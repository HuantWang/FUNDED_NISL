-----label-----
1
-----code-----
static int
_TIFFVGetField(TIFF* tif, uint32 tag, va_list ap)
{
	TIFFDirectory* td = &tif->tif_dir;
	int ret_val = 1;
	uint32 standard_tag = tag;
	const TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);
	
	/*
	 * We want to force the custom code to be used for custom
	 * fields even if the tag happens to match a well known 
	 * one - important for reinterpreted handling of standard
	 * tag values in custom directories (ie. EXIF) 
	 */
	if (fip->field_bit == FIELD_CUSTOM) {
		standard_tag = 0;
	}

	switch (standard_tag) {
		case TIFFTAG_SUBFILETYPE:
			*va_arg(ap, uint32*) = td->td_subfiletype;
			break;
		case TIFFTAG_IMAGEWIDTH:
			*va_arg(ap, uint32*) = td->td_imagewidth;
			break;
		case TIFFTAG_IMAGELENGTH:
			*va_arg(ap, uint32*) = td->td_imagelength;
			break;
		case TIFFTAG_BITSPERSAMPLE:
			*va_arg(ap, uint16*) = td->td_bitspersample;
			break;
		case TIFFTAG_COMPRESSION:
			*va_arg(ap, uint16*) = td->td_compression;
			break;
		case TIFFTAG_PHOTOMETRIC:
			*va_arg(ap, uint16*) = td->td_photometric;
			break;
		case TIFFTAG_THRESHHOLDING:
			*va_arg(ap, uint16*) = td->td_threshholding;
			break;
		case TIFFTAG_FILLORDER:
			*va_arg(ap, uint16*) = td->td_fillorder;
			break;
		case TIFFTAG_ORIENTATION:
			*va_arg(ap, uint16*) = td->td_orientation;
			break;
		case TIFFTAG_SAMPLESPERPIXEL:
			*va_arg(ap, uint16*) = td->td_samplesperpixel;
			break;
		case TIFFTAG_ROWSPERSTRIP:
			*va_arg(ap, uint32*) = td->td_rowsperstrip;
			break;
		case TIFFTAG_MINSAMPLEVALUE:
			*va_arg(ap, uint16*) = td->td_minsamplevalue;
			break;
		case TIFFTAG_MAXSAMPLEVALUE:
			*va_arg(ap, uint16*) = td->td_maxsamplevalue;
			break;
		case TIFFTAG_SMINSAMPLEVALUE:
			if (tif->tif_flags & TIFF_PERSAMPLE)
				*va_arg(ap, double**) = td->td_sminsamplevalue;
			else
			{
				/* libtiff historially treats this as a single value. */
				uint16 i;
				double v = td->td_sminsamplevalue[0];
				for (i=1; i < td->td_samplesperpixel; ++i)
					if( td->td_sminsamplevalue[i] < v )
						v = td->td_sminsamplevalue[i];
				*va_arg(ap, double*) = v;
			}
			break;
		case TIFFTAG_SMAXSAMPLEVALUE:
			if (tif->tif_flags & TIFF_PERSAMPLE)
				*va_arg(ap, double**) = td->td_smaxsamplevalue;
			else
			{
				/* libtiff historially treats this as a single value. */
				uint16 i;
				double v = td->td_smaxsamplevalue[0];
				for (i=1; i < td->td_samplesperpixel; ++i)
					if( td->td_smaxsamplevalue[i] > v )
						v = td->td_smaxsamplevalue[i];
				*va_arg(ap, double*) = v;
			}
			break;
		case TIFFTAG_XRESOLUTION:
			*va_arg(ap, float*) = td->td_xresolution;
			break;
		case TIFFTAG_YRESOLUTION:
			*va_arg(ap, float*) = td->td_yresolution;
			break;
		case TIFFTAG_PLANARCONFIG:
			*va_arg(ap, uint16*) = td->td_planarconfig;
			break;
		case TIFFTAG_XPOSITION:
			*va_arg(ap, float*) = td->td_xposition;
			break;
		case TIFFTAG_YPOSITION:
			*va_arg(ap, float*) = td->td_yposition;
			break;
		case TIFFTAG_RESOLUTIONUNIT:
			*va_arg(ap, uint16*) = td->td_resolutionunit;
			break;
		case TIFFTAG_PAGENUMBER:
			*va_arg(ap, uint16*) = td->td_pagenumber[0];
			*va_arg(ap, uint16*) = td->td_pagenumber[1];
			break;
		case TIFFTAG_HALFTONEHINTS:
			*va_arg(ap, uint16*) = td->td_halftonehints[0];
			*va_arg(ap, uint16*) = td->td_halftonehints[1];
			break;
		case TIFFTAG_COLORMAP:
			*va_arg(ap, uint16**) = td->td_colormap[0];
			*va_arg(ap, uint16**) = td->td_colormap[1];
			*va_arg(ap, uint16**) = td->td_colormap[2];
			break;
		case TIFFTAG_STRIPOFFSETS:
		case TIFFTAG_TILEOFFSETS:
			_TIFFFillStriles( tif );
			*va_arg(ap, uint64**) = td->td_stripoffset;
			break;
		case TIFFTAG_STRIPBYTECOUNTS:
		case TIFFTAG_TILEBYTECOUNTS:
			_TIFFFillStriles( tif );
			*va_arg(ap, uint64**) = td->td_stripbytecount;
			break;
		case TIFFTAG_MATTEING:
			*va_arg(ap, uint16*) =
			    (td->td_extrasamples == 1 &&
			    td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA);
			break;
		case TIFFTAG_EXTRASAMPLES:
			*va_arg(ap, uint16*) = td->td_extrasamples;
			*va_arg(ap, uint16**) = td->td_sampleinfo;
			break;
		case TIFFTAG_TILEWIDTH:
			*va_arg(ap, uint32*) = td->td_tilewidth;
			break;
		case TIFFTAG_TILELENGTH:
			*va_arg(ap, uint32*) = td->td_tilelength;
			break;
		case TIFFTAG_TILEDEPTH:
			*va_arg(ap, uint32*) = td->td_tiledepth;
			break;
		case TIFFTAG_DATATYPE:
			switch (td->td_sampleformat) {
				case SAMPLEFORMAT_UINT:
					*va_arg(ap, uint16*) = DATATYPE_UINT;
					break;
				case SAMPLEFORMAT_INT:
					*va_arg(ap, uint16*) = DATATYPE_INT;
					break;
				case SAMPLEFORMAT_IEEEFP:
					*va_arg(ap, uint16*) = DATATYPE_IEEEFP;
					break;
				case SAMPLEFORMAT_VOID:
					*va_arg(ap, uint16*) = DATATYPE_VOID;
					break;
			}
			break;
		case TIFFTAG_SAMPLEFORMAT:
			*va_arg(ap, uint16*) = td->td_sampleformat;
			break;
		case TIFFTAG_IMAGEDEPTH:
			*va_arg(ap, uint32*) = td->td_imagedepth;
			break;
		case TIFFTAG_SUBIFD:
			*va_arg(ap, uint16*) = td->td_nsubifd;
			*va_arg(ap, uint64**) = td->td_subifd;
			break;
		case TIFFTAG_YCBCRPOSITIONING:
			*va_arg(ap, uint16*) = td->td_ycbcrpositioning;
			break;
		case TIFFTAG_YCBCRSUBSAMPLING:
			*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[0];
			*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[1];
			break;
		case TIFFTAG_TRANSFERFUNCTION:
			*va_arg(ap, uint16**) = td->td_transferfunction[0];
			if (td->td_samplesperpixel - td->td_extrasamples > 1) {
				*va_arg(ap, uint16**) = td->td_transferfunction[1];
				*va_arg(ap, uint16**) = td->td_transferfunction[2];
			}
			break;
		case TIFFTAG_REFERENCEBLACKWHITE:
			*va_arg(ap, float**) = td->td_refblackwhite;
			break;
		case TIFFTAG_INKNAMES:
			*va_arg(ap, char**) = td->td_inknames;
			break;
		default:
			{
				int i;

				/*
				 * This can happen if multiple images are open
				 * with different codecs which have private
				 * tags.  The global tag information table may
				 * then have tags that are valid for one file
				 * but not the other. If the client tries to
				 * get a tag that is not valid for the image's
				 * codec then we'll arrive here.
				 */
				if( fip == NULL || fip->field_bit != FIELD_CUSTOM )
				{
					TIFFErrorExt(tif->tif_clientdata, "_TIFFVGetField",
					    "%s: Invalid %stag \"%s\" "
					    "(not supported by codec)",
					    tif->tif_name,
					    isPseudoTag(tag) ? "pseudo-" : "",
					    fip ? fip->field_name : "Unknown");
					ret_val = 0;
					break;
				}

				/*
				 * Do we have a custom value?
				 */
				ret_val = 0;
				for (i = 0; i < td->td_customValueCount; i++) {
					TIFFTagValue *tv = td->td_customValues + i;

					if (tv->info->field_tag != tag)
						continue;

					if (fip->field_passcount) {
						if (fip->field_readcount == TIFF_VARIABLE2)
							*va_arg(ap, uint32*) = (uint32)tv->count;
						else  /* Assume TIFF_VARIABLE */
							*va_arg(ap, uint16*) = (uint16)tv->count;
						*va_arg(ap, void **) = tv->value;
						ret_val = 1;
					} else if (fip->field_tag == TIFFTAG_DOTRANGE
						   && strcmp(fip->field_name,"DotRange") == 0) {
						/* TODO: This is an evil exception and should not have been
						   handled this way ... likely best if we move it into
						   the directory structure with an explicit field in 
						   libtiff 4.1 and assign it a FIELD_ value */
						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[0];
						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[1];
						ret_val = 1;
					} else {
						if (fip->field_type == TIFF_ASCII
						    || fip->field_readcount == TIFF_VARIABLE
						    || fip->field_readcount == TIFF_VARIABLE2
						    || fip->field_readcount == TIFF_SPP
						    || tv->count > 1) {
							*va_arg(ap, void **) = tv->value;
							ret_val = 1;
						} else {
							char *val = (char *)tv->value;
							assert( tv->count == 1 );
							switch (fip->field_type) {
							case TIFF_BYTE:
							case TIFF_UNDEFINED:
								*va_arg(ap, uint8*) =
									*(uint8 *)val;
								ret_val = 1;
								break;
							case TIFF_SBYTE:
								*va_arg(ap, int8*) =
									*(int8 *)val;
								ret_val = 1;
								break;
							case TIFF_SHORT:
								*va_arg(ap, uint16*) =
									*(uint16 *)val;
								ret_val = 1;
								break;
							case TIFF_SSHORT:
								*va_arg(ap, int16*) =
									*(int16 *)val;
								ret_val = 1;
								break;
							case TIFF_LONG:
							case TIFF_IFD:
								*va_arg(ap, uint32*) =
									*(uint32 *)val;
								ret_val = 1;
								break;
							case TIFF_SLONG:
								*va_arg(ap, int32*) =
									*(int32 *)val;
								ret_val = 1;
								break;
							case TIFF_LONG8:
							case TIFF_IFD8:
								*va_arg(ap, uint64*) =
									*(uint64 *)val;
								ret_val = 1;
								break;
							case TIFF_SLONG8:
								*va_arg(ap, int64*) =
									*(int64 *)val;
								ret_val = 1;
								break;
							case TIFF_RATIONAL:
							case TIFF_SRATIONAL:
							case TIFF_FLOAT:
								*va_arg(ap, float*) =
									*(float *)val;
								ret_val = 1;
								break;
							case TIFF_DOUBLE:
								*va_arg(ap, double*) =
									*(double *)val;
								ret_val = 1;
								break;
							default:
								ret_val = 0;
								break;
							}
						}
					}
					break;
				}
			}
	}
	return(ret_val);
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
3,7
5,6
5,7
6,7
8,9
8,10
11,12
11,13
12,13
14,15
16,17
16,18
17,18
19,20
21,22
21,23
21,24
21,25
21,26
21,27
21,28
22,23
23,24
23,25
24,25
26,27
26,28
26,29
29,30
30,31
31,32
31,33
32,33
35,36
36,37
36,38
38,39
38,40
40,41
42,43
43,44
43,45
44,45
46,47
46,48
48,49
49,50
51,52
52,53
52,54
53,54
55,56
55,57
55,58
58,59
59,60
59,61
59,62
59,63
60,61
62,63
64,65
66,67
68,69
68,70
69,70
69,71
70,71
70,72
71,72
74,75
76,77
77,78
78,79
78,80
79,80
82,83
82,84
83,84
85,86
85,87
85,88
85,89
85,90
85,91
85,92
85,93
85,94
85,95
85,96
85,97
85,98
85,99
85,100
85,101
85,102
85,103
85,104
85,105
85,106
85,107
85,108
85,109
85,110
85,111
85,112
85,113
85,114
85,115
85,116
85,117
85,118
85,119
85,120
85,121
85,122
85,123
85,124
85,125
85,126
85,127
85,128
85,129
85,130
85,131
85,132
85,133
85,134
85,135
85,136
85,137
85,138
85,139
85,140
85,141
85,142
85,143
85,144
85,145
85,146
85,147
85,148
85,149
85,150
85,151
85,152
85,153
85,154
85,155
85,156
85,157
85,158
85,159
85,160
85,161
85,162
85,163
85,164
85,165
85,166
85,167
85,168
85,169
85,170
85,171
85,172
85,173
85,174
85,175
85,176
85,177
85,178
85,179
85,180
85,181
85,182
85,183
85,184
85,185
85,186
85,187
85,188
85,189
85,190
85,191
85,192
85,193
85,194
85,195
85,196
85,197
85,198
85,199
85,200
85,201
85,202
85,203
85,204
85,205
85,206
85,207
85,208
85,209
85,210
85,211
85,212
85,213
85,214
85,215
85,216
85,217
85,218
85,219
85,220
85,221
86,87
87,88
89,90
91,92
92,93
94,95
96,97
97,98
99,100
101,102
102,103
104,105
106,107
107,108
109,110
111,112
112,113
114,115
116,117
117,118
119,120
121,122
122,123
124,125
126,127
127,128
129,130
131,132
132,133
134,135
136,137
137,138
139,140
141,142
142,143
144,145
146,147
147,148
149,150
151,152
152,153
154,155
155,156
157,158
158,159
160,161
161,162
163,164
164,165
166,167
168,169
169,170
171,172
173,174
174,175
176,177
178,179
179,180
181,182
183,184
184,185
186,187
188,189
189,190
191,192
193,194
194,195
196,197
197,198
199,200
200,201
202,203
203,204
205,206
206,207
208,209
209,210
210,211
212,213
213,214
215,216
216,217
218,219
219,220
219,221
220,221
222,223
224,225
226,227
227,228
229,230
230,231
232,233
233,234
233,235
234,235
236,237
238,239
240,241
241,242
243,244
245,246
246,247
248,249
249,250
251,252
252,253
254,255
256,257
257,258
259,260
261,262
262,263
264,265
266,267
267,268
269,270
269,271
270,271
270,272
271,272
274,275
274,276
274,277
274,278
274,279
274,280
274,281
274,282
274,283
274,284
274,285
274,286
275,276
276,277
278,279
280,281
281,282
283,284
285,286
286,287
288,289
290,291
291,292
293,294
296,297
297,298
299,300
301,302
302,303
304,305
306,307
307,308
309,310
310,311
312,313
313,314
315,316
317,318
318,319
320,321
321,322
323,324
324,325
326,327
327,328
327,329
328,329
328,330
329,330
329,331
330,331
330,332
331,332
334,335
334,336
335,336
339,340
339,341
340,341
341,342
343,344
344,345
346,347
348,349
349,350
351,352
354,355
354,356
354,357
354,358
355,356
356,357
356,358
358,359
360,361
360,362
361,362
361,363
362,363
362,364
363,364
365,366
367,368
367,369
368,369
368,370
369,370
372,373
374,375
374,376
374,377
375,376
376,377
376,378
376,379
376,380
376,381
376,382
376,383
377,378
379,380
379,381
380,381
385,386
385,387
386,387
389,390
389,391
389,392
390,391
390,392
391,392
393,394
397,398
397,399
397,400
398,399
400,401
400,402
401,402
405,406
406,407
406,408
407,408
411,412
412,413
412,414
413,414
416,417
416,418
416,419
416,420
417,418
418,419
418,420
419,420
422,423
422,424
423,424
425,426
425,427
426,427
429,430
430,431
432,433
432,434
432,435
432,436
433,434
434,435
434,436
435,436
437,438
437,439
437,440
440,441
441,442
441,443
442,443
442,444
443,444
446,447
448,449
448,450
449,450
449,451
450,451
450,452
451,452
451,453
452,453
456,457
459,460
459,461
459,462
460,461
460,462
461,462
464,465
464,466
464,467
464,468
465,466
466,467
467,468
468,469
469,470
469,471
470,471
473,474
473,475
473,476
474,475
474,476
475,476
475,477
476,477
476,478
477,478
480,481
482,483
482,484
483,484
483,485
483,486
484,485
486,487
486,488
487,488
492,493
492,494
492,495
493,494
494,495
495,496
496,497
496,498
497,498
500,501
501,502
501,503
501,504
502,503
502,504
503,504
503,505
504,505
504,506
505,506
505,507
506,507
506,508
507,508
507,509
508,509
511,512
513,514
513,515
514,515
514,516
515,516
518,519
520,521
520,522
521,522
521,523
522,523
525,526
527,528
527,529
528,529
528,530
529,530
532,533
534,535
534,536
535,536
535,537
536,537
540,541
540,542
541,542
542,543
543,544
543,545
544,545
547,548
547,549
547,550
548,549
549,550
549,551
551,552
551,553
551,554
554,555
555,556
555,557
556,557
556,558
558,559
560,561
560,562
561,562
564,565
565,566
565,567
566,567
568,569
568,570
569,570
569,571
570,571
574,575
574,576
575,576
575,577
576,577
579,580
579,581
579,582
579,583
579,584
579,585
579,586
579,587
579,588
579,589
579,590
579,591
579,592
579,593
579,594
579,595
579,596
579,597
579,598
579,599
579,600
579,601
579,602
579,603
579,604
579,605
579,606
579,607
579,608
579,609
579,610
579,611
579,612
579,613
579,614
579,615
579,616
579,617
579,618
579,619
579,620
579,621
579,622
579,623
579,624
579,625
579,626
579,627
580,581
581,582
583,584
584,585
586,587
587,588
588,589
588,590
589,590
593,594
594,595
596,597
597,598
598,599
598,600
599,600
603,604
604,605
606,607
607,608
608,609
608,610
609,610
613,614
614,615
616,617
617,618
618,619
618,620
619,620
623,624
624,625
626,627
627,628
629,630
630,631
631,632
631,633
632,633
636,637
637,638
639,640
640,641
641,642
641,643
642,643
646,647
647,648
649,650
650,651
652,653
653,654
654,655
654,656
655,656
659,660
660,661
662,663
663,664
664,665
664,666
665,666
669,670
670,671
672,673
673,674
675,676
676,677
678,679
679,680
680,681
680,682
681,682
685,686
686,687
688,689
689,690
690,691
690,692
691,692
696,697
697,698
697,699
698,699
703,704
704,705
705,706
-----nextToken-----
2,4,7,9,10,13,15,18,20,25,27,28,33,34,37,39,41,45,47,50,54,56,57,61,63,65,67,72,73,75,80,81,84,88,90,93,95,98,100,103,105,108,110,113,115,118,120,123,125,128,130,133,135,138,140,143,145,148,150,153,156,159,162,165,167,170,172,175,177,180,182,185,187,190,192,195,198,201,204,207,211,214,217,221,223,225,228,231,235,237,239,242,244,247,250,253,255,258,260,263,265,268,272,273,277,279,282,284,287,289,292,294,295,298,300,303,305,308,311,314,316,319,322,325,332,333,336,337,338,342,345,347,350,352,353,357,359,364,366,370,371,373,378,381,382,383,384,387,388,392,394,395,396,399,402,403,404,408,409,410,414,415,420,421,424,427,428,431,436,438,439,444,445,447,453,454,455,457,458,462,463,471,472,478,479,481,485,488,489,490,491,498,499,509,510,512,516,517,519,523,524,526,530,531,533,537,538,539,545,546,550,552,553,557,559,562,563,567,571,572,573,577,578,582,585,590,591,592,595,600,601,602,605,610,611,612,615,620,621,622,625,628,633,634,635,638,643,644,645,648,651,656,657,658,661,666,667,668,671,674,677,682,683,684,687,692,693,694,695,699,700,701,702,706
-----computeFrom-----
69,70
69,71
78,79
78,80
328,329
328,330
329,330
329,331
361,362
361,363
362,363
362,364
367,368
367,369
406,407
406,408
412,413
412,414
418,419
418,420
422,423
422,424
441,442
441,443
449,450
449,451
469,470
469,471
474,475
474,476
475,476
475,477
482,483
482,484
496,497
496,498
502,503
502,504
503,504
503,505
504,505
504,506
505,506
505,507
506,507
506,508
513,514
513,515
520,521
520,522
527,528
527,529
534,535
534,536
543,544
543,545
568,569
568,570
588,589
588,590
598,599
598,600
608,609
608,610
618,619
618,620
631,632
631,633
641,642
641,643
654,655
654,656
664,665
664,666
680,681
680,682
690,691
690,692
697,698
697,699
-----guardedBy-----
370,402
-----guardedByNegation-----
488,577
537,571
538,572
530,577
510,578
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;UnaryExpression;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;SwitchStatement;IdExpression;Name;CompoundStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;ProblemStatement;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;SwitchStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;IfStatement;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ProblemStatement;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;DefaultStatement;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;ConditionalExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;ConditionalExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BreakStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ContinueStatement;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ProblemStatement;ProblemStatement;ProblemStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;CompoundStatement;ProblemStatement;ProblemStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ProblemStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;SwitchStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;ProblemStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;ProblemStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;ProblemStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;ProblemStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BreakStatement;DefaultStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BreakStatement;BreakStatement;ReturnStatement;UnaryExpression;IdExpression;Name;
-----ast_node-----
static int_TIFFVGetField(TIFF* tif, uint32 tag, va_list ap){	TIFFDirectory* td = &tif->tif_dir;	int ret_val = 1;	uint32 standard_tag = tag;	const TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);		/*	 * We want to force the custom code to be used for custom	 * fields even if the tag happens to match a well known 	 * one - important for reinterpreted handling of standard	 * tag values in custom directories (ie. EXIF) 	 */	if (fip->field_bit == FIELD_CUSTOM) {		standard_tag = 0;	}	switch (standard_tag) {		case TIFFTAG_SUBFILETYPE:			*va_arg(ap, uint32*) = td->td_subfiletype;			break;		case TIFFTAG_IMAGEWIDTH:			*va_arg(ap, uint32*) = td->td_imagewidth;			break;		case TIFFTAG_IMAGELENGTH:			*va_arg(ap, uint32*) = td->td_imagelength;			break;		case TIFFTAG_BITSPERSAMPLE:			*va_arg(ap, uint16*) = td->td_bitspersample;			break;		case TIFFTAG_COMPRESSION:			*va_arg(ap, uint16*) = td->td_compression;			break;		case TIFFTAG_PHOTOMETRIC:			*va_arg(ap, uint16*) = td->td_photometric;			break;		case TIFFTAG_THRESHHOLDING:			*va_arg(ap, uint16*) = td->td_threshholding;			break;		case TIFFTAG_FILLORDER:			*va_arg(ap, uint16*) = td->td_fillorder;			break;		case TIFFTAG_ORIENTATION:			*va_arg(ap, uint16*) = td->td_orientation;			break;		case TIFFTAG_SAMPLESPERPIXEL:			*va_arg(ap, uint16*) = td->td_samplesperpixel;			break;		case TIFFTAG_ROWSPERSTRIP:			*va_arg(ap, uint32*) = td->td_rowsperstrip;			break;		case TIFFTAG_MINSAMPLEVALUE:			*va_arg(ap, uint16*) = td->td_minsamplevalue;			break;		case TIFFTAG_MAXSAMPLEVALUE:			*va_arg(ap, uint16*) = td->td_maxsamplevalue;			break;		case TIFFTAG_SMINSAMPLEVALUE:			if (tif->tif_flags & TIFF_PERSAMPLE)				*va_arg(ap, double**) = td->td_sminsamplevalue;			else			{				/* libtiff historially treats this as a single value. */				uint16 i;				double v = td->td_sminsamplevalue[0];				for (i=1; i < td->td_samplesperpixel; ++i)					if( td->td_sminsamplevalue[i] < v )						v = td->td_sminsamplevalue[i];				*va_arg(ap, double*) = v;			}			break;		case TIFFTAG_SMAXSAMPLEVALUE:			if (tif->tif_flags & TIFF_PERSAMPLE)				*va_arg(ap, double**) = td->td_smaxsamplevalue;			else			{				/* libtiff historially treats this as a single value. */				uint16 i;				double v = td->td_smaxsamplevalue[0];				for (i=1; i < td->td_samplesperpixel; ++i)					if( td->td_smaxsamplevalue[i] > v )						v = td->td_smaxsamplevalue[i];				*va_arg(ap, double*) = v;			}			break;		case TIFFTAG_XRESOLUTION:			*va_arg(ap, float*) = td->td_xresolution;			break;		case TIFFTAG_YRESOLUTION:			*va_arg(ap, float*) = td->td_yresolution;			break;		case TIFFTAG_PLANARCONFIG:			*va_arg(ap, uint16*) = td->td_planarconfig;			break;		case TIFFTAG_XPOSITION:			*va_arg(ap, float*) = td->td_xposition;			break;		case TIFFTAG_YPOSITION:			*va_arg(ap, float*) = td->td_yposition;			break;		case TIFFTAG_RESOLUTIONUNIT:			*va_arg(ap, uint16*) = td->td_resolutionunit;			break;		case TIFFTAG_PAGENUMBER:			*va_arg(ap, uint16*) = td->td_pagenumber[0];			*va_arg(ap, uint16*) = td->td_pagenumber[1];			break;		case TIFFTAG_HALFTONEHINTS:			*va_arg(ap, uint16*) = td->td_halftonehints[0];			*va_arg(ap, uint16*) = td->td_halftonehints[1];			break;		case TIFFTAG_COLORMAP:			*va_arg(ap, uint16**) = td->td_colormap[0];			*va_arg(ap, uint16**) = td->td_colormap[1];			*va_arg(ap, uint16**) = td->td_colormap[2];			break;		case TIFFTAG_STRIPOFFSETS:		case TIFFTAG_TILEOFFSETS:			_TIFFFillStriles( tif );			*va_arg(ap, uint64**) = td->td_stripoffset;			break;		case TIFFTAG_STRIPBYTECOUNTS:		case TIFFTAG_TILEBYTECOUNTS:			_TIFFFillStriles( tif );			*va_arg(ap, uint64**) = td->td_stripbytecount;			break;		case TIFFTAG_MATTEING:			*va_arg(ap, uint16*) =			    (td->td_extrasamples == 1 &&			    td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA);			break;		case TIFFTAG_EXTRASAMPLES:			*va_arg(ap, uint16*) = td->td_extrasamples;			*va_arg(ap, uint16**) = td->td_sampleinfo;			break;		case TIFFTAG_TILEWIDTH:			*va_arg(ap, uint32*) = td->td_tilewidth;			break;		case TIFFTAG_TILELENGTH:			*va_arg(ap, uint32*) = td->td_tilelength;			break;		case TIFFTAG_TILEDEPTH:			*va_arg(ap, uint32*) = td->td_tiledepth;			break;		case TIFFTAG_DATATYPE:			switch (td->td_sampleformat) {				case SAMPLEFORMAT_UINT:					*va_arg(ap, uint16*) = DATATYPE_UINT;					break;				case SAMPLEFORMAT_INT:					*va_arg(ap, uint16*) = DATATYPE_INT;					break;				case SAMPLEFORMAT_IEEEFP:					*va_arg(ap, uint16*) = DATATYPE_IEEEFP;					break;				case SAMPLEFORMAT_VOID:					*va_arg(ap, uint16*) = DATATYPE_VOID;					break;			}			break;		case TIFFTAG_SAMPLEFORMAT:			*va_arg(ap, uint16*) = td->td_sampleformat;			break;		case TIFFTAG_IMAGEDEPTH:			*va_arg(ap, uint32*) = td->td_imagedepth;			break;		case TIFFTAG_SUBIFD:			*va_arg(ap, uint16*) = td->td_nsubifd;			*va_arg(ap, uint64**) = td->td_subifd;			break;		case TIFFTAG_YCBCRPOSITIONING:			*va_arg(ap, uint16*) = td->td_ycbcrpositioning;			break;		case TIFFTAG_YCBCRSUBSAMPLING:			*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[0];			*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[1];			break;		case TIFFTAG_TRANSFERFUNCTION:			*va_arg(ap, uint16**) = td->td_transferfunction[0];			if (td->td_samplesperpixel - td->td_extrasamples > 1) {				*va_arg(ap, uint16**) = td->td_transferfunction[1];				*va_arg(ap, uint16**) = td->td_transferfunction[2];			}			break;		case TIFFTAG_REFERENCEBLACKWHITE:			*va_arg(ap, float**) = td->td_refblackwhite;			break;		case TIFFTAG_INKNAMES:			*va_arg(ap, char**) = td->td_inknames;			break;		default:			{				int i;				/*				 * This can happen if multiple images are open				 * with different codecs which have private				 * tags.  The global tag information table may				 * then have tags that are valid for one file				 * but not the other. If the client tries to				 * get a tag that is not valid for the image's				 * codec then we'll arrive here.				 */				if( fip == NULL || fip->field_bit != FIELD_CUSTOM )				{					TIFFErrorExt(tif->tif_clientdata, "_TIFFVGetField",					    "%s: Invalid %stag \"%s\" "					    "(not supported by codec)",					    tif->tif_name,					    isPseudoTag(tag) ? "pseudo-" : "",					    fip ? fip->field_name : "Unknown");					ret_val = 0;					break;				}				/*				 * Do we have a custom value?				 */				ret_val = 0;				for (i = 0; i < td->td_customValueCount; i++) {					TIFFTagValue *tv = td->td_customValues + i;					if (tv->info->field_tag != tag)						continue;					if (fip->field_passcount) {						if (fip->field_readcount == TIFF_VARIABLE2)							*va_arg(ap, uint32*) = (uint32)tv->count;						else  /* Assume TIFF_VARIABLE */							*va_arg(ap, uint16*) = (uint16)tv->count;						*va_arg(ap, void **) = tv->value;						ret_val = 1;					} else if (fip->field_tag == TIFFTAG_DOTRANGE						   && strcmp(fip->field_name,"DotRange") == 0) {						/* TODO: This is an evil exception and should not have been						   handled this way ... likely best if we move it into						   the directory structure with an explicit field in 						   libtiff 4.1 and assign it a FIELD_ value */						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[0];						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[1];						ret_val = 1;					} else {						if (fip->field_type == TIFF_ASCII						    || fip->field_readcount == TIFF_VARIABLE						    || fip->field_readcount == TIFF_VARIABLE2						    || fip->field_readcount == TIFF_SPP						    || tv->count > 1) {							*va_arg(ap, void **) = tv->value;							ret_val = 1;						} else {							char *val = (char *)tv->value;							assert( tv->count == 1 );							switch (fip->field_type) {							case TIFF_BYTE:							case TIFF_UNDEFINED:								*va_arg(ap, uint8*) =									*(uint8 *)val;								ret_val = 1;								break;							case TIFF_SBYTE:								*va_arg(ap, int8*) =									*(int8 *)val;								ret_val = 1;								break;							case TIFF_SHORT:								*va_arg(ap, uint16*) =									*(uint16 *)val;								ret_val = 1;								break;							case TIFF_SSHORT:								*va_arg(ap, int16*) =									*(int16 *)val;								ret_val = 1;								break;							case TIFF_LONG:							case TIFF_IFD:								*va_arg(ap, uint32*) =									*(uint32 *)val;								ret_val = 1;								break;							case TIFF_SLONG:								*va_arg(ap, int32*) =									*(int32 *)val;								ret_val = 1;								break;							case TIFF_LONG8:							case TIFF_IFD8:								*va_arg(ap, uint64*) =									*(uint64 *)val;								ret_val = 1;								break;							case TIFF_SLONG8:								*va_arg(ap, int64*) =									*(int64 *)val;								ret_val = 1;								break;							case TIFF_RATIONAL:							case TIFF_SRATIONAL:							case TIFF_FLOAT:								*va_arg(ap, float*) =									*(float *)val;								ret_val = 1;								break;							case TIFF_DOUBLE:								*va_arg(ap, double*) =									*(double *)val;								ret_val = 1;								break;							default:								ret_val = 0;								break;							}						}					}					break;				}			}	}	return(ret_val);}
static int
_TIFFVGetField(TIFF* tif, uint32 tag, va_list ap)
_TIFFVGetField
TIFF* tif
TIFF
TIFF
* tif
*
tif
uint32 tag
uint32
uint32
tag
tag
va_list ap
va_list
va_list
ap
ap
{	TIFFDirectory* td = &tif->tif_dir;	int ret_val = 1;	uint32 standard_tag = tag;	const TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);		/*	 * We want to force the custom code to be used for custom	 * fields even if the tag happens to match a well known 	 * one - important for reinterpreted handling of standard	 * tag values in custom directories (ie. EXIF) 	 */	if (fip->field_bit == FIELD_CUSTOM) {		standard_tag = 0;	}	switch (standard_tag) {		case TIFFTAG_SUBFILETYPE:			*va_arg(ap, uint32*) = td->td_subfiletype;			break;		case TIFFTAG_IMAGEWIDTH:			*va_arg(ap, uint32*) = td->td_imagewidth;			break;		case TIFFTAG_IMAGELENGTH:			*va_arg(ap, uint32*) = td->td_imagelength;			break;		case TIFFTAG_BITSPERSAMPLE:			*va_arg(ap, uint16*) = td->td_bitspersample;			break;		case TIFFTAG_COMPRESSION:			*va_arg(ap, uint16*) = td->td_compression;			break;		case TIFFTAG_PHOTOMETRIC:			*va_arg(ap, uint16*) = td->td_photometric;			break;		case TIFFTAG_THRESHHOLDING:			*va_arg(ap, uint16*) = td->td_threshholding;			break;		case TIFFTAG_FILLORDER:			*va_arg(ap, uint16*) = td->td_fillorder;			break;		case TIFFTAG_ORIENTATION:			*va_arg(ap, uint16*) = td->td_orientation;			break;		case TIFFTAG_SAMPLESPERPIXEL:			*va_arg(ap, uint16*) = td->td_samplesperpixel;			break;		case TIFFTAG_ROWSPERSTRIP:			*va_arg(ap, uint32*) = td->td_rowsperstrip;			break;		case TIFFTAG_MINSAMPLEVALUE:			*va_arg(ap, uint16*) = td->td_minsamplevalue;			break;		case TIFFTAG_MAXSAMPLEVALUE:			*va_arg(ap, uint16*) = td->td_maxsamplevalue;			break;		case TIFFTAG_SMINSAMPLEVALUE:			if (tif->tif_flags & TIFF_PERSAMPLE)				*va_arg(ap, double**) = td->td_sminsamplevalue;			else			{				/* libtiff historially treats this as a single value. */				uint16 i;				double v = td->td_sminsamplevalue[0];				for (i=1; i < td->td_samplesperpixel; ++i)					if( td->td_sminsamplevalue[i] < v )						v = td->td_sminsamplevalue[i];				*va_arg(ap, double*) = v;			}			break;		case TIFFTAG_SMAXSAMPLEVALUE:			if (tif->tif_flags & TIFF_PERSAMPLE)				*va_arg(ap, double**) = td->td_smaxsamplevalue;			else			{				/* libtiff historially treats this as a single value. */				uint16 i;				double v = td->td_smaxsamplevalue[0];				for (i=1; i < td->td_samplesperpixel; ++i)					if( td->td_smaxsamplevalue[i] > v )						v = td->td_smaxsamplevalue[i];				*va_arg(ap, double*) = v;			}			break;		case TIFFTAG_XRESOLUTION:			*va_arg(ap, float*) = td->td_xresolution;			break;		case TIFFTAG_YRESOLUTION:			*va_arg(ap, float*) = td->td_yresolution;			break;		case TIFFTAG_PLANARCONFIG:			*va_arg(ap, uint16*) = td->td_planarconfig;			break;		case TIFFTAG_XPOSITION:			*va_arg(ap, float*) = td->td_xposition;			break;		case TIFFTAG_YPOSITION:			*va_arg(ap, float*) = td->td_yposition;			break;		case TIFFTAG_RESOLUTIONUNIT:			*va_arg(ap, uint16*) = td->td_resolutionunit;			break;		case TIFFTAG_PAGENUMBER:			*va_arg(ap, uint16*) = td->td_pagenumber[0];			*va_arg(ap, uint16*) = td->td_pagenumber[1];			break;		case TIFFTAG_HALFTONEHINTS:			*va_arg(ap, uint16*) = td->td_halftonehints[0];			*va_arg(ap, uint16*) = td->td_halftonehints[1];			break;		case TIFFTAG_COLORMAP:			*va_arg(ap, uint16**) = td->td_colormap[0];			*va_arg(ap, uint16**) = td->td_colormap[1];			*va_arg(ap, uint16**) = td->td_colormap[2];			break;		case TIFFTAG_STRIPOFFSETS:		case TIFFTAG_TILEOFFSETS:			_TIFFFillStriles( tif );			*va_arg(ap, uint64**) = td->td_stripoffset;			break;		case TIFFTAG_STRIPBYTECOUNTS:		case TIFFTAG_TILEBYTECOUNTS:			_TIFFFillStriles( tif );			*va_arg(ap, uint64**) = td->td_stripbytecount;			break;		case TIFFTAG_MATTEING:			*va_arg(ap, uint16*) =			    (td->td_extrasamples == 1 &&			    td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA);			break;		case TIFFTAG_EXTRASAMPLES:			*va_arg(ap, uint16*) = td->td_extrasamples;			*va_arg(ap, uint16**) = td->td_sampleinfo;			break;		case TIFFTAG_TILEWIDTH:			*va_arg(ap, uint32*) = td->td_tilewidth;			break;		case TIFFTAG_TILELENGTH:			*va_arg(ap, uint32*) = td->td_tilelength;			break;		case TIFFTAG_TILEDEPTH:			*va_arg(ap, uint32*) = td->td_tiledepth;			break;		case TIFFTAG_DATATYPE:			switch (td->td_sampleformat) {				case SAMPLEFORMAT_UINT:					*va_arg(ap, uint16*) = DATATYPE_UINT;					break;				case SAMPLEFORMAT_INT:					*va_arg(ap, uint16*) = DATATYPE_INT;					break;				case SAMPLEFORMAT_IEEEFP:					*va_arg(ap, uint16*) = DATATYPE_IEEEFP;					break;				case SAMPLEFORMAT_VOID:					*va_arg(ap, uint16*) = DATATYPE_VOID;					break;			}			break;		case TIFFTAG_SAMPLEFORMAT:			*va_arg(ap, uint16*) = td->td_sampleformat;			break;		case TIFFTAG_IMAGEDEPTH:			*va_arg(ap, uint32*) = td->td_imagedepth;			break;		case TIFFTAG_SUBIFD:			*va_arg(ap, uint16*) = td->td_nsubifd;			*va_arg(ap, uint64**) = td->td_subifd;			break;		case TIFFTAG_YCBCRPOSITIONING:			*va_arg(ap, uint16*) = td->td_ycbcrpositioning;			break;		case TIFFTAG_YCBCRSUBSAMPLING:			*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[0];			*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[1];			break;		case TIFFTAG_TRANSFERFUNCTION:			*va_arg(ap, uint16**) = td->td_transferfunction[0];			if (td->td_samplesperpixel - td->td_extrasamples > 1) {				*va_arg(ap, uint16**) = td->td_transferfunction[1];				*va_arg(ap, uint16**) = td->td_transferfunction[2];			}			break;		case TIFFTAG_REFERENCEBLACKWHITE:			*va_arg(ap, float**) = td->td_refblackwhite;			break;		case TIFFTAG_INKNAMES:			*va_arg(ap, char**) = td->td_inknames;			break;		default:			{				int i;				/*				 * This can happen if multiple images are open				 * with different codecs which have private				 * tags.  The global tag information table may				 * then have tags that are valid for one file				 * but not the other. If the client tries to				 * get a tag that is not valid for the image's				 * codec then we'll arrive here.				 */				if( fip == NULL || fip->field_bit != FIELD_CUSTOM )				{					TIFFErrorExt(tif->tif_clientdata, "_TIFFVGetField",					    "%s: Invalid %stag \"%s\" "					    "(not supported by codec)",					    tif->tif_name,					    isPseudoTag(tag) ? "pseudo-" : "",					    fip ? fip->field_name : "Unknown");					ret_val = 0;					break;				}				/*				 * Do we have a custom value?				 */				ret_val = 0;				for (i = 0; i < td->td_customValueCount; i++) {					TIFFTagValue *tv = td->td_customValues + i;					if (tv->info->field_tag != tag)						continue;					if (fip->field_passcount) {						if (fip->field_readcount == TIFF_VARIABLE2)							*va_arg(ap, uint32*) = (uint32)tv->count;						else  /* Assume TIFF_VARIABLE */							*va_arg(ap, uint16*) = (uint16)tv->count;						*va_arg(ap, void **) = tv->value;						ret_val = 1;					} else if (fip->field_tag == TIFFTAG_DOTRANGE						   && strcmp(fip->field_name,"DotRange") == 0) {						/* TODO: This is an evil exception and should not have been						   handled this way ... likely best if we move it into						   the directory structure with an explicit field in 						   libtiff 4.1 and assign it a FIELD_ value */						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[0];						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[1];						ret_val = 1;					} else {						if (fip->field_type == TIFF_ASCII						    || fip->field_readcount == TIFF_VARIABLE						    || fip->field_readcount == TIFF_VARIABLE2						    || fip->field_readcount == TIFF_SPP						    || tv->count > 1) {							*va_arg(ap, void **) = tv->value;							ret_val = 1;						} else {							char *val = (char *)tv->value;							assert( tv->count == 1 );							switch (fip->field_type) {							case TIFF_BYTE:							case TIFF_UNDEFINED:								*va_arg(ap, uint8*) =									*(uint8 *)val;								ret_val = 1;								break;							case TIFF_SBYTE:								*va_arg(ap, int8*) =									*(int8 *)val;								ret_val = 1;								break;							case TIFF_SHORT:								*va_arg(ap, uint16*) =									*(uint16 *)val;								ret_val = 1;								break;							case TIFF_SSHORT:								*va_arg(ap, int16*) =									*(int16 *)val;								ret_val = 1;								break;							case TIFF_LONG:							case TIFF_IFD:								*va_arg(ap, uint32*) =									*(uint32 *)val;								ret_val = 1;								break;							case TIFF_SLONG:								*va_arg(ap, int32*) =									*(int32 *)val;								ret_val = 1;								break;							case TIFF_LONG8:							case TIFF_IFD8:								*va_arg(ap, uint64*) =									*(uint64 *)val;								ret_val = 1;								break;							case TIFF_SLONG8:								*va_arg(ap, int64*) =									*(int64 *)val;								ret_val = 1;								break;							case TIFF_RATIONAL:							case TIFF_SRATIONAL:							case TIFF_FLOAT:								*va_arg(ap, float*) =									*(float *)val;								ret_val = 1;								break;							case TIFF_DOUBLE:								*va_arg(ap, double*) =									*(double *)val;								ret_val = 1;								break;							default:								ret_val = 0;								break;							}						}					}					break;				}			}	}	return(ret_val);}
TIFFDirectory* td = &tif->tif_dir;
TIFFDirectory* td = &tif->tif_dir;
TIFFDirectory
TIFFDirectory
* td = &tif->tif_dir
*
td
= &tif->tif_dir
&tif->tif_dir
tif->tif_dir
tif
tif
tif_dir
int ret_val = 1;
int ret_val = 1;
int
ret_val = 1
ret_val
= 1
1
uint32 standard_tag = tag;
uint32 standard_tag = tag;
uint32
uint32
standard_tag = tag
standard_tag
= tag
tag
tag
const TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);
const TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);
const TIFFField
TIFFField
* fip = TIFFFindField(tif, tag, TIFF_ANY)
*
fip
= TIFFFindField(tif, tag, TIFF_ANY)
TIFFFindField(tif, tag, TIFF_ANY)
TIFFFindField
TIFFFindField
tif
tif
tag
tag
TIFF_ANY
TIFF_ANY
if (fip->field_bit == FIELD_CUSTOM) {		standard_tag = 0;	}
fip->field_bit == FIELD_CUSTOM
fip->field_bit
fip
fip
field_bit
FIELD_CUSTOM
FIELD_CUSTOM
{		standard_tag = 0;	}
standard_tag = 0;
standard_tag = 0
standard_tag
standard_tag
0
switch (standard_tag) {		case TIFFTAG_SUBFILETYPE:			*va_arg(ap, uint32*) = td->td_subfiletype;			break;		case TIFFTAG_IMAGEWIDTH:			*va_arg(ap, uint32*) = td->td_imagewidth;			break;		case TIFFTAG_IMAGELENGTH:			*va_arg(ap, uint32*) = td->td_imagelength;			break;		case TIFFTAG_BITSPERSAMPLE:			*va_arg(ap, uint16*) = td->td_bitspersample;			break;		case TIFFTAG_COMPRESSION:			*va_arg(ap, uint16*) = td->td_compression;			break;		case TIFFTAG_PHOTOMETRIC:			*va_arg(ap, uint16*) = td->td_photometric;			break;		case TIFFTAG_THRESHHOLDING:			*va_arg(ap, uint16*) = td->td_threshholding;			break;		case TIFFTAG_FILLORDER:			*va_arg(ap, uint16*) = td->td_fillorder;			break;		case TIFFTAG_ORIENTATION:			*va_arg(ap, uint16*) = td->td_orientation;			break;		case TIFFTAG_SAMPLESPERPIXEL:			*va_arg(ap, uint16*) = td->td_samplesperpixel;			break;		case TIFFTAG_ROWSPERSTRIP:			*va_arg(ap, uint32*) = td->td_rowsperstrip;			break;		case TIFFTAG_MINSAMPLEVALUE:			*va_arg(ap, uint16*) = td->td_minsamplevalue;			break;		case TIFFTAG_MAXSAMPLEVALUE:			*va_arg(ap, uint16*) = td->td_maxsamplevalue;			break;		case TIFFTAG_SMINSAMPLEVALUE:			if (tif->tif_flags & TIFF_PERSAMPLE)				*va_arg(ap, double**) = td->td_sminsamplevalue;			else			{				/* libtiff historially treats this as a single value. */				uint16 i;				double v = td->td_sminsamplevalue[0];				for (i=1; i < td->td_samplesperpixel; ++i)					if( td->td_sminsamplevalue[i] < v )						v = td->td_sminsamplevalue[i];				*va_arg(ap, double*) = v;			}			break;		case TIFFTAG_SMAXSAMPLEVALUE:			if (tif->tif_flags & TIFF_PERSAMPLE)				*va_arg(ap, double**) = td->td_smaxsamplevalue;			else			{				/* libtiff historially treats this as a single value. */				uint16 i;				double v = td->td_smaxsamplevalue[0];				for (i=1; i < td->td_samplesperpixel; ++i)					if( td->td_smaxsamplevalue[i] > v )						v = td->td_smaxsamplevalue[i];				*va_arg(ap, double*) = v;			}			break;		case TIFFTAG_XRESOLUTION:			*va_arg(ap, float*) = td->td_xresolution;			break;		case TIFFTAG_YRESOLUTION:			*va_arg(ap, float*) = td->td_yresolution;			break;		case TIFFTAG_PLANARCONFIG:			*va_arg(ap, uint16*) = td->td_planarconfig;			break;		case TIFFTAG_XPOSITION:			*va_arg(ap, float*) = td->td_xposition;			break;		case TIFFTAG_YPOSITION:			*va_arg(ap, float*) = td->td_yposition;			break;		case TIFFTAG_RESOLUTIONUNIT:			*va_arg(ap, uint16*) = td->td_resolutionunit;			break;		case TIFFTAG_PAGENUMBER:			*va_arg(ap, uint16*) = td->td_pagenumber[0];			*va_arg(ap, uint16*) = td->td_pagenumber[1];			break;		case TIFFTAG_HALFTONEHINTS:			*va_arg(ap, uint16*) = td->td_halftonehints[0];			*va_arg(ap, uint16*) = td->td_halftonehints[1];			break;		case TIFFTAG_COLORMAP:			*va_arg(ap, uint16**) = td->td_colormap[0];			*va_arg(ap, uint16**) = td->td_colormap[1];			*va_arg(ap, uint16**) = td->td_colormap[2];			break;		case TIFFTAG_STRIPOFFSETS:		case TIFFTAG_TILEOFFSETS:			_TIFFFillStriles( tif );			*va_arg(ap, uint64**) = td->td_stripoffset;			break;		case TIFFTAG_STRIPBYTECOUNTS:		case TIFFTAG_TILEBYTECOUNTS:			_TIFFFillStriles( tif );			*va_arg(ap, uint64**) = td->td_stripbytecount;			break;		case TIFFTAG_MATTEING:			*va_arg(ap, uint16*) =			    (td->td_extrasamples == 1 &&			    td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA);			break;		case TIFFTAG_EXTRASAMPLES:			*va_arg(ap, uint16*) = td->td_extrasamples;			*va_arg(ap, uint16**) = td->td_sampleinfo;			break;		case TIFFTAG_TILEWIDTH:			*va_arg(ap, uint32*) = td->td_tilewidth;			break;		case TIFFTAG_TILELENGTH:			*va_arg(ap, uint32*) = td->td_tilelength;			break;		case TIFFTAG_TILEDEPTH:			*va_arg(ap, uint32*) = td->td_tiledepth;			break;		case TIFFTAG_DATATYPE:			switch (td->td_sampleformat) {				case SAMPLEFORMAT_UINT:					*va_arg(ap, uint16*) = DATATYPE_UINT;					break;				case SAMPLEFORMAT_INT:					*va_arg(ap, uint16*) = DATATYPE_INT;					break;				case SAMPLEFORMAT_IEEEFP:					*va_arg(ap, uint16*) = DATATYPE_IEEEFP;					break;				case SAMPLEFORMAT_VOID:					*va_arg(ap, uint16*) = DATATYPE_VOID;					break;			}			break;		case TIFFTAG_SAMPLEFORMAT:			*va_arg(ap, uint16*) = td->td_sampleformat;			break;		case TIFFTAG_IMAGEDEPTH:			*va_arg(ap, uint32*) = td->td_imagedepth;			break;		case TIFFTAG_SUBIFD:			*va_arg(ap, uint16*) = td->td_nsubifd;			*va_arg(ap, uint64**) = td->td_subifd;			break;		case TIFFTAG_YCBCRPOSITIONING:			*va_arg(ap, uint16*) = td->td_ycbcrpositioning;			break;		case TIFFTAG_YCBCRSUBSAMPLING:			*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[0];			*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[1];			break;		case TIFFTAG_TRANSFERFUNCTION:			*va_arg(ap, uint16**) = td->td_transferfunction[0];			if (td->td_samplesperpixel - td->td_extrasamples > 1) {				*va_arg(ap, uint16**) = td->td_transferfunction[1];				*va_arg(ap, uint16**) = td->td_transferfunction[2];			}			break;		case TIFFTAG_REFERENCEBLACKWHITE:			*va_arg(ap, float**) = td->td_refblackwhite;			break;		case TIFFTAG_INKNAMES:			*va_arg(ap, char**) = td->td_inknames;			break;		default:			{				int i;				/*				 * This can happen if multiple images are open				 * with different codecs which have private				 * tags.  The global tag information table may				 * then have tags that are valid for one file				 * but not the other. If the client tries to				 * get a tag that is not valid for the image's				 * codec then we'll arrive here.				 */				if( fip == NULL || fip->field_bit != FIELD_CUSTOM )				{					TIFFErrorExt(tif->tif_clientdata, "_TIFFVGetField",					    "%s: Invalid %stag \"%s\" "					    "(not supported by codec)",					    tif->tif_name,					    isPseudoTag(tag) ? "pseudo-" : "",					    fip ? fip->field_name : "Unknown");					ret_val = 0;					break;				}				/*				 * Do we have a custom value?				 */				ret_val = 0;				for (i = 0; i < td->td_customValueCount; i++) {					TIFFTagValue *tv = td->td_customValues + i;					if (tv->info->field_tag != tag)						continue;					if (fip->field_passcount) {						if (fip->field_readcount == TIFF_VARIABLE2)							*va_arg(ap, uint32*) = (uint32)tv->count;						else  /* Assume TIFF_VARIABLE */							*va_arg(ap, uint16*) = (uint16)tv->count;						*va_arg(ap, void **) = tv->value;						ret_val = 1;					} else if (fip->field_tag == TIFFTAG_DOTRANGE						   && strcmp(fip->field_name,"DotRange") == 0) {						/* TODO: This is an evil exception and should not have been						   handled this way ... likely best if we move it into						   the directory structure with an explicit field in 						   libtiff 4.1 and assign it a FIELD_ value */						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[0];						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[1];						ret_val = 1;					} else {						if (fip->field_type == TIFF_ASCII						    || fip->field_readcount == TIFF_VARIABLE						    || fip->field_readcount == TIFF_VARIABLE2						    || fip->field_readcount == TIFF_SPP						    || tv->count > 1) {							*va_arg(ap, void **) = tv->value;							ret_val = 1;						} else {							char *val = (char *)tv->value;							assert( tv->count == 1 );							switch (fip->field_type) {							case TIFF_BYTE:							case TIFF_UNDEFINED:								*va_arg(ap, uint8*) =									*(uint8 *)val;								ret_val = 1;								break;							case TIFF_SBYTE:								*va_arg(ap, int8*) =									*(int8 *)val;								ret_val = 1;								break;							case TIFF_SHORT:								*va_arg(ap, uint16*) =									*(uint16 *)val;								ret_val = 1;								break;							case TIFF_SSHORT:								*va_arg(ap, int16*) =									*(int16 *)val;								ret_val = 1;								break;							case TIFF_LONG:							case TIFF_IFD:								*va_arg(ap, uint32*) =									*(uint32 *)val;								ret_val = 1;								break;							case TIFF_SLONG:								*va_arg(ap, int32*) =									*(int32 *)val;								ret_val = 1;								break;							case TIFF_LONG8:							case TIFF_IFD8:								*va_arg(ap, uint64*) =									*(uint64 *)val;								ret_val = 1;								break;							case TIFF_SLONG8:								*va_arg(ap, int64*) =									*(int64 *)val;								ret_val = 1;								break;							case TIFF_RATIONAL:							case TIFF_SRATIONAL:							case TIFF_FLOAT:								*va_arg(ap, float*) =									*(float *)val;								ret_val = 1;								break;							case TIFF_DOUBLE:								*va_arg(ap, double*) =									*(double *)val;								ret_val = 1;								break;							default:								ret_val = 0;								break;							}						}					}					break;				}			}	}
standard_tag
standard_tag
{		case TIFFTAG_SUBFILETYPE:			*va_arg(ap, uint32*) = td->td_subfiletype;			break;		case TIFFTAG_IMAGEWIDTH:			*va_arg(ap, uint32*) = td->td_imagewidth;			break;		case TIFFTAG_IMAGELENGTH:			*va_arg(ap, uint32*) = td->td_imagelength;			break;		case TIFFTAG_BITSPERSAMPLE:			*va_arg(ap, uint16*) = td->td_bitspersample;			break;		case TIFFTAG_COMPRESSION:			*va_arg(ap, uint16*) = td->td_compression;			break;		case TIFFTAG_PHOTOMETRIC:			*va_arg(ap, uint16*) = td->td_photometric;			break;		case TIFFTAG_THRESHHOLDING:			*va_arg(ap, uint16*) = td->td_threshholding;			break;		case TIFFTAG_FILLORDER:			*va_arg(ap, uint16*) = td->td_fillorder;			break;		case TIFFTAG_ORIENTATION:			*va_arg(ap, uint16*) = td->td_orientation;			break;		case TIFFTAG_SAMPLESPERPIXEL:			*va_arg(ap, uint16*) = td->td_samplesperpixel;			break;		case TIFFTAG_ROWSPERSTRIP:			*va_arg(ap, uint32*) = td->td_rowsperstrip;			break;		case TIFFTAG_MINSAMPLEVALUE:			*va_arg(ap, uint16*) = td->td_minsamplevalue;			break;		case TIFFTAG_MAXSAMPLEVALUE:			*va_arg(ap, uint16*) = td->td_maxsamplevalue;			break;		case TIFFTAG_SMINSAMPLEVALUE:			if (tif->tif_flags & TIFF_PERSAMPLE)				*va_arg(ap, double**) = td->td_sminsamplevalue;			else			{				/* libtiff historially treats this as a single value. */				uint16 i;				double v = td->td_sminsamplevalue[0];				for (i=1; i < td->td_samplesperpixel; ++i)					if( td->td_sminsamplevalue[i] < v )						v = td->td_sminsamplevalue[i];				*va_arg(ap, double*) = v;			}			break;		case TIFFTAG_SMAXSAMPLEVALUE:			if (tif->tif_flags & TIFF_PERSAMPLE)				*va_arg(ap, double**) = td->td_smaxsamplevalue;			else			{				/* libtiff historially treats this as a single value. */				uint16 i;				double v = td->td_smaxsamplevalue[0];				for (i=1; i < td->td_samplesperpixel; ++i)					if( td->td_smaxsamplevalue[i] > v )						v = td->td_smaxsamplevalue[i];				*va_arg(ap, double*) = v;			}			break;		case TIFFTAG_XRESOLUTION:			*va_arg(ap, float*) = td->td_xresolution;			break;		case TIFFTAG_YRESOLUTION:			*va_arg(ap, float*) = td->td_yresolution;			break;		case TIFFTAG_PLANARCONFIG:			*va_arg(ap, uint16*) = td->td_planarconfig;			break;		case TIFFTAG_XPOSITION:			*va_arg(ap, float*) = td->td_xposition;			break;		case TIFFTAG_YPOSITION:			*va_arg(ap, float*) = td->td_yposition;			break;		case TIFFTAG_RESOLUTIONUNIT:			*va_arg(ap, uint16*) = td->td_resolutionunit;			break;		case TIFFTAG_PAGENUMBER:			*va_arg(ap, uint16*) = td->td_pagenumber[0];			*va_arg(ap, uint16*) = td->td_pagenumber[1];			break;		case TIFFTAG_HALFTONEHINTS:			*va_arg(ap, uint16*) = td->td_halftonehints[0];			*va_arg(ap, uint16*) = td->td_halftonehints[1];			break;		case TIFFTAG_COLORMAP:			*va_arg(ap, uint16**) = td->td_colormap[0];			*va_arg(ap, uint16**) = td->td_colormap[1];			*va_arg(ap, uint16**) = td->td_colormap[2];			break;		case TIFFTAG_STRIPOFFSETS:		case TIFFTAG_TILEOFFSETS:			_TIFFFillStriles( tif );			*va_arg(ap, uint64**) = td->td_stripoffset;			break;		case TIFFTAG_STRIPBYTECOUNTS:		case TIFFTAG_TILEBYTECOUNTS:			_TIFFFillStriles( tif );			*va_arg(ap, uint64**) = td->td_stripbytecount;			break;		case TIFFTAG_MATTEING:			*va_arg(ap, uint16*) =			    (td->td_extrasamples == 1 &&			    td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA);			break;		case TIFFTAG_EXTRASAMPLES:			*va_arg(ap, uint16*) = td->td_extrasamples;			*va_arg(ap, uint16**) = td->td_sampleinfo;			break;		case TIFFTAG_TILEWIDTH:			*va_arg(ap, uint32*) = td->td_tilewidth;			break;		case TIFFTAG_TILELENGTH:			*va_arg(ap, uint32*) = td->td_tilelength;			break;		case TIFFTAG_TILEDEPTH:			*va_arg(ap, uint32*) = td->td_tiledepth;			break;		case TIFFTAG_DATATYPE:			switch (td->td_sampleformat) {				case SAMPLEFORMAT_UINT:					*va_arg(ap, uint16*) = DATATYPE_UINT;					break;				case SAMPLEFORMAT_INT:					*va_arg(ap, uint16*) = DATATYPE_INT;					break;				case SAMPLEFORMAT_IEEEFP:					*va_arg(ap, uint16*) = DATATYPE_IEEEFP;					break;				case SAMPLEFORMAT_VOID:					*va_arg(ap, uint16*) = DATATYPE_VOID;					break;			}			break;		case TIFFTAG_SAMPLEFORMAT:			*va_arg(ap, uint16*) = td->td_sampleformat;			break;		case TIFFTAG_IMAGEDEPTH:			*va_arg(ap, uint32*) = td->td_imagedepth;			break;		case TIFFTAG_SUBIFD:			*va_arg(ap, uint16*) = td->td_nsubifd;			*va_arg(ap, uint64**) = td->td_subifd;			break;		case TIFFTAG_YCBCRPOSITIONING:			*va_arg(ap, uint16*) = td->td_ycbcrpositioning;			break;		case TIFFTAG_YCBCRSUBSAMPLING:			*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[0];			*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[1];			break;		case TIFFTAG_TRANSFERFUNCTION:			*va_arg(ap, uint16**) = td->td_transferfunction[0];			if (td->td_samplesperpixel - td->td_extrasamples > 1) {				*va_arg(ap, uint16**) = td->td_transferfunction[1];				*va_arg(ap, uint16**) = td->td_transferfunction[2];			}			break;		case TIFFTAG_REFERENCEBLACKWHITE:			*va_arg(ap, float**) = td->td_refblackwhite;			break;		case TIFFTAG_INKNAMES:			*va_arg(ap, char**) = td->td_inknames;			break;		default:			{				int i;				/*				 * This can happen if multiple images are open				 * with different codecs which have private				 * tags.  The global tag information table may				 * then have tags that are valid for one file				 * but not the other. If the client tries to				 * get a tag that is not valid for the image's				 * codec then we'll arrive here.				 */				if( fip == NULL || fip->field_bit != FIELD_CUSTOM )				{					TIFFErrorExt(tif->tif_clientdata, "_TIFFVGetField",					    "%s: Invalid %stag \"%s\" "					    "(not supported by codec)",					    tif->tif_name,					    isPseudoTag(tag) ? "pseudo-" : "",					    fip ? fip->field_name : "Unknown");					ret_val = 0;					break;				}				/*				 * Do we have a custom value?				 */				ret_val = 0;				for (i = 0; i < td->td_customValueCount; i++) {					TIFFTagValue *tv = td->td_customValues + i;					if (tv->info->field_tag != tag)						continue;					if (fip->field_passcount) {						if (fip->field_readcount == TIFF_VARIABLE2)							*va_arg(ap, uint32*) = (uint32)tv->count;						else  /* Assume TIFF_VARIABLE */							*va_arg(ap, uint16*) = (uint16)tv->count;						*va_arg(ap, void **) = tv->value;						ret_val = 1;					} else if (fip->field_tag == TIFFTAG_DOTRANGE						   && strcmp(fip->field_name,"DotRange") == 0) {						/* TODO: This is an evil exception and should not have been						   handled this way ... likely best if we move it into						   the directory structure with an explicit field in 						   libtiff 4.1 and assign it a FIELD_ value */						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[0];						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[1];						ret_val = 1;					} else {						if (fip->field_type == TIFF_ASCII						    || fip->field_readcount == TIFF_VARIABLE						    || fip->field_readcount == TIFF_VARIABLE2						    || fip->field_readcount == TIFF_SPP						    || tv->count > 1) {							*va_arg(ap, void **) = tv->value;							ret_val = 1;						} else {							char *val = (char *)tv->value;							assert( tv->count == 1 );							switch (fip->field_type) {							case TIFF_BYTE:							case TIFF_UNDEFINED:								*va_arg(ap, uint8*) =									*(uint8 *)val;								ret_val = 1;								break;							case TIFF_SBYTE:								*va_arg(ap, int8*) =									*(int8 *)val;								ret_val = 1;								break;							case TIFF_SHORT:								*va_arg(ap, uint16*) =									*(uint16 *)val;								ret_val = 1;								break;							case TIFF_SSHORT:								*va_arg(ap, int16*) =									*(int16 *)val;								ret_val = 1;								break;							case TIFF_LONG:							case TIFF_IFD:								*va_arg(ap, uint32*) =									*(uint32 *)val;								ret_val = 1;								break;							case TIFF_SLONG:								*va_arg(ap, int32*) =									*(int32 *)val;								ret_val = 1;								break;							case TIFF_LONG8:							case TIFF_IFD8:								*va_arg(ap, uint64*) =									*(uint64 *)val;								ret_val = 1;								break;							case TIFF_SLONG8:								*va_arg(ap, int64*) =									*(int64 *)val;								ret_val = 1;								break;							case TIFF_RATIONAL:							case TIFF_SRATIONAL:							case TIFF_FLOAT:								*va_arg(ap, float*) =									*(float *)val;								ret_val = 1;								break;							case TIFF_DOUBLE:								*va_arg(ap, double*) =									*(double *)val;								ret_val = 1;								break;							default:								ret_val = 0;								break;							}						}					}					break;				}			}	}
case TIFFTAG_SUBFILETYPE:
TIFFTAG_SUBFILETYPE
TIFFTAG_SUBFILETYPE
*va_arg(ap, uint32*) = td->td_subfiletype;
break;
case TIFFTAG_IMAGEWIDTH:
TIFFTAG_IMAGEWIDTH
TIFFTAG_IMAGEWIDTH
*va_arg(ap, uint32*) = td->td_imagewidth;
break;
case TIFFTAG_IMAGELENGTH:
TIFFTAG_IMAGELENGTH
TIFFTAG_IMAGELENGTH
*va_arg(ap, uint32*) = td->td_imagelength;
break;
case TIFFTAG_BITSPERSAMPLE:
TIFFTAG_BITSPERSAMPLE
TIFFTAG_BITSPERSAMPLE
*va_arg(ap, uint16*) = td->td_bitspersample;
break;
case TIFFTAG_COMPRESSION:
TIFFTAG_COMPRESSION
TIFFTAG_COMPRESSION
*va_arg(ap, uint16*) = td->td_compression;
break;
case TIFFTAG_PHOTOMETRIC:
TIFFTAG_PHOTOMETRIC
TIFFTAG_PHOTOMETRIC
*va_arg(ap, uint16*) = td->td_photometric;
break;
case TIFFTAG_THRESHHOLDING:
TIFFTAG_THRESHHOLDING
TIFFTAG_THRESHHOLDING
*va_arg(ap, uint16*) = td->td_threshholding;
break;
case TIFFTAG_FILLORDER:
TIFFTAG_FILLORDER
TIFFTAG_FILLORDER
*va_arg(ap, uint16*) = td->td_fillorder;
break;
case TIFFTAG_ORIENTATION:
TIFFTAG_ORIENTATION
TIFFTAG_ORIENTATION
*va_arg(ap, uint16*) = td->td_orientation;
break;
case TIFFTAG_SAMPLESPERPIXEL:
TIFFTAG_SAMPLESPERPIXEL
TIFFTAG_SAMPLESPERPIXEL
*va_arg(ap, uint16*) = td->td_samplesperpixel;
break;
case TIFFTAG_ROWSPERSTRIP:
TIFFTAG_ROWSPERSTRIP
TIFFTAG_ROWSPERSTRIP
*va_arg(ap, uint32*) = td->td_rowsperstrip;
break;
case TIFFTAG_MINSAMPLEVALUE:
TIFFTAG_MINSAMPLEVALUE
TIFFTAG_MINSAMPLEVALUE
*va_arg(ap, uint16*) = td->td_minsamplevalue;
break;
case TIFFTAG_MAXSAMPLEVALUE:
TIFFTAG_MAXSAMPLEVALUE
TIFFTAG_MAXSAMPLEVALUE
*va_arg(ap, uint16*) = td->td_maxsamplevalue;
break;
case TIFFTAG_SMINSAMPLEVALUE:
TIFFTAG_SMINSAMPLEVALUE
TIFFTAG_SMINSAMPLEVALUE
if (tif->tif_flags & TIFF_PERSAMPLE)				*va_arg(ap, double**) = td->td_sminsamplevalue;
else			{				/* libtiff historially treats this as a single value. */				uint16 i;				double v = td->td_sminsamplevalue[0];				for (i=1; i < td->td_samplesperpixel; ++i)					if( td->td_sminsamplevalue[i] < v )						v = td->td_sminsamplevalue[i];				*va_arg(ap, double*) = v;			}
break;
case TIFFTAG_SMAXSAMPLEVALUE:
TIFFTAG_SMAXSAMPLEVALUE
TIFFTAG_SMAXSAMPLEVALUE
if (tif->tif_flags & TIFF_PERSAMPLE)				*va_arg(ap, double**) = td->td_smaxsamplevalue;
else			{				/* libtiff historially treats this as a single value. */				uint16 i;				double v = td->td_smaxsamplevalue[0];				for (i=1; i < td->td_samplesperpixel; ++i)					if( td->td_smaxsamplevalue[i] > v )						v = td->td_smaxsamplevalue[i];				*va_arg(ap, double*) = v;			}
break;
case TIFFTAG_XRESOLUTION:
TIFFTAG_XRESOLUTION
TIFFTAG_XRESOLUTION
*va_arg(ap, float*) = td->td_xresolution;
break;
case TIFFTAG_YRESOLUTION:
TIFFTAG_YRESOLUTION
TIFFTAG_YRESOLUTION
*va_arg(ap, float*) = td->td_yresolution;
break;
case TIFFTAG_PLANARCONFIG:
TIFFTAG_PLANARCONFIG
TIFFTAG_PLANARCONFIG
*va_arg(ap, uint16*) = td->td_planarconfig;
break;
case TIFFTAG_XPOSITION:
TIFFTAG_XPOSITION
TIFFTAG_XPOSITION
*va_arg(ap, float*) = td->td_xposition;
break;
case TIFFTAG_YPOSITION:
TIFFTAG_YPOSITION
TIFFTAG_YPOSITION
*va_arg(ap, float*) = td->td_yposition;
break;
case TIFFTAG_RESOLUTIONUNIT:
TIFFTAG_RESOLUTIONUNIT
TIFFTAG_RESOLUTIONUNIT
*va_arg(ap, uint16*) = td->td_resolutionunit;
break;
case TIFFTAG_PAGENUMBER:
TIFFTAG_PAGENUMBER
TIFFTAG_PAGENUMBER
*va_arg(ap, uint16*) = td->td_pagenumber[0];
*va_arg(ap, uint16*) = td->td_pagenumber[1];
break;
case TIFFTAG_HALFTONEHINTS:
TIFFTAG_HALFTONEHINTS
TIFFTAG_HALFTONEHINTS
*va_arg(ap, uint16*) = td->td_halftonehints[0];
*va_arg(ap, uint16*) = td->td_halftonehints[1];
break;
case TIFFTAG_COLORMAP:
TIFFTAG_COLORMAP
TIFFTAG_COLORMAP
*va_arg(ap, uint16**) = td->td_colormap[0];
*va_arg(ap, uint16**) = td->td_colormap[1];
*va_arg(ap, uint16**) = td->td_colormap[2];
break;
case TIFFTAG_STRIPOFFSETS:
TIFFTAG_STRIPOFFSETS
TIFFTAG_STRIPOFFSETS
case TIFFTAG_TILEOFFSETS:
TIFFTAG_TILEOFFSETS
TIFFTAG_TILEOFFSETS
_TIFFFillStriles( tif );
_TIFFFillStriles( tif )
_TIFFFillStriles
_TIFFFillStriles
tif
tif
*va_arg(ap, uint64**) = td->td_stripoffset;
break;
case TIFFTAG_STRIPBYTECOUNTS:
TIFFTAG_STRIPBYTECOUNTS
TIFFTAG_STRIPBYTECOUNTS
case TIFFTAG_TILEBYTECOUNTS:
TIFFTAG_TILEBYTECOUNTS
TIFFTAG_TILEBYTECOUNTS
_TIFFFillStriles( tif );
_TIFFFillStriles( tif )
_TIFFFillStriles
_TIFFFillStriles
tif
tif
*va_arg(ap, uint64**) = td->td_stripbytecount;
break;
case TIFFTAG_MATTEING:
TIFFTAG_MATTEING
TIFFTAG_MATTEING
*va_arg(ap, uint16*) =			    (td->td_extrasamples == 1 &&			    td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA);
break;
case TIFFTAG_EXTRASAMPLES:
TIFFTAG_EXTRASAMPLES
TIFFTAG_EXTRASAMPLES
*va_arg(ap, uint16*) = td->td_extrasamples;
*va_arg(ap, uint16**) = td->td_sampleinfo;
break;
case TIFFTAG_TILEWIDTH:
TIFFTAG_TILEWIDTH
TIFFTAG_TILEWIDTH
*va_arg(ap, uint32*) = td->td_tilewidth;
break;
case TIFFTAG_TILELENGTH:
TIFFTAG_TILELENGTH
TIFFTAG_TILELENGTH
*va_arg(ap, uint32*) = td->td_tilelength;
break;
case TIFFTAG_TILEDEPTH:
TIFFTAG_TILEDEPTH
TIFFTAG_TILEDEPTH
*va_arg(ap, uint32*) = td->td_tiledepth;
break;
case TIFFTAG_DATATYPE:
TIFFTAG_DATATYPE
TIFFTAG_DATATYPE
switch (td->td_sampleformat) {				case SAMPLEFORMAT_UINT:					*va_arg(ap, uint16*) = DATATYPE_UINT;					break;				case SAMPLEFORMAT_INT:					*va_arg(ap, uint16*) = DATATYPE_INT;					break;				case SAMPLEFORMAT_IEEEFP:					*va_arg(ap, uint16*) = DATATYPE_IEEEFP;					break;				case SAMPLEFORMAT_VOID:					*va_arg(ap, uint16*) = DATATYPE_VOID;					break;			}
td->td_sampleformat
td
td
td_sampleformat
{				case SAMPLEFORMAT_UINT:					*va_arg(ap, uint16*) = DATATYPE_UINT;					break;				case SAMPLEFORMAT_INT:					*va_arg(ap, uint16*) = DATATYPE_INT;					break;				case SAMPLEFORMAT_IEEEFP:					*va_arg(ap, uint16*) = DATATYPE_IEEEFP;					break;				case SAMPLEFORMAT_VOID:					*va_arg(ap, uint16*) = DATATYPE_VOID;					break;			}
case SAMPLEFORMAT_UINT:
SAMPLEFORMAT_UINT
SAMPLEFORMAT_UINT
*va_arg(ap, uint16*) = DATATYPE_UINT;
break;
case SAMPLEFORMAT_INT:
SAMPLEFORMAT_INT
SAMPLEFORMAT_INT
*va_arg(ap, uint16*) = DATATYPE_INT;
break;
case SAMPLEFORMAT_IEEEFP:
SAMPLEFORMAT_IEEEFP
SAMPLEFORMAT_IEEEFP
*va_arg(ap, uint16*) = DATATYPE_IEEEFP;
break;
case SAMPLEFORMAT_VOID:
SAMPLEFORMAT_VOID
SAMPLEFORMAT_VOID
*va_arg(ap, uint16*) = DATATYPE_VOID;
break;
break;
case TIFFTAG_SAMPLEFORMAT:
TIFFTAG_SAMPLEFORMAT
TIFFTAG_SAMPLEFORMAT
*va_arg(ap, uint16*) = td->td_sampleformat;
break;
case TIFFTAG_IMAGEDEPTH:
TIFFTAG_IMAGEDEPTH
TIFFTAG_IMAGEDEPTH
*va_arg(ap, uint32*) = td->td_imagedepth;
break;
case TIFFTAG_SUBIFD:
TIFFTAG_SUBIFD
TIFFTAG_SUBIFD
*va_arg(ap, uint16*) = td->td_nsubifd;
*va_arg(ap, uint64**) = td->td_subifd;
break;
case TIFFTAG_YCBCRPOSITIONING:
TIFFTAG_YCBCRPOSITIONING
TIFFTAG_YCBCRPOSITIONING
*va_arg(ap, uint16*) = td->td_ycbcrpositioning;
break;
case TIFFTAG_YCBCRSUBSAMPLING:
TIFFTAG_YCBCRSUBSAMPLING
TIFFTAG_YCBCRSUBSAMPLING
*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[0];
*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[1];
break;
case TIFFTAG_TRANSFERFUNCTION:
TIFFTAG_TRANSFERFUNCTION
TIFFTAG_TRANSFERFUNCTION
*va_arg(ap, uint16**) = td->td_transferfunction[0];
if (td->td_samplesperpixel - td->td_extrasamples > 1) {				*va_arg(ap, uint16**) = td->td_transferfunction[1];				*va_arg(ap, uint16**) = td->td_transferfunction[2];			}
td->td_samplesperpixel - td->td_extrasamples > 1
td->td_samplesperpixel - td->td_extrasamples
td->td_samplesperpixel
td
td
td_samplesperpixel
td->td_extrasamples
td
td
td_extrasamples
1
{				*va_arg(ap, uint16**) = td->td_transferfunction[1];				*va_arg(ap, uint16**) = td->td_transferfunction[2];			}
*va_arg(ap, uint16**) = td->td_transferfunction[1];
*va_arg(ap, uint16**) = td->td_transferfunction[2];
break;
case TIFFTAG_REFERENCEBLACKWHITE:
TIFFTAG_REFERENCEBLACKWHITE
TIFFTAG_REFERENCEBLACKWHITE
*va_arg(ap, float**) = td->td_refblackwhite;
break;
case TIFFTAG_INKNAMES:
TIFFTAG_INKNAMES
TIFFTAG_INKNAMES
*va_arg(ap, char**) = td->td_inknames;
break;
default:
{				int i;				/*				 * This can happen if multiple images are open				 * with different codecs which have private				 * tags.  The global tag information table may				 * then have tags that are valid for one file				 * but not the other. If the client tries to				 * get a tag that is not valid for the image's				 * codec then we'll arrive here.				 */				if( fip == NULL || fip->field_bit != FIELD_CUSTOM )				{					TIFFErrorExt(tif->tif_clientdata, "_TIFFVGetField",					    "%s: Invalid %stag \"%s\" "					    "(not supported by codec)",					    tif->tif_name,					    isPseudoTag(tag) ? "pseudo-" : "",					    fip ? fip->field_name : "Unknown");					ret_val = 0;					break;				}				/*				 * Do we have a custom value?				 */				ret_val = 0;				for (i = 0; i < td->td_customValueCount; i++) {					TIFFTagValue *tv = td->td_customValues + i;					if (tv->info->field_tag != tag)						continue;					if (fip->field_passcount) {						if (fip->field_readcount == TIFF_VARIABLE2)							*va_arg(ap, uint32*) = (uint32)tv->count;						else  /* Assume TIFF_VARIABLE */							*va_arg(ap, uint16*) = (uint16)tv->count;						*va_arg(ap, void **) = tv->value;						ret_val = 1;					} else if (fip->field_tag == TIFFTAG_DOTRANGE						   && strcmp(fip->field_name,"DotRange") == 0) {						/* TODO: This is an evil exception and should not have been						   handled this way ... likely best if we move it into						   the directory structure with an explicit field in 						   libtiff 4.1 and assign it a FIELD_ value */						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[0];						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[1];						ret_val = 1;					} else {						if (fip->field_type == TIFF_ASCII						    || fip->field_readcount == TIFF_VARIABLE						    || fip->field_readcount == TIFF_VARIABLE2						    || fip->field_readcount == TIFF_SPP						    || tv->count > 1) {							*va_arg(ap, void **) = tv->value;							ret_val = 1;						} else {							char *val = (char *)tv->value;							assert( tv->count == 1 );							switch (fip->field_type) {							case TIFF_BYTE:							case TIFF_UNDEFINED:								*va_arg(ap, uint8*) =									*(uint8 *)val;								ret_val = 1;								break;							case TIFF_SBYTE:								*va_arg(ap, int8*) =									*(int8 *)val;								ret_val = 1;								break;							case TIFF_SHORT:								*va_arg(ap, uint16*) =									*(uint16 *)val;								ret_val = 1;								break;							case TIFF_SSHORT:								*va_arg(ap, int16*) =									*(int16 *)val;								ret_val = 1;								break;							case TIFF_LONG:							case TIFF_IFD:								*va_arg(ap, uint32*) =									*(uint32 *)val;								ret_val = 1;								break;							case TIFF_SLONG:								*va_arg(ap, int32*) =									*(int32 *)val;								ret_val = 1;								break;							case TIFF_LONG8:							case TIFF_IFD8:								*va_arg(ap, uint64*) =									*(uint64 *)val;								ret_val = 1;								break;							case TIFF_SLONG8:								*va_arg(ap, int64*) =									*(int64 *)val;								ret_val = 1;								break;							case TIFF_RATIONAL:							case TIFF_SRATIONAL:							case TIFF_FLOAT:								*va_arg(ap, float*) =									*(float *)val;								ret_val = 1;								break;							case TIFF_DOUBLE:								*va_arg(ap, double*) =									*(double *)val;								ret_val = 1;								break;							default:								ret_val = 0;								break;							}						}					}					break;				}			}
int i;
int i;
int
i
i
if( fip == NULL || fip->field_bit != FIELD_CUSTOM )				{					TIFFErrorExt(tif->tif_clientdata, "_TIFFVGetField",					    "%s: Invalid %stag \"%s\" "					    "(not supported by codec)",					    tif->tif_name,					    isPseudoTag(tag) ? "pseudo-" : "",					    fip ? fip->field_name : "Unknown");					ret_val = 0;					break;				}
fip == NULL || fip->field_bit != FIELD_CUSTOM
fip == NULL
fip
fip
NULL
NULL
fip->field_bit != FIELD_CUSTOM
fip->field_bit
fip
fip
field_bit
FIELD_CUSTOM
FIELD_CUSTOM
{					TIFFErrorExt(tif->tif_clientdata, "_TIFFVGetField",					    "%s: Invalid %stag \"%s\" "					    "(not supported by codec)",					    tif->tif_name,					    isPseudoTag(tag) ? "pseudo-" : "",					    fip ? fip->field_name : "Unknown");					ret_val = 0;					break;				}
TIFFErrorExt(tif->tif_clientdata, "_TIFFVGetField",					    "%s: Invalid %stag \"%s\" "					    "(not supported by codec)",					    tif->tif_name,					    isPseudoTag(tag) ? "pseudo-" : "",					    fip ? fip->field_name : "Unknown");
TIFFErrorExt(tif->tif_clientdata, "_TIFFVGetField",					    "%s: Invalid %stag \"%s\" "					    "(not supported by codec)",					    tif->tif_name,					    isPseudoTag(tag) ? "pseudo-" : "",					    fip ? fip->field_name : "Unknown")
TIFFErrorExt
TIFFErrorExt
tif->tif_clientdata
tif
tif
tif_clientdata
"_TIFFVGetField"
"%s: Invalid %stag \"%s\" "					    "(not supported by codec)"
tif->tif_name
tif
tif
tif_name
isPseudoTag(tag) ? "pseudo-" : ""
isPseudoTag(tag)
isPseudoTag
isPseudoTag
tag
tag
"pseudo-"
""
fip ? fip->field_name : "Unknown"
fip
fip
fip->field_name
fip
fip
field_name
"Unknown"
ret_val = 0;
ret_val = 0
ret_val
ret_val
0
break;
ret_val = 0;
ret_val = 0
ret_val
ret_val
0
for (i = 0; i < td->td_customValueCount; i++) {					TIFFTagValue *tv = td->td_customValues + i;					if (tv->info->field_tag != tag)						continue;					if (fip->field_passcount) {						if (fip->field_readcount == TIFF_VARIABLE2)							*va_arg(ap, uint32*) = (uint32)tv->count;						else  /* Assume TIFF_VARIABLE */							*va_arg(ap, uint16*) = (uint16)tv->count;						*va_arg(ap, void **) = tv->value;						ret_val = 1;					} else if (fip->field_tag == TIFFTAG_DOTRANGE						   && strcmp(fip->field_name,"DotRange") == 0) {						/* TODO: This is an evil exception and should not have been						   handled this way ... likely best if we move it into						   the directory structure with an explicit field in 						   libtiff 4.1 and assign it a FIELD_ value */						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[0];						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[1];						ret_val = 1;					} else {						if (fip->field_type == TIFF_ASCII						    || fip->field_readcount == TIFF_VARIABLE						    || fip->field_readcount == TIFF_VARIABLE2						    || fip->field_readcount == TIFF_SPP						    || tv->count > 1) {							*va_arg(ap, void **) = tv->value;							ret_val = 1;						} else {							char *val = (char *)tv->value;							assert( tv->count == 1 );							switch (fip->field_type) {							case TIFF_BYTE:							case TIFF_UNDEFINED:								*va_arg(ap, uint8*) =									*(uint8 *)val;								ret_val = 1;								break;							case TIFF_SBYTE:								*va_arg(ap, int8*) =									*(int8 *)val;								ret_val = 1;								break;							case TIFF_SHORT:								*va_arg(ap, uint16*) =									*(uint16 *)val;								ret_val = 1;								break;							case TIFF_SSHORT:								*va_arg(ap, int16*) =									*(int16 *)val;								ret_val = 1;								break;							case TIFF_LONG:							case TIFF_IFD:								*va_arg(ap, uint32*) =									*(uint32 *)val;								ret_val = 1;								break;							case TIFF_SLONG:								*va_arg(ap, int32*) =									*(int32 *)val;								ret_val = 1;								break;							case TIFF_LONG8:							case TIFF_IFD8:								*va_arg(ap, uint64*) =									*(uint64 *)val;								ret_val = 1;								break;							case TIFF_SLONG8:								*va_arg(ap, int64*) =									*(int64 *)val;								ret_val = 1;								break;							case TIFF_RATIONAL:							case TIFF_SRATIONAL:							case TIFF_FLOAT:								*va_arg(ap, float*) =									*(float *)val;								ret_val = 1;								break;							case TIFF_DOUBLE:								*va_arg(ap, double*) =									*(double *)val;								ret_val = 1;								break;							default:								ret_val = 0;								break;							}						}					}					break;				}
i = 0;
i = 0
i
i
0
i < td->td_customValueCount
i
i
td->td_customValueCount
td
td
td_customValueCount
i++
i
i
{					TIFFTagValue *tv = td->td_customValues + i;					if (tv->info->field_tag != tag)						continue;					if (fip->field_passcount) {						if (fip->field_readcount == TIFF_VARIABLE2)							*va_arg(ap, uint32*) = (uint32)tv->count;						else  /* Assume TIFF_VARIABLE */							*va_arg(ap, uint16*) = (uint16)tv->count;						*va_arg(ap, void **) = tv->value;						ret_val = 1;					} else if (fip->field_tag == TIFFTAG_DOTRANGE						   && strcmp(fip->field_name,"DotRange") == 0) {						/* TODO: This is an evil exception and should not have been						   handled this way ... likely best if we move it into						   the directory structure with an explicit field in 						   libtiff 4.1 and assign it a FIELD_ value */						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[0];						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[1];						ret_val = 1;					} else {						if (fip->field_type == TIFF_ASCII						    || fip->field_readcount == TIFF_VARIABLE						    || fip->field_readcount == TIFF_VARIABLE2						    || fip->field_readcount == TIFF_SPP						    || tv->count > 1) {							*va_arg(ap, void **) = tv->value;							ret_val = 1;						} else {							char *val = (char *)tv->value;							assert( tv->count == 1 );							switch (fip->field_type) {							case TIFF_BYTE:							case TIFF_UNDEFINED:								*va_arg(ap, uint8*) =									*(uint8 *)val;								ret_val = 1;								break;							case TIFF_SBYTE:								*va_arg(ap, int8*) =									*(int8 *)val;								ret_val = 1;								break;							case TIFF_SHORT:								*va_arg(ap, uint16*) =									*(uint16 *)val;								ret_val = 1;								break;							case TIFF_SSHORT:								*va_arg(ap, int16*) =									*(int16 *)val;								ret_val = 1;								break;							case TIFF_LONG:							case TIFF_IFD:								*va_arg(ap, uint32*) =									*(uint32 *)val;								ret_val = 1;								break;							case TIFF_SLONG:								*va_arg(ap, int32*) =									*(int32 *)val;								ret_val = 1;								break;							case TIFF_LONG8:							case TIFF_IFD8:								*va_arg(ap, uint64*) =									*(uint64 *)val;								ret_val = 1;								break;							case TIFF_SLONG8:								*va_arg(ap, int64*) =									*(int64 *)val;								ret_val = 1;								break;							case TIFF_RATIONAL:							case TIFF_SRATIONAL:							case TIFF_FLOAT:								*va_arg(ap, float*) =									*(float *)val;								ret_val = 1;								break;							case TIFF_DOUBLE:								*va_arg(ap, double*) =									*(double *)val;								ret_val = 1;								break;							default:								ret_val = 0;								break;							}						}					}					break;				}
TIFFTagValue *tv = td->td_customValues + i;
TIFFTagValue *tv = td->td_customValues + i;
TIFFTagValue
TIFFTagValue
*tv = td->td_customValues + i
*
tv
= td->td_customValues + i
td->td_customValues + i
td->td_customValues
td
td
td_customValues
i
i
if (tv->info->field_tag != tag)						continue;
tv->info->field_tag != tag
tv->info->field_tag
tv->info
tv
tv
info
field_tag
tag
tag
continue;
if (fip->field_passcount) {						if (fip->field_readcount == TIFF_VARIABLE2)							*va_arg(ap, uint32*) = (uint32)tv->count;						else  /* Assume TIFF_VARIABLE */							*va_arg(ap, uint16*) = (uint16)tv->count;						*va_arg(ap, void **) = tv->value;						ret_val = 1;					} else if (fip->field_tag == TIFFTAG_DOTRANGE						   && strcmp(fip->field_name,"DotRange") == 0) {						/* TODO: This is an evil exception and should not have been						   handled this way ... likely best if we move it into						   the directory structure with an explicit field in 						   libtiff 4.1 and assign it a FIELD_ value */						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[0];						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[1];						ret_val = 1;					} else {						if (fip->field_type == TIFF_ASCII						    || fip->field_readcount == TIFF_VARIABLE						    || fip->field_readcount == TIFF_VARIABLE2						    || fip->field_readcount == TIFF_SPP						    || tv->count > 1) {							*va_arg(ap, void **) = tv->value;							ret_val = 1;						} else {							char *val = (char *)tv->value;							assert( tv->count == 1 );							switch (fip->field_type) {							case TIFF_BYTE:							case TIFF_UNDEFINED:								*va_arg(ap, uint8*) =									*(uint8 *)val;								ret_val = 1;								break;							case TIFF_SBYTE:								*va_arg(ap, int8*) =									*(int8 *)val;								ret_val = 1;								break;							case TIFF_SHORT:								*va_arg(ap, uint16*) =									*(uint16 *)val;								ret_val = 1;								break;							case TIFF_SSHORT:								*va_arg(ap, int16*) =									*(int16 *)val;								ret_val = 1;								break;							case TIFF_LONG:							case TIFF_IFD:								*va_arg(ap, uint32*) =									*(uint32 *)val;								ret_val = 1;								break;							case TIFF_SLONG:								*va_arg(ap, int32*) =									*(int32 *)val;								ret_val = 1;								break;							case TIFF_LONG8:							case TIFF_IFD8:								*va_arg(ap, uint64*) =									*(uint64 *)val;								ret_val = 1;								break;							case TIFF_SLONG8:								*va_arg(ap, int64*) =									*(int64 *)val;								ret_val = 1;								break;							case TIFF_RATIONAL:							case TIFF_SRATIONAL:							case TIFF_FLOAT:								*va_arg(ap, float*) =									*(float *)val;								ret_val = 1;								break;							case TIFF_DOUBLE:								*va_arg(ap, double*) =									*(double *)val;								ret_val = 1;								break;							default:								ret_val = 0;								break;							}						}					}
fip->field_passcount
fip
fip
field_passcount
{						if (fip->field_readcount == TIFF_VARIABLE2)							*va_arg(ap, uint32*) = (uint32)tv->count;						else  /* Assume TIFF_VARIABLE */							*va_arg(ap, uint16*) = (uint16)tv->count;						*va_arg(ap, void **) = tv->value;						ret_val = 1;					}
if (fip->field_readcount == TIFF_VARIABLE2)							*va_arg(ap, uint32*) = (uint32)tv->count;
else  /* Assume TIFF_VARIABLE */							*va_arg(ap, uint16*) = (uint16)tv->count;
*va_arg(ap, void **) = tv->value;
ret_val = 1;
ret_val = 1
ret_val
ret_val
1
if (fip->field_tag == TIFFTAG_DOTRANGE						   && strcmp(fip->field_name,"DotRange") == 0) {						/* TODO: This is an evil exception and should not have been						   handled this way ... likely best if we move it into						   the directory structure with an explicit field in 						   libtiff 4.1 and assign it a FIELD_ value */						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[0];						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[1];						ret_val = 1;					} else {						if (fip->field_type == TIFF_ASCII						    || fip->field_readcount == TIFF_VARIABLE						    || fip->field_readcount == TIFF_VARIABLE2						    || fip->field_readcount == TIFF_SPP						    || tv->count > 1) {							*va_arg(ap, void **) = tv->value;							ret_val = 1;						} else {							char *val = (char *)tv->value;							assert( tv->count == 1 );							switch (fip->field_type) {							case TIFF_BYTE:							case TIFF_UNDEFINED:								*va_arg(ap, uint8*) =									*(uint8 *)val;								ret_val = 1;								break;							case TIFF_SBYTE:								*va_arg(ap, int8*) =									*(int8 *)val;								ret_val = 1;								break;							case TIFF_SHORT:								*va_arg(ap, uint16*) =									*(uint16 *)val;								ret_val = 1;								break;							case TIFF_SSHORT:								*va_arg(ap, int16*) =									*(int16 *)val;								ret_val = 1;								break;							case TIFF_LONG:							case TIFF_IFD:								*va_arg(ap, uint32*) =									*(uint32 *)val;								ret_val = 1;								break;							case TIFF_SLONG:								*va_arg(ap, int32*) =									*(int32 *)val;								ret_val = 1;								break;							case TIFF_LONG8:							case TIFF_IFD8:								*va_arg(ap, uint64*) =									*(uint64 *)val;								ret_val = 1;								break;							case TIFF_SLONG8:								*va_arg(ap, int64*) =									*(int64 *)val;								ret_val = 1;								break;							case TIFF_RATIONAL:							case TIFF_SRATIONAL:							case TIFF_FLOAT:								*va_arg(ap, float*) =									*(float *)val;								ret_val = 1;								break;							case TIFF_DOUBLE:								*va_arg(ap, double*) =									*(double *)val;								ret_val = 1;								break;							default:								ret_val = 0;								break;							}						}					}
fip->field_tag == TIFFTAG_DOTRANGE						   && strcmp(fip->field_name,"DotRange") == 0
fip->field_tag == TIFFTAG_DOTRANGE
fip->field_tag
fip
fip
field_tag
TIFFTAG_DOTRANGE
TIFFTAG_DOTRANGE
strcmp(fip->field_name,"DotRange") == 0
strcmp(fip->field_name,"DotRange")
strcmp
strcmp
fip->field_name
fip
fip
field_name
"DotRange"
0
{						/* TODO: This is an evil exception and should not have been						   handled this way ... likely best if we move it into						   the directory structure with an explicit field in 						   libtiff 4.1 and assign it a FIELD_ value */						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[0];						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[1];						ret_val = 1;					}
*va_arg(ap, uint16*) = ((uint16 *)tv->value)[0];
*va_arg(ap, uint16*) = ((uint16 *)tv->value)[1];
ret_val = 1;
ret_val = 1
ret_val
ret_val
1
{						if (fip->field_type == TIFF_ASCII						    || fip->field_readcount == TIFF_VARIABLE						    || fip->field_readcount == TIFF_VARIABLE2						    || fip->field_readcount == TIFF_SPP						    || tv->count > 1) {							*va_arg(ap, void **) = tv->value;							ret_val = 1;						} else {							char *val = (char *)tv->value;							assert( tv->count == 1 );							switch (fip->field_type) {							case TIFF_BYTE:							case TIFF_UNDEFINED:								*va_arg(ap, uint8*) =									*(uint8 *)val;								ret_val = 1;								break;							case TIFF_SBYTE:								*va_arg(ap, int8*) =									*(int8 *)val;								ret_val = 1;								break;							case TIFF_SHORT:								*va_arg(ap, uint16*) =									*(uint16 *)val;								ret_val = 1;								break;							case TIFF_SSHORT:								*va_arg(ap, int16*) =									*(int16 *)val;								ret_val = 1;								break;							case TIFF_LONG:							case TIFF_IFD:								*va_arg(ap, uint32*) =									*(uint32 *)val;								ret_val = 1;								break;							case TIFF_SLONG:								*va_arg(ap, int32*) =									*(int32 *)val;								ret_val = 1;								break;							case TIFF_LONG8:							case TIFF_IFD8:								*va_arg(ap, uint64*) =									*(uint64 *)val;								ret_val = 1;								break;							case TIFF_SLONG8:								*va_arg(ap, int64*) =									*(int64 *)val;								ret_val = 1;								break;							case TIFF_RATIONAL:							case TIFF_SRATIONAL:							case TIFF_FLOAT:								*va_arg(ap, float*) =									*(float *)val;								ret_val = 1;								break;							case TIFF_DOUBLE:								*va_arg(ap, double*) =									*(double *)val;								ret_val = 1;								break;							default:								ret_val = 0;								break;							}						}					}
if (fip->field_type == TIFF_ASCII						    || fip->field_readcount == TIFF_VARIABLE						    || fip->field_readcount == TIFF_VARIABLE2						    || fip->field_readcount == TIFF_SPP						    || tv->count > 1) {							*va_arg(ap, void **) = tv->value;							ret_val = 1;						} else {							char *val = (char *)tv->value;							assert( tv->count == 1 );							switch (fip->field_type) {							case TIFF_BYTE:							case TIFF_UNDEFINED:								*va_arg(ap, uint8*) =									*(uint8 *)val;								ret_val = 1;								break;							case TIFF_SBYTE:								*va_arg(ap, int8*) =									*(int8 *)val;								ret_val = 1;								break;							case TIFF_SHORT:								*va_arg(ap, uint16*) =									*(uint16 *)val;								ret_val = 1;								break;							case TIFF_SSHORT:								*va_arg(ap, int16*) =									*(int16 *)val;								ret_val = 1;								break;							case TIFF_LONG:							case TIFF_IFD:								*va_arg(ap, uint32*) =									*(uint32 *)val;								ret_val = 1;								break;							case TIFF_SLONG:								*va_arg(ap, int32*) =									*(int32 *)val;								ret_val = 1;								break;							case TIFF_LONG8:							case TIFF_IFD8:								*va_arg(ap, uint64*) =									*(uint64 *)val;								ret_val = 1;								break;							case TIFF_SLONG8:								*va_arg(ap, int64*) =									*(int64 *)val;								ret_val = 1;								break;							case TIFF_RATIONAL:							case TIFF_SRATIONAL:							case TIFF_FLOAT:								*va_arg(ap, float*) =									*(float *)val;								ret_val = 1;								break;							case TIFF_DOUBLE:								*va_arg(ap, double*) =									*(double *)val;								ret_val = 1;								break;							default:								ret_val = 0;								break;							}						}
fip->field_type == TIFF_ASCII						    || fip->field_readcount == TIFF_VARIABLE						    || fip->field_readcount == TIFF_VARIABLE2						    || fip->field_readcount == TIFF_SPP						    || tv->count > 1
fip->field_type == TIFF_ASCII						    || fip->field_readcount == TIFF_VARIABLE						    || fip->field_readcount == TIFF_VARIABLE2						    || fip->field_readcount == TIFF_SPP
fip->field_type == TIFF_ASCII						    || fip->field_readcount == TIFF_VARIABLE						    || fip->field_readcount == TIFF_VARIABLE2
fip->field_type == TIFF_ASCII						    || fip->field_readcount == TIFF_VARIABLE
fip->field_type == TIFF_ASCII
fip->field_type
fip
fip
field_type
TIFF_ASCII
TIFF_ASCII
fip->field_readcount == TIFF_VARIABLE
fip->field_readcount
fip
fip
field_readcount
TIFF_VARIABLE
TIFF_VARIABLE
fip->field_readcount == TIFF_VARIABLE2
fip->field_readcount
fip
fip
field_readcount
TIFF_VARIABLE2
TIFF_VARIABLE2
fip->field_readcount == TIFF_SPP
fip->field_readcount
fip
fip
field_readcount
TIFF_SPP
TIFF_SPP
tv->count > 1
tv->count
tv
tv
count
1
{							*va_arg(ap, void **) = tv->value;							ret_val = 1;						}
*va_arg(ap, void **) = tv->value;
ret_val = 1;
ret_val = 1
ret_val
ret_val
1
{							char *val = (char *)tv->value;							assert( tv->count == 1 );							switch (fip->field_type) {							case TIFF_BYTE:							case TIFF_UNDEFINED:								*va_arg(ap, uint8*) =									*(uint8 *)val;								ret_val = 1;								break;							case TIFF_SBYTE:								*va_arg(ap, int8*) =									*(int8 *)val;								ret_val = 1;								break;							case TIFF_SHORT:								*va_arg(ap, uint16*) =									*(uint16 *)val;								ret_val = 1;								break;							case TIFF_SSHORT:								*va_arg(ap, int16*) =									*(int16 *)val;								ret_val = 1;								break;							case TIFF_LONG:							case TIFF_IFD:								*va_arg(ap, uint32*) =									*(uint32 *)val;								ret_val = 1;								break;							case TIFF_SLONG:								*va_arg(ap, int32*) =									*(int32 *)val;								ret_val = 1;								break;							case TIFF_LONG8:							case TIFF_IFD8:								*va_arg(ap, uint64*) =									*(uint64 *)val;								ret_val = 1;								break;							case TIFF_SLONG8:								*va_arg(ap, int64*) =									*(int64 *)val;								ret_val = 1;								break;							case TIFF_RATIONAL:							case TIFF_SRATIONAL:							case TIFF_FLOAT:								*va_arg(ap, float*) =									*(float *)val;								ret_val = 1;								break;							case TIFF_DOUBLE:								*va_arg(ap, double*) =									*(double *)val;								ret_val = 1;								break;							default:								ret_val = 0;								break;							}						}
char *val = (char *)tv->value;
char *val = (char *)tv->value;
char
*val = (char *)tv->value
*
val
= (char *)tv->value
(char *)tv->value
char *
char
*
*
tv->value
tv
tv
value
assert( tv->count == 1 );
assert( tv->count == 1 )
assert
assert
tv->count == 1
tv->count
tv
tv
count
1
switch (fip->field_type) {							case TIFF_BYTE:							case TIFF_UNDEFINED:								*va_arg(ap, uint8*) =									*(uint8 *)val;								ret_val = 1;								break;							case TIFF_SBYTE:								*va_arg(ap, int8*) =									*(int8 *)val;								ret_val = 1;								break;							case TIFF_SHORT:								*va_arg(ap, uint16*) =									*(uint16 *)val;								ret_val = 1;								break;							case TIFF_SSHORT:								*va_arg(ap, int16*) =									*(int16 *)val;								ret_val = 1;								break;							case TIFF_LONG:							case TIFF_IFD:								*va_arg(ap, uint32*) =									*(uint32 *)val;								ret_val = 1;								break;							case TIFF_SLONG:								*va_arg(ap, int32*) =									*(int32 *)val;								ret_val = 1;								break;							case TIFF_LONG8:							case TIFF_IFD8:								*va_arg(ap, uint64*) =									*(uint64 *)val;								ret_val = 1;								break;							case TIFF_SLONG8:								*va_arg(ap, int64*) =									*(int64 *)val;								ret_val = 1;								break;							case TIFF_RATIONAL:							case TIFF_SRATIONAL:							case TIFF_FLOAT:								*va_arg(ap, float*) =									*(float *)val;								ret_val = 1;								break;							case TIFF_DOUBLE:								*va_arg(ap, double*) =									*(double *)val;								ret_val = 1;								break;							default:								ret_val = 0;								break;							}
fip->field_type
fip
fip
field_type
{							case TIFF_BYTE:							case TIFF_UNDEFINED:								*va_arg(ap, uint8*) =									*(uint8 *)val;								ret_val = 1;								break;							case TIFF_SBYTE:								*va_arg(ap, int8*) =									*(int8 *)val;								ret_val = 1;								break;							case TIFF_SHORT:								*va_arg(ap, uint16*) =									*(uint16 *)val;								ret_val = 1;								break;							case TIFF_SSHORT:								*va_arg(ap, int16*) =									*(int16 *)val;								ret_val = 1;								break;							case TIFF_LONG:							case TIFF_IFD:								*va_arg(ap, uint32*) =									*(uint32 *)val;								ret_val = 1;								break;							case TIFF_SLONG:								*va_arg(ap, int32*) =									*(int32 *)val;								ret_val = 1;								break;							case TIFF_LONG8:							case TIFF_IFD8:								*va_arg(ap, uint64*) =									*(uint64 *)val;								ret_val = 1;								break;							case TIFF_SLONG8:								*va_arg(ap, int64*) =									*(int64 *)val;								ret_val = 1;								break;							case TIFF_RATIONAL:							case TIFF_SRATIONAL:							case TIFF_FLOAT:								*va_arg(ap, float*) =									*(float *)val;								ret_val = 1;								break;							case TIFF_DOUBLE:								*va_arg(ap, double*) =									*(double *)val;								ret_val = 1;								break;							default:								ret_val = 0;								break;							}
case TIFF_BYTE:
TIFF_BYTE
TIFF_BYTE
case TIFF_UNDEFINED:
TIFF_UNDEFINED
TIFF_UNDEFINED
*va_arg(ap, uint8*) =									*(uint8 *)val;
ret_val = 1;
ret_val = 1
ret_val
ret_val
1
break;
case TIFF_SBYTE:
TIFF_SBYTE
TIFF_SBYTE
*va_arg(ap, int8*) =									*(int8 *)val;
ret_val = 1;
ret_val = 1
ret_val
ret_val
1
break;
case TIFF_SHORT:
TIFF_SHORT
TIFF_SHORT
*va_arg(ap, uint16*) =									*(uint16 *)val;
ret_val = 1;
ret_val = 1
ret_val
ret_val
1
break;
case TIFF_SSHORT:
TIFF_SSHORT
TIFF_SSHORT
*va_arg(ap, int16*) =									*(int16 *)val;
ret_val = 1;
ret_val = 1
ret_val
ret_val
1
break;
case TIFF_LONG:
TIFF_LONG
TIFF_LONG
case TIFF_IFD:
TIFF_IFD
TIFF_IFD
*va_arg(ap, uint32*) =									*(uint32 *)val;
ret_val = 1;
ret_val = 1
ret_val
ret_val
1
break;
case TIFF_SLONG:
TIFF_SLONG
TIFF_SLONG
*va_arg(ap, int32*) =									*(int32 *)val;
ret_val = 1;
ret_val = 1
ret_val
ret_val
1
break;
case TIFF_LONG8:
TIFF_LONG8
TIFF_LONG8
case TIFF_IFD8:
TIFF_IFD8
TIFF_IFD8
*va_arg(ap, uint64*) =									*(uint64 *)val;
ret_val = 1;
ret_val = 1
ret_val
ret_val
1
break;
case TIFF_SLONG8:
TIFF_SLONG8
TIFF_SLONG8
*va_arg(ap, int64*) =									*(int64 *)val;
ret_val = 1;
ret_val = 1
ret_val
ret_val
1
break;
case TIFF_RATIONAL:
TIFF_RATIONAL
TIFF_RATIONAL
case TIFF_SRATIONAL:
TIFF_SRATIONAL
TIFF_SRATIONAL
case TIFF_FLOAT:
TIFF_FLOAT
TIFF_FLOAT
*va_arg(ap, float*) =									*(float *)val;
ret_val = 1;
ret_val = 1
ret_val
ret_val
1
break;
case TIFF_DOUBLE:
TIFF_DOUBLE
TIFF_DOUBLE
*va_arg(ap, double*) =									*(double *)val;
ret_val = 1;
ret_val = 1
ret_val
ret_val
1
break;
default:
ret_val = 0;
ret_val = 0
ret_val
ret_val
0
break;
break;
return(ret_val);
(ret_val)
ret_val
ret_val
-----joern-----
(555,151,0)
(333,463,0)
(113,468,0)
(59,278,0)
(221,377,0)
(91,670,0)
(398,8,0)
(308,59,0)
(148,131,0)
(495,132,0)
(238,197,0)
(565,338,0)
(488,105,0)
(415,344,0)
(684,338,0)
(570,278,0)
(697,338,0)
(566,476,0)
(29,364,0)
(69,86,0)
(278,136,0)
(365,342,0)
(284,338,0)
(27,102,0)
(411,328,0)
(156,375,0)
(578,439,0)
(306,278,0)
(239,86,0)
(88,338,0)
(699,131,0)
(606,86,0)
(40,99,0)
(660,618,0)
(598,638,0)
(297,255,0)
(469,86,0)
(357,338,0)
(667,609,0)
(501,594,0)
(65,681,0)
(398,509,0)
(382,278,0)
(547,131,0)
(567,159,0)
(698,68,0)
(70,674,0)
(137,332,0)
(641,432,0)
(249,57,0)
(36,618,0)
(532,180,0)
(159,278,0)
(566,278,0)
(429,86,0)
(184,387,0)
(224,338,0)
(131,289,0)
(341,506,0)
(397,143,0)
(240,278,0)
(554,699,0)
(607,579,0)
(134,86,0)
(611,95,0)
(310,320,0)
(350,231,0)
(281,86,0)
(463,131,0)
(316,121,0)
(615,630,0)
(152,551,0)
(485,338,0)
(398,35,0)
(685,524,0)
(201,270,0)
(44,557,0)
(61,524,0)
(266,121,0)
(11,346,0)
(311,69,0)
(214,409,0)
(354,146,0)
(633,448,0)
(593,3,0)
(68,246,0)
(377,86,0)
(301,593,0)
(18,86,0)
(83,318,0)
(404,289,0)
(450,197,0)
(581,509,0)
(63,328,0)
(656,667,0)
(558,445,0)
(514,231,0)
(59,308,0)
(318,91,0)
(320,310,0)
(448,120,0)
(472,455,0)
(45,357,0)
(451,250,0)
(105,134,0)
(277,696,0)
(552,316,0)
(547,245,0)
(37,497,0)
(662,26,0)
(134,105,0)
(97,151,0)
(98,99,0)
(366,665,0)
(24,388,0)
(194,149,0)
(525,344,0)
(251,127,0)
(597,551,0)
(108,278,0)
(96,278,0)
(48,387,0)
(368,227,0)
(68,647,0)
(585,338,0)
(574,224,0)
(489,86,0)
(262,86,0)
(142,455,0)
(607,86,0)
(575,547,0)
(10,500,0)
(249,131,0)
(409,88,0)
(25,86,0)
(111,121,0)
(584,86,0)
(138,131,0)
(266,591,0)
(197,450,0)
(197,278,0)
(107,586,0)
(283,59,0)
(103,377,0)
(318,618,0)
(116,95,0)
(145,86,0)
(80,451,0)
(9,548,0)
(117,308,0)
(487,484,0)
(149,86,0)
(203,384,0)
(167,638,0)
(477,86,0)
(105,278,0)
(571,86,0)
(151,555,0)
(329,24,0)
(354,497,0)
(177,338,0)
(225,346,0)
(409,480,0)
(286,379,0)
(428,480,0)
(87,8,0)
(419,205,0)
(259,387,0)
(90,378,0)
(198,86,0)
(461,316,0)
(448,444,0)
(591,620,0)
(330,338,0)
(409,136,0)
(452,86,0)
(4,387,0)
(570,86,0)
(490,402,0)
(151,181,0)
(593,618,0)
(542,278,0)
(159,201,0)
(34,59,0)
(445,108,0)
(501,131,0)
(588,10,0)
(408,338,0)
(208,459,0)
(409,498,0)
(507,86,0)
(621,86,0)
(464,277,0)
(58,87,0)
(416,429,0)
(680,417,0)
(645,328,0)
(568,628,0)
(444,35,0)
(563,630,0)
(620,591,0)
(310,332,0)
(545,143,0)
(216,231,0)
(667,627,0)
(33,123,0)
(422,388,0)
(198,278,0)
(342,228,0)
(187,557,0)
(617,526,0)
(284,671,0)
(628,86,0)
(275,302,0)
(382,86,0)
(190,30,0)
(232,86,0)
(499,410,0)
(30,388,0)
(399,596,0)
(423,558,0)
(233,86,0)
(131,600,0)
(484,549,0)
(54,224,0)
(586,278,0)
(682,278,0)
(96,243,0)
(687,537,0)
(155,549,0)
(352,113,0)
(508,86,0)
(160,390,0)
(339,5,0)
(50,303,0)
(188,618,0)
(193,134,0)
(104,338,0)
(289,131,0)
(3,593,0)
(486,601,0)
(621,278,0)
(179,8,0)
(64,671,0)
(381,86,0)
(457,170,0)
(178,618,0)
(260,123,0)
(74,86,0)
(94,338,0)
(511,278,0)
(19,121,0)
(52,86,0)
(2,86,0)
(250,121,0)
(433,246,0)
(319,36,0)
(500,437,0)
(199,86,0)
(242,388,0)
(695,387,0)
(133,123,0)
(360,600,0)
(651,504,0)
(57,338,0)
(473,451,0)
(293,239,0)
(326,114,0)
(192,621,0)
(455,142,0)
(522,86,0)
(436,86,0)
(392,324,0)
(421,25,0)
(292,243,0)
(616,86,0)
(150,526,0)
(463,100,0)
(484,136,0)
(556,86,0)
(432,641,0)
(679,19,0)
(494,338,0)
(6,522,0)
(614,338,0)
(191,653,0)
(359,188,0)
(470,477,0)
(114,260,0)
(372,86,0)
(401,30,0)
(396,287,0)
(682,86,0)
(610,511,0)
(242,603,0)
(462,86,0)
(561,86,0)
(144,181,0)
(655,476,0)
(409,44,0)
(267,86,0)
(644,387,0)
(440,278,0)
(456,260,0)
(100,338,0)
(33,552,0)
(547,575,0)
(65,86,0)
(409,170,0)
(630,615,0)
(374,278,0)
(415,86,0)
(548,86,0)
(217,86,0)
(157,498,0)
(153,439,0)
(130,86,0)
(524,663,0)
(544,240,0)
(558,437,0)
(95,131,0)
(653,287,0)
(210,271,0)
(51,278,0)
(55,251,0)
(509,398,0)
(353,108,0)
(166,665,0)
(552,33,0)
(409,302,0)
(344,278,0)
(186,180,0)
(180,532,0)
(47,497,0)
(209,384,0)
(196,500,0)
(38,379,0)
(111,460,0)
(114,121,0)
(671,64,0)
(589,86,0)
(636,660,0)
(140,502,0)
(272,660,0)
(535,128,0)
(274,318,0)
(500,10,0)
(229,121,0)
(35,398,0)
(67,198,0)
(235,501,0)
(623,271,0)
(347,600,0)
(613,251,0)
(261,86,0)
(316,552,0)
(417,102,0)
(260,114,0)
(592,35,0)
(92,155,0)
(331,409,0)
(538,86,0)
(594,501,0)
(402,86,0)
(663,287,0)
(413,497,0)
(386,324,0)
(599,148,0)
(171,250,0)
(661,188,0)
(609,667,0)
(7,121,0)
(572,621,0)
(473,246,0)
(169,69,0)
(308,86,0)
(508,278,0)
(204,92,0)
(576,181,0)
(271,623,0)
(14,387,0)
(91,318,0)
(84,220,0)
(312,86,0)
(133,620,0)
(108,445,0)
(124,508,0)
(404,618,0)
(243,86,0)
(230,465,0)
(427,468,0)
(630,278,0)
(403,86,0)
(135,338,0)
(409,504,0)
(325,118,0)
(358,505,0)
(278,603,0)
(504,136,0)
(252,120,0)
(676,86,0)
(205,618,0)
(375,133,0)
(380,86,0)
(25,278,0)
(535,278,0)
(370,566,0)
(273,338,0)
(56,205,0)
(503,86,0)
(57,249,0)
(591,266,0)
(451,473,0)
(321,422,0)
(172,24,0)
(123,133,0)
(678,593,0)
(642,239,0)
(307,312,0)
(542,86,0)
(432,270,0)
(391,111,0)
(128,86,0)
(464,278,0)
(635,538,0)
(39,653,0)
(476,566,0)
(379,86,0)
(349,338,0)
(389,535,0)
(347,3,0)
(379,278,0)
(207,86,0)
(548,278,0)
(632,146,0)
(250,451,0)
(174,19,0)
(448,8,0)
(694,86,0)
(253,86,0)
(279,136,0)
(41,663,0)
(277,464,0)
(154,148,0)
(165,682,0)
(450,86,0)
(618,354,0)
(420,86,0)
(268,86,0)
(371,338,0)
(683,86,0)
(383,111,0)
(122,465,0)
(690,547,0)
(75,198,0)
(71,537,0)
(409,465,0)
(119,628,0)
(155,92,0)
(255,121,0)
(677,86,0)
(627,667,0)
(641,674,0)
(62,114,0)
(477,278,0)
(362,159,0)
(337,178,0)
(173,266,0)
(453,88,0)
(180,511,0)
(385,86,0)
(458,674,0)
(373,364,0)
(312,278,0)
(175,86,0)
(336,44,0)
(498,338,0)
(188,342,0)
(664,357,0)
(129,44,0)
(143,26,0)
(110,404,0)
(459,86,0)
(112,354,0)
(16,86,0)
(201,159,0)
(409,224,0)
(582,498,0)
(681,65,0)
(650,136,0)
(303,86,0)
(430,86,0)
(93,278,0)
(409,324,0)
(148,599,0)
(659,86,0)
(653,388,0)
(407,86,0)
(523,316,0)
(412,444,0)
(237,86,0)
(603,242,0)
(684,148,0)
(332,121,0)
(82,505,0)
(146,278,0)
(539,662,0)
(231,514,0)
(666,681,0)
(254,146,0)
(454,338,0)
(289,53,0)
(517,86,0)
(102,127,0)
(241,537,0)
(480,338,0)
(442,600,0)
(414,591,0)
(377,278,0)
(463,333,0)
(335,638,0)
(533,86,0)
(586,86,0)
(133,375,0)
(417,618,0)
(121,136,0)
(66,338,0)
(467,56,0)
(300,249,0)
(601,121,0)
(356,417,0)
(496,641,0)
(526,338,0)
(434,439,0)
(243,96,0)
(10,278,0)
(615,497,0)
(109,167,0)
(395,374,0)
(628,278,0)
(343,86,0)
(1,96,0)
(218,258,0)
(440,86,0)
(42,382,0)
(256,310,0)
(546,86,0)
(532,99,0)
(348,596,0)
(534,105,0)
(298,65,0)
(32,682,0)
(445,558,0)
(314,374,0)
(271,234,0)
(447,229,0)
(595,681,0)
(602,538,0)
(579,607,0)
(315,86,0)
(583,132,0)
(699,164,0)
(334,120,0)
(287,455,0)
(125,136,0)
(405,647,0)
(182,86,0)
(515,86,0)
(12,535,0)
(3,347,0)
(77,199,0)
(622,422,0)
(375,255,0)
(516,86,0)
(550,542,0)
(559,51,0)
(409,596,0)
(626,268,0)
(17,86,0)
(432,532,0)
(268,278,0)
(505,278,0)
(435,332,0)
(541,509,0)
(637,277,0)
(234,271,0)
(287,653,0)
(255,375,0)
(354,618,0)
(247,566,0)
(189,485,0)
(491,30,0)
(95,425,0)
(139,346,0)
(270,201,0)
(288,522,0)
(701,364,0)
(645,8,0)
(378,86,0)
(482,127,0)
(355,155,0)
(437,558,0)
(163,432,0)
(502,278,0)
(211,504,0)
(115,8,0)
(263,502,0)
(492,468,0)
(437,500,0)
(519,338,0)
(381,388,0)
(72,86,0)
(699,349,0)
(378,278,0)
(660,127,0)
(446,615,0)
(444,167,0)
(94,501,0)
(639,86,0)
(264,86,0)
(328,645,0)
(673,86,0)
(509,278,0)
(304,86,0)
(15,86,0)
(438,696,0)
(53,289,0)
(167,109,0)
(23,240,0)
(89,229,0)
(551,278,0)
(168,382,0)
(538,278,0)
(459,278,0)
(120,448,0)
(506,278,0)
(147,86,0)
(323,570,0)
(30,549,0)
(551,86,0)
(374,86,0)
(206,86,0)
(691,687,0)
(365,26,0)
(625,630,0)
(493,118,0)
(222,438,0)
(700,93,0)
(5,86,0)
(100,463,0)
(675,477,0)
(409,485,0)
(142,549,0)
(332,310,0)
(569,250,0)
(213,402,0)
(596,338,0)
(410,86,0)
(215,484,0)
(431,86,0)
(527,338,0)
(670,91,0)
(429,388,0)
(126,268,0)
(406,338,0)
(162,178,0)
(78,344,0)
(418,86,0)
(294,99,0)
(612,86,0)
(212,511,0)
(132,278,0)
(543,338,0)
(24,287,0)
(443,249,0)
(587,136,0)
(437,86,0)
(249,443,0)
(317,387,0)
(620,133,0)
(671,284,0)
(424,136,0)
(141,378,0)
(351,607,0)
(231,121,0)
(520,463,0)
(608,36,0)
(195,364,0)
(240,86,0)
(479,338,0)
(258,278,0)
(363,205,0)
(289,404,0)
(702,170,0)
(409,143,0)
(502,5,0)
(205,56,0)
(665,438,0)
(658,136,0)
(409,357,0)
(647,68,0)
(663,121,0)
(181,151,0)
(652,506,0)
(271,131,0)
(236,31,0)
(530,149,0)
(531,440,0)
(36,92,0)
(649,302,0)
(21,460,0)
(5,502,0)
(409,526,0)
(449,258,0)
(161,645,0)
(28,638,0)
(342,365,0)
(148,684,0)
(475,601,0)
(512,312,0)
(521,381,0)
(693,338,0)
(102,27,0)
(118,278,0)
(291,303,0)
(481,663,0)
(409,390,0)
(603,278,0)
(305,638,0)
(109,93,0)
(579,278,0)
(483,86,0)
(313,86,0)
(258,410,0)
(287,663,0)
(536,338,0)
(441,255,0)
(176,570,0)
(128,535,0)
(269,440,0)
(537,618,0)
(689,450,0)
(478,88,0)
(465,346,0)
(228,342,0)
(674,278,0)
(199,278,0)
(60,86,0)
(201,468,0)
(654,86,0)
(170,322,0)
(553,242,0)
(202,338,0)
(287,24,0)
(688,548,0)
(361,128,0)
(624,542,0)
(56,467,0)
(56,662,0)
(132,86,0)
(376,555,0)
(580,532,0)
(30,121,0)
(340,96,0)
(223,86,0)
(476,468,0)
(466,86,0)
(282,10,0)
(400,51,0)
(668,455,0)
(290,197,0)
(513,387,0)
(665,278,0)
(562,338,0)
(226,3,0)
(564,586,0)
(555,278,0)
(511,180,0)
(618,364,0)
(146,354,0)
(120,278,0)
(151,97,0)
(422,31,0)
(79,242,0)
(620,687,0)
(344,415,0)
(384,86,0)
(537,687,0)
(643,398,0)
(49,25,0)
(367,338,0)
(296,365,0)
(524,121,0)
(647,121,0)
(149,278,0)
(410,258,0)
(69,278,0)
(640,387,0)
(529,579,0)
(118,86,0)
(245,547,0)
(667,131,0)
(506,86,0)
(73,434,0)
(229,320,0)
(346,86,0)
(501,94,0)
(227,672,0)
(657,464,0)
(324,338,0)
(474,445,0)
(528,108,0)
(518,671,0)
(295,270,0)
(605,86,0)
(646,415,0)
(692,86,0)
(246,68,0)
(687,620,0)
(634,199,0)
(178,322,0)
(604,514,0)
(101,618,0)
(439,388,0)
(302,338,0)
(409,251,0)
(394,167,0)
(671,131,0)
(575,338,0)
(577,287,0)
(425,338,0)
(185,266,0)
(265,459,0)
(505,86,0)
(219,86,0)
(641,468,0)
(426,86,0)
(46,201,0)
(239,278,0)
(95,116,0)
(393,86,0)
(158,552,0)
(123,33,0)
(309,142,0)
(369,387,0)
(31,422,0)
(276,387,0)
(438,665,0)
(342,188,0)
(164,699,0)
(703,86,0)
(200,579,0)
(303,278,0)
(681,278,0)
(540,390,0)
(627,338,0)
(299,86,0)
(106,338,0)
(81,485,0)
(439,434,0)
(425,95,0)
(590,227,0)
(328,278,0)
(402,278,0)
(320,229,0)
(560,109,0)
(280,86,0)
(444,448,0)
(244,338,0)
(43,480,0)
(455,287,0)
(287,557,0)
(384,278,0)
(85,86,0)
(102,417,0)
(248,86,0)
(13,555,0)
(327,86,0)
(662,56,0)
(181,278,0)
(629,86,0)
(257,86,0)
(22,97,0)
(234,338,0)
(619,47,0)
(669,99,0)
(20,93,0)
(648,647,0)
(349,699,0)
(92,36,0)
(183,86,0)
(76,86,0)
(246,473,0)
(471,86,0)
(93,109,0)
(390,338,0)
(460,111,0)
(674,641,0)
(123,260,0)
(121,30,0)
(285,338,0)
(686,508,0)
(345,464,0)
(91,127,0)
(663,524,0)
(522,278,0)
(0,86,0)
(510,404,0)
(667,131,1)
(9,631,1)
(615,497,1)
(55,660,1)
(5,502,1)
(331,659,1)
(538,278,1)
(508,278,1)
(566,278,1)
(477,278,1)
(253,199,1)
(674,278,1)
(310,256,1)
(328,278,1)
(142,309,1)
(260,456,1)
(651,211,1)
(93,20,1)
(644,51,1)
(492,427,1)
(54,425,1)
(504,651,1)
(475,347,1)
(308,59,1)
(384,203,1)
(205,363,1)
(361,535,1)
(440,531,1)
(559,400,1)
(682,278,1)
(295,432,1)
(698,647,1)
(145,5,1)
(464,657,1)
(655,468,1)
(92,36,1)
(6,288,1)
(480,428,1)
(619,573,1)
(121,30,1)
(68,698,1)
(537,241,1)
(618,354,1)
(682,165,1)
(314,395,1)
(432,532,1)
(522,6,1)
(675,631,1)
(645,328,1)
(468,492,1)
(303,50,1)
(331,253,1)
(331,584,1)
(506,341,1)
(512,631,1)
(33,123,1)
(411,63,1)
(398,643,1)
(201,468,1)
(2,374,1)
(620,687,1)
(316,121,1)
(186,511,1)
(664,45,1)
(381,521,1)
(97,151,1)
(195,697,1)
(133,375,1)
(195,562,1)
(261,621,1)
(302,275,1)
(348,399,1)
(362,567,1)
(397,545,1)
(455,142,1)
(155,92,1)
(63,161,1)
(395,631,1)
(292,96,1)
(199,278,1)
(80,250,1)
(513,51,1)
(432,163,1)
(649,349,1)
(90,631,1)
(325,493,1)
(409,526,1)
(233,243,1)
(73,439,1)
(85,402,1)
(288,429,1)
(622,321,1)
(390,540,1)
(111,391,1)
(615,630,1)
(448,633,1)
(195,251,1)
(544,28,1)
(189,57,1)
(178,337,1)
(100,463,1)
(554,601,1)
(691,537,1)
(484,487,1)
(237,570,1)
(365,296,1)
(238,290,1)
(560,93,1)
(583,631,1)
(331,343,1)
(345,438,1)
(133,620,1)
(39,320,1)
(444,167,1)
(151,555,1)
(501,131,1)
(273,224,1)
(555,376,1)
(287,455,1)
(107,631,1)
(30,549,1)
(656,601,1)
(433,68,1)
(647,405,1)
(149,194,1)
(178,618,1)
(83,274,1)
(331,673,1)
(589,586,1)
(190,7,1)
(344,278,1)
(144,576,1)
(7,484,1)
(566,247,1)
(221,103,1)
(430,14,1)
(653,388,1)
(662,56,1)
(500,10,1)
(36,618,1)
(667,609,1)
(551,278,1)
(167,109,1)
(255,121,1)
(91,670,1)
(501,235,1)
(679,174,1)
(96,340,1)
(398,8,1)
(496,674,1)
(409,498,1)
(574,54,1)
(521,631,1)
(374,278,1)
(347,3,1)
(143,397,1)
(309,24,1)
(278,603,1)
(331,262,1)
(31,236,1)
(597,152,1)
(575,547,1)
(331,237,1)
(216,19,1)
(46,159,1)
(399,684,1)
(318,83,1)
(1,607,1)
(142,549,1)
(423,445,1)
(339,502,1)
(270,201,1)
(354,112,1)
(647,121,1)
(146,254,1)
(118,325,1)
(613,55,1)
(579,200,1)
(604,231,1)
(158,316,1)
(114,326,1)
(444,448,1)
(229,89,1)
(471,477,1)
(671,64,1)
(506,278,1)
(277,464,1)
(230,122,1)
(28,645,1)
(123,133,1)
(342,188,1)
(79,306,1)
(195,367,1)
(446,47,1)
(438,665,1)
(474,108,1)
(21,111,1)
(586,564,1)
(470,675,1)
(671,518,1)
(528,500,1)
(413,37,1)
(555,278,1)
(476,468,1)
(532,180,1)
(243,292,1)
(497,413,1)
(284,671,1)
(409,143,1)
(409,485,1)
(87,58,1)
(217,382,1)
(331,466,1)
(681,595,1)
(570,176,1)
(102,417,1)
(688,9,1)
(446,497,1)
(197,278,1)
(176,323,1)
(409,44,1)
(242,553,1)
(404,618,1)
(449,218,1)
(93,278,1)
(408,596,1)
(68,647,1)
(409,465,1)
(331,372,1)
(529,631,1)
(550,624,1)
(459,208,1)
(444,412,1)
(82,358,1)
(514,604,1)
(166,97,1)
(320,310,1)
(312,278,1)
(365,342,1)
(0,149,1)
(596,348,1)
(331,683,1)
(465,230,1)
(78,525,1)
(440,278,1)
(531,269,1)
(343,384,1)
(301,131,1)
(573,155,1)
(320,229,1)
(318,618,1)
(584,377,1)
(30,401,1)
(422,388,1)
(134,105,1)
(287,653,1)
(624,631,1)
(5,339,1)
(400,631,1)
(331,393,1)
(524,61,1)
(312,307,1)
(663,121,1)
(567,295,1)
(336,287,1)
(372,268,1)
(367,498,1)
(409,357,1)
(19,679,1)
(409,88,1)
(379,286,1)
(611,601,1)
(677,312,1)
(447,631,1)
(331,85,1)
(236,422,1)
(669,476,1)
(490,631,1)
(104,526,1)
(23,544,1)
(188,618,1)
(249,131,1)
(444,35,1)
(654,25,1)
(89,447,1)
(404,110,1)
(110,510,1)
(268,126,1)
(272,636,1)
(498,582,1)
(463,333,1)
(544,434,1)
(51,559,1)
(448,120,1)
(430,317,1)
(111,121,1)
(331,219,1)
(14,369,1)
(351,579,1)
(621,192,1)
(368,460,1)
(415,646,1)
(342,228,1)
(581,592,1)
(396,577,1)
(119,631,1)
(132,278,1)
(247,370,1)
(516,239,1)
(331,471,1)
(445,108,1)
(108,353,1)
(430,184,1)
(148,154,1)
(350,216,1)
(154,601,1)
(42,538,1)
(47,497,1)
(260,114,1)
(266,173,1)
(205,618,1)
(445,474,1)
(106,357,1)
(38,631,1)
(409,331,1)
(275,649,1)
(62,552,1)
(49,421,1)
(546,440,1)
(625,563,1)
(331,589,1)
(191,39,1)
(324,392,1)
(209,631,1)
(198,278,1)
(212,580,1)
(92,204,1)
(331,182,1)
(405,648,1)
(460,21,1)
(282,588,1)
(686,631,1)
(331,654,1)
(409,251,1)
(200,529,1)
(331,516,1)
(242,388,1)
(464,278,1)
(495,583,1)
(389,12,1)
(331,217,1)
(31,422,1)
(198,67,1)
(509,541,1)
(290,631,1)
(645,8,1)
(662,539,1)
(128,535,1)
(207,628,1)
(628,568,1)
(525,631,1)
(226,593,1)
(59,278,1)
(542,278,1)
(47,619,1)
(159,362,1)
(642,293,1)
(240,23,1)
(357,664,1)
(195,565,1)
(331,0,1)
(435,137,1)
(572,631,1)
(552,316,1)
(258,278,1)
(316,461,1)
(608,618,1)
(117,59,1)
(607,579,1)
(331,2,1)
(58,35,1)
(552,158,1)
(410,499,1)
(660,618,1)
(97,22,1)
(607,351,1)
(319,608,1)
(131,289,1)
(458,70,1)
(570,278,1)
(487,215,1)
(578,631,1)
(222,665,1)
(680,356,1)
(331,187,1)
(352,270,1)
(548,688,1)
(58,444,1)
(310,332,1)
(568,119,1)
(391,383,1)
(108,278,1)
(311,169,1)
(50,291,1)
(409,504,1)
(101,615,1)
(505,82,1)
(545,365,1)
(231,121,1)
(88,478,1)
(120,278,1)
(265,631,1)
(473,451,1)
(537,618,1)
(579,278,1)
(349,699,1)
(331,313,1)
(539,56,1)
(331,426,1)
(695,644,1)
(456,114,1)
(577,653,1)
(485,81,1)
(637,464,1)
(181,144,1)
(122,320,1)
(30,388,1)
(170,457,1)
(254,632,1)
(437,500,1)
(45,94,1)
(219,97,1)
(450,197,1)
(409,170,1)
(239,278,1)
(699,164,1)
(379,278,1)
(377,278,1)
(331,431,1)
(61,685,1)
(630,625,1)
(298,681,1)
(412,448,1)
(118,278,1)
(331,571,1)
(547,131,1)
(51,278,1)
(634,77,1)
(120,334,1)
(10,282,1)
(37,465,1)
(409,480,1)
(173,185,1)
(430,695,1)
(328,411,1)
(181,278,1)
(564,107,1)
(586,278,1)
(340,1,1)
(331,145,1)
(643,509,1)
(25,49,1)
(201,159,1)
(195,406,1)
(289,53,1)
(210,601,1)
(218,134,1)
(13,128,1)
(501,594,1)
(141,90,1)
(331,232,1)
(149,278,1)
(353,528,1)
(352,432,1)
(434,439,1)
(580,31,1)
(126,626,1)
(702,178,1)
(156,255,1)
(331,261,1)
(481,41,1)
(652,31,1)
(87,8,1)
(409,390,1)
(274,102,1)
(441,260,1)
(684,148,1)
(240,278,1)
(296,342,1)
(114,121,1)
(409,302,1)
(65,681,1)
(331,195,1)
(535,389,1)
(326,62,1)
(235,601,1)
(414,266,1)
(197,238,1)
(283,34,1)
(140,65,1)
(606,506,1)
(434,73,1)
(363,419,1)
(534,488,1)
(256,332,1)
(271,131,1)
(32,631,1)
(505,278,1)
(461,523,1)
(563,446,1)
(514,231,1)
(473,246,1)
(195,273,1)
(224,574,1)
(231,350,1)
(518,601,1)
(169,631,1)
(617,150,1)
(69,278,1)
(180,511,1)
(195,408,1)
(35,398,1)
(48,51,1)
(432,270,1)
(569,19,1)
(331,430,1)
(204,36,1)
(332,121,1)
(20,700,1)
(188,661,1)
(510,138,1)
(163,641,1)
(331,615,1)
(341,652,1)
(415,344,1)
(354,146,1)
(393,522,1)
(148,131,1)
(329,396,1)
(182,682,1)
(635,631,1)
(323,381,1)
(344,78,1)
(331,257,1)
(187,44,1)
(19,121,1)
(478,453,1)
(287,663,1)
(666,450,1)
(174,155,1)
(153,578,1)
(523,473,1)
(484,549,1)
(307,512,1)
(195,330,1)
(25,278,1)
(234,271,1)
(168,42,1)
(103,631,1)
(386,100,1)
(195,104,1)
(3,226,1)
(576,555,1)
(448,8,1)
(271,210,1)
(258,449,1)
(439,388,1)
(331,15,1)
(511,610,1)
(377,221,1)
(105,278,1)
(378,141,1)
(33,552,1)
(394,434,1)
(161,87,1)
(620,591,1)
(502,278,1)
(252,645,1)
(683,69,1)
(195,143,1)
(631,460,1)
(595,666,1)
(366,166,1)
(383,121,1)
(401,491,1)
(673,508,1)
(477,470,1)
(208,265,1)
(657,345,1)
(250,171,1)
(375,255,1)
(44,129,1)
(384,278,1)
(331,60,1)
(263,140,1)
(417,680,1)
(659,378,1)
(641,674,1)
(287,24,1)
(699,131,1)
(665,278,1)
(382,168,1)
(565,88,1)
(71,591,1)
(155,355,1)
(227,590,1)
(151,181,1)
(123,260,1)
(540,160,1)
(500,196,1)
(630,278,1)
(105,534,1)
(463,520,1)
(277,637,1)
(409,224,1)
(251,613,1)
(109,93,1)
(355,92,1)
(215,504,1)
(652,669,1)
(687,691,1)
(195,106,1)
(172,329,1)
(59,283,1)
(547,690,1)
(271,623,1)
(646,344,1)
(195,170,1)
(590,368,1)
(134,193,1)
(150,601,1)
(562,390,1)
(138,33,1)
(146,278,1)
(128,361,1)
(65,298,1)
(571,505,1)
(300,601,1)
(508,124,1)
(109,560,1)
(211,278,1)
(524,121,1)
(687,537,1)
(420,551,1)
(246,433,1)
(438,222,1)
(499,258,1)
(674,458,1)
(592,444,1)
(199,634,1)
(668,142,1)
(476,566,1)
(96,278,1)
(232,410,1)
(699,554,1)
(535,278,1)
(402,213,1)
(697,485,1)
(15,379,1)
(155,549,1)
(538,602,1)
(195,371,1)
(409,324,1)
(551,597,1)
(627,667,1)
(700,394,1)
(374,314,1)
(162,33,1)
(112,146,1)
(689,197,1)
(194,530,1)
(330,324,1)
(36,319,1)
(56,205,1)
(382,278,1)
(250,121,1)
(113,468,1)
(115,179,1)
(427,532,1)
(193,105,1)
(331,207,1)
(422,622,1)
(636,91,1)
(509,278,1)
(601,486,1)
(10,278,1)
(378,278,1)
(213,490,1)
(410,258,1)
(266,121,1)
(553,79,1)
(633,120,1)
(257,308,1)
(631,227,1)
(439,153,1)
(137,229,1)
(95,116,1)
(626,631,1)
(663,524,1)
(196,10,1)
(416,631,1)
(75,631,1)
(229,121,1)
(268,278,1)
(542,550,1)
(334,252,1)
(370,655,1)
(201,46,1)
(12,631,1)
(129,336,1)
(522,278,1)
(246,68,1)
(359,662,1)
(502,263,1)
(429,388,1)
(493,631,1)
(157,234,1)
(41,455,1)
(491,190,1)
(593,678,1)
(354,497,1)
(459,278,1)
(22,151,1)
(429,416,1)
(185,375,1)
(95,131,1)
(331,420,1)
(60,548,1)
(582,157,1)
(402,278,1)
(541,581,1)
(356,514,1)
(159,278,1)
(694,459,1)
(419,473,1)
(690,601,1)
(451,80,1)
(603,242,1)
(67,75,1)
(332,435,1)
(102,27,1)
(665,366,1)
(601,121,1)
(641,468,1)
(432,641,1)
(455,668,1)
(381,388,1)
(430,51,1)
(331,677,1)
(655,113,1)
(621,278,1)
(591,266,1)
(648,451,1)
(291,631,1)
(171,569,1)
(24,388,1)
(530,631,1)
(681,278,1)
(81,189,1)
(241,71,1)
(398,509,1)
(431,240,1)
(409,596,1)
(472,142,1)
(95,611,1)
(593,618,1)
(289,404,1)
(463,131,1)
(91,318,1)
(331,233,1)
(369,51,1)
(148,599,1)
(455,472,1)
(426,303,1)
(313,542,1)
(375,156,1)
(94,501,1)
(671,131,1)
(486,475,1)
(428,43,1)
(591,414,1)
(331,546,1)
(667,656,1)
(520,601,1)
(460,111,1)
(453,627,1)
(255,297,1)
(69,311,1)
(249,300,1)
(262,132,1)
(249,443,1)
(24,172,1)
(337,162,1)
(124,686,1)
(219,277,1)
(179,167,1)
(588,631,1)
(239,642,1)
(488,631,1)
(660,272,1)
(628,278,1)
(417,618,1)
(663,481,1)
(653,191,1)
(685,41,1)
(214,409,1)
(457,702,1)
(243,96,1)
(152,631,1)
(526,617,1)
(331,694,1)
(57,249,1)
(331,612,1)
(303,278,1)
(165,32,1)
(371,302,1)
(77,631,1)
(632,101,1)
(3,593,1)
(317,513,1)
(511,278,1)
(113,352,1)
(602,635,1)
(70,476,1)
(56,467,1)
(547,245,1)
(269,198,1)
(678,301,1)
(406,480,1)
(203,209,1)
(132,495,1)
(308,117,1)
(451,250,1)
(34,415,1)
(8,115,1)
(293,631,1)
(610,212,1)
(286,38,1)
(558,445,1)
(192,572,1)
(548,278,1)
(184,48,1)
(421,631,1)
(297,441,1)
(376,13,1)
(558,423,1)
(358,631,1)
(160,284,1)
(180,186,1)
(641,496,1)
(425,95,1)
(161,8,1)
(331,606,1)
(466,118,1)
(321,631,1)
(392,386,1)
(437,558,1)
(450,689,1)
(43,575,1)
(612,437,1)
(661,359,1)
(112,615,2)
(695,51,2)
(12,631,2)
(198,278,2)
(661,473,2)
(432,270,2)
(666,631,2)
(529,631,2)
(558,445,2)
(70,476,2)
(178,33,2)
(5,631,2)
(406,601,2)
(538,631,2)
(463,131,2)
(169,631,2)
(176,631,2)
(261,631,2)
(699,164,2)
(210,601,2)
(126,631,2)
(447,631,2)
(307,631,2)
(298,631,2)
(342,473,2)
(449,631,2)
(214,409,2)
(683,631,2)
(240,278,2)
(645,8,2)
(188,473,2)
(632,615,2)
(209,631,2)
(114,552,2)
(240,631,2)
(554,601,2)
(615,155,2)
(180,511,2)
(36,615,2)
(514,231,2)
(367,601,2)
(163,476,2)
(65,631,2)
(93,434,2)
(110,33,2)
(162,33,2)
(434,631,2)
(295,432,2)
(35,444,2)
(535,631,2)
(345,97,2)
(366,97,2)
(146,278,2)
(131,289,2)
(437,631,2)
(142,320,2)
(626,631,2)
(432,532,2)
(180,31,2)
(205,618,2)
(14,51,2)
(239,631,2)
(339,631,2)
(193,631,2)
(133,260,2)
(284,671,2)
(642,631,2)
(229,121,2)
(409,596,2)
(402,631,2)
(656,601,2)
(155,549,2)
(384,278,2)
(622,631,2)
(208,631,2)
(630,320,2)
(680,19,2)
(252,645,2)
(409,224,2)
(138,33,2)
(161,645,2)
(500,631,2)
(282,631,2)
(19,155,2)
(615,497,2)
(409,480,2)
(524,41,2)
(90,631,2)
(542,278,2)
(408,601,2)
(700,434,2)
(289,33,2)
(187,320,2)
(237,631,2)
(663,524,2)
(381,388,2)
(593,33,2)
(687,537,2)
(155,92,2)
(115,434,2)
(46,432,2)
(260,114,2)
(450,631,2)
(505,631,2)
(393,631,2)
(576,631,2)
(681,631,2)
(103,631,2)
(56,467,2)
(634,631,2)
(451,19,2)
(274,19,2)
(59,631,2)
(303,631,2)
(47,155,2)
(337,33,2)
(427,31,2)
(502,631,2)
(445,108,2)
(681,278,2)
(697,601,2)
(522,631,2)
(377,278,2)
(5,502,2)
(627,667,2)
(441,260,2)
(94,501,2)
(194,631,2)
(409,251,2)
(508,631,2)
(184,51,2)
(25,631,2)
(463,333,2)
(410,258,2)
(263,631,2)
(332,121,2)
(579,278,2)
(699,601,2)
(379,278,2)
(431,631,2)
(109,434,2)
(271,131,2)
(437,558,2)
(222,97,2)
(575,547,2)
(630,278,2)
(25,278,2)
(340,631,2)
(685,41,2)
(101,615,2)
(552,473,2)
(330,601,2)
(412,645,2)
(203,631,2)
(268,631,2)
(143,473,2)
(152,631,2)
(589,631,2)
(105,631,2)
(654,631,2)
(148,601,2)
(478,601,2)
(621,278,2)
(24,388,2)
(3,33,2)
(470,631,2)
(105,278,2)
(620,591,2)
(544,631,2)
(242,388,2)
(100,601,2)
(316,121,2)
(641,468,2)
(689,631,2)
(235,601,2)
(158,473,2)
(409,302,2)
(77,631,2)
(413,320,2)
(457,33,2)
(159,432,2)
(645,328,2)
(649,601,2)
(601,121,2)
(562,601,2)
(128,631,2)
(409,143,2)
(516,631,2)
(57,601,2)
(501,131,2)
(690,601,2)
(87,645,2)
(123,133,2)
(684,601,2)
(292,631,2)
(608,615,2)
(540,601,2)
(277,97,2)
(71,591,2)
(255,121,2)
(635,631,2)
(172,320,2)
(466,631,2)
(528,500,2)
(204,615,2)
(563,320,2)
(233,631,2)
(312,278,2)
(665,278,2)
(365,473,2)
(398,8,2)
(665,97,2)
(610,31,2)
(155,615,2)
(188,618,2)
(247,476,2)
(569,19,2)
(582,601,2)
(660,19,2)
(371,601,2)
(446,155,2)
(344,631,2)
(630,155,2)
(617,601,2)
(624,631,2)
(627,601,2)
(377,631,2)
(265,631,2)
(22,631,2)
(75,631,2)
(314,631,2)
(663,121,2)
(78,631,2)
(547,601,2)
(32,631,2)
(429,631,2)
(513,51,2)
(682,278,2)
(444,167,2)
(350,19,2)
(56,205,2)
(148,599,2)
(150,601,2)
(62,552,2)
(0,631,2)
(595,631,2)
(378,278,2)
(293,631,2)
(369,51,2)
(10,278,2)
(186,31,2)
(355,615,2)
(191,320,2)
(409,88,2)
(288,631,2)
(618,354,2)
(577,320,2)
(111,121,2)
(195,155,2)
(357,601,2)
(207,631,2)
(420,631,2)
(221,631,2)
(212,31,2)
(249,601,2)
(161,434,2)
(31,631,2)
(699,131,2)
(28,434,2)
(446,320,2)
(185,375,2)
(250,19,2)
(375,260,2)
(353,500,2)
(566,278,2)
(511,278,2)
(417,618,2)
(181,278,2)
(286,631,2)
(189,601,2)
(396,320,2)
(404,618,2)
(96,631,2)
(69,278,2)
(368,460,2)
(106,601,2)
(20,434,2)
(308,631,2)
(590,460,2)
(702,33,2)
(92,36,2)
(266,121,2)
(613,19,2)
(342,188,2)
(546,631,2)
(523,473,2)
(85,631,2)
(268,278,2)
(532,31,2)
(684,148,2)
(243,631,2)
(641,674,2)
(567,432,2)
(596,601,2)
(197,278,2)
(271,601,2)
(473,451,2)
(308,59,2)
(167,434,2)
(134,631,2)
(688,631,2)
(509,278,2)
(674,278,2)
(520,601,2)
(414,375,2)
(465,320,2)
(473,19,2)
(493,631,2)
(664,601,2)
(434,439,2)
(313,631,2)
(269,631,2)
(55,19,2)
(68,647,2)
(551,631,2)
(541,444,2)
(463,601,2)
(548,278,2)
(23,631,2)
(344,278,2)
(530,631,2)
(118,631,2)
(472,142,2)
(492,31,2)
(258,278,2)
(606,631,2)
(580,31,2)
(97,151,2)
(102,27,2)
(415,631,2)
(667,601,2)
(198,631,2)
(597,631,2)
(382,631,2)
(35,398,2)
(474,500,2)
(113,468,2)
(524,121,2)
(63,434,2)
(132,631,2)
(256,229,2)
(41,320,2)
(551,278,2)
(502,278,2)
(409,504,2)
(505,278,2)
(409,44,2)
(525,631,2)
(422,388,2)
(375,255,2)
(122,320,2)
(601,33,2)
(475,33,2)
(655,476,2)
(38,631,2)
(484,549,2)
(586,278,2)
(324,601,2)
(133,375,2)
(464,278,2)
(679,155,2)
(398,444,2)
(647,451,2)
(415,344,2)
(271,623,2)
(287,663,2)
(496,476,2)
(260,552,2)
(663,320,2)
(320,229,2)
(247,31,2)
(526,601,2)
(91,19,2)
(100,463,2)
(123,552,2)
(686,631,2)
(255,260,2)
(511,31,2)
(522,278,2)
(532,180,2)
(201,432,2)
(405,451,2)
(310,229,2)
(618,615,2)
(192,631,2)
(93,278,2)
(584,631,2)
(657,97,2)
(318,19,2)
(480,601,2)
(645,434,2)
(694,631,2)
(61,41,2)
(458,476,2)
(319,615,2)
(254,615,2)
(13,631,2)
(236,631,2)
(645,645,2)
(312,631,2)
(137,229,2)
(44,320,2)
(266,375,2)
(402,278,2)
(432,641,2)
(36,618,2)
(440,278,2)
(698,451,2)
(151,181,2)
(621,631,2)
(538,278,2)
(430,631,2)
(318,618,2)
(379,631,2)
(500,10,2)
(673,631,2)
(94,601,2)
(234,271,2)
(332,229,2)
(33,552,2)
(358,631,2)
(421,631,2)
(82,631,2)
(419,473,2)
(102,19,2)
(231,19,2)
(486,33,2)
(555,631,2)
(662,473,2)
(119,631,2)
(323,631,2)
(675,631,2)
(361,631,2)
(287,455,2)
(232,631,2)
(438,665,2)
(411,434,2)
(230,320,2)
(141,631,2)
(178,618,2)
(641,476,2)
(425,95,2)
(54,601,2)
(109,93,2)
(341,631,2)
(33,123,2)
(448,645,2)
(518,601,2)
(473,246,2)
(151,555,2)
(149,278,2)
(662,56,2)
(328,645,2)
(552,316,2)
(660,618,2)
(226,33,2)
(182,631,2)
(283,631,2)
(167,109,2)
(456,552,2)
(382,278,2)
(216,19,2)
(213,631,2)
(326,552,2)
(565,601,2)
(2,631,2)
(537,618,2)
(444,35,2)
(671,131,2)
(181,631,2)
(488,631,2)
(386,601,2)
(134,105,2)
(374,278,2)
(564,631,2)
(19,121,2)
(272,19,2)
(464,97,2)
(166,97,2)
(303,278,2)
(65,681,2)
(607,579,2)
(476,31,2)
(508,278,2)
(477,631,2)
(154,601,2)
(448,120,2)
(277,464,2)
(509,444,2)
(563,155,2)
(439,388,2)
(91,670,2)
(296,473,2)
(378,631,2)
(365,342,2)
(218,631,2)
(145,631,2)
(171,19,2)
(133,620,2)
(108,500,2)
(309,320,2)
(45,601,2)
(42,631,2)
(325,631,2)
(131,33,2)
(477,278,2)
(129,320,2)
(671,64,2)
(68,451,2)
(534,631,2)
(217,631,2)
(426,631,2)
(132,278,2)
(591,266,2)
(347,33,2)
(459,278,2)
(287,653,2)
(104,601,2)
(362,432,2)
(80,19,2)
(409,498,2)
(246,68,2)
(384,631,2)
(611,601,2)
(574,601,2)
(455,320,2)
(409,465,2)
(317,51,2)
(160,601,2)
(328,434,2)
(173,375,2)
(97,631,2)
(432,476,2)
(60,631,2)
(481,41,2)
(83,19,2)
(234,601,2)
(95,601,2)
(174,155,2)
(121,30,2)
(8,434,2)
(570,631,2)
(644,51,2)
(603,242,2)
(445,500,2)
(91,318,2)
(422,631,2)
(372,631,2)
(15,631,2)
(250,121,2)
(118,278,2)
(495,631,2)
(409,324,2)
(397,473,2)
(50,631,2)
(47,497,2)
(501,594,2)
(410,631,2)
(33,473,2)
(459,631,2)
(219,631,2)
(278,603,2)
(390,601,2)
(409,170,2)
(10,631,2)
(200,631,2)
(542,631,2)
(239,278,2)
(425,601,2)
(108,278,2)
(555,278,2)
(149,631,2)
(229,631,2)
(328,278,2)
(24,320,2)
(1,631,2)
(531,631,2)
(320,631,2)
(88,601,2)
(438,97,2)
(148,131,2)
(506,631,2)
(409,526,2)
(615,630,2)
(547,131,2)
(501,601,2)
(107,631,2)
(159,278,2)
(352,476,2)
(653,320,2)
(102,417,2)
(289,404,2)
(300,601,2)
(566,476,2)
(439,631,2)
(444,448,2)
(643,444,2)
(37,320,2)
(124,631,2)
(117,631,2)
(671,601,2)
(224,601,2)
(398,509,2)
(677,631,2)
(437,500,2)
(311,631,2)
(460,111,2)
(231,121,2)
(196,631,2)
(625,155,2)
(348,601,2)
(316,473,2)
(342,228,2)
(667,609,2)
(351,631,2)
(320,310,2)
(201,159,2)
(258,631,2)
(579,631,2)
(205,473,2)
(539,473,2)
(646,631,2)
(96,278,2)
(581,444,2)
(310,332,2)
(363,473,2)
(586,631,2)
(633,645,2)
(572,631,2)
(329,320,2)
(95,116,2)
(568,631,2)
(453,601,2)
(512,631,2)
(550,631,2)
(682,631,2)
(30,388,2)
(270,201,2)
(151,631,2)
(95,131,2)
(165,631,2)
(120,645,2)
(497,320,2)
(321,631,2)
(92,615,2)
(571,631,2)
(114,121,2)
(227,460,2)
(142,549,2)
(499,631,2)
(251,19,2)
(262,631,2)
(81,601,2)
(558,500,2)
(498,601,2)
(249,443,2)
(63,645,2)
(392,601,2)
(197,631,2)
(628,278,2)
(570,278,2)
(140,631,2)
(273,601,2)
(537,591,2)
(144,631,2)
(69,631,2)
(123,260,2)
(655,31,2)
(485,601,2)
(51,631,2)
(647,121,2)
(575,601,2)
(67,631,2)
(559,631,2)
(409,485,2)
(199,278,2)
(404,33,2)
(636,19,2)
(395,631,2)
(417,19,2)
(241,591,2)
(592,444,2)
(535,278,2)
(170,33,2)
(471,631,2)
(548,631,2)
(238,631,2)
(428,601,2)
(347,3,2)
(394,434,2)
(354,146,2)
(302,601,2)
(476,566,2)
(687,591,2)
(301,33,2)
(87,8,2)
(389,631,2)
(566,31,2)
(120,278,2)
(593,618,2)
(3,593,2)
(30,549,2)
(179,434,2)
(349,699,2)
(89,631,2)
(49,631,2)
(199,631,2)
(691,591,2)
(435,229,2)
(249,131,2)
(356,19,2)
(667,131,2)
(573,155,2)
(653,388,2)
(648,451,2)
(440,631,2)
(674,476,2)
(57,249,2)
(400,631,2)
(9,631,2)
(370,476,2)
(257,631,2)
(668,142,2)
(602,631,2)
(399,601,2)
(39,320,2)
(423,500,2)
(376,631,2)
(336,320,2)
(113,476,2)
(506,278,2)
(34,631,2)
(607,631,2)
(246,451,2)
(591,375,2)
(243,96,2)
(59,278,2)
(270,432,2)
(560,434,2)
(637,97,2)
(521,631,2)
(468,31,2)
(381,631,2)
(547,245,2)
(490,631,2)
(588,631,2)
(168,631,2)
(678,33,2)
(448,8,2)
(451,250,2)
(153,631,2)
(354,615,2)
(433,451,2)
(146,615,2)
(359,473,2)
(514,19,2)
(409,357,2)
(287,24,2)
(615,320,2)
(201,468,2)
(429,388,2)
(51,278,2)
(620,375,2)
(156,260,2)
(625,320,2)
(620,687,2)
(510,33,2)
(370,31,2)
(612,631,2)
(157,601,2)
(73,631,2)
(628,631,2)
(349,601,2)
(354,497,2)
(450,197,2)
(659,631,2)
(6,631,2)
(275,601,2)
(416,631,2)
(545,473,2)
(409,390,2)
(284,601,2)
(652,631,2)
(31,422,2)
(48,51,2)
(455,142,2)
(297,260,2)
(334,645,2)
(411,645,2)
(461,473,2)
(619,155,2)
(578,631,2)
(583,631,2)
(58,645,2)
(669,31,2)
(43,601,2)
(374,631,2)
(476,476,2)
(56,473,2)
(290,631,2)
(289,53,2)
(287,320,2)
(128,535,2)
(253,631,2)
(291,631,2)
(476,468,2)
(604,19,2)
(343,631,2)
(444,645,2)
-----------------------------------
(0,break;)
(1,td)
(2,break;)
(3,tv->count == 1)
(4,case SAMPLEFORMAT_UINT:)
(5,td->td_colormap[2])
(6,td_stripbytecount)
(7,fip)
(8,i=1)
(9,td)
(10,td->td_extrasamples)
(11,if( fip == NULL || fip->field_bit != FIELD_CUSTOM )
(12,td)
(13,td)
(14,break;)
(15,break;)
(16,case TIFFTAG_TILEOFFSETS:)
(17,case TIFFTAG_STRIPOFFSETS:)
(18,case TIFFTAG_COMPRESSION:)
(19,fip->field_passcount)
(20,td_smaxsamplevalue)
(21,FIELD_CUSTOM)
(22,1)
(23,td_smaxsamplevalue)
(24,tif->tif_name)
(25,td->td_imagelength)
(26,)
(27,uint32)
(28,v)
(29,if (fip->field_passcount)
(30,TIFFFindField(tif, tag, TIFF_ANY)
(31,tif->tif_flags & TIFF_PERSAMPLE)
(32,td)
(33,fip->field_type == TIFF_ASCII\\n\\t\\t\\t\\t\\t\\t    || fip->field_readcount == TIFF_VARIABLE\\n\\t\\t\\t\\t\\t\\t    || fip->field_readcount == TIFF_VARIABLE2\\n\\t\\t\\t\\t\\t\\t    || fip->field_readcount == TIFF_SPP\\n\\t\\t\\t\\t\\t\\t    || tv->count > 1)
(34,td)
(35,v = td->td_smaxsamplevalue[i])
(36,tv->info)
(37,i)
(38,td)
(39,tif)
(40,for (i=1; i < td->td_samplesperpixel; ++i)
(41,fip)
(42,td)
(43,ret_val)
(44,ret_val = 0)
(45,ret_val)
(46,i)
(47,i++)
(48,DATATYPE_VOID)
(49,td_imagelength)
(50,td_xresolution)
(51,td->td_sampleformat)
(52,case TIFFTAG_COLORMAP:)
(53,char *)
(54,ret_val)
(55,ret_val)
(56,(uint16 *)
(57,*(double *)
(58,i)
(59,td->td_ycbcrsubsampling)
(60,break;)
(61,field_name)
(62,fip)
(63,td)
(64,uint32 *)
(65,td->td_colormap[1])
(66,case TIFF_SLONG:)
(67,td_extrasamples)
(68,strcmp(fip->field_name,"DotRange")
(69,td->td_photometric)
(70,td)
(71,tv)
(72,case TIFFTAG_FILLORDER:)
(73,TIFF_PERSAMPLE)
(74,if (tif->tif_flags & TIFF_PERSAMPLE)
(75,td)
(76,case TIFFTAG_IMAGELENGTH:)
(77,td)
(78,td_ycbcrsubsampling)
(79,tif)
(80,TIFFTAG_DOTRANGE)
(81,1)
(82,td_threshholding)
(83,count)
(84,if (fip->field_type == TIFF_ASCII\\n\\t\\t\\t\\t\\t\\t    || fip->field_readcount == TIFF_VARIABLE\\n\\t\\t\\t\\t\\t\\t    || fip->field_readcount == TIFF_VARIABLE2\\n\\t\\t\\t\\t\\t\\t    || fip->field_readcount == TIFF_SPP\\n\\t\\t\\t\\t\\t\\t    || tv->count > 1)
(85,break;)
(86,)
(87,++i)
(88,ret_val = 1)
(89,NULL)
(90,td)
(91,(uint16)
(92,tv->info->field_tag)
(93,td->td_smaxsamplevalue)
(94,*(int32 *)
(95,(int64 *)
(96,td->td_pagenumber)
(97,td->td_samplesperpixel - td->td_extrasamples > 1)
(98,v)
(99,)
(100,*(uint16 *)
(101,tv)
(102,(uint32)
(103,td)
(104,break;)
(105,td->td_halftonehints)
(106,break;)
(107,td)
(108,td->td_sampleinfo)
(109,td->td_smaxsamplevalue[0])
(110,value)
(111,fip->field_bit)
(112,i)
(113,++i)
(114,fip->field_readcount)
(115,1)
(116,int64 *)
(117,1)
(118,td->td_inknames)
(119,td)
(120,td->td_smaxsamplevalue)
(121,* fip = TIFFFindField(tif, tag, TIFF_ANY)
(122,ret_val)
(123,fip->field_readcount == TIFF_VARIABLE\\n\\t\\t\\t\\t\\t\\t    || fip->field_readcount == TIFF_VARIABLE2\\n\\t\\t\\t\\t\\t\\t    || fip->field_readcount == TIFF_SPP\\n\\t\\t\\t\\t\\t\\t    || tv->count > 1)
(124,td_ycbcrpositioning)
(125,fip)
(126,td_rowsperstrip)
(127,)
(128,td->td_transferfunction[0])
(129,0)
(130,switch (td->td_sampleformat)
(131,*val = (char *)
(132,td->td_yposition)
(133,fip->field_readcount == TIFF_VARIABLE2\\n\\t\\t\\t\\t\\t\\t    || fip->field_readcount == TIFF_SPP\\n\\t\\t\\t\\t\\t\\t    || tv->count > 1)
(134,td->td_halftonehints[0])
(135,case TIFF_LONG:)
(136,)
(137,fip)
(138,val)
(139,for (i = 0; i < td->td_customValueCount; i++)
(140,td)
(141,td_fillorder)
(142,isPseudoTag(tag)
(143,ret_val = 1)
(144,td_extrasamples)
(145,break;)
(146,td->td_customValues)
(147,case TIFFTAG_SAMPLESPERPIXEL:)
(148,(uint8 *)
(149,td->td_sampleformat)
(150,ret_val)
(151,td->td_samplesperpixel - td->td_extrasamples)
(152,td)
(153,tif_flags)
(154,val)
(155,tv->info->field_tag != tag)
(156,TIFF_VARIABLE2)
(157,ret_val)
(158,TIFF_ASCII)
(159,td->td_sminsamplevalue)
(160,ret_val)
(161,i)
(162,tv)
(163,v)
(164,int16 *)
(165,td_orientation)
(166,td)
(167,v = td->td_smaxsamplevalue[0])
(168,td_subifd)
(169,td)
(170,ret_val = 1)
(171,field_tag)
(172,tif_name)
(173,field_readcount)
(174,fip)
(175,case TIFFTAG_YRESOLUTION:)
(176,td_stripoffset)
(177,case TIFF_DOUBLE:)
(178,tv->value)
(179,i)
(180,td->td_sminsamplevalue[0])
(181,td->td_extrasamples)
(182,break;)
(183,case TIFFTAG_MINSAMPLEVALUE:)
(184,break;)
(185,fip)
(186,0)
(187,break;)
(188,tv->value)
(189,ret_val)
(190,tif)
(191,tif_clientdata)
(192,td_planarconfig)
(193,0)
(194,td_sampleformat)
(195,break;)
(196,1)
(197,td->td_colormap)
(198,td->td_extrasamples)
(199,td->td_compression)
(200,td_pagenumber)
(201,td->td_sminsamplevalue[i])
(202,case TIFF_BYTE:)
(203,td_imagedepth)
(204,field_tag)
(205,tv->value)
(206,case TIFFTAG_YPOSITION:)
(207,break;)
(208,td_minsamplevalue)
(209,td)
(210,val)
(211,ret_val)
(212,td)
(213,td_resolutionunit)
(214,RET)
(215,standard_tag)
(216,fip)
(217,break;)
(218,td)
(219,break;)
(220,)
(221,td_tiledepth)
(222,1)
(223,if (tif->tif_flags & TIFF_PERSAMPLE)
(224,ret_val = 1)
(225,i)
(226,1)
(227,standard_tag = 0)
(228,uint16 *)
(229,fip == NULL)
(230,0)
(231,fip->field_readcount)
(232,break;)
(233,break;)
(234,*(float *)
(235,val)
(236,TIFF_PERSAMPLE)
(237,break;)
(238,td_colormap)
(239,td->td_yresolution)
(240,td->td_smaxsamplevalue)
(241,count)
(242,tif->tif_dir)
(243,td->td_pagenumber[1])
(244,case TIFF_SHORT:)
(245,int8 *)
(246,strcmp(fip->field_name,"DotRange")
(247,td_samplesperpixel)
(248,case TIFFTAG_TILEBYTECOUNTS:)
(249,(double *)
(250,fip->field_tag)
(251,ret_val = 1)
(252,td)
(253,break;)
(254,td_customValues)
(255,fip->field_readcount)
(256,FIELD_CUSTOM)
(257,break;)
(258,td->td_halftonehints)
(259,case SAMPLEFORMAT_VOID:)
(260,fip->field_readcount == TIFF_VARIABLE)
(261,break;)
(262,break;)
(263,td_colormap)
(264,case TIFFTAG_TILEWIDTH:)
(265,td)
(266,fip->field_readcount)
(267,case TIFFTAG_IMAGEDEPTH:)
(268,td->td_rowsperstrip)
(269,td)
(270,v = td->td_sminsamplevalue[i])
(271,(float *)
(272,value)
(273,break;)
(274,tv)
(275,1)
(276,case SAMPLEFORMAT_IEEEFP:)
(277,td->td_transferfunction[2])
(278,* td = &tif->tif_dir)
(279,ret_val)
(280,case TIFFTAG_YCBCRPOSITIONING:)
(281,case TIFFTAG_BITSPERSAMPLE:)
(282,td_extrasamples)
(283,td_ycbcrsubsampling)
(284,*(uint32 *)
(285,case TIFF_SBYTE:)
(286,td_tilelength)
(287,TIFFErrorExt(tif->tif_clientdata, "_TIFFVGetField",\\n\\t\\t\\t\\t\\t    "%s: Invalid %stag \\"%s\\" "\\n\\t\\t\\t\\t\\t    "(not supported by codec)
(288,td)
(289,(char *)
(290,td)
(291,td)
(292,1)
(293,td)
(294,i)
(295,v)
(296,1)
(297,field_readcount)
(298,1)
(299,case TIFFTAG_XRESOLUTION:)
(300,val)
(301,tv)
(302,ret_val = 1)
(303,td->td_xresolution)
(304,default:)
(305,for (i=1; i < td->td_samplesperpixel; ++i)
(306,td)
(307,td_subfiletype)
(308,td->td_ycbcrsubsampling[1])
(309,tag)
(310,fip->field_bit != FIELD_CUSTOM)
(311,td_photometric)
(312,td->td_subfiletype)
(313,break;)
(314,td_samplesperpixel)
(315,case TIFFTAG_STRIPBYTECOUNTS:)
(316,fip->field_type)
(317,break;)
(318,tv->count)
(319,info)
(320,fip == NULL || fip->field_bit != FIELD_CUSTOM)
(321,tif)
(322,)
(323,td)
(324,ret_val = 1)
(325,td_inknames)
(326,field_readcount)
(327,case TIFFTAG_THRESHHOLDING:)
(328,td->td_samplesperpixel)
(329,tif)
(330,break;)
(331,ret_val)
(332,fip->field_bit)
(333,uint16 *)
(334,td_smaxsamplevalue)
(335,i)
(336,ret_val)
(337,value)
(338,)
(339,2)
(340,td_pagenumber)
(341,td_sminsamplevalue)
(342,(uint16 *)
(343,break;)
(344,td->td_ycbcrsubsampling)
(345,td)
(346,)
(347,assert( tv->count == 1 )
(348,1)
(349,*(int16 *)
(350,field_readcount)
(351,0)
(352,i)
(353,td_sampleinfo)
(354,td->td_customValues + i)
(355,tag)
(356,tv)
(357,ret_val = 1)
(358,td)
(359,tv)
(360,switch (fip->field_type)
(361,0)
(362,td_sminsamplevalue)
(363,value)
(364,)
(365,((uint16 *)
(366,td_transferfunction)
(367,break;)
(368,standard_tag)
(369,DATATYPE_INT)
(370,td)
(371,break;)
(372,break;)
(373,tv)
(374,td->td_samplesperpixel)
(375,fip->field_readcount == TIFF_VARIABLE2)
(376,td_samplesperpixel)
(377,td->td_tiledepth)
(378,td->td_fillorder)
(379,td->td_tilelength)
(380,case TIFFTAG_SMINSAMPLEVALUE:)
(381,_TIFFFillStriles( tif )
(382,td->td_subifd)
(383,fip)
(384,td->td_imagedepth)
(385,case TIFFTAG_TRANSFERFUNCTION:)
(386,ret_val)
(387,)
(388,TIFF* tif)
(389,td_transferfunction)
(390,ret_val = 1)
(391,field_bit)
(392,1)
(393,break;)
(394,v)
(395,td)
(396,"%s: Invalid %stag \\"%s\\" "\\n\\t\\t\\t\\t\\t    "(not supported by codec)
(397,1)
(398,td->td_smaxsamplevalue[i])
(399,ret_val)
(400,td)
(401,TIFF_ANY)
(402,td->td_resolutionunit)
(403,case TIFFTAG_PHOTOMETRIC:)
(404,tv->value)
(405,field_name)
(406,break;)
(407,case TIFFTAG_ROWSPERSTRIP:)
(408,break;)
(409,return(ret_val)
(410,td->td_halftonehints[1])
(411,td_samplesperpixel)
(412,v)
(413,0)
(414,TIFF_SPP)
(415,td->td_ycbcrsubsampling[0])
(416,tif)
(417,tv->count)
(418,case TIFFTAG_RESOLUTIONUNIT:)
(419,tv)
(420,break;)
(421,td)
(422,tif->tif_flags)
(423,EXTRASAMPLE_ASSOCALPHA)
(424,standard_tag)
(425,*(int64 *)
(426,break;)
(427,i)
(428,1)
(429,_TIFFFillStriles( tif )
(430,break;)
(431,break;)
(432,td->td_sminsamplevalue[i] < v)
(433,0)
(434,tif->tif_flags & TIFF_PERSAMPLE)
(435,field_bit)
(436,case TIFFTAG_SUBFILETYPE:)
(437,td->td_extrasamples == 1 &&\\n\\t\\t\\t    td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA)
(438,td->td_transferfunction[1])
(439,tif->tif_flags)
(440,td->td_sampleinfo)
(441,fip)
(442,val)
(443,double *)
(444,td->td_smaxsamplevalue[i] > v)
(445,td->td_sampleinfo[0])
(446,i)
(447,fip)
(448,td->td_smaxsamplevalue[i])
(449,td_halftonehints)
(450,td->td_colormap[0])
(451,fip->field_tag == TIFFTAG_DOTRANGE)
(452,case TIFFTAG_HALFTONEHINTS:)
(453,ret_val)
(454,case TIFF_SRATIONAL:)
(455,isPseudoTag(tag)
(456,TIFF_VARIABLE)
(457,1)
(458,td_sminsamplevalue)
(459,td->td_minsamplevalue)
(460,fip->field_bit == FIELD_CUSTOM)
(461,field_type)
(462,case TIFFTAG_TILELENGTH:)
(463,(uint16 *)
(464,td->td_transferfunction)
(465,ret_val = 0)
(466,break;)
(467,uint16 *)
(468,i=1)
(469,case TIFFTAG_EXTRASAMPLES:)
(470,td_maxsamplevalue)
(471,break;)
(472,"pseudo-")
(473,fip->field_tag == TIFFTAG_DOTRANGE\\n\\t\\t\\t\\t\\t\\t   && strcmp(fip->field_name,"DotRange")
(474,0)
(475,fip)
(476,i < td->td_samplesperpixel)
(477,td->td_maxsamplevalue)
(478,1)
(479,case TIFF_LONG8:)
(480,ret_val = 1)
(481,"Unknown")
(482,if (fip->field_readcount == TIFF_VARIABLE2)
(483,case TIFFTAG_XPOSITION:)
(484,standard_tag = tag)
(485,ret_val = 1)
(486,field_type)
(487,tag)
(488,td)
(489,case TIFFTAG_YCBCRSUBSAMPLING:)
(490,td)
(491,tag)
(492,1)
(493,td)
(494,case TIFF_FLOAT:)
(495,td_yposition)
(496,i)
(497,i = 0)
(498,ret_val = 1)
(499,1)
(500,td->td_extrasamples == 1)
(501,(int32 *)
(502,td->td_colormap)
(503,case TIFFTAG_REFERENCEBLACKWHITE:)
(504,ret_val = 1)
(505,td->td_threshholding)
(506,td->td_sminsamplevalue)
(507,case TIFFTAG_SUBIFD:)
(508,td->td_ycbcrpositioning)
(509,td->td_smaxsamplevalue)
(510,tv)
(511,td->td_sminsamplevalue)
(512,td)
(513,DATATYPE_UINT)
(514,fip->field_readcount == TIFF_VARIABLE2)
(515,case TIFFTAG_IMAGEWIDTH:)
(516,break;)
(517,case TIFFTAG_PAGENUMBER:)
(518,val)
(519,case TIFF_RATIONAL:)
(520,val)
(521,tif)
(522,td->td_stripbytecount)
(523,fip)
(524,fip->field_name)
(525,td)
(526,ret_val = 0)
(527,case TIFF_SLONG8:)
(528,td)
(529,td)
(530,td)
(531,td_sampleinfo)
(532,v = td->td_sminsamplevalue[0])
(533,case TIFFTAG_SAMPLEFORMAT:)
(534,td_halftonehints)
(535,td->td_transferfunction)
(536,case TIFF_IFD:)
(537,tv->count)
(538,td->td_nsubifd)
(539,0)
(540,1)
(541,td_smaxsamplevalue)
(542,td->td_bitspersample)
(543,case TIFF_SSHORT:)
(544,td)
(545,ret_val)
(546,break;)
(547,(int8 *)
(548,td->td_xposition)
(549,uint32 tag)
(550,td_bitspersample)
(551,td->td_tilewidth)
(552,fip->field_type == TIFF_ASCII)
(553,tif_dir)
(554,val)
(555,td->td_samplesperpixel)
(556,case TIFFTAG_DATATYPE:)
(557,)
(558,td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA)
(559,td_sampleformat)
(560,0)
(561,case TIFFTAG_TILEDEPTH:)
(562,break;)
(563,td)
(564,td_imagewidth)
(565,break;)
(566,td->td_samplesperpixel)
(567,td)
(568,td_refblackwhite)
(569,fip)
(570,td->td_stripoffset)
(571,break;)
(572,td)
(573,continue;)
(574,1)
(575,*(int8 *)
(576,td)
(577,"_TIFFVGetField")
(578,tif)
(579,td->td_pagenumber)
(580,v)
(581,td)
(582,1)
(583,td)
(584,break;)
(585,case TIFF_UNDEFINED:)
(586,td->td_imagewidth)
(587,switch (standard_tag)
(588,td)
(589,break;)
(590,0)
(591,fip->field_readcount == TIFF_SPP)
(592,v)
(593,tv->count)
(594,int32 *)
(595,td_colormap)
(596,ret_val = 1)
(597,td_tilewidth)
(598,v)
(599,uint8 *)
(600,)
(601,fip->field_type)
(602,td_nsubifd)
(603,&tif->tif_dir)
(604,TIFF_VARIABLE2)
(605,case TIFFTAG_SMAXSAMPLEVALUE:)
(606,break;)
(607,td->td_pagenumber[0])
(608,tv)
(609,uint64 *)
(610,td_sminsamplevalue)
(611,val)
(612,break;)
(613,1)
(614,default:)
(615,i < td->td_customValueCount)
(616,case TIFFTAG_ORIENTATION:)
(617,0)
(618,*tv = td->td_customValues + i)
(619,i)
(620,fip->field_readcount == TIFF_SPP\\n\\t\\t\\t\\t\\t\\t    || tv->count > 1)
(621,td->td_planarconfig)
(622,tif_flags)
(623,float *)
(624,td)
(625,td_customValueCount)
(626,td)
(627,*(uint64 *)
(628,td->td_refblackwhite)
(629,case TIFFTAG_INKNAMES:)
(630,td->td_customValueCount)
(631,standard_tag)
(632,td)
(633,i)
(634,td_compression)
(635,td)
(636,tv)
(637,2)
(638,)
(639,case TIFFTAG_PLANARCONFIG:)
(640,case SAMPLEFORMAT_INT:)
(641,td->td_sminsamplevalue[i])
(642,td_yresolution)
(643,i)
(644,DATATYPE_IEEEFP)
(645,i < td->td_samplesperpixel)
(646,0)
(647,fip->field_name)
(648,fip)
(649,ret_val)
(650,if (fip->field_bit == FIELD_CUSTOM)
(651,1)
(652,td)
(653,tif->tif_clientdata)
(654,break;)
(655,i)
(656,val)
(657,td_transferfunction)
(658,td)
(659,break;)
(660,tv->value)
(661,value)
(662,((uint16 *)
(663,fip ? fip->field_name : "Unknown")
(664,1)
(665,td->td_transferfunction)
(666,td)
(667,(uint64 *)
(668,"")
(669,v)
(670,uint16)
(671,(uint32 *)
(672,)
(673,break;)
(674,td->td_sminsamplevalue)
(675,td)
(676,if (td->td_samplesperpixel - td->td_extrasamples > 1)
(677,break;)
(678,count)
(679,field_passcount)
(680,count)
(681,td->td_colormap)
(682,td->td_orientation)
(683,break;)
(684,*(uint8 *)
(685,fip)
(686,td)
(687,tv->count > 1)
(688,td_xposition)
(689,0)
(690,val)
(691,1)
(692,case TIFFTAG_MATTEING:)
(693,case TIFF_IFD8:)
(694,break;)
(695,break;)
(696,)
(697,break;)
(698,"DotRange")
(699,(int16 *)
(700,td)
(701,if (tv->info->field_tag != tag)
(702,ret_val)
(703,case TIFFTAG_MAXSAMPLEVALUE:)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
