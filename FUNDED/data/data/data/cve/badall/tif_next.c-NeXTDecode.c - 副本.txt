-----label-----
1
-----code-----
static int
NeXTDecode(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s)
{
	static const char module[] = "NeXTDecode";
	unsigned char *bp, *op;
	tmsize_t cc;
	uint8* row;
	tmsize_t scanline, n;

	(void) s;
	/*
	 * Each scanline is assumed to start off as all
	 * white (we assume a PhotometricInterpretation
	 * of ``min-is-black'').
	 */
	for (op = (unsigned char*) buf, cc = occ; cc-- > 0;)
		*op++ = 0xff;

	bp = (unsigned char *)tif->tif_rawcp;
	cc = tif->tif_rawcc;
	scanline = tif->tif_scanlinesize;
	if (occ % scanline)
	{
		TIFFErrorExt(tif->tif_clientdata, module, "Fractional scanlines cannot be read");
		return (0);
	}
	for (row = buf; occ > 0; occ -= scanline, row += scanline) {
		n = *bp++, cc--;
		switch (n) {
		case LITERALROW:
			/*
			 * The entire scanline is given as literal values.
			 */
			if (cc < scanline)
				goto bad;
			_TIFFmemcpy(row, bp, scanline);
			bp += scanline;
			cc -= scanline;
			break;
		case LITERALSPAN: {
			tmsize_t off;
			/*
			 * The scanline has a literal span that begins at some
			 * offset.
			 */
			off = (bp[0] * 256) + bp[1];
			n = (bp[2] * 256) + bp[3];
			if (cc < 4+n || off+n > scanline)
				goto bad;
			_TIFFmemcpy(row+off, bp+4, n);
			bp += 4+n;
			cc -= 4+n;
			break;
		}
		default: {
			uint32 npixels = 0, grey;
			uint32 imagewidth = tif->tif_dir.td_imagewidth;

			/*
			 * The scanline is composed of a sequence of constant
			 * color ``runs''.  We shift into ``run mode'' and
			 * interpret bytes as codes of the form
			 * <color><npixels> until we've filled the scanline.
			 */
			op = row;
			for (;;) {
				grey = (uint32)((n>>6) & 0x3);
				n &= 0x3f;
				/*
				 * Ensure the run does not exceed the scanline
				 * bounds, potentially resulting in a security
				 * issue.
				 */
				while (n-- > 0 && npixels < imagewidth)
					SETPIXEL(op, grey);
				if (npixels >= imagewidth)
					break;
				if (cc == 0)
					goto bad;
				n = *bp++, cc--;
			}
			break;
		}
		}
	}
	tif->tif_rawcp = (uint8*) bp;
	tif->tif_rawcc = cc;
	return (1);
bad:
	TIFFErrorExt(tif->tif_clientdata, module, "Not enough data for scanline %ld",
	    (long) tif->tif_row);
	return (0);
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
3,7
3,8
5,6
5,7
6,7
8,9
8,10
11,12
11,13
12,13
14,15
14,16
17,18
17,19
18,19
20,21
22,23
22,24
23,24
25,26
27,28
27,29
27,30
27,31
27,32
27,33
27,34
27,35
27,36
27,37
27,38
27,39
27,40
27,41
27,42
27,43
27,44
28,29
29,30
29,31
31,32
31,33
31,34
34,35
36,37
37,38
37,39
37,40
39,40
39,41
42,43
42,44
45,46
46,47
46,48
47,48
49,50
51,52
52,53
52,54
53,54
55,56
55,57
58,59
59,60
59,61
59,62
60,61
62,63
64,65
66,67
67,68
67,69
68,69
68,70
71,72
73,74
73,75
73,76
74,75
75,76
75,77
76,77
76,78
77,78
79,80
79,81
80,81
80,82
82,83
84,85
86,87
86,88
87,88
89,90
91,92
91,93
92,93
93,94
96,97
97,98
97,99
98,99
99,100
100,101
103,104
104,105
104,106
105,106
107,108
107,109
108,109
108,110
110,111
112,113
112,114
113,114
116,117
117,118
117,119
118,119
120,121
120,122
121,122
124,125
125,126
125,127
126,127
128,129
128,130
129,130
132,133
132,134
133,134
133,135
134,135
136,137
138,139
138,140
139,140
140,141
140,142
140,143
140,144
141,142
143,144
143,145
144,145
147,148
150,151
151,152
153,154
153,155
153,156
153,157
154,155
155,156
155,157
156,157
158,159
160,161
160,162
161,162
164,165
164,166
165,166
165,167
166,167
168,169
170,171
170,172
171,172
173,174
175,176
175,177
176,177
177,178
177,179
178,179
178,180
179,180
181,182
182,183
183,184
185,186
186,187
188,189
188,190
189,190
191,192
191,193
191,194
191,195
191,196
191,197
191,198
191,199
191,200
191,201
192,193
193,194
195,196
195,197
196,197
196,198
197,198
199,200
201,202
203,204
204,205
204,206
204,207
204,208
205,206
207,208
209,210
211,212
213,214
214,215
214,216
215,216
217,218
219,220
220,221
220,222
221,222
223,224
226,227
227,228
229,230
229,231
229,232
229,233
229,234
229,235
229,236
229,237
230,231
231,232
231,233
232,233
234,235
236,237
237,238
237,239
238,239
240,241
240,242
241,242
242,243
242,244
243,244
243,245
244,245
248,249
248,250
249,250
252,253
253,254
253,255
254,255
256,257
256,258
257,258
258,259
258,260
259,260
259,261
260,261
264,265
264,266
265,266
268,269
268,270
269,270
269,271
270,271
270,272
271,272
273,274
273,275
275,276
277,278
277,279
278,279
278,280
279,280
281,282
283,284
285,286
287,288
288,289
288,290
288,291
288,292
289,290
291,292
291,293
292,293
294,295
296,297
296,298
297,298
300,301
302,303
303,304
303,305
304,305
306,307
306,308
308,309
310,311
311,312
311,313
312,313
314,315
314,316
316,317
320,321
320,322
320,323
320,324
320,325
321,322
322,323
322,324
322,325
323,324
325,326
325,327
327,328
329,330
331,332
332,333
332,334
333,334
335,336
335,337
337,338
338,339
338,340
339,340
339,341
340,341
344,345
345,346
345,347
346,347
348,349
350,351
350,352
352,353
352,354
352,355
352,356
352,357
352,358
353,354
354,355
354,356
355,356
357,358
357,359
358,359
359,360
361,362
361,363
362,363
363,364
363,365
364,365
368,369
369,370
369,371
370,371
373,374
373,375
374,375
374,376
375,376
375,377
376,377
377,378
380,381
380,382
381,382
383,384
385,386
386,387
386,388
386,389
387,388
389,390
391,392
393,394
393,395
394,395
394,396
395,396
397,398
400,401
400,402
401,402
401,403
402,403
405,406
407,408
408,409
408,410
409,410
409,411
410,411
412,413
413,414
414,415
416,417
417,418
420,421
421,422
421,423
422,423
422,424
423,424
426,427
426,428
427,428
427,429
428,429
430,431
432,433
434,435
435,436
435,437
436,437
436,438
437,438
440,441
442,443
443,444
445,446
445,447
447,448
448,449
448,450
448,451
448,452
448,453
449,450
451,452
451,453
452,453
455,456
458,459
458,460
459,460
459,461
462,463
462,464
463,464
466,467
467,468
-----nextToken-----
2,4,7,9,10,13,15,16,19,21,24,26,30,32,33,35,38,40,41,43,44,48,50,54,56,57,61,63,65,69,70,72,78,81,83,85,88,90,94,95,101,102,106,109,111,114,115,119,122,123,127,130,131,135,137,142,145,146,148,149,152,157,159,162,163,167,169,172,174,180,184,187,190,194,198,200,202,206,208,210,212,216,218,222,224,225,228,233,235,239,245,246,247,250,251,255,261,262,263,266,267,272,274,276,280,282,284,286,290,293,295,298,299,301,305,307,309,313,315,317,318,319,324,326,328,330,334,336,341,342,343,347,349,351,356,360,365,366,367,371,372,378,379,382,384,388,390,392,396,398,399,403,404,406,411,415,418,419,424,425,429,431,433,438,439,441,444,446,450,453,454,456,457,460,461,464,465,468
-----computeFrom-----
76,77
76,78
86,87
86,88
91,92
91,93
97,98
97,99
104,105
104,106
117,118
117,119
125,126
125,127
133,134
133,135
155,156
155,157
160,161
160,162
165,166
165,167
170,171
170,172
178,179
178,180
196,197
196,198
214,215
214,216
220,221
220,222
237,238
237,239
240,241
240,242
242,243
242,244
253,254
253,255
256,257
256,258
258,259
258,260
269,270
269,271
270,271
270,272
273,274
273,275
277,278
277,279
278,279
278,280
291,292
291,293
296,297
296,298
303,304
303,305
306,307
306,308
311,312
311,313
314,315
314,316
345,346
345,347
354,355
354,356
361,362
361,363
363,364
363,365
369,370
369,371
374,375
374,376
375,376
375,377
380,381
380,382
394,395
394,396
401,402
401,403
409,410
409,411
421,422
421,423
435,436
435,437
-----guardedBy-----
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;Declarator;Name;ExpressionStatement;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;IdExpression;Name;ForStatement;ExpressionStatement;ExpressionList;BinaryExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;ReturnStatement;UnaryExpression;LiteralExpression;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionList;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;ExpressionList;BinaryExpression;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;SwitchStatement;IdExpression;Name;CompoundStatement;CaseStatement;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;GotoStatement;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;UnaryExpression;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;UnaryExpression;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;BinaryExpression;LiteralExpression;IdExpression;Name;BinaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;GotoStatement;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;LiteralExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;LiteralExpression;IdExpression;Name;BreakStatement;DefaultStatement;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;LiteralExpression;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ForStatement;NullStatement;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;UnaryExpression;IdExpression;Name;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;WhileStatement;BinaryExpression;BinaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BreakStatement;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;GotoStatement;Name;ExpressionStatement;ExpressionList;BinaryExpression;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;BreakStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;Pointer;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ReturnStatement;UnaryExpression;LiteralExpression;LabelStatement;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;FieldReference;IdExpression;Name;Name;ReturnStatement;UnaryExpression;LiteralExpression;
-----ast_node-----
static intNeXTDecode(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s){	static const char module[] = "NeXTDecode";	unsigned char *bp, *op;	tmsize_t cc;	uint8* row;	tmsize_t scanline, n;	(void) s;	/*	 * Each scanline is assumed to start off as all	 * white (we assume a PhotometricInterpretation	 * of ``min-is-black'').	 */	for (op = (unsigned char*) buf, cc = occ; cc-- > 0;)		*op++ = 0xff;	bp = (unsigned char *)tif->tif_rawcp;	cc = tif->tif_rawcc;	scanline = tif->tif_scanlinesize;	if (occ % scanline)	{		TIFFErrorExt(tif->tif_clientdata, module, "Fractional scanlines cannot be read");		return (0);	}	for (row = buf; occ > 0; occ -= scanline, row += scanline) {		n = *bp++, cc--;		switch (n) {		case LITERALROW:			/*			 * The entire scanline is given as literal values.			 */			if (cc < scanline)				goto bad;			_TIFFmemcpy(row, bp, scanline);			bp += scanline;			cc -= scanline;			break;		case LITERALSPAN: {			tmsize_t off;			/*			 * The scanline has a literal span that begins at some			 * offset.			 */			off = (bp[0] * 256) + bp[1];			n = (bp[2] * 256) + bp[3];			if (cc < 4+n || off+n > scanline)				goto bad;			_TIFFmemcpy(row+off, bp+4, n);			bp += 4+n;			cc -= 4+n;			break;		}		default: {			uint32 npixels = 0, grey;			uint32 imagewidth = tif->tif_dir.td_imagewidth;			/*			 * The scanline is composed of a sequence of constant			 * color ``runs''.  We shift into ``run mode'' and			 * interpret bytes as codes of the form			 * <color><npixels> until we've filled the scanline.			 */			op = row;			for (;;) {				grey = (uint32)((n>>6) & 0x3);				n &= 0x3f;				/*				 * Ensure the run does not exceed the scanline				 * bounds, potentially resulting in a security				 * issue.				 */				while (n-- > 0 && npixels < imagewidth)					SETPIXEL(op, grey);				if (npixels >= imagewidth)					break;				if (cc == 0)					goto bad;				n = *bp++, cc--;			}			break;		}		}	}	tif->tif_rawcp = (uint8*) bp;	tif->tif_rawcc = cc;	return (1);bad:	TIFFErrorExt(tif->tif_clientdata, module, "Not enough data for scanline %ld",	    (long) tif->tif_row);	return (0);}
static int
NeXTDecode(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s)
NeXTDecode
TIFF* tif
TIFF
TIFF
* tif
*
tif
uint8* buf
uint8
uint8
* buf
*
buf
tmsize_t occ
tmsize_t
tmsize_t
occ
occ
uint16 s
uint16
uint16
s
s
{	static const char module[] = "NeXTDecode";	unsigned char *bp, *op;	tmsize_t cc;	uint8* row;	tmsize_t scanline, n;	(void) s;	/*	 * Each scanline is assumed to start off as all	 * white (we assume a PhotometricInterpretation	 * of ``min-is-black'').	 */	for (op = (unsigned char*) buf, cc = occ; cc-- > 0;)		*op++ = 0xff;	bp = (unsigned char *)tif->tif_rawcp;	cc = tif->tif_rawcc;	scanline = tif->tif_scanlinesize;	if (occ % scanline)	{		TIFFErrorExt(tif->tif_clientdata, module, "Fractional scanlines cannot be read");		return (0);	}	for (row = buf; occ > 0; occ -= scanline, row += scanline) {		n = *bp++, cc--;		switch (n) {		case LITERALROW:			/*			 * The entire scanline is given as literal values.			 */			if (cc < scanline)				goto bad;			_TIFFmemcpy(row, bp, scanline);			bp += scanline;			cc -= scanline;			break;		case LITERALSPAN: {			tmsize_t off;			/*			 * The scanline has a literal span that begins at some			 * offset.			 */			off = (bp[0] * 256) + bp[1];			n = (bp[2] * 256) + bp[3];			if (cc < 4+n || off+n > scanline)				goto bad;			_TIFFmemcpy(row+off, bp+4, n);			bp += 4+n;			cc -= 4+n;			break;		}		default: {			uint32 npixels = 0, grey;			uint32 imagewidth = tif->tif_dir.td_imagewidth;			/*			 * The scanline is composed of a sequence of constant			 * color ``runs''.  We shift into ``run mode'' and			 * interpret bytes as codes of the form			 * <color><npixels> until we've filled the scanline.			 */			op = row;			for (;;) {				grey = (uint32)((n>>6) & 0x3);				n &= 0x3f;				/*				 * Ensure the run does not exceed the scanline				 * bounds, potentially resulting in a security				 * issue.				 */				while (n-- > 0 && npixels < imagewidth)					SETPIXEL(op, grey);				if (npixels >= imagewidth)					break;				if (cc == 0)					goto bad;				n = *bp++, cc--;			}			break;		}		}	}	tif->tif_rawcp = (uint8*) bp;	tif->tif_rawcc = cc;	return (1);bad:	TIFFErrorExt(tif->tif_clientdata, module, "Not enough data for scanline %ld",	    (long) tif->tif_row);	return (0);}
static const char module[] = "NeXTDecode";
static const char module[] = "NeXTDecode";
static const char
module[] = "NeXTDecode"
module
[]
= "NeXTDecode"
"NeXTDecode"
unsigned char *bp, *op;
unsigned char *bp, *op;
unsigned char
*bp
*
bp
*op
*
op
tmsize_t cc;
tmsize_t cc;
tmsize_t
tmsize_t
cc
cc
uint8* row;
uint8* row;
uint8
uint8
* row
*
row
tmsize_t scanline, n;
tmsize_t scanline, n;
tmsize_t
tmsize_t
scanline
scanline
n
n
(void) s;
(void) s
void
void

s
s
for (op = (unsigned char*) buf, cc = occ; cc-- > 0;)		*op++ = 0xff;
op = (unsigned char*) buf, cc = occ;
op = (unsigned char*) buf, cc = occ
op = (unsigned char*) buf
op
op
(unsigned char*) buf
unsigned char*
unsigned char
*
*
buf
buf
cc = occ
cc
cc
occ
occ
cc-- > 0
cc--
cc
cc
0
*op++ = 0xff;
*op++ = 0xff
*op++
op++
op
op
0xff
bp = (unsigned char *)tif->tif_rawcp;
bp = (unsigned char *)tif->tif_rawcp
bp
bp
(unsigned char *)tif->tif_rawcp
unsigned char *
unsigned char
*
*
tif->tif_rawcp
tif
tif
tif_rawcp
cc = tif->tif_rawcc;
cc = tif->tif_rawcc
cc
cc
tif->tif_rawcc
tif
tif
tif_rawcc
scanline = tif->tif_scanlinesize;
scanline = tif->tif_scanlinesize
scanline
scanline
tif->tif_scanlinesize
tif
tif
tif_scanlinesize
if (occ % scanline)	{		TIFFErrorExt(tif->tif_clientdata, module, "Fractional scanlines cannot be read");		return (0);	}
occ % scanline
occ
occ
scanline
scanline
{		TIFFErrorExt(tif->tif_clientdata, module, "Fractional scanlines cannot be read");		return (0);	}
TIFFErrorExt(tif->tif_clientdata, module, "Fractional scanlines cannot be read");
TIFFErrorExt(tif->tif_clientdata, module, "Fractional scanlines cannot be read")
TIFFErrorExt
TIFFErrorExt
tif->tif_clientdata
tif
tif
tif_clientdata
module
module
"Fractional scanlines cannot be read"
return (0);
(0)
0
for (row = buf; occ > 0; occ -= scanline, row += scanline) {		n = *bp++, cc--;		switch (n) {		case LITERALROW:			/*			 * The entire scanline is given as literal values.			 */			if (cc < scanline)				goto bad;			_TIFFmemcpy(row, bp, scanline);			bp += scanline;			cc -= scanline;			break;		case LITERALSPAN: {			tmsize_t off;			/*			 * The scanline has a literal span that begins at some			 * offset.			 */			off = (bp[0] * 256) + bp[1];			n = (bp[2] * 256) + bp[3];			if (cc < 4+n || off+n > scanline)				goto bad;			_TIFFmemcpy(row+off, bp+4, n);			bp += 4+n;			cc -= 4+n;			break;		}		default: {			uint32 npixels = 0, grey;			uint32 imagewidth = tif->tif_dir.td_imagewidth;			/*			 * The scanline is composed of a sequence of constant			 * color ``runs''.  We shift into ``run mode'' and			 * interpret bytes as codes of the form			 * <color><npixels> until we've filled the scanline.			 */			op = row;			for (;;) {				grey = (uint32)((n>>6) & 0x3);				n &= 0x3f;				/*				 * Ensure the run does not exceed the scanline				 * bounds, potentially resulting in a security				 * issue.				 */				while (n-- > 0 && npixels < imagewidth)					SETPIXEL(op, grey);				if (npixels >= imagewidth)					break;				if (cc == 0)					goto bad;				n = *bp++, cc--;			}			break;		}		}	}
row = buf;
row = buf
row
row
buf
buf
occ > 0
occ
occ
0
occ -= scanline, row += scanline
occ -= scanline
occ
occ
scanline
scanline
row += scanline
row
row
scanline
scanline
{		n = *bp++, cc--;		switch (n) {		case LITERALROW:			/*			 * The entire scanline is given as literal values.			 */			if (cc < scanline)				goto bad;			_TIFFmemcpy(row, bp, scanline);			bp += scanline;			cc -= scanline;			break;		case LITERALSPAN: {			tmsize_t off;			/*			 * The scanline has a literal span that begins at some			 * offset.			 */			off = (bp[0] * 256) + bp[1];			n = (bp[2] * 256) + bp[3];			if (cc < 4+n || off+n > scanline)				goto bad;			_TIFFmemcpy(row+off, bp+4, n);			bp += 4+n;			cc -= 4+n;			break;		}		default: {			uint32 npixels = 0, grey;			uint32 imagewidth = tif->tif_dir.td_imagewidth;			/*			 * The scanline is composed of a sequence of constant			 * color ``runs''.  We shift into ``run mode'' and			 * interpret bytes as codes of the form			 * <color><npixels> until we've filled the scanline.			 */			op = row;			for (;;) {				grey = (uint32)((n>>6) & 0x3);				n &= 0x3f;				/*				 * Ensure the run does not exceed the scanline				 * bounds, potentially resulting in a security				 * issue.				 */				while (n-- > 0 && npixels < imagewidth)					SETPIXEL(op, grey);				if (npixels >= imagewidth)					break;				if (cc == 0)					goto bad;				n = *bp++, cc--;			}			break;		}		}	}
n = *bp++, cc--;
n = *bp++, cc--
n = *bp++
n
n
*bp++
bp++
bp
bp
cc--
cc
cc
switch (n) {		case LITERALROW:			/*			 * The entire scanline is given as literal values.			 */			if (cc < scanline)				goto bad;			_TIFFmemcpy(row, bp, scanline);			bp += scanline;			cc -= scanline;			break;		case LITERALSPAN: {			tmsize_t off;			/*			 * The scanline has a literal span that begins at some			 * offset.			 */			off = (bp[0] * 256) + bp[1];			n = (bp[2] * 256) + bp[3];			if (cc < 4+n || off+n > scanline)				goto bad;			_TIFFmemcpy(row+off, bp+4, n);			bp += 4+n;			cc -= 4+n;			break;		}		default: {			uint32 npixels = 0, grey;			uint32 imagewidth = tif->tif_dir.td_imagewidth;			/*			 * The scanline is composed of a sequence of constant			 * color ``runs''.  We shift into ``run mode'' and			 * interpret bytes as codes of the form			 * <color><npixels> until we've filled the scanline.			 */			op = row;			for (;;) {				grey = (uint32)((n>>6) & 0x3);				n &= 0x3f;				/*				 * Ensure the run does not exceed the scanline				 * bounds, potentially resulting in a security				 * issue.				 */				while (n-- > 0 && npixels < imagewidth)					SETPIXEL(op, grey);				if (npixels >= imagewidth)					break;				if (cc == 0)					goto bad;				n = *bp++, cc--;			}			break;		}		}
n
n
{		case LITERALROW:			/*			 * The entire scanline is given as literal values.			 */			if (cc < scanline)				goto bad;			_TIFFmemcpy(row, bp, scanline);			bp += scanline;			cc -= scanline;			break;		case LITERALSPAN: {			tmsize_t off;			/*			 * The scanline has a literal span that begins at some			 * offset.			 */			off = (bp[0] * 256) + bp[1];			n = (bp[2] * 256) + bp[3];			if (cc < 4+n || off+n > scanline)				goto bad;			_TIFFmemcpy(row+off, bp+4, n);			bp += 4+n;			cc -= 4+n;			break;		}		default: {			uint32 npixels = 0, grey;			uint32 imagewidth = tif->tif_dir.td_imagewidth;			/*			 * The scanline is composed of a sequence of constant			 * color ``runs''.  We shift into ``run mode'' and			 * interpret bytes as codes of the form			 * <color><npixels> until we've filled the scanline.			 */			op = row;			for (;;) {				grey = (uint32)((n>>6) & 0x3);				n &= 0x3f;				/*				 * Ensure the run does not exceed the scanline				 * bounds, potentially resulting in a security				 * issue.				 */				while (n-- > 0 && npixels < imagewidth)					SETPIXEL(op, grey);				if (npixels >= imagewidth)					break;				if (cc == 0)					goto bad;				n = *bp++, cc--;			}			break;		}		}
case LITERALROW:
LITERALROW
LITERALROW
if (cc < scanline)				goto bad;
cc < scanline
cc
cc
scanline
scanline
goto bad;
bad
_TIFFmemcpy(row, bp, scanline);
_TIFFmemcpy(row, bp, scanline)
_TIFFmemcpy
_TIFFmemcpy
row
row
bp
bp
scanline
scanline
bp += scanline;
bp += scanline
bp
bp
scanline
scanline
cc -= scanline;
cc -= scanline
cc
cc
scanline
scanline
break;
case LITERALSPAN:
LITERALSPAN
LITERALSPAN
{			tmsize_t off;			/*			 * The scanline has a literal span that begins at some			 * offset.			 */			off = (bp[0] * 256) + bp[1];			n = (bp[2] * 256) + bp[3];			if (cc < 4+n || off+n > scanline)				goto bad;			_TIFFmemcpy(row+off, bp+4, n);			bp += 4+n;			cc -= 4+n;			break;		}
tmsize_t off;
tmsize_t off;
tmsize_t
tmsize_t
off
off
off = (bp[0] * 256) + bp[1];
off = (bp[0] * 256) + bp[1]
off
off
(bp[0] * 256) + bp[1]
(bp[0] * 256)
bp[0] * 256
bp[0]
bp
bp
0
256
bp[1]
bp
bp
1
n = (bp[2] * 256) + bp[3];
n = (bp[2] * 256) + bp[3]
n
n
(bp[2] * 256) + bp[3]
(bp[2] * 256)
bp[2] * 256
bp[2]
bp
bp
2
256
bp[3]
bp
bp
3
if (cc < 4+n || off+n > scanline)				goto bad;
cc < 4+n || off+n > scanline
cc < 4+n
cc
cc
4+n
4
n
n
off+n > scanline
off+n
off
off
n
n
scanline
scanline
goto bad;
bad
_TIFFmemcpy(row+off, bp+4, n);
_TIFFmemcpy(row+off, bp+4, n)
_TIFFmemcpy
_TIFFmemcpy
row+off
row
row
off
off
bp+4
bp
bp
4
n
n
bp += 4+n;
bp += 4+n
bp
bp
4+n
4
n
n
cc -= 4+n;
cc -= 4+n
cc
cc
4+n
4
n
n
break;
default:
{			uint32 npixels = 0, grey;			uint32 imagewidth = tif->tif_dir.td_imagewidth;			/*			 * The scanline is composed of a sequence of constant			 * color ``runs''.  We shift into ``run mode'' and			 * interpret bytes as codes of the form			 * <color><npixels> until we've filled the scanline.			 */			op = row;			for (;;) {				grey = (uint32)((n>>6) & 0x3);				n &= 0x3f;				/*				 * Ensure the run does not exceed the scanline				 * bounds, potentially resulting in a security				 * issue.				 */				while (n-- > 0 && npixels < imagewidth)					SETPIXEL(op, grey);				if (npixels >= imagewidth)					break;				if (cc == 0)					goto bad;				n = *bp++, cc--;			}			break;		}
uint32 npixels = 0, grey;
uint32 npixels = 0, grey;
uint32
uint32
npixels = 0
npixels
= 0
0
grey
grey
uint32 imagewidth = tif->tif_dir.td_imagewidth;
uint32 imagewidth = tif->tif_dir.td_imagewidth;
uint32
uint32
imagewidth = tif->tif_dir.td_imagewidth
imagewidth
= tif->tif_dir.td_imagewidth
tif->tif_dir.td_imagewidth
tif->tif_dir
tif
tif
tif_dir
td_imagewidth
op = row;
op = row
op
op
row
row
for (;;) {				grey = (uint32)((n>>6) & 0x3);				n &= 0x3f;				/*				 * Ensure the run does not exceed the scanline				 * bounds, potentially resulting in a security				 * issue.				 */				while (n-- > 0 && npixels < imagewidth)					SETPIXEL(op, grey);				if (npixels >= imagewidth)					break;				if (cc == 0)					goto bad;				n = *bp++, cc--;			}
;
{				grey = (uint32)((n>>6) & 0x3);				n &= 0x3f;				/*				 * Ensure the run does not exceed the scanline				 * bounds, potentially resulting in a security				 * issue.				 */				while (n-- > 0 && npixels < imagewidth)					SETPIXEL(op, grey);				if (npixels >= imagewidth)					break;				if (cc == 0)					goto bad;				n = *bp++, cc--;			}
grey = (uint32)((n>>6) & 0x3);
grey = (uint32)((n>>6) & 0x3)
grey
grey
(uint32)((n>>6) & 0x3)
(uint32)
uint32
uint32
(n>>6) & 0x3
(n>>6)
n>>6
n
n
6
0x3
n &= 0x3f;
n &= 0x3f
n
n
0x3f
while (n-- > 0 && npixels < imagewidth)					SETPIXEL(op, grey);
n-- > 0 && npixels < imagewidth
n-- > 0
n--
n
n
0
npixels < imagewidth
npixels
npixels
imagewidth
imagewidth
SETPIXEL(op, grey);
SETPIXEL(op, grey)
SETPIXEL
SETPIXEL
op
op
grey
grey
if (npixels >= imagewidth)					break;
npixels >= imagewidth
npixels
npixels
imagewidth
imagewidth
break;
if (cc == 0)					goto bad;
cc == 0
cc
cc
0
goto bad;
bad
n = *bp++, cc--;
n = *bp++, cc--
n = *bp++
n
n
*bp++
bp++
bp
bp
cc--
cc
cc
break;
tif->tif_rawcp = (uint8*) bp;
tif->tif_rawcp = (uint8*) bp
tif->tif_rawcp
tif
tif
tif_rawcp
(uint8*) bp
uint8*
uint8
uint8
*
*
bp
bp
tif->tif_rawcc = cc;
tif->tif_rawcc = cc
tif->tif_rawcc
tif
tif
tif_rawcc
cc
cc
return (1);
(1)
1
bad:	TIFFErrorExt(tif->tif_clientdata, module, "Not enough data for scanline %ld",	    (long) tif->tif_row);
bad
TIFFErrorExt(tif->tif_clientdata, module, "Not enough data for scanline %ld",	    (long) tif->tif_row);
TIFFErrorExt(tif->tif_clientdata, module, "Not enough data for scanline %ld",	    (long) tif->tif_row)
TIFFErrorExt
TIFFErrorExt
tif->tif_clientdata
tif
tif
tif_clientdata
module
module
"Not enough data for scanline %ld"
(long) tif->tif_row
long
long

tif->tif_row
tif
tif
tif_row
return (0);
(0)
0
-----joern-----
(51,241,0)
(80,60,0)
(23,57,0)
(61,25,0)
(72,110,0)
(238,221,0)
(116,251,0)
(65,72,0)
(244,195,0)
(251,116,0)
(146,140,0)
(202,129,0)
(53,139,0)
(154,228,0)
(62,3,0)
(200,92,0)
(178,76,0)
(102,238,0)
(255,83,0)
(62,196,0)
(215,161,0)
(127,191,0)
(177,114,0)
(23,18,0)
(116,155,0)
(0,228,0)
(32,58,0)
(38,5,0)
(256,31,0)
(232,40,0)
(18,77,0)
(50,112,0)
(241,57,0)
(98,77,0)
(8,87,0)
(148,30,0)
(40,155,0)
(81,227,0)
(58,32,0)
(221,221,0)
(5,99,0)
(87,236,0)
(161,114,0)
(0,71,0)
(13,169,0)
(46,155,0)
(169,110,0)
(235,124,0)
(32,43,0)
(195,241,0)
(3,15,0)
(165,86,0)
(220,255,0)
(3,34,0)
(120,255,0)
(155,31,0)
(212,25,0)
(89,236,0)
(63,160,0)
(112,85,0)
(58,86,0)
(221,31,0)
(204,182,0)
(112,30,0)
(203,193,0)
(20,21,0)
(189,249,0)
(92,228,0)
(99,221,0)
(99,155,0)
(254,18,0)
(88,42,0)
(159,147,0)
(14,124,0)
(187,221,0)
(146,174,0)
(186,30,0)
(121,139,0)
(21,86,0)
(174,146,0)
(124,155,0)
(33,30,0)
(195,56,0)
(88,244,0)
(238,31,0)
(118,116,0)
(137,72,0)
(150,86,0)
(18,228,0)
(63,193,0)
(46,228,0)
(92,110,0)
(210,62,0)
(126,96,0)
(234,68,0)
(177,110,0)
(158,30,0)
(49,76,0)
(157,11,0)
(140,146,0)
(99,31,0)
(91,206,0)
(75,155,0)
(105,120,0)
(140,228,0)
(155,228,0)
(35,187,0)
(58,121,0)
(112,224,0)
(103,58,0)
(116,31,0)
(3,62,0)
(96,124,0)
(160,40,0)
(116,221,0)
(57,123,0)
(187,155,0)
(245,30,0)
(124,221,0)
(135,171,0)
(150,72,0)
(77,151,0)
(126,236,0)
(107,77,0)
(106,31,0)
(122,97,0)
(114,177,0)
(216,45,0)
(18,76,0)
(86,150,0)
(242,23,0)
(85,112,0)
(155,76,0)
(127,83,0)
(149,245,0)
(96,126,0)
(98,18,0)
(48,116,0)
(205,241,0)
(19,177,0)
(89,35,0)
(219,169,0)
(46,221,0)
(31,249,0)
(191,71,0)
(184,221,0)
(228,30,0)
(78,191,0)
(250,30,0)
(75,221,0)
(187,35,0)
(144,76,0)
(59,155,0)
(111,77,0)
(167,98,0)
(7,238,0)
(152,30,0)
(151,63,0)
(243,135,0)
(191,191,0)
(164,46,0)
(46,0,0)
(147,174,0)
(40,160,0)
(114,161,0)
(107,18,0)
(221,155,0)
(22,30,0)
(16,186,0)
(174,77,0)
(51,106,0)
(218,30,0)
(0,9,0)
(73,106,0)
(140,87,0)
(77,77,0)
(236,126,0)
(171,206,0)
(171,214,0)
(27,77,0)
(172,89,0)
(206,62,0)
(0,0,0)
(135,153,0)
(25,41,0)
(107,30,0)
(37,54,0)
(106,155,0)
(118,30,0)
(249,169,0)
(161,215,0)
(67,151,0)
(238,155,0)
(175,155,0)
(82,195,0)
(153,110,0)
(240,56,0)
(151,77,0)
(245,171,0)
(173,170,0)
(111,186,0)
(47,139,0)
(248,121,0)
(87,140,0)
(174,18,0)
(156,54,0)
(98,186,0)
(190,46,0)
(133,236,0)
(56,222,0)
(186,4,0)
(7,56,0)
(129,9,0)
(117,60,0)
(246,58,0)
(99,5,0)
(97,161,0)
(134,148,0)
(87,63,0)
(182,55,0)
(221,193,0)
(193,76,0)
(1,41,0)
(26,35,0)
(45,18,0)
(46,76,0)
(113,4,0)
(233,151,0)
(160,5,0)
(77,18,0)
(187,31,0)
(35,89,0)
(6,97,0)
(179,30,0)
(74,127,0)
(23,77,0)
(114,148,0)
(4,186,0)
(60,129,0)
(86,139,0)
(5,160,0)
(237,3,0)
(143,87,0)
(11,88,0)
(9,15,0)
(197,255,0)
(223,111,0)
(66,76,0)
(79,150,0)
(34,3,0)
(24,107,0)
(124,31,0)
(147,63,0)
(40,31,0)
(108,227,0)
(191,83,0)
(257,241,0)
(198,114,0)
(18,18,0)
(97,110,0)
(243,188,0)
(40,221,0)
(257,56,0)
(174,186,0)
(255,196,0)
(161,97,0)
(100,193,0)
(28,214,0)
(257,43,0)
(77,186,0)
(52,118,0)
(11,41,0)
(207,41,0)
(208,153,0)
(221,68,0)
(56,7,0)
(54,83,0)
(89,9,0)
(119,193,0)
(252,98,0)
(209,41,0)
(75,126,0)
(249,31,0)
(35,63,0)
(106,51,0)
(170,120,0)
(45,186,0)
(89,0,0)
(249,189,0)
(129,0,0)
(64,191,0)
(29,30,0)
(201,75,0)
(142,135,0)
(155,155,0)
(31,30,0)
(126,75,0)
(141,153,0)
(25,241,0)
(94,244,0)
(45,77,0)
(236,193,0)
(226,68,0)
(36,140,0)
(222,41,0)
(90,114,0)
(104,63,0)
(243,245,0)
(239,4,0)
(132,148,0)
(145,30,0)
(247,187,0)
(93,30,0)
(77,193,0)
(72,150,0)
(169,249,0)
(12,76,0)
(52,110,0)
(21,121,0)
(60,11,0)
(194,21,0)
(206,171,0)
(107,186,0)
(181,99,0)
(69,18,0)
(211,45,0)
(129,139,0)
(115,123,0)
(174,147,0)
(88,11,0)
(227,182,0)
(84,96,0)
(166,257,0)
(225,0,0)
(191,228,0)
(124,96,0)
(10,174,0)
(180,177,0)
(153,107,0)
(228,92,0)
(160,63,0)
(188,55,0)
(109,75,0)
(43,257,0)
(68,221,0)
(138,129,0)
(192,43,0)
(125,0,0)
(195,244,0)
(101,188,0)
(182,148,0)
(182,227,0)
(95,46,0)
(217,139,0)
(116,118,0)
(231,9,0)
(258,139,0)
(120,170,0)
(43,32,0)
(139,76,0)
(229,182,0)
(18,186,0)
(44,52,0)
(23,186,0)
(68,63,0)
(183,30,0)
(241,51,0)
(135,30,0)
(46,31,0)
(131,195,0)
(35,193,0)
(114,30,0)
(39,89,0)
(111,222,0)
(244,88,0)
(176,147,0)
(4,110,0)
(199,139,0)
(111,18,0)
(46,9,0)
(135,52,0)
(54,228,0)
(230,52,0)
(253,99,0)
(45,228,0)
(238,7,0)
(213,121,0)
(106,221,0)
(168,127,0)
(42,88,0)
(17,187,0)
(75,31,0)
(227,110,0)
(162,9,0)
(70,40,0)
(25,56,0)
(2,92,0)
(188,171,0)
(155,221,0)
(94,195,1)
(111,186,1)
(146,140,1)
(3,237,1)
(7,238,1)
(223,56,1)
(239,16,1)
(54,37,1)
(23,77,1)
(232,5,1)
(177,110,1)
(54,228,1)
(157,111,1)
(98,18,1)
(37,156,1)
(43,257,1)
(191,83,1)
(227,108,1)
(245,149,1)
(91,170,1)
(5,38,1)
(202,86,1)
(210,112,1)
(75,109,1)
(116,251,1)
(247,89,1)
(40,70,1)
(5,99,1)
(249,169,1)
(116,155,1)
(77,77,1)
(155,228,1)
(225,125,1)
(36,87,1)
(203,77,1)
(180,130,1)
(107,18,1)
(127,168,1)
(23,18,1)
(28,171,1)
(114,177,1)
(4,113,1)
(155,155,1)
(248,213,1)
(175,46,1)
(124,155,1)
(187,17,1)
(0,0,1)
(96,84,1)
(107,24,1)
(174,147,1)
(122,90,1)
(59,175,1)
(53,185,1)
(197,220,1)
(45,228,1)
(181,253,1)
(243,245,1)
(64,78,1)
(206,91,1)
(182,204,1)
(113,239,1)
(157,129,1)
(79,72,1)
(182,227,1)
(40,221,1)
(168,74,1)
(166,25,1)
(147,176,1)
(40,31,1)
(162,231,1)
(140,228,1)
(188,171,1)
(61,212,1)
(208,118,1)
(86,150,1)
(58,246,1)
(70,232,1)
(213,163,1)
(221,68,1)
(18,186,1)
(50,148,1)
(257,166,1)
(62,3,1)
(155,59,1)
(164,45,1)
(27,221,1)
(244,195,1)
(46,0,1)
(48,52,1)
(6,122,1)
(17,247,1)
(257,241,1)
(238,102,1)
(13,256,1)
(177,19,1)
(18,254,1)
(63,160,1)
(25,56,1)
(104,236,1)
(166,60,1)
(97,110,1)
(174,77,1)
(65,137,1)
(230,44,1)
(112,50,1)
(23,186,1)
(191,191,1)
(201,96,1)
(146,174,1)
(117,32,1)
(3,34,1)
(3,15,1)
(81,54,1)
(32,58,1)
(11,88,1)
(238,31,1)
(35,26,1)
(38,99,1)
(18,18,1)
(82,157,1)
(129,0,1)
(128,98,1)
(180,136,1)
(255,197,1)
(174,18,1)
(35,187,1)
(54,83,1)
(69,155,1)
(21,86,1)
(204,229,1)
(135,171,1)
(9,162,1)
(130,146,1)
(8,143,1)
(172,146,1)
(112,85,1)
(10,63,1)
(39,172,1)
(116,48,1)
(150,79,1)
(244,94,1)
(155,221,1)
(52,230,1)
(18,77,1)
(31,249,1)
(106,73,1)
(254,69,1)
(60,129,1)
(221,221,1)
(160,5,1)
(35,63,1)
(0,228,1)
(75,221,1)
(73,205,1)
(21,194,1)
(106,31,1)
(124,31,1)
(231,54,1)
(187,155,1)
(92,2,1)
(200,154,1)
(221,31,1)
(182,148,1)
(148,132,1)
(228,92,1)
(46,155,1)
(20,32,1)
(99,31,1)
(26,187,1)
(44,127,1)
(143,174,1)
(214,28,1)
(192,257,1)
(242,241,1)
(109,201,1)
(149,114,1)
(51,106,1)
(235,133,1)
(89,0,1)
(219,13,1)
(170,173,1)
(68,63,1)
(243,135,1)
(133,163,1)
(142,107,1)
(116,221,1)
(87,8,1)
(155,31,1)
(78,53,1)
(84,124,1)
(180,128,1)
(89,39,1)
(236,126,1)
(160,40,1)
(43,192,1)
(238,221,1)
(67,27,1)
(151,63,1)
(99,221,1)
(45,77,1)
(135,52,1)
(116,31,1)
(169,219,1)
(25,61,1)
(75,155,1)
(159,10,1)
(0,225,1)
(75,31,1)
(87,63,1)
(46,228,1)
(161,215,1)
(127,191,1)
(161,97,1)
(140,87,1)
(131,82,1)
(151,233,1)
(106,221,1)
(23,242,1)
(92,110,1)
(147,63,1)
(194,20,1)
(170,120,1)
(98,186,1)
(135,142,1)
(245,171,1)
(150,72,1)
(35,89,1)
(255,83,1)
(238,155,1)
(40,155,1)
(46,190,1)
(97,6,1)
(102,240,1)
(253,104,1)
(185,21,1)
(87,236,1)
(18,228,1)
(88,42,1)
(184,35,1)
(153,110,1)
(191,228,1)
(88,244,1)
(99,181,1)
(118,116,1)
(221,155,1)
(99,155,1)
(72,65,1)
(105,214,1)
(101,182,1)
(111,18,1)
(206,62,1)
(25,241,1)
(112,224,1)
(120,255,1)
(256,170,1)
(32,43,1)
(227,110,1)
(211,216,1)
(252,21,1)
(205,127,1)
(156,228,1)
(191,64,1)
(4,110,1)
(24,153,1)
(240,98,1)
(125,191,1)
(78,144,1)
(46,31,1)
(46,9,1)
(45,211,1)
(257,56,1)
(106,155,1)
(174,186,1)
(216,163,1)
(90,198,1)
(114,161,1)
(135,153,1)
(129,138,1)
(195,56,1)
(78,203,1)
(45,18,1)
(233,67,1)
(234,226,1)
(58,121,1)
(95,164,1)
(229,227,1)
(19,180,1)
(126,75,1)
(176,159,1)
(127,83,1)
(195,131,1)
(163,23,1)
(124,14,1)
(246,103,1)
(188,101,1)
(89,236,1)
(89,9,1)
(167,252,1)
(96,124,1)
(121,248,1)
(243,188,1)
(14,235,1)
(9,15,1)
(126,96,1)
(136,45,1)
(171,206,1)
(105,255,1)
(186,4,1)
(138,202,1)
(169,110,1)
(74,9,1)
(132,134,1)
(107,77,1)
(249,189,1)
(77,151,1)
(56,7,1)
(198,177,1)
(46,221,1)
(144,18,1)
(80,117,1)
(140,36,1)
(16,31,1)
(68,234,1)
(0,9,1)
(137,165,1)
(195,241,1)
(52,110,1)
(74,0,1)
(141,208,1)
(60,11,1)
(98,77,1)
(60,80,1)
(107,186,1)
(129,9,1)
(190,95,1)
(77,186,1)
(153,141,1)
(21,121,1)
(103,43,1)
(187,221,1)
(77,18,1)
(111,223,1)
(2,200,1)
(226,184,1)
(187,31,1)
(220,62,1)
(124,221,1)
(120,105,1)
(154,186,1)
(98,167,1)
(237,210,1)
(58,86,1)
(165,121,1)
(241,51,1)
(173,120,1)
(212,11,1)
(72,110,1)
(45,186,1)
(108,81,1)
(114,148,1)
(111,77,1)
(191,228,2)
(21,98,2)
(137,163,2)
(173,170,2)
(238,155,2)
(18,18,2)
(255,83,2)
(149,146,2)
(202,163,2)
(45,77,2)
(5,163,2)
(88,163,2)
(147,63,2)
(135,153,2)
(227,54,2)
(160,163,2)
(140,87,2)
(245,146,2)
(142,127,2)
(140,174,2)
(107,127,2)
(184,146,2)
(61,163,2)
(243,188,2)
(252,21,2)
(238,221,2)
(122,146,2)
(170,120,2)
(78,146,2)
(149,45,2)
(249,169,2)
(101,54,2)
(129,163,2)
(135,52,2)
(127,83,2)
(87,63,2)
(46,221,2)
(99,163,2)
(235,163,2)
(120,255,2)
(180,45,2)
(114,177,2)
(20,98,2)
(99,31,2)
(244,163,2)
(99,155,2)
(241,51,2)
(194,163,2)
(51,127,2)
(0,9,2)
(169,110,2)
(118,127,2)
(73,127,2)
(82,98,2)
(107,186,2)
(124,221,2)
(163,127,2)
(211,163,2)
(257,241,2)
(127,146,2)
(227,110,2)
(90,45,2)
(87,174,2)
(229,54,2)
(240,98,2)
(150,72,2)
(63,160,2)
(205,127,2)
(138,163,2)
(168,146,2)
(114,146,2)
(74,21,2)
(45,186,2)
(203,146,2)
(198,146,2)
(245,98,2)
(257,56,2)
(164,45,2)
(84,163,2)
(216,163,2)
(180,146,2)
(25,56,2)
(127,54,2)
(221,68,2)
(97,146,2)
(79,163,2)
(128,98,2)
(6,146,2)
(78,21,2)
(195,98,2)
(130,146,2)
(175,45,2)
(35,146,2)
(116,127,2)
(114,161,2)
(177,98,2)
(118,116,2)
(155,221,2)
(131,98,2)
(168,21,2)
(52,127,2)
(244,98,2)
(171,206,2)
(53,21,2)
(230,127,2)
(226,146,2)
(198,45,2)
(214,170,2)
(117,32,2)
(124,31,2)
(20,163,2)
(187,155,2)
(112,85,2)
(106,31,2)
(149,98,2)
(82,163,2)
(185,21,2)
(174,163,2)
(201,163,2)
(60,129,2)
(135,171,2)
(212,98,2)
(111,77,2)
(31,249,2)
(60,11,2)
(91,170,2)
(161,97,2)
(143,174,2)
(46,31,2)
(43,257,2)
(157,163,2)
(90,98,2)
(99,221,2)
(64,45,2)
(0,21,2)
(170,170,2)
(231,54,2)
(166,98,2)
(165,163,2)
(177,110,2)
(32,163,2)
(212,163,2)
(127,191,2)
(124,163,2)
(68,146,2)
(122,45,2)
(174,186,2)
(26,146,2)
(221,31,2)
(191,146,2)
(181,163,2)
(108,54,2)
(171,170,2)
(88,98,2)
(174,147,2)
(97,98,2)
(192,98,2)
(43,163,2)
(35,63,2)
(46,0,2)
(72,163,2)
(25,163,2)
(19,45,2)
(98,186,2)
(21,163,2)
(0,45,2)
(8,174,2)
(180,98,2)
(25,98,2)
(97,110,2)
(151,63,2)
(121,163,2)
(18,45,2)
(191,191,2)
(21,86,2)
(161,45,2)
(126,96,2)
(86,163,2)
(161,146,2)
(198,98,2)
(161,98,2)
(127,45,2)
(168,54,2)
(19,146,2)
(97,45,2)
(54,228,2)
(27,146,2)
(234,146,2)
(106,155,2)
(3,34,2)
(23,77,2)
(254,45,2)
(17,146,2)
(18,77,2)
(188,54,2)
(190,45,2)
(206,62,2)
(177,45,2)
(23,127,2)
(174,18,2)
(192,163,2)
(78,45,2)
(188,171,2)
(204,54,2)
(243,245,2)
(242,127,2)
(236,126,2)
(32,98,2)
(24,127,2)
(146,174,2)
(166,163,2)
(153,110,2)
(245,171,2)
(146,163,2)
(249,189,2)
(223,98,2)
(257,163,2)
(3,15,2)
(89,236,2)
(107,77,2)
(69,45,2)
(221,146,2)
(18,228,2)
(74,45,2)
(248,163,2)
(232,163,2)
(155,155,2)
(126,75,2)
(46,228,2)
(75,31,2)
(74,146,2)
(221,155,2)
(182,148,2)
(19,98,2)
(88,42,2)
(221,221,2)
(191,45,2)
(192,32,2)
(195,241,2)
(87,236,2)
(11,98,2)
(58,121,2)
(114,98,2)
(243,135,2)
(106,221,2)
(58,86,2)
(81,54,2)
(89,9,2)
(136,45,2)
(159,163,2)
(131,163,2)
(77,151,2)
(187,146,2)
(56,98,2)
(90,146,2)
(244,195,2)
(0,228,2)
(11,163,2)
(32,58,2)
(160,40,2)
(56,7,2)
(191,21,2)
(67,146,2)
(63,163,2)
(44,127,2)
(59,45,2)
(60,32,2)
(89,146,2)
(245,45,2)
(23,18,2)
(120,170,2)
(112,224,2)
(45,228,2)
(28,170,2)
(70,163,2)
(186,4,2)
(107,18,2)
(206,170,2)
(6,45,2)
(75,221,2)
(127,21,2)
(116,221,2)
(25,241,2)
(257,98,2)
(187,31,2)
(157,98,2)
(114,45,2)
(111,186,2)
(225,45,2)
(116,251,2)
(77,186,2)
(64,146,2)
(94,98,2)
(147,163,2)
(21,121,2)
(98,77,2)
(125,45,2)
(182,54,2)
(225,21,2)
(40,221,2)
(96,124,2)
(46,45,2)
(7,238,2)
(46,155,2)
(43,32,2)
(96,163,2)
(51,106,2)
(35,187,2)
(129,0,2)
(6,98,2)
(14,163,2)
(88,244,2)
(74,54,2)
(122,98,2)
(144,45,2)
(151,146,2)
(168,45,2)
(166,32,2)
(45,163,2)
(177,146,2)
(77,146,2)
(92,110,2)
(54,83,2)
(253,163,2)
(43,98,2)
(111,98,2)
(103,43,2)
(45,18,2)
(68,63,2)
(150,163,2)
(160,5,2)
(194,98,2)
(125,146,2)
(62,3,2)
(32,43,2)
(182,227,2)
(195,163,2)
(111,18,2)
(7,98,2)
(155,45,2)
(23,186,2)
(36,174,2)
(116,31,2)
(174,77,2)
(32,32,2)
(94,163,2)
(236,163,2)
(153,127,2)
(141,127,2)
(162,54,2)
(0,146,2)
(238,98,2)
(48,127,2)
(75,155,2)
(10,163,2)
(125,21,2)
(228,92,2)
(86,150,2)
(167,21,2)
(39,146,2)
(257,32,2)
(208,127,2)
(114,148,2)
(155,228,2)
(109,163,2)
(46,9,2)
(241,127,2)
(161,215,2)
(75,163,2)
(176,163,2)
(213,163,2)
(18,186,2)
(38,163,2)
(140,228,2)
(133,163,2)
(246,43,2)
(102,98,2)
(95,45,2)
(72,110,2)
(5,99,2)
(77,77,2)
(135,127,2)
(105,170,2)
(104,163,2)
(0,0,2)
(52,110,2)
(195,56,2)
(4,110,2)
(233,146,2)
(77,18,2)
(80,32,2)
(191,83,2)
(64,21,2)
(58,43,2)
(126,163,2)
(61,98,2)
(35,89,2)
(247,146,2)
(106,127,2)
(40,31,2)
(11,88,2)
(225,146,2)
(40,155,2)
(89,0,2)
(116,155,2)
(172,146,2)
(187,221,2)
(129,9,2)
(9,15,2)
(40,163,2)
(146,140,2)
(155,31,2)
(238,31,2)
(65,163,2)
(124,155,2)
(98,21,2)
(9,54,2)
(98,18,2)
-----------------------------------
(0,row += scanline)
(1,if (npixels >= imagewidth)
(2,tif_scanlinesize)
(3,(unsigned char*)
(4,tif->tif_rawcc)
(5,bp[2] * 256)
(6,tif_row)
(7,*bp++)
(8,n)
(9,row = buf)
(10,cc)
(11,grey = (uint32)
(12,default:)
(13,tif)
(14,0)
(15,uint8* buf)
(16,cc)
(17,4)
(18,cc -= scanline)
(19,tif_clientdata)
(20,npixels)
(21,npixels >= imagewidth)
(22,for (op = (unsigned char*)
(23,cc--)
(24,cc)
(25,n &= 0x3f)
(26,n)
(27,cc)
(28,0xff)
(29,cc)
(30,)
(31,bp = (unsigned char *)
(32,n-- > 0 && npixels < imagewidth)
(33,scanline)
(34,unsigned char*)
(35,_TIFFmemcpy(row+off, bp+4, n)
(36,scanline)
(37,scanline)
(38,256)
(39,off)
(40,bp[3])
(41,)
(42,uint32)
(43,n-- > 0)
(44,tif)
(45,cc < scanline)
(46,_TIFFmemcpy(row, bp, scanline)
(47,for (;;)
(48,bp)
(49,case LITERALSPAN:)
(50,s)
(51,*bp++)
(52,tif->tif_rawcp)
(53,break;)
(54,occ % scanline)
(55,)
(56,n = *bp++)
(57,)
(58,npixels < imagewidth)
(59,scanline)
(60,SETPIXEL(op, grey)
(61,0x3f)
(62,op = (unsigned char*)
(63,n = (bp[2] * 256)
(64,scanline)
(65,tif_dir)
(66,case LITERALROW:)
(67,4)
(68,4+n)
(69,cc)
(70,3)
(71,)
(72,tif->tif_dir)
(73,bp)
(74,occ)
(75,bp[1])
(76,)
(77,cc -= 4+n)
(78,occ)
(79,td_imagewidth)
(80,grey)
(81,tif)
(82,n)
(83,tmsize_t occ)
(84,256)
(85,void)
(86,imagewidth = tif->tif_dir.td_imagewidth)
(87,off+n)
(88,(uint32)
(89,row+off)
(90,"Not enough data for scanline %ld")
(91,op)
(92,tif->tif_scanlinesize)
(93,op)
(94,0x3)
(95,bp)
(96,bp[0] * 256)
(97,tif->tif_row)
(98,cc == 0)
(99,bp[2])
(100,if (cc < 4+n || off+n > scanline)
(101,0)
(102,bp)
(103,npixels)
(104,n)
(105,cc)
(106,bp++)
(107,tif->tif_rawcc = cc)
(108,tif_clientdata)
(109,1)
(110,TIFF* tif)
(111,cc--)
(112,(void)
(113,tif_rawcc)
(114,TIFFErrorExt(tif->tif_clientdata, module, "Not enough data for scanline %ld",\n\\n\\t    (long)
(115,switch (n)
(116,(uint8*)
(117,op)
(118,tif->tif_rawcp = (uint8*)
(119,off)
(120,cc--)
(121,npixels = 0)
(122,tif)
(123,)
(124,bp[0])
(125,row)
(126,(bp[0] * 256)
(127,occ > 0)
(128,goto bad;)
(129,op = row)
(130,goto bad;)
(131,6)
(132,"NeXTDecode")
(133,off)
(134,module)
(135,return (1)
(136,goto bad;)
(137,tif)
(138,row)
(139,)
(140,off+n > scanline)
(141,tif_rawcc)
(142,1)
(143,off)
(144,break;)
(145,if (occ % scanline)
(146,cc < 4+n || off+n > scanline)
(147,4+n)
(148,module[] = "NeXTDecode")
(149,0)
(150,tif->tif_dir.td_imagewidth)
(151,4+n)
(152,module)
(153,tif->tif_rawcc)
(154,scanline)
(155,bp += scanline)
(156,occ)
(157,grey)
(158,row)
(159,4)
(160,(bp[2] * 256)
(161,(long)
(162,buf)
(163,n)
(164,row)
(165,imagewidth)
(166,n)
(167,0)
(168,0)
(169,tif->tif_rawcp)
(170,cc-- > 0)
(171,*op++)
(172,row)
(173,0)
(174,cc < 4+n)
(175,bp)
(176,n)
(177,tif->tif_clientdata)
(178,if (cc < scanline)
(179,bp)
(180,tif)
(181,2)
(182,TIFFErrorExt(tif->tif_clientdata, module, "Fractional scanlines cannot be read")
(183,for (row = buf; occ > 0; occ -= scanline, row += scanline)
(184,bp)
(185,break;)
(186,cc = tif->tif_rawcc)
(187,bp+4)
(188,return (0)
(189,unsigned char *)
(190,scanline)
(191,occ -= scanline)
(192,0)
(193,)
(194,imagewidth)
(195,n>>6)
(196,)
(197,occ)
(198,module)
(199,npixels)
(200,tif)
(201,bp)
(202,op)
(203,break;)
(204,"Fractional scanlines cannot be read")
(205,n)
(206,op++)
(207,if (cc == 0)
(208,tif)
(209,while (n-- > 0 && npixels < imagewidth)
(210,op)
(211,scanline)
(212,n)
(213,npixels)
(214,*op++ = 0xff)
(215,long)
(216,cc)
(217,imagewidth)
(218,bad:)
(219,tif_rawcp)
(220,cc)
(221,bp += 4+n)
(222,)
(223,cc)
(224,uint16 s)
(225,scanline)
(226,4)
(227,tif->tif_clientdata)
(228,scanline = tif->tif_scanlinesize)
(229,module)
(230,tif_rawcp)
(231,row)
(232,bp)
(233,n)
(234,n)
(235,bp)
(236,off = (bp[0] * 256)
(237,buf)
(238,bp++)
(239,tif)
(240,n)
(241,n = *bp++)
(242,cc)
(243,RET)
(244,(n>>6)
(245,return (0)
(246,imagewidth)
(247,bp)
(248,0)
(249,(unsigned char *)
(250,n)
(251,uint8*)
(252,cc)
(253,bp)
(254,scanline)
(255,cc = occ)
(256,bp)
(257,n--)
(258,grey)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
