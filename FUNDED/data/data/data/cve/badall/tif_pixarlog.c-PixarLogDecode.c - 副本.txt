-----label-----
1
-----code-----
static int
PixarLogDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)
{
	static const char module[] = "PixarLogDecode";
	TIFFDirectory *td = &tif->tif_dir;
	PixarLogState* sp = DecoderState(tif);
	tmsize_t i;
	tmsize_t nsamples;
	int llen;
	uint16 *up;

	switch (sp->user_datafmt) {
	case PIXARLOGDATAFMT_FLOAT:
		nsamples = occ / sizeof(float);	/* XXX float == 32 bits */
		break;
	case PIXARLOGDATAFMT_16BIT:
	case PIXARLOGDATAFMT_12BITPICIO:
	case PIXARLOGDATAFMT_11BITLOG:
		nsamples = occ / sizeof(uint16); /* XXX uint16 == 16 bits */
		break;
	case PIXARLOGDATAFMT_8BIT:
	case PIXARLOGDATAFMT_8BITABGR:
		nsamples = occ;
		break;
	default:
		TIFFErrorExt(tif->tif_clientdata, module,
			"%d bit input not supported in PixarLog",
			td->td_bitspersample);
		return 0;
	}

	llen = sp->stride * td->td_imagewidth;

	(void) s;
	assert(sp != NULL);
	sp->stream.next_out = (unsigned char *) sp->tbuf;
	assert(sizeof(sp->stream.avail_out)==4);  /* if this assert gets raised,
	    we need to simplify this code to reflect a ZLib that is likely updated
	    to deal with 8byte memory sizes, though this code will respond
	    apropriately even before we simplify it */
	sp->stream.avail_out = (uInt) (nsamples * sizeof(uint16));
	if (sp->stream.avail_out != nsamples * sizeof(uint16))
	{
		TIFFErrorExt(tif->tif_clientdata, module, "ZLib cannot deal with buffers this size");
		return (0);
	}
	do {
		int state = inflate(&sp->stream, Z_PARTIAL_FLUSH);
		if (state == Z_STREAM_END) {
			break;			/* XXX */
		}
		if (state == Z_DATA_ERROR) {
			TIFFErrorExt(tif->tif_clientdata, module,
			    "Decoding error at scanline %lu, %s",
			    (unsigned long) tif->tif_row, sp->stream.msg);
			if (inflateSync(&sp->stream) != Z_OK)
				return (0);
			continue;
		}
		if (state != Z_OK) {
			TIFFErrorExt(tif->tif_clientdata, module, "ZLib error: %s",
			    sp->stream.msg);
			return (0);
		}
	} while (sp->stream.avail_out > 0);

	/* hopefully, we got all the bytes we needed */
	if (sp->stream.avail_out != 0) {
		TIFFErrorExt(tif->tif_clientdata, module,
		    "Not enough data at scanline %lu (short " TIFF_UINT64_FORMAT " bytes)",
		    (unsigned long) tif->tif_row, (TIFF_UINT64_T) sp->stream.avail_out);
		return (0);
	}

	up = sp->tbuf;
	/* Swap bytes in the data if from a different endian machine. */
	if (tif->tif_flags & TIFF_SWAB)
		TIFFSwabArrayOfShort(up, nsamples);

	/*
	 * if llen is not an exact multiple of nsamples, the decode operation
	 * may overflow the output buffer, so truncate it enough to prevent
	 * that but still salvage as much data as possible.
	 */
	if (nsamples % llen) { 
		TIFFWarningExt(tif->tif_clientdata, module,
			"stride %lu is not a multiple of sample count, "
			"%lu, data truncated.", (unsigned long) llen, (unsigned long) nsamples);
		nsamples -= nsamples % llen;
	}

	for (i = 0; i < nsamples; i += llen, up += llen) {
		switch (sp->user_datafmt)  {
		case PIXARLOGDATAFMT_FLOAT:
			horizontalAccumulateF(up, llen, sp->stride,
					(float *)op, sp->ToLinearF);
			op += llen * sizeof(float);
			break;
		case PIXARLOGDATAFMT_16BIT:
			horizontalAccumulate16(up, llen, sp->stride,
					(uint16 *)op, sp->ToLinear16);
			op += llen * sizeof(uint16);
			break;
		case PIXARLOGDATAFMT_12BITPICIO:
			horizontalAccumulate12(up, llen, sp->stride,
					(int16 *)op, sp->ToLinearF);
			op += llen * sizeof(int16);
			break;
		case PIXARLOGDATAFMT_11BITLOG:
			horizontalAccumulate11(up, llen, sp->stride,
					(uint16 *)op);
			op += llen * sizeof(uint16);
			break;
		case PIXARLOGDATAFMT_8BIT:
			horizontalAccumulate8(up, llen, sp->stride,
					(unsigned char *)op, sp->ToLinear8);
			op += llen * sizeof(unsigned char);
			break;
		case PIXARLOGDATAFMT_8BITABGR:
			horizontalAccumulate8abgr(up, llen, sp->stride,
					(unsigned char *)op, sp->ToLinear8);
			op += llen * sizeof(unsigned char);
			break;
		default:
			TIFFErrorExt(tif->tif_clientdata, module,
				  "Unsupported bits/sample: %d",
				  td->td_bitspersample);
			return (0);
		}
	}

	return (1);
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
3,7
3,8
5,6
5,7
6,7
8,9
8,10
11,12
11,13
12,13
14,15
14,16
17,18
17,19
18,19
20,21
22,23
22,24
23,24
25,26
27,28
27,29
27,30
27,31
27,32
27,33
27,34
27,35
27,36
27,37
27,38
27,39
27,40
27,41
27,42
27,43
27,44
27,45
27,46
27,47
27,48
27,49
28,29
29,30
29,31
31,32
31,33
31,34
34,35
36,37
37,38
37,39
38,39
40,41
40,42
40,43
43,44
44,45
45,46
45,47
46,47
49,50
50,51
50,52
51,52
53,54
53,55
53,56
56,57
57,58
57,59
58,59
60,61
62,63
63,64
63,65
64,65
66,67
68,69
69,70
69,71
70,71
72,73
74,75
75,76
75,77
77,78
79,80
80,81
80,82
81,82
83,84
83,85
86,87
86,88
87,88
87,89
88,89
91,92
91,93
91,94
91,95
91,96
91,97
91,98
91,99
91,100
91,101
91,102
91,103
91,104
91,105
91,106
92,93
93,94
95,96
96,97
96,98
97,98
99,100
99,101
100,101
102,103
103,104
103,105
107,108
108,109
110,111
111,112
113,114
114,115
116,117
117,118
117,119
118,119
120,121
120,122
121,122
123,124
124,125
124,126
125,126
129,130
130,131
132,133
133,134
135,136
136,137
136,138
137,138
139,140
143,144
144,145
144,146
144,147
144,148
144,149
145,146
147,148
147,149
148,149
151,152
154,155
154,156
155,156
158,159
160,161
161,162
161,163
162,163
164,165
164,166
165,166
165,167
166,167
169,170
169,171
170,171
173,174
174,175
174,176
175,176
175,177
178,179
180,181
181,182
181,183
182,183
184,185
184,186
185,186
187,188
189,190
190,191
190,192
191,192
191,193
192,193
192,194
193,194
197,198
197,199
198,199
198,200
200,201
202,203
202,204
203,204
206,207
207,208
207,209
208,209
210,211
210,212
211,212
212,213
213,214
213,215
214,215
214,216
215,216
220,221
221,222
221,223
222,223
222,224
223,224
223,225
224,225
228,229
228,230
229,230
230,231
232,233
232,234
233,234
235,236
236,237
236,238
237,238
240,241
240,242
241,242
241,243
242,243
242,244
243,244
243,245
244,245
248,249
248,250
249,250
251,252
252,253
252,254
253,254
256,257
256,258
257,258
258,259
258,260
258,261
258,262
259,260
261,262
261,263
262,263
265,266
268,269
269,270
271,272
271,273
272,273
272,274
272,275
272,276
273,274
274,275
274,276
276,277
276,278
278,279
279,280
279,281
279,282
280,281
282,283
283,284
283,285
284,285
287,288
289,290
289,291
290,291
290,292
291,292
293,294
295,296
297,298
297,299
298,299
298,300
299,300
301,302
303,304
303,305
303,306
304,305
305,306
305,307
305,308
305,309
305,310
305,311
306,307
308,309
308,310
309,310
312,313
315,316
315,317
316,317
316,318
319,320
319,321
320,321
323,324
323,325
324,325
324,326
325,326
329,330
329,331
330,331
330,332
331,332
331,333
332,333
334,335
335,336
335,337
336,337
339,340
341,342
342,343
345,346
345,347
346,347
346,348
347,348
349,350
351,352
351,353
352,353
353,354
353,355
353,356
353,357
353,358
354,355
356,357
356,358
357,358
360,361
363,364
363,365
364,365
364,366
365,366
369,370
370,371
372,373
372,374
373,374
373,375
374,375
374,376
375,376
380,381
380,382
381,382
381,383
382,383
382,384
383,384
383,385
384,385
389,390
389,391
390,391
391,392
392,393
394,395
395,396
395,397
396,397
398,399
398,400
399,400
402,403
402,404
403,404
403,405
404,405
404,406
405,406
408,409
410,411
411,412
411,413
411,414
412,413
414,415
416,417
418,419
418,420
419,420
419,421
420,421
422,423
424,425
424,426
425,426
426,427
426,428
426,429
426,430
426,431
426,432
427,428
429,430
429,431
430,431
433,434
436,437
436,438
437,438
437,439
440,441
442,443
442,444
443,444
443,445
446,447
448,449
449,450
449,451
450,451
452,453
452,454
453,454
455,456
457,458
457,459
457,460
457,461
458,459
459,460
459,461
460,461
463,464
463,465
464,465
466,467
468,469
468,470
469,470
469,471
470,471
472,473
474,475
474,476
475,476
477,478
479,480
480,481
480,482
481,482
481,483
482,483
485,486
485,487
485,488
485,489
485,490
485,491
485,492
485,493
485,494
485,495
485,496
485,497
485,498
485,499
485,500
485,501
485,502
485,503
485,504
485,505
485,506
485,507
485,508
485,509
485,510
485,511
485,512
486,487
487,488
489,490
490,491
490,492
490,493
490,494
490,495
490,496
491,492
493,494
495,496
497,498
497,499
498,499
501,502
501,503
502,503
502,504
504,505
506,507
508,509
508,510
509,510
512,513
513,514
513,515
514,515
516,517
516,518
517,518
519,520
520,521
520,522
524,525
525,526
527,528
528,529
528,530
528,531
528,532
528,533
528,534
529,530
531,532
533,534
535,536
535,537
536,537
539,540
539,541
540,541
540,542
541,542
543,544
545,546
547,548
547,549
548,549
551,552
552,553
552,554
553,554
555,556
555,557
556,557
558,559
559,560
559,561
560,561
564,565
565,566
567,568
568,569
568,570
568,571
568,572
568,573
568,574
569,570
571,572
573,574
575,576
575,577
576,577
579,580
579,581
580,581
580,582
581,582
583,584
585,586
587,588
587,589
588,589
591,592
592,593
592,594
593,594
595,596
595,597
596,597
598,599
599,600
599,601
600,601
604,605
605,606
607,608
608,609
608,610
608,611
608,612
608,613
609,610
611,612
613,614
615,616
615,617
616,617
619,620
619,621
620,621
620,622
621,622
623,624
625,626
627,628
628,629
628,630
629,630
631,632
631,633
632,633
634,635
635,636
635,637
636,637
640,641
641,642
643,644
644,645
644,646
644,647
644,648
644,649
644,650
645,646
647,648
649,650
651,652
651,653
652,653
655,656
655,657
656,657
656,658
658,659
660,661
662,663
662,664
663,664
666,667
667,668
667,669
668,669
670,671
670,672
671,672
673,674
674,675
674,676
678,679
679,680
681,682
682,683
682,684
682,685
682,686
682,687
682,688
683,684
685,686
687,688
689,690
689,691
690,691
693,694
693,695
694,695
694,696
696,697
698,699
700,701
700,702
701,702
704,705
705,706
705,707
706,707
708,709
708,710
709,710
711,712
712,713
712,714
717,718
718,719
718,720
718,721
718,722
718,723
719,720
721,722
721,723
722,723
725,726
728,729
728,730
729,730
732,733
733,734
735,736
736,737
-----nextToken-----
2,4,7,9,10,13,15,16,19,21,24,26,30,32,33,35,39,41,42,47,48,52,54,55,59,61,65,67,71,73,76,78,82,84,85,89,90,94,98,101,104,105,106,109,112,115,119,122,126,127,128,131,134,138,140,141,142,146,149,150,152,153,156,157,159,163,167,168,171,172,176,177,179,183,186,188,194,195,196,199,201,204,205,209,216,217,218,219,225,226,227,231,234,238,239,245,246,247,250,254,255,260,263,264,266,267,270,275,277,281,285,286,288,292,294,296,300,302,307,310,311,313,314,317,318,321,322,326,327,328,333,337,338,340,343,344,348,350,355,358,359,361,362,366,367,368,371,376,377,378,379,385,386,387,388,393,397,400,401,406,407,409,413,415,417,421,423,428,431,432,434,435,438,439,441,444,445,447,451,454,456,461,462,465,467,471,473,476,478,483,484,488,492,494,496,499,500,503,505,507,510,511,515,518,521,522,523,526,530,532,534,537,538,542,544,546,549,550,554,557,561,562,563,566,570,572,574,577,578,582,584,586,589,590,594,597,601,602,603,606,610,612,614,617,618,622,624,626,630,633,637,638,639,642,646,648,650,653,654,657,659,661,664,665,669,672,675,676,677,680,684,686,688,691,692,695,697,699,702,703,707,710,713,714,715,716,720,723,724,726,727,730,731,734,737
-----computeFrom-----
96,97
96,98
99,100
99,101
117,118
117,119
120,121
120,122
136,137
136,138
161,162
161,163
164,165
164,166
184,185
184,186
190,191
190,192
210,211
210,212
221,222
221,223
232,233
232,234
241,242
241,243
248,249
248,250
290,291
290,292
298,299
298,300
330,331
330,332
346,347
346,348
372,373
372,374
381,382
381,383
395,396
395,397
403,404
403,405
419,420
419,421
449,450
449,451
452,453
452,454
459,460
459,461
463,464
463,465
469,470
469,471
474,475
474,476
513,514
513,515
516,517
516,518
552,553
552,554
555,556
555,557
592,593
592,594
595,596
595,597
628,629
628,630
631,632
631,633
667,668
667,669
670,671
670,672
705,706
705,707
708,709
708,710
-----guardedBy-----
421,454
423,456
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;UnaryExpression;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;SwitchStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;CaseStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;TypeIdExpression;TypeId;SimpleDeclSpecifier;Declarator;BreakStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;BreakStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BreakStatement;DefaultStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;ReturnStatement;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;UnaryExpression;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;UnaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;IfStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;BinaryExpression;IdExpression;Name;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;ReturnStatement;UnaryExpression;LiteralExpression;DoStatement;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;BreakStatement;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;FieldReference;IdExpression;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ReturnStatement;UnaryExpression;LiteralExpression;ContinueStatement;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;ReturnStatement;UnaryExpression;LiteralExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;IfStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;CompoundStatement;ProblemStatement;ReturnStatement;UnaryExpression;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionList;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;SwitchStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;TypeIdExpression;TypeId;SimpleDeclSpecifier;Declarator;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;Pointer;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;Pointer;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;Pointer;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;TypeIdExpression;TypeId;SimpleDeclSpecifier;Declarator;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;TypeIdExpression;TypeId;SimpleDeclSpecifier;Declarator;BreakStatement;DefaultStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;ReturnStatement;UnaryExpression;LiteralExpression;ReturnStatement;UnaryExpression;LiteralExpression;
-----ast_node-----
static intPixarLogDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s){	static const char module[] = "PixarLogDecode";	TIFFDirectory *td = &tif->tif_dir;	PixarLogState* sp = DecoderState(tif);	tmsize_t i;	tmsize_t nsamples;	int llen;	uint16 *up;	switch (sp->user_datafmt) {	case PIXARLOGDATAFMT_FLOAT:		nsamples = occ / sizeof(float);	/* XXX float == 32 bits */		break;	case PIXARLOGDATAFMT_16BIT:	case PIXARLOGDATAFMT_12BITPICIO:	case PIXARLOGDATAFMT_11BITLOG:		nsamples = occ / sizeof(uint16); /* XXX uint16 == 16 bits */		break;	case PIXARLOGDATAFMT_8BIT:	case PIXARLOGDATAFMT_8BITABGR:		nsamples = occ;		break;	default:		TIFFErrorExt(tif->tif_clientdata, module,			"%d bit input not supported in PixarLog",			td->td_bitspersample);		return 0;	}	llen = sp->stride * td->td_imagewidth;	(void) s;	assert(sp != NULL);	sp->stream.next_out = (unsigned char *) sp->tbuf;	assert(sizeof(sp->stream.avail_out)==4);  /* if this assert gets raised,	    we need to simplify this code to reflect a ZLib that is likely updated	    to deal with 8byte memory sizes, though this code will respond	    apropriately even before we simplify it */	sp->stream.avail_out = (uInt) (nsamples * sizeof(uint16));	if (sp->stream.avail_out != nsamples * sizeof(uint16))	{		TIFFErrorExt(tif->tif_clientdata, module, "ZLib cannot deal with buffers this size");		return (0);	}	do {		int state = inflate(&sp->stream, Z_PARTIAL_FLUSH);		if (state == Z_STREAM_END) {			break;			/* XXX */		}		if (state == Z_DATA_ERROR) {			TIFFErrorExt(tif->tif_clientdata, module,			    "Decoding error at scanline %lu, %s",			    (unsigned long) tif->tif_row, sp->stream.msg);			if (inflateSync(&sp->stream) != Z_OK)				return (0);			continue;		}		if (state != Z_OK) {			TIFFErrorExt(tif->tif_clientdata, module, "ZLib error: %s",			    sp->stream.msg);			return (0);		}	} while (sp->stream.avail_out > 0);	/* hopefully, we got all the bytes we needed */	if (sp->stream.avail_out != 0) {		TIFFErrorExt(tif->tif_clientdata, module,		    "Not enough data at scanline %lu (short " TIFF_UINT64_FORMAT " bytes)",		    (unsigned long) tif->tif_row, (TIFF_UINT64_T) sp->stream.avail_out);		return (0);	}	up = sp->tbuf;	/* Swap bytes in the data if from a different endian machine. */	if (tif->tif_flags & TIFF_SWAB)		TIFFSwabArrayOfShort(up, nsamples);	/*	 * if llen is not an exact multiple of nsamples, the decode operation	 * may overflow the output buffer, so truncate it enough to prevent	 * that but still salvage as much data as possible.	 */	if (nsamples % llen) { 		TIFFWarningExt(tif->tif_clientdata, module,			"stride %lu is not a multiple of sample count, "			"%lu, data truncated.", (unsigned long) llen, (unsigned long) nsamples);		nsamples -= nsamples % llen;	}	for (i = 0; i < nsamples; i += llen, up += llen) {		switch (sp->user_datafmt)  {		case PIXARLOGDATAFMT_FLOAT:			horizontalAccumulateF(up, llen, sp->stride,					(float *)op, sp->ToLinearF);			op += llen * sizeof(float);			break;		case PIXARLOGDATAFMT_16BIT:			horizontalAccumulate16(up, llen, sp->stride,					(uint16 *)op, sp->ToLinear16);			op += llen * sizeof(uint16);			break;		case PIXARLOGDATAFMT_12BITPICIO:			horizontalAccumulate12(up, llen, sp->stride,					(int16 *)op, sp->ToLinearF);			op += llen * sizeof(int16);			break;		case PIXARLOGDATAFMT_11BITLOG:			horizontalAccumulate11(up, llen, sp->stride,					(uint16 *)op);			op += llen * sizeof(uint16);			break;		case PIXARLOGDATAFMT_8BIT:			horizontalAccumulate8(up, llen, sp->stride,					(unsigned char *)op, sp->ToLinear8);			op += llen * sizeof(unsigned char);			break;		case PIXARLOGDATAFMT_8BITABGR:			horizontalAccumulate8abgr(up, llen, sp->stride,					(unsigned char *)op, sp->ToLinear8);			op += llen * sizeof(unsigned char);			break;		default:			TIFFErrorExt(tif->tif_clientdata, module,				  "Unsupported bits/sample: %d",				  td->td_bitspersample);			return (0);		}	}	return (1);}
static int
PixarLogDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)
PixarLogDecode
TIFF* tif
TIFF
TIFF
* tif
*
tif
uint8* op
uint8
uint8
* op
*
op
tmsize_t occ
tmsize_t
tmsize_t
occ
occ
uint16 s
uint16
uint16
s
s
{	static const char module[] = "PixarLogDecode";	TIFFDirectory *td = &tif->tif_dir;	PixarLogState* sp = DecoderState(tif);	tmsize_t i;	tmsize_t nsamples;	int llen;	uint16 *up;	switch (sp->user_datafmt) {	case PIXARLOGDATAFMT_FLOAT:		nsamples = occ / sizeof(float);	/* XXX float == 32 bits */		break;	case PIXARLOGDATAFMT_16BIT:	case PIXARLOGDATAFMT_12BITPICIO:	case PIXARLOGDATAFMT_11BITLOG:		nsamples = occ / sizeof(uint16); /* XXX uint16 == 16 bits */		break;	case PIXARLOGDATAFMT_8BIT:	case PIXARLOGDATAFMT_8BITABGR:		nsamples = occ;		break;	default:		TIFFErrorExt(tif->tif_clientdata, module,			"%d bit input not supported in PixarLog",			td->td_bitspersample);		return 0;	}	llen = sp->stride * td->td_imagewidth;	(void) s;	assert(sp != NULL);	sp->stream.next_out = (unsigned char *) sp->tbuf;	assert(sizeof(sp->stream.avail_out)==4);  /* if this assert gets raised,	    we need to simplify this code to reflect a ZLib that is likely updated	    to deal with 8byte memory sizes, though this code will respond	    apropriately even before we simplify it */	sp->stream.avail_out = (uInt) (nsamples * sizeof(uint16));	if (sp->stream.avail_out != nsamples * sizeof(uint16))	{		TIFFErrorExt(tif->tif_clientdata, module, "ZLib cannot deal with buffers this size");		return (0);	}	do {		int state = inflate(&sp->stream, Z_PARTIAL_FLUSH);		if (state == Z_STREAM_END) {			break;			/* XXX */		}		if (state == Z_DATA_ERROR) {			TIFFErrorExt(tif->tif_clientdata, module,			    "Decoding error at scanline %lu, %s",			    (unsigned long) tif->tif_row, sp->stream.msg);			if (inflateSync(&sp->stream) != Z_OK)				return (0);			continue;		}		if (state != Z_OK) {			TIFFErrorExt(tif->tif_clientdata, module, "ZLib error: %s",			    sp->stream.msg);			return (0);		}	} while (sp->stream.avail_out > 0);	/* hopefully, we got all the bytes we needed */	if (sp->stream.avail_out != 0) {		TIFFErrorExt(tif->tif_clientdata, module,		    "Not enough data at scanline %lu (short " TIFF_UINT64_FORMAT " bytes)",		    (unsigned long) tif->tif_row, (TIFF_UINT64_T) sp->stream.avail_out);		return (0);	}	up = sp->tbuf;	/* Swap bytes in the data if from a different endian machine. */	if (tif->tif_flags & TIFF_SWAB)		TIFFSwabArrayOfShort(up, nsamples);	/*	 * if llen is not an exact multiple of nsamples, the decode operation	 * may overflow the output buffer, so truncate it enough to prevent	 * that but still salvage as much data as possible.	 */	if (nsamples % llen) { 		TIFFWarningExt(tif->tif_clientdata, module,			"stride %lu is not a multiple of sample count, "			"%lu, data truncated.", (unsigned long) llen, (unsigned long) nsamples);		nsamples -= nsamples % llen;	}	for (i = 0; i < nsamples; i += llen, up += llen) {		switch (sp->user_datafmt)  {		case PIXARLOGDATAFMT_FLOAT:			horizontalAccumulateF(up, llen, sp->stride,					(float *)op, sp->ToLinearF);			op += llen * sizeof(float);			break;		case PIXARLOGDATAFMT_16BIT:			horizontalAccumulate16(up, llen, sp->stride,					(uint16 *)op, sp->ToLinear16);			op += llen * sizeof(uint16);			break;		case PIXARLOGDATAFMT_12BITPICIO:			horizontalAccumulate12(up, llen, sp->stride,					(int16 *)op, sp->ToLinearF);			op += llen * sizeof(int16);			break;		case PIXARLOGDATAFMT_11BITLOG:			horizontalAccumulate11(up, llen, sp->stride,					(uint16 *)op);			op += llen * sizeof(uint16);			break;		case PIXARLOGDATAFMT_8BIT:			horizontalAccumulate8(up, llen, sp->stride,					(unsigned char *)op, sp->ToLinear8);			op += llen * sizeof(unsigned char);			break;		case PIXARLOGDATAFMT_8BITABGR:			horizontalAccumulate8abgr(up, llen, sp->stride,					(unsigned char *)op, sp->ToLinear8);			op += llen * sizeof(unsigned char);			break;		default:			TIFFErrorExt(tif->tif_clientdata, module,				  "Unsupported bits/sample: %d",				  td->td_bitspersample);			return (0);		}	}	return (1);}
static const char module[] = "PixarLogDecode";
static const char module[] = "PixarLogDecode";
static const char
module[] = "PixarLogDecode"
module
[]
= "PixarLogDecode"
"PixarLogDecode"
TIFFDirectory *td = &tif->tif_dir;
TIFFDirectory *td = &tif->tif_dir;
TIFFDirectory
TIFFDirectory
*td = &tif->tif_dir
*
td
= &tif->tif_dir
&tif->tif_dir
tif->tif_dir
tif
tif
tif_dir
PixarLogState* sp = DecoderState(tif);
PixarLogState* sp = DecoderState(tif);
PixarLogState
PixarLogState
* sp = DecoderState(tif)
*
sp
= DecoderState(tif)
DecoderState(tif)
DecoderState
DecoderState
tif
tif
tmsize_t i;
tmsize_t i;
tmsize_t
tmsize_t
i
i
tmsize_t nsamples;
tmsize_t nsamples;
tmsize_t
tmsize_t
nsamples
nsamples
int llen;
int llen;
int
llen
llen
uint16 *up;
uint16 *up;
uint16
uint16
*up
*
up
switch (sp->user_datafmt) {	case PIXARLOGDATAFMT_FLOAT:		nsamples = occ / sizeof(float);	/* XXX float == 32 bits */		break;	case PIXARLOGDATAFMT_16BIT:	case PIXARLOGDATAFMT_12BITPICIO:	case PIXARLOGDATAFMT_11BITLOG:		nsamples = occ / sizeof(uint16); /* XXX uint16 == 16 bits */		break;	case PIXARLOGDATAFMT_8BIT:	case PIXARLOGDATAFMT_8BITABGR:		nsamples = occ;		break;	default:		TIFFErrorExt(tif->tif_clientdata, module,			"%d bit input not supported in PixarLog",			td->td_bitspersample);		return 0;	}
sp->user_datafmt
sp
sp
user_datafmt
{	case PIXARLOGDATAFMT_FLOAT:		nsamples = occ / sizeof(float);	/* XXX float == 32 bits */		break;	case PIXARLOGDATAFMT_16BIT:	case PIXARLOGDATAFMT_12BITPICIO:	case PIXARLOGDATAFMT_11BITLOG:		nsamples = occ / sizeof(uint16); /* XXX uint16 == 16 bits */		break;	case PIXARLOGDATAFMT_8BIT:	case PIXARLOGDATAFMT_8BITABGR:		nsamples = occ;		break;	default:		TIFFErrorExt(tif->tif_clientdata, module,			"%d bit input not supported in PixarLog",			td->td_bitspersample);		return 0;	}
case PIXARLOGDATAFMT_FLOAT:
PIXARLOGDATAFMT_FLOAT
PIXARLOGDATAFMT_FLOAT
nsamples = occ / sizeof(float);
nsamples = occ / sizeof(float)
nsamples
nsamples
occ / sizeof(float)
occ
occ
sizeof(float)
float
float

break;
case PIXARLOGDATAFMT_16BIT:
PIXARLOGDATAFMT_16BIT
PIXARLOGDATAFMT_16BIT
case PIXARLOGDATAFMT_12BITPICIO:
PIXARLOGDATAFMT_12BITPICIO
PIXARLOGDATAFMT_12BITPICIO
case PIXARLOGDATAFMT_11BITLOG:
PIXARLOGDATAFMT_11BITLOG
PIXARLOGDATAFMT_11BITLOG
nsamples = occ / sizeof(uint16);
nsamples = occ / sizeof(uint16)
nsamples
nsamples
occ / sizeof(uint16)
occ
occ
sizeof(uint16)
uint16
uint16
uint16

break;
case PIXARLOGDATAFMT_8BIT:
PIXARLOGDATAFMT_8BIT
PIXARLOGDATAFMT_8BIT
case PIXARLOGDATAFMT_8BITABGR:
PIXARLOGDATAFMT_8BITABGR
PIXARLOGDATAFMT_8BITABGR
nsamples = occ;
nsamples = occ
nsamples
nsamples
occ
occ
break;
default:
TIFFErrorExt(tif->tif_clientdata, module,			"%d bit input not supported in PixarLog",			td->td_bitspersample);
TIFFErrorExt(tif->tif_clientdata, module,			"%d bit input not supported in PixarLog",			td->td_bitspersample)
TIFFErrorExt
TIFFErrorExt
tif->tif_clientdata
tif
tif
tif_clientdata
module
module
"%d bit input not supported in PixarLog"
td->td_bitspersample
td
td
td_bitspersample
return 0;
0
llen = sp->stride * td->td_imagewidth;
llen = sp->stride * td->td_imagewidth
llen
llen
sp->stride * td->td_imagewidth
sp->stride
sp
sp
stride
td->td_imagewidth
td
td
td_imagewidth
(void) s;
(void) s
void
void

s
s
assert(sp != NULL);
assert(sp != NULL)
assert
assert
sp != NULL
sp
sp
NULL
NULL
sp->stream.next_out = (unsigned char *) sp->tbuf;
sp->stream.next_out = (unsigned char *) sp->tbuf
sp->stream.next_out
sp->stream
sp
sp
stream
next_out
(unsigned char *) sp->tbuf
unsigned char *
unsigned char
*
*
sp->tbuf
sp
sp
tbuf
assert(sizeof(sp->stream.avail_out)==4);
assert(sizeof(sp->stream.avail_out)==4)
assert
assert
sizeof(sp->stream.avail_out)==4
sizeof(sp->stream.avail_out)
(sp->stream.avail_out)
sp->stream.avail_out
sp->stream
sp
sp
stream
avail_out
4
sp->stream.avail_out = (uInt) (nsamples * sizeof(uint16));
sp->stream.avail_out = (uInt) (nsamples * sizeof(uint16))
sp->stream.avail_out
sp->stream
sp
sp
stream
avail_out
(uInt) (nsamples * sizeof(uint16))
(uInt)
uInt
uInt
nsamples * sizeof(uint16)
nsamples
nsamples
sizeof(uint16)
uint16
uint16
uint16

if (sp->stream.avail_out != nsamples * sizeof(uint16))	{		TIFFErrorExt(tif->tif_clientdata, module, "ZLib cannot deal with buffers this size");		return (0);	}
sp->stream.avail_out != nsamples * sizeof(uint16)
sp->stream.avail_out
sp->stream
sp
sp
stream
avail_out
nsamples * sizeof(uint16)
nsamples
nsamples
sizeof(uint16)
uint16
uint16
uint16

{		TIFFErrorExt(tif->tif_clientdata, module, "ZLib cannot deal with buffers this size");		return (0);	}
TIFFErrorExt(tif->tif_clientdata, module, "ZLib cannot deal with buffers this size");
TIFFErrorExt(tif->tif_clientdata, module, "ZLib cannot deal with buffers this size")
TIFFErrorExt
TIFFErrorExt
tif->tif_clientdata
tif
tif
tif_clientdata
module
module
"ZLib cannot deal with buffers this size"
return (0);
(0)
0
do {		int state = inflate(&sp->stream, Z_PARTIAL_FLUSH);		if (state == Z_STREAM_END) {			break;			/* XXX */		}		if (state == Z_DATA_ERROR) {			TIFFErrorExt(tif->tif_clientdata, module,			    "Decoding error at scanline %lu, %s",			    (unsigned long) tif->tif_row, sp->stream.msg);			if (inflateSync(&sp->stream) != Z_OK)				return (0);			continue;		}		if (state != Z_OK) {			TIFFErrorExt(tif->tif_clientdata, module, "ZLib error: %s",			    sp->stream.msg);			return (0);		}	} while (sp->stream.avail_out > 0);
{		int state = inflate(&sp->stream, Z_PARTIAL_FLUSH);		if (state == Z_STREAM_END) {			break;			/* XXX */		}		if (state == Z_DATA_ERROR) {			TIFFErrorExt(tif->tif_clientdata, module,			    "Decoding error at scanline %lu, %s",			    (unsigned long) tif->tif_row, sp->stream.msg);			if (inflateSync(&sp->stream) != Z_OK)				return (0);			continue;		}		if (state != Z_OK) {			TIFFErrorExt(tif->tif_clientdata, module, "ZLib error: %s",			    sp->stream.msg);			return (0);		}	}
int state = inflate(&sp->stream, Z_PARTIAL_FLUSH);
int state = inflate(&sp->stream, Z_PARTIAL_FLUSH);
int
state = inflate(&sp->stream, Z_PARTIAL_FLUSH)
state
= inflate(&sp->stream, Z_PARTIAL_FLUSH)
inflate(&sp->stream, Z_PARTIAL_FLUSH)
inflate
inflate
&sp->stream
sp->stream
sp
sp
stream
Z_PARTIAL_FLUSH
Z_PARTIAL_FLUSH
if (state == Z_STREAM_END) {			break;			/* XXX */		}
state == Z_STREAM_END
state
state
Z_STREAM_END
Z_STREAM_END
{			break;			/* XXX */		}
break;
if (state == Z_DATA_ERROR) {			TIFFErrorExt(tif->tif_clientdata, module,			    "Decoding error at scanline %lu, %s",			    (unsigned long) tif->tif_row, sp->stream.msg);			if (inflateSync(&sp->stream) != Z_OK)				return (0);			continue;		}
state == Z_DATA_ERROR
state
state
Z_DATA_ERROR
Z_DATA_ERROR
{			TIFFErrorExt(tif->tif_clientdata, module,			    "Decoding error at scanline %lu, %s",			    (unsigned long) tif->tif_row, sp->stream.msg);			if (inflateSync(&sp->stream) != Z_OK)				return (0);			continue;		}
TIFFErrorExt(tif->tif_clientdata, module,			    "Decoding error at scanline %lu, %s",			    (unsigned long) tif->tif_row, sp->stream.msg);
TIFFErrorExt(tif->tif_clientdata, module,			    "Decoding error at scanline %lu, %s",			    (unsigned long) tif->tif_row, sp->stream.msg)
TIFFErrorExt
TIFFErrorExt
tif->tif_clientdata
tif
tif
tif_clientdata
module
module
"Decoding error at scanline %lu, %s"
(unsigned long) tif->tif_row
unsigned long
unsigned long

tif->tif_row
tif
tif
tif_row
sp->stream.msg
sp->stream
sp
sp
stream
msg
if (inflateSync(&sp->stream) != Z_OK)				return (0);
inflateSync(&sp->stream) != Z_OK
inflateSync(&sp->stream)
inflateSync
inflateSync
&sp->stream
sp->stream
sp
sp
stream
Z_OK
Z_OK
return (0);
(0)
0
continue;
if (state != Z_OK) {			TIFFErrorExt(tif->tif_clientdata, module, "ZLib error: %s",			    sp->stream.msg);			return (0);		}
state != Z_OK
state
state
Z_OK
Z_OK
{			TIFFErrorExt(tif->tif_clientdata, module, "ZLib error: %s",			    sp->stream.msg);			return (0);		}
TIFFErrorExt(tif->tif_clientdata, module, "ZLib error: %s",			    sp->stream.msg);
TIFFErrorExt(tif->tif_clientdata, module, "ZLib error: %s",			    sp->stream.msg)
TIFFErrorExt
TIFFErrorExt
tif->tif_clientdata
tif
tif
tif_clientdata
module
module
"ZLib error: %s"
sp->stream.msg
sp->stream
sp
sp
stream
msg
return (0);
(0)
0
sp->stream.avail_out > 0
sp->stream.avail_out
sp->stream
sp
sp
stream
avail_out
0
if (sp->stream.avail_out != 0) {		TIFFErrorExt(tif->tif_clientdata, module,		    "Not enough data at scanline %lu (short " TIFF_UINT64_FORMAT " bytes)",		    (unsigned long) tif->tif_row, (TIFF_UINT64_T) sp->stream.avail_out);		return (0);	}
sp->stream.avail_out != 0
sp->stream.avail_out
sp->stream
sp
sp
stream
avail_out
0
{		TIFFErrorExt(tif->tif_clientdata, module,		    "Not enough data at scanline %lu (short " TIFF_UINT64_FORMAT " bytes)",		    (unsigned long) tif->tif_row, (TIFF_UINT64_T) sp->stream.avail_out);		return (0);	}
TIFFErrorExt(tif->tif_clientdata, module,		    "Not enough data at scanline %lu (short " TIFF_UINT64_FORMAT " bytes)",		    (unsigned long) tif->tif_row, (TIFF_UINT64_T) sp->stream.avail_out);
return (0);
(0)
0
up = sp->tbuf;
up = sp->tbuf
up
up
sp->tbuf
sp
sp
tbuf
if (tif->tif_flags & TIFF_SWAB)		TIFFSwabArrayOfShort(up, nsamples);
tif->tif_flags & TIFF_SWAB
tif->tif_flags
tif
tif
tif_flags
TIFF_SWAB
TIFF_SWAB
TIFFSwabArrayOfShort(up, nsamples);
TIFFSwabArrayOfShort(up, nsamples)
TIFFSwabArrayOfShort
TIFFSwabArrayOfShort
up
up
nsamples
nsamples
if (nsamples % llen) { 		TIFFWarningExt(tif->tif_clientdata, module,			"stride %lu is not a multiple of sample count, "			"%lu, data truncated.", (unsigned long) llen, (unsigned long) nsamples);		nsamples -= nsamples % llen;	}
nsamples % llen
nsamples
nsamples
llen
llen
{ 		TIFFWarningExt(tif->tif_clientdata, module,			"stride %lu is not a multiple of sample count, "			"%lu, data truncated.", (unsigned long) llen, (unsigned long) nsamples);		nsamples -= nsamples % llen;	}
TIFFWarningExt(tif->tif_clientdata, module,			"stride %lu is not a multiple of sample count, "			"%lu, data truncated.", (unsigned long) llen, (unsigned long) nsamples);
TIFFWarningExt(tif->tif_clientdata, module,			"stride %lu is not a multiple of sample count, "			"%lu, data truncated.", (unsigned long) llen, (unsigned long) nsamples)
TIFFWarningExt
TIFFWarningExt
tif->tif_clientdata
tif
tif
tif_clientdata
module
module
"stride %lu is not a multiple of sample count, "			"%lu, data truncated."
(unsigned long) llen
unsigned long
unsigned long

llen
llen
(unsigned long) nsamples
unsigned long
unsigned long

nsamples
nsamples
nsamples -= nsamples % llen;
nsamples -= nsamples % llen
nsamples
nsamples
nsamples % llen
nsamples
nsamples
llen
llen
for (i = 0; i < nsamples; i += llen, up += llen) {		switch (sp->user_datafmt)  {		case PIXARLOGDATAFMT_FLOAT:			horizontalAccumulateF(up, llen, sp->stride,					(float *)op, sp->ToLinearF);			op += llen * sizeof(float);			break;		case PIXARLOGDATAFMT_16BIT:			horizontalAccumulate16(up, llen, sp->stride,					(uint16 *)op, sp->ToLinear16);			op += llen * sizeof(uint16);			break;		case PIXARLOGDATAFMT_12BITPICIO:			horizontalAccumulate12(up, llen, sp->stride,					(int16 *)op, sp->ToLinearF);			op += llen * sizeof(int16);			break;		case PIXARLOGDATAFMT_11BITLOG:			horizontalAccumulate11(up, llen, sp->stride,					(uint16 *)op);			op += llen * sizeof(uint16);			break;		case PIXARLOGDATAFMT_8BIT:			horizontalAccumulate8(up, llen, sp->stride,					(unsigned char *)op, sp->ToLinear8);			op += llen * sizeof(unsigned char);			break;		case PIXARLOGDATAFMT_8BITABGR:			horizontalAccumulate8abgr(up, llen, sp->stride,					(unsigned char *)op, sp->ToLinear8);			op += llen * sizeof(unsigned char);			break;		default:			TIFFErrorExt(tif->tif_clientdata, module,				  "Unsupported bits/sample: %d",				  td->td_bitspersample);			return (0);		}	}
i = 0;
i = 0
i
i
0
i < nsamples
i
i
nsamples
nsamples
i += llen, up += llen
i += llen
i
i
llen
llen
up += llen
up
up
llen
llen
{		switch (sp->user_datafmt)  {		case PIXARLOGDATAFMT_FLOAT:			horizontalAccumulateF(up, llen, sp->stride,					(float *)op, sp->ToLinearF);			op += llen * sizeof(float);			break;		case PIXARLOGDATAFMT_16BIT:			horizontalAccumulate16(up, llen, sp->stride,					(uint16 *)op, sp->ToLinear16);			op += llen * sizeof(uint16);			break;		case PIXARLOGDATAFMT_12BITPICIO:			horizontalAccumulate12(up, llen, sp->stride,					(int16 *)op, sp->ToLinearF);			op += llen * sizeof(int16);			break;		case PIXARLOGDATAFMT_11BITLOG:			horizontalAccumulate11(up, llen, sp->stride,					(uint16 *)op);			op += llen * sizeof(uint16);			break;		case PIXARLOGDATAFMT_8BIT:			horizontalAccumulate8(up, llen, sp->stride,					(unsigned char *)op, sp->ToLinear8);			op += llen * sizeof(unsigned char);			break;		case PIXARLOGDATAFMT_8BITABGR:			horizontalAccumulate8abgr(up, llen, sp->stride,					(unsigned char *)op, sp->ToLinear8);			op += llen * sizeof(unsigned char);			break;		default:			TIFFErrorExt(tif->tif_clientdata, module,				  "Unsupported bits/sample: %d",				  td->td_bitspersample);			return (0);		}	}
switch (sp->user_datafmt)  {		case PIXARLOGDATAFMT_FLOAT:			horizontalAccumulateF(up, llen, sp->stride,					(float *)op, sp->ToLinearF);			op += llen * sizeof(float);			break;		case PIXARLOGDATAFMT_16BIT:			horizontalAccumulate16(up, llen, sp->stride,					(uint16 *)op, sp->ToLinear16);			op += llen * sizeof(uint16);			break;		case PIXARLOGDATAFMT_12BITPICIO:			horizontalAccumulate12(up, llen, sp->stride,					(int16 *)op, sp->ToLinearF);			op += llen * sizeof(int16);			break;		case PIXARLOGDATAFMT_11BITLOG:			horizontalAccumulate11(up, llen, sp->stride,					(uint16 *)op);			op += llen * sizeof(uint16);			break;		case PIXARLOGDATAFMT_8BIT:			horizontalAccumulate8(up, llen, sp->stride,					(unsigned char *)op, sp->ToLinear8);			op += llen * sizeof(unsigned char);			break;		case PIXARLOGDATAFMT_8BITABGR:			horizontalAccumulate8abgr(up, llen, sp->stride,					(unsigned char *)op, sp->ToLinear8);			op += llen * sizeof(unsigned char);			break;		default:			TIFFErrorExt(tif->tif_clientdata, module,				  "Unsupported bits/sample: %d",				  td->td_bitspersample);			return (0);		}
sp->user_datafmt
sp
sp
user_datafmt
{		case PIXARLOGDATAFMT_FLOAT:			horizontalAccumulateF(up, llen, sp->stride,					(float *)op, sp->ToLinearF);			op += llen * sizeof(float);			break;		case PIXARLOGDATAFMT_16BIT:			horizontalAccumulate16(up, llen, sp->stride,					(uint16 *)op, sp->ToLinear16);			op += llen * sizeof(uint16);			break;		case PIXARLOGDATAFMT_12BITPICIO:			horizontalAccumulate12(up, llen, sp->stride,					(int16 *)op, sp->ToLinearF);			op += llen * sizeof(int16);			break;		case PIXARLOGDATAFMT_11BITLOG:			horizontalAccumulate11(up, llen, sp->stride,					(uint16 *)op);			op += llen * sizeof(uint16);			break;		case PIXARLOGDATAFMT_8BIT:			horizontalAccumulate8(up, llen, sp->stride,					(unsigned char *)op, sp->ToLinear8);			op += llen * sizeof(unsigned char);			break;		case PIXARLOGDATAFMT_8BITABGR:			horizontalAccumulate8abgr(up, llen, sp->stride,					(unsigned char *)op, sp->ToLinear8);			op += llen * sizeof(unsigned char);			break;		default:			TIFFErrorExt(tif->tif_clientdata, module,				  "Unsupported bits/sample: %d",				  td->td_bitspersample);			return (0);		}
case PIXARLOGDATAFMT_FLOAT:
PIXARLOGDATAFMT_FLOAT
PIXARLOGDATAFMT_FLOAT
horizontalAccumulateF(up, llen, sp->stride,					(float *)op, sp->ToLinearF);
horizontalAccumulateF(up, llen, sp->stride,					(float *)op, sp->ToLinearF)
horizontalAccumulateF
horizontalAccumulateF
up
up
llen
llen
sp->stride
sp
sp
stride
(float *)op
float *
float
*
*
op
op
sp->ToLinearF
sp
sp
ToLinearF
op += llen * sizeof(float);
op += llen * sizeof(float)
op
op
llen * sizeof(float)
llen
llen
sizeof(float)
float
float

break;
case PIXARLOGDATAFMT_16BIT:
PIXARLOGDATAFMT_16BIT
PIXARLOGDATAFMT_16BIT
horizontalAccumulate16(up, llen, sp->stride,					(uint16 *)op, sp->ToLinear16);
horizontalAccumulate16(up, llen, sp->stride,					(uint16 *)op, sp->ToLinear16)
horizontalAccumulate16
horizontalAccumulate16
up
up
llen
llen
sp->stride
sp
sp
stride
(uint16 *)op
uint16 *
uint16
uint16
*
*
op
op
sp->ToLinear16
sp
sp
ToLinear16
op += llen * sizeof(uint16);
op += llen * sizeof(uint16)
op
op
llen * sizeof(uint16)
llen
llen
sizeof(uint16)
uint16
uint16
uint16

break;
case PIXARLOGDATAFMT_12BITPICIO:
PIXARLOGDATAFMT_12BITPICIO
PIXARLOGDATAFMT_12BITPICIO
horizontalAccumulate12(up, llen, sp->stride,					(int16 *)op, sp->ToLinearF);
horizontalAccumulate12(up, llen, sp->stride,					(int16 *)op, sp->ToLinearF)
horizontalAccumulate12
horizontalAccumulate12
up
up
llen
llen
sp->stride
sp
sp
stride
(int16 *)op
int16 *
int16
int16
*
*
op
op
sp->ToLinearF
sp
sp
ToLinearF
op += llen * sizeof(int16);
op += llen * sizeof(int16)
op
op
llen * sizeof(int16)
llen
llen
sizeof(int16)
int16
int16
int16

break;
case PIXARLOGDATAFMT_11BITLOG:
PIXARLOGDATAFMT_11BITLOG
PIXARLOGDATAFMT_11BITLOG
horizontalAccumulate11(up, llen, sp->stride,					(uint16 *)op);
horizontalAccumulate11(up, llen, sp->stride,					(uint16 *)op)
horizontalAccumulate11
horizontalAccumulate11
up
up
llen
llen
sp->stride
sp
sp
stride
(uint16 *)op
uint16 *
uint16
uint16
*
*
op
op
op += llen * sizeof(uint16);
op += llen * sizeof(uint16)
op
op
llen * sizeof(uint16)
llen
llen
sizeof(uint16)
uint16
uint16
uint16

break;
case PIXARLOGDATAFMT_8BIT:
PIXARLOGDATAFMT_8BIT
PIXARLOGDATAFMT_8BIT
horizontalAccumulate8(up, llen, sp->stride,					(unsigned char *)op, sp->ToLinear8);
horizontalAccumulate8(up, llen, sp->stride,					(unsigned char *)op, sp->ToLinear8)
horizontalAccumulate8
horizontalAccumulate8
up
up
llen
llen
sp->stride
sp
sp
stride
(unsigned char *)op
unsigned char *
unsigned char
*
*
op
op
sp->ToLinear8
sp
sp
ToLinear8
op += llen * sizeof(unsigned char);
op += llen * sizeof(unsigned char)
op
op
llen * sizeof(unsigned char)
llen
llen
sizeof(unsigned char)
unsigned char
unsigned char

break;
case PIXARLOGDATAFMT_8BITABGR:
PIXARLOGDATAFMT_8BITABGR
PIXARLOGDATAFMT_8BITABGR
horizontalAccumulate8abgr(up, llen, sp->stride,					(unsigned char *)op, sp->ToLinear8);
horizontalAccumulate8abgr(up, llen, sp->stride,					(unsigned char *)op, sp->ToLinear8)
horizontalAccumulate8abgr
horizontalAccumulate8abgr
up
up
llen
llen
sp->stride
sp
sp
stride
(unsigned char *)op
unsigned char *
unsigned char
*
*
op
op
sp->ToLinear8
sp
sp
ToLinear8
op += llen * sizeof(unsigned char);
op += llen * sizeof(unsigned char)
op
op
llen * sizeof(unsigned char)
llen
llen
sizeof(unsigned char)
unsigned char
unsigned char

break;
default:
TIFFErrorExt(tif->tif_clientdata, module,				  "Unsupported bits/sample: %d",				  td->td_bitspersample);
TIFFErrorExt(tif->tif_clientdata, module,				  "Unsupported bits/sample: %d",				  td->td_bitspersample)
TIFFErrorExt
TIFFErrorExt
tif->tif_clientdata
tif
tif
tif_clientdata
module
module
"Unsupported bits/sample: %d"
td->td_bitspersample
td
td
td_bitspersample
return (0);
(0)
0
return (1);
(1)
1
-----joern-----
(19,87,0)
(28,70,0)
(325,68,0)
(178,359,0)
(325,228,0)
(34,252,0)
(212,133,0)
(339,329,0)
(169,162,0)
(13,73,0)
(291,274,0)
(283,4,0)
(229,415,0)
(394,330,0)
(290,374,0)
(341,382,0)
(412,51,0)
(400,68,0)
(289,209,0)
(139,260,0)
(174,146,0)
(77,267,0)
(399,355,0)
(83,410,0)
(394,207,0)
(370,209,0)
(124,330,0)
(359,157,0)
(341,68,0)
(359,178,0)
(15,256,0)
(194,371,0)
(84,410,0)
(24,179,0)
(320,162,0)
(243,191,0)
(263,333,0)
(326,157,0)
(115,359,0)
(348,132,0)
(123,262,0)
(250,24,0)
(394,300,0)
(391,236,0)
(393,100,0)
(120,87,0)
(79,191,0)
(360,55,0)
(361,129,0)
(28,296,0)
(69,98,0)
(129,302,0)
(132,260,0)
(311,214,0)
(383,256,0)
(388,296,0)
(294,175,0)
(195,107,0)
(362,172,0)
(219,289,0)
(413,121,0)
(228,382,0)
(256,409,0)
(37,1,0)
(327,308,0)
(73,158,0)
(80,228,0)
(410,412,0)
(371,171,0)
(203,341,0)
(411,100,0)
(175,173,0)
(370,355,0)
(324,371,0)
(333,382,0)
(371,267,0)
(41,132,0)
(351,34,0)
(371,121,0)
(424,68,0)
(119,237,0)
(310,172,0)
(100,228,0)
(116,52,0)
(249,133,0)
(113,223,0)
(240,350,0)
(349,249,0)
(195,223,0)
(138,236,0)
(2,377,0)
(403,389,0)
(100,382,0)
(167,56,0)
(305,86,0)
(324,350,0)
(132,266,0)
(9,260,0)
(117,162,0)
(42,370,0)
(263,401,0)
(66,187,0)
(3,245,0)
(5,251,0)
(221,220,0)
(325,412,0)
(192,162,0)
(323,162,0)
(284,89,0)
(370,111,0)
(312,398,0)
(100,412,0)
(319,246,0)
(97,418,0)
(382,412,0)
(210,132,0)
(288,252,0)
(94,298,0)
(377,113,0)
(423,388,0)
(341,412,0)
(400,333,0)
(52,263,0)
(394,220,0)
(4,325,0)
(361,323,0)
(345,70,0)
(231,325,0)
(414,258,0)
(363,162,0)
(218,156,0)
(399,47,0)
(132,210,0)
(309,161,0)
(47,270,0)
(53,209,0)
(113,227,0)
(161,171,0)
(321,77,0)
(330,172,0)
(316,414,0)
(206,285,0)
(375,258,0)
(31,209,0)
(236,51,0)
(329,121,0)
(214,365,0)
(200,252,0)
(248,162,0)
(34,351,0)
(59,290,0)
(236,333,0)
(136,172,0)
(415,121,0)
(68,68,0)
(264,132,0)
(359,266,0)
(178,252,0)
(331,210,0)
(333,400,0)
(188,151,0)
(389,403,0)
(209,223,0)
(130,175,0)
(405,225,0)
(330,256,0)
(389,323,0)
(103,178,0)
(400,382,0)
(300,127,0)
(68,382,0)
(365,322,0)
(137,296,0)
(341,203,0)
(368,246,0)
(271,314,0)
(166,16,0)
(1,400,0)
(33,266,0)
(249,209,0)
(175,294,0)
(209,262,0)
(279,127,0)
(61,296,0)
(344,98,0)
(241,99,0)
(413,377,0)
(70,328,0)
(245,296,0)
(112,172,0)
(329,421,0)
(334,127,0)
(336,28,0)
(378,266,0)
(399,209,0)
(362,296,0)
(204,328,0)
(353,320,0)
(10,34,0)
(244,350,0)
(19,45,0)
(106,397,0)
(159,173,0)
(56,296,0)
(343,267,0)
(235,264,0)
(415,388,0)
(369,252,0)
(68,333,0)
(144,229,0)
(157,326,0)
(151,262,0)
(391,127,0)
(359,111,0)
(201,162,0)
(132,264,0)
(412,382,0)
(68,127,0)
(4,392,0)
(367,288,0)
(143,400,0)
(1,228,0)
(269,397,0)
(17,270,0)
(382,333,0)
(1,412,0)
(220,256,0)
(154,169,0)
(121,415,0)
(163,91,0)
(346,127,0)
(233,127,0)
(356,16,0)
(374,290,0)
(257,40,0)
(32,48,0)
(335,127,0)
(391,371,0)
(104,296,0)
(409,206,0)
(77,209,0)
(179,238,0)
(296,369,0)
(333,68,0)
(205,185,0)
(140,317,0)
(68,329,0)
(172,362,0)
(261,173,0)
(301,28,0)
(232,249,0)
(333,412,0)
(72,174,0)
(382,400,0)
(268,158,0)
(333,374,0)
(370,289,0)
(373,296,0)
(118,214,0)
(338,33,0)
(341,51,0)
(168,361,0)
(207,256,0)
(141,288,0)
(365,214,0)
(317,324,0)
(382,228,0)
(263,412,0)
(397,275,0)
(40,399,0)
(271,241,0)
(1,68,0)
(398,121,0)
(24,252,0)
(333,127,0)
(15,296,0)
(342,80,0)
(412,127,0)
(158,73,0)
(213,270,0)
(267,162,0)
(236,391,0)
(157,377,0)
(333,333,0)
(381,61,0)
(18,127,0)
(110,15,0)
(300,172,0)
(143,121,0)
(91,252,0)
(236,382,0)
(411,56,0)
(273,89,0)
(389,73,0)
(186,35,0)
(104,4,0)
(90,262,0)
(324,341,0)
(372,157,0)
(391,121,0)
(228,80,0)
(91,33,0)
(39,267,0)
(100,400,0)
(333,51,0)
(45,19,0)
(249,355,0)
(374,121,0)
(25,162,0)
(397,185,0)
(228,400,0)
(0,274,0)
(254,362,0)
(239,373,0)
(175,266,0)
(413,209,0)
(317,296,0)
(174,296,0)
(156,332,0)
(99,241,0)
(236,228,0)
(256,15,0)
(173,175,0)
(236,412,0)
(175,127,0)
(397,288,0)
(398,340,0)
(302,129,0)
(161,121,0)
(113,377,0)
(100,93,0)
(306,356,0)
(304,359,0)
(77,377,0)
(384,16,0)
(368,121,0)
(21,262,0)
(289,355,0)
(23,252,0)
(70,1,0)
(107,195,0)
(401,263,0)
(202,174,0)
(61,273,0)
(149,237,0)
(197,251,0)
(412,400,0)
(228,228,0)
(400,143,0)
(187,332,0)
(361,251,0)
(340,398,0)
(377,262,0)
(242,363,0)
(376,162,0)
(237,411,0)
(369,296,0)
(195,355,0)
(298,296,0)
(67,77,0)
(48,338,0)
(249,370,0)
(16,356,0)
(295,187,0)
(54,175,0)
(154,322,0)
(157,359,0)
(251,296,0)
(394,151,0)
(177,314,0)
(288,397,0)
(207,172,0)
(410,121,0)
(410,84,0)
(179,24,0)
(249,161,0)
(52,121,0)
(412,228,0)
(52,298,0)
(247,200,0)
(70,121,0)
(161,133,0)
(303,162,0)
(109,338,0)
(263,400,0)
(356,252,0)
(70,127,0)
(185,373,0)
(379,382,0)
(87,19,0)
(263,51,0)
(236,400,0)
(263,382,0)
(390,341,0)
(143,225,0)
(68,51,0)
(350,324,0)
(278,33,0)
(47,399,0)
(4,121,0)
(216,369,0)
(35,296,0)
(397,266,0)
(394,112,0)
(181,127,0)
(310,256,0)
(80,121,0)
(56,411,0)
(382,68,0)
(68,412,0)
(260,132,0)
(150,191,0)
(400,228,0)
(100,411,0)
(263,52,0)
(270,17,0)
(225,143,0)
(14,155,0)
(73,209,0)
(400,400,0)
(280,179,0)
(224,162,0)
(422,266,0)
(114,300,0)
(228,333,0)
(16,266,0)
(85,324,0)
(29,333,0)
(152,412,0)
(199,273,0)
(341,324,0)
(236,68,0)
(328,296,0)
(318,162,0)
(228,127,0)
(196,392,0)
(400,412,0)
(289,377,0)
(148,113,0)
(27,207,0)
(33,164,0)
(411,127,0)
(313,70,0)
(153,399,0)
(46,127,0)
(220,164,0)
(86,391,0)
(402,320,0)
(30,86,0)
(129,33,0)
(198,112,0)
(102,179,0)
(382,51,0)
(95,154,0)
(419,127,0)
(368,382,0)
(17,296,0)
(258,323,0)
(358,162,0)
(352,15,0)
(341,333,0)
(52,371,0)
(400,127,0)
(82,317,0)
(276,52,0)
(338,109,0)
(370,377,0)
(73,355,0)
(400,51,0)
(364,262,0)
(70,28,0)
(366,368,0)
(210,252,0)
(277,133,0)
(290,59,0)
(380,391,0)
(105,143,0)
(214,296,0)
(363,36,0)
(330,275,0)
(337,161,0)
(273,323,0)
(227,113,0)
(266,162,0)
(386,7,0)
(190,411,0)
(8,147,0)
(217,362,0)
(298,52,0)
(411,267,0)
(286,351,0)
(132,98,0)
(52,127,0)
(215,84,0)
(70,267,0)
(157,209,0)
(193,400,0)
(392,4,0)
(229,363,0)
(55,363,0)
(297,87,0)
(413,355,0)
(89,273,0)
(139,296,0)
(398,359,0)
(206,137,0)
(263,228,0)
(57,392,0)
(373,185,0)
(293,4,0)
(263,68,0)
(62,24,0)
(325,400,0)
(55,16,0)
(207,162,0)
(264,235,0)
(147,391,0)
(411,237,0)
(371,371,0)
(126,23,0)
(228,68,0)
(296,162,0)
(11,263,0)
(237,296,0)
(200,36,0)
(93,100,0)
(421,329,0)
(112,256,0)
(6,137,0)
(310,238,0)
(236,138,0)
(220,172,0)
(26,210,0)
(4,371,0)
(45,332,0)
(50,55,0)
(420,162,0)
(33,129,0)
(412,410,0)
(282,121,0)
(409,162,0)
(249,377,0)
(314,271,0)
(81,294,0)
(258,274,0)
(108,236,0)
(341,400,0)
(404,34,0)
(20,324,0)
(78,200,0)
(44,162,0)
(135,262,0)
(68,228,0)
(315,374,0)
(281,262,0)
(392,296,0)
(222,418,0)
(64,127,0)
(60,17,0)
(165,191,0)
(299,343,0)
(155,80,0)
(234,104,0)
(355,262,0)
(4,127,0)
(274,296,0)
(100,333,0)
(184,162,0)
(137,206,0)
(415,229,0)
(255,178,0)
(253,139,0)
(1,417,0)
(208,127,0)
(350,296,0)
(146,174,0)
(84,215,0)
(121,162,0)
(273,61,0)
(322,154,0)
(265,421,0)
(324,127,0)
(388,415,0)
(179,266,0)
(211,104,0)
(134,262,0)
(412,68,0)
(145,91,0)
(125,48,0)
(391,267,0)
(230,156,0)
(173,363,0)
(329,68,0)
(147,296,0)
(80,155,0)
(73,389,0)
(325,382,0)
(338,48,0)
(189,35,0)
(36,363,0)
(294,252,0)
(396,45,0)
(206,409,0)
(170,296,0)
(76,310,0)
(1,333,0)
(354,147,0)
(272,328,0)
(395,413,0)
(292,289,0)
(285,206,0)
(274,258,0)
(399,40,0)
(70,371,0)
(347,365,0)
(48,252,0)
(100,51,0)
(258,414,0)
(241,271,0)
(142,107,0)
(33,338,0)
(71,127,0)
(324,267,0)
(86,296,0)
(382,382,0)
(100,68,0)
(74,195,0)
(23,264,0)
(131,391,0)
(36,200,0)
(260,139,0)
(325,231,0)
(412,412,0)
(68,400,0)
(264,23,0)
(359,398,0)
(300,256,0)
(355,195,0)
(101,61,0)
(1,382,0)
(408,227,0)
(4,267,0)
(270,323,0)
(128,314,0)
(172,323,0)
(96,56,0)
(226,411,0)
(185,397,0)
(343,296,0)
(169,154,0)
(58,343,0)
(320,92,0)
(416,373,0)
(323,389,0)
(325,4,0)
(65,355,0)
(307,162,0)
(180,228,0)
(87,296,0)
(328,70,0)
(374,333,0)
(418,332,0)
(287,262,0)
(325,51,0)
(289,370,0)
(399,377,0)
(246,368,0)
(417,1,0)
(22,262,0)
(43,371,0)
(4,104,0)
(333,228,0)
(182,356,0)
(385,23,0)
(161,161,0)
(259,262,0)
(267,343,0)
(75,332,0)
(33,91,0)
(314,296,0)
(322,365,0)
(12,294,0)
(16,55,0)
(1,51,0)
(270,47,0)
(324,317,0)
(391,147,0)
(228,412,0)
(183,229,0)
(88,325,0)
(146,162,0)
(77,355,0)
(325,333,0)
(49,298,0)
(391,86,0)
(406,137,0)
(52,267,0)
(382,368,0)
(411,121,0)
(407,139,0)
(38,33,0)
(412,333,0)
(394,310,0)
(387,245,0)
(332,191,0)
(357,413,0)
(122,127,0)
(73,377,0)
(176,17,0)
(324,121,0)
(341,228,0)
(160,99,0)
(332,45,0)
(382,127,0)
(289,121,0)
(320,402,0)
(1,70,0)
(16,262,0)
(129,361,0)
(228,51,0)
(63,388,0)
(157,355,0)
(251,361,0)
(411,371,0)
(161,337,1)
(166,356,1)
(265,339,1)
(228,80,1)
(345,313,1)
(365,214,1)
(368,246,1)
(218,230,1)
(151,188,1)
(416,269,1)
(382,382,1)
(394,300,1)
(55,50,1)
(300,256,1)
(174,296,1)
(397,266,1)
(413,121,1)
(382,368,1)
(393,56,1)
(386,187,1)
(338,48,1)
(382,228,1)
(20,35,1)
(277,413,1)
(211,234,1)
(394,207,1)
(359,398,1)
(341,382,1)
(83,152,1)
(14,342,1)
(209,31,1)
(228,228,1)
(205,373,1)
(263,412,1)
(245,296,1)
(360,384,1)
(294,252,1)
(61,381,1)
(1,412,1)
(353,121,1)
(289,219,1)
(1,37,1)
(91,252,1)
(334,228,1)
(221,33,1)
(356,306,1)
(399,209,1)
(293,35,1)
(351,286,1)
(259,355,1)
(33,129,1)
(217,169,1)
(309,346,1)
(0,386,1)
(68,412,1)
(371,371,1)
(52,263,1)
(266,378,1)
(157,377,1)
(175,266,1)
(0,89,1)
(400,400,1)
(352,110,1)
(154,95,1)
(207,172,1)
(324,317,1)
(175,173,1)
(309,334,1)
(32,125,1)
(132,264,1)
(45,19,1)
(17,296,1)
(82,140,1)
(107,142,1)
(391,371,1)
(411,267,1)
(56,96,1)
(212,277,1)
(129,302,1)
(153,270,1)
(24,252,1)
(37,28,1)
(19,87,1)
(421,265,1)
(202,320,1)
(27,249,1)
(373,296,1)
(228,382,1)
(300,172,1)
(249,161,1)
(136,362,1)
(179,266,1)
(106,288,1)
(374,121,1)
(368,121,1)
(249,349,1)
(263,68,1)
(321,351,1)
(325,231,1)
(400,333,1)
(299,58,1)
(350,296,1)
(364,209,1)
(147,354,1)
(406,6,1)
(270,213,1)
(143,225,1)
(330,172,1)
(273,61,1)
(394,220,1)
(90,377,1)
(232,371,1)
(4,104,1)
(228,68,1)
(199,61,1)
(408,148,1)
(170,363,1)
(264,235,1)
(78,242,1)
(354,8,1)
(317,82,1)
(355,195,1)
(412,228,1)
(145,414,1)
(116,35,1)
(148,2,1)
(23,126,1)
(33,338,1)
(396,19,1)
(4,325,1)
(272,1,1)
(324,350,1)
(73,355,1)
(336,345,1)
(228,333,1)
(309,122,1)
(197,338,1)
(312,115,1)
(251,296,1)
(10,404,1)
(177,132,1)
(348,210,1)
(100,393,1)
(375,274,1)
(363,36,1)
(4,267,1)
(132,260,1)
(73,158,1)
(188,16,1)
(157,326,1)
(167,226,1)
(180,70,1)
(216,170,1)
(237,296,1)
(185,205,1)
(226,190,1)
(367,156,1)
(390,317,1)
(236,400,1)
(391,86,1)
(227,408,1)
(122,382,1)
(356,252,1)
(152,391,1)
(341,203,1)
(161,133,1)
(258,274,1)
(100,333,1)
(289,209,1)
(49,276,1)
(289,121,1)
(288,141,1)
(347,214,1)
(305,131,1)
(16,55,1)
(397,288,1)
(108,86,1)
(279,333,1)
(330,124,1)
(61,296,1)
(250,47,1)
(274,296,1)
(253,407,1)
(182,245,1)
(333,51,1)
(325,51,1)
(186,189,1)
(273,199,1)
(213,17,1)
(112,172,1)
(91,163,1)
(323,389,1)
(270,17,1)
(388,63,1)
(333,333,1)
(179,102,1)
(333,382,1)
(81,12,1)
(130,294,1)
(84,215,1)
(52,121,1)
(320,402,1)
(156,332,1)
(382,51,1)
(219,292,1)
(289,377,1)
(57,283,1)
(324,121,1)
(36,200,1)
(228,412,1)
(415,229,1)
(34,252,1)
(100,51,1)
(341,228,1)
(301,336,1)
(86,30,1)
(70,328,1)
(73,377,1)
(40,257,1)
(154,322,1)
(68,68,1)
(370,289,1)
(115,304,1)
(324,267,1)
(88,392,1)
(70,267,1)
(398,312,1)
(341,51,1)
(75,47,1)
(411,371,1)
(290,315,1)
(373,239,1)
(410,121,1)
(31,53,1)
(389,403,1)
(256,383,1)
(300,114,1)
(311,118,1)
(414,258,1)
(277,370,1)
(278,91,1)
(4,121,1)
(333,68,1)
(400,68,1)
(214,311,1)
(8,236,1)
(196,57,1)
(359,266,1)
(369,252,1)
(255,413,1)
(339,424,1)
(4,371,1)
(157,355,1)
(325,228,1)
(366,379,1)
(47,270,1)
(103,255,1)
(328,204,1)
(383,15,1)
(100,93,1)
(112,198,1)
(6,256,1)
(400,228,1)
(176,60,1)
(309,208,1)
(89,273,1)
(263,228,1)
(237,149,1)
(267,343,1)
(220,221,1)
(258,375,1)
(120,75,1)
(157,209,1)
(131,380,1)
(50,360,1)
(361,323,1)
(389,73,1)
(394,310,1)
(100,382,1)
(207,27,1)
(236,412,1)
(193,52,1)
(209,223,1)
(415,388,1)
(294,81,1)
(324,371,1)
(35,296,1)
(95,322,1)
(341,412,1)
(310,76,1)
(97,222,1)
(15,296,1)
(394,330,1)
(273,323,1)
(411,121,1)
(58,39,1)
(178,103,1)
(310,172,1)
(53,245,1)
(411,56,1)
(141,367,1)
(155,14,1)
(128,177,1)
(161,121,1)
(229,183,1)
(244,240,1)
(399,40,1)
(187,295,1)
(110,146,1)
(423,282,1)
(270,323,1)
(413,377,1)
(344,99,1)
(249,355,1)
(325,382,1)
(413,209,1)
(200,247,1)
(377,113,1)
(407,264,1)
(384,166,1)
(2,245,1)
(236,51,1)
(269,106,1)
(70,121,1)
(333,412,1)
(158,268,1)
(232,133,1)
(68,51,1)
(314,128,1)
(322,365,1)
(87,297,1)
(133,212,1)
(17,176,1)
(119,100,1)
(147,296,1)
(200,252,1)
(291,0,1)
(206,137,1)
(236,382,1)
(357,395,1)
(1,333,1)
(328,296,1)
(282,364,1)
(137,406,1)
(4,392,1)
(316,258,1)
(47,399,1)
(68,382,1)
(100,228,1)
(341,390,1)
(220,172,1)
(104,296,1)
(282,259,1)
(395,77,1)
(257,153,1)
(1,51,1)
(412,400,1)
(225,405,1)
(391,236,1)
(55,363,1)
(409,206,1)
(412,410,1)
(38,278,1)
(228,400,1)
(263,333,1)
(100,412,1)
(382,400,1)
(335,68,1)
(369,216,1)
(60,323,1)
(114,175,1)
(263,11,1)
(359,157,1)
(168,251,1)
(89,284,1)
(142,74,1)
(325,68,1)
(343,299,1)
(101,156,1)
(374,290,1)
(400,382,1)
(394,112,1)
(309,335,1)
(12,35,1)
(371,121,1)
(296,369,1)
(77,67,1)
(391,267,1)
(362,254,1)
(77,267,1)
(382,333,1)
(410,84,1)
(314,296,1)
(342,180,1)
(382,68,1)
(33,266,1)
(210,26,1)
(124,397,1)
(331,418,1)
(391,121,1)
(1,382,1)
(298,94,1)
(139,296,1)
(404,267,1)
(236,228,1)
(100,400,1)
(129,361,1)
(172,136,1)
(371,267,1)
(263,51,1)
(333,228,1)
(297,120,1)
(283,293,1)
(282,90,1)
(33,91,1)
(330,256,1)
(292,42,1)
(11,298,1)
(174,72,1)
(207,256,1)
(276,116,1)
(392,196,1)
(3,387,1)
(411,100,1)
(13,172,1)
(156,218,1)
(118,409,1)
(52,267,1)
(68,333,1)
(100,68,1)
(187,332,1)
(249,377,1)
(247,78,1)
(361,251,1)
(222,187,1)
(63,423,1)
(175,294,1)
(338,109,1)
(74,65,1)
(424,324,1)
(230,418,1)
(400,51,1)
(206,285,1)
(23,252,1)
(397,185,1)
(43,161,1)
(161,161,1)
(412,412,1)
(325,88,1)
(260,139,1)
(137,296,1)
(413,357,1)
(378,422,1)
(380,35,1)
(149,119,1)
(39,414,1)
(361,168,1)
(290,59,1)
(48,252,1)
(392,296,1)
(370,377,1)
(236,68,1)
(195,223,1)
(359,178,1)
(96,167,1)
(159,261,1)
(332,45,1)
(194,43,1)
(304,178,1)
(391,147,1)
(132,210,1)
(329,121,1)
(320,92,1)
(382,412,1)
(68,329,1)
(54,130,1)
(306,182,1)
(388,296,1)
(77,377,1)
(398,121,1)
(405,105,1)
(365,347,1)
(35,186,1)
(324,341,1)
(87,296,1)
(68,228,1)
(16,266,1)
(249,370,1)
(1,228,1)
(274,291,1)
(333,374,1)
(30,305,1)
(362,296,1)
(351,34,1)
(317,296,1)
(387,296,1)
(412,382,1)
(62,250,1)
(310,256,1)
(208,400,1)
(263,382,1)
(295,66,1)
(333,400,1)
(251,5,1)
(72,202,1)
(414,316,1)
(288,252,1)
(264,23,1)
(172,362,1)
(52,298,1)
(400,143,1)
(263,401,1)
(260,9,1)
(99,241,1)
(76,179,1)
(245,3,1)
(34,10,1)
(337,309,1)
(52,371,1)
(256,15,1)
(66,332,1)
(398,340,1)
(341,400,1)
(341,333,1)
(121,415,1)
(214,296,1)
(263,400,1)
(254,217,1)
(236,138,1)
(24,62,1)
(29,411,1)
(381,101,1)
(239,416,1)
(349,232,1)
(412,68,1)
(146,174,1)
(261,54,1)
(220,256,1)
(286,34,1)
(70,371,1)
(70,28,1)
(385,41,1)
(173,159,1)
(329,421,1)
(343,296,1)
(236,333,1)
(400,412,1)
(86,296,1)
(99,160,1)
(5,197,1)
(126,385,1)
(394,151,1)
(15,352,1)
(183,144,1)
(370,209,1)
(195,107,1)
(399,377,1)
(75,89,1)
(132,266,1)
(48,32,1)
(370,355,1)
(1,417,1)
(178,252,1)
(412,51,1)
(112,256,1)
(26,331,1)
(84,83,1)
(143,121,1)
(1,68,1)
(242,266,1)
(315,29,1)
(268,13,1)
(241,271,1)
(289,355,1)
(413,355,1)
(42,359,1)
(412,333,1)
(70,1,1)
(309,279,1)
(371,194,1)
(298,296,1)
(399,355,1)
(28,296,1)
(346,412,1)
(179,24,1)
(125,38,1)
(246,319,1)
(236,108,1)
(113,227,1)
(320,353,1)
(144,388,1)
(65,245,1)
(1,400,1)
(372,398,1)
(204,272,1)
(325,400,1)
(16,356,1)
(101,344,1)
(140,85,1)
(319,366,1)
(350,244,1)
(240,341,1)
(163,145,1)
(160,241,1)
(41,348,1)
(325,412,1)
(228,51,1)
(284,273,1)
(418,332,1)
(157,372,1)
(85,20,1)
(395,351,1)
(325,333,1)
(45,396,1)
(210,252,1)
(341,68,1)
(249,133,1)
(198,99,1)
(77,209,1)
(104,211,1)
(411,237,1)
(105,193,1)
(189,249,1)
(169,154,1)
(102,280,1)
(280,24,1)
(379,4,1)
(28,301,1)
(249,209,1)
(229,363,1)
(56,296,1)
(9,139,1)
(68,400,1)
(418,97,1)
(313,35,1)
(80,121,1)
(73,209,1)
(113,223,1)
(67,321,1)
(94,49,1)
(80,155,1)
(190,35,1)
(77,355,1)
(185,373,1)
(271,314,1)
(173,363,1)
(139,253,1)
(258,323,1)
(234,325,1)
(172,362,2)
(249,35,2)
(289,413,2)
(416,156,2)
(258,89,2)
(4,267,2)
(394,300,2)
(103,413,2)
(377,245,2)
(197,414,2)
(218,418,2)
(325,231,2)
(273,156,2)
(55,363,2)
(220,256,2)
(236,333,2)
(4,392,2)
(175,173,2)
(315,35,2)
(254,245,2)
(132,210,2)
(76,47,2)
(240,35,2)
(272,35,2)
(43,35,2)
(267,414,2)
(149,35,2)
(394,330,2)
(174,296,2)
(236,400,2)
(260,418,2)
(289,209,2)
(353,245,2)
(228,333,2)
(325,68,2)
(86,296,2)
(166,245,2)
(324,350,2)
(341,35,2)
(100,51,2)
(67,351,2)
(397,185,2)
(1,333,2)
(373,296,2)
(236,51,2)
(245,296,2)
(34,414,2)
(228,400,2)
(364,245,2)
(305,35,2)
(118,245,2)
(200,252,2)
(151,245,2)
(381,156,2)
(415,229,2)
(289,121,2)
(236,68,2)
(382,35,2)
(140,35,2)
(398,413,2)
(333,374,2)
(361,251,2)
(61,99,2)
(391,371,2)
(333,333,2)
(102,47,2)
(84,215,2)
(321,351,2)
(207,172,2)
(410,84,2)
(343,296,2)
(382,228,2)
(130,35,2)
(322,365,2)
(310,172,2)
(15,296,2)
(333,35,2)
(217,245,2)
(70,35,2)
(60,245,2)
(77,377,2)
(205,156,2)
(264,418,2)
(68,333,2)
(412,51,2)
(100,333,2)
(334,35,2)
(324,371,2)
(325,228,2)
(382,412,2)
(33,414,2)
(81,35,2)
(120,47,2)
(194,35,2)
(54,35,2)
(16,356,2)
(183,245,2)
(114,35,2)
(361,323,2)
(2,245,2)
(341,382,2)
(89,156,2)
(167,35,2)
(383,245,2)
(161,161,2)
(256,245,2)
(95,245,2)
(68,400,2)
(372,413,2)
(1,412,2)
(45,47,2)
(290,35,2)
(341,333,2)
(91,252,2)
(1,51,2)
(375,89,2)
(324,341,2)
(15,245,2)
(370,377,2)
(221,414,2)
(396,89,2)
(359,157,2)
(30,35,2)
(70,371,2)
(284,99,2)
(411,267,2)
(320,92,2)
(142,245,2)
(300,35,2)
(345,35,2)
(143,121,2)
(357,414,2)
(228,382,2)
(382,68,2)
(301,35,2)
(409,245,2)
(70,28,2)
(399,40,2)
(320,402,2)
(415,245,2)
(414,89,2)
(236,228,2)
(47,399,2)
(310,47,2)
(53,245,2)
(350,35,2)
(379,35,2)
(126,418,2)
(156,332,2)
(400,382,2)
(236,35,2)
(236,382,2)
(323,245,2)
(1,35,2)
(411,56,2)
(27,249,2)
(338,109,2)
(349,35,2)
(397,266,2)
(86,35,2)
(179,47,2)
(234,35,2)
(99,241,2)
(267,343,2)
(329,421,2)
(70,267,2)
(333,228,2)
(333,68,2)
(154,245,2)
(10,414,2)
(258,323,2)
(176,245,2)
(157,413,2)
(73,377,2)
(370,289,2)
(45,89,2)
(246,35,2)
(232,35,2)
(263,228,2)
(366,35,2)
(414,258,2)
(45,19,2)
(163,414,2)
(112,99,2)
(204,35,2)
(19,87,2)
(316,187,2)
(23,252,2)
(110,245,2)
(73,209,2)
(343,414,2)
(390,35,2)
(258,274,2)
(169,245,2)
(368,246,2)
(300,172,2)
(263,401,2)
(312,413,2)
(28,35,2)
(317,35,2)
(157,355,2)
(105,35,2)
(253,418,2)
(210,418,2)
(48,252,2)
(341,228,2)
(139,296,2)
(341,412,2)
(56,35,2)
(404,414,2)
(359,413,2)
(145,414,2)
(295,47,2)
(1,417,2)
(101,156,2)
(23,418,2)
(106,156,2)
(174,245,2)
(220,414,2)
(411,100,2)
(36,200,2)
(273,61,2)
(373,156,2)
(211,35,2)
(391,267,2)
(133,414,2)
(289,355,2)
(249,209,2)
(413,121,2)
(356,245,2)
(325,400,2)
(156,418,2)
(413,377,2)
(121,415,2)
(58,414,2)
(152,35,2)
(277,414,2)
(90,245,2)
(263,382,2)
(349,414,2)
(198,99,2)
(374,121,2)
(80,121,2)
(80,155,2)
(355,245,2)
(276,35,2)
(298,35,2)
(193,35,2)
(42,413,2)
(87,47,2)
(270,245,2)
(185,156,2)
(380,35,2)
(143,225,2)
(411,237,2)
(330,172,2)
(116,35,2)
(333,400,2)
(319,35,2)
(412,410,2)
(100,382,2)
(48,414,2)
(70,1,2)
(325,333,2)
(399,245,2)
(249,414,2)
(159,35,2)
(210,252,2)
(399,355,2)
(147,35,2)
(82,35,2)
(33,129,2)
(199,156,2)
(230,418,2)
(190,35,2)
(398,121,2)
(282,245,2)
(187,47,2)
(394,112,2)
(400,228,2)
(382,382,2)
(388,245,2)
(206,245,2)
(168,414,2)
(333,412,2)
(395,414,2)
(397,288,2)
(96,35,2)
(330,156,2)
(330,256,2)
(400,143,2)
(120,89,2)
(365,245,2)
(363,36,2)
(411,121,2)
(19,47,2)
(132,260,2)
(413,414,2)
(424,35,2)
(244,35,2)
(361,414,2)
(129,414,2)
(0,187,2)
(1,400,2)
(362,296,2)
(411,371,2)
(273,323,2)
(259,245,2)
(178,413,2)
(399,209,2)
(329,35,2)
(394,310,2)
(40,245,2)
(339,35,2)
(236,412,2)
(297,89,2)
(207,256,2)
(284,156,2)
(370,355,2)
(113,223,2)
(24,47,2)
(341,51,2)
(209,223,2)
(314,296,2)
(237,296,2)
(61,156,2)
(322,245,2)
(4,121,2)
(52,371,2)
(33,91,2)
(219,413,2)
(393,35,2)
(100,93,2)
(94,35,2)
(328,35,2)
(62,47,2)
(195,223,2)
(33,266,2)
(342,35,2)
(250,47,2)
(157,377,2)
(249,370,2)
(249,133,2)
(100,228,2)
(351,414,2)
(228,51,2)
(11,35,2)
(296,369,2)
(4,371,2)
(121,245,2)
(63,245,2)
(400,412,2)
(158,245,2)
(333,382,2)
(4,35,2)
(414,187,2)
(108,35,2)
(50,245,2)
(137,296,2)
(153,245,2)
(399,377,2)
(338,414,2)
(49,35,2)
(412,382,2)
(391,86,2)
(336,35,2)
(304,413,2)
(144,245,2)
(313,35,2)
(249,355,2)
(291,89,2)
(75,47,2)
(391,121,2)
(61,296,2)
(125,414,2)
(423,245,2)
(418,187,2)
(73,158,2)
(146,245,2)
(418,332,2)
(232,414,2)
(329,121,2)
(293,35,2)
(324,317,2)
(34,252,2)
(294,252,2)
(335,35,2)
(147,296,2)
(236,138,2)
(83,35,2)
(415,388,2)
(195,245,2)
(208,35,2)
(356,252,2)
(396,47,2)
(100,68,2)
(261,35,2)
(355,195,2)
(325,51,2)
(160,418,2)
(16,55,2)
(214,245,2)
(132,264,2)
(189,249,2)
(362,245,2)
(100,412,2)
(392,296,2)
(187,332,2)
(179,24,2)
(368,35,2)
(412,333,2)
(124,156,2)
(38,414,2)
(263,412,2)
(113,245,2)
(371,267,2)
(47,270,2)
(368,121,2)
(263,68,2)
(394,151,2)
(333,51,2)
(311,245,2)
(5,414,2)
(377,113,2)
(269,156,2)
(229,363,2)
(294,35,2)
(392,35,2)
(382,51,2)
(274,89,2)
(1,382,2)
(407,418,2)
(66,89,2)
(370,413,2)
(132,418,2)
(382,400,2)
(263,400,2)
(360,245,2)
(113,227,2)
(382,333,2)
(265,35,2)
(35,296,2)
(199,99,2)
(413,209,2)
(263,35,2)
(421,35,2)
(68,51,2)
(225,35,2)
(6,245,2)
(57,35,2)
(391,35,2)
(406,245,2)
(47,245,2)
(104,296,2)
(129,361,2)
(68,412,2)
(207,249,2)
(209,245,2)
(55,245,2)
(354,35,2)
(65,245,2)
(161,35,2)
(87,296,2)
(228,68,2)
(24,252,2)
(178,252,2)
(400,333,2)
(68,228,2)
(77,355,2)
(229,245,2)
(295,89,2)
(371,371,2)
(412,68,2)
(400,35,2)
(107,245,2)
(411,35,2)
(132,266,2)
(241,271,2)
(175,294,2)
(306,245,2)
(292,413,2)
(344,99,2)
(359,266,2)
(228,80,2)
(239,156,2)
(263,333,2)
(400,400,2)
(291,187,2)
(154,322,2)
(77,267,2)
(52,35,2)
(66,47,2)
(371,35,2)
(316,89,2)
(324,267,2)
(388,296,2)
(99,418,2)
(251,296,2)
(394,220,2)
(89,273,2)
(1,228,2)
(394,207,2)
(341,203,2)
(139,418,2)
(288,252,2)
(68,35,2)
(331,418,2)
(314,418,2)
(389,245,2)
(104,35,2)
(258,187,2)
(405,35,2)
(70,328,2)
(410,121,2)
(255,413,2)
(317,296,2)
(87,89,2)
(196,35,2)
(297,47,2)
(237,35,2)
(249,377,2)
(384,245,2)
(88,35,2)
(251,414,2)
(341,400,2)
(1,68,2)
(280,47,2)
(359,178,2)
(264,23,2)
(391,236,2)
(222,187,2)
(186,249,2)
(412,228,2)
(52,267,2)
(31,245,2)
(299,414,2)
(172,245,2)
(309,35,2)
(288,156,2)
(187,89,2)
(52,298,2)
(241,418,2)
(32,414,2)
(325,412,2)
(370,209,2)
(4,104,2)
(300,256,2)
(320,245,2)
(85,35,2)
(325,35,2)
(100,400,2)
(408,245,2)
(286,414,2)
(112,172,2)
(278,414,2)
(271,418,2)
(412,400,2)
(37,35,2)
(8,35,2)
(365,214,2)
(271,314,2)
(409,206,2)
(386,187,2)
(374,290,2)
(260,139,2)
(131,35,2)
(179,266,2)
(161,121,2)
(73,355,2)
(347,245,2)
(137,245,2)
(382,368,2)
(68,68,2)
(298,296,2)
(279,35,2)
(70,121,2)
(80,35,2)
(157,209,2)
(206,137,2)
(155,35,2)
(290,59,2)
(19,89,2)
(9,418,2)
(91,414,2)
(115,413,2)
(375,187,2)
(398,340,2)
(41,418,2)
(385,418,2)
(289,377,2)
(220,172,2)
(324,121,2)
(324,35,2)
(412,35,2)
(39,414,2)
(84,35,2)
(157,326,2)
(12,35,2)
(337,35,2)
(141,156,2)
(72,245,2)
(14,35,2)
(227,245,2)
(346,35,2)
(332,45,2)
(206,285,2)
(136,245,2)
(16,266,2)
(310,256,2)
(182,245,2)
(180,35,2)
(369,252,2)
(270,17,2)
(212,414,2)
(214,296,2)
(177,418,2)
(4,325,2)
(359,398,2)
(367,156,2)
(202,245,2)
(328,296,2)
(332,47,2)
(325,382,2)
(173,363,2)
(148,245,2)
(228,228,2)
(413,355,2)
(74,245,2)
(52,121,2)
(410,35,2)
(371,121,2)
(391,147,2)
(389,73,2)
(263,51,2)
(249,161,2)
(52,263,2)
(273,99,2)
(412,412,2)
(268,245,2)
(97,187,2)
(112,256,2)
(257,245,2)
(33,338,2)
(226,35,2)
(75,89,2)
(77,209,2)
(16,245,2)
(20,35,2)
(173,35,2)
(274,296,2)
(175,35,2)
(389,403,2)
(338,48,2)
(264,235,2)
(35,249,2)
(119,35,2)
(56,296,2)
(351,34,2)
(256,15,2)
(397,156,2)
(350,296,2)
(146,174,2)
(161,133,2)
(274,187,2)
(73,245,2)
(228,412,2)
(188,245,2)
(400,68,2)
(381,99,2)
(143,35,2)
(29,35,2)
(332,89,2)
(13,245,2)
(28,296,2)
(185,373,2)
(77,351,2)
(17,245,2)
(341,68,2)
(128,418,2)
(213,245,2)
(374,35,2)
(129,302,2)
(352,245,2)
(100,35,2)
(122,35,2)
(0,89,2)
(323,389,2)
(283,35,2)
(26,418,2)
(89,99,2)
(270,323,2)
(348,418,2)
(17,296,2)
(101,99,2)
(68,382,2)
(175,266,2)
(228,35,2)
(195,107,2)
(169,154,2)
(68,329,2)
(400,51,2)
-----------------------------------
(0,sp)
(1,(float *)
(2,nsamples)
(3,user_datafmt)
(4,horizontalAccumulate16(up, llen, sp->stride,\n\\n\\t\\t\\t\\t\\t(uint16 *)
(5,stream)
(6,sp)
(7,)
(8,sp)
(9,msg)
(10,tif_flags)
(11,op)
(12,tif)
(13,nsamples)
(14,float)
(15,sp->stream)
(16,TIFFErrorExt(tif->tif_clientdata, module,\n\\n\\t\\t\\t"%d bit input not supported in PixarLog",\n\\n\\t\\t\\ttd->td_bitspersample)
(17,sp->stream)
(18,case PIXARLOGDATAFMT_8BIT:)
(19,&sp->stream)
(20,up)
(21,case PIXARLOGDATAFMT_FLOAT:)
(22,case PIXARLOGDATAFMT_8BIT:)
(23,tif->tif_row)
(24,tif->tif_clientdata)
(25,if (sp->stream.avail_out != nsamples * sizeof(uint16)
(26,tif_clientdata)
(27,1)
(28,sp->stride)
(29,op)
(30,stride)
(31,occ)
(32,tif_row)
(33,TIFFErrorExt(tif->tif_clientdata, module,\n\\n\\t\\t    "Not enough data at scanline %lu (short " TIFF_UINT64_FORMAT " bytes)
(34,tif->tif_flags)
(35,sp->user_datafmt)
(36,&tif->tif_dir)
(37,op)
(38,"Not enough data at scanline %lu (short " TIFF_UINT64_FORMAT " bytes)
(39,up)
(40,sizeof(uint16)
(41,"Decoding error at scanline %lu, %s")
(42,nsamples)
(43,up)
(44,if (sp->stream.avail_out != 0)
(45,inflate(&sp->stream, Z_PARTIAL_FLUSH)
(46,case PIXARLOGDATAFMT_FLOAT:)
(47,sp->stream.avail_out != nsamples * sizeof(uint16)
(48,tif->tif_row)
(49,sp)
(50,td_bitspersample)
(51,uint8* op)
(52,horizontalAccumulate11(up, llen, sp->stride,\n\\n\\t\\t\\t\\t\\t(uint16 *)
(53,nsamples)
(54,"Unsupported bits/sample: %d")
(55,td->td_bitspersample)
(56,sp->stride)
(57,sp)
(58,sp)
(59,unsigned char)
(60,sp)
(61,sp->stream)
(62,tif_clientdata)
(63,stride)
(64,case PIXARLOGDATAFMT_16BIT:)
(65,nsamples)
(66,state)
(67,nsamples)
(68,op += llen * sizeof(int16)
(69,if (inflateSync(&sp->stream)
(70,horizontalAccumulateF(up, llen, sp->stride,\n\\n\\t\\t\\t\\t\\t(float *)
(71,case PIXARLOGDATAFMT_11BITLOG:)
(72,NULL)
(73,nsamples * sizeof(uint16)
(74,occ)
(75,state)
(76,0)
(77,TIFFSwabArrayOfShort(up, nsamples)
(78,tif)
(79,if (state == Z_STREAM_END)
(80,llen * sizeof(float)
(81,tif_clientdata)
(82,stride)
(83,llen)
(84,sizeof(unsigned char)
(85,llen)
(86,sp->stride)
(87,sp->stream)
(88,op)
(89,sp->stream.avail_out > 0)
(90,break;)
(91,tif->tif_clientdata)
(92,uint16 s)
(93,unsigned char *)
(94,stride)
(95,4)
(96,stride)
(97,Z_DATA_ERROR)
(98,)
(99,inflateSync(&sp->stream)
(100,(unsigned char *)
(101,sp)
(102,"ZLib cannot deal with buffers this size")
(103,tif_clientdata)
(104,sp->ToLinear16)
(105,llen)
(106,module)
(107,sizeof(uint16)
(108,op)
(109,unsigned long)
(110,sp)
(111,)
(112,return (0)
(113,occ / sizeof(float)
(114,0)
(115,"stride %lu is not a multiple of sample count, "\n\\n\\t\\t\\t"%lu, data truncated.")
(116,up)
(117,llen)
(118,sp)
(119,sp)
(120,sp)
(121,llen = sp->stride * td->td_imagewidth)
(122,break;)
(123,case PIXARLOGDATAFMT_16BIT:)
(124,0)
(125,tif)
(126,tif_row)
(127,)
(128,stream)
(129,(TIFF_UINT64_T)
(130,module)
(131,llen)
(132,TIFFErrorExt(tif->tif_clientdata, module,\n\\n\\t\\t\\t    "Decoding error at scanline %lu, %s",\n\\n\\t\\t\\t    (unsigned long)
(133,i = 0)
(134,case PIXARLOGDATAFMT_8BITABGR:)
(135,case PIXARLOGDATAFMT_11BITLOG:)
(136,avail_out)
(137,sp->tbuf)
(138,unsigned char *)
(139,sp->stream)
(140,sp)
(141,tif_clientdata)
(142,uint16)
(143,llen * sizeof(uint16)
(144,td)
(145,tif)
(146,assert(sp != NULL)
(147,sp->ToLinear8)
(148,occ)
(149,ToLinear8)
(150,if (state != Z_OK)
(151,return 0;)
(152,op)
(153,nsamples)
(154,sizeof(sp->stream.avail_out)
(155,sizeof(float)
(156,state != Z_OK)
(157,(unsigned long)
(158,sizeof(uint16)
(159,td_bitspersample)
(160,Z_OK)
(161,i += llen)
(162,)
(163,tif_clientdata)
(164,)
(165,if (state == Z_DATA_ERROR)
(166,module)
(167,sp)
(168,avail_out)
(169,assert(sizeof(sp->stream.avail_out)
(170,sp)
(171,)
(172,sp->stream.avail_out)
(173,td->td_bitspersample)
(174,sp != NULL)
(175,TIFFErrorExt(tif->tif_clientdata, module,\n\\n\\t\\t\\t\\t  "Unsupported bits/sample: %d",\n\\n\\t\\t\\t\\t  td->td_bitspersample)
(176,stream)
(177,sp)
(178,tif->tif_clientdata)
(179,TIFFErrorExt(tif->tif_clientdata, module, "ZLib cannot deal with buffers this size")
(180,op)
(181,default:)
(182,tif)
(183,td_imagewidth)
(184,sp)
(185,sp->stream.msg)
(186,user_datafmt)
(187,state == Z_STREAM_END)
(188,0)
(189,sp)
(190,up)
(191,)
(192,up)
(193,op)
(194,llen)
(195,occ / sizeof(uint16)
(196,stride)
(197,sp)
(198,0)
(199,avail_out)
(200,tif->tif_dir)
(201,module)
(202,sp)
(203,int16 *)
(204,ToLinearF)
(205,msg)
(206,(unsigned char *)
(207,return (1)
(208,break;)
(209,nsamples = occ)
(210,tif->tif_clientdata)
(211,ToLinear16)
(212,0)
(213,avail_out)
(214,sp->stream)
(215,unsigned char)
(216,tif)
(217,sp)
(218,Z_OK)
(219,llen)
(220,return (0)
(221,0)
(222,state)
(223,tmsize_t occ)
(224,nsamples)
(225,sizeof(uint16)
(226,llen)
(227,sizeof(float)
(228,op += llen * sizeof(float)
(229,td->td_imagewidth)
(230,state)
(231,uint16 *)
(232,i)
(233,case PIXARLOGDATAFMT_8BITABGR:)
(234,sp)
(235,unsigned long)
(236,(unsigned char *)
(237,sp->ToLinear8)
(238,)
(239,stream)
(240,sp)
(241,inflateSync(&sp->stream)
(242,td)
(243,state)
(244,ToLinearF)
(245,sp->user_datafmt)
(246,sizeof(uint16)
(247,tif_dir)
(248,if (tif->tif_flags & TIFF_SWAB)
(249,i < nsamples)
(250,tif)
(251,sp->stream)
(252,TIFF* tif)
(253,stream)
(254,stream)
(255,tif)
(256,sp->stream.next_out)
(257,uint16)
(258,sp->stream.avail_out)
(259,break;)
(260,sp->stream.msg)
(261,td)
(262,)
(263,(uint16 *)
(264,(unsigned long)
(265,int16)
(266,module[] = "PixarLogDecode")
(267,up = sp->tbuf)
(268,uint16)
(269,"ZLib error: %s")
(270,sp->stream.avail_out)
(271,&sp->stream)
(272,sp)
(273,sp->stream.avail_out)
(274,sp->stream)
(275,)
(276,llen)
(277,i)
(278,module)
(279,break;)
(280,module)
(281,case PIXARLOGDATAFMT_12BITPICIO:)
(282,llen)
(283,llen)
(284,0)
(285,unsigned char *)
(286,TIFF_SWAB)
(287,default:)
(288,tif->tif_clientdata)
(289,nsamples % llen)
(290,sizeof(unsigned char)
(291,stream)
(292,nsamples)
(293,up)
(294,tif->tif_clientdata)
(295,Z_STREAM_END)
(296,* sp = DecoderState(tif)
(297,stream)
(298,sp->stride)
(299,tbuf)
(300,return (0)
(301,stride)
(302,TIFF_UINT64_T)
(303,td)
(304,module)
(305,sp)
(306,tif_clientdata)
(307,for (i = 0; i < nsamples; i += llen, up += llen)
(308,)
(309,i)
(310,return (0)
(311,stream)
(312,llen)
(313,up)
(314,sp->stream)
(315,llen)
(316,0)
(317,sp->stride)
(318,switch (sp->user_datafmt)
(319,uint16)
(320,(void)
(321,up)
(322,sizeof(sp->stream.avail_out)
(323,sp->stream.avail_out = (uInt)
(324,horizontalAccumulate12(up, llen, sp->stride,\n\\n\\t\\t\\t\\t\\t(int16 *)
(325,(uint16 *)
(326,unsigned long)
(327,switch (sp->user_datafmt)
(328,sp->ToLinearF)
(329,llen * sizeof(int16)
(330,return (0)
(331,tif)
(332,state = inflate(&sp->stream, Z_PARTIAL_FLUSH)
(333,op += llen * sizeof(unsigned char)
(334,break;)
(335,break;)
(336,sp)
(337,llen)
(338,(unsigned long)
(339,llen)
(340,unsigned long)
(341,(int16 *)
(342,llen)
(343,sp->tbuf)
(344,continue;)
(345,llen)
(346,break;)
(347,avail_out)
(348,module)
(349,nsamples)
(350,sp->ToLinearF)
(351,tif->tif_flags & TIFF_SWAB)
(352,stream)
(353,s)
(354,ToLinear8)
(355,nsamples = occ / sizeof(uint16)
(356,tif->tif_clientdata)
(357,llen)
(358,do)
(359,TIFFWarningExt(tif->tif_clientdata, module,\n\\n\\t\\t\\t"stride %lu is not a multiple of sample count, "\n\\n\\t\\t\\t"%lu, data truncated.", (unsigned long)
(360,td)
(361,sp->stream.avail_out)
(362,sp->stream)
(363,*td = &tif->tif_dir)
(364,break;)
(365,sp->stream.avail_out)
(366,llen)
(367,tif)
(368,llen * sizeof(uint16)
(369,DecoderState(tif)
(370,nsamples -= nsamples % llen)
(371,up += llen)
(372,nsamples)
(373,sp->stream)
(374,llen * sizeof(unsigned char)
(375,avail_out)
(376,if (nsamples % llen)
(377,nsamples = occ / sizeof(float)
(378,"PixarLogDecode")
(379,op)
(380,up)
(381,stream)
(382,op += llen * sizeof(uint16)
(383,next_out)
(384,"%d bit input not supported in PixarLog")
(385,tif)
(386,break;)
(387,sp)
(388,sp->stride)
(389,(uInt)
(390,op)
(391,horizontalAccumulate8(up, llen, sp->stride,\n\\n\\t\\t\\t\\t\\t(unsigned char *)
(392,sp->stride)
(393,op)
(394,RET)
(395,nsamples)
(396,Z_PARTIAL_FLUSH)
(397,TIFFErrorExt(tif->tif_clientdata, module, "ZLib error: %s",\n\\n\\t\\t\\t    sp->stream.msg)
(398,(unsigned long)
(399,nsamples * sizeof(uint16)
(400,op += llen * sizeof(uint16)
(401,uint16 *)
(402,void)
(403,uInt)
(404,tif)
(405,uint16)
(406,tbuf)
(407,sp)
(408,float)
(409,sp->stream.next_out = (unsigned char *)
(410,llen * sizeof(unsigned char)
(411,horizontalAccumulate8abgr(up, llen, sp->stride,\n\\n\\t\\t\\t\\t\\t(unsigned char *)
(412,op += llen * sizeof(unsigned char)
(413,nsamples % llen)
(414,sp->stream.avail_out != 0)
(415,sp->stride * td->td_imagewidth)
(416,sp)
(417,float *)
(418,state == Z_DATA_ERROR)
(419,case PIXARLOGDATAFMT_12BITPICIO:)
(420,i)
(421,sizeof(int16)
(422,module)
(423,sp)
(424,op)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
