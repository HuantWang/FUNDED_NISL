-----label-----
1
-----code-----
static int
_TIFFVGetField(TIFF* tif, uint32 tag, va_list ap)
{
	TIFFDirectory* td = &tif->tif_dir;
	int ret_val = 1;
	uint32 standard_tag = tag;
	const TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);
	if( fip == NULL ) /* cannot happen since TIFFGetField() already checks it */
	    return 0;

	/*
	 * We want to force the custom code to be used for custom
	 * fields even if the tag happens to match a well known 
	 * one - important for reinterpreted handling of standard
	 * tag values in custom directories (i.e. EXIF) 
	 */
	if (fip->field_bit == FIELD_CUSTOM) {
		standard_tag = 0;
	}
	
        if( standard_tag == TIFFTAG_NUMBEROFINKS )
        {
            int i;
            for (i = 0; i < td->td_customValueCount; i++) {
                uint16 val;
                TIFFTagValue *tv = td->td_customValues + i;
                if (tv->info->field_tag != standard_tag)
                    continue;
                if( tv->value == NULL )
                    return 0;
                val = *(uint16 *)tv->value;
                /* Truncate to SamplesPerPixel, since the */
                /* setting code for INKNAMES assume that there are SamplesPerPixel */
                /* inknames. */
                /* Fixes http://bugzilla.maptools.org/show_bug.cgi?id=2599 */
                if( val > td->td_samplesperpixel )
                {
                    TIFFWarningExt(tif->tif_clientdata,"_TIFFVGetField",
                                   "Truncating NumberOfInks from %u to %u",
                                   val, td->td_samplesperpixel);
                    val = td->td_samplesperpixel;
                }
                *va_arg(ap, uint16*) = val;
                return 1;
            }
            return 0;
        }

	switch (standard_tag) {
		case TIFFTAG_SUBFILETYPE:
			*va_arg(ap, uint32*) = td->td_subfiletype;
			break;
		case TIFFTAG_IMAGEWIDTH:
			*va_arg(ap, uint32*) = td->td_imagewidth;
			break;
		case TIFFTAG_IMAGELENGTH:
			*va_arg(ap, uint32*) = td->td_imagelength;
			break;
		case TIFFTAG_BITSPERSAMPLE:
			*va_arg(ap, uint16*) = td->td_bitspersample;
			break;
		case TIFFTAG_COMPRESSION:
			*va_arg(ap, uint16*) = td->td_compression;
			break;
		case TIFFTAG_PHOTOMETRIC:
			*va_arg(ap, uint16*) = td->td_photometric;
			break;
		case TIFFTAG_THRESHHOLDING:
			*va_arg(ap, uint16*) = td->td_threshholding;
			break;
		case TIFFTAG_FILLORDER:
			*va_arg(ap, uint16*) = td->td_fillorder;
			break;
		case TIFFTAG_ORIENTATION:
			*va_arg(ap, uint16*) = td->td_orientation;
			break;
		case TIFFTAG_SAMPLESPERPIXEL:
			*va_arg(ap, uint16*) = td->td_samplesperpixel;
			break;
		case TIFFTAG_ROWSPERSTRIP:
			*va_arg(ap, uint32*) = td->td_rowsperstrip;
			break;
		case TIFFTAG_MINSAMPLEVALUE:
			*va_arg(ap, uint16*) = td->td_minsamplevalue;
			break;
		case TIFFTAG_MAXSAMPLEVALUE:
			*va_arg(ap, uint16*) = td->td_maxsamplevalue;
			break;
		case TIFFTAG_SMINSAMPLEVALUE:
			if (tif->tif_flags & TIFF_PERSAMPLE)
				*va_arg(ap, double**) = td->td_sminsamplevalue;
			else
			{
				/* libtiff historically treats this as a single value. */
				uint16 i;
				double v = td->td_sminsamplevalue[0];
				for (i=1; i < td->td_samplesperpixel; ++i)
					if( td->td_sminsamplevalue[i] < v )
						v = td->td_sminsamplevalue[i];
				*va_arg(ap, double*) = v;
			}
			break;
		case TIFFTAG_SMAXSAMPLEVALUE:
			if (tif->tif_flags & TIFF_PERSAMPLE)
				*va_arg(ap, double**) = td->td_smaxsamplevalue;
			else
			{
				/* libtiff historically treats this as a single value. */
				uint16 i;
				double v = td->td_smaxsamplevalue[0];
				for (i=1; i < td->td_samplesperpixel; ++i)
					if( td->td_smaxsamplevalue[i] > v )
						v = td->td_smaxsamplevalue[i];
				*va_arg(ap, double*) = v;
			}
			break;
		case TIFFTAG_XRESOLUTION:
			*va_arg(ap, float*) = td->td_xresolution;
			break;
		case TIFFTAG_YRESOLUTION:
			*va_arg(ap, float*) = td->td_yresolution;
			break;
		case TIFFTAG_PLANARCONFIG:
			*va_arg(ap, uint16*) = td->td_planarconfig;
			break;
		case TIFFTAG_XPOSITION:
			*va_arg(ap, float*) = td->td_xposition;
			break;
		case TIFFTAG_YPOSITION:
			*va_arg(ap, float*) = td->td_yposition;
			break;
		case TIFFTAG_RESOLUTIONUNIT:
			*va_arg(ap, uint16*) = td->td_resolutionunit;
			break;
		case TIFFTAG_PAGENUMBER:
			*va_arg(ap, uint16*) = td->td_pagenumber[0];
			*va_arg(ap, uint16*) = td->td_pagenumber[1];
			break;
		case TIFFTAG_HALFTONEHINTS:
			*va_arg(ap, uint16*) = td->td_halftonehints[0];
			*va_arg(ap, uint16*) = td->td_halftonehints[1];
			break;
		case TIFFTAG_COLORMAP:
			*va_arg(ap, uint16**) = td->td_colormap[0];
			*va_arg(ap, uint16**) = td->td_colormap[1];
			*va_arg(ap, uint16**) = td->td_colormap[2];
			break;
		case TIFFTAG_STRIPOFFSETS:
		case TIFFTAG_TILEOFFSETS:
			_TIFFFillStriles( tif );
			*va_arg(ap, uint64**) = td->td_stripoffset;
			break;
		case TIFFTAG_STRIPBYTECOUNTS:
		case TIFFTAG_TILEBYTECOUNTS:
			_TIFFFillStriles( tif );
			*va_arg(ap, uint64**) = td->td_stripbytecount;
			break;
		case TIFFTAG_MATTEING:
			*va_arg(ap, uint16*) =
			    (td->td_extrasamples == 1 &&
			    td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA);
			break;
		case TIFFTAG_EXTRASAMPLES:
			*va_arg(ap, uint16*) = td->td_extrasamples;
			*va_arg(ap, uint16**) = td->td_sampleinfo;
			break;
		case TIFFTAG_TILEWIDTH:
			*va_arg(ap, uint32*) = td->td_tilewidth;
			break;
		case TIFFTAG_TILELENGTH:
			*va_arg(ap, uint32*) = td->td_tilelength;
			break;
		case TIFFTAG_TILEDEPTH:
			*va_arg(ap, uint32*) = td->td_tiledepth;
			break;
		case TIFFTAG_DATATYPE:
			switch (td->td_sampleformat) {
				case SAMPLEFORMAT_UINT:
					*va_arg(ap, uint16*) = DATATYPE_UINT;
					break;
				case SAMPLEFORMAT_INT:
					*va_arg(ap, uint16*) = DATATYPE_INT;
					break;
				case SAMPLEFORMAT_IEEEFP:
					*va_arg(ap, uint16*) = DATATYPE_IEEEFP;
					break;
				case SAMPLEFORMAT_VOID:
					*va_arg(ap, uint16*) = DATATYPE_VOID;
					break;
			}
			break;
		case TIFFTAG_SAMPLEFORMAT:
			*va_arg(ap, uint16*) = td->td_sampleformat;
			break;
		case TIFFTAG_IMAGEDEPTH:
			*va_arg(ap, uint32*) = td->td_imagedepth;
			break;
		case TIFFTAG_SUBIFD:
			*va_arg(ap, uint16*) = td->td_nsubifd;
			*va_arg(ap, uint64**) = td->td_subifd;
			break;
		case TIFFTAG_YCBCRPOSITIONING:
			*va_arg(ap, uint16*) = td->td_ycbcrpositioning;
			break;
		case TIFFTAG_YCBCRSUBSAMPLING:
			*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[0];
			*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[1];
			break;
		case TIFFTAG_TRANSFERFUNCTION:
			*va_arg(ap, uint16**) = td->td_transferfunction[0];
			if (td->td_samplesperpixel - td->td_extrasamples > 1) {
				*va_arg(ap, uint16**) = td->td_transferfunction[1];
				*va_arg(ap, uint16**) = td->td_transferfunction[2];
			} else {
				*va_arg(ap, uint16**) = NULL;
				*va_arg(ap, uint16**) = NULL;
			}
			break;
		case TIFFTAG_REFERENCEBLACKWHITE:
			*va_arg(ap, float**) = td->td_refblackwhite;
			break;
		case TIFFTAG_INKNAMES:
			*va_arg(ap, char**) = td->td_inknames;
			break;
		default:
			{
				int i;

				/*
				 * This can happen if multiple images are open
				 * with different codecs which have private
				 * tags.  The global tag information table may
				 * then have tags that are valid for one file
				 * but not the other. If the client tries to
				 * get a tag that is not valid for the image's
				 * codec then we'll arrive here.
				 */
				if( fip->field_bit != FIELD_CUSTOM )
				{
					TIFFErrorExt(tif->tif_clientdata, "_TIFFVGetField",
					    "%s: Invalid %stag \"%s\" "
					    "(not supported by codec)",
					    tif->tif_name,
					    isPseudoTag(tag) ? "pseudo-" : "",
					    fip->field_name);
					ret_val = 0;
					break;
				}

				/*
				 * Do we have a custom value?
				 */
				ret_val = 0;
				for (i = 0; i < td->td_customValueCount; i++) {
					TIFFTagValue *tv = td->td_customValues + i;

					if (tv->info->field_tag != tag)
						continue;

					if (fip->field_passcount) {
						if (fip->field_readcount == TIFF_VARIABLE2)
							*va_arg(ap, uint32*) = (uint32)tv->count;
						else  /* Assume TIFF_VARIABLE */
							*va_arg(ap, uint16*) = (uint16)tv->count;
						*va_arg(ap, void **) = tv->value;
						ret_val = 1;
					} else if (fip->field_tag == TIFFTAG_DOTRANGE
						   && strcmp(fip->field_name,"DotRange") == 0) {
						/* TODO: This is an evil exception and should not have been
						   handled this way ... likely best if we move it into
						   the directory structure with an explicit field in 
						   libtiff 4.1 and assign it a FIELD_ value */
						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[0];
						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[1];
						ret_val = 1;
					} else {
						if (fip->field_type == TIFF_ASCII
						    || fip->field_readcount == TIFF_VARIABLE
						    || fip->field_readcount == TIFF_VARIABLE2
						    || fip->field_readcount == TIFF_SPP
						    || tv->count > 1) {
							*va_arg(ap, void **) = tv->value;
							ret_val = 1;
						} else {
							char *val = (char *)tv->value;
							assert( tv->count == 1 );
							switch (fip->field_type) {
							case TIFF_BYTE:
							case TIFF_UNDEFINED:
								*va_arg(ap, uint8*) =
									*(uint8 *)val;
								ret_val = 1;
								break;
							case TIFF_SBYTE:
								*va_arg(ap, int8*) =
									*(int8 *)val;
								ret_val = 1;
								break;
							case TIFF_SHORT:
								*va_arg(ap, uint16*) =
									*(uint16 *)val;
								ret_val = 1;
								break;
							case TIFF_SSHORT:
								*va_arg(ap, int16*) =
									*(int16 *)val;
								ret_val = 1;
								break;
							case TIFF_LONG:
							case TIFF_IFD:
								*va_arg(ap, uint32*) =
									*(uint32 *)val;
								ret_val = 1;
								break;
							case TIFF_SLONG:
								*va_arg(ap, int32*) =
									*(int32 *)val;
								ret_val = 1;
								break;
							case TIFF_LONG8:
							case TIFF_IFD8:
								*va_arg(ap, uint64*) =
									*(uint64 *)val;
								ret_val = 1;
								break;
							case TIFF_SLONG8:
								*va_arg(ap, int64*) =
									*(int64 *)val;
								ret_val = 1;
								break;
							case TIFF_RATIONAL:
							case TIFF_SRATIONAL:
							case TIFF_FLOAT:
								*va_arg(ap, float*) =
									*(float *)val;
								ret_val = 1;
								break;
							case TIFF_DOUBLE:
								*va_arg(ap, double*) =
									*(double *)val;
								ret_val = 1;
								break;
							default:
								ret_val = 0;
								break;
							}
						}
					}
					break;
				}
			}
	}
	return(ret_val);
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
3,7
5,6
5,7
6,7
8,9
8,10
11,12
11,13
12,13
14,15
16,17
16,18
17,18
19,20
21,22
21,23
21,24
21,25
21,26
21,27
21,28
21,29
21,30
22,23
23,24
23,25
24,25
26,27
26,28
26,29
29,30
30,31
31,32
31,33
32,33
35,36
36,37
36,38
38,39
38,40
40,41
42,43
43,44
43,45
44,45
46,47
46,48
48,49
49,50
51,52
52,53
52,54
53,54
55,56
55,57
55,58
58,59
59,60
59,61
59,62
59,63
60,61
62,63
64,65
66,67
68,69
68,70
69,70
69,71
70,71
72,73
74,75
76,77
76,78
77,78
77,79
78,79
78,80
79,80
82,83
84,85
85,86
86,87
86,88
87,88
90,91
90,92
91,92
91,93
92,93
94,95
96,97
96,98
96,99
97,98
98,99
98,100
100,101
102,103
102,104
102,105
102,106
103,104
104,105
104,106
105,106
108,109
108,110
109,110
111,112
111,113
112,113
115,116
116,117
118,119
118,120
118,121
118,122
118,123
118,124
118,125
118,126
119,120
120,121
120,122
121,122
123,124
125,126
126,127
126,128
127,128
129,130
129,131
129,132
132,133
133,134
133,135
134,135
134,136
135,136
138,139
140,141
140,142
141,142
141,143
142,143
142,144
143,144
143,145
144,145
148,149
151,152
151,153
152,153
152,154
153,154
153,155
154,155
157,158
159,160
161,162
162,163
162,164
163,164
165,166
166,167
166,168
167,168
167,169
168,169
170,171
172,173
172,174
173,174
176,177
176,178
177,178
177,179
178,179
180,181
180,182
181,182
184,185
184,186
185,186
186,187
186,188
186,189
186,190
186,191
186,192
187,188
189,190
189,191
190,191
195,196
197,198
197,199
198,199
201,202
202,203
202,204
203,204
205,206
205,207
206,207
209,210
210,211
212,213
214,215
214,216
215,216
217,218
217,219
217,220
217,221
217,222
217,223
217,224
217,225
217,226
217,227
217,228
217,229
217,230
217,231
217,232
217,233
217,234
217,235
217,236
217,237
217,238
217,239
217,240
217,241
217,242
217,243
217,244
217,245
217,246
217,247
217,248
217,249
217,250
217,251
217,252
217,253
217,254
217,255
217,256
217,257
217,258
217,259
217,260
217,261
217,262
217,263
217,264
217,265
217,266
217,267
217,268
217,269
217,270
217,271
217,272
217,273
217,274
217,275
217,276
217,277
217,278
217,279
217,280
217,281
217,282
217,283
217,284
217,285
217,286
217,287
217,288
217,289
217,290
217,291
217,292
217,293
217,294
217,295
217,296
217,297
217,298
217,299
217,300
217,301
217,302
217,303
217,304
217,305
217,306
217,307
217,308
217,309
217,310
217,311
217,312
217,313
217,314
217,315
217,316
217,317
217,318
217,319
217,320
217,321
217,322
217,323
217,324
217,325
217,326
217,327
217,328
217,329
217,330
217,331
217,332
217,333
217,334
217,335
217,336
217,337
217,338
217,339
217,340
217,341
217,342
217,343
217,344
217,345
217,346
217,347
217,348
217,349
217,350
217,351
217,352
217,353
218,219
219,220
221,222
223,224
224,225
226,227
228,229
229,230
231,232
233,234
234,235
236,237
238,239
239,240
241,242
243,244
244,245
246,247
248,249
249,250
251,252
253,254
254,255
256,257
258,259
259,260
261,262
263,264
264,265
266,267
268,269
269,270
271,272
273,274
274,275
276,277
278,279
279,280
281,282
283,284
284,285
286,287
287,288
289,290
290,291
292,293
293,294
295,296
296,297
298,299
300,301
301,302
303,304
305,306
306,307
308,309
310,311
311,312
313,314
315,316
316,317
318,319
320,321
321,322
323,324
325,326
326,327
328,329
329,330
331,332
332,333
334,335
335,336
337,338
338,339
340,341
341,342
342,343
344,345
345,346
347,348
348,349
350,351
351,352
351,353
352,353
354,355
356,357
358,359
359,360
361,362
362,363
364,365
365,366
365,367
366,367
368,369
370,371
372,373
373,374
375,376
377,378
378,379
380,381
381,382
383,384
384,385
386,387
388,389
389,390
391,392
393,394
394,395
396,397
398,399
399,400
401,402
401,403
402,403
402,404
403,404
406,407
406,408
406,409
406,410
406,411
406,412
406,413
406,414
406,415
406,416
406,417
406,418
407,408
408,409
410,411
412,413
413,414
415,416
417,418
418,419
420,421
422,423
423,424
425,426
428,429
429,430
431,432
433,434
434,435
436,437
438,439
439,440
441,442
442,443
444,445
445,446
447,448
449,450
450,451
452,453
453,454
455,456
456,457
458,459
459,460
459,461
459,462
460,461
460,462
461,462
461,463
462,463
462,464
463,464
466,467
466,468
467,468
471,472
471,473
472,473
473,474
474,475
474,476
475,476
476,477
478,479
479,480
481,482
483,484
484,485
486,487
489,490
489,491
489,492
489,493
490,491
491,492
491,493
493,494
495,496
495,497
496,497
496,498
497,498
497,499
498,499
501,502
503,504
503,505
503,506
504,505
505,506
505,507
505,508
505,509
505,510
505,511
505,512
506,507
508,509
508,510
509,510
514,515
514,516
515,516
518,519
518,520
518,521
519,520
519,521
520,521
522,523
526,527
526,528
527,528
530,531
531,532
531,533
532,533
536,537
537,538
537,539
538,539
541,542
541,543
541,544
541,545
542,543
543,544
543,545
544,545
547,548
547,549
548,549
550,551
550,552
551,552
554,555
555,556
557,558
557,559
557,560
557,561
558,559
559,560
559,561
560,561
562,563
562,564
562,565
565,566
566,567
566,568
567,568
567,569
568,569
571,572
573,574
573,575
574,575
574,576
575,576
575,577
576,577
576,578
577,578
581,582
584,585
584,586
584,587
585,586
585,587
586,587
589,590
589,591
589,592
589,593
590,591
591,592
592,593
593,594
594,595
594,596
595,596
598,599
598,600
598,601
599,600
599,601
600,601
600,602
601,602
601,603
602,603
605,606
607,608
607,609
608,609
608,610
608,611
609,610
611,612
611,613
612,613
617,618
617,619
617,620
618,619
619,620
620,621
621,622
621,623
622,623
625,626
626,627
626,628
626,629
627,628
627,629
628,629
628,630
629,630
629,631
630,631
630,632
631,632
631,633
632,633
632,634
633,634
636,637
638,639
638,640
639,640
639,641
640,641
643,644
645,646
645,647
646,647
646,648
647,648
650,651
652,653
652,654
653,654
653,655
654,655
657,658
659,660
659,661
660,661
660,662
661,662
665,666
665,667
666,667
667,668
668,669
668,670
669,670
672,673
672,674
672,675
673,674
674,675
674,676
676,677
676,678
676,679
679,680
680,681
680,682
681,682
681,683
683,684
685,686
685,687
686,687
689,690
690,691
690,692
691,692
693,694
693,695
694,695
694,696
695,696
699,700
699,701
700,701
700,702
701,702
704,705
704,706
704,707
704,708
704,709
704,710
704,711
704,712
704,713
704,714
704,715
704,716
704,717
704,718
704,719
704,720
704,721
704,722
704,723
704,724
704,725
704,726
704,727
704,728
704,729
704,730
704,731
704,732
704,733
704,734
704,735
704,736
704,737
704,738
704,739
704,740
704,741
704,742
704,743
704,744
704,745
704,746
704,747
704,748
704,749
704,750
704,751
704,752
705,706
706,707
708,709
709,710
711,712
712,713
713,714
713,715
714,715
718,719
719,720
721,722
722,723
723,724
723,725
724,725
728,729
729,730
731,732
732,733
733,734
733,735
734,735
738,739
739,740
741,742
742,743
743,744
743,745
744,745
748,749
749,750
751,752
752,753
754,755
755,756
756,757
756,758
757,758
761,762
762,763
764,765
765,766
766,767
766,768
767,768
771,772
772,773
774,775
775,776
777,778
778,779
779,780
779,781
780,781
784,785
785,786
787,788
788,789
789,790
789,791
790,791
794,795
795,796
797,798
798,799
800,801
801,802
803,804
804,805
805,806
805,807
806,807
810,811
811,812
813,814
814,815
815,816
815,817
816,817
821,822
822,823
822,824
823,824
828,829
829,830
830,831
-----nextToken-----
2,4,7,9,10,13,15,18,20,25,27,28,33,34,37,39,41,45,47,50,54,56,57,61,63,65,67,71,73,75,80,81,83,88,89,93,95,99,101,106,107,110,113,114,117,122,124,128,130,131,136,137,139,145,146,147,149,150,155,156,158,160,164,169,171,174,175,179,182,183,188,191,192,193,194,196,199,200,204,207,208,211,213,216,220,222,225,227,230,232,235,237,240,242,245,247,250,252,255,257,260,262,265,267,270,272,275,277,280,282,285,288,291,294,297,299,302,304,307,309,312,314,317,319,322,324,327,330,333,336,339,343,346,349,353,355,357,360,363,367,369,371,374,376,379,382,385,387,390,392,395,397,400,404,405,409,411,414,416,419,421,424,426,427,430,432,435,437,440,443,446,448,451,454,457,464,465,468,469,470,477,480,482,485,487,488,492,494,499,500,502,507,510,511,512,513,516,517,521,523,524,525,528,529,533,534,535,539,540,545,546,549,552,553,556,561,563,564,569,570,572,578,579,580,582,583,587,588,596,597,603,604,606,610,613,614,615,616,623,624,634,635,637,641,642,644,648,649,651,655,656,658,662,663,664,670,671,675,677,678,682,684,687,688,692,696,697,698,702,703,707,710,715,716,717,720,725,726,727,730,735,736,737,740,745,746,747,750,753,758,759,760,763,768,769,770,773,776,781,782,783,786,791,792,793,796,799,802,807,808,809,812,817,818,819,820,824,825,826,827,831
-----computeFrom-----
69,70
69,71
77,78
77,79
86,87
86,88
91,92
91,93
104,105
104,106
108,109
108,110
133,134
133,135
141,142
141,143
152,153
152,154
162,163
162,164
177,178
177,179
202,203
202,204
460,461
460,462
461,462
461,463
496,497
496,498
531,532
531,533
537,538
537,539
543,544
543,545
547,548
547,549
566,567
566,568
574,575
574,576
594,595
594,596
599,600
599,601
600,601
600,602
607,608
607,609
621,622
621,623
627,628
627,629
628,629
628,630
629,630
629,631
630,631
630,632
631,632
631,633
638,639
638,640
645,646
645,647
652,653
652,654
659,660
659,661
668,669
668,670
693,694
693,695
713,714
713,715
723,724
723,725
733,734
733,735
743,744
743,745
756,757
756,758
766,767
766,768
779,780
779,781
789,790
789,791
805,806
805,807
815,816
815,817
822,823
822,824
-----guardedBy-----
93,149
179,204
182,207
183,208
499,528
-----guardedByNegation-----
613,702
662,696
663,697
655,702
635,703
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;UnaryExpression;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;LiteralExpression;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ContinueStatement;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ReturnStatement;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;Pointer;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ProblemStatement;ReturnStatement;LiteralExpression;ReturnStatement;LiteralExpression;SwitchStatement;IdExpression;Name;CompoundStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;ProblemStatement;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;SwitchStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;IfStatement;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ProblemStatement;ProblemStatement;CompoundStatement;ProblemStatement;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;BreakStatement;DefaultStatement;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;ConditionalExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BreakStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ContinueStatement;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ProblemStatement;ProblemStatement;ProblemStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;CompoundStatement;ProblemStatement;ProblemStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ProblemStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;SwitchStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;ProblemStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;ProblemStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;ProblemStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;ProblemStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;ProblemStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BreakStatement;DefaultStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BreakStatement;BreakStatement;ReturnStatement;UnaryExpression;IdExpression;Name;
-----ast_node-----
static int_TIFFVGetField(TIFF* tif, uint32 tag, va_list ap){	TIFFDirectory* td = &tif->tif_dir;	int ret_val = 1;	uint32 standard_tag = tag;	const TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);	if( fip == NULL ) /* cannot happen since TIFFGetField() already checks it */	    return 0;	/*	 * We want to force the custom code to be used for custom	 * fields even if the tag happens to match a well known 	 * one - important for reinterpreted handling of standard	 * tag values in custom directories (i.e. EXIF) 	 */	if (fip->field_bit == FIELD_CUSTOM) {		standard_tag = 0;	}	        if( standard_tag == TIFFTAG_NUMBEROFINKS )        {            int i;            for (i = 0; i < td->td_customValueCount; i++) {                uint16 val;                TIFFTagValue *tv = td->td_customValues + i;                if (tv->info->field_tag != standard_tag)                    continue;                if( tv->value == NULL )                    return 0;                val = *(uint16 *)tv->value;                /* Truncate to SamplesPerPixel, since the */                /* setting code for INKNAMES assume that there are SamplesPerPixel */                /* inknames. */                /* Fixes http://bugzilla.maptools.org/show_bug.cgi?id=2599 */                if( val > td->td_samplesperpixel )                {                    TIFFWarningExt(tif->tif_clientdata,"_TIFFVGetField",                                   "Truncating NumberOfInks from %u to %u",                                   val, td->td_samplesperpixel);                    val = td->td_samplesperpixel;                }                *va_arg(ap, uint16*) = val;                return 1;            }            return 0;        }	switch (standard_tag) {		case TIFFTAG_SUBFILETYPE:			*va_arg(ap, uint32*) = td->td_subfiletype;			break;		case TIFFTAG_IMAGEWIDTH:			*va_arg(ap, uint32*) = td->td_imagewidth;			break;		case TIFFTAG_IMAGELENGTH:			*va_arg(ap, uint32*) = td->td_imagelength;			break;		case TIFFTAG_BITSPERSAMPLE:			*va_arg(ap, uint16*) = td->td_bitspersample;			break;		case TIFFTAG_COMPRESSION:			*va_arg(ap, uint16*) = td->td_compression;			break;		case TIFFTAG_PHOTOMETRIC:			*va_arg(ap, uint16*) = td->td_photometric;			break;		case TIFFTAG_THRESHHOLDING:			*va_arg(ap, uint16*) = td->td_threshholding;			break;		case TIFFTAG_FILLORDER:			*va_arg(ap, uint16*) = td->td_fillorder;			break;		case TIFFTAG_ORIENTATION:			*va_arg(ap, uint16*) = td->td_orientation;			break;		case TIFFTAG_SAMPLESPERPIXEL:			*va_arg(ap, uint16*) = td->td_samplesperpixel;			break;		case TIFFTAG_ROWSPERSTRIP:			*va_arg(ap, uint32*) = td->td_rowsperstrip;			break;		case TIFFTAG_MINSAMPLEVALUE:			*va_arg(ap, uint16*) = td->td_minsamplevalue;			break;		case TIFFTAG_MAXSAMPLEVALUE:			*va_arg(ap, uint16*) = td->td_maxsamplevalue;			break;		case TIFFTAG_SMINSAMPLEVALUE:			if (tif->tif_flags & TIFF_PERSAMPLE)				*va_arg(ap, double**) = td->td_sminsamplevalue;			else			{				/* libtiff historically treats this as a single value. */				uint16 i;				double v = td->td_sminsamplevalue[0];				for (i=1; i < td->td_samplesperpixel; ++i)					if( td->td_sminsamplevalue[i] < v )						v = td->td_sminsamplevalue[i];				*va_arg(ap, double*) = v;			}			break;		case TIFFTAG_SMAXSAMPLEVALUE:			if (tif->tif_flags & TIFF_PERSAMPLE)				*va_arg(ap, double**) = td->td_smaxsamplevalue;			else			{				/* libtiff historically treats this as a single value. */				uint16 i;				double v = td->td_smaxsamplevalue[0];				for (i=1; i < td->td_samplesperpixel; ++i)					if( td->td_smaxsamplevalue[i] > v )						v = td->td_smaxsamplevalue[i];				*va_arg(ap, double*) = v;			}			break;		case TIFFTAG_XRESOLUTION:			*va_arg(ap, float*) = td->td_xresolution;			break;		case TIFFTAG_YRESOLUTION:			*va_arg(ap, float*) = td->td_yresolution;			break;		case TIFFTAG_PLANARCONFIG:			*va_arg(ap, uint16*) = td->td_planarconfig;			break;		case TIFFTAG_XPOSITION:			*va_arg(ap, float*) = td->td_xposition;			break;		case TIFFTAG_YPOSITION:			*va_arg(ap, float*) = td->td_yposition;			break;		case TIFFTAG_RESOLUTIONUNIT:			*va_arg(ap, uint16*) = td->td_resolutionunit;			break;		case TIFFTAG_PAGENUMBER:			*va_arg(ap, uint16*) = td->td_pagenumber[0];			*va_arg(ap, uint16*) = td->td_pagenumber[1];			break;		case TIFFTAG_HALFTONEHINTS:			*va_arg(ap, uint16*) = td->td_halftonehints[0];			*va_arg(ap, uint16*) = td->td_halftonehints[1];			break;		case TIFFTAG_COLORMAP:			*va_arg(ap, uint16**) = td->td_colormap[0];			*va_arg(ap, uint16**) = td->td_colormap[1];			*va_arg(ap, uint16**) = td->td_colormap[2];			break;		case TIFFTAG_STRIPOFFSETS:		case TIFFTAG_TILEOFFSETS:			_TIFFFillStriles( tif );			*va_arg(ap, uint64**) = td->td_stripoffset;			break;		case TIFFTAG_STRIPBYTECOUNTS:		case TIFFTAG_TILEBYTECOUNTS:			_TIFFFillStriles( tif );			*va_arg(ap, uint64**) = td->td_stripbytecount;			break;		case TIFFTAG_MATTEING:			*va_arg(ap, uint16*) =			    (td->td_extrasamples == 1 &&			    td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA);			break;		case TIFFTAG_EXTRASAMPLES:			*va_arg(ap, uint16*) = td->td_extrasamples;			*va_arg(ap, uint16**) = td->td_sampleinfo;			break;		case TIFFTAG_TILEWIDTH:			*va_arg(ap, uint32*) = td->td_tilewidth;			break;		case TIFFTAG_TILELENGTH:			*va_arg(ap, uint32*) = td->td_tilelength;			break;		case TIFFTAG_TILEDEPTH:			*va_arg(ap, uint32*) = td->td_tiledepth;			break;		case TIFFTAG_DATATYPE:			switch (td->td_sampleformat) {				case SAMPLEFORMAT_UINT:					*va_arg(ap, uint16*) = DATATYPE_UINT;					break;				case SAMPLEFORMAT_INT:					*va_arg(ap, uint16*) = DATATYPE_INT;					break;				case SAMPLEFORMAT_IEEEFP:					*va_arg(ap, uint16*) = DATATYPE_IEEEFP;					break;				case SAMPLEFORMAT_VOID:					*va_arg(ap, uint16*) = DATATYPE_VOID;					break;			}			break;		case TIFFTAG_SAMPLEFORMAT:			*va_arg(ap, uint16*) = td->td_sampleformat;			break;		case TIFFTAG_IMAGEDEPTH:			*va_arg(ap, uint32*) = td->td_imagedepth;			break;		case TIFFTAG_SUBIFD:			*va_arg(ap, uint16*) = td->td_nsubifd;			*va_arg(ap, uint64**) = td->td_subifd;			break;		case TIFFTAG_YCBCRPOSITIONING:			*va_arg(ap, uint16*) = td->td_ycbcrpositioning;			break;		case TIFFTAG_YCBCRSUBSAMPLING:			*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[0];			*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[1];			break;		case TIFFTAG_TRANSFERFUNCTION:			*va_arg(ap, uint16**) = td->td_transferfunction[0];			if (td->td_samplesperpixel - td->td_extrasamples > 1) {				*va_arg(ap, uint16**) = td->td_transferfunction[1];				*va_arg(ap, uint16**) = td->td_transferfunction[2];			} else {				*va_arg(ap, uint16**) = NULL;				*va_arg(ap, uint16**) = NULL;			}			break;		case TIFFTAG_REFERENCEBLACKWHITE:			*va_arg(ap, float**) = td->td_refblackwhite;			break;		case TIFFTAG_INKNAMES:			*va_arg(ap, char**) = td->td_inknames;			break;		default:			{				int i;				/*				 * This can happen if multiple images are open				 * with different codecs which have private				 * tags.  The global tag information table may				 * then have tags that are valid for one file				 * but not the other. If the client tries to				 * get a tag that is not valid for the image's				 * codec then we'll arrive here.				 */				if( fip->field_bit != FIELD_CUSTOM )				{					TIFFErrorExt(tif->tif_clientdata, "_TIFFVGetField",					    "%s: Invalid %stag \"%s\" "					    "(not supported by codec)",					    tif->tif_name,					    isPseudoTag(tag) ? "pseudo-" : "",					    fip->field_name);					ret_val = 0;					break;				}				/*				 * Do we have a custom value?				 */				ret_val = 0;				for (i = 0; i < td->td_customValueCount; i++) {					TIFFTagValue *tv = td->td_customValues + i;					if (tv->info->field_tag != tag)						continue;					if (fip->field_passcount) {						if (fip->field_readcount == TIFF_VARIABLE2)							*va_arg(ap, uint32*) = (uint32)tv->count;						else  /* Assume TIFF_VARIABLE */							*va_arg(ap, uint16*) = (uint16)tv->count;						*va_arg(ap, void **) = tv->value;						ret_val = 1;					} else if (fip->field_tag == TIFFTAG_DOTRANGE						   && strcmp(fip->field_name,"DotRange") == 0) {						/* TODO: This is an evil exception and should not have been						   handled this way ... likely best if we move it into						   the directory structure with an explicit field in 						   libtiff 4.1 and assign it a FIELD_ value */						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[0];						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[1];						ret_val = 1;					} else {						if (fip->field_type == TIFF_ASCII						    || fip->field_readcount == TIFF_VARIABLE						    || fip->field_readcount == TIFF_VARIABLE2						    || fip->field_readcount == TIFF_SPP						    || tv->count > 1) {							*va_arg(ap, void **) = tv->value;							ret_val = 1;						} else {							char *val = (char *)tv->value;							assert( tv->count == 1 );							switch (fip->field_type) {							case TIFF_BYTE:							case TIFF_UNDEFINED:								*va_arg(ap, uint8*) =									*(uint8 *)val;								ret_val = 1;								break;							case TIFF_SBYTE:								*va_arg(ap, int8*) =									*(int8 *)val;								ret_val = 1;								break;							case TIFF_SHORT:								*va_arg(ap, uint16*) =									*(uint16 *)val;								ret_val = 1;								break;							case TIFF_SSHORT:								*va_arg(ap, int16*) =									*(int16 *)val;								ret_val = 1;								break;							case TIFF_LONG:							case TIFF_IFD:								*va_arg(ap, uint32*) =									*(uint32 *)val;								ret_val = 1;								break;							case TIFF_SLONG:								*va_arg(ap, int32*) =									*(int32 *)val;								ret_val = 1;								break;							case TIFF_LONG8:							case TIFF_IFD8:								*va_arg(ap, uint64*) =									*(uint64 *)val;								ret_val = 1;								break;							case TIFF_SLONG8:								*va_arg(ap, int64*) =									*(int64 *)val;								ret_val = 1;								break;							case TIFF_RATIONAL:							case TIFF_SRATIONAL:							case TIFF_FLOAT:								*va_arg(ap, float*) =									*(float *)val;								ret_val = 1;								break;							case TIFF_DOUBLE:								*va_arg(ap, double*) =									*(double *)val;								ret_val = 1;								break;							default:								ret_val = 0;								break;							}						}					}					break;				}			}	}	return(ret_val);}
static int
_TIFFVGetField(TIFF* tif, uint32 tag, va_list ap)
_TIFFVGetField
TIFF* tif
TIFF
TIFF
* tif
*
tif
uint32 tag
uint32
uint32
tag
tag
va_list ap
va_list
va_list
ap
ap
{	TIFFDirectory* td = &tif->tif_dir;	int ret_val = 1;	uint32 standard_tag = tag;	const TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);	if( fip == NULL ) /* cannot happen since TIFFGetField() already checks it */	    return 0;	/*	 * We want to force the custom code to be used for custom	 * fields even if the tag happens to match a well known 	 * one - important for reinterpreted handling of standard	 * tag values in custom directories (i.e. EXIF) 	 */	if (fip->field_bit == FIELD_CUSTOM) {		standard_tag = 0;	}	        if( standard_tag == TIFFTAG_NUMBEROFINKS )        {            int i;            for (i = 0; i < td->td_customValueCount; i++) {                uint16 val;                TIFFTagValue *tv = td->td_customValues + i;                if (tv->info->field_tag != standard_tag)                    continue;                if( tv->value == NULL )                    return 0;                val = *(uint16 *)tv->value;                /* Truncate to SamplesPerPixel, since the */                /* setting code for INKNAMES assume that there are SamplesPerPixel */                /* inknames. */                /* Fixes http://bugzilla.maptools.org/show_bug.cgi?id=2599 */                if( val > td->td_samplesperpixel )                {                    TIFFWarningExt(tif->tif_clientdata,"_TIFFVGetField",                                   "Truncating NumberOfInks from %u to %u",                                   val, td->td_samplesperpixel);                    val = td->td_samplesperpixel;                }                *va_arg(ap, uint16*) = val;                return 1;            }            return 0;        }	switch (standard_tag) {		case TIFFTAG_SUBFILETYPE:			*va_arg(ap, uint32*) = td->td_subfiletype;			break;		case TIFFTAG_IMAGEWIDTH:			*va_arg(ap, uint32*) = td->td_imagewidth;			break;		case TIFFTAG_IMAGELENGTH:			*va_arg(ap, uint32*) = td->td_imagelength;			break;		case TIFFTAG_BITSPERSAMPLE:			*va_arg(ap, uint16*) = td->td_bitspersample;			break;		case TIFFTAG_COMPRESSION:			*va_arg(ap, uint16*) = td->td_compression;			break;		case TIFFTAG_PHOTOMETRIC:			*va_arg(ap, uint16*) = td->td_photometric;			break;		case TIFFTAG_THRESHHOLDING:			*va_arg(ap, uint16*) = td->td_threshholding;			break;		case TIFFTAG_FILLORDER:			*va_arg(ap, uint16*) = td->td_fillorder;			break;		case TIFFTAG_ORIENTATION:			*va_arg(ap, uint16*) = td->td_orientation;			break;		case TIFFTAG_SAMPLESPERPIXEL:			*va_arg(ap, uint16*) = td->td_samplesperpixel;			break;		case TIFFTAG_ROWSPERSTRIP:			*va_arg(ap, uint32*) = td->td_rowsperstrip;			break;		case TIFFTAG_MINSAMPLEVALUE:			*va_arg(ap, uint16*) = td->td_minsamplevalue;			break;		case TIFFTAG_MAXSAMPLEVALUE:			*va_arg(ap, uint16*) = td->td_maxsamplevalue;			break;		case TIFFTAG_SMINSAMPLEVALUE:			if (tif->tif_flags & TIFF_PERSAMPLE)				*va_arg(ap, double**) = td->td_sminsamplevalue;			else			{				/* libtiff historically treats this as a single value. */				uint16 i;				double v = td->td_sminsamplevalue[0];				for (i=1; i < td->td_samplesperpixel; ++i)					if( td->td_sminsamplevalue[i] < v )						v = td->td_sminsamplevalue[i];				*va_arg(ap, double*) = v;			}			break;		case TIFFTAG_SMAXSAMPLEVALUE:			if (tif->tif_flags & TIFF_PERSAMPLE)				*va_arg(ap, double**) = td->td_smaxsamplevalue;			else			{				/* libtiff historically treats this as a single value. */				uint16 i;				double v = td->td_smaxsamplevalue[0];				for (i=1; i < td->td_samplesperpixel; ++i)					if( td->td_smaxsamplevalue[i] > v )						v = td->td_smaxsamplevalue[i];				*va_arg(ap, double*) = v;			}			break;		case TIFFTAG_XRESOLUTION:			*va_arg(ap, float*) = td->td_xresolution;			break;		case TIFFTAG_YRESOLUTION:			*va_arg(ap, float*) = td->td_yresolution;			break;		case TIFFTAG_PLANARCONFIG:			*va_arg(ap, uint16*) = td->td_planarconfig;			break;		case TIFFTAG_XPOSITION:			*va_arg(ap, float*) = td->td_xposition;			break;		case TIFFTAG_YPOSITION:			*va_arg(ap, float*) = td->td_yposition;			break;		case TIFFTAG_RESOLUTIONUNIT:			*va_arg(ap, uint16*) = td->td_resolutionunit;			break;		case TIFFTAG_PAGENUMBER:			*va_arg(ap, uint16*) = td->td_pagenumber[0];			*va_arg(ap, uint16*) = td->td_pagenumber[1];			break;		case TIFFTAG_HALFTONEHINTS:			*va_arg(ap, uint16*) = td->td_halftonehints[0];			*va_arg(ap, uint16*) = td->td_halftonehints[1];			break;		case TIFFTAG_COLORMAP:			*va_arg(ap, uint16**) = td->td_colormap[0];			*va_arg(ap, uint16**) = td->td_colormap[1];			*va_arg(ap, uint16**) = td->td_colormap[2];			break;		case TIFFTAG_STRIPOFFSETS:		case TIFFTAG_TILEOFFSETS:			_TIFFFillStriles( tif );			*va_arg(ap, uint64**) = td->td_stripoffset;			break;		case TIFFTAG_STRIPBYTECOUNTS:		case TIFFTAG_TILEBYTECOUNTS:			_TIFFFillStriles( tif );			*va_arg(ap, uint64**) = td->td_stripbytecount;			break;		case TIFFTAG_MATTEING:			*va_arg(ap, uint16*) =			    (td->td_extrasamples == 1 &&			    td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA);			break;		case TIFFTAG_EXTRASAMPLES:			*va_arg(ap, uint16*) = td->td_extrasamples;			*va_arg(ap, uint16**) = td->td_sampleinfo;			break;		case TIFFTAG_TILEWIDTH:			*va_arg(ap, uint32*) = td->td_tilewidth;			break;		case TIFFTAG_TILELENGTH:			*va_arg(ap, uint32*) = td->td_tilelength;			break;		case TIFFTAG_TILEDEPTH:			*va_arg(ap, uint32*) = td->td_tiledepth;			break;		case TIFFTAG_DATATYPE:			switch (td->td_sampleformat) {				case SAMPLEFORMAT_UINT:					*va_arg(ap, uint16*) = DATATYPE_UINT;					break;				case SAMPLEFORMAT_INT:					*va_arg(ap, uint16*) = DATATYPE_INT;					break;				case SAMPLEFORMAT_IEEEFP:					*va_arg(ap, uint16*) = DATATYPE_IEEEFP;					break;				case SAMPLEFORMAT_VOID:					*va_arg(ap, uint16*) = DATATYPE_VOID;					break;			}			break;		case TIFFTAG_SAMPLEFORMAT:			*va_arg(ap, uint16*) = td->td_sampleformat;			break;		case TIFFTAG_IMAGEDEPTH:			*va_arg(ap, uint32*) = td->td_imagedepth;			break;		case TIFFTAG_SUBIFD:			*va_arg(ap, uint16*) = td->td_nsubifd;			*va_arg(ap, uint64**) = td->td_subifd;			break;		case TIFFTAG_YCBCRPOSITIONING:			*va_arg(ap, uint16*) = td->td_ycbcrpositioning;			break;		case TIFFTAG_YCBCRSUBSAMPLING:			*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[0];			*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[1];			break;		case TIFFTAG_TRANSFERFUNCTION:			*va_arg(ap, uint16**) = td->td_transferfunction[0];			if (td->td_samplesperpixel - td->td_extrasamples > 1) {				*va_arg(ap, uint16**) = td->td_transferfunction[1];				*va_arg(ap, uint16**) = td->td_transferfunction[2];			} else {				*va_arg(ap, uint16**) = NULL;				*va_arg(ap, uint16**) = NULL;			}			break;		case TIFFTAG_REFERENCEBLACKWHITE:			*va_arg(ap, float**) = td->td_refblackwhite;			break;		case TIFFTAG_INKNAMES:			*va_arg(ap, char**) = td->td_inknames;			break;		default:			{				int i;				/*				 * This can happen if multiple images are open				 * with different codecs which have private				 * tags.  The global tag information table may				 * then have tags that are valid for one file				 * but not the other. If the client tries to				 * get a tag that is not valid for the image's				 * codec then we'll arrive here.				 */				if( fip->field_bit != FIELD_CUSTOM )				{					TIFFErrorExt(tif->tif_clientdata, "_TIFFVGetField",					    "%s: Invalid %stag \"%s\" "					    "(not supported by codec)",					    tif->tif_name,					    isPseudoTag(tag) ? "pseudo-" : "",					    fip->field_name);					ret_val = 0;					break;				}				/*				 * Do we have a custom value?				 */				ret_val = 0;				for (i = 0; i < td->td_customValueCount; i++) {					TIFFTagValue *tv = td->td_customValues + i;					if (tv->info->field_tag != tag)						continue;					if (fip->field_passcount) {						if (fip->field_readcount == TIFF_VARIABLE2)							*va_arg(ap, uint32*) = (uint32)tv->count;						else  /* Assume TIFF_VARIABLE */							*va_arg(ap, uint16*) = (uint16)tv->count;						*va_arg(ap, void **) = tv->value;						ret_val = 1;					} else if (fip->field_tag == TIFFTAG_DOTRANGE						   && strcmp(fip->field_name,"DotRange") == 0) {						/* TODO: This is an evil exception and should not have been						   handled this way ... likely best if we move it into						   the directory structure with an explicit field in 						   libtiff 4.1 and assign it a FIELD_ value */						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[0];						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[1];						ret_val = 1;					} else {						if (fip->field_type == TIFF_ASCII						    || fip->field_readcount == TIFF_VARIABLE						    || fip->field_readcount == TIFF_VARIABLE2						    || fip->field_readcount == TIFF_SPP						    || tv->count > 1) {							*va_arg(ap, void **) = tv->value;							ret_val = 1;						} else {							char *val = (char *)tv->value;							assert( tv->count == 1 );							switch (fip->field_type) {							case TIFF_BYTE:							case TIFF_UNDEFINED:								*va_arg(ap, uint8*) =									*(uint8 *)val;								ret_val = 1;								break;							case TIFF_SBYTE:								*va_arg(ap, int8*) =									*(int8 *)val;								ret_val = 1;								break;							case TIFF_SHORT:								*va_arg(ap, uint16*) =									*(uint16 *)val;								ret_val = 1;								break;							case TIFF_SSHORT:								*va_arg(ap, int16*) =									*(int16 *)val;								ret_val = 1;								break;							case TIFF_LONG:							case TIFF_IFD:								*va_arg(ap, uint32*) =									*(uint32 *)val;								ret_val = 1;								break;							case TIFF_SLONG:								*va_arg(ap, int32*) =									*(int32 *)val;								ret_val = 1;								break;							case TIFF_LONG8:							case TIFF_IFD8:								*va_arg(ap, uint64*) =									*(uint64 *)val;								ret_val = 1;								break;							case TIFF_SLONG8:								*va_arg(ap, int64*) =									*(int64 *)val;								ret_val = 1;								break;							case TIFF_RATIONAL:							case TIFF_SRATIONAL:							case TIFF_FLOAT:								*va_arg(ap, float*) =									*(float *)val;								ret_val = 1;								break;							case TIFF_DOUBLE:								*va_arg(ap, double*) =									*(double *)val;								ret_val = 1;								break;							default:								ret_val = 0;								break;							}						}					}					break;				}			}	}	return(ret_val);}
TIFFDirectory* td = &tif->tif_dir;
TIFFDirectory* td = &tif->tif_dir;
TIFFDirectory
TIFFDirectory
* td = &tif->tif_dir
*
td
= &tif->tif_dir
&tif->tif_dir
tif->tif_dir
tif
tif
tif_dir
int ret_val = 1;
int ret_val = 1;
int
ret_val = 1
ret_val
= 1
1
uint32 standard_tag = tag;
uint32 standard_tag = tag;
uint32
uint32
standard_tag = tag
standard_tag
= tag
tag
tag
const TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);
const TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);
const TIFFField
TIFFField
* fip = TIFFFindField(tif, tag, TIFF_ANY)
*
fip
= TIFFFindField(tif, tag, TIFF_ANY)
TIFFFindField(tif, tag, TIFF_ANY)
TIFFFindField
TIFFFindField
tif
tif
tag
tag
TIFF_ANY
TIFF_ANY
if( fip == NULL ) /* cannot happen since TIFFGetField() already checks it */	    return 0;
fip == NULL
fip
fip
NULL
NULL
return 0;
0
if (fip->field_bit == FIELD_CUSTOM) {		standard_tag = 0;	}
fip->field_bit == FIELD_CUSTOM
fip->field_bit
fip
fip
field_bit
FIELD_CUSTOM
FIELD_CUSTOM
{		standard_tag = 0;	}
standard_tag = 0;
standard_tag = 0
standard_tag
standard_tag
0
if( standard_tag == TIFFTAG_NUMBEROFINKS )        {            int i;            for (i = 0; i < td->td_customValueCount; i++) {                uint16 val;                TIFFTagValue *tv = td->td_customValues + i;                if (tv->info->field_tag != standard_tag)                    continue;                if( tv->value == NULL )                    return 0;                val = *(uint16 *)tv->value;                /* Truncate to SamplesPerPixel, since the */                /* setting code for INKNAMES assume that there are SamplesPerPixel */                /* inknames. */                /* Fixes http://bugzilla.maptools.org/show_bug.cgi?id=2599 */                if( val > td->td_samplesperpixel )                {                    TIFFWarningExt(tif->tif_clientdata,"_TIFFVGetField",                                   "Truncating NumberOfInks from %u to %u",                                   val, td->td_samplesperpixel);                    val = td->td_samplesperpixel;                }                *va_arg(ap, uint16*) = val;                return 1;            }            return 0;        }
standard_tag == TIFFTAG_NUMBEROFINKS
standard_tag
standard_tag
TIFFTAG_NUMBEROFINKS
TIFFTAG_NUMBEROFINKS
{            int i;            for (i = 0; i < td->td_customValueCount; i++) {                uint16 val;                TIFFTagValue *tv = td->td_customValues + i;                if (tv->info->field_tag != standard_tag)                    continue;                if( tv->value == NULL )                    return 0;                val = *(uint16 *)tv->value;                /* Truncate to SamplesPerPixel, since the */                /* setting code for INKNAMES assume that there are SamplesPerPixel */                /* inknames. */                /* Fixes http://bugzilla.maptools.org/show_bug.cgi?id=2599 */                if( val > td->td_samplesperpixel )                {                    TIFFWarningExt(tif->tif_clientdata,"_TIFFVGetField",                                   "Truncating NumberOfInks from %u to %u",                                   val, td->td_samplesperpixel);                    val = td->td_samplesperpixel;                }                *va_arg(ap, uint16*) = val;                return 1;            }            return 0;        }
int i;
int i;
int
i
i
for (i = 0; i < td->td_customValueCount; i++) {                uint16 val;                TIFFTagValue *tv = td->td_customValues + i;                if (tv->info->field_tag != standard_tag)                    continue;                if( tv->value == NULL )                    return 0;                val = *(uint16 *)tv->value;                /* Truncate to SamplesPerPixel, since the */                /* setting code for INKNAMES assume that there are SamplesPerPixel */                /* inknames. */                /* Fixes http://bugzilla.maptools.org/show_bug.cgi?id=2599 */                if( val > td->td_samplesperpixel )                {                    TIFFWarningExt(tif->tif_clientdata,"_TIFFVGetField",                                   "Truncating NumberOfInks from %u to %u",                                   val, td->td_samplesperpixel);                    val = td->td_samplesperpixel;                }                *va_arg(ap, uint16*) = val;                return 1;            }
i = 0;
i = 0
i
i
0
i < td->td_customValueCount
i
i
td->td_customValueCount
td
td
td_customValueCount
i++
i
i
{                uint16 val;                TIFFTagValue *tv = td->td_customValues + i;                if (tv->info->field_tag != standard_tag)                    continue;                if( tv->value == NULL )                    return 0;                val = *(uint16 *)tv->value;                /* Truncate to SamplesPerPixel, since the */                /* setting code for INKNAMES assume that there are SamplesPerPixel */                /* inknames. */                /* Fixes http://bugzilla.maptools.org/show_bug.cgi?id=2599 */                if( val > td->td_samplesperpixel )                {                    TIFFWarningExt(tif->tif_clientdata,"_TIFFVGetField",                                   "Truncating NumberOfInks from %u to %u",                                   val, td->td_samplesperpixel);                    val = td->td_samplesperpixel;                }                *va_arg(ap, uint16*) = val;                return 1;            }
uint16 val;
uint16 val;
uint16
uint16
val
val
TIFFTagValue *tv = td->td_customValues + i;
TIFFTagValue *tv = td->td_customValues + i;
TIFFTagValue
TIFFTagValue
*tv = td->td_customValues + i
*
tv
= td->td_customValues + i
td->td_customValues + i
td->td_customValues
td
td
td_customValues
i
i
if (tv->info->field_tag != standard_tag)                    continue;
tv->info->field_tag != standard_tag
tv->info->field_tag
tv->info
tv
tv
info
field_tag
standard_tag
standard_tag
continue;
if( tv->value == NULL )                    return 0;
tv->value == NULL
tv->value
tv
tv
value
NULL
NULL
return 0;
0
val = *(uint16 *)tv->value;
val = *(uint16 *)tv->value
val
val
*(uint16 *)tv->value
(uint16 *)tv->value
uint16 *
uint16
uint16
*
*
tv->value
tv
tv
value
if( val > td->td_samplesperpixel )                {                    TIFFWarningExt(tif->tif_clientdata,"_TIFFVGetField",                                   "Truncating NumberOfInks from %u to %u",                                   val, td->td_samplesperpixel);                    val = td->td_samplesperpixel;                }
val > td->td_samplesperpixel
val
val
td->td_samplesperpixel
td
td
td_samplesperpixel
{                    TIFFWarningExt(tif->tif_clientdata,"_TIFFVGetField",                                   "Truncating NumberOfInks from %u to %u",                                   val, td->td_samplesperpixel);                    val = td->td_samplesperpixel;                }
TIFFWarningExt(tif->tif_clientdata,"_TIFFVGetField",                                   "Truncating NumberOfInks from %u to %u",                                   val, td->td_samplesperpixel);
TIFFWarningExt(tif->tif_clientdata,"_TIFFVGetField",                                   "Truncating NumberOfInks from %u to %u",                                   val, td->td_samplesperpixel)
TIFFWarningExt
TIFFWarningExt
tif->tif_clientdata
tif
tif
tif_clientdata
"_TIFFVGetField"
"Truncating NumberOfInks from %u to %u"
val
val
td->td_samplesperpixel
td
td
td_samplesperpixel
val = td->td_samplesperpixel;
val = td->td_samplesperpixel
val
val
td->td_samplesperpixel
td
td
td_samplesperpixel
*va_arg(ap, uint16*) = val;
return 1;
1
return 0;
0
switch (standard_tag) {		case TIFFTAG_SUBFILETYPE:			*va_arg(ap, uint32*) = td->td_subfiletype;			break;		case TIFFTAG_IMAGEWIDTH:			*va_arg(ap, uint32*) = td->td_imagewidth;			break;		case TIFFTAG_IMAGELENGTH:			*va_arg(ap, uint32*) = td->td_imagelength;			break;		case TIFFTAG_BITSPERSAMPLE:			*va_arg(ap, uint16*) = td->td_bitspersample;			break;		case TIFFTAG_COMPRESSION:			*va_arg(ap, uint16*) = td->td_compression;			break;		case TIFFTAG_PHOTOMETRIC:			*va_arg(ap, uint16*) = td->td_photometric;			break;		case TIFFTAG_THRESHHOLDING:			*va_arg(ap, uint16*) = td->td_threshholding;			break;		case TIFFTAG_FILLORDER:			*va_arg(ap, uint16*) = td->td_fillorder;			break;		case TIFFTAG_ORIENTATION:			*va_arg(ap, uint16*) = td->td_orientation;			break;		case TIFFTAG_SAMPLESPERPIXEL:			*va_arg(ap, uint16*) = td->td_samplesperpixel;			break;		case TIFFTAG_ROWSPERSTRIP:			*va_arg(ap, uint32*) = td->td_rowsperstrip;			break;		case TIFFTAG_MINSAMPLEVALUE:			*va_arg(ap, uint16*) = td->td_minsamplevalue;			break;		case TIFFTAG_MAXSAMPLEVALUE:			*va_arg(ap, uint16*) = td->td_maxsamplevalue;			break;		case TIFFTAG_SMINSAMPLEVALUE:			if (tif->tif_flags & TIFF_PERSAMPLE)				*va_arg(ap, double**) = td->td_sminsamplevalue;			else			{				/* libtiff historically treats this as a single value. */				uint16 i;				double v = td->td_sminsamplevalue[0];				for (i=1; i < td->td_samplesperpixel; ++i)					if( td->td_sminsamplevalue[i] < v )						v = td->td_sminsamplevalue[i];				*va_arg(ap, double*) = v;			}			break;		case TIFFTAG_SMAXSAMPLEVALUE:			if (tif->tif_flags & TIFF_PERSAMPLE)				*va_arg(ap, double**) = td->td_smaxsamplevalue;			else			{				/* libtiff historically treats this as a single value. */				uint16 i;				double v = td->td_smaxsamplevalue[0];				for (i=1; i < td->td_samplesperpixel; ++i)					if( td->td_smaxsamplevalue[i] > v )						v = td->td_smaxsamplevalue[i];				*va_arg(ap, double*) = v;			}			break;		case TIFFTAG_XRESOLUTION:			*va_arg(ap, float*) = td->td_xresolution;			break;		case TIFFTAG_YRESOLUTION:			*va_arg(ap, float*) = td->td_yresolution;			break;		case TIFFTAG_PLANARCONFIG:			*va_arg(ap, uint16*) = td->td_planarconfig;			break;		case TIFFTAG_XPOSITION:			*va_arg(ap, float*) = td->td_xposition;			break;		case TIFFTAG_YPOSITION:			*va_arg(ap, float*) = td->td_yposition;			break;		case TIFFTAG_RESOLUTIONUNIT:			*va_arg(ap, uint16*) = td->td_resolutionunit;			break;		case TIFFTAG_PAGENUMBER:			*va_arg(ap, uint16*) = td->td_pagenumber[0];			*va_arg(ap, uint16*) = td->td_pagenumber[1];			break;		case TIFFTAG_HALFTONEHINTS:			*va_arg(ap, uint16*) = td->td_halftonehints[0];			*va_arg(ap, uint16*) = td->td_halftonehints[1];			break;		case TIFFTAG_COLORMAP:			*va_arg(ap, uint16**) = td->td_colormap[0];			*va_arg(ap, uint16**) = td->td_colormap[1];			*va_arg(ap, uint16**) = td->td_colormap[2];			break;		case TIFFTAG_STRIPOFFSETS:		case TIFFTAG_TILEOFFSETS:			_TIFFFillStriles( tif );			*va_arg(ap, uint64**) = td->td_stripoffset;			break;		case TIFFTAG_STRIPBYTECOUNTS:		case TIFFTAG_TILEBYTECOUNTS:			_TIFFFillStriles( tif );			*va_arg(ap, uint64**) = td->td_stripbytecount;			break;		case TIFFTAG_MATTEING:			*va_arg(ap, uint16*) =			    (td->td_extrasamples == 1 &&			    td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA);			break;		case TIFFTAG_EXTRASAMPLES:			*va_arg(ap, uint16*) = td->td_extrasamples;			*va_arg(ap, uint16**) = td->td_sampleinfo;			break;		case TIFFTAG_TILEWIDTH:			*va_arg(ap, uint32*) = td->td_tilewidth;			break;		case TIFFTAG_TILELENGTH:			*va_arg(ap, uint32*) = td->td_tilelength;			break;		case TIFFTAG_TILEDEPTH:			*va_arg(ap, uint32*) = td->td_tiledepth;			break;		case TIFFTAG_DATATYPE:			switch (td->td_sampleformat) {				case SAMPLEFORMAT_UINT:					*va_arg(ap, uint16*) = DATATYPE_UINT;					break;				case SAMPLEFORMAT_INT:					*va_arg(ap, uint16*) = DATATYPE_INT;					break;				case SAMPLEFORMAT_IEEEFP:					*va_arg(ap, uint16*) = DATATYPE_IEEEFP;					break;				case SAMPLEFORMAT_VOID:					*va_arg(ap, uint16*) = DATATYPE_VOID;					break;			}			break;		case TIFFTAG_SAMPLEFORMAT:			*va_arg(ap, uint16*) = td->td_sampleformat;			break;		case TIFFTAG_IMAGEDEPTH:			*va_arg(ap, uint32*) = td->td_imagedepth;			break;		case TIFFTAG_SUBIFD:			*va_arg(ap, uint16*) = td->td_nsubifd;			*va_arg(ap, uint64**) = td->td_subifd;			break;		case TIFFTAG_YCBCRPOSITIONING:			*va_arg(ap, uint16*) = td->td_ycbcrpositioning;			break;		case TIFFTAG_YCBCRSUBSAMPLING:			*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[0];			*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[1];			break;		case TIFFTAG_TRANSFERFUNCTION:			*va_arg(ap, uint16**) = td->td_transferfunction[0];			if (td->td_samplesperpixel - td->td_extrasamples > 1) {				*va_arg(ap, uint16**) = td->td_transferfunction[1];				*va_arg(ap, uint16**) = td->td_transferfunction[2];			} else {				*va_arg(ap, uint16**) = NULL;				*va_arg(ap, uint16**) = NULL;			}			break;		case TIFFTAG_REFERENCEBLACKWHITE:			*va_arg(ap, float**) = td->td_refblackwhite;			break;		case TIFFTAG_INKNAMES:			*va_arg(ap, char**) = td->td_inknames;			break;		default:			{				int i;				/*				 * This can happen if multiple images are open				 * with different codecs which have private				 * tags.  The global tag information table may				 * then have tags that are valid for one file				 * but not the other. If the client tries to				 * get a tag that is not valid for the image's				 * codec then we'll arrive here.				 */				if( fip->field_bit != FIELD_CUSTOM )				{					TIFFErrorExt(tif->tif_clientdata, "_TIFFVGetField",					    "%s: Invalid %stag \"%s\" "					    "(not supported by codec)",					    tif->tif_name,					    isPseudoTag(tag) ? "pseudo-" : "",					    fip->field_name);					ret_val = 0;					break;				}				/*				 * Do we have a custom value?				 */				ret_val = 0;				for (i = 0; i < td->td_customValueCount; i++) {					TIFFTagValue *tv = td->td_customValues + i;					if (tv->info->field_tag != tag)						continue;					if (fip->field_passcount) {						if (fip->field_readcount == TIFF_VARIABLE2)							*va_arg(ap, uint32*) = (uint32)tv->count;						else  /* Assume TIFF_VARIABLE */							*va_arg(ap, uint16*) = (uint16)tv->count;						*va_arg(ap, void **) = tv->value;						ret_val = 1;					} else if (fip->field_tag == TIFFTAG_DOTRANGE						   && strcmp(fip->field_name,"DotRange") == 0) {						/* TODO: This is an evil exception and should not have been						   handled this way ... likely best if we move it into						   the directory structure with an explicit field in 						   libtiff 4.1 and assign it a FIELD_ value */						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[0];						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[1];						ret_val = 1;					} else {						if (fip->field_type == TIFF_ASCII						    || fip->field_readcount == TIFF_VARIABLE						    || fip->field_readcount == TIFF_VARIABLE2						    || fip->field_readcount == TIFF_SPP						    || tv->count > 1) {							*va_arg(ap, void **) = tv->value;							ret_val = 1;						} else {							char *val = (char *)tv->value;							assert( tv->count == 1 );							switch (fip->field_type) {							case TIFF_BYTE:							case TIFF_UNDEFINED:								*va_arg(ap, uint8*) =									*(uint8 *)val;								ret_val = 1;								break;							case TIFF_SBYTE:								*va_arg(ap, int8*) =									*(int8 *)val;								ret_val = 1;								break;							case TIFF_SHORT:								*va_arg(ap, uint16*) =									*(uint16 *)val;								ret_val = 1;								break;							case TIFF_SSHORT:								*va_arg(ap, int16*) =									*(int16 *)val;								ret_val = 1;								break;							case TIFF_LONG:							case TIFF_IFD:								*va_arg(ap, uint32*) =									*(uint32 *)val;								ret_val = 1;								break;							case TIFF_SLONG:								*va_arg(ap, int32*) =									*(int32 *)val;								ret_val = 1;								break;							case TIFF_LONG8:							case TIFF_IFD8:								*va_arg(ap, uint64*) =									*(uint64 *)val;								ret_val = 1;								break;							case TIFF_SLONG8:								*va_arg(ap, int64*) =									*(int64 *)val;								ret_val = 1;								break;							case TIFF_RATIONAL:							case TIFF_SRATIONAL:							case TIFF_FLOAT:								*va_arg(ap, float*) =									*(float *)val;								ret_val = 1;								break;							case TIFF_DOUBLE:								*va_arg(ap, double*) =									*(double *)val;								ret_val = 1;								break;							default:								ret_val = 0;								break;							}						}					}					break;				}			}	}
standard_tag
standard_tag
{		case TIFFTAG_SUBFILETYPE:			*va_arg(ap, uint32*) = td->td_subfiletype;			break;		case TIFFTAG_IMAGEWIDTH:			*va_arg(ap, uint32*) = td->td_imagewidth;			break;		case TIFFTAG_IMAGELENGTH:			*va_arg(ap, uint32*) = td->td_imagelength;			break;		case TIFFTAG_BITSPERSAMPLE:			*va_arg(ap, uint16*) = td->td_bitspersample;			break;		case TIFFTAG_COMPRESSION:			*va_arg(ap, uint16*) = td->td_compression;			break;		case TIFFTAG_PHOTOMETRIC:			*va_arg(ap, uint16*) = td->td_photometric;			break;		case TIFFTAG_THRESHHOLDING:			*va_arg(ap, uint16*) = td->td_threshholding;			break;		case TIFFTAG_FILLORDER:			*va_arg(ap, uint16*) = td->td_fillorder;			break;		case TIFFTAG_ORIENTATION:			*va_arg(ap, uint16*) = td->td_orientation;			break;		case TIFFTAG_SAMPLESPERPIXEL:			*va_arg(ap, uint16*) = td->td_samplesperpixel;			break;		case TIFFTAG_ROWSPERSTRIP:			*va_arg(ap, uint32*) = td->td_rowsperstrip;			break;		case TIFFTAG_MINSAMPLEVALUE:			*va_arg(ap, uint16*) = td->td_minsamplevalue;			break;		case TIFFTAG_MAXSAMPLEVALUE:			*va_arg(ap, uint16*) = td->td_maxsamplevalue;			break;		case TIFFTAG_SMINSAMPLEVALUE:			if (tif->tif_flags & TIFF_PERSAMPLE)				*va_arg(ap, double**) = td->td_sminsamplevalue;			else			{				/* libtiff historically treats this as a single value. */				uint16 i;				double v = td->td_sminsamplevalue[0];				for (i=1; i < td->td_samplesperpixel; ++i)					if( td->td_sminsamplevalue[i] < v )						v = td->td_sminsamplevalue[i];				*va_arg(ap, double*) = v;			}			break;		case TIFFTAG_SMAXSAMPLEVALUE:			if (tif->tif_flags & TIFF_PERSAMPLE)				*va_arg(ap, double**) = td->td_smaxsamplevalue;			else			{				/* libtiff historically treats this as a single value. */				uint16 i;				double v = td->td_smaxsamplevalue[0];				for (i=1; i < td->td_samplesperpixel; ++i)					if( td->td_smaxsamplevalue[i] > v )						v = td->td_smaxsamplevalue[i];				*va_arg(ap, double*) = v;			}			break;		case TIFFTAG_XRESOLUTION:			*va_arg(ap, float*) = td->td_xresolution;			break;		case TIFFTAG_YRESOLUTION:			*va_arg(ap, float*) = td->td_yresolution;			break;		case TIFFTAG_PLANARCONFIG:			*va_arg(ap, uint16*) = td->td_planarconfig;			break;		case TIFFTAG_XPOSITION:			*va_arg(ap, float*) = td->td_xposition;			break;		case TIFFTAG_YPOSITION:			*va_arg(ap, float*) = td->td_yposition;			break;		case TIFFTAG_RESOLUTIONUNIT:			*va_arg(ap, uint16*) = td->td_resolutionunit;			break;		case TIFFTAG_PAGENUMBER:			*va_arg(ap, uint16*) = td->td_pagenumber[0];			*va_arg(ap, uint16*) = td->td_pagenumber[1];			break;		case TIFFTAG_HALFTONEHINTS:			*va_arg(ap, uint16*) = td->td_halftonehints[0];			*va_arg(ap, uint16*) = td->td_halftonehints[1];			break;		case TIFFTAG_COLORMAP:			*va_arg(ap, uint16**) = td->td_colormap[0];			*va_arg(ap, uint16**) = td->td_colormap[1];			*va_arg(ap, uint16**) = td->td_colormap[2];			break;		case TIFFTAG_STRIPOFFSETS:		case TIFFTAG_TILEOFFSETS:			_TIFFFillStriles( tif );			*va_arg(ap, uint64**) = td->td_stripoffset;			break;		case TIFFTAG_STRIPBYTECOUNTS:		case TIFFTAG_TILEBYTECOUNTS:			_TIFFFillStriles( tif );			*va_arg(ap, uint64**) = td->td_stripbytecount;			break;		case TIFFTAG_MATTEING:			*va_arg(ap, uint16*) =			    (td->td_extrasamples == 1 &&			    td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA);			break;		case TIFFTAG_EXTRASAMPLES:			*va_arg(ap, uint16*) = td->td_extrasamples;			*va_arg(ap, uint16**) = td->td_sampleinfo;			break;		case TIFFTAG_TILEWIDTH:			*va_arg(ap, uint32*) = td->td_tilewidth;			break;		case TIFFTAG_TILELENGTH:			*va_arg(ap, uint32*) = td->td_tilelength;			break;		case TIFFTAG_TILEDEPTH:			*va_arg(ap, uint32*) = td->td_tiledepth;			break;		case TIFFTAG_DATATYPE:			switch (td->td_sampleformat) {				case SAMPLEFORMAT_UINT:					*va_arg(ap, uint16*) = DATATYPE_UINT;					break;				case SAMPLEFORMAT_INT:					*va_arg(ap, uint16*) = DATATYPE_INT;					break;				case SAMPLEFORMAT_IEEEFP:					*va_arg(ap, uint16*) = DATATYPE_IEEEFP;					break;				case SAMPLEFORMAT_VOID:					*va_arg(ap, uint16*) = DATATYPE_VOID;					break;			}			break;		case TIFFTAG_SAMPLEFORMAT:			*va_arg(ap, uint16*) = td->td_sampleformat;			break;		case TIFFTAG_IMAGEDEPTH:			*va_arg(ap, uint32*) = td->td_imagedepth;			break;		case TIFFTAG_SUBIFD:			*va_arg(ap, uint16*) = td->td_nsubifd;			*va_arg(ap, uint64**) = td->td_subifd;			break;		case TIFFTAG_YCBCRPOSITIONING:			*va_arg(ap, uint16*) = td->td_ycbcrpositioning;			break;		case TIFFTAG_YCBCRSUBSAMPLING:			*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[0];			*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[1];			break;		case TIFFTAG_TRANSFERFUNCTION:			*va_arg(ap, uint16**) = td->td_transferfunction[0];			if (td->td_samplesperpixel - td->td_extrasamples > 1) {				*va_arg(ap, uint16**) = td->td_transferfunction[1];				*va_arg(ap, uint16**) = td->td_transferfunction[2];			} else {				*va_arg(ap, uint16**) = NULL;				*va_arg(ap, uint16**) = NULL;			}			break;		case TIFFTAG_REFERENCEBLACKWHITE:			*va_arg(ap, float**) = td->td_refblackwhite;			break;		case TIFFTAG_INKNAMES:			*va_arg(ap, char**) = td->td_inknames;			break;		default:			{				int i;				/*				 * This can happen if multiple images are open				 * with different codecs which have private				 * tags.  The global tag information table may				 * then have tags that are valid for one file				 * but not the other. If the client tries to				 * get a tag that is not valid for the image's				 * codec then we'll arrive here.				 */				if( fip->field_bit != FIELD_CUSTOM )				{					TIFFErrorExt(tif->tif_clientdata, "_TIFFVGetField",					    "%s: Invalid %stag \"%s\" "					    "(not supported by codec)",					    tif->tif_name,					    isPseudoTag(tag) ? "pseudo-" : "",					    fip->field_name);					ret_val = 0;					break;				}				/*				 * Do we have a custom value?				 */				ret_val = 0;				for (i = 0; i < td->td_customValueCount; i++) {					TIFFTagValue *tv = td->td_customValues + i;					if (tv->info->field_tag != tag)						continue;					if (fip->field_passcount) {						if (fip->field_readcount == TIFF_VARIABLE2)							*va_arg(ap, uint32*) = (uint32)tv->count;						else  /* Assume TIFF_VARIABLE */							*va_arg(ap, uint16*) = (uint16)tv->count;						*va_arg(ap, void **) = tv->value;						ret_val = 1;					} else if (fip->field_tag == TIFFTAG_DOTRANGE						   && strcmp(fip->field_name,"DotRange") == 0) {						/* TODO: This is an evil exception and should not have been						   handled this way ... likely best if we move it into						   the directory structure with an explicit field in 						   libtiff 4.1 and assign it a FIELD_ value */						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[0];						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[1];						ret_val = 1;					} else {						if (fip->field_type == TIFF_ASCII						    || fip->field_readcount == TIFF_VARIABLE						    || fip->field_readcount == TIFF_VARIABLE2						    || fip->field_readcount == TIFF_SPP						    || tv->count > 1) {							*va_arg(ap, void **) = tv->value;							ret_val = 1;						} else {							char *val = (char *)tv->value;							assert( tv->count == 1 );							switch (fip->field_type) {							case TIFF_BYTE:							case TIFF_UNDEFINED:								*va_arg(ap, uint8*) =									*(uint8 *)val;								ret_val = 1;								break;							case TIFF_SBYTE:								*va_arg(ap, int8*) =									*(int8 *)val;								ret_val = 1;								break;							case TIFF_SHORT:								*va_arg(ap, uint16*) =									*(uint16 *)val;								ret_val = 1;								break;							case TIFF_SSHORT:								*va_arg(ap, int16*) =									*(int16 *)val;								ret_val = 1;								break;							case TIFF_LONG:							case TIFF_IFD:								*va_arg(ap, uint32*) =									*(uint32 *)val;								ret_val = 1;								break;							case TIFF_SLONG:								*va_arg(ap, int32*) =									*(int32 *)val;								ret_val = 1;								break;							case TIFF_LONG8:							case TIFF_IFD8:								*va_arg(ap, uint64*) =									*(uint64 *)val;								ret_val = 1;								break;							case TIFF_SLONG8:								*va_arg(ap, int64*) =									*(int64 *)val;								ret_val = 1;								break;							case TIFF_RATIONAL:							case TIFF_SRATIONAL:							case TIFF_FLOAT:								*va_arg(ap, float*) =									*(float *)val;								ret_val = 1;								break;							case TIFF_DOUBLE:								*va_arg(ap, double*) =									*(double *)val;								ret_val = 1;								break;							default:								ret_val = 0;								break;							}						}					}					break;				}			}	}
case TIFFTAG_SUBFILETYPE:
TIFFTAG_SUBFILETYPE
TIFFTAG_SUBFILETYPE
*va_arg(ap, uint32*) = td->td_subfiletype;
break;
case TIFFTAG_IMAGEWIDTH:
TIFFTAG_IMAGEWIDTH
TIFFTAG_IMAGEWIDTH
*va_arg(ap, uint32*) = td->td_imagewidth;
break;
case TIFFTAG_IMAGELENGTH:
TIFFTAG_IMAGELENGTH
TIFFTAG_IMAGELENGTH
*va_arg(ap, uint32*) = td->td_imagelength;
break;
case TIFFTAG_BITSPERSAMPLE:
TIFFTAG_BITSPERSAMPLE
TIFFTAG_BITSPERSAMPLE
*va_arg(ap, uint16*) = td->td_bitspersample;
break;
case TIFFTAG_COMPRESSION:
TIFFTAG_COMPRESSION
TIFFTAG_COMPRESSION
*va_arg(ap, uint16*) = td->td_compression;
break;
case TIFFTAG_PHOTOMETRIC:
TIFFTAG_PHOTOMETRIC
TIFFTAG_PHOTOMETRIC
*va_arg(ap, uint16*) = td->td_photometric;
break;
case TIFFTAG_THRESHHOLDING:
TIFFTAG_THRESHHOLDING
TIFFTAG_THRESHHOLDING
*va_arg(ap, uint16*) = td->td_threshholding;
break;
case TIFFTAG_FILLORDER:
TIFFTAG_FILLORDER
TIFFTAG_FILLORDER
*va_arg(ap, uint16*) = td->td_fillorder;
break;
case TIFFTAG_ORIENTATION:
TIFFTAG_ORIENTATION
TIFFTAG_ORIENTATION
*va_arg(ap, uint16*) = td->td_orientation;
break;
case TIFFTAG_SAMPLESPERPIXEL:
TIFFTAG_SAMPLESPERPIXEL
TIFFTAG_SAMPLESPERPIXEL
*va_arg(ap, uint16*) = td->td_samplesperpixel;
break;
case TIFFTAG_ROWSPERSTRIP:
TIFFTAG_ROWSPERSTRIP
TIFFTAG_ROWSPERSTRIP
*va_arg(ap, uint32*) = td->td_rowsperstrip;
break;
case TIFFTAG_MINSAMPLEVALUE:
TIFFTAG_MINSAMPLEVALUE
TIFFTAG_MINSAMPLEVALUE
*va_arg(ap, uint16*) = td->td_minsamplevalue;
break;
case TIFFTAG_MAXSAMPLEVALUE:
TIFFTAG_MAXSAMPLEVALUE
TIFFTAG_MAXSAMPLEVALUE
*va_arg(ap, uint16*) = td->td_maxsamplevalue;
break;
case TIFFTAG_SMINSAMPLEVALUE:
TIFFTAG_SMINSAMPLEVALUE
TIFFTAG_SMINSAMPLEVALUE
if (tif->tif_flags & TIFF_PERSAMPLE)				*va_arg(ap, double**) = td->td_sminsamplevalue;
else			{				/* libtiff historically treats this as a single value. */				uint16 i;				double v = td->td_sminsamplevalue[0];				for (i=1; i < td->td_samplesperpixel; ++i)					if( td->td_sminsamplevalue[i] < v )						v = td->td_sminsamplevalue[i];				*va_arg(ap, double*) = v;			}
break;
case TIFFTAG_SMAXSAMPLEVALUE:
TIFFTAG_SMAXSAMPLEVALUE
TIFFTAG_SMAXSAMPLEVALUE
if (tif->tif_flags & TIFF_PERSAMPLE)				*va_arg(ap, double**) = td->td_smaxsamplevalue;
else			{				/* libtiff historically treats this as a single value. */				uint16 i;				double v = td->td_smaxsamplevalue[0];				for (i=1; i < td->td_samplesperpixel; ++i)					if( td->td_smaxsamplevalue[i] > v )						v = td->td_smaxsamplevalue[i];				*va_arg(ap, double*) = v;			}
break;
case TIFFTAG_XRESOLUTION:
TIFFTAG_XRESOLUTION
TIFFTAG_XRESOLUTION
*va_arg(ap, float*) = td->td_xresolution;
break;
case TIFFTAG_YRESOLUTION:
TIFFTAG_YRESOLUTION
TIFFTAG_YRESOLUTION
*va_arg(ap, float*) = td->td_yresolution;
break;
case TIFFTAG_PLANARCONFIG:
TIFFTAG_PLANARCONFIG
TIFFTAG_PLANARCONFIG
*va_arg(ap, uint16*) = td->td_planarconfig;
break;
case TIFFTAG_XPOSITION:
TIFFTAG_XPOSITION
TIFFTAG_XPOSITION
*va_arg(ap, float*) = td->td_xposition;
break;
case TIFFTAG_YPOSITION:
TIFFTAG_YPOSITION
TIFFTAG_YPOSITION
*va_arg(ap, float*) = td->td_yposition;
break;
case TIFFTAG_RESOLUTIONUNIT:
TIFFTAG_RESOLUTIONUNIT
TIFFTAG_RESOLUTIONUNIT
*va_arg(ap, uint16*) = td->td_resolutionunit;
break;
case TIFFTAG_PAGENUMBER:
TIFFTAG_PAGENUMBER
TIFFTAG_PAGENUMBER
*va_arg(ap, uint16*) = td->td_pagenumber[0];
*va_arg(ap, uint16*) = td->td_pagenumber[1];
break;
case TIFFTAG_HALFTONEHINTS:
TIFFTAG_HALFTONEHINTS
TIFFTAG_HALFTONEHINTS
*va_arg(ap, uint16*) = td->td_halftonehints[0];
*va_arg(ap, uint16*) = td->td_halftonehints[1];
break;
case TIFFTAG_COLORMAP:
TIFFTAG_COLORMAP
TIFFTAG_COLORMAP
*va_arg(ap, uint16**) = td->td_colormap[0];
*va_arg(ap, uint16**) = td->td_colormap[1];
*va_arg(ap, uint16**) = td->td_colormap[2];
break;
case TIFFTAG_STRIPOFFSETS:
TIFFTAG_STRIPOFFSETS
TIFFTAG_STRIPOFFSETS
case TIFFTAG_TILEOFFSETS:
TIFFTAG_TILEOFFSETS
TIFFTAG_TILEOFFSETS
_TIFFFillStriles( tif );
_TIFFFillStriles( tif )
_TIFFFillStriles
_TIFFFillStriles
tif
tif
*va_arg(ap, uint64**) = td->td_stripoffset;
break;
case TIFFTAG_STRIPBYTECOUNTS:
TIFFTAG_STRIPBYTECOUNTS
TIFFTAG_STRIPBYTECOUNTS
case TIFFTAG_TILEBYTECOUNTS:
TIFFTAG_TILEBYTECOUNTS
TIFFTAG_TILEBYTECOUNTS
_TIFFFillStriles( tif );
_TIFFFillStriles( tif )
_TIFFFillStriles
_TIFFFillStriles
tif
tif
*va_arg(ap, uint64**) = td->td_stripbytecount;
break;
case TIFFTAG_MATTEING:
TIFFTAG_MATTEING
TIFFTAG_MATTEING
*va_arg(ap, uint16*) =			    (td->td_extrasamples == 1 &&			    td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA);
break;
case TIFFTAG_EXTRASAMPLES:
TIFFTAG_EXTRASAMPLES
TIFFTAG_EXTRASAMPLES
*va_arg(ap, uint16*) = td->td_extrasamples;
*va_arg(ap, uint16**) = td->td_sampleinfo;
break;
case TIFFTAG_TILEWIDTH:
TIFFTAG_TILEWIDTH
TIFFTAG_TILEWIDTH
*va_arg(ap, uint32*) = td->td_tilewidth;
break;
case TIFFTAG_TILELENGTH:
TIFFTAG_TILELENGTH
TIFFTAG_TILELENGTH
*va_arg(ap, uint32*) = td->td_tilelength;
break;
case TIFFTAG_TILEDEPTH:
TIFFTAG_TILEDEPTH
TIFFTAG_TILEDEPTH
*va_arg(ap, uint32*) = td->td_tiledepth;
break;
case TIFFTAG_DATATYPE:
TIFFTAG_DATATYPE
TIFFTAG_DATATYPE
switch (td->td_sampleformat) {				case SAMPLEFORMAT_UINT:					*va_arg(ap, uint16*) = DATATYPE_UINT;					break;				case SAMPLEFORMAT_INT:					*va_arg(ap, uint16*) = DATATYPE_INT;					break;				case SAMPLEFORMAT_IEEEFP:					*va_arg(ap, uint16*) = DATATYPE_IEEEFP;					break;				case SAMPLEFORMAT_VOID:					*va_arg(ap, uint16*) = DATATYPE_VOID;					break;			}
td->td_sampleformat
td
td
td_sampleformat
{				case SAMPLEFORMAT_UINT:					*va_arg(ap, uint16*) = DATATYPE_UINT;					break;				case SAMPLEFORMAT_INT:					*va_arg(ap, uint16*) = DATATYPE_INT;					break;				case SAMPLEFORMAT_IEEEFP:					*va_arg(ap, uint16*) = DATATYPE_IEEEFP;					break;				case SAMPLEFORMAT_VOID:					*va_arg(ap, uint16*) = DATATYPE_VOID;					break;			}
case SAMPLEFORMAT_UINT:
SAMPLEFORMAT_UINT
SAMPLEFORMAT_UINT
*va_arg(ap, uint16*) = DATATYPE_UINT;
break;
case SAMPLEFORMAT_INT:
SAMPLEFORMAT_INT
SAMPLEFORMAT_INT
*va_arg(ap, uint16*) = DATATYPE_INT;
break;
case SAMPLEFORMAT_IEEEFP:
SAMPLEFORMAT_IEEEFP
SAMPLEFORMAT_IEEEFP
*va_arg(ap, uint16*) = DATATYPE_IEEEFP;
break;
case SAMPLEFORMAT_VOID:
SAMPLEFORMAT_VOID
SAMPLEFORMAT_VOID
*va_arg(ap, uint16*) = DATATYPE_VOID;
break;
break;
case TIFFTAG_SAMPLEFORMAT:
TIFFTAG_SAMPLEFORMAT
TIFFTAG_SAMPLEFORMAT
*va_arg(ap, uint16*) = td->td_sampleformat;
break;
case TIFFTAG_IMAGEDEPTH:
TIFFTAG_IMAGEDEPTH
TIFFTAG_IMAGEDEPTH
*va_arg(ap, uint32*) = td->td_imagedepth;
break;
case TIFFTAG_SUBIFD:
TIFFTAG_SUBIFD
TIFFTAG_SUBIFD
*va_arg(ap, uint16*) = td->td_nsubifd;
*va_arg(ap, uint64**) = td->td_subifd;
break;
case TIFFTAG_YCBCRPOSITIONING:
TIFFTAG_YCBCRPOSITIONING
TIFFTAG_YCBCRPOSITIONING
*va_arg(ap, uint16*) = td->td_ycbcrpositioning;
break;
case TIFFTAG_YCBCRSUBSAMPLING:
TIFFTAG_YCBCRSUBSAMPLING
TIFFTAG_YCBCRSUBSAMPLING
*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[0];
*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[1];
break;
case TIFFTAG_TRANSFERFUNCTION:
TIFFTAG_TRANSFERFUNCTION
TIFFTAG_TRANSFERFUNCTION
*va_arg(ap, uint16**) = td->td_transferfunction[0];
if (td->td_samplesperpixel - td->td_extrasamples > 1) {				*va_arg(ap, uint16**) = td->td_transferfunction[1];				*va_arg(ap, uint16**) = td->td_transferfunction[2];			} else {				*va_arg(ap, uint16**) = NULL;				*va_arg(ap, uint16**) = NULL;			}
td->td_samplesperpixel - td->td_extrasamples > 1
td->td_samplesperpixel - td->td_extrasamples
td->td_samplesperpixel
td
td
td_samplesperpixel
td->td_extrasamples
td
td
td_extrasamples
1
{				*va_arg(ap, uint16**) = td->td_transferfunction[1];				*va_arg(ap, uint16**) = td->td_transferfunction[2];			}
*va_arg(ap, uint16**) = td->td_transferfunction[1];
*va_arg(ap, uint16**) = td->td_transferfunction[2];
{				*va_arg(ap, uint16**) = NULL;				*va_arg(ap, uint16**) = NULL;			}
*va_arg(ap, uint16**) = NULL;
*va_arg(ap, uint16**) = NULL;
break;
case TIFFTAG_REFERENCEBLACKWHITE:
TIFFTAG_REFERENCEBLACKWHITE
TIFFTAG_REFERENCEBLACKWHITE
*va_arg(ap, float**) = td->td_refblackwhite;
break;
case TIFFTAG_INKNAMES:
TIFFTAG_INKNAMES
TIFFTAG_INKNAMES
*va_arg(ap, char**) = td->td_inknames;
break;
default:
{				int i;				/*				 * This can happen if multiple images are open				 * with different codecs which have private				 * tags.  The global tag information table may				 * then have tags that are valid for one file				 * but not the other. If the client tries to				 * get a tag that is not valid for the image's				 * codec then we'll arrive here.				 */				if( fip->field_bit != FIELD_CUSTOM )				{					TIFFErrorExt(tif->tif_clientdata, "_TIFFVGetField",					    "%s: Invalid %stag \"%s\" "					    "(not supported by codec)",					    tif->tif_name,					    isPseudoTag(tag) ? "pseudo-" : "",					    fip->field_name);					ret_val = 0;					break;				}				/*				 * Do we have a custom value?				 */				ret_val = 0;				for (i = 0; i < td->td_customValueCount; i++) {					TIFFTagValue *tv = td->td_customValues + i;					if (tv->info->field_tag != tag)						continue;					if (fip->field_passcount) {						if (fip->field_readcount == TIFF_VARIABLE2)							*va_arg(ap, uint32*) = (uint32)tv->count;						else  /* Assume TIFF_VARIABLE */							*va_arg(ap, uint16*) = (uint16)tv->count;						*va_arg(ap, void **) = tv->value;						ret_val = 1;					} else if (fip->field_tag == TIFFTAG_DOTRANGE						   && strcmp(fip->field_name,"DotRange") == 0) {						/* TODO: This is an evil exception and should not have been						   handled this way ... likely best if we move it into						   the directory structure with an explicit field in 						   libtiff 4.1 and assign it a FIELD_ value */						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[0];						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[1];						ret_val = 1;					} else {						if (fip->field_type == TIFF_ASCII						    || fip->field_readcount == TIFF_VARIABLE						    || fip->field_readcount == TIFF_VARIABLE2						    || fip->field_readcount == TIFF_SPP						    || tv->count > 1) {							*va_arg(ap, void **) = tv->value;							ret_val = 1;						} else {							char *val = (char *)tv->value;							assert( tv->count == 1 );							switch (fip->field_type) {							case TIFF_BYTE:							case TIFF_UNDEFINED:								*va_arg(ap, uint8*) =									*(uint8 *)val;								ret_val = 1;								break;							case TIFF_SBYTE:								*va_arg(ap, int8*) =									*(int8 *)val;								ret_val = 1;								break;							case TIFF_SHORT:								*va_arg(ap, uint16*) =									*(uint16 *)val;								ret_val = 1;								break;							case TIFF_SSHORT:								*va_arg(ap, int16*) =									*(int16 *)val;								ret_val = 1;								break;							case TIFF_LONG:							case TIFF_IFD:								*va_arg(ap, uint32*) =									*(uint32 *)val;								ret_val = 1;								break;							case TIFF_SLONG:								*va_arg(ap, int32*) =									*(int32 *)val;								ret_val = 1;								break;							case TIFF_LONG8:							case TIFF_IFD8:								*va_arg(ap, uint64*) =									*(uint64 *)val;								ret_val = 1;								break;							case TIFF_SLONG8:								*va_arg(ap, int64*) =									*(int64 *)val;								ret_val = 1;								break;							case TIFF_RATIONAL:							case TIFF_SRATIONAL:							case TIFF_FLOAT:								*va_arg(ap, float*) =									*(float *)val;								ret_val = 1;								break;							case TIFF_DOUBLE:								*va_arg(ap, double*) =									*(double *)val;								ret_val = 1;								break;							default:								ret_val = 0;								break;							}						}					}					break;				}			}
int i;
int i;
int
i
i
if( fip->field_bit != FIELD_CUSTOM )				{					TIFFErrorExt(tif->tif_clientdata, "_TIFFVGetField",					    "%s: Invalid %stag \"%s\" "					    "(not supported by codec)",					    tif->tif_name,					    isPseudoTag(tag) ? "pseudo-" : "",					    fip->field_name);					ret_val = 0;					break;				}
fip->field_bit != FIELD_CUSTOM
fip->field_bit
fip
fip
field_bit
FIELD_CUSTOM
FIELD_CUSTOM
{					TIFFErrorExt(tif->tif_clientdata, "_TIFFVGetField",					    "%s: Invalid %stag \"%s\" "					    "(not supported by codec)",					    tif->tif_name,					    isPseudoTag(tag) ? "pseudo-" : "",					    fip->field_name);					ret_val = 0;					break;				}
TIFFErrorExt(tif->tif_clientdata, "_TIFFVGetField",					    "%s: Invalid %stag \"%s\" "					    "(not supported by codec)",					    tif->tif_name,					    isPseudoTag(tag) ? "pseudo-" : "",					    fip->field_name);
TIFFErrorExt(tif->tif_clientdata, "_TIFFVGetField",					    "%s: Invalid %stag \"%s\" "					    "(not supported by codec)",					    tif->tif_name,					    isPseudoTag(tag) ? "pseudo-" : "",					    fip->field_name)
TIFFErrorExt
TIFFErrorExt
tif->tif_clientdata
tif
tif
tif_clientdata
"_TIFFVGetField"
"%s: Invalid %stag \"%s\" "					    "(not supported by codec)"
tif->tif_name
tif
tif
tif_name
isPseudoTag(tag) ? "pseudo-" : ""
isPseudoTag(tag)
isPseudoTag
isPseudoTag
tag
tag
"pseudo-"
""
fip->field_name
fip
fip
field_name
ret_val = 0;
ret_val = 0
ret_val
ret_val
0
break;
ret_val = 0;
ret_val = 0
ret_val
ret_val
0
for (i = 0; i < td->td_customValueCount; i++) {					TIFFTagValue *tv = td->td_customValues + i;					if (tv->info->field_tag != tag)						continue;					if (fip->field_passcount) {						if (fip->field_readcount == TIFF_VARIABLE2)							*va_arg(ap, uint32*) = (uint32)tv->count;						else  /* Assume TIFF_VARIABLE */							*va_arg(ap, uint16*) = (uint16)tv->count;						*va_arg(ap, void **) = tv->value;						ret_val = 1;					} else if (fip->field_tag == TIFFTAG_DOTRANGE						   && strcmp(fip->field_name,"DotRange") == 0) {						/* TODO: This is an evil exception and should not have been						   handled this way ... likely best if we move it into						   the directory structure with an explicit field in 						   libtiff 4.1 and assign it a FIELD_ value */						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[0];						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[1];						ret_val = 1;					} else {						if (fip->field_type == TIFF_ASCII						    || fip->field_readcount == TIFF_VARIABLE						    || fip->field_readcount == TIFF_VARIABLE2						    || fip->field_readcount == TIFF_SPP						    || tv->count > 1) {							*va_arg(ap, void **) = tv->value;							ret_val = 1;						} else {							char *val = (char *)tv->value;							assert( tv->count == 1 );							switch (fip->field_type) {							case TIFF_BYTE:							case TIFF_UNDEFINED:								*va_arg(ap, uint8*) =									*(uint8 *)val;								ret_val = 1;								break;							case TIFF_SBYTE:								*va_arg(ap, int8*) =									*(int8 *)val;								ret_val = 1;								break;							case TIFF_SHORT:								*va_arg(ap, uint16*) =									*(uint16 *)val;								ret_val = 1;								break;							case TIFF_SSHORT:								*va_arg(ap, int16*) =									*(int16 *)val;								ret_val = 1;								break;							case TIFF_LONG:							case TIFF_IFD:								*va_arg(ap, uint32*) =									*(uint32 *)val;								ret_val = 1;								break;							case TIFF_SLONG:								*va_arg(ap, int32*) =									*(int32 *)val;								ret_val = 1;								break;							case TIFF_LONG8:							case TIFF_IFD8:								*va_arg(ap, uint64*) =									*(uint64 *)val;								ret_val = 1;								break;							case TIFF_SLONG8:								*va_arg(ap, int64*) =									*(int64 *)val;								ret_val = 1;								break;							case TIFF_RATIONAL:							case TIFF_SRATIONAL:							case TIFF_FLOAT:								*va_arg(ap, float*) =									*(float *)val;								ret_val = 1;								break;							case TIFF_DOUBLE:								*va_arg(ap, double*) =									*(double *)val;								ret_val = 1;								break;							default:								ret_val = 0;								break;							}						}					}					break;				}
i = 0;
i = 0
i
i
0
i < td->td_customValueCount
i
i
td->td_customValueCount
td
td
td_customValueCount
i++
i
i
{					TIFFTagValue *tv = td->td_customValues + i;					if (tv->info->field_tag != tag)						continue;					if (fip->field_passcount) {						if (fip->field_readcount == TIFF_VARIABLE2)							*va_arg(ap, uint32*) = (uint32)tv->count;						else  /* Assume TIFF_VARIABLE */							*va_arg(ap, uint16*) = (uint16)tv->count;						*va_arg(ap, void **) = tv->value;						ret_val = 1;					} else if (fip->field_tag == TIFFTAG_DOTRANGE						   && strcmp(fip->field_name,"DotRange") == 0) {						/* TODO: This is an evil exception and should not have been						   handled this way ... likely best if we move it into						   the directory structure with an explicit field in 						   libtiff 4.1 and assign it a FIELD_ value */						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[0];						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[1];						ret_val = 1;					} else {						if (fip->field_type == TIFF_ASCII						    || fip->field_readcount == TIFF_VARIABLE						    || fip->field_readcount == TIFF_VARIABLE2						    || fip->field_readcount == TIFF_SPP						    || tv->count > 1) {							*va_arg(ap, void **) = tv->value;							ret_val = 1;						} else {							char *val = (char *)tv->value;							assert( tv->count == 1 );							switch (fip->field_type) {							case TIFF_BYTE:							case TIFF_UNDEFINED:								*va_arg(ap, uint8*) =									*(uint8 *)val;								ret_val = 1;								break;							case TIFF_SBYTE:								*va_arg(ap, int8*) =									*(int8 *)val;								ret_val = 1;								break;							case TIFF_SHORT:								*va_arg(ap, uint16*) =									*(uint16 *)val;								ret_val = 1;								break;							case TIFF_SSHORT:								*va_arg(ap, int16*) =									*(int16 *)val;								ret_val = 1;								break;							case TIFF_LONG:							case TIFF_IFD:								*va_arg(ap, uint32*) =									*(uint32 *)val;								ret_val = 1;								break;							case TIFF_SLONG:								*va_arg(ap, int32*) =									*(int32 *)val;								ret_val = 1;								break;							case TIFF_LONG8:							case TIFF_IFD8:								*va_arg(ap, uint64*) =									*(uint64 *)val;								ret_val = 1;								break;							case TIFF_SLONG8:								*va_arg(ap, int64*) =									*(int64 *)val;								ret_val = 1;								break;							case TIFF_RATIONAL:							case TIFF_SRATIONAL:							case TIFF_FLOAT:								*va_arg(ap, float*) =									*(float *)val;								ret_val = 1;								break;							case TIFF_DOUBLE:								*va_arg(ap, double*) =									*(double *)val;								ret_val = 1;								break;							default:								ret_val = 0;								break;							}						}					}					break;				}
TIFFTagValue *tv = td->td_customValues + i;
TIFFTagValue *tv = td->td_customValues + i;
TIFFTagValue
TIFFTagValue
*tv = td->td_customValues + i
*
tv
= td->td_customValues + i
td->td_customValues + i
td->td_customValues
td
td
td_customValues
i
i
if (tv->info->field_tag != tag)						continue;
tv->info->field_tag != tag
tv->info->field_tag
tv->info
tv
tv
info
field_tag
tag
tag
continue;
if (fip->field_passcount) {						if (fip->field_readcount == TIFF_VARIABLE2)							*va_arg(ap, uint32*) = (uint32)tv->count;						else  /* Assume TIFF_VARIABLE */							*va_arg(ap, uint16*) = (uint16)tv->count;						*va_arg(ap, void **) = tv->value;						ret_val = 1;					} else if (fip->field_tag == TIFFTAG_DOTRANGE						   && strcmp(fip->field_name,"DotRange") == 0) {						/* TODO: This is an evil exception and should not have been						   handled this way ... likely best if we move it into						   the directory structure with an explicit field in 						   libtiff 4.1 and assign it a FIELD_ value */						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[0];						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[1];						ret_val = 1;					} else {						if (fip->field_type == TIFF_ASCII						    || fip->field_readcount == TIFF_VARIABLE						    || fip->field_readcount == TIFF_VARIABLE2						    || fip->field_readcount == TIFF_SPP						    || tv->count > 1) {							*va_arg(ap, void **) = tv->value;							ret_val = 1;						} else {							char *val = (char *)tv->value;							assert( tv->count == 1 );							switch (fip->field_type) {							case TIFF_BYTE:							case TIFF_UNDEFINED:								*va_arg(ap, uint8*) =									*(uint8 *)val;								ret_val = 1;								break;							case TIFF_SBYTE:								*va_arg(ap, int8*) =									*(int8 *)val;								ret_val = 1;								break;							case TIFF_SHORT:								*va_arg(ap, uint16*) =									*(uint16 *)val;								ret_val = 1;								break;							case TIFF_SSHORT:								*va_arg(ap, int16*) =									*(int16 *)val;								ret_val = 1;								break;							case TIFF_LONG:							case TIFF_IFD:								*va_arg(ap, uint32*) =									*(uint32 *)val;								ret_val = 1;								break;							case TIFF_SLONG:								*va_arg(ap, int32*) =									*(int32 *)val;								ret_val = 1;								break;							case TIFF_LONG8:							case TIFF_IFD8:								*va_arg(ap, uint64*) =									*(uint64 *)val;								ret_val = 1;								break;							case TIFF_SLONG8:								*va_arg(ap, int64*) =									*(int64 *)val;								ret_val = 1;								break;							case TIFF_RATIONAL:							case TIFF_SRATIONAL:							case TIFF_FLOAT:								*va_arg(ap, float*) =									*(float *)val;								ret_val = 1;								break;							case TIFF_DOUBLE:								*va_arg(ap, double*) =									*(double *)val;								ret_val = 1;								break;							default:								ret_val = 0;								break;							}						}					}
fip->field_passcount
fip
fip
field_passcount
{						if (fip->field_readcount == TIFF_VARIABLE2)							*va_arg(ap, uint32*) = (uint32)tv->count;						else  /* Assume TIFF_VARIABLE */							*va_arg(ap, uint16*) = (uint16)tv->count;						*va_arg(ap, void **) = tv->value;						ret_val = 1;					}
if (fip->field_readcount == TIFF_VARIABLE2)							*va_arg(ap, uint32*) = (uint32)tv->count;
else  /* Assume TIFF_VARIABLE */							*va_arg(ap, uint16*) = (uint16)tv->count;
*va_arg(ap, void **) = tv->value;
ret_val = 1;
ret_val = 1
ret_val
ret_val
1
if (fip->field_tag == TIFFTAG_DOTRANGE						   && strcmp(fip->field_name,"DotRange") == 0) {						/* TODO: This is an evil exception and should not have been						   handled this way ... likely best if we move it into						   the directory structure with an explicit field in 						   libtiff 4.1 and assign it a FIELD_ value */						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[0];						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[1];						ret_val = 1;					} else {						if (fip->field_type == TIFF_ASCII						    || fip->field_readcount == TIFF_VARIABLE						    || fip->field_readcount == TIFF_VARIABLE2						    || fip->field_readcount == TIFF_SPP						    || tv->count > 1) {							*va_arg(ap, void **) = tv->value;							ret_val = 1;						} else {							char *val = (char *)tv->value;							assert( tv->count == 1 );							switch (fip->field_type) {							case TIFF_BYTE:							case TIFF_UNDEFINED:								*va_arg(ap, uint8*) =									*(uint8 *)val;								ret_val = 1;								break;							case TIFF_SBYTE:								*va_arg(ap, int8*) =									*(int8 *)val;								ret_val = 1;								break;							case TIFF_SHORT:								*va_arg(ap, uint16*) =									*(uint16 *)val;								ret_val = 1;								break;							case TIFF_SSHORT:								*va_arg(ap, int16*) =									*(int16 *)val;								ret_val = 1;								break;							case TIFF_LONG:							case TIFF_IFD:								*va_arg(ap, uint32*) =									*(uint32 *)val;								ret_val = 1;								break;							case TIFF_SLONG:								*va_arg(ap, int32*) =									*(int32 *)val;								ret_val = 1;								break;							case TIFF_LONG8:							case TIFF_IFD8:								*va_arg(ap, uint64*) =									*(uint64 *)val;								ret_val = 1;								break;							case TIFF_SLONG8:								*va_arg(ap, int64*) =									*(int64 *)val;								ret_val = 1;								break;							case TIFF_RATIONAL:							case TIFF_SRATIONAL:							case TIFF_FLOAT:								*va_arg(ap, float*) =									*(float *)val;								ret_val = 1;								break;							case TIFF_DOUBLE:								*va_arg(ap, double*) =									*(double *)val;								ret_val = 1;								break;							default:								ret_val = 0;								break;							}						}					}
fip->field_tag == TIFFTAG_DOTRANGE						   && strcmp(fip->field_name,"DotRange") == 0
fip->field_tag == TIFFTAG_DOTRANGE
fip->field_tag
fip
fip
field_tag
TIFFTAG_DOTRANGE
TIFFTAG_DOTRANGE
strcmp(fip->field_name,"DotRange") == 0
strcmp(fip->field_name,"DotRange")
strcmp
strcmp
fip->field_name
fip
fip
field_name
"DotRange"
0
{						/* TODO: This is an evil exception and should not have been						   handled this way ... likely best if we move it into						   the directory structure with an explicit field in 						   libtiff 4.1 and assign it a FIELD_ value */						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[0];						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[1];						ret_val = 1;					}
*va_arg(ap, uint16*) = ((uint16 *)tv->value)[0];
*va_arg(ap, uint16*) = ((uint16 *)tv->value)[1];
ret_val = 1;
ret_val = 1
ret_val
ret_val
1
{						if (fip->field_type == TIFF_ASCII						    || fip->field_readcount == TIFF_VARIABLE						    || fip->field_readcount == TIFF_VARIABLE2						    || fip->field_readcount == TIFF_SPP						    || tv->count > 1) {							*va_arg(ap, void **) = tv->value;							ret_val = 1;						} else {							char *val = (char *)tv->value;							assert( tv->count == 1 );							switch (fip->field_type) {							case TIFF_BYTE:							case TIFF_UNDEFINED:								*va_arg(ap, uint8*) =									*(uint8 *)val;								ret_val = 1;								break;							case TIFF_SBYTE:								*va_arg(ap, int8*) =									*(int8 *)val;								ret_val = 1;								break;							case TIFF_SHORT:								*va_arg(ap, uint16*) =									*(uint16 *)val;								ret_val = 1;								break;							case TIFF_SSHORT:								*va_arg(ap, int16*) =									*(int16 *)val;								ret_val = 1;								break;							case TIFF_LONG:							case TIFF_IFD:								*va_arg(ap, uint32*) =									*(uint32 *)val;								ret_val = 1;								break;							case TIFF_SLONG:								*va_arg(ap, int32*) =									*(int32 *)val;								ret_val = 1;								break;							case TIFF_LONG8:							case TIFF_IFD8:								*va_arg(ap, uint64*) =									*(uint64 *)val;								ret_val = 1;								break;							case TIFF_SLONG8:								*va_arg(ap, int64*) =									*(int64 *)val;								ret_val = 1;								break;							case TIFF_RATIONAL:							case TIFF_SRATIONAL:							case TIFF_FLOAT:								*va_arg(ap, float*) =									*(float *)val;								ret_val = 1;								break;							case TIFF_DOUBLE:								*va_arg(ap, double*) =									*(double *)val;								ret_val = 1;								break;							default:								ret_val = 0;								break;							}						}					}
if (fip->field_type == TIFF_ASCII						    || fip->field_readcount == TIFF_VARIABLE						    || fip->field_readcount == TIFF_VARIABLE2						    || fip->field_readcount == TIFF_SPP						    || tv->count > 1) {							*va_arg(ap, void **) = tv->value;							ret_val = 1;						} else {							char *val = (char *)tv->value;							assert( tv->count == 1 );							switch (fip->field_type) {							case TIFF_BYTE:							case TIFF_UNDEFINED:								*va_arg(ap, uint8*) =									*(uint8 *)val;								ret_val = 1;								break;							case TIFF_SBYTE:								*va_arg(ap, int8*) =									*(int8 *)val;								ret_val = 1;								break;							case TIFF_SHORT:								*va_arg(ap, uint16*) =									*(uint16 *)val;								ret_val = 1;								break;							case TIFF_SSHORT:								*va_arg(ap, int16*) =									*(int16 *)val;								ret_val = 1;								break;							case TIFF_LONG:							case TIFF_IFD:								*va_arg(ap, uint32*) =									*(uint32 *)val;								ret_val = 1;								break;							case TIFF_SLONG:								*va_arg(ap, int32*) =									*(int32 *)val;								ret_val = 1;								break;							case TIFF_LONG8:							case TIFF_IFD8:								*va_arg(ap, uint64*) =									*(uint64 *)val;								ret_val = 1;								break;							case TIFF_SLONG8:								*va_arg(ap, int64*) =									*(int64 *)val;								ret_val = 1;								break;							case TIFF_RATIONAL:							case TIFF_SRATIONAL:							case TIFF_FLOAT:								*va_arg(ap, float*) =									*(float *)val;								ret_val = 1;								break;							case TIFF_DOUBLE:								*va_arg(ap, double*) =									*(double *)val;								ret_val = 1;								break;							default:								ret_val = 0;								break;							}						}
fip->field_type == TIFF_ASCII						    || fip->field_readcount == TIFF_VARIABLE						    || fip->field_readcount == TIFF_VARIABLE2						    || fip->field_readcount == TIFF_SPP						    || tv->count > 1
fip->field_type == TIFF_ASCII						    || fip->field_readcount == TIFF_VARIABLE						    || fip->field_readcount == TIFF_VARIABLE2						    || fip->field_readcount == TIFF_SPP
fip->field_type == TIFF_ASCII						    || fip->field_readcount == TIFF_VARIABLE						    || fip->field_readcount == TIFF_VARIABLE2
fip->field_type == TIFF_ASCII						    || fip->field_readcount == TIFF_VARIABLE
fip->field_type == TIFF_ASCII
fip->field_type
fip
fip
field_type
TIFF_ASCII
TIFF_ASCII
fip->field_readcount == TIFF_VARIABLE
fip->field_readcount
fip
fip
field_readcount
TIFF_VARIABLE
TIFF_VARIABLE
fip->field_readcount == TIFF_VARIABLE2
fip->field_readcount
fip
fip
field_readcount
TIFF_VARIABLE2
TIFF_VARIABLE2
fip->field_readcount == TIFF_SPP
fip->field_readcount
fip
fip
field_readcount
TIFF_SPP
TIFF_SPP
tv->count > 1
tv->count
tv
tv
count
1
{							*va_arg(ap, void **) = tv->value;							ret_val = 1;						}
*va_arg(ap, void **) = tv->value;
ret_val = 1;
ret_val = 1
ret_val
ret_val
1
{							char *val = (char *)tv->value;							assert( tv->count == 1 );							switch (fip->field_type) {							case TIFF_BYTE:							case TIFF_UNDEFINED:								*va_arg(ap, uint8*) =									*(uint8 *)val;								ret_val = 1;								break;							case TIFF_SBYTE:								*va_arg(ap, int8*) =									*(int8 *)val;								ret_val = 1;								break;							case TIFF_SHORT:								*va_arg(ap, uint16*) =									*(uint16 *)val;								ret_val = 1;								break;							case TIFF_SSHORT:								*va_arg(ap, int16*) =									*(int16 *)val;								ret_val = 1;								break;							case TIFF_LONG:							case TIFF_IFD:								*va_arg(ap, uint32*) =									*(uint32 *)val;								ret_val = 1;								break;							case TIFF_SLONG:								*va_arg(ap, int32*) =									*(int32 *)val;								ret_val = 1;								break;							case TIFF_LONG8:							case TIFF_IFD8:								*va_arg(ap, uint64*) =									*(uint64 *)val;								ret_val = 1;								break;							case TIFF_SLONG8:								*va_arg(ap, int64*) =									*(int64 *)val;								ret_val = 1;								break;							case TIFF_RATIONAL:							case TIFF_SRATIONAL:							case TIFF_FLOAT:								*va_arg(ap, float*) =									*(float *)val;								ret_val = 1;								break;							case TIFF_DOUBLE:								*va_arg(ap, double*) =									*(double *)val;								ret_val = 1;								break;							default:								ret_val = 0;								break;							}						}
char *val = (char *)tv->value;
char *val = (char *)tv->value;
char
*val = (char *)tv->value
*
val
= (char *)tv->value
(char *)tv->value
char *
char
*
*
tv->value
tv
tv
value
assert( tv->count == 1 );
assert( tv->count == 1 )
assert
assert
tv->count == 1
tv->count
tv
tv
count
1
switch (fip->field_type) {							case TIFF_BYTE:							case TIFF_UNDEFINED:								*va_arg(ap, uint8*) =									*(uint8 *)val;								ret_val = 1;								break;							case TIFF_SBYTE:								*va_arg(ap, int8*) =									*(int8 *)val;								ret_val = 1;								break;							case TIFF_SHORT:								*va_arg(ap, uint16*) =									*(uint16 *)val;								ret_val = 1;								break;							case TIFF_SSHORT:								*va_arg(ap, int16*) =									*(int16 *)val;								ret_val = 1;								break;							case TIFF_LONG:							case TIFF_IFD:								*va_arg(ap, uint32*) =									*(uint32 *)val;								ret_val = 1;								break;							case TIFF_SLONG:								*va_arg(ap, int32*) =									*(int32 *)val;								ret_val = 1;								break;							case TIFF_LONG8:							case TIFF_IFD8:								*va_arg(ap, uint64*) =									*(uint64 *)val;								ret_val = 1;								break;							case TIFF_SLONG8:								*va_arg(ap, int64*) =									*(int64 *)val;								ret_val = 1;								break;							case TIFF_RATIONAL:							case TIFF_SRATIONAL:							case TIFF_FLOAT:								*va_arg(ap, float*) =									*(float *)val;								ret_val = 1;								break;							case TIFF_DOUBLE:								*va_arg(ap, double*) =									*(double *)val;								ret_val = 1;								break;							default:								ret_val = 0;								break;							}
fip->field_type
fip
fip
field_type
{							case TIFF_BYTE:							case TIFF_UNDEFINED:								*va_arg(ap, uint8*) =									*(uint8 *)val;								ret_val = 1;								break;							case TIFF_SBYTE:								*va_arg(ap, int8*) =									*(int8 *)val;								ret_val = 1;								break;							case TIFF_SHORT:								*va_arg(ap, uint16*) =									*(uint16 *)val;								ret_val = 1;								break;							case TIFF_SSHORT:								*va_arg(ap, int16*) =									*(int16 *)val;								ret_val = 1;								break;							case TIFF_LONG:							case TIFF_IFD:								*va_arg(ap, uint32*) =									*(uint32 *)val;								ret_val = 1;								break;							case TIFF_SLONG:								*va_arg(ap, int32*) =									*(int32 *)val;								ret_val = 1;								break;							case TIFF_LONG8:							case TIFF_IFD8:								*va_arg(ap, uint64*) =									*(uint64 *)val;								ret_val = 1;								break;							case TIFF_SLONG8:								*va_arg(ap, int64*) =									*(int64 *)val;								ret_val = 1;								break;							case TIFF_RATIONAL:							case TIFF_SRATIONAL:							case TIFF_FLOAT:								*va_arg(ap, float*) =									*(float *)val;								ret_val = 1;								break;							case TIFF_DOUBLE:								*va_arg(ap, double*) =									*(double *)val;								ret_val = 1;								break;							default:								ret_val = 0;								break;							}
case TIFF_BYTE:
TIFF_BYTE
TIFF_BYTE
case TIFF_UNDEFINED:
TIFF_UNDEFINED
TIFF_UNDEFINED
*va_arg(ap, uint8*) =									*(uint8 *)val;
ret_val = 1;
ret_val = 1
ret_val
ret_val
1
break;
case TIFF_SBYTE:
TIFF_SBYTE
TIFF_SBYTE
*va_arg(ap, int8*) =									*(int8 *)val;
ret_val = 1;
ret_val = 1
ret_val
ret_val
1
break;
case TIFF_SHORT:
TIFF_SHORT
TIFF_SHORT
*va_arg(ap, uint16*) =									*(uint16 *)val;
ret_val = 1;
ret_val = 1
ret_val
ret_val
1
break;
case TIFF_SSHORT:
TIFF_SSHORT
TIFF_SSHORT
*va_arg(ap, int16*) =									*(int16 *)val;
ret_val = 1;
ret_val = 1
ret_val
ret_val
1
break;
case TIFF_LONG:
TIFF_LONG
TIFF_LONG
case TIFF_IFD:
TIFF_IFD
TIFF_IFD
*va_arg(ap, uint32*) =									*(uint32 *)val;
ret_val = 1;
ret_val = 1
ret_val
ret_val
1
break;
case TIFF_SLONG:
TIFF_SLONG
TIFF_SLONG
*va_arg(ap, int32*) =									*(int32 *)val;
ret_val = 1;
ret_val = 1
ret_val
ret_val
1
break;
case TIFF_LONG8:
TIFF_LONG8
TIFF_LONG8
case TIFF_IFD8:
TIFF_IFD8
TIFF_IFD8
*va_arg(ap, uint64*) =									*(uint64 *)val;
ret_val = 1;
ret_val = 1
ret_val
ret_val
1
break;
case TIFF_SLONG8:
TIFF_SLONG8
TIFF_SLONG8
*va_arg(ap, int64*) =									*(int64 *)val;
ret_val = 1;
ret_val = 1
ret_val
ret_val
1
break;
case TIFF_RATIONAL:
TIFF_RATIONAL
TIFF_RATIONAL
case TIFF_SRATIONAL:
TIFF_SRATIONAL
TIFF_SRATIONAL
case TIFF_FLOAT:
TIFF_FLOAT
TIFF_FLOAT
*va_arg(ap, float*) =									*(float *)val;
ret_val = 1;
ret_val = 1
ret_val
ret_val
1
break;
case TIFF_DOUBLE:
TIFF_DOUBLE
TIFF_DOUBLE
*va_arg(ap, double*) =									*(double *)val;
ret_val = 1;
ret_val = 1
ret_val
ret_val
1
break;
default:
ret_val = 0;
ret_val = 0
ret_val
ret_val
0
break;
break;
return(ret_val);
(ret_val)
ret_val
ret_val
-----joern-----
(645,504,0)
(479,389,0)
(120,737,0)
(555,345,0)
(726,306,0)
(533,345,0)
(294,504,0)
(18,601,0)
(679,364,0)
(244,82,0)
(556,487,0)
(626,601,0)
(133,345,0)
(491,504,0)
(768,93,0)
(622,487,0)
(3,666,0)
(551,131,0)
(686,110,0)
(207,97,0)
(505,504,0)
(754,259,0)
(108,642,0)
(449,659,0)
(350,345,0)
(498,560,0)
(677,754,0)
(257,504,0)
(664,562,0)
(350,504,0)
(326,642,0)
(521,345,0)
(558,540,0)
(596,601,0)
(767,504,0)
(775,755,0)
(524,31,0)
(176,229,0)
(152,642,0)
(649,51,0)
(62,667,0)
(562,572,0)
(330,601,0)
(379,64,0)
(479,221,0)
(77,504,0)
(675,601,0)
(125,338,0)
(713,429,0)
(587,418,0)
(249,225,0)
(537,426,0)
(44,504,0)
(506,504,0)
(672,611,0)
(458,12,0)
(454,528,0)
(93,508,0)
(346,504,0)
(199,410,0)
(637,388,0)
(418,345,0)
(155,504,0)
(520,94,0)
(673,658,0)
(202,124,0)
(277,276,0)
(565,111,0)
(455,306,0)
(130,781,0)
(650,713,0)
(652,504,0)
(443,623,0)
(163,601,0)
(732,700,0)
(556,659,0)
(172,504,0)
(642,635,0)
(539,642,0)
(457,504,0)
(563,228,0)
(778,676,0)
(661,659,0)
(484,190,0)
(173,659,0)
(114,700,0)
(16,504,0)
(486,669,0)
(615,537,0)
(229,223,0)
(113,713,0)
(154,676,0)
(478,166,0)
(770,733,0)
(733,504,0)
(481,713,0)
(5,601,0)
(42,721,0)
(476,651,0)
(735,37,0)
(281,504,0)
(479,340,0)
(305,230,0)
(296,272,0)
(289,537,0)
(32,732,0)
(246,426,0)
(271,398,0)
(242,94,0)
(737,345,0)
(567,555,0)
(118,84,0)
(403,650,0)
(193,496,0)
(685,219,0)
(507,601,0)
(394,769,0)
(384,638,0)
(300,4,0)
(88,504,0)
(247,504,0)
(755,781,0)
(518,288,0)
(147,504,0)
(523,411,0)
(212,614,0)
(399,504,0)
(447,276,0)
(767,533,0)
(728,504,0)
(741,228,0)
(250,661,0)
(164,220,0)
(451,304,0)
(382,504,0)
(708,601,0)
(295,345,0)
(534,359,0)
(348,426,0)
(337,326,0)
(718,89,0)
(772,201,0)
(110,717,0)
(281,345,0)
(742,504,0)
(747,389,0)
(224,504,0)
(452,312,0)
(468,627,0)
(528,345,0)
(97,241,0)
(110,51,0)
(146,306,0)
(61,355,0)
(331,761,0)
(17,288,0)
(628,682,0)
(34,604,0)
(220,504,0)
(595,406,0)
(86,584,0)
(445,504,0)
(318,524,0)
(354,230,0)
(385,94,0)
(659,276,0)
(714,35,0)
(46,133,0)
(662,258,0)
(500,224,0)
(553,589,0)
(410,199,0)
(102,506,0)
(417,12,0)
(467,406,0)
(431,730,0)
(183,180,0)
(570,92,0)
(763,609,0)
(670,504,0)
(658,754,0)
(184,535,0)
(547,504,0)
(262,560,0)
(322,504,0)
(474,221,0)
(105,395,0)
(65,187,0)
(535,642,0)
(377,345,0)
(371,345,0)
(409,601,0)
(67,304,0)
(473,305,0)
(221,601,0)
(487,556,0)
(256,673,0)
(461,504,0)
(344,308,0)
(441,504,0)
(649,345,0)
(436,669,0)
(351,504,0)
(658,638,0)
(579,758,0)
(586,749,0)
(546,559,0)
(757,504,0)
(70,362,0)
(479,710,0)
(428,187,0)
(714,345,0)
(150,34,0)
(781,37,0)
(31,524,0)
(570,368,0)
(352,504,0)
(669,780,0)
(482,345,0)
(533,767,0)
(304,451,0)
(355,61,0)
(475,668,0)
(87,276,0)
(405,345,0)
(107,528,0)
(668,504,0)
(64,163,0)
(492,504,0)
(715,654,0)
(223,234,0)
(438,504,0)
(606,83,0)
(15,42,0)
(387,494,0)
(718,426,0)
(74,86,0)
(203,504,0)
(501,601,0)
(777,435,0)
(621,504,0)
(748,53,0)
(332,343,0)
(258,345,0)
(783,504,0)
(93,659,0)
(516,173,0)
(592,601,0)
(753,472,0)
(526,504,0)
(30,281,0)
(373,539,0)
(370,673,0)
(487,74,0)
(105,58,0)
(418,599,0)
(70,60,0)
(636,765,0)
(697,49,0)
(590,442,0)
(514,676,0)
(603,730,0)
(589,345,0)
(534,761,0)
(559,774,0)
(241,97,0)
(325,561,0)
(61,690,0)
(119,500,0)
(673,256,0)
(769,658,0)
(358,452,0)
(713,667,0)
(629,61,0)
(716,504,0)
(573,442,0)
(771,504,0)
(201,504,0)
(192,160,0)
(485,345,0)
(195,635,0)
(315,759,0)
(156,645,0)
(307,126,0)
(784,276,0)
(667,713,0)
(636,426,0)
(141,37,0)
(647,521,0)
(47,525,0)
(623,700,0)
(479,228,0)
(288,504,0)
(234,345,0)
(326,656,0)
(104,190,0)
(532,614,0)
(220,345,0)
(691,540,0)
(349,295,0)
(182,530,0)
(446,627,0)
(157,276,0)
(432,358,0)
(764,469,0)
(35,714,0)
(411,504,0)
(479,490,0)
(12,417,0)
(667,700,0)
(618,659,0)
(498,601,0)
(274,290,0)
(611,308,0)
(369,676,0)
(123,135,0)
(269,37,0)
(362,601,0)
(472,345,0)
(132,89,0)
(698,345,0)
(466,493,0)
(723,258,0)
(479,106,0)
(746,504,0)
(231,504,0)
(599,418,0)
(235,504,0)
(83,426,0)
(781,130,0)
(142,490,0)
(188,180,0)
(268,504,0)
(340,343,0)
(493,601,0)
(510,528,0)
(720,114,0)
(167,530,0)
(317,504,0)
(613,281,0)
(266,638,0)
(178,539,0)
(560,515,0)
(709,401,0)
(145,601,0)
(766,529,0)
(187,642,0)
(463,781,0)
(329,295,0)
(539,178,0)
(210,31,0)
(605,710,0)
(501,535,0)
(85,325,0)
(358,426,0)
(405,504,0)
(413,609,0)
(469,569,0)
(425,84,0)
(252,355,0)
(134,345,0)
(267,529,0)
(292,83,0)
(321,601,0)
(705,725,0)
(593,183,0)
(194,326,0)
(282,276,0)
(36,73,0)
(585,504,0)
(189,756,0)
(738,410,0)
(288,345,0)
(130,534,0)
(406,504,0)
(749,345,0)
(472,756,0)
(85,751,0)
(465,618,0)
(286,395,0)
(320,658,0)
(437,485,0)
(322,345,0)
(656,601,0)
(138,388,0)
(130,355,0)
(148,51,0)
(690,345,0)
(72,449,0)
(80,504,0)
(555,761,0)
(208,687,0)
(771,700,0)
(260,187,0)
(54,676,0)
(683,418,0)
(451,368,0)
(651,737,0)
(712,294,0)
(304,659,0)
(530,345,0)
(583,106,0)
(640,345,0)
(98,504,0)
(224,500,0)
(57,472,0)
(482,504,0)
(378,767,0)
(464,304,0)
(444,344,0)
(326,337,0)
(614,532,0)
(756,59,0)
(591,425,0)
(569,345,0)
(479,276,0)
(383,106,0)
(392,141,0)
(356,504,0)
(4,601,0)
(173,318,0)
(608,638,0)
(121,230,0)
(393,556,0)
(544,676,0)
(360,345,0)
(291,649,0)
(731,725,0)
(654,223,0)
(89,132,0)
(749,381,0)
(402,107,0)
(697,700,0)
(636,575,0)
(161,556,0)
(159,643,0)
(421,733,0)
(323,504,0)
(341,601,0)
(338,125,0)
(602,697,0)
(395,105,0)
(439,340,0)
(201,345,0)
(459,347,0)
(51,110,0)
(625,150,0)
(293,601,0)
(125,59,0)
(333,328,0)
(234,223,0)
(536,601,0)
(634,504,0)
(363,727,0)
(725,504,0)
(160,345,0)
(26,504,0)
(344,345,0)
(761,555,0)
(230,305,0)
(263,49,0)
(752,133,0)
(774,398,0)
(598,504,0)
(76,504,0)
(78,601,0)
(730,429,0)
(415,210,0)
(416,308,0)
(529,504,0)
(663,166,0)
(275,504,0)
(643,504,0)
(740,259,0)
(81,504,0)
(211,779,0)
(582,713,0)
(723,572,0)
(488,344,0)
(754,658,0)
(722,549,0)
(494,698,0)
(14,258,0)
(428,601,0)
(710,601,0)
(566,115,0)
(424,504,0)
(733,345,0)
(261,290,0)
(264,716,0)
(739,152,0)
(372,537,0)
(368,451,0)
(153,276,0)
(60,70,0)
(503,504,0)
(51,649,0)
(49,697,0)
(780,601,0)
(776,601,0)
(525,345,0)
(684,601,0)
(755,345,0)
(560,498,0)
(650,779,0)
(669,642,0)
(763,256,0)
(8,504,0)
(301,92,0)
(223,654,0)
(744,521,0)
(751,85,0)
(630,359,0)
(584,86,0)
(137,601,0)
(227,635,0)
(460,504,0)
(366,152,0)
(27,714,0)
(284,347,0)
(97,83,0)
(21,322,0)
(528,107,0)
(353,504,0)
(774,559,0)
(204,358,0)
(178,601,0)
(61,37,0)
(114,7,0)
(166,645,0)
(306,426,0)
(648,504,0)
(306,726,0)
(678,359,0)
(294,345,0)
(657,589,0)
(53,504,0)
(517,732,0)
(524,318,0)
(55,152,0)
(318,173,0)
(542,496,0)
(181,601,0)
(750,561,0)
(617,624,0)
(729,541,0)
(713,732,0)
(48,504,0)
(361,340,0)
(180,183,0)
(717,35,0)
(7,345,0)
(515,560,0)
(312,452,0)
(165,698,0)
(687,642,0)
(581,569,0)
(496,253,0)
(191,325,0)
(499,364,0)
(339,85,0)
(71,769,0)
(576,676,0)
(754,398,0)
(74,487,0)
(171,93,0)
(225,529,0)
(763,565,0)
(10,360,0)
(372,1,0)
(519,506,0)
(691,479,0)
(205,676,0)
(116,271,0)
(631,532,0)
(69,708,0)
(726,375,0)
(619,573,0)
(456,749,0)
(85,339,0)
(216,601,0)
(285,220,0)
(426,636,0)
(253,496,0)
(646,549,0)
(22,504,0)
(160,504,0)
(38,359,0)
(591,611,0)
(479,42,0)
(278,504,0)
(177,575,0)
(248,345,0)
(375,726,0)
(183,134,0)
(479,624,0)
(303,575,0)
(485,504,0)
(410,659,0)
(425,759,0)
(89,718,0)
(655,201,0)
(716,345,0)
(691,127,0)
(144,94,0)
(28,35,0)
(427,241,0)
(745,555,0)
(600,601,0)
(506,345,0)
(256,763,0)
(190,601,0)
(279,676,0)
(665,350,0)
(660,504,0)
(240,504,0)
(765,345,0)
(58,105,0)
(139,601,0)
(511,638,0)
(521,504,0)
(131,92,0)
(209,183,0)
(690,61,0)
(169,618,0)
(713,113,0)
(129,636,0)
(496,426,0)
(448,755,0)
(780,669,0)
(270,180,0)
(74,253,0)
(230,345,0)
(218,599,0)
(283,640,0)
(620,504,0)
(236,504,0)
(214,419,0)
(313,126,0)
(782,504,0)
(562,549,0)
(573,666,0)
(442,573,0)
(627,345,0)
(470,246,0)
(228,601,0)
(425,591,0)
(59,125,0)
(374,710,0)
(471,580,0)
(273,667,0)
(532,658,0)
(695,661,0)
(734,371,0)
(549,562,0)
(75,5,0)
(135,575,0)
(580,659,0)
(311,698,0)
(401,399,0)
(543,259,0)
(41,504,0)
(483,623,0)
(489,638,0)
(442,290,0)
(101,643,0)
(206,687,0)
(779,650,0)
(183,59,0)
(537,372,0)
(327,504,0)
(435,345,0)
(33,150,0)
(549,345,0)
(502,371,0)
(560,642,0)
(680,504,0)
(531,601,0)
(497,482,0)
(100,389,0)
(627,504,0)
(166,345,0)
(86,74,0)
(381,504,0)
(308,344,0)
(779,111,0)
(127,219,0)
(762,127,0)
(477,84,0)
(407,417,0)
(480,290,0)
(462,248,0)
(126,345,0)
(420,246,0)
(124,505,0)
(39,504,0)
(599,575,0)
(381,749,0)
(56,401,0)
(150,345,0)
(25,359,0)
(187,428,0)
(124,345,0)
(607,334,0)
(255,763,0)
(396,334,0)
(642,372,0)
(682,345,0)
(259,754,0)
(376,682,0)
(674,290,0)
(197,248,0)
(338,232,0)
(112,224,0)
(179,690,0)
(651,759,0)
(490,601,0)
(426,94,0)
(758,759,0)
(258,723,0)
(559,345,0)
(756,472,0)
(196,650,0)
(152,366,0)
(367,504,0)
(452,358,0)
(82,659,0)
(175,225,0)
(400,504,0)
(769,338,0)
(479,190,0)
(308,611,0)
(92,570,0)
(185,398,0)
(83,97,0)
(43,451,0)
(149,504,0)
(328,426,0)
(143,504,0)
(535,501,0)
(641,70,0)
(691,272,0)
(727,248,0)
(357,16,0)
(53,345,0)
(612,500,0)
(616,405,0)
(223,229,0)
(319,624,0)
(773,580,0)
(133,504,0)
(310,504,0)
(0,609,0)
(222,676,0)
(365,360,0)
(186,668,0)
(661,210,0)
(401,345,0)
(163,64,0)
(180,700,0)
(324,399,0)
(50,449,0)
(1,372,0)
(246,343,0)
(238,160,0)
(265,493,0)
(2,417,0)
(380,429,0)
(726,750,0)
(494,504,0)
(725,345,0)
(145,687,0)
(64,379,0)
(719,183,0)
(84,345,0)
(391,504,0)
(430,134,0)
(569,469,0)
(389,601,0)
(241,111,0)
(7,114,0)
(308,759,0)
(251,618,0)
(6,173,0)
(717,110,0)
(24,504,0)
(86,524,0)
(168,504,0)
(435,504,0)
(643,345,0)
(368,570,0)
(639,673,0)
(737,651,0)
(79,405,0)
(360,504,0)
(618,111,0)
(479,5,0)
(414,765,0)
(691,419,0)
(29,219,0)
(610,59,0)
(545,5,0)
(73,601,0)
(495,504,0)
(335,199,0)
(527,751,0)
(469,504,0)
(35,717,0)
(535,644,0)
(334,504,0)
(453,751,0)
(99,105,0)
(59,638,0)
(645,166,0)
(452,343,0)
(372,642,0)
(366,601,0)
(295,504,0)
(524,86,0)
(397,42,0)
(479,708,0)
(404,591,0)
(259,345,0)
(395,426,0)
(336,504,0)
(245,584,0)
(609,699,0)
(644,535,0)
(152,55,0)
(588,368,0)
(11,697,0)
(411,345,0)
(707,395,0)
(345,276,0)
(70,642,0)
(669,486,0)
(298,328,0)
(226,113,0)
(422,750,0)
(64,642,0)
(479,730,0)
(107,37,0)
(761,534,0)
(578,771,0)
(554,73,0)
(89,343,0)
(760,130,0)
(103,508,0)
(765,636,0)
(19,322,0)
(347,504,0)
(704,485,0)
(151,504,0)
(362,70,0)
(198,716,0)
(200,601,0)
(419,638,0)
(750,726,0)
(136,134,0)
(106,561,0)
(390,601,0)
(92,131,0)
(550,743,0)
(386,601,0)
(412,504,0)
(538,666,0)
(693,398,0)
(305,504,0)
(109,350,0)
(656,326,0)
(539,373,0)
(40,723,0)
(732,713,0)
(399,401,0)
(702,534,0)
(68,504,0)
(508,93,0)
(52,714,0)
(623,443,0)
(254,690,0)
(183,604,0)
(624,276,0)
(433,533,0)
(16,700,0)
(122,505,0)
(479,4,0)
(548,638,0)
(328,721,0)
(126,504,0)
(717,504,0)
(541,565,0)
(128,34,0)
(408,410,0)
(632,601,0)
(525,504,0)
(174,234,0)
(140,4,0)
(158,490,0)
(479,73,0)
(237,131,0)
(84,425,0)
(253,74,0)
(564,113,0)
(162,504,0)
(248,727,0)
(659,618,0)
(82,584,0)
(727,504,0)
(280,640,0)
(325,85,0)
(713,650,0)
(597,532,0)
(309,529,0)
(618,700,0)
(681,504,0)
(736,504,0)
(215,565,0)
(338,769,0)
(565,276,0)
(671,541,0)
(90,504,0)
(9,294,0)
(345,7,0)
(633,539,0)
(666,345,0)
(694,435,0)
(170,676,0)
(724,525,0)
(34,150,0)
(210,661,0)
(751,426,0)
(589,504,0)
(347,345,0)
(364,504,0)
(406,345,0)
(479,493,0)
(13,504,0)
(584,82,0)
(552,253,0)
(434,601,0)
(20,318,0)
(31,210,0)
(364,345,0)
(530,504,0)
(342,504,0)
(440,718,0)
(668,345,0)
(512,569,0)
(388,659,0)
(781,755,0)
(113,659,0)
(701,708,0)
(95,504,0)
(66,482,0)
(23,774,0)
(696,533,0)
(239,229,0)
(653,276,0)
(45,659,0)
(423,381,0)
(297,479,0)
(574,623,0)
(689,234,0)
(692,443,0)
(314,504,0)
(233,559,0)
(541,609,0)
(706,221,0)
(703,64,0)
(58,635,0)
(299,256,0)
(213,676,0)
(557,565,0)
(232,338,0)
(568,53,0)
(96,504,0)
(509,425,0)
(131,659,0)
(591,442,0)
(217,82,0)
(316,718,0)
(500,345,0)
(417,659,0)
(287,649,0)
(505,124,0)
(687,206,0)
(698,494,0)
(640,504,0)
(134,183,0)
(91,765,0)
(450,737,0)
(63,124,0)
(243,601,0)
(577,504,0)
(688,114,0)
(594,411,0)
(711,115,0)
(687,145,0)
(371,504,0)
(479,225,0)
(302,504,0)
(187,65,0)
(229,345,0)
(571,759,0)
(666,573,0)
(334,345,0)
(297,380,1)
(479,297,1)
(196,779,1)
(185,541,1)
(506,519,1)
(323,133,1)
(583,750,1)
(715,223,1)
(442,573,1)
(187,642,1)
(690,179,1)
(755,775,1)
(562,549,1)
(201,655,1)
(2,407,1)
(70,60,1)
(92,301,1)
(126,345,1)
(297,168,1)
(530,345,1)
(315,442,1)
(425,84,1)
(771,578,1)
(491,682,1)
(325,191,1)
(553,513,1)
(582,481,1)
(479,42,1)
(178,539,1)
(713,732,1)
(108,31,1)
(563,741,1)
(687,208,1)
(516,210,1)
(358,432,1)
(297,41,1)
(371,345,1)
(559,546,1)
(395,426,1)
(749,345,1)
(104,428,1)
(347,345,1)
(723,258,1)
(564,226,1)
(338,769,1)
(542,193,1)
(89,718,1)
(308,759,1)
(297,155,1)
(64,703,1)
(612,119,1)
(570,368,1)
(187,65,1)
(562,664,1)
(432,204,1)
(5,75,1)
(741,656,1)
(183,134,1)
(146,325,1)
(496,426,1)
(297,323,1)
(554,145,1)
(403,779,1)
(762,774,1)
(176,234,1)
(409,73,1)
(71,394,1)
(422,726,1)
(251,169,1)
(82,217,1)
(84,345,1)
(629,690,1)
(259,345,1)
(555,345,1)
(333,298,1)
(673,370,1)
(428,187,1)
(643,101,1)
(732,700,1)
(673,658,1)
(385,200,1)
(120,450,1)
(306,455,1)
(239,176,1)
(136,209,1)
(383,583,1)
(23,271,1)
(297,782,1)
(440,12,1)
(135,575,1)
(402,141,1)
(194,580,1)
(739,580,1)
(723,40,1)
(508,103,1)
(767,533,1)
(297,400,1)
(437,513,1)
(646,654,1)
(407,388,1)
(28,714,1)
(85,751,1)
(636,575,1)
(479,225,1)
(93,171,1)
(539,633,1)
(159,513,1)
(485,345,1)
(774,559,1)
(324,401,1)
(425,759,1)
(624,617,1)
(385,341,1)
(326,337,1)
(455,146,1)
(655,772,1)
(648,126,1)
(130,781,1)
(751,527,1)
(659,618,1)
(297,162,1)
(402,37,1)
(689,469,1)
(738,513,1)
(556,659,1)
(325,85,1)
(521,744,1)
(605,374,1)
(316,440,1)
(539,373,1)
(141,392,1)
(406,345,1)
(297,342,1)
(400,589,1)
(607,513,1)
(127,762,1)
(753,189,1)
(355,61,1)
(691,540,1)
(714,345,1)
(479,5,1)
(591,611,1)
(755,345,1)
(517,32,1)
(233,23,1)
(372,537,1)
(500,612,1)
(297,353,1)
(524,318,1)
(175,199,1)
(399,324,1)
(297,783,1)
(250,570,1)
(297,81,1)
(40,258,1)
(771,700,1)
(367,406,1)
(603,713,1)
(156,166,1)
(85,339,1)
(436,580,1)
(479,190,1)
(388,659,1)
(661,695,1)
(51,649,1)
(385,386,1)
(632,221,1)
(763,609,1)
(254,252,1)
(385,675,1)
(297,314,1)
(356,566,1)
(70,642,1)
(372,1,1)
(113,659,1)
(209,719,1)
(525,724,1)
(472,345,1)
(626,493,1)
(404,425,1)
(698,345,1)
(114,720,1)
(656,326,1)
(717,110,1)
(349,513,1)
(244,318,1)
(92,131,1)
(228,563,1)
(491,544,1)
(61,690,1)
(133,46,1)
(381,749,1)
(682,376,1)
(297,634,1)
(385,243,1)
(577,530,1)
(6,516,1)
(224,500,1)
(44,305,1)
(168,717,1)
(636,765,1)
(297,143,1)
(658,754,1)
(691,272,1)
(669,642,1)
(297,275,1)
(671,508,1)
(203,381,1)
(401,345,1)
(167,182,1)
(378,533,1)
(713,650,1)
(584,82,1)
(704,437,1)
(297,352,1)
(758,759,1)
(745,702,1)
(643,345,1)
(443,623,1)
(163,64,1)
(614,532,1)
(392,130,1)
(204,89,1)
(304,67,1)
(535,642,1)
(479,710,1)
(88,322,1)
(697,602,1)
(165,311,1)
(14,662,1)
(387,698,1)
(173,659,1)
(763,256,1)
(491,170,1)
(618,700,1)
(489,756,1)
(636,129,1)
(256,673,1)
(714,27,1)
(586,456,1)
(252,130,1)
(581,512,1)
(446,468,1)
(573,619,1)
(283,513,1)
(297,652,1)
(452,312,1)
(730,431,1)
(469,764,1)
(243,708,1)
(72,50,1)
(297,621,1)
(639,658,1)
(535,644,1)
(381,423,1)
(297,13,1)
(585,725,1)
(187,260,1)
(369,682,1)
(713,113,1)
(297,526,1)
(79,616,1)
(696,513,1)
(493,265,1)
(451,43,1)
(249,175,1)
(150,345,1)
(385,340,1)
(45,565,1)
(42,15,1)
(126,313,1)
(297,585,1)
(198,513,1)
(733,770,1)
(399,401,1)
(348,599,1)
(732,517,1)
(479,730,1)
(716,345,1)
(606,292,1)
(342,334,1)
(171,768,1)
(533,345,1)
(761,331,1)
(70,641,1)
(580,471,1)
(765,345,1)
(287,35,1)
(189,59,1)
(297,648,1)
(352,360,1)
(148,649,1)
(573,666,1)
(83,606,1)
(412,643,1)
(100,747,1)
(197,462,1)
(212,532,1)
(435,777,1)
(353,485,1)
(362,70,1)
(779,111,1)
(385,507,1)
(694,513,1)
(285,443,1)
(213,682,1)
(458,417,1)
(297,385,1)
(347,459,1)
(119,767,1)
(297,491,1)
(16,357,1)
(297,492,1)
(23,398,1)
(473,230,1)
(273,199,1)
(479,708,1)
(410,408,1)
(89,132,1)
(241,427,1)
(155,521,1)
(364,499,1)
(105,395,1)
(34,150,1)
(726,375,1)
(467,513,1)
(414,91,1)
(642,372,1)
(106,383,1)
(727,363,1)
(134,430,1)
(483,574,1)
(350,109,1)
(56,494,1)
(584,245,1)
(162,281,1)
(284,364,1)
(722,646,1)
(103,93,1)
(51,148,1)
(388,637,1)
(229,345,1)
(311,513,1)
(416,344,1)
(718,426,1)
(297,80,1)
(16,700,1)
(754,259,1)
(640,280,1)
(37,735,1)
(25,107,1)
(278,506,1)
(733,345,1)
(637,138,1)
(494,698,1)
(338,232,1)
(43,304,1)
(341,710,1)
(654,223,1)
(654,715,1)
(385,42,1)
(322,345,1)
(560,515,1)
(491,778,1)
(340,361,1)
(297,278,1)
(190,484,1)
(433,696,1)
(161,584,1)
(396,607,1)
(719,593,1)
(218,135,1)
(726,306,1)
(579,611,1)
(513,541,1)
(549,722,1)
(709,56,1)
(724,47,1)
(220,164,1)
(489,34,1)
(482,345,1)
(105,99,1)
(783,371,1)
(11,513,1)
(116,522,1)
(479,493,1)
(370,639,1)
(395,707,1)
(752,513,1)
(452,358,1)
(248,197,1)
(215,624,1)
(297,247,1)
(692,623,1)
(499,679,1)
(314,525,1)
(210,661,1)
(567,745,1)
(368,588,1)
(494,387,1)
(451,304,1)
(570,92,1)
(207,83,1)
(117,241,1)
(713,667,1)
(306,426,1)
(237,388,1)
(160,192,1)
(443,692,1)
(297,367,1)
(137,389,1)
(621,220,1)
(560,642,1)
(768,449,1)
(502,513,1)
(498,560,1)
(305,230,1)
(363,248,1)
(385,106,1)
(687,206,1)
(140,580,1)
(500,345,1)
(518,513,1)
(180,270,1)
(545,780,1)
(769,71,1)
(444,488,1)
(716,264,1)
(595,467,1)
(613,513,1)
(73,36,1)
(479,389,1)
(651,759,1)
(74,487,1)
(579,591,1)
(702,49,1)
(627,345,1)
(269,534,1)
(698,165,1)
(727,248,1)
(13,295,1)
(647,513,1)
(410,659,1)
(385,626,1)
(141,37,1)
(610,614,1)
(775,448,1)
(476,759,1)
(450,476,1)
(183,59,1)
(199,335,1)
(751,426,1)
(260,580,1)
(292,426,1)
(272,296,1)
(652,435,1)
(152,55,1)
(158,142,1)
(179,254,1)
(522,763,1)
(705,731,1)
(623,483,1)
(666,345,1)
(130,534,1)
(671,609,1)
(31,210,1)
(231,645,1)
(475,513,1)
(50,659,1)
(690,345,1)
(505,124,1)
(667,700,1)
(123,117,1)
(246,426,1)
(221,474,1)
(725,345,1)
(482,66,1)
(99,395,1)
(619,666,1)
(12,417,1)
(462,513,1)
(288,345,1)
(712,9,1)
(308,416,1)
(394,610,1)
(754,398,1)
(439,246,1)
(566,711,1)
(622,556,1)
(668,186,1)
(760,781,1)
(747,501,1)
(130,760,1)
(541,729,1)
(385,409,1)
(308,344,1)
(27,52,1)
(248,345,1)
(628,513,1)
(623,700,1)
(532,597,1)
(275,627,1)
(420,470,1)
(142,163,1)
(7,114,1)
(611,308,1)
(335,410,1)
(666,3,1)
(160,345,1)
(124,345,1)
(241,97,1)
(479,624,1)
(297,48,1)
(501,535,1)
(334,396,1)
(102,513,1)
(487,622,1)
(528,510,1)
(35,28,1)
(453,570,1)
(97,83,1)
(649,345,1)
(669,486,1)
(408,738,1)
(344,444,1)
(110,686,1)
(125,338,1)
(302,399,1)
(255,256,1)
(334,345,1)
(183,180,1)
(469,569,1)
(618,465,1)
(532,658,1)
(392,355,1)
(295,329,1)
(124,202,1)
(17,518,1)
(669,436,1)
(53,345,1)
(253,552,1)
(687,642,1)
(208,580,1)
(625,128,1)
(466,366,1)
(328,333,1)
(62,273,1)
(765,414,1)
(64,642,1)
(588,451,1)
(151,347,1)
(48,288,1)
(218,575,1)
(145,687,1)
(479,4,1)
(401,709,1)
(431,603,1)
(535,184,1)
(574,513,1)
(772,513,1)
(82,659,1)
(262,580,1)
(448,107,1)
(49,697,1)
(527,453,1)
(456,727,1)
(459,284,1)
(74,253,1)
(223,229,1)
(417,659,1)
(578,513,1)
(30,613,1)
(173,6,1)
(374,362,1)
(663,505,1)
(589,345,1)
(376,628,1)
(54,682,1)
(297,231,1)
(331,555,1)
(565,557,1)
(569,581,1)
(295,345,1)
(695,250,1)
(449,659,1)
(758,579,1)
(211,732,1)
(289,108,1)
(413,508,1)
(4,300,1)
(707,286,1)
(435,345,1)
(737,345,1)
(368,451,1)
(754,677,1)
(662,562,1)
(246,420,1)
(650,403,1)
(35,714,1)
(543,740,1)
(214,489,1)
(61,629,1)
(380,730,1)
(541,609,1)
(419,214,1)
(41,294,1)
(220,345,1)
(744,647,1)
(417,2,1)
(779,211,1)
(354,121,1)
(288,17,1)
(683,587,1)
(481,667,1)
(415,661,1)
(328,426,1)
(297,356,1)
(61,37,1)
(594,513,1)
(691,479,1)
(479,228,1)
(555,567,1)
(426,636,1)
(479,106,1)
(186,475,1)
(305,473,1)
(371,734,1)
(534,761,1)
(703,580,1)
(761,555,1)
(33,625,1)
(3,538,1)
(174,689,1)
(519,102,1)
(575,303,1)
(649,291,1)
(781,37,1)
(631,763,1)
(560,262,1)
(234,345,1)
(538,590,1)
(506,345,1)
(0,413,1)
(781,463,1)
(668,345,1)
(569,345,1)
(107,37,1)
(230,345,1)
(131,659,1)
(75,545,1)
(609,0,1)
(571,315,1)
(297,88,1)
(344,345,1)
(767,378,1)
(152,739,1)
(425,509,1)
(53,568,1)
(711,654,1)
(591,442,1)
(763,255,1)
(618,111,1)
(130,355,1)
(271,116,1)
(478,663,1)
(291,287,1)
(113,564,1)
(112,500,1)
(657,553,1)
(769,658,1)
(202,63,1)
(170,369,1)
(91,348,1)
(479,340,1)
(645,166,1)
(749,586,1)
(143,160,1)
(717,35,1)
(485,704,1)
(418,683,1)
(591,404,1)
(633,580,1)
(294,345,1)
(558,614,1)
(691,419,1)
(259,543,1)
(389,100,1)
(512,513,1)
(110,51,1)
(280,283,1)
(166,478,1)
(385,293,1)
(307,771,1)
(364,345,1)
(556,393,1)
(627,446,1)
(9,513,1)
(472,57,1)
(764,569,1)
(319,345,1)
(81,733,1)
(184,580,1)
(301,131,1)
(418,345,1)
(93,659,1)
(297,44,1)
(667,62,1)
(303,177,1)
(36,554,1)
(679,513,1)
(497,513,1)
(107,528,1)
(230,354,1)
(533,433,1)
(750,422,1)
(616,513,1)
(199,410,1)
(329,349,1)
(599,575,1)
(80,482,1)
(67,464,1)
(774,398,1)
(164,285,1)
(559,345,1)
(552,496,1)
(101,159,1)
(557,215,1)
(265,466,1)
(773,58,1)
(258,14,1)
(423,749,1)
(650,779,1)
(479,221,1)
(326,194,1)
(12,458,1)
(740,320,1)
(568,748,1)
(463,755,1)
(225,249,1)
(471,773,1)
(182,513,1)
(285,274,1)
(477,651,1)
(296,449,1)
(672,591,1)
(365,10,1)
(57,753,1)
(134,345,1)
(322,19,1)
(697,700,1)
(640,345,1)
(357,513,1)
(492,668,1)
(720,688,1)
(476,758,1)
(540,558,1)
(484,104,1)
(541,565,1)
(180,700,1)
(593,180,1)
(386,5,1)
(360,345,1)
(474,706,1)
(509,84,1)
(318,173,1)
(86,74,1)
(166,345,1)
(763,565,1)
(393,161,1)
(589,657,1)
(411,523,1)
(46,752,1)
(778,514,1)
(234,174,1)
(297,203,1)
(590,443,1)
(297,257,1)
(406,595,1)
(217,244,1)
(128,183,1)
(614,212,1)
(488,672,1)
(20,173,1)
(507,190,1)
(326,642,1)
(686,51,1)
(59,125,1)
(645,156,1)
(224,112,1)
(777,694,1)
(781,755,1)
(693,185,1)
(708,69,1)
(241,111,1)
(508,93,1)
(397,328,1)
(688,377,1)
(449,72,1)
(281,345,1)
(253,496,1)
(118,477,1)
(468,25,1)
(223,234,1)
(487,556,1)
(580,659,1)
(257,640,1)
(479,490,1)
(405,345,1)
(152,642,1)
(470,452,1)
(64,379,1)
(58,105,1)
(358,426,1)
(97,207,1)
(274,651,1)
(129,765,1)
(133,345,1)
(615,289,1)
(549,345,1)
(411,345,1)
(300,140,1)
(490,158,1)
(297,412,1)
(537,615,1)
(526,716,1)
(665,513,1)
(114,700,1)
(597,631,1)
(770,421,1)
(318,20,1)
(530,167,1)
(49,263,1)
(479,73,1)
(748,513,1)
(258,345,1)
(264,198,1)
(15,397,1)
(427,97,1)
(271,398,1)
(675,490,1)
(66,497,1)
(177,225,1)
(304,659,1)
(361,439,1)
(725,705,1)
(169,45,1)
(10,513,1)
(122,124,1)
(710,605,1)
(539,642,1)
(780,669,1)
(31,524,1)
(650,196,1)
(524,86,1)
(385,632,1)
(460,411,1)
(229,239,1)
(729,671,1)
(398,693,1)
(366,152,1)
(546,233,1)
(297,151,1)
(247,350,1)
(69,701,1)
(47,16,1)
(191,85,1)
(421,513,1)
(731,513,1)
(63,513,1)
(682,345,1)
(188,756,1)
(465,251,1)
(135,123,1)
(496,542,1)
(641,580,1)
(651,737,1)
(297,460,1)
(617,319,1)
(52,513,1)
(286,642,1)
(192,238,1)
(293,4,1)
(345,7,1)
(759,571,1)
(256,299,1)
(591,425,1)
(356,723,1)
(83,426,1)
(521,345,1)
(19,21,1)
(734,502,1)
(756,472,1)
(281,30,1)
(537,426,1)
(565,111,1)
(602,11,1)
(750,726,1)
(299,673,1)
(782,405,1)
(245,82,1)
(238,201,1)
(528,345,1)
(320,774,1)
(691,127,1)
(510,454,1)
(544,213,1)
(270,188,1)
(294,712,1)
(21,513,1)
(525,345,1)
(84,118,1)
(677,259,1)
(193,487,1)
(468,49,1)
(634,53,1)
(505,122,1)
(109,665,1)
(661,659,1)
(201,345,1)
(297,577,1)
(587,218,1)
(226,650,1)
(664,549,1)
(263,697,1)
(150,33,1)
(385,137,1)
(131,551,1)
(701,498,1)
(200,228,1)
(350,345,1)
(756,59,1)
(210,415,1)
(464,92,1)
(706,178,1)
(86,584,1)
(551,237,1)
(718,316,1)
(313,307,1)
(737,120,1)
(121,224,1)
(405,79,1)
(138,241,1)
(32,582,1)
(297,599,1)
(523,594,1)
(514,682,1)
(360,365,1)
(298,31,1)
(491,205,1)
(454,402,1)
(297,302,1)
(735,269,1)
(599,418,1)
(430,136,1)
(205,54,1)
(768,449,2)
(360,513,2)
(476,443,2)
(527,570,2)
(305,513,2)
(526,513,2)
(672,591,2)
(150,756,2)
(225,199,2)
(599,199,2)
(415,570,2)
(634,513,2)
(538,443,2)
(64,379,2)
(469,513,2)
(91,599,2)
(524,318,2)
(31,570,2)
(404,651,2)
(362,580,2)
(560,580,2)
(217,318,2)
(51,35,2)
(231,513,2)
(713,650,2)
(241,599,2)
(637,241,2)
(296,449,2)
(749,345,2)
(13,513,2)
(307,513,2)
(187,65,2)
(255,774,2)
(452,388,2)
(299,774,2)
(118,651,2)
(383,570,2)
(184,580,2)
(220,345,2)
(74,253,2)
(661,659,2)
(407,388,2)
(450,651,2)
(284,513,2)
(494,513,2)
(530,345,2)
(725,345,2)
(479,73,2)
(625,756,2)
(563,580,2)
(582,199,2)
(733,513,2)
(726,375,2)
(93,659,2)
(708,580,2)
(759,443,2)
(4,580,2)
(450,443,2)
(218,199,2)
(326,337,2)
(121,513,2)
(338,769,2)
(86,584,2)
(602,513,2)
(416,591,2)
(155,513,2)
(362,70,2)
(673,774,2)
(737,443,2)
(733,345,2)
(124,513,2)
(70,580,2)
(403,779,2)
(452,312,2)
(763,609,2)
(472,345,2)
(623,700,2)
(781,107,2)
(280,513,2)
(171,449,2)
(338,614,2)
(345,7,2)
(258,345,2)
(315,443,2)
(619,443,2)
(539,642,2)
(300,580,2)
(654,223,2)
(201,345,2)
(419,614,2)
(751,570,2)
(478,513,2)
(570,92,2)
(133,513,2)
(782,513,2)
(763,774,2)
(159,513,2)
(256,673,2)
(501,535,2)
(423,513,2)
(732,199,2)
(223,513,2)
(569,345,2)
(512,513,2)
(539,373,2)
(482,345,2)
(717,35,2)
(237,388,2)
(468,513,2)
(156,513,2)
(533,345,2)
(534,49,2)
(482,513,2)
(748,513,2)
(381,513,2)
(690,130,2)
(306,570,2)
(475,513,2)
(176,513,2)
(718,426,2)
(223,229,2)
(580,659,2)
(648,513,2)
(665,513,2)
(765,345,2)
(501,580,2)
(291,35,2)
(295,345,2)
(19,513,2)
(23,763,2)
(244,318,2)
(489,614,2)
(589,513,2)
(274,443,2)
(643,345,2)
(108,31,2)
(544,682,2)
(127,774,2)
(460,513,2)
(740,774,2)
(371,513,2)
(668,513,2)
(243,580,2)
(74,584,2)
(479,190,2)
(627,345,2)
(499,513,2)
(286,31,2)
(549,654,2)
(187,580,2)
(338,232,2)
(313,513,2)
(130,107,2)
(226,199,2)
(479,225,2)
(462,513,2)
(11,513,2)
(500,345,2)
(651,651,2)
(605,580,2)
(347,345,2)
(528,107,2)
(7,114,2)
(368,92,2)
(34,756,2)
(107,528,2)
(611,308,2)
(12,417,2)
(212,763,2)
(372,537,2)
(723,654,2)
(707,31,2)
(599,418,2)
(271,763,2)
(425,84,2)
(229,345,2)
(254,130,2)
(9,513,2)
(187,642,2)
(517,199,2)
(479,340,2)
(89,388,2)
(745,49,2)
(541,565,2)
(425,651,2)
(564,199,2)
(650,779,2)
(311,513,2)
(363,513,2)
(555,49,2)
(669,642,2)
(272,449,2)
(239,513,2)
(253,496,2)
(392,107,2)
(183,134,2)
(70,60,2)
(425,759,2)
(671,449,2)
(487,584,2)
(509,651,2)
(479,228,2)
(659,618,2)
(494,698,2)
(285,513,2)
(417,659,2)
(640,513,2)
(288,513,2)
(35,513,2)
(696,513,2)
(92,388,2)
(589,345,2)
(533,513,2)
(568,513,2)
(472,614,2)
(173,210,2)
(632,580,2)
(411,513,2)
(749,513,2)
(744,513,2)
(481,199,2)
(437,513,2)
(778,682,2)
(469,569,2)
(772,513,2)
(717,110,2)
(273,199,2)
(92,131,2)
(93,449,2)
(705,513,2)
(449,659,2)
(316,388,2)
(253,487,2)
(85,339,2)
(36,580,2)
(496,487,2)
(675,580,2)
(183,756,2)
(426,599,2)
(769,614,2)
(573,443,2)
(83,599,2)
(508,93,2)
(116,763,2)
(735,49,2)
(673,658,2)
(667,199,2)
(717,513,2)
(200,580,2)
(574,513,2)
(126,513,2)
(302,513,2)
(151,513,2)
(2,388,2)
(760,107,2)
(35,714,2)
(82,659,2)
(256,774,2)
(305,230,2)
(320,774,2)
(677,774,2)
(716,345,2)
(570,368,2)
(278,513,2)
(71,614,2)
(358,388,2)
(540,614,2)
(33,756,2)
(85,570,2)
(308,759,2)
(15,31,2)
(479,490,2)
(361,388,2)
(764,513,2)
(241,111,2)
(193,487,2)
(183,59,2)
(519,513,2)
(652,513,2)
(618,700,2)
(64,642,2)
(119,513,2)
(370,774,2)
(611,591,2)
(711,654,2)
(695,570,2)
(556,584,2)
(556,659,2)
(668,345,2)
(479,389,2)
(265,580,2)
(40,654,2)
(122,513,2)
(152,642,2)
(142,580,2)
(666,443,2)
(180,700,2)
(355,61,2)
(360,345,2)
(451,304,2)
(61,690,2)
(774,763,2)
(405,345,2)
(14,654,2)
(194,580,2)
(687,206,2)
(691,272,2)
(69,580,2)
(352,513,2)
(559,763,2)
(525,513,2)
(264,513,2)
(163,580,2)
(333,31,2)
(130,534,2)
(697,700,2)
(210,661,2)
(452,358,2)
(86,74,2)
(618,111,2)
(84,651,2)
(587,241,2)
(234,513,2)
(726,306,2)
(199,513,2)
(191,570,2)
(579,651,2)
(616,513,2)
(669,580,2)
(661,570,2)
(609,508,2)
(342,513,2)
(75,580,2)
(663,513,2)
(378,513,2)
(542,487,2)
(546,763,2)
(473,513,2)
(114,700,2)
(692,513,2)
(400,513,2)
(102,513,2)
(66,513,2)
(44,513,2)
(691,540,2)
(301,388,2)
(347,513,2)
(348,599,2)
(137,580,2)
(367,513,2)
(731,513,2)
(641,580,2)
(63,513,2)
(20,210,2)
(687,580,2)
(418,345,2)
(657,513,2)
(629,130,2)
(562,549,2)
(649,345,2)
(393,584,2)
(97,83,2)
(647,513,2)
(120,443,2)
(49,513,2)
(402,107,2)
(374,580,2)
(658,774,2)
(131,659,2)
(599,575,2)
(43,92,2)
(510,49,2)
(595,513,2)
(514,682,2)
(182,513,2)
(588,92,2)
(32,199,2)
(594,513,2)
(781,755,2)
(0,508,2)
(288,345,2)
(779,199,2)
(591,611,2)
(152,580,2)
(175,199,2)
(366,152,2)
(89,132,2)
(105,395,2)
(355,130,2)
(500,513,2)
(252,130,2)
(162,513,2)
(758,651,2)
(86,318,2)
(335,513,2)
(213,682,2)
(318,173,2)
(479,710,2)
(259,774,2)
(250,570,2)
(81,513,2)
(293,580,2)
(732,700,2)
(27,513,2)
(523,513,2)
(134,756,2)
(3,443,2)
(358,426,2)
(431,199,2)
(372,31,2)
(130,781,2)
(516,210,2)
(762,774,2)
(443,623,2)
(133,345,2)
(636,575,2)
(103,449,2)
(318,210,2)
(756,614,2)
(463,107,2)
(737,651,2)
(207,599,2)
(411,345,2)
(323,513,2)
(418,199,2)
(246,426,2)
(621,513,2)
(655,513,2)
(719,756,2)
(774,541,2)
(248,513,2)
(97,599,2)
(421,513,2)
(751,426,2)
(30,513,2)
(31,210,2)
(85,751,2)
(774,398,2)
(203,513,2)
(67,92,2)
(287,35,2)
(485,345,2)
(722,654,2)
(738,513,2)
(729,449,2)
(178,539,2)
(627,513,2)
(471,31,2)
(754,774,2)
(756,472,2)
(543,774,2)
(152,55,2)
(135,575,2)
(535,644,2)
(262,580,2)
(58,31,2)
(238,513,2)
(534,761,2)
(233,541,2)
(477,651,2)
(160,513,2)
(593,756,2)
(228,580,2)
(454,107,2)
(146,570,2)
(496,426,2)
(297,541,2)
(308,344,2)
(507,580,2)
(34,150,2)
(723,258,2)
(513,541,2)
(381,749,2)
(747,580,2)
(220,513,2)
(322,345,2)
(70,642,2)
(682,345,2)
(667,700,2)
(234,345,2)
(406,345,2)
(739,580,2)
(410,659,2)
(697,513,2)
(303,199,2)
(224,500,2)
(100,580,2)
(703,580,2)
(682,513,2)
(110,51,2)
(690,345,2)
(651,737,2)
(689,513,2)
(560,642,2)
(354,513,2)
(325,570,2)
(218,241,2)
(716,513,2)
(614,763,2)
(64,580,2)
(532,763,2)
(314,513,2)
(581,513,2)
(702,49,2)
(271,398,2)
(493,580,2)
(683,199,2)
(334,345,2)
(597,763,2)
(340,388,2)
(613,513,2)
(752,513,2)
(83,426,2)
(487,556,2)
(173,659,2)
(714,513,2)
(341,580,2)
(53,513,2)
(229,513,2)
(763,565,2)
(328,426,2)
(726,570,2)
(734,513,2)
(779,111,2)
(643,513,2)
(491,513,2)
(535,642,2)
(642,31,2)
(281,345,2)
(479,493,2)
(541,449,2)
(455,570,2)
(88,513,2)
(479,708,2)
(349,513,2)
(113,659,2)
(177,199,2)
(257,513,2)
(166,513,2)
(444,591,2)
(245,318,2)
(479,42,2)
(263,513,2)
(524,86,2)
(401,513,2)
(364,345,2)
(541,609,2)
(590,443,2)
(399,401,2)
(167,513,2)
(555,345,2)
(136,756,2)
(168,513,2)
(409,580,2)
(706,580,2)
(724,513,2)
(479,624,2)
(160,345,2)
(59,614,2)
(430,756,2)
(199,410,2)
(769,658,2)
(545,580,2)
(56,513,2)
(294,345,2)
(58,105,2)
(645,513,2)
(488,591,2)
(275,513,2)
(442,573,2)
(223,234,2)
(37,49,2)
(165,513,2)
(756,59,2)
(443,513,2)
(84,345,2)
(755,345,2)
(698,345,2)
(562,654,2)
(485,513,2)
(761,555,2)
(553,513,2)
(289,31,2)
(61,130,2)
(270,756,2)
(650,199,2)
(101,513,2)
(591,442,2)
(614,532,2)
(691,479,2)
(202,513,2)
(334,513,2)
(62,199,2)
(551,388,2)
(150,345,2)
(567,49,2)
(615,31,2)
(59,125,2)
(221,580,2)
(331,49,2)
(105,31,2)
(414,599,2)
(130,355,2)
(558,614,2)
(42,31,2)
(442,443,2)
(586,513,2)
(435,513,2)
(420,388,2)
(713,732,2)
(145,580,2)
(233,763,2)
(79,513,2)
(306,426,2)
(577,513,2)
(694,513,2)
(82,318,2)
(304,92,2)
(765,599,2)
(249,199,2)
(180,756,2)
(458,388,2)
(126,345,2)
(459,513,2)
(522,763,2)
(80,513,2)
(532,658,2)
(405,513,2)
(248,345,2)
(5,580,2)
(141,107,2)
(546,541,2)
(107,37,2)
(479,730,2)
(777,513,2)
(448,107,2)
(428,187,2)
(398,541,2)
(428,580,2)
(205,682,2)
(691,127,2)
(385,241,2)
(371,345,2)
(506,513,2)
(525,345,2)
(521,345,2)
(433,513,2)
(401,345,2)
(583,570,2)
(497,513,2)
(322,513,2)
(763,256,2)
(134,345,2)
(713,667,2)
(528,345,2)
(387,513,2)
(666,345,2)
(631,763,2)
(125,338,2)
(107,49,2)
(143,513,2)
(47,513,2)
(506,345,2)
(530,513,2)
(397,31,2)
(230,345,2)
(464,92,2)
(21,513,2)
(186,513,2)
(189,614,2)
(174,513,2)
(649,35,2)
(725,513,2)
(741,580,2)
(123,241,2)
(399,513,2)
(603,199,2)
(780,580,2)
(767,533,2)
(435,345,2)
(25,49,2)
(623,513,2)
(718,388,2)
(418,241,2)
(31,524,2)
(241,97,2)
(622,584,2)
(350,345,2)
(770,513,2)
(686,35,2)
(140,580,2)
(502,513,2)
(466,580,2)
(292,599,2)
(479,5,2)
(758,759,2)
(396,513,2)
(645,166,2)
(402,49,2)
(549,345,2)
(124,345,2)
(715,513,2)
(753,614,2)
(467,513,2)
(704,513,2)
(559,345,2)
(408,513,2)
(651,759,2)
(185,541,2)
(170,682,2)
(190,580,2)
(16,513,2)
(129,599,2)
(773,31,2)
(662,654,2)
(612,513,2)
(117,241,2)
(17,513,2)
(505,124,2)
(727,248,2)
(325,85,2)
(585,513,2)
(559,541,2)
(524,210,2)
(57,614,2)
(73,580,2)
(656,580,2)
(610,614,2)
(427,599,2)
(683,241,2)
(10,513,2)
(353,513,2)
(780,669,2)
(192,513,2)
(106,570,2)
(12,388,2)
(89,718,2)
(521,513,2)
(566,654,2)
(498,560,2)
(537,31,2)
(781,37,2)
(208,580,2)
(640,345,2)
(48,513,2)
(656,326,2)
(737,345,2)
(651,443,2)
(587,199,2)
(164,513,2)
(138,241,2)
(456,513,2)
(446,513,2)
(211,199,2)
(607,513,2)
(573,666,2)
(368,451,2)
(109,513,2)
(767,513,2)
(198,513,2)
(575,199,2)
(344,591,2)
(328,31,2)
(281,513,2)
(183,180,2)
(204,388,2)
(53,345,2)
(259,345,2)
(730,199,2)
(633,580,2)
(380,199,2)
(388,659,2)
(698,513,2)
(679,513,2)
(761,49,2)
(260,580,2)
(308,591,2)
(201,513,2)
(6,210,2)
(386,580,2)
(304,659,2)
(490,580,2)
(298,31,2)
(775,107,2)
(197,513,2)
(128,756,2)
(626,580,2)
(755,107,2)
(41,513,2)
(417,388,2)
(372,1,2)
(528,49,2)
(571,443,2)
(258,654,2)
(125,614,2)
(246,388,2)
(210,570,2)
(492,513,2)
(505,513,2)
(410,513,2)
(664,654,2)
(283,513,2)
(366,580,2)
(99,31,2)
(107,107,2)
(639,774,2)
(580,31,2)
(413,508,2)
(388,241,2)
(578,513,2)
(422,570,2)
(326,580,2)
(474,580,2)
(224,513,2)
(141,37,2)
(535,580,2)
(453,570,2)
(61,37,2)
(518,513,2)
(713,113,2)
(28,513,2)
(436,580,2)
(584,318,2)
(701,580,2)
(209,756,2)
(750,726,2)
(163,64,2)
(230,513,2)
(554,580,2)
(16,700,2)
(188,756,2)
(584,82,2)
(693,541,2)
(145,687,2)
(713,199,2)
(712,513,2)
(52,513,2)
(131,388,2)
(329,513,2)
(440,388,2)
(295,513,2)
(344,345,2)
(350,513,2)
(376,513,2)
(691,419,2)
(552,487,2)
(161,584,2)
(570,388,2)
(479,4,2)
(771,700,2)
(658,754,2)
(23,541,2)
(714,345,2)
(539,580,2)
(196,779,2)
(783,513,2)
(135,241,2)
(247,513,2)
(642,372,2)
(560,515,2)
(179,130,2)
(750,570,2)
(754,259,2)
(476,651,2)
(365,513,2)
(54,682,2)
(49,697,2)
(537,426,2)
(357,513,2)
(406,513,2)
(599,241,2)
(432,388,2)
(483,513,2)
(166,345,2)
(110,35,2)
(356,513,2)
(148,35,2)
(369,682,2)
(395,426,2)
(606,599,2)
(178,580,2)
(774,559,2)
(628,513,2)
(654,513,2)
(214,614,2)
(74,487,2)
(508,449,2)
(51,649,2)
(395,31,2)
(591,425,2)
(269,49,2)
(498,580,2)
(669,486,2)
(394,614,2)
(112,513,2)
(510,107,2)
(709,513,2)
(727,513,2)
(389,580,2)
(479,221,2)
(104,580,2)
(565,111,2)
(646,654,2)
(294,513,2)
(364,513,2)
(454,49,2)
(754,398,2)
(324,513,2)
(479,106,2)
(439,388,2)
(771,513,2)
(426,636,2)
(484,580,2)
(591,651,2)
(113,199,2)
(470,388,2)
(710,580,2)
(451,92,2)
(158,580,2)
(687,642,2)
(326,642,2)
(636,765,2)
(636,599,2)
(479,541,2)
(569,513,2)
(46,513,2)
(120,651,2)
(412,513,2)
-----------------------------------
(0,0)
(1,char *)
(2,field_readcount)
(3,td_smaxsamplevalue)
(4,ret_val = 0)
(5,ret_val = 1)
(6,field_readcount)
(7,&tif->tif_dir)
(8,case TIFFTAG_HALFTONEHINTS:)
(9,td)
(10,td)
(11,tif)
(12,fip->field_readcount == TIFF_VARIABLE2)
(13,break;)
(14,td_transferfunction)
(15,1)
(16,_TIFFFillStriles( tif )
(17,td_imagedepth)
(18,case TIFF_SHORT:)
(19,td_maxsamplevalue)
(20,TIFF_VARIABLE)
(21,td)
(22,case TIFFTAG_YCBCRPOSITIONING:)
(23,i)
(24,case TIFFTAG_XRESOLUTION:)
(25,v)
(26,case TIFFTAG_TILELENGTH:)
(27,td_extrasamples)
(28,1)
(29,for (i = 0; i < td->td_customValueCount; i++)
(30,td_imagelength)
(31,fip->field_type == TIFF_ASCII\n\\n\\t\\t\\t\\t\\t\\t    || fip->field_readcount == TIFF_VARIABLE\n\\n\\t\\t\\t\\t\\t\\t    || fip->field_readcount == TIFF_VARIABLE2\n\\n\\t\\t\\t\\t\\t\\t    || fip->field_readcount == TIFF_SPP\n\\n\\t\\t\\t\\t\\t\\t    || tv->count > 1)
(32,tif)
(33,td_samplesperpixel)
(34,val = td->td_samplesperpixel)
(35,td->td_extrasamples == 1)
(36,1)
(37,i=1)
(38,i)
(39,default:)
(40,2)
(41,break;)
(42,ret_val = 1)
(43,"DotRange")
(44,break;)
(45,fip)
(46,td_tilelength)
(47,td)
(48,break;)
(49,tif->tif_flags & TIFF_PERSAMPLE)
(50,fip)
(51,td->td_sampleinfo[0])
(52,td)
(53,td->td_inknames)
(54,DATATYPE_IEEEFP)
(55,uint8 *)
(56,td)
(57,td_samplesperpixel)
(58,assert( tv->count == 1 )
(59,val = *(uint16 *)
(60,uint64 *)
(61,td->td_sminsamplevalue[i])
(62,tif_clientdata)
(63,td)
(64,(int32 *)
(65,int16 *)
(66,td_imagewidth)
(67,field_name)
(68,case TIFFTAG_IMAGEDEPTH:)
(69,1)
(70,(uint64 *)
(71,value)
(72,NULL)
(73,ret_val = 1)
(74,fip->field_readcount == TIFF_SPP\n\\n\\t\\t\\t\\t\\t\\t    || tv->count > 1)
(75,1)
(76,case TIFFTAG_DATATYPE:)
(77,case TIFFTAG_STRIPOFFSETS:)
(78,case TIFF_IFD8:)
(79,td_planarconfig)
(80,break;)
(81,break;)
(82,fip->field_readcount)
(83,tv->info)
(84,td->td_smaxsamplevalue)
(85,(uint16 *)
(86,fip->field_readcount == TIFF_VARIABLE2\n\\n\\t\\t\\t\\t\\t\\t    || fip->field_readcount == TIFF_SPP\n\\n\\t\\t\\t\\t\\t\\t    || tv->count > 1)
(87,if( fip == NULL )
(88,break;)
(89,(uint32)
(90,case TIFFTAG_COMPRESSION:)
(91,td)
(92,fip->field_tag == TIFFTAG_DOTRANGE)
(93,fip->field_bit)
(94,)
(95,case TIFFTAG_SAMPLESPERPIXEL:)
(96,case TIFFTAG_ORIENTATION:)
(97,tv->info->field_tag)
(98,case TIFFTAG_RESOLUTIONUNIT:)
(99,1)
(100,1)
(101,td_bitspersample)
(102,td)
(103,FIELD_CUSTOM)
(104,ret_val)
(105,tv->count == 1)
(106,ret_val = 1)
(107,i < td->td_samplesperpixel)
(108,val)
(109,td_tilewidth)
(110,td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA)
(111,uint32 tag)
(112,1)
(113,fip->field_name)
(114,tif->tif_dir)
(115,)
(116,i)
(117,continue;)
(118,td_smaxsamplevalue)
(119,td)
(120,td_samplesperpixel)
(121,td)
(122,0)
(123,i)
(124,td->td_ycbcrsubsampling)
(125,*(uint16 *)
(126,td->td_stripbytecount)
(127,return 0;)
(128,val)
(129,i)
(130,td->td_sminsamplevalue[i] < v)
(131,fip->field_tag)
(132,uint32)
(133,td->td_tilelength)
(134,td->td_samplesperpixel)
(135,i++)
(136,td)
(137,break;)
(138,fip)
(139,case TIFF_RATIONAL:)
(140,ret_val)
(141,++i)
(142,ret_val)
(143,break;)
(144,if (fip->field_passcount)
(145,*(double *)
(146,tv)
(147,if (td->td_samplesperpixel - td->td_extrasamples > 1)
(148,0)
(149,case TIFFTAG_ROWSPERSTRIP:)
(150,td->td_samplesperpixel)
(151,break;)
(152,(uint8 *)
(153,if (fip->field_bit == FIELD_CUSTOM)
(154,case SAMPLEFORMAT_VOID:)
(155,break;)
(156,1)
(157,switch (standard_tag)
(158,1)
(159,td)
(160,td->td_sampleinfo)
(161,fip)
(162,break;)
(163,*(int32 *)
(164,td_smaxsamplevalue)
(165,td_halftonehints)
(166,td->td_ycbcrsubsampling)
(167,td_yresolution)
(168,break;)
(169,tif)
(170,break;)
(171,field_bit)
(172,case TIFFTAG_INKNAMES:)
(173,fip->field_readcount)
(174,td_samplesperpixel)
(175,ret_val)
(176,td)
(177,i)
(178,*(uint16 *)
(179,td_sminsamplevalue)
(180,tif->tif_clientdata)
(181,case TIFF_LONG8:)
(182,td)
(183,TIFFWarningExt(tif->tif_clientdata,"_TIFFVGetField",\n\\n                                   "Truncating NumberOfInks from %u to %u",\n\\n                                   val, td->td_samplesperpixel)
(184,val)
(185,i)
(186,td_sampleformat)
(187,(int16 *)
(188,tif)
(189,val)
(190,ret_val = 1)
(191,0)
(192,td_sampleinfo)
(193,tv)
(194,val)
(195,val)
(196,"")
(197,td_pagenumber)
(198,td)
(199,fip->field_bit != FIELD_CUSTOM)
(200,break;)
(201,td->td_extrasamples)
(202,td_ycbcrsubsampling)
(203,break;)
(204,tv)
(205,break;)
(206,double *)
(207,field_tag)
(208,val)
(209,val)
(210,fip->field_type == TIFF_ASCII)
(211,tag)
(212,NULL)
(213,DATATYPE_UINT)
(214,1)
(215,standard_tag)
(216,case TIFF_BYTE:)
(217,field_readcount)
(218,i)
(219,)
(220,td->td_smaxsamplevalue)
(221,ret_val = 1)
(222,case SAMPLEFORMAT_INT:)
(223,td->td_samplesperpixel - td->td_extrasamples)
(224,td->td_colormap[1])
(225,ret_val = 0)
(226,fip)
(227,switch (fip->field_type)
(228,ret_val = 1)
(229,td->td_extrasamples)
(230,td->td_colormap)
(231,break;)
(232,uint16 *)
(233,td)
(234,td->td_samplesperpixel)
(235,case TIFFTAG_TILEWIDTH:)
(236,case TIFFTAG_TRANSFERFUNCTION:)
(237,fip)
(238,td)
(239,td_extrasamples)
(240,case TIFFTAG_FILLORDER:)
(241,tv->info->field_tag != tag)
(242,tv)
(243,break;)
(244,fip)
(245,TIFF_VARIABLE2)
(246,tv->value)
(247,break;)
(248,td->td_pagenumber)
(249,0)
(250,fip)
(251,tag)
(252,v)
(253,tv->count > 1)
(254,td)
(255,standard_tag)
(256,tv->info->field_tag)
(257,break;)
(258,td->td_transferfunction)
(259,td->td_customValues)
(260,val)
(261,for (i=1; i < td->td_samplesperpixel; ++i)
(262,val)
(263,TIFF_PERSAMPLE)
(264,td_resolutionunit)
(265,1)
(266,val)
(267,if( fip->field_bit != FIELD_CUSTOM )
(268,case TIFFTAG_SAMPLEFORMAT:)
(269,i)
(270,tif_clientdata)
(271,i++)
(272,return 0;)
(273,tif)
(274,v)
(275,break;)
(276,)
(277,td)
(278,break;)
(279,case SAMPLEFORMAT_UINT:)
(280,td_xposition)
(281,td->td_imagelength)
(282,if( standard_tag == TIFFTAG_NUMBEROFINKS )
(283,td)
(284,td)
(285,td)
(286,tv)
(287,td)
(288,td->td_imagedepth)
(289,tv)
(290,)
(291,td_sampleinfo)
(292,tv)
(293,break;)
(294,td->td_tiledepth)
(295,td->td_samplesperpixel)
(296,0)
(297,ret_val)
(298,tv)
(299,field_tag)
(300,0)
(301,TIFFTAG_DOTRANGE)
(302,break;)
(303,0)
(304,fip->field_name)
(305,td->td_colormap[2])
(306,tv->value)
(307,td)
(308,td->td_smaxsamplevalue[i])
(309,i)
(310,case TIFFTAG_THRESHHOLDING:)
(311,td)
(312,uint16)
(313,td_stripbytecount)
(314,break;)
(315,i)
(316,count)
(317,case TIFFTAG_MINSAMPLEVALUE:)
(318,fip->field_readcount == TIFF_VARIABLE)
(319,ret_val)
(320,tv)
(321,default:)
(322,td->td_maxsamplevalue)
(323,break;)
(324,1)
(325,((uint16 *)
(326,(int64 *)
(327,case TIFFTAG_SMAXSAMPLEVALUE:)
(328,tv->value)
(329,td_samplesperpixel)
(330,case TIFF_SSHORT:)
(331,0)
(332,if (fip->field_readcount == TIFF_VARIABLE2)
(333,value)
(334,td->td_fillorder)
(335,FIELD_CUSTOM)
(336,case TIFFTAG_REFERENCEBLACKWHITE:)
(337,int64 *)
(338,(uint16 *)
(339,uint16 *)
(340,ret_val = 1)
(341,break;)
(342,break;)
(343,)
(344,td->td_smaxsamplevalue)
(345,* td = &tif->tif_dir)
(346,case TIFFTAG_SUBFILETYPE:)
(347,td->td_subifd)
(348,tv)
(349,td)
(350,td->td_tilewidth)
(351,case TIFFTAG_TILEOFFSETS:)
(352,break;)
(353,break;)
(354,td_colormap)
(355,v = td->td_sminsamplevalue[i])
(356,break;)
(357,tif)
(358,tv->count)
(359,)
(360,td->td_subfiletype)
(361,1)
(362,*(uint64 *)
(363,0)
(364,td->td_nsubifd)
(365,td_subfiletype)
(366,*(uint8 *)
(367,break;)
(368,strcmp(fip->field_name,"DotRange")
(369,DATATYPE_VOID)
(370,info)
(371,td->td_refblackwhite)
(372,(char *)
(373,uint16 *)
(374,ret_val)
(375,uint16 *)
(376,td_sampleformat)
(377,td)
(378,0)
(379,int32 *)
(380,break;)
(381,td->td_pagenumber[1])
(382,switch (td->td_sampleformat)
(383,1)
(384,tv)
(385,break;)
(386,break;)
(387,0)
(388,fip->field_passcount)
(389,ret_val = 1)
(390,case TIFF_FLOAT:)
(391,case TIFFTAG_YRESOLUTION:)
(392,i)
(393,field_readcount)
(394,tv)
(395,tv->count)
(396,td_fillorder)
(397,ret_val)
(398,i = 0)
(399,td->td_halftonehints[1])
(400,break;)
(401,td->td_halftonehints)
(402,i)
(403,"pseudo-")
(404,v)
(405,td->td_planarconfig)
(406,td->td_minsamplevalue)
(407,fip)
(408,field_bit)
(409,break;)
(410,fip->field_bit)
(411,td->td_threshholding)
(412,break;)
(413,standard_tag)
(414,td_customValues)
(415,TIFF_ASCII)
(416,i)
(417,fip->field_readcount)
(418,td->td_customValueCount)
(419,return 1;)
(420,value)
(421,td)
(422,1)
(423,1)
(424,case TIFFTAG_YPOSITION:)
(425,td->td_smaxsamplevalue[i])
(426,*tv = td->td_customValues + i)
(427,tag)
(428,*(int16 *)
(429,)
(430,td_samplesperpixel)
(431,0)
(432,count)
(433,td_colormap)
(434,case TIFF_IFD:)
(435,td->td_orientation)
(436,val)
(437,td)
(438,case TIFFTAG_BITSPERSAMPLE:)
(439,ret_val)
(440,tv)
(441,case TIFFTAG_YCBCRSUBSAMPLING:)
(442,v = td->td_smaxsamplevalue[0])
(443,tif->tif_flags & TIFF_PERSAMPLE)
(444,td_smaxsamplevalue)
(445,case TIFFTAG_SMINSAMPLEVALUE:)
(446,td_sminsamplevalue)
(447,standard_tag)
(448,td)
(449,fip == NULL)
(450,td)
(451,strcmp(fip->field_name,"DotRange")
(452,(uint16)
(453,tv)
(454,td)
(455,value)
(456,td)
(457,case TIFFTAG_TILEDEPTH:)
(458,TIFF_VARIABLE2)
(459,td_subifd)
(460,break;)
(461,case TIFFTAG_IMAGEWIDTH:)
(462,td)
(463,i)
(464,fip)
(465,TIFF_ANY)
(466,ret_val)
(467,td)
(468,td)
(469,td->td_transferfunction[0])
(470,tv)
(471,field_type)
(472,td->td_samplesperpixel)
(473,2)
(474,1)
(475,td)
(476,i)
(477,td)
(478,td_ycbcrsubsampling)
(479,return(ret_val)
(480,v)
(481,"_TIFFVGetField")
(482,td->td_imagewidth)
(483,tif_flags)
(484,1)
(485,td->td_xresolution)
(486,float *)
(487,fip->field_readcount == TIFF_SPP)
(488,td)
(489,val)
(490,ret_val = 1)
(491,break;)
(492,break;)
(493,ret_val = 1)
(494,td->td_halftonehints[0])
(495,case TIFFTAG_EXTRASAMPLES:)
(496,tv->count)
(497,td)
(498,*(uint32 *)
(499,td_nsubifd)
(500,td->td_colormap)
(501,*(int8 *)
(502,td)
(503,case TIFFTAG_STRIPBYTECOUNTS:)
(504,)
(505,td->td_ycbcrsubsampling[0])
(506,td->td_yposition)
(507,break;)
(508,fip->field_bit == FIELD_CUSTOM)
(509,i)
(510,td_samplesperpixel)
(511,if( tv->value == NULL )
(512,td)
(513,standard_tag)
(514,DATATYPE_INT)
(515,uint32 *)
(516,fip)
(517,tif_name)
(518,td)
(519,td_yposition)
(520,if (tv->info->field_tag != tag)
(521,td->td_ycbcrpositioning)
(522,continue;)
(523,td_threshholding)
(524,fip->field_readcount == TIFF_VARIABLE\n\\n\\t\\t\\t\\t\\t\\t    || fip->field_readcount == TIFF_VARIABLE2\n\\n\\t\\t\\t\\t\\t\\t    || fip->field_readcount == TIFF_SPP\n\\n\\t\\t\\t\\t\\t\\t    || tv->count > 1)
(525,td->td_stripoffset)
(526,break;)
(527,value)
(528,td->td_samplesperpixel)
(529,)
(530,td->td_yresolution)
(531,case TIFF_SBYTE:)
(532,tv->value)
(533,td->td_colormap)
(534,v = td->td_sminsamplevalue[0])
(535,(int8 *)
(536,case TIFF_DOUBLE:)
(537,tv->value)
(538,td)
(539,(uint16 *)
(540,return 0;)
(541,standard_tag == TIFFTAG_NUMBEROFINKS)
(542,count)
(543,td_customValues)
(544,break;)
(545,ret_val)
(546,td_customValueCount)
(547,if (tif->tif_flags & TIFF_PERSAMPLE)
(548,if (tv->info->field_tag != standard_tag)
(549,td->td_transferfunction)
(550,if (fip->field_type == TIFF_ASCII\n\\n\\t\\t\\t\\t\\t\\t    || fip->field_readcount == TIFF_VARIABLE\n\\n\\t\\t\\t\\t\\t\\t    || fip->field_readcount == TIFF_VARIABLE2\n\\n\\t\\t\\t\\t\\t\\t    || fip->field_readcount == TIFF_SPP\n\\n\\t\\t\\t\\t\\t\\t    || tv->count > 1)
(551,field_tag)
(552,1)
(553,td)
(554,ret_val)
(555,td->td_sminsamplevalue)
(556,fip->field_readcount)
(557,tag)
(558,0)
(559,td->td_customValueCount)
(560,(uint32 *)
(561,)
(562,td->td_transferfunction[1])
(563,1)
(564,field_name)
(565,standard_tag = tag)
(566,NULL)
(567,td_sminsamplevalue)
(568,td_inknames)
(569,td->td_transferfunction)
(570,fip->field_tag == TIFFTAG_DOTRANGE\n\\n\\t\\t\\t\\t\\t\\t   && strcmp(fip->field_name,"DotRange")
(571,1)
(572,)
(573,td->td_smaxsamplevalue[0])
(574,tif)
(575,i = 0)
(576,case SAMPLEFORMAT_IEEEFP:)
(577,break;)
(578,tif)
(579,i)
(580,fip->field_type)
(581,td_transferfunction)
(582,"%s: Invalid %stag \\"%s\\" "\n\\n\\t\\t\\t\\t\\t    "(not supported by codec)
(583,ret_val)
(584,fip->field_readcount == TIFF_VARIABLE2)
(585,break;)
(586,td_pagenumber)
(587,td)
(588,0)
(589,td->td_compression)
(590,v)
(591,td->td_smaxsamplevalue[i] > v)
(592,case TIFF_SRATIONAL:)
(593,"_TIFFVGetField")
(594,td)
(595,td_minsamplevalue)
(596,case TIFF_UNDEFINED:)
(597,value)
(598,case TIFFTAG_PHOTOMETRIC:)
(599,i < td->td_customValueCount)
(600,case TIFF_SLONG:)
(601,)
(602,tif_flags)
(603,ret_val)
(604,)
(605,1)
(606,info)
(607,td)
(608,if( val > td->td_samplesperpixel )
(609,standard_tag = 0)
(610,val)
(611,v = td->td_smaxsamplevalue[i])
(612,td_colormap)
(613,td)
(614,tv->value == NULL)
(615,value)
(616,td)
(617,1)
(618,TIFFFindField(tif, tag, TIFF_ANY)
(619,0)
(620,case TIFFTAG_PAGENUMBER:)
(621,break;)
(622,TIFF_SPP)
(623,tif->tif_flags)
(624,ret_val = 1)
(625,td)
(626,break;)
(627,td->td_sminsamplevalue)
(628,td)
(629,i)
(630,for (i=1; i < td->td_samplesperpixel; ++i)
(631,tv)
(632,break;)
(633,val)
(634,break;)
(635,)
(636,td->td_customValues + i)
(637,field_passcount)
(638,)
(639,tv)
(640,td->td_xposition)
(641,val)
(642,*val = (char *)
(643,td->td_bitspersample)
(644,int8 *)
(645,td->td_ycbcrsubsampling[1])
(646,td)
(647,td)
(648,break;)
(649,td->td_sampleinfo)
(650,isPseudoTag(tag)
(651,i < td->td_samplesperpixel)
(652,break;)
(653,fip)
(654,td->td_samplesperpixel - td->td_extrasamples > 1)
(655,td_extrasamples)
(656,*(int64 *)
(657,td_compression)
(658,*tv = td->td_customValues + i)
(659,* fip = TIFFFindField(tif, tag, TIFF_ANY)
(660,case TIFFTAG_MATTEING:)
(661,fip->field_type)
(662,td)
(663,td)
(664,1)
(665,td)
(666,td->td_smaxsamplevalue)
(667,tif->tif_clientdata)
(668,td->td_sampleformat)
(669,(float *)
(670,case TIFFTAG_COLORMAP:)
(671,standard_tag)
(672,v)
(673,tv->info)
(674,i)
(675,break;)
(676,)
(677,i)
(678,v)
(679,td)
(680,if (tif->tif_flags & TIFF_PERSAMPLE)
(681,case TIFFTAG_IMAGELENGTH:)
(682,td->td_sampleformat)
(683,td_customValueCount)
(684,case TIFF_SLONG8:)
(685,i)
(686,EXTRASAMPLE_ASSOCALPHA)
(687,(double *)
(688,tif)
(689,td)
(690,td->td_sminsamplevalue)
(691,RET)
(692,TIFF_PERSAMPLE)
(693,0)
(694,td)
(695,field_type)
(696,td)
(697,tif->tif_flags)
(698,td->td_halftonehints)
(699,)
(700,TIFF* tif)
(701,ret_val)
(702,v)
(703,val)
(704,td_xresolution)
(705,td_photometric)
(706,ret_val)
(707,count)
(708,ret_val = 1)
(709,td_halftonehints)
(710,ret_val = 1)
(711,NULL)
(712,td_tiledepth)
(713,TIFFErrorExt(tif->tif_clientdata, "_TIFFVGetField",\n\\n\\t\\t\\t\\t\\t    "%s: Invalid %stag \\"%s\\" "\n\\n\\t\\t\\t\\t\\t    "(not supported by codec)
(714,td->td_extrasamples)
(715,1)
(716,td->td_resolutionunit)
(717,td->td_extrasamples == 1 &&\n\\n\\t\\t\\t    td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA)
(718,tv->count)
(719,"Truncating NumberOfInks from %u to %u")
(720,tif_dir)
(721,)
(722,td_transferfunction)
(723,td->td_transferfunction[2])
(724,td_stripoffset)
(725,td->td_photometric)
(726,(uint16 *)
(727,td->td_pagenumber[0])
(728,case TIFFTAG_MAXSAMPLEVALUE:)
(729,TIFFTAG_NUMBEROFINKS)
(730,ret_val = 0)
(731,td)
(732,tif->tif_name)
(733,td->td_rowsperstrip)
(734,td_refblackwhite)
(735,1)
(736,case TIFFTAG_XPOSITION:)
(737,td->td_samplesperpixel)
(738,fip)
(739,val)
(740,td)
(741,ret_val)
(742,case TIFFTAG_SUBIFD:)
(743,)
(744,td_ycbcrpositioning)
(745,td)
(746,case TIFFTAG_PLANARCONFIG:)
(747,ret_val)
(748,td)
(749,td->td_pagenumber)
(750,((uint16 *)
(751,tv->value)
(752,td)
(753,td)
(754,td->td_customValues + i)
(755,td->td_sminsamplevalue)
(756,val > td->td_samplesperpixel)
(757,case TIFFTAG_TILEBYTECOUNTS:)
(758,++i)
(759,i=1)
(760,v)
(761,td->td_sminsamplevalue[0])
(762,0)
(763,tv->info->field_tag != standard_tag)
(764,0)
(765,td->td_customValues)
(766,for (i = 0; i < td->td_customValueCount; i++)
(767,td->td_colormap[0])
(768,fip)
(769,tv->value)
(770,td_rowsperstrip)
(771,_TIFFFillStriles( tif )
(772,td)
(773,fip)
(774,i < td->td_customValueCount)
(775,td_sminsamplevalue)
(776,case TIFF_LONG:)
(777,td_orientation)
(778,break;)
(779,isPseudoTag(tag)
(780,*(float *)
(781,td->td_sminsamplevalue[i])
(782,break;)
(783,break;)
(784,ret_val)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
