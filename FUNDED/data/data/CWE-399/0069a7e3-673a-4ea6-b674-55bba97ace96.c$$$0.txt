-----label-----
1
-----code-----
static int manage_bandwidth(struct fw_card *card, int irm_id, int generation,
			    int bandwidth, bool allocate, __be32 data[2])
{
	int try, new, old = allocate ? BANDWIDTH_AVAILABLE_INITIAL : 0;

	/*
	 * On a 1394a IRM with low contention, try < 1 is enough.
	 * On a 1394-1995 IRM, we need at least try < 2.
	 * Let's just do try < 5.
	 */
	for (try = 0; try < 5; try++) {
		new = allocate ? old - bandwidth : old + bandwidth;
		if (new < 0 || new > BANDWIDTH_AVAILABLE_INITIAL)
			break;

		data[0] = cpu_to_be32(old);
		data[1] = cpu_to_be32(new);
		switch (fw_run_transaction(card, TCODE_LOCK_COMPARE_SWAP,
				irm_id, generation, SCODE_100,
				CSR_REGISTER_BASE + CSR_BANDWIDTH_AVAILABLE,
				data, 8)) {
		case RCODE_GENERATION:
			/* A generation change frees all bandwidth. */
			return allocate ? -EAGAIN : bandwidth;

		case RCODE_COMPLETE:
			if (be32_to_cpup(data) == old)
				return bandwidth;

			old = be32_to_cpup(data);
			/* Fall through. */
		}
	}

	return -EIO;
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
3,7
3,8
3,9
3,10
5,6
5,7
6,7
8,9
8,10
11,12
11,13
13,14
15,16
15,17
17,18
19,20
19,21
21,22
23,24
23,25
25,26
27,28
27,29
28,29
30,31
30,32
32,33
34,35
34,36
34,37
34,38
34,39
35,36
36,37
37,38
38,39
39,40
40,41
41,42
-----nextToken-----
2,4,7,9,10,12,14,16,18,20,22,24,26,29,31,33,42
-----computeFrom-----
-----guardedBy-----
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;CompoundStatement;ProblemStatement;ProblemStatement;ProblemStatement;ProblemStatement;ReturnStatement;UnaryExpression;IdExpression;Name;
-----ast_node-----
static int manage_bandwidth(struct fw_card *card, int irm_id, int generation,			    int bandwidth, bool allocate, __be32 data[2]){	int try, new, old = allocate ? BANDWIDTH_AVAILABLE_INITIAL : 0;	/*	 * On a 1394a IRM with low contention, try < 1 is enough.	 * On a 1394-1995 IRM, we need at least try < 2.	 * Let's just do try < 5.	 */	for (try = 0; try < 5; try++) {		new = allocate ? old - bandwidth : old + bandwidth;		if (new < 0 || new > BANDWIDTH_AVAILABLE_INITIAL)			break;		data[0] = cpu_to_be32(old);		data[1] = cpu_to_be32(new);		switch (fw_run_transaction(card, TCODE_LOCK_COMPARE_SWAP,				irm_id, generation, SCODE_100,				CSR_REGISTER_BASE + CSR_BANDWIDTH_AVAILABLE,				data, 8)) {		case RCODE_GENERATION:			/* A generation change frees all bandwidth. */			return allocate ? -EAGAIN : bandwidth;		case RCODE_COMPLETE:			if (be32_to_cpup(data) == old)				return bandwidth;			old = be32_to_cpup(data);			/* Fall through. */		}	}	return -EIO;}
static int
manage_bandwidth(struct fw_card *card, int irm_id, int generation,			    int bandwidth, bool allocate, __be32 data[2])
manage_bandwidth
struct fw_card *card
struct fw_card
fw_card
*card
*
card
int irm_id
int
irm_id
irm_id
int generation
int
generation
generation
int bandwidth
int
bandwidth
bandwidth
bool allocate
bool
allocate
allocate
__be32 data[2]
__be32
__be32
data[2]
data
[2]
2
{	int try, new, old = allocate ? BANDWIDTH_AVAILABLE_INITIAL : 0;	/*	 * On a 1394a IRM with low contention, try < 1 is enough.	 * On a 1394-1995 IRM, we need at least try < 2.	 * Let's just do try < 5.	 */	for (try = 0; try < 5; try++) {		new = allocate ? old - bandwidth : old + bandwidth;		if (new < 0 || new > BANDWIDTH_AVAILABLE_INITIAL)			break;		data[0] = cpu_to_be32(old);		data[1] = cpu_to_be32(new);		switch (fw_run_transaction(card, TCODE_LOCK_COMPARE_SWAP,				irm_id, generation, SCODE_100,				CSR_REGISTER_BASE + CSR_BANDWIDTH_AVAILABLE,				data, 8)) {		case RCODE_GENERATION:			/* A generation change frees all bandwidth. */			return allocate ? -EAGAIN : bandwidth;		case RCODE_COMPLETE:			if (be32_to_cpup(data) == old)				return bandwidth;			old = be32_to_cpup(data);			/* Fall through. */		}	}	return -EIO;}
int try, new, old = allocate ? BANDWIDTH_AVAILABLE_INITIAL : 0;
for (try = 0;
try < 5;
try++) {		new = allocate ? old - bandwidth : old + bandwidth;		if (new < 0 || new > BANDWIDTH_AVAILABLE_INITIAL)			break;		data[0] = cpu_to_be32(old);		data[1] = cpu_to_be32(new);		switch (fw_run_transaction(card, TCODE_LOCK_COMPARE_SWAP,				irm_id, generation, SCODE_100,				CSR_REGISTER_BASE + CSR_BANDWIDTH_AVAILABLE,				data, 8)) {		case RCODE_GENERATION:			/* A generation change frees all bandwidth. */			return allocate ? -EAGAIN : bandwidth;		case RCODE_COMPLETE:			if (be32_to_cpup(data) == old)				return bandwidth;			old = be32_to_cpup(data);			/* Fall through. */		}	}
return -EIO;
-EIO
EIO
EIO
-----joern-----
(20,29,0)
(41,37,0)
(13,33,0)
(37,33,0)
(29,32,0)
(14,32,0)
(6,33,0)
(25,14,0)
(3,21,0)
(2,21,0)
(19,33,0)
(28,10,0)
(11,1,0)
(27,21,0)
(7,21,0)
(9,37,0)
(12,21,0)
(17,38,0)
(8,31,0)
(10,6,0)
(16,33,0)
(6,31,0)
(6,37,0)
(34,33,0)
(42,33,0)
(34,37,1)
(12,3,1)
(26,23,1)
(10,28,1)
(28,21,1)
(29,32,1)
(39,8,1)
(15,19,1)
(28,31,1)
(3,27,1)
(17,23,1)
(24,0,1)
(1,11,1)
(6,31,1)
(14,32,1)
(22,18,1)
(25,15,1)
(23,21,1)
(19,34,1)
(6,37,1)
(29,20,1)
(38,17,1)
(9,37,1)
(6,10,1)
(2,12,1)
(10,21,2)
(17,23,2)
(28,21,2)
(24,21,2)
(14,15,2)
(23,21,2)
(6,37,2)
(38,23,2)
(26,23,2)
(14,32,2)
(6,21,2)
(29,32,2)
(6,31,2)
(0,21,2)
(40,15,2)
(9,37,2)
(25,15,2)
(9,21,2)
-----------------------------------
(0,be32_to_cpup(data)
(1,cpu_to_be32(old)
(2,generation)
(3,TCODE_LOCK_COMPARE_SWAP)
(4,bool allocate)
(5,0)
(6,return -EIO;)
(7,data)
(8,old)
(9,return allocate ? -EAGAIN : bandwidth;)
(10,-EIO)
(11,old)
(12,irm_id)
(13,try)
(14,old - bandwidth)
(15,allocate)
(16,try)
(17,EAGAIN)
(18,CSR_REGISTER_BASE)
(19,5)
(20,bandwidth)
(21,fw_run_transaction(card, TCODE_LOCK_COMPARE_SWAP,\n\\n\\t\\t\\t\\tirm_id, generation, SCODE_100,\n\\n\\t\\t\\t\\tCSR_REGISTER_BASE + CSR_BANDWIDTH_AVAILABLE,\n\\n\\t\\t\\t\\tdata, 8)
(22,CSR_BANDWIDTH_AVAILABLE)
(23,allocate)
(24,old)
(25,old)
(26,bandwidth)
(27,card)
(28,EIO)
(29,return bandwidth;)
(30,0)
(31,old = be32_to_cpup(data)
(32,int bandwidth)
(33,)
(34,0)
(35,if (be32_to_cpup(data)
(36,break;)
(37,old = allocate ? BANDWIDTH_AVAILABLE_INITIAL : 0)
(38,-EAGAIN)
(39,data)
(40,bandwidth)
(41,old)
(42,try)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^