-----label-----
1
-----code-----
void
AtEOSubXact_SPI(bool isCommit, SubTransactionId mySubid)
{
	bool		found = false;

	while (_SPI_connected >= 0)
	{
		_SPI_connection *connection = &(_SPI_stack[_SPI_connected]);

		if (connection->connectSubid != mySubid)
			break;				/* couldn't be any underneath it either */

		found = true;

		/*
		 * Release procedure memory explicitly (see note in SPI_connect)
		 */
		if (connection->execCxt)
		{
			MemoryContextDelete(connection->execCxt);
			connection->execCxt = NULL;
		}
		if (connection->procCxt)
		{
			MemoryContextDelete(connection->procCxt);
			connection->procCxt = NULL;
		}

		/*
		 * Pop the stack entry and reset global variables.  Unlike
		 * SPI_finish(), we don't risk switching to memory contexts that might
		 * be already gone.
		 */
		_SPI_connected--;
		if (_SPI_connected < 0)
			_SPI_current = NULL;
		else
			_SPI_current = &(_SPI_stack[_SPI_connected]);
		SPI_processed = 0;
		SPI_lastoid = InvalidOid;
		SPI_tuptable = NULL;
	}

	if (found && isCommit)
		ereport(WARNING,
				(errcode(ERRCODE_WARNING),
				 errmsg("subtransaction left non-empty SPI stack"),
				 errhint("Check for missing \"SPI_finish\" calls.")));

	/*
	 * If we are aborting a subtransaction and there is an open SPI context
	 * surrounding the subxact, clean up to prevent memory leakage.
	 */
	if (_SPI_current && !isCommit)
	{
		slist_mutable_iter siter;

		/* free Executor memory the same as _SPI_end_call would do */
		MemoryContextResetAndDeleteChildren(_SPI_current->execCxt);

		/* throw away any tuple tables created within current subxact */
		slist_foreach_modify(siter, &_SPI_current->tuptables)
		{
			SPITupleTable *tuptable;

			tuptable = slist_container(SPITupleTable, next, siter.cur);
			if (tuptable->subid >= mySubid)
			{
				/*
				 * If we used SPI_freetuptable() here, its internal search of
				 * the tuptables list would make this operation O(N^2).
				 * Instead, just free the tuptable manually.  This should
				 * match what SPI_freetuptable() does.
				 */
				slist_delete_current(&siter);
				if (tuptable == _SPI_current->tuptable)
					_SPI_current->tuptable = NULL;
				if (tuptable == SPI_tuptable)
					SPI_tuptable = NULL;
				MemoryContextDelete(tuptable->tuptabcxt);
			}
		}
		/* in particular we should have gotten rid of any in-progress table */
		Assert(_SPI_current->tuptable == NULL);
	}
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
5,6
5,7
7,8
9,10
9,11
10,11
12,13
14,15
14,16
14,17
14,18
15,16
16,17
16,18
18,19
18,20
20,21
22,23
22,24
23,24
23,25
24,25
27,28
27,29
27,30
27,31
27,32
27,33
27,34
27,35
27,36
27,37
28,29
29,30
29,31
30,31
32,33
32,34
32,35
35,36
36,37
37,38
38,39
38,40
39,40
41,42
43,44
43,45
44,45
44,46
45,46
45,47
46,47
49,50
52,53
53,54
53,55
54,55
57,58
57,59
58,59
58,60
59,60
62,63
62,64
63,64
64,65
64,66
65,66
67,68
67,69
68,69
71,72
72,73
72,74
73,74
73,75
74,75
77,78
79,80
79,81
80,81
80,82
81,82
84,85
84,86
85,86
86,87
86,88
87,88
89,90
89,91
90,91
93,94
94,95
94,96
95,96
95,97
96,97
99,100
101,102
102,103
103,104
105,106
105,107
105,108
106,107
106,108
107,108
110,111
111,112
111,113
112,113
114,115
116,117
117,118
117,119
118,119
120,121
121,122
122,123
122,124
123,124
125,126
127,128
128,129
128,130
129,130
132,133
133,134
133,135
134,135
136,137
138,139
139,140
139,141
140,141
142,143
144,145
144,146
145,146
145,147
146,147
148,149
150,151
151,152
151,153
151,154
152,153
154,155
156,157
157,158
157,159
157,160
158,159
158,160
159,160
161,162
163,164
163,165
164,165
167,168
167,169
168,169
171,172
171,173
172,173
172,174
173,174
175,176
176,177
178,179
178,180
178,181
178,182
178,183
178,184
179,180
180,181
180,182
181,182
183,184
185,186
186,187
186,188
187,188
189,190
189,191
190,191
193,194
194,195
194,196
194,197
195,196
197,198
199,200
200,201
200,202
201,202
204,205
205,206
205,207
205,208
206,207
207,208
207,209
208,209
210,211
210,212
213,214
214,215
214,216
215,216
217,218
217,219
217,220
217,221
218,219
220,221
222,223
224,225
224,226
225,226
228,229
228,230
229,230
229,231
230,231
230,232
231,232
234,235
236,237
236,238
236,239
236,240
237,238
238,239
238,240
239,240
241,242
242,243
244,245
244,246
245,246
245,247
246,247
248,249
248,250
249,250
252,253
253,254
253,255
254,255
254,256
255,256
258,259
260,261
260,262
261,262
261,263
262,263
264,265
266,267
267,268
267,269
268,269
270,271
272,273
273,274
273,275
274,275
276,277
276,278
277,278
280,281
281,282
281,283
282,283
284,285
284,286
285,286
285,287
286,287
289,290
-----nextToken-----
2,4,6,8,11,13,17,19,21,25,26,31,33,34,40,42,47,48,50,51,55,56,60,61,66,69,70,75,76,78,82,83,88,91,92,97,98,100,104,108,109,113,115,119,124,126,130,131,135,137,141,143,147,149,153,155,160,162,165,166,169,170,174,177,182,184,188,191,192,196,198,202,203,209,211,212,216,219,221,223,226,227,232,233,235,240,243,247,250,251,256,257,259,263,265,269,271,275,278,279,283,287,288,290
-----computeFrom-----
23,24
23,25
44,45
44,46
53,54
53,55
72,73
72,74
94,95
94,96
106,107
106,108
111,112
111,113
117,118
117,119
128,129
128,130
133,134
133,135
139,140
139,141
145,146
145,147
172,173
172,174
214,215
214,216
229,230
229,231
245,246
245,247
253,254
253,255
261,262
261,263
267,268
267,269
284,285
284,286
-----guardedBy-----
174,287
232,278
250,256
251,257
265,269
-----guardedByNegation-----
108,126
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;WhileStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;UnaryExpression;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BreakStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;ExpressionList;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ProblemStatement;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;
-----ast_node-----
voidAtEOSubXact_SPI(bool isCommit, SubTransactionId mySubid){	bool		found = false;	while (_SPI_connected >= 0)	{		_SPI_connection *connection = &(_SPI_stack[_SPI_connected]);		if (connection->connectSubid != mySubid)			break;				/* couldn't be any underneath it either */		found = true;		/*		 * Release procedure memory explicitly (see note in SPI_connect)		 */		if (connection->execCxt)		{			MemoryContextDelete(connection->execCxt);			connection->execCxt = NULL;		}		if (connection->procCxt)		{			MemoryContextDelete(connection->procCxt);			connection->procCxt = NULL;		}		/*		 * Pop the stack entry and reset global variables.  Unlike		 * SPI_finish(), we don't risk switching to memory contexts that might		 * be already gone.		 */		_SPI_connected--;		if (_SPI_connected < 0)			_SPI_current = NULL;		else			_SPI_current = &(_SPI_stack[_SPI_connected]);		SPI_processed = 0;		SPI_lastoid = InvalidOid;		SPI_tuptable = NULL;	}	if (found && isCommit)		ereport(WARNING,				(errcode(ERRCODE_WARNING),				 errmsg("subtransaction left non-empty SPI stack"),				 errhint("Check for missing \"SPI_finish\" calls.")));	/*	 * If we are aborting a subtransaction and there is an open SPI context	 * surrounding the subxact, clean up to prevent memory leakage.	 */	if (_SPI_current && !isCommit)	{		slist_mutable_iter siter;		/* free Executor memory the same as _SPI_end_call would do */		MemoryContextResetAndDeleteChildren(_SPI_current->execCxt);		/* throw away any tuple tables created within current subxact */		slist_foreach_modify(siter, &_SPI_current->tuptables)		{			SPITupleTable *tuptable;			tuptable = slist_container(SPITupleTable, next, siter.cur);			if (tuptable->subid >= mySubid)			{				/*				 * If we used SPI_freetuptable() here, its internal search of				 * the tuptables list would make this operation O(N^2).				 * Instead, just free the tuptable manually.  This should				 * match what SPI_freetuptable() does.				 */				slist_delete_current(&siter);				if (tuptable == _SPI_current->tuptable)					_SPI_current->tuptable = NULL;				if (tuptable == SPI_tuptable)					SPI_tuptable = NULL;				MemoryContextDelete(tuptable->tuptabcxt);			}		}		/* in particular we should have gotten rid of any in-progress table */		Assert(_SPI_current->tuptable == NULL);	}}
void
AtEOSubXact_SPI(bool isCommit, SubTransactionId mySubid)
AtEOSubXact_SPI
bool isCommit
bool
isCommit
isCommit
SubTransactionId mySubid
SubTransactionId
SubTransactionId
mySubid
mySubid
{	bool		found = false;	while (_SPI_connected >= 0)	{		_SPI_connection *connection = &(_SPI_stack[_SPI_connected]);		if (connection->connectSubid != mySubid)			break;				/* couldn't be any underneath it either */		found = true;		/*		 * Release procedure memory explicitly (see note in SPI_connect)		 */		if (connection->execCxt)		{			MemoryContextDelete(connection->execCxt);			connection->execCxt = NULL;		}		if (connection->procCxt)		{			MemoryContextDelete(connection->procCxt);			connection->procCxt = NULL;		}		/*		 * Pop the stack entry and reset global variables.  Unlike		 * SPI_finish(), we don't risk switching to memory contexts that might		 * be already gone.		 */		_SPI_connected--;		if (_SPI_connected < 0)			_SPI_current = NULL;		else			_SPI_current = &(_SPI_stack[_SPI_connected]);		SPI_processed = 0;		SPI_lastoid = InvalidOid;		SPI_tuptable = NULL;	}	if (found && isCommit)		ereport(WARNING,				(errcode(ERRCODE_WARNING),				 errmsg("subtransaction left non-empty SPI stack"),				 errhint("Check for missing \"SPI_finish\" calls.")));	/*	 * If we are aborting a subtransaction and there is an open SPI context	 * surrounding the subxact, clean up to prevent memory leakage.	 */	if (_SPI_current && !isCommit)	{		slist_mutable_iter siter;		/* free Executor memory the same as _SPI_end_call would do */		MemoryContextResetAndDeleteChildren(_SPI_current->execCxt);		/* throw away any tuple tables created within current subxact */		slist_foreach_modify(siter, &_SPI_current->tuptables)		{			SPITupleTable *tuptable;			tuptable = slist_container(SPITupleTable, next, siter.cur);			if (tuptable->subid >= mySubid)			{				/*				 * If we used SPI_freetuptable() here, its internal search of				 * the tuptables list would make this operation O(N^2).				 * Instead, just free the tuptable manually.  This should				 * match what SPI_freetuptable() does.				 */				slist_delete_current(&siter);				if (tuptable == _SPI_current->tuptable)					_SPI_current->tuptable = NULL;				if (tuptable == SPI_tuptable)					SPI_tuptable = NULL;				MemoryContextDelete(tuptable->tuptabcxt);			}		}		/* in particular we should have gotten rid of any in-progress table */		Assert(_SPI_current->tuptable == NULL);	}}
bool		found = false;
bool		found = false;
bool
found = false
found
= false
false
while (_SPI_connected >= 0)	{		_SPI_connection *connection = &(_SPI_stack[_SPI_connected]);		if (connection->connectSubid != mySubid)			break;				/* couldn't be any underneath it either */		found = true;		/*		 * Release procedure memory explicitly (see note in SPI_connect)		 */		if (connection->execCxt)		{			MemoryContextDelete(connection->execCxt);			connection->execCxt = NULL;		}		if (connection->procCxt)		{			MemoryContextDelete(connection->procCxt);			connection->procCxt = NULL;		}		/*		 * Pop the stack entry and reset global variables.  Unlike		 * SPI_finish(), we don't risk switching to memory contexts that might		 * be already gone.		 */		_SPI_connected--;		if (_SPI_connected < 0)			_SPI_current = NULL;		else			_SPI_current = &(_SPI_stack[_SPI_connected]);		SPI_processed = 0;		SPI_lastoid = InvalidOid;		SPI_tuptable = NULL;	}
_SPI_connected >= 0
_SPI_connected
_SPI_connected
0
{		_SPI_connection *connection = &(_SPI_stack[_SPI_connected]);		if (connection->connectSubid != mySubid)			break;				/* couldn't be any underneath it either */		found = true;		/*		 * Release procedure memory explicitly (see note in SPI_connect)		 */		if (connection->execCxt)		{			MemoryContextDelete(connection->execCxt);			connection->execCxt = NULL;		}		if (connection->procCxt)		{			MemoryContextDelete(connection->procCxt);			connection->procCxt = NULL;		}		/*		 * Pop the stack entry and reset global variables.  Unlike		 * SPI_finish(), we don't risk switching to memory contexts that might		 * be already gone.		 */		_SPI_connected--;		if (_SPI_connected < 0)			_SPI_current = NULL;		else			_SPI_current = &(_SPI_stack[_SPI_connected]);		SPI_processed = 0;		SPI_lastoid = InvalidOid;		SPI_tuptable = NULL;	}
_SPI_connection *connection = &(_SPI_stack[_SPI_connected]);
_SPI_connection *connection = &(_SPI_stack[_SPI_connected]);
_SPI_connection
_SPI_connection
*connection = &(_SPI_stack[_SPI_connected])
*
connection
= &(_SPI_stack[_SPI_connected])
&(_SPI_stack[_SPI_connected])
(_SPI_stack[_SPI_connected])
_SPI_stack[_SPI_connected]
_SPI_stack
_SPI_stack
_SPI_connected
_SPI_connected
if (connection->connectSubid != mySubid)			break;
connection->connectSubid != mySubid
connection->connectSubid
connection
connection
connectSubid
mySubid
mySubid
break;
found = true;
found = true
found
found
true
if (connection->execCxt)		{			MemoryContextDelete(connection->execCxt);			connection->execCxt = NULL;		}
connection->execCxt
connection
connection
execCxt
{			MemoryContextDelete(connection->execCxt);			connection->execCxt = NULL;		}
MemoryContextDelete(connection->execCxt);
MemoryContextDelete(connection->execCxt)
MemoryContextDelete
MemoryContextDelete
connection->execCxt
connection
connection
execCxt
connection->execCxt = NULL;
connection->execCxt = NULL
connection->execCxt
connection
connection
execCxt
NULL
NULL
if (connection->procCxt)		{			MemoryContextDelete(connection->procCxt);			connection->procCxt = NULL;		}
connection->procCxt
connection
connection
procCxt
{			MemoryContextDelete(connection->procCxt);			connection->procCxt = NULL;		}
MemoryContextDelete(connection->procCxt);
MemoryContextDelete(connection->procCxt)
MemoryContextDelete
MemoryContextDelete
connection->procCxt
connection
connection
procCxt
connection->procCxt = NULL;
connection->procCxt = NULL
connection->procCxt
connection
connection
procCxt
NULL
NULL
_SPI_connected--;
_SPI_connected--
_SPI_connected
_SPI_connected
if (_SPI_connected < 0)			_SPI_current = NULL;		else			_SPI_current = &(_SPI_stack[_SPI_connected]);
_SPI_connected < 0
_SPI_connected
_SPI_connected
0
_SPI_current = NULL;
_SPI_current = NULL
_SPI_current
_SPI_current
NULL
NULL
_SPI_current = &(_SPI_stack[_SPI_connected]);
_SPI_current = &(_SPI_stack[_SPI_connected])
_SPI_current
_SPI_current
&(_SPI_stack[_SPI_connected])
(_SPI_stack[_SPI_connected])
_SPI_stack[_SPI_connected]
_SPI_stack
_SPI_stack
_SPI_connected
_SPI_connected
SPI_processed = 0;
SPI_processed = 0
SPI_processed
SPI_processed
0
SPI_lastoid = InvalidOid;
SPI_lastoid = InvalidOid
SPI_lastoid
SPI_lastoid
InvalidOid
InvalidOid
SPI_tuptable = NULL;
SPI_tuptable = NULL
SPI_tuptable
SPI_tuptable
NULL
NULL
if (found && isCommit)		ereport(WARNING,				(errcode(ERRCODE_WARNING),				 errmsg("subtransaction left non-empty SPI stack"),				 errhint("Check for missing \"SPI_finish\" calls.")));
found && isCommit
found
found
isCommit
isCommit
ereport(WARNING,				(errcode(ERRCODE_WARNING),				 errmsg("subtransaction left non-empty SPI stack"),				 errhint("Check for missing \"SPI_finish\" calls.")));
ereport(WARNING,				(errcode(ERRCODE_WARNING),				 errmsg("subtransaction left non-empty SPI stack"),				 errhint("Check for missing \"SPI_finish\" calls.")))
ereport
ereport
WARNING
WARNING
(errcode(ERRCODE_WARNING),				 errmsg("subtransaction left non-empty SPI stack"),				 errhint("Check for missing \"SPI_finish\" calls."))
errcode(ERRCODE_WARNING),				 errmsg("subtransaction left non-empty SPI stack"),				 errhint("Check for missing \"SPI_finish\" calls.")
errcode(ERRCODE_WARNING)
errcode
errcode
ERRCODE_WARNING
ERRCODE_WARNING
errmsg("subtransaction left non-empty SPI stack")
errmsg
errmsg
"subtransaction left non-empty SPI stack"
errhint("Check for missing \"SPI_finish\" calls.")
errhint
errhint
"Check for missing \"SPI_finish\" calls."
if (_SPI_current && !isCommit)	{		slist_mutable_iter siter;		/* free Executor memory the same as _SPI_end_call would do */		MemoryContextResetAndDeleteChildren(_SPI_current->execCxt);		/* throw away any tuple tables created within current subxact */		slist_foreach_modify(siter, &_SPI_current->tuptables)		{			SPITupleTable *tuptable;			tuptable = slist_container(SPITupleTable, next, siter.cur);			if (tuptable->subid >= mySubid)			{				/*				 * If we used SPI_freetuptable() here, its internal search of				 * the tuptables list would make this operation O(N^2).				 * Instead, just free the tuptable manually.  This should				 * match what SPI_freetuptable() does.				 */				slist_delete_current(&siter);				if (tuptable == _SPI_current->tuptable)					_SPI_current->tuptable = NULL;				if (tuptable == SPI_tuptable)					SPI_tuptable = NULL;				MemoryContextDelete(tuptable->tuptabcxt);			}		}		/* in particular we should have gotten rid of any in-progress table */		Assert(_SPI_current->tuptable == NULL);	}
_SPI_current && !isCommit
_SPI_current
_SPI_current
!isCommit
isCommit
isCommit
{		slist_mutable_iter siter;		/* free Executor memory the same as _SPI_end_call would do */		MemoryContextResetAndDeleteChildren(_SPI_current->execCxt);		/* throw away any tuple tables created within current subxact */		slist_foreach_modify(siter, &_SPI_current->tuptables)		{			SPITupleTable *tuptable;			tuptable = slist_container(SPITupleTable, next, siter.cur);			if (tuptable->subid >= mySubid)			{				/*				 * If we used SPI_freetuptable() here, its internal search of				 * the tuptables list would make this operation O(N^2).				 * Instead, just free the tuptable manually.  This should				 * match what SPI_freetuptable() does.				 */				slist_delete_current(&siter);				if (tuptable == _SPI_current->tuptable)					_SPI_current->tuptable = NULL;				if (tuptable == SPI_tuptable)					SPI_tuptable = NULL;				MemoryContextDelete(tuptable->tuptabcxt);			}		}		/* in particular we should have gotten rid of any in-progress table */		Assert(_SPI_current->tuptable == NULL);	}
slist_mutable_iter siter;
slist_mutable_iter siter;
slist_mutable_iter
slist_mutable_iter
siter
siter
MemoryContextResetAndDeleteChildren(_SPI_current->execCxt);
MemoryContextResetAndDeleteChildren(_SPI_current->execCxt)
MemoryContextResetAndDeleteChildren
MemoryContextResetAndDeleteChildren
_SPI_current->execCxt
_SPI_current
_SPI_current
execCxt
slist_foreach_modify(siter, &_SPI_current->tuptables)
slist_foreach_modify(siter, &_SPI_current->tuptables)
slist_foreach_modify
slist_foreach_modify
siter
siter
&_SPI_current->tuptables
_SPI_current->tuptables
_SPI_current
_SPI_current
tuptables
)
{			SPITupleTable *tuptable;			tuptable = slist_container(SPITupleTable, next, siter.cur);			if (tuptable->subid >= mySubid)			{				/*				 * If we used SPI_freetuptable() here, its internal search of				 * the tuptables list would make this operation O(N^2).				 * Instead, just free the tuptable manually.  This should				 * match what SPI_freetuptable() does.				 */				slist_delete_current(&siter);				if (tuptable == _SPI_current->tuptable)					_SPI_current->tuptable = NULL;				if (tuptable == SPI_tuptable)					SPI_tuptable = NULL;				MemoryContextDelete(tuptable->tuptabcxt);			}		}
SPITupleTable *tuptable;
SPITupleTable *tuptable;
SPITupleTable
SPITupleTable
*tuptable
*
tuptable
tuptable = slist_container(SPITupleTable, next, siter.cur);
tuptable = slist_container(SPITupleTable, next, siter.cur)
tuptable
tuptable
slist_container(SPITupleTable, next, siter.cur)
slist_container
slist_container
SPITupleTable
SPITupleTable
next
next
siter.cur
siter
siter
cur
if (tuptable->subid >= mySubid)			{				/*				 * If we used SPI_freetuptable() here, its internal search of				 * the tuptables list would make this operation O(N^2).				 * Instead, just free the tuptable manually.  This should				 * match what SPI_freetuptable() does.				 */				slist_delete_current(&siter);				if (tuptable == _SPI_current->tuptable)					_SPI_current->tuptable = NULL;				if (tuptable == SPI_tuptable)					SPI_tuptable = NULL;				MemoryContextDelete(tuptable->tuptabcxt);			}
tuptable->subid >= mySubid
tuptable->subid
tuptable
tuptable
subid
mySubid
mySubid
{				/*				 * If we used SPI_freetuptable() here, its internal search of				 * the tuptables list would make this operation O(N^2).				 * Instead, just free the tuptable manually.  This should				 * match what SPI_freetuptable() does.				 */				slist_delete_current(&siter);				if (tuptable == _SPI_current->tuptable)					_SPI_current->tuptable = NULL;				if (tuptable == SPI_tuptable)					SPI_tuptable = NULL;				MemoryContextDelete(tuptable->tuptabcxt);			}
slist_delete_current(&siter);
slist_delete_current(&siter)
slist_delete_current
slist_delete_current
&siter
siter
siter
if (tuptable == _SPI_current->tuptable)					_SPI_current->tuptable = NULL;
tuptable == _SPI_current->tuptable
tuptable
tuptable
_SPI_current->tuptable
_SPI_current
_SPI_current
tuptable
_SPI_current->tuptable = NULL;
_SPI_current->tuptable = NULL
_SPI_current->tuptable
_SPI_current
_SPI_current
tuptable
NULL
NULL
if (tuptable == SPI_tuptable)					SPI_tuptable = NULL;
tuptable == SPI_tuptable
tuptable
tuptable
SPI_tuptable
SPI_tuptable
SPI_tuptable = NULL;
SPI_tuptable = NULL
SPI_tuptable
SPI_tuptable
NULL
NULL
MemoryContextDelete(tuptable->tuptabcxt);
MemoryContextDelete(tuptable->tuptabcxt)
MemoryContextDelete
MemoryContextDelete
tuptable->tuptabcxt
tuptable
tuptable
tuptabcxt
Assert(_SPI_current->tuptable == NULL);
Assert(_SPI_current->tuptable == NULL)
Assert
Assert
_SPI_current->tuptable == NULL
_SPI_current->tuptable
_SPI_current
_SPI_current
tuptable
NULL
NULL
-----joern-----
(115,127,0)
(93,132,0)
(2,130,0)
(53,148,0)
(57,131,0)
(132,82,0)
(20,139,0)
(27,60,0)
(50,112,0)
(153,73,0)
(62,131,0)
(69,110,0)
(91,87,0)
(6,89,0)
(46,13,0)
(111,23,0)
(152,88,0)
(142,94,0)
(125,36,0)
(107,100,0)
(120,17,0)
(100,7,0)
(133,102,0)
(127,115,0)
(37,22,0)
(148,16,0)
(81,128,0)
(150,119,0)
(7,131,0)
(30,128,0)
(72,100,0)
(115,82,0)
(51,74,0)
(19,147,0)
(76,90,0)
(148,53,0)
(103,19,0)
(10,151,0)
(145,53,0)
(119,7,0)
(35,136,0)
(86,131,0)
(147,130,0)
(151,16,0)
(60,27,0)
(146,7,0)
(95,6,0)
(77,17,0)
(110,69,0)
(105,38,0)
(96,62,0)
(26,7,0)
(71,59,0)
(13,7,0)
(123,112,0)
(154,10,0)
(119,109,0)
(18,132,0)
(109,64,0)
(8,136,0)
(139,69,0)
(54,148,0)
(3,13,0)
(48,25,0)
(69,139,0)
(58,22,0)
(129,118,0)
(122,131,0)
(30,38,0)
(31,23,0)
(39,128,0)
(56,87,0)
(11,84,0)
(106,147,0)
(109,119,0)
(79,122,0)
(4,131,0)
(98,139,0)
(36,116,0)
(42,30,0)
(75,105,0)
(101,57,0)
(24,146,0)
(144,131,0)
(146,48,0)
(9,22,0)
(90,74,0)
(15,151,0)
(143,131,0)
(28,16,0)
(104,90,0)
(49,51,0)
(126,29,0)
(60,6,0)
(60,7,0)
(108,29,0)
(128,131,0)
(130,2,0)
(88,131,0)
(94,29,0)
(68,118,0)
(127,51,0)
(27,89,0)
(78,74,0)
(63,110,0)
(87,34,0)
(47,43,0)
(140,106,0)
(17,7,0)
(43,105,0)
(116,36,0)
(1,53,0)
(5,118,0)
(121,25,0)
(51,127,0)
(114,127,0)
(100,121,0)
(134,148,0)
(85,28,0)
(44,88,0)
(121,100,0)
(40,29,0)
(65,60,0)
(129,59,0)
(151,10,0)
(10,64,0)
(0,60,0)
(23,73,0)
(73,23,0)
(7,116,0)
(16,132,0)
(149,146,0)
(92,151,0)
(34,118,0)
(9,82,0)
(34,87,0)
(99,84,0)
(97,2,0)
(52,29,0)
(117,45,0)
(12,45,0)
(137,130,0)
(22,9,0)
(87,16,0)
(138,57,0)
(66,109,0)
(61,48,0)
(30,94,0)
(141,51,0)
(116,7,0)
(83,94,0)
(55,119,0)
(32,16,0)
(14,131,0)
(124,137,0)
(16,148,0)
(67,30,0)
(105,43,0)
(135,82,0)
(17,6,0)
(73,16,0)
(80,36,0)
(100,48,0)
(33,28,0)
(41,102,0)
(21,122,0)
(45,7,0)
(59,129,0)
(112,123,1)
(125,26,1)
(30,67,1)
(1,145,1)
(79,112,1)
(58,37,1)
(46,128,1)
(12,13,1)
(20,63,1)
(85,73,1)
(35,8,1)
(45,117,1)
(116,36,1)
(117,12,1)
(36,80,1)
(13,3,1)
(10,151,1)
(67,70,1)
(2,106,1)
(28,16,1)
(136,35,1)
(71,10,1)
(139,98,1)
(119,7,1)
(113,43,1)
(141,10,1)
(69,139,1)
(110,69,1)
(128,81,1)
(70,109,1)
(111,31,1)
(96,45,1)
(61,146,1)
(44,122,1)
(109,66,1)
(100,107,1)
(41,62,1)
(123,50,1)
(27,60,1)
(73,16,1)
(134,54,1)
(96,48,1)
(31,153,1)
(74,78,1)
(17,77,1)
(42,67,1)
(30,94,1)
(113,115,1)
(2,130,1)
(57,101,1)
(145,134,1)
(59,71,1)
(152,44,1)
(77,120,1)
(127,51,1)
(12,6,1)
(129,59,1)
(102,133,1)
(66,119,1)
(81,39,1)
(76,104,1)
(83,142,1)
(105,38,1)
(60,6,1)
(10,154,1)
(92,15,1)
(56,28,1)
(88,152,1)
(60,0,1)
(119,150,1)
(56,84,1)
(124,97,1)
(95,17,1)
(43,105,1)
(80,125,1)
(67,136,1)
(137,124,1)
(63,102,1)
(55,7,1)
(30,128,1)
(22,58,1)
(73,23,1)
(141,34,1)
(15,16,1)
(24,121,1)
(45,7,1)
(120,27,1)
(107,72,1)
(101,138,1)
(47,2,1)
(3,46,1)
(146,149,1)
(91,56,1)
(94,83,1)
(114,51,1)
(60,7,1)
(105,75,1)
(51,74,1)
(10,64,1)
(140,19,1)
(100,7,1)
(50,102,1)
(149,24,1)
(87,16,1)
(97,30,1)
(100,48,1)
(154,151,1)
(98,20,1)
(48,61,1)
(30,38,1)
(109,64,1)
(6,95,1)
(9,22,1)
(49,141,1)
(43,47,1)
(99,28,1)
(8,94,1)
(21,79,1)
(78,90,1)
(151,16,1)
(17,7,1)
(150,55,1)
(121,100,1)
(26,136,1)
(13,7,1)
(133,41,1)
(109,119,1)
(33,85,1)
(54,32,1)
(115,127,1)
(90,76,1)
(75,47,1)
(103,137,1)
(127,114,1)
(34,87,1)
(79,110,1)
(65,13,1)
(84,11,1)
(37,43,1)
(146,7,1)
(28,33,1)
(11,99,1)
(104,73,1)
(47,30,1)
(8,57,1)
(16,148,1)
(87,91,1)
(53,1,1)
(138,88,1)
(51,49,1)
(151,92,1)
(39,109,1)
(62,96,1)
(32,9,1)
(148,53,1)
(19,103,1)
(85,74,1)
(30,42,1)
(153,129,1)
(7,116,1)
(23,111,1)
(106,140,1)
(0,65,1)
(122,21,1)
(72,45,1)
(95,13,2)
(55,136,2)
(60,13,2)
(110,102,2)
(91,10,2)
(87,10,2)
(23,10,2)
(31,10,2)
(50,102,2)
(112,102,2)
(116,36,2)
(79,109,2)
(73,23,2)
(137,30,2)
(43,105,2)
(20,102,2)
(115,127,2)
(39,109,2)
(41,109,2)
(75,47,2)
(136,109,2)
(146,45,2)
(57,109,2)
(34,87,2)
(44,109,2)
(97,30,2)
(150,136,2)
(1,43,2)
(10,64,2)
(7,116,2)
(116,136,2)
(100,45,2)
(152,109,2)
(51,43,2)
(70,109,2)
(28,16,2)
(16,148,2)
(92,43,2)
(10,43,2)
(109,64,2)
(145,43,2)
(78,73,2)
(54,43,2)
(134,43,2)
(11,28,2)
(111,10,2)
(62,109,2)
(121,45,2)
(48,45,2)
(0,13,2)
(76,73,2)
(73,16,2)
(81,109,2)
(84,28,2)
(123,102,2)
(37,43,2)
(105,47,2)
(102,109,2)
(105,38,2)
(148,53,2)
(15,43,2)
(72,45,2)
(9,43,2)
(109,136,2)
(80,136,2)
(6,13,2)
(140,30,2)
(65,13,2)
(69,139,2)
(100,48,2)
(45,109,2)
(28,10,2)
(22,43,2)
(49,43,2)
(87,16,2)
(3,109,2)
(100,7,2)
(32,43,2)
(129,59,2)
(124,30,2)
(74,73,2)
(103,30,2)
(7,136,2)
(60,7,2)
(110,69,2)
(127,43,2)
(129,10,2)
(36,136,2)
(34,10,2)
(51,74,2)
(61,45,2)
(148,43,2)
(114,43,2)
(106,30,2)
(119,7,2)
(9,22,2)
(133,109,2)
(151,43,2)
(19,30,2)
(99,28,2)
(107,45,2)
(63,102,2)
(46,109,2)
(138,109,2)
(13,7,2)
(85,10,2)
(17,13,2)
(154,43,2)
(139,102,2)
(45,7,2)
(149,45,2)
(8,109,2)
(24,45,2)
(109,119,2)
(146,7,2)
(104,73,2)
(125,136,2)
(33,10,2)
(122,109,2)
(128,109,2)
(2,130,2)
(58,43,2)
(119,136,2)
(12,109,2)
(121,100,2)
(77,13,2)
(66,136,2)
(30,38,2)
(127,51,2)
(2,30,2)
(21,109,2)
(120,13,2)
(141,43,2)
(115,43,2)
(98,102,2)
(151,16,2)
(10,151,2)
(101,109,2)
(96,109,2)
(59,10,2)
(73,10,2)
(71,10,2)
(27,60,2)
(153,10,2)
(30,128,2)
(56,10,2)
(35,109,2)
(60,6,2)
(69,102,2)
(117,109,2)
(30,94,2)
(27,13,2)
(88,109,2)
(90,73,2)
(42,67,2)
(17,7,2)
(26,136,2)
(13,109,2)
(53,43,2)
(16,43,2)
-----------------------------------
(0,execCxt)
(1,cur)
(2,ereport(WARNING,\n\\n\\t\\t\\t\\t(errcode(ERRCODE_WARNING)
(3,execCxt)
(4,connection)
(5,if (tuptable == _SPI_current->tuptable)
(6,connection->execCxt = NULL)
(7,*connection = &(_SPI_stack[_SPI_connected])
(8,_SPI_connected)
(9,MemoryContextResetAndDeleteChildren(_SPI_current->execCxt)
(10,tuptable->subid >= mySubid)
(11,NULL)
(12,connection)
(13,connection->execCxt)
(14,if (connection->execCxt)
(15,tuptable)
(16,tuptable = slist_container(SPITupleTable, next, siter.cur)
(17,connection->execCxt)
(18,if (tuptable->subid >= mySubid)
(19,errmsg("subtransaction left non-empty SPI stack")
(20,_SPI_stack)
(21,0)
(22,_SPI_current->execCxt)
(23,_SPI_current->tuptable)
(24,connection)
(25,)
(26,connection)
(27,MemoryContextDelete(connection->execCxt)
(28,tuptable == SPI_tuptable)
(29,)
(30,found && isCommit)
(31,_SPI_current)
(32,tuptable)
(33,SPI_tuptable)
(34,MemoryContextDelete(tuptable->tuptabcxt)
(35,0)
(36,_SPI_stack[_SPI_connected])
(37,_SPI_current)
(38,bool isCommit)
(39,found)
(40,while (_SPI_connected >= 0)
(41,_SPI_connected)
(42,isCommit)
(43,_SPI_current && !isCommit)
(44,SPI_lastoid)
(45,connection->procCxt)
(46,connection)
(47,_SPI_current)
(48,connection->procCxt = NULL)
(49,tuptable)
(50,_SPI_current)
(51,_SPI_current->tuptable)
(52,if (_SPI_current && !isCommit)
(53,siter.cur)
(54,SPITupleTable)
(55,connection)
(56,tuptable)
(57,SPI_tuptable = NULL)
(58,execCxt)
(59,&siter)
(60,connection->execCxt)
(61,NULL)
(62,_SPI_connected--)
(63,_SPI_current)
(64,SubTransactionId mySubid)
(65,connection)
(66,mySubid)
(67,found)
(68,if (tuptable == SPI_tuptable)
(69,&(_SPI_stack[_SPI_connected])
(70,break;)
(71,siter)
(72,connection)
(73,tuptable == _SPI_current->tuptable)
(74,_SPI_current->tuptable = NULL)
(75,isCommit)
(76,tuptable)
(77,execCxt)
(78,NULL)
(79,SPI_processed)
(80,_SPI_connected)
(81,true)
(82,)
(83,false)
(84,SPI_tuptable = NULL)
(85,tuptable)
(86,if (connection->procCxt)
(87,tuptable->tuptabcxt)
(88,SPI_lastoid = InvalidOid)
(89,)
(90,_SPI_current->tuptable)
(91,tuptabcxt)
(92,subid)
(93,tuptable)
(94,found = false)
(95,NULL)
(96,_SPI_connected)
(97,WARNING)
(98,_SPI_connected)
(99,SPI_tuptable)
(100,connection->procCxt)
(101,NULL)
(102,_SPI_connected < 0)
(103,"subtransaction left non-empty SPI stack")
(104,_SPI_current)
(105,!isCommit)
(106,errhint("Check for missing \\"SPI_finish\\" calls.")
(107,procCxt)
(108,found)
(109,connection->connectSubid != mySubid)
(110,_SPI_current = &(_SPI_stack[_SPI_connected])
(111,tuptable)
(112,_SPI_current = NULL)
(113,RET)
(114,NULL)
(115,Assert(_SPI_current->tuptable == NULL)
(116,&(_SPI_stack[_SPI_connected])
(117,procCxt)
(118,)
(119,connection->connectSubid)
(120,connection)
(121,MemoryContextDelete(connection->procCxt)
(122,SPI_processed = 0)
(123,NULL)
(124,ERRCODE_WARNING)
(125,_SPI_stack)
(126,if (found && isCommit)
(127,_SPI_current->tuptable == NULL)
(128,found = true)
(129,slist_delete_current(&siter)
(130,)
(131,)
(132,)
(133,0)
(134,next)
(135,siter)
(136,_SPI_connected >= 0)
(137,errcode(ERRCODE_WARNING)
(138,SPI_tuptable)
(139,_SPI_stack[_SPI_connected])
(140,"Check for missing \\"SPI_finish\\" calls.")
(141,_SPI_current)
(142,found)
(143,if (connection->connectSubid != mySubid)
(144,if (_SPI_connected < 0)
(145,siter)
(146,connection->procCxt)
(147,)
(148,slist_container(SPITupleTable, next, siter.cur)
(149,procCxt)
(150,connectSubid)
(151,tuptable->subid)
(152,InvalidOid)
(153,tuptable)
(154,mySubid)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^