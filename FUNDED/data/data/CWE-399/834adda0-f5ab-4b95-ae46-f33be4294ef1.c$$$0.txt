-----label-----
0
-----code-----
static void dw_mci_tasklet_func(unsigned long priv)
{
	struct dw_mci *host = (struct dw_mci *)priv;
	struct mmc_data	*data;
	struct mmc_command *cmd;
	enum dw_mci_state state;
	enum dw_mci_state prev_state;
	u32 status, ctrl;

	spin_lock(&host->lock);

	state = host->state;
	data = host->data;

	do {
		prev_state = state;

		switch (state) {
		case STATE_IDLE:
			break;

		case STATE_SENDING_CMD:
			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,
						&host->pending_events))
				break;

			cmd = host->cmd;
			host->cmd = NULL;
			set_bit(EVENT_CMD_COMPLETE, &host->completed_events);
			dw_mci_command_complete(host, cmd);
			if (cmd == host->mrq->sbc && !cmd->error) {
				prev_state = state = STATE_SENDING_CMD;
				__dw_mci_start_request(host, host->cur_slot,
						       host->mrq->cmd);
				goto unlock;
			}

			if (!host->mrq->data || cmd->error) {
				dw_mci_request_end(host, host->mrq);
				goto unlock;
			}

			prev_state = state = STATE_SENDING_DATA;
			/* fall through */

		case STATE_SENDING_DATA:
			if (test_and_clear_bit(EVENT_DATA_ERROR,
					       &host->pending_events)) {
				dw_mci_stop_dma(host);
				if (data->stop)
					send_stop_cmd(host, data);
				state = STATE_DATA_ERROR;
				break;
			}

			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,
						&host->pending_events))
				break;

			set_bit(EVENT_XFER_COMPLETE, &host->completed_events);
			prev_state = state = STATE_DATA_BUSY;
			/* fall through */

		case STATE_DATA_BUSY:
			if (!test_and_clear_bit(EVENT_DATA_COMPLETE,
						&host->pending_events))
				break;

			host->data = NULL;
			set_bit(EVENT_DATA_COMPLETE, &host->completed_events);
			status = host->data_status;

			if (status & DW_MCI_DATA_ERROR_FLAGS) {
				if (status & SDMMC_INT_DTO) {
					data->error = -ETIMEDOUT;
				} else if (status & SDMMC_INT_DCRC) {
					data->error = -EILSEQ;
				} else if (status & SDMMC_INT_EBE &&
					   host->dir_status ==
							DW_MCI_SEND_STATUS) {
					/*
					 * No data CRC status was returned.
					 * The number of bytes transferred will
					 * be exaggerated in PIO mode.
					 */
					data->bytes_xfered = 0;
					data->error = -ETIMEDOUT;
				} else {
					dev_err(&host->dev,
						"data FIFO error "
						"(status=%08x)\n",
						status);
					data->error = -EIO;
				}
				/*
				 * After an error, there may be data lingering
				 * in the FIFO, so reset it - doing so
				 * generates a block interrupt, hence setting
				 * the scatter-gather pointer to NULL.
				 */
				sg_miter_stop(&host->sg_miter);
				host->sg = NULL;
				ctrl = mci_readl(host, CTRL);
				ctrl |= SDMMC_CTRL_FIFO_RESET;
				mci_writel(host, CTRL, ctrl);
			} else {
				data->bytes_xfered = data->blocks * data->blksz;
				data->error = 0;
			}

			if (!data->stop) {
				dw_mci_request_end(host, host->mrq);
				goto unlock;
			}

			if (host->mrq->sbc && !data->error) {
				data->stop->error = 0;
				dw_mci_request_end(host, host->mrq);
				goto unlock;
			}

			prev_state = state = STATE_SENDING_STOP;
			if (!data->error)
				send_stop_cmd(host, data);
			/* fall through */

		case STATE_SENDING_STOP:
			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,
						&host->pending_events))
				break;

			host->cmd = NULL;
			dw_mci_command_complete(host, host->mrq->stop);
			dw_mci_request_end(host, host->mrq);
			goto unlock;

		case STATE_DATA_ERROR:
			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,
						&host->pending_events))
				break;

			state = STATE_DATA_BUSY;
			break;
		}
	} while (state != prev_state);

	host->state = state;
unlock:
	spin_unlock(&host->lock);

}
-----children-----
1,2
1,3
1,4
3,4
3,5
5,6
5,7
7,8
9,10
9,11
9,12
9,13
9,14
9,15
9,16
9,17
9,18
9,19
9,20
9,21
10,11
11,12
11,13
12,13
14,15
14,16
14,17
17,18
18,19
18,20
19,20
19,21
20,21
22,23
24,25
26,27
27,28
27,29
28,29
30,31
30,32
33,34
34,35
34,36
35,36
37,38
37,39
40,41
41,42
41,43
42,43
44,45
46,47
47,48
47,49
48,49
50,51
52,53
53,54
53,55
53,56
54,55
56,57
58,59
60,61
61,62
61,63
62,63
64,65
65,66
65,67
66,67
69,70
70,71
70,72
71,72
73,74
73,75
74,75
77,78
78,79
78,80
79,80
81,82
81,83
82,83
85,86
85,87
86,87
86,88
87,88
88,89
88,90
89,90
91,92
93,94
93,95
94,95
96,97
96,98
96,99
96,100
96,101
96,102
96,103
96,104
96,105
96,106
96,107
96,108
96,109
96,110
96,111
96,112
96,113
96,114
96,115
96,116
96,117
96,118
96,119
96,120
96,121
96,122
96,123
96,124
96,125
96,126
96,127
96,128
96,129
96,130
96,131
96,132
97,98
98,99
101,102
102,103
104,105
104,106
105,106
106,107
106,108
106,109
107,108
109,110
111,112
112,113
112,114
113,114
117,118
118,119
118,120
119,120
121,122
121,123
122,123
125,126
126,127
126,128
127,128
127,129
128,129
131,132
133,134
134,135
134,136
134,137
135,136
137,138
139,140
140,141
140,142
141,142
144,145
145,146
145,147
145,148
146,147
148,149
150,151
152,153
152,154
153,154
153,155
154,155
154,156
155,156
157,158
157,159
158,159
158,160
159,160
163,164
164,165
164,166
165,166
168,169
168,170
168,171
169,170
170,171
170,172
171,172
173,174
173,175
174,175
176,177
178,179
179,180
179,181
179,182
179,183
180,181
182,183
184,185
184,186
185,186
188,189
188,190
189,190
189,191
190,191
194,195
196,197
196,198
197,198
197,199
198,199
199,200
199,201
200,201
200,202
201,202
205,206
205,207
206,207
209,210
209,211
210,211
211,212
211,213
211,214
212,213
214,215
216,217
216,218
217,218
220,221
222,223
223,224
223,225
224,225
226,227
226,228
227,228
229,230
231,232
232,233
234,235
234,236
235,236
235,237
235,238
236,237
238,239
240,241
241,242
241,243
242,243
245,246
245,247
245,248
245,249
246,247
247,248
247,249
248,249
250,251
252,253
252,254
253,254
253,255
254,255
257,258
258,259
258,260
258,261
259,260
261,262
263,264
265,266
266,267
266,268
267,268
269,270
272,273
272,274
273,274
274,275
274,276
274,277
275,276
277,278
279,280
280,281
280,282
281,282
285,286
286,287
286,288
286,289
287,288
289,290
291,292
292,293
292,294
293,294
296,297
297,298
297,299
298,299
300,301
300,302
301,302
303,304
305,306
306,307
308,309
308,310
309,310
310,311
310,312
310,313
311,312
313,314
315,316
316,317
316,318
317,318
321,322
322,323
322,324
323,324
323,325
324,325
327,328
329,330
330,331
330,332
330,333
331,332
333,334
335,336
336,337
336,338
337,338
340,341
341,342
341,343
342,343
344,345
344,346
345,346
348,349
348,350
348,351
349,350
349,351
350,351
352,353
354,355
354,356
354,357
354,358
354,359
354,360
355,356
355,357
355,358
356,357
356,358
357,358
359,360
361,362
362,363
363,364
363,365
364,365
364,366
365,366
368,369
369,370
371,372
371,373
371,374
372,373
372,374
373,374
375,376
377,378
378,379
379,380
379,381
380,381
380,382
381,382
384,385
385,386
387,388
387,389
387,390
388,389
388,390
389,390
389,391
390,391
392,393
394,395
394,396
395,396
395,397
396,397
399,400
401,402
401,403
402,403
403,404
403,405
404,405
404,406
405,406
409,410
410,411
410,412
411,412
411,413
412,413
415,416
416,417
418,419
418,420
419,420
420,421
420,422
420,423
420,424
421,422
423,424
424,425
424,426
425,426
429,430
431,432
432,433
432,434
433,434
433,435
434,435
437,438
438,439
440,441
441,442
441,443
442,443
444,445
445,446
445,447
446,447
449,450
450,451
450,452
451,452
451,453
452,453
455,456
457,458
458,459
458,460
459,460
461,462
461,463
461,464
462,463
464,465
466,467
468,469
469,470
469,471
470,471
472,473
474,475
475,476
475,477
475,478
475,479
476,477
478,479
480,481
482,483
484,485
484,486
485,486
486,487
486,488
487,488
487,489
488,489
491,492
491,493
492,493
492,494
493,494
496,497
496,498
497,498
500,501
501,502
501,503
502,503
502,504
503,504
507,508
507,509
508,509
509,510
509,511
510,511
513,514
513,515
514,515
515,516
515,517
515,518
516,517
518,519
520,521
520,522
521,522
524,525
526,527
526,528
527,528
527,529
528,529
528,530
529,530
529,531
530,531
534,535
535,536
535,537
536,537
539,540
539,541
539,542
540,541
541,542
541,543
542,543
542,544
543,544
543,545
544,545
549,550
550,551
550,552
550,553
551,552
553,554
555,556
555,557
556,557
559,560
561,562
562,563
562,564
563,564
565,566
565,567
566,567
568,569
570,571
570,572
571,572
572,573
572,574
573,574
576,577
577,578
577,579
577,580
578,579
580,581
582,583
584,585
585,586
587,588
587,589
588,589
589,590
589,591
589,592
590,591
592,593
594,595
595,596
595,597
596,597
600,601
601,602
601,603
602,603
602,604
603,604
606,607
608,609
609,610
609,611
609,612
610,611
612,613
614,615
614,616
615,616
615,617
616,617
620,621
621,622
621,623
621,624
622,623
624,625
626,627
626,628
627,628
630,631
632,633
633,634
635,636
635,637
636,637
637,638
637,639
637,640
638,639
640,641
642,643
643,644
643,645
644,645
648,649
649,650
649,651
650,651
652,653
655,656
655,657
656,657
658,659
660,661
661,662
661,663
662,663
662,664
663,664
666,667
668,669
668,670
670,671
671,672
671,673
672,673
674,675
675,676
675,677
676,677
-----nextToken-----
2,4,6,8,13,15,16,21,23,25,29,31,32,36,38,39,43,45,49,51,55,57,59,63,67,68,72,75,76,80,83,84,90,92,95,99,100,103,108,110,114,115,116,120,123,124,129,130,132,136,138,142,143,147,149,151,156,160,161,162,166,167,172,175,177,181,183,186,187,191,192,193,195,202,203,204,207,208,213,215,218,219,221,225,228,230,233,237,239,243,244,249,251,255,256,260,262,264,268,270,271,276,278,282,283,284,288,290,294,295,299,302,304,307,312,314,318,319,320,325,326,328,332,334,338,339,343,346,347,351,353,358,360,366,367,370,374,376,382,383,386,391,393,397,398,400,406,407,408,413,414,417,422,426,427,428,430,435,436,439,443,447,448,453,454,456,460,463,465,467,471,473,477,479,481,483,489,490,494,495,498,499,504,505,506,511,512,517,519,522,523,525,531,532,533,537,538,545,546,547,548,552,554,557,558,560,564,567,569,574,575,579,581,583,586,591,593,597,598,599,604,605,607,611,613,617,618,619,623,625,628,629,631,634,639,641,645,646,647,651,653,654,657,659,664,665,667,669,673,677,678
-----computeFrom-----
70,71
70,72
78,79
78,80
88,89
88,90
118,119
118,120
126,127
126,128
153,154
153,155
154,155
154,156
170,171
170,172
173,174
173,175
197,198
197,199
223,224
223,225
226,227
226,228
266,267
266,268
297,298
297,299
300,301
300,302
322,323
322,324
341,342
341,343
349,350
349,351
356,357
356,358
363,364
363,365
372,373
372,374
379,380
379,381
388,389
388,390
389,390
389,391
394,395
394,396
403,404
403,405
410,411
410,412
432,433
432,434
450,451
450,452
458,459
458,460
469,470
469,471
486,487
486,488
491,492
491,493
501,502
501,503
527,528
527,529
541,542
541,543
562,563
562,564
565,566
565,567
601,602
601,603
649,650
649,651
655,656
655,657
661,662
661,663
-----guardedBy-----
160,191
166,193
161,192
202,218
203,219
351,430
537,545
531,557
538,547
532,558
-----guardedByNegation-----
358,430
374,430
397,426
391,430
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;CastExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;Pointer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;DoStatement;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;SwitchStatement;IdExpression;Name;CompoundStatement;CaseStatement;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;BreakStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;GotoStatement;Name;IfStatement;BinaryExpression;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;GotoStatement;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;CaseStatement;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BreakStatement;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;BreakStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;CaseStatement;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;BreakStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IfStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;GotoStatement;Name;IfStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;GotoStatement;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CaseStatement;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;BreakStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;GotoStatement;Name;CaseStatement;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;BreakStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BreakStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;LabelStatement;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;
-----ast_node-----
static void dw_mci_tasklet_func(unsigned long priv){	struct dw_mci *host = (struct dw_mci *)priv;	struct mmc_data	*data;	struct mmc_command *cmd;	enum dw_mci_state state;	enum dw_mci_state prev_state;	u32 status, ctrl;	spin_lock(&host->lock);	state = host->state;	data = host->data;	do {		prev_state = state;		switch (state) {		case STATE_IDLE:			break;		case STATE_SENDING_CMD:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			cmd = host->cmd;			host->cmd = NULL;			set_bit(EVENT_CMD_COMPLETE, &host->completed_events);			dw_mci_command_complete(host, cmd);			if (cmd == host->mrq->sbc && !cmd->error) {				prev_state = state = STATE_SENDING_CMD;				__dw_mci_start_request(host, host->cur_slot,						       host->mrq->cmd);				goto unlock;			}			if (!host->mrq->data || cmd->error) {				dw_mci_request_end(host, host->mrq);				goto unlock;			}			prev_state = state = STATE_SENDING_DATA;			/* fall through */		case STATE_SENDING_DATA:			if (test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)) {				dw_mci_stop_dma(host);				if (data->stop)					send_stop_cmd(host, data);				state = STATE_DATA_ERROR;				break;			}			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events))				break;			set_bit(EVENT_XFER_COMPLETE, &host->completed_events);			prev_state = state = STATE_DATA_BUSY;			/* fall through */		case STATE_DATA_BUSY:			if (!test_and_clear_bit(EVENT_DATA_COMPLETE,						&host->pending_events))				break;			host->data = NULL;			set_bit(EVENT_DATA_COMPLETE, &host->completed_events);			status = host->data_status;			if (status & DW_MCI_DATA_ERROR_FLAGS) {				if (status & SDMMC_INT_DTO) {					data->error = -ETIMEDOUT;				} else if (status & SDMMC_INT_DCRC) {					data->error = -EILSEQ;				} else if (status & SDMMC_INT_EBE &&					   host->dir_status ==							DW_MCI_SEND_STATUS) {					/*					 * No data CRC status was returned.					 * The number of bytes transferred will					 * be exaggerated in PIO mode.					 */					data->bytes_xfered = 0;					data->error = -ETIMEDOUT;				} else {					dev_err(&host->dev,						"data FIFO error "						"(status=%08x)\n",						status);					data->error = -EIO;				}				/*				 * After an error, there may be data lingering				 * in the FIFO, so reset it - doing so				 * generates a block interrupt, hence setting				 * the scatter-gather pointer to NULL.				 */				sg_miter_stop(&host->sg_miter);				host->sg = NULL;				ctrl = mci_readl(host, CTRL);				ctrl |= SDMMC_CTRL_FIFO_RESET;				mci_writel(host, CTRL, ctrl);			} else {				data->bytes_xfered = data->blocks * data->blksz;				data->error = 0;			}			if (!data->stop) {				dw_mci_request_end(host, host->mrq);				goto unlock;			}			if (host->mrq->sbc && !data->error) {				data->stop->error = 0;				dw_mci_request_end(host, host->mrq);				goto unlock;			}			prev_state = state = STATE_SENDING_STOP;			if (!data->error)				send_stop_cmd(host, data);			/* fall through */		case STATE_SENDING_STOP:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			host->cmd = NULL;			dw_mci_command_complete(host, host->mrq->stop);			dw_mci_request_end(host, host->mrq);			goto unlock;		case STATE_DATA_ERROR:			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events))				break;			state = STATE_DATA_BUSY;			break;		}	} while (state != prev_state);	host->state = state;unlock:	spin_unlock(&host->lock);}
static void
dw_mci_tasklet_func(unsigned long priv)
dw_mci_tasklet_func
unsigned long priv
unsigned long
priv
priv
{	struct dw_mci *host = (struct dw_mci *)priv;	struct mmc_data	*data;	struct mmc_command *cmd;	enum dw_mci_state state;	enum dw_mci_state prev_state;	u32 status, ctrl;	spin_lock(&host->lock);	state = host->state;	data = host->data;	do {		prev_state = state;		switch (state) {		case STATE_IDLE:			break;		case STATE_SENDING_CMD:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			cmd = host->cmd;			host->cmd = NULL;			set_bit(EVENT_CMD_COMPLETE, &host->completed_events);			dw_mci_command_complete(host, cmd);			if (cmd == host->mrq->sbc && !cmd->error) {				prev_state = state = STATE_SENDING_CMD;				__dw_mci_start_request(host, host->cur_slot,						       host->mrq->cmd);				goto unlock;			}			if (!host->mrq->data || cmd->error) {				dw_mci_request_end(host, host->mrq);				goto unlock;			}			prev_state = state = STATE_SENDING_DATA;			/* fall through */		case STATE_SENDING_DATA:			if (test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)) {				dw_mci_stop_dma(host);				if (data->stop)					send_stop_cmd(host, data);				state = STATE_DATA_ERROR;				break;			}			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events))				break;			set_bit(EVENT_XFER_COMPLETE, &host->completed_events);			prev_state = state = STATE_DATA_BUSY;			/* fall through */		case STATE_DATA_BUSY:			if (!test_and_clear_bit(EVENT_DATA_COMPLETE,						&host->pending_events))				break;			host->data = NULL;			set_bit(EVENT_DATA_COMPLETE, &host->completed_events);			status = host->data_status;			if (status & DW_MCI_DATA_ERROR_FLAGS) {				if (status & SDMMC_INT_DTO) {					data->error = -ETIMEDOUT;				} else if (status & SDMMC_INT_DCRC) {					data->error = -EILSEQ;				} else if (status & SDMMC_INT_EBE &&					   host->dir_status ==							DW_MCI_SEND_STATUS) {					/*					 * No data CRC status was returned.					 * The number of bytes transferred will					 * be exaggerated in PIO mode.					 */					data->bytes_xfered = 0;					data->error = -ETIMEDOUT;				} else {					dev_err(&host->dev,						"data FIFO error "						"(status=%08x)\n",						status);					data->error = -EIO;				}				/*				 * After an error, there may be data lingering				 * in the FIFO, so reset it - doing so				 * generates a block interrupt, hence setting				 * the scatter-gather pointer to NULL.				 */				sg_miter_stop(&host->sg_miter);				host->sg = NULL;				ctrl = mci_readl(host, CTRL);				ctrl |= SDMMC_CTRL_FIFO_RESET;				mci_writel(host, CTRL, ctrl);			} else {				data->bytes_xfered = data->blocks * data->blksz;				data->error = 0;			}			if (!data->stop) {				dw_mci_request_end(host, host->mrq);				goto unlock;			}			if (host->mrq->sbc && !data->error) {				data->stop->error = 0;				dw_mci_request_end(host, host->mrq);				goto unlock;			}			prev_state = state = STATE_SENDING_STOP;			if (!data->error)				send_stop_cmd(host, data);			/* fall through */		case STATE_SENDING_STOP:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			host->cmd = NULL;			dw_mci_command_complete(host, host->mrq->stop);			dw_mci_request_end(host, host->mrq);			goto unlock;		case STATE_DATA_ERROR:			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events))				break;			state = STATE_DATA_BUSY;			break;		}	} while (state != prev_state);	host->state = state;unlock:	spin_unlock(&host->lock);}
struct dw_mci *host = (struct dw_mci *)priv;
struct dw_mci *host = (struct dw_mci *)priv;
struct dw_mci
dw_mci
*host = (struct dw_mci *)priv
*
host
= (struct dw_mci *)priv
(struct dw_mci *)priv
struct dw_mci *
struct dw_mci
dw_mci
*
*
priv
priv
struct mmc_data	*data;
struct mmc_data	*data;
struct mmc_data
mmc_data
*data
*
data
struct mmc_command *cmd;
struct mmc_command *cmd;
struct mmc_command
mmc_command
*cmd
*
cmd
enum dw_mci_state state;
enum dw_mci_state state;
enum dw_mci_state
dw_mci_state
state
state
enum dw_mci_state prev_state;
enum dw_mci_state prev_state;
enum dw_mci_state
dw_mci_state
prev_state
prev_state
u32 status, ctrl;
u32 status, ctrl;
u32
u32
status
status
ctrl
ctrl
spin_lock(&host->lock);
spin_lock(&host->lock)
spin_lock
spin_lock
&host->lock
host->lock
host
host
lock
state = host->state;
state = host->state
state
state
host->state
host
host
state
data = host->data;
data = host->data
data
data
host->data
host
host
data
do {		prev_state = state;		switch (state) {		case STATE_IDLE:			break;		case STATE_SENDING_CMD:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			cmd = host->cmd;			host->cmd = NULL;			set_bit(EVENT_CMD_COMPLETE, &host->completed_events);			dw_mci_command_complete(host, cmd);			if (cmd == host->mrq->sbc && !cmd->error) {				prev_state = state = STATE_SENDING_CMD;				__dw_mci_start_request(host, host->cur_slot,						       host->mrq->cmd);				goto unlock;			}			if (!host->mrq->data || cmd->error) {				dw_mci_request_end(host, host->mrq);				goto unlock;			}			prev_state = state = STATE_SENDING_DATA;			/* fall through */		case STATE_SENDING_DATA:			if (test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)) {				dw_mci_stop_dma(host);				if (data->stop)					send_stop_cmd(host, data);				state = STATE_DATA_ERROR;				break;			}			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events))				break;			set_bit(EVENT_XFER_COMPLETE, &host->completed_events);			prev_state = state = STATE_DATA_BUSY;			/* fall through */		case STATE_DATA_BUSY:			if (!test_and_clear_bit(EVENT_DATA_COMPLETE,						&host->pending_events))				break;			host->data = NULL;			set_bit(EVENT_DATA_COMPLETE, &host->completed_events);			status = host->data_status;			if (status & DW_MCI_DATA_ERROR_FLAGS) {				if (status & SDMMC_INT_DTO) {					data->error = -ETIMEDOUT;				} else if (status & SDMMC_INT_DCRC) {					data->error = -EILSEQ;				} else if (status & SDMMC_INT_EBE &&					   host->dir_status ==							DW_MCI_SEND_STATUS) {					/*					 * No data CRC status was returned.					 * The number of bytes transferred will					 * be exaggerated in PIO mode.					 */					data->bytes_xfered = 0;					data->error = -ETIMEDOUT;				} else {					dev_err(&host->dev,						"data FIFO error "						"(status=%08x)\n",						status);					data->error = -EIO;				}				/*				 * After an error, there may be data lingering				 * in the FIFO, so reset it - doing so				 * generates a block interrupt, hence setting				 * the scatter-gather pointer to NULL.				 */				sg_miter_stop(&host->sg_miter);				host->sg = NULL;				ctrl = mci_readl(host, CTRL);				ctrl |= SDMMC_CTRL_FIFO_RESET;				mci_writel(host, CTRL, ctrl);			} else {				data->bytes_xfered = data->blocks * data->blksz;				data->error = 0;			}			if (!data->stop) {				dw_mci_request_end(host, host->mrq);				goto unlock;			}			if (host->mrq->sbc && !data->error) {				data->stop->error = 0;				dw_mci_request_end(host, host->mrq);				goto unlock;			}			prev_state = state = STATE_SENDING_STOP;			if (!data->error)				send_stop_cmd(host, data);			/* fall through */		case STATE_SENDING_STOP:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			host->cmd = NULL;			dw_mci_command_complete(host, host->mrq->stop);			dw_mci_request_end(host, host->mrq);			goto unlock;		case STATE_DATA_ERROR:			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events))				break;			state = STATE_DATA_BUSY;			break;		}	} while (state != prev_state);
{		prev_state = state;		switch (state) {		case STATE_IDLE:			break;		case STATE_SENDING_CMD:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			cmd = host->cmd;			host->cmd = NULL;			set_bit(EVENT_CMD_COMPLETE, &host->completed_events);			dw_mci_command_complete(host, cmd);			if (cmd == host->mrq->sbc && !cmd->error) {				prev_state = state = STATE_SENDING_CMD;				__dw_mci_start_request(host, host->cur_slot,						       host->mrq->cmd);				goto unlock;			}			if (!host->mrq->data || cmd->error) {				dw_mci_request_end(host, host->mrq);				goto unlock;			}			prev_state = state = STATE_SENDING_DATA;			/* fall through */		case STATE_SENDING_DATA:			if (test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)) {				dw_mci_stop_dma(host);				if (data->stop)					send_stop_cmd(host, data);				state = STATE_DATA_ERROR;				break;			}			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events))				break;			set_bit(EVENT_XFER_COMPLETE, &host->completed_events);			prev_state = state = STATE_DATA_BUSY;			/* fall through */		case STATE_DATA_BUSY:			if (!test_and_clear_bit(EVENT_DATA_COMPLETE,						&host->pending_events))				break;			host->data = NULL;			set_bit(EVENT_DATA_COMPLETE, &host->completed_events);			status = host->data_status;			if (status & DW_MCI_DATA_ERROR_FLAGS) {				if (status & SDMMC_INT_DTO) {					data->error = -ETIMEDOUT;				} else if (status & SDMMC_INT_DCRC) {					data->error = -EILSEQ;				} else if (status & SDMMC_INT_EBE &&					   host->dir_status ==							DW_MCI_SEND_STATUS) {					/*					 * No data CRC status was returned.					 * The number of bytes transferred will					 * be exaggerated in PIO mode.					 */					data->bytes_xfered = 0;					data->error = -ETIMEDOUT;				} else {					dev_err(&host->dev,						"data FIFO error "						"(status=%08x)\n",						status);					data->error = -EIO;				}				/*				 * After an error, there may be data lingering				 * in the FIFO, so reset it - doing so				 * generates a block interrupt, hence setting				 * the scatter-gather pointer to NULL.				 */				sg_miter_stop(&host->sg_miter);				host->sg = NULL;				ctrl = mci_readl(host, CTRL);				ctrl |= SDMMC_CTRL_FIFO_RESET;				mci_writel(host, CTRL, ctrl);			} else {				data->bytes_xfered = data->blocks * data->blksz;				data->error = 0;			}			if (!data->stop) {				dw_mci_request_end(host, host->mrq);				goto unlock;			}			if (host->mrq->sbc && !data->error) {				data->stop->error = 0;				dw_mci_request_end(host, host->mrq);				goto unlock;			}			prev_state = state = STATE_SENDING_STOP;			if (!data->error)				send_stop_cmd(host, data);			/* fall through */		case STATE_SENDING_STOP:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			host->cmd = NULL;			dw_mci_command_complete(host, host->mrq->stop);			dw_mci_request_end(host, host->mrq);			goto unlock;		case STATE_DATA_ERROR:			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events))				break;			state = STATE_DATA_BUSY;			break;		}	}
prev_state = state;
prev_state = state
prev_state
prev_state
state
state
switch (state) {		case STATE_IDLE:			break;		case STATE_SENDING_CMD:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			cmd = host->cmd;			host->cmd = NULL;			set_bit(EVENT_CMD_COMPLETE, &host->completed_events);			dw_mci_command_complete(host, cmd);			if (cmd == host->mrq->sbc && !cmd->error) {				prev_state = state = STATE_SENDING_CMD;				__dw_mci_start_request(host, host->cur_slot,						       host->mrq->cmd);				goto unlock;			}			if (!host->mrq->data || cmd->error) {				dw_mci_request_end(host, host->mrq);				goto unlock;			}			prev_state = state = STATE_SENDING_DATA;			/* fall through */		case STATE_SENDING_DATA:			if (test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)) {				dw_mci_stop_dma(host);				if (data->stop)					send_stop_cmd(host, data);				state = STATE_DATA_ERROR;				break;			}			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events))				break;			set_bit(EVENT_XFER_COMPLETE, &host->completed_events);			prev_state = state = STATE_DATA_BUSY;			/* fall through */		case STATE_DATA_BUSY:			if (!test_and_clear_bit(EVENT_DATA_COMPLETE,						&host->pending_events))				break;			host->data = NULL;			set_bit(EVENT_DATA_COMPLETE, &host->completed_events);			status = host->data_status;			if (status & DW_MCI_DATA_ERROR_FLAGS) {				if (status & SDMMC_INT_DTO) {					data->error = -ETIMEDOUT;				} else if (status & SDMMC_INT_DCRC) {					data->error = -EILSEQ;				} else if (status & SDMMC_INT_EBE &&					   host->dir_status ==							DW_MCI_SEND_STATUS) {					/*					 * No data CRC status was returned.					 * The number of bytes transferred will					 * be exaggerated in PIO mode.					 */					data->bytes_xfered = 0;					data->error = -ETIMEDOUT;				} else {					dev_err(&host->dev,						"data FIFO error "						"(status=%08x)\n",						status);					data->error = -EIO;				}				/*				 * After an error, there may be data lingering				 * in the FIFO, so reset it - doing so				 * generates a block interrupt, hence setting				 * the scatter-gather pointer to NULL.				 */				sg_miter_stop(&host->sg_miter);				host->sg = NULL;				ctrl = mci_readl(host, CTRL);				ctrl |= SDMMC_CTRL_FIFO_RESET;				mci_writel(host, CTRL, ctrl);			} else {				data->bytes_xfered = data->blocks * data->blksz;				data->error = 0;			}			if (!data->stop) {				dw_mci_request_end(host, host->mrq);				goto unlock;			}			if (host->mrq->sbc && !data->error) {				data->stop->error = 0;				dw_mci_request_end(host, host->mrq);				goto unlock;			}			prev_state = state = STATE_SENDING_STOP;			if (!data->error)				send_stop_cmd(host, data);			/* fall through */		case STATE_SENDING_STOP:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			host->cmd = NULL;			dw_mci_command_complete(host, host->mrq->stop);			dw_mci_request_end(host, host->mrq);			goto unlock;		case STATE_DATA_ERROR:			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events))				break;			state = STATE_DATA_BUSY;			break;		}
state
state
{		case STATE_IDLE:			break;		case STATE_SENDING_CMD:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			cmd = host->cmd;			host->cmd = NULL;			set_bit(EVENT_CMD_COMPLETE, &host->completed_events);			dw_mci_command_complete(host, cmd);			if (cmd == host->mrq->sbc && !cmd->error) {				prev_state = state = STATE_SENDING_CMD;				__dw_mci_start_request(host, host->cur_slot,						       host->mrq->cmd);				goto unlock;			}			if (!host->mrq->data || cmd->error) {				dw_mci_request_end(host, host->mrq);				goto unlock;			}			prev_state = state = STATE_SENDING_DATA;			/* fall through */		case STATE_SENDING_DATA:			if (test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)) {				dw_mci_stop_dma(host);				if (data->stop)					send_stop_cmd(host, data);				state = STATE_DATA_ERROR;				break;			}			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events))				break;			set_bit(EVENT_XFER_COMPLETE, &host->completed_events);			prev_state = state = STATE_DATA_BUSY;			/* fall through */		case STATE_DATA_BUSY:			if (!test_and_clear_bit(EVENT_DATA_COMPLETE,						&host->pending_events))				break;			host->data = NULL;			set_bit(EVENT_DATA_COMPLETE, &host->completed_events);			status = host->data_status;			if (status & DW_MCI_DATA_ERROR_FLAGS) {				if (status & SDMMC_INT_DTO) {					data->error = -ETIMEDOUT;				} else if (status & SDMMC_INT_DCRC) {					data->error = -EILSEQ;				} else if (status & SDMMC_INT_EBE &&					   host->dir_status ==							DW_MCI_SEND_STATUS) {					/*					 * No data CRC status was returned.					 * The number of bytes transferred will					 * be exaggerated in PIO mode.					 */					data->bytes_xfered = 0;					data->error = -ETIMEDOUT;				} else {					dev_err(&host->dev,						"data FIFO error "						"(status=%08x)\n",						status);					data->error = -EIO;				}				/*				 * After an error, there may be data lingering				 * in the FIFO, so reset it - doing so				 * generates a block interrupt, hence setting				 * the scatter-gather pointer to NULL.				 */				sg_miter_stop(&host->sg_miter);				host->sg = NULL;				ctrl = mci_readl(host, CTRL);				ctrl |= SDMMC_CTRL_FIFO_RESET;				mci_writel(host, CTRL, ctrl);			} else {				data->bytes_xfered = data->blocks * data->blksz;				data->error = 0;			}			if (!data->stop) {				dw_mci_request_end(host, host->mrq);				goto unlock;			}			if (host->mrq->sbc && !data->error) {				data->stop->error = 0;				dw_mci_request_end(host, host->mrq);				goto unlock;			}			prev_state = state = STATE_SENDING_STOP;			if (!data->error)				send_stop_cmd(host, data);			/* fall through */		case STATE_SENDING_STOP:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			host->cmd = NULL;			dw_mci_command_complete(host, host->mrq->stop);			dw_mci_request_end(host, host->mrq);			goto unlock;		case STATE_DATA_ERROR:			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events))				break;			state = STATE_DATA_BUSY;			break;		}
case STATE_IDLE:
STATE_IDLE
STATE_IDLE
break;
case STATE_SENDING_CMD:
STATE_SENDING_CMD
STATE_SENDING_CMD
if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;
!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events)
test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events)
test_and_clear_bit
test_and_clear_bit
EVENT_CMD_COMPLETE
EVENT_CMD_COMPLETE
&host->pending_events
host->pending_events
host
host
pending_events
break;
cmd = host->cmd;
cmd = host->cmd
cmd
cmd
host->cmd
host
host
cmd
host->cmd = NULL;
host->cmd = NULL
host->cmd
host
host
cmd
NULL
NULL
set_bit(EVENT_CMD_COMPLETE, &host->completed_events);
set_bit(EVENT_CMD_COMPLETE, &host->completed_events)
set_bit
set_bit
EVENT_CMD_COMPLETE
EVENT_CMD_COMPLETE
&host->completed_events
host->completed_events
host
host
completed_events
dw_mci_command_complete(host, cmd);
dw_mci_command_complete(host, cmd)
dw_mci_command_complete
dw_mci_command_complete
host
host
cmd
cmd
if (cmd == host->mrq->sbc && !cmd->error) {				prev_state = state = STATE_SENDING_CMD;				__dw_mci_start_request(host, host->cur_slot,						       host->mrq->cmd);				goto unlock;			}
cmd == host->mrq->sbc && !cmd->error
cmd == host->mrq->sbc
cmd
cmd
host->mrq->sbc
host->mrq
host
host
mrq
sbc
!cmd->error
cmd->error
cmd
cmd
error
{				prev_state = state = STATE_SENDING_CMD;				__dw_mci_start_request(host, host->cur_slot,						       host->mrq->cmd);				goto unlock;			}
prev_state = state = STATE_SENDING_CMD;
prev_state = state = STATE_SENDING_CMD
prev_state
prev_state
state = STATE_SENDING_CMD
state
state
STATE_SENDING_CMD
STATE_SENDING_CMD
__dw_mci_start_request(host, host->cur_slot,						       host->mrq->cmd);
__dw_mci_start_request(host, host->cur_slot,						       host->mrq->cmd)
__dw_mci_start_request
__dw_mci_start_request
host
host
host->cur_slot
host
host
cur_slot
host->mrq->cmd
host->mrq
host
host
mrq
cmd
goto unlock;
unlock
if (!host->mrq->data || cmd->error) {				dw_mci_request_end(host, host->mrq);				goto unlock;			}
!host->mrq->data || cmd->error
!host->mrq->data
host->mrq->data
host->mrq
host
host
mrq
data
cmd->error
cmd
cmd
error
{				dw_mci_request_end(host, host->mrq);				goto unlock;			}
dw_mci_request_end(host, host->mrq);
dw_mci_request_end(host, host->mrq)
dw_mci_request_end
dw_mci_request_end
host
host
host->mrq
host
host
mrq
goto unlock;
unlock
prev_state = state = STATE_SENDING_DATA;
prev_state = state = STATE_SENDING_DATA
prev_state
prev_state
state = STATE_SENDING_DATA
state
state
STATE_SENDING_DATA
STATE_SENDING_DATA
case STATE_SENDING_DATA:
STATE_SENDING_DATA
STATE_SENDING_DATA
if (test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)) {				dw_mci_stop_dma(host);				if (data->stop)					send_stop_cmd(host, data);				state = STATE_DATA_ERROR;				break;			}
test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)
test_and_clear_bit
test_and_clear_bit
EVENT_DATA_ERROR
EVENT_DATA_ERROR
&host->pending_events
host->pending_events
host
host
pending_events
{				dw_mci_stop_dma(host);				if (data->stop)					send_stop_cmd(host, data);				state = STATE_DATA_ERROR;				break;			}
dw_mci_stop_dma(host);
dw_mci_stop_dma(host)
dw_mci_stop_dma
dw_mci_stop_dma
host
host
if (data->stop)					send_stop_cmd(host, data);
data->stop
data
data
stop
send_stop_cmd(host, data);
send_stop_cmd(host, data)
send_stop_cmd
send_stop_cmd
host
host
data
data
state = STATE_DATA_ERROR;
state = STATE_DATA_ERROR
state
state
STATE_DATA_ERROR
STATE_DATA_ERROR
break;
if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events))				break;
!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events)
test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events)
test_and_clear_bit
test_and_clear_bit
EVENT_XFER_COMPLETE
EVENT_XFER_COMPLETE
&host->pending_events
host->pending_events
host
host
pending_events
break;
set_bit(EVENT_XFER_COMPLETE, &host->completed_events);
set_bit(EVENT_XFER_COMPLETE, &host->completed_events)
set_bit
set_bit
EVENT_XFER_COMPLETE
EVENT_XFER_COMPLETE
&host->completed_events
host->completed_events
host
host
completed_events
prev_state = state = STATE_DATA_BUSY;
prev_state = state = STATE_DATA_BUSY
prev_state
prev_state
state = STATE_DATA_BUSY
state
state
STATE_DATA_BUSY
STATE_DATA_BUSY
case STATE_DATA_BUSY:
STATE_DATA_BUSY
STATE_DATA_BUSY
if (!test_and_clear_bit(EVENT_DATA_COMPLETE,						&host->pending_events))				break;
!test_and_clear_bit(EVENT_DATA_COMPLETE,						&host->pending_events)
test_and_clear_bit(EVENT_DATA_COMPLETE,						&host->pending_events)
test_and_clear_bit
test_and_clear_bit
EVENT_DATA_COMPLETE
EVENT_DATA_COMPLETE
&host->pending_events
host->pending_events
host
host
pending_events
break;
host->data = NULL;
host->data = NULL
host->data
host
host
data
NULL
NULL
set_bit(EVENT_DATA_COMPLETE, &host->completed_events);
set_bit(EVENT_DATA_COMPLETE, &host->completed_events)
set_bit
set_bit
EVENT_DATA_COMPLETE
EVENT_DATA_COMPLETE
&host->completed_events
host->completed_events
host
host
completed_events
status = host->data_status;
status = host->data_status
status
status
host->data_status
host
host
data_status
if (status & DW_MCI_DATA_ERROR_FLAGS) {				if (status & SDMMC_INT_DTO) {					data->error = -ETIMEDOUT;				} else if (status & SDMMC_INT_DCRC) {					data->error = -EILSEQ;				} else if (status & SDMMC_INT_EBE &&					   host->dir_status ==							DW_MCI_SEND_STATUS) {					/*					 * No data CRC status was returned.					 * The number of bytes transferred will					 * be exaggerated in PIO mode.					 */					data->bytes_xfered = 0;					data->error = -ETIMEDOUT;				} else {					dev_err(&host->dev,						"data FIFO error "						"(status=%08x)\n",						status);					data->error = -EIO;				}				/*				 * After an error, there may be data lingering				 * in the FIFO, so reset it - doing so				 * generates a block interrupt, hence setting				 * the scatter-gather pointer to NULL.				 */				sg_miter_stop(&host->sg_miter);				host->sg = NULL;				ctrl = mci_readl(host, CTRL);				ctrl |= SDMMC_CTRL_FIFO_RESET;				mci_writel(host, CTRL, ctrl);			} else {				data->bytes_xfered = data->blocks * data->blksz;				data->error = 0;			}
status & DW_MCI_DATA_ERROR_FLAGS
status
status
DW_MCI_DATA_ERROR_FLAGS
DW_MCI_DATA_ERROR_FLAGS
{				if (status & SDMMC_INT_DTO) {					data->error = -ETIMEDOUT;				} else if (status & SDMMC_INT_DCRC) {					data->error = -EILSEQ;				} else if (status & SDMMC_INT_EBE &&					   host->dir_status ==							DW_MCI_SEND_STATUS) {					/*					 * No data CRC status was returned.					 * The number of bytes transferred will					 * be exaggerated in PIO mode.					 */					data->bytes_xfered = 0;					data->error = -ETIMEDOUT;				} else {					dev_err(&host->dev,						"data FIFO error "						"(status=%08x)\n",						status);					data->error = -EIO;				}				/*				 * After an error, there may be data lingering				 * in the FIFO, so reset it - doing so				 * generates a block interrupt, hence setting				 * the scatter-gather pointer to NULL.				 */				sg_miter_stop(&host->sg_miter);				host->sg = NULL;				ctrl = mci_readl(host, CTRL);				ctrl |= SDMMC_CTRL_FIFO_RESET;				mci_writel(host, CTRL, ctrl);			}
if (status & SDMMC_INT_DTO) {					data->error = -ETIMEDOUT;				} else if (status & SDMMC_INT_DCRC) {					data->error = -EILSEQ;				} else if (status & SDMMC_INT_EBE &&					   host->dir_status ==							DW_MCI_SEND_STATUS) {					/*					 * No data CRC status was returned.					 * The number of bytes transferred will					 * be exaggerated in PIO mode.					 */					data->bytes_xfered = 0;					data->error = -ETIMEDOUT;				} else {					dev_err(&host->dev,						"data FIFO error "						"(status=%08x)\n",						status);					data->error = -EIO;				}
status & SDMMC_INT_DTO
status
status
SDMMC_INT_DTO
SDMMC_INT_DTO
{					data->error = -ETIMEDOUT;				}
data->error = -ETIMEDOUT;
data->error = -ETIMEDOUT
data->error
data
data
error
-ETIMEDOUT
ETIMEDOUT
ETIMEDOUT
if (status & SDMMC_INT_DCRC) {					data->error = -EILSEQ;				} else if (status & SDMMC_INT_EBE &&					   host->dir_status ==							DW_MCI_SEND_STATUS) {					/*					 * No data CRC status was returned.					 * The number of bytes transferred will					 * be exaggerated in PIO mode.					 */					data->bytes_xfered = 0;					data->error = -ETIMEDOUT;				} else {					dev_err(&host->dev,						"data FIFO error "						"(status=%08x)\n",						status);					data->error = -EIO;				}
status & SDMMC_INT_DCRC
status
status
SDMMC_INT_DCRC
SDMMC_INT_DCRC
{					data->error = -EILSEQ;				}
data->error = -EILSEQ;
data->error = -EILSEQ
data->error
data
data
error
-EILSEQ
EILSEQ
EILSEQ
if (status & SDMMC_INT_EBE &&					   host->dir_status ==							DW_MCI_SEND_STATUS) {					/*					 * No data CRC status was returned.					 * The number of bytes transferred will					 * be exaggerated in PIO mode.					 */					data->bytes_xfered = 0;					data->error = -ETIMEDOUT;				} else {					dev_err(&host->dev,						"data FIFO error "						"(status=%08x)\n",						status);					data->error = -EIO;				}
status & SDMMC_INT_EBE &&					   host->dir_status ==							DW_MCI_SEND_STATUS
status & SDMMC_INT_EBE
status
status
SDMMC_INT_EBE
SDMMC_INT_EBE
host->dir_status ==							DW_MCI_SEND_STATUS
host->dir_status
host
host
dir_status
DW_MCI_SEND_STATUS
DW_MCI_SEND_STATUS
{					/*					 * No data CRC status was returned.					 * The number of bytes transferred will					 * be exaggerated in PIO mode.					 */					data->bytes_xfered = 0;					data->error = -ETIMEDOUT;				}
data->bytes_xfered = 0;
data->bytes_xfered = 0
data->bytes_xfered
data
data
bytes_xfered
0
data->error = -ETIMEDOUT;
data->error = -ETIMEDOUT
data->error
data
data
error
-ETIMEDOUT
ETIMEDOUT
ETIMEDOUT
{					dev_err(&host->dev,						"data FIFO error "						"(status=%08x)\n",						status);					data->error = -EIO;				}
dev_err(&host->dev,						"data FIFO error "						"(status=%08x)\n",						status);
dev_err(&host->dev,						"data FIFO error "						"(status=%08x)\n",						status)
dev_err
dev_err
&host->dev
host->dev
host
host
dev
"data FIFO error "						"(status=%08x)\n"
status
status
data->error = -EIO;
data->error = -EIO
data->error
data
data
error
-EIO
EIO
EIO
sg_miter_stop(&host->sg_miter);
sg_miter_stop(&host->sg_miter)
sg_miter_stop
sg_miter_stop
&host->sg_miter
host->sg_miter
host
host
sg_miter
host->sg = NULL;
host->sg = NULL
host->sg
host
host
sg
NULL
NULL
ctrl = mci_readl(host, CTRL);
ctrl = mci_readl(host, CTRL)
ctrl
ctrl
mci_readl(host, CTRL)
mci_readl
mci_readl
host
host
CTRL
CTRL
ctrl |= SDMMC_CTRL_FIFO_RESET;
ctrl |= SDMMC_CTRL_FIFO_RESET
ctrl
ctrl
SDMMC_CTRL_FIFO_RESET
SDMMC_CTRL_FIFO_RESET
mci_writel(host, CTRL, ctrl);
mci_writel(host, CTRL, ctrl)
mci_writel
mci_writel
host
host
CTRL
CTRL
ctrl
ctrl
{				data->bytes_xfered = data->blocks * data->blksz;				data->error = 0;			}
data->bytes_xfered = data->blocks * data->blksz;
data->bytes_xfered = data->blocks * data->blksz
data->bytes_xfered
data
data
bytes_xfered
data->blocks * data->blksz
data->blocks
data
data
blocks
data->blksz
data
data
blksz
data->error = 0;
data->error = 0
data->error
data
data
error
0
if (!data->stop) {				dw_mci_request_end(host, host->mrq);				goto unlock;			}
!data->stop
data->stop
data
data
stop
{				dw_mci_request_end(host, host->mrq);				goto unlock;			}
dw_mci_request_end(host, host->mrq);
dw_mci_request_end(host, host->mrq)
dw_mci_request_end
dw_mci_request_end
host
host
host->mrq
host
host
mrq
goto unlock;
unlock
if (host->mrq->sbc && !data->error) {				data->stop->error = 0;				dw_mci_request_end(host, host->mrq);				goto unlock;			}
host->mrq->sbc && !data->error
host->mrq->sbc
host->mrq
host
host
mrq
sbc
!data->error
data->error
data
data
error
{				data->stop->error = 0;				dw_mci_request_end(host, host->mrq);				goto unlock;			}
data->stop->error = 0;
data->stop->error = 0
data->stop->error
data->stop
data
data
stop
error
0
dw_mci_request_end(host, host->mrq);
dw_mci_request_end(host, host->mrq)
dw_mci_request_end
dw_mci_request_end
host
host
host->mrq
host
host
mrq
goto unlock;
unlock
prev_state = state = STATE_SENDING_STOP;
prev_state = state = STATE_SENDING_STOP
prev_state
prev_state
state = STATE_SENDING_STOP
state
state
STATE_SENDING_STOP
STATE_SENDING_STOP
if (!data->error)				send_stop_cmd(host, data);
!data->error
data->error
data
data
error
send_stop_cmd(host, data);
send_stop_cmd(host, data)
send_stop_cmd
send_stop_cmd
host
host
data
data
case STATE_SENDING_STOP:
STATE_SENDING_STOP
STATE_SENDING_STOP
if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;
!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events)
test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events)
test_and_clear_bit
test_and_clear_bit
EVENT_CMD_COMPLETE
EVENT_CMD_COMPLETE
&host->pending_events
host->pending_events
host
host
pending_events
break;
host->cmd = NULL;
host->cmd = NULL
host->cmd
host
host
cmd
NULL
NULL
dw_mci_command_complete(host, host->mrq->stop);
dw_mci_command_complete(host, host->mrq->stop)
dw_mci_command_complete
dw_mci_command_complete
host
host
host->mrq->stop
host->mrq
host
host
mrq
stop
dw_mci_request_end(host, host->mrq);
dw_mci_request_end(host, host->mrq)
dw_mci_request_end
dw_mci_request_end
host
host
host->mrq
host
host
mrq
goto unlock;
unlock
case STATE_DATA_ERROR:
STATE_DATA_ERROR
STATE_DATA_ERROR
if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events))				break;
!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events)
test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events)
test_and_clear_bit
test_and_clear_bit
EVENT_XFER_COMPLETE
EVENT_XFER_COMPLETE
&host->pending_events
host->pending_events
host
host
pending_events
break;
state = STATE_DATA_BUSY;
state = STATE_DATA_BUSY
state
state
STATE_DATA_BUSY
STATE_DATA_BUSY
break;
state != prev_state
state
state
prev_state
prev_state
host->state = state;
host->state = state
host->state
host
host
state
state
state
unlock:	spin_unlock(&host->lock);
unlock
spin_unlock(&host->lock);
spin_unlock(&host->lock)
spin_unlock
spin_unlock
&host->lock
host->lock
host
host
lock
-----joern-----
(139,364,0)
(59,374,0)
(46,34,0)
(46,328,0)
(46,5,0)
(237,389,0)
(369,333,0)
(270,392,0)
(290,113,0)
(167,318,0)
(258,318,0)
(341,90,0)
(269,64,0)
(176,258,0)
(247,99,0)
(337,270,0)
(276,249,0)
(282,203,0)
(157,143,0)
(182,249,0)
(244,392,0)
(335,192,0)
(269,318,0)
(155,59,0)
(15,188,0)
(280,74,0)
(307,392,0)
(168,392,0)
(203,66,0)
(231,342,0)
(203,46,0)
(248,233,0)
(67,103,0)
(299,46,0)
(7,63,0)
(323,72,0)
(160,392,0)
(322,5,0)
(256,316,0)
(301,213,0)
(104,392,0)
(366,310,0)
(256,284,0)
(213,301,0)
(116,337,0)
(353,52,0)
(18,318,0)
(46,374,0)
(129,157,0)
(163,336,0)
(364,318,0)
(156,12,0)
(94,270,0)
(389,318,0)
(169,249,0)
(251,185,0)
(352,318,0)
(161,310,0)
(20,392,0)
(234,5,0)
(320,280,0)
(309,392,0)
(286,85,0)
(121,234,0)
(113,306,0)
(87,328,0)
(321,132,0)
(191,392,0)
(179,114,0)
(358,212,0)
(336,279,0)
(66,392,0)
(280,34,0)
(10,86,0)
(241,44,0)
(150,235,0)
(111,330,0)
(281,74,0)
(292,80,0)
(288,266,0)
(289,311,0)
(125,284,0)
(162,381,0)
(185,325,0)
(263,389,0)
(123,274,0)
(334,364,0)
(142,166,0)
(318,74,0)
(354,107,0)
(223,34,0)
(219,74,0)
(23,16,0)
(246,52,0)
(371,41,0)
(379,23,0)
(224,339,0)
(376,392,0)
(49,293,0)
(256,335,0)
(53,360,0)
(245,77,0)
(118,220,0)
(339,330,0)
(39,318,0)
(314,213,0)
(32,381,0)
(133,2,0)
(345,135,0)
(114,179,0)
(189,213,0)
(58,74,0)
(270,167,0)
(153,163,0)
(197,233,0)
(280,41,0)
(344,210,0)
(183,318,0)
(102,392,0)
(394,360,0)
(24,132,0)
(208,212,0)
(19,135,0)
(174,362,0)
(194,392,0)
(52,212,0)
(387,212,0)
(60,311,0)
(388,256,0)
(300,212,0)
(241,318,0)
(132,318,0)
(285,363,0)
(272,227,0)
(64,20,0)
(124,333,0)
(319,135,0)
(296,114,0)
(188,238,0)
(46,96,0)
(176,78,0)
(23,10,0)
(185,318,0)
(325,318,0)
(389,237,0)
(51,160,0)
(110,370,0)
(108,130,0)
(44,392,0)
(62,352,0)
(210,135,0)
(200,347,0)
(303,342,0)
(48,336,0)
(325,360,0)
(333,233,0)
(17,214,0)
(359,78,0)
(68,5,0)
(4,86,0)
(134,74,0)
(29,318,0)
(46,235,0)
(298,387,0)
(377,90,0)
(372,358,0)
(253,208,0)
(41,55,0)
(261,114,0)
(122,285,0)
(325,185,0)
(109,19,0)
(222,74,0)
(203,234,0)
(283,144,0)
(256,357,0)
(77,318,0)
(342,303,0)
(16,23,0)
(201,318,0)
(130,188,0)
(283,103,0)
(181,101,0)
(324,339,0)
(239,334,0)
(258,176,0)
(144,283,0)
(21,200,0)
(277,180,0)
(188,233,0)
(148,66,0)
(230,201,0)
(271,85,0)
(99,220,0)
(292,381,0)
(80,292,0)
(51,318,0)
(61,74,0)
(378,382,0)
(163,153,0)
(25,258,0)
(284,125,0)
(225,392,0)
(203,41,0)
(26,258,0)
(153,123,0)
(112,39,0)
(266,318,0)
(335,240,0)
(91,56,0)
(315,320,0)
(365,362,0)
(381,318,0)
(386,318,0)
(326,300,0)
(98,270,0)
(72,212,0)
(190,392,0)
(264,283,0)
(132,24,0)
(11,201,0)
(216,144,0)
(212,74,0)
(330,135,0)
(293,318,0)
(275,392,0)
(119,392,0)
(163,335,0)
(12,212,0)
(187,7,0)
(143,157,0)
(214,370,0)
(342,233,0)
(183,242,0)
(18,91,0)
(101,270,0)
(82,392,0)
(5,234,0)
(114,318,0)
(177,98,0)
(277,190,0)
(340,24,0)
(95,201,0)
(93,18,0)
(297,56,0)
(280,328,0)
(374,59,0)
(338,336,0)
(384,55,0)
(9,212,0)
(24,340,0)
(106,392,0)
(339,318,0)
(64,269,0)
(126,67,0)
(334,346,0)
(343,392,0)
(128,318,0)
(304,256,0)
(356,183,0)
(278,144,0)
(203,328,0)
(193,240,0)
(138,378,0)
(233,392,0)
(45,102,0)
(188,130,0)
(280,374,0)
(2,179,0)
(207,340,0)
(117,203,0)
(284,166,0)
(287,241,0)
(218,80,0)
(100,347,0)
(286,67,0)
(386,55,0)
(349,101,0)
(197,318,0)
(180,318,0)
(66,328,0)
(291,74,0)
(35,131,0)
(63,220,0)
(203,34,0)
(203,5,0)
(38,352,0)
(310,212,0)
(154,9,0)
(196,108,0)
(29,274,0)
(262,392,0)
(393,306,0)
(380,77,0)
(1,392,0)
(176,318,0)
(276,142,0)
(86,10,0)
(145,227,0)
(361,337,0)
(293,370,0)
(295,12,0)
(179,2,0)
(67,318,0)
(7,270,0)
(285,79,0)
(152,392,0)
(311,318,0)
(243,180,0)
(257,183,0)
(274,29,0)
(367,107,0)
(80,43,0)
(213,318,0)
(310,377,0)
(273,128,0)
(54,210,0)
(373,364,0)
(242,319,0)
(37,300,0)
(302,48,0)
(312,9,0)
(120,51,0)
(203,374,0)
(99,318,0)
(46,41,0)
(31,142,0)
(137,59,0)
(329,19,0)
(73,41,0)
(172,72,0)
(220,99,0)
(346,303,0)
(36,190,0)
(163,284,0)
(369,238,0)
(115,74,0)
(226,237,0)
(84,269,0)
(180,277,0)
(306,212,0)
(91,18,0)
(319,242,0)
(332,387,0)
(327,130,0)
(67,286,0)
(346,334,0)
(214,318,0)
(142,276,0)
(303,346,0)
(390,96,0)
(100,387,0)
(250,74,0)
(62,178,0)
(3,103,0)
(227,318,0)
(88,100,0)
(72,284,0)
(89,2,0)
(355,306,0)
(163,212,0)
(301,135,0)
(167,270,0)
(266,44,0)
(158,176,0)
(92,91,0)
(348,392,0)
(347,279,0)
(127,392,0)
(362,289,0)
(368,266,0)
(233,241,0)
(238,369,0)
(20,64,0)
(130,108,0)
(300,316,0)
(306,113,0)
(316,131,0)
(12,318,0)
(328,66,0)
(280,235,0)
(256,212,0)
(217,128,0)
(141,214,0)
(85,286,0)
(234,392,0)
(242,183,0)
(227,102,0)
(313,328,0)
(123,153,0)
(203,343,0)
(347,100,0)
(285,318,0)
(171,325,0)
(22,51,0)
(205,44,0)
(178,74,0)
(83,392,0)
(211,286,0)
(374,74,0)
(52,378,0)
(252,85,0)
(274,123,0)
(267,241,0)
(107,13,0)
(127,11,0)
(34,392,0)
(115,217,0)
(200,212,0)
(235,343,0)
(375,76,0)
(39,67,0)
(59,318,0)
(108,318,0)
(320,318,0)
(268,39,0)
(43,80,0)
(318,285,0)
(215,167,0)
(48,212,0)
(14,167,0)
(364,334,0)
(395,311,0)
(197,392,0)
(293,392,0)
(159,320,0)
(256,336,0)
(173,76,0)
(105,88,0)
(370,214,0)
(260,160,0)
(389,392,0)
(151,180,0)
(352,62,0)
(8,157,0)
(2,89,0)
(81,280,0)
(237,318,0)
(9,318,0)
(142,270,0)
(249,318,0)
(249,276,0)
(206,125,0)
(210,318,0)
(19,301,0)
(383,29,0)
(220,63,0)
(259,185,0)
(107,354,0)
(311,289,0)
(157,212,0)
(30,386,0)
(165,34,0)
(186,132,0)
(33,208,0)
(228,318,0)
(128,217,0)
(86,318,0)
(69,74,0)
(203,235,0)
(199,392,0)
(357,256,0)
(289,362,0)
(100,88,0)
(42,55,0)
(170,48,0)
(76,212,0)
(308,342,0)
(6,46,0)
(265,127,0)
(204,392,0)
(77,354,0)
(331,7,0)
(363,285,0)
(201,11,0)
(0,352,0)
(316,75,0)
(256,377,0)
(280,5,0)
(217,115,0)
(163,377,0)
(333,369,0)
(210,19,0)
(76,318,0)
(178,62,0)
(350,392,0)
(88,212,0)
(362,174,0)
(113,394,0)
(229,86,0)
(198,333,0)
(195,374,0)
(63,7,0)
(27,98,0)
(354,77,0)
(67,39,0)
(11,127,0)
(10,23,0)
(305,163,0)
(70,20,0)
(370,293,0)
(91,318,0)
(232,274,0)
(255,197,0)
(71,163,0)
(240,335,0)
(13,107,0)
(351,200,0)
(209,29,0)
(65,99,0)
(381,292,0)
(163,316,0)
(387,100,0)
(97,343,0)
(131,316,0)
(254,358,0)
(85,318,0)
(140,88,0)
(208,335,0)
(241,233,0)
(221,108,0)
(28,212,0)
(147,269,0)
(385,301,0)
(57,237,0)
(90,377,0)
(294,394,0)
(343,235,0)
(377,382,0)
(164,18,0)
(136,142,0)
(40,197,0)
(212,12,0)
(238,188,0)
(149,210,0)
(202,128,0)
(190,277,0)
(184,235,0)
(38,297,1)
(207,47,1)
(115,217,1)
(321,186,1)
(203,117,1)
(71,305,1)
(196,221,1)
(99,247,1)
(9,212,1)
(314,385,1)
(63,220,1)
(380,245,1)
(167,318,1)
(362,289,1)
(200,351,1)
(91,18,1)
(334,364,1)
(72,212,1)
(333,198,1)
(358,372,1)
(26,158,1)
(367,340,1)
(10,86,1)
(164,92,1)
(100,387,1)
(54,344,1)
(276,249,1)
(326,337,1)
(356,316,1)
(12,318,1)
(109,301,1)
(387,212,1)
(12,156,1)
(256,316,1)
(130,108,1)
(356,335,1)
(377,90,1)
(181,270,1)
(86,4,1)
(46,5,1)
(6,212,1)
(264,238,1)
(23,10,1)
(351,21,1)
(394,294,1)
(88,212,1)
(51,22,1)
(84,147,1)
(220,118,1)
(234,5,1)
(120,16,1)
(244,389,1)
(89,2,1)
(241,44,1)
(313,148,1)
(175,174,1)
(163,335,1)
(342,233,1)
(290,306,1)
(254,386,1)
(211,85,1)
(271,39,1)
(39,318,1)
(235,150,1)
(123,274,1)
(278,264,1)
(300,37,1)
(320,315,1)
(76,173,1)
(85,318,1)
(268,126,1)
(257,356,1)
(205,266,1)
(343,235,1)
(354,77,1)
(393,355,1)
(282,376,1)
(256,335,1)
(140,105,1)
(295,28,1)
(112,268,1)
(137,155,1)
(73,358,1)
(77,380,1)
(59,318,1)
(280,81,1)
(282,50,1)
(265,102,1)
(139,238,1)
(251,171,1)
(252,271,1)
(101,270,1)
(266,368,1)
(28,374,1)
(201,95,1)
(256,284,1)
(355,123,1)
(46,299,1)
(8,210,1)
(29,383,1)
(370,110,1)
(368,288,1)
(46,328,1)
(306,393,1)
(91,318,1)
(176,318,1)
(173,375,1)
(325,318,1)
(22,120,1)
(218,47,1)
(133,66,1)
(169,182,1)
(227,318,1)
(160,260,1)
(34,165,1)
(288,233,1)
(132,318,1)
(65,7,1)
(376,47,1)
(210,54,1)
(203,34,1)
(386,30,1)
(95,230,1)
(293,370,1)
(67,318,1)
(324,224,1)
(176,258,1)
(38,244,1)
(310,212,1)
(347,100,1)
(203,328,1)
(233,241,1)
(231,308,1)
(46,41,1)
(369,333,1)
(389,237,1)
(108,196,1)
(183,257,1)
(349,181,1)
(356,284,1)
(280,374,1)
(117,282,1)
(39,112,1)
(184,97,1)
(107,354,1)
(51,318,1)
(300,212,1)
(18,318,1)
(282,236,1)
(379,9,1)
(124,188,1)
(304,388,1)
(275,34,1)
(334,239,1)
(273,202,1)
(153,163,1)
(163,316,1)
(274,29,1)
(43,80,1)
(60,395,1)
(186,207,1)
(282,391,1)
(212,12,1)
(126,283,1)
(203,374,1)
(389,318,1)
(128,273,1)
(280,235,1)
(57,263,1)
(261,296,1)
(185,318,1)
(64,269,1)
(226,57,1)
(25,26,1)
(180,151,1)
(311,60,1)
(38,359,1)
(37,326,1)
(379,357,1)
(159,203,1)
(189,314,1)
(144,216,1)
(303,346,1)
(256,336,1)
(282,275,1)
(294,113,1)
(337,270,1)
(364,318,1)
(4,229,1)
(316,131,1)
(113,290,1)
(9,312,1)
(136,31,1)
(208,212,1)
(50,43,1)
(3,67,1)
(299,6,1)
(30,340,1)
(286,211,1)
(132,321,1)
(221,15,1)
(342,231,1)
(328,87,1)
(42,41,1)
(238,369,1)
(16,23,1)
(320,318,1)
(203,234,1)
(2,179,1)
(243,36,1)
(245,367,1)
(391,89,1)
(45,227,1)
(280,34,1)
(287,267,1)
(46,374,1)
(280,5,1)
(383,209,1)
(118,99,1)
(116,101,1)
(142,276,1)
(31,276,1)
(310,161,1)
(375,358,1)
(339,324,1)
(171,394,1)
(157,129,1)
(46,34,1)
(185,259,1)
(163,71,1)
(209,143,1)
(149,19,1)
(73,76,1)
(312,154,1)
(98,270,1)
(246,353,1)
(142,136,1)
(145,272,1)
(143,157,1)
(68,322,1)
(70,44,1)
(366,378,1)
(280,328,1)
(239,364,1)
(20,64,1)
(27,337,1)
(197,255,1)
(258,25,1)
(379,47,1)
(66,328,1)
(203,41,1)
(256,304,1)
(133,47,1)
(67,286,1)
(0,38,1)
(156,295,1)
(157,212,1)
(303,342,1)
(193,208,1)
(88,140,1)
(381,318,1)
(17,49,1)
(346,334,1)
(150,184,1)
(230,265,1)
(5,68,1)
(283,144,1)
(52,246,1)
(297,91,1)
(146,16,1)
(340,24,1)
(40,20,1)
(101,349,1)
(237,226,1)
(35,300,1)
(285,122,1)
(203,343,1)
(100,88,1)
(311,318,1)
(274,232,1)
(333,233,1)
(188,233,1)
(63,7,1)
(361,116,1)
(155,195,1)
(370,214,1)
(81,320,1)
(325,185,1)
(365,47,1)
(97,123,1)
(385,330,1)
(267,248,1)
(29,318,1)
(296,133,1)
(148,190,1)
(47,46,1)
(285,79,1)
(331,187,1)
(318,285,1)
(282,175,1)
(386,318,1)
(190,277,1)
(49,160,1)
(141,17,1)
(167,215,1)
(163,212,1)
(113,306,1)
(249,318,1)
(102,45,1)
(158,303,1)
(332,200,1)
(247,65,1)
(301,213,1)
(210,19,1)
(174,362,1)
(154,357,1)
(203,235,1)
(215,14,1)
(259,251,1)
(373,139,1)
(183,318,1)
(114,261,1)
(223,43,1)
(319,242,1)
(108,318,1)
(285,363,1)
(269,318,1)
(46,235,1)
(203,46,1)
(241,287,1)
(6,203,1)
(85,252,1)
(147,70,1)
(197,233,1)
(13,107,1)
(388,343,1)
(238,188,1)
(76,212,1)
(256,377,1)
(330,111,1)
(210,318,1)
(282,42,1)
(282,146,1)
(178,62,1)
(38,3,1)
(202,318,1)
(372,254,1)
(255,40,1)
(241,318,1)
(381,162,1)
(195,115,1)
(353,63,1)
(24,132,1)
(227,145,1)
(165,223,1)
(359,176,1)
(11,201,1)
(36,13,1)
(18,93,1)
(38,53,1)
(19,329,1)
(289,311,1)
(229,379,1)
(59,137,1)
(122,228,1)
(182,63,1)
(237,318,1)
(236,13,1)
(258,318,1)
(180,318,1)
(323,142,1)
(93,164,1)
(90,341,1)
(253,33,1)
(317,178,1)
(86,318,1)
(123,153,1)
(129,8,1)
(387,298,1)
(179,114,1)
(203,66,1)
(298,332,1)
(187,98,1)
(19,301,1)
(92,143,1)
(269,84,1)
(336,338,1)
(216,278,1)
(67,39,1)
(130,327,1)
(293,318,1)
(98,177,1)
(48,302,1)
(127,11,1)
(232,29,1)
(207,234,1)
(99,318,1)
(220,99,1)
(201,318,1)
(270,167,1)
(138,52,1)
(338,48,1)
(38,280,1)
(21,101,1)
(344,149,1)
(121,303,1)
(292,381,1)
(214,318,1)
(76,318,1)
(260,51,1)
(172,323,1)
(162,32,1)
(163,336,1)
(263,293,1)
(358,212,1)
(72,172,1)
(280,41,1)
(217,128,1)
(352,0,1)
(80,292,1)
(125,206,1)
(32,218,1)
(378,138,1)
(240,193,1)
(356,377,1)
(213,318,1)
(352,318,1)
(335,240,1)
(248,174,1)
(94,127,1)
(286,85,1)
(339,318,1)
(364,373,1)
(105,387,1)
(197,318,1)
(337,361,1)
(110,214,1)
(203,5,1)
(9,318,1)
(315,159,1)
(329,109,1)
(163,284,1)
(170,347,1)
(277,180,1)
(284,125,1)
(48,212,1)
(341,310,1)
(131,35,1)
(53,325,1)
(41,371,1)
(242,183,1)
(395,365,1)
(322,121,1)
(213,189,1)
(151,243,1)
(177,27,1)
(62,352,1)
(208,253,1)
(266,318,1)
(7,331,1)
(214,141,1)
(206,72,1)
(188,130,1)
(198,124,1)
(161,366,1)
(163,377,1)
(77,318,1)
(306,212,1)
(256,212,1)
(15,197,1)
(114,318,1)
(302,170,1)
(14,94,1)
(87,313,1)
(200,212,1)
(8,336,1)
(305,274,1)
(142,270,1)
(374,59,1)
(371,73,1)
(327,108,1)
(44,205,1)
(7,270,1)
(357,256,1)
(128,318,1)
(272,89,1)
(52,212,1)
(33,98,1)
(308,346,1)
(224,319,1)
(249,169,1)
(282,47,1)
(111,339,1)
(142,270,2)
(227,318,2)
(337,101,2)
(101,89,2)
(16,23,2)
(216,238,2)
(289,47,2)
(280,235,2)
(359,303,2)
(52,212,2)
(213,318,2)
(285,363,2)
(88,101,2)
(372,340,2)
(342,233,2)
(381,318,2)
(120,16,2)
(114,13,2)
(186,47,2)
(30,340,2)
(98,270,2)
(99,318,2)
(181,89,2)
(318,285,2)
(213,101,2)
(170,101,2)
(163,274,2)
(190,13,2)
(346,238,2)
(6,203,2)
(27,337,2)
(227,89,2)
(237,16,2)
(356,101,2)
(132,303,2)
(44,174,2)
(203,234,2)
(371,340,2)
(39,238,2)
(100,88,2)
(256,335,2)
(302,101,2)
(319,242,2)
(229,123,2)
(272,89,2)
(234,303,2)
(124,188,2)
(8,89,2)
(203,41,2)
(176,303,2)
(389,318,2)
(270,167,2)
(253,98,2)
(138,63,2)
(276,249,2)
(125,63,2)
(237,318,2)
(220,99,2)
(343,123,2)
(143,89,2)
(311,47,2)
(46,5,2)
(60,47,2)
(220,7,2)
(256,336,2)
(203,16,2)
(289,311,2)
(238,369,2)
(223,43,2)
(239,238,2)
(198,188,2)
(387,212,2)
(13,107,2)
(323,63,2)
(22,16,2)
(84,174,2)
(293,370,2)
(326,337,2)
(193,98,2)
(218,47,2)
(267,174,2)
(50,43,2)
(338,101,2)
(128,318,2)
(205,174,2)
(172,63,2)
(212,12,2)
(203,328,2)
(182,63,2)
(203,89,2)
(277,13,2)
(395,47,2)
(179,13,2)
(301,213,2)
(286,238,2)
(3,238,2)
(178,62,2)
(322,303,2)
(190,277,2)
(163,284,2)
(243,13,2)
(29,143,2)
(183,318,2)
(342,346,2)
(260,16,2)
(46,374,2)
(180,13,2)
(123,274,2)
(11,89,2)
(23,123,2)
(113,123,2)
(300,212,2)
(251,123,2)
(386,340,2)
(241,174,2)
(233,174,2)
(290,123,2)
(247,7,2)
(374,59,2)
(146,16,2)
(21,101,2)
(40,174,2)
(346,334,2)
(72,212,2)
(67,39,2)
(266,318,2)
(299,203,2)
(51,318,2)
(214,16,2)
(376,47,2)
(370,214,2)
(66,13,2)
(126,238,2)
(203,5,2)
(86,47,2)
(54,101,2)
(117,89,2)
(109,101,2)
(315,203,2)
(284,63,2)
(117,16,2)
(77,340,2)
(335,98,2)
(256,377,2)
(5,303,2)
(238,188,2)
(276,63,2)
(269,174,2)
(63,7,2)
(183,101,2)
(139,238,2)
(284,125,2)
(238,174,2)
(76,358,2)
(153,163,2)
(357,123,2)
(263,16,2)
(341,63,2)
(332,101,2)
(143,157,2)
(145,89,2)
(24,303,2)
(48,212,2)
(123,153,2)
(111,101,2)
(313,13,2)
(254,340,2)
(121,303,2)
(127,89,2)
(25,303,2)
(210,101,2)
(294,123,2)
(246,63,2)
(334,238,2)
(7,98,2)
(46,34,2)
(203,13,2)
(179,47,2)
(256,123,2)
(366,63,2)
(203,343,2)
(387,101,2)
(232,143,2)
(379,47,2)
(108,174,2)
(132,318,2)
(306,123,2)
(386,318,2)
(76,318,2)
(234,5,2)
(215,89,2)
(159,203,2)
(340,47,2)
(258,303,2)
(147,174,2)
(57,16,2)
(282,13,2)
(164,143,2)
(142,63,2)
(261,47,2)
(231,346,2)
(226,16,2)
(36,13,2)
(151,13,2)
(23,10,2)
(67,318,2)
(256,212,2)
(316,337,2)
(257,101,2)
(224,101,2)
(19,301,2)
(310,63,2)
(62,352,2)
(26,303,2)
(362,289,2)
(66,328,2)
(304,123,2)
(329,101,2)
(377,63,2)
(200,101,2)
(352,318,2)
(73,340,2)
(233,241,2)
(357,256,2)
(64,174,2)
(296,47,2)
(46,328,2)
(203,47,2)
(370,16,2)
(355,123,2)
(296,13,2)
(91,318,2)
(201,318,2)
(340,24,2)
(244,16,2)
(319,101,2)
(389,237,2)
(310,212,2)
(282,174,2)
(162,47,2)
(362,47,2)
(105,101,2)
(312,357,2)
(49,16,2)
(107,354,2)
(2,179,2)
(393,123,2)
(305,274,2)
(86,123,2)
(118,7,2)
(354,340,2)
(154,357,2)
(275,43,2)
(221,174,2)
(185,318,2)
(150,123,2)
(242,183,2)
(333,233,2)
(297,143,2)
(176,258,2)
(88,212,2)
(149,101,2)
(266,174,2)
(278,238,2)
(214,318,2)
(249,63,2)
(258,318,2)
(280,203,2)
(89,47,2)
(43,47,2)
(46,235,2)
(7,270,2)
(242,101,2)
(43,80,2)
(186,303,2)
(188,174,2)
(67,238,2)
(127,11,2)
(293,318,2)
(110,16,2)
(80,47,2)
(9,318,2)
(157,212,2)
(87,13,2)
(274,143,2)
(37,337,2)
(298,101,2)
(287,174,2)
(240,98,2)
(47,203,2)
(368,174,2)
(206,63,2)
(177,337,2)
(163,316,2)
(274,29,2)
(293,16,2)
(292,47,2)
(20,64,2)
(123,143,2)
(203,235,2)
(256,316,2)
(184,123,2)
(174,47,2)
(208,98,2)
(117,340,2)
(282,16,2)
(163,212,2)
(282,340,2)
(16,47,2)
(196,174,2)
(86,318,2)
(142,276,2)
(256,284,2)
(283,144,2)
(108,318,2)
(53,123,2)
(203,374,2)
(24,47,2)
(286,85,2)
(175,174,2)
(114,318,2)
(18,143,2)
(71,274,2)
(320,203,2)
(369,333,2)
(13,340,2)
(209,143,2)
(92,143,2)
(208,212,2)
(115,217,2)
(269,318,2)
(292,381,2)
(339,101,2)
(364,318,2)
(327,174,2)
(133,13,2)
(48,101,2)
(113,306,2)
(229,47,2)
(280,5,2)
(364,238,2)
(210,19,2)
(381,47,2)
(324,101,2)
(331,98,2)
(114,47,2)
(351,101,2)
(394,123,2)
(91,143,2)
(9,212,2)
(163,335,2)
(132,47,2)
(93,143,2)
(158,303,2)
(189,101,2)
(116,101,2)
(2,47,2)
(353,63,2)
(328,13,2)
(349,89,2)
(89,2,2)
(367,340,2)
(148,13,2)
(378,63,2)
(361,101,2)
(129,89,2)
(46,41,2)
(280,374,2)
(10,123,2)
(24,132,2)
(102,89,2)
(4,47,2)
(207,47,2)
(160,16,2)
(51,16,2)
(2,13,2)
(130,174,2)
(10,86,2)
(379,123,2)
(303,238,2)
(268,238,2)
(335,240,2)
(185,123,2)
(34,43,2)
(336,101,2)
(249,318,2)
(339,318,2)
(107,340,2)
(11,201,2)
(321,47,2)
(265,89,2)
(334,364,2)
(388,123,2)
(20,174,2)
(261,13,2)
(64,269,2)
(98,337,2)
(383,143,2)
(303,346,2)
(303,342,2)
(343,235,2)
(333,188,2)
(252,238,2)
(4,123,2)
(171,123,2)
(23,47,2)
(144,238,2)
(169,63,2)
(15,174,2)
(112,238,2)
(283,238,2)
(282,47,2)
(117,13,2)
(300,337,2)
(211,238,2)
(358,340,2)
(153,274,2)
(167,89,2)
(165,43,2)
(136,63,2)
(201,89,2)
(271,238,2)
(97,123,2)
(188,130,2)
(217,128,2)
(32,47,2)
(285,79,2)
(248,174,2)
(33,98,2)
(101,270,2)
(301,101,2)
(210,318,2)
(94,89,2)
(19,101,2)
(200,212,2)
(389,16,2)
(81,203,2)
(340,303,2)
(131,337,2)
(308,346,2)
(174,362,2)
(311,318,2)
(161,63,2)
(117,174,2)
(241,44,2)
(391,89,2)
(89,13,2)
(72,63,2)
(29,318,2)
(280,328,2)
(14,89,2)
(163,336,2)
(17,16,2)
(259,123,2)
(197,318,2)
(12,318,2)
(373,238,2)
(85,238,2)
(203,340,2)
(76,212,2)
(197,174,2)
(100,101,2)
(245,340,2)
(180,318,2)
(10,47,2)
(31,63,2)
(288,174,2)
(344,101,2)
(176,318,2)
(197,233,2)
(354,77,2)
(67,286,2)
(90,63,2)
(380,340,2)
(207,303,2)
(369,188,2)
(45,89,2)
(133,47,2)
(167,318,2)
(179,114,2)
(277,180,2)
(42,340,2)
(203,34,2)
(280,34,2)
(330,101,2)
(203,46,2)
(46,203,2)
(9,357,2)
(188,233,2)
(91,18,2)
(187,98,2)
(130,108,2)
(77,318,2)
(316,131,2)
(314,101,2)
(41,340,2)
(63,220,2)
(203,66,2)
(163,377,2)
(280,41,2)
(236,13,2)
(59,318,2)
(95,89,2)
(325,185,2)
(173,358,2)
(347,100,2)
(264,238,2)
(99,7,2)
(241,318,2)
(140,101,2)
(70,174,2)
(325,123,2)
(375,358,2)
(39,318,2)
(63,98,2)
(385,101,2)
(52,63,2)
(230,89,2)
(203,174,2)
(255,174,2)
(80,292,2)
(282,89,2)
(235,123,2)
(321,303,2)
(325,318,2)
(65,7,2)
(377,90,2)
(68,303,2)
(117,47,2)
(35,337,2)
(306,212,2)
(365,47,2)
(141,16,2)
(16,123,2)
(270,89,2)
(337,270,2)
(100,387,2)
(347,101,2)
(358,212,2)
(157,89,2)
(85,318,2)
(18,318,2)
(320,318,2)
-----------------------------------
(0,lock)
(1,if (!data->error)
(2,test_and_clear_bit(EVENT_DATA_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(3,goto unlock;)
(4,pending_events)
(5,state = STATE_SENDING_DATA)
(6,prev_state)
(7,status & SDMMC_INT_EBE)
(8,data)
(9,send_stop_cmd(host, data)
(10,&host->pending_events)
(11,&host->completed_events)
(12,host->data)
(13,!test_and_clear_bit(EVENT_XFER_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(14,host)
(15,cmd)
(16,!test_and_clear_bit(EVENT_CMD_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(17,host)
(18,host->mrq)
(19,ctrl |= SDMMC_CTRL_FIFO_RESET)
(20,set_bit(EVENT_CMD_COMPLETE, &host->completed_events)
(21,data)
(22,cmd)
(23,test_and_clear_bit(EVENT_CMD_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(24,&host->pending_events)
(25,mrq)
(26,host)
(27,status)
(28,data)
(29,host->mrq)
(30,host)
(31,"data FIFO error "\n\\n\\t\\t\\t\\t\\t\\t"(status=%08x)
(32,host)
(33,data)
(34,state = STATE_DATA_BUSY)
(35,ETIMEDOUT)
(36,EVENT_XFER_COMPLETE)
(37,error)
(38,host)
(39,host->cur_slot)
(40,host)
(41,state = STATE_DATA_ERROR)
(42,break;)
(43,!test_and_clear_bit(EVENT_XFER_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(44,host->cmd = NULL)
(45,NULL)
(46,prev_state = state)
(47,state)
(48,data->error)
(49,host)
(50,break;)
(51,host->cmd)
(52,data->bytes_xfered)
(53,goto unlock;)
(54,ctrl)
(55,)
(56,)
(57,host)
(58,do)
(59,host->state)
(60,pending_events)
(61,state)
(62,&host->lock)
(63,status & SDMMC_INT_EBE &&\n\\n\\t\\t\\t\\t\\t   host->dir_status ==\n\\n\\t\\t\\t\\t\\t\\t\\tDW_MCI_SEND_STATUS)
(64,&host->completed_events)
(65,host)
(66,prev_state = state = STATE_DATA_BUSY)
(67,__dw_mci_start_request(host, host->cur_slot,\n\\n\\t\\t\\t\\t\\t\\t       host->mrq->cmd)
(68,STATE_SENDING_DATA)
(69,status)
(70,EVENT_CMD_COMPLETE)
(71,error)
(72,data->error)
(73,state)
(74,)
(75,)
(76,send_stop_cmd(host, data)
(77,host->pending_events)
(78,)
(79,unsigned long priv)
(80,test_and_clear_bit(EVENT_XFER_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(81,state)
(82,if (!test_and_clear_bit(EVENT_CMD_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(83,if (test_and_clear_bit(EVENT_DATA_ERROR,\n\\n\\t\\t\\t\\t\\t       &host->pending_events)
(84,completed_events)
(85,host->mrq)
(86,host->pending_events)
(87,STATE_DATA_BUSY)
(88,data->blksz)
(89,!test_and_clear_bit(EVENT_DATA_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(90,-ETIMEDOUT)
(91,dw_mci_request_end(host, host->mrq)
(92,host)
(93,mrq)
(94,status)
(95,completed_events)
(96,)
(97,prev_state)
(98,status & SDMMC_INT_DCRC)
(99,host->dir_status)
(100,data->blocks * data->blksz)
(101,status & DW_MCI_DATA_ERROR_FLAGS)
(102,host->data = NULL)
(103,)
(104,case STATE_DATA_BUSY:)
(105,data)
(106,if (!test_and_clear_bit(EVENT_CMD_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(107,test_and_clear_bit(EVENT_XFER_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(108,host->mrq)
(109,ctrl)
(110,stop)
(111,NULL)
(112,cur_slot)
(113,data->stop->error)
(114,host->pending_events)
(115,spin_lock(&host->lock)
(116,status)
(117,prev_state)
(118,DW_MCI_SEND_STATUS)
(119,if (!data->stop)
(120,host)
(121,prev_state)
(122,priv)
(123,host->mrq->sbc && !data->error)
(124,cmd)
(125,-EIO)
(126,host)
(127,set_bit(EVENT_DATA_COMPLETE, &host->completed_events)
(128,host->lock)
(129,stop)
(130,host->mrq->sbc)
(131,-ETIMEDOUT)
(132,host->pending_events)
(133,EVENT_DATA_COMPLETE)
(134,unlock:)
(135,)
(136,status)
(137,state)
(138,0)
(139,host)
(140,blksz)
(141,mrq)
(142,dev_err(&host->dev,\n\\n\\t\\t\\t\\t\\t\\t"data FIFO error "\n\\n\\t\\t\\t\\t\\t\\t"(status=%08x)
(143,!data->stop)
(144,state = STATE_SENDING_CMD)
(145,data)
(146,break;)
(147,host)
(148,prev_state)
(149,host)
(150,STATE_SENDING_STOP)
(151,completed_events)
(152,case STATE_IDLE:)
(153,!data->error)
(154,host)
(155,host)
(156,data)
(157,data->stop)
(158,host)
(159,host)
(160,host->cmd = NULL)
(161,error)
(162,pending_events)
(163,data->error)
(164,host)
(165,STATE_DATA_BUSY)
(166,)
(167,host->data_status)
(168,case STATE_DATA_ERROR:)
(169,dev)
(170,data)
(171,host)
(172,error)
(173,data)
(174,!test_and_clear_bit(EVENT_CMD_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(175,break;)
(176,dw_mci_request_end(host, host->mrq)
(177,SDMMC_INT_DCRC)
(178,spin_unlock(&host->lock)
(179,&host->pending_events)
(180,host->completed_events)
(181,status)
(182,host)
(183,host->sg_miter)
(184,state)
(185,host->mrq)
(186,host)
(187,status)
(188,cmd == host->mrq->sbc)
(189,CTRL)
(190,set_bit(EVENT_XFER_COMPLETE, &host->completed_events)
(191,if (!test_and_clear_bit(EVENT_DATA_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(192,)
(193,EILSEQ)
(194,if (!host->mrq->data || cmd->error)
(195,state)
(196,mrq)
(197,dw_mci_command_complete(host, cmd)
(198,error)
(199,if (cmd == host->mrq->sbc && !cmd->error)
(200,data->bytes_xfered)
(201,host->completed_events)
(202,host)
(203,state != prev_state)
(204,case STATE_SENDING_STOP:)
(205,NULL)
(206,EIO)
(207,EVENT_DATA_ERROR)
(208,data->error)
(209,host)
(210,mci_writel(host, CTRL, ctrl)
(211,cmd)
(212,data = host->data)
(213,mci_readl(host, CTRL)
(214,host->mrq)
(215,data_status)
(216,STATE_SENDING_CMD)
(217,&host->lock)
(218,EVENT_XFER_COMPLETE)
(219,prev_state)
(220,host->dir_status ==\n\\n\\t\\t\\t\\t\\t\\t\\tDW_MCI_SEND_STATUS)
(221,host)
(222,cmd)
(223,state)
(224,host)
(225,case STATE_SENDING_CMD:)
(226,mrq)
(227,host->data)
(228,host)
(229,host)
(230,host)
(231,error)
(232,sbc)
(233,cmd = host->cmd)
(234,prev_state = state = STATE_SENDING_DATA)
(235,state = STATE_SENDING_STOP)
(236,break;)
(237,host->mrq)
(238,cmd == host->mrq->sbc && !cmd->error)
(239,data)
(240,-EILSEQ)
(241,host->cmd)
(242,&host->sg_miter)
(243,host)
(244,goto unlock;)
(245,host)
(246,bytes_xfered)
(247,dir_status)
(248,cmd)
(249,host->dev)
(250,host)
(251,host)
(252,mrq)
(253,error)
(254,data)
(255,cmd)
(256,data->error)
(257,sg_miter)
(258,host->mrq)
(259,mrq)
(260,NULL)
(261,pending_events)
(262,if (!test_and_clear_bit(EVENT_XFER_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(263,host)
(264,prev_state)
(265,EVENT_DATA_COMPLETE)
(266,host->cmd)
(267,host)
(268,host)
(269,host->completed_events)
(270,status = host->data_status)
(271,host)
(272,host)
(273,lock)
(274,host->mrq->sbc)
(275,break;)
(276,&host->dev)
(277,&host->completed_events)
(278,state)
(279,)
(280,host->state = state)
(281,ctrl)
(282,state)
(283,prev_state = state = STATE_SENDING_CMD)
(284,data->error = -EIO)
(285,(struct dw_mci *)
(286,host->mrq->cmd)
(287,cmd)
(288,host)
(289,&host->pending_events)
(290,error)
(291,data)
(292,&host->pending_events)
(293,dw_mci_command_complete(host, host->mrq->stop)
(294,0)
(295,host)
(296,host)
(297,goto unlock;)
(298,blocks)
(299,state)
(300,data->error)
(301,ctrl = mci_readl(host, CTRL)
(302,error)
(303,!host->mrq->data || cmd->error)
(304,error)
(305,data)
(306,data->stop)
(307,if (status & DW_MCI_DATA_ERROR_FLAGS)
(308,cmd)
(309,case STATE_SENDING_DATA:)
(310,data->error)
(311,host->pending_events)
(312,data)
(313,state)
(314,host)
(315,state)
(316,data->error = -ETIMEDOUT)
(317,RET)
(318,*host = (struct dw_mci *)
(319,sg_miter_stop(&host->sg_miter)
(320,host->state)
(321,pending_events)
(322,state)
(323,data)
(324,sg)
(325,dw_mci_request_end(host, host->mrq)
(326,data)
(327,sbc)
(328,state = STATE_DATA_BUSY)
(329,SDMMC_CTRL_FIFO_RESET)
(330,host->sg = NULL)
(331,SDMMC_INT_EBE)
(332,data)
(333,cmd->error)
(334,host->mrq->data)
(335,data->error = -EILSEQ)
(336,data->error = 0)
(337,status & SDMMC_INT_DTO)
(338,0)
(339,host->sg)
(340,test_and_clear_bit(EVENT_DATA_ERROR,\n\\n\\t\\t\\t\\t\\t       &host->pending_events)
(341,ETIMEDOUT)
(342,cmd->error)
(343,prev_state = state = STATE_SENDING_STOP)
(344,CTRL)
(345,if (status & SDMMC_INT_DTO)
(346,!host->mrq->data)
(347,data->bytes_xfered = data->blocks * data->blksz)
(348,if (!test_and_clear_bit(EVENT_XFER_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(349,DW_MCI_DATA_ERROR_FLAGS)
(350,if (host->mrq->sbc && !data->error)
(351,bytes_xfered)
(352,host->lock)
(353,data)
(354,&host->pending_events)
(355,data)
(356,host)
(357,!data->error)
(358,data->stop)
(359,goto unlock;)
(360,)
(361,SDMMC_INT_DTO)
(362,test_and_clear_bit(EVENT_CMD_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(363,struct dw_mci *)
(364,host->mrq)
(365,EVENT_CMD_COMPLETE)
(366,data)
(367,EVENT_XFER_COMPLETE)
(368,cmd)
(369,!cmd->error)
(370,host->mrq->stop)
(371,STATE_DATA_ERROR)
(372,stop)
(373,mrq)
(374,state = host->state)
(375,host)
(376,break;)
(377,data->error = -ETIMEDOUT)
(378,data->bytes_xfered = 0)
(379,EVENT_CMD_COMPLETE)
(380,pending_events)
(381,host->pending_events)
(382,)
(383,mrq)
(384,if (data->stop)
(385,ctrl)
(386,dw_mci_stop_dma(host)
(387,data->blocks)
(388,data)
(389,dw_mci_request_end(host, host->mrq)
(390,switch (state)
(391,break;)
(392,)
(393,stop)
(394,data->stop->error = 0)
(395,host)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^