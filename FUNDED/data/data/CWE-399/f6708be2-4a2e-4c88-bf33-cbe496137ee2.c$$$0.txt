-----label-----
0
-----code-----
Res* evaluateExpression3(Node *expr, int applyAll, int force, ruleExecInfo_t *rei, int reiSaveFlag, Env *env, rError_t* errmsg, Region *r) {
/*
    printTree(expr, 0);
*/
    char errbuf[ERR_MSG_LEN];
    Res *res = newRes(r), *funcRes = NULL, *argRes = NULL;
    FunctionDesc *fd = NULL;
    int i;
    Res **tupleComps = NULL;
    if(force || expr->iotype == IO_TYPE_INPUT) {
		switch(expr->nodeType) {
			case TK_INT:
				res->exprType = newSimpType(T_INT,r);
				res->value.dval=atof(expr->text);
							break;
			case TK_DOUBLE:
				res->exprType = newSimpType(T_DOUBLE,r);
				res->value.dval=atof(expr->text);
							break;
			case TK_STRING:
				res = newStringRes(r, expr->text);
							break;
			case TK_VAR:
					res = evaluateVar3(expr->text, expr, rei, reiSaveFlag,  env, errmsg,r);
					break;
			case TK_TEXT:
					fd = (FunctionDesc *)lookupFromEnv(ruleEngineConfig.extFuncDescIndex, expr->text);
					if(fd!=NULL) {
						int nArgs = 0;
						ExprType *type = fd->exprType;
						while(type->nodeType == T_CONS && strcmp(type->text, FUNC) == 0) {
							type = type->subtrees[1];
							nArgs ++;
						}
						if(nArgs == 0) {
							Node *appNode = newPartialApplication(expr, newTupleRes(0,NULL,r), 0, r);
							res = evaluateFunction3(appNode, applyAll, expr, env, rei, reiSaveFlag, errmsg, r);
						} else {
							res = newFuncSymLink(expr->text, nArgs, r);
						}
					} else {
						res = newFuncSymLink(expr->text, 1, r);
					}
					break;


			case N_APPLICATION:
							/* try to evaluate as a function, */
	/*
							printf("start execing %s\n", oper1);
							printEnvToStdOut(env);

	*/			funcRes = evaluateExpression3(expr->subtrees[0], applyAll, 0, rei, reiSaveFlag, env, errmsg,r);
				if(funcRes->nodeType==N_ERROR) {
					res = funcRes;
					break;
				}
				/* printTree(expr->subtrees[1], 0); */
				argRes = evaluateExpression3(expr->subtrees[1], applyAll, 0, rei, reiSaveFlag, env, errmsg,r);
				if(argRes->nodeType==N_ERROR) {
					res = argRes;
					break;
				}
				res = evaluateFunctionApplication(funcRes, argRes, applyAll, expr, rei, reiSaveFlag, env, errmsg,r);
	/*
							printf("finish execing %s\n", oper1);
							printEnvToStdOut(env);
	*/
							break;
			case N_TUPLE:
				tupleComps = (Res **) region_alloc(r, sizeof(Res *) * expr->degree);
				for(i=0;i<expr->degree;i++) {
					res = tupleComps[i] = evaluateExpression3(expr->subtrees[i], applyAll, 0, rei, reiSaveFlag, env, errmsg, r);
					if(res->nodeType == N_ERROR) {
						break;
					}
				}
				if(expr->degree == 0 || res->nodeType != N_ERROR) {
					if(expr->value.constructTuple || expr->degree != 1) {
						res = newTupleRes(expr->degree, tupleComps, r);
					}
				}
				break;
			case N_ACTIONS_RECOVERY:
							res = evaluateActions(expr->subtrees[0], expr->subtrees[1], rei, reiSaveFlag, env, errmsg, r);
							break;

			case N_ACTIONS:
							generateErrMsg("error: evaluate actions using function evaluateExpression3, use function evaluateActions instead.", expr->expr, expr->base, errbuf);
							addRErrorMsg(errmsg, -1, errbuf);
							res = newErrorRes(r, -1);
							break;
					default:
							generateErrMsg("error: unsupported ast node type.", expr->expr, expr->base, errbuf);
							addRErrorMsg(errmsg, -1, errbuf);
							res = newErrorRes(r, -1);
							break;
		}
    } else {
    	res = expr;
    	while(res->nodeType == N_TUPLE && res->degree == 1) {
    		res = res->subtrees[0];
    	}
    }
        /* coercions are applied at application locations only */
        return res;
}
-----children-----
1,2
1,3
1,4
2,3
4,5
4,6
4,7
4,8
4,9
4,10
4,11
4,12
4,13
4,14
7,8
7,9
8,9
10,11
10,12
13,14
13,15
15,16
17,18
17,19
19,20
21,22
21,23
22,23
24,25
24,26
27,28
27,29
29,30
31,32
31,33
32,33
34,35
34,36
37,38
37,39
38,39
40,41
40,42
43,44
43,45
44,45
46,47
46,48
49,50
49,51
49,52
49,53
49,54
49,55
49,56
50,51
51,52
51,53
53,54
53,55
55,56
56,57
58,59
59,60
59,61
59,62
59,63
60,61
62,63
62,64
62,65
65,66
66,67
66,68
67,68
69,70
71,72
71,73
71,74
74,75
75,76
77,78
77,79
77,80
80,81
81,82
83,84
84,85
84,86
85,86
87,88
87,89
87,90
90,91
91,92
93,94
94,95
94,96
96,97
98,99
99,100
99,101
100,101
102,103
102,104
102,105
102,106
106,107
107,108
109,110
109,111
109,112
110,111
110,112
111,112
113,114
113,115
114,115
114,116
115,116
118,119
120,121
121,122
121,123
122,123
122,124
123,124
126,127
126,128
126,129
126,130
126,131
126,132
126,133
126,134
126,135
126,136
126,137
126,138
126,139
126,140
126,141
126,142
126,143
126,144
126,145
126,146
126,147
126,148
126,149
126,150
126,151
126,152
126,153
126,154
126,155
126,156
126,157
126,158
126,159
126,160
126,161
126,162
126,163
126,164
126,165
126,166
126,167
126,168
126,169
127,128
128,129
130,131
131,132
131,133
132,133
132,134
133,134
136,137
136,138
136,139
137,138
139,140
141,142
143,144
144,145
144,146
145,146
145,147
146,147
146,148
147,148
151,152
151,153
152,153
154,155
154,156
155,156
159,160
160,161
162,163
163,164
163,165
164,165
164,166
165,166
168,169
168,170
168,171
169,170
171,172
173,174
175,176
176,177
176,178
177,178
177,179
178,179
178,180
179,180
183,184
183,185
184,185
186,187
186,188
187,188
191,192
192,193
194,195
195,196
195,197
196,197
198,199
198,200
198,201
199,200
201,202
203,204
203,205
204,205
208,209
209,210
211,212
212,213
212,214
213,214
215,216
215,217
215,218
215,219
215,220
215,221
215,222
215,223
216,217
218,219
218,220
219,220
222,223
224,225
226,227
228,229
230,231
232,233
235,236
236,237
238,239
239,240
239,241
240,241
242,243
242,244
243,244
243,245
244,245
246,247
248,249
248,250
248,251
249,250
251,252
251,253
252,253
255,256
255,257
256,257
259,260
259,261
259,262
260,261
260,262
261,262
263,264
265,266
265,267
265,268
265,269
266,267
267,268
267,269
269,270
269,271
271,272
273,274
274,275
274,276
275,276
277,278
277,279
277,280
280,281
281,282
281,283
282,283
285,286
285,287
286,287
286,288
287,288
287,289
288,289
288,290
289,290
292,293
294,295
294,296
295,296
295,297
295,298
296,297
298,299
298,300
299,300
302,303
305,306
305,307
306,307
307,308
307,309
308,309
310,311
310,312
311,312
311,313
312,313
316,317
317,318
318,319
320,321
320,322
320,323
321,322
321,323
322,323
325,326
325,327
326,327
327,328
327,329
328,329
330,331
330,332
330,333
333,334
334,335
334,336
334,337
334,338
334,339
335,336
337,338
339,340
339,341
339,342
339,343
340,341
343,344
345,346
348,349
350,351
351,352
351,353
352,353
354,355
354,356
354,357
354,358
354,359
354,360
354,361
354,362
354,363
355,356
357,358
359,360
361,362
363,364
365,366
367,368
369,370
371,372
373,374
374,375
375,376
375,377
376,377
378,379
378,380
378,381
378,382
379,380
381,382
381,383
382,383
385,386
387,388
389,390
390,391
391,392
391,393
392,393
394,395
394,396
394,397
394,398
395,396
397,398
397,399
398,399
402,403
405,406
406,407
408,409
409,410
409,411
410,411
412,413
412,414
412,415
412,416
412,417
412,418
412,419
412,420
412,421
413,414
415,416
415,417
416,417
416,418
417,418
421,422
424,425
426,427
428,429
430,431
432,433
434,435
434,436
435,436
435,437
436,437
436,438
437,438
440,441
442,443
442,444
443,444
444,445
444,446
445,446
447,448
450,451
451,452
451,453
452,453
454,455
454,456
454,457
454,458
454,459
454,460
454,461
454,462
454,463
455,456
457,458
457,459
458,459
458,460
459,460
463,464
466,467
468,469
470,471
472,473
474,475
476,477
476,478
477,478
477,479
478,479
478,480
479,480
482,483
484,485
484,486
485,486
486,487
486,488
487,488
489,490
492,493
493,494
493,495
494,495
496,497
496,498
496,499
496,500
496,501
496,502
496,503
496,504
496,505
496,506
497,498
499,500
501,502
503,504
505,506
507,508
509,510
511,512
513,514
515,516
518,519
519,520
521,522
522,523
522,524
523,524
525,526
525,527
526,527
526,528
527,528
529,530
529,531
532,533
532,534
532,535
533,534
535,536
537,538
537,539
538,539
539,540
539,541
540,541
542,543
544,545
544,546
545,546
548,549
548,550
548,551
548,552
549,550
550,551
550,552
551,552
554,555
554,556
555,556
557,558
557,559
558,559
561,562
562,563
564,565
564,566
565,566
566,567
566,568
567,568
569,570
569,571
570,571
570,572
571,572
573,574
575,576
575,577
575,578
575,579
575,580
575,581
575,582
575,583
575,584
576,577
578,579
578,580
579,580
579,581
580,581
583,584
585,586
588,589
590,591
592,593
594,595
596,597
598,599
598,600
599,600
599,601
600,601
600,602
601,602
604,605
606,607
608,609
608,610
609,610
609,611
610,611
610,612
611,612
611,613
612,613
616,617
616,618
617,618
617,619
618,619
621,622
623,624
624,625
624,626
625,626
625,627
626,627
626,628
627,628
627,629
628,629
632,633
632,634
633,634
633,635
634,635
638,639
639,640
640,641
640,642
641,642
643,644
643,645
643,646
643,647
644,645
646,647
646,648
647,648
650,651
652,653
655,656
656,657
658,659
659,660
659,661
660,661
662,663
662,664
662,665
662,666
662,667
662,668
662,669
662,670
663,664
665,666
665,667
666,667
666,668
667,668
671,672
671,673
672,673
672,674
673,674
677,678
679,680
681,682
683,684
685,686
688,689
689,690
691,692
692,693
692,694
692,695
692,696
692,697
693,694
696,697
696,698
697,698
700,701
700,702
701,702
704,705
706,707
707,708
707,709
707,710
707,711
708,709
710,711
712,713
714,715
716,717
717,718
717,719
718,719
720,721
720,722
720,723
721,722
723,724
725,726
729,730
730,731
730,732
730,733
730,734
730,735
731,732
734,735
734,736
735,736
738,739
738,740
739,740
742,743
744,745
745,746
745,747
745,748
745,749
746,747
748,749
750,751
752,753
754,755
755,756
755,757
756,757
758,759
758,760
758,761
759,760
761,762
763,764
766,767
766,768
767,768
768,769
768,770
769,770
771,772
773,774
773,775
774,775
774,776
775,776
775,777
776,777
776,778
777,778
780,781
782,783
782,784
783,784
783,785
784,785
788,789
789,790
790,791
790,792
791,792
793,794
793,795
794,795
794,796
795,796
799,800
800,801
-----nextToken-----
3,5,6,9,11,12,14,16,18,20,23,25,26,28,30,33,35,36,39,41,42,45,47,48,52,54,57,61,63,64,68,70,72,73,76,78,79,82,86,88,89,92,95,97,101,103,104,105,108,112,116,117,119,124,125,129,134,135,138,140,142,148,149,150,153,156,157,158,161,166,167,170,172,174,180,181,182,185,188,189,190,193,197,200,202,205,206,207,210,214,217,220,221,223,225,227,229,231,233,234,237,241,245,247,250,253,254,257,258,262,264,268,270,272,276,278,279,283,284,290,291,293,297,300,301,303,304,309,313,314,315,319,323,324,329,331,332,336,338,341,342,344,346,347,349,353,356,358,360,362,364,366,368,370,372,377,380,383,384,386,388,393,396,399,400,401,403,404,407,411,414,418,419,420,422,423,425,427,429,431,433,438,439,441,446,448,449,453,456,460,461,462,464,465,467,469,471,473,475,480,481,483,488,490,491,495,498,500,502,504,506,508,510,512,514,516,517,520,524,528,530,531,534,536,541,543,546,547,552,553,556,559,560,563,568,572,574,577,581,582,584,586,587,589,591,593,595,597,602,603,605,607,613,614,615,619,620,622,629,630,631,635,636,637,642,645,648,649,651,653,654,657,661,664,668,669,670,674,675,676,678,680,682,684,686,687,690,694,695,698,699,702,703,705,709,711,713,715,719,722,724,726,727,728,732,733,736,737,740,741,743,747,749,751,753,757,760,762,764,765,770,772,778,779,781,785,786,787,792,796,797,798,801
-----computeFrom-----
110,111
110,112
113,114
113,115
131,132
131,133
144,145
144,146
163,164
163,165
176,177
176,178
195,196
195,197
212,213
212,214
239,240
239,241
260,261
260,262
286,287
286,288
287,288
287,289
294,295
294,296
307,308
307,309
321,322
321,323
351,352
351,353
375,376
375,377
391,392
391,393
409,410
409,411
435,436
435,437
444,445
444,446
451,452
451,453
477,478
477,479
486,487
486,488
493,494
493,495
522,523
522,524
537,538
537,539
550,551
550,552
554,555
554,556
566,567
566,568
569,570
569,571
599,600
599,601
609,610
609,611
610,611
610,612
616,617
616,618
625,626
625,627
632,633
632,634
640,641
640,642
659,660
659,661
717,718
717,719
755,756
755,757
768,769
768,770
774,775
774,776
775,776
775,777
782,783
782,784
790,791
790,792
-----guardedBy-----
116,740
264,344
262,283
438,448
480,490
619,642
614,649
613,648
636,649
635,648
-----guardedByNegation-----
116,772
323,386
-----lastLexicalUse-----
116,772
-----jump-----
116,772
-----attribute-----
FunctionDefinition;NamedTypeSpecifier;Name;FunctionDeclarator;Pointer;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;IdExpression;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Pointer;Name;EqualsInitializer;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;SwitchStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;CaseStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;Pointer;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FieldReference;IdExpression;Name;Name;WhileStatement;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BreakStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BreakStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;Pointer;Pointer;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;Pointer;FieldReference;IdExpression;Name;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;BreakStatement;IfStatement;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;LiteralExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;LiteralExpression;BreakStatement;DefaultStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;LiteralExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;LiteralExpression;BreakStatement;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;WhileStatement;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ReturnStatement;IdExpression;Name;
-----ast_node-----
Res* evaluateExpression3(Node *expr, int applyAll, int force, ruleExecInfo_t *rei, int reiSaveFlag, Env *env, rError_t* errmsg, Region *r) {/*    printTree(expr, 0);*/    char errbuf[ERR_MSG_LEN];    Res *res = newRes(r), *funcRes = NULL, *argRes = NULL;    FunctionDesc *fd = NULL;    int i;    Res **tupleComps = NULL;    if(force || expr->iotype == IO_TYPE_INPUT) {		switch(expr->nodeType) {			case TK_INT:				res->exprType = newSimpType(T_INT,r);				res->value.dval=atof(expr->text);							break;			case TK_DOUBLE:				res->exprType = newSimpType(T_DOUBLE,r);				res->value.dval=atof(expr->text);							break;			case TK_STRING:				res = newStringRes(r, expr->text);							break;			case TK_VAR:					res = evaluateVar3(expr->text, expr, rei, reiSaveFlag,  env, errmsg,r);					break;			case TK_TEXT:					fd = (FunctionDesc *)lookupFromEnv(ruleEngineConfig.extFuncDescIndex, expr->text);					if(fd!=NULL) {						int nArgs = 0;						ExprType *type = fd->exprType;						while(type->nodeType == T_CONS && strcmp(type->text, FUNC) == 0) {							type = type->subtrees[1];							nArgs ++;						}						if(nArgs == 0) {							Node *appNode = newPartialApplication(expr, newTupleRes(0,NULL,r), 0, r);							res = evaluateFunction3(appNode, applyAll, expr, env, rei, reiSaveFlag, errmsg, r);						} else {							res = newFuncSymLink(expr->text, nArgs, r);						}					} else {						res = newFuncSymLink(expr->text, 1, r);					}					break;			case N_APPLICATION:							/* try to evaluate as a function, */	/*							printf("start execing %s\n", oper1);							printEnvToStdOut(env);	*/			funcRes = evaluateExpression3(expr->subtrees[0], applyAll, 0, rei, reiSaveFlag, env, errmsg,r);				if(funcRes->nodeType==N_ERROR) {					res = funcRes;					break;				}				/* printTree(expr->subtrees[1], 0); */				argRes = evaluateExpression3(expr->subtrees[1], applyAll, 0, rei, reiSaveFlag, env, errmsg,r);				if(argRes->nodeType==N_ERROR) {					res = argRes;					break;				}				res = evaluateFunctionApplication(funcRes, argRes, applyAll, expr, rei, reiSaveFlag, env, errmsg,r);	/*							printf("finish execing %s\n", oper1);							printEnvToStdOut(env);	*/							break;			case N_TUPLE:				tupleComps = (Res **) region_alloc(r, sizeof(Res *) * expr->degree);				for(i=0;i<expr->degree;i++) {					res = tupleComps[i] = evaluateExpression3(expr->subtrees[i], applyAll, 0, rei, reiSaveFlag, env, errmsg, r);					if(res->nodeType == N_ERROR) {						break;					}				}				if(expr->degree == 0 || res->nodeType != N_ERROR) {					if(expr->value.constructTuple || expr->degree != 1) {						res = newTupleRes(expr->degree, tupleComps, r);					}				}				break;			case N_ACTIONS_RECOVERY:							res = evaluateActions(expr->subtrees[0], expr->subtrees[1], rei, reiSaveFlag, env, errmsg, r);							break;			case N_ACTIONS:							generateErrMsg("error: evaluate actions using function evaluateExpression3, use function evaluateActions instead.", expr->expr, expr->base, errbuf);							addRErrorMsg(errmsg, -1, errbuf);							res = newErrorRes(r, -1);							break;					default:							generateErrMsg("error: unsupported ast node type.", expr->expr, expr->base, errbuf);							addRErrorMsg(errmsg, -1, errbuf);							res = newErrorRes(r, -1);							break;		}    } else {    	res = expr;    	while(res->nodeType == N_TUPLE && res->degree == 1) {    		res = res->subtrees[0];    	}    }        /* coercions are applied at application locations only */        return res;}
Res
Res
* evaluateExpression3(Node *expr, int applyAll, int force, ruleExecInfo_t *rei, int reiSaveFlag, Env *env, rError_t* errmsg, Region *r)
*
evaluateExpression3
Node *expr
Node
Node
*expr
*
expr
int applyAll
int
applyAll
applyAll
int force
int
force
force
ruleExecInfo_t *rei
ruleExecInfo_t
ruleExecInfo_t
*rei
*
rei
int reiSaveFlag
int
reiSaveFlag
reiSaveFlag
Env *env
Env
Env
*env
*
env
rError_t* errmsg
rError_t
rError_t
* errmsg
*
errmsg
Region *r
Region
Region
*r
*
r
{/*    printTree(expr, 0);*/    char errbuf[ERR_MSG_LEN];    Res *res = newRes(r), *funcRes = NULL, *argRes = NULL;    FunctionDesc *fd = NULL;    int i;    Res **tupleComps = NULL;    if(force || expr->iotype == IO_TYPE_INPUT) {		switch(expr->nodeType) {			case TK_INT:				res->exprType = newSimpType(T_INT,r);				res->value.dval=atof(expr->text);							break;			case TK_DOUBLE:				res->exprType = newSimpType(T_DOUBLE,r);				res->value.dval=atof(expr->text);							break;			case TK_STRING:				res = newStringRes(r, expr->text);							break;			case TK_VAR:					res = evaluateVar3(expr->text, expr, rei, reiSaveFlag,  env, errmsg,r);					break;			case TK_TEXT:					fd = (FunctionDesc *)lookupFromEnv(ruleEngineConfig.extFuncDescIndex, expr->text);					if(fd!=NULL) {						int nArgs = 0;						ExprType *type = fd->exprType;						while(type->nodeType == T_CONS && strcmp(type->text, FUNC) == 0) {							type = type->subtrees[1];							nArgs ++;						}						if(nArgs == 0) {							Node *appNode = newPartialApplication(expr, newTupleRes(0,NULL,r), 0, r);							res = evaluateFunction3(appNode, applyAll, expr, env, rei, reiSaveFlag, errmsg, r);						} else {							res = newFuncSymLink(expr->text, nArgs, r);						}					} else {						res = newFuncSymLink(expr->text, 1, r);					}					break;			case N_APPLICATION:							/* try to evaluate as a function, */	/*							printf("start execing %s\n", oper1);							printEnvToStdOut(env);	*/			funcRes = evaluateExpression3(expr->subtrees[0], applyAll, 0, rei, reiSaveFlag, env, errmsg,r);				if(funcRes->nodeType==N_ERROR) {					res = funcRes;					break;				}				/* printTree(expr->subtrees[1], 0); */				argRes = evaluateExpression3(expr->subtrees[1], applyAll, 0, rei, reiSaveFlag, env, errmsg,r);				if(argRes->nodeType==N_ERROR) {					res = argRes;					break;				}				res = evaluateFunctionApplication(funcRes, argRes, applyAll, expr, rei, reiSaveFlag, env, errmsg,r);	/*							printf("finish execing %s\n", oper1);							printEnvToStdOut(env);	*/							break;			case N_TUPLE:				tupleComps = (Res **) region_alloc(r, sizeof(Res *) * expr->degree);				for(i=0;i<expr->degree;i++) {					res = tupleComps[i] = evaluateExpression3(expr->subtrees[i], applyAll, 0, rei, reiSaveFlag, env, errmsg, r);					if(res->nodeType == N_ERROR) {						break;					}				}				if(expr->degree == 0 || res->nodeType != N_ERROR) {					if(expr->value.constructTuple || expr->degree != 1) {						res = newTupleRes(expr->degree, tupleComps, r);					}				}				break;			case N_ACTIONS_RECOVERY:							res = evaluateActions(expr->subtrees[0], expr->subtrees[1], rei, reiSaveFlag, env, errmsg, r);							break;			case N_ACTIONS:							generateErrMsg("error: evaluate actions using function evaluateExpression3, use function evaluateActions instead.", expr->expr, expr->base, errbuf);							addRErrorMsg(errmsg, -1, errbuf);							res = newErrorRes(r, -1);							break;					default:							generateErrMsg("error: unsupported ast node type.", expr->expr, expr->base, errbuf);							addRErrorMsg(errmsg, -1, errbuf);							res = newErrorRes(r, -1);							break;		}    } else {    	res = expr;    	while(res->nodeType == N_TUPLE && res->degree == 1) {    		res = res->subtrees[0];    	}    }        /* coercions are applied at application locations only */        return res;}
char errbuf[ERR_MSG_LEN];
char errbuf[ERR_MSG_LEN];
char
errbuf[ERR_MSG_LEN]
errbuf
[ERR_MSG_LEN]
ERR_MSG_LEN
ERR_MSG_LEN
Res *res = newRes(r), *funcRes = NULL, *argRes = NULL;
Res *res = newRes(r), *funcRes = NULL, *argRes = NULL;
Res
Res
*res = newRes(r)
*
res
= newRes(r)
newRes(r)
newRes
newRes
r
r
*funcRes = NULL
*
funcRes
= NULL
NULL
NULL
*argRes = NULL
*
argRes
= NULL
NULL
NULL
FunctionDesc *fd = NULL;
FunctionDesc *fd = NULL;
FunctionDesc
FunctionDesc
*fd = NULL
*
fd
= NULL
NULL
NULL
int i;
int i;
int
i
i
Res **tupleComps = NULL;
Res **tupleComps = NULL;
Res
Res
**tupleComps = NULL
*
*
tupleComps
= NULL
NULL
NULL
if(force || expr->iotype == IO_TYPE_INPUT) {		switch(expr->nodeType) {			case TK_INT:				res->exprType = newSimpType(T_INT,r);				res->value.dval=atof(expr->text);							break;			case TK_DOUBLE:				res->exprType = newSimpType(T_DOUBLE,r);				res->value.dval=atof(expr->text);							break;			case TK_STRING:				res = newStringRes(r, expr->text);							break;			case TK_VAR:					res = evaluateVar3(expr->text, expr, rei, reiSaveFlag,  env, errmsg,r);					break;			case TK_TEXT:					fd = (FunctionDesc *)lookupFromEnv(ruleEngineConfig.extFuncDescIndex, expr->text);					if(fd!=NULL) {						int nArgs = 0;						ExprType *type = fd->exprType;						while(type->nodeType == T_CONS && strcmp(type->text, FUNC) == 0) {							type = type->subtrees[1];							nArgs ++;						}						if(nArgs == 0) {							Node *appNode = newPartialApplication(expr, newTupleRes(0,NULL,r), 0, r);							res = evaluateFunction3(appNode, applyAll, expr, env, rei, reiSaveFlag, errmsg, r);						} else {							res = newFuncSymLink(expr->text, nArgs, r);						}					} else {						res = newFuncSymLink(expr->text, 1, r);					}					break;			case N_APPLICATION:							/* try to evaluate as a function, */	/*							printf("start execing %s\n", oper1);							printEnvToStdOut(env);	*/			funcRes = evaluateExpression3(expr->subtrees[0], applyAll, 0, rei, reiSaveFlag, env, errmsg,r);				if(funcRes->nodeType==N_ERROR) {					res = funcRes;					break;				}				/* printTree(expr->subtrees[1], 0); */				argRes = evaluateExpression3(expr->subtrees[1], applyAll, 0, rei, reiSaveFlag, env, errmsg,r);				if(argRes->nodeType==N_ERROR) {					res = argRes;					break;				}				res = evaluateFunctionApplication(funcRes, argRes, applyAll, expr, rei, reiSaveFlag, env, errmsg,r);	/*							printf("finish execing %s\n", oper1);							printEnvToStdOut(env);	*/							break;			case N_TUPLE:				tupleComps = (Res **) region_alloc(r, sizeof(Res *) * expr->degree);				for(i=0;i<expr->degree;i++) {					res = tupleComps[i] = evaluateExpression3(expr->subtrees[i], applyAll, 0, rei, reiSaveFlag, env, errmsg, r);					if(res->nodeType == N_ERROR) {						break;					}				}				if(expr->degree == 0 || res->nodeType != N_ERROR) {					if(expr->value.constructTuple || expr->degree != 1) {						res = newTupleRes(expr->degree, tupleComps, r);					}				}				break;			case N_ACTIONS_RECOVERY:							res = evaluateActions(expr->subtrees[0], expr->subtrees[1], rei, reiSaveFlag, env, errmsg, r);							break;			case N_ACTIONS:							generateErrMsg("error: evaluate actions using function evaluateExpression3, use function evaluateActions instead.", expr->expr, expr->base, errbuf);							addRErrorMsg(errmsg, -1, errbuf);							res = newErrorRes(r, -1);							break;					default:							generateErrMsg("error: unsupported ast node type.", expr->expr, expr->base, errbuf);							addRErrorMsg(errmsg, -1, errbuf);							res = newErrorRes(r, -1);							break;		}    } else {    	res = expr;    	while(res->nodeType == N_TUPLE && res->degree == 1) {    		res = res->subtrees[0];    	}    }
force || expr->iotype == IO_TYPE_INPUT
force
force
expr->iotype == IO_TYPE_INPUT
expr->iotype
expr
expr
iotype
IO_TYPE_INPUT
IO_TYPE_INPUT
{		switch(expr->nodeType) {			case TK_INT:				res->exprType = newSimpType(T_INT,r);				res->value.dval=atof(expr->text);							break;			case TK_DOUBLE:				res->exprType = newSimpType(T_DOUBLE,r);				res->value.dval=atof(expr->text);							break;			case TK_STRING:				res = newStringRes(r, expr->text);							break;			case TK_VAR:					res = evaluateVar3(expr->text, expr, rei, reiSaveFlag,  env, errmsg,r);					break;			case TK_TEXT:					fd = (FunctionDesc *)lookupFromEnv(ruleEngineConfig.extFuncDescIndex, expr->text);					if(fd!=NULL) {						int nArgs = 0;						ExprType *type = fd->exprType;						while(type->nodeType == T_CONS && strcmp(type->text, FUNC) == 0) {							type = type->subtrees[1];							nArgs ++;						}						if(nArgs == 0) {							Node *appNode = newPartialApplication(expr, newTupleRes(0,NULL,r), 0, r);							res = evaluateFunction3(appNode, applyAll, expr, env, rei, reiSaveFlag, errmsg, r);						} else {							res = newFuncSymLink(expr->text, nArgs, r);						}					} else {						res = newFuncSymLink(expr->text, 1, r);					}					break;			case N_APPLICATION:							/* try to evaluate as a function, */	/*							printf("start execing %s\n", oper1);							printEnvToStdOut(env);	*/			funcRes = evaluateExpression3(expr->subtrees[0], applyAll, 0, rei, reiSaveFlag, env, errmsg,r);				if(funcRes->nodeType==N_ERROR) {					res = funcRes;					break;				}				/* printTree(expr->subtrees[1], 0); */				argRes = evaluateExpression3(expr->subtrees[1], applyAll, 0, rei, reiSaveFlag, env, errmsg,r);				if(argRes->nodeType==N_ERROR) {					res = argRes;					break;				}				res = evaluateFunctionApplication(funcRes, argRes, applyAll, expr, rei, reiSaveFlag, env, errmsg,r);	/*							printf("finish execing %s\n", oper1);							printEnvToStdOut(env);	*/							break;			case N_TUPLE:				tupleComps = (Res **) region_alloc(r, sizeof(Res *) * expr->degree);				for(i=0;i<expr->degree;i++) {					res = tupleComps[i] = evaluateExpression3(expr->subtrees[i], applyAll, 0, rei, reiSaveFlag, env, errmsg, r);					if(res->nodeType == N_ERROR) {						break;					}				}				if(expr->degree == 0 || res->nodeType != N_ERROR) {					if(expr->value.constructTuple || expr->degree != 1) {						res = newTupleRes(expr->degree, tupleComps, r);					}				}				break;			case N_ACTIONS_RECOVERY:							res = evaluateActions(expr->subtrees[0], expr->subtrees[1], rei, reiSaveFlag, env, errmsg, r);							break;			case N_ACTIONS:							generateErrMsg("error: evaluate actions using function evaluateExpression3, use function evaluateActions instead.", expr->expr, expr->base, errbuf);							addRErrorMsg(errmsg, -1, errbuf);							res = newErrorRes(r, -1);							break;					default:							generateErrMsg("error: unsupported ast node type.", expr->expr, expr->base, errbuf);							addRErrorMsg(errmsg, -1, errbuf);							res = newErrorRes(r, -1);							break;		}    }
switch(expr->nodeType) {			case TK_INT:				res->exprType = newSimpType(T_INT,r);				res->value.dval=atof(expr->text);							break;			case TK_DOUBLE:				res->exprType = newSimpType(T_DOUBLE,r);				res->value.dval=atof(expr->text);							break;			case TK_STRING:				res = newStringRes(r, expr->text);							break;			case TK_VAR:					res = evaluateVar3(expr->text, expr, rei, reiSaveFlag,  env, errmsg,r);					break;			case TK_TEXT:					fd = (FunctionDesc *)lookupFromEnv(ruleEngineConfig.extFuncDescIndex, expr->text);					if(fd!=NULL) {						int nArgs = 0;						ExprType *type = fd->exprType;						while(type->nodeType == T_CONS && strcmp(type->text, FUNC) == 0) {							type = type->subtrees[1];							nArgs ++;						}						if(nArgs == 0) {							Node *appNode = newPartialApplication(expr, newTupleRes(0,NULL,r), 0, r);							res = evaluateFunction3(appNode, applyAll, expr, env, rei, reiSaveFlag, errmsg, r);						} else {							res = newFuncSymLink(expr->text, nArgs, r);						}					} else {						res = newFuncSymLink(expr->text, 1, r);					}					break;			case N_APPLICATION:							/* try to evaluate as a function, */	/*							printf("start execing %s\n", oper1);							printEnvToStdOut(env);	*/			funcRes = evaluateExpression3(expr->subtrees[0], applyAll, 0, rei, reiSaveFlag, env, errmsg,r);				if(funcRes->nodeType==N_ERROR) {					res = funcRes;					break;				}				/* printTree(expr->subtrees[1], 0); */				argRes = evaluateExpression3(expr->subtrees[1], applyAll, 0, rei, reiSaveFlag, env, errmsg,r);				if(argRes->nodeType==N_ERROR) {					res = argRes;					break;				}				res = evaluateFunctionApplication(funcRes, argRes, applyAll, expr, rei, reiSaveFlag, env, errmsg,r);	/*							printf("finish execing %s\n", oper1);							printEnvToStdOut(env);	*/							break;			case N_TUPLE:				tupleComps = (Res **) region_alloc(r, sizeof(Res *) * expr->degree);				for(i=0;i<expr->degree;i++) {					res = tupleComps[i] = evaluateExpression3(expr->subtrees[i], applyAll, 0, rei, reiSaveFlag, env, errmsg, r);					if(res->nodeType == N_ERROR) {						break;					}				}				if(expr->degree == 0 || res->nodeType != N_ERROR) {					if(expr->value.constructTuple || expr->degree != 1) {						res = newTupleRes(expr->degree, tupleComps, r);					}				}				break;			case N_ACTIONS_RECOVERY:							res = evaluateActions(expr->subtrees[0], expr->subtrees[1], rei, reiSaveFlag, env, errmsg, r);							break;			case N_ACTIONS:							generateErrMsg("error: evaluate actions using function evaluateExpression3, use function evaluateActions instead.", expr->expr, expr->base, errbuf);							addRErrorMsg(errmsg, -1, errbuf);							res = newErrorRes(r, -1);							break;					default:							generateErrMsg("error: unsupported ast node type.", expr->expr, expr->base, errbuf);							addRErrorMsg(errmsg, -1, errbuf);							res = newErrorRes(r, -1);							break;		}
expr->nodeType
expr
expr
nodeType
{			case TK_INT:				res->exprType = newSimpType(T_INT,r);				res->value.dval=atof(expr->text);							break;			case TK_DOUBLE:				res->exprType = newSimpType(T_DOUBLE,r);				res->value.dval=atof(expr->text);							break;			case TK_STRING:				res = newStringRes(r, expr->text);							break;			case TK_VAR:					res = evaluateVar3(expr->text, expr, rei, reiSaveFlag,  env, errmsg,r);					break;			case TK_TEXT:					fd = (FunctionDesc *)lookupFromEnv(ruleEngineConfig.extFuncDescIndex, expr->text);					if(fd!=NULL) {						int nArgs = 0;						ExprType *type = fd->exprType;						while(type->nodeType == T_CONS && strcmp(type->text, FUNC) == 0) {							type = type->subtrees[1];							nArgs ++;						}						if(nArgs == 0) {							Node *appNode = newPartialApplication(expr, newTupleRes(0,NULL,r), 0, r);							res = evaluateFunction3(appNode, applyAll, expr, env, rei, reiSaveFlag, errmsg, r);						} else {							res = newFuncSymLink(expr->text, nArgs, r);						}					} else {						res = newFuncSymLink(expr->text, 1, r);					}					break;			case N_APPLICATION:							/* try to evaluate as a function, */	/*							printf("start execing %s\n", oper1);							printEnvToStdOut(env);	*/			funcRes = evaluateExpression3(expr->subtrees[0], applyAll, 0, rei, reiSaveFlag, env, errmsg,r);				if(funcRes->nodeType==N_ERROR) {					res = funcRes;					break;				}				/* printTree(expr->subtrees[1], 0); */				argRes = evaluateExpression3(expr->subtrees[1], applyAll, 0, rei, reiSaveFlag, env, errmsg,r);				if(argRes->nodeType==N_ERROR) {					res = argRes;					break;				}				res = evaluateFunctionApplication(funcRes, argRes, applyAll, expr, rei, reiSaveFlag, env, errmsg,r);	/*							printf("finish execing %s\n", oper1);							printEnvToStdOut(env);	*/							break;			case N_TUPLE:				tupleComps = (Res **) region_alloc(r, sizeof(Res *) * expr->degree);				for(i=0;i<expr->degree;i++) {					res = tupleComps[i] = evaluateExpression3(expr->subtrees[i], applyAll, 0, rei, reiSaveFlag, env, errmsg, r);					if(res->nodeType == N_ERROR) {						break;					}				}				if(expr->degree == 0 || res->nodeType != N_ERROR) {					if(expr->value.constructTuple || expr->degree != 1) {						res = newTupleRes(expr->degree, tupleComps, r);					}				}				break;			case N_ACTIONS_RECOVERY:							res = evaluateActions(expr->subtrees[0], expr->subtrees[1], rei, reiSaveFlag, env, errmsg, r);							break;			case N_ACTIONS:							generateErrMsg("error: evaluate actions using function evaluateExpression3, use function evaluateActions instead.", expr->expr, expr->base, errbuf);							addRErrorMsg(errmsg, -1, errbuf);							res = newErrorRes(r, -1);							break;					default:							generateErrMsg("error: unsupported ast node type.", expr->expr, expr->base, errbuf);							addRErrorMsg(errmsg, -1, errbuf);							res = newErrorRes(r, -1);							break;		}
case TK_INT:
TK_INT
TK_INT
res->exprType = newSimpType(T_INT,r);
res->exprType = newSimpType(T_INT,r)
res->exprType
res
res
exprType
newSimpType(T_INT,r)
newSimpType
newSimpType
T_INT
T_INT
r
r
res->value.dval=atof(expr->text);
res->value.dval=atof(expr->text)
res->value.dval
res->value
res
res
value
dval
atof(expr->text)
atof
atof
expr->text
expr
expr
text
break;
case TK_DOUBLE:
TK_DOUBLE
TK_DOUBLE
res->exprType = newSimpType(T_DOUBLE,r);
res->exprType = newSimpType(T_DOUBLE,r)
res->exprType
res
res
exprType
newSimpType(T_DOUBLE,r)
newSimpType
newSimpType
T_DOUBLE
T_DOUBLE
r
r
res->value.dval=atof(expr->text);
res->value.dval=atof(expr->text)
res->value.dval
res->value
res
res
value
dval
atof(expr->text)
atof
atof
expr->text
expr
expr
text
break;
case TK_STRING:
TK_STRING
TK_STRING
res = newStringRes(r, expr->text);
res = newStringRes(r, expr->text)
res
res
newStringRes(r, expr->text)
newStringRes
newStringRes
r
r
expr->text
expr
expr
text
break;
case TK_VAR:
TK_VAR
TK_VAR
res = evaluateVar3(expr->text, expr, rei, reiSaveFlag,  env, errmsg,r);
res = evaluateVar3(expr->text, expr, rei, reiSaveFlag,  env, errmsg,r)
res
res
evaluateVar3(expr->text, expr, rei, reiSaveFlag,  env, errmsg,r)
evaluateVar3
evaluateVar3
expr->text
expr
expr
text
expr
expr
rei
rei
reiSaveFlag
reiSaveFlag
env
env
errmsg
errmsg
r
r
break;
case TK_TEXT:
TK_TEXT
TK_TEXT
fd = (FunctionDesc *)lookupFromEnv(ruleEngineConfig.extFuncDescIndex, expr->text);
fd = (FunctionDesc *)lookupFromEnv(ruleEngineConfig.extFuncDescIndex, expr->text)
fd
fd
(FunctionDesc *)lookupFromEnv(ruleEngineConfig.extFuncDescIndex, expr->text)
FunctionDesc *
FunctionDesc
FunctionDesc
*
*
lookupFromEnv(ruleEngineConfig.extFuncDescIndex, expr->text)
lookupFromEnv
lookupFromEnv
ruleEngineConfig.extFuncDescIndex
ruleEngineConfig
ruleEngineConfig
extFuncDescIndex
expr->text
expr
expr
text
if(fd!=NULL) {						int nArgs = 0;						ExprType *type = fd->exprType;						while(type->nodeType == T_CONS && strcmp(type->text, FUNC) == 0) {							type = type->subtrees[1];							nArgs ++;						}						if(nArgs == 0) {							Node *appNode = newPartialApplication(expr, newTupleRes(0,NULL,r), 0, r);							res = evaluateFunction3(appNode, applyAll, expr, env, rei, reiSaveFlag, errmsg, r);						} else {							res = newFuncSymLink(expr->text, nArgs, r);						}					} else {						res = newFuncSymLink(expr->text, 1, r);					}
fd!=NULL
fd
fd
NULL
NULL
{						int nArgs = 0;						ExprType *type = fd->exprType;						while(type->nodeType == T_CONS && strcmp(type->text, FUNC) == 0) {							type = type->subtrees[1];							nArgs ++;						}						if(nArgs == 0) {							Node *appNode = newPartialApplication(expr, newTupleRes(0,NULL,r), 0, r);							res = evaluateFunction3(appNode, applyAll, expr, env, rei, reiSaveFlag, errmsg, r);						} else {							res = newFuncSymLink(expr->text, nArgs, r);						}					}
int nArgs = 0;
int nArgs = 0;
int
nArgs = 0
nArgs
= 0
0
ExprType *type = fd->exprType;
ExprType *type = fd->exprType;
ExprType
ExprType
*type = fd->exprType
*
type
= fd->exprType
fd->exprType
fd
fd
exprType
while(type->nodeType == T_CONS && strcmp(type->text, FUNC) == 0) {							type = type->subtrees[1];							nArgs ++;						}
type->nodeType == T_CONS && strcmp(type->text, FUNC) == 0
type->nodeType == T_CONS
type->nodeType
type
type
nodeType
T_CONS
T_CONS
strcmp(type->text, FUNC) == 0
strcmp(type->text, FUNC)
strcmp
strcmp
type->text
type
type
text
FUNC
FUNC
0
{							type = type->subtrees[1];							nArgs ++;						}
type = type->subtrees[1];
type = type->subtrees[1]
type
type
type->subtrees[1]
type->subtrees
type
type
subtrees
1
nArgs ++;
nArgs ++
nArgs
nArgs
if(nArgs == 0) {							Node *appNode = newPartialApplication(expr, newTupleRes(0,NULL,r), 0, r);							res = evaluateFunction3(appNode, applyAll, expr, env, rei, reiSaveFlag, errmsg, r);						} else {							res = newFuncSymLink(expr->text, nArgs, r);						}
nArgs == 0
nArgs
nArgs
0
{							Node *appNode = newPartialApplication(expr, newTupleRes(0,NULL,r), 0, r);							res = evaluateFunction3(appNode, applyAll, expr, env, rei, reiSaveFlag, errmsg, r);						}
Node *appNode = newPartialApplication(expr, newTupleRes(0,NULL,r), 0, r);
Node *appNode = newPartialApplication(expr, newTupleRes(0,NULL,r), 0, r);
Node
Node
*appNode = newPartialApplication(expr, newTupleRes(0,NULL,r), 0, r)
*
appNode
= newPartialApplication(expr, newTupleRes(0,NULL,r), 0, r)
newPartialApplication(expr, newTupleRes(0,NULL,r), 0, r)
newPartialApplication
newPartialApplication
expr
expr
newTupleRes(0,NULL,r)
newTupleRes
newTupleRes
0
NULL
NULL
r
r
0
r
r
res = evaluateFunction3(appNode, applyAll, expr, env, rei, reiSaveFlag, errmsg, r);
res = evaluateFunction3(appNode, applyAll, expr, env, rei, reiSaveFlag, errmsg, r)
res
res
evaluateFunction3(appNode, applyAll, expr, env, rei, reiSaveFlag, errmsg, r)
evaluateFunction3
evaluateFunction3
appNode
appNode
applyAll
applyAll
expr
expr
env
env
rei
rei
reiSaveFlag
reiSaveFlag
errmsg
errmsg
r
r
{							res = newFuncSymLink(expr->text, nArgs, r);						}
res = newFuncSymLink(expr->text, nArgs, r);
res = newFuncSymLink(expr->text, nArgs, r)
res
res
newFuncSymLink(expr->text, nArgs, r)
newFuncSymLink
newFuncSymLink
expr->text
expr
expr
text
nArgs
nArgs
r
r
{						res = newFuncSymLink(expr->text, 1, r);					}
res = newFuncSymLink(expr->text, 1, r);
res = newFuncSymLink(expr->text, 1, r)
res
res
newFuncSymLink(expr->text, 1, r)
newFuncSymLink
newFuncSymLink
expr->text
expr
expr
text
1
r
r
break;
case N_APPLICATION:
N_APPLICATION
N_APPLICATION
funcRes = evaluateExpression3(expr->subtrees[0], applyAll, 0, rei, reiSaveFlag, env, errmsg,r);
funcRes = evaluateExpression3(expr->subtrees[0], applyAll, 0, rei, reiSaveFlag, env, errmsg,r)
funcRes
funcRes
evaluateExpression3(expr->subtrees[0], applyAll, 0, rei, reiSaveFlag, env, errmsg,r)
evaluateExpression3
evaluateExpression3
expr->subtrees[0]
expr->subtrees
expr
expr
subtrees
0
applyAll
applyAll
0
rei
rei
reiSaveFlag
reiSaveFlag
env
env
errmsg
errmsg
r
r
if(funcRes->nodeType==N_ERROR) {					res = funcRes;					break;				}
funcRes->nodeType==N_ERROR
funcRes->nodeType
funcRes
funcRes
nodeType
N_ERROR
N_ERROR
{					res = funcRes;					break;				}
res = funcRes;
res = funcRes
res
res
funcRes
funcRes
break;
argRes = evaluateExpression3(expr->subtrees[1], applyAll, 0, rei, reiSaveFlag, env, errmsg,r);
argRes = evaluateExpression3(expr->subtrees[1], applyAll, 0, rei, reiSaveFlag, env, errmsg,r)
argRes
argRes
evaluateExpression3(expr->subtrees[1], applyAll, 0, rei, reiSaveFlag, env, errmsg,r)
evaluateExpression3
evaluateExpression3
expr->subtrees[1]
expr->subtrees
expr
expr
subtrees
1
applyAll
applyAll
0
rei
rei
reiSaveFlag
reiSaveFlag
env
env
errmsg
errmsg
r
r
if(argRes->nodeType==N_ERROR) {					res = argRes;					break;				}
argRes->nodeType==N_ERROR
argRes->nodeType
argRes
argRes
nodeType
N_ERROR
N_ERROR
{					res = argRes;					break;				}
res = argRes;
res = argRes
res
res
argRes
argRes
break;
res = evaluateFunctionApplication(funcRes, argRes, applyAll, expr, rei, reiSaveFlag, env, errmsg,r);
res = evaluateFunctionApplication(funcRes, argRes, applyAll, expr, rei, reiSaveFlag, env, errmsg,r)
res
res
evaluateFunctionApplication(funcRes, argRes, applyAll, expr, rei, reiSaveFlag, env, errmsg,r)
evaluateFunctionApplication
evaluateFunctionApplication
funcRes
funcRes
argRes
argRes
applyAll
applyAll
expr
expr
rei
rei
reiSaveFlag
reiSaveFlag
env
env
errmsg
errmsg
r
r
break;
case N_TUPLE:
N_TUPLE
N_TUPLE
tupleComps = (Res **) region_alloc(r, sizeof(Res *) * expr->degree);
tupleComps = (Res **) region_alloc(r, sizeof(Res *) * expr->degree)
tupleComps
tupleComps
(Res **) region_alloc(r, sizeof(Res *) * expr->degree)
Res **
Res
Res
**
*
*
region_alloc(r, sizeof(Res *) * expr->degree)
region_alloc
region_alloc
r
r
sizeof(Res *) * expr->degree
sizeof(Res *)
Res *
Res
Res
*
*
expr->degree
expr
expr
degree
for(i=0;i<expr->degree;i++) {					res = tupleComps[i] = evaluateExpression3(expr->subtrees[i], applyAll, 0, rei, reiSaveFlag, env, errmsg, r);					if(res->nodeType == N_ERROR) {						break;					}				}
i=0;
i=0
i
i
0
i<expr->degree
i
i
expr->degree
expr
expr
degree
i++
i
i
{					res = tupleComps[i] = evaluateExpression3(expr->subtrees[i], applyAll, 0, rei, reiSaveFlag, env, errmsg, r);					if(res->nodeType == N_ERROR) {						break;					}				}
res = tupleComps[i] = evaluateExpression3(expr->subtrees[i], applyAll, 0, rei, reiSaveFlag, env, errmsg, r);
res = tupleComps[i] = evaluateExpression3(expr->subtrees[i], applyAll, 0, rei, reiSaveFlag, env, errmsg, r)
res
res
tupleComps[i] = evaluateExpression3(expr->subtrees[i], applyAll, 0, rei, reiSaveFlag, env, errmsg, r)
tupleComps[i]
tupleComps
tupleComps
i
i
evaluateExpression3(expr->subtrees[i], applyAll, 0, rei, reiSaveFlag, env, errmsg, r)
evaluateExpression3
evaluateExpression3
expr->subtrees[i]
expr->subtrees
expr
expr
subtrees
i
i
applyAll
applyAll
0
rei
rei
reiSaveFlag
reiSaveFlag
env
env
errmsg
errmsg
r
r
if(res->nodeType == N_ERROR) {						break;					}
res->nodeType == N_ERROR
res->nodeType
res
res
nodeType
N_ERROR
N_ERROR
{						break;					}
break;
if(expr->degree == 0 || res->nodeType != N_ERROR) {					if(expr->value.constructTuple || expr->degree != 1) {						res = newTupleRes(expr->degree, tupleComps, r);					}				}
expr->degree == 0 || res->nodeType != N_ERROR
expr->degree == 0
expr->degree
expr
expr
degree
0
res->nodeType != N_ERROR
res->nodeType
res
res
nodeType
N_ERROR
N_ERROR
{					if(expr->value.constructTuple || expr->degree != 1) {						res = newTupleRes(expr->degree, tupleComps, r);					}				}
if(expr->value.constructTuple || expr->degree != 1) {						res = newTupleRes(expr->degree, tupleComps, r);					}
expr->value.constructTuple || expr->degree != 1
expr->value.constructTuple
expr->value
expr
expr
value
constructTuple
expr->degree != 1
expr->degree
expr
expr
degree
1
{						res = newTupleRes(expr->degree, tupleComps, r);					}
res = newTupleRes(expr->degree, tupleComps, r);
res = newTupleRes(expr->degree, tupleComps, r)
res
res
newTupleRes(expr->degree, tupleComps, r)
newTupleRes
newTupleRes
expr->degree
expr
expr
degree
tupleComps
tupleComps
r
r
break;
case N_ACTIONS_RECOVERY:
N_ACTIONS_RECOVERY
N_ACTIONS_RECOVERY
res = evaluateActions(expr->subtrees[0], expr->subtrees[1], rei, reiSaveFlag, env, errmsg, r);
res = evaluateActions(expr->subtrees[0], expr->subtrees[1], rei, reiSaveFlag, env, errmsg, r)
res
res
evaluateActions(expr->subtrees[0], expr->subtrees[1], rei, reiSaveFlag, env, errmsg, r)
evaluateActions
evaluateActions
expr->subtrees[0]
expr->subtrees
expr
expr
subtrees
0
expr->subtrees[1]
expr->subtrees
expr
expr
subtrees
1
rei
rei
reiSaveFlag
reiSaveFlag
env
env
errmsg
errmsg
r
r
break;
case N_ACTIONS:
N_ACTIONS
N_ACTIONS
generateErrMsg("error: evaluate actions using function evaluateExpression3, use function evaluateActions instead.", expr->expr, expr->base, errbuf);
generateErrMsg("error: evaluate actions using function evaluateExpression3, use function evaluateActions instead.", expr->expr, expr->base, errbuf)
generateErrMsg
generateErrMsg
"error: evaluate actions using function evaluateExpression3, use function evaluateActions instead."
expr->expr
expr
expr
expr
expr->base
expr
expr
base
errbuf
errbuf
addRErrorMsg(errmsg, -1, errbuf);
addRErrorMsg(errmsg, -1, errbuf)
addRErrorMsg
addRErrorMsg
errmsg
errmsg
-1
1
errbuf
errbuf
res = newErrorRes(r, -1);
res = newErrorRes(r, -1)
res
res
newErrorRes(r, -1)
newErrorRes
newErrorRes
r
r
-1
1
break;
default:
generateErrMsg("error: unsupported ast node type.", expr->expr, expr->base, errbuf);
generateErrMsg("error: unsupported ast node type.", expr->expr, expr->base, errbuf)
generateErrMsg
generateErrMsg
"error: unsupported ast node type."
expr->expr
expr
expr
expr
expr->base
expr
expr
base
errbuf
errbuf
addRErrorMsg(errmsg, -1, errbuf);
addRErrorMsg(errmsg, -1, errbuf)
addRErrorMsg
addRErrorMsg
errmsg
errmsg
-1
1
errbuf
errbuf
res = newErrorRes(r, -1);
res = newErrorRes(r, -1)
res
res
newErrorRes(r, -1)
newErrorRes
newErrorRes
r
r
-1
1
break;
{    	res = expr;    	while(res->nodeType == N_TUPLE && res->degree == 1) {    		res = res->subtrees[0];    	}    }
res = expr;
res = expr
res
res
expr
expr
while(res->nodeType == N_TUPLE && res->degree == 1) {    		res = res->subtrees[0];    	}
res->nodeType == N_TUPLE && res->degree == 1
res->nodeType == N_TUPLE
res->nodeType
res
res
nodeType
N_TUPLE
N_TUPLE
res->degree == 1
res->degree
res
res
degree
1
{    		res = res->subtrees[0];    	}
res = res->subtrees[0];
res = res->subtrees[0]
res
res
res->subtrees[0]
res->subtrees
res
res
subtrees
0
return res;
res
res
-----joern-----
(147,40,0)
(238,287,0)
(421,315,0)
(57,40,0)
(383,402,0)
(116,398,0)
(151,215,0)
(387,286,0)
(275,346,0)
(234,40,0)
(45,332,0)
(241,284,0)
(273,313,0)
(171,206,0)
(410,328,0)
(393,206,0)
(365,287,0)
(356,46,0)
(66,291,0)
(326,328,0)
(226,174,0)
(76,435,0)
(172,13,0)
(34,24,0)
(243,18,0)
(322,34,0)
(119,33,0)
(303,260,0)
(351,34,0)
(84,70,0)
(294,365,0)
(84,279,0)
(354,7,0)
(121,343,0)
(198,206,0)
(343,296,0)
(51,260,0)
(33,289,0)
(81,104,0)
(381,326,0)
(405,284,0)
(318,57,0)
(317,328,0)
(248,74,0)
(29,40,0)
(445,169,0)
(35,39,0)
(276,134,0)
(174,245,0)
(228,114,0)
(279,193,0)
(403,427,0)
(223,29,0)
(390,296,0)
(106,57,0)
(90,71,0)
(296,218,0)
(444,40,0)
(265,328,0)
(181,114,0)
(113,40,0)
(32,398,0)
(238,417,0)
(38,107,0)
(132,430,0)
(201,215,0)
(59,193,0)
(407,328,0)
(264,272,0)
(60,40,0)
(388,65,0)
(244,328,0)
(164,238,0)
(214,365,0)
(377,416,0)
(159,13,0)
(215,151,0)
(441,365,0)
(105,238,0)
(374,104,0)
(84,405,0)
(255,138,0)
(431,419,0)
(80,89,0)
(401,71,0)
(133,330,0)
(27,328,0)
(53,326,0)
(235,337,0)
(307,328,0)
(43,330,0)
(176,414,0)
(350,25,0)
(261,169,0)
(33,287,0)
(338,263,0)
(166,266,0)
(108,7,0)
(438,399,0)
(193,65,0)
(336,405,0)
(384,122,0)
(246,192,0)
(382,284,0)
(225,147,0)
(62,57,0)
(311,328,0)
(382,209,0)
(173,209,0)
(146,328,0)
(350,417,0)
(368,278,0)
(335,418,0)
(156,289,0)
(71,49,0)
(218,40,0)
(65,193,0)
(365,289,0)
(123,33,0)
(247,365,0)
(272,299,0)
(301,289,0)
(411,16,0)
(334,89,0)
(285,29,0)
(341,60,0)
(340,165,0)
(427,403,0)
(48,140,0)
(212,380,0)
(102,61,0)
(254,398,0)
(427,435,0)
(304,16,0)
(71,289,0)
(422,53,0)
(125,138,0)
(4,379,0)
(357,240,0)
(292,13,0)
(30,328,0)
(184,116,0)
(365,361,0)
(418,335,0)
(3,238,0)
(193,279,0)
(46,256,0)
(71,263,0)
(440,328,0)
(228,48,0)
(340,16,0)
(365,49,0)
(283,259,0)
(391,344,0)
(84,403,0)
(333,288,0)
(430,419,0)
(315,49,0)
(202,24,0)
(153,278,0)
(107,203,0)
(226,328,0)
(378,156,0)
(238,335,0)
(215,40,0)
(257,338,0)
(258,384,0)
(22,375,0)
(371,346,0)
(323,233,0)
(61,29,0)
(384,258,0)
(79,272,0)
(135,379,0)
(250,328,0)
(284,382,0)
(5,122,0)
(270,13,0)
(126,332,0)
(18,368,0)
(206,67,0)
(379,16,0)
(68,6,0)
(154,6,0)
(169,16,0)
(96,328,0)
(55,206,0)
(174,226,0)
(437,215,0)
(446,328,0)
(396,315,0)
(211,40,0)
(268,387,0)
(78,21,0)
(402,291,0)
(375,219,0)
(348,401,0)
(325,315,0)
(279,69,0)
(360,244,0)
(188,416,0)
(94,328,0)
(236,113,0)
(416,377,0)
(232,219,0)
(136,238,0)
(149,397,0)
(65,40,0)
(231,157,0)
(331,315,0)
(256,46,0)
(84,134,0)
(206,393,0)
(195,156,0)
(115,116,0)
(274,33,0)
(158,385,0)
(94,301,0)
(290,398,0)
(301,94,0)
(346,40,0)
(224,206,0)
(324,254,0)
(263,33,0)
(334,328,0)
(394,238,0)
(295,33,0)
(410,206,0)
(140,48,0)
(419,430,0)
(84,240,0)
(434,379,0)
(84,398,0)
(217,70,0)
(108,228,0)
(73,218,0)
(387,16,0)
(431,328,0)
(82,185,0)
(10,207,0)
(229,147,0)
(346,315,0)
(64,200,0)
(365,363,0)
(399,282,0)
(131,45,0)
(121,192,0)
(163,233,0)
(128,380,0)
(260,40,0)
(353,114,0)
(91,326,0)
(277,428,0)
(16,411,0)
(315,14,0)
(315,259,0)
(179,328,0)
(185,40,0)
(330,233,0)
(286,297,0)
(118,233,0)
(219,375,0)
(256,247,0)
(359,382,0)
(71,361,0)
(205,427,0)
(444,244,0)
(364,266,0)
(207,40,0)
(165,426,0)
(84,431,0)
(13,428,0)
(162,315,0)
(54,13,0)
(9,444,0)
(39,358,0)
(13,40,0)
(362,230,0)
(197,358,0)
(13,361,0)
(155,258,0)
(107,328,0)
(20,226,0)
(13,14,0)
(167,239,0)
(352,384,0)
(6,380,0)
(34,328,0)
(443,398,0)
(347,263,0)
(196,365,0)
(404,395,0)
(190,238,0)
(150,231,0)
(148,335,0)
(104,40,0)
(206,14,0)
(436,382,0)
(247,328,0)
(380,289,0)
(278,122,0)
(222,47,0)
(143,71,0)
(71,40,0)
(397,74,0)
(309,218,0)
(415,414,0)
(291,402,0)
(310,340,0)
(52,60,0)
(72,385,0)
(368,18,0)
(320,245,0)
(84,350,0)
(335,238,0)
(98,157,0)
(365,247,0)
(251,406,0)
(219,209,0)
(272,417,0)
(160,375,0)
(1,234,0)
(393,60,0)
(2,328,0)
(6,397,0)
(61,33,0)
(299,7,0)
(108,289,0)
(71,247,0)
(33,14,0)
(188,200,0)
(420,398,0)
(240,399,0)
(253,88,0)
(278,368,0)
(204,194,0)
(408,243,0)
(376,84,0)
(178,328,0)
(7,354,0)
(114,228,0)
(280,328,0)
(151,407,0)
(139,301,0)
(298,209,0)
(21,166,0)
(84,16,0)
(379,434,0)
(315,361,0)
(134,263,0)
(342,206,0)
(206,230,0)
(244,104,0)
(185,363,0)
(186,193,0)
(100,254,0)
(7,299,0)
(206,361,0)
(428,13,0)
(13,67,0)
(412,120,0)
(399,289,0)
(266,122,0)
(110,328,0)
(335,385,0)
(243,258,0)
(271,45,0)
(426,318,0)
(13,49,0)
(219,405,0)
(329,108,0)
(33,49,0)
(129,211,0)
(332,22,0)
(70,247,0)
(53,122,0)
(349,368,0)
(240,314,0)
(244,444,0)
(84,428,0)
(299,328,0)
(87,65,0)
(238,67,0)
(355,328,0)
(269,166,0)
(315,67,0)
(249,71,0)
(206,410,0)
(337,138,0)
(416,188,0)
(327,13,0)
(16,398,0)
(406,330,0)
(26,427,0)
(57,318,0)
(365,67,0)
(71,401,0)
(384,21,0)
(19,380,0)
(378,328,0)
(101,71,0)
(145,94,0)
(165,340,0)
(97,113,0)
(88,253,0)
(18,243,0)
(84,401,0)
(435,40,0)
(344,330,0)
(260,34,0)
(83,431,0)
(220,71,0)
(253,413,0)
(259,315,0)
(266,21,0)
(170,297,0)
(397,6,0)
(84,259,0)
(191,299,0)
(419,289,0)
(315,40,0)
(405,137,0)
(189,185,0)
(296,343,0)
(424,435,0)
(369,418,0)
(41,419,0)
(60,393,0)
(182,71,0)
(24,40,0)
(366,387,0)
(70,120,0)
(318,426,0)
(7,108,0)
(58,334,0)
(234,230,0)
(218,296,0)
(168,282,0)
(343,121,0)
(42,157,0)
(238,289,0)
(417,238,0)
(89,334,0)
(432,234,0)
(84,226,0)
(262,365,0)
(138,337,0)
(242,393,0)
(192,40,0)
(188,211,0)
(392,33,0)
(12,399,0)
(230,206,0)
(166,21,0)
(192,121,0)
(402,383,0)
(428,74,0)
(372,134,0)
(37,200,0)
(177,266,0)
(147,88,0)
(213,381,0)
(344,75,0)
(266,166,0)
(252,410,0)
(31,365,0)
(414,398,0)
(258,243,0)
(45,405,0)
(63,233,0)
(157,16,0)
(112,398,0)
(48,228,0)
(104,244,0)
(281,334,0)
(84,410,0)
(407,151,0)
(297,289,0)
(103,398,0)
(439,315,0)
(56,174,0)
(434,383,0)
(403,237,0)
(340,350,0)
(156,378,0)
(208,211,0)
(339,88,0)
(375,22,0)
(417,350,0)
(33,61,0)
(400,291,0)
(11,13,0)
(293,219,0)
(114,40,0)
(124,203,0)
(134,288,0)
(33,361,0)
(263,328,0)
(71,287,0)
(423,156,0)
(36,384,0)
(169,378,0)
(39,385,0)
(238,14,0)
(433,23,0)
(107,49,0)
(245,174,0)
(363,185,0)
(34,260,0)
(319,381,0)
(138,350,0)
(326,416,0)
(395,398,0)
(363,365,0)
(152,328,0)
(33,263,0)
(109,328,0)
(111,278,0)
(300,72,0)
(209,40,0)
(227,358,0)
(200,188,0)
(282,399,0)
(272,385,0)
(373,363,0)
(312,403,0)
(95,406,0)
(122,53,0)
(84,94,0)
(0,25,0)
(301,207,0)
(389,70,0)
(308,338,0)
(21,75,0)
(85,13,0)
(6,289,0)
(13,287,0)
(429,444,0)
(231,407,0)
(77,328,0)
(380,6,0)
(28,238,0)
(44,418,0)
(144,121,0)
(358,40,0)
(345,165,0)
(416,326,0)
(206,49,0)
(238,49,0)
(33,67,0)
(47,338,0)
(419,431,0)
(302,6,0)
(210,253,0)
(174,289,0)
(193,330,0)
(291,40,0)
(99,328,0)
(367,71,0)
(127,318,0)
(117,244,0)
(370,411,0)
(442,350,0)
(427,289,0)
(338,47,0)
(71,14,0)
(278,21,0)
(382,405,0)
(316,398,0)
(332,45,0)
(321,192,0)
(13,289,0)
(267,365,0)
(230,234,0)
(315,346,0)
(334,49,0)
(426,165,0)
(238,361,0)
(259,328,0)
(315,289,0)
(206,289,0)
(45,209,0)
(435,427,0)
(199,256,0)
(409,434,0)
(13,397,0)
(142,71,0)
(187,84,0)
(221,53,0)
(401,328,0)
(418,40,0)
(386,297,0)
(175,328,0)
(88,147,0)
(24,34,0)
(203,107,0)
(306,256,0)
(297,286,0)
(216,328,0)
(180,247,0)
(50,328,0)
(427,299,0)
(228,108,0)
(8,282,0)
(447,33,0)
(141,24,0)
(15,71,0)
(207,301,0)
(22,332,0)
(86,33,0)
(92,385,0)
(211,188,0)
(183,279,0)
(209,239,0)
(358,39,0)
(157,231,0)
(425,398,0)
(282,40,0)
(305,107,0)
(193,289,0)
(399,240,0)
(383,328,0)
(17,328,0)
(6,40,0)
(411,289,0)
(71,67,0)
(93,340,0)
(365,14,0)
(130,395,0)
(122,233,0)
(284,405,0)
(84,209,0)
(161,207,0)
(29,61,0)
(286,328,0)
(401,71,1)
(365,441,1)
(187,317,1)
(66,434,1)
(84,410,1)
(199,306,1)
(57,62,1)
(315,67,1)
(84,431,1)
(266,21,1)
(322,113,1)
(223,347,1)
(26,435,1)
(187,30,1)
(165,345,1)
(136,394,1)
(293,405,1)
(33,49,1)
(277,397,1)
(206,361,1)
(419,289,1)
(266,177,1)
(434,379,1)
(183,406,1)
(238,136,1)
(141,322,1)
(166,269,1)
(278,122,1)
(6,154,1)
(363,373,1)
(123,274,1)
(84,259,1)
(158,299,1)
(339,147,1)
(245,320,1)
(107,49,1)
(238,287,1)
(101,142,1)
(347,113,1)
(188,200,1)
(299,7,1)
(206,49,1)
(71,40,1)
(238,335,1)
(345,340,1)
(365,289,1)
(318,127,1)
(315,289,1)
(445,261,1)
(327,159,1)
(160,219,1)
(244,444,1)
(46,356,1)
(209,40,1)
(17,383,1)
(68,149,1)
(24,202,1)
(107,203,1)
(192,246,1)
(317,343,1)
(253,210,1)
(385,92,1)
(93,318,1)
(84,405,1)
(13,397,1)
(45,131,1)
(178,431,1)
(157,98,1)
(235,138,1)
(134,372,1)
(206,230,1)
(71,14,1)
(381,213,1)
(131,271,1)
(212,128,1)
(62,106,1)
(97,253,1)
(352,368,1)
(205,26,1)
(65,40,1)
(187,265,1)
(214,31,1)
(230,362,1)
(403,427,1)
(260,40,1)
(155,384,1)
(258,155,1)
(84,226,1)
(135,4,1)
(219,405,1)
(331,162,1)
(87,388,1)
(257,308,1)
(343,296,1)
(187,22,1)
(5,330,1)
(358,40,1)
(2,94,1)
(37,91,1)
(169,445,1)
(34,24,1)
(365,14,1)
(230,234,1)
(115,184,1)
(365,67,1)
(272,299,1)
(389,46,1)
(21,166,1)
(152,226,1)
(84,350,1)
(156,195,1)
(84,240,1)
(207,161,1)
(359,436,1)
(368,349,1)
(218,73,1)
(404,130,1)
(238,361,1)
(71,361,1)
(193,330,1)
(197,227,1)
(88,339,1)
(435,76,1)
(111,153,1)
(82,180,1)
(192,40,1)
(259,315,1)
(90,101,1)
(402,291,1)
(270,172,1)
(320,56,1)
(373,185,1)
(376,84,1)
(260,303,1)
(238,289,1)
(156,289,1)
(421,331,1)
(116,115,1)
(228,48,1)
(71,247,1)
(232,293,1)
(442,39,1)
(405,284,1)
(399,12,1)
(207,40,1)
(423,169,1)
(407,151,1)
(298,253,1)
(247,365,1)
(22,332,1)
(312,343,1)
(35,72,1)
(364,78,1)
(208,129,1)
(169,16,1)
(24,40,1)
(411,370,1)
(109,259,1)
(215,40,1)
(440,279,1)
(105,164,1)
(33,67,1)
(198,342,1)
(444,40,1)
(172,292,1)
(296,390,1)
(39,385,1)
(70,217,1)
(203,124,1)
(171,393,1)
(308,263,1)
(255,350,1)
(251,18,1)
(387,268,1)
(51,24,1)
(375,160,1)
(54,85,1)
(33,61,1)
(6,289,1)
(84,70,1)
(434,409,1)
(406,95,1)
(7,354,1)
(174,245,1)
(218,40,1)
(84,94,1)
(396,439,1)
(231,157,1)
(38,203,1)
(173,298,1)
(44,369,1)
(72,385,1)
(262,214,1)
(133,43,1)
(397,6,1)
(64,37,1)
(382,359,1)
(102,29,1)
(153,122,1)
(267,196,1)
(193,65,1)
(399,282,1)
(340,16,1)
(18,243,1)
(106,273,1)
(394,3,1)
(256,199,1)
(310,93,1)
(187,333,1)
(182,367,1)
(84,428,1)
(254,324,1)
(374,444,1)
(444,9,1)
(149,406,1)
(326,416,1)
(395,404,1)
(59,186,1)
(30,407,1)
(13,14,1)
(45,405,1)
(79,264,1)
(350,417,1)
(166,266,1)
(439,421,1)
(174,289,1)
(60,40,1)
(242,60,1)
(81,374,1)
(187,412,1)
(384,21,1)
(104,40,1)
(243,408,1)
(281,34,1)
(153,344,1)
(249,143,1)
(416,377,1)
(13,361,1)
(213,319,1)
(128,68,1)
(206,198,1)
(34,351,1)
(143,220,1)
(369,272,1)
(1,252,1)
(76,424,1)
(138,350,1)
(409,379,1)
(391,21,1)
(437,231,1)
(60,52,1)
(189,82,1)
(220,15,1)
(73,309,1)
(399,289,1)
(440,428,1)
(84,401,1)
(191,113,1)
(271,375,1)
(417,238,1)
(121,144,1)
(147,40,1)
(33,361,1)
(278,111,1)
(261,113,1)
(47,338,1)
(436,336,1)
(365,49,1)
(78,18,1)
(438,282,1)
(295,119,1)
(253,413,1)
(283,113,1)
(225,210,1)
(154,302,1)
(317,403,1)
(236,97,1)
(92,158,1)
(61,102,1)
(292,327,1)
(187,2,1)
(6,40,1)
(193,289,1)
(370,304,1)
(336,22,1)
(15,182,1)
(265,401,1)
(332,45,1)
(11,277,1)
(340,350,1)
(176,415,1)
(150,157,1)
(302,380,1)
(43,381,1)
(365,287,1)
(8,168,1)
(393,60,1)
(315,49,1)
(202,141,1)
(89,80,1)
(184,395,1)
(18,368,1)
(168,357,1)
(419,430,1)
(414,176,1)
(390,218,1)
(228,114,1)
(428,13,1)
(315,346,1)
(381,326,1)
(431,419,1)
(344,391,1)
(88,147,1)
(185,189,1)
(315,361,1)
(196,294,1)
(264,442,1)
(130,414,1)
(94,301,1)
(427,205,1)
(393,242,1)
(256,247,1)
(48,140,1)
(61,29,1)
(388,183,1)
(368,278,1)
(164,190,1)
(70,247,1)
(27,410,1)
(268,366,1)
(206,14,1)
(4,286,1)
(162,325,1)
(142,249,1)
(193,59,1)
(139,145,1)
(335,148,1)
(84,16,1)
(286,297,1)
(16,411,1)
(325,346,1)
(39,358,1)
(334,58,1)
(72,300,1)
(300,337,1)
(275,371,1)
(246,321,1)
(161,10,1)
(296,218,1)
(338,257,1)
(274,392,1)
(279,193,1)
(243,258,1)
(305,244,1)
(42,378,1)
(45,209,1)
(380,289,1)
(384,122,1)
(291,40,1)
(360,104,1)
(356,256,1)
(180,47,1)
(144,192,1)
(284,241,1)
(188,211,1)
(71,90,1)
(238,49,1)
(411,289,1)
(379,135,1)
(418,44,1)
(427,289,1)
(343,121,1)
(282,40,1)
(367,348,1)
(349,278,1)
(100,116,1)
(429,117,1)
(107,38,1)
(219,209,1)
(134,263,1)
(269,266,1)
(147,229,1)
(113,236,1)
(435,40,1)
(400,66,1)
(386,387,1)
(229,225,1)
(240,399,1)
(210,254,1)
(282,8,1)
(315,40,1)
(31,363,1)
(106,39,1)
(318,57,1)
(122,53,1)
(46,256,1)
(200,64,1)
(440,240,1)
(13,40,1)
(117,113,1)
(33,14,1)
(324,100,1)
(206,393,1)
(187,178,1)
(86,123,1)
(190,335,1)
(334,49,1)
(145,113,1)
(378,156,1)
(301,207,1)
(7,108,1)
(22,375,1)
(238,67,1)
(35,385,1)
(151,215,1)
(380,19,1)
(219,232,1)
(273,337,1)
(28,105,1)
(224,171,1)
(13,289,1)
(321,296,1)
(306,247,1)
(392,295,1)
(253,88,1)
(426,165,1)
(48,329,1)
(335,418,1)
(284,382,1)
(187,109,1)
(337,235,1)
(33,289,1)
(83,107,1)
(365,363,1)
(84,134,1)
(71,287,1)
(129,200,1)
(226,174,1)
(293,209,1)
(330,133,1)
(382,405,1)
(412,70,1)
(301,289,1)
(426,318,1)
(272,79,1)
(241,382,1)
(418,40,1)
(13,54,1)
(329,191,1)
(365,361,1)
(227,35,1)
(334,89,1)
(53,326,1)
(357,381,1)
(297,289,1)
(238,14,1)
(57,40,1)
(56,20,1)
(127,57,1)
(315,14,1)
(335,385,1)
(71,67,1)
(371,283,1)
(33,287,1)
(372,276,1)
(432,1,1)
(353,181,1)
(344,330,1)
(384,36,1)
(124,305,1)
(266,122,1)
(358,197,1)
(234,40,1)
(84,403,1)
(95,251,1)
(55,224,1)
(159,11,1)
(263,33,1)
(148,418,1)
(234,432,1)
(47,222,1)
(71,263,1)
(244,360,1)
(58,89,1)
(181,48,1)
(186,65,1)
(53,422,1)
(408,258,1)
(317,426,1)
(332,126,1)
(187,440,1)
(114,40,1)
(303,51,1)
(366,113,1)
(6,380,1)
(201,437,1)
(19,212,1)
(333,134,1)
(415,16,1)
(84,279,1)
(125,255,1)
(217,389,1)
(387,16,1)
(80,281,1)
(211,208,1)
(29,285,1)
(71,49,1)
(383,402,1)
(252,113,1)
(209,173,1)
(215,201,1)
(422,221,1)
(13,49,1)
(447,86,1)
(84,187,1)
(41,83,1)
(138,125,1)
(346,40,1)
(126,45,1)
(342,55,1)
(34,260,1)
(9,429,1)
(108,228,1)
(65,87,1)
(85,270,1)
(315,396,1)
(33,447,1)
(206,289,1)
(12,438,1)
(206,67,1)
(406,330,1)
(71,289,1)
(430,132,1)
(222,338,1)
(185,40,1)
(113,40,1)
(363,185,1)
(258,384,1)
(132,41,1)
(416,188,1)
(157,16,1)
(211,40,1)
(346,275,1)
(187,152,1)
(119,61,1)
(297,170,1)
(362,234,1)
(278,21,1)
(427,435,1)
(20,334,1)
(98,42,1)
(379,16,1)
(221,5,1)
(319,326,1)
(10,139,1)
(165,340,1)
(104,81,1)
(337,138,1)
(114,353,1)
(195,423,1)
(427,299,1)
(3,28,1)
(340,310,1)
(294,262,1)
(52,341,1)
(121,192,1)
(276,47,1)
(291,400,1)
(187,27,1)
(348,46,1)
(424,312,1)
(309,426,1)
(170,386,1)
(36,352,1)
(91,113,1)
(375,219,1)
(285,223,1)
(351,260,1)
(382,209,1)
(13,67,1)
(177,364,1)
(108,289,1)
(410,206,1)
(441,267,1)
(231,150,1)
(29,40,1)
(84,209,1)
(13,287,1)
(341,230,1)
(187,17,1)
(272,385,1)
(338,263,1)
(244,104,1)
(394,39,2)
(84,240,2)
(22,332,2)
(84,134,2)
(279,406,2)
(232,253,2)
(422,381,2)
(72,337,2)
(240,399,2)
(315,40,2)
(335,39,2)
(59,406,2)
(174,245,2)
(84,209,2)
(401,71,2)
(53,326,2)
(107,113,2)
(285,113,2)
(206,230,2)
(374,113,2)
(393,60,2)
(218,426,2)
(122,381,2)
(365,361,2)
(22,375,2)
(65,40,2)
(261,113,2)
(165,340,2)
(320,113,2)
(282,40,2)
(7,113,2)
(224,113,2)
(393,113,2)
(416,377,2)
(16,411,2)
(275,113,2)
(403,427,2)
(13,397,2)
(431,113,2)
(234,113,2)
(298,253,2)
(341,113,2)
(330,381,2)
(195,113,2)
(352,368,2)
(231,113,2)
(444,113,2)
(306,47,2)
(402,291,2)
(255,39,2)
(173,253,2)
(428,13,2)
(258,368,2)
(428,406,2)
(225,210,2)
(238,49,2)
(238,289,2)
(95,381,2)
(57,113,2)
(296,218,2)
(386,113,2)
(124,113,2)
(437,113,2)
(206,361,2)
(21,166,2)
(206,393,2)
(48,113,2)
(33,67,2)
(150,113,2)
(384,368,2)
(419,289,2)
(84,70,2)
(435,343,2)
(378,156,2)
(358,40,2)
(365,14,2)
(272,39,2)
(335,385,2)
(84,428,2)
(269,18,2)
(200,113,2)
(359,22,2)
(70,46,2)
(432,113,2)
(308,113,2)
(299,113,2)
(22,22,2)
(71,289,2)
(256,247,2)
(375,22,2)
(148,39,2)
(266,122,2)
(193,65,2)
(46,256,2)
(60,40,2)
(332,375,2)
(396,113,2)
(435,40,2)
(215,40,2)
(243,368,2)
(399,289,2)
(236,253,2)
(185,47,2)
(301,207,2)
(30,113,2)
(205,343,2)
(141,113,2)
(202,113,2)
(259,315,2)
(228,48,2)
(346,40,2)
(334,113,2)
(153,381,2)
(338,113,2)
(215,113,2)
(101,46,2)
(321,296,2)
(33,287,2)
(71,67,2)
(168,381,2)
(332,45,2)
(172,406,2)
(353,113,2)
(392,113,2)
(301,113,2)
(383,402,2)
(208,113,2)
(331,113,2)
(399,282,2)
(121,192,2)
(263,33,2)
(230,234,2)
(263,113,2)
(315,346,2)
(317,113,2)
(406,330,2)
(379,16,2)
(121,296,2)
(105,39,2)
(247,47,2)
(417,238,2)
(379,113,2)
(158,113,2)
(34,260,2)
(315,14,2)
(188,200,2)
(242,113,2)
(183,406,2)
(408,368,2)
(293,253,2)
(206,113,2)
(238,335,2)
(219,22,2)
(68,406,2)
(346,113,2)
(78,18,2)
(421,113,2)
(39,358,2)
(427,343,2)
(387,113,2)
(39,385,2)
(334,49,2)
(230,113,2)
(434,113,2)
(310,318,2)
(18,18,2)
(371,113,2)
(378,113,2)
(442,39,2)
(344,18,2)
(174,289,2)
(113,40,2)
(11,406,2)
(227,113,2)
(318,113,2)
(21,18,2)
(292,406,2)
(223,113,2)
(73,426,2)
(52,113,2)
(388,406,2)
(430,113,2)
(33,289,2)
(160,22,2)
(186,406,2)
(174,113,2)
(39,113,2)
(104,40,2)
(129,113,2)
(365,47,2)
(281,113,2)
(253,413,2)
(34,24,2)
(166,18,2)
(72,385,2)
(218,40,2)
(251,381,2)
(297,113,2)
(84,405,2)
(315,113,2)
(349,381,2)
(385,113,2)
(260,113,2)
(151,215,2)
(13,406,2)
(384,122,2)
(333,47,2)
(401,46,2)
(259,113,2)
(56,113,2)
(3,39,2)
(45,375,2)
(382,405,2)
(365,287,2)
(274,113,2)
(238,39,2)
(88,147,2)
(365,289,2)
(64,113,2)
(315,289,2)
(171,113,2)
(85,406,2)
(154,406,2)
(245,113,2)
(272,299,2)
(29,40,2)
(351,113,2)
(246,296,2)
(439,113,2)
(397,6,2)
(243,258,2)
(87,406,2)
(315,361,2)
(177,18,2)
(160,253,2)
(193,289,2)
(206,14,2)
(60,113,2)
(180,47,2)
(189,47,2)
(157,16,2)
(31,47,2)
(418,39,2)
(418,40,2)
(278,381,2)
(61,29,2)
(241,22,2)
(226,113,2)
(84,410,2)
(8,381,2)
(258,384,2)
(166,266,2)
(350,417,2)
(37,113,2)
(111,18,2)
(334,89,2)
(38,113,2)
(340,350,2)
(400,113,2)
(22,253,2)
(51,113,2)
(440,113,2)
(6,380,2)
(447,113,2)
(4,113,2)
(119,113,2)
(152,113,2)
(382,209,2)
(360,113,2)
(277,406,2)
(106,113,2)
(410,206,2)
(41,113,2)
(387,16,2)
(97,253,2)
(326,416,2)
(338,263,2)
(18,381,2)
(358,113,2)
(271,375,2)
(15,46,2)
(211,40,2)
(363,47,2)
(291,40,2)
(135,113,2)
(390,426,2)
(296,426,2)
(197,113,2)
(162,113,2)
(350,39,2)
(419,430,2)
(27,113,2)
(18,243,2)
(219,253,2)
(286,297,2)
(169,113,2)
(226,174,2)
(265,46,2)
(372,47,2)
(434,379,2)
(383,113,2)
(48,140,2)
(315,49,2)
(244,444,2)
(283,113,2)
(102,113,2)
(192,40,2)
(19,406,2)
(234,40,2)
(282,381,2)
(368,381,2)
(397,406,2)
(108,228,2)
(249,46,2)
(207,113,2)
(20,113,2)
(71,361,2)
(343,296,2)
(155,368,2)
(13,67,2)
(190,39,2)
(340,318,2)
(416,188,2)
(419,113,2)
(53,381,2)
(326,113,2)
(33,361,2)
(88,210,2)
(229,210,2)
(9,113,2)
(284,382,2)
(114,113,2)
(411,289,2)
(247,365,2)
(206,67,2)
(80,113,2)
(188,211,2)
(382,22,2)
(84,279,2)
(83,113,2)
(343,121,2)
(410,113,2)
(238,287,2)
(24,113,2)
(181,113,2)
(151,113,2)
(278,21,2)
(427,299,2)
(199,47,2)
(125,39,2)
(7,354,2)
(36,368,2)
(182,46,2)
(427,435,2)
(407,151,2)
(138,350,2)
(222,113,2)
(47,338,2)
(203,113,2)
(84,350,2)
(71,14,2)
(238,14,2)
(82,47,2)
(165,318,2)
(13,14,2)
(300,337,2)
(70,247,2)
(35,337,2)
(196,47,2)
(33,49,2)
(264,39,2)
(6,289,2)
(391,18,2)
(144,296,2)
(133,381,2)
(57,40,2)
(10,113,2)
(71,263,2)
(127,113,2)
(381,113,2)
(336,22,2)
(356,47,2)
(347,113,2)
(339,210,2)
(403,343,2)
(94,301,2)
(178,113,2)
(228,113,2)
(84,226,2)
(278,18,2)
(231,157,2)
(266,21,2)
(157,113,2)
(240,381,2)
(369,39,2)
(325,113,2)
(107,49,2)
(126,375,2)
(373,47,2)
(299,7,2)
(128,406,2)
(412,46,2)
(193,330,2)
(342,113,2)
(238,67,2)
(380,289,2)
(13,361,2)
(260,40,2)
(213,113,2)
(436,22,2)
(188,113,2)
(406,381,2)
(302,406,2)
(445,113,2)
(212,406,2)
(84,431,2)
(84,94,2)
(26,343,2)
(337,138,2)
(66,113,2)
(365,49,2)
(134,47,2)
(108,113,2)
(191,113,2)
(322,113,2)
(309,426,2)
(42,113,2)
(91,113,2)
(270,406,2)
(276,47,2)
(227,337,2)
(429,113,2)
(6,406,2)
(267,47,2)
(209,253,2)
(139,113,2)
(368,278,2)
(98,113,2)
(335,418,2)
(114,40,2)
(427,289,2)
(232,22,2)
(81,113,2)
(405,22,2)
(206,289,2)
(45,405,2)
(424,343,2)
(305,113,2)
(134,263,2)
(1,113,2)
(364,18,2)
(156,289,2)
(286,113,2)
(278,122,2)
(45,209,2)
(337,39,2)
(107,203,2)
(268,113,2)
(192,296,2)
(327,406,2)
(143,46,2)
(365,363,2)
(145,113,2)
(266,18,2)
(238,361,2)
(12,381,2)
(89,113,2)
(284,22,2)
(71,40,2)
(376,84,2)
(2,113,2)
(416,113,2)
(244,113,2)
(170,113,2)
(71,46,2)
(441,47,2)
(13,40,2)
(138,39,2)
(93,318,2)
(384,21,2)
(86,113,2)
(13,49,2)
(209,40,2)
(147,210,2)
(389,46,2)
(340,16,2)
(358,337,2)
(423,113,2)
(147,40,2)
(201,113,2)
(111,381,2)
(33,14,2)
(108,289,2)
(375,253,2)
(61,113,2)
(39,337,2)
(149,406,2)
(6,40,2)
(193,406,2)
(198,113,2)
(24,40,2)
(399,381,2)
(92,113,2)
(262,47,2)
(29,113,2)
(84,16,2)
(319,113,2)
(43,381,2)
(228,114,2)
(132,113,2)
(123,113,2)
(367,46,2)
(136,39,2)
(315,67,2)
(407,113,2)
(273,337,2)
(84,259,2)
(345,318,2)
(444,40,2)
(113,253,2)
(79,39,2)
(294,47,2)
(84,401,2)
(58,113,2)
(54,406,2)
(368,18,2)
(426,165,2)
(71,287,2)
(62,113,2)
(431,419,2)
(303,113,2)
(76,343,2)
(375,219,2)
(295,113,2)
(291,113,2)
(35,113,2)
(348,46,2)
(257,113,2)
(220,46,2)
(33,113,2)
(219,209,2)
(366,113,2)
(71,247,2)
(13,287,2)
(169,16,2)
(402,113,2)
(7,108,2)
(65,406,2)
(159,406,2)
(47,113,2)
(329,113,2)
(185,40,2)
(84,403,2)
(13,289,2)
(312,343,2)
(5,381,2)
(409,113,2)
(207,40,2)
(253,88,2)
(161,113,2)
(363,185,2)
(44,39,2)
(349,18,2)
(256,47,2)
(380,406,2)
(297,289,2)
(405,284,2)
(71,49,2)
(206,49,2)
(90,46,2)
(55,113,2)
(217,46,2)
(357,381,2)
(28,39,2)
(417,39,2)
(153,18,2)
(214,47,2)
(33,61,2)
(122,53,2)
(301,289,2)
(362,113,2)
(17,113,2)
(197,337,2)
(18,368,2)
(272,385,2)
(219,405,2)
(318,57,2)
(426,318,2)
(426,113,2)
(235,39,2)
(109,113,2)
(156,113,2)
(34,113,2)
(117,113,2)
(142,46,2)
(279,193,2)
(46,47,2)
(252,113,2)
(438,381,2)
(221,381,2)
(94,113,2)
(244,104,2)
(381,326,2)
(104,113,2)
(293,22,2)
(365,67,2)
(211,113,2)
(343,426,2)
(164,39,2)
(131,375,2)
(344,330,2)
-----------------------------------
(0,if(res->nodeType == N_ERROR)
(1,expr)
(2,break;)
(3,env)
(4,res)
(5,type)
(6,newPartialApplication(expr, newTupleRes(0,NULL,r)
(7,(Res **)
(8,text)
(9,expr)
(10,expr)
(11,appNode)
(12,r)
(13,evaluateFunction3(appNode, applyAll, expr, env, rei, reiSaveFlag, errmsg, r)
(14,Env *env)
(15,applyAll)
(16,*res = newRes(r)
(17,break;)
(18,type->nodeType == T_CONS && strcmp(type->text, FUNC)
(19,r)
(20,res)
(21,type = type->subtrees[1])
(22,res->nodeType == N_TUPLE && res->degree == 1)
(23,)
(24,expr->expr)
(25,)
(26,tupleComps)
(27,break;)
(28,reiSaveFlag)
(29,expr->subtrees)
(30,break;)
(31,applyAll)
(32,i)
(33,evaluateExpression3(expr->subtrees[0], applyAll, 0, rei, reiSaveFlag, env, errmsg,r)
(34,generateErrMsg("error: unsupported ast node type.", expr->expr, expr->base, errbuf)
(35,i)
(36,text)
(37,ruleEngineConfig)
(38,errbuf)
(39,i<expr->degree)
(40,Node *expr)
(41,r)
(42,res)
(43,nArgs)
(44,subtrees)
(45,res->degree)
(46,argRes->nodeType==N_ERROR)
(47,funcRes->nodeType==N_ERROR)
(48,sizeof(Res *)
(49,rError_t* errmsg)
(50,if(fd!=NULL)
(51,expr)
(52,subtrees)
(53,fd->exprType)
(54,r)
(55,env)
(56,r)
(57,expr->degree)
(58,errbuf)
(59,r)
(60,expr->subtrees)
(61,expr->subtrees[0])
(62,degree)
(63,if(nArgs == 0)
(64,extFuncDescIndex)
(65,expr->text)
(66,expr)
(67,ruleExecInfo_t *rei)
(68,expr)
(69,)
(70,res = argRes)
(71,evaluateFunctionApplication(funcRes, argRes, applyAll, expr, rei, reiSaveFlag, env, errmsg,r)
(72,i++)
(73,value)
(74,)
(75,)
(76,degree)
(77,default:)
(78,type)
(79,i)
(80,1)
(81,base)
(82,expr)
(83,res)
(84,return res;)
(85,errmsg)
(86,errmsg)
(87,text)
(88,expr->iotype == IO_TYPE_INPUT)
(89,-1)
(90,r)
(91,fd)
(92,0)
(93,res)
(94,res = newStringRes(r, expr->text)
(95,0)
(96,case N_APPLICATION:)
(97,expr)
(98,value)
(99,case N_TUPLE:)
(100,tupleComps)
(101,errmsg)
(102,0)
(103,tupleComps)
(104,expr->base)
(105,rei)
(106,expr)
(107,addRErrorMsg(errmsg, -1, errbuf)
(108,region_alloc(r, sizeof(Res *)
(109,break;)
(110,case TK_STRING:)
(111,nodeType)
(112,if(force || expr->iotype == IO_TYPE_INPUT)
(113,expr->nodeType)
(114,expr->degree)
(115,NULL)
(116,*fd = NULL)
(117,"error: evaluate actions using function evaluateExpression3, use function evaluateActions instead.")
(118,nArgs)
(119,applyAll)
(120,)
(121,expr->degree != 1)
(122,*type = fd->exprType)
(123,env)
(124,1)
(125,nodeType)
(126,1)
(127,0)
(128,0)
(129,expr)
(130,argRes)
(131,degree)
(132,1)
(133,0)
(134,res = funcRes)
(135,value)
(136,r)
(137,)
(138,res->nodeType)
(139,r)
(140,Res *)
(141,expr)
(142,env)
(143,rei)
(144,1)
(145,res)
(146,if(expr->degree == 0 || res->nodeType != N_ERROR)
(147,expr->iotype)
(148,i)
(149,appNode)
(150,dval)
(151,atof(expr->text)
(152,break;)
(153,type)
(154,r)
(155,FUNC)
(156,newSimpType(T_INT,r)
(157,res->value)
(158,i)
(159,applyAll)
(160,N_TUPLE)
(161,text)
(162,rei)
(163,type)
(164,0)
(165,res->nodeType != N_ERROR)
(166,type->subtrees[1])
(167,while(res->nodeType == N_TUPLE && res->degree == 1)
(168,expr)
(169,res->exprType)
(170,r)
(171,rei)
(172,rei)
(173,expr)
(174,newErrorRes(r, -1)
(175,case TK_INT:)
(176,NULL)
(177,subtrees)
(178,break;)
(179,case N_ACTIONS:)
(180,argRes)
(181,expr)
(182,argRes)
(183,res)
(184,fd)
(185,expr->subtrees)
(186,nArgs)
(187,res)
(188,lookupFromEnv(ruleEngineConfig.extFuncDescIndex, expr->text)
(189,subtrees)
(190,applyAll)
(191,tupleComps)
(192,expr->degree)
(193,newFuncSymLink(expr->text, nArgs, r)
(194,)
(195,r)
(196,env)
(197,degree)
(198,r)
(199,nodeType)
(200,ruleEngineConfig.extFuncDescIndex)
(201,text)
(202,expr)
(203,-1)
(204,if(expr->value.constructTuple || expr->degree != 1)
(205,r)
(206,evaluateActions(expr->subtrees[0], expr->subtrees[1], rei, reiSaveFlag, env, errmsg, r)
(207,expr->text)
(208,text)
(209,res = expr)
(210,force)
(211,expr->text)
(212,NULL)
(213,NULL)
(214,0)
(215,expr->text)
(216,if(funcRes->nodeType==N_ERROR)
(217,argRes)
(218,expr->value)
(219,res->nodeType)
(220,expr)
(221,fd)
(222,N_ERROR)
(223,expr)
(224,reiSaveFlag)
(225,expr)
(226,res = newErrorRes(r, -1)
(227,expr)
(228,sizeof(Res *)
(229,iotype)
(230,expr->subtrees[0])
(231,res->value.dval)
(232,nodeType)
(233,)
(234,expr->subtrees)
(235,N_ERROR)
(236,nodeType)
(237,)
(238,evaluateExpression3(expr->subtrees[i], applyAll, 0, rei, reiSaveFlag, env, errmsg, r)
(239,)
(240,res = newFuncSymLink(expr->text, 1, r)
(241,0)
(242,1)
(243,strcmp(type->text, FUNC)
(244,generateErrMsg("error: evaluate actions using function evaluateExpression3, use function evaluateActions instead.", expr->expr, expr->base, errbuf)
(245,-1)
(246,degree)
(247,argRes = evaluateExpression3(expr->subtrees[1], applyAll, 0, rei, reiSaveFlag, env, errmsg,r)
(248,appNode)
(249,reiSaveFlag)
(250,case TK_VAR:)
(251,nArgs)
(252,res)
(253,force || expr->iotype == IO_TYPE_INPUT)
(254,**tupleComps = NULL)
(255,res)
(256,argRes->nodeType)
(257,nodeType)
(258,strcmp(type->text, FUNC)
(259,res = evaluateVar3(expr->text, expr, rei, reiSaveFlag,  env, errmsg,r)
(260,expr->base)
(261,res)
(262,rei)
(263,funcRes = evaluateExpression3(expr->subtrees[0], applyAll, 0, rei, reiSaveFlag, env, errmsg,r)
(264,tupleComps)
(265,break;)
(266,type->subtrees)
(267,errmsg)
(268,exprType)
(269,1)
(270,reiSaveFlag)
(271,res)
(272,tupleComps[i])
(273,break;)
(274,reiSaveFlag)
(275,text)
(276,res)
(277,res)
(278,type->nodeType)
(279,res = newFuncSymLink(expr->text, nArgs, r)
(280,case TK_TEXT:)
(281,errmsg)
(282,expr->text)
(283,res)
(284,res->subtrees[0])
(285,subtrees)
(286,res->exprType = newSimpType(T_DOUBLE,r)
(287,int applyAll)
(288,)
(289,Region *r)
(290,fd)
(291,expr->text)
(292,env)
(293,res)
(294,reiSaveFlag)
(295,0)
(296,expr->value.constructTuple)
(297,newSimpType(T_DOUBLE,r)
(298,res)
(299,tupleComps = (Res **)
(300,i)
(301,newStringRes(r, expr->text)
(302,0)
(303,base)
(304,res)
(305,errmsg)
(306,argRes)
(307,case N_ACTIONS_RECOVERY:)
(308,funcRes)
(309,expr)
(310,nodeType)
(311,if(argRes->nodeType==N_ERROR)
(312,res)
(313,)
(314,)
(315,evaluateVar3(expr->text, expr, rei, reiSaveFlag,  env, errmsg,r)
(316,argRes)
(317,break;)
(318,expr->degree == 0)
(319,fd)
(320,1)
(321,expr)
(322,"error: unsupported ast node type.")
(323,while(type->nodeType == T_CONS && strcmp(type->text, FUNC)
(324,NULL)
(325,expr)
(326,fd = (FunctionDesc *)
(327,expr)
(328,)
(329,r)
(330,nArgs = 0)
(331,reiSaveFlag)
(332,res->degree == 1)
(333,break;)
(334,addRErrorMsg(errmsg, -1, errbuf)
(335,expr->subtrees[i])
(336,res)
(337,res->nodeType == N_ERROR)
(338,funcRes->nodeType)
(339,IO_TYPE_INPUT)
(340,res->nodeType)
(341,expr)
(342,errmsg)
(343,expr->value.constructTuple || expr->degree != 1)
(344,nArgs ++)
(345,N_ERROR)
(346,expr->text)
(347,funcRes)
(348,res)
(349,T_CONS)
(350,res = tupleComps[i] = evaluateExpression3(expr->subtrees[i], applyAll, 0, rei, reiSaveFlag, env, errmsg, r)
(351,errbuf)
(352,type)
(353,degree)
(354,Res **)
(355,for(i=0;i<expr->degree;i++)
(356,N_ERROR)
(357,res)
(358,expr->degree)
(359,subtrees)
(360,errbuf)
(361,int reiSaveFlag)
(362,0)
(363,expr->subtrees[1])
(364,type)
(365,evaluateExpression3(expr->subtrees[1], applyAll, 0, rei, reiSaveFlag, env, errmsg,r)
(366,res)
(367,funcRes)
(368,type->nodeType == T_CONS)
(369,expr)
(370,r)
(371,expr)
(372,funcRes)
(373,1)
(374,expr)
(375,res->nodeType == N_TUPLE)
(376,RET)
(377,FunctionDesc *)
(378,res->exprType = newSimpType(T_INT,r)
(379,res->value)
(380,newTupleRes(0,NULL,r)
(381,fd!=NULL)
(382,res->subtrees)
(383,res->value.dval=atof(expr->text)
(384,type->text)
(385,i=0)
(386,T_DOUBLE)
(387,res->exprType)
(388,expr)
(389,res)
(390,constructTuple)
(391,nArgs)
(392,rei)
(393,expr->subtrees[1])
(394,errmsg)
(395,*argRes = NULL)
(396,r)
(397,*appNode = newPartialApplication(expr, newTupleRes(0,NULL,r)
(398,)
(399,newFuncSymLink(expr->text, 1, r)
(400,text)
(401,res = evaluateFunctionApplication(funcRes, argRes, applyAll, expr, rei, reiSaveFlag, env, errmsg,r)
(402,atof(expr->text)
(403,res = newTupleRes(expr->degree, tupleComps, r)
(404,NULL)
(405,res = res->subtrees[0])
(406,nArgs == 0)
(407,res->value.dval=atof(expr->text)
(408,0)
(409,dval)
(410,res = evaluateActions(expr->subtrees[0], expr->subtrees[1], rei, reiSaveFlag, env, errmsg, r)
(411,newRes(r)
(412,break;)
(413,int force)
(414,*funcRes = NULL)
(415,funcRes)
(416,(FunctionDesc *)
(417,tupleComps[i] = evaluateExpression3(expr->subtrees[i], applyAll, 0, rei, reiSaveFlag, env, errmsg, r)
(418,expr->subtrees)
(419,newErrorRes(r, -1)
(420,errbuf)
(421,env)
(422,exprType)
(423,T_INT)
(424,expr)
(425,funcRes)
(426,expr->degree == 0 || res->nodeType != N_ERROR)
(427,newTupleRes(expr->degree, tupleComps, r)
(428,res = evaluateFunction3(appNode, applyAll, expr, env, rei, reiSaveFlag, errmsg, r)
(429,expr)
(430,-1)
(431,res = newErrorRes(r, -1)
(432,subtrees)
(433,switch(expr->nodeType)
(434,res->value.dval)
(435,expr->degree)
(436,res)
(437,expr)
(438,1)
(439,errmsg)
(440,break;)
(441,r)
(442,res)
(443,res)
(444,expr->expr)
(445,exprType)
(446,case TK_DOUBLE:)
(447,r)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^