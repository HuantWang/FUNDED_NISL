-----label-----
0
-----code-----
static void dw_mci_tasklet_func(unsigned long priv)
{
	struct dw_mci *host = (struct dw_mci *)priv;
	struct mmc_data	*data;
	struct mmc_command *cmd;
	enum dw_mci_state state;
	enum dw_mci_state prev_state;
	u32 status, ctrl;

	spin_lock(&host->lock);

	state = host->state;
	data = host->data;

	do {
		prev_state = state;

		switch (state) {
		case STATE_IDLE:
			break;

		case STATE_SENDING_CMD:
			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,
						&host->pending_events))
				break;

			cmd = host->cmd;
			host->cmd = NULL;
			set_bit(EVENT_CMD_COMPLETE, &host->completed_events);
			dw_mci_command_complete(host, cmd);
			if (cmd == host->mrq->sbc && !cmd->error) {
				prev_state = state = STATE_SENDING_CMD;
				__dw_mci_start_request(host, host->cur_slot,
						       host->mrq->cmd);
				goto unlock;
			}

			if (!host->mrq->data || cmd->error) {
				dw_mci_request_end(host, host->mrq);
				goto unlock;
			}

			prev_state = state = STATE_SENDING_DATA;
			/* fall through */

		case STATE_SENDING_DATA:
			if (test_and_clear_bit(EVENT_DATA_ERROR,
					       &host->pending_events)) {
				dw_mci_stop_dma(host);
				if (data->stop)
					send_stop_cmd(host, data);
				state = STATE_DATA_ERROR;
				break;
			}

			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,
						&host->pending_events))
				break;

			set_bit(EVENT_XFER_COMPLETE, &host->completed_events);
			prev_state = state = STATE_DATA_BUSY;
			/* fall through */

		case STATE_DATA_BUSY:
			if (!test_and_clear_bit(EVENT_DATA_COMPLETE,
						&host->pending_events))
				break;

			host->data = NULL;
			set_bit(EVENT_DATA_COMPLETE, &host->completed_events);
			status = host->data_status;

			if (status & DW_MCI_DATA_ERROR_FLAGS) {
				if (status & SDMMC_INT_DTO) {
					data->error = -ETIMEDOUT;
				} else if (status & SDMMC_INT_DCRC) {
					data->error = -EILSEQ;
				} else if (status & SDMMC_INT_EBE &&
					   host->dir_status ==
							DW_MCI_SEND_STATUS) {
					/*
					 * No data CRC status was returned.
					 * The number of bytes transferred will
					 * be exaggerated in PIO mode.
					 */
					data->bytes_xfered = 0;
					data->error = -ETIMEDOUT;
				} else {
					dev_err(host->dev,
						"data FIFO error "
						"(status=%08x)\n",
						status);
					data->error = -EIO;
				}
				/*
				 * After an error, there may be data lingering
				 * in the FIFO, so reset it - doing so
				 * generates a block interrupt, hence setting
				 * the scatter-gather pointer to NULL.
				 */
				sg_miter_stop(&host->sg_miter);
				host->sg = NULL;
				ctrl = mci_readl(host, CTRL);
				ctrl |= SDMMC_CTRL_FIFO_RESET;
				mci_writel(host, CTRL, ctrl);
			} else {
				data->bytes_xfered = data->blocks * data->blksz;
				data->error = 0;
			}

			if (!data->stop) {
				dw_mci_request_end(host, host->mrq);
				goto unlock;
			}

			if (host->mrq->sbc && !data->error) {
				data->stop->error = 0;
				dw_mci_request_end(host, host->mrq);
				goto unlock;
			}

			prev_state = state = STATE_SENDING_STOP;
			if (!data->error)
				send_stop_cmd(host, data);
			/* fall through */

		case STATE_SENDING_STOP:
			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,
						&host->pending_events))
				break;

			host->cmd = NULL;
			dw_mci_command_complete(host, host->mrq->stop);
			dw_mci_request_end(host, host->mrq);
			goto unlock;

		case STATE_DATA_ERROR:
			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,
						&host->pending_events))
				break;

			state = STATE_DATA_BUSY;
			break;
		}
	} while (state != prev_state);

	host->state = state;
unlock:
	spin_unlock(&host->lock);

}
-----children-----
1,2
1,3
1,4
3,4
3,5
5,6
5,7
7,8
9,10
9,11
9,12
9,13
9,14
9,15
9,16
9,17
9,18
9,19
9,20
9,21
10,11
11,12
11,13
12,13
14,15
14,16
14,17
17,18
18,19
18,20
19,20
19,21
20,21
22,23
24,25
26,27
27,28
27,29
28,29
30,31
30,32
33,34
34,35
34,36
35,36
37,38
37,39
40,41
41,42
41,43
42,43
44,45
46,47
47,48
47,49
48,49
50,51
52,53
53,54
53,55
53,56
54,55
56,57
58,59
60,61
61,62
61,63
62,63
64,65
65,66
65,67
66,67
69,70
70,71
70,72
71,72
73,74
73,75
74,75
77,78
78,79
78,80
79,80
81,82
81,83
82,83
85,86
85,87
86,87
86,88
87,88
88,89
88,90
89,90
91,92
93,94
93,95
94,95
96,97
96,98
96,99
96,100
96,101
96,102
96,103
96,104
96,105
96,106
96,107
96,108
96,109
96,110
96,111
96,112
96,113
96,114
96,115
96,116
96,117
96,118
96,119
96,120
96,121
96,122
96,123
96,124
96,125
96,126
96,127
96,128
96,129
96,130
96,131
96,132
97,98
98,99
101,102
102,103
104,105
104,106
105,106
106,107
106,108
106,109
107,108
109,110
111,112
112,113
112,114
113,114
117,118
118,119
118,120
119,120
121,122
121,123
122,123
125,126
126,127
126,128
127,128
127,129
128,129
131,132
133,134
134,135
134,136
134,137
135,136
137,138
139,140
140,141
140,142
141,142
144,145
145,146
145,147
145,148
146,147
148,149
150,151
152,153
152,154
153,154
153,155
154,155
154,156
155,156
157,158
157,159
158,159
158,160
159,160
163,164
164,165
164,166
165,166
168,169
168,170
168,171
169,170
170,171
170,172
171,172
173,174
173,175
174,175
176,177
178,179
179,180
179,181
179,182
179,183
180,181
182,183
184,185
184,186
185,186
188,189
188,190
189,190
189,191
190,191
194,195
196,197
196,198
197,198
197,199
198,199
199,200
199,201
200,201
200,202
201,202
205,206
205,207
206,207
209,210
209,211
210,211
211,212
211,213
211,214
212,213
214,215
216,217
216,218
217,218
220,221
222,223
223,224
223,225
224,225
226,227
226,228
227,228
229,230
231,232
232,233
234,235
234,236
235,236
235,237
235,238
236,237
238,239
240,241
241,242
241,243
242,243
245,246
245,247
245,248
245,249
246,247
247,248
247,249
248,249
250,251
252,253
252,254
253,254
253,255
254,255
257,258
258,259
258,260
258,261
259,260
261,262
263,264
265,266
266,267
266,268
267,268
269,270
272,273
272,274
273,274
274,275
274,276
274,277
275,276
277,278
279,280
280,281
280,282
281,282
285,286
286,287
286,288
286,289
287,288
289,290
291,292
292,293
292,294
293,294
296,297
297,298
297,299
298,299
300,301
300,302
301,302
303,304
305,306
306,307
308,309
308,310
309,310
310,311
310,312
310,313
311,312
313,314
315,316
316,317
316,318
317,318
321,322
322,323
322,324
323,324
323,325
324,325
327,328
329,330
330,331
330,332
330,333
331,332
333,334
335,336
336,337
336,338
337,338
340,341
341,342
341,343
342,343
344,345
344,346
345,346
348,349
348,350
348,351
349,350
349,351
350,351
352,353
354,355
354,356
354,357
354,358
354,359
354,360
355,356
355,357
355,358
356,357
356,358
357,358
359,360
361,362
362,363
363,364
363,365
364,365
364,366
365,366
368,369
369,370
371,372
371,373
371,374
372,373
372,374
373,374
375,376
377,378
378,379
379,380
379,381
380,381
380,382
381,382
384,385
385,386
387,388
387,389
387,390
388,389
388,390
389,390
389,391
390,391
392,393
394,395
394,396
395,396
395,397
396,397
399,400
401,402
401,403
402,403
403,404
403,405
404,405
404,406
405,406
409,410
410,411
410,412
411,412
411,413
412,413
415,416
416,417
418,419
418,420
419,420
420,421
420,422
420,423
420,424
421,422
423,424
423,425
424,425
428,429
430,431
431,432
431,433
432,433
432,434
433,434
436,437
437,438
439,440
440,441
440,442
441,442
443,444
444,445
444,446
445,446
448,449
449,450
449,451
450,451
450,452
451,452
454,455
456,457
457,458
457,459
458,459
460,461
460,462
460,463
461,462
463,464
465,466
467,468
468,469
468,470
469,470
471,472
473,474
474,475
474,476
474,477
474,478
475,476
477,478
479,480
481,482
483,484
483,485
484,485
485,486
485,487
486,487
486,488
487,488
490,491
490,492
491,492
491,493
492,493
495,496
495,497
496,497
499,500
500,501
500,502
501,502
501,503
502,503
506,507
506,508
507,508
508,509
508,510
509,510
512,513
512,514
513,514
514,515
514,516
514,517
515,516
517,518
519,520
519,521
520,521
523,524
525,526
525,527
526,527
526,528
527,528
527,529
528,529
528,530
529,530
533,534
534,535
534,536
535,536
538,539
538,540
538,541
539,540
540,541
540,542
541,542
541,543
542,543
542,544
543,544
548,549
549,550
549,551
549,552
550,551
552,553
554,555
554,556
555,556
558,559
560,561
561,562
561,563
562,563
564,565
564,566
565,566
567,568
569,570
569,571
570,571
571,572
571,573
572,573
575,576
576,577
576,578
576,579
577,578
579,580
581,582
583,584
584,585
586,587
586,588
587,588
588,589
588,590
588,591
589,590
591,592
593,594
594,595
594,596
595,596
599,600
600,601
600,602
601,602
601,603
602,603
605,606
607,608
608,609
608,610
608,611
609,610
611,612
613,614
613,615
614,615
614,616
615,616
619,620
620,621
620,622
620,623
621,622
623,624
625,626
625,627
626,627
629,630
631,632
632,633
634,635
634,636
635,636
636,637
636,638
636,639
637,638
639,640
641,642
642,643
642,644
643,644
647,648
648,649
648,650
649,650
651,652
654,655
654,656
655,656
657,658
659,660
660,661
660,662
661,662
661,663
662,663
665,666
667,668
667,669
669,670
670,671
670,672
671,672
673,674
674,675
674,676
675,676
-----nextToken-----
2,4,6,8,13,15,16,21,23,25,29,31,32,36,38,39,43,45,49,51,55,57,59,63,67,68,72,75,76,80,83,84,90,92,95,99,100,103,108,110,114,115,116,120,123,124,129,130,132,136,138,142,143,147,149,151,156,160,161,162,166,167,172,175,177,181,183,186,187,191,192,193,195,202,203,204,207,208,213,215,218,219,221,225,228,230,233,237,239,243,244,249,251,255,256,260,262,264,268,270,271,276,278,282,283,284,288,290,294,295,299,302,304,307,312,314,318,319,320,325,326,328,332,334,338,339,343,346,347,351,353,358,360,366,367,370,374,376,382,383,386,391,393,397,398,400,406,407,408,413,414,417,422,425,426,427,429,434,435,438,442,446,447,452,453,455,459,462,464,466,470,472,476,478,480,482,488,489,493,494,497,498,503,504,505,510,511,516,518,521,522,524,530,531,532,536,537,544,545,546,547,551,553,556,557,559,563,566,568,573,574,578,580,582,585,590,592,596,597,598,603,604,606,610,612,616,617,618,622,624,627,628,630,633,638,640,644,645,646,650,652,653,656,658,663,664,666,668,672,676,677
-----computeFrom-----
70,71
70,72
78,79
78,80
88,89
88,90
118,119
118,120
126,127
126,128
153,154
153,155
154,155
154,156
170,171
170,172
173,174
173,175
197,198
197,199
223,224
223,225
226,227
226,228
266,267
266,268
297,298
297,299
300,301
300,302
322,323
322,324
341,342
341,343
349,350
349,351
356,357
356,358
363,364
363,365
372,373
372,374
379,380
379,381
388,389
388,390
389,390
389,391
394,395
394,396
403,404
403,405
410,411
410,412
431,432
431,433
449,450
449,451
457,458
457,459
468,469
468,470
485,486
485,487
490,491
490,492
500,501
500,502
526,527
526,528
540,541
540,542
561,562
561,563
564,565
564,566
600,601
600,602
648,649
648,650
654,655
654,656
660,661
660,662
-----guardedBy-----
160,191
166,193
161,192
202,218
203,219
351,429
536,544
530,556
537,546
531,557
-----guardedByNegation-----
358,429
374,429
397,425
391,429
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;CastExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;Pointer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;DoStatement;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;SwitchStatement;IdExpression;Name;CompoundStatement;CaseStatement;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;BreakStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;GotoStatement;Name;IfStatement;BinaryExpression;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;GotoStatement;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;CaseStatement;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BreakStatement;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;BreakStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;CaseStatement;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;BreakStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IfStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;GotoStatement;Name;IfStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;GotoStatement;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CaseStatement;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;BreakStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;GotoStatement;Name;CaseStatement;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;BreakStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BreakStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;LabelStatement;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;
-----ast_node-----
static void dw_mci_tasklet_func(unsigned long priv){	struct dw_mci *host = (struct dw_mci *)priv;	struct mmc_data	*data;	struct mmc_command *cmd;	enum dw_mci_state state;	enum dw_mci_state prev_state;	u32 status, ctrl;	spin_lock(&host->lock);	state = host->state;	data = host->data;	do {		prev_state = state;		switch (state) {		case STATE_IDLE:			break;		case STATE_SENDING_CMD:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			cmd = host->cmd;			host->cmd = NULL;			set_bit(EVENT_CMD_COMPLETE, &host->completed_events);			dw_mci_command_complete(host, cmd);			if (cmd == host->mrq->sbc && !cmd->error) {				prev_state = state = STATE_SENDING_CMD;				__dw_mci_start_request(host, host->cur_slot,						       host->mrq->cmd);				goto unlock;			}			if (!host->mrq->data || cmd->error) {				dw_mci_request_end(host, host->mrq);				goto unlock;			}			prev_state = state = STATE_SENDING_DATA;			/* fall through */		case STATE_SENDING_DATA:			if (test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)) {				dw_mci_stop_dma(host);				if (data->stop)					send_stop_cmd(host, data);				state = STATE_DATA_ERROR;				break;			}			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events))				break;			set_bit(EVENT_XFER_COMPLETE, &host->completed_events);			prev_state = state = STATE_DATA_BUSY;			/* fall through */		case STATE_DATA_BUSY:			if (!test_and_clear_bit(EVENT_DATA_COMPLETE,						&host->pending_events))				break;			host->data = NULL;			set_bit(EVENT_DATA_COMPLETE, &host->completed_events);			status = host->data_status;			if (status & DW_MCI_DATA_ERROR_FLAGS) {				if (status & SDMMC_INT_DTO) {					data->error = -ETIMEDOUT;				} else if (status & SDMMC_INT_DCRC) {					data->error = -EILSEQ;				} else if (status & SDMMC_INT_EBE &&					   host->dir_status ==							DW_MCI_SEND_STATUS) {					/*					 * No data CRC status was returned.					 * The number of bytes transferred will					 * be exaggerated in PIO mode.					 */					data->bytes_xfered = 0;					data->error = -ETIMEDOUT;				} else {					dev_err(host->dev,						"data FIFO error "						"(status=%08x)\n",						status);					data->error = -EIO;				}				/*				 * After an error, there may be data lingering				 * in the FIFO, so reset it - doing so				 * generates a block interrupt, hence setting				 * the scatter-gather pointer to NULL.				 */				sg_miter_stop(&host->sg_miter);				host->sg = NULL;				ctrl = mci_readl(host, CTRL);				ctrl |= SDMMC_CTRL_FIFO_RESET;				mci_writel(host, CTRL, ctrl);			} else {				data->bytes_xfered = data->blocks * data->blksz;				data->error = 0;			}			if (!data->stop) {				dw_mci_request_end(host, host->mrq);				goto unlock;			}			if (host->mrq->sbc && !data->error) {				data->stop->error = 0;				dw_mci_request_end(host, host->mrq);				goto unlock;			}			prev_state = state = STATE_SENDING_STOP;			if (!data->error)				send_stop_cmd(host, data);			/* fall through */		case STATE_SENDING_STOP:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			host->cmd = NULL;			dw_mci_command_complete(host, host->mrq->stop);			dw_mci_request_end(host, host->mrq);			goto unlock;		case STATE_DATA_ERROR:			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events))				break;			state = STATE_DATA_BUSY;			break;		}	} while (state != prev_state);	host->state = state;unlock:	spin_unlock(&host->lock);}
static void
dw_mci_tasklet_func(unsigned long priv)
dw_mci_tasklet_func
unsigned long priv
unsigned long
priv
priv
{	struct dw_mci *host = (struct dw_mci *)priv;	struct mmc_data	*data;	struct mmc_command *cmd;	enum dw_mci_state state;	enum dw_mci_state prev_state;	u32 status, ctrl;	spin_lock(&host->lock);	state = host->state;	data = host->data;	do {		prev_state = state;		switch (state) {		case STATE_IDLE:			break;		case STATE_SENDING_CMD:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			cmd = host->cmd;			host->cmd = NULL;			set_bit(EVENT_CMD_COMPLETE, &host->completed_events);			dw_mci_command_complete(host, cmd);			if (cmd == host->mrq->sbc && !cmd->error) {				prev_state = state = STATE_SENDING_CMD;				__dw_mci_start_request(host, host->cur_slot,						       host->mrq->cmd);				goto unlock;			}			if (!host->mrq->data || cmd->error) {				dw_mci_request_end(host, host->mrq);				goto unlock;			}			prev_state = state = STATE_SENDING_DATA;			/* fall through */		case STATE_SENDING_DATA:			if (test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)) {				dw_mci_stop_dma(host);				if (data->stop)					send_stop_cmd(host, data);				state = STATE_DATA_ERROR;				break;			}			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events))				break;			set_bit(EVENT_XFER_COMPLETE, &host->completed_events);			prev_state = state = STATE_DATA_BUSY;			/* fall through */		case STATE_DATA_BUSY:			if (!test_and_clear_bit(EVENT_DATA_COMPLETE,						&host->pending_events))				break;			host->data = NULL;			set_bit(EVENT_DATA_COMPLETE, &host->completed_events);			status = host->data_status;			if (status & DW_MCI_DATA_ERROR_FLAGS) {				if (status & SDMMC_INT_DTO) {					data->error = -ETIMEDOUT;				} else if (status & SDMMC_INT_DCRC) {					data->error = -EILSEQ;				} else if (status & SDMMC_INT_EBE &&					   host->dir_status ==							DW_MCI_SEND_STATUS) {					/*					 * No data CRC status was returned.					 * The number of bytes transferred will					 * be exaggerated in PIO mode.					 */					data->bytes_xfered = 0;					data->error = -ETIMEDOUT;				} else {					dev_err(host->dev,						"data FIFO error "						"(status=%08x)\n",						status);					data->error = -EIO;				}				/*				 * After an error, there may be data lingering				 * in the FIFO, so reset it - doing so				 * generates a block interrupt, hence setting				 * the scatter-gather pointer to NULL.				 */				sg_miter_stop(&host->sg_miter);				host->sg = NULL;				ctrl = mci_readl(host, CTRL);				ctrl |= SDMMC_CTRL_FIFO_RESET;				mci_writel(host, CTRL, ctrl);			} else {				data->bytes_xfered = data->blocks * data->blksz;				data->error = 0;			}			if (!data->stop) {				dw_mci_request_end(host, host->mrq);				goto unlock;			}			if (host->mrq->sbc && !data->error) {				data->stop->error = 0;				dw_mci_request_end(host, host->mrq);				goto unlock;			}			prev_state = state = STATE_SENDING_STOP;			if (!data->error)				send_stop_cmd(host, data);			/* fall through */		case STATE_SENDING_STOP:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			host->cmd = NULL;			dw_mci_command_complete(host, host->mrq->stop);			dw_mci_request_end(host, host->mrq);			goto unlock;		case STATE_DATA_ERROR:			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events))				break;			state = STATE_DATA_BUSY;			break;		}	} while (state != prev_state);	host->state = state;unlock:	spin_unlock(&host->lock);}
struct dw_mci *host = (struct dw_mci *)priv;
struct dw_mci *host = (struct dw_mci *)priv;
struct dw_mci
dw_mci
*host = (struct dw_mci *)priv
*
host
= (struct dw_mci *)priv
(struct dw_mci *)priv
struct dw_mci *
struct dw_mci
dw_mci
*
*
priv
priv
struct mmc_data	*data;
struct mmc_data	*data;
struct mmc_data
mmc_data
*data
*
data
struct mmc_command *cmd;
struct mmc_command *cmd;
struct mmc_command
mmc_command
*cmd
*
cmd
enum dw_mci_state state;
enum dw_mci_state state;
enum dw_mci_state
dw_mci_state
state
state
enum dw_mci_state prev_state;
enum dw_mci_state prev_state;
enum dw_mci_state
dw_mci_state
prev_state
prev_state
u32 status, ctrl;
u32 status, ctrl;
u32
u32
status
status
ctrl
ctrl
spin_lock(&host->lock);
spin_lock(&host->lock)
spin_lock
spin_lock
&host->lock
host->lock
host
host
lock
state = host->state;
state = host->state
state
state
host->state
host
host
state
data = host->data;
data = host->data
data
data
host->data
host
host
data
do {		prev_state = state;		switch (state) {		case STATE_IDLE:			break;		case STATE_SENDING_CMD:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			cmd = host->cmd;			host->cmd = NULL;			set_bit(EVENT_CMD_COMPLETE, &host->completed_events);			dw_mci_command_complete(host, cmd);			if (cmd == host->mrq->sbc && !cmd->error) {				prev_state = state = STATE_SENDING_CMD;				__dw_mci_start_request(host, host->cur_slot,						       host->mrq->cmd);				goto unlock;			}			if (!host->mrq->data || cmd->error) {				dw_mci_request_end(host, host->mrq);				goto unlock;			}			prev_state = state = STATE_SENDING_DATA;			/* fall through */		case STATE_SENDING_DATA:			if (test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)) {				dw_mci_stop_dma(host);				if (data->stop)					send_stop_cmd(host, data);				state = STATE_DATA_ERROR;				break;			}			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events))				break;			set_bit(EVENT_XFER_COMPLETE, &host->completed_events);			prev_state = state = STATE_DATA_BUSY;			/* fall through */		case STATE_DATA_BUSY:			if (!test_and_clear_bit(EVENT_DATA_COMPLETE,						&host->pending_events))				break;			host->data = NULL;			set_bit(EVENT_DATA_COMPLETE, &host->completed_events);			status = host->data_status;			if (status & DW_MCI_DATA_ERROR_FLAGS) {				if (status & SDMMC_INT_DTO) {					data->error = -ETIMEDOUT;				} else if (status & SDMMC_INT_DCRC) {					data->error = -EILSEQ;				} else if (status & SDMMC_INT_EBE &&					   host->dir_status ==							DW_MCI_SEND_STATUS) {					/*					 * No data CRC status was returned.					 * The number of bytes transferred will					 * be exaggerated in PIO mode.					 */					data->bytes_xfered = 0;					data->error = -ETIMEDOUT;				} else {					dev_err(host->dev,						"data FIFO error "						"(status=%08x)\n",						status);					data->error = -EIO;				}				/*				 * After an error, there may be data lingering				 * in the FIFO, so reset it - doing so				 * generates a block interrupt, hence setting				 * the scatter-gather pointer to NULL.				 */				sg_miter_stop(&host->sg_miter);				host->sg = NULL;				ctrl = mci_readl(host, CTRL);				ctrl |= SDMMC_CTRL_FIFO_RESET;				mci_writel(host, CTRL, ctrl);			} else {				data->bytes_xfered = data->blocks * data->blksz;				data->error = 0;			}			if (!data->stop) {				dw_mci_request_end(host, host->mrq);				goto unlock;			}			if (host->mrq->sbc && !data->error) {				data->stop->error = 0;				dw_mci_request_end(host, host->mrq);				goto unlock;			}			prev_state = state = STATE_SENDING_STOP;			if (!data->error)				send_stop_cmd(host, data);			/* fall through */		case STATE_SENDING_STOP:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			host->cmd = NULL;			dw_mci_command_complete(host, host->mrq->stop);			dw_mci_request_end(host, host->mrq);			goto unlock;		case STATE_DATA_ERROR:			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events))				break;			state = STATE_DATA_BUSY;			break;		}	} while (state != prev_state);
{		prev_state = state;		switch (state) {		case STATE_IDLE:			break;		case STATE_SENDING_CMD:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			cmd = host->cmd;			host->cmd = NULL;			set_bit(EVENT_CMD_COMPLETE, &host->completed_events);			dw_mci_command_complete(host, cmd);			if (cmd == host->mrq->sbc && !cmd->error) {				prev_state = state = STATE_SENDING_CMD;				__dw_mci_start_request(host, host->cur_slot,						       host->mrq->cmd);				goto unlock;			}			if (!host->mrq->data || cmd->error) {				dw_mci_request_end(host, host->mrq);				goto unlock;			}			prev_state = state = STATE_SENDING_DATA;			/* fall through */		case STATE_SENDING_DATA:			if (test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)) {				dw_mci_stop_dma(host);				if (data->stop)					send_stop_cmd(host, data);				state = STATE_DATA_ERROR;				break;			}			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events))				break;			set_bit(EVENT_XFER_COMPLETE, &host->completed_events);			prev_state = state = STATE_DATA_BUSY;			/* fall through */		case STATE_DATA_BUSY:			if (!test_and_clear_bit(EVENT_DATA_COMPLETE,						&host->pending_events))				break;			host->data = NULL;			set_bit(EVENT_DATA_COMPLETE, &host->completed_events);			status = host->data_status;			if (status & DW_MCI_DATA_ERROR_FLAGS) {				if (status & SDMMC_INT_DTO) {					data->error = -ETIMEDOUT;				} else if (status & SDMMC_INT_DCRC) {					data->error = -EILSEQ;				} else if (status & SDMMC_INT_EBE &&					   host->dir_status ==							DW_MCI_SEND_STATUS) {					/*					 * No data CRC status was returned.					 * The number of bytes transferred will					 * be exaggerated in PIO mode.					 */					data->bytes_xfered = 0;					data->error = -ETIMEDOUT;				} else {					dev_err(host->dev,						"data FIFO error "						"(status=%08x)\n",						status);					data->error = -EIO;				}				/*				 * After an error, there may be data lingering				 * in the FIFO, so reset it - doing so				 * generates a block interrupt, hence setting				 * the scatter-gather pointer to NULL.				 */				sg_miter_stop(&host->sg_miter);				host->sg = NULL;				ctrl = mci_readl(host, CTRL);				ctrl |= SDMMC_CTRL_FIFO_RESET;				mci_writel(host, CTRL, ctrl);			} else {				data->bytes_xfered = data->blocks * data->blksz;				data->error = 0;			}			if (!data->stop) {				dw_mci_request_end(host, host->mrq);				goto unlock;			}			if (host->mrq->sbc && !data->error) {				data->stop->error = 0;				dw_mci_request_end(host, host->mrq);				goto unlock;			}			prev_state = state = STATE_SENDING_STOP;			if (!data->error)				send_stop_cmd(host, data);			/* fall through */		case STATE_SENDING_STOP:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			host->cmd = NULL;			dw_mci_command_complete(host, host->mrq->stop);			dw_mci_request_end(host, host->mrq);			goto unlock;		case STATE_DATA_ERROR:			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events))				break;			state = STATE_DATA_BUSY;			break;		}	}
prev_state = state;
prev_state = state
prev_state
prev_state
state
state
switch (state) {		case STATE_IDLE:			break;		case STATE_SENDING_CMD:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			cmd = host->cmd;			host->cmd = NULL;			set_bit(EVENT_CMD_COMPLETE, &host->completed_events);			dw_mci_command_complete(host, cmd);			if (cmd == host->mrq->sbc && !cmd->error) {				prev_state = state = STATE_SENDING_CMD;				__dw_mci_start_request(host, host->cur_slot,						       host->mrq->cmd);				goto unlock;			}			if (!host->mrq->data || cmd->error) {				dw_mci_request_end(host, host->mrq);				goto unlock;			}			prev_state = state = STATE_SENDING_DATA;			/* fall through */		case STATE_SENDING_DATA:			if (test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)) {				dw_mci_stop_dma(host);				if (data->stop)					send_stop_cmd(host, data);				state = STATE_DATA_ERROR;				break;			}			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events))				break;			set_bit(EVENT_XFER_COMPLETE, &host->completed_events);			prev_state = state = STATE_DATA_BUSY;			/* fall through */		case STATE_DATA_BUSY:			if (!test_and_clear_bit(EVENT_DATA_COMPLETE,						&host->pending_events))				break;			host->data = NULL;			set_bit(EVENT_DATA_COMPLETE, &host->completed_events);			status = host->data_status;			if (status & DW_MCI_DATA_ERROR_FLAGS) {				if (status & SDMMC_INT_DTO) {					data->error = -ETIMEDOUT;				} else if (status & SDMMC_INT_DCRC) {					data->error = -EILSEQ;				} else if (status & SDMMC_INT_EBE &&					   host->dir_status ==							DW_MCI_SEND_STATUS) {					/*					 * No data CRC status was returned.					 * The number of bytes transferred will					 * be exaggerated in PIO mode.					 */					data->bytes_xfered = 0;					data->error = -ETIMEDOUT;				} else {					dev_err(host->dev,						"data FIFO error "						"(status=%08x)\n",						status);					data->error = -EIO;				}				/*				 * After an error, there may be data lingering				 * in the FIFO, so reset it - doing so				 * generates a block interrupt, hence setting				 * the scatter-gather pointer to NULL.				 */				sg_miter_stop(&host->sg_miter);				host->sg = NULL;				ctrl = mci_readl(host, CTRL);				ctrl |= SDMMC_CTRL_FIFO_RESET;				mci_writel(host, CTRL, ctrl);			} else {				data->bytes_xfered = data->blocks * data->blksz;				data->error = 0;			}			if (!data->stop) {				dw_mci_request_end(host, host->mrq);				goto unlock;			}			if (host->mrq->sbc && !data->error) {				data->stop->error = 0;				dw_mci_request_end(host, host->mrq);				goto unlock;			}			prev_state = state = STATE_SENDING_STOP;			if (!data->error)				send_stop_cmd(host, data);			/* fall through */		case STATE_SENDING_STOP:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			host->cmd = NULL;			dw_mci_command_complete(host, host->mrq->stop);			dw_mci_request_end(host, host->mrq);			goto unlock;		case STATE_DATA_ERROR:			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events))				break;			state = STATE_DATA_BUSY;			break;		}
state
state
{		case STATE_IDLE:			break;		case STATE_SENDING_CMD:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			cmd = host->cmd;			host->cmd = NULL;			set_bit(EVENT_CMD_COMPLETE, &host->completed_events);			dw_mci_command_complete(host, cmd);			if (cmd == host->mrq->sbc && !cmd->error) {				prev_state = state = STATE_SENDING_CMD;				__dw_mci_start_request(host, host->cur_slot,						       host->mrq->cmd);				goto unlock;			}			if (!host->mrq->data || cmd->error) {				dw_mci_request_end(host, host->mrq);				goto unlock;			}			prev_state = state = STATE_SENDING_DATA;			/* fall through */		case STATE_SENDING_DATA:			if (test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)) {				dw_mci_stop_dma(host);				if (data->stop)					send_stop_cmd(host, data);				state = STATE_DATA_ERROR;				break;			}			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events))				break;			set_bit(EVENT_XFER_COMPLETE, &host->completed_events);			prev_state = state = STATE_DATA_BUSY;			/* fall through */		case STATE_DATA_BUSY:			if (!test_and_clear_bit(EVENT_DATA_COMPLETE,						&host->pending_events))				break;			host->data = NULL;			set_bit(EVENT_DATA_COMPLETE, &host->completed_events);			status = host->data_status;			if (status & DW_MCI_DATA_ERROR_FLAGS) {				if (status & SDMMC_INT_DTO) {					data->error = -ETIMEDOUT;				} else if (status & SDMMC_INT_DCRC) {					data->error = -EILSEQ;				} else if (status & SDMMC_INT_EBE &&					   host->dir_status ==							DW_MCI_SEND_STATUS) {					/*					 * No data CRC status was returned.					 * The number of bytes transferred will					 * be exaggerated in PIO mode.					 */					data->bytes_xfered = 0;					data->error = -ETIMEDOUT;				} else {					dev_err(host->dev,						"data FIFO error "						"(status=%08x)\n",						status);					data->error = -EIO;				}				/*				 * After an error, there may be data lingering				 * in the FIFO, so reset it - doing so				 * generates a block interrupt, hence setting				 * the scatter-gather pointer to NULL.				 */				sg_miter_stop(&host->sg_miter);				host->sg = NULL;				ctrl = mci_readl(host, CTRL);				ctrl |= SDMMC_CTRL_FIFO_RESET;				mci_writel(host, CTRL, ctrl);			} else {				data->bytes_xfered = data->blocks * data->blksz;				data->error = 0;			}			if (!data->stop) {				dw_mci_request_end(host, host->mrq);				goto unlock;			}			if (host->mrq->sbc && !data->error) {				data->stop->error = 0;				dw_mci_request_end(host, host->mrq);				goto unlock;			}			prev_state = state = STATE_SENDING_STOP;			if (!data->error)				send_stop_cmd(host, data);			/* fall through */		case STATE_SENDING_STOP:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			host->cmd = NULL;			dw_mci_command_complete(host, host->mrq->stop);			dw_mci_request_end(host, host->mrq);			goto unlock;		case STATE_DATA_ERROR:			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events))				break;			state = STATE_DATA_BUSY;			break;		}
case STATE_IDLE:
STATE_IDLE
STATE_IDLE
break;
case STATE_SENDING_CMD:
STATE_SENDING_CMD
STATE_SENDING_CMD
if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;
!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events)
test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events)
test_and_clear_bit
test_and_clear_bit
EVENT_CMD_COMPLETE
EVENT_CMD_COMPLETE
&host->pending_events
host->pending_events
host
host
pending_events
break;
cmd = host->cmd;
cmd = host->cmd
cmd
cmd
host->cmd
host
host
cmd
host->cmd = NULL;
host->cmd = NULL
host->cmd
host
host
cmd
NULL
NULL
set_bit(EVENT_CMD_COMPLETE, &host->completed_events);
set_bit(EVENT_CMD_COMPLETE, &host->completed_events)
set_bit
set_bit
EVENT_CMD_COMPLETE
EVENT_CMD_COMPLETE
&host->completed_events
host->completed_events
host
host
completed_events
dw_mci_command_complete(host, cmd);
dw_mci_command_complete(host, cmd)
dw_mci_command_complete
dw_mci_command_complete
host
host
cmd
cmd
if (cmd == host->mrq->sbc && !cmd->error) {				prev_state = state = STATE_SENDING_CMD;				__dw_mci_start_request(host, host->cur_slot,						       host->mrq->cmd);				goto unlock;			}
cmd == host->mrq->sbc && !cmd->error
cmd == host->mrq->sbc
cmd
cmd
host->mrq->sbc
host->mrq
host
host
mrq
sbc
!cmd->error
cmd->error
cmd
cmd
error
{				prev_state = state = STATE_SENDING_CMD;				__dw_mci_start_request(host, host->cur_slot,						       host->mrq->cmd);				goto unlock;			}
prev_state = state = STATE_SENDING_CMD;
prev_state = state = STATE_SENDING_CMD
prev_state
prev_state
state = STATE_SENDING_CMD
state
state
STATE_SENDING_CMD
STATE_SENDING_CMD
__dw_mci_start_request(host, host->cur_slot,						       host->mrq->cmd);
__dw_mci_start_request(host, host->cur_slot,						       host->mrq->cmd)
__dw_mci_start_request
__dw_mci_start_request
host
host
host->cur_slot
host
host
cur_slot
host->mrq->cmd
host->mrq
host
host
mrq
cmd
goto unlock;
unlock
if (!host->mrq->data || cmd->error) {				dw_mci_request_end(host, host->mrq);				goto unlock;			}
!host->mrq->data || cmd->error
!host->mrq->data
host->mrq->data
host->mrq
host
host
mrq
data
cmd->error
cmd
cmd
error
{				dw_mci_request_end(host, host->mrq);				goto unlock;			}
dw_mci_request_end(host, host->mrq);
dw_mci_request_end(host, host->mrq)
dw_mci_request_end
dw_mci_request_end
host
host
host->mrq
host
host
mrq
goto unlock;
unlock
prev_state = state = STATE_SENDING_DATA;
prev_state = state = STATE_SENDING_DATA
prev_state
prev_state
state = STATE_SENDING_DATA
state
state
STATE_SENDING_DATA
STATE_SENDING_DATA
case STATE_SENDING_DATA:
STATE_SENDING_DATA
STATE_SENDING_DATA
if (test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)) {				dw_mci_stop_dma(host);				if (data->stop)					send_stop_cmd(host, data);				state = STATE_DATA_ERROR;				break;			}
test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)
test_and_clear_bit
test_and_clear_bit
EVENT_DATA_ERROR
EVENT_DATA_ERROR
&host->pending_events
host->pending_events
host
host
pending_events
{				dw_mci_stop_dma(host);				if (data->stop)					send_stop_cmd(host, data);				state = STATE_DATA_ERROR;				break;			}
dw_mci_stop_dma(host);
dw_mci_stop_dma(host)
dw_mci_stop_dma
dw_mci_stop_dma
host
host
if (data->stop)					send_stop_cmd(host, data);
data->stop
data
data
stop
send_stop_cmd(host, data);
send_stop_cmd(host, data)
send_stop_cmd
send_stop_cmd
host
host
data
data
state = STATE_DATA_ERROR;
state = STATE_DATA_ERROR
state
state
STATE_DATA_ERROR
STATE_DATA_ERROR
break;
if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events))				break;
!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events)
test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events)
test_and_clear_bit
test_and_clear_bit
EVENT_XFER_COMPLETE
EVENT_XFER_COMPLETE
&host->pending_events
host->pending_events
host
host
pending_events
break;
set_bit(EVENT_XFER_COMPLETE, &host->completed_events);
set_bit(EVENT_XFER_COMPLETE, &host->completed_events)
set_bit
set_bit
EVENT_XFER_COMPLETE
EVENT_XFER_COMPLETE
&host->completed_events
host->completed_events
host
host
completed_events
prev_state = state = STATE_DATA_BUSY;
prev_state = state = STATE_DATA_BUSY
prev_state
prev_state
state = STATE_DATA_BUSY
state
state
STATE_DATA_BUSY
STATE_DATA_BUSY
case STATE_DATA_BUSY:
STATE_DATA_BUSY
STATE_DATA_BUSY
if (!test_and_clear_bit(EVENT_DATA_COMPLETE,						&host->pending_events))				break;
!test_and_clear_bit(EVENT_DATA_COMPLETE,						&host->pending_events)
test_and_clear_bit(EVENT_DATA_COMPLETE,						&host->pending_events)
test_and_clear_bit
test_and_clear_bit
EVENT_DATA_COMPLETE
EVENT_DATA_COMPLETE
&host->pending_events
host->pending_events
host
host
pending_events
break;
host->data = NULL;
host->data = NULL
host->data
host
host
data
NULL
NULL
set_bit(EVENT_DATA_COMPLETE, &host->completed_events);
set_bit(EVENT_DATA_COMPLETE, &host->completed_events)
set_bit
set_bit
EVENT_DATA_COMPLETE
EVENT_DATA_COMPLETE
&host->completed_events
host->completed_events
host
host
completed_events
status = host->data_status;
status = host->data_status
status
status
host->data_status
host
host
data_status
if (status & DW_MCI_DATA_ERROR_FLAGS) {				if (status & SDMMC_INT_DTO) {					data->error = -ETIMEDOUT;				} else if (status & SDMMC_INT_DCRC) {					data->error = -EILSEQ;				} else if (status & SDMMC_INT_EBE &&					   host->dir_status ==							DW_MCI_SEND_STATUS) {					/*					 * No data CRC status was returned.					 * The number of bytes transferred will					 * be exaggerated in PIO mode.					 */					data->bytes_xfered = 0;					data->error = -ETIMEDOUT;				} else {					dev_err(host->dev,						"data FIFO error "						"(status=%08x)\n",						status);					data->error = -EIO;				}				/*				 * After an error, there may be data lingering				 * in the FIFO, so reset it - doing so				 * generates a block interrupt, hence setting				 * the scatter-gather pointer to NULL.				 */				sg_miter_stop(&host->sg_miter);				host->sg = NULL;				ctrl = mci_readl(host, CTRL);				ctrl |= SDMMC_CTRL_FIFO_RESET;				mci_writel(host, CTRL, ctrl);			} else {				data->bytes_xfered = data->blocks * data->blksz;				data->error = 0;			}
status & DW_MCI_DATA_ERROR_FLAGS
status
status
DW_MCI_DATA_ERROR_FLAGS
DW_MCI_DATA_ERROR_FLAGS
{				if (status & SDMMC_INT_DTO) {					data->error = -ETIMEDOUT;				} else if (status & SDMMC_INT_DCRC) {					data->error = -EILSEQ;				} else if (status & SDMMC_INT_EBE &&					   host->dir_status ==							DW_MCI_SEND_STATUS) {					/*					 * No data CRC status was returned.					 * The number of bytes transferred will					 * be exaggerated in PIO mode.					 */					data->bytes_xfered = 0;					data->error = -ETIMEDOUT;				} else {					dev_err(host->dev,						"data FIFO error "						"(status=%08x)\n",						status);					data->error = -EIO;				}				/*				 * After an error, there may be data lingering				 * in the FIFO, so reset it - doing so				 * generates a block interrupt, hence setting				 * the scatter-gather pointer to NULL.				 */				sg_miter_stop(&host->sg_miter);				host->sg = NULL;				ctrl = mci_readl(host, CTRL);				ctrl |= SDMMC_CTRL_FIFO_RESET;				mci_writel(host, CTRL, ctrl);			}
if (status & SDMMC_INT_DTO) {					data->error = -ETIMEDOUT;				} else if (status & SDMMC_INT_DCRC) {					data->error = -EILSEQ;				} else if (status & SDMMC_INT_EBE &&					   host->dir_status ==							DW_MCI_SEND_STATUS) {					/*					 * No data CRC status was returned.					 * The number of bytes transferred will					 * be exaggerated in PIO mode.					 */					data->bytes_xfered = 0;					data->error = -ETIMEDOUT;				} else {					dev_err(host->dev,						"data FIFO error "						"(status=%08x)\n",						status);					data->error = -EIO;				}
status & SDMMC_INT_DTO
status
status
SDMMC_INT_DTO
SDMMC_INT_DTO
{					data->error = -ETIMEDOUT;				}
data->error = -ETIMEDOUT;
data->error = -ETIMEDOUT
data->error
data
data
error
-ETIMEDOUT
ETIMEDOUT
ETIMEDOUT
if (status & SDMMC_INT_DCRC) {					data->error = -EILSEQ;				} else if (status & SDMMC_INT_EBE &&					   host->dir_status ==							DW_MCI_SEND_STATUS) {					/*					 * No data CRC status was returned.					 * The number of bytes transferred will					 * be exaggerated in PIO mode.					 */					data->bytes_xfered = 0;					data->error = -ETIMEDOUT;				} else {					dev_err(host->dev,						"data FIFO error "						"(status=%08x)\n",						status);					data->error = -EIO;				}
status & SDMMC_INT_DCRC
status
status
SDMMC_INT_DCRC
SDMMC_INT_DCRC
{					data->error = -EILSEQ;				}
data->error = -EILSEQ;
data->error = -EILSEQ
data->error
data
data
error
-EILSEQ
EILSEQ
EILSEQ
if (status & SDMMC_INT_EBE &&					   host->dir_status ==							DW_MCI_SEND_STATUS) {					/*					 * No data CRC status was returned.					 * The number of bytes transferred will					 * be exaggerated in PIO mode.					 */					data->bytes_xfered = 0;					data->error = -ETIMEDOUT;				} else {					dev_err(host->dev,						"data FIFO error "						"(status=%08x)\n",						status);					data->error = -EIO;				}
status & SDMMC_INT_EBE &&					   host->dir_status ==							DW_MCI_SEND_STATUS
status & SDMMC_INT_EBE
status
status
SDMMC_INT_EBE
SDMMC_INT_EBE
host->dir_status ==							DW_MCI_SEND_STATUS
host->dir_status
host
host
dir_status
DW_MCI_SEND_STATUS
DW_MCI_SEND_STATUS
{					/*					 * No data CRC status was returned.					 * The number of bytes transferred will					 * be exaggerated in PIO mode.					 */					data->bytes_xfered = 0;					data->error = -ETIMEDOUT;				}
data->bytes_xfered = 0;
data->bytes_xfered = 0
data->bytes_xfered
data
data
bytes_xfered
0
data->error = -ETIMEDOUT;
data->error = -ETIMEDOUT
data->error
data
data
error
-ETIMEDOUT
ETIMEDOUT
ETIMEDOUT
{					dev_err(host->dev,						"data FIFO error "						"(status=%08x)\n",						status);					data->error = -EIO;				}
dev_err(host->dev,						"data FIFO error "						"(status=%08x)\n",						status);
dev_err(host->dev,						"data FIFO error "						"(status=%08x)\n",						status)
dev_err
dev_err
host->dev
host
host
dev
"data FIFO error "						"(status=%08x)\n"
status
status
data->error = -EIO;
data->error = -EIO
data->error
data
data
error
-EIO
EIO
EIO
sg_miter_stop(&host->sg_miter);
sg_miter_stop(&host->sg_miter)
sg_miter_stop
sg_miter_stop
&host->sg_miter
host->sg_miter
host
host
sg_miter
host->sg = NULL;
host->sg = NULL
host->sg
host
host
sg
NULL
NULL
ctrl = mci_readl(host, CTRL);
ctrl = mci_readl(host, CTRL)
ctrl
ctrl
mci_readl(host, CTRL)
mci_readl
mci_readl
host
host
CTRL
CTRL
ctrl |= SDMMC_CTRL_FIFO_RESET;
ctrl |= SDMMC_CTRL_FIFO_RESET
ctrl
ctrl
SDMMC_CTRL_FIFO_RESET
SDMMC_CTRL_FIFO_RESET
mci_writel(host, CTRL, ctrl);
mci_writel(host, CTRL, ctrl)
mci_writel
mci_writel
host
host
CTRL
CTRL
ctrl
ctrl
{				data->bytes_xfered = data->blocks * data->blksz;				data->error = 0;			}
data->bytes_xfered = data->blocks * data->blksz;
data->bytes_xfered = data->blocks * data->blksz
data->bytes_xfered
data
data
bytes_xfered
data->blocks * data->blksz
data->blocks
data
data
blocks
data->blksz
data
data
blksz
data->error = 0;
data->error = 0
data->error
data
data
error
0
if (!data->stop) {				dw_mci_request_end(host, host->mrq);				goto unlock;			}
!data->stop
data->stop
data
data
stop
{				dw_mci_request_end(host, host->mrq);				goto unlock;			}
dw_mci_request_end(host, host->mrq);
dw_mci_request_end(host, host->mrq)
dw_mci_request_end
dw_mci_request_end
host
host
host->mrq
host
host
mrq
goto unlock;
unlock
if (host->mrq->sbc && !data->error) {				data->stop->error = 0;				dw_mci_request_end(host, host->mrq);				goto unlock;			}
host->mrq->sbc && !data->error
host->mrq->sbc
host->mrq
host
host
mrq
sbc
!data->error
data->error
data
data
error
{				data->stop->error = 0;				dw_mci_request_end(host, host->mrq);				goto unlock;			}
data->stop->error = 0;
data->stop->error = 0
data->stop->error
data->stop
data
data
stop
error
0
dw_mci_request_end(host, host->mrq);
dw_mci_request_end(host, host->mrq)
dw_mci_request_end
dw_mci_request_end
host
host
host->mrq
host
host
mrq
goto unlock;
unlock
prev_state = state = STATE_SENDING_STOP;
prev_state = state = STATE_SENDING_STOP
prev_state
prev_state
state = STATE_SENDING_STOP
state
state
STATE_SENDING_STOP
STATE_SENDING_STOP
if (!data->error)				send_stop_cmd(host, data);
!data->error
data->error
data
data
error
send_stop_cmd(host, data);
send_stop_cmd(host, data)
send_stop_cmd
send_stop_cmd
host
host
data
data
case STATE_SENDING_STOP:
STATE_SENDING_STOP
STATE_SENDING_STOP
if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;
!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events)
test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events)
test_and_clear_bit
test_and_clear_bit
EVENT_CMD_COMPLETE
EVENT_CMD_COMPLETE
&host->pending_events
host->pending_events
host
host
pending_events
break;
host->cmd = NULL;
host->cmd = NULL
host->cmd
host
host
cmd
NULL
NULL
dw_mci_command_complete(host, host->mrq->stop);
dw_mci_command_complete(host, host->mrq->stop)
dw_mci_command_complete
dw_mci_command_complete
host
host
host->mrq->stop
host->mrq
host
host
mrq
stop
dw_mci_request_end(host, host->mrq);
dw_mci_request_end(host, host->mrq)
dw_mci_request_end
dw_mci_request_end
host
host
host->mrq
host
host
mrq
goto unlock;
unlock
case STATE_DATA_ERROR:
STATE_DATA_ERROR
STATE_DATA_ERROR
if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events))				break;
!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events)
test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events)
test_and_clear_bit
test_and_clear_bit
EVENT_XFER_COMPLETE
EVENT_XFER_COMPLETE
&host->pending_events
host->pending_events
host
host
pending_events
break;
state = STATE_DATA_BUSY;
state = STATE_DATA_BUSY
state
state
STATE_DATA_BUSY
STATE_DATA_BUSY
break;
state != prev_state
state
state
prev_state
prev_state
host->state = state;
host->state = state
host->state
host
host
state
state
state
unlock:	spin_unlock(&host->lock);
unlock
spin_unlock(&host->lock);
spin_unlock(&host->lock)
spin_unlock
spin_unlock
&host->lock
host->lock
host
host
lock
-----joern-----
(163,184,0)
(123,121,0)
(345,248,0)
(390,266,0)
(86,232,0)
(184,214,0)
(238,24,0)
(63,33,0)
(340,275,0)
(177,5,0)
(156,262,0)
(173,222,0)
(296,391,0)
(160,391,0)
(259,33,0)
(256,190,0)
(145,248,0)
(19,49,0)
(362,394,0)
(381,190,0)
(252,198,0)
(203,11,0)
(239,156,0)
(388,204,0)
(197,156,0)
(149,78,0)
(383,378,0)
(45,207,0)
(318,292,0)
(15,316,0)
(128,31,0)
(306,45,0)
(42,262,0)
(183,138,0)
(237,213,0)
(361,79,0)
(243,293,0)
(171,72,0)
(392,173,0)
(212,322,0)
(160,320,0)
(24,393,0)
(278,333,0)
(154,184,0)
(159,110,0)
(312,198,0)
(125,217,0)
(110,257,0)
(263,357,0)
(344,235,0)
(244,138,0)
(356,316,0)
(13,69,0)
(5,316,0)
(366,50,0)
(165,107,0)
(62,316,0)
(30,248,0)
(250,51,0)
(327,387,0)
(137,316,0)
(17,355,0)
(204,388,0)
(134,320,0)
(249,51,0)
(209,80,0)
(274,168,0)
(119,78,0)
(142,69,0)
(21,316,0)
(387,363,0)
(290,214,0)
(16,186,0)
(77,55,0)
(83,165,0)
(185,304,0)
(352,24,0)
(90,307,0)
(35,248,0)
(285,22,0)
(333,65,0)
(25,222,0)
(118,124,0)
(328,222,0)
(115,169,0)
(116,31,0)
(378,383,0)
(297,145,0)
(80,299,0)
(47,257,0)
(23,316,0)
(187,155,0)
(309,80,0)
(41,232,0)
(115,373,0)
(391,299,0)
(113,316,0)
(238,373,0)
(302,69,0)
(207,85,0)
(81,144,0)
(241,26,0)
(53,132,0)
(80,372,0)
(186,195,0)
(333,270,0)
(145,69,0)
(261,69,0)
(129,352,0)
(279,369,0)
(144,81,0)
(292,93,0)
(208,26,0)
(369,2,0)
(115,185,0)
(392,12,0)
(360,69,0)
(82,69,0)
(49,19,0)
(262,156,0)
(192,375,0)
(160,270,0)
(242,306,0)
(271,72,0)
(273,276,0)
(136,246,0)
(246,66,0)
(152,222,0)
(174,20,0)
(38,316,0)
(60,316,0)
(289,316,0)
(170,247,0)
(164,237,0)
(372,320,0)
(135,316,0)
(99,213,0)
(147,316,0)
(334,339,0)
(313,387,0)
(310,361,0)
(69,222,0)
(13,11,0)
(41,49,0)
(371,168,0)
(121,257,0)
(324,6,0)
(333,391,0)
(140,261,0)
(101,367,0)
(80,5,0)
(10,308,0)
(357,368,0)
(388,69,0)
(304,185,0)
(355,185,0)
(311,293,0)
(374,145,0)
(261,248,0)
(95,167,0)
(365,12,0)
(231,55,0)
(262,42,0)
(186,293,0)
(126,81,0)
(144,104,0)
(389,222,0)
(345,69,0)
(333,326,0)
(314,38,0)
(227,142,0)
(34,222,0)
(200,183,0)
(228,59,0)
(84,92,0)
(248,222,0)
(364,316,0)
(45,306,0)
(108,86,0)
(333,320,0)
(295,391,0)
(293,186,0)
(232,41,0)
(373,179,0)
(238,248,0)
(167,316,0)
(273,152,0)
(361,104,0)
(66,316,0)
(91,276,0)
(384,327,0)
(37,61,0)
(210,33,0)
(67,235,0)
(214,290,0)
(132,69,0)
(221,207,0)
(227,376,0)
(102,115,0)
(0,118,0)
(189,160,0)
(106,115,0)
(31,73,0)
(81,275,0)
(70,222,0)
(281,350,0)
(104,361,0)
(306,69,0)
(169,368,0)
(272,333,0)
(289,55,0)
(7,79,0)
(20,201,0)
(226,175,0)
(307,124,0)
(165,69,0)
(138,183,0)
(122,345,0)
(370,299,0)
(190,69,0)
(235,179,0)
(175,69,0)
(29,65,0)
(254,142,0)
(385,316,0)
(48,373,0)
(109,372,0)
(363,376,0)
(130,306,0)
(124,118,0)
(138,316,0)
(117,263,0)
(294,290,0)
(342,279,0)
(18,388,0)
(366,53,0)
(20,248,0)
(211,316,0)
(277,270,0)
(74,201,0)
(168,326,0)
(286,261,0)
(162,281,0)
(50,366,0)
(111,290,0)
(188,222,0)
(335,302,0)
(86,69,0)
(160,326,0)
(336,316,0)
(133,316,0)
(237,69,0)
(85,207,0)
(217,248,0)
(59,275,0)
(73,31,0)
(305,74,0)
(266,73,0)
(323,121,0)
(80,320,0)
(11,13,0)
(80,250,0)
(219,42,0)
(173,392,0)
(373,48,0)
(182,316,0)
(265,20,0)
(315,78,0)
(168,69,0)
(49,41,0)
(350,69,0)
(269,222,0)
(290,111,0)
(92,271,0)
(104,144,0)
(284,12,0)
(46,363,0)
(107,375,0)
(58,276,0)
(59,69,0)
(333,250,0)
(350,281,0)
(380,222,0)
(193,189,0)
(120,308,0)
(383,69,0)
(132,53,0)
(73,357,0)
(343,383,0)
(22,69,0)
(238,185,0)
(40,356,0)
(381,69,0)
(61,51,0)
(19,367,0)
(31,248,0)
(329,316,0)
(191,316,0)
(39,53,0)
(320,372,0)
(213,99,0)
(235,66,0)
(166,279,0)
(151,237,0)
(387,327,0)
(229,326,0)
(43,196,0)
(36,175,0)
(288,79,0)
(266,248,0)
(33,63,0)
(115,106,0)
(276,69,0)
(289,69,0)
(6,175,0)
(94,59,0)
(61,69,0)
(235,22,0)
(75,81,0)
(236,316,0)
(302,348,0)
(13,348,0)
(190,381,0)
(80,391,0)
(24,352,0)
(32,42,0)
(41,275,0)
(178,227,0)
(89,48,0)
(150,190,0)
(131,82,0)
(44,2,0)
(275,316,0)
(347,99,0)
(195,186,0)
(326,168,0)
(357,73,0)
(238,50,0)
(205,10,0)
(115,201,0)
(321,238,0)
(157,98,0)
(127,38,0)
(213,237,0)
(382,160,0)
(175,6,0)
(156,69,0)
(283,69,0)
(78,69,0)
(217,373,0)
(356,69,0)
(314,69,0)
(167,204,0)
(215,270,0)
(348,13,0)
(80,333,0)
(348,302,0)
(172,316,0)
(367,275,0)
(153,165,0)
(183,200,0)
(114,250,0)
(307,69,0)
(69,292,0)
(50,238,0)
(327,248,0)
(33,248,0)
(201,74,0)
(142,227,0)
(54,10,0)
(293,69,0)
(292,69,0)
(339,248,0)
(155,195,0)
(270,277,0)
(375,316,0)
(271,69,0)
(121,69,0)
(78,149,0)
(59,38,0)
(198,66,0)
(13,2,0)
(330,307,0)
(386,250,0)
(56,338,0)
(308,257,0)
(79,69,0)
(291,316,0)
(55,289,0)
(80,270,0)
(143,13,0)
(367,19,0)
(276,273,0)
(35,169,0)
(350,316,0)
(337,356,0)
(378,257,0)
(82,182,0)
(202,232,0)
(253,355,0)
(194,115,0)
(332,121,0)
(8,76,0)
(206,376,0)
(354,182,0)
(149,56,0)
(199,110,0)
(115,24,0)
(255,99,0)
(68,367,0)
(339,196,0)
(394,66,0)
(247,24,0)
(275,59,0)
(218,378,0)
(4,277,0)
(28,383,0)
(349,292,0)
(369,279,0)
(92,69,0)
(227,69,0)
(185,325,0)
(281,26,0)
(238,201,0)
(204,167,0)
(98,316,0)
(146,316,0)
(317,266,0)
(160,222,0)
(180,66,0)
(333,5,0)
(152,273,0)
(268,314,0)
(251,263,0)
(214,184,0)
(73,266,0)
(240,246,0)
(303,316,0)
(216,51,0)
(258,222,0)
(282,56,0)
(55,69,0)
(42,219,0)
(338,56,0)
(161,169,0)
(232,86,0)
(301,155,0)
(247,248,0)
(64,142,0)
(79,361,0)
(356,275,0)
(200,69,0)
(124,307,0)
(292,318,0)
(351,132,0)
(298,30,0)
(158,271,0)
(96,248,0)
(148,327,0)
(220,82,0)
(110,378,0)
(358,200,0)
(14,41,0)
(26,69,0)
(271,92,0)
(115,248,0)
(264,302,0)
(299,316,0)
(346,388,0)
(176,35,0)
(224,394,0)
(300,381,0)
(353,339,0)
(12,392,0)
(88,35,0)
(299,391,0)
(112,86,0)
(234,322,0)
(377,11,0)
(230,92,0)
(22,235,0)
(10,69,0)
(360,98,0)
(201,181,0)
(379,132,0)
(372,316,0)
(359,238,0)
(107,165,0)
(155,66,0)
(238,169,0)
(196,181,0)
(6,324,0)
(80,277,0)
(12,69,0)
(80,326,0)
(198,69,0)
(225,289,0)
(189,69,0)
(248,261,0)
(26,281,0)
(355,248,0)
(99,255,0)
(11,69,0)
(280,320,0)
(160,5,0)
(184,69,0)
(57,189,0)
(260,314,0)
(207,45,0)
(56,149,0)
(71,22,0)
(263,248,0)
(375,107,0)
(3,350,0)
(245,247,0)
(1,369,0)
(27,217,0)
(195,155,0)
(100,304,0)
(139,270,0)
(160,250,0)
(105,360,0)
(287,345,0)
(324,257,0)
(121,110,0)
(341,348,0)
(326,222,0)
(319,5,0)
(322,66,0)
(277,316,0)
(381,76,0)
(9,30,0)
(267,200,0)
(223,360,0)
(66,198,0)
(53,366,0)
(177,319,1)
(243,155,1)
(227,142,1)
(36,201,1)
(327,148,1)
(209,52,1)
(378,383,1)
(394,66,1)
(224,322,1)
(100,355,1)
(36,373,1)
(82,69,1)
(92,69,1)
(22,69,1)
(299,391,1)
(260,268,1)
(164,151,1)
(223,105,1)
(66,198,1)
(282,331,1)
(217,248,1)
(273,276,1)
(333,391,1)
(317,390,1)
(241,208,1)
(89,217,1)
(77,231,1)
(130,242,1)
(383,28,1)
(349,283,1)
(266,317,1)
(197,32,1)
(190,150,1)
(187,394,1)
(357,73,1)
(262,156,1)
(363,46,1)
(80,391,1)
(80,309,1)
(374,297,1)
(371,274,1)
(175,226,1)
(209,331,1)
(67,344,1)
(305,20,1)
(289,69,1)
(176,88,1)
(159,378,1)
(372,320,1)
(92,84,1)
(142,69,1)
(118,124,1)
(225,350,1)
(168,371,1)
(81,75,1)
(392,12,1)
(79,69,1)
(183,200,1)
(86,108,1)
(149,78,1)
(296,295,1)
(194,299,1)
(152,273,1)
(249,250,1)
(290,214,1)
(96,326,1)
(292,318,1)
(97,85,1)
(281,26,1)
(115,102,1)
(134,109,1)
(265,174,1)
(261,140,1)
(59,38,1)
(186,293,1)
(263,248,1)
(18,346,1)
(354,82,1)
(212,234,1)
(315,119,1)
(207,45,1)
(351,63,1)
(339,353,1)
(238,359,1)
(271,92,1)
(362,224,1)
(377,203,1)
(235,67,1)
(167,204,1)
(108,112,1)
(155,66,1)
(332,323,1)
(131,220,1)
(226,36,1)
(293,69,1)
(210,259,1)
(237,164,1)
(238,24,1)
(60,331,1)
(252,312,1)
(295,370,1)
(288,49,1)
(56,149,1)
(78,69,1)
(189,69,1)
(110,378,1)
(26,69,1)
(382,189,1)
(276,69,1)
(282,106,1)
(180,138,1)
(381,190,1)
(144,104,1)
(49,41,1)
(246,66,1)
(321,53,1)
(287,122,1)
(350,69,1)
(246,136,1)
(383,69,1)
(157,360,1)
(333,272,1)
(120,10,1)
(88,357,1)
(20,248,1)
(217,125,1)
(390,31,1)
(82,131,1)
(388,69,1)
(322,212,1)
(333,270,1)
(101,68,1)
(13,11,1)
(103,338,1)
(248,261,1)
(311,243,1)
(145,374,1)
(356,337,1)
(237,69,1)
(137,289,1)
(0,372,1)
(107,165,1)
(259,169,1)
(4,375,1)
(343,218,1)
(247,245,1)
(69,292,1)
(294,118,1)
(63,33,1)
(208,3,1)
(160,5,1)
(99,213,1)
(13,348,1)
(320,280,1)
(117,246,1)
(300,63,1)
(270,139,1)
(162,26,1)
(266,248,1)
(394,362,1)
(334,195,1)
(234,246,1)
(361,79,1)
(209,172,1)
(91,58,1)
(6,175,1)
(22,71,1)
(322,66,1)
(41,232,1)
(345,69,1)
(98,157,1)
(333,320,1)
(132,69,1)
(124,307,1)
(166,1,1)
(150,256,1)
(20,265,1)
(7,288,1)
(313,327,1)
(80,299,1)
(58,44,1)
(1,49,1)
(272,278,1)
(254,178,1)
(301,187,1)
(338,56,1)
(345,248,1)
(193,80,1)
(160,270,1)
(90,0,1)
(292,349,1)
(54,205,1)
(73,31,1)
(342,166,1)
(370,366,1)
(214,184,1)
(331,333,1)
(327,248,1)
(384,366,1)
(73,266,1)
(105,338,1)
(9,61,1)
(209,87,1)
(115,248,1)
(256,300,1)
(31,248,1)
(48,89,1)
(274,229,1)
(168,69,1)
(151,347,1)
(111,290,1)
(209,97,1)
(367,101,1)
(109,144,1)
(114,386,1)
(80,5,1)
(106,115,1)
(143,369,1)
(122,106,1)
(367,275,1)
(309,209,1)
(219,42,1)
(115,169,1)
(46,387,1)
(102,194,1)
(204,388,1)
(242,221,1)
(235,22,1)
(12,365,1)
(19,367,1)
(115,201,1)
(388,18,1)
(292,93,1)
(263,251,1)
(302,264,1)
(345,287,1)
(163,294,1)
(145,69,1)
(379,351,1)
(71,285,1)
(53,132,1)
(12,69,1)
(356,275,1)
(41,275,1)
(286,96,1)
(58,171,1)
(160,391,1)
(3,98,1)
(37,118,1)
(348,341,1)
(36,24,1)
(16,293,1)
(231,225,1)
(358,244,1)
(110,199,1)
(148,384,1)
(44,13,1)
(58,160,1)
(337,40,1)
(75,126,1)
(280,134,1)
(203,143,1)
(202,86,1)
(55,77,1)
(323,110,1)
(341,302,1)
(53,39,1)
(185,304,1)
(308,120,1)
(128,116,1)
(277,270,1)
(136,240,1)
(232,86,1)
(160,250,1)
(144,81,1)
(68,41,1)
(238,201,1)
(121,110,1)
(201,74,1)
(178,363,1)
(141,152,1)
(307,69,1)
(171,271,1)
(255,99,1)
(335,11,1)
(43,339,1)
(38,127,1)
(31,128,1)
(240,66,1)
(10,54,1)
(50,238,1)
(42,262,1)
(175,69,1)
(381,69,1)
(61,37,1)
(59,69,1)
(366,50,1)
(235,66,1)
(282,345,1)
(205,324,1)
(192,111,1)
(5,177,1)
(209,249,1)
(11,69,1)
(220,255,1)
(189,57,1)
(95,38,1)
(271,69,1)
(52,255,1)
(339,248,1)
(360,69,1)
(238,373,1)
(87,111,1)
(200,69,1)
(326,168,1)
(27,235,1)
(276,91,1)
(353,334,1)
(268,275,1)
(74,305,1)
(247,248,1)
(307,330,1)
(333,250,1)
(347,277,1)
(156,239,1)
(80,250,1)
(360,223,1)
(251,117,1)
(85,207,1)
(112,14,1)
(230,158,1)
(319,85,1)
(58,8,1)
(17,253,1)
(279,342,1)
(170,322,1)
(359,321,1)
(239,197,1)
(366,53,1)
(173,392,1)
(84,230,1)
(80,333,1)
(160,320,1)
(26,241,1)
(160,326,1)
(115,24,1)
(132,379,1)
(154,163,1)
(195,155,1)
(340,219,1)
(172,5,1)
(221,331,1)
(138,183,1)
(209,103,1)
(324,6,1)
(306,130,1)
(35,248,1)
(386,145,1)
(64,254,1)
(346,95,1)
(129,247,1)
(49,19,1)
(229,173,1)
(32,331,1)
(361,310,1)
(184,69,1)
(119,282,1)
(104,361,1)
(190,69,1)
(80,277,1)
(125,27,1)
(10,69,1)
(306,69,1)
(253,394,1)
(182,354,1)
(298,9,1)
(196,43,1)
(238,248,1)
(289,55,1)
(126,104,1)
(80,270,1)
(348,302,1)
(80,372,1)
(387,327,1)
(238,185,1)
(355,248,1)
(238,169,1)
(80,320,1)
(373,48,1)
(11,377,1)
(58,137,1)
(297,30,1)
(57,193,1)
(355,17,1)
(161,35,1)
(86,69,1)
(365,284,1)
(59,94,1)
(30,298,1)
(155,301,1)
(8,381,1)
(232,202,1)
(245,170,1)
(140,286,1)
(186,16,1)
(333,326,1)
(281,162,1)
(121,69,1)
(261,69,1)
(80,326,1)
(213,237,1)
(78,315,1)
(347,331,1)
(165,69,1)
(285,195,1)
(153,192,1)
(94,228,1)
(83,153,1)
(115,185,1)
(13,69,1)
(209,233,1)
(228,340,1)
(123,332,1)
(139,215,1)
(127,314,1)
(142,64,1)
(314,69,1)
(275,59,1)
(61,69,1)
(115,373,1)
(30,248,1)
(169,161,1)
(350,281,1)
(206,227,1)
(352,129,1)
(387,313,1)
(310,79,1)
(198,252,1)
(199,159,1)
(356,69,1)
(33,248,1)
(198,69,1)
(121,123,1)
(215,4,1)
(45,306,1)
(81,275,1)
(278,248,1)
(184,154,1)
(218,308,1)
(233,219,1)
(333,5,1)
(302,69,1)
(293,311,1)
(35,176,1)
(24,352,1)
(0,331,1)
(259,121,1)
(174,196,1)
(145,248,1)
(304,100,1)
(284,69,1)
(156,69,1)
(28,343,1)
(33,210,1)
(391,296,1)
(278,80,1)
(116,263,1)
(312,180,1)
(58,206,1)
(195,186,1)
(39,132,1)
(200,267,1)
(314,260,1)
(375,107,1)
(55,69,1)
(267,358,1)
(158,144,1)
(386,30,1)
(14,356,1)
(250,114,1)
(165,83,1)
(40,167,1)
(369,279,1)
(79,7,1)
(227,69,1)
(330,90,1)
(344,22,1)
(264,335,1)
(36,185,1)
(244,182,1)
(160,382,1)
(209,60,1)
(4,111,2)
(378,383,2)
(195,186,2)
(355,394,2)
(282,331,2)
(142,69,2)
(172,85,2)
(313,366,2)
(296,366,2)
(287,106,2)
(73,266,2)
(24,322,2)
(243,155,2)
(225,338,2)
(207,331,2)
(279,49,2)
(327,248,2)
(333,5,2)
(41,219,2)
(292,93,2)
(49,41,2)
(255,331,2)
(322,66,2)
(262,331,2)
(184,118,2)
(38,219,2)
(164,331,2)
(370,366,2)
(36,246,2)
(238,201,2)
(190,69,2)
(382,80,2)
(214,118,2)
(241,338,2)
(66,255,2)
(119,331,2)
(120,246,2)
(346,219,2)
(367,41,2)
(338,331,2)
(167,219,2)
(115,185,2)
(152,273,2)
(145,30,2)
(217,195,2)
(104,361,2)
(315,366,2)
(130,331,2)
(10,246,2)
(20,195,2)
(333,320,2)
(55,69,2)
(42,331,2)
(309,111,2)
(375,111,2)
(64,366,2)
(12,69,2)
(79,49,2)
(124,331,2)
(278,80,2)
(66,198,2)
(61,69,2)
(374,30,2)
(101,41,2)
(49,19,2)
(80,219,2)
(259,255,2)
(248,261,2)
(90,144,2)
(124,307,2)
(264,49,2)
(341,49,2)
(231,338,2)
(354,255,2)
(272,80,2)
(175,246,2)
(63,255,2)
(235,66,2)
(136,255,2)
(352,322,2)
(115,373,2)
(378,246,2)
(394,322,2)
(57,80,2)
(247,322,2)
(102,366,2)
(106,366,2)
(119,366,2)
(160,270,2)
(110,246,2)
(118,144,2)
(11,49,2)
(157,338,2)
(394,66,2)
(144,81,2)
(361,79,2)
(121,110,2)
(7,49,2)
(52,255,2)
(28,246,2)
(160,250,2)
(199,246,2)
(338,56,2)
(219,331,2)
(159,246,2)
(392,12,2)
(14,219,2)
(343,246,2)
(282,366,2)
(131,255,2)
(56,366,2)
(19,41,2)
(366,50,2)
(251,246,2)
(110,378,2)
(160,80,2)
(309,338,2)
(184,69,2)
(345,69,2)
(156,69,2)
(237,331,2)
(314,219,2)
(24,352,2)
(320,144,2)
(220,255,2)
(50,238,2)
(176,246,2)
(98,338,2)
(247,248,2)
(289,55,2)
(33,248,2)
(170,322,2)
(56,331,2)
(197,331,2)
(297,30,2)
(213,237,2)
(80,326,2)
(200,255,2)
(144,49,2)
(182,255,2)
(61,118,2)
(107,165,2)
(78,331,2)
(357,246,2)
(73,246,2)
(185,394,2)
(280,144,2)
(160,326,2)
(151,111,2)
(275,59,2)
(150,63,2)
(387,327,2)
(327,366,2)
(339,195,2)
(190,63,2)
(106,115,2)
(55,338,2)
(41,275,2)
(350,281,2)
(13,348,2)
(271,144,2)
(10,69,2)
(37,118,2)
(82,69,2)
(252,255,2)
(299,366,2)
(92,69,2)
(310,49,2)
(285,195,2)
(155,66,2)
(238,185,2)
(209,331,2)
(117,246,2)
(363,366,2)
(45,331,2)
(115,201,2)
(6,246,2)
(307,69,2)
(230,144,2)
(317,246,2)
(330,144,2)
(42,262,2)
(161,246,2)
(240,255,2)
(381,69,2)
(162,338,2)
(333,270,2)
(134,144,2)
(262,156,2)
(153,111,2)
(302,69,2)
(201,195,2)
(80,270,2)
(53,132,2)
(80,333,2)
(175,69,2)
(111,290,2)
(75,104,2)
(204,219,2)
(210,255,2)
(121,246,2)
(123,246,2)
(306,331,2)
(366,53,2)
(187,394,2)
(165,111,2)
(311,155,2)
(118,331,2)
(0,144,2)
(366,63,2)
(209,255,2)
(193,80,2)
(86,69,2)
(195,394,2)
(138,255,2)
(160,5,2)
(319,85,2)
(277,111,2)
(205,246,2)
(256,63,2)
(115,169,2)
(333,80,2)
(351,63,2)
(151,331,2)
(53,63,2)
(143,49,2)
(273,276,2)
(304,394,2)
(362,322,2)
(129,322,2)
(186,155,2)
(270,111,2)
(332,246,2)
(112,219,2)
(128,246,2)
(59,219,2)
(309,118,2)
(145,69,2)
(213,111,2)
(322,246,2)
(345,248,2)
(227,142,2)
(333,250,2)
(79,69,2)
(78,69,2)
(381,63,2)
(198,69,2)
(213,331,2)
(99,213,2)
(334,195,2)
(358,255,2)
(27,195,2)
(149,331,2)
(127,219,2)
(347,111,2)
(309,219,2)
(254,366,2)
(17,394,2)
(8,63,2)
(219,42,2)
(266,246,2)
(80,5,2)
(165,69,2)
(103,338,2)
(71,195,2)
(74,195,2)
(185,304,2)
(35,246,2)
(255,99,2)
(224,322,2)
(18,219,2)
(314,69,2)
(360,69,2)
(206,366,2)
(348,49,2)
(324,6,2)
(384,366,2)
(39,63,2)
(54,246,2)
(309,255,2)
(338,366,2)
(238,24,2)
(168,69,2)
(253,394,2)
(226,246,2)
(160,391,2)
(356,219,2)
(80,250,2)
(292,318,2)
(373,48,2)
(192,111,2)
(40,219,2)
(261,69,2)
(200,69,2)
(35,248,2)
(44,49,2)
(195,155,2)
(232,219,2)
(166,49,2)
(290,214,2)
(209,338,2)
(163,118,2)
(238,373,2)
(323,246,2)
(45,306,2)
(321,53,2)
(372,144,2)
(31,246,2)
(99,331,2)
(83,111,2)
(22,69,2)
(32,331,2)
(80,111,2)
(30,248,2)
(174,195,2)
(353,195,2)
(80,391,2)
(100,394,2)
(142,366,2)
(275,219,2)
(268,219,2)
(22,195,2)
(137,338,2)
(164,111,2)
(0,331,2)
(263,248,2)
(107,111,2)
(345,106,2)
(237,111,2)
(122,106,2)
(115,366,2)
(342,49,2)
(80,372,2)
(149,366,2)
(383,69,2)
(238,53,2)
(293,69,2)
(244,255,2)
(41,232,2)
(375,107,2)
(372,320,2)
(266,248,2)
(333,391,2)
(263,246,2)
(265,195,2)
(97,85,2)
(302,49,2)
(196,195,2)
(209,219,2)
(373,195,2)
(331,80,2)
(391,366,2)
(3,338,2)
(356,69,2)
(246,255,2)
(307,144,2)
(267,255,2)
(13,11,2)
(227,69,2)
(43,195,2)
(82,255,2)
(78,366,2)
(80,331,2)
(95,219,2)
(239,331,2)
(326,168,2)
(289,69,2)
(386,118,2)
(77,338,2)
(383,246,2)
(160,320,2)
(16,155,2)
(69,292,2)
(215,111,2)
(67,195,2)
(56,149,2)
(50,53,2)
(340,219,2)
(138,183,2)
(356,275,2)
(209,111,2)
(26,338,2)
(81,104,2)
(337,219,2)
(84,144,2)
(87,111,2)
(81,275,2)
(271,92,2)
(357,73,2)
(237,69,2)
(92,144,2)
(20,248,2)
(121,69,2)
(173,392,2)
(85,331,2)
(218,246,2)
(11,69,2)
(308,246,2)
(111,118,2)
(207,45,2)
(13,69,2)
(388,219,2)
(183,255,2)
(30,118,2)
(105,338,2)
(33,255,2)
(324,246,2)
(144,104,2)
(379,63,2)
(63,33,2)
(250,118,2)
(80,320,2)
(80,277,2)
(118,124,2)
(99,111,2)
(155,394,2)
(234,246,2)
(60,331,2)
(180,255,2)
(115,24,2)
(369,49,2)
(94,219,2)
(68,41,2)
(381,190,2)
(48,195,2)
(189,69,2)
(390,246,2)
(26,69,2)
(242,331,2)
(306,69,2)
(355,248,2)
(178,366,2)
(249,118,2)
(59,69,2)
(46,366,2)
(294,118,2)
(350,338,2)
(223,338,2)
(309,331,2)
(59,38,2)
(298,118,2)
(80,255,2)
(255,111,2)
(245,322,2)
(388,69,2)
(367,275,2)
(369,279,2)
(289,338,2)
(125,195,2)
(114,118,2)
(194,366,2)
(271,69,2)
(104,49,2)
(235,22,2)
(80,299,2)
(330,331,2)
(377,49,2)
(198,255,2)
(339,248,2)
(124,144,2)
(80,118,2)
(132,69,2)
(49,219,2)
(6,175,2)
(214,184,2)
(301,394,2)
(116,246,2)
(19,367,2)
(171,144,2)
(201,74,2)
(281,26,2)
(203,49,2)
(9,118,2)
(158,144,2)
(333,326,2)
(228,219,2)
(359,53,2)
(88,246,2)
(238,169,2)
(288,49,2)
(73,31,2)
(145,248,2)
(290,118,2)
(347,331,2)
(277,270,2)
(1,49,2)
(5,85,2)
(154,118,2)
(312,255,2)
(260,219,2)
(361,49,2)
(126,104,2)
(90,331,2)
(212,246,2)
(86,219,2)
(89,195,2)
(204,388,2)
(344,195,2)
(108,219,2)
(80,338,2)
(227,366,2)
(360,338,2)
(115,248,2)
(13,49,2)
(189,80,2)
(167,204,2)
(149,78,2)
(232,86,2)
(233,219,2)
(307,331,2)
(276,69,2)
(387,366,2)
(109,144,2)
(350,69,2)
(281,338,2)
(156,331,2)
(235,195,2)
(209,118,2)
(246,66,2)
(169,246,2)
(148,366,2)
(315,331,2)
(177,85,2)
(31,248,2)
(221,331,2)
(299,391,2)
(295,366,2)
(348,302,2)
(85,207,2)
(186,293,2)
(208,338,2)
(139,111,2)
(183,200,2)
(202,219,2)
(238,248,2)
(217,248,2)
(132,63,2)
(335,49,2)
(293,155,2)
(300,63,2)
(305,195,2)
-----------------------------------
(0,EVENT_DATA_ERROR)
(1,prev_state)
(2,)
(3,host)
(4,prev_state)
(5,state = STATE_DATA_BUSY)
(6,&host->sg_miter)
(7,mrq)
(8,goto unlock;)
(9,data)
(10,host->sg)
(11,host->cur_slot)
(12,host->lock)
(13,__dw_mci_start_request(host, host->cur_slot,\n\\n\\t\\t\\t\\t\\t\\t       host->mrq->cmd)
(14,cmd)
(15,if (!test_and_clear_bit(EVENT_CMD_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(16,DW_MCI_SEND_STATUS)
(17,error)
(18,completed_events)
(19,!cmd->error)
(20,data->error)
(21,if (!host->mrq->data || cmd->error)
(22,host->dev)
(23,if (test_and_clear_bit(EVENT_DATA_ERROR,\n\\n\\t\\t\\t\\t\\t       &host->pending_events)
(24,data->error = -ETIMEDOUT)
(25,data)
(26,host->mrq)
(27,data)
(28,CTRL)
(29,switch (state)
(30,data->stop)
(31,data->blocks)
(32,EVENT_CMD_COMPLETE)
(33,data->stop)
(34,ctrl)
(35,data->error)
(36,host)
(37,host)
(38,host->cmd = NULL)
(39,sbc)
(40,host)
(41,cmd == host->mrq->sbc)
(42,test_and_clear_bit(EVENT_CMD_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(43,0)
(44,goto unlock;)
(45,&host->pending_events)
(46,0)
(47,if (status & SDMMC_INT_DTO)
(48,-EIO)
(49,cmd == host->mrq->sbc && !cmd->error)
(50,!data->error)
(51,)
(52,break;)
(53,host->mrq->sbc)
(54,sg)
(55,host->mrq)
(56,test_and_clear_bit(EVENT_CMD_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(57,state)
(58,host)
(59,host->cmd)
(60,break;)
(61,dw_mci_stop_dma(host)
(62,case STATE_SENDING_DATA:)
(63,!data->stop)
(64,mrq)
(65,)
(66,status = host->data_status)
(67,status)
(68,cmd)
(69,*host = (struct dw_mci *)
(70,host)
(71,dev)
(72,)
(73,data->blocks * data->blksz)
(74,-ETIMEDOUT)
(75,error)
(76,)
(77,mrq)
(78,host->pending_events)
(79,host->mrq)
(80,state != prev_state)
(81,cmd->error)
(82,host->data)
(83,completed_events)
(84,mrq)
(85,!test_and_clear_bit(EVENT_XFER_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(86,host->mrq)
(87,break;)
(88,data)
(89,EIO)
(90,host)
(91,lock)
(92,host->mrq)
(93,unsigned long priv)
(94,cmd)
(95,EVENT_CMD_COMPLETE)
(96,data)
(97,break;)
(98,host->cmd = NULL)
(99,test_and_clear_bit(EVENT_DATA_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(100,EILSEQ)
(101,error)
(102,error)
(103,break;)
(104,!host->mrq->data)
(105,host)
(106,!data->error)
(107,&host->completed_events)
(108,mrq)
(109,prev_state)
(110,ctrl |= SDMMC_CTRL_FIFO_RESET)
(111,!test_and_clear_bit(EVENT_XFER_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(112,host)
(113,case STATE_IDLE:)
(114,STATE_DATA_ERROR)
(115,data->error)
(116,data)
(117,data)
(118,test_and_clear_bit(EVENT_DATA_ERROR,\n\\n\\t\\t\\t\\t\\t       &host->pending_events)
(119,host)
(120,NULL)
(121,mci_writel(host, CTRL, ctrl)
(122,host)
(123,ctrl)
(124,&host->pending_events)
(125,error)
(126,cmd)
(127,NULL)
(128,blocks)
(129,ETIMEDOUT)
(130,pending_events)
(131,data)
(132,host->mrq)
(133,if (!test_and_clear_bit(EVENT_XFER_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(134,state)
(135,case STATE_DATA_BUSY:)
(136,DW_MCI_DATA_ERROR_FLAGS)
(137,goto unlock;)
(138,set_bit(EVENT_DATA_COMPLETE, &host->completed_events)
(139,STATE_DATA_BUSY)
(140,data)
(141,RET)
(142,host->mrq)
(143,host)
(144,!host->mrq->data || cmd->error)
(145,send_stop_cmd(host, data)
(146,if (!test_and_clear_bit(EVENT_CMD_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(147,if (status & DW_MCI_DATA_ERROR_FLAGS)
(148,stop)
(149,&host->pending_events)
(150,mrq)
(151,host)
(152,spin_unlock(&host->lock)
(153,host)
(154,pending_events)
(155,status & SDMMC_INT_EBE)
(156,host->pending_events)
(157,NULL)
(158,host)
(159,ctrl)
(160,host->state = state)
(161,0)
(162,stop)
(163,host)
(164,pending_events)
(165,host->completed_events)
(166,state)
(167,set_bit(EVENT_CMD_COMPLETE, &host->completed_events)
(168,host->state)
(169,data->error = 0)
(170,data)
(171,goto unlock;)
(172,break;)
(173,spin_lock(&host->lock)
(174,data)
(175,host->sg_miter)
(176,error)
(177,STATE_DATA_BUSY)
(178,host)
(179,)
(180,status)
(181,)
(182,host->data = NULL)
(183,&host->completed_events)
(184,host->pending_events)
(185,data->error = -EILSEQ)
(186,host->dir_status ==\n\\n\\t\\t\\t\\t\\t\\t\\tDW_MCI_SEND_STATUS)
(187,status)
(188,state)
(189,host->state)
(190,host->mrq)
(191,if (!test_and_clear_bit(EVENT_XFER_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(192,EVENT_XFER_COMPLETE)
(193,host)
(194,data)
(195,status & SDMMC_INT_EBE &&\n\\n\\t\\t\\t\\t\\t   host->dir_status ==\n\\n\\t\\t\\t\\t\\t\\t\\tDW_MCI_SEND_STATUS)
(196,data->bytes_xfered = 0)
(197,host)
(198,host->data_status)
(199,SDMMC_CTRL_FIFO_RESET)
(200,host->completed_events)
(201,data->error = -ETIMEDOUT)
(202,sbc)
(203,host)
(204,&host->completed_events)
(205,host)
(206,goto unlock;)
(207,test_and_clear_bit(EVENT_XFER_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(208,host)
(209,state)
(210,stop)
(211,if (host->mrq->sbc && !data->error)
(212,SDMMC_INT_DTO)
(213,&host->pending_events)
(214,&host->pending_events)
(215,state)
(216,if (data->stop)
(217,data->error)
(218,ctrl)
(219,!test_and_clear_bit(EVENT_CMD_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(220,host)
(221,EVENT_XFER_COMPLETE)
(222,)
(223,cmd)
(224,status)
(225,host)
(226,sg_miter)
(227,dw_mci_request_end(host, host->mrq)
(228,host)
(229,state)
(230,host)
(231,host)
(232,host->mrq->sbc)
(233,break;)
(234,status)
(235,dev_err(host->dev,\n\\n\\t\\t\\t\\t\\t\\t"data FIFO error "\n\\n\\t\\t\\t\\t\\t\\t"(status=%08x)
(236,if (!data->stop)
(237,host->pending_events)
(238,data->error)
(239,pending_events)
(240,status)
(241,mrq)
(242,host)
(243,host)
(244,EVENT_DATA_COMPLETE)
(245,error)
(246,status & DW_MCI_DATA_ERROR_FLAGS)
(247,data->error)
(248,data = host->data)
(249,break;)
(250,state = STATE_DATA_ERROR)
(251,bytes_xfered)
(252,data_status)
(253,data)
(254,host)
(255,!test_and_clear_bit(EVENT_DATA_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(256,host)
(257,)
(258,unlock:)
(259,data)
(260,cmd)
(261,host->data)
(262,&host->pending_events)
(263,data->bytes_xfered)
(264,mrq)
(265,error)
(266,data->blksz)
(267,completed_events)
(268,host)
(269,do)
(270,state = STATE_DATA_BUSY)
(271,dw_mci_request_end(host, host->mrq)
(272,state)
(273,&host->lock)
(274,host)
(275,cmd = host->cmd)
(276,host->lock)
(277,prev_state = state = STATE_DATA_BUSY)
(278,prev_state)
(279,state = STATE_SENDING_CMD)
(280,STATE_SENDING_DATA)
(281,host->mrq->stop)
(282,EVENT_CMD_COMPLETE)
(283,host)
(284,host)
(285,host)
(286,host)
(287,data)
(288,host)
(289,dw_mci_request_end(host, host->mrq)
(290,test_and_clear_bit(EVENT_XFER_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(291,case STATE_DATA_ERROR:)
(292,(struct dw_mci *)
(293,host->dir_status)
(294,EVENT_XFER_COMPLETE)
(295,state)
(296,STATE_SENDING_STOP)
(297,host)
(298,stop)
(299,prev_state = state = STATE_SENDING_STOP)
(300,host)
(301,SDMMC_INT_EBE)
(302,host->mrq)
(303,case STATE_SENDING_CMD:)
(304,-EILSEQ)
(305,ETIMEDOUT)
(306,host->pending_events)
(307,host->pending_events)
(308,host->sg = NULL)
(309,prev_state)
(310,data)
(311,dir_status)
(312,host)
(313,error)
(314,host->cmd)
(315,pending_events)
(316,)
(317,blksz)
(318,struct dw_mci *)
(319,state)
(320,state = STATE_SENDING_DATA)
(321,data)
(322,status & SDMMC_INT_DTO)
(323,host)
(324,sg_miter_stop(&host->sg_miter)
(325,)
(326,state = host->state)
(327,data->stop)
(328,prev_state)
(329,if (!test_and_clear_bit(EVENT_DATA_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(330,pending_events)
(331,state)
(332,CTRL)
(333,prev_state = state)
(334,data)
(335,host)
(336,if (!data->error)
(337,cmd)
(338,!test_and_clear_bit(EVENT_CMD_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(339,data->bytes_xfered)
(340,cmd)
(341,cmd)
(342,STATE_SENDING_CMD)
(343,host)
(344,"data FIFO error "\n\\n\\t\\t\\t\\t\\t\\t"(status=%08x)
(345,send_stop_cmd(host, data)
(346,host)
(347,EVENT_DATA_COMPLETE)
(348,host->mrq->cmd)
(349,priv)
(350,dw_mci_command_complete(host, host->mrq->stop)
(351,host)
(352,-ETIMEDOUT)
(353,bytes_xfered)
(354,NULL)
(355,data->error)
(356,dw_mci_command_complete(host, cmd)
(357,data->bytes_xfered = data->blocks * data->blksz)
(358,host)
(359,error)
(360,host->cmd)
(361,host->mrq->data)
(362,SDMMC_INT_DCRC)
(363,data->stop->error = 0)
(364,if (cmd == host->mrq->sbc && !cmd->error)
(365,lock)
(366,host->mrq->sbc && !data->error)
(367,cmd->error)
(368,)
(369,prev_state = state = STATE_SENDING_CMD)
(370,prev_state)
(371,state)
(372,prev_state = state = STATE_SENDING_DATA)
(373,data->error = -EIO)
(374,data)
(375,set_bit(EVENT_XFER_COMPLETE, &host->completed_events)
(376,)
(377,cur_slot)
(378,ctrl = mci_readl(host, CTRL)
(379,mrq)
(380,status)
(381,dw_mci_request_end(host, host->mrq)
(382,state)
(383,mci_readl(host, CTRL)
(384,data)
(385,case STATE_SENDING_STOP:)
(386,state)
(387,data->stop->error)
(388,host->completed_events)
(389,cmd)
(390,data)
(391,state = STATE_SENDING_STOP)
(392,&host->lock)
(393,)
(394,status & SDMMC_INT_DCRC)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^