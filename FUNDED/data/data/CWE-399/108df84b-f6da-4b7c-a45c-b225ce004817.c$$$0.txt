-----label-----
1
-----code-----
int ptrace_attach(struct task_struct *task)
{
	int retval;

	retval = -EPERM;
	if (task->pid <= 1)
		goto out;
	if (task->tgid == current->tgid)
		goto out;

repeat:
	/*
	 * Nasty, nasty.
	 *
	 * We want to hold both the task-lock and the
	 * tasklist_lock for writing at the same time.
	 * But that's against the rules (tasklist_lock
	 * is taken for reading by interrupts on other
	 * cpu's that may have task_lock).
	 */
	task_lock(task);
	local_irq_disable();
	if (!write_trylock(&tasklist_lock)) {
		local_irq_enable();
		task_unlock(task);
		do {
			cpu_relax();
		} while (!write_can_lock(&tasklist_lock));
		goto repeat;
	}

	/* the same process cannot be attached many times */
	if (task->ptrace & PT_PTRACED)
		goto bad;
	retval = may_attach(task);
	if (retval)
		goto bad;

	/* Go */
	task->ptrace |= PT_PTRACED | ((task->real_parent != current)
				      ? PT_ATTACHED : 0);
	if (capable(CAP_SYS_PTRACE))
		task->ptrace |= PT_PTRACE_CAP;

	__ptrace_link(task, current);

	force_sig_specific(SIGSTOP, task);

bad:
	write_unlock_irq(&tasklist_lock);
	task_unlock(task);
out:
	return retval;
}
-----children-----
1,2
1,3
1,4
3,4
3,5
5,6
5,7
6,7
8,9
8,10
11,12
11,13
11,14
11,15
11,16
11,17
11,18
11,19
11,20
11,21
11,22
11,23
11,24
11,25
11,26
11,27
11,28
12,13
13,14
13,15
15,16
17,18
18,19
18,20
19,20
21,22
22,23
24,25
24,26
25,26
25,27
26,27
26,28
27,28
31,32
33,34
33,35
34,35
34,36
35,36
35,37
36,37
39,40
39,41
40,41
43,44
45,46
45,47
47,48
48,49
48,50
49,50
51,52
53,54
54,55
55,56
57,58
57,59
58,59
59,60
59,61
60,61
62,63
63,64
65,66
65,67
65,68
65,69
66,67
67,68
68,69
70,71
71,72
71,73
72,73
74,75
76,77
76,78
77,78
78,79
79,80
80,81
82,83
83,84
83,85
84,85
86,87
87,88
89,90
91,92
91,93
92,93
92,94
93,94
93,95
94,95
97,98
99,100
101,102
102,103
102,104
103,104
105,106
105,107
106,107
108,109
110,111
110,112
111,112
113,114
115,116
116,117
116,118
117,118
117,119
118,119
121,122
121,123
122,123
124,125
125,126
125,127
125,128
126,127
127,128
127,129
128,129
128,130
129,130
132,133
134,135
137,138
137,139
138,139
138,140
139,140
141,142
142,143
144,145
145,146
145,147
146,147
146,148
147,148
150,151
152,153
153,154
153,155
153,156
154,155
156,157
158,159
160,161
161,162
161,163
161,164
162,163
164,165
166,167
168,169
168,170
170,171
171,172
171,173
172,173
174,175
175,176
175,177
178,179
179,180
179,181
180,181
182,183
184,185
184,186
186,187
187,188
-----nextToken-----
2,4,7,9,10,14,16,20,23,28,29,30,32,37,38,41,42,44,46,50,52,56,61,64,69,73,75,81,85,88,90,95,96,98,100,104,107,109,112,114,119,120,123,130,131,133,135,136,140,143,148,149,151,155,157,159,163,165,167,169,173,176,177,181,183,185,188
-----computeFrom-----
18,19
18,20
25,26
25,27
34,35
34,36
92,93
92,94
102,103
102,104
116,117
116,118
121,122
121,123
127,128
127,129
145,146
145,147
-----guardedBy-----
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;GotoStatement;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;GotoStatement;Name;LabelStatement;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;DoStatement;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;GotoStatement;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;GotoStatement;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;GotoStatement;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;IdExpression;Name;UnaryExpression;ConditionalExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;IfStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LabelStatement;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;ReferenceOperator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LabelStatement;Name;ReturnStatement;IdExpression;Name;
-----ast_node-----
int ptrace_attach(struct task_struct *task){	int retval;	retval = -EPERM;	if (task->pid <= 1)		goto out;	if (task->tgid == current->tgid)		goto out;repeat:	/*	 * Nasty, nasty.	 *	 * We want to hold both the task-lock and the	 * tasklist_lock for writing at the same time.	 * But that's against the rules (tasklist_lock	 * is taken for reading by interrupts on other	 * cpu's that may have task_lock).	 */	task_lock(task);	local_irq_disable();	if (!write_trylock(&tasklist_lock)) {		local_irq_enable();		task_unlock(task);		do {			cpu_relax();		} while (!write_can_lock(&tasklist_lock));		goto repeat;	}	/* the same process cannot be attached many times */	if (task->ptrace & PT_PTRACED)		goto bad;	retval = may_attach(task);	if (retval)		goto bad;	/* Go */	task->ptrace |= PT_PTRACED | ((task->real_parent != current)				      ? PT_ATTACHED : 0);	if (capable(CAP_SYS_PTRACE))		task->ptrace |= PT_PTRACE_CAP;	__ptrace_link(task, current);	force_sig_specific(SIGSTOP, task);bad:	write_unlock_irq(&tasklist_lock);	task_unlock(task);out:	return retval;}
int
ptrace_attach(struct task_struct *task)
ptrace_attach
struct task_struct *task
struct task_struct
task_struct
*task
*
task
{	int retval;	retval = -EPERM;	if (task->pid <= 1)		goto out;	if (task->tgid == current->tgid)		goto out;repeat:	/*	 * Nasty, nasty.	 *	 * We want to hold both the task-lock and the	 * tasklist_lock for writing at the same time.	 * But that's against the rules (tasklist_lock	 * is taken for reading by interrupts on other	 * cpu's that may have task_lock).	 */	task_lock(task);	local_irq_disable();	if (!write_trylock(&tasklist_lock)) {		local_irq_enable();		task_unlock(task);		do {			cpu_relax();		} while (!write_can_lock(&tasklist_lock));		goto repeat;	}	/* the same process cannot be attached many times */	if (task->ptrace & PT_PTRACED)		goto bad;	retval = may_attach(task);	if (retval)		goto bad;	/* Go */	task->ptrace |= PT_PTRACED | ((task->real_parent != current)				      ? PT_ATTACHED : 0);	if (capable(CAP_SYS_PTRACE))		task->ptrace |= PT_PTRACE_CAP;	__ptrace_link(task, current);	force_sig_specific(SIGSTOP, task);bad:	write_unlock_irq(&tasklist_lock);	task_unlock(task);out:	return retval;}
int retval;
int retval;
int
retval
retval
retval = -EPERM;
retval = -EPERM
retval
retval
-EPERM
EPERM
EPERM
if (task->pid <= 1)		goto out;
task->pid <= 1
task->pid
task
task
pid
1
goto out;
out
if (task->tgid == current->tgid)		goto out;
task->tgid == current->tgid
task->tgid
task
task
tgid
current->tgid
current
current
tgid
goto out;
out
repeat:	/*	 * Nasty, nasty.	 *	 * We want to hold both the task-lock and the	 * tasklist_lock for writing at the same time.	 * But that's against the rules (tasklist_lock	 * is taken for reading by interrupts on other	 * cpu's that may have task_lock).	 */	task_lock(task);
repeat
task_lock(task);
task_lock(task)
task_lock
task_lock
task
task
local_irq_disable();
local_irq_disable()
local_irq_disable
local_irq_disable
if (!write_trylock(&tasklist_lock)) {		local_irq_enable();		task_unlock(task);		do {			cpu_relax();		} while (!write_can_lock(&tasklist_lock));		goto repeat;	}
!write_trylock(&tasklist_lock)
write_trylock(&tasklist_lock)
write_trylock
write_trylock
&tasklist_lock
tasklist_lock
tasklist_lock
{		local_irq_enable();		task_unlock(task);		do {			cpu_relax();		} while (!write_can_lock(&tasklist_lock));		goto repeat;	}
local_irq_enable();
local_irq_enable()
local_irq_enable
local_irq_enable
task_unlock(task);
task_unlock(task)
task_unlock
task_unlock
task
task
do {			cpu_relax();		} while (!write_can_lock(&tasklist_lock));
{			cpu_relax();		}
cpu_relax();
cpu_relax()
cpu_relax
cpu_relax
!write_can_lock(&tasklist_lock)
write_can_lock(&tasklist_lock)
write_can_lock
write_can_lock
&tasklist_lock
tasklist_lock
tasklist_lock
goto repeat;
repeat
if (task->ptrace & PT_PTRACED)		goto bad;
task->ptrace & PT_PTRACED
task->ptrace
task
task
ptrace
PT_PTRACED
PT_PTRACED
goto bad;
bad
retval = may_attach(task);
retval = may_attach(task)
retval
retval
may_attach(task)
may_attach
may_attach
task
task
if (retval)		goto bad;
retval
retval
goto bad;
bad
task->ptrace |= PT_PTRACED | ((task->real_parent != current)				      ? PT_ATTACHED : 0);
task->ptrace |= PT_PTRACED | ((task->real_parent != current)				      ? PT_ATTACHED : 0)
task->ptrace
task
task
ptrace
PT_PTRACED | ((task->real_parent != current)				      ? PT_ATTACHED : 0)
PT_PTRACED
PT_PTRACED
((task->real_parent != current)				      ? PT_ATTACHED : 0)
(task->real_parent != current)				      ? PT_ATTACHED : 0
(task->real_parent != current)
task->real_parent != current
task->real_parent
task
task
real_parent
current
current
PT_ATTACHED
PT_ATTACHED
0
if (capable(CAP_SYS_PTRACE))		task->ptrace |= PT_PTRACE_CAP;
capable(CAP_SYS_PTRACE)
capable
capable
(CAP_SYS_PTRACE)
CAP_SYS_PTRACE
CAP_SYS_PTRACE
task->ptrace |= PT_PTRACE_CAP;
task->ptrace |= PT_PTRACE_CAP
task->ptrace
task
task
ptrace
PT_PTRACE_CAP
PT_PTRACE_CAP
__ptrace_link(task, current);
__ptrace_link(task, current)
__ptrace_link
__ptrace_link
task
task
current
current
force_sig_specific(SIGSTOP, task);
force_sig_specific(SIGSTOP, task)
force_sig_specific
force_sig_specific
SIGSTOP
SIGSTOP
task
task
bad:	write_unlock_irq(&tasklist_lock);
bad
write_unlock_irq(&tasklist_lock);
write_unlock_irq(&tasklist_lock);
write_unlock_irq
write_unlock_irq
(&tasklist_lock)
&tasklist_lock
&
tasklist_lock
task_unlock(task);
task_unlock(task)
task_unlock
task_unlock
task
task
out:	return retval;
out
return retval;
retval
retval
-----joern-----
(80,48,0)
(36,94,0)
(63,67,0)
(88,94,0)
(20,89,0)
(4,84,0)
(51,89,0)
(70,84,0)
(9,23,0)
(75,89,0)
(14,42,0)
(84,49,0)
(10,31,0)
(49,71,0)
(17,31,0)
(31,10,0)
(50,94,0)
(79,40,0)
(38,89,0)
(58,5,0)
(68,38,0)
(7,89,0)
(42,2,0)
(74,76,0)
(95,67,0)
(15,28,0)
(48,94,0)
(41,44,0)
(38,58,0)
(37,5,0)
(48,62,0)
(16,71,0)
(1,47,0)
(45,50,0)
(13,89,0)
(92,40,0)
(6,10,0)
(40,89,0)
(19,89,0)
(0,86,0)
(86,94,0)
(81,89,0)
(54,82,0)
(40,94,0)
(47,1,0)
(57,71,0)
(31,62,0)
(46,89,0)
(76,81,0)
(87,41,0)
(10,6,0)
(41,94,0)
(27,82,0)
(62,31,0)
(34,38,0)
(2,43,0)
(22,89,0)
(5,58,0)
(32,89,0)
(88,89,0)
(59,36,0)
(67,73,0)
(55,48,0)
(28,89,0)
(43,2,0)
(21,1,0)
(82,6,0)
(90,50,0)
(12,77,0)
(67,94,0)
(81,76,0)
(53,88,0)
(64,60,0)
(24,11,0)
(77,36,0)
(2,42,0)
(78,41,0)
(56,21,0)
(82,94,0)
(49,84,0)
(66,52,0)
(85,35,0)
(58,89,0)
(26,73,0)
(1,21,0)
(28,86,0)
(91,89,0)
(8,60,0)
(38,28,0)
(71,49,0)
(29,36,0)
(11,60,0)
(73,48,0)
(62,89,0)
(44,41,0)
(23,89,0)
(72,10,0)
(39,44,0)
(18,58,0)
(36,77,0)
(93,10,0)
(23,94,0)
(69,89,0)
(86,28,0)
(65,6,0)
(11,94,0)
(83,60,0)
(50,89,0)
(6,82,0)
(84,94,0)
(62,31,1)
(10,6,1)
(73,48,1)
(11,24,1)
(77,36,1)
(58,5,1)
(78,58,1)
(10,72,1)
(50,94,1)
(56,19,1)
(74,30,1)
(92,79,1)
(70,44,1)
(14,66,1)
(33,28,1)
(88,94,1)
(66,43,1)
(30,77,1)
(12,36,1)
(17,48,1)
(71,16,1)
(77,12,1)
(48,55,1)
(44,39,1)
(83,43,1)
(48,94,1)
(79,50,1)
(27,54,1)
(85,62,1)
(9,83,1)
(42,14,1)
(74,3,1)
(34,25,1)
(45,73,1)
(90,45,1)
(67,63,1)
(23,94,1)
(82,94,1)
(53,81,1)
(21,56,1)
(86,0,1)
(38,58,1)
(68,38,1)
(6,82,1)
(29,47,1)
(41,87,1)
(2,42,1)
(72,6,1)
(1,21,1)
(11,94,1)
(5,37,1)
(50,90,1)
(28,86,1)
(16,57,1)
(73,26,1)
(9,49,1)
(38,34,1)
(0,15,1)
(95,35,1)
(88,53,1)
(80,33,1)
(39,41,1)
(47,1,1)
(19,23,1)
(67,94,1)
(15,77,1)
(36,59,1)
(6,65,1)
(59,29,1)
(49,84,1)
(40,94,1)
(87,78,1)
(76,74,1)
(49,71,1)
(44,41,1)
(25,49,1)
(45,35,1)
(81,76,1)
(74,40,1)
(55,80,1)
(37,18,1)
(10,93,1)
(84,4,1)
(24,64,1)
(57,84,1)
(54,17,1)
(41,94,1)
(64,47,1)
(86,94,1)
(36,94,1)
(4,70,1)
(61,44,1)
(43,2,1)
(23,9,1)
(82,27,1)
(34,88,1)
(38,28,1)
(35,85,1)
(93,6,1)
(65,82,1)
(40,92,1)
(63,95,1)
(26,67,1)
(31,10,1)
(3,33,1)
(66,11,1)
(84,94,1)
(34,61,1)
(9,47,2)
(58,5,2)
(73,35,2)
(4,44,2)
(50,94,2)
(85,33,2)
(73,48,2)
(65,33,2)
(6,33,2)
(56,49,2)
(67,35,2)
(14,43,2)
(82,94,2)
(79,33,2)
(28,86,2)
(48,33,2)
(74,49,2)
(81,76,2)
(66,43,2)
(2,47,2)
(11,47,2)
(14,47,2)
(23,94,2)
(62,31,2)
(19,49,2)
(12,49,2)
(1,47,2)
(84,94,2)
(36,49,2)
(28,77,2)
(61,44,2)
(82,33,2)
(88,49,2)
(38,58,2)
(30,77,2)
(76,49,2)
(62,33,2)
(2,42,2)
(10,33,2)
(24,47,2)
(31,33,2)
(49,71,2)
(67,94,2)
(80,33,2)
(35,33,2)
(77,36,2)
(43,2,2)
(59,49,2)
(17,33,2)
(56,47,2)
(70,44,2)
(43,47,2)
(49,44,2)
(43,43,2)
(10,6,2)
(27,33,2)
(45,33,2)
(21,47,2)
(88,94,2)
(19,47,2)
(57,44,2)
(50,33,2)
(40,94,2)
(66,47,2)
(86,94,2)
(25,49,2)
(71,44,2)
(92,33,2)
(53,49,2)
(21,49,2)
(1,49,2)
(31,10,2)
(72,6,2)
(86,77,2)
(83,47,2)
(26,35,2)
(2,43,2)
(11,94,2)
(47,49,2)
(84,44,2)
(33,77,2)
(68,38,2)
(90,33,2)
(63,35,2)
(93,6,2)
(29,49,2)
(48,94,2)
(23,49,2)
(64,47,2)
(40,33,2)
(9,49,2)
(6,82,2)
(44,41,2)
(54,33,2)
(0,77,2)
(55,33,2)
(1,21,2)
(49,84,2)
(47,47,2)
(81,49,2)
(77,49,2)
(42,47,2)
(38,28,2)
(42,43,2)
(47,1,2)
(95,35,2)
(41,94,2)
(3,33,2)
(23,47,2)
(36,94,2)
(16,44,2)
(15,77,2)
-----------------------------------
(0,task)
(1,write_trylock(&tasklist_lock)
(2,write_can_lock(&tasklist_lock)
(3,goto bad;)
(4,tgid)
(5,-EPERM)
(6,task->real_parent != current)
(7,out:)
(8,do)
(9,task)
(10,(task->real_parent != current)
(11,task_unlock(task)
(12,PT_PTRACED)
(13,if (!write_trylock(&tasklist_lock)
(14,tasklist_lock)
(15,retval)
(16,tgid)
(17,PT_PTRACED)
(18,retval)
(19,local_irq_disable()
(20,if (retval)
(21,&tasklist_lock)
(22,if (task->pid <= 1)
(23,task_lock(task)
(24,task)
(25,goto out;)
(26,PT_PTRACE_CAP)
(27,real_parent)
(28,retval = may_attach(task)
(29,task)
(30,goto bad;)
(31,PT_PTRACED | ((task->real_parent != current)
(32,if (capable(CAP_SYS_PTRACE)
(33,retval)
(34,retval)
(35,capable(CAP_SYS_PTRACE)
(36,task->ptrace)
(37,EPERM)
(38,return retval;)
(39,1)
(40,force_sig_specific(SIGSTOP, task)
(41,task->pid)
(42,&tasklist_lock)
(43,!write_can_lock(&tasklist_lock)
(44,task->pid <= 1)
(45,task)
(46,if (task->tgid == current->tgid)
(47,!write_trylock(&tasklist_lock)
(48,task->ptrace)
(49,task->tgid == current->tgid)
(50,__ptrace_link(task, current)
(51,bad:)
(52,)
(53,task)
(54,task)
(55,ptrace)
(56,tasklist_lock)
(57,current)
(58,retval = -EPERM)
(59,ptrace)
(60,)
(61,goto out;)
(62,task->ptrace |= PT_PTRACED | ((task->real_parent != current)
(63,ptrace)
(64,local_irq_enable()
(65,current)
(66,cpu_relax()
(67,task->ptrace)
(68,RET)
(69,retval)
(70,task)
(71,current->tgid)
(72,0)
(73,task->ptrace |= PT_PTRACE_CAP)
(74,tasklist_lock)
(75,repeat:)
(76,&tasklist_lock)
(77,task->ptrace & PT_PTRACED)
(78,task)
(79,SIGSTOP)
(80,task)
(81,write_unlock_irq(&tasklist_lock)
(82,task->real_parent)
(83,goto repeat;)
(84,task->tgid)
(85,CAP_SYS_PTRACE)
(86,may_attach(task)
(87,pid)
(88,task_unlock(task)
(89,)
(90,current)
(91,if (task->ptrace & PT_PTRACED)
(92,task)
(93,PT_ATTACHED)
(94,struct task_struct *task)
(95,task)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^