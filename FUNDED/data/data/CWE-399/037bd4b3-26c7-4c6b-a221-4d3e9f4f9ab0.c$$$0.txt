-----label-----
0
-----code-----
void cpuidle_enter_freeze(void)
{
	struct cpuidle_device *dev = __this_cpu_read(cpuidle_devices);
	struct cpuidle_driver *drv = cpuidle_get_cpu_driver(dev);
	int index;

	/*
	 * Find the deepest state with ->enter_freeze present, which guarantees
	 * that interrupts won't be enabled when it exits and allows the tick to
	 * be frozen safely.
	 */
	index = cpuidle_find_deepest_state(drv, dev, true);
	if (index >= 0) {
		enter_freeze_proper(drv, dev, index);
		return;
	}

	/*
	 * It is not safe to freeze the tick, find the deepest state available
	 * at all and try to enter it normally.
	 */
	index = cpuidle_find_deepest_state(drv, dev, false);
	if (index >= 0)
		cpuidle_enter(drv, dev, index);
	else
		arch_cpu_idle();

	/* Interrupts are enabled again here. */
	local_irq_disable();
}
-----children-----
1,2
1,3
1,4
3,4
3,5
5,6
5,7
7,8
9,10
9,11
9,12
9,13
9,14
9,15
9,16
9,17
10,11
11,12
11,13
12,13
14,15
14,16
14,17
17,18
18,19
18,20
19,20
21,22
23,24
24,25
24,26
25,26
27,28
27,29
27,30
30,31
31,32
31,33
32,33
34,35
36,37
37,38
37,39
39,40
41,42
42,43
42,44
43,44
45,46
45,47
45,48
45,49
46,47
48,49
50,51
53,54
53,55
54,55
54,56
55,56
58,59
58,60
59,60
60,61
60,62
60,63
60,64
61,62
63,64
65,66
67,68
70,71
71,72
71,73
72,73
74,75
74,76
74,77
74,78
75,76
77,78
79,80
82,83
82,84
82,85
83,84
83,85
84,85
87,88
88,89
88,90
88,91
88,92
89,90
91,92
93,94
95,96
97,98
98,99
99,100
101,102
102,103
103,104
-----nextToken-----
2,4,6,8,13,15,16,20,22,26,28,29,33,35,38,40,44,47,49,51,52,56,57,62,64,66,68,69,73,76,78,80,81,85,86,90,92,94,96,100,104
-----computeFrom-----
42,43
42,44
54,55
54,56
71,72
71,73
83,84
83,85
-----guardedBy-----
56,68
85,96
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ReturnStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;
-----ast_node-----
void cpuidle_enter_freeze(void){	struct cpuidle_device *dev = __this_cpu_read(cpuidle_devices);	struct cpuidle_driver *drv = cpuidle_get_cpu_driver(dev);	int index;	/*	 * Find the deepest state with ->enter_freeze present, which guarantees	 * that interrupts won't be enabled when it exits and allows the tick to	 * be frozen safely.	 */	index = cpuidle_find_deepest_state(drv, dev, true);	if (index >= 0) {		enter_freeze_proper(drv, dev, index);		return;	}	/*	 * It is not safe to freeze the tick, find the deepest state available	 * at all and try to enter it normally.	 */	index = cpuidle_find_deepest_state(drv, dev, false);	if (index >= 0)		cpuidle_enter(drv, dev, index);	else		arch_cpu_idle();	/* Interrupts are enabled again here. */	local_irq_disable();}
void
cpuidle_enter_freeze(void)
cpuidle_enter_freeze
void
void


{	struct cpuidle_device *dev = __this_cpu_read(cpuidle_devices);	struct cpuidle_driver *drv = cpuidle_get_cpu_driver(dev);	int index;	/*	 * Find the deepest state with ->enter_freeze present, which guarantees	 * that interrupts won't be enabled when it exits and allows the tick to	 * be frozen safely.	 */	index = cpuidle_find_deepest_state(drv, dev, true);	if (index >= 0) {		enter_freeze_proper(drv, dev, index);		return;	}	/*	 * It is not safe to freeze the tick, find the deepest state available	 * at all and try to enter it normally.	 */	index = cpuidle_find_deepest_state(drv, dev, false);	if (index >= 0)		cpuidle_enter(drv, dev, index);	else		arch_cpu_idle();	/* Interrupts are enabled again here. */	local_irq_disable();}
struct cpuidle_device *dev = __this_cpu_read(cpuidle_devices);
struct cpuidle_device *dev = __this_cpu_read(cpuidle_devices);
struct cpuidle_device
cpuidle_device
*dev = __this_cpu_read(cpuidle_devices)
*
dev
= __this_cpu_read(cpuidle_devices)
__this_cpu_read(cpuidle_devices)
__this_cpu_read
__this_cpu_read
cpuidle_devices
cpuidle_devices
struct cpuidle_driver *drv = cpuidle_get_cpu_driver(dev);
struct cpuidle_driver *drv = cpuidle_get_cpu_driver(dev);
struct cpuidle_driver
cpuidle_driver
*drv = cpuidle_get_cpu_driver(dev)
*
drv
= cpuidle_get_cpu_driver(dev)
cpuidle_get_cpu_driver(dev)
cpuidle_get_cpu_driver
cpuidle_get_cpu_driver
dev
dev
int index;
int index;
int
index
index
index = cpuidle_find_deepest_state(drv, dev, true);
index = cpuidle_find_deepest_state(drv, dev, true)
index
index
cpuidle_find_deepest_state(drv, dev, true)
cpuidle_find_deepest_state
cpuidle_find_deepest_state
drv
drv
dev
dev
true
if (index >= 0) {		enter_freeze_proper(drv, dev, index);		return;	}
index >= 0
index
index
0
{		enter_freeze_proper(drv, dev, index);		return;	}
enter_freeze_proper(drv, dev, index);
enter_freeze_proper(drv, dev, index)
enter_freeze_proper
enter_freeze_proper
drv
drv
dev
dev
index
index
return;
index = cpuidle_find_deepest_state(drv, dev, false);
index = cpuidle_find_deepest_state(drv, dev, false)
index
index
cpuidle_find_deepest_state(drv, dev, false)
cpuidle_find_deepest_state
cpuidle_find_deepest_state
drv
drv
dev
dev
false
if (index >= 0)		cpuidle_enter(drv, dev, index);	else		arch_cpu_idle();
index >= 0
index
index
0
cpuidle_enter(drv, dev, index);
cpuidle_enter(drv, dev, index)
cpuidle_enter
cpuidle_enter
drv
drv
dev
dev
index
index
arch_cpu_idle();
arch_cpu_idle()
arch_cpu_idle
arch_cpu_idle
local_irq_disable();
local_irq_disable()
local_irq_disable
local_irq_disable
-----joern-----
(6,22,0)
(14,13,0)
(12,34,0)
(7,44,0)
(44,4,0)
(8,40,0)
(33,4,0)
(8,22,0)
(26,19,0)
(44,13,0)
(42,19,0)
(27,22,0)
(23,40,0)
(20,40,0)
(25,28,0)
(28,44,0)
(31,44,0)
(21,22,0)
(37,13,0)
(1,43,0)
(0,19,0)
(34,8,0)
(43,4,0)
(4,43,0)
(41,28,0)
(17,22,0)
(33,28,0)
(4,22,0)
(9,40,0)
(35,25,0)
(32,33,0)
(11,44,0)
(38,33,0)
(5,14,0)
(29,30,0)
(2,22,0)
(16,34,0)
(40,4,0)
(40,13,0)
(18,25,0)
(13,22,0)
(44,28,0)
(33,13,0)
(13,14,0)
(24,4,0)
(10,8,0)
(30,39,0)
(15,33,0)
(40,8,0)
(14,4,0)
(19,13,0)
(19,8,0)
(36,22,0)
(28,22,0)
(19,4,0)
(33,39,0)
(29,30,1)
(0,26,1)
(19,42,1)
(43,1,1)
(34,8,1)
(14,5,1)
(19,13,1)
(42,0,1)
(33,13,1)
(31,7,1)
(11,41,1)
(18,35,1)
(37,4,1)
(20,10,1)
(33,4,1)
(44,13,1)
(41,13,1)
(23,20,1)
(38,25,1)
(29,36,1)
(25,28,1)
(15,32,1)
(33,15,1)
(1,24,1)
(5,37,1)
(44,31,1)
(13,14,1)
(33,28,1)
(40,9,1)
(9,23,1)
(12,16,1)
(34,12,1)
(36,19,1)
(19,8,1)
(28,44,1)
(40,13,1)
(25,18,1)
(40,4,1)
(10,25,1)
(3,34,1)
(14,4,1)
(7,11,1)
(26,34,1)
(8,40,1)
(36,3,1)
(4,43,1)
(32,38,1)
(30,33,1)
(44,4,1)
(19,4,1)
(16,8,1)
(35,28,1)
(34,8,2)
(44,13,2)
(33,13,2)
(28,44,2)
(42,34,2)
(25,28,2)
(19,8,2)
(33,25,2)
(29,30,2)
(13,14,2)
(40,25,2)
(38,25,2)
(40,13,2)
(34,25,2)
(19,13,2)
(4,43,2)
(32,25,2)
(3,34,2)
(23,25,2)
(8,40,2)
(16,25,2)
(12,25,2)
(9,25,2)
(14,4,2)
(20,25,2)
(30,25,2)
(0,34,2)
(19,4,2)
(44,4,2)
(36,25,2)
(33,4,2)
(19,34,2)
(33,28,2)
(26,34,2)
(15,25,2)
(8,25,2)
(40,4,2)
(10,25,2)
-----------------------------------
(0,dev)
(1,cpuidle_devices)
(2,dev)
(3,arch_cpu_idle()
(4,*dev = __this_cpu_read(cpuidle_devices)
(5,dev)
(6,drv)
(7,dev)
(8,index = cpuidle_find_deepest_state(drv, dev, false)
(9,false)
(10,index)
(11,drv)
(12,0)
(13,*drv = cpuidle_get_cpu_driver(dev)
(14,cpuidle_get_cpu_driver(dev)
(15,index)
(16,index)
(17,if (index >= 0)
(18,0)
(19,cpuidle_enter(drv, dev, index)
(20,drv)
(21,if (index >= 0)
(22,)
(23,dev)
(24,dev)
(25,index >= 0)
(26,drv)
(27,index)
(28,index = cpuidle_find_deepest_state(drv, dev, true)
(29,RET)
(30,return;)
(31,true)
(32,dev)
(33,enter_freeze_proper(drv, dev, index)
(34,index >= 0)
(35,index)
(36,local_irq_disable()
(37,drv)
(38,drv)
(39,)
(40,cpuidle_find_deepest_state(drv, dev, false)
(41,index)
(42,index)
(43,__this_cpu_read(cpuidle_devices)
(44,cpuidle_find_deepest_state(drv, dev, true)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^