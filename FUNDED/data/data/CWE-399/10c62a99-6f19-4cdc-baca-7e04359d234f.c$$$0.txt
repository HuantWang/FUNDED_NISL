-----label-----
1
-----code-----
static void
parse_unit(Eo_Lexer *ls, Eina_Bool eot)
{
   switch (ls->t.kw)
     {
      case KW_abstract:
        if (eot) goto def;
        parse_class(ls, EINA_TRUE, EOLIAN_CLASS_ABSTRACT);
        goto found_class;
      case KW_class:
        if (eot) goto def;
        parse_class(ls, EINA_TRUE, EOLIAN_CLASS_REGULAR);
        goto found_class;
      case KW_mixin:
        if (eot) goto def;
        parse_class(ls, EINA_FALSE, EOLIAN_CLASS_MIXIN);
        goto found_class;
      case KW_interface:
        if (eot) goto def;
        parse_class(ls, EINA_FALSE, EOLIAN_CLASS_INTERFACE);
        goto found_class;
      case KW_type:
        {
           parse_typedef(ls);
           append_node(ls, NODE_TYPEDEF, ls->tmp.typedef_def);
           ls->tmp.typedef_def = NULL;
           break;
        }
      case KW_struct:
        {
           const char *name;
           eo_lexer_get(ls);
           check(ls, TOK_VALUE);
           if (eo_lexer_get_c_type(ls->t.kw))
             eo_lexer_syntax_error(ls, "invalid struct name");
           name = eina_stringshare_add(ls->t.value);
           eo_lexer_get(ls);
           parse_struct(ls, name);
           pop_type(ls);
           break;
        }
      def:
      default:
        eo_lexer_syntax_error(ls, "invalid token");
        break;
     }
   return;
found_class:
   append_node(ls, NODE_CLASS, ls->tmp.kls);
   ls->tmp.kls = NULL;
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
5,6
5,7
6,7
8,9
8,10
11,12
11,13
12,13
14,15
16,17
16,18
16,19
16,20
17,18
17,19
18,19
18,20
19,20
19,21
20,21
24,25
24,26
24,27
24,28
24,29
24,30
24,31
24,32
24,33
24,34
24,35
24,36
24,37
24,38
24,39
24,40
24,41
24,42
24,43
24,44
24,45
24,46
24,47
25,26
26,27
28,29
28,30
29,30
31,32
33,34
34,35
34,36
34,37
34,38
35,36
37,38
39,40
41,42
43,44
45,46
46,47
48,49
48,50
49,50
51,52
53,54
54,55
54,56
54,57
54,58
55,56
57,58
59,60
61,62
63,64
65,66
66,67
68,69
68,70
69,70
71,72
73,74
74,75
74,76
74,77
74,78
75,76
77,78
79,80
81,82
83,84
85,86
86,87
88,89
88,90
89,90
91,92
93,94
94,95
94,96
94,97
94,98
95,96
97,98
99,100
101,102
103,104
105,106
106,107
108,109
108,110
108,111
108,112
109,110
110,111
110,112
111,112
113,114
115,116
116,117
116,118
116,119
116,120
117,118
119,120
121,122
123,124
123,125
124,125
124,126
125,126
129,130
130,131
130,132
131,132
131,133
132,133
132,134
133,134
137,138
140,141
141,142
143,144
143,145
143,146
143,147
143,148
143,149
143,150
143,151
143,152
144,145
145,146
145,147
147,148
147,149
150,151
151,152
151,153
152,153
154,155
156,157
157,158
157,159
157,160
158,159
160,161
162,163
164,165
164,166
165,166
165,167
166,167
168,169
168,170
169,170
169,171
170,171
174,175
175,176
175,177
175,178
176,177
178,179
181,182
182,183
182,184
183,184
185,186
185,187
186,187
188,189
188,190
189,190
189,191
190,191
194,195
195,196
195,197
196,197
198,199
200,201
201,202
201,203
201,204
202,203
204,205
206,207
208,209
209,210
209,211
210,211
212,213
215,216
215,217
218,219
219,220
219,221
219,222
220,221
222,223
227,228
227,229
229,230
230,231
230,232
230,233
230,234
231,232
233,234
235,236
237,238
237,239
238,239
238,240
239,240
243,244
244,245
244,246
245,246
245,247
246,247
246,248
247,248
251,252
-----nextToken-----
2,4,7,9,10,13,15,21,22,23,27,30,32,36,38,40,42,44,47,50,52,56,58,60,62,64,67,70,72,76,78,80,82,84,87,90,92,96,98,100,102,104,107,112,114,118,120,122,126,127,128,134,135,136,138,139,142,146,148,149,153,155,159,161,163,167,171,172,173,177,179,180,184,187,191,192,193,197,199,203,205,207,211,213,214,216,217,221,223,224,225,226,228,232,234,236,240,241,242,248,249,250,252
-----computeFrom-----
130,131
130,132
182,183
182,184
244,245
244,246
-----guardedBy-----
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Name;CompoundStatement;SwitchStatement;FieldReference;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;CaseStatement;IdExpression;Name;IfStatement;IdExpression;Name;GotoStatement;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;GotoStatement;Name;CaseStatement;IdExpression;Name;IfStatement;IdExpression;Name;GotoStatement;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;GotoStatement;Name;CaseStatement;IdExpression;Name;IfStatement;IdExpression;Name;GotoStatement;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;GotoStatement;Name;CaseStatement;IdExpression;Name;IfStatement;IdExpression;Name;GotoStatement;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;GotoStatement;Name;CaseStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BreakStatement;LabelStatement;Name;DefaultStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;BreakStatement;ReturnStatement;LabelStatement;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;
-----ast_node-----
static voidparse_unit(Eo_Lexer *ls, Eina_Bool eot){   switch (ls->t.kw)     {      case KW_abstract:        if (eot) goto def;        parse_class(ls, EINA_TRUE, EOLIAN_CLASS_ABSTRACT);        goto found_class;      case KW_class:        if (eot) goto def;        parse_class(ls, EINA_TRUE, EOLIAN_CLASS_REGULAR);        goto found_class;      case KW_mixin:        if (eot) goto def;        parse_class(ls, EINA_FALSE, EOLIAN_CLASS_MIXIN);        goto found_class;      case KW_interface:        if (eot) goto def;        parse_class(ls, EINA_FALSE, EOLIAN_CLASS_INTERFACE);        goto found_class;      case KW_type:        {           parse_typedef(ls);           append_node(ls, NODE_TYPEDEF, ls->tmp.typedef_def);           ls->tmp.typedef_def = NULL;           break;        }      case KW_struct:        {           const char *name;           eo_lexer_get(ls);           check(ls, TOK_VALUE);           if (eo_lexer_get_c_type(ls->t.kw))             eo_lexer_syntax_error(ls, "invalid struct name");           name = eina_stringshare_add(ls->t.value);           eo_lexer_get(ls);           parse_struct(ls, name);           pop_type(ls);           break;        }      def:      default:        eo_lexer_syntax_error(ls, "invalid token");        break;     }   return;found_class:   append_node(ls, NODE_CLASS, ls->tmp.kls);   ls->tmp.kls = NULL;}
static void
parse_unit(Eo_Lexer *ls, Eina_Bool eot)
parse_unit
Eo_Lexer *ls
Eo_Lexer
Eo_Lexer
*ls
*
ls
Eina_Bool eot
Eina_Bool
Eina_Bool
eot
eot
{   switch (ls->t.kw)     {      case KW_abstract:        if (eot) goto def;        parse_class(ls, EINA_TRUE, EOLIAN_CLASS_ABSTRACT);        goto found_class;      case KW_class:        if (eot) goto def;        parse_class(ls, EINA_TRUE, EOLIAN_CLASS_REGULAR);        goto found_class;      case KW_mixin:        if (eot) goto def;        parse_class(ls, EINA_FALSE, EOLIAN_CLASS_MIXIN);        goto found_class;      case KW_interface:        if (eot) goto def;        parse_class(ls, EINA_FALSE, EOLIAN_CLASS_INTERFACE);        goto found_class;      case KW_type:        {           parse_typedef(ls);           append_node(ls, NODE_TYPEDEF, ls->tmp.typedef_def);           ls->tmp.typedef_def = NULL;           break;        }      case KW_struct:        {           const char *name;           eo_lexer_get(ls);           check(ls, TOK_VALUE);           if (eo_lexer_get_c_type(ls->t.kw))             eo_lexer_syntax_error(ls, "invalid struct name");           name = eina_stringshare_add(ls->t.value);           eo_lexer_get(ls);           parse_struct(ls, name);           pop_type(ls);           break;        }      def:      default:        eo_lexer_syntax_error(ls, "invalid token");        break;     }   return;found_class:   append_node(ls, NODE_CLASS, ls->tmp.kls);   ls->tmp.kls = NULL;}
switch (ls->t.kw)     {      case KW_abstract:        if (eot) goto def;        parse_class(ls, EINA_TRUE, EOLIAN_CLASS_ABSTRACT);        goto found_class;      case KW_class:        if (eot) goto def;        parse_class(ls, EINA_TRUE, EOLIAN_CLASS_REGULAR);        goto found_class;      case KW_mixin:        if (eot) goto def;        parse_class(ls, EINA_FALSE, EOLIAN_CLASS_MIXIN);        goto found_class;      case KW_interface:        if (eot) goto def;        parse_class(ls, EINA_FALSE, EOLIAN_CLASS_INTERFACE);        goto found_class;      case KW_type:        {           parse_typedef(ls);           append_node(ls, NODE_TYPEDEF, ls->tmp.typedef_def);           ls->tmp.typedef_def = NULL;           break;        }      case KW_struct:        {           const char *name;           eo_lexer_get(ls);           check(ls, TOK_VALUE);           if (eo_lexer_get_c_type(ls->t.kw))             eo_lexer_syntax_error(ls, "invalid struct name");           name = eina_stringshare_add(ls->t.value);           eo_lexer_get(ls);           parse_struct(ls, name);           pop_type(ls);           break;        }      def:      default:        eo_lexer_syntax_error(ls, "invalid token");        break;     }
ls->t.kw
ls->t
ls
ls
t
kw
{      case KW_abstract:        if (eot) goto def;        parse_class(ls, EINA_TRUE, EOLIAN_CLASS_ABSTRACT);        goto found_class;      case KW_class:        if (eot) goto def;        parse_class(ls, EINA_TRUE, EOLIAN_CLASS_REGULAR);        goto found_class;      case KW_mixin:        if (eot) goto def;        parse_class(ls, EINA_FALSE, EOLIAN_CLASS_MIXIN);        goto found_class;      case KW_interface:        if (eot) goto def;        parse_class(ls, EINA_FALSE, EOLIAN_CLASS_INTERFACE);        goto found_class;      case KW_type:        {           parse_typedef(ls);           append_node(ls, NODE_TYPEDEF, ls->tmp.typedef_def);           ls->tmp.typedef_def = NULL;           break;        }      case KW_struct:        {           const char *name;           eo_lexer_get(ls);           check(ls, TOK_VALUE);           if (eo_lexer_get_c_type(ls->t.kw))             eo_lexer_syntax_error(ls, "invalid struct name");           name = eina_stringshare_add(ls->t.value);           eo_lexer_get(ls);           parse_struct(ls, name);           pop_type(ls);           break;        }      def:      default:        eo_lexer_syntax_error(ls, "invalid token");        break;     }
case KW_abstract:
KW_abstract
KW_abstract
if (eot) goto def;
eot
eot
goto def;
def
parse_class(ls, EINA_TRUE, EOLIAN_CLASS_ABSTRACT);
parse_class(ls, EINA_TRUE, EOLIAN_CLASS_ABSTRACT)
parse_class
parse_class
ls
ls
EINA_TRUE
EINA_TRUE
EOLIAN_CLASS_ABSTRACT
EOLIAN_CLASS_ABSTRACT
goto found_class;
found_class
case KW_class:
KW_class
KW_class
if (eot) goto def;
eot
eot
goto def;
def
parse_class(ls, EINA_TRUE, EOLIAN_CLASS_REGULAR);
parse_class(ls, EINA_TRUE, EOLIAN_CLASS_REGULAR)
parse_class
parse_class
ls
ls
EINA_TRUE
EINA_TRUE
EOLIAN_CLASS_REGULAR
EOLIAN_CLASS_REGULAR
goto found_class;
found_class
case KW_mixin:
KW_mixin
KW_mixin
if (eot) goto def;
eot
eot
goto def;
def
parse_class(ls, EINA_FALSE, EOLIAN_CLASS_MIXIN);
parse_class(ls, EINA_FALSE, EOLIAN_CLASS_MIXIN)
parse_class
parse_class
ls
ls
EINA_FALSE
EINA_FALSE
EOLIAN_CLASS_MIXIN
EOLIAN_CLASS_MIXIN
goto found_class;
found_class
case KW_interface:
KW_interface
KW_interface
if (eot) goto def;
eot
eot
goto def;
def
parse_class(ls, EINA_FALSE, EOLIAN_CLASS_INTERFACE);
parse_class(ls, EINA_FALSE, EOLIAN_CLASS_INTERFACE)
parse_class
parse_class
ls
ls
EINA_FALSE
EINA_FALSE
EOLIAN_CLASS_INTERFACE
EOLIAN_CLASS_INTERFACE
goto found_class;
found_class
case KW_type:
KW_type
KW_type
{           parse_typedef(ls);           append_node(ls, NODE_TYPEDEF, ls->tmp.typedef_def);           ls->tmp.typedef_def = NULL;           break;        }
parse_typedef(ls);
parse_typedef(ls)
parse_typedef
parse_typedef
ls
ls
append_node(ls, NODE_TYPEDEF, ls->tmp.typedef_def);
append_node(ls, NODE_TYPEDEF, ls->tmp.typedef_def)
append_node
append_node
ls
ls
NODE_TYPEDEF
NODE_TYPEDEF
ls->tmp.typedef_def
ls->tmp
ls
ls
tmp
typedef_def
ls->tmp.typedef_def = NULL;
ls->tmp.typedef_def = NULL
ls->tmp.typedef_def
ls->tmp
ls
ls
tmp
typedef_def
NULL
NULL
break;
case KW_struct:
KW_struct
KW_struct
{           const char *name;           eo_lexer_get(ls);           check(ls, TOK_VALUE);           if (eo_lexer_get_c_type(ls->t.kw))             eo_lexer_syntax_error(ls, "invalid struct name");           name = eina_stringshare_add(ls->t.value);           eo_lexer_get(ls);           parse_struct(ls, name);           pop_type(ls);           break;        }
const char *name;
const char *name;
const char
*name
*
name
eo_lexer_get(ls);
eo_lexer_get(ls)
eo_lexer_get
eo_lexer_get
ls
ls
check(ls, TOK_VALUE);
check(ls, TOK_VALUE)
check
check
ls
ls
TOK_VALUE
TOK_VALUE
if (eo_lexer_get_c_type(ls->t.kw))             eo_lexer_syntax_error(ls, "invalid struct name");
eo_lexer_get_c_type(ls->t.kw)
eo_lexer_get_c_type
eo_lexer_get_c_type
ls->t.kw
ls->t
ls
ls
t
kw
eo_lexer_syntax_error(ls, "invalid struct name");
eo_lexer_syntax_error(ls, "invalid struct name")
eo_lexer_syntax_error
eo_lexer_syntax_error
ls
ls
"invalid struct name"
name = eina_stringshare_add(ls->t.value);
name = eina_stringshare_add(ls->t.value)
name
name
eina_stringshare_add(ls->t.value)
eina_stringshare_add
eina_stringshare_add
ls->t.value
ls->t
ls
ls
t
value
eo_lexer_get(ls);
eo_lexer_get(ls)
eo_lexer_get
eo_lexer_get
ls
ls
parse_struct(ls, name);
parse_struct(ls, name)
parse_struct
parse_struct
ls
ls
name
name
pop_type(ls);
pop_type(ls)
pop_type
pop_type
ls
ls
break;
def:      default:
def
default:
eo_lexer_syntax_error(ls, "invalid token");
eo_lexer_syntax_error(ls, "invalid token")
eo_lexer_syntax_error
eo_lexer_syntax_error
ls
ls
"invalid token"
break;
return;
found_class:   append_node(ls, NODE_CLASS, ls->tmp.kls);
found_class
append_node(ls, NODE_CLASS, ls->tmp.kls);
append_node(ls, NODE_CLASS, ls->tmp.kls)
append_node
append_node
ls
ls
NODE_CLASS
NODE_CLASS
ls->tmp.kls
ls->tmp
ls
ls
tmp
kls
ls->tmp.kls = NULL;
ls->tmp.kls = NULL
ls->tmp.kls
ls->tmp
ls
ls
tmp
kls
NULL
NULL
-----joern-----
(6,81,0)
(119,103,0)
(35,89,0)
(76,26,0)
(101,109,0)
(118,32,0)
(94,107,0)
(11,107,0)
(45,71,0)
(94,53,0)
(51,23,0)
(0,35,0)
(8,32,0)
(41,95,0)
(95,41,0)
(116,89,0)
(39,32,0)
(69,110,0)
(78,107,0)
(30,107,0)
(48,109,0)
(11,53,0)
(37,35,0)
(14,30,0)
(52,59,0)
(70,117,0)
(17,32,0)
(40,78,0)
(52,97,0)
(13,22,0)
(122,32,0)
(56,32,0)
(38,80,0)
(112,32,0)
(65,109,0)
(71,32,0)
(35,37,0)
(61,13,0)
(7,118,0)
(83,118,0)
(111,9,0)
(110,107,0)
(4,37,0)
(80,88,0)
(110,32,0)
(22,13,0)
(42,64,0)
(49,97,0)
(34,109,0)
(104,59,0)
(60,32,0)
(92,11,0)
(28,31,0)
(24,94,0)
(62,53,0)
(31,64,0)
(89,107,0)
(18,32,0)
(59,107,0)
(20,67,0)
(89,35,0)
(47,39,0)
(79,97,0)
(5,52,0)
(67,53,0)
(53,32,0)
(1,118,0)
(58,32,0)
(41,107,0)
(78,67,0)
(117,107,0)
(74,110,0)
(13,25,0)
(37,107,0)
(63,89,0)
(80,107,0)
(46,32,0)
(75,67,0)
(106,25,0)
(97,52,0)
(72,26,0)
(117,32,0)
(2,32,0)
(43,88,0)
(85,103,0)
(25,13,0)
(95,20,0)
(10,71,0)
(103,9,0)
(78,53,0)
(73,117,0)
(121,80,0)
(64,32,0)
(57,41,0)
(55,78,0)
(99,32,0)
(59,109,0)
(23,64,0)
(66,16,0)
(97,107,0)
(29,32,0)
(118,107,0)
(87,32,0)
(20,95,0)
(51,26,0)
(88,80,0)
(30,53,0)
(93,39,0)
(25,107,0)
(67,20,0)
(82,65,0)
(115,41,0)
(26,107,0)
(39,107,0)
(108,81,0)
(27,95,0)
(26,51,0)
(68,37,0)
(44,32,0)
(9,48,0)
(91,23,0)
(54,16,0)
(81,107,0)
(16,107,0)
(9,103,0)
(37,64,0)
(31,107,0)
(12,53,0)
(96,48,0)
(81,53,0)
(15,25,0)
(102,53,0)
(50,117,0)
(84,59,0)
(103,107,0)
(114,32,0)
(100,32,0)
(105,51,0)
(98,32,0)
(59,52,0)
(90,39,0)
(21,110,0)
(71,107,0)
(102,30,1)
(75,16,1)
(81,6,1)
(95,27,1)
(113,88,1)
(0,89,1)
(90,93,1)
(52,5,1)
(96,9,1)
(10,3,1)
(35,89,1)
(65,42,1)
(67,20,1)
(21,69,1)
(13,25,1)
(91,51,1)
(110,74,1)
(25,107,1)
(80,107,1)
(71,107,1)
(97,49,1)
(9,111,1)
(35,0,1)
(20,95,1)
(51,105,1)
(81,107,1)
(61,25,1)
(7,83,1)
(54,22,1)
(106,15,1)
(93,47,1)
(48,96,1)
(45,10,1)
(23,91,1)
(84,56,1)
(117,73,1)
(65,112,1)
(75,22,1)
(78,55,1)
(94,24,1)
(80,38,1)
(103,107,1)
(27,41,1)
(9,103,1)
(42,23,1)
(10,86,1)
(10,36,1)
(112,71,1)
(10,88,1)
(41,115,1)
(115,57,1)
(59,52,1)
(118,1,1)
(55,40,1)
(26,72,1)
(118,107,1)
(86,120,1)
(103,119,1)
(14,78,1)
(56,118,1)
(3,19,1)
(25,106,1)
(108,94,1)
(83,113,1)
(84,58,1)
(13,61,1)
(79,104,1)
(74,21,1)
(69,77,1)
(116,68,1)
(31,107,1)
(82,65,1)
(5,97,1)
(117,107,1)
(38,121,1)
(41,107,1)
(70,50,1)
(76,37,1)
(119,85,1)
(11,107,1)
(73,70,1)
(19,88,1)
(68,4,1)
(85,59,1)
(120,88,1)
(104,84,1)
(88,43,1)
(88,80,1)
(72,76,1)
(89,63,1)
(6,108,1)
(59,107,1)
(31,28,1)
(29,110,1)
(49,79,1)
(71,45,1)
(30,14,1)
(22,13,1)
(100,39,1)
(47,120,1)
(84,100,1)
(11,92,1)
(58,117,1)
(37,35,1)
(95,41,1)
(111,103,1)
(16,66,1)
(105,26,1)
(26,107,1)
(110,107,1)
(24,88,1)
(82,48,1)
(92,67,1)
(39,107,1)
(40,11,1)
(36,113,1)
(30,107,1)
(66,54,1)
(84,29,1)
(78,107,1)
(16,107,1)
(28,88,1)
(57,75,1)
(52,97,1)
(89,107,1)
(51,26,1)
(1,7,1)
(43,80,1)
(10,33,1)
(65,102,1)
(77,88,1)
(97,107,1)
(50,19,1)
(37,107,1)
(39,90,1)
(33,77,1)
(78,67,1)
(4,31,1)
(15,81,1)
(63,116,1)
(94,107,1)
(79,19,2)
(84,77,2)
(58,19,2)
(10,88,2)
(35,88,2)
(94,107,2)
(106,88,2)
(74,77,2)
(65,120,2)
(112,113,2)
(3,19,2)
(45,77,2)
(102,88,2)
(110,77,2)
(104,120,2)
(83,113,2)
(48,120,2)
(65,19,2)
(54,22,2)
(48,113,2)
(7,113,2)
(9,103,2)
(119,120,2)
(117,19,2)
(72,88,2)
(26,107,2)
(85,120,2)
(52,19,2)
(65,113,2)
(22,13,2)
(103,77,2)
(117,107,2)
(13,25,2)
(73,19,2)
(97,107,2)
(29,77,2)
(78,107,2)
(113,88,2)
(52,113,2)
(59,107,2)
(119,77,2)
(84,113,2)
(118,113,2)
(10,113,2)
(89,88,2)
(94,88,2)
(78,88,2)
(70,19,2)
(47,120,2)
(11,107,2)
(45,19,2)
(96,120,2)
(71,77,2)
(103,19,2)
(23,88,2)
(31,107,2)
(103,107,2)
(9,113,2)
(120,88,2)
(71,19,2)
(82,65,2)
(5,113,2)
(67,20,2)
(79,120,2)
(16,107,2)
(56,113,2)
(105,88,2)
(104,19,2)
(20,88,2)
(59,19,2)
(59,120,2)
(49,120,2)
(85,113,2)
(97,77,2)
(59,77,2)
(37,107,2)
(80,107,2)
(111,113,2)
(96,77,2)
(9,77,2)
(112,77,2)
(103,113,2)
(13,88,2)
(96,19,2)
(14,88,2)
(66,22,2)
(67,88,2)
(41,107,2)
(63,88,2)
(116,88,2)
(45,88,2)
(15,88,2)
(10,77,2)
(111,19,2)
(24,88,2)
(21,77,2)
(71,107,2)
(52,120,2)
(20,95,2)
(97,19,2)
(111,77,2)
(108,88,2)
(71,113,2)
(81,88,2)
(77,88,2)
(25,88,2)
(85,77,2)
(33,77,2)
(31,88,2)
(50,19,2)
(68,88,2)
(71,88,2)
(96,113,2)
(51,88,2)
(39,107,2)
(115,88,2)
(75,88,2)
(40,88,2)
(111,120,2)
(119,19,2)
(22,88,2)
(90,120,2)
(76,88,2)
(57,88,2)
(42,88,2)
(4,88,2)
(79,77,2)
(30,107,2)
(61,88,2)
(41,88,2)
(69,77,2)
(119,113,2)
(71,120,2)
(89,107,2)
(65,77,2)
(104,77,2)
(28,88,2)
(100,120,2)
(45,120,2)
(11,88,2)
(48,19,2)
(19,88,2)
(92,88,2)
(65,88,2)
(59,52,2)
(5,77,2)
(95,41,2)
(9,19,2)
(78,67,2)
(10,19,2)
(112,19,2)
(84,120,2)
(104,113,2)
(27,88,2)
(86,120,2)
(49,19,2)
(30,88,2)
(79,113,2)
(91,88,2)
(93,120,2)
(103,120,2)
(6,88,2)
(97,113,2)
(5,19,2)
(49,113,2)
(112,88,2)
(110,107,2)
(9,120,2)
(118,107,2)
(88,80,2)
(5,120,2)
(25,107,2)
(1,113,2)
(81,107,2)
(59,113,2)
(16,22,2)
(52,97,2)
(84,19,2)
(52,77,2)
(36,113,2)
(95,88,2)
(35,89,2)
(37,88,2)
(26,88,2)
(97,120,2)
(0,88,2)
(48,77,2)
(85,19,2)
(112,120,2)
(51,26,2)
(45,113,2)
(10,120,2)
(39,120,2)
(37,35,2)
(49,77,2)
(55,88,2)
-----------------------------------
(0,typedef_def)
(1,EOLIAN_CLASS_INTERFACE)
(2,case KW_abstract:)
(3,goto def;)
(4,ls)
(5,kls)
(6,TOK_VALUE)
(7,EINA_FALSE)
(8,if (eot)
(9,ls->tmp.kls)
(10,ls)
(11,eo_lexer_get(ls)
(12,if (eo_lexer_get_c_type(ls->t.kw)
(13,ls->t.kw)
(14,ls)
(15,ls)
(16,eo_lexer_syntax_error(ls, "invalid struct name")
(17,if (eot)
(18,case KW_mixin:)
(19,eot)
(20,eina_stringshare_add(ls->t.value)
(21,EINA_TRUE)
(22,eo_lexer_get_c_type(ls->t.kw)
(23,ls->tmp.typedef_def = NULL)
(24,ls)
(25,ls->t)
(26,ls->tmp)
(27,value)
(28,ls)
(29,goto found_class;)
(30,pop_type(ls)
(31,parse_typedef(ls)
(32,)
(33,goto def;)
(34,switch (ls->t.kw)
(35,ls->tmp.typedef_def)
(36,goto def;)
(37,append_node(ls, NODE_TYPEDEF, ls->tmp.typedef_def)
(38,t)
(39,parse_class(ls, EINA_FALSE, EOLIAN_CLASS_MIXIN)
(40,ls)
(41,ls->t)
(42,break;)
(43,kw)
(44,case KW_interface:)
(45,"invalid token")
(46,if (eot)
(47,ls)
(48,ls->tmp.kls = NULL)
(49,tmp)
(50,ls)
(51,ls->tmp.typedef_def)
(52,ls->tmp.kls)
(53,)
(54,ls)
(55,name)
(56,goto found_class;)
(57,ls)
(58,goto found_class;)
(59,append_node(ls, NODE_CLASS, ls->tmp.kls)
(60,case KW_type:)
(61,kw)
(62,name)
(63,tmp)
(64,)
(65,return;)
(66,"invalid struct name")
(67,name = eina_stringshare_add(ls->t.value)
(68,NODE_TYPEDEF)
(69,ls)
(70,EINA_TRUE)
(71,eo_lexer_syntax_error(ls, "invalid token")
(72,tmp)
(73,EOLIAN_CLASS_REGULAR)
(74,EOLIAN_CLASS_ABSTRACT)
(75,name)
(76,ls)
(77,eot)
(78,parse_struct(ls, name)
(79,ls)
(80,ls->t)
(81,check(ls, TOK_VALUE)
(82,RET)
(83,ls)
(84,ls)
(85,ls)
(86,goto def;)
(87,if (eot)
(88,ls->t.kw)
(89,ls->tmp)
(90,EOLIAN_CLASS_MIXIN)
(91,NULL)
(92,ls)
(93,EINA_FALSE)
(94,eo_lexer_get(ls)
(95,ls->t.value)
(96,NULL)
(97,ls->tmp)
(98,default:)
(99,def:)
(100,goto found_class;)
(101,found_class:)
(102,break;)
(103,ls->tmp)
(104,NODE_CLASS)
(105,typedef_def)
(106,t)
(107,Eo_Lexer *ls)
(108,ls)
(109,)
(110,parse_class(ls, EINA_TRUE, EOLIAN_CLASS_ABSTRACT)
(111,kls)
(112,break;)
(113,eot)
(114,case KW_class:)
(115,t)
(116,ls)
(117,parse_class(ls, EINA_TRUE, EOLIAN_CLASS_REGULAR)
(118,parse_class(ls, EINA_FALSE, EOLIAN_CLASS_INTERFACE)
(119,tmp)
(120,eot)
(121,ls)
(122,case KW_struct:)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^