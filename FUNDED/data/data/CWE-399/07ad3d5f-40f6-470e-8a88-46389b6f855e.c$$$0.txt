-----label-----
1
-----code-----
static void process_one_req(struct work_struct *_work)
{
	struct addr_req *req;
	struct sockaddr *src_in, *dst_in;

	mutex_lock(&lock);
	req = container_of(_work, struct addr_req, work.work);

	if (req->status == -ENODATA) {
		src_in = (struct sockaddr *)&req->src_addr;
		dst_in = (struct sockaddr *)&req->dst_addr;
		req->status = addr_resolve(src_in, dst_in, req->addr,
					   true, req->seq);
		if (req->status && time_after_eq(jiffies, req->timeout)) {
			req->status = -ETIMEDOUT;
		} else if (req->status == -ENODATA) {
			/* requeue the work for retrying again */
			set_timeout(&req->work, req->timeout);
			mutex_unlock(&lock);
			return;
		}
	}
	list_del(&req->list);
	mutex_unlock(&lock);

	/*
	 * Although the work will normally have been canceled by the
	 * workqueue, it can still be requeued as long as it is on the
	 * req_list, so it could have been requeued before we grabbed &lock.
	 * We need to cancel it after it is removed from req_list to really be
	 * sure it is safe to free.
	 */
	cancel_delayed_work(&req->work);

	req->callback(req->status, (struct sockaddr *)&req->src_addr,
		req->addr, req->context);
	put_client(req->client);
	kfree(req);
}
-----children-----
1,2
1,3
1,4
3,4
3,5
5,6
5,7
6,7
8,9
8,10
11,12
11,13
11,14
11,15
11,16
11,17
11,18
11,19
11,20
11,21
11,22
12,13
13,14
13,15
14,15
16,17
16,18
19,20
20,21
20,22
20,23
21,22
23,24
23,25
26,27
26,28
29,30
30,31
30,32
31,32
33,34
34,35
34,36
37,38
38,39
38,40
39,40
39,41
40,41
40,42
41,42
44,45
45,46
47,48
47,49
47,50
47,51
48,49
49,50
49,51
50,51
52,53
52,54
53,54
53,55
54,55
56,57
58,59
59,60
59,61
60,61
63,64
64,65
64,66
65,66
67,68
67,69
68,69
68,70
69,70
71,72
73,74
74,75
74,76
75,76
78,79
79,80
79,81
80,81
80,82
81,82
84,85
84,86
84,87
84,88
84,89
84,90
85,86
87,88
89,90
91,92
91,93
92,93
96,97
96,98
97,98
100,101
100,102
100,103
101,102
101,103
102,103
102,104
103,104
106,107
106,108
106,109
107,108
109,110
111,112
111,113
112,113
115,116
116,117
117,118
117,119
118,119
118,120
119,120
122,123
123,124
125,126
125,127
126,127
126,128
127,128
127,129
128,129
131,132
132,133
134,135
134,136
134,137
135,136
136,137
136,138
136,139
137,138
139,140
140,141
140,142
141,142
144,145
144,146
145,146
148,149
149,150
149,151
150,151
152,153
153,154
156,157
157,158
157,159
158,159
160,161
161,162
161,163
162,163
165,166
166,167
166,168
167,168
169,170
170,171
172,173
173,174
173,175
174,175
176,177
177,178
177,179
178,179
181,182
182,183
182,184
182,185
182,186
182,187
183,184
183,185
184,185
187,188
187,189
188,189
191,192
191,193
192,193
192,194
193,194
195,196
197,198
198,199
198,200
199,200
202,203
202,204
203,204
206,207
206,208
207,208
210,211
211,212
211,213
212,213
214,215
214,216
215,216
218,219
219,220
219,221
220,221
222,223
-----nextToken-----
2,4,7,9,10,15,17,18,22,24,25,27,28,32,35,36,42,43,46,51,55,57,61,62,66,70,72,76,77,82,83,86,88,90,93,94,95,98,99,104,105,108,110,113,114,120,121,124,129,130,133,138,142,143,146,147,151,154,155,159,163,164,168,171,175,179,180,185,186,189,190,194,196,200,201,204,205,208,209,213,216,217,221,223
-----computeFrom-----
39,40
39,41
49,50
49,51
64,65
64,66
79,80
79,81
101,102
101,103
117,118
117,119
126,127
126,128
-----guardedBy-----
46,133
42,146
43,130
113,120
105,121
129,146
-----guardedByNegation-----
114,147
113,146
105,130
-----lastLexicalUse-----
113,146
105,130
-----jump-----
113,146
105,130
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;ReferenceOperator;Name;ProblemStatement;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;Pointer;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;Pointer;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ReturnStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;CastExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;Pointer;UnaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;
-----ast_node-----
static void process_one_req(struct work_struct *_work){	struct addr_req *req;	struct sockaddr *src_in, *dst_in;	mutex_lock(&lock);	req = container_of(_work, struct addr_req, work.work);	if (req->status == -ENODATA) {		src_in = (struct sockaddr *)&req->src_addr;		dst_in = (struct sockaddr *)&req->dst_addr;		req->status = addr_resolve(src_in, dst_in, req->addr,					   true, req->seq);		if (req->status && time_after_eq(jiffies, req->timeout)) {			req->status = -ETIMEDOUT;		} else if (req->status == -ENODATA) {			/* requeue the work for retrying again */			set_timeout(&req->work, req->timeout);			mutex_unlock(&lock);			return;		}	}	list_del(&req->list);	mutex_unlock(&lock);	/*	 * Although the work will normally have been canceled by the	 * workqueue, it can still be requeued as long as it is on the	 * req_list, so it could have been requeued before we grabbed &lock.	 * We need to cancel it after it is removed from req_list to really be	 * sure it is safe to free.	 */	cancel_delayed_work(&req->work);	req->callback(req->status, (struct sockaddr *)&req->src_addr,		req->addr, req->context);	put_client(req->client);	kfree(req);}
static void
process_one_req(struct work_struct *_work)
process_one_req
struct work_struct *_work
struct work_struct
work_struct
*_work
*
_work
{	struct addr_req *req;	struct sockaddr *src_in, *dst_in;	mutex_lock(&lock);	req = container_of(_work, struct addr_req, work.work);	if (req->status == -ENODATA) {		src_in = (struct sockaddr *)&req->src_addr;		dst_in = (struct sockaddr *)&req->dst_addr;		req->status = addr_resolve(src_in, dst_in, req->addr,					   true, req->seq);		if (req->status && time_after_eq(jiffies, req->timeout)) {			req->status = -ETIMEDOUT;		} else if (req->status == -ENODATA) {			/* requeue the work for retrying again */			set_timeout(&req->work, req->timeout);			mutex_unlock(&lock);			return;		}	}	list_del(&req->list);	mutex_unlock(&lock);	/*	 * Although the work will normally have been canceled by the	 * workqueue, it can still be requeued as long as it is on the	 * req_list, so it could have been requeued before we grabbed &lock.	 * We need to cancel it after it is removed from req_list to really be	 * sure it is safe to free.	 */	cancel_delayed_work(&req->work);	req->callback(req->status, (struct sockaddr *)&req->src_addr,		req->addr, req->context);	put_client(req->client);	kfree(req);}
struct addr_req *req;
struct addr_req *req;
struct addr_req
addr_req
*req
*
req
struct sockaddr *src_in, *dst_in;
struct sockaddr *src_in, *dst_in;
struct sockaddr
sockaddr
*src_in
*
src_in
*dst_in
*
dst_in
mutex_lock(&lock);
mutex_lock(&lock);
mutex_lock
mutex_lock
(&lock)
&lock
&
lock
req = container_of(_work, struct addr_req, work.work);
if (req->status == -ENODATA) {		src_in = (struct sockaddr *)&req->src_addr;		dst_in = (struct sockaddr *)&req->dst_addr;		req->status = addr_resolve(src_in, dst_in, req->addr,					   true, req->seq);		if (req->status && time_after_eq(jiffies, req->timeout)) {			req->status = -ETIMEDOUT;		} else if (req->status == -ENODATA) {			/* requeue the work for retrying again */			set_timeout(&req->work, req->timeout);			mutex_unlock(&lock);			return;		}	}
req->status == -ENODATA
req->status
req
req
status
-ENODATA
ENODATA
ENODATA
{		src_in = (struct sockaddr *)&req->src_addr;		dst_in = (struct sockaddr *)&req->dst_addr;		req->status = addr_resolve(src_in, dst_in, req->addr,					   true, req->seq);		if (req->status && time_after_eq(jiffies, req->timeout)) {			req->status = -ETIMEDOUT;		} else if (req->status == -ENODATA) {			/* requeue the work for retrying again */			set_timeout(&req->work, req->timeout);			mutex_unlock(&lock);			return;		}	}
src_in = (struct sockaddr *)&req->src_addr;
src_in = (struct sockaddr *)&req->src_addr
src_in
src_in
(struct sockaddr *)&req->src_addr
struct sockaddr *
struct sockaddr
sockaddr
*
*
&req->src_addr
req->src_addr
req
req
src_addr
dst_in = (struct sockaddr *)&req->dst_addr;
dst_in = (struct sockaddr *)&req->dst_addr
dst_in
dst_in
(struct sockaddr *)&req->dst_addr
struct sockaddr *
struct sockaddr
sockaddr
*
*
&req->dst_addr
req->dst_addr
req
req
dst_addr
req->status = addr_resolve(src_in, dst_in, req->addr,					   true, req->seq);
req->status = addr_resolve(src_in, dst_in, req->addr,					   true, req->seq)
req->status
req
req
status
addr_resolve(src_in, dst_in, req->addr,					   true, req->seq)
addr_resolve
addr_resolve
src_in
src_in
dst_in
dst_in
req->addr
req
req
addr
true
req->seq
req
req
seq
if (req->status && time_after_eq(jiffies, req->timeout)) {			req->status = -ETIMEDOUT;		} else if (req->status == -ENODATA) {			/* requeue the work for retrying again */			set_timeout(&req->work, req->timeout);			mutex_unlock(&lock);			return;		}
req->status && time_after_eq(jiffies, req->timeout)
req->status
req
req
status
time_after_eq(jiffies, req->timeout)
time_after_eq
time_after_eq
jiffies
jiffies
req->timeout
req
req
timeout
{			req->status = -ETIMEDOUT;		}
req->status = -ETIMEDOUT;
req->status = -ETIMEDOUT
req->status
req
req
status
-ETIMEDOUT
ETIMEDOUT
ETIMEDOUT
if (req->status == -ENODATA) {			/* requeue the work for retrying again */			set_timeout(&req->work, req->timeout);			mutex_unlock(&lock);			return;		}
req->status == -ENODATA
req->status
req
req
status
-ENODATA
ENODATA
ENODATA
{			/* requeue the work for retrying again */			set_timeout(&req->work, req->timeout);			mutex_unlock(&lock);			return;		}
set_timeout(&req->work, req->timeout);
set_timeout(&req->work, req->timeout)
set_timeout
set_timeout
&req->work
req->work
req
req
work
req->timeout
req
req
timeout
mutex_unlock(&lock);
mutex_unlock(&lock)
mutex_unlock
mutex_unlock
&lock
lock
lock
return;
list_del(&req->list);
list_del(&req->list)
list_del
list_del
&req->list
req->list
req
req
list
mutex_unlock(&lock);
mutex_unlock(&lock)
mutex_unlock
mutex_unlock
&lock
lock
lock
cancel_delayed_work(&req->work);
cancel_delayed_work(&req->work)
cancel_delayed_work
cancel_delayed_work
&req->work
req->work
req
req
work
req->callback(req->status, (struct sockaddr *)&req->src_addr,		req->addr, req->context);
req->callback(req->status, (struct sockaddr *)&req->src_addr,		req->addr, req->context)
req->callback
req
req
callback
req->status
req
req
status
(struct sockaddr *)&req->src_addr
struct sockaddr *
struct sockaddr
sockaddr
*
*
&req->src_addr
req->src_addr
req
req
src_addr
req->addr
req
req
addr
req->context
req
req
context
put_client(req->client);
put_client(req->client)
put_client
put_client
req->client
req
req
client
kfree(req);
kfree(req)
kfree
kfree
req
req
-----joern-----
(14,99,0)
(91,0,0)
(34,89,0)
(112,44,0)
(71,91,0)
(21,42,0)
(42,21,0)
(8,84,0)
(100,98,0)
(75,45,0)
(17,80,0)
(84,0,0)
(13,2,0)
(44,80,0)
(25,35,0)
(23,62,0)
(14,104,0)
(90,99,0)
(93,96,0)
(60,99,0)
(83,48,0)
(1,99,0)
(101,34,0)
(35,112,0)
(66,10,0)
(33,74,0)
(78,91,0)
(42,2,0)
(24,77,0)
(39,99,0)
(58,84,0)
(76,96,0)
(61,76,0)
(49,44,0)
(53,19,0)
(36,15,0)
(84,14,0)
(44,43,0)
(69,21,0)
(96,76,0)
(77,52,0)
(26,107,0)
(115,41,0)
(97,106,0)
(112,19,0)
(44,112,0)
(98,10,0)
(85,11,0)
(111,97,0)
(89,34,0)
(12,48,0)
(87,111,0)
(104,14,0)
(80,44,0)
(54,44,0)
(1,52,0)
(14,111,0)
(64,38,0)
(105,44,0)
(41,19,0)
(103,107,0)
(62,112,0)
(43,19,0)
(73,99,0)
(47,114,0)
(10,98,0)
(0,92,0)
(74,33,0)
(83,99,0)
(37,74,0)
(106,97,0)
(116,106,0)
(14,84,0)
(81,39,0)
(60,79,0)
(81,57,0)
(28,99,0)
(98,100,0)
(86,62,0)
(32,7,0)
(26,89,0)
(0,31,0)
(4,72,0)
(26,72,0)
(20,73,0)
(100,43,0)
(100,59,0)
(57,81,0)
(29,99,0)
(18,106,0)
(43,100,0)
(73,20,0)
(95,7,0)
(33,114,0)
(67,79,0)
(52,77,0)
(97,111,0)
(68,45,0)
(110,77,0)
(114,33,0)
(44,38,0)
(79,60,0)
(88,114,0)
(25,76,0)
(3,102,0)
(84,112,0)
(51,99,0)
(46,35,0)
(111,14,0)
(9,72,0)
(2,112,0)
(94,113,0)
(70,104,0)
(15,103,0)
(102,14,0)
(76,25,0)
(55,10,0)
(16,38,0)
(30,34,0)
(103,15,0)
(111,87,0)
(108,57,0)
(52,1,0)
(92,0,0)
(74,41,0)
(109,35,0)
(113,99,0)
(44,41,0)
(48,83,0)
(7,32,0)
(63,2,0)
(11,107,0)
(27,43,0)
(74,37,0)
(50,80,0)
(32,45,0)
(89,26,0)
(45,32,0)
(38,44,0)
(59,100,0)
(22,20,0)
(6,92,0)
(5,96,0)
(14,102,0)
(39,81,0)
(82,102,0)
(56,57,0)
(41,74,0)
(35,25,0)
(65,104,0)
(2,42,0)
(40,79,0)
(72,26,0)
(106,116,1)
(24,83,1)
(52,77,1)
(74,37,1)
(7,95,1)
(84,112,1)
(5,61,1)
(57,108,1)
(2,63,1)
(3,82,1)
(35,109,1)
(26,89,1)
(84,8,1)
(77,110,1)
(32,7,1)
(36,26,1)
(12,39,1)
(13,25,1)
(44,38,1)
(88,115,1)
(70,111,1)
(44,41,1)
(80,50,1)
(58,1,1)
(63,13,1)
(69,2,1)
(25,35,1)
(8,58,1)
(18,84,1)
(100,59,1)
(62,86,1)
(96,93,1)
(111,97,1)
(114,47,1)
(100,98,1)
(54,49,1)
(44,43,1)
(108,56,1)
(21,69,1)
(113,94,1)
(78,71,1)
(2,112,1)
(42,21,1)
(105,38,1)
(89,34,1)
(66,27,1)
(109,46,1)
(94,60,1)
(85,11,1)
(0,92,1)
(82,104,1)
(60,79,1)
(104,65,1)
(86,23,1)
(103,15,1)
(45,75,1)
(16,64,1)
(97,106,1)
(38,16,1)
(56,32,1)
(93,5,1)
(112,44,1)
(14,104,1)
(14,102,1)
(27,41,1)
(75,68,1)
(98,10,1)
(49,62,1)
(43,100,1)
(34,30,1)
(32,45,1)
(26,72,1)
(71,25,1)
(25,76,1)
(56,42,1)
(115,32,1)
(47,88,1)
(92,6,1)
(116,18,1)
(64,54,1)
(73,20,1)
(102,3,1)
(14,111,1)
(10,55,1)
(68,73,1)
(101,42,1)
(91,78,1)
(85,113,1)
(76,96,1)
(44,80,1)
(9,4,1)
(40,14,1)
(20,22,1)
(84,0,1)
(67,40,1)
(39,81,1)
(79,67,1)
(61,35,1)
(48,12,1)
(95,45,1)
(110,24,1)
(6,91,1)
(14,84,1)
(15,36,1)
(81,57,1)
(17,105,1)
(41,74,1)
(11,103,1)
(30,101,1)
(65,70,1)
(42,2,1)
(23,43,1)
(50,17,1)
(46,112,1)
(72,9,1)
(111,87,1)
(74,33,1)
(56,0,1)
(35,112,1)
(83,48,1)
(1,52,1)
(33,114,1)
(4,89,1)
(55,66,1)
(98,10,2)
(12,42,2)
(106,25,2)
(14,25,2)
(58,42,2)
(83,42,2)
(54,32,2)
(42,2,2)
(110,42,2)
(39,25,2)
(5,35,2)
(58,25,2)
(74,37,2)
(27,32,2)
(112,32,2)
(52,25,2)
(56,42,2)
(111,42,2)
(111,97,2)
(42,21,2)
(14,84,2)
(16,32,2)
(103,15,2)
(63,25,2)
(8,42,2)
(44,38,2)
(44,80,2)
(66,32,2)
(100,98,2)
(3,32,2)
(78,25,2)
(82,25,2)
(116,32,2)
(2,112,2)
(32,7,2)
(113,25,2)
(97,42,2)
(25,76,2)
(108,42,2)
(26,89,2)
(9,42,2)
(39,42,2)
(0,25,2)
(89,34,2)
(1,25,2)
(103,42,2)
(38,32,2)
(34,42,2)
(32,45,2)
(25,32,2)
(110,32,2)
(100,59,2)
(61,35,2)
(105,32,2)
(111,25,2)
(81,25,2)
(2,25,2)
(44,41,2)
(46,32,2)
(60,32,2)
(74,33,2)
(58,32,2)
(14,111,2)
(67,25,2)
(15,42,2)
(88,32,2)
(108,32,2)
(12,32,2)
(97,32,2)
(83,25,2)
(57,25,2)
(77,42,2)
(83,48,2)
(48,25,2)
(47,32,2)
(113,42,2)
(13,25,2)
(69,25,2)
(81,57,2)
(33,32,2)
(82,42,2)
(106,32,2)
(65,42,2)
(43,32,2)
(65,25,2)
(41,32,2)
(33,114,2)
(81,32,2)
(70,32,2)
(92,25,2)
(44,43,2)
(104,25,2)
(83,32,2)
(102,32,2)
(73,20,2)
(104,32,2)
(60,25,2)
(94,42,2)
(60,42,2)
(25,35,2)
(111,32,2)
(76,35,2)
(115,32,2)
(1,42,2)
(96,35,2)
(70,25,2)
(94,25,2)
(79,25,2)
(84,42,2)
(102,42,2)
(52,32,2)
(113,32,2)
(39,81,2)
(35,32,2)
(79,42,2)
(56,32,2)
(24,42,2)
(55,32,2)
(36,42,2)
(108,25,2)
(35,112,2)
(0,92,2)
(109,32,2)
(12,25,2)
(23,32,2)
(81,42,2)
(26,42,2)
(89,42,2)
(101,42,2)
(100,32,2)
(50,32,2)
(24,25,2)
(30,42,2)
(77,32,2)
(57,32,2)
(64,32,2)
(18,32,2)
(85,11,2)
(86,32,2)
(116,25,2)
(21,25,2)
(84,0,2)
(77,25,2)
(111,87,2)
(112,44,2)
(6,25,2)
(24,32,2)
(48,42,2)
(106,42,2)
(14,102,2)
(3,25,2)
(67,42,2)
(40,42,2)
(8,25,2)
(65,32,2)
(40,32,2)
(40,25,2)
(62,32,2)
(82,32,2)
(1,32,2)
(52,42,2)
(76,96,2)
(80,32,2)
(14,42,2)
(67,32,2)
(102,25,2)
(97,25,2)
(18,42,2)
(52,77,2)
(39,32,2)
(114,32,2)
(93,35,2)
(17,32,2)
(41,74,2)
(10,32,2)
(84,112,2)
(14,104,2)
(70,42,2)
(1,52,2)
(26,72,2)
(98,32,2)
(18,25,2)
(94,32,2)
(91,25,2)
(84,32,2)
(14,32,2)
(79,32,2)
(8,32,2)
(3,42,2)
(72,42,2)
(116,42,2)
(44,32,2)
(56,25,2)
(97,106,2)
(110,25,2)
(84,25,2)
(4,42,2)
(104,42,2)
(49,32,2)
(43,100,2)
(71,25,2)
(11,42,2)
(60,79,2)
(74,32,2)
(57,42,2)
(48,32,2)
(42,25,2)
-----------------------------------
(0,req->status = -ETIMEDOUT)
(1,cancel_delayed_work(&req->work)
(2,req->status)
(3,context)
(4,req)
(5,req)
(6,ETIMEDOUT)
(7,-ENODATA)
(8,status)
(9,timeout)
(10,req->dst_addr)
(11,return;)
(12,lock)
(13,req)
(14,req->callback(req->status, (struct sockaddr *)
(15,&lock)
(16,addr)
(17,req)
(18,req)
(19,)
(20,&lock)
(21,-ENODATA)
(22,lock)
(23,req)
(24,req)
(25,req->status && time_after_eq(jiffies, req->timeout)
(26,set_timeout(&req->work, req->timeout)
(27,dst_in)
(28,dst_in)
(29,src_in)
(30,work)
(31,)
(32,req->status == -ENODATA)
(33,&req->src_addr)
(34,req->work)
(35,req->status)
(36,lock)
(37,struct sockaddr *)
(38,req->addr)
(39,list_del(&req->list)
(40,req)
(41,src_in = (struct sockaddr *)
(42,req->status == -ENODATA)
(43,dst_in = (struct sockaddr *)
(44,addr_resolve(src_in, dst_in, req->addr,\n\\n\\t\\t\\t\\t\\t   true, req->seq)
(45,req->status)
(46,req)
(47,src_addr)
(48,&lock)
(49,src_in)
(50,seq)
(51,if (req->status == -ENODATA)
(52,&req->work)
(53,if (req->status && time_after_eq(jiffies, req->timeout)
(54,dst_in)
(55,dst_addr)
(56,req)
(57,req->list)
(58,req)
(59,struct sockaddr *)
(60,put_client(req->client)
(61,jiffies)
(62,req->status)
(63,status)
(64,req)
(65,addr)
(66,req)
(67,client)
(68,req)
(69,ENODATA)
(70,req)
(71,req)
(72,req->timeout)
(73,mutex_lock(&lock)
(74,(struct sockaddr *)
(75,status)
(76,time_after_eq(jiffies, req->timeout)
(77,req->work)
(78,status)
(79,req->client)
(80,req->seq)
(81,&req->list)
(82,req)
(83,mutex_unlock(&lock)
(84,req->status)
(85,RET)
(86,status)
(87,struct sockaddr *)
(88,req)
(89,&req->work)
(90,req)
(91,req->status)
(92,-ETIMEDOUT)
(93,timeout)
(94,req)
(95,ENODATA)
(96,req->timeout)
(97,&req->src_addr)
(98,&req->dst_addr)
(99,)
(100,(struct sockaddr *)
(101,req)
(102,req->context)
(103,mutex_unlock(&lock)
(104,req->addr)
(105,true)
(106,req->src_addr)
(107,)
(108,list)
(109,status)
(110,work)
(111,(struct sockaddr *)
(112,req->status = addr_resolve(src_in, dst_in, req->addr,\n\\n\\t\\t\\t\\t\\t   true, req->seq)
(113,kfree(req)
(114,req->src_addr)
(115,src_in)
(116,src_addr)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^