-----label-----
1
-----code-----
int hdd_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
{
   VOS_STATUS status;
   WLANTL_ACEnumType ac;
   sme_QosWmmUpType up;
   skb_list_node_t *pktNode = NULL;
   hdd_list_node_t *anchor = NULL;
   v_SIZE_t pktListSize = 0;
   hdd_adapter_t *pAdapter =  WLAN_HDD_GET_PRIV_PTR(dev);
   v_BOOL_t granted;

   hdd_station_ctx_t *pHddStaCtx = &pAdapter->sessionCtx.station;

   v_BOOL_t txSuspended = VOS_FALSE;

   ++pAdapter->hdd_stats.hddTxRxStats.txXmitCalled;

   if (unlikely(netif_queue_stopped(dev))) {
       VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
                  "%s is called when netif TX is disabled", __func__);
       return NETDEV_TX_BUSY;
   }

   //Get TL AC corresponding to Qdisc queue index/AC.
   ac = hdd_QdiscAcToTlAC[skb->queue_mapping];

   //user priority from IP header, which is already extracted and set from
   //select_queue call back function
   up = skb->priority;

   ++pAdapter->hdd_stats.hddTxRxStats.txXmitClassifiedAC[ac];

#ifdef HDD_WMM_DEBUG
   VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
              "%s: Classified as ac %d up %d", __func__, ac, up);
#endif // HDD_WMM_DEBUG

   spin_lock(&pAdapter->wmm_tx_queue[ac].lock);
   /*CR 463598,384996*/
   /*For every increment of 10 pkts in the queue, we inform TL about pending pkts.
    *We check for +1 in the logic,to take care of Zero count which
    *occurs very frequently in low traffic cases */
   if((pAdapter->wmm_tx_queue[ac].count + 1) % 10 == 0)
   {
           /* Use the following debug statement during Engineering Debugging.There are chance that this will lead to a Watchdog Bark
            * if it is in the mainline code and if the log level is enabled by someone for debugging
           VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,"%s:Queue is Filling up.Inform TL again about pending packets", __func__);*/
           WLANTL_STAPktPending( (WLAN_HDD_GET_CTX(pAdapter))->pvosContext, pHddStaCtx->conn_info.staId[0], ac );
   }
   //If we have already reached the max queue size, disable the TX queue
   if ( pAdapter->wmm_tx_queue[ac].count == pAdapter->wmm_tx_queue[ac].max_size)
   {
      ++pAdapter->hdd_stats.hddTxRxStats.txXmitBackPressured;
      ++pAdapter->hdd_stats.hddTxRxStats.txXmitBackPressuredAC[ac];

      netif_tx_stop_queue(netdev_get_tx_queue(dev, skb_get_queue_mapping(skb)));
      pAdapter->isTxSuspended[ac] = VOS_TRUE;
      txSuspended = VOS_TRUE;
   }

   spin_unlock(&pAdapter->wmm_tx_queue[ac].lock);
   if (VOS_TRUE == txSuspended)
   {
       VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
                  "%s: TX queue full for AC=%d Disable OS TX queue",
                  __func__, ac );
      return NETDEV_TX_BUSY;
   }

   //Use the skb->cb field to hold the list node information
   pktNode = (skb_list_node_t *)&skb->cb;

   //Stick the OS packet inside this node.
   pktNode->skb = skb;

   //Stick the User Priority inside this node
   pktNode->userPriority = up;


   INIT_LIST_HEAD(&pktNode->anchor);

   //Insert the OS packet into the appropriate AC queue
   spin_lock(&pAdapter->wmm_tx_queue[ac].lock);
   status = hdd_list_insert_back_size( &pAdapter->wmm_tx_queue[ac], &pktNode->anchor, &pktListSize );
   spin_unlock(&pAdapter->wmm_tx_queue[ac].lock);

   if ( !VOS_IS_STATUS_SUCCESS( status ) )
   {
      VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_WARN,"%s:Insert Tx queue failed. Pkt dropped", __func__);
      ++pAdapter->hdd_stats.hddTxRxStats.txXmitDropped;
      ++pAdapter->hdd_stats.hddTxRxStats.txXmitDroppedAC[ac];
      ++pAdapter->stats.tx_dropped;
      kfree_skb(skb);
      return NETDEV_TX_OK;
   }

   ++pAdapter->hdd_stats.hddTxRxStats.txXmitQueued;
   ++pAdapter->hdd_stats.hddTxRxStats.txXmitQueuedAC[ac];

   //Make sure we have access to this access category
   if (likely(pAdapter->hddWmmStatus.wmmAcStatus[ac].wmmAcAccessAllowed) ||
           ( pHddStaCtx->conn_info.uIsAuthenticated == VOS_FALSE))
   {
      granted = VOS_TRUE;
   }
   else
   {
      status = hdd_wmm_acquire_access( pAdapter, ac, &granted );
   }

   if ( granted && ( pktListSize == 1 ))
   {
      //Let TL know we have a packet to send for this AC
      //VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,"%s:Indicating Packet to TL", __func__);
      status = WLANTL_STAPktPending( (WLAN_HDD_GET_CTX(pAdapter))->pvosContext, pHddStaCtx->conn_info.staId[0], ac );

      if ( !VOS_IS_STATUS_SUCCESS( status ) )
      {
         VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_WARN, "%s: Failed to signal TL for AC=%d", __func__, ac );

         //Remove the packet from queue. It must be at the back of the queue, as TX thread cannot preempt us in the middle
         //as we are in a soft irq context. Also it must be the same packet that we just allocated.
         spin_lock(&pAdapter->wmm_tx_queue[ac].lock);
         status = hdd_list_remove_back( &pAdapter->wmm_tx_queue[ac], &anchor );
         spin_unlock(&pAdapter->wmm_tx_queue[ac].lock);
         ++pAdapter->stats.tx_dropped;
         ++pAdapter->hdd_stats.hddTxRxStats.txXmitDropped;
         ++pAdapter->hdd_stats.hddTxRxStats.txXmitDroppedAC[ac];
         kfree_skb(skb);
         return NETDEV_TX_OK;
      }
   }

   dev->trans_start = jiffies;

   return NETDEV_TX_OK;
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
5,6
5,7
6,7
8,9
8,10
11,12
11,13
12,13
14,15
14,16
17,18
17,19
17,20
17,21
17,22
17,23
17,24
17,25
17,26
17,27
17,28
17,29
17,30
17,31
17,32
17,33
17,34
17,35
17,36
17,37
17,38
17,39
17,40
17,41
17,42
17,43
17,44
17,45
17,46
17,47
17,48
17,49
17,50
17,51
18,19
19,20
19,21
20,21
22,23
24,25
25,26
25,27
26,27
28,29
30,31
31,32
31,33
32,33
34,35
36,37
37,38
37,39
38,39
40,41
40,42
40,43
43,44
44,45
46,47
47,48
47,49
48,49
50,51
50,52
50,53
53,54
54,55
56,57
57,58
57,59
58,59
60,61
60,62
62,63
64,65
65,66
65,67
66,67
68,69
68,70
68,71
71,72
72,73
72,74
73,74
75,76
77,78
78,79
78,80
79,80
81,82
83,84
84,85
84,86
85,86
87,88
87,89
87,90
90,91
91,92
92,93
92,94
93,94
93,95
94,95
98,99
99,100
99,101
100,101
102,103
102,104
104,105
105,106
107,108
108,109
109,110
109,111
110,111
110,112
111,112
111,113
112,113
117,118
117,119
118,119
118,120
119,120
121,122
121,123
122,123
124,125
126,127
126,128
127,128
128,129
128,130
128,131
128,132
128,133
129,130
131,132
133,134
136,137
138,139
139,140
141,142
142,143
142,144
143,144
145,146
145,147
146,147
148,149
148,150
149,150
152,153
153,154
153,155
154,155
156,157
156,158
157,158
160,161
161,162
162,163
162,164
163,164
163,165
164,165
164,166
165,166
165,167
166,167
171,172
173,174
174,175
174,176
175,176
177,178
178,179
178,180
179,180
179,181
180,181
180,182
181,182
184,185
187,188
187,189
188,189
188,190
189,190
189,191
190,191
191,192
191,193
192,193
192,194
193,194
193,195
194,195
194,196
195,196
198,199
204,205
205,206
206,207
206,208
206,209
206,210
207,208
209,210
209,211
210,211
211,212
211,213
212,213
214,215
217,218
217,219
218,219
218,220
219,220
219,221
220,221
225,226
227,228
227,229
228,229
228,230
229,230
229,231
230,231
230,232
231,232
231,233
232,233
235,236
238,239
238,240
239,240
239,241
240,241
240,242
241,242
244,245
247,248
247,249
247,250
247,251
247,252
248,249
249,250
250,251
250,252
251,252
251,253
252,253
252,254
253,254
258,259
259,260
260,261
260,262
261,262
261,263
262,263
262,264
263,264
263,265
264,265
269,270
271,272
272,273
272,274
273,274
275,276
275,277
275,278
276,277
278,279
280,281
280,282
281,282
283,284
285,286
286,287
286,288
287,288
287,289
288,289
288,290
289,290
292,293
294,295
296,297
297,298
297,299
298,299
300,301
302,303
303,304
303,305
304,305
306,307
307,308
307,309
308,309
308,310
309,310
309,311
310,311
313,314
316,317
316,318
317,318
317,319
318,319
320,321
322,323
322,324
323,324
324,325
324,326
324,327
324,328
324,329
324,330
325,326
327,328
329,330
332,333
334,335
336,337
337,338
339,340
340,341
340,342
341,342
343,344
343,345
344,345
344,346
345,346
347,348
349,350
350,351
350,352
351,352
354,355
355,356
355,357
356,357
356,358
357,358
360,361
362,363
363,364
363,365
364,365
364,366
365,366
368,369
370,371
371,372
371,373
372,373
374,375
375,376
375,377
376,377
379,380
380,381
380,382
381,382
383,384
384,385
384,386
385,386
385,387
386,387
386,388
387,388
390,391
393,394
394,395
394,396
395,396
397,398
397,399
397,400
397,401
398,399
400,401
401,402
401,403
402,403
402,404
403,404
406,407
408,409
409,410
409,411
410,411
413,414
414,415
416,417
417,418
417,419
418,419
420,421
421,422
421,423
422,423
422,424
423,424
423,425
424,425
427,428
430,431
430,432
431,432
432,433
432,434
433,434
435,436
437,438
437,439
437,440
437,441
437,442
437,443
438,439
439,440
439,441
439,442
439,443
439,444
440,441
442,443
444,445
447,448
449,450
450,451
451,452
451,453
452,453
452,454
453,454
453,455
454,455
459,460
460,461
461,462
461,463
462,463
462,464
463,464
463,465
464,465
464,466
465,466
470,471
472,473
473,474
474,475
474,476
475,476
475,477
476,477
480,481
481,482
481,483
482,483
484,485
486,487
487,488
489,490
490,491
491,492
491,493
492,493
492,494
493,494
493,495
494,495
499,500
500,501
501,502
501,503
502,503
502,504
503,504
503,505
504,505
504,506
505,506
510,511
512,513
512,514
512,515
513,514
513,515
514,515
514,516
515,516
517,518
517,519
518,519
518,520
519,520
519,521
520,521
520,522
521,522
525,526
528,529
529,530
529,531
530,531
530,532
531,532
531,533
532,533
536,537
538,539
539,540
540,541
540,542
541,542
543,544
545,546
546,547
547,548
547,549
548,549
550,551
550,552
550,553
550,554
551,552
553,554
555,556
557,558
558,559
560,561
560,562
561,562
561,563
562,563
564,565
565,566
565,567
566,567
569,570
569,571
570,571
571,572
571,573
572,573
574,575
574,576
574,577
574,578
575,576
577,578
577,579
578,579
579,580
579,581
580,581
582,583
585,586
585,587
586,587
586,588
587,588
587,589
588,589
593,594
595,596
595,597
596,597
597,598
597,599
598,599
600,601
602,603
602,604
602,605
602,606
602,607
602,608
602,609
602,610
602,611
603,604
604,605
604,606
604,607
604,608
604,609
604,610
605,606
607,608
609,610
612,613
614,615
616,617
617,618
617,619
618,619
620,621
621,622
621,623
622,623
622,624
623,624
623,625
624,625
627,628
630,631
631,632
631,633
632,633
634,635
634,636
634,637
635,636
637,638
638,639
638,640
639,640
639,641
640,641
643,644
645,646
646,647
648,649
649,650
649,651
650,651
652,653
653,654
653,655
654,655
654,656
655,656
655,657
656,657
659,660
662,663
663,664
664,665
664,666
665,666
665,667
666,667
670,671
671,672
672,673
672,674
673,674
673,675
674,675
674,676
675,676
680,681
681,682
682,683
682,684
683,684
683,685
684,685
684,686
685,686
685,687
686,687
691,692
693,694
694,695
694,696
695,696
697,698
699,700
700,701
702,703
703,704
703,705
704,705
704,706
705,706
708,709
710,711
711,712
-----nextToken-----
2,4,7,9,10,13,15,16,21,23,27,29,33,35,39,41,42,45,49,51,52,55,59,61,63,67,69,70,74,76,80,82,86,88,89,95,96,97,101,103,106,113,114,115,116,120,123,125,130,132,134,135,137,140,144,147,150,151,155,158,159,167,168,169,170,172,176,182,183,185,186,196,197,199,200,201,202,203,208,213,215,216,221,222,223,224,226,233,234,236,237,242,243,245,246,254,255,256,257,265,266,267,268,270,274,277,279,282,284,290,291,293,295,299,301,305,311,312,314,315,319,321,326,328,330,331,333,335,338,342,346,348,352,353,358,359,361,366,367,369,373,377,378,382,388,389,391,392,396,399,404,405,407,411,412,415,419,425,426,428,429,434,436,441,443,445,446,448,455,456,457,458,466,467,468,469,471,477,478,479,483,485,488,495,496,497,498,506,507,508,509,511,516,522,523,524,526,527,533,534,535,537,542,544,549,552,554,556,559,563,567,568,573,576,581,583,584,589,590,591,592,594,599,601,606,608,610,611,613,615,619,625,626,628,629,633,636,641,642,644,647,651,657,658,660,661,667,668,669,676,677,678,679,687,688,689,690,692,696,698,701,706,707,709,712
-----computeFrom-----
142,143
142,144
153,154
153,155
188,189
188,190
189,190
189,191
191,192
191,193
228,229
228,230
286,287
286,288
297,298
297,299
317,318
317,319
340,341
340,342
355,356
355,357
363,364
363,365
394,395
394,396
513,514
513,515
529,530
529,531
540,541
540,542
547,548
547,549
561,562
561,563
565,566
565,567
571,572
571,573
631,632
631,633
703,704
703,705
-----guardedBy-----
199,226
196,215
245,293
242,290
-----guardedByNegation-----
526,556
522,554
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;IdExpression;Name;ExpressionStatement;UnaryExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;IfStatement;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;ReturnStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;UnaryExpression;ArraySubscriptExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;Name;IfStatement;BinaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;Name;LiteralExpression;LiteralExpression;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;Name;ArraySubscriptExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;Name;FieldReference;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;UnaryExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;ExpressionStatement;UnaryExpression;ArraySubscriptExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;Pointer;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;UnaryExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;ExpressionStatement;UnaryExpression;ArraySubscriptExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;IdExpression;Name;ExpressionStatement;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;IdExpression;Name;ExpressionStatement;UnaryExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;ExpressionStatement;UnaryExpression;ArraySubscriptExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;Name;ArraySubscriptExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;Name;ExpressionStatement;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;UnaryExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;ExpressionStatement;UnaryExpression;ArraySubscriptExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ReturnStatement;IdExpression;Name;
-----ast_node-----
int hdd_hard_start_xmit(struct sk_buff *skb, struct net_device *dev){   VOS_STATUS status;   WLANTL_ACEnumType ac;   sme_QosWmmUpType up;   skb_list_node_t *pktNode = NULL;   hdd_list_node_t *anchor = NULL;   v_SIZE_t pktListSize = 0;   hdd_adapter_t *pAdapter =  WLAN_HDD_GET_PRIV_PTR(dev);   v_BOOL_t granted;   hdd_station_ctx_t *pHddStaCtx = &pAdapter->sessionCtx.station;   v_BOOL_t txSuspended = VOS_FALSE;   ++pAdapter->hdd_stats.hddTxRxStats.txXmitCalled;   if (unlikely(netif_queue_stopped(dev))) {       VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,                  "%s is called when netif TX is disabled", __func__);       return NETDEV_TX_BUSY;   }   //Get TL AC corresponding to Qdisc queue index/AC.   ac = hdd_QdiscAcToTlAC[skb->queue_mapping];   //user priority from IP header, which is already extracted and set from   //select_queue call back function   up = skb->priority;   ++pAdapter->hdd_stats.hddTxRxStats.txXmitClassifiedAC[ac];#ifdef HDD_WMM_DEBUG   VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,              "%s: Classified as ac %d up %d", __func__, ac, up);#endif // HDD_WMM_DEBUG   spin_lock(&pAdapter->wmm_tx_queue[ac].lock);   /*CR 463598,384996*/   /*For every increment of 10 pkts in the queue, we inform TL about pending pkts.    *We check for +1 in the logic,to take care of Zero count which    *occurs very frequently in low traffic cases */   if((pAdapter->wmm_tx_queue[ac].count + 1) % 10 == 0)   {           /* Use the following debug statement during Engineering Debugging.There are chance that this will lead to a Watchdog Bark            * if it is in the mainline code and if the log level is enabled by someone for debugging           VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,"%s:Queue is Filling up.Inform TL again about pending packets", __func__);*/           WLANTL_STAPktPending( (WLAN_HDD_GET_CTX(pAdapter))->pvosContext, pHddStaCtx->conn_info.staId[0], ac );   }   //If we have already reached the max queue size, disable the TX queue   if ( pAdapter->wmm_tx_queue[ac].count == pAdapter->wmm_tx_queue[ac].max_size)   {      ++pAdapter->hdd_stats.hddTxRxStats.txXmitBackPressured;      ++pAdapter->hdd_stats.hddTxRxStats.txXmitBackPressuredAC[ac];      netif_tx_stop_queue(netdev_get_tx_queue(dev, skb_get_queue_mapping(skb)));      pAdapter->isTxSuspended[ac] = VOS_TRUE;      txSuspended = VOS_TRUE;   }   spin_unlock(&pAdapter->wmm_tx_queue[ac].lock);   if (VOS_TRUE == txSuspended)   {       VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,                  "%s: TX queue full for AC=%d Disable OS TX queue",                  __func__, ac );      return NETDEV_TX_BUSY;   }   //Use the skb->cb field to hold the list node information   pktNode = (skb_list_node_t *)&skb->cb;   //Stick the OS packet inside this node.   pktNode->skb = skb;   //Stick the User Priority inside this node   pktNode->userPriority = up;   INIT_LIST_HEAD(&pktNode->anchor);   //Insert the OS packet into the appropriate AC queue   spin_lock(&pAdapter->wmm_tx_queue[ac].lock);   status = hdd_list_insert_back_size( &pAdapter->wmm_tx_queue[ac], &pktNode->anchor, &pktListSize );   spin_unlock(&pAdapter->wmm_tx_queue[ac].lock);   if ( !VOS_IS_STATUS_SUCCESS( status ) )   {      VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_WARN,"%s:Insert Tx queue failed. Pkt dropped", __func__);      ++pAdapter->hdd_stats.hddTxRxStats.txXmitDropped;      ++pAdapter->hdd_stats.hddTxRxStats.txXmitDroppedAC[ac];      ++pAdapter->stats.tx_dropped;      kfree_skb(skb);      return NETDEV_TX_OK;   }   ++pAdapter->hdd_stats.hddTxRxStats.txXmitQueued;   ++pAdapter->hdd_stats.hddTxRxStats.txXmitQueuedAC[ac];   //Make sure we have access to this access category   if (likely(pAdapter->hddWmmStatus.wmmAcStatus[ac].wmmAcAccessAllowed) ||           ( pHddStaCtx->conn_info.uIsAuthenticated == VOS_FALSE))   {      granted = VOS_TRUE;   }   else   {      status = hdd_wmm_acquire_access( pAdapter, ac, &granted );   }   if ( granted && ( pktListSize == 1 ))   {      //Let TL know we have a packet to send for this AC      //VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,"%s:Indicating Packet to TL", __func__);      status = WLANTL_STAPktPending( (WLAN_HDD_GET_CTX(pAdapter))->pvosContext, pHddStaCtx->conn_info.staId[0], ac );      if ( !VOS_IS_STATUS_SUCCESS( status ) )      {         VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_WARN, "%s: Failed to signal TL for AC=%d", __func__, ac );         //Remove the packet from queue. It must be at the back of the queue, as TX thread cannot preempt us in the middle         //as we are in a soft irq context. Also it must be the same packet that we just allocated.         spin_lock(&pAdapter->wmm_tx_queue[ac].lock);         status = hdd_list_remove_back( &pAdapter->wmm_tx_queue[ac], &anchor );         spin_unlock(&pAdapter->wmm_tx_queue[ac].lock);         ++pAdapter->stats.tx_dropped;         ++pAdapter->hdd_stats.hddTxRxStats.txXmitDropped;         ++pAdapter->hdd_stats.hddTxRxStats.txXmitDroppedAC[ac];         kfree_skb(skb);         return NETDEV_TX_OK;      }   }   dev->trans_start = jiffies;   return NETDEV_TX_OK;}
int
hdd_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
hdd_hard_start_xmit
struct sk_buff *skb
struct sk_buff
sk_buff
*skb
*
skb
struct net_device *dev
struct net_device
net_device
*dev
*
dev
{   VOS_STATUS status;   WLANTL_ACEnumType ac;   sme_QosWmmUpType up;   skb_list_node_t *pktNode = NULL;   hdd_list_node_t *anchor = NULL;   v_SIZE_t pktListSize = 0;   hdd_adapter_t *pAdapter =  WLAN_HDD_GET_PRIV_PTR(dev);   v_BOOL_t granted;   hdd_station_ctx_t *pHddStaCtx = &pAdapter->sessionCtx.station;   v_BOOL_t txSuspended = VOS_FALSE;   ++pAdapter->hdd_stats.hddTxRxStats.txXmitCalled;   if (unlikely(netif_queue_stopped(dev))) {       VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,                  "%s is called when netif TX is disabled", __func__);       return NETDEV_TX_BUSY;   }   //Get TL AC corresponding to Qdisc queue index/AC.   ac = hdd_QdiscAcToTlAC[skb->queue_mapping];   //user priority from IP header, which is already extracted and set from   //select_queue call back function   up = skb->priority;   ++pAdapter->hdd_stats.hddTxRxStats.txXmitClassifiedAC[ac];#ifdef HDD_WMM_DEBUG   VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,              "%s: Classified as ac %d up %d", __func__, ac, up);#endif // HDD_WMM_DEBUG   spin_lock(&pAdapter->wmm_tx_queue[ac].lock);   /*CR 463598,384996*/   /*For every increment of 10 pkts in the queue, we inform TL about pending pkts.    *We check for +1 in the logic,to take care of Zero count which    *occurs very frequently in low traffic cases */   if((pAdapter->wmm_tx_queue[ac].count + 1) % 10 == 0)   {           /* Use the following debug statement during Engineering Debugging.There are chance that this will lead to a Watchdog Bark            * if it is in the mainline code and if the log level is enabled by someone for debugging           VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,"%s:Queue is Filling up.Inform TL again about pending packets", __func__);*/           WLANTL_STAPktPending( (WLAN_HDD_GET_CTX(pAdapter))->pvosContext, pHddStaCtx->conn_info.staId[0], ac );   }   //If we have already reached the max queue size, disable the TX queue   if ( pAdapter->wmm_tx_queue[ac].count == pAdapter->wmm_tx_queue[ac].max_size)   {      ++pAdapter->hdd_stats.hddTxRxStats.txXmitBackPressured;      ++pAdapter->hdd_stats.hddTxRxStats.txXmitBackPressuredAC[ac];      netif_tx_stop_queue(netdev_get_tx_queue(dev, skb_get_queue_mapping(skb)));      pAdapter->isTxSuspended[ac] = VOS_TRUE;      txSuspended = VOS_TRUE;   }   spin_unlock(&pAdapter->wmm_tx_queue[ac].lock);   if (VOS_TRUE == txSuspended)   {       VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,                  "%s: TX queue full for AC=%d Disable OS TX queue",                  __func__, ac );      return NETDEV_TX_BUSY;   }   //Use the skb->cb field to hold the list node information   pktNode = (skb_list_node_t *)&skb->cb;   //Stick the OS packet inside this node.   pktNode->skb = skb;   //Stick the User Priority inside this node   pktNode->userPriority = up;   INIT_LIST_HEAD(&pktNode->anchor);   //Insert the OS packet into the appropriate AC queue   spin_lock(&pAdapter->wmm_tx_queue[ac].lock);   status = hdd_list_insert_back_size( &pAdapter->wmm_tx_queue[ac], &pktNode->anchor, &pktListSize );   spin_unlock(&pAdapter->wmm_tx_queue[ac].lock);   if ( !VOS_IS_STATUS_SUCCESS( status ) )   {      VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_WARN,"%s:Insert Tx queue failed. Pkt dropped", __func__);      ++pAdapter->hdd_stats.hddTxRxStats.txXmitDropped;      ++pAdapter->hdd_stats.hddTxRxStats.txXmitDroppedAC[ac];      ++pAdapter->stats.tx_dropped;      kfree_skb(skb);      return NETDEV_TX_OK;   }   ++pAdapter->hdd_stats.hddTxRxStats.txXmitQueued;   ++pAdapter->hdd_stats.hddTxRxStats.txXmitQueuedAC[ac];   //Make sure we have access to this access category   if (likely(pAdapter->hddWmmStatus.wmmAcStatus[ac].wmmAcAccessAllowed) ||           ( pHddStaCtx->conn_info.uIsAuthenticated == VOS_FALSE))   {      granted = VOS_TRUE;   }   else   {      status = hdd_wmm_acquire_access( pAdapter, ac, &granted );   }   if ( granted && ( pktListSize == 1 ))   {      //Let TL know we have a packet to send for this AC      //VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,"%s:Indicating Packet to TL", __func__);      status = WLANTL_STAPktPending( (WLAN_HDD_GET_CTX(pAdapter))->pvosContext, pHddStaCtx->conn_info.staId[0], ac );      if ( !VOS_IS_STATUS_SUCCESS( status ) )      {         VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_WARN, "%s: Failed to signal TL for AC=%d", __func__, ac );         //Remove the packet from queue. It must be at the back of the queue, as TX thread cannot preempt us in the middle         //as we are in a soft irq context. Also it must be the same packet that we just allocated.         spin_lock(&pAdapter->wmm_tx_queue[ac].lock);         status = hdd_list_remove_back( &pAdapter->wmm_tx_queue[ac], &anchor );         spin_unlock(&pAdapter->wmm_tx_queue[ac].lock);         ++pAdapter->stats.tx_dropped;         ++pAdapter->hdd_stats.hddTxRxStats.txXmitDropped;         ++pAdapter->hdd_stats.hddTxRxStats.txXmitDroppedAC[ac];         kfree_skb(skb);         return NETDEV_TX_OK;      }   }   dev->trans_start = jiffies;   return NETDEV_TX_OK;}
VOS_STATUS status;
VOS_STATUS status;
VOS_STATUS
VOS_STATUS
status
status
WLANTL_ACEnumType ac;
WLANTL_ACEnumType ac;
WLANTL_ACEnumType
WLANTL_ACEnumType
ac
ac
sme_QosWmmUpType up;
sme_QosWmmUpType up;
sme_QosWmmUpType
sme_QosWmmUpType
up
up
skb_list_node_t *pktNode = NULL;
skb_list_node_t *pktNode = NULL;
skb_list_node_t
skb_list_node_t
*pktNode = NULL
*
pktNode
= NULL
NULL
NULL
hdd_list_node_t *anchor = NULL;
hdd_list_node_t *anchor = NULL;
hdd_list_node_t
hdd_list_node_t
*anchor = NULL
*
anchor
= NULL
NULL
NULL
v_SIZE_t pktListSize = 0;
v_SIZE_t pktListSize = 0;
v_SIZE_t
v_SIZE_t
pktListSize = 0
pktListSize
= 0
0
hdd_adapter_t *pAdapter =  WLAN_HDD_GET_PRIV_PTR(dev);
hdd_adapter_t *pAdapter =  WLAN_HDD_GET_PRIV_PTR(dev);
hdd_adapter_t
hdd_adapter_t
*pAdapter =  WLAN_HDD_GET_PRIV_PTR(dev)
*
pAdapter
=  WLAN_HDD_GET_PRIV_PTR(dev)
WLAN_HDD_GET_PRIV_PTR(dev)
WLAN_HDD_GET_PRIV_PTR
WLAN_HDD_GET_PRIV_PTR
dev
dev
v_BOOL_t granted;
v_BOOL_t granted;
v_BOOL_t
v_BOOL_t
granted
granted
hdd_station_ctx_t *pHddStaCtx = &pAdapter->sessionCtx.station;
hdd_station_ctx_t *pHddStaCtx = &pAdapter->sessionCtx.station;
hdd_station_ctx_t
hdd_station_ctx_t
*pHddStaCtx = &pAdapter->sessionCtx.station
*
pHddStaCtx
= &pAdapter->sessionCtx.station
&pAdapter->sessionCtx.station
pAdapter->sessionCtx.station
pAdapter->sessionCtx
pAdapter
pAdapter
sessionCtx
station
v_BOOL_t txSuspended = VOS_FALSE;
v_BOOL_t txSuspended = VOS_FALSE;
v_BOOL_t
v_BOOL_t
txSuspended = VOS_FALSE
txSuspended
= VOS_FALSE
VOS_FALSE
VOS_FALSE
++pAdapter->hdd_stats.hddTxRxStats.txXmitCalled;
++pAdapter->hdd_stats.hddTxRxStats.txXmitCalled
pAdapter->hdd_stats.hddTxRxStats.txXmitCalled
pAdapter->hdd_stats.hddTxRxStats
pAdapter->hdd_stats
pAdapter
pAdapter
hdd_stats
hddTxRxStats
txXmitCalled
if (unlikely(netif_queue_stopped(dev))) {       VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,                  "%s is called when netif TX is disabled", __func__);       return NETDEV_TX_BUSY;   }
unlikely(netif_queue_stopped(dev))
unlikely
unlikely
netif_queue_stopped(dev)
netif_queue_stopped
netif_queue_stopped
dev
dev
{       VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,                  "%s is called when netif TX is disabled", __func__);       return NETDEV_TX_BUSY;   }
VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,                  "%s is called when netif TX is disabled", __func__);
VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,                  "%s is called when netif TX is disabled", __func__)
VOS_TRACE
VOS_TRACE
VOS_MODULE_ID_HDD
VOS_MODULE_ID_HDD
VOS_TRACE_LEVEL_ERROR
VOS_TRACE_LEVEL_ERROR
"%s is called when netif TX is disabled"
__func__
__func__
return NETDEV_TX_BUSY;
NETDEV_TX_BUSY
NETDEV_TX_BUSY
ac = hdd_QdiscAcToTlAC[skb->queue_mapping];
ac = hdd_QdiscAcToTlAC[skb->queue_mapping]
ac
ac
hdd_QdiscAcToTlAC[skb->queue_mapping]
hdd_QdiscAcToTlAC
hdd_QdiscAcToTlAC
skb->queue_mapping
skb
skb
queue_mapping
up = skb->priority;
up = skb->priority
up
up
skb->priority
skb
skb
priority
++pAdapter->hdd_stats.hddTxRxStats.txXmitClassifiedAC[ac];
++pAdapter->hdd_stats.hddTxRxStats.txXmitClassifiedAC[ac]
pAdapter->hdd_stats.hddTxRxStats.txXmitClassifiedAC[ac]
pAdapter->hdd_stats.hddTxRxStats.txXmitClassifiedAC
pAdapter->hdd_stats.hddTxRxStats
pAdapter->hdd_stats
pAdapter
pAdapter
hdd_stats
hddTxRxStats
txXmitClassifiedAC
ac
ac
spin_lock(&pAdapter->wmm_tx_queue[ac].lock);
spin_lock(&pAdapter->wmm_tx_queue[ac].lock)
spin_lock
spin_lock
&pAdapter->wmm_tx_queue[ac].lock
pAdapter->wmm_tx_queue[ac].lock
pAdapter->wmm_tx_queue[ac]
pAdapter->wmm_tx_queue
pAdapter
pAdapter
wmm_tx_queue
ac
ac
lock
if((pAdapter->wmm_tx_queue[ac].count + 1) % 10 == 0)   {           /* Use the following debug statement during Engineering Debugging.There are chance that this will lead to a Watchdog Bark            * if it is in the mainline code and if the log level is enabled by someone for debugging           VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,"%s:Queue is Filling up.Inform TL again about pending packets", __func__);*/           WLANTL_STAPktPending( (WLAN_HDD_GET_CTX(pAdapter))->pvosContext, pHddStaCtx->conn_info.staId[0], ac );   }
(pAdapter->wmm_tx_queue[ac].count + 1) % 10 == 0
(pAdapter->wmm_tx_queue[ac].count + 1) % 10
(pAdapter->wmm_tx_queue[ac].count + 1)
pAdapter->wmm_tx_queue[ac].count + 1
pAdapter->wmm_tx_queue[ac].count
pAdapter->wmm_tx_queue[ac]
pAdapter->wmm_tx_queue
pAdapter
pAdapter
wmm_tx_queue
ac
ac
count
1
10
0
{           /* Use the following debug statement during Engineering Debugging.There are chance that this will lead to a Watchdog Bark            * if it is in the mainline code and if the log level is enabled by someone for debugging           VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,"%s:Queue is Filling up.Inform TL again about pending packets", __func__);*/           WLANTL_STAPktPending( (WLAN_HDD_GET_CTX(pAdapter))->pvosContext, pHddStaCtx->conn_info.staId[0], ac );   }
WLANTL_STAPktPending( (WLAN_HDD_GET_CTX(pAdapter))->pvosContext, pHddStaCtx->conn_info.staId[0], ac );
WLANTL_STAPktPending( (WLAN_HDD_GET_CTX(pAdapter))->pvosContext, pHddStaCtx->conn_info.staId[0], ac )
WLANTL_STAPktPending
WLANTL_STAPktPending
(WLAN_HDD_GET_CTX(pAdapter))->pvosContext
(WLAN_HDD_GET_CTX(pAdapter))
WLAN_HDD_GET_CTX(pAdapter)
WLAN_HDD_GET_CTX
WLAN_HDD_GET_CTX
pAdapter
pAdapter
pvosContext
pHddStaCtx->conn_info.staId[0]
pHddStaCtx->conn_info.staId
pHddStaCtx->conn_info
pHddStaCtx
pHddStaCtx
conn_info
staId
0
ac
ac
if ( pAdapter->wmm_tx_queue[ac].count == pAdapter->wmm_tx_queue[ac].max_size)   {      ++pAdapter->hdd_stats.hddTxRxStats.txXmitBackPressured;      ++pAdapter->hdd_stats.hddTxRxStats.txXmitBackPressuredAC[ac];      netif_tx_stop_queue(netdev_get_tx_queue(dev, skb_get_queue_mapping(skb)));      pAdapter->isTxSuspended[ac] = VOS_TRUE;      txSuspended = VOS_TRUE;   }
pAdapter->wmm_tx_queue[ac].count == pAdapter->wmm_tx_queue[ac].max_size
pAdapter->wmm_tx_queue[ac].count
pAdapter->wmm_tx_queue[ac]
pAdapter->wmm_tx_queue
pAdapter
pAdapter
wmm_tx_queue
ac
ac
count
pAdapter->wmm_tx_queue[ac].max_size
pAdapter->wmm_tx_queue[ac]
pAdapter->wmm_tx_queue
pAdapter
pAdapter
wmm_tx_queue
ac
ac
max_size
{      ++pAdapter->hdd_stats.hddTxRxStats.txXmitBackPressured;      ++pAdapter->hdd_stats.hddTxRxStats.txXmitBackPressuredAC[ac];      netif_tx_stop_queue(netdev_get_tx_queue(dev, skb_get_queue_mapping(skb)));      pAdapter->isTxSuspended[ac] = VOS_TRUE;      txSuspended = VOS_TRUE;   }
++pAdapter->hdd_stats.hddTxRxStats.txXmitBackPressured;
++pAdapter->hdd_stats.hddTxRxStats.txXmitBackPressured
pAdapter->hdd_stats.hddTxRxStats.txXmitBackPressured
pAdapter->hdd_stats.hddTxRxStats
pAdapter->hdd_stats
pAdapter
pAdapter
hdd_stats
hddTxRxStats
txXmitBackPressured
++pAdapter->hdd_stats.hddTxRxStats.txXmitBackPressuredAC[ac];
++pAdapter->hdd_stats.hddTxRxStats.txXmitBackPressuredAC[ac]
pAdapter->hdd_stats.hddTxRxStats.txXmitBackPressuredAC[ac]
pAdapter->hdd_stats.hddTxRxStats.txXmitBackPressuredAC
pAdapter->hdd_stats.hddTxRxStats
pAdapter->hdd_stats
pAdapter
pAdapter
hdd_stats
hddTxRxStats
txXmitBackPressuredAC
ac
ac
netif_tx_stop_queue(netdev_get_tx_queue(dev, skb_get_queue_mapping(skb)));
netif_tx_stop_queue(netdev_get_tx_queue(dev, skb_get_queue_mapping(skb)))
netif_tx_stop_queue
netif_tx_stop_queue
netdev_get_tx_queue(dev, skb_get_queue_mapping(skb))
netdev_get_tx_queue
netdev_get_tx_queue
dev
dev
skb_get_queue_mapping(skb)
skb_get_queue_mapping
skb_get_queue_mapping
skb
skb
pAdapter->isTxSuspended[ac] = VOS_TRUE;
pAdapter->isTxSuspended[ac] = VOS_TRUE
pAdapter->isTxSuspended[ac]
pAdapter->isTxSuspended
pAdapter
pAdapter
isTxSuspended
ac
ac
VOS_TRUE
VOS_TRUE
txSuspended = VOS_TRUE;
txSuspended = VOS_TRUE
txSuspended
txSuspended
VOS_TRUE
VOS_TRUE
spin_unlock(&pAdapter->wmm_tx_queue[ac].lock);
spin_unlock(&pAdapter->wmm_tx_queue[ac].lock)
spin_unlock
spin_unlock
&pAdapter->wmm_tx_queue[ac].lock
pAdapter->wmm_tx_queue[ac].lock
pAdapter->wmm_tx_queue[ac]
pAdapter->wmm_tx_queue
pAdapter
pAdapter
wmm_tx_queue
ac
ac
lock
if (VOS_TRUE == txSuspended)   {       VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,                  "%s: TX queue full for AC=%d Disable OS TX queue",                  __func__, ac );      return NETDEV_TX_BUSY;   }
VOS_TRUE == txSuspended
VOS_TRUE
VOS_TRUE
txSuspended
txSuspended
{       VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,                  "%s: TX queue full for AC=%d Disable OS TX queue",                  __func__, ac );      return NETDEV_TX_BUSY;   }
VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,                  "%s: TX queue full for AC=%d Disable OS TX queue",                  __func__, ac );
VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,                  "%s: TX queue full for AC=%d Disable OS TX queue",                  __func__, ac )
VOS_TRACE
VOS_TRACE
VOS_MODULE_ID_HDD
VOS_MODULE_ID_HDD
VOS_TRACE_LEVEL_INFO
VOS_TRACE_LEVEL_INFO
"%s: TX queue full for AC=%d Disable OS TX queue"
__func__
__func__
ac
ac
return NETDEV_TX_BUSY;
NETDEV_TX_BUSY
NETDEV_TX_BUSY
pktNode = (skb_list_node_t *)&skb->cb;
pktNode = (skb_list_node_t *)&skb->cb
pktNode
pktNode
(skb_list_node_t *)&skb->cb
skb_list_node_t *
skb_list_node_t
skb_list_node_t
*
*
&skb->cb
skb->cb
skb
skb
cb
pktNode->skb = skb;
pktNode->skb = skb
pktNode->skb
pktNode
pktNode
skb
skb
skb
pktNode->userPriority = up;
pktNode->userPriority = up
pktNode->userPriority
pktNode
pktNode
userPriority
up
up
INIT_LIST_HEAD(&pktNode->anchor);
INIT_LIST_HEAD(&pktNode->anchor)
INIT_LIST_HEAD
INIT_LIST_HEAD
&pktNode->anchor
pktNode->anchor
pktNode
pktNode
anchor
spin_lock(&pAdapter->wmm_tx_queue[ac].lock);
spin_lock(&pAdapter->wmm_tx_queue[ac].lock)
spin_lock
spin_lock
&pAdapter->wmm_tx_queue[ac].lock
pAdapter->wmm_tx_queue[ac].lock
pAdapter->wmm_tx_queue[ac]
pAdapter->wmm_tx_queue
pAdapter
pAdapter
wmm_tx_queue
ac
ac
lock
status = hdd_list_insert_back_size( &pAdapter->wmm_tx_queue[ac], &pktNode->anchor, &pktListSize );
status = hdd_list_insert_back_size( &pAdapter->wmm_tx_queue[ac], &pktNode->anchor, &pktListSize )
status
status
hdd_list_insert_back_size( &pAdapter->wmm_tx_queue[ac], &pktNode->anchor, &pktListSize )
hdd_list_insert_back_size
hdd_list_insert_back_size
&pAdapter->wmm_tx_queue[ac]
pAdapter->wmm_tx_queue[ac]
pAdapter->wmm_tx_queue
pAdapter
pAdapter
wmm_tx_queue
ac
ac
&pktNode->anchor
pktNode->anchor
pktNode
pktNode
anchor
&pktListSize
pktListSize
pktListSize
spin_unlock(&pAdapter->wmm_tx_queue[ac].lock);
spin_unlock(&pAdapter->wmm_tx_queue[ac].lock)
spin_unlock
spin_unlock
&pAdapter->wmm_tx_queue[ac].lock
pAdapter->wmm_tx_queue[ac].lock
pAdapter->wmm_tx_queue[ac]
pAdapter->wmm_tx_queue
pAdapter
pAdapter
wmm_tx_queue
ac
ac
lock
if ( !VOS_IS_STATUS_SUCCESS( status ) )   {      VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_WARN,"%s:Insert Tx queue failed. Pkt dropped", __func__);      ++pAdapter->hdd_stats.hddTxRxStats.txXmitDropped;      ++pAdapter->hdd_stats.hddTxRxStats.txXmitDroppedAC[ac];      ++pAdapter->stats.tx_dropped;      kfree_skb(skb);      return NETDEV_TX_OK;   }
!VOS_IS_STATUS_SUCCESS( status )
VOS_IS_STATUS_SUCCESS( status )
VOS_IS_STATUS_SUCCESS
VOS_IS_STATUS_SUCCESS
status
status
{      VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_WARN,"%s:Insert Tx queue failed. Pkt dropped", __func__);      ++pAdapter->hdd_stats.hddTxRxStats.txXmitDropped;      ++pAdapter->hdd_stats.hddTxRxStats.txXmitDroppedAC[ac];      ++pAdapter->stats.tx_dropped;      kfree_skb(skb);      return NETDEV_TX_OK;   }
VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_WARN,"%s:Insert Tx queue failed. Pkt dropped", __func__);
VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_WARN,"%s:Insert Tx queue failed. Pkt dropped", __func__)
VOS_TRACE
VOS_TRACE
VOS_MODULE_ID_HDD
VOS_MODULE_ID_HDD
VOS_TRACE_LEVEL_WARN
VOS_TRACE_LEVEL_WARN
"%s:Insert Tx queue failed. Pkt dropped"
__func__
__func__
++pAdapter->hdd_stats.hddTxRxStats.txXmitDropped;
++pAdapter->hdd_stats.hddTxRxStats.txXmitDropped
pAdapter->hdd_stats.hddTxRxStats.txXmitDropped
pAdapter->hdd_stats.hddTxRxStats
pAdapter->hdd_stats
pAdapter
pAdapter
hdd_stats
hddTxRxStats
txXmitDropped
++pAdapter->hdd_stats.hddTxRxStats.txXmitDroppedAC[ac];
++pAdapter->hdd_stats.hddTxRxStats.txXmitDroppedAC[ac]
pAdapter->hdd_stats.hddTxRxStats.txXmitDroppedAC[ac]
pAdapter->hdd_stats.hddTxRxStats.txXmitDroppedAC
pAdapter->hdd_stats.hddTxRxStats
pAdapter->hdd_stats
pAdapter
pAdapter
hdd_stats
hddTxRxStats
txXmitDroppedAC
ac
ac
++pAdapter->stats.tx_dropped;
++pAdapter->stats.tx_dropped
pAdapter->stats.tx_dropped
pAdapter->stats
pAdapter
pAdapter
stats
tx_dropped
kfree_skb(skb);
kfree_skb(skb)
kfree_skb
kfree_skb
skb
skb
return NETDEV_TX_OK;
NETDEV_TX_OK
NETDEV_TX_OK
++pAdapter->hdd_stats.hddTxRxStats.txXmitQueued;
++pAdapter->hdd_stats.hddTxRxStats.txXmitQueued
pAdapter->hdd_stats.hddTxRxStats.txXmitQueued
pAdapter->hdd_stats.hddTxRxStats
pAdapter->hdd_stats
pAdapter
pAdapter
hdd_stats
hddTxRxStats
txXmitQueued
++pAdapter->hdd_stats.hddTxRxStats.txXmitQueuedAC[ac];
++pAdapter->hdd_stats.hddTxRxStats.txXmitQueuedAC[ac]
pAdapter->hdd_stats.hddTxRxStats.txXmitQueuedAC[ac]
pAdapter->hdd_stats.hddTxRxStats.txXmitQueuedAC
pAdapter->hdd_stats.hddTxRxStats
pAdapter->hdd_stats
pAdapter
pAdapter
hdd_stats
hddTxRxStats
txXmitQueuedAC
ac
ac
if (likely(pAdapter->hddWmmStatus.wmmAcStatus[ac].wmmAcAccessAllowed) ||           ( pHddStaCtx->conn_info.uIsAuthenticated == VOS_FALSE))   {      granted = VOS_TRUE;   }   else   {      status = hdd_wmm_acquire_access( pAdapter, ac, &granted );   }
likely(pAdapter->hddWmmStatus.wmmAcStatus[ac].wmmAcAccessAllowed) ||           ( pHddStaCtx->conn_info.uIsAuthenticated == VOS_FALSE)
likely(pAdapter->hddWmmStatus.wmmAcStatus[ac].wmmAcAccessAllowed)
likely
likely
pAdapter->hddWmmStatus.wmmAcStatus[ac].wmmAcAccessAllowed
pAdapter->hddWmmStatus.wmmAcStatus[ac]
pAdapter->hddWmmStatus.wmmAcStatus
pAdapter->hddWmmStatus
pAdapter
pAdapter
hddWmmStatus
wmmAcStatus
ac
ac
wmmAcAccessAllowed
( pHddStaCtx->conn_info.uIsAuthenticated == VOS_FALSE)
pHddStaCtx->conn_info.uIsAuthenticated == VOS_FALSE
pHddStaCtx->conn_info.uIsAuthenticated
pHddStaCtx->conn_info
pHddStaCtx
pHddStaCtx
conn_info
uIsAuthenticated
VOS_FALSE
VOS_FALSE
{      granted = VOS_TRUE;   }
granted = VOS_TRUE;
granted = VOS_TRUE
granted
granted
VOS_TRUE
VOS_TRUE
{      status = hdd_wmm_acquire_access( pAdapter, ac, &granted );   }
status = hdd_wmm_acquire_access( pAdapter, ac, &granted );
status = hdd_wmm_acquire_access( pAdapter, ac, &granted )
status
status
hdd_wmm_acquire_access( pAdapter, ac, &granted )
hdd_wmm_acquire_access
hdd_wmm_acquire_access
pAdapter
pAdapter
ac
ac
&granted
granted
granted
if ( granted && ( pktListSize == 1 ))   {      //Let TL know we have a packet to send for this AC      //VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,"%s:Indicating Packet to TL", __func__);      status = WLANTL_STAPktPending( (WLAN_HDD_GET_CTX(pAdapter))->pvosContext, pHddStaCtx->conn_info.staId[0], ac );      if ( !VOS_IS_STATUS_SUCCESS( status ) )      {         VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_WARN, "%s: Failed to signal TL for AC=%d", __func__, ac );         //Remove the packet from queue. It must be at the back of the queue, as TX thread cannot preempt us in the middle         //as we are in a soft irq context. Also it must be the same packet that we just allocated.         spin_lock(&pAdapter->wmm_tx_queue[ac].lock);         status = hdd_list_remove_back( &pAdapter->wmm_tx_queue[ac], &anchor );         spin_unlock(&pAdapter->wmm_tx_queue[ac].lock);         ++pAdapter->stats.tx_dropped;         ++pAdapter->hdd_stats.hddTxRxStats.txXmitDropped;         ++pAdapter->hdd_stats.hddTxRxStats.txXmitDroppedAC[ac];         kfree_skb(skb);         return NETDEV_TX_OK;      }   }
granted && ( pktListSize == 1 )
granted
granted
( pktListSize == 1 )
pktListSize == 1
pktListSize
pktListSize
1
{      //Let TL know we have a packet to send for this AC      //VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,"%s:Indicating Packet to TL", __func__);      status = WLANTL_STAPktPending( (WLAN_HDD_GET_CTX(pAdapter))->pvosContext, pHddStaCtx->conn_info.staId[0], ac );      if ( !VOS_IS_STATUS_SUCCESS( status ) )      {         VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_WARN, "%s: Failed to signal TL for AC=%d", __func__, ac );         //Remove the packet from queue. It must be at the back of the queue, as TX thread cannot preempt us in the middle         //as we are in a soft irq context. Also it must be the same packet that we just allocated.         spin_lock(&pAdapter->wmm_tx_queue[ac].lock);         status = hdd_list_remove_back( &pAdapter->wmm_tx_queue[ac], &anchor );         spin_unlock(&pAdapter->wmm_tx_queue[ac].lock);         ++pAdapter->stats.tx_dropped;         ++pAdapter->hdd_stats.hddTxRxStats.txXmitDropped;         ++pAdapter->hdd_stats.hddTxRxStats.txXmitDroppedAC[ac];         kfree_skb(skb);         return NETDEV_TX_OK;      }   }
status = WLANTL_STAPktPending( (WLAN_HDD_GET_CTX(pAdapter))->pvosContext, pHddStaCtx->conn_info.staId[0], ac );
status = WLANTL_STAPktPending( (WLAN_HDD_GET_CTX(pAdapter))->pvosContext, pHddStaCtx->conn_info.staId[0], ac )
status
status
WLANTL_STAPktPending( (WLAN_HDD_GET_CTX(pAdapter))->pvosContext, pHddStaCtx->conn_info.staId[0], ac )
WLANTL_STAPktPending
WLANTL_STAPktPending
(WLAN_HDD_GET_CTX(pAdapter))->pvosContext
(WLAN_HDD_GET_CTX(pAdapter))
WLAN_HDD_GET_CTX(pAdapter)
WLAN_HDD_GET_CTX
WLAN_HDD_GET_CTX
pAdapter
pAdapter
pvosContext
pHddStaCtx->conn_info.staId[0]
pHddStaCtx->conn_info.staId
pHddStaCtx->conn_info
pHddStaCtx
pHddStaCtx
conn_info
staId
0
ac
ac
if ( !VOS_IS_STATUS_SUCCESS( status ) )      {         VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_WARN, "%s: Failed to signal TL for AC=%d", __func__, ac );         //Remove the packet from queue. It must be at the back of the queue, as TX thread cannot preempt us in the middle         //as we are in a soft irq context. Also it must be the same packet that we just allocated.         spin_lock(&pAdapter->wmm_tx_queue[ac].lock);         status = hdd_list_remove_back( &pAdapter->wmm_tx_queue[ac], &anchor );         spin_unlock(&pAdapter->wmm_tx_queue[ac].lock);         ++pAdapter->stats.tx_dropped;         ++pAdapter->hdd_stats.hddTxRxStats.txXmitDropped;         ++pAdapter->hdd_stats.hddTxRxStats.txXmitDroppedAC[ac];         kfree_skb(skb);         return NETDEV_TX_OK;      }
!VOS_IS_STATUS_SUCCESS( status )
VOS_IS_STATUS_SUCCESS( status )
VOS_IS_STATUS_SUCCESS
VOS_IS_STATUS_SUCCESS
status
status
{         VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_WARN, "%s: Failed to signal TL for AC=%d", __func__, ac );         //Remove the packet from queue. It must be at the back of the queue, as TX thread cannot preempt us in the middle         //as we are in a soft irq context. Also it must be the same packet that we just allocated.         spin_lock(&pAdapter->wmm_tx_queue[ac].lock);         status = hdd_list_remove_back( &pAdapter->wmm_tx_queue[ac], &anchor );         spin_unlock(&pAdapter->wmm_tx_queue[ac].lock);         ++pAdapter->stats.tx_dropped;         ++pAdapter->hdd_stats.hddTxRxStats.txXmitDropped;         ++pAdapter->hdd_stats.hddTxRxStats.txXmitDroppedAC[ac];         kfree_skb(skb);         return NETDEV_TX_OK;      }
VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_WARN, "%s: Failed to signal TL for AC=%d", __func__, ac );
VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_WARN, "%s: Failed to signal TL for AC=%d", __func__, ac )
VOS_TRACE
VOS_TRACE
VOS_MODULE_ID_HDD
VOS_MODULE_ID_HDD
VOS_TRACE_LEVEL_WARN
VOS_TRACE_LEVEL_WARN
"%s: Failed to signal TL for AC=%d"
__func__
__func__
ac
ac
spin_lock(&pAdapter->wmm_tx_queue[ac].lock);
spin_lock(&pAdapter->wmm_tx_queue[ac].lock)
spin_lock
spin_lock
&pAdapter->wmm_tx_queue[ac].lock
pAdapter->wmm_tx_queue[ac].lock
pAdapter->wmm_tx_queue[ac]
pAdapter->wmm_tx_queue
pAdapter
pAdapter
wmm_tx_queue
ac
ac
lock
status = hdd_list_remove_back( &pAdapter->wmm_tx_queue[ac], &anchor );
status = hdd_list_remove_back( &pAdapter->wmm_tx_queue[ac], &anchor )
status
status
hdd_list_remove_back( &pAdapter->wmm_tx_queue[ac], &anchor )
hdd_list_remove_back
hdd_list_remove_back
&pAdapter->wmm_tx_queue[ac]
pAdapter->wmm_tx_queue[ac]
pAdapter->wmm_tx_queue
pAdapter
pAdapter
wmm_tx_queue
ac
ac
&anchor
anchor
anchor
spin_unlock(&pAdapter->wmm_tx_queue[ac].lock);
spin_unlock(&pAdapter->wmm_tx_queue[ac].lock)
spin_unlock
spin_unlock
&pAdapter->wmm_tx_queue[ac].lock
pAdapter->wmm_tx_queue[ac].lock
pAdapter->wmm_tx_queue[ac]
pAdapter->wmm_tx_queue
pAdapter
pAdapter
wmm_tx_queue
ac
ac
lock
++pAdapter->stats.tx_dropped;
++pAdapter->stats.tx_dropped
pAdapter->stats.tx_dropped
pAdapter->stats
pAdapter
pAdapter
stats
tx_dropped
++pAdapter->hdd_stats.hddTxRxStats.txXmitDropped;
++pAdapter->hdd_stats.hddTxRxStats.txXmitDropped
pAdapter->hdd_stats.hddTxRxStats.txXmitDropped
pAdapter->hdd_stats.hddTxRxStats
pAdapter->hdd_stats
pAdapter
pAdapter
hdd_stats
hddTxRxStats
txXmitDropped
++pAdapter->hdd_stats.hddTxRxStats.txXmitDroppedAC[ac];
++pAdapter->hdd_stats.hddTxRxStats.txXmitDroppedAC[ac]
pAdapter->hdd_stats.hddTxRxStats.txXmitDroppedAC[ac]
pAdapter->hdd_stats.hddTxRxStats.txXmitDroppedAC
pAdapter->hdd_stats.hddTxRxStats
pAdapter->hdd_stats
pAdapter
pAdapter
hdd_stats
hddTxRxStats
txXmitDroppedAC
ac
ac
kfree_skb(skb);
kfree_skb(skb)
kfree_skb
kfree_skb
skb
skb
return NETDEV_TX_OK;
NETDEV_TX_OK
NETDEV_TX_OK
dev->trans_start = jiffies;
dev->trans_start = jiffies
dev->trans_start
dev
dev
trans_start
jiffies
jiffies
return NETDEV_TX_OK;
NETDEV_TX_OK
NETDEV_TX_OK
-----joern-----
(107,276,0)
(391,199,0)
(202,197,0)
(349,336,0)
(142,98,0)
(201,317,0)
(371,399,0)
(267,310,0)
(4,401,0)
(205,228,0)
(45,215,0)
(181,427,0)
(269,393,0)
(183,45,0)
(293,45,0)
(303,374,0)
(281,397,0)
(326,233,0)
(271,214,0)
(80,126,0)
(335,368,0)
(409,23,0)
(226,46,0)
(242,160,0)
(434,154,0)
(121,63,0)
(124,83,0)
(197,431,0)
(116,88,0)
(36,254,0)
(419,214,0)
(129,318,0)
(225,397,0)
(59,57,0)
(24,70,0)
(210,285,0)
(0,121,0)
(342,196,0)
(89,271,0)
(265,264,0)
(303,385,0)
(433,223,0)
(364,358,0)
(290,143,0)
(274,283,0)
(362,187,0)
(310,228,0)
(214,419,0)
(125,105,0)
(191,401,0)
(421,385,0)
(28,424,0)
(402,199,0)
(427,333,0)
(123,46,0)
(164,243,0)
(154,347,0)
(299,199,0)
(179,7,0)
(26,329,0)
(245,317,0)
(110,340,0)
(119,42,0)
(171,309,0)
(240,57,0)
(187,165,0)
(182,45,0)
(52,231,0)
(280,9,0)
(234,88,0)
(141,45,0)
(69,199,0)
(333,427,0)
(309,428,0)
(406,333,0)
(207,293,0)
(309,313,0)
(432,418,0)
(138,435,0)
(428,390,0)
(237,424,0)
(431,63,0)
(40,232,0)
(250,24,0)
(17,428,0)
(35,417,0)
(315,417,0)
(59,160,0)
(16,258,0)
(83,63,0)
(48,111,0)
(231,350,0)
(77,199,0)
(16,389,0)
(396,87,0)
(155,328,0)
(288,280,0)
(163,45,0)
(17,83,0)
(70,239,0)
(261,397,0)
(201,81,0)
(146,261,0)
(197,122,0)
(180,163,0)
(276,93,0)
(157,42,0)
(113,121,0)
(198,431,0)
(42,119,0)
(206,231,0)
(121,199,0)
(97,311,0)
(17,27,0)
(300,295,0)
(186,114,0)
(73,22,0)
(262,7,0)
(387,114,0)
(423,90,0)
(415,192,0)
(71,142,0)
(381,368,0)
(45,199,0)
(117,27,0)
(336,393,0)
(307,199,0)
(30,417,0)
(23,63,0)
(303,375,0)
(367,261,0)
(318,45,0)
(361,8,0)
(423,63,0)
(64,413,0)
(76,283,0)
(44,99,0)
(20,45,0)
(217,337,0)
(401,332,0)
(155,243,0)
(308,347,0)
(304,161,0)
(398,63,0)
(422,161,0)
(181,63,0)
(375,303,0)
(424,45,0)
(132,87,0)
(272,199,0)
(37,375,0)
(161,422,0)
(128,132,0)
(66,199,0)
(63,247,0)
(382,141,0)
(159,263,0)
(348,106,0)
(8,423,0)
(341,117,0)
(435,127,0)
(233,354,0)
(433,27,0)
(184,140,0)
(150,302,0)
(185,199,0)
(11,90,0)
(276,63,0)
(204,332,0)
(155,4,0)
(254,251,0)
(342,236,0)
(371,99,0)
(265,181,0)
(360,39,0)
(229,287,0)
(54,199,0)
(390,19,0)
(325,25,0)
(318,364,0)
(247,216,0)
(72,192,0)
(24,42,0)
(152,98,0)
(421,63,0)
(258,351,0)
(190,125,0)
(196,393,0)
(29,93,0)
(83,123,0)
(376,336,0)
(235,59,0)
(136,79,0)
(127,63,0)
(236,232,0)
(377,9,0)
(107,36,0)
(227,223,0)
(135,99,0)
(101,280,0)
(263,159,0)
(84,154,0)
(338,245,0)
(103,295,0)
(76,45,0)
(263,45,0)
(383,431,0)
(196,245,0)
(219,308,0)
(307,87,0)
(141,13,0)
(296,6,0)
(6,63,0)
(114,63,0)
(98,152,0)
(148,128,0)
(233,326,0)
(383,45,0)
(393,199,0)
(187,159,0)
(423,8,0)
(365,125,0)
(347,308,0)
(313,232,0)
(38,285,0)
(162,423,0)
(320,311,0)
(61,183,0)
(404,122,0)
(120,143,0)
(411,199,0)
(334,428,0)
(9,280,0)
(400,13,0)
(195,216,0)
(295,45,0)
(99,371,0)
(310,45,0)
(364,318,0)
(323,27,0)
(4,83,0)
(357,182,0)
(270,351,0)
(413,140,0)
(4,428,0)
(216,19,0)
(26,93,0)
(385,421,0)
(238,49,0)
(139,264,0)
(81,201,0)
(399,371,0)
(172,192,0)
(4,313,0)
(354,233,0)
(7,199,0)
(389,16,0)
(100,328,0)
(189,140,0)
(366,285,0)
(311,320,0)
(395,351,0)
(14,371,0)
(181,253,0)
(39,360,0)
(58,123,0)
(115,313,0)
(244,199,0)
(228,205,0)
(226,407,0)
(259,343,0)
(248,199,0)
(245,196,0)
(94,130,0)
(393,196,0)
(193,398,0)
(4,199,0)
(79,312,0)
(75,292,0)
(351,395,0)
(358,422,0)
(327,214,0)
(194,343,0)
(351,258,0)
(56,383,0)
(352,159,0)
(94,126,0)
(285,63,0)
(347,154,0)
(230,251,0)
(398,368,0)
(62,104,0)
(87,307,0)
(337,45,0)
(17,313,0)
(363,337,0)
(293,395,0)
(357,63,0)
(78,407,0)
(249,419,0)
(340,45,0)
(93,384,0)
(13,63,0)
(326,134,0)
(339,23,0)
(264,230,0)
(309,83,0)
(55,236,0)
(268,45,0)
(196,342,0)
(122,197,0)
(60,94,0)
(405,287,0)
(223,433,0)
(311,45,0)
(120,6,0)
(1,189,0)
(223,106,0)
(51,119,0)
(254,36,0)
(20,206,0)
(119,45,0)
(5,285,0)
(163,421,0)
(114,27,0)
(369,326,0)
(273,236,0)
(243,305,0)
(32,134,0)
(330,418,0)
(212,163,0)
(431,383,0)
(403,395,0)
(181,265,0)
(320,276,0)
(312,46,0)
(40,344,0)
(221,318,0)
(132,128,0)
(332,199,0)
(47,271,0)
(53,90,0)
(13,141,0)
(276,320,0)
(109,127,0)
(167,17,0)
(356,317,0)
(417,232,0)
(297,201,0)
(394,63,0)
(408,50,0)
(160,46,0)
(285,305,0)
(10,114,0)
(385,303,0)
(131,263,0)
(337,398,0)
(324,141,0)
(106,223,0)
(158,313,0)
(281,251,0)
(420,78,0)
(280,19,0)
(257,378,0)
(25,392,0)
(279,199,0)
(111,45,0)
(390,199,0)
(78,340,0)
(354,27,0)
(137,19,0)
(353,182,0)
(76,257,0)
(108,358,0)
(215,105,0)
(63,199,0)
(417,315,0)
(155,17,0)
(41,230,0)
(421,163,0)
(401,105,0)
(169,199,0)
(328,68,0)
(128,45,0)
(69,39,0)
(346,182,0)
(121,9,0)
(412,216,0)
(257,76,0)
(315,244,0)
(301,258,0)
(205,143,0)
(18,114,0)
(126,94,0)
(25,105,0)
(368,381,0)
(224,160,0)
(3,407,0)
(118,22,0)
(255,384,0)
(85,106,0)
(373,360,0)
(350,143,0)
(278,293,0)
(96,340,0)
(322,132,0)
(323,287,0)
(109,199,0)
(178,401,0)
(292,355,0)
(8,361,0)
(343,143,0)
(40,173,0)
(435,138,0)
(127,435,0)
(422,358,0)
(116,405,0)
(283,76,0)
(313,302,0)
(222,59,0)
(88,45,0)
(149,257,0)
(309,143,0)
(256,199,0)
(231,206,0)
(23,183,0)
(220,357,0)
(410,310,0)
(429,300,0)
(344,40,0)
(425,199,0)
(370,118,0)
(39,69,0)
(134,326,0)
(25,137,0)
(196,339,0)
(287,323,0)
(251,281,0)
(12,251,0)
(247,63,0)
(161,357,0)
(295,300,0)
(290,19,0)
(138,418,0)
(336,376,0)
(392,25,0)
(284,107,0)
(260,413,0)
(177,121,0)
(174,128,0)
(228,310,0)
(252,364,0)
(130,199,0)
(339,196,0)
(239,70,0)
(416,399,0)
(340,78,0)
(374,49,0)
(216,247,0)
(175,435,0)
(98,142,0)
(236,342,0)
(286,192,0)
(203,199,0)
(345,263,0)
(118,126,0)
(159,187,0)
(176,183,0)
(230,264,0)
(388,317,0)
(79,189,0)
(232,40,0)
(386,428,0)
(83,111,0)
(407,226,0)
(361,33,0)
(140,189,0)
(308,13,0)
(389,419,0)
(213,20,0)
(34,199,0)
(82,8,0)
(188,292,0)
(102,26,0)
(165,199,0)
(258,16,0)
(90,423,0)
(374,303,0)
(275,421,0)
(241,76,0)
(23,339,0)
(232,199,0)
(418,138,0)
(22,45,0)
(93,276,0)
(426,116,0)
(168,76,0)
(76,63,0)
(357,161,0)
(57,199,0)
(368,398,0)
(137,25,0)
(111,83,0)
(112,230,0)
(99,45,0)
(218,201,0)
(144,111,0)
(291,181,0)
(31,343,0)
(147,127,0)
(91,138,0)
(140,413,0)
(300,360,0)
(88,116,0)
(133,22,0)
(6,399,0)
(170,285,0)
(360,300,0)
(206,20,0)
(358,364,0)
(86,247,0)
(243,83,0)
(94,63,0)
(427,181,0)
(117,19,0)
(21,49,0)
(424,134,0)
(106,45,0)
(431,197,0)
(142,50,0)
(418,45,0)
(13,308,0)
(319,199,0)
(152,27,0)
(300,63,0)
(33,361,0)
(36,107,0)
(145,232,0)
(2,390,0)
(70,24,0)
(67,295,0)
(9,199,0)
(15,50,0)
(189,79,0)
(183,23,0)
(287,63,0)
(298,119,0)
(182,357,0)
(397,281,0)
(350,231,0)
(294,84,0)
(398,337,0)
(153,57,0)
(22,118,0)
(74,206,0)
(127,109,0)
(154,84,0)
(173,104,0)
(6,120,0)
(419,389,0)
(134,424,0)
(65,4,0)
(289,254,0)
(130,94,0)
(215,45,0)
(50,45,0)
(331,199,0)
(380,383,0)
(251,199,0)
(399,6,0)
(192,68,0)
(321,320,0)
(156,20,0)
(375,27,0)
(43,290,0)
(104,19,0)
(372,215,0)
(407,78,0)
(151,347,0)
(329,26,0)
(211,228,0)
(405,116,0)
(173,40,0)
(264,265,0)
(271,251,0)
(430,276,0)
(126,118,0)
(209,98,0)
(302,9,0)
(306,374,0)
(266,114,0)
(200,265,0)
(49,199,0)
(351,63,0)
(122,404,0)
(79,63,0)
(413,45,0)
(34,381,0)
(33,199,0)
(42,63,0)
(379,121,0)
(316,104,0)
(317,199,0)
(287,405,0)
(364,63,0)
(381,34,0)
(81,292,0)
(90,45,0)
(282,81,0)
(314,36,0)
(333,45,0)
(395,293,0)
(414,137,0)
(428,232,0)
(276,107,0)
(155,309,0)
(125,365,0)
(246,343,0)
(166,254,0)
(214,271,0)
(87,132,0)
(104,173,0)
(277,121,0)
(397,261,0)
(208,427,0)
(302,199,0)
(312,79,0)
(92,405,0)
(134,63,0)
(261,45,0)
(95,121,0)
(392,46,0)
(244,315,0)
(42,24,0)
(165,187,0)
(359,88,0)
(404,199,0)
(239,27,0)
(50,142,0)
(17,313,1)
(431,198,1)
(102,93,1)
(90,45,1)
(427,208,1)
(368,335,1)
(13,63,1)
(178,81,1)
(404,122,1)
(227,106,1)
(81,282,1)
(361,8,1)
(409,183,1)
(87,396,1)
(275,163,1)
(271,251,1)
(374,49,1)
(211,310,1)
(50,45,1)
(168,149,1)
(137,19,1)
(381,368,1)
(261,367,1)
(233,326,1)
(125,105,1)
(162,90,1)
(138,418,1)
(111,144,1)
(364,252,1)
(306,385,1)
(101,288,1)
(112,427,1)
(12,45,1)
(160,242,1)
(290,43,1)
(25,137,1)
(410,120,1)
(158,390,1)
(67,244,1)
(52,206,1)
(368,398,1)
(428,386,1)
(421,275,1)
(6,63,1)
(118,22,1)
(131,376,1)
(376,336,1)
(260,226,1)
(145,59,1)
(163,212,1)
(196,339,1)
(352,263,1)
(336,393,1)
(144,48,1)
(121,63,1)
(4,83,1)
(290,19,1)
(333,406,1)
(313,232,1)
(298,114,1)
(336,349,1)
(300,63,1)
(84,294,1)
(215,372,1)
(214,271,1)
(148,57,1)
(273,339,1)
(420,340,1)
(81,292,1)
(155,328,1)
(349,404,1)
(326,369,1)
(431,63,1)
(284,36,1)
(159,352,1)
(94,126,1)
(4,401,1)
(347,151,1)
(189,140,1)
(383,45,1)
(343,31,1)
(262,179,1)
(98,209,1)
(263,345,1)
(309,313,1)
(312,79,1)
(235,222,1)
(303,385,1)
(396,132,1)
(360,373,1)
(88,45,1)
(329,26,1)
(61,176,1)
(17,428,1)
(335,398,1)
(11,160,1)
(94,60,1)
(435,175,1)
(83,111,1)
(151,308,1)
(134,63,1)
(24,42,1)
(181,291,1)
(104,316,1)
(365,125,1)
(147,435,1)
(16,258,1)
(245,338,1)
(417,30,1)
(267,410,1)
(107,284,1)
(419,214,1)
(93,276,1)
(302,9,1)
(265,200,1)
(172,72,1)
(295,45,1)
(183,61,1)
(62,145,1)
(422,161,1)
(292,75,1)
(120,6,1)
(47,16,1)
(106,45,1)
(44,135,1)
(327,271,1)
(283,274,1)
(39,360,1)
(338,342,1)
(401,105,1)
(121,9,1)
(393,196,1)
(266,10,1)
(48,392,1)
(250,42,1)
(324,382,1)
(223,227,1)
(107,36,1)
(421,163,1)
(195,86,1)
(208,333,1)
(213,343,1)
(412,195,1)
(35,302,1)
(317,356,1)
(300,429,1)
(385,421,1)
(155,309,1)
(395,403,1)
(122,197,1)
(81,201,1)
(22,133,1)
(358,108,1)
(40,344,1)
(370,22,1)
(117,19,1)
(94,63,1)
(111,45,1)
(176,269,1)
(25,105,1)
(247,216,1)
(171,290,1)
(5,38,1)
(278,130,1)
(429,295,1)
(33,361,1)
(187,159,1)
(51,298,1)
(21,238,1)
(110,96,1)
(83,63,1)
(296,399,1)
(137,414,1)
(15,433,1)
(180,37,1)
(345,131,1)
(116,426,1)
(239,70,1)
(26,102,1)
(342,236,1)
(337,45,1)
(245,317,1)
(89,47,1)
(140,184,1)
(11,422,1)
(118,370,1)
(430,107,1)
(201,317,1)
(219,13,1)
(427,333,1)
(23,409,1)
(216,412,1)
(274,241,1)
(71,50,1)
(4,428,1)
(23,63,1)
(382,34,1)
(371,14,1)
(302,150,1)
(79,189,1)
(388,49,1)
(334,232,1)
(243,83,1)
(100,192,1)
(196,245,1)
(57,240,1)
(374,306,1)
(221,129,1)
(166,320,1)
(78,340,1)
(307,87,1)
(91,418,1)
(56,380,1)
(276,63,1)
(114,63,1)
(375,303,1)
(241,168,1)
(99,44,1)
(17,167,1)
(187,362,1)
(333,45,1)
(234,152,1)
(4,313,1)
(271,89,1)
(201,297,1)
(189,1,1)
(351,395,1)
(357,182,1)
(123,58,1)
(424,28,1)
(379,277,1)
(84,154,1)
(214,327,1)
(128,45,1)
(258,301,1)
(133,73,1)
(220,182,1)
(126,80,1)
(155,4,1)
(300,295,1)
(115,158,1)
(320,321,1)
(418,45,1)
(225,261,1)
(242,224,1)
(125,190,1)
(17,83,1)
(6,399,1)
(311,97,1)
(161,304,1)
(82,423,1)
(264,139,1)
(287,63,1)
(308,13,1)
(40,173,1)
(397,225,1)
(390,19,1)
(406,84,1)
(200,264,1)
(252,318,1)
(359,234,1)
(249,214,1)
(423,162,1)
(358,364,1)
(418,432,1)
(197,202,1)
(42,157,1)
(422,358,1)
(196,342,1)
(184,413,1)
(400,141,1)
(258,351,1)
(127,435,1)
(240,153,1)
(310,267,1)
(135,350,1)
(285,63,1)
(152,98,1)
(159,263,1)
(209,142,1)
(254,251,1)
(288,377,1)
(183,45,1)
(386,334,1)
(367,146,1)
(309,428,1)
(190,307,1)
(330,9,1)
(309,171,1)
(371,99,1)
(95,109,1)
(98,142,1)
(119,45,1)
(373,300,1)
(261,45,1)
(276,320,1)
(55,273,1)
(70,24,1)
(397,261,1)
(389,16,1)
(156,213,1)
(198,383,1)
(194,259,1)
(86,394,1)
(395,293,1)
(80,118,1)
(321,311,1)
(405,92,1)
(207,278,1)
(78,420,1)
(289,166,1)
(18,329,1)
(14,99,1)
(294,154,1)
(36,314,1)
(216,19,1)
(280,19,1)
(257,76,1)
(276,430,1)
(155,17,1)
(173,104,1)
(318,45,1)
(328,100,1)
(309,83,1)
(231,52,1)
(116,88,1)
(340,110,1)
(311,45,1)
(224,123,1)
(8,423,1)
(204,401,1)
(2,428,1)
(341,323,1)
(167,117,1)
(285,170,1)
(231,206,1)
(348,354,1)
(193,337,1)
(64,260,1)
(108,364,1)
(357,220,1)
(206,20,1)
(13,141,1)
(340,45,1)
(259,376,1)
(392,25,1)
(351,270,1)
(403,293,1)
(323,287,1)
(83,124,1)
(72,365,1)
(398,63,1)
(58,83,1)
(364,63,1)
(394,365,1)
(163,45,1)
(399,371,1)
(3,78,1)
(281,397,1)
(353,358,1)
(73,165,1)
(136,189,1)
(268,317,1)
(364,318,1)
(228,211,1)
(90,53,1)
(432,330,1)
(423,63,1)
(188,389,1)
(423,90,1)
(126,118,1)
(132,322,1)
(186,18,1)
(154,347,1)
(49,21,1)
(383,56,1)
(29,81,1)
(96,422,1)
(232,40,1)
(22,45,1)
(413,64,1)
(426,88,1)
(399,416,1)
(65,332,1)
(150,313,1)
(408,15,1)
(63,247,1)
(206,74,1)
(287,229,1)
(85,348,1)
(38,210,1)
(405,116,1)
(308,219,1)
(377,63,1)
(97,29,1)
(181,265,1)
(433,223,1)
(121,379,1)
(314,254,1)
(87,132,1)
(13,400,1)
(32,424,1)
(326,134,1)
(155,243,1)
(282,292,1)
(99,45,1)
(134,424,1)
(146,12,1)
(59,57,1)
(434,347,1)
(154,434,1)
(7,262,1)
(129,181,1)
(295,103,1)
(244,315,1)
(313,115,1)
(421,63,1)
(428,232,1)
(337,363,1)
(366,59,1)
(310,45,1)
(9,280,1)
(332,204,1)
(293,45,1)
(76,283,1)
(30,35,1)
(6,296,1)
(28,237,1)
(175,138,1)
(106,85,1)
(222,33,1)
(165,187,1)
(50,408,1)
(153,251,1)
(178,329,1)
(387,266,1)
(127,63,1)
(76,63,1)
(297,218,1)
(104,19,1)
(181,427,1)
(218,282,1)
(191,178,1)
(205,228,1)
(129,84,1)
(417,232,1)
(75,188,1)
(10,186,1)
(192,286,1)
(43,205,1)
(109,127,1)
(276,107,1)
(8,82,1)
(170,5,1)
(36,254,1)
(130,94,1)
(246,194,1)
(243,164,1)
(237,375,1)
(103,67,1)
(346,353,1)
(149,389,1)
(217,121,1)
(141,324,1)
(41,112,1)
(315,417,1)
(263,45,1)
(113,95,1)
(142,50,1)
(407,78,1)
(316,62,1)
(304,357,1)
(372,268,1)
(124,111,1)
(301,351,1)
(407,3,1)
(88,359,1)
(142,71,1)
(435,138,1)
(415,172,1)
(360,300,1)
(318,221,1)
(351,63,1)
(182,346,1)
(138,91,1)
(24,250,1)
(134,32,1)
(34,381,1)
(76,45,1)
(431,383,1)
(23,183,1)
(141,45,1)
(132,128,1)
(350,231,1)
(325,312,1)
(280,101,1)
(92,116,1)
(398,193,1)
(287,405,1)
(398,337,1)
(413,45,1)
(202,431,1)
(79,136,1)
(230,41,1)
(264,230,1)
(174,148,1)
(128,174,1)
(20,156,1)
(79,63,1)
(339,23,1)
(286,415,1)
(114,387,1)
(354,233,1)
(197,431,1)
(69,39,1)
(4,65,1)
(269,69,1)
(59,235,1)
(223,106,1)
(416,371,1)
(369,134,1)
(181,63,1)
(60,126,1)
(226,407,1)
(117,341,1)
(229,405,1)
(161,357,1)
(303,374,1)
(238,7,1)
(414,325,1)
(212,180,1)
(127,147,1)
(215,105,1)
(347,308,1)
(1,140,1)
(322,128,1)
(390,2,1)
(157,119,1)
(277,0,1)
(254,289,1)
(42,63,1)
(362,159,1)
(282,257,1)
(74,20,1)
(177,113,1)
(228,310,1)
(291,265,1)
(230,251,1)
(182,45,1)
(140,413,1)
(210,366,1)
(236,232,1)
(31,246,1)
(236,55,1)
(265,264,1)
(270,395,1)
(320,311,1)
(164,285,1)
(357,63,1)
(59,160,1)
(424,45,1)
(139,230,1)
(42,119,1)
(26,93,1)
(251,281,1)
(389,419,1)
(20,45,1)
(45,215,1)
(53,11,1)
(356,388,1)
(363,217,1)
(119,51,1)
(37,239,1)
(419,249,1)
(293,207,1)
(0,177,1)
(401,191,1)
(380,393,1)
(195,365,2)
(111,422,2)
(427,333,2)
(323,287,2)
(280,365,2)
(223,106,2)
(40,344,2)
(264,84,2)
(170,59,2)
(144,422,2)
(206,20,2)
(232,40,2)
(287,63,2)
(104,59,2)
(26,81,2)
(131,376,2)
(138,365,2)
(211,376,2)
(276,81,2)
(186,329,2)
(354,233,2)
(96,422,2)
(300,59,2)
(258,376,2)
(264,230,2)
(192,365,2)
(231,376,2)
(414,422,2)
(161,365,2)
(233,329,2)
(97,81,2)
(13,141,2)
(360,59,2)
(125,105,2)
(337,45,2)
(112,84,2)
(137,422,2)
(113,365,2)
(230,84,2)
(121,365,2)
(83,63,2)
(270,376,2)
(70,24,2)
(71,329,2)
(41,84,2)
(364,318,2)
(315,417,2)
(29,81,2)
(98,142,2)
(36,254,2)
(431,383,2)
(93,81,2)
(86,365,2)
(381,368,2)
(118,22,2)
(399,371,2)
(429,59,2)
(309,83,2)
(306,329,2)
(374,49,2)
(204,81,2)
(375,329,2)
(261,45,2)
(2,59,2)
(342,236,2)
(108,365,2)
(381,365,2)
(191,329,2)
(142,50,2)
(111,45,2)
(180,329,2)
(431,63,2)
(181,427,2)
(383,45,2)
(11,365,2)
(109,365,2)
(403,376,2)
(276,63,2)
(40,59,2)
(152,98,2)
(9,280,2)
(117,329,2)
(59,160,2)
(223,329,2)
(290,376,2)
(140,413,2)
(173,59,2)
(421,329,2)
(404,122,2)
(320,311,2)
(354,329,2)
(26,93,2)
(59,365,2)
(423,63,2)
(100,365,2)
(196,245,2)
(420,422,2)
(370,376,2)
(162,365,2)
(5,59,2)
(4,329,2)
(103,59,2)
(369,329,2)
(424,329,2)
(194,376,2)
(164,59,2)
(35,59,2)
(269,59,2)
(214,16,2)
(163,45,2)
(284,81,2)
(42,329,2)
(50,45,2)
(154,347,2)
(137,19,2)
(107,81,2)
(140,422,2)
(246,376,2)
(351,376,2)
(67,59,2)
(42,119,2)
(339,23,2)
(64,422,2)
(363,365,2)
(165,187,2)
(6,63,2)
(237,329,2)
(51,329,2)
(358,364,2)
(395,293,2)
(90,365,2)
(129,365,2)
(116,88,2)
(0,365,2)
(399,376,2)
(364,63,2)
(311,45,2)
(79,422,2)
(377,365,2)
(181,84,2)
(183,59,2)
(375,303,2)
(50,329,2)
(324,365,2)
(300,63,2)
(263,45,2)
(158,59,2)
(134,424,2)
(360,300,2)
(134,329,2)
(304,365,2)
(196,59,2)
(422,358,2)
(252,365,2)
(247,216,2)
(423,365,2)
(154,365,2)
(379,365,2)
(73,376,2)
(202,59,2)
(418,45,2)
(196,342,2)
(138,418,2)
(308,13,2)
(115,59,2)
(295,45,2)
(415,365,2)
(309,313,2)
(373,59,2)
(134,63,2)
(302,59,2)
(9,365,2)
(293,376,2)
(99,376,2)
(220,365,2)
(336,59,2)
(250,329,2)
(282,376,2)
(287,405,2)
(340,422,2)
(419,214,2)
(254,81,2)
(13,63,2)
(106,45,2)
(60,376,2)
(175,365,2)
(122,59,2)
(209,329,2)
(359,329,2)
(121,63,2)
(63,365,2)
(155,309,2)
(365,125,2)
(70,329,2)
(107,36,2)
(149,389,2)
(48,422,2)
(52,376,2)
(6,399,2)
(141,45,2)
(16,376,2)
(127,435,2)
(30,59,2)
(301,376,2)
(183,45,2)
(303,385,2)
(271,251,2)
(347,308,2)
(303,374,2)
(263,376,2)
(80,376,2)
(380,59,2)
(398,63,2)
(302,9,2)
(265,264,2)
(226,407,2)
(352,376,2)
(288,365,2)
(90,45,2)
(341,329,2)
(273,59,2)
(155,243,2)
(385,421,2)
(18,329,2)
(307,87,2)
(389,376,2)
(343,376,2)
(275,329,2)
(214,271,2)
(173,104,2)
(397,261,2)
(191,81,2)
(1,422,2)
(151,365,2)
(362,376,2)
(17,428,2)
(135,376,2)
(65,81,2)
(346,365,2)
(94,126,2)
(22,376,2)
(295,59,2)
(114,63,2)
(432,365,2)
(348,329,2)
(257,389,2)
(230,251,2)
(350,376,2)
(236,59,2)
(205,376,2)
(221,365,2)
(232,59,2)
(155,4,2)
(351,395,2)
(401,81,2)
(74,376,2)
(61,59,2)
(141,365,2)
(401,105,2)
(37,329,2)
(104,19,2)
(400,365,2)
(398,365,2)
(147,365,2)
(249,16,2)
(43,376,2)
(314,81,2)
(53,365,2)
(176,59,2)
(244,315,2)
(205,228,2)
(357,365,2)
(312,422,2)
(433,329,2)
(229,329,2)
(291,84,2)
(84,365,2)
(201,317,2)
(394,365,2)
(260,422,2)
(181,265,2)
(409,59,2)
(168,389,2)
(126,118,2)
(401,329,2)
(368,398,2)
(177,365,2)
(320,81,2)
(88,329,2)
(13,365,2)
(6,376,2)
(339,59,2)
(290,19,2)
(165,376,2)
(3,422,2)
(92,329,2)
(287,329,2)
(358,365,2)
(333,84,2)
(435,138,2)
(392,25,2)
(222,365,2)
(308,365,2)
(159,263,2)
(337,365,2)
(258,351,2)
(338,59,2)
(126,376,2)
(389,419,2)
(166,81,2)
(316,59,2)
(193,365,2)
(393,59,2)
(219,365,2)
(17,83,2)
(93,276,2)
(17,329,2)
(216,365,2)
(336,393,2)
(82,365,2)
(78,422,2)
(4,313,2)
(150,59,2)
(285,63,2)
(398,337,2)
(257,76,2)
(55,59,2)
(407,78,2)
(22,45,2)
(156,376,2)
(428,59,2)
(309,376,2)
(72,365,2)
(139,84,2)
(410,376,2)
(187,376,2)
(23,63,2)
(422,365,2)
(28,329,2)
(40,173,2)
(241,389,2)
(318,45,2)
(130,376,2)
(182,45,2)
(14,376,2)
(435,365,2)
(118,376,2)
(208,84,2)
(361,365,2)
(332,329,2)
(364,365,2)
(76,45,2)
(4,428,2)
(10,329,2)
(376,336,2)
(357,182,2)
(217,365,2)
(315,59,2)
(184,422,2)
(145,59,2)
(132,128,2)
(123,422,2)
(412,365,2)
(207,376,2)
(227,329,2)
(172,365,2)
(297,282,2)
(407,422,2)
(182,365,2)
(281,397,2)
(36,81,2)
(274,389,2)
(434,365,2)
(431,59,2)
(345,376,2)
(101,365,2)
(383,59,2)
(298,329,2)
(233,326,2)
(405,329,2)
(95,365,2)
(300,295,2)
(328,365,2)
(329,26,2)
(296,376,2)
(426,329,2)
(4,83,2)
(161,357,2)
(293,45,2)
(81,201,2)
(31,376,2)
(20,376,2)
(84,154,2)
(8,423,2)
(189,140,2)
(235,365,2)
(88,45,2)
(75,389,2)
(181,63,2)
(361,8,2)
(215,105,2)
(212,329,2)
(405,116,2)
(285,59,2)
(294,365,2)
(326,134,2)
(167,329,2)
(34,381,2)
(266,329,2)
(251,281,2)
(178,81,2)
(390,19,2)
(130,94,2)
(283,389,2)
(351,63,2)
(422,161,2)
(99,45,2)
(332,81,2)
(81,376,2)
(408,329,2)
(89,16,2)
(234,329,2)
(413,422,2)
(228,376,2)
(152,329,2)
(335,365,2)
(423,90,2)
(224,422,2)
(119,45,2)
(59,57,2)
(323,329,2)
(33,365,2)
(197,431,2)
(276,320,2)
(259,376,2)
(157,329,2)
(239,70,2)
(371,99,2)
(376,59,2)
(136,422,2)
(218,282,2)
(56,59,2)
(386,59,2)
(311,81,2)
(366,59,2)
(39,360,2)
(428,232,2)
(303,329,2)
(160,422,2)
(333,45,2)
(63,247,2)
(254,251,2)
(292,389,2)
(421,163,2)
(24,42,2)
(65,329,2)
(325,422,2)
(340,45,2)
(329,81,2)
(122,197,2)
(236,232,2)
(127,63,2)
(178,329,2)
(421,63,2)
(277,365,2)
(371,376,2)
(38,59,2)
(91,365,2)
(390,59,2)
(313,232,2)
(110,422,2)
(33,361,2)
(413,45,2)
(25,105,2)
(76,283,2)
(94,376,2)
(47,16,2)
(25,137,2)
(395,376,2)
(382,365,2)
(342,59,2)
(417,232,2)
(310,376,2)
(188,389,2)
(85,329,2)
(69,39,2)
(392,422,2)
(120,376,2)
(114,329,2)
(350,231,2)
(76,389,2)
(226,422,2)
(78,340,2)
(171,376,2)
(419,16,2)
(368,365,2)
(271,16,2)
(109,127,2)
(349,59,2)
(393,196,2)
(200,84,2)
(128,45,2)
(106,329,2)
(265,84,2)
(87,132,2)
(245,59,2)
(357,63,2)
(44,376,2)
(32,329,2)
(187,159,2)
(309,428,2)
(79,63,2)
(81,292,2)
(280,19,2)
(83,422,2)
(83,111,2)
(387,329,2)
(210,59,2)
(318,365,2)
(406,84,2)
(197,59,2)
(23,59,2)
(204,329,2)
(430,81,2)
(242,422,2)
(196,339,2)
(418,365,2)
(8,365,2)
(330,365,2)
(116,329,2)
(39,59,2)
(4,401,2)
(124,422,2)
(76,63,2)
(334,59,2)
(34,365,2)
(15,329,2)
(326,329,2)
(25,422,2)
(243,83,2)
(289,81,2)
(94,63,2)
(24,329,2)
(45,215,2)
(127,365,2)
(231,206,2)
(244,59,2)
(385,329,2)
(163,329,2)
(228,310,2)
(312,79,2)
(286,365,2)
(117,19,2)
(159,376,2)
(424,45,2)
(327,16,2)
(42,63,2)
(353,365,2)
(389,16,2)
(155,17,2)
(239,329,2)
(58,422,2)
(201,282,2)
(245,317,2)
(4,81,2)
(198,59,2)
(206,376,2)
(427,84,2)
(313,59,2)
(23,183,2)
(416,376,2)
(347,365,2)
(433,223,2)
(216,19,2)
(404,59,2)
(278,376,2)
(417,59,2)
(321,81,2)
(69,59,2)
(267,376,2)
(98,329,2)
(121,9,2)
(119,329,2)
(17,313,2)
(102,81,2)
(133,376,2)
(247,365,2)
(374,329,2)
(155,328,2)
(20,45,2)
(120,6,2)
(79,189,2)
(276,107,2)
(310,45,2)
(142,329,2)
(189,422,2)
(16,258,2)
(62,59,2)
(213,376,2)
(243,59,2)
-----------------------------------
(0,__func__)
(1,txXmitBackPressuredAC)
(2,skb)
(3,txXmitBackPressured)
(4,return NETDEV_TX_OK;)
(5,__func__)
(6,pAdapter->hdd_stats.hddTxRxStats.txXmitDroppedAC[ac])
(7,*pktNode = NULL)
(8,pAdapter->wmm_tx_queue[ac].lock)
(9,up = skb->priority)
(10,"%s: Failed to signal TL for AC=%d")
(11,pAdapter)
(12,pHddStaCtx)
(13,pAdapter->wmm_tx_queue[ac])
(14,hddTxRxStats)
(15,pAdapter)
(16,likely(pAdapter->hddWmmStatus.wmmAcStatus[ac].wmmAcAccessAllowed)
(17,return NETDEV_TX_OK;)
(18,VOS_MODULE_ID_HDD)
(19,struct sk_buff *skb)
(20,pAdapter->hdd_stats)
(21,NULL)
(22,pAdapter->hdd_stats)
(23,pAdapter->wmm_tx_queue[ac])
(24,pAdapter->wmm_tx_queue[ac].lock)
(25,netdev_get_tx_queue(dev, skb_get_queue_mapping(skb)
(26,VOS_IS_STATUS_SUCCESS( status )
(27,)
(28,wmm_tx_queue)
(29,status)
(30,anchor)
(31,__func__)
(32,ac)
(33,spin_unlock(&pAdapter->wmm_tx_queue[ac].lock)
(34,spin_lock(&pAdapter->wmm_tx_queue[ac].lock)
(35,pktNode)
(36,pHddStaCtx->conn_info.staId)
(37,status)
(38,"%s: TX queue full for AC=%d Disable OS TX queue")
(39,&pAdapter->wmm_tx_queue[ac].lock)
(40,(skb_list_node_t *)
(41,conn_info)
(42,pAdapter->wmm_tx_queue[ac])
(43,skb)
(44,hdd_stats)
(45,*pAdapter =  WLAN_HDD_GET_PRIV_PTR(dev)
(46,)
(47,pHddStaCtx)
(48,pAdapter)
(49,*anchor = NULL)
(50,pAdapter->hdd_stats)
(51,wmm_tx_queue)
(52,txXmitDropped)
(53,wmm_tx_queue)
(54,txSuspended)
(55,anchor)
(56,wmm_tx_queue)
(57,txSuspended = VOS_FALSE)
(58,VOS_TRUE)
(59,VOS_TRUE == txSuspended)
(60,ac)
(61,wmm_tx_queue)
(62,skb)
(63,ac = hdd_QdiscAcToTlAC[skb->queue_mapping])
(64,hdd_stats)
(65,NETDEV_TX_OK)
(66,up)
(67,pAdapter)
(68,)
(69,spin_lock(&pAdapter->wmm_tx_queue[ac].lock)
(70,&pAdapter->wmm_tx_queue[ac].lock)
(71,hddTxRxStats)
(72,VOS_MODULE_ID_HDD)
(73,pAdapter)
(74,hddTxRxStats)
(75,VOS_TRUE)
(76,hdd_wmm_acquire_access( pAdapter, ac, &granted )
(77,granted)
(78,pAdapter->hdd_stats.hddTxRxStats)
(79,pAdapter->hdd_stats.hddTxRxStats.txXmitBackPressuredAC[ac])
(80,txXmitQueuedAC)
(81,granted && ( pktListSize == 1 )
(82,lock)
(83,pAdapter->isTxSuspended[ac])
(84,(pAdapter->wmm_tx_queue[ac].count + 1)
(85,stats)
(86,hdd_QdiscAcToTlAC)
(87,pAdapter->hdd_stats.hddTxRxStats.txXmitCalled)
(88,pAdapter->hdd_stats)
(89,conn_info)
(90,pAdapter->wmm_tx_queue)
(91,hddTxRxStats)
(92,txXmitDroppedAC)
(93,status = WLANTL_STAPktPending( (WLAN_HDD_GET_CTX(pAdapter)
(94,pAdapter->hdd_stats.hddTxRxStats.txXmitQueuedAC[ac])
(95,VOS_MODULE_ID_HDD)
(96,pAdapter)
(97,pAdapter)
(98,pAdapter->hdd_stats.hddTxRxStats.txXmitDropped)
(99,pAdapter->hdd_stats)
(100,NETDEV_TX_BUSY)
(101,priority)
(102,status)
(103,wmm_tx_queue)
(104,skb->cb)
(105,struct net_device *dev)
(106,pAdapter->stats)
(107,pHddStaCtx->conn_info.staId[0])
(108,count)
(109,++pAdapter->hdd_stats.hddTxRxStats.txXmitClassifiedAC[ac])
(110,hdd_stats)
(111,pAdapter->isTxSuspended)
(112,pHddStaCtx)
(113,VOS_TRACE_LEVEL_FATAL)
(114,VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_WARN, "%s: Failed to signal TL for AC=%d", __func__, ac )
(115,userPriority)
(116,pAdapter->hdd_stats.hddTxRxStats)
(117,kfree_skb(skb)
(118,pAdapter->hdd_stats.hddTxRxStats)
(119,pAdapter->wmm_tx_queue)
(120,++pAdapter->hdd_stats.hddTxRxStats.txXmitDroppedAC[ac])
(121,VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,\n\\n              "%s: Classified as ac %d up %d", __func__, ac, up)
(122,&pAdapter->wmm_tx_queue[ac].lock)
(123,pAdapter->isTxSuspended[ac] = VOS_TRUE)
(124,ac)
(125,netif_queue_stopped(dev)
(126,pAdapter->hdd_stats.hddTxRxStats.txXmitQueuedAC)
(127,pAdapter->hdd_stats.hddTxRxStats.txXmitClassifiedAC[ac])
(128,pAdapter->hdd_stats)
(129,pAdapter)
(130,++pAdapter->hdd_stats.hddTxRxStats.txXmitQueuedAC[ac])
(131,pAdapter)
(132,pAdapter->hdd_stats.hddTxRxStats)
(133,hdd_stats)
(134,pAdapter->wmm_tx_queue[ac])
(135,pAdapter)
(136,ac)
(137,skb_get_queue_mapping(skb)
(138,pAdapter->hdd_stats.hddTxRxStats)
(139,staId)
(140,pAdapter->hdd_stats.hddTxRxStats)
(141,pAdapter->wmm_tx_queue)
(142,pAdapter->hdd_stats.hddTxRxStats)
(143,)
(144,isTxSuspended)
(145,pktNode)
(146,pAdapter)
(147,ac)
(148,pAdapter)
(149,status)
(150,up)
(151,1)
(152,++pAdapter->hdd_stats.hddTxRxStats.txXmitDropped)
(153,txSuspended)
(154,(pAdapter->wmm_tx_queue[ac].count + 1)
(155,RET)
(156,hdd_stats)
(157,ac)
(158,pktNode)
(159,pAdapter->hdd_stats.hddTxRxStats)
(160,txSuspended = VOS_TRUE)
(161,pAdapter->wmm_tx_queue[ac].max_size)
(162,ac)
(163,pAdapter->wmm_tx_queue)
(164,NETDEV_TX_BUSY)
(165,++pAdapter->hdd_stats.hddTxRxStats.txXmitQueued)
(166,pHddStaCtx)
(167,NETDEV_TX_OK)
(168,pAdapter)
(169,if (unlikely(netif_queue_stopped(dev)
(170,ac)
(171,NETDEV_TX_OK)
(172,VOS_TRACE_LEVEL_ERROR)
(173,&skb->cb)
(174,hdd_stats)
(175,txXmitClassifiedAC)
(176,pAdapter)
(177,"%s: Classified as ac %d up %d")
(178,dev)
(179,pktNode)
(180,pAdapter)
(181,WLANTL_STAPktPending( (WLAN_HDD_GET_CTX(pAdapter)
(182,pAdapter->wmm_tx_queue)
(183,pAdapter->wmm_tx_queue)
(184,hddTxRxStats)
(185,pHddStaCtx)
(186,VOS_TRACE_LEVEL_WARN)
(187,pAdapter->hdd_stats.hddTxRxStats.txXmitQueued)
(188,granted)
(189,pAdapter->hdd_stats.hddTxRxStats.txXmitBackPressuredAC)
(190,dev)
(191,trans_start)
(192,VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,\n\\n                  "%s is called when netif TX is disabled", __func__)
(193,ac)
(194,VOS_TRACE_LEVEL_WARN)
(195,skb)
(196,hdd_list_insert_back_size( &pAdapter->wmm_tx_queue[ac], &pktNode->anchor, &pktListSize )
(197,pAdapter->wmm_tx_queue[ac].lock)
(198,ac)
(199,)
(200,0)
(201,pktListSize == 1)
(202,lock)
(203,if((pAdapter->wmm_tx_queue[ac].count + 1)
(204,jiffies)
(205,++pAdapter->stats.tx_dropped)
(206,pAdapter->hdd_stats.hddTxRxStats)
(207,hddWmmStatus)
(208,pvosContext)
(209,txXmitDropped)
(210,VOS_TRACE_LEVEL_INFO)
(211,tx_dropped)
(212,wmm_tx_queue)
(213,pAdapter)
(214,pHddStaCtx->conn_info.uIsAuthenticated)
(215,WLAN_HDD_GET_PRIV_PTR(dev)
(216,skb->queue_mapping)
(217,pAdapter)
(218,pktListSize)
(219,count)
(220,ac)
(221,wmm_tx_queue)
(222,VOS_TRUE)
(223,pAdapter->stats.tx_dropped)
(224,txSuspended)
(225,station)
(226,++pAdapter->hdd_stats.hddTxRxStats.txXmitBackPressured)
(227,tx_dropped)
(228,pAdapter->stats.tx_dropped)
(229,ac)
(230,pHddStaCtx->conn_info)
(231,pAdapter->hdd_stats.hddTxRxStats.txXmitDropped)
(232,pktNode = (skb_list_node_t *)
(233,&pAdapter->wmm_tx_queue[ac].lock)
(234,pAdapter)
(235,txSuspended)
(236,pktNode->anchor)
(237,pAdapter)
(238,anchor)
(239,spin_lock(&pAdapter->wmm_tx_queue[ac].lock)
(240,VOS_FALSE)
(241,ac)
(242,VOS_TRUE)
(243,return NETDEV_TX_BUSY;)
(244,INIT_LIST_HEAD(&pktNode->anchor)
(245,&pktListSize)
(246,"%s:Insert Tx queue failed. Pkt dropped")
(247,hdd_QdiscAcToTlAC[skb->queue_mapping])
(248,anchor)
(249,VOS_FALSE)
(250,lock)
(251,*pHddStaCtx = &pAdapter->sessionCtx.station)
(252,ac)
(253,)
(254,pHddStaCtx->conn_info)
(255,if ( !VOS_IS_STATUS_SUCCESS( status )
(256,if ( !VOS_IS_STATUS_SUCCESS( status )
(257,status = hdd_wmm_acquire_access( pAdapter, ac, &granted )
(258,pAdapter->hddWmmStatus.wmmAcStatus[ac].wmmAcAccessAllowed)
(259,VOS_MODULE_ID_HDD)
(260,pAdapter)
(261,pAdapter->sessionCtx)
(262,NULL)
(263,pAdapter->hdd_stats)
(264,pHddStaCtx->conn_info.staId)
(265,pHddStaCtx->conn_info.staId[0])
(266,__func__)
(267,stats)
(268,pAdapter)
(269,status)
(270,ac)
(271,pHddStaCtx->conn_info)
(272,if ( pAdapter->wmm_tx_queue[ac].count == pAdapter->wmm_tx_queue[ac].max_size)
(273,pktNode)
(274,granted)
(275,ac)
(276,WLANTL_STAPktPending( (WLAN_HDD_GET_CTX(pAdapter)
(277,ac)
(278,pAdapter)
(279,pktListSize)
(280,skb->priority)
(281,&pAdapter->sessionCtx.station)
(282,granted)
(283,&granted)
(284,0)
(285,VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,\n\\n                  "%s: TX queue full for AC=%d Disable OS TX queue",\n\\n                  __func__, ac )
(286,__func__)
(287,pAdapter->hdd_stats.hddTxRxStats.txXmitDroppedAC[ac])
(288,skb)
(289,conn_info)
(290,kfree_skb(skb)
(291,ac)
(292,granted = VOS_TRUE)
(293,pAdapter->hddWmmStatus)
(294,0)
(295,pAdapter->wmm_tx_queue)
(296,ac)
(297,1)
(298,pAdapter)
(299,if ( granted && ( pktListSize == 1 )
(300,pAdapter->wmm_tx_queue[ac])
(301,wmmAcAccessAllowed)
(302,pktNode->userPriority = up)
(303,hdd_list_remove_back( &pAdapter->wmm_tx_queue[ac], &anchor )
(304,max_size)
(305,)
(306,anchor)
(307,++pAdapter->hdd_stats.hddTxRxStats.txXmitCalled)
(308,pAdapter->wmm_tx_queue[ac].count)
(309,return NETDEV_TX_OK;)
(310,pAdapter->stats)
(311,WLAN_HDD_GET_CTX(pAdapter)
(312,++pAdapter->hdd_stats.hddTxRxStats.txXmitBackPressuredAC[ac])
(313,pktNode->userPriority)
(314,staId)
(315,&pktNode->anchor)
(316,cb)
(317,pktListSize = 0)
(318,pAdapter->wmm_tx_queue)
(319,pktNode)
(320,(WLAN_HDD_GET_CTX(pAdapter)
(321,pvosContext)
(322,hddTxRxStats)
(323,++pAdapter->hdd_stats.hddTxRxStats.txXmitDroppedAC[ac])
(324,wmm_tx_queue)
(325,dev)
(326,pAdapter->wmm_tx_queue[ac].lock)
(327,uIsAuthenticated)
(328,return NETDEV_TX_BUSY;)
(329,!VOS_IS_STATUS_SUCCESS( status )
(330,pAdapter)
(331,if (likely(pAdapter->hddWmmStatus.wmmAcStatus[ac].wmmAcAccessAllowed)
(332,dev->trans_start = jiffies)
(333,WLAN_HDD_GET_CTX(pAdapter)
(334,pktNode)
(335,lock)
(336,VOS_IS_STATUS_SUCCESS( status )
(337,pAdapter->wmm_tx_queue)
(338,pktListSize)
(339,&pAdapter->wmm_tx_queue[ac])
(340,pAdapter->hdd_stats)
(341,skb)
(342,&pktNode->anchor)
(343,VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_WARN,"%s:Insert Tx queue failed. Pkt dropped", __func__)
(344,skb_list_node_t *)
(345,hdd_stats)
(346,wmm_tx_queue)
(347,pAdapter->wmm_tx_queue[ac].count + 1)
(348,pAdapter)
(349,status)
(350,++pAdapter->hdd_stats.hddTxRxStats.txXmitDropped)
(351,pAdapter->hddWmmStatus.wmmAcStatus[ac])
(352,hddTxRxStats)
(353,pAdapter)
(354,spin_unlock(&pAdapter->wmm_tx_queue[ac].lock)
(355,)
(356,0)
(357,pAdapter->wmm_tx_queue[ac])
(358,pAdapter->wmm_tx_queue[ac].count)
(359,hdd_stats)
(360,pAdapter->wmm_tx_queue[ac].lock)
(361,&pAdapter->wmm_tx_queue[ac].lock)
(362,txXmitQueued)
(363,wmm_tx_queue)
(364,pAdapter->wmm_tx_queue[ac])
(365,unlikely(netif_queue_stopped(dev)
(366,VOS_MODULE_ID_HDD)
(367,sessionCtx)
(368,pAdapter->wmm_tx_queue[ac].lock)
(369,lock)
(370,hddTxRxStats)
(371,pAdapter->hdd_stats.hddTxRxStats)
(372,dev)
(373,lock)
(374,&anchor)
(375,status = hdd_list_remove_back( &pAdapter->wmm_tx_queue[ac], &anchor )
(376,!VOS_IS_STATUS_SUCCESS( status )
(377,up)
(378,)
(379,up)
(380,pAdapter)
(381,&pAdapter->wmm_tx_queue[ac].lock)
(382,pAdapter)
(383,pAdapter->wmm_tx_queue)
(384,)
(385,&pAdapter->wmm_tx_queue[ac])
(386,skb)
(387,ac)
(388,pktListSize)
(389,likely(pAdapter->hddWmmStatus.wmmAcStatus[ac].wmmAcAccessAllowed)
(390,pktNode->skb = skb)
(391,ac)
(392,netif_tx_stop_queue(netdev_get_tx_queue(dev, skb_get_queue_mapping(skb)
(393,status = hdd_list_insert_back_size( &pAdapter->wmm_tx_queue[ac], &pktNode->anchor, &pktListSize )
(394,ac)
(395,pAdapter->hddWmmStatus.wmmAcStatus)
(396,txXmitCalled)
(397,pAdapter->sessionCtx.station)
(398,pAdapter->wmm_tx_queue[ac])
(399,pAdapter->hdd_stats.hddTxRxStats.txXmitDroppedAC)
(400,ac)
(401,dev->trans_start)
(402,pAdapter)
(403,wmmAcStatus)
(404,spin_unlock(&pAdapter->wmm_tx_queue[ac].lock)
(405,pAdapter->hdd_stats.hddTxRxStats.txXmitDroppedAC)
(406,pAdapter)
(407,pAdapter->hdd_stats.hddTxRxStats.txXmitBackPressured)
(408,hdd_stats)
(409,ac)
(410,pAdapter)
(411,status)
(412,queue_mapping)
(413,pAdapter->hdd_stats)
(414,skb)
(415,"%s is called when netif TX is disabled")
(416,txXmitDroppedAC)
(417,pktNode->anchor)
(418,pAdapter->hdd_stats)
(419,pHddStaCtx->conn_info.uIsAuthenticated == VOS_FALSE)
(420,hddTxRxStats)
(421,pAdapter->wmm_tx_queue[ac])
(422,pAdapter->wmm_tx_queue[ac].count == pAdapter->wmm_tx_queue[ac].max_size)
(423,pAdapter->wmm_tx_queue[ac])
(424,pAdapter->wmm_tx_queue)
(425,if (VOS_TRUE == txSuspended)
(426,hddTxRxStats)
(427,(WLAN_HDD_GET_CTX(pAdapter)
(428,pktNode->skb)
(429,ac)
(430,ac)
(431,pAdapter->wmm_tx_queue[ac])
(432,hdd_stats)
(433,++pAdapter->stats.tx_dropped)
(434,10)
(435,pAdapter->hdd_stats.hddTxRxStats.txXmitClassifiedAC)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^