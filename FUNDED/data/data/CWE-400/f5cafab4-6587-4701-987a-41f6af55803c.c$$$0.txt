-----label-----
0
-----code-----
static int socket_process_helper(struct iax2_thread *thread)
{
	struct sockaddr_in sin;
	int res;
	int updatehistory=1;
	int new = NEW_PREVENT;
	int dcallno = 0;
	char decrypted = 0;
	struct ast_iax2_full_hdr *fh = (struct ast_iax2_full_hdr *)thread->buf;
	struct ast_iax2_mini_hdr *mh = (struct ast_iax2_mini_hdr *)thread->buf;
	struct ast_iax2_meta_hdr *meta = (struct ast_iax2_meta_hdr *)thread->buf;
	struct ast_iax2_video_hdr *vh = (struct ast_iax2_video_hdr *)thread->buf;
	struct iax_frame *fr;
	struct iax_frame *cur;
	struct ast_frame f = { 0, };
	struct ast_channel *c = NULL;
	struct iax2_dpcache *dp;
	struct iax2_peer *peer;
	struct iax_ies ies;
	struct iax_ie_data ied0, ied1;
	iax2_format format;
	int fd;
	int exists;
	int minivid = 0;
	char empty[32]="";		/* Safety measure */
	struct iax_frame *duped_fr;
	char host_pref_buf[128];
	char caller_pref_buf[128];
	struct ast_codec_pref pref;
	char *using_prefs = "mine";

	/* allocate an iax_frame with 4096 bytes of data buffer */
	fr = ast_alloca(sizeof(*fr) + 4096);
	memset(fr, 0, sizeof(*fr));
	fr->afdatalen = 4096; /* From ast_alloca() above */

	/* Copy frequently used parameters to the stack */
	res = thread->buf_len;
	fd = thread->iofd;
	memcpy(&sin, &thread->iosin, sizeof(sin));

	if (res < sizeof(*mh)) {
		ast_log(LOG_WARNING, "midget packet received (%d of %d min)\n", res, (int) sizeof(*mh));
		return 1;
	}
	if ((vh->zeros == 0) && (ntohs(vh->callno) & 0x8000)) {
		if (res < sizeof(*vh)) {
			ast_log(LOG_WARNING, "Rejecting packet from '%s.%d' that is flagged as a video frame but is too short\n", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));
			return 1;
		}

		/* This is a video frame, get call number */
		fr->callno = find_callno(ntohs(vh->callno) & ~0x8000, dcallno, &sin, new, fd, 0);
		minivid = 1;
	} else if ((meta->zeros == 0) && !(ntohs(meta->metacmd) & 0x8000))
		return socket_process_meta(res, meta, &sin, fd, fr);

#ifdef DEBUG_SUPPORT
	if (res >= sizeof(*fh))
		iax_outputframe(NULL, fh, 1, &sin, res - sizeof(*fh));
#endif
	if (ntohs(mh->callno) & IAX_FLAG_FULL) {
		if (res < sizeof(*fh)) {
			ast_log(LOG_WARNING, "Rejecting packet from '%s.%d' that is flagged as a full frame but is too short\n", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));
			return 1;
		}

		/* Get the destination call number */
		dcallno = ntohs(fh->dcallno) & ~IAX_FLAG_RETRANS;


		/* check to make sure this full frame isn't encrypted before we attempt
 		 * to look inside of it. If it is encrypted, decrypt it first. Its ok if the
		 * callno is not found here, that just means one hasn't been allocated for
		 * this connection yet. */
		if ((dcallno != 1) && (fr->callno = find_callno(ntohs(mh->callno) & ~IAX_FLAG_FULL, dcallno, &sin, NEW_PREVENT, fd, 1))) {
			ast_mutex_lock(&iaxsl[fr->callno]);
			if (iaxs[fr->callno] && ast_test_flag64(iaxs[fr->callno], IAX_ENCRYPTED)) {
				if (decrypt_frame(fr->callno, fh, &f, &res)) {
					ast_log(LOG_NOTICE, "Packet Decrypt Failed!\n");
					ast_mutex_unlock(&iaxsl[fr->callno]);
					return 1;
				}
				decrypted = 1;
			}
			ast_mutex_unlock(&iaxsl[fr->callno]);
		}

		/* Retrieve the type and subclass */
		f.frametype = fh->type;
		if (f.frametype == AST_FRAME_VIDEO) {
			ast_format_from_old_bitfield(&f.subclass.format, (uncompress_subclass(fh->csub & ~0x40)));
			if ((fh->csub >> 6) & 0x1) {
				ast_format_set_video_mark(&f.subclass.format);
			}
		} else if (f.frametype == AST_FRAME_VOICE) {
			ast_format_from_old_bitfield(&f.subclass.format, uncompress_subclass(fh->csub));
		} else {
			f.subclass.integer = uncompress_subclass(fh->csub);
		}

		/* Deal with POKE/PONG without allocating a callno */
		if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_POKE) {
			/* Reply back with a PONG, but don't care about the result. */
			send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_PONG, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);
			return 1;
		} else if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_ACK && dcallno == 1) {
			/* Ignore */
			return 1;
		}

		f.datalen = res - sizeof(*fh);
		if (f.datalen) {
			if (f.frametype == AST_FRAME_IAX) {
				if (iax_parse_ies(&ies, thread->buf + sizeof(struct ast_iax2_full_hdr), f.datalen)) {
					ast_log(LOG_WARNING, "Undecodable frame received from '%s'\n", ast_inet_ntoa(sin.sin_addr));
					ast_variables_destroy(ies.vars);
					return 1;
				}
				f.data.ptr = NULL;
				f.datalen = 0;
			} else {
				f.data.ptr = thread->buf + sizeof(struct ast_iax2_full_hdr);
				memset(&ies, 0, sizeof(ies));
			}
		} else {
			if (f.frametype == AST_FRAME_IAX)
				f.data.ptr = NULL;
			else
				f.data.ptr = empty;
			memset(&ies, 0, sizeof(ies));
		}

		if (!dcallno && iax2_allow_new(f.frametype, f.subclass.integer, 1)) {
			/* only set NEW_ALLOW if calltoken checks out */
			if (handle_call_token(fh, &ies, &sin, fd)) {
				ast_variables_destroy(ies.vars);
				return 1;
			}

			if (ies.calltoken && ies.calltokendata) {
				/* if we've gotten this far, and the calltoken ie data exists,
				 * then calltoken validation _MUST_ have taken place.  If calltoken
				 * data is provided, it is always validated reguardless of any
				 * calltokenoptional or requirecalltoken options */
				new = NEW_ALLOW_CALLTOKEN_VALIDATED;
			} else {
				new = NEW_ALLOW;
			}
		}
	} else {
		/* Don't know anything about it yet */
		f.frametype = AST_FRAME_NULL;
		f.subclass.integer = 0;
		memset(&ies, 0, sizeof(ies));
	}

	if (!fr->callno) {
		int check_dcallno = 0;

		/*
		 * We enforce accurate destination call numbers for ACKs.  This forces the other
		 * end to know the destination call number before call setup can complete.
		 *
		 * Discussed in the following thread:
		 *    http://lists.digium.com/pipermail/asterisk-dev/2008-May/033217.html 
		 */

		if ((ntohs(mh->callno) & IAX_FLAG_FULL) && ((f.frametype == AST_FRAME_IAX) && (f.subclass.integer == IAX_COMMAND_ACK))) {
			check_dcallno = 1;
		}

		if (!(fr->callno = find_callno(ntohs(mh->callno) & ~IAX_FLAG_FULL, dcallno, &sin, new, fd, check_dcallno))) {
			if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_NEW) {
				send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REJECT, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);
			} else if (f.frametype == AST_FRAME_IAX && (f.subclass.integer == IAX_COMMAND_REGREQ || f.subclass.integer == IAX_COMMAND_REGREL)) {
				send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REGREJ, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);
			}
			ast_variables_destroy(ies.vars);
			return 1;
		}
	}

	if (fr->callno > 0) {
		struct ast_callid *mount_callid;
		ast_mutex_lock(&iaxsl[fr->callno]);
		if (iaxs[fr->callno] && ((mount_callid = iax_pvt_callid_get(fr->callno)))) {
			/* Bind to thread */
			ast_callid_threadassoc_add(mount_callid);
			ast_callid_unref(mount_callid);
		}
	}

	if (!fr->callno || !iaxs[fr->callno]) {
		/* A call arrived for a nonexistent destination.  Unless it's an "inval"
		   frame, reply with an inval */
		if (ntohs(mh->callno) & IAX_FLAG_FULL) {
			/* We can only raw hangup control frames */
			if (((f.subclass.integer != IAX_COMMAND_INVAL) &&
				 (f.subclass.integer != IAX_COMMAND_TXCNT) &&
				 (f.subclass.integer != IAX_COMMAND_TXACC) &&
				 (f.subclass.integer != IAX_COMMAND_FWDOWNL))||
			    (f.frametype != AST_FRAME_IAX))
				raw_hangup(&sin, ntohs(fh->dcallno) & ~IAX_FLAG_RETRANS, ntohs(mh->callno) & ~IAX_FLAG_FULL,
				fd);
		}
		if (fr->callno > 0) 
			ast_mutex_unlock(&iaxsl[fr->callno]);
		ast_variables_destroy(ies.vars);
		return 1;
	}
	if (ast_test_flag64(iaxs[fr->callno], IAX_ENCRYPTED) && !decrypted) {
		if (decrypt_frame(fr->callno, fh, &f, &res)) {
			ast_log(LOG_NOTICE, "Packet Decrypt Failed!\n");
			ast_variables_destroy(ies.vars);
			ast_mutex_unlock(&iaxsl[fr->callno]);
			return 1;
		}
		decrypted = 1;
	}

#ifdef DEBUG_SUPPORT
	if (decrypted) {
		iax_outputframe(NULL, fh, 3, &sin, res - sizeof(*fh));
	}
#endif

	if (iaxs[fr->callno]->owner && fh->type == AST_FRAME_IAX &&
			(fh->csub == IAX_COMMAND_HANGUP
			|| fh->csub == IAX_COMMAND_REJECT
			|| fh->csub == IAX_COMMAND_REGREJ
			|| fh->csub == IAX_COMMAND_TXREJ)) {
		struct ast_control_pvt_cause_code *cause_code;
		int data_size = sizeof(*cause_code);
		char subclass[40] = "";

		/* get subclass text */
		iax_frame_subclass2str(fh->csub, subclass, sizeof(subclass));

		/* add length of "IAX2 " */
		data_size += 5;
		/* for IAX hangup frames, add length of () and number */
		data_size += 3;
		if (ies.causecode > 9) {
			data_size++;
		}
		if (ies.causecode > 99) {
			data_size++;
		}
		/* add length of subclass */
		data_size += strlen(subclass);

		cause_code = ast_alloca(data_size);
		ast_copy_string(cause_code->chan_name, ast_channel_name(iaxs[fr->callno]->owner), AST_CHANNEL_NAME);

		cause_code->ast_cause = ies.causecode;
		snprintf(cause_code->code, data_size - sizeof(*cause_code) + 1, "IAX2 %s(%d)", subclass, ies.causecode);

		iax2_lock_owner(fr->callno);
		if (iaxs[fr->callno] && iaxs[fr->callno]->owner) {
			ast_queue_control_data(iaxs[fr->callno]->owner, AST_CONTROL_PVT_CAUSE_CODE, cause_code, data_size);
			ast_channel_hangupcause_hash_set(iaxs[fr->callno]->owner, cause_code, data_size);
			ast_channel_unlock(iaxs[fr->callno]->owner);
		}
		if (!iaxs[fr->callno]) {
			ast_variables_destroy(ies.vars);
			ast_mutex_unlock(&iaxsl[fr->callno]);
			return 1;
		}
	}

	/* count this frame */
	iaxs[fr->callno]->frames_received++;

	if (!inaddrcmp(&sin, &iaxs[fr->callno]->addr) && !minivid &&
		f.subclass.integer != IAX_COMMAND_TXCNT &&		/* for attended transfer */
		f.subclass.integer != IAX_COMMAND_TXACC) {		/* for attended transfer */
		unsigned short new_peercallno;

		new_peercallno = (unsigned short) (ntohs(mh->callno) & ~IAX_FLAG_FULL);
		if (new_peercallno && new_peercallno != iaxs[fr->callno]->peercallno) {
			if (iaxs[fr->callno]->peercallno) {
				remove_by_peercallno(iaxs[fr->callno]);
			}
			iaxs[fr->callno]->peercallno = new_peercallno;
			store_by_peercallno(iaxs[fr->callno]);
		}
	}
	if (ntohs(mh->callno) & IAX_FLAG_FULL) {
		if (iaxdebug)
			ast_debug(1, "Received packet %d, (%d, %u)\n", fh->oseqno, f.frametype, f.subclass.integer);
		/* Check if it's out of order (and not an ACK or INVAL) */
		fr->oseqno = fh->oseqno;
		fr->iseqno = fh->iseqno;
		fr->ts = ntohl(fh->ts);
#ifdef IAXTESTS
		if (test_resync) {
			ast_debug(1, "Simulating frame ts resync, was %u now %u\n", fr->ts, fr->ts + test_resync);
			fr->ts += test_resync;
		}
#endif /* IAXTESTS */
#if 0
		if ( (ntohs(fh->dcallno) & IAX_FLAG_RETRANS) ||
		     ( (f.frametype != AST_FRAME_VOICE) && ! (f.frametype == AST_FRAME_IAX &&
								(f.subclass == IAX_COMMAND_NEW ||
								 f.subclass == IAX_COMMAND_AUTHREQ ||
								 f.subclass == IAX_COMMAND_ACCEPT ||
								 f.subclass == IAX_COMMAND_REJECT))      ) )
#endif
		if ((ntohs(fh->dcallno) & IAX_FLAG_RETRANS) || (f.frametype != AST_FRAME_VOICE))
			updatehistory = 0;
		if ((iaxs[fr->callno]->iseqno != fr->oseqno) &&
			(iaxs[fr->callno]->iseqno ||
				((f.subclass.integer != IAX_COMMAND_TXCNT) &&
				(f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */
				(f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */
				(f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */
				(f.subclass.integer != IAX_COMMAND_TXACC)) ||
				(f.frametype != AST_FRAME_IAX))) {
			if (
			 ((f.subclass.integer != IAX_COMMAND_ACK) &&
			  (f.subclass.integer != IAX_COMMAND_INVAL) &&
			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&
			  (f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */
			  (f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */
			  (f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */
			  (f.subclass.integer != IAX_COMMAND_TXACC) &&
			  (f.subclass.integer != IAX_COMMAND_VNAK)) ||
			  (f.frametype != AST_FRAME_IAX)) {
				/* If it's not an ACK packet, it's out of order. */
				ast_debug(1, "Packet arrived out of order (expecting %d, got %d) (frametype = %d, subclass = %d)\n",
					iaxs[fr->callno]->iseqno, fr->oseqno, f.frametype, f.subclass.integer);
				/* Check to see if we need to request retransmission,
				 * and take sequence number wraparound into account */
				if ((unsigned char) (iaxs[fr->callno]->iseqno - fr->oseqno) < 128) {
					/* If we've already seen it, ack it XXX There's a border condition here XXX */
					if ((f.frametype != AST_FRAME_IAX) ||
							((f.subclass.integer != IAX_COMMAND_ACK) && (f.subclass.integer != IAX_COMMAND_INVAL))) {
						ast_debug(1, "Acking anyway\n");
						/* XXX Maybe we should handle its ack to us, but then again, it's probably outdated anyway, and if
						   we have anything to send, we'll retransmit and get an ACK back anyway XXX */
						send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
					}
				} else {
					/* Send a VNAK requesting retransmission */
					iax2_vnak(fr->callno);
				}
				ast_variables_destroy(ies.vars);
				ast_mutex_unlock(&iaxsl[fr->callno]);
				return 1;
			}
		} else {
			/* Increment unless it's an ACK or VNAK */
			if (((f.subclass.integer != IAX_COMMAND_ACK) &&
			    (f.subclass.integer != IAX_COMMAND_INVAL) &&
			    (f.subclass.integer != IAX_COMMAND_TXCNT) &&
			    (f.subclass.integer != IAX_COMMAND_TXACC) &&
				(f.subclass.integer != IAX_COMMAND_VNAK)) ||
			    (f.frametype != AST_FRAME_IAX))
				iaxs[fr->callno]->iseqno++;
		}
		/* Ensure text frames are NULL-terminated */
		if (f.frametype == AST_FRAME_TEXT && thread->buf[res - 1] != '\0') {
			if (res < thread->buf_size)
				thread->buf[res++] = '\0';
			else /* Trims one character from the text message, but that's better than overwriting the end of the buffer. */
				thread->buf[res - 1] = '\0';
		}

		/* Handle implicit ACKing unless this is an INVAL, and only if this is 
		   from the real peer, not the transfer peer */
		if (!inaddrcmp(&sin, &iaxs[fr->callno]->addr) &&
		    ((f.subclass.integer != IAX_COMMAND_INVAL) ||
		     (f.frametype != AST_FRAME_IAX))) {
			unsigned char x;
			int call_to_destroy;
			/* First we have to qualify that the ACKed value is within our window */
			if (iaxs[fr->callno]->rseqno >= iaxs[fr->callno]->oseqno || (fr->iseqno >= iaxs[fr->callno]->rseqno && fr->iseqno < iaxs[fr->callno]->oseqno))
				x = fr->iseqno;
			else
				x = iaxs[fr->callno]->oseqno;
			if ((x != iaxs[fr->callno]->oseqno) || (iaxs[fr->callno]->oseqno == fr->iseqno)) {
				/* The acknowledgement is within our window.  Time to acknowledge everything
				   that it says to */
				for (x=iaxs[fr->callno]->rseqno; x != fr->iseqno; x++) {
					/* Ack the packet with the given timestamp */
					if (iaxdebug)
						ast_debug(1, "Cancelling transmission of packet %d\n", x);
					call_to_destroy = 0;
					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {
						/* If it's our call, and our timestamp, mark -1 retries */
						if (x == cur->oseqno) {
							cur->retries = -1;
							/* Destroy call if this is the end */
							if (cur->final)
								call_to_destroy = fr->callno;
						}
					}
					if (call_to_destroy) {
						if (iaxdebug)
							ast_debug(1, "Really destroying %d, having been acked on final message\n", call_to_destroy);
						ast_mutex_lock(&iaxsl[call_to_destroy]);
						iax2_destroy(call_to_destroy);
						ast_mutex_unlock(&iaxsl[call_to_destroy]);
					}
				}
				/* Note how much we've received acknowledgement for */
				if (iaxs[fr->callno])
					iaxs[fr->callno]->rseqno = fr->iseqno;
				else {
					/* Stop processing now */
					ast_variables_destroy(ies.vars);
					ast_mutex_unlock(&iaxsl[fr->callno]);
					return 1;
				}
			} else {
				ast_debug(1, "Received iseqno %d not within window %d->%d\n", fr->iseqno, iaxs[fr->callno]->rseqno, iaxs[fr->callno]->oseqno);
			}
		}
		if (inaddrcmp(&sin, &iaxs[fr->callno]->addr) &&
			((f.frametype != AST_FRAME_IAX) ||
			 ((f.subclass.integer != IAX_COMMAND_TXACC) &&
			  (f.subclass.integer != IAX_COMMAND_TXCNT)))) {
			/* Only messages we accept from a transfer host are TXACC and TXCNT */
			ast_variables_destroy(ies.vars);
			ast_mutex_unlock(&iaxsl[fr->callno]);
			return 1;
		}

		/* when we receive the first full frame for a new incoming channel,
		   it is safe to start the PBX on the channel because we have now
		   completed a 3-way handshake with the peer */
		if ((f.frametype == AST_FRAME_VOICE) ||
		    (f.frametype == AST_FRAME_VIDEO) ||
		    (f.frametype == AST_FRAME_IAX)) {
			if (ast_test_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART)) {
				ast_clear_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);
				if (!ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->chosenformat, NULL,
						  ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED))) {
					ast_variables_destroy(ies.vars);
					ast_mutex_unlock(&iaxsl[fr->callno]);
					return 1;
				}
			}

			if (ies.vars) {
				struct ast_datastore *variablestore = NULL;
				struct ast_variable *var, *prev = NULL;
				AST_LIST_HEAD(, ast_var_t) *varlist;

				iax2_lock_owner(fr->callno);
				if (!iaxs[fr->callno]) {
					ast_variables_destroy(ies.vars);
					ast_mutex_unlock(&iaxsl[fr->callno]);
					return 1;
				}
				if ((c = iaxs[fr->callno]->owner)) {
					varlist = ast_calloc(1, sizeof(*varlist));
					variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);

					if (variablestore && varlist) {
						variablestore->data = varlist;
						variablestore->inheritance = DATASTORE_INHERIT_FOREVER;
						AST_LIST_HEAD_INIT(varlist);
						ast_debug(1, "I can haz IAX vars?\n");
						for (var = ies.vars; var; var = var->next) {
							struct ast_var_t *newvar = ast_var_assign(var->name, var->value);
							if (prev) {
								ast_free(prev);
							}
							prev = var;
							if (!newvar) {
								/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */
								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");
							} else {
								AST_LIST_INSERT_TAIL(varlist, newvar, entries);
							}
						}
						if (prev) {
							ast_free(prev);
						}
						ies.vars = NULL;
						ast_channel_datastore_add(c, variablestore);
					} else {
						ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");
						if (variablestore) {
							ast_datastore_free(variablestore);
						}
						if (varlist) {
							ast_free(varlist);
						}
					}
					ast_channel_unlock(c);
				} else {
					/* No channel yet, so transfer the variables directly over to the pvt,
					 * for later inheritance. */
					ast_debug(1, "No channel, so populating IAXVARs to the pvt, as an intermediate step.\n");
					for (var = ies.vars; var && var->next; var = var->next);
					if (var) {
						var->next = iaxs[fr->callno]->iaxvars;
						iaxs[fr->callno]->iaxvars = ies.vars;
						ies.vars = NULL;
					}
				}
			}

			if (ies.vars) {
				ast_debug(1, "I have IAX variables, but they were not processed\n");
			}
		}

		/* once we receive our first IAX Full Frame that is not CallToken related, send all
		 * queued signaling frames that were being held. */
		if ((f.frametype == AST_FRAME_IAX) && (f.subclass.integer != IAX_COMMAND_CALLTOKEN) && iaxs[fr->callno]->hold_signaling) {
			send_signaling(iaxs[fr->callno]);
		}

		if (f.frametype == AST_FRAME_VOICE) {
			if (ast_format_to_old_bitfield(&f.subclass.format) != iaxs[fr->callno]->voiceformat) {
					iaxs[fr->callno]->voiceformat = ast_format_to_old_bitfield(&f.subclass.format);
					ast_debug(1, "Ooh, voice format changed to '%s'\n", ast_getformatname(&f.subclass.format));
					if (iaxs[fr->callno]->owner) {
						iax2_lock_owner(fr->callno);
						if (iaxs[fr->callno]) {
							if (iaxs[fr->callno]->owner) {
								struct ast_format_cap *orignative = ast_format_cap_dup(ast_channel_nativeformats(iaxs[fr->callno]->owner));
								struct ast_format_cap *native = ast_channel_nativeformats(iaxs[fr->callno]->owner);
								if (orignative) {
									ast_format_cap_set(native, &f.subclass.format);
									if (ast_channel_readformat(iaxs[fr->callno]->owner)->id) {
										ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));
									}
									ast_format_cap_copy(native, orignative);
									ast_channel_unlock(iaxs[fr->callno]->owner);
									orignative = ast_format_cap_destroy(orignative);
								}
							}
						} else {
							ast_debug(1, "Neat, somebody took away the channel at a magical time but i found it!\n");
							/* Free remote variables (if any) */
							if (ies.vars) {
								ast_variables_destroy(ies.vars);
								ast_debug(1, "I can haz iaxvars, but they is no good.  :-(\n");
								ies.vars = NULL;
							}
							ast_mutex_unlock(&iaxsl[fr->callno]);
							return 1;
						}
					}
			}
		}
		if (f.frametype == AST_FRAME_VIDEO) {
			if (f.subclass.format.id != ast_format_id_from_old_bitfield(iaxs[fr->callno]->videoformat)) {
				ast_debug(1, "Ooh, video format changed to %s\n", ast_getformatname(&f.subclass.format));
				iaxs[fr->callno]->videoformat = ast_format_to_old_bitfield(&f.subclass.format);
			}
		}
		if (f.frametype == AST_FRAME_CONTROL && iaxs[fr->callno]->owner) {
			if (f.subclass.integer == AST_CONTROL_BUSY) {
				ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_BUSY);
			} else if (f.subclass.integer == AST_CONTROL_CONGESTION) {
				ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_CONGESTION);
			}
		}
		if (f.frametype == AST_FRAME_IAX) {
			AST_SCHED_DEL(sched, iaxs[fr->callno]->initid);
			/* Handle the IAX pseudo frame itself */
			if (iaxdebug)
				ast_debug(1, "IAX subclass %d received\n", f.subclass.integer);

                        /* Update last ts unless the frame's timestamp originated with us. */
			if (iaxs[fr->callno]->last < fr->ts &&
                            f.subclass.integer != IAX_COMMAND_ACK &&
                            f.subclass.integer != IAX_COMMAND_PONG &&
                            f.subclass.integer != IAX_COMMAND_LAGRP) {
				iaxs[fr->callno]->last = fr->ts;
				if (iaxdebug)
					ast_debug(1, "For call=%d, set last=%d\n", fr->callno, fr->ts);
			}
			iaxs[fr->callno]->last_iax_message = f.subclass.integer;
			if (!iaxs[fr->callno]->first_iax_message) {
				iaxs[fr->callno]->first_iax_message = f.subclass.integer;
			}
			switch(f.subclass.integer) {
			case IAX_COMMAND_ACK:
				/* Do nothing */
				break;
			case IAX_COMMAND_QUELCH:
				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {
				        /* Generate Manager Hold event, if necessary*/
					if (iaxs[fr->callno]->owner) {
						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",
							"Status: On\r\n"
							"Channel: %s\r\n"
							"Uniqueid: %s\r\n",
							ast_channel_name(iaxs[fr->callno]->owner),
							ast_channel_uniqueid(iaxs[fr->callno]->owner));
					}

					ast_set_flag64(iaxs[fr->callno], IAX_QUELCH);
					if (ies.musiconhold) {
						iax2_lock_owner(fr->callno);
						if (!iaxs[fr->callno] || !iaxs[fr->callno]->owner) {
							break;
						}
						if (ast_bridged_channel(iaxs[fr->callno]->owner)) {
							const char *moh_suggest = iaxs[fr->callno]->mohsuggest;

							/*
							 * We already hold the owner lock so we do not
							 * need to check iaxs[fr->callno] after it returns.
							 */
							iax2_queue_control_data(fr->callno, AST_CONTROL_HOLD, 
								S_OR(moh_suggest, NULL),
								!ast_strlen_zero(moh_suggest) ? strlen(moh_suggest) + 1 : 0);
						}
						ast_channel_unlock(iaxs[fr->callno]->owner);
					}
				}
				break;
			case IAX_COMMAND_UNQUELCH:
				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {
					iax2_lock_owner(fr->callno);
					if (!iaxs[fr->callno]) {
						break;
					}
					/* Generate Manager Unhold event, if necessary */
					if (iaxs[fr->callno]->owner && ast_test_flag64(iaxs[fr->callno], IAX_QUELCH)) {
						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",
							"Status: Off\r\n"
							"Channel: %s\r\n"
							"Uniqueid: %s\r\n",
							ast_channel_name(iaxs[fr->callno]->owner),
							ast_channel_uniqueid(iaxs[fr->callno]->owner));
					}

					ast_clear_flag64(iaxs[fr->callno], IAX_QUELCH);
					if (!iaxs[fr->callno]->owner) {
						break;
					}
					if (ast_bridged_channel(iaxs[fr->callno]->owner)) {
						/*
						 * We already hold the owner lock so we do not
						 * need to check iaxs[fr->callno] after it returns.
						 */
						iax2_queue_control_data(fr->callno, AST_CONTROL_UNHOLD, NULL, 0);
					}
					ast_channel_unlock(iaxs[fr->callno]->owner);
				}
				break;
			case IAX_COMMAND_TXACC:
				if (iaxs[fr->callno]->transferring == TRANSFER_BEGIN) {
					/* Ack the packet with the given timestamp */
					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {
						/* Cancel any outstanding txcnt's */
						if (cur->transfer) {
							cur->retries = -1;
						}
					}
					memset(&ied1, 0, sizeof(ied1));
					iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->callno);
					send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREADY, 0, ied1.buf, ied1.pos, -1);
					iaxs[fr->callno]->transferring = TRANSFER_READY;
				}
				break;
			case IAX_COMMAND_NEW:
				/* Ignore if it's already up */
				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD))
					break;
				if (ies.provverpres && ies.serviceident && sin.sin_addr.s_addr) {
					ast_mutex_unlock(&iaxsl[fr->callno]);
					check_provisioning(&sin, fd, ies.serviceident, ies.provver);
					ast_mutex_lock(&iaxsl[fr->callno]);
					if (!iaxs[fr->callno]) {
						break;
					}
				}
				/* If we're in trunk mode, do it now, and update the trunk number in our frame before continuing */
				if (ast_test_flag64(iaxs[fr->callno], IAX_TRUNK)) {
					int new_callno;
					if ((new_callno = make_trunk(fr->callno, 1)) != -1)
						fr->callno = new_callno;
				}
				/* For security, always ack immediately */
				if (delayreject)
					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
				if (check_access(fr->callno, &sin, &ies)) {
					/* They're not allowed on */
					auth_fail(fr->callno, IAX_COMMAND_REJECT);
					if (authdebug)
						ast_log(LOG_NOTICE, "Rejected connect attempt from %s, who was trying to reach '%s@%s'\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);
					break;
				}
				if (ast_strlen_zero(iaxs[fr->callno]->secret) && ast_test_flag64(iaxs[fr->callno], IAX_FORCE_ENCRYPT)) {
					auth_fail(fr->callno, IAX_COMMAND_REJECT);
					ast_log(LOG_WARNING, "Rejected connect attempt.  No secret present while force encrypt enabled.\n");
					break;
				}
				if (strcasecmp(iaxs[fr->callno]->exten, "TBD")) {
					const char *context, *exten, *cid_num;

					context = ast_strdupa(iaxs[fr->callno]->context);
					exten = ast_strdupa(iaxs[fr->callno]->exten);
					cid_num = ast_strdupa(iaxs[fr->callno]->cid_num);

					/* This might re-enter the IAX code and need the lock */
					ast_mutex_unlock(&iaxsl[fr->callno]);
					exists = ast_exists_extension(NULL, context, exten, 1, cid_num);
					ast_mutex_lock(&iaxsl[fr->callno]);

					if (!iaxs[fr->callno]) {
						break;
					}
				} else
					exists = 0;
				/* Get OSP token if it does exist */
				save_osptoken(fr, &ies);
				if (ast_strlen_zero(iaxs[fr->callno]->secret) && ast_strlen_zero(iaxs[fr->callno]->inkeys)) {
					if (strcmp(iaxs[fr->callno]->exten, "TBD") && !exists) {
						memset(&ied0, 0, sizeof(ied0));
						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");
						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);
						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);
						if (!iaxs[fr->callno]) {
							break;
						}
						if (authdebug)
							ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);
					} else {
						/* Select an appropriate format */

						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {
							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {
								using_prefs = "reqonly";
							} else {
								using_prefs = "disabled";
							}
							format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;
							memset(&pref, 0, sizeof(pref));
							strcpy(caller_pref_buf, "disabled");
							strcpy(host_pref_buf, "disabled");
						} else {
							struct ast_format tmpfmt;
							using_prefs = "mine";
							/* If the information elements are in here... use them */
							if (ies.codec_prefs)
								ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);
							if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {
								/* If we are codec_first_choice we let the caller have the 1st shot at picking the codec.*/
								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {
									pref = iaxs[fr->callno]->rprefs;
									using_prefs = "caller";
								} else {
									pref = iaxs[fr->callno]->prefs;
								}
							} else
								pref = iaxs[fr->callno]->prefs;

							format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);
							ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);
							ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);
						}
						if (!format) {
							if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP))
								format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;
							if (!format) {
								memset(&ied0, 0, sizeof(ied0));
								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");
								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);
								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);
								if (!iaxs[fr->callno]) {
									break;
								}
								if (authdebug) {
									char tmp[256], tmp2[256], tmp3[256];
									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {
										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",
											ast_inet_ntoa(sin.sin_addr),
											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),
											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));
									} else {
										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",
											ast_inet_ntoa(sin.sin_addr),
											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),
											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),
											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));
									}
								}
							} else {
								/* Pick one... */
								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {
									if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))
										format = 0;
								} else {
									if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {
										using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";
										memset(&pref, 0, sizeof(pref));
										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);
										strcpy(caller_pref_buf,"disabled");
										strcpy(host_pref_buf,"disabled");
									} else {
										struct ast_format tmpfmt;
										using_prefs = "mine";
										if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {
											/* Do the opposite of what we tried above. */
											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {
												pref = iaxs[fr->callno]->prefs;
											} else {
												pref = iaxs[fr->callno]->rprefs;
												using_prefs = "caller";
											}
											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);
										} else /* if no codec_prefs IE do it the old way */
											format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);
									}
								}

								if (!format) {
									char tmp[256], tmp2[256], tmp3[256];
									memset(&ied0, 0, sizeof(ied0));
									iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");
									iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);
									ast_log(LOG_ERROR, "No best format in '%s'???\n", iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));
									send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);
									if (!iaxs[fr->callno]) {
										break;
									}
									if (authdebug) {
										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",
											ast_inet_ntoa(sin.sin_addr),
											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),
											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),
											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));
									}
									ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);
									break;
								}
							}
						}
						if (format) {
							/* No authentication required, let them in */
							memset(&ied1, 0, sizeof(ied1));
							iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);
							iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);
							send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);
							if (strcmp(iaxs[fr->callno]->exten, "TBD")) {
								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);
								ast_verb(3, "Accepting UNAUTHENTICATED call from %s:\n"
												"%srequested format = %s,\n"
												"%srequested prefs = %s,\n"
												"%sactual format = %s,\n"
												"%shost prefs = %s,\n"
												"%spriority = %s\n",
												ast_inet_ntoa(sin.sin_addr), 
												VERBOSE_PREFIX_4,
												iax2_getformatname(iaxs[fr->callno]->peerformat), 
												VERBOSE_PREFIX_4,
												caller_pref_buf,
												VERBOSE_PREFIX_4,
												iax2_getformatname(format), 
												VERBOSE_PREFIX_4,
												host_pref_buf, 
												VERBOSE_PREFIX_4,
												using_prefs);

								iaxs[fr->callno]->chosenformat = format;

								/* Since this is a new call, we should go ahead and set the callid for it. */
								iax_pvt_callid_new(fr->callno);
								ast_set_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);
							} else {
								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);
								/* If this is a TBD call, we're ready but now what...  */
								ast_verb(3, "Accepted unauthenticated TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));
							}
						}
					}
					break;
				}
				if (iaxs[fr->callno]->authmethods & IAX_AUTH_MD5)
					merge_encryption(iaxs[fr->callno],ies.encmethods);
				else
					iaxs[fr->callno]->encmethods = 0;
				if (!authenticate_request(fr->callno) && iaxs[fr->callno])
					ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED);
				break;
			case IAX_COMMAND_DPREQ:
				/* Request status in the dialplan */
				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD) &&
					!ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED) && ies.called_number) {
					if (iaxcompat) {
						/* Spawn a thread for the lookup */
						spawn_dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num);
					} else {
						/* Just look it up */
						dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num, 1);
					}
				}
				break;
			case IAX_COMMAND_HANGUP:
				ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);
				ast_debug(1, "Immediately destroying %d, having received hangup\n", fr->callno);
				/* Set hangup cause according to remote and hangupsource */
				if (iaxs[fr->callno]->owner) {
					set_hangup_source_and_cause(fr->callno, ies.causecode);
					if (!iaxs[fr->callno]) {
						break;
					}
				}

				/* Send ack immediately, before we destroy */
				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
				iax2_destroy(fr->callno);
				break;
			case IAX_COMMAND_REJECT:
				/* Set hangup cause according to remote and hangup source */
				if (iaxs[fr->callno]->owner) {
					set_hangup_source_and_cause(fr->callno, ies.causecode);
					if (!iaxs[fr->callno]) {
						break;
					}
				}

				if (!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)) {
					if (iaxs[fr->callno]->owner && authdebug)
						ast_log(LOG_WARNING, "Call rejected by %s: %s\n",
							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr),
							ies.cause ? ies.cause : "<Unknown>");
					ast_debug(1, "Immediately destroying %d, having received reject\n",
						fr->callno);
				}
				/* Send ack immediately, before we destroy */
				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK,
						       fr->ts, NULL, 0, fr->iseqno);
				if (!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION))
					iaxs[fr->callno]->error = EPERM;
				iax2_destroy(fr->callno);
				break;
			case IAX_COMMAND_TRANSFER:
			{
				struct ast_channel *bridged_chan;
				struct ast_channel *owner;

				iax2_lock_owner(fr->callno);
				if (!iaxs[fr->callno]) {
					/* Initiating call went away before we could transfer. */
					break;
				}
				owner = iaxs[fr->callno]->owner;
				bridged_chan = owner ? ast_bridged_channel(owner) : NULL;
				if (bridged_chan && ies.called_number) {
					const char *context;

					context = ast_strdupa(iaxs[fr->callno]->context);

					ast_channel_ref(owner);
					ast_channel_ref(bridged_chan);
					ast_channel_unlock(owner);
					ast_mutex_unlock(&iaxsl[fr->callno]);

					/* Set BLINDTRANSFER channel variables */
					pbx_builtin_setvar_helper(owner, "BLINDTRANSFER", ast_channel_name(bridged_chan));
					pbx_builtin_setvar_helper(bridged_chan, "BLINDTRANSFER", ast_channel_name(owner));

					/* DO NOT hold any locks while calling ast_parking_ext_valid() */
					if (ast_parking_ext_valid(ies.called_number, owner, context)) {
						ast_debug(1, "Parking call '%s'\n", ast_channel_name(bridged_chan));
						if (iax_park(bridged_chan, owner, ies.called_number, context)) {
							ast_log(LOG_WARNING, "Failed to park call '%s'\n",
								ast_channel_name(bridged_chan));
						}
					} else {
						if (ast_async_goto(bridged_chan, context, ies.called_number, 1)) {
							ast_log(LOG_WARNING,
								"Async goto of '%s' to '%s@%s' failed\n",
								ast_channel_name(bridged_chan), ies.called_number, context);
						} else {
							ast_debug(1, "Async goto of '%s' to '%s@%s' started\n",
								ast_channel_name(bridged_chan), ies.called_number, context);
						}
					}
					ast_channel_unref(owner);
					ast_channel_unref(bridged_chan);

					ast_mutex_lock(&iaxsl[fr->callno]);
				} else {
					ast_debug(1, "Async goto not applicable on call %d\n", fr->callno);
					if (owner) {
						ast_channel_unlock(owner);
					}
				}

				break;
			}
			case IAX_COMMAND_ACCEPT:
				/* Ignore if call is already up or needs authentication or is a TBD */
				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD | IAX_STATE_AUTHENTICATED))
					break;
				if (ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)) {
					/* Send ack immediately, before we destroy */
					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
					iax2_destroy(fr->callno);
					break;
				}
				if (ies.format) {
					iaxs[fr->callno]->peerformat = ies.format;
				} else {
					if (iaxs[fr->callno]->owner)
						iaxs[fr->callno]->peerformat = ast_format_cap_to_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner));
					else
						iaxs[fr->callno]->peerformat = iaxs[fr->callno]->capability;
				}
				ast_verb(3, "Call accepted by %s (format %s)\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iax2_getformatname(iaxs[fr->callno]->peerformat));
				if (!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)) {
					memset(&ied0, 0, sizeof(ied0));
					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");
					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);
					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);
					if (!iaxs[fr->callno]) {
						break;
					}
					if (authdebug) {
						char tmp1[256], tmp2[256];
						ast_log(LOG_NOTICE, "Rejected call to %s, format %s incompatible with our capability %s.\n",
							ast_inet_ntoa(sin.sin_addr),
							iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),
							iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));
					}
				} else {
					ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);
					iax2_lock_owner(fr->callno);
					if (iaxs[fr->callno] && iaxs[fr->callno]->owner) {
						char tmp[256];
						/* Switch us to use a compatible format */
						ast_format_cap_from_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner), iaxs[fr->callno]->peerformat);
						ast_verb(3, "Format for call is %s\n", ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(iaxs[fr->callno]->owner)));

						/* Setup read/write formats properly. */
						if (ast_channel_writeformat(iaxs[fr->callno]->owner)->id)
							ast_set_write_format(iaxs[fr->callno]->owner, ast_channel_writeformat(iaxs[fr->callno]->owner));
						if (ast_channel_readformat(iaxs[fr->callno]->owner)->id)
							ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));
						ast_channel_unlock(iaxs[fr->callno]->owner);
					}
				}
				if (iaxs[fr->callno]) {
					AST_LIST_LOCK(&dpcache);
					AST_LIST_TRAVERSE(&iaxs[fr->callno]->dpentries, dp, peer_list)
						if (!(dp->flags & CACHE_FLAG_TRANSMITTED))
							iax2_dprequest(dp, fr->callno);
					AST_LIST_UNLOCK(&dpcache);
				}
				break;
			case IAX_COMMAND_POKE:
				/* Send back a pong packet with the original timestamp */
				send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, NULL, 0, -1);
				break;
			case IAX_COMMAND_PING:
			{
				struct iax_ie_data pingied;
				construct_rr(iaxs[fr->callno], &pingied);
				/* Send back a pong packet with the original timestamp */
				send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, pingied.buf, pingied.pos, -1);
			}
				break;
			case IAX_COMMAND_PONG:
				/* Calculate ping time */
				iaxs[fr->callno]->pingtime =  calc_timestamp(iaxs[fr->callno], 0, &f) - fr->ts;
				/* save RR info */
				save_rr(fr, &ies);

				/* Good time to write jb stats for this call */
				log_jitterstats(fr->callno);

				if (iaxs[fr->callno]->peerpoke) {
					peer = iaxs[fr->callno]->peerpoke;
					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms)) {
						if (iaxs[fr->callno]->pingtime <= peer->maxms) {
							ast_log(LOG_NOTICE, "Peer '%s' is now REACHABLE! Time: %d\n", peer->name, iaxs[fr->callno]->pingtime);
							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Reachable\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 
							ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "IAX2/%s", peer->name); /* Activate notification */
						}
					} else if ((peer->historicms > 0) && (peer->historicms <= peer->maxms)) {
						if (iaxs[fr->callno]->pingtime > peer->maxms) {
							ast_log(LOG_NOTICE, "Peer '%s' is now TOO LAGGED (%d ms)!\n", peer->name, iaxs[fr->callno]->pingtime);
							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Lagged\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 
							ast_devstate_changed(AST_DEVICE_UNAVAILABLE, AST_DEVSTATE_CACHABLE, "IAX2/%s", peer->name); /* Activate notification */
						}
					}
					peer->lastms = iaxs[fr->callno]->pingtime;
					if (peer->smoothing && (peer->lastms > -1))
						peer->historicms = (iaxs[fr->callno]->pingtime + peer->historicms) / 2;
					else if (peer->smoothing && peer->lastms < 0)
						peer->historicms = (0 + peer->historicms) / 2;
					else					
						peer->historicms = iaxs[fr->callno]->pingtime;

					/* Remove scheduled iax2_poke_noanswer */
					if (peer->pokeexpire > -1) {
						if (!AST_SCHED_DEL(sched, peer->pokeexpire)) {
							peer_unref(peer);
							peer->pokeexpire = -1;
						}
					}
					/* Schedule the next cycle */
					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms))
						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_peer_s, peer_ref(peer));
					else
						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqok, iax2_poke_peer_s, peer_ref(peer));
					if (peer->pokeexpire == -1)
						peer_unref(peer);
					/* and finally send the ack */
					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
					/* And wrap up the qualify call */
					iax2_destroy(fr->callno);
					peer->callno = 0;
					ast_debug(1, "Peer %s: got pong, lastms %d, historicms %d, maxms %d\n", peer->name, peer->lastms, peer->historicms, peer->maxms);
				}
				break;
			case IAX_COMMAND_LAGRQ:
			case IAX_COMMAND_LAGRP:
				f.src = "LAGRQ";
				f.mallocd = 0;
				f.offset = 0;
				f.samples = 0;
				iax_frame_wrap(fr, &f);
				if (f.subclass.integer == IAX_COMMAND_LAGRQ) {
					/* Received a LAGRQ - echo back a LAGRP */
					fr->af.subclass.integer = IAX_COMMAND_LAGRP;
					iax2_send(iaxs[fr->callno], &fr->af, fr->ts, -1, 0, 0, 0);
				} else {
					/* Received LAGRP in response to our LAGRQ */
					unsigned int ts;
					/* This is a reply we've been given, actually measure the difference */
					ts = calc_timestamp(iaxs[fr->callno], 0, &fr->af);
					iaxs[fr->callno]->lag = ts - fr->ts;
					if (iaxdebug)
						ast_debug(1, "Peer %s lag measured as %dms\n",
							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->lag);
				}
				break;
			case IAX_COMMAND_AUTHREQ:
				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)) {
					ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");
					break;
				}
				if (authenticate_reply(iaxs[fr->callno], &iaxs[fr->callno]->addr, &ies, iaxs[fr->callno]->secret, iaxs[fr->callno]->outkey)) {
					struct ast_frame hangup_fr = { .frametype = AST_FRAME_CONTROL,
								.subclass.integer = AST_CONTROL_HANGUP,
					};
					ast_log(LOG_WARNING, 
						"I don't know how to authenticate %s to %s\n", 
						ies.username ? ies.username : "<unknown>", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr));
					iax2_queue_frame(fr->callno, &hangup_fr);
				}
				break;
			case IAX_COMMAND_AUTHREP:
				/* For security, always ack immediately */
				if (delayreject)
					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
				/* Ignore once we've started */
				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)) {
					ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");
					break;
				}
				if (authenticate_verify(iaxs[fr->callno], &ies)) {
					if (authdebug)
						ast_log(LOG_NOTICE, "Host %s failed to authenticate as %s\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->username);
					memset(&ied0, 0, sizeof(ied0));
					auth_fail(fr->callno, IAX_COMMAND_REJECT);
					break;
				}
				if (strcasecmp(iaxs[fr->callno]->exten, "TBD")) {
					/* This might re-enter the IAX code and need the lock */
					exists = ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num);
				} else
					exists = 0;
				if (strcmp(iaxs[fr->callno]->exten, "TBD") && !exists) {
					if (authdebug)
						ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);
					memset(&ied0, 0, sizeof(ied0));
					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");
					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);
					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);
					if (!iaxs[fr->callno]) {
						break;
					}
				} else {
					/* Select an appropriate format */
					if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {
						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {
							using_prefs = "reqonly";
						} else {
							using_prefs = "disabled";
						}
						format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;
						memset(&pref, 0, sizeof(pref));
						strcpy(caller_pref_buf, "disabled");
						strcpy(host_pref_buf, "disabled");
					} else {
						struct ast_format tmpfmt;
						using_prefs = "mine";
						if (ies.codec_prefs)
							ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);
						if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {
							if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {
								pref = iaxs[fr->callno]->rprefs;
								using_prefs = "caller";
							} else {
								pref = iaxs[fr->callno]->prefs;
							}
						} else /* if no codec_prefs IE do it the old way */
							pref = iaxs[fr->callno]->prefs;
						format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);
						ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);
						ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);
					}
					if (!format) {
						char tmp1[256], tmp2[256], tmp3[256];
						if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {
							ast_debug(1, "We don't do requested format %s, falling back to peer capability '%s'\n",
								iax2_getformatname(iaxs[fr->callno]->peerformat),
								iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability));
							format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;
						}
						if (!format) {
							if (authdebug) {
								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {
									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n", ast_inet_ntoa(sin.sin_addr),
										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),
										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));
								} else {
									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",
										ast_inet_ntoa(sin.sin_addr),
										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),
										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),
										iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));
								}
							}
							memset(&ied0, 0, sizeof(ied0));
							iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");
							iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);
							send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);
							if (!iaxs[fr->callno]) {
								break;
							}
						} else {
							/* Pick one... */
							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {
								if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))
									format = 0;
							} else {
								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {
									using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";
									memset(&pref, 0, sizeof(pref));
									format = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ?
										iaxs[fr->callno]->peerformat : iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);
									strcpy(caller_pref_buf,"disabled");
									strcpy(host_pref_buf,"disabled");
								} else {
									struct ast_format tmpfmt;
									using_prefs = "mine";
									if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {
										/* Do the opposite of what we tried above. */
										if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {
											pref = iaxs[fr->callno]->prefs;
										} else {
											pref = iaxs[fr->callno]->rprefs;
											using_prefs = "caller";
										}
										format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);
									} else /* if no codec_prefs IE do it the old way */
										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);	
								}
							}
							if (!format) {
								char tmp1[256], tmp2[256], tmp3[256];
								ast_log(LOG_ERROR, "No best format in %s???\n",
									iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));
								if (authdebug) {
									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {
										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",
											ast_inet_ntoa(sin.sin_addr),
											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),
											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));
									} else {
										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",
											ast_inet_ntoa(sin.sin_addr),
											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),
											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),
											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));
									}
								}
								memset(&ied0, 0, sizeof(ied0));
								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");
								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);
								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);
								if (!iaxs[fr->callno]) {
									break;
								}
							}
						}
					}
					if (format) {
						/* Authentication received */
						memset(&ied1, 0, sizeof(ied1));
						iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);
						iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);
						send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);
						if (strcmp(iaxs[fr->callno]->exten, "TBD")) {
							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);
							ast_verb(3, "Accepting AUTHENTICATED call from %s:\n"
											"%srequested format = %s,\n"
											"%srequested prefs = %s,\n"
											"%sactual format = %s,\n"
											"%shost prefs = %s,\n"
											"%spriority = %s\n", 
											ast_inet_ntoa(sin.sin_addr), 
											VERBOSE_PREFIX_4,
											iax2_getformatname(iaxs[fr->callno]->peerformat),
											VERBOSE_PREFIX_4,
											caller_pref_buf,
											VERBOSE_PREFIX_4,
											iax2_getformatname(format),
											VERBOSE_PREFIX_4,
											host_pref_buf,
											VERBOSE_PREFIX_4,
											using_prefs);

							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);
							if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, format, NULL, 1)))
								iax2_destroy(fr->callno);
							else if (ies.vars) {
								struct ast_datastore *variablestore;
								struct ast_variable *var, *prev = NULL;
								AST_LIST_HEAD(, ast_var_t) *varlist;
								varlist = ast_calloc(1, sizeof(*varlist));
								variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);
								if (variablestore && varlist) {
									variablestore->data = varlist;
									variablestore->inheritance = DATASTORE_INHERIT_FOREVER;
									AST_LIST_HEAD_INIT(varlist);
									ast_debug(1, "I can haz IAX vars? w00t\n");
									for (var = ies.vars; var; var = var->next) {
										struct ast_var_t *newvar = ast_var_assign(var->name, var->value);
										if (prev)
											ast_free(prev);
										prev = var;
										if (!newvar) {
											/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */
											ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");
										} else {
											AST_LIST_INSERT_TAIL(varlist, newvar, entries);
										}
									}
									if (prev)
										ast_free(prev);
									ies.vars = NULL;
									ast_channel_datastore_add(c, variablestore);
								} else {
									ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");
									if (variablestore)
										ast_datastore_free(variablestore);
									if (varlist)
										ast_free(varlist);
								}
							}
						} else {
							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);
							/* If this is a TBD call, we're ready but now what...  */
							ast_verb(3, "Accepted AUTHENTICATED TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));
							if (ast_test_flag64(iaxs[fr->callno], IAX_IMMEDIATE)) {
								goto immediatedial;
							}
						}
					}
				}
				break;
			case IAX_COMMAND_DIAL:
immediatedial:
				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD)) {
					ast_clear_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);
					ast_string_field_set(iaxs[fr->callno], exten, ies.called_number ? ies.called_number : "s");
					if (!ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num)) {
						if (authdebug)
							ast_log(LOG_NOTICE, "Rejected dial attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);
						memset(&ied0, 0, sizeof(ied0));
						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");
						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);
						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);
						if (!iaxs[fr->callno]) {
							break;
						}
					} else {
						char tmp[256];
						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);
						ast_verb(3, "Accepting DIAL from %s, formats = %s\n",
							ast_inet_ntoa(sin.sin_addr),
							iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat));
						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);
						send_command(iaxs[fr->callno], AST_FRAME_CONTROL, AST_CONTROL_PROGRESS, 0, NULL, 0, -1);
						if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->peerformat, NULL, 1)))
							iax2_destroy(fr->callno);
						else if (ies.vars) {
							struct ast_datastore *variablestore;
							struct ast_variable *var, *prev = NULL;
							AST_LIST_HEAD(, ast_var_t) *varlist;
							varlist = ast_calloc(1, sizeof(*varlist));
							variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);
							ast_debug(1, "I can haz IAX vars? w00t\n");
							if (variablestore && varlist) {
								variablestore->data = varlist;
								variablestore->inheritance = DATASTORE_INHERIT_FOREVER;
								AST_LIST_HEAD_INIT(varlist);
								for (var = ies.vars; var; var = var->next) {
									struct ast_var_t *newvar = ast_var_assign(var->name, var->value);
									if (prev)
										ast_free(prev);
									prev = var;
									if (!newvar) {
										/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */
										ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");
									} else {
										AST_LIST_INSERT_TAIL(varlist, newvar, entries);
									}
								}
								if (prev)
									ast_free(prev);
								ies.vars = NULL;
								ast_channel_datastore_add(c, variablestore);
							} else {
								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");
								if (variablestore)
									ast_datastore_free(variablestore);
								if (varlist)
									ast_free(varlist);
							}
						}
					}
				}
				break;
			case IAX_COMMAND_INVAL:
				iaxs[fr->callno]->error = ENOTCONN;
				ast_debug(1, "Immediately destroying %d, having received INVAL\n", fr->callno);
				iax2_destroy(fr->callno);
				ast_debug(1, "Destroying call %d\n", fr->callno);
				break;
			case IAX_COMMAND_VNAK:
				ast_debug(1, "Received VNAK: resending outstanding frames\n");
				/* Force retransmission */
				vnak_retransmit(fr->callno, fr->iseqno);
				break;
			case IAX_COMMAND_REGREQ:
			case IAX_COMMAND_REGREL:
				/* For security, always ack immediately */
				if (delayreject)
					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
				if (register_verify(fr->callno, &sin, &ies)) {
					if (!iaxs[fr->callno]) {
						break;
					}
					/* Send delayed failure */
					auth_fail(fr->callno, IAX_COMMAND_REGREJ);
					break;
				}
				if (!iaxs[fr->callno]) {
					break;
				}
				if ((ast_strlen_zero(iaxs[fr->callno]->secret) && ast_strlen_zero(iaxs[fr->callno]->inkeys)) ||
						ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED)) {

					if (f.subclass.integer == IAX_COMMAND_REGREL) {
						memset(&sin, 0, sizeof(sin));
						sin.sin_family = AF_INET;
					}
					if (update_registry(&sin, fr->callno, ies.devicetype, fd, ies.refresh)) {
						ast_log(LOG_WARNING, "Registry error\n");
					}
					if (!iaxs[fr->callno]) {
						break;
					}
					if (ies.provverpres && ies.serviceident && sin.sin_addr.s_addr) {
						ast_mutex_unlock(&iaxsl[fr->callno]);
						check_provisioning(&sin, fd, ies.serviceident, ies.provver);
						ast_mutex_lock(&iaxsl[fr->callno]);
					}
					break;
				}
				registry_authrequest(fr->callno);
				break;
			case IAX_COMMAND_REGACK:
				if (iax2_ack_registry(&ies, &sin, fr->callno)) 
					ast_log(LOG_WARNING, "Registration failure\n");
				/* Send ack immediately, before we destroy */
				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
				iax2_destroy(fr->callno);
				break;
			case IAX_COMMAND_REGREJ:
				if (iaxs[fr->callno]->reg) {
					if (authdebug) {
						ast_log(LOG_NOTICE, "Registration of '%s' rejected: '%s' from: '%s'\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>", ast_inet_ntoa(sin.sin_addr));
						manager_event(EVENT_FLAG_SYSTEM, "Registry", "ChannelType: IAX2\r\nUsername: %s\r\nStatus: Rejected\r\nCause: %s\r\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>");
					}
					iaxs[fr->callno]->reg->regstate = REG_STATE_REJECTED;
				}
				/* Send ack immediately, before we destroy */
				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
				iax2_destroy(fr->callno);
				break;
			case IAX_COMMAND_REGAUTH:
				/* Authentication request */
				if (registry_rerequest(&ies, fr->callno, &sin)) {
					memset(&ied0, 0, sizeof(ied0));
					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No authority found");
					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_FACILITY_NOT_SUBSCRIBED);
					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);
				}
				break;
			case IAX_COMMAND_TXREJ:
				iaxs[fr->callno]->transferring = 0;
				ast_verb(3, "Channel '%s' unable to transfer\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");
				memset(&iaxs[fr->callno]->transfer, 0, sizeof(iaxs[fr->callno]->transfer));
				if (iaxs[fr->callno]->bridgecallno) {
					if (iaxs[iaxs[fr->callno]->bridgecallno]->transferring) {
						iaxs[iaxs[fr->callno]->bridgecallno]->transferring = 0;
						send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREJ, 0, NULL, 0, -1);
					}
				}
				break;
			case IAX_COMMAND_TXREADY:
				if ((iaxs[fr->callno]->transferring == TRANSFER_BEGIN) ||
				    (iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)) {
					if (iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)
						iaxs[fr->callno]->transferring = TRANSFER_MREADY;
					else
						iaxs[fr->callno]->transferring = TRANSFER_READY;
					ast_verb(3, "Channel '%s' ready to transfer\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");
					if (iaxs[fr->callno]->bridgecallno) {
						if ((iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_READY) ||
						    (iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_MREADY)) {
							/* They're both ready, now release them. */
							if (iaxs[fr->callno]->transferring == TRANSFER_MREADY) {
								ast_verb(3, "Attempting media bridge of %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",
										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");

								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_MEDIA;
								iaxs[fr->callno]->transferring = TRANSFER_MEDIA;

								memset(&ied0, 0, sizeof(ied0));
								memset(&ied1, 0, sizeof(ied1));
								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);
								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);
								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied0.buf, ied0.pos, -1);
								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied1.buf, ied1.pos, -1);
							} else {
								ast_verb(3, "Releasing %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",
										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");

								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_RELEASED;
								iaxs[fr->callno]->transferring = TRANSFER_RELEASED;
								ast_set_flag64(iaxs[iaxs[fr->callno]->bridgecallno], IAX_ALREADYGONE);
								ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);

								/* Stop doing lag & ping requests */
								stop_stuff(fr->callno);
								stop_stuff(iaxs[fr->callno]->bridgecallno);

								memset(&ied0, 0, sizeof(ied0));
								memset(&ied1, 0, sizeof(ied1));
								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);
								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);
								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied0.buf, ied0.pos, -1);
								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied1.buf, ied1.pos, -1);
							}

						}
					}
				}
				break;
			case IAX_COMMAND_TXREQ:
				try_transfer(iaxs[fr->callno], &ies);
				break;
			case IAX_COMMAND_TXCNT:
				if (iaxs[fr->callno]->transferring)
					send_command_transfer(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXACC, 0, NULL, 0);
				break;
			case IAX_COMMAND_TXREL:
				/* Send ack immediately, rather than waiting until we've changed addresses */
				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
				complete_transfer(fr->callno, &ies);
				stop_stuff(fr->callno);	/* for attended transfer to work with libiax */
				break;	
			case IAX_COMMAND_TXMEDIA:
				if (iaxs[fr->callno]->transferring == TRANSFER_READY) {
					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {
						/* Cancel any outstanding frames and start anew */
						if (cur->transfer) {
							cur->retries = -1;
						}
					}
					/* Start sending our media to the transfer address, but otherwise leave the call as-is */
					iaxs[fr->callno]->transferring = TRANSFER_MEDIAPASS;
				}
				break;
			case IAX_COMMAND_RTKEY:
				if (!IAX_CALLENCRYPTED(iaxs[fr->callno])) {
					ast_log(LOG_WARNING, 
						"we've been told to rotate our encryption key, "
						"but this isn't an encrypted call. bad things will happen.\n"
					);
					break;
				}

				IAX_DEBUGDIGEST("Receiving", ies.challenge);

				ast_aes_set_decrypt_key((unsigned char *) ies.challenge, &iaxs[fr->callno]->dcx);
				break;
			case IAX_COMMAND_DPREP:
				complete_dpreply(iaxs[fr->callno], &ies);
				break;
			case IAX_COMMAND_UNSUPPORT:
				ast_log(LOG_NOTICE, "Peer did not understand our iax command '%d'\n", ies.iax_unknown);
				break;
			case IAX_COMMAND_FWDOWNL:
				/* Firmware download */
				if (!ast_test_flag64(&globalflags, IAX_ALLOWFWDOWNLOAD)) {
					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_UNSUPPORT, 0, NULL, 0, -1);
					break;
				}
				memset(&ied0, 0, sizeof(ied0));
				res = iax_firmware_append(&ied0, (unsigned char *)ies.devicetype, ies.fwdesc);
				if (res < 0)
					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);
				else if (res > 0)
					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1);
				else
					send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1);
				break;
			case IAX_COMMAND_CALLTOKEN:
			{
				struct iax_frame *cur;
				/* find last sent frame */
				if ((cur = AST_LIST_LAST(&frame_queue[fr->callno])) && ies.calltoken && ies.calltokendata) {
					resend_with_token(fr->callno, cur, (char *) ies.calltokendata);
				}
				break;
			}
			default:
				ast_debug(1, "Unknown IAX command %d on %d/%d\n", f.subclass.integer, fr->callno, iaxs[fr->callno]->peercallno);
				memset(&ied0, 0, sizeof(ied0));
				iax_ie_append_byte(&ied0, IAX_IE_IAX_UNKNOWN, f.subclass.integer);
				send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_UNSUPPORT, 0, ied0.buf, ied0.pos, -1);
			}
			/* Free remote variables (if any) */
			if (ies.vars) {
				ast_variables_destroy(ies.vars);
				ast_debug(1, "I can haz IAX vars, but they is no good :-(\n");
				ies.vars = NULL;
			}

			/* Don't actually pass these frames along */
			if ((f.subclass.integer != IAX_COMMAND_ACK) &&
			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&
			  (f.subclass.integer != IAX_COMMAND_TXACC) &&
			  (f.subclass.integer != IAX_COMMAND_INVAL) &&
			  (f.subclass.integer != IAX_COMMAND_VNAK)) {
				if (iaxs[fr->callno] && iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno)
					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
			}
			ast_mutex_unlock(&iaxsl[fr->callno]);
			return 1;
		}
		/* Unless this is an ACK or INVAL frame, ack it */
		if (iaxs[fr->callno] && iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno)
			send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
	}
-----children-----
1,2
1,3
1,4
3,4
3,5
5,6
5,7
6,7
8,9
8,10
11,12
11,13
11,14
11,15
11,16
11,17
11,18
11,19
11,20
11,21
11,22
11,23
11,24
11,25
11,26
11,27
11,28
11,29
11,30
11,31
11,32
11,33
11,34
11,35
11,36
11,37
11,38
11,39
11,40
11,41
11,42
11,43
11,44
11,45
11,46
11,47
11,48
11,49
11,50
11,51
11,52
11,53
11,54
11,55
11,56
11,57
12,13
13,14
13,15
14,15
16,17
18,19
19,20
19,21
21,22
23,24
24,25
24,26
26,27
26,28
28,29
30,31
31,32
32,33
32,34
34,35
34,36
36,37
38,39
39,40
39,41
41,42
41,43
43,44
45,46
46,47
46,48
47,48
49,50
49,51
49,52
52,53
53,54
53,55
54,55
54,56
55,56
57,58
59,60
59,61
60,61
63,64
64,65
64,66
65,66
67,68
67,69
67,70
70,71
71,72
71,73
72,73
72,74
73,74
75,76
77,78
77,79
78,79
81,82
82,83
82,84
83,84
85,86
85,87
85,88
88,89
89,90
89,91
90,91
90,92
91,92
93,94
95,96
95,97
96,97
99,100
100,101
100,102
101,102
103,104
103,105
103,106
106,107
107,108
107,109
108,109
108,110
109,110
111,112
113,114
113,115
114,115
117,118
118,119
118,120
119,120
121,122
121,123
124,125
125,126
125,127
126,127
128,129
128,130
131,132
132,133
132,134
133,134
135,136
135,137
137,138
138,139
140,141
141,142
141,143
142,143
144,145
144,146
144,147
147,148
148,149
150,151
151,152
151,153
152,153
154,155
154,156
157,158
158,159
158,160
159,160
161,162
161,163
164,165
165,166
165,167
166,167
168,169
170,171
171,172
171,173
171,174
172,173
174,175
176,177
178,179
179,180
179,181
180,181
182,183
184,185
185,186
185,187
187,188
189,190
190,191
190,192
192,193
194,195
195,196
195,197
197,198
197,199
199,200
201,202
202,203
202,204
204,205
204,206
204,207
206,207
208,209
210,211
211,212
211,213
212,213
214,215
214,216
217,218
218,219
218,220
220,221
220,222
222,223
224,225
225,226
225,227
227,228
227,229
229,230
231,232
232,233
232,234
233,234
235,236
237,238
238,239
238,240
240,241
240,242
240,243
243,244
245,246
246,247
246,248
247,248
249,250
249,251
250,251
252,253
252,254
253,254
254,255
255,256
256,257
259,260
260,261
260,262
260,263
260,264
261,262
263,264
266,267
267,268
268,269
269,270
271,272
272,273
272,274
273,274
273,275
274,275
278,279
279,280
279,281
280,281
282,283
282,284
283,284
286,287
287,288
287,289
288,289
290,291
290,292
291,292
294,295
295,296
295,297
295,298
295,299
296,297
298,299
299,300
301,302
302,303
302,304
303,304
306,307
307,308
308,309
310,311
310,312
311,312
311,313
312,313
314,315
315,316
316,317
317,318
319,320
319,321
320,321
321,322
321,323
321,324
321,325
321,326
322,323
324,325
327,328
329,330
329,331
330,331
330,332
333,334
334,335
335,336
336,337
338,339
340,341
340,342
340,343
341,342
341,343
342,343
343,344
343,345
344,345
344,346
345,346
349,350
350,351
350,352
351,352
351,353
352,353
354,355
354,356
355,356
359,360
359,361
359,362
360,361
360,362
361,362
361,363
362,363
364,365
365,366
366,367
367,368
369,370
369,371
370,371
371,372
371,373
371,374
371,375
371,376
372,373
374,375
377,378
377,379
378,379
380,381
380,382
381,382
384,385
384,386
385,386
387,388
387,389
388,389
391,392
393,394
394,395
395,396
395,397
396,397
399,400
399,401
400,401
400,402
401,402
402,403
402,404
403,404
403,405
404,405
408,409
409,410
410,411
410,412
411,412
411,413
412,413
414,415
414,416
415,416
419,420
420,421
420,422
420,423
420,424
420,425
420,426
421,422
423,424
425,426
427,428
428,429
430,431
432,433
434,435
434,436
434,437
435,436
435,437
436,437
436,438
437,438
439,440
439,441
440,441
443,444
445,446
445,447
445,448
445,449
445,450
445,451
445,452
445,453
445,454
446,447
446,448
447,448
447,449
448,449
450,451
451,452
452,453
453,454
455,456
455,457
456,457
457,458
457,459
457,460
457,461
457,462
458,459
460,461
463,464
463,465
464,465
466,467
466,468
467,468
470,471
470,472
471,472
473,474
473,475
474,475
477,478
479,480
480,481
480,482
481,482
483,484
483,485
484,485
484,486
485,486
487,488
487,489
488,489
491,492
492,493
494,495
494,496
495,496
495,497
496,497
497,498
497,499
498,499
501,502
502,503
502,504
503,504
503,505
504,505
507,508
507,509
507,510
507,511
507,512
507,513
507,514
508,509
510,511
510,512
511,512
511,513
512,513
514,515
514,516
515,516
518,519
519,520
521,522
523,524
524,525
526,527
528,529
531,532
531,533
531,534
532,533
533,534
533,535
534,535
536,537
537,538
537,539
537,540
540,541
541,542
541,543
542,543
545,546
545,547
546,547
546,548
547,548
547,549
548,549
550,551
550,552
551,552
554,555
554,556
554,557
555,556
557,558
557,559
558,559
560,561
560,562
561,562
564,565
566,567
566,568
567,568
567,569
568,569
568,570
568,571
568,572
568,573
569,570
571,572
571,573
572,573
575,576
577,578
578,579
580,581
581,582
583,584
583,585
583,586
584,585
585,586
585,587
585,588
586,587
588,589
591,592
592,593
592,594
593,594
595,596
596,597
596,598
597,598
599,600
599,601
600,601
603,604
605,606
606,607
606,608
607,608
610,611
611,612
611,613
612,613
614,615
615,616
615,617
616,617
618,619
618,620
619,620
622,623
623,624
623,625
624,625
624,626
625,626
628,629
628,630
629,630
632,633
632,634
632,635
633,634
633,635
634,635
634,636
635,636
638,639
640,641
640,642
641,642
642,643
642,644
642,645
643,644
645,646
646,647
646,648
647,648
647,649
648,649
652,653
653,654
653,655
654,655
656,657
656,658
657,658
657,659
658,659
661,662
663,664
663,665
664,665
664,666
665,666
666,667
666,668
667,668
667,669
668,669
673,674
674,675
675,676
675,677
676,677
678,679
679,680
679,681
680,681
680,682
681,682
685,686
685,687
685,688
686,687
686,688
687,688
687,689
688,689
691,692
693,694
694,695
695,696
695,697
695,698
696,697
698,699
699,700
699,701
700,701
700,702
701,702
705,706
705,707
706,707
708,709
708,710
709,710
712,713
713,714
714,715
714,716
715,716
715,717
716,717
716,718
717,718
721,722
721,723
722,723
724,725
724,726
725,726
728,729
728,730
728,731
729,730
729,731
730,731
730,732
731,732
731,733
732,733
735,736
737,738
737,739
738,739
738,740
739,740
739,741
740,741
744,745
746,747
746,748
747,748
748,749
748,750
748,751
748,752
748,753
748,754
748,755
748,756
748,757
749,750
752,753
752,754
753,754
755,756
755,757
756,757
759,760
760,761
762,763
764,765
764,766
765,766
767,768
767,769
768,769
771,772
771,773
772,773
772,774
773,774
777,778
779,780
781,782
783,784
783,785
784,785
784,786
785,786
785,787
786,787
786,788
787,788
787,789
788,789
791,792
793,794
793,795
794,795
794,796
795,796
795,797
796,797
800,801
802,803
802,804
803,804
806,807
807,808
809,810
810,811
810,812
811,812
811,813
812,813
815,816
815,817
816,817
818,819
819,820
820,821
821,822
823,824
823,825
823,826
824,825
824,826
825,826
828,829
829,830
829,831
829,832
830,831
830,832
831,832
831,833
832,833
835,836
837,838
837,839
837,840
838,839
838,840
839,840
839,841
839,842
839,843
840,841
842,843
843,844
845,846
845,847
846,847
846,848
847,848
850,851
851,852
851,853
852,853
855,856
855,857
856,857
859,860
859,861
859,862
860,861
861,862
861,863
861,864
861,865
862,863
864,865
867,868
867,869
868,869
870,871
870,872
871,872
874,875
875,876
875,877
876,877
878,879
878,880
879,880
882,883
884,885
885,886
885,887
886,887
886,888
887,888
887,889
888,889
892,893
894,895
895,896
895,897
896,897
896,898
897,898
901,902
901,903
902,903
903,904
903,905
904,905
904,906
905,906
905,907
906,907
910,911
910,912
911,912
911,913
912,913
915,916
916,917
916,918
917,918
920,921
921,922
921,923
921,924
921,925
922,923
924,925
925,926
928,929
929,930
930,931
932,933
932,934
933,934
933,935
933,936
934,935
934,936
935,936
935,937
936,937
939,940
941,942
942,943
942,944
943,944
943,945
944,945
944,946
945,946
949,950
951,952
952,953
952,954
953,954
953,955
954,955
954,956
955,956
959,960
961,962
962,963
962,964
962,965
962,966
963,964
965,966
966,967
969,970
970,971
971,972
973,974
973,975
974,975
974,976
975,976
976,977
978,979
978,980
978,981
978,982
979,980
981,982
981,983
982,983
985,986
985,987
986,987
986,988
987,988
992,993
992,994
993,994
993,995
994,995
994,996
994,997
994,998
994,999
995,996
997,998
999,1000
1000,1001
1002,1003
1003,1004
1005,1006
1007,1008
1007,1009
1008,1009
1009,1010
1009,1011
1010,1011
1012,1013
1012,1014
1013,1014
1016,1017
1018,1019
1018,1020
1018,1021
1019,1020
1019,1021
1020,1021
1020,1022
1021,1022
1024,1025
1024,1026
1025,1026
1028,1029
1029,1030
1030,1031
1031,1032
1032,1033
1032,1034
1032,1035
1033,1034
1034,1035
1034,1036
1035,1036
1035,1037
1036,1037
1039,1040
1041,1042
1042,1043
1042,1044
1043,1044
1043,1045
1044,1045
1044,1046
1045,1046
1050,1051
1051,1052
1051,1053
1051,1054
1051,1055
1052,1053
1054,1055
1055,1056
1058,1059
1059,1060
1060,1061
1062,1063
1062,1064
1063,1064
1064,1065
1064,1066
1065,1066
1068,1069
1068,1070
1068,1071
1069,1070
1070,1071
1070,1072
1072,1073
1072,1074
1074,1075
1076,1077
1076,1078
1077,1078
1077,1079
1078,1079
1079,1080
1079,1081
1080,1081
1080,1082
1081,1082
1083,1084
1083,1085
1084,1085
1087,1088
1089,1090
1090,1091
1090,1092
1091,1092
1092,1093
1092,1094
1093,1094
1093,1095
1094,1095
1097,1098
1099,1100
1100,1101
1100,1102
1101,1102
1101,1103
1102,1103
1102,1104
1103,1104
1107,1108
1109,1110
1110,1111
1111,1112
1111,1113
1112,1113
1115,1116
1115,1117
1116,1117
1117,1118
1117,1119
1117,1120
1118,1119
1118,1120
1118,1121
1119,1120
1119,1121
1120,1121
1120,1122
1121,1122
1121,1123
1122,1123
1125,1126
1127,1128
1127,1129
1128,1129
1128,1130
1129,1130
1129,1131
1130,1131
1134,1135
1136,1137
1137,1138
1138,1139
1138,1140
1138,1141
1138,1142
1138,1143
1138,1144
1138,1145
1138,1146
1138,1147
1139,1140
1142,1143
1142,1144
1143,1144
1145,1146
1145,1147
1146,1147
1149,1150
1150,1151
1152,1153
1154,1155
1154,1156
1155,1156
1157,1158
1157,1159
1158,1159
1161,1162
1161,1163
1162,1163
1162,1164
1163,1164
1167,1168
1169,1170
1171,1172
1171,1173
1172,1173
1172,1174
1173,1174
1173,1175
1174,1175
1174,1176
1175,1176
1178,1179
1180,1181
1181,1182
1181,1183
1182,1183
1182,1184
1183,1184
1183,1185
1184,1185
1184,1186
1185,1186
1189,1190
1191,1192
1191,1193
1192,1193
1192,1194
1193,1194
1193,1195
1194,1195
1198,1199
1200,1201
1201,1202
1202,1203
1202,1204
1202,1205
1202,1206
1202,1207
1202,1208
1202,1209
1202,1210
1202,1211
1203,1204
1206,1207
1206,1208
1207,1208
1209,1210
1209,1211
1210,1211
1213,1214
1214,1215
1216,1217
1218,1219
1218,1220
1219,1220
1221,1222
1221,1223
1222,1223
1225,1226
1225,1227
1226,1227
1226,1228
1227,1228
1231,1232
1233,1234
1235,1236
1236,1237
1236,1238
1237,1238
1239,1240
1239,1241
1240,1241
1243,1244
1245,1246
1245,1247
1246,1247
1246,1248
1247,1248
1247,1249
1248,1249
1252,1253
1252,1254
1252,1255
1253,1254
1254,1255
1254,1256
1255,1256
1257,1258
1257,1259
1260,1261
1261,1262
1261,1263
1262,1263
1264,1265
1265,1266
1265,1267
1265,1268
1268,1269
1269,1270
1269,1271
1270,1271
1273,1274
1273,1275
1274,1275
1274,1276
1275,1276
1275,1277
1276,1277
1278,1279
1278,1280
1279,1280
1282,1283
1283,1284
1284,1285
1284,1286
1285,1286
1287,1288
1287,1289
1288,1289
1290,1291
1290,1292
1291,1292
1294,1295
1294,1296
1295,1296
1296,1297
1296,1298
1297,1298
1299,1300
1301,1302
1302,1303
1302,1304
1303,1304
1305,1306
1307,1308
1307,1309
1308,1309
1308,1310
1309,1310
1310,1311
1310,1312
1311,1312
1314,1315
1315,1316
1315,1317
1316,1317
1318,1319
1318,1320
1319,1320
1322,1323
1322,1324
1322,1325
1322,1326
1323,1324
1323,1325
1324,1325
1324,1326
1325,1326
1325,1327
1326,1327
1328,1329
1328,1330
1329,1330
1332,1333
1334,1335
1335,1336
1335,1337
1336,1337
1336,1338
1337,1338
1338,1339
1338,1340
1339,1340
1339,1341
1340,1341
1340,1342
1341,1342
1342,1343
1342,1344
1343,1344
1343,1345
1344,1345
1344,1346
1345,1346
1349,1350
1351,1352
1352,1353
1352,1354
1353,1354
1353,1355
1354,1355
1354,1356
1355,1356
1359,1360
1361,1362
1362,1363
1362,1364
1363,1364
1363,1365
1364,1365
1364,1366
1365,1366
1369,1370
1371,1372
1372,1373
1372,1374
1373,1374
1373,1375
1374,1375
1374,1376
1375,1376
1379,1380
1381,1382
1382,1383
1382,1384
1383,1384
1383,1385
1384,1385
1387,1388
1389,1390
1390,1391
1390,1392
1390,1393
1390,1394
1390,1395
1391,1392
1393,1394
1394,1395
1396,1397
1396,1398
1397,1398
1397,1399
1398,1399
1400,1401
1400,1402
1401,1402
1404,1405
1405,1406
1407,1408
1407,1409
1408,1409
1408,1410
1409,1410
1411,1412
1411,1413
1412,1413
1415,1416
1416,1417
1418,1419
1420,1421
1420,1422
1421,1422
1421,1423
1422,1423
1422,1424
1423,1424
1427,1428
1428,1429
1428,1430
1429,1430
1431,1432
1432,1433
1432,1434
1432,1435
1435,1436
1436,1437
1436,1438
1437,1438
1440,1441
1441,1442
1441,1443
1442,1443
1444,1445
1444,1446
1445,1446
1448,1449
1450,1451
1450,1452
1451,1452
1451,1453
1452,1453
1452,1454
1452,1455
1453,1454
1455,1456
1455,1457
1456,1457
1458,1459
1458,1460
1459,1460
1462,1463
1464,1465
1465,1466
1467,1468
1467,1469
1468,1469
1468,1470
1469,1470
1469,1471
1469,1472
1469,1473
1469,1474
1470,1471
1472,1473
1472,1474
1473,1474
1476,1477
1478,1479
1479,1480
1481,1482
1482,1483
1484,1485
1484,1486
1484,1487
1484,1488
1485,1486
1486,1487
1486,1488
1486,1489
1487,1488
1489,1490
1492,1493
1493,1494
1493,1495
1494,1495
1496,1497
1496,1498
1497,1498
1500,1501
1501,1502
1501,1503
1502,1503
1504,1505
1505,1506
1505,1507
1505,1508
1508,1509
1509,1510
1509,1511
1510,1511
1513,1514
1515,1516
1516,1517
1516,1518
1517,1518
1520,1521
1520,1522
1521,1522
1521,1523
1522,1523
1522,1524
1523,1524
1523,1525
1524,1525
1524,1526
1525,1526
1527,1528
1527,1529
1528,1529
1532,1533
1532,1534
1533,1534
1533,1535
1534,1535
1537,1538
1539,1540
1540,1541
1540,1542
1541,1542
1541,1543
1542,1543
1542,1544
1543,1544
1543,1545
1544,1545
1544,1546
1545,1546
1548,1549
1550,1551
1550,1552
1551,1552
1551,1553
1552,1553
1555,1556
1557,1558
1557,1559
1558,1559
1558,1560
1559,1560
1562,1563
1564,1565
1564,1566
1565,1566
1565,1567
1566,1567
1569,1570
1571,1572
1571,1573
1571,1574
1571,1575
1571,1576
1571,1577
1571,1578
1571,1579
1571,1580
1571,1581
1571,1582
1571,1583
1571,1584
1571,1585
1571,1586
1571,1587
1572,1573
1573,1574
1573,1575
1574,1575
1576,1577
1576,1578
1579,1580
1580,1581
1580,1582
1582,1583
1582,1584
1584,1585
1585,1586
1586,1587
1587,1588
1588,1589
1590,1591
1591,1592
1591,1593
1593,1594
1593,1595
1593,1596
1595,1596
1597,1598
1599,1600
1600,1601
1600,1602
1600,1603
1600,1604
1601,1602
1603,1604
1603,1605
1604,1605
1607,1608
1609,1610
1610,1611
1611,1612
1613,1614
1614,1615
1614,1616
1615,1616
1618,1619
1619,1620
1619,1621
1620,1621
1623,1624
1623,1625
1624,1625
1624,1626
1625,1626
1625,1627
1626,1627
1630,1631
1631,1632
1632,1633
1633,1634
1635,1636
1635,1637
1636,1637
1636,1638
1637,1638
1637,1639
1638,1639
1642,1643
1643,1644
1644,1645
1645,1646
1647,1648
1648,1649
1648,1650
1649,1650
1651,1652
1651,1653
1652,1653
1654,1655
1656,1657
1657,1658
1657,1659
1658,1659
1660,1661
1660,1662
1661,1662
1663,1664
1665,1666
1666,1667
1666,1668
1666,1669
1666,1670
1667,1668
1669,1670
1669,1671
1670,1671
1673,1674
1673,1675
1674,1675
1676,1677
1676,1678
1677,1678
1677,1679
1678,1679
1680,1681
1680,1682
1681,1682
1685,1686
1687,1688
1688,1689
1688,1690
1689,1690
1689,1691
1690,1691
1693,1694
1693,1695
1694,1695
1697,1698
1698,1699
1698,1700
1698,1701
1698,1702
1698,1703
1698,1704
1699,1700
1701,1702
1701,1703
1702,1703
1705,1706
1705,1707
1706,1707
1706,1708
1707,1708
1709,1710
1710,1711
1711,1712
1712,1713
1716,1717
1718,1719
1718,1720
1719,1720
1722,1723
1723,1724
1723,1725
1724,1725
1726,1727
1726,1728
1727,1728
1730,1731
1730,1732
1731,1732
1731,1733
1732,1733
1732,1734
1733,1734
1735,1736
1735,1737
1736,1737
1739,1740
1739,1741
1740,1741
1740,1742
1741,1742
1743,1744
1743,1745
1744,1745
1748,1749
1748,1750
1748,1751
1749,1750
1750,1751
1750,1752
1750,1753
1750,1754
1750,1755
1751,1752
1753,1754
1753,1755
1754,1755
1754,1756
1755,1756
1757,1758
1757,1759
1758,1759
1762,1763
1764,1765
1766,1767
1768,1769
1769,1770
1769,1771
1769,1772
1769,1773
1770,1771
1772,1773
1772,1774
1773,1774
1773,1775
1774,1775
1776,1777
1776,1778
1777,1778
1781,1782
1783,1784
1785,1786
1786,1787
1786,1788
1787,1788
1789,1790
1789,1791
1790,1791
1790,1792
1791,1792
1793,1794
1793,1795
1794,1795
1798,1799
1798,1800
1799,1800
1800,1801
1800,1802
1801,1802
1803,1804
1803,1805
1804,1805
1807,1808
1807,1809
1807,1810
1808,1809
1809,1810
1809,1811
1810,1811
1812,1813
1812,1814
1813,1814
1816,1817
1817,1818
1817,1819
1818,1819
1820,1821
1821,1822
1821,1823
1821,1824
1824,1825
1825,1826
1825,1827
1826,1827
1829,1830
1831,1832
1832,1833
1833,1834
1833,1835
1834,1835
1834,1836
1835,1836
1837,1838
1837,1839
1838,1839
1842,1843
1842,1844
1843,1844
1843,1845
1844,1845
1844,1846
1845,1846
1845,1847
1846,1847
1847,1848
1847,1849
1847,1850
1848,1849
1850,1851
1851,1852
1853,1854
1854,1855
1854,1856
1855,1856
1855,1857
1856,1857
1858,1859
1858,1860
1859,1860
1863,1864
1864,1865
1866,1867
1866,1868
1867,1868
1867,1869
1868,1869
1868,1870
1869,1870
1873,1874
1875,1876
1875,1877
1876,1877
1876,1878
1877,1878
1877,1879
1878,1879
1882,1883
1884,1885
1884,1886
1884,1887
1885,1886
1886,1887
1886,1888
1888,1889
1890,1891
1891,1892
1891,1893
1892,1893
1894,1895
1894,1896
1895,1896
1895,1897
1898,1899
1899,1900
1899,1901
1900,1901
1900,1902
1901,1902
1903,1904
1903,1905
1904,1905
1907,1908
1908,1909
1910,1911
1910,1912
1911,1912
1911,1913
1912,1913
1914,1915
1914,1916
1915,1916
1917,1918
1917,1919
1918,1919
1918,1920
1919,1920
1921,1922
1921,1923
1922,1923
1926,1927
1926,1928
1926,1929
1927,1928
1927,1929
1928,1929
1928,1930
1929,1930
1929,1931
1930,1931
1932,1933
1932,1934
1933,1934
1937,1938
1938,1939
1939,1940
1939,1941
1940,1941
1942,1943
1943,1944
1943,1945
1945,1946
1946,1947
1946,1948
1947,1948
1950,1951
1951,1952
1951,1953
1952,1953
1952,1954
1953,1954
1953,1955
1954,1955
1956,1957
1956,1958
1957,1958
1961,1962
1963,1964
1964,1965
1964,1966
1965,1966
1967,1968
1968,1969
1968,1970
1970,1971
1971,1972
1971,1973
1972,1973
1975,1976
1975,1977
1976,1977
1976,1978
1977,1978
1977,1979
1978,1979
1980,1981
1980,1982
1981,1982
1984,1985
1986,1987
1986,1988
1986,1989
1986,1990
1986,1991
1986,1992
1986,1993
1986,1994
1986,1995
1986,1996
1986,1997
1986,1998
1986,1999
1986,2000
1986,2001
1986,2002
1986,2003
1986,2004
1986,2005
1987,1988
1987,1989
1988,1989
1990,1991
1991,1992
1991,1993
1991,1994
1991,1995
1991,1996
1991,1997
1992,1993
1996,1997
1996,1998
1997,1998
2000,2001
2000,2002
2001,2002
2004,2005
2004,2006
2005,2006
2005,2007
2006,2007
2010,2011
2011,2012
2011,2013
2012,2013
2012,2014
2013,2014
2016,2017
2016,2018
2017,2018
2020,2021
2021,2022
2021,2023
2022,2023
2022,2024
2023,2024
2026,2027
2026,2028
2027,2028
2030,2031
2031,2032
2031,2033
2032,2033
2032,2034
2033,2034
2036,2037
2036,2038
2037,2038
2039,2040
2039,2041
2040,2041
2043,2044
2043,2045
2044,2045
2044,2046
2045,2046
2046,2047
2046,2048
2047,2048
2047,2049
2048,2049
2050,2051
2050,2052
2051,2052
2054,2055
2056,2057
2057,2058
2057,2059
2058,2059
2058,2060
2059,2060
2062,2063
2064,2065
2065,2066
2065,2067
2066,2067
2069,2070
2069,2071
2069,2072
2070,2071
2070,2072
2071,2072
2072,2073
2072,2074
2073,2074
2073,2075
2074,2075
2074,2076
2075,2076
2077,2078
2077,2079
2078,2079
2082,2083
2082,2084
2083,2084
2086,2087
2087,2088
2087,2089
2088,2089
2088,2090
2089,2090
2089,2091
2090,2091
2090,2092
2091,2092
2093,2094
2093,2095
2094,2095
2098,2099
2099,2100
2099,2101
2100,2101
2100,2102
2101,2102
2101,2103
2102,2103
2102,2104
2103,2104
2104,2105
2104,2106
2105,2106
2105,2107
2106,2107
2106,2108
2107,2108
2111,2112
2113,2114
2114,2115
2114,2116
2115,2116
2115,2117
2116,2117
2116,2118
2117,2118
2121,2122
2123,2124
2124,2125
2124,2126
2125,2126
2125,2127
2126,2127
2126,2128
2127,2128
2131,2132
2133,2134
2134,2135
2134,2136
2135,2136
2135,2137
2136,2137
2136,2138
2137,2138
2141,2142
2143,2144
2144,2145
2144,2146
2145,2146
2145,2147
2146,2147
2146,2148
2147,2148
2151,2152
2153,2154
2154,2155
2154,2156
2155,2156
2155,2157
2156,2157
2159,2160
2161,2162
2162,2163
2162,2164
2163,2164
2163,2165
2164,2165
2165,2166
2165,2167
2166,2167
2166,2168
2167,2168
2167,2169
2168,2169
2168,2170
2169,2170
2169,2171
2170,2171
2170,2172
2171,2172
2171,2173
2172,2173
2173,2174
2173,2175
2174,2175
2174,2176
2175,2176
2175,2177
2176,2177
2180,2181
2182,2183
2183,2184
2183,2185
2184,2185
2184,2186
2185,2186
2185,2187
2186,2187
2190,2191
2192,2193
2193,2194
2193,2195
2194,2195
2194,2196
2195,2196
2195,2197
2196,2197
2200,2201
2202,2203
2203,2204
2203,2205
2204,2205
2204,2206
2205,2206
2205,2207
2206,2207
2210,2211
2212,2213
2213,2214
2213,2215
2214,2215
2214,2216
2215,2216
2215,2217
2216,2217
2220,2221
2222,2223
2223,2224
2223,2225
2224,2225
2224,2226
2225,2226
2225,2227
2226,2227
2230,2231
2232,2233
2233,2234
2233,2235
2234,2235
2234,2236
2235,2236
2235,2237
2236,2237
2240,2241
2242,2243
2243,2244
2243,2245
2244,2245
2244,2246
2245,2246
2245,2247
2246,2247
2250,2251
2252,2253
2253,2254
2253,2255
2254,2255
2254,2256
2255,2256
2258,2259
2260,2261
2260,2262
2260,2263
2260,2264
2260,2265
2261,2262
2262,2263
2262,2264
2262,2265
2262,2266
2262,2267
2262,2268
2262,2269
2263,2264
2267,2268
2267,2269
2268,2269
2268,2270
2269,2270
2271,2272
2271,2273
2272,2273
2276,2277
2276,2278
2277,2278
2280,2281
2280,2282
2281,2282
2284,2285
2284,2286
2285,2286
2285,2287
2286,2287
2290,2291
2290,2292
2290,2293
2291,2292
2291,2293
2292,2293
2292,2294
2293,2294
2293,2295
2296,2297
2297,2298
2297,2299
2298,2299
2298,2300
2299,2300
2299,2301
2300,2301
2302,2303
2302,2304
2303,2304
2307,2308
2307,2309
2308,2309
2312,2313
2313,2314
2313,2315
2314,2315
2314,2316
2315,2316
2316,2317
2316,2318
2317,2318
2317,2319
2318,2319
2321,2322
2323,2324
2324,2325
2324,2326
2325,2326
2326,2327
2326,2328
2327,2328
2327,2329
2328,2329
2328,2330
2329,2330
2333,2334
2335,2336
2336,2337
2336,2338
2337,2338
2337,2339
2338,2339
2338,2340
2339,2340
2343,2344
2345,2346
2345,2347
2346,2347
2347,2348
2347,2349
2347,2350
2348,2349
2352,2353
2353,2354
2353,2355
2353,2356
2353,2357
2353,2358
2353,2359
2353,2360
2353,2361
2354,2355
2356,2357
2356,2358
2357,2358
2359,2360
2359,2361
2360,2361
2363,2364
2365,2366
2367,2368
2367,2369
2368,2369
2371,2372
2374,2375
2374,2376
2375,2376
2378,2379
2379,2380
2380,2381
2380,2382
2381,2382
2383,2384
2383,2385
2384,2385
2387,2388
2388,2389
2388,2390
2389,2390
2391,2392
2391,2393
2392,2393
2395,2396
2396,2397
2396,2398
2397,2398
2399,2400
2400,2401
2400,2402
2400,2403
2403,2404
2404,2405
2404,2406
2405,2406
2408,2409
2410,2411
2411,2412
2411,2413
2412,2413
2412,2414
2413,2414
2414,2415
2414,2416
2415,2416
2415,2417
2416,2417
2416,2418
2417,2418
2417,2419
2418,2419
2419,2420
2419,2421
2420,2421
2420,2422
2421,2422
2421,2423
2422,2423
2426,2427
2428,2429
2429,2430
2429,2431
2430,2431
2430,2432
2431,2432
2431,2433
2432,2433
2436,2437
2438,2439
2439,2440
2439,2441
2440,2441
2440,2442
2441,2442
2441,2443
2442,2443
2446,2447
2448,2449
2449,2450
2449,2451
2450,2451
2450,2452
2451,2452
2451,2453
2452,2453
2456,2457
2458,2459
2459,2460
2459,2461
2460,2461
2460,2462
2461,2462
2461,2463
2462,2463
2466,2467
2468,2469
2469,2470
2469,2471
2470,2471
2470,2472
2471,2472
2474,2475
2476,2477
2477,2478
2478,2479
2478,2480
2479,2480
2479,2481
2480,2481
2482,2483
2482,2484
2483,2484
2487,2488
2487,2489
2488,2489
2488,2490
2489,2490
2489,2491
2490,2491
2490,2492
2491,2492
2494,2495
2496,2497
2496,2498
2497,2498
2497,2499
2498,2499
2498,2500
2499,2500
2502,2503
2502,2504
2503,2504
2507,2508
2508,2509
2508,2510
2508,2511
2509,2510
2509,2511
2510,2511
2512,2513
2512,2514
2513,2514
2516,2517
2517,2518
2517,2519
2518,2519
2518,2520
2519,2520
2519,2521
2520,2521
2523,2524
2524,2525
2527,2528
2528,2529
2528,2530
2529,2530
2529,2531
2530,2531
2530,2532
2531,2532
2534,2535
2534,2536
2535,2536
2539,2540
2539,2541
2540,2541
2540,2542
2541,2542
2542,2543
2542,2544
2542,2545
2543,2544
2545,2546
2546,2547
2548,2549
2549,2550
2549,2551
2550,2551
2550,2552
2551,2552
2553,2554
2553,2555
2554,2555
2558,2559
2559,2560
2559,2561
2560,2561
2561,2562
2561,2563
2562,2563
2562,2564
2563,2564
2563,2565
2564,2565
2568,2569
2570,2571
2571,2572
2571,2573
2572,2573
2572,2574
2573,2574
2576,2577
2578,2579
2578,2580
2578,2581
2578,2582
2579,2580
2580,2581
2580,2582
2582,2583
2584,2585
2585,2586
2585,2587
2587,2588
2589,2590
2589,2591
2589,2592
2590,2591
2590,2592
2591,2592
2591,2593
2592,2593
2592,2594
2593,2594
2593,2595
2594,2595
2596,2597
2596,2598
2597,2598
2601,2602
2601,2603
2602,2603
2602,2604
2603,2604
2605,2606
2605,2607
2606,2607
2610,2611
2611,2612
2611,2613
2612,2613
2612,2614
2613,2614
2613,2615
2614,2615
2617,2618
2617,2619
2618,2619
2618,2620
2619,2620
2621,2622
2621,2623
2622,2623
2626,2627
2626,2628
2627,2628
2627,2629
2628,2629
2631,2632
2631,2633
2632,2633
2632,2634
2633,2634
2635,2636
2635,2637
2636,2637
2640,2641
2641,2642
2641,2643
2642,2643
2644,2645
2644,2646
2645,2646
2648,2649
2649,2650
2649,2651
2650,2651
2652,2653
2652,2654
2653,2654
2653,2655
2654,2655
2656,2657
2656,2658
2657,2658
2661,2662
2661,2663
2661,2664
2662,2663
2662,2664
2663,2664
2664,2665
2664,2666
2665,2666
2667,2668
2667,2669
2668,2669
2668,2670
2669,2670
2671,2672
2671,2673
2672,2673
2676,2677
2677,2678
2677,2679
2678,2679
2678,2680
2679,2680
2679,2681
2680,2681
2682,2683
2682,2684
2683,2684
2687,2688
2687,2689
2688,2689
2691,2692
2691,2693
2692,2693
2692,2694
2692,2695
2692,2696
2693,2694
2694,2695
2694,2696
2695,2696
2697,2698
2697,2699
2698,2699
2698,2700
2699,2700
2701,2702
2701,2703
2702,2703
2706,2707
2706,2708
2707,2708
2709,2710
2709,2711
2710,2711
2713,2714
2714,2715
2716,2717
2716,2718
2716,2719
2716,2720
2716,2721
2716,2722
2717,2718
2717,2719
2718,2719
2720,2721
2721,2722
2721,2723
2721,2724
2721,2725
2722,2723
2726,2727
2728,2729
2729,2730
2729,2731
2730,2731
2733,2734
2734,2735
2734,2736
2734,2737
2734,2738
2735,2736
2737,2738
2738,2739
2738,2740
2739,2740
2741,2742
2741,2743
2742,2743
2745,2746
2747,2748
2749,2750
2750,2751
2751,2752
2751,2753
2752,2753
2752,2754
2753,2754
2755,2756
2755,2757
2756,2757
2759,2760
2759,2761
2760,2761
2761,2762
2761,2763
2762,2763
2762,2764
2763,2764
2766,2767
2768,2769
2768,2770
2769,2770
2769,2771
2770,2771
2773,2774
2774,2775
2774,2776
2775,2776
2777,2778
2777,2779
2778,2779
2781,2782
2781,2783
2782,2783
2784,2785
2784,2786
2784,2787
2784,2788
2785,2786
2785,2787
2786,2787
2788,2789
2789,2790
2789,2791
2789,2792
2789,2793
2790,2791
2794,2795
2796,2797
2797,2798
2797,2799
2798,2799
2800,2801
2801,2802
2801,2803
2801,2804
2804,2805
2805,2806
2807,2808
2808,2809
2808,2810
2809,2810
2811,2812
2813,2814
2814,2815
2814,2816
2815,2816
2817,2818
2818,2819
2818,2820
2819,2820
2821,2822
2823,2824
2823,2825
2823,2826
2824,2825
2824,2826
2825,2826
2827,2828
2827,2829
2828,2829
2831,2832
2832,2833
2832,2834
2833,2834
2833,2835
2834,2835
2834,2836
2835,2836
2837,2838
2837,2839
2838,2839
2842,2843
2842,2844
2843,2844
2846,2847
2846,2848
2846,2849
2847,2848
2848,2849
2848,2850
2849,2850
2851,2852
2851,2853
2852,2853
2855,2856
2856,2857
2856,2858
2857,2858
2859,2860
2860,2861
2860,2862
2860,2863
2863,2864
2864,2865
2864,2866
2865,2866
2868,2869
2870,2871
2871,2872
2872,2873
2872,2874
2872,2875
2872,2876
2872,2877
2872,2878
2873,2874
2877,2878
2877,2879
2878,2879
2881,2882
2881,2883
2882,2883
2882,2884
2883,2884
2885,2886
2885,2887
2886,2887
2890,2891
2890,2892
2891,2892
2891,2893
2892,2893
2894,2895
2894,2896
2895,2896
2899,2900
2899,2901
2900,2901
2900,2902
2901,2902
2901,2903
2901,2904
2902,2903
2904,2905
2905,2906
2907,2908
2908,2909
2908,2910
2909,2910
2909,2911
2910,2911
2912,2913
2912,2914
2913,2914
2917,2918
2918,2919
2918,2920
2919,2920
2920,2921
2920,2922
2921,2922
2921,2923
2922,2923
2925,2926
2927,2928
2928,2929
2928,2930
2929,2930
2930,2931
2930,2932
2931,2932
2931,2933
2932,2933
2932,2934
2933,2934
2937,2938
2939,2940
2940,2941
2940,2942
2941,2942
2941,2943
2942,2943
2942,2944
2943,2944
2947,2948
2949,2950
2949,2951
2949,2952
2950,2951
2951,2952
2951,2953
2952,2953
2954,2955
2954,2956
2955,2956
2958,2959
2959,2960
2959,2961
2960,2961
2962,2963
2963,2964
2963,2965
2963,2966
2966,2967
2967,2968
2967,2969
2968,2969
2971,2972
2973,2974
2973,2975
2974,2975
2974,2976
2975,2976
2975,2977
2976,2977
2977,2978
2977,2979
2978,2979
2978,2980
2979,2980
2982,2983
2984,2985
2985,2986
2985,2987
2986,2987
2986,2988
2987,2988
2990,2991
2992,2993
2993,2994
2993,2995
2994,2995
2994,2996
2995,2996
2998,2999
3000,3001
3000,3002
3000,3003
3001,3002
3001,3003
3002,3003
3002,3004
3002,3005
3003,3004
3005,3006
3005,3007
3006,3007
3008,3009
3008,3010
3009,3010
3012,3013
3014,3015
3014,3016
3015,3016
3016,3017
3016,3018
3016,3019
3017,3018
3019,3020
3019,3021
3020,3021
3022,3023
3022,3024
3023,3024
3026,3027
3028,3029
3028,3030
3029,3030
3030,3031
3030,3032
3030,3033
3030,3034
3030,3035
3030,3036
3031,3032
3033,3034
3033,3035
3034,3035
3037,3038
3039,3040
3039,3041
3040,3041
3040,3042
3041,3042
3043,3044
3043,3045
3044,3045
3048,3049
3050,3051
3050,3052
3050,3053
3051,3052
3053,3054
3054,3055
3054,3056
3055,3056
3055,3057
3056,3057
3058,3059
3058,3060
3059,3060
3063,3064
3065,3066
3065,3067
3065,3068
3066,3067
3067,3068
3067,3069
3068,3069
3070,3071
3070,3072
3071,3072
3074,3075
3075,3076
3075,3077
3076,3077
3078,3079
3079,3080
3079,3081
3079,3082
3082,3083
3083,3084
3083,3085
3084,3085
3087,3088
3089,3090
3089,3091
3090,3091
3090,3092
3091,3092
3094,3095
3094,3096
3094,3097
3094,3098
3094,3099
3094,3100
3095,3096
3096,3097
3096,3098
3097,3098
3099,3100
3099,3101
3099,3102
3102,3103
3103,3104
3105,3106
3106,3107
3106,3108
3106,3109
3107,3108
3109,3110
3109,3111
3112,3113
3112,3114
3112,3115
3115,3116
3116,3117
3118,3119
3119,3120
3120,3121
3120,3122
3121,3122
3123,3124
3123,3125
3124,3125
3127,3128
3127,3129
3128,3129
3129,3130
3129,3131
3130,3131
3132,3133
3132,3134
3133,3134
3136,3137
3136,3138
3136,3139
3137,3138
3138,3139
3138,3140
3139,3140
3141,3142
3141,3143
3142,3143
3145,3146
3146,3147
3146,3148
3147,3148
3149,3150
3150,3151
3150,3152
3150,3153
3153,3154
3154,3155
3154,3156
3155,3156
3158,3159
3160,3161
3160,3162
3160,3163
3161,3162
3162,3163
3162,3164
3163,3164
3165,3166
3165,3167
3166,3167
3166,3168
3167,3168
3169,3170
3169,3171
3170,3171
3174,3175
3174,3176
3174,3177
3174,3178
3175,3176
3176,3177
3176,3178
3177,3178
3179,3180
3179,3181
3179,3182
3180,3181
3183,3184
3184,3185
3185,3186
3186,3187
3188,3189
3189,3190
3189,3191
3190,3191
3192,3193
3192,3194
3192,3195
3193,3194
3195,3196
3196,3197
3198,3199
3200,3201
3200,3202
3200,3203
3201,3202
3201,3203
3202,3203
3204,3205
3206,3207
3206,3208
3206,3209
3206,3210
3206,3211
3206,3212
3206,3213
3206,3214
3207,3208
3208,3209
3208,3210
3209,3210
3209,3211
3210,3211
3213,3214
3215,3216
3216,3217
3216,3218
3217,3218
3217,3219
3218,3219
3221,3222
3223,3224
3224,3225
3224,3226
3225,3226
3227,3228
3228,3229
3230,3231
3231,3232
3231,3233
3231,3234
3232,3233
3236,3237
3236,3238
3236,3239
3236,3240
3237,3238
3238,3239
3238,3240
3239,3240
3241,3242
3241,3243
3242,3243
3245,3246
3247,3248
3247,3249
3248,3249
3250,3251
3250,3252
3251,3252
3254,3255
3254,3256
3254,3257
3254,3258
3255,3256
3256,3257
3256,3258
3257,3258
3259,3260
3259,3261
3259,3262
3262,3263
3263,3264
3263,3265
3263,3266
3264,3265
3266,3267
3266,3268
3267,3268
3270,3271
3270,3272
3271,3272
3274,3275
3274,3276
3275,3276
3277,3278
3278,3279
3279,3280
3279,3281
3280,3281
3282,3283
3284,3285
3285,3286
3285,3287
3286,3287
3288,3289
3290,3291
3290,3292
3290,3293
3291,3292
3292,3293
3294,3295
3295,3296
3296,3297
3296,3298
3296,3299
3297,3298
3299,3300
3302,3303
3303,3304
3304,3305
3304,3306
3304,3307
3304,3308
3305,3306
3307,3308
3309,3310
3311,3312
3313,3314
3313,3315
3314,3315
3316,3317
3317,3318
3318,3319
3318,3320
3319,3320
3321,3322
3323,3324
3324,3325
3324,3326
3325,3326
3325,3327
3326,3327
3329,3330
3331,3332
3332,3333
3332,3334
3332,3335
3333,3334
3335,3336
3337,3338
3339,3340
3339,3341
3339,3342
3340,3341
3341,3342
3341,3343
3341,3344
3342,3343
3344,3345
3347,3348
3347,3349
3348,3349
3350,3351
3351,3352
3352,3353
3352,3354
3353,3354
3355,3356
3357,3358
3357,3359
3358,3359
3360,3361
3361,3362
3362,3363
3362,3364
3363,3364
3365,3366
3366,3367
3368,3369
3369,3370
3369,3371
3370,3371
3372,3373
3374,3375
3374,3376
3374,3377
3375,3376
3376,3377
3376,3378
3376,3379
3377,3378
3381,3382
3381,3383
3381,3384
3381,3385
3382,3383
3383,3384
3383,3385
3384,3385
3386,3387
3386,3388
3387,3388
3390,3391
3390,3392
3391,3392
3393,3394
3393,3395
3394,3395
3397,3398
3397,3399
3398,3399
3400,3401
3400,3402
3401,3402
3405,3406
3405,3407
3406,3407
3408,3409
3408,3410
3408,3411
3409,3410
3410,3411
3410,3412
3411,3412
3411,3413
3412,3413
3415,3416
3415,3417
3416,3417
3416,3418
3417,3418
3419,3420
3419,3421
3420,3421
3424,3425
3425,3426
3425,3427
3426,3427
3426,3428
3427,3428
3427,3429
3428,3429
3430,3431
3430,3432
3431,3432
3435,3436
3435,3437
3436,3437
3439,3440
3440,3441
3440,3442
3441,3442
3441,3443
3442,3443
3445,3446
3447,3448
3447,3449
3448,3449
3448,3450
3449,3450
3452,3453
3453,3454
3454,3455
3454,3456
3454,3457
3455,3456
3459,3460
3459,3461
3460,3461
3460,3462
3461,3462
3461,3463
3462,3463
3463,3464
3463,3465
3464,3465
3464,3466
3465,3466
3468,3469
3470,3471
3471,3472
3471,3473
3472,3473
3472,3474
3473,3474
3473,3475
3474,3475
3478,3479
3480,3481
3480,3482
3481,3482
3481,3483
3482,3483
3484,3485
3484,3486
3485,3486
3489,3490
3490,3491
3491,3492
3491,3493
3492,3493
3494,3495
3495,3496
3495,3497
3497,3498
3498,3499
3498,3500
3499,3500
3502,3503
3502,3504
3503,3504
3503,3505
3504,3505
3504,3506
3505,3506
3508,3509
3510,3511
3511,3512
3511,3513
3512,3513
3512,3514
3513,3514
3513,3515
3514,3515
3516,3517
3517,3518
3517,3519
3518,3519
3518,3520
3519,3520
3523,3524
3523,3525
3524,3525
3524,3526
3525,3526
3527,3528
3527,3529
3528,3529
3532,3533
3532,3534
3532,3535
3533,3534
3534,3535
3534,3536
3535,3536
3535,3537
3536,3537
3536,3538
3537,3538
3539,3540
3539,3541
3540,3541
3544,3545
3544,3546
3545,3546
3547,3548
3548,3549
3548,3550
3549,3550
3549,3551
3550,3551
3554,3555
3555,3556
3555,3557
3555,3558
3555,3559
3556,3557
3560,3561
3560,3562
3561,3562
3563,3564
3564,3565
3564,3566
3565,3566
3565,3567
3566,3567
3570,3571
3570,3572
3571,3572
3571,3573
3572,3573
3572,3574
3573,3574
3575,3576
3575,3577
3576,3577
3580,3581
3580,3582
3581,3582
3582,3583
3582,3584
3583,3584
3585,3586
3585,3587
3586,3587
3589,3590
3589,3591
3589,3592
3590,3591
3590,3592
3591,3592
3593,3594
3593,3595
3594,3595
3597,3598
3598,3599
3598,3600
3599,3600
3599,3601
3600,3601
3600,3602
3601,3602
3603,3604
3603,3605
3604,3605
3608,3609
3608,3610
3608,3611
3609,3610
3610,3611
3610,3612
3611,3612
3613,3614
3613,3615
3613,3616
3616,3617
3617,3618
3617,3619
3618,3619
3620,3621
3620,3622
3621,3622
3623,3624
3623,3625
3624,3625
3624,3626
3625,3626
3627,3628
3627,3629
3628,3629
3632,3633
3633,3634
3633,3635
3634,3635
3636,3637
3636,3638
3636,3639
3639,3640
3640,3641
3640,3642
3641,3642
3643,3644
3643,3645
3644,3645
3644,3646
3645,3646
3647,3648
3647,3649
3648,3649
3652,3653
3652,3654
3653,3654
3655,3656
3655,3657
3655,3658
3655,3659
3655,3660
3656,3657
3657,3658
3657,3659
3657,3660
3658,3659
3660,3661
3662,3663
3663,3664
3663,3665
3664,3665
3664,3666
3665,3666
3669,3670
3669,3671
3670,3671
3670,3672
3671,3672
3671,3673
3672,3673
3674,3675
3674,3676
3675,3676
3675,3677
3676,3677
3678,3679
3678,3680
3679,3680
3684,3685
3685,3686
3686,3687
3686,3688
3686,3689
3687,3688
3689,3690
3689,3691
3690,3691
3690,3692
3691,3692
3693,3694
3693,3695
3694,3695
3698,3699
3698,3700
3699,3700
3701,3702
3701,3703
3702,3703
3702,3704
3703,3704
3705,3706
3705,3707
3706,3707
3710,3711
3711,3712
3711,3713
3711,3714
3712,3713
3714,3715
3716,3717
3718,3719
3719,3720
3719,3721
3720,3721
3722,3723
3722,3724
3723,3724
3723,3725
3724,3725
3726,3727
3726,3728
3727,3728
3731,3732
3732,3733
3732,3734
3733,3734
3735,3736
3735,3737
3736,3737
3738,3739
3740,3741
3740,3742
3740,3743
3740,3744
3741,3742
3742,3743
3742,3744
3742,3745
3743,3744
3747,3748
3747,3749
3748,3749
3748,3750
3749,3750
3752,3753
3752,3754
3752,3755
3753,3754
3754,3755
3754,3756
3755,3756
3757,3758
3757,3759
3758,3759
3761,3762
3762,3763
3762,3764
3762,3765
3763,3764
3767,3768
3768,3769
3768,3770
3769,3770
3769,3771
3770,3771
3773,3774
3775,3776
3776,3777
3776,3778
3777,3778
3779,3780
3780,3781
3780,3782
3780,3783
3783,3784
3784,3785
3784,3786
3785,3786
3788,3789
3790,3791
3790,3792
3791,3792
3791,3793
3792,3793
3792,3794
3793,3794
3796,3797
3798,3799
3799,3800
3799,3801
3800,3801
3800,3802
3801,3802
3801,3803
3802,3803
3802,3804
3803,3804
3803,3805
3804,3805
3809,3810
3809,3811
3810,3811
3812,3813
3812,3814
3813,3814
3813,3815
3814,3815
3816,3817
3816,3818
3817,3818
3821,3822
3821,3823
3822,3823
3823,3824
3823,3825
3823,3826
3823,3827
3824,3825
3828,3829
3828,3830
3829,3830
3831,3832
3832,3833
3832,3834
3833,3834
3833,3835
3834,3835
3838,3839
3839,3840
3839,3841
3840,3841
3840,3842
3841,3842
3841,3843
3842,3843
3844,3845
3844,3846
3845,3846
3849,3850
3849,3851
3850,3851
3852,3853
3853,3854
3853,3855
3854,3855
3854,3856
3855,3856
3859,3860
3859,3861
3860,3861
3860,3862
3861,3862
3861,3863
3862,3863
3862,3864
3863,3864
3866,3867
3868,3869
3868,3870
3869,3870
3869,3871
3870,3871
3872,3873
3872,3874
3873,3874
3877,3878
3878,3879
3878,3880
3878,3881
3879,3880
3879,3881
3880,3881
3880,3882
3881,3882
3881,3883
3882,3883
3886,3887
3888,3889
3889,3890
3890,3891
3890,3892
3890,3893
3891,3892
3893,3894
3893,3895
3894,3895
3894,3896
3895,3896
3897,3898
3897,3899
3898,3899
3902,3903
3904,3905
3904,3906
3905,3906
3905,3907
3906,3907
3906,3908
3907,3908
3907,3909
3908,3909
3912,3913
3914,3915
3915,3916
3916,3917
3916,3918
3916,3919
3917,3918
3919,3920
3919,3921
3920,3921
3920,3922
3921,3922
3923,3924
3923,3925
3924,3925
3928,3929
3930,3931
3930,3932
3931,3932
3931,3933
3932,3933
3932,3934
3933,3934
3936,3937
3938,3939
3938,3940
3938,3941
3938,3942
3938,3943
3938,3944
3938,3945
3938,3946
3938,3947
3938,3948
3938,3949
3938,3950
3938,3951
3938,3952
3938,3953
3938,3954
3938,3955
3938,3956
3938,3957
3938,3958
3938,3959
3938,3960
3938,3961
3938,3962
3938,3963
3938,3964
3938,3965
3938,3966
3938,3967
3938,3968
3938,3969
3938,3970
3938,3971
3938,3972
3938,3973
3938,3974
3938,3975
3938,3976
3938,3977
3938,3978
3938,3979
3938,3980
3938,3981
3938,3982
3938,3983
3938,3984
3938,3985
3938,3986
3938,3987
3938,3988
3938,3989
3938,3990
3938,3991
3938,3992
3938,3993
3938,3994
3938,3995
3938,3996
3938,3997
3938,3998
3938,3999
3938,4000
3938,4001
3938,4002
3938,4003
3938,4004
3938,4005
3938,4006
3938,4007
3938,4008
3938,4009
3938,4010
3938,4011
3938,4012
3938,4013
3938,4014
3938,4015
3938,4016
3938,4017
3938,4018
3938,4019
3938,4020
3938,4021
3938,4022
3938,4023
3938,4024
3938,4025
3938,4026
3938,4027
3938,4028
3938,4029
3938,4030
3938,4031
3938,4032
3938,4033
3939,3940
3940,3941
3940,3942
3940,3943
3941,3942
3943,3944
3945,3946
3945,3947
3946,3947
3946,3948
3947,3948
3949,3950
3949,3951
3950,3951
3954,3955
3954,3956
3955,3956
3957,3958
3958,3959
3958,3960
3958,3961
3958,3962
3959,3960
3963,3964
3963,3965
3964,3965
3964,3966
3965,3966
3969,3970
3969,3971
3970,3971
3970,3972
3971,3972
3971,3973
3972,3973
3972,3974
3973,3974
3973,3975
3974,3975
3974,3976
3975,3976
3975,3977
3976,3977
3978,3979
3978,3980
3979,3980
3983,3984
3983,3985
3984,3985
3987,3988
3987,3989
3988,3989
3988,3990
3989,3990
3989,3991
3990,3991
3994,3995
3996,3997
3996,3998
3997,3998
3997,3999
3998,3999
3998,4000
3999,4000
4003,4004
4005,4006
4005,4007
4006,4007
4006,4008
4007,4008
4007,4009
4008,4009
4012,4013
4014,4015
4014,4016
4015,4016
4016,4017
4016,4018
4017,4018
4017,4019
4018,4019
4018,4020
4019,4020
4021,4022
4021,4023
4022,4023
4026,4027
4026,4028
4027,4028
4030,4031
4030,4032
4031,4032
4033,4034
4034,4035
4034,4036
4034,4037
4034,4038
4034,4039
4035,4036
4039,4040
4039,4041
4040,4041
4043,4044
4043,4045
4044,4045
4047,4048
4048,4049
4048,4050
4049,4050
4049,4051
4050,4051
4050,4052
4051,4052
4053,4054
4053,4055
4054,4055
4058,4059
4058,4060
4059,4060
4059,4061
4060,4061
4064,4065
4064,4066
4065,4066
4066,4067
4066,4068
4067,4068
4067,4069
4068,4069
4070,4071
4070,4072
4071,4072
4075,4076
4076,4077
4077,4078
4077,4079
4078,4079
4078,4080
4079,4080
4079,4081
4080,4081
4082,4083
4082,4084
4083,4084
4087,4088
4087,4089
4088,4089
4088,4090
4089,4090
4093,4094
4093,4095
4094,4095
4094,4096
4095,4096
4095,4097
4096,4097
4100,4101
4100,4102
4100,4103
4100,4104
4100,4105
4100,4106
4100,4107
4100,4108
4100,4109
4100,4110
4100,4111
4100,4112
4100,4113
4100,4114
4100,4115
4100,4116
4100,4117
4100,4118
4100,4119
4100,4120
4100,4121
4100,4122
4100,4123
4100,4124
4100,4125
4100,4126
4100,4127
4100,4128
4100,4129
4100,4130
4100,4131
4100,4132
4100,4133
4100,4134
4100,4135
4100,4136
4100,4137
4100,4138
4100,4139
4100,4140
4100,4141
4100,4142
4100,4143
4100,4144
4100,4145
4100,4146
4100,4147
4100,4148
4100,4149
4100,4150
4100,4151
4100,4152
4100,4153
4100,4154
4100,4155
4100,4156
4100,4157
4100,4158
4100,4159
4100,4160
4100,4161
4100,4162
4100,4163
4100,4164
4100,4165
4100,4166
4100,4167
4100,4168
4100,4169
4100,4170
4100,4171
4100,4172
4100,4173
4100,4174
4100,4175
4100,4176
4100,4177
4100,4178
4101,4102
4102,4103
4105,4106
4106,4107
4108,4109
4108,4110
4109,4110
4109,4111
4109,4112
4110,4111
4112,4113
4113,4114
4113,4115
4114,4115
4114,4116
4115,4116
4117,4118
4117,4119
4118,4119
4122,4123
4124,4125
4124,4126
4124,4127
4125,4126
4125,4127
4126,4127
4126,4128
4127,4128
4127,4129
4128,4129
4130,4131
4130,4132
4131,4132
4135,4136
4136,4137
4137,4138
4137,4139
4137,4140
4137,4141
4137,4142
4137,4143
4137,4144
4138,4139
4140,4141
4140,4142
4141,4142
4141,4143
4142,4143
4144,4145
4144,4146
4145,4146
4149,4150
4153,4154
4153,4155
4154,4155
4156,4157
4156,4158
4157,4158
4157,4159
4158,4159
4160,4161
4160,4162
4161,4162
4165,4166
4165,4167
4166,4167
4168,4169
4168,4170
4169,4170
4169,4171
4170,4171
4172,4173
4172,4174
4173,4174
4177,4178
4178,4179
4178,4180
4178,4181
4179,4180
4181,4182
4181,4183
4182,4183
4184,4185
4184,4186
4185,4186
4188,4189
4190,4191
4190,4192
4191,4192
4191,4193
4192,4193
4195,4196
4195,4197
4195,4198
4195,4199
4196,4197
4197,4198
4197,4199
4198,4199
4200,4201
4200,4202
4201,4202
4204,4205
4204,4206
4205,4206
4205,4207
4206,4207
4207,4208
4207,4209
4208,4209
4210,4211
4210,4212
4211,4212
4214,4215
4215,4216
4215,4217
4216,4217
4216,4218
4217,4218
4219,4220
4219,4221
4220,4221
4224,4225
4226,4227
4226,4228
4227,4228
4227,4229
4228,4229
4230,4231
4230,4232
4231,4232
4231,4233
4232,4233
4234,4235
4234,4236
4235,4236
4239,4240
4239,4241
4240,4241
4241,4242
4241,4243
4243,4244
4243,4245
4243,4246
4246,4247
4247,4248
4247,4249
4248,4249
4248,4250
4249,4250
4251,4252
4251,4253
4252,4253
4256,4257
4257,4258
4257,4259
4257,4260
4257,4261
4257,4262
4258,4259
4260,4261
4260,4262
4261,4262
4264,4265
4266,4267
4266,4268
4266,4269
4267,4268
4269,4270
4271,4272
4273,4274
4273,4275
4273,4276
4274,4275
4275,4276
4275,4277
4276,4277
4278,4279
4280,4281
4280,4282
4281,4282
4281,4283
4282,4283
4284,4285
4288,4289
4289,4290
4289,4291
4290,4291
4292,4293
4292,4294
4293,4294
4293,4295
4294,4295
4296,4297
4296,4298
4297,4298
4302,4303
4303,4304
4305,4306
4305,4307
4306,4307
4306,4308
4306,4309
4307,4308
4309,4310
4310,4311
4310,4312
4311,4312
4311,4313
4312,4313
4314,4315
4314,4316
4315,4316
4319,4320
4321,4322
4321,4323
4321,4324
4321,4325
4321,4326
4321,4327
4321,4328
4322,4323
4323,4324
4323,4325
4324,4325
4326,4327
4326,4328
4327,4328
4330,4331
4330,4332
4331,4332
4332,4333
4332,4334
4333,4334
4335,4336
4335,4337
4336,4337
4339,4340
4341,4342
4341,4343
4342,4343
4342,4344
4343,4344
4343,4345
4344,4345
4344,4346
4345,4346
4347,4348
4347,4349
4348,4349
4352,4353
4352,4354
4352,4355
4353,4354
4355,4356
4355,4357
4356,4357
4358,4359
4358,4360
4359,4360
4362,4363
4364,4365
4365,4366
4366,4367
4366,4368
4366,4369
4366,4370
4366,4371
4366,4372
4366,4373
4367,4368
4369,4370
4369,4371
4370,4371
4370,4372
4371,4372
4373,4374
4373,4375
4374,4375
4378,4379
4382,4383
4382,4384
4383,4384
4385,4386
4385,4387
4386,4387
4386,4388
4387,4388
4389,4390
4389,4391
4390,4391
4394,4395
4394,4396
4395,4396
4397,4398
4397,4399
4398,4399
4398,4400
4399,4400
4401,4402
4401,4403
4402,4403
4406,4407
4407,4408
4407,4409
4407,4410
4408,4409
4410,4411
4410,4412
4411,4412
4413,4414
4413,4415
4414,4415
4417,4418
4419,4420
4419,4421
4420,4421
4421,4422
4421,4423
4422,4423
4422,4424
4423,4424
4425,4426
4425,4427
4426,4427
4430,4431
4432,4433
4432,4434
4433,4434
4433,4435
4434,4435
4436,4437
4436,4438
4437,4438
4437,4439
4438,4439
4440,4441
4440,4442
4441,4442
4445,4446
4446,4447
4447,4448
4447,4449
4447,4450
4447,4451
4447,4452
4448,4449
4450,4451
4450,4452
4451,4452
4454,4455
4456,4457
4459,4460
4460,4461
4460,4462
4461,4462
4463,4464
4463,4465
4464,4465
4464,4466
4465,4466
4467,4468
4467,4469
4468,4469
4473,4474
4474,4475
4476,4477
4476,4478
4477,4478
4477,4479
4478,4479
4478,4480
4479,4480
4479,4481
4480,4481
4482,4483
4482,4484
4483,4484
4487,4488
4489,4490
4489,4491
4489,4492
4489,4493
4489,4494
4489,4495
4489,4496
4490,4491
4491,4492
4491,4493
4491,4494
4491,4495
4492,4493
4494,4495
4495,4496
4495,4497
4496,4497
4498,4499
4498,4500
4499,4500
4502,4503
4504,4505
4506,4507
4507,4508
4508,4509
4508,4510
4509,4510
4509,4511
4510,4511
4513,4514
4514,4515
4515,4516
4515,4517
4516,4517
4516,4518
4517,4518
4520,4521
4522,4523
4523,4524
4523,4525
4523,4526
4523,4527
4524,4525
4526,4527
4527,4528
4530,4531
4531,4532
4532,4533
4534,4535
4535,4536
4535,4537
4535,4538
4535,4539
4536,4537
4538,4539
4539,4540
4541,4542
4543,4544
4543,4545
4544,4545
4544,4546
4545,4546
4547,4548
4547,4549
4548,4549
4552,4553
4553,4554
4553,4555
4553,4556
4553,4557
4553,4558
4553,4559
4553,4560
4553,4561
4554,4555
4556,4557
4556,4558
4557,4558
4559,4560
4559,4561
4560,4561
4563,4564
4565,4566
4568,4569
4568,4570
4569,4570
4572,4573
4572,4574
4573,4574
4576,4577
4578,4579
4579,4580
4579,4581
4580,4581
4580,4582
4581,4582
4581,4583
4582,4583
4584,4585
4584,4586
4585,4586
4589,4590
4592,4593
4593,4594
4595,4596
4595,4597
4596,4597
4596,4598
4596,4599
4597,4598
4599,4600
4600,4601
4600,4602
4601,4602
4601,4603
4602,4603
4604,4605
4604,4606
4605,4606
4609,4610
4609,4611
4610,4611
4612,4613
4615,4616
4615,4617
4616,4617
4616,4618
4617,4618
4617,4619
4618,4619
4618,4620
4619,4620
4622,4623
4622,4624
4623,4624
4626,4627
4626,4628
4627,4628
4627,4629
4628,4629
4632,4633
4632,4634
4632,4635
4632,4636
4633,4634
4634,4635
4634,4636
4635,4636
4637,4638
4638,4639
4638,4640
4638,4641
4641,4642
4642,4643
4642,4644
4643,4644
4646,4647
4647,4648
4647,4649
4647,4650
4647,4651
4647,4652
4648,4649
4650,4651
4651,4652
4653,4654
4655,4656
4655,4657
4656,4657
4659,4660
4659,4661
4660,4661
4663,4664
4664,4665
4664,4666
4665,4666
4667,4668
4668,4669
4668,4670
4669,4670
4671,4672
4671,4673
4672,4673
4675,4676
4675,4677
4676,4677
4677,4678
4677,4679
4678,4679
4680,4681
4680,4682
4681,4682
4684,4685
4686,4687
4686,4688
4687,4688
4687,4689
4687,4690
4688,4689
4690,4691
4690,4692
4691,4692
4693,4694
4693,4695
4694,4695
4697,4698
4699,4700
4699,4701
4700,4701
4701,4702
4701,4703
4703,4704
4705,4706
4705,4707
4706,4707
4706,4708
4707,4708
4708,4709
4708,4710
4709,4710
4711,4712
4711,4713
4711,4714
4712,4713
4714,4715
4714,4716
4715,4716
4719,4720
4721,4722
4722,4723
4722,4724
4723,4724
4723,4725
4724,4725
4727,4728
4729,4730
4729,4731
4730,4731
4732,4733
4733,4734
4733,4735
4733,4736
4733,4737
4733,4738
4733,4739
4733,4740
4733,4741
4734,4735
4736,4737
4736,4738
4737,4738
4739,4740
4739,4741
4740,4741
4743,4744
4745,4746
4747,4748
4747,4749
4748,4749
4751,4752
4754,4755
4754,4756
4755,4756
4758,4759
4758,4760
4759,4760
4759,4761
4759,4762
4759,4763
4760,4761
4762,4763
4762,4764
4763,4764
4766,4767
4767,4768
4769,4770
4770,4771
4772,4773
4772,4774
4772,4775
4773,4774
4774,4775
4774,4776
4774,4777
4775,4776
4777,4778
4777,4779
4778,4779
4781,4782
4783,4784
4783,4785
4784,4785
4786,4787
4787,4788
4787,4789
4787,4790
4787,4791
4787,4792
4787,4793
4788,4789
4790,4791
4793,4794
4793,4795
4794,4795
4796,4797
4796,4798
4797,4798
4800,4801
4800,4802
4801,4802
4801,4803
4802,4803
4804,4805
4804,4806
4805,4806
4809,4810
4809,4811
4810,4811
4810,4812
4811,4812
4813,4814
4813,4815
4814,4815
4819,4820
4819,4821
4820,4821
4820,4822
4821,4822
4821,4823
4822,4823
4824,4825
4824,4826
4825,4826
4825,4827
4826,4827
4828,4829
4828,4830
4829,4830
4833,4834
4833,4835
4833,4836
4834,4835
4836,4837
4836,4838
4837,4838
4839,4840
4839,4841
4840,4841
4843,4844
4845,4846
4845,4847
4845,4848
4846,4847
4847,4848
4847,4849
4847,4850
4848,4849
4850,4851
4850,4852
4851,4852
4854,4855
4856,4857
4857,4858
4857,4859
4857,4860
4858,4859
4860,4861
4864,4865
4864,4866
4864,4867
4865,4866
4865,4867
4865,4868
4866,4867
4868,4869
4868,4870
4869,4870
4869,4871
4870,4871
4872,4873
4872,4874
4873,4874
4878,4879
4878,4880
4878,4881
4878,4882
4878,4883
4878,4884
4878,4885
4878,4886
4879,4880
4880,4881
4880,4882
4880,4883
4880,4884
4882,4883
4882,4884
4885,4886
4885,4887
4888,4889
4888,4890
4891,4892
4892,4893
4892,4894
4893,4894
4895,4896
4895,4897
4896,4897
4898,4899
4898,4900
4899,4900
4899,4901
4900,4901
4902,4903
4902,4904
4903,4904
4907,4908
4908,4909
4908,4910
4909,4910
4911,4912
4911,4913
4912,4913
4914,4915
4914,4916
4915,4916
4915,4917
4916,4917
4918,4919
4918,4920
4919,4920
4923,4924
4924,4925
4924,4926
4925,4926
4927,4928
4927,4929
4928,4929
4930,4931
4930,4932
4931,4932
4931,4933
4932,4933
4934,4935
4934,4936
4935,4936
4939,4940
4940,4941
4940,4942
4941,4942
4943,4944
4944,4945
4944,4946
4944,4947
4947,4948
4948,4949
4948,4950
4949,4950
4952,4953
4953,4954
4953,4955
4954,4955
4956,4957
4956,4958
4956,4959
4956,4960
4956,4961
4956,4962
4957,4958
4959,4960
4961,4962
4963,4964
4966,4967
4968,4969
4969,4970
4969,4971
4970,4971
4972,4973
4973,4974
4973,4975
4974,4975
4976,4977
4976,4978
4977,4978
4980,4981
4980,4982
4981,4982
4982,4983
4982,4984
4983,4984
4985,4986
4985,4987
4986,4987
4989,4990
4991,4992
4992,4993
4992,4994
4993,4994
4996,4997
4997,4998
4997,4999
4997,5000
4998,4999
5000,5001
5002,5003
5003,5004
5005,5006
5005,5007
5006,5007
5006,5008
5007,5008
5007,5009
5008,5009
5010,5011
5010,5012
5011,5012
5011,5013
5012,5013
5014,5015
5014,5016
5015,5016
5019,5020
5019,5021
5020,5021
5022,5023
5022,5024
5023,5024
5023,5025
5024,5025
5026,5027
5026,5028
5027,5028
5031,5032
5031,5033
5032,5033
5032,5034
5032,5035
5033,5034
5033,5035
5034,5035
5034,5036
5034,5037
5035,5036
5037,5038
5037,5039
5038,5039
5038,5040
5039,5040
5041,5042
5041,5043
5042,5043
5047,5048
5048,5049
5050,5051
5050,5052
5050,5053
5050,5054
5050,5055
5050,5056
5051,5052
5052,5053
5052,5054
5052,5055
5052,5056
5053,5054
5055,5056
5056,5057
5059,5060
5060,5061
5061,5062
5063,5064
5064,5065
5064,5066
5064,5067
5064,5068
5065,5066
5067,5068
5068,5069
5070,5071
5073,5074
5074,5075
5074,5076
5074,5077
5074,5078
5075,5076
5077,5078
5078,5079
5080,5081
5082,5083
5084,5085
5085,5086
5085,5087
5085,5088
5085,5089
5085,5090
5085,5091
5085,5092
5085,5093
5086,5087
5088,5089
5088,5090
5089,5090
5091,5092
5091,5093
5092,5093
5095,5096
5097,5098
5100,5101
5100,5102
5101,5102
5104,5105
5104,5106
5105,5106
5108,5109
5110,5111
5110,5112
5111,5112
5112,5113
5112,5114
5113,5114
5115,5116
5115,5117
5116,5117
5119,5120
5121,5122
5121,5123
5122,5123
5124,5125
5125,5126
5125,5127
5125,5128
5125,5129
5125,5130
5125,5131
5126,5127
5128,5129
5131,5132
5131,5133
5132,5133
5134,5135
5134,5136
5135,5136
5138,5139
5138,5140
5139,5140
5139,5141
5140,5141
5142,5143
5142,5144
5143,5144
5147,5148
5147,5149
5148,5149
5148,5150
5149,5150
5151,5152
5151,5153
5152,5153
5156,5157
5156,5158
5156,5159
5157,5158
5157,5159
5157,5160
5158,5159
5158,5160
5158,5161
5159,5160
5161,5162
5161,5163
5162,5163
5164,5165
5164,5166
5165,5166
5168,5169
5170,5171
5170,5172
5170,5173
5170,5174
5170,5175
5171,5172
5171,5173
5171,5174
5172,5173
5172,5174
5172,5175
5173,5174
5175,5176
5175,5177
5176,5177
5178,5179
5178,5180
5179,5180
5182,5183
5184,5185
5185,5186
5186,5187
5186,5188
5187,5188
5190,5191
5191,5192
5192,5193
5192,5194
5193,5194
5196,5197
5197,5198
5197,5199
5198,5199
5200,5201
5200,5202
5201,5202
5201,5203
5202,5203
5202,5204
5203,5204
5205,5206
5205,5207
5206,5207
5210,5211
5210,5212
5211,5212
5211,5213
5212,5213
5214,5215
5214,5216
5215,5216
5219,5220
5220,5221
5220,5222
5220,5223
5220,5224
5221,5222
5223,5224
5224,5225
5227,5228
5228,5229
5229,5230
5231,5232
5232,5233
5232,5234
5232,5235
5233,5234
5235,5236
5238,5239
5239,5240
5239,5241
5239,5242
5240,5241
5242,5243
5245,5246
5245,5247
5245,5248
5245,5249
5245,5250
5245,5251
5245,5252
5246,5247
5247,5248
5247,5249
5248,5249
5250,5251
5252,5253
5253,5254
5253,5255
5254,5255
5257,5258
5257,5259
5258,5259
5258,5260
5259,5260
5262,5263
5263,5264
5263,5265
5263,5266
5263,5267
5263,5268
5264,5265
5266,5267
5267,5268
5267,5269
5268,5269
5268,5270
5269,5270
5271,5272
5271,5273
5272,5273
5276,5277
5276,5278
5277,5278
5282,5283
5282,5284
5282,5285
5283,5284
5283,5285
5283,5286
5283,5287
5284,5285
5286,5287
5287,5288
5287,5289
5288,5289
5288,5290
5289,5290
5291,5292
5291,5293
5292,5293
5297,5298
5298,5299
5300,5301
5301,5302
5301,5303
5301,5304
5302,5303
5302,5304
5302,5305
5303,5304
5305,5306
5305,5307
5306,5307
5308,5309
5308,5310
5309,5310
5312,5313
5314,5315
5314,5316
5315,5316
5316,5317
5316,5318
5317,5318
5319,5320
5319,5321
5320,5321
5320,5322
5321,5322
5323,5324
5323,5325
5324,5325
5328,5329
5329,5330
5329,5331
5330,5331
5333,5334
5334,5335
5335,5336
5335,5337
5336,5337
5338,5339
5338,5340
5339,5340
5339,5341
5340,5341
5342,5343
5342,5344
5343,5344
5347,5348
5348,5349
5348,5350
5349,5350
5351,5352
5351,5353
5352,5353
5352,5354
5353,5354
5355,5356
5355,5357
5356,5357
5360,5361
5361,5362
5361,5363
5362,5363
5364,5365
5364,5366
5364,5367
5364,5368
5365,5366
5367,5368
5368,5369
5370,5371
5370,5372
5371,5372
5371,5373
5372,5373
5372,5374
5373,5374
5375,5376
5375,5377
5376,5377
5380,5381
5380,5382
5381,5382
5381,5383
5382,5383
5384,5385
5384,5386
5385,5386
5390,5391
5391,5392
5391,5393
5391,5394
5391,5395
5392,5393
5394,5395
5395,5396
5395,5397
5396,5397
5396,5398
5397,5398
5399,5400
5399,5401
5400,5401
5404,5405
5406,5407
5406,5408
5407,5408
5408,5409
5409,5410
5412,5413
5413,5414
5413,5415
5413,5416
5413,5417
5414,5415
5416,5417
5417,5418
5417,5419
5418,5419
5418,5420
5419,5420
5421,5422
5421,5423
5422,5423
5426,5427
5428,5429
5428,5430
5429,5430
5430,5431
5431,5432
5434,5435
5434,5436
5435,5436
5436,5437
5438,5439
5438,5440
5439,5440
5439,5441
5440,5441
5441,5442
5441,5443
5441,5444
5442,5443
5444,5445
5444,5446
5445,5446
5447,5448
5447,5449
5448,5449
5451,5452
5453,5454
5454,5455
5454,5456
5455,5456
5457,5458
5457,5459
5458,5459
5458,5460
5459,5460
5459,5461
5460,5461
5462,5463
5462,5464
5463,5464
5467,5468
5467,5469
5468,5469
5468,5470
5469,5470
5471,5472
5471,5473
5472,5473
5476,5477
5476,5478
5476,5479
5477,5478
5478,5479
5480,5481
5480,5482
5480,5483
5480,5484
5480,5485
5480,5486
5481,5482
5482,5483
5482,5484
5482,5485
5482,5486
5483,5484
5485,5486
5486,5487
5489,5490
5490,5491
5491,5492
5493,5494
5494,5495
5494,5496
5494,5497
5494,5498
5495,5496
5497,5498
5498,5499
5500,5501
5503,5504
5504,5505
5504,5506
5504,5507
5504,5508
5505,5506
5507,5508
5508,5509
5510,5511
5512,5513
5514,5515
5515,5516
5515,5517
5515,5518
5515,5519
5515,5520
5515,5521
5515,5522
5515,5523
5516,5517
5518,5519
5518,5520
5519,5520
5521,5522
5521,5523
5522,5523
5525,5526
5527,5528
5530,5531
5530,5532
5531,5532
5534,5535
5534,5536
5535,5536
5538,5539
5540,5541
5540,5542
5541,5542
5542,5543
5542,5544
5543,5544
5545,5546
5545,5547
5546,5547
5549,5550
5551,5552
5551,5553
5552,5553
5554,5555
5554,5556
5555,5556
5556,5557
5556,5558
5556,5559
5556,5560
5558,5559
5558,5560
5560,5561
5562,5563
5562,5564
5564,5565
5566,5567
5566,5568
5568,5569
5570,5571
5570,5572
5570,5573
5571,5572
5571,5573
5571,5574
5572,5573
5574,5575
5574,5576
5575,5576
5577,5578
5577,5579
5578,5579
5581,5582
5583,5584
5584,5585
5585,5586
5585,5587
5585,5588
5585,5589
5585,5590
5585,5591
5586,5587
5588,5589
5591,5592
5591,5593
5592,5593
5594,5595
5594,5596
5595,5596
5598,5599
5598,5600
5598,5601
5598,5602
5599,5600
5601,5602
5603,5604
5604,5605
5605,5606
5607,5608
5607,5609
5608,5609
5608,5610
5609,5610
5611,5612
5611,5613
5612,5613
5616,5617
5616,5618
5616,5619
5616,5620
5617,5618
5619,5620
5621,5622
5622,5623
5623,5624
5625,5626
5625,5627
5626,5627
5626,5628
5627,5628
5629,5630
5629,5631
5630,5631
5634,5635
5635,5636
5636,5637
5636,5638
5636,5639
5636,5640
5636,5641
5636,5642
5636,5643
5637,5638
5639,5640
5642,5643
5642,5644
5643,5644
5645,5646
5645,5647
5646,5647
5649,5650
5649,5651
5649,5652
5649,5653
5650,5651
5652,5653
5654,5655
5655,5656
5656,5657
5658,5659
5658,5660
5659,5660
5659,5661
5660,5661
5662,5663
5662,5664
5663,5664
5667,5668
5667,5669
5667,5670
5667,5671
5668,5669
5670,5671
5672,5673
5673,5674
5674,5675
5676,5677
5676,5678
5677,5678
5677,5679
5678,5679
5680,5681
5680,5682
5681,5682
5685,5686
5685,5687
5685,5688
5685,5689
5686,5687
5688,5689
5690,5691
5691,5692
5692,5693
5694,5695
5694,5696
5695,5696
5695,5697
5696,5697
5698,5699
5698,5700
5699,5700
5703,5704
5703,5705
5704,5705
5704,5706
5704,5707
5705,5706
5705,5707
5705,5708
5706,5707
5708,5709
5708,5710
5709,5710
5711,5712
5711,5713
5712,5713
5715,5716
5717,5718
5718,5719
5718,5720
5719,5720
5720,5721
5721,5722
5721,5723
5722,5723
5722,5724
5723,5724
5723,5725
5724,5725
5726,5727
5726,5728
5727,5728
5731,5732
5731,5733
5732,5733
5732,5734
5733,5734
5735,5736
5735,5737
5736,5737
5740,5741
5741,5742
5741,5743
5742,5743
5745,5746
5746,5747
5746,5748
5746,5749
5747,5748
5747,5749
5747,5750
5748,5749
5750,5751
5750,5752
5751,5752
5753,5754
5753,5755
5754,5755
5757,5758
5759,5760
5759,5761
5759,5762
5759,5763
5759,5764
5760,5761
5761,5762
5761,5763
5762,5763
5764,5765
5764,5766
5764,5767
5765,5766
5765,5767
5765,5768
5766,5767
5768,5769
5768,5770
5769,5770
5771,5772
5771,5773
5772,5773
5775,5776
5779,5780
5780,5781
5780,5782
5780,5783
5780,5784
5781,5782
5783,5784
5784,5785
5787,5788
5788,5789
5789,5790
5791,5792
5792,5793
5792,5794
5793,5794
5795,5796
5795,5797
5796,5797
5798,5799
5798,5800
5799,5800
5799,5801
5800,5801
5800,5802
5801,5802
5803,5804
5803,5805
5804,5805
5808,5809
5808,5810
5809,5810
5809,5811
5810,5811
5812,5813
5812,5814
5813,5814
5817,5818
5818,5819
5818,5820
5818,5821
5819,5820
5821,5822
5824,5825
5825,5826
5825,5827
5825,5828
5826,5827
5828,5829
5831,5832
5831,5833
5831,5834
5832,5833
5833,5834
5833,5835
5834,5835
5836,5837
5838,5839
5839,5840
5839,5841
5840,5841
5843,5844
5843,5845
5843,5846
5844,5845
5844,5846
5844,5847
5844,5848
5845,5846
5847,5848
5848,5849
5848,5850
5849,5850
5849,5851
5850,5851
5852,5853
5852,5854
5853,5854
5858,5859
5859,5860
5861,5862
5861,5863
5862,5863
5862,5864
5862,5865
5863,5864
5863,5865
5863,5866
5864,5865
5866,5867
5866,5868
5867,5868
5869,5870
5869,5871
5870,5871
5873,5874
5875,5876
5876,5877
5877,5878
5877,5879
5878,5879
5880,5881
5880,5882
5881,5882
5881,5883
5882,5883
5884,5885
5884,5886
5885,5886
5889,5890
5889,5891
5890,5891
5891,5892
5891,5893
5892,5893
5894,5895
5894,5896
5895,5896
5895,5897
5896,5897
5898,5899
5898,5900
5899,5900
5903,5904
5904,5905
5904,5906
5905,5906
5908,5909
5909,5910
5909,5911
5910,5911
5912,5913
5912,5914
5912,5915
5912,5916
5913,5914
5915,5916
5916,5917
5918,5919
5918,5920
5919,5920
5919,5921
5920,5921
5920,5922
5921,5922
5923,5924
5923,5925
5924,5925
5928,5929
5928,5930
5929,5930
5929,5931
5930,5931
5932,5933
5932,5934
5933,5934
5938,5939
5939,5940
5939,5941
5940,5941
5942,5943
5942,5944
5943,5944
5945,5946
5945,5947
5946,5947
5946,5948
5947,5948
5947,5949
5948,5949
5950,5951
5950,5952
5951,5952
5955,5956
5955,5957
5956,5957
5956,5958
5957,5958
5959,5960
5959,5961
5960,5961
5964,5965
5964,5966
5965,5966
5966,5967
5968,5969
5968,5970
5968,5971
5968,5972
5968,5973
5968,5974
5968,5975
5968,5976
5968,5977
5968,5978
5969,5970
5970,5971
5970,5972
5970,5973
5970,5974
5972,5973
5972,5974
5974,5975
5976,5977
5976,5978
5978,5979
5980,5981
5980,5982
5982,5983
5984,5985
5985,5986
5985,5987
5985,5988
5985,5989
5986,5987
5988,5989
5989,5990
5992,5993
5993,5994
5994,5995
5996,5997
5997,5998
5997,5999
5997,6000
5997,6001
5998,5999
6000,6001
6001,6002
6003,6004
6006,6007
6007,6008
6007,6009
6007,6010
6007,6011
6008,6009
6010,6011
6011,6012
6013,6014
6015,6016
6017,6018
6018,6019
6018,6020
6018,6021
6018,6022
6019,6020
6021,6022
6024,6025
6024,6026
6024,6027
6024,6028
6025,6026
6027,6028
6029,6030
6030,6031
6031,6032
6033,6034
6033,6035
6034,6035
6034,6036
6035,6036
6035,6037
6036,6037
6038,6039
6038,6040
6039,6040
6043,6044
6043,6045
6044,6045
6044,6046
6045,6046
6047,6048
6047,6049
6048,6049
6052,6053
6053,6054
6053,6055
6053,6056
6053,6057
6053,6058
6053,6059
6053,6060
6053,6061
6054,6055
6056,6057
6056,6058
6057,6058
6059,6060
6059,6061
6060,6061
6063,6064
6065,6066
6068,6069
6068,6070
6069,6070
6072,6073
6072,6074
6073,6074
6076,6077
6078,6079
6078,6080
6079,6080
6080,6081
6080,6082
6081,6082
6083,6084
6083,6085
6084,6085
6087,6088
6089,6090
6089,6091
6090,6091
6092,6093
6093,6094
6094,6095
6094,6096
6094,6097
6094,6098
6094,6099
6094,6100
6094,6101
6095,6096
6097,6098
6100,6101
6100,6102
6101,6102
6103,6104
6103,6105
6104,6105
6107,6108
6107,6109
6107,6110
6107,6111
6108,6109
6110,6111
6112,6113
6113,6114
6114,6115
6116,6117
6116,6118
6117,6118
6117,6119
6118,6119
6120,6121
6120,6122
6121,6122
6125,6126
6125,6127
6125,6128
6125,6129
6126,6127
6128,6129
6130,6131
6131,6132
6132,6133
6134,6135
6134,6136
6135,6136
6135,6137
6136,6137
6138,6139
6138,6140
6139,6140
6143,6144
6143,6145
6143,6146
6143,6147
6144,6145
6146,6147
6148,6149
6149,6150
6150,6151
6152,6153
6152,6154
6153,6154
6153,6155
6154,6155
6156,6157
6156,6158
6157,6158
6161,6162
6162,6163
6162,6164
6162,6165
6163,6164
6165,6166
6165,6167
6166,6167
6168,6169
6168,6170
6169,6170
6172,6173
6175,6176
6175,6177
6176,6177
6178,6179
6178,6180
6178,6181
6178,6182
6178,6183
6179,6180
6180,6181
6180,6182
6180,6183
6180,6184
6181,6182
6183,6184
6184,6185
6187,6188
6188,6189
6189,6190
6191,6192
6192,6193
6192,6194
6192,6195
6192,6196
6193,6194
6195,6196
6196,6197
6198,6199
6200,6201
6202,6203
6203,6204
6203,6205
6203,6206
6203,6207
6203,6208
6204,6205
6206,6207
6207,6208
6209,6210
6212,6213
6214,6215
6215,6216
6215,6217
6215,6218
6215,6219
6215,6220
6215,6221
6215,6222
6215,6223
6216,6217
6218,6219
6218,6220
6219,6220
6221,6222
6221,6223
6222,6223
6225,6226
6227,6228
6230,6231
6230,6232
6231,6232
6234,6235
6234,6236
6235,6236
6238,6239
6240,6241
6240,6242
6240,6243
6241,6242
6241,6243
6241,6244
6242,6243
6244,6245
6244,6246
6245,6246
6245,6247
6246,6247
6248,6249
6248,6250
6249,6250
6254,6255
6254,6256
6254,6257
6254,6258
6254,6259
6255,6256
6256,6257
6256,6258
6256,6259
6257,6258
6259,6260
6260,6261
6260,6262
6261,6262
6261,6263
6262,6263
6264,6265
6264,6266
6265,6266
6269,6270
6271,6272
6272,6273
6272,6274
6272,6275
6272,6276
6272,6277
6272,6278
6272,6279
6272,6280
6272,6281
6272,6282
6272,6283
6272,6284
6272,6285
6272,6286
6273,6274
6277,6278
6277,6279
6278,6279
6280,6281
6280,6282
6281,6282
6284,6285
6286,6287
6286,6288
6287,6288
6289,6290
6289,6291
6290,6291
6290,6292
6291,6292
6293,6294
6293,6295
6294,6295
6298,6299
6300,6301
6302,6303
6304,6305
6304,6306
6305,6306
6307,6308
6309,6310
6311,6312
6313,6314
6315,6316
6317,6318
6318,6319
6318,6320
6319,6320
6319,6321
6320,6321
6320,6322
6321,6322
6323,6324
6323,6325
6324,6325
6328,6329
6330,6331
6331,6332
6331,6333
6332,6333
6334,6335
6334,6336
6335,6336
6338,6339
6339,6340
6339,6341
6339,6342
6340,6341
6342,6343
6342,6344
6343,6344
6345,6346
6345,6347
6346,6347
6349,6350
6351,6352
6351,6353
6352,6353
6353,6354
6353,6355
6353,6356
6354,6355
6356,6357
6357,6358
6357,6359
6358,6359
6358,6360
6359,6360
6361,6362
6361,6363
6362,6363
6366,6367
6368,6369
6369,6370
6369,6371
6369,6372
6369,6373
6370,6371
6374,6375
6374,6376
6375,6376
6377,6378
6377,6379
6378,6379
6382,6383
6382,6384
6382,6385
6383,6384
6383,6385
6384,6385
6384,6386
6385,6386
6385,6387
6386,6387
6388,6389
6388,6390
6389,6390
6393,6394
6395,6396
6396,6397
6396,6398
6396,6399
6397,6398
6399,6400
6399,6401
6400,6401
6402,6403
6402,6404
6403,6404
6406,6407
6406,6408
6407,6408
6410,6411
6411,6412
6411,6413
6412,6413
6412,6414
6413,6414
6413,6415
6414,6415
6416,6417
6416,6418
6417,6418
6422,6423
6422,6424
6423,6424
6423,6425
6424,6425
6425,6426
6425,6427
6426,6427
6428,6429
6428,6430
6429,6430
6432,6433
6432,6434
6433,6434
6435,6436
6435,6437
6436,6437
6439,6440
6440,6441
6440,6442
6440,6443
6441,6442
6443,6444
6444,6445
6444,6446
6445,6446
6445,6447
6446,6447
6448,6449
6448,6450
6449,6450
6453,6454
6456,6457
6457,6458
6459,6460
6459,6461
6460,6461
6460,6462
6461,6462
6461,6463
6462,6463
6462,6464
6462,6465
6463,6464
6465,6466
6466,6467
6466,6468
6467,6468
6467,6469
6468,6469
6470,6471
6470,6472
6471,6472
6475,6476
6477,6478
6478,6479
6478,6480
6478,6481
6479,6480
6481,6482
6482,6483
6482,6484
6483,6484
6483,6485
6484,6485
6486,6487
6486,6488
6487,6488
6491,6492
6493,6494
6493,6495
6494,6495
6497,6498
6498,6499
6498,6500
6498,6501
6499,6500
6501,6502
6502,6503
6503,6504
6503,6505
6503,6506
6503,6507
6503,6508
6504,6505
6506,6507
6506,6508
6507,6508
6510,6511
6510,6512
6511,6512
6511,6513
6512,6513
6514,6515
6514,6516
6515,6516
6519,6520
6519,6521
6520,6521
6523,6524
6523,6525
6524,6525
6524,6526
6525,6526
6527,6528
6527,6529
6528,6529
6532,6533
6533,6534
6534,6535
6534,6536
6534,6537
6534,6538
6534,6539
6534,6540
6535,6536
6537,6538
6537,6539
6538,6539
6541,6542
6541,6543
6542,6543
6542,6544
6543,6544
6545,6546
6545,6547
6546,6547
6550,6551
6550,6552
6551,6552
6554,6555
6554,6556
6555,6556
6555,6557
6556,6557
6558,6559
6558,6560
6559,6560
6565,6566
6566,6567
6568,6569
6569,6570
6569,6571
6569,6572
6570,6571
6572,6573
6572,6574
6573,6574
6575,6576
6575,6577
6576,6577
6579,6580
6581,6582
6582,6583
6582,6584
6582,6585
6582,6586
6583,6584
6587,6588
6587,6589
6588,6589
6591,6592
6591,6593
6592,6593
6592,6594
6593,6594
6593,6595
6594,6595
6596,6597
6596,6598
6597,6598
6601,6602
6601,6603
6602,6603
6603,6604
6603,6605
6603,6606
6604,6605
6606,6607
6606,6608
6607,6608
6610,6611
6610,6612
6611,6612
6614,6615
6614,6616
6615,6616
6616,6617
6616,6618
6617,6618
6619,6620
6619,6621
6620,6621
6623,6624
6625,6626
6626,6627
6626,6628
6626,6629
6626,6630
6626,6631
6626,6632
6626,6633
6626,6634
6627,6628
6629,6630
6629,6631
6630,6631
6632,6633
6632,6634
6633,6634
6636,6637
6638,6639
6640,6641
6640,6642
6641,6642
6644,6645
6647,6648
6647,6649
6648,6649
6651,6652
6652,6653
6652,6654
6653,6654
6655,6656
6655,6657
6656,6657
6660,6661
6661,6662
6663,6664
6663,6665
6664,6665
6664,6666
6665,6666
6665,6667
6666,6667
6668,6669
6668,6670
6669,6670
6673,6674
6673,6675
6674,6675
6675,6676
6675,6677
6675,6678
6676,6677
6678,6679
6678,6680
6679,6680
6682,6683
6682,6684
6683,6684
6686,6687
6686,6688
6687,6688
6688,6689
6688,6690
6689,6690
6691,6692
6691,6693
6692,6693
6695,6696
6697,6698
6697,6699
6698,6699
6699,6700
6699,6701
6699,6702
6700,6701
6702,6703
6702,6704
6703,6704
6705,6706
6705,6707
6706,6707
6709,6710
6711,6712
6711,6713
6712,6713
6712,6714
6713,6714
6713,6715
6714,6715
6714,6716
6715,6716
6715,6717
6716,6717
6718,6719
6718,6720
6719,6720
6723,6724
6725,6726
6726,6727
6726,6728
6726,6729
6726,6730
6726,6731
6727,6728
6729,6730
6732,6733
6732,6734
6733,6734
6735,6736
6735,6737
6736,6737
6736,6738
6737,6738
6737,6739
6738,6739
6740,6741
6740,6742
6741,6742
6746,6747
6746,6748
6746,6749
6747,6748
6747,6749
6748,6749
6751,6752
6751,6753
6752,6753
6756,6757
6757,6758
6757,6759
6757,6760
6757,6761
6758,6759
6762,6763
6762,6764
6763,6764
6766,6767
6767,6768
6767,6769
6767,6770
6767,6771
6767,6772
6767,6773
6767,6774
6767,6775
6768,6769
6770,6771
6770,6772
6771,6772
6773,6774
6773,6775
6774,6775
6777,6778
6779,6780
6781,6782
6781,6783
6782,6783
6785,6786
6788,6789
6788,6790
6789,6790
6792,6793
6792,6794
6793,6794
6794,6795
6794,6796
6794,6797
6795,6796
6797,6798
6797,6799
6798,6799
6800,6801
6800,6802
6801,6802
6804,6805
6806,6807
6807,6808
6807,6809
6808,6809
6808,6810
6809,6810
6809,6811
6810,6811
6812,6813
6812,6814
6813,6814
6817,6818
6819,6820
6820,6821
6820,6822
6821,6822
6823,6824
6823,6825
6824,6825
6828,6829
6829,6830
6831,6832
6831,6833
6831,6834
6831,6835
6831,6836
6831,6837
6831,6838
6831,6839
6832,6833
6833,6834
6833,6835
6834,6835
6836,6837
6836,6838
6839,6840
6840,6841
6840,6842
6841,6842
6843,6844
6843,6845
6846,6847
6847,6848
6847,6849
6848,6849
6850,6851
6850,6852
6851,6852
6854,6855
6854,6856
6855,6856
6856,6857
6856,6858
6857,6858
6859,6860
6859,6861
6860,6861
6863,6864
6865,6866
6866,6867
6866,6868
6867,6868
6869,6870
6869,6871
6870,6871
6870,6872
6871,6872
6873,6874
6873,6875
6874,6875
6878,6879
6879,6880
6879,6881
6880,6881
6882,6883
6882,6884
6882,6885
6883,6884
6885,6886
6885,6887
6886,6887
6888,6889
6890,6891
6892,6893
6892,6894
6892,6895
6893,6894
6893,6895
6894,6895
6896,6897
6896,6898
6897,6898
6900,6901
6900,6902
6900,6903
6900,6904
6900,6905
6900,6906
6900,6907
6900,6908
6900,6909
6900,6910
6900,6911
6900,6912
6901,6902
6902,6903
6902,6904
6904,6905
6904,6906
6907,6908
6908,6909
6908,6910
6909,6910
6911,6912
6911,6913
6912,6913
6914,6915
6914,6916
6915,6916
6915,6917
6916,6917
6918,6919
6918,6920
6919,6920
6923,6924
6924,6925
6924,6926
6925,6926
6927,6928
6929,6930
6930,6931
6930,6932
6931,6932
6933,6934
6935,6936
6936,6937
6936,6938
6937,6938
6939,6940
6941,6942
6942,6943
6942,6944
6943,6944
6945,6946
6946,6947
6946,6948
6946,6949
6949,6950
6950,6951
6950,6952
6951,6952
6954,6955
6955,6956
6955,6957
6955,6958
6955,6959
6956,6957
6958,6959
6961,6962
6961,6963
6962,6963
6964,6965
6966,6967
6967,6968
6967,6969
6967,6970
6967,6971
6968,6969
6970,6971
6973,6974
6973,6975
6974,6975
6976,6977
6978,6979
6978,6980
6978,6981
6979,6980
6979,6981
6979,6982
6979,6983
6980,6981
6982,6983
6982,6984
6983,6984
6986,6987
6988,6989
6990,6991
6990,6992
6991,6992
6992,6993
6992,6994
6992,6995
6992,6996
6993,6994
6997,6998
6997,6999
6998,6999
7000,7001
7002,7003
7002,7004
7003,7004
7003,7005
7003,7006
7003,7007
7003,7008
7004,7005
7006,7007
7008,7009
7010,7011
7010,7012
7011,7012
7014,7015
7016,7017
7017,7018
7018,7019
7018,7020
7018,7021
7018,7022
7019,7020
7021,7022
7024,7025
7024,7026
7025,7026
7027,7028
7029,7030
7030,7031
7030,7032
7030,7033
7031,7032
7031,7033
7031,7034
7031,7035
7031,7036
7032,7033
7034,7035
7036,7037
7038,7039
7038,7040
7039,7040
7043,7044
7044,7045
7045,7046
7045,7047
7045,7048
7045,7049
7045,7050
7045,7051
7046,7047
7048,7049
7051,7052
7051,7053
7052,7053
7054,7055
7056,7057
7056,7058
7057,7058
7060,7061
7062,7063
7063,7064
7064,7065
7064,7066
7064,7067
7064,7068
7064,7069
7064,7070
7065,7066
7069,7070
7069,7071
7070,7071
7072,7073
7074,7075
7074,7076
7075,7076
7078,7079
7080,7081
7081,7082
7081,7083
7082,7083
7084,7085
7086,7087
7087,7088
7087,7089
7088,7089
7090,7091
7092,7093
7093,7094
7093,7095
7094,7095
7096,7097
7097,7098
7097,7099
7098,7099
7100,7101
7100,7102
7101,7102
7104,7105
7104,7106
7105,7106
7106,7107
7106,7108
7106,7109
7106,7110
7107,7108
7111,7112
7111,7113
7112,7113
7115,7116
7115,7117
7116,7117
7118,7119
7119,7120
7120,7121
7120,7122
7121,7122
7123,7124
7126,7127
7127,7128
7129,7130
7129,7131
7130,7131
7130,7132
7130,7133
7131,7132
7133,7134
7134,7135
7134,7136
7135,7136
7135,7137
7136,7137
7138,7139
7138,7140
7139,7140
7143,7144
7143,7145
7144,7145
7144,7146
7145,7146
7147,7148
7149,7150
7152,7153
7152,7154
7153,7154
7153,7155
7153,7156
7154,7155
7156,7157
7156,7158
7157,7158
7159,7160
7159,7161
7160,7161
7163,7164
7165,7166
7165,7167
7165,7168
7166,7167
7167,7168
7167,7169
7167,7170
7167,7171
7167,7172
7167,7173
7167,7174
7167,7175
7168,7169
7170,7171
7170,7172
7171,7172
7173,7174
7173,7175
7174,7175
7177,7178
7179,7180
7181,7182
7181,7183
7182,7183
7185,7186
7188,7189
7188,7190
7189,7190
7192,7193
7193,7194
7193,7195
7194,7195
7196,7197
7196,7198
7197,7198
7201,7202
7201,7203
7201,7204
7202,7203
7202,7204
7203,7204
7206,7207
7207,7208
7208,7209
7208,7210
7209,7210
7209,7211
7210,7211
7210,7212
7211,7212
7213,7214
7213,7215
7214,7215
7218,7219
7218,7220
7219,7220
7222,7223
7223,7224
7223,7225
7223,7226
7224,7225
7224,7226
7225,7226
7225,7227
7226,7227
7228,7229
7228,7230
7229,7230
7233,7234
7234,7235
7234,7236
7235,7236
7235,7237
7236,7237
7236,7238
7237,7238
7239,7240
7239,7241
7240,7241
7244,7245
7244,7246
7245,7246
7247,7248
7247,7249
7248,7249
7250,7251
7250,7252
7251,7252
7251,7253
7252,7253
7254,7255
7254,7256
7255,7256
7259,7260
7260,7261
7260,7262
7261,7262
7261,7263
7262,7263
7262,7264
7263,7264
7265,7266
7265,7267
7266,7267
7270,7271
7270,7272
7271,7272
7271,7273
7272,7273
7274,7275
7274,7276
7275,7276
7279,7280
7280,7281
7280,7282
7280,7283
7280,7284
7280,7285
7281,7282
7285,7286
7285,7287
7286,7287
7288,7289
7288,7290
7289,7290
7289,7291
7290,7291
7290,7292
7291,7292
7293,7294
7293,7295
7294,7295
7299,7300
7299,7301
7300,7301
7302,7303
7302,7304
7303,7304
7303,7305
7304,7305
7306,7307
7306,7308
7307,7308
7311,7312
7311,7313
7311,7314
7312,7313
7313,7314
7314,7315
7314,7316
7315,7316
7315,7317
7316,7317
7316,7318
7317,7318
7319,7320
7319,7321
7320,7321
7324,7325
7324,7326
7325,7326
7325,7327
7326,7327
7328,7329
7328,7330
7329,7330
7333,7334
7333,7335
7333,7336
7333,7337
7333,7338
7333,7339
7334,7335
7335,7336
7335,7337
7335,7338
7335,7339
7336,7337
7338,7339
7339,7340
7342,7343
7343,7344
7344,7345
7346,7347
7347,7348
7347,7349
7347,7350
7347,7351
7348,7349
7350,7351
7351,7352
7353,7354
7356,7357
7357,7358
7357,7359
7357,7360
7357,7361
7358,7359
7360,7361
7361,7362
7363,7364
7365,7366
7367,7368
7368,7369
7368,7370
7368,7371
7368,7372
7368,7373
7368,7374
7368,7375
7368,7376
7369,7370
7371,7372
7371,7373
7372,7373
7374,7375
7374,7376
7375,7376
7378,7379
7380,7381
7383,7384
7383,7385
7384,7385
7387,7388
7387,7389
7388,7389
7391,7392
7393,7394
7393,7395
7394,7395
7395,7396
7395,7397
7396,7397
7398,7399
7398,7400
7399,7400
7402,7403
7404,7405
7404,7406
7405,7406
7407,7408
7407,7409
7408,7409
7409,7410
7409,7411
7409,7412
7411,7412
7411,7413
7413,7414
7415,7416
7415,7417
7417,7418
7419,7420
7420,7421
7420,7422
7420,7423
7420,7424
7420,7425
7420,7426
7421,7422
7423,7424
7426,7427
7426,7428
7427,7428
7429,7430
7429,7431
7430,7431
7433,7434
7433,7435
7433,7436
7433,7437
7434,7435
7436,7437
7438,7439
7439,7440
7440,7441
7442,7443
7442,7444
7443,7444
7443,7445
7444,7445
7446,7447
7446,7448
7447,7448
7451,7452
7451,7453
7451,7454
7451,7455
7452,7453
7454,7455
7456,7457
7457,7458
7458,7459
7460,7461
7460,7462
7461,7462
7461,7463
7462,7463
7464,7465
7464,7466
7465,7466
7469,7470
7469,7471
7469,7472
7470,7471
7471,7472
7471,7473
7471,7474
7472,7473
7474,7475
7475,7476
7475,7477
7476,7477
7476,7478
7477,7478
7479,7480
7479,7481
7480,7481
7484,7485
7486,7487
7487,7488
7487,7489
7488,7489
7490,7491
7490,7492
7491,7492
7494,7495
7494,7496
7495,7496
7495,7497
7496,7497
7496,7498
7497,7498
7499,7500
7499,7501
7500,7501
7503,7504
7503,7505
7504,7505
7504,7506
7505,7506
7507,7508
7507,7509
7508,7509
7512,7513
7512,7514
7512,7515
7512,7516
7512,7517
7512,7518
7513,7514
7514,7515
7514,7516
7516,7517
7516,7518
7518,7519
7520,7521
7521,7522
7521,7523
7521,7524
7522,7523
7524,7525
7524,7526
7525,7526
7527,7528
7527,7529
7528,7529
7528,7530
7529,7530
7531,7532
7531,7533
7532,7533
7536,7537
7536,7538
7537,7538
7537,7539
7538,7539
7540,7541
7540,7542
7541,7542
7545,7546
7546,7547
7546,7548
7546,7549
7546,7550
7547,7548
7551,7552
7551,7553
7551,7554
7551,7555
7552,7553
7554,7555
7556,7557
7557,7558
7558,7559
7560,7561
7560,7562
7561,7562
7563,7564
7563,7565
7564,7565
7564,7566
7565,7566
7567,7568
7567,7569
7568,7569
7572,7573
7572,7574
7573,7574
7573,7575
7574,7575
7574,7576
7575,7576
7577,7578
7577,7579
7578,7579
7578,7580
7579,7580
7581,7582
7581,7583
7582,7583
7587,7588
7588,7589
7588,7590
7588,7591
7589,7590
7591,7592
7591,7593
7592,7593
7592,7594
7593,7594
7595,7596
7595,7597
7596,7597
7600,7601
7600,7602
7601,7602
7603,7604
7603,7605
7604,7605
7604,7606
7605,7606
7607,7608
7607,7609
7608,7609
7612,7613
7612,7614
7613,7614
7613,7615
7614,7615
7614,7616
7615,7616
7617,7618
7617,7619
7618,7619
7618,7620
7619,7620
7621,7622
7621,7623
7622,7623
7627,7628
7628,7629
7628,7630
7628,7631
7629,7630
7631,7632
7631,7633
7632,7633
7632,7634
7633,7634
7635,7636
7635,7637
7636,7637
7640,7641
7640,7642
7641,7642
7643,7644
7643,7645
7644,7645
7644,7646
7645,7646
7647,7648
7647,7649
7648,7649
7652,7653
7653,7654
7653,7655
7654,7655
7656,7657
7656,7658
7657,7658
7657,7659
7658,7659
7660,7661
7660,7662
7661,7662
7665,7666
7665,7667
7666,7667
7666,7668
7667,7668
7669,7670
7669,7671
7670,7671
7673,7674
7673,7675
7673,7676
7673,7677
7673,7678
7674,7675
7675,7676
7675,7677
7676,7677
7678,7679
7679,7680
7679,7681
7682,7683
7683,7684
7683,7685
7683,7686
7683,7687
7684,7685
7686,7687
7687,7688
7687,7689
7688,7689
7688,7690
7689,7690
7691,7692
7691,7693
7692,7693
7696,7697
7698,7699
7700,7701
7701,7702
7701,7703
7702,7703
7703,7704
7704,7705
7704,7706
7705,7706
7705,7707
7706,7707
7709,7710
7711,7712
7712,7713
7712,7714
7712,7715
7713,7714
7715,7716
7717,7718
7717,7719
7718,7719
7721,7722
7722,7723
7722,7724
7723,7724
7725,7726
7726,7727
7729,7730
7730,7731
7732,7733
7733,7734
7733,7735
7733,7736
7733,7737
7733,7738
7733,7739
7733,7740
7733,7741
7734,7735
7736,7737
7736,7738
7737,7738
7739,7740
7739,7741
7740,7741
7743,7744
7745,7746
7747,7748
7747,7749
7748,7749
7751,7752
7754,7755
7757,7758
7758,7759
7760,7761
7760,7762
7760,7763
7761,7762
7762,7763
7762,7764
7763,7764
7765,7766
7767,7768
7768,7769
7768,7770
7768,7771
7769,7770
7771,7772
7771,7773
7772,7773
7774,7775
7774,7776
7775,7776
7778,7779
7779,7780
7781,7782
7782,7783
7782,7784
7782,7785
7782,7786
7782,7787
7782,7788
7782,7789
7782,7790
7783,7784
7785,7786
7785,7787
7786,7787
7788,7789
7788,7790
7789,7790
7792,7793
7794,7795
7796,7797
7796,7798
7797,7798
7800,7801
7800,7802
7801,7802
7804,7805
7804,7806
7805,7806
7808,7809
7811,7812
7812,7813
7814,7815
7815,7816
7815,7817
7816,7817
7816,7818
7817,7818
7817,7819
7818,7819
7820,7821
7820,7822
7821,7822
7825,7826
7825,7827
7826,7827
7826,7828
7826,7829
7826,7830
7827,7828
7829,7830
7829,7831
7830,7831
7832,7833
7832,7834
7833,7834
7837,7838
7838,7839
7840,7841
7840,7842
7841,7842
7844,7845
7845,7846
7845,7847
7845,7848
7846,7847
7848,7849
7850,7851
7851,7852
7853,7854
7854,7855
7854,7856
7855,7856
7857,7858
7857,7859
7858,7859
7861,7862
7861,7863
7862,7863
7862,7864
7863,7864
7863,7865
7864,7865
7866,7867
7866,7868
7867,7868
7871,7872
7871,7873
7871,7874
7871,7875
7871,7876
7871,7877
7871,7878
7871,7879
7871,7880
7871,7881
7871,7882
7872,7873
7873,7874
7873,7875
7874,7875
7876,7877
7876,7878
7877,7878
7877,7879
7878,7879
7880,7881
7880,7882
7881,7882
7885,7886
7885,7887
7885,7888
7886,7887
7886,7888
7887,7888
7888,7889
7888,7890
7889,7890
7889,7891
7890,7891
7894,7895
7895,7896
7895,7897
7896,7897
7896,7898
7897,7898
7900,7901
7900,7902
7901,7902
7904,7905
7905,7906
7905,7907
7906,7907
7906,7908
7907,7908
7907,7909
7908,7909
7908,7910
7909,7910
7911,7912
7911,7913
7912,7913
7916,7917
7916,7918
7917,7918
7920,7921
7920,7922
7920,7923
7921,7922
7922,7923
7922,7924
7922,7925
7922,7926
7922,7927
7923,7924
7925,7926
7928,7929
7928,7930
7929,7930
7932,7933
7932,7934
7933,7934
7933,7935
7934,7935
7936,7937
7936,7938
7937,7938
7941,7942
7942,7943
7942,7944
7942,7945
7942,7946
7942,7947
7942,7948
7943,7944
7945,7946
7949,7950
7949,7951
7950,7951
7953,7954
7953,7955
7954,7955
7954,7956
7955,7956
7957,7958
7957,7959
7958,7959
7962,7963
7963,7964
7963,7965
7963,7966
7963,7967
7963,7968
7964,7965
7966,7967
7968,7969
7971,7972
7971,7973
7972,7973
7975,7976
7975,7977
7976,7977
7976,7978
7977,7978
7978,7979
7978,7980
7979,7980
7979,7981
7980,7981
7984,7985
7985,7986
7985,7987
7986,7987
7986,7988
7987,7988
7990,7991
7990,7992
7991,7992
7994,7995
7995,7996
7995,7997
7996,7997
7996,7998
7997,7998
7997,7999
7998,7999
7998,8000
7999,8000
8001,8002
8001,8003
8002,8003
8006,8007
8006,8008
8007,8008
8010,8011
8010,8012
8010,8013
8011,8012
8012,8013
8012,8014
8012,8015
8012,8016
8012,8017
8013,8014
8015,8016
8018,8019
8018,8020
8019,8020
8022,8023
8022,8024
8023,8024
8023,8025
8024,8025
8026,8027
8026,8028
8027,8028
8031,8032
8032,8033
8032,8034
8032,8035
8032,8036
8032,8037
8032,8038
8033,8034
8035,8036
8039,8040
8039,8041
8040,8041
8043,8044
8043,8045
8044,8045
8044,8046
8045,8046
8047,8048
8047,8049
8048,8049
8052,8053
8053,8054
8053,8055
8053,8056
8053,8057
8053,8058
8054,8055
8056,8057
8058,8059
8061,8062
8061,8063
8062,8063
8065,8066
8066,8067
8066,8068
8067,8068
8067,8069
8068,8069
8071,8072
8071,8073
8072,8073
8072,8074
8073,8074
8075,8076
8075,8077
8076,8077
8080,8081
8080,8082
8080,8083
8081,8082
8081,8083
8082,8083
8082,8084
8083,8084
8086,8087
8087,8088
8087,8089
8088,8089
8088,8090
8089,8090
8092,8093
8094,8095
8095,8096
8095,8097
8096,8097
8096,8098
8097,8098
8100,8101
8100,8102
8101,8102
8102,8103
8102,8104
8103,8104
8103,8105
8104,8105
8104,8106
8105,8106
8107,8108
8107,8109
8108,8109
8112,8113
8112,8114
8113,8114
8117,8118
8117,8119
8117,8120
8118,8119
8118,8120
8119,8120
8119,8121
8120,8121
8123,8124
8123,8125
8124,8125
8124,8126
8125,8126
8129,8130
8130,8131
8130,8132
8131,8132
8131,8133
8132,8133
8135,8136
8135,8137
8136,8137
8137,8138
8137,8139
8139,8140
8139,8141
8140,8141
8144,8145
8145,8146
8145,8147
8146,8147
8146,8148
8147,8148
8150,8151
8150,8152
8151,8152
8151,8153
8152,8153
8154,8155
8154,8156
8155,8156
8159,8160
8159,8161
8160,8161
8160,8162
8161,8162
8161,8163
8162,8163
8165,8166
8167,8168
8168,8169
8168,8170
8169,8170
8170,8171
8170,8172
8170,8173
8171,8172
8173,8174
8175,8176
8175,8177
8176,8177
8179,8180
8179,8181
8180,8181
8181,8182
8181,8183
8182,8183
8184,8185
8186,8187
8187,8188
8187,8189
8188,8189
8188,8190
8189,8190
8192,8193
8194,8195
8194,8196
8194,8197
8195,8196
8195,8197
8196,8197
8197,8198
8197,8199
8198,8199
8198,8200
8199,8200
8203,8204
8204,8205
8204,8206
8205,8206
8205,8207
8206,8207
8209,8210
8209,8211
8210,8211
8213,8214
8214,8215
8214,8216
8215,8216
8215,8217
8216,8217
8219,8220
8219,8221
8219,8222
8219,8223
8219,8224
8220,8221
8222,8223
8224,8225
8224,8226
8225,8226
8228,8229
8230,8231
8230,8232
8231,8232
8233,8234
8235,8236
8236,8237
8236,8238
8237,8238
8237,8239
8238,8239
8241,8242
8241,8243
8241,8244
8241,8245
8241,8246
8242,8243
8244,8245
8246,8247
8246,8248
8247,8248
8250,8251
8252,8253
8252,8254
8253,8254
8255,8256
8257,8258
8257,8259
8258,8259
8258,8260
8259,8260
8259,8261
8260,8261
8263,8264
8265,8266
8266,8267
8266,8268
8267,8268
8269,8270
8271,8272
8272,8273
8272,8274
8272,8275
8272,8276
8272,8277
8272,8278
8272,8279
8272,8280
8273,8274
8275,8276
8275,8277
8276,8277
8278,8279
8278,8280
8279,8280
8282,8283
8284,8285
8286,8287
8286,8288
8287,8288
8290,8291
8293,8294
8293,8295
8294,8295
8297,8298
8298,8299
8298,8300
8299,8300
8301,8302
8301,8303
8302,8303
8305,8306
8306,8307
8306,8308
8307,8308
8307,8309
8308,8309
8312,8313
8313,8314
8313,8315
8313,8316
8313,8317
8313,8318
8313,8319
8313,8320
8314,8315
8318,8319
8318,8320
8319,8320
8322,8323
8322,8324
8323,8324
8326,8327
8326,8328
8327,8328
8330,8331
8330,8332
8331,8332
8335,8336
8336,8337
8338,8339
8339,8340
8341,8342
8342,8343
8342,8344
8343,8344
8343,8345
8344,8345
8348,8349
8349,8350
8349,8351
8350,8351
8350,8352
8351,8352
8355,8356
8356,8357
8356,8358
8357,8358
8357,8359
8358,8359
8362,8363
8363,8364
8363,8365
8364,8365
8364,8366
8365,8366
8369,8370
8370,8371
8370,8372
8370,8373
8371,8372
8373,8374
8375,8376
8376,8377
8378,8379
8378,8380
8378,8381
8379,8380
8379,8381
8380,8381
8380,8382
8381,8382
8381,8383
8382,8383
8386,8387
8388,8389
8388,8390
8389,8390
8390,8391
8390,8392
8391,8392
8391,8393
8392,8393
8392,8394
8393,8394
8393,8395
8394,8395
8399,8400
8401,8402
8402,8403
8402,8404
8402,8405
8402,8406
8402,8407
8402,8408
8402,8409
8402,8410
8403,8404
8405,8406
8405,8407
8406,8407
8408,8409
8408,8410
8409,8410
8412,8413
8413,8414
8413,8415
8414,8415
8417,8418
8417,8419
8418,8419
8421,8422
8426,8427
8426,8428
8426,8429
8426,8430
8427,8428
8428,8429
8428,8430
8430,8431
8432,8433
8433,8434
8433,8435
8434,8435
8436,8437
8436,8438
8436,8439
8436,8440
8437,8438
8439,8440
8439,8441
8440,8441
8442,8443
8442,8444
8443,8444
8447,8448
8448,8449
8448,8450
8449,8450
8452,8453
8453,8454
8453,8455
8454,8455
8454,8456
8455,8456
8455,8457
8456,8457
8458,8459
8458,8460
8459,8460
8463,8464
8463,8465
8464,8465
8466,8467
8466,8468
8467,8468
8470,8471
8470,8472
8471,8472
8473,8474
8474,8475
8474,8476
8474,8477
8474,8478
8474,8479
8475,8476
8479,8480
8479,8481
8480,8481
8482,8483
8482,8484
8483,8484
8483,8485
8484,8485
8484,8486
8485,8486
8487,8488
8487,8489
8488,8489
8493,8494
8493,8495
8494,8495
8494,8496
8495,8496
8497,8498
8497,8499
8498,8499
8503,8504
8504,8505
8506,8507
8506,8508
8507,8508
8507,8509
8507,8510
8508,8509
8510,8511
8511,8512
8511,8513
8512,8513
8512,8514
8513,8514
8515,8516
8515,8517
8516,8517
8520,8521
8520,8522
8521,8522
8523,8524
8525,8526
8525,8527
8526,8527
8527,8528
8527,8529
8527,8530
8527,8531
8528,8529
8530,8531
8533,8534
8533,8535
8533,8536
8534,8535
8534,8536
8535,8536
8535,8537
8536,8537
8538,8539
8538,8540
8539,8540
8543,8544
8543,8545
8544,8545
8546,8547
8546,8548
8547,8548
8547,8549
8548,8549
8550,8551
8550,8552
8551,8552
8557,8558
8557,8559
8558,8559
8558,8560
8558,8561
8558,8562
8558,8563
8558,8564
8559,8560
8561,8562
8561,8563
8562,8563
8564,8565
8564,8566
8565,8566
8568,8569
8569,8570
8569,8571
8570,8571
8570,8572
8571,8572
8573,8574
8573,8575
8574,8575
8578,8579
8579,8580
8581,8582
8581,8583
8582,8583
8582,8584
8583,8584
8585,8586
8585,8587
8586,8587
8590,8591
8590,8592
8591,8592
8591,8593
8592,8593
8594,8595
8594,8596
8595,8596
8599,8600
8600,8601
8602,8603
8603,8604
8603,8605
8603,8606
8603,8607
8603,8608
8604,8605
8606,8607
8609,8610
8609,8611
8609,8612
8610,8611
8610,8612
8611,8612
8614,8615
8614,8616
8615,8616
8619,8620
8619,8621
8620,8621
8622,8623
8622,8624
8623,8624
8623,8625
8624,8625
8624,8626
8625,8626
8627,8628
8627,8629
8628,8629
8633,8634
8634,8635
8634,8636
8634,8637
8635,8636
8637,8638
8637,8639
8638,8639
8641,8642
8642,8643
8645,8646
8646,8647
8648,8649
8648,8650
8649,8650
8651,8652
8652,8653
8652,8654
8652,8655
8652,8656
8652,8657
8652,8658
8652,8659
8652,8660
8653,8654
8655,8656
8655,8657
8656,8657
8658,8659
8658,8660
8659,8660
8662,8663
8664,8665
8666,8667
8666,8668
8667,8668
8670,8671
8673,8674
8673,8675
8674,8675
8677,8678
8677,8679
8678,8679
8678,8680
8678,8681
8679,8680
8681,8682
8682,8683
8682,8684
8683,8684
8683,8685
8684,8685
8686,8687
8686,8688
8687,8688
8691,8692
8691,8693
8692,8693
8694,8695
8696,8697
8696,8698
8697,8698
8698,8699
8698,8700
8698,8701
8698,8702
8699,8700
8701,8702
8704,8705
8704,8706
8704,8707
8705,8706
8705,8707
8706,8707
8706,8708
8707,8708
8709,8710
8709,8711
8710,8711
8714,8715
8714,8716
8715,8716
8717,8718
8717,8719
8718,8719
8718,8720
8719,8720
8721,8722
8721,8723
8722,8723
8728,8729
8728,8730
8729,8730
8729,8731
8729,8732
8730,8731
8732,8733
8732,8734
8733,8734
8735,8736
8735,8737
8736,8737
8739,8740
8740,8741
8742,8743
8742,8744
8742,8745
8742,8746
8743,8744
8743,8745
8744,8745
8746,8747
8747,8748
8747,8749
8747,8750
8747,8751
8747,8752
8748,8749
8750,8751
8753,8754
8753,8755
8754,8755
8756,8757
8756,8758
8757,8758
8757,8759
8758,8759
8758,8760
8759,8760
8761,8762
8761,8763
8762,8763
8767,8768
8767,8769
8768,8769
8768,8770
8769,8770
8771,8772
8771,8773
8772,8773
8776,8777
8777,8778
8777,8779
8777,8780
8777,8781
8778,8779
8780,8781
8781,8782
8784,8785
8785,8786
8786,8787
8788,8789
8789,8790
8789,8791
8789,8792
8790,8791
8792,8793
8792,8794
8793,8794
8796,8797
8799,8800
8799,8801
8799,8802
8800,8801
8800,8802
8800,8803
8801,8802
8803,8804
8803,8805
8804,8805
8804,8806
8805,8806
8807,8808
8807,8809
8808,8809
8813,8814
8814,8815
8815,8816
8815,8817
8816,8817
8818,8819
8818,8820
8818,8821
8818,8822
8818,8823
8818,8824
8819,8820
8821,8822
8823,8824
8823,8825
8824,8825
8824,8826
8825,8826
8827,8828
8827,8829
8828,8829
8832,8833
8832,8834
8833,8834
8833,8835
8834,8835
8836,8837
8836,8838
8837,8838
8842,8843
8842,8844
8843,8844
8843,8845
8844,8845
8846,8847
8846,8848
8847,8848
8851,8852
8852,8853
8852,8854
8853,8854
8856,8857
8856,8858
8856,8859
8857,8858
8857,8859
8858,8859
8858,8860
8858,8861
8859,8860
8861,8862
8861,8863
8862,8863
8862,8864
8863,8864
8865,8866
8865,8867
8866,8867
8871,8872
8872,8873
8874,8875
8874,8876
8874,8877
8874,8878
8874,8879
8874,8880
8875,8876
8875,8877
8876,8877
8878,8879
8879,8880
8879,8881
8879,8882
8879,8883
8879,8884
8879,8885
8880,8881
8882,8883
8885,8886
8885,8887
8886,8887
8888,8889
8888,8890
8889,8890
8892,8893
8892,8894
8893,8894
8893,8895
8894,8895
8896,8897
8896,8898
8897,8898
8901,8902
8901,8903
8902,8903
8902,8904
8903,8904
8905,8906
8905,8907
8906,8907
8910,8911
8911,8912
8911,8913
8911,8914
8911,8915
8912,8913
8914,8915
8915,8916
8918,8919
8919,8920
8920,8921
8922,8923
8923,8924
8923,8925
8923,8926
8923,8927
8924,8925
8926,8927
8927,8928
8929,8930
8932,8933
8933,8934
8933,8935
8933,8936
8933,8937
8934,8935
8936,8937
8937,8938
8939,8940
8941,8942
8943,8944
8944,8945
8944,8946
8944,8947
8944,8948
8944,8949
8944,8950
8944,8951
8944,8952
8945,8946
8947,8948
8947,8949
8948,8949
8950,8951
8950,8952
8951,8952
8954,8955
8956,8957
8959,8960
8959,8961
8960,8961
8963,8964
8963,8965
8964,8965
8967,8968
8969,8970
8969,8971
8970,8971
8971,8972
8971,8973
8972,8973
8974,8975
8974,8976
8975,8976
8978,8979
8980,8981
8980,8982
8980,8983
8981,8982
8981,8983
8981,8984
8982,8983
8982,8984
8982,8985
8983,8984
8985,8986
8985,8987
8986,8987
8988,8989
8988,8990
8989,8990
8992,8993
8994,8995
8994,8996
8994,8997
8994,8998
8994,8999
8995,8996
8995,8997
8995,8998
8996,8997
8996,8998
8996,8999
8997,8998
8999,9000
8999,9001
9000,9001
9002,9003
9002,9004
9003,9004
9006,9007
9008,9009
9009,9010
9010,9011
9010,9012
9011,9012
9014,9015
9015,9016
9016,9017
9016,9018
9017,9018
9020,9021
9021,9022
9021,9023
9022,9023
9024,9025
9024,9026
9025,9026
9025,9027
9026,9027
9026,9028
9027,9028
9029,9030
9029,9031
9030,9031
9034,9035
9034,9036
9035,9036
9035,9037
9036,9037
9038,9039
9038,9040
9039,9040
9043,9044
9044,9045
9044,9046
9044,9047
9044,9048
9045,9046
9047,9048
9048,9049
9051,9052
9052,9053
9053,9054
9055,9056
9056,9057
9056,9058
9056,9059
9057,9058
9059,9060
9062,9063
9063,9064
9063,9065
9063,9066
9064,9065
9066,9067
9069,9070
9069,9071
9069,9072
9069,9073
9069,9074
9069,9075
9069,9076
9070,9071
9071,9072
9071,9073
9072,9073
9074,9075
9076,9077
9077,9078
9077,9079
9078,9079
9081,9082
9081,9083
9082,9083
9082,9084
9083,9084
9086,9087
9087,9088
9087,9089
9087,9090
9087,9091
9087,9092
9088,9089
9090,9091
9091,9092
9091,9093
9092,9093
9092,9094
9093,9094
9095,9096
9095,9097
9096,9097
9100,9101
9100,9102
9101,9102
9106,9107
9106,9108
9106,9109
9107,9108
9107,9109
9107,9110
9107,9111
9108,9109
9110,9111
9111,9112
9111,9113
9112,9113
9112,9114
9113,9114
9115,9116
9115,9117
9116,9117
9121,9122
9122,9123
9124,9125
9125,9126
9125,9127
9125,9128
9126,9127
9126,9128
9126,9129
9127,9128
9129,9130
9129,9131
9130,9131
9132,9133
9132,9134
9133,9134
9136,9137
9138,9139
9138,9140
9139,9140
9140,9141
9140,9142
9141,9142
9143,9144
9143,9145
9144,9145
9144,9146
9145,9146
9147,9148
9147,9149
9148,9149
9152,9153
9153,9154
9153,9155
9154,9155
9157,9158
9158,9159
9159,9160
9159,9161
9160,9161
9162,9163
9162,9164
9163,9164
9163,9165
9164,9165
9166,9167
9166,9168
9167,9168
9171,9172
9172,9173
9172,9174
9173,9174
9175,9176
9175,9177
9176,9177
9176,9178
9177,9178
9179,9180
9179,9181
9180,9181
9184,9185
9185,9186
9185,9187
9186,9187
9188,9189
9188,9190
9188,9191
9188,9192
9189,9190
9191,9192
9192,9193
9194,9195
9194,9196
9195,9196
9195,9197
9196,9197
9196,9198
9197,9198
9199,9200
9199,9201
9200,9201
9204,9205
9204,9206
9205,9206
9205,9207
9206,9207
9208,9209
9208,9210
9209,9210
9214,9215
9215,9216
9215,9217
9215,9218
9215,9219
9216,9217
9218,9219
9219,9220
9219,9221
9220,9221
9220,9222
9221,9222
9223,9224
9223,9225
9224,9225
9228,9229
9230,9231
9230,9232
9231,9232
9232,9233
9233,9234
9236,9237
9237,9238
9237,9239
9237,9240
9237,9241
9238,9239
9240,9241
9241,9242
9241,9243
9242,9243
9242,9244
9243,9244
9245,9246
9245,9247
9246,9247
9250,9251
9252,9253
9252,9254
9253,9254
9254,9255
9255,9256
9258,9259
9258,9260
9259,9260
9260,9261
9262,9263
9262,9264
9262,9265
9263,9264
9264,9265
9264,9266
9264,9267
9264,9268
9266,9267
9266,9268
9268,9269
9270,9271
9270,9272
9272,9273
9274,9275
9274,9276
9276,9277
9278,9279
9278,9280
9279,9280
9280,9281
9280,9282
9280,9283
9281,9282
9283,9284
9283,9285
9284,9285
9286,9287
9286,9288
9287,9288
9290,9291
9292,9293
9292,9294
9293,9294
9294,9295
9294,9296
9294,9297
9294,9298
9294,9299
9295,9296
9299,9300
9299,9301
9300,9301
9302,9303
9302,9304
9303,9304
9303,9305
9304,9305
9306,9307
9306,9308
9307,9308
9311,9312
9311,9313
9311,9314
9311,9315
9312,9313
9314,9315
9316,9317
9317,9318
9318,9319
9320,9321
9320,9322
9321,9322
9321,9323
9322,9323
9324,9325
9324,9326
9325,9326
9329,9330
9330,9331
9330,9332
9331,9332
9333,9334
9333,9335
9334,9335
9334,9336
9335,9336
9335,9337
9336,9337
9338,9339
9338,9340
9339,9340
9343,9344
9343,9345
9344,9345
9344,9346
9345,9346
9347,9348
9347,9349
9348,9349
9352,9353
9352,9354
9352,9355
9353,9354
9354,9355
9356,9357
9356,9358
9356,9359
9356,9360
9356,9361
9356,9362
9357,9358
9357,9359
9358,9359
9360,9361
9361,9362
9361,9363
9361,9364
9362,9363
9362,9364
9362,9365
9363,9364
9365,9366
9365,9367
9366,9367
9368,9369
9368,9370
9369,9370
9372,9373
9374,9375
9375,9376
9376,9377
9376,9378
9376,9379
9376,9380
9376,9381
9376,9382
9377,9378
9379,9380
9382,9383
9382,9384
9383,9384
9385,9386
9385,9387
9386,9387
9389,9390
9389,9391
9389,9392
9389,9393
9390,9391
9392,9393
9394,9395
9395,9396
9396,9397
9398,9399
9398,9400
9399,9400
9399,9401
9400,9401
9402,9403
9402,9404
9403,9404
9407,9408
9407,9409
9407,9410
9407,9411
9408,9409
9410,9411
9412,9413
9413,9414
9414,9415
9416,9417
9416,9418
9417,9418
9417,9419
9418,9419
9420,9421
9420,9422
9421,9422
9425,9426
9426,9427
9427,9428
9427,9429
9427,9430
9427,9431
9427,9432
9427,9433
9427,9434
9428,9429
9430,9431
9433,9434
9433,9435
9434,9435
9436,9437
9436,9438
9437,9438
9440,9441
9440,9442
9440,9443
9440,9444
9441,9442
9443,9444
9445,9446
9446,9447
9447,9448
9449,9450
9449,9451
9450,9451
9450,9452
9451,9452
9453,9454
9453,9455
9454,9455
9458,9459
9458,9460
9458,9461
9458,9462
9459,9460
9461,9462
9463,9464
9464,9465
9465,9466
9467,9468
9467,9469
9468,9469
9468,9470
9469,9470
9471,9472
9471,9473
9472,9473
9476,9477
9476,9478
9476,9479
9476,9480
9477,9478
9479,9480
9481,9482
9482,9483
9483,9484
9485,9486
9485,9487
9486,9487
9486,9488
9487,9488
9489,9490
9489,9491
9490,9491
9494,9495
9495,9496
9495,9497
9495,9498
9495,9499
9496,9497
9498,9499
9499,9500
9502,9503
9503,9504
9504,9505
9506,9507
9507,9508
9507,9509
9507,9510
9507,9511
9508,9509
9510,9511
9511,9512
9513,9514
9516,9517
9517,9518
9517,9519
9517,9520
9517,9521
9518,9519
9520,9521
9521,9522
9523,9524
9525,9526
9527,9528
9528,9529
9528,9530
9528,9531
9528,9532
9528,9533
9528,9534
9528,9535
9528,9536
9529,9530
9531,9532
9531,9533
9532,9533
9534,9535
9534,9536
9535,9536
9538,9539
9540,9541
9543,9544
9543,9545
9544,9545
9547,9548
9547,9549
9548,9549
9551,9552
9553,9554
9553,9555
9554,9555
9555,9556
9555,9557
9556,9557
9558,9559
9558,9560
9559,9560
9562,9563
9564,9565
9564,9566
9565,9566
9565,9567
9565,9568
9566,9567
9566,9568
9566,9569
9567,9568
9569,9570
9569,9571
9570,9571
9572,9573
9572,9574
9573,9574
9576,9577
9578,9579
9579,9580
9579,9581
9580,9581
9581,9582
9582,9583
9582,9584
9583,9584
9583,9585
9584,9585
9584,9586
9585,9586
9587,9588
9587,9589
9588,9589
9592,9593
9592,9594
9593,9594
9593,9595
9594,9595
9596,9597
9596,9598
9597,9598
9601,9602
9602,9603
9602,9604
9603,9604
9606,9607
9607,9608
9607,9609
9607,9610
9608,9609
9608,9610
9608,9611
9609,9610
9611,9612
9611,9613
9612,9613
9614,9615
9614,9616
9615,9616
9618,9619
9620,9621
9620,9622
9620,9623
9620,9624
9620,9625
9621,9622
9622,9623
9622,9624
9623,9624
9625,9626
9625,9627
9625,9628
9626,9627
9626,9628
9626,9629
9627,9628
9629,9630
9629,9631
9630,9631
9632,9633
9632,9634
9633,9634
9636,9637
9640,9641
9641,9642
9641,9643
9641,9644
9641,9645
9642,9643
9644,9645
9645,9646
9648,9649
9649,9650
9650,9651
9652,9653
9653,9654
9653,9655
9654,9655
9656,9657
9656,9658
9656,9659
9657,9658
9657,9659
9657,9660
9658,9659
9660,9661
9660,9662
9661,9662
9663,9664
9663,9665
9664,9665
9667,9668
9669,9670
9669,9671
9670,9671
9670,9672
9671,9672
9673,9674
9673,9675
9674,9675
9678,9679
9678,9680
9679,9680
9681,9682
9681,9683
9682,9683
9682,9684
9683,9684
9683,9685
9684,9685
9686,9687
9686,9688
9687,9688
9691,9692
9691,9693
9692,9693
9692,9694
9693,9694
9695,9696
9695,9697
9696,9697
9700,9701
9701,9702
9701,9703
9701,9704
9702,9703
9704,9705
9707,9708
9708,9709
9708,9710
9708,9711
9709,9710
9711,9712
9714,9715
9714,9716
9714,9717
9715,9716
9716,9717
9716,9718
9717,9718
9719,9720
9721,9722
9722,9723
9722,9724
9723,9724
9726,9727
9726,9728
9726,9729
9727,9728
9727,9729
9727,9730
9727,9731
9728,9729
9730,9731
9731,9732
9731,9733
9732,9733
9732,9734
9733,9734
9735,9736
9735,9737
9736,9737
9741,9742
9742,9743
9744,9745
9744,9746
9745,9746
9745,9747
9745,9748
9746,9747
9746,9748
9746,9749
9747,9748
9749,9750
9749,9751
9750,9751
9752,9753
9752,9754
9753,9754
9756,9757
9758,9759
9759,9760
9760,9761
9760,9762
9761,9762
9763,9764
9763,9765
9764,9765
9764,9766
9765,9766
9767,9768
9767,9769
9768,9769
9772,9773
9772,9774
9773,9774
9774,9775
9774,9776
9775,9776
9777,9778
9777,9779
9778,9779
9778,9780
9779,9780
9781,9782
9781,9783
9782,9783
9786,9787
9787,9788
9787,9789
9788,9789
9791,9792
9792,9793
9792,9794
9793,9794
9795,9796
9795,9797
9795,9798
9795,9799
9796,9797
9798,9799
9799,9800
9801,9802
9801,9803
9802,9803
9802,9804
9803,9804
9803,9805
9804,9805
9806,9807
9806,9808
9807,9808
9811,9812
9811,9813
9812,9813
9812,9814
9813,9814
9815,9816
9815,9817
9816,9817
9821,9822
9822,9823
9822,9824
9823,9824
9825,9826
9825,9827
9826,9827
9828,9829
9828,9830
9829,9830
9829,9831
9830,9831
9830,9832
9831,9832
9833,9834
9833,9835
9834,9835
9838,9839
9838,9840
9839,9840
9839,9841
9840,9841
9842,9843
9842,9844
9843,9844
9847,9848
9847,9849
9848,9849
9849,9850
9851,9852
9851,9853
9851,9854
9851,9855
9851,9856
9851,9857
9851,9858
9851,9859
9852,9853
9853,9854
9853,9855
9853,9856
9853,9857
9855,9856
9855,9857
9857,9858
9859,9860
9859,9861
9861,9862
9863,9864
9863,9865
9865,9866
9867,9868
9868,9869
9868,9870
9868,9871
9868,9872
9869,9870
9871,9872
9874,9875
9874,9876
9874,9877
9874,9878
9875,9876
9877,9878
9879,9880
9880,9881
9881,9882
9883,9884
9883,9885
9884,9885
9884,9886
9885,9886
9885,9887
9886,9887
9888,9889
9888,9890
9889,9890
9893,9894
9893,9895
9894,9895
9894,9896
9895,9896
9897,9898
9897,9899
9898,9899
9902,9903
9902,9904
9903,9904
9905,9906
9906,9907
9906,9908
9906,9909
9907,9908
9907,9909
9907,9910
9908,9909
9910,9911
9910,9912
9911,9912
9913,9914
9913,9915
9914,9915
9917,9918
9919,9920
9920,9921
9921,9922
9921,9923
9921,9924
9921,9925
9921,9926
9921,9927
9922,9923
9924,9925
9927,9928
9927,9929
9928,9929
9930,9931
9930,9932
9931,9932
9934,9935
9934,9936
9934,9937
9934,9938
9935,9936
9937,9938
9939,9940
9940,9941
9941,9942
9943,9944
9943,9945
9944,9945
9944,9946
9945,9946
9947,9948
9947,9949
9948,9949
9952,9953
9952,9954
9952,9955
9952,9956
9953,9954
9955,9956
9957,9958
9958,9959
9959,9960
9961,9962
9961,9963
9962,9963
9962,9964
9963,9964
9965,9966
9965,9967
9966,9967
9970,9971
9971,9972
9972,9973
9972,9974
9972,9975
9972,9976
9972,9977
9972,9978
9972,9979
9973,9974
9975,9976
9978,9979
9978,9980
9979,9980
9981,9982
9981,9983
9982,9983
9985,9986
9985,9987
9985,9988
9985,9989
9986,9987
9988,9989
9990,9991
9991,9992
9992,9993
9994,9995
9994,9996
9995,9996
9995,9997
9996,9997
9998,9999
9998,10000
9999,10000
10003,10004
10003,10005
10003,10006
10003,10007
10004,10005
10006,10007
10008,10009
10009,10010
10010,10011
10012,10013
10012,10014
10013,10014
10013,10015
10014,10015
10016,10017
10016,10018
10017,10018
10021,10022
10021,10023
10021,10024
10021,10025
10022,10023
10024,10025
10026,10027
10027,10028
10028,10029
10030,10031
10030,10032
10031,10032
10031,10033
10032,10033
10034,10035
10034,10036
10035,10036
10039,10040
10040,10041
10040,10042
10040,10043
10040,10044
10041,10042
10043,10044
10044,10045
10047,10048
10048,10049
10049,10050
10051,10052
10052,10053
10052,10054
10052,10055
10052,10056
10053,10054
10055,10056
10056,10057
10058,10059
10061,10062
10062,10063
10062,10064
10062,10065
10062,10066
10063,10064
10065,10066
10066,10067
10068,10069
10070,10071
10072,10073
10073,10074
10073,10075
10073,10076
10073,10077
10073,10078
10073,10079
10073,10080
10073,10081
10074,10075
10076,10077
10076,10078
10077,10078
10079,10080
10079,10081
10080,10081
10083,10084
10085,10086
10088,10089
10088,10090
10089,10090
10092,10093
10092,10094
10093,10094
10096,10097
10098,10099
10098,10100
10099,10100
10100,10101
10100,10102
10101,10102
10103,10104
10103,10105
10104,10105
10107,10108
10109,10110
10109,10111
10110,10111
10112,10113
10112,10114
10112,10115
10112,10116
10112,10117
10113,10114
10114,10115
10114,10116
10114,10117
10114,10118
10115,10116
10117,10118
10118,10119
10121,10122
10122,10123
10123,10124
10125,10126
10126,10127
10126,10128
10126,10129
10126,10130
10127,10128
10129,10130
10130,10131
10132,10133
10134,10135
10136,10137
10137,10138
10137,10139
10137,10140
10137,10141
10137,10142
10138,10139
10140,10141
10141,10142
10143,10144
10146,10147
10148,10149
10149,10150
10149,10151
10149,10152
10149,10153
10149,10154
10149,10155
10149,10156
10149,10157
10150,10151
10152,10153
10152,10154
10153,10154
10155,10156
10155,10157
10156,10157
10159,10160
10161,10162
10164,10165
10164,10166
10165,10166
10168,10169
10168,10170
10169,10170
10172,10173
10174,10175
10174,10176
10174,10177
10175,10176
10175,10177
10175,10178
10176,10177
10178,10179
10178,10180
10179,10180
10179,10181
10180,10181
10182,10183
10182,10184
10183,10184
10188,10189
10188,10190
10188,10191
10188,10192
10189,10190
10190,10191
10190,10192
10190,10193
10191,10192
10193,10194
10194,10195
10194,10196
10195,10196
10195,10197
10196,10197
10198,10199
10198,10200
10199,10200
10203,10204
10205,10206
10206,10207
10206,10208
10206,10209
10206,10210
10206,10211
10206,10212
10206,10213
10206,10214
10206,10215
10206,10216
10206,10217
10206,10218
10206,10219
10206,10220
10207,10208
10211,10212
10211,10213
10212,10213
10214,10215
10214,10216
10215,10216
10218,10219
10220,10221
10220,10222
10221,10222
10223,10224
10223,10225
10224,10225
10224,10226
10225,10226
10227,10228
10227,10229
10228,10229
10232,10233
10234,10235
10236,10237
10238,10239
10238,10240
10239,10240
10241,10242
10243,10244
10245,10246
10247,10248
10249,10250
10251,10252
10252,10253
10252,10254
10252,10255
10253,10254
10255,10256
10256,10257
10256,10258
10257,10258
10257,10259
10258,10259
10260,10261
10260,10262
10261,10262
10265,10266
10267,10268
10267,10269
10267,10270
10268,10269
10269,10270
10270,10271
10270,10272
10271,10272
10273,10274
10273,10275
10273,10276
10273,10277
10273,10278
10273,10279
10274,10275
10276,10277
10276,10278
10277,10278
10280,10281
10282,10283
10284,10285
10287,10288
10288,10289
10288,10290
10289,10290
10291,10292
10291,10293
10292,10293
10295,10296
10295,10297
10296,10297
10296,10298
10297,10298
10300,10301
10300,10302
10300,10303
10300,10304
10300,10305
10300,10306
10301,10302
10302,10303
10302,10304
10303,10304
10305,10306
10305,10307
10308,10309
10309,10310
10309,10311
10309,10312
10310,10311
10312,10313
10312,10314
10315,10316
10315,10317
10315,10318
10318,10319
10319,10320
10321,10322
10322,10323
10323,10324
10323,10325
10324,10325
10326,10327
10326,10328
10326,10329
10327,10328
10330,10331
10331,10332
10332,10333
10333,10334
10335,10336
10336,10337
10336,10338
10337,10338
10339,10340
10339,10341
10339,10342
10340,10341
10342,10343
10343,10344
10345,10346
10347,10348
10347,10349
10347,10350
10348,10349
10348,10350
10349,10350
10351,10352
10353,10354
10353,10355
10353,10356
10353,10357
10353,10358
10353,10359
10353,10360
10353,10361
10354,10355
10355,10356
10355,10357
10356,10357
10356,10358
10357,10358
10360,10361
10362,10363
10363,10364
10363,10365
10364,10365
10364,10366
10365,10366
10368,10369
10370,10371
10371,10372
10371,10373
10372,10373
10374,10375
10375,10376
10377,10378
10378,10379
10378,10380
10378,10381
10379,10380
10383,10384
10383,10385
10383,10386
10383,10387
10384,10385
10385,10386
10385,10387
10386,10387
10388,10389
10388,10390
10389,10390
10392,10393
10394,10395
10394,10396
10395,10396
10397,10398
10397,10399
10398,10399
10401,10402
10401,10403
10401,10404
10401,10405
10402,10403
10403,10404
10403,10405
10404,10405
10406,10407
10406,10408
10406,10409
10409,10410
10410,10411
10410,10412
10410,10413
10411,10412
10413,10414
10413,10415
10414,10415
10417,10418
10417,10419
10418,10419
10421,10422
10421,10423
10422,10423
10424,10425
10425,10426
10425,10427
10426,10427
10428,10429
10430,10431
10431,10432
10431,10433
10432,10433
10434,10435
10436,10437
10436,10438
10436,10439
10437,10438
10438,10439
10440,10441
10441,10442
10442,10443
10442,10444
10442,10445
10443,10444
10445,10446
10448,10449
10449,10450
10450,10451
10450,10452
10450,10453
10450,10454
10451,10452
10453,10454
10455,10456
10457,10458
10459,10460
10459,10461
10460,10461
10462,10463
10463,10464
10463,10465
10464,10465
10466,10467
10468,10469
10469,10470
10469,10471
10470,10471
10470,10472
10471,10472
10474,10475
10476,10477
10477,10478
10477,10479
10477,10480
10478,10479
10480,10481
10482,10483
10484,10485
10484,10486
10484,10487
10485,10486
10486,10487
10486,10488
10486,10489
10487,10488
10489,10490
10492,10493
10492,10494
10493,10494
10495,10496
10496,10497
10496,10498
10497,10498
10499,10500
10501,10502
10501,10503
10502,10503
10504,10505
10505,10506
10505,10507
10506,10507
10508,10509
10509,10510
10511,10512
10511,10513
10511,10514
10512,10513
10513,10514
10513,10515
10513,10516
10514,10515
10516,10517
10517,10518
10517,10519
10518,10519
10518,10520
10519,10520
10521,10522
10521,10523
10522,10523
10526,10527
10528,10529
10529,10530
10529,10531
10529,10532
10529,10533
10530,10531
10534,10535
10534,10536
10535,10536
10537,10538
10537,10539
10538,10539
10541,10542
10541,10543
10542,10543
10542,10544
10542,10545
10543,10544
10545,10546
10545,10547
10546,10547
10548,10549
10548,10550
10549,10550
10552,10553
10554,10555
10555,10556
10558,10559
10559,10560
10561,10562
10561,10563
10563,10564
10563,10565
10564,10565
10564,10566
10564,10567
10565,10566
10567,10568
10568,10569
10568,10570
10569,10570
10569,10571
10570,10571
10572,10573
10572,10574
10573,10574
10577,10578
10579,10580
10579,10581
10579,10582
10580,10581
10581,10582
10581,10583
10581,10584
10582,10583
10584,10585
10585,10586
10585,10587
10586,10587
10586,10588
10587,10588
10589,10590
10589,10591
10590,10591
10594,10595
10596,10597
10597,10598
10597,10599
10597,10600
10597,10601
10598,10599
10600,10601
10600,10602
10601,10602
10603,10604
10603,10605
10604,10605
10607,10608
10609,10610
10609,10611
10609,10612
10610,10611
10610,10612
10611,10612
10614,10615
10614,10616
10615,10616
10619,10620
10619,10621
10619,10622
10620,10621
10621,10622
10621,10623
10621,10624
10621,10625
10621,10626
10621,10627
10622,10623
10624,10625
10626,10627
10626,10628
10627,10628
10627,10629
10628,10629
10630,10631
10630,10632
10631,10632
10635,10636
10635,10637
10636,10637
10636,10638
10637,10638
10639,10640
10639,10641
10640,10641
10645,10646
10645,10647
10646,10647
10646,10648
10647,10648
10649,10650
10649,10651
10650,10651
10654,10655
10654,10656
10654,10657
10654,10658
10654,10659
10654,10660
10655,10656
10655,10657
10656,10657
10658,10659
10659,10660
10659,10661
10659,10662
10659,10663
10659,10664
10659,10665
10660,10661
10662,10663
10665,10666
10665,10667
10666,10667
10668,10669
10668,10670
10669,10670
10672,10673
10672,10674
10673,10674
10673,10675
10674,10675
10676,10677
10676,10678
10677,10678
10681,10682
10681,10683
10682,10683
10682,10684
10683,10684
10685,10686
10685,10687
10686,10687
10690,10691
10691,10692
10691,10693
10691,10694
10691,10695
10692,10693
10694,10695
10695,10696
10698,10699
10699,10700
10700,10701
10702,10703
10703,10704
10703,10705
10703,10706
10703,10707
10704,10705
10706,10707
10707,10708
10709,10710
10712,10713
10713,10714
10713,10715
10713,10716
10713,10717
10714,10715
10716,10717
10717,10718
10719,10720
10721,10722
10723,10724
10724,10725
10724,10726
10724,10727
10724,10728
10724,10729
10724,10730
10724,10731
10724,10732
10725,10726
10727,10728
10727,10729
10728,10729
10730,10731
10730,10732
10731,10732
10734,10735
10736,10737
10739,10740
10739,10741
10740,10741
10743,10744
10743,10745
10744,10745
10747,10748
10749,10750
10749,10751
10750,10751
10751,10752
10751,10753
10752,10753
10754,10755
10754,10756
10755,10756
10758,10759
10760,10761
10760,10762
10760,10763
10760,10764
10760,10765
10760,10766
10761,10762
10762,10763
10762,10764
10764,10765
10764,10766
10766,10767
10768,10769
10769,10770
10769,10771
10769,10772
10770,10771
10772,10773
10773,10774
10773,10775
10774,10775
10774,10776
10775,10776
10777,10778
10777,10779
10778,10779
10782,10783
10784,10785
10785,10786
10785,10787
10785,10788
10785,10789
10785,10790
10786,10787
10790,10791
10790,10792
10791,10792
10793,10794
10793,10795
10794,10795
10797,10798
10797,10799
10797,10800
10797,10801
10798,10799
10800,10801
10802,10803
10803,10804
10804,10805
10806,10807
10806,10808
10807,10808
10807,10809
10808,10809
10810,10811
10810,10812
10811,10812
10815,10816
10816,10817
10816,10818
10816,10819
10817,10818
10819,10820
10820,10821
10820,10822
10821,10822
10821,10823
10822,10823
10824,10825
10824,10826
10825,10826
10829,10830
10831,10832
10832,10833
10832,10834
10832,10835
10832,10836
10832,10837
10832,10838
10832,10839
10832,10840
10833,10834
10835,10836
10835,10837
10836,10837
10838,10839
10838,10840
10839,10840
10842,10843
10844,10845
10847,10848
10850,10851
10852,10853
10852,10854
10852,10855
10853,10854
10854,10855
10855,10856
10855,10857
10856,10857
10858,10859
10858,10860
10858,10861
10858,10862
10858,10863
10858,10864
10859,10860
10861,10862
10861,10863
10862,10863
10865,10866
10867,10868
10867,10869
10868,10869
10868,10870
10869,10870
10871,10872
10871,10873
10872,10873
10876,10877
10879,10880
10880,10881
10880,10882
10881,10882
10883,10884
10883,10885
10884,10885
10887,10888
10887,10889
10888,10889
10888,10890
10889,10890
10892,10893
10892,10894
10892,10895
10892,10896
10892,10897
10892,10898
10892,10899
10893,10894
10894,10895
10894,10896
10895,10896
10897,10898
10897,10899
10900,10901
10901,10902
10901,10903
10901,10904
10902,10903
10904,10905
10904,10906
10907,10908
10907,10909
10907,10910
10910,10911
10911,10912
10913,10914
10914,10915
10915,10916
10915,10917
10916,10917
10918,10919
10918,10920
10918,10921
10919,10920
10922,10923
10923,10924
10924,10925
10925,10926
10927,10928
10928,10929
10928,10930
10929,10930
10931,10932
10931,10933
10931,10934
10932,10933
10934,10935
10935,10936
10937,10938
10939,10940
10940,10941
10940,10942
10940,10943
10941,10942
10945,10946
10945,10947
10945,10948
10946,10947
10946,10948
10947,10948
10949,10950
10951,10952
10951,10953
10951,10954
10951,10955
10951,10956
10951,10957
10951,10958
10952,10953
10953,10954
10953,10955
10954,10955
10954,10956
10955,10956
10958,10959
10960,10961
10961,10962
10961,10963
10962,10963
10962,10964
10963,10964
10966,10967
10968,10969
10969,10970
10969,10971
10970,10971
10972,10973
10973,10974
10975,10976
10975,10977
10975,10978
10975,10979
10976,10977
10977,10978
10977,10979
10978,10979
10980,10981
10980,10982
10981,10982
10984,10985
10986,10987
10986,10988
10987,10988
10989,10990
10989,10991
10990,10991
10993,10994
10993,10995
10993,10996
10993,10997
10994,10995
10995,10996
10995,10997
10996,10997
10998,10999
10998,11000
10998,11001
11001,11002
11002,11003
11002,11004
11002,11005
11003,11004
11005,11006
11005,11007
11006,11007
11009,11010
11009,11011
11010,11011
11013,11014
11013,11015
11014,11015
11016,11017
11017,11018
11017,11019
11018,11019
11020,11021
11022,11023
11023,11024
11023,11025
11024,11025
11026,11027
11028,11029
11028,11030
11028,11031
11029,11030
11030,11031
11032,11033
11033,11034
11034,11035
11034,11036
11034,11037
11035,11036
11037,11038
11040,11041
11041,11042
11042,11043
11042,11044
11042,11045
11042,11046
11043,11044
11045,11046
11047,11048
11049,11050
11051,11052
11051,11053
11052,11053
11054,11055
11055,11056
11055,11057
11056,11057
11058,11059
11060,11061
11061,11062
11061,11063
11062,11063
11062,11064
11063,11064
11066,11067
11068,11069
11069,11070
11069,11071
11069,11072
11070,11071
11072,11073
11074,11075
11076,11077
11076,11078
11076,11079
11077,11078
11078,11079
11078,11080
11078,11081
11079,11080
11081,11082
11084,11085
11084,11086
11085,11086
11087,11088
11088,11089
11088,11090
11089,11090
11091,11092
11093,11094
11093,11095
11094,11095
11096,11097
11097,11098
11097,11099
11098,11099
11100,11101
11101,11102
11104,11105
11105,11106
11107,11108
11108,11109
11108,11110
11109,11110
11109,11111
11110,11111
11110,11112
11111,11112
11113,11114
11113,11115
11114,11115
11118,11119
11120,11121
11121,11122
11121,11123
11121,11124
11121,11125
11122,11123
11126,11127
11126,11128
11127,11128
11130,11131
11131,11132
11131,11133
11132,11133
11134,11135
11134,11136
11135,11136
11138,11139
11139,11140
11139,11141
11139,11142
11139,11143
11140,11141
11144,11145
11144,11146
11145,11146
11149,11150
11150,11151
11152,11153
11153,11154
11153,11155
11153,11156
11154,11155
11158,11159
11159,11160
11159,11161
11159,11162
11160,11161
11162,11163
11162,11164
11163,11164
11166,11167
11166,11168
11167,11168
11171,11172
11172,11173
11174,11175
11175,11176
11177,11178
11177,11179
11178,11179
11180,11181
11181,11182
11181,11183
11181,11184
11181,11185
11181,11186
11181,11187
11181,11188
11181,11189
11182,11183
11184,11185
11184,11186
11185,11186
11187,11188
11187,11189
11188,11189
11191,11192
11193,11194
11195,11196
11195,11197
11196,11197
11199,11200
11202,11203
11202,11204
11203,11204
11206,11207
11206,11208
11207,11208
11207,11209
11207,11210
11207,11211
11208,11209
11210,11211
11210,11212
11211,11212
11214,11215
11215,11216
11217,11218
11218,11219
11220,11221
11220,11222
11220,11223
11221,11222
11221,11223
11222,11223
11223,11224
11223,11225
11224,11225
11226,11227
11226,11228
11227,11228
11230,11231
11232,11233
11233,11234
11233,11235
11233,11236
11234,11235
11236,11237
11236,11238
11237,11238
11240,11241
11243,11244
11243,11245
11244,11245
11245,11246
11245,11247
11246,11247
11248,11249
11248,11250
11249,11250
11252,11253
11254,11255
11254,11256
11255,11256
11255,11257
11256,11257
11257,11258
11257,11259
11258,11259
11258,11260
11259,11260
11261,11262
11261,11263
11262,11263
11262,11264
11263,11264
11265,11266
11265,11267
11266,11267
11270,11271
11270,11272
11271,11272
11273,11274
11273,11275
11274,11275
11274,11276
11275,11276
11277,11278
11277,11279
11278,11279
11282,11283
11282,11284
11282,11285
11283,11284
11285,11286
11286,11287
11286,11288
11287,11288
11287,11289
11288,11289
11290,11291
11290,11292
11291,11292
11295,11296
11297,11298
11297,11299
11297,11300
11297,11301
11297,11302
11298,11299
11298,11300
11299,11300
11299,11301
11300,11301
11300,11302
11301,11302
11301,11303
11302,11303
11306,11307
11308,11309
11308,11310
11309,11310
11310,11311
11310,11312
11310,11313
11310,11314
11311,11312
11313,11314
11314,11315
11317,11318
11318,11319
11319,11320
11321,11322
11322,11323
11322,11324
11323,11324
11323,11325
11324,11325
11327,11328
11329,11330
11329,11331
11330,11331
11330,11332
11330,11333
11330,11334
11330,11335
11330,11336
11331,11332
11333,11334
11334,11335
11336,11337
11336,11338
11337,11338
11340,11341
11340,11342
11341,11342
11344,11345
11346,11347
11346,11348
11347,11348
11350,11351
11351,11352
11352,11353
11352,11354
11352,11355
11353,11354
11355,11356
11358,11359
11358,11360
11359,11360
11360,11361
11360,11362
11361,11362
11363,11364
11363,11365
11364,11365
11367,11368
11369,11370
11369,11371
11370,11371
11370,11372
11371,11372
11371,11373
11372,11373
11372,11374
11373,11374
11376,11377
11376,11378
11377,11378
11380,11381
11380,11382
11381,11382
11381,11383
11382,11383
11386,11387
11386,11388
11386,11389
11387,11388
11388,11389
11388,11390
11389,11390
11391,11392
11392,11393
11392,11394
11392,11395
11395,11396
11396,11397
11396,11398
11397,11398
11400,11401
11401,11402
11401,11403
11401,11404
11401,11405
11401,11406
11402,11403
11404,11405
11405,11406
11407,11408
11409,11410
11409,11411
11410,11411
11413,11414
11413,11415
11414,11415
11417,11418
11418,11419
11418,11420
11419,11420
11421,11422
11422,11423
11422,11424
11423,11424
11425,11426
11425,11427
11426,11427
11430,11431
11431,11432
11431,11433
11432,11433
11434,11435
11434,11436
11435,11436
11439,11440
11440,11441
11442,11443
11442,11444
11443,11444
11443,11445
11443,11446
11443,11447
11444,11445
11446,11447
11447,11448
11449,11450
11450,11451
11452,11453
11452,11454
11453,11454
11456,11457
11457,11458
11457,11459
11457,11460
11458,11459
11460,11461
11463,11464
11464,11465
11464,11466
11464,11467
11464,11468
11464,11469
11464,11470
11464,11471
11464,11472
11465,11466
11467,11468
11467,11469
11468,11469
11470,11471
11470,11472
11471,11472
11474,11475
11476,11477
11478,11479
11478,11480
11479,11480
11482,11483
11485,11486
11485,11487
11486,11487
11489,11490
11490,11491
11490,11492
11491,11492
11493,11494
11493,11495
11494,11495
11498,11499
11499,11500
11501,11502
11501,11503
11502,11503
11502,11504
11503,11504
11503,11505
11504,11505
11506,11507
11506,11508
11507,11508
11511,11512
11511,11513
11512,11513
11512,11514
11513,11514
11515,11516
11515,11517
11516,11517
11517,11518
11517,11519
11517,11520
11517,11521
11517,11522
11517,11523
11518,11519
11520,11521
11523,11524
11523,11525
11524,11525
11524,11526
11525,11526
11525,11527
11526,11527
11528,11529
11528,11530
11529,11530
11534,11535
11534,11536
11534,11537
11535,11536
11535,11537
11536,11537
11539,11540
11539,11541
11540,11541
11544,11545
11544,11546
11545,11546
11547,11548
11547,11549
11548,11549
11551,11552
11552,11553
11552,11554
11552,11555
11552,11556
11552,11557
11552,11558
11553,11554
11555,11556
11559,11560
11559,11561
11560,11561
11560,11562
11561,11562
11561,11563
11562,11563
11564,11565
11564,11566
11565,11566
11570,11571
11570,11572
11570,11573
11571,11572
11571,11573
11572,11573
11575,11576
11575,11577
11576,11577
11580,11581
11581,11582
11581,11583
11582,11583
11582,11584
11583,11584
11583,11585
11584,11585
11584,11586
11585,11586
11587,11588
11587,11589
11588,11589
11593,11594
11595,11596
11596,11597
11596,11598
11596,11599
11596,11600
11596,11601
11596,11602
11596,11603
11596,11604
11597,11598
11599,11600
11599,11601
11600,11601
11602,11603
11602,11604
11603,11604
11606,11607
11608,11609
11610,11611
11610,11612
11611,11612
11614,11615
11617,11618
11617,11619
11618,11619
11621,11622
11622,11623
11622,11624
11623,11624
11625,11626
11625,11627
11626,11627
11630,11631
11631,11632
11633,11634
11633,11635
11634,11635
11634,11636
11634,11637
11634,11638
11635,11636
11637,11638
11638,11639
11640,11641
11640,11642
11641,11642
11644,11645
11645,11646
11647,11648
11647,11649
11647,11650
11647,11651
11648,11649
11649,11650
11649,11651
11649,11652
11649,11653
11650,11651
11652,11653
11653,11654
11656,11657
11657,11658
11658,11659
11660,11661
11661,11662
11661,11663
11661,11664
11661,11665
11662,11663
11664,11665
11665,11666
11667,11668
11670,11671
11671,11672
11671,11673
11671,11674
11671,11675
11672,11673
11674,11675
11675,11676
11677,11678
11679,11680
11681,11682
11682,11683
11682,11684
11682,11685
11682,11686
11682,11687
11682,11688
11682,11689
11682,11690
11683,11684
11685,11686
11685,11687
11686,11687
11688,11689
11688,11690
11689,11690
11692,11693
11694,11695
11697,11698
11697,11699
11698,11699
11701,11702
11701,11703
11702,11703
11705,11706
11708,11709
11709,11710
11711,11712
11712,11713
11712,11714
11713,11714
11713,11715
11714,11715
11714,11716
11715,11716
11717,11718
11717,11719
11718,11719
11723,11724
11724,11725
11724,11726
11724,11727
11724,11728
11725,11726
11729,11730
11729,11731
11729,11732
11730,11731
11730,11732
11731,11732
11731,11733
11732,11733
11734,11735
11734,11736
11735,11736
11739,11740
11739,11741
11740,11741
11742,11743
11742,11744
11743,11744
11743,11745
11744,11745
11746,11747
11746,11748
11747,11748
11752,11753
11753,11754
11753,11755
11753,11756
11753,11757
11754,11755
11756,11757
11757,11758
11757,11759
11758,11759
11758,11760
11759,11760
11761,11762
11761,11763
11762,11763
11767,11768
11768,11769
11769,11770
11769,11771
11770,11771
11770,11772
11771,11772
11773,11774
11773,11775
11774,11775
11778,11779
11778,11780
11779,11780
11779,11781
11780,11781
11780,11782
11781,11782
11783,11784
11783,11785
11784,11785
11788,11789
11789,11790
11789,11791
11790,11791
11790,11792
11791,11792
11791,11793
11792,11793
11794,11795
11794,11796
11795,11796
11795,11797
11796,11797
11798,11799
11798,11800
11799,11800
11804,11805
11804,11806
11805,11806
11806,11807
11806,11808
11807,11808
11807,11809
11808,11809
11808,11810
11809,11810
11811,11812
11811,11813
11812,11813
11812,11814
11813,11814
11815,11816
11815,11817
11816,11817
11822,11823
11823,11824
11823,11825
11823,11826
11823,11827
11823,11828
11823,11829
11823,11830
11823,11831
11824,11825
11826,11827
11826,11828
11827,11828
11829,11830
11829,11831
11830,11831
11830,11832
11831,11832
11833,11834
11833,11835
11834,11835
11838,11839
11840,11841
11843,11844
11846,11847
11849,11850
11850,11851
11852,11853
11852,11854
11853,11854
11853,11855
11854,11855
11855,11856
11855,11857
11856,11857
11856,11858
11857,11858
11857,11859
11858,11859
11860,11861
11860,11862
11861,11862
11865,11866
11867,11868
11868,11869
11868,11870
11869,11870
11869,11871
11870,11871
11870,11872
11871,11872
11873,11874
11873,11875
11874,11875
11878,11879
11880,11881
11880,11882
11880,11883
11881,11882
11881,11883
11881,11884
11882,11883
11882,11884
11883,11884
11883,11885
11884,11885
11884,11886
11885,11886
11887,11888
11887,11889
11888,11889
11892,11893
11894,11895
11895,11896
11895,11897
11896,11897
11896,11898
11897,11898
11897,11899
11898,11899
11900,11901
11900,11902
11901,11902
11905,11906
11907,11908
11908,11909
11908,11910
11909,11910
11909,11911
11910,11911
11910,11912
11911,11912
11913,11914
11913,11915
11914,11915
11918,11919
11920,11921
11921,11922
11921,11923
11921,11924
11921,11925
11922,11923
11926,11927
11926,11928
11926,11929
11927,11928
11927,11929
11928,11929
11928,11930
11929,11930
11931,11932
11931,11933
11932,11933
11936,11937
11936,11938
11937,11938
11939,11940
11939,11941
11940,11941
11940,11942
11941,11942
11943,11944
11943,11945
11944,11945
11949,11950
11949,11951
11950,11951
11950,11952
11951,11952
11951,11953
11952,11953
11954,11955
11954,11956
11955,11956
11959,11960
11960,11961
11960,11962
11961,11962
11961,11963
11962,11963
11963,11964
11963,11965
11964,11965
11964,11966
11965,11966
11965,11967
11966,11967
11968,11969
11968,11970
11969,11970
11969,11971
11970,11971
11972,11973
11972,11974
11973,11974
11978,11979
11980,11981
11981,11982
11981,11983
11982,11983
11982,11984
11983,11984
11983,11985
11984,11985
11986,11987
11986,11988
11987,11988
11987,11989
11988,11989
11990,11991
11990,11992
11991,11992
11996,11997
11998,11999
11999,12000
11999,12001
11999,12002
12000,12001
12000,12002
12001,12002
12001,12003
12002,12003
12002,12004
12003,12004
12005,12006
12005,12007
12006,12007
12010,12011
12012,12013
12012,12014
12012,12015
12012,12016
12012,12017
12012,12018
12012,12019
12012,12020
12012,12021
12013,12014
12014,12015
12014,12016
12014,12017
12014,12018
12014,12019
12015,12016
12019,12020
12019,12021
12019,12022
12020,12021
12020,12022
12021,12022
12021,12023
12022,12023
12024,12025
12024,12026
12025,12026
12029,12030
12029,12031
12030,12031
12032,12033
12032,12034
12033,12034
12033,12035
12034,12035
12036,12037
12036,12038
12037,12038
12042,12043
12042,12044
12042,12045
12043,12044
12043,12045
12044,12045
12044,12046
12045,12046
12047,12048
12047,12049
12048,12049
12048,12050
12049,12050
12051,12052
12051,12053
12052,12053
12057,12058
12057,12059
12058,12059
12060,12061
12060,12062
12061,12062
12061,12063
12062,12063
12064,12065
12064,12066
12065,12066
12065,12067
12066,12067
12068,12069
12068,12070
12069,12070
12075,12076
12076,12077
12076,12078
12077,12078
12077,12079
12078,12079
12078,12080
12079,12080
12081,12082
12081,12083
12082,12083
12082,12084
12083,12084
12085,12086
12085,12087
12086,12087
12091,12092
12093,12094
12094,12095
12094,12096
12095,12096
12095,12097
12096,12097
12096,12098
12097,12098
12099,12100
12099,12101
12100,12101
12104,12105
12106,12107
12107,12108
12107,12109
12107,12110
12107,12111
12108,12109
12110,12111
12111,12112
12114,12115
12115,12116
12116,12117
12118,12119
12119,12120
12119,12121
12119,12122
12119,12123
12120,12121
12122,12123
12123,12124
12126,12127
12127,12128
12128,12129
12130,12131
12131,12132
12131,12133
12131,12134
12131,12135
12132,12133
12134,12135
12135,12136
12137,12138
12139,12140
12139,12141
12140,12141
12140,12142
12141,12142
12143,12144
12143,12145
12144,12145
12144,12146
12145,12146
12147,12148
12147,12149
12148,12149
12153,12154
12154,12155
12154,12156
12154,12157
12154,12158
12155,12156
12157,12158
12158,12159
12160,12161
12162,12163
12162,12164
12163,12164
12163,12165
12164,12165
12166,12167
12166,12168
12167,12168
12171,12172
12172,12173
12172,12174
12172,12175
12172,12176
12172,12177
12172,12178
12172,12179
12172,12180
12173,12174
12175,12176
12175,12177
12176,12177
12178,12179
12178,12180
12179,12180
12182,12183
12184,12185
12187,12188
12187,12189
12188,12189
12191,12192
12191,12193
12192,12193
12195,12196
12197,12198
12198,12199
12198,12200
12198,12201
12198,12202
12198,12203
12198,12204
12198,12205
12198,12206
12199,12200
12201,12202
12201,12203
12202,12203
12204,12205
12204,12206
12205,12206
12205,12207
12206,12207
12208,12209
12208,12210
12209,12210
12213,12214
12215,12216
12218,12219
12218,12220
12219,12220
12222,12223
12222,12224
12223,12224
12226,12227
12228,12229
12228,12230
12228,12231
12228,12232
12228,12233
12228,12234
12228,12235
12228,12236
12228,12237
12228,12238
12228,12239
12228,12240
12228,12241
12229,12230
12230,12231
12230,12232
12230,12233
12230,12234
12230,12235
12231,12232
12235,12236
12235,12237
12235,12238
12236,12237
12236,12238
12237,12238
12237,12239
12238,12239
12240,12241
12240,12242
12241,12242
12245,12246
12245,12247
12246,12247
12248,12249
12248,12250
12249,12250
12249,12251
12250,12251
12252,12253
12252,12254
12253,12254
12258,12259
12258,12260
12258,12261
12259,12260
12259,12261
12260,12261
12260,12262
12261,12262
12263,12264
12263,12265
12264,12265
12264,12266
12265,12266
12267,12268
12267,12269
12268,12269
12273,12274
12273,12275
12274,12275
12276,12277
12276,12278
12277,12278
12277,12279
12278,12279
12280,12281
12280,12282
12281,12282
12281,12283
12282,12283
12284,12285
12284,12286
12285,12286
12291,12292
12292,12293
12292,12294
12293,12294
12293,12295
12294,12295
12294,12296
12295,12296
12297,12298
12297,12299
12298,12299
12298,12300
12299,12300
12301,12302
12301,12303
12302,12303
12307,12308
12309,12310
12310,12311
12310,12312
12311,12312
12311,12313
12312,12313
12312,12314
12313,12314
12315,12316
12315,12317
12316,12317
12320,12321
12322,12323
12323,12324
12323,12325
12323,12326
12324,12325
12326,12327
12326,12328
12327,12328
12329,12330
12329,12331
12330,12331
12330,12332
12331,12332
12333,12334
12333,12335
12334,12335
12338,12339
12340,12341
12341,12342
12341,12343
12341,12344
12342,12343
12344,12345
12344,12346
12345,12346
12347,12348
12347,12349
12348,12349
12351,12352
12353,12354
12354,12355
12354,12356
12355,12356
12357,12358
12357,12359
12358,12359
12361,12362
12362,12363
12362,12364
12363,12364
12365,12366
12365,12367
12366,12367
12366,12368
12367,12368
12369,12370
12369,12371
12370,12371
12374,12375
12375,12376
12375,12377
12375,12378
12375,12379
12376,12377
12378,12379
12379,12380
12382,12383
12383,12384
12384,12385
12386,12387
12387,12388
12387,12389
12387,12390
12387,12391
12388,12389
12390,12391
12391,12392
12394,12395
12395,12396
12396,12397
12398,12399
12399,12400
12399,12401
12399,12402
12399,12403
12400,12401
12402,12403
12403,12404
12405,12406
12407,12408
12407,12409
12408,12409
12408,12410
12409,12410
12411,12412
12411,12413
12412,12413
12412,12414
12413,12414
12415,12416
12415,12417
12416,12417
12421,12422
12422,12423
12422,12424
12422,12425
12422,12426
12423,12424
12425,12426
12426,12427
12428,12429
12430,12431
12430,12432
12431,12432
12431,12433
12432,12433
12434,12435
12434,12436
12435,12436
12439,12440
12440,12441
12440,12442
12440,12443
12440,12444
12440,12445
12440,12446
12440,12447
12440,12448
12441,12442
12443,12444
12443,12445
12444,12445
12446,12447
12446,12448
12447,12448
12450,12451
12452,12453
12455,12456
12455,12457
12456,12457
12459,12460
12459,12461
12460,12461
12463,12464
12465,12466
12466,12467
12466,12468
12466,12469
12466,12470
12466,12471
12466,12472
12466,12473
12466,12474
12467,12468
12469,12470
12469,12471
12470,12471
12472,12473
12472,12474
12473,12474
12473,12475
12474,12475
12476,12477
12476,12478
12477,12478
12481,12482
12483,12484
12486,12487
12486,12488
12487,12488
12490,12491
12490,12492
12491,12492
12494,12495
12497,12498
12498,12499
12500,12501
12501,12502
12501,12503
12501,12504
12502,12503
12504,12505
12504,12506
12505,12506
12507,12508
12507,12509
12508,12509
12511,12512
12512,12513
12515,12516
12516,12517
12518,12519
12518,12520
12519,12520
12519,12521
12520,12521
12520,12522
12521,12522
12523,12524
12523,12525
12524,12525
12528,12529
12529,12530
12529,12531
12529,12532
12529,12533
12529,12534
12529,12535
12529,12536
12530,12531
12532,12533
12532,12534
12533,12534
12535,12536
12535,12537
12536,12537
12539,12540
12541,12542
12544,12545
12548,12549
12549,12550
12551,12552
12552,12553
12552,12554
12552,12555
12552,12556
12552,12557
12552,12558
12552,12559
12552,12560
12553,12554
12555,12556
12555,12557
12556,12557
12558,12559
12558,12560
12559,12560
12562,12563
12564,12565
12566,12567
12566,12568
12567,12568
12570,12571
12573,12574
12573,12575
12574,12575
12577,12578
12578,12579
12578,12580
12578,12581
12579,12580
12581,12582
12581,12583
12582,12583
12585,12586
12586,12587
12588,12589
12589,12590
12589,12591
12590,12591
12592,12593
12592,12594
12593,12594
12597,12598
12598,12599
12600,12601
12600,12602
12601,12602
12601,12603
12602,12603
12602,12604
12603,12604
12603,12605
12604,12605
12606,12607
12606,12608
12607,12608
12611,12612
12613,12614
12613,12615
12613,12616
12613,12617
12614,12615
12615,12616
12615,12617
12615,12618
12615,12619
12616,12617
12618,12619
12619,12620
12619,12621
12620,12621
12622,12623
12622,12624
12623,12624
12626,12627
12628,12629
12630,12631
12631,12632
12632,12633
12632,12634
12633,12634
12633,12635
12634,12635
12637,12638
12638,12639
12639,12640
12639,12641
12640,12641
12640,12642
12641,12642
12644,12645
12646,12647
12647,12648
12647,12649
12648,12649
12648,12650
12649,12650
12649,12651
12650,12651
12652,12653
12652,12654
12653,12654
12657,12658
12660,12661
12661,12662
12663,12664
12663,12665
12664,12665
12665,12666
12665,12667
12666,12667
12668,12669
12668,12670
12669,12670
12671,12672
12671,12673
12672,12673
12675,12676
12675,12677
12676,12677
12677,12678
12677,12679
12677,12680
12678,12679
12680,12681
12684,12685
12685,12686
12685,12687
12685,12688
12686,12687
12689,12690
12689,12691
12690,12691
12693,12694
12694,12695
12694,12696
12694,12697
12695,12696
12697,12698
12697,12699
12698,12699
12698,12700
12700,12701
12702,12703
12702,12704
12703,12704
12706,12707
12707,12708
12707,12709
12708,12709
12708,12710
12709,12710
12711,12712
12711,12713
12712,12713
12717,12718
12718,12719
12720,12721
12721,12722
12721,12723
12721,12724
12722,12723
12724,12725
12724,12726
12725,12726
12727,12728
12727,12729
12728,12729
12731,12732
12732,12733
12735,12736
12736,12737
12738,12739
12739,12740
12739,12741
12739,12742
12739,12743
12740,12741
12742,12743
12745,12746
12745,12747
12746,12747
12750,12751
12751,12752
12753,12754
12753,12755
12754,12755
12755,12756
12755,12757
12755,12758
12756,12757
12758,12759
12759,12760
12761,12762
12763,12764
12763,12765
12764,12765
12765,12766
12765,12767
12765,12768
12765,12769
12765,12770
12765,12771
12765,12772
12765,12773
12766,12767
12768,12769
12768,12770
12769,12770
12771,12772
12771,12773
12772,12773
12775,12776
12777,12778
12780,12781
12783,12784
12786,12787
12787,12788
12787,12789
12787,12790
12787,12791
12788,12789
12790,12791
12791,12792
12794,12795
12795,12796
12796,12797
12798,12799
12799,12800
12799,12801
12800,12801
12802,12803
12802,12804
12802,12805
12802,12806
12803,12804
12805,12806
12806,12807
12808,12809
12808,12810
12809,12810
12809,12811
12811,12812
12813,12814
12813,12815
12814,12815
12817,12818
12817,12819
12818,12819
12821,12822
12821,12823
12821,12824
12822,12823
12822,12824
12823,12824
12826,12827
12827,12828
12827,12829
12827,12830
12827,12831
12827,12832
12827,12833
12827,12834
12827,12835
12828,12829
12830,12831
12830,12832
12831,12832
12833,12834
12833,12835
12834,12835
12837,12838
12839,12840
12842,12843
12842,12844
12843,12844
12846,12847
12846,12848
12847,12848
12850,12851
12852,12853
12852,12854
12852,12855
12853,12854
12853,12855
12854,12855
12857,12858
12858,12859
12858,12860
12858,12861
12858,12862
12858,12863
12858,12864
12858,12865
12858,12866
12859,12860
12861,12862
12861,12863
12862,12863
12864,12865
12864,12866
12865,12866
12868,12869
12870,12871
12873,12874
12873,12875
12874,12875
12877,12878
12877,12879
12878,12879
12881,12882
12883,12884
12884,12885
12884,12886
12884,12887
12884,12888
12884,12889
12884,12890
12884,12891
12884,12892
12885,12886
12887,12888
12887,12889
12888,12889
12890,12891
12890,12892
12891,12892
12894,12895
12896,12897
12899,12900
12899,12901
12900,12901
12903,12904
12903,12905
12904,12905
12907,12908
12910,12911
12911,12912
12913,12914
12913,12915
12913,12916
12914,12915
12915,12916
12915,12917
12916,12917
12918,12919
12918,12920
12921,12922
12921,12923
12922,12923
12922,12924
12923,12924
12923,12925
12924,12925
12925,12926
12925,12927
12926,12927
12928,12929
12928,12930
12929,12930
12931,12932
12932,12933
12932,12934
12933,12934
12935,12936
12935,12937
12936,12937
12939,12940
12939,12941
12940,12941
12943,12944
12943,12945
12944,12945
12947,12948
12948,12949
12949,12950
12949,12951
12949,12952
12949,12953
12950,12951
12952,12953
12952,12954
12953,12954
12956,12957
12958,12959
12958,12960
12959,12960
12959,12961
12961,12962
12963,12964
12963,12965
12964,12965
12969,12970
12970,12971
12970,12972
12970,12973
12970,12974
12970,12975
12970,12976
12971,12972
12975,12976
12975,12977
12976,12977
12976,12978
12977,12978
12981,12982
12981,12983
12982,12983
12985,12986
12985,12987
12986,12987
12986,12988
12987,12988
12989,12990
12989,12991
12990,12991
12994,12995
12995,12996
12995,12997
12995,12998
12995,12999
12996,12997
12998,12999
12999,13000
13002,13003
13003,13004
13004,13005
13006,13007
13007,13008
13007,13009
13007,13010
13007,13011
13008,13009
13010,13011
13011,13012
13013,13014
13015,13016
13015,13017
13016,13017
13016,13018
13017,13018
13021,13022
13022,13023
13022,13024
13022,13025
13022,13026
13022,13027
13022,13028
13022,13029
13022,13030
13023,13024
13025,13026
13025,13027
13026,13027
13028,13029
13028,13030
13029,13030
13032,13033
13034,13035
13037,13038
13037,13039
13038,13039
13041,13042
13041,13043
13042,13043
13045,13046
13047,13048
13047,13049
13048,13049
13048,13050
13049,13050
13052,13053
13052,13054
13052,13055
13053,13054
13054,13055
13054,13056
13055,13056
13057,13058
13057,13059
13058,13059
13061,13062
13062,13063
13062,13064
13062,13065
13063,13064
13067,13068
13068,13069
13068,13070
13069,13070
13069,13071
13070,13071
13073,13074
13075,13076
13075,13077
13076,13077
13076,13078
13077,13078
13077,13079
13078,13079
13078,13080
13079,13080
13079,13081
13080,13081
13081,13082
13081,13083
13082,13083
13082,13084
13083,13084
13083,13085
13084,13085
13088,13089
13090,13091
13091,13092
13091,13093
13092,13093
13092,13094
13093,13094
13093,13095
13094,13095
13098,13099
13100,13101
13101,13102
13101,13103
13102,13103
13102,13104
13103,13104
13103,13105
13104,13105
13108,13109
13110,13111
13111,13112
13111,13113
13112,13113
13112,13114
13113,13114
13113,13115
13114,13115
13118,13119
13120,13121
13121,13122
13121,13123
13122,13123
13122,13124
13123,13124
13123,13125
13124,13125
13128,13129
13130,13131
13131,13132
13131,13133
13132,13133
13132,13134
13133,13134
13133,13135
13134,13135
13136,13137
13136,13138
13137,13138
13140,13141
13140,13142
13141,13142
13141,13143
13142,13143
13142,13144
13143,13144
13145,13146
13145,13147
13146,13147
13150,13151
13150,13152
13151,13152
13151,13153
13152,13153
13154,13155
13154,13156
13155,13156
13159,13160
13160,13161
13160,13162
13160,13163
13160,13164
13160,13165
13160,13166
13160,13167
13160,13168
13161,13162
13163,13164
13163,13165
13164,13165
13166,13167
13166,13168
13167,13168
13170,13171
13172,13173
13174,13175
13174,13176
13175,13176
13178,13179
13181,13182
13181,13183
13182,13183
13185,13186
13186,13187
13186,13188
13187,13188
13189,13190
13190,13191
13190,13192
13190,13193
13193,13194
13194,13195
13194,13196
13195,13196
13198,13199
13200,13201
13200,13202
13201,13202
13201,13203
13202,13203
13202,13204
13203,13204
13205,13206
13205,13207
13206,13207
13209,13210
13209,13211
13210,13211
13210,13212
13211,13212
13211,13213
13212,13213
13214,13215
13214,13216
13215,13216
13219,13220
13219,13221
13220,13221
13220,13222
13221,13222
13223,13224
13223,13225
13224,13225
13228,13229
13229,13230
13229,13231
13229,13232
13229,13233
13229,13234
13229,13235
13229,13236
13229,13237
13230,13231
13232,13233
13232,13234
13233,13234
13235,13236
13235,13237
13236,13237
13239,13240
13241,13242
13243,13244
13243,13245
13244,13245
13247,13248
13250,13251
13250,13252
13251,13252
-----nextToken-----
2,4,7,9,10,15,17,20,22,25,27,29,33,35,37,40,42,44,48,50,51,56,58,61,62,66,68,69,74,76,79,80,84,86,87,92,94,97,98,102,104,105,110,112,115,116,120,122,123,127,129,130,134,136,139,143,145,146,149,153,155,156,160,162,163,167,169,173,175,177,181,183,186,188,191,193,196,198,200,203,205,207,209,213,215,216,219,221,223,226,228,230,234,236,239,241,242,244,248,251,257,258,262,264,265,270,275,276,277,281,284,285,289,292,293,297,300,304,305,309,313,318,323,325,326,328,331,332,337,339,346,347,348,353,356,357,358,363,368,373,375,376,379,382,383,386,389,390,392,397,398,405,406,407,413,416,417,418,422,424,426,429,431,433,438,441,442,444,449,454,459,461,462,465,468,469,472,475,476,478,482,486,489,490,493,499,500,505,506,509,513,516,517,520,522,525,527,529,530,535,538,539,543,544,549,552,553,556,559,562,563,565,570,573,574,576,579,582,587,589,590,594,598,601,602,604,608,609,613,617,620,621,626,627,630,631,636,637,639,644,649,650,651,655,659,660,662,669,670,671,672,677,682,683,684,689,690,692,697,702,703,704,707,710,711,718,719,720,723,726,727,733,734,736,741,742,743,745,750,751,754,757,758,761,763,766,769,770,774,775,776,778,780,782,789,790,792,797,798,799,801,804,805,808,813,814,817,822,826,827,833,834,836,841,844,848,849,853,854,857,858,863,865,866,869,872,873,877,880,881,883,889,890,891,893,898,899,900,907,908,909,913,914,918,919,923,926,927,931,937,938,940,946,947,948,950,956,957,958,960,964,967,968,972,977,980,983,984,988,989,990,991,996,998,1001,1004,1006,1011,1014,1015,1017,1022,1023,1026,1027,1037,1038,1040,1046,1047,1048,1049,1053,1056,1057,1061,1066,1067,1071,1073,1075,1082,1085,1086,1088,1095,1096,1098,1104,1105,1106,1108,1113,1114,1123,1124,1126,1131,1132,1133,1135,1140,1141,1144,1147,1148,1151,1153,1156,1159,1160,1164,1165,1166,1168,1170,1176,1177,1179,1186,1187,1188,1190,1195,1196,1197,1199,1204,1205,1208,1211,1212,1215,1217,1220,1223,1224,1228,1229,1230,1232,1234,1238,1241,1242,1244,1249,1250,1251,1256,1258,1259,1263,1266,1267,1271,1272,1277,1280,1281,1286,1289,1292,1293,1298,1300,1304,1306,1312,1313,1317,1320,1321,1327,1330,1331,1333,1346,1347,1348,1350,1356,1357,1358,1360,1366,1367,1368,1370,1376,1377,1378,1380,1385,1386,1388,1392,1395,1399,1402,1403,1406,1410,1413,1414,1417,1419,1424,1425,1426,1430,1433,1434,1438,1439,1443,1446,1447,1449,1454,1457,1460,1461,1463,1466,1471,1474,1475,1477,1480,1483,1488,1490,1491,1495,1498,1499,1503,1506,1507,1511,1512,1514,1518,1519,1526,1529,1530,1531,1535,1536,1538,1546,1547,1549,1553,1554,1556,1560,1561,1563,1567,1568,1570,1575,1577,1578,1581,1583,1589,1592,1594,1596,1598,1602,1605,1606,1608,1612,1616,1617,1621,1622,1627,1628,1629,1634,1639,1640,1641,1646,1650,1653,1655,1659,1662,1664,1668,1671,1672,1675,1679,1682,1683,1684,1686,1691,1692,1695,1696,1700,1703,1704,1708,1713,1714,1715,1717,1720,1721,1725,1728,1729,1734,1737,1738,1742,1745,1746,1747,1752,1756,1759,1760,1761,1763,1765,1767,1771,1775,1778,1779,1780,1782,1784,1788,1792,1795,1796,1797,1802,1805,1806,1811,1814,1815,1819,1822,1823,1827,1828,1830,1836,1839,1840,1841,1849,1852,1857,1860,1861,1862,1865,1870,1871,1872,1874,1879,1880,1881,1883,1887,1889,1893,1896,1897,1902,1905,1906,1909,1913,1916,1920,1923,1924,1925,1931,1934,1935,1936,1941,1944,1948,1949,1955,1958,1959,1960,1962,1966,1969,1973,1974,1979,1982,1983,1985,1989,1993,1994,1995,1998,1999,2002,2003,2007,2008,2009,2014,2015,2018,2019,2024,2025,2028,2029,2034,2035,2038,2041,2042,2049,2052,2053,2055,2060,2061,2063,2067,2068,2076,2079,2080,2081,2084,2085,2092,2095,2096,2097,2108,2109,2110,2112,2118,2119,2120,2122,2128,2129,2130,2132,2138,2139,2140,2142,2148,2149,2150,2152,2157,2158,2160,2177,2178,2179,2181,2187,2188,2189,2191,2197,2198,2199,2201,2207,2208,2209,2211,2217,2218,2219,2221,2227,2228,2229,2231,2237,2238,2239,2241,2247,2248,2249,2251,2256,2257,2259,2264,2265,2266,2270,2273,2274,2275,2278,2279,2282,2283,2287,2288,2289,2294,2295,2301,2304,2305,2306,2309,2310,2311,2319,2320,2322,2330,2331,2332,2334,2340,2341,2342,2344,2349,2350,2351,2355,2358,2361,2362,2364,2366,2369,2370,2372,2373,2376,2377,2382,2385,2386,2390,2393,2394,2398,2401,2402,2406,2407,2409,2423,2424,2425,2427,2433,2434,2435,2437,2443,2444,2445,2447,2453,2454,2455,2457,2463,2464,2465,2467,2472,2473,2475,2481,2484,2485,2486,2492,2493,2495,2500,2501,2504,2505,2506,2511,2514,2515,2521,2522,2525,2526,2532,2533,2536,2537,2538,2544,2547,2552,2555,2556,2557,2565,2566,2567,2569,2574,2575,2577,2581,2583,2586,2588,2595,2598,2599,2600,2604,2607,2608,2609,2615,2616,2620,2623,2624,2625,2629,2630,2634,2637,2638,2639,2643,2646,2647,2651,2655,2658,2659,2660,2666,2670,2673,2674,2675,2681,2684,2685,2686,2689,2690,2696,2700,2703,2704,2705,2708,2711,2712,2715,2719,2723,2724,2725,2727,2731,2732,2736,2740,2743,2744,2746,2748,2754,2757,2758,2764,2765,2767,2771,2772,2776,2779,2780,2783,2787,2791,2792,2793,2795,2799,2802,2803,2806,2810,2812,2816,2820,2822,2826,2829,2830,2836,2839,2840,2841,2844,2845,2850,2853,2854,2858,2861,2862,2866,2867,2869,2874,2875,2876,2879,2880,2884,2887,2888,2889,2893,2896,2897,2898,2903,2906,2911,2914,2915,2916,2923,2924,2926,2934,2935,2936,2938,2944,2945,2946,2948,2953,2956,2957,2961,2964,2965,2969,2970,2972,2980,2981,2983,2988,2989,2991,2996,2997,2999,3004,3007,3010,3011,3013,3018,3021,3024,3025,3027,3032,3035,3036,3038,3042,3045,3046,3047,3049,3052,3057,3060,3061,3062,3064,3069,3072,3073,3077,3080,3081,3085,3086,3088,3092,3093,3098,3100,3101,3104,3108,3110,3111,3113,3114,3117,3122,3125,3126,3131,3134,3135,3140,3143,3144,3148,3151,3152,3156,3157,3159,3164,3168,3171,3172,3173,3178,3181,3182,3187,3191,3194,3197,3199,3203,3205,3211,3212,3214,3219,3220,3222,3226,3229,3233,3234,3235,3240,3243,3244,3246,3249,3252,3253,3258,3260,3261,3265,3268,3269,3272,3273,3276,3281,3283,3287,3289,3293,3298,3300,3301,3306,3308,3310,3312,3315,3320,3322,3327,3328,3330,3334,3336,3338,3343,3345,3346,3349,3354,3356,3359,3364,3367,3371,3373,3378,3379,3380,3385,3388,3389,3392,3395,3396,3399,3402,3403,3404,3407,3413,3414,3418,3421,3422,3423,3429,3432,3433,3434,3437,3438,3443,3444,3446,3450,3451,3456,3457,3458,3466,3467,3469,3475,3476,3477,3479,3483,3486,3487,3488,3493,3496,3500,3501,3506,3507,3509,3515,3520,3521,3522,3526,3529,3530,3531,3538,3541,3542,3543,3546,3551,3552,3553,3557,3558,3559,3562,3567,3568,3569,3574,3577,3578,3579,3584,3587,3588,3592,3595,3596,3602,3605,3606,3607,3612,3614,3615,3619,3622,3626,3629,3630,3631,3635,3637,3638,3642,3646,3649,3650,3651,3654,3659,3661,3666,3667,3668,3673,3677,3680,3681,3682,3683,3688,3692,3695,3696,3697,3700,3704,3707,3708,3709,3713,3715,3717,3721,3725,3728,3729,3730,3734,3737,3739,3744,3745,3746,3750,3751,3756,3759,3760,3764,3765,3766,3771,3772,3774,3778,3781,3782,3786,3787,3789,3794,3795,3797,3805,3806,3807,3808,3811,3815,3818,3819,3820,3825,3826,3827,3830,3835,3836,3837,3843,3846,3847,3848,3851,3856,3857,3858,3864,3865,3867,3871,3874,3875,3876,3883,3884,3885,3887,3892,3896,3899,3900,3901,3903,3909,3910,3911,3913,3918,3922,3925,3926,3927,3929,3934,3935,3937,3942,3944,3948,3951,3952,3953,3956,3960,3961,3962,3966,3967,3968,3977,3980,3981,3982,3985,3986,3991,3992,3993,3995,4000,4001,4002,4004,4009,4010,4011,4013,4020,4023,4024,4025,4028,4029,4032,4036,4037,4038,4041,4042,4045,4046,4052,4055,4056,4057,4061,4062,4063,4069,4072,4073,4074,4081,4084,4085,4086,4090,4091,4092,4097,4098,4099,4103,4104,4107,4111,4116,4119,4120,4121,4123,4129,4132,4133,4134,4139,4143,4146,4147,4148,4150,4151,4152,4155,4159,4162,4163,4164,4167,4171,4174,4175,4176,4180,4183,4186,4187,4189,4193,4194,4199,4202,4203,4209,4212,4213,4218,4221,4222,4223,4225,4229,4233,4236,4237,4238,4242,4244,4245,4250,4253,4254,4255,4259,4262,4263,4265,4268,4270,4272,4277,4279,4283,4285,4286,4287,4291,4295,4298,4299,4300,4301,4304,4308,4313,4316,4317,4318,4320,4325,4328,4329,4334,4337,4338,4340,4346,4349,4350,4351,4354,4357,4360,4361,4363,4368,4372,4375,4376,4377,4379,4380,4381,4384,4388,4391,4392,4393,4396,4400,4403,4404,4405,4409,4412,4415,4416,4418,4424,4427,4428,4429,4431,4435,4439,4442,4443,4444,4449,4452,4453,4455,4457,4458,4462,4466,4469,4470,4471,4472,4475,4481,4484,4485,4486,4488,4493,4497,4500,4501,4503,4505,4511,4512,4518,4519,4521,4525,4528,4529,4533,4537,4540,4542,4546,4549,4550,4551,4555,4558,4561,4562,4564,4566,4567,4570,4571,4574,4575,4577,4583,4586,4587,4588,4590,4591,4594,4598,4603,4606,4607,4608,4611,4613,4614,4620,4621,4624,4625,4629,4630,4631,4636,4639,4640,4644,4645,4649,4652,4654,4657,4658,4661,4662,4666,4670,4673,4674,4679,4682,4683,4685,4689,4692,4695,4696,4698,4702,4704,4710,4713,4716,4717,4718,4720,4725,4726,4728,4731,4735,4738,4741,4742,4744,4746,4749,4750,4752,4753,4756,4757,4761,4764,4765,4768,4771,4776,4779,4780,4782,4785,4789,4791,4792,4795,4798,4799,4803,4806,4807,4808,4812,4815,4816,4817,4818,4823,4827,4830,4831,4832,4835,4838,4841,4842,4844,4849,4852,4853,4855,4859,4861,4862,4863,4867,4871,4874,4875,4876,4877,4881,4883,4884,4886,4887,4889,4890,4894,4897,4901,4904,4905,4906,4910,4913,4917,4920,4921,4922,4926,4929,4933,4936,4937,4938,4942,4945,4946,4950,4951,4955,4958,4960,4962,4964,4965,4967,4971,4975,4978,4979,4984,4987,4988,4990,4994,4995,4999,5001,5004,5009,5013,5016,5017,5018,5021,5025,5028,5029,5030,5036,5040,5043,5044,5045,5046,5049,5054,5057,5058,5062,5066,5069,5071,5072,5076,5079,5081,5083,5087,5090,5093,5094,5096,5098,5099,5102,5103,5106,5107,5109,5114,5117,5118,5120,5123,5127,5129,5130,5133,5136,5137,5141,5144,5145,5146,5150,5153,5154,5155,5160,5163,5166,5167,5169,5174,5177,5180,5181,5183,5188,5189,5194,5195,5199,5204,5207,5208,5209,5213,5216,5217,5218,5222,5225,5226,5230,5234,5236,5237,5241,5243,5244,5249,5251,5255,5256,5260,5261,5265,5270,5273,5274,5275,5278,5279,5280,5281,5285,5290,5293,5294,5295,5296,5299,5304,5307,5310,5311,5313,5318,5322,5325,5326,5327,5331,5332,5337,5341,5344,5345,5346,5350,5354,5357,5358,5359,5363,5366,5369,5374,5377,5378,5379,5383,5386,5387,5388,5389,5393,5398,5401,5402,5403,5405,5410,5411,5415,5420,5423,5424,5425,5427,5432,5433,5437,5443,5446,5449,5450,5452,5456,5461,5464,5465,5466,5470,5473,5474,5475,5479,5484,5487,5488,5492,5496,5499,5501,5502,5506,5509,5511,5513,5517,5520,5523,5524,5526,5528,5529,5532,5533,5536,5537,5539,5544,5547,5548,5550,5553,5557,5559,5561,5563,5565,5567,5569,5573,5576,5579,5580,5582,5587,5589,5590,5593,5596,5597,5600,5602,5606,5610,5613,5614,5615,5618,5620,5624,5628,5631,5632,5633,5638,5640,5641,5644,5647,5648,5651,5653,5657,5661,5664,5665,5666,5669,5671,5675,5679,5682,5683,5684,5687,5689,5693,5697,5700,5701,5702,5707,5710,5713,5714,5716,5725,5728,5729,5730,5734,5737,5738,5739,5743,5744,5749,5752,5755,5756,5758,5763,5767,5770,5773,5774,5776,5777,5778,5782,5785,5786,5790,5794,5797,5802,5805,5806,5807,5811,5814,5815,5816,5820,5822,5823,5827,5829,5830,5835,5837,5841,5842,5846,5851,5854,5855,5856,5857,5860,5865,5868,5871,5872,5874,5879,5883,5886,5887,5888,5893,5897,5900,5901,5902,5906,5907,5911,5914,5917,5922,5925,5926,5927,5931,5934,5935,5936,5937,5941,5944,5949,5952,5953,5954,5958,5961,5962,5963,5967,5971,5973,5975,5977,5979,5981,5983,5987,5990,5991,5995,5999,6002,6004,6005,6009,6012,6014,6016,6020,6022,6023,6026,6028,6032,6037,6040,6041,6042,6046,6049,6050,6051,6055,6058,6061,6062,6064,6066,6067,6070,6071,6074,6075,6077,6082,6085,6086,6088,6091,6096,6098,6099,6102,6105,6106,6109,6111,6115,6119,6122,6123,6124,6127,6129,6133,6137,6140,6141,6142,6145,6147,6151,6155,6158,6159,6160,6164,6167,6170,6171,6173,6174,6177,6182,6185,6186,6190,6194,6197,6199,6201,6205,6208,6210,6211,6213,6217,6220,6223,6224,6226,6228,6229,6232,6233,6236,6237,6239,6243,6247,6250,6251,6252,6253,6258,6263,6266,6267,6268,6270,6274,6275,6276,6279,6282,6283,6285,6288,6292,6295,6296,6297,6299,6301,6303,6306,6308,6310,6312,6314,6316,6322,6325,6326,6327,6329,6333,6336,6337,6341,6344,6347,6348,6350,6355,6360,6363,6364,6365,6367,6371,6372,6373,6376,6379,6380,6381,6387,6390,6391,6392,6394,6398,6401,6404,6405,6408,6409,6415,6418,6419,6420,6421,6427,6430,6431,6434,6437,6438,6442,6447,6450,6451,6452,6454,6455,6458,6464,6469,6472,6473,6474,6476,6480,6485,6488,6489,6490,6492,6495,6496,6500,6505,6508,6509,6513,6516,6517,6518,6521,6522,6526,6529,6530,6531,6536,6539,6540,6544,6547,6548,6549,6552,6553,6557,6560,6561,6562,6563,6564,6567,6571,6574,6577,6578,6580,6584,6585,6586,6589,6590,6595,6598,6599,6600,6605,6608,6609,6612,6613,6618,6621,6622,6624,6628,6631,6634,6635,6637,6639,6642,6643,6645,6646,6649,6650,6654,6657,6658,6659,6662,6667,6670,6671,6672,6677,6680,6681,6684,6685,6690,6693,6694,6696,6701,6704,6707,6708,6710,6717,6720,6721,6722,6724,6728,6730,6731,6734,6739,6742,6743,6744,6745,6749,6750,6753,6754,6755,6759,6760,6761,6764,6765,6769,6772,6775,6776,6778,6780,6783,6784,6786,6787,6790,6791,6796,6799,6802,6803,6805,6811,6814,6815,6816,6818,6822,6825,6826,6827,6830,6835,6837,6838,6842,6844,6845,6849,6852,6853,6858,6861,6862,6864,6868,6872,6875,6876,6877,6881,6884,6887,6889,6891,6895,6898,6899,6903,6905,6906,6910,6913,6917,6920,6921,6922,6926,6928,6932,6934,6938,6940,6944,6947,6948,6952,6953,6957,6959,6960,6963,6965,6969,6971,6972,6975,6977,6981,6984,6985,6987,6989,6994,6995,6996,6999,7001,7005,7007,7009,7012,7013,7015,7020,7022,7023,7026,7028,7033,7035,7037,7040,7041,7042,7047,7049,7050,7053,7055,7058,7059,7061,7066,7067,7068,7071,7073,7076,7077,7079,7083,7085,7089,7091,7095,7099,7102,7103,7108,7109,7110,7113,7114,7117,7122,7124,7125,7128,7132,7137,7140,7141,7142,7146,7148,7150,7151,7155,7158,7161,7162,7164,7169,7172,7175,7176,7178,7180,7183,7184,7186,7187,7190,7191,7195,7198,7199,7200,7204,7205,7212,7215,7216,7217,7220,7221,7227,7230,7231,7232,7238,7241,7242,7243,7246,7249,7253,7256,7257,7258,7264,7267,7268,7269,7273,7276,7277,7278,7282,7283,7284,7287,7292,7295,7296,7297,7298,7301,7305,7308,7309,7310,7318,7321,7322,7323,7327,7330,7331,7332,7337,7340,7341,7345,7349,7352,7354,7355,7359,7362,7364,7366,7370,7373,7376,7377,7379,7381,7382,7385,7386,7389,7390,7392,7397,7400,7401,7403,7406,7410,7412,7414,7416,7418,7422,7424,7425,7428,7431,7432,7435,7437,7441,7445,7448,7449,7450,7453,7455,7459,7463,7466,7467,7468,7473,7478,7481,7482,7483,7485,7489,7492,7493,7498,7501,7502,7506,7509,7510,7511,7515,7517,7519,7523,7526,7530,7533,7534,7535,7539,7542,7543,7544,7548,7549,7550,7553,7555,7559,7562,7566,7569,7570,7571,7576,7580,7583,7584,7585,7586,7590,7594,7597,7598,7599,7602,7606,7609,7610,7611,7616,7620,7623,7624,7625,7626,7630,7634,7637,7638,7639,7642,7646,7649,7650,7651,7655,7659,7662,7663,7664,7668,7671,7672,7677,7680,7681,7685,7690,7693,7694,7695,7697,7699,7707,7708,7710,7714,7716,7719,7720,7724,7727,7728,7731,7735,7738,7741,7742,7744,7746,7749,7750,7752,7753,7755,7756,7759,7764,7766,7770,7773,7776,7777,7780,7784,7787,7790,7791,7793,7795,7798,7799,7802,7803,7806,7807,7809,7810,7813,7819,7822,7823,7824,7828,7831,7834,7835,7836,7839,7842,7843,7847,7849,7852,7856,7859,7860,7865,7868,7869,7870,7875,7879,7882,7883,7884,7891,7892,7893,7898,7899,7902,7903,7910,7913,7914,7915,7918,7919,7924,7926,7927,7930,7931,7935,7938,7939,7940,7944,7946,7947,7948,7951,7952,7956,7959,7960,7961,7965,7967,7969,7970,7973,7974,7981,7982,7983,7988,7989,7992,7993,8000,8003,8004,8005,8008,8009,8014,8016,8017,8020,8021,8025,8028,8029,8030,8034,8036,8037,8038,8041,8042,8046,8049,8050,8051,8055,8057,8059,8060,8063,8064,8069,8070,8074,8077,8078,8079,8084,8085,8090,8091,8093,8098,8099,8106,8109,8110,8111,8114,8115,8116,8121,8122,8126,8127,8128,8133,8134,8138,8141,8142,8143,8148,8149,8153,8156,8157,8158,8163,8164,8166,8172,8174,8177,8178,8183,8185,8190,8191,8193,8200,8201,8202,8207,8208,8211,8212,8217,8218,8221,8223,8226,8227,8229,8232,8234,8239,8240,8243,8245,8248,8249,8251,8254,8256,8261,8262,8264,8268,8270,8274,8277,8280,8281,8283,8285,8288,8289,8291,8292,8295,8296,8300,8303,8304,8309,8310,8311,8315,8316,8317,8320,8321,8324,8325,8328,8329,8332,8333,8334,8337,8340,8345,8346,8347,8352,8353,8354,8359,8360,8361,8366,8367,8368,8372,8374,8377,8383,8384,8385,8387,8395,8396,8397,8398,8400,8404,8407,8410,8411,8415,8416,8419,8420,8422,8423,8424,8425,8429,8431,8435,8438,8441,8444,8445,8446,8450,8451,8457,8460,8461,8462,8465,8468,8469,8472,8476,8477,8478,8481,8486,8489,8490,8491,8492,8496,8499,8500,8501,8502,8505,8509,8514,8517,8518,8519,8522,8524,8529,8531,8532,8537,8540,8541,8542,8545,8549,8552,8553,8554,8555,8556,8560,8563,8566,8567,8572,8575,8576,8577,8580,8584,8587,8588,8589,8593,8596,8597,8598,8601,8605,8607,8608,8612,8613,8616,8617,8618,8621,8626,8629,8630,8631,8632,8636,8639,8640,8643,8644,8647,8650,8654,8657,8660,8661,8663,8665,8668,8669,8671,8672,8675,8676,8680,8685,8688,8689,8690,8693,8695,8700,8702,8703,8708,8711,8712,8713,8716,8720,8723,8724,8725,8726,8727,8731,8734,8737,8738,8741,8745,8749,8751,8752,8755,8760,8763,8764,8765,8766,8770,8773,8774,8775,8779,8782,8783,8787,8791,8794,8795,8797,8798,8802,8806,8809,8810,8811,8812,8817,8820,8822,8826,8829,8830,8831,8835,8838,8839,8840,8841,8845,8848,8849,8850,8854,8855,8860,8864,8867,8868,8869,8870,8873,8877,8881,8883,8884,8887,8890,8891,8895,8898,8899,8900,8904,8907,8908,8909,8913,8916,8917,8921,8925,8928,8930,8931,8935,8938,8940,8942,8946,8949,8952,8953,8955,8957,8958,8961,8962,8965,8966,8968,8973,8976,8977,8979,8984,8987,8990,8991,8993,8998,9001,9004,9005,9007,9012,9013,9018,9019,9023,9028,9031,9032,9033,9037,9040,9041,9042,9046,9049,9050,9054,9058,9060,9061,9065,9067,9068,9073,9075,9079,9080,9084,9085,9089,9094,9097,9098,9099,9102,9103,9104,9105,9109,9114,9117,9118,9119,9120,9123,9128,9131,9134,9135,9137,9142,9146,9149,9150,9151,9155,9156,9161,9165,9168,9169,9170,9174,9178,9181,9182,9183,9187,9190,9193,9198,9201,9202,9203,9207,9210,9211,9212,9213,9217,9222,9225,9226,9227,9229,9234,9235,9239,9244,9247,9248,9249,9251,9256,9257,9261,9265,9267,9269,9271,9273,9275,9277,9282,9285,9288,9289,9291,9296,9297,9298,9301,9305,9308,9309,9310,9313,9315,9319,9323,9326,9327,9328,9332,9337,9340,9341,9342,9346,9349,9350,9351,9355,9359,9364,9367,9370,9371,9373,9378,9380,9381,9384,9387,9388,9391,9393,9397,9401,9404,9405,9406,9409,9411,9415,9419,9422,9423,9424,9429,9431,9432,9435,9438,9439,9442,9444,9448,9452,9455,9456,9457,9460,9462,9466,9470,9473,9474,9475,9478,9480,9484,9488,9491,9492,9493,9497,9500,9501,9505,9509,9512,9514,9515,9519,9522,9524,9526,9530,9533,9536,9537,9539,9541,9542,9545,9546,9549,9550,9552,9557,9560,9561,9563,9568,9571,9574,9575,9577,9586,9589,9590,9591,9595,9598,9599,9600,9604,9605,9610,9613,9616,9617,9619,9624,9628,9631,9634,9635,9637,9638,9639,9643,9646,9647,9651,9655,9659,9662,9665,9666,9668,9672,9675,9676,9677,9680,9685,9688,9689,9690,9694,9697,9698,9699,9703,9705,9706,9710,9712,9713,9718,9720,9724,9725,9729,9734,9737,9738,9739,9740,9743,9748,9751,9754,9755,9757,9762,9766,9769,9770,9771,9776,9780,9783,9784,9785,9789,9790,9794,9797,9800,9805,9808,9809,9810,9814,9817,9818,9819,9820,9824,9827,9832,9835,9836,9837,9841,9844,9845,9846,9850,9854,9856,9858,9860,9862,9864,9866,9870,9872,9873,9876,9878,9882,9887,9890,9891,9892,9896,9899,9900,9901,9904,9909,9912,9915,9916,9918,9923,9925,9926,9929,9932,9933,9936,9938,9942,9946,9949,9950,9951,9954,9956,9960,9964,9967,9968,9969,9974,9976,9977,9980,9983,9984,9987,9989,9993,9997,10000,10001,10002,10005,10007,10011,10015,10018,10019,10020,10023,10025,10029,10033,10036,10037,10038,10042,10045,10046,10050,10054,10057,10059,10060,10064,10067,10069,10071,10075,10078,10081,10082,10084,10086,10087,10090,10091,10094,10095,10097,10102,10105,10106,10108,10111,10116,10119,10120,10124,10128,10131,10133,10135,10139,10142,10144,10145,10147,10151,10154,10157,10158,10160,10162,10163,10166,10167,10170,10171,10173,10177,10181,10184,10185,10186,10187,10192,10197,10200,10201,10202,10204,10208,10209,10210,10213,10216,10217,10219,10222,10226,10229,10230,10231,10233,10235,10237,10240,10242,10244,10246,10248,10250,10254,10259,10262,10263,10264,10266,10272,10275,10278,10279,10281,10283,10285,10286,10290,10293,10294,10298,10299,10304,10306,10307,10311,10313,10314,10316,10317,10320,10325,10328,10329,10334,10338,10341,10344,10346,10350,10352,10358,10359,10361,10366,10367,10369,10373,10376,10380,10381,10382,10387,10390,10391,10393,10396,10399,10400,10405,10407,10408,10412,10415,10416,10419,10420,10423,10427,10429,10433,10435,10439,10444,10446,10447,10452,10454,10456,10458,10461,10465,10467,10472,10473,10475,10479,10481,10483,10488,10490,10491,10494,10498,10500,10503,10507,10510,10515,10520,10523,10524,10525,10527,10531,10532,10533,10536,10539,10540,10544,10547,10550,10551,10553,10556,10557,10560,10562,10566,10571,10574,10575,10576,10578,10583,10588,10591,10592,10593,10595,10599,10602,10605,10606,10608,10612,10613,10616,10617,10618,10623,10625,10629,10632,10633,10634,10638,10641,10642,10643,10644,10648,10651,10652,10653,10657,10661,10663,10664,10667,10670,10671,10675,10678,10679,10680,10684,10687,10688,10689,10693,10696,10697,10701,10705,10708,10710,10711,10715,10718,10720,10722,10726,10729,10732,10733,10735,10737,10738,10741,10742,10745,10746,10748,10753,10756,10757,10759,10763,10765,10767,10771,10776,10779,10780,10781,10783,10787,10788,10789,10792,10795,10796,10799,10801,10805,10809,10812,10813,10814,10818,10823,10826,10827,10828,10830,10834,10837,10840,10841,10843,10845,10846,10848,10849,10851,10857,10860,10863,10864,10866,10870,10873,10874,10875,10877,10878,10882,10885,10886,10890,10891,10896,10898,10899,10903,10905,10906,10908,10909,10912,10917,10920,10921,10926,10930,10933,10936,10938,10942,10943,10944,10948,10950,10956,10957,10959,10964,10965,10967,10971,10974,10979,10982,10983,10985,10988,10991,10992,10997,10999,11000,11004,11007,11008,11011,11012,11015,11019,11021,11025,11027,11031,11036,11038,11039,11044,11046,11048,11050,11053,11057,11059,11064,11065,11067,11071,11073,11075,11080,11082,11083,11086,11090,11092,11095,11099,11102,11103,11106,11112,11115,11116,11117,11119,11123,11124,11125,11128,11129,11133,11136,11137,11141,11142,11143,11146,11147,11148,11151,11155,11156,11157,11161,11164,11165,11168,11169,11170,11173,11176,11179,11183,11186,11189,11190,11192,11194,11197,11198,11200,11201,11204,11205,11209,11212,11213,11216,11219,11225,11228,11229,11231,11235,11238,11239,11241,11242,11247,11250,11251,11253,11260,11264,11267,11268,11269,11272,11276,11279,11280,11281,11284,11289,11292,11293,11294,11296,11303,11304,11305,11307,11312,11315,11316,11320,11325,11326,11328,11332,11335,11338,11339,11342,11343,11345,11348,11349,11354,11356,11357,11362,11365,11366,11368,11374,11375,11378,11379,11383,11384,11385,11390,11393,11394,11398,11399,11403,11406,11408,11411,11412,11415,11416,11420,11424,11427,11428,11429,11433,11436,11437,11438,11441,11445,11448,11451,11454,11455,11459,11461,11462,11466,11469,11472,11473,11475,11477,11480,11481,11483,11484,11487,11488,11492,11495,11496,11497,11500,11505,11508,11509,11510,11514,11519,11521,11522,11527,11530,11531,11532,11533,11537,11538,11541,11542,11543,11546,11549,11550,11554,11556,11557,11558,11563,11566,11567,11568,11569,11573,11574,11577,11578,11579,11586,11589,11590,11591,11592,11594,11598,11601,11604,11605,11607,11609,11612,11613,11615,11616,11619,11620,11624,11627,11628,11629,11632,11636,11639,11642,11643,11646,11651,11654,11655,11659,11663,11666,11668,11669,11673,11676,11678,11680,11684,11687,11690,11691,11693,11695,11696,11699,11700,11703,11704,11706,11707,11710,11716,11719,11720,11721,11722,11726,11727,11728,11733,11736,11737,11738,11741,11745,11748,11749,11750,11751,11755,11760,11763,11764,11765,11766,11772,11775,11776,11777,11782,11785,11786,11787,11793,11797,11800,11801,11802,11803,11810,11814,11817,11818,11819,11820,11821,11825,11828,11832,11835,11836,11837,11839,11841,11842,11844,11845,11847,11848,11851,11859,11862,11863,11864,11866,11872,11875,11876,11877,11879,11886,11889,11890,11891,11893,11899,11902,11903,11904,11906,11912,11915,11916,11917,11919,11923,11924,11925,11930,11933,11934,11935,11938,11942,11945,11946,11947,11948,11953,11956,11957,11958,11967,11971,11974,11975,11976,11977,11979,11985,11989,11992,11993,11994,11995,11997,12004,12007,12008,12009,12011,12016,12017,12018,12023,12026,12027,12028,12031,12035,12038,12039,12040,12041,12046,12050,12053,12054,12055,12056,12059,12063,12067,12070,12071,12072,12073,12074,12080,12084,12087,12088,12089,12090,12092,12098,12101,12102,12103,12105,12109,12112,12113,12117,12121,12124,12125,12129,12133,12136,12138,12142,12146,12149,12150,12151,12152,12156,12159,12161,12165,12168,12169,12170,12174,12177,12180,12181,12183,12185,12186,12189,12190,12193,12194,12196,12200,12203,12207,12210,12211,12212,12214,12216,12217,12220,12221,12224,12225,12227,12232,12233,12234,12239,12242,12243,12244,12247,12251,12254,12255,12256,12257,12262,12266,12269,12270,12271,12272,12275,12279,12283,12286,12287,12288,12289,12290,12296,12300,12303,12304,12305,12306,12308,12314,12317,12318,12319,12321,12325,12328,12332,12335,12336,12337,12339,12343,12346,12349,12350,12352,12356,12359,12360,12364,12368,12371,12372,12373,12377,12380,12381,12385,12389,12392,12393,12397,12401,12404,12406,12410,12414,12417,12418,12419,12420,12424,12427,12429,12433,12436,12437,12438,12442,12445,12448,12449,12451,12453,12454,12457,12458,12461,12462,12464,12468,12471,12475,12478,12479,12480,12482,12484,12485,12488,12489,12492,12493,12495,12496,12499,12503,12506,12509,12510,12513,12514,12517,12522,12525,12526,12527,12531,12534,12537,12538,12540,12542,12543,12545,12546,12547,12550,12554,12557,12560,12561,12563,12565,12568,12569,12571,12572,12575,12576,12580,12583,12584,12587,12591,12594,12595,12596,12599,12605,12608,12609,12610,12612,12617,12621,12624,12625,12627,12629,12635,12636,12642,12643,12645,12651,12654,12655,12656,12658,12659,12662,12667,12670,12673,12674,12679,12681,12682,12683,12687,12688,12691,12692,12696,12699,12701,12704,12705,12710,12713,12714,12715,12716,12719,12723,12726,12729,12730,12733,12734,12737,12741,12743,12744,12747,12748,12749,12752,12757,12760,12762,12767,12770,12773,12774,12776,12778,12779,12781,12782,12784,12785,12789,12792,12793,12797,12801,12804,12807,12810,12812,12815,12816,12819,12820,12824,12825,12829,12832,12835,12836,12838,12840,12841,12844,12845,12848,12849,12851,12855,12856,12860,12863,12866,12867,12869,12871,12872,12875,12876,12879,12880,12882,12886,12889,12892,12893,12895,12897,12898,12901,12902,12905,12906,12908,12909,12912,12917,12919,12920,12927,12930,12934,12937,12938,12941,12942,12945,12946,12951,12954,12955,12957,12960,12962,12965,12966,12967,12968,12972,12973,12974,12978,12979,12980,12983,12984,12988,12991,12992,12993,12997,13000,13001,13005,13009,13012,13014,13018,13019,13020,13024,13027,13030,13031,13033,13035,13036,13039,13040,13043,13044,13046,13050,13051,13056,13059,13060,13064,13065,13066,13071,13072,13074,13085,13086,13087,13089,13095,13096,13097,13099,13105,13106,13107,13109,13115,13116,13117,13119,13125,13126,13127,13129,13135,13138,13139,13144,13147,13148,13149,13153,13156,13157,13158,13162,13165,13168,13169,13171,13173,13176,13177,13179,13180,13183,13184,13188,13191,13192,13196,13197,13199,13204,13207,13208,13213,13216,13217,13218,13222,13225,13226,13227,13231,13234,13237,13238,13240,13242,13245,13246,13248,13249,13252,13253
-----computeFrom-----
246,247
246,248
252,253
252,254
272,273
272,274
279,280
279,281
287,288
287,289
311,312
311,313
341,342
341,343
343,344
343,345
350,351
350,352
361,362
361,363
395,396
395,397
400,401
400,402
402,403
402,404
410,411
410,412
435,436
435,437
447,448
447,449
480,481
480,482
483,484
483,485
495,496
495,497
497,498
497,499
502,503
502,504
510,511
510,512
546,547
546,548
606,607
606,608
623,624
623,625
633,634
633,635
656,657
656,658
664,665
664,666
666,667
666,668
686,687
686,688
714,715
714,716
729,730
729,731
730,731
730,732
737,738
737,739
771,772
771,773
784,785
784,786
785,786
785,787
786,787
786,788
793,794
793,795
802,803
802,804
810,811
810,812
815,816
815,817
830,831
830,832
845,846
845,847
885,886
885,887
895,896
895,897
903,904
903,905
910,911
910,912
934,935
934,936
942,943
942,944
952,953
952,954
974,975
974,976
1019,1020
1019,1021
1034,1035
1034,1036
1042,1043
1042,1044
1077,1078
1077,1079
1079,1080
1079,1081
1090,1091
1090,1092
1092,1093
1092,1094
1100,1101
1100,1102
1111,1112
1111,1113
1119,1120
1119,1121
1120,1121
1120,1122
1127,1128
1127,1129
1161,1162
1161,1163
1172,1173
1172,1174
1173,1174
1173,1175
1181,1182
1181,1183
1182,1183
1182,1184
1191,1192
1191,1193
1225,1226
1225,1227
1246,1247
1246,1248
1274,1275
1274,1276
1284,1285
1284,1286
1308,1309
1308,1310
1324,1325
1324,1326
1336,1337
1336,1338
1338,1339
1338,1340
1339,1340
1339,1341
1340,1341
1340,1342
1342,1343
1342,1344
1352,1353
1352,1354
1362,1363
1362,1364
1372,1373
1372,1374
1382,1383
1382,1384
1396,1397
1396,1398
1407,1408
1407,1409
1421,1422
1421,1423
1451,1452
1451,1453
1516,1517
1516,1518
1521,1522
1521,1523
1522,1523
1522,1524
1532,1533
1532,1534
1540,1541
1540,1542
1541,1542
1541,1543
1542,1543
1542,1544
1543,1544
1543,1545
1550,1551
1550,1552
1557,1558
1557,1559
1564,1565
1564,1566
1614,1615
1614,1616
1619,1620
1619,1621
1624,1625
1624,1626
1636,1637
1636,1638
1648,1649
1648,1650
1657,1658
1657,1659
1688,1689
1688,1690
1705,1706
1705,1707
1706,1707
1706,1708
1731,1732
1731,1733
1843,1844
1843,1845
1844,1845
1844,1846
1845,1846
1845,1847
1866,1867
1866,1868
1875,1876
1875,1877
1891,1892
1891,1893
1899,1900
1899,1901
1911,1912
1911,1913
1914,1915
1914,1916
1951,1952
1951,1953
1976,1977
1976,1978
2011,2012
2011,2013
2021,2022
2021,2023
2031,2032
2031,2033
2044,2045
2044,2046
2046,2047
2046,2048
2057,2058
2057,2059
2065,2066
2065,2067
2070,2071
2070,2072
2072,2073
2072,2074
2087,2088
2087,2089
2088,2089
2088,2090
2099,2100
2099,2101
2100,2101
2100,2102
2101,2102
2101,2103
2102,2103
2102,2104
2104,2105
2104,2106
2114,2115
2114,2116
2124,2125
2124,2126
2134,2135
2134,2136
2144,2145
2144,2146
2154,2155
2154,2156
2163,2164
2163,2165
2165,2166
2165,2167
2166,2167
2166,2168
2167,2168
2167,2169
2168,2169
2168,2170
2169,2170
2169,2171
2170,2171
2170,2172
2171,2172
2171,2173
2173,2174
2173,2175
2183,2184
2183,2185
2193,2194
2193,2195
2203,2204
2203,2205
2213,2214
2213,2215
2223,2224
2223,2225
2233,2234
2233,2235
2243,2244
2243,2245
2253,2254
2253,2255
2291,2292
2291,2293
2297,2298
2297,2299
2314,2315
2314,2316
2316,2317
2316,2318
2324,2325
2324,2326
2326,2327
2326,2328
2336,2337
2336,2338
2412,2413
2412,2414
2414,2415
2414,2416
2415,2416
2415,2417
2416,2417
2416,2418
2417,2418
2417,2419
2419,2420
2419,2421
2429,2430
2429,2431
2439,2440
2439,2441
2449,2450
2449,2451
2459,2460
2459,2461
2469,2470
2469,2471
2488,2489
2488,2490
2489,2490
2489,2491
2496,2497
2496,2498
2502,2503
2502,2504
2509,2510
2509,2511
2517,2518
2517,2519
2528,2529
2528,2530
2534,2535
2534,2536
2540,2541
2540,2542
2559,2560
2559,2561
2561,2562
2561,2563
2571,2572
2571,2573
2590,2591
2590,2592
2591,2592
2591,2593
2611,2612
2611,2613
2612,2613
2612,2614
2626,2627
2626,2628
2641,2642
2641,2643
2649,2650
2649,2651
2662,2663
2662,2664
2664,2665
2664,2666
2677,2678
2677,2679
2694,2695
2694,2696
2706,2707
2706,2708
2729,2730
2729,2731
2752,2753
2752,2754
2761,2762
2761,2763
2774,2775
2774,2776
2832,2833
2832,2834
2900,2901
2900,2902
2918,2919
2918,2920
2920,2921
2920,2922
2928,2929
2928,2930
2930,2931
2930,2932
2940,2941
2940,2942
2974,2975
2974,2976
2975,2976
2975,2977
2977,2978
2977,2979
2985,2986
2985,2987
2993,2994
2993,2995
3162,3163
3162,3164
3176,3177
3176,3178
3189,3190
3189,3191
3201,3202
3201,3203
3208,3209
3208,3210
3216,3217
3216,3218
3238,3239
3238,3240
3247,3248
3247,3249
3285,3286
3285,3287
3324,3325
3324,3326
3383,3384
3383,3385
3390,3391
3390,3392
3397,3398
3397,3399
3410,3411
3410,3412
3425,3426
3425,3427
3440,3441
3440,3442
3460,3461
3460,3462
3461,3462
3461,3463
3463,3464
3463,3465
3471,3472
3471,3473
3503,3504
3503,3505
3512,3513
3512,3514
3534,3535
3534,3536
3732,3733
3732,3734
3768,3769
3768,3770
3791,3792
3791,3793
3800,3801
3800,3802
3839,3840
3839,3841
3860,3861
3860,3862
3861,3862
3861,3863
3879,3880
3879,3881
3905,3906
3905,3907
3931,3932
3931,3933
3970,3971
3970,3972
3971,3972
3971,3973
3972,3973
3972,3974
3973,3974
3973,3975
3987,3988
3987,3989
3996,3997
3996,3998
4005,4006
4005,4007
4016,4017
4016,4018
4048,4049
4048,4050
4077,4078
4077,4079
4205,4206
4205,4207
4280,4281
4280,4282
4342,4343
4342,4344
4477,4478
4477,4479
4515,4516
4515,4517
4579,4580
4579,4581
4609,4610
4609,4611
4616,4617
4616,4618
4617,4618
4617,4619
4706,4707
4706,4708
4708,4709
4708,4710
4722,4723
4722,4724
4820,4821
4820,4822
4892,4893
4892,4894
4908,4909
4908,4910
4924,4925
4924,4926
4953,4954
4953,4955
4992,4993
4992,4994
5006,5007
5006,5008
5033,5034
5033,5035
5186,5187
5186,5188
5192,5193
5192,5194
5197,5198
5197,5199
5200,5201
5200,5202
5253,5254
5253,5255
5316,5317
5316,5318
5329,5330
5329,5331
5335,5336
5335,5337
5348,5349
5348,5350
5361,5362
5361,5363
5370,5371
5370,5372
5406,5407
5406,5408
5428,5429
5428,5430
5454,5455
5454,5456
5457,5458
5457,5459
5721,5722
5721,5723
5741,5742
5741,5743
5761,5762
5761,5763
5792,5793
5792,5794
5798,5799
5798,5800
5839,5840
5839,5841
5877,5878
5877,5879
5891,5892
5891,5893
5904,5905
5904,5906
5909,5910
5909,5911
5918,5919
5918,5920
5939,5940
5939,5941
5945,5946
5945,5947
6033,6034
6033,6035
6318,6319
6318,6320
6383,6384
6383,6385
6411,6412
6411,6413
6423,6424
6423,6425
6460,6461
6460,6462
6461,6462
6461,6463
6713,6714
6713,6715
6807,6808
6807,6809
6866,6867
6866,6868
6879,6880
6879,6881
6893,6894
6893,6895
6908,6909
6908,6910
7143,7144
7143,7145
7144,7145
7144,7146
7208,7209
7208,7210
7234,7235
7234,7236
7260,7261
7260,7262
7314,7315
7314,7316
7495,7496
7495,7497
7704,7705
7704,7706
7815,7816
7815,7817
7825,7826
7825,7827
7873,7874
7873,7875
7886,7887
7886,7888
7888,7889
7888,7890
7895,7896
7895,7897
7906,7907
7906,7908
7976,7977
7976,7978
7978,7979
7978,7980
7985,7986
7985,7987
7996,7997
7996,7998
8066,8067
8066,8068
8081,8082
8081,8083
8087,8088
8087,8089
8095,8096
8095,8097
8100,8101
8100,8102
8102,8103
8102,8104
8118,8119
8118,8120
8123,8124
8123,8125
8130,8131
8130,8132
8135,8136
8135,8137
8137,8138
8137,8139
8145,8146
8145,8147
8160,8161
8160,8162
8187,8188
8187,8189
8195,8196
8195,8197
8197,8198
8197,8199
8204,8205
8204,8206
8214,8215
8214,8216
8236,8237
8236,8238
8258,8259
8258,8260
8306,8307
8306,8308
8342,8343
8342,8344
8349,8350
8349,8351
8356,8357
8356,8358
8363,8364
8363,8365
8379,8380
8379,8381
8390,8391
8390,8392
8433,8434
8433,8435
8453,8454
8453,8455
8463,8464
8463,8465
8520,8521
8520,8522
8691,8692
8691,8693
8815,8816
8815,8817
8852,8853
8852,8854
8857,8858
8857,8859
9010,9011
9010,9012
9016,9017
9016,9018
9021,9022
9021,9023
9024,9025
9024,9026
9077,9078
9077,9079
9140,9141
9140,9142
9153,9154
9153,9155
9159,9160
9159,9161
9172,9173
9172,9174
9185,9186
9185,9187
9194,9195
9194,9196
9230,9231
9230,9232
9252,9253
9252,9254
9330,9331
9330,9332
9333,9334
9333,9335
9582,9583
9582,9584
9602,9603
9602,9604
9622,9623
9622,9624
9653,9654
9653,9655
9681,9682
9681,9683
9722,9723
9722,9724
9760,9761
9760,9762
9774,9775
9774,9776
9787,9788
9787,9789
9792,9793
9792,9794
9801,9802
9801,9803
9822,9823
9822,9824
9828,9829
9828,9830
9883,9884
9883,9885
10270,10271
10270,10272
10323,10324
10323,10325
10336,10337
10336,10338
10348,10349
10348,10350
10355,10356
10355,10357
10363,10364
10363,10365
10385,10386
10385,10387
10394,10395
10394,10396
10431,10432
10431,10433
10469,10470
10469,10471
10855,10856
10855,10857
10915,10916
10915,10917
10928,10929
10928,10930
10946,10947
10946,10948
10953,10954
10953,10955
10961,10962
10961,10963
10977,10978
10977,10979
10986,10987
10986,10988
11023,11024
11023,11025
11061,11062
11061,11063
11108,11109
11108,11110
11255,11256
11255,11257
11257,11258
11257,11259
11299,11300
11299,11301
11322,11323
11322,11324
11370,11371
11370,11372
11371,11372
11371,11373
11581,11582
11581,11583
11712,11713
11712,11714
11806,11807
11806,11808
11853,11854
11853,11855
11855,11856
11855,11857
11868,11869
11868,11870
11882,11883
11882,11884
11895,11896
11895,11897
11908,11909
11908,11910
11961,11962
11961,11963
11963,11964
11963,11965
11981,11982
11981,11983
12000,12001
12000,12002
12076,12077
12076,12078
12094,12095
12094,12096
12292,12293
12292,12294
12310,12311
12310,12312
12601,12602
12601,12603
12639,12640
12639,12641
12647,12648
12647,12649
12799,12800
12799,12801
12822,12823
12822,12824
12853,12854
12853,12855
12922,12923
12922,12924
12923,12924
12923,12925
12925,12926
12925,12927
13068,13069
13068,13070
13076,13077
13076,13078
13077,13078
13077,13079
13078,13079
13078,13080
13079,13080
13079,13081
13081,13082
13081,13083
13091,13092
13091,13093
13101,13102
13101,13103
13111,13112
13111,13113
13121,13122
13121,13123
13132,13133
13132,13134
13140,13141
13140,13142
13201,13202
13201,13203
13209,13210
13209,13211
-----guardedBy-----
313,328
318,337
353,386
356,368
416,426
438,754
442,621
441,516
444,520
517,621
505,620
563,602
562,601
636,682
689,702
833,898
937,946
1250,1293
1249,1292
1286,1306
1321,1439
1320,1438
1327,1410
1331,1414
1330,1413
1333,1417
1425,1439
1424,1438
1461,1512
1460,1511
1466,1518
1531,1797
1526,1802
1567,1605
1568,1606
1530,1828
1529,1827
1747,1797
1742,1792
1746,1796
1745,1795
1857,1969
1861,1974
1860,1973
1920,1969
1924,1974
1925,1960
1916,1962
1923,1973
1979,2049
1983,13197
2092,2358
2160,2364
2096,2407
2097,2377
2157,2340
2142,2231
2112,2201
2122,2211
2150,2342
2158,2320
2095,2406
2152,2241
2149,2341
2132,2221
2085,2310
2259,2364
2256,2340
2249,2342
2257,2320
2181,2366
2191,2344
2248,2341
2301,2358
2305,2362
2306,2377
2309,2376
2334,2366
2322,2364
2504,2536
2501,2533
2500,2532
2511,2525
2514,2521
2552,2893
2556,2897
2555,2896
2630,2647
2637,2646
2681,2836
2685,2867
2690,2845
2666,2754
2689,2866
2686,2758
2757,2771
2915,2970
2914,2969
3203,3338
3205,3308
3483,3496
3487,3501
3486,3500
3506,3666
3515,3546
3526,3725
3531,3543
3520,3666
3530,3787
3521,3667
3522,3668
3529,3786
3794,3856
3815,3843
3805,3856
3819,3847
3806,3857
3807,3858
3818,3846
3820,3848
3876,3927
3871,3922
3864,3909
3875,3926
3874,3925
3937,13033
3934,13018
3977,4020
3982,4025
3981,4042
3985,4045
3986,4046
4351,4405
4357,4400
4361,4404
4360,4403
4486,4588
4481,4583
4485,4587
4484,4586
4625,4658
4624,4661
4629,4652
4717,4726
4716,4725
4710,4728
4842,4853
4841,4852
5025,6360
5029,6364
5028,6363
5040,5150
5044,5154
5043,5153
5045,5146
6387,6401
6391,6405
6390,6404
6434,6447
6438,6451
6437,6450
6485,6557
6489,6561
6495,6552
6496,6553
6488,6560
6717,6739
6721,6743
6720,6742
6895,7091
6898,7076
6899,7077
7511,7664
7506,7659
7510,7663
7509,7662
7902,7973
7903,7919
7910,7956
7914,7960
7918,7973
7915,7961
7913,7959
7992,8063
7993,8009
8000,8046
8004,8050
8008,8063
8005,8051
8003,8049
8090,8114
8126,8141
8164,8191
8163,8190
8211,8234
8261,8270
8384,8397
8385,8398
8864,8973
8868,8977
8867,8976
8869,8900
10350,10483
10352,10454
10948,11075
10950,11046
11289,11362
11293,11428
11292,11427
11379,11412
11378,11415
11383,11406
11877,12319
11872,12475
11879,11893
11876,12479
11875,12478
11891,11904
11886,11899
11890,11903
11889,11902
11995,12319
11989,12475
11994,12480
11993,12479
11992,12478
11997,12011
12009,12103
12004,12207
12008,12211
12007,12210
12610,12656
12605,12651
12609,12655
12608,12654
12927,12957
12938,12955
12945,12965
12937,12954
12946,12966
13089,13173
13153,13165
13157,13169
13158,13184
13156,13183
13222,13234
13226,13238
13227,13253
13225,13252
-----guardedByNegation-----
353,413
347,406
636,718
637,690
689,718
736,792
741,797
742,798
734,790
743,799
833,907
937,956
1126,1179
1131,1195
1132,1196
1124,1177
1133,1197
2092,2481
2160,2475
2096,2485
2097,2486
2157,2472
2112,2447
2150,2465
2158,2473
2095,2484
2152,2457
2149,2464
2305,2386
2309,2385
2511,2536
2514,2532
2634,2655
2638,2659
2637,2658
2639,2660
2681,2893
2685,2897
2690,2880
2689,2896
2686,2898
3203,3356
3205,3367
3883,3909
3884,3910
3885,3911
5036,6243
5040,6360
5044,6364
5043,6363
5045,6252
6387,6415
6391,6419
6390,6418
7902,8063
7899,7989
7903,8009
8091,8127
8090,8148
8085,8122
8126,8148
8211,8256
8860,10177
8864,10547
8868,10551
8867,10550
8869,10186
10350,10500
10352,10510
10948,11092
10950,11102
11891,11917
11886,11912
11890,11916
11889,11915
12009,12319
12004,12475
12008,12479
12007,12478
12824,12855
-----lastLexicalUse-----
353,413
636,718
689,718
833,907
937,956
2112,2447
2150,2465
2095,2484
2092,2481
2160,2475
2157,2472
2096,2485
2097,2486
2158,2473
2152,2457
2149,2464
2305,2386
2309,2385
2511,2536
2514,2532
2637,2658
2681,2893
2685,2897
2690,2880
2689,2896
2686,2898
3205,3367
3203,3356
5040,6360
5044,6364
5043,6363
5045,6252
6387,6415
6391,6419
6390,6418
7903,8009
7902,8063
8090,8148
8126,8148
8211,8256
8864,10547
8868,10551
8867,10550
8869,10186
10352,10510
10350,10500
10948,11092
10950,11102
11891,11917
11886,11912
11890,11916
11889,11915
12004,12475
12008,12479
12007,12478
12009,12319
-----jump-----
353,413
636,718
689,718
833,907
937,956
2112,2447
2150,2465
2095,2484
2092,2481
2160,2475
2157,2472
2096,2485
2097,2486
2158,2473
2152,2457
2149,2464
2305,2386
2309,2385
2511,2536
2514,2532
2637,2658
2681,2893
2685,2897
2690,2880
2689,2896
2686,2898
3205,3367
3203,3356
5040,6360
5044,6364
5043,6363
5045,6252
6387,6415
6391,6419
6390,6418
7903,8009
7902,8063
8090,8148
8126,8148
8211,8256
8864,10547
8868,10551
8867,10550
8869,10186
10352,10510
10350,10500
10948,11092
10950,11102
11891,11917
11886,11912
11890,11916
11889,11915
12004,12475
12008,12479
12007,12478
12009,12319
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;ProblemStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;CastExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;Pointer;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;CastExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;Pointer;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;CastExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;Pointer;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;CastExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;Pointer;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;InitializerList;LiteralExpression;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;BinaryExpression;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ReturnStatement;LiteralExpression;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;UnaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;IfStatement;BinaryExpression;IdExpression;Name;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ReturnStatement;LiteralExpression;ProblemStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;UnaryExpression;UnaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;ReturnStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;IdExpression;Name;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ReturnStatement;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ArrayDeclarator;ReferenceOperator;Name;ArrayModifier;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ReturnStatement;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;UnaryExpression;FunctionCallExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ReturnStatement;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;IdExpression;Name;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;TypeIdExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ReturnStatement;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;TypeIdExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;UnaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ReturnStatement;LiteralExpression;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ProblemStatement;CompoundStatement;ProblemStatement;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;IfStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;ProblemExpression;CompoundStatement;IfStatement;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ReturnStatement;LiteralExpression;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ArrayDeclarator;ReferenceOperator;Name;ArrayModifier;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ArrayDeclarator;ReferenceOperator;Name;ArrayModifier;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ReturnStatement;LiteralExpression;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ArrayDeclarator;ReferenceOperator;Name;ArrayModifier;FieldReference;IdExpression;Name;Name;ReturnStatement;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;EqualsInitializer;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BinaryExpression;BinaryExpression;IdExpression;Name;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IfStatement;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ArrayDeclarator;ReferenceOperator;Name;ArrayModifier;FieldReference;IdExpression;Name;Name;ReturnStatement;LiteralExpression;ExpressionStatement;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;UnaryExpression;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;UnaryExpression;IdExpression;Name;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;UnaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;IfStatement;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ArrayDeclarator;Name;ArrayModifier;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ArrayDeclarator;Name;ArrayModifier;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;UnaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;IfStatement;BinaryExpression;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;UnaryExpression;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ArrayDeclarator;ReferenceOperator;Name;ArrayModifier;FieldReference;IdExpression;Name;Name;ReturnStatement;LiteralExpression;CompoundStatement;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IfStatement;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;CompoundStatement;IfStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IfStatement;BinaryExpression;UnaryExpression;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;UnaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;IfStatement;BinaryExpression;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;UnaryExpression;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;UnaryExpression;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;ProblemStatement;CompoundStatement;IfStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;IfStatement;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;IdExpression;Name;CompoundStatement;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ArrayDeclarator;ReferenceOperator;Name;ArrayModifier;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;IfStatement;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ArrayDeclarator;ReferenceOperator;Name;ArrayModifier;FieldReference;IdExpression;Name;Name;ReturnStatement;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;UnaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ArrayDeclarator;ReferenceOperator;Name;ArrayModifier;FieldReference;IdExpression;Name;Name;ReturnStatement;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ArrayDeclarator;ReferenceOperator;Name;ArrayModifier;FieldReference;IdExpression;Name;Name;ReturnStatement;LiteralExpression;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;ProblemStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ArrayDeclarator;ReferenceOperator;Name;ArrayModifier;FieldReference;IdExpression;Name;Name;ReturnStatement;LiteralExpression;IfStatement;UnaryExpression;BinaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;NullStatement;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ArrayDeclarator;Name;ArrayModifier;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IfStatement;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;IfStatement;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IfStatement;FieldReference;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ArrayDeclarator;ReferenceOperator;Name;ArrayModifier;FieldReference;IdExpression;Name;Name;ReturnStatement;LiteralExpression;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IfStatement;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;IfStatement;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;SwitchStatement;FieldReference;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;CaseStatement;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;BreakStatement;IfStatement;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ConditionalExpression;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;BreakStatement;IfStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;BreakStatement;IfStatement;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;ProblemStatement;CompoundStatement;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;BreakStatement;IfStatement;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ArrayDeclarator;ReferenceOperator;Name;ArrayModifier;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;BreakStatement;IfStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;UnaryExpression;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;IfStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;BreakStatement;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;BreakStatement;IfStatement;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;Declarator;Pointer;Name;Declarator;Pointer;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ArrayDeclarator;ReferenceOperator;Name;ArrayModifier;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;BreakStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;IfStatement;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;BreakStatement;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;IfStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;BinaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;BinaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;IfStatement;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;BreakStatement;IfStatement;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;IfStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;UnaryExpression;UnaryExpression;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;ConditionalExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;IfStatement;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;BreakStatement;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;BreakStatement;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;IfStatement;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BreakStatement;IfStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;IfStatement;BinaryExpression;UnaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;IfStatement;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IfStatement;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;BreakStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;IfStatement;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IfStatement;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;BreakStatement;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;ConditionalExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;BreakStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;ConditionalExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ArrayDeclarator;ReferenceOperator;Name;ArrayModifier;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;BinaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;BreakStatement;IfStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BreakStatement;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;IfStatement;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IfStatement;UnaryExpression;UnaryExpression;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;IfStatement;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;BreakStatement;IfStatement;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IfStatement;FieldReference;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IfStatement;FieldReference;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IfStatement;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;ReferenceOperator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;IdExpression;Name;ProblemStatement;IfStatement;UnaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;UnaryExpression;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;UnaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;UnaryExpression;BinaryExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;CompoundStatement;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;LiteralExpression;LiteralExpression;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ConditionalExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;BreakStatement;IfStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ProblemStatement;NullStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ConditionalExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;IfStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ConditionalExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;BreakStatement;IfStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;BreakStatement;IfStatement;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;IfStatement;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;BreakStatement;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;IfStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;BinaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;BinaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;IdExpression;Name;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;IfStatement;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;BreakStatement;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;UnaryExpression;UnaryExpression;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;ConditionalExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;ConditionalExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IfStatement;IdExpression;Name;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;IfStatement;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;BreakStatement;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;IfStatement;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;IfStatement;UnaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;ProblemStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;GotoStatement;Name;BreakStatement;CaseStatement;IdExpression;Name;LabelStatement;Name;IfStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;ConditionalExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;IfStatement;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;BreakStatement;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;LiteralExpression;UnaryExpression;LiteralExpression;IfStatement;UnaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;ProblemStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;IfStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;BreakStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;BreakStatement;IfStatement;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;BreakStatement;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IfStatement;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;BreakStatement;IfStatement;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ArrayDeclarator;ReferenceOperator;Name;ArrayModifier;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BreakStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;IfStatement;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;ConditionalExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;ConditionalExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ConditionalExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;UnaryExpression;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IfStatement;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;IfStatement;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;LiteralExpression;UnaryExpression;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ConditionalExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;IfStatement;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ConditionalExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;ConditionalExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ConditionalExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;ConditionalExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;IfStatement;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;ProblemStatement;CompoundStatement;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;BreakStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FieldReference;IdExpression;Name;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;LiteralExpression;UnaryExpression;LiteralExpression;BreakStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;IfStatement;BinaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FieldReference;IdExpression;Name;Name;BreakStatement;DefaultStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ArrayDeclarator;ReferenceOperator;Name;ArrayModifier;FieldReference;IdExpression;Name;Name;ReturnStatement;LiteralExpression;IfStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;
-----ast_node-----
static int socket_process_helper(struct iax2_thread *thread){	struct sockaddr_in sin;	int res;	int updatehistory=1;	int new = NEW_PREVENT;	int dcallno = 0;	char decrypted = 0;	struct ast_iax2_full_hdr *fh = (struct ast_iax2_full_hdr *)thread->buf;	struct ast_iax2_mini_hdr *mh = (struct ast_iax2_mini_hdr *)thread->buf;	struct ast_iax2_meta_hdr *meta = (struct ast_iax2_meta_hdr *)thread->buf;	struct ast_iax2_video_hdr *vh = (struct ast_iax2_video_hdr *)thread->buf;	struct iax_frame *fr;	struct iax_frame *cur;	struct ast_frame f = { 0, };	struct ast_channel *c = NULL;	struct iax2_dpcache *dp;	struct iax2_peer *peer;	struct iax_ies ies;	struct iax_ie_data ied0, ied1;	iax2_format format;	int fd;	int exists;	int minivid = 0;	char empty[32]="";		/* Safety measure */	struct iax_frame *duped_fr;	char host_pref_buf[128];	char caller_pref_buf[128];	struct ast_codec_pref pref;	char *using_prefs = "mine";	/* allocate an iax_frame with 4096 bytes of data buffer */	fr = ast_alloca(sizeof(*fr) + 4096);	memset(fr, 0, sizeof(*fr));	fr->afdatalen = 4096; /* From ast_alloca() above */	/* Copy frequently used parameters to the stack */	res = thread->buf_len;	fd = thread->iofd;	memcpy(&sin, &thread->iosin, sizeof(sin));	if (res < sizeof(*mh)) {		ast_log(LOG_WARNING, "midget packet received (%d of %d min)\n", res, (int) sizeof(*mh));		return 1;	}	if ((vh->zeros == 0) && (ntohs(vh->callno) & 0x8000)) {		if (res < sizeof(*vh)) {			ast_log(LOG_WARNING, "Rejecting packet from '%s.%d' that is flagged as a video frame but is too short\n", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));			return 1;		}		/* This is a video frame, get call number */		fr->callno = find_callno(ntohs(vh->callno) & ~0x8000, dcallno, &sin, new, fd, 0);		minivid = 1;	} else if ((meta->zeros == 0) && !(ntohs(meta->metacmd) & 0x8000))		return socket_process_meta(res, meta, &sin, fd, fr);#ifdef DEBUG_SUPPORT	if (res >= sizeof(*fh))		iax_outputframe(NULL, fh, 1, &sin, res - sizeof(*fh));#endif	if (ntohs(mh->callno) & IAX_FLAG_FULL) {		if (res < sizeof(*fh)) {			ast_log(LOG_WARNING, "Rejecting packet from '%s.%d' that is flagged as a full frame but is too short\n", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));			return 1;		}		/* Get the destination call number */		dcallno = ntohs(fh->dcallno) & ~IAX_FLAG_RETRANS;		/* check to make sure this full frame isn't encrypted before we attempt 		 * to look inside of it. If it is encrypted, decrypt it first. Its ok if the		 * callno is not found here, that just means one hasn't been allocated for		 * this connection yet. */		if ((dcallno != 1) && (fr->callno = find_callno(ntohs(mh->callno) & ~IAX_FLAG_FULL, dcallno, &sin, NEW_PREVENT, fd, 1))) {			ast_mutex_lock(&iaxsl[fr->callno]);			if (iaxs[fr->callno] && ast_test_flag64(iaxs[fr->callno], IAX_ENCRYPTED)) {				if (decrypt_frame(fr->callno, fh, &f, &res)) {					ast_log(LOG_NOTICE, "Packet Decrypt Failed!\n");					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}				decrypted = 1;			}			ast_mutex_unlock(&iaxsl[fr->callno]);		}		/* Retrieve the type and subclass */		f.frametype = fh->type;		if (f.frametype == AST_FRAME_VIDEO) {			ast_format_from_old_bitfield(&f.subclass.format, (uncompress_subclass(fh->csub & ~0x40)));			if ((fh->csub >> 6) & 0x1) {				ast_format_set_video_mark(&f.subclass.format);			}		} else if (f.frametype == AST_FRAME_VOICE) {			ast_format_from_old_bitfield(&f.subclass.format, uncompress_subclass(fh->csub));		} else {			f.subclass.integer = uncompress_subclass(fh->csub);		}		/* Deal with POKE/PONG without allocating a callno */		if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_POKE) {			/* Reply back with a PONG, but don't care about the result. */			send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_PONG, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			return 1;		} else if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_ACK && dcallno == 1) {			/* Ignore */			return 1;		}		f.datalen = res - sizeof(*fh);		if (f.datalen) {			if (f.frametype == AST_FRAME_IAX) {				if (iax_parse_ies(&ies, thread->buf + sizeof(struct ast_iax2_full_hdr), f.datalen)) {					ast_log(LOG_WARNING, "Undecodable frame received from '%s'\n", ast_inet_ntoa(sin.sin_addr));					ast_variables_destroy(ies.vars);					return 1;				}				f.data.ptr = NULL;				f.datalen = 0;			} else {				f.data.ptr = thread->buf + sizeof(struct ast_iax2_full_hdr);				memset(&ies, 0, sizeof(ies));			}		} else {			if (f.frametype == AST_FRAME_IAX)				f.data.ptr = NULL;			else				f.data.ptr = empty;			memset(&ies, 0, sizeof(ies));		}		if (!dcallno && iax2_allow_new(f.frametype, f.subclass.integer, 1)) {			/* only set NEW_ALLOW if calltoken checks out */			if (handle_call_token(fh, &ies, &sin, fd)) {				ast_variables_destroy(ies.vars);				return 1;			}			if (ies.calltoken && ies.calltokendata) {				/* if we've gotten this far, and the calltoken ie data exists,				 * then calltoken validation _MUST_ have taken place.  If calltoken				 * data is provided, it is always validated reguardless of any				 * calltokenoptional or requirecalltoken options */				new = NEW_ALLOW_CALLTOKEN_VALIDATED;			} else {				new = NEW_ALLOW;			}		}	} else {		/* Don't know anything about it yet */		f.frametype = AST_FRAME_NULL;		f.subclass.integer = 0;		memset(&ies, 0, sizeof(ies));	}	if (!fr->callno) {		int check_dcallno = 0;		/*		 * We enforce accurate destination call numbers for ACKs.  This forces the other		 * end to know the destination call number before call setup can complete.		 *		 * Discussed in the following thread:		 *    http://lists.digium.com/pipermail/asterisk-dev/2008-May/033217.html 		 */		if ((ntohs(mh->callno) & IAX_FLAG_FULL) && ((f.frametype == AST_FRAME_IAX) && (f.subclass.integer == IAX_COMMAND_ACK))) {			check_dcallno = 1;		}		if (!(fr->callno = find_callno(ntohs(mh->callno) & ~IAX_FLAG_FULL, dcallno, &sin, new, fd, check_dcallno))) {			if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_NEW) {				send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REJECT, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			} else if (f.frametype == AST_FRAME_IAX && (f.subclass.integer == IAX_COMMAND_REGREQ || f.subclass.integer == IAX_COMMAND_REGREL)) {				send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REGREJ, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			}			ast_variables_destroy(ies.vars);			return 1;		}	}	if (fr->callno > 0) {		struct ast_callid *mount_callid;		ast_mutex_lock(&iaxsl[fr->callno]);		if (iaxs[fr->callno] && ((mount_callid = iax_pvt_callid_get(fr->callno)))) {			/* Bind to thread */			ast_callid_threadassoc_add(mount_callid);			ast_callid_unref(mount_callid);		}	}	if (!fr->callno || !iaxs[fr->callno]) {		/* A call arrived for a nonexistent destination.  Unless it's an "inval"		   frame, reply with an inval */		if (ntohs(mh->callno) & IAX_FLAG_FULL) {			/* We can only raw hangup control frames */			if (((f.subclass.integer != IAX_COMMAND_INVAL) &&				 (f.subclass.integer != IAX_COMMAND_TXCNT) &&				 (f.subclass.integer != IAX_COMMAND_TXACC) &&				 (f.subclass.integer != IAX_COMMAND_FWDOWNL))||			    (f.frametype != AST_FRAME_IAX))				raw_hangup(&sin, ntohs(fh->dcallno) & ~IAX_FLAG_RETRANS, ntohs(mh->callno) & ~IAX_FLAG_FULL,				fd);		}		if (fr->callno > 0) 			ast_mutex_unlock(&iaxsl[fr->callno]);		ast_variables_destroy(ies.vars);		return 1;	}	if (ast_test_flag64(iaxs[fr->callno], IAX_ENCRYPTED) && !decrypted) {		if (decrypt_frame(fr->callno, fh, &f, &res)) {			ast_log(LOG_NOTICE, "Packet Decrypt Failed!\n");			ast_variables_destroy(ies.vars);			ast_mutex_unlock(&iaxsl[fr->callno]);			return 1;		}		decrypted = 1;	}#ifdef DEBUG_SUPPORT	if (decrypted) {		iax_outputframe(NULL, fh, 3, &sin, res - sizeof(*fh));	}#endif	if (iaxs[fr->callno]->owner && fh->type == AST_FRAME_IAX &&			(fh->csub == IAX_COMMAND_HANGUP			|| fh->csub == IAX_COMMAND_REJECT			|| fh->csub == IAX_COMMAND_REGREJ			|| fh->csub == IAX_COMMAND_TXREJ)) {		struct ast_control_pvt_cause_code *cause_code;		int data_size = sizeof(*cause_code);		char subclass[40] = "";		/* get subclass text */		iax_frame_subclass2str(fh->csub, subclass, sizeof(subclass));		/* add length of "IAX2 " */		data_size += 5;		/* for IAX hangup frames, add length of () and number */		data_size += 3;		if (ies.causecode > 9) {			data_size++;		}		if (ies.causecode > 99) {			data_size++;		}		/* add length of subclass */		data_size += strlen(subclass);		cause_code = ast_alloca(data_size);		ast_copy_string(cause_code->chan_name, ast_channel_name(iaxs[fr->callno]->owner), AST_CHANNEL_NAME);		cause_code->ast_cause = ies.causecode;		snprintf(cause_code->code, data_size - sizeof(*cause_code) + 1, "IAX2 %s(%d)", subclass, ies.causecode);		iax2_lock_owner(fr->callno);		if (iaxs[fr->callno] && iaxs[fr->callno]->owner) {			ast_queue_control_data(iaxs[fr->callno]->owner, AST_CONTROL_PVT_CAUSE_CODE, cause_code, data_size);			ast_channel_hangupcause_hash_set(iaxs[fr->callno]->owner, cause_code, data_size);			ast_channel_unlock(iaxs[fr->callno]->owner);		}		if (!iaxs[fr->callno]) {			ast_variables_destroy(ies.vars);			ast_mutex_unlock(&iaxsl[fr->callno]);			return 1;		}	}	/* count this frame */	iaxs[fr->callno]->frames_received++;	if (!inaddrcmp(&sin, &iaxs[fr->callno]->addr) && !minivid &&		f.subclass.integer != IAX_COMMAND_TXCNT &&		/* for attended transfer */		f.subclass.integer != IAX_COMMAND_TXACC) {		/* for attended transfer */		unsigned short new_peercallno;		new_peercallno = (unsigned short) (ntohs(mh->callno) & ~IAX_FLAG_FULL);		if (new_peercallno && new_peercallno != iaxs[fr->callno]->peercallno) {			if (iaxs[fr->callno]->peercallno) {				remove_by_peercallno(iaxs[fr->callno]);			}			iaxs[fr->callno]->peercallno = new_peercallno;			store_by_peercallno(iaxs[fr->callno]);		}	}	if (ntohs(mh->callno) & IAX_FLAG_FULL) {		if (iaxdebug)			ast_debug(1, "Received packet %d, (%d, %u)\n", fh->oseqno, f.frametype, f.subclass.integer);		/* Check if it's out of order (and not an ACK or INVAL) */		fr->oseqno = fh->oseqno;		fr->iseqno = fh->iseqno;		fr->ts = ntohl(fh->ts);#ifdef IAXTESTS		if (test_resync) {			ast_debug(1, "Simulating frame ts resync, was %u now %u\n", fr->ts, fr->ts + test_resync);			fr->ts += test_resync;		}#endif /* IAXTESTS */#if 0		if ( (ntohs(fh->dcallno) & IAX_FLAG_RETRANS) ||		     ( (f.frametype != AST_FRAME_VOICE) && ! (f.frametype == AST_FRAME_IAX &&								(f.subclass == IAX_COMMAND_NEW ||								 f.subclass == IAX_COMMAND_AUTHREQ ||								 f.subclass == IAX_COMMAND_ACCEPT ||								 f.subclass == IAX_COMMAND_REJECT))      ) )#endif		if ((ntohs(fh->dcallno) & IAX_FLAG_RETRANS) || (f.frametype != AST_FRAME_VOICE))			updatehistory = 0;		if ((iaxs[fr->callno]->iseqno != fr->oseqno) &&			(iaxs[fr->callno]->iseqno ||				((f.subclass.integer != IAX_COMMAND_TXCNT) &&				(f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXACC)) ||				(f.frametype != AST_FRAME_IAX))) {			if (			 ((f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_INVAL) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&			  (f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_VNAK)) ||			  (f.frametype != AST_FRAME_IAX)) {				/* If it's not an ACK packet, it's out of order. */				ast_debug(1, "Packet arrived out of order (expecting %d, got %d) (frametype = %d, subclass = %d)\n",					iaxs[fr->callno]->iseqno, fr->oseqno, f.frametype, f.subclass.integer);				/* Check to see if we need to request retransmission,				 * and take sequence number wraparound into account */				if ((unsigned char) (iaxs[fr->callno]->iseqno - fr->oseqno) < 128) {					/* If we've already seen it, ack it XXX There's a border condition here XXX */					if ((f.frametype != AST_FRAME_IAX) ||							((f.subclass.integer != IAX_COMMAND_ACK) && (f.subclass.integer != IAX_COMMAND_INVAL))) {						ast_debug(1, "Acking anyway\n");						/* XXX Maybe we should handle its ack to us, but then again, it's probably outdated anyway, and if						   we have anything to send, we'll retransmit and get an ACK back anyway XXX */						send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					}				} else {					/* Send a VNAK requesting retransmission */					iax2_vnak(fr->callno);				}				ast_variables_destroy(ies.vars);				ast_mutex_unlock(&iaxsl[fr->callno]);				return 1;			}		} else {			/* Increment unless it's an ACK or VNAK */			if (((f.subclass.integer != IAX_COMMAND_ACK) &&			    (f.subclass.integer != IAX_COMMAND_INVAL) &&			    (f.subclass.integer != IAX_COMMAND_TXCNT) &&			    (f.subclass.integer != IAX_COMMAND_TXACC) &&				(f.subclass.integer != IAX_COMMAND_VNAK)) ||			    (f.frametype != AST_FRAME_IAX))				iaxs[fr->callno]->iseqno++;		}		/* Ensure text frames are NULL-terminated */		if (f.frametype == AST_FRAME_TEXT && thread->buf[res - 1] != '\0') {			if (res < thread->buf_size)				thread->buf[res++] = '\0';			else /* Trims one character from the text message, but that's better than overwriting the end of the buffer. */				thread->buf[res - 1] = '\0';		}		/* Handle implicit ACKing unless this is an INVAL, and only if this is 		   from the real peer, not the transfer peer */		if (!inaddrcmp(&sin, &iaxs[fr->callno]->addr) &&		    ((f.subclass.integer != IAX_COMMAND_INVAL) ||		     (f.frametype != AST_FRAME_IAX))) {			unsigned char x;			int call_to_destroy;			/* First we have to qualify that the ACKed value is within our window */			if (iaxs[fr->callno]->rseqno >= iaxs[fr->callno]->oseqno || (fr->iseqno >= iaxs[fr->callno]->rseqno && fr->iseqno < iaxs[fr->callno]->oseqno))				x = fr->iseqno;			else				x = iaxs[fr->callno]->oseqno;			if ((x != iaxs[fr->callno]->oseqno) || (iaxs[fr->callno]->oseqno == fr->iseqno)) {				/* The acknowledgement is within our window.  Time to acknowledge everything				   that it says to */				for (x=iaxs[fr->callno]->rseqno; x != fr->iseqno; x++) {					/* Ack the packet with the given timestamp */					if (iaxdebug)						ast_debug(1, "Cancelling transmission of packet %d\n", x);					call_to_destroy = 0;					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* If it's our call, and our timestamp, mark -1 retries */						if (x == cur->oseqno) {							cur->retries = -1;							/* Destroy call if this is the end */							if (cur->final)								call_to_destroy = fr->callno;						}					}					if (call_to_destroy) {						if (iaxdebug)							ast_debug(1, "Really destroying %d, having been acked on final message\n", call_to_destroy);						ast_mutex_lock(&iaxsl[call_to_destroy]);						iax2_destroy(call_to_destroy);						ast_mutex_unlock(&iaxsl[call_to_destroy]);					}				}				/* Note how much we've received acknowledgement for */				if (iaxs[fr->callno])					iaxs[fr->callno]->rseqno = fr->iseqno;				else {					/* Stop processing now */					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}			} else {				ast_debug(1, "Received iseqno %d not within window %d->%d\n", fr->iseqno, iaxs[fr->callno]->rseqno, iaxs[fr->callno]->oseqno);			}		}		if (inaddrcmp(&sin, &iaxs[fr->callno]->addr) &&			((f.frametype != AST_FRAME_IAX) ||			 ((f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT)))) {			/* Only messages we accept from a transfer host are TXACC and TXCNT */			ast_variables_destroy(ies.vars);			ast_mutex_unlock(&iaxsl[fr->callno]);			return 1;		}		/* when we receive the first full frame for a new incoming channel,		   it is safe to start the PBX on the channel because we have now		   completed a 3-way handshake with the peer */		if ((f.frametype == AST_FRAME_VOICE) ||		    (f.frametype == AST_FRAME_VIDEO) ||		    (f.frametype == AST_FRAME_IAX)) {			if (ast_test_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART)) {				ast_clear_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);				if (!ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->chosenformat, NULL,						  ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED))) {					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}			}			if (ies.vars) {				struct ast_datastore *variablestore = NULL;				struct ast_variable *var, *prev = NULL;				AST_LIST_HEAD(, ast_var_t) *varlist;				iax2_lock_owner(fr->callno);				if (!iaxs[fr->callno]) {					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}				if ((c = iaxs[fr->callno]->owner)) {					varlist = ast_calloc(1, sizeof(*varlist));					variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);					if (variablestore && varlist) {						variablestore->data = varlist;						variablestore->inheritance = DATASTORE_INHERIT_FOREVER;						AST_LIST_HEAD_INIT(varlist);						ast_debug(1, "I can haz IAX vars?\n");						for (var = ies.vars; var; var = var->next) {							struct ast_var_t *newvar = ast_var_assign(var->name, var->value);							if (prev) {								ast_free(prev);							}							prev = var;							if (!newvar) {								/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");							} else {								AST_LIST_INSERT_TAIL(varlist, newvar, entries);							}						}						if (prev) {							ast_free(prev);						}						ies.vars = NULL;						ast_channel_datastore_add(c, variablestore);					} else {						ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");						if (variablestore) {							ast_datastore_free(variablestore);						}						if (varlist) {							ast_free(varlist);						}					}					ast_channel_unlock(c);				} else {					/* No channel yet, so transfer the variables directly over to the pvt,					 * for later inheritance. */					ast_debug(1, "No channel, so populating IAXVARs to the pvt, as an intermediate step.\n");					for (var = ies.vars; var && var->next; var = var->next);					if (var) {						var->next = iaxs[fr->callno]->iaxvars;						iaxs[fr->callno]->iaxvars = ies.vars;						ies.vars = NULL;					}				}			}			if (ies.vars) {				ast_debug(1, "I have IAX variables, but they were not processed\n");			}		}		/* once we receive our first IAX Full Frame that is not CallToken related, send all		 * queued signaling frames that were being held. */		if ((f.frametype == AST_FRAME_IAX) && (f.subclass.integer != IAX_COMMAND_CALLTOKEN) && iaxs[fr->callno]->hold_signaling) {			send_signaling(iaxs[fr->callno]);		}		if (f.frametype == AST_FRAME_VOICE) {			if (ast_format_to_old_bitfield(&f.subclass.format) != iaxs[fr->callno]->voiceformat) {					iaxs[fr->callno]->voiceformat = ast_format_to_old_bitfield(&f.subclass.format);					ast_debug(1, "Ooh, voice format changed to '%s'\n", ast_getformatname(&f.subclass.format));					if (iaxs[fr->callno]->owner) {						iax2_lock_owner(fr->callno);						if (iaxs[fr->callno]) {							if (iaxs[fr->callno]->owner) {								struct ast_format_cap *orignative = ast_format_cap_dup(ast_channel_nativeformats(iaxs[fr->callno]->owner));								struct ast_format_cap *native = ast_channel_nativeformats(iaxs[fr->callno]->owner);								if (orignative) {									ast_format_cap_set(native, &f.subclass.format);									if (ast_channel_readformat(iaxs[fr->callno]->owner)->id) {										ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));									}									ast_format_cap_copy(native, orignative);									ast_channel_unlock(iaxs[fr->callno]->owner);									orignative = ast_format_cap_destroy(orignative);								}							}						} else {							ast_debug(1, "Neat, somebody took away the channel at a magical time but i found it!\n");							/* Free remote variables (if any) */							if (ies.vars) {								ast_variables_destroy(ies.vars);								ast_debug(1, "I can haz iaxvars, but they is no good.  :-(\n");								ies.vars = NULL;							}							ast_mutex_unlock(&iaxsl[fr->callno]);							return 1;						}					}			}		}		if (f.frametype == AST_FRAME_VIDEO) {			if (f.subclass.format.id != ast_format_id_from_old_bitfield(iaxs[fr->callno]->videoformat)) {				ast_debug(1, "Ooh, video format changed to %s\n", ast_getformatname(&f.subclass.format));				iaxs[fr->callno]->videoformat = ast_format_to_old_bitfield(&f.subclass.format);			}		}		if (f.frametype == AST_FRAME_CONTROL && iaxs[fr->callno]->owner) {			if (f.subclass.integer == AST_CONTROL_BUSY) {				ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_BUSY);			} else if (f.subclass.integer == AST_CONTROL_CONGESTION) {				ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_CONGESTION);			}		}		if (f.frametype == AST_FRAME_IAX) {			AST_SCHED_DEL(sched, iaxs[fr->callno]->initid);			/* Handle the IAX pseudo frame itself */			if (iaxdebug)				ast_debug(1, "IAX subclass %d received\n", f.subclass.integer);                        /* Update last ts unless the frame's timestamp originated with us. */			if (iaxs[fr->callno]->last < fr->ts &&                            f.subclass.integer != IAX_COMMAND_ACK &&                            f.subclass.integer != IAX_COMMAND_PONG &&                            f.subclass.integer != IAX_COMMAND_LAGRP) {				iaxs[fr->callno]->last = fr->ts;				if (iaxdebug)					ast_debug(1, "For call=%d, set last=%d\n", fr->callno, fr->ts);			}			iaxs[fr->callno]->last_iax_message = f.subclass.integer;			if (!iaxs[fr->callno]->first_iax_message) {				iaxs[fr->callno]->first_iax_message = f.subclass.integer;			}			switch(f.subclass.integer) {			case IAX_COMMAND_ACK:				/* Do nothing */				break;			case IAX_COMMAND_QUELCH:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {				        /* Generate Manager Hold event, if necessary*/					if (iaxs[fr->callno]->owner) {						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: On\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}					ast_set_flag64(iaxs[fr->callno], IAX_QUELCH);					if (ies.musiconhold) {						iax2_lock_owner(fr->callno);						if (!iaxs[fr->callno] || !iaxs[fr->callno]->owner) {							break;						}						if (ast_bridged_channel(iaxs[fr->callno]->owner)) {							const char *moh_suggest = iaxs[fr->callno]->mohsuggest;							/*							 * We already hold the owner lock so we do not							 * need to check iaxs[fr->callno] after it returns.							 */							iax2_queue_control_data(fr->callno, AST_CONTROL_HOLD, 								S_OR(moh_suggest, NULL),								!ast_strlen_zero(moh_suggest) ? strlen(moh_suggest) + 1 : 0);						}						ast_channel_unlock(iaxs[fr->callno]->owner);					}				}				break;			case IAX_COMMAND_UNQUELCH:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {					iax2_lock_owner(fr->callno);					if (!iaxs[fr->callno]) {						break;					}					/* Generate Manager Unhold event, if necessary */					if (iaxs[fr->callno]->owner && ast_test_flag64(iaxs[fr->callno], IAX_QUELCH)) {						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: Off\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}					ast_clear_flag64(iaxs[fr->callno], IAX_QUELCH);					if (!iaxs[fr->callno]->owner) {						break;					}					if (ast_bridged_channel(iaxs[fr->callno]->owner)) {						/*						 * We already hold the owner lock so we do not						 * need to check iaxs[fr->callno] after it returns.						 */						iax2_queue_control_data(fr->callno, AST_CONTROL_UNHOLD, NULL, 0);					}					ast_channel_unlock(iaxs[fr->callno]->owner);				}				break;			case IAX_COMMAND_TXACC:				if (iaxs[fr->callno]->transferring == TRANSFER_BEGIN) {					/* Ack the packet with the given timestamp */					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* Cancel any outstanding txcnt's */						if (cur->transfer) {							cur->retries = -1;						}					}					memset(&ied1, 0, sizeof(ied1));					iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->callno);					send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREADY, 0, ied1.buf, ied1.pos, -1);					iaxs[fr->callno]->transferring = TRANSFER_READY;				}				break;			case IAX_COMMAND_NEW:				/* Ignore if it's already up */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD))					break;				if (ies.provverpres && ies.serviceident && sin.sin_addr.s_addr) {					ast_mutex_unlock(&iaxsl[fr->callno]);					check_provisioning(&sin, fd, ies.serviceident, ies.provver);					ast_mutex_lock(&iaxsl[fr->callno]);					if (!iaxs[fr->callno]) {						break;					}				}				/* If we're in trunk mode, do it now, and update the trunk number in our frame before continuing */				if (ast_test_flag64(iaxs[fr->callno], IAX_TRUNK)) {					int new_callno;					if ((new_callno = make_trunk(fr->callno, 1)) != -1)						fr->callno = new_callno;				}				/* For security, always ack immediately */				if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				if (check_access(fr->callno, &sin, &ies)) {					/* They're not allowed on */					auth_fail(fr->callno, IAX_COMMAND_REJECT);					if (authdebug)						ast_log(LOG_NOTICE, "Rejected connect attempt from %s, who was trying to reach '%s@%s'\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					break;				}				if (ast_strlen_zero(iaxs[fr->callno]->secret) && ast_test_flag64(iaxs[fr->callno], IAX_FORCE_ENCRYPT)) {					auth_fail(fr->callno, IAX_COMMAND_REJECT);					ast_log(LOG_WARNING, "Rejected connect attempt.  No secret present while force encrypt enabled.\n");					break;				}				if (strcasecmp(iaxs[fr->callno]->exten, "TBD")) {					const char *context, *exten, *cid_num;					context = ast_strdupa(iaxs[fr->callno]->context);					exten = ast_strdupa(iaxs[fr->callno]->exten);					cid_num = ast_strdupa(iaxs[fr->callno]->cid_num);					/* This might re-enter the IAX code and need the lock */					ast_mutex_unlock(&iaxsl[fr->callno]);					exists = ast_exists_extension(NULL, context, exten, 1, cid_num);					ast_mutex_lock(&iaxsl[fr->callno]);					if (!iaxs[fr->callno]) {						break;					}				} else					exists = 0;				/* Get OSP token if it does exist */				save_osptoken(fr, &ies);				if (ast_strlen_zero(iaxs[fr->callno]->secret) && ast_strlen_zero(iaxs[fr->callno]->inkeys)) {					if (strcmp(iaxs[fr->callno]->exten, "TBD") && !exists) {						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}						if (authdebug)							ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					} else {						/* Select an appropriate format */						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								using_prefs = "reqonly";							} else {								using_prefs = "disabled";							}							format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;							memset(&pref, 0, sizeof(pref));							strcpy(caller_pref_buf, "disabled");							strcpy(host_pref_buf, "disabled");						} else {							struct ast_format tmpfmt;							using_prefs = "mine";							/* If the information elements are in here... use them */							if (ies.codec_prefs)								ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);							if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {								/* If we are codec_first_choice we let the caller have the 1st shot at picking the codec.*/								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {									pref = iaxs[fr->callno]->rprefs;									using_prefs = "caller";								} else {									pref = iaxs[fr->callno]->prefs;								}							} else								pref = iaxs[fr->callno]->prefs;							format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);							ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);							ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);						}						if (!format) {							if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP))								format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;							if (!format) {								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}								if (authdebug) {									char tmp[256], tmp2[256], tmp3[256];									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}							} else {								/* Pick one... */								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))										format = 0;								} else {									if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {										using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";										memset(&pref, 0, sizeof(pref));										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);										strcpy(caller_pref_buf,"disabled");										strcpy(host_pref_buf,"disabled");									} else {										struct ast_format tmpfmt;										using_prefs = "mine";										if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {											/* Do the opposite of what we tried above. */											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);										} else /* if no codec_prefs IE do it the old way */											format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}								}								if (!format) {									char tmp[256], tmp2[256], tmp3[256];									memset(&ied0, 0, sizeof(ied0));									iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");									iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);									ast_log(LOG_ERROR, "No best format in '%s'???\n", iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));									send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);									if (!iaxs[fr->callno]) {										break;									}									if (authdebug) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}									ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);									break;								}							}						}						if (format) {							/* No authentication required, let them in */							memset(&ied1, 0, sizeof(ied1));							iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);							iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);							send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);							if (strcmp(iaxs[fr->callno]->exten, "TBD")) {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);								ast_verb(3, "Accepting UNAUTHENTICATED call from %s:\n"												"%srequested format = %s,\n"												"%srequested prefs = %s,\n"												"%sactual format = %s,\n"												"%shost prefs = %s,\n"												"%spriority = %s\n",												ast_inet_ntoa(sin.sin_addr), 												VERBOSE_PREFIX_4,												iax2_getformatname(iaxs[fr->callno]->peerformat), 												VERBOSE_PREFIX_4,												caller_pref_buf,												VERBOSE_PREFIX_4,												iax2_getformatname(format), 												VERBOSE_PREFIX_4,												host_pref_buf, 												VERBOSE_PREFIX_4,												using_prefs);								iaxs[fr->callno]->chosenformat = format;								/* Since this is a new call, we should go ahead and set the callid for it. */								iax_pvt_callid_new(fr->callno);								ast_set_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);							} else {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);								/* If this is a TBD call, we're ready but now what...  */								ast_verb(3, "Accepted unauthenticated TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							}						}					}					break;				}				if (iaxs[fr->callno]->authmethods & IAX_AUTH_MD5)					merge_encryption(iaxs[fr->callno],ies.encmethods);				else					iaxs[fr->callno]->encmethods = 0;				if (!authenticate_request(fr->callno) && iaxs[fr->callno])					ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED);				break;			case IAX_COMMAND_DPREQ:				/* Request status in the dialplan */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD) &&					!ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED) && ies.called_number) {					if (iaxcompat) {						/* Spawn a thread for the lookup */						spawn_dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num);					} else {						/* Just look it up */						dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num, 1);					}				}				break;			case IAX_COMMAND_HANGUP:				ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);				ast_debug(1, "Immediately destroying %d, having received hangup\n", fr->callno);				/* Set hangup cause according to remote and hangupsource */				if (iaxs[fr->callno]->owner) {					set_hangup_source_and_cause(fr->callno, ies.causecode);					if (!iaxs[fr->callno]) {						break;					}				}				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_REJECT:				/* Set hangup cause according to remote and hangup source */				if (iaxs[fr->callno]->owner) {					set_hangup_source_and_cause(fr->callno, ies.causecode);					if (!iaxs[fr->callno]) {						break;					}				}				if (!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)) {					if (iaxs[fr->callno]->owner && authdebug)						ast_log(LOG_WARNING, "Call rejected by %s: %s\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr),							ies.cause ? ies.cause : "<Unknown>");					ast_debug(1, "Immediately destroying %d, having received reject\n",						fr->callno);				}				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK,						       fr->ts, NULL, 0, fr->iseqno);				if (!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION))					iaxs[fr->callno]->error = EPERM;				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_TRANSFER:			{				struct ast_channel *bridged_chan;				struct ast_channel *owner;				iax2_lock_owner(fr->callno);				if (!iaxs[fr->callno]) {					/* Initiating call went away before we could transfer. */					break;				}				owner = iaxs[fr->callno]->owner;				bridged_chan = owner ? ast_bridged_channel(owner) : NULL;				if (bridged_chan && ies.called_number) {					const char *context;					context = ast_strdupa(iaxs[fr->callno]->context);					ast_channel_ref(owner);					ast_channel_ref(bridged_chan);					ast_channel_unlock(owner);					ast_mutex_unlock(&iaxsl[fr->callno]);					/* Set BLINDTRANSFER channel variables */					pbx_builtin_setvar_helper(owner, "BLINDTRANSFER", ast_channel_name(bridged_chan));					pbx_builtin_setvar_helper(bridged_chan, "BLINDTRANSFER", ast_channel_name(owner));					/* DO NOT hold any locks while calling ast_parking_ext_valid() */					if (ast_parking_ext_valid(ies.called_number, owner, context)) {						ast_debug(1, "Parking call '%s'\n", ast_channel_name(bridged_chan));						if (iax_park(bridged_chan, owner, ies.called_number, context)) {							ast_log(LOG_WARNING, "Failed to park call '%s'\n",								ast_channel_name(bridged_chan));						}					} else {						if (ast_async_goto(bridged_chan, context, ies.called_number, 1)) {							ast_log(LOG_WARNING,								"Async goto of '%s' to '%s@%s' failed\n",								ast_channel_name(bridged_chan), ies.called_number, context);						} else {							ast_debug(1, "Async goto of '%s' to '%s@%s' started\n",								ast_channel_name(bridged_chan), ies.called_number, context);						}					}					ast_channel_unref(owner);					ast_channel_unref(bridged_chan);					ast_mutex_lock(&iaxsl[fr->callno]);				} else {					ast_debug(1, "Async goto not applicable on call %d\n", fr->callno);					if (owner) {						ast_channel_unlock(owner);					}				}				break;			}			case IAX_COMMAND_ACCEPT:				/* Ignore if call is already up or needs authentication or is a TBD */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD | IAX_STATE_AUTHENTICATED))					break;				if (ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)) {					/* Send ack immediately, before we destroy */					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					iax2_destroy(fr->callno);					break;				}				if (ies.format) {					iaxs[fr->callno]->peerformat = ies.format;				} else {					if (iaxs[fr->callno]->owner)						iaxs[fr->callno]->peerformat = ast_format_cap_to_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner));					else						iaxs[fr->callno]->peerformat = iaxs[fr->callno]->capability;				}				ast_verb(3, "Call accepted by %s (format %s)\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iax2_getformatname(iaxs[fr->callno]->peerformat));				if (!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)) {					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);					if (!iaxs[fr->callno]) {						break;					}					if (authdebug) {						char tmp1[256], tmp2[256];						ast_log(LOG_NOTICE, "Rejected call to %s, format %s incompatible with our capability %s.\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),							iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));					}				} else {					ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);					iax2_lock_owner(fr->callno);					if (iaxs[fr->callno] && iaxs[fr->callno]->owner) {						char tmp[256];						/* Switch us to use a compatible format */						ast_format_cap_from_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner), iaxs[fr->callno]->peerformat);						ast_verb(3, "Format for call is %s\n", ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(iaxs[fr->callno]->owner)));						/* Setup read/write formats properly. */						if (ast_channel_writeformat(iaxs[fr->callno]->owner)->id)							ast_set_write_format(iaxs[fr->callno]->owner, ast_channel_writeformat(iaxs[fr->callno]->owner));						if (ast_channel_readformat(iaxs[fr->callno]->owner)->id)							ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));						ast_channel_unlock(iaxs[fr->callno]->owner);					}				}				if (iaxs[fr->callno]) {					AST_LIST_LOCK(&dpcache);					AST_LIST_TRAVERSE(&iaxs[fr->callno]->dpentries, dp, peer_list)						if (!(dp->flags & CACHE_FLAG_TRANSMITTED))							iax2_dprequest(dp, fr->callno);					AST_LIST_UNLOCK(&dpcache);				}				break;			case IAX_COMMAND_POKE:				/* Send back a pong packet with the original timestamp */				send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, NULL, 0, -1);				break;			case IAX_COMMAND_PING:			{				struct iax_ie_data pingied;				construct_rr(iaxs[fr->callno], &pingied);				/* Send back a pong packet with the original timestamp */				send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, pingied.buf, pingied.pos, -1);			}				break;			case IAX_COMMAND_PONG:				/* Calculate ping time */				iaxs[fr->callno]->pingtime =  calc_timestamp(iaxs[fr->callno], 0, &f) - fr->ts;				/* save RR info */				save_rr(fr, &ies);				/* Good time to write jb stats for this call */				log_jitterstats(fr->callno);				if (iaxs[fr->callno]->peerpoke) {					peer = iaxs[fr->callno]->peerpoke;					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms)) {						if (iaxs[fr->callno]->pingtime <= peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now REACHABLE! Time: %d\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Reachable\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "IAX2/%s", peer->name); /* Activate notification */						}					} else if ((peer->historicms > 0) && (peer->historicms <= peer->maxms)) {						if (iaxs[fr->callno]->pingtime > peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now TOO LAGGED (%d ms)!\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Lagged\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_UNAVAILABLE, AST_DEVSTATE_CACHABLE, "IAX2/%s", peer->name); /* Activate notification */						}					}					peer->lastms = iaxs[fr->callno]->pingtime;					if (peer->smoothing && (peer->lastms > -1))						peer->historicms = (iaxs[fr->callno]->pingtime + peer->historicms) / 2;					else if (peer->smoothing && peer->lastms < 0)						peer->historicms = (0 + peer->historicms) / 2;					else											peer->historicms = iaxs[fr->callno]->pingtime;					/* Remove scheduled iax2_poke_noanswer */					if (peer->pokeexpire > -1) {						if (!AST_SCHED_DEL(sched, peer->pokeexpire)) {							peer_unref(peer);							peer->pokeexpire = -1;						}					}					/* Schedule the next cycle */					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms))						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_peer_s, peer_ref(peer));					else						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqok, iax2_poke_peer_s, peer_ref(peer));					if (peer->pokeexpire == -1)						peer_unref(peer);					/* and finally send the ack */					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					/* And wrap up the qualify call */					iax2_destroy(fr->callno);					peer->callno = 0;					ast_debug(1, "Peer %s: got pong, lastms %d, historicms %d, maxms %d\n", peer->name, peer->lastms, peer->historicms, peer->maxms);				}				break;			case IAX_COMMAND_LAGRQ:			case IAX_COMMAND_LAGRP:				f.src = "LAGRQ";				f.mallocd = 0;				f.offset = 0;				f.samples = 0;				iax_frame_wrap(fr, &f);				if (f.subclass.integer == IAX_COMMAND_LAGRQ) {					/* Received a LAGRQ - echo back a LAGRP */					fr->af.subclass.integer = IAX_COMMAND_LAGRP;					iax2_send(iaxs[fr->callno], &fr->af, fr->ts, -1, 0, 0, 0);				} else {					/* Received LAGRP in response to our LAGRQ */					unsigned int ts;					/* This is a reply we've been given, actually measure the difference */					ts = calc_timestamp(iaxs[fr->callno], 0, &fr->af);					iaxs[fr->callno]->lag = ts - fr->ts;					if (iaxdebug)						ast_debug(1, "Peer %s lag measured as %dms\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->lag);				}				break;			case IAX_COMMAND_AUTHREQ:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)) {					ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					break;				}				if (authenticate_reply(iaxs[fr->callno], &iaxs[fr->callno]->addr, &ies, iaxs[fr->callno]->secret, iaxs[fr->callno]->outkey)) {					struct ast_frame hangup_fr = { .frametype = AST_FRAME_CONTROL,								.subclass.integer = AST_CONTROL_HANGUP,					};					ast_log(LOG_WARNING, 						"I don't know how to authenticate %s to %s\n", 						ies.username ? ies.username : "<unknown>", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr));					iax2_queue_frame(fr->callno, &hangup_fr);				}				break;			case IAX_COMMAND_AUTHREP:				/* For security, always ack immediately */				if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				/* Ignore once we've started */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)) {					ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					break;				}				if (authenticate_verify(iaxs[fr->callno], &ies)) {					if (authdebug)						ast_log(LOG_NOTICE, "Host %s failed to authenticate as %s\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->username);					memset(&ied0, 0, sizeof(ied0));					auth_fail(fr->callno, IAX_COMMAND_REJECT);					break;				}				if (strcasecmp(iaxs[fr->callno]->exten, "TBD")) {					/* This might re-enter the IAX code and need the lock */					exists = ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num);				} else					exists = 0;				if (strcmp(iaxs[fr->callno]->exten, "TBD") && !exists) {					if (authdebug)						ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);					if (!iaxs[fr->callno]) {						break;					}				} else {					/* Select an appropriate format */					if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {							using_prefs = "reqonly";						} else {							using_prefs = "disabled";						}						format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;						memset(&pref, 0, sizeof(pref));						strcpy(caller_pref_buf, "disabled");						strcpy(host_pref_buf, "disabled");					} else {						struct ast_format tmpfmt;						using_prefs = "mine";						if (ies.codec_prefs)							ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);						if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {							if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {								pref = iaxs[fr->callno]->rprefs;								using_prefs = "caller";							} else {								pref = iaxs[fr->callno]->prefs;							}						} else /* if no codec_prefs IE do it the old way */							pref = iaxs[fr->callno]->prefs;						format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);						ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);						ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);					}					if (!format) {						char tmp1[256], tmp2[256], tmp3[256];						if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {							ast_debug(1, "We don't do requested format %s, falling back to peer capability '%s'\n",								iax2_getformatname(iaxs[fr->callno]->peerformat),								iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability));							format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;						}						if (!format) {							if (authdebug) {								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n", ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));								} else {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",										ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),										iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));								}							}							memset(&ied0, 0, sizeof(ied0));							iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");							iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);							send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);							if (!iaxs[fr->callno]) {								break;							}						} else {							/* Pick one... */							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))									format = 0;							} else {								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {									using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";									memset(&pref, 0, sizeof(pref));									format = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ?										iaxs[fr->callno]->peerformat : iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									strcpy(caller_pref_buf,"disabled");									strcpy(host_pref_buf,"disabled");								} else {									struct ast_format tmpfmt;									using_prefs = "mine";									if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {										/* Do the opposite of what we tried above. */										if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {											pref = iaxs[fr->callno]->prefs;										} else {											pref = iaxs[fr->callno]->rprefs;											using_prefs = "caller";										}										format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);									} else /* if no codec_prefs IE do it the old way */										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}							}							if (!format) {								char tmp1[256], tmp2[256], tmp3[256];								ast_log(LOG_ERROR, "No best format in %s???\n",									iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));								if (authdebug) {									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}							}						}					}					if (format) {						/* Authentication received */						memset(&ied1, 0, sizeof(ied1));						iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);						iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);						send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);						if (strcmp(iaxs[fr->callno]->exten, "TBD")) {							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							ast_verb(3, "Accepting AUTHENTICATED call from %s:\n"											"%srequested format = %s,\n"											"%srequested prefs = %s,\n"											"%sactual format = %s,\n"											"%shost prefs = %s,\n"											"%spriority = %s\n", 											ast_inet_ntoa(sin.sin_addr), 											VERBOSE_PREFIX_4,											iax2_getformatname(iaxs[fr->callno]->peerformat),											VERBOSE_PREFIX_4,											caller_pref_buf,											VERBOSE_PREFIX_4,											iax2_getformatname(format),											VERBOSE_PREFIX_4,											host_pref_buf,											VERBOSE_PREFIX_4,											using_prefs);							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, format, NULL, 1)))								iax2_destroy(fr->callno);							else if (ies.vars) {								struct ast_datastore *variablestore;								struct ast_variable *var, *prev = NULL;								AST_LIST_HEAD(, ast_var_t) *varlist;								varlist = ast_calloc(1, sizeof(*varlist));								variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);								if (variablestore && varlist) {									variablestore->data = varlist;									variablestore->inheritance = DATASTORE_INHERIT_FOREVER;									AST_LIST_HEAD_INIT(varlist);									ast_debug(1, "I can haz IAX vars? w00t\n");									for (var = ies.vars; var; var = var->next) {										struct ast_var_t *newvar = ast_var_assign(var->name, var->value);										if (prev)											ast_free(prev);										prev = var;										if (!newvar) {											/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */											ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");										} else {											AST_LIST_INSERT_TAIL(varlist, newvar, entries);										}									}									if (prev)										ast_free(prev);									ies.vars = NULL;									ast_channel_datastore_add(c, variablestore);								} else {									ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									if (variablestore)										ast_datastore_free(variablestore);									if (varlist)										ast_free(varlist);								}							}						} else {							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);							/* If this is a TBD call, we're ready but now what...  */							ast_verb(3, "Accepted AUTHENTICATED TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							if (ast_test_flag64(iaxs[fr->callno], IAX_IMMEDIATE)) {								goto immediatedial;							}						}					}				}				break;			case IAX_COMMAND_DIAL:immediatedial:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD)) {					ast_clear_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);					ast_string_field_set(iaxs[fr->callno], exten, ies.called_number ? ies.called_number : "s");					if (!ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num)) {						if (authdebug)							ast_log(LOG_NOTICE, "Rejected dial attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}					} else {						char tmp[256];						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);						ast_verb(3, "Accepting DIAL from %s, formats = %s\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat));						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);						send_command(iaxs[fr->callno], AST_FRAME_CONTROL, AST_CONTROL_PROGRESS, 0, NULL, 0, -1);						if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->peerformat, NULL, 1)))							iax2_destroy(fr->callno);						else if (ies.vars) {							struct ast_datastore *variablestore;							struct ast_variable *var, *prev = NULL;							AST_LIST_HEAD(, ast_var_t) *varlist;							varlist = ast_calloc(1, sizeof(*varlist));							variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);							ast_debug(1, "I can haz IAX vars? w00t\n");							if (variablestore && varlist) {								variablestore->data = varlist;								variablestore->inheritance = DATASTORE_INHERIT_FOREVER;								AST_LIST_HEAD_INIT(varlist);								for (var = ies.vars; var; var = var->next) {									struct ast_var_t *newvar = ast_var_assign(var->name, var->value);									if (prev)										ast_free(prev);									prev = var;									if (!newvar) {										/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */										ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									} else {										AST_LIST_INSERT_TAIL(varlist, newvar, entries);									}								}								if (prev)									ast_free(prev);								ies.vars = NULL;								ast_channel_datastore_add(c, variablestore);							} else {								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");								if (variablestore)									ast_datastore_free(variablestore);								if (varlist)									ast_free(varlist);							}						}					}				}				break;			case IAX_COMMAND_INVAL:				iaxs[fr->callno]->error = ENOTCONN;				ast_debug(1, "Immediately destroying %d, having received INVAL\n", fr->callno);				iax2_destroy(fr->callno);				ast_debug(1, "Destroying call %d\n", fr->callno);				break;			case IAX_COMMAND_VNAK:				ast_debug(1, "Received VNAK: resending outstanding frames\n");				/* Force retransmission */				vnak_retransmit(fr->callno, fr->iseqno);				break;			case IAX_COMMAND_REGREQ:			case IAX_COMMAND_REGREL:				/* For security, always ack immediately */				if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				if (register_verify(fr->callno, &sin, &ies)) {					if (!iaxs[fr->callno]) {						break;					}					/* Send delayed failure */					auth_fail(fr->callno, IAX_COMMAND_REGREJ);					break;				}				if (!iaxs[fr->callno]) {					break;				}				if ((ast_strlen_zero(iaxs[fr->callno]->secret) && ast_strlen_zero(iaxs[fr->callno]->inkeys)) ||						ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED)) {					if (f.subclass.integer == IAX_COMMAND_REGREL) {						memset(&sin, 0, sizeof(sin));						sin.sin_family = AF_INET;					}					if (update_registry(&sin, fr->callno, ies.devicetype, fd, ies.refresh)) {						ast_log(LOG_WARNING, "Registry error\n");					}					if (!iaxs[fr->callno]) {						break;					}					if (ies.provverpres && ies.serviceident && sin.sin_addr.s_addr) {						ast_mutex_unlock(&iaxsl[fr->callno]);						check_provisioning(&sin, fd, ies.serviceident, ies.provver);						ast_mutex_lock(&iaxsl[fr->callno]);					}					break;				}				registry_authrequest(fr->callno);				break;			case IAX_COMMAND_REGACK:				if (iax2_ack_registry(&ies, &sin, fr->callno)) 					ast_log(LOG_WARNING, "Registration failure\n");				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_REGREJ:				if (iaxs[fr->callno]->reg) {					if (authdebug) {						ast_log(LOG_NOTICE, "Registration of '%s' rejected: '%s' from: '%s'\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>", ast_inet_ntoa(sin.sin_addr));						manager_event(EVENT_FLAG_SYSTEM, "Registry", "ChannelType: IAX2\r\nUsername: %s\r\nStatus: Rejected\r\nCause: %s\r\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>");					}					iaxs[fr->callno]->reg->regstate = REG_STATE_REJECTED;				}				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_REGAUTH:				/* Authentication request */				if (registry_rerequest(&ies, fr->callno, &sin)) {					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No authority found");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_FACILITY_NOT_SUBSCRIBED);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);				}				break;			case IAX_COMMAND_TXREJ:				iaxs[fr->callno]->transferring = 0;				ast_verb(3, "Channel '%s' unable to transfer\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");				memset(&iaxs[fr->callno]->transfer, 0, sizeof(iaxs[fr->callno]->transfer));				if (iaxs[fr->callno]->bridgecallno) {					if (iaxs[iaxs[fr->callno]->bridgecallno]->transferring) {						iaxs[iaxs[fr->callno]->bridgecallno]->transferring = 0;						send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREJ, 0, NULL, 0, -1);					}				}				break;			case IAX_COMMAND_TXREADY:				if ((iaxs[fr->callno]->transferring == TRANSFER_BEGIN) ||				    (iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)) {					if (iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)						iaxs[fr->callno]->transferring = TRANSFER_MREADY;					else						iaxs[fr->callno]->transferring = TRANSFER_READY;					ast_verb(3, "Channel '%s' ready to transfer\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					if (iaxs[fr->callno]->bridgecallno) {						if ((iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_READY) ||						    (iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_MREADY)) {							/* They're both ready, now release them. */							if (iaxs[fr->callno]->transferring == TRANSFER_MREADY) {								ast_verb(3, "Attempting media bridge of %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_MEDIA;								iaxs[fr->callno]->transferring = TRANSFER_MEDIA;								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied1.buf, ied1.pos, -1);							} else {								ast_verb(3, "Releasing %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_RELEASED;								iaxs[fr->callno]->transferring = TRANSFER_RELEASED;								ast_set_flag64(iaxs[iaxs[fr->callno]->bridgecallno], IAX_ALREADYGONE);								ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);								/* Stop doing lag & ping requests */								stop_stuff(fr->callno);								stop_stuff(iaxs[fr->callno]->bridgecallno);								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied1.buf, ied1.pos, -1);							}						}					}				}				break;			case IAX_COMMAND_TXREQ:				try_transfer(iaxs[fr->callno], &ies);				break;			case IAX_COMMAND_TXCNT:				if (iaxs[fr->callno]->transferring)					send_command_transfer(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXACC, 0, NULL, 0);				break;			case IAX_COMMAND_TXREL:				/* Send ack immediately, rather than waiting until we've changed addresses */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				complete_transfer(fr->callno, &ies);				stop_stuff(fr->callno);	/* for attended transfer to work with libiax */				break;				case IAX_COMMAND_TXMEDIA:				if (iaxs[fr->callno]->transferring == TRANSFER_READY) {					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* Cancel any outstanding frames and start anew */						if (cur->transfer) {							cur->retries = -1;						}					}					/* Start sending our media to the transfer address, but otherwise leave the call as-is */					iaxs[fr->callno]->transferring = TRANSFER_MEDIAPASS;				}				break;			case IAX_COMMAND_RTKEY:				if (!IAX_CALLENCRYPTED(iaxs[fr->callno])) {					ast_log(LOG_WARNING, 						"we've been told to rotate our encryption key, "						"but this isn't an encrypted call. bad things will happen.\n"					);					break;				}				IAX_DEBUGDIGEST("Receiving", ies.challenge);				ast_aes_set_decrypt_key((unsigned char *) ies.challenge, &iaxs[fr->callno]->dcx);				break;			case IAX_COMMAND_DPREP:				complete_dpreply(iaxs[fr->callno], &ies);				break;			case IAX_COMMAND_UNSUPPORT:				ast_log(LOG_NOTICE, "Peer did not understand our iax command '%d'\n", ies.iax_unknown);				break;			case IAX_COMMAND_FWDOWNL:				/* Firmware download */				if (!ast_test_flag64(&globalflags, IAX_ALLOWFWDOWNLOAD)) {					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_UNSUPPORT, 0, NULL, 0, -1);					break;				}				memset(&ied0, 0, sizeof(ied0));				res = iax_firmware_append(&ied0, (unsigned char *)ies.devicetype, ies.fwdesc);				if (res < 0)					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);				else if (res > 0)					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1);				else					send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1);				break;			case IAX_COMMAND_CALLTOKEN:			{				struct iax_frame *cur;				/* find last sent frame */				if ((cur = AST_LIST_LAST(&frame_queue[fr->callno])) && ies.calltoken && ies.calltokendata) {					resend_with_token(fr->callno, cur, (char *) ies.calltokendata);				}				break;			}			default:				ast_debug(1, "Unknown IAX command %d on %d/%d\n", f.subclass.integer, fr->callno, iaxs[fr->callno]->peercallno);				memset(&ied0, 0, sizeof(ied0));				iax_ie_append_byte(&ied0, IAX_IE_IAX_UNKNOWN, f.subclass.integer);				send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_UNSUPPORT, 0, ied0.buf, ied0.pos, -1);			}			/* Free remote variables (if any) */			if (ies.vars) {				ast_variables_destroy(ies.vars);				ast_debug(1, "I can haz IAX vars, but they is no good :-(\n");				ies.vars = NULL;			}			/* Don't actually pass these frames along */			if ((f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&			  (f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_INVAL) &&			  (f.subclass.integer != IAX_COMMAND_VNAK)) {				if (iaxs[fr->callno] && iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);			}			ast_mutex_unlock(&iaxsl[fr->callno]);			return 1;		}		/* Unless this is an ACK or INVAL frame, ack it */		if (iaxs[fr->callno] && iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno)			send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);	}
static int
socket_process_helper(struct iax2_thread *thread)
socket_process_helper
struct iax2_thread *thread
struct iax2_thread
iax2_thread
*thread
*
thread
{	struct sockaddr_in sin;	int res;	int updatehistory=1;	int new = NEW_PREVENT;	int dcallno = 0;	char decrypted = 0;	struct ast_iax2_full_hdr *fh = (struct ast_iax2_full_hdr *)thread->buf;	struct ast_iax2_mini_hdr *mh = (struct ast_iax2_mini_hdr *)thread->buf;	struct ast_iax2_meta_hdr *meta = (struct ast_iax2_meta_hdr *)thread->buf;	struct ast_iax2_video_hdr *vh = (struct ast_iax2_video_hdr *)thread->buf;	struct iax_frame *fr;	struct iax_frame *cur;	struct ast_frame f = { 0, };	struct ast_channel *c = NULL;	struct iax2_dpcache *dp;	struct iax2_peer *peer;	struct iax_ies ies;	struct iax_ie_data ied0, ied1;	iax2_format format;	int fd;	int exists;	int minivid = 0;	char empty[32]="";		/* Safety measure */	struct iax_frame *duped_fr;	char host_pref_buf[128];	char caller_pref_buf[128];	struct ast_codec_pref pref;	char *using_prefs = "mine";	/* allocate an iax_frame with 4096 bytes of data buffer */	fr = ast_alloca(sizeof(*fr) + 4096);	memset(fr, 0, sizeof(*fr));	fr->afdatalen = 4096; /* From ast_alloca() above */	/* Copy frequently used parameters to the stack */	res = thread->buf_len;	fd = thread->iofd;	memcpy(&sin, &thread->iosin, sizeof(sin));	if (res < sizeof(*mh)) {		ast_log(LOG_WARNING, "midget packet received (%d of %d min)\n", res, (int) sizeof(*mh));		return 1;	}	if ((vh->zeros == 0) && (ntohs(vh->callno) & 0x8000)) {		if (res < sizeof(*vh)) {			ast_log(LOG_WARNING, "Rejecting packet from '%s.%d' that is flagged as a video frame but is too short\n", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));			return 1;		}		/* This is a video frame, get call number */		fr->callno = find_callno(ntohs(vh->callno) & ~0x8000, dcallno, &sin, new, fd, 0);		minivid = 1;	} else if ((meta->zeros == 0) && !(ntohs(meta->metacmd) & 0x8000))		return socket_process_meta(res, meta, &sin, fd, fr);#ifdef DEBUG_SUPPORT	if (res >= sizeof(*fh))		iax_outputframe(NULL, fh, 1, &sin, res - sizeof(*fh));#endif	if (ntohs(mh->callno) & IAX_FLAG_FULL) {		if (res < sizeof(*fh)) {			ast_log(LOG_WARNING, "Rejecting packet from '%s.%d' that is flagged as a full frame but is too short\n", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));			return 1;		}		/* Get the destination call number */		dcallno = ntohs(fh->dcallno) & ~IAX_FLAG_RETRANS;		/* check to make sure this full frame isn't encrypted before we attempt 		 * to look inside of it. If it is encrypted, decrypt it first. Its ok if the		 * callno is not found here, that just means one hasn't been allocated for		 * this connection yet. */		if ((dcallno != 1) && (fr->callno = find_callno(ntohs(mh->callno) & ~IAX_FLAG_FULL, dcallno, &sin, NEW_PREVENT, fd, 1))) {			ast_mutex_lock(&iaxsl[fr->callno]);			if (iaxs[fr->callno] && ast_test_flag64(iaxs[fr->callno], IAX_ENCRYPTED)) {				if (decrypt_frame(fr->callno, fh, &f, &res)) {					ast_log(LOG_NOTICE, "Packet Decrypt Failed!\n");					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}				decrypted = 1;			}			ast_mutex_unlock(&iaxsl[fr->callno]);		}		/* Retrieve the type and subclass */		f.frametype = fh->type;		if (f.frametype == AST_FRAME_VIDEO) {			ast_format_from_old_bitfield(&f.subclass.format, (uncompress_subclass(fh->csub & ~0x40)));			if ((fh->csub >> 6) & 0x1) {				ast_format_set_video_mark(&f.subclass.format);			}		} else if (f.frametype == AST_FRAME_VOICE) {			ast_format_from_old_bitfield(&f.subclass.format, uncompress_subclass(fh->csub));		} else {			f.subclass.integer = uncompress_subclass(fh->csub);		}		/* Deal with POKE/PONG without allocating a callno */		if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_POKE) {			/* Reply back with a PONG, but don't care about the result. */			send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_PONG, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			return 1;		} else if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_ACK && dcallno == 1) {			/* Ignore */			return 1;		}		f.datalen = res - sizeof(*fh);		if (f.datalen) {			if (f.frametype == AST_FRAME_IAX) {				if (iax_parse_ies(&ies, thread->buf + sizeof(struct ast_iax2_full_hdr), f.datalen)) {					ast_log(LOG_WARNING, "Undecodable frame received from '%s'\n", ast_inet_ntoa(sin.sin_addr));					ast_variables_destroy(ies.vars);					return 1;				}				f.data.ptr = NULL;				f.datalen = 0;			} else {				f.data.ptr = thread->buf + sizeof(struct ast_iax2_full_hdr);				memset(&ies, 0, sizeof(ies));			}		} else {			if (f.frametype == AST_FRAME_IAX)				f.data.ptr = NULL;			else				f.data.ptr = empty;			memset(&ies, 0, sizeof(ies));		}		if (!dcallno && iax2_allow_new(f.frametype, f.subclass.integer, 1)) {			/* only set NEW_ALLOW if calltoken checks out */			if (handle_call_token(fh, &ies, &sin, fd)) {				ast_variables_destroy(ies.vars);				return 1;			}			if (ies.calltoken && ies.calltokendata) {				/* if we've gotten this far, and the calltoken ie data exists,				 * then calltoken validation _MUST_ have taken place.  If calltoken				 * data is provided, it is always validated reguardless of any				 * calltokenoptional or requirecalltoken options */				new = NEW_ALLOW_CALLTOKEN_VALIDATED;			} else {				new = NEW_ALLOW;			}		}	} else {		/* Don't know anything about it yet */		f.frametype = AST_FRAME_NULL;		f.subclass.integer = 0;		memset(&ies, 0, sizeof(ies));	}	if (!fr->callno) {		int check_dcallno = 0;		/*		 * We enforce accurate destination call numbers for ACKs.  This forces the other		 * end to know the destination call number before call setup can complete.		 *		 * Discussed in the following thread:		 *    http://lists.digium.com/pipermail/asterisk-dev/2008-May/033217.html 		 */		if ((ntohs(mh->callno) & IAX_FLAG_FULL) && ((f.frametype == AST_FRAME_IAX) && (f.subclass.integer == IAX_COMMAND_ACK))) {			check_dcallno = 1;		}		if (!(fr->callno = find_callno(ntohs(mh->callno) & ~IAX_FLAG_FULL, dcallno, &sin, new, fd, check_dcallno))) {			if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_NEW) {				send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REJECT, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			} else if (f.frametype == AST_FRAME_IAX && (f.subclass.integer == IAX_COMMAND_REGREQ || f.subclass.integer == IAX_COMMAND_REGREL)) {				send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REGREJ, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			}			ast_variables_destroy(ies.vars);			return 1;		}	}	if (fr->callno > 0) {		struct ast_callid *mount_callid;		ast_mutex_lock(&iaxsl[fr->callno]);		if (iaxs[fr->callno] && ((mount_callid = iax_pvt_callid_get(fr->callno)))) {			/* Bind to thread */			ast_callid_threadassoc_add(mount_callid);			ast_callid_unref(mount_callid);		}	}	if (!fr->callno || !iaxs[fr->callno]) {		/* A call arrived for a nonexistent destination.  Unless it's an "inval"		   frame, reply with an inval */		if (ntohs(mh->callno) & IAX_FLAG_FULL) {			/* We can only raw hangup control frames */			if (((f.subclass.integer != IAX_COMMAND_INVAL) &&				 (f.subclass.integer != IAX_COMMAND_TXCNT) &&				 (f.subclass.integer != IAX_COMMAND_TXACC) &&				 (f.subclass.integer != IAX_COMMAND_FWDOWNL))||			    (f.frametype != AST_FRAME_IAX))				raw_hangup(&sin, ntohs(fh->dcallno) & ~IAX_FLAG_RETRANS, ntohs(mh->callno) & ~IAX_FLAG_FULL,				fd);		}		if (fr->callno > 0) 			ast_mutex_unlock(&iaxsl[fr->callno]);		ast_variables_destroy(ies.vars);		return 1;	}	if (ast_test_flag64(iaxs[fr->callno], IAX_ENCRYPTED) && !decrypted) {		if (decrypt_frame(fr->callno, fh, &f, &res)) {			ast_log(LOG_NOTICE, "Packet Decrypt Failed!\n");			ast_variables_destroy(ies.vars);			ast_mutex_unlock(&iaxsl[fr->callno]);			return 1;		}		decrypted = 1;	}#ifdef DEBUG_SUPPORT	if (decrypted) {		iax_outputframe(NULL, fh, 3, &sin, res - sizeof(*fh));	}#endif	if (iaxs[fr->callno]->owner && fh->type == AST_FRAME_IAX &&			(fh->csub == IAX_COMMAND_HANGUP			|| fh->csub == IAX_COMMAND_REJECT			|| fh->csub == IAX_COMMAND_REGREJ			|| fh->csub == IAX_COMMAND_TXREJ)) {		struct ast_control_pvt_cause_code *cause_code;		int data_size = sizeof(*cause_code);		char subclass[40] = "";		/* get subclass text */		iax_frame_subclass2str(fh->csub, subclass, sizeof(subclass));		/* add length of "IAX2 " */		data_size += 5;		/* for IAX hangup frames, add length of () and number */		data_size += 3;		if (ies.causecode > 9) {			data_size++;		}		if (ies.causecode > 99) {			data_size++;		}		/* add length of subclass */		data_size += strlen(subclass);		cause_code = ast_alloca(data_size);		ast_copy_string(cause_code->chan_name, ast_channel_name(iaxs[fr->callno]->owner), AST_CHANNEL_NAME);		cause_code->ast_cause = ies.causecode;		snprintf(cause_code->code, data_size - sizeof(*cause_code) + 1, "IAX2 %s(%d)", subclass, ies.causecode);		iax2_lock_owner(fr->callno);		if (iaxs[fr->callno] && iaxs[fr->callno]->owner) {			ast_queue_control_data(iaxs[fr->callno]->owner, AST_CONTROL_PVT_CAUSE_CODE, cause_code, data_size);			ast_channel_hangupcause_hash_set(iaxs[fr->callno]->owner, cause_code, data_size);			ast_channel_unlock(iaxs[fr->callno]->owner);		}		if (!iaxs[fr->callno]) {			ast_variables_destroy(ies.vars);			ast_mutex_unlock(&iaxsl[fr->callno]);			return 1;		}	}	/* count this frame */	iaxs[fr->callno]->frames_received++;	if (!inaddrcmp(&sin, &iaxs[fr->callno]->addr) && !minivid &&		f.subclass.integer != IAX_COMMAND_TXCNT &&		/* for attended transfer */		f.subclass.integer != IAX_COMMAND_TXACC) {		/* for attended transfer */		unsigned short new_peercallno;		new_peercallno = (unsigned short) (ntohs(mh->callno) & ~IAX_FLAG_FULL);		if (new_peercallno && new_peercallno != iaxs[fr->callno]->peercallno) {			if (iaxs[fr->callno]->peercallno) {				remove_by_peercallno(iaxs[fr->callno]);			}			iaxs[fr->callno]->peercallno = new_peercallno;			store_by_peercallno(iaxs[fr->callno]);		}	}	if (ntohs(mh->callno) & IAX_FLAG_FULL) {		if (iaxdebug)			ast_debug(1, "Received packet %d, (%d, %u)\n", fh->oseqno, f.frametype, f.subclass.integer);		/* Check if it's out of order (and not an ACK or INVAL) */		fr->oseqno = fh->oseqno;		fr->iseqno = fh->iseqno;		fr->ts = ntohl(fh->ts);#ifdef IAXTESTS		if (test_resync) {			ast_debug(1, "Simulating frame ts resync, was %u now %u\n", fr->ts, fr->ts + test_resync);			fr->ts += test_resync;		}#endif /* IAXTESTS */#if 0		if ( (ntohs(fh->dcallno) & IAX_FLAG_RETRANS) ||		     ( (f.frametype != AST_FRAME_VOICE) && ! (f.frametype == AST_FRAME_IAX &&								(f.subclass == IAX_COMMAND_NEW ||								 f.subclass == IAX_COMMAND_AUTHREQ ||								 f.subclass == IAX_COMMAND_ACCEPT ||								 f.subclass == IAX_COMMAND_REJECT))      ) )#endif		if ((ntohs(fh->dcallno) & IAX_FLAG_RETRANS) || (f.frametype != AST_FRAME_VOICE))			updatehistory = 0;		if ((iaxs[fr->callno]->iseqno != fr->oseqno) &&			(iaxs[fr->callno]->iseqno ||				((f.subclass.integer != IAX_COMMAND_TXCNT) &&				(f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXACC)) ||				(f.frametype != AST_FRAME_IAX))) {			if (			 ((f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_INVAL) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&			  (f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_VNAK)) ||			  (f.frametype != AST_FRAME_IAX)) {				/* If it's not an ACK packet, it's out of order. */				ast_debug(1, "Packet arrived out of order (expecting %d, got %d) (frametype = %d, subclass = %d)\n",					iaxs[fr->callno]->iseqno, fr->oseqno, f.frametype, f.subclass.integer);				/* Check to see if we need to request retransmission,				 * and take sequence number wraparound into account */				if ((unsigned char) (iaxs[fr->callno]->iseqno - fr->oseqno) < 128) {					/* If we've already seen it, ack it XXX There's a border condition here XXX */					if ((f.frametype != AST_FRAME_IAX) ||							((f.subclass.integer != IAX_COMMAND_ACK) && (f.subclass.integer != IAX_COMMAND_INVAL))) {						ast_debug(1, "Acking anyway\n");						/* XXX Maybe we should handle its ack to us, but then again, it's probably outdated anyway, and if						   we have anything to send, we'll retransmit and get an ACK back anyway XXX */						send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					}				} else {					/* Send a VNAK requesting retransmission */					iax2_vnak(fr->callno);				}				ast_variables_destroy(ies.vars);				ast_mutex_unlock(&iaxsl[fr->callno]);				return 1;			}		} else {			/* Increment unless it's an ACK or VNAK */			if (((f.subclass.integer != IAX_COMMAND_ACK) &&			    (f.subclass.integer != IAX_COMMAND_INVAL) &&			    (f.subclass.integer != IAX_COMMAND_TXCNT) &&			    (f.subclass.integer != IAX_COMMAND_TXACC) &&				(f.subclass.integer != IAX_COMMAND_VNAK)) ||			    (f.frametype != AST_FRAME_IAX))				iaxs[fr->callno]->iseqno++;		}		/* Ensure text frames are NULL-terminated */		if (f.frametype == AST_FRAME_TEXT && thread->buf[res - 1] != '\0') {			if (res < thread->buf_size)				thread->buf[res++] = '\0';			else /* Trims one character from the text message, but that's better than overwriting the end of the buffer. */				thread->buf[res - 1] = '\0';		}		/* Handle implicit ACKing unless this is an INVAL, and only if this is 		   from the real peer, not the transfer peer */		if (!inaddrcmp(&sin, &iaxs[fr->callno]->addr) &&		    ((f.subclass.integer != IAX_COMMAND_INVAL) ||		     (f.frametype != AST_FRAME_IAX))) {			unsigned char x;			int call_to_destroy;			/* First we have to qualify that the ACKed value is within our window */			if (iaxs[fr->callno]->rseqno >= iaxs[fr->callno]->oseqno || (fr->iseqno >= iaxs[fr->callno]->rseqno && fr->iseqno < iaxs[fr->callno]->oseqno))				x = fr->iseqno;			else				x = iaxs[fr->callno]->oseqno;			if ((x != iaxs[fr->callno]->oseqno) || (iaxs[fr->callno]->oseqno == fr->iseqno)) {				/* The acknowledgement is within our window.  Time to acknowledge everything				   that it says to */				for (x=iaxs[fr->callno]->rseqno; x != fr->iseqno; x++) {					/* Ack the packet with the given timestamp */					if (iaxdebug)						ast_debug(1, "Cancelling transmission of packet %d\n", x);					call_to_destroy = 0;					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* If it's our call, and our timestamp, mark -1 retries */						if (x == cur->oseqno) {							cur->retries = -1;							/* Destroy call if this is the end */							if (cur->final)								call_to_destroy = fr->callno;						}					}					if (call_to_destroy) {						if (iaxdebug)							ast_debug(1, "Really destroying %d, having been acked on final message\n", call_to_destroy);						ast_mutex_lock(&iaxsl[call_to_destroy]);						iax2_destroy(call_to_destroy);						ast_mutex_unlock(&iaxsl[call_to_destroy]);					}				}				/* Note how much we've received acknowledgement for */				if (iaxs[fr->callno])					iaxs[fr->callno]->rseqno = fr->iseqno;				else {					/* Stop processing now */					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}			} else {				ast_debug(1, "Received iseqno %d not within window %d->%d\n", fr->iseqno, iaxs[fr->callno]->rseqno, iaxs[fr->callno]->oseqno);			}		}		if (inaddrcmp(&sin, &iaxs[fr->callno]->addr) &&			((f.frametype != AST_FRAME_IAX) ||			 ((f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT)))) {			/* Only messages we accept from a transfer host are TXACC and TXCNT */			ast_variables_destroy(ies.vars);			ast_mutex_unlock(&iaxsl[fr->callno]);			return 1;		}		/* when we receive the first full frame for a new incoming channel,		   it is safe to start the PBX on the channel because we have now		   completed a 3-way handshake with the peer */		if ((f.frametype == AST_FRAME_VOICE) ||		    (f.frametype == AST_FRAME_VIDEO) ||		    (f.frametype == AST_FRAME_IAX)) {			if (ast_test_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART)) {				ast_clear_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);				if (!ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->chosenformat, NULL,						  ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED))) {					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}			}			if (ies.vars) {				struct ast_datastore *variablestore = NULL;				struct ast_variable *var, *prev = NULL;				AST_LIST_HEAD(, ast_var_t) *varlist;				iax2_lock_owner(fr->callno);				if (!iaxs[fr->callno]) {					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}				if ((c = iaxs[fr->callno]->owner)) {					varlist = ast_calloc(1, sizeof(*varlist));					variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);					if (variablestore && varlist) {						variablestore->data = varlist;						variablestore->inheritance = DATASTORE_INHERIT_FOREVER;						AST_LIST_HEAD_INIT(varlist);						ast_debug(1, "I can haz IAX vars?\n");						for (var = ies.vars; var; var = var->next) {							struct ast_var_t *newvar = ast_var_assign(var->name, var->value);							if (prev) {								ast_free(prev);							}							prev = var;							if (!newvar) {								/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");							} else {								AST_LIST_INSERT_TAIL(varlist, newvar, entries);							}						}						if (prev) {							ast_free(prev);						}						ies.vars = NULL;						ast_channel_datastore_add(c, variablestore);					} else {						ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");						if (variablestore) {							ast_datastore_free(variablestore);						}						if (varlist) {							ast_free(varlist);						}					}					ast_channel_unlock(c);				} else {					/* No channel yet, so transfer the variables directly over to the pvt,					 * for later inheritance. */					ast_debug(1, "No channel, so populating IAXVARs to the pvt, as an intermediate step.\n");					for (var = ies.vars; var && var->next; var = var->next);					if (var) {						var->next = iaxs[fr->callno]->iaxvars;						iaxs[fr->callno]->iaxvars = ies.vars;						ies.vars = NULL;					}				}			}			if (ies.vars) {				ast_debug(1, "I have IAX variables, but they were not processed\n");			}		}		/* once we receive our first IAX Full Frame that is not CallToken related, send all		 * queued signaling frames that were being held. */		if ((f.frametype == AST_FRAME_IAX) && (f.subclass.integer != IAX_COMMAND_CALLTOKEN) && iaxs[fr->callno]->hold_signaling) {			send_signaling(iaxs[fr->callno]);		}		if (f.frametype == AST_FRAME_VOICE) {			if (ast_format_to_old_bitfield(&f.subclass.format) != iaxs[fr->callno]->voiceformat) {					iaxs[fr->callno]->voiceformat = ast_format_to_old_bitfield(&f.subclass.format);					ast_debug(1, "Ooh, voice format changed to '%s'\n", ast_getformatname(&f.subclass.format));					if (iaxs[fr->callno]->owner) {						iax2_lock_owner(fr->callno);						if (iaxs[fr->callno]) {							if (iaxs[fr->callno]->owner) {								struct ast_format_cap *orignative = ast_format_cap_dup(ast_channel_nativeformats(iaxs[fr->callno]->owner));								struct ast_format_cap *native = ast_channel_nativeformats(iaxs[fr->callno]->owner);								if (orignative) {									ast_format_cap_set(native, &f.subclass.format);									if (ast_channel_readformat(iaxs[fr->callno]->owner)->id) {										ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));									}									ast_format_cap_copy(native, orignative);									ast_channel_unlock(iaxs[fr->callno]->owner);									orignative = ast_format_cap_destroy(orignative);								}							}						} else {							ast_debug(1, "Neat, somebody took away the channel at a magical time but i found it!\n");							/* Free remote variables (if any) */							if (ies.vars) {								ast_variables_destroy(ies.vars);								ast_debug(1, "I can haz iaxvars, but they is no good.  :-(\n");								ies.vars = NULL;							}							ast_mutex_unlock(&iaxsl[fr->callno]);							return 1;						}					}			}		}		if (f.frametype == AST_FRAME_VIDEO) {			if (f.subclass.format.id != ast_format_id_from_old_bitfield(iaxs[fr->callno]->videoformat)) {				ast_debug(1, "Ooh, video format changed to %s\n", ast_getformatname(&f.subclass.format));				iaxs[fr->callno]->videoformat = ast_format_to_old_bitfield(&f.subclass.format);			}		}		if (f.frametype == AST_FRAME_CONTROL && iaxs[fr->callno]->owner) {			if (f.subclass.integer == AST_CONTROL_BUSY) {				ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_BUSY);			} else if (f.subclass.integer == AST_CONTROL_CONGESTION) {				ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_CONGESTION);			}		}		if (f.frametype == AST_FRAME_IAX) {			AST_SCHED_DEL(sched, iaxs[fr->callno]->initid);			/* Handle the IAX pseudo frame itself */			if (iaxdebug)				ast_debug(1, "IAX subclass %d received\n", f.subclass.integer);                        /* Update last ts unless the frame's timestamp originated with us. */			if (iaxs[fr->callno]->last < fr->ts &&                            f.subclass.integer != IAX_COMMAND_ACK &&                            f.subclass.integer != IAX_COMMAND_PONG &&                            f.subclass.integer != IAX_COMMAND_LAGRP) {				iaxs[fr->callno]->last = fr->ts;				if (iaxdebug)					ast_debug(1, "For call=%d, set last=%d\n", fr->callno, fr->ts);			}			iaxs[fr->callno]->last_iax_message = f.subclass.integer;			if (!iaxs[fr->callno]->first_iax_message) {				iaxs[fr->callno]->first_iax_message = f.subclass.integer;			}			switch(f.subclass.integer) {			case IAX_COMMAND_ACK:				/* Do nothing */				break;			case IAX_COMMAND_QUELCH:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {				        /* Generate Manager Hold event, if necessary*/					if (iaxs[fr->callno]->owner) {						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: On\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}					ast_set_flag64(iaxs[fr->callno], IAX_QUELCH);					if (ies.musiconhold) {						iax2_lock_owner(fr->callno);						if (!iaxs[fr->callno] || !iaxs[fr->callno]->owner) {							break;						}						if (ast_bridged_channel(iaxs[fr->callno]->owner)) {							const char *moh_suggest = iaxs[fr->callno]->mohsuggest;							/*							 * We already hold the owner lock so we do not							 * need to check iaxs[fr->callno] after it returns.							 */							iax2_queue_control_data(fr->callno, AST_CONTROL_HOLD, 								S_OR(moh_suggest, NULL),								!ast_strlen_zero(moh_suggest) ? strlen(moh_suggest) + 1 : 0);						}						ast_channel_unlock(iaxs[fr->callno]->owner);					}				}				break;			case IAX_COMMAND_UNQUELCH:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {					iax2_lock_owner(fr->callno);					if (!iaxs[fr->callno]) {						break;					}					/* Generate Manager Unhold event, if necessary */					if (iaxs[fr->callno]->owner && ast_test_flag64(iaxs[fr->callno], IAX_QUELCH)) {						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: Off\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}					ast_clear_flag64(iaxs[fr->callno], IAX_QUELCH);					if (!iaxs[fr->callno]->owner) {						break;					}					if (ast_bridged_channel(iaxs[fr->callno]->owner)) {						/*						 * We already hold the owner lock so we do not						 * need to check iaxs[fr->callno] after it returns.						 */						iax2_queue_control_data(fr->callno, AST_CONTROL_UNHOLD, NULL, 0);					}					ast_channel_unlock(iaxs[fr->callno]->owner);				}				break;			case IAX_COMMAND_TXACC:				if (iaxs[fr->callno]->transferring == TRANSFER_BEGIN) {					/* Ack the packet with the given timestamp */					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* Cancel any outstanding txcnt's */						if (cur->transfer) {							cur->retries = -1;						}					}					memset(&ied1, 0, sizeof(ied1));					iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->callno);					send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREADY, 0, ied1.buf, ied1.pos, -1);					iaxs[fr->callno]->transferring = TRANSFER_READY;				}				break;			case IAX_COMMAND_NEW:				/* Ignore if it's already up */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD))					break;				if (ies.provverpres && ies.serviceident && sin.sin_addr.s_addr) {					ast_mutex_unlock(&iaxsl[fr->callno]);					check_provisioning(&sin, fd, ies.serviceident, ies.provver);					ast_mutex_lock(&iaxsl[fr->callno]);					if (!iaxs[fr->callno]) {						break;					}				}				/* If we're in trunk mode, do it now, and update the trunk number in our frame before continuing */				if (ast_test_flag64(iaxs[fr->callno], IAX_TRUNK)) {					int new_callno;					if ((new_callno = make_trunk(fr->callno, 1)) != -1)						fr->callno = new_callno;				}				/* For security, always ack immediately */				if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				if (check_access(fr->callno, &sin, &ies)) {					/* They're not allowed on */					auth_fail(fr->callno, IAX_COMMAND_REJECT);					if (authdebug)						ast_log(LOG_NOTICE, "Rejected connect attempt from %s, who was trying to reach '%s@%s'\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					break;				}				if (ast_strlen_zero(iaxs[fr->callno]->secret) && ast_test_flag64(iaxs[fr->callno], IAX_FORCE_ENCRYPT)) {					auth_fail(fr->callno, IAX_COMMAND_REJECT);					ast_log(LOG_WARNING, "Rejected connect attempt.  No secret present while force encrypt enabled.\n");					break;				}				if (strcasecmp(iaxs[fr->callno]->exten, "TBD")) {					const char *context, *exten, *cid_num;					context = ast_strdupa(iaxs[fr->callno]->context);					exten = ast_strdupa(iaxs[fr->callno]->exten);					cid_num = ast_strdupa(iaxs[fr->callno]->cid_num);					/* This might re-enter the IAX code and need the lock */					ast_mutex_unlock(&iaxsl[fr->callno]);					exists = ast_exists_extension(NULL, context, exten, 1, cid_num);					ast_mutex_lock(&iaxsl[fr->callno]);					if (!iaxs[fr->callno]) {						break;					}				} else					exists = 0;				/* Get OSP token if it does exist */				save_osptoken(fr, &ies);				if (ast_strlen_zero(iaxs[fr->callno]->secret) && ast_strlen_zero(iaxs[fr->callno]->inkeys)) {					if (strcmp(iaxs[fr->callno]->exten, "TBD") && !exists) {						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}						if (authdebug)							ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					} else {						/* Select an appropriate format */						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								using_prefs = "reqonly";							} else {								using_prefs = "disabled";							}							format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;							memset(&pref, 0, sizeof(pref));							strcpy(caller_pref_buf, "disabled");							strcpy(host_pref_buf, "disabled");						} else {							struct ast_format tmpfmt;							using_prefs = "mine";							/* If the information elements are in here... use them */							if (ies.codec_prefs)								ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);							if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {								/* If we are codec_first_choice we let the caller have the 1st shot at picking the codec.*/								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {									pref = iaxs[fr->callno]->rprefs;									using_prefs = "caller";								} else {									pref = iaxs[fr->callno]->prefs;								}							} else								pref = iaxs[fr->callno]->prefs;							format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);							ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);							ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);						}						if (!format) {							if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP))								format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;							if (!format) {								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}								if (authdebug) {									char tmp[256], tmp2[256], tmp3[256];									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}							} else {								/* Pick one... */								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))										format = 0;								} else {									if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {										using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";										memset(&pref, 0, sizeof(pref));										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);										strcpy(caller_pref_buf,"disabled");										strcpy(host_pref_buf,"disabled");									} else {										struct ast_format tmpfmt;										using_prefs = "mine";										if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {											/* Do the opposite of what we tried above. */											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);										} else /* if no codec_prefs IE do it the old way */											format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}								}								if (!format) {									char tmp[256], tmp2[256], tmp3[256];									memset(&ied0, 0, sizeof(ied0));									iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");									iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);									ast_log(LOG_ERROR, "No best format in '%s'???\n", iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));									send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);									if (!iaxs[fr->callno]) {										break;									}									if (authdebug) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}									ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);									break;								}							}						}						if (format) {							/* No authentication required, let them in */							memset(&ied1, 0, sizeof(ied1));							iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);							iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);							send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);							if (strcmp(iaxs[fr->callno]->exten, "TBD")) {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);								ast_verb(3, "Accepting UNAUTHENTICATED call from %s:\n"												"%srequested format = %s,\n"												"%srequested prefs = %s,\n"												"%sactual format = %s,\n"												"%shost prefs = %s,\n"												"%spriority = %s\n",												ast_inet_ntoa(sin.sin_addr), 												VERBOSE_PREFIX_4,												iax2_getformatname(iaxs[fr->callno]->peerformat), 												VERBOSE_PREFIX_4,												caller_pref_buf,												VERBOSE_PREFIX_4,												iax2_getformatname(format), 												VERBOSE_PREFIX_4,												host_pref_buf, 												VERBOSE_PREFIX_4,												using_prefs);								iaxs[fr->callno]->chosenformat = format;								/* Since this is a new call, we should go ahead and set the callid for it. */								iax_pvt_callid_new(fr->callno);								ast_set_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);							} else {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);								/* If this is a TBD call, we're ready but now what...  */								ast_verb(3, "Accepted unauthenticated TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							}						}					}					break;				}				if (iaxs[fr->callno]->authmethods & IAX_AUTH_MD5)					merge_encryption(iaxs[fr->callno],ies.encmethods);				else					iaxs[fr->callno]->encmethods = 0;				if (!authenticate_request(fr->callno) && iaxs[fr->callno])					ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED);				break;			case IAX_COMMAND_DPREQ:				/* Request status in the dialplan */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD) &&					!ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED) && ies.called_number) {					if (iaxcompat) {						/* Spawn a thread for the lookup */						spawn_dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num);					} else {						/* Just look it up */						dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num, 1);					}				}				break;			case IAX_COMMAND_HANGUP:				ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);				ast_debug(1, "Immediately destroying %d, having received hangup\n", fr->callno);				/* Set hangup cause according to remote and hangupsource */				if (iaxs[fr->callno]->owner) {					set_hangup_source_and_cause(fr->callno, ies.causecode);					if (!iaxs[fr->callno]) {						break;					}				}				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_REJECT:				/* Set hangup cause according to remote and hangup source */				if (iaxs[fr->callno]->owner) {					set_hangup_source_and_cause(fr->callno, ies.causecode);					if (!iaxs[fr->callno]) {						break;					}				}				if (!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)) {					if (iaxs[fr->callno]->owner && authdebug)						ast_log(LOG_WARNING, "Call rejected by %s: %s\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr),							ies.cause ? ies.cause : "<Unknown>");					ast_debug(1, "Immediately destroying %d, having received reject\n",						fr->callno);				}				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK,						       fr->ts, NULL, 0, fr->iseqno);				if (!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION))					iaxs[fr->callno]->error = EPERM;				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_TRANSFER:			{				struct ast_channel *bridged_chan;				struct ast_channel *owner;				iax2_lock_owner(fr->callno);				if (!iaxs[fr->callno]) {					/* Initiating call went away before we could transfer. */					break;				}				owner = iaxs[fr->callno]->owner;				bridged_chan = owner ? ast_bridged_channel(owner) : NULL;				if (bridged_chan && ies.called_number) {					const char *context;					context = ast_strdupa(iaxs[fr->callno]->context);					ast_channel_ref(owner);					ast_channel_ref(bridged_chan);					ast_channel_unlock(owner);					ast_mutex_unlock(&iaxsl[fr->callno]);					/* Set BLINDTRANSFER channel variables */					pbx_builtin_setvar_helper(owner, "BLINDTRANSFER", ast_channel_name(bridged_chan));					pbx_builtin_setvar_helper(bridged_chan, "BLINDTRANSFER", ast_channel_name(owner));					/* DO NOT hold any locks while calling ast_parking_ext_valid() */					if (ast_parking_ext_valid(ies.called_number, owner, context)) {						ast_debug(1, "Parking call '%s'\n", ast_channel_name(bridged_chan));						if (iax_park(bridged_chan, owner, ies.called_number, context)) {							ast_log(LOG_WARNING, "Failed to park call '%s'\n",								ast_channel_name(bridged_chan));						}					} else {						if (ast_async_goto(bridged_chan, context, ies.called_number, 1)) {							ast_log(LOG_WARNING,								"Async goto of '%s' to '%s@%s' failed\n",								ast_channel_name(bridged_chan), ies.called_number, context);						} else {							ast_debug(1, "Async goto of '%s' to '%s@%s' started\n",								ast_channel_name(bridged_chan), ies.called_number, context);						}					}					ast_channel_unref(owner);					ast_channel_unref(bridged_chan);					ast_mutex_lock(&iaxsl[fr->callno]);				} else {					ast_debug(1, "Async goto not applicable on call %d\n", fr->callno);					if (owner) {						ast_channel_unlock(owner);					}				}				break;			}			case IAX_COMMAND_ACCEPT:				/* Ignore if call is already up or needs authentication or is a TBD */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD | IAX_STATE_AUTHENTICATED))					break;				if (ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)) {					/* Send ack immediately, before we destroy */					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					iax2_destroy(fr->callno);					break;				}				if (ies.format) {					iaxs[fr->callno]->peerformat = ies.format;				} else {					if (iaxs[fr->callno]->owner)						iaxs[fr->callno]->peerformat = ast_format_cap_to_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner));					else						iaxs[fr->callno]->peerformat = iaxs[fr->callno]->capability;				}				ast_verb(3, "Call accepted by %s (format %s)\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iax2_getformatname(iaxs[fr->callno]->peerformat));				if (!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)) {					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);					if (!iaxs[fr->callno]) {						break;					}					if (authdebug) {						char tmp1[256], tmp2[256];						ast_log(LOG_NOTICE, "Rejected call to %s, format %s incompatible with our capability %s.\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),							iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));					}				} else {					ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);					iax2_lock_owner(fr->callno);					if (iaxs[fr->callno] && iaxs[fr->callno]->owner) {						char tmp[256];						/* Switch us to use a compatible format */						ast_format_cap_from_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner), iaxs[fr->callno]->peerformat);						ast_verb(3, "Format for call is %s\n", ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(iaxs[fr->callno]->owner)));						/* Setup read/write formats properly. */						if (ast_channel_writeformat(iaxs[fr->callno]->owner)->id)							ast_set_write_format(iaxs[fr->callno]->owner, ast_channel_writeformat(iaxs[fr->callno]->owner));						if (ast_channel_readformat(iaxs[fr->callno]->owner)->id)							ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));						ast_channel_unlock(iaxs[fr->callno]->owner);					}				}				if (iaxs[fr->callno]) {					AST_LIST_LOCK(&dpcache);					AST_LIST_TRAVERSE(&iaxs[fr->callno]->dpentries, dp, peer_list)						if (!(dp->flags & CACHE_FLAG_TRANSMITTED))							iax2_dprequest(dp, fr->callno);					AST_LIST_UNLOCK(&dpcache);				}				break;			case IAX_COMMAND_POKE:				/* Send back a pong packet with the original timestamp */				send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, NULL, 0, -1);				break;			case IAX_COMMAND_PING:			{				struct iax_ie_data pingied;				construct_rr(iaxs[fr->callno], &pingied);				/* Send back a pong packet with the original timestamp */				send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, pingied.buf, pingied.pos, -1);			}				break;			case IAX_COMMAND_PONG:				/* Calculate ping time */				iaxs[fr->callno]->pingtime =  calc_timestamp(iaxs[fr->callno], 0, &f) - fr->ts;				/* save RR info */				save_rr(fr, &ies);				/* Good time to write jb stats for this call */				log_jitterstats(fr->callno);				if (iaxs[fr->callno]->peerpoke) {					peer = iaxs[fr->callno]->peerpoke;					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms)) {						if (iaxs[fr->callno]->pingtime <= peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now REACHABLE! Time: %d\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Reachable\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "IAX2/%s", peer->name); /* Activate notification */						}					} else if ((peer->historicms > 0) && (peer->historicms <= peer->maxms)) {						if (iaxs[fr->callno]->pingtime > peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now TOO LAGGED (%d ms)!\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Lagged\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_UNAVAILABLE, AST_DEVSTATE_CACHABLE, "IAX2/%s", peer->name); /* Activate notification */						}					}					peer->lastms = iaxs[fr->callno]->pingtime;					if (peer->smoothing && (peer->lastms > -1))						peer->historicms = (iaxs[fr->callno]->pingtime + peer->historicms) / 2;					else if (peer->smoothing && peer->lastms < 0)						peer->historicms = (0 + peer->historicms) / 2;					else											peer->historicms = iaxs[fr->callno]->pingtime;					/* Remove scheduled iax2_poke_noanswer */					if (peer->pokeexpire > -1) {						if (!AST_SCHED_DEL(sched, peer->pokeexpire)) {							peer_unref(peer);							peer->pokeexpire = -1;						}					}					/* Schedule the next cycle */					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms))						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_peer_s, peer_ref(peer));					else						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqok, iax2_poke_peer_s, peer_ref(peer));					if (peer->pokeexpire == -1)						peer_unref(peer);					/* and finally send the ack */					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					/* And wrap up the qualify call */					iax2_destroy(fr->callno);					peer->callno = 0;					ast_debug(1, "Peer %s: got pong, lastms %d, historicms %d, maxms %d\n", peer->name, peer->lastms, peer->historicms, peer->maxms);				}				break;			case IAX_COMMAND_LAGRQ:			case IAX_COMMAND_LAGRP:				f.src = "LAGRQ";				f.mallocd = 0;				f.offset = 0;				f.samples = 0;				iax_frame_wrap(fr, &f);				if (f.subclass.integer == IAX_COMMAND_LAGRQ) {					/* Received a LAGRQ - echo back a LAGRP */					fr->af.subclass.integer = IAX_COMMAND_LAGRP;					iax2_send(iaxs[fr->callno], &fr->af, fr->ts, -1, 0, 0, 0);				} else {					/* Received LAGRP in response to our LAGRQ */					unsigned int ts;					/* This is a reply we've been given, actually measure the difference */					ts = calc_timestamp(iaxs[fr->callno], 0, &fr->af);					iaxs[fr->callno]->lag = ts - fr->ts;					if (iaxdebug)						ast_debug(1, "Peer %s lag measured as %dms\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->lag);				}				break;			case IAX_COMMAND_AUTHREQ:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)) {					ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					break;				}				if (authenticate_reply(iaxs[fr->callno], &iaxs[fr->callno]->addr, &ies, iaxs[fr->callno]->secret, iaxs[fr->callno]->outkey)) {					struct ast_frame hangup_fr = { .frametype = AST_FRAME_CONTROL,								.subclass.integer = AST_CONTROL_HANGUP,					};					ast_log(LOG_WARNING, 						"I don't know how to authenticate %s to %s\n", 						ies.username ? ies.username : "<unknown>", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr));					iax2_queue_frame(fr->callno, &hangup_fr);				}				break;			case IAX_COMMAND_AUTHREP:				/* For security, always ack immediately */				if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				/* Ignore once we've started */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)) {					ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					break;				}				if (authenticate_verify(iaxs[fr->callno], &ies)) {					if (authdebug)						ast_log(LOG_NOTICE, "Host %s failed to authenticate as %s\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->username);					memset(&ied0, 0, sizeof(ied0));					auth_fail(fr->callno, IAX_COMMAND_REJECT);					break;				}				if (strcasecmp(iaxs[fr->callno]->exten, "TBD")) {					/* This might re-enter the IAX code and need the lock */					exists = ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num);				} else					exists = 0;				if (strcmp(iaxs[fr->callno]->exten, "TBD") && !exists) {					if (authdebug)						ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);					if (!iaxs[fr->callno]) {						break;					}				} else {					/* Select an appropriate format */					if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {							using_prefs = "reqonly";						} else {							using_prefs = "disabled";						}						format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;						memset(&pref, 0, sizeof(pref));						strcpy(caller_pref_buf, "disabled");						strcpy(host_pref_buf, "disabled");					} else {						struct ast_format tmpfmt;						using_prefs = "mine";						if (ies.codec_prefs)							ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);						if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {							if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {								pref = iaxs[fr->callno]->rprefs;								using_prefs = "caller";							} else {								pref = iaxs[fr->callno]->prefs;							}						} else /* if no codec_prefs IE do it the old way */							pref = iaxs[fr->callno]->prefs;						format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);						ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);						ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);					}					if (!format) {						char tmp1[256], tmp2[256], tmp3[256];						if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {							ast_debug(1, "We don't do requested format %s, falling back to peer capability '%s'\n",								iax2_getformatname(iaxs[fr->callno]->peerformat),								iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability));							format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;						}						if (!format) {							if (authdebug) {								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n", ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));								} else {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",										ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),										iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));								}							}							memset(&ied0, 0, sizeof(ied0));							iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");							iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);							send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);							if (!iaxs[fr->callno]) {								break;							}						} else {							/* Pick one... */							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))									format = 0;							} else {								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {									using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";									memset(&pref, 0, sizeof(pref));									format = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ?										iaxs[fr->callno]->peerformat : iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									strcpy(caller_pref_buf,"disabled");									strcpy(host_pref_buf,"disabled");								} else {									struct ast_format tmpfmt;									using_prefs = "mine";									if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {										/* Do the opposite of what we tried above. */										if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {											pref = iaxs[fr->callno]->prefs;										} else {											pref = iaxs[fr->callno]->rprefs;											using_prefs = "caller";										}										format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);									} else /* if no codec_prefs IE do it the old way */										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}							}							if (!format) {								char tmp1[256], tmp2[256], tmp3[256];								ast_log(LOG_ERROR, "No best format in %s???\n",									iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));								if (authdebug) {									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}							}						}					}					if (format) {						/* Authentication received */						memset(&ied1, 0, sizeof(ied1));						iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);						iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);						send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);						if (strcmp(iaxs[fr->callno]->exten, "TBD")) {							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							ast_verb(3, "Accepting AUTHENTICATED call from %s:\n"											"%srequested format = %s,\n"											"%srequested prefs = %s,\n"											"%sactual format = %s,\n"											"%shost prefs = %s,\n"											"%spriority = %s\n", 											ast_inet_ntoa(sin.sin_addr), 											VERBOSE_PREFIX_4,											iax2_getformatname(iaxs[fr->callno]->peerformat),											VERBOSE_PREFIX_4,											caller_pref_buf,											VERBOSE_PREFIX_4,											iax2_getformatname(format),											VERBOSE_PREFIX_4,											host_pref_buf,											VERBOSE_PREFIX_4,											using_prefs);							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, format, NULL, 1)))								iax2_destroy(fr->callno);							else if (ies.vars) {								struct ast_datastore *variablestore;								struct ast_variable *var, *prev = NULL;								AST_LIST_HEAD(, ast_var_t) *varlist;								varlist = ast_calloc(1, sizeof(*varlist));								variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);								if (variablestore && varlist) {									variablestore->data = varlist;									variablestore->inheritance = DATASTORE_INHERIT_FOREVER;									AST_LIST_HEAD_INIT(varlist);									ast_debug(1, "I can haz IAX vars? w00t\n");									for (var = ies.vars; var; var = var->next) {										struct ast_var_t *newvar = ast_var_assign(var->name, var->value);										if (prev)											ast_free(prev);										prev = var;										if (!newvar) {											/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */											ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");										} else {											AST_LIST_INSERT_TAIL(varlist, newvar, entries);										}									}									if (prev)										ast_free(prev);									ies.vars = NULL;									ast_channel_datastore_add(c, variablestore);								} else {									ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									if (variablestore)										ast_datastore_free(variablestore);									if (varlist)										ast_free(varlist);								}							}						} else {							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);							/* If this is a TBD call, we're ready but now what...  */							ast_verb(3, "Accepted AUTHENTICATED TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							if (ast_test_flag64(iaxs[fr->callno], IAX_IMMEDIATE)) {								goto immediatedial;							}						}					}				}				break;			case IAX_COMMAND_DIAL:immediatedial:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD)) {					ast_clear_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);					ast_string_field_set(iaxs[fr->callno], exten, ies.called_number ? ies.called_number : "s");					if (!ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num)) {						if (authdebug)							ast_log(LOG_NOTICE, "Rejected dial attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}					} else {						char tmp[256];						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);						ast_verb(3, "Accepting DIAL from %s, formats = %s\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat));						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);						send_command(iaxs[fr->callno], AST_FRAME_CONTROL, AST_CONTROL_PROGRESS, 0, NULL, 0, -1);						if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->peerformat, NULL, 1)))							iax2_destroy(fr->callno);						else if (ies.vars) {							struct ast_datastore *variablestore;							struct ast_variable *var, *prev = NULL;							AST_LIST_HEAD(, ast_var_t) *varlist;							varlist = ast_calloc(1, sizeof(*varlist));							variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);							ast_debug(1, "I can haz IAX vars? w00t\n");							if (variablestore && varlist) {								variablestore->data = varlist;								variablestore->inheritance = DATASTORE_INHERIT_FOREVER;								AST_LIST_HEAD_INIT(varlist);								for (var = ies.vars; var; var = var->next) {									struct ast_var_t *newvar = ast_var_assign(var->name, var->value);									if (prev)										ast_free(prev);									prev = var;									if (!newvar) {										/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */										ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									} else {										AST_LIST_INSERT_TAIL(varlist, newvar, entries);									}								}								if (prev)									ast_free(prev);								ies.vars = NULL;								ast_channel_datastore_add(c, variablestore);							} else {								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");								if (variablestore)									ast_datastore_free(variablestore);								if (varlist)									ast_free(varlist);							}						}					}				}				break;			case IAX_COMMAND_INVAL:				iaxs[fr->callno]->error = ENOTCONN;				ast_debug(1, "Immediately destroying %d, having received INVAL\n", fr->callno);				iax2_destroy(fr->callno);				ast_debug(1, "Destroying call %d\n", fr->callno);				break;			case IAX_COMMAND_VNAK:				ast_debug(1, "Received VNAK: resending outstanding frames\n");				/* Force retransmission */				vnak_retransmit(fr->callno, fr->iseqno);				break;			case IAX_COMMAND_REGREQ:			case IAX_COMMAND_REGREL:				/* For security, always ack immediately */				if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				if (register_verify(fr->callno, &sin, &ies)) {					if (!iaxs[fr->callno]) {						break;					}					/* Send delayed failure */					auth_fail(fr->callno, IAX_COMMAND_REGREJ);					break;				}				if (!iaxs[fr->callno]) {					break;				}				if ((ast_strlen_zero(iaxs[fr->callno]->secret) && ast_strlen_zero(iaxs[fr->callno]->inkeys)) ||						ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED)) {					if (f.subclass.integer == IAX_COMMAND_REGREL) {						memset(&sin, 0, sizeof(sin));						sin.sin_family = AF_INET;					}					if (update_registry(&sin, fr->callno, ies.devicetype, fd, ies.refresh)) {						ast_log(LOG_WARNING, "Registry error\n");					}					if (!iaxs[fr->callno]) {						break;					}					if (ies.provverpres && ies.serviceident && sin.sin_addr.s_addr) {						ast_mutex_unlock(&iaxsl[fr->callno]);						check_provisioning(&sin, fd, ies.serviceident, ies.provver);						ast_mutex_lock(&iaxsl[fr->callno]);					}					break;				}				registry_authrequest(fr->callno);				break;			case IAX_COMMAND_REGACK:				if (iax2_ack_registry(&ies, &sin, fr->callno)) 					ast_log(LOG_WARNING, "Registration failure\n");				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_REGREJ:				if (iaxs[fr->callno]->reg) {					if (authdebug) {						ast_log(LOG_NOTICE, "Registration of '%s' rejected: '%s' from: '%s'\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>", ast_inet_ntoa(sin.sin_addr));						manager_event(EVENT_FLAG_SYSTEM, "Registry", "ChannelType: IAX2\r\nUsername: %s\r\nStatus: Rejected\r\nCause: %s\r\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>");					}					iaxs[fr->callno]->reg->regstate = REG_STATE_REJECTED;				}				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_REGAUTH:				/* Authentication request */				if (registry_rerequest(&ies, fr->callno, &sin)) {					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No authority found");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_FACILITY_NOT_SUBSCRIBED);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);				}				break;			case IAX_COMMAND_TXREJ:				iaxs[fr->callno]->transferring = 0;				ast_verb(3, "Channel '%s' unable to transfer\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");				memset(&iaxs[fr->callno]->transfer, 0, sizeof(iaxs[fr->callno]->transfer));				if (iaxs[fr->callno]->bridgecallno) {					if (iaxs[iaxs[fr->callno]->bridgecallno]->transferring) {						iaxs[iaxs[fr->callno]->bridgecallno]->transferring = 0;						send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREJ, 0, NULL, 0, -1);					}				}				break;			case IAX_COMMAND_TXREADY:				if ((iaxs[fr->callno]->transferring == TRANSFER_BEGIN) ||				    (iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)) {					if (iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)						iaxs[fr->callno]->transferring = TRANSFER_MREADY;					else						iaxs[fr->callno]->transferring = TRANSFER_READY;					ast_verb(3, "Channel '%s' ready to transfer\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					if (iaxs[fr->callno]->bridgecallno) {						if ((iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_READY) ||						    (iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_MREADY)) {							/* They're both ready, now release them. */							if (iaxs[fr->callno]->transferring == TRANSFER_MREADY) {								ast_verb(3, "Attempting media bridge of %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_MEDIA;								iaxs[fr->callno]->transferring = TRANSFER_MEDIA;								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied1.buf, ied1.pos, -1);							} else {								ast_verb(3, "Releasing %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_RELEASED;								iaxs[fr->callno]->transferring = TRANSFER_RELEASED;								ast_set_flag64(iaxs[iaxs[fr->callno]->bridgecallno], IAX_ALREADYGONE);								ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);								/* Stop doing lag & ping requests */								stop_stuff(fr->callno);								stop_stuff(iaxs[fr->callno]->bridgecallno);								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied1.buf, ied1.pos, -1);							}						}					}				}				break;			case IAX_COMMAND_TXREQ:				try_transfer(iaxs[fr->callno], &ies);				break;			case IAX_COMMAND_TXCNT:				if (iaxs[fr->callno]->transferring)					send_command_transfer(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXACC, 0, NULL, 0);				break;			case IAX_COMMAND_TXREL:				/* Send ack immediately, rather than waiting until we've changed addresses */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				complete_transfer(fr->callno, &ies);				stop_stuff(fr->callno);	/* for attended transfer to work with libiax */				break;				case IAX_COMMAND_TXMEDIA:				if (iaxs[fr->callno]->transferring == TRANSFER_READY) {					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* Cancel any outstanding frames and start anew */						if (cur->transfer) {							cur->retries = -1;						}					}					/* Start sending our media to the transfer address, but otherwise leave the call as-is */					iaxs[fr->callno]->transferring = TRANSFER_MEDIAPASS;				}				break;			case IAX_COMMAND_RTKEY:				if (!IAX_CALLENCRYPTED(iaxs[fr->callno])) {					ast_log(LOG_WARNING, 						"we've been told to rotate our encryption key, "						"but this isn't an encrypted call. bad things will happen.\n"					);					break;				}				IAX_DEBUGDIGEST("Receiving", ies.challenge);				ast_aes_set_decrypt_key((unsigned char *) ies.challenge, &iaxs[fr->callno]->dcx);				break;			case IAX_COMMAND_DPREP:				complete_dpreply(iaxs[fr->callno], &ies);				break;			case IAX_COMMAND_UNSUPPORT:				ast_log(LOG_NOTICE, "Peer did not understand our iax command '%d'\n", ies.iax_unknown);				break;			case IAX_COMMAND_FWDOWNL:				/* Firmware download */				if (!ast_test_flag64(&globalflags, IAX_ALLOWFWDOWNLOAD)) {					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_UNSUPPORT, 0, NULL, 0, -1);					break;				}				memset(&ied0, 0, sizeof(ied0));				res = iax_firmware_append(&ied0, (unsigned char *)ies.devicetype, ies.fwdesc);				if (res < 0)					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);				else if (res > 0)					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1);				else					send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1);				break;			case IAX_COMMAND_CALLTOKEN:			{				struct iax_frame *cur;				/* find last sent frame */				if ((cur = AST_LIST_LAST(&frame_queue[fr->callno])) && ies.calltoken && ies.calltokendata) {					resend_with_token(fr->callno, cur, (char *) ies.calltokendata);				}				break;			}			default:				ast_debug(1, "Unknown IAX command %d on %d/%d\n", f.subclass.integer, fr->callno, iaxs[fr->callno]->peercallno);				memset(&ied0, 0, sizeof(ied0));				iax_ie_append_byte(&ied0, IAX_IE_IAX_UNKNOWN, f.subclass.integer);				send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_UNSUPPORT, 0, ied0.buf, ied0.pos, -1);			}			/* Free remote variables (if any) */			if (ies.vars) {				ast_variables_destroy(ies.vars);				ast_debug(1, "I can haz IAX vars, but they is no good :-(\n");				ies.vars = NULL;			}			/* Don't actually pass these frames along */			if ((f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&			  (f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_INVAL) &&			  (f.subclass.integer != IAX_COMMAND_VNAK)) {				if (iaxs[fr->callno] && iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);			}			ast_mutex_unlock(&iaxsl[fr->callno]);			return 1;		}		/* Unless this is an ACK or INVAL frame, ack it */		if (iaxs[fr->callno] && iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno)			send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);	}
struct sockaddr_in sin;
struct sockaddr_in sin;
struct sockaddr_in
sockaddr_in
sin
sin
int res;
int res;
int
res
res
int updatehistory=1;
int updatehistory=1;
int
updatehistory=1
updatehistory
=1
1
int new = NEW_PREVENT;
int dcallno = 0;
int dcallno = 0;
int
dcallno = 0
dcallno
= 0
0
char decrypted = 0;
char decrypted = 0;
char
decrypted = 0
decrypted
= 0
0
struct ast_iax2_full_hdr *fh = (struct ast_iax2_full_hdr *)thread->buf;
struct ast_iax2_full_hdr *fh = (struct ast_iax2_full_hdr *)thread->buf;
struct ast_iax2_full_hdr
ast_iax2_full_hdr
*fh = (struct ast_iax2_full_hdr *)thread->buf
*
fh
= (struct ast_iax2_full_hdr *)thread->buf
(struct ast_iax2_full_hdr *)thread->buf
struct ast_iax2_full_hdr *
struct ast_iax2_full_hdr
ast_iax2_full_hdr
*
*
thread->buf
thread
thread
buf
struct ast_iax2_mini_hdr *mh = (struct ast_iax2_mini_hdr *)thread->buf;
struct ast_iax2_mini_hdr *mh = (struct ast_iax2_mini_hdr *)thread->buf;
struct ast_iax2_mini_hdr
ast_iax2_mini_hdr
*mh = (struct ast_iax2_mini_hdr *)thread->buf
*
mh
= (struct ast_iax2_mini_hdr *)thread->buf
(struct ast_iax2_mini_hdr *)thread->buf
struct ast_iax2_mini_hdr *
struct ast_iax2_mini_hdr
ast_iax2_mini_hdr
*
*
thread->buf
thread
thread
buf
struct ast_iax2_meta_hdr *meta = (struct ast_iax2_meta_hdr *)thread->buf;
struct ast_iax2_meta_hdr *meta = (struct ast_iax2_meta_hdr *)thread->buf;
struct ast_iax2_meta_hdr
ast_iax2_meta_hdr
*meta = (struct ast_iax2_meta_hdr *)thread->buf
*
meta
= (struct ast_iax2_meta_hdr *)thread->buf
(struct ast_iax2_meta_hdr *)thread->buf
struct ast_iax2_meta_hdr *
struct ast_iax2_meta_hdr
ast_iax2_meta_hdr
*
*
thread->buf
thread
thread
buf
struct ast_iax2_video_hdr *vh = (struct ast_iax2_video_hdr *)thread->buf;
struct ast_iax2_video_hdr *vh = (struct ast_iax2_video_hdr *)thread->buf;
struct ast_iax2_video_hdr
ast_iax2_video_hdr
*vh = (struct ast_iax2_video_hdr *)thread->buf
*
vh
= (struct ast_iax2_video_hdr *)thread->buf
(struct ast_iax2_video_hdr *)thread->buf
struct ast_iax2_video_hdr *
struct ast_iax2_video_hdr
ast_iax2_video_hdr
*
*
thread->buf
thread
thread
buf
struct iax_frame *fr;
struct iax_frame *fr;
struct iax_frame
iax_frame
*fr
*
fr
struct iax_frame *cur;
struct iax_frame *cur;
struct iax_frame
iax_frame
*cur
*
cur
struct ast_frame f = { 0, };
struct ast_frame f = { 0, };
struct ast_frame
ast_frame
f = { 0, }
f
= { 0, }
{ 0, }
0
struct ast_channel *c = NULL;
struct ast_channel *c = NULL;
struct ast_channel
ast_channel
*c = NULL
*
c
= NULL
NULL
NULL
struct iax2_dpcache *dp;
struct iax2_dpcache *dp;
struct iax2_dpcache
iax2_dpcache
*dp
*
dp
struct iax2_peer *peer;
struct iax2_peer *peer;
struct iax2_peer
iax2_peer
*peer
*
peer
struct iax_ies ies;
struct iax_ies ies;
struct iax_ies
iax_ies
ies
ies
struct iax_ie_data ied0, ied1;
struct iax_ie_data ied0, ied1;
struct iax_ie_data
iax_ie_data
ied0
ied0
ied1
ied1
iax2_format format;
iax2_format format;
iax2_format
iax2_format
format
format
int fd;
int fd;
int
fd
fd
int exists;
int exists;
int
exists
exists
int minivid = 0;
int minivid = 0;
int
minivid = 0
minivid
= 0
0
char empty[32]="";
char empty[32]="";
char
empty[32]=""
empty
[32]
32
=""
""
struct iax_frame *duped_fr;
struct iax_frame *duped_fr;
struct iax_frame
iax_frame
*duped_fr
*
duped_fr
char host_pref_buf[128];
char host_pref_buf[128];
char
host_pref_buf[128]
host_pref_buf
[128]
128
char caller_pref_buf[128];
char caller_pref_buf[128];
char
caller_pref_buf[128]
caller_pref_buf
[128]
128
struct ast_codec_pref pref;
struct ast_codec_pref pref;
struct ast_codec_pref
ast_codec_pref
pref
pref
char *using_prefs = "mine";
char *using_prefs = "mine";
char
*using_prefs = "mine"
*
using_prefs
= "mine"
"mine"
fr = ast_alloca(sizeof(*fr) + 4096);
fr = ast_alloca(sizeof(*fr) + 4096)
fr
fr
ast_alloca(sizeof(*fr) + 4096)
ast_alloca
ast_alloca
sizeof(*fr) + 4096
sizeof(*fr)
(*fr)
*fr
fr
fr
4096
memset(fr, 0, sizeof(*fr));
memset(fr, 0, sizeof(*fr))
memset
memset
fr
fr
0
sizeof(*fr)
(*fr)
*fr
fr
fr
fr->afdatalen = 4096;
fr->afdatalen = 4096
fr->afdatalen
fr
fr
afdatalen
4096
res = thread->buf_len;
res = thread->buf_len
res
res
thread->buf_len
thread
thread
buf_len
fd = thread->iofd;
fd = thread->iofd
fd
fd
thread->iofd
thread
thread
iofd
memcpy(&sin, &thread->iosin, sizeof(sin));
memcpy(&sin, &thread->iosin, sizeof(sin))
memcpy
memcpy
&sin
sin
sin
&thread->iosin
thread->iosin
thread
thread
iosin
sizeof(sin)
(sin)
sin
sin
if (res < sizeof(*mh)) {		ast_log(LOG_WARNING, "midget packet received (%d of %d min)\n", res, (int) sizeof(*mh));		return 1;	}
res < sizeof(*mh)
res
res
sizeof(*mh)
(*mh)
*mh
mh
mh
{		ast_log(LOG_WARNING, "midget packet received (%d of %d min)\n", res, (int) sizeof(*mh));		return 1;	}
ast_log(LOG_WARNING, "midget packet received (%d of %d min)\n", res, (int) sizeof(*mh));
ast_log(LOG_WARNING, "midget packet received (%d of %d min)\n", res, (int) sizeof(*mh))
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"midget packet received (%d of %d min)\n"
res
res
(int) sizeof(*mh)
int
int

sizeof(*mh)
(*mh)
*mh
mh
mh
return 1;
1
if ((vh->zeros == 0) && (ntohs(vh->callno) & 0x8000)) {		if (res < sizeof(*vh)) {			ast_log(LOG_WARNING, "Rejecting packet from '%s.%d' that is flagged as a video frame but is too short\n", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));			return 1;		}		/* This is a video frame, get call number */		fr->callno = find_callno(ntohs(vh->callno) & ~0x8000, dcallno, &sin, new, fd, 0);		minivid = 1;	} else if ((meta->zeros == 0) && !(ntohs(meta->metacmd) & 0x8000))		return socket_process_meta(res, meta, &sin, fd, fr);
(vh->zeros == 0) && (ntohs(vh->callno) & 0x8000)
(vh->zeros == 0)
vh->zeros == 0
vh->zeros
vh
vh
zeros
0
(ntohs(vh->callno) & 0x8000)
ntohs(vh->callno) & 0x8000
ntohs(vh->callno)
ntohs
ntohs
vh->callno
vh
vh
callno
0x8000
{		if (res < sizeof(*vh)) {			ast_log(LOG_WARNING, "Rejecting packet from '%s.%d' that is flagged as a video frame but is too short\n", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));			return 1;		}		/* This is a video frame, get call number */		fr->callno = find_callno(ntohs(vh->callno) & ~0x8000, dcallno, &sin, new, fd, 0);		minivid = 1;	}
if (res < sizeof(*vh)) {			ast_log(LOG_WARNING, "Rejecting packet from '%s.%d' that is flagged as a video frame but is too short\n", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));			return 1;		}
res < sizeof(*vh)
res
res
sizeof(*vh)
(*vh)
*vh
vh
vh
{			ast_log(LOG_WARNING, "Rejecting packet from '%s.%d' that is flagged as a video frame but is too short\n", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));			return 1;		}
ast_log(LOG_WARNING, "Rejecting packet from '%s.%d' that is flagged as a video frame but is too short\n", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));
ast_log(LOG_WARNING, "Rejecting packet from '%s.%d' that is flagged as a video frame but is too short\n", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port))
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"Rejecting packet from '%s.%d' that is flagged as a video frame but is too short\n"
ast_inet_ntoa(sin.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
sin.sin_addr
sin
sin
sin_addr
ntohs(sin.sin_port)
ntohs
ntohs
sin.sin_port
sin
sin
sin_port
return 1;
1
fr->callno = find_callno(ntohs(vh->callno) & ~0x8000, dcallno, &sin, new, fd, 0);
minivid = 1;
minivid = 1
minivid
minivid
1
if ((meta->zeros == 0) && !(ntohs(meta->metacmd) & 0x8000))		return socket_process_meta(res, meta, &sin, fd, fr);
(meta->zeros == 0) && !(ntohs(meta->metacmd) & 0x8000)
(meta->zeros == 0)
meta->zeros == 0
meta->zeros
meta
meta
zeros
0
!(ntohs(meta->metacmd) & 0x8000)
(ntohs(meta->metacmd) & 0x8000)
ntohs(meta->metacmd) & 0x8000
ntohs(meta->metacmd)
ntohs
ntohs
meta->metacmd
meta
meta
metacmd
0x8000
return socket_process_meta(res, meta, &sin, fd, fr);
socket_process_meta(res, meta, &sin, fd, fr)
socket_process_meta
socket_process_meta
res
res
meta
meta
&sin
sin
sin
fd
fd
fr
fr
if (ntohs(mh->callno) & IAX_FLAG_FULL) {		if (res < sizeof(*fh)) {			ast_log(LOG_WARNING, "Rejecting packet from '%s.%d' that is flagged as a full frame but is too short\n", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));			return 1;		}		/* Get the destination call number */		dcallno = ntohs(fh->dcallno) & ~IAX_FLAG_RETRANS;		/* check to make sure this full frame isn't encrypted before we attempt 		 * to look inside of it. If it is encrypted, decrypt it first. Its ok if the		 * callno is not found here, that just means one hasn't been allocated for		 * this connection yet. */		if ((dcallno != 1) && (fr->callno = find_callno(ntohs(mh->callno) & ~IAX_FLAG_FULL, dcallno, &sin, NEW_PREVENT, fd, 1))) {			ast_mutex_lock(&iaxsl[fr->callno]);			if (iaxs[fr->callno] && ast_test_flag64(iaxs[fr->callno], IAX_ENCRYPTED)) {				if (decrypt_frame(fr->callno, fh, &f, &res)) {					ast_log(LOG_NOTICE, "Packet Decrypt Failed!\n");					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}				decrypted = 1;			}			ast_mutex_unlock(&iaxsl[fr->callno]);		}		/* Retrieve the type and subclass */		f.frametype = fh->type;		if (f.frametype == AST_FRAME_VIDEO) {			ast_format_from_old_bitfield(&f.subclass.format, (uncompress_subclass(fh->csub & ~0x40)));			if ((fh->csub >> 6) & 0x1) {				ast_format_set_video_mark(&f.subclass.format);			}		} else if (f.frametype == AST_FRAME_VOICE) {			ast_format_from_old_bitfield(&f.subclass.format, uncompress_subclass(fh->csub));		} else {			f.subclass.integer = uncompress_subclass(fh->csub);		}		/* Deal with POKE/PONG without allocating a callno */		if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_POKE) {			/* Reply back with a PONG, but don't care about the result. */			send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_PONG, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			return 1;		} else if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_ACK && dcallno == 1) {			/* Ignore */			return 1;		}		f.datalen = res - sizeof(*fh);		if (f.datalen) {			if (f.frametype == AST_FRAME_IAX) {				if (iax_parse_ies(&ies, thread->buf + sizeof(struct ast_iax2_full_hdr), f.datalen)) {					ast_log(LOG_WARNING, "Undecodable frame received from '%s'\n", ast_inet_ntoa(sin.sin_addr));					ast_variables_destroy(ies.vars);					return 1;				}				f.data.ptr = NULL;				f.datalen = 0;			} else {				f.data.ptr = thread->buf + sizeof(struct ast_iax2_full_hdr);				memset(&ies, 0, sizeof(ies));			}		} else {			if (f.frametype == AST_FRAME_IAX)				f.data.ptr = NULL;			else				f.data.ptr = empty;			memset(&ies, 0, sizeof(ies));		}		if (!dcallno && iax2_allow_new(f.frametype, f.subclass.integer, 1)) {			/* only set NEW_ALLOW if calltoken checks out */			if (handle_call_token(fh, &ies, &sin, fd)) {				ast_variables_destroy(ies.vars);				return 1;			}			if (ies.calltoken && ies.calltokendata) {				/* if we've gotten this far, and the calltoken ie data exists,				 * then calltoken validation _MUST_ have taken place.  If calltoken				 * data is provided, it is always validated reguardless of any				 * calltokenoptional or requirecalltoken options */				new = NEW_ALLOW_CALLTOKEN_VALIDATED;			} else {				new = NEW_ALLOW;			}		}	} else {		/* Don't know anything about it yet */		f.frametype = AST_FRAME_NULL;		f.subclass.integer = 0;		memset(&ies, 0, sizeof(ies));	}
ntohs(mh->callno) & IAX_FLAG_FULL
ntohs(mh->callno)
ntohs
ntohs
mh->callno
mh
mh
callno
IAX_FLAG_FULL
IAX_FLAG_FULL
{		if (res < sizeof(*fh)) {			ast_log(LOG_WARNING, "Rejecting packet from '%s.%d' that is flagged as a full frame but is too short\n", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));			return 1;		}		/* Get the destination call number */		dcallno = ntohs(fh->dcallno) & ~IAX_FLAG_RETRANS;		/* check to make sure this full frame isn't encrypted before we attempt 		 * to look inside of it. If it is encrypted, decrypt it first. Its ok if the		 * callno is not found here, that just means one hasn't been allocated for		 * this connection yet. */		if ((dcallno != 1) && (fr->callno = find_callno(ntohs(mh->callno) & ~IAX_FLAG_FULL, dcallno, &sin, NEW_PREVENT, fd, 1))) {			ast_mutex_lock(&iaxsl[fr->callno]);			if (iaxs[fr->callno] && ast_test_flag64(iaxs[fr->callno], IAX_ENCRYPTED)) {				if (decrypt_frame(fr->callno, fh, &f, &res)) {					ast_log(LOG_NOTICE, "Packet Decrypt Failed!\n");					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}				decrypted = 1;			}			ast_mutex_unlock(&iaxsl[fr->callno]);		}		/* Retrieve the type and subclass */		f.frametype = fh->type;		if (f.frametype == AST_FRAME_VIDEO) {			ast_format_from_old_bitfield(&f.subclass.format, (uncompress_subclass(fh->csub & ~0x40)));			if ((fh->csub >> 6) & 0x1) {				ast_format_set_video_mark(&f.subclass.format);			}		} else if (f.frametype == AST_FRAME_VOICE) {			ast_format_from_old_bitfield(&f.subclass.format, uncompress_subclass(fh->csub));		} else {			f.subclass.integer = uncompress_subclass(fh->csub);		}		/* Deal with POKE/PONG without allocating a callno */		if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_POKE) {			/* Reply back with a PONG, but don't care about the result. */			send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_PONG, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			return 1;		} else if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_ACK && dcallno == 1) {			/* Ignore */			return 1;		}		f.datalen = res - sizeof(*fh);		if (f.datalen) {			if (f.frametype == AST_FRAME_IAX) {				if (iax_parse_ies(&ies, thread->buf + sizeof(struct ast_iax2_full_hdr), f.datalen)) {					ast_log(LOG_WARNING, "Undecodable frame received from '%s'\n", ast_inet_ntoa(sin.sin_addr));					ast_variables_destroy(ies.vars);					return 1;				}				f.data.ptr = NULL;				f.datalen = 0;			} else {				f.data.ptr = thread->buf + sizeof(struct ast_iax2_full_hdr);				memset(&ies, 0, sizeof(ies));			}		} else {			if (f.frametype == AST_FRAME_IAX)				f.data.ptr = NULL;			else				f.data.ptr = empty;			memset(&ies, 0, sizeof(ies));		}		if (!dcallno && iax2_allow_new(f.frametype, f.subclass.integer, 1)) {			/* only set NEW_ALLOW if calltoken checks out */			if (handle_call_token(fh, &ies, &sin, fd)) {				ast_variables_destroy(ies.vars);				return 1;			}			if (ies.calltoken && ies.calltokendata) {				/* if we've gotten this far, and the calltoken ie data exists,				 * then calltoken validation _MUST_ have taken place.  If calltoken				 * data is provided, it is always validated reguardless of any				 * calltokenoptional or requirecalltoken options */				new = NEW_ALLOW_CALLTOKEN_VALIDATED;			} else {				new = NEW_ALLOW;			}		}	}
if (res < sizeof(*fh)) {			ast_log(LOG_WARNING, "Rejecting packet from '%s.%d' that is flagged as a full frame but is too short\n", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));			return 1;		}
res < sizeof(*fh)
res
res
sizeof(*fh)
(*fh)
*fh
fh
fh
{			ast_log(LOG_WARNING, "Rejecting packet from '%s.%d' that is flagged as a full frame but is too short\n", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));			return 1;		}
ast_log(LOG_WARNING, "Rejecting packet from '%s.%d' that is flagged as a full frame but is too short\n", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));
ast_log(LOG_WARNING, "Rejecting packet from '%s.%d' that is flagged as a full frame but is too short\n", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port))
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"Rejecting packet from '%s.%d' that is flagged as a full frame but is too short\n"
ast_inet_ntoa(sin.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
sin.sin_addr
sin
sin
sin_addr
ntohs(sin.sin_port)
ntohs
ntohs
sin.sin_port
sin
sin
sin_port
return 1;
1
dcallno = ntohs(fh->dcallno) & ~IAX_FLAG_RETRANS;
dcallno = ntohs(fh->dcallno) & ~IAX_FLAG_RETRANS
dcallno
dcallno
ntohs(fh->dcallno) & ~IAX_FLAG_RETRANS
ntohs(fh->dcallno)
ntohs
ntohs
fh->dcallno
fh
fh
dcallno
~IAX_FLAG_RETRANS
IAX_FLAG_RETRANS
IAX_FLAG_RETRANS
if ((dcallno != 1) && (fr->callno = find_callno(ntohs(mh->callno) & ~IAX_FLAG_FULL, dcallno, &sin, NEW_PREVENT, fd, 1))) {			ast_mutex_lock(&iaxsl[fr->callno]);			if (iaxs[fr->callno] && ast_test_flag64(iaxs[fr->callno], IAX_ENCRYPTED)) {				if (decrypt_frame(fr->callno, fh, &f, &res)) {					ast_log(LOG_NOTICE, "Packet Decrypt Failed!\n");					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}				decrypted = 1;			}			ast_mutex_unlock(&iaxsl[fr->callno]);		}
(dcallno != 1) && (fr->callno = find_callno(ntohs(mh->callno) & ~IAX_FLAG_FULL, dcallno, &sin, NEW_PREVENT, fd, 1))
(dcallno != 1)
dcallno != 1
dcallno
dcallno
1
(fr->callno = find_callno(ntohs(mh->callno) & ~IAX_FLAG_FULL, dcallno, &sin, NEW_PREVENT, fd, 1))
fr->callno = find_callno(ntohs(mh->callno) & ~IAX_FLAG_FULL, dcallno, &sin, NEW_PREVENT, fd, 1)
fr->callno
fr
fr
callno
find_callno(ntohs(mh->callno) & ~IAX_FLAG_FULL, dcallno, &sin, NEW_PREVENT, fd, 1)
find_callno
find_callno
ntohs(mh->callno) & ~IAX_FLAG_FULL
ntohs(mh->callno)
ntohs
ntohs
mh->callno
mh
mh
callno
~IAX_FLAG_FULL
IAX_FLAG_FULL
IAX_FLAG_FULL
dcallno
dcallno
&sin
sin
sin
NEW_PREVENT
NEW_PREVENT
fd
fd
1
{			ast_mutex_lock(&iaxsl[fr->callno]);			if (iaxs[fr->callno] && ast_test_flag64(iaxs[fr->callno], IAX_ENCRYPTED)) {				if (decrypt_frame(fr->callno, fh, &f, &res)) {					ast_log(LOG_NOTICE, "Packet Decrypt Failed!\n");					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}				decrypted = 1;			}			ast_mutex_unlock(&iaxsl[fr->callno]);		}
ast_mutex_lock(&iaxsl[fr->callno]);
ast_mutex_lock(&iaxsl[fr->callno]);
ast_mutex_lock
ast_mutex_lock
(&iaxsl[fr->callno])
&iaxsl[fr->callno]
&
iaxsl
[fr->callno]
fr->callno
fr
fr
callno
if (iaxs[fr->callno] && ast_test_flag64(iaxs[fr->callno], IAX_ENCRYPTED)) {				if (decrypt_frame(fr->callno, fh, &f, &res)) {					ast_log(LOG_NOTICE, "Packet Decrypt Failed!\n");					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}				decrypted = 1;			}
iaxs[fr->callno] && ast_test_flag64(iaxs[fr->callno], IAX_ENCRYPTED)
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
ast_test_flag64(iaxs[fr->callno], IAX_ENCRYPTED)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_ENCRYPTED
IAX_ENCRYPTED
{				if (decrypt_frame(fr->callno, fh, &f, &res)) {					ast_log(LOG_NOTICE, "Packet Decrypt Failed!\n");					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}				decrypted = 1;			}
if (decrypt_frame(fr->callno, fh, &f, &res)) {					ast_log(LOG_NOTICE, "Packet Decrypt Failed!\n");					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}
decrypt_frame(fr->callno, fh, &f, &res)
decrypt_frame
decrypt_frame
fr->callno
fr
fr
callno
fh
fh
&f
f
f
&res
res
res
{					ast_log(LOG_NOTICE, "Packet Decrypt Failed!\n");					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}
ast_log(LOG_NOTICE, "Packet Decrypt Failed!\n");
ast_log(LOG_NOTICE, "Packet Decrypt Failed!\n")
ast_log
ast_log
LOG_NOTICE
LOG_NOTICE
"Packet Decrypt Failed!\n"
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock(&iaxsl[fr->callno])
ast_mutex_unlock
ast_mutex_unlock
&iaxsl[fr->callno]
iaxsl[fr->callno]
iaxsl
iaxsl
fr->callno
fr
fr
callno
return 1;
1
decrypted = 1;
decrypted = 1
decrypted
decrypted
1
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock(&iaxsl[fr->callno])
ast_mutex_unlock
ast_mutex_unlock
&iaxsl[fr->callno]
iaxsl[fr->callno]
iaxsl
iaxsl
fr->callno
fr
fr
callno
f.frametype = fh->type;
f.frametype = fh->type
f.frametype
f
f
frametype
fh->type
fh
fh
type
if (f.frametype == AST_FRAME_VIDEO) {			ast_format_from_old_bitfield(&f.subclass.format, (uncompress_subclass(fh->csub & ~0x40)));			if ((fh->csub >> 6) & 0x1) {				ast_format_set_video_mark(&f.subclass.format);			}		} else if (f.frametype == AST_FRAME_VOICE) {			ast_format_from_old_bitfield(&f.subclass.format, uncompress_subclass(fh->csub));		} else {			f.subclass.integer = uncompress_subclass(fh->csub);		}
f.frametype == AST_FRAME_VIDEO
f.frametype
f
f
frametype
AST_FRAME_VIDEO
AST_FRAME_VIDEO
{			ast_format_from_old_bitfield(&f.subclass.format, (uncompress_subclass(fh->csub & ~0x40)));			if ((fh->csub >> 6) & 0x1) {				ast_format_set_video_mark(&f.subclass.format);			}		}
ast_format_from_old_bitfield(&f.subclass.format, (uncompress_subclass(fh->csub & ~0x40)));
ast_format_from_old_bitfield(&f.subclass.format, (uncompress_subclass(fh->csub & ~0x40)))
ast_format_from_old_bitfield
ast_format_from_old_bitfield
&f.subclass.format
f.subclass.format
f.subclass
f
f
subclass
format
(uncompress_subclass(fh->csub & ~0x40))
uncompress_subclass(fh->csub & ~0x40)
uncompress_subclass
uncompress_subclass
fh->csub & ~0x40
fh->csub
fh
fh
csub
~0x40
0x40
if ((fh->csub >> 6) & 0x1) {				ast_format_set_video_mark(&f.subclass.format);			}
(fh->csub >> 6) & 0x1
(fh->csub >> 6)
fh->csub >> 6
fh->csub
fh
fh
csub
6
0x1
{				ast_format_set_video_mark(&f.subclass.format);			}
ast_format_set_video_mark(&f.subclass.format);
ast_format_set_video_mark(&f.subclass.format)
ast_format_set_video_mark
ast_format_set_video_mark
&f.subclass.format
f.subclass.format
f.subclass
f
f
subclass
format
if (f.frametype == AST_FRAME_VOICE) {			ast_format_from_old_bitfield(&f.subclass.format, uncompress_subclass(fh->csub));		} else {			f.subclass.integer = uncompress_subclass(fh->csub);		}
f.frametype == AST_FRAME_VOICE
f.frametype
f
f
frametype
AST_FRAME_VOICE
AST_FRAME_VOICE
{			ast_format_from_old_bitfield(&f.subclass.format, uncompress_subclass(fh->csub));		}
ast_format_from_old_bitfield(&f.subclass.format, uncompress_subclass(fh->csub));
ast_format_from_old_bitfield(&f.subclass.format, uncompress_subclass(fh->csub))
ast_format_from_old_bitfield
ast_format_from_old_bitfield
&f.subclass.format
f.subclass.format
f.subclass
f
f
subclass
format
uncompress_subclass(fh->csub)
uncompress_subclass
uncompress_subclass
fh->csub
fh
fh
csub
{			f.subclass.integer = uncompress_subclass(fh->csub);		}
f.subclass.integer = uncompress_subclass(fh->csub);
f.subclass.integer = uncompress_subclass(fh->csub)
f.subclass.integer
f.subclass
f
f
subclass
integer
uncompress_subclass(fh->csub)
uncompress_subclass
uncompress_subclass
fh->csub
fh
fh
csub
if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_POKE) {			/* Reply back with a PONG, but don't care about the result. */			send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_PONG, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			return 1;		} else if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_ACK && dcallno == 1) {			/* Ignore */			return 1;		}
f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_POKE
f.frametype == AST_FRAME_IAX
f.frametype
f
f
frametype
AST_FRAME_IAX
AST_FRAME_IAX
f.subclass.integer == IAX_COMMAND_POKE
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_POKE
IAX_COMMAND_POKE
{			/* Reply back with a PONG, but don't care about the result. */			send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_PONG, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			return 1;		}
send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_PONG, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);
send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_PONG, ntohl(fh->ts), fh->iseqno + 1, fd, NULL)
send_apathetic_reply
send_apathetic_reply
1
ntohs(fh->scallno)
ntohs
ntohs
fh->scallno
fh
fh
scallno
&sin
sin
sin
IAX_COMMAND_PONG
IAX_COMMAND_PONG
ntohl(fh->ts)
ntohl
ntohl
fh->ts
fh
fh
ts
fh->iseqno + 1
fh->iseqno
fh
fh
iseqno
1
fd
fd
NULL
NULL
return 1;
1
if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_ACK && dcallno == 1) {			/* Ignore */			return 1;		}
f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_ACK && dcallno == 1
f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_ACK
f.frametype == AST_FRAME_IAX
f.frametype
f
f
frametype
AST_FRAME_IAX
AST_FRAME_IAX
f.subclass.integer == IAX_COMMAND_ACK
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_ACK
IAX_COMMAND_ACK
dcallno == 1
dcallno
dcallno
1
{			/* Ignore */			return 1;		}
return 1;
1
f.datalen = res - sizeof(*fh);
f.datalen = res - sizeof(*fh)
f.datalen
f
f
datalen
res - sizeof(*fh)
res
res
sizeof(*fh)
(*fh)
*fh
fh
fh
if (f.datalen) {			if (f.frametype == AST_FRAME_IAX) {				if (iax_parse_ies(&ies, thread->buf + sizeof(struct ast_iax2_full_hdr), f.datalen)) {					ast_log(LOG_WARNING, "Undecodable frame received from '%s'\n", ast_inet_ntoa(sin.sin_addr));					ast_variables_destroy(ies.vars);					return 1;				}				f.data.ptr = NULL;				f.datalen = 0;			} else {				f.data.ptr = thread->buf + sizeof(struct ast_iax2_full_hdr);				memset(&ies, 0, sizeof(ies));			}		} else {			if (f.frametype == AST_FRAME_IAX)				f.data.ptr = NULL;			else				f.data.ptr = empty;			memset(&ies, 0, sizeof(ies));		}
f.datalen
f
f
datalen
{			if (f.frametype == AST_FRAME_IAX) {				if (iax_parse_ies(&ies, thread->buf + sizeof(struct ast_iax2_full_hdr), f.datalen)) {					ast_log(LOG_WARNING, "Undecodable frame received from '%s'\n", ast_inet_ntoa(sin.sin_addr));					ast_variables_destroy(ies.vars);					return 1;				}				f.data.ptr = NULL;				f.datalen = 0;			} else {				f.data.ptr = thread->buf + sizeof(struct ast_iax2_full_hdr);				memset(&ies, 0, sizeof(ies));			}		}
if (f.frametype == AST_FRAME_IAX) {				if (iax_parse_ies(&ies, thread->buf + sizeof(struct ast_iax2_full_hdr), f.datalen)) {					ast_log(LOG_WARNING, "Undecodable frame received from '%s'\n", ast_inet_ntoa(sin.sin_addr));					ast_variables_destroy(ies.vars);					return 1;				}				f.data.ptr = NULL;				f.datalen = 0;			} else {				f.data.ptr = thread->buf + sizeof(struct ast_iax2_full_hdr);				memset(&ies, 0, sizeof(ies));			}
f.frametype == AST_FRAME_IAX
f.frametype
f
f
frametype
AST_FRAME_IAX
AST_FRAME_IAX
{				if (iax_parse_ies(&ies, thread->buf + sizeof(struct ast_iax2_full_hdr), f.datalen)) {					ast_log(LOG_WARNING, "Undecodable frame received from '%s'\n", ast_inet_ntoa(sin.sin_addr));					ast_variables_destroy(ies.vars);					return 1;				}				f.data.ptr = NULL;				f.datalen = 0;			}
if (iax_parse_ies(&ies, thread->buf + sizeof(struct ast_iax2_full_hdr), f.datalen)) {					ast_log(LOG_WARNING, "Undecodable frame received from '%s'\n", ast_inet_ntoa(sin.sin_addr));					ast_variables_destroy(ies.vars);					return 1;				}
iax_parse_ies(&ies, thread->buf + sizeof(struct ast_iax2_full_hdr), f.datalen)
iax_parse_ies
iax_parse_ies
&ies
ies
ies
thread->buf + sizeof(struct ast_iax2_full_hdr)
thread->buf
thread
thread
buf
sizeof(struct ast_iax2_full_hdr)
struct ast_iax2_full_hdr
struct ast_iax2_full_hdr
ast_iax2_full_hdr

f.datalen
f
f
datalen
{					ast_log(LOG_WARNING, "Undecodable frame received from '%s'\n", ast_inet_ntoa(sin.sin_addr));					ast_variables_destroy(ies.vars);					return 1;				}
ast_log(LOG_WARNING, "Undecodable frame received from '%s'\n", ast_inet_ntoa(sin.sin_addr));
ast_log(LOG_WARNING, "Undecodable frame received from '%s'\n", ast_inet_ntoa(sin.sin_addr))
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"Undecodable frame received from '%s'\n"
ast_inet_ntoa(sin.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
sin.sin_addr
sin
sin
sin_addr
ast_variables_destroy(ies.vars);
ast_variables_destroy(ies.vars)
ast_variables_destroy
ast_variables_destroy
ies.vars
ies
ies
vars
return 1;
1
f.data.ptr = NULL;
f.data.ptr = NULL
f.data.ptr
f.data
f
f
data
ptr
NULL
NULL
f.datalen = 0;
f.datalen = 0
f.datalen
f
f
datalen
0
{				f.data.ptr = thread->buf + sizeof(struct ast_iax2_full_hdr);				memset(&ies, 0, sizeof(ies));			}
f.data.ptr = thread->buf + sizeof(struct ast_iax2_full_hdr);
f.data.ptr = thread->buf + sizeof(struct ast_iax2_full_hdr)
f.data.ptr
f.data
f
f
data
ptr
thread->buf + sizeof(struct ast_iax2_full_hdr)
thread->buf
thread
thread
buf
sizeof(struct ast_iax2_full_hdr)
struct ast_iax2_full_hdr
struct ast_iax2_full_hdr
ast_iax2_full_hdr

memset(&ies, 0, sizeof(ies));
memset(&ies, 0, sizeof(ies))
memset
memset
&ies
ies
ies
0
sizeof(ies)
(ies)
ies
ies
{			if (f.frametype == AST_FRAME_IAX)				f.data.ptr = NULL;			else				f.data.ptr = empty;			memset(&ies, 0, sizeof(ies));		}
if (f.frametype == AST_FRAME_IAX)				f.data.ptr = NULL;			else				f.data.ptr = empty;
f.frametype == AST_FRAME_IAX
f.frametype
f
f
frametype
AST_FRAME_IAX
AST_FRAME_IAX
f.data.ptr = NULL;
f.data.ptr = NULL
f.data.ptr
f.data
f
f
data
ptr
NULL
NULL
f.data.ptr = empty;
f.data.ptr = empty
f.data.ptr
f.data
f
f
data
ptr
empty
empty
memset(&ies, 0, sizeof(ies));
memset(&ies, 0, sizeof(ies))
memset
memset
&ies
ies
ies
0
sizeof(ies)
(ies)
ies
ies
if (!dcallno && iax2_allow_new(f.frametype, f.subclass.integer, 1)) {			/* only set NEW_ALLOW if calltoken checks out */			if (handle_call_token(fh, &ies, &sin, fd)) {				ast_variables_destroy(ies.vars);				return 1;			}			if (ies.calltoken && ies.calltokendata) {				/* if we've gotten this far, and the calltoken ie data exists,				 * then calltoken validation _MUST_ have taken place.  If calltoken				 * data is provided, it is always validated reguardless of any				 * calltokenoptional or requirecalltoken options */				new = NEW_ALLOW_CALLTOKEN_VALIDATED;			} else {				new = NEW_ALLOW;			}		}
!dcallno && iax2_allow_new(f.frametype, f.subclass.integer, 1)
!dcallno
dcallno
dcallno
iax2_allow_new(f.frametype, f.subclass.integer, 1)
iax2_allow_new
iax2_allow_new
f.frametype
f
f
frametype
f.subclass.integer
f.subclass
f
f
subclass
integer
1
{			/* only set NEW_ALLOW if calltoken checks out */			if (handle_call_token(fh, &ies, &sin, fd)) {				ast_variables_destroy(ies.vars);				return 1;			}			if (ies.calltoken && ies.calltokendata) {				/* if we've gotten this far, and the calltoken ie data exists,				 * then calltoken validation _MUST_ have taken place.  If calltoken				 * data is provided, it is always validated reguardless of any				 * calltokenoptional or requirecalltoken options */				new = NEW_ALLOW_CALLTOKEN_VALIDATED;			} else {				new = NEW_ALLOW;			}		}
if (handle_call_token(fh, &ies, &sin, fd)) {				ast_variables_destroy(ies.vars);				return 1;			}
handle_call_token(fh, &ies, &sin, fd)
handle_call_token
handle_call_token
fh
fh
&ies
ies
ies
&sin
sin
sin
fd
fd
{				ast_variables_destroy(ies.vars);				return 1;			}
ast_variables_destroy(ies.vars);
ast_variables_destroy(ies.vars)
ast_variables_destroy
ast_variables_destroy
ies.vars
ies
ies
vars
return 1;
1
if (ies.calltoken && ies.calltokendata) {				/* if we've gotten this far, and the calltoken ie data exists,				 * then calltoken validation _MUST_ have taken place.  If calltoken				 * data is provided, it is always validated reguardless of any				 * calltokenoptional or requirecalltoken options */				new = NEW_ALLOW_CALLTOKEN_VALIDATED;			} else {				new = NEW_ALLOW;			}
ies.calltoken && ies.calltokendata
ies.calltoken
ies
ies
calltoken
ies.calltokendata
ies
ies
calltokendata
{				/* if we've gotten this far, and the calltoken ie data exists,				 * then calltoken validation _MUST_ have taken place.  If calltoken				 * data is provided, it is always validated reguardless of any				 * calltokenoptional or requirecalltoken options */				new = NEW_ALLOW_CALLTOKEN_VALIDATED;			}
new = NEW_ALLOW_CALLTOKEN_VALIDATED;
{				new = NEW_ALLOW;			}
new = NEW_ALLOW;
{		/* Don't know anything about it yet */		f.frametype = AST_FRAME_NULL;		f.subclass.integer = 0;		memset(&ies, 0, sizeof(ies));	}
f.frametype = AST_FRAME_NULL;
f.frametype = AST_FRAME_NULL
f.frametype
f
f
frametype
AST_FRAME_NULL
AST_FRAME_NULL
f.subclass.integer = 0;
f.subclass.integer = 0
f.subclass.integer
f.subclass
f
f
subclass
integer
0
memset(&ies, 0, sizeof(ies));
memset(&ies, 0, sizeof(ies))
memset
memset
&ies
ies
ies
0
sizeof(ies)
(ies)
ies
ies
if (!fr->callno) {		int check_dcallno = 0;		/*		 * We enforce accurate destination call numbers for ACKs.  This forces the other		 * end to know the destination call number before call setup can complete.		 *		 * Discussed in the following thread:		 *    http://lists.digium.com/pipermail/asterisk-dev/2008-May/033217.html 		 */		if ((ntohs(mh->callno) & IAX_FLAG_FULL) && ((f.frametype == AST_FRAME_IAX) && (f.subclass.integer == IAX_COMMAND_ACK))) {			check_dcallno = 1;		}		if (!(fr->callno = find_callno(ntohs(mh->callno) & ~IAX_FLAG_FULL, dcallno, &sin, new, fd, check_dcallno))) {			if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_NEW) {				send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REJECT, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			} else if (f.frametype == AST_FRAME_IAX && (f.subclass.integer == IAX_COMMAND_REGREQ || f.subclass.integer == IAX_COMMAND_REGREL)) {				send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REGREJ, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			}			ast_variables_destroy(ies.vars);			return 1;		}	}
!fr->callno
fr->callno
fr
fr
callno
{		int check_dcallno = 0;		/*		 * We enforce accurate destination call numbers for ACKs.  This forces the other		 * end to know the destination call number before call setup can complete.		 *		 * Discussed in the following thread:		 *    http://lists.digium.com/pipermail/asterisk-dev/2008-May/033217.html 		 */		if ((ntohs(mh->callno) & IAX_FLAG_FULL) && ((f.frametype == AST_FRAME_IAX) && (f.subclass.integer == IAX_COMMAND_ACK))) {			check_dcallno = 1;		}		if (!(fr->callno = find_callno(ntohs(mh->callno) & ~IAX_FLAG_FULL, dcallno, &sin, new, fd, check_dcallno))) {			if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_NEW) {				send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REJECT, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			} else if (f.frametype == AST_FRAME_IAX && (f.subclass.integer == IAX_COMMAND_REGREQ || f.subclass.integer == IAX_COMMAND_REGREL)) {				send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REGREJ, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			}			ast_variables_destroy(ies.vars);			return 1;		}	}
int check_dcallno = 0;
int check_dcallno = 0;
int
check_dcallno = 0
check_dcallno
= 0
0
if ((ntohs(mh->callno) & IAX_FLAG_FULL) && ((f.frametype == AST_FRAME_IAX) && (f.subclass.integer == IAX_COMMAND_ACK))) {			check_dcallno = 1;		}
(ntohs(mh->callno) & IAX_FLAG_FULL) && ((f.frametype == AST_FRAME_IAX) && (f.subclass.integer == IAX_COMMAND_ACK))
(ntohs(mh->callno) & IAX_FLAG_FULL)
ntohs(mh->callno) & IAX_FLAG_FULL
ntohs(mh->callno)
ntohs
ntohs
mh->callno
mh
mh
callno
IAX_FLAG_FULL
IAX_FLAG_FULL
((f.frametype == AST_FRAME_IAX) && (f.subclass.integer == IAX_COMMAND_ACK))
(f.frametype == AST_FRAME_IAX) && (f.subclass.integer == IAX_COMMAND_ACK)
(f.frametype == AST_FRAME_IAX)
f.frametype == AST_FRAME_IAX
f.frametype
f
f
frametype
AST_FRAME_IAX
AST_FRAME_IAX
(f.subclass.integer == IAX_COMMAND_ACK)
f.subclass.integer == IAX_COMMAND_ACK
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_ACK
IAX_COMMAND_ACK
{			check_dcallno = 1;		}
check_dcallno = 1;
check_dcallno = 1
check_dcallno
check_dcallno
1
if (!(fr->callno = find_callno(ntohs(mh->callno) & ~IAX_FLAG_FULL, dcallno, &sin, new, fd, check_dcallno))) {			if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_NEW) {				send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REJECT, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			} else if (f.frametype == AST_FRAME_IAX && (f.subclass.integer == IAX_COMMAND_REGREQ || f.subclass.integer == IAX_COMMAND_REGREL)) {				send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REGREJ, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			}			ast_variables_destroy(ies.vars);			return 1;		}
!(fr->callno = find_callno(ntohs(mh->callno) & ~IAX_FLAG_FULL, dcallno, &sin, new, fd, check_dcallno))
{			if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_NEW) {				send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REJECT, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			} else if (f.frametype == AST_FRAME_IAX && (f.subclass.integer == IAX_COMMAND_REGREQ || f.subclass.integer == IAX_COMMAND_REGREL)) {				send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REGREJ, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			}			ast_variables_destroy(ies.vars);			return 1;		}
if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_NEW) {				send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REJECT, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			} else if (f.frametype == AST_FRAME_IAX && (f.subclass.integer == IAX_COMMAND_REGREQ || f.subclass.integer == IAX_COMMAND_REGREL)) {				send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REGREJ, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			}
f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_NEW
f.frametype == AST_FRAME_IAX
f.frametype
f
f
frametype
AST_FRAME_IAX
AST_FRAME_IAX
f.subclass.integer == IAX_COMMAND_NEW
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_NEW
IAX_COMMAND_NEW
{				send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REJECT, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			}
send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REJECT, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);
send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REJECT, ntohl(fh->ts), fh->iseqno + 1, fd, NULL)
send_apathetic_reply
send_apathetic_reply
1
ntohs(fh->scallno)
ntohs
ntohs
fh->scallno
fh
fh
scallno
&sin
sin
sin
IAX_COMMAND_REJECT
IAX_COMMAND_REJECT
ntohl(fh->ts)
ntohl
ntohl
fh->ts
fh
fh
ts
fh->iseqno + 1
fh->iseqno
fh
fh
iseqno
1
fd
fd
NULL
NULL
if (f.frametype == AST_FRAME_IAX && (f.subclass.integer == IAX_COMMAND_REGREQ || f.subclass.integer == IAX_COMMAND_REGREL)) {				send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REGREJ, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			}
f.frametype == AST_FRAME_IAX && (f.subclass.integer == IAX_COMMAND_REGREQ || f.subclass.integer == IAX_COMMAND_REGREL)
f.frametype == AST_FRAME_IAX
f.frametype
f
f
frametype
AST_FRAME_IAX
AST_FRAME_IAX
(f.subclass.integer == IAX_COMMAND_REGREQ || f.subclass.integer == IAX_COMMAND_REGREL)
f.subclass.integer == IAX_COMMAND_REGREQ || f.subclass.integer == IAX_COMMAND_REGREL
f.subclass.integer == IAX_COMMAND_REGREQ
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_REGREQ
IAX_COMMAND_REGREQ
f.subclass.integer == IAX_COMMAND_REGREL
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_REGREL
IAX_COMMAND_REGREL
{				send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REGREJ, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			}
send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REGREJ, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);
send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REGREJ, ntohl(fh->ts), fh->iseqno + 1, fd, NULL)
send_apathetic_reply
send_apathetic_reply
1
ntohs(fh->scallno)
ntohs
ntohs
fh->scallno
fh
fh
scallno
&sin
sin
sin
IAX_COMMAND_REGREJ
IAX_COMMAND_REGREJ
ntohl(fh->ts)
ntohl
ntohl
fh->ts
fh
fh
ts
fh->iseqno + 1
fh->iseqno
fh
fh
iseqno
1
fd
fd
NULL
NULL
ast_variables_destroy(ies.vars);
ast_variables_destroy(ies.vars)
ast_variables_destroy
ast_variables_destroy
ies.vars
ies
ies
vars
return 1;
1
if (fr->callno > 0) {		struct ast_callid *mount_callid;		ast_mutex_lock(&iaxsl[fr->callno]);		if (iaxs[fr->callno] && ((mount_callid = iax_pvt_callid_get(fr->callno)))) {			/* Bind to thread */			ast_callid_threadassoc_add(mount_callid);			ast_callid_unref(mount_callid);		}	}
fr->callno > 0
fr->callno
fr
fr
callno
0
{		struct ast_callid *mount_callid;		ast_mutex_lock(&iaxsl[fr->callno]);		if (iaxs[fr->callno] && ((mount_callid = iax_pvt_callid_get(fr->callno)))) {			/* Bind to thread */			ast_callid_threadassoc_add(mount_callid);			ast_callid_unref(mount_callid);		}	}
struct ast_callid *mount_callid;
struct ast_callid *mount_callid;
struct ast_callid
ast_callid
*mount_callid
*
mount_callid
ast_mutex_lock(&iaxsl[fr->callno]);
ast_mutex_lock(&iaxsl[fr->callno]);
ast_mutex_lock
ast_mutex_lock
(&iaxsl[fr->callno])
&iaxsl[fr->callno]
&
iaxsl
[fr->callno]
fr->callno
fr
fr
callno
if (iaxs[fr->callno] && ((mount_callid = iax_pvt_callid_get(fr->callno)))) {			/* Bind to thread */			ast_callid_threadassoc_add(mount_callid);			ast_callid_unref(mount_callid);		}
iaxs[fr->callno] && ((mount_callid = iax_pvt_callid_get(fr->callno)))
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
((mount_callid = iax_pvt_callid_get(fr->callno)))
(mount_callid = iax_pvt_callid_get(fr->callno))
mount_callid = iax_pvt_callid_get(fr->callno)
mount_callid
mount_callid
iax_pvt_callid_get(fr->callno)
iax_pvt_callid_get
iax_pvt_callid_get
fr->callno
fr
fr
callno
{			/* Bind to thread */			ast_callid_threadassoc_add(mount_callid);			ast_callid_unref(mount_callid);		}
ast_callid_threadassoc_add(mount_callid);
ast_callid_threadassoc_add(mount_callid)
ast_callid_threadassoc_add
ast_callid_threadassoc_add
mount_callid
mount_callid
ast_callid_unref(mount_callid);
ast_callid_unref(mount_callid)
ast_callid_unref
ast_callid_unref
mount_callid
mount_callid
if (!fr->callno || !iaxs[fr->callno]) {		/* A call arrived for a nonexistent destination.  Unless it's an "inval"		   frame, reply with an inval */		if (ntohs(mh->callno) & IAX_FLAG_FULL) {			/* We can only raw hangup control frames */			if (((f.subclass.integer != IAX_COMMAND_INVAL) &&				 (f.subclass.integer != IAX_COMMAND_TXCNT) &&				 (f.subclass.integer != IAX_COMMAND_TXACC) &&				 (f.subclass.integer != IAX_COMMAND_FWDOWNL))||			    (f.frametype != AST_FRAME_IAX))				raw_hangup(&sin, ntohs(fh->dcallno) & ~IAX_FLAG_RETRANS, ntohs(mh->callno) & ~IAX_FLAG_FULL,				fd);		}		if (fr->callno > 0) 			ast_mutex_unlock(&iaxsl[fr->callno]);		ast_variables_destroy(ies.vars);		return 1;	}
!fr->callno || !iaxs[fr->callno]
!fr->callno
fr->callno
fr
fr
callno
!iaxs[fr->callno]
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{		/* A call arrived for a nonexistent destination.  Unless it's an "inval"		   frame, reply with an inval */		if (ntohs(mh->callno) & IAX_FLAG_FULL) {			/* We can only raw hangup control frames */			if (((f.subclass.integer != IAX_COMMAND_INVAL) &&				 (f.subclass.integer != IAX_COMMAND_TXCNT) &&				 (f.subclass.integer != IAX_COMMAND_TXACC) &&				 (f.subclass.integer != IAX_COMMAND_FWDOWNL))||			    (f.frametype != AST_FRAME_IAX))				raw_hangup(&sin, ntohs(fh->dcallno) & ~IAX_FLAG_RETRANS, ntohs(mh->callno) & ~IAX_FLAG_FULL,				fd);		}		if (fr->callno > 0) 			ast_mutex_unlock(&iaxsl[fr->callno]);		ast_variables_destroy(ies.vars);		return 1;	}
if (ntohs(mh->callno) & IAX_FLAG_FULL) {			/* We can only raw hangup control frames */			if (((f.subclass.integer != IAX_COMMAND_INVAL) &&				 (f.subclass.integer != IAX_COMMAND_TXCNT) &&				 (f.subclass.integer != IAX_COMMAND_TXACC) &&				 (f.subclass.integer != IAX_COMMAND_FWDOWNL))||			    (f.frametype != AST_FRAME_IAX))				raw_hangup(&sin, ntohs(fh->dcallno) & ~IAX_FLAG_RETRANS, ntohs(mh->callno) & ~IAX_FLAG_FULL,				fd);		}
ntohs(mh->callno) & IAX_FLAG_FULL
ntohs(mh->callno)
ntohs
ntohs
mh->callno
mh
mh
callno
IAX_FLAG_FULL
IAX_FLAG_FULL
{			/* We can only raw hangup control frames */			if (((f.subclass.integer != IAX_COMMAND_INVAL) &&				 (f.subclass.integer != IAX_COMMAND_TXCNT) &&				 (f.subclass.integer != IAX_COMMAND_TXACC) &&				 (f.subclass.integer != IAX_COMMAND_FWDOWNL))||			    (f.frametype != AST_FRAME_IAX))				raw_hangup(&sin, ntohs(fh->dcallno) & ~IAX_FLAG_RETRANS, ntohs(mh->callno) & ~IAX_FLAG_FULL,				fd);		}
if (((f.subclass.integer != IAX_COMMAND_INVAL) &&				 (f.subclass.integer != IAX_COMMAND_TXCNT) &&				 (f.subclass.integer != IAX_COMMAND_TXACC) &&				 (f.subclass.integer != IAX_COMMAND_FWDOWNL))||			    (f.frametype != AST_FRAME_IAX))				raw_hangup(&sin, ntohs(fh->dcallno) & ~IAX_FLAG_RETRANS, ntohs(mh->callno) & ~IAX_FLAG_FULL,				fd);
((f.subclass.integer != IAX_COMMAND_INVAL) &&				 (f.subclass.integer != IAX_COMMAND_TXCNT) &&				 (f.subclass.integer != IAX_COMMAND_TXACC) &&				 (f.subclass.integer != IAX_COMMAND_FWDOWNL))||			    (f.frametype != AST_FRAME_IAX)
((f.subclass.integer != IAX_COMMAND_INVAL) &&				 (f.subclass.integer != IAX_COMMAND_TXCNT) &&				 (f.subclass.integer != IAX_COMMAND_TXACC) &&				 (f.subclass.integer != IAX_COMMAND_FWDOWNL))
(f.subclass.integer != IAX_COMMAND_INVAL) &&				 (f.subclass.integer != IAX_COMMAND_TXCNT) &&				 (f.subclass.integer != IAX_COMMAND_TXACC) &&				 (f.subclass.integer != IAX_COMMAND_FWDOWNL)
(f.subclass.integer != IAX_COMMAND_INVAL) &&				 (f.subclass.integer != IAX_COMMAND_TXCNT) &&				 (f.subclass.integer != IAX_COMMAND_TXACC)
(f.subclass.integer != IAX_COMMAND_INVAL) &&				 (f.subclass.integer != IAX_COMMAND_TXCNT)
(f.subclass.integer != IAX_COMMAND_INVAL)
f.subclass.integer != IAX_COMMAND_INVAL
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_INVAL
IAX_COMMAND_INVAL
(f.subclass.integer != IAX_COMMAND_TXCNT)
f.subclass.integer != IAX_COMMAND_TXCNT
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_TXCNT
IAX_COMMAND_TXCNT
(f.subclass.integer != IAX_COMMAND_TXACC)
f.subclass.integer != IAX_COMMAND_TXACC
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_TXACC
IAX_COMMAND_TXACC
(f.subclass.integer != IAX_COMMAND_FWDOWNL)
f.subclass.integer != IAX_COMMAND_FWDOWNL
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_FWDOWNL
IAX_COMMAND_FWDOWNL
(f.frametype != AST_FRAME_IAX)
f.frametype != AST_FRAME_IAX
f.frametype
f
f
frametype
AST_FRAME_IAX
AST_FRAME_IAX
raw_hangup(&sin, ntohs(fh->dcallno) & ~IAX_FLAG_RETRANS, ntohs(mh->callno) & ~IAX_FLAG_FULL,				fd);
raw_hangup(&sin, ntohs(fh->dcallno) & ~IAX_FLAG_RETRANS, ntohs(mh->callno) & ~IAX_FLAG_FULL,				fd)
raw_hangup
raw_hangup
&sin
sin
sin
ntohs(fh->dcallno) & ~IAX_FLAG_RETRANS
ntohs(fh->dcallno)
ntohs
ntohs
fh->dcallno
fh
fh
dcallno
~IAX_FLAG_RETRANS
IAX_FLAG_RETRANS
IAX_FLAG_RETRANS
ntohs(mh->callno) & ~IAX_FLAG_FULL
ntohs(mh->callno)
ntohs
ntohs
mh->callno
mh
mh
callno
~IAX_FLAG_FULL
IAX_FLAG_FULL
IAX_FLAG_FULL
fd
fd
if (fr->callno > 0) 			ast_mutex_unlock(&iaxsl[fr->callno]);
fr->callno > 0
fr->callno
fr
fr
callno
0
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock
ast_mutex_unlock
(&iaxsl[fr->callno])
&iaxsl[fr->callno]
&
iaxsl
[fr->callno]
fr->callno
fr
fr
callno
ast_variables_destroy(ies.vars);
ast_variables_destroy(ies.vars)
ast_variables_destroy
ast_variables_destroy
ies.vars
ies
ies
vars
return 1;
1
if (ast_test_flag64(iaxs[fr->callno], IAX_ENCRYPTED) && !decrypted) {		if (decrypt_frame(fr->callno, fh, &f, &res)) {			ast_log(LOG_NOTICE, "Packet Decrypt Failed!\n");			ast_variables_destroy(ies.vars);			ast_mutex_unlock(&iaxsl[fr->callno]);			return 1;		}		decrypted = 1;	}
ast_test_flag64(iaxs[fr->callno], IAX_ENCRYPTED) && !decrypted
ast_test_flag64(iaxs[fr->callno], IAX_ENCRYPTED)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_ENCRYPTED
IAX_ENCRYPTED
!decrypted
decrypted
decrypted
{		if (decrypt_frame(fr->callno, fh, &f, &res)) {			ast_log(LOG_NOTICE, "Packet Decrypt Failed!\n");			ast_variables_destroy(ies.vars);			ast_mutex_unlock(&iaxsl[fr->callno]);			return 1;		}		decrypted = 1;	}
if (decrypt_frame(fr->callno, fh, &f, &res)) {			ast_log(LOG_NOTICE, "Packet Decrypt Failed!\n");			ast_variables_destroy(ies.vars);			ast_mutex_unlock(&iaxsl[fr->callno]);			return 1;		}
decrypt_frame(fr->callno, fh, &f, &res)
decrypt_frame
decrypt_frame
fr->callno
fr
fr
callno
fh
fh
&f
f
f
&res
res
res
{			ast_log(LOG_NOTICE, "Packet Decrypt Failed!\n");			ast_variables_destroy(ies.vars);			ast_mutex_unlock(&iaxsl[fr->callno]);			return 1;		}
ast_log(LOG_NOTICE, "Packet Decrypt Failed!\n");
ast_log(LOG_NOTICE, "Packet Decrypt Failed!\n")
ast_log
ast_log
LOG_NOTICE
LOG_NOTICE
"Packet Decrypt Failed!\n"
ast_variables_destroy(ies.vars);
ast_variables_destroy(ies.vars)
ast_variables_destroy
ast_variables_destroy
ies.vars
ies
ies
vars
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock
ast_mutex_unlock
(&iaxsl[fr->callno])
&iaxsl[fr->callno]
&
iaxsl
[fr->callno]
fr->callno
fr
fr
callno
return 1;
1
decrypted = 1;
decrypted = 1
decrypted
decrypted
1
if (iaxs[fr->callno]->owner && fh->type == AST_FRAME_IAX &&			(fh->csub == IAX_COMMAND_HANGUP			|| fh->csub == IAX_COMMAND_REJECT			|| fh->csub == IAX_COMMAND_REGREJ			|| fh->csub == IAX_COMMAND_TXREJ)) {		struct ast_control_pvt_cause_code *cause_code;		int data_size = sizeof(*cause_code);		char subclass[40] = "";		/* get subclass text */		iax_frame_subclass2str(fh->csub, subclass, sizeof(subclass));		/* add length of "IAX2 " */		data_size += 5;		/* for IAX hangup frames, add length of () and number */		data_size += 3;		if (ies.causecode > 9) {			data_size++;		}		if (ies.causecode > 99) {			data_size++;		}		/* add length of subclass */		data_size += strlen(subclass);		cause_code = ast_alloca(data_size);		ast_copy_string(cause_code->chan_name, ast_channel_name(iaxs[fr->callno]->owner), AST_CHANNEL_NAME);		cause_code->ast_cause = ies.causecode;		snprintf(cause_code->code, data_size - sizeof(*cause_code) + 1, "IAX2 %s(%d)", subclass, ies.causecode);		iax2_lock_owner(fr->callno);		if (iaxs[fr->callno] && iaxs[fr->callno]->owner) {			ast_queue_control_data(iaxs[fr->callno]->owner, AST_CONTROL_PVT_CAUSE_CODE, cause_code, data_size);			ast_channel_hangupcause_hash_set(iaxs[fr->callno]->owner, cause_code, data_size);			ast_channel_unlock(iaxs[fr->callno]->owner);		}		if (!iaxs[fr->callno]) {			ast_variables_destroy(ies.vars);			ast_mutex_unlock(&iaxsl[fr->callno]);			return 1;		}	}
iaxs[fr->callno]->owner && fh->type == AST_FRAME_IAX &&			(fh->csub == IAX_COMMAND_HANGUP			|| fh->csub == IAX_COMMAND_REJECT			|| fh->csub == IAX_COMMAND_REGREJ			|| fh->csub == IAX_COMMAND_TXREJ)
iaxs[fr->callno]->owner && fh->type == AST_FRAME_IAX
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
fh->type == AST_FRAME_IAX
fh->type
fh
fh
type
AST_FRAME_IAX
AST_FRAME_IAX
(fh->csub == IAX_COMMAND_HANGUP			|| fh->csub == IAX_COMMAND_REJECT			|| fh->csub == IAX_COMMAND_REGREJ			|| fh->csub == IAX_COMMAND_TXREJ)
fh->csub == IAX_COMMAND_HANGUP			|| fh->csub == IAX_COMMAND_REJECT			|| fh->csub == IAX_COMMAND_REGREJ			|| fh->csub == IAX_COMMAND_TXREJ
fh->csub == IAX_COMMAND_HANGUP			|| fh->csub == IAX_COMMAND_REJECT			|| fh->csub == IAX_COMMAND_REGREJ
fh->csub == IAX_COMMAND_HANGUP			|| fh->csub == IAX_COMMAND_REJECT
fh->csub == IAX_COMMAND_HANGUP
fh->csub
fh
fh
csub
IAX_COMMAND_HANGUP
IAX_COMMAND_HANGUP
fh->csub == IAX_COMMAND_REJECT
fh->csub
fh
fh
csub
IAX_COMMAND_REJECT
IAX_COMMAND_REJECT
fh->csub == IAX_COMMAND_REGREJ
fh->csub
fh
fh
csub
IAX_COMMAND_REGREJ
IAX_COMMAND_REGREJ
fh->csub == IAX_COMMAND_TXREJ
fh->csub
fh
fh
csub
IAX_COMMAND_TXREJ
IAX_COMMAND_TXREJ
{		struct ast_control_pvt_cause_code *cause_code;		int data_size = sizeof(*cause_code);		char subclass[40] = "";		/* get subclass text */		iax_frame_subclass2str(fh->csub, subclass, sizeof(subclass));		/* add length of "IAX2 " */		data_size += 5;		/* for IAX hangup frames, add length of () and number */		data_size += 3;		if (ies.causecode > 9) {			data_size++;		}		if (ies.causecode > 99) {			data_size++;		}		/* add length of subclass */		data_size += strlen(subclass);		cause_code = ast_alloca(data_size);		ast_copy_string(cause_code->chan_name, ast_channel_name(iaxs[fr->callno]->owner), AST_CHANNEL_NAME);		cause_code->ast_cause = ies.causecode;		snprintf(cause_code->code, data_size - sizeof(*cause_code) + 1, "IAX2 %s(%d)", subclass, ies.causecode);		iax2_lock_owner(fr->callno);		if (iaxs[fr->callno] && iaxs[fr->callno]->owner) {			ast_queue_control_data(iaxs[fr->callno]->owner, AST_CONTROL_PVT_CAUSE_CODE, cause_code, data_size);			ast_channel_hangupcause_hash_set(iaxs[fr->callno]->owner, cause_code, data_size);			ast_channel_unlock(iaxs[fr->callno]->owner);		}		if (!iaxs[fr->callno]) {			ast_variables_destroy(ies.vars);			ast_mutex_unlock(&iaxsl[fr->callno]);			return 1;		}	}
struct ast_control_pvt_cause_code *cause_code;
struct ast_control_pvt_cause_code *cause_code;
struct ast_control_pvt_cause_code
ast_control_pvt_cause_code
*cause_code
*
cause_code
int data_size = sizeof(*cause_code);
int data_size = sizeof(*cause_code);
int
data_size = sizeof(*cause_code)
data_size
= sizeof(*cause_code)
sizeof(*cause_code)
(*cause_code)
*cause_code
cause_code
cause_code
char subclass[40] = "";
char subclass[40] = "";
char
subclass[40] = ""
subclass
[40]
40
= ""
""
iax_frame_subclass2str(fh->csub, subclass, sizeof(subclass));
iax_frame_subclass2str(fh->csub, subclass, sizeof(subclass))
iax_frame_subclass2str
iax_frame_subclass2str
fh->csub
fh
fh
csub
subclass
subclass
sizeof(subclass)
(subclass)
subclass
subclass
data_size += 5;
data_size += 5
data_size
data_size
5
data_size += 3;
data_size += 3
data_size
data_size
3
if (ies.causecode > 9) {			data_size++;		}
ies.causecode > 9
ies.causecode
ies
ies
causecode
9
{			data_size++;		}
data_size++;
data_size++
data_size
data_size
if (ies.causecode > 99) {			data_size++;		}
ies.causecode > 99
ies.causecode
ies
ies
causecode
99
{			data_size++;		}
data_size++;
data_size++
data_size
data_size
data_size += strlen(subclass);
data_size += strlen(subclass)
data_size
data_size
strlen(subclass)
strlen
strlen
subclass
subclass
cause_code = ast_alloca(data_size);
cause_code = ast_alloca(data_size)
cause_code
cause_code
ast_alloca(data_size)
ast_alloca
ast_alloca
data_size
data_size
ast_copy_string(cause_code->chan_name, ast_channel_name(iaxs[fr->callno]->owner), AST_CHANNEL_NAME);
ast_copy_string(cause_code->chan_name, ast_channel_name(iaxs[fr->callno]->owner), AST_CHANNEL_NAME)
ast_copy_string
ast_copy_string
cause_code->chan_name
cause_code
cause_code
chan_name
ast_channel_name(iaxs[fr->callno]->owner)
ast_channel_name
ast_channel_name
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
AST_CHANNEL_NAME
AST_CHANNEL_NAME
cause_code->ast_cause = ies.causecode;
cause_code->ast_cause = ies.causecode
cause_code->ast_cause
cause_code
cause_code
ast_cause
ies.causecode
ies
ies
causecode
snprintf(cause_code->code, data_size - sizeof(*cause_code) + 1, "IAX2 %s(%d)", subclass, ies.causecode);
snprintf(cause_code->code, data_size - sizeof(*cause_code) + 1, "IAX2 %s(%d)", subclass, ies.causecode)
snprintf
snprintf
cause_code->code
cause_code
cause_code
code
data_size - sizeof(*cause_code) + 1
data_size - sizeof(*cause_code)
data_size
data_size
sizeof(*cause_code)
(*cause_code)
*cause_code
cause_code
cause_code
1
"IAX2 %s(%d)"
subclass
subclass
ies.causecode
ies
ies
causecode
iax2_lock_owner(fr->callno);
iax2_lock_owner(fr->callno)
iax2_lock_owner
iax2_lock_owner
fr->callno
fr
fr
callno
if (iaxs[fr->callno] && iaxs[fr->callno]->owner) {			ast_queue_control_data(iaxs[fr->callno]->owner, AST_CONTROL_PVT_CAUSE_CODE, cause_code, data_size);			ast_channel_hangupcause_hash_set(iaxs[fr->callno]->owner, cause_code, data_size);			ast_channel_unlock(iaxs[fr->callno]->owner);		}
iaxs[fr->callno] && iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
{			ast_queue_control_data(iaxs[fr->callno]->owner, AST_CONTROL_PVT_CAUSE_CODE, cause_code, data_size);			ast_channel_hangupcause_hash_set(iaxs[fr->callno]->owner, cause_code, data_size);			ast_channel_unlock(iaxs[fr->callno]->owner);		}
ast_queue_control_data(iaxs[fr->callno]->owner, AST_CONTROL_PVT_CAUSE_CODE, cause_code, data_size);
ast_queue_control_data(iaxs[fr->callno]->owner, AST_CONTROL_PVT_CAUSE_CODE, cause_code, data_size)
ast_queue_control_data
ast_queue_control_data
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
AST_CONTROL_PVT_CAUSE_CODE
AST_CONTROL_PVT_CAUSE_CODE
cause_code
cause_code
data_size
data_size
ast_channel_hangupcause_hash_set(iaxs[fr->callno]->owner, cause_code, data_size);
ast_channel_hangupcause_hash_set(iaxs[fr->callno]->owner, cause_code, data_size)
ast_channel_hangupcause_hash_set
ast_channel_hangupcause_hash_set
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
cause_code
cause_code
data_size
data_size
ast_channel_unlock(iaxs[fr->callno]->owner);
ast_channel_unlock(iaxs[fr->callno]->owner)
ast_channel_unlock
ast_channel_unlock
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
if (!iaxs[fr->callno]) {			ast_variables_destroy(ies.vars);			ast_mutex_unlock(&iaxsl[fr->callno]);			return 1;		}
!iaxs[fr->callno]
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{			ast_variables_destroy(ies.vars);			ast_mutex_unlock(&iaxsl[fr->callno]);			return 1;		}
ast_variables_destroy(ies.vars);
ast_variables_destroy(ies.vars)
ast_variables_destroy
ast_variables_destroy
ies.vars
ies
ies
vars
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock
ast_mutex_unlock
(&iaxsl[fr->callno])
&iaxsl[fr->callno]
&
iaxsl
[fr->callno]
fr->callno
fr
fr
callno
return 1;
1
iaxs[fr->callno]->frames_received++;
iaxs[fr->callno]->frames_received++
iaxs[fr->callno]->frames_received
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
frames_received
if (!inaddrcmp(&sin, &iaxs[fr->callno]->addr) && !minivid &&		f.subclass.integer != IAX_COMMAND_TXCNT &&		/* for attended transfer */		f.subclass.integer != IAX_COMMAND_TXACC) {		/* for attended transfer */		unsigned short new_peercallno;		new_peercallno = (unsigned short) (ntohs(mh->callno) & ~IAX_FLAG_FULL);		if (new_peercallno && new_peercallno != iaxs[fr->callno]->peercallno) {			if (iaxs[fr->callno]->peercallno) {				remove_by_peercallno(iaxs[fr->callno]);			}			iaxs[fr->callno]->peercallno = new_peercallno;			store_by_peercallno(iaxs[fr->callno]);		}	}
!inaddrcmp(&sin, &iaxs[fr->callno]->addr) && !minivid &&		f.subclass.integer != IAX_COMMAND_TXCNT &&		/* for attended transfer */		f.subclass.integer != IAX_COMMAND_TXACC
!inaddrcmp(&sin, &iaxs[fr->callno]->addr) && !minivid &&		f.subclass.integer != IAX_COMMAND_TXCNT
!inaddrcmp(&sin, &iaxs[fr->callno]->addr) && !minivid
!inaddrcmp(&sin, &iaxs[fr->callno]->addr)
inaddrcmp(&sin, &iaxs[fr->callno]->addr)
inaddrcmp
inaddrcmp
&sin
sin
sin
&iaxs[fr->callno]->addr
iaxs[fr->callno]->addr
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
addr
!minivid
minivid
minivid
f.subclass.integer != IAX_COMMAND_TXCNT
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_TXCNT
IAX_COMMAND_TXCNT
f.subclass.integer != IAX_COMMAND_TXACC
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_TXACC
IAX_COMMAND_TXACC
{		/* for attended transfer */		unsigned short new_peercallno;		new_peercallno = (unsigned short) (ntohs(mh->callno) & ~IAX_FLAG_FULL);		if (new_peercallno && new_peercallno != iaxs[fr->callno]->peercallno) {			if (iaxs[fr->callno]->peercallno) {				remove_by_peercallno(iaxs[fr->callno]);			}			iaxs[fr->callno]->peercallno = new_peercallno;			store_by_peercallno(iaxs[fr->callno]);		}	}
unsigned short new_peercallno;
unsigned short new_peercallno;
unsigned short
new_peercallno
new_peercallno
new_peercallno = (unsigned short) (ntohs(mh->callno) & ~IAX_FLAG_FULL);
new_peercallno = (unsigned short) (ntohs(mh->callno) & ~IAX_FLAG_FULL)
new_peercallno
new_peercallno
(unsigned short) (ntohs(mh->callno) & ~IAX_FLAG_FULL)
unsigned short
unsigned short

(ntohs(mh->callno) & ~IAX_FLAG_FULL)
ntohs(mh->callno) & ~IAX_FLAG_FULL
ntohs(mh->callno)
ntohs
ntohs
mh->callno
mh
mh
callno
~IAX_FLAG_FULL
IAX_FLAG_FULL
IAX_FLAG_FULL
if (new_peercallno && new_peercallno != iaxs[fr->callno]->peercallno) {			if (iaxs[fr->callno]->peercallno) {				remove_by_peercallno(iaxs[fr->callno]);			}			iaxs[fr->callno]->peercallno = new_peercallno;			store_by_peercallno(iaxs[fr->callno]);		}
new_peercallno && new_peercallno != iaxs[fr->callno]->peercallno
new_peercallno
new_peercallno
new_peercallno != iaxs[fr->callno]->peercallno
new_peercallno
new_peercallno
iaxs[fr->callno]->peercallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercallno
{			if (iaxs[fr->callno]->peercallno) {				remove_by_peercallno(iaxs[fr->callno]);			}			iaxs[fr->callno]->peercallno = new_peercallno;			store_by_peercallno(iaxs[fr->callno]);		}
if (iaxs[fr->callno]->peercallno) {				remove_by_peercallno(iaxs[fr->callno]);			}
iaxs[fr->callno]->peercallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercallno
{				remove_by_peercallno(iaxs[fr->callno]);			}
remove_by_peercallno(iaxs[fr->callno]);
remove_by_peercallno(iaxs[fr->callno]);
remove_by_peercallno
remove_by_peercallno
(iaxs[fr->callno])
iaxs[fr->callno]
iaxs
[fr->callno]
fr->callno
fr
fr
callno
iaxs[fr->callno]->peercallno = new_peercallno;
iaxs[fr->callno]->peercallno = new_peercallno
iaxs[fr->callno]->peercallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercallno
new_peercallno
new_peercallno
store_by_peercallno(iaxs[fr->callno]);
store_by_peercallno(iaxs[fr->callno]);
store_by_peercallno
store_by_peercallno
(iaxs[fr->callno])
iaxs[fr->callno]
iaxs
[fr->callno]
fr->callno
fr
fr
callno
if (ntohs(mh->callno) & IAX_FLAG_FULL) {		if (iaxdebug)			ast_debug(1, "Received packet %d, (%d, %u)\n", fh->oseqno, f.frametype, f.subclass.integer);		/* Check if it's out of order (and not an ACK or INVAL) */		fr->oseqno = fh->oseqno;		fr->iseqno = fh->iseqno;		fr->ts = ntohl(fh->ts);#ifdef IAXTESTS		if (test_resync) {			ast_debug(1, "Simulating frame ts resync, was %u now %u\n", fr->ts, fr->ts + test_resync);			fr->ts += test_resync;		}#endif /* IAXTESTS */#if 0		if ( (ntohs(fh->dcallno) & IAX_FLAG_RETRANS) ||		     ( (f.frametype != AST_FRAME_VOICE) && ! (f.frametype == AST_FRAME_IAX &&								(f.subclass == IAX_COMMAND_NEW ||								 f.subclass == IAX_COMMAND_AUTHREQ ||								 f.subclass == IAX_COMMAND_ACCEPT ||								 f.subclass == IAX_COMMAND_REJECT))      ) )#endif		if ((ntohs(fh->dcallno) & IAX_FLAG_RETRANS) || (f.frametype != AST_FRAME_VOICE))			updatehistory = 0;		if ((iaxs[fr->callno]->iseqno != fr->oseqno) &&			(iaxs[fr->callno]->iseqno ||				((f.subclass.integer != IAX_COMMAND_TXCNT) &&				(f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXACC)) ||				(f.frametype != AST_FRAME_IAX))) {			if (			 ((f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_INVAL) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&			  (f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_VNAK)) ||			  (f.frametype != AST_FRAME_IAX)) {				/* If it's not an ACK packet, it's out of order. */				ast_debug(1, "Packet arrived out of order (expecting %d, got %d) (frametype = %d, subclass = %d)\n",					iaxs[fr->callno]->iseqno, fr->oseqno, f.frametype, f.subclass.integer);				/* Check to see if we need to request retransmission,				 * and take sequence number wraparound into account */				if ((unsigned char) (iaxs[fr->callno]->iseqno - fr->oseqno) < 128) {					/* If we've already seen it, ack it XXX There's a border condition here XXX */					if ((f.frametype != AST_FRAME_IAX) ||							((f.subclass.integer != IAX_COMMAND_ACK) && (f.subclass.integer != IAX_COMMAND_INVAL))) {						ast_debug(1, "Acking anyway\n");						/* XXX Maybe we should handle its ack to us, but then again, it's probably outdated anyway, and if						   we have anything to send, we'll retransmit and get an ACK back anyway XXX */						send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					}				} else {					/* Send a VNAK requesting retransmission */					iax2_vnak(fr->callno);				}				ast_variables_destroy(ies.vars);				ast_mutex_unlock(&iaxsl[fr->callno]);				return 1;			}		} else {			/* Increment unless it's an ACK or VNAK */			if (((f.subclass.integer != IAX_COMMAND_ACK) &&			    (f.subclass.integer != IAX_COMMAND_INVAL) &&			    (f.subclass.integer != IAX_COMMAND_TXCNT) &&			    (f.subclass.integer != IAX_COMMAND_TXACC) &&				(f.subclass.integer != IAX_COMMAND_VNAK)) ||			    (f.frametype != AST_FRAME_IAX))				iaxs[fr->callno]->iseqno++;		}		/* Ensure text frames are NULL-terminated */		if (f.frametype == AST_FRAME_TEXT && thread->buf[res - 1] != '\0') {			if (res < thread->buf_size)				thread->buf[res++] = '\0';			else /* Trims one character from the text message, but that's better than overwriting the end of the buffer. */				thread->buf[res - 1] = '\0';		}		/* Handle implicit ACKing unless this is an INVAL, and only if this is 		   from the real peer, not the transfer peer */		if (!inaddrcmp(&sin, &iaxs[fr->callno]->addr) &&		    ((f.subclass.integer != IAX_COMMAND_INVAL) ||		     (f.frametype != AST_FRAME_IAX))) {			unsigned char x;			int call_to_destroy;			/* First we have to qualify that the ACKed value is within our window */			if (iaxs[fr->callno]->rseqno >= iaxs[fr->callno]->oseqno || (fr->iseqno >= iaxs[fr->callno]->rseqno && fr->iseqno < iaxs[fr->callno]->oseqno))				x = fr->iseqno;			else				x = iaxs[fr->callno]->oseqno;			if ((x != iaxs[fr->callno]->oseqno) || (iaxs[fr->callno]->oseqno == fr->iseqno)) {				/* The acknowledgement is within our window.  Time to acknowledge everything				   that it says to */				for (x=iaxs[fr->callno]->rseqno; x != fr->iseqno; x++) {					/* Ack the packet with the given timestamp */					if (iaxdebug)						ast_debug(1, "Cancelling transmission of packet %d\n", x);					call_to_destroy = 0;					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* If it's our call, and our timestamp, mark -1 retries */						if (x == cur->oseqno) {							cur->retries = -1;							/* Destroy call if this is the end */							if (cur->final)								call_to_destroy = fr->callno;						}					}					if (call_to_destroy) {						if (iaxdebug)							ast_debug(1, "Really destroying %d, having been acked on final message\n", call_to_destroy);						ast_mutex_lock(&iaxsl[call_to_destroy]);						iax2_destroy(call_to_destroy);						ast_mutex_unlock(&iaxsl[call_to_destroy]);					}				}				/* Note how much we've received acknowledgement for */				if (iaxs[fr->callno])					iaxs[fr->callno]->rseqno = fr->iseqno;				else {					/* Stop processing now */					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}			} else {				ast_debug(1, "Received iseqno %d not within window %d->%d\n", fr->iseqno, iaxs[fr->callno]->rseqno, iaxs[fr->callno]->oseqno);			}		}		if (inaddrcmp(&sin, &iaxs[fr->callno]->addr) &&			((f.frametype != AST_FRAME_IAX) ||			 ((f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT)))) {			/* Only messages we accept from a transfer host are TXACC and TXCNT */			ast_variables_destroy(ies.vars);			ast_mutex_unlock(&iaxsl[fr->callno]);			return 1;		}		/* when we receive the first full frame for a new incoming channel,		   it is safe to start the PBX on the channel because we have now		   completed a 3-way handshake with the peer */		if ((f.frametype == AST_FRAME_VOICE) ||		    (f.frametype == AST_FRAME_VIDEO) ||		    (f.frametype == AST_FRAME_IAX)) {			if (ast_test_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART)) {				ast_clear_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);				if (!ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->chosenformat, NULL,						  ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED))) {					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}			}			if (ies.vars) {				struct ast_datastore *variablestore = NULL;				struct ast_variable *var, *prev = NULL;				AST_LIST_HEAD(, ast_var_t) *varlist;				iax2_lock_owner(fr->callno);				if (!iaxs[fr->callno]) {					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}				if ((c = iaxs[fr->callno]->owner)) {					varlist = ast_calloc(1, sizeof(*varlist));					variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);					if (variablestore && varlist) {						variablestore->data = varlist;						variablestore->inheritance = DATASTORE_INHERIT_FOREVER;						AST_LIST_HEAD_INIT(varlist);						ast_debug(1, "I can haz IAX vars?\n");						for (var = ies.vars; var; var = var->next) {							struct ast_var_t *newvar = ast_var_assign(var->name, var->value);							if (prev) {								ast_free(prev);							}							prev = var;							if (!newvar) {								/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");							} else {								AST_LIST_INSERT_TAIL(varlist, newvar, entries);							}						}						if (prev) {							ast_free(prev);						}						ies.vars = NULL;						ast_channel_datastore_add(c, variablestore);					} else {						ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");						if (variablestore) {							ast_datastore_free(variablestore);						}						if (varlist) {							ast_free(varlist);						}					}					ast_channel_unlock(c);				} else {					/* No channel yet, so transfer the variables directly over to the pvt,					 * for later inheritance. */					ast_debug(1, "No channel, so populating IAXVARs to the pvt, as an intermediate step.\n");					for (var = ies.vars; var && var->next; var = var->next);					if (var) {						var->next = iaxs[fr->callno]->iaxvars;						iaxs[fr->callno]->iaxvars = ies.vars;						ies.vars = NULL;					}				}			}			if (ies.vars) {				ast_debug(1, "I have IAX variables, but they were not processed\n");			}		}		/* once we receive our first IAX Full Frame that is not CallToken related, send all		 * queued signaling frames that were being held. */		if ((f.frametype == AST_FRAME_IAX) && (f.subclass.integer != IAX_COMMAND_CALLTOKEN) && iaxs[fr->callno]->hold_signaling) {			send_signaling(iaxs[fr->callno]);		}		if (f.frametype == AST_FRAME_VOICE) {			if (ast_format_to_old_bitfield(&f.subclass.format) != iaxs[fr->callno]->voiceformat) {					iaxs[fr->callno]->voiceformat = ast_format_to_old_bitfield(&f.subclass.format);					ast_debug(1, "Ooh, voice format changed to '%s'\n", ast_getformatname(&f.subclass.format));					if (iaxs[fr->callno]->owner) {						iax2_lock_owner(fr->callno);						if (iaxs[fr->callno]) {							if (iaxs[fr->callno]->owner) {								struct ast_format_cap *orignative = ast_format_cap_dup(ast_channel_nativeformats(iaxs[fr->callno]->owner));								struct ast_format_cap *native = ast_channel_nativeformats(iaxs[fr->callno]->owner);								if (orignative) {									ast_format_cap_set(native, &f.subclass.format);									if (ast_channel_readformat(iaxs[fr->callno]->owner)->id) {										ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));									}									ast_format_cap_copy(native, orignative);									ast_channel_unlock(iaxs[fr->callno]->owner);									orignative = ast_format_cap_destroy(orignative);								}							}						} else {							ast_debug(1, "Neat, somebody took away the channel at a magical time but i found it!\n");							/* Free remote variables (if any) */							if (ies.vars) {								ast_variables_destroy(ies.vars);								ast_debug(1, "I can haz iaxvars, but they is no good.  :-(\n");								ies.vars = NULL;							}							ast_mutex_unlock(&iaxsl[fr->callno]);							return 1;						}					}			}		}		if (f.frametype == AST_FRAME_VIDEO) {			if (f.subclass.format.id != ast_format_id_from_old_bitfield(iaxs[fr->callno]->videoformat)) {				ast_debug(1, "Ooh, video format changed to %s\n", ast_getformatname(&f.subclass.format));				iaxs[fr->callno]->videoformat = ast_format_to_old_bitfield(&f.subclass.format);			}		}		if (f.frametype == AST_FRAME_CONTROL && iaxs[fr->callno]->owner) {			if (f.subclass.integer == AST_CONTROL_BUSY) {				ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_BUSY);			} else if (f.subclass.integer == AST_CONTROL_CONGESTION) {				ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_CONGESTION);			}		}		if (f.frametype == AST_FRAME_IAX) {			AST_SCHED_DEL(sched, iaxs[fr->callno]->initid);			/* Handle the IAX pseudo frame itself */			if (iaxdebug)				ast_debug(1, "IAX subclass %d received\n", f.subclass.integer);                        /* Update last ts unless the frame's timestamp originated with us. */			if (iaxs[fr->callno]->last < fr->ts &&                            f.subclass.integer != IAX_COMMAND_ACK &&                            f.subclass.integer != IAX_COMMAND_PONG &&                            f.subclass.integer != IAX_COMMAND_LAGRP) {				iaxs[fr->callno]->last = fr->ts;				if (iaxdebug)					ast_debug(1, "For call=%d, set last=%d\n", fr->callno, fr->ts);			}			iaxs[fr->callno]->last_iax_message = f.subclass.integer;			if (!iaxs[fr->callno]->first_iax_message) {				iaxs[fr->callno]->first_iax_message = f.subclass.integer;			}			switch(f.subclass.integer) {			case IAX_COMMAND_ACK:				/* Do nothing */				break;			case IAX_COMMAND_QUELCH:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {				        /* Generate Manager Hold event, if necessary*/					if (iaxs[fr->callno]->owner) {						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: On\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}					ast_set_flag64(iaxs[fr->callno], IAX_QUELCH);					if (ies.musiconhold) {						iax2_lock_owner(fr->callno);						if (!iaxs[fr->callno] || !iaxs[fr->callno]->owner) {							break;						}						if (ast_bridged_channel(iaxs[fr->callno]->owner)) {							const char *moh_suggest = iaxs[fr->callno]->mohsuggest;							/*							 * We already hold the owner lock so we do not							 * need to check iaxs[fr->callno] after it returns.							 */							iax2_queue_control_data(fr->callno, AST_CONTROL_HOLD, 								S_OR(moh_suggest, NULL),								!ast_strlen_zero(moh_suggest) ? strlen(moh_suggest) + 1 : 0);						}						ast_channel_unlock(iaxs[fr->callno]->owner);					}				}				break;			case IAX_COMMAND_UNQUELCH:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {					iax2_lock_owner(fr->callno);					if (!iaxs[fr->callno]) {						break;					}					/* Generate Manager Unhold event, if necessary */					if (iaxs[fr->callno]->owner && ast_test_flag64(iaxs[fr->callno], IAX_QUELCH)) {						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: Off\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}					ast_clear_flag64(iaxs[fr->callno], IAX_QUELCH);					if (!iaxs[fr->callno]->owner) {						break;					}					if (ast_bridged_channel(iaxs[fr->callno]->owner)) {						/*						 * We already hold the owner lock so we do not						 * need to check iaxs[fr->callno] after it returns.						 */						iax2_queue_control_data(fr->callno, AST_CONTROL_UNHOLD, NULL, 0);					}					ast_channel_unlock(iaxs[fr->callno]->owner);				}				break;			case IAX_COMMAND_TXACC:				if (iaxs[fr->callno]->transferring == TRANSFER_BEGIN) {					/* Ack the packet with the given timestamp */					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* Cancel any outstanding txcnt's */						if (cur->transfer) {							cur->retries = -1;						}					}					memset(&ied1, 0, sizeof(ied1));					iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->callno);					send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREADY, 0, ied1.buf, ied1.pos, -1);					iaxs[fr->callno]->transferring = TRANSFER_READY;				}				break;			case IAX_COMMAND_NEW:				/* Ignore if it's already up */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD))					break;				if (ies.provverpres && ies.serviceident && sin.sin_addr.s_addr) {					ast_mutex_unlock(&iaxsl[fr->callno]);					check_provisioning(&sin, fd, ies.serviceident, ies.provver);					ast_mutex_lock(&iaxsl[fr->callno]);					if (!iaxs[fr->callno]) {						break;					}				}				/* If we're in trunk mode, do it now, and update the trunk number in our frame before continuing */				if (ast_test_flag64(iaxs[fr->callno], IAX_TRUNK)) {					int new_callno;					if ((new_callno = make_trunk(fr->callno, 1)) != -1)						fr->callno = new_callno;				}				/* For security, always ack immediately */				if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				if (check_access(fr->callno, &sin, &ies)) {					/* They're not allowed on */					auth_fail(fr->callno, IAX_COMMAND_REJECT);					if (authdebug)						ast_log(LOG_NOTICE, "Rejected connect attempt from %s, who was trying to reach '%s@%s'\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					break;				}				if (ast_strlen_zero(iaxs[fr->callno]->secret) && ast_test_flag64(iaxs[fr->callno], IAX_FORCE_ENCRYPT)) {					auth_fail(fr->callno, IAX_COMMAND_REJECT);					ast_log(LOG_WARNING, "Rejected connect attempt.  No secret present while force encrypt enabled.\n");					break;				}				if (strcasecmp(iaxs[fr->callno]->exten, "TBD")) {					const char *context, *exten, *cid_num;					context = ast_strdupa(iaxs[fr->callno]->context);					exten = ast_strdupa(iaxs[fr->callno]->exten);					cid_num = ast_strdupa(iaxs[fr->callno]->cid_num);					/* This might re-enter the IAX code and need the lock */					ast_mutex_unlock(&iaxsl[fr->callno]);					exists = ast_exists_extension(NULL, context, exten, 1, cid_num);					ast_mutex_lock(&iaxsl[fr->callno]);					if (!iaxs[fr->callno]) {						break;					}				} else					exists = 0;				/* Get OSP token if it does exist */				save_osptoken(fr, &ies);				if (ast_strlen_zero(iaxs[fr->callno]->secret) && ast_strlen_zero(iaxs[fr->callno]->inkeys)) {					if (strcmp(iaxs[fr->callno]->exten, "TBD") && !exists) {						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}						if (authdebug)							ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					} else {						/* Select an appropriate format */						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								using_prefs = "reqonly";							} else {								using_prefs = "disabled";							}							format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;							memset(&pref, 0, sizeof(pref));							strcpy(caller_pref_buf, "disabled");							strcpy(host_pref_buf, "disabled");						} else {							struct ast_format tmpfmt;							using_prefs = "mine";							/* If the information elements are in here... use them */							if (ies.codec_prefs)								ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);							if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {								/* If we are codec_first_choice we let the caller have the 1st shot at picking the codec.*/								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {									pref = iaxs[fr->callno]->rprefs;									using_prefs = "caller";								} else {									pref = iaxs[fr->callno]->prefs;								}							} else								pref = iaxs[fr->callno]->prefs;							format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);							ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);							ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);						}						if (!format) {							if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP))								format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;							if (!format) {								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}								if (authdebug) {									char tmp[256], tmp2[256], tmp3[256];									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}							} else {								/* Pick one... */								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))										format = 0;								} else {									if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {										using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";										memset(&pref, 0, sizeof(pref));										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);										strcpy(caller_pref_buf,"disabled");										strcpy(host_pref_buf,"disabled");									} else {										struct ast_format tmpfmt;										using_prefs = "mine";										if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {											/* Do the opposite of what we tried above. */											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);										} else /* if no codec_prefs IE do it the old way */											format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}								}								if (!format) {									char tmp[256], tmp2[256], tmp3[256];									memset(&ied0, 0, sizeof(ied0));									iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");									iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);									ast_log(LOG_ERROR, "No best format in '%s'???\n", iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));									send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);									if (!iaxs[fr->callno]) {										break;									}									if (authdebug) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}									ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);									break;								}							}						}						if (format) {							/* No authentication required, let them in */							memset(&ied1, 0, sizeof(ied1));							iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);							iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);							send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);							if (strcmp(iaxs[fr->callno]->exten, "TBD")) {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);								ast_verb(3, "Accepting UNAUTHENTICATED call from %s:\n"												"%srequested format = %s,\n"												"%srequested prefs = %s,\n"												"%sactual format = %s,\n"												"%shost prefs = %s,\n"												"%spriority = %s\n",												ast_inet_ntoa(sin.sin_addr), 												VERBOSE_PREFIX_4,												iax2_getformatname(iaxs[fr->callno]->peerformat), 												VERBOSE_PREFIX_4,												caller_pref_buf,												VERBOSE_PREFIX_4,												iax2_getformatname(format), 												VERBOSE_PREFIX_4,												host_pref_buf, 												VERBOSE_PREFIX_4,												using_prefs);								iaxs[fr->callno]->chosenformat = format;								/* Since this is a new call, we should go ahead and set the callid for it. */								iax_pvt_callid_new(fr->callno);								ast_set_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);							} else {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);								/* If this is a TBD call, we're ready but now what...  */								ast_verb(3, "Accepted unauthenticated TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							}						}					}					break;				}				if (iaxs[fr->callno]->authmethods & IAX_AUTH_MD5)					merge_encryption(iaxs[fr->callno],ies.encmethods);				else					iaxs[fr->callno]->encmethods = 0;				if (!authenticate_request(fr->callno) && iaxs[fr->callno])					ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED);				break;			case IAX_COMMAND_DPREQ:				/* Request status in the dialplan */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD) &&					!ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED) && ies.called_number) {					if (iaxcompat) {						/* Spawn a thread for the lookup */						spawn_dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num);					} else {						/* Just look it up */						dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num, 1);					}				}				break;			case IAX_COMMAND_HANGUP:				ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);				ast_debug(1, "Immediately destroying %d, having received hangup\n", fr->callno);				/* Set hangup cause according to remote and hangupsource */				if (iaxs[fr->callno]->owner) {					set_hangup_source_and_cause(fr->callno, ies.causecode);					if (!iaxs[fr->callno]) {						break;					}				}				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_REJECT:				/* Set hangup cause according to remote and hangup source */				if (iaxs[fr->callno]->owner) {					set_hangup_source_and_cause(fr->callno, ies.causecode);					if (!iaxs[fr->callno]) {						break;					}				}				if (!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)) {					if (iaxs[fr->callno]->owner && authdebug)						ast_log(LOG_WARNING, "Call rejected by %s: %s\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr),							ies.cause ? ies.cause : "<Unknown>");					ast_debug(1, "Immediately destroying %d, having received reject\n",						fr->callno);				}				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK,						       fr->ts, NULL, 0, fr->iseqno);				if (!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION))					iaxs[fr->callno]->error = EPERM;				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_TRANSFER:			{				struct ast_channel *bridged_chan;				struct ast_channel *owner;				iax2_lock_owner(fr->callno);				if (!iaxs[fr->callno]) {					/* Initiating call went away before we could transfer. */					break;				}				owner = iaxs[fr->callno]->owner;				bridged_chan = owner ? ast_bridged_channel(owner) : NULL;				if (bridged_chan && ies.called_number) {					const char *context;					context = ast_strdupa(iaxs[fr->callno]->context);					ast_channel_ref(owner);					ast_channel_ref(bridged_chan);					ast_channel_unlock(owner);					ast_mutex_unlock(&iaxsl[fr->callno]);					/* Set BLINDTRANSFER channel variables */					pbx_builtin_setvar_helper(owner, "BLINDTRANSFER", ast_channel_name(bridged_chan));					pbx_builtin_setvar_helper(bridged_chan, "BLINDTRANSFER", ast_channel_name(owner));					/* DO NOT hold any locks while calling ast_parking_ext_valid() */					if (ast_parking_ext_valid(ies.called_number, owner, context)) {						ast_debug(1, "Parking call '%s'\n", ast_channel_name(bridged_chan));						if (iax_park(bridged_chan, owner, ies.called_number, context)) {							ast_log(LOG_WARNING, "Failed to park call '%s'\n",								ast_channel_name(bridged_chan));						}					} else {						if (ast_async_goto(bridged_chan, context, ies.called_number, 1)) {							ast_log(LOG_WARNING,								"Async goto of '%s' to '%s@%s' failed\n",								ast_channel_name(bridged_chan), ies.called_number, context);						} else {							ast_debug(1, "Async goto of '%s' to '%s@%s' started\n",								ast_channel_name(bridged_chan), ies.called_number, context);						}					}					ast_channel_unref(owner);					ast_channel_unref(bridged_chan);					ast_mutex_lock(&iaxsl[fr->callno]);				} else {					ast_debug(1, "Async goto not applicable on call %d\n", fr->callno);					if (owner) {						ast_channel_unlock(owner);					}				}				break;			}			case IAX_COMMAND_ACCEPT:				/* Ignore if call is already up or needs authentication or is a TBD */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD | IAX_STATE_AUTHENTICATED))					break;				if (ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)) {					/* Send ack immediately, before we destroy */					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					iax2_destroy(fr->callno);					break;				}				if (ies.format) {					iaxs[fr->callno]->peerformat = ies.format;				} else {					if (iaxs[fr->callno]->owner)						iaxs[fr->callno]->peerformat = ast_format_cap_to_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner));					else						iaxs[fr->callno]->peerformat = iaxs[fr->callno]->capability;				}				ast_verb(3, "Call accepted by %s (format %s)\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iax2_getformatname(iaxs[fr->callno]->peerformat));				if (!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)) {					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);					if (!iaxs[fr->callno]) {						break;					}					if (authdebug) {						char tmp1[256], tmp2[256];						ast_log(LOG_NOTICE, "Rejected call to %s, format %s incompatible with our capability %s.\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),							iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));					}				} else {					ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);					iax2_lock_owner(fr->callno);					if (iaxs[fr->callno] && iaxs[fr->callno]->owner) {						char tmp[256];						/* Switch us to use a compatible format */						ast_format_cap_from_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner), iaxs[fr->callno]->peerformat);						ast_verb(3, "Format for call is %s\n", ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(iaxs[fr->callno]->owner)));						/* Setup read/write formats properly. */						if (ast_channel_writeformat(iaxs[fr->callno]->owner)->id)							ast_set_write_format(iaxs[fr->callno]->owner, ast_channel_writeformat(iaxs[fr->callno]->owner));						if (ast_channel_readformat(iaxs[fr->callno]->owner)->id)							ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));						ast_channel_unlock(iaxs[fr->callno]->owner);					}				}				if (iaxs[fr->callno]) {					AST_LIST_LOCK(&dpcache);					AST_LIST_TRAVERSE(&iaxs[fr->callno]->dpentries, dp, peer_list)						if (!(dp->flags & CACHE_FLAG_TRANSMITTED))							iax2_dprequest(dp, fr->callno);					AST_LIST_UNLOCK(&dpcache);				}				break;			case IAX_COMMAND_POKE:				/* Send back a pong packet with the original timestamp */				send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, NULL, 0, -1);				break;			case IAX_COMMAND_PING:			{				struct iax_ie_data pingied;				construct_rr(iaxs[fr->callno], &pingied);				/* Send back a pong packet with the original timestamp */				send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, pingied.buf, pingied.pos, -1);			}				break;			case IAX_COMMAND_PONG:				/* Calculate ping time */				iaxs[fr->callno]->pingtime =  calc_timestamp(iaxs[fr->callno], 0, &f) - fr->ts;				/* save RR info */				save_rr(fr, &ies);				/* Good time to write jb stats for this call */				log_jitterstats(fr->callno);				if (iaxs[fr->callno]->peerpoke) {					peer = iaxs[fr->callno]->peerpoke;					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms)) {						if (iaxs[fr->callno]->pingtime <= peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now REACHABLE! Time: %d\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Reachable\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "IAX2/%s", peer->name); /* Activate notification */						}					} else if ((peer->historicms > 0) && (peer->historicms <= peer->maxms)) {						if (iaxs[fr->callno]->pingtime > peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now TOO LAGGED (%d ms)!\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Lagged\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_UNAVAILABLE, AST_DEVSTATE_CACHABLE, "IAX2/%s", peer->name); /* Activate notification */						}					}					peer->lastms = iaxs[fr->callno]->pingtime;					if (peer->smoothing && (peer->lastms > -1))						peer->historicms = (iaxs[fr->callno]->pingtime + peer->historicms) / 2;					else if (peer->smoothing && peer->lastms < 0)						peer->historicms = (0 + peer->historicms) / 2;					else											peer->historicms = iaxs[fr->callno]->pingtime;					/* Remove scheduled iax2_poke_noanswer */					if (peer->pokeexpire > -1) {						if (!AST_SCHED_DEL(sched, peer->pokeexpire)) {							peer_unref(peer);							peer->pokeexpire = -1;						}					}					/* Schedule the next cycle */					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms))						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_peer_s, peer_ref(peer));					else						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqok, iax2_poke_peer_s, peer_ref(peer));					if (peer->pokeexpire == -1)						peer_unref(peer);					/* and finally send the ack */					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					/* And wrap up the qualify call */					iax2_destroy(fr->callno);					peer->callno = 0;					ast_debug(1, "Peer %s: got pong, lastms %d, historicms %d, maxms %d\n", peer->name, peer->lastms, peer->historicms, peer->maxms);				}				break;			case IAX_COMMAND_LAGRQ:			case IAX_COMMAND_LAGRP:				f.src = "LAGRQ";				f.mallocd = 0;				f.offset = 0;				f.samples = 0;				iax_frame_wrap(fr, &f);				if (f.subclass.integer == IAX_COMMAND_LAGRQ) {					/* Received a LAGRQ - echo back a LAGRP */					fr->af.subclass.integer = IAX_COMMAND_LAGRP;					iax2_send(iaxs[fr->callno], &fr->af, fr->ts, -1, 0, 0, 0);				} else {					/* Received LAGRP in response to our LAGRQ */					unsigned int ts;					/* This is a reply we've been given, actually measure the difference */					ts = calc_timestamp(iaxs[fr->callno], 0, &fr->af);					iaxs[fr->callno]->lag = ts - fr->ts;					if (iaxdebug)						ast_debug(1, "Peer %s lag measured as %dms\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->lag);				}				break;			case IAX_COMMAND_AUTHREQ:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)) {					ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					break;				}				if (authenticate_reply(iaxs[fr->callno], &iaxs[fr->callno]->addr, &ies, iaxs[fr->callno]->secret, iaxs[fr->callno]->outkey)) {					struct ast_frame hangup_fr = { .frametype = AST_FRAME_CONTROL,								.subclass.integer = AST_CONTROL_HANGUP,					};					ast_log(LOG_WARNING, 						"I don't know how to authenticate %s to %s\n", 						ies.username ? ies.username : "<unknown>", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr));					iax2_queue_frame(fr->callno, &hangup_fr);				}				break;			case IAX_COMMAND_AUTHREP:				/* For security, always ack immediately */				if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				/* Ignore once we've started */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)) {					ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					break;				}				if (authenticate_verify(iaxs[fr->callno], &ies)) {					if (authdebug)						ast_log(LOG_NOTICE, "Host %s failed to authenticate as %s\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->username);					memset(&ied0, 0, sizeof(ied0));					auth_fail(fr->callno, IAX_COMMAND_REJECT);					break;				}				if (strcasecmp(iaxs[fr->callno]->exten, "TBD")) {					/* This might re-enter the IAX code and need the lock */					exists = ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num);				} else					exists = 0;				if (strcmp(iaxs[fr->callno]->exten, "TBD") && !exists) {					if (authdebug)						ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);					if (!iaxs[fr->callno]) {						break;					}				} else {					/* Select an appropriate format */					if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {							using_prefs = "reqonly";						} else {							using_prefs = "disabled";						}						format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;						memset(&pref, 0, sizeof(pref));						strcpy(caller_pref_buf, "disabled");						strcpy(host_pref_buf, "disabled");					} else {						struct ast_format tmpfmt;						using_prefs = "mine";						if (ies.codec_prefs)							ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);						if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {							if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {								pref = iaxs[fr->callno]->rprefs;								using_prefs = "caller";							} else {								pref = iaxs[fr->callno]->prefs;							}						} else /* if no codec_prefs IE do it the old way */							pref = iaxs[fr->callno]->prefs;						format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);						ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);						ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);					}					if (!format) {						char tmp1[256], tmp2[256], tmp3[256];						if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {							ast_debug(1, "We don't do requested format %s, falling back to peer capability '%s'\n",								iax2_getformatname(iaxs[fr->callno]->peerformat),								iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability));							format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;						}						if (!format) {							if (authdebug) {								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n", ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));								} else {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",										ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),										iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));								}							}							memset(&ied0, 0, sizeof(ied0));							iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");							iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);							send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);							if (!iaxs[fr->callno]) {								break;							}						} else {							/* Pick one... */							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))									format = 0;							} else {								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {									using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";									memset(&pref, 0, sizeof(pref));									format = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ?										iaxs[fr->callno]->peerformat : iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									strcpy(caller_pref_buf,"disabled");									strcpy(host_pref_buf,"disabled");								} else {									struct ast_format tmpfmt;									using_prefs = "mine";									if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {										/* Do the opposite of what we tried above. */										if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {											pref = iaxs[fr->callno]->prefs;										} else {											pref = iaxs[fr->callno]->rprefs;											using_prefs = "caller";										}										format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);									} else /* if no codec_prefs IE do it the old way */										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}							}							if (!format) {								char tmp1[256], tmp2[256], tmp3[256];								ast_log(LOG_ERROR, "No best format in %s???\n",									iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));								if (authdebug) {									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}							}						}					}					if (format) {						/* Authentication received */						memset(&ied1, 0, sizeof(ied1));						iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);						iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);						send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);						if (strcmp(iaxs[fr->callno]->exten, "TBD")) {							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							ast_verb(3, "Accepting AUTHENTICATED call from %s:\n"											"%srequested format = %s,\n"											"%srequested prefs = %s,\n"											"%sactual format = %s,\n"											"%shost prefs = %s,\n"											"%spriority = %s\n", 											ast_inet_ntoa(sin.sin_addr), 											VERBOSE_PREFIX_4,											iax2_getformatname(iaxs[fr->callno]->peerformat),											VERBOSE_PREFIX_4,											caller_pref_buf,											VERBOSE_PREFIX_4,											iax2_getformatname(format),											VERBOSE_PREFIX_4,											host_pref_buf,											VERBOSE_PREFIX_4,											using_prefs);							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, format, NULL, 1)))								iax2_destroy(fr->callno);							else if (ies.vars) {								struct ast_datastore *variablestore;								struct ast_variable *var, *prev = NULL;								AST_LIST_HEAD(, ast_var_t) *varlist;								varlist = ast_calloc(1, sizeof(*varlist));								variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);								if (variablestore && varlist) {									variablestore->data = varlist;									variablestore->inheritance = DATASTORE_INHERIT_FOREVER;									AST_LIST_HEAD_INIT(varlist);									ast_debug(1, "I can haz IAX vars? w00t\n");									for (var = ies.vars; var; var = var->next) {										struct ast_var_t *newvar = ast_var_assign(var->name, var->value);										if (prev)											ast_free(prev);										prev = var;										if (!newvar) {											/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */											ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");										} else {											AST_LIST_INSERT_TAIL(varlist, newvar, entries);										}									}									if (prev)										ast_free(prev);									ies.vars = NULL;									ast_channel_datastore_add(c, variablestore);								} else {									ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									if (variablestore)										ast_datastore_free(variablestore);									if (varlist)										ast_free(varlist);								}							}						} else {							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);							/* If this is a TBD call, we're ready but now what...  */							ast_verb(3, "Accepted AUTHENTICATED TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							if (ast_test_flag64(iaxs[fr->callno], IAX_IMMEDIATE)) {								goto immediatedial;							}						}					}				}				break;			case IAX_COMMAND_DIAL:immediatedial:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD)) {					ast_clear_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);					ast_string_field_set(iaxs[fr->callno], exten, ies.called_number ? ies.called_number : "s");					if (!ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num)) {						if (authdebug)							ast_log(LOG_NOTICE, "Rejected dial attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}					} else {						char tmp[256];						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);						ast_verb(3, "Accepting DIAL from %s, formats = %s\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat));						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);						send_command(iaxs[fr->callno], AST_FRAME_CONTROL, AST_CONTROL_PROGRESS, 0, NULL, 0, -1);						if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->peerformat, NULL, 1)))							iax2_destroy(fr->callno);						else if (ies.vars) {							struct ast_datastore *variablestore;							struct ast_variable *var, *prev = NULL;							AST_LIST_HEAD(, ast_var_t) *varlist;							varlist = ast_calloc(1, sizeof(*varlist));							variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);							ast_debug(1, "I can haz IAX vars? w00t\n");							if (variablestore && varlist) {								variablestore->data = varlist;								variablestore->inheritance = DATASTORE_INHERIT_FOREVER;								AST_LIST_HEAD_INIT(varlist);								for (var = ies.vars; var; var = var->next) {									struct ast_var_t *newvar = ast_var_assign(var->name, var->value);									if (prev)										ast_free(prev);									prev = var;									if (!newvar) {										/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */										ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									} else {										AST_LIST_INSERT_TAIL(varlist, newvar, entries);									}								}								if (prev)									ast_free(prev);								ies.vars = NULL;								ast_channel_datastore_add(c, variablestore);							} else {								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");								if (variablestore)									ast_datastore_free(variablestore);								if (varlist)									ast_free(varlist);							}						}					}				}				break;			case IAX_COMMAND_INVAL:				iaxs[fr->callno]->error = ENOTCONN;				ast_debug(1, "Immediately destroying %d, having received INVAL\n", fr->callno);				iax2_destroy(fr->callno);				ast_debug(1, "Destroying call %d\n", fr->callno);				break;			case IAX_COMMAND_VNAK:				ast_debug(1, "Received VNAK: resending outstanding frames\n");				/* Force retransmission */				vnak_retransmit(fr->callno, fr->iseqno);				break;			case IAX_COMMAND_REGREQ:			case IAX_COMMAND_REGREL:				/* For security, always ack immediately */				if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				if (register_verify(fr->callno, &sin, &ies)) {					if (!iaxs[fr->callno]) {						break;					}					/* Send delayed failure */					auth_fail(fr->callno, IAX_COMMAND_REGREJ);					break;				}				if (!iaxs[fr->callno]) {					break;				}				if ((ast_strlen_zero(iaxs[fr->callno]->secret) && ast_strlen_zero(iaxs[fr->callno]->inkeys)) ||						ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED)) {					if (f.subclass.integer == IAX_COMMAND_REGREL) {						memset(&sin, 0, sizeof(sin));						sin.sin_family = AF_INET;					}					if (update_registry(&sin, fr->callno, ies.devicetype, fd, ies.refresh)) {						ast_log(LOG_WARNING, "Registry error\n");					}					if (!iaxs[fr->callno]) {						break;					}					if (ies.provverpres && ies.serviceident && sin.sin_addr.s_addr) {						ast_mutex_unlock(&iaxsl[fr->callno]);						check_provisioning(&sin, fd, ies.serviceident, ies.provver);						ast_mutex_lock(&iaxsl[fr->callno]);					}					break;				}				registry_authrequest(fr->callno);				break;			case IAX_COMMAND_REGACK:				if (iax2_ack_registry(&ies, &sin, fr->callno)) 					ast_log(LOG_WARNING, "Registration failure\n");				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_REGREJ:				if (iaxs[fr->callno]->reg) {					if (authdebug) {						ast_log(LOG_NOTICE, "Registration of '%s' rejected: '%s' from: '%s'\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>", ast_inet_ntoa(sin.sin_addr));						manager_event(EVENT_FLAG_SYSTEM, "Registry", "ChannelType: IAX2\r\nUsername: %s\r\nStatus: Rejected\r\nCause: %s\r\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>");					}					iaxs[fr->callno]->reg->regstate = REG_STATE_REJECTED;				}				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_REGAUTH:				/* Authentication request */				if (registry_rerequest(&ies, fr->callno, &sin)) {					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No authority found");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_FACILITY_NOT_SUBSCRIBED);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);				}				break;			case IAX_COMMAND_TXREJ:				iaxs[fr->callno]->transferring = 0;				ast_verb(3, "Channel '%s' unable to transfer\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");				memset(&iaxs[fr->callno]->transfer, 0, sizeof(iaxs[fr->callno]->transfer));				if (iaxs[fr->callno]->bridgecallno) {					if (iaxs[iaxs[fr->callno]->bridgecallno]->transferring) {						iaxs[iaxs[fr->callno]->bridgecallno]->transferring = 0;						send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREJ, 0, NULL, 0, -1);					}				}				break;			case IAX_COMMAND_TXREADY:				if ((iaxs[fr->callno]->transferring == TRANSFER_BEGIN) ||				    (iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)) {					if (iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)						iaxs[fr->callno]->transferring = TRANSFER_MREADY;					else						iaxs[fr->callno]->transferring = TRANSFER_READY;					ast_verb(3, "Channel '%s' ready to transfer\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					if (iaxs[fr->callno]->bridgecallno) {						if ((iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_READY) ||						    (iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_MREADY)) {							/* They're both ready, now release them. */							if (iaxs[fr->callno]->transferring == TRANSFER_MREADY) {								ast_verb(3, "Attempting media bridge of %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_MEDIA;								iaxs[fr->callno]->transferring = TRANSFER_MEDIA;								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied1.buf, ied1.pos, -1);							} else {								ast_verb(3, "Releasing %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_RELEASED;								iaxs[fr->callno]->transferring = TRANSFER_RELEASED;								ast_set_flag64(iaxs[iaxs[fr->callno]->bridgecallno], IAX_ALREADYGONE);								ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);								/* Stop doing lag & ping requests */								stop_stuff(fr->callno);								stop_stuff(iaxs[fr->callno]->bridgecallno);								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied1.buf, ied1.pos, -1);							}						}					}				}				break;			case IAX_COMMAND_TXREQ:				try_transfer(iaxs[fr->callno], &ies);				break;			case IAX_COMMAND_TXCNT:				if (iaxs[fr->callno]->transferring)					send_command_transfer(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXACC, 0, NULL, 0);				break;			case IAX_COMMAND_TXREL:				/* Send ack immediately, rather than waiting until we've changed addresses */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				complete_transfer(fr->callno, &ies);				stop_stuff(fr->callno);	/* for attended transfer to work with libiax */				break;				case IAX_COMMAND_TXMEDIA:				if (iaxs[fr->callno]->transferring == TRANSFER_READY) {					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* Cancel any outstanding frames and start anew */						if (cur->transfer) {							cur->retries = -1;						}					}					/* Start sending our media to the transfer address, but otherwise leave the call as-is */					iaxs[fr->callno]->transferring = TRANSFER_MEDIAPASS;				}				break;			case IAX_COMMAND_RTKEY:				if (!IAX_CALLENCRYPTED(iaxs[fr->callno])) {					ast_log(LOG_WARNING, 						"we've been told to rotate our encryption key, "						"but this isn't an encrypted call. bad things will happen.\n"					);					break;				}				IAX_DEBUGDIGEST("Receiving", ies.challenge);				ast_aes_set_decrypt_key((unsigned char *) ies.challenge, &iaxs[fr->callno]->dcx);				break;			case IAX_COMMAND_DPREP:				complete_dpreply(iaxs[fr->callno], &ies);				break;			case IAX_COMMAND_UNSUPPORT:				ast_log(LOG_NOTICE, "Peer did not understand our iax command '%d'\n", ies.iax_unknown);				break;			case IAX_COMMAND_FWDOWNL:				/* Firmware download */				if (!ast_test_flag64(&globalflags, IAX_ALLOWFWDOWNLOAD)) {					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_UNSUPPORT, 0, NULL, 0, -1);					break;				}				memset(&ied0, 0, sizeof(ied0));				res = iax_firmware_append(&ied0, (unsigned char *)ies.devicetype, ies.fwdesc);				if (res < 0)					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);				else if (res > 0)					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1);				else					send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1);				break;			case IAX_COMMAND_CALLTOKEN:			{				struct iax_frame *cur;				/* find last sent frame */				if ((cur = AST_LIST_LAST(&frame_queue[fr->callno])) && ies.calltoken && ies.calltokendata) {					resend_with_token(fr->callno, cur, (char *) ies.calltokendata);				}				break;			}			default:				ast_debug(1, "Unknown IAX command %d on %d/%d\n", f.subclass.integer, fr->callno, iaxs[fr->callno]->peercallno);				memset(&ied0, 0, sizeof(ied0));				iax_ie_append_byte(&ied0, IAX_IE_IAX_UNKNOWN, f.subclass.integer);				send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_UNSUPPORT, 0, ied0.buf, ied0.pos, -1);			}			/* Free remote variables (if any) */			if (ies.vars) {				ast_variables_destroy(ies.vars);				ast_debug(1, "I can haz IAX vars, but they is no good :-(\n");				ies.vars = NULL;			}			/* Don't actually pass these frames along */			if ((f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&			  (f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_INVAL) &&			  (f.subclass.integer != IAX_COMMAND_VNAK)) {				if (iaxs[fr->callno] && iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);			}			ast_mutex_unlock(&iaxsl[fr->callno]);			return 1;		}
ntohs(mh->callno) & IAX_FLAG_FULL
ntohs(mh->callno)
ntohs
ntohs
mh->callno
mh
mh
callno
IAX_FLAG_FULL
IAX_FLAG_FULL
{		if (iaxdebug)			ast_debug(1, "Received packet %d, (%d, %u)\n", fh->oseqno, f.frametype, f.subclass.integer);		/* Check if it's out of order (and not an ACK or INVAL) */		fr->oseqno = fh->oseqno;		fr->iseqno = fh->iseqno;		fr->ts = ntohl(fh->ts);#ifdef IAXTESTS		if (test_resync) {			ast_debug(1, "Simulating frame ts resync, was %u now %u\n", fr->ts, fr->ts + test_resync);			fr->ts += test_resync;		}#endif /* IAXTESTS */#if 0		if ( (ntohs(fh->dcallno) & IAX_FLAG_RETRANS) ||		     ( (f.frametype != AST_FRAME_VOICE) && ! (f.frametype == AST_FRAME_IAX &&								(f.subclass == IAX_COMMAND_NEW ||								 f.subclass == IAX_COMMAND_AUTHREQ ||								 f.subclass == IAX_COMMAND_ACCEPT ||								 f.subclass == IAX_COMMAND_REJECT))      ) )#endif		if ((ntohs(fh->dcallno) & IAX_FLAG_RETRANS) || (f.frametype != AST_FRAME_VOICE))			updatehistory = 0;		if ((iaxs[fr->callno]->iseqno != fr->oseqno) &&			(iaxs[fr->callno]->iseqno ||				((f.subclass.integer != IAX_COMMAND_TXCNT) &&				(f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXACC)) ||				(f.frametype != AST_FRAME_IAX))) {			if (			 ((f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_INVAL) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&			  (f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_VNAK)) ||			  (f.frametype != AST_FRAME_IAX)) {				/* If it's not an ACK packet, it's out of order. */				ast_debug(1, "Packet arrived out of order (expecting %d, got %d) (frametype = %d, subclass = %d)\n",					iaxs[fr->callno]->iseqno, fr->oseqno, f.frametype, f.subclass.integer);				/* Check to see if we need to request retransmission,				 * and take sequence number wraparound into account */				if ((unsigned char) (iaxs[fr->callno]->iseqno - fr->oseqno) < 128) {					/* If we've already seen it, ack it XXX There's a border condition here XXX */					if ((f.frametype != AST_FRAME_IAX) ||							((f.subclass.integer != IAX_COMMAND_ACK) && (f.subclass.integer != IAX_COMMAND_INVAL))) {						ast_debug(1, "Acking anyway\n");						/* XXX Maybe we should handle its ack to us, but then again, it's probably outdated anyway, and if						   we have anything to send, we'll retransmit and get an ACK back anyway XXX */						send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					}				} else {					/* Send a VNAK requesting retransmission */					iax2_vnak(fr->callno);				}				ast_variables_destroy(ies.vars);				ast_mutex_unlock(&iaxsl[fr->callno]);				return 1;			}		} else {			/* Increment unless it's an ACK or VNAK */			if (((f.subclass.integer != IAX_COMMAND_ACK) &&			    (f.subclass.integer != IAX_COMMAND_INVAL) &&			    (f.subclass.integer != IAX_COMMAND_TXCNT) &&			    (f.subclass.integer != IAX_COMMAND_TXACC) &&				(f.subclass.integer != IAX_COMMAND_VNAK)) ||			    (f.frametype != AST_FRAME_IAX))				iaxs[fr->callno]->iseqno++;		}		/* Ensure text frames are NULL-terminated */		if (f.frametype == AST_FRAME_TEXT && thread->buf[res - 1] != '\0') {			if (res < thread->buf_size)				thread->buf[res++] = '\0';			else /* Trims one character from the text message, but that's better than overwriting the end of the buffer. */				thread->buf[res - 1] = '\0';		}		/* Handle implicit ACKing unless this is an INVAL, and only if this is 		   from the real peer, not the transfer peer */		if (!inaddrcmp(&sin, &iaxs[fr->callno]->addr) &&		    ((f.subclass.integer != IAX_COMMAND_INVAL) ||		     (f.frametype != AST_FRAME_IAX))) {			unsigned char x;			int call_to_destroy;			/* First we have to qualify that the ACKed value is within our window */			if (iaxs[fr->callno]->rseqno >= iaxs[fr->callno]->oseqno || (fr->iseqno >= iaxs[fr->callno]->rseqno && fr->iseqno < iaxs[fr->callno]->oseqno))				x = fr->iseqno;			else				x = iaxs[fr->callno]->oseqno;			if ((x != iaxs[fr->callno]->oseqno) || (iaxs[fr->callno]->oseqno == fr->iseqno)) {				/* The acknowledgement is within our window.  Time to acknowledge everything				   that it says to */				for (x=iaxs[fr->callno]->rseqno; x != fr->iseqno; x++) {					/* Ack the packet with the given timestamp */					if (iaxdebug)						ast_debug(1, "Cancelling transmission of packet %d\n", x);					call_to_destroy = 0;					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* If it's our call, and our timestamp, mark -1 retries */						if (x == cur->oseqno) {							cur->retries = -1;							/* Destroy call if this is the end */							if (cur->final)								call_to_destroy = fr->callno;						}					}					if (call_to_destroy) {						if (iaxdebug)							ast_debug(1, "Really destroying %d, having been acked on final message\n", call_to_destroy);						ast_mutex_lock(&iaxsl[call_to_destroy]);						iax2_destroy(call_to_destroy);						ast_mutex_unlock(&iaxsl[call_to_destroy]);					}				}				/* Note how much we've received acknowledgement for */				if (iaxs[fr->callno])					iaxs[fr->callno]->rseqno = fr->iseqno;				else {					/* Stop processing now */					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}			} else {				ast_debug(1, "Received iseqno %d not within window %d->%d\n", fr->iseqno, iaxs[fr->callno]->rseqno, iaxs[fr->callno]->oseqno);			}		}		if (inaddrcmp(&sin, &iaxs[fr->callno]->addr) &&			((f.frametype != AST_FRAME_IAX) ||			 ((f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT)))) {			/* Only messages we accept from a transfer host are TXACC and TXCNT */			ast_variables_destroy(ies.vars);			ast_mutex_unlock(&iaxsl[fr->callno]);			return 1;		}		/* when we receive the first full frame for a new incoming channel,		   it is safe to start the PBX on the channel because we have now		   completed a 3-way handshake with the peer */		if ((f.frametype == AST_FRAME_VOICE) ||		    (f.frametype == AST_FRAME_VIDEO) ||		    (f.frametype == AST_FRAME_IAX)) {			if (ast_test_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART)) {				ast_clear_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);				if (!ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->chosenformat, NULL,						  ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED))) {					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}			}			if (ies.vars) {				struct ast_datastore *variablestore = NULL;				struct ast_variable *var, *prev = NULL;				AST_LIST_HEAD(, ast_var_t) *varlist;				iax2_lock_owner(fr->callno);				if (!iaxs[fr->callno]) {					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}				if ((c = iaxs[fr->callno]->owner)) {					varlist = ast_calloc(1, sizeof(*varlist));					variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);					if (variablestore && varlist) {						variablestore->data = varlist;						variablestore->inheritance = DATASTORE_INHERIT_FOREVER;						AST_LIST_HEAD_INIT(varlist);						ast_debug(1, "I can haz IAX vars?\n");						for (var = ies.vars; var; var = var->next) {							struct ast_var_t *newvar = ast_var_assign(var->name, var->value);							if (prev) {								ast_free(prev);							}							prev = var;							if (!newvar) {								/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");							} else {								AST_LIST_INSERT_TAIL(varlist, newvar, entries);							}						}						if (prev) {							ast_free(prev);						}						ies.vars = NULL;						ast_channel_datastore_add(c, variablestore);					} else {						ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");						if (variablestore) {							ast_datastore_free(variablestore);						}						if (varlist) {							ast_free(varlist);						}					}					ast_channel_unlock(c);				} else {					/* No channel yet, so transfer the variables directly over to the pvt,					 * for later inheritance. */					ast_debug(1, "No channel, so populating IAXVARs to the pvt, as an intermediate step.\n");					for (var = ies.vars; var && var->next; var = var->next);					if (var) {						var->next = iaxs[fr->callno]->iaxvars;						iaxs[fr->callno]->iaxvars = ies.vars;						ies.vars = NULL;					}				}			}			if (ies.vars) {				ast_debug(1, "I have IAX variables, but they were not processed\n");			}		}		/* once we receive our first IAX Full Frame that is not CallToken related, send all		 * queued signaling frames that were being held. */		if ((f.frametype == AST_FRAME_IAX) && (f.subclass.integer != IAX_COMMAND_CALLTOKEN) && iaxs[fr->callno]->hold_signaling) {			send_signaling(iaxs[fr->callno]);		}		if (f.frametype == AST_FRAME_VOICE) {			if (ast_format_to_old_bitfield(&f.subclass.format) != iaxs[fr->callno]->voiceformat) {					iaxs[fr->callno]->voiceformat = ast_format_to_old_bitfield(&f.subclass.format);					ast_debug(1, "Ooh, voice format changed to '%s'\n", ast_getformatname(&f.subclass.format));					if (iaxs[fr->callno]->owner) {						iax2_lock_owner(fr->callno);						if (iaxs[fr->callno]) {							if (iaxs[fr->callno]->owner) {								struct ast_format_cap *orignative = ast_format_cap_dup(ast_channel_nativeformats(iaxs[fr->callno]->owner));								struct ast_format_cap *native = ast_channel_nativeformats(iaxs[fr->callno]->owner);								if (orignative) {									ast_format_cap_set(native, &f.subclass.format);									if (ast_channel_readformat(iaxs[fr->callno]->owner)->id) {										ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));									}									ast_format_cap_copy(native, orignative);									ast_channel_unlock(iaxs[fr->callno]->owner);									orignative = ast_format_cap_destroy(orignative);								}							}						} else {							ast_debug(1, "Neat, somebody took away the channel at a magical time but i found it!\n");							/* Free remote variables (if any) */							if (ies.vars) {								ast_variables_destroy(ies.vars);								ast_debug(1, "I can haz iaxvars, but they is no good.  :-(\n");								ies.vars = NULL;							}							ast_mutex_unlock(&iaxsl[fr->callno]);							return 1;						}					}			}		}		if (f.frametype == AST_FRAME_VIDEO) {			if (f.subclass.format.id != ast_format_id_from_old_bitfield(iaxs[fr->callno]->videoformat)) {				ast_debug(1, "Ooh, video format changed to %s\n", ast_getformatname(&f.subclass.format));				iaxs[fr->callno]->videoformat = ast_format_to_old_bitfield(&f.subclass.format);			}		}		if (f.frametype == AST_FRAME_CONTROL && iaxs[fr->callno]->owner) {			if (f.subclass.integer == AST_CONTROL_BUSY) {				ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_BUSY);			} else if (f.subclass.integer == AST_CONTROL_CONGESTION) {				ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_CONGESTION);			}		}		if (f.frametype == AST_FRAME_IAX) {			AST_SCHED_DEL(sched, iaxs[fr->callno]->initid);			/* Handle the IAX pseudo frame itself */			if (iaxdebug)				ast_debug(1, "IAX subclass %d received\n", f.subclass.integer);                        /* Update last ts unless the frame's timestamp originated with us. */			if (iaxs[fr->callno]->last < fr->ts &&                            f.subclass.integer != IAX_COMMAND_ACK &&                            f.subclass.integer != IAX_COMMAND_PONG &&                            f.subclass.integer != IAX_COMMAND_LAGRP) {				iaxs[fr->callno]->last = fr->ts;				if (iaxdebug)					ast_debug(1, "For call=%d, set last=%d\n", fr->callno, fr->ts);			}			iaxs[fr->callno]->last_iax_message = f.subclass.integer;			if (!iaxs[fr->callno]->first_iax_message) {				iaxs[fr->callno]->first_iax_message = f.subclass.integer;			}			switch(f.subclass.integer) {			case IAX_COMMAND_ACK:				/* Do nothing */				break;			case IAX_COMMAND_QUELCH:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {				        /* Generate Manager Hold event, if necessary*/					if (iaxs[fr->callno]->owner) {						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: On\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}					ast_set_flag64(iaxs[fr->callno], IAX_QUELCH);					if (ies.musiconhold) {						iax2_lock_owner(fr->callno);						if (!iaxs[fr->callno] || !iaxs[fr->callno]->owner) {							break;						}						if (ast_bridged_channel(iaxs[fr->callno]->owner)) {							const char *moh_suggest = iaxs[fr->callno]->mohsuggest;							/*							 * We already hold the owner lock so we do not							 * need to check iaxs[fr->callno] after it returns.							 */							iax2_queue_control_data(fr->callno, AST_CONTROL_HOLD, 								S_OR(moh_suggest, NULL),								!ast_strlen_zero(moh_suggest) ? strlen(moh_suggest) + 1 : 0);						}						ast_channel_unlock(iaxs[fr->callno]->owner);					}				}				break;			case IAX_COMMAND_UNQUELCH:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {					iax2_lock_owner(fr->callno);					if (!iaxs[fr->callno]) {						break;					}					/* Generate Manager Unhold event, if necessary */					if (iaxs[fr->callno]->owner && ast_test_flag64(iaxs[fr->callno], IAX_QUELCH)) {						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: Off\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}					ast_clear_flag64(iaxs[fr->callno], IAX_QUELCH);					if (!iaxs[fr->callno]->owner) {						break;					}					if (ast_bridged_channel(iaxs[fr->callno]->owner)) {						/*						 * We already hold the owner lock so we do not						 * need to check iaxs[fr->callno] after it returns.						 */						iax2_queue_control_data(fr->callno, AST_CONTROL_UNHOLD, NULL, 0);					}					ast_channel_unlock(iaxs[fr->callno]->owner);				}				break;			case IAX_COMMAND_TXACC:				if (iaxs[fr->callno]->transferring == TRANSFER_BEGIN) {					/* Ack the packet with the given timestamp */					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* Cancel any outstanding txcnt's */						if (cur->transfer) {							cur->retries = -1;						}					}					memset(&ied1, 0, sizeof(ied1));					iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->callno);					send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREADY, 0, ied1.buf, ied1.pos, -1);					iaxs[fr->callno]->transferring = TRANSFER_READY;				}				break;			case IAX_COMMAND_NEW:				/* Ignore if it's already up */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD))					break;				if (ies.provverpres && ies.serviceident && sin.sin_addr.s_addr) {					ast_mutex_unlock(&iaxsl[fr->callno]);					check_provisioning(&sin, fd, ies.serviceident, ies.provver);					ast_mutex_lock(&iaxsl[fr->callno]);					if (!iaxs[fr->callno]) {						break;					}				}				/* If we're in trunk mode, do it now, and update the trunk number in our frame before continuing */				if (ast_test_flag64(iaxs[fr->callno], IAX_TRUNK)) {					int new_callno;					if ((new_callno = make_trunk(fr->callno, 1)) != -1)						fr->callno = new_callno;				}				/* For security, always ack immediately */				if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				if (check_access(fr->callno, &sin, &ies)) {					/* They're not allowed on */					auth_fail(fr->callno, IAX_COMMAND_REJECT);					if (authdebug)						ast_log(LOG_NOTICE, "Rejected connect attempt from %s, who was trying to reach '%s@%s'\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					break;				}				if (ast_strlen_zero(iaxs[fr->callno]->secret) && ast_test_flag64(iaxs[fr->callno], IAX_FORCE_ENCRYPT)) {					auth_fail(fr->callno, IAX_COMMAND_REJECT);					ast_log(LOG_WARNING, "Rejected connect attempt.  No secret present while force encrypt enabled.\n");					break;				}				if (strcasecmp(iaxs[fr->callno]->exten, "TBD")) {					const char *context, *exten, *cid_num;					context = ast_strdupa(iaxs[fr->callno]->context);					exten = ast_strdupa(iaxs[fr->callno]->exten);					cid_num = ast_strdupa(iaxs[fr->callno]->cid_num);					/* This might re-enter the IAX code and need the lock */					ast_mutex_unlock(&iaxsl[fr->callno]);					exists = ast_exists_extension(NULL, context, exten, 1, cid_num);					ast_mutex_lock(&iaxsl[fr->callno]);					if (!iaxs[fr->callno]) {						break;					}				} else					exists = 0;				/* Get OSP token if it does exist */				save_osptoken(fr, &ies);				if (ast_strlen_zero(iaxs[fr->callno]->secret) && ast_strlen_zero(iaxs[fr->callno]->inkeys)) {					if (strcmp(iaxs[fr->callno]->exten, "TBD") && !exists) {						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}						if (authdebug)							ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					} else {						/* Select an appropriate format */						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								using_prefs = "reqonly";							} else {								using_prefs = "disabled";							}							format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;							memset(&pref, 0, sizeof(pref));							strcpy(caller_pref_buf, "disabled");							strcpy(host_pref_buf, "disabled");						} else {							struct ast_format tmpfmt;							using_prefs = "mine";							/* If the information elements are in here... use them */							if (ies.codec_prefs)								ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);							if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {								/* If we are codec_first_choice we let the caller have the 1st shot at picking the codec.*/								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {									pref = iaxs[fr->callno]->rprefs;									using_prefs = "caller";								} else {									pref = iaxs[fr->callno]->prefs;								}							} else								pref = iaxs[fr->callno]->prefs;							format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);							ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);							ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);						}						if (!format) {							if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP))								format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;							if (!format) {								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}								if (authdebug) {									char tmp[256], tmp2[256], tmp3[256];									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}							} else {								/* Pick one... */								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))										format = 0;								} else {									if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {										using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";										memset(&pref, 0, sizeof(pref));										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);										strcpy(caller_pref_buf,"disabled");										strcpy(host_pref_buf,"disabled");									} else {										struct ast_format tmpfmt;										using_prefs = "mine";										if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {											/* Do the opposite of what we tried above. */											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);										} else /* if no codec_prefs IE do it the old way */											format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}								}								if (!format) {									char tmp[256], tmp2[256], tmp3[256];									memset(&ied0, 0, sizeof(ied0));									iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");									iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);									ast_log(LOG_ERROR, "No best format in '%s'???\n", iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));									send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);									if (!iaxs[fr->callno]) {										break;									}									if (authdebug) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}									ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);									break;								}							}						}						if (format) {							/* No authentication required, let them in */							memset(&ied1, 0, sizeof(ied1));							iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);							iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);							send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);							if (strcmp(iaxs[fr->callno]->exten, "TBD")) {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);								ast_verb(3, "Accepting UNAUTHENTICATED call from %s:\n"												"%srequested format = %s,\n"												"%srequested prefs = %s,\n"												"%sactual format = %s,\n"												"%shost prefs = %s,\n"												"%spriority = %s\n",												ast_inet_ntoa(sin.sin_addr), 												VERBOSE_PREFIX_4,												iax2_getformatname(iaxs[fr->callno]->peerformat), 												VERBOSE_PREFIX_4,												caller_pref_buf,												VERBOSE_PREFIX_4,												iax2_getformatname(format), 												VERBOSE_PREFIX_4,												host_pref_buf, 												VERBOSE_PREFIX_4,												using_prefs);								iaxs[fr->callno]->chosenformat = format;								/* Since this is a new call, we should go ahead and set the callid for it. */								iax_pvt_callid_new(fr->callno);								ast_set_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);							} else {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);								/* If this is a TBD call, we're ready but now what...  */								ast_verb(3, "Accepted unauthenticated TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							}						}					}					break;				}				if (iaxs[fr->callno]->authmethods & IAX_AUTH_MD5)					merge_encryption(iaxs[fr->callno],ies.encmethods);				else					iaxs[fr->callno]->encmethods = 0;				if (!authenticate_request(fr->callno) && iaxs[fr->callno])					ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED);				break;			case IAX_COMMAND_DPREQ:				/* Request status in the dialplan */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD) &&					!ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED) && ies.called_number) {					if (iaxcompat) {						/* Spawn a thread for the lookup */						spawn_dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num);					} else {						/* Just look it up */						dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num, 1);					}				}				break;			case IAX_COMMAND_HANGUP:				ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);				ast_debug(1, "Immediately destroying %d, having received hangup\n", fr->callno);				/* Set hangup cause according to remote and hangupsource */				if (iaxs[fr->callno]->owner) {					set_hangup_source_and_cause(fr->callno, ies.causecode);					if (!iaxs[fr->callno]) {						break;					}				}				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_REJECT:				/* Set hangup cause according to remote and hangup source */				if (iaxs[fr->callno]->owner) {					set_hangup_source_and_cause(fr->callno, ies.causecode);					if (!iaxs[fr->callno]) {						break;					}				}				if (!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)) {					if (iaxs[fr->callno]->owner && authdebug)						ast_log(LOG_WARNING, "Call rejected by %s: %s\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr),							ies.cause ? ies.cause : "<Unknown>");					ast_debug(1, "Immediately destroying %d, having received reject\n",						fr->callno);				}				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK,						       fr->ts, NULL, 0, fr->iseqno);				if (!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION))					iaxs[fr->callno]->error = EPERM;				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_TRANSFER:			{				struct ast_channel *bridged_chan;				struct ast_channel *owner;				iax2_lock_owner(fr->callno);				if (!iaxs[fr->callno]) {					/* Initiating call went away before we could transfer. */					break;				}				owner = iaxs[fr->callno]->owner;				bridged_chan = owner ? ast_bridged_channel(owner) : NULL;				if (bridged_chan && ies.called_number) {					const char *context;					context = ast_strdupa(iaxs[fr->callno]->context);					ast_channel_ref(owner);					ast_channel_ref(bridged_chan);					ast_channel_unlock(owner);					ast_mutex_unlock(&iaxsl[fr->callno]);					/* Set BLINDTRANSFER channel variables */					pbx_builtin_setvar_helper(owner, "BLINDTRANSFER", ast_channel_name(bridged_chan));					pbx_builtin_setvar_helper(bridged_chan, "BLINDTRANSFER", ast_channel_name(owner));					/* DO NOT hold any locks while calling ast_parking_ext_valid() */					if (ast_parking_ext_valid(ies.called_number, owner, context)) {						ast_debug(1, "Parking call '%s'\n", ast_channel_name(bridged_chan));						if (iax_park(bridged_chan, owner, ies.called_number, context)) {							ast_log(LOG_WARNING, "Failed to park call '%s'\n",								ast_channel_name(bridged_chan));						}					} else {						if (ast_async_goto(bridged_chan, context, ies.called_number, 1)) {							ast_log(LOG_WARNING,								"Async goto of '%s' to '%s@%s' failed\n",								ast_channel_name(bridged_chan), ies.called_number, context);						} else {							ast_debug(1, "Async goto of '%s' to '%s@%s' started\n",								ast_channel_name(bridged_chan), ies.called_number, context);						}					}					ast_channel_unref(owner);					ast_channel_unref(bridged_chan);					ast_mutex_lock(&iaxsl[fr->callno]);				} else {					ast_debug(1, "Async goto not applicable on call %d\n", fr->callno);					if (owner) {						ast_channel_unlock(owner);					}				}				break;			}			case IAX_COMMAND_ACCEPT:				/* Ignore if call is already up or needs authentication or is a TBD */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD | IAX_STATE_AUTHENTICATED))					break;				if (ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)) {					/* Send ack immediately, before we destroy */					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					iax2_destroy(fr->callno);					break;				}				if (ies.format) {					iaxs[fr->callno]->peerformat = ies.format;				} else {					if (iaxs[fr->callno]->owner)						iaxs[fr->callno]->peerformat = ast_format_cap_to_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner));					else						iaxs[fr->callno]->peerformat = iaxs[fr->callno]->capability;				}				ast_verb(3, "Call accepted by %s (format %s)\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iax2_getformatname(iaxs[fr->callno]->peerformat));				if (!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)) {					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);					if (!iaxs[fr->callno]) {						break;					}					if (authdebug) {						char tmp1[256], tmp2[256];						ast_log(LOG_NOTICE, "Rejected call to %s, format %s incompatible with our capability %s.\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),							iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));					}				} else {					ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);					iax2_lock_owner(fr->callno);					if (iaxs[fr->callno] && iaxs[fr->callno]->owner) {						char tmp[256];						/* Switch us to use a compatible format */						ast_format_cap_from_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner), iaxs[fr->callno]->peerformat);						ast_verb(3, "Format for call is %s\n", ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(iaxs[fr->callno]->owner)));						/* Setup read/write formats properly. */						if (ast_channel_writeformat(iaxs[fr->callno]->owner)->id)							ast_set_write_format(iaxs[fr->callno]->owner, ast_channel_writeformat(iaxs[fr->callno]->owner));						if (ast_channel_readformat(iaxs[fr->callno]->owner)->id)							ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));						ast_channel_unlock(iaxs[fr->callno]->owner);					}				}				if (iaxs[fr->callno]) {					AST_LIST_LOCK(&dpcache);					AST_LIST_TRAVERSE(&iaxs[fr->callno]->dpentries, dp, peer_list)						if (!(dp->flags & CACHE_FLAG_TRANSMITTED))							iax2_dprequest(dp, fr->callno);					AST_LIST_UNLOCK(&dpcache);				}				break;			case IAX_COMMAND_POKE:				/* Send back a pong packet with the original timestamp */				send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, NULL, 0, -1);				break;			case IAX_COMMAND_PING:			{				struct iax_ie_data pingied;				construct_rr(iaxs[fr->callno], &pingied);				/* Send back a pong packet with the original timestamp */				send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, pingied.buf, pingied.pos, -1);			}				break;			case IAX_COMMAND_PONG:				/* Calculate ping time */				iaxs[fr->callno]->pingtime =  calc_timestamp(iaxs[fr->callno], 0, &f) - fr->ts;				/* save RR info */				save_rr(fr, &ies);				/* Good time to write jb stats for this call */				log_jitterstats(fr->callno);				if (iaxs[fr->callno]->peerpoke) {					peer = iaxs[fr->callno]->peerpoke;					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms)) {						if (iaxs[fr->callno]->pingtime <= peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now REACHABLE! Time: %d\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Reachable\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "IAX2/%s", peer->name); /* Activate notification */						}					} else if ((peer->historicms > 0) && (peer->historicms <= peer->maxms)) {						if (iaxs[fr->callno]->pingtime > peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now TOO LAGGED (%d ms)!\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Lagged\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_UNAVAILABLE, AST_DEVSTATE_CACHABLE, "IAX2/%s", peer->name); /* Activate notification */						}					}					peer->lastms = iaxs[fr->callno]->pingtime;					if (peer->smoothing && (peer->lastms > -1))						peer->historicms = (iaxs[fr->callno]->pingtime + peer->historicms) / 2;					else if (peer->smoothing && peer->lastms < 0)						peer->historicms = (0 + peer->historicms) / 2;					else											peer->historicms = iaxs[fr->callno]->pingtime;					/* Remove scheduled iax2_poke_noanswer */					if (peer->pokeexpire > -1) {						if (!AST_SCHED_DEL(sched, peer->pokeexpire)) {							peer_unref(peer);							peer->pokeexpire = -1;						}					}					/* Schedule the next cycle */					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms))						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_peer_s, peer_ref(peer));					else						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqok, iax2_poke_peer_s, peer_ref(peer));					if (peer->pokeexpire == -1)						peer_unref(peer);					/* and finally send the ack */					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					/* And wrap up the qualify call */					iax2_destroy(fr->callno);					peer->callno = 0;					ast_debug(1, "Peer %s: got pong, lastms %d, historicms %d, maxms %d\n", peer->name, peer->lastms, peer->historicms, peer->maxms);				}				break;			case IAX_COMMAND_LAGRQ:			case IAX_COMMAND_LAGRP:				f.src = "LAGRQ";				f.mallocd = 0;				f.offset = 0;				f.samples = 0;				iax_frame_wrap(fr, &f);				if (f.subclass.integer == IAX_COMMAND_LAGRQ) {					/* Received a LAGRQ - echo back a LAGRP */					fr->af.subclass.integer = IAX_COMMAND_LAGRP;					iax2_send(iaxs[fr->callno], &fr->af, fr->ts, -1, 0, 0, 0);				} else {					/* Received LAGRP in response to our LAGRQ */					unsigned int ts;					/* This is a reply we've been given, actually measure the difference */					ts = calc_timestamp(iaxs[fr->callno], 0, &fr->af);					iaxs[fr->callno]->lag = ts - fr->ts;					if (iaxdebug)						ast_debug(1, "Peer %s lag measured as %dms\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->lag);				}				break;			case IAX_COMMAND_AUTHREQ:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)) {					ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					break;				}				if (authenticate_reply(iaxs[fr->callno], &iaxs[fr->callno]->addr, &ies, iaxs[fr->callno]->secret, iaxs[fr->callno]->outkey)) {					struct ast_frame hangup_fr = { .frametype = AST_FRAME_CONTROL,								.subclass.integer = AST_CONTROL_HANGUP,					};					ast_log(LOG_WARNING, 						"I don't know how to authenticate %s to %s\n", 						ies.username ? ies.username : "<unknown>", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr));					iax2_queue_frame(fr->callno, &hangup_fr);				}				break;			case IAX_COMMAND_AUTHREP:				/* For security, always ack immediately */				if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				/* Ignore once we've started */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)) {					ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					break;				}				if (authenticate_verify(iaxs[fr->callno], &ies)) {					if (authdebug)						ast_log(LOG_NOTICE, "Host %s failed to authenticate as %s\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->username);					memset(&ied0, 0, sizeof(ied0));					auth_fail(fr->callno, IAX_COMMAND_REJECT);					break;				}				if (strcasecmp(iaxs[fr->callno]->exten, "TBD")) {					/* This might re-enter the IAX code and need the lock */					exists = ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num);				} else					exists = 0;				if (strcmp(iaxs[fr->callno]->exten, "TBD") && !exists) {					if (authdebug)						ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);					if (!iaxs[fr->callno]) {						break;					}				} else {					/* Select an appropriate format */					if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {							using_prefs = "reqonly";						} else {							using_prefs = "disabled";						}						format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;						memset(&pref, 0, sizeof(pref));						strcpy(caller_pref_buf, "disabled");						strcpy(host_pref_buf, "disabled");					} else {						struct ast_format tmpfmt;						using_prefs = "mine";						if (ies.codec_prefs)							ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);						if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {							if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {								pref = iaxs[fr->callno]->rprefs;								using_prefs = "caller";							} else {								pref = iaxs[fr->callno]->prefs;							}						} else /* if no codec_prefs IE do it the old way */							pref = iaxs[fr->callno]->prefs;						format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);						ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);						ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);					}					if (!format) {						char tmp1[256], tmp2[256], tmp3[256];						if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {							ast_debug(1, "We don't do requested format %s, falling back to peer capability '%s'\n",								iax2_getformatname(iaxs[fr->callno]->peerformat),								iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability));							format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;						}						if (!format) {							if (authdebug) {								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n", ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));								} else {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",										ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),										iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));								}							}							memset(&ied0, 0, sizeof(ied0));							iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");							iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);							send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);							if (!iaxs[fr->callno]) {								break;							}						} else {							/* Pick one... */							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))									format = 0;							} else {								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {									using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";									memset(&pref, 0, sizeof(pref));									format = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ?										iaxs[fr->callno]->peerformat : iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									strcpy(caller_pref_buf,"disabled");									strcpy(host_pref_buf,"disabled");								} else {									struct ast_format tmpfmt;									using_prefs = "mine";									if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {										/* Do the opposite of what we tried above. */										if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {											pref = iaxs[fr->callno]->prefs;										} else {											pref = iaxs[fr->callno]->rprefs;											using_prefs = "caller";										}										format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);									} else /* if no codec_prefs IE do it the old way */										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}							}							if (!format) {								char tmp1[256], tmp2[256], tmp3[256];								ast_log(LOG_ERROR, "No best format in %s???\n",									iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));								if (authdebug) {									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}							}						}					}					if (format) {						/* Authentication received */						memset(&ied1, 0, sizeof(ied1));						iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);						iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);						send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);						if (strcmp(iaxs[fr->callno]->exten, "TBD")) {							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							ast_verb(3, "Accepting AUTHENTICATED call from %s:\n"											"%srequested format = %s,\n"											"%srequested prefs = %s,\n"											"%sactual format = %s,\n"											"%shost prefs = %s,\n"											"%spriority = %s\n", 											ast_inet_ntoa(sin.sin_addr), 											VERBOSE_PREFIX_4,											iax2_getformatname(iaxs[fr->callno]->peerformat),											VERBOSE_PREFIX_4,											caller_pref_buf,											VERBOSE_PREFIX_4,											iax2_getformatname(format),											VERBOSE_PREFIX_4,											host_pref_buf,											VERBOSE_PREFIX_4,											using_prefs);							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, format, NULL, 1)))								iax2_destroy(fr->callno);							else if (ies.vars) {								struct ast_datastore *variablestore;								struct ast_variable *var, *prev = NULL;								AST_LIST_HEAD(, ast_var_t) *varlist;								varlist = ast_calloc(1, sizeof(*varlist));								variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);								if (variablestore && varlist) {									variablestore->data = varlist;									variablestore->inheritance = DATASTORE_INHERIT_FOREVER;									AST_LIST_HEAD_INIT(varlist);									ast_debug(1, "I can haz IAX vars? w00t\n");									for (var = ies.vars; var; var = var->next) {										struct ast_var_t *newvar = ast_var_assign(var->name, var->value);										if (prev)											ast_free(prev);										prev = var;										if (!newvar) {											/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */											ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");										} else {											AST_LIST_INSERT_TAIL(varlist, newvar, entries);										}									}									if (prev)										ast_free(prev);									ies.vars = NULL;									ast_channel_datastore_add(c, variablestore);								} else {									ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									if (variablestore)										ast_datastore_free(variablestore);									if (varlist)										ast_free(varlist);								}							}						} else {							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);							/* If this is a TBD call, we're ready but now what...  */							ast_verb(3, "Accepted AUTHENTICATED TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							if (ast_test_flag64(iaxs[fr->callno], IAX_IMMEDIATE)) {								goto immediatedial;							}						}					}				}				break;			case IAX_COMMAND_DIAL:immediatedial:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD)) {					ast_clear_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);					ast_string_field_set(iaxs[fr->callno], exten, ies.called_number ? ies.called_number : "s");					if (!ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num)) {						if (authdebug)							ast_log(LOG_NOTICE, "Rejected dial attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}					} else {						char tmp[256];						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);						ast_verb(3, "Accepting DIAL from %s, formats = %s\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat));						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);						send_command(iaxs[fr->callno], AST_FRAME_CONTROL, AST_CONTROL_PROGRESS, 0, NULL, 0, -1);						if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->peerformat, NULL, 1)))							iax2_destroy(fr->callno);						else if (ies.vars) {							struct ast_datastore *variablestore;							struct ast_variable *var, *prev = NULL;							AST_LIST_HEAD(, ast_var_t) *varlist;							varlist = ast_calloc(1, sizeof(*varlist));							variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);							ast_debug(1, "I can haz IAX vars? w00t\n");							if (variablestore && varlist) {								variablestore->data = varlist;								variablestore->inheritance = DATASTORE_INHERIT_FOREVER;								AST_LIST_HEAD_INIT(varlist);								for (var = ies.vars; var; var = var->next) {									struct ast_var_t *newvar = ast_var_assign(var->name, var->value);									if (prev)										ast_free(prev);									prev = var;									if (!newvar) {										/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */										ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									} else {										AST_LIST_INSERT_TAIL(varlist, newvar, entries);									}								}								if (prev)									ast_free(prev);								ies.vars = NULL;								ast_channel_datastore_add(c, variablestore);							} else {								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");								if (variablestore)									ast_datastore_free(variablestore);								if (varlist)									ast_free(varlist);							}						}					}				}				break;			case IAX_COMMAND_INVAL:				iaxs[fr->callno]->error = ENOTCONN;				ast_debug(1, "Immediately destroying %d, having received INVAL\n", fr->callno);				iax2_destroy(fr->callno);				ast_debug(1, "Destroying call %d\n", fr->callno);				break;			case IAX_COMMAND_VNAK:				ast_debug(1, "Received VNAK: resending outstanding frames\n");				/* Force retransmission */				vnak_retransmit(fr->callno, fr->iseqno);				break;			case IAX_COMMAND_REGREQ:			case IAX_COMMAND_REGREL:				/* For security, always ack immediately */				if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				if (register_verify(fr->callno, &sin, &ies)) {					if (!iaxs[fr->callno]) {						break;					}					/* Send delayed failure */					auth_fail(fr->callno, IAX_COMMAND_REGREJ);					break;				}				if (!iaxs[fr->callno]) {					break;				}				if ((ast_strlen_zero(iaxs[fr->callno]->secret) && ast_strlen_zero(iaxs[fr->callno]->inkeys)) ||						ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED)) {					if (f.subclass.integer == IAX_COMMAND_REGREL) {						memset(&sin, 0, sizeof(sin));						sin.sin_family = AF_INET;					}					if (update_registry(&sin, fr->callno, ies.devicetype, fd, ies.refresh)) {						ast_log(LOG_WARNING, "Registry error\n");					}					if (!iaxs[fr->callno]) {						break;					}					if (ies.provverpres && ies.serviceident && sin.sin_addr.s_addr) {						ast_mutex_unlock(&iaxsl[fr->callno]);						check_provisioning(&sin, fd, ies.serviceident, ies.provver);						ast_mutex_lock(&iaxsl[fr->callno]);					}					break;				}				registry_authrequest(fr->callno);				break;			case IAX_COMMAND_REGACK:				if (iax2_ack_registry(&ies, &sin, fr->callno)) 					ast_log(LOG_WARNING, "Registration failure\n");				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_REGREJ:				if (iaxs[fr->callno]->reg) {					if (authdebug) {						ast_log(LOG_NOTICE, "Registration of '%s' rejected: '%s' from: '%s'\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>", ast_inet_ntoa(sin.sin_addr));						manager_event(EVENT_FLAG_SYSTEM, "Registry", "ChannelType: IAX2\r\nUsername: %s\r\nStatus: Rejected\r\nCause: %s\r\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>");					}					iaxs[fr->callno]->reg->regstate = REG_STATE_REJECTED;				}				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_REGAUTH:				/* Authentication request */				if (registry_rerequest(&ies, fr->callno, &sin)) {					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No authority found");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_FACILITY_NOT_SUBSCRIBED);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);				}				break;			case IAX_COMMAND_TXREJ:				iaxs[fr->callno]->transferring = 0;				ast_verb(3, "Channel '%s' unable to transfer\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");				memset(&iaxs[fr->callno]->transfer, 0, sizeof(iaxs[fr->callno]->transfer));				if (iaxs[fr->callno]->bridgecallno) {					if (iaxs[iaxs[fr->callno]->bridgecallno]->transferring) {						iaxs[iaxs[fr->callno]->bridgecallno]->transferring = 0;						send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREJ, 0, NULL, 0, -1);					}				}				break;			case IAX_COMMAND_TXREADY:				if ((iaxs[fr->callno]->transferring == TRANSFER_BEGIN) ||				    (iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)) {					if (iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)						iaxs[fr->callno]->transferring = TRANSFER_MREADY;					else						iaxs[fr->callno]->transferring = TRANSFER_READY;					ast_verb(3, "Channel '%s' ready to transfer\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					if (iaxs[fr->callno]->bridgecallno) {						if ((iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_READY) ||						    (iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_MREADY)) {							/* They're both ready, now release them. */							if (iaxs[fr->callno]->transferring == TRANSFER_MREADY) {								ast_verb(3, "Attempting media bridge of %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_MEDIA;								iaxs[fr->callno]->transferring = TRANSFER_MEDIA;								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied1.buf, ied1.pos, -1);							} else {								ast_verb(3, "Releasing %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_RELEASED;								iaxs[fr->callno]->transferring = TRANSFER_RELEASED;								ast_set_flag64(iaxs[iaxs[fr->callno]->bridgecallno], IAX_ALREADYGONE);								ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);								/* Stop doing lag & ping requests */								stop_stuff(fr->callno);								stop_stuff(iaxs[fr->callno]->bridgecallno);								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied1.buf, ied1.pos, -1);							}						}					}				}				break;			case IAX_COMMAND_TXREQ:				try_transfer(iaxs[fr->callno], &ies);				break;			case IAX_COMMAND_TXCNT:				if (iaxs[fr->callno]->transferring)					send_command_transfer(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXACC, 0, NULL, 0);				break;			case IAX_COMMAND_TXREL:				/* Send ack immediately, rather than waiting until we've changed addresses */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				complete_transfer(fr->callno, &ies);				stop_stuff(fr->callno);	/* for attended transfer to work with libiax */				break;				case IAX_COMMAND_TXMEDIA:				if (iaxs[fr->callno]->transferring == TRANSFER_READY) {					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* Cancel any outstanding frames and start anew */						if (cur->transfer) {							cur->retries = -1;						}					}					/* Start sending our media to the transfer address, but otherwise leave the call as-is */					iaxs[fr->callno]->transferring = TRANSFER_MEDIAPASS;				}				break;			case IAX_COMMAND_RTKEY:				if (!IAX_CALLENCRYPTED(iaxs[fr->callno])) {					ast_log(LOG_WARNING, 						"we've been told to rotate our encryption key, "						"but this isn't an encrypted call. bad things will happen.\n"					);					break;				}				IAX_DEBUGDIGEST("Receiving", ies.challenge);				ast_aes_set_decrypt_key((unsigned char *) ies.challenge, &iaxs[fr->callno]->dcx);				break;			case IAX_COMMAND_DPREP:				complete_dpreply(iaxs[fr->callno], &ies);				break;			case IAX_COMMAND_UNSUPPORT:				ast_log(LOG_NOTICE, "Peer did not understand our iax command '%d'\n", ies.iax_unknown);				break;			case IAX_COMMAND_FWDOWNL:				/* Firmware download */				if (!ast_test_flag64(&globalflags, IAX_ALLOWFWDOWNLOAD)) {					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_UNSUPPORT, 0, NULL, 0, -1);					break;				}				memset(&ied0, 0, sizeof(ied0));				res = iax_firmware_append(&ied0, (unsigned char *)ies.devicetype, ies.fwdesc);				if (res < 0)					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);				else if (res > 0)					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1);				else					send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1);				break;			case IAX_COMMAND_CALLTOKEN:			{				struct iax_frame *cur;				/* find last sent frame */				if ((cur = AST_LIST_LAST(&frame_queue[fr->callno])) && ies.calltoken && ies.calltokendata) {					resend_with_token(fr->callno, cur, (char *) ies.calltokendata);				}				break;			}			default:				ast_debug(1, "Unknown IAX command %d on %d/%d\n", f.subclass.integer, fr->callno, iaxs[fr->callno]->peercallno);				memset(&ied0, 0, sizeof(ied0));				iax_ie_append_byte(&ied0, IAX_IE_IAX_UNKNOWN, f.subclass.integer);				send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_UNSUPPORT, 0, ied0.buf, ied0.pos, -1);			}			/* Free remote variables (if any) */			if (ies.vars) {				ast_variables_destroy(ies.vars);				ast_debug(1, "I can haz IAX vars, but they is no good :-(\n");				ies.vars = NULL;			}			/* Don't actually pass these frames along */			if ((f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&			  (f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_INVAL) &&			  (f.subclass.integer != IAX_COMMAND_VNAK)) {				if (iaxs[fr->callno] && iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);			}			ast_mutex_unlock(&iaxsl[fr->callno]);			return 1;		}
if (iaxdebug)			ast_debug(1, "Received packet %d, (%d, %u)\n", fh->oseqno, f.frametype, f.subclass.integer);
iaxdebug
iaxdebug
ast_debug(1, "Received packet %d, (%d, %u)\n", fh->oseqno, f.frametype, f.subclass.integer);
ast_debug(1, "Received packet %d, (%d, %u)\n", fh->oseqno, f.frametype, f.subclass.integer)
ast_debug
ast_debug
1
"Received packet %d, (%d, %u)\n"
fh->oseqno
fh
fh
oseqno
f.frametype
f
f
frametype
f.subclass.integer
f.subclass
f
f
subclass
integer
fr->oseqno = fh->oseqno;
fr->oseqno = fh->oseqno
fr->oseqno
fr
fr
oseqno
fh->oseqno
fh
fh
oseqno
fr->iseqno = fh->iseqno;
fr->iseqno = fh->iseqno
fr->iseqno
fr
fr
iseqno
fh->iseqno
fh
fh
iseqno
fr->ts = ntohl(fh->ts);
fr->ts = ntohl(fh->ts)
fr->ts
fr
fr
ts
ntohl(fh->ts)
ntohl
ntohl
fh->ts
fh
fh
ts
if ((ntohs(fh->dcallno) & IAX_FLAG_RETRANS) || (f.frametype != AST_FRAME_VOICE))			updatehistory = 0;
(ntohs(fh->dcallno) & IAX_FLAG_RETRANS) || (f.frametype != AST_FRAME_VOICE)
(ntohs(fh->dcallno) & IAX_FLAG_RETRANS)
ntohs(fh->dcallno) & IAX_FLAG_RETRANS
ntohs(fh->dcallno)
ntohs
ntohs
fh->dcallno
fh
fh
dcallno
IAX_FLAG_RETRANS
IAX_FLAG_RETRANS
(f.frametype != AST_FRAME_VOICE)
f.frametype != AST_FRAME_VOICE
f.frametype
f
f
frametype
AST_FRAME_VOICE
AST_FRAME_VOICE
updatehistory = 0;
updatehistory = 0
updatehistory
updatehistory
0
if ((iaxs[fr->callno]->iseqno != fr->oseqno) &&			(iaxs[fr->callno]->iseqno ||				((f.subclass.integer != IAX_COMMAND_TXCNT) &&				(f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXACC)) ||				(f.frametype != AST_FRAME_IAX))) {			if (			 ((f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_INVAL) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&			  (f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_VNAK)) ||			  (f.frametype != AST_FRAME_IAX)) {				/* If it's not an ACK packet, it's out of order. */				ast_debug(1, "Packet arrived out of order (expecting %d, got %d) (frametype = %d, subclass = %d)\n",					iaxs[fr->callno]->iseqno, fr->oseqno, f.frametype, f.subclass.integer);				/* Check to see if we need to request retransmission,				 * and take sequence number wraparound into account */				if ((unsigned char) (iaxs[fr->callno]->iseqno - fr->oseqno) < 128) {					/* If we've already seen it, ack it XXX There's a border condition here XXX */					if ((f.frametype != AST_FRAME_IAX) ||							((f.subclass.integer != IAX_COMMAND_ACK) && (f.subclass.integer != IAX_COMMAND_INVAL))) {						ast_debug(1, "Acking anyway\n");						/* XXX Maybe we should handle its ack to us, but then again, it's probably outdated anyway, and if						   we have anything to send, we'll retransmit and get an ACK back anyway XXX */						send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					}				} else {					/* Send a VNAK requesting retransmission */					iax2_vnak(fr->callno);				}				ast_variables_destroy(ies.vars);				ast_mutex_unlock(&iaxsl[fr->callno]);				return 1;			}		} else {			/* Increment unless it's an ACK or VNAK */			if (((f.subclass.integer != IAX_COMMAND_ACK) &&			    (f.subclass.integer != IAX_COMMAND_INVAL) &&			    (f.subclass.integer != IAX_COMMAND_TXCNT) &&			    (f.subclass.integer != IAX_COMMAND_TXACC) &&				(f.subclass.integer != IAX_COMMAND_VNAK)) ||			    (f.frametype != AST_FRAME_IAX))				iaxs[fr->callno]->iseqno++;		}
(iaxs[fr->callno]->iseqno != fr->oseqno) &&			(iaxs[fr->callno]->iseqno ||				((f.subclass.integer != IAX_COMMAND_TXCNT) &&				(f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXACC)) ||				(f.frametype != AST_FRAME_IAX))
(iaxs[fr->callno]->iseqno != fr->oseqno)
iaxs[fr->callno]->iseqno != fr->oseqno
iaxs[fr->callno]->iseqno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
iseqno
fr->oseqno
fr
fr
oseqno
(iaxs[fr->callno]->iseqno ||				((f.subclass.integer != IAX_COMMAND_TXCNT) &&				(f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXACC)) ||				(f.frametype != AST_FRAME_IAX))
iaxs[fr->callno]->iseqno ||				((f.subclass.integer != IAX_COMMAND_TXCNT) &&				(f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXACC)) ||				(f.frametype != AST_FRAME_IAX)
iaxs[fr->callno]->iseqno ||				((f.subclass.integer != IAX_COMMAND_TXCNT) &&				(f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXACC))
iaxs[fr->callno]->iseqno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
iseqno
((f.subclass.integer != IAX_COMMAND_TXCNT) &&				(f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXACC))
(f.subclass.integer != IAX_COMMAND_TXCNT) &&				(f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXACC)
(f.subclass.integer != IAX_COMMAND_TXCNT) &&				(f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_UNQUELCH )
(f.subclass.integer != IAX_COMMAND_TXCNT) &&				(f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXREL)
(f.subclass.integer != IAX_COMMAND_TXCNT) &&				(f.subclass.integer != IAX_COMMAND_TXREADY)
(f.subclass.integer != IAX_COMMAND_TXCNT)
f.subclass.integer != IAX_COMMAND_TXCNT
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_TXCNT
IAX_COMMAND_TXCNT
(f.subclass.integer != IAX_COMMAND_TXREADY)
f.subclass.integer != IAX_COMMAND_TXREADY
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_TXREADY
IAX_COMMAND_TXREADY
(f.subclass.integer != IAX_COMMAND_TXREL)
f.subclass.integer != IAX_COMMAND_TXREL
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_TXREL
IAX_COMMAND_TXREL
(f.subclass.integer != IAX_COMMAND_UNQUELCH )
f.subclass.integer != IAX_COMMAND_UNQUELCH
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_UNQUELCH
IAX_COMMAND_UNQUELCH
(f.subclass.integer != IAX_COMMAND_TXACC)
f.subclass.integer != IAX_COMMAND_TXACC
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_TXACC
IAX_COMMAND_TXACC
(f.frametype != AST_FRAME_IAX)
f.frametype != AST_FRAME_IAX
f.frametype
f
f
frametype
AST_FRAME_IAX
AST_FRAME_IAX
{			if (			 ((f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_INVAL) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&			  (f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_VNAK)) ||			  (f.frametype != AST_FRAME_IAX)) {				/* If it's not an ACK packet, it's out of order. */				ast_debug(1, "Packet arrived out of order (expecting %d, got %d) (frametype = %d, subclass = %d)\n",					iaxs[fr->callno]->iseqno, fr->oseqno, f.frametype, f.subclass.integer);				/* Check to see if we need to request retransmission,				 * and take sequence number wraparound into account */				if ((unsigned char) (iaxs[fr->callno]->iseqno - fr->oseqno) < 128) {					/* If we've already seen it, ack it XXX There's a border condition here XXX */					if ((f.frametype != AST_FRAME_IAX) ||							((f.subclass.integer != IAX_COMMAND_ACK) && (f.subclass.integer != IAX_COMMAND_INVAL))) {						ast_debug(1, "Acking anyway\n");						/* XXX Maybe we should handle its ack to us, but then again, it's probably outdated anyway, and if						   we have anything to send, we'll retransmit and get an ACK back anyway XXX */						send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					}				} else {					/* Send a VNAK requesting retransmission */					iax2_vnak(fr->callno);				}				ast_variables_destroy(ies.vars);				ast_mutex_unlock(&iaxsl[fr->callno]);				return 1;			}		}
if (			 ((f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_INVAL) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&			  (f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_VNAK)) ||			  (f.frametype != AST_FRAME_IAX)) {				/* If it's not an ACK packet, it's out of order. */				ast_debug(1, "Packet arrived out of order (expecting %d, got %d) (frametype = %d, subclass = %d)\n",					iaxs[fr->callno]->iseqno, fr->oseqno, f.frametype, f.subclass.integer);				/* Check to see if we need to request retransmission,				 * and take sequence number wraparound into account */				if ((unsigned char) (iaxs[fr->callno]->iseqno - fr->oseqno) < 128) {					/* If we've already seen it, ack it XXX There's a border condition here XXX */					if ((f.frametype != AST_FRAME_IAX) ||							((f.subclass.integer != IAX_COMMAND_ACK) && (f.subclass.integer != IAX_COMMAND_INVAL))) {						ast_debug(1, "Acking anyway\n");						/* XXX Maybe we should handle its ack to us, but then again, it's probably outdated anyway, and if						   we have anything to send, we'll retransmit and get an ACK back anyway XXX */						send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					}				} else {					/* Send a VNAK requesting retransmission */					iax2_vnak(fr->callno);				}				ast_variables_destroy(ies.vars);				ast_mutex_unlock(&iaxsl[fr->callno]);				return 1;			}
((f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_INVAL) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&			  (f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_VNAK)) ||			  (f.frametype != AST_FRAME_IAX)
((f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_INVAL) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&			  (f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_VNAK))
(f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_INVAL) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&			  (f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_VNAK)
(f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_INVAL) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&			  (f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXACC)
(f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_INVAL) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&			  (f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_UNQUELCH )
(f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_INVAL) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&			  (f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXREL)
(f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_INVAL) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&			  (f.subclass.integer != IAX_COMMAND_TXREADY)
(f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_INVAL) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT)
(f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_INVAL)
(f.subclass.integer != IAX_COMMAND_ACK)
f.subclass.integer != IAX_COMMAND_ACK
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_ACK
IAX_COMMAND_ACK
(f.subclass.integer != IAX_COMMAND_INVAL)
f.subclass.integer != IAX_COMMAND_INVAL
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_INVAL
IAX_COMMAND_INVAL
(f.subclass.integer != IAX_COMMAND_TXCNT)
f.subclass.integer != IAX_COMMAND_TXCNT
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_TXCNT
IAX_COMMAND_TXCNT
(f.subclass.integer != IAX_COMMAND_TXREADY)
f.subclass.integer != IAX_COMMAND_TXREADY
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_TXREADY
IAX_COMMAND_TXREADY
(f.subclass.integer != IAX_COMMAND_TXREL)
f.subclass.integer != IAX_COMMAND_TXREL
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_TXREL
IAX_COMMAND_TXREL
(f.subclass.integer != IAX_COMMAND_UNQUELCH )
f.subclass.integer != IAX_COMMAND_UNQUELCH
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_UNQUELCH
IAX_COMMAND_UNQUELCH
(f.subclass.integer != IAX_COMMAND_TXACC)
f.subclass.integer != IAX_COMMAND_TXACC
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_TXACC
IAX_COMMAND_TXACC
(f.subclass.integer != IAX_COMMAND_VNAK)
f.subclass.integer != IAX_COMMAND_VNAK
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_VNAK
IAX_COMMAND_VNAK
(f.frametype != AST_FRAME_IAX)
f.frametype != AST_FRAME_IAX
f.frametype
f
f
frametype
AST_FRAME_IAX
AST_FRAME_IAX
{				/* If it's not an ACK packet, it's out of order. */				ast_debug(1, "Packet arrived out of order (expecting %d, got %d) (frametype = %d, subclass = %d)\n",					iaxs[fr->callno]->iseqno, fr->oseqno, f.frametype, f.subclass.integer);				/* Check to see if we need to request retransmission,				 * and take sequence number wraparound into account */				if ((unsigned char) (iaxs[fr->callno]->iseqno - fr->oseqno) < 128) {					/* If we've already seen it, ack it XXX There's a border condition here XXX */					if ((f.frametype != AST_FRAME_IAX) ||							((f.subclass.integer != IAX_COMMAND_ACK) && (f.subclass.integer != IAX_COMMAND_INVAL))) {						ast_debug(1, "Acking anyway\n");						/* XXX Maybe we should handle its ack to us, but then again, it's probably outdated anyway, and if						   we have anything to send, we'll retransmit and get an ACK back anyway XXX */						send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					}				} else {					/* Send a VNAK requesting retransmission */					iax2_vnak(fr->callno);				}				ast_variables_destroy(ies.vars);				ast_mutex_unlock(&iaxsl[fr->callno]);				return 1;			}
ast_debug(1, "Packet arrived out of order (expecting %d, got %d) (frametype = %d, subclass = %d)\n",					iaxs[fr->callno]->iseqno, fr->oseqno, f.frametype, f.subclass.integer);
ast_debug(1, "Packet arrived out of order (expecting %d, got %d) (frametype = %d, subclass = %d)\n",					iaxs[fr->callno]->iseqno, fr->oseqno, f.frametype, f.subclass.integer)
ast_debug
ast_debug
1
"Packet arrived out of order (expecting %d, got %d) (frametype = %d, subclass = %d)\n"
iaxs[fr->callno]->iseqno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
iseqno
fr->oseqno
fr
fr
oseqno
f.frametype
f
f
frametype
f.subclass.integer
f.subclass
f
f
subclass
integer
if ((unsigned char) (iaxs[fr->callno]->iseqno - fr->oseqno) < 128) {					/* If we've already seen it, ack it XXX There's a border condition here XXX */					if ((f.frametype != AST_FRAME_IAX) ||							((f.subclass.integer != IAX_COMMAND_ACK) && (f.subclass.integer != IAX_COMMAND_INVAL))) {						ast_debug(1, "Acking anyway\n");						/* XXX Maybe we should handle its ack to us, but then again, it's probably outdated anyway, and if						   we have anything to send, we'll retransmit and get an ACK back anyway XXX */						send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					}				} else {					/* Send a VNAK requesting retransmission */					iax2_vnak(fr->callno);				}
(unsigned char) (iaxs[fr->callno]->iseqno - fr->oseqno) < 128
(unsigned char) (iaxs[fr->callno]->iseqno - fr->oseqno)
unsigned char
unsigned char

(iaxs[fr->callno]->iseqno - fr->oseqno)
iaxs[fr->callno]->iseqno - fr->oseqno
iaxs[fr->callno]->iseqno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
iseqno
fr->oseqno
fr
fr
oseqno
128
{					/* If we've already seen it, ack it XXX There's a border condition here XXX */					if ((f.frametype != AST_FRAME_IAX) ||							((f.subclass.integer != IAX_COMMAND_ACK) && (f.subclass.integer != IAX_COMMAND_INVAL))) {						ast_debug(1, "Acking anyway\n");						/* XXX Maybe we should handle its ack to us, but then again, it's probably outdated anyway, and if						   we have anything to send, we'll retransmit and get an ACK back anyway XXX */						send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					}				}
if ((f.frametype != AST_FRAME_IAX) ||							((f.subclass.integer != IAX_COMMAND_ACK) && (f.subclass.integer != IAX_COMMAND_INVAL))) {						ast_debug(1, "Acking anyway\n");						/* XXX Maybe we should handle its ack to us, but then again, it's probably outdated anyway, and if						   we have anything to send, we'll retransmit and get an ACK back anyway XXX */						send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					}
(f.frametype != AST_FRAME_IAX) ||							((f.subclass.integer != IAX_COMMAND_ACK) && (f.subclass.integer != IAX_COMMAND_INVAL))
(f.frametype != AST_FRAME_IAX)
f.frametype != AST_FRAME_IAX
f.frametype
f
f
frametype
AST_FRAME_IAX
AST_FRAME_IAX
((f.subclass.integer != IAX_COMMAND_ACK) && (f.subclass.integer != IAX_COMMAND_INVAL))
(f.subclass.integer != IAX_COMMAND_ACK) && (f.subclass.integer != IAX_COMMAND_INVAL)
(f.subclass.integer != IAX_COMMAND_ACK)
f.subclass.integer != IAX_COMMAND_ACK
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_ACK
IAX_COMMAND_ACK
(f.subclass.integer != IAX_COMMAND_INVAL)
f.subclass.integer != IAX_COMMAND_INVAL
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_INVAL
IAX_COMMAND_INVAL
{						ast_debug(1, "Acking anyway\n");						/* XXX Maybe we should handle its ack to us, but then again, it's probably outdated anyway, and if						   we have anything to send, we'll retransmit and get an ACK back anyway XXX */						send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					}
ast_debug(1, "Acking anyway\n");
ast_debug(1, "Acking anyway\n")
ast_debug
ast_debug
1
"Acking anyway\n"
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
send_command_immediate
send_command_immediate
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_ACK
IAX_COMMAND_ACK
fr->ts
fr
fr
ts
NULL
NULL
0
fr->iseqno
fr
fr
iseqno
{					/* Send a VNAK requesting retransmission */					iax2_vnak(fr->callno);				}
iax2_vnak(fr->callno);
iax2_vnak(fr->callno)
iax2_vnak
iax2_vnak
fr->callno
fr
fr
callno
ast_variables_destroy(ies.vars);
ast_variables_destroy(ies.vars)
ast_variables_destroy
ast_variables_destroy
ies.vars
ies
ies
vars
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock
ast_mutex_unlock
(&iaxsl[fr->callno])
&iaxsl[fr->callno]
&
iaxsl
[fr->callno]
fr->callno
fr
fr
callno
return 1;
1
{			/* Increment unless it's an ACK or VNAK */			if (((f.subclass.integer != IAX_COMMAND_ACK) &&			    (f.subclass.integer != IAX_COMMAND_INVAL) &&			    (f.subclass.integer != IAX_COMMAND_TXCNT) &&			    (f.subclass.integer != IAX_COMMAND_TXACC) &&				(f.subclass.integer != IAX_COMMAND_VNAK)) ||			    (f.frametype != AST_FRAME_IAX))				iaxs[fr->callno]->iseqno++;		}
if (((f.subclass.integer != IAX_COMMAND_ACK) &&			    (f.subclass.integer != IAX_COMMAND_INVAL) &&			    (f.subclass.integer != IAX_COMMAND_TXCNT) &&			    (f.subclass.integer != IAX_COMMAND_TXACC) &&				(f.subclass.integer != IAX_COMMAND_VNAK)) ||			    (f.frametype != AST_FRAME_IAX))				iaxs[fr->callno]->iseqno++;
((f.subclass.integer != IAX_COMMAND_ACK) &&			    (f.subclass.integer != IAX_COMMAND_INVAL) &&			    (f.subclass.integer != IAX_COMMAND_TXCNT) &&			    (f.subclass.integer != IAX_COMMAND_TXACC) &&				(f.subclass.integer != IAX_COMMAND_VNAK)) ||			    (f.frametype != AST_FRAME_IAX)
((f.subclass.integer != IAX_COMMAND_ACK) &&			    (f.subclass.integer != IAX_COMMAND_INVAL) &&			    (f.subclass.integer != IAX_COMMAND_TXCNT) &&			    (f.subclass.integer != IAX_COMMAND_TXACC) &&				(f.subclass.integer != IAX_COMMAND_VNAK))
(f.subclass.integer != IAX_COMMAND_ACK) &&			    (f.subclass.integer != IAX_COMMAND_INVAL) &&			    (f.subclass.integer != IAX_COMMAND_TXCNT) &&			    (f.subclass.integer != IAX_COMMAND_TXACC) &&				(f.subclass.integer != IAX_COMMAND_VNAK)
(f.subclass.integer != IAX_COMMAND_ACK) &&			    (f.subclass.integer != IAX_COMMAND_INVAL) &&			    (f.subclass.integer != IAX_COMMAND_TXCNT) &&			    (f.subclass.integer != IAX_COMMAND_TXACC)
(f.subclass.integer != IAX_COMMAND_ACK) &&			    (f.subclass.integer != IAX_COMMAND_INVAL) &&			    (f.subclass.integer != IAX_COMMAND_TXCNT)
(f.subclass.integer != IAX_COMMAND_ACK) &&			    (f.subclass.integer != IAX_COMMAND_INVAL)
(f.subclass.integer != IAX_COMMAND_ACK)
f.subclass.integer != IAX_COMMAND_ACK
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_ACK
IAX_COMMAND_ACK
(f.subclass.integer != IAX_COMMAND_INVAL)
f.subclass.integer != IAX_COMMAND_INVAL
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_INVAL
IAX_COMMAND_INVAL
(f.subclass.integer != IAX_COMMAND_TXCNT)
f.subclass.integer != IAX_COMMAND_TXCNT
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_TXCNT
IAX_COMMAND_TXCNT
(f.subclass.integer != IAX_COMMAND_TXACC)
f.subclass.integer != IAX_COMMAND_TXACC
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_TXACC
IAX_COMMAND_TXACC
(f.subclass.integer != IAX_COMMAND_VNAK)
f.subclass.integer != IAX_COMMAND_VNAK
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_VNAK
IAX_COMMAND_VNAK
(f.frametype != AST_FRAME_IAX)
f.frametype != AST_FRAME_IAX
f.frametype
f
f
frametype
AST_FRAME_IAX
AST_FRAME_IAX
iaxs[fr->callno]->iseqno++;
iaxs[fr->callno]->iseqno++
iaxs[fr->callno]->iseqno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
iseqno
if (f.frametype == AST_FRAME_TEXT && thread->buf[res - 1] != '\0') {			if (res < thread->buf_size)				thread->buf[res++] = '\0';			else /* Trims one character from the text message, but that's better than overwriting the end of the buffer. */				thread->buf[res - 1] = '\0';		}
f.frametype == AST_FRAME_TEXT && thread->buf[res - 1] != '\0'
f.frametype == AST_FRAME_TEXT
f.frametype
f
f
frametype
AST_FRAME_TEXT
AST_FRAME_TEXT
thread->buf[res - 1] != '\0'
thread->buf[res - 1]
thread->buf
thread
thread
buf
res - 1
res
res
1
'\0'
{			if (res < thread->buf_size)				thread->buf[res++] = '\0';			else /* Trims one character from the text message, but that's better than overwriting the end of the buffer. */				thread->buf[res - 1] = '\0';		}
if (res < thread->buf_size)				thread->buf[res++] = '\0';			else /* Trims one character from the text message, but that's better than overwriting the end of the buffer. */				thread->buf[res - 1] = '\0';
res < thread->buf_size
res
res
thread->buf_size
thread
thread
buf_size
thread->buf[res++] = '\0';
thread->buf[res++] = '\0'
thread->buf[res++]
thread->buf
thread
thread
buf
res++
res
res
'\0'
thread->buf[res - 1] = '\0';
thread->buf[res - 1] = '\0'
thread->buf[res - 1]
thread->buf
thread
thread
buf
res - 1
res
res
1
'\0'
if (!inaddrcmp(&sin, &iaxs[fr->callno]->addr) &&		    ((f.subclass.integer != IAX_COMMAND_INVAL) ||		     (f.frametype != AST_FRAME_IAX))) {			unsigned char x;			int call_to_destroy;			/* First we have to qualify that the ACKed value is within our window */			if (iaxs[fr->callno]->rseqno >= iaxs[fr->callno]->oseqno || (fr->iseqno >= iaxs[fr->callno]->rseqno && fr->iseqno < iaxs[fr->callno]->oseqno))				x = fr->iseqno;			else				x = iaxs[fr->callno]->oseqno;			if ((x != iaxs[fr->callno]->oseqno) || (iaxs[fr->callno]->oseqno == fr->iseqno)) {				/* The acknowledgement is within our window.  Time to acknowledge everything				   that it says to */				for (x=iaxs[fr->callno]->rseqno; x != fr->iseqno; x++) {					/* Ack the packet with the given timestamp */					if (iaxdebug)						ast_debug(1, "Cancelling transmission of packet %d\n", x);					call_to_destroy = 0;					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* If it's our call, and our timestamp, mark -1 retries */						if (x == cur->oseqno) {							cur->retries = -1;							/* Destroy call if this is the end */							if (cur->final)								call_to_destroy = fr->callno;						}					}					if (call_to_destroy) {						if (iaxdebug)							ast_debug(1, "Really destroying %d, having been acked on final message\n", call_to_destroy);						ast_mutex_lock(&iaxsl[call_to_destroy]);						iax2_destroy(call_to_destroy);						ast_mutex_unlock(&iaxsl[call_to_destroy]);					}				}				/* Note how much we've received acknowledgement for */				if (iaxs[fr->callno])					iaxs[fr->callno]->rseqno = fr->iseqno;				else {					/* Stop processing now */					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}			} else {				ast_debug(1, "Received iseqno %d not within window %d->%d\n", fr->iseqno, iaxs[fr->callno]->rseqno, iaxs[fr->callno]->oseqno);			}		}
!inaddrcmp(&sin, &iaxs[fr->callno]->addr) &&		    ((f.subclass.integer != IAX_COMMAND_INVAL) ||		     (f.frametype != AST_FRAME_IAX))
!inaddrcmp(&sin, &iaxs[fr->callno]->addr)
inaddrcmp(&sin, &iaxs[fr->callno]->addr)
inaddrcmp
inaddrcmp
&sin
sin
sin
&iaxs[fr->callno]->addr
iaxs[fr->callno]->addr
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
addr
((f.subclass.integer != IAX_COMMAND_INVAL) ||		     (f.frametype != AST_FRAME_IAX))
(f.subclass.integer != IAX_COMMAND_INVAL) ||		     (f.frametype != AST_FRAME_IAX)
(f.subclass.integer != IAX_COMMAND_INVAL)
f.subclass.integer != IAX_COMMAND_INVAL
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_INVAL
IAX_COMMAND_INVAL
(f.frametype != AST_FRAME_IAX)
f.frametype != AST_FRAME_IAX
f.frametype
f
f
frametype
AST_FRAME_IAX
AST_FRAME_IAX
{			unsigned char x;			int call_to_destroy;			/* First we have to qualify that the ACKed value is within our window */			if (iaxs[fr->callno]->rseqno >= iaxs[fr->callno]->oseqno || (fr->iseqno >= iaxs[fr->callno]->rseqno && fr->iseqno < iaxs[fr->callno]->oseqno))				x = fr->iseqno;			else				x = iaxs[fr->callno]->oseqno;			if ((x != iaxs[fr->callno]->oseqno) || (iaxs[fr->callno]->oseqno == fr->iseqno)) {				/* The acknowledgement is within our window.  Time to acknowledge everything				   that it says to */				for (x=iaxs[fr->callno]->rseqno; x != fr->iseqno; x++) {					/* Ack the packet with the given timestamp */					if (iaxdebug)						ast_debug(1, "Cancelling transmission of packet %d\n", x);					call_to_destroy = 0;					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* If it's our call, and our timestamp, mark -1 retries */						if (x == cur->oseqno) {							cur->retries = -1;							/* Destroy call if this is the end */							if (cur->final)								call_to_destroy = fr->callno;						}					}					if (call_to_destroy) {						if (iaxdebug)							ast_debug(1, "Really destroying %d, having been acked on final message\n", call_to_destroy);						ast_mutex_lock(&iaxsl[call_to_destroy]);						iax2_destroy(call_to_destroy);						ast_mutex_unlock(&iaxsl[call_to_destroy]);					}				}				/* Note how much we've received acknowledgement for */				if (iaxs[fr->callno])					iaxs[fr->callno]->rseqno = fr->iseqno;				else {					/* Stop processing now */					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}			} else {				ast_debug(1, "Received iseqno %d not within window %d->%d\n", fr->iseqno, iaxs[fr->callno]->rseqno, iaxs[fr->callno]->oseqno);			}		}
unsigned char x;
unsigned char x;
unsigned char
x
x
int call_to_destroy;
int call_to_destroy;
int
call_to_destroy
call_to_destroy
if (iaxs[fr->callno]->rseqno >= iaxs[fr->callno]->oseqno || (fr->iseqno >= iaxs[fr->callno]->rseqno && fr->iseqno < iaxs[fr->callno]->oseqno))				x = fr->iseqno;			else				x = iaxs[fr->callno]->oseqno;
iaxs[fr->callno]->rseqno >= iaxs[fr->callno]->oseqno || (fr->iseqno >= iaxs[fr->callno]->rseqno && fr->iseqno < iaxs[fr->callno]->oseqno)
iaxs[fr->callno]->rseqno >= iaxs[fr->callno]->oseqno
iaxs[fr->callno]->rseqno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
rseqno
iaxs[fr->callno]->oseqno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
oseqno
(fr->iseqno >= iaxs[fr->callno]->rseqno && fr->iseqno < iaxs[fr->callno]->oseqno)
fr->iseqno >= iaxs[fr->callno]->rseqno && fr->iseqno < iaxs[fr->callno]->oseqno
fr->iseqno >= iaxs[fr->callno]->rseqno
fr->iseqno
fr
fr
iseqno
iaxs[fr->callno]->rseqno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
rseqno
fr->iseqno < iaxs[fr->callno]->oseqno
fr->iseqno
fr
fr
iseqno
iaxs[fr->callno]->oseqno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
oseqno
x = fr->iseqno;
x = fr->iseqno
x
x
fr->iseqno
fr
fr
iseqno
x = iaxs[fr->callno]->oseqno;
x = iaxs[fr->callno]->oseqno
x
x
iaxs[fr->callno]->oseqno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
oseqno
if ((x != iaxs[fr->callno]->oseqno) || (iaxs[fr->callno]->oseqno == fr->iseqno)) {				/* The acknowledgement is within our window.  Time to acknowledge everything				   that it says to */				for (x=iaxs[fr->callno]->rseqno; x != fr->iseqno; x++) {					/* Ack the packet with the given timestamp */					if (iaxdebug)						ast_debug(1, "Cancelling transmission of packet %d\n", x);					call_to_destroy = 0;					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* If it's our call, and our timestamp, mark -1 retries */						if (x == cur->oseqno) {							cur->retries = -1;							/* Destroy call if this is the end */							if (cur->final)								call_to_destroy = fr->callno;						}					}					if (call_to_destroy) {						if (iaxdebug)							ast_debug(1, "Really destroying %d, having been acked on final message\n", call_to_destroy);						ast_mutex_lock(&iaxsl[call_to_destroy]);						iax2_destroy(call_to_destroy);						ast_mutex_unlock(&iaxsl[call_to_destroy]);					}				}				/* Note how much we've received acknowledgement for */				if (iaxs[fr->callno])					iaxs[fr->callno]->rseqno = fr->iseqno;				else {					/* Stop processing now */					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}			} else {				ast_debug(1, "Received iseqno %d not within window %d->%d\n", fr->iseqno, iaxs[fr->callno]->rseqno, iaxs[fr->callno]->oseqno);			}
(x != iaxs[fr->callno]->oseqno) || (iaxs[fr->callno]->oseqno == fr->iseqno)
(x != iaxs[fr->callno]->oseqno)
x != iaxs[fr->callno]->oseqno
x
x
iaxs[fr->callno]->oseqno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
oseqno
(iaxs[fr->callno]->oseqno == fr->iseqno)
iaxs[fr->callno]->oseqno == fr->iseqno
iaxs[fr->callno]->oseqno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
oseqno
fr->iseqno
fr
fr
iseqno
{				/* The acknowledgement is within our window.  Time to acknowledge everything				   that it says to */				for (x=iaxs[fr->callno]->rseqno; x != fr->iseqno; x++) {					/* Ack the packet with the given timestamp */					if (iaxdebug)						ast_debug(1, "Cancelling transmission of packet %d\n", x);					call_to_destroy = 0;					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* If it's our call, and our timestamp, mark -1 retries */						if (x == cur->oseqno) {							cur->retries = -1;							/* Destroy call if this is the end */							if (cur->final)								call_to_destroy = fr->callno;						}					}					if (call_to_destroy) {						if (iaxdebug)							ast_debug(1, "Really destroying %d, having been acked on final message\n", call_to_destroy);						ast_mutex_lock(&iaxsl[call_to_destroy]);						iax2_destroy(call_to_destroy);						ast_mutex_unlock(&iaxsl[call_to_destroy]);					}				}				/* Note how much we've received acknowledgement for */				if (iaxs[fr->callno])					iaxs[fr->callno]->rseqno = fr->iseqno;				else {					/* Stop processing now */					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}			}
for (x=iaxs[fr->callno]->rseqno; x != fr->iseqno; x++) {					/* Ack the packet with the given timestamp */					if (iaxdebug)						ast_debug(1, "Cancelling transmission of packet %d\n", x);					call_to_destroy = 0;					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* If it's our call, and our timestamp, mark -1 retries */						if (x == cur->oseqno) {							cur->retries = -1;							/* Destroy call if this is the end */							if (cur->final)								call_to_destroy = fr->callno;						}					}					if (call_to_destroy) {						if (iaxdebug)							ast_debug(1, "Really destroying %d, having been acked on final message\n", call_to_destroy);						ast_mutex_lock(&iaxsl[call_to_destroy]);						iax2_destroy(call_to_destroy);						ast_mutex_unlock(&iaxsl[call_to_destroy]);					}				}
x=iaxs[fr->callno]->rseqno;
x=iaxs[fr->callno]->rseqno
x
x
iaxs[fr->callno]->rseqno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
rseqno
x != fr->iseqno
x
x
fr->iseqno
fr
fr
iseqno
x++
x
x
{					/* Ack the packet with the given timestamp */					if (iaxdebug)						ast_debug(1, "Cancelling transmission of packet %d\n", x);					call_to_destroy = 0;					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* If it's our call, and our timestamp, mark -1 retries */						if (x == cur->oseqno) {							cur->retries = -1;							/* Destroy call if this is the end */							if (cur->final)								call_to_destroy = fr->callno;						}					}					if (call_to_destroy) {						if (iaxdebug)							ast_debug(1, "Really destroying %d, having been acked on final message\n", call_to_destroy);						ast_mutex_lock(&iaxsl[call_to_destroy]);						iax2_destroy(call_to_destroy);						ast_mutex_unlock(&iaxsl[call_to_destroy]);					}				}
if (iaxdebug)						ast_debug(1, "Cancelling transmission of packet %d\n", x);
iaxdebug
iaxdebug
ast_debug(1, "Cancelling transmission of packet %d\n", x);
ast_debug(1, "Cancelling transmission of packet %d\n", x)
ast_debug
ast_debug
1
"Cancelling transmission of packet %d\n"
x
x
call_to_destroy = 0;
call_to_destroy = 0
call_to_destroy
call_to_destroy
0
AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list)
AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list)
AST_LIST_TRAVERSE
AST_LIST_TRAVERSE
&frame_queue[fr->callno]
frame_queue[fr->callno]
frame_queue
frame_queue
fr->callno
fr
fr
callno
cur
cur
list
list
)
{						/* If it's our call, and our timestamp, mark -1 retries */						if (x == cur->oseqno) {							cur->retries = -1;							/* Destroy call if this is the end */							if (cur->final)								call_to_destroy = fr->callno;						}					}
if (x == cur->oseqno) {							cur->retries = -1;							/* Destroy call if this is the end */							if (cur->final)								call_to_destroy = fr->callno;						}
x == cur->oseqno
x
x
cur->oseqno
cur
cur
oseqno
{							cur->retries = -1;							/* Destroy call if this is the end */							if (cur->final)								call_to_destroy = fr->callno;						}
cur->retries = -1;
cur->retries = -1
cur->retries
cur
cur
retries
-1
1
if (cur->final)								call_to_destroy = fr->callno;
cur->final
cur
cur
final
call_to_destroy = fr->callno;
call_to_destroy = fr->callno
call_to_destroy
call_to_destroy
fr->callno
fr
fr
callno
if (call_to_destroy) {						if (iaxdebug)							ast_debug(1, "Really destroying %d, having been acked on final message\n", call_to_destroy);						ast_mutex_lock(&iaxsl[call_to_destroy]);						iax2_destroy(call_to_destroy);						ast_mutex_unlock(&iaxsl[call_to_destroy]);					}
call_to_destroy
call_to_destroy
{						if (iaxdebug)							ast_debug(1, "Really destroying %d, having been acked on final message\n", call_to_destroy);						ast_mutex_lock(&iaxsl[call_to_destroy]);						iax2_destroy(call_to_destroy);						ast_mutex_unlock(&iaxsl[call_to_destroy]);					}
if (iaxdebug)							ast_debug(1, "Really destroying %d, having been acked on final message\n", call_to_destroy);
iaxdebug
iaxdebug
ast_debug(1, "Really destroying %d, having been acked on final message\n", call_to_destroy);
ast_debug(1, "Really destroying %d, having been acked on final message\n", call_to_destroy)
ast_debug
ast_debug
1
"Really destroying %d, having been acked on final message\n"
call_to_destroy
call_to_destroy
ast_mutex_lock(&iaxsl[call_to_destroy]);
ast_mutex_lock(&iaxsl[call_to_destroy]);
ast_mutex_lock
ast_mutex_lock
(&iaxsl[call_to_destroy])
&iaxsl[call_to_destroy]
&
iaxsl
[call_to_destroy]
call_to_destroy
call_to_destroy
iax2_destroy(call_to_destroy);
iax2_destroy(call_to_destroy)
iax2_destroy
iax2_destroy
call_to_destroy
call_to_destroy
ast_mutex_unlock(&iaxsl[call_to_destroy]);
ast_mutex_unlock(&iaxsl[call_to_destroy])
ast_mutex_unlock
ast_mutex_unlock
&iaxsl[call_to_destroy]
iaxsl[call_to_destroy]
iaxsl
iaxsl
call_to_destroy
call_to_destroy
if (iaxs[fr->callno])					iaxs[fr->callno]->rseqno = fr->iseqno;				else {					/* Stop processing now */					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
iaxs[fr->callno]->rseqno = fr->iseqno;
iaxs[fr->callno]->rseqno = fr->iseqno
iaxs[fr->callno]->rseqno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
rseqno
fr->iseqno
fr
fr
iseqno
{					/* Stop processing now */					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}
ast_variables_destroy(ies.vars);
ast_variables_destroy(ies.vars)
ast_variables_destroy
ast_variables_destroy
ies.vars
ies
ies
vars
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock
ast_mutex_unlock
(&iaxsl[fr->callno])
&iaxsl[fr->callno]
&
iaxsl
[fr->callno]
fr->callno
fr
fr
callno
return 1;
1
{				ast_debug(1, "Received iseqno %d not within window %d->%d\n", fr->iseqno, iaxs[fr->callno]->rseqno, iaxs[fr->callno]->oseqno);			}
ast_debug(1, "Received iseqno %d not within window %d->%d\n", fr->iseqno, iaxs[fr->callno]->rseqno, iaxs[fr->callno]->oseqno);
ast_debug(1, "Received iseqno %d not within window %d->%d\n", fr->iseqno, iaxs[fr->callno]->rseqno, iaxs[fr->callno]->oseqno)
ast_debug
ast_debug
1
"Received iseqno %d not within window %d->%d\n"
fr->iseqno
fr
fr
iseqno
iaxs[fr->callno]->rseqno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
rseqno
iaxs[fr->callno]->oseqno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
oseqno
if (inaddrcmp(&sin, &iaxs[fr->callno]->addr) &&			((f.frametype != AST_FRAME_IAX) ||			 ((f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT)))) {			/* Only messages we accept from a transfer host are TXACC and TXCNT */			ast_variables_destroy(ies.vars);			ast_mutex_unlock(&iaxsl[fr->callno]);			return 1;		}
inaddrcmp(&sin, &iaxs[fr->callno]->addr) &&			((f.frametype != AST_FRAME_IAX) ||			 ((f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT)))
inaddrcmp(&sin, &iaxs[fr->callno]->addr)
inaddrcmp
inaddrcmp
&sin
sin
sin
&iaxs[fr->callno]->addr
iaxs[fr->callno]->addr
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
addr
((f.frametype != AST_FRAME_IAX) ||			 ((f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT)))
(f.frametype != AST_FRAME_IAX) ||			 ((f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT))
(f.frametype != AST_FRAME_IAX)
f.frametype != AST_FRAME_IAX
f.frametype
f
f
frametype
AST_FRAME_IAX
AST_FRAME_IAX
((f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT))
(f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT)
(f.subclass.integer != IAX_COMMAND_TXACC)
f.subclass.integer != IAX_COMMAND_TXACC
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_TXACC
IAX_COMMAND_TXACC
(f.subclass.integer != IAX_COMMAND_TXCNT)
f.subclass.integer != IAX_COMMAND_TXCNT
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_TXCNT
IAX_COMMAND_TXCNT
{			/* Only messages we accept from a transfer host are TXACC and TXCNT */			ast_variables_destroy(ies.vars);			ast_mutex_unlock(&iaxsl[fr->callno]);			return 1;		}
ast_variables_destroy(ies.vars);
ast_variables_destroy(ies.vars)
ast_variables_destroy
ast_variables_destroy
ies.vars
ies
ies
vars
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock
ast_mutex_unlock
(&iaxsl[fr->callno])
&iaxsl[fr->callno]
&
iaxsl
[fr->callno]
fr->callno
fr
fr
callno
return 1;
1
if ((f.frametype == AST_FRAME_VOICE) ||		    (f.frametype == AST_FRAME_VIDEO) ||		    (f.frametype == AST_FRAME_IAX)) {			if (ast_test_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART)) {				ast_clear_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);				if (!ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->chosenformat, NULL,						  ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED))) {					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}			}			if (ies.vars) {				struct ast_datastore *variablestore = NULL;				struct ast_variable *var, *prev = NULL;				AST_LIST_HEAD(, ast_var_t) *varlist;				iax2_lock_owner(fr->callno);				if (!iaxs[fr->callno]) {					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}				if ((c = iaxs[fr->callno]->owner)) {					varlist = ast_calloc(1, sizeof(*varlist));					variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);					if (variablestore && varlist) {						variablestore->data = varlist;						variablestore->inheritance = DATASTORE_INHERIT_FOREVER;						AST_LIST_HEAD_INIT(varlist);						ast_debug(1, "I can haz IAX vars?\n");						for (var = ies.vars; var; var = var->next) {							struct ast_var_t *newvar = ast_var_assign(var->name, var->value);							if (prev) {								ast_free(prev);							}							prev = var;							if (!newvar) {								/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");							} else {								AST_LIST_INSERT_TAIL(varlist, newvar, entries);							}						}						if (prev) {							ast_free(prev);						}						ies.vars = NULL;						ast_channel_datastore_add(c, variablestore);					} else {						ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");						if (variablestore) {							ast_datastore_free(variablestore);						}						if (varlist) {							ast_free(varlist);						}					}					ast_channel_unlock(c);				} else {					/* No channel yet, so transfer the variables directly over to the pvt,					 * for later inheritance. */					ast_debug(1, "No channel, so populating IAXVARs to the pvt, as an intermediate step.\n");					for (var = ies.vars; var && var->next; var = var->next);					if (var) {						var->next = iaxs[fr->callno]->iaxvars;						iaxs[fr->callno]->iaxvars = ies.vars;						ies.vars = NULL;					}				}			}			if (ies.vars) {				ast_debug(1, "I have IAX variables, but they were not processed\n");			}		}
(f.frametype == AST_FRAME_VOICE) ||		    (f.frametype == AST_FRAME_VIDEO) ||		    (f.frametype == AST_FRAME_IAX)
(f.frametype == AST_FRAME_VOICE) ||		    (f.frametype == AST_FRAME_VIDEO)
(f.frametype == AST_FRAME_VOICE)
f.frametype == AST_FRAME_VOICE
f.frametype
f
f
frametype
AST_FRAME_VOICE
AST_FRAME_VOICE
(f.frametype == AST_FRAME_VIDEO)
f.frametype == AST_FRAME_VIDEO
f.frametype
f
f
frametype
AST_FRAME_VIDEO
AST_FRAME_VIDEO
(f.frametype == AST_FRAME_IAX)
f.frametype == AST_FRAME_IAX
f.frametype
f
f
frametype
AST_FRAME_IAX
AST_FRAME_IAX
{			if (ast_test_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART)) {				ast_clear_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);				if (!ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->chosenformat, NULL,						  ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED))) {					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}			}			if (ies.vars) {				struct ast_datastore *variablestore = NULL;				struct ast_variable *var, *prev = NULL;				AST_LIST_HEAD(, ast_var_t) *varlist;				iax2_lock_owner(fr->callno);				if (!iaxs[fr->callno]) {					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}				if ((c = iaxs[fr->callno]->owner)) {					varlist = ast_calloc(1, sizeof(*varlist));					variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);					if (variablestore && varlist) {						variablestore->data = varlist;						variablestore->inheritance = DATASTORE_INHERIT_FOREVER;						AST_LIST_HEAD_INIT(varlist);						ast_debug(1, "I can haz IAX vars?\n");						for (var = ies.vars; var; var = var->next) {							struct ast_var_t *newvar = ast_var_assign(var->name, var->value);							if (prev) {								ast_free(prev);							}							prev = var;							if (!newvar) {								/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");							} else {								AST_LIST_INSERT_TAIL(varlist, newvar, entries);							}						}						if (prev) {							ast_free(prev);						}						ies.vars = NULL;						ast_channel_datastore_add(c, variablestore);					} else {						ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");						if (variablestore) {							ast_datastore_free(variablestore);						}						if (varlist) {							ast_free(varlist);						}					}					ast_channel_unlock(c);				} else {					/* No channel yet, so transfer the variables directly over to the pvt,					 * for later inheritance. */					ast_debug(1, "No channel, so populating IAXVARs to the pvt, as an intermediate step.\n");					for (var = ies.vars; var && var->next; var = var->next);					if (var) {						var->next = iaxs[fr->callno]->iaxvars;						iaxs[fr->callno]->iaxvars = ies.vars;						ies.vars = NULL;					}				}			}			if (ies.vars) {				ast_debug(1, "I have IAX variables, but they were not processed\n");			}		}
if (ast_test_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART)) {				ast_clear_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);				if (!ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->chosenformat, NULL,						  ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED))) {					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}			}
ast_test_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_DELAYPBXSTART
IAX_DELAYPBXSTART
{				ast_clear_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);				if (!ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->chosenformat, NULL,						  ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED))) {					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}			}
ast_clear_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);
ast_clear_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART)
ast_clear_flag64
ast_clear_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_DELAYPBXSTART
IAX_DELAYPBXSTART
if (!ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->chosenformat, NULL,						  ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED))) {					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}
!ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->chosenformat, NULL,						  ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED))
ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->chosenformat, NULL,						  ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED))
ast_iax2_new
ast_iax2_new
fr->callno
fr
fr
callno
AST_STATE_RING
AST_STATE_RING
iaxs[fr->callno]->chosenformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
chosenformat
NULL
NULL
ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED)
ast_test_flag
ast_test_flag
&iaxs[fr->callno]->state
iaxs[fr->callno]->state
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
state
IAX_STATE_AUTHENTICATED
IAX_STATE_AUTHENTICATED
{					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}
ast_variables_destroy(ies.vars);
ast_variables_destroy(ies.vars)
ast_variables_destroy
ast_variables_destroy
ies.vars
ies
ies
vars
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock
ast_mutex_unlock
(&iaxsl[fr->callno])
&iaxsl[fr->callno]
&
iaxsl
[fr->callno]
fr->callno
fr
fr
callno
return 1;
1
if (ies.vars) {				struct ast_datastore *variablestore = NULL;				struct ast_variable *var, *prev = NULL;				AST_LIST_HEAD(, ast_var_t) *varlist;				iax2_lock_owner(fr->callno);				if (!iaxs[fr->callno]) {					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}				if ((c = iaxs[fr->callno]->owner)) {					varlist = ast_calloc(1, sizeof(*varlist));					variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);					if (variablestore && varlist) {						variablestore->data = varlist;						variablestore->inheritance = DATASTORE_INHERIT_FOREVER;						AST_LIST_HEAD_INIT(varlist);						ast_debug(1, "I can haz IAX vars?\n");						for (var = ies.vars; var; var = var->next) {							struct ast_var_t *newvar = ast_var_assign(var->name, var->value);							if (prev) {								ast_free(prev);							}							prev = var;							if (!newvar) {								/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");							} else {								AST_LIST_INSERT_TAIL(varlist, newvar, entries);							}						}						if (prev) {							ast_free(prev);						}						ies.vars = NULL;						ast_channel_datastore_add(c, variablestore);					} else {						ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");						if (variablestore) {							ast_datastore_free(variablestore);						}						if (varlist) {							ast_free(varlist);						}					}					ast_channel_unlock(c);				} else {					/* No channel yet, so transfer the variables directly over to the pvt,					 * for later inheritance. */					ast_debug(1, "No channel, so populating IAXVARs to the pvt, as an intermediate step.\n");					for (var = ies.vars; var && var->next; var = var->next);					if (var) {						var->next = iaxs[fr->callno]->iaxvars;						iaxs[fr->callno]->iaxvars = ies.vars;						ies.vars = NULL;					}				}			}
ies.vars
ies
ies
vars
{				struct ast_datastore *variablestore = NULL;				struct ast_variable *var, *prev = NULL;				AST_LIST_HEAD(, ast_var_t) *varlist;				iax2_lock_owner(fr->callno);				if (!iaxs[fr->callno]) {					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}				if ((c = iaxs[fr->callno]->owner)) {					varlist = ast_calloc(1, sizeof(*varlist));					variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);					if (variablestore && varlist) {						variablestore->data = varlist;						variablestore->inheritance = DATASTORE_INHERIT_FOREVER;						AST_LIST_HEAD_INIT(varlist);						ast_debug(1, "I can haz IAX vars?\n");						for (var = ies.vars; var; var = var->next) {							struct ast_var_t *newvar = ast_var_assign(var->name, var->value);							if (prev) {								ast_free(prev);							}							prev = var;							if (!newvar) {								/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");							} else {								AST_LIST_INSERT_TAIL(varlist, newvar, entries);							}						}						if (prev) {							ast_free(prev);						}						ies.vars = NULL;						ast_channel_datastore_add(c, variablestore);					} else {						ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");						if (variablestore) {							ast_datastore_free(variablestore);						}						if (varlist) {							ast_free(varlist);						}					}					ast_channel_unlock(c);				} else {					/* No channel yet, so transfer the variables directly over to the pvt,					 * for later inheritance. */					ast_debug(1, "No channel, so populating IAXVARs to the pvt, as an intermediate step.\n");					for (var = ies.vars; var && var->next; var = var->next);					if (var) {						var->next = iaxs[fr->callno]->iaxvars;						iaxs[fr->callno]->iaxvars = ies.vars;						ies.vars = NULL;					}				}			}
struct ast_datastore *variablestore = NULL;
struct ast_datastore *variablestore = NULL;
struct ast_datastore
ast_datastore
*variablestore = NULL
*
variablestore
= NULL
NULL
NULL
struct ast_variable *var, *prev = NULL;
struct ast_variable *var, *prev = NULL;
struct ast_variable
ast_variable
*var
*
var
*prev = NULL
*
prev
= NULL
NULL
NULL
AST_LIST_HEAD(, ast_var_t) *varlist;
iax2_lock_owner(fr->callno);
iax2_lock_owner(fr->callno)
iax2_lock_owner
iax2_lock_owner
fr->callno
fr
fr
callno
if (!iaxs[fr->callno]) {					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}
!iaxs[fr->callno]
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}
ast_variables_destroy(ies.vars);
ast_variables_destroy(ies.vars)
ast_variables_destroy
ast_variables_destroy
ies.vars
ies
ies
vars
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock
ast_mutex_unlock
(&iaxsl[fr->callno])
&iaxsl[fr->callno]
&
iaxsl
[fr->callno]
fr->callno
fr
fr
callno
return 1;
1
if ((c = iaxs[fr->callno]->owner)) {					varlist = ast_calloc(1, sizeof(*varlist));					variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);					if (variablestore && varlist) {						variablestore->data = varlist;						variablestore->inheritance = DATASTORE_INHERIT_FOREVER;						AST_LIST_HEAD_INIT(varlist);						ast_debug(1, "I can haz IAX vars?\n");						for (var = ies.vars; var; var = var->next) {							struct ast_var_t *newvar = ast_var_assign(var->name, var->value);							if (prev) {								ast_free(prev);							}							prev = var;							if (!newvar) {								/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");							} else {								AST_LIST_INSERT_TAIL(varlist, newvar, entries);							}						}						if (prev) {							ast_free(prev);						}						ies.vars = NULL;						ast_channel_datastore_add(c, variablestore);					} else {						ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");						if (variablestore) {							ast_datastore_free(variablestore);						}						if (varlist) {							ast_free(varlist);						}					}					ast_channel_unlock(c);				} else {					/* No channel yet, so transfer the variables directly over to the pvt,					 * for later inheritance. */					ast_debug(1, "No channel, so populating IAXVARs to the pvt, as an intermediate step.\n");					for (var = ies.vars; var && var->next; var = var->next);					if (var) {						var->next = iaxs[fr->callno]->iaxvars;						iaxs[fr->callno]->iaxvars = ies.vars;						ies.vars = NULL;					}				}
(c = iaxs[fr->callno]->owner)
c = iaxs[fr->callno]->owner
c
c
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
{					varlist = ast_calloc(1, sizeof(*varlist));					variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);					if (variablestore && varlist) {						variablestore->data = varlist;						variablestore->inheritance = DATASTORE_INHERIT_FOREVER;						AST_LIST_HEAD_INIT(varlist);						ast_debug(1, "I can haz IAX vars?\n");						for (var = ies.vars; var; var = var->next) {							struct ast_var_t *newvar = ast_var_assign(var->name, var->value);							if (prev) {								ast_free(prev);							}							prev = var;							if (!newvar) {								/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");							} else {								AST_LIST_INSERT_TAIL(varlist, newvar, entries);							}						}						if (prev) {							ast_free(prev);						}						ies.vars = NULL;						ast_channel_datastore_add(c, variablestore);					} else {						ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");						if (variablestore) {							ast_datastore_free(variablestore);						}						if (varlist) {							ast_free(varlist);						}					}					ast_channel_unlock(c);				}
varlist = ast_calloc(1, sizeof(*varlist));
varlist = ast_calloc(1, sizeof(*varlist))
varlist
varlist
ast_calloc(1, sizeof(*varlist))
ast_calloc
ast_calloc
1
sizeof(*varlist)
(*varlist)
*varlist
varlist
varlist
variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);
variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL)
variablestore
variablestore
ast_datastore_alloc(&iax2_variable_datastore_info, NULL)
ast_datastore_alloc
ast_datastore_alloc
&iax2_variable_datastore_info
iax2_variable_datastore_info
iax2_variable_datastore_info
NULL
NULL
if (variablestore && varlist) {						variablestore->data = varlist;						variablestore->inheritance = DATASTORE_INHERIT_FOREVER;						AST_LIST_HEAD_INIT(varlist);						ast_debug(1, "I can haz IAX vars?\n");						for (var = ies.vars; var; var = var->next) {							struct ast_var_t *newvar = ast_var_assign(var->name, var->value);							if (prev) {								ast_free(prev);							}							prev = var;							if (!newvar) {								/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");							} else {								AST_LIST_INSERT_TAIL(varlist, newvar, entries);							}						}						if (prev) {							ast_free(prev);						}						ies.vars = NULL;						ast_channel_datastore_add(c, variablestore);					} else {						ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");						if (variablestore) {							ast_datastore_free(variablestore);						}						if (varlist) {							ast_free(varlist);						}					}
variablestore && varlist
variablestore
variablestore
varlist
varlist
{						variablestore->data = varlist;						variablestore->inheritance = DATASTORE_INHERIT_FOREVER;						AST_LIST_HEAD_INIT(varlist);						ast_debug(1, "I can haz IAX vars?\n");						for (var = ies.vars; var; var = var->next) {							struct ast_var_t *newvar = ast_var_assign(var->name, var->value);							if (prev) {								ast_free(prev);							}							prev = var;							if (!newvar) {								/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");							} else {								AST_LIST_INSERT_TAIL(varlist, newvar, entries);							}						}						if (prev) {							ast_free(prev);						}						ies.vars = NULL;						ast_channel_datastore_add(c, variablestore);					}
variablestore->data = varlist;
variablestore->data = varlist
variablestore->data
variablestore
variablestore
data
varlist
varlist
variablestore->inheritance = DATASTORE_INHERIT_FOREVER;
variablestore->inheritance = DATASTORE_INHERIT_FOREVER
variablestore->inheritance
variablestore
variablestore
inheritance
DATASTORE_INHERIT_FOREVER
DATASTORE_INHERIT_FOREVER
AST_LIST_HEAD_INIT(varlist);
AST_LIST_HEAD_INIT(varlist);
AST_LIST_HEAD_INIT
AST_LIST_HEAD_INIT
(varlist)
varlist
varlist
ast_debug(1, "I can haz IAX vars?\n");
ast_debug(1, "I can haz IAX vars?\n")
ast_debug
ast_debug
1
"I can haz IAX vars?\n"
for (var = ies.vars; var; var = var->next) {							struct ast_var_t *newvar = ast_var_assign(var->name, var->value);							if (prev) {								ast_free(prev);							}							prev = var;							if (!newvar) {								/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");							} else {								AST_LIST_INSERT_TAIL(varlist, newvar, entries);							}						}
var = ies.vars;
var = ies.vars
var
var
ies.vars
ies
ies
vars
var
var
var = var->next
var
var
var->next
var
var
next
{							struct ast_var_t *newvar = ast_var_assign(var->name, var->value);							if (prev) {								ast_free(prev);							}							prev = var;							if (!newvar) {								/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");							} else {								AST_LIST_INSERT_TAIL(varlist, newvar, entries);							}						}
struct ast_var_t *newvar = ast_var_assign(var->name, var->value);
struct ast_var_t *newvar = ast_var_assign(var->name, var->value);
struct ast_var_t
ast_var_t
*newvar = ast_var_assign(var->name, var->value)
*
newvar
= ast_var_assign(var->name, var->value)
ast_var_assign(var->name, var->value)
ast_var_assign
ast_var_assign
var->name
var
var
name
var->value
var
var
value
if (prev) {								ast_free(prev);							}
prev
prev
{								ast_free(prev);							}
ast_free(prev);
ast_free(prev)
ast_free
ast_free
prev
prev
prev = var;
prev = var
prev
prev
var
var
if (!newvar) {								/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");							} else {								AST_LIST_INSERT_TAIL(varlist, newvar, entries);							}
!newvar
newvar
newvar
{								/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");							}
ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");
ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n")
ast_log
ast_log
LOG_ERROR
LOG_ERROR
"Memory allocation error while processing IAX2 variables\n"
{								AST_LIST_INSERT_TAIL(varlist, newvar, entries);							}
AST_LIST_INSERT_TAIL(varlist, newvar, entries);
AST_LIST_INSERT_TAIL(varlist, newvar, entries)
AST_LIST_INSERT_TAIL
AST_LIST_INSERT_TAIL
varlist
varlist
newvar
newvar
entries
entries
if (prev) {							ast_free(prev);						}
prev
prev
{							ast_free(prev);						}
ast_free(prev);
ast_free(prev)
ast_free
ast_free
prev
prev
ies.vars = NULL;
ies.vars = NULL
ies.vars
ies
ies
vars
NULL
NULL
ast_channel_datastore_add(c, variablestore);
ast_channel_datastore_add(c, variablestore)
ast_channel_datastore_add
ast_channel_datastore_add
c
c
variablestore
variablestore
{						ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");						if (variablestore) {							ast_datastore_free(variablestore);						}						if (varlist) {							ast_free(varlist);						}					}
ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");
ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n")
ast_log
ast_log
LOG_ERROR
LOG_ERROR
"Memory allocation error while processing IAX2 variables\n"
if (variablestore) {							ast_datastore_free(variablestore);						}
variablestore
variablestore
{							ast_datastore_free(variablestore);						}
ast_datastore_free(variablestore);
ast_datastore_free(variablestore)
ast_datastore_free
ast_datastore_free
variablestore
variablestore
if (varlist) {							ast_free(varlist);						}
varlist
varlist
{							ast_free(varlist);						}
ast_free(varlist);
ast_free(varlist);
ast_free
ast_free
(varlist)
varlist
varlist
ast_channel_unlock(c);
ast_channel_unlock(c)
ast_channel_unlock
ast_channel_unlock
c
c
{					/* No channel yet, so transfer the variables directly over to the pvt,					 * for later inheritance. */					ast_debug(1, "No channel, so populating IAXVARs to the pvt, as an intermediate step.\n");					for (var = ies.vars; var && var->next; var = var->next);					if (var) {						var->next = iaxs[fr->callno]->iaxvars;						iaxs[fr->callno]->iaxvars = ies.vars;						ies.vars = NULL;					}				}
ast_debug(1, "No channel, so populating IAXVARs to the pvt, as an intermediate step.\n");
ast_debug(1, "No channel, so populating IAXVARs to the pvt, as an intermediate step.\n")
ast_debug
ast_debug
1
"No channel, so populating IAXVARs to the pvt, as an intermediate step.\n"
for (var = ies.vars; var && var->next; var = var->next);
var = ies.vars;
var = ies.vars
var
var
ies.vars
ies
ies
vars
var && var->next
var
var
var->next
var
var
next
var = var->next
var
var
var->next
var
var
next
;
if (var) {						var->next = iaxs[fr->callno]->iaxvars;						iaxs[fr->callno]->iaxvars = ies.vars;						ies.vars = NULL;					}
var
var
{						var->next = iaxs[fr->callno]->iaxvars;						iaxs[fr->callno]->iaxvars = ies.vars;						ies.vars = NULL;					}
var->next = iaxs[fr->callno]->iaxvars;
var->next = iaxs[fr->callno]->iaxvars
var->next
var
var
next
iaxs[fr->callno]->iaxvars
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
iaxvars
iaxs[fr->callno]->iaxvars = ies.vars;
iaxs[fr->callno]->iaxvars = ies.vars
iaxs[fr->callno]->iaxvars
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
iaxvars
ies.vars
ies
ies
vars
ies.vars = NULL;
ies.vars = NULL
ies.vars
ies
ies
vars
NULL
NULL
if (ies.vars) {				ast_debug(1, "I have IAX variables, but they were not processed\n");			}
ies.vars
ies
ies
vars
{				ast_debug(1, "I have IAX variables, but they were not processed\n");			}
ast_debug(1, "I have IAX variables, but they were not processed\n");
ast_debug(1, "I have IAX variables, but they were not processed\n")
ast_debug
ast_debug
1
"I have IAX variables, but they were not processed\n"
if ((f.frametype == AST_FRAME_IAX) && (f.subclass.integer != IAX_COMMAND_CALLTOKEN) && iaxs[fr->callno]->hold_signaling) {			send_signaling(iaxs[fr->callno]);		}
(f.frametype == AST_FRAME_IAX) && (f.subclass.integer != IAX_COMMAND_CALLTOKEN) && iaxs[fr->callno]->hold_signaling
(f.frametype == AST_FRAME_IAX) && (f.subclass.integer != IAX_COMMAND_CALLTOKEN)
(f.frametype == AST_FRAME_IAX)
f.frametype == AST_FRAME_IAX
f.frametype
f
f
frametype
AST_FRAME_IAX
AST_FRAME_IAX
(f.subclass.integer != IAX_COMMAND_CALLTOKEN)
f.subclass.integer != IAX_COMMAND_CALLTOKEN
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_CALLTOKEN
IAX_COMMAND_CALLTOKEN
iaxs[fr->callno]->hold_signaling
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
hold_signaling
{			send_signaling(iaxs[fr->callno]);		}
send_signaling(iaxs[fr->callno]);
send_signaling(iaxs[fr->callno]);
send_signaling
send_signaling
(iaxs[fr->callno])
iaxs[fr->callno]
iaxs
[fr->callno]
fr->callno
fr
fr
callno
if (f.frametype == AST_FRAME_VOICE) {			if (ast_format_to_old_bitfield(&f.subclass.format) != iaxs[fr->callno]->voiceformat) {					iaxs[fr->callno]->voiceformat = ast_format_to_old_bitfield(&f.subclass.format);					ast_debug(1, "Ooh, voice format changed to '%s'\n", ast_getformatname(&f.subclass.format));					if (iaxs[fr->callno]->owner) {						iax2_lock_owner(fr->callno);						if (iaxs[fr->callno]) {							if (iaxs[fr->callno]->owner) {								struct ast_format_cap *orignative = ast_format_cap_dup(ast_channel_nativeformats(iaxs[fr->callno]->owner));								struct ast_format_cap *native = ast_channel_nativeformats(iaxs[fr->callno]->owner);								if (orignative) {									ast_format_cap_set(native, &f.subclass.format);									if (ast_channel_readformat(iaxs[fr->callno]->owner)->id) {										ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));									}									ast_format_cap_copy(native, orignative);									ast_channel_unlock(iaxs[fr->callno]->owner);									orignative = ast_format_cap_destroy(orignative);								}							}						} else {							ast_debug(1, "Neat, somebody took away the channel at a magical time but i found it!\n");							/* Free remote variables (if any) */							if (ies.vars) {								ast_variables_destroy(ies.vars);								ast_debug(1, "I can haz iaxvars, but they is no good.  :-(\n");								ies.vars = NULL;							}							ast_mutex_unlock(&iaxsl[fr->callno]);							return 1;						}					}			}		}
f.frametype == AST_FRAME_VOICE
f.frametype
f
f
frametype
AST_FRAME_VOICE
AST_FRAME_VOICE
{			if (ast_format_to_old_bitfield(&f.subclass.format) != iaxs[fr->callno]->voiceformat) {					iaxs[fr->callno]->voiceformat = ast_format_to_old_bitfield(&f.subclass.format);					ast_debug(1, "Ooh, voice format changed to '%s'\n", ast_getformatname(&f.subclass.format));					if (iaxs[fr->callno]->owner) {						iax2_lock_owner(fr->callno);						if (iaxs[fr->callno]) {							if (iaxs[fr->callno]->owner) {								struct ast_format_cap *orignative = ast_format_cap_dup(ast_channel_nativeformats(iaxs[fr->callno]->owner));								struct ast_format_cap *native = ast_channel_nativeformats(iaxs[fr->callno]->owner);								if (orignative) {									ast_format_cap_set(native, &f.subclass.format);									if (ast_channel_readformat(iaxs[fr->callno]->owner)->id) {										ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));									}									ast_format_cap_copy(native, orignative);									ast_channel_unlock(iaxs[fr->callno]->owner);									orignative = ast_format_cap_destroy(orignative);								}							}						} else {							ast_debug(1, "Neat, somebody took away the channel at a magical time but i found it!\n");							/* Free remote variables (if any) */							if (ies.vars) {								ast_variables_destroy(ies.vars);								ast_debug(1, "I can haz iaxvars, but they is no good.  :-(\n");								ies.vars = NULL;							}							ast_mutex_unlock(&iaxsl[fr->callno]);							return 1;						}					}			}		}
if (ast_format_to_old_bitfield(&f.subclass.format) != iaxs[fr->callno]->voiceformat) {					iaxs[fr->callno]->voiceformat = ast_format_to_old_bitfield(&f.subclass.format);					ast_debug(1, "Ooh, voice format changed to '%s'\n", ast_getformatname(&f.subclass.format));					if (iaxs[fr->callno]->owner) {						iax2_lock_owner(fr->callno);						if (iaxs[fr->callno]) {							if (iaxs[fr->callno]->owner) {								struct ast_format_cap *orignative = ast_format_cap_dup(ast_channel_nativeformats(iaxs[fr->callno]->owner));								struct ast_format_cap *native = ast_channel_nativeformats(iaxs[fr->callno]->owner);								if (orignative) {									ast_format_cap_set(native, &f.subclass.format);									if (ast_channel_readformat(iaxs[fr->callno]->owner)->id) {										ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));									}									ast_format_cap_copy(native, orignative);									ast_channel_unlock(iaxs[fr->callno]->owner);									orignative = ast_format_cap_destroy(orignative);								}							}						} else {							ast_debug(1, "Neat, somebody took away the channel at a magical time but i found it!\n");							/* Free remote variables (if any) */							if (ies.vars) {								ast_variables_destroy(ies.vars);								ast_debug(1, "I can haz iaxvars, but they is no good.  :-(\n");								ies.vars = NULL;							}							ast_mutex_unlock(&iaxsl[fr->callno]);							return 1;						}					}			}
ast_format_to_old_bitfield(&f.subclass.format) != iaxs[fr->callno]->voiceformat
ast_format_to_old_bitfield(&f.subclass.format)
ast_format_to_old_bitfield
ast_format_to_old_bitfield
&f.subclass.format
f.subclass.format
f.subclass
f
f
subclass
format
iaxs[fr->callno]->voiceformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
voiceformat
{					iaxs[fr->callno]->voiceformat = ast_format_to_old_bitfield(&f.subclass.format);					ast_debug(1, "Ooh, voice format changed to '%s'\n", ast_getformatname(&f.subclass.format));					if (iaxs[fr->callno]->owner) {						iax2_lock_owner(fr->callno);						if (iaxs[fr->callno]) {							if (iaxs[fr->callno]->owner) {								struct ast_format_cap *orignative = ast_format_cap_dup(ast_channel_nativeformats(iaxs[fr->callno]->owner));								struct ast_format_cap *native = ast_channel_nativeformats(iaxs[fr->callno]->owner);								if (orignative) {									ast_format_cap_set(native, &f.subclass.format);									if (ast_channel_readformat(iaxs[fr->callno]->owner)->id) {										ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));									}									ast_format_cap_copy(native, orignative);									ast_channel_unlock(iaxs[fr->callno]->owner);									orignative = ast_format_cap_destroy(orignative);								}							}						} else {							ast_debug(1, "Neat, somebody took away the channel at a magical time but i found it!\n");							/* Free remote variables (if any) */							if (ies.vars) {								ast_variables_destroy(ies.vars);								ast_debug(1, "I can haz iaxvars, but they is no good.  :-(\n");								ies.vars = NULL;							}							ast_mutex_unlock(&iaxsl[fr->callno]);							return 1;						}					}			}
iaxs[fr->callno]->voiceformat = ast_format_to_old_bitfield(&f.subclass.format);
iaxs[fr->callno]->voiceformat = ast_format_to_old_bitfield(&f.subclass.format)
iaxs[fr->callno]->voiceformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
voiceformat
ast_format_to_old_bitfield(&f.subclass.format)
ast_format_to_old_bitfield
ast_format_to_old_bitfield
&f.subclass.format
f.subclass.format
f.subclass
f
f
subclass
format
ast_debug(1, "Ooh, voice format changed to '%s'\n", ast_getformatname(&f.subclass.format));
ast_debug(1, "Ooh, voice format changed to '%s'\n", ast_getformatname(&f.subclass.format))
ast_debug
ast_debug
1
"Ooh, voice format changed to '%s'\n"
ast_getformatname(&f.subclass.format)
ast_getformatname
ast_getformatname
&f.subclass.format
f.subclass.format
f.subclass
f
f
subclass
format
if (iaxs[fr->callno]->owner) {						iax2_lock_owner(fr->callno);						if (iaxs[fr->callno]) {							if (iaxs[fr->callno]->owner) {								struct ast_format_cap *orignative = ast_format_cap_dup(ast_channel_nativeformats(iaxs[fr->callno]->owner));								struct ast_format_cap *native = ast_channel_nativeformats(iaxs[fr->callno]->owner);								if (orignative) {									ast_format_cap_set(native, &f.subclass.format);									if (ast_channel_readformat(iaxs[fr->callno]->owner)->id) {										ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));									}									ast_format_cap_copy(native, orignative);									ast_channel_unlock(iaxs[fr->callno]->owner);									orignative = ast_format_cap_destroy(orignative);								}							}						} else {							ast_debug(1, "Neat, somebody took away the channel at a magical time but i found it!\n");							/* Free remote variables (if any) */							if (ies.vars) {								ast_variables_destroy(ies.vars);								ast_debug(1, "I can haz iaxvars, but they is no good.  :-(\n");								ies.vars = NULL;							}							ast_mutex_unlock(&iaxsl[fr->callno]);							return 1;						}					}
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
{						iax2_lock_owner(fr->callno);						if (iaxs[fr->callno]) {							if (iaxs[fr->callno]->owner) {								struct ast_format_cap *orignative = ast_format_cap_dup(ast_channel_nativeformats(iaxs[fr->callno]->owner));								struct ast_format_cap *native = ast_channel_nativeformats(iaxs[fr->callno]->owner);								if (orignative) {									ast_format_cap_set(native, &f.subclass.format);									if (ast_channel_readformat(iaxs[fr->callno]->owner)->id) {										ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));									}									ast_format_cap_copy(native, orignative);									ast_channel_unlock(iaxs[fr->callno]->owner);									orignative = ast_format_cap_destroy(orignative);								}							}						} else {							ast_debug(1, "Neat, somebody took away the channel at a magical time but i found it!\n");							/* Free remote variables (if any) */							if (ies.vars) {								ast_variables_destroy(ies.vars);								ast_debug(1, "I can haz iaxvars, but they is no good.  :-(\n");								ies.vars = NULL;							}							ast_mutex_unlock(&iaxsl[fr->callno]);							return 1;						}					}
iax2_lock_owner(fr->callno);
iax2_lock_owner(fr->callno)
iax2_lock_owner
iax2_lock_owner
fr->callno
fr
fr
callno
if (iaxs[fr->callno]) {							if (iaxs[fr->callno]->owner) {								struct ast_format_cap *orignative = ast_format_cap_dup(ast_channel_nativeformats(iaxs[fr->callno]->owner));								struct ast_format_cap *native = ast_channel_nativeformats(iaxs[fr->callno]->owner);								if (orignative) {									ast_format_cap_set(native, &f.subclass.format);									if (ast_channel_readformat(iaxs[fr->callno]->owner)->id) {										ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));									}									ast_format_cap_copy(native, orignative);									ast_channel_unlock(iaxs[fr->callno]->owner);									orignative = ast_format_cap_destroy(orignative);								}							}						} else {							ast_debug(1, "Neat, somebody took away the channel at a magical time but i found it!\n");							/* Free remote variables (if any) */							if (ies.vars) {								ast_variables_destroy(ies.vars);								ast_debug(1, "I can haz iaxvars, but they is no good.  :-(\n");								ies.vars = NULL;							}							ast_mutex_unlock(&iaxsl[fr->callno]);							return 1;						}
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{							if (iaxs[fr->callno]->owner) {								struct ast_format_cap *orignative = ast_format_cap_dup(ast_channel_nativeformats(iaxs[fr->callno]->owner));								struct ast_format_cap *native = ast_channel_nativeformats(iaxs[fr->callno]->owner);								if (orignative) {									ast_format_cap_set(native, &f.subclass.format);									if (ast_channel_readformat(iaxs[fr->callno]->owner)->id) {										ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));									}									ast_format_cap_copy(native, orignative);									ast_channel_unlock(iaxs[fr->callno]->owner);									orignative = ast_format_cap_destroy(orignative);								}							}						}
if (iaxs[fr->callno]->owner) {								struct ast_format_cap *orignative = ast_format_cap_dup(ast_channel_nativeformats(iaxs[fr->callno]->owner));								struct ast_format_cap *native = ast_channel_nativeformats(iaxs[fr->callno]->owner);								if (orignative) {									ast_format_cap_set(native, &f.subclass.format);									if (ast_channel_readformat(iaxs[fr->callno]->owner)->id) {										ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));									}									ast_format_cap_copy(native, orignative);									ast_channel_unlock(iaxs[fr->callno]->owner);									orignative = ast_format_cap_destroy(orignative);								}							}
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
{								struct ast_format_cap *orignative = ast_format_cap_dup(ast_channel_nativeformats(iaxs[fr->callno]->owner));								struct ast_format_cap *native = ast_channel_nativeformats(iaxs[fr->callno]->owner);								if (orignative) {									ast_format_cap_set(native, &f.subclass.format);									if (ast_channel_readformat(iaxs[fr->callno]->owner)->id) {										ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));									}									ast_format_cap_copy(native, orignative);									ast_channel_unlock(iaxs[fr->callno]->owner);									orignative = ast_format_cap_destroy(orignative);								}							}
struct ast_format_cap *orignative = ast_format_cap_dup(ast_channel_nativeformats(iaxs[fr->callno]->owner));
struct ast_format_cap *orignative = ast_format_cap_dup(ast_channel_nativeformats(iaxs[fr->callno]->owner));
struct ast_format_cap
ast_format_cap
*orignative = ast_format_cap_dup(ast_channel_nativeformats(iaxs[fr->callno]->owner))
*
orignative
= ast_format_cap_dup(ast_channel_nativeformats(iaxs[fr->callno]->owner))
ast_format_cap_dup(ast_channel_nativeformats(iaxs[fr->callno]->owner))
ast_format_cap_dup
ast_format_cap_dup
ast_channel_nativeformats(iaxs[fr->callno]->owner)
ast_channel_nativeformats
ast_channel_nativeformats
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
struct ast_format_cap *native = ast_channel_nativeformats(iaxs[fr->callno]->owner);
struct ast_format_cap *native = ast_channel_nativeformats(iaxs[fr->callno]->owner);
struct ast_format_cap
ast_format_cap
*native = ast_channel_nativeformats(iaxs[fr->callno]->owner)
*
native
= ast_channel_nativeformats(iaxs[fr->callno]->owner)
ast_channel_nativeformats(iaxs[fr->callno]->owner)
ast_channel_nativeformats
ast_channel_nativeformats
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
if (orignative) {									ast_format_cap_set(native, &f.subclass.format);									if (ast_channel_readformat(iaxs[fr->callno]->owner)->id) {										ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));									}									ast_format_cap_copy(native, orignative);									ast_channel_unlock(iaxs[fr->callno]->owner);									orignative = ast_format_cap_destroy(orignative);								}
orignative
orignative
{									ast_format_cap_set(native, &f.subclass.format);									if (ast_channel_readformat(iaxs[fr->callno]->owner)->id) {										ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));									}									ast_format_cap_copy(native, orignative);									ast_channel_unlock(iaxs[fr->callno]->owner);									orignative = ast_format_cap_destroy(orignative);								}
ast_format_cap_set(native, &f.subclass.format);
ast_format_cap_set(native, &f.subclass.format)
ast_format_cap_set
ast_format_cap_set
native
native
&f.subclass.format
f.subclass.format
f.subclass
f
f
subclass
format
if (ast_channel_readformat(iaxs[fr->callno]->owner)->id) {										ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));									}
ast_channel_readformat(iaxs[fr->callno]->owner)->id
ast_channel_readformat(iaxs[fr->callno]->owner)
ast_channel_readformat
ast_channel_readformat
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
id
{										ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));									}
ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));
ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner))
ast_set_read_format
ast_set_read_format
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
ast_channel_readformat(iaxs[fr->callno]->owner)
ast_channel_readformat
ast_channel_readformat
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
ast_format_cap_copy(native, orignative);
ast_format_cap_copy(native, orignative)
ast_format_cap_copy
ast_format_cap_copy
native
native
orignative
orignative
ast_channel_unlock(iaxs[fr->callno]->owner);
ast_channel_unlock(iaxs[fr->callno]->owner)
ast_channel_unlock
ast_channel_unlock
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
orignative = ast_format_cap_destroy(orignative);
orignative = ast_format_cap_destroy(orignative)
orignative
orignative
ast_format_cap_destroy(orignative)
ast_format_cap_destroy
ast_format_cap_destroy
orignative
orignative
{							ast_debug(1, "Neat, somebody took away the channel at a magical time but i found it!\n");							/* Free remote variables (if any) */							if (ies.vars) {								ast_variables_destroy(ies.vars);								ast_debug(1, "I can haz iaxvars, but they is no good.  :-(\n");								ies.vars = NULL;							}							ast_mutex_unlock(&iaxsl[fr->callno]);							return 1;						}
ast_debug(1, "Neat, somebody took away the channel at a magical time but i found it!\n");
ast_debug(1, "Neat, somebody took away the channel at a magical time but i found it!\n")
ast_debug
ast_debug
1
"Neat, somebody took away the channel at a magical time but i found it!\n"
if (ies.vars) {								ast_variables_destroy(ies.vars);								ast_debug(1, "I can haz iaxvars, but they is no good.  :-(\n");								ies.vars = NULL;							}
ies.vars
ies
ies
vars
{								ast_variables_destroy(ies.vars);								ast_debug(1, "I can haz iaxvars, but they is no good.  :-(\n");								ies.vars = NULL;							}
ast_variables_destroy(ies.vars);
ast_variables_destroy(ies.vars)
ast_variables_destroy
ast_variables_destroy
ies.vars
ies
ies
vars
ast_debug(1, "I can haz iaxvars, but they is no good.  :-(\n");
ast_debug(1, "I can haz iaxvars, but they is no good.  :-(\n")
ast_debug
ast_debug
1
"I can haz iaxvars, but they is no good.  :-(\n"
ies.vars = NULL;
ies.vars = NULL
ies.vars
ies
ies
vars
NULL
NULL
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock
ast_mutex_unlock
(&iaxsl[fr->callno])
&iaxsl[fr->callno]
&
iaxsl
[fr->callno]
fr->callno
fr
fr
callno
return 1;
1
if (f.frametype == AST_FRAME_VIDEO) {			if (f.subclass.format.id != ast_format_id_from_old_bitfield(iaxs[fr->callno]->videoformat)) {				ast_debug(1, "Ooh, video format changed to %s\n", ast_getformatname(&f.subclass.format));				iaxs[fr->callno]->videoformat = ast_format_to_old_bitfield(&f.subclass.format);			}		}
f.frametype == AST_FRAME_VIDEO
f.frametype
f
f
frametype
AST_FRAME_VIDEO
AST_FRAME_VIDEO
{			if (f.subclass.format.id != ast_format_id_from_old_bitfield(iaxs[fr->callno]->videoformat)) {				ast_debug(1, "Ooh, video format changed to %s\n", ast_getformatname(&f.subclass.format));				iaxs[fr->callno]->videoformat = ast_format_to_old_bitfield(&f.subclass.format);			}		}
if (f.subclass.format.id != ast_format_id_from_old_bitfield(iaxs[fr->callno]->videoformat)) {				ast_debug(1, "Ooh, video format changed to %s\n", ast_getformatname(&f.subclass.format));				iaxs[fr->callno]->videoformat = ast_format_to_old_bitfield(&f.subclass.format);			}
f.subclass.format.id != ast_format_id_from_old_bitfield(iaxs[fr->callno]->videoformat)
f.subclass.format.id
f.subclass.format
f.subclass
f
f
subclass
format
id
ast_format_id_from_old_bitfield(iaxs[fr->callno]->videoformat)
ast_format_id_from_old_bitfield
ast_format_id_from_old_bitfield
iaxs[fr->callno]->videoformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
videoformat
{				ast_debug(1, "Ooh, video format changed to %s\n", ast_getformatname(&f.subclass.format));				iaxs[fr->callno]->videoformat = ast_format_to_old_bitfield(&f.subclass.format);			}
ast_debug(1, "Ooh, video format changed to %s\n", ast_getformatname(&f.subclass.format));
ast_debug(1, "Ooh, video format changed to %s\n", ast_getformatname(&f.subclass.format))
ast_debug
ast_debug
1
"Ooh, video format changed to %s\n"
ast_getformatname(&f.subclass.format)
ast_getformatname
ast_getformatname
&f.subclass.format
f.subclass.format
f.subclass
f
f
subclass
format
iaxs[fr->callno]->videoformat = ast_format_to_old_bitfield(&f.subclass.format);
iaxs[fr->callno]->videoformat = ast_format_to_old_bitfield(&f.subclass.format)
iaxs[fr->callno]->videoformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
videoformat
ast_format_to_old_bitfield(&f.subclass.format)
ast_format_to_old_bitfield
ast_format_to_old_bitfield
&f.subclass.format
f.subclass.format
f.subclass
f
f
subclass
format
if (f.frametype == AST_FRAME_CONTROL && iaxs[fr->callno]->owner) {			if (f.subclass.integer == AST_CONTROL_BUSY) {				ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_BUSY);			} else if (f.subclass.integer == AST_CONTROL_CONGESTION) {				ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_CONGESTION);			}		}
f.frametype == AST_FRAME_CONTROL && iaxs[fr->callno]->owner
f.frametype == AST_FRAME_CONTROL
f.frametype
f
f
frametype
AST_FRAME_CONTROL
AST_FRAME_CONTROL
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
{			if (f.subclass.integer == AST_CONTROL_BUSY) {				ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_BUSY);			} else if (f.subclass.integer == AST_CONTROL_CONGESTION) {				ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_CONGESTION);			}		}
if (f.subclass.integer == AST_CONTROL_BUSY) {				ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_BUSY);			} else if (f.subclass.integer == AST_CONTROL_CONGESTION) {				ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_CONGESTION);			}
f.subclass.integer == AST_CONTROL_BUSY
f.subclass.integer
f.subclass
f
f
subclass
integer
AST_CONTROL_BUSY
AST_CONTROL_BUSY
{				ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_BUSY);			}
ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_BUSY);
ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_BUSY)
ast_channel_hangupcause_set
ast_channel_hangupcause_set
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
AST_CAUSE_BUSY
AST_CAUSE_BUSY
if (f.subclass.integer == AST_CONTROL_CONGESTION) {				ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_CONGESTION);			}
f.subclass.integer == AST_CONTROL_CONGESTION
f.subclass.integer
f.subclass
f
f
subclass
integer
AST_CONTROL_CONGESTION
AST_CONTROL_CONGESTION
{				ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_CONGESTION);			}
ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_CONGESTION);
ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_CONGESTION)
ast_channel_hangupcause_set
ast_channel_hangupcause_set
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
AST_CAUSE_CONGESTION
AST_CAUSE_CONGESTION
if (f.frametype == AST_FRAME_IAX) {			AST_SCHED_DEL(sched, iaxs[fr->callno]->initid);			/* Handle the IAX pseudo frame itself */			if (iaxdebug)				ast_debug(1, "IAX subclass %d received\n", f.subclass.integer);                        /* Update last ts unless the frame's timestamp originated with us. */			if (iaxs[fr->callno]->last < fr->ts &&                            f.subclass.integer != IAX_COMMAND_ACK &&                            f.subclass.integer != IAX_COMMAND_PONG &&                            f.subclass.integer != IAX_COMMAND_LAGRP) {				iaxs[fr->callno]->last = fr->ts;				if (iaxdebug)					ast_debug(1, "For call=%d, set last=%d\n", fr->callno, fr->ts);			}			iaxs[fr->callno]->last_iax_message = f.subclass.integer;			if (!iaxs[fr->callno]->first_iax_message) {				iaxs[fr->callno]->first_iax_message = f.subclass.integer;			}			switch(f.subclass.integer) {			case IAX_COMMAND_ACK:				/* Do nothing */				break;			case IAX_COMMAND_QUELCH:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {				        /* Generate Manager Hold event, if necessary*/					if (iaxs[fr->callno]->owner) {						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: On\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}					ast_set_flag64(iaxs[fr->callno], IAX_QUELCH);					if (ies.musiconhold) {						iax2_lock_owner(fr->callno);						if (!iaxs[fr->callno] || !iaxs[fr->callno]->owner) {							break;						}						if (ast_bridged_channel(iaxs[fr->callno]->owner)) {							const char *moh_suggest = iaxs[fr->callno]->mohsuggest;							/*							 * We already hold the owner lock so we do not							 * need to check iaxs[fr->callno] after it returns.							 */							iax2_queue_control_data(fr->callno, AST_CONTROL_HOLD, 								S_OR(moh_suggest, NULL),								!ast_strlen_zero(moh_suggest) ? strlen(moh_suggest) + 1 : 0);						}						ast_channel_unlock(iaxs[fr->callno]->owner);					}				}				break;			case IAX_COMMAND_UNQUELCH:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {					iax2_lock_owner(fr->callno);					if (!iaxs[fr->callno]) {						break;					}					/* Generate Manager Unhold event, if necessary */					if (iaxs[fr->callno]->owner && ast_test_flag64(iaxs[fr->callno], IAX_QUELCH)) {						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: Off\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}					ast_clear_flag64(iaxs[fr->callno], IAX_QUELCH);					if (!iaxs[fr->callno]->owner) {						break;					}					if (ast_bridged_channel(iaxs[fr->callno]->owner)) {						/*						 * We already hold the owner lock so we do not						 * need to check iaxs[fr->callno] after it returns.						 */						iax2_queue_control_data(fr->callno, AST_CONTROL_UNHOLD, NULL, 0);					}					ast_channel_unlock(iaxs[fr->callno]->owner);				}				break;			case IAX_COMMAND_TXACC:				if (iaxs[fr->callno]->transferring == TRANSFER_BEGIN) {					/* Ack the packet with the given timestamp */					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* Cancel any outstanding txcnt's */						if (cur->transfer) {							cur->retries = -1;						}					}					memset(&ied1, 0, sizeof(ied1));					iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->callno);					send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREADY, 0, ied1.buf, ied1.pos, -1);					iaxs[fr->callno]->transferring = TRANSFER_READY;				}				break;			case IAX_COMMAND_NEW:				/* Ignore if it's already up */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD))					break;				if (ies.provverpres && ies.serviceident && sin.sin_addr.s_addr) {					ast_mutex_unlock(&iaxsl[fr->callno]);					check_provisioning(&sin, fd, ies.serviceident, ies.provver);					ast_mutex_lock(&iaxsl[fr->callno]);					if (!iaxs[fr->callno]) {						break;					}				}				/* If we're in trunk mode, do it now, and update the trunk number in our frame before continuing */				if (ast_test_flag64(iaxs[fr->callno], IAX_TRUNK)) {					int new_callno;					if ((new_callno = make_trunk(fr->callno, 1)) != -1)						fr->callno = new_callno;				}				/* For security, always ack immediately */				if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				if (check_access(fr->callno, &sin, &ies)) {					/* They're not allowed on */					auth_fail(fr->callno, IAX_COMMAND_REJECT);					if (authdebug)						ast_log(LOG_NOTICE, "Rejected connect attempt from %s, who was trying to reach '%s@%s'\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					break;				}				if (ast_strlen_zero(iaxs[fr->callno]->secret) && ast_test_flag64(iaxs[fr->callno], IAX_FORCE_ENCRYPT)) {					auth_fail(fr->callno, IAX_COMMAND_REJECT);					ast_log(LOG_WARNING, "Rejected connect attempt.  No secret present while force encrypt enabled.\n");					break;				}				if (strcasecmp(iaxs[fr->callno]->exten, "TBD")) {					const char *context, *exten, *cid_num;					context = ast_strdupa(iaxs[fr->callno]->context);					exten = ast_strdupa(iaxs[fr->callno]->exten);					cid_num = ast_strdupa(iaxs[fr->callno]->cid_num);					/* This might re-enter the IAX code and need the lock */					ast_mutex_unlock(&iaxsl[fr->callno]);					exists = ast_exists_extension(NULL, context, exten, 1, cid_num);					ast_mutex_lock(&iaxsl[fr->callno]);					if (!iaxs[fr->callno]) {						break;					}				} else					exists = 0;				/* Get OSP token if it does exist */				save_osptoken(fr, &ies);				if (ast_strlen_zero(iaxs[fr->callno]->secret) && ast_strlen_zero(iaxs[fr->callno]->inkeys)) {					if (strcmp(iaxs[fr->callno]->exten, "TBD") && !exists) {						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}						if (authdebug)							ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					} else {						/* Select an appropriate format */						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								using_prefs = "reqonly";							} else {								using_prefs = "disabled";							}							format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;							memset(&pref, 0, sizeof(pref));							strcpy(caller_pref_buf, "disabled");							strcpy(host_pref_buf, "disabled");						} else {							struct ast_format tmpfmt;							using_prefs = "mine";							/* If the information elements are in here... use them */							if (ies.codec_prefs)								ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);							if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {								/* If we are codec_first_choice we let the caller have the 1st shot at picking the codec.*/								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {									pref = iaxs[fr->callno]->rprefs;									using_prefs = "caller";								} else {									pref = iaxs[fr->callno]->prefs;								}							} else								pref = iaxs[fr->callno]->prefs;							format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);							ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);							ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);						}						if (!format) {							if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP))								format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;							if (!format) {								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}								if (authdebug) {									char tmp[256], tmp2[256], tmp3[256];									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}							} else {								/* Pick one... */								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))										format = 0;								} else {									if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {										using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";										memset(&pref, 0, sizeof(pref));										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);										strcpy(caller_pref_buf,"disabled");										strcpy(host_pref_buf,"disabled");									} else {										struct ast_format tmpfmt;										using_prefs = "mine";										if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {											/* Do the opposite of what we tried above. */											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);										} else /* if no codec_prefs IE do it the old way */											format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}								}								if (!format) {									char tmp[256], tmp2[256], tmp3[256];									memset(&ied0, 0, sizeof(ied0));									iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");									iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);									ast_log(LOG_ERROR, "No best format in '%s'???\n", iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));									send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);									if (!iaxs[fr->callno]) {										break;									}									if (authdebug) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}									ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);									break;								}							}						}						if (format) {							/* No authentication required, let them in */							memset(&ied1, 0, sizeof(ied1));							iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);							iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);							send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);							if (strcmp(iaxs[fr->callno]->exten, "TBD")) {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);								ast_verb(3, "Accepting UNAUTHENTICATED call from %s:\n"												"%srequested format = %s,\n"												"%srequested prefs = %s,\n"												"%sactual format = %s,\n"												"%shost prefs = %s,\n"												"%spriority = %s\n",												ast_inet_ntoa(sin.sin_addr), 												VERBOSE_PREFIX_4,												iax2_getformatname(iaxs[fr->callno]->peerformat), 												VERBOSE_PREFIX_4,												caller_pref_buf,												VERBOSE_PREFIX_4,												iax2_getformatname(format), 												VERBOSE_PREFIX_4,												host_pref_buf, 												VERBOSE_PREFIX_4,												using_prefs);								iaxs[fr->callno]->chosenformat = format;								/* Since this is a new call, we should go ahead and set the callid for it. */								iax_pvt_callid_new(fr->callno);								ast_set_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);							} else {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);								/* If this is a TBD call, we're ready but now what...  */								ast_verb(3, "Accepted unauthenticated TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							}						}					}					break;				}				if (iaxs[fr->callno]->authmethods & IAX_AUTH_MD5)					merge_encryption(iaxs[fr->callno],ies.encmethods);				else					iaxs[fr->callno]->encmethods = 0;				if (!authenticate_request(fr->callno) && iaxs[fr->callno])					ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED);				break;			case IAX_COMMAND_DPREQ:				/* Request status in the dialplan */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD) &&					!ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED) && ies.called_number) {					if (iaxcompat) {						/* Spawn a thread for the lookup */						spawn_dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num);					} else {						/* Just look it up */						dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num, 1);					}				}				break;			case IAX_COMMAND_HANGUP:				ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);				ast_debug(1, "Immediately destroying %d, having received hangup\n", fr->callno);				/* Set hangup cause according to remote and hangupsource */				if (iaxs[fr->callno]->owner) {					set_hangup_source_and_cause(fr->callno, ies.causecode);					if (!iaxs[fr->callno]) {						break;					}				}				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_REJECT:				/* Set hangup cause according to remote and hangup source */				if (iaxs[fr->callno]->owner) {					set_hangup_source_and_cause(fr->callno, ies.causecode);					if (!iaxs[fr->callno]) {						break;					}				}				if (!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)) {					if (iaxs[fr->callno]->owner && authdebug)						ast_log(LOG_WARNING, "Call rejected by %s: %s\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr),							ies.cause ? ies.cause : "<Unknown>");					ast_debug(1, "Immediately destroying %d, having received reject\n",						fr->callno);				}				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK,						       fr->ts, NULL, 0, fr->iseqno);				if (!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION))					iaxs[fr->callno]->error = EPERM;				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_TRANSFER:			{				struct ast_channel *bridged_chan;				struct ast_channel *owner;				iax2_lock_owner(fr->callno);				if (!iaxs[fr->callno]) {					/* Initiating call went away before we could transfer. */					break;				}				owner = iaxs[fr->callno]->owner;				bridged_chan = owner ? ast_bridged_channel(owner) : NULL;				if (bridged_chan && ies.called_number) {					const char *context;					context = ast_strdupa(iaxs[fr->callno]->context);					ast_channel_ref(owner);					ast_channel_ref(bridged_chan);					ast_channel_unlock(owner);					ast_mutex_unlock(&iaxsl[fr->callno]);					/* Set BLINDTRANSFER channel variables */					pbx_builtin_setvar_helper(owner, "BLINDTRANSFER", ast_channel_name(bridged_chan));					pbx_builtin_setvar_helper(bridged_chan, "BLINDTRANSFER", ast_channel_name(owner));					/* DO NOT hold any locks while calling ast_parking_ext_valid() */					if (ast_parking_ext_valid(ies.called_number, owner, context)) {						ast_debug(1, "Parking call '%s'\n", ast_channel_name(bridged_chan));						if (iax_park(bridged_chan, owner, ies.called_number, context)) {							ast_log(LOG_WARNING, "Failed to park call '%s'\n",								ast_channel_name(bridged_chan));						}					} else {						if (ast_async_goto(bridged_chan, context, ies.called_number, 1)) {							ast_log(LOG_WARNING,								"Async goto of '%s' to '%s@%s' failed\n",								ast_channel_name(bridged_chan), ies.called_number, context);						} else {							ast_debug(1, "Async goto of '%s' to '%s@%s' started\n",								ast_channel_name(bridged_chan), ies.called_number, context);						}					}					ast_channel_unref(owner);					ast_channel_unref(bridged_chan);					ast_mutex_lock(&iaxsl[fr->callno]);				} else {					ast_debug(1, "Async goto not applicable on call %d\n", fr->callno);					if (owner) {						ast_channel_unlock(owner);					}				}				break;			}			case IAX_COMMAND_ACCEPT:				/* Ignore if call is already up or needs authentication or is a TBD */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD | IAX_STATE_AUTHENTICATED))					break;				if (ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)) {					/* Send ack immediately, before we destroy */					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					iax2_destroy(fr->callno);					break;				}				if (ies.format) {					iaxs[fr->callno]->peerformat = ies.format;				} else {					if (iaxs[fr->callno]->owner)						iaxs[fr->callno]->peerformat = ast_format_cap_to_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner));					else						iaxs[fr->callno]->peerformat = iaxs[fr->callno]->capability;				}				ast_verb(3, "Call accepted by %s (format %s)\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iax2_getformatname(iaxs[fr->callno]->peerformat));				if (!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)) {					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);					if (!iaxs[fr->callno]) {						break;					}					if (authdebug) {						char tmp1[256], tmp2[256];						ast_log(LOG_NOTICE, "Rejected call to %s, format %s incompatible with our capability %s.\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),							iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));					}				} else {					ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);					iax2_lock_owner(fr->callno);					if (iaxs[fr->callno] && iaxs[fr->callno]->owner) {						char tmp[256];						/* Switch us to use a compatible format */						ast_format_cap_from_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner), iaxs[fr->callno]->peerformat);						ast_verb(3, "Format for call is %s\n", ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(iaxs[fr->callno]->owner)));						/* Setup read/write formats properly. */						if (ast_channel_writeformat(iaxs[fr->callno]->owner)->id)							ast_set_write_format(iaxs[fr->callno]->owner, ast_channel_writeformat(iaxs[fr->callno]->owner));						if (ast_channel_readformat(iaxs[fr->callno]->owner)->id)							ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));						ast_channel_unlock(iaxs[fr->callno]->owner);					}				}				if (iaxs[fr->callno]) {					AST_LIST_LOCK(&dpcache);					AST_LIST_TRAVERSE(&iaxs[fr->callno]->dpentries, dp, peer_list)						if (!(dp->flags & CACHE_FLAG_TRANSMITTED))							iax2_dprequest(dp, fr->callno);					AST_LIST_UNLOCK(&dpcache);				}				break;			case IAX_COMMAND_POKE:				/* Send back a pong packet with the original timestamp */				send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, NULL, 0, -1);				break;			case IAX_COMMAND_PING:			{				struct iax_ie_data pingied;				construct_rr(iaxs[fr->callno], &pingied);				/* Send back a pong packet with the original timestamp */				send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, pingied.buf, pingied.pos, -1);			}				break;			case IAX_COMMAND_PONG:				/* Calculate ping time */				iaxs[fr->callno]->pingtime =  calc_timestamp(iaxs[fr->callno], 0, &f) - fr->ts;				/* save RR info */				save_rr(fr, &ies);				/* Good time to write jb stats for this call */				log_jitterstats(fr->callno);				if (iaxs[fr->callno]->peerpoke) {					peer = iaxs[fr->callno]->peerpoke;					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms)) {						if (iaxs[fr->callno]->pingtime <= peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now REACHABLE! Time: %d\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Reachable\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "IAX2/%s", peer->name); /* Activate notification */						}					} else if ((peer->historicms > 0) && (peer->historicms <= peer->maxms)) {						if (iaxs[fr->callno]->pingtime > peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now TOO LAGGED (%d ms)!\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Lagged\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_UNAVAILABLE, AST_DEVSTATE_CACHABLE, "IAX2/%s", peer->name); /* Activate notification */						}					}					peer->lastms = iaxs[fr->callno]->pingtime;					if (peer->smoothing && (peer->lastms > -1))						peer->historicms = (iaxs[fr->callno]->pingtime + peer->historicms) / 2;					else if (peer->smoothing && peer->lastms < 0)						peer->historicms = (0 + peer->historicms) / 2;					else											peer->historicms = iaxs[fr->callno]->pingtime;					/* Remove scheduled iax2_poke_noanswer */					if (peer->pokeexpire > -1) {						if (!AST_SCHED_DEL(sched, peer->pokeexpire)) {							peer_unref(peer);							peer->pokeexpire = -1;						}					}					/* Schedule the next cycle */					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms))						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_peer_s, peer_ref(peer));					else						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqok, iax2_poke_peer_s, peer_ref(peer));					if (peer->pokeexpire == -1)						peer_unref(peer);					/* and finally send the ack */					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					/* And wrap up the qualify call */					iax2_destroy(fr->callno);					peer->callno = 0;					ast_debug(1, "Peer %s: got pong, lastms %d, historicms %d, maxms %d\n", peer->name, peer->lastms, peer->historicms, peer->maxms);				}				break;			case IAX_COMMAND_LAGRQ:			case IAX_COMMAND_LAGRP:				f.src = "LAGRQ";				f.mallocd = 0;				f.offset = 0;				f.samples = 0;				iax_frame_wrap(fr, &f);				if (f.subclass.integer == IAX_COMMAND_LAGRQ) {					/* Received a LAGRQ - echo back a LAGRP */					fr->af.subclass.integer = IAX_COMMAND_LAGRP;					iax2_send(iaxs[fr->callno], &fr->af, fr->ts, -1, 0, 0, 0);				} else {					/* Received LAGRP in response to our LAGRQ */					unsigned int ts;					/* This is a reply we've been given, actually measure the difference */					ts = calc_timestamp(iaxs[fr->callno], 0, &fr->af);					iaxs[fr->callno]->lag = ts - fr->ts;					if (iaxdebug)						ast_debug(1, "Peer %s lag measured as %dms\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->lag);				}				break;			case IAX_COMMAND_AUTHREQ:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)) {					ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					break;				}				if (authenticate_reply(iaxs[fr->callno], &iaxs[fr->callno]->addr, &ies, iaxs[fr->callno]->secret, iaxs[fr->callno]->outkey)) {					struct ast_frame hangup_fr = { .frametype = AST_FRAME_CONTROL,								.subclass.integer = AST_CONTROL_HANGUP,					};					ast_log(LOG_WARNING, 						"I don't know how to authenticate %s to %s\n", 						ies.username ? ies.username : "<unknown>", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr));					iax2_queue_frame(fr->callno, &hangup_fr);				}				break;			case IAX_COMMAND_AUTHREP:				/* For security, always ack immediately */				if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				/* Ignore once we've started */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)) {					ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					break;				}				if (authenticate_verify(iaxs[fr->callno], &ies)) {					if (authdebug)						ast_log(LOG_NOTICE, "Host %s failed to authenticate as %s\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->username);					memset(&ied0, 0, sizeof(ied0));					auth_fail(fr->callno, IAX_COMMAND_REJECT);					break;				}				if (strcasecmp(iaxs[fr->callno]->exten, "TBD")) {					/* This might re-enter the IAX code and need the lock */					exists = ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num);				} else					exists = 0;				if (strcmp(iaxs[fr->callno]->exten, "TBD") && !exists) {					if (authdebug)						ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);					if (!iaxs[fr->callno]) {						break;					}				} else {					/* Select an appropriate format */					if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {							using_prefs = "reqonly";						} else {							using_prefs = "disabled";						}						format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;						memset(&pref, 0, sizeof(pref));						strcpy(caller_pref_buf, "disabled");						strcpy(host_pref_buf, "disabled");					} else {						struct ast_format tmpfmt;						using_prefs = "mine";						if (ies.codec_prefs)							ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);						if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {							if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {								pref = iaxs[fr->callno]->rprefs;								using_prefs = "caller";							} else {								pref = iaxs[fr->callno]->prefs;							}						} else /* if no codec_prefs IE do it the old way */							pref = iaxs[fr->callno]->prefs;						format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);						ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);						ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);					}					if (!format) {						char tmp1[256], tmp2[256], tmp3[256];						if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {							ast_debug(1, "We don't do requested format %s, falling back to peer capability '%s'\n",								iax2_getformatname(iaxs[fr->callno]->peerformat),								iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability));							format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;						}						if (!format) {							if (authdebug) {								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n", ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));								} else {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",										ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),										iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));								}							}							memset(&ied0, 0, sizeof(ied0));							iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");							iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);							send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);							if (!iaxs[fr->callno]) {								break;							}						} else {							/* Pick one... */							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))									format = 0;							} else {								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {									using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";									memset(&pref, 0, sizeof(pref));									format = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ?										iaxs[fr->callno]->peerformat : iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									strcpy(caller_pref_buf,"disabled");									strcpy(host_pref_buf,"disabled");								} else {									struct ast_format tmpfmt;									using_prefs = "mine";									if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {										/* Do the opposite of what we tried above. */										if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {											pref = iaxs[fr->callno]->prefs;										} else {											pref = iaxs[fr->callno]->rprefs;											using_prefs = "caller";										}										format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);									} else /* if no codec_prefs IE do it the old way */										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}							}							if (!format) {								char tmp1[256], tmp2[256], tmp3[256];								ast_log(LOG_ERROR, "No best format in %s???\n",									iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));								if (authdebug) {									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}							}						}					}					if (format) {						/* Authentication received */						memset(&ied1, 0, sizeof(ied1));						iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);						iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);						send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);						if (strcmp(iaxs[fr->callno]->exten, "TBD")) {							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							ast_verb(3, "Accepting AUTHENTICATED call from %s:\n"											"%srequested format = %s,\n"											"%srequested prefs = %s,\n"											"%sactual format = %s,\n"											"%shost prefs = %s,\n"											"%spriority = %s\n", 											ast_inet_ntoa(sin.sin_addr), 											VERBOSE_PREFIX_4,											iax2_getformatname(iaxs[fr->callno]->peerformat),											VERBOSE_PREFIX_4,											caller_pref_buf,											VERBOSE_PREFIX_4,											iax2_getformatname(format),											VERBOSE_PREFIX_4,											host_pref_buf,											VERBOSE_PREFIX_4,											using_prefs);							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, format, NULL, 1)))								iax2_destroy(fr->callno);							else if (ies.vars) {								struct ast_datastore *variablestore;								struct ast_variable *var, *prev = NULL;								AST_LIST_HEAD(, ast_var_t) *varlist;								varlist = ast_calloc(1, sizeof(*varlist));								variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);								if (variablestore && varlist) {									variablestore->data = varlist;									variablestore->inheritance = DATASTORE_INHERIT_FOREVER;									AST_LIST_HEAD_INIT(varlist);									ast_debug(1, "I can haz IAX vars? w00t\n");									for (var = ies.vars; var; var = var->next) {										struct ast_var_t *newvar = ast_var_assign(var->name, var->value);										if (prev)											ast_free(prev);										prev = var;										if (!newvar) {											/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */											ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");										} else {											AST_LIST_INSERT_TAIL(varlist, newvar, entries);										}									}									if (prev)										ast_free(prev);									ies.vars = NULL;									ast_channel_datastore_add(c, variablestore);								} else {									ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									if (variablestore)										ast_datastore_free(variablestore);									if (varlist)										ast_free(varlist);								}							}						} else {							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);							/* If this is a TBD call, we're ready but now what...  */							ast_verb(3, "Accepted AUTHENTICATED TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							if (ast_test_flag64(iaxs[fr->callno], IAX_IMMEDIATE)) {								goto immediatedial;							}						}					}				}				break;			case IAX_COMMAND_DIAL:immediatedial:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD)) {					ast_clear_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);					ast_string_field_set(iaxs[fr->callno], exten, ies.called_number ? ies.called_number : "s");					if (!ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num)) {						if (authdebug)							ast_log(LOG_NOTICE, "Rejected dial attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}					} else {						char tmp[256];						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);						ast_verb(3, "Accepting DIAL from %s, formats = %s\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat));						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);						send_command(iaxs[fr->callno], AST_FRAME_CONTROL, AST_CONTROL_PROGRESS, 0, NULL, 0, -1);						if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->peerformat, NULL, 1)))							iax2_destroy(fr->callno);						else if (ies.vars) {							struct ast_datastore *variablestore;							struct ast_variable *var, *prev = NULL;							AST_LIST_HEAD(, ast_var_t) *varlist;							varlist = ast_calloc(1, sizeof(*varlist));							variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);							ast_debug(1, "I can haz IAX vars? w00t\n");							if (variablestore && varlist) {								variablestore->data = varlist;								variablestore->inheritance = DATASTORE_INHERIT_FOREVER;								AST_LIST_HEAD_INIT(varlist);								for (var = ies.vars; var; var = var->next) {									struct ast_var_t *newvar = ast_var_assign(var->name, var->value);									if (prev)										ast_free(prev);									prev = var;									if (!newvar) {										/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */										ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									} else {										AST_LIST_INSERT_TAIL(varlist, newvar, entries);									}								}								if (prev)									ast_free(prev);								ies.vars = NULL;								ast_channel_datastore_add(c, variablestore);							} else {								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");								if (variablestore)									ast_datastore_free(variablestore);								if (varlist)									ast_free(varlist);							}						}					}				}				break;			case IAX_COMMAND_INVAL:				iaxs[fr->callno]->error = ENOTCONN;				ast_debug(1, "Immediately destroying %d, having received INVAL\n", fr->callno);				iax2_destroy(fr->callno);				ast_debug(1, "Destroying call %d\n", fr->callno);				break;			case IAX_COMMAND_VNAK:				ast_debug(1, "Received VNAK: resending outstanding frames\n");				/* Force retransmission */				vnak_retransmit(fr->callno, fr->iseqno);				break;			case IAX_COMMAND_REGREQ:			case IAX_COMMAND_REGREL:				/* For security, always ack immediately */				if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				if (register_verify(fr->callno, &sin, &ies)) {					if (!iaxs[fr->callno]) {						break;					}					/* Send delayed failure */					auth_fail(fr->callno, IAX_COMMAND_REGREJ);					break;				}				if (!iaxs[fr->callno]) {					break;				}				if ((ast_strlen_zero(iaxs[fr->callno]->secret) && ast_strlen_zero(iaxs[fr->callno]->inkeys)) ||						ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED)) {					if (f.subclass.integer == IAX_COMMAND_REGREL) {						memset(&sin, 0, sizeof(sin));						sin.sin_family = AF_INET;					}					if (update_registry(&sin, fr->callno, ies.devicetype, fd, ies.refresh)) {						ast_log(LOG_WARNING, "Registry error\n");					}					if (!iaxs[fr->callno]) {						break;					}					if (ies.provverpres && ies.serviceident && sin.sin_addr.s_addr) {						ast_mutex_unlock(&iaxsl[fr->callno]);						check_provisioning(&sin, fd, ies.serviceident, ies.provver);						ast_mutex_lock(&iaxsl[fr->callno]);					}					break;				}				registry_authrequest(fr->callno);				break;			case IAX_COMMAND_REGACK:				if (iax2_ack_registry(&ies, &sin, fr->callno)) 					ast_log(LOG_WARNING, "Registration failure\n");				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_REGREJ:				if (iaxs[fr->callno]->reg) {					if (authdebug) {						ast_log(LOG_NOTICE, "Registration of '%s' rejected: '%s' from: '%s'\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>", ast_inet_ntoa(sin.sin_addr));						manager_event(EVENT_FLAG_SYSTEM, "Registry", "ChannelType: IAX2\r\nUsername: %s\r\nStatus: Rejected\r\nCause: %s\r\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>");					}					iaxs[fr->callno]->reg->regstate = REG_STATE_REJECTED;				}				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_REGAUTH:				/* Authentication request */				if (registry_rerequest(&ies, fr->callno, &sin)) {					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No authority found");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_FACILITY_NOT_SUBSCRIBED);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);				}				break;			case IAX_COMMAND_TXREJ:				iaxs[fr->callno]->transferring = 0;				ast_verb(3, "Channel '%s' unable to transfer\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");				memset(&iaxs[fr->callno]->transfer, 0, sizeof(iaxs[fr->callno]->transfer));				if (iaxs[fr->callno]->bridgecallno) {					if (iaxs[iaxs[fr->callno]->bridgecallno]->transferring) {						iaxs[iaxs[fr->callno]->bridgecallno]->transferring = 0;						send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREJ, 0, NULL, 0, -1);					}				}				break;			case IAX_COMMAND_TXREADY:				if ((iaxs[fr->callno]->transferring == TRANSFER_BEGIN) ||				    (iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)) {					if (iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)						iaxs[fr->callno]->transferring = TRANSFER_MREADY;					else						iaxs[fr->callno]->transferring = TRANSFER_READY;					ast_verb(3, "Channel '%s' ready to transfer\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					if (iaxs[fr->callno]->bridgecallno) {						if ((iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_READY) ||						    (iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_MREADY)) {							/* They're both ready, now release them. */							if (iaxs[fr->callno]->transferring == TRANSFER_MREADY) {								ast_verb(3, "Attempting media bridge of %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_MEDIA;								iaxs[fr->callno]->transferring = TRANSFER_MEDIA;								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied1.buf, ied1.pos, -1);							} else {								ast_verb(3, "Releasing %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_RELEASED;								iaxs[fr->callno]->transferring = TRANSFER_RELEASED;								ast_set_flag64(iaxs[iaxs[fr->callno]->bridgecallno], IAX_ALREADYGONE);								ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);								/* Stop doing lag & ping requests */								stop_stuff(fr->callno);								stop_stuff(iaxs[fr->callno]->bridgecallno);								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied1.buf, ied1.pos, -1);							}						}					}				}				break;			case IAX_COMMAND_TXREQ:				try_transfer(iaxs[fr->callno], &ies);				break;			case IAX_COMMAND_TXCNT:				if (iaxs[fr->callno]->transferring)					send_command_transfer(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXACC, 0, NULL, 0);				break;			case IAX_COMMAND_TXREL:				/* Send ack immediately, rather than waiting until we've changed addresses */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				complete_transfer(fr->callno, &ies);				stop_stuff(fr->callno);	/* for attended transfer to work with libiax */				break;				case IAX_COMMAND_TXMEDIA:				if (iaxs[fr->callno]->transferring == TRANSFER_READY) {					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* Cancel any outstanding frames and start anew */						if (cur->transfer) {							cur->retries = -1;						}					}					/* Start sending our media to the transfer address, but otherwise leave the call as-is */					iaxs[fr->callno]->transferring = TRANSFER_MEDIAPASS;				}				break;			case IAX_COMMAND_RTKEY:				if (!IAX_CALLENCRYPTED(iaxs[fr->callno])) {					ast_log(LOG_WARNING, 						"we've been told to rotate our encryption key, "						"but this isn't an encrypted call. bad things will happen.\n"					);					break;				}				IAX_DEBUGDIGEST("Receiving", ies.challenge);				ast_aes_set_decrypt_key((unsigned char *) ies.challenge, &iaxs[fr->callno]->dcx);				break;			case IAX_COMMAND_DPREP:				complete_dpreply(iaxs[fr->callno], &ies);				break;			case IAX_COMMAND_UNSUPPORT:				ast_log(LOG_NOTICE, "Peer did not understand our iax command '%d'\n", ies.iax_unknown);				break;			case IAX_COMMAND_FWDOWNL:				/* Firmware download */				if (!ast_test_flag64(&globalflags, IAX_ALLOWFWDOWNLOAD)) {					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_UNSUPPORT, 0, NULL, 0, -1);					break;				}				memset(&ied0, 0, sizeof(ied0));				res = iax_firmware_append(&ied0, (unsigned char *)ies.devicetype, ies.fwdesc);				if (res < 0)					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);				else if (res > 0)					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1);				else					send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1);				break;			case IAX_COMMAND_CALLTOKEN:			{				struct iax_frame *cur;				/* find last sent frame */				if ((cur = AST_LIST_LAST(&frame_queue[fr->callno])) && ies.calltoken && ies.calltokendata) {					resend_with_token(fr->callno, cur, (char *) ies.calltokendata);				}				break;			}			default:				ast_debug(1, "Unknown IAX command %d on %d/%d\n", f.subclass.integer, fr->callno, iaxs[fr->callno]->peercallno);				memset(&ied0, 0, sizeof(ied0));				iax_ie_append_byte(&ied0, IAX_IE_IAX_UNKNOWN, f.subclass.integer);				send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_UNSUPPORT, 0, ied0.buf, ied0.pos, -1);			}
f.frametype == AST_FRAME_IAX
f.frametype
f
f
frametype
AST_FRAME_IAX
AST_FRAME_IAX
{			AST_SCHED_DEL(sched, iaxs[fr->callno]->initid);			/* Handle the IAX pseudo frame itself */			if (iaxdebug)				ast_debug(1, "IAX subclass %d received\n", f.subclass.integer);                        /* Update last ts unless the frame's timestamp originated with us. */			if (iaxs[fr->callno]->last < fr->ts &&                            f.subclass.integer != IAX_COMMAND_ACK &&                            f.subclass.integer != IAX_COMMAND_PONG &&                            f.subclass.integer != IAX_COMMAND_LAGRP) {				iaxs[fr->callno]->last = fr->ts;				if (iaxdebug)					ast_debug(1, "For call=%d, set last=%d\n", fr->callno, fr->ts);			}			iaxs[fr->callno]->last_iax_message = f.subclass.integer;			if (!iaxs[fr->callno]->first_iax_message) {				iaxs[fr->callno]->first_iax_message = f.subclass.integer;			}			switch(f.subclass.integer) {			case IAX_COMMAND_ACK:				/* Do nothing */				break;			case IAX_COMMAND_QUELCH:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {				        /* Generate Manager Hold event, if necessary*/					if (iaxs[fr->callno]->owner) {						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: On\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}					ast_set_flag64(iaxs[fr->callno], IAX_QUELCH);					if (ies.musiconhold) {						iax2_lock_owner(fr->callno);						if (!iaxs[fr->callno] || !iaxs[fr->callno]->owner) {							break;						}						if (ast_bridged_channel(iaxs[fr->callno]->owner)) {							const char *moh_suggest = iaxs[fr->callno]->mohsuggest;							/*							 * We already hold the owner lock so we do not							 * need to check iaxs[fr->callno] after it returns.							 */							iax2_queue_control_data(fr->callno, AST_CONTROL_HOLD, 								S_OR(moh_suggest, NULL),								!ast_strlen_zero(moh_suggest) ? strlen(moh_suggest) + 1 : 0);						}						ast_channel_unlock(iaxs[fr->callno]->owner);					}				}				break;			case IAX_COMMAND_UNQUELCH:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {					iax2_lock_owner(fr->callno);					if (!iaxs[fr->callno]) {						break;					}					/* Generate Manager Unhold event, if necessary */					if (iaxs[fr->callno]->owner && ast_test_flag64(iaxs[fr->callno], IAX_QUELCH)) {						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: Off\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}					ast_clear_flag64(iaxs[fr->callno], IAX_QUELCH);					if (!iaxs[fr->callno]->owner) {						break;					}					if (ast_bridged_channel(iaxs[fr->callno]->owner)) {						/*						 * We already hold the owner lock so we do not						 * need to check iaxs[fr->callno] after it returns.						 */						iax2_queue_control_data(fr->callno, AST_CONTROL_UNHOLD, NULL, 0);					}					ast_channel_unlock(iaxs[fr->callno]->owner);				}				break;			case IAX_COMMAND_TXACC:				if (iaxs[fr->callno]->transferring == TRANSFER_BEGIN) {					/* Ack the packet with the given timestamp */					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* Cancel any outstanding txcnt's */						if (cur->transfer) {							cur->retries = -1;						}					}					memset(&ied1, 0, sizeof(ied1));					iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->callno);					send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREADY, 0, ied1.buf, ied1.pos, -1);					iaxs[fr->callno]->transferring = TRANSFER_READY;				}				break;			case IAX_COMMAND_NEW:				/* Ignore if it's already up */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD))					break;				if (ies.provverpres && ies.serviceident && sin.sin_addr.s_addr) {					ast_mutex_unlock(&iaxsl[fr->callno]);					check_provisioning(&sin, fd, ies.serviceident, ies.provver);					ast_mutex_lock(&iaxsl[fr->callno]);					if (!iaxs[fr->callno]) {						break;					}				}				/* If we're in trunk mode, do it now, and update the trunk number in our frame before continuing */				if (ast_test_flag64(iaxs[fr->callno], IAX_TRUNK)) {					int new_callno;					if ((new_callno = make_trunk(fr->callno, 1)) != -1)						fr->callno = new_callno;				}				/* For security, always ack immediately */				if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				if (check_access(fr->callno, &sin, &ies)) {					/* They're not allowed on */					auth_fail(fr->callno, IAX_COMMAND_REJECT);					if (authdebug)						ast_log(LOG_NOTICE, "Rejected connect attempt from %s, who was trying to reach '%s@%s'\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					break;				}				if (ast_strlen_zero(iaxs[fr->callno]->secret) && ast_test_flag64(iaxs[fr->callno], IAX_FORCE_ENCRYPT)) {					auth_fail(fr->callno, IAX_COMMAND_REJECT);					ast_log(LOG_WARNING, "Rejected connect attempt.  No secret present while force encrypt enabled.\n");					break;				}				if (strcasecmp(iaxs[fr->callno]->exten, "TBD")) {					const char *context, *exten, *cid_num;					context = ast_strdupa(iaxs[fr->callno]->context);					exten = ast_strdupa(iaxs[fr->callno]->exten);					cid_num = ast_strdupa(iaxs[fr->callno]->cid_num);					/* This might re-enter the IAX code and need the lock */					ast_mutex_unlock(&iaxsl[fr->callno]);					exists = ast_exists_extension(NULL, context, exten, 1, cid_num);					ast_mutex_lock(&iaxsl[fr->callno]);					if (!iaxs[fr->callno]) {						break;					}				} else					exists = 0;				/* Get OSP token if it does exist */				save_osptoken(fr, &ies);				if (ast_strlen_zero(iaxs[fr->callno]->secret) && ast_strlen_zero(iaxs[fr->callno]->inkeys)) {					if (strcmp(iaxs[fr->callno]->exten, "TBD") && !exists) {						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}						if (authdebug)							ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					} else {						/* Select an appropriate format */						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								using_prefs = "reqonly";							} else {								using_prefs = "disabled";							}							format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;							memset(&pref, 0, sizeof(pref));							strcpy(caller_pref_buf, "disabled");							strcpy(host_pref_buf, "disabled");						} else {							struct ast_format tmpfmt;							using_prefs = "mine";							/* If the information elements are in here... use them */							if (ies.codec_prefs)								ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);							if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {								/* If we are codec_first_choice we let the caller have the 1st shot at picking the codec.*/								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {									pref = iaxs[fr->callno]->rprefs;									using_prefs = "caller";								} else {									pref = iaxs[fr->callno]->prefs;								}							} else								pref = iaxs[fr->callno]->prefs;							format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);							ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);							ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);						}						if (!format) {							if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP))								format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;							if (!format) {								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}								if (authdebug) {									char tmp[256], tmp2[256], tmp3[256];									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}							} else {								/* Pick one... */								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))										format = 0;								} else {									if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {										using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";										memset(&pref, 0, sizeof(pref));										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);										strcpy(caller_pref_buf,"disabled");										strcpy(host_pref_buf,"disabled");									} else {										struct ast_format tmpfmt;										using_prefs = "mine";										if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {											/* Do the opposite of what we tried above. */											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);										} else /* if no codec_prefs IE do it the old way */											format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}								}								if (!format) {									char tmp[256], tmp2[256], tmp3[256];									memset(&ied0, 0, sizeof(ied0));									iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");									iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);									ast_log(LOG_ERROR, "No best format in '%s'???\n", iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));									send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);									if (!iaxs[fr->callno]) {										break;									}									if (authdebug) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}									ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);									break;								}							}						}						if (format) {							/* No authentication required, let them in */							memset(&ied1, 0, sizeof(ied1));							iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);							iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);							send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);							if (strcmp(iaxs[fr->callno]->exten, "TBD")) {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);								ast_verb(3, "Accepting UNAUTHENTICATED call from %s:\n"												"%srequested format = %s,\n"												"%srequested prefs = %s,\n"												"%sactual format = %s,\n"												"%shost prefs = %s,\n"												"%spriority = %s\n",												ast_inet_ntoa(sin.sin_addr), 												VERBOSE_PREFIX_4,												iax2_getformatname(iaxs[fr->callno]->peerformat), 												VERBOSE_PREFIX_4,												caller_pref_buf,												VERBOSE_PREFIX_4,												iax2_getformatname(format), 												VERBOSE_PREFIX_4,												host_pref_buf, 												VERBOSE_PREFIX_4,												using_prefs);								iaxs[fr->callno]->chosenformat = format;								/* Since this is a new call, we should go ahead and set the callid for it. */								iax_pvt_callid_new(fr->callno);								ast_set_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);							} else {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);								/* If this is a TBD call, we're ready but now what...  */								ast_verb(3, "Accepted unauthenticated TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							}						}					}					break;				}				if (iaxs[fr->callno]->authmethods & IAX_AUTH_MD5)					merge_encryption(iaxs[fr->callno],ies.encmethods);				else					iaxs[fr->callno]->encmethods = 0;				if (!authenticate_request(fr->callno) && iaxs[fr->callno])					ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED);				break;			case IAX_COMMAND_DPREQ:				/* Request status in the dialplan */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD) &&					!ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED) && ies.called_number) {					if (iaxcompat) {						/* Spawn a thread for the lookup */						spawn_dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num);					} else {						/* Just look it up */						dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num, 1);					}				}				break;			case IAX_COMMAND_HANGUP:				ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);				ast_debug(1, "Immediately destroying %d, having received hangup\n", fr->callno);				/* Set hangup cause according to remote and hangupsource */				if (iaxs[fr->callno]->owner) {					set_hangup_source_and_cause(fr->callno, ies.causecode);					if (!iaxs[fr->callno]) {						break;					}				}				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_REJECT:				/* Set hangup cause according to remote and hangup source */				if (iaxs[fr->callno]->owner) {					set_hangup_source_and_cause(fr->callno, ies.causecode);					if (!iaxs[fr->callno]) {						break;					}				}				if (!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)) {					if (iaxs[fr->callno]->owner && authdebug)						ast_log(LOG_WARNING, "Call rejected by %s: %s\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr),							ies.cause ? ies.cause : "<Unknown>");					ast_debug(1, "Immediately destroying %d, having received reject\n",						fr->callno);				}				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK,						       fr->ts, NULL, 0, fr->iseqno);				if (!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION))					iaxs[fr->callno]->error = EPERM;				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_TRANSFER:			{				struct ast_channel *bridged_chan;				struct ast_channel *owner;				iax2_lock_owner(fr->callno);				if (!iaxs[fr->callno]) {					/* Initiating call went away before we could transfer. */					break;				}				owner = iaxs[fr->callno]->owner;				bridged_chan = owner ? ast_bridged_channel(owner) : NULL;				if (bridged_chan && ies.called_number) {					const char *context;					context = ast_strdupa(iaxs[fr->callno]->context);					ast_channel_ref(owner);					ast_channel_ref(bridged_chan);					ast_channel_unlock(owner);					ast_mutex_unlock(&iaxsl[fr->callno]);					/* Set BLINDTRANSFER channel variables */					pbx_builtin_setvar_helper(owner, "BLINDTRANSFER", ast_channel_name(bridged_chan));					pbx_builtin_setvar_helper(bridged_chan, "BLINDTRANSFER", ast_channel_name(owner));					/* DO NOT hold any locks while calling ast_parking_ext_valid() */					if (ast_parking_ext_valid(ies.called_number, owner, context)) {						ast_debug(1, "Parking call '%s'\n", ast_channel_name(bridged_chan));						if (iax_park(bridged_chan, owner, ies.called_number, context)) {							ast_log(LOG_WARNING, "Failed to park call '%s'\n",								ast_channel_name(bridged_chan));						}					} else {						if (ast_async_goto(bridged_chan, context, ies.called_number, 1)) {							ast_log(LOG_WARNING,								"Async goto of '%s' to '%s@%s' failed\n",								ast_channel_name(bridged_chan), ies.called_number, context);						} else {							ast_debug(1, "Async goto of '%s' to '%s@%s' started\n",								ast_channel_name(bridged_chan), ies.called_number, context);						}					}					ast_channel_unref(owner);					ast_channel_unref(bridged_chan);					ast_mutex_lock(&iaxsl[fr->callno]);				} else {					ast_debug(1, "Async goto not applicable on call %d\n", fr->callno);					if (owner) {						ast_channel_unlock(owner);					}				}				break;			}			case IAX_COMMAND_ACCEPT:				/* Ignore if call is already up or needs authentication or is a TBD */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD | IAX_STATE_AUTHENTICATED))					break;				if (ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)) {					/* Send ack immediately, before we destroy */					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					iax2_destroy(fr->callno);					break;				}				if (ies.format) {					iaxs[fr->callno]->peerformat = ies.format;				} else {					if (iaxs[fr->callno]->owner)						iaxs[fr->callno]->peerformat = ast_format_cap_to_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner));					else						iaxs[fr->callno]->peerformat = iaxs[fr->callno]->capability;				}				ast_verb(3, "Call accepted by %s (format %s)\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iax2_getformatname(iaxs[fr->callno]->peerformat));				if (!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)) {					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);					if (!iaxs[fr->callno]) {						break;					}					if (authdebug) {						char tmp1[256], tmp2[256];						ast_log(LOG_NOTICE, "Rejected call to %s, format %s incompatible with our capability %s.\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),							iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));					}				} else {					ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);					iax2_lock_owner(fr->callno);					if (iaxs[fr->callno] && iaxs[fr->callno]->owner) {						char tmp[256];						/* Switch us to use a compatible format */						ast_format_cap_from_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner), iaxs[fr->callno]->peerformat);						ast_verb(3, "Format for call is %s\n", ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(iaxs[fr->callno]->owner)));						/* Setup read/write formats properly. */						if (ast_channel_writeformat(iaxs[fr->callno]->owner)->id)							ast_set_write_format(iaxs[fr->callno]->owner, ast_channel_writeformat(iaxs[fr->callno]->owner));						if (ast_channel_readformat(iaxs[fr->callno]->owner)->id)							ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));						ast_channel_unlock(iaxs[fr->callno]->owner);					}				}				if (iaxs[fr->callno]) {					AST_LIST_LOCK(&dpcache);					AST_LIST_TRAVERSE(&iaxs[fr->callno]->dpentries, dp, peer_list)						if (!(dp->flags & CACHE_FLAG_TRANSMITTED))							iax2_dprequest(dp, fr->callno);					AST_LIST_UNLOCK(&dpcache);				}				break;			case IAX_COMMAND_POKE:				/* Send back a pong packet with the original timestamp */				send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, NULL, 0, -1);				break;			case IAX_COMMAND_PING:			{				struct iax_ie_data pingied;				construct_rr(iaxs[fr->callno], &pingied);				/* Send back a pong packet with the original timestamp */				send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, pingied.buf, pingied.pos, -1);			}				break;			case IAX_COMMAND_PONG:				/* Calculate ping time */				iaxs[fr->callno]->pingtime =  calc_timestamp(iaxs[fr->callno], 0, &f) - fr->ts;				/* save RR info */				save_rr(fr, &ies);				/* Good time to write jb stats for this call */				log_jitterstats(fr->callno);				if (iaxs[fr->callno]->peerpoke) {					peer = iaxs[fr->callno]->peerpoke;					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms)) {						if (iaxs[fr->callno]->pingtime <= peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now REACHABLE! Time: %d\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Reachable\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "IAX2/%s", peer->name); /* Activate notification */						}					} else if ((peer->historicms > 0) && (peer->historicms <= peer->maxms)) {						if (iaxs[fr->callno]->pingtime > peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now TOO LAGGED (%d ms)!\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Lagged\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_UNAVAILABLE, AST_DEVSTATE_CACHABLE, "IAX2/%s", peer->name); /* Activate notification */						}					}					peer->lastms = iaxs[fr->callno]->pingtime;					if (peer->smoothing && (peer->lastms > -1))						peer->historicms = (iaxs[fr->callno]->pingtime + peer->historicms) / 2;					else if (peer->smoothing && peer->lastms < 0)						peer->historicms = (0 + peer->historicms) / 2;					else											peer->historicms = iaxs[fr->callno]->pingtime;					/* Remove scheduled iax2_poke_noanswer */					if (peer->pokeexpire > -1) {						if (!AST_SCHED_DEL(sched, peer->pokeexpire)) {							peer_unref(peer);							peer->pokeexpire = -1;						}					}					/* Schedule the next cycle */					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms))						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_peer_s, peer_ref(peer));					else						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqok, iax2_poke_peer_s, peer_ref(peer));					if (peer->pokeexpire == -1)						peer_unref(peer);					/* and finally send the ack */					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					/* And wrap up the qualify call */					iax2_destroy(fr->callno);					peer->callno = 0;					ast_debug(1, "Peer %s: got pong, lastms %d, historicms %d, maxms %d\n", peer->name, peer->lastms, peer->historicms, peer->maxms);				}				break;			case IAX_COMMAND_LAGRQ:			case IAX_COMMAND_LAGRP:				f.src = "LAGRQ";				f.mallocd = 0;				f.offset = 0;				f.samples = 0;				iax_frame_wrap(fr, &f);				if (f.subclass.integer == IAX_COMMAND_LAGRQ) {					/* Received a LAGRQ - echo back a LAGRP */					fr->af.subclass.integer = IAX_COMMAND_LAGRP;					iax2_send(iaxs[fr->callno], &fr->af, fr->ts, -1, 0, 0, 0);				} else {					/* Received LAGRP in response to our LAGRQ */					unsigned int ts;					/* This is a reply we've been given, actually measure the difference */					ts = calc_timestamp(iaxs[fr->callno], 0, &fr->af);					iaxs[fr->callno]->lag = ts - fr->ts;					if (iaxdebug)						ast_debug(1, "Peer %s lag measured as %dms\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->lag);				}				break;			case IAX_COMMAND_AUTHREQ:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)) {					ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					break;				}				if (authenticate_reply(iaxs[fr->callno], &iaxs[fr->callno]->addr, &ies, iaxs[fr->callno]->secret, iaxs[fr->callno]->outkey)) {					struct ast_frame hangup_fr = { .frametype = AST_FRAME_CONTROL,								.subclass.integer = AST_CONTROL_HANGUP,					};					ast_log(LOG_WARNING, 						"I don't know how to authenticate %s to %s\n", 						ies.username ? ies.username : "<unknown>", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr));					iax2_queue_frame(fr->callno, &hangup_fr);				}				break;			case IAX_COMMAND_AUTHREP:				/* For security, always ack immediately */				if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				/* Ignore once we've started */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)) {					ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					break;				}				if (authenticate_verify(iaxs[fr->callno], &ies)) {					if (authdebug)						ast_log(LOG_NOTICE, "Host %s failed to authenticate as %s\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->username);					memset(&ied0, 0, sizeof(ied0));					auth_fail(fr->callno, IAX_COMMAND_REJECT);					break;				}				if (strcasecmp(iaxs[fr->callno]->exten, "TBD")) {					/* This might re-enter the IAX code and need the lock */					exists = ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num);				} else					exists = 0;				if (strcmp(iaxs[fr->callno]->exten, "TBD") && !exists) {					if (authdebug)						ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);					if (!iaxs[fr->callno]) {						break;					}				} else {					/* Select an appropriate format */					if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {							using_prefs = "reqonly";						} else {							using_prefs = "disabled";						}						format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;						memset(&pref, 0, sizeof(pref));						strcpy(caller_pref_buf, "disabled");						strcpy(host_pref_buf, "disabled");					} else {						struct ast_format tmpfmt;						using_prefs = "mine";						if (ies.codec_prefs)							ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);						if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {							if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {								pref = iaxs[fr->callno]->rprefs;								using_prefs = "caller";							} else {								pref = iaxs[fr->callno]->prefs;							}						} else /* if no codec_prefs IE do it the old way */							pref = iaxs[fr->callno]->prefs;						format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);						ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);						ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);					}					if (!format) {						char tmp1[256], tmp2[256], tmp3[256];						if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {							ast_debug(1, "We don't do requested format %s, falling back to peer capability '%s'\n",								iax2_getformatname(iaxs[fr->callno]->peerformat),								iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability));							format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;						}						if (!format) {							if (authdebug) {								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n", ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));								} else {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",										ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),										iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));								}							}							memset(&ied0, 0, sizeof(ied0));							iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");							iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);							send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);							if (!iaxs[fr->callno]) {								break;							}						} else {							/* Pick one... */							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))									format = 0;							} else {								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {									using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";									memset(&pref, 0, sizeof(pref));									format = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ?										iaxs[fr->callno]->peerformat : iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									strcpy(caller_pref_buf,"disabled");									strcpy(host_pref_buf,"disabled");								} else {									struct ast_format tmpfmt;									using_prefs = "mine";									if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {										/* Do the opposite of what we tried above. */										if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {											pref = iaxs[fr->callno]->prefs;										} else {											pref = iaxs[fr->callno]->rprefs;											using_prefs = "caller";										}										format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);									} else /* if no codec_prefs IE do it the old way */										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}							}							if (!format) {								char tmp1[256], tmp2[256], tmp3[256];								ast_log(LOG_ERROR, "No best format in %s???\n",									iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));								if (authdebug) {									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}							}						}					}					if (format) {						/* Authentication received */						memset(&ied1, 0, sizeof(ied1));						iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);						iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);						send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);						if (strcmp(iaxs[fr->callno]->exten, "TBD")) {							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							ast_verb(3, "Accepting AUTHENTICATED call from %s:\n"											"%srequested format = %s,\n"											"%srequested prefs = %s,\n"											"%sactual format = %s,\n"											"%shost prefs = %s,\n"											"%spriority = %s\n", 											ast_inet_ntoa(sin.sin_addr), 											VERBOSE_PREFIX_4,											iax2_getformatname(iaxs[fr->callno]->peerformat),											VERBOSE_PREFIX_4,											caller_pref_buf,											VERBOSE_PREFIX_4,											iax2_getformatname(format),											VERBOSE_PREFIX_4,											host_pref_buf,											VERBOSE_PREFIX_4,											using_prefs);							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, format, NULL, 1)))								iax2_destroy(fr->callno);							else if (ies.vars) {								struct ast_datastore *variablestore;								struct ast_variable *var, *prev = NULL;								AST_LIST_HEAD(, ast_var_t) *varlist;								varlist = ast_calloc(1, sizeof(*varlist));								variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);								if (variablestore && varlist) {									variablestore->data = varlist;									variablestore->inheritance = DATASTORE_INHERIT_FOREVER;									AST_LIST_HEAD_INIT(varlist);									ast_debug(1, "I can haz IAX vars? w00t\n");									for (var = ies.vars; var; var = var->next) {										struct ast_var_t *newvar = ast_var_assign(var->name, var->value);										if (prev)											ast_free(prev);										prev = var;										if (!newvar) {											/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */											ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");										} else {											AST_LIST_INSERT_TAIL(varlist, newvar, entries);										}									}									if (prev)										ast_free(prev);									ies.vars = NULL;									ast_channel_datastore_add(c, variablestore);								} else {									ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									if (variablestore)										ast_datastore_free(variablestore);									if (varlist)										ast_free(varlist);								}							}						} else {							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);							/* If this is a TBD call, we're ready but now what...  */							ast_verb(3, "Accepted AUTHENTICATED TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							if (ast_test_flag64(iaxs[fr->callno], IAX_IMMEDIATE)) {								goto immediatedial;							}						}					}				}				break;			case IAX_COMMAND_DIAL:immediatedial:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD)) {					ast_clear_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);					ast_string_field_set(iaxs[fr->callno], exten, ies.called_number ? ies.called_number : "s");					if (!ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num)) {						if (authdebug)							ast_log(LOG_NOTICE, "Rejected dial attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}					} else {						char tmp[256];						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);						ast_verb(3, "Accepting DIAL from %s, formats = %s\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat));						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);						send_command(iaxs[fr->callno], AST_FRAME_CONTROL, AST_CONTROL_PROGRESS, 0, NULL, 0, -1);						if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->peerformat, NULL, 1)))							iax2_destroy(fr->callno);						else if (ies.vars) {							struct ast_datastore *variablestore;							struct ast_variable *var, *prev = NULL;							AST_LIST_HEAD(, ast_var_t) *varlist;							varlist = ast_calloc(1, sizeof(*varlist));							variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);							ast_debug(1, "I can haz IAX vars? w00t\n");							if (variablestore && varlist) {								variablestore->data = varlist;								variablestore->inheritance = DATASTORE_INHERIT_FOREVER;								AST_LIST_HEAD_INIT(varlist);								for (var = ies.vars; var; var = var->next) {									struct ast_var_t *newvar = ast_var_assign(var->name, var->value);									if (prev)										ast_free(prev);									prev = var;									if (!newvar) {										/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */										ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									} else {										AST_LIST_INSERT_TAIL(varlist, newvar, entries);									}								}								if (prev)									ast_free(prev);								ies.vars = NULL;								ast_channel_datastore_add(c, variablestore);							} else {								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");								if (variablestore)									ast_datastore_free(variablestore);								if (varlist)									ast_free(varlist);							}						}					}				}				break;			case IAX_COMMAND_INVAL:				iaxs[fr->callno]->error = ENOTCONN;				ast_debug(1, "Immediately destroying %d, having received INVAL\n", fr->callno);				iax2_destroy(fr->callno);				ast_debug(1, "Destroying call %d\n", fr->callno);				break;			case IAX_COMMAND_VNAK:				ast_debug(1, "Received VNAK: resending outstanding frames\n");				/* Force retransmission */				vnak_retransmit(fr->callno, fr->iseqno);				break;			case IAX_COMMAND_REGREQ:			case IAX_COMMAND_REGREL:				/* For security, always ack immediately */				if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				if (register_verify(fr->callno, &sin, &ies)) {					if (!iaxs[fr->callno]) {						break;					}					/* Send delayed failure */					auth_fail(fr->callno, IAX_COMMAND_REGREJ);					break;				}				if (!iaxs[fr->callno]) {					break;				}				if ((ast_strlen_zero(iaxs[fr->callno]->secret) && ast_strlen_zero(iaxs[fr->callno]->inkeys)) ||						ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED)) {					if (f.subclass.integer == IAX_COMMAND_REGREL) {						memset(&sin, 0, sizeof(sin));						sin.sin_family = AF_INET;					}					if (update_registry(&sin, fr->callno, ies.devicetype, fd, ies.refresh)) {						ast_log(LOG_WARNING, "Registry error\n");					}					if (!iaxs[fr->callno]) {						break;					}					if (ies.provverpres && ies.serviceident && sin.sin_addr.s_addr) {						ast_mutex_unlock(&iaxsl[fr->callno]);						check_provisioning(&sin, fd, ies.serviceident, ies.provver);						ast_mutex_lock(&iaxsl[fr->callno]);					}					break;				}				registry_authrequest(fr->callno);				break;			case IAX_COMMAND_REGACK:				if (iax2_ack_registry(&ies, &sin, fr->callno)) 					ast_log(LOG_WARNING, "Registration failure\n");				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_REGREJ:				if (iaxs[fr->callno]->reg) {					if (authdebug) {						ast_log(LOG_NOTICE, "Registration of '%s' rejected: '%s' from: '%s'\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>", ast_inet_ntoa(sin.sin_addr));						manager_event(EVENT_FLAG_SYSTEM, "Registry", "ChannelType: IAX2\r\nUsername: %s\r\nStatus: Rejected\r\nCause: %s\r\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>");					}					iaxs[fr->callno]->reg->regstate = REG_STATE_REJECTED;				}				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_REGAUTH:				/* Authentication request */				if (registry_rerequest(&ies, fr->callno, &sin)) {					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No authority found");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_FACILITY_NOT_SUBSCRIBED);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);				}				break;			case IAX_COMMAND_TXREJ:				iaxs[fr->callno]->transferring = 0;				ast_verb(3, "Channel '%s' unable to transfer\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");				memset(&iaxs[fr->callno]->transfer, 0, sizeof(iaxs[fr->callno]->transfer));				if (iaxs[fr->callno]->bridgecallno) {					if (iaxs[iaxs[fr->callno]->bridgecallno]->transferring) {						iaxs[iaxs[fr->callno]->bridgecallno]->transferring = 0;						send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREJ, 0, NULL, 0, -1);					}				}				break;			case IAX_COMMAND_TXREADY:				if ((iaxs[fr->callno]->transferring == TRANSFER_BEGIN) ||				    (iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)) {					if (iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)						iaxs[fr->callno]->transferring = TRANSFER_MREADY;					else						iaxs[fr->callno]->transferring = TRANSFER_READY;					ast_verb(3, "Channel '%s' ready to transfer\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					if (iaxs[fr->callno]->bridgecallno) {						if ((iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_READY) ||						    (iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_MREADY)) {							/* They're both ready, now release them. */							if (iaxs[fr->callno]->transferring == TRANSFER_MREADY) {								ast_verb(3, "Attempting media bridge of %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_MEDIA;								iaxs[fr->callno]->transferring = TRANSFER_MEDIA;								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied1.buf, ied1.pos, -1);							} else {								ast_verb(3, "Releasing %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_RELEASED;								iaxs[fr->callno]->transferring = TRANSFER_RELEASED;								ast_set_flag64(iaxs[iaxs[fr->callno]->bridgecallno], IAX_ALREADYGONE);								ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);								/* Stop doing lag & ping requests */								stop_stuff(fr->callno);								stop_stuff(iaxs[fr->callno]->bridgecallno);								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied1.buf, ied1.pos, -1);							}						}					}				}				break;			case IAX_COMMAND_TXREQ:				try_transfer(iaxs[fr->callno], &ies);				break;			case IAX_COMMAND_TXCNT:				if (iaxs[fr->callno]->transferring)					send_command_transfer(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXACC, 0, NULL, 0);				break;			case IAX_COMMAND_TXREL:				/* Send ack immediately, rather than waiting until we've changed addresses */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				complete_transfer(fr->callno, &ies);				stop_stuff(fr->callno);	/* for attended transfer to work with libiax */				break;				case IAX_COMMAND_TXMEDIA:				if (iaxs[fr->callno]->transferring == TRANSFER_READY) {					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* Cancel any outstanding frames and start anew */						if (cur->transfer) {							cur->retries = -1;						}					}					/* Start sending our media to the transfer address, but otherwise leave the call as-is */					iaxs[fr->callno]->transferring = TRANSFER_MEDIAPASS;				}				break;			case IAX_COMMAND_RTKEY:				if (!IAX_CALLENCRYPTED(iaxs[fr->callno])) {					ast_log(LOG_WARNING, 						"we've been told to rotate our encryption key, "						"but this isn't an encrypted call. bad things will happen.\n"					);					break;				}				IAX_DEBUGDIGEST("Receiving", ies.challenge);				ast_aes_set_decrypt_key((unsigned char *) ies.challenge, &iaxs[fr->callno]->dcx);				break;			case IAX_COMMAND_DPREP:				complete_dpreply(iaxs[fr->callno], &ies);				break;			case IAX_COMMAND_UNSUPPORT:				ast_log(LOG_NOTICE, "Peer did not understand our iax command '%d'\n", ies.iax_unknown);				break;			case IAX_COMMAND_FWDOWNL:				/* Firmware download */				if (!ast_test_flag64(&globalflags, IAX_ALLOWFWDOWNLOAD)) {					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_UNSUPPORT, 0, NULL, 0, -1);					break;				}				memset(&ied0, 0, sizeof(ied0));				res = iax_firmware_append(&ied0, (unsigned char *)ies.devicetype, ies.fwdesc);				if (res < 0)					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);				else if (res > 0)					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1);				else					send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1);				break;			case IAX_COMMAND_CALLTOKEN:			{				struct iax_frame *cur;				/* find last sent frame */				if ((cur = AST_LIST_LAST(&frame_queue[fr->callno])) && ies.calltoken && ies.calltokendata) {					resend_with_token(fr->callno, cur, (char *) ies.calltokendata);				}				break;			}			default:				ast_debug(1, "Unknown IAX command %d on %d/%d\n", f.subclass.integer, fr->callno, iaxs[fr->callno]->peercallno);				memset(&ied0, 0, sizeof(ied0));				iax_ie_append_byte(&ied0, IAX_IE_IAX_UNKNOWN, f.subclass.integer);				send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_UNSUPPORT, 0, ied0.buf, ied0.pos, -1);			}
AST_SCHED_DEL(sched, iaxs[fr->callno]->initid);
AST_SCHED_DEL(sched, iaxs[fr->callno]->initid)
AST_SCHED_DEL
AST_SCHED_DEL
sched
sched
iaxs[fr->callno]->initid
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
initid
if (iaxdebug)				ast_debug(1, "IAX subclass %d received\n", f.subclass.integer);
iaxdebug
iaxdebug
ast_debug(1, "IAX subclass %d received\n", f.subclass.integer);
ast_debug(1, "IAX subclass %d received\n", f.subclass.integer)
ast_debug
ast_debug
1
"IAX subclass %d received\n"
f.subclass.integer
f.subclass
f
f
subclass
integer
if (iaxs[fr->callno]->last < fr->ts &&                            f.subclass.integer != IAX_COMMAND_ACK &&                            f.subclass.integer != IAX_COMMAND_PONG &&                            f.subclass.integer != IAX_COMMAND_LAGRP) {				iaxs[fr->callno]->last = fr->ts;				if (iaxdebug)					ast_debug(1, "For call=%d, set last=%d\n", fr->callno, fr->ts);			}
iaxs[fr->callno]->last < fr->ts &&                            f.subclass.integer != IAX_COMMAND_ACK &&                            f.subclass.integer != IAX_COMMAND_PONG &&                            f.subclass.integer != IAX_COMMAND_LAGRP
iaxs[fr->callno]->last < fr->ts &&                            f.subclass.integer != IAX_COMMAND_ACK &&                            f.subclass.integer != IAX_COMMAND_PONG
iaxs[fr->callno]->last < fr->ts &&                            f.subclass.integer != IAX_COMMAND_ACK
iaxs[fr->callno]->last < fr->ts
iaxs[fr->callno]->last
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
last
fr->ts
fr
fr
ts
f.subclass.integer != IAX_COMMAND_ACK
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_ACK
IAX_COMMAND_ACK
f.subclass.integer != IAX_COMMAND_PONG
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_PONG
IAX_COMMAND_PONG
f.subclass.integer != IAX_COMMAND_LAGRP
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_LAGRP
IAX_COMMAND_LAGRP
{				iaxs[fr->callno]->last = fr->ts;				if (iaxdebug)					ast_debug(1, "For call=%d, set last=%d\n", fr->callno, fr->ts);			}
iaxs[fr->callno]->last = fr->ts;
iaxs[fr->callno]->last = fr->ts
iaxs[fr->callno]->last
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
last
fr->ts
fr
fr
ts
if (iaxdebug)					ast_debug(1, "For call=%d, set last=%d\n", fr->callno, fr->ts);
iaxdebug
iaxdebug
ast_debug(1, "For call=%d, set last=%d\n", fr->callno, fr->ts);
ast_debug(1, "For call=%d, set last=%d\n", fr->callno, fr->ts)
ast_debug
ast_debug
1
"For call=%d, set last=%d\n"
fr->callno
fr
fr
callno
fr->ts
fr
fr
ts
iaxs[fr->callno]->last_iax_message = f.subclass.integer;
iaxs[fr->callno]->last_iax_message = f.subclass.integer
iaxs[fr->callno]->last_iax_message
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
last_iax_message
f.subclass.integer
f.subclass
f
f
subclass
integer
if (!iaxs[fr->callno]->first_iax_message) {				iaxs[fr->callno]->first_iax_message = f.subclass.integer;			}
!iaxs[fr->callno]->first_iax_message
iaxs[fr->callno]->first_iax_message
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
first_iax_message
{				iaxs[fr->callno]->first_iax_message = f.subclass.integer;			}
iaxs[fr->callno]->first_iax_message = f.subclass.integer;
iaxs[fr->callno]->first_iax_message = f.subclass.integer
iaxs[fr->callno]->first_iax_message
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
first_iax_message
f.subclass.integer
f.subclass
f
f
subclass
integer
switch(f.subclass.integer) {			case IAX_COMMAND_ACK:				/* Do nothing */				break;			case IAX_COMMAND_QUELCH:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {				        /* Generate Manager Hold event, if necessary*/					if (iaxs[fr->callno]->owner) {						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: On\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}					ast_set_flag64(iaxs[fr->callno], IAX_QUELCH);					if (ies.musiconhold) {						iax2_lock_owner(fr->callno);						if (!iaxs[fr->callno] || !iaxs[fr->callno]->owner) {							break;						}						if (ast_bridged_channel(iaxs[fr->callno]->owner)) {							const char *moh_suggest = iaxs[fr->callno]->mohsuggest;							/*							 * We already hold the owner lock so we do not							 * need to check iaxs[fr->callno] after it returns.							 */							iax2_queue_control_data(fr->callno, AST_CONTROL_HOLD, 								S_OR(moh_suggest, NULL),								!ast_strlen_zero(moh_suggest) ? strlen(moh_suggest) + 1 : 0);						}						ast_channel_unlock(iaxs[fr->callno]->owner);					}				}				break;			case IAX_COMMAND_UNQUELCH:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {					iax2_lock_owner(fr->callno);					if (!iaxs[fr->callno]) {						break;					}					/* Generate Manager Unhold event, if necessary */					if (iaxs[fr->callno]->owner && ast_test_flag64(iaxs[fr->callno], IAX_QUELCH)) {						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: Off\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}					ast_clear_flag64(iaxs[fr->callno], IAX_QUELCH);					if (!iaxs[fr->callno]->owner) {						break;					}					if (ast_bridged_channel(iaxs[fr->callno]->owner)) {						/*						 * We already hold the owner lock so we do not						 * need to check iaxs[fr->callno] after it returns.						 */						iax2_queue_control_data(fr->callno, AST_CONTROL_UNHOLD, NULL, 0);					}					ast_channel_unlock(iaxs[fr->callno]->owner);				}				break;			case IAX_COMMAND_TXACC:				if (iaxs[fr->callno]->transferring == TRANSFER_BEGIN) {					/* Ack the packet with the given timestamp */					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* Cancel any outstanding txcnt's */						if (cur->transfer) {							cur->retries = -1;						}					}					memset(&ied1, 0, sizeof(ied1));					iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->callno);					send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREADY, 0, ied1.buf, ied1.pos, -1);					iaxs[fr->callno]->transferring = TRANSFER_READY;				}				break;			case IAX_COMMAND_NEW:				/* Ignore if it's already up */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD))					break;				if (ies.provverpres && ies.serviceident && sin.sin_addr.s_addr) {					ast_mutex_unlock(&iaxsl[fr->callno]);					check_provisioning(&sin, fd, ies.serviceident, ies.provver);					ast_mutex_lock(&iaxsl[fr->callno]);					if (!iaxs[fr->callno]) {						break;					}				}				/* If we're in trunk mode, do it now, and update the trunk number in our frame before continuing */				if (ast_test_flag64(iaxs[fr->callno], IAX_TRUNK)) {					int new_callno;					if ((new_callno = make_trunk(fr->callno, 1)) != -1)						fr->callno = new_callno;				}				/* For security, always ack immediately */				if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				if (check_access(fr->callno, &sin, &ies)) {					/* They're not allowed on */					auth_fail(fr->callno, IAX_COMMAND_REJECT);					if (authdebug)						ast_log(LOG_NOTICE, "Rejected connect attempt from %s, who was trying to reach '%s@%s'\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					break;				}				if (ast_strlen_zero(iaxs[fr->callno]->secret) && ast_test_flag64(iaxs[fr->callno], IAX_FORCE_ENCRYPT)) {					auth_fail(fr->callno, IAX_COMMAND_REJECT);					ast_log(LOG_WARNING, "Rejected connect attempt.  No secret present while force encrypt enabled.\n");					break;				}				if (strcasecmp(iaxs[fr->callno]->exten, "TBD")) {					const char *context, *exten, *cid_num;					context = ast_strdupa(iaxs[fr->callno]->context);					exten = ast_strdupa(iaxs[fr->callno]->exten);					cid_num = ast_strdupa(iaxs[fr->callno]->cid_num);					/* This might re-enter the IAX code and need the lock */					ast_mutex_unlock(&iaxsl[fr->callno]);					exists = ast_exists_extension(NULL, context, exten, 1, cid_num);					ast_mutex_lock(&iaxsl[fr->callno]);					if (!iaxs[fr->callno]) {						break;					}				} else					exists = 0;				/* Get OSP token if it does exist */				save_osptoken(fr, &ies);				if (ast_strlen_zero(iaxs[fr->callno]->secret) && ast_strlen_zero(iaxs[fr->callno]->inkeys)) {					if (strcmp(iaxs[fr->callno]->exten, "TBD") && !exists) {						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}						if (authdebug)							ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					} else {						/* Select an appropriate format */						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								using_prefs = "reqonly";							} else {								using_prefs = "disabled";							}							format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;							memset(&pref, 0, sizeof(pref));							strcpy(caller_pref_buf, "disabled");							strcpy(host_pref_buf, "disabled");						} else {							struct ast_format tmpfmt;							using_prefs = "mine";							/* If the information elements are in here... use them */							if (ies.codec_prefs)								ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);							if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {								/* If we are codec_first_choice we let the caller have the 1st shot at picking the codec.*/								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {									pref = iaxs[fr->callno]->rprefs;									using_prefs = "caller";								} else {									pref = iaxs[fr->callno]->prefs;								}							} else								pref = iaxs[fr->callno]->prefs;							format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);							ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);							ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);						}						if (!format) {							if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP))								format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;							if (!format) {								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}								if (authdebug) {									char tmp[256], tmp2[256], tmp3[256];									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}							} else {								/* Pick one... */								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))										format = 0;								} else {									if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {										using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";										memset(&pref, 0, sizeof(pref));										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);										strcpy(caller_pref_buf,"disabled");										strcpy(host_pref_buf,"disabled");									} else {										struct ast_format tmpfmt;										using_prefs = "mine";										if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {											/* Do the opposite of what we tried above. */											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);										} else /* if no codec_prefs IE do it the old way */											format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}								}								if (!format) {									char tmp[256], tmp2[256], tmp3[256];									memset(&ied0, 0, sizeof(ied0));									iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");									iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);									ast_log(LOG_ERROR, "No best format in '%s'???\n", iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));									send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);									if (!iaxs[fr->callno]) {										break;									}									if (authdebug) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}									ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);									break;								}							}						}						if (format) {							/* No authentication required, let them in */							memset(&ied1, 0, sizeof(ied1));							iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);							iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);							send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);							if (strcmp(iaxs[fr->callno]->exten, "TBD")) {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);								ast_verb(3, "Accepting UNAUTHENTICATED call from %s:\n"												"%srequested format = %s,\n"												"%srequested prefs = %s,\n"												"%sactual format = %s,\n"												"%shost prefs = %s,\n"												"%spriority = %s\n",												ast_inet_ntoa(sin.sin_addr), 												VERBOSE_PREFIX_4,												iax2_getformatname(iaxs[fr->callno]->peerformat), 												VERBOSE_PREFIX_4,												caller_pref_buf,												VERBOSE_PREFIX_4,												iax2_getformatname(format), 												VERBOSE_PREFIX_4,												host_pref_buf, 												VERBOSE_PREFIX_4,												using_prefs);								iaxs[fr->callno]->chosenformat = format;								/* Since this is a new call, we should go ahead and set the callid for it. */								iax_pvt_callid_new(fr->callno);								ast_set_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);							} else {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);								/* If this is a TBD call, we're ready but now what...  */								ast_verb(3, "Accepted unauthenticated TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							}						}					}					break;				}				if (iaxs[fr->callno]->authmethods & IAX_AUTH_MD5)					merge_encryption(iaxs[fr->callno],ies.encmethods);				else					iaxs[fr->callno]->encmethods = 0;				if (!authenticate_request(fr->callno) && iaxs[fr->callno])					ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED);				break;			case IAX_COMMAND_DPREQ:				/* Request status in the dialplan */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD) &&					!ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED) && ies.called_number) {					if (iaxcompat) {						/* Spawn a thread for the lookup */						spawn_dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num);					} else {						/* Just look it up */						dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num, 1);					}				}				break;			case IAX_COMMAND_HANGUP:				ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);				ast_debug(1, "Immediately destroying %d, having received hangup\n", fr->callno);				/* Set hangup cause according to remote and hangupsource */				if (iaxs[fr->callno]->owner) {					set_hangup_source_and_cause(fr->callno, ies.causecode);					if (!iaxs[fr->callno]) {						break;					}				}				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_REJECT:				/* Set hangup cause according to remote and hangup source */				if (iaxs[fr->callno]->owner) {					set_hangup_source_and_cause(fr->callno, ies.causecode);					if (!iaxs[fr->callno]) {						break;					}				}				if (!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)) {					if (iaxs[fr->callno]->owner && authdebug)						ast_log(LOG_WARNING, "Call rejected by %s: %s\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr),							ies.cause ? ies.cause : "<Unknown>");					ast_debug(1, "Immediately destroying %d, having received reject\n",						fr->callno);				}				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK,						       fr->ts, NULL, 0, fr->iseqno);				if (!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION))					iaxs[fr->callno]->error = EPERM;				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_TRANSFER:			{				struct ast_channel *bridged_chan;				struct ast_channel *owner;				iax2_lock_owner(fr->callno);				if (!iaxs[fr->callno]) {					/* Initiating call went away before we could transfer. */					break;				}				owner = iaxs[fr->callno]->owner;				bridged_chan = owner ? ast_bridged_channel(owner) : NULL;				if (bridged_chan && ies.called_number) {					const char *context;					context = ast_strdupa(iaxs[fr->callno]->context);					ast_channel_ref(owner);					ast_channel_ref(bridged_chan);					ast_channel_unlock(owner);					ast_mutex_unlock(&iaxsl[fr->callno]);					/* Set BLINDTRANSFER channel variables */					pbx_builtin_setvar_helper(owner, "BLINDTRANSFER", ast_channel_name(bridged_chan));					pbx_builtin_setvar_helper(bridged_chan, "BLINDTRANSFER", ast_channel_name(owner));					/* DO NOT hold any locks while calling ast_parking_ext_valid() */					if (ast_parking_ext_valid(ies.called_number, owner, context)) {						ast_debug(1, "Parking call '%s'\n", ast_channel_name(bridged_chan));						if (iax_park(bridged_chan, owner, ies.called_number, context)) {							ast_log(LOG_WARNING, "Failed to park call '%s'\n",								ast_channel_name(bridged_chan));						}					} else {						if (ast_async_goto(bridged_chan, context, ies.called_number, 1)) {							ast_log(LOG_WARNING,								"Async goto of '%s' to '%s@%s' failed\n",								ast_channel_name(bridged_chan), ies.called_number, context);						} else {							ast_debug(1, "Async goto of '%s' to '%s@%s' started\n",								ast_channel_name(bridged_chan), ies.called_number, context);						}					}					ast_channel_unref(owner);					ast_channel_unref(bridged_chan);					ast_mutex_lock(&iaxsl[fr->callno]);				} else {					ast_debug(1, "Async goto not applicable on call %d\n", fr->callno);					if (owner) {						ast_channel_unlock(owner);					}				}				break;			}			case IAX_COMMAND_ACCEPT:				/* Ignore if call is already up or needs authentication or is a TBD */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD | IAX_STATE_AUTHENTICATED))					break;				if (ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)) {					/* Send ack immediately, before we destroy */					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					iax2_destroy(fr->callno);					break;				}				if (ies.format) {					iaxs[fr->callno]->peerformat = ies.format;				} else {					if (iaxs[fr->callno]->owner)						iaxs[fr->callno]->peerformat = ast_format_cap_to_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner));					else						iaxs[fr->callno]->peerformat = iaxs[fr->callno]->capability;				}				ast_verb(3, "Call accepted by %s (format %s)\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iax2_getformatname(iaxs[fr->callno]->peerformat));				if (!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)) {					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);					if (!iaxs[fr->callno]) {						break;					}					if (authdebug) {						char tmp1[256], tmp2[256];						ast_log(LOG_NOTICE, "Rejected call to %s, format %s incompatible with our capability %s.\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),							iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));					}				} else {					ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);					iax2_lock_owner(fr->callno);					if (iaxs[fr->callno] && iaxs[fr->callno]->owner) {						char tmp[256];						/* Switch us to use a compatible format */						ast_format_cap_from_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner), iaxs[fr->callno]->peerformat);						ast_verb(3, "Format for call is %s\n", ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(iaxs[fr->callno]->owner)));						/* Setup read/write formats properly. */						if (ast_channel_writeformat(iaxs[fr->callno]->owner)->id)							ast_set_write_format(iaxs[fr->callno]->owner, ast_channel_writeformat(iaxs[fr->callno]->owner));						if (ast_channel_readformat(iaxs[fr->callno]->owner)->id)							ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));						ast_channel_unlock(iaxs[fr->callno]->owner);					}				}				if (iaxs[fr->callno]) {					AST_LIST_LOCK(&dpcache);					AST_LIST_TRAVERSE(&iaxs[fr->callno]->dpentries, dp, peer_list)						if (!(dp->flags & CACHE_FLAG_TRANSMITTED))							iax2_dprequest(dp, fr->callno);					AST_LIST_UNLOCK(&dpcache);				}				break;			case IAX_COMMAND_POKE:				/* Send back a pong packet with the original timestamp */				send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, NULL, 0, -1);				break;			case IAX_COMMAND_PING:			{				struct iax_ie_data pingied;				construct_rr(iaxs[fr->callno], &pingied);				/* Send back a pong packet with the original timestamp */				send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, pingied.buf, pingied.pos, -1);			}				break;			case IAX_COMMAND_PONG:				/* Calculate ping time */				iaxs[fr->callno]->pingtime =  calc_timestamp(iaxs[fr->callno], 0, &f) - fr->ts;				/* save RR info */				save_rr(fr, &ies);				/* Good time to write jb stats for this call */				log_jitterstats(fr->callno);				if (iaxs[fr->callno]->peerpoke) {					peer = iaxs[fr->callno]->peerpoke;					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms)) {						if (iaxs[fr->callno]->pingtime <= peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now REACHABLE! Time: %d\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Reachable\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "IAX2/%s", peer->name); /* Activate notification */						}					} else if ((peer->historicms > 0) && (peer->historicms <= peer->maxms)) {						if (iaxs[fr->callno]->pingtime > peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now TOO LAGGED (%d ms)!\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Lagged\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_UNAVAILABLE, AST_DEVSTATE_CACHABLE, "IAX2/%s", peer->name); /* Activate notification */						}					}					peer->lastms = iaxs[fr->callno]->pingtime;					if (peer->smoothing && (peer->lastms > -1))						peer->historicms = (iaxs[fr->callno]->pingtime + peer->historicms) / 2;					else if (peer->smoothing && peer->lastms < 0)						peer->historicms = (0 + peer->historicms) / 2;					else											peer->historicms = iaxs[fr->callno]->pingtime;					/* Remove scheduled iax2_poke_noanswer */					if (peer->pokeexpire > -1) {						if (!AST_SCHED_DEL(sched, peer->pokeexpire)) {							peer_unref(peer);							peer->pokeexpire = -1;						}					}					/* Schedule the next cycle */					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms))						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_peer_s, peer_ref(peer));					else						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqok, iax2_poke_peer_s, peer_ref(peer));					if (peer->pokeexpire == -1)						peer_unref(peer);					/* and finally send the ack */					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					/* And wrap up the qualify call */					iax2_destroy(fr->callno);					peer->callno = 0;					ast_debug(1, "Peer %s: got pong, lastms %d, historicms %d, maxms %d\n", peer->name, peer->lastms, peer->historicms, peer->maxms);				}				break;			case IAX_COMMAND_LAGRQ:			case IAX_COMMAND_LAGRP:				f.src = "LAGRQ";				f.mallocd = 0;				f.offset = 0;				f.samples = 0;				iax_frame_wrap(fr, &f);				if (f.subclass.integer == IAX_COMMAND_LAGRQ) {					/* Received a LAGRQ - echo back a LAGRP */					fr->af.subclass.integer = IAX_COMMAND_LAGRP;					iax2_send(iaxs[fr->callno], &fr->af, fr->ts, -1, 0, 0, 0);				} else {					/* Received LAGRP in response to our LAGRQ */					unsigned int ts;					/* This is a reply we've been given, actually measure the difference */					ts = calc_timestamp(iaxs[fr->callno], 0, &fr->af);					iaxs[fr->callno]->lag = ts - fr->ts;					if (iaxdebug)						ast_debug(1, "Peer %s lag measured as %dms\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->lag);				}				break;			case IAX_COMMAND_AUTHREQ:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)) {					ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					break;				}				if (authenticate_reply(iaxs[fr->callno], &iaxs[fr->callno]->addr, &ies, iaxs[fr->callno]->secret, iaxs[fr->callno]->outkey)) {					struct ast_frame hangup_fr = { .frametype = AST_FRAME_CONTROL,								.subclass.integer = AST_CONTROL_HANGUP,					};					ast_log(LOG_WARNING, 						"I don't know how to authenticate %s to %s\n", 						ies.username ? ies.username : "<unknown>", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr));					iax2_queue_frame(fr->callno, &hangup_fr);				}
f.subclass.integer
f.subclass
f
f
subclass
integer
{			case IAX_COMMAND_ACK:				/* Do nothing */				break;			case IAX_COMMAND_QUELCH:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {				        /* Generate Manager Hold event, if necessary*/					if (iaxs[fr->callno]->owner) {						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: On\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}					ast_set_flag64(iaxs[fr->callno], IAX_QUELCH);					if (ies.musiconhold) {						iax2_lock_owner(fr->callno);						if (!iaxs[fr->callno] || !iaxs[fr->callno]->owner) {							break;						}						if (ast_bridged_channel(iaxs[fr->callno]->owner)) {							const char *moh_suggest = iaxs[fr->callno]->mohsuggest;							/*							 * We already hold the owner lock so we do not							 * need to check iaxs[fr->callno] after it returns.							 */							iax2_queue_control_data(fr->callno, AST_CONTROL_HOLD, 								S_OR(moh_suggest, NULL),								!ast_strlen_zero(moh_suggest) ? strlen(moh_suggest) + 1 : 0);						}						ast_channel_unlock(iaxs[fr->callno]->owner);					}				}				break;			case IAX_COMMAND_UNQUELCH:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {					iax2_lock_owner(fr->callno);					if (!iaxs[fr->callno]) {						break;					}					/* Generate Manager Unhold event, if necessary */					if (iaxs[fr->callno]->owner && ast_test_flag64(iaxs[fr->callno], IAX_QUELCH)) {						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: Off\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}					ast_clear_flag64(iaxs[fr->callno], IAX_QUELCH);					if (!iaxs[fr->callno]->owner) {						break;					}					if (ast_bridged_channel(iaxs[fr->callno]->owner)) {						/*						 * We already hold the owner lock so we do not						 * need to check iaxs[fr->callno] after it returns.						 */						iax2_queue_control_data(fr->callno, AST_CONTROL_UNHOLD, NULL, 0);					}					ast_channel_unlock(iaxs[fr->callno]->owner);				}				break;			case IAX_COMMAND_TXACC:				if (iaxs[fr->callno]->transferring == TRANSFER_BEGIN) {					/* Ack the packet with the given timestamp */					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* Cancel any outstanding txcnt's */						if (cur->transfer) {							cur->retries = -1;						}					}					memset(&ied1, 0, sizeof(ied1));					iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->callno);					send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREADY, 0, ied1.buf, ied1.pos, -1);					iaxs[fr->callno]->transferring = TRANSFER_READY;				}				break;			case IAX_COMMAND_NEW:				/* Ignore if it's already up */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD))					break;				if (ies.provverpres && ies.serviceident && sin.sin_addr.s_addr) {					ast_mutex_unlock(&iaxsl[fr->callno]);					check_provisioning(&sin, fd, ies.serviceident, ies.provver);					ast_mutex_lock(&iaxsl[fr->callno]);					if (!iaxs[fr->callno]) {						break;					}				}				/* If we're in trunk mode, do it now, and update the trunk number in our frame before continuing */				if (ast_test_flag64(iaxs[fr->callno], IAX_TRUNK)) {					int new_callno;					if ((new_callno = make_trunk(fr->callno, 1)) != -1)						fr->callno = new_callno;				}				/* For security, always ack immediately */				if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				if (check_access(fr->callno, &sin, &ies)) {					/* They're not allowed on */					auth_fail(fr->callno, IAX_COMMAND_REJECT);					if (authdebug)						ast_log(LOG_NOTICE, "Rejected connect attempt from %s, who was trying to reach '%s@%s'\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					break;				}				if (ast_strlen_zero(iaxs[fr->callno]->secret) && ast_test_flag64(iaxs[fr->callno], IAX_FORCE_ENCRYPT)) {					auth_fail(fr->callno, IAX_COMMAND_REJECT);					ast_log(LOG_WARNING, "Rejected connect attempt.  No secret present while force encrypt enabled.\n");					break;				}				if (strcasecmp(iaxs[fr->callno]->exten, "TBD")) {					const char *context, *exten, *cid_num;					context = ast_strdupa(iaxs[fr->callno]->context);					exten = ast_strdupa(iaxs[fr->callno]->exten);					cid_num = ast_strdupa(iaxs[fr->callno]->cid_num);					/* This might re-enter the IAX code and need the lock */					ast_mutex_unlock(&iaxsl[fr->callno]);					exists = ast_exists_extension(NULL, context, exten, 1, cid_num);					ast_mutex_lock(&iaxsl[fr->callno]);					if (!iaxs[fr->callno]) {						break;					}				} else					exists = 0;				/* Get OSP token if it does exist */				save_osptoken(fr, &ies);				if (ast_strlen_zero(iaxs[fr->callno]->secret) && ast_strlen_zero(iaxs[fr->callno]->inkeys)) {					if (strcmp(iaxs[fr->callno]->exten, "TBD") && !exists) {						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}						if (authdebug)							ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					} else {						/* Select an appropriate format */						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								using_prefs = "reqonly";							} else {								using_prefs = "disabled";							}							format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;							memset(&pref, 0, sizeof(pref));							strcpy(caller_pref_buf, "disabled");							strcpy(host_pref_buf, "disabled");						} else {							struct ast_format tmpfmt;							using_prefs = "mine";							/* If the information elements are in here... use them */							if (ies.codec_prefs)								ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);							if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {								/* If we are codec_first_choice we let the caller have the 1st shot at picking the codec.*/								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {									pref = iaxs[fr->callno]->rprefs;									using_prefs = "caller";								} else {									pref = iaxs[fr->callno]->prefs;								}							} else								pref = iaxs[fr->callno]->prefs;							format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);							ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);							ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);						}						if (!format) {							if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP))								format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;							if (!format) {								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}								if (authdebug) {									char tmp[256], tmp2[256], tmp3[256];									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}							} else {								/* Pick one... */								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))										format = 0;								} else {									if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {										using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";										memset(&pref, 0, sizeof(pref));										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);										strcpy(caller_pref_buf,"disabled");										strcpy(host_pref_buf,"disabled");									} else {										struct ast_format tmpfmt;										using_prefs = "mine";										if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {											/* Do the opposite of what we tried above. */											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);										} else /* if no codec_prefs IE do it the old way */											format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}								}								if (!format) {									char tmp[256], tmp2[256], tmp3[256];									memset(&ied0, 0, sizeof(ied0));									iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");									iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);									ast_log(LOG_ERROR, "No best format in '%s'???\n", iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));									send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);									if (!iaxs[fr->callno]) {										break;									}									if (authdebug) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}									ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);									break;								}							}						}						if (format) {							/* No authentication required, let them in */							memset(&ied1, 0, sizeof(ied1));							iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);							iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);							send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);							if (strcmp(iaxs[fr->callno]->exten, "TBD")) {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);								ast_verb(3, "Accepting UNAUTHENTICATED call from %s:\n"												"%srequested format = %s,\n"												"%srequested prefs = %s,\n"												"%sactual format = %s,\n"												"%shost prefs = %s,\n"												"%spriority = %s\n",												ast_inet_ntoa(sin.sin_addr), 												VERBOSE_PREFIX_4,												iax2_getformatname(iaxs[fr->callno]->peerformat), 												VERBOSE_PREFIX_4,												caller_pref_buf,												VERBOSE_PREFIX_4,												iax2_getformatname(format), 												VERBOSE_PREFIX_4,												host_pref_buf, 												VERBOSE_PREFIX_4,												using_prefs);								iaxs[fr->callno]->chosenformat = format;								/* Since this is a new call, we should go ahead and set the callid for it. */								iax_pvt_callid_new(fr->callno);								ast_set_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);							} else {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);								/* If this is a TBD call, we're ready but now what...  */								ast_verb(3, "Accepted unauthenticated TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							}						}					}					break;				}				if (iaxs[fr->callno]->authmethods & IAX_AUTH_MD5)					merge_encryption(iaxs[fr->callno],ies.encmethods);				else					iaxs[fr->callno]->encmethods = 0;				if (!authenticate_request(fr->callno) && iaxs[fr->callno])					ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED);				break;			case IAX_COMMAND_DPREQ:				/* Request status in the dialplan */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD) &&					!ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED) && ies.called_number) {					if (iaxcompat) {						/* Spawn a thread for the lookup */						spawn_dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num);					} else {						/* Just look it up */						dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num, 1);					}				}				break;			case IAX_COMMAND_HANGUP:				ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);				ast_debug(1, "Immediately destroying %d, having received hangup\n", fr->callno);				/* Set hangup cause according to remote and hangupsource */				if (iaxs[fr->callno]->owner) {					set_hangup_source_and_cause(fr->callno, ies.causecode);					if (!iaxs[fr->callno]) {						break;					}				}				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_REJECT:				/* Set hangup cause according to remote and hangup source */				if (iaxs[fr->callno]->owner) {					set_hangup_source_and_cause(fr->callno, ies.causecode);					if (!iaxs[fr->callno]) {						break;					}				}				if (!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)) {					if (iaxs[fr->callno]->owner && authdebug)						ast_log(LOG_WARNING, "Call rejected by %s: %s\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr),							ies.cause ? ies.cause : "<Unknown>");					ast_debug(1, "Immediately destroying %d, having received reject\n",						fr->callno);				}				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK,						       fr->ts, NULL, 0, fr->iseqno);				if (!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION))					iaxs[fr->callno]->error = EPERM;				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_TRANSFER:			{				struct ast_channel *bridged_chan;				struct ast_channel *owner;				iax2_lock_owner(fr->callno);				if (!iaxs[fr->callno]) {					/* Initiating call went away before we could transfer. */					break;				}				owner = iaxs[fr->callno]->owner;				bridged_chan = owner ? ast_bridged_channel(owner) : NULL;				if (bridged_chan && ies.called_number) {					const char *context;					context = ast_strdupa(iaxs[fr->callno]->context);					ast_channel_ref(owner);					ast_channel_ref(bridged_chan);					ast_channel_unlock(owner);					ast_mutex_unlock(&iaxsl[fr->callno]);					/* Set BLINDTRANSFER channel variables */					pbx_builtin_setvar_helper(owner, "BLINDTRANSFER", ast_channel_name(bridged_chan));					pbx_builtin_setvar_helper(bridged_chan, "BLINDTRANSFER", ast_channel_name(owner));					/* DO NOT hold any locks while calling ast_parking_ext_valid() */					if (ast_parking_ext_valid(ies.called_number, owner, context)) {						ast_debug(1, "Parking call '%s'\n", ast_channel_name(bridged_chan));						if (iax_park(bridged_chan, owner, ies.called_number, context)) {							ast_log(LOG_WARNING, "Failed to park call '%s'\n",								ast_channel_name(bridged_chan));						}					} else {						if (ast_async_goto(bridged_chan, context, ies.called_number, 1)) {							ast_log(LOG_WARNING,								"Async goto of '%s' to '%s@%s' failed\n",								ast_channel_name(bridged_chan), ies.called_number, context);						} else {							ast_debug(1, "Async goto of '%s' to '%s@%s' started\n",								ast_channel_name(bridged_chan), ies.called_number, context);						}					}					ast_channel_unref(owner);					ast_channel_unref(bridged_chan);					ast_mutex_lock(&iaxsl[fr->callno]);				} else {					ast_debug(1, "Async goto not applicable on call %d\n", fr->callno);					if (owner) {						ast_channel_unlock(owner);					}				}				break;			}			case IAX_COMMAND_ACCEPT:				/* Ignore if call is already up or needs authentication or is a TBD */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD | IAX_STATE_AUTHENTICATED))					break;				if (ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)) {					/* Send ack immediately, before we destroy */					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					iax2_destroy(fr->callno);					break;				}				if (ies.format) {					iaxs[fr->callno]->peerformat = ies.format;				} else {					if (iaxs[fr->callno]->owner)						iaxs[fr->callno]->peerformat = ast_format_cap_to_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner));					else						iaxs[fr->callno]->peerformat = iaxs[fr->callno]->capability;				}				ast_verb(3, "Call accepted by %s (format %s)\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iax2_getformatname(iaxs[fr->callno]->peerformat));				if (!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)) {					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);					if (!iaxs[fr->callno]) {						break;					}					if (authdebug) {						char tmp1[256], tmp2[256];						ast_log(LOG_NOTICE, "Rejected call to %s, format %s incompatible with our capability %s.\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),							iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));					}				} else {					ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);					iax2_lock_owner(fr->callno);					if (iaxs[fr->callno] && iaxs[fr->callno]->owner) {						char tmp[256];						/* Switch us to use a compatible format */						ast_format_cap_from_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner), iaxs[fr->callno]->peerformat);						ast_verb(3, "Format for call is %s\n", ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(iaxs[fr->callno]->owner)));						/* Setup read/write formats properly. */						if (ast_channel_writeformat(iaxs[fr->callno]->owner)->id)							ast_set_write_format(iaxs[fr->callno]->owner, ast_channel_writeformat(iaxs[fr->callno]->owner));						if (ast_channel_readformat(iaxs[fr->callno]->owner)->id)							ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));						ast_channel_unlock(iaxs[fr->callno]->owner);					}				}				if (iaxs[fr->callno]) {					AST_LIST_LOCK(&dpcache);					AST_LIST_TRAVERSE(&iaxs[fr->callno]->dpentries, dp, peer_list)						if (!(dp->flags & CACHE_FLAG_TRANSMITTED))							iax2_dprequest(dp, fr->callno);					AST_LIST_UNLOCK(&dpcache);				}				break;			case IAX_COMMAND_POKE:				/* Send back a pong packet with the original timestamp */				send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, NULL, 0, -1);				break;			case IAX_COMMAND_PING:			{				struct iax_ie_data pingied;				construct_rr(iaxs[fr->callno], &pingied);				/* Send back a pong packet with the original timestamp */				send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, pingied.buf, pingied.pos, -1);			}				break;			case IAX_COMMAND_PONG:				/* Calculate ping time */				iaxs[fr->callno]->pingtime =  calc_timestamp(iaxs[fr->callno], 0, &f) - fr->ts;				/* save RR info */				save_rr(fr, &ies);				/* Good time to write jb stats for this call */				log_jitterstats(fr->callno);				if (iaxs[fr->callno]->peerpoke) {					peer = iaxs[fr->callno]->peerpoke;					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms)) {						if (iaxs[fr->callno]->pingtime <= peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now REACHABLE! Time: %d\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Reachable\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "IAX2/%s", peer->name); /* Activate notification */						}					} else if ((peer->historicms > 0) && (peer->historicms <= peer->maxms)) {						if (iaxs[fr->callno]->pingtime > peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now TOO LAGGED (%d ms)!\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Lagged\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_UNAVAILABLE, AST_DEVSTATE_CACHABLE, "IAX2/%s", peer->name); /* Activate notification */						}					}					peer->lastms = iaxs[fr->callno]->pingtime;					if (peer->smoothing && (peer->lastms > -1))						peer->historicms = (iaxs[fr->callno]->pingtime + peer->historicms) / 2;					else if (peer->smoothing && peer->lastms < 0)						peer->historicms = (0 + peer->historicms) / 2;					else											peer->historicms = iaxs[fr->callno]->pingtime;					/* Remove scheduled iax2_poke_noanswer */					if (peer->pokeexpire > -1) {						if (!AST_SCHED_DEL(sched, peer->pokeexpire)) {							peer_unref(peer);							peer->pokeexpire = -1;						}					}					/* Schedule the next cycle */					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms))						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_peer_s, peer_ref(peer));					else						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqok, iax2_poke_peer_s, peer_ref(peer));					if (peer->pokeexpire == -1)						peer_unref(peer);					/* and finally send the ack */					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					/* And wrap up the qualify call */					iax2_destroy(fr->callno);					peer->callno = 0;					ast_debug(1, "Peer %s: got pong, lastms %d, historicms %d, maxms %d\n", peer->name, peer->lastms, peer->historicms, peer->maxms);				}				break;			case IAX_COMMAND_LAGRQ:			case IAX_COMMAND_LAGRP:				f.src = "LAGRQ";				f.mallocd = 0;				f.offset = 0;				f.samples = 0;				iax_frame_wrap(fr, &f);				if (f.subclass.integer == IAX_COMMAND_LAGRQ) {					/* Received a LAGRQ - echo back a LAGRP */					fr->af.subclass.integer = IAX_COMMAND_LAGRP;					iax2_send(iaxs[fr->callno], &fr->af, fr->ts, -1, 0, 0, 0);				} else {					/* Received LAGRP in response to our LAGRQ */					unsigned int ts;					/* This is a reply we've been given, actually measure the difference */					ts = calc_timestamp(iaxs[fr->callno], 0, &fr->af);					iaxs[fr->callno]->lag = ts - fr->ts;					if (iaxdebug)						ast_debug(1, "Peer %s lag measured as %dms\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->lag);				}				break;			case IAX_COMMAND_AUTHREQ:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)) {					ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					break;				}				if (authenticate_reply(iaxs[fr->callno], &iaxs[fr->callno]->addr, &ies, iaxs[fr->callno]->secret, iaxs[fr->callno]->outkey)) {					struct ast_frame hangup_fr = { .frametype = AST_FRAME_CONTROL,								.subclass.integer = AST_CONTROL_HANGUP,					};					ast_log(LOG_WARNING, 						"I don't know how to authenticate %s to %s\n", 						ies.username ? ies.username : "<unknown>", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr));					iax2_queue_frame(fr->callno, &hangup_fr);				}
case IAX_COMMAND_ACK:
IAX_COMMAND_ACK
IAX_COMMAND_ACK
break;
case IAX_COMMAND_QUELCH:
IAX_COMMAND_QUELCH
IAX_COMMAND_QUELCH
if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {				        /* Generate Manager Hold event, if necessary*/					if (iaxs[fr->callno]->owner) {						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: On\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}					ast_set_flag64(iaxs[fr->callno], IAX_QUELCH);					if (ies.musiconhold) {						iax2_lock_owner(fr->callno);						if (!iaxs[fr->callno] || !iaxs[fr->callno]->owner) {							break;						}						if (ast_bridged_channel(iaxs[fr->callno]->owner)) {							const char *moh_suggest = iaxs[fr->callno]->mohsuggest;							/*							 * We already hold the owner lock so we do not							 * need to check iaxs[fr->callno] after it returns.							 */							iax2_queue_control_data(fr->callno, AST_CONTROL_HOLD, 								S_OR(moh_suggest, NULL),								!ast_strlen_zero(moh_suggest) ? strlen(moh_suggest) + 1 : 0);						}						ast_channel_unlock(iaxs[fr->callno]->owner);					}				}
ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
ast_test_flag
ast_test_flag
&iaxs[fr->callno]->state
iaxs[fr->callno]->state
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
state
IAX_STATE_STARTED
IAX_STATE_STARTED
{				        /* Generate Manager Hold event, if necessary*/					if (iaxs[fr->callno]->owner) {						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: On\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}					ast_set_flag64(iaxs[fr->callno], IAX_QUELCH);					if (ies.musiconhold) {						iax2_lock_owner(fr->callno);						if (!iaxs[fr->callno] || !iaxs[fr->callno]->owner) {							break;						}						if (ast_bridged_channel(iaxs[fr->callno]->owner)) {							const char *moh_suggest = iaxs[fr->callno]->mohsuggest;							/*							 * We already hold the owner lock so we do not							 * need to check iaxs[fr->callno] after it returns.							 */							iax2_queue_control_data(fr->callno, AST_CONTROL_HOLD, 								S_OR(moh_suggest, NULL),								!ast_strlen_zero(moh_suggest) ? strlen(moh_suggest) + 1 : 0);						}						ast_channel_unlock(iaxs[fr->callno]->owner);					}				}
if (iaxs[fr->callno]->owner) {						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: On\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
{						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: On\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}
ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: On\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));
ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: On\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner))
ast_manager_event
ast_manager_event
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
EVENT_FLAG_CALL
EVENT_FLAG_CALL
"Hold"
"Status: On\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n"
ast_channel_name(iaxs[fr->callno]->owner)
ast_channel_name
ast_channel_name
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
ast_channel_uniqueid(iaxs[fr->callno]->owner)
ast_channel_uniqueid
ast_channel_uniqueid
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
ast_set_flag64(iaxs[fr->callno], IAX_QUELCH);
ast_set_flag64(iaxs[fr->callno], IAX_QUELCH)
ast_set_flag64
ast_set_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_QUELCH
IAX_QUELCH
if (ies.musiconhold) {						iax2_lock_owner(fr->callno);						if (!iaxs[fr->callno] || !iaxs[fr->callno]->owner) {							break;						}						if (ast_bridged_channel(iaxs[fr->callno]->owner)) {							const char *moh_suggest = iaxs[fr->callno]->mohsuggest;							/*							 * We already hold the owner lock so we do not							 * need to check iaxs[fr->callno] after it returns.							 */							iax2_queue_control_data(fr->callno, AST_CONTROL_HOLD, 								S_OR(moh_suggest, NULL),								!ast_strlen_zero(moh_suggest) ? strlen(moh_suggest) + 1 : 0);						}						ast_channel_unlock(iaxs[fr->callno]->owner);					}
ies.musiconhold
ies
ies
musiconhold
{						iax2_lock_owner(fr->callno);						if (!iaxs[fr->callno] || !iaxs[fr->callno]->owner) {							break;						}						if (ast_bridged_channel(iaxs[fr->callno]->owner)) {							const char *moh_suggest = iaxs[fr->callno]->mohsuggest;							/*							 * We already hold the owner lock so we do not							 * need to check iaxs[fr->callno] after it returns.							 */							iax2_queue_control_data(fr->callno, AST_CONTROL_HOLD, 								S_OR(moh_suggest, NULL),								!ast_strlen_zero(moh_suggest) ? strlen(moh_suggest) + 1 : 0);						}						ast_channel_unlock(iaxs[fr->callno]->owner);					}
iax2_lock_owner(fr->callno);
iax2_lock_owner(fr->callno)
iax2_lock_owner
iax2_lock_owner
fr->callno
fr
fr
callno
if (!iaxs[fr->callno] || !iaxs[fr->callno]->owner) {							break;						}
!iaxs[fr->callno] || !iaxs[fr->callno]->owner
!iaxs[fr->callno]
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
!iaxs[fr->callno]->owner
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
{							break;						}
break;
if (ast_bridged_channel(iaxs[fr->callno]->owner)) {							const char *moh_suggest = iaxs[fr->callno]->mohsuggest;							/*							 * We already hold the owner lock so we do not							 * need to check iaxs[fr->callno] after it returns.							 */							iax2_queue_control_data(fr->callno, AST_CONTROL_HOLD, 								S_OR(moh_suggest, NULL),								!ast_strlen_zero(moh_suggest) ? strlen(moh_suggest) + 1 : 0);						}
ast_bridged_channel(iaxs[fr->callno]->owner)
ast_bridged_channel
ast_bridged_channel
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
{							const char *moh_suggest = iaxs[fr->callno]->mohsuggest;							/*							 * We already hold the owner lock so we do not							 * need to check iaxs[fr->callno] after it returns.							 */							iax2_queue_control_data(fr->callno, AST_CONTROL_HOLD, 								S_OR(moh_suggest, NULL),								!ast_strlen_zero(moh_suggest) ? strlen(moh_suggest) + 1 : 0);						}
const char *moh_suggest = iaxs[fr->callno]->mohsuggest;
const char *moh_suggest = iaxs[fr->callno]->mohsuggest;
const char
*moh_suggest = iaxs[fr->callno]->mohsuggest
*
moh_suggest
= iaxs[fr->callno]->mohsuggest
iaxs[fr->callno]->mohsuggest
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
mohsuggest
iax2_queue_control_data(fr->callno, AST_CONTROL_HOLD, 								S_OR(moh_suggest, NULL),								!ast_strlen_zero(moh_suggest) ? strlen(moh_suggest) + 1 : 0);
iax2_queue_control_data(fr->callno, AST_CONTROL_HOLD, 								S_OR(moh_suggest, NULL),								!ast_strlen_zero(moh_suggest) ? strlen(moh_suggest) + 1 : 0)
iax2_queue_control_data
iax2_queue_control_data
fr->callno
fr
fr
callno
AST_CONTROL_HOLD
AST_CONTROL_HOLD
S_OR(moh_suggest, NULL)
S_OR
S_OR
moh_suggest
moh_suggest
NULL
NULL
!ast_strlen_zero(moh_suggest) ? strlen(moh_suggest) + 1 : 0
!ast_strlen_zero(moh_suggest)
ast_strlen_zero(moh_suggest)
ast_strlen_zero
ast_strlen_zero
moh_suggest
moh_suggest
strlen(moh_suggest) + 1
strlen(moh_suggest)
strlen
strlen
moh_suggest
moh_suggest
1
0
ast_channel_unlock(iaxs[fr->callno]->owner);
ast_channel_unlock(iaxs[fr->callno]->owner)
ast_channel_unlock
ast_channel_unlock
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
break;
case IAX_COMMAND_UNQUELCH:
IAX_COMMAND_UNQUELCH
IAX_COMMAND_UNQUELCH
if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {					iax2_lock_owner(fr->callno);					if (!iaxs[fr->callno]) {						break;					}					/* Generate Manager Unhold event, if necessary */					if (iaxs[fr->callno]->owner && ast_test_flag64(iaxs[fr->callno], IAX_QUELCH)) {						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: Off\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}					ast_clear_flag64(iaxs[fr->callno], IAX_QUELCH);					if (!iaxs[fr->callno]->owner) {						break;					}					if (ast_bridged_channel(iaxs[fr->callno]->owner)) {						/*						 * We already hold the owner lock so we do not						 * need to check iaxs[fr->callno] after it returns.						 */						iax2_queue_control_data(fr->callno, AST_CONTROL_UNHOLD, NULL, 0);					}					ast_channel_unlock(iaxs[fr->callno]->owner);				}
ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
ast_test_flag
ast_test_flag
&iaxs[fr->callno]->state
iaxs[fr->callno]->state
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
state
IAX_STATE_STARTED
IAX_STATE_STARTED
{					iax2_lock_owner(fr->callno);					if (!iaxs[fr->callno]) {						break;					}					/* Generate Manager Unhold event, if necessary */					if (iaxs[fr->callno]->owner && ast_test_flag64(iaxs[fr->callno], IAX_QUELCH)) {						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: Off\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}					ast_clear_flag64(iaxs[fr->callno], IAX_QUELCH);					if (!iaxs[fr->callno]->owner) {						break;					}					if (ast_bridged_channel(iaxs[fr->callno]->owner)) {						/*						 * We already hold the owner lock so we do not						 * need to check iaxs[fr->callno] after it returns.						 */						iax2_queue_control_data(fr->callno, AST_CONTROL_UNHOLD, NULL, 0);					}					ast_channel_unlock(iaxs[fr->callno]->owner);				}
iax2_lock_owner(fr->callno);
iax2_lock_owner(fr->callno)
iax2_lock_owner
iax2_lock_owner
fr->callno
fr
fr
callno
if (!iaxs[fr->callno]) {						break;					}
!iaxs[fr->callno]
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{						break;					}
break;
if (iaxs[fr->callno]->owner && ast_test_flag64(iaxs[fr->callno], IAX_QUELCH)) {						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: Off\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}
iaxs[fr->callno]->owner && ast_test_flag64(iaxs[fr->callno], IAX_QUELCH)
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
ast_test_flag64(iaxs[fr->callno], IAX_QUELCH)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_QUELCH
IAX_QUELCH
{						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: Off\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}
ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: Off\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));
ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: Off\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner))
ast_manager_event
ast_manager_event
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
EVENT_FLAG_CALL
EVENT_FLAG_CALL
"Hold"
"Status: Off\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n"
ast_channel_name(iaxs[fr->callno]->owner)
ast_channel_name
ast_channel_name
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
ast_channel_uniqueid(iaxs[fr->callno]->owner)
ast_channel_uniqueid
ast_channel_uniqueid
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
ast_clear_flag64(iaxs[fr->callno], IAX_QUELCH);
ast_clear_flag64(iaxs[fr->callno], IAX_QUELCH)
ast_clear_flag64
ast_clear_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_QUELCH
IAX_QUELCH
if (!iaxs[fr->callno]->owner) {						break;					}
!iaxs[fr->callno]->owner
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
{						break;					}
break;
if (ast_bridged_channel(iaxs[fr->callno]->owner)) {						/*						 * We already hold the owner lock so we do not						 * need to check iaxs[fr->callno] after it returns.						 */						iax2_queue_control_data(fr->callno, AST_CONTROL_UNHOLD, NULL, 0);					}
ast_bridged_channel(iaxs[fr->callno]->owner)
ast_bridged_channel
ast_bridged_channel
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
{						/*						 * We already hold the owner lock so we do not						 * need to check iaxs[fr->callno] after it returns.						 */						iax2_queue_control_data(fr->callno, AST_CONTROL_UNHOLD, NULL, 0);					}
iax2_queue_control_data(fr->callno, AST_CONTROL_UNHOLD, NULL, 0);
iax2_queue_control_data(fr->callno, AST_CONTROL_UNHOLD, NULL, 0)
iax2_queue_control_data
iax2_queue_control_data
fr->callno
fr
fr
callno
AST_CONTROL_UNHOLD
AST_CONTROL_UNHOLD
NULL
NULL
0
ast_channel_unlock(iaxs[fr->callno]->owner);
ast_channel_unlock(iaxs[fr->callno]->owner)
ast_channel_unlock
ast_channel_unlock
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
break;
case IAX_COMMAND_TXACC:
IAX_COMMAND_TXACC
IAX_COMMAND_TXACC
if (iaxs[fr->callno]->transferring == TRANSFER_BEGIN) {					/* Ack the packet with the given timestamp */					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* Cancel any outstanding txcnt's */						if (cur->transfer) {							cur->retries = -1;						}					}					memset(&ied1, 0, sizeof(ied1));					iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->callno);					send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREADY, 0, ied1.buf, ied1.pos, -1);					iaxs[fr->callno]->transferring = TRANSFER_READY;				}
iaxs[fr->callno]->transferring == TRANSFER_BEGIN
iaxs[fr->callno]->transferring
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
transferring
TRANSFER_BEGIN
TRANSFER_BEGIN
{					/* Ack the packet with the given timestamp */					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* Cancel any outstanding txcnt's */						if (cur->transfer) {							cur->retries = -1;						}					}					memset(&ied1, 0, sizeof(ied1));					iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->callno);					send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREADY, 0, ied1.buf, ied1.pos, -1);					iaxs[fr->callno]->transferring = TRANSFER_READY;				}
AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list)
AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list)
AST_LIST_TRAVERSE
AST_LIST_TRAVERSE
&frame_queue[fr->callno]
frame_queue[fr->callno]
frame_queue
frame_queue
fr->callno
fr
fr
callno
cur
cur
list
list
)
{						/* Cancel any outstanding txcnt's */						if (cur->transfer) {							cur->retries = -1;						}					}
if (cur->transfer) {							cur->retries = -1;						}
cur->transfer
cur
cur
transfer
{							cur->retries = -1;						}
cur->retries = -1;
cur->retries = -1
cur->retries
cur
cur
retries
-1
1
memset(&ied1, 0, sizeof(ied1));
memset(&ied1, 0, sizeof(ied1))
memset
memset
&ied1
ied1
ied1
0
sizeof(ied1)
(ied1)
ied1
ied1
iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->callno);
iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->callno)
iax_ie_append_short
iax_ie_append_short
&ied1
ied1
ied1
IAX_IE_CALLNO
IAX_IE_CALLNO
iaxs[fr->callno]->callno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
callno
send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREADY, 0, ied1.buf, ied1.pos, -1);
send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREADY, 0, ied1.buf, ied1.pos, -1)
send_command
send_command
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_TXREADY
IAX_COMMAND_TXREADY
0
ied1.buf
ied1
ied1
buf
ied1.pos
ied1
ied1
pos
-1
1
iaxs[fr->callno]->transferring = TRANSFER_READY;
iaxs[fr->callno]->transferring = TRANSFER_READY
iaxs[fr->callno]->transferring
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
transferring
TRANSFER_READY
TRANSFER_READY
break;
case IAX_COMMAND_NEW:
IAX_COMMAND_NEW
IAX_COMMAND_NEW
if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD))					break;
ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)
ast_test_flag
ast_test_flag
&iaxs[fr->callno]->state
iaxs[fr->callno]->state
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
state
IAX_STATE_STARTED | IAX_STATE_TBD
IAX_STATE_STARTED
IAX_STATE_STARTED
IAX_STATE_TBD
IAX_STATE_TBD
break;
if (ies.provverpres && ies.serviceident && sin.sin_addr.s_addr) {					ast_mutex_unlock(&iaxsl[fr->callno]);					check_provisioning(&sin, fd, ies.serviceident, ies.provver);					ast_mutex_lock(&iaxsl[fr->callno]);					if (!iaxs[fr->callno]) {						break;					}				}
ies.provverpres && ies.serviceident && sin.sin_addr.s_addr
ies.provverpres && ies.serviceident
ies.provverpres
ies
ies
provverpres
ies.serviceident
ies
ies
serviceident
sin.sin_addr.s_addr
sin.sin_addr
sin
sin
sin_addr
s_addr
{					ast_mutex_unlock(&iaxsl[fr->callno]);					check_provisioning(&sin, fd, ies.serviceident, ies.provver);					ast_mutex_lock(&iaxsl[fr->callno]);					if (!iaxs[fr->callno]) {						break;					}				}
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock
ast_mutex_unlock
(&iaxsl[fr->callno])
&iaxsl[fr->callno]
&
iaxsl
[fr->callno]
fr->callno
fr
fr
callno
check_provisioning(&sin, fd, ies.serviceident, ies.provver);
check_provisioning(&sin, fd, ies.serviceident, ies.provver)
check_provisioning
check_provisioning
&sin
sin
sin
fd
fd
ies.serviceident
ies
ies
serviceident
ies.provver
ies
ies
provver
ast_mutex_lock(&iaxsl[fr->callno]);
ast_mutex_lock(&iaxsl[fr->callno])
ast_mutex_lock
ast_mutex_lock
&iaxsl[fr->callno]
iaxsl[fr->callno]
iaxsl
iaxsl
fr->callno
fr
fr
callno
if (!iaxs[fr->callno]) {						break;					}
!iaxs[fr->callno]
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{						break;					}
break;
if (ast_test_flag64(iaxs[fr->callno], IAX_TRUNK)) {					int new_callno;					if ((new_callno = make_trunk(fr->callno, 1)) != -1)						fr->callno = new_callno;				}
ast_test_flag64(iaxs[fr->callno], IAX_TRUNK)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_TRUNK
IAX_TRUNK
{					int new_callno;					if ((new_callno = make_trunk(fr->callno, 1)) != -1)						fr->callno = new_callno;				}
int new_callno;
int new_callno;
int
new_callno
new_callno
if ((new_callno = make_trunk(fr->callno, 1)) != -1)						fr->callno = new_callno;
(new_callno = make_trunk(fr->callno, 1)) != -1
(new_callno = make_trunk(fr->callno, 1))
new_callno = make_trunk(fr->callno, 1)
new_callno
new_callno
make_trunk(fr->callno, 1)
make_trunk
make_trunk
fr->callno
fr
fr
callno
1
-1
1
fr->callno = new_callno;
fr->callno = new_callno
fr->callno
fr
fr
callno
new_callno
new_callno
if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
delayreject
delayreject
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
send_command_immediate
send_command_immediate
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_ACK
IAX_COMMAND_ACK
fr->ts
fr
fr
ts
NULL
NULL
0
fr->iseqno
fr
fr
iseqno
if (check_access(fr->callno, &sin, &ies)) {					/* They're not allowed on */					auth_fail(fr->callno, IAX_COMMAND_REJECT);					if (authdebug)						ast_log(LOG_NOTICE, "Rejected connect attempt from %s, who was trying to reach '%s@%s'\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					break;				}
check_access(fr->callno, &sin, &ies)
check_access
check_access
fr->callno
fr
fr
callno
&sin
sin
sin
&ies
ies
ies
{					/* They're not allowed on */					auth_fail(fr->callno, IAX_COMMAND_REJECT);					if (authdebug)						ast_log(LOG_NOTICE, "Rejected connect attempt from %s, who was trying to reach '%s@%s'\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					break;				}
auth_fail(fr->callno, IAX_COMMAND_REJECT);
auth_fail(fr->callno, IAX_COMMAND_REJECT)
auth_fail
auth_fail
fr->callno
fr
fr
callno
IAX_COMMAND_REJECT
IAX_COMMAND_REJECT
if (authdebug)						ast_log(LOG_NOTICE, "Rejected connect attempt from %s, who was trying to reach '%s@%s'\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);
authdebug
authdebug
ast_log(LOG_NOTICE, "Rejected connect attempt from %s, who was trying to reach '%s@%s'\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);
ast_log(LOG_NOTICE, "Rejected connect attempt from %s, who was trying to reach '%s@%s'\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context)
ast_log
ast_log
LOG_NOTICE
LOG_NOTICE
"Rejected connect attempt from %s, who was trying to reach '%s@%s'\n"
ast_inet_ntoa(sin.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
sin.sin_addr
sin
sin
sin_addr
iaxs[fr->callno]->exten
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
exten
iaxs[fr->callno]->context
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
context
break;
if (ast_strlen_zero(iaxs[fr->callno]->secret) && ast_test_flag64(iaxs[fr->callno], IAX_FORCE_ENCRYPT)) {					auth_fail(fr->callno, IAX_COMMAND_REJECT);					ast_log(LOG_WARNING, "Rejected connect attempt.  No secret present while force encrypt enabled.\n");					break;				}
ast_strlen_zero(iaxs[fr->callno]->secret) && ast_test_flag64(iaxs[fr->callno], IAX_FORCE_ENCRYPT)
ast_strlen_zero(iaxs[fr->callno]->secret)
ast_strlen_zero
ast_strlen_zero
iaxs[fr->callno]->secret
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
secret
ast_test_flag64(iaxs[fr->callno], IAX_FORCE_ENCRYPT)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_FORCE_ENCRYPT
IAX_FORCE_ENCRYPT
{					auth_fail(fr->callno, IAX_COMMAND_REJECT);					ast_log(LOG_WARNING, "Rejected connect attempt.  No secret present while force encrypt enabled.\n");					break;				}
auth_fail(fr->callno, IAX_COMMAND_REJECT);
auth_fail(fr->callno, IAX_COMMAND_REJECT)
auth_fail
auth_fail
fr->callno
fr
fr
callno
IAX_COMMAND_REJECT
IAX_COMMAND_REJECT
ast_log(LOG_WARNING, "Rejected connect attempt.  No secret present while force encrypt enabled.\n");
ast_log(LOG_WARNING, "Rejected connect attempt.  No secret present while force encrypt enabled.\n")
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"Rejected connect attempt.  No secret present while force encrypt enabled.\n"
break;
if (strcasecmp(iaxs[fr->callno]->exten, "TBD")) {					const char *context, *exten, *cid_num;					context = ast_strdupa(iaxs[fr->callno]->context);					exten = ast_strdupa(iaxs[fr->callno]->exten);					cid_num = ast_strdupa(iaxs[fr->callno]->cid_num);					/* This might re-enter the IAX code and need the lock */					ast_mutex_unlock(&iaxsl[fr->callno]);					exists = ast_exists_extension(NULL, context, exten, 1, cid_num);					ast_mutex_lock(&iaxsl[fr->callno]);					if (!iaxs[fr->callno]) {						break;					}				} else					exists = 0;
strcasecmp(iaxs[fr->callno]->exten, "TBD")
strcasecmp
strcasecmp
iaxs[fr->callno]->exten
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
exten
"TBD"
{					const char *context, *exten, *cid_num;					context = ast_strdupa(iaxs[fr->callno]->context);					exten = ast_strdupa(iaxs[fr->callno]->exten);					cid_num = ast_strdupa(iaxs[fr->callno]->cid_num);					/* This might re-enter the IAX code and need the lock */					ast_mutex_unlock(&iaxsl[fr->callno]);					exists = ast_exists_extension(NULL, context, exten, 1, cid_num);					ast_mutex_lock(&iaxsl[fr->callno]);					if (!iaxs[fr->callno]) {						break;					}				}
const char *context, *exten, *cid_num;
const char *context, *exten, *cid_num;
const char
*context
*
context
*exten
*
exten
*cid_num
*
cid_num
context = ast_strdupa(iaxs[fr->callno]->context);
context = ast_strdupa(iaxs[fr->callno]->context)
context
context
ast_strdupa(iaxs[fr->callno]->context)
ast_strdupa
ast_strdupa
iaxs[fr->callno]->context
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
context
exten = ast_strdupa(iaxs[fr->callno]->exten);
exten = ast_strdupa(iaxs[fr->callno]->exten)
exten
exten
ast_strdupa(iaxs[fr->callno]->exten)
ast_strdupa
ast_strdupa
iaxs[fr->callno]->exten
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
exten
cid_num = ast_strdupa(iaxs[fr->callno]->cid_num);
cid_num = ast_strdupa(iaxs[fr->callno]->cid_num)
cid_num
cid_num
ast_strdupa(iaxs[fr->callno]->cid_num)
ast_strdupa
ast_strdupa
iaxs[fr->callno]->cid_num
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
cid_num
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock
ast_mutex_unlock
(&iaxsl[fr->callno])
&iaxsl[fr->callno]
&
iaxsl
[fr->callno]
fr->callno
fr
fr
callno
exists = ast_exists_extension(NULL, context, exten, 1, cid_num);
exists = ast_exists_extension(NULL, context, exten, 1, cid_num)
exists
exists
ast_exists_extension(NULL, context, exten, 1, cid_num)
ast_exists_extension
ast_exists_extension
NULL
NULL
context
context
exten
exten
1
cid_num
cid_num
ast_mutex_lock(&iaxsl[fr->callno]);
ast_mutex_lock(&iaxsl[fr->callno])
ast_mutex_lock
ast_mutex_lock
&iaxsl[fr->callno]
iaxsl[fr->callno]
iaxsl
iaxsl
fr->callno
fr
fr
callno
if (!iaxs[fr->callno]) {						break;					}
!iaxs[fr->callno]
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{						break;					}
break;
exists = 0;
exists = 0
exists
exists
0
save_osptoken(fr, &ies);
save_osptoken(fr, &ies)
save_osptoken
save_osptoken
fr
fr
&ies
ies
ies
if (ast_strlen_zero(iaxs[fr->callno]->secret) && ast_strlen_zero(iaxs[fr->callno]->inkeys)) {					if (strcmp(iaxs[fr->callno]->exten, "TBD") && !exists) {						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}						if (authdebug)							ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					} else {						/* Select an appropriate format */						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								using_prefs = "reqonly";							} else {								using_prefs = "disabled";							}							format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;							memset(&pref, 0, sizeof(pref));							strcpy(caller_pref_buf, "disabled");							strcpy(host_pref_buf, "disabled");						} else {							struct ast_format tmpfmt;							using_prefs = "mine";							/* If the information elements are in here... use them */							if (ies.codec_prefs)								ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);							if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {								/* If we are codec_first_choice we let the caller have the 1st shot at picking the codec.*/								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {									pref = iaxs[fr->callno]->rprefs;									using_prefs = "caller";								} else {									pref = iaxs[fr->callno]->prefs;								}							} else								pref = iaxs[fr->callno]->prefs;							format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);							ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);							ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);						}						if (!format) {							if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP))								format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;							if (!format) {								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}								if (authdebug) {									char tmp[256], tmp2[256], tmp3[256];									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}							} else {								/* Pick one... */								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))										format = 0;								} else {									if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {										using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";										memset(&pref, 0, sizeof(pref));										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);										strcpy(caller_pref_buf,"disabled");										strcpy(host_pref_buf,"disabled");									} else {										struct ast_format tmpfmt;										using_prefs = "mine";										if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {											/* Do the opposite of what we tried above. */											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);										} else /* if no codec_prefs IE do it the old way */											format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}								}								if (!format) {									char tmp[256], tmp2[256], tmp3[256];									memset(&ied0, 0, sizeof(ied0));									iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");									iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);									ast_log(LOG_ERROR, "No best format in '%s'???\n", iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));									send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);									if (!iaxs[fr->callno]) {										break;									}									if (authdebug) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}									ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);									break;								}							}						}						if (format) {							/* No authentication required, let them in */							memset(&ied1, 0, sizeof(ied1));							iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);							iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);							send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);							if (strcmp(iaxs[fr->callno]->exten, "TBD")) {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);								ast_verb(3, "Accepting UNAUTHENTICATED call from %s:\n"												"%srequested format = %s,\n"												"%srequested prefs = %s,\n"												"%sactual format = %s,\n"												"%shost prefs = %s,\n"												"%spriority = %s\n",												ast_inet_ntoa(sin.sin_addr), 												VERBOSE_PREFIX_4,												iax2_getformatname(iaxs[fr->callno]->peerformat), 												VERBOSE_PREFIX_4,												caller_pref_buf,												VERBOSE_PREFIX_4,												iax2_getformatname(format), 												VERBOSE_PREFIX_4,												host_pref_buf, 												VERBOSE_PREFIX_4,												using_prefs);								iaxs[fr->callno]->chosenformat = format;								/* Since this is a new call, we should go ahead and set the callid for it. */								iax_pvt_callid_new(fr->callno);								ast_set_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);							} else {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);								/* If this is a TBD call, we're ready but now what...  */								ast_verb(3, "Accepted unauthenticated TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							}						}					}					break;				}
ast_strlen_zero(iaxs[fr->callno]->secret) && ast_strlen_zero(iaxs[fr->callno]->inkeys)
ast_strlen_zero(iaxs[fr->callno]->secret)
ast_strlen_zero
ast_strlen_zero
iaxs[fr->callno]->secret
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
secret
ast_strlen_zero(iaxs[fr->callno]->inkeys)
ast_strlen_zero
ast_strlen_zero
iaxs[fr->callno]->inkeys
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
inkeys
{					if (strcmp(iaxs[fr->callno]->exten, "TBD") && !exists) {						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}						if (authdebug)							ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					} else {						/* Select an appropriate format */						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								using_prefs = "reqonly";							} else {								using_prefs = "disabled";							}							format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;							memset(&pref, 0, sizeof(pref));							strcpy(caller_pref_buf, "disabled");							strcpy(host_pref_buf, "disabled");						} else {							struct ast_format tmpfmt;							using_prefs = "mine";							/* If the information elements are in here... use them */							if (ies.codec_prefs)								ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);							if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {								/* If we are codec_first_choice we let the caller have the 1st shot at picking the codec.*/								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {									pref = iaxs[fr->callno]->rprefs;									using_prefs = "caller";								} else {									pref = iaxs[fr->callno]->prefs;								}							} else								pref = iaxs[fr->callno]->prefs;							format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);							ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);							ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);						}						if (!format) {							if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP))								format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;							if (!format) {								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}								if (authdebug) {									char tmp[256], tmp2[256], tmp3[256];									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}							} else {								/* Pick one... */								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))										format = 0;								} else {									if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {										using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";										memset(&pref, 0, sizeof(pref));										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);										strcpy(caller_pref_buf,"disabled");										strcpy(host_pref_buf,"disabled");									} else {										struct ast_format tmpfmt;										using_prefs = "mine";										if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {											/* Do the opposite of what we tried above. */											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);										} else /* if no codec_prefs IE do it the old way */											format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}								}								if (!format) {									char tmp[256], tmp2[256], tmp3[256];									memset(&ied0, 0, sizeof(ied0));									iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");									iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);									ast_log(LOG_ERROR, "No best format in '%s'???\n", iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));									send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);									if (!iaxs[fr->callno]) {										break;									}									if (authdebug) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}									ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);									break;								}							}						}						if (format) {							/* No authentication required, let them in */							memset(&ied1, 0, sizeof(ied1));							iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);							iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);							send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);							if (strcmp(iaxs[fr->callno]->exten, "TBD")) {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);								ast_verb(3, "Accepting UNAUTHENTICATED call from %s:\n"												"%srequested format = %s,\n"												"%srequested prefs = %s,\n"												"%sactual format = %s,\n"												"%shost prefs = %s,\n"												"%spriority = %s\n",												ast_inet_ntoa(sin.sin_addr), 												VERBOSE_PREFIX_4,												iax2_getformatname(iaxs[fr->callno]->peerformat), 												VERBOSE_PREFIX_4,												caller_pref_buf,												VERBOSE_PREFIX_4,												iax2_getformatname(format), 												VERBOSE_PREFIX_4,												host_pref_buf, 												VERBOSE_PREFIX_4,												using_prefs);								iaxs[fr->callno]->chosenformat = format;								/* Since this is a new call, we should go ahead and set the callid for it. */								iax_pvt_callid_new(fr->callno);								ast_set_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);							} else {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);								/* If this is a TBD call, we're ready but now what...  */								ast_verb(3, "Accepted unauthenticated TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							}						}					}					break;				}
if (strcmp(iaxs[fr->callno]->exten, "TBD") && !exists) {						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}						if (authdebug)							ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					} else {						/* Select an appropriate format */						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								using_prefs = "reqonly";							} else {								using_prefs = "disabled";							}							format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;							memset(&pref, 0, sizeof(pref));							strcpy(caller_pref_buf, "disabled");							strcpy(host_pref_buf, "disabled");						} else {							struct ast_format tmpfmt;							using_prefs = "mine";							/* If the information elements are in here... use them */							if (ies.codec_prefs)								ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);							if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {								/* If we are codec_first_choice we let the caller have the 1st shot at picking the codec.*/								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {									pref = iaxs[fr->callno]->rprefs;									using_prefs = "caller";								} else {									pref = iaxs[fr->callno]->prefs;								}							} else								pref = iaxs[fr->callno]->prefs;							format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);							ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);							ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);						}						if (!format) {							if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP))								format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;							if (!format) {								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}								if (authdebug) {									char tmp[256], tmp2[256], tmp3[256];									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}							} else {								/* Pick one... */								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))										format = 0;								} else {									if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {										using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";										memset(&pref, 0, sizeof(pref));										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);										strcpy(caller_pref_buf,"disabled");										strcpy(host_pref_buf,"disabled");									} else {										struct ast_format tmpfmt;										using_prefs = "mine";										if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {											/* Do the opposite of what we tried above. */											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);										} else /* if no codec_prefs IE do it the old way */											format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}								}								if (!format) {									char tmp[256], tmp2[256], tmp3[256];									memset(&ied0, 0, sizeof(ied0));									iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");									iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);									ast_log(LOG_ERROR, "No best format in '%s'???\n", iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));									send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);									if (!iaxs[fr->callno]) {										break;									}									if (authdebug) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}									ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);									break;								}							}						}						if (format) {							/* No authentication required, let them in */							memset(&ied1, 0, sizeof(ied1));							iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);							iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);							send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);							if (strcmp(iaxs[fr->callno]->exten, "TBD")) {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);								ast_verb(3, "Accepting UNAUTHENTICATED call from %s:\n"												"%srequested format = %s,\n"												"%srequested prefs = %s,\n"												"%sactual format = %s,\n"												"%shost prefs = %s,\n"												"%spriority = %s\n",												ast_inet_ntoa(sin.sin_addr), 												VERBOSE_PREFIX_4,												iax2_getformatname(iaxs[fr->callno]->peerformat), 												VERBOSE_PREFIX_4,												caller_pref_buf,												VERBOSE_PREFIX_4,												iax2_getformatname(format), 												VERBOSE_PREFIX_4,												host_pref_buf, 												VERBOSE_PREFIX_4,												using_prefs);								iaxs[fr->callno]->chosenformat = format;								/* Since this is a new call, we should go ahead and set the callid for it. */								iax_pvt_callid_new(fr->callno);								ast_set_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);							} else {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);								/* If this is a TBD call, we're ready but now what...  */								ast_verb(3, "Accepted unauthenticated TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							}						}					}
strcmp(iaxs[fr->callno]->exten, "TBD") && !exists
strcmp(iaxs[fr->callno]->exten, "TBD")
strcmp
strcmp
iaxs[fr->callno]->exten
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
exten
"TBD"
!exists
exists
exists
{						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}						if (authdebug)							ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					}
memset(&ied0, 0, sizeof(ied0));
memset(&ied0, 0, sizeof(ied0))
memset
memset
&ied0
ied0
ied0
0
sizeof(ied0)
(ied0)
ied0
ied0
iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");
iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension")
iax_ie_append_str
iax_ie_append_str
&ied0
ied0
ied0
IAX_IE_CAUSE
IAX_IE_CAUSE
"No such context/extension"
iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);
iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION)
iax_ie_append_byte
iax_ie_append_byte
&ied0
ied0
ied0
IAX_IE_CAUSECODE
IAX_IE_CAUSECODE
AST_CAUSE_NO_ROUTE_DESTINATION
AST_CAUSE_NO_ROUTE_DESTINATION
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1)
send_command_final
send_command_final
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_REJECT
IAX_COMMAND_REJECT
0
ied0.buf
ied0
ied0
buf
ied0.pos
ied0
ied0
pos
-1
1
if (!iaxs[fr->callno]) {							break;						}
!iaxs[fr->callno]
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{							break;						}
break;
if (authdebug)							ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);
authdebug
authdebug
ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);
ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context)
ast_log
ast_log
LOG_NOTICE
LOG_NOTICE
"Rejected connect attempt from %s, request '%s@%s' does not exist\n"
ast_inet_ntoa(sin.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
sin.sin_addr
sin
sin
sin_addr
iaxs[fr->callno]->exten
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
exten
iaxs[fr->callno]->context
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
context
{						/* Select an appropriate format */						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								using_prefs = "reqonly";							} else {								using_prefs = "disabled";							}							format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;							memset(&pref, 0, sizeof(pref));							strcpy(caller_pref_buf, "disabled");							strcpy(host_pref_buf, "disabled");						} else {							struct ast_format tmpfmt;							using_prefs = "mine";							/* If the information elements are in here... use them */							if (ies.codec_prefs)								ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);							if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {								/* If we are codec_first_choice we let the caller have the 1st shot at picking the codec.*/								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {									pref = iaxs[fr->callno]->rprefs;									using_prefs = "caller";								} else {									pref = iaxs[fr->callno]->prefs;								}							} else								pref = iaxs[fr->callno]->prefs;							format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);							ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);							ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);						}						if (!format) {							if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP))								format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;							if (!format) {								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}								if (authdebug) {									char tmp[256], tmp2[256], tmp3[256];									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}							} else {								/* Pick one... */								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))										format = 0;								} else {									if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {										using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";										memset(&pref, 0, sizeof(pref));										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);										strcpy(caller_pref_buf,"disabled");										strcpy(host_pref_buf,"disabled");									} else {										struct ast_format tmpfmt;										using_prefs = "mine";										if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {											/* Do the opposite of what we tried above. */											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);										} else /* if no codec_prefs IE do it the old way */											format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}								}								if (!format) {									char tmp[256], tmp2[256], tmp3[256];									memset(&ied0, 0, sizeof(ied0));									iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");									iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);									ast_log(LOG_ERROR, "No best format in '%s'???\n", iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));									send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);									if (!iaxs[fr->callno]) {										break;									}									if (authdebug) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}									ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);									break;								}							}						}						if (format) {							/* No authentication required, let them in */							memset(&ied1, 0, sizeof(ied1));							iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);							iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);							send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);							if (strcmp(iaxs[fr->callno]->exten, "TBD")) {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);								ast_verb(3, "Accepting UNAUTHENTICATED call from %s:\n"												"%srequested format = %s,\n"												"%srequested prefs = %s,\n"												"%sactual format = %s,\n"												"%shost prefs = %s,\n"												"%spriority = %s\n",												ast_inet_ntoa(sin.sin_addr), 												VERBOSE_PREFIX_4,												iax2_getformatname(iaxs[fr->callno]->peerformat), 												VERBOSE_PREFIX_4,												caller_pref_buf,												VERBOSE_PREFIX_4,												iax2_getformatname(format), 												VERBOSE_PREFIX_4,												host_pref_buf, 												VERBOSE_PREFIX_4,												using_prefs);								iaxs[fr->callno]->chosenformat = format;								/* Since this is a new call, we should go ahead and set the callid for it. */								iax_pvt_callid_new(fr->callno);								ast_set_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);							} else {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);								/* If this is a TBD call, we're ready but now what...  */								ast_verb(3, "Accepted unauthenticated TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							}						}					}
if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								using_prefs = "reqonly";							} else {								using_prefs = "disabled";							}							format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;							memset(&pref, 0, sizeof(pref));							strcpy(caller_pref_buf, "disabled");							strcpy(host_pref_buf, "disabled");						} else {							struct ast_format tmpfmt;							using_prefs = "mine";							/* If the information elements are in here... use them */							if (ies.codec_prefs)								ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);							if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {								/* If we are codec_first_choice we let the caller have the 1st shot at picking the codec.*/								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {									pref = iaxs[fr->callno]->rprefs;									using_prefs = "caller";								} else {									pref = iaxs[fr->callno]->prefs;								}							} else								pref = iaxs[fr->callno]->prefs;							format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);							ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);							ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);						}
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_CODEC_NOPREFS
IAX_CODEC_NOPREFS
{							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								using_prefs = "reqonly";							} else {								using_prefs = "disabled";							}							format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;							memset(&pref, 0, sizeof(pref));							strcpy(caller_pref_buf, "disabled");							strcpy(host_pref_buf, "disabled");						}
if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								using_prefs = "reqonly";							} else {								using_prefs = "disabled";							}
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_CODEC_NOCAP
IAX_CODEC_NOCAP
{								using_prefs = "reqonly";							}
using_prefs = "reqonly";
using_prefs = "reqonly"
using_prefs
using_prefs
"reqonly"
{								using_prefs = "disabled";							}
using_prefs = "disabled";
using_prefs = "disabled"
using_prefs
using_prefs
"disabled"
format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;
format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability
format
format
iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
memset(&pref, 0, sizeof(pref));
memset(&pref, 0, sizeof(pref))
memset
memset
&pref
pref
pref
0
sizeof(pref)
(pref)
pref
pref
strcpy(caller_pref_buf, "disabled");
strcpy(caller_pref_buf, "disabled")
strcpy
strcpy
caller_pref_buf
caller_pref_buf
"disabled"
strcpy(host_pref_buf, "disabled");
strcpy(host_pref_buf, "disabled")
strcpy
strcpy
host_pref_buf
host_pref_buf
"disabled"
{							struct ast_format tmpfmt;							using_prefs = "mine";							/* If the information elements are in here... use them */							if (ies.codec_prefs)								ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);							if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {								/* If we are codec_first_choice we let the caller have the 1st shot at picking the codec.*/								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {									pref = iaxs[fr->callno]->rprefs;									using_prefs = "caller";								} else {									pref = iaxs[fr->callno]->prefs;								}							} else								pref = iaxs[fr->callno]->prefs;							format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);							ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);							ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);						}
struct ast_format tmpfmt;
struct ast_format tmpfmt;
struct ast_format
ast_format
tmpfmt
tmpfmt
using_prefs = "mine";
using_prefs = "mine"
using_prefs
using_prefs
"mine"
if (ies.codec_prefs)								ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);
ies.codec_prefs
ies
ies
codec_prefs
ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);
ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0)
ast_codec_pref_convert
ast_codec_pref_convert
&iaxs[fr->callno]->rprefs
iaxs[fr->callno]->rprefs
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
rprefs
ies.codec_prefs
ies
ies
codec_prefs
32
0
if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {								/* If we are codec_first_choice we let the caller have the 1st shot at picking the codec.*/								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {									pref = iaxs[fr->callno]->rprefs;									using_prefs = "caller";								} else {									pref = iaxs[fr->callno]->prefs;								}							} else								pref = iaxs[fr->callno]->prefs;
ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)
ast_codec_pref_index
ast_codec_pref_index
&iaxs[fr->callno]->rprefs
iaxs[fr->callno]->rprefs
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
rprefs
0
&tmpfmt
tmpfmt
tmpfmt
{								/* If we are codec_first_choice we let the caller have the 1st shot at picking the codec.*/								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {									pref = iaxs[fr->callno]->rprefs;									using_prefs = "caller";								} else {									pref = iaxs[fr->callno]->prefs;								}							}
if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {									pref = iaxs[fr->callno]->rprefs;									using_prefs = "caller";								} else {									pref = iaxs[fr->callno]->prefs;								}
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_CODEC_USER_FIRST
IAX_CODEC_USER_FIRST
{									pref = iaxs[fr->callno]->rprefs;									using_prefs = "caller";								}
pref = iaxs[fr->callno]->rprefs;
pref = iaxs[fr->callno]->rprefs
pref
pref
iaxs[fr->callno]->rprefs
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
rprefs
using_prefs = "caller";
using_prefs = "caller"
using_prefs
using_prefs
"caller"
{									pref = iaxs[fr->callno]->prefs;								}
pref = iaxs[fr->callno]->prefs;
pref = iaxs[fr->callno]->prefs
pref
pref
iaxs[fr->callno]->prefs
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
prefs
pref = iaxs[fr->callno]->prefs;
pref = iaxs[fr->callno]->prefs
pref
pref
iaxs[fr->callno]->prefs
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
prefs
format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);
format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0)
format
format
iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0)
iax2_codec_choose
iax2_codec_choose
&pref
pref
pref
iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
iaxs[fr->callno]->peercapability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercapability
0
ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);
ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1)
ast_codec_pref_string
ast_codec_pref_string
&iaxs[fr->callno]->rprefs
iaxs[fr->callno]->rprefs
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
rprefs
caller_pref_buf
caller_pref_buf
sizeof(caller_pref_buf) - 1
sizeof(caller_pref_buf)
(caller_pref_buf)
caller_pref_buf
caller_pref_buf
1
ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);
ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1)
ast_codec_pref_string
ast_codec_pref_string
&iaxs[fr->callno]->prefs
iaxs[fr->callno]->prefs
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
prefs
host_pref_buf
host_pref_buf
sizeof(host_pref_buf) - 1
sizeof(host_pref_buf)
(host_pref_buf)
host_pref_buf
host_pref_buf
1
if (!format) {							if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP))								format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;							if (!format) {								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}								if (authdebug) {									char tmp[256], tmp2[256], tmp3[256];									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}							} else {								/* Pick one... */								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))										format = 0;								} else {									if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {										using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";										memset(&pref, 0, sizeof(pref));										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);										strcpy(caller_pref_buf,"disabled");										strcpy(host_pref_buf,"disabled");									} else {										struct ast_format tmpfmt;										using_prefs = "mine";										if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {											/* Do the opposite of what we tried above. */											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);										} else /* if no codec_prefs IE do it the old way */											format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}								}								if (!format) {									char tmp[256], tmp2[256], tmp3[256];									memset(&ied0, 0, sizeof(ied0));									iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");									iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);									ast_log(LOG_ERROR, "No best format in '%s'???\n", iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));									send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);									if (!iaxs[fr->callno]) {										break;									}									if (authdebug) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}									ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);									break;								}							}						}
!format
format
format
{							if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP))								format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;							if (!format) {								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}								if (authdebug) {									char tmp[256], tmp2[256], tmp3[256];									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}							} else {								/* Pick one... */								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))										format = 0;								} else {									if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {										using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";										memset(&pref, 0, sizeof(pref));										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);										strcpy(caller_pref_buf,"disabled");										strcpy(host_pref_buf,"disabled");									} else {										struct ast_format tmpfmt;										using_prefs = "mine";										if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {											/* Do the opposite of what we tried above. */											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);										} else /* if no codec_prefs IE do it the old way */											format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}								}								if (!format) {									char tmp[256], tmp2[256], tmp3[256];									memset(&ied0, 0, sizeof(ied0));									iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");									iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);									ast_log(LOG_ERROR, "No best format in '%s'???\n", iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));									send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);									if (!iaxs[fr->callno]) {										break;									}									if (authdebug) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}									ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);									break;								}							}						}
if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP))								format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;
!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_CODEC_NOCAP
IAX_CODEC_NOCAP
format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;
format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability
format
format
iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability
iaxs[fr->callno]->peercapability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercapability
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
if (!format) {								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}								if (authdebug) {									char tmp[256], tmp2[256], tmp3[256];									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}							} else {								/* Pick one... */								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))										format = 0;								} else {									if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {										using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";										memset(&pref, 0, sizeof(pref));										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);										strcpy(caller_pref_buf,"disabled");										strcpy(host_pref_buf,"disabled");									} else {										struct ast_format tmpfmt;										using_prefs = "mine";										if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {											/* Do the opposite of what we tried above. */											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);										} else /* if no codec_prefs IE do it the old way */											format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}								}								if (!format) {									char tmp[256], tmp2[256], tmp3[256];									memset(&ied0, 0, sizeof(ied0));									iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");									iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);									ast_log(LOG_ERROR, "No best format in '%s'???\n", iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));									send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);									if (!iaxs[fr->callno]) {										break;									}									if (authdebug) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}									ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);									break;								}							}
!format
format
format
{								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}								if (authdebug) {									char tmp[256], tmp2[256], tmp3[256];									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}							}
memset(&ied0, 0, sizeof(ied0));
memset(&ied0, 0, sizeof(ied0))
memset
memset
&ied0
ied0
ied0
0
sizeof(ied0)
(ied0)
ied0
ied0
iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");
iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec")
iax_ie_append_str
iax_ie_append_str
&ied0
ied0
ied0
IAX_IE_CAUSE
IAX_IE_CAUSE
"Unable to negotiate codec"
iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);
iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL)
iax_ie_append_byte
iax_ie_append_byte
&ied0
ied0
ied0
IAX_IE_CAUSECODE
IAX_IE_CAUSECODE
AST_CAUSE_BEARERCAPABILITY_NOTAVAIL
AST_CAUSE_BEARERCAPABILITY_NOTAVAIL
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1)
send_command_final
send_command_final
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_REJECT
IAX_COMMAND_REJECT
0
ied0.buf
ied0
ied0
buf
ied0.pos
ied0
ied0
pos
-1
1
if (!iaxs[fr->callno]) {									break;								}
!iaxs[fr->callno]
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{									break;								}
break;
if (authdebug) {									char tmp[256], tmp2[256], tmp3[256];									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}
authdebug
authdebug
{									char tmp[256], tmp2[256], tmp3[256];									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}
char tmp[256], tmp2[256], tmp3[256];
char tmp[256], tmp2[256], tmp3[256];
char
tmp[256]
tmp
[256]
256
tmp2[256]
tmp2
[256]
256
tmp3[256]
tmp3
[256]
256
if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_CODEC_NOCAP
IAX_CODEC_NOCAP
{										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									}
ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));
ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability))
ast_log
ast_log
LOG_NOTICE
LOG_NOTICE
"Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n"
ast_inet_ntoa(sin.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
sin.sin_addr
sin
sin
sin_addr
iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp
tmp
sizeof(tmp)
(tmp)
tmp
tmp
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp2
tmp2
sizeof(tmp2)
(tmp2)
tmp2
tmp2
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
{										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}
ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));
ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability))
ast_log
ast_log
LOG_NOTICE
LOG_NOTICE
"Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n"
ast_inet_ntoa(sin.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
sin.sin_addr
sin
sin
sin_addr
iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp
tmp
sizeof(tmp)
(tmp)
tmp
tmp
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp2
tmp2
sizeof(tmp2)
(tmp2)
tmp2
tmp2
iaxs[fr->callno]->peercapability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercapability
iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp3
tmp3
sizeof(tmp3)
(tmp3)
tmp3
tmp3
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
{								/* Pick one... */								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))										format = 0;								} else {									if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {										using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";										memset(&pref, 0, sizeof(pref));										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);										strcpy(caller_pref_buf,"disabled");										strcpy(host_pref_buf,"disabled");									} else {										struct ast_format tmpfmt;										using_prefs = "mine";										if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {											/* Do the opposite of what we tried above. */											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);										} else /* if no codec_prefs IE do it the old way */											format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}								}								if (!format) {									char tmp[256], tmp2[256], tmp3[256];									memset(&ied0, 0, sizeof(ied0));									iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");									iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);									ast_log(LOG_ERROR, "No best format in '%s'???\n", iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));									send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);									if (!iaxs[fr->callno]) {										break;									}									if (authdebug) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}									ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);									break;								}							}
if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))										format = 0;								} else {									if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {										using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";										memset(&pref, 0, sizeof(pref));										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);										strcpy(caller_pref_buf,"disabled");										strcpy(host_pref_buf,"disabled");									} else {										struct ast_format tmpfmt;										using_prefs = "mine";										if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {											/* Do the opposite of what we tried above. */											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);										} else /* if no codec_prefs IE do it the old way */											format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}								}
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_CODEC_NOCAP
IAX_CODEC_NOCAP
{									if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))										format = 0;								}
if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))										format = 0;
!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)
(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)
iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
format = 0;
format = 0
format
format
0
{									if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {										using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";										memset(&pref, 0, sizeof(pref));										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);										strcpy(caller_pref_buf,"disabled");										strcpy(host_pref_buf,"disabled");									} else {										struct ast_format tmpfmt;										using_prefs = "mine";										if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {											/* Do the opposite of what we tried above. */											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);										} else /* if no codec_prefs IE do it the old way */											format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}								}
if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {										using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";										memset(&pref, 0, sizeof(pref));										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);										strcpy(caller_pref_buf,"disabled");										strcpy(host_pref_buf,"disabled");									} else {										struct ast_format tmpfmt;										using_prefs = "mine";										if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {											/* Do the opposite of what we tried above. */											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);										} else /* if no codec_prefs IE do it the old way */											format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_CODEC_NOPREFS
IAX_CODEC_NOPREFS
{										using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";										memset(&pref, 0, sizeof(pref));										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);										strcpy(caller_pref_buf,"disabled");										strcpy(host_pref_buf,"disabled");									}
using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";
using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled"
using_prefs
using_prefs
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled"
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_CODEC_NOCAP
IAX_CODEC_NOCAP
"reqonly"
"disabled"
memset(&pref, 0, sizeof(pref));
memset(&pref, 0, sizeof(pref))
memset
memset
&pref
pref
pref
0
sizeof(pref)
(pref)
pref
pref
format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);
format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
format
format
iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
iax2_best_codec
iax2_best_codec
iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability
iaxs[fr->callno]->peercapability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercapability
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
strcpy(caller_pref_buf,"disabled");
strcpy(caller_pref_buf,"disabled")
strcpy
strcpy
caller_pref_buf
caller_pref_buf
"disabled"
strcpy(host_pref_buf,"disabled");
strcpy(host_pref_buf,"disabled")
strcpy
strcpy
host_pref_buf
host_pref_buf
"disabled"
{										struct ast_format tmpfmt;										using_prefs = "mine";										if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {											/* Do the opposite of what we tried above. */											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);										} else /* if no codec_prefs IE do it the old way */											format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}
struct ast_format tmpfmt;
struct ast_format tmpfmt;
struct ast_format
ast_format
tmpfmt
tmpfmt
using_prefs = "mine";
using_prefs = "mine"
using_prefs
using_prefs
"mine"
if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {											/* Do the opposite of what we tried above. */											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);										} else /* if no codec_prefs IE do it the old way */											format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);
ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)
ast_codec_pref_index
ast_codec_pref_index
&iaxs[fr->callno]->rprefs
iaxs[fr->callno]->rprefs
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
rprefs
0
&tmpfmt
tmpfmt
tmpfmt
{											/* Do the opposite of what we tried above. */											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);										}
if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_CODEC_USER_FIRST
IAX_CODEC_USER_FIRST
{												pref = iaxs[fr->callno]->prefs;											}
pref = iaxs[fr->callno]->prefs;
pref = iaxs[fr->callno]->prefs
pref
pref
iaxs[fr->callno]->prefs
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
prefs
{												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}
pref = iaxs[fr->callno]->rprefs;
pref = iaxs[fr->callno]->rprefs
pref
pref
iaxs[fr->callno]->rprefs
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
rprefs
using_prefs = "caller";
using_prefs = "caller"
using_prefs
using_prefs
"caller"
format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);
format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1)
format
format
iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1)
iax2_codec_choose
iax2_codec_choose
&pref
pref
pref
iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability
iaxs[fr->callno]->peercapability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercapability
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
1
format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);
format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
format
format
iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
iax2_best_codec
iax2_best_codec
iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability
iaxs[fr->callno]->peercapability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercapability
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
if (!format) {									char tmp[256], tmp2[256], tmp3[256];									memset(&ied0, 0, sizeof(ied0));									iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");									iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);									ast_log(LOG_ERROR, "No best format in '%s'???\n", iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));									send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);									if (!iaxs[fr->callno]) {										break;									}									if (authdebug) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}									ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);									break;								}
!format
format
format
{									char tmp[256], tmp2[256], tmp3[256];									memset(&ied0, 0, sizeof(ied0));									iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");									iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);									ast_log(LOG_ERROR, "No best format in '%s'???\n", iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));									send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);									if (!iaxs[fr->callno]) {										break;									}									if (authdebug) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}									ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);									break;								}
char tmp[256], tmp2[256], tmp3[256];
char tmp[256], tmp2[256], tmp3[256];
char
tmp[256]
tmp
[256]
256
tmp2[256]
tmp2
[256]
256
tmp3[256]
tmp3
[256]
256
memset(&ied0, 0, sizeof(ied0));
memset(&ied0, 0, sizeof(ied0))
memset
memset
&ied0
ied0
ied0
0
sizeof(ied0)
(ied0)
ied0
ied0
iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");
iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec")
iax_ie_append_str
iax_ie_append_str
&ied0
ied0
ied0
IAX_IE_CAUSE
IAX_IE_CAUSE
"Unable to negotiate codec"
iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);
iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL)
iax_ie_append_byte
iax_ie_append_byte
&ied0
ied0
ied0
IAX_IE_CAUSECODE
IAX_IE_CAUSECODE
AST_CAUSE_BEARERCAPABILITY_NOTAVAIL
AST_CAUSE_BEARERCAPABILITY_NOTAVAIL
ast_log(LOG_ERROR, "No best format in '%s'???\n", iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));
ast_log(LOG_ERROR, "No best format in '%s'???\n", iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability))
ast_log
ast_log
LOG_ERROR
LOG_ERROR
"No best format in '%s'???\n"
iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp
tmp
sizeof(tmp)
(tmp)
tmp
tmp
iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability
iaxs[fr->callno]->peercapability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercapability
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1)
send_command_final
send_command_final
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_REJECT
IAX_COMMAND_REJECT
0
ied0.buf
ied0
ied0
buf
ied0.pos
ied0
ied0
pos
-1
1
if (!iaxs[fr->callno]) {										break;									}
!iaxs[fr->callno]
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{										break;									}
break;
if (authdebug) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}
authdebug
authdebug
{										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}
ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));
ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability))
ast_log
ast_log
LOG_NOTICE
LOG_NOTICE
"Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n"
ast_inet_ntoa(sin.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
sin.sin_addr
sin
sin
sin_addr
iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp
tmp
sizeof(tmp)
(tmp)
tmp
tmp
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp2
tmp2
sizeof(tmp2)
(tmp2)
tmp2
tmp2
iaxs[fr->callno]->peercapability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercapability
iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp3
tmp3
sizeof(tmp3)
(tmp3)
tmp3
tmp3
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);
ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE)
ast_set_flag64
ast_set_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_ALREADYGONE
IAX_ALREADYGONE
break;
if (format) {							/* No authentication required, let them in */							memset(&ied1, 0, sizeof(ied1));							iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);							iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);							send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);							if (strcmp(iaxs[fr->callno]->exten, "TBD")) {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);								ast_verb(3, "Accepting UNAUTHENTICATED call from %s:\n"												"%srequested format = %s,\n"												"%srequested prefs = %s,\n"												"%sactual format = %s,\n"												"%shost prefs = %s,\n"												"%spriority = %s\n",												ast_inet_ntoa(sin.sin_addr), 												VERBOSE_PREFIX_4,												iax2_getformatname(iaxs[fr->callno]->peerformat), 												VERBOSE_PREFIX_4,												caller_pref_buf,												VERBOSE_PREFIX_4,												iax2_getformatname(format), 												VERBOSE_PREFIX_4,												host_pref_buf, 												VERBOSE_PREFIX_4,												using_prefs);								iaxs[fr->callno]->chosenformat = format;								/* Since this is a new call, we should go ahead and set the callid for it. */								iax_pvt_callid_new(fr->callno);								ast_set_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);							} else {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);								/* If this is a TBD call, we're ready but now what...  */								ast_verb(3, "Accepted unauthenticated TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							}						}
format
format
{							/* No authentication required, let them in */							memset(&ied1, 0, sizeof(ied1));							iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);							iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);							send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);							if (strcmp(iaxs[fr->callno]->exten, "TBD")) {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);								ast_verb(3, "Accepting UNAUTHENTICATED call from %s:\n"												"%srequested format = %s,\n"												"%srequested prefs = %s,\n"												"%sactual format = %s,\n"												"%shost prefs = %s,\n"												"%spriority = %s\n",												ast_inet_ntoa(sin.sin_addr), 												VERBOSE_PREFIX_4,												iax2_getformatname(iaxs[fr->callno]->peerformat), 												VERBOSE_PREFIX_4,												caller_pref_buf,												VERBOSE_PREFIX_4,												iax2_getformatname(format), 												VERBOSE_PREFIX_4,												host_pref_buf, 												VERBOSE_PREFIX_4,												using_prefs);								iaxs[fr->callno]->chosenformat = format;								/* Since this is a new call, we should go ahead and set the callid for it. */								iax_pvt_callid_new(fr->callno);								ast_set_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);							} else {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);								/* If this is a TBD call, we're ready but now what...  */								ast_verb(3, "Accepted unauthenticated TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							}						}
memset(&ied1, 0, sizeof(ied1));
memset(&ied1, 0, sizeof(ied1))
memset
memset
&ied1
ied1
ied1
0
sizeof(ied1)
(ied1)
ied1
ied1
iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);
iax_ie_append_int(&ied1, IAX_IE_FORMAT, format)
iax_ie_append_int
iax_ie_append_int
&ied1
ied1
ied1
IAX_IE_FORMAT
IAX_IE_FORMAT
format
format
iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);
iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format)
iax_ie_append_versioned_uint64
iax_ie_append_versioned_uint64
&ied1
ied1
ied1
IAX_IE_FORMAT2
IAX_IE_FORMAT2
0
format
format
send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);
send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1)
send_command
send_command
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_ACCEPT
IAX_COMMAND_ACCEPT
0
ied1.buf
ied1
ied1
buf
ied1.pos
ied1
ied1
pos
-1
1
if (strcmp(iaxs[fr->callno]->exten, "TBD")) {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);								ast_verb(3, "Accepting UNAUTHENTICATED call from %s:\n"												"%srequested format = %s,\n"												"%srequested prefs = %s,\n"												"%sactual format = %s,\n"												"%shost prefs = %s,\n"												"%spriority = %s\n",												ast_inet_ntoa(sin.sin_addr), 												VERBOSE_PREFIX_4,												iax2_getformatname(iaxs[fr->callno]->peerformat), 												VERBOSE_PREFIX_4,												caller_pref_buf,												VERBOSE_PREFIX_4,												iax2_getformatname(format), 												VERBOSE_PREFIX_4,												host_pref_buf, 												VERBOSE_PREFIX_4,												using_prefs);								iaxs[fr->callno]->chosenformat = format;								/* Since this is a new call, we should go ahead and set the callid for it. */								iax_pvt_callid_new(fr->callno);								ast_set_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);							} else {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);								/* If this is a TBD call, we're ready but now what...  */								ast_verb(3, "Accepted unauthenticated TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							}
strcmp(iaxs[fr->callno]->exten, "TBD")
strcmp
strcmp
iaxs[fr->callno]->exten
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
exten
"TBD"
{								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);								ast_verb(3, "Accepting UNAUTHENTICATED call from %s:\n"												"%srequested format = %s,\n"												"%srequested prefs = %s,\n"												"%sactual format = %s,\n"												"%shost prefs = %s,\n"												"%spriority = %s\n",												ast_inet_ntoa(sin.sin_addr), 												VERBOSE_PREFIX_4,												iax2_getformatname(iaxs[fr->callno]->peerformat), 												VERBOSE_PREFIX_4,												caller_pref_buf,												VERBOSE_PREFIX_4,												iax2_getformatname(format), 												VERBOSE_PREFIX_4,												host_pref_buf, 												VERBOSE_PREFIX_4,												using_prefs);								iaxs[fr->callno]->chosenformat = format;								/* Since this is a new call, we should go ahead and set the callid for it. */								iax_pvt_callid_new(fr->callno);								ast_set_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);							}
ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);
ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
ast_set_flag
ast_set_flag
&iaxs[fr->callno]->state
iaxs[fr->callno]->state
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
state
IAX_STATE_STARTED
IAX_STATE_STARTED
ast_verb(3, "Accepting UNAUTHENTICATED call from %s:\n"												"%srequested format = %s,\n"												"%srequested prefs = %s,\n"												"%sactual format = %s,\n"												"%shost prefs = %s,\n"												"%spriority = %s\n",												ast_inet_ntoa(sin.sin_addr), 												VERBOSE_PREFIX_4,												iax2_getformatname(iaxs[fr->callno]->peerformat), 												VERBOSE_PREFIX_4,												caller_pref_buf,												VERBOSE_PREFIX_4,												iax2_getformatname(format), 												VERBOSE_PREFIX_4,												host_pref_buf, 												VERBOSE_PREFIX_4,												using_prefs);
ast_verb(3, "Accepting UNAUTHENTICATED call from %s:\n"												"%srequested format = %s,\n"												"%srequested prefs = %s,\n"												"%sactual format = %s,\n"												"%shost prefs = %s,\n"												"%spriority = %s\n",												ast_inet_ntoa(sin.sin_addr), 												VERBOSE_PREFIX_4,												iax2_getformatname(iaxs[fr->callno]->peerformat), 												VERBOSE_PREFIX_4,												caller_pref_buf,												VERBOSE_PREFIX_4,												iax2_getformatname(format), 												VERBOSE_PREFIX_4,												host_pref_buf, 												VERBOSE_PREFIX_4,												using_prefs)
ast_verb
ast_verb
3
"Accepting UNAUTHENTICATED call from %s:\n"												"%srequested format = %s,\n"												"%srequested prefs = %s,\n"												"%sactual format = %s,\n"												"%shost prefs = %s,\n"												"%spriority = %s\n"
ast_inet_ntoa(sin.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
sin.sin_addr
sin
sin
sin_addr
VERBOSE_PREFIX_4
VERBOSE_PREFIX_4
iax2_getformatname(iaxs[fr->callno]->peerformat)
iax2_getformatname
iax2_getformatname
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
VERBOSE_PREFIX_4
VERBOSE_PREFIX_4
caller_pref_buf
caller_pref_buf
VERBOSE_PREFIX_4
VERBOSE_PREFIX_4
iax2_getformatname(format)
iax2_getformatname
iax2_getformatname
format
format
VERBOSE_PREFIX_4
VERBOSE_PREFIX_4
host_pref_buf
host_pref_buf
VERBOSE_PREFIX_4
VERBOSE_PREFIX_4
using_prefs
using_prefs
iaxs[fr->callno]->chosenformat = format;
iaxs[fr->callno]->chosenformat = format
iaxs[fr->callno]->chosenformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
chosenformat
format
format
iax_pvt_callid_new(fr->callno);
iax_pvt_callid_new(fr->callno)
iax_pvt_callid_new
iax_pvt_callid_new
fr->callno
fr
fr
callno
ast_set_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);
ast_set_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART)
ast_set_flag64
ast_set_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_DELAYPBXSTART
IAX_DELAYPBXSTART
{								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);								/* If this is a TBD call, we're ready but now what...  */								ast_verb(3, "Accepted unauthenticated TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							}
ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);
ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD)
ast_set_flag
ast_set_flag
&iaxs[fr->callno]->state
iaxs[fr->callno]->state
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
state
IAX_STATE_TBD
IAX_STATE_TBD
ast_verb(3, "Accepted unauthenticated TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));
ast_verb(3, "Accepted unauthenticated TBD call from %s\n", ast_inet_ntoa(sin.sin_addr))
ast_verb
ast_verb
3
"Accepted unauthenticated TBD call from %s\n"
ast_inet_ntoa(sin.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
sin.sin_addr
sin
sin
sin_addr
break;
if (iaxs[fr->callno]->authmethods & IAX_AUTH_MD5)					merge_encryption(iaxs[fr->callno],ies.encmethods);				else					iaxs[fr->callno]->encmethods = 0;
iaxs[fr->callno]->authmethods & IAX_AUTH_MD5
iaxs[fr->callno]->authmethods
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
authmethods
IAX_AUTH_MD5
IAX_AUTH_MD5
merge_encryption(iaxs[fr->callno],ies.encmethods);
merge_encryption(iaxs[fr->callno],ies.encmethods)
merge_encryption
merge_encryption
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
ies.encmethods
ies
ies
encmethods
iaxs[fr->callno]->encmethods = 0;
iaxs[fr->callno]->encmethods = 0
iaxs[fr->callno]->encmethods
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
encmethods
0
if (!authenticate_request(fr->callno) && iaxs[fr->callno])					ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED);
!authenticate_request(fr->callno) && iaxs[fr->callno]
!authenticate_request(fr->callno)
authenticate_request(fr->callno)
authenticate_request
authenticate_request
fr->callno
fr
fr
callno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED);
ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED)
ast_set_flag
ast_set_flag
&iaxs[fr->callno]->state
iaxs[fr->callno]->state
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
state
IAX_STATE_AUTHENTICATED
IAX_STATE_AUTHENTICATED
break;
case IAX_COMMAND_DPREQ:
IAX_COMMAND_DPREQ
IAX_COMMAND_DPREQ
if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD) &&					!ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED) && ies.called_number) {					if (iaxcompat) {						/* Spawn a thread for the lookup */						spawn_dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num);					} else {						/* Just look it up */						dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num, 1);					}				}
ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD) &&					!ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED) && ies.called_number
ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD) &&					!ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD)
ast_test_flag
ast_test_flag
&iaxs[fr->callno]->state
iaxs[fr->callno]->state
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
state
IAX_STATE_TBD
IAX_STATE_TBD
!ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
ast_test_flag
ast_test_flag
&iaxs[fr->callno]->state
iaxs[fr->callno]->state
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
state
IAX_STATE_STARTED
IAX_STATE_STARTED
ies.called_number
ies
ies
called_number
{					if (iaxcompat) {						/* Spawn a thread for the lookup */						spawn_dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num);					} else {						/* Just look it up */						dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num, 1);					}				}
if (iaxcompat) {						/* Spawn a thread for the lookup */						spawn_dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num);					} else {						/* Just look it up */						dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num, 1);					}
iaxcompat
iaxcompat
{						/* Spawn a thread for the lookup */						spawn_dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num);					}
spawn_dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num);
spawn_dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num)
spawn_dp_lookup
spawn_dp_lookup
fr->callno
fr
fr
callno
iaxs[fr->callno]->context
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
context
ies.called_number
ies
ies
called_number
iaxs[fr->callno]->cid_num
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
cid_num
{						/* Just look it up */						dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num, 1);					}
dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num, 1);
dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num, 1)
dp_lookup
dp_lookup
fr->callno
fr
fr
callno
iaxs[fr->callno]->context
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
context
ies.called_number
ies
ies
called_number
iaxs[fr->callno]->cid_num
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
cid_num
1
break;
case IAX_COMMAND_HANGUP:
IAX_COMMAND_HANGUP
IAX_COMMAND_HANGUP
ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);
ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE)
ast_set_flag64
ast_set_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_ALREADYGONE
IAX_ALREADYGONE
ast_debug(1, "Immediately destroying %d, having received hangup\n", fr->callno);
ast_debug(1, "Immediately destroying %d, having received hangup\n", fr->callno)
ast_debug
ast_debug
1
"Immediately destroying %d, having received hangup\n"
fr->callno
fr
fr
callno
if (iaxs[fr->callno]->owner) {					set_hangup_source_and_cause(fr->callno, ies.causecode);					if (!iaxs[fr->callno]) {						break;					}				}
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
{					set_hangup_source_and_cause(fr->callno, ies.causecode);					if (!iaxs[fr->callno]) {						break;					}				}
set_hangup_source_and_cause(fr->callno, ies.causecode);
set_hangup_source_and_cause(fr->callno, ies.causecode)
set_hangup_source_and_cause
set_hangup_source_and_cause
fr->callno
fr
fr
callno
ies.causecode
ies
ies
causecode
if (!iaxs[fr->callno]) {						break;					}
!iaxs[fr->callno]
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{						break;					}
break;
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
send_command_immediate
send_command_immediate
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_ACK
IAX_COMMAND_ACK
fr->ts
fr
fr
ts
NULL
NULL
0
fr->iseqno
fr
fr
iseqno
iax2_destroy(fr->callno);
iax2_destroy(fr->callno)
iax2_destroy
iax2_destroy
fr->callno
fr
fr
callno
break;
case IAX_COMMAND_REJECT:
IAX_COMMAND_REJECT
IAX_COMMAND_REJECT
if (iaxs[fr->callno]->owner) {					set_hangup_source_and_cause(fr->callno, ies.causecode);					if (!iaxs[fr->callno]) {						break;					}				}
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
{					set_hangup_source_and_cause(fr->callno, ies.causecode);					if (!iaxs[fr->callno]) {						break;					}				}
set_hangup_source_and_cause(fr->callno, ies.causecode);
set_hangup_source_and_cause(fr->callno, ies.causecode)
set_hangup_source_and_cause
set_hangup_source_and_cause
fr->callno
fr
fr
callno
ies.causecode
ies
ies
causecode
if (!iaxs[fr->callno]) {						break;					}
!iaxs[fr->callno]
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{						break;					}
break;
if (!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)) {					if (iaxs[fr->callno]->owner && authdebug)						ast_log(LOG_WARNING, "Call rejected by %s: %s\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr),							ies.cause ? ies.cause : "<Unknown>");					ast_debug(1, "Immediately destroying %d, having received reject\n",						fr->callno);				}
!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)
ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_PROVISION
IAX_PROVISION
{					if (iaxs[fr->callno]->owner && authdebug)						ast_log(LOG_WARNING, "Call rejected by %s: %s\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr),							ies.cause ? ies.cause : "<Unknown>");					ast_debug(1, "Immediately destroying %d, having received reject\n",						fr->callno);				}
if (iaxs[fr->callno]->owner && authdebug)						ast_log(LOG_WARNING, "Call rejected by %s: %s\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr),							ies.cause ? ies.cause : "<Unknown>");
iaxs[fr->callno]->owner && authdebug
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
authdebug
authdebug
ast_log(LOG_WARNING, "Call rejected by %s: %s\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr),							ies.cause ? ies.cause : "<Unknown>");
ast_log(LOG_WARNING, "Call rejected by %s: %s\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr),							ies.cause ? ies.cause : "<Unknown>")
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"Call rejected by %s: %s\n"
ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
iaxs[fr->callno]->addr.sin_addr
iaxs[fr->callno]->addr
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
addr
sin_addr
ies.cause ? ies.cause : "<Unknown>"
ies.cause
ies
ies
cause
ies.cause
ies
ies
cause
"<Unknown>"
ast_debug(1, "Immediately destroying %d, having received reject\n",						fr->callno);
ast_debug(1, "Immediately destroying %d, having received reject\n",						fr->callno)
ast_debug
ast_debug
1
"Immediately destroying %d, having received reject\n"
fr->callno
fr
fr
callno
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK,						       fr->ts, NULL, 0, fr->iseqno);
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK,						       fr->ts, NULL, 0, fr->iseqno)
send_command_immediate
send_command_immediate
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_ACK
IAX_COMMAND_ACK
fr->ts
fr
fr
ts
NULL
NULL
0
fr->iseqno
fr
fr
iseqno
if (!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION))					iaxs[fr->callno]->error = EPERM;
!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)
ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_PROVISION
IAX_PROVISION
iaxs[fr->callno]->error = EPERM;
iaxs[fr->callno]->error = EPERM
iaxs[fr->callno]->error
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
error
EPERM
EPERM
iax2_destroy(fr->callno);
iax2_destroy(fr->callno)
iax2_destroy
iax2_destroy
fr->callno
fr
fr
callno
break;
case IAX_COMMAND_TRANSFER:
IAX_COMMAND_TRANSFER
IAX_COMMAND_TRANSFER
{				struct ast_channel *bridged_chan;				struct ast_channel *owner;				iax2_lock_owner(fr->callno);				if (!iaxs[fr->callno]) {					/* Initiating call went away before we could transfer. */					break;				}				owner = iaxs[fr->callno]->owner;				bridged_chan = owner ? ast_bridged_channel(owner) : NULL;				if (bridged_chan && ies.called_number) {					const char *context;					context = ast_strdupa(iaxs[fr->callno]->context);					ast_channel_ref(owner);					ast_channel_ref(bridged_chan);					ast_channel_unlock(owner);					ast_mutex_unlock(&iaxsl[fr->callno]);					/* Set BLINDTRANSFER channel variables */					pbx_builtin_setvar_helper(owner, "BLINDTRANSFER", ast_channel_name(bridged_chan));					pbx_builtin_setvar_helper(bridged_chan, "BLINDTRANSFER", ast_channel_name(owner));					/* DO NOT hold any locks while calling ast_parking_ext_valid() */					if (ast_parking_ext_valid(ies.called_number, owner, context)) {						ast_debug(1, "Parking call '%s'\n", ast_channel_name(bridged_chan));						if (iax_park(bridged_chan, owner, ies.called_number, context)) {							ast_log(LOG_WARNING, "Failed to park call '%s'\n",								ast_channel_name(bridged_chan));						}					} else {						if (ast_async_goto(bridged_chan, context, ies.called_number, 1)) {							ast_log(LOG_WARNING,								"Async goto of '%s' to '%s@%s' failed\n",								ast_channel_name(bridged_chan), ies.called_number, context);						} else {							ast_debug(1, "Async goto of '%s' to '%s@%s' started\n",								ast_channel_name(bridged_chan), ies.called_number, context);						}					}					ast_channel_unref(owner);					ast_channel_unref(bridged_chan);					ast_mutex_lock(&iaxsl[fr->callno]);				} else {					ast_debug(1, "Async goto not applicable on call %d\n", fr->callno);					if (owner) {						ast_channel_unlock(owner);					}				}				break;			}
struct ast_channel *bridged_chan;
struct ast_channel *bridged_chan;
struct ast_channel
ast_channel
*bridged_chan
*
bridged_chan
struct ast_channel *owner;
struct ast_channel *owner;
struct ast_channel
ast_channel
*owner
*
owner
iax2_lock_owner(fr->callno);
iax2_lock_owner(fr->callno)
iax2_lock_owner
iax2_lock_owner
fr->callno
fr
fr
callno
if (!iaxs[fr->callno]) {					/* Initiating call went away before we could transfer. */					break;				}
!iaxs[fr->callno]
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{					/* Initiating call went away before we could transfer. */					break;				}
break;
owner = iaxs[fr->callno]->owner;
owner = iaxs[fr->callno]->owner
owner
owner
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
bridged_chan = owner ? ast_bridged_channel(owner) : NULL;
bridged_chan = owner ? ast_bridged_channel(owner) : NULL
bridged_chan
bridged_chan
owner ? ast_bridged_channel(owner) : NULL
owner
owner
ast_bridged_channel(owner)
ast_bridged_channel
ast_bridged_channel
owner
owner
NULL
NULL
if (bridged_chan && ies.called_number) {					const char *context;					context = ast_strdupa(iaxs[fr->callno]->context);					ast_channel_ref(owner);					ast_channel_ref(bridged_chan);					ast_channel_unlock(owner);					ast_mutex_unlock(&iaxsl[fr->callno]);					/* Set BLINDTRANSFER channel variables */					pbx_builtin_setvar_helper(owner, "BLINDTRANSFER", ast_channel_name(bridged_chan));					pbx_builtin_setvar_helper(bridged_chan, "BLINDTRANSFER", ast_channel_name(owner));					/* DO NOT hold any locks while calling ast_parking_ext_valid() */					if (ast_parking_ext_valid(ies.called_number, owner, context)) {						ast_debug(1, "Parking call '%s'\n", ast_channel_name(bridged_chan));						if (iax_park(bridged_chan, owner, ies.called_number, context)) {							ast_log(LOG_WARNING, "Failed to park call '%s'\n",								ast_channel_name(bridged_chan));						}					} else {						if (ast_async_goto(bridged_chan, context, ies.called_number, 1)) {							ast_log(LOG_WARNING,								"Async goto of '%s' to '%s@%s' failed\n",								ast_channel_name(bridged_chan), ies.called_number, context);						} else {							ast_debug(1, "Async goto of '%s' to '%s@%s' started\n",								ast_channel_name(bridged_chan), ies.called_number, context);						}					}					ast_channel_unref(owner);					ast_channel_unref(bridged_chan);					ast_mutex_lock(&iaxsl[fr->callno]);				} else {					ast_debug(1, "Async goto not applicable on call %d\n", fr->callno);					if (owner) {						ast_channel_unlock(owner);					}				}
bridged_chan && ies.called_number
bridged_chan
bridged_chan
ies.called_number
ies
ies
called_number
{					const char *context;					context = ast_strdupa(iaxs[fr->callno]->context);					ast_channel_ref(owner);					ast_channel_ref(bridged_chan);					ast_channel_unlock(owner);					ast_mutex_unlock(&iaxsl[fr->callno]);					/* Set BLINDTRANSFER channel variables */					pbx_builtin_setvar_helper(owner, "BLINDTRANSFER", ast_channel_name(bridged_chan));					pbx_builtin_setvar_helper(bridged_chan, "BLINDTRANSFER", ast_channel_name(owner));					/* DO NOT hold any locks while calling ast_parking_ext_valid() */					if (ast_parking_ext_valid(ies.called_number, owner, context)) {						ast_debug(1, "Parking call '%s'\n", ast_channel_name(bridged_chan));						if (iax_park(bridged_chan, owner, ies.called_number, context)) {							ast_log(LOG_WARNING, "Failed to park call '%s'\n",								ast_channel_name(bridged_chan));						}					} else {						if (ast_async_goto(bridged_chan, context, ies.called_number, 1)) {							ast_log(LOG_WARNING,								"Async goto of '%s' to '%s@%s' failed\n",								ast_channel_name(bridged_chan), ies.called_number, context);						} else {							ast_debug(1, "Async goto of '%s' to '%s@%s' started\n",								ast_channel_name(bridged_chan), ies.called_number, context);						}					}					ast_channel_unref(owner);					ast_channel_unref(bridged_chan);					ast_mutex_lock(&iaxsl[fr->callno]);				}
const char *context;
const char *context;
const char
*context
*
context
context = ast_strdupa(iaxs[fr->callno]->context);
context = ast_strdupa(iaxs[fr->callno]->context)
context
context
ast_strdupa(iaxs[fr->callno]->context)
ast_strdupa
ast_strdupa
iaxs[fr->callno]->context
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
context
ast_channel_ref(owner);
ast_channel_ref(owner)
ast_channel_ref
ast_channel_ref
owner
owner
ast_channel_ref(bridged_chan);
ast_channel_ref(bridged_chan)
ast_channel_ref
ast_channel_ref
bridged_chan
bridged_chan
ast_channel_unlock(owner);
ast_channel_unlock(owner)
ast_channel_unlock
ast_channel_unlock
owner
owner
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock
ast_mutex_unlock
(&iaxsl[fr->callno])
&iaxsl[fr->callno]
&
iaxsl
[fr->callno]
fr->callno
fr
fr
callno
pbx_builtin_setvar_helper(owner, "BLINDTRANSFER", ast_channel_name(bridged_chan));
pbx_builtin_setvar_helper(owner, "BLINDTRANSFER", ast_channel_name(bridged_chan))
pbx_builtin_setvar_helper
pbx_builtin_setvar_helper
owner
owner
"BLINDTRANSFER"
ast_channel_name(bridged_chan)
ast_channel_name
ast_channel_name
bridged_chan
bridged_chan
pbx_builtin_setvar_helper(bridged_chan, "BLINDTRANSFER", ast_channel_name(owner));
pbx_builtin_setvar_helper(bridged_chan, "BLINDTRANSFER", ast_channel_name(owner))
pbx_builtin_setvar_helper
pbx_builtin_setvar_helper
bridged_chan
bridged_chan
"BLINDTRANSFER"
ast_channel_name(owner)
ast_channel_name
ast_channel_name
owner
owner
if (ast_parking_ext_valid(ies.called_number, owner, context)) {						ast_debug(1, "Parking call '%s'\n", ast_channel_name(bridged_chan));						if (iax_park(bridged_chan, owner, ies.called_number, context)) {							ast_log(LOG_WARNING, "Failed to park call '%s'\n",								ast_channel_name(bridged_chan));						}					} else {						if (ast_async_goto(bridged_chan, context, ies.called_number, 1)) {							ast_log(LOG_WARNING,								"Async goto of '%s' to '%s@%s' failed\n",								ast_channel_name(bridged_chan), ies.called_number, context);						} else {							ast_debug(1, "Async goto of '%s' to '%s@%s' started\n",								ast_channel_name(bridged_chan), ies.called_number, context);						}					}
ast_parking_ext_valid(ies.called_number, owner, context)
ast_parking_ext_valid
ast_parking_ext_valid
ies.called_number
ies
ies
called_number
owner
owner
context
context
{						ast_debug(1, "Parking call '%s'\n", ast_channel_name(bridged_chan));						if (iax_park(bridged_chan, owner, ies.called_number, context)) {							ast_log(LOG_WARNING, "Failed to park call '%s'\n",								ast_channel_name(bridged_chan));						}					}
ast_debug(1, "Parking call '%s'\n", ast_channel_name(bridged_chan));
ast_debug(1, "Parking call '%s'\n", ast_channel_name(bridged_chan))
ast_debug
ast_debug
1
"Parking call '%s'\n"
ast_channel_name(bridged_chan)
ast_channel_name
ast_channel_name
bridged_chan
bridged_chan
if (iax_park(bridged_chan, owner, ies.called_number, context)) {							ast_log(LOG_WARNING, "Failed to park call '%s'\n",								ast_channel_name(bridged_chan));						}
iax_park(bridged_chan, owner, ies.called_number, context)
iax_park
iax_park
bridged_chan
bridged_chan
owner
owner
ies.called_number
ies
ies
called_number
context
context
{							ast_log(LOG_WARNING, "Failed to park call '%s'\n",								ast_channel_name(bridged_chan));						}
ast_log(LOG_WARNING, "Failed to park call '%s'\n",								ast_channel_name(bridged_chan));
ast_log(LOG_WARNING, "Failed to park call '%s'\n",								ast_channel_name(bridged_chan))
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"Failed to park call '%s'\n"
ast_channel_name(bridged_chan)
ast_channel_name
ast_channel_name
bridged_chan
bridged_chan
{						if (ast_async_goto(bridged_chan, context, ies.called_number, 1)) {							ast_log(LOG_WARNING,								"Async goto of '%s' to '%s@%s' failed\n",								ast_channel_name(bridged_chan), ies.called_number, context);						} else {							ast_debug(1, "Async goto of '%s' to '%s@%s' started\n",								ast_channel_name(bridged_chan), ies.called_number, context);						}					}
if (ast_async_goto(bridged_chan, context, ies.called_number, 1)) {							ast_log(LOG_WARNING,								"Async goto of '%s' to '%s@%s' failed\n",								ast_channel_name(bridged_chan), ies.called_number, context);						} else {							ast_debug(1, "Async goto of '%s' to '%s@%s' started\n",								ast_channel_name(bridged_chan), ies.called_number, context);						}
ast_async_goto(bridged_chan, context, ies.called_number, 1)
ast_async_goto
ast_async_goto
bridged_chan
bridged_chan
context
context
ies.called_number
ies
ies
called_number
1
{							ast_log(LOG_WARNING,								"Async goto of '%s' to '%s@%s' failed\n",								ast_channel_name(bridged_chan), ies.called_number, context);						}
ast_log(LOG_WARNING,								"Async goto of '%s' to '%s@%s' failed\n",								ast_channel_name(bridged_chan), ies.called_number, context);
ast_log(LOG_WARNING,								"Async goto of '%s' to '%s@%s' failed\n",								ast_channel_name(bridged_chan), ies.called_number, context)
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"Async goto of '%s' to '%s@%s' failed\n"
ast_channel_name(bridged_chan)
ast_channel_name
ast_channel_name
bridged_chan
bridged_chan
ies.called_number
ies
ies
called_number
context
context
{							ast_debug(1, "Async goto of '%s' to '%s@%s' started\n",								ast_channel_name(bridged_chan), ies.called_number, context);						}
ast_debug(1, "Async goto of '%s' to '%s@%s' started\n",								ast_channel_name(bridged_chan), ies.called_number, context);
ast_debug(1, "Async goto of '%s' to '%s@%s' started\n",								ast_channel_name(bridged_chan), ies.called_number, context)
ast_debug
ast_debug
1
"Async goto of '%s' to '%s@%s' started\n"
ast_channel_name(bridged_chan)
ast_channel_name
ast_channel_name
bridged_chan
bridged_chan
ies.called_number
ies
ies
called_number
context
context
ast_channel_unref(owner);
ast_channel_unref(owner)
ast_channel_unref
ast_channel_unref
owner
owner
ast_channel_unref(bridged_chan);
ast_channel_unref(bridged_chan)
ast_channel_unref
ast_channel_unref
bridged_chan
bridged_chan
ast_mutex_lock(&iaxsl[fr->callno]);
ast_mutex_lock(&iaxsl[fr->callno])
ast_mutex_lock
ast_mutex_lock
&iaxsl[fr->callno]
iaxsl[fr->callno]
iaxsl
iaxsl
fr->callno
fr
fr
callno
{					ast_debug(1, "Async goto not applicable on call %d\n", fr->callno);					if (owner) {						ast_channel_unlock(owner);					}				}
ast_debug(1, "Async goto not applicable on call %d\n", fr->callno);
ast_debug(1, "Async goto not applicable on call %d\n", fr->callno)
ast_debug
ast_debug
1
"Async goto not applicable on call %d\n"
fr->callno
fr
fr
callno
if (owner) {						ast_channel_unlock(owner);					}
owner
owner
{						ast_channel_unlock(owner);					}
ast_channel_unlock(owner);
ast_channel_unlock(owner)
ast_channel_unlock
ast_channel_unlock
owner
owner
break;
case IAX_COMMAND_ACCEPT:
IAX_COMMAND_ACCEPT
IAX_COMMAND_ACCEPT
if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD | IAX_STATE_AUTHENTICATED))					break;
ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD | IAX_STATE_AUTHENTICATED)
ast_test_flag
ast_test_flag
&iaxs[fr->callno]->state
iaxs[fr->callno]->state
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
state
IAX_STATE_STARTED | IAX_STATE_TBD | IAX_STATE_AUTHENTICATED
IAX_STATE_STARTED | IAX_STATE_TBD
IAX_STATE_STARTED
IAX_STATE_STARTED
IAX_STATE_TBD
IAX_STATE_TBD
IAX_STATE_AUTHENTICATED
IAX_STATE_AUTHENTICATED
break;
if (ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)) {					/* Send ack immediately, before we destroy */					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					iax2_destroy(fr->callno);					break;				}
ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_PROVISION
IAX_PROVISION
{					/* Send ack immediately, before we destroy */					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					iax2_destroy(fr->callno);					break;				}
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
send_command_immediate
send_command_immediate
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_ACK
IAX_COMMAND_ACK
fr->ts
fr
fr
ts
NULL
NULL
0
fr->iseqno
fr
fr
iseqno
iax2_destroy(fr->callno);
iax2_destroy(fr->callno)
iax2_destroy
iax2_destroy
fr->callno
fr
fr
callno
break;
if (ies.format) {					iaxs[fr->callno]->peerformat = ies.format;				} else {					if (iaxs[fr->callno]->owner)						iaxs[fr->callno]->peerformat = ast_format_cap_to_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner));					else						iaxs[fr->callno]->peerformat = iaxs[fr->callno]->capability;				}
ies.format
ies
ies
format
{					iaxs[fr->callno]->peerformat = ies.format;				}
iaxs[fr->callno]->peerformat = ies.format;
iaxs[fr->callno]->peerformat = ies.format
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
ies.format
ies
ies
format
{					if (iaxs[fr->callno]->owner)						iaxs[fr->callno]->peerformat = ast_format_cap_to_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner));					else						iaxs[fr->callno]->peerformat = iaxs[fr->callno]->capability;				}
if (iaxs[fr->callno]->owner)						iaxs[fr->callno]->peerformat = ast_format_cap_to_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner));					else						iaxs[fr->callno]->peerformat = iaxs[fr->callno]->capability;
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
iaxs[fr->callno]->peerformat = ast_format_cap_to_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner));
iaxs[fr->callno]->peerformat = ast_format_cap_to_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner))
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
ast_format_cap_to_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner))
ast_format_cap_to_old_bitfield
ast_format_cap_to_old_bitfield
ast_channel_nativeformats(iaxs[fr->callno]->owner)
ast_channel_nativeformats
ast_channel_nativeformats
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
iaxs[fr->callno]->peerformat = iaxs[fr->callno]->capability;
iaxs[fr->callno]->peerformat = iaxs[fr->callno]->capability
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
ast_verb(3, "Call accepted by %s (format %s)\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iax2_getformatname(iaxs[fr->callno]->peerformat));
ast_verb(3, "Call accepted by %s (format %s)\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iax2_getformatname(iaxs[fr->callno]->peerformat))
ast_verb
ast_verb
3
"Call accepted by %s (format %s)\n"
ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
iaxs[fr->callno]->addr.sin_addr
iaxs[fr->callno]->addr
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
addr
sin_addr
iax2_getformatname(iaxs[fr->callno]->peerformat)
iax2_getformatname
iax2_getformatname
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
if (!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)) {					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);					if (!iaxs[fr->callno]) {						break;					}					if (authdebug) {						char tmp1[256], tmp2[256];						ast_log(LOG_NOTICE, "Rejected call to %s, format %s incompatible with our capability %s.\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),							iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));					}				} else {					ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);					iax2_lock_owner(fr->callno);					if (iaxs[fr->callno] && iaxs[fr->callno]->owner) {						char tmp[256];						/* Switch us to use a compatible format */						ast_format_cap_from_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner), iaxs[fr->callno]->peerformat);						ast_verb(3, "Format for call is %s\n", ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(iaxs[fr->callno]->owner)));						/* Setup read/write formats properly. */						if (ast_channel_writeformat(iaxs[fr->callno]->owner)->id)							ast_set_write_format(iaxs[fr->callno]->owner, ast_channel_writeformat(iaxs[fr->callno]->owner));						if (ast_channel_readformat(iaxs[fr->callno]->owner)->id)							ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));						ast_channel_unlock(iaxs[fr->callno]->owner);					}				}
!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)
(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)
iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
{					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);					if (!iaxs[fr->callno]) {						break;					}					if (authdebug) {						char tmp1[256], tmp2[256];						ast_log(LOG_NOTICE, "Rejected call to %s, format %s incompatible with our capability %s.\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),							iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));					}				}
memset(&ied0, 0, sizeof(ied0));
memset(&ied0, 0, sizeof(ied0))
memset
memset
&ied0
ied0
ied0
0
sizeof(ied0)
(ied0)
ied0
ied0
iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");
iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec")
iax_ie_append_str
iax_ie_append_str
&ied0
ied0
ied0
IAX_IE_CAUSE
IAX_IE_CAUSE
"Unable to negotiate codec"
iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);
iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL)
iax_ie_append_byte
iax_ie_append_byte
&ied0
ied0
ied0
IAX_IE_CAUSECODE
IAX_IE_CAUSECODE
AST_CAUSE_BEARERCAPABILITY_NOTAVAIL
AST_CAUSE_BEARERCAPABILITY_NOTAVAIL
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1)
send_command_final
send_command_final
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_REJECT
IAX_COMMAND_REJECT
0
ied0.buf
ied0
ied0
buf
ied0.pos
ied0
ied0
pos
-1
1
if (!iaxs[fr->callno]) {						break;					}
!iaxs[fr->callno]
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{						break;					}
break;
if (authdebug) {						char tmp1[256], tmp2[256];						ast_log(LOG_NOTICE, "Rejected call to %s, format %s incompatible with our capability %s.\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),							iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));					}
authdebug
authdebug
{						char tmp1[256], tmp2[256];						ast_log(LOG_NOTICE, "Rejected call to %s, format %s incompatible with our capability %s.\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),							iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));					}
char tmp1[256], tmp2[256];
char tmp1[256], tmp2[256];
char
tmp1[256]
tmp1
[256]
256
tmp2[256]
tmp2
[256]
256
ast_log(LOG_NOTICE, "Rejected call to %s, format %s incompatible with our capability %s.\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),							iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));
ast_log(LOG_NOTICE, "Rejected call to %s, format %s incompatible with our capability %s.\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),							iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability))
ast_log
ast_log
LOG_NOTICE
LOG_NOTICE
"Rejected call to %s, format %s incompatible with our capability %s.\n"
ast_inet_ntoa(sin.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
sin.sin_addr
sin
sin
sin_addr
iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp1
tmp1
sizeof(tmp1)
(tmp1)
tmp1
tmp1
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp2
tmp2
sizeof(tmp2)
(tmp2)
tmp2
tmp2
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
{					ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);					iax2_lock_owner(fr->callno);					if (iaxs[fr->callno] && iaxs[fr->callno]->owner) {						char tmp[256];						/* Switch us to use a compatible format */						ast_format_cap_from_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner), iaxs[fr->callno]->peerformat);						ast_verb(3, "Format for call is %s\n", ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(iaxs[fr->callno]->owner)));						/* Setup read/write formats properly. */						if (ast_channel_writeformat(iaxs[fr->callno]->owner)->id)							ast_set_write_format(iaxs[fr->callno]->owner, ast_channel_writeformat(iaxs[fr->callno]->owner));						if (ast_channel_readformat(iaxs[fr->callno]->owner)->id)							ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));						ast_channel_unlock(iaxs[fr->callno]->owner);					}				}
ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);
ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
ast_set_flag
ast_set_flag
&iaxs[fr->callno]->state
iaxs[fr->callno]->state
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
state
IAX_STATE_STARTED
IAX_STATE_STARTED
iax2_lock_owner(fr->callno);
iax2_lock_owner(fr->callno)
iax2_lock_owner
iax2_lock_owner
fr->callno
fr
fr
callno
if (iaxs[fr->callno] && iaxs[fr->callno]->owner) {						char tmp[256];						/* Switch us to use a compatible format */						ast_format_cap_from_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner), iaxs[fr->callno]->peerformat);						ast_verb(3, "Format for call is %s\n", ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(iaxs[fr->callno]->owner)));						/* Setup read/write formats properly. */						if (ast_channel_writeformat(iaxs[fr->callno]->owner)->id)							ast_set_write_format(iaxs[fr->callno]->owner, ast_channel_writeformat(iaxs[fr->callno]->owner));						if (ast_channel_readformat(iaxs[fr->callno]->owner)->id)							ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));						ast_channel_unlock(iaxs[fr->callno]->owner);					}
iaxs[fr->callno] && iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
{						char tmp[256];						/* Switch us to use a compatible format */						ast_format_cap_from_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner), iaxs[fr->callno]->peerformat);						ast_verb(3, "Format for call is %s\n", ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(iaxs[fr->callno]->owner)));						/* Setup read/write formats properly. */						if (ast_channel_writeformat(iaxs[fr->callno]->owner)->id)							ast_set_write_format(iaxs[fr->callno]->owner, ast_channel_writeformat(iaxs[fr->callno]->owner));						if (ast_channel_readformat(iaxs[fr->callno]->owner)->id)							ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));						ast_channel_unlock(iaxs[fr->callno]->owner);					}
char tmp[256];
char tmp[256];
char
tmp[256]
tmp
[256]
256
ast_format_cap_from_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner), iaxs[fr->callno]->peerformat);
ast_format_cap_from_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner), iaxs[fr->callno]->peerformat)
ast_format_cap_from_old_bitfield
ast_format_cap_from_old_bitfield
ast_channel_nativeformats(iaxs[fr->callno]->owner)
ast_channel_nativeformats
ast_channel_nativeformats
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
ast_verb(3, "Format for call is %s\n", ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(iaxs[fr->callno]->owner)));
ast_verb(3, "Format for call is %s\n", ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(iaxs[fr->callno]->owner)))
ast_verb
ast_verb
3
"Format for call is %s\n"
ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(iaxs[fr->callno]->owner))
ast_getformatname_multiple
ast_getformatname_multiple
tmp
tmp
sizeof(tmp)
(tmp)
tmp
tmp
ast_channel_nativeformats(iaxs[fr->callno]->owner)
ast_channel_nativeformats
ast_channel_nativeformats
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
if (ast_channel_writeformat(iaxs[fr->callno]->owner)->id)							ast_set_write_format(iaxs[fr->callno]->owner, ast_channel_writeformat(iaxs[fr->callno]->owner));
ast_channel_writeformat(iaxs[fr->callno]->owner)->id
ast_channel_writeformat(iaxs[fr->callno]->owner)
ast_channel_writeformat
ast_channel_writeformat
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
id
ast_set_write_format(iaxs[fr->callno]->owner, ast_channel_writeformat(iaxs[fr->callno]->owner));
ast_set_write_format(iaxs[fr->callno]->owner, ast_channel_writeformat(iaxs[fr->callno]->owner))
ast_set_write_format
ast_set_write_format
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
ast_channel_writeformat(iaxs[fr->callno]->owner)
ast_channel_writeformat
ast_channel_writeformat
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
if (ast_channel_readformat(iaxs[fr->callno]->owner)->id)							ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));
ast_channel_readformat(iaxs[fr->callno]->owner)->id
ast_channel_readformat(iaxs[fr->callno]->owner)
ast_channel_readformat
ast_channel_readformat
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
id
ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));
ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner))
ast_set_read_format
ast_set_read_format
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
ast_channel_readformat(iaxs[fr->callno]->owner)
ast_channel_readformat
ast_channel_readformat
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
ast_channel_unlock(iaxs[fr->callno]->owner);
ast_channel_unlock(iaxs[fr->callno]->owner)
ast_channel_unlock
ast_channel_unlock
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
if (iaxs[fr->callno]) {					AST_LIST_LOCK(&dpcache);					AST_LIST_TRAVERSE(&iaxs[fr->callno]->dpentries, dp, peer_list)						if (!(dp->flags & CACHE_FLAG_TRANSMITTED))							iax2_dprequest(dp, fr->callno);					AST_LIST_UNLOCK(&dpcache);				}
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{					AST_LIST_LOCK(&dpcache);					AST_LIST_TRAVERSE(&iaxs[fr->callno]->dpentries, dp, peer_list)						if (!(dp->flags & CACHE_FLAG_TRANSMITTED))							iax2_dprequest(dp, fr->callno);					AST_LIST_UNLOCK(&dpcache);				}
AST_LIST_LOCK(&dpcache);
AST_LIST_LOCK(&dpcache);
AST_LIST_LOCK
AST_LIST_LOCK
(&dpcache)
&dpcache
&
dpcache
AST_LIST_TRAVERSE(&iaxs[fr->callno]->dpentries, dp, peer_list)
AST_LIST_TRAVERSE(&iaxs[fr->callno]->dpentries, dp, peer_list)
AST_LIST_TRAVERSE
AST_LIST_TRAVERSE
&iaxs[fr->callno]->dpentries
iaxs[fr->callno]->dpentries
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
dpentries
dp
dp
peer_list
peer_list
)
if (!(dp->flags & CACHE_FLAG_TRANSMITTED))							iax2_dprequest(dp, fr->callno);
!(dp->flags & CACHE_FLAG_TRANSMITTED)
(dp->flags & CACHE_FLAG_TRANSMITTED)
dp->flags & CACHE_FLAG_TRANSMITTED
dp->flags
dp
dp
flags
CACHE_FLAG_TRANSMITTED
CACHE_FLAG_TRANSMITTED
iax2_dprequest(dp, fr->callno);
iax2_dprequest(dp, fr->callno)
iax2_dprequest
iax2_dprequest
dp
dp
fr->callno
fr
fr
callno
AST_LIST_UNLOCK(&dpcache);
AST_LIST_UNLOCK(&dpcache)
AST_LIST_UNLOCK
AST_LIST_UNLOCK
&dpcache
dpcache
dpcache
break;
case IAX_COMMAND_POKE:
IAX_COMMAND_POKE
IAX_COMMAND_POKE
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, NULL, 0, -1);
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, NULL, 0, -1)
send_command_final
send_command_final
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_PONG
IAX_COMMAND_PONG
fr->ts
fr
fr
ts
NULL
NULL
0
-1
1
break;
case IAX_COMMAND_PING:
IAX_COMMAND_PING
IAX_COMMAND_PING
{				struct iax_ie_data pingied;				construct_rr(iaxs[fr->callno], &pingied);				/* Send back a pong packet with the original timestamp */				send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, pingied.buf, pingied.pos, -1);			}
struct iax_ie_data pingied;
struct iax_ie_data pingied;
struct iax_ie_data
iax_ie_data
pingied
pingied
construct_rr(iaxs[fr->callno], &pingied);
construct_rr(iaxs[fr->callno], &pingied)
construct_rr
construct_rr
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
&pingied
pingied
pingied
send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, pingied.buf, pingied.pos, -1);
send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, pingied.buf, pingied.pos, -1)
send_command
send_command
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_PONG
IAX_COMMAND_PONG
fr->ts
fr
fr
ts
pingied.buf
pingied
pingied
buf
pingied.pos
pingied
pingied
pos
-1
1
break;
case IAX_COMMAND_PONG:
IAX_COMMAND_PONG
IAX_COMMAND_PONG
iaxs[fr->callno]->pingtime =  calc_timestamp(iaxs[fr->callno], 0, &f) - fr->ts;
iaxs[fr->callno]->pingtime =  calc_timestamp(iaxs[fr->callno], 0, &f) - fr->ts
iaxs[fr->callno]->pingtime
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
pingtime
calc_timestamp(iaxs[fr->callno], 0, &f) - fr->ts
calc_timestamp(iaxs[fr->callno], 0, &f)
calc_timestamp
calc_timestamp
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
0
&f
f
f
fr->ts
fr
fr
ts
save_rr(fr, &ies);
save_rr(fr, &ies)
save_rr
save_rr
fr
fr
&ies
ies
ies
log_jitterstats(fr->callno);
log_jitterstats(fr->callno)
log_jitterstats
log_jitterstats
fr->callno
fr
fr
callno
if (iaxs[fr->callno]->peerpoke) {					peer = iaxs[fr->callno]->peerpoke;					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms)) {						if (iaxs[fr->callno]->pingtime <= peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now REACHABLE! Time: %d\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Reachable\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "IAX2/%s", peer->name); /* Activate notification */						}					} else if ((peer->historicms > 0) && (peer->historicms <= peer->maxms)) {						if (iaxs[fr->callno]->pingtime > peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now TOO LAGGED (%d ms)!\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Lagged\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_UNAVAILABLE, AST_DEVSTATE_CACHABLE, "IAX2/%s", peer->name); /* Activate notification */						}					}					peer->lastms = iaxs[fr->callno]->pingtime;					if (peer->smoothing && (peer->lastms > -1))						peer->historicms = (iaxs[fr->callno]->pingtime + peer->historicms) / 2;					else if (peer->smoothing && peer->lastms < 0)						peer->historicms = (0 + peer->historicms) / 2;					else											peer->historicms = iaxs[fr->callno]->pingtime;					/* Remove scheduled iax2_poke_noanswer */					if (peer->pokeexpire > -1) {						if (!AST_SCHED_DEL(sched, peer->pokeexpire)) {							peer_unref(peer);							peer->pokeexpire = -1;						}					}					/* Schedule the next cycle */					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms))						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_peer_s, peer_ref(peer));					else						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqok, iax2_poke_peer_s, peer_ref(peer));					if (peer->pokeexpire == -1)						peer_unref(peer);					/* and finally send the ack */					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					/* And wrap up the qualify call */					iax2_destroy(fr->callno);					peer->callno = 0;					ast_debug(1, "Peer %s: got pong, lastms %d, historicms %d, maxms %d\n", peer->name, peer->lastms, peer->historicms, peer->maxms);				}
iaxs[fr->callno]->peerpoke
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerpoke
{					peer = iaxs[fr->callno]->peerpoke;					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms)) {						if (iaxs[fr->callno]->pingtime <= peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now REACHABLE! Time: %d\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Reachable\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "IAX2/%s", peer->name); /* Activate notification */						}					} else if ((peer->historicms > 0) && (peer->historicms <= peer->maxms)) {						if (iaxs[fr->callno]->pingtime > peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now TOO LAGGED (%d ms)!\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Lagged\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_UNAVAILABLE, AST_DEVSTATE_CACHABLE, "IAX2/%s", peer->name); /* Activate notification */						}					}					peer->lastms = iaxs[fr->callno]->pingtime;					if (peer->smoothing && (peer->lastms > -1))						peer->historicms = (iaxs[fr->callno]->pingtime + peer->historicms) / 2;					else if (peer->smoothing && peer->lastms < 0)						peer->historicms = (0 + peer->historicms) / 2;					else											peer->historicms = iaxs[fr->callno]->pingtime;					/* Remove scheduled iax2_poke_noanswer */					if (peer->pokeexpire > -1) {						if (!AST_SCHED_DEL(sched, peer->pokeexpire)) {							peer_unref(peer);							peer->pokeexpire = -1;						}					}					/* Schedule the next cycle */					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms))						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_peer_s, peer_ref(peer));					else						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqok, iax2_poke_peer_s, peer_ref(peer));					if (peer->pokeexpire == -1)						peer_unref(peer);					/* and finally send the ack */					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					/* And wrap up the qualify call */					iax2_destroy(fr->callno);					peer->callno = 0;					ast_debug(1, "Peer %s: got pong, lastms %d, historicms %d, maxms %d\n", peer->name, peer->lastms, peer->historicms, peer->maxms);				}
peer = iaxs[fr->callno]->peerpoke;
peer = iaxs[fr->callno]->peerpoke
peer
peer
iaxs[fr->callno]->peerpoke
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerpoke
if ((peer->lastms < 0)  || (peer->historicms > peer->maxms)) {						if (iaxs[fr->callno]->pingtime <= peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now REACHABLE! Time: %d\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Reachable\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "IAX2/%s", peer->name); /* Activate notification */						}					} else if ((peer->historicms > 0) && (peer->historicms <= peer->maxms)) {						if (iaxs[fr->callno]->pingtime > peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now TOO LAGGED (%d ms)!\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Lagged\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_UNAVAILABLE, AST_DEVSTATE_CACHABLE, "IAX2/%s", peer->name); /* Activate notification */						}					}
(peer->lastms < 0)  || (peer->historicms > peer->maxms)
(peer->lastms < 0)
peer->lastms < 0
peer->lastms
peer
peer
lastms
0
(peer->historicms > peer->maxms)
peer->historicms > peer->maxms
peer->historicms
peer
peer
historicms
peer->maxms
peer
peer
maxms
{						if (iaxs[fr->callno]->pingtime <= peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now REACHABLE! Time: %d\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Reachable\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "IAX2/%s", peer->name); /* Activate notification */						}					}
if (iaxs[fr->callno]->pingtime <= peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now REACHABLE! Time: %d\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Reachable\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "IAX2/%s", peer->name); /* Activate notification */						}
iaxs[fr->callno]->pingtime <= peer->maxms
iaxs[fr->callno]->pingtime
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
pingtime
peer->maxms
peer
peer
maxms
{							ast_log(LOG_NOTICE, "Peer '%s' is now REACHABLE! Time: %d\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Reachable\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "IAX2/%s", peer->name); /* Activate notification */						}
ast_log(LOG_NOTICE, "Peer '%s' is now REACHABLE! Time: %d\n", peer->name, iaxs[fr->callno]->pingtime);
ast_log(LOG_NOTICE, "Peer '%s' is now REACHABLE! Time: %d\n", peer->name, iaxs[fr->callno]->pingtime)
ast_log
ast_log
LOG_NOTICE
LOG_NOTICE
"Peer '%s' is now REACHABLE! Time: %d\n"
peer->name
peer
peer
name
iaxs[fr->callno]->pingtime
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
pingtime
manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Reachable\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime);
manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Reachable\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime)
manager_event
manager_event
EVENT_FLAG_SYSTEM
EVENT_FLAG_SYSTEM
"PeerStatus"
"ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Reachable\r\nTime: %d\r\n"
peer->name
peer
peer
name
iaxs[fr->callno]->pingtime
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
pingtime
ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "IAX2/%s", peer->name);
ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "IAX2/%s", peer->name)
ast_devstate_changed
ast_devstate_changed
AST_DEVICE_NOT_INUSE
AST_DEVICE_NOT_INUSE
AST_DEVSTATE_CACHABLE
AST_DEVSTATE_CACHABLE
"IAX2/%s"
peer->name
peer
peer
name
if ((peer->historicms > 0) && (peer->historicms <= peer->maxms)) {						if (iaxs[fr->callno]->pingtime > peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now TOO LAGGED (%d ms)!\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Lagged\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_UNAVAILABLE, AST_DEVSTATE_CACHABLE, "IAX2/%s", peer->name); /* Activate notification */						}					}
(peer->historicms > 0) && (peer->historicms <= peer->maxms)
(peer->historicms > 0)
peer->historicms > 0
peer->historicms
peer
peer
historicms
0
(peer->historicms <= peer->maxms)
peer->historicms <= peer->maxms
peer->historicms
peer
peer
historicms
peer->maxms
peer
peer
maxms
{						if (iaxs[fr->callno]->pingtime > peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now TOO LAGGED (%d ms)!\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Lagged\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_UNAVAILABLE, AST_DEVSTATE_CACHABLE, "IAX2/%s", peer->name); /* Activate notification */						}					}
if (iaxs[fr->callno]->pingtime > peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now TOO LAGGED (%d ms)!\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Lagged\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_UNAVAILABLE, AST_DEVSTATE_CACHABLE, "IAX2/%s", peer->name); /* Activate notification */						}
iaxs[fr->callno]->pingtime > peer->maxms
iaxs[fr->callno]->pingtime
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
pingtime
peer->maxms
peer
peer
maxms
{							ast_log(LOG_NOTICE, "Peer '%s' is now TOO LAGGED (%d ms)!\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Lagged\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_UNAVAILABLE, AST_DEVSTATE_CACHABLE, "IAX2/%s", peer->name); /* Activate notification */						}
ast_log(LOG_NOTICE, "Peer '%s' is now TOO LAGGED (%d ms)!\n", peer->name, iaxs[fr->callno]->pingtime);
ast_log(LOG_NOTICE, "Peer '%s' is now TOO LAGGED (%d ms)!\n", peer->name, iaxs[fr->callno]->pingtime)
ast_log
ast_log
LOG_NOTICE
LOG_NOTICE
"Peer '%s' is now TOO LAGGED (%d ms)!\n"
peer->name
peer
peer
name
iaxs[fr->callno]->pingtime
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
pingtime
manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Lagged\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime);
manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Lagged\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime)
manager_event
manager_event
EVENT_FLAG_SYSTEM
EVENT_FLAG_SYSTEM
"PeerStatus"
"ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Lagged\r\nTime: %d\r\n"
peer->name
peer
peer
name
iaxs[fr->callno]->pingtime
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
pingtime
ast_devstate_changed(AST_DEVICE_UNAVAILABLE, AST_DEVSTATE_CACHABLE, "IAX2/%s", peer->name);
ast_devstate_changed(AST_DEVICE_UNAVAILABLE, AST_DEVSTATE_CACHABLE, "IAX2/%s", peer->name)
ast_devstate_changed
ast_devstate_changed
AST_DEVICE_UNAVAILABLE
AST_DEVICE_UNAVAILABLE
AST_DEVSTATE_CACHABLE
AST_DEVSTATE_CACHABLE
"IAX2/%s"
peer->name
peer
peer
name
peer->lastms = iaxs[fr->callno]->pingtime;
peer->lastms = iaxs[fr->callno]->pingtime
peer->lastms
peer
peer
lastms
iaxs[fr->callno]->pingtime
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
pingtime
if (peer->smoothing && (peer->lastms > -1))						peer->historicms = (iaxs[fr->callno]->pingtime + peer->historicms) / 2;					else if (peer->smoothing && peer->lastms < 0)						peer->historicms = (0 + peer->historicms) / 2;					else											peer->historicms = iaxs[fr->callno]->pingtime;
peer->smoothing && (peer->lastms > -1)
peer->smoothing
peer
peer
smoothing
(peer->lastms > -1)
peer->lastms > -1
peer->lastms
peer
peer
lastms
-1
1
peer->historicms = (iaxs[fr->callno]->pingtime + peer->historicms) / 2;
peer->historicms = (iaxs[fr->callno]->pingtime + peer->historicms) / 2
peer->historicms
peer
peer
historicms
(iaxs[fr->callno]->pingtime + peer->historicms) / 2
(iaxs[fr->callno]->pingtime + peer->historicms)
iaxs[fr->callno]->pingtime + peer->historicms
iaxs[fr->callno]->pingtime
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
pingtime
peer->historicms
peer
peer
historicms
2
if (peer->smoothing && peer->lastms < 0)						peer->historicms = (0 + peer->historicms) / 2;					else											peer->historicms = iaxs[fr->callno]->pingtime;
peer->smoothing && peer->lastms < 0
peer->smoothing
peer
peer
smoothing
peer->lastms < 0
peer->lastms
peer
peer
lastms
0
peer->historicms = (0 + peer->historicms) / 2;
peer->historicms = (0 + peer->historicms) / 2
peer->historicms
peer
peer
historicms
(0 + peer->historicms) / 2
(0 + peer->historicms)
0 + peer->historicms
0
peer->historicms
peer
peer
historicms
2
peer->historicms = iaxs[fr->callno]->pingtime;
peer->historicms = iaxs[fr->callno]->pingtime
peer->historicms
peer
peer
historicms
iaxs[fr->callno]->pingtime
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
pingtime
if (peer->pokeexpire > -1) {						if (!AST_SCHED_DEL(sched, peer->pokeexpire)) {							peer_unref(peer);							peer->pokeexpire = -1;						}					}
peer->pokeexpire > -1
peer->pokeexpire
peer
peer
pokeexpire
-1
1
{						if (!AST_SCHED_DEL(sched, peer->pokeexpire)) {							peer_unref(peer);							peer->pokeexpire = -1;						}					}
if (!AST_SCHED_DEL(sched, peer->pokeexpire)) {							peer_unref(peer);							peer->pokeexpire = -1;						}
!AST_SCHED_DEL(sched, peer->pokeexpire)
AST_SCHED_DEL(sched, peer->pokeexpire)
AST_SCHED_DEL
AST_SCHED_DEL
sched
sched
peer->pokeexpire
peer
peer
pokeexpire
{							peer_unref(peer);							peer->pokeexpire = -1;						}
peer_unref(peer);
peer_unref(peer)
peer_unref
peer_unref
peer
peer
peer->pokeexpire = -1;
peer->pokeexpire = -1
peer->pokeexpire
peer
peer
pokeexpire
-1
1
if ((peer->lastms < 0)  || (peer->historicms > peer->maxms))						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_peer_s, peer_ref(peer));					else						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqok, iax2_poke_peer_s, peer_ref(peer));
(peer->lastms < 0)  || (peer->historicms > peer->maxms)
(peer->lastms < 0)
peer->lastms < 0
peer->lastms
peer
peer
lastms
0
(peer->historicms > peer->maxms)
peer->historicms > peer->maxms
peer->historicms
peer
peer
historicms
peer->maxms
peer
peer
maxms
peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_peer_s, peer_ref(peer));
peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_peer_s, peer_ref(peer))
peer->pokeexpire
peer
peer
pokeexpire
iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_peer_s, peer_ref(peer))
iax2_sched_add
iax2_sched_add
sched
sched
peer->pokefreqnotok
peer
peer
pokefreqnotok
iax2_poke_peer_s
iax2_poke_peer_s
peer_ref(peer)
peer_ref
peer_ref
peer
peer
peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqok, iax2_poke_peer_s, peer_ref(peer));
peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqok, iax2_poke_peer_s, peer_ref(peer))
peer->pokeexpire
peer
peer
pokeexpire
iax2_sched_add(sched, peer->pokefreqok, iax2_poke_peer_s, peer_ref(peer))
iax2_sched_add
iax2_sched_add
sched
sched
peer->pokefreqok
peer
peer
pokefreqok
iax2_poke_peer_s
iax2_poke_peer_s
peer_ref(peer)
peer_ref
peer_ref
peer
peer
if (peer->pokeexpire == -1)						peer_unref(peer);
peer->pokeexpire == -1
peer->pokeexpire
peer
peer
pokeexpire
-1
1
peer_unref(peer);
peer_unref(peer)
peer_unref
peer_unref
peer
peer
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
send_command_immediate
send_command_immediate
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_ACK
IAX_COMMAND_ACK
fr->ts
fr
fr
ts
NULL
NULL
0
fr->iseqno
fr
fr
iseqno
iax2_destroy(fr->callno);
iax2_destroy(fr->callno)
iax2_destroy
iax2_destroy
fr->callno
fr
fr
callno
peer->callno = 0;
peer->callno = 0
peer->callno
peer
peer
callno
0
ast_debug(1, "Peer %s: got pong, lastms %d, historicms %d, maxms %d\n", peer->name, peer->lastms, peer->historicms, peer->maxms);
ast_debug(1, "Peer %s: got pong, lastms %d, historicms %d, maxms %d\n", peer->name, peer->lastms, peer->historicms, peer->maxms)
ast_debug
ast_debug
1
"Peer %s: got pong, lastms %d, historicms %d, maxms %d\n"
peer->name
peer
peer
name
peer->lastms
peer
peer
lastms
peer->historicms
peer
peer
historicms
peer->maxms
peer
peer
maxms
break;
case IAX_COMMAND_LAGRQ:
IAX_COMMAND_LAGRQ
IAX_COMMAND_LAGRQ
case IAX_COMMAND_LAGRP:
IAX_COMMAND_LAGRP
IAX_COMMAND_LAGRP
f.src = "LAGRQ";
f.src = "LAGRQ"
f.src
f
f
src
"LAGRQ"
f.mallocd = 0;
f.mallocd = 0
f.mallocd
f
f
mallocd
0
f.offset = 0;
f.offset = 0
f.offset
f
f
offset
0
f.samples = 0;
f.samples = 0
f.samples
f
f
samples
0
iax_frame_wrap(fr, &f);
iax_frame_wrap(fr, &f)
iax_frame_wrap
iax_frame_wrap
fr
fr
&f
f
f
if (f.subclass.integer == IAX_COMMAND_LAGRQ) {					/* Received a LAGRQ - echo back a LAGRP */					fr->af.subclass.integer = IAX_COMMAND_LAGRP;					iax2_send(iaxs[fr->callno], &fr->af, fr->ts, -1, 0, 0, 0);				} else {					/* Received LAGRP in response to our LAGRQ */					unsigned int ts;					/* This is a reply we've been given, actually measure the difference */					ts = calc_timestamp(iaxs[fr->callno], 0, &fr->af);					iaxs[fr->callno]->lag = ts - fr->ts;					if (iaxdebug)						ast_debug(1, "Peer %s lag measured as %dms\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->lag);				}
f.subclass.integer == IAX_COMMAND_LAGRQ
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_LAGRQ
IAX_COMMAND_LAGRQ
{					/* Received a LAGRQ - echo back a LAGRP */					fr->af.subclass.integer = IAX_COMMAND_LAGRP;					iax2_send(iaxs[fr->callno], &fr->af, fr->ts, -1, 0, 0, 0);				}
fr->af.subclass.integer = IAX_COMMAND_LAGRP;
fr->af.subclass.integer = IAX_COMMAND_LAGRP
fr->af.subclass.integer
fr->af.subclass
fr->af
fr
fr
af
subclass
integer
IAX_COMMAND_LAGRP
IAX_COMMAND_LAGRP
iax2_send(iaxs[fr->callno], &fr->af, fr->ts, -1, 0, 0, 0);
iax2_send(iaxs[fr->callno], &fr->af, fr->ts, -1, 0, 0, 0)
iax2_send
iax2_send
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
&fr->af
fr->af
fr
fr
af
fr->ts
fr
fr
ts
-1
1
0
0
0
{					/* Received LAGRP in response to our LAGRQ */					unsigned int ts;					/* This is a reply we've been given, actually measure the difference */					ts = calc_timestamp(iaxs[fr->callno], 0, &fr->af);					iaxs[fr->callno]->lag = ts - fr->ts;					if (iaxdebug)						ast_debug(1, "Peer %s lag measured as %dms\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->lag);				}
unsigned int ts;
unsigned int ts;
unsigned int
ts
ts
ts = calc_timestamp(iaxs[fr->callno], 0, &fr->af);
ts = calc_timestamp(iaxs[fr->callno], 0, &fr->af)
ts
ts
calc_timestamp(iaxs[fr->callno], 0, &fr->af)
calc_timestamp
calc_timestamp
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
0
&fr->af
fr->af
fr
fr
af
iaxs[fr->callno]->lag = ts - fr->ts;
iaxs[fr->callno]->lag = ts - fr->ts
iaxs[fr->callno]->lag
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
lag
ts - fr->ts
ts
ts
fr->ts
fr
fr
ts
if (iaxdebug)						ast_debug(1, "Peer %s lag measured as %dms\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->lag);
iaxdebug
iaxdebug
ast_debug(1, "Peer %s lag measured as %dms\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->lag);
ast_debug(1, "Peer %s lag measured as %dms\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->lag)
ast_debug
ast_debug
1
"Peer %s lag measured as %dms\n"
ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
iaxs[fr->callno]->addr.sin_addr
iaxs[fr->callno]->addr
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
addr
sin_addr
iaxs[fr->callno]->lag
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
lag
break;
case IAX_COMMAND_AUTHREQ:
IAX_COMMAND_AUTHREQ
IAX_COMMAND_AUTHREQ
if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)) {					ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					break;				}
ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)
ast_test_flag
ast_test_flag
&iaxs[fr->callno]->state
iaxs[fr->callno]->state
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
state
IAX_STATE_STARTED | IAX_STATE_TBD
IAX_STATE_STARTED
IAX_STATE_STARTED
IAX_STATE_TBD
IAX_STATE_TBD
{					ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					break;				}
ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");
ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>")
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"Call on %s is already up, can't start on it\n"
iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>"
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
ast_channel_name(iaxs[fr->callno]->owner)
ast_channel_name
ast_channel_name
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
"<Unknown>"
break;
if (authenticate_reply(iaxs[fr->callno], &iaxs[fr->callno]->addr, &ies, iaxs[fr->callno]->secret, iaxs[fr->callno]->outkey)) {					struct ast_frame hangup_fr = { .frametype = AST_FRAME_CONTROL,								.subclass.integer = AST_CONTROL_HANGUP,					}
authenticate_reply(iaxs[fr->callno], &iaxs[fr->callno]->addr, &ies, iaxs[fr->callno]->secret, iaxs[fr->callno]->outkey)
authenticate_reply
authenticate_reply
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
&iaxs[fr->callno]->addr
iaxs[fr->callno]->addr
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
addr
&ies
ies
ies
iaxs[fr->callno]->secret
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
secret
iaxs[fr->callno]->outkey
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
outkey
{					struct ast_frame hangup_fr = { .frametype = AST_FRAME_CONTROL,								.subclass.integer = AST_CONTROL_HANGUP,					}
struct ast_frame hangup_fr = { .frametype = AST_FRAME_CONTROL,								.subclass.integer = AST_CONTROL_HANGUP,
;
ast_log(LOG_WARNING, 						"I don't know how to authenticate %s to %s\n", 						ies.username ? ies.username : "<unknown>", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr));
ast_log(LOG_WARNING, 						"I don't know how to authenticate %s to %s\n", 						ies.username ? ies.username : "<unknown>", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr))
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"I don't know how to authenticate %s to %s\n"
ies.username ? ies.username : "<unknown>"
ies.username
ies
ies
username
ies.username
ies
ies
username
"<unknown>"
ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
iaxs[fr->callno]->addr.sin_addr
iaxs[fr->callno]->addr
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
addr
sin_addr
iax2_queue_frame(fr->callno, &hangup_fr);
iax2_queue_frame(fr->callno, &hangup_fr)
iax2_queue_frame
iax2_queue_frame
fr->callno
fr
fr
callno
&hangup_fr
hangup_fr
hangup_fr
break;
case IAX_COMMAND_AUTHREP:
IAX_COMMAND_AUTHREP
IAX_COMMAND_AUTHREP
if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
delayreject
delayreject
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
send_command_immediate
send_command_immediate
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_ACK
IAX_COMMAND_ACK
fr->ts
fr
fr
ts
NULL
NULL
0
fr->iseqno
fr
fr
iseqno
if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)) {					ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					break;				}
ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)
ast_test_flag
ast_test_flag
&iaxs[fr->callno]->state
iaxs[fr->callno]->state
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
state
IAX_STATE_STARTED | IAX_STATE_TBD
IAX_STATE_STARTED
IAX_STATE_STARTED
IAX_STATE_TBD
IAX_STATE_TBD
{					ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					break;				}
ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");
ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>")
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"Call on %s is already up, can't start on it\n"
iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>"
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
ast_channel_name(iaxs[fr->callno]->owner)
ast_channel_name
ast_channel_name
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
"<Unknown>"
break;
if (authenticate_verify(iaxs[fr->callno], &ies)) {					if (authdebug)						ast_log(LOG_NOTICE, "Host %s failed to authenticate as %s\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->username);					memset(&ied0, 0, sizeof(ied0));					auth_fail(fr->callno, IAX_COMMAND_REJECT);					break;				}
authenticate_verify(iaxs[fr->callno], &ies)
authenticate_verify
authenticate_verify
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
&ies
ies
ies
{					if (authdebug)						ast_log(LOG_NOTICE, "Host %s failed to authenticate as %s\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->username);					memset(&ied0, 0, sizeof(ied0));					auth_fail(fr->callno, IAX_COMMAND_REJECT);					break;				}
if (authdebug)						ast_log(LOG_NOTICE, "Host %s failed to authenticate as %s\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->username);
authdebug
authdebug
ast_log(LOG_NOTICE, "Host %s failed to authenticate as %s\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->username);
ast_log(LOG_NOTICE, "Host %s failed to authenticate as %s\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->username)
ast_log
ast_log
LOG_NOTICE
LOG_NOTICE
"Host %s failed to authenticate as %s\n"
ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
iaxs[fr->callno]->addr.sin_addr
iaxs[fr->callno]->addr
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
addr
sin_addr
iaxs[fr->callno]->username
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
username
memset(&ied0, 0, sizeof(ied0));
memset(&ied0, 0, sizeof(ied0))
memset
memset
&ied0
ied0
ied0
0
sizeof(ied0)
(ied0)
ied0
ied0
auth_fail(fr->callno, IAX_COMMAND_REJECT);
auth_fail(fr->callno, IAX_COMMAND_REJECT)
auth_fail
auth_fail
fr->callno
fr
fr
callno
IAX_COMMAND_REJECT
IAX_COMMAND_REJECT
break;
if (strcasecmp(iaxs[fr->callno]->exten, "TBD")) {					/* This might re-enter the IAX code and need the lock */					exists = ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num);				} else					exists = 0;
strcasecmp(iaxs[fr->callno]->exten, "TBD")
strcasecmp
strcasecmp
iaxs[fr->callno]->exten
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
exten
"TBD"
{					/* This might re-enter the IAX code and need the lock */					exists = ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num);				}
exists = ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num);
exists = ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num)
exists
exists
ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num)
ast_exists_extension
ast_exists_extension
NULL
NULL
iaxs[fr->callno]->context
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
context
iaxs[fr->callno]->exten
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
exten
1
iaxs[fr->callno]->cid_num
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
cid_num
exists = 0;
exists = 0
exists
exists
0
if (strcmp(iaxs[fr->callno]->exten, "TBD") && !exists) {					if (authdebug)						ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);					if (!iaxs[fr->callno]) {						break;					}				} else {					/* Select an appropriate format */					if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {							using_prefs = "reqonly";						} else {							using_prefs = "disabled";						}						format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;						memset(&pref, 0, sizeof(pref));						strcpy(caller_pref_buf, "disabled");						strcpy(host_pref_buf, "disabled");					} else {						struct ast_format tmpfmt;						using_prefs = "mine";						if (ies.codec_prefs)							ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);						if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {							if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {								pref = iaxs[fr->callno]->rprefs;								using_prefs = "caller";							} else {								pref = iaxs[fr->callno]->prefs;							}						} else /* if no codec_prefs IE do it the old way */							pref = iaxs[fr->callno]->prefs;						format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);						ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);						ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);					}					if (!format) {						char tmp1[256], tmp2[256], tmp3[256];						if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {							ast_debug(1, "We don't do requested format %s, falling back to peer capability '%s'\n",								iax2_getformatname(iaxs[fr->callno]->peerformat),								iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability));							format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;						}						if (!format) {							if (authdebug) {								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n", ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));								} else {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",										ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),										iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));								}							}							memset(&ied0, 0, sizeof(ied0));							iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");							iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);							send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);							if (!iaxs[fr->callno]) {								break;							}						} else {							/* Pick one... */							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))									format = 0;							} else {								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {									using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";									memset(&pref, 0, sizeof(pref));									format = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ?										iaxs[fr->callno]->peerformat : iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									strcpy(caller_pref_buf,"disabled");									strcpy(host_pref_buf,"disabled");								} else {									struct ast_format tmpfmt;									using_prefs = "mine";									if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {										/* Do the opposite of what we tried above. */										if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {											pref = iaxs[fr->callno]->prefs;										} else {											pref = iaxs[fr->callno]->rprefs;											using_prefs = "caller";										}										format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);									} else /* if no codec_prefs IE do it the old way */										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}							}							if (!format) {								char tmp1[256], tmp2[256], tmp3[256];								ast_log(LOG_ERROR, "No best format in %s???\n",									iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));								if (authdebug) {									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}							}						}					}					if (format) {						/* Authentication received */						memset(&ied1, 0, sizeof(ied1));						iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);						iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);						send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);						if (strcmp(iaxs[fr->callno]->exten, "TBD")) {							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							ast_verb(3, "Accepting AUTHENTICATED call from %s:\n"											"%srequested format = %s,\n"											"%srequested prefs = %s,\n"											"%sactual format = %s,\n"											"%shost prefs = %s,\n"											"%spriority = %s\n", 											ast_inet_ntoa(sin.sin_addr), 											VERBOSE_PREFIX_4,											iax2_getformatname(iaxs[fr->callno]->peerformat),											VERBOSE_PREFIX_4,											caller_pref_buf,											VERBOSE_PREFIX_4,											iax2_getformatname(format),											VERBOSE_PREFIX_4,											host_pref_buf,											VERBOSE_PREFIX_4,											using_prefs);							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, format, NULL, 1)))								iax2_destroy(fr->callno);							else if (ies.vars) {								struct ast_datastore *variablestore;								struct ast_variable *var, *prev = NULL;								AST_LIST_HEAD(, ast_var_t) *varlist;								varlist = ast_calloc(1, sizeof(*varlist));								variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);								if (variablestore && varlist) {									variablestore->data = varlist;									variablestore->inheritance = DATASTORE_INHERIT_FOREVER;									AST_LIST_HEAD_INIT(varlist);									ast_debug(1, "I can haz IAX vars? w00t\n");									for (var = ies.vars; var; var = var->next) {										struct ast_var_t *newvar = ast_var_assign(var->name, var->value);										if (prev)											ast_free(prev);										prev = var;										if (!newvar) {											/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */											ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");										} else {											AST_LIST_INSERT_TAIL(varlist, newvar, entries);										}									}									if (prev)										ast_free(prev);									ies.vars = NULL;									ast_channel_datastore_add(c, variablestore);								} else {									ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									if (variablestore)										ast_datastore_free(variablestore);									if (varlist)										ast_free(varlist);								}							}						} else {							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);							/* If this is a TBD call, we're ready but now what...  */							ast_verb(3, "Accepted AUTHENTICATED TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							if (ast_test_flag64(iaxs[fr->callno], IAX_IMMEDIATE)) {								goto immediatedial;							}						}					}				}
strcmp(iaxs[fr->callno]->exten, "TBD") && !exists
strcmp(iaxs[fr->callno]->exten, "TBD")
strcmp
strcmp
iaxs[fr->callno]->exten
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
exten
"TBD"
!exists
exists
exists
{					if (authdebug)						ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);					if (!iaxs[fr->callno]) {						break;					}				}
if (authdebug)						ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);
authdebug
authdebug
ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);
ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context)
ast_log
ast_log
LOG_NOTICE
LOG_NOTICE
"Rejected connect attempt from %s, request '%s@%s' does not exist\n"
ast_inet_ntoa(sin.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
sin.sin_addr
sin
sin
sin_addr
iaxs[fr->callno]->exten
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
exten
iaxs[fr->callno]->context
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
context
memset(&ied0, 0, sizeof(ied0));
memset(&ied0, 0, sizeof(ied0))
memset
memset
&ied0
ied0
ied0
0
sizeof(ied0)
(ied0)
ied0
ied0
iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");
iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension")
iax_ie_append_str
iax_ie_append_str
&ied0
ied0
ied0
IAX_IE_CAUSE
IAX_IE_CAUSE
"No such context/extension"
iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);
iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION)
iax_ie_append_byte
iax_ie_append_byte
&ied0
ied0
ied0
IAX_IE_CAUSECODE
IAX_IE_CAUSECODE
AST_CAUSE_NO_ROUTE_DESTINATION
AST_CAUSE_NO_ROUTE_DESTINATION
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1)
send_command_final
send_command_final
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_REJECT
IAX_COMMAND_REJECT
0
ied0.buf
ied0
ied0
buf
ied0.pos
ied0
ied0
pos
-1
1
if (!iaxs[fr->callno]) {						break;					}
!iaxs[fr->callno]
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{						break;					}
break;
{					/* Select an appropriate format */					if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {							using_prefs = "reqonly";						} else {							using_prefs = "disabled";						}						format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;						memset(&pref, 0, sizeof(pref));						strcpy(caller_pref_buf, "disabled");						strcpy(host_pref_buf, "disabled");					} else {						struct ast_format tmpfmt;						using_prefs = "mine";						if (ies.codec_prefs)							ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);						if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {							if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {								pref = iaxs[fr->callno]->rprefs;								using_prefs = "caller";							} else {								pref = iaxs[fr->callno]->prefs;							}						} else /* if no codec_prefs IE do it the old way */							pref = iaxs[fr->callno]->prefs;						format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);						ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);						ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);					}					if (!format) {						char tmp1[256], tmp2[256], tmp3[256];						if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {							ast_debug(1, "We don't do requested format %s, falling back to peer capability '%s'\n",								iax2_getformatname(iaxs[fr->callno]->peerformat),								iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability));							format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;						}						if (!format) {							if (authdebug) {								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n", ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));								} else {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",										ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),										iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));								}							}							memset(&ied0, 0, sizeof(ied0));							iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");							iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);							send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);							if (!iaxs[fr->callno]) {								break;							}						} else {							/* Pick one... */							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))									format = 0;							} else {								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {									using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";									memset(&pref, 0, sizeof(pref));									format = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ?										iaxs[fr->callno]->peerformat : iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									strcpy(caller_pref_buf,"disabled");									strcpy(host_pref_buf,"disabled");								} else {									struct ast_format tmpfmt;									using_prefs = "mine";									if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {										/* Do the opposite of what we tried above. */										if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {											pref = iaxs[fr->callno]->prefs;										} else {											pref = iaxs[fr->callno]->rprefs;											using_prefs = "caller";										}										format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);									} else /* if no codec_prefs IE do it the old way */										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}							}							if (!format) {								char tmp1[256], tmp2[256], tmp3[256];								ast_log(LOG_ERROR, "No best format in %s???\n",									iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));								if (authdebug) {									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}							}						}					}					if (format) {						/* Authentication received */						memset(&ied1, 0, sizeof(ied1));						iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);						iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);						send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);						if (strcmp(iaxs[fr->callno]->exten, "TBD")) {							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							ast_verb(3, "Accepting AUTHENTICATED call from %s:\n"											"%srequested format = %s,\n"											"%srequested prefs = %s,\n"											"%sactual format = %s,\n"											"%shost prefs = %s,\n"											"%spriority = %s\n", 											ast_inet_ntoa(sin.sin_addr), 											VERBOSE_PREFIX_4,											iax2_getformatname(iaxs[fr->callno]->peerformat),											VERBOSE_PREFIX_4,											caller_pref_buf,											VERBOSE_PREFIX_4,											iax2_getformatname(format),											VERBOSE_PREFIX_4,											host_pref_buf,											VERBOSE_PREFIX_4,											using_prefs);							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, format, NULL, 1)))								iax2_destroy(fr->callno);							else if (ies.vars) {								struct ast_datastore *variablestore;								struct ast_variable *var, *prev = NULL;								AST_LIST_HEAD(, ast_var_t) *varlist;								varlist = ast_calloc(1, sizeof(*varlist));								variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);								if (variablestore && varlist) {									variablestore->data = varlist;									variablestore->inheritance = DATASTORE_INHERIT_FOREVER;									AST_LIST_HEAD_INIT(varlist);									ast_debug(1, "I can haz IAX vars? w00t\n");									for (var = ies.vars; var; var = var->next) {										struct ast_var_t *newvar = ast_var_assign(var->name, var->value);										if (prev)											ast_free(prev);										prev = var;										if (!newvar) {											/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */											ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");										} else {											AST_LIST_INSERT_TAIL(varlist, newvar, entries);										}									}									if (prev)										ast_free(prev);									ies.vars = NULL;									ast_channel_datastore_add(c, variablestore);								} else {									ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									if (variablestore)										ast_datastore_free(variablestore);									if (varlist)										ast_free(varlist);								}							}						} else {							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);							/* If this is a TBD call, we're ready but now what...  */							ast_verb(3, "Accepted AUTHENTICATED TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							if (ast_test_flag64(iaxs[fr->callno], IAX_IMMEDIATE)) {								goto immediatedial;							}						}					}				}
if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {							using_prefs = "reqonly";						} else {							using_prefs = "disabled";						}						format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;						memset(&pref, 0, sizeof(pref));						strcpy(caller_pref_buf, "disabled");						strcpy(host_pref_buf, "disabled");					} else {						struct ast_format tmpfmt;						using_prefs = "mine";						if (ies.codec_prefs)							ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);						if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {							if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {								pref = iaxs[fr->callno]->rprefs;								using_prefs = "caller";							} else {								pref = iaxs[fr->callno]->prefs;							}						} else /* if no codec_prefs IE do it the old way */							pref = iaxs[fr->callno]->prefs;						format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);						ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);						ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);					}
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_CODEC_NOPREFS
IAX_CODEC_NOPREFS
{						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {							using_prefs = "reqonly";						} else {							using_prefs = "disabled";						}						format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;						memset(&pref, 0, sizeof(pref));						strcpy(caller_pref_buf, "disabled");						strcpy(host_pref_buf, "disabled");					}
if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {							using_prefs = "reqonly";						} else {							using_prefs = "disabled";						}
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_CODEC_NOCAP
IAX_CODEC_NOCAP
{							using_prefs = "reqonly";						}
using_prefs = "reqonly";
using_prefs = "reqonly"
using_prefs
using_prefs
"reqonly"
{							using_prefs = "disabled";						}
using_prefs = "disabled";
using_prefs = "disabled"
using_prefs
using_prefs
"disabled"
format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;
format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability
format
format
iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
memset(&pref, 0, sizeof(pref));
memset(&pref, 0, sizeof(pref))
memset
memset
&pref
pref
pref
0
sizeof(pref)
(pref)
pref
pref
strcpy(caller_pref_buf, "disabled");
strcpy(caller_pref_buf, "disabled")
strcpy
strcpy
caller_pref_buf
caller_pref_buf
"disabled"
strcpy(host_pref_buf, "disabled");
strcpy(host_pref_buf, "disabled")
strcpy
strcpy
host_pref_buf
host_pref_buf
"disabled"
{						struct ast_format tmpfmt;						using_prefs = "mine";						if (ies.codec_prefs)							ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);						if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {							if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {								pref = iaxs[fr->callno]->rprefs;								using_prefs = "caller";							} else {								pref = iaxs[fr->callno]->prefs;							}						} else /* if no codec_prefs IE do it the old way */							pref = iaxs[fr->callno]->prefs;						format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);						ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);						ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);					}
struct ast_format tmpfmt;
struct ast_format tmpfmt;
struct ast_format
ast_format
tmpfmt
tmpfmt
using_prefs = "mine";
using_prefs = "mine"
using_prefs
using_prefs
"mine"
if (ies.codec_prefs)							ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);
ies.codec_prefs
ies
ies
codec_prefs
ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);
ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0)
ast_codec_pref_convert
ast_codec_pref_convert
&iaxs[fr->callno]->rprefs
iaxs[fr->callno]->rprefs
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
rprefs
ies.codec_prefs
ies
ies
codec_prefs
32
0
if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {							if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {								pref = iaxs[fr->callno]->rprefs;								using_prefs = "caller";							} else {								pref = iaxs[fr->callno]->prefs;							}						} else /* if no codec_prefs IE do it the old way */							pref = iaxs[fr->callno]->prefs;
ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)
ast_codec_pref_index
ast_codec_pref_index
&iaxs[fr->callno]->rprefs
iaxs[fr->callno]->rprefs
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
rprefs
0
&tmpfmt
tmpfmt
tmpfmt
{							if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {								pref = iaxs[fr->callno]->rprefs;								using_prefs = "caller";							} else {								pref = iaxs[fr->callno]->prefs;							}						}
if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {								pref = iaxs[fr->callno]->rprefs;								using_prefs = "caller";							} else {								pref = iaxs[fr->callno]->prefs;							}
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_CODEC_USER_FIRST
IAX_CODEC_USER_FIRST
{								pref = iaxs[fr->callno]->rprefs;								using_prefs = "caller";							}
pref = iaxs[fr->callno]->rprefs;
pref = iaxs[fr->callno]->rprefs
pref
pref
iaxs[fr->callno]->rprefs
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
rprefs
using_prefs = "caller";
using_prefs = "caller"
using_prefs
using_prefs
"caller"
{								pref = iaxs[fr->callno]->prefs;							}
pref = iaxs[fr->callno]->prefs;
pref = iaxs[fr->callno]->prefs
pref
pref
iaxs[fr->callno]->prefs
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
prefs
pref = iaxs[fr->callno]->prefs;
pref = iaxs[fr->callno]->prefs
pref
pref
iaxs[fr->callno]->prefs
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
prefs
format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);
format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0)
format
format
iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0)
iax2_codec_choose
iax2_codec_choose
&pref
pref
pref
iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
iaxs[fr->callno]->peercapability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercapability
0
ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);
ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1)
ast_codec_pref_string
ast_codec_pref_string
&iaxs[fr->callno]->rprefs
iaxs[fr->callno]->rprefs
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
rprefs
caller_pref_buf
caller_pref_buf
sizeof(caller_pref_buf) - 1
sizeof(caller_pref_buf)
(caller_pref_buf)
caller_pref_buf
caller_pref_buf
1
ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);
ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1)
ast_codec_pref_string
ast_codec_pref_string
&iaxs[fr->callno]->prefs
iaxs[fr->callno]->prefs
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
prefs
host_pref_buf
host_pref_buf
sizeof(host_pref_buf) - 1
sizeof(host_pref_buf)
(host_pref_buf)
host_pref_buf
host_pref_buf
1
if (!format) {						char tmp1[256], tmp2[256], tmp3[256];						if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {							ast_debug(1, "We don't do requested format %s, falling back to peer capability '%s'\n",								iax2_getformatname(iaxs[fr->callno]->peerformat),								iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability));							format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;						}						if (!format) {							if (authdebug) {								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n", ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));								} else {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",										ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),										iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));								}							}							memset(&ied0, 0, sizeof(ied0));							iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");							iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);							send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);							if (!iaxs[fr->callno]) {								break;							}						} else {							/* Pick one... */							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))									format = 0;							} else {								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {									using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";									memset(&pref, 0, sizeof(pref));									format = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ?										iaxs[fr->callno]->peerformat : iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									strcpy(caller_pref_buf,"disabled");									strcpy(host_pref_buf,"disabled");								} else {									struct ast_format tmpfmt;									using_prefs = "mine";									if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {										/* Do the opposite of what we tried above. */										if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {											pref = iaxs[fr->callno]->prefs;										} else {											pref = iaxs[fr->callno]->rprefs;											using_prefs = "caller";										}										format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);									} else /* if no codec_prefs IE do it the old way */										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}							}							if (!format) {								char tmp1[256], tmp2[256], tmp3[256];								ast_log(LOG_ERROR, "No best format in %s???\n",									iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));								if (authdebug) {									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}							}						}					}
!format
format
format
{						char tmp1[256], tmp2[256], tmp3[256];						if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {							ast_debug(1, "We don't do requested format %s, falling back to peer capability '%s'\n",								iax2_getformatname(iaxs[fr->callno]->peerformat),								iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability));							format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;						}						if (!format) {							if (authdebug) {								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n", ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));								} else {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",										ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),										iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));								}							}							memset(&ied0, 0, sizeof(ied0));							iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");							iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);							send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);							if (!iaxs[fr->callno]) {								break;							}						} else {							/* Pick one... */							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))									format = 0;							} else {								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {									using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";									memset(&pref, 0, sizeof(pref));									format = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ?										iaxs[fr->callno]->peerformat : iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									strcpy(caller_pref_buf,"disabled");									strcpy(host_pref_buf,"disabled");								} else {									struct ast_format tmpfmt;									using_prefs = "mine";									if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {										/* Do the opposite of what we tried above. */										if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {											pref = iaxs[fr->callno]->prefs;										} else {											pref = iaxs[fr->callno]->rprefs;											using_prefs = "caller";										}										format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);									} else /* if no codec_prefs IE do it the old way */										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}							}							if (!format) {								char tmp1[256], tmp2[256], tmp3[256];								ast_log(LOG_ERROR, "No best format in %s???\n",									iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));								if (authdebug) {									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}							}						}					}
char tmp1[256], tmp2[256], tmp3[256];
char tmp1[256], tmp2[256], tmp3[256];
char
tmp1[256]
tmp1
[256]
256
tmp2[256]
tmp2
[256]
256
tmp3[256]
tmp3
[256]
256
if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {							ast_debug(1, "We don't do requested format %s, falling back to peer capability '%s'\n",								iax2_getformatname(iaxs[fr->callno]->peerformat),								iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability));							format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;						}
!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_CODEC_NOCAP
IAX_CODEC_NOCAP
{							ast_debug(1, "We don't do requested format %s, falling back to peer capability '%s'\n",								iax2_getformatname(iaxs[fr->callno]->peerformat),								iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability));							format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;						}
ast_debug(1, "We don't do requested format %s, falling back to peer capability '%s'\n",								iax2_getformatname(iaxs[fr->callno]->peerformat),								iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability));
ast_debug(1, "We don't do requested format %s, falling back to peer capability '%s'\n",								iax2_getformatname(iaxs[fr->callno]->peerformat),								iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability))
ast_debug
ast_debug
1
"We don't do requested format %s, falling back to peer capability '%s'\n"
iax2_getformatname(iaxs[fr->callno]->peerformat)
iax2_getformatname
iax2_getformatname
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp1
tmp1
sizeof(tmp1)
(tmp1)
tmp1
tmp1
iaxs[fr->callno]->peercapability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercapability
format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;
format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability
format
format
iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability
iaxs[fr->callno]->peercapability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercapability
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
if (!format) {							if (authdebug) {								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n", ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));								} else {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",										ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),										iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));								}							}							memset(&ied0, 0, sizeof(ied0));							iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");							iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);							send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);							if (!iaxs[fr->callno]) {								break;							}						} else {							/* Pick one... */							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))									format = 0;							} else {								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {									using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";									memset(&pref, 0, sizeof(pref));									format = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ?										iaxs[fr->callno]->peerformat : iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									strcpy(caller_pref_buf,"disabled");									strcpy(host_pref_buf,"disabled");								} else {									struct ast_format tmpfmt;									using_prefs = "mine";									if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {										/* Do the opposite of what we tried above. */										if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {											pref = iaxs[fr->callno]->prefs;										} else {											pref = iaxs[fr->callno]->rprefs;											using_prefs = "caller";										}										format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);									} else /* if no codec_prefs IE do it the old way */										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}							}							if (!format) {								char tmp1[256], tmp2[256], tmp3[256];								ast_log(LOG_ERROR, "No best format in %s???\n",									iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));								if (authdebug) {									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}							}						}
!format
format
format
{							if (authdebug) {								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n", ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));								} else {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",										ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),										iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));								}							}							memset(&ied0, 0, sizeof(ied0));							iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");							iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);							send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);							if (!iaxs[fr->callno]) {								break;							}						}
if (authdebug) {								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n", ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));								} else {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",										ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),										iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));								}							}
authdebug
authdebug
{								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n", ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));								} else {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",										ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),										iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));								}							}
if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n", ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));								} else {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",										ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),										iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));								}
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_CODEC_NOCAP
IAX_CODEC_NOCAP
{									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n", ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));								}
ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n", ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));
ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n", ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability))
ast_log
ast_log
LOG_NOTICE
LOG_NOTICE
"Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n"
ast_inet_ntoa(sin.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
sin.sin_addr
sin
sin
sin_addr
iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp1
tmp1
sizeof(tmp1)
(tmp1)
tmp1
tmp1
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp2
tmp2
sizeof(tmp2)
(tmp2)
tmp2
tmp2
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
{									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",										ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),										iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));								}
ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",										ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),										iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));
ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",										ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),										iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability))
ast_log
ast_log
LOG_NOTICE
LOG_NOTICE
"Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n"
ast_inet_ntoa(sin.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
sin.sin_addr
sin
sin
sin_addr
iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp1
tmp1
sizeof(tmp1)
(tmp1)
tmp1
tmp1
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp2
tmp2
sizeof(tmp2)
(tmp2)
tmp2
tmp2
iaxs[fr->callno]->peercapability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercapability
iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp3
tmp3
sizeof(tmp3)
(tmp3)
tmp3
tmp3
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
memset(&ied0, 0, sizeof(ied0));
memset(&ied0, 0, sizeof(ied0))
memset
memset
&ied0
ied0
ied0
0
sizeof(ied0)
(ied0)
ied0
ied0
iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");
iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec")
iax_ie_append_str
iax_ie_append_str
&ied0
ied0
ied0
IAX_IE_CAUSE
IAX_IE_CAUSE
"Unable to negotiate codec"
iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);
iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL)
iax_ie_append_byte
iax_ie_append_byte
&ied0
ied0
ied0
IAX_IE_CAUSECODE
IAX_IE_CAUSECODE
AST_CAUSE_BEARERCAPABILITY_NOTAVAIL
AST_CAUSE_BEARERCAPABILITY_NOTAVAIL
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1)
send_command_final
send_command_final
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_REJECT
IAX_COMMAND_REJECT
0
ied0.buf
ied0
ied0
buf
ied0.pos
ied0
ied0
pos
-1
1
if (!iaxs[fr->callno]) {								break;							}
!iaxs[fr->callno]
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{								break;							}
break;
{							/* Pick one... */							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))									format = 0;							} else {								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {									using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";									memset(&pref, 0, sizeof(pref));									format = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ?										iaxs[fr->callno]->peerformat : iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									strcpy(caller_pref_buf,"disabled");									strcpy(host_pref_buf,"disabled");								} else {									struct ast_format tmpfmt;									using_prefs = "mine";									if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {										/* Do the opposite of what we tried above. */										if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {											pref = iaxs[fr->callno]->prefs;										} else {											pref = iaxs[fr->callno]->rprefs;											using_prefs = "caller";										}										format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);									} else /* if no codec_prefs IE do it the old way */										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}							}							if (!format) {								char tmp1[256], tmp2[256], tmp3[256];								ast_log(LOG_ERROR, "No best format in %s???\n",									iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));								if (authdebug) {									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}							}						}
if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))									format = 0;							} else {								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {									using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";									memset(&pref, 0, sizeof(pref));									format = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ?										iaxs[fr->callno]->peerformat : iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									strcpy(caller_pref_buf,"disabled");									strcpy(host_pref_buf,"disabled");								} else {									struct ast_format tmpfmt;									using_prefs = "mine";									if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {										/* Do the opposite of what we tried above. */										if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {											pref = iaxs[fr->callno]->prefs;										} else {											pref = iaxs[fr->callno]->rprefs;											using_prefs = "caller";										}										format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);									} else /* if no codec_prefs IE do it the old way */										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}							}
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_CODEC_NOCAP
IAX_CODEC_NOCAP
{								if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))									format = 0;							}
if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))									format = 0;
!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)
(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)
iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
format = 0;
format = 0
format
format
0
{								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {									using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";									memset(&pref, 0, sizeof(pref));									format = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ?										iaxs[fr->callno]->peerformat : iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									strcpy(caller_pref_buf,"disabled");									strcpy(host_pref_buf,"disabled");								} else {									struct ast_format tmpfmt;									using_prefs = "mine";									if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {										/* Do the opposite of what we tried above. */										if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {											pref = iaxs[fr->callno]->prefs;										} else {											pref = iaxs[fr->callno]->rprefs;											using_prefs = "caller";										}										format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);									} else /* if no codec_prefs IE do it the old way */										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}							}
if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {									using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";									memset(&pref, 0, sizeof(pref));									format = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ?										iaxs[fr->callno]->peerformat : iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									strcpy(caller_pref_buf,"disabled");									strcpy(host_pref_buf,"disabled");								} else {									struct ast_format tmpfmt;									using_prefs = "mine";									if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {										/* Do the opposite of what we tried above. */										if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {											pref = iaxs[fr->callno]->prefs;										} else {											pref = iaxs[fr->callno]->rprefs;											using_prefs = "caller";										}										format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);									} else /* if no codec_prefs IE do it the old way */										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_CODEC_NOPREFS
IAX_CODEC_NOPREFS
{									using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";									memset(&pref, 0, sizeof(pref));									format = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ?										iaxs[fr->callno]->peerformat : iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									strcpy(caller_pref_buf,"disabled");									strcpy(host_pref_buf,"disabled");								}
using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";
using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled"
using_prefs
using_prefs
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled"
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_CODEC_NOCAP
IAX_CODEC_NOCAP
"reqonly"
"disabled"
memset(&pref, 0, sizeof(pref));
memset(&pref, 0, sizeof(pref))
memset
memset
&pref
pref
pref
0
sizeof(pref)
(pref)
pref
pref
format = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ?										iaxs[fr->callno]->peerformat : iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);
format = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ?										iaxs[fr->callno]->peerformat : iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
format
format
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ?										iaxs[fr->callno]->peerformat : iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_CODEC_NOCAP
IAX_CODEC_NOCAP
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
iax2_best_codec
iax2_best_codec
iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability
iaxs[fr->callno]->peercapability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercapability
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
strcpy(caller_pref_buf,"disabled");
strcpy(caller_pref_buf,"disabled")
strcpy
strcpy
caller_pref_buf
caller_pref_buf
"disabled"
strcpy(host_pref_buf,"disabled");
strcpy(host_pref_buf,"disabled")
strcpy
strcpy
host_pref_buf
host_pref_buf
"disabled"
{									struct ast_format tmpfmt;									using_prefs = "mine";									if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {										/* Do the opposite of what we tried above. */										if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {											pref = iaxs[fr->callno]->prefs;										} else {											pref = iaxs[fr->callno]->rprefs;											using_prefs = "caller";										}										format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);									} else /* if no codec_prefs IE do it the old way */										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}
struct ast_format tmpfmt;
struct ast_format tmpfmt;
struct ast_format
ast_format
tmpfmt
tmpfmt
using_prefs = "mine";
using_prefs = "mine"
using_prefs
using_prefs
"mine"
if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {										/* Do the opposite of what we tried above. */										if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {											pref = iaxs[fr->callno]->prefs;										} else {											pref = iaxs[fr->callno]->rprefs;											using_prefs = "caller";										}										format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);									} else /* if no codec_prefs IE do it the old way */										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);
ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)
ast_codec_pref_index
ast_codec_pref_index
&iaxs[fr->callno]->rprefs
iaxs[fr->callno]->rprefs
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
rprefs
0
&tmpfmt
tmpfmt
tmpfmt
{										/* Do the opposite of what we tried above. */										if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {											pref = iaxs[fr->callno]->prefs;										} else {											pref = iaxs[fr->callno]->rprefs;											using_prefs = "caller";										}										format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);									}
if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {											pref = iaxs[fr->callno]->prefs;										} else {											pref = iaxs[fr->callno]->rprefs;											using_prefs = "caller";										}
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_CODEC_USER_FIRST
IAX_CODEC_USER_FIRST
{											pref = iaxs[fr->callno]->prefs;										}
pref = iaxs[fr->callno]->prefs;
pref = iaxs[fr->callno]->prefs
pref
pref
iaxs[fr->callno]->prefs
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
prefs
{											pref = iaxs[fr->callno]->rprefs;											using_prefs = "caller";										}
pref = iaxs[fr->callno]->rprefs;
pref = iaxs[fr->callno]->rprefs
pref
pref
iaxs[fr->callno]->rprefs
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
rprefs
using_prefs = "caller";
using_prefs = "caller"
using_prefs
using_prefs
"caller"
format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);
format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1)
format
format
iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1)
iax2_codec_choose
iax2_codec_choose
&pref
pref
pref
iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability
iaxs[fr->callno]->peercapability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercapability
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
1
format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);
format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
format
format
iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
iax2_best_codec
iax2_best_codec
iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability
iaxs[fr->callno]->peercapability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercapability
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
if (!format) {								char tmp1[256], tmp2[256], tmp3[256];								ast_log(LOG_ERROR, "No best format in %s???\n",									iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));								if (authdebug) {									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}							}
!format
format
format
{								char tmp1[256], tmp2[256], tmp3[256];								ast_log(LOG_ERROR, "No best format in %s???\n",									iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));								if (authdebug) {									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}							}
char tmp1[256], tmp2[256], tmp3[256];
char tmp1[256], tmp2[256], tmp3[256];
char
tmp1[256]
tmp1
[256]
256
tmp2[256]
tmp2
[256]
256
tmp3[256]
tmp3
[256]
256
ast_log(LOG_ERROR, "No best format in %s???\n",									iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));
ast_log(LOG_ERROR, "No best format in %s???\n",									iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability))
ast_log
ast_log
LOG_ERROR
LOG_ERROR
"No best format in %s???\n"
iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp1
tmp1
sizeof(tmp1)
(tmp1)
tmp1
tmp1
iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability
iaxs[fr->callno]->peercapability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercapability
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
if (authdebug) {									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}
authdebug
authdebug
{									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}
if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_CODEC_NOCAP
IAX_CODEC_NOCAP
{										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									}
ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));
ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability))
ast_log
ast_log
LOG_NOTICE
LOG_NOTICE
"Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n"
ast_inet_ntoa(sin.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
sin.sin_addr
sin
sin
sin_addr
iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp1
tmp1
sizeof(tmp1)
(tmp1)
tmp1
tmp1
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp2
tmp2
sizeof(tmp2)
(tmp2)
tmp2
tmp2
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
{										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}
ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));
ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability))
ast_log
ast_log
LOG_NOTICE
LOG_NOTICE
"Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n"
ast_inet_ntoa(sin.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
sin.sin_addr
sin
sin
sin_addr
iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp1
tmp1
sizeof(tmp1)
(tmp1)
tmp1
tmp1
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp2
tmp2
sizeof(tmp2)
(tmp2)
tmp2
tmp2
iaxs[fr->callno]->peercapability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercapability
iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp3
tmp3
sizeof(tmp3)
(tmp3)
tmp3
tmp3
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
memset(&ied0, 0, sizeof(ied0));
memset(&ied0, 0, sizeof(ied0))
memset
memset
&ied0
ied0
ied0
0
sizeof(ied0)
(ied0)
ied0
ied0
iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");
iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec")
iax_ie_append_str
iax_ie_append_str
&ied0
ied0
ied0
IAX_IE_CAUSE
IAX_IE_CAUSE
"Unable to negotiate codec"
iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);
iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL)
iax_ie_append_byte
iax_ie_append_byte
&ied0
ied0
ied0
IAX_IE_CAUSECODE
IAX_IE_CAUSECODE
AST_CAUSE_BEARERCAPABILITY_NOTAVAIL
AST_CAUSE_BEARERCAPABILITY_NOTAVAIL
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1)
send_command_final
send_command_final
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_REJECT
IAX_COMMAND_REJECT
0
ied0.buf
ied0
ied0
buf
ied0.pos
ied0
ied0
pos
-1
1
if (!iaxs[fr->callno]) {									break;								}
!iaxs[fr->callno]
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{									break;								}
break;
if (format) {						/* Authentication received */						memset(&ied1, 0, sizeof(ied1));						iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);						iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);						send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);						if (strcmp(iaxs[fr->callno]->exten, "TBD")) {							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							ast_verb(3, "Accepting AUTHENTICATED call from %s:\n"											"%srequested format = %s,\n"											"%srequested prefs = %s,\n"											"%sactual format = %s,\n"											"%shost prefs = %s,\n"											"%spriority = %s\n", 											ast_inet_ntoa(sin.sin_addr), 											VERBOSE_PREFIX_4,											iax2_getformatname(iaxs[fr->callno]->peerformat),											VERBOSE_PREFIX_4,											caller_pref_buf,											VERBOSE_PREFIX_4,											iax2_getformatname(format),											VERBOSE_PREFIX_4,											host_pref_buf,											VERBOSE_PREFIX_4,											using_prefs);							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, format, NULL, 1)))								iax2_destroy(fr->callno);							else if (ies.vars) {								struct ast_datastore *variablestore;								struct ast_variable *var, *prev = NULL;								AST_LIST_HEAD(, ast_var_t) *varlist;								varlist = ast_calloc(1, sizeof(*varlist));								variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);								if (variablestore && varlist) {									variablestore->data = varlist;									variablestore->inheritance = DATASTORE_INHERIT_FOREVER;									AST_LIST_HEAD_INIT(varlist);									ast_debug(1, "I can haz IAX vars? w00t\n");									for (var = ies.vars; var; var = var->next) {										struct ast_var_t *newvar = ast_var_assign(var->name, var->value);										if (prev)											ast_free(prev);										prev = var;										if (!newvar) {											/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */											ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");										} else {											AST_LIST_INSERT_TAIL(varlist, newvar, entries);										}									}									if (prev)										ast_free(prev);									ies.vars = NULL;									ast_channel_datastore_add(c, variablestore);								} else {									ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									if (variablestore)										ast_datastore_free(variablestore);									if (varlist)										ast_free(varlist);								}							}						} else {							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);							/* If this is a TBD call, we're ready but now what...  */							ast_verb(3, "Accepted AUTHENTICATED TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							if (ast_test_flag64(iaxs[fr->callno], IAX_IMMEDIATE)) {								goto immediatedial;							}						}					}
format
format
{						/* Authentication received */						memset(&ied1, 0, sizeof(ied1));						iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);						iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);						send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);						if (strcmp(iaxs[fr->callno]->exten, "TBD")) {							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							ast_verb(3, "Accepting AUTHENTICATED call from %s:\n"											"%srequested format = %s,\n"											"%srequested prefs = %s,\n"											"%sactual format = %s,\n"											"%shost prefs = %s,\n"											"%spriority = %s\n", 											ast_inet_ntoa(sin.sin_addr), 											VERBOSE_PREFIX_4,											iax2_getformatname(iaxs[fr->callno]->peerformat),											VERBOSE_PREFIX_4,											caller_pref_buf,											VERBOSE_PREFIX_4,											iax2_getformatname(format),											VERBOSE_PREFIX_4,											host_pref_buf,											VERBOSE_PREFIX_4,											using_prefs);							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, format, NULL, 1)))								iax2_destroy(fr->callno);							else if (ies.vars) {								struct ast_datastore *variablestore;								struct ast_variable *var, *prev = NULL;								AST_LIST_HEAD(, ast_var_t) *varlist;								varlist = ast_calloc(1, sizeof(*varlist));								variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);								if (variablestore && varlist) {									variablestore->data = varlist;									variablestore->inheritance = DATASTORE_INHERIT_FOREVER;									AST_LIST_HEAD_INIT(varlist);									ast_debug(1, "I can haz IAX vars? w00t\n");									for (var = ies.vars; var; var = var->next) {										struct ast_var_t *newvar = ast_var_assign(var->name, var->value);										if (prev)											ast_free(prev);										prev = var;										if (!newvar) {											/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */											ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");										} else {											AST_LIST_INSERT_TAIL(varlist, newvar, entries);										}									}									if (prev)										ast_free(prev);									ies.vars = NULL;									ast_channel_datastore_add(c, variablestore);								} else {									ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									if (variablestore)										ast_datastore_free(variablestore);									if (varlist)										ast_free(varlist);								}							}						} else {							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);							/* If this is a TBD call, we're ready but now what...  */							ast_verb(3, "Accepted AUTHENTICATED TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							if (ast_test_flag64(iaxs[fr->callno], IAX_IMMEDIATE)) {								goto immediatedial;							}						}					}
memset(&ied1, 0, sizeof(ied1));
memset(&ied1, 0, sizeof(ied1))
memset
memset
&ied1
ied1
ied1
0
sizeof(ied1)
(ied1)
ied1
ied1
iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);
iax_ie_append_int(&ied1, IAX_IE_FORMAT, format)
iax_ie_append_int
iax_ie_append_int
&ied1
ied1
ied1
IAX_IE_FORMAT
IAX_IE_FORMAT
format
format
iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);
iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format)
iax_ie_append_versioned_uint64
iax_ie_append_versioned_uint64
&ied1
ied1
ied1
IAX_IE_FORMAT2
IAX_IE_FORMAT2
0
format
format
send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);
send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1)
send_command
send_command
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_ACCEPT
IAX_COMMAND_ACCEPT
0
ied1.buf
ied1
ied1
buf
ied1.pos
ied1
ied1
pos
-1
1
if (strcmp(iaxs[fr->callno]->exten, "TBD")) {							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							ast_verb(3, "Accepting AUTHENTICATED call from %s:\n"											"%srequested format = %s,\n"											"%srequested prefs = %s,\n"											"%sactual format = %s,\n"											"%shost prefs = %s,\n"											"%spriority = %s\n", 											ast_inet_ntoa(sin.sin_addr), 											VERBOSE_PREFIX_4,											iax2_getformatname(iaxs[fr->callno]->peerformat),											VERBOSE_PREFIX_4,											caller_pref_buf,											VERBOSE_PREFIX_4,											iax2_getformatname(format),											VERBOSE_PREFIX_4,											host_pref_buf,											VERBOSE_PREFIX_4,											using_prefs);							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, format, NULL, 1)))								iax2_destroy(fr->callno);							else if (ies.vars) {								struct ast_datastore *variablestore;								struct ast_variable *var, *prev = NULL;								AST_LIST_HEAD(, ast_var_t) *varlist;								varlist = ast_calloc(1, sizeof(*varlist));								variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);								if (variablestore && varlist) {									variablestore->data = varlist;									variablestore->inheritance = DATASTORE_INHERIT_FOREVER;									AST_LIST_HEAD_INIT(varlist);									ast_debug(1, "I can haz IAX vars? w00t\n");									for (var = ies.vars; var; var = var->next) {										struct ast_var_t *newvar = ast_var_assign(var->name, var->value);										if (prev)											ast_free(prev);										prev = var;										if (!newvar) {											/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */											ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");										} else {											AST_LIST_INSERT_TAIL(varlist, newvar, entries);										}									}									if (prev)										ast_free(prev);									ies.vars = NULL;									ast_channel_datastore_add(c, variablestore);								} else {									ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									if (variablestore)										ast_datastore_free(variablestore);									if (varlist)										ast_free(varlist);								}							}						} else {							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);							/* If this is a TBD call, we're ready but now what...  */							ast_verb(3, "Accepted AUTHENTICATED TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							if (ast_test_flag64(iaxs[fr->callno], IAX_IMMEDIATE)) {								goto immediatedial;							}						}
strcmp(iaxs[fr->callno]->exten, "TBD")
strcmp
strcmp
iaxs[fr->callno]->exten
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
exten
"TBD"
{							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							ast_verb(3, "Accepting AUTHENTICATED call from %s:\n"											"%srequested format = %s,\n"											"%srequested prefs = %s,\n"											"%sactual format = %s,\n"											"%shost prefs = %s,\n"											"%spriority = %s\n", 											ast_inet_ntoa(sin.sin_addr), 											VERBOSE_PREFIX_4,											iax2_getformatname(iaxs[fr->callno]->peerformat),											VERBOSE_PREFIX_4,											caller_pref_buf,											VERBOSE_PREFIX_4,											iax2_getformatname(format),											VERBOSE_PREFIX_4,											host_pref_buf,											VERBOSE_PREFIX_4,											using_prefs);							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, format, NULL, 1)))								iax2_destroy(fr->callno);							else if (ies.vars) {								struct ast_datastore *variablestore;								struct ast_variable *var, *prev = NULL;								AST_LIST_HEAD(, ast_var_t) *varlist;								varlist = ast_calloc(1, sizeof(*varlist));								variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);								if (variablestore && varlist) {									variablestore->data = varlist;									variablestore->inheritance = DATASTORE_INHERIT_FOREVER;									AST_LIST_HEAD_INIT(varlist);									ast_debug(1, "I can haz IAX vars? w00t\n");									for (var = ies.vars; var; var = var->next) {										struct ast_var_t *newvar = ast_var_assign(var->name, var->value);										if (prev)											ast_free(prev);										prev = var;										if (!newvar) {											/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */											ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");										} else {											AST_LIST_INSERT_TAIL(varlist, newvar, entries);										}									}									if (prev)										ast_free(prev);									ies.vars = NULL;									ast_channel_datastore_add(c, variablestore);								} else {									ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									if (variablestore)										ast_datastore_free(variablestore);									if (varlist)										ast_free(varlist);								}							}						}
ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);
ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
ast_set_flag
ast_set_flag
&iaxs[fr->callno]->state
iaxs[fr->callno]->state
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
state
IAX_STATE_STARTED
IAX_STATE_STARTED
ast_verb(3, "Accepting AUTHENTICATED call from %s:\n"											"%srequested format = %s,\n"											"%srequested prefs = %s,\n"											"%sactual format = %s,\n"											"%shost prefs = %s,\n"											"%spriority = %s\n", 											ast_inet_ntoa(sin.sin_addr), 											VERBOSE_PREFIX_4,											iax2_getformatname(iaxs[fr->callno]->peerformat),											VERBOSE_PREFIX_4,											caller_pref_buf,											VERBOSE_PREFIX_4,											iax2_getformatname(format),											VERBOSE_PREFIX_4,											host_pref_buf,											VERBOSE_PREFIX_4,											using_prefs);
ast_verb(3, "Accepting AUTHENTICATED call from %s:\n"											"%srequested format = %s,\n"											"%srequested prefs = %s,\n"											"%sactual format = %s,\n"											"%shost prefs = %s,\n"											"%spriority = %s\n", 											ast_inet_ntoa(sin.sin_addr), 											VERBOSE_PREFIX_4,											iax2_getformatname(iaxs[fr->callno]->peerformat),											VERBOSE_PREFIX_4,											caller_pref_buf,											VERBOSE_PREFIX_4,											iax2_getformatname(format),											VERBOSE_PREFIX_4,											host_pref_buf,											VERBOSE_PREFIX_4,											using_prefs)
ast_verb
ast_verb
3
"Accepting AUTHENTICATED call from %s:\n"											"%srequested format = %s,\n"											"%srequested prefs = %s,\n"											"%sactual format = %s,\n"											"%shost prefs = %s,\n"											"%spriority = %s\n"
ast_inet_ntoa(sin.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
sin.sin_addr
sin
sin
sin_addr
VERBOSE_PREFIX_4
VERBOSE_PREFIX_4
iax2_getformatname(iaxs[fr->callno]->peerformat)
iax2_getformatname
iax2_getformatname
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
VERBOSE_PREFIX_4
VERBOSE_PREFIX_4
caller_pref_buf
caller_pref_buf
VERBOSE_PREFIX_4
VERBOSE_PREFIX_4
iax2_getformatname(format)
iax2_getformatname
iax2_getformatname
format
format
VERBOSE_PREFIX_4
VERBOSE_PREFIX_4
host_pref_buf
host_pref_buf
VERBOSE_PREFIX_4
VERBOSE_PREFIX_4
using_prefs
using_prefs
ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);
ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
ast_set_flag
ast_set_flag
&iaxs[fr->callno]->state
iaxs[fr->callno]->state
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
state
IAX_STATE_STARTED
IAX_STATE_STARTED
if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, format, NULL, 1)))								iax2_destroy(fr->callno);							else if (ies.vars) {								struct ast_datastore *variablestore;								struct ast_variable *var, *prev = NULL;								AST_LIST_HEAD(, ast_var_t) *varlist;								varlist = ast_calloc(1, sizeof(*varlist));								variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);								if (variablestore && varlist) {									variablestore->data = varlist;									variablestore->inheritance = DATASTORE_INHERIT_FOREVER;									AST_LIST_HEAD_INIT(varlist);									ast_debug(1, "I can haz IAX vars? w00t\n");									for (var = ies.vars; var; var = var->next) {										struct ast_var_t *newvar = ast_var_assign(var->name, var->value);										if (prev)											ast_free(prev);										prev = var;										if (!newvar) {											/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */											ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");										} else {											AST_LIST_INSERT_TAIL(varlist, newvar, entries);										}									}									if (prev)										ast_free(prev);									ies.vars = NULL;									ast_channel_datastore_add(c, variablestore);								} else {									ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									if (variablestore)										ast_datastore_free(variablestore);									if (varlist)										ast_free(varlist);								}							}
!(c = ast_iax2_new(fr->callno, AST_STATE_RING, format, NULL, 1))
(c = ast_iax2_new(fr->callno, AST_STATE_RING, format, NULL, 1))
c = ast_iax2_new(fr->callno, AST_STATE_RING, format, NULL, 1)
c
c
ast_iax2_new(fr->callno, AST_STATE_RING, format, NULL, 1)
ast_iax2_new
ast_iax2_new
fr->callno
fr
fr
callno
AST_STATE_RING
AST_STATE_RING
format
format
NULL
NULL
1
iax2_destroy(fr->callno);
iax2_destroy(fr->callno)
iax2_destroy
iax2_destroy
fr->callno
fr
fr
callno
if (ies.vars) {								struct ast_datastore *variablestore;								struct ast_variable *var, *prev = NULL;								AST_LIST_HEAD(, ast_var_t) *varlist;								varlist = ast_calloc(1, sizeof(*varlist));								variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);								if (variablestore && varlist) {									variablestore->data = varlist;									variablestore->inheritance = DATASTORE_INHERIT_FOREVER;									AST_LIST_HEAD_INIT(varlist);									ast_debug(1, "I can haz IAX vars? w00t\n");									for (var = ies.vars; var; var = var->next) {										struct ast_var_t *newvar = ast_var_assign(var->name, var->value);										if (prev)											ast_free(prev);										prev = var;										if (!newvar) {											/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */											ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");										} else {											AST_LIST_INSERT_TAIL(varlist, newvar, entries);										}									}									if (prev)										ast_free(prev);									ies.vars = NULL;									ast_channel_datastore_add(c, variablestore);								} else {									ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									if (variablestore)										ast_datastore_free(variablestore);									if (varlist)										ast_free(varlist);								}							}
ies.vars
ies
ies
vars
{								struct ast_datastore *variablestore;								struct ast_variable *var, *prev = NULL;								AST_LIST_HEAD(, ast_var_t) *varlist;								varlist = ast_calloc(1, sizeof(*varlist));								variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);								if (variablestore && varlist) {									variablestore->data = varlist;									variablestore->inheritance = DATASTORE_INHERIT_FOREVER;									AST_LIST_HEAD_INIT(varlist);									ast_debug(1, "I can haz IAX vars? w00t\n");									for (var = ies.vars; var; var = var->next) {										struct ast_var_t *newvar = ast_var_assign(var->name, var->value);										if (prev)											ast_free(prev);										prev = var;										if (!newvar) {											/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */											ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");										} else {											AST_LIST_INSERT_TAIL(varlist, newvar, entries);										}									}									if (prev)										ast_free(prev);									ies.vars = NULL;									ast_channel_datastore_add(c, variablestore);								} else {									ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									if (variablestore)										ast_datastore_free(variablestore);									if (varlist)										ast_free(varlist);								}							}
struct ast_datastore *variablestore;
struct ast_datastore *variablestore;
struct ast_datastore
ast_datastore
*variablestore
*
variablestore
struct ast_variable *var, *prev = NULL;
struct ast_variable *var, *prev = NULL;
struct ast_variable
ast_variable
*var
*
var
*prev = NULL
*
prev
= NULL
NULL
NULL
AST_LIST_HEAD(, ast_var_t) *varlist;
varlist = ast_calloc(1, sizeof(*varlist));
varlist = ast_calloc(1, sizeof(*varlist))
varlist
varlist
ast_calloc(1, sizeof(*varlist))
ast_calloc
ast_calloc
1
sizeof(*varlist)
(*varlist)
*varlist
varlist
varlist
variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);
variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL)
variablestore
variablestore
ast_datastore_alloc(&iax2_variable_datastore_info, NULL)
ast_datastore_alloc
ast_datastore_alloc
&iax2_variable_datastore_info
iax2_variable_datastore_info
iax2_variable_datastore_info
NULL
NULL
if (variablestore && varlist) {									variablestore->data = varlist;									variablestore->inheritance = DATASTORE_INHERIT_FOREVER;									AST_LIST_HEAD_INIT(varlist);									ast_debug(1, "I can haz IAX vars? w00t\n");									for (var = ies.vars; var; var = var->next) {										struct ast_var_t *newvar = ast_var_assign(var->name, var->value);										if (prev)											ast_free(prev);										prev = var;										if (!newvar) {											/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */											ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");										} else {											AST_LIST_INSERT_TAIL(varlist, newvar, entries);										}									}									if (prev)										ast_free(prev);									ies.vars = NULL;									ast_channel_datastore_add(c, variablestore);								} else {									ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									if (variablestore)										ast_datastore_free(variablestore);									if (varlist)										ast_free(varlist);								}
variablestore && varlist
variablestore
variablestore
varlist
varlist
{									variablestore->data = varlist;									variablestore->inheritance = DATASTORE_INHERIT_FOREVER;									AST_LIST_HEAD_INIT(varlist);									ast_debug(1, "I can haz IAX vars? w00t\n");									for (var = ies.vars; var; var = var->next) {										struct ast_var_t *newvar = ast_var_assign(var->name, var->value);										if (prev)											ast_free(prev);										prev = var;										if (!newvar) {											/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */											ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");										} else {											AST_LIST_INSERT_TAIL(varlist, newvar, entries);										}									}									if (prev)										ast_free(prev);									ies.vars = NULL;									ast_channel_datastore_add(c, variablestore);								}
variablestore->data = varlist;
variablestore->data = varlist
variablestore->data
variablestore
variablestore
data
varlist
varlist
variablestore->inheritance = DATASTORE_INHERIT_FOREVER;
variablestore->inheritance = DATASTORE_INHERIT_FOREVER
variablestore->inheritance
variablestore
variablestore
inheritance
DATASTORE_INHERIT_FOREVER
DATASTORE_INHERIT_FOREVER
AST_LIST_HEAD_INIT(varlist);
AST_LIST_HEAD_INIT(varlist);
AST_LIST_HEAD_INIT
AST_LIST_HEAD_INIT
(varlist)
varlist
varlist
ast_debug(1, "I can haz IAX vars? w00t\n");
ast_debug(1, "I can haz IAX vars? w00t\n")
ast_debug
ast_debug
1
"I can haz IAX vars? w00t\n"
for (var = ies.vars; var; var = var->next) {										struct ast_var_t *newvar = ast_var_assign(var->name, var->value);										if (prev)											ast_free(prev);										prev = var;										if (!newvar) {											/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */											ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");										} else {											AST_LIST_INSERT_TAIL(varlist, newvar, entries);										}									}
var = ies.vars;
var = ies.vars
var
var
ies.vars
ies
ies
vars
var
var
var = var->next
var
var
var->next
var
var
next
{										struct ast_var_t *newvar = ast_var_assign(var->name, var->value);										if (prev)											ast_free(prev);										prev = var;										if (!newvar) {											/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */											ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");										} else {											AST_LIST_INSERT_TAIL(varlist, newvar, entries);										}									}
struct ast_var_t *newvar = ast_var_assign(var->name, var->value);
struct ast_var_t *newvar = ast_var_assign(var->name, var->value);
struct ast_var_t
ast_var_t
*newvar = ast_var_assign(var->name, var->value)
*
newvar
= ast_var_assign(var->name, var->value)
ast_var_assign(var->name, var->value)
ast_var_assign
ast_var_assign
var->name
var
var
name
var->value
var
var
value
if (prev)											ast_free(prev);
prev
prev
ast_free(prev);
ast_free(prev)
ast_free
ast_free
prev
prev
prev = var;
prev = var
prev
prev
var
var
if (!newvar) {											/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */											ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");										} else {											AST_LIST_INSERT_TAIL(varlist, newvar, entries);										}
!newvar
newvar
newvar
{											/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */											ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");										}
ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");
ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n")
ast_log
ast_log
LOG_ERROR
LOG_ERROR
"Memory allocation error while processing IAX2 variables\n"
{											AST_LIST_INSERT_TAIL(varlist, newvar, entries);										}
AST_LIST_INSERT_TAIL(varlist, newvar, entries);
AST_LIST_INSERT_TAIL(varlist, newvar, entries)
AST_LIST_INSERT_TAIL
AST_LIST_INSERT_TAIL
varlist
varlist
newvar
newvar
entries
entries
if (prev)										ast_free(prev);
prev
prev
ast_free(prev);
ast_free(prev)
ast_free
ast_free
prev
prev
ies.vars = NULL;
ies.vars = NULL
ies.vars
ies
ies
vars
NULL
NULL
ast_channel_datastore_add(c, variablestore);
ast_channel_datastore_add(c, variablestore)
ast_channel_datastore_add
ast_channel_datastore_add
c
c
variablestore
variablestore
{									ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									if (variablestore)										ast_datastore_free(variablestore);									if (varlist)										ast_free(varlist);								}
ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");
ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n")
ast_log
ast_log
LOG_ERROR
LOG_ERROR
"Memory allocation error while processing IAX2 variables\n"
if (variablestore)										ast_datastore_free(variablestore);
variablestore
variablestore
ast_datastore_free(variablestore);
ast_datastore_free(variablestore)
ast_datastore_free
ast_datastore_free
variablestore
variablestore
if (varlist)										ast_free(varlist);
varlist
varlist
ast_free(varlist);
ast_free(varlist);
ast_free
ast_free
(varlist)
varlist
varlist
{							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);							/* If this is a TBD call, we're ready but now what...  */							ast_verb(3, "Accepted AUTHENTICATED TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							if (ast_test_flag64(iaxs[fr->callno], IAX_IMMEDIATE)) {								goto immediatedial;							}						}
ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);
ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD)
ast_set_flag
ast_set_flag
&iaxs[fr->callno]->state
iaxs[fr->callno]->state
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
state
IAX_STATE_TBD
IAX_STATE_TBD
ast_verb(3, "Accepted AUTHENTICATED TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));
ast_verb(3, "Accepted AUTHENTICATED TBD call from %s\n", ast_inet_ntoa(sin.sin_addr))
ast_verb
ast_verb
3
"Accepted AUTHENTICATED TBD call from %s\n"
ast_inet_ntoa(sin.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
sin.sin_addr
sin
sin
sin_addr
if (ast_test_flag64(iaxs[fr->callno], IAX_IMMEDIATE)) {								goto immediatedial;							}
ast_test_flag64(iaxs[fr->callno], IAX_IMMEDIATE)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_IMMEDIATE
IAX_IMMEDIATE
{								goto immediatedial;							}
goto immediatedial;
immediatedial
break;
case IAX_COMMAND_DIAL:
IAX_COMMAND_DIAL
IAX_COMMAND_DIAL
immediatedial:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD)) {					ast_clear_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);					ast_string_field_set(iaxs[fr->callno], exten, ies.called_number ? ies.called_number : "s");					if (!ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num)) {						if (authdebug)							ast_log(LOG_NOTICE, "Rejected dial attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}					} else {						char tmp[256];						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);						ast_verb(3, "Accepting DIAL from %s, formats = %s\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat));						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);						send_command(iaxs[fr->callno], AST_FRAME_CONTROL, AST_CONTROL_PROGRESS, 0, NULL, 0, -1);						if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->peerformat, NULL, 1)))							iax2_destroy(fr->callno);						else if (ies.vars) {							struct ast_datastore *variablestore;							struct ast_variable *var, *prev = NULL;							AST_LIST_HEAD(, ast_var_t) *varlist;							varlist = ast_calloc(1, sizeof(*varlist));							variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);							ast_debug(1, "I can haz IAX vars? w00t\n");							if (variablestore && varlist) {								variablestore->data = varlist;								variablestore->inheritance = DATASTORE_INHERIT_FOREVER;								AST_LIST_HEAD_INIT(varlist);								for (var = ies.vars; var; var = var->next) {									struct ast_var_t *newvar = ast_var_assign(var->name, var->value);									if (prev)										ast_free(prev);									prev = var;									if (!newvar) {										/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */										ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									} else {										AST_LIST_INSERT_TAIL(varlist, newvar, entries);									}								}								if (prev)									ast_free(prev);								ies.vars = NULL;								ast_channel_datastore_add(c, variablestore);							} else {								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");								if (variablestore)									ast_datastore_free(variablestore);								if (varlist)									ast_free(varlist);							}						}					}				}
immediatedial
if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD)) {					ast_clear_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);					ast_string_field_set(iaxs[fr->callno], exten, ies.called_number ? ies.called_number : "s");					if (!ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num)) {						if (authdebug)							ast_log(LOG_NOTICE, "Rejected dial attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}					} else {						char tmp[256];						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);						ast_verb(3, "Accepting DIAL from %s, formats = %s\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat));						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);						send_command(iaxs[fr->callno], AST_FRAME_CONTROL, AST_CONTROL_PROGRESS, 0, NULL, 0, -1);						if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->peerformat, NULL, 1)))							iax2_destroy(fr->callno);						else if (ies.vars) {							struct ast_datastore *variablestore;							struct ast_variable *var, *prev = NULL;							AST_LIST_HEAD(, ast_var_t) *varlist;							varlist = ast_calloc(1, sizeof(*varlist));							variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);							ast_debug(1, "I can haz IAX vars? w00t\n");							if (variablestore && varlist) {								variablestore->data = varlist;								variablestore->inheritance = DATASTORE_INHERIT_FOREVER;								AST_LIST_HEAD_INIT(varlist);								for (var = ies.vars; var; var = var->next) {									struct ast_var_t *newvar = ast_var_assign(var->name, var->value);									if (prev)										ast_free(prev);									prev = var;									if (!newvar) {										/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */										ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									} else {										AST_LIST_INSERT_TAIL(varlist, newvar, entries);									}								}								if (prev)									ast_free(prev);								ies.vars = NULL;								ast_channel_datastore_add(c, variablestore);							} else {								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");								if (variablestore)									ast_datastore_free(variablestore);								if (varlist)									ast_free(varlist);							}						}					}				}
ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD)
ast_test_flag
ast_test_flag
&iaxs[fr->callno]->state
iaxs[fr->callno]->state
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
state
IAX_STATE_TBD
IAX_STATE_TBD
{					ast_clear_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);					ast_string_field_set(iaxs[fr->callno], exten, ies.called_number ? ies.called_number : "s");					if (!ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num)) {						if (authdebug)							ast_log(LOG_NOTICE, "Rejected dial attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}					} else {						char tmp[256];						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);						ast_verb(3, "Accepting DIAL from %s, formats = %s\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat));						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);						send_command(iaxs[fr->callno], AST_FRAME_CONTROL, AST_CONTROL_PROGRESS, 0, NULL, 0, -1);						if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->peerformat, NULL, 1)))							iax2_destroy(fr->callno);						else if (ies.vars) {							struct ast_datastore *variablestore;							struct ast_variable *var, *prev = NULL;							AST_LIST_HEAD(, ast_var_t) *varlist;							varlist = ast_calloc(1, sizeof(*varlist));							variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);							ast_debug(1, "I can haz IAX vars? w00t\n");							if (variablestore && varlist) {								variablestore->data = varlist;								variablestore->inheritance = DATASTORE_INHERIT_FOREVER;								AST_LIST_HEAD_INIT(varlist);								for (var = ies.vars; var; var = var->next) {									struct ast_var_t *newvar = ast_var_assign(var->name, var->value);									if (prev)										ast_free(prev);									prev = var;									if (!newvar) {										/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */										ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									} else {										AST_LIST_INSERT_TAIL(varlist, newvar, entries);									}								}								if (prev)									ast_free(prev);								ies.vars = NULL;								ast_channel_datastore_add(c, variablestore);							} else {								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");								if (variablestore)									ast_datastore_free(variablestore);								if (varlist)									ast_free(varlist);							}						}					}				}
ast_clear_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);
ast_clear_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD)
ast_clear_flag
ast_clear_flag
&iaxs[fr->callno]->state
iaxs[fr->callno]->state
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
state
IAX_STATE_TBD
IAX_STATE_TBD
ast_string_field_set(iaxs[fr->callno], exten, ies.called_number ? ies.called_number : "s");
ast_string_field_set(iaxs[fr->callno], exten, ies.called_number ? ies.called_number : "s")
ast_string_field_set
ast_string_field_set
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
exten
exten
ies.called_number ? ies.called_number : "s"
ies.called_number
ies
ies
called_number
ies.called_number
ies
ies
called_number
"s"
if (!ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num)) {						if (authdebug)							ast_log(LOG_NOTICE, "Rejected dial attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}					} else {						char tmp[256];						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);						ast_verb(3, "Accepting DIAL from %s, formats = %s\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat));						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);						send_command(iaxs[fr->callno], AST_FRAME_CONTROL, AST_CONTROL_PROGRESS, 0, NULL, 0, -1);						if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->peerformat, NULL, 1)))							iax2_destroy(fr->callno);						else if (ies.vars) {							struct ast_datastore *variablestore;							struct ast_variable *var, *prev = NULL;							AST_LIST_HEAD(, ast_var_t) *varlist;							varlist = ast_calloc(1, sizeof(*varlist));							variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);							ast_debug(1, "I can haz IAX vars? w00t\n");							if (variablestore && varlist) {								variablestore->data = varlist;								variablestore->inheritance = DATASTORE_INHERIT_FOREVER;								AST_LIST_HEAD_INIT(varlist);								for (var = ies.vars; var; var = var->next) {									struct ast_var_t *newvar = ast_var_assign(var->name, var->value);									if (prev)										ast_free(prev);									prev = var;									if (!newvar) {										/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */										ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									} else {										AST_LIST_INSERT_TAIL(varlist, newvar, entries);									}								}								if (prev)									ast_free(prev);								ies.vars = NULL;								ast_channel_datastore_add(c, variablestore);							} else {								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");								if (variablestore)									ast_datastore_free(variablestore);								if (varlist)									ast_free(varlist);							}						}					}
!ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num)
ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num)
ast_exists_extension
ast_exists_extension
NULL
NULL
iaxs[fr->callno]->context
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
context
iaxs[fr->callno]->exten
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
exten
1
iaxs[fr->callno]->cid_num
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
cid_num
{						if (authdebug)							ast_log(LOG_NOTICE, "Rejected dial attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}					}
if (authdebug)							ast_log(LOG_NOTICE, "Rejected dial attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);
authdebug
authdebug
ast_log(LOG_NOTICE, "Rejected dial attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);
ast_log(LOG_NOTICE, "Rejected dial attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context)
ast_log
ast_log
LOG_NOTICE
LOG_NOTICE
"Rejected dial attempt from %s, request '%s@%s' does not exist\n"
ast_inet_ntoa(sin.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
sin.sin_addr
sin
sin
sin_addr
iaxs[fr->callno]->exten
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
exten
iaxs[fr->callno]->context
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
context
memset(&ied0, 0, sizeof(ied0));
memset(&ied0, 0, sizeof(ied0))
memset
memset
&ied0
ied0
ied0
0
sizeof(ied0)
(ied0)
ied0
ied0
iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");
iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension")
iax_ie_append_str
iax_ie_append_str
&ied0
ied0
ied0
IAX_IE_CAUSE
IAX_IE_CAUSE
"No such context/extension"
iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);
iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION)
iax_ie_append_byte
iax_ie_append_byte
&ied0
ied0
ied0
IAX_IE_CAUSECODE
IAX_IE_CAUSECODE
AST_CAUSE_NO_ROUTE_DESTINATION
AST_CAUSE_NO_ROUTE_DESTINATION
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1)
send_command_final
send_command_final
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_REJECT
IAX_COMMAND_REJECT
0
ied0.buf
ied0
ied0
buf
ied0.pos
ied0
ied0
pos
-1
1
if (!iaxs[fr->callno]) {							break;						}
!iaxs[fr->callno]
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{							break;						}
break;
{						char tmp[256];						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);						ast_verb(3, "Accepting DIAL from %s, formats = %s\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat));						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);						send_command(iaxs[fr->callno], AST_FRAME_CONTROL, AST_CONTROL_PROGRESS, 0, NULL, 0, -1);						if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->peerformat, NULL, 1)))							iax2_destroy(fr->callno);						else if (ies.vars) {							struct ast_datastore *variablestore;							struct ast_variable *var, *prev = NULL;							AST_LIST_HEAD(, ast_var_t) *varlist;							varlist = ast_calloc(1, sizeof(*varlist));							variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);							ast_debug(1, "I can haz IAX vars? w00t\n");							if (variablestore && varlist) {								variablestore->data = varlist;								variablestore->inheritance = DATASTORE_INHERIT_FOREVER;								AST_LIST_HEAD_INIT(varlist);								for (var = ies.vars; var; var = var->next) {									struct ast_var_t *newvar = ast_var_assign(var->name, var->value);									if (prev)										ast_free(prev);									prev = var;									if (!newvar) {										/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */										ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									} else {										AST_LIST_INSERT_TAIL(varlist, newvar, entries);									}								}								if (prev)									ast_free(prev);								ies.vars = NULL;								ast_channel_datastore_add(c, variablestore);							} else {								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");								if (variablestore)									ast_datastore_free(variablestore);								if (varlist)									ast_free(varlist);							}						}					}
char tmp[256];
char tmp[256];
char
tmp[256]
tmp
[256]
256
ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);
ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
ast_set_flag
ast_set_flag
&iaxs[fr->callno]->state
iaxs[fr->callno]->state
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
state
IAX_STATE_STARTED
IAX_STATE_STARTED
ast_verb(3, "Accepting DIAL from %s, formats = %s\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat));
ast_verb(3, "Accepting DIAL from %s, formats = %s\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat))
ast_verb
ast_verb
3
"Accepting DIAL from %s, formats = %s\n"
ast_inet_ntoa(sin.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
sin.sin_addr
sin
sin
sin_addr
iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp
tmp
sizeof(tmp)
(tmp)
tmp
tmp
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);
ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
ast_set_flag
ast_set_flag
&iaxs[fr->callno]->state
iaxs[fr->callno]->state
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
state
IAX_STATE_STARTED
IAX_STATE_STARTED
send_command(iaxs[fr->callno], AST_FRAME_CONTROL, AST_CONTROL_PROGRESS, 0, NULL, 0, -1);
send_command(iaxs[fr->callno], AST_FRAME_CONTROL, AST_CONTROL_PROGRESS, 0, NULL, 0, -1)
send_command
send_command
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_CONTROL
AST_FRAME_CONTROL
AST_CONTROL_PROGRESS
AST_CONTROL_PROGRESS
0
NULL
NULL
0
-1
1
if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->peerformat, NULL, 1)))							iax2_destroy(fr->callno);						else if (ies.vars) {							struct ast_datastore *variablestore;							struct ast_variable *var, *prev = NULL;							AST_LIST_HEAD(, ast_var_t) *varlist;							varlist = ast_calloc(1, sizeof(*varlist));							variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);							ast_debug(1, "I can haz IAX vars? w00t\n");							if (variablestore && varlist) {								variablestore->data = varlist;								variablestore->inheritance = DATASTORE_INHERIT_FOREVER;								AST_LIST_HEAD_INIT(varlist);								for (var = ies.vars; var; var = var->next) {									struct ast_var_t *newvar = ast_var_assign(var->name, var->value);									if (prev)										ast_free(prev);									prev = var;									if (!newvar) {										/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */										ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									} else {										AST_LIST_INSERT_TAIL(varlist, newvar, entries);									}								}								if (prev)									ast_free(prev);								ies.vars = NULL;								ast_channel_datastore_add(c, variablestore);							} else {								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");								if (variablestore)									ast_datastore_free(variablestore);								if (varlist)									ast_free(varlist);							}						}
!(c = ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->peerformat, NULL, 1))
(c = ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->peerformat, NULL, 1))
c = ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->peerformat, NULL, 1)
c
c
ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->peerformat, NULL, 1)
ast_iax2_new
ast_iax2_new
fr->callno
fr
fr
callno
AST_STATE_RING
AST_STATE_RING
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
NULL
NULL
1
iax2_destroy(fr->callno);
iax2_destroy(fr->callno)
iax2_destroy
iax2_destroy
fr->callno
fr
fr
callno
if (ies.vars) {							struct ast_datastore *variablestore;							struct ast_variable *var, *prev = NULL;							AST_LIST_HEAD(, ast_var_t) *varlist;							varlist = ast_calloc(1, sizeof(*varlist));							variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);							ast_debug(1, "I can haz IAX vars? w00t\n");							if (variablestore && varlist) {								variablestore->data = varlist;								variablestore->inheritance = DATASTORE_INHERIT_FOREVER;								AST_LIST_HEAD_INIT(varlist);								for (var = ies.vars; var; var = var->next) {									struct ast_var_t *newvar = ast_var_assign(var->name, var->value);									if (prev)										ast_free(prev);									prev = var;									if (!newvar) {										/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */										ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									} else {										AST_LIST_INSERT_TAIL(varlist, newvar, entries);									}								}								if (prev)									ast_free(prev);								ies.vars = NULL;								ast_channel_datastore_add(c, variablestore);							} else {								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");								if (variablestore)									ast_datastore_free(variablestore);								if (varlist)									ast_free(varlist);							}						}
ies.vars
ies
ies
vars
{							struct ast_datastore *variablestore;							struct ast_variable *var, *prev = NULL;							AST_LIST_HEAD(, ast_var_t) *varlist;							varlist = ast_calloc(1, sizeof(*varlist));							variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);							ast_debug(1, "I can haz IAX vars? w00t\n");							if (variablestore && varlist) {								variablestore->data = varlist;								variablestore->inheritance = DATASTORE_INHERIT_FOREVER;								AST_LIST_HEAD_INIT(varlist);								for (var = ies.vars; var; var = var->next) {									struct ast_var_t *newvar = ast_var_assign(var->name, var->value);									if (prev)										ast_free(prev);									prev = var;									if (!newvar) {										/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */										ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									} else {										AST_LIST_INSERT_TAIL(varlist, newvar, entries);									}								}								if (prev)									ast_free(prev);								ies.vars = NULL;								ast_channel_datastore_add(c, variablestore);							} else {								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");								if (variablestore)									ast_datastore_free(variablestore);								if (varlist)									ast_free(varlist);							}						}
struct ast_datastore *variablestore;
struct ast_datastore *variablestore;
struct ast_datastore
ast_datastore
*variablestore
*
variablestore
struct ast_variable *var, *prev = NULL;
struct ast_variable *var, *prev = NULL;
struct ast_variable
ast_variable
*var
*
var
*prev = NULL
*
prev
= NULL
NULL
NULL
AST_LIST_HEAD(, ast_var_t) *varlist;
varlist = ast_calloc(1, sizeof(*varlist));
varlist = ast_calloc(1, sizeof(*varlist))
varlist
varlist
ast_calloc(1, sizeof(*varlist))
ast_calloc
ast_calloc
1
sizeof(*varlist)
(*varlist)
*varlist
varlist
varlist
variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);
variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL)
variablestore
variablestore
ast_datastore_alloc(&iax2_variable_datastore_info, NULL)
ast_datastore_alloc
ast_datastore_alloc
&iax2_variable_datastore_info
iax2_variable_datastore_info
iax2_variable_datastore_info
NULL
NULL
ast_debug(1, "I can haz IAX vars? w00t\n");
ast_debug(1, "I can haz IAX vars? w00t\n")
ast_debug
ast_debug
1
"I can haz IAX vars? w00t\n"
if (variablestore && varlist) {								variablestore->data = varlist;								variablestore->inheritance = DATASTORE_INHERIT_FOREVER;								AST_LIST_HEAD_INIT(varlist);								for (var = ies.vars; var; var = var->next) {									struct ast_var_t *newvar = ast_var_assign(var->name, var->value);									if (prev)										ast_free(prev);									prev = var;									if (!newvar) {										/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */										ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									} else {										AST_LIST_INSERT_TAIL(varlist, newvar, entries);									}								}								if (prev)									ast_free(prev);								ies.vars = NULL;								ast_channel_datastore_add(c, variablestore);							} else {								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");								if (variablestore)									ast_datastore_free(variablestore);								if (varlist)									ast_free(varlist);							}
variablestore && varlist
variablestore
variablestore
varlist
varlist
{								variablestore->data = varlist;								variablestore->inheritance = DATASTORE_INHERIT_FOREVER;								AST_LIST_HEAD_INIT(varlist);								for (var = ies.vars; var; var = var->next) {									struct ast_var_t *newvar = ast_var_assign(var->name, var->value);									if (prev)										ast_free(prev);									prev = var;									if (!newvar) {										/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */										ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									} else {										AST_LIST_INSERT_TAIL(varlist, newvar, entries);									}								}								if (prev)									ast_free(prev);								ies.vars = NULL;								ast_channel_datastore_add(c, variablestore);							}
variablestore->data = varlist;
variablestore->data = varlist
variablestore->data
variablestore
variablestore
data
varlist
varlist
variablestore->inheritance = DATASTORE_INHERIT_FOREVER;
variablestore->inheritance = DATASTORE_INHERIT_FOREVER
variablestore->inheritance
variablestore
variablestore
inheritance
DATASTORE_INHERIT_FOREVER
DATASTORE_INHERIT_FOREVER
AST_LIST_HEAD_INIT(varlist);
AST_LIST_HEAD_INIT(varlist);
AST_LIST_HEAD_INIT
AST_LIST_HEAD_INIT
(varlist)
varlist
varlist
for (var = ies.vars; var; var = var->next) {									struct ast_var_t *newvar = ast_var_assign(var->name, var->value);									if (prev)										ast_free(prev);									prev = var;									if (!newvar) {										/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */										ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									} else {										AST_LIST_INSERT_TAIL(varlist, newvar, entries);									}								}
var = ies.vars;
var = ies.vars
var
var
ies.vars
ies
ies
vars
var
var
var = var->next
var
var
var->next
var
var
next
{									struct ast_var_t *newvar = ast_var_assign(var->name, var->value);									if (prev)										ast_free(prev);									prev = var;									if (!newvar) {										/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */										ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									} else {										AST_LIST_INSERT_TAIL(varlist, newvar, entries);									}								}
struct ast_var_t *newvar = ast_var_assign(var->name, var->value);
struct ast_var_t *newvar = ast_var_assign(var->name, var->value);
struct ast_var_t
ast_var_t
*newvar = ast_var_assign(var->name, var->value)
*
newvar
= ast_var_assign(var->name, var->value)
ast_var_assign(var->name, var->value)
ast_var_assign
ast_var_assign
var->name
var
var
name
var->value
var
var
value
if (prev)										ast_free(prev);
prev
prev
ast_free(prev);
ast_free(prev)
ast_free
ast_free
prev
prev
prev = var;
prev = var
prev
prev
var
var
if (!newvar) {										/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */										ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									} else {										AST_LIST_INSERT_TAIL(varlist, newvar, entries);									}
!newvar
newvar
newvar
{										/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */										ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									}
ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");
ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n")
ast_log
ast_log
LOG_ERROR
LOG_ERROR
"Memory allocation error while processing IAX2 variables\n"
{										AST_LIST_INSERT_TAIL(varlist, newvar, entries);									}
AST_LIST_INSERT_TAIL(varlist, newvar, entries);
AST_LIST_INSERT_TAIL(varlist, newvar, entries)
AST_LIST_INSERT_TAIL
AST_LIST_INSERT_TAIL
varlist
varlist
newvar
newvar
entries
entries
if (prev)									ast_free(prev);
prev
prev
ast_free(prev);
ast_free(prev)
ast_free
ast_free
prev
prev
ies.vars = NULL;
ies.vars = NULL
ies.vars
ies
ies
vars
NULL
NULL
ast_channel_datastore_add(c, variablestore);
ast_channel_datastore_add(c, variablestore)
ast_channel_datastore_add
ast_channel_datastore_add
c
c
variablestore
variablestore
{								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");								if (variablestore)									ast_datastore_free(variablestore);								if (varlist)									ast_free(varlist);							}
ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");
ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n")
ast_log
ast_log
LOG_ERROR
LOG_ERROR
"Memory allocation error while processing IAX2 variables\n"
if (variablestore)									ast_datastore_free(variablestore);
variablestore
variablestore
ast_datastore_free(variablestore);
ast_datastore_free(variablestore)
ast_datastore_free
ast_datastore_free
variablestore
variablestore
if (varlist)									ast_free(varlist);
varlist
varlist
ast_free(varlist);
ast_free(varlist);
ast_free
ast_free
(varlist)
varlist
varlist
break;
case IAX_COMMAND_INVAL:
IAX_COMMAND_INVAL
IAX_COMMAND_INVAL
iaxs[fr->callno]->error = ENOTCONN;
iaxs[fr->callno]->error = ENOTCONN
iaxs[fr->callno]->error
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
error
ENOTCONN
ENOTCONN
ast_debug(1, "Immediately destroying %d, having received INVAL\n", fr->callno);
ast_debug(1, "Immediately destroying %d, having received INVAL\n", fr->callno)
ast_debug
ast_debug
1
"Immediately destroying %d, having received INVAL\n"
fr->callno
fr
fr
callno
iax2_destroy(fr->callno);
iax2_destroy(fr->callno)
iax2_destroy
iax2_destroy
fr->callno
fr
fr
callno
ast_debug(1, "Destroying call %d\n", fr->callno);
ast_debug(1, "Destroying call %d\n", fr->callno)
ast_debug
ast_debug
1
"Destroying call %d\n"
fr->callno
fr
fr
callno
break;
case IAX_COMMAND_VNAK:
IAX_COMMAND_VNAK
IAX_COMMAND_VNAK
ast_debug(1, "Received VNAK: resending outstanding frames\n");
ast_debug(1, "Received VNAK: resending outstanding frames\n")
ast_debug
ast_debug
1
"Received VNAK: resending outstanding frames\n"
vnak_retransmit(fr->callno, fr->iseqno);
vnak_retransmit(fr->callno, fr->iseqno)
vnak_retransmit
vnak_retransmit
fr->callno
fr
fr
callno
fr->iseqno
fr
fr
iseqno
break;
case IAX_COMMAND_REGREQ:
IAX_COMMAND_REGREQ
IAX_COMMAND_REGREQ
case IAX_COMMAND_REGREL:
IAX_COMMAND_REGREL
IAX_COMMAND_REGREL
if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
delayreject
delayreject
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
send_command_immediate
send_command_immediate
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_ACK
IAX_COMMAND_ACK
fr->ts
fr
fr
ts
NULL
NULL
0
fr->iseqno
fr
fr
iseqno
if (register_verify(fr->callno, &sin, &ies)) {					if (!iaxs[fr->callno]) {						break;					}					/* Send delayed failure */					auth_fail(fr->callno, IAX_COMMAND_REGREJ);					break;				}
register_verify(fr->callno, &sin, &ies)
register_verify
register_verify
fr->callno
fr
fr
callno
&sin
sin
sin
&ies
ies
ies
{					if (!iaxs[fr->callno]) {						break;					}					/* Send delayed failure */					auth_fail(fr->callno, IAX_COMMAND_REGREJ);					break;				}
if (!iaxs[fr->callno]) {						break;					}
!iaxs[fr->callno]
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{						break;					}
break;
auth_fail(fr->callno, IAX_COMMAND_REGREJ);
auth_fail(fr->callno, IAX_COMMAND_REGREJ)
auth_fail
auth_fail
fr->callno
fr
fr
callno
IAX_COMMAND_REGREJ
IAX_COMMAND_REGREJ
break;
if (!iaxs[fr->callno]) {					break;				}
!iaxs[fr->callno]
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{					break;				}
break;
if ((ast_strlen_zero(iaxs[fr->callno]->secret) && ast_strlen_zero(iaxs[fr->callno]->inkeys)) ||						ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED)) {					if (f.subclass.integer == IAX_COMMAND_REGREL) {						memset(&sin, 0, sizeof(sin));						sin.sin_family = AF_INET;					}					if (update_registry(&sin, fr->callno, ies.devicetype, fd, ies.refresh)) {						ast_log(LOG_WARNING, "Registry error\n");					}					if (!iaxs[fr->callno]) {						break;					}					if (ies.provverpres && ies.serviceident && sin.sin_addr.s_addr) {						ast_mutex_unlock(&iaxsl[fr->callno]);						check_provisioning(&sin, fd, ies.serviceident, ies.provver);						ast_mutex_lock(&iaxsl[fr->callno]);					}					break;				}
(ast_strlen_zero(iaxs[fr->callno]->secret) && ast_strlen_zero(iaxs[fr->callno]->inkeys)) ||						ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED)
(ast_strlen_zero(iaxs[fr->callno]->secret) && ast_strlen_zero(iaxs[fr->callno]->inkeys))
ast_strlen_zero(iaxs[fr->callno]->secret) && ast_strlen_zero(iaxs[fr->callno]->inkeys)
ast_strlen_zero(iaxs[fr->callno]->secret)
ast_strlen_zero
ast_strlen_zero
iaxs[fr->callno]->secret
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
secret
ast_strlen_zero(iaxs[fr->callno]->inkeys)
ast_strlen_zero
ast_strlen_zero
iaxs[fr->callno]->inkeys
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
inkeys
ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED)
ast_test_flag
ast_test_flag
&iaxs[fr->callno]->state
iaxs[fr->callno]->state
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
state
IAX_STATE_AUTHENTICATED
IAX_STATE_AUTHENTICATED
{					if (f.subclass.integer == IAX_COMMAND_REGREL) {						memset(&sin, 0, sizeof(sin));						sin.sin_family = AF_INET;					}					if (update_registry(&sin, fr->callno, ies.devicetype, fd, ies.refresh)) {						ast_log(LOG_WARNING, "Registry error\n");					}					if (!iaxs[fr->callno]) {						break;					}					if (ies.provverpres && ies.serviceident && sin.sin_addr.s_addr) {						ast_mutex_unlock(&iaxsl[fr->callno]);						check_provisioning(&sin, fd, ies.serviceident, ies.provver);						ast_mutex_lock(&iaxsl[fr->callno]);					}					break;				}
if (f.subclass.integer == IAX_COMMAND_REGREL) {						memset(&sin, 0, sizeof(sin));						sin.sin_family = AF_INET;					}
f.subclass.integer == IAX_COMMAND_REGREL
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_REGREL
IAX_COMMAND_REGREL
{						memset(&sin, 0, sizeof(sin));						sin.sin_family = AF_INET;					}
memset(&sin, 0, sizeof(sin));
memset(&sin, 0, sizeof(sin))
memset
memset
&sin
sin
sin
0
sizeof(sin)
(sin)
sin
sin
sin.sin_family = AF_INET;
sin.sin_family = AF_INET
sin.sin_family
sin
sin
sin_family
AF_INET
AF_INET
if (update_registry(&sin, fr->callno, ies.devicetype, fd, ies.refresh)) {						ast_log(LOG_WARNING, "Registry error\n");					}
update_registry(&sin, fr->callno, ies.devicetype, fd, ies.refresh)
update_registry
update_registry
&sin
sin
sin
fr->callno
fr
fr
callno
ies.devicetype
ies
ies
devicetype
fd
fd
ies.refresh
ies
ies
refresh
{						ast_log(LOG_WARNING, "Registry error\n");					}
ast_log(LOG_WARNING, "Registry error\n");
ast_log(LOG_WARNING, "Registry error\n")
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"Registry error\n"
if (!iaxs[fr->callno]) {						break;					}
!iaxs[fr->callno]
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{						break;					}
break;
if (ies.provverpres && ies.serviceident && sin.sin_addr.s_addr) {						ast_mutex_unlock(&iaxsl[fr->callno]);						check_provisioning(&sin, fd, ies.serviceident, ies.provver);						ast_mutex_lock(&iaxsl[fr->callno]);					}
ies.provverpres && ies.serviceident && sin.sin_addr.s_addr
ies.provverpres && ies.serviceident
ies.provverpres
ies
ies
provverpres
ies.serviceident
ies
ies
serviceident
sin.sin_addr.s_addr
sin.sin_addr
sin
sin
sin_addr
s_addr
{						ast_mutex_unlock(&iaxsl[fr->callno]);						check_provisioning(&sin, fd, ies.serviceident, ies.provver);						ast_mutex_lock(&iaxsl[fr->callno]);					}
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock
ast_mutex_unlock
(&iaxsl[fr->callno])
&iaxsl[fr->callno]
&
iaxsl
[fr->callno]
fr->callno
fr
fr
callno
check_provisioning(&sin, fd, ies.serviceident, ies.provver);
check_provisioning(&sin, fd, ies.serviceident, ies.provver)
check_provisioning
check_provisioning
&sin
sin
sin
fd
fd
ies.serviceident
ies
ies
serviceident
ies.provver
ies
ies
provver
ast_mutex_lock(&iaxsl[fr->callno]);
ast_mutex_lock(&iaxsl[fr->callno])
ast_mutex_lock
ast_mutex_lock
&iaxsl[fr->callno]
iaxsl[fr->callno]
iaxsl
iaxsl
fr->callno
fr
fr
callno
break;
registry_authrequest(fr->callno);
registry_authrequest(fr->callno)
registry_authrequest
registry_authrequest
fr->callno
fr
fr
callno
break;
case IAX_COMMAND_REGACK:
IAX_COMMAND_REGACK
IAX_COMMAND_REGACK
if (iax2_ack_registry(&ies, &sin, fr->callno)) 					ast_log(LOG_WARNING, "Registration failure\n");
iax2_ack_registry(&ies, &sin, fr->callno)
iax2_ack_registry
iax2_ack_registry
&ies
ies
ies
&sin
sin
sin
fr->callno
fr
fr
callno
ast_log(LOG_WARNING, "Registration failure\n");
ast_log(LOG_WARNING, "Registration failure\n")
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"Registration failure\n"
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
send_command_immediate
send_command_immediate
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_ACK
IAX_COMMAND_ACK
fr->ts
fr
fr
ts
NULL
NULL
0
fr->iseqno
fr
fr
iseqno
iax2_destroy(fr->callno);
iax2_destroy(fr->callno)
iax2_destroy
iax2_destroy
fr->callno
fr
fr
callno
break;
case IAX_COMMAND_REGREJ:
IAX_COMMAND_REGREJ
IAX_COMMAND_REGREJ
if (iaxs[fr->callno]->reg) {					if (authdebug) {						ast_log(LOG_NOTICE, "Registration of '%s' rejected: '%s' from: '%s'\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>", ast_inet_ntoa(sin.sin_addr));						manager_event(EVENT_FLAG_SYSTEM, "Registry", "ChannelType: IAX2\r\nUsername: %s\r\nStatus: Rejected\r\nCause: %s\r\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>");					}					iaxs[fr->callno]->reg->regstate = REG_STATE_REJECTED;				}
iaxs[fr->callno]->reg
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
reg
{					if (authdebug) {						ast_log(LOG_NOTICE, "Registration of '%s' rejected: '%s' from: '%s'\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>", ast_inet_ntoa(sin.sin_addr));						manager_event(EVENT_FLAG_SYSTEM, "Registry", "ChannelType: IAX2\r\nUsername: %s\r\nStatus: Rejected\r\nCause: %s\r\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>");					}					iaxs[fr->callno]->reg->regstate = REG_STATE_REJECTED;				}
if (authdebug) {						ast_log(LOG_NOTICE, "Registration of '%s' rejected: '%s' from: '%s'\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>", ast_inet_ntoa(sin.sin_addr));						manager_event(EVENT_FLAG_SYSTEM, "Registry", "ChannelType: IAX2\r\nUsername: %s\r\nStatus: Rejected\r\nCause: %s\r\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>");					}
authdebug
authdebug
{						ast_log(LOG_NOTICE, "Registration of '%s' rejected: '%s' from: '%s'\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>", ast_inet_ntoa(sin.sin_addr));						manager_event(EVENT_FLAG_SYSTEM, "Registry", "ChannelType: IAX2\r\nUsername: %s\r\nStatus: Rejected\r\nCause: %s\r\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>");					}
ast_log(LOG_NOTICE, "Registration of '%s' rejected: '%s' from: '%s'\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>", ast_inet_ntoa(sin.sin_addr));
ast_log(LOG_NOTICE, "Registration of '%s' rejected: '%s' from: '%s'\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>", ast_inet_ntoa(sin.sin_addr))
ast_log
ast_log
LOG_NOTICE
LOG_NOTICE
"Registration of '%s' rejected: '%s' from: '%s'\n"
iaxs[fr->callno]->reg->username
iaxs[fr->callno]->reg
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
reg
username
ies.cause ? ies.cause : "<unknown>"
ies.cause
ies
ies
cause
ies.cause
ies
ies
cause
"<unknown>"
ast_inet_ntoa(sin.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
sin.sin_addr
sin
sin
sin_addr
manager_event(EVENT_FLAG_SYSTEM, "Registry", "ChannelType: IAX2\r\nUsername: %s\r\nStatus: Rejected\r\nCause: %s\r\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>");
manager_event(EVENT_FLAG_SYSTEM, "Registry", "ChannelType: IAX2\r\nUsername: %s\r\nStatus: Rejected\r\nCause: %s\r\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>")
manager_event
manager_event
EVENT_FLAG_SYSTEM
EVENT_FLAG_SYSTEM
"Registry"
"ChannelType: IAX2\r\nUsername: %s\r\nStatus: Rejected\r\nCause: %s\r\n"
iaxs[fr->callno]->reg->username
iaxs[fr->callno]->reg
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
reg
username
ies.cause ? ies.cause : "<unknown>"
ies.cause
ies
ies
cause
ies.cause
ies
ies
cause
"<unknown>"
iaxs[fr->callno]->reg->regstate = REG_STATE_REJECTED;
iaxs[fr->callno]->reg->regstate = REG_STATE_REJECTED
iaxs[fr->callno]->reg->regstate
iaxs[fr->callno]->reg
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
reg
regstate
REG_STATE_REJECTED
REG_STATE_REJECTED
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
send_command_immediate
send_command_immediate
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_ACK
IAX_COMMAND_ACK
fr->ts
fr
fr
ts
NULL
NULL
0
fr->iseqno
fr
fr
iseqno
iax2_destroy(fr->callno);
iax2_destroy(fr->callno)
iax2_destroy
iax2_destroy
fr->callno
fr
fr
callno
break;
case IAX_COMMAND_REGAUTH:
IAX_COMMAND_REGAUTH
IAX_COMMAND_REGAUTH
if (registry_rerequest(&ies, fr->callno, &sin)) {					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No authority found");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_FACILITY_NOT_SUBSCRIBED);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);				}
registry_rerequest(&ies, fr->callno, &sin)
registry_rerequest
registry_rerequest
&ies
ies
ies
fr->callno
fr
fr
callno
&sin
sin
sin
{					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No authority found");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_FACILITY_NOT_SUBSCRIBED);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);				}
memset(&ied0, 0, sizeof(ied0));
memset(&ied0, 0, sizeof(ied0))
memset
memset
&ied0
ied0
ied0
0
sizeof(ied0)
(ied0)
ied0
ied0
iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No authority found");
iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No authority found")
iax_ie_append_str
iax_ie_append_str
&ied0
ied0
ied0
IAX_IE_CAUSE
IAX_IE_CAUSE
"No authority found"
iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_FACILITY_NOT_SUBSCRIBED);
iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_FACILITY_NOT_SUBSCRIBED)
iax_ie_append_byte
iax_ie_append_byte
&ied0
ied0
ied0
IAX_IE_CAUSECODE
IAX_IE_CAUSECODE
AST_CAUSE_FACILITY_NOT_SUBSCRIBED
AST_CAUSE_FACILITY_NOT_SUBSCRIBED
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1)
send_command_final
send_command_final
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_REJECT
IAX_COMMAND_REJECT
0
ied0.buf
ied0
ied0
buf
ied0.pos
ied0
ied0
pos
-1
1
break;
case IAX_COMMAND_TXREJ:
IAX_COMMAND_TXREJ
IAX_COMMAND_TXREJ
iaxs[fr->callno]->transferring = 0;
iaxs[fr->callno]->transferring = 0
iaxs[fr->callno]->transferring
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
transferring
0
ast_verb(3, "Channel '%s' unable to transfer\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");
ast_verb(3, "Channel '%s' unable to transfer\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>")
ast_verb
ast_verb
3
"Channel '%s' unable to transfer\n"
iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>"
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
ast_channel_name(iaxs[fr->callno]->owner)
ast_channel_name
ast_channel_name
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
"<Unknown>"
memset(&iaxs[fr->callno]->transfer, 0, sizeof(iaxs[fr->callno]->transfer));
memset(&iaxs[fr->callno]->transfer, 0, sizeof(iaxs[fr->callno]->transfer))
memset
memset
&iaxs[fr->callno]->transfer
iaxs[fr->callno]->transfer
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
transfer
0
sizeof(iaxs[fr->callno]->transfer)
(iaxs[fr->callno]->transfer)
iaxs[fr->callno]->transfer
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
transfer
if (iaxs[fr->callno]->bridgecallno) {					if (iaxs[iaxs[fr->callno]->bridgecallno]->transferring) {						iaxs[iaxs[fr->callno]->bridgecallno]->transferring = 0;						send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREJ, 0, NULL, 0, -1);					}				}
iaxs[fr->callno]->bridgecallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
bridgecallno
{					if (iaxs[iaxs[fr->callno]->bridgecallno]->transferring) {						iaxs[iaxs[fr->callno]->bridgecallno]->transferring = 0;						send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREJ, 0, NULL, 0, -1);					}				}
if (iaxs[iaxs[fr->callno]->bridgecallno]->transferring) {						iaxs[iaxs[fr->callno]->bridgecallno]->transferring = 0;						send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREJ, 0, NULL, 0, -1);					}
iaxs[iaxs[fr->callno]->bridgecallno]->transferring
iaxs[iaxs[fr->callno]->bridgecallno]
iaxs
iaxs
iaxs[fr->callno]->bridgecallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
bridgecallno
transferring
{						iaxs[iaxs[fr->callno]->bridgecallno]->transferring = 0;						send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREJ, 0, NULL, 0, -1);					}
iaxs[iaxs[fr->callno]->bridgecallno]->transferring = 0;
iaxs[iaxs[fr->callno]->bridgecallno]->transferring = 0
iaxs[iaxs[fr->callno]->bridgecallno]->transferring
iaxs[iaxs[fr->callno]->bridgecallno]
iaxs
iaxs
iaxs[fr->callno]->bridgecallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
bridgecallno
transferring
0
send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREJ, 0, NULL, 0, -1);
send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREJ, 0, NULL, 0, -1)
send_command
send_command
iaxs[iaxs[fr->callno]->bridgecallno]
iaxs
iaxs
iaxs[fr->callno]->bridgecallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
bridgecallno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_TXREJ
IAX_COMMAND_TXREJ
0
NULL
NULL
0
-1
1
break;
case IAX_COMMAND_TXREADY:
IAX_COMMAND_TXREADY
IAX_COMMAND_TXREADY
if ((iaxs[fr->callno]->transferring == TRANSFER_BEGIN) ||				    (iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)) {					if (iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)						iaxs[fr->callno]->transferring = TRANSFER_MREADY;					else						iaxs[fr->callno]->transferring = TRANSFER_READY;					ast_verb(3, "Channel '%s' ready to transfer\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					if (iaxs[fr->callno]->bridgecallno) {						if ((iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_READY) ||						    (iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_MREADY)) {							/* They're both ready, now release them. */							if (iaxs[fr->callno]->transferring == TRANSFER_MREADY) {								ast_verb(3, "Attempting media bridge of %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_MEDIA;								iaxs[fr->callno]->transferring = TRANSFER_MEDIA;								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied1.buf, ied1.pos, -1);							} else {								ast_verb(3, "Releasing %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_RELEASED;								iaxs[fr->callno]->transferring = TRANSFER_RELEASED;								ast_set_flag64(iaxs[iaxs[fr->callno]->bridgecallno], IAX_ALREADYGONE);								ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);								/* Stop doing lag & ping requests */								stop_stuff(fr->callno);								stop_stuff(iaxs[fr->callno]->bridgecallno);								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied1.buf, ied1.pos, -1);							}						}					}				}
(iaxs[fr->callno]->transferring == TRANSFER_BEGIN) ||				    (iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)
(iaxs[fr->callno]->transferring == TRANSFER_BEGIN)
iaxs[fr->callno]->transferring == TRANSFER_BEGIN
iaxs[fr->callno]->transferring
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
transferring
TRANSFER_BEGIN
TRANSFER_BEGIN
(iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)
iaxs[fr->callno]->transferring == TRANSFER_MBEGIN
iaxs[fr->callno]->transferring
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
transferring
TRANSFER_MBEGIN
TRANSFER_MBEGIN
{					if (iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)						iaxs[fr->callno]->transferring = TRANSFER_MREADY;					else						iaxs[fr->callno]->transferring = TRANSFER_READY;					ast_verb(3, "Channel '%s' ready to transfer\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					if (iaxs[fr->callno]->bridgecallno) {						if ((iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_READY) ||						    (iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_MREADY)) {							/* They're both ready, now release them. */							if (iaxs[fr->callno]->transferring == TRANSFER_MREADY) {								ast_verb(3, "Attempting media bridge of %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_MEDIA;								iaxs[fr->callno]->transferring = TRANSFER_MEDIA;								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied1.buf, ied1.pos, -1);							} else {								ast_verb(3, "Releasing %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_RELEASED;								iaxs[fr->callno]->transferring = TRANSFER_RELEASED;								ast_set_flag64(iaxs[iaxs[fr->callno]->bridgecallno], IAX_ALREADYGONE);								ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);								/* Stop doing lag & ping requests */								stop_stuff(fr->callno);								stop_stuff(iaxs[fr->callno]->bridgecallno);								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied1.buf, ied1.pos, -1);							}						}					}				}
if (iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)						iaxs[fr->callno]->transferring = TRANSFER_MREADY;					else						iaxs[fr->callno]->transferring = TRANSFER_READY;
iaxs[fr->callno]->transferring == TRANSFER_MBEGIN
iaxs[fr->callno]->transferring
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
transferring
TRANSFER_MBEGIN
TRANSFER_MBEGIN
iaxs[fr->callno]->transferring = TRANSFER_MREADY;
iaxs[fr->callno]->transferring = TRANSFER_MREADY
iaxs[fr->callno]->transferring
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
transferring
TRANSFER_MREADY
TRANSFER_MREADY
iaxs[fr->callno]->transferring = TRANSFER_READY;
iaxs[fr->callno]->transferring = TRANSFER_READY
iaxs[fr->callno]->transferring
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
transferring
TRANSFER_READY
TRANSFER_READY
ast_verb(3, "Channel '%s' ready to transfer\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");
ast_verb(3, "Channel '%s' ready to transfer\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>")
ast_verb
ast_verb
3
"Channel '%s' ready to transfer\n"
iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>"
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
ast_channel_name(iaxs[fr->callno]->owner)
ast_channel_name
ast_channel_name
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
"<Unknown>"
if (iaxs[fr->callno]->bridgecallno) {						if ((iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_READY) ||						    (iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_MREADY)) {							/* They're both ready, now release them. */							if (iaxs[fr->callno]->transferring == TRANSFER_MREADY) {								ast_verb(3, "Attempting media bridge of %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_MEDIA;								iaxs[fr->callno]->transferring = TRANSFER_MEDIA;								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied1.buf, ied1.pos, -1);							} else {								ast_verb(3, "Releasing %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_RELEASED;								iaxs[fr->callno]->transferring = TRANSFER_RELEASED;								ast_set_flag64(iaxs[iaxs[fr->callno]->bridgecallno], IAX_ALREADYGONE);								ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);								/* Stop doing lag & ping requests */								stop_stuff(fr->callno);								stop_stuff(iaxs[fr->callno]->bridgecallno);								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied1.buf, ied1.pos, -1);							}						}					}
iaxs[fr->callno]->bridgecallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
bridgecallno
{						if ((iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_READY) ||						    (iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_MREADY)) {							/* They're both ready, now release them. */							if (iaxs[fr->callno]->transferring == TRANSFER_MREADY) {								ast_verb(3, "Attempting media bridge of %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_MEDIA;								iaxs[fr->callno]->transferring = TRANSFER_MEDIA;								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied1.buf, ied1.pos, -1);							} else {								ast_verb(3, "Releasing %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_RELEASED;								iaxs[fr->callno]->transferring = TRANSFER_RELEASED;								ast_set_flag64(iaxs[iaxs[fr->callno]->bridgecallno], IAX_ALREADYGONE);								ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);								/* Stop doing lag & ping requests */								stop_stuff(fr->callno);								stop_stuff(iaxs[fr->callno]->bridgecallno);								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied1.buf, ied1.pos, -1);							}						}					}
if ((iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_READY) ||						    (iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_MREADY)) {							/* They're both ready, now release them. */							if (iaxs[fr->callno]->transferring == TRANSFER_MREADY) {								ast_verb(3, "Attempting media bridge of %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_MEDIA;								iaxs[fr->callno]->transferring = TRANSFER_MEDIA;								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied1.buf, ied1.pos, -1);							} else {								ast_verb(3, "Releasing %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_RELEASED;								iaxs[fr->callno]->transferring = TRANSFER_RELEASED;								ast_set_flag64(iaxs[iaxs[fr->callno]->bridgecallno], IAX_ALREADYGONE);								ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);								/* Stop doing lag & ping requests */								stop_stuff(fr->callno);								stop_stuff(iaxs[fr->callno]->bridgecallno);								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied1.buf, ied1.pos, -1);							}						}
(iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_READY) ||						    (iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_MREADY)
(iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_READY)
iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_READY
iaxs[iaxs[fr->callno]->bridgecallno]->transferring
iaxs[iaxs[fr->callno]->bridgecallno]
iaxs
iaxs
iaxs[fr->callno]->bridgecallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
bridgecallno
transferring
TRANSFER_READY
TRANSFER_READY
(iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_MREADY)
iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_MREADY
iaxs[iaxs[fr->callno]->bridgecallno]->transferring
iaxs[iaxs[fr->callno]->bridgecallno]
iaxs
iaxs
iaxs[fr->callno]->bridgecallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
bridgecallno
transferring
TRANSFER_MREADY
TRANSFER_MREADY
{							/* They're both ready, now release them. */							if (iaxs[fr->callno]->transferring == TRANSFER_MREADY) {								ast_verb(3, "Attempting media bridge of %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_MEDIA;								iaxs[fr->callno]->transferring = TRANSFER_MEDIA;								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied1.buf, ied1.pos, -1);							} else {								ast_verb(3, "Releasing %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_RELEASED;								iaxs[fr->callno]->transferring = TRANSFER_RELEASED;								ast_set_flag64(iaxs[iaxs[fr->callno]->bridgecallno], IAX_ALREADYGONE);								ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);								/* Stop doing lag & ping requests */								stop_stuff(fr->callno);								stop_stuff(iaxs[fr->callno]->bridgecallno);								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied1.buf, ied1.pos, -1);							}						}
if (iaxs[fr->callno]->transferring == TRANSFER_MREADY) {								ast_verb(3, "Attempting media bridge of %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_MEDIA;								iaxs[fr->callno]->transferring = TRANSFER_MEDIA;								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied1.buf, ied1.pos, -1);							} else {								ast_verb(3, "Releasing %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_RELEASED;								iaxs[fr->callno]->transferring = TRANSFER_RELEASED;								ast_set_flag64(iaxs[iaxs[fr->callno]->bridgecallno], IAX_ALREADYGONE);								ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);								/* Stop doing lag & ping requests */								stop_stuff(fr->callno);								stop_stuff(iaxs[fr->callno]->bridgecallno);								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied1.buf, ied1.pos, -1);							}
iaxs[fr->callno]->transferring == TRANSFER_MREADY
iaxs[fr->callno]->transferring
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
transferring
TRANSFER_MREADY
TRANSFER_MREADY
{								ast_verb(3, "Attempting media bridge of %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_MEDIA;								iaxs[fr->callno]->transferring = TRANSFER_MEDIA;								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied1.buf, ied1.pos, -1);							}
ast_verb(3, "Attempting media bridge of %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");
ast_verb(3, "Attempting media bridge of %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>")
ast_verb
ast_verb
3
"Attempting media bridge of %s and %s\n"
iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>"
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
ast_channel_name(iaxs[fr->callno]->owner)
ast_channel_name
ast_channel_name
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
"<Unknown>"
iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>"
iaxs[iaxs[fr->callno]->bridgecallno]->owner
iaxs[iaxs[fr->callno]->bridgecallno]
iaxs
iaxs
iaxs[fr->callno]->bridgecallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
bridgecallno
owner
ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner)
ast_channel_name
ast_channel_name
iaxs[iaxs[fr->callno]->bridgecallno]->owner
iaxs[iaxs[fr->callno]->bridgecallno]
iaxs
iaxs
iaxs[fr->callno]->bridgecallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
bridgecallno
owner
"<Unknown>"
iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_MEDIA;
iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_MEDIA
iaxs[iaxs[fr->callno]->bridgecallno]->transferring
iaxs[iaxs[fr->callno]->bridgecallno]
iaxs
iaxs
iaxs[fr->callno]->bridgecallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
bridgecallno
transferring
TRANSFER_MEDIA
TRANSFER_MEDIA
iaxs[fr->callno]->transferring = TRANSFER_MEDIA;
iaxs[fr->callno]->transferring = TRANSFER_MEDIA
iaxs[fr->callno]->transferring
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
transferring
TRANSFER_MEDIA
TRANSFER_MEDIA
memset(&ied0, 0, sizeof(ied0));
memset(&ied0, 0, sizeof(ied0))
memset
memset
&ied0
ied0
ied0
0
sizeof(ied0)
(ied0)
ied0
ied0
memset(&ied1, 0, sizeof(ied1));
memset(&ied1, 0, sizeof(ied1))
memset
memset
&ied1
ied1
ied1
0
sizeof(ied1)
(ied1)
ied1
ied1
iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);
iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno)
iax_ie_append_short
iax_ie_append_short
&ied0
ied0
ied0
IAX_IE_CALLNO
IAX_IE_CALLNO
iaxs[iaxs[fr->callno]->bridgecallno]->peercallno
iaxs[iaxs[fr->callno]->bridgecallno]
iaxs
iaxs
iaxs[fr->callno]->bridgecallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
bridgecallno
peercallno
iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);
iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno)
iax_ie_append_short
iax_ie_append_short
&ied1
ied1
ied1
IAX_IE_CALLNO
IAX_IE_CALLNO
iaxs[fr->callno]->peercallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercallno
send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied0.buf, ied0.pos, -1);
send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied0.buf, ied0.pos, -1)
send_command
send_command
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_TXMEDIA
IAX_COMMAND_TXMEDIA
0
ied0.buf
ied0
ied0
buf
ied0.pos
ied0
ied0
pos
-1
1
send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied1.buf, ied1.pos, -1);
send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied1.buf, ied1.pos, -1)
send_command
send_command
iaxs[iaxs[fr->callno]->bridgecallno]
iaxs
iaxs
iaxs[fr->callno]->bridgecallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
bridgecallno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_TXMEDIA
IAX_COMMAND_TXMEDIA
0
ied1.buf
ied1
ied1
buf
ied1.pos
ied1
ied1
pos
-1
1
{								ast_verb(3, "Releasing %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_RELEASED;								iaxs[fr->callno]->transferring = TRANSFER_RELEASED;								ast_set_flag64(iaxs[iaxs[fr->callno]->bridgecallno], IAX_ALREADYGONE);								ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);								/* Stop doing lag & ping requests */								stop_stuff(fr->callno);								stop_stuff(iaxs[fr->callno]->bridgecallno);								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied1.buf, ied1.pos, -1);							}
ast_verb(3, "Releasing %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");
ast_verb(3, "Releasing %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>")
ast_verb
ast_verb
3
"Releasing %s and %s\n"
iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>"
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
ast_channel_name(iaxs[fr->callno]->owner)
ast_channel_name
ast_channel_name
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
"<Unknown>"
iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>"
iaxs[iaxs[fr->callno]->bridgecallno]->owner
iaxs[iaxs[fr->callno]->bridgecallno]
iaxs
iaxs
iaxs[fr->callno]->bridgecallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
bridgecallno
owner
ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner)
ast_channel_name
ast_channel_name
iaxs[iaxs[fr->callno]->bridgecallno]->owner
iaxs[iaxs[fr->callno]->bridgecallno]
iaxs
iaxs
iaxs[fr->callno]->bridgecallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
bridgecallno
owner
"<Unknown>"
iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_RELEASED;
iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_RELEASED
iaxs[iaxs[fr->callno]->bridgecallno]->transferring
iaxs[iaxs[fr->callno]->bridgecallno]
iaxs
iaxs
iaxs[fr->callno]->bridgecallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
bridgecallno
transferring
TRANSFER_RELEASED
TRANSFER_RELEASED
iaxs[fr->callno]->transferring = TRANSFER_RELEASED;
iaxs[fr->callno]->transferring = TRANSFER_RELEASED
iaxs[fr->callno]->transferring
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
transferring
TRANSFER_RELEASED
TRANSFER_RELEASED
ast_set_flag64(iaxs[iaxs[fr->callno]->bridgecallno], IAX_ALREADYGONE);
ast_set_flag64(iaxs[iaxs[fr->callno]->bridgecallno], IAX_ALREADYGONE)
ast_set_flag64
ast_set_flag64
iaxs[iaxs[fr->callno]->bridgecallno]
iaxs
iaxs
iaxs[fr->callno]->bridgecallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
bridgecallno
IAX_ALREADYGONE
IAX_ALREADYGONE
ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);
ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE)
ast_set_flag64
ast_set_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_ALREADYGONE
IAX_ALREADYGONE
stop_stuff(fr->callno);
stop_stuff(fr->callno)
stop_stuff
stop_stuff
fr->callno
fr
fr
callno
stop_stuff(iaxs[fr->callno]->bridgecallno);
stop_stuff(iaxs[fr->callno]->bridgecallno)
stop_stuff
stop_stuff
iaxs[fr->callno]->bridgecallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
bridgecallno
memset(&ied0, 0, sizeof(ied0));
memset(&ied0, 0, sizeof(ied0))
memset
memset
&ied0
ied0
ied0
0
sizeof(ied0)
(ied0)
ied0
ied0
memset(&ied1, 0, sizeof(ied1));
memset(&ied1, 0, sizeof(ied1))
memset
memset
&ied1
ied1
ied1
0
sizeof(ied1)
(ied1)
ied1
ied1
iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);
iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno)
iax_ie_append_short
iax_ie_append_short
&ied0
ied0
ied0
IAX_IE_CALLNO
IAX_IE_CALLNO
iaxs[iaxs[fr->callno]->bridgecallno]->peercallno
iaxs[iaxs[fr->callno]->bridgecallno]
iaxs
iaxs
iaxs[fr->callno]->bridgecallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
bridgecallno
peercallno
iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);
iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno)
iax_ie_append_short
iax_ie_append_short
&ied1
ied1
ied1
IAX_IE_CALLNO
IAX_IE_CALLNO
iaxs[fr->callno]->peercallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercallno
send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied0.buf, ied0.pos, -1);
send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied0.buf, ied0.pos, -1)
send_command
send_command
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_TXREL
IAX_COMMAND_TXREL
0
ied0.buf
ied0
ied0
buf
ied0.pos
ied0
ied0
pos
-1
1
send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied1.buf, ied1.pos, -1);
send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied1.buf, ied1.pos, -1)
send_command
send_command
iaxs[iaxs[fr->callno]->bridgecallno]
iaxs
iaxs
iaxs[fr->callno]->bridgecallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
bridgecallno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_TXREL
IAX_COMMAND_TXREL
0
ied1.buf
ied1
ied1
buf
ied1.pos
ied1
ied1
pos
-1
1
break;
case IAX_COMMAND_TXREQ:
IAX_COMMAND_TXREQ
IAX_COMMAND_TXREQ
try_transfer(iaxs[fr->callno], &ies);
try_transfer(iaxs[fr->callno], &ies)
try_transfer
try_transfer
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
&ies
ies
ies
break;
case IAX_COMMAND_TXCNT:
IAX_COMMAND_TXCNT
IAX_COMMAND_TXCNT
if (iaxs[fr->callno]->transferring)					send_command_transfer(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXACC, 0, NULL, 0);
iaxs[fr->callno]->transferring
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
transferring
send_command_transfer(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXACC, 0, NULL, 0);
send_command_transfer(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXACC, 0, NULL, 0)
send_command_transfer
send_command_transfer
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_TXACC
IAX_COMMAND_TXACC
0
NULL
NULL
0
break;
case IAX_COMMAND_TXREL:
IAX_COMMAND_TXREL
IAX_COMMAND_TXREL
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
send_command_immediate
send_command_immediate
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_ACK
IAX_COMMAND_ACK
fr->ts
fr
fr
ts
NULL
NULL
0
fr->iseqno
fr
fr
iseqno
complete_transfer(fr->callno, &ies);
complete_transfer(fr->callno, &ies)
complete_transfer
complete_transfer
fr->callno
fr
fr
callno
&ies
ies
ies
stop_stuff(fr->callno);
stop_stuff(fr->callno)
stop_stuff
stop_stuff
fr->callno
fr
fr
callno
break;
case IAX_COMMAND_TXMEDIA:
IAX_COMMAND_TXMEDIA
IAX_COMMAND_TXMEDIA
if (iaxs[fr->callno]->transferring == TRANSFER_READY) {					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* Cancel any outstanding frames and start anew */						if (cur->transfer) {							cur->retries = -1;						}					}					/* Start sending our media to the transfer address, but otherwise leave the call as-is */					iaxs[fr->callno]->transferring = TRANSFER_MEDIAPASS;				}
iaxs[fr->callno]->transferring == TRANSFER_READY
iaxs[fr->callno]->transferring
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
transferring
TRANSFER_READY
TRANSFER_READY
{					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* Cancel any outstanding frames and start anew */						if (cur->transfer) {							cur->retries = -1;						}					}					/* Start sending our media to the transfer address, but otherwise leave the call as-is */					iaxs[fr->callno]->transferring = TRANSFER_MEDIAPASS;				}
AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list)
AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list)
AST_LIST_TRAVERSE
AST_LIST_TRAVERSE
&frame_queue[fr->callno]
frame_queue[fr->callno]
frame_queue
frame_queue
fr->callno
fr
fr
callno
cur
cur
list
list
)
{						/* Cancel any outstanding frames and start anew */						if (cur->transfer) {							cur->retries = -1;						}					}
if (cur->transfer) {							cur->retries = -1;						}
cur->transfer
cur
cur
transfer
{							cur->retries = -1;						}
cur->retries = -1;
cur->retries = -1
cur->retries
cur
cur
retries
-1
1
iaxs[fr->callno]->transferring = TRANSFER_MEDIAPASS;
iaxs[fr->callno]->transferring = TRANSFER_MEDIAPASS
iaxs[fr->callno]->transferring
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
transferring
TRANSFER_MEDIAPASS
TRANSFER_MEDIAPASS
break;
case IAX_COMMAND_RTKEY:
IAX_COMMAND_RTKEY
IAX_COMMAND_RTKEY
if (!IAX_CALLENCRYPTED(iaxs[fr->callno])) {					ast_log(LOG_WARNING, 						"we've been told to rotate our encryption key, "						"but this isn't an encrypted call. bad things will happen.\n"					);					break;				}
!IAX_CALLENCRYPTED(iaxs[fr->callno])
IAX_CALLENCRYPTED(iaxs[fr->callno])
IAX_CALLENCRYPTED
IAX_CALLENCRYPTED
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{					ast_log(LOG_WARNING, 						"we've been told to rotate our encryption key, "						"but this isn't an encrypted call. bad things will happen.\n"					);					break;				}
ast_log(LOG_WARNING, 						"we've been told to rotate our encryption key, "						"but this isn't an encrypted call. bad things will happen.\n"					);
ast_log(LOG_WARNING, 						"we've been told to rotate our encryption key, "						"but this isn't an encrypted call. bad things will happen.\n"					)
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"we've been told to rotate our encryption key, "						"but this isn't an encrypted call. bad things will happen.\n"
break;
IAX_DEBUGDIGEST("Receiving", ies.challenge);
IAX_DEBUGDIGEST("Receiving", ies.challenge)
IAX_DEBUGDIGEST
IAX_DEBUGDIGEST
"Receiving"
ies.challenge
ies
ies
challenge
ast_aes_set_decrypt_key((unsigned char *) ies.challenge, &iaxs[fr->callno]->dcx);
ast_aes_set_decrypt_key((unsigned char *) ies.challenge, &iaxs[fr->callno]->dcx)
ast_aes_set_decrypt_key
ast_aes_set_decrypt_key
(unsigned char *) ies.challenge
unsigned char *
unsigned char
*
*
ies.challenge
ies
ies
challenge
&iaxs[fr->callno]->dcx
iaxs[fr->callno]->dcx
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
dcx
break;
case IAX_COMMAND_DPREP:
IAX_COMMAND_DPREP
IAX_COMMAND_DPREP
complete_dpreply(iaxs[fr->callno], &ies);
complete_dpreply(iaxs[fr->callno], &ies)
complete_dpreply
complete_dpreply
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
&ies
ies
ies
break;
case IAX_COMMAND_UNSUPPORT:
IAX_COMMAND_UNSUPPORT
IAX_COMMAND_UNSUPPORT
ast_log(LOG_NOTICE, "Peer did not understand our iax command '%d'\n", ies.iax_unknown);
ast_log(LOG_NOTICE, "Peer did not understand our iax command '%d'\n", ies.iax_unknown)
ast_log
ast_log
LOG_NOTICE
LOG_NOTICE
"Peer did not understand our iax command '%d'\n"
ies.iax_unknown
ies
ies
iax_unknown
break;
case IAX_COMMAND_FWDOWNL:
IAX_COMMAND_FWDOWNL
IAX_COMMAND_FWDOWNL
if (!ast_test_flag64(&globalflags, IAX_ALLOWFWDOWNLOAD)) {					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_UNSUPPORT, 0, NULL, 0, -1);					break;				}
!ast_test_flag64(&globalflags, IAX_ALLOWFWDOWNLOAD)
ast_test_flag64(&globalflags, IAX_ALLOWFWDOWNLOAD)
ast_test_flag64
ast_test_flag64
&globalflags
globalflags
globalflags
IAX_ALLOWFWDOWNLOAD
IAX_ALLOWFWDOWNLOAD
{					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_UNSUPPORT, 0, NULL, 0, -1);					break;				}
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_UNSUPPORT, 0, NULL, 0, -1);
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_UNSUPPORT, 0, NULL, 0, -1)
send_command_final
send_command_final
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_UNSUPPORT
IAX_COMMAND_UNSUPPORT
0
NULL
NULL
0
-1
1
break;
memset(&ied0, 0, sizeof(ied0));
memset(&ied0, 0, sizeof(ied0))
memset
memset
&ied0
ied0
ied0
0
sizeof(ied0)
(ied0)
ied0
ied0
res = iax_firmware_append(&ied0, (unsigned char *)ies.devicetype, ies.fwdesc);
res = iax_firmware_append(&ied0, (unsigned char *)ies.devicetype, ies.fwdesc)
res
res
iax_firmware_append(&ied0, (unsigned char *)ies.devicetype, ies.fwdesc)
iax_firmware_append
iax_firmware_append
&ied0
ied0
ied0
(unsigned char *)ies.devicetype
unsigned char *
unsigned char
*
*
ies.devicetype
ies
ies
devicetype
ies.fwdesc
ies
ies
fwdesc
if (res < 0)					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);				else if (res > 0)					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1);				else					send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1);
res < 0
res
res
0
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1)
send_command_final
send_command_final
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_REJECT
IAX_COMMAND_REJECT
0
ied0.buf
ied0
ied0
buf
ied0.pos
ied0
ied0
pos
-1
1
if (res > 0)					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1);				else					send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1);
res > 0
res
res
0
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1);
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1)
send_command_final
send_command_final
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_FWDATA
IAX_COMMAND_FWDATA
0
ied0.buf
ied0
ied0
buf
ied0.pos
ied0
ied0
pos
-1
1
send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1);
send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1)
send_command
send_command
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_FWDATA
IAX_COMMAND_FWDATA
0
ied0.buf
ied0
ied0
buf
ied0.pos
ied0
ied0
pos
-1
1
break;
case IAX_COMMAND_CALLTOKEN:
IAX_COMMAND_CALLTOKEN
IAX_COMMAND_CALLTOKEN
{				struct iax_frame *cur;				/* find last sent frame */				if ((cur = AST_LIST_LAST(&frame_queue[fr->callno])) && ies.calltoken && ies.calltokendata) {					resend_with_token(fr->callno, cur, (char *) ies.calltokendata);				}				break;			}
struct iax_frame *cur;
struct iax_frame *cur;
struct iax_frame
iax_frame
*cur
*
cur
if ((cur = AST_LIST_LAST(&frame_queue[fr->callno])) && ies.calltoken && ies.calltokendata) {					resend_with_token(fr->callno, cur, (char *) ies.calltokendata);				}
(cur = AST_LIST_LAST(&frame_queue[fr->callno])) && ies.calltoken && ies.calltokendata
(cur = AST_LIST_LAST(&frame_queue[fr->callno])) && ies.calltoken
(cur = AST_LIST_LAST(&frame_queue[fr->callno]))
cur = AST_LIST_LAST(&frame_queue[fr->callno])
cur
cur
AST_LIST_LAST(&frame_queue[fr->callno])
AST_LIST_LAST
AST_LIST_LAST
&frame_queue[fr->callno]
frame_queue[fr->callno]
frame_queue
frame_queue
fr->callno
fr
fr
callno
ies.calltoken
ies
ies
calltoken
ies.calltokendata
ies
ies
calltokendata
{					resend_with_token(fr->callno, cur, (char *) ies.calltokendata);				}
resend_with_token(fr->callno, cur, (char *) ies.calltokendata);
resend_with_token(fr->callno, cur, (char *) ies.calltokendata)
resend_with_token
resend_with_token
fr->callno
fr
fr
callno
cur
cur
(char *) ies.calltokendata
char *
char
*
*
ies.calltokendata
ies
ies
calltokendata
break;
default:
ast_debug(1, "Unknown IAX command %d on %d/%d\n", f.subclass.integer, fr->callno, iaxs[fr->callno]->peercallno);
ast_debug(1, "Unknown IAX command %d on %d/%d\n", f.subclass.integer, fr->callno, iaxs[fr->callno]->peercallno)
ast_debug
ast_debug
1
"Unknown IAX command %d on %d/%d\n"
f.subclass.integer
f.subclass
f
f
subclass
integer
fr->callno
fr
fr
callno
iaxs[fr->callno]->peercallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercallno
memset(&ied0, 0, sizeof(ied0));
memset(&ied0, 0, sizeof(ied0))
memset
memset
&ied0
ied0
ied0
0
sizeof(ied0)
(ied0)
ied0
ied0
iax_ie_append_byte(&ied0, IAX_IE_IAX_UNKNOWN, f.subclass.integer);
iax_ie_append_byte(&ied0, IAX_IE_IAX_UNKNOWN, f.subclass.integer)
iax_ie_append_byte
iax_ie_append_byte
&ied0
ied0
ied0
IAX_IE_IAX_UNKNOWN
IAX_IE_IAX_UNKNOWN
f.subclass.integer
f.subclass
f
f
subclass
integer
send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_UNSUPPORT, 0, ied0.buf, ied0.pos, -1);
send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_UNSUPPORT, 0, ied0.buf, ied0.pos, -1)
send_command
send_command
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_UNSUPPORT
IAX_COMMAND_UNSUPPORT
0
ied0.buf
ied0
ied0
buf
ied0.pos
ied0
ied0
pos
-1
1
if (ies.vars) {				ast_variables_destroy(ies.vars);				ast_debug(1, "I can haz IAX vars, but they is no good :-(\n");				ies.vars = NULL;			}
ies.vars
ies
ies
vars
{				ast_variables_destroy(ies.vars);				ast_debug(1, "I can haz IAX vars, but they is no good :-(\n");				ies.vars = NULL;			}
ast_variables_destroy(ies.vars);
ast_variables_destroy(ies.vars)
ast_variables_destroy
ast_variables_destroy
ies.vars
ies
ies
vars
ast_debug(1, "I can haz IAX vars, but they is no good :-(\n");
ast_debug(1, "I can haz IAX vars, but they is no good :-(\n")
ast_debug
ast_debug
1
"I can haz IAX vars, but they is no good :-(\n"
ies.vars = NULL;
ies.vars = NULL
ies.vars
ies
ies
vars
NULL
NULL
if ((f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&			  (f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_INVAL) &&			  (f.subclass.integer != IAX_COMMAND_VNAK)) {				if (iaxs[fr->callno] && iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);			}
(f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&			  (f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_INVAL) &&			  (f.subclass.integer != IAX_COMMAND_VNAK)
(f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&			  (f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_INVAL)
(f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&			  (f.subclass.integer != IAX_COMMAND_TXACC)
(f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT)
(f.subclass.integer != IAX_COMMAND_ACK)
f.subclass.integer != IAX_COMMAND_ACK
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_ACK
IAX_COMMAND_ACK
(f.subclass.integer != IAX_COMMAND_TXCNT)
f.subclass.integer != IAX_COMMAND_TXCNT
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_TXCNT
IAX_COMMAND_TXCNT
(f.subclass.integer != IAX_COMMAND_TXACC)
f.subclass.integer != IAX_COMMAND_TXACC
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_TXACC
IAX_COMMAND_TXACC
(f.subclass.integer != IAX_COMMAND_INVAL)
f.subclass.integer != IAX_COMMAND_INVAL
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_INVAL
IAX_COMMAND_INVAL
(f.subclass.integer != IAX_COMMAND_VNAK)
f.subclass.integer != IAX_COMMAND_VNAK
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_VNAK
IAX_COMMAND_VNAK
{				if (iaxs[fr->callno] && iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);			}
if (iaxs[fr->callno] && iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
iaxs[fr->callno] && iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno
iaxs[fr->callno]->aseqno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
aseqno
iaxs[fr->callno]->iseqno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
iseqno
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
send_command_immediate
send_command_immediate
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_ACK
IAX_COMMAND_ACK
fr->ts
fr
fr
ts
NULL
NULL
0
fr->iseqno
fr
fr
iseqno
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock
ast_mutex_unlock
(&iaxsl[fr->callno])
&iaxsl[fr->callno]
&
iaxsl
[fr->callno]
fr->callno
fr
fr
callno
return 1;
1
if (iaxs[fr->callno] && iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno)			send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
iaxs[fr->callno] && iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno
iaxs[fr->callno]->aseqno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
aseqno
iaxs[fr->callno]->iseqno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
iseqno
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
send_command_immediate
send_command_immediate
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_ACK
IAX_COMMAND_ACK
fr->ts
fr
fr
ts
NULL
NULL
0
fr->iseqno
fr
fr
iseqno
-----joern-----
(6821,4291,0)
(7566,3187,0)
(7597,7355,0)
(8773,2024,0)
(3340,6880,0)
(4846,8188,0)
(1616,3521,0)
(822,9129,0)
(2589,1502,0)
(3483,3874,0)
(4475,8893,0)
(3169,5509,0)
(2885,2166,0)
(4480,476,0)
(6599,2952,0)
(521,8647,0)
(8171,4584,0)
(5137,9089,0)
(4977,540,0)
(2401,4928,0)
(2791,3917,0)
(7184,7450,0)
(8047,5409,0)
(868,1050,0)
(7265,4928,0)
(8463,2819,0)
(4290,1088,0)
(7300,3354,0)
(3795,679,0)
(4537,2462,0)
(2041,6912,0)
(7693,1091,0)
(7468,4551,0)
(8829,5244,0)
(6987,6922,0)
(7670,818,0)
(1427,1170,0)
(7143,4512,0)
(3047,3647,0)
(4452,3480,0)
(8246,7225,0)
(8089,8506,0)
(1997,2953,0)
(5560,1975,0)
(4222,5043,0)
(4753,435,0)
(2467,216,0)
(7866,5071,0)
(2852,7875,0)
(7734,3129,0)
(5782,793,0)
(619,2193,0)
(6405,6713,0)
(4812,9108,0)
(1708,2159,0)
(1917,7496,0)
(8043,4775,0)
(3213,8848,0)
(1,5817,0)
(2144,9150,0)
(6423,3852,0)
(6815,6416,0)
(7046,1128,0)
(7917,1502,0)
(4133,7666,0)
(4412,2141,0)
(3915,4747,0)
(1359,1502,0)
(7521,3583,0)
(5408,4754,0)
(3330,7884,0)
(9155,7188,0)
(5734,4783,0)
(5843,6150,0)
(3501,1977,0)
(5704,5134,0)
(7260,8035,0)
(2414,8039,0)
(3144,7076,0)
(1648,2656,0)
(7486,5949,0)
(1650,8415,0)
(1210,2047,0)
(1653,1502,0)
(451,1316,0)
(8480,1502,0)
(2366,3880,0)
(4942,3485,0)
(8510,1603,0)
(5689,5610,0)
(4148,8733,0)
(3655,4245,0)
(9002,2656,0)
(3069,3229,0)
(5098,6057,0)
(2454,2320,0)
(2699,5043,0)
(1749,334,0)
(606,8340,0)
(3874,6431,0)
(6432,4934,0)
(954,2135,0)
(3670,2011,0)
(362,6047,0)
(2767,842,0)
(7139,500,0)
(5371,8868,0)
(7603,8471,0)
(2477,1502,0)
(1702,2039,0)
(864,3496,0)
(6758,2062,0)
(4214,5218,0)
(5085,284,0)
(5626,5354,0)
(976,8037,0)
(546,5932,0)
(5830,2184,0)
(7763,7624,0)
(49,7992,0)
(662,1502,0)
(7677,8822,0)
(2723,1982,0)
(2471,1502,0)
(5327,6047,0)
(6500,6994,0)
(2186,2074,0)
(9037,4985,0)
(4830,2013,0)
(5109,2863,0)
(2970,8385,0)
(8918,2220,0)
(7805,5043,0)
(126,3605,0)
(3681,8688,0)
(211,8637,0)
(6304,3465,0)
(4588,8840,0)
(3067,8516,0)
(3535,2663,0)
(3585,8950,0)
(2656,4623,0)
(7238,598,0)
(6886,1686,0)
(775,181,0)
(5820,3152,0)
(505,7994,0)
(3287,54,0)
(7689,1502,0)
(4622,3672,0)
(7422,1502,0)
(3860,331,0)
(3528,2728,0)
(3477,9,0)
(2091,1206,0)
(8990,605,0)
(5014,1419,0)
(3520,5477,0)
(5849,3216,0)
(4640,1502,0)
(1451,7389,0)
(6637,5259,0)
(1392,1502,0)
(1025,3288,0)
(3509,1919,0)
(4578,927,0)
(9130,4928,0)
(4348,7021,0)
(2047,1210,0)
(1176,5718,0)
(8647,2926,0)
(5294,3624,0)
(4490,1502,0)
(1107,1620,0)
(7516,2283,0)
(5364,4552,0)
(5344,314,0)
(3680,4642,0)
(3083,4928,0)
(3196,2744,0)
(6869,7999,0)
(1677,6606,0)
(5845,2700,0)
(5411,1930,0)
(2787,5999,0)
(5474,1502,0)
(8635,3082,0)
(7820,5443,0)
(559,2402,0)
(5137,5778,0)
(2641,836,0)
(9057,5078,0)
(9103,1387,0)
(6217,972,0)
(81,5282,0)
(1173,2349,0)
(7219,3557,0)
(1181,4491,0)
(1158,5305,0)
(4841,1502,0)
(6119,3510,0)
(5108,5871,0)
(662,4928,0)
(9005,2280,0)
(5064,3184,0)
(2719,8400,0)
(2622,3534,0)
(5569,4991,0)
(2468,5266,0)
(639,7453,0)
(3328,2414,0)
(630,4914,0)
(3753,4928,0)
(1349,3043,0)
(6569,4928,0)
(7878,8306,0)
(8593,4997,0)
(903,3161,0)
(4444,4835,0)
(4873,1502,0)
(2359,603,0)
(49,4928,0)
(4437,4551,0)
(7427,4928,0)
(8854,1549,0)
(3093,5994,0)
(354,4744,0)
(8727,1334,0)
(2717,5754,0)
(2473,4928,0)
(4456,6183,0)
(7012,3677,0)
(2505,2704,0)
(6818,8877,0)
(1494,7240,0)
(7405,7905,0)
(1099,3624,0)
(2775,3942,0)
(8859,1539,0)
(46,9080,0)
(23,8334,0)
(7077,4551,0)
(1446,1502,0)
(2760,4001,0)
(6363,2129,0)
(8347,7545,0)
(6933,4518,0)
(829,519,0)
(5826,1185,0)
(1521,5504,0)
(3134,2666,0)
(7238,4021,0)
(2904,8205,0)
(8442,6985,0)
(2027,7969,0)
(8729,343,0)
(340,2199,0)
(2622,1043,0)
(372,1753,0)
(8121,6054,0)
(1665,5118,0)
(5761,8809,0)
(538,7468,0)
(6988,3416,0)
(3532,4266,0)
(7240,1502,0)
(1244,2398,0)
(6520,4986,0)
(5391,4778,0)
(2171,8797,0)
(6178,2772,0)
(856,418,0)
(7486,2322,0)
(3424,4702,0)
(4965,5136,0)
(6229,863,0)
(2498,2496,0)
(6690,8421,0)
(5756,494,0)
(8211,3693,0)
(5693,6110,0)
(285,8385,0)
(7389,8288,0)
(2008,1502,0)
(5806,7288,0)
(2071,2686,0)
(5294,6981,0)
(2563,6560,0)
(5330,1502,0)
(3060,1503,0)
(2794,4647,0)
(6293,822,0)
(3238,8975,0)
(335,847,0)
(7301,6173,0)
(5837,7984,0)
(2179,5469,0)
(9084,7264,0)
(3420,1590,0)
(6546,3594,0)
(8240,7885,0)
(593,5082,0)
(484,2782,0)
(2642,8452,0)
(4820,2035,0)
(849,1515,0)
(2401,1502,0)
(4150,4676,0)
(8684,2378,0)
(3627,7355,0)
(1446,1895,0)
(4437,908,0)
(5437,6953,0)
(4641,3594,0)
(1029,4030,0)
(6751,3777,0)
(8201,8022,0)
(8036,1046,0)
(8065,7208,0)
(2232,648,0)
(2586,5733,0)
(5224,1543,0)
(1817,7474,0)
(6175,898,0)
(2860,4502,0)
(3123,8722,0)
(3614,7016,0)
(4260,6059,0)
(4024,8593,0)
(542,7119,0)
(1194,8451,0)
(1146,5932,0)
(4744,8085,0)
(4296,761,0)
(1759,3605,0)
(8204,1456,0)
(3507,3632,0)
(5929,159,0)
(6460,6688,0)
(1274,3793,0)
(8299,5291,0)
(7046,6560,0)
(2071,1428,0)
(3396,9142,0)
(8947,312,0)
(9037,3465,0)
(8866,8937,0)
(3621,5861,0)
(5321,3007,0)
(7991,7100,0)
(8632,1502,0)
(4276,5178,0)
(1221,4799,0)
(1049,6244,0)
(6249,3667,0)
(7426,4284,0)
(4221,4928,0)
(3076,1892,0)
(3231,2414,0)
(7699,7867,0)
(9148,1502,0)
(4042,2426,0)
(2225,3777,0)
(7005,3251,0)
(1530,1502,0)
(1846,2611,0)
(2785,1503,0)
(6130,4591,0)
(8751,2571,0)
(2272,5573,0)
(5842,8893,0)
(8249,522,0)
(8887,1821,0)
(3604,7304,0)
(3580,1982,0)
(8094,8624,0)
(3302,598,0)
(4954,984,0)
(2571,1502,0)
(8328,6385,0)
(3224,3787,0)
(8465,7453,0)
(1092,2698,0)
(2804,8593,0)
(7697,730,0)
(8357,7043,0)
(2111,1249,0)
(7612,5515,0)
(8829,2113,0)
(3462,7526,0)
(7955,1794,0)
(1877,5115,0)
(1923,5891,0)
(3682,1006,0)
(8686,1631,0)
(4717,1609,0)
(8484,658,0)
(5322,1502,0)
(4786,1295,0)
(4837,3211,0)
(89,7004,0)
(706,727,0)
(6674,6940,0)
(8263,1768,0)
(4730,1389,0)
(9149,2950,0)
(8457,1108,0)
(7743,328,0)
(6081,4024,0)
(6294,7477,0)
(1391,2773,0)
(2831,1520,0)
(7459,8487,0)
(3302,8188,0)
(2424,3943,0)
(4628,593,0)
(8765,3699,0)
(1139,7685,0)
(3526,2898,0)
(1250,6232,0)
(6573,6518,0)
(5504,1521,0)
(7558,1761,0)
(6356,2402,0)
(4232,5467,0)
(3983,5142,0)
(5265,3677,0)
(8538,392,0)
(243,1251,0)
(1802,1367,0)
(6957,157,0)
(5755,4928,0)
(4437,4335,0)
(1977,2661,0)
(4816,1152,0)
(8891,3583,0)
(6996,5214,0)
(8694,4893,0)
(2927,466,0)
(6304,1855,0)
(1355,7610,0)
(5000,5426,0)
(4623,7526,0)
(6398,2176,0)
(263,8724,0)
(1477,5646,0)
(8114,5915,0)
(3933,9031,0)
(7949,2979,0)
(4810,5202,0)
(5774,5934,0)
(6868,7309,0)
(7160,8910,0)
(3131,4374,0)
(5503,3243,0)
(2067,5902,0)
(4074,46,0)
(162,5718,0)
(942,212,0)
(2197,2699,0)
(7682,4139,0)
(1620,1502,0)
(6410,4272,0)
(7944,3581,0)
(6248,2753,0)
(4234,5035,0)
(7375,1207,0)
(7094,7453,0)
(5741,4695,0)
(6122,5346,0)
(1964,1798,0)
(8706,1048,0)
(904,1793,0)
(3939,9022,0)
(6640,4928,0)
(3681,6047,0)
(8418,3311,0)
(2358,2882,0)
(1654,5202,0)
(4572,2893,0)
(3518,8843,0)
(648,1502,0)
(1334,4928,0)
(788,3929,0)
(7254,6591,0)
(6508,2998,0)
(5544,1502,0)
(8335,7061,0)
(830,4266,0)
(6758,4928,0)
(2005,4004,0)
(6482,2806,0)
(6159,7405,0)
(2368,5859,0)
(3864,7597,0)
(6530,4928,0)
(3074,2246,0)
(677,5260,0)
(3540,3088,0)
(1395,3648,0)
(911,189,0)
(4833,6431,0)
(6298,7122,0)
(8195,1553,0)
(569,4928,0)
(4286,6546,0)
(6654,1988,0)
(826,3375,0)
(9046,8637,0)
(6229,4592,0)
(1884,4928,0)
(5383,6643,0)
(4954,5891,0)
(8111,1219,0)
(289,7545,0)
(4747,5614,0)
(7125,1502,0)
(4748,8464,0)
(2368,7390,0)
(7822,4711,0)
(3623,5218,0)
(658,4928,0)
(6417,5623,0)
(3322,8312,0)
(8550,8759,0)
(8507,3414,0)
(2212,915,0)
(1838,4362,0)
(8159,468,0)
(5371,2574,0)
(2630,3137,0)
(7986,3489,0)
(90,2381,0)
(635,412,0)
(5294,4955,0)
(8707,1961,0)
(447,166,0)
(8386,2894,0)
(4090,7892,0)
(5846,8578,0)
(8826,1982,0)
(2416,5888,0)
(7458,5104,0)
(1570,740,0)
(4425,8876,0)
(3036,8222,0)
(2320,7092,0)
(7023,5029,0)
(3279,2964,0)
(3870,6290,0)
(881,522,0)
(7689,4928,0)
(4694,2443,0)
(2637,7659,0)
(871,7161,0)
(5498,5751,0)
(6851,1812,0)
(8145,8334,0)
(3539,6783,0)
(9090,1502,0)
(4631,7264,0)
(1915,6726,0)
(276,334,0)
(2025,8066,0)
(6391,2242,0)
(1467,3504,0)
(4014,4595,0)
(4104,4653,0)
(7844,4169,0)
(8117,5320,0)
(3728,2656,0)
(8797,2171,0)
(2027,427,0)
(3230,1889,0)
(8632,4928,0)
(880,499,0)
(711,1439,0)
(4962,6871,0)
(7800,5211,0)
(4439,8245,0)
(4938,5705,0)
(1907,1284,0)
(3741,2126,0)
(8780,4744,0)
(4561,3931,0)
(8868,390,0)
(8025,1598,0)
(5489,5902,0)
(8616,902,0)
(6304,1591,0)
(2152,3390,0)
(1300,3819,0)
(3810,2771,0)
(6867,3385,0)
(3989,4175,0)
(2248,1502,0)
(6907,7793,0)
(2108,6285,0)
(2209,5088,0)
(1374,3433,0)
(6523,7463,0)
(2967,4649,0)
(7947,7167,0)
(5018,7004,0)
(9130,4834,0)
(4307,3639,0)
(8146,4555,0)
(1622,7725,0)
(4106,6346,0)
(6205,2801,0)
(6009,4494,0)
(9066,8201,0)
(8699,3337,0)
(1549,4928,0)
(3333,7979,0)
(8031,6073,0)
(4653,4281,0)
(8049,8260,0)
(1289,4928,0)
(5478,7889,0)
(5666,7554,0)
(6221,3279,0)
(1685,5997,0)
(1786,8334,0)
(1009,4509,0)
(2013,1502,0)
(7103,3491,0)
(9026,8678,0)
(4605,8887,0)
(732,582,0)
(7159,6495,0)
(4670,7239,0)
(1050,6737,0)
(1042,1502,0)
(3973,2679,0)
(2328,551,0)
(8461,1502,0)
(5663,1983,0)
(6526,39,0)
(4498,1160,0)
(4101,6746,0)
(7523,9122,0)
(7991,2894,0)
(8848,3213,0)
(4281,1577,0)
(6749,3326,0)
(3042,3526,0)
(5847,8335,0)
(9015,3217,0)
(350,6888,0)
(8272,7219,0)
(8070,6068,0)
(4802,8028,0)
(8809,5761,0)
(4562,3870,0)
(4178,6188,0)
(8075,1423,0)
(2626,2445,0)
(8800,3721,0)
(6029,1478,0)
(3184,1502,0)
(6605,727,0)
(3299,4928,0)
(4382,5226,0)
(2660,8593,0)
(5116,1155,0)
(8728,7017,0)
(6932,3341,0)
(6210,5451,0)
(7230,1442,0)
(2410,1515,0)
(5294,3465,0)
(5955,7521,0)
(2315,7473,0)
(4623,826,0)
(3605,5640,0)
(6812,4150,0)
(5440,4610,0)
(278,6802,0)
(4312,4452,0)
(2638,1254,0)
(361,1502,0)
(6883,1502,0)
(1464,8892,0)
(6647,5658,0)
(1530,6047,0)
(1028,1502,0)
(2196,3383,0)
(3008,5993,0)
(559,4928,0)
(1365,5878,0)
(1097,3088,0)
(4402,680,0)
(298,6948,0)
(4180,1166,0)
(525,3799,0)
(2336,4150,0)
(3821,4702,0)
(8366,2214,0)
(2776,6075,0)
(7791,7049,0)
(5686,5902,0)
(4484,3125,0)
(3967,498,0)
(7349,3608,0)
(6693,1506,0)
(1552,3473,0)
(612,2223,0)
(8564,4680,0)
(3455,4740,0)
(5568,7648,0)
(4220,1512,0)
(651,1953,0)
(1747,3326,0)
(2704,2505,0)
(7096,1880,0)
(2599,514,0)
(8547,2535,0)
(3912,2043,0)
(8690,4150,0)
(1423,905,0)
(8789,8550,0)
(6930,7252,0)
(1199,7829,0)
(2806,5048,0)
(9137,4206,0)
(3188,1141,0)
(2819,4928,0)
(8501,15,0)
(4350,5328,0)
(4437,3674,0)
(6724,9083,0)
(3159,4928,0)
(8213,3243,0)
(7447,6431,0)
(803,4473,0)
(1006,8072,0)
(950,4548,0)
(9106,7453,0)
(1053,5209,0)
(8927,5066,0)
(1769,6873,0)
(4472,1591,0)
(8600,6739,0)
(8407,6073,0)
(429,171,0)
(460,4928,0)
(4192,8402,0)
(1726,4928,0)
(4115,2981,0)
(7437,6517,0)
(3027,4809,0)
(6780,4374,0)
(322,5646,0)
(844,2414,0)
(418,856,0)
(7990,2741,0)
(2760,7901,0)
(5264,8843,0)
(801,8979,0)
(3712,3199,0)
(5900,5218,0)
(7652,6047,0)
(3161,6206,0)
(605,8716,0)
(4483,4158,0)
(6950,2471,0)
(7449,3953,0)
(4971,3654,0)
(5757,4928,0)
(5219,2192,0)
(2706,341,0)
(3215,6728,0)
(4280,1502,0)
(5370,8086,0)
(7975,2737,0)
(6416,6815,0)
(6930,2898,0)
(5975,4928,0)
(4766,2401,0)
(1232,7946,0)
(3486,1502,0)
(5294,820,0)
(7468,7100,0)
(5143,840,0)
(4343,2056,0)
(46,6147,0)
(8806,1986,0)
(1743,3084,0)
(7446,3084,0)
(3537,6587,0)
(8791,1502,0)
(7880,7453,0)
(3868,5222,0)
(2768,4725,0)
(8082,828,0)
(4592,7172,0)
(5493,4928,0)
(7906,9106,0)
(8311,5066,0)
(8473,491,0)
(6304,2113,0)
(3390,2152,0)
(730,7697,0)
(252,6500,0)
(2964,3279,0)
(8232,981,0)
(424,4951,0)
(6364,6561,0)
(4336,1502,0)
(7991,1228,0)
(6322,5789,0)
(5075,3583,0)
(4629,2882,0)
(4517,1502,0)
(8430,6574,0)
(5230,5618,0)
(6448,8199,0)
(6640,1502,0)
(2902,4930,0)
(4417,2732,0)
(5711,4808,0)
(2487,8188,0)
(3651,2962,0)
(5294,1128,0)
(3153,1502,0)
(2613,5897,0)
(3628,598,0)
(351,7838,0)
(8239,8083,0)
(609,8311,0)
(6626,5680,0)
(3157,4013,0)
(7738,4327,0)
(7372,7512,0)
(1206,2091,0)
(2391,5048,0)
(8218,4847,0)
(1426,1382,0)
(4341,2192,0)
(4328,1756,0)
(4360,2738,0)
(4034,1539,0)
(6304,6853,0)
(2641,4793,0)
(2941,7924,0)
(3857,7687,0)
(1419,8848,0)
(3098,7562,0)
(2754,521,0)
(1424,6195,0)
(4277,5942,0)
(2122,2368,0)
(8345,7173,0)
(1,6270,0)
(5689,7557,0)
(2202,1502,0)
(718,1,0)
(6506,6554,0)
(4278,1502,0)
(9037,598,0)
(2817,5342,0)
(1734,1828,0)
(8961,6205,0)
(1487,2662,0)
(1954,1328,0)
(3,6150,0)
(6442,7453,0)
(6672,4928,0)
(7324,7113,0)
(2296,3272,0)
(4887,7432,0)
(8599,7351,0)
(504,4551,0)
(1901,1502,0)
(2214,2639,0)
(7783,6431,0)
(5418,4352,0)
(394,4928,0)
(4547,6611,0)
(1698,4928,0)
(8415,8668,0)
(4871,1836,0)
(7750,4928,0)
(5489,9076,0)
(5737,1231,0)
(1024,3414,0)
(372,5854,0)
(287,6568,0)
(2403,4928,0)
(1271,2515,0)
(8997,56,0)
(8542,6802,0)
(2945,8484,0)
(2156,3185,0)
(2361,4972,0)
(207,2684,0)
(2800,2461,0)
(8908,6998,0)
(8832,6737,0)
(675,8105,0)
(7161,7137,0)
(1676,4775,0)
(1158,4928,0)
(5011,6949,0)
(3097,1774,0)
(5199,4833,0)
(8158,3114,0)
(5390,6958,0)
(3243,8213,0)
(6917,7155,0)
(7889,4928,0)
(5275,1419,0)
(676,3686,0)
(4176,2222,0)
(367,1749,0)
(8894,8650,0)
(4690,2925,0)
(1694,423,0)
(1294,1593,0)
(1059,5637,0)
(7771,6365,0)
(5827,3382,0)
(4446,4647,0)
(6735,7453,0)
(8444,8877,0)
(6439,1631,0)
(1882,5218,0)
(3466,6862,0)
(965,8016,0)
(5469,8510,0)
(5733,1502,0)
(3838,4322,0)
(5235,7453,0)
(7589,847,0)
(2155,9075,0)
(8461,2794,0)
(6710,4332,0)
(8452,291,0)
(4070,1840,0)
(2468,5023,0)
(7793,1502,0)
(4595,4014,0)
(2210,8298,0)
(7945,2679,0)
(2691,751,0)
(6230,7453,0)
(7778,4928,0)
(8723,3545,0)
(1565,1968,0)
(7252,5286,0)
(4240,7453,0)
(4999,941,0)
(588,998,0)
(9052,385,0)
(5118,4928,0)
(7383,6985,0)
(4649,2967,0)
(3822,4070,0)
(5838,1600,0)
(4739,1502,0)
(658,6047,0)
(4065,7215,0)
(7364,8884,0)
(188,4747,0)
(4684,5264,0)
(5438,32,0)
(5658,7518,0)
(6606,4293,0)
(3368,4062,0)
(5151,5270,0)
(3862,5717,0)
(1700,1288,0)
(8748,6264,0)
(2095,6170,0)
(5641,2357,0)
(4847,8218,0)
(6529,789,0)
(6883,6880,0)
(4593,2772,0)
(4347,1008,0)
(865,3159,0)
(5776,1475,0)
(6222,1274,0)
(8062,4722,0)
(3522,2199,0)
(5486,216,0)
(1364,8494,0)
(3717,4415,0)
(1316,8986,0)
(2126,3267,0)
(6830,4928,0)
(4078,1087,0)
(6145,1693,0)
(1096,7753,0)
(7991,7148,0)
(8937,632,0)
(7106,2869,0)
(5200,7571,0)
(3189,8779,0)
(8435,5177,0)
(5071,494,0)
(9134,2283,0)
(5398,7022,0)
(1109,7291,0)
(7690,4164,0)
(8604,5781,0)
(4633,8408,0)
(3686,676,0)
(5267,7671,0)
(1342,8294,0)
(4020,4247,0)
(3411,598,0)
(1100,3921,0)
(8393,6896,0)
(192,6288,0)
(2299,1219,0)
(1348,5218,0)
(8261,6238,0)
(8653,3421,0)
(5646,4527,0)
(4437,7092,0)
(2229,7453,0)
(7457,8360,0)
(7712,1133,0)
(2305,8888,0)
(6989,4330,0)
(811,8103,0)
(1469,4525,0)
(333,7948,0)
(2152,1502,0)
(2221,6508,0)
(246,7546,0)
(2770,6184,0)
(8175,2212,0)
(2320,2893,0)
(5459,4322,0)
(7123,2283,0)
(165,3869,0)
(4341,2126,0)
(4532,8455,0)
(6367,4836,0)
(4980,4480,0)
(152,8260,0)
(6622,2679,0)
(1943,1025,0)
(7854,6032,0)
(1555,5114,0)
(6304,6560,0)
(1450,4222,0)
(8858,5902,0)
(5377,2636,0)
(4074,4220,0)
(3253,9125,0)
(4110,2054,0)
(2093,1675,0)
(8920,7917,0)
(8779,7516,0)
(1657,3338,0)
(3878,8753,0)
(8889,1081,0)
(6641,2525,0)
(211,6070,0)
(8800,5526,0)
(5436,791,0)
(6792,4594,0)
(5618,5230,0)
(3069,4928,0)
(5919,4507,0)
(8787,1711,0)
(82,632,0)
(2430,7273,0)
(8761,2894,0)
(7692,1592,0)
(8048,4477,0)
(5878,8265,0)
(1594,8535,0)
(7760,1075,0)
(5452,3130,0)
(8193,7049,0)
(294,8313,0)
(6698,2961,0)
(1592,8850,0)
(4678,2898,0)
(2878,2904,0)
(7610,4928,0)
(1393,7267,0)
(2025,6999,0)
(3318,8840,0)
(3140,6038,0)
(8344,5957,0)
(567,4928,0)
(4951,3120,0)
(9139,5172,0)
(1102,21,0)
(83,2525,0)
(2441,7347,0)
(6961,603,0)
(6873,6505,0)
(4407,4320,0)
(4742,8604,0)
(2038,98,0)
(7687,3582,0)
(4842,3130,0)
(7218,6084,0)
(5927,4732,0)
(2829,3902,0)
(4073,1155,0)
(3043,6385,0)
(2072,5260,0)
(1180,8071,0)
(585,6792,0)
(1188,7191,0)
(1572,5218,0)
(2123,6978,0)
(5402,1009,0)
(5470,450,0)
(1449,6512,0)
(6450,5147,0)
(8064,2230,0)
(3806,1075,0)
(1690,7178,0)
(1202,4820,0)
(101,7829,0)
(5327,4928,0)
(5936,7446,0)
(2102,5531,0)
(1710,6384,0)
(731,8795,0)
(4899,8987,0)
(1008,4018,0)
(2670,2466,0)
(4451,4147,0)
(3836,2635,0)
(7565,1515,0)
(4009,1046,0)
(8935,1905,0)
(7736,7004,0)
(4055,1000,0)
(4836,1174,0)
(4575,6,0)
(3590,8918,0)
(2647,2847,0)
(4658,1502,0)
(8092,313,0)
(4069,5474,0)
(3631,3869,0)
(740,4624,0)
(1247,4168,0)
(7192,7004,0)
(5998,4212,0)
(2953,956,0)
(1246,4928,0)
(6304,6988,0)
(7575,6938,0)
(2582,1220,0)
(7047,6208,0)
(5204,2882,0)
(1082,5681,0)
(6981,3248,0)
(5457,175,0)
(7289,4739,0)
(919,3292,0)
(4781,2915,0)
(2320,2113,0)
(5433,1050,0)
(2605,2898,0)
(2602,9105,0)
(6587,3537,0)
(3919,4834,0)
(5294,4910,0)
(8942,530,0)
(7072,4974,0)
(5496,3921,0)
(6545,1226,0)
(8287,5571,0)
(590,3777,0)
(1199,3880,0)
(2350,5977,0)
(3302,1207,0)
(9122,7523,0)
(1962,1880,0)
(6879,2576,0)
(6443,7946,0)
(4884,7453,0)
(5573,3391,0)
(7629,1478,0)
(4699,1341,0)
(3610,198,0)
(5663,3233,0)
(3383,4890,0)
(8678,4928,0)
(7354,1582,0)
(960,6430,0)
(4623,7518,0)
(1433,157,0)
(312,6751,0)
(5594,5286,0)
(768,8612,0)
(8980,4459,0)
(3743,3378,0)
(1913,2951,0)
(1919,5966,0)
(2007,7509,0)
(6598,6974,0)
(2389,150,0)
(6058,2322,0)
(5759,1502,0)
(4666,1768,0)
(3230,5043,0)
(8321,4333,0)
(7061,3823,0)
(5122,6431,0)
(4590,1502,0)
(7841,2964,0)
(7862,3182,0)
(402,1218,0)
(8267,8287,0)
(4493,6571,0)
(2911,5048,0)
(4286,2898,0)
(8294,1342,0)
(6715,3152,0)
(731,5301,0)
(3758,8033,0)
(5920,1474,0)
(4865,5849,0)
(4503,5988,0)
(6170,2095,0)
(2656,7847,0)
(3410,4928,0)
(1687,7056,0)
(8816,948,0)
(310,5705,0)
(6158,7937,0)
(6660,748,0)
(8677,5613,0)
(5862,2782,0)
(5560,1502,0)
(4888,3317,0)
(2402,6905,0)
(9033,1502,0)
(8888,2898,0)
(5682,5149,0)
(2234,2535,0)
(2869,598,0)
(8776,2493,0)
(7971,5322,0)
(4361,7311,0)
(1333,7628,0)
(4178,609,0)
(9043,6272,0)
(1235,1492,0)
(1776,614,0)
(7466,4928,0)
(6435,675,0)
(6068,8843,0)
(1396,4571,0)
(8560,3530,0)
(1701,805,0)
(2854,7091,0)
(7817,6659,0)
(5524,8213,0)
(3900,5509,0)
(5385,896,0)
(8836,4404,0)
(4670,7004,0)
(7196,2555,0)
(721,2461,0)
(6431,8960,0)
(5928,3990,0)
(3886,4928,0)
(6198,7196,0)
(5531,7057,0)
(1924,1749,0)
(3427,2051,0)
(1142,6431,0)
(3044,3378,0)
(3288,4928,0)
(1793,598,0)
(5162,2898,0)
(3409,4928,0)
(8140,8395,0)
(5961,6705,0)
(2466,4765,0)
(8778,669,0)
(6034,9126,0)
(8944,4928,0)
(180,1609,0)
(280,1553,0)
(6847,5337,0)
(6796,8214,0)
(2442,5887,0)
(712,1228,0)
(5297,143,0)
(2146,4979,0)
(5300,4471,0)
(3591,5574,0)
(5217,7324,0)
(3094,2704,0)
(6301,254,0)
(4602,997,0)
(2463,6360,0)
(5505,7501,0)
(7521,6752,0)
(2250,9062,0)
(2320,6465,0)
(2033,7453,0)
(2182,1774,0)
(2869,7092,0)
(4022,6379,0)
(4759,6353,0)
(7304,514,0)
(8280,4928,0)
(4378,1891,0)
(9137,7905,0)
(2843,1502,0)
(8630,3855,0)
(7984,339,0)
(3757,235,0)
(7046,8678,0)
(7307,2047,0)
(1553,8195,0)
(8579,3721,0)
(2022,408,0)
(3474,2214,0)
(6192,6744,0)
(8107,400,0)
(3528,6703,0)
(5430,4078,0)
(7077,7100,0)
(4616,4760,0)
(3487,7030,0)
(8653,7893,0)
(1120,4928,0)
(972,3583,0)
(8923,1760,0)
(4491,1181,0)
(6312,7281,0)
(4810,392,0)
(4352,6047,0)
(8708,8519,0)
(3319,4928,0)
(5899,7199,0)
(7750,1502,0)
(5101,7388,0)
(2865,5111,0)
(691,3971,0)
(5923,3738,0)
(1556,9081,0)
(6928,2732,0)
(4092,3779,0)
(12,2493,0)
(7778,1502,0)
(3716,6882,0)
(6378,7397,0)
(4401,8635,0)
(504,8678,0)
(6686,6401,0)
(1987,7674,0)
(50,1914,0)
(5294,1919,0)
(1399,1882,0)
(8733,4148,0)
(7261,1502,0)
(5562,6467,0)
(6885,7341,0)
(7525,4849,0)
(7900,8247,0)
(1077,2329,0)
(1751,791,0)
(1120,1502,0)
(1318,1956,0)
(4848,526,0)
(7030,1409,0)
(7592,485,0)
(3338,1502,0)
(9063,3192,0)
(7551,6182,0)
(8675,3202,0)
(4409,6767,0)
(8622,4688,0)
(1128,1502,0)
(6181,3221,0)
(1266,1271,0)
(6048,8056,0)
(5895,4740,0)
(4979,5465,0)
(3606,6384,0)
(5360,5594,0)
(268,2219,0)
(2073,4744,0)
(1986,8806,0)
(822,4928,0)
(7991,8678,0)
(7535,4525,0)
(994,5875,0)
(1631,4928,0)
(2124,2741,0)
(2825,6889,0)
(4437,932,0)
(567,1502,0)
(720,8325,0)
(2317,7533,0)
(7236,6010,0)
(4573,8886,0)
(3264,8288,0)
(2306,9010,0)
(6242,5942,0)
(7171,5211,0)
(1287,9031,0)
(3990,5043,0)
(5390,6959,0)
(3932,7453,0)
(2689,4851,0)
(5658,3058,0)
(1809,7760,0)
(3482,6431,0)
(4933,8105,0)
(5861,3621,0)
(5233,3376,0)
(6244,8666,0)
(4656,8701,0)
(1482,8172,0)
(5294,3674,0)
(822,1502,0)
(5220,7945,0)
(7203,6460,0)
(4472,598,0)
(6036,8975,0)
(7270,6350,0)
(2298,4928,0)
(161,4768,0)
(3173,4150,0)
(4403,3179,0)
(6302,7893,0)
(2614,314,0)
(7355,1502,0)
(7868,1902,0)
(1817,4928,0)
(4592,6229,0)
(5666,7737,0)
(2003,8843,0)
(8035,5694,0)
(6924,2002,0)
(2869,8678,0)
(5234,9089,0)
(8201,9066,0)
(214,1817,0)
(2890,731,0)
(1739,4071,0)
(5294,2367,0)
(852,6047,0)
(2542,8285,0)
(7265,8337,0)
(2257,7670,0)
(5731,406,0)
(3697,2181,0)
(7737,6213,0)
(6915,753,0)
(8310,8008,0)
(4814,2899,0)
(7693,3792,0)
(1857,3611,0)
(5913,4598,0)
(6166,5939,0)
(7697,1502,0)
(9148,6299,0)
(1157,1872,0)
(4945,514,0)
(7811,7890,0)
(2617,3669,0)
(2972,3082,0)
(2838,7079,0)
(1774,0,0)
(1291,5178,0)
(6148,6483,0)
(3371,3100,0)
(2789,3639,0)
(2275,3321,0)
(2013,4830,0)
(6377,7186,0)
(6056,3464,0)
(6295,6346,0)
(1017,5769,0)
(5676,4150,0)
(258,8194,0)
(3462,7518,0)
(1152,8545,0)
(312,5300,0)
(4310,7361,0)
(7360,4067,0)
(7911,2751,0)
(7977,4294,0)
(722,6849,0)
(93,1003,0)
(5088,2209,0)
(8247,7900,0)
(8809,8767,0)
(2424,4113,0)
(7515,4224,0)
(21,1102,0)
(9044,1295,0)
(2560,2653,0)
(1856,7695,0)
(4313,2869,0)
(7078,7453,0)
(3198,828,0)
(6454,2301,0)
(6951,6071,0)
(2999,223,0)
(4292,8954,0)
(7752,7453,0)
(2801,5266,0)
(538,1502,0)
(2118,1823,0)
(4746,1170,0)
(6612,318,0)
(1918,8590,0)
(1498,1628,0)
(2664,20,0)
(4687,189,0)
(237,5043,0)
(4750,1794,0)
(6739,7206,0)
(244,7567,0)
(1187,3303,0)
(2935,2038,0)
(1298,3085,0)
(7612,8200,0)
(7055,1502,0)
(8776,9020,0)
(4031,5247,0)
(5957,7720,0)
(952,9069,0)
(3562,2479,0)
(4030,7872,0)
(967,1766,0)
(3522,9020,0)
(3361,1951,0)
(7137,7232,0)
(5693,7150,0)
(1695,1920,0)
(5213,2571,0)
(2119,2124,0)
(4960,8149,0)
(7247,3886,0)
(2599,4339,0)
(544,9000,0)
(6187,3943,0)
(1988,4551,0)
(7621,1103,0)
(1716,3718,0)
(7076,4928,0)
(3229,3069,0)
(6139,1554,0)
(2539,1181,0)
(6203,6260,0)
(2962,7527,0)
(1390,4928,0)
(1941,5556,0)
(5743,591,0)
(2275,2937,0)
(5100,940,0)
(4048,8827,0)
(7762,6047,0)
(7446,1879,0)
(6992,5311,0)
(7533,2338,0)
(4164,4928,0)
(5067,4676,0)
(549,1064,0)
(4345,2107,0)
(2157,5824,0)
(6549,7207,0)
(3914,4289,0)
(3004,8843,0)
(8782,1502,0)
(1294,6810,0)
(7433,2350,0)
(4212,1502,0)
(6878,7717,0)
(7141,3292,0)
(2380,2599,0)
(441,3725,0)
(7928,6489,0)
(8897,7453,0)
(3669,4928,0)
(6075,3549,0)
(3426,1292,0)
(347,519,0)
(5142,4928,0)
(7221,9092,0)
(6409,4772,0)
(4300,1712,0)
(3446,8421,0)
(1740,7753,0)
(356,2345,0)
(6285,5897,0)
(5616,1898,0)
(8197,6008,0)
(9055,3764,0)
(8987,7390,0)
(3685,1680,0)
(4256,809,0)
(2712,3456,0)
(5752,8931,0)
(6587,8762,0)
(288,7774,0)
(8012,5039,0)
(291,5683,0)
(5456,5700,0)
(4303,4972,0)
(6330,6883,0)
(3703,4744,0)
(4829,1502,0)
(9037,8188,0)
(9129,6967,0)
(4254,683,0)
(6999,7628,0)
(3674,7460,0)
(6079,7810,0)
(2958,3594,0)
(6706,6090,0)
(4572,5115,0)
(1760,8923,0)
(3747,7534,0)
(7285,7563,0)
(7727,1250,0)
(1240,5397,0)
(2335,1958,0)
(1413,3442,0)
(423,6010,0)
(59,282,0)
(7914,7453,0)
(5471,1096,0)
(2562,7693,0)
(7991,2893,0)
(5727,5448,0)
(7209,5266,0)
(3008,3755,0)
(1428,2109,0)
(4288,6926,0)
(2271,1375,0)
(8565,2349,0)
(8973,4928,0)
(2117,4779,0)
(4313,2677,0)
(5269,5169,0)
(3399,2757,0)
(8717,1295,0)
(614,5558,0)
(5294,6247,0)
(2133,1654,0)
(1363,4529,0)
(2118,1103,0)
(4405,9100,0)
(6285,1502,0)
(9105,2758,0)
(8989,5102,0)
(5154,1302,0)
(5720,55,0)
(464,2834,0)
(8290,8005,0)
(176,4928,0)
(8310,8998,0)
(4313,504,0)
(2698,6546,0)
(7387,922,0)
(8877,6818,0)
(7026,1044,0)
(4206,2417,0)
(5869,7994,0)
(7605,5701,0)
(6298,5948,0)
(4851,3135,0)
(2869,6465,0)
(929,3326,0)
(1147,8972,0)
(852,4187,0)
(4620,1838,0)
(2015,8334,0)
(1398,4286,0)
(2764,4788,0)
(6215,7247,0)
(3462,5398,0)
(2956,3470,0)
(8691,1502,0)
(2705,941,0)
(1416,1120,0)
(28,413,0)
(2815,1495,0)
(3833,8691,0)
(4459,5218,0)
(8028,3997,0)
(2568,5909,0)
(1994,755,0)
(2398,1633,0)
(3299,2265,0)
(712,7100,0)
(2297,5613,0)
(1085,1254,0)
(2679,7945,0)
(186,9006,0)
(5294,136,0)
(2841,2128,0)
(1145,3854,0)
(8182,1778,0)
(2271,3995,0)
(2319,1950,0)
(460,1810,0)
(1751,2965,0)
(7563,1502,0)
(771,887,0)
(1222,383,0)
(8850,4928,0)
(4205,304,0)
(3924,5461,0)
(7527,250,0)
(6260,8330,0)
(2656,2223,0)
(7630,5902,0)
(7526,5293,0)
(1365,4179,0)
(4437,1489,0)
(729,413,0)
(6100,220,0)
(728,7453,0)
(9119,9096,0)
(6682,4036,0)
(6397,1855,0)
(5468,5623,0)
(8401,7366,0)
(8741,6773,0)
(3880,1502,0)
(1835,8105,0)
(1292,1722,0)
(1329,6783,0)
(7222,7801,0)
(3089,7004,0)
(7765,7659,0)
(7322,4475,0)
(845,7453,0)
(1212,2015,0)
(1587,2967,0)
(1270,4892,0)
(3674,1850,0)
(3513,7814,0)
(4811,5665,0)
(5826,4181,0)
(5244,3179,0)
(215,4190,0)
(8634,3869,0)
(7546,246,0)
(5691,2637,0)
(1945,4928,0)
(173,2774,0)
(1270,8545,0)
(930,1502,0)
(3755,3008,0)
(6304,5244,0)
(7547,5867,0)
(4986,7481,0)
(5147,6450,0)
(5411,1502,0)
(3365,1502,0)
(8509,2571,0)
(2466,1964,0)
(8312,4384,0)
(3654,5829,0)
(7476,1221,0)
(4861,7308,0)
(1111,1502,0)
(1667,282,0)
(3952,685,0)
(6736,804,0)
(1162,6758,0)
(1571,9116,0)
(6872,4919,0)
(7144,4384,0)
(6529,2166,0)
(4712,3028,0)
(3106,1800,0)
(6225,7457,0)
(7991,4551,0)
(3756,2839,0)
(2241,9123,0)
(4472,6465,0)
(4872,7265,0)
(7485,2101,0)
(746,7117,0)
(1590,3420,0)
(7979,7790,0)
(8333,9150,0)
(5812,2587,0)
(3011,2228,0)
(7374,3051,0)
(1642,8227,0)
(2020,3647,0)
(7946,1232,0)
(1528,5531,0)
(7662,6724,0)
(1506,6693,0)
(4502,6385,0)
(1768,4722,0)
(9085,4928,0)
(1111,5145,0)
(3968,3727,0)
(2763,3286,0)
(6762,4280,0)
(1071,2889,0)
(1289,1502,0)
(2686,3658,0)
(6531,8843,0)
(7342,4539,0)
(6415,6852,0)
(6477,8843,0)
(5019,5655,0)
(7605,1502,0)
(4368,6836,0)
(2119,2294,0)
(3812,7014,0)
(2587,948,0)
(7405,6931,0)
(7172,1502,0)
(4041,7101,0)
(5448,1502,0)
(3963,826,0)
(1578,7895,0)
(7729,2133,0)
(7295,6127,0)
(3985,3612,0)
(1617,644,0)
(8958,7753,0)
(6811,4995,0)
(6835,7373,0)
(7997,3636,0)
(700,4285,0)
(4471,478,0)
(5529,543,0)
(291,8452,0)
(8855,8149,0)
(3879,2839,0)
(4313,712,0)
(5988,4503,0)
(8282,4252,0)
(7936,6775,0)
(4231,4640,0)
(2050,1048,0)
(7735,7453,0)
(395,1232,0)
(5233,4052,0)
(4278,5523,0)
(2971,5098,0)
(6125,8843,0)
(3527,8545,0)
(4855,7453,0)
(6778,9041,0)
(3226,750,0)
(9037,7033,0)
(6324,2751,0)
(4745,6165,0)
(6884,1914,0)
(6407,3829,0)
(7468,1489,0)
(6138,789,0)
(4683,7440,0)
(4968,4148,0)
(501,1778,0)
(2626,8447,0)
(2519,7337,0)
(7838,5188,0)
(1066,7659,0)
(9055,5043,0)
(496,1108,0)
(7077,8678,0)
(2991,1088,0)
(3980,8851,0)
(3304,2817,0)
(5475,771,0)
(3496,2135,0)
(2847,5293,0)
(606,5747,0)
(1499,4535,0)
(3014,4076,0)
(1251,6960,0)
(3769,2117,0)
(4270,1625,0)
(4437,707,0)
(2673,6741,0)
(5189,3632,0)
(504,7100,0)
(3435,5517,0)
(5817,4928,0)
(3788,829,0)
(7849,5944,0)
(675,6435,0)
(4492,2378,0)
(7435,1788,0)
(6767,4409,0)
(4942,6975,0)
(3792,7693,0)
(2912,1502,0)
(3892,7408,0)
(6208,7744,0)
(3120,4070,0)
(246,4781,0)
(6304,493,0)
(3647,5902,0)
(9036,216,0)
(6369,544,0)
(8088,5003,0)
(7810,4928,0)
(8268,1651,0)
(5213,3718,0)
(1912,8099,0)
(8553,6134,0)
(2321,7386,0)
(2113,1502,0)
(5236,2105,0)
(3360,7033,0)
(8841,5686,0)
(8666,6244,0)
(6818,4541,0)
(2443,1924,0)
(3425,626,0)
(1975,1650,0)
(3885,6836,0)
(209,6047,0)
(3489,4928,0)
(1764,2734,0)
(3457,4928,0)
(1988,6465,0)
(850,6702,0)
(3229,2644,0)
(4327,7738,0)
(8293,3899,0)
(6899,1505,0)
(3020,5080,0)
(5294,735,0)
(5484,4576,0)
(4706,8178,0)
(5151,1513,0)
(102,1155,0)
(5642,1557,0)
(8187,3903,0)
(2953,1502,0)
(4302,3158,0)
(7891,8989,0)
(6105,359,0)
(6465,4744,0)
(3550,1320,0)
(2806,5177,0)
(4809,4928,0)
(3017,1505,0)
(8862,95,0)
(8133,7453,0)
(1332,3136,0)
(3632,2929,0)
(4384,2233,0)
(4167,2741,0)
(8313,8334,0)
(8829,6465,0)
(8541,3929,0)
(5705,310,0)
(7757,5673,0)
(5799,4973,0)
(6087,3794,0)
(1539,4034,0)
(1414,2952,0)
(986,750,0)
(1999,1343,0)
(343,8729,0)
(712,5115,0)
(632,8937,0)
(49,1502,0)
(7819,2298,0)
(4949,5757,0)
(4404,607,0)
(4196,7281,0)
(7375,4247,0)
(6850,5154,0)
(4319,726,0)
(5342,1425,0)
(1251,243,0)
(3462,4961,0)
(2089,6529,0)
(7717,1502,0)
(5372,8922,0)
(2858,5513,0)
(4083,504,0)
(1193,3105,0)
(4529,1363,0)
(1448,4183,0)
(1063,7602,0)
(2462,7607,0)
(6791,5633,0)
(2148,6672,0)
(3007,1250,0)
(8652,8298,0)
(3213,3792,0)
(3276,4141,0)
(1425,6566,0)
(4738,1502,0)
(5992,1809,0)
(4423,441,0)
(8122,5846,0)
(1839,6951,0)
(6517,4744,0)
(3591,4892,0)
(3307,5665,0)
(7115,5902,0)
(5036,4928,0)
(4502,1160,0)
(92,8029,0)
(1270,5646,0)
(7856,4977,0)
(4437,3465,0)
(3494,3232,0)
(5458,2003,0)
(6053,5941,0)
(3794,6791,0)
(5451,862,0)
(1003,4234,0)
(4010,8313,0)
(7018,5249,0)
(7797,1708,0)
(1316,8081,0)
(4584,8171,0)
(1739,3114,0)
(6904,7656,0)
(909,6959,0)
(6316,4023,0)
(2073,573,0)
(2364,1328,0)
(7502,8975,0)
(1909,2738,0)
(6935,5110,0)
(5819,8388,0)
(9152,6910,0)
(8312,8681,0)
(5648,5769,0)
(7561,8498,0)
(3599,7681,0)
(1772,8411,0)
(7532,7159,0)
(931,8826,0)
(1860,7668,0)
(5231,373,0)
(4182,8792,0)
(1080,6432,0)
(4664,5159,0)
(6705,6047,0)
(5294,6574,0)
(912,7374,0)
(1027,5211,0)
(387,669,0)
(7966,318,0)
(381,6743,0)
(6304,742,0)
(2869,5115,0)
(5008,2002,0)
(6506,4842,0)
(1786,4322,0)
(6012,1506,0)
(3493,1502,0)
(6009,173,0)
(3182,7862,0)
(1369,5948,0)
(886,6894,0)
(5122,4744,0)
(3646,2806,0)
(1560,2136,0)
(1103,2118,0)
(2097,7229,0)
(2591,1848,0)
(3172,2839,0)
(808,1846,0)
(8777,4914,0)
(1203,3962,0)
(4587,5336,0)
(361,7476,0)
(5363,7746,0)
(8161,2308,0)
(3085,8802,0)
(7271,7453,0)
(6133,845,0)
(5159,4928,0)
(6145,6213,0)
(8627,5383,0)
(1275,9031,0)
(5797,3663,0)
(8022,4841,0)
(6795,4374,0)
(7587,8675,0)
(1960,4696,0)
(3252,7905,0)
(6304,2893,0)
(5533,3880,0)
(4224,7515,0)
(902,6027,0)
(8904,3549,0)
(4166,6306,0)
(9080,6430,0)
(712,2893,0)
(8755,1446,0)
(4357,1423,0)
(5735,4721,0)
(118,8827,0)
(1115,8520,0)
(2166,4928,0)
(5034,5509,0)
(5208,8724,0)
(2455,2952,0)
(5841,5637,0)
(7574,3570,0)
(1609,4717,0)
(48,2656,0)
(7620,8225,0)
(5939,3877,0)
(5311,8645,0)
(3314,275,0)
(4175,3989,0)
(4624,740,0)
(4400,918,0)
(2676,315,0)
(386,4336,0)
(6119,1502,0)
(8160,3582,0)
(4106,3013,0)
(657,1221,0)
(4297,8091,0)
(5066,8311,0)
(6657,3582,0)
(4845,4928,0)
(1624,7225,0)
(2751,6301,0)
(7405,6159,0)
(1985,7453,0)
(7374,4928,0)
(1319,4831,0)
(3434,350,0)
(9034,8767,0)
(813,4928,0)
(5348,1575,0)
(6267,3923,0)
(2700,1502,0)
(3829,5062,0)
(344,5625,0)
(1433,1005,0)
(5824,9155,0)
(2403,1502,0)
(8725,3190,0)
(6724,7662,0)
(6887,1651,0)
(5611,1502,0)
(2075,828,0)
(6198,2898,0)
(4589,7229,0)
(2488,8809,0)
(5261,676,0)
(8555,1034,0)
(7707,4928,0)
(1474,2942,0)
(8740,6817,0)
(8091,8179,0)
(621,6054,0)
(4494,4928,0)
(7787,6003,0)
(7496,1442,0)
(5069,820,0)
(8886,6314,0)
(7507,7725,0)
(5192,2389,0)
(5501,1755,0)
(3321,2687,0)
(4474,5416,0)
(8234,6139,0)
(1338,2492,0)
(5980,4928,0)
(2092,2530,0)
(4428,8505,0)
(8080,9118,0)
(8034,6847,0)
(5829,3654,0)
(3865,9125,0)
(8981,266,0)
(8789,3493,0)
(3470,8400,0)
(2434,7171,0)
(6063,3212,0)
(2806,6482,0)
(8978,8636,0)
(4463,7192,0)
(3221,5531,0)
(7202,4554,0)
(7438,8086,0)
(4022,334,0)
(4139,4744,0)
(7991,8037,0)
(3884,1502,0)
(4332,4928,0)
(7602,5264,0)
(751,8938,0)
(6546,4286,0)
(1132,1502,0)
(8076,9106,0)
(4402,7591,0)
(9083,6724,0)
(2391,4928,0)
(6288,91,0)
(2964,7841,0)
(7919,9049,0)
(3277,9071,0)
(8682,5714,0)
(4684,1502,0)
(5149,1484,0)
(2599,2380,0)
(2608,4754,0)
(4931,3837,0)
(1257,6792,0)
(7332,3365,0)
(3136,8107,0)
(1718,1538,0)
(3657,4928,0)
(8666,3397,0)
(2470,4036,0)
(9019,3658,0)
(4892,301,0)
(1948,7052,0)
(6074,7622,0)
(5245,6974,0)
(3188,1292,0)
(9037,2894,0)
(6673,1635,0)
(8987,9089,0)
(7000,821,0)
(7637,2498,0)
(2656,6260,0)
(809,1033,0)
(725,6232,0)
(5700,5456,0)
(1204,7506,0)
(2571,5213,0)
(4216,4790,0)
(7371,4699,0)
(4623,4961,0)
(7981,6588,0)
(6467,7453,0)
(1497,6197,0)
(1983,4214,0)
(8962,7737,0)
(1715,139,0)
(8650,8894,0)
(908,4105,0)
(6225,1267,0)
(8698,1502,0)
(3467,8841,0)
(1340,1255,0)
(334,7502,0)
(2773,1120,0)
(5294,4952,0)
(1322,5993,0)
(3928,1942,0)
(8278,3865,0)
(5990,7442,0)
(8157,6786,0)
(3302,1489,0)
(3385,5851,0)
(3090,3719,0)
(4685,829,0)
(6424,4455,0)
(4131,6208,0)
(1561,569,0)
(398,8100,0)
(3721,8800,0)
(5159,7096,0)
(304,1502,0)
(732,8331,0)
(2503,2828,0)
(1636,3695,0)
(3256,755,0)
(841,5701,0)
(5627,6199,0)
(120,2051,0)
(9026,4551,0)
(303,4888,0)
(8769,9025,0)
(712,5559,0)
(2823,7767,0)
(535,1277,0)
(6182,598,0)
(607,3114,0)
(4437,2204,0)
(1502,6191,0)
(7316,4,0)
(5832,1216,0)
(2771,3810,0)
(3588,3786,0)
(7518,7395,0)
(2957,6888,0)
(5544,4928,0)
(2171,1502,0)
(2295,1502,0)
(7257,586,0)
(7315,4682,0)
(4797,6198,0)
(3024,554,0)
(1034,814,0)
(8315,8843,0)
(234,2637,0)
(5205,2726,0)
(7633,2112,0)
(3306,6461,0)
(2364,4760,0)
(9026,7100,0)
(5975,1502,0)
(8464,2943,0)
(2001,2943,0)
(3239,4928,0)
(6823,2069,0)
(1316,451,0)
(3045,4739,0)
(1954,2206,0)
(941,7594,0)
(870,4768,0)
(3656,7862,0)
(3341,6932,0)
(8434,4013,0)
(8884,7364,0)
(6508,2221,0)
(6731,1495,0)
(7356,7887,0)
(5941,7686,0)
(5530,8436,0)
(2081,3605,0)
(909,4928,0)
(777,4176,0)
(4002,7475,0)
(5412,2289,0)
(5061,5086,0)
(914,5789,0)
(7187,6942,0)
(6503,2345,0)
(6752,5339,0)
(1116,3885,0)
(5384,5943,0)
(8378,4177,0)
(5347,8668,0)
(7524,6882,0)
(6787,2340,0)
(5631,1221,0)
(2869,3313,0)
(3463,4928,0)
(1921,4928,0)
(4888,303,0)
(5709,4928,0)
(8117,1502,0)
(6777,7453,0)
(6571,4493,0)
(831,3698,0)
(2488,7103,0)
(7602,6068,0)
(2403,8255,0)
(603,2359,0)
(53,6353,0)
(1019,5696,0)
(594,8767,0)
(712,1591,0)
(7471,5111,0)
(8864,4061,0)
(7694,6539,0)
(1209,4553,0)
(4902,5305,0)
(8908,6003,0)
(6165,806,0)
(2860,7563,0)
(2320,6988,0)
(8829,5559,0)
(7760,1809,0)
(7319,5848,0)
(1582,6351,0)
(8807,7453,0)
(6893,4493,0)
(8693,8179,0)
(892,1116,0)
(9096,6743,0)
(247,1582,0)
(3524,7453,0)
(3152,4928,0)
(8322,750,0)
(7159,1502,0)
(6429,9028,0)
(1911,9,0)
(7436,2985,0)
(6032,7854,0)
(7816,4095,0)
(5755,1502,0)
(7904,6197,0)
(3075,3564,0)
(6736,4928,0)
(4784,7004,0)
(7605,4928,0)
(3055,1289,0)
(1607,2865,0)
(666,1366,0)
(1938,1801,0)
(536,2113,0)
(4436,8799,0)
(8119,2352,0)
(834,5757,0)
(2736,1502,0)
(6953,5437,0)
(4313,3093,0)
(9120,1879,0)
(8650,4072,0)
(4407,8681,0)
(1697,7453,0)
(2388,3313,0)
(6738,3500,0)
(4992,8382,0)
(6073,95,0)
(4966,2525,0)
(7991,1591,0)
(4675,2407,0)
(6008,1502,0)
(8705,1732,0)
(4951,2898,0)
(8715,7453,0)
(5294,2641,0)
(5162,3167,0)
(1405,1861,0)
(2694,4991,0)
(6162,3652,0)
(455,6091,0)
(5246,5327,0)
(4775,8043,0)
(6494,4048,0)
(1064,1155,0)
(9100,7329,0)
(7102,3831,0)
(6648,8662,0)
(2874,9073,0)
(7746,4052,0)
(8629,3961,0)
(2726,7015,0)
(9143,2133,0)
(7858,6137,0)
(8072,6782,0)
(6705,8623,0)
(2848,5874,0)
(494,2462,0)
(409,5861,0)
(787,5635,0)
(4238,2088,0)
(4016,411,0)
(4579,4595,0)
(3742,7125,0)
(1722,1292,0)
(3180,8638,0)
(1023,7453,0)
(6493,4928,0)
(1456,3110,0)
(4280,4552,0)
(8453,4297,0)
(1193,733,0)
(1290,5258,0)
(3830,4928,0)
(1518,8466,0)
(1511,8659,0)
(749,7917,0)
(2343,2741,0)
(100,1688,0)
(3921,1489,0)
(479,1928,0)
(1422,909,0)
(1926,9145,0)
(6743,9096,0)
(7284,7337,0)
(7629,5197,0)
(6304,4551,0)
(4536,1798,0)
(669,4402,0)
(3830,1502,0)
(4306,8945,0)
(7951,1721,0)
(8977,2840,0)
(4610,2367,0)
(3579,4456,0)
(4524,8037,0)
(4846,6465,0)
(3612,3985,0)
(481,3963,0)
(6418,8843,0)
(5683,5902,0)
(5759,4928,0)
(6328,4928,0)
(8871,8843,0)
(3632,5189,0)
(8251,1502,0)
(4116,4415,0)
(1736,7934,0)
(4125,5735,0)
(9037,7148,0)
(6304,677,0)
(4914,3463,0)
(8208,3451,0)
(5494,638,0)
(6840,3857,0)
(9147,8638,0)
(4940,208,0)
(404,2253,0)
(2925,7671,0)
(9037,677,0)
(1434,3892,0)
(5775,2185,0)
(3771,2585,0)
(838,4950,0)
(6962,1240,0)
(7474,4930,0)
(6002,1512,0)
(2141,148,0)
(7016,4928,0)
(6071,6951,0)
(1988,8678,0)
(3083,3698,0)
(743,6218,0)
(6344,5964,0)
(922,3542,0)
(2211,2265,0)
(915,2212,0)
(336,4676,0)
(7542,839,0)
(7670,7571,0)
(6725,3385,0)
(151,87,0)
(596,3159,0)
(7552,3843,0)
(4222,5902,0)
(1778,8182,0)
(6746,334,0)
(8818,160,0)
(3049,3087,0)
(6094,6467,0)
(5080,6047,0)
(4973,8627,0)
(4987,2063,0)
(5792,4317,0)
(8592,1591,0)
(2142,1502,0)
(5658,5398,0)
(4729,2621,0)
(1536,3379,0)
(6202,4932,0)
(7929,6645,0)
(3793,1274,0)
(1628,3417,0)
(2870,3669,0)
(5769,1017,0)
(1545,5675,0)
(2713,157,0)
(6444,1908,0)
(1770,5327,0)
(6527,2039,0)
(3846,1389,0)
(7839,2954,0)
(8593,6209,0)
(5557,3103,0)
(3122,8333,0)
(6732,8136,0)
(4572,7100,0)
(9039,7994,0)
(498,817,0)
(4698,4920,0)
(2210,1415,0)
(3734,3250,0)
(2844,7619,0)
(5294,3303,0)
(8471,7603,0)
(8872,4705,0)
(5450,8464,0)
(7514,4996,0)
(4541,6818,0)
(1832,8518,0)
(5484,1420,0)
(2919,7453,0)
(7773,4067,0)
(3476,7694,0)
(4601,806,0)
(231,5515,0)
(8633,1502,0)
(1128,3259,0)
(5277,3645,0)
(1849,6702,0)
(8490,842,0)
(7643,1328,0)
(155,4849,0)
(3296,278,0)
(6971,400,0)
(2687,3321,0)
(514,2599,0)
(884,2831,0)
(7039,7124,0)
(8931,1502,0)
(6115,2957,0)
(7517,8339,0)
(5504,6127,0)
(3171,6249,0)
(7021,7919,0)
(2680,2009,0)
(4851,405,0)
(6748,1502,0)
(1727,5311,0)
(8595,1941,0)
(7402,205,0)
(963,7131,0)
(8486,5035,0)
(6528,6889,0)
(658,1502,0)
(8519,5902,0)
(184,1169,0)
(3165,4597,0)
(105,6402,0)
(3880,6047,0)
(2728,4928,0)
(450,4928,0)
(4070,3120,0)
(8277,6596,0)
(8017,2359,0)
(7379,3928,0)
(4601,7929,0)
(7466,1502,0)
(2028,3082,0)
(2940,8700,0)
(1175,2929,0)
(2845,6071,0)
(783,3219,0)
(3755,4928,0)
(3745,2942,0)
(6040,3410,0)
(8629,32,0)
(5671,7318,0)
(2136,5751,0)
(6055,5648,0)
(9026,6465,0)
(1228,1502,0)
(8747,2322,0)
(3153,4928,0)
(7309,6868,0)
(4431,9042,0)
(182,79,0)
(5898,8722,0)
(4333,9049,0)
(5086,6047,0)
(4374,3245,0)
(6304,5559,0)
(7726,8782,0)
(1438,220,0)
(5638,4243,0)
(1902,6334,0)
(5495,2741,0)
(7630,5043,0)
(1792,8320,0)
(673,644,0)
(4313,6182,0)
(4390,4928,0)
(3285,2473,0)
(1958,4657,0)
(7959,2050,0)
(1620,1902,0)
(4773,8666,0)
(4177,7453,0)
(496,6040,0)
(3882,2551,0)
(8829,1855,0)
(2153,5696,0)
(611,4928,0)
(4390,3915,0)
(1206,5703,0)
(1043,4928,0)
(8115,1904,0)
(4364,6366,0)
(8394,3995,0)
(3146,5964,0)
(4353,841,0)
(8256,900,0)
(8728,1502,0)
(5658,7556,0)
(8219,1222,0)
(7594,941,0)
(73,7131,0)
(8417,7763,0)
(767,6981,0)
(1779,383,0)
(4772,2898,0)
(3316,8893,0)
(4655,9008,0)
(5608,4532,0)
(7432,8081,0)
(6825,3026,0)
(6642,3098,0)
(8383,4494,0)
(2428,5646,0)
(8500,8145,0)
(3028,666,0)
(3120,2873,0)
(8247,4624,0)
(2439,3354,0)
(7595,2050,0)
(8946,6795,0)
(7963,7961,0)
(2523,5702,0)
(2206,8970,0)
(3286,4928,0)
(522,881,0)
(979,8298,0)
(171,4531,0)
(727,4928,0)
(3918,3719,0)
(3836,4072,0)
(149,176,0)
(7266,2095,0)
(4097,1991,0)
(521,1502,0)
(6050,3500,0)
(6304,4986,0)
(5927,7226,0)
(6783,3539,0)
(7611,6963,0)
(7935,4967,0)
(5656,5909,0)
(237,5902,0)
(7742,4843,0)
(8338,326,0)
(52,1392,0)
(5340,1091,0)
(921,5136,0)
(7920,8535,0)
(4472,8678,0)
(127,959,0)
(4928,1246,0)
(3357,7079,0)
(5531,1528,0)
(6883,4928,0)
(2080,5902,0)
(5527,6416,0)
(3659,7807,0)
(378,2728,0)
(1320,3550,0)
(1867,9037,0)
(5917,5574,0)
(796,7517,0)
(5106,1502,0)
(3652,75,0)
(7631,7453,0)
(1278,4928,0)
(4514,6922,0)
(4915,3848,0)
(6052,6508,0)
(205,1502,0)
(3426,4304,0)
(2749,3181,0)
(354,6431,0)
(8601,2865,0)
(5154,5862,0)
(6491,1142,0)
(5141,4928,0)
(5573,581,0)
(6191,218,0)
(3884,4972,0)
(7898,8701,0)
(7229,2551,0)
(5696,2153,0)
(7540,4284,0)
(2819,8463,0)
(3660,2124,0)
(2609,6483,0)
(2748,2295,0)
(5197,2741,0)
(4176,4177,0)
(5133,3596,0)
(62,6120,0)
(4572,2894,0)
(4679,1108,0)
(3768,2100,0)
(5294,5244,0)
(8753,3878,0)
(1446,4928,0)
(3414,8839,0)
(2686,7453,0)
(2134,2163,0)
(3217,9015,0)
(8700,4676,0)
(7556,5658,0)
(2197,6512,0)
(1525,6454,0)
(3367,4071,0)
(4223,3398,0)
(1540,3973,0)
(6197,7904,0)
(5156,1028,0)
(8149,8855,0)
(5537,9083,0)
(533,1472,0)
(2111,8370,0)
(4437,4373,0)
(3863,630,0)
(207,3337,0)
(3325,7680,0)
(2631,1169,0)
(8513,6289,0)
(4942,7453,0)
(1626,1502,0)
(2285,359,0)
(4580,3183,0)
(6728,1502,0)
(16,224,0)
(9019,3583,0)
(5624,8877,0)
(3137,6431,0)
(3033,186,0)
(1402,7366,0)
(3979,4928,0)
(8813,3416,0)
(2663,4928,0)
(3373,1304,0)
(5942,4277,0)
(1110,3512,0)
(400,4928,0)
(5211,1892,0)
(4336,4928,0)
(5909,2568,0)
(5028,2092,0)
(4165,3089,0)
(6699,4442,0)
(5830,4064,0)
(1614,5188,0)
(5215,251,0)
(6875,2498,0)
(3070,3239,0)
(4435,8471,0)
(7308,5172,0)
(4920,5860,0)
(7606,3330,0)
(7468,2894,0)
(3267,2629,0)
(7937,4928,0)
(6889,2825,0)
(320,3239,0)
(4366,6975,0)
(4730,702,0)
(2492,1338,0)
(1545,157,0)
(7922,8611,0)
(1325,6375,0)
(6420,5641,0)
(1040,943,0)
(4634,2516,0)
(8466,1518,0)
(1739,5797,0)
(8126,6241,0)
(4807,7647,0)
(4487,1636,0)
(4996,1502,0)
(4397,1554,0)
(2293,902,0)
(5460,7337,0)
(5247,4031,0)
(5781,3406,0)
(8701,7898,0)
(289,6554,0)
(8325,9123,0)
(5176,7389,0)
(7049,8193,0)
(1185,4928,0)
(6507,7237,0)
(8743,8606,0)
(2642,5928,0)
(4512,6868,0)
(4253,3492,0)
(7056,1687,0)
(1606,7621,0)
(4519,5784,0)
(6698,8875,0)
(3053,3601,0)
(8768,7734,0)
(1957,7929,0)
(6854,4811,0)
(7454,2973,0)
(9128,1502,0)
(4070,8849,0)
(9114,8099,0)
(9125,3865,0)
(61,2915,0)
(6461,3306,0)
(245,4928,0)
(4597,4565,0)
(7616,8331,0)
(1028,7468,0)
(7875,2899,0)
(7938,6199,0)
(7596,1334,0)
(5359,4928,0)
(7090,2787,0)
(1321,3433,0)
(6586,55,0)
(6772,7124,0)
(4518,5086,0)
(1358,8132,0)
(7457,6225,0)
(2161,4550,0)
(7169,1111,0)
(8020,6964,0)
(7650,662,0)
(4448,6047,0)
(4572,598,0)
(9026,1591,0)
(9018,2684,0)
(888,3216,0)
(949,1433,0)
(4640,4182,0)
(8651,4362,0)
(3905,5962,0)
(6183,4113,0)
(8241,2450,0)
(9067,3463,0)
(2792,3272,0)
(907,2598,0)
(1654,702,0)
(3899,8293,0)
(3283,1086,0)
(811,7488,0)
(1810,331,0)
(5571,8287,0)
(3302,6465,0)
(2684,2058,0)
(4392,5904,0)
(7540,2378,0)
(5838,4579,0)
(1986,6978,0)
(2510,8623,0)
(2892,7920,0)
(6427,3716,0)
(8851,1502,0)
(1974,8073,0)
(5358,7194,0)
(1110,803,0)
(4437,6853,0)
(4437,4986,0)
(951,4252,0)
(3790,7428,0)
(7586,679,0)
(1912,2060,0)
(5255,4928,0)
(3255,2912,0)
(6092,2403,0)
(3297,4572,0)
(6916,3083,0)
(5336,4928,0)
(6569,7485,0)
(744,3613,0)
(5431,2312,0)
(1042,4928,0)
(9098,3428,0)
(4198,8334,0)
(7909,4179,0)
(2811,4942,0)
(6532,5993,0)
(7346,4635,0)
(7311,5100,0)
(3953,4443,0)
(5428,5566,0)
(6148,1502,0)
(4961,8064,0)
(7994,1385,0)
(3473,5387,0)
(8426,5941,0)
(7871,7992,0)
(7676,5016,0)
(7950,1653,0)
(8770,1611,0)
(5699,5888,0)
(397,6111,0)
(7351,5341,0)
(2311,4928,0)
(2114,6060,0)
(9142,1502,0)
(5683,5784,0)
(4897,7805,0)
(7942,8136,0)
(7279,4787,0)
(1890,730,0)
(4912,9114,0)
(4160,8058,0)
(7185,3753,0)
(6252,2373,0)
(4202,6058,0)
(3019,1502,0)
(7707,5712,0)
(654,8767,0)
(2531,4037,0)
(7397,6378,0)
(8358,309,0)
(332,7425,0)
(8498,4176,0)
(4201,3305,0)
(5508,7453,0)
(1126,66,0)
(6094,1502,0)
(1004,5398,0)
(5551,1449,0)
(838,318,0)
(920,2808,0)
(2624,3681,0)
(8885,7052,0)
(1557,4784,0)
(431,1502,0)
(3998,503,0)
(9132,8335,0)
(3754,7565,0)
(5974,8975,0)
(4142,1717,0)
(1797,4106,0)
(8519,5043,0)
(4291,7429,0)
(6713,1502,0)
(1859,3811,0)
(2278,3252,0)
(7049,1502,0)
(4262,7453,0)
(4489,8340,0)
(3766,8402,0)
(4164,6718,0)
(235,3757,0)
(3984,635,0)
(6939,7675,0)
(3859,5531,0)
(1152,4892,0)
(1149,1460,0)
(6304,7092,0)
(6047,3112,0)
(7630,9041,0)
(5077,1515,0)
(9037,9075,0)
(5668,1502,0)
(2473,770,0)
(9090,4928,0)
(3456,2712,0)
(6464,6673,0)
(1047,7732,0)
(4522,8299,0)
(4714,6692,0)
(7396,5802,0)
(1683,5511,0)
(6952,1278,0)
(143,5097,0)
(5456,972,0)
(5760,1154,0)
(7174,8471,0)
(8829,7100,0)
(6920,211,0)
(7201,9062,0)
(6566,1425,0)
(7351,6942,0)
(3992,2269,0)
(6497,4928,0)
(2948,8223,0)
(506,8428,0)
(2338,2898,0)
(7235,3669,0)
(4921,3098,0)
(485,7154,0)
(6414,3836,0)
(6653,3213,0)
(6748,463,0)
(499,6937,0)
(3913,3790,0)
(7984,3905,0)
(2593,3302,0)
(45,3233,0)
(8041,451,0)
(3672,2202,0)
(7015,2726,0)
(7191,7801,0)
(2587,3251,0)
(3088,3540,0)
(2701,5732,0)
(4347,1502,0)
(4225,828,0)
(4601,1596,0)
(1183,7250,0)
(4516,4081,0)
(7119,3581,0)
(3365,5526,0)
(4699,5043,0)
(9055,5902,0)
(3345,8107,0)
(7107,3423,0)
(7724,1950,0)
(5538,5897,0)
(5118,1502,0)
(4313,7046,0)
(2303,4833,0)
(6224,8358,0)
(2008,1237,0)
(6535,266,0)
(5625,344,0)
(2058,2684,0)
(2258,5835,0)
(186,3033,0)
(6258,5922,0)
(8339,4993,0)
(7612,8083,0)
(3665,7945,0)
(1077,7677,0)
(5311,2644,0)
(5286,6785,0)
(4718,862,0)
(1363,3830,0)
(4851,5279,0)
(6819,2548,0)
(5900,5997,0)
(6625,1738,0)
(6090,6706,0)
(613,32,0)
(4842,6506,0)
(8659,4069,0)
(7837,7453,0)
(5425,1397,0)
(5190,5255,0)
(4826,8596,0)
(2009,5889,0)
(508,6070,0)
(1297,891,0)
(5615,5980,0)
(4871,5902,0)
(183,8791,0)
(8884,5666,0)
(5383,9155,0)
(4793,2641,0)
(1345,3805,0)
(1551,3961,0)
(2459,3185,0)
(4173,8192,0)
(8105,675,0)
(2363,3129,0)
(6354,5247,0)
(5295,4841,0)
(2426,1359,0)
(9049,4333,0)
(7884,9022,0)
(2736,1548,0)
(7910,1515,0)
(121,5002,0)
(8177,7732,0)
(8116,8843,0)
(2136,4928,0)
(2766,8779,0)
(1299,5266,0)
(3903,7475,0)
(953,213,0)
(344,1937,0)
(4543,5397,0)
(1248,703,0)
(6718,7004,0)
(3726,2914,0)
(33,1492,0)
(1875,595,0)
(1972,5109,0)
(124,2636,0)
(2981,4115,0)
(2899,7875,0)
(1968,198,0)
(9012,5796,0)
(7994,7453,0)
(9037,6988,0)
(5534,6737,0)
(6665,8762,0)
(2820,2776,0)
(5320,8117,0)
(3380,2464,0)
(5094,2164,0)
(4595,4579,0)
(7737,5666,0)
(3288,1502,0)
(8858,8668,0)
(4490,4928,0)
(3216,5849,0)
(1462,2131,0)
(5016,8119,0)
(2247,2460,0)
(94,887,0)
(543,8922,0)
(7229,3583,0)
(6400,2283,0)
(4509,1425,0)
(1479,7429,0)
(1042,1608,0)
(3653,6105,0)
(7330,6314,0)
(5227,6720,0)
(8136,6732,0)
(8136,4928,0)
(1530,7063,0)
(3638,7453,0)
(2605,7389,0)
(1864,7421,0)
(2988,4890,0)
(2341,4078,0)
(1026,8853,0)
(7965,6899,0)
(5903,1624,0)
(3290,1482,0)
(6104,8394,0)
(6488,3981,0)
(4952,1540,0)
(4352,4928,0)
(2168,742,0)
(4891,3327,0)
(5454,5043,0)
(2551,7229,0)
(5370,5134,0)
(4687,9,0)
(491,6252,0)
(5565,982,0)
(6546,2698,0)
(1579,6505,0)
(8692,8612,0)
(2659,2875,0)
(2066,538,0)
(8832,845,0)
(7288,2898,0)
(6212,4573,0)
(939,1810,0)
(5721,1608,0)
(8411,1772,0)
(63,3462,0)
(5407,8518,0)
(1817,1502,0)
(5029,3354,0)
(3462,3626,0)
(504,5115,0)
(7014,2898,0)
(2073,1449,0)
(1279,4793,0)
(8081,7598,0)
(1726,791,0)
(8520,4928,0)
(583,7383,0)
(2575,1679,0)
(2208,6430,0)
(7377,6047,0)
(5566,1438,0)
(69,6830,0)
(6198,8849,0)
(4689,6034,0)
(4056,6224,0)
(5948,6298,0)
(1930,5411,0)
(3923,9074,0)
(5675,1691,0)
(8368,7453,0)
(4151,5826,0)
(8829,908,0)
(6509,4688,0)
(1712,887,0)
(2055,4928,0)
(6527,3961,0)
(5294,8578,0)
(7962,7156,0)
(562,8843,0)
(9060,141,0)
(3574,3857,0)
(5294,2978,0)
(8422,1034,0)
(304,3583,0)
(3326,929,0)
(2852,8189,0)
(8266,6849,0)
(4507,2985,0)
(5191,4652,0)
(8329,6431,0)
(6995,3251,0)
(8584,4928,0)
(6247,2898,0)
(7814,1502,0)
(2537,2605,0)
(7435,4928,0)
(6226,582,0)
(5863,7708,0)
(1067,2343,0)
(9037,908,0)
(1079,4928,0)
(5697,8843,0)
(1116,2954,0)
(7672,2676,0)
(814,2381,0)
(3154,4846,0)
(7220,1471,0)
(6076,7707,0)
(6304,7250,0)
(388,8159,0)
(2132,956,0)
(4257,3412,0)
(7391,8043,0)
(5942,7453,0)
(2973,806,0)
(6279,3995,0)
(6792,585,0)
(3063,4793,0)
(5078,3110,0)
(1260,6082,0)
(989,236,0)
(597,1502,0)
(157,1433,0)
(141,4928,0)
(9050,240,0)
(6425,6566,0)
(1354,7333,0)
(1681,1879,0)
(6434,8725,0)
(9037,4551,0)
(4871,3638,0)
(3462,826,0)
(522,4598,0)
(3909,2378,0)
(279,3239,0)
(1479,4928,0)
(144,91,0)
(2085,9018,0)
(5379,5016,0)
(7701,7565,0)
(8561,4081,0)
(1895,1446,0)
(7318,8020,0)
(122,8009,0)
(6056,2705,0)
(2799,2069,0)
(6902,2969,0)
(7566,4298,0)
(2147,7703,0)
(95,5047,0)
(3811,1859,0)
(5259,4928,0)
(4809,6047,0)
(5708,5544,0)
(2555,4725,0)
(8195,2209,0)
(1079,1502,0)
(2473,1502,0)
(3206,5122,0)
(4917,5010,0)
(2673,1502,0)
(9078,5635,0)
(3356,110,0)
(7917,4610,0)
(5421,828,0)
(3669,7235,0)
(7593,4928,0)
(7042,4873,0)
(7854,1302,0)
(8092,8260,0)
(8178,8385,0)
(4313,1793,0)
(3475,9019,0)
(6756,995,0)
(7268,7387,0)
(432,8297,0)
(1074,5136,0)
(1138,2779,0)
(183,7125,0)
(391,5759,0)
(6606,65,0)
(6577,8843,0)
(983,1627,0)
(1827,49,0)
(7768,6697,0)
(6321,2471,0)
(1598,278,0)
(7039,3236,0)
(3286,5268,0)
(98,3341,0)
(5548,788,0)
(1213,181,0)
(2448,8420,0)
(4429,303,0)
(972,5456,0)
(2069,6249,0)
(2458,8739,0)
(3291,68,0)
(1341,4699,0)
(3732,7785,0)
(7905,3252,0)
(4890,3383,0)
(4139,573,0)
(4864,8843,0)
(6967,4181,0)
(8566,4076,0)
(2358,7179,0)
(78,3823,0)
(975,2021,0)
(6941,2468,0)
(7309,8197,0)
(8643,3511,0)
(7176,8724,0)
(1216,8392,0)
(4148,7653,0)
(7972,1017,0)
(2846,5343,0)
(1823,4928,0)
(5234,2425,0)
(991,4193,0)
(7521,7468,0)
(7985,5839,0)
(2249,350,0)
(7767,2823,0)
(2554,4373,0)
(5286,5594,0)
(4265,4023,0)
(4440,1028,0)
(4219,4171,0)
(3163,2441,0)
(6101,2786,0)
(1030,9007,0)
(5098,7348,0)
(3955,4200,0)
(217,2324,0)
(3730,6047,0)
(5774,2666,0)
(803,1110,0)
(7999,4928,0)
(8480,4928,0)
(6769,2214,0)
(4018,1008,0)
(7338,3881,0)
(7407,492,0)
(5887,3892,0)
(7928,5043,0)
(620,2599,0)
(6438,9115,0)
(7479,8385,0)
(3250,258,0)
(7033,6179,0)
(6786,7442,0)
(609,4178,0)
(1438,5902,0)
(3129,2702,0)
(5987,5610,0)
(8882,1687,0)
(2316,4624,0)
(1346,7235,0)
(3934,8480,0)
(3526,8271,0)
(1814,7625,0)
(4803,3843,0)
(1376,7100,0)
(1310,8227,0)
(7613,4961,0)
(9128,8631,0)
(1988,7148,0)
(6697,3305,0)
(6987,997,0)
(7903,6002,0)
(1255,2898,0)
(6113,1205,0)
(5352,2725,0)
(3953,4928,0)
(8472,4015,0)
(6002,2533,0)
(1495,2898,0)
(8556,4296,0)
(5330,1535,0)
(2731,2663,0)
(5542,5954,0)
(8593,4024,0)
(8894,326,0)
(4392,2491,0)
(1244,2105,0)
(3051,7374,0)
(7348,4928,0)
(8500,5885,0)
(1419,4928,0)
(1687,1502,0)
(8217,7477,0)
(1916,4523,0)
(4233,7971,0)
(3016,8767,0)
(7810,1838,0)
(4078,4734,0)
(3736,1722,0)
(7846,2017,0)
(8852,2533,0)
(1197,1502,0)
(6837,4426,0)
(3819,1502,0)
(8647,521,0)
(7355,7597,0)
(7775,4433,0)
(2992,4602,0)
(3860,2755,0)
(3597,7098,0)
(3823,1483,0)
(748,5241,0)
(2340,6787,0)
(8571,6777,0)
(1915,5266,0)
(5886,1394,0)
(6014,7367,0)
(1737,5090,0)
(3572,5957,0)
(8514,7910,0)
(1880,3251,0)
(6028,3097,0)
(52,1518,0)
(472,2937,0)
(1208,2808,0)
(6659,3877,0)
(4204,5608,0)
(1454,6996,0)
(7226,6344,0)
(2853,3135,0)
(141,5996,0)
(7976,336,0)
(8326,2415,0)
(1075,4928,0)
(6054,621,0)
(3709,8915,0)
(838,8225,0)
(9080,2774,0)
(6328,1659,0)
(1271,4169,0)
(382,4181,0)
(4076,8566,0)
(8421,4928,0)
(6975,6493,0)
(7985,7668,0)
(565,2974,0)
(8390,2253,0)
(3232,8843,0)
(2545,499,0)
(4472,7100,0)
(7853,2450,0)
(1303,4928,0)
(8242,5941,0)
(9032,4854,0)
(8892,1464,0)
(3645,7326,0)
(3963,5398,0)
(5874,6213,0)
(7164,8632,0)
(3167,2001,0)
(3370,1502,0)
(5563,4245,0)
(2330,6580,0)
(2184,5830,0)
(7067,8283,0)
(8469,1925,0)
(7863,4561,0)
(6763,1348,0)
(2178,1502,0)
(3407,5609,0)
(7776,3075,0)
(1750,7348,0)
(4699,5902,0)
(361,4928,0)
(3817,7768,0)
(3963,7518,0)
(3302,2894,0)
(4237,7728,0)
(6620,1502,0)
(4869,509,0)
(3329,2445,0)
(7117,9106,0)
(8888,2305,0)
(4452,4928,0)
(6149,4247,0)
(4584,2187,0)
(1043,1502,0)
(6211,8944,0)
(1866,8590,0)
(2543,7462,0)
(6051,6388,0)
(6447,4602,0)
(2982,3611,0)
(7087,2782,0)
(3695,1636,0)
(8665,4022,0)
(4364,2704,0)
(4437,1591,0)
(1929,586,0)
(7386,7965,0)
(6249,2069,0)
(9024,7981,0)
(5996,141,0)
(7143,1502,0)
(1152,2507,0)
(4313,3411,0)
(7045,5637,0)
(9150,8333,0)
(3568,2054,0)
(5467,4232,0)
(5294,1228,0)
(6632,7946,0)
(8306,1633,0)
(3898,4187,0)
(3963,7526,0)
(5310,4289,0)
(2145,17,0)
(3082,3502,0)
(3729,5234,0)
(1403,6066,0)
(6056,3232,0)
(5673,7892,0)
(6836,3885,0)
(7723,5673,0)
(1974,1515,0)
(3246,8182,0)
(8015,998,0)
(7651,4928,0)
(6994,6500,0)
(4437,4985,0)
(2407,7379,0)
(2166,1502,0)
(3723,8203,0)
(2357,5641,0)
(2869,2113,0)
(5273,7780,0)
(2196,801,0)
(696,5783,0)
(3075,3378,0)
(6677,1528,0)
(2600,4491,0)
(733,1193,0)
(6288,5222,0)
(3727,8515,0)
(8922,5969,0)
(615,2308,0)
(9091,6952,0)
(3721,1502,0)
(7955,1502,0)
(956,5039,0)
(3046,7012,0)
(2998,371,0)
(799,1502,0)
(1140,8843,0)
(2137,489,0)
(1768,7211,0)
(4576,5484,0)
(828,5421,0)
(3607,7132,0)
(5281,2963,0)
(9133,7928,0)
(2976,6198,0)
(4067,7035,0)
(4581,2295,0)
(3684,8083,0)
(5750,9028,0)
(1651,726,0)
(5129,5700,0)
(3598,5310,0)
(4258,8343,0)
(2751,6324,0)
(2334,2128,0)
(5456,7249,0)
(5641,4928,0)
(6565,822,0)
(1549,5944,0)
(9040,8739,0)
(8478,3581,0)
(5646,9118,0)
(947,242,0)
(6824,5544,0)
(1389,4928,0)
(6537,182,0)
(2479,4497,0)
(4651,2784,0)
(5454,5902,0)
(9127,4678,0)
(6504,1518,0)
(3514,1753,0)
(4496,5037,0)
(1311,7021,0)
(2635,3836,0)
(6611,7256,0)
(3311,7946,0)
(4139,7481,0)
(389,3232,0)
(5392,4071,0)
(8739,5200,0)
(4809,7122,0)
(1443,1688,0)
(7265,1502,0)
(7188,9155,0)
(727,1502,0)
(677,8180,0)
(4948,286,0)
(2202,3672,0)
(2567,7192,0)
(7444,5170,0)
(2164,7148,0)
(2922,8691,0)
(2228,1502,0)
(4695,1502,0)
(7810,1502,0)
(7367,1502,0)
(1642,1487,0)
(3591,2507,0)
(2127,9125,0)
(5870,1738,0)
(4372,1502,0)
(1119,6082,0)
(8890,4928,0)
(6154,2741,0)
(8729,3499,0)
(2116,3623,0)
(2289,245,0)
(4777,6776,0)
(712,8678,0)
(357,90,0)
(7439,3486,0)
(6202,3259,0)
(5294,7092,0)
(2915,4676,0)
(5818,8411,0)
(5616,8370,0)
(6499,1152,0)
(1631,6887,0)
(2894,806,0)
(1572,807,0)
(1784,8863,0)
(2177,8310,0)
(3187,4765,0)
(2084,4442,0)
(5995,1502,0)
(2842,6205,0)
(6285,4928,0)
(6422,6998,0)
(651,3346,0)
(2765,8541,0)
(8672,2851,0)
(2100,4744,0)
(8213,5524,0)
(4052,5233,0)
(5937,5142,0)
(1256,7659,0)
(7960,2893,0)
(2449,3319,0)
(6561,3676,0)
(5258,5971,0)
(5834,418,0)
(4695,2349,0)
(7046,4551,0)
(6575,4826,0)
(7602,8917,0)
(5223,6416,0)
(5112,8336,0)
(5075,1063,0)
(261,3512,0)
(7247,3352,0)
(8810,5943,0)
(1518,52,0)
(2704,3094,0)
(3624,2172,0)
(3782,7453,0)
(6844,3577,0)
(7097,4191,0)
(5996,4655,0)
(7670,5043,0)
(6198,1201,0)
(8794,5460,0)
(805,1701,0)
(6387,9011,0)
(315,2676,0)
(5818,6179,0)
(5473,1598,0)
(7893,6302,0)
(242,4928,0)
(4688,4517,0)
(9033,4928,0)
(9107,8064,0)
(7559,2893,0)
(309,5270,0)
(3638,4871,0)
(2220,8918,0)
(3940,9091,0)
(5771,4157,0)
(3342,6047,0)
(2803,5902,0)
(4088,2784,0)
(7297,6889,0)
(724,2128,0)
(8532,7434,0)
(1233,9102,0)
(8032,2507,0)
(6607,1502,0)
(3617,4212,0)
(3825,2898,0)
(451,8041,0)
(6729,8058,0)
(8945,4306,0)
(3458,4078,0)
(1776,4930,0)
(3098,6642,0)
(5024,7780,0)
(769,3621,0)
(1682,826,0)
(8664,7453,0)
(2391,1502,0)
(8042,5755,0)
(2497,2665,0)
(4901,1950,0)
(5790,5964,0)
(6510,4997,0)
(7599,3500,0)
(9071,1502,0)
(793,5782,0)
(5865,9142,0)
(5333,8809,0)
(7340,1732,0)
(5294,1222,0)
(1123,6900,0)
(7063,4807,0)
(6806,8217,0)
(5154,6850,0)
(8467,4545,0)
(6495,7666,0)
(5598,3190,0)
(8151,2791,0)
(5786,8140,0)
(1380,1502,0)
(8310,404,0)
(4818,5701,0)
(6783,1329,0)
(7046,1591,0)
(8613,8966,0)
(2767,5902,0)
(2901,3338,0)
(5733,4928,0)
(1943,6999,0)
(6304,932,0)
(6740,1328,0)
(8753,5301,0)
(5910,1498,0)
(8632,2141,0)
(1432,540,0)
(8339,7517,0)
(7093,1502,0)
(8551,3491,0)
(8933,4076,0)
(667,9036,0)
(4033,882,0)
(1782,7946,0)
(2029,9083,0)
(8270,891,0)
(4896,8128,0)
(7862,3656,0)
(3720,2100,0)
(4266,830,0)
(3669,1502,0)
(8956,3783,0)
(842,2767,0)
(3554,6482,0)
(2062,6758,0)
(8248,8843,0)
(24,2589,0)
(7159,4928,0)
(6912,1502,0)
(5222,6288,0)
(8759,3094,0)
(4169,1271,0)
(2889,1472,0)
(7907,7512,0)
(5587,7321,0)
(7677,1077,0)
(8510,5545,0)
(3815,66,0)
(2576,1510,0)
(1108,4679,0)
(156,4105,0)
(1394,5886,0)
(5889,5802,0)
(8580,8262,0)
(1360,3077,0)
(5036,1502,0)
(4846,5559,0)
(5618,5030,0)
(5167,7589,0)
(5135,2883,0)
(6119,4928,0)
(5087,842,0)
(3330,1502,0)
(569,1502,0)
(7029,8039,0)
(8220,1925,0)
(8012,3343,0)
(3609,5813,0)
(1098,2736,0)
(8238,4014,0)
(4691,3826,0)
(9102,4928,0)
(1384,2024,0)
(6457,6134,0)
(2880,888,0)
(4991,5569,0)
(528,3457,0)
(31,5869,0)
(2411,4638,0)
(2105,1244,0)
(2228,4928,0)
(3216,888,0)
(4535,136,0)
(4297,3397,0)
(7059,8145,0)
(2772,3199,0)
(1250,2674,0)
(6268,2364,0)
(4619,8120,0)
(400,8107,0)
(5896,6137,0)
(3039,3127,0)
(9038,4956,0)
(5399,4629,0)
(7259,7286,0)
(3120,8288,0)
(2128,4928,0)
(7546,7098,0)
(8541,4928,0)
(4112,597,0)
(8944,2738,0)
(779,6209,0)
(578,4301,0)
(5005,122,0)
(7549,4001,0)
(455,2893,0)
(5389,5477,0)
(2722,3069,0)
(7362,4928,0)
(8395,2985,0)
(6175,1502,0)
(8926,4189,0)
(1656,5480,0)
(6728,2074,0)
(2589,3583,0)
(4996,4928,0)
(3826,3051,0)
(4032,6985,0)
(6562,7338,0)
(5625,5383,0)
(5902,5639,0)
(4433,4928,0)
(6973,9100,0)
(2933,4464,0)
(4524,8975,0)
(7964,1323,0)
(6463,8681,0)
(8710,2427,0)
(5772,5481,0)
(7991,7092,0)
(6656,8298,0)
(7846,7317,0)
(9037,1855,0)
(661,3062,0)
(369,7067,0)
(2320,7100,0)
(4071,5392,0)
(3479,7206,0)
(575,5409,0)
(2035,4928,0)
(8181,3990,0)
(5294,1235,0)
(8537,1535,0)
(7027,1892,0)
(5650,8576,0)
(5080,4928,0)
(7313,1558,0)
(8317,4402,0)
(3319,3063,0)
(5294,8188,0)
(6247,8849,0)
(7753,1096,0)
(1879,7446,0)
(6238,1502,0)
(7021,1311,0)
(6692,6558,0)
(4925,8584,0)
(2461,1028,0)
(638,1502,0)
(3211,1502,0)
(6391,4928,0)
(8403,5945,0)
(35,5411,0)
(3960,4655,0)
(4728,7557,0)
(8759,7821,0)
(8591,7115,0)
(7055,4928,0)
(7746,4783,0)
(4511,9071,0)
(852,1502,0)
(4472,4551,0)
(7112,9073,0)
(2405,2368,0)
(2087,1255,0)
(7014,4025,0)
(4370,8544,0)
(8359,3491,0)
(2396,732,0)
(8574,3222,0)
(4531,171,0)
(6273,8550,0)
(4464,3332,0)
(1122,5980,0)
(1527,178,0)
(7744,6208,0)
(8829,3674,0)
(3391,5573,0)
(50,7422,0)
(7115,6931,0)
(4762,5817,0)
(5225,6298,0)
(540,4977,0)
(6680,4374,0)
(8106,6785,0)
(6150,2898,0)
(5727,4969,0)
(3473,7067,0)
(1475,1502,0)
(449,4657,0)
(3591,8545,0)
(7216,3689,0)
(2914,4851,0)
(4015,6862,0)
(2070,5758,0)
(8474,6158,0)
(2212,7043,0)
(1483,3823,0)
(7170,8843,0)
(4355,1123,0)
(2005,1505,0)
(2310,1460,0)
(3948,7750,0)
(1003,93,0)
(5701,841,0)
(1242,1953,0)
(8758,1954,0)
(1889,3230,0)
(148,2141,0)
(7731,6413,0)
(2230,4320,0)
(1927,2525,0)
(7387,4928,0)
(2651,996,0)
(5646,1270,0)
(6620,4928,0)
(7602,1063,0)
(1036,5059,0)
(851,8510,0)
(3073,3838,0)
(5078,1502,0)
(1680,6431,0)
(6290,3870,0)
(370,1502,0)
(18,668,0)
(4542,4928,0)
(4826,7453,0)
(7793,4928,0)
(6899,2210,0)
(770,2473,0)
(2834,2440,0)
(7097,3077,0)
(3288,1025,0)
(1554,6139,0)
(7472,3657,0)
(5369,3998,0)
(838,8494,0)
(2429,6222,0)
(8525,7377,0)
(5294,5115,0)
(5748,2656,0)
(3186,4163,0)
(4372,3856,0)
(2590,5636,0)
(6022,6301,0)
(8949,3433,0)
(7292,4069,0)
(5309,5097,0)
(7119,5783,0)
(8255,2403,0)
(8013,7016,0)
(5957,618,0)
(5914,6368,0)
(1158,1502,0)
(4061,8864,0)
(8991,8073,0)
(7256,6611,0)
(5382,8140,0)
(2610,8117,0)
(2294,2119,0)
(7656,4928,0)
(3592,1353,0)
(9077,119,0)
(5298,8973,0)
(8788,858,0)
(5010,2024,0)
(1094,2394,0)
(2834,464,0)
(3775,1421,0)
(8110,3211,0)
(938,4,0)
(3153,4259,0)
(2208,807,0)
(7002,585,0)
(6659,4928,0)
(9028,1961,0)
(7481,6384,0)
(9001,9055,0)
(6304,4985,0)
(9040,6894,0)
(5868,3793,0)
(6169,3941,0)
(3484,1711,0)
(6004,636,0)
(1934,2551,0)
(1155,1064,0)
(4780,972,0)
(2340,1889,0)
(6143,1626,0)
(5580,5260,0)
(4756,1727,0)
(4004,2005,0)
(3567,3906,0)
(3911,43,0)
(5617,8975,0)
(8384,8436,0)
(7377,1502,0)
(4340,658,0)
(4251,7506,0)
(3022,405,0)
(2498,2425,0)
(7815,3969,0)
(655,1534,0)
(6719,8843,0)
(5102,4036,0)
(6705,1502,0)
(2598,3131,0)
(1235,5082,0)
(6044,8912,0)
(5754,1553,0)
(2415,1756,0)
(3056,6731,0)
(884,7004,0)
(7386,1502,0)
(8912,6184,0)
(3995,2271,0)
(328,7743,0)
(3793,4928,0)
(4491,4928,0)
(8188,649,0)
(3397,6264,0)
(1002,1151,0)
(5794,9018,0)
(7799,6705,0)
(2917,4246,0)
(6617,1520,0)
(5880,8593,0)
(6672,1492,0)
(3883,5454,0)
(2996,493,0)
(8757,2898,0)
(1906,5665,0)
(3708,476,0)
(5198,1084,0)
(7998,1833,0)
(2136,6047,0)
(1951,3361,0)
(7588,3937,0)
(1559,4048,0)
(3895,1945,0)
(6551,2753,0)
(5884,2598,0)
(4241,8987,0)
(7954,7221,0)
(7575,8975,0)
(8339,9021,0)
(5730,7590,0)
(1853,2605,0)
(1871,4772,0)
(2899,4814,0)
(5764,2491,0)
(1977,1502,0)
(8500,5948,0)
(2033,7610,0)
(2055,1502,0)
(5876,598,0)
(5897,6285,0)
(3197,7453,0)
(106,1298,0)
(1144,7778,0)
(4888,636,0)
(2616,8631,0)
(1081,4928,0)
(2931,7736,0)
(2383,7974,0)
(5304,8488,0)
(5089,6959,0)
(2219,1721,0)
(4485,7478,0)
(712,598,0)
(368,8264,0)
(4372,4928,0)
(591,5743,0)
(3352,7469,0)
(1301,7453,0)
(8535,7920,0)
(5486,1061,0)
(5878,5435,0)
(8351,2253,0)
(2304,5525,0)
(7451,7904,0)
(5023,2468,0)
(7688,7478,0)
(5515,3491,0)
(5356,1502,0)
(4135,3339,0)
(6530,1502,0)
(7537,8902,0)
(5302,8670,0)
(518,5116,0)
(407,6432,0)
(8135,876,0)
(2882,2358,0)
(3069,1502,0)
(3272,8067,0)
(62,1343,0)
(1920,8843,0)
(1120,2773,0)
(3414,4928,0)
(5116,1037,0)
(2099,849,0)
(1196,1053,0)
(7113,7324,0)
(7077,2893,0)
(1634,2425,0)
(1538,1515,0)
(606,649,0)
(4264,1294,0)
(7131,73,0)
(3414,1502,0)
(956,2953,0)
(8929,1502,0)
(948,2582,0)
(6365,7771,0)
(7669,4719,0)
(1492,6672,0)
(6051,7004,0)
(3639,2789,0)
(4377,845,0)
(5152,2305,0)
(1734,1883,0)
(6988,4386,0)
(8120,4928,0)
(2826,3520,0)
(3906,1502,0)
(9014,6750,0)
(6889,7004,0)
(5935,1548,0)
(982,3535,0)
(5797,1739,0)
(3037,5733,0)
(5104,7458,0)
(3190,8725,0)
(7166,7589,0)
(5932,7000,0)
(5669,4730,0)
(3462,5030,0)
(7212,7219,0)
(1510,579,0)
(930,943,0)
(1707,435,0)
(1539,1502,0)
(4448,4928,0)
(8105,7004,0)
(2595,2604,0)
(8644,2661,0)
(6126,3137,0)
(2628,2253,0)
(1879,5222,0)
(3954,8888,0)
(380,7697,0)
(7281,4196,0)
(9144,1698,0)
(807,2208,0)
(6176,1346,0)
(7872,8224,0)
(6060,8230,0)
(1342,4074,0)
(5294,577,0)
(346,8235,0)
(3145,1928,0)
(2043,3912,0)
(962,5510,0)
(9037,5559,0)
(9090,3095,0)
(6264,8748,0)
(5319,6435,0)
(2967,1502,0)
(2983,6294,0)
(1373,7098,0)
(7100,7728,0)
(8745,7498,0)
(4246,7912,0)
(547,350,0)
(2968,6776,0)
(2464,5110,0)
(4880,3639,0)
(1742,4734,0)
(7924,9033,0)
(8323,5474,0)
(9043,1502,0)
(9145,6390,0)
(8517,1303,0)
(2136,1502,0)
(2400,5655,0)
(8463,2222,0)
(7533,4772,0)
(3594,6546,0)
(5134,5370,0)
(3586,1359,0)
(4894,591,0)
(4653,4765,0)
(1372,6888,0)
(6339,7453,0)
(7784,6732,0)
(9093,3971,0)
(5163,2111,0)
(9017,581,0)
(687,7849,0)
(9026,2893,0)
(8846,2759,0)
(6791,5124,0)
(3347,4157,0)
(8567,820,0)
(4801,6968,0)
(3401,1061,0)
(6060,2114,0)
(2492,5902,0)
(1738,5870,0)
(6944,7453,0)
(2544,2576,0)
(1329,2898,0)
(8471,7174,0)
(3535,982,0)
(2821,1645,0)
(7378,3482,0)
(7987,777,0)
(1672,4565,0)
(8879,1061,0)
(2640,4810,0)
(2830,1860,0)
(3512,1411,0)
(5320,1191,0)
(7248,8447,0)
(445,7522,0)
(7053,5259,0)
(8014,7995,0)
(2656,527,0)
(8862,251,0)
(2903,8574,0)
(3235,3720,0)
(2414,7004,0)
(1845,2899,0)
(4955,7675,0)
(2100,3720,0)
(7788,370,0)
(7403,4915,0)
(1812,8890,0)
(3101,7160,0)
(5875,6431,0)
(5403,4185,0)
(364,1502,0)
(8973,1502,0)
(6435,5319,0)
(7092,5937,0)
(147,3412,0)
(6553,7814,0)
(9027,3303,0)
(1061,5486,0)
(8533,1755,0)
(8032,7628,0)
(2692,1530,0)
(1735,7237,0)
(8631,8918,0)
(373,1408,0)
(2511,7453,0)
(7550,2171,0)
(5007,6558,0)
(1772,1463,0)
(1273,1731,0)
(8373,2943,0)
(5259,6637,0)
(1805,4159,0)
(1963,8223,0)
(1004,4961,0)
(6965,2109,0)
(4066,8713,0)
(8928,4972,0)
(2839,1502,0)
(2835,2793,0)
(6304,2204,0)
(8032,8283,0)
(4912,1502,0)
(2645,6718,0)
(6351,1582,0)
(991,8957,0)
(6964,8020,0)
(3978,2741,0)
(7403,7004,0)
(4980,855,0)
(1825,3553,0)
(5065,1515,0)
(305,1502,0)
(6805,5796,0)
(226,908,0)
(3744,9131,0)
(6249,7412,0)
(7089,1502,0)
(5453,8792,0)
(4572,5559,0)
(2594,5957,0)
(4031,5038,0)
(504,598,0)
(2998,6508,0)
(8311,7667,0)
(428,3033,0)
(5728,3017,0)
(7084,1123,0)
(6580,7394,0)
(2744,5454,0)
(7927,6818,0)
(9026,598,0)
(1852,4242,0)
(1898,5616,0)
(6193,2459,0)
(3420,1502,0)
(1767,774,0)
(7506,7974,0)
(4421,4402,0)
(883,4155,0)
(6505,6873,0)
(4213,8480,0)
(7612,797,0)
(530,2898,0)
(3167,5162,0)
(3608,3341,0)
(5937,7092,0)
(283,1619,0)
(263,5043,0)
(3040,8843,0)
(719,1502,0)
(8546,6691,0)
(5239,6036,0)
(8382,3965,0)
(5251,557,0)
(2390,2618,0)
(2850,4653,0)
(7877,2828,0)
(6003,8908,0)
(6880,6883,0)
(7312,5559,0)
(5747,1685,0)
(712,6465,0)
(334,8843,0)
(4719,8015,0)
(6065,1915,0)
(2453,5899,0)
(6367,7892,0)
(1637,1785,0)
(8291,8843,0)
(8952,1901,0)
(2592,3715,0)
(7291,4715,0)
(5075,6179,0)
(6679,7362,0)
(901,4554,0)
(4746,4754,0)
(856,3172,0)
(1456,8204,0)
(7468,8188,0)
(1171,4734,0)
(861,7659,0)
(4741,9044,0)
(1366,7841,0)
(3929,788,0)
(5757,1502,0)
(3094,8759,0)
(4636,8188,0)
(4725,5176,0)
(6353,1502,0)
(7974,7506,0)
(5294,3313,0)
(3616,4768,0)
(166,4928,0)
(3439,6075,0)
(2938,7461,0)
(6782,6051,0)
(2174,5198,0)
(4437,642,0)
(736,450,0)
(7181,8728,0)
(1377,9129,0)
(6510,4928,0)
(2358,6597,0)
(3443,5759,0)
(618,1515,0)
(5279,4851,0)
(7186,3896,0)
(6871,1502,0)
(3854,2278,0)
(3121,2401,0)
(6789,3142,0)
(6766,2852,0)
(581,9017,0)
(5614,8428,0)
(7754,427,0)
(4835,6344,0)
(6304,3652,0)
(8744,339,0)
(8924,3997,0)
(4928,7937,0)
(7789,2808,0)
(2909,7215,0)
(1034,8555,0)
(4850,5663,0)
(1954,4760,0)
(8563,9055,0)
(8456,6334,0)
(1651,3581,0)
(6645,3489,0)
(1229,8182,0)
(339,6530,0)
(6761,7166,0)
(2359,1502,0)
(3799,1121,0)
(5077,1502,0)
(3801,8851,0)
(2450,8241,0)
(4834,8262,0)
(4499,5795,0)
(2918,7453,0)
(3560,136,0)
(5157,648,0)
(8753,7838,0)
(1532,645,0)
(2395,2185,0)
(7367,4928,0)
(1655,4378,0)
(7568,1067,0)
(2001,2686,0)
(431,4576,0)
(245,2289,0)
(4311,7901,0)
(1540,4952,0)
(540,3168,0)
(1583,8192,0)
(5343,287,0)
(7133,8404,0)
(89,7029,0)
(6256,2278,0)
(3358,5426,0)
(3411,1591,0)
(1369,1930,0)
(6702,2865,0)
(4662,2195,0)
(1935,668,0)
(6383,4888,0)
(1590,4853,0)
(3722,3654,0)
(4612,2483,0)
(2109,4928,0)
(8609,2544,0)
(3002,6645,0)
(6750,4502,0)
(5388,4888,0)
(6931,7405,0)
(2869,1489,0)
(6659,1502,0)
(7007,2334,0)
(3696,3896,0)
(984,6404,0)
(2191,6978,0)
(1863,5721,0)
(8258,8629,0)
(2819,1502,0)
(440,693,0)
(4126,1043,0)
(1897,7932,0)
(2231,5991,0)
(6701,5030,0)
(8910,6658,0)
(1896,4025,0)
(6932,881,0)
(805,7729,0)
(7487,7556,0)
(4545,1502,0)
(4211,52,0)
(6613,4673,0)
(1824,2219,0)
(5010,7463,0)
(7681,3175,0)
(1974,1502,0)
(5294,2462,0)
(2537,1635,0)
(1654,2133,0)
(7630,5789,0)
(7982,98,0)
(6964,1072,0)
(2447,6620,0)
(7934,1653,0)
(3823,7061,0)
(263,2316,0)
(3302,8678,0)
(1604,2107,0)
(1686,4760,0)
(7004,8765,0)
(7348,1502,0)
(5857,2673,0)
(7353,5971,0)
(2716,1091,0)
(2565,5778,0)
(4597,7462,0)
(6186,4779,0)
(7894,1502,0)
(8414,2883,0)
(414,2712,0)
(2615,8843,0)
(7167,6733,0)
(6748,4928,0)
(7905,9137,0)
(7206,6739,0)
(621,2639,0)
(817,498,0)
(7043,6047,0)
(2030,1603,0)
(8570,7762,0)
(5365,1651,0)
(6932,4598,0)
(8128,4840,0)
(7060,7329,0)
(7924,579,0)
(6167,7288,0)
(8683,7527,0)
(6954,8655,0)
(2792,6431,0)
(6940,8361,0)
(6940,6674,0)
(6437,1924,0)
(3848,2982,0)
(8837,7277,0)
(6830,1502,0)
(1860,1464,0)
(6776,5860,0)
(2401,8518,0)
(8346,8637,0)
(7418,1008,0)
(6405,858,0)
(7572,1796,0)
(3421,8653,0)
(5623,1502,0)
(6614,4277,0)
(8363,2546,0)
(7214,8635,0)
(7946,1782,0)
(8250,1928,0)
(7080,7125,0)
(7229,3530,0)
(3048,7329,0)
(7114,3755,0)
(5923,4928,0)
(2071,8119,0)
(4843,1502,0)
(9122,2753,0)
(3344,5835,0)
(3779,7335,0)
(4682,7370,0)
(5449,4545,0)
(4732,5927,0)
(1113,8839,0)
(6341,6051,0)
(274,8800,0)
(7434,9020,0)
(3337,207,0)
(4612,171,0)
(3888,6277,0)
(241,3783,0)
(8615,6925,0)
(7994,7910,0)
(7881,2392,0)
(3987,6175,0)
(1936,7622,0)
(8896,8800,0)
(7538,7089,0)
(2056,4928,0)
(3583,4013,0)
(7627,2241,0)
(2311,6047,0)
(6633,7959,0)
(7166,1502,0)
(1566,818,0)
(7855,6398,0)
(5234,2496,0)
(563,8551,0)
(5393,5189,0)
(3078,4705,0)
(6308,5684,0)
(7196,6198,0)
(2879,5162,0)
(1361,4049,0)
(468,8159,0)
(8619,1558,0)
(2485,3521,0)
(8169,6994,0)
(1781,978,0)
(4115,6431,0)
(5447,3049,0)
(7428,3790,0)
(5222,1879,0)
(6398,2572,0)
(3247,7529,0)
(5075,46,0)
(5374,240,0)
(1780,976,0)
(437,141,0)
(6600,6527,0)
(686,243,0)
(3000,245,0)
(3312,5973,0)
(1389,1502,0)
(1534,7042,0)
(1072,4835,0)
(1441,6398,0)
(6584,3566,0)
(5945,1502,0)
(8397,6974,0)
(6284,6994,0)
(7421,7477,0)
(1012,5065,0)
(5499,123,0)
(3441,4090,0)
(5941,1262,0)
(362,1502,0)
(6945,5883,0)
(8295,7453,0)
(889,1494,0)
(3387,5923,0)
(6098,922,0)
(311,1898,0)
(222,8722,0)
(2230,8681,0)
(6672,1502,0)
(6304,5573,0)
(9037,7100,0)
(4143,228,0)
(6,7892,0)
(3935,5090,0)
(8585,2253,0)
(5294,7100,0)
(5214,6996,0)
(272,5027,0)
(8018,8548,0)
(2873,3120,0)
(4494,6009,0)
(7648,5568,0)
(1436,1956,0)
(8829,1919,0)
(5531,3221,0)
(2568,4928,0)
(788,5548,0)
(8019,2906,0)
(6798,237,0)
(4835,1072,0)
(8560,4220,0)
(2588,7207,0)
(4283,3981,0)
(1869,7561,0)
(8100,4979,0)
(7612,7892,0)
(3214,3085,0)
(5300,312,0)
(7308,8302,0)
(6209,8593,0)
(8762,4928,0)
(4473,9102,0)
(2386,3639,0)
(7086,7526,0)
(7645,4158,0)
(8286,7995,0)
(2796,1474,0)
(2874,1161,0)
(4371,9021,0)
(5325,5665,0)
(7940,7453,0)
(3963,5030,0)
(7288,6948,0)
(1513,5151,0)
(6375,6317,0)
(6000,4635,0)
(8668,8858,0)
(191,3211,0)
(4420,1348,0)
(5765,4847,0)
(3668,6517,0)
(8032,8545,0)
(5646,7681,0)
(442,8033,0)
(1435,6128,0)
(6859,1496,0)
(6305,1911,0)
(3313,1515,0)
(6057,1210,0)
(4388,9114,0)
(1243,5137,0)
(2381,1505,0)
(326,8894,0)
(4853,1590,0)
(3818,5633,0)
(6370,1271,0)
(8398,7438,0)
(1370,2697,0)
(6876,4553,0)
(4758,5886,0)
(8182,1052,0)
(342,5216,0)
(9062,4744,0)
(2652,4746,0)
(5336,1502,0)
(5107,362,0)
(4796,5142,0)
(3145,7035,0)
(6497,1502,0)
(3203,3401,0)
(2058,1365,0)
(4375,856,0)
(2139,4837,0)
(6272,9043,0)
(1033,809,0)
(4331,6202,0)
(5788,8843,0)
(7234,7033,0)
(4162,1680,0)
(3200,4374,0)
(4752,3581,0)
(2184,8180,0)
(8867,284,0)
(6142,6175,0)
(5477,5389,0)
(572,6367,0)
(1418,354,0)
(301,4892,0)
(4503,2505,0)
(3299,1502,0)
(6153,4390,0)
(7981,9024,0)
(6604,294,0)
(1777,344,0)
(6695,5950,0)
(5896,1502,0)
(564,2639,0)
(4772,7533,0)
(7698,2011,0)
(1267,6225,0)
(3395,2695,0)
(2898,8288,0)
(7740,3689,0)
(1407,7605,0)
(8866,1383,0)
(5559,3142,0)
(1133,3409,0)
(2833,7475,0)
(6706,5821,0)
(6492,5484,0)
(8891,7468,0)
(7861,5734,0)
(6792,815,0)
(6792,7239,0)
(3182,8938,0)
(218,6507,0)
(2214,8366,0)
(2322,2054,0)
(2404,7079,0)
(7771,4374,0)
(8631,9128,0)
(4795,1985,0)
(6911,2262,0)
(251,8459,0)
(3411,5559,0)
(7369,4678,0)
(140,2334,0)
(1309,7249,0)
(4268,8498,0)
(774,1632,0)
(1410,7156,0)
(1755,4928,0)
(1550,5106,0)
(8280,1502,0)
(3302,7100,0)
(680,6866,0)
(6304,7137,0)
(5389,384,0)
(1727,1515,0)
(5125,5037,0)
(610,753,0)
(8032,4892,0)
(4840,8128,0)
(8505,1717,0)
(7306,1904,0)
(5713,3420,0)
(8957,6431,0)
(2774,173,0)
(4646,468,0)
(6251,1250,0)
(6887,1631,0)
(5584,7520,0)
(8083,1675,0)
(2119,2741,0)
(257,7287,0)
(3517,8119,0)
(6561,6364,0)
(7221,5965,0)
(3621,769,0)
(878,4061,0)
(5341,1502,0)
(7652,1502,0)
(3379,1502,0)
(7960,598,0)
(2739,1914,0)
(3565,3456,0)
(3485,4942,0)
(876,7821,0)
(2121,981,0)
(6852,6655,0)
(3622,4119,0)
(8670,5302,0)
(3023,4177,0)
(4134,451,0)
(6110,5693,0)
(3557,7219,0)
(2581,7238,0)
(4131,1502,0)
(2843,4928,0)
(7998,595,0)
(4049,1502,0)
(6128,845,0)
(4360,7062,0)
(6304,6427,0)
(345,1389,0)
(1101,3390,0)
(558,38,0)
(1236,7458,0)
(5773,1846,0)
(6518,4459,0)
(7932,3695,0)
(1729,6110,0)
(2152,4928,0)
(9021,7961,0)
(5856,301,0)
(5414,3703,0)
(2814,3147,0)
(8280,3078,0)
(6427,7516,0)
(421,8590,0)
(1002,6509,0)
(1646,4928,0)
(7411,7277,0)
(4120,3884,0)
(2362,5244,0)
(6857,5867,0)
(4682,7315,0)
(5322,7971,0)
(4969,5727,0)
(6635,5411,0)
(900,8913,0)
(1289,3810,0)
(6317,3378,0)
(5141,8822,0)
(8343,4778,0)
(3317,4888,0)
(5942,1502,0)
(1237,2008,0)
(5142,5937,0)
(6281,4432,0)
(6958,5390,0)
(4885,1380,0)
(8179,4928,0)
(7172,4592,0)
(1291,6047,0)
(3193,406,0)
(6729,2126,0)
(8297,8516,0)
(2844,5043,0)
(8096,7453,0)
(7955,4928,0)
(893,3657,0)
(8309,4640,0)
(168,6932,0)
(7468,2113,0)
(758,3093,0)
(7334,5090,0)
(8597,8285,0)
(3236,7039,0)
(3755,1502,0)
(6501,998,0)
(6663,6864,0)
(6105,5902,0)
(2355,7315,0)
(513,726,0)
(1152,7821,0)
(2267,131,0)
(4942,2906,0)
(1691,5675,0)
(5743,8635,0)
(3797,166,0)
(5294,1255,0)
(5921,128,0)
(4398,7227,0)
(5500,2298,0)
(1342,1191,0)
(32,8629,0)
(630,7062,0)
(6301,2751,0)
(9037,4373,0)
(8193,3085,0)
(4888,2741,0)
(6001,4602,0)
(1796,1218,0)
(5981,7610,0)
(4794,1326,0)
(3635,3818,0)
(93,5753,0)
(5836,5651,0)
(4533,5063,0)
(455,8678,0)
(1044,6754,0)
(3819,4163,0)
(9119,1502,0)
(6127,7505,0)
(1800,4928,0)
(3917,2791,0)
(1383,8866,0)
(8081,1316,0)
(2720,7893,0)
(8483,5751,0)
(1152,492,0)
(712,2894,0)
(474,877,0)
(6365,7004,0)
(4841,4928,0)
(1942,8948,0)
(1910,7122,0)
(4251,6592,0)
(6082,1119,0)
(1577,4281,0)
(6434,3135,0)
(3856,4372,0)
(2223,978,0)
(4787,4059,0)
(8907,8288,0)
(4791,6899,0)
(4221,1502,0)
(2585,3771,0)
(1152,2322,0)
(6558,6692,0)
(4139,343,0)
(6607,4928,0)
(9019,7468,0)
(1836,4871,0)
(1520,334,0)
(4329,8726,0)
(1653,4928,0)
(1530,4928,0)
(3856,5674,0)
(2006,7348,0)
(5859,2368,0)
(21,5018,0)
(4472,7148,0)
(342,1304,0)
(823,4541,0)
(5732,4928,0)
(7189,838,0)
(3687,6543,0)
(9025,8027,0)
(1343,62,0)
(2700,4928,0)
(4459,8980,0)
(4549,1554,0)
(6836,6711,0)
(2552,1934,0)
(8774,8563,0)
(385,9052,0)
(2010,2997,0)
(8865,5761,0)
(3838,6047,0)
(7257,3101,0)
(7361,2032,0)
(3852,6423,0)
(1004,6554,0)
(4981,1930,0)
(7015,5646,0)
(5517,7819,0)
(4843,4928,0)
(4373,1260,0)
(2207,806,0)
(7945,4928,0)
(3928,7379,0)
(8498,7561,0)
(8938,3182,0)
(4829,4928,0)
(4757,5118,0)
(3302,7148,0)
(8172,7737,0)
(1421,1645,0)
(873,2503,0)
(2704,4364,0)
(608,1686,0)
(3112,59,0)
(8582,3286,0)
(5523,4919,0)
(115,3488,0)
(4221,44,0)
(2629,2420,0)
(3298,5666,0)
(3704,852,0)
(6781,4561,0)
(2727,6958,0)
(8431,8492,0)
(551,4928,0)
(7157,6561,0)
(6934,7093,0)
(2220,1108,0)
(6155,7395,0)
(6366,4364,0)
(737,6758,0)
(6003,1502,0)
(7367,6014,0)
(6453,8278,0)
(7798,7211,0)
(1365,2058,0)
(8454,7366,0)
(1220,1800,0)
(9156,5124,0)
(8578,5846,0)
(6943,8655,0)
(6868,4512,0)
(8241,925,0)
(4569,3388,0)
(8624,4857,0)
(7079,2404,0)
(5257,5568,0)
(2715,6864,0)
(2679,3973,0)
(7715,7729,0)
(8624,8094,0)
(9146,4629,0)
(8377,4013,0)
(4929,3730,0)
(5053,7453,0)
(8395,3924,0)
(1270,8283,0)
(3224,3941,0)
(9052,2357,0)
(8527,4125,0)
(3407,3317,0)
(1816,5879,0)
(504,2894,0)
(9094,8669,0)
(832,6318,0)
(8138,8036,0)
(4481,2814,0)
(598,1502,0)
(6078,1567,0)
(5956,1923,0)
(7492,8822,0)
(1589,6533,0)
(465,3342,0)
(9114,4912,0)
(212,8809,0)
(6497,6591,0)
(2407,4675,0)
(4631,3676,0)
(8784,6837,0)
(8912,8636,0)
(2494,4928,0)
(4038,3618,0)
(2548,1502,0)
(8938,1950,0)
(6355,8329,0)
(6300,7438,0)
(8957,4744,0)
(3738,5923,0)
(2598,7004,0)
(4148,7453,0)
(8230,6060,0)
(6315,1762,0)
(2380,2243,0)
(4287,6467,0)
(7780,5024,0)
(7128,2056,0)
(4376,1653,0)
(8822,5141,0)
(2259,8334,0)
(4765,200,0)
(894,4212,0)
(3350,1115,0)
(3762,6713,0)
(5038,4031,0)
(9142,1166,0)
(3617,7479,0)
(819,961,0)
(3811,8910,0)
(849,1502,0)
(157,3705,0)
(6301,2950,0)
(3792,3213,0)
(1343,3510,0)
(4437,1228,0)
(7756,8132,0)
(3640,5132,0)
(574,3681,0)
(8436,1502,0)
(726,1651,0)
(3649,8725,0)
(8190,3881,0)
(7055,383,0)
(9037,2113,0)
(6952,9091,0)
(310,1502,0)
(4027,7822,0)
(918,7000,0)
(8832,995,0)
(9042,2997,0)
(2000,1048,0)
(3785,3969,0)
(5555,1228,0)
(1925,8196,0)
(8409,3837,0)
(6235,8664,0)
(7083,5813,0)
(9072,1152,0)
(6403,6262,0)
(315,3012,0)
(6213,7737,0)
(8674,1751,0)
(2825,4374,0)
(6277,1502,0)
(3463,4914,0)
(7585,242,0)
(5229,8545,0)
(5395,1479,0)
(4643,1235,0)
(8099,1912,0)
(1760,5902,0)
(636,4888,0)
(2818,6736,0)
(5088,4928,0)
(1385,3583,0)
(5941,167,0)
(3335,7453,0)
(6698,1981,0)
(8399,3874,0)
(4332,1502,0)
(4851,9020,0)
(5804,6968,0)
(1842,1246,0)
(7625,3648,0)
(2663,3535,0)
(1821,8887,0)
(6515,4928,0)
(4635,3566,0)
(5995,4967,0)
(4125,8527,0)
(4729,3979,0)
(4696,1960,0)
(417,2459,0)
(5757,7638,0)
(5124,9156,0)
(1448,7141,0)
(1387,1502,0)
(2831,884,0)
(2153,1691,0)
(7625,8973,0)
(1666,2954,0)
(7228,8289,0)
(1931,5753,0)
(2011,7892,0)
(2417,4206,0)
(4174,5999,0)
(4125,7590,0)
(2893,6431,0)
(1261,1936,0)
(237,4246,0)
(297,1502,0)
(4472,5115,0)
(5313,7774,0)
(504,2893,0)
(3442,7004,0)
(681,2008,0)
(311,1986,0)
(6922,6987,0)
(3900,1946,0)
(5614,3413,0)
(4200,3955,0)
(1884,1502,0)
(592,4886,0)
(3852,7261,0)
(8008,8310,0)
(5808,8957,0)
(8395,8140,0)
(5926,5036,0)
(1471,1214,0)
(4717,1502,0)
(3995,8394,0)
(2007,6555,0)
(8647,3398,0)
(7179,2358,0)
(4238,8770,0)
(1688,4928,0)
(3881,7338,0)
(5610,4994,0)
(1272,7453,0)
(7807,6047,0)
(6691,936,0)
(3814,432,0)
(2561,2185,0)
(406,7736,0)
(8554,1934,0)
(7257,8563,0)
(8301,7328,0)
(3886,1502,0)
(5659,1360,0)
(4323,4944,0)
(6970,7453,0)
(6334,1902,0)
(5326,7453,0)
(3761,8843,0)
(1055,6888,0)
(8108,8208,0)
(1623,2491,0)
(6120,62,0)
(230,9119,0)
(1254,1085,0)
(6849,557,0)
(483,2709,0)
(5665,4811,0)
(6304,8843,0)
(2349,4695,0)
(250,6532,0)
(2985,7436,0)
(5024,4422,0)
(5991,2226,0)
(4663,1120,0)
(8694,4062,0)
(6713,4928,0)
(8212,836,0)
(3923,5674,0)
(4669,8678,0)
(977,6335,0)
(5294,3907,0)
(6401,7661,0)
(6839,4303,0)
(6759,8251,0)
(1968,7453,0)
(606,5127,0)
(3658,9019,0)
(6304,9075,0)
(1306,3553,0)
(8729,2630,0)
(6094,4928,0)
(5111,569,0)
(4191,1619,0)
(3594,2898,0)
(2427,5941,0)
(4912,4928,0)
(6718,2645,0)
(6536,5088,0)
(2058,7518,0)
(4395,4031,0)
(8310,3233,0)
(2063,7453,0)
(1618,7453,0)
(2313,2907,0)
(7089,4928,0)
(615,5311,0)
(8437,2074,0)
(5467,362,0)
(5420,4373,0)
(1334,1502,0)
(4147,1157,0)
(6828,5356,0)
(7707,1502,0)
(3944,5571,0)
(3719,8306,0)
(6705,4928,0)
(6843,134,0)
(2459,5043,0)
(6304,2894,0)
(355,777,0)
(1126,7501,0)
(485,7592,0)
(1286,3819,0)
(8402,7898,0)
(5451,4179,0)
(309,8358,0)
(1484,5149,0)
(1090,197,0)
(3515,998,0)
(6035,6571,0)
(7416,1126,0)
(2381,90,0)
(3851,2696,0)
(1476,1502,0)
(7005,948,0)
(2875,891,0)
(4445,6696,0)
(8510,9020,0)
(7939,8520,0)
(3338,4928,0)
(5775,1483,0)
(6912,4928,0)
(5124,6791,0)
(988,7991,0)
(514,882,0)
(1988,7100,0)
(7463,5010,0)
(3041,534,0)
(8691,1515,0)
(2198,305,0)
(4502,2860,0)
(4919,5523,0)
(7415,7056,0)
(7364,3575,0)
(4959,6730,0)
(7923,6010,0)
(7562,6431,0)
(5310,1502,0)
(2604,821,0)
(8764,6853,0)
(7050,2703,0)
(4586,6401,0)
(6877,8469,0)
(4686,830,0)
(666,3028,0)
(3132,8843,0)
(1662,3381,0)
(4356,5974,0)
(2061,8851,0)
(6640,6047,0)
(8020,7318,0)
(6815,6754,0)
(7074,8408,0)
(1895,7432,0)
(566,4550,0)
(4442,2084,0)
(8223,5456,0)
(712,4551,0)
(8356,6047,0)
(8464,4928,0)
(9042,3367,0)
(7466,925,0)
(1415,2210,0)
(9105,2602,0)
(7091,2854,0)
(9037,6465,0)
(203,8541,0)
(5479,3933,0)
(69,5166,0)
(1638,8928,0)
(3853,8510,0)
(8141,4166,0)
(6314,8886,0)
(7048,3217,0)
(4734,4078,0)
(4301,578,0)
(5492,8454,0)
(4167,683,0)
(8281,1025,0)
(3602,4650,0)
(7656,1611,0)
(4994,5610,0)
(1852,222,0)
(7341,8832,0)
(7118,6874,0)
(5730,8847,0)
(6808,8560,0)
(5396,2131,0)
(9137,8056,0)
(1762,5241,0)
(8337,5358,0)
(2925,1502,0)
(5621,7453,0)
(6316,1230,0)
(3603,6718,0)
(3327,3084,0)
(1942,3928,0)
(4437,1128,0)
(1102,334,0)
(8713,2844,0)
(5888,1230,0)
(8454,1515,0)
(2737,4928,0)
(3270,4464,0)
(3584,4190,0)
(660,1608,0)
(8660,2194,0)
(3608,881,0)
(554,5840,0)
(44,3111,0)
(1246,8585,0)
(3497,255,0)
(6277,3499,0)
(2129,257,0)
(2794,8461,0)
(4183,1502,0)
(4923,7428,0)
(2630,8729,0)
(5670,840,0)
(6966,5646,0)
(4692,852,0)
(7046,1228,0)
(509,7004,0)
(4993,8339,0)
(4434,2269,0)
(551,2043,0)
(5182,4638,0)
(891,1502,0)
(8101,3225,0)
(2863,5109,0)
(7500,1836,0)
(2364,3183,0)
(3412,5219,0)
(5498,5790,0)
(7968,3183,0)
(2018,4929,0)
(576,3626,0)
(6767,9063,0)
(626,8282,0)
(7461,8998,0)
(6783,8053,0)
(4098,7137,0)
(7119,1597,0)
(7025,1360,0)
(7860,2091,0)
(256,4270,0)
(6332,6482,0)
(2419,8698,0)
(7603,205,0)
(332,5043,0)
(2209,8195,0)
(5124,8548,0)
(3220,2697,0)
(2417,6431,0)
(38,5833,0)
(4448,1502,0)
(7738,6385,0)
(7001,2080,0)
(478,4471,0)
(8257,3184,0)
(7531,5996,0)
(7749,712,0)
(4320,4613,0)
(5963,3216,0)
(5692,2584,0)
(5949,3532,0)
(3530,6711,0)
(6410,4765,0)
(1773,6304,0)
(2678,6568,0)
(8273,5743,0)
(1041,2208,0)
(7071,8843,0)
(1439,3123,0)
(5770,2055,0)
(3555,4704,0)
(8200,7612,0)
(7720,7468,0)
(8964,738,0)
(3680,4497,0)
(6304,4373,0)
(750,2185,0)
(1248,2661,0)
(6609,3817,0)
(342,3058,0)
(3470,2814,0)
(2314,8973,0)
(7600,5294,0)
(3150,3361,0)
(150,2389,0)
(7925,390,0)
(3480,4452,0)
(7141,1448,0)
(8875,4222,0)
(1891,4378,0)
(5009,7819,0)
(2627,2478,0)
(8892,4928,0)
(9019,1502,0)
(8941,742,0)
(6353,6047,0)
(716,3537,0)
(205,7603,0)
(6232,1250,0)
(2781,4897,0)
(2544,7453,0)
(638,6960,0)
(6538,4306,0)
(2646,7439,0)
(8960,7004,0)
(2516,703,0)
(7678,6860,0)
(2864,6493,0)
(4026,7049,0)
(6533,2751,0)
(8771,669,0)
(7051,9119,0)
(712,5161,0)
(8410,6937,0)
(7282,4030,0)
(5897,5538,0)
(9013,2609,0)
(4422,5024,0)
(7035,3145,0)
(3158,2961,0)
(8222,9072,0)
(2281,3838,0)
(4267,3229,0)
(4413,522,0)
(1478,7629,0)
(9008,4655,0)
(4846,8678,0)
(6484,7910,0)
(58,2789,0)
(7154,485,0)
(959,5576,0)
(6102,1502,0)
(5358,7880,0)
(7063,1530,0)
(7077,598,0)
(8557,95,0)
(8104,8128,0)
(2745,3931,0)
(478,809,0)
(1981,2642,0)
(4161,3854,0)
(136,4535,0)
(2235,2410,0)
(9043,4928,0)
(1303,2308,0)
(4078,3458,0)
(5319,8399,0)
(5971,6775,0)
(3564,3075,0)
(6353,4270,0)
(315,8334,0)
(6304,3313,0)
(8902,2619,0)
(9119,4928,0)
(7691,5709,0)
(3026,7807,0)
(8728,3583,0)
(7321,5587,0)
(8931,4928,0)
(5902,2837,0)
(1249,311,0)
(3087,8998,0)
(7208,7872,0)
(8985,4182,0)
(7928,9133,0)
(6280,3924,0)
(3714,8843,0)
(1481,6047,0)
(7808,593,0)
(4531,3339,0)
(6590,8461,0)
(8851,4928,0)
(7469,3605,0)
(2426,8834,0)
(7887,5077,0)
(6818,4817,0)
(4467,8743,0)
(5415,8440,0)
(3802,5371,0)
(3943,2424,0)
(2697,1502,0)
(719,4928,0)
(4437,1855,0)
(224,16,0)
(6451,7308,0)
(5988,4928,0)
(3652,8614,0)
(5560,4928,0)
(6114,3657,0)
(4779,6186,0)
(8112,2004,0)
(8194,6324,0)
(1218,4928,0)
(3317,3407,0)
(4561,4928,0)
(2869,2893,0)
(6109,4074,0)
(6013,5383,0)
(7563,6047,0)
(7794,3007,0)
(1252,8461,0)
(537,6388,0)
(3489,1502,0)
(1820,208,0)
(6938,334,0)
(5294,1489,0)
(5766,3410,0)
(616,4952,0)
(1081,3508,0)
(374,1111,0)
(6318,832,0)
(3271,3288,0)
(4437,677,0)
(8185,6408,0)
(235,7813,0)
(2907,5839,0)
(5667,371,0)
(658,8484,0)
(7261,4928,0)
(1576,1890,0)
(6734,3981,0)
(7293,7943,0)
(8064,4961,0)
(3043,2934,0)
(8225,838,0)
(7093,4928,0)
(4808,5043,0)
(6299,5957,0)
(4820,1202,0)
(7397,6864,0)
(6224,4056,0)
(3128,9090,0)
(6278,4717,0)
(7659,7765,0)
(2080,1053,0)
(1534,5269,0)
(3155,5782,0)
(412,635,0)
(4919,6872,0)
(5674,3923,0)
(1706,8288,0)
(8966,5922,0)
(8492,7668,0)
(804,4709,0)
(2550,1358,0)
(7085,817,0)
(8412,412,0)
(5734,8590,0)
(8027,9025,0)
(4681,8119,0)
(3703,6431,0)
(8671,4477,0)
(4015,5230,0)
(4236,17,0)
(6331,6090,0)
(7046,6988,0)
(6392,5902,0)
(4913,7785,0)
(9031,3933,0)
(5989,3508,0)
(4623,2656,0)
(2683,5455,0)
(3052,3891,0)
(1460,4928,0)
(3081,4820,0)
(1921,1502,0)
(6014,8053,0)
(5166,69,0)
(7569,5437,0)
(8868,5371,0)
(5294,5559,0)
(5170,7444,0)
(2308,1303,0)
(6011,6491,0)
(5795,4499,0)
(4576,431,0)
(2230,8064,0)
(2194,8782,0)
(8372,877,0)
(826,8266,0)
(4975,5424,0)
(8503,7453,0)
(6008,8197,0)
(1768,1961,0)
(4696,1512,0)
(7062,630,0)
(8522,4738,0)
(2812,3658,0)
(6522,1311,0)
(862,2311,0)
(7095,5526,0)
(2433,881,0)
(4611,4407,0)
(209,4928,0)
(2167,5369,0)
(5294,4037,0)
(7888,4364,0)
(6927,3577,0)
(55,1502,0)
(1486,8929,0)
(5545,8510,0)
(8738,3110,0)
(1608,5721,0)
(4836,6367,0)
(4879,8726,0)
(3658,2812,0)
(6852,8788,0)
(1302,7854,0)
(7239,4670,0)
(71,1589,0)
(3906,4928,0)
(7565,1502,0)
(2461,721,0)
(4988,1535,0)
(8476,5737,0)
(2672,4833,0)
(3870,1502,0)
(5980,1502,0)
(4442,4928,0)
(124,375,0)
(2530,727,0)
(9008,1502,0)
(5071,4928,0)
(4155,7921,0)
(919,7977,0)
(8860,4332,0)
(6097,5448,0)
(5077,7887,0)
(5658,4961,0)
(5114,6478,0)
(7539,1823,0)
(8922,543,0)
(8545,5871,0)
(5673,8083,0)
(7704,2230,0)
(5658,87,0)
(5466,6626,0)
(7772,6238,0)
(75,2283,0)
(956,1227,0)
(5248,8700,0)
(4354,7753,0)
(6376,311,0)
(6479,1760,0)
(7607,5301,0)
(1789,4928,0)
(9026,8188,0)
(8829,7148,0)
(9037,6560,0)
(6800,7889,0)
(5512,3126,0)
(8968,8241,0)
(2205,2359,0)
(4063,6018,0)
(8289,4928,0)
(8459,2712,0)
(1438,5043,0)
(5586,7474,0)
(5559,6316,0)
(7363,567,0)
(961,5392,0)
(1475,4928,0)
(6775,5971,0)
(8829,6988,0)
(159,5929,0)
(7413,75,0)
(1411,166,0)
(5854,372,0)
(4886,1521,0)
(532,3699,0)
(8499,8329,0)
(1076,8688,0)
(4697,5141,0)
(6664,5213,0)
(3638,4805,0)
(2656,1712,0)
(4727,7922,0)
(4702,1502,0)
(776,2904,0)
(3713,4784,0)
(804,6736,0)
(6576,1026,0)
(3529,4928,0)
(510,6014,0)
(4347,4928,0)
(6241,8126,0)
(8545,7591,0)
(3252,2278,0)
(6671,6051,0)
(6511,1438,0)
(4472,7461,0)
(7290,1062,0)
(578,3997,0)
(6645,7929,0)
(6102,1037,0)
(40,4350,0)
(8604,4742,0)
(1711,6392,0)
(5040,6306,0)
(55,6366,0)
(1794,175,0)
(1660,1042,0)
(7802,4445,0)
(8399,5319,0)
(5036,6047,0)
(4500,7362,0)
(2869,5559,0)
(8124,7643,0)
(5359,6047,0)
(4769,4928,0)
(468,2471,0)
(3591,7821,0)
(3386,1701,0)
(1385,1502,0)
(7807,1502,0)
(8496,735,0)
(7227,3639,0)
(3556,1044,0)
(4294,7977,0)
(8099,9114,0)
(1537,4717,0)
(8511,7979,0)
(8353,2171,0)
(1181,8146,0)
(4859,5113,0)
(3605,7469,0)
(1558,6290,0)
(4341,679,0)
(8918,8631,0)
(6239,6733,0)
(5419,1043,0)
(2393,6597,0)
(6899,5082,0)
(321,5282,0)
(9061,4130,0)
(3096,2641,0)
(4544,7753,0)
(1925,8217,0)
(8260,4928,0)
(0,1774,0)
(8909,573,0)
(4396,246,0)
(837,7575,0)
(205,4928,0)
(3411,5115,0)
(1409,7030,0)
(2942,1474,0)
(3403,6495,0)
(3498,8923,0)
(1953,1502,0)
(1680,4744,0)
(6982,8847,0)
(2936,4258,0)
(3848,4915,0)
(8073,6810,0)
(7991,2755,0)
(3861,4719,0)
(4173,2084,0)
(6323,279,0)
(86,7741,0)
(1505,2005,0)
(4947,5646,0)
(6559,4157,0)
(4304,3426,0)
(9037,2893,0)
(3331,676,0)
(9022,7884,0)
(3506,8480,0)
(1688,100,0)
(1415,7321,0)
(6198,1840,0)
(435,1502,0)
(527,7835,0)
(3209,6515,0)
(8728,6179,0)
(5059,1651,0)
(3266,5145,0)
(4488,1921,0)
(4445,2843,0)
(6172,4765,0)
(7329,9100,0)
(375,124,0)
(2629,3267,0)
(3824,5329,0)
(1304,342,0)
(5055,6782,0)
(2320,2894,0)
(0,4778,0)
(3411,7100,0)
(2193,5115,0)
(1595,3878,0)
(8829,4551,0)
(3374,5855,0)
(8718,7202,0)
(8966,4928,0)
(9029,1491,0)
(3444,1762,0)
(8436,1515,0)
(985,313,0)
(4857,8624,0)
(6673,2898,0)
(4062,8694,0)
(438,1918,0)
(343,4139,0)
(7032,8811,0)
(2269,4434,0)
(8348,5718,0)
(858,6405,0)
(7056,4163,0)
(4130,4744,0)
(3398,8647,0)
(2753,1502,0)
(2784,237,0)
(3703,961,0)
(5212,2058,0)
(3740,56,0)
(6704,2370,0)
(3463,1502,0)
(74,3153,0)
(2715,1502,0)
(4709,804,0)
(7140,5151,0)
(1765,8805,0)
(8649,7656,0)
(8166,4298,0)
(6093,8894,0)
(7131,1502,0)
(7046,2893,0)
(1749,1924,0)
(8826,3583,0)
(3488,2063,0)
(2533,6567,0)
(7647,4807,0)
(2059,7151,0)
(2057,814,0)
(8148,7922,0)
(1083,614,0)
(4767,1289,0)
(1791,1768,0)
(1610,3462,0)
(257,2129,0)
(5883,3715,0)
(6810,8073,0)
(7073,7720,0)
(5740,7904,0)
(7919,7021,0)
(5805,7790,0)
(7763,8417,0)
(1371,5761,0)
(5376,211,0)
(8455,4532,0)
(4778,5226,0)
(689,4595,0)
(2772,1502,0)
(3809,7896,0)
(953,6377,0)
(5763,697,0)
(3127,8809,0)
(1015,8841,0)
(1331,5988,0)
(1704,3978,0)
(7411,4542,0)
(3334,3083,0)
(3019,3950,0)
(8227,1502,0)
(2960,649,0)
(2301,6454,0)
(5950,7813,0)
(9037,5244,0)
(5097,143,0)
(2436,3112,0)
(2817,3304,0)
(6974,1502,0)
(1356,176,0)
(2565,4928,0)
(1392,52,0)
(8703,7150,0)
(3101,6491,0)
(1789,1502,0)
(8191,4814,0)
(6049,1375,0)
(2492,1498,0)
(2160,7397,0)
(213,2248,0)
(7462,4597,0)
(3874,4744,0)
(2771,7369,0)
(4351,4048,0)
(1503,1599,0)
(1108,496,0)
(7069,3830,0)
(8312,4320,0)
(5258,1502,0)
(4272,4857,0)
(5294,1855,0)
(7713,3181,0)
(538,8515,0)
(7814,4928,0)
(5343,1502,0)
(3391,7999,0)
(6923,4732,0)
(8722,1210,0)
(384,5611,0)
(4603,2251,0)
(4647,2794,0)
(8893,4744,0)
(2496,5673,0)
(8355,8146,0)
(5206,7853,0)
(7239,6792,0)
(900,7826,0)
(3178,1768,0)
(6168,2487,0)
(3874,8399,0)
(669,8778,0)
(3817,7783,0)
(6131,5753,0)
(4426,6837,0)
(3412,4257,0)
(5294,1451,0)
(6084,8058,0)
(307,3416,0)
(3871,3227,0)
(3504,5774,0)
(5265,2854,0)
(1783,772,0)
(5977,2350,0)
(1806,1977,0)
(3591,7628,0)
(336,6674,0)
(2705,6056,0)
(5941,8242,0)
(7410,1690,0)
(8316,8593,0)
(3542,1367,0)
(1438,5566,0)
(4720,7920,0)
(2868,8843,0)
(8987,5829,0)
(6255,6960,0)
(4249,477,0)
(2278,5902,0)
(5988,1502,0)
(6949,3690,0)
(6077,7571,0)
(4119,4194,0)
(8627,4973,0)
(1924,7004,0)
(8387,1717,0)
(5022,5969,0)
(392,1502,0)
(2574,888,0)
(5035,8486,0)
(4682,7762,0)
(1210,8722,0)
(6552,3663,0)
(5342,2817,0)
(5117,4234,0)
(3612,8811,0)
(5186,6529,0)
(6853,1502,0)
(3105,1193,0)
(5778,2565,0)
(3839,7936,0)
(1809,5992,0)
(476,8975,0)
(5287,932,0)
(9037,1591,0)
(3001,464,0)
(2226,2028,0)
(8098,2644,0)
(9063,6767,0)
(4437,7033,0)
(1940,7750,0)
(3176,7453,0)
(5068,4560,0)
(5735,4125,0)
(3834,5286,0)
(5815,5390,0)
(2963,2994,0)
(6899,3905,0)
(5437,3543,0)
(2241,1502,0)
(6683,2305,0)
(1947,6810,0)
(4755,254,0)
(6467,6094,0)
(4222,4171,0)
(5493,1502,0)
(4832,6910,0)
(8752,3493,0)
(4946,3386,0)
(5065,1502,0)
(6344,7226,0)
(5280,7453,0)
(410,5957,0)
(3332,4928,0)
(460,1502,0)
(7859,7612,0)
(8722,3123,0)
(4399,3522,0)
(6307,4284,0)
(9141,5909,0)
(2505,4503,0)
(3630,8487,0)
(2714,5322,0)
(6006,908,0)
(7590,4125,0)
(7171,3529,0)
(8657,1366,0)
(42,1748,0)
(3591,2322,0)
(5802,5871,0)
(4882,2771,0)
(642,4220,0)
(6357,1314,0)
(4591,774,0)
(4085,2961,0)
(4939,3617,0)
(6785,5286,0)
(4313,1988,0)
(3630,1789,0)
(2100,573,0)
(759,7453,0)
(6978,8370,0)
(2035,6047,0)
(5408,4676,0)
(1254,5043,0)
(2955,9120,0)
(703,2516,0)
(4716,1703,0)
(6692,7659,0)
(551,1502,0)
(5341,7351,0)
(3379,4928,0)
(3925,4601,0)
(2762,6111,0)
(2649,8795,0)
(1258,5760,0)
(821,2604,0)
(6021,2952,0)
(3379,5700,0)
(995,8832,0)
(3205,7148,0)
(8560,6179,0)
(4054,2994,0)
(5532,5042,0)
(2061,7453,0)
(2737,2554,0)
(3243,5945,0)
(2221,7277,0)
(6489,7928,0)
(6042,6754,0)
(7959,6431,0)
(4908,4560,0)
(6702,1502,0)
(195,2951,0)
(8033,3758,0)
(3698,831,0)
(7709,2196,0)
(3411,1489,0)
(2589,7468,0)
(1744,8803,0)
(8799,826,0)
(6968,2889,0)
(7869,3367,0)
(7109,8934,0)
(5336,2460,0)
(7587,3503,0)
(5178,315,0)
(3411,4551,0)
(416,7159,0)
(2262,5902,0)
(4169,4928,0)
(1237,4541,0)
(8236,4845,0)
(2350,408,0)
(6770,1321,0)
(1460,1353,0)
(6170,5043,0)
(7642,8962,0)
(8391,9085,0)
(4612,5655,0)
(3119,5291,0)
(7818,7453,0)
(930,4928,0)
(5886,2898,0)
(4599,4490,0)
(1224,370,0)
(7991,6560,0)
(4632,6890,0)
(6386,2283,0)
(8728,46,0)
(394,1502,0)
(917,3383,0)
(653,6770,0)
(8829,3465,0)
(3179,5244,0)
(621,5513,0)
(1397,4407,0)
(8313,294,0)
(3779,2973,0)
(5409,8047,0)
(4325,6730,0)
(1474,2796,0)
(435,4928,0)
(7628,1721,0)
(5633,6791,0)
(2028,2226,0)
(4102,4434,0)
(2872,7408,0)
(3399,2791,0)
(7130,4542,0)
(264,3391,0)
(8661,3529,0)
(4559,896,0)
(3030,6817,0)
(2981,3417,0)
(5760,7004,0)
(5359,1502,0)
(6222,8074,0)
(2863,1502,0)
(317,7215,0)
(7529,4928,0)
(664,1139,0)
(2280,4928,0)
(4272,6410,0)
(4052,7746,0)
(1476,2181,0)
(5662,1119,0)
(5306,4760,0)
(1108,2307,0)
(7893,8653,0)
(209,6862,0)
(157,5636,0)
(2014,4036,0)
(6238,4928,0)
(7324,3375,0)
(3059,4565,0)
(5356,6896,0)
(2856,6483,0)
(998,6501,0)
(364,5424,0)
(8222,7337,0)
(4001,979,0)
(5103,8843,0)
(3392,1791,0)
(5507,683,0)
(2601,8520,0)
(5745,4943,0)
(5717,3862,0)
(3216,5043,0)
(3473,3923,0)
(2240,6460,0)
(7058,551,0)
(5862,5154,0)
(5355,8447,0)
(3323,611,0)
(1057,4735,0)
(1738,4928,0)
(4672,2806,0)
(278,1598,0)
(3564,8451,0)
(3095,9090,0)
(2016,8525,0)
(4606,5964,0)
(6951,7651,0)
(7852,5840,0)
(5146,1583,0)
(2019,2871,0)
(4128,7235,0)
(1548,3265,0)
(2376,5807,0)
(9051,7734,0)
(77,3230,0)
(1633,2398,0)
(7666,6495,0)
(2480,7737,0)
(5218,4459,0)
(7764,7453,0)
(5461,5694,0)
(3993,1502,0)
(8955,4699,0)
(5255,812,0)
(5896,6047,0)
(8392,4928,0)
(1995,9000,0)
(7946,3311,0)
(8519,5346,0)
(36,1444,0)
(1838,7810,0)
(601,673,0)
(2035,4820,0)
(7029,89,0)
(1018,8843,0)
(8005,6777,0)
(4944,2407,0)
(5091,6787,0)
(1828,1734,0)
(2557,3999,0)
(7475,3903,0)
(9018,5794,0)
(2399,6967,0)
(682,5743,0)
(6185,1967,0)
(1475,1513,0)
(3624,1046,0)
(4486,3405,0)
(2884,6084,0)
(1452,5383,0)
(5018,21,0)
(1037,5116,0)
(8420,7453,0)
(3217,2178,0)
(7240,1494,0)
(3544,8945,0)
(8519,2172,0)
(3529,7171,0)
(7670,5902,0)
(1823,2118,0)
(4190,7946,0)
(4923,626,0)
(2834,4269,0)
(6430,9080,0)
(2493,8776,0)
(3254,1385,0)
(1035,2011,0)
(5219,3412,0)
(5791,3062,0)
(4437,8678,0)
(7175,8833,0)
(7948,1636,0)
(3805,5282,0)
(4037,2062,0)
(5886,7389,0)
(413,7219,0)
(3267,2126,0)
(4454,4831,0)
(8605,7743,0)
(3596,3577,0)
(6348,4928,0)
(684,4829,0)
(6025,6047,0)
(6246,812,0)
(9075,8340,0)
(3735,3340,0)
(45,644,0)
(4732,4448,0)
(1295,7223,0)
(8810,6962,0)
(7593,8950,0)
(6304,1314,0)
(7991,1489,0)
(933,635,0)
(4863,460,0)
(2932,3740,0)
(3656,6907,0)
(8811,6105,0)
(1942,2574,0)
(185,8843,0)
(1321,6770,0)
(7725,1528,0)
(9011,9104,0)
(1563,8356,0)
(6218,3840,0)
(7795,1390,0)
(8540,6706,0)
(331,3860,0)
(4453,8294,0)
(5915,3794,0)
(3688,4193,0)
(5366,471,0)
(4437,8987,0)
(1353,4642,0)
(7980,1320,0)
(173,6009,0)
(6908,6791,0)
(8910,3811,0)
(6018,2852,0)
(3917,5807,0)
(7519,1937,0)
(3410,1502,0)
(5168,1766,0)
(4089,6025,0)
(3855,4928,0)
(4243,5610,0)
(7829,1199,0)
(8670,761,0)
(7649,4545,0)
(5270,5151,0)
(6479,1981,0)
(3278,2472,0)
(1270,7821,0)
(6906,1221,0)
(5222,1484,0)
(5736,5885,0)
(2509,7014,0)
(5881,54,0)
(598,5252,0)
(2044,1872,0)
(3464,7741,0)
(6287,4173,0)
(5517,4972,0)
(7465,7453,0)
(7528,7699,0)
(408,2350,0)
(2126,4341,0)
(2462,494,0)
(139,450,0)
(3678,2575,0)
(829,4685,0)
(1133,4650,0)
(5115,2193,0)
(2021,7642,0)
(2869,8063,0)
(8394,5818,0)
(8872,1277,0)
(579,1510,0)
(5175,2357,0)
(738,8964,0)
(4998,7324,0)
(7381,2113,0)
(2475,8065,0)
(204,5709,0)
(1191,1342,0)
(5383,8627,0)
(439,5833,0)
(3064,4294,0)
(6817,585,0)
(8585,1440,0)
(3891,1273,0)
(702,4730,0)
(7521,6179,0)
(2410,1761,0)
(7391,2898,0)
(3516,62,0)
(3707,7453,0)
(2080,1627,0)
(1430,5124,0)
(248,7737,0)
(2074,6728,0)
(371,1502,0)
(1970,3462,0)
(8421,1502,0)
(494,5071,0)
(8921,9052,0)
(5564,1941,0)
(1723,7043,0)
(7807,4928,0)
(3837,1502,0)
(7489,5176,0)
(1609,4061,0)
(7996,6718,0)
(7118,4765,0)
(2978,5305,0)
(4,4502,0)
(3965,8382,0)
(3452,2914,0)
(4185,4021,0)
(2942,1502,0)
(3780,788,0)
(8974,5560,0)
(4281,4653,0)
(5294,8037,0)
(3061,2316,0)
(8487,8252,0)
(4114,6580,0)
(7744,9092,0)
(8512,2635,0)
(5294,996,0)
(623,3496,0)
(8301,5964,0)
(6304,4166,0)
(7370,4682,0)
(4554,7393,0)
(2049,1925,0)
(432,4765,0)
(8593,2804,0)
(6288,6436,0)
(1980,4897,0)
(6592,4251,0)
(3107,1675,0)
(6304,7767,0)
(4229,5302,0)
(4074,7468,0)
(6262,1502,0)
(2280,1791,0)
(2120,7529,0)
(3542,922,0)
(5132,4560,0)
(8826,1502,0)
(740,1680,0)
(3416,334,0)
(7497,898,0)
(2399,5989,0)
(898,6175,0)
(8146,1181,0)
(6207,7453,0)
(5050,2585,0)
(2440,6731,0)
(6716,7598,0)
(6861,3533,0)
(4675,4018,0)
(4103,7461,0)
(626,4923,0)
(4868,6497,0)
(4284,4928,0)
(2024,1502,0)
(5506,751,0)
(2009,1502,0)
(987,2703,0)
(8804,1833,0)
(3471,8120,0)
(4316,2166,0)
(6105,5043,0)
(4497,3680,0)
(3805,2107,0)
(4808,5902,0)
(6830,69,0)
(5929,4186,0)
(4572,6465,0)
(4509,1009,0)
(1840,3539,0)
(6832,3325,0)
(7225,7453,0)
(7335,4969,0)
(6860,4615,0)
(3233,3776,0)
(971,984,0)
(200,7440,0)
(8289,2021,0)
(8838,1682,0)
(4433,4704,0)
(548,364,0)
(4416,2028,0)
(922,7387,0)
(247,2686,0)
(1285,3581,0)
(3465,6539,0)
(8724,263,0)
(8794,350,0)
(9037,3313,0)
(5113,4928,0)
(6921,3800,0)
(1879,9120,0)
(7009,2417,0)
(774,3962,0)
(3202,1390,0)
(5605,4912,0)
(923,7677,0)
(1375,4765,0)
(2687,7969,0)
(166,1411,0)
(5636,4928,0)
(1273,3891,0)
(8862,2939,0)
(4070,1201,0)
(7657,5914,0)
(1480,2149,0)
(8588,7117,0)
(8428,5614,0)
(8451,3564,0)
(839,1442,0)
(7193,7643,0)
(8853,1026,0)
(2559,3945,0)
(2966,7567,0)
(772,4928,0)
(809,478,0)
(3950,3019,0)
(1011,3247,0)
(1087,4078,0)
(4036,6682,0)
(1647,7783,0)
(7812,4878,0)
(3110,5078,0)
(1245,559,0)
(5993,3008,0)
(4510,495,0)
(4374,7771,0)
(122,5005,0)
(1291,4928,0)
(3129,7734,0)
(8791,183,0)
(4974,3390,0)
(6794,1946,0)
(877,9051,0)
(5489,5043,0)
(1791,2280,0)
(4269,2898,0)
(7548,1502,0)
(558,5856,0)
(8719,8692,0)
(5889,2009,0)
(4972,3884,0)
(3453,4200,0)
(8327,521,0)
(4195,9108,0)
(67,7675,0)
(3529,1502,0)
(30,2088,0)
(1088,5840,0)
(6304,4638,0)
(470,4738,0)
(4781,246,0)
(1210,6057,0)
(6179,5818,0)
(7766,8850,0)
(2288,9007,0)
(5835,1502,0)
(4590,3583,0)
(727,2530,0)
(2435,5106,0)
(355,5266,0)
(7615,5927,0)
(4420,3428,0)
(6568,287,0)
(4313,8829,0)
(2625,2349,0)
(2978,2557,0)
(5725,7593,0)
(5719,3329,0)
(6959,909,0)
(1659,3236,0)
(3279,1502,0)
(3891,2079,0)
(7441,2498,0)
(6557,7273,0)
(5717,2686,0)
(1829,1219,0)
(5097,1502,0)
(3029,1627,0)
(1919,7000,0)
(6057,5098,0)
(6026,7974,0)
(3793,1502,0)
(8829,1228,0)
(3388,5161,0)
(8081,7432,0)
(9037,4986,0)
(8520,1115,0)
(7345,2854,0)
(6771,8149,0)
(8486,2242,0)
(4733,7011,0)
(777,355,0)
(6351,4928,0)
(5767,3145,0)
(8948,1942,0)
(5005,3955,0)
(3382,3688,0)
(1601,6621,0)
(1118,6709,0)
(5429,525,0)
(7256,3905,0)
(8215,4709,0)
(8963,5264,0)
(456,2893,0)
(1156,3648,0)
(5646,7015,0)
(8307,6599,0)
(998,1052,0)
(8461,4928,0)
(7326,1941,0)
(2782,5862,0)
(6621,4265,0)
(7563,4928,0)
(9076,5489,0)
(9123,8325,0)
(5413,6051,0)
(4924,803,0)
(6408,1878,0)
(1630,4360,0)
(1103,7621,0)
(2769,0,0)
(8051,3218,0)
(4007,4884,0)
(7298,7686,0)
(3916,3464,0)
(8163,8892,0)
(3910,5550,0)
(266,8981,0)
(6042,6478,0)
(4095,7453,0)
(1901,4928,0)
(690,7630,0)
(3941,3978,0)
(1115,3350,0)
(504,6465,0)
(6171,8667,0)
(5672,8604,0)
(3118,9008,0)
(3775,6592,0)
(441,5964,0)
(2912,4928,0)
(5751,2136,0)
(7458,1236,0)
(7132,4909,0)
(3539,1840,0)
(2658,5878,0)
(4163,3819,0)
(6983,2611,0)
(8748,1991,0)
(7081,4286,0)
(1270,7628,0)
(2175,3539,0)
(1095,4910,0)
(8833,6108,0)
(4313,6304,0)
(2278,3854,0)
(8716,605,0)
(8016,1394,0)
(5558,493,0)
(2156,220,0)
(5972,1246,0)
(1502,8843,0)
(3009,392,0)
(2512,5448,0)
(1239,5680,0)
(3241,4187,0)
(7034,1339,0)
(8354,8848,0)
(7901,4928,0)
(7753,3058,0)
(4852,5941,0)
(6534,8197,0)
(3956,7453,0)
(6470,3399,0)
(4430,6133,0)
(7046,598,0)
(782,5567,0)
(7522,1502,0)
(1709,618,0)
(6440,4874,0)
(113,8578,0)
(4583,9152,0)
(2107,6888,0)
(3341,3608,0)
(8703,5583,0)
(1033,1502,0)
(5490,1405,0)
(6987,9131,0)
(2665,7337,0)
(5341,4928,0)
(909,1502,0)
(1883,1734,0)
(1582,247,0)
(6547,4070,0)
(3320,6351,0)
(8221,5829,0)
(1965,2226,0)
(7377,4928,0)
(2847,4929,0)
(8320,423,0)
(1191,5320,0)
(8892,1502,0)
(7841,1366,0)
(1085,5797,0)
(3989,466,0)
(6591,6497,0)
(5958,4884,0)
(3211,4837,0)
(4839,984,0)
(5620,4115,0)
(4130,6431,0)
(7892,7873,0)
(3672,329,0)
(8067,8415,0)
(4380,8834,0)
(1507,1480,0)
(7165,4139,0)
(9133,5209,0)
(8374,6427,0)
(3082,7703,0)
(7172,4928,0)
(1861,662,0)
(7992,49,0)
(5209,1053,0)
(6102,4928,0)
(1873,4920,0)
(6067,2378,0)
(4441,688,0)
(1359,4928,0)
(3359,3791,0)
(5411,4928,0)
(5535,4502,0)
(4644,7267,0)
(9097,7453,0)
(5614,6568,0)
(422,2963,0)
(8765,1966,0)
(4374,3131,0)
(7488,8743,0)
(4076,4744,0)
(8990,4928,0)
(7468,5115,0)
(308,3089,0)
(4045,5545,0)
(206,5989,0)
(7899,16,0)
(7016,1502,0)
(1254,2638,0)
(3618,7547,0)
(3411,8188,0)
(5131,5891,0)
(2322,7486,0)
(8126,1961,0)
(1056,4765,0)
(415,7605,0)
(8868,5043,0)
(6727,5964,0)
(4982,3299,0)
(6509,1002,0)
(6733,7167,0)
(1988,1489,0)
(504,1489,0)
(5578,1271,0)
(2080,5043,0)
(5106,2865,0)
(5833,1502,0)
(7151,6866,0)
(3675,801,0)
(1788,7435,0)
(7158,799,0)
(854,3307,0)
(6303,478,0)
(3974,7453,0)
(8481,4679,0)
(7011,4733,0)
(6786,8285,0)
(5417,2443,0)
(980,4862,0)
(1160,4502,0)
(7991,8188,0)
(3551,7593,0)
(3786,6915,0)
(2114,1863,0)
(1231,8547,0)
(2474,5587,0)
(3087,404,0)
(7573,6812,0)
(2269,3992,0)
(839,3673,0)
(6533,1589,0)
(6737,1050,0)
(3502,5056,0)
(8782,2194,0)
(2653,7390,0)
(5411,6047,0)
(7786,6398,0)
(8262,4834,0)
(323,5018,0)
(7020,1402,0)
(8318,1688,0)
(4920,228,0)
(8279,9105,0)
(9009,7928,0)
(7917,4928,0)
(7250,2306,0)
(8688,6682,0)
(1091,4676,0)
(2398,1244,0)
(7952,558,0)
(2967,4928,0)
(3850,4527,0)
(6105,8811,0)
(3810,1289,0)
(8856,6365,0)
(2656,6503,0)
(5644,5696,0)
(4012,801,0)
(3926,8081,0)
(4775,1201,0)
(3168,540,0)
(8485,930,0)
(3795,5409,0)
(128,4443,0)
(7943,1693,0)
(7308,8214,0)
(6245,8126,0)
(5294,8005,0)
(7813,5950,0)
(5123,7453,0)
(7874,9116,0)
(710,6569,0)
(7989,5894,0)
(396,5310,0)
(1670,178,0)
(5695,4602,0)
(1148,167,0)
(7445,7642,0)
(4373,2554,0)
(8214,7308,0)
(462,3017,0)
(7922,8148,0)
(582,732,0)
(617,3192,0)
(3482,4744,0)
(1516,6674,0)
(642,1502,0)
(9123,2241,0)
(5222,3423,0)
(5846,7372,0)
(557,176,0)
(879,4283,0)
(8370,6596,0)
(6189,887,0)
(5742,3051,0)
(6650,8664,0)
(4349,2802,0)
(6608,7453,0)
(8659,236,0)
(2900,8636,0)
(6913,7453,0)
(8572,8843,0)
(7913,6045,0)
(1386,2187,0)
(1881,2589,0)
(2133,2086,0)
(5543,933,0)
(7663,8675,0)
(4525,7535,0)
(7579,4385,0)
(3433,1502,0)
(814,1034,0)
(6990,1650,0)
(8392,1216,0)
(4091,43,0)
(6977,8254,0)
(425,4257,0)
(8603,3677,0)
(3968,6289,0)
(7299,825,0)
(4362,4817,0)
(2263,1642,0)
(7983,2874,0)
(3436,200,0)
(7241,1960,0)
(9037,742,0)
(2843,6047,0)
(1661,5531,0)
(3147,2814,0)
(6703,3528,0)
(3730,4928,0)
(7679,3852,0)
(1130,6924,0)
(1423,7481,0)
(7117,1502,0)
(3543,4928,0)
(8617,2873,0)
(6070,211,0)
(4255,3238,0)
(1876,5457,0)
(236,6335,0)
(5282,208,0)
(2417,4744,0)
(8130,2639,0)
(1698,1502,0)
(8805,4059,0)
(1048,7004,0)
(3302,4551,0)
(8590,5734,0)
(2656,5510,0)
(3699,8975,0)
(7819,5517,0)
(8716,6496,0)
(2218,1228,0)
(2300,1424,0)
(1971,8420,0)
(1933,7562,0)
(6788,4784,0)
(2183,8762,0)
(1925,2049,0)
(4072,8650,0)
(4909,5782,0)
(6428,5899,0)
(200,4765,0)
(5189,8361,0)
(4739,4928,0)
(2098,9026,0)
(4709,8215,0)
(1157,2741,0)
(3808,2962,0)
(2106,936,0)
(1312,9064,0)
(4265,6621,0)
(7010,1489,0)
(579,7924,0)
(371,4928,0)
(6254,6967,0)
(5166,832,0)
(4895,1919,0)
(4602,7904,0)
(4523,1916,0)
(7496,4928,0)
(7904,8843,0)
(3510,1343,0)
(7780,5273,0)
(5160,2017,0)
(7105,1859,0)
(2881,3175,0)
(3397,8666,0)
(8251,5587,0)
(4626,657,0)
(7362,1502,0)
(5202,1654,0)
(3790,825,0)
(5612,4835,0)
(6803,4452,0)
(4309,1901,0)
(6304,8037,0)
(7046,8037,0)
(4673,1502,0)
(1833,7998,0)
(4743,7965,0)
(1813,3086,0)
(6174,5637,0)
(3889,7377,0)
(6607,3126,0)
(4234,336,0)
(1159,405,0)
(656,1365,0)
(495,2124,0)
(3770,5108,0)
(4989,8678,0)
(5623,5468,0)
(6295,9126,0)
(5658,826,0)
(483,8408,0)
(2556,932,0)
(4139,6431,0)
(7943,1502,0)
(2953,1515,0)
(6327,7338,0)
(493,4138,0)
(1716,9,0)
(5020,155,0)
(177,3361,0)
(3019,4928,0)
(3302,4986,0)
(5203,4004,0)
(5075,3530,0)
(2117,4928,0)
(8829,6560,0)
(5250,343,0)
(5345,4912,0)
(4171,4222,0)
(3922,1440,0)
(2384,998,0)
(7804,2912,0)
(2101,7485,0)
(1231,5737,0)
(3191,1784,0)
(4539,8484,0)
(4365,7453,0)
(2301,1502,0)
(3642,4327,0)
(2320,3313,0)
(8614,5848,0)
(8698,7473,0)
(5338,2728,0)
(0,8995,0)
(609,672,0)
(6790,7269,0)
(708,4442,0)
(7427,1502,0)
(7253,5995,0)
(5441,1359,0)
(7668,1860,0)
(7320,2275,0)
(4617,5641,0)
(6436,1288,0)
(7003,8117,0)
(8445,6962,0)
(753,4236,0)
(5993,6532,0)
(8730,3087,0)
(997,6036,0)
(7555,2378,0)
(7443,7484,0)
(8772,6172,0)
(5608,4204,0)
(135,2851,0)
(461,2803,0)
(2778,3248,0)
(5035,4234,0)
(2994,4176,0)
(2947,1925,0)
(8479,6594,0)
(2869,6560,0)
(4184,4374,0)
(4008,4835,0)
(8542,802,0)
(6675,4571,0)
(8030,6894,0)
(8283,7067,0)
(2623,5062,0)
(8726,2262,0)
(8056,9137,0)
(8174,8585,0)
(7910,7994,0)
(6197,1497,0)
(3990,5902,0)
(2915,4781,0)
(9037,2204,0)
(6349,6882,0)
(7287,257,0)
(7046,1489,0)
(6218,4928,0)
(7366,8454,0)
(2342,6880,0)
(4907,1152,0)
(3941,2741,0)
(7506,4251,0)
(2489,4232,0)
(4258,8356,0)
(137,6790,0)
(2492,5043,0)
(4602,2677,0)
(4461,8830,0)
(3282,2700,0)
(2952,6599,0)
(6286,8770,0)
(5354,828,0)
(2835,1502,0)
(763,3012,0)
(1394,8271,0)
(5851,3385,0)
(8663,3458,0)
(595,7998,0)
(8198,2732,0)
(5329,7468,0)
(8186,4448,0)
(2173,7079,0)
(3690,6949,0)
(2643,2324,0)
(2805,8843,0)
(627,2114,0)
(695,4053,0)
(2298,7819,0)
(2803,5613,0)
(6721,4956,0)
(4896,7780,0)
(5703,1206,0)
(1795,2810,0)
(1851,5339,0)
(6947,1262,0)
(3406,5781,0)
(6768,6364,0)
(68,4155,0)
(5294,8678,0)
(3187,7566,0)
(1510,2576,0)
(8806,1502,0)
(8891,1502,0)
(1635,2537,0)
(4800,7412,0)
(9116,5614,0)
(7493,7447,0)
(3221,6181,0)
(9116,1502,0)
(7468,3313,0)
(3454,5611,0)
(9099,8612,0)
(9037,1228,0)
(4910,1502,0)
(5249,4613,0)
(5139,2013,0)
(3946,5118,0)
(2611,5950,0)
(3679,1497,0)
(3401,1502,0)
(1575,7444,0)
(5456,3263,0)
(1400,8722,0)
(4985,1502,0)
(6779,5336,0)
(7926,3019,0)
(1696,1298,0)
(9024,6928,0)
(7511,5320,0)
(140,8266,0)
(4950,838,0)
(504,5559,0)
(8202,4155,0)
(7533,672,0)
(4437,6560,0)
(8369,1572,0)
(9102,4473,0)
(5105,8510,0)
(2657,4915,0)
(1978,7706,0)
(8821,8475,0)
(1404,8866,0)
(7921,4155,0)
(2664,4928,0)
(2032,7361,0)
(523,1873,0)
(8574,4928,0)
(5244,800,0)
(2114,8902,0)
(9037,3674,0)
(2897,6148,0)
(4596,1170,0)
(8832,7341,0)
(818,7670,0)
(431,4928,0)
(2707,2844,0)
(6456,6987,0)
(2392,7004,0)
(1401,5953,0)
(970,4221,0)
(5977,1502,0)
(4963,2364,0)
(5477,3520,0)
(8058,6729,0)
(8855,4928,0)
(7697,4928,0)
(863,7477,0)
(1110,7067,0)
(3306,1502,0)
(1789,3630,0)
(4313,4437,0)
(194,6497,0)
(9156,2798,0)
(979,4001,0)
(8829,1128,0)
(6156,4551,0)
(7177,6391,0)
(1825,1502,0)
(2865,5106,0)
(5943,8810,0)
(512,5047,0)
(8416,5568,0)
(4531,5902,0)
(7847,2656,0)
(4343,1277,0)
(5268,8510,0)
(1046,8036,0)
(1968,1502,0)
(5871,8545,0)
(45,404,0)
(3104,2737,0)
(6027,3583,0)
(5721,1863,0)
(2994,2963,0)
(7329,7060,0)
(2206,5306,0)
(1646,1502,0)
(3676,6561,0)
(6148,4928,0)
(2530,2092,0)
(3525,1092,0)
(4794,8085,0)
(4036,5102,0)
(7521,46,0)
(9051,877,0)
(8581,7333,0)
(4378,7516,0)
(4175,8171,0)
(2237,6434,0)
(3875,3673,0)
(6688,6460,0)
(4731,3843,0)
(2476,1651,0)
(1643,8119,0)
(5680,4928,0)
(4701,213,0)
(2699,2197,0)
(8529,636,0)
(714,4860,0)
(3376,1502,0)
(1436,7671,0)
(2549,8827,0)
(5597,2338,0)
(163,2004,0)
(2207,5609,0)
(3302,5115,0)
(3468,3180,0)
(8883,2013,0)
(7957,4176,0)
(3342,1937,0)
(7382,7429,0)
(427,2027,0)
(934,3958,0)
(290,6314,0)
(6326,19,0)
(376,3058,0)
(6137,5896,0)
(2101,4320,0)
(5823,2794,0)
(300,6945,0)
(2189,5693,0)
(1983,5663,0)
(5228,4942,0)
(7805,4897,0)
(9065,6047,0)
(3458,2228,0)
(4835,441,0)
(5327,1502,0)
(3181,7713,0)
(9033,7924,0)
(6430,2208,0)
(1841,7023,0)
(1625,4550,0)
(242,1502,0)
(1479,1502,0)
(3259,4013,0)
(1503,1574,0)
(829,4571,0)
(8477,3609,0)
(1288,6436,0)
(8066,2025,0)
(2370,2349,0)
(1731,1273,0)
(153,7256,0)
(5456,8223,0)
(9115,1592,0)
(4740,5895,0)
(7737,4621,0)
(8620,8123,0)
(2558,1299,0)
(1859,770,0)
(2779,1873,0)
(444,1213,0)
(7721,7453,0)
(41,6184,0)
(3971,9093,0)
(648,632,0)
(5604,4095,0)
(5674,3856,0)
(1634,2496,0)
(7782,2404,0)
(5200,7912,0)
(6135,4013,0)
(766,3884,0)
(1053,2080,0)
(6005,1502,0)
(4779,2117,0)
(2431,6351,0)
(8737,3883,0)
(908,7000,0)
(4624,2316,0)
(5789,7630,0)
(5986,813,0)
(6352,5760,0)
(4798,4227,0)
(2735,2112,0)
(7043,1502,0)
(7243,6729,0)
(8200,4715,0)
(604,797,0)
(1123,4928,0)
(5641,1502,0)
(6706,5902,0)
(6807,8855,0)
(4099,1585,0)
(9062,6431,0)
(4124,4928,0)
(8142,5953,0)
(3034,3810,0)
(6304,7461,0)
(8929,6047,0)
(8337,7265,0)
(1512,4696,0)
(4557,4835,0)
(5062,6323,0)
(4071,1739,0)
(6942,3503,0)
(3633,211,0)
(379,8515,0)
(7168,2558,0)
(3026,3504,0)
(6458,3434,0)
(4898,4843,0)
(2020,9063,0)
(7480,371,0)
(2140,7738,0)
(4315,6290,0)
(2003,5458,0)
(702,1654,0)
(2536,4090,0)
(8306,3719,0)
(7928,5902,0)
(2688,3993,0)
(7902,4013,0)
(7473,8698,0)
(8993,4814,0)
(7208,8065,0)
(4137,5486,0)
(3292,919,0)
(179,7261,0)
(6517,6431,0)
(7491,5665,0)
(3695,7932,0)
(618,5957,0)
(5583,8703,0)
(1528,7725,0)
(250,7527,0)
(5294,8757,0)
(2832,3294,0)
(2373,7453,0)
(5294,908,0)
(829,997,0)
(8480,6047,0)
(7645,5902,0)
(4326,69,0)
(5179,4013,0)
(3975,4150,0)
(2242,8486,0)
(2204,7774,0)
(401,4910,0)
(6253,7765,0)
(1646,3134,0)
(4437,5244,0)
(3185,2156,0)
(4295,1928,0)
(1991,1502,0)
(632,648,0)
(3737,2804,0)
(1812,5973,0)
(4635,1502,0)
(5673,2496,0)
(362,5467,0)
(6602,8499,0)
(8147,3370,0)
(5343,4928,0)
(7635,7304,0)
(5350,1256,0)
(5768,5259,0)
(2829,2498,0)
(2533,6002,0)
(4659,1027,0)
(8829,2894,0)
(5318,7478,0)
(8492,1166,0)
(4704,4433,0)
(3456,4928,0)
(6036,997,0)
(5211,7171,0)
(8792,1774,0)
(4433,1502,0)
(4957,1921,0)
(1753,372,0)
(543,1502,0)
(2052,8527,0)
(6793,2243,0)
(6146,3376,0)
(1170,1502,0)
(5329,3583,0)
(7162,4196,0)
(7948,43,0)
(3620,7394,0)
(66,3815,0)
(7845,1600,0)
(7512,7372,0)
(3715,334,0)
(7889,4014,0)
(2812,6454,0)
(7857,7753,0)
(3179,8931,0)
(5911,1220,0)
(84,3185,0)
(3639,4880,0)
(2274,5733,0)
(4236,997,0)
(5647,8791,0)
(4142,3837,0)
(4367,6188,0)
(6490,5222,0)
(6320,6728,0)
(1423,573,0)
(1410,4744,0)
(3480,7453,0)
(3111,7453,0)
(4967,1600,0)
(17,6874,0)
(8805,451,0)
(3332,4464,0)
(5977,4928,0)
(2333,3793,0)
(6381,329,0)
(4785,3174,0)
(1762,1502,0)
(190,2739,0)
(5943,4518,0)
(7249,5456,0)
(5761,8865,0)
(7219,7212,0)
(8992,7509,0)
(8395,4321,0)
(4278,4928,0)
(6723,6410,0)
(1295,9044,0)
(1794,7955,0)
(1593,1294,0)
(8739,9040,0)
(5012,6402,0)
(2869,8188,0)
(7273,7399,0)
(6760,7453,0)
(5636,1502,0)
(7992,3372,0)
(7720,3583,0)
(2187,4584,0)
(3634,4131,0)
(7065,7083,0)
(1163,8392,0)
(7194,5358,0)
(8036,1502,0)
(284,5085,0)
(1708,4928,0)
(2699,5902,0)
(2320,1489,0)
(5263,1000,0)
(7156,4085,0)
(4627,375,0)
(2295,4928,0)
(6589,3999,0)
(5323,3381,0)
(671,7476,0)
(5839,7985,0)
(5590,3856,0)
(1387,591,0)
(9058,2054,0)
(5946,1027,0)
(2340,2156,0)
(6345,997,0)
(637,1102,0)
(7326,3645,0)
(3764,9055,0)
(9116,4928,0)
(1924,2443,0)
(2862,5161,0)
(1847,3656,0)
(1889,2340,0)
(9068,2741,0)
(6801,5443,0)
(7261,3852,0)
(8168,3968,0)
(4740,4928,0)
(324,7785,0)
(7212,1405,0)
(4437,8188,0)
(1402,3583,0)
(6227,4063,0)
(5144,5755,0)
(7768,3817,0)
(5260,677,0)
(7122,6298,0)
(7456,7453,0)
(6496,1843,0)
(4465,4095,0)
(2503,7223,0)
(8829,3313,0)
(8627,4199,0)
(7219,413,0)
(8278,5025,0)
(2320,503,0)
(4074,3583,0)
(1385,7994,0)
(5465,5980,0)
(8689,4896,0)
(2828,1502,0)
(1520,404,0)
(5196,5727,0)
(6395,4280,0)
(2159,8481,0)
(6202,1502,0)
(1632,774,0)
(6674,336,0)
(3843,7552,0)
(6737,8832,0)
(4623,5398,0)
(8525,2016,0)
(3641,1507,0)
(5051,93,0)
(1513,1475,0)
(2662,6588,0)
(4381,6348,0)
(6072,732,0)
(5623,3583,0)
(1801,6694,0)
(3942,6047,0)
(6771,5949,0)
(584,1590,0)
(8853,7453,0)
(6159,341,0)
(2793,2835,0)
(4466,6302,0)
(5611,384,0)
(2056,1502,0)
(3041,6450,0)
(2410,1502,0)
(2952,7453,0)
(713,2586,0)
(5110,6431,0)
(8820,7619,0)
(377,4304,0)
(5088,1502,0)
(2096,5071,0)
(3843,6431,0)
(4918,6247,0)
(436,5894,0)
(8625,3332,0)
(4185,5403,0)
(4158,7645,0)
(7328,8301,0)
(7011,4335,0)
(5062,3829,0)
(8137,5408,0)
(5043,8085,0)
(4313,4572,0)
(5383,1452,0)
(8023,2978,0)
(4346,6366,0)
(705,3786,0)
(3317,1157,0)
(6519,7390,0)
(9017,3168,0)
(2682,8843,0)
(6948,8288,0)
(3242,4426,0)
(3881,4744,0)
(1699,9128,0)
(8033,8767,0)
(6337,9049,0)
(1155,5116,0)
(366,4711,0)
(1508,7637,0)
(3095,7328,0)
(8555,1884,0)
(7303,7707,0)
(5547,804,0)
(7991,6465,0)
(6486,3028,0)
(170,7453,0)
(7046,5115,0)
(7231,6170,0)
(2406,8789,0)
(5269,1534,0)
(4851,2914,0)
(8143,3730,0)
(1872,2124,0)
(4201,8975,0)
(7803,8843,0)
(8072,1006,0)
(7614,1495,0)
(504,7148,0)
(8691,3220,0)
(3877,6659,0)
(4141,1502,0)
(821,7000,0)
(8951,6888,0)
(7440,8975,0)
(8427,731,0)
(2432,5937,0)
(8293,1856,0)
(5609,3407,0)
(3482,8833,0)
(1404,2289,0)
(6310,8455,0)
(3139,4266,0)
(3951,909,0)
(7504,734,0)
(7773,1502,0)
(8608,4269,0)
(1682,4961,0)
(6830,6047,0)
(5006,7453,0)
(4437,598,0)
(463,2783,0)
(1822,173,0)
(6285,6047,0)
(2184,5974,0)
(3114,1739,0)
(5358,8337,0)
(5694,5461,0)
(6601,6296,0)
(4154,1206,0)
(6107,2676,0)
(1060,7425,0)
(602,3909,0)
(2546,6461,0)
(5619,5646,0)
(6274,8178,0)
(2246,7101,0)
(5749,1040,0)
(2874,6150,0)
(5553,2767,0)
(5950,2611,0)
(2668,996,0)
(5871,5802,0)
(5118,4757,0)
(4943,9022,0)
(8128,4896,0)
(3757,9062,0)
(1734,2092,0)
(3303,9027,0)
(5074,1277,0)
(599,7453,0)
(7515,1831,0)
(544,5266,0)
(1991,4928,0)
(1728,1482,0)
(8750,7154,0)
(3192,9063,0)
(755,3899,0)
(9000,4700,0)
(4719,1502,0)
(2910,4013,0)
(6348,6296,0)
(1046,3624,0)
(2170,7113,0)
(6163,1530,0)
(6658,8910,0)
(9007,8809,0)
(3521,8843,0)
(1215,4141,0)
(8971,1420,0)
(1425,4509,0)
(8759,317,0)
(8294,7638,0)
(4081,8561,0)
(4778,0,0)
(8829,8678,0)
(4163,6838,0)
(1674,8782,0)
(723,6952,0)
(694,4238,0)
(6987,6588,0)
(85,7061,0)
(3658,2686,0)
(2228,3458,0)
(8226,2926,0)
(5001,1210,0)
(1240,6962,0)
(1828,3583,0)
(7435,1502,0)
(6452,5077,0)
(2009,4928,0)
(8901,7892,0)
(7609,594,0)
(1421,3775,0)
(2367,4610,0)
(7991,3674,0)
(7317,7846,0)
(6454,2812,0)
(7747,5039,0)
(1350,5686,0)
(8056,3340,0)
(5646,9036,0)
(4442,6047,0)
(8055,7552,0)
(4247,7375,0)
(5294,7216,0)
(1380,929,0)
(770,1859,0)
(3688,5199,0)
(2379,2180,0)
(2994,8217,0)
(2295,2748,0)
(1108,2220,0)
(5082,593,0)
(1902,1620,0)
(1991,6047,0)
(2349,7649,0)
(5315,7468,0)
(3825,8311,0)
(4409,8692,0)
(6702,7468,0)
(3284,3525,0)
(5409,3795,0)
(5238,1593,0)
(4978,7453,0)
(7716,7386,0)
(141,6047,0)
(8230,2088,0)
(7809,7374,0)
(4437,6465,0)
(2126,6729,0)
(6328,1502,0)
(1200,2119,0)
(1937,344,0)
(8077,5113,0)
(2777,1092,0)
(8847,5730,0)
(6560,2007,0)
(8559,3175,0)
(5099,5966,0)
(4845,3829,0)
(6208,4131,0)
(174,160,0)
(2256,3488,0)
(4932,6202,0)
(8656,7652,0)
(2632,6461,0)
(1717,8505,0)
(8006,7317,0)
(6299,9148,0)
(5883,6945,0)
(915,5635,0)
(3511,3180,0)
(7671,1436,0)
(8053,2686,0)
(6472,4194,0)
(2067,4831,0)
(1154,6792,0)
(1360,1502,0)
(3440,5668,0)
(6304,1489,0)
(7960,8678,0)
(7915,2516,0)
(1726,1502,0)
(3227,3871,0)
(5294,7288,0)
(5193,7103,0)
(7075,5721,0)
(3538,2067,0)
(955,394,0)
(64,5328,0)
(7409,4472,0)
(2548,4095,0)
(7898,8402,0)
(735,2665,0)
(1084,5198,0)
(352,4065,0)
(1352,2942,0)
(5821,6706,0)
(3370,4928,0)
(8140,1502,0)
(1320,2051,0)
(7305,6119,0)
(8560,46,0)
(4144,431,0)
(8455,4336,0)
(6304,6465,0)
(6802,278,0)
(3784,7805,0)
(1389,4730,0)
(3508,1081,0)
(4505,7411,0)
(504,1914,0)
(7148,2164,0)
(1553,5754,0)
(2206,1954,0)
(2265,3299,0)
(6183,4456,0)
(3609,1366,0)
(2751,2939,0)
(2418,8334,0)
(8537,4036,0)
(5882,5995,0)
(2579,5176,0)
(390,8868,0)
(6718,4164,0)
(1785,733,0)
(8785,1303,0)
(1629,2009,0)
(1746,7773,0)
(4301,2928,0)
(5232,2602,0)
(2138,9076,0)
(8524,3915,0)
(9075,4245,0)
(1302,5154,0)
(1701,3386,0)
(1585,3540,0)
(4976,8334,0)
(5762,3764,0)
(329,3672,0)
(3219,4808,0)
(8939,2004,0)
(1732,8843,0)
(3976,1469,0)
(8498,5266,0)
(5443,4928,0)
(3087,119,0)
(4169,1502,0)
(1988,5115,0)
(876,7628,0)
(4846,4551,0)
(4407,1397,0)
(8216,1866,0)
(3262,3674,0)
(1899,6694,0)
(270,7427,0)
(4937,3456,0)
(5491,7594,0)
(6900,1123,0)
(1327,3183,0)
(1818,1421,0)
(4608,5002,0)
(255,3085,0)
(2869,1228,0)
(1249,2111,0)
(8131,4336,0)
(7713,9118,0)
(4615,6860,0)
(3543,5437,0)
(6170,5902,0)
(1253,8960,0)
(972,7468,0)
(9037,642,0)
(2907,1502,0)
(2159,1708,0)
(5113,7699,0)
(2752,1597,0)
(3523,3575,0)
(2359,4928,0)
(4283,1599,0)
(4860,4928,0)
(5995,4928,0)
(2816,1991,0)
(1509,3267,0)
(4472,4986,0)
(5825,3770,0)
(3779,2741,0)
(1774,8792,0)
(5294,6252,0)
(2217,4567,0)
(3550,4928,0)
(5873,5728,0)
(7023,679,0)
(1586,6543,0)
(6213,5874,0)
(1790,4655,0)
(1539,4928,0)
(3381,8712,0)
(1032,713,0)
(6304,5914,0)
(8817,7534,0)
(2737,1502,0)
(8823,431,0)
(5782,4909,0)
(3131,2598,0)
(6426,4873,0)
(2119,495,0)
(9040,5902,0)
(3432,8611,0)
(1167,5566,0)
(5715,1599,0)
(1218,1502,0)
(7046,5559,0)
(2083,205,0)
(7006,3764,0)
(3028,1502,0)
(6351,1502,0)
(7821,56,0)
(6304,8987,0)
(6478,5114,0)
(493,5558,0)
(8696,4955,0)
(7685,4928,0)
(7132,4928,0)
(1501,3942,0)
(1487,1642,0)
(4245,9075,0)
(7840,7453,0)
(2017,7846,0)
(3643,5858,0)
(8412,7515,0)
(4809,1502,0)
(3894,2202,0)
(6309,2417,0)
(8775,2998,0)
(5474,4069,0)
(9128,4928,0)
(7308,6103,0)
(392,4928,0)
(9155,5383,0)
(3731,8476,0)
(1619,4191,0)
(8834,2426,0)
(1444,1452,0)
(1685,5617,0)
(2697,4928,0)
(1472,533,0)
(9065,7347,0)
(511,2874,0)
(4845,1502,0)
(8405,3840,0)
(5322,8843,0)
(3694,1675,0)
(2332,8908,0)
(5574,3591,0)
(959,6025,0)
(7229,6179,0)
(830,1502,0)
(1089,7502,0)
(5859,7390,0)
(4246,237,0)
(5078,4928,0)
(7457,1761,0)
(9096,9119,0)
(2329,1236,0)
(5835,4928,0)
(2869,2894,0)
(8178,2898,0)
(5207,9072,0)
(580,6673,0)
(1803,1833,0)
(5594,2898,0)
(4374,6795,0)
(3351,7035,0)
(7567,8843,0)
(4455,1502,0)
(4526,6539,0)
(3377,1246,0)
(7468,1128,0)
(7813,235,0)
(7280,2180,0)
(6853,3530,0)
(1798,1964,0)
(6265,4018,0)
(5405,5730,0)
(1460,1502,0)
(8893,6431,0)
(4196,5266,0)
(3575,1502,0)
(1492,1235,0)
(2949,929,0)
(4011,1786,0)
(6592,3775,0)
(848,3105,0)
(313,8092,0)
(5795,489,0)
(5683,5043,0)
(3289,8047,0)
(1141,3188,0)
(1111,4928,0)
(3336,3095,0)
(3304,5122,0)
(741,3899,0)
(2067,5091,0)
(8037,976,0)
(5922,8966,0)
(2999,2898,0)
(2597,5038,0)
(4980,8843,0)
(7470,7269,0)
(1405,7212,0)
(6188,4178,0)
(1494,428,0)
(2002,6924,0)
(4929,2847,0)
(3385,4928,0)
(1986,6596,0)
(8117,4928,0)
(863,6229,0)
(6628,7901,0)
(1894,4074,0)
(3595,3357,0)
(328,4928,0)
(2648,7793,0)
(5356,4928,0)
(5859,5829,0)
(4095,2548,0)
(6668,7466,0)
(4585,134,0)
(4787,6047,0)
(6634,4655,0)
(997,8843,0)
(6450,5043,0)
(4130,6566,0)
(3721,1515,0)
(8502,1369,0)
(8324,4306,0)
(4215,8126,0)
(3778,8843,0)
(6491,3101,0)
(6064,7453,0)
(606,6325,0)
(142,1335,0)
(6005,2929,0)
(7214,7439,0)
(3313,1502,0)
(196,2391,0)
(5706,2197,0)
(3263,5456,0)
(1088,1502,0)
(5027,272,0)
(8087,5097,0)
(4742,7548,0)
(9130,1502,0)
(2790,3557,0)
(7030,1502,0)
(7720,1502,0)
(4635,4928,0)
(4953,7151,0)
(371,2998,0)
(1256,849,0)
(6141,1108,0)
(7311,5043,0)
(6436,6288,0)
(4320,2101,0)
(5432,7846,0)
(5634,890,0)
(5442,49,0)
(735,350,0)
(4787,1502,0)
(6968,4928,0)
(1787,3376,0)
(2500,7232,0)
(6530,339,0)
(4668,4056,0)
(1479,6047,0)
(3880,4928,0)
(7664,4186,0)
(6213,6145,0)
(6476,2254,0)
(1613,7653,0)
(8659,7178,0)
(4157,6559,0)
(8305,5569,0)
(2381,3905,0)
(1423,6431,0)
(4138,2192,0)
(1004,7526,0)
(1142,6491,0)
(6304,7100,0)
(8086,5370,0)
(277,8370,0)
(2666,3134,0)
(4943,3025,0)
(7648,4296,0)
(910,3227,0)
(4804,2370,0)
(7046,7100,0)
(7638,8294,0)
(3352,7247,0)
(8244,1141,0)
(267,3758,0)
(3639,7227,0)
(1293,3171,0)
(3749,5282,0)
(1975,5560,0)
(9030,3935,0)
(2154,5233,0)
(777,7477,0)
(4874,4928,0)
(6881,6060,0)
(3903,7323,0)
(3591,3962,0)
(7468,6465,0)
(5875,4744,0)
(7061,8335,0)
(7108,7596,0)
(5810,1250,0)
(1524,328,0)
(2905,4544,0)
(5317,5460,0)
(4770,159,0)
(4523,9071,0)
(136,3041,0)
(3303,6888,0)
(5306,2206,0)
(2200,3902,0)
(4432,5625,0)
(1981,6479,0)
(464,2898,0)
(5085,7004,0)
(1915,4176,0)
(3279,4928,0)
(8873,2124,0)
(2721,6246,0)
(8032,7821,0)
(5852,6907,0)
(1831,7515,0)
(2736,3259,0)
(4678,7369,0)
(8697,3222,0)
(5544,1323,0)
(6562,9076,0)
(7748,3825,0)
(5173,8606,0)
(7155,4721,0)
(0,2290,0)
(4105,1675,0)
(3796,9020,0)
(1112,4473,0)
(2320,8678,0)
(482,8603,0)
(2602,1502,0)
(5916,3263,0)
(6404,984,0)
(1131,3491,0)
(2891,7554,0)
(6473,2164,0)
(1472,2889,0)
(2243,1502,0)
(1307,245,0)
(2898,4650,0)
(1932,7141,0)
(4648,4986,0)
(3972,484,0)
(3493,4928,0)
(8950,7593,0)
(2043,551,0)
(8972,927,0)
(2857,1033,0)
(7637,3902,0)
(8781,3808,0)
(7889,1502,0)
(8152,7453,0)
(1214,1471,0)
(2866,6465,0)
(5822,1848,0)
(5521,5421,0)
(8578,3140,0)
(2669,2674,0)
(4548,354,0)
(5780,1062,0)
(7380,4053,0)
(8217,6721,0)
(774,4591,0)
(4953,1502,0)
(8648,6884,0)
(4828,6626,0)
(1504,1843,0)
(1214,4878,0)
(945,2934,0)
(8231,7602,0)
(5293,7526,0)
(4313,7238,0)
(1388,3265,0)
(7781,209,0)
(6264,3397,0)
(1799,4805,0)
(2048,2051,0)
(7879,407,0)
(3159,1502,0)
(3300,4594,0)
(1091,7693,0)
(3666,1158,0)
(54,3305,0)
(4615,7453,0)
(2696,4265,0)
(3963,4961,0)
(4765,8843,0)
(4824,223,0)
(8969,738,0)
(697,5763,0)
(8898,4492,0)
(8205,3192,0)
(2887,212,0)
(166,1502,0)
(211,8544,0)
(3084,7446,0)
(2053,8392,0)
(4860,1502,0)
(731,8427,0)
(6191,1502,0)
(1305,1634,0)
(8097,5839,0)
(4555,771,0)
(6190,4352,0)
(5575,1428,0)
(6936,7563,0)
(7217,5493,0)
(4721,5735,0)
(8094,5854,0)
(8039,2414,0)
(5871,5108,0)
(3549,6075,0)
(3781,291,0)
(315,5178,0)
(3457,1502,0)
(5906,8964,0)
(3409,1133,0)
(609,2898,0)
(4754,8635,0)
(7385,818,0)
(3199,2772,0)
(1186,8662,0)
(4565,4928,0)
(7743,6249,0)
(5310,4928,0)
(249,8712,0)
(9125,4928,0)
(4150,2336,0)
(5271,2020,0)
(3274,2736,0)
(6953,6967,0)
(7400,5197,0)
(5329,956,0)
(8890,1812,0)
(304,7887,0)
(750,4704,0)
(1556,4341,0)
(9000,544,0)
(7805,5902,0)
(7695,2702,0)
(4164,1502,0)
(5753,1502,0)
(3137,573,0)
(2667,6036,0)
(6999,1943,0)
(5335,7060,0)
(8205,5902,0)
(5585,7959,0)
(7978,7291,0)
(5485,2298,0)
(2733,1616,0)
(4491,6047,0)
(2345,6503,0)
(2852,6018,0)
(6914,3978,0)
(5177,1515,0)
(2928,5705,0)
(4359,5330,0)
(3305,54,0)
(8417,1911,0)
(3512,1110,0)
(4019,3693,0)
(670,2249,0)
(2471,4928,0)
(3961,8629,0)
(8819,8843,0)
(3858,1491,0)
(45,119,0)
(8066,611,0)
(5934,5774,0)
(3362,1788,0)
(9112,2507,0)
(3220,8691,0)
(748,8370,0)
(6548,2325,0)
(8180,2184,0)
(7885,8233,0)
(6711,6836,0)
(6784,5252,0)
(2795,7370,0)
(5611,4928,0)
(669,387,0)
(4890,1698,0)
(3286,1502,0)
(2979,6455,0)
(605,8990,0)
(57,7713,0)
(8404,4194,0)
(371,6047,0)
(560,2001,0)
(7350,5343,0)
(4657,6047,0)
(4757,7961,0)
(8569,4517,0)
(3295,7708,0)
(7496,1502,0)
(745,8245,0)
(2802,8573,0)
(4609,2054,0)
(1302,284,0)
(5679,4590,0)
(5694,8035,0)
(5546,4169,0)
(6850,3089,0)
(3437,8858,0)
(7240,4928,0)
(2642,1981,0)
(2817,5735,0)
(3428,4420,0)
(43,3911,0)
(8534,2311,0)
(2128,1502,0)
(926,1654,0)
(7618,1502,0)
(1061,3401,0)
(4873,7042,0)
(3706,6247,0)
(9136,2267,0)
(6678,1115,0)
(3250,4928,0)
(6074,5642,0)
(5665,5325,0)
(1292,3188,0)
(7404,8041,0)
(1230,2627,0)
(1973,3100,0)
(4833,5199,0)
(6450,5902,0)
(4967,5995,0)
(6960,1251,0)
(4330,5301,0)
(1223,8513,0)
(6391,1502,0)
(5191,197,0)
(7398,4433,0)
(2471,468,0)
(1904,1502,0)
(752,20,0)
(3661,5889,0)
(1291,1502,0)
(7115,5043,0)
(4110,3815,0)
(4437,5573,0)
(2226,5991,0)
(2855,2568,0)
(6693,2194,0)
(4556,3941,0)
(8839,7413,0)
(1021,8194,0)
(6374,8574,0)
(8513,4928,0)
(7136,3085,0)
(515,1646,0)
(2035,1502,0)
(3662,6587,0)
(2656,6554,0)
(6200,6613,0)
(1324,5794,0)
(4906,5899,0)
(3605,7801,0)
(1170,4928,0)
(1837,8694,0)
(2812,2077,0)
(3031,2548,0)
(1295,4786,0)
(4299,6937,0)
(7132,1502,0)
(3152,1502,0)
(8802,3085,0)
(6979,7161,0)
(3767,9092,0)
(2987,5558,0)
(1406,3365,0)
(5378,735,0)
(3872,247,0)
(8972,8331,0)
(8136,1502,0)
(4771,4942,0)
(6106,6040,0)
(6594,7477,0)
(5142,1502,0)
(7366,8397,0)
(1211,2254,0)
(7427,6139,0)
(514,7304,0)
(8128,5902,0)
(8454,1502,0)
(1658,7951,0)
(1569,5683,0)
(5751,5498,0)
(7656,1502,0)
(4146,2420,0)
(4479,8079,0)
(7229,4220,0)
(6899,7965,0)
(4182,4640,0)
(5200,8739,0)
(3372,7992,0)
(6340,719,0)
(2311,862,0)
(6051,6782,0)
(1991,8748,0)
(4265,2696,0)
(7598,8081,0)
(1771,6530,0)
(8851,2061,0)
(2634,3306,0)
(8442,5593,0)
(3893,7548,0)
(4477,8671,0)
(3663,5797,0)
(220,2156,0)
(1105,1497,0)
(2316,263,0)
(4541,1237,0)
(9037,932,0)
(1043,2622,0)
(2943,8464,0)
(5359,4006,0)
(4006,3163,0)
(2836,6209,0)
(5075,4220,0)
(7126,3755,0)
(1488,6249,0)
(1447,3881,0)
(3292,3673,0)
(2521,3409,0)
(898,5203,0)
(3326,6749,0)
(7374,1502,0)
(139,6981,0)
(1741,2299,0)
(5194,3795,0)
(4490,2079,0)
(2869,7148,0)
(1311,6522,0)
(1634,6216,0)
(5930,8079,0)
(9055,8563,0)
(8783,799,0)
(5474,4928,0)
(2483,5351,0)
(5579,7089,0)
(5798,1837,0)
(5079,2630,0)
(3325,423,0)
(1440,8585,0)
(5769,8573,0)
(4572,1489,0)
(2553,3529,0)
(2620,3430,0)
(2844,8713,0)
(7277,2221,0)
(9037,8987,0)
(1123,1502,0)
(6411,2477,0)
(3625,7372,0)
(2490,7216,0)
(1269,7645,0)
(2587,7486,0)
(4443,128,0)
(5294,3825,0)
(3028,4928,0)
(131,6523,0)
(7527,2962,0)
(1457,3019,0)
(3419,3299,0)
(2666,5774,0)
(4618,7250,0)
(8440,3981,0)
(1568,5029,0)
(3459,3633,0)
(4660,6384,0)
(7834,7778,0)
(6302,4928,0)
(7960,7100,0)
(1903,2801,0)
(8408,1502,0)
(1986,311,0)
(6513,5085,0)
(7991,5559,0)
(8589,1326,0)
(6870,6853,0)
(4909,7132,0)
(6595,3608,0)
(5202,4810,0)
(721,4928,0)
(4590,8800,0)
(1254,5902,0)
(830,4928,0)
(3701,3877,0)
(404,1520,0)
(5785,839,0)
(4565,4597,0)
(1470,605,0)
(3330,4928,0)
(5416,2803,0)
(4150,6812,0)
(5311,1727,0)
(6737,5534,0)
(8679,8239,0)
(1775,336,0)
(4807,7063,0)
(5861,5036,0)
(606,7232,0)
(7392,464,0)
(6591,228,0)
(1979,484,0)
(5140,3907,0)
(5907,3167,0)
(2115,1855,0)
(9154,2025,0)
(7386,4928,0)
(5785,1908,0)
(3552,2568,0)
(1150,5211,0)
(7801,7191,0)
(1745,3463,0)
(4018,4675,0)
(5581,2084,0)
(1891,3969,0)
(9040,5043,0)
(2062,4037,0)
(7826,900,0)
(1522,4649,0)
(6988,2871,0)
(905,2262,0)
(753,6915,0)
(5899,2453,0)
(2374,7858,0)
(2172,1928,0)
(1628,6787,0)
(1135,6102,0)
(8283,5128,0)
(6483,2609,0)
(467,7481,0)
(295,3078,0)
(5642,4308,0)
(5787,1502,0)
(8171,4175,0)
(7286,1515,0)
(5004,8843,0)
(3116,8203,0)
(3748,9148,0)
(341,6159,0)
(5253,3885,0)
(8102,5023,0)
(1651,6887,0)
(8560,905,0)
(8861,2073,0)
(1934,4928,0)
(3573,1545,0)
(6849,8266,0)
(806,6165,0)
(4630,7284,0)
(338,1915,0)
(2106,181,0)
(8360,7457,0)
(8863,305,0)
(8358,6224,0)
(2921,7793,0)
(7547,3618,0)
(305,4928,0)
(8218,2353,0)
(5668,4928,0)
(4594,6792,0)
(4545,7649,0)
(2131,4078,0)
(2709,483,0)
(3338,1645,0)
(328,1502,0)
(373,8970,0)
(4124,1502,0)
(3725,441,0)
(2092,1734,0)
(1463,1772,0)
(5683,291,0)
(457,5086,0)
(7148,5043,0)
(6060,9020,0)
(7041,9148,0)
(829,1151,0)
(7089,5038,0)
(1519,7367,0)
(8890,6047,0)
(5294,6988,0)
(3349,5091,0)
(1654,4529,0)
(2290,0,0)
(6764,5104,0)
(111,7496,0)
(7518,2058,0)
(1241,1375,0)
(6488,1574,0)
(7875,2852,0)
(1027,7468,0)
(2980,4684,0)
(446,7652,0)
(7229,1502,0)
(6669,5458,0)
(5091,2067,0)
(7200,1232,0)
(2472,8767,0)
(6040,496,0)
(4831,2067,0)
(4657,1502,0)
(7089,6047,0)
(7644,618,0)
(4248,6148,0)
(6566,4130,0)
(7013,1801,0)
(7501,1502,0)
(9092,7744,0)
(2551,1934,0)
(4460,1626,0)
(631,2336,0)
(2951,4928,0)
(2407,4944,0)
(1078,7355,0)
(8376,2062,0)
(123,5499,0)
(8209,272,0)
(1523,4059,0)
(1027,1502,0)
(72,5311,0)
(797,7337,0)
(734,3990,0)
(5732,1502,0)
(847,7589,0)
(5518,905,0)
(8155,4781,0)
(8840,4021,0)
(899,4303,0)
(8668,8415,0)
(8362,6709,0)
(7668,7985,0)
(453,1789,0)
(4769,1502,0)
(933,1502,0)
(1337,483,0)
(1005,1433,0)
(8869,2852,0)
(6581,6555,0)
(7116,3226,0)
(7858,7847,0)
(9131,6987,0)
(756,7240,0)
(820,6455,0)
(4469,2544,0)
(2803,5043,0)
(1951,1202,0)
(927,8972,0)
(8695,7463,0)
(2621,4729,0)
(8779,2766,0)
(7362,3570,0)
(1638,9085,0)
(4707,2228,0)
(2239,905,0)
(3390,4974,0)
(5701,7605,0)
(9153,4490,0)
(5571,8334,0)
(9037,7092,0)
(1016,7422,0)
(3417,2981,0)
(2142,4928,0)
(5932,1675,0)
(2739,190,0)
(2046,5775,0)
(5366,2283,0)
(6820,6031,0)
(2732,6928,0)
(8762,6587,0)
(1192,5136,0)
(100,4177,0)
(8026,3069,0)
(5153,4163,0)
(3108,4110,0)
(6733,924,0)
(2172,8519,0)
(5550,7389,0)
(8271,3526,0)
(7417,5325,0)
(7068,2294,0)
(3184,6047,0)
(6749,4304,0)
(1600,5838,0)
(1390,3202,0)
(3442,3710,0)
(7460,6871,0)
(1440,2567,0)
(7593,1502,0)
(370,4928,0)
(1313,3375,0)
(7468,1591,0)
(3210,6246,0)
(516,1693,0)
(1182,6197,0)
(455,7100,0)
(4582,7697,0)
(1195,7453,0)
(2612,6844,0)
(5282,4598,0)
(2779,56,0)
(5351,1086,0)
(981,3783,0)
(7129,4573,0)
(317,8759,0)
(2325,2028,0)
(197,5191,0)
(8964,7558,0)
(5145,1111,0)
(132,4676,0)
(1977,4928,0)
(1004,826,0)
(624,1410,0)
(5912,289,0)
(6461,2546,0)
(4817,4362,0)
(5294,7885,0)
(3535,6164,0)
(7399,3227,0)
(4084,2378,0)
(6380,8802,0)
(5458,3931,0)
(381,2227,0)
(458,4517,0)
(2951,1502,0)
(5337,6847,0)
(4293,6606,0)
(1685,5747,0)
(2732,1502,0)
(1048,2050,0)
(4673,6613,0)
(8642,4372,0)
(3876,216,0)
(6945,7004,0)
(6681,4171,0)
(5472,6375,0)
(4652,5191,0)
(8728,3530,0)
(2460,5336,0)
(2926,8647,0)
(5174,2054,0)
(8692,5043,0)
(4090,2536,0)
(4468,7486,0)
(9066,1843,0)
(199,3485,0)
(5984,8310,0)
(4313,5294,0)
(7673,6871,0)
(6197,1182,0)
(6714,45,0)
(8849,6071,0)
(6918,7958,0)
(4049,4928,0)
(3503,6942,0)
(219,9006,0)
(2673,4928,0)
(2798,9156,0)
(2141,8632,0)
(3162,310,0)
(7043,4928,0)
(1631,1502,0)
(4565,1502,0)
(4658,4928,0)
(905,8561,0)
(3418,355,0)
(8348,3907,0)
(6585,750,0)
(6338,3238,0)
(3820,7453,0)
(7796,4705,0)
(2798,2142,0)
(5934,5398,0)
(1591,119,0)
(1898,311,0)
(6306,8843,0)
(8828,3411,0)
(8948,1335,0)
(4053,1031,0)
(7725,7004,0)
(5680,1502,0)
(5833,38,0)
(1664,952,0)
(7373,8527,0)
(1025,1943,0)
(6020,4830,0)
(6108,8833,0)
(7762,4928,0)
(1392,4928,0)
(164,6868,0)
(4502,4,0)
(4525,1469,0)
(4437,5559,0)
(393,3258,0)
(998,588,0)
(6259,7347,0)
(6314,7761,0)
(1531,2391,0)
(7792,2035,0)
(9081,1556,0)
(8176,9019,0)
(6379,4022,0)
(4561,1502,0)
(4078,5301,0)
(5803,7022,0)
(8482,2681,0)
(4322,3838,0)
(1945,6047,0)
(7999,1502,0)
(1165,7364,0)
(4566,4013,0)
(2262,8726,0)
(175,5457,0)
(1072,5964,0)
(3382,5875,0)
(924,6733,0)
(8550,8789,0)
(3937,5109,0)
(3251,1880,0)
(1998,8092,0)
(3996,4164,0)
(4358,6008,0)
(1650,1975,0)
(6112,7118,0)
(3493,8789,0)
(4738,90,0)
(8929,3771,0)
(8814,1227,0)
(6159,5209,0)
(7728,7100,0)
(7440,200,0)
(2997,9042,0)
(8863,7453,0)
(2219,6890,0)
(7046,3313,0)
(5195,4293,0)
(719,4081,0)
(1626,1005,0)
(3222,8574,0)
(4059,4787,0)
(1796,2952,0)
(1831,3362,0)
(4849,155,0)
(6276,8525,0)
(4034,1093,0)
(4513,3613,0)
(1270,2322,0)
(4005,3378,0)
(6296,3992,0)
(7088,2189,0)
(7264,4631,0)
(7347,9065,0)
(3346,651,0)
(3423,5003,0)
(365,6500,0)
(1222,3905,0)
(7245,304,0)
(1390,1502,0)
(8260,8092,0)
(499,1502,0)
(3089,6850,0)
(2354,3553,0)
(6623,7453,0)
(7702,4294,0)
(7368,2248,0)
(1281,8843,0)
(4579,5838,0)
(3561,8388,0)
(4774,7093,0)
(7401,1278,0)
(3012,315,0)
(6304,707,0)
(2290,5894,0)
(2021,8289,0)
(3499,8843,0)
(321,2107,0)
(4843,825,0)
(5694,2254,0)
(2808,920,0)
(497,2819,0)
(2050,7959,0)
(6388,6051,0)
(507,3405,0)
(8618,3111,0)
(6250,1861,0)
(2824,1347,0)
(8308,1402,0)
(245,1502,0)
(2828,4928,0)
(4072,3836,0)
(16,5964,0)
(8167,6744,0)
(2346,354,0)
(7016,3693,0)
(6392,5043,0)
(7211,1768,0)
(3099,8884,0)
(3238,7150,0)
(3249,5886,0)
(8895,8868,0)
(6871,4928,0)
(2959,7366,0)
(5030,5618,0)
(644,606,0)
(3149,8551,0)
(7224,1589,0)
(2270,5560,0)
(4808,3219,0)
(3294,5415,0)
(2090,1476,0)
(3244,7649,0)
(1761,7558,0)
(5610,4243,0)
(1645,1421,0)
(8448,9117,0)
(6482,1502,0)
(4448,4732,0)
(5726,1722,0)
(5758,6572,0)
(7822,4567,0)
(902,7004,0)
(5655,8585,0)
(2109,1502,0)
(5294,8029,0)
(1284,5763,0)
(8858,5043,0)
(876,8545,0)
(5526,8800,0)
(8965,2329,0)
(1033,4928,0)
(7321,1415,0)
(6810,1294,0)
(8765,7004,0)
(5044,161,0)
(798,2280,0)
(4437,7137,0)
(5569,5337,0)
(8222,350,0)
(7352,5266,0)
(2742,7724,0)
(198,1968,0)
(4996,5104,0)
(2541,3525,0)
(2619,8902,0)
(5305,2978,0)
(5858,8843,0)
(1598,4928,0)
(6157,8366,0)
(7210,3577,0)
(1461,8325,0)
(2382,8222,0)
(2746,3791,0)
(4702,1463,0)
(2867,5662,0)
(7264,8199,0)
(6689,5291,0)
(4866,5306,0)
(772,1502,0)
(6842,7765,0)
(5794,5080,0)
(4673,4928,0)
(254,6301,0)
(7953,1548,0)
(3920,6791,0)
(5653,9058,0)
(6786,5902,0)
(1092,3525,0)
(7501,4928,0)
(5572,7885,0)
(4391,4371,0)
(6919,7738,0)
(4152,4892,0)
(3054,4371,0)
(1946,3900,0)
(394,7394,0)
(3461,2741,0)
(891,2875,0)
(2278,5043,0)
(976,334,0)
(117,6910,0)
(5607,5617,0)
(3978,5197,0)
(593,7808,0)
(3502,3082,0)
(4725,2555,0)
(9145,6047,0)
(3958,3933,0)
(4181,5826,0)
(3227,8129,0)
(4815,9156,0)
(6708,4769,0)
(7468,7148,0)
(3166,7622,0)
(5268,3286,0)
(5329,1502,0)
(8778,2265,0)
(2264,4721,0)
(8776,5684,0)
(3087,3049,0)
(7780,4896,0)
(1925,8469,0)
(5294,2893,0)
(2517,5493,0)
(5045,8753,0)
(1593,1502,0)
(8027,4829,0)
(7478,4485,0)
(3123,1439,0)
(1892,5211,0)
(5891,1923,0)
(5997,5900,0)
(473,2495,0)
(1423,4744,0)
(2536,8009,0)
(8596,6571,0)
(3938,6,0)
(8443,7412,0)
(6515,1502,0)
(2294,7004,0)
(614,1776,0)
(282,59,0)
(251,8862,0)
(8829,8987,0)
(5814,7453,0)
(32,4928,0)
(6873,3581,0)
(8179,1502,0)
(7610,2033,0)
(6304,6277,0)
(4813,5080,0)
(2210,6899,0)
(8054,7453,0)
(7229,46,0)
(6518,8975,0)
(7807,3026,0)
(2869,6988,0)
(3258,393,0)
(47,4757,0)
(8282,626,0)
(7729,805,0)
(3677,8603,0)
(341,7790,0)
(222,1852,0)
(6567,2533,0)
(8560,3583,0)
(8827,4048,0)
(7912,4246,0)
(1424,3152,0)
(3258,1056,0)
(5183,2537,0)
(4147,1596,0)
(9062,3757,0)
(3077,7097,0)
(5793,7502,0)
(5457,2748,0)
(4025,1161,0)
(6069,7132,0)
(611,8066,0)
(2633,4670,0)
(2603,3077,0)
(6755,8442,0)
(8361,6940,0)
(4572,1591,0)
(3869,8634,0)
(2527,7447,0)
(2128,6047,0)
(3066,3043,0)
(7897,2557,0)
(8806,4928,0)
(1826,7092,0)
(6123,6391,0)
(7651,6951,0)
(8539,6489,0)
(1451,2898,0)
(364,4928,0)
(2171,4928,0)
(7769,4492,0)
(1761,7457,0)
(7668,8492,0)
(5294,7148,0)
(8139,8794,0)
(555,7453,0)
(7225,1624,0)
(5294,598,0)
(7262,2558,0)
(8815,4163,0)
(118,6172,0)
(5002,8843,0)
(263,5902,0)
(5158,8994,0)
(7674,329,0)
(827,2666,0)
(1520,2831,0)
(8078,7612,0)
(7597,4569,0)
(4150,2181,0)
(5632,5929,0)
(2453,2709,0)
(6292,4257,0)
(918,9113,0)
(5724,1446,0)
(5628,8778,0)
(2372,527,0)
(8,5202,0)
(751,9,0)
(838,997,0)
(672,7533,0)
(5840,554,0)
(7618,5869,0)
(7660,1961,0)
(7934,5403,0)
(7423,4673,0)
(5294,6930,0)
(6080,1753,0)
(3389,4124,0)
(3305,6697,0)
(7732,7645,0)
(4972,5809,0)
(2740,6750,0)
(3647,2020,0)
(7150,3238,0)
(1278,6952,0)
(8866,1404,0)
(3531,5745,0)
(6317,6375,0)
(8487,3630,0)
(5729,3550,0)
(3885,1116,0)
(1139,8638,0)
(7377,8525,0)
(8848,1419,0)
(7115,4168,0)
(4236,753,0)
(7901,2760,0)
(2810,1553,0)
(5145,4956,0)
(6903,1037,0)
(455,598,0)
(5745,645,0)
(5723,812,0)
(7166,4928,0)
(6984,2793,0)
(7215,4065,0)
(7509,2007,0)
(8795,731,0)
(5294,8033,0)
(2286,7498,0)
(6455,2979,0)
(2292,2051,0)
(5707,2241,0)
(6304,1616,0)
(3752,1128,0)
(2895,3343,0)
(4117,7042,0)
(4711,7822,0)
(5065,4163,0)
(412,8412,0)
(5664,2645,0)
(375,2898,0)
(4542,1502,0)
(2344,2825,0)
(5778,5137,0)
(1548,7462,0)
(1065,2551,0)
(8552,1866,0)
(5763,1284,0)
(3409,1502,0)
(659,1829,0)
(2394,4837,0)
(9008,7468,0)
(504,7092,0)
(3927,1314,0)
(920,8063,0)
(1420,3032,0)
(2137,993,0)
(6024,6922,0)
(6866,7151,0)
(3310,2656,0)
(8994,7822,0)
(6161,1291,0)
(1218,1796,0)
(5599,876,0)
(428,1494,0)
(3177,2699,0)
(5965,7221,0)
(7590,5730,0)
(1599,2004,0)
(6892,5286,0)
(3110,1456,0)
(8208,3941,0)
(629,3591,0)
(3370,4204,0)
(1738,1502,0)
(2370,1502,0)
(764,890,0)
(7842,3699,0)
(4857,4272,0)
(4841,8022,0)
(6736,1502,0)
(8450,3125,0)
(1684,1031,0)
(3211,6047,0)
(5790,5498,0)
(5589,8280,0)
(5086,4928,0)
(3773,7413,0)
(7286,7004,0)
(5185,4740,0)
(4873,4928,0)
(5781,8604,0)
(3308,432,0)
(76,828,0)
(7563,2860,0)
(107,4529,0)
(2791,7447,0)
(7104,2079,0)
(543,6047,0)
(2684,207,0)
(526,9028,0)
(5038,7089,0)
(5461,3924,0)
(1659,6328,0)
(7729,1763,0)
(8736,2575,0)
(2337,6435,0)
(4296,7648,0)
(8371,6260,0)
(4336,8455,0)
(3354,5029,0)
(8998,6746,0)
(258,3250,0)
(5482,2367,0)
(15,8501,0)
(1339,4676,0)
(1808,1197,0)
(4371,3259,0)
(2287,8399,0)
(6712,4221,0)
(1990,3855,0)
(2204,5747,0)
(8432,5255,0)
(7017,8728,0)
(8360,3958,0)
(8342,2077,0)
(8931,3179,0)
(3457,6842,0)
(833,1142,0)
(7890,5787,0)
(1553,2810,0)
(1793,7761,0)
(4212,3617,0)
(5854,8094,0)
(8891,2952,0)
(6978,1986,0)
(4846,1591,0)
(266,6170,0)
(4528,7999,0)
(225,5953,0)
(2349,2370,0)
(4552,4280,0)
(6037,5456,0)
(1073,2565,0)
(7125,8843,0)
(7017,9015,0)
(1580,2741,0)
(5324,7884,0)
(443,66,0)
(3294,1599,0)
(4911,4525,0)
(784,6684,0)
(4878,1214,0)
(435,4753,0)
(5924,5787,0)
(7233,2700,0)
(3794,7256,0)
(4306,8324,0)
(5848,8614,0)
(5844,4354,0)
(3085,8193,0)
(259,3184,0)
(8982,2461,0)
(5435,5878,0)
(1688,1502,0)
(3548,7453,0)
(3195,8027,0)
(3079,4163,0)
(193,8843,0)
(1597,7119,0)
(4542,6047,0)
(1367,3542,0)
(4193,991,0)
(3163,4006,0)
(4571,829,0)
(7498,4788,0)
(9037,1919,0)
(1679,62,0)
(8936,297,0)
(1934,1502,0)
(4554,7202,0)
(7545,289,0)
(2130,7807,0)
(2627,1230,0)
(7092,8635,0)
(8165,6133,0)
(6791,3794,0)
(7098,4928,0)
(843,4115,0)
(2015,6066,0)
(4437,742,0)
(916,4853,0)
(4862,222,0)
(600,2766,0)
(2289,1404,0)
(8199,1502,0)
(3362,1831,0)
(8954,4443,0)
(1592,9115,0)
(5948,8500,0)
(5890,7453,0)
(4990,8005,0)
(4534,5043,0)
(8914,8826,0)
(5108,3770,0)
(3777,4928,0)
(5755,3862,0)
(1425,5342,0)
(1514,5531,0)
(5294,6757,0)
(8356,4928,0)
(1156,6318,0)
(8611,7922,0)
(6483,6148,0)
(1588,2178,0)
(4170,4278,0)
(4204,3370,0)
(3727,6335,0)
(4844,211,0)
(1346,5265,0)
(66,1126,0)
(9021,8339,0)
(2065,6931,0)
(3417,1628,0)
(8548,5124,0)
(6360,8313,0)
(8714,8843,0)
(8890,1502,0)
(5197,7629,0)
(5177,1502,0)
(5602,3486,0)
(5522,1085,0)
(2032,2786,0)
(7945,1502,0)
(5840,1088,0)
(7131,4928,0)
(8132,2626,0)
(8262,8580,0)
(1626,4928,0)
(2743,2757,0)
(2273,8614,0)
(5550,2898,0)
(5488,8192,0)
(2262,905,0)
(5600,8966,0)
(8531,4130,0)
(645,1945,0)
(6017,5785,0)
(8664,567,0)
(674,6057,0)
(9065,4928,0)
(4719,4928,0)
(8497,4236,0)
(1086,6431,0)
(6512,2197,0)
(2774,9080,0)
(8127,8843,0)
(5509,3169,0)
(8068,1003,0)
(4837,2394,0)
(3575,4928,0)
(8855,1502,0)
(6556,7337,0)
(1394,8016,0)
(4563,6844,0)
(6495,7159,0)
(4247,1502,0)
(3085,255,0)
(4846,5115,0)
(3015,6726,0)
(1152,9072,0)
(6103,7308,0)
(2150,3953,0)
(1619,2185,0)
(400,1502,0)
(3763,5047,0)
(3220,7453,0)
(9008,3583,0)
(739,578,0)
(8712,7453,0)
(7755,4392,0)
(413,8298,0)
(5979,3667,0)
(7948,2650,0)
(3068,2843,0)
(5294,3613,0)
(7675,4955,0)
(5851,7453,0)
(5294,8794,0)
(4472,5559,0)
(1521,4886,0)
(3971,4928,0)
(3739,3472,0)
(9050,2755,0)
(3167,2352,0)
(6631,3142,0)
(885,5576,0)
(160,2569,0)
(4338,8633,0)
(4419,460,0)
(5252,8843,0)
(7522,4928,0)
(5895,952,0)
(8481,2159,0)
(6722,3792,0)
(8561,905,0)
(7079,3357,0)
(2050,2767,0)
(2747,8962,0)
(6726,1915,0)
(2117,1502,0)
(5514,1936,0)
(5159,1502,0)
(4934,6432,0)
(1081,1502,0)
(5015,8367,0)
(237,2784,0)
(7422,4928,0)
(9110,7960,0)
(1260,7505,0)
(1038,4996,0)
(8937,8866,0)
(3309,7453,0)
(1471,4765,0)
(2535,8547,0)
(3361,5455,0)
(7833,3639,0)
(8688,3681,0)
(3591,8283,0)
(1645,3338,0)
(8829,1489,0)
(3559,3013,0)
(7143,4928,0)
(5307,8800,0)
(2459,6193,0)
(9036,56,0)
(1714,8329,0)
(4459,6518,0)
(9129,822,0)
(3112,9093,0)
(4462,1131,0)
(928,7199,0)
(5969,8922,0)
(799,1515,0)
(7046,3674,0)
(3603,334,0)
(2280,6047,0)
(7361,7750,0)
(7215,317,0)
(895,1852,0)
(1900,1329,0)
(581,3013,0)
(7310,3401,0)
(1000,6838,0)
(2969,4928,0)
(2566,525,0)
(4915,7403,0)
(4749,6792,0)
(6891,8145,0)
(2368,5829,0)
(5080,1502,0)
(5520,4025,0)
(4342,1950,0)
(3086,3265,0)
(5121,1132,0)
(4187,3241,0)
(1001,1197,0)
(1197,4928,0)
(8319,6637,0)
(5908,6932,0)
(4087,4201,0)
(1567,9074,0)
(6563,425,0)
(103,4623,0)
(4121,8891,0)
(1870,3591,0)
(1004,87,0)
(8590,1918,0)
(5199,3688,0)
(6413,5218,0)
(6767,1883,0)
(6336,4849,0)
(8402,4928,0)
(7419,2749,0)
(7901,1502,0)
(1960,4765,0)
(8929,4928,0)
(7204,5999,0)
(7336,2565,0)
(2730,6224,0)
(4782,2095,0)
(4710,3167,0)
(3872,3533,0)
(6626,5466,0)
(841,4932,0)
(4927,2741,0)
(3340,8056,0)
(2840,772,0)
(346,4259,0)
(2751,6533,0)
(223,2999,0)
(6993,4422,0)
(913,3372,0)
(65,3040,0)
(2031,4024,0)
(3691,6658,0)
(5122,3304,0)
(490,2622,0)
(1964,2466,0)
(2320,1228,0)
(1949,1390,0)
(6129,4090,0)
(1155,5759,0)
(996,1084,0)
(862,5451,0)
(4776,8962,0)
(8722,222,0)
(2703,6577,0)
(8870,6912,0)
(7188,259,0)
(4849,7453,0)
(7017,831,0)
(7278,3955,0)
(8419,3527,0)
(5914,6752,0)
(475,8230,0)
(3870,4928,0)
(2421,1616,0)
(5665,8254,0)
(7394,394,0)
(9100,1502,0)
(2105,813,0)
(7758,1436,0)
(7564,8537,0)
(4415,4116,0)
(7912,3985,0)
(7005,2779,0)
(2929,6005,0)
(4823,8252,0)
(1283,4072,0)
(3998,5369,0)
(8800,4590,0)
(1288,2969,0)
(1937,3342,0)
(7730,8915,0)
(2311,1502,0)
(812,5255,0)
(491,1132,0)
(1825,4928,0)
(2555,7196,0)
(392,4810,0)
(2268,2863,0)
(1483,5775,0)
(7750,7361,0)
(5896,4928,0)
(4969,7335,0)
(3201,5180,0)
(8273,5975,0)
(4952,7434,0)
(3126,6607,0)
(8239,4598,0)
(8636,4928,0)
(284,1302,0)
(8325,720,0)
(5351,2483,0)
(3348,7685,0)
(7894,3225,0)
(1952,6620,0)
(2243,4928,0)
(3519,4347,0)
(5387,319,0)
(5652,7366,0)
(2443,1502,0)
(1512,4220,0)
(4458,5988,0)
(45,8998,0)
(7325,73,0)
(7675,6939,0)
(7790,7979,0)
(26,4347,0)
(567,8664,0)
(6512,1449,0)
(8934,876,0)
(4374,2825,0)
(6895,8242,0)
(1989,3219,0)
(1178,1329,0)
(882,514,0)
(5636,157,0)
(8233,4715,0)
(8544,7523,0)
(1303,1502,0)
(2049,5266,0)
(3503,7587,0)
(4107,642,0)
(6362,4997,0)
(6578,3250,0)
(4078,2131,0)
(2338,7533,0)
(2513,8843,0)
(3282,2535,0)
(5093,1441,0)
(3212,764,0)
(6872,1151,0)
(2876,5042,0)
(5839,2907,0)
(9029,4384,0)
(4222,8875,0)
(329,7674,0)
(5270,309,0)
(7150,8703,0)
(7894,4928,0)
(9056,4236,0)
(7705,4034,0)
(935,8195,0)
(4274,4880,0)
(4036,8537,0)
(1429,5545,0)
(2169,6588,0)
(1259,4923,0)
(8590,1866,0)
(6741,2673,0)
(5746,6385,0)
(7238,8678,0)
(98,208,0)
(8123,1904,0)
(5554,2967,0)
(3897,1185,0)
(5054,6996,0)
(2045,3327,0)
(9026,489,0)
(2565,1502,0)
(1868,8396,0)
(7683,2453,0)
(2413,3965,0)
(4252,4991,0)
(3063,3319,0)
(6294,4176,0)
(877,1502,0)
(6272,8741,0)
(6816,4657,0)
(5941,2427,0)
(5802,5889,0)
(2163,3905,0)
(5306,1328,0)
(4163,7056,0)
(2989,7199,0)
(5489,6134,0)
(836,1581,0)
(4443,8954,0)
(9063,2020,0)
(4553,7196,0)
(4298,1246,0)
(3716,6427,0)
(5406,826,0)
(5989,2399,0)
(9037,8037,0)
(5959,4209,0)
(7004,8843,0)
(9104,3758,0)
(4535,2477,0)
(6025,1502,0)
(6610,8032,0)
(9069,952,0)
(313,6108,0)
(1179,1727,0)
(764,3212,0)
(6246,2721,0)
(2738,4360,0)
(3447,3721,0)
(7684,218,0)
(6882,3716,0)
(304,7468,0)
(2023,2838,0)
(2320,8037,0)
(3216,5902,0)
(4958,4448,0)
(9037,7461,0)
(6787,5091,0)
(9093,3112,0)
(3017,5728,0)
(2684,9018,0)
(4625,6830,0)
(5294,6423,0)
(8273,332,0)
(4410,6270,0)
(9037,1489,0)
(6962,8810,0)
(3789,7736,0)
(6343,3372,0)
(5401,3410,0)
(2349,7453,0)
(2611,5902,0)
(466,3989,0)
(7943,4928,0)
(6181,7004,0)
(3184,259,0)
(8829,7092,0)
(8584,7206,0)
(7296,5211,0)
(6046,2709,0)
(990,2381,0)
(7206,8584,0)
(3003,6398,0)
(5945,3243,0)
(7046,2113,0)
(5081,8205,0)
(6896,5356,0)
(5357,2073,0)
(2254,5694,0)
(4652,2838,0)
(8903,2253,0)
(1164,1476,0)
(3495,8066,0)
(8451,4928,0)
(6629,3575,0)
(4257,425,0)
(8118,1837,0)
(2912,8913,0)
(4754,4746,0)
(1206,6385,0)
(5330,6047,0)
(8120,1502,0)
(5448,4928,0)
(2221,8064,0)
(6802,8542,0)
(4025,7014,0)
(5243,2664,0)
(8944,1502,0)
(4717,4928,0)
(6909,3193,0)
(3786,7004,0)
(4936,315,0)
(1459,6384,0)
(4437,2893,0)
(1584,272,0)
(3753,9150,0)
(2596,2,0)
(867,8233,0)
(597,4928,0)
(6493,6975,0)
(8742,2253,0)
(1858,8606,0)
(6445,8015,0)
(6968,1502,0)
(3133,6812,0)
(6304,642,0)
(7832,6510,0)
(15,9027,0)
(9126,6295,0)
(4805,3638,0)
(4602,334,0)
(8411,5818,0)
(586,7257,0)
(5949,7486,0)
(5446,190,0)
(4115,4744,0)
(6960,638,0)
(1028,2461,0)
(1004,7518,0)
(7242,3342,0)
(7462,1548,0)
(2888,8862,0)
(2331,9040,0)
(5642,6074,0)
(4074,1342,0)
(4674,2414,0)
(2859,1687,0)
(5528,3375,0)
(6325,5858,0)
(1542,2494,0)
(8970,2206,0)
(1515,7286,0)
(5397,1240,0)
(5951,7391,0)
(4979,8100,0)
(4705,3078,0)
(480,3063,0)
(8284,3616,0)
(5945,4928,0)
(7836,7529,0)
(4324,3406,0)
(7430,5217,0)
(8050,2656,0)
(3159,4056,0)
(8024,4124,0)
(1930,1369,0)
(5658,7526,0)
(4760,1686,0)
(7355,4928,0)
(6480,8213,0)
(875,2468,0)
(9082,7453,0)
(3369,6826,0)
(4389,1918,0)
(2977,5945,0)
(8415,8067,0)
(7722,492,0)
(3534,2622,0)
(6304,8678,0)
(5294,6560,0)
(9026,5115,0)
(4708,2487,0)
(2181,4150,0)
(4472,7092,0)
(286,4176,0)
(5468,4209,0)
(7890,3386,0)
(1381,5665,0)
(8966,1502,0)
(2587,4920,0)
(7393,7652,0)
(5278,772,0)
(2076,7955,0)
(2929,3632,0)
(5258,4928,0)
(8300,5499,0)
(466,7451,0)
(6257,222,0)
(8792,4182,0)
(2522,2165,0)
(1357,1339,0)
(2499,7453,0)
(200,3436,0)
(4910,6047,0)
(2238,9131,0)
(4168,7115,0)
(8950,577,0)
(5443,1502,0)
(531,8997,0)
(6732,326,0)
(7149,7833,0)
(7652,7393,0)
(4227,4825,0)
(4638,8488,0)
(733,1785,0)
(2889,6968,0)
(4615,3440,0)
(3979,4729,0)
(704,1914,0)
(2636,124,0)
(1829,659,0)
(4723,1299,0)
(2662,1487,0)
(5610,5689,0)
(4838,2035,0)
(65,6606,0)
(4437,2113,0)
(5885,8500,0)
(6997,9065,0)
(8266,140,0)
(3657,1502,0)
(9045,6173,0)
(1005,1626,0)
(9108,1605,0)
(5732,9081,0)
(2477,4535,0)
(4411,3325,0)
(4476,2715,0)
(1837,1502,0)
(8408,483,0)
(6469,2744,0)
(4520,4177,0)
(2946,5100,0)
(2494,6047,0)
(6005,4928,0)
(1334,7596,0)
(7865,8931,0)
(4930,1776,0)
(2056,4343,0)
(6311,930,0)
(8084,2142,0)
(3343,1502,0)
(7393,4554,0)
(7256,5082,0)
(2838,4652,0)
(1086,5351,0)
(138,1226,0)
(2837,5902,0)
(3693,4019,0)
(4884,1502,0)
(2190,7638,0)
(1198,9043,0)
(5944,7849,0)
(5738,1363,0)
(5991,1901,0)
(9081,5732,0)
(3533,2898,0)
(9027,15,0)
(4856,6925,0)
(1129,5166,0)
(7444,1575,0)
(5328,4350,0)
(3871,8367,0)
(2222,8463,0)
(6974,8397,0)
(223,4824,0)
(554,2576,0)
(8197,7309,0)
(2051,1320,0)
(2320,5559,0)
(591,1387,0)
(7098,1502,0)
(1064,549,0)
(4602,1502,0)
(2671,4007,0)
(5561,8990,0)
(1250,2041,0)
(1154,5760,0)
(2305,2352,0)
(679,3795,0)
(7468,598,0)
(5119,1772,0)
(6939,1502,0)
(7383,8406,0)
(9086,7956,0)
(4095,2793,0)
(1558,8619,0)
(134,1052,0)
(2944,8989,0)
(1834,4744,0)
(4713,4685,0)
(4956,5145,0)
(8875,6698,0)
(4904,7055,0)
(2381,5082,0)
(5100,7311,0)
(3138,6607,0)
(9076,6562,0)
(7850,2618,0)
(8199,7264,0)
(8702,7453,0)
(3953,1502,0)
(5299,7097,0)
(8336,7167,0)
(3164,2312,0)
(9042,5902,0)
(2954,1116,0)
(7473,2315,0)
(4472,2894,0)
(4482,8459,0)
(2248,213,0)
(1339,1357,0)
(852,4928,0)
(3593,8501,0)
(3156,5703,0)
(9070,4753,0)
(8227,4928,0)
(5021,651,0)
(4472,2893,0)
(7628,6999,0)
(4313,7077,0)
(7640,543,0)
(1323,5544,0)
(4555,8146,0)
(7689,4242,0)
(1953,4928,0)
(6368,597,0)
(1132,491,0)
(1008,4347,0)
(3677,7012,0)
(4426,7412,0)
(3969,1891,0)
(4270,6353,0)
(2882,4629,0)
(187,3886,0)
(7099,2056,0)
(135,6431,0)
(2761,588,0)
(6,6418,0)
(7831,9093,0)
(8402,1502,0)
(336,4234,0)
(1577,3502,0)
(1117,6450,0)
(2863,4928,0)
(4512,7143,0)
(4783,5734,0)
(7592,688,0)
(7543,7523,0)
(2387,2999,0)
(3420,4928,0)
(2457,7211,0)
(6685,7428,0)
(4814,1502,0)
(7414,1202,0)
(1387,4928,0)
(4941,8428,0)
(693,1502,0)
(6583,7440,0)
(6090,3985,0)
(9069,1596,0)
(2002,771,0)
(4546,2477,0)
(6291,3409,0)
(4477,6431,0)
(1981,6698,0)
(9085,1502,0)
(8593,8331,0)
(8610,4527,0)
(3904,6866,0)
(1216,64,0)
(6967,2399,0)
(8967,707,0)
(7580,7477,0)
(8829,5999,0)
(9135,463,0)
(6270,1,0)
(7854,5214,0)
(7661,6401,0)
(8494,4928,0)
(6942,7351,0)
(7933,3603,0)
(1385,7468,0)
(5960,1358,0)
(4210,2715,0)
(6392,3663,0)
(4874,6440,0)
(4158,6642,0)
(1141,8244,0)
(6199,98,0)
(7601,6405,0)
(8709,8331,0)
(3623,6379,0)
(4155,7004,0)
(3366,5525,0)
(2907,4928,0)
(450,1502,0)
(7994,5869,0)
(2748,5457,0)
(281,7618,0)
(218,6191,0)
(4538,4390,0)
(824,5698,0)
(1335,8843,0)
(1653,7934,0)
(6027,902,0)
(349,2798,0)
(6642,4158,0)
(5368,1634,0)
(7498,1961,0)
(3511,6270,0)
(7046,7148,0)
(3091,5548,0)
(7759,1274,0)
(4095,2589,0)
(1720,6850,0)
(5286,7252,0)
(4109,4100,0)
(1692,5658,0)
(2440,2834,0)
(7937,6158,0)
(5595,4639,0)
(5714,9134,0)
(7482,7453,0)
(1547,849,0)
(2024,5010,0)
(1982,8826,0)
(2661,1977,0)
(4590,7468,0)
(3791,6847,0)
(8192,1583,0)
(943,930,0)
(2571,4928,0)
(7590,7269,0)
(4455,4928,0)
(109,425,0)
(1134,2812,0)
(6261,1475,0)
(6865,8843,0)
(1353,1460,0)
(6532,250,0)
(8188,2487,0)
(7383,2364,0)
(1988,5559,0)
(6862,209,0)
(3705,157,0)
(4304,6749,0)
(8109,5147,0)
(6743,381,0)
(8071,4928,0)
(3760,2060,0)
(4004,5203,0)
(6062,7689,0)
(5992,4116,0)
(504,8188,0)
(9037,707,0)
(7502,334,0)
(54,334,0)
(6082,1260,0)
(1136,2629,0)
(8292,2494,0)
(3751,5848,0)
(2873,2898,0)
(3979,1502,0)
(509,2837,0)
(7124,4224,0)
(5029,7023,0)
(5264,4684,0)
(8833,3482,0)
(4724,8700,0)
(5052,8337,0)
(933,4928,0)
(7790,5043,0)
(6313,1042,0)
(7883,830,0)
(7323,2982,0)
(7700,6674,0)
(8329,8499,0)
(6667,8970,0)
(1265,8498,0)
(7685,1139,0)
(5787,7890,0)
(4846,3596,0)
(1441,5266,0)
(1250,3007,0)
(1892,1502,0)
(6304,3674,0)
(6137,7858,0)
(1762,4928,0)
(1040,1599,0)
(3212,3725,0)
(1442,839,0)
(3511,8991,0)
(8863,1784,0)
(2837,509,0)
(399,7453,0)
(1828,1502,0)
(3688,3382,0)
(4515,1108,0)
(7734,9051,0)
(961,3703,0)
(3080,7188,0)
(3845,2554,0)
(5115,8940,0)
(1517,3618,0)
(3192,8205,0)
(7767,5219,0)
(5901,6187,0)
(4553,2898,0)
(7117,4928,0)
(5274,6128,0)
(5294,8987,0)
(5434,4786,0)
(8239,7892,0)
(5869,7618,0)
(8793,6164,0)
(6194,3100,0)
(7825,7427,0)
(4314,5895,0)
(7338,6562,0)
(1004,5030,0)
(3136,7708,0)
(232,1549,0)
(8692,4409,0)
(7541,8887,0)
(1982,8831,0)
(7718,956,0)
(3120,4951,0)
(8678,1502,0)
(8011,7602,0)
(2460,6120,0)
(5712,7707,0)
(7420,1513,0)
(7900,7186,0)
(6871,7460,0)
(7150,5693,0)
(5439,5302,0)
(2655,2302,0)
(8760,182,0)
(3233,5663,0)
(5259,6047,0)
(1612,821,0)
(6975,4942,0)
(7870,3979,0)
(3010,7453,0)
(4671,5523,0)
(6418,6,0)
(4437,7148,0)
(3710,3442,0)
(2215,2315,0)
(6025,4928,0)
(8508,750,0)
(3791,1502,0)
(5693,2189,0)
(6478,6042,0)
(1419,1502,0)
(5753,93,0)
(1185,1502,0)
(6099,3280,0)
(6955,2488,0)
(6482,7468,0)
(7632,3140,0)
(7432,1895,0)
(840,2699,0)
(5918,3306,0)
(1506,3032,0)
(2241,4928,0)
(7120,1698,0)
(8913,2912,0)
(9089,5137,0)
(3831,5180,0)
(259,7188,0)
(8379,362,0)
(3532,5949,0)
(1562,8843,0)
(6574,5515,0)
(3563,1691,0)
(1458,8367,0)
(8638,3180,0)
(175,1794,0)
(543,4928,0)
(271,4674,0)
(5095,8960,0)
(4572,4113,0)
(8991,3511,0)
(2248,4928,0)
(3120,5550,0)
(5427,1249,0)
(6032,1766,0)
(2792,4744,0)
(5862,5025,0)
(6482,3583,0)
(5092,3086,0)
(7621,1516,0)
(7984,1505,0)
(8518,2401,0)
(7521,1502,0)
(8313,6360,0)
(7922,7412,0)
(1490,7453,0)
(7046,8188,0)
(7876,4825,0)
(2299,4928,0)
(3430,161,0)
(6018,4063,0)
(5807,8585,0)
(3033,428,0)
(4016,4455,0)
(6864,2715,0)
(3511,500,0)
(699,4499,0)
(2166,6529,0)
(1755,2619,0)
(3234,884,0)
(3973,1540,0)
(6481,5351,0)
(7429,1479,0)
(8397,7366,0)
(4768,161,0)
(529,131,0)
(2718,7689,0)
(4922,8091,0)
(845,8832,0)
(8741,6272,0)
(6218,1502,0)
(7960,3245,0)
(2780,5695,0)
(3505,1240,0)
(2444,3526,0)
(17,4236,0)
(641,4765,0)
(7710,6103,0)
(5541,3147,0)
(8662,6648,0)
(872,6912,0)
(7474,1817,0)
(6905,4676,0)
(1152,7628,0)
(4235,2726,0)
(1911,8417,0)
(7661,1207,0)
(4291,5293,0)
(3791,4928,0)
(9037,6853,0)
(4374,997,0)
(3152,1424,0)
(9004,361,0)
(2280,1502,0)
(5283,8358,0)
(4761,5036,0)
(4284,1502,0)
(8796,6479,0)
(4418,6158,0)
(6866,680,0)
(5293,4291,0)
(6361,5110,0)
(484,7004,0)
(7146,1828,0)
(7311,5954,0)
(874,8343,0)
(3170,2202,0)
(5178,1291,0)
(2728,3528,0)
(6773,8741,0)
(8780,4422,0)
(6515,255,0)
(1574,1503,0)
(5502,1540,0)
(2012,2865,0)
(9041,940,0)
(4259,3153,0)
(8170,4299,0)
(8356,1502,0)
(1782,7076,0)
(3819,7468,0)
(2451,5896,0)
(7793,6907,0)
(849,1256,0)
(712,2113,0)
(8731,6034,0)
(8575,1075,0)
(5592,2336,0)
(4830,2389,0)
(846,7720,0)
(5909,5656,0)
(8389,594,0)
(8113,5821,0)
(37,6181,0)
(6981,139,0)
(7523,8544,0)
(6195,1424,0)
(4111,9130,0)
(332,8273,0)
(8839,3414,0)
(1713,7451,0)
(5109,3937,0)
(3301,3227,0)
(1220,2582,0)
(7658,1884,0)
(3402,5130,0)
(2580,6757,0)
(3777,6047,0)
(4043,6328,0)
(1104,7477,0)
(1644,5031,0)
(9106,7117,0)
(2064,9096,0)
(5817,1,0)
(6792,1154,0)
(4614,4200,0)
(1958,4243,0)
(2518,7435,0)
(2243,2380,0)
(5997,1685,0)
(3294,943,0)
(2213,1928,0)
(6521,6985,0)
(2828,2503,0)
(5596,5854,0)
(2861,3339,0)
(1028,3583,0)
(993,2137,0)
(3777,1502,0)
(4739,8214,0)
(3032,1506,0)
(6809,1158,0)
(2516,4634,0)
(5265,1346,0)
(8681,4539,0)
(5463,6410,0)
(7806,6751,0)
(7642,2021,0)
(5665,2639,0)
(4014,7889,0)
(1485,4729,0)
(2073,7481,0)
(2026,7453,0)
(3725,3212,0)
(3130,4842,0)
(2843,4445,0)
(2937,4928,0)
(1636,7948,0)
(3237,8923,0)
(8763,4078,0)
(2320,1128,0)
(8829,5115,0)
(2924,6465,0)
(2753,4928,0)
(1075,1502,0)
(2869,1128,0)
(8636,6047,0)
(1651,5059,0)
(2782,484,0)
(685,3375,0)
(771,2002,0)
(4269,2834,0)
(2750,8273,0)
(8001,721,0)
(5354,7662,0)
(2073,6431,0)
(3508,5989,0)
(663,4502,0)
(4369,6884,0)
(1535,8537,0)
(813,2105,0)
(5968,393,0)
(8192,0,0)
(7178,8659,0)
(7872,7208,0)
(8480,3506,0)
(3993,2766,0)
(1944,4799,0)
(5294,4373,0)
(9035,4655,0)
(7229,7468,0)
(6296,6348,0)
(5769,5648,0)
(3319,1502,0)
(6234,5408,0)
(6471,6102,0)
(5096,3288,0)
(3693,7016,0)
(1984,7240,0)
(5940,1636,0)
(2982,3848,0)
(6822,8979,0)
(4056,3159,0)
(5171,4983,0)
(7122,4809,0)
(7867,7699,0)
(7557,5689,0)
(5435,8623,0)
(4155,997,0)
(5864,2496,0)
(4889,5610,0)
(925,7466,0)
(7343,2663,0)
(4384,9029,0)
(4394,2249,0)
(7335,3779,0)
(688,6896,0)
(0,8192,0)
(5361,6953,0)
(5866,2774,0)
(6249,7743,0)
(5073,4052,0)
(2178,3217,0)
(8596,4826,0)
(8829,2893,0)
(6041,4166,0)
(4497,2479,0)
(8957,991,0)
(7070,855,0)
(2611,1846,0)
(3115,5132,0)
(6752,7521,0)
(4138,4378,0)
(255,6515,0)
(1219,2299,0)
(6757,672,0)
(8441,5258,0)
(6841,738,0)
(8560,7468,0)
(644,1617,0)
(7467,915,0)
(2039,7484,0)
(2930,2301,0)
(2728,1502,0)
(4961,887,0)
(7486,2587,0)
(713,1032,0)
(4502,6750,0)
(8612,8692,0)
(2392,3259,0)
(3376,5233,0)
(2986,2760,0)
(6015,6193,0)
(5784,5683,0)
(5155,3407,0)
(1088,4928,0)
(1410,6431,0)
(4174,148,0)
(5510,6765,0)
(5511,1924,0)
(3306,4928,0)
(8380,2101,0)
(4058,2496,0)
(7560,4507,0)
(4508,5370,0)
(2452,7453,0)
(2886,925,0)
(1621,2051,0)
(4572,8188,0)
(2135,1174,0)
(2201,7281,0)
(6120,2460,0)
(4913,5161,0)
(806,2741,0)
(5516,7152,0)
(5696,1502,0)
(4194,1052,0)
(8145,8500,0)
(7717,4928,0)
(8990,1502,0)
(3460,6574,0)
(4017,2100,0)
(3986,7624,0)
(7213,2403,0)
(5700,3379,0)
(890,764,0)
(3994,7651,0)
(5180,7453,0)
(1351,764,0)
(176,6047,0)
(7965,7386,0)
(1296,1334,0)
(8687,4695,0)
(3502,1577,0)
(1230,5888,0)
(3906,8662,0)
(492,1502,0)
(1719,2981,0)
(8002,3330,0)
(8803,5327,0)
(4480,4980,0)
(426,6738,0)
(2582,948,0)
(7076,1782,0)
(8864,8576,0)
(7308,3962,0)
(8452,2642,0)
(6571,8596,0)
(8603,3581,0)
(618,1502,0)
(7512,1921,0)
(7460,3674,0)
(4564,5122,0)
(4942,5228,0)
(3327,4928,0)
(5444,4502,0)
(4472,1489,0)
(5291,7412,0)
(2950,6301,0)
(4860,4811,0)
(3589,3325,0)
(5787,4928,0)
(3547,3883,0)
(5362,3304,0)
(7570,6613,0)
(7448,6266,0)
(5817,1502,0)
(1533,2223,0)
(4387,4769,0)
(8073,8991,0)
(1453,3510,0)
(6959,5390,0)
(310,4928,0)
(2506,123,0)
(3842,6757,0)
(3608,4598,0)
(4778,8343,0)
(607,5043,0)
(4705,8872,0)
(6019,4278,0)
(4811,4860,0)
(8040,8302,0)
(8704,5325,0)
(5086,1502,0)
(2109,1428,0)
(3527,2322,0)
(1544,2525,0)
(2654,8280,0)
(1687,4928,0)
(4640,6047,0)
(5331,4214,0)
(5587,8251,0)
(5938,4242,0)
(7127,8053,0)
(5327,8803,0)
(8314,8850,0)
(7991,6988,0)
(5948,1369,0)
(4693,0,0)
(6075,5043,0)
(7645,7732,0)
(5209,6159,0)
(8834,3423,0)
(8038,45,0)
(9031,1502,0)
(22,9058,0)
(1051,7880,0)
(6302,1502,0)
(1328,7643,0)
(6304,1128,0)
(6372,7783,0)
(4284,7540,0)
(8515,3727,0)
(4352,7545,0)
(3415,5241,0)
(8452,8981,0)
(7182,315,0)
(6353,4928,0)
(7778,2734,0)
(363,6193,0)
(5630,8972,0)
(7777,3830,0)
(5114,7522,0)
(2788,7562,0)
(3746,62,0)
(5661,6218,0)
(2074,8437,0)
(7473,4189,0)
(7814,6522,0)
(7671,2925,0)
(5334,4678,0)
(8304,5864,0)
(5828,6103,0)
(5867,7547,0)
(8513,1502,0)
(7589,7166,0)
(5222,1114,0)
(8641,328,0)
(8447,2626,0)
(6639,471,0)
(3268,887,0)
(1317,5977,0)
(7347,2441,0)
(998,8015,0)
(7421,4176,0)
(5330,4928,0)
(2079,3891,0)
(6544,8728,0)
(3865,8278,0)
(6516,7422,0)
(8215,503,0)
(6901,3491,0)
(4183,1448,0)
(2329,7453,0)
(3302,2893,0)
(8039,7029,0)
(712,7148,0)
(6440,7154,0)
(4506,1072,0)
(7813,5416,0)
(7277,7411,0)
(4569,7597,0)
(7147,2729,0)
(2896,4942,0)
(8229,5668,0)
(7186,6377,0)
(6304,7033,0)
(4442,1502,0)
(6928,9024,0)
(1221,657,0)
(7737,8962,0)
(6398,8217,0)
(4540,7214,0)
(1830,5646,0)
(2486,487,0)
(7851,1848,0)
(2219,268,0)
(7005,4920,0)
(1464,1860,0)
(1142,4744,0)
(2913,476,0)
(6739,1267,0)
(502,2776,0)
(6637,7216,0)
(8039,334,0)
(6187,2951,0)
(5678,427,0)
(1362,5900,0)
(2925,4928,0)
(8498,8217,0)
(712,7092,0)
(6304,1837,0)
(6243,9081,0)
(6848,978,0)
(6507,218,0)
(2577,3147,0)
(4821,2838,0)
(2242,6391,0)
(3506,6554,0)
(3261,8843,0)
(7037,1221,0)
(4183,4928,0)
(772,2840,0)
(5259,1502,0)
(292,4840,0)
(7565,1850,0)
(8563,7257,0)
(2222,4176,0)
(6085,8273,0)
(5049,7388,0)
(4206,9137,0)
(1548,2736,0)
(6707,7265,0)
(9142,4928,0)
(4874,1502,0)
(2674,1250,0)
(7267,1207,0)
(7753,7596,0)
(7654,2619,0)
(7959,4744,0)
(1069,5248,0)
(9111,3638,0)
(6216,5864,0)
(6373,7919,0)
(2749,4289,0)
(4572,8678,0)
(1611,8770,0)
(5558,614,0)
(7554,5666,0)
(7033,1502,0)
(5850,1411,0)
(6158,8585,0)
(9151,8862,0)
(4407,4384,0)
(5663,334,0)
(1548,6517,0)
(8746,4724,0)
(4000,6659,0)
(7581,1103,0)
(4955,3796,0)
(6348,1502,0)
(2954,4928,0)
(3575,7364,0)
(7042,1534,0)
(8260,1502,0)
(1397,8312,0)
(370,4328,0)
(6620,5472,0)
(210,6056,0)
(3993,4928,0)
(7256,1505,0)
(2110,3630,0)
(5481,668,0)
(6329,4271,0)
(2437,1316,0)
(5230,6696,0)
(3158,4808,0)
(7920,1262,0)
(8880,5435,0)
(7548,4928,0)
(1213,242,0)
(3032,1420,0)
(6726,4176,0)
(8722,8930,0)
(5067,3855,0)
(4658,8885,0)
(742,8083,0)
(7916,9130,0)
(5733,2586,0)
(5408,6234,0)
(1788,3362,0)
(9054,2507,0)
(5735,2817,0)
(1484,5222,0)
(2547,3528,0)
(8640,567,0)
(8623,6705,0)
(5646,6776,0)
(3997,8028,0)
(7214,3522,0)
(4650,2898,0)
(5965,8230,0)
(8442,2364,0)
(6998,8908,0)
(8120,7191,0)
(9125,1502,0)
(5801,6607,0)
(3676,4631,0)
(3977,5456,0)
(932,573,0)
(6455,6446,0)
(1236,2329,0)
(1774,3097,0)
(5953,7453,0)
(2082,4950,0)
(2715,4928,0)
(8032,2322,0)
(6517,1548,0)
(6697,7768,0)
(3410,6040,0)
(4141,4928,0)
(2445,2626,0)
(5097,3583,0)
(4057,3543,0)
(6611,6262,0)
(181,1213,0)
(4046,6785,0)
(2572,6398,0)
(6999,2025,0)
(8506,8089,0)
(8192,4173,0)
(8803,4994,0)
(8336,4928,0)
(4521,1701,0)
(5893,7453,0)
(70,1943,0)
(5262,7607,0)
(5398,5934,0)
(7988,5075,0)
(6231,7172,0)
(3388,4569,0)
(3393,5859,0)
(9037,5573,0)
(6413,3169,0)
(940,9041,0)
(5373,5467,0)
(4390,1502,0)
(2260,8239,0)
(228,6591,0)
(2423,6771,0)
(8367,3871,0)
(4602,5695,0)
(8528,3902,0)
(8335,1502,0)
(7641,3718,0)
(5456,7880,0)
(4846,598,0)
(3103,6742,0)
(6496,8716,0)
(3566,1785,0)
(2055,5134,0)
(5464,5821,0)
(538,3583,0)
(7451,466,0)
(6111,1908,0)
(8858,6173,0)
(8782,4928,0)
(4610,7917,0)
(6746,5651,0)
(3190,4928,0)
(3637,3187,0)
(4726,155,0)
(1380,4928,0)
(905,8560,0)
(1874,4497,0)
(552,2178,0)
(8184,8566,0)
(7783,3817,0)
(5622,209,0)
(5525,7000,0)
(1402,7468,0)
(7931,721,0)
(1292,3426,0)
(80,3929,0)
(2478,2627,0)
(7583,3379,0)
(6377,953,0)
(3265,5902,0)
(5933,8937,0)
(7464,2952,0)
(607,5902,0)
(7408,3892,0)
(216,9036,0)
(2301,4928,0)
(269,2656,0)
(6371,6688,0)
(5387,8333,0)
(8544,211,0)
(5290,8733,0)
(4156,3839,0)
(3478,6440,0)
(6987,7520,0)
(8530,4977,0)
(3462,3058,0)
(984,5656,0)
(1603,8510,0)
(8074,6222,0)
(1636,5349,0)
(9073,2686,0)
(2113,3583,0)
(4313,9026,0)
(8913,900,0)
(937,1409,0)
(6450,3041,0)
(3639,7833,0)
(7145,3120,0)
(8424,6436,0)
(4136,1185,0)
(7619,2844,0)
(795,310,0)
(5292,4551,0)
(7463,6523,0)
(96,2153,0)
(4984,991,0)
(7256,3794,0)
(5241,1762,0)
(7054,9123,0)
(1698,4890,0)
(9037,7137,0)
(1234,3187,0)
(6173,8858,0)
(5803,5635,0)
(1727,1502,0)
(6008,4928,0)
(6898,7744,0)
(8646,750,0)
(1166,8492,0)
(1010,6949,0)
(2710,1721,0)
(1190,4183,0)
(6874,7118,0)
(150,2415,0)
(3887,6252,0)
(358,2187,0)
(3832,2792,0)
(1693,7943,0)
(3553,1825,0)
(5294,2488,0)
(7476,361,0)
(8392,1502,0)
(213,953,0)
(5705,2928,0)
(1014,2873,0)
(4494,1502,0)
(645,5745,0)
(2849,6232,0)
(1953,651,0)
(7244,359,0)
(2088,8230,0)
(5084,8794,0)
(3469,3294,0)
(2252,4969,0)
(2408,1079,0)
(4386,8975,0)
(5696,4928,0)
(2738,8944,0)
(3730,4929,0)
(1993,3971,0)
(1359,2426,0)
(8633,4928,0)
(4378,4138,0)
(6346,6295,0)
(272,8209,0)
(1230,6316,0)
(3733,7166,0)
(3247,7887,0)
(1463,4702,0)
(7379,2407,0)
(5603,3357,0)
(3236,1659,0)
(6969,5864,0)
(5033,2906,0)
(5120,8209,0)
(2482,1338,0)
(7838,8753,0)
(6831,611,0)
(1493,5330,0)
(3536,6691,0)
(2422,5750,0)
(2961,6698,0)
(4677,64,0)
(8266,826,0)
(3991,5668,0)
(211,4676,0)
(2326,4477,0)
(44,4221,0)
(3384,7810,0)
(4282,3639,0)
(8350,7575,0)
(9138,2819,0)
(8850,1592,0)
(331,1810,0)
(5702,4980,0)
(1904,8123,0)
(2334,140,0)
(8059,8891,0)
(738,1502,0)
(2456,7046,0)
(3677,5265,0)
(6829,6068,0)
(1278,1502,0)
(3211,4928,0)
(7930,4673,0)
(6996,7004,0)
(6333,2843,0)
(4077,2222,0)
(1872,1157,0)
(7973,8500,0)
(5774,3504,0)
(5698,224,0)
(7485,6569,0)
(4437,8037,0)
(2284,8847,0)
(3777,6751,0)
(3815,4110,0)
(6567,5443,0)
(1573,8757,0)
(6751,312,0)
(1298,3583,0)
(5526,3365,0)
(236,8659,0)
(2969,1288,0)
(7576,3703,0)
(6638,1788,0)
(181,2106,0)
(3117,1155,0)
(3576,8036,0)
(6827,5964,0)
(6071,2686,0)
(1939,1539,0)
(4943,5745,0)
(143,1982,0)
(876,3962,0)
(3130,4649,0)
(2088,4238,0)
(9041,7630,0)
(2244,7547,0)
(1854,6285,0)
(6304,1919,0)
(3142,5559,0)
(8607,5465,0)
(6972,4985,0)
(8886,4573,0)
(8440,5415,0)
(5519,3493,0)
(3137,7481,0)
(3892,5887,0)
(6433,3667,0)
(1850,7565,0)
(3339,4531,0)
(2202,4928,0)
(2266,8397,0)
(2965,1751,0)
(3558,7957,0)
(2967,6047,0)
(6262,4928,0)
(2772,4928,0)
(7847,7858,0)
(125,6254,0)
(6619,1439,0)
(571,223,0)
(5164,5656,0)
(3185,2459,0)
(7447,2791,0)
(4667,6900,0)
(4341,1556,0)
(488,4722,0)
(3218,8203,0)
(3799,525,0)
(4740,1502,0)
(6937,4299,0)
(8762,1502,0)
(3840,7450,0)
(6814,7118,0)
(1865,4013,0)
(8119,5016,0)
(1366,666,0)
(1397,7022,0)
(4203,5329,0)
(2767,5043,0)
(1549,1502,0)
(6931,7115,0)
(3227,7399,0)
(998,2384,0)
(5221,8148,0)
(3057,2055,0)
(6468,6939,0)
(5308,5228,0)
(4132,8298,0)
(807,1572,0)
(4545,4928,0)
(5717,7389,0)
(7294,3442,0)
(6744,6963,0)
(9085,1638,0)
(452,4544,0)
(8015,4719,0)
(7399,7273,0)
(9022,4943,0)
(2664,1502,0)
(3208,6501,0)
(2495,6275,0)
(3450,1782,0)
(678,7143,0)
(9100,4928,0)
(7696,2681,0)
(3955,5005,0)
(6593,1502,0)
(662,1861,0)
(7501,1126,0)
(3884,4928,0)
(2484,5974,0)
(7733,1825,0)
(2982,7323,0)
(4472,8188,0)
(3671,8939,0)
(4695,7468,0)
(1315,5975,0)
(1548,5161,0)
(3062,7179,0)
(6579,4372,0)
(597,6368,0)
(6582,8855,0)
(7737,8172,0)
(828,5354,0)
(4449,8475,0)
(8583,3120,0)
(3401,4928,0)
(4491,1502,0)
(5609,2207,0)
(2807,5646,0)
(7235,1346,0)
(688,7592,0)
(9090,6047,0)
(6976,4787,0)
(4695,3583,0)
(4218,2863,0)
(2491,1502,0)
(3931,5458,0)
(6929,5149,0)
(8046,6008,0)
(4187,852,0)
(2143,4512,0)
(3397,4297,0)
(4764,87,0)
(2347,73,0)
(5894,2290,0)
(9115,5856,0)
(5680,6626,0)
(7192,2567,0)
(9026,5559,0)
(3990,734,0)
(5864,2425,0)
(6304,8188,0)
(9155,5824,0)
(8156,607,0)
(7028,8890,0)
(4051,876,0)
(4926,4951,0)
(2699,840,0)
(1056,3258,0)
(704,8506,0)
(8254,5665,0)
(5312,5611,0)
(3077,1360,0)
(7251,8035,0)
(5273,7805,0)
(7887,304,0)
(1221,7476,0)
(648,4928,0)
(876,2507,0)
(8551,8809,0)
(2320,1591,0)
(4846,7148,0)
(3840,6218,0)
(7578,208,0)
(4214,1983,0)
(4443,3953,0)
(7995,3647,0)
(750,3226,0)
(6880,3340,0)
(1498,2492,0)
(2142,2798,0)
(4199,8627,0)
(4702,4928,0)
(7521,4220,0)
(4186,5929,0)
(1264,207,0)
(3486,4928,0)
(7503,7453,0)
(3862,5755,0)
(8361,5189,0)
(8925,4809,0)
(8053,6783,0)
(7276,2193,0)
(8230,5965,0)
(5272,9090,0)
(1678,6597,0)
(7774,2204,0)
(7062,4360,0)
(8515,538,0)
(568,7453,0)
(1717,4142,0)
(6048,4932,0)
(5635,5803,0)
(4328,370,0)
(6379,3623,0)
(1908,6111,0)
(2367,132,0)
(2920,3808,0)
(9150,3753,0)
(973,7096,0)
(738,4928,0)
(7652,4928,0)
(4457,7826,0)
(5294,9007,0)
(3988,2345,0)
(4279,8913,0)
(8203,3218,0)
(4704,750,0)
(4769,3935,0)
(6165,1157,0)
(2535,3282,0)
(1585,3465,0)
(7043,2212,0)
(5635,915,0)
(891,4928,0)
(8067,3272,0)
(5058,8948,0)
(6682,8688,0)
(8029,2802,0)
(5294,3017,0)
(7111,615,0)
(1022,9006,0)
(1904,4928,0)
(721,1502,0)
(4829,8027,0)
(8523,2253,0)
(3225,8189,0)
(5367,527,0)
(941,2705,0)
(7153,7227,0)
(8824,3263,0)
(6864,7397,0)
(6731,2440,0)
(5646,2495,0)
(6249,3171,0)
(5606,8888,0)
(1608,1042,0)
(471,5366,0)
(8370,748,0)
(6412,8334,0)
(8493,1444,0)
(7887,3247,0)
(3715,5883,0)
(9026,7148,0)
(1045,135,0)
(1758,7453,0)
(8332,7377,0)
(1411,3512,0)
(5188,7896,0)
(2236,428,0)
(4003,2950,0)
(6912,2041,0)
(5677,8454,0)
(6967,9129,0)
(4783,7746,0)
(123,4110,0)
(5462,6181,0)
(3040,65,0)
(6432,407,0)
(450,139,0)
(1124,3865,0)
(4075,5474,0)
(7515,8412,0)
(227,7138,0)
(7205,1410,0)
(5337,5569,0)
(4495,1556,0)
(239,8843,0)
(3804,1473,0)
(8506,704,0)
(792,956,0)
(7706,5698,0)
(2869,3674,0)
(4226,1472,0)
(2483,4612,0)
(9026,1489,0)
(5332,8171,0)
(2756,4147,0)
(3738,7453,0)
(3710,5531,0)
(936,6691,0)
(5925,1473,0)
(7522,5114,0)
(7864,4994,0)
(2766,3993,0)
(2441,3163,0)
(3305,4201,0)
(4493,2875,0)
(3412,75,0)
(2282,3370,0)
(1821,7453,0)
(6061,734,0)
(6314,6559,0)
(1905,8244,0)
(1268,1132,0)
(2094,4794,0)
(5353,3862,0)
(800,8915,0)
(2459,5902,0)
(7984,1887,0)
(2656,5803,0)
(7495,4642,0)
(4475,8094,0)
(638,4928,0)
(5455,3361,0)
(1635,6673,0)
(4422,8780,0)
(8885,4658,0)
(7829,7318,0)
(1811,7602,0)
(7773,4928,0)
(3553,1306,0)
(3499,8729,0)
(7801,3605,0)
(2465,6145,0)
(3422,658,0)
(3931,4561,0)
(860,1321,0)
(6804,1404,0)
(7196,4553,0)
(7984,5082,0)
(8421,8089,0)
(5483,4265,0)
(8364,2937,0)
(171,4612,0)
(8551,1064,0)
(5415,3294,0)
(8119,2071,0)
(858,8788,0)
(6441,7451,0)
(5739,3874,0)
(8007,8633,0)
(4789,7522,0)
(8352,9152,0)
(800,7873,0)
(8902,2114,0)
(8911,8627,0)
(5386,496,0)
(1378,5646,0)
(8123,8620,0)
(1673,509,0)
(3924,1032,0)
(5314,7603,0)
(6649,7155,0)
(3647,7995,0)
(3911,693,0)
(4074,6179,0)
(6283,2757,0)
(4788,7498,0)
(5423,2495,0)
(8735,8251,0)
(5685,4406,0)
(8685,5228,0)
(1189,4293,0)
(4819,956,0)
(1593,4928,0)
(3134,1646,0)
(2969,1502,0)
(4916,642,0)
(1924,5511,0)
(6201,7485,0)
(1828,7468,0)
(6652,4524,0)
(9053,2492,0)
(6347,6089,0)
(7314,1620,0)
(8375,2015,0)
(2734,3280,0)
(622,1690,0)
(3837,4928,0)
(1625,4270,0)
(1680,740,0)
(3982,1955,0)
(1445,6589,0)
(859,6640,0)
(6569,1502,0)
(5577,538,0)
(3280,2734,0)
(3465,1585,0)
(7372,5846,0)
(3992,6296,0)
(825,3790,0)
(2203,5270,0)
(5864,6216,0)
(5025,5862,0)
(1009,79,0)
(3440,4615,0)
(1800,1502,0)
(8728,7468,0)
(6058,7628,0)
(7991,598,0)
(7046,7969,0)
(4972,8928,0)
(3250,1502,0)
(6007,361,0)
(9145,4928,0)
(4650,1133,0)
(279,6323,0)
(3569,9155,0)
(712,3313,0)
(5086,4518,0)
(1651,5426,0)
(4408,6748,0)
(4688,6509,0)
(1503,943,0)
(4905,3236,0)
(4236,8497,0)
(835,7308,0)
(7198,8829,0)
(4005,4124,0)
(4064,4765,0)
(9126,6034,0)
(966,4503,0)
(2312,1721,0)
(4450,1079,0)
(2181,1476,0)
(5875,3382,0)
(3302,7092,0)
(4250,3035,0)
(3190,1502,0)
(8568,1842,0)
(90,4738,0)
(5381,1516,0)
(7977,919,0)
(8205,5043,0)
(3629,6693,0)
(7685,1502,0)
(7275,5758,0)
(1039,2152,0)
(4737,933,0)
(5980,5465,0)
(7174,3605,0)
(6392,1711,0)
(3367,9042,0)
(1620,4928,0)
(3774,5923,0)
(5633,3818,0)
(6896,688,0)
(4344,6560,0)
(1880,7096,0)
(3085,3429,0)
(3500,4928,0)
(6967,6953,0)
(1863,2114,0)
(5375,4199,0)
(3449,8944,0)
(6613,7173,0)
(8071,5728,0)
(3207,4524,0)
(3490,4601,0)
(9083,4928,0)
(296,4874,0)
(6616,6883,0)
(6498,8767,0)
(1143,890,0)
(286,7477,0)
(3293,6930,0)
(6051,7,0)
(3830,1363,0)
(2491,4928,0)
(1217,4206,0)
(6925,3230,0)
(1316,8634,0)
(1006,7004,0)
(9049,9020,0)
(8149,6771,0)
(2626,8132,0)
(6949,4928,0)
(5294,742,0)
(189,8938,0)
(3135,6434,0)
(7651,1502,0)
(8598,6413,0)
(4875,140,0)
(8953,998,0)
(1368,806,0)
(3269,6775,0)
(6150,2874,0)
(3935,4769,0)
(2700,3282,0)
(8341,3581,0)
(6540,4602,0)
(7452,9033,0)
(2801,6205,0)
(1495,6731,0)
(2865,7453,0)
(3168,9017,0)
(7830,5778,0)
(890,1502,0)
(2583,595,0)
(7077,761,0)
(79,1009,0)
(5656,984,0)
(7687,3857,0)
(3681,1502,0)
(1323,197,0)
(8037,9023,0)
(6510,1502,0)
(6487,8463,0)
(2650,7948,0)
(1037,6102,0)
(5289,2159,0)
(7490,5480,0)
(5904,4392,0)
(6304,4030,0)
(7468,2893,0)
(7918,5306,0)
(3260,2673,0)
(6216,423,0)
(4313,4846,0)
(4572,4551,0)
(3964,4177,0)
(8905,7662,0)
(2520,5269,0)
(6514,6241,0)
(7479,2686,0)
(8829,3496,0)
(6757,2898,0)
(4825,4227,0)
(940,5100,0)
(7624,7763,0)
(6676,5896,0)
(3433,4928,0)
(8491,3911,0)
(8504,7763,0)
(8243,2787,0)
(5294,4853,0)
(3228,2243,0)
(7066,7453,0)
(4751,7055,0)
(7163,7558,0)
(4155,68,0)
(7250,1502,0)
(7186,7900,0)
(5877,5128,0)
(3867,6367,0)
(4069,8659,0)
(1489,6325,0)
(3411,8678,0)
(434,2301,0)
(2779,7005,0)
(8090,4386,0)
(7263,8136,0)
(3618,4928,0)
(4532,5608,0)
(2803,5416,0)
(133,7366,0)
(4452,1502,0)
(8228,1884,0)
(5184,5497,0)
(8636,1502,0)
(3838,4928,0)
(8721,8830,0)
(8786,5875,0)
(8766,7501,0)
(119,5855,0)
(2839,4928,0)
(3966,8940,0)
(1280,3979,0)
(5294,3488,0)
(647,7091,0)
(4153,8698,0)
(969,6905,0)
(4985,46,0)
(7833,7717,0)
(4790,8633,0)
(717,4687,0)
(5476,1828,0)
(5294,6465,0)
(8289,1502,0)
(4293,4928,0)
(1690,1502,0)
(6304,1228,0)
(2532,5833,0)
(2854,5265,0)
(2734,7778,0)
(7991,3313,0)
(2291,770,0)
(1497,8975,0)
(8543,5944,0)
(8237,6567,0)
(4188,6696,0)
(3915,4390,0)
(7634,817,0)
(3433,1321,0)
(2822,1005,0)
(3330,6047,0)
(451,8805,0)
(6398,1441,0)
(4424,1821,0)
(7623,2898,0)
(311,1249,0)
(2975,4320,0)
(5718,1502,0)
(6711,3428,0)
(492,1152,0)
(3302,5559,0)
(326,3727,0)
(7178,1690,0)
(4753,7317,0)
(229,2384,0)
(3109,858,0)
(1760,6479,0)
(8037,4524,0)
(1752,7651,0)
(3829,4845,0)
(5127,606,0)
(7529,1502,0)
(1476,4928,0)
(3522,7214,0)
(8008,3720,0)
(2320,8188,0)
(9021,4371,0)
(1132,4928,0)
(1605,5042,0)
(4060,1825,0)
(5759,1155,0)
(7183,5341,0)
(318,838,0)
(8162,240,0)
(7000,6539,0)
(839,5785,0)
(3971,1502,0)
(2265,8778,0)
(7057,5531,0)
(6721,8217,0)
(176,1502,0)
(1663,4386,0)
(522,9089,0)
(299,4049,0)
(8433,2142,0)
(8134,4013,0)
(4703,9029,0)
(4122,8632,0)
(5497,2974,0)
(8812,3486,0)
(8973,6047,0)
(2951,6187,0)
(1996,7371,0)
(5818,8394,0)
(7720,5957,0)
(8089,8421,0)
(1449,2073,0)
(1557,5642,0)
(929,1380,0)
(5165,7932,0)
(5294,2039,0)
(2791,3399,0)
(8173,7005,0)
(8210,6423,0)
(7125,183,0)
(8273,7453,0)
(305,8863,0)
(7376,1611,0)
(7135,2299,0)
(7636,6842,0)
(4289,5310,0)
(14,5218,0)
(1768,4385,0)
(6666,577,0)
(3546,2349,0)
(7366,1402,0)
(3400,7453,0)
(383,1222,0)
(1529,2638,0)
(2397,3378,0)
(9072,5207,0)
(2034,5162,0)
(4570,268,0)
(6466,1064,0)
(6938,7575,0)
(5032,5356,0)
(765,1463,0)
(504,1591,0)
(4473,803,0)
(4542,7411,0)
(6304,7148,0)
(8906,7223,0)
(6116,8584,0)
(5614,9116,0)
(3855,5067,0)
(646,6032,0)
(3431,1955,0)
(1412,7403,0)
(1873,2779,0)
(9065,1502,0)
(287,5343,0)
(4337,7760,0)
(3124,7548,0)
(7520,6987,0)
(5536,1392,0)
(1982,143,0)
(4207,4140,0)
(2425,5234,0)
(5448,5727,0)
(6753,4953,0)
(3718,5213,0)
(7762,4682,0)
(3828,1823,0)
(900,2974,0)
(9088,5817,0)
(1941,7326,0)
(8073,1974,0)
(8808,6826,0)
(3363,7557,0)
(2995,4177,0)
(6774,5085,0)
(8107,3136,0)
(5392,961,0)
(8516,8297,0)
(6003,4928,0)
(3605,7174,0)
(956,5329,0)
(4247,4928,0)
(4846,1489,0)
(1326,4794,0)
(11,5383,0)
(6890,2219,0)
(4081,719,0)
(6263,4064,0)
(1627,2080,0)
(5658,5030,0)
(984,4954,0)
(3489,6645,0)
(4437,2894,0)
(2227,257,0)
(6,8083,0)
(5651,6746,0)
(148,4174,0)
(5294,1928,0)
(8928,1638,0)
(4679,8481,0)
(5614,4747,0)
(4163,5065,0)
(4847,6238,0)
(7428,4923,0)
(8962,7642,0)
(6368,5914,0)
(2491,6047,0)
(8728,4220,0)
(3837,4142,0)
(2356,3161,0)
(6937,499,0)
(43,7948,0)
(5241,748,0)
(6967,6254,0)
(6782,334,0)
(2041,1250,0)
(7529,3247,0)
(9087,7685,0)
(3720,8008,0)
(7468,5559,0)
(5835,1575,0)
(4029,1251,0)
(4973,6390,0)
(6083,7453,0)
(4379,3796,0)
(3541,882,0)
(2156,2340,0)
(8881,3464,0)
(9006,186,0)
(2453,924,0)
(4870,8047,0)
(5649,2953,0)
(3500,6738,0)
(4886,1473,0)
(4096,1451,0)
(3647,5043,0)
(5722,3202,0)
(8459,251,0)
(1068,384,0)
(8676,3137,0)
(104,9126,0)
(1013,5510,0)
(4259,346,0)
(5075,1502,0)
(4517,4928,0)
(75,7413,0)
(6151,9043,0)
(8962,2747,0)
(4900,8283,0)
(3281,3975,0)
(5176,2898,0)
(3700,4874,0)
(5172,7308,0)
(5975,8273,0)
(265,2999,0)
(5660,3564,0)
(5655,4612,0)
(4822,6300,0)
(459,2828,0)
(905,1423,0)
(3006,7435,0)
(5294,4551,0)
(3654,7390,0)
(9049,7919,0)
(924,2453,0)
(73,2347,0)
(1976,1338,0)
(712,8188,0)
(606,6316,0)
(4147,806,0)
(5646,1567,0)
(6559,6314,0)
(297,7091,0)
(3510,6119,0)
(6569,6047,0)
(5294,2113,0)
(4568,1923,0)
(3901,621,0)
(853,7143,0)
(4665,5340,0)
(316,1848,0)
(3936,4851,0)
(3275,1659,0)
(5013,2466,0)
(5978,2420,0)
(4871,5043,0)
(8021,943,0)
(1375,2271,0)
(7717,7833,0)
(1238,1246,0)
(4721,7155,0)
(5181,6640,0)
(4039,1205,0)
(3686,3596,0)
(8587,6299,0)
(4266,3532,0)
(9028,526,0)
(7024,8288,0)
(5905,6365,0)
(1166,9142,0)
(5403,7934,0)
(8144,1141,0)
(5293,2847,0)
(3337,3942,0)
(3423,8834,0)
(4806,7453,0)
(2564,1409,0)
(337,8451,0)
(1887,4826,0)
(607,4404,0)
(5976,7994,0)
(5380,1448,0)
(2320,598,0)
(2320,5115,0)
(1693,6145,0)
(7516,8779,0)
(6502,5389,0)
(293,8843,0)
(7896,4928,0)
(4076,6431,0)
(5629,3645,0)
(7822,8994,0)
(2576,554,0)
(4149,7479,0)
(8919,1278,0)
(2844,5902,0)
(5665,3307,0)
(1575,5835,0)
(925,8241,0)
(8811,3612,0)
(7137,7161,0)
(958,5159,0)
(2806,8288,0)
(302,3886,0)
(7808,4141,0)
(801,2196,0)
(1888,5528,0)
(3364,7453,0)
(6304,7141,0)
(8711,693,0)
(2644,5311,0)
(4825,350,0)
(8547,1231,0)
(2494,1502,0)
(5753,4928,0)
(5110,2464,0)
(7929,4601,0)
(4464,3270,0)
(2348,5803,0)
(6799,6790,0)
(1574,6488,0)
(3342,1502,0)
(3663,6392,0)
(5303,7535,0)
(406,3193,0)
(1274,6222,0)
(7138,3429,0)
(9121,6682,0)
(2558,1543,0)
(8343,4258,0)
(6956,3153,0)
(4827,3698,0)
(3321,2275,0)
(2675,2969,0)
(570,3730,0)
(330,6826,0)
(2635,5709,0)
(8086,7438,0)
(60,6010,0)
(6846,372,0)
(6196,5077,0)
(3430,1502,0)
(2711,7453,0)
(7853,9118,0)
(1007,1726,0)
(3997,578,0)
(2952,8891,0)
(3184,4928,0)
(6423,2686,0)
(262,5398,0)
(7455,6713,0)
(3343,8012,0)
(5216,342,0)
(6269,1800,0)
(3222,993,0)
(114,1646,0)
(1263,3457,0)
(6170,266,0)
(2502,968,0)
(161,3430,0)
(6075,2776,0)
(3500,1502,0)
(384,5389,0)
(393,334,0)
(7610,1502,0)
(8621,6939,0)
(6207,5493,0)
(6618,4063,0)
(4645,6060,0)
(1201,4775,0)
(5540,315,0)
(9003,4523,0)
(2414,4674,0)
(778,4742,0)
(4808,3158,0)
(4600,6277,0)
(7333,1174,0)
(8639,398,0)
(1402,1502,0)
(4793,3063,0)
(5754,1973,0)
(4197,4985,0)
(5075,7468,0)
(4574,3973,0)
(2576,2544,0)
(327,1142,0)
(372,5043,0)
(91,6288,0)
(3141,44,0)
(1652,1221,0)
(5688,5737,0)
(7191,8120,0)
(3199,9073,0)
(3259,2392,0)
(773,4953,0)
(1070,6930,0)
(4145,1817,0)
(1428,2071,0)
(2329,1077,0)
(2216,7063,0)
(3819,3583,0)
(4252,8282,0)
(4242,1852,0)
(8060,4790,0)
(2797,6748,0)
(5582,2653,0)
(1689,8361,0)
(5242,3740,0)
(794,1248,0)
(8302,7308,0)
(1988,5042,0)
(6627,7688,0)
(2381,814,0)
(4790,8060,0)
(6541,5616,0)
(5316,4871,0)
(27,6569,0)
(8385,7479,0)
(7226,5927,0)
(5383,5625,0)
(7093,7594,0)
(5892,1975,0)
(8214,4739,0)
(4298,7566,0)
(1768,1791,0)
(1554,4397,0)
(521,4928,0)
(4191,7097,0)
(1127,7223,0)
(517,8224,0)
(8720,7209,0)
(99,7624,0)
(4094,1577,0)
(5983,2747,0)
(8521,2602,0)
(5102,8989,0)
(2039,6527,0)
(5218,8843,0)
(4234,1003,0)
(7468,8678,0)
(790,8437,0)
(4061,1609,0)
(7237,6507,0)
(3899,755,0)
(4064,5830,0)
(2077,2812,0)
(146,7535,0)
(95,6073,0)
(4074,1502,0)
(7008,3677,0)
(2965,6500,0)
(4736,6390,0)
(1686,1328,0)
(2793,4095,0)
(4048,5994,0)
(5150,7453,0)
(7936,3839,0)
(3169,6413,0)
(1228,7468,0)
(7639,2050,0)
(3961,6527,0)
(8100,398,0)
(7134,2505,0)
(5076,8475,0)
(9048,1056,0)
(4332,6047,0)
(2942,4928,0)
(4437,3313,0)
(8675,7587,0)
(8576,8864,0)
(2801,8217,0)
(2055,6047,0)
(4642,1353,0)
(7468,7092,0)
(1282,3993,0)
(6144,2835,0)
(2351,1632,0)
(606,8940,0)
(7438,6300,0)
(1885,4826,0)
(5288,4860,0)
(5036,5861,0)
(4657,1958,0)
(1026,4928,0)
(8940,5855,0)
(2194,6693,0)
(2409,190,0)
(2360,7077,0)
(5294,3381,0)
(5513,621,0)
(1075,7760,0)
(7970,89,0)
(1611,7656,0)
(3240,3008,0)
(2079,4490,0)
(2103,777,0)
(1945,645,0)
(6271,1270,0)
(6856,5177,0)
(1966,8765,0)
(8770,4238,0)
(7577,3085,0)
(1600,4967,0)
(8638,1139,0)
(2906,4942,0)
(8484,4539,0)
(4604,8561,0)
(4572,7148,0)
(5932,7674,0)
(4437,5115,0)
(5684,8776,0)
(8945,4928,0)
(7096,5159,0)
(2554,2737,0)
(578,2054,0)
(1679,2575,0)
(4243,1958,0)
(650,3105,0)
(7046,2894,0)
(2369,6672,0)
(964,6697,0)
(6031,3491,0)
(5294,408,0)
(5416,7813,0)
(3930,263,0)
(5237,2725,0)
(8673,1348,0)
(211,3633,0)
(6367,8083,0)
(1246,997,0)
(5282,881,0)
(2178,4928,0)
(1807,6005,0)
(4478,8289,0)
(1959,5387,0)
(693,4928,0)
(8798,487,0)
(2990,1954,0)
(7545,4352,0)
(5203,898,0)
(3126,8382,0)
(831,7017,0)
(4217,5454,0)
(1844,606,0)
(1515,4013,0)
(7719,697,0)
(4768,3616,0)
(747,6137,0)
(4261,9145,0)
(1988,2893,0)
(59,3112,0)
(500,1538,0)
(3270,3673,0)
(586,5686,0)
(3071,1199,0)
(5601,2189,0)
(8252,8487,0)
(8829,8037,0)
(577,8950,0)
(8932,5078,0)
(545,4404,0)
(4079,3489,0)
(2865,6702,0)
(1152,8283,0)
(4470,5858,0)
(2681,8482,0)
(8970,3183,0)
(635,933,0)
(3527,7628,0)
(7653,4148,0)
(869,1591,0)
(6570,3134,0)
(242,1213,0)
(1276,4409,0)
(4517,4688,0)
(7082,3694,0)
(1091,5340,0)
(1339,7034,0)
(8960,6431,0)
(157,1545,0)
(6963,6744,0)
(306,1026,0)
(4147,3280,0)
(762,297,0)
(6696,4445,0)
(6238,4847,0)
(6252,491,0)
(4427,2008,0)
(8061,4176,0)
(7571,7670,0)
(9031,4928,0)
(6974,4928,0)
(6462,6195,0)
(9089,7873,0)
(6894,9040,0)
(569,5111,0)
(6177,1244,0)
(4074,3530,0)
(4623,5030,0)
(3181,2749,0)
(4224,7124,0)
(5613,2803,0)
(5104,4996,0)
(5539,259,0)
(4006,5359,0)
(2276,6530,0)
(2068,2586,0)
(5211,1027,0)
(3315,3992,0)
(2840,5497,0)
(3855,1502,0)
(3151,9072,0)
(7571,5200,0)
(4527,6474,0)
(3648,1156,0)
(1026,1502,0)
(1605,9108,0)
(6674,1516,0)
(1420,5484,0)
(6121,8022,0)
(3324,2380,0)
(4332,6244,0)
(9028,5750,0)
(5072,3440,0)
(1708,1502,0)
(5966,1675,0)
(423,6216,0)
(1267,6739,0)
(643,8476,0)
(6644,2246,0)
(129,8560,0)
(3114,607,0)
(1137,4531,0)
(2443,4928,0)
(2605,2537,0)
(5709,2635,0)
(7311,5902,0)
(8271,1394,0)
(6342,1654,0)
(4065,1502,0)
(7468,8831,0)
(7946,4190,0)
(8199,4928,0)
(7646,860,0)
(420,1945,0)
(1526,3800,0)
(7751,719,0)
(272,9020,0)
(2357,9052,0)
(7216,6637,0)
(154,3087,0)
(6949,1502,0)
(492,4928,0)
(2962,3808,0)
(3386,7890,0)
(1893,4491,0)
(2869,1591,0)
(8071,1502,0)
(7508,6272,0)
(6350,4794,0)
(6043,2792,0)
(1969,7373,0)
(3272,2792,0)
(8470,2049,0)
(876,4892,0)
(4001,2760,0)
(5654,3482,0)
(1671,394,0)
(4623,87,0)
(4657,4928,0)
(238,1832,0)
(1334,6047,0)
(5400,1538,0)
(8385,8178,0)
(6382,8620,0)
(9109,8806,0)
(1538,500,0)
(3866,5127,0)
(5718,8348,0)
(6318,1156,0)
(3327,1502,0)
(2036,7403,0)
(8153,2664,0)
(1733,4259,0)
(825,4843,0)
(13,1387,0)
(1855,7892,0)
(757,8806,0)
(5797,1085,0)
(2037,5769,0)
(3372,6343,0)
(7739,7453,0)
(1861,1405,0)
(3065,9033,0)
(611,1502,0)
(7258,4183,0)
(8204,8063,0)
(6915,3786,0)
(5177,2806,0)
(4964,6938,0)
(5048,2391,0)
(6500,2965,0)
(6785,2898,0)
(1298,1502,0)
(4932,841,0)
(7790,5902,0)
(1321,860,0)
(4263,2572,0)
(4876,5636,0)
(112,5268,0)
(2607,8892,0)
(3430,4928,0)
(2013,4928,0)
(2011,8083,0)
(6399,332,0)
(359,6105,0)
(233,8469,0)
(876,8283,0)
(8253,2117,0)
(3750,8071,0)
(3273,6389,0)
(2308,615,0)
(4129,519,0)
(5710,7951,0)
(7584,7453,0)
(5209,9133,0)
(1170,4746,0)
(1284,2773,0)
(8759,8550,0)
(8064,2221,0)
(7469,3352,0)
(1755,1502,0)
(5831,8555,0)
(8132,1358,0)
(7160,3101,0)
(8349,373,0)
(8333,5387,0)
(504,932,0)
(791,1751,0)
(9148,4928,0)
(7369,2771,0)
(751,7724,0)
(4550,1625,0)
(5952,5954,0)
(2786,2032,0)
(8541,1502,0)
(4082,5341,0)
(9016,279,0)
(7324,5217,0)
(228,4920,0)
(5,9008,0)
(8976,8862,0)
(8788,6852,0)
(9095,569,0)
(4447,364,0)
(8619,5646,0)
(1489,3921,0)
(3896,7186,0)
(7993,579,0)
(2529,7875,0)
(7494,1335,0)
(1887,7984,0)
(4124,4005,0)
(2875,4493,0)
(7331,4013,0)
(253,7561,0)
(222,4862,0)
(3933,3958,0)
(4754,5408,0)
(3583,6027,0)
(5973,8425,0)
(5686,5043,0)
(8464,1502,0)
(8227,1642,0)
(7479,3617,0)
(2162,7887,0)
(4784,1557,0)
(8297,432,0)
(8095,6094,0)
(4280,4928,0)
(2040,4807,0)
(8312,1397,0)
(6233,5273,0)
(8606,8743,0)
(2656,5249,0)
(6713,6405,0)
(7544,7057,0)
(4914,630,0)
(6834,455,0)
(1226,1093,0)
(3160,287,0)
(2586,713,0)
(7348,5098,0)
(9037,1128,0)
(5294,3968,0)
(1185,5826,0)
(476,4480,0)
(3385,1502,0)
(9037,8009,0)
(2724,3350,0)
(3265,1548,0)
(769,1928,0)
(7617,3352,0)
(7548,4742,0)
(6845,2637,0)
(3949,390,0)
(8510,5469,0)
(7079,2838,0)
(6594,5266,0)
(6564,321,0)
(3428,6711,0)
(7553,7994,0)
(3578,4680,0)
(7365,5346,0)
(2323,5216,0)
(6897,4893,0)
(3486,7439,0)
(6393,1726,0)
(7805,5273,0)
(301,5856,0)
(3137,2630,0)
(2869,7100,0)
(5947,5214,0)
(4640,4928,0)
(3947,1836,0)
(8010,1960,0)
(2514,8497,0)
(3376,4928,0)
(463,6748,0)
(6475,6325,0)
(3265,5043,0)
(5645,8427,0)
(182,7004,0)
(7327,7921,0)
(224,5698,0)
(2534,5977,0)
(6847,3791,0)
(6874,17,0)
(6282,5359,0)
(8172,1482,0)
(8829,8188,0)
(8207,5625,0)
(2835,4928,0)
(8310,119,0)
(3092,1763,0)
(5465,4979,0)
(4313,2320,0)
(8303,8385,0)
(6786,5043,0)
(3650,412,0)
(8893,4475,0)
(6833,4065,0)
(348,5646,0)
(3399,5902,0)
(1819,3362,0)
(1067,1502,0)
(1691,2153,0)
(4385,1768,0)
(7724,2721,0)
(5048,2806,0)
(4994,8803,0)
(559,1502,0)
(7706,2494,0)
(810,1928,0)
(3626,3462,0)
(2446,3776,0)
(7269,6790,0)
(5662,8667,0)
(952,5895,0)
(1761,2410,0)
(4437,1919,0)
(6304,5115,0)
(8756,8395,0)
(972,1502,0)
(5686,8841,0)
(6702,3583,0)
(890,6047,0)
(5188,7838,0)
(4883,6518,0)
(8251,4928,0)
(897,8227,0)
(5294,5573,0)
(7046,7092,0)
(3462,87,0)
(2450,7853,0)
(7406,2860,0)
(4437,7100,0)
(3438,7192,0)
(6991,4106,0)
(79,182,0)
(2767,2050,0)
(8734,6003,0)
(3093,598,0)
(5291,8299,0)
(8757,1201,0)
(2693,4341,0)
(3886,7247,0)
(4322,1786,0)
(6485,135,0)
(8194,258,0)
(5404,4455,0)
(2973,3779,0)
(585,6817,0)
(1409,2564,0)
(2783,463,0)
(1602,8189,0)
(2227,7453,0)
(1500,6709,0)
(8408,4928,0)
(8626,7533,0)
(216,5486,0)
(8189,3225,0)
(6180,4542,0)
(6670,2473,0)
(5944,1549,0)
(519,829,0)
(7142,5141,0)
(7821,8759,0)
(2814,3470,0)
(5424,1905,0)
(2567,1440,0)
(3270,1469,0)
(2943,2001,0)
(698,7688,0)
(5497,2840,0)
(8790,4851,0)
(3657,7472,0)
(2916,7896,0)
(8844,8843,0)
(3950,7453,0)
(3456,1502,0)
(1862,2242,0)
(2685,4499,0)
(4577,6489,0)
(2690,1316,0)
(6792,997,0)
(5698,7706,0)
(2869,8037,0)
(4305,4670,0)
(984,4299,0)
(2028,2325,0)
(5266,1915,0)
(7478,7688,0)
(2320,4551,0)
(8494,838,0)
(3571,2378,0)
(1892,1515,0)
(3566,4635,0)
(4970,8757,0)
(625,3472,0)
(8199,6047,0)
(2984,7943,0)
(2606,3870,0)
(1067,4928,0)
(6718,3603,0)
(5230,4015,0)
(1157,3941,0)
(3570,7362,0)
(8274,7453,0)
(3078,8280,0)
(3420,6047,0)
(3587,5199,0)
(7843,5211,0)
(7991,5115,0)
(9117,2149,0)
(3942,1502,0)
(7425,332,0)
(7824,6289,0)
(2011,3670,0)
(3770,4049,0)
(7269,7590,0)
(5285,4841,0)
(2024,4928,0)
(2758,9105,0)
(4888,2124,0)
(6597,2358,0)
(8984,4131,0)
(325,3818,0)
(6219,4880,0)
(7283,1756,0)
(3943,6187,0)
(2589,4095,0)
(8973,7625,0)
(8458,2997,0)
(62,1679,0)
(2279,3771,0)
(3648,7625,0)
(4980,5702,0)
(8780,6431,0)
(8698,4928,0)
(6787,1628,0)
(7967,7762,0)
(209,1502,0)
(7626,2823,0)
(8000,3430,0)
(3618,1502,0)
(176,557,0)
(3990,5928,0)
(8549,167,0)
(9015,7017,0)
(3613,797,0)
(7582,7521,0)
(8829,598,0)
(7180,4658,0)
(5687,4013,0)
(6140,2392,0)
(3958,8360,0)
(866,4168,0)
(4642,3680,0)
(1564,1341,0)
(8754,6392,0)
(6346,4106,0)
(5214,7854,0)
(1106,2016,0)
(4059,8805,0)
(7422,50,0)
(6646,2829,0)
(8725,6434,0)
(3985,6090,0)
(6813,3282,0)
(2952,1796,0)
(8415,1650,0)
(1922,1925,0)
(1480,1507,0)
(6661,1593,0)
(5623,7468,0)
(957,4576,0)
(2320,6560,0)
(6244,4332,0)
(4179,8330,0)
(4472,6754,0)
(3135,4851,0)
(6066,2015,0)
(8999,7458,0)
(4193,3688,0)
(3698,3083,0)
(8489,1081,0)
(2568,1502,0)
(2851,135,0)
(8536,6324,0)
(7358,2060,0)
(4991,4252,0)
(7064,3716,0)
(5737,8476,0)
(5872,9122,0)
(876,8934,0)
(8700,4724,0)
(9042,5043,0)
(7745,2907,0)
(4877,7393,0)
(2771,2686,0)
(799,4655,0)
(5617,1685,0)
(8520,1502,0)
(6148,6047,0)
(6842,3457,0)
(6359,2801,0)
(2570,5754,0)
(2602,4928,0)
(3405,7022,0)
(5254,1040,0)
(640,4779,0)
(7484,4676,0)
(7389,5717,0)
(634,1567,0)
(4035,7681,0)
(900,3248,0)
(5057,2118,0)
(8515,236,0)
(3847,1471,0)
(3343,4928,0)
(1823,1502,0)
(3342,4928,0)
(2230,4384,0)
(1469,3270,0)
(3445,1152,0)
(7190,6830,0)
(3550,1502,0)
(3481,1763,0)
(8510,5268,0)
(2151,2925,0)
(1539,6047,0)
(5134,2055,0)
(8945,1502,0)
(5493,6207,0)
(8425,5973,0)
(4318,2305,0)
(487,315,0)
(8850,1502,0)
(4080,7453,0)
(1945,1502,0)
(3230,6925,0)
(6199,8429,0)
(4661,6888,0)
(3018,6928,0)
(8628,5191,0)
(5226,4778,0)
(32,1502,0)
(8635,4735,0)
(3148,2656,0)
(5426,1651,0)
(9071,4523,0)
(6630,8748,0)
(3718,1716,0)
(9117,8448,0)
(5811,4845,0)
(5017,9102,0)
(2877,1218,0)
(7655,8043,0)
(20,2664,0)
(7067,1110,0)
(3542,7453,0)
(9047,373,0)
(3394,387,0)
(3699,8765,0)
(7910,1502,0)
(9073,3199,0)
(108,4354,0)
(9080,46,0)
(362,4928,0)
(781,6510,0)
(3724,7261,0)
(8623,5435,0)
(814,2057,0)
(6711,3530,0)
(7121,5455,0)
(5071,1502,0)
(5346,8519,0)
(7736,406,0)
(816,8255,0)
(1336,7387,0)
(3111,44,0)
(7886,8199,0)
(754,8348,0)
(1348,4420,0)
(2262,5043,0)
(4271,6329,0)
(1639,998,0)
(448,8667,0)
(1308,3224,0)
(6782,8072,0)
(992,2109,0)
(2100,7481,0)
(6747,2865,0)
(1225,1004,0)
(6402,4208,0)
(8518,1832,0)
(5783,7119,0)
(4787,4928,0)
(6946,7773,0)
(2548,1515,0)
(8189,2852,0)
(6182,8129,0)
(4558,3190,0)
(4455,4016,0)
(8255,4415,0)
(906,5234,0)
(7622,1936,0)
(3902,8767,0)
(4363,6262,0)
(5083,7618,0)
(6709,8362,0)
(6290,1558,0)
(3807,9065,0)
(5041,6249,0)
(6687,4095,0)
(1873,3251,0)
(8259,7955,0)
(5080,5794,0)
(4123,6119,0)
(948,5777,0)
(4044,1067,0)
(1882,1946,0)
(4313,9037,0)
(7083,1366,0)
(2377,8336,0)
(8244,1905,0)
(2491,4392,0)
(1465,2973,0)
(4293,1502,0)
(8910,7160,0)
(5187,1311,0)
(1299,2558,0)
(3172,856,0)
(4047,1087,0)
(1267,8060,0)
(6118,1928,0)
(64,1216,0)
(4637,1291,0)
(8877,8876,0)
(5552,1157,0)
(5138,7453,0)
(4814,4928,0)
(6964,1062,0)
(5743,8273,0)
(273,2656,0)
(8329,4744,0)
(97,8498,0)
(573,3776,0)
(7896,5188,0)
(6406,692,0)
(8948,1801,0)
(4817,6818,0)
(8700,5248,0)
(7711,3550,0)
(2839,3172,0)
(303,806,0)
(2363,8482,0)
(1033,6047,0)
(1184,9133,0)
(4313,3302,0)
(2644,3229,0)
(1446,6047,0)
(4972,5517,0)
(1468,1380,0)
(3411,1121,0)
(1598,1502,0)
(9037,5115,0)
(1360,4928,0)
(1417,7367,0)
(7339,8671,0)
(2725,7337,0)
(7030,4928,0)
(4437,6988,0)
(2773,1284,0)
(5567,2898,0)
(4244,7453,0)
(2619,1755,0)
(4048,334,0)
(8829,742,0)
(6525,6094,0)
(7274,638,0)
(7302,1708,0)
(4118,3776,0)
(812,6246,0)
(2330,4676,0)
(5923,1502,0)
(8614,3652,0)
(189,4687,0)
(4230,5359,0)
(8385,1161,0)
(6348,6047,0)
(8436,8360,0)
(3835,2697,0)
(4953,4928,0)
(8057,1451,0)
(7442,6786,0)
(1760,5043,0)
(7035,4067,0)
(665,6558,0)
(3406,4339,0)
(6304,2703,0)
(6394,3420,0)
(3794,5915,0)
(4093,1392,0)
(6127,5504,0)
(2128,2334,0)
(3051,3826,0)
(5210,802,0)
(8446,6802,0)
(5113,1502,0)
(7957,8449,0)
(1177,662,0)
(3239,279,0)
(7912,5200,0)
(2809,3346,0)
(1725,8411,0)
(2757,3399,0)
(5472,6620,0)
(3025,4943,0)
(6075,5902,0)
(4437,9075,0)
(1205,4239,0)
(1946,1882,0)
(4935,400,0)
(2042,2129,0)
(3129,2363,0)
(2823,8284,0)
(55,4928,0)
(3365,4928,0)
(1227,956,0)
(2661,1248,0)
(2578,2748,0)
(3265,3086,0)
(2224,6506,0)
(5675,1545,0)
(8140,4928,0)
(3194,6792,0)
(6775,7936,0)
(4833,4744,0)
(6700,6234,0)
(197,1323,0)
(4228,4590,0)
(3239,1502,0)
(5709,1502,0)
(524,4631,0)
(372,5902,0)
(3690,8288,0)
(3225,7894,0)
(644,673,0)
(4997,6510,0)
(2753,9122,0)
(556,3825,0)
(350,4825,0)
(2504,7194,0)
(2937,1502,0)
(7019,9124,0)
(3880,1199,0)
(1815,4426,0)
(1043,6047,0)
(3877,5939,0)
(8667,5662,0)
(7357,4840,0)
(4747,3915,0)
(3202,8675,0)
(8915,800,0)
(10,4296,0)
(541,1341,0)
(6431,2253,0)
(6262,6611,0)
(1668,8060,0)
(8045,5637,0)
(4393,5127,0)
(2187,7904,0)
(6358,8362,0)
(6240,7686,0)
(2961,3158,0)
(1988,8188,0)
(6797,7453,0)
(8439,5623,0)
(25,8865,0)
(1669,2404,0)
(5982,4025,0)
(3636,8324,0)
(7076,1502,0)
(8052,4271,0)
(5646,9058,0)
(4067,7773,0)
(944,3532,0)
(7991,2113,0)
(7618,4928,0)
(5625,4432,0)
(791,1726,0)
(3355,5075,0)
(5025,8278,0)
(3670,4335,0)
(3644,2806,0)
(9145,1502,0)
(6304,908,0)
(4049,3770,0)
(8365,3757,0)
(7366,7453,0)
(6220,6368,0)
(8058,6084,0)
(2299,1502,0)
(4434,5556,0)
(7390,2653,0)
(712,1128,0)
(405,4851,0)
(7156,1410,0)
(4383,132,0)
(974,8990,0)
(6204,702,0)
(4402,669,0)
(1125,2530,0)
(7499,1974,0)
(2498,6010,0)
(828,6038,0)
(7765,6842,0)
(202,8843,0)
(8822,7677,0)
(5296,8486,0)
(9092,7221,0)
(8091,4297,0)
(4414,4437,0)
(1219,1829,0)
(8125,7894,0)
(3816,1760,0)
(5643,4013,0)
(936,2106,0)
(7318,7829,0)
(4884,4007,0)
(2611,5043,0)
(5531,469,0)
(7790,341,0)
(5646,8619,0)
(257,2227,0)
(4085,7156,0)
(4438,6199,0)
(6223,4829,0)
(4881,8653,0)
(4362,1838,0)
(7604,6792,0)
(2923,7101,0)
(6088,1572,0)
(4194,4119,0)
(7762,1502,0)
(3959,4873,0)
(6580,2330,0)
(2540,3172,0)
(4070,2898,0)
(8275,677,0)
(4530,7534,0)
(4131,4928,0)
(5106,1515,0)
(2508,1891,0)
(8959,6703,0)
(5201,609,0)
(1766,6032,0)
(8801,8179,0)
(8799,7526,0)
(5570,1581,0)
(6817,7004,0)
(5985,7453,0)
(7594,7093,0)
(6542,2835,0)
(4654,3270,0)
(2494,7706,0)
(3174,134,0)
(5256,8288,0)
(520,7034,0)
(9134,5714,0)
(1921,7512,0)
(4930,7474,0)
(8056,6048,0)
(3753,1502,0)
(4598,8239,0)
(4601,1157,0)
(8093,9027,0)
(606,8180,0)
(4313,455,0)
(220,1438,0)
(5870,3849,0)
(1640,7453,0)
(7827,5279,0)
(4037,5468,0)
(7424,4269,0)
(2721,7724,0)
(8004,8890,0)
(1646,6047,0)
(2526,2928,0)
(4518,5943,0)
(2385,4995,0)
(4110,123,0)
(3929,8541,0)
(134,3174,0)
(5023,4176,0)
(5891,4954,0)
(6717,8358,0)
(589,6736,0)
(8360,8436,0)
(8003,2638,0)
(1058,6493,0)
(6025,959,0)
(7246,8957,0)
(4200,4928,0)
(6023,6624,0)
(8998,6384,0)
(3416,6988,0)
(5928,2642,0)
(4071,3367,0)
(7602,4680,0)
(1153,7453,0)
(5949,6771,0)
(877,4928,0)
(1810,460,0)
(7848,4147,0)
(628,2163,0)
(1379,1273,0)
(7328,3095,0)
(940,8981,0)
(1227,1197,0)
(2908,7946,0)
(1197,1227,0)
(3404,7703,0)
(4242,7689,0)
(8829,5573,0)
(7067,3473,0)
(3892,8331,0)
(5728,8071,0)
(7488,811,0)
(1988,598,0)
(709,5571,0)
(890,4928,0)
(606,644,0)
(8069,5928,0)
(2277,7887,0)
(7779,2572,0)
(95,8862,0)
(5056,3502,0)
(332,5902,0)
(3540,1585,0)
(8494,1502,0)
(2677,598,0)
(7896,1502,0)
(5548,7040,0)
(4738,4928,0)
(680,4402,0)
(5591,254,0)
(1992,4494,0)
(7823,8776,0)
(4108,953,0)
(8845,258,0)
(51,5784,0)
(8636,8912,0)
(6323,5062,0)
(2993,7728,0)
(5305,1158,0)
(3615,8264,0)
(5666,8884,0)
(1255,1840,0)
(1988,1591,0)
(5284,7453,0)
(8988,8039,0)
(297,4928,0)
(993,3222,0)
(88,1731,0)
(2528,360,0)
(3525,2898,0)
(2324,489,0)
(1923,4928,0)
(2524,4339,0)
(9083,1502,0)
(876,2322,0)
(6095,6900,0)
(6543,1675,0)
(8943,8875,0)
(8335,4928,0)
(7558,8964,0)
(454,6501,0)
(1535,5330,0)
(3800,1347,0)
(5060,8603,0)
(4846,7100,0)
(8179,8091,0)
(2501,9000,0)
(1431,7131,0)
(8043,7391,0)
(1119,5662,0)
(8996,435,0)
(2574,5371,0)
(2343,1067,0)
(5970,4592,0)
(7151,4953,0)
(3383,2196,0)
(7882,3252,0)
(4501,3753,0)
(4299,984,0)
(4371,1502,0)
(644,45,0)
(8164,3329,0)
(3408,6655,0)
(5853,5489,0)
(730,1890,0)
(4539,8681,0)
(9007,6031,0)
(4846,2893,0)
(3582,7687,0)
(7785,4913,0)
(8580,1207,0)
(8584,1502,0)
(6523,131,0)
(8438,2041,0)
(5111,2865,0)
(4140,8970,0)
(6568,5614,0)
(561,305,0)
(5954,7311,0)
(2261,2311,0)
(1246,4298,0)
(8482,2363,0)
(3771,8929,0)
(8036,4928,0)
(8868,5902,0)
(6636,1033,0)
(5311,615,0)
(2320,7148,0)
(8827,2549,0)
(9140,8997,0)
(6175,4928,0)
(693,3911,0)
(4386,6988,0)
(7846,1636,0)
(3683,375,0)
(5833,4928,0)
(5026,8481,0)
(4313,4472,0)
(2412,7717,0)
(1063,5075,0)
(9073,2874,0)
(2838,8396,0)
(5394,3906,0)
(4179,5451,0)
(172,8843,0)
(9102,1502,0)
(1344,3317,0)
(7662,5354,0)
(2327,6009,0)
(7387,1502,0)
(495,2119,0)
(8981,940,0)
(116,7391,0)
(7110,1339,0)
(855,4980,0)
(6419,7808,0)
(5126,6887,0)
(3942,3337,0)
(2420,2629,0)
(6033,2994,0)
(38,558,0)
(5856,558,0)
(7608,3465,0)
(7255,3776,0)
(5454,2744,0)
(5588,7546,0)
(4956,6721,0)
(1330,533,0)
(3084,3327,0)
(4090,8083,0)
(8594,8302,0)
(7038,6515,0)
(1032,3924,0)
(7483,8843,0)
(786,3319,0)
(6108,313,0)
(1883,6767,0)
(5974,2184,0)
(4283,943,0)
(5550,3120,0)
(5690,1237,0)
(5294,2894,0)
(326,6732,0)
(8044,8938,0)
(7209,7477,0)
(4150,3975,0)
(3101,7257,0)
(9071,4928,0)
(6132,8894,0)
(7699,5113,0)
(1455,2295,0)
(6862,4015,0)
(6016,8324,0)
(7694,7674,0)
(4275,4016,0)
(707,3233,0)
(3492,7022,0)
(4127,5734,0)
(1730,5108,0)
(9104,9011,0)
(8468,597,0)
(3711,2136,0)
(3942,4928,0)
(7317,4753,0)
(6696,5230,0)
(652,2410,0)
(999,9128,0)
(4607,2315,0)
(8495,2806,0)
(4194,8404,0)
(3529,6047,0)
(5424,364,0)
(8560,1502,0)
(6980,2204,0)
(7046,6465,0)
(8692,5902,0)
(2869,4551,0)
(6179,8577,0)
(6071,8849,0)
(5328,64,0)
(6117,8089,0)
(2389,4830,0)
(6651,5472,0)
(2985,4507,0)
(7999,3391,0)
(6985,2378,0)
(1491,9029,0)
(5800,5975,0)
(2445,3329,0)
(7431,4835,0)
(3970,7466,0)
(7225,5879,0)
(8336,1502,0)
(888,2574,0)
(8916,6577,0)
(557,6849,0)
(7036,707,0)
(2894,4167,0)
(8356,4258,0)
(1466,6408,0)
(3963,87,0)
(2067,5043,0)
(3543,1502,0)
(8558,3313,0)
(3758,9104,0)
(353,5249,0)
(7714,8284,0)
(2188,559,0)
(3085,1298,0)
(1027,3583,0)
(7195,3633,0)
(7384,7453,0)
(3230,5902,0)
(7197,39,0)
(4086,7030,0)
(1516,7621,0)
(8324,3636,0)
(4415,8255,0)
(4181,6967,0)
(5509,3900,0)
(2309,7518,0)
(8053,6014,0)
(1172,1953,0)
(7622,6074,0)
(4858,9085,0)
(5856,9115,0)
(131,2267,0)
(1886,6348,0)
(4733,4552,0)
(6939,4928,0)
(7783,4744,0)
(2189,404,0)
(2477,4928,0)
(4028,1262,0)
(7521,3530,0)
(6706,5043,0)
(3341,98,0)
(633,2650,0)
(2712,8459,0)
(2697,3220,0)
(6962,887,0)
(5294,3831,0)
(240,9050,0)
(3137,4744,0)
(1538,1502,0)
(1270,2507,0)
(3905,2163,0)
(4792,2582,0)
(4068,5147,0)
(8128,5043,0)
(3083,1502,0)
(4212,4928,0)
(4835,16,0)
(7510,7453,0)
(2415,150,0)
(3772,1895,0)
(8878,2306,0)
(4667,4735,0)
(1800,1220,0)
(1905,5424,0)
(6136,7460,0)
(158,1479,0)
(7884,3330,0)
(8242,1079,0)
(8296,2294,0)
(6039,2801,0)
(6366,55,0)
(8658,5337,0)
(3881,6431,0)
(4655,5996,0)
(7154,6440,0)
(8981,8452,0)
(5779,1385,0)
(2298,1502,0)
(4932,6048,0)
(2402,559,0)
(1202,1951,0)
(9079,4909,0)
(4853,1004,0)
(8527,7373,0)
(4040,7453,0)
(5276,3378,0)
(715,7453,0)
(3411,2893,0)
(3907,7138,0)
(499,4928,0)
(5879,7225,0)
(8285,6786,0)
(145,6005,0)
(2255,7000,0)
(8123,8396,0)
(4763,7472,0)
(1636,7846,0)
(2008,4928,0)
(4529,1654,0)
(6728,4928,0)
(5016,2898,0)
(7091,297,0)
(595,6655,0)
(6503,2656,0)
(354,4548,0)
(2934,3043,0)
(5443,6567,0)
(1437,4142,0)
(2227,381,0)
(6378,2196,0)
(946,4201,0)
(5047,95,0)
(6449,3543,0)
(3223,6127,0)
(3803,5088,0)
(8827,118,0)
(4624,8247,0)
(8842,342,0)
(6289,3968,0)
(8602,8800,0)
(4141,7808,0)
(8732,7004,0)
(8743,7488,0)
(5967,7453,0)
(8205,2904,0)
(4065,4928,0)
(4699,7371,0)
(9037,8678,0)
(433,5617,0)
(8400,3470,0)
(668,5481,0)
(408,1748,0)
(3050,1789,0)
(530,7667,0)
(8284,2823,0)
(383,7055,0)
(5971,5258,0)
(8829,1591,0)
(4997,8593,0)
(1084,4504,0)
(3533,3872,0)
(3957,1093,0)
(339,7984,0)
(5754,2185,0)
(6319,3279,0)
(1473,4886,0)
(8526,1603,0)
(7100,5902,0)
(3204,8482,0)
(813,1502,0)
(3985,7912,0)
(659,7477,0)
(6460,2639,0)
(4551,404,0)
(6086,7425,0)
(7991,1128,0)
(2813,6964,0)
(8633,4790,0)
(3667,6249,0)
(5657,5787,0)
(832,5166,0)
(3100,1973,0)
(5931,5027,0)
(2245,1738,0)
(3908,6335,0)
(5003,3423,0)
(1856,8293,0)
(3423,5222,0)
(7596,7753,0)
(1452,1444,0)
(6493,1502,0)
(1873,948,0)
(1054,5732,0)
(8022,8201,0)
(4352,1502,0)
(5929,1262,0)
(6289,8513,0)
(4649,3130,0)
(5888,8975,0)
(1766,7004,0)
(8634,1316,0)
(1633,8306,0)
(6459,3533,0)
(6216,1634,0)
(5651,5836,0)
(5255,1502,0)
(7098,7546,0)
(6324,8194,0)
(8654,1986,0)
(5838,3353,0)
(6096,1599,0)
(9059,5680,0)
(5266,4177,0)
(6746,8998,0)
(7638,5757,0)
(6304,598,0)
(130,6120,0)
(4172,2751,0)
(2196,6378,0)
(4826,1887,0)
(5523,4278,0)
(7562,3098,0)
(7753,4544,0)
(1628,1498,0)
(3005,8448,0)
(3890,5717,0)
(5294,1591,0)
(2481,7767,0)
(7124,7039,0)
(5294,5497,0)
(6139,7427,0)
(760,8029,0)
(6390,9145,0)
(1705,317,0)
(3692,2425,0)
(5148,6025,0)
(2574,1942,0)
(8060,1267,0)
(6900,4667,0)
(6907,3656,0)
(6615,1254,0)
(4722,1768,0)
(2954,1502,0)
(201,1712,0)
(712,1489,0)
(411,4016,0)
(7439,7214,0)
(6134,5489,0)
(1442,7496,0)
(6270,3511,0)
(7450,3840,0)
(6152,3492,0)
(4200,1502,0)
(609,7252,0)
(6905,2402,0)
(703,1248,0)
(2371,7894,0)
(6237,7172,0)
(3280,4147,0)
(7649,2349,0)
(5973,1812,0)
(3759,6202,0)
(771,4555,0)
(8662,3906,0)
(8269,3508,0)
(8874,7286,0)
(3302,1591,0)
(3765,5065,0)
(5176,4725,0)
(5576,959,0)
(2663,1502,0)
(221,8928,0)
(7530,6873,0)
(7344,2043,0)
(7031,7341,0)
(29,1066,0)
(8574,1502,0)
(5531,3710,0)
(7961,9021,0)
(167,5941,0)
(8451,1502,0)
(1649,4857,0)
(1901,5991,0)
(7323,3903,0)
(8799,4961,0)
(4313,7991,0)
(5454,3883,0)
(2573,2488,0)
(6524,6302,0)
(1079,8242,0)
(3038,2207,0)
(2438,6743,0)
(7961,4757,0)
(3600,588,0)
(5716,2373,0)
(780,5849,0)
(8381,7821,0)
(4116,5992,0)
(4289,2749,0)
(8983,1086,0)
(2365,1357,0)
(2199,3522,0)
(8835,3831,0)
(1785,3566,0)
(7272,5369,0)
(7429,4291,0)
(3730,1502,0)
(3841,1464,0)
(4552,4733,0)
(1724,5203,0)
(2698,1092,0)
(8150,7321,0)
(2732,4928,0)
(6603,247,0)
(4834,9130,0)
(2078,1974,0)
(6858,1040,0)
(4334,1221,0)
(3257,6522,0)
(6744,1262,0)
(247,3872,0)
(2370,1515,0)
(7770,4658,0)
(3664,9023,0)
(7179,3062,0)
(6662,4013,0)
(1541,3332,0)
(1246,1842,0)
(2318,730,0)
(1314,1920,0)
(577,1985,0)
(1908,5785,0)
(4471,5300,0)
(5686,586,0)
(7753,4354,0)
(8899,7076,0)
(5410,813,0)
(2375,6213,0)
(2104,2605,0)
(2339,8513,0)
(683,4167,0)
(4972,4303,0)
(8206,831,0)
(4903,8356,0)
(3143,5528,0)
(3504,3026,0)
(6228,609,0)
(8179,6047,0)
(2158,8945,0)
(8900,8494,0)
(2001,3167,0)
(7394,6580,0)
(6214,38,0)
(8094,4475,0)
(679,7023,0)
(5141,1502,0)
(8637,211,0)
(315,487,0)
(3616,8284,0)
(2325,3082,0)
(5046,982,0)
(857,4954,0)
(2937,2275,0)
(4655,799,0)
(3827,8425,0)
(4313,7960,0)
(3813,9051,0)
(8382,3126,0)
(1973,5754,0)
(1923,1502,0)
(8154,6724,0)
(3332,1502,0)
(5668,3440,0)
(6390,4973,0)
(8413,2681,0)
(6421,1128,0)
(6172,118,0)
(6640,1491,0)
(6030,6328,0)
(1020,8254,0)
(8462,8780,0)
(2100,6431,0)
(7905,7405,0)
(8857,3343,0)
(8680,8780,0)
(7665,7887,0)
(7686,5941,0)
(7167,8336,0)
(1911,7724,0)
(5957,6299,0)
(486,1638,0)
(802,8542,0)
(2709,2453,0)
(8203,3581,0)
(6375,5472,0)
(7413,8839,0)
(1298,7468,0)
(5807,3917,0)
(8749,4456,0)
(4867,8713,0)
(3838,1502,0)
(1491,6640,0)
(6791,2618,0)
(2961,4085,0)
(5258,6047,0)
(141,1502,0)
(1641,1889,0)
(1884,8555,0)
(4273,2964,0)
(2928,4301,0)
(1757,2149,0)
(5240,5674,0)
(679,4341,0)
(2084,4173,0)
(5816,2209,0)
(6522,7814,0)
(785,2071,0)
(3619,1882,0)
(8460,8929,0)
(8586,2248,0)
(4794,6350,0)
(5422,303,0)
(3907,8348,0)
(1615,6249,0)
(2468,7477,0)
(2827,685,0)
(3681,4928,0)
(3102,1246,0)
(4437,7461,0)
(587,5550,0)
(6986,6344,0)
(5531,997,0)
(3072,8225,0)
(2985,8395,0)
(6758,1502,0)
(1512,6002,0)
(5070,2152,0)
(1754,7898,0)
(8829,1128,1)
(1419,5275,1)
(5937,5142,1)
(4121,2455,1)
(3463,4928,1)
(4044,7568,1)
(8486,5296,1)
(4889,5987,1)
(6726,4176,1)
(3265,3086,1)
(1800,4928,1)
(8829,8188,1)
(2620,5044,1)
(6924,1130,1)
(5710,1658,1)
(4345,1604,1)
(3097,6028,1)
(6649,3304,1)
(7994,1385,1)
(3823,7061,1)
(7816,2793,1)
(3793,5868,1)
(5580,2072,1)
(3818,3635,1)
(2735,4966,1)
(106,1696,1)
(5470,736,1)
(3036,797,1)
(8829,5573,1)
(1267,6739,1)
(3297,2424,1)
(6233,7805,1)
(2503,873,1)
(435,1502,1)
(6427,8374,1)
(3842,2555,1)
(5952,266,1)
(5445,3583,1)
(2854,7091,1)
(3322,5803,1)
(4528,6869,1)
(4754,2608,1)
(5705,310,1)
(504,4551,1)
(2017,5160,1)
(18,8208,1)
(6220,1191,1)
(6450,1117,1)
(6658,3691,1)
(3272,2296,1)
(5709,204,1)
(8836,3367,1)
(4431,2997,1)
(6353,53,1)
(3179,8931,1)
(7383,2364,1)
(613,8258,1)
(5979,6433,1)
(4572,5559,1)
(5097,8087,1)
(6176,7235,1)
(1828,1502,1)
(3027,8925,1)
(6809,3666,1)
(3609,8477,1)
(858,3109,1)
(6864,2715,1)
(4841,5285,1)
(4702,1502,1)
(2003,5458,1)
(2685,699,1)
(3275,7515,1)
(8465,2952,1)
(5318,7688,1)
(5196,2973,1)
(2164,6473,1)
(924,6733,1)
(2473,1502,1)
(586,5686,1)
(3216,5849,1)
(6321,4646,1)
(8828,3799,1)
(7131,1502,1)
(5294,6560,1)
(7901,1502,1)
(5627,2038,1)
(7558,8964,1)
(5635,9078,1)
(3657,1502,1)
(7764,360,1)
(4506,5790,1)
(8931,7865,1)
(6805,3448,1)
(1404,2289,1)
(2114,627,1)
(8141,6512,1)
(1513,1475,1)
(7563,7285,1)
(5641,4928,1)
(7046,7148,1)
(3502,5056,1)
(5383,8627,1)
(8551,3149,1)
(1881,24,1)
(893,4763,1)
(8229,3991,1)
(4860,4928,1)
(3188,1141,1)
(7383,583,1)
(7807,6047,1)
(32,5438,1)
(8536,8194,1)
(1438,5902,1)
(1916,4523,1)
(8121,3901,1)
(996,2668,1)
(5699,5559,1)
(3793,4928,1)
(7821,8759,1)
(8100,4979,1)
(1009,79,1)
(2858,2852,1)
(4651,6090,1)
(984,4299,1)
(5673,7892,1)
(4140,4207,1)
(2640,702,1)
(8299,4522,1)
(1390,4928,1)
(7529,4928,1)
(3327,1502,1)
(166,3797,1)
(8960,5095,1)
(3007,7794,1)
(5733,3037,1)
(6398,8217,1)
(6790,137,1)
(998,6501,1)
(3775,6592,1)
(5420,2554,1)
(8088,7107,1)
(2526,5705,1)
(4548,950,1)
(1118,1500,1)
(2912,4928,1)
(7015,2726,1)
(7055,4928,1)
(4226,2889,1)
(237,5902,1)
(3838,6047,1)
(1367,1802,1)
(1320,3550,1)
(8929,1486,1)
(3339,2861,1)
(1921,4488,1)
(1464,8892,1)
(4918,1635,1)
(7140,1513,1)
(5294,3831,1)
(3217,2178,1)
(7863,6781,1)
(7612,8083,1)
(359,7244,1)
(2246,6644,1)
(222,4862,1)
(411,4016,1)
(5022,8922,1)
(7289,3045,1)
(7209,8720,1)
(1436,7758,1)
(7784,8650,1)
(3859,7057,1)
(6423,3852,1)
(1582,6351,1)
(2736,3259,1)
(1088,2991,1)
(8110,2139,1)
(3447,8579,1)
(1903,6359,1)
(5361,5437,1)
(6985,6521,1)
(7610,5981,1)
(4022,6379,1)
(3703,4744,1)
(8856,4184,1)
(6415,8788,1)
(2963,422,1)
(4809,3027,1)
(611,4928,1)
(2995,3873,1)
(3486,4928,1)
(7458,5104,1)
(2450,8241,1)
(610,6915,1)
(9075,2155,1)
(7557,4728,1)
(2851,135,1)
(2053,5832,1)
(3918,3090,1)
(4434,4102,1)
(2962,3651,1)
(3979,1280,1)
(192,3423,1)
(7807,4928,1)
(3439,2776,1)
(8236,5811,1)
(8586,7368,1)
(7765,6842,1)
(7949,820,1)
(7171,3529,1)
(4727,8148,1)
(2320,4551,1)
(1185,1502,1)
(6530,4928,1)
(822,6293,1)
(3460,8562,1)
(2728,4928,1)
(2043,551,1)
(3158,4808,1)
(5243,752,1)
(436,2769,1)
(7501,8766,1)
(3711,8483,1)
(5633,3818,1)
(8578,5846,1)
(4952,616,1)
(5982,8385,1)
(2735,5890,1)
(1698,1502,1)
(3772,7598,1)
(3543,4057,1)
(6252,3887,1)
(196,1531,1)
(824,7706,1)
(5423,8437,1)
(3527,7628,1)
(1193,733,1)
(393,3258,1)
(8584,4925,1)
(7238,598,1)
(7712,7623,1)
(8307,6021,1)
(4365,6467,1)
(4915,2657,1)
(2627,5888,1)
(455,598,1)
(702,6204,1)
(3703,6431,1)
(7917,8920,1)
(8018,1430,1)
(3423,8834,1)
(3241,4187,1)
(3306,1502,1)
(6203,8371,1)
(3191,305,1)
(701,4878,1)
(5807,8585,1)
(5277,5629,1)
(4843,4928,1)
(8607,8362,1)
(3235,2100,1)
(34,8970,1)
(4220,1512,1)
(3055,3034,1)
(5961,2510,1)
(1268,8473,1)
(6592,4251,1)
(4987,3488,1)
(8934,7109,1)
(7991,6988,1)
(6713,7455,1)
(2359,4928,1)
(3238,8975,1)
(6304,8037,1)
(5160,5432,1)
(1500,3041,1)
(3325,423,1)
(3844,423,1)
(4333,8321,1)
(2216,1682,1)
(2311,4928,1)
(6606,4293,1)
(8187,7475,1)
(7687,3857,1)
(3715,5883,1)
(8587,8423,1)
(9147,1139,1)
(1213,242,1)
(191,8110,1)
(6406,2783,1)
(1410,7205,1)
(521,1502,1)
(4377,4148,1)
(9069,952,1)
(6899,1505,1)
(9049,7919,1)
(1954,4760,1)
(4235,5205,1)
(8883,5139,1)
(7947,2709,1)
(18,498,1)
(4553,2898,1)
(1063,5075,1)
(4829,4928,1)
(7675,6939,1)
(3512,1411,1)
(445,1555,1)
(2480,248,1)
(2338,2898,1)
(6304,3674,1)
(3435,7819,1)
(1547,2099,1)
(2403,4928,1)
(4313,4437,1)
(7037,7476,1)
(5198,2174,1)
(1629,2680,1)
(8775,2230,1)
(3979,1502,1)
(8004,7028,1)
(3950,3019,1)
(8624,8094,1)
(2394,4837,1)
(6883,1502,1)
(4590,7468,1)
(5635,915,1)
(1714,5269,1)
(7090,8243,1)
(7405,6159,1)
(1222,383,1)
(2009,1629,1)
(7240,756,1)
(7247,3886,1)
(4818,4680,1)
(6261,5776,1)
(8454,5492,1)
(2817,5735,1)
(6279,2271,1)
(4070,2898,1)
(516,5874,1)
(1502,6191,1)
(1626,4928,1)
(2946,7311,1)
(7648,5568,1)
(8543,131,1)
(6194,2717,1)
(6614,6242,1)
(707,7036,1)
(7139,6225,1)
(1441,5093,1)
(3165,5935,1)
(8310,3233,1)
(1226,138,1)
(2588,6549,1)
(5222,1484,1)
(384,5611,1)
(854,5325,1)
(7177,1862,1)
(1300,1286,1)
(2453,2709,1)
(7698,1035,1)
(3414,4928,1)
(5086,1502,1)
(7532,3403,1)
(8485,6311,1)
(4883,14,1)
(5209,1053,1)
(1115,8520,1)
(3270,1469,1)
(3444,6315,1)
(6766,6236,1)
(4254,5507,1)
(8671,4477,1)
(7588,5109,1)
(1004,4961,1)
(7305,4123,1)
(7962,1410,1)
(1359,5441,1)
(1498,5910,1)
(510,1255,1)
(480,7941,1)
(4253,6152,1)
(1438,6511,1)
(3041,6450,1)
(4054,6033,1)
(5268,3286,1)
(4191,7097,1)
(1690,622,1)
(5748,3728,1)
(2587,5812,1)
(1641,3230,1)
(4005,4124,1)
(5859,3393,1)
(205,4928,1)
(2523,997,1)
(3478,688,1)
(5164,5909,1)
(4813,1324,1)
(4203,3824,1)
(7908,7828,1)
(7046,5559,1)
(963,1431,1)
(3920,6908,1)
(3446,6117,1)
(5485,5009,1)
(6718,3603,1)
(3808,8781,1)
(4925,6116,1)
(8855,6807,1)
(2298,4928,1)
(8963,3499,1)
(5989,206,1)
(311,1898,1)
(4766,3121,1)
(4169,1502,1)
(8728,3583,1)
(308,4165,1)
(4092,7335,1)
(4572,2893,1)
(3987,6142,1)
(5560,4928,1)
(4095,2548,1)
(3715,334,1)
(3093,758,1)
(4042,5003,1)
(4948,6398,1)
(6255,2032,1)
(1267,8060,1)
(6675,3788,1)
(4104,2850,1)
(371,6047,1)
(1033,2857,1)
(7102,8712,1)
(7133,1321,1)
(8153,5243,1)
(7209,5266,1)
(5122,6431,1)
(2634,5918,1)
(4769,4928,1)
(7814,1502,1)
(8758,2990,1)
(218,7684,1)
(7010,3921,1)
(5330,1502,1)
(2025,8066,1)
(3431,3136,1)
(3096,4793,1)
(2886,5646,1)
(9006,1022,1)
(7773,1502,1)
(7447,2527,1)
(3484,1085,1)
(7417,8704,1)
(8398,8086,1)
(8365,9062,1)
(8725,3190,1)
(7612,797,1)
(2697,4928,1)
(7355,1078,1)
(1006,3682,1)
(8864,4061,1)
(8464,4748,1)
(4120,2125,1)
(8314,7766,1)
(2694,5569,1)
(7656,8649,1)
(289,7545,1)
(8814,5867,1)
(5187,6522,1)
(3207,6652,1)
(7481,467,1)
(2924,8516,1)
(3777,4928,1)
(2560,6519,1)
(5082,593,1)
(5815,6959,1)
(1657,2901,1)
(5395,158,1)
(1054,6243,1)
(2848,2375,1)
(7656,4928,1)
(6772,7039,1)
(1884,7658,1)
(73,7131,1)
(8722,3123,1)
(7547,3618,1)
(1067,4044,1)
(7264,8199,1)
(2698,1092,1)
(2300,419,1)
(7672,6107,1)
(4115,843,1)
(7335,4969,1)
(892,6853,1)
(1539,6047,1)
(2665,2497,1)
(3088,1097,1)
(6270,1,1)
(3066,1349,1)
(5531,7057,1)
(8911,1452,1)
(2360,8670,1)
(4478,7228,1)
(4636,2487,1)
(6304,3313,1)
(7793,1502,1)
(593,7808,1)
(3200,6680,1)
(4369,8648,1)
(4313,2869,1)
(2706,7790,1)
(6379,3623,1)
(1594,6744,1)
(49,4928,1)
(3741,3267,1)
(9019,8176,1)
(5456,8223,1)
(6503,2345,1)
(5566,5428,1)
(5199,3587,1)
(4635,1502,1)
(2568,1502,1)
(2032,7361,1)
(4212,4928,1)
(2843,4928,1)
(6353,4928,1)
(1443,8362,1)
(7464,8891,1)
(7183,4082,1)
(3361,5455,1)
(8222,350,1)
(2442,1434,1)
(55,6586,1)
(5973,1812,1)
(2232,82,1)
(827,3134,1)
(7055,1502,1)
(3846,345,1)
(4213,1004,1)
(2735,9097,1)
(3326,1747,1)
(2931,2982,1)
(2212,7043,1)
(4973,5799,1)
(124,375,1)
(673,601,1)
(5353,1451,1)
(7610,1502,1)
(6925,4856,1)
(7493,5807,1)
(1894,6109,1)
(950,354,1)
(4698,6334,1)
(8300,3108,1)
(849,1515,1)
(7249,1309,1)
(8201,8022,1)
(1974,2078,1)
(296,3478,1)
(8609,4469,1)
(8748,1991,1)
(4437,1128,1)
(5717,2686,1)
(7235,3669,1)
(3582,8160,1)
(7955,2076,1)
(1892,1502,1)
(559,1502,1)
(6195,1424,1)
(7892,8901,1)
(6716,3926,1)
(4149,3617,1)
(629,5574,1)
(9139,6103,1)
(6304,4373,1)
(6736,2818,1)
(852,1502,1)
(1471,4765,1)
(5842,3316,1)
(2357,5641,1)
(1479,4928,1)
(6575,1505,1)
(3143,685,1)
(4840,292,1)
(1633,8306,1)
(897,1310,1)
(1254,5902,1)
(4068,136,1)
(3591,4892,1)
(2735,4559,1)
(6999,1943,1)
(3603,7933,1)
(8031,8407,1)
(4640,4928,1)
(3205,2164,1)
(712,8188,1)
(7356,304,1)
(6961,2359,1)
(292,7357,1)
(6951,7651,1)
(8097,8499,1)
(1747,929,1)
(5294,7288,1)
(9065,3807,1)
(7782,2023,1)
(8850,4928,1)
(7404,4134,1)
(7925,3949,1)
(5116,518,1)
(6506,2224,1)
(1844,5127,1)
(8431,1166,1)
(465,7242,1)
(711,6619,1)
(6408,8185,1)
(2869,6560,1)
(7917,4928,1)
(7888,6366,1)
(6791,5124,1)
(2801,8217,1)
(6095,8635,1)
(2852,6018,1)
(7394,394,1)
(7860,8799,1)
(4554,901,1)
(5938,4862,1)
(6171,448,1)
(4372,6579,1)
(1368,1157,1)
(8413,1856,1)
(4409,8692,1)
(4952,1540,1)
(8285,2542,1)
(2632,697,1)
(2304,3366,1)
(8505,1717,1)
(5327,4928,1)
(1589,7224,1)
(7536,8362,1)
(8945,1502,1)
(773,2059,1)
(4958,8186,1)
(1987,4019,1)
(3649,2853,1)
(9007,1030,1)
(3565,414,1)
(5418,6190,1)
(4581,1455,1)
(7993,7924,1)
(5157,2232,1)
(3155,4909,1)
(5079,3137,1)
(5759,4928,1)
(5294,742,1)
(4920,228,1)
(7021,1311,1)
(8826,3583,1)
(7931,8001,1)
(538,1502,1)
(395,7200,1)
(9037,7137,1)
(1338,2482,1)
(8728,46,1)
(123,2506,1)
(5030,5618,1)
(3709,7730,1)
(7879,8362,1)
(3489,4079,1)
(7311,4361,1)
(8273,332,1)
(8514,6484,1)
(2202,3894,1)
(8184,4076,1)
(6347,2564,1)
(4154,2091,1)
(577,8950,1)
(2356,903,1)
(8858,5902,1)
(6509,4688,1)
(7579,7211,1)
(3367,7869,1)
(7574,8885,1)
(6860,7678,1)
(3533,2898,1)
(5936,3084,1)
(4221,1502,1)
(2540,3032,1)
(2148,33,1)
(5558,2987,1)
(6785,4046,1)
(3936,3135,1)
(1765,4059,1)
(2100,6431,1)
(4437,9075,1)
(4297,8453,1)
(1198,7508,1)
(4770,8183,1)
(6344,7226,1)
(3129,2363,1)
(5294,8005,1)
(4390,4538,1)
(5531,3710,1)
(3881,6431,1)
(4349,8029,1)
(272,5027,1)
(4049,4928,1)
(2814,4481,1)
(597,4928,1)
(5658,826,1)
(1530,6047,1)
(5454,2744,1)
(4884,4007,1)
(398,8639,1)
(8008,3720,1)
(8631,9128,1)
(4211,5992,1)
(5651,5836,1)
(310,4928,1)
(603,6961,1)
(4730,1389,1)
(7113,2170,1)
(6778,7630,1)
(1525,6423,1)
(150,2389,1)
(4593,6178,1)
(2444,3042,1)
(2182,8192,1)
(6873,6505,1)
(8829,7198,1)
(3716,6882,1)
(3240,7527,1)
(2610,7003,1)
(6304,9075,1)
(5104,4996,1)
(1873,3251,1)
(912,5742,1)
(3472,625,1)
(8280,5589,1)
(7626,8284,1)
(1620,1502,1)
(1122,8607,1)
(9037,5573,1)
(7039,3236,1)
(7896,4928,1)
(4956,9038,1)
(8777,4360,1)
(4924,4473,1)
(7077,2360,1)
(4616,3161,1)
(2869,5115,1)
(1120,1502,1)
(2471,1502,1)
(4904,1779,1)
(6738,426,1)
(7268,1336,1)
(7103,5193,1)
(7116,986,1)
(3529,4928,1)
(744,4513,1)
(8535,1594,1)
(2790,8272,1)
(8915,3709,1)
(315,487,1)
(5293,2847,1)
(8056,3340,1)
(4647,2794,1)
(6419,1235,1)
(7620,3072,1)
(8936,762,1)
(6094,8095,1)
(6770,653,1)
(7684,6507,1)
(2894,806,1)
(4352,6047,1)
(6479,8796,1)
(7486,2587,1)
(8780,6431,1)
(6304,5559,1)
(2039,1702,1)
(5080,6047,1)
(3613,744,1)
(1297,2659,1)
(4897,2781,1)
(6207,5493,1)
(8695,5010,1)
(3164,7951,1)
(394,1671,1)
(2734,7778,1)
(334,7502,1)
(8797,2171,1)
(8199,4928,1)
(5230,4015,1)
(6659,1502,1)
(6105,3653,1)
(4726,6336,1)
(5238,6661,1)
(295,8466,1)
(8882,7415,1)
(2071,2686,1)
(3910,587,1)
(8109,4068,1)
(5438,613,1)
(3812,2509,1)
(9042,4431,1)
(677,5260,1)
(5755,4928,1)
(2807,322,1)
(4551,5292,1)
(6368,597,1)
(838,8225,1)
(5037,5125,1)
(7814,4928,1)
(8818,174,1)
(6921,1526,1)
(7023,5029,1)
(3621,5861,1)
(1334,8727,1)
(6576,306,1)
(1859,7105,1)
(7605,1502,1)
(1351,4423,1)
(4168,1247,1)
(7492,8965,1)
(300,2592,1)
(3893,3124,1)
(1647,3417,1)
(5679,4228,1)
(1797,6991,1)
(1030,2288,1)
(9126,104,1)
(7760,1075,1)
(6251,2041,1)
(5373,7438,1)
(3426,1292,1)
(3192,8205,1)
(3817,6609,1)
(3500,4928,1)
(3204,2681,1)
(303,4429,1)
(2494,4928,1)
(1090,1323,1)
(7320,2027,1)
(4146,6729,1)
(1811,8231,1)
(8271,3526,1)
(582,6226,1)
(1197,1001,1)
(7077,598,1)
(401,1095,1)
(3302,2894,1)
(8628,197,1)
(8059,4121,1)
(4839,5656,1)
(2844,5902,1)
(6546,4286,1)
(5309,8826,1)
(5075,7468,1)
(4340,3422,1)
(5725,3585,1)
(4497,2479,1)
(5294,6574,1)
(8124,6740,1)
(4880,6219,1)
(7820,6801,1)
(855,7070,1)
(6833,352,1)
(2456,2687,1)
(4110,123,1)
(4842,3130,1)
(3139,2587,1)
(3396,4180,1)
(5176,2898,1)
(3159,1502,1)
(8032,7628,1)
(9129,822,1)
(386,6310,1)
(632,648,1)
(8340,4489,1)
(7445,2021,1)
(2002,6924,1)
(4304,6749,1)
(5166,1129,1)
(2713,5636,1)
(7696,8413,1)
(228,6591,1)
(5066,8927,1)
(328,4928,1)
(5460,5317,1)
(4398,7153,1)
(6105,5902,1)
(7843,1027,1)
(6121,6323,1)
(173,6009,1)
(2852,8189,1)
(8358,6224,1)
(3971,1502,1)
(315,5178,1)
(7749,3388,1)
(551,4928,1)
(1854,2108,1)
(753,6915,1)
(6011,1142,1)
(2791,8151,1)
(5010,2024,1)
(830,7883,1)
(8128,5902,1)
(5779,505,1)
(1425,6566,1)
(2393,1678,1)
(246,7546,1)
(6698,8875,1)
(2025,9154,1)
(7329,9100,1)
(657,4626,1)
(245,1502,1)
(440,8491,1)
(481,3025,1)
(3262,7460,1)
(8297,432,1)
(2067,3538,1)
(788,3929,1)
(5730,5405,1)
(25,5333,1)
(1516,5381,1)
(8356,4903,1)
(1964,2466,1)
(6081,5880,1)
(2414,4674,1)
(7068,8296,1)
(552,7048,1)
(5092,1813,1)
(5646,1567,1)
(8120,1502,1)
(3411,8188,1)
(957,1506,1)
(5768,8319,1)
(7785,3732,1)
(3345,1108,1)
(9119,1502,1)
(2142,1502,1)
(8325,1461,1)
(3265,1388,1)
(8461,4928,1)
(5455,2683,1)
(5941,8242,1)
(6777,8571,1)
(4008,4444,1)
(216,2467,1)
(2769,4693,1)
(675,8105,1)
(7539,3828,1)
(306,7366,1)
(337,1194,1)
(7558,7163,1)
(799,7158,1)
(374,3266,1)
(7614,2815,1)
(2136,4928,1)
(7387,4928,1)
(4779,2117,1)
(2656,2223,1)
(8128,8104,1)
(580,8271,1)
(3720,2100,1)
(7393,7652,1)
(3392,7498,1)
(1977,1502,1)
(5045,3878,1)
(829,519,1)
(8430,3460,1)
(8644,46,1)
(3730,4928,1)
(4523,9071,1)
(2351,1767,1)
(2546,8363,1)
(7738,4327,1)
(3524,8872,1)
(470,8522,1)
(2325,6548,1)
(7619,8820,1)
(6122,3624,1)
(5817,4928,1)
(4224,7515,1)
(4711,366,1)
(5088,3803,1)
(6945,300,1)
(7938,4438,1)
(2108,2613,1)
(4037,2531,1)
(2704,2505,1)
(8335,1502,1)
(1665,3946,1)
(6713,4928,1)
(1420,8971,1)
(8160,6657,1)
(4256,4682,1)
(3727,8515,1)
(3099,7364,1)
(729,2210,1)
(2009,4928,1)
(5887,2442,1)
(8812,5602,1)
(8726,4329,1)
(7778,4928,1)
(4744,1834,1)
(8242,1079,1)
(7595,2469,1)
(6198,2976,1)
(2877,402,1)
(5372,2609,1)
(8719,8612,1)
(864,623,1)
(6871,4928,1)
(5700,3379,1)
(2161,566,1)
(7419,4289,1)
(8829,8987,1)
(5294,2893,1)
(7001,1627,1)
(2325,2028,1)
(1579,7119,1)
(8987,4899,1)
(3900,1946,1)
(2627,2478,1)
(6645,3489,1)
(7587,3503,1)
(5294,2488,1)
(7074,4633,1)
(3367,9042,1)
(98,3341,1)
(2927,7451,1)
(939,9050,1)
(1701,4521,1)
(3973,4574,1)
(5787,1502,1)
(7802,4015,1)
(1510,579,1)
(830,1502,1)
(7347,9065,1)
(2785,1040,1)
(2166,1502,1)
(8674,791,1)
(2320,1489,1)
(400,1502,1)
(33,6703,1)
(8837,7411,1)
(747,8050,1)
(5218,4459,1)
(2036,1412,1)
(3725,3212,1)
(2518,3006,1)
(4623,87,1)
(8910,3811,1)
(1199,3880,1)
(9019,1502,1)
(6514,9028,1)
(6557,3871,1)
(3803,6536,1)
(2433,6199,1)
(4428,1717,1)
(276,5252,1)
(8516,8297,1)
(6296,6348,1)
(8301,7328,1)
(329,3672,1)
(1834,6465,1)
(1350,8841,1)
(0,2290,1)
(8382,3126,1)
(5211,1027,1)
(4236,9056,1)
(4058,1131,1)
(2210,6899,1)
(7996,4164,1)
(2354,7309,1)
(9035,5996,1)
(8402,4192,1)
(2965,1751,1)
(8826,1502,1)
(8966,1502,1)
(2401,1502,1)
(982,5565,1)
(13,9103,1)
(4716,7867,1)
(8373,5162,1)
(876,5599,1)
(4906,3248,1)
(7156,1410,1)
(8893,6431,1)
(1102,334,1)
(5658,7556,1)
(5193,2488,1)
(796,8339,1)
(842,5087,1)
(5370,5134,1)
(1378,7015,1)
(2291,6658,1)
(1209,6876,1)
(8339,4993,1)
(6843,4585,1)
(6755,2538,1)
(45,404,1)
(6781,2745,1)
(3883,5454,1)
(5200,8739,1)
(8253,3769,1)
(6020,2057,1)
(6098,8362,1)
(6342,9143,1)
(6449,7569,1)
(1680,4162,1)
(4169,5546,1)
(2388,3259,1)
(2548,1515,1)
(1775,7976,1)
(10,5693,1)
(65,6606,1)
(2320,1228,1)
(6066,1403,1)
(4947,1477,1)
(5028,2530,1)
(885,959,1)
(2492,5043,1)
(2697,1370,1)
(3415,277,1)
(2595,2255,1)
(4846,8678,1)
(5541,2577,1)
(5126,8203,1)
(5544,4928,1)
(7049,4026,1)
(6429,5750,1)
(431,4144,1)
(2535,3282,1)
(8866,8937,1)
(1655,1891,1)
(1505,2005,1)
(834,4949,1)
(3057,5770,1)
(3385,1502,1)
(7841,2964,1)
(2884,7218,1)
(2531,2062,1)
(8442,6985,1)
(2280,6047,1)
(1015,3467,1)
(662,7650,1)
(8042,5353,1)
(3979,4928,1)
(9037,7092,1)
(468,2471,1)
(4134,8081,1)
(4892,301,1)
(5307,4590,1)
(5718,1502,1)
(7310,3203,1)
(1796,1218,1)
(7806,4471,1)
(4575,1191,1)
(4313,3411,1)
(2005,4004,1)
(5766,6106,1)
(9008,7468,1)
(7751,4516,1)
(4836,6367,1)
(4437,1855,1)
(8962,2747,1)
(7387,7268,1)
(2320,5115,1)
(3961,8629,1)
(1086,6431,1)
(8862,251,1)
(2929,6005,1)
(8247,4624,1)
(6145,1693,1)
(2449,786,1)
(1474,2942,1)
(1991,4928,1)
(6380,1298,1)
(989,7619,1)
(6006,5966,1)
(1863,5721,1)
(5388,3317,1)
(5222,3423,1)
(4701,3896,1)
(8538,3009,1)
(9037,3465,1)
(4825,7876,1)
(324,235,1)
(7134,4503,1)
(4261,1926,1)
(644,673,1)
(8890,6047,1)
(5466,6626,1)
(2845,6951,1)
(5666,7554,1)
(5923,1502,1)
(2088,4238,1)
(5023,8102,1)
(7927,4541,1)
(2735,6822,1)
(7825,8234,1)
(4201,946,1)
(3654,5829,1)
(4130,8531,1)
(3248,2778,1)
(1583,5146,1)
(9084,3361,1)
(1123,7084,1)
(3731,5688,1)
(5480,7490,1)
(6912,1502,1)
(3953,1502,1)
(4073,102,1)
(3270,4464,1)
(2117,4928,1)
(3829,4845,1)
(5916,8824,1)
(2851,8672,1)
(8492,1166,1)
(238,8518,1)
(8855,1502,1)
(6464,580,1)
(8026,4267,1)
(6987,9131,1)
(2557,7897,1)
(1097,4099,1)
(3990,5902,1)
(1485,6249,1)
(6226,3892,1)
(304,4205,1)
(6792,585,1)
(463,6748,1)
(3215,2186,1)
(2984,7293,1)
(4402,669,1)
(7269,6790,1)
(6398,3003,1)
(4625,4326,1)
(712,598,1)
(4657,1502,1)
(2589,3583,1)
(6822,801,1)
(4216,8247,1)
(42,408,1)
(2206,1954,1)
(36,11,1)
(3187,3637,1)
(4932,6202,1)
(2527,7493,1)
(6682,8688,1)
(8322,4704,1)
(1573,1635,1)
(1098,3274,1)
(2863,4928,1)
(7030,4928,1)
(2673,5857,1)
(2853,8510,1)
(229,588,1)
(3536,8546,1)
(5969,5022,1)
(4915,7403,1)
(9040,5902,1)
(6484,5976,1)
(1968,198,1)
(6659,7817,1)
(267,442,1)
(3941,4556,1)
(5727,5448,1)
(5450,8373,1)
(8323,7292,1)
(2346,4687,1)
(960,2208,1)
(7791,255,1)
(4682,7370,1)
(6304,742,1)
(2157,3569,1)
(2309,6260,1)
(6669,3931,1)
(282,1667,1)
(1621,2292,1)
(2967,1502,1)
(7528,4443,1)
(7541,4424,1)
(7630,5902,1)
(9071,1502,1)
(2006,2971,1)
(7770,7180,1)
(4590,5679,1)
(6981,139,1)
(8765,1966,1)
(8629,32,1)
(4570,1824,1)
(4472,7461,1)
(5138,8853,1)
(8405,4106,1)
(788,3780,1)
(6025,6047,1)
(4882,3810,1)
(1872,2124,1)
(8972,927,1)
(5949,3532,1)
(1890,1576,1)
(8541,203,1)
(5180,3201,1)
(3370,4928,1)
(2151,4690,1)
(6057,674,1)
(3885,1116,1)
(1953,4928,1)
(9021,4371,1)
(1205,4039,1)
(4402,680,1)
(6069,9079,1)
(2486,8798,1)
(1113,3652,1)
(5338,2547,1)
(944,4266,1)
(152,1998,1)
(211,8544,1)
(6414,2635,1)
(7359,3963,1)
(1919,4895,1)
(6468,67,1)
(8632,7164,1)
(2666,827,1)
(6725,6867,1)
(5350,7659,1)
(3666,4902,1)
(976,1780,1)
(3957,1226,1)
(4896,8128,1)
(6304,4030,1)
(8974,5892,1)
(5899,2453,1)
(3006,6638,1)
(3546,1173,1)
(2156,3185,1)
(5493,1502,1)
(8467,3244,1)
(2808,7789,1)
(5158,649,1)
(7303,4260,1)
(8167,6963,1)
(5234,906,1)
(3034,2440,1)
(7747,8012,1)
(0,1774,1)
(1152,4892,1)
(1279,3063,1)
(3383,4890,1)
(281,5083,1)
(7316,5535,1)
(4437,3674,1)
(8388,5819,1)
(5018,7004,1)
(6697,3305,1)
(8511,6931,1)
(6304,4638,1)
(5859,2368,1)
(2609,6483,1)
(1461,9123,1)
(1988,6465,1)
(3623,5218,1)
(6148,2897,1)
(5249,7018,1)
(5294,2894,1)
(1072,4835,1)
(7017,8728,1)
(3018,6987,1)
(8996,9070,1)
(7733,2354,1)
(1751,791,1)
(936,2106,1)
(3003,2572,1)
(1789,1502,1)
(1197,4928,1)
(1799,7225,1)
(4623,5030,1)
(3354,2439,1)
(4502,1160,1)
(781,7832,1)
(6622,5502,1)
(8425,3827,1)
(689,4014,1)
(4655,5996,1)
(4914,3463,1)
(335,7589,1)
(9037,7033,1)
(3101,6491,1)
(8829,2893,1)
(1026,6576,1)
(5744,3241,1)
(1179,72,1)
(5673,7757,1)
(8497,2514,1)
(1636,7846,1)
(4392,2491,1)
(4162,3685,1)
(3626,576,1)
(5377,375,1)
(938,7316,1)
(1142,4744,1)
(8678,1502,1)
(4835,6344,1)
(5186,4196,1)
(7298,167,1)
(9156,4815,1)
(8000,2620,1)
(1601,5483,1)
(9125,1502,1)
(3412,147,1)
(409,5211,1)
(5698,824,1)
(8515,236,1)
(7527,2962,1)
(4910,401,1)
(2100,4017,1)
(7000,821,1)
(723,3940,1)
(4863,939,1)
(2320,2894,1)
(2001,2943,1)
(6157,6460,1)
(315,3012,1)
(5857,3260,1)
(5808,7246,1)
(8896,5526,1)
(5159,958,1)
(1287,5479,1)
(8038,606,1)
(8805,1765,1)
(519,4129,1)
(6890,4632,1)
(1611,7656,1)
(8290,4990,1)
(3977,6037,1)
(1804,1256,1)
(2337,675,1)
(3319,2449,1)
(8216,8552,1)
(8053,7127,1)
(2641,4793,1)
(5611,4928,1)
(7720,7073,1)
(3688,5199,1)
(7030,3487,1)
(5708,6824,1)
(3428,4420,1)
(8829,1489,1)
(3657,6114,1)
(2611,6983,1)
(2226,1965,1)
(6085,8362,1)
(3085,1298,1)
(8435,4672,1)
(5061,457,1)
(2869,4551,1)
(406,7736,1)
(2735,5516,1)
(3286,1502,1)
(1817,4928,1)
(7523,9122,1)
(6841,8969,1)
(2551,1934,1)
(6132,6093,1)
(6304,4551,1)
(6793,3324,1)
(171,429,1)
(90,4738,1)
(3259,2392,1)
(1135,6471,1)
(4998,7113,1)
(8339,9021,1)
(2387,571,1)
(5411,4928,1)
(8064,9107,1)
(9085,4928,1)
(1860,1464,1)
(8370,748,1)
(7157,3676,1)
(7869,9042,1)
(1282,600,1)
(9143,243,1)
(1879,7446,1)
(7865,5752,1)
(3302,8678,1)
(2123,8654,1)
(4994,7864,1)
(8456,1902,1)
(7737,8962,1)
(6048,4932,1)
(325,3920,1)
(6082,1119,1)
(1101,2329,1)
(2101,8380,1)
(1427,2652,1)
(4469,2373,1)
(4733,4552,1)
(6362,8972,1)
(3288,1502,1)
(2735,8368,1)
(9029,1491,1)
(3496,864,1)
(1165,7554,1)
(2413,8382,1)
(2871,2019,1)
(5591,4755,1)
(2598,7004,1)
(9040,6894,1)
(3877,6659,1)
(2126,3741,1)
(2222,4077,1)
(4790,8633,1)
(5610,4243,1)
(540,1432,1)
(4926,424,1)
(2008,1502,1)
(6741,2673,1)
(4131,1502,1)
(4498,6750,1)
(3251,1880,1)
(3694,7082,1)
(428,2236,1)
(6175,1502,1)
(5949,6771,1)
(4283,1599,1)
(4846,1591,1)
(8806,1502,1)
(3855,4928,1)
(2110,8362,1)
(8032,8545,1)
(6717,4050,1)
(7840,4974,1)
(373,8349,1)
(826,8266,1)
(8412,412,1)
(2671,5958,1)
(2477,1502,1)
(3401,7310,1)
(7027,7800,1)
(6955,212,1)
(2577,7872,1)
(2121,8232,1)
(7100,7728,1)
(5159,4928,1)
(3608,7349,1)
(4830,2013,1)
(3141,8362,1)
(7563,6047,1)
(8289,4478,1)
(1736,8840,1)
(271,3231,1)
(3320,2431,1)
(6134,8553,1)
(5595,2796,1)
(2263,2445,1)
(1622,3221,1)
(4489,9075,1)
(3550,1502,1)
(8093,1187,1)
(8002,5324,1)
(2377,5112,1)
(5451,6210,1)
(4572,5115,1)
(3757,8365,1)
(6224,2730,1)
(3538,4831,1)
(3993,1502,1)
(3847,3928,1)
(3083,6916,1)
(5294,5573,1)
(7444,1575,1)
(6348,1886,1)
(4542,1502,1)
(5997,5900,1)
(2629,2420,1)
(287,5343,1)
(6659,4928,1)
(5657,7811,1)
(9026,8188,1)
(8237,642,1)
(5428,1167,1)
(5328,64,1)
(7309,6868,1)
(6302,4466,1)
(8436,8384,1)
(5886,7389,1)
(6170,2095,1)
(4898,7299,1)
(5686,5902,1)
(2114,1863,1)
(2194,8782,1)
(5357,8861,1)
(2234,3282,1)
(321,2107,1)
(3497,7138,1)
(4873,6426,1)
(7598,6716,1)
(4313,2320,1)
(364,548,1)
(6253,6842,1)
(5467,362,1)
(1004,5398,1)
(2312,5431,1)
(3310,3148,1)
(1852,4242,1)
(1872,2044,1)
(7876,4227,1)
(9037,1128,1)
(6569,6047,1)
(5804,4801,1)
(7801,7222,1)
(952,1664,1)
(6257,1210,1)
(2985,4507,1)
(7567,244,1)
(5294,5244,1)
(7043,8357,1)
(2215,4607,1)
(5498,5751,1)
(871,4995,1)
(3704,3898,1)
(7991,3674,1)
(2789,58,1)
(2904,2878,1)
(3284,2541,1)
(2139,8020,1)
(5838,4579,1)
(2817,3304,1)
(941,4999,1)
(8203,3116,1)
(2865,5106,1)
(1438,5043,1)
(2071,785,1)
(8610,3850,1)
(645,1945,1)
(1994,3256,1)
(5954,5542,1)
(6786,8157,1)
(8938,3182,1)
(2752,419,1)
(5656,5909,1)
(5977,1502,1)
(3933,9031,1)
(3956,3636,1)
(6513,6774,1)
(1299,5266,1)
(3532,4266,1)
(336,6674,1)
(1599,5715,1)
(926,5202,1)
(7989,436,1)
(6208,4131,1)
(7378,1260,1)
(8343,4258,1)
(6535,6170,1)
(4794,1326,1)
(3108,3815,1)
(3648,1395,1)
(9122,2753,1)
(3541,4033,1)
(5660,7062,1)
(4658,7770,1)
(8644,3530,1)
(7089,4928,1)
(7665,2277,1)
(4725,5176,1)
(3763,251,1)
(8699,1365,1)
(49,1502,1)
(1187,2957,1)
(5214,6996,1)
(5635,787,1)
(5896,1502,1)
(7365,6122,1)
(5559,3142,1)
(7903,2533,1)
(5939,3877,1)
(8238,1600,1)
(4170,4671,1)
(8325,9123,1)
(880,8410,1)
(5298,2314,1)
(405,1159,1)
(5072,8362,1)
(5923,3774,1)
(3106,6269,1)
(1945,3895,1)
(6056,210,1)
(7810,1502,1)
(2976,4797,1)
(4984,8957,1)
(1635,2537,1)
(6205,8961,1)
(4415,8255,1)
(9104,9011,1)
(8194,1021,1)
(2370,1502,1)
(1619,4191,1)
(6705,1502,1)
(4490,4928,1)
(7875,2529,1)
(6574,8430,1)
(726,513,1)
(1147,5630,1)
(6143,2822,1)
(5901,6183,1)
(8644,8800,1)
(7829,1199,1)
(8189,1602,1)
(5108,1730,1)
(2782,7087,1)
(1004,1225,1)
(8260,4928,1)
(8472,6862,1)
(224,5698,1)
(1484,5149,1)
(8168,6289,1)
(2767,5553,1)
(3900,5509,1)
(2936,5226,1)
(3184,1502,1)
(4124,1502,1)
(5220,3665,1)
(5935,7953,1)
(7550,8353,1)
(5274,1435,1)
(5474,4928,1)
(451,8041,1)
(5608,4532,1)
(1766,7004,1)
(7801,7191,1)
(3811,1859,1)
(6463,6561,1)
(5406,5510,1)
(8461,1252,1)
(595,7998,1)
(8268,2476,1)
(8451,4928,1)
(5127,4393,1)
(361,6007,1)
(7973,7059,1)
(2574,5371,1)
(9152,4583,1)
(8829,1228,1)
(4669,4989,1)
(8576,5650,1)
(3583,6027,1)
(2889,6968,1)
(7517,8339,1)
(7738,2140,1)
(8293,3899,1)
(2605,7389,1)
(5282,4598,1)
(8254,6977,1)
(111,1917,1)
(7065,7841,1)
(6149,7267,1)
(1003,93,1)
(8943,4222,1)
(1690,1502,1)
(660,8902,1)
(4966,7179,1)
(9124,7019,1)
(7896,3809,1)
(2599,2380,1)
(6616,6330,1)
(6923,6986,1)
(166,1502,1)
(3828,5057,1)
(4263,7779,1)
(1926,4736,1)
(6763,8673,1)
(2812,6454,1)
(212,942,1)
(2622,1043,1)
(5350,1066,1)
(6197,1497,1)
(3224,1308,1)
(6348,4928,1)
(1050,868,1)
(4265,2696,1)
(8827,2549,1)
(5005,3955,1)
(7994,5869,1)
(4819,792,1)
(579,7924,1)
(1558,7313,1)
(6304,3652,1)
(2368,5829,1)
(3202,1390,1)
(6682,9121,1)
(1027,3583,1)
(6929,6490,1)
(9145,6047,1)
(8267,8313,1)
(945,7738,1)
(8495,6482,1)
(6265,1008,1)
(6,3938,1)
(4686,3139,1)
(6035,4493,1)
(3608,4598,1)
(7654,6881,1)
(2843,6333,1)
(1409,7030,1)
(6912,4928,1)
(2661,1977,1)
(955,3620,1)
(5649,1997,1)
(4457,900,1)
(4388,6738,1)
(4514,6456,1)
(1034,8555,1)
(1397,8312,1)
(4494,1992,1)
(925,7466,1)
(7467,2212,1)
(7016,4928,1)
(5774,2666,1)
(4808,5902,1)
(4847,6238,1)
(2309,5878,1)
(3549,8904,1)
(3515,8015,1)
(4856,8615,1)
(1222,8219,1)
(7587,8675,1)
(1770,5246,1)
(2815,2898,1)
(1080,407,1)
(4437,6560,1)
(8385,7479,1)
(3520,2826,1)
(6587,8762,1)
(2248,1502,1)
(3087,404,1)
(6016,4306,1)
(8698,1502,1)
(1803,1875,1)
(6304,7092,1)
(8680,6562,1)
(4313,1988,1)
(6988,3416,1)
(4437,5115,1)
(4459,8980,1)
(3944,8287,1)
(8570,8276,1)
(1196,2080,1)
(4129,347,1)
(6568,287,1)
(2733,2421,1)
(43,4091,1)
(4601,3925,1)
(829,4685,1)
(5703,3156,1)
(4433,7398,1)
(5941,167,1)
(5369,7272,1)
(7811,1763,1)
(6709,1118,1)
(6490,3868,1)
(6987,997,1)
(1716,3718,1)
(758,4048,1)
(7060,7329,1)
(5835,1502,1)
(5148,127,1)
(7129,6559,1)
(8838,5528,1)
(7256,5082,1)
(1654,702,1)
(7737,8172,1)
(6968,5804,1)
(5945,1502,1)
(176,4928,1)
(6298,5225,1)
(6304,8987,1)
(1155,5759,1)
(2974,565,1)
(2056,7128,1)
(2647,4929,1)
(4816,492,1)
(8556,10,1)
(5996,141,1)
(2402,559,1)
(846,3572,1)
(8991,3511,1)
(8046,6534,1)
(5628,2265,1)
(7960,8678,1)
(4200,4614,1)
(372,5902,1)
(5932,7000,1)
(7693,2562,1)
(3591,8545,1)
(5974,2484,1)
(7533,4772,1)
(2441,3163,1)
(8067,3272,1)
(3550,7711,1)
(3794,5915,1)
(6094,4928,1)
(6192,8167,1)
(697,5763,1)
(5555,2218,1)
(5296,2242,1)
(4460,6143,1)
(141,9060,1)
(984,5656,1)
(1124,403,1)
(4878,7812,1)
(1867,122,1)
(3480,4452,1)
(3213,6653,1)
(948,2582,1)
(1570,1680,1)
(3813,2363,1)
(905,2262,1)
(9052,2357,1)
(5942,4277,1)
(6340,7751,1)
(4477,8048,1)
(2092,5028,1)
(1344,303,1)
(3398,4223,1)
(6862,209,1)
(3965,8382,1)
(7228,975,1)
(5743,682,1)
(7367,1519,1)
(2320,598,1)
(1469,3976,1)
(1249,2111,1)
(3591,7821,1)
(20,2664,1)
(3311,8418,1)
(5852,8044,1)
(5769,5648,1)
(8208,8108,1)
(6846,1753,1)
(7597,7355,1)
(3681,2624,1)
(5969,8922,1)
(8768,9051,1)
(2218,1982,1)
(6075,5043,1)
(2320,1128,1)
(1539,1939,1)
(348,1830,1)
(3081,5037,1)
(3951,1422,1)
(2034,4710,1)
(890,1502,1)
(5232,8279,1)
(3047,7995,1)
(6853,6870,1)
(833,8910,1)
(2893,456,1)
(5611,5312,1)
(8053,6014,1)
(3370,2282,1)
(5668,8229,1)
(3953,4928,1)
(8527,7373,1)
(4143,6591,1)
(432,4765,1)
(455,8678,1)
(4851,5279,1)
(777,4176,1)
(8055,3843,1)
(5835,2258,1)
(669,387,1)
(8919,723,1)
(7418,4944,1)
(2885,2089,1)
(3724,179,1)
(1148,8549,1)
(6909,406,1)
(652,2235,1)
(6108,8833,1)
(269,3310,1)
(1532,2609,1)
(1235,1492,1)
(799,1515,1)
(1991,6047,1)
(6144,6984,1)
(8713,4066,1)
(215,3584,1)
(1264,3337,1)
(8409,1437,1)
(4943,9022,1)
(2013,4928,1)
(6639,4138,1)
(1529,3114,1)
(3903,8187,1)
(1011,7536,1)
(2735,2919,1)
(5645,2890,1)
(5646,7681,1)
(5785,6017,1)
(2688,1282,1)
(7991,2893,1)
(8621,6468,1)
(5742,8362,1)
(5745,645,1)
(493,5558,1)
(8945,2158,1)
(8745,4788,1)
(3885,5253,1)
(2464,5110,1)
(1565,5538,1)
(2854,7345,1)
(3255,7804,1)
(6367,8083,1)
(3517,3167,1)
(2461,721,1)
(4611,5425,1)
(338,7352,1)
(3836,2635,1)
(1538,1515,1)
(1402,7468,1)
(2058,2684,1)
(1905,8935,1)
(4475,8893,1)
(4280,4928,1)
(1951,1202,1)
(6193,6015,1)
(4607,8698,1)
(1116,2954,1)
(8872,4705,1)
(9037,1867,1)
(920,2808,1)
(7804,4279,1)
(494,5071,1)
(4313,504,1)
(1558,6290,1)
(1977,4928,1)
(5493,7217,1)
(5367,2016,1)
(2196,6378,1)
(8474,8585,1)
(6048,8056,1)
(8144,8244,1)
(8700,4724,1)
(4618,1183,1)
(6813,8362,1)
(2699,5902,1)
(3111,8618,1)
(5359,4230,1)
(1278,7401,1)
(2401,4928,1)
(1416,1391,1)
(5878,5435,1)
(8394,3995,1)
(1952,2447,1)
(6529,2166,1)
(8392,4928,1)
(129,6808,1)
(8829,8678,1)
(7303,3917,1)
(1317,2534,1)
(7991,3313,1)
(8437,2074,1)
(5603,3595,1)
(8510,5469,1)
(8615,5091,1)
(1772,5119,1)
(3989,466,1)
(6852,8788,1)
(1245,6356,1)
(2381,90,1)
(443,1126,1)
(888,3216,1)
(1348,6763,1)
(3337,3942,1)
(6405,6713,1)
(6792,4594,1)
(6246,3210,1)
(3616,4768,1)
(7652,1502,1)
(7082,4105,1)
(1600,4967,1)
(4787,1502,1)
(8392,1163,1)
(2035,6047,1)
(8114,6087,1)
(8509,6664,1)
(4122,4412,1)
(6533,1589,1)
(2482,1976,1)
(4649,2967,1)
(9127,2771,1)
(653,8362,1)
(688,4441,1)
(371,7480,1)
(8469,233,1)
(5461,3924,1)
(2571,1502,1)
(1696,8193,1)
(1466,2038,1)
(2354,9069,1)
(4738,4928,1)
(740,1680,1)
(8997,9140,1)
(7705,1539,1)
(6695,2611,1)
(8829,3496,1)
(173,1822,1)
(5294,3624,1)
(3644,3646,1)
(3533,6861,1)
(6103,7710,1)
(6823,3667,1)
(4415,3717,1)
(2735,8152,1)
(3672,2202,1)
(2699,840,1)
(5308,2811,1)
(7159,416,1)
(3049,5447,1)
(3456,1502,1)
(1727,1502,1)
(8498,5266,1)
(3094,2704,1)
(2031,6081,1)
(6281,8207,1)
(1143,5634,1)
(1754,8362,1)
(2894,8386,1)
(6607,4928,1)
(9151,8976,1)
(5294,4373,1)
(1415,7321,1)
(7254,4698,1)
(385,9052,1)
(6541,6978,1)
(2463,4010,1)
(5448,2512,1)
(818,1566,1)
(6839,8928,1)
(4233,2714,1)
(4942,6975,1)
(1986,8806,1)
(349,8548,1)
(5259,4928,1)
(6285,4928,1)
(8691,1515,1)
(3647,3047,1)
(6994,6284,1)
(3574,6840,1)
(7476,361,1)
(2150,7449,1)
(3338,1657,1)
(4390,1502,1)
(751,8938,1)
(4071,3367,1)
(6931,7115,1)
(8728,1502,1)
(6165,4745,1)
(5923,4928,1)
(8942,4824,1)
(118,6172,1)
(4236,997,1)
(5588,8155,1)
(2080,5043,1)
(732,6072,1)
(5674,5240,1)
(3199,2772,1)
(8827,118,1)
(6899,5082,1)
(3130,5452,1)
(990,90,1)
(6032,1766,1)
(4650,1133,1)
(2780,6001,1)
(7494,142,1)
(5261,6792,1)
(1061,3401,1)
(417,6193,1)
(5826,1185,1)
(2583,6852,1)
(1085,1254,1)
(8895,390,1)
(8464,4928,1)
(1652,6906,1)
(2820,502,1)
(2558,1299,1)
(264,3775,1)
(5170,7444,1)
(852,4928,1)
(8908,6003,1)
(2756,7848,1)
(8658,6847,1)
(8064,2230,1)
(4985,1502,1)
(5108,3770,1)
(5154,1302,1)
(2434,6264,1)
(1906,1381,1)
(49,1827,1)
(2969,1502,1)
(7105,770,1)
(4127,7861,1)
(2211,387,1)
(3753,1502,1)
(1988,5559,1)
(3318,6718,1)
(3567,1186,1)
(5614,9116,1)
(6628,2986,1)
(1232,395,1)
(1257,4749,1)
(791,1726,1)
(211,8637,1)
(748,5241,1)
(1651,6887,1)
(5417,2705,1)
(3148,4623,1)
(2763,112,1)
(7689,4928,1)
(4466,6524,1)
(6003,1502,1)
(1935,18,1)
(2028,3082,1)
(8989,2944,1)
(3224,3941,1)
(1308,5481,1)
(7050,987,1)
(7442,5990,1)
(5497,2840,1)
(5434,8717,1)
(4680,3578,1)
(8039,7029,1)
(8091,8179,1)
(8032,8283,1)
(3390,2152,1)
(2288,7103,1)
(7911,4172,1)
(1134,6454,1)
(7779,1441,1)
(1271,6370,1)
(209,6047,1)
(5472,6620,1)
(959,6025,1)
(1248,2661,1)
(2078,7499,1)
(1986,311,1)
(838,8494,1)
(5599,4051,1)
(8198,3018,1)
(5892,8668,1)
(6460,2240,1)
(8807,8123,1)
(9099,768,1)
(5117,1003,1)
(2548,1502,1)
(1874,3680,1)
(5118,1502,1)
(6131,5051,1)
(2494,1542,1)
(712,5115,1)
(2177,5984,1)
(4298,8166,1)
(6562,9076,1)
(5398,5934,1)
(2833,2851,1)
(4594,3300,1)
(7780,4896,1)
(2448,1971,1)
(55,1502,1)
(6248,5872,1)
(2664,8153,1)
(3631,165,1)
(7810,3384,1)
(2408,4450,1)
(1236,7458,1)
(7011,4733,1)
(7221,7954,1)
(2517,4884,1)
(7212,1405,1)
(1231,8547,1)
(8973,4928,1)
(4018,1008,1)
(447,5850,1)
(5427,2111,1)
(3814,3308,1)
(6112,753,1)
(3002,4147,1)
(6407,279,1)
(1305,5368,1)
(6807,6582,1)
(7930,7570,1)
(3394,8771,1)
(2470,2014,1)
(4468,5949,1)
(8423,8362,1)
(5520,5982,1)
(8604,4742,1)
(8308,7020,1)
(5930,4479,1)
(1979,3972,1)
(6939,4928,1)
(822,1502,1)
(884,7004,1)
(6334,1902,1)
(1494,7240,1)
(6696,4188,1)
(8454,1515,1)
(8199,1502,1)
(5500,5485,1)
(6526,7197,1)
(5113,4928,1)
(8050,6503,1)
(6748,4408,1)
(1960,4765,1)
(7421,4176,1)
(2477,4546,1)
(6026,8566,1)
(1128,6421,1)
(5594,5360,1)
(9063,2020,1)
(8493,36,1)
(5864,6969,1)
(5183,2605,1)
(4383,2367,1)
(5975,1315,1)
(4437,8188,1)
(4980,855,1)
(139,450,1)
(1211,6476,1)
(7637,1508,1)
(4482,2712,1)
(559,2188,1)
(6796,876,1)
(6482,7468,1)
(4442,4928,1)
(3098,4921,1)
(751,5506,1)
(4095,2793,1)
(1076,5102,1)
(5514,2464,1)
(5801,3138,1)
(120,2048,1)
(7847,7858,1)
(8961,2842,1)
(2669,3007,1)
(3647,7995,1)
(2773,1120,1)
(4436,7647,1)
(1723,8175,1)
(130,2460,1)
(7773,6946,1)
(3737,6209,1)
(5162,2879,1)
(8520,1502,1)
(5709,4928,1)
(4517,8569,1)
(4545,4928,1)
(5623,3583,1)
(3639,7833,1)
(7919,7021,1)
(3454,1068,1)
(6288,6436,1)
(31,8362,1)
(3125,4484,1)
(6508,2998,1)
(7819,2298,1)
(4980,5702,1)
(5027,5931,1)
(5294,6981,1)
(1752,3994,1)
(7504,6061,1)
(2269,3992,1)
(8546,2106,1)
(498,817,1)
(3870,4562,1)
(634,6078,1)
(1433,949,1)
(1487,1642,1)
(7321,5587,1)
(3302,4986,1)
(8239,7892,1)
(7970,8988,1)
(4075,8323,1)
(6287,2084,1)
(1536,5129,1)
(585,6817,1)
(1995,8498,1)
(1686,4760,1)
(514,4945,1)
(1019,96,1)
(3749,5549,1)
(6633,5585,1)
(4124,8024,1)
(2869,1228,1)
(1452,1444,1)
(5234,2496,1)
(4512,7143,1)
(495,4510,1)
(5543,3984,1)
(6794,1882,1)
(6707,5052,1)
(8800,4590,1)
(7229,46,1)
(1798,4536,1)
(1026,4928,1)
(2993,2464,1)
(3180,8638,1)
(5654,7378,1)
(7699,5113,1)
(2538,550,1)
(6096,1804,1)
(5259,1502,1)
(2187,7904,1)
(5003,8088,1)
(4284,1502,1)
(6536,5816,1)
(7780,5273,1)
(822,4928,1)
(3603,334,1)
(3654,4971,1)
(7979,3333,1)
(6094,1502,1)
(1689,5189,1)
(7766,7692,1)
(3208,8953,1)
(8450,5867,1)
(1814,832,1)
(2788,811,1)
(2327,4985,1)
(7986,3002,1)
(5531,1528,1)
(123,5499,1)
(8421,4928,1)
(1664,5895,1)
(3527,8419,1)
(759,2796,1)
(434,2930,1)
(5451,862,1)
(6351,3320,1)
(3476,5932,1)
(1509,2629,1)
(2331,6894,1)
(2346,9025,1)
(8804,1803,1)
(6127,5504,1)
(8800,3721,1)
(8219,383,1)
(5798,905,1)
(9005,798,1)
(2214,6769,1)
(2197,2699,1)
(6228,7252,1)
(4678,2898,1)
(7980,3826,1)
(8890,8004,1)
(135,6431,1)
(5354,7662,1)
(2735,4240,1)
(2007,7509,1)
(4541,1237,1)
(3298,8172,1)
(5433,995,1)
(149,1356,1)
(5172,9139,1)
(5247,6354,1)
(7256,3905,1)
(6986,8425,1)
(2761,6501,1)
(4969,2252,1)
(2056,1502,1)
(9039,5869,1)
(5909,2568,1)
(7098,1373,1)
(2668,2651,1)
(6493,1502,1)
(8181,734,1)
(7295,3223,1)
(5389,6502,1)
(6718,4164,1)
(5750,2422,1)
(6304,1919,1)
(5463,6844,1)
(6676,747,1)
(7098,4928,1)
(6517,3668,1)
(609,7252,1)
(2266,2883,1)
(7840,1731,1)
(8612,9099,1)
(3630,1789,1)
(2417,6431,1)
(686,1251,1)
(1904,4928,1)
(6304,6465,1)
(5336,1502,1)
(8282,4252,1)
(1319,4454,1)
(605,8990,1)
(4164,7690,1)
(2330,6580,1)
(7046,2893,1)
(2459,6193,1)
(2127,1124,1)
(6096,2637,1)
(6133,8165,1)
(2735,41,1)
(9102,4928,1)
(7943,2984,1)
(263,8724,1)
(169,2621,1)
(285,2874,1)
(2816,4097,1)
(4635,6000,1)
(3882,6160,1)
(4584,2187,1)
(5351,6481,1)
(8402,1502,1)
(7645,1269,1)
(4381,6601,1)
(6502,384,1)
(8395,8140,1)
(3382,5875,1)
(2594,6299,1)
(2787,7090,1)
(8518,2401,1)
(6056,3232,1)
(2784,4088,1)
(2130,3659,1)
(9037,598,1)
(2256,115,1)
(6692,7659,1)
(4437,6988,1)
(2681,7696,1)
(5329,3583,1)
(7601,3965,1)
(5694,8035,1)
(14,7904,1)
(6851,5300,1)
(3306,2634,1)
(3156,4154,1)
(1925,1922,1)
(556,7748,1)
(6209,779,1)
(8638,9147,1)
(4789,445,1)
(3799,525,1)
(4282,4307,1)
(5294,8037,1)
(7376,694,1)
(8924,8028,1)
(547,3303,1)
(7076,3144,1)
(8356,1502,1)
(8901,1855,1)
(1210,6057,1)
(8272,28,1)
(5478,6800,1)
(9140,531,1)
(1296,7108,1)
(5945,4928,1)
(2295,4581,1)
(3643,4470,1)
(2659,1885,1)
(5630,927,1)
(8731,1797,1)
(6459,247,1)
(5014,8354,1)
(5988,4928,1)
(9102,1502,1)
(4653,4765,1)
(3646,5048,1)
(1246,1238,1)
(6945,7004,1)
(3937,7588,1)
(3272,2792,1)
(7637,3902,1)
(7216,2490,1)
(7046,3674,1)
(1962,7096,1)
(5422,4167,1)
(3285,6670,1)
(3462,3626,1)
(4740,1502,1)
(3826,4691,1)
(8668,8858,1)
(5614,8428,1)
(4188,4445,1)
(662,4928,1)
(4481,3147,1)
(4296,7648,1)
(2301,4928,1)
(3463,9067,1)
(8625,1541,1)
(7838,351,1)
(6932,5908,1)
(1095,59,1)
(513,4319,1)
(3340,3735,1)
(1755,4928,1)
(2090,1164,1)
(235,3757,1)
(5294,4551,1)
(7229,6179,1)
(6939,8621,1)
(5177,1515,1)
(5845,7233,1)
(6364,6768,1)
(2092,2530,1)
(5279,7827,1)
(1572,5218,1)
(5908,168,1)
(2311,8534,1)
(4977,8530,1)
(6058,4202,1)
(1988,8188,1)
(1252,6590,1)
(5258,4928,1)
(453,2110,1)
(1646,6047,1)
(5294,4955,1)
(8278,3865,1)
(2847,2647,1)
(838,4950,1)
(3984,7867,1)
(2914,3726,1)
(3411,5115,1)
(449,6816,1)
(6824,7964,1)
(3647,5902,1)
(6324,8194,1)
(7767,2823,1)
(7932,1897,1)
(3729,3692,1)
(7468,7148,1)
(4575,6160,1)
(4703,1491,1)
(8319,5247,1)
(6005,1502,1)
(21,5018,1)
(3836,6414,1)
(2476,6887,1)
(778,8576,1)
(4257,425,1)
(1395,7625,1)
(5851,3385,1)
(2578,1794,1)
(133,2959,1)
(4577,8539,1)
(6620,4928,1)
(5086,4928,1)
(6530,1771,1)
(9037,3313,1)
(4173,2084,1)
(5452,4649,1)
(6249,3667,1)
(3269,5971,1)
(9062,4744,1)
(6599,8307,1)
(2973,806,1)
(2869,1489,1)
(7458,8999,1)
(9051,877,1)
(7225,5879,1)
(7776,3564,1)
(5880,8316,1)
(5769,1017,1)
(7400,5025,1)
(289,5912,1)
(4217,2744,1)
(993,3222,1)
(6737,5534,1)
(6256,3854,1)
(7282,1029,1)
(78,7061,1)
(4155,8202,1)
(6427,3716,1)
(3411,8678,1)
(6480,3243,1)
(8762,2183,1)
(132,4383,1)
(3781,5683,1)
(4814,8993,1)
(5461,5694,1)
(4923,7428,1)
(4150,3975,1)
(5821,5464,1)
(4873,1502,1)
(9138,497,1)
(7658,8228,1)
(1385,1502,1)
(7922,8148,1)
(3385,6725,1)
(5336,6779,1)
(6749,3326,1)
(5718,162,1)
(7069,5738,1)
(7714,3616,1)
(5025,8278,1)
(518,1037,1)
(4288,3912,1)
(2172,8519,1)
(7894,1502,1)
(8275,5260,1)
(7196,6198,1)
(8809,5761,1)
(6476,8035,1)
(1298,3583,1)
(4435,7603,1)
(2717,2570,1)
(5602,2646,1)
(2262,5043,1)
(2942,1502,1)
(4754,4746,1)
(1891,2508,1)
(8869,6766,1)
(5147,8109,1)
(8639,8100,1)
(985,8092,1)
(3847,2325,1)
(5294,7885,1)
(2641,3096,1)
(4988,6682,1)
(4029,6960,1)
(9125,3253,1)
(5429,2566,1)
(1880,1962,1)
(4004,5203,1)
(8371,4179,1)
(2048,1621,1)
(5747,1685,1)
(7354,2698,1)
(5550,2898,1)
(4142,3837,1)
(6304,1616,1)
(1922,8469,1)
(4107,4916,1)
(2453,7683,1)
(9117,8448,1)
(2735,3524,1)
(828,5421,1)
(8759,317,1)
(5282,81,1)
(1012,3765,1)
(3619,393,1)
(5444,663,1)
(727,4928,1)
(3230,5043,1)
(4991,5569,1)
(738,6841,1)
(3802,8868,1)
(9153,7104,1)
(6607,1502,1)
(3410,4928,1)
(5294,2641,1)
(4437,8987,1)
(1556,4495,1)
(3130,4649,1)
(5714,8682,1)
(8918,8631,1)
(2506,5499,1)
(953,213,1)
(7200,4190,1)
(5083,31,1)
(6896,5356,1)
(8519,5043,1)
(2315,2215,1)
(3372,913,1)
(7575,8975,1)
(8779,2766,1)
(1915,6065,1)
(1787,2154,1)
(2737,4928,1)
(1750,2006,1)
(5158,6325,1)
(5680,1502,1)
(422,5281,1)
(8270,1297,1)
(538,5577,1)
(2191,2123,1)
(7399,7273,1)
(2396,582,1)
(5050,3771,1)
(5787,5924,1)
(2843,1502,1)
(8280,4928,1)
(4412,2135,1)
(6458,3113,1)
(5653,847,1)
(6610,4892,1)
(5100,7311,1)
(8633,1502,1)
(7280,3705,1)
(8906,2503,1)
(8357,1723,1)
(8336,2377,1)
(5903,8246,1)
(3618,1517,1)
(2103,863,1)
(1330,1472,1)
(6958,5390,1)
(4081,719,1)
(550,1328,1)
(4242,7689,1)
(3329,5719,1)
(4576,431,1)
(721,4928,1)
(7214,7439,1)
(1137,3339,1)
(8845,7911,1)
(2699,3177,1)
(7089,6047,1)
(2171,1502,1)
(220,6100,1)
(2087,1340,1)
(5785,1908,1)
(7043,4928,1)
(7472,3657,1)
(81,3749,1)
(2155,4245,1)
(8350,4964,1)
(4324,5781,1)
(4192,3766,1)
(4426,3242,1)
(2492,1338,1)
(3323,3495,1)
(2952,1796,1)
(7511,7602,1)
(9040,2331,1)
(6651,6343,1)
(6975,6493,1)
(8881,6718,1)
(7059,6891,1)
(8071,1502,1)
(1788,7435,1)
(5294,1919,1)
(1634,1305,1)
(2471,6950,1)
(8231,8011,1)
(4472,4986,1)
(7694,3476,1)
(2869,1128,1)
(8060,4790,1)
(6396,260,1)
(210,941,1)
(4910,1502,1)
(4407,4611,1)
(9133,1184,1)
(733,1785,1)
(450,5470,1)
(7203,6688,1)
(4617,6420,1)
(3343,8857,1)
(6447,2992,1)
(8393,802,1)
(606,6316,1)
(7315,2355,1)
(1029,8008,1)
(2424,3943,1)
(3364,3220,1)
(3302,1591,1)
(1552,4900,1)
(8422,8555,1)
(5977,4928,1)
(3569,5625,1)
(2516,703,1)
(4948,1925,1)
(7372,7512,1)
(6030,4043,1)
(1100,5496,1)
(3791,2746,1)
(8990,4928,1)
(5571,709,1)
(3880,6047,1)
(7953,4085,1)
(3866,7516,1)
(8923,3237,1)
(4826,1887,1)
(1013,2016,1)
(1988,4551,1)
(6198,8849,1)
(7238,8678,1)
(4480,476,1)
(135,1045,1)
(4227,4798,1)
(774,4591,1)
(3487,4086,1)
(8589,2094,1)
(4147,1157,1)
(3222,8574,1)
(1590,3420,1)
(7725,7004,1)
(4694,5417,1)
(3025,4943,1)
(2494,6047,1)
(1785,3566,1)
(6361,2851,1)
(2361,5517,1)
(1342,4074,1)
(7723,4058,1)
(3947,7500,1)
(2912,3255,1)
(693,4928,1)
(4204,3370,1)
(8057,2698,1)
(5597,2317,1)
(6857,7547,1)
(6101,7361,1)
(4243,1958,1)
(549,1064,1)
(712,2894,1)
(131,2267,1)
(5561,1470,1)
(6969,8304,1)
(877,4928,1)
(1254,6615,1)
(5185,3455,1)
(441,3725,1)
(5787,4928,1)
(4257,6292,1)
(933,1502,1)
(3495,1333,1)
(8526,3853,1)
(6047,3112,1)
(5484,4576,1)
(5242,2932,1)
(3552,9141,1)
(3302,7148,1)
(3120,2873,1)
(934,3933,1)
(3080,259,1)
(5078,4928,1)
(8893,5842,1)
(372,5043,1)
(8867,5085,1)
(4315,1378,1)
(930,4928,1)
(2735,7840,1)
(3411,8828,1)
(1027,1502,1)
(2571,4928,1)
(4448,4928,1)
(8614,2273,1)
(9133,7928,1)
(4437,5244,1)
(3668,7437,1)
(2858,6236,1)
(7565,1515,1)
(9026,4551,1)
(4038,2244,1)
(8448,3005,1)
(6312,2201,1)
(6448,9084,1)
(4673,7423,1)
(606,8940,1)
(2600,2539,1)
(4293,5195,1)
(7670,2257,1)
(7762,1502,1)
(3021,6855,1)
(317,1705,1)
(5941,2427,1)
(6973,4405,1)
(2735,3957,1)
(7093,4928,1)
(3832,5796,1)
(5717,3862,1)
(1478,6029,1)
(4427,5690,1)
(6181,37,1)
(4437,4373,1)
(6506,4842,1)
(8549,8426,1)
(3941,3978,1)
(6731,1495,1)
(4834,9130,1)
(8757,4970,1)
(1610,63,1)
(4443,3953,1)
(2792,6431,1)
(393,334,1)
(6919,4327,1)
(690,5789,1)
(6418,6,1)
(7857,8958,1)
(741,755,1)
(7548,3893,1)
(3777,6047,1)
(1247,866,1)
(2735,6023,1)
(923,8822,1)
(569,9095,1)
(2714,6329,1)
(6262,1502,1)
(8656,446,1)
(6510,781,1)
(6084,2884,1)
(2576,1510,1)
(1042,1502,1)
(7055,4751,1)
(6378,7397,1)
(3993,4928,1)
(1402,3583,1)
(1988,6654,1)
(2573,6955,1)
(4559,6124,1)
(1953,1172,1)
(4545,1502,1)
(6594,5266,1)
(1520,2831,1)
(2550,5960,1)
(370,4928,1)
(1907,2773,1)
(3514,4475,1)
(6409,8626,1)
(4881,7893,1)
(7762,6047,1)
(845,8832,1)
(3534,2622,1)
(4905,1659,1)
(4215,6245,1)
(6808,2262,1)
(3627,3864,1)
(201,4300,1)
(521,4928,1)
(8084,349,1)
(8544,7523,1)
(5492,5677,1)
(8003,1529,1)
(6786,5043,1)
(2221,6508,1)
(6222,2429,1)
(8329,4744,1)
(8024,3389,1)
(1636,7948,1)
(4158,7645,1)
(2067,5043,1)
(6501,454,1)
(3805,5282,1)
(2173,2404,1)
(6702,1502,1)
(2735,1644,1)
(4309,8952,1)
(5294,1255,1)
(3527,8545,1)
(3553,1825,1)
(1771,2276,1)
(5990,6786,1)
(3796,4379,1)
(7998,1833,1)
(2493,12,1)
(3409,6291,1)
(4829,6223,1)
(7593,4928,1)
(1809,7760,1)
(1356,5251,1)
(211,6070,1)
(7097,5299,1)
(5464,8113,1)
(1228,1502,1)
(7630,690,1)
(8685,5308,1)
(3361,3150,1)
(3193,406,1)
(7596,1334,1)
(6559,4157,1)
(7689,1502,1)
(777,355,1)
(8892,2607,1)
(6750,2740,1)
(6473,5094,1)
(5554,1587,1)
(6729,8058,1)
(4313,7046,1)
(3005,4485,1)
(1620,4928,1)
(6078,3923,1)
(2604,2595,1)
(7422,1016,1)
(5392,961,1)
(4643,1492,1)
(7711,5729,1)
(1392,4928,1)
(6706,8540,1)
(8415,8668,1)
(7972,7442,1)
(606,7232,1)
(8985,3097,1)
(38,5833,1)
(343,5250,1)
(8123,8620,1)
(391,6466,1)
(7046,1591,1)
(1411,166,1)
(1405,5490,1)
(7181,831,1)
(8471,7603,1)
(5770,5704,1)
(6433,1488,1)
(6241,6514,1)
(803,4924,1)
(8421,1502,1)
(8428,4941,1)
(1423,4744,1)
(3434,350,1)
(6701,7438,1)
(5895,4740,1)
(4932,841,1)
(124,2636,1)
(2954,1502,1)
(6680,2825,1)
(1424,3152,1)
(6892,6930,1)
(7693,3792,1)
(7141,1448,1)
(7451,6441,1)
(1040,943,1)
(6198,2898,1)
(5875,4744,1)
(7934,1653,1)
(7683,2709,1)
(6021,7464,1)
(8689,8128,1)
(4912,1502,1)
(6639,5939,1)
(3642,1206,1)
(5412,1890,1)
(7977,4294,1)
(5832,802,1)
(7121,1951,1)
(6950,6321,1)
(543,1502,1)
(7957,3558,1)
(7743,328,1)
(3612,3985,1)
(6792,1154,1)
(4461,3049,1)
(693,8711,1)
(3345,2546,1)
(9023,3664,1)
(5484,6492,1)
(1286,5153,1)
(4319,5426,1)
(817,7634,1)
(3203,8879,1)
(484,1979,1)
(8077,4859,1)
(5730,8847,1)
(5889,2009,1)
(4437,1919,1)
(5080,4928,1)
(2542,8597,1)
(682,591,1)
(8459,2712,1)
(5115,1877,1)
(2189,404,1)
(2806,5048,1)
(6443,6632,1)
(4472,7092,1)
(1418,2346,1)
(4953,6753,1)
(740,1570,1)
(1389,4928,1)
(3457,4928,1)
(6889,7004,1)
(4074,1894,1)
(5646,2495,1)
(3324,3406,1)
(5993,1322,1)
(4723,7262,1)
(7671,2925,1)
(3426,4304,1)
(3379,4928,1)
(4007,2671,1)
(1947,1294,1)
(8195,2209,1)
(505,9039,1)
(2438,9096,1)
(5797,3663,1)
(1751,8674,1)
(2294,7068,1)
(621,5513,1)
(5294,4853,1)
(7656,1502,1)
(637,1801,1)
(237,6798,1)
(8202,7921,1)
(4266,830,1)
(7479,3617,1)
(8829,7092,1)
(5346,7365,1)
(712,1591,1)
(5673,8083,1)
(4362,8651,1)
(8047,4870,1)
(7256,153,1)
(811,7488,1)
(5933,632,1)
(8520,2601,1)
(7468,6465,1)
(3555,1619,1)
(3470,2956,1)
(8338,6732,1)
(7381,1515,1)
(7521,3583,1)
(1631,8686,1)
(8991,8073,1)
(3356,5904,1)
(9037,8987,1)
(7288,5806,1)
(2925,1502,1)
(2013,1502,1)
(5062,3829,1)
(525,5429,1)
(1612,2604,1)
(685,3952,1)
(3308,2414,1)
(1514,1661,1)
(2673,1502,1)
(8013,8211,1)
(9088,718,1)
(1170,1502,1)
(3550,4928,1)
(1822,6009,1)
(8928,221,1)
(8460,2279,1)
(3539,2175,1)
(4745,1368,1)
(2909,8381,1)
(3990,8181,1)
(583,34,1)
(5141,1502,1)
(3942,1502,1)
(5524,8213,1)
(7745,8097,1)
(2801,5266,1)
(5581,1583,1)
(4866,7918,1)
(8052,8400,1)
(3113,2246,1)
(176,1502,1)
(2230,4320,1)
(3838,3073,1)
(4900,5387,1)
(780,5371,1)
(6991,581,1)
(6294,2983,1)
(4827,3217,1)
(7910,1502,1)
(2754,3398,1)
(3764,7006,1)
(8822,5141,1)
(3065,2941,1)
(403,2705,1)
(2656,6260,1)
(8510,5268,1)
(7179,3062,1)
(161,3430,1)
(3171,1293,1)
(2473,4928,1)
(8394,6104,1)
(4792,1220,1)
(3124,778,1)
(2896,4771,1)
(8099,9114,1)
(3511,6270,1)
(2204,7774,1)
(8203,3218,1)
(6200,8505,1)
(5437,3543,1)
(2869,7092,1)
(302,187,1)
(5738,926,1)
(4508,5134,1)
(9056,17,1)
(737,1162,1)
(2937,1502,1)
(8178,2898,1)
(7485,6569,1)
(2967,5554,1)
(1066,29,1)
(6249,7743,1)
(3870,1502,1)
(3493,5519,1)
(2623,3829,1)
(5194,5409,1)
(4305,2633,1)
(6141,4515,1)
(8215,4709,1)
(521,8327,1)
(2328,7344,1)
(2602,1502,1)
(2543,4597,1)
(8425,5973,1)
(7498,2286,1)
(2460,5336,1)
(3103,5557,1)
(630,4914,1)
(8791,1502,1)
(644,606,1)
(1708,4928,1)
(8424,1288,1)
(4341,2126,1)
(1616,2733,1)
(8324,4306,1)
(5986,5236,1)
(545,8836,1)
(3890,3862,1)
(970,6712,1)
(138,6545,1)
(7271,3839,1)
(2981,1719,1)
(119,9077,1)
(4565,4928,1)
(5992,4116,1)
(4479,2787,1)
(5222,1879,1)
(5041,1615,1)
(7991,8678,1)
(8374,3716,1)
(2863,2268,1)
(8858,3437,1)
(6642,3098,1)
(9037,5244,1)
(6604,3963,1)
(5577,2066,1)
(8848,1419,1)
(2091,7860,1)
(7858,2374,1)
(5330,4359,1)
(4387,6708,1)
(563,5515,1)
(544,5266,1)
(3548,1321,1)
(6802,278,1)
(3618,1502,1)
(1934,8554,1)
(7637,2498,1)
(1673,7100,1)
(2432,8218,1)
(4787,4928,1)
(8209,5120,1)
(7470,6790,1)
(8676,6126,1)
(3147,5541,1)
(2320,2454,1)
(9081,5732,1)
(4797,4725,1)
(667,4647,1)
(1768,1791,1)
(7496,1502,1)
(3410,1502,1)
(3906,4928,1)
(3605,7469,1)
(5828,8302,1)
(7455,3762,1)
(7502,1089,1)
(4763,169,1)
(4884,1502,1)
(6298,7122,1)
(5719,8164,1)
(3412,75,1)
(9148,4928,1)
(7202,8718,1)
(6595,6932,1)
(7361,7750,1)
(5294,8029,1)
(7340,8705,1)
(1229,1778,1)
(4887,1895,1)
(1656,3636,1)
(6106,2546,1)
(6974,5245,1)
(4172,7941,1)
(4599,9153,1)
(6202,3759,1)
(526,4848,1)
(3417,2981,1)
(2626,8447,1)
(2242,6391,1)
(3022,8790,1)
(8432,5190,1)
(2219,268,1)
(2072,8830,1)
(8292,1978,1)
(1646,4928,1)
(6547,5550,1)
(3779,7335,1)
(7759,2347,1)
(618,1515,1)
(7281,6312,1)
(7391,116,1)
(1645,3338,1)
(8633,4928,1)
(7991,5115,1)
(1020,1906,1)
(932,2556,1)
(1334,6047,1)
(4871,5043,1)
(4696,1960,1)
(8794,350,1)
(1488,5041,1)
(71,6301,1)
(5264,4684,1)
(712,1128,1)
(7894,4928,1)
(225,8395,1)
(5856,558,1)
(3691,8247,1)
(2986,4350,1)
(9103,4894,1)
(8259,4750,1)
(2358,6597,1)
(2605,2898,1)
(412,3650,1)
(6120,2460,1)
(3839,7936,1)
(3355,7988,1)
(1842,8568,1)
(5212,2684,1)
(427,7754,1)
(1155,5116,1)
(543,4928,1)
(523,9036,1)
(6990,1975,1)
(7630,5789,1)
(3492,4253,1)
(1786,4011,1)
(6967,6953,1)
(4542,6047,1)
(2094,6350,1)
(849,1502,1)
(4968,8733,1)
(712,8678,1)
(7586,7023,1)
(6942,7351,1)
(1680,4744,1)
(1303,8517,1)
(5173,3193,1)
(7119,5783,1)
(7463,5010,1)
(3700,296,1)
(3330,7606,1)
(8774,9055,1)
(9100,6973,1)
(1801,7013,1)
(2210,1415,1)
(8722,1210,1)
(3403,6207,1)
(2096,5756,1)
(1223,2339,1)
(8649,6904,1)
(8261,5765,1)
(1892,3076,1)
(953,4108,1)
(2684,207,1)
(1541,2933,1)
(4112,6220,1)
(2512,6097,1)
(6551,6248,1)
(4702,3424,1)
(1325,5472,1)
(738,4928,1)
(3955,4200,1)
(6076,7303,1)
(4531,5902,1)
(8321,272,1)
(5425,8312,1)
(1598,1502,1)
(3886,1502,1)
(7108,3462,1)
(6815,6416,1)
(6304,8188,1)
(3462,1970,1)
(3591,2322,1)
(209,1502,1)
(3430,8000,1)
(6455,2979,1)
(3462,4961,1)
(4062,3368,1)
(1832,8518,1)
(802,5210,1)
(8537,7564,1)
(6058,2322,1)
(8803,5327,1)
(6571,6035,1)
(3617,4212,1)
(7651,1752,1)
(4755,6324,1)
(4183,7258,1)
(2128,724,1)
(3365,4928,1)
(2735,5595,1)
(7935,3520,1)
(3137,6431,1)
(1499,385,1)
(355,5266,1)
(5517,7819,1)
(1027,7468,1)
(6968,4928,1)
(3014,8067,1)
(6179,5818,1)
(1026,1502,1)
(6577,8916,1)
(7166,1502,1)
(2024,1502,1)
(9156,2798,1)
(4549,6139,1)
(6435,2337,1)
(6090,6706,1)
(1988,2893,1)
(1838,7810,1)
(4652,5191,1)
(5544,5708,1)
(2777,3525,1)
(3521,2485,1)
(4772,2898,1)
(5858,3643,1)
(1548,3265,1)
(4572,6465,1)
(927,4578,1)
(5085,7004,1)
(4604,4081,1)
(919,7977,1)
(2999,265,1)
(114,515,1)
(1921,4928,1)
(4928,1246,1)
(5567,2898,1)
(9042,2997,1)
(6930,2898,1)
(2436,1832,1)
(103,1648,1)
(5341,4928,1)
(4587,2247,1)
(2083,7402,1)
(6071,6951,1)
(5071,7866,1)
(301,5856,1)
(7561,1869,1)
(2443,4694,1)
(5798,9091,1)
(2554,2737,1)
(7095,7985,1)
(1506,6012,1)
(2106,181,1)
(5970,7421,1)
(1643,3517,1)
(9030,4769,1)
(8019,5228,1)
(3755,7114,1)
(4341,679,1)
(7324,7113,1)
(3771,8929,1)
(6553,3257,1)
(1141,8144,1)
(3391,7999,1)
(6204,4730,1)
(3167,5162,1)
(3233,5663,1)
(4495,9081,1)
(2727,5390,1)
(6304,1591,1)
(951,4991,1)
(3302,2893,1)
(451,8805,1)
(460,4419,1)
(3149,563,1)
(321,5282,1)
(6392,5043,1)
(7159,4928,1)
(1329,1900,1)
(1859,770,1)
(1131,4462,1)
(8251,4928,1)
(6288,91,1)
(4085,2961,1)
(5141,4928,1)
(1571,7874,1)
(9076,5489,1)
(4329,4879,1)
(8603,3677,1)
(5835,4928,1)
(8346,9046,1)
(5796,9012,1)
(4000,3701,1)
(776,2020,1)
(6728,1502,1)
(6941,777,1)
(8608,6731,1)
(8138,4009,1)
(3211,4928,1)
(9085,8391,1)
(5292,6156,1)
(962,1013,1)
(3046,7008,1)
(4845,8236,1)
(4699,8955,1)
(903,4140,1)
(4740,5185,1)
(7124,7039,1)
(7187,7351,1)
(3327,4928,1)
(8666,4773,1)
(1682,826,1)
(8522,357,1)
(7046,598,1)
(6365,5905,1)
(4907,4816,1)
(4433,1502,1)
(1702,6527,1)
(2240,7203,1)
(3271,5096,1)
(141,6047,1)
(1028,7468,1)
(2869,1591,1)
(7062,4360,1)
(5159,1502,1)
(4627,3683,1)
(4979,2146,1)
(4936,7182,1)
(2570,5775,1)
(8111,6594,1)
(4280,1502,1)
(4849,155,1)
(3650,635,1)
(9145,1502,1)
(3037,2274,1)
(7571,6077,1)
(6244,4332,1)
(1479,6047,1)
(1539,1502,1)
(5255,4928,1)
(1974,1502,1)
(4407,4384,1)
(738,1502,1)
(2262,6911,1)
(6836,3885,1)
(1075,1502,1)
(7144,5576,1)
(4269,2898,1)
(1141,8244,1)
(3198,8082,1)
(7999,4528,1)
(4852,8242,1)
(8007,4216,1)
(7605,415,1)
(3879,2540,1)
(410,8344,1)
(2689,3936,1)
(370,7788,1)
(8551,8809,1)
(4778,8343,1)
(3286,4928,1)
(4011,4322,1)
(484,7004,1)
(9061,1009,1)
(1815,6837,1)
(7097,3077,1)
(7858,6137,1)
(2788,5902,1)
(223,2999,1)
(4846,5115,1)
(6479,1760,1)
(1600,7845,1)
(3934,4213,1)
(8212,2641,1)
(1233,1112,1)
(8094,5854,1)
(7086,7647,1)
(1291,4928,1)
(1908,6444,1)
(2368,7390,1)
(628,2134,1)
(6610,3740,1)
(100,1688,1)
(7513,8912,1)
(5605,4388,1)
(2714,8488,1)
(7038,3209,1)
(89,7004,1)
(2915,61,1)
(8407,5047,1)
(481,87,1)
(4090,8083,1)
(3091,788,1)
(1341,541,1)
(4494,1502,1)
(7302,7797,1)
(2878,776,1)
(8344,7720,1)
(5910,2492,1)
(7488,8743,1)
(3082,3502,1)
(2652,8137,1)
(1123,1502,1)
(8720,6294,1)
(849,1547,1)
(5304,4638,1)
(1595,731,1)
(1734,1828,1)
(3168,540,1)
(759,6741,1)
(7845,4967,1)
(2664,1502,1)
(6304,7250,1)
(8213,6480,1)
(4332,8860,1)
(5246,1744,1)
(7420,5283,1)
(6540,3989,1)
(2322,7486,1)
(5262,2462,1)
(6115,2107,1)
(873,2828,1)
(7974,2383,1)
(274,5307,1)
(4761,409,1)
(1816,8273,1)
(1691,2153,1)
(1909,6186,1)
(2959,1402,1)
(5995,1502,1)
(2590,4876,1)
(1588,552,1)
(7297,6528,1)
(2073,573,1)
(4522,7922,1)
(712,4551,1)
(40,5328,1)
(2391,196,1)
(7005,3251,1)
(3830,4928,1)
(3227,7399,1)
(719,4928,1)
(3442,1413,1)
(1332,8107,1)
(5293,4291,1)
(9043,4928,1)
(8289,4928,1)
(3332,1502,1)
(4332,1502,1)
(8833,7175,1)
(4116,4415,1)
(1760,8923,1)
(7942,7263,1)
(5443,4928,1)
(8635,4401,1)
(2071,1428,1)
(3531,645,1)
(6737,1050,1)
(1149,2310,1)
(9119,4928,1)
(6611,6262,1)
(7334,3935,1)
(475,2088,1)
(4103,2398,1)
(3075,7776,1)
(4531,3339,1)
(4937,3565,1)
(2271,1375,1)
(3178,1791,1)
(6686,4586,1)
(7143,853,1)
(3935,4769,1)
(6242,5180,1)
(5294,1451,1)
(2349,7649,1)
(8701,7898,1)
(5294,8033,1)
(3120,5550,1)
(2735,2995,1)
(1978,7899,1)
(6198,1201,1)
(3837,1502,1)
(5456,972,1)
(6634,9035,1)
(5327,6047,1)
(4074,7468,1)
(2599,514,1)
(2732,4928,1)
(3696,7768,1)
(45,3233,1)
(6392,1711,1)
(8580,8262,1)
(2961,3158,1)
(1078,3627,1)
(8931,4928,1)
(1828,5476,1)
(5869,7618,1)
(9055,3764,1)
(1626,1502,1)
(2199,340,1)
(53,4759,1)
(7468,2894,1)
(2844,8713,1)
(1250,2041,1)
(27,6201,1)
(8081,7598,1)
(4511,3277,1)
(8972,1147,1)
(671,4934,1)
(5739,6435,1)
(2326,6730,1)
(9037,742,1)
(2095,7266,1)
(496,6040,1)
(2370,1515,1)
(8716,605,1)
(5619,2807,1)
(5294,2113,1)
(2228,3011,1)
(2381,5082,1)
(4517,1502,1)
(4738,1502,1)
(4474,2803,1)
(2978,5305,1)
(207,3337,1)
(4437,1489,1)
(6229,4592,1)
(4657,4928,1)
(6678,8183,1)
(147,4257,1)
(876,7628,1)
(2751,6533,1)
(4670,7004,1)
(7724,2721,1)
(2222,8463,1)
(2454,8215,1)
(3852,7261,1)
(3807,6997,1)
(5135,8414,1)
(6930,1070,1)
(6323,279,1)
(8117,4928,1)
(3791,1502,1)
(2737,1502,1)
(380,2318,1)
(8973,1502,1)
(8829,3313,1)
(7406,3043,1)
(569,4928,1)
(1483,3823,1)
(6216,1634,1)
(4640,1502,1)
(5721,7075,1)
(5501,7654,1)
(7378,4548,1)
(8590,1918,1)
(4166,6041,1)
(1218,1502,1)
(7451,7904,1)
(4437,7033,1)
(6983,1846,1)
(2715,1502,1)
(764,890,1)
(357,4826,1)
(5911,8816,1)
(7984,5837,1)
(2567,7192,1)
(3519,26,1)
(3953,2150,1)
(1626,4460,1)
(5087,8490,1)
(2057,814,1)
(8395,2985,1)
(8627,4973,1)
(2869,6988,1)
(8564,5319,1)
(1204,7974,1)
(844,1102,1)
(148,2141,1)
(8294,7638,1)
(709,3944,1)
(5980,5615,1)
(7928,5043,1)
(7137,4098,1)
(4083,704,1)
(1028,3583,1)
(5818,8411,1)
(5001,3123,1)
(3449,1909,1)
(3896,3696,1)
(7378,250,1)
(7342,8484,1)
(4909,7132,1)
(5059,1036,1)
(1762,4928,1)
(3302,1489,1)
(8006,4753,1)
(4225,5354,1)
(3085,8193,1)
(7991,1128,1)
(793,5782,1)
(8082,4225,1)
(7621,1103,1)
(236,8659,1)
(5248,1069,1)
(2916,1614,1)
(4990,2063,1)
(1557,4784,1)
(3376,6146,1)
(626,3425,1)
(4738,470,1)
(5397,4543,1)
(973,6995,1)
(5258,6047,1)
(8379,5107,1)
(6013,2585,1)
(4871,5316,1)
(3482,5654,1)
(6885,6737,1)
(1108,4679,1)
(6907,7793,1)
(7159,1502,1)
(5873,6703,1)
(6239,7167,1)
(8616,2113,1)
(7429,1479,1)
(2917,237,1)
(1166,9142,1)
(6391,1502,1)
(5064,5539,1)
(217,1924,1)
(9037,1591,1)
(3857,3574,1)
(2735,3314,1)
(8770,1611,1)
(3071,6318,1)
(2691,5838,1)
(6467,6094,1)
(5075,6179,1)
(5558,614,1)
(8634,3869,1)
(8498,7561,1)
(2058,5212,1)
(2843,6047,1)
(6304,493,1)
(5038,7089,1)
(6346,6295,1)
(8145,8500,1)
(2767,842,1)
(3721,3447,1)
(5867,6857,1)
(5142,4928,1)
(7613,5249,1)
(143,5097,1)
(2749,4289,1)
(3800,6921,1)
(5980,4928,1)
(607,5902,1)
(6697,964,1)
(7410,1511,1)
(4624,2316,1)
(3905,2163,1)
(7543,9122,1)
(3333,8511,1)
(5824,2157,1)
(4465,2589,1)
(7885,8240,1)
(2329,1236,1)
(2793,2835,1)
(5586,5219,1)
(2819,4928,1)
(2698,6546,1)
(1869,253,1)
(5589,2654,1)
(2069,2799,1)
(6102,4928,1)
(5091,2067,1)
(1033,1502,1)
(3014,346,1)
(981,2121,1)
(4178,6188,1)
(4493,2875,1)
(8008,8310,1)
(5530,1761,1)
(6403,4363,1)
(3062,661,1)
(82,1404,1)
(1250,2674,1)
(1248,794,1)
(2491,1502,1)
(9142,5865,1)
(5300,4471,1)
(2666,3134,1)
(8179,6047,1)
(4174,148,1)
(358,1386,1)
(3136,1332,1)
(3639,7227,1)
(4350,5328,1)
(8482,2681,1)
(3978,5197,1)
(1498,2492,1)
(4677,1216,1)
(4491,4928,1)
(5875,994,1)
(7744,6208,1)
(4705,7796,1)
(6639,1617,1)
(8574,4928,1)
(6711,3428,1)
(4682,7762,1)
(6987,7520,1)
(8834,4380,1)
(3440,5668,1)
(1755,1502,1)
(5294,9007,1)
(1609,4717,1)
(8937,5933,1)
(8807,6967,1)
(5576,959,1)
(7498,4788,1)
(8570,4655,1)
(1298,1502,1)
(4794,6350,1)
(5294,8987,1)
(2020,5271,1)
(8829,6465,1)
(5383,9155,1)
(68,3291,1)
(551,1502,1)
(6619,5898,1)
(4939,8178,1)
(5615,1122,1)
(2954,7839,1)
(1760,3816,1)
(7036,8967,1)
(8076,1985,1)
(1585,3540,1)
(2303,2672,1)
(7491,4811,1)
(8614,5848,1)
(5036,1502,1)
(272,8209,1)
(3971,4928,1)
(799,1502,1)
(8834,2426,1)
(4014,7889,1)
(3218,8051,1)
(8706,2000,1)
(1685,5617,1)
(4555,8146,1)
(6470,2757,1)
(7753,1096,1)
(4077,8463,1)
(2948,3263,1)
(4212,1502,1)
(5669,6342,1)
(2113,1502,1)
(4525,4911,1)
(5475,4555,1)
(9037,4985,1)
(4534,7148,1)
(2126,3267,1)
(1735,6593,1)
(4945,882,1)
(2602,4928,1)
(6800,8238,1)
(3313,8558,1)
(7084,4355,1)
(2575,8736,1)
(4306,8945,1)
(9037,1855,1)
(2609,9013,1)
(4067,7773,1)
(394,1502,1)
(5197,7629,1)
(1759,7801,1)
(5404,4275,1)
(8618,44,1)
(6301,6022,1)
(2779,7005,1)
(4421,3421,1)
(8023,5305,1)
(3554,6332,1)
(8766,5505,1)
(8555,1884,1)
(5399,6597,1)
(8763,2341,1)
(5622,3466,1)
(371,4928,1)
(8801,4922,1)
(4602,6447,1)
(7184,3840,1)
(7462,4597,1)
(7312,3142,1)
(6786,8285,1)
(6136,5922,1)
(6783,8053,1)
(6107,487,1)
(458,8622,1)
(1428,2109,1)
(6689,3119,1)
(1946,1882,1)
(1419,1502,1)
(5560,1502,1)
(6316,1230,1)
(5447,3087,1)
(2724,1115,1)
(759,8551,1)
(8910,6658,1)
(5446,2409,1)
(2340,1889,1)
(4751,4904,1)
(8681,4539,1)
(2347,73,1)
(4529,1363,1)
(8863,305,1)
(8704,8254,1)
(2381,990,1)
(6584,8423,1)
(9013,6483,1)
(3897,4136,1)
(6071,2845,1)
(4115,4744,1)
(8694,4062,1)
(7805,5043,1)
(8659,4069,1)
(8451,337,1)
(3819,7468,1)
(3028,4928,1)
(413,7219,1)
(3584,2908,1)
(7652,4928,1)
(3790,825,1)
(3089,7004,1)
(186,3033,1)
(7928,9009,1)
(7918,1954,1)
(1837,8118,1)
(4690,5267,1)
(3701,3292,1)
(9026,8678,1)
(3172,2839,1)
(431,4928,1)
(8204,1456,1)
(2453,924,1)
(9115,1592,1)
(4871,5902,1)
(8239,8083,1)
(3211,6047,1)
(8040,8594,1)
(2778,6981,1)
(4454,1498,1)
(7353,2441,1)
(2401,4766,1)
(7468,5559,1)
(5260,5580,1)
(454,3208,1)
(6183,4456,1)
(4685,4713,1)
(4459,6518,1)
(875,6941,1)
(1933,2788,1)
(3223,250,1)
(6876,6198,1)
(2819,9138,1)
(6231,5970,1)
(6956,1733,1)
(6310,4204,1)
(4095,2589,1)
(3476,3103,1)
(1722,5726,1)
(8171,4584,1)
(6452,2162,1)
(5626,3140,1)
(7003,7511,1)
(312,8947,1)
(5112,7947,1)
(7198,4174,1)
(5864,2425,1)
(1067,4928,1)
(3032,1420,1)
(6515,4928,1)
(323,637,1)
(5781,8604,1)
(4360,2738,1)
(6582,4960,1)
(4769,4387,1)
(6512,1449,1)
(6388,537,1)
(3170,4622,1)
(3884,1502,1)
(7425,6086,1)
(6453,3865,1)
(3835,8420,1)
(8269,9129,1)
(2509,1896,1)
(3526,2898,1)
(838,318,1)
(8647,2926,1)
(986,6585,1)
(4193,991,1)
(2568,2855,1)
(5204,4629,1)
(3881,4744,1)
(7731,8598,1)
(32,4928,1)
(8663,8753,1)
(2011,7892,1)
(7509,8992,1)
(623,7333,1)
(8143,2018,1)
(1568,3354,1)
(95,5047,1)
(8154,5626,1)
(4139,573,1)
(7717,4928,1)
(8487,3630,1)
(2792,6043,1)
(2811,2896,1)
(998,588,1)
(1366,666,1)
(1291,4637,1)
(7416,578,1)
(3350,1115,1)
(1628,6787,1)
(6245,6241,1)
(7317,4753,1)
(3481,243,1)
(5900,1362,1)
(4982,2211,1)
(1475,1502,1)
(6802,8446,1)
(7054,6512,1)
(6304,7137,1)
(5202,8,1)
(6,7892,1)
(2100,7481,1)
(3929,8541,1)
(5101,5049,1)
(2941,554,1)
(362,4928,1)
(1434,7408,1)
(539,7724,1)
(0,4778,1)
(6439,5126,1)
(4601,806,1)
(250,7527,1)
(438,4783,1)
(6263,5974,1)
(3652,8614,1)
(157,1433,1)
(4313,6182,1)
(3414,1502,1)
(7891,2470,1)
(3632,3507,1)
(8403,2977,1)
(7985,7668,1)
(6703,8959,1)
(5598,4558,1)
(5453,4182,1)
(499,1502,1)
(2547,3125,1)
(8539,1053,1)
(4876,1436,1)
(6460,6688,1)
(4748,5450,1)
(1152,8283,1)
(6325,5858,1)
(6075,2776,1)
(2828,459,1)
(5656,5164,1)
(4605,7541,1)
(2389,5192,1)
(578,3997,1)
(4991,2694,1)
(154,8998,1)
(7663,3202,1)
(4552,4280,1)
(1070,3293,1)
(2722,8026,1)
(4770,8722,1)
(6528,7771,1)
(6787,2340,1)
(6425,4130,1)
(8182,1778,1)
(1455,2578,1)
(2010,8458,1)
(571,124,1)
(383,7055,1)
(6221,4273,1)
(8588,746,1)
(8090,6938,1)
(4846,7148,1)
(3952,2827,1)
(8180,2184,1)
(4448,1502,1)
(2184,5830,1)
(7046,4551,1)
(265,2387,1)
(6960,638,1)
(2487,6168,1)
(7926,1457,1)
(8347,3506,1)
(5316,1836,1)
(1638,9085,1)
(8560,7468,1)
(1294,1593,1)
(373,8970,1)
(1256,849,1)
(8921,2357,1)
(5018,323,1)
(3830,1502,1)
(8058,6084,1)
(8798,4936,1)
(7046,2456,1)
(6009,4494,1)
(5780,8425,1)
(4433,4928,1)
(4759,256,1)
(3998,5369,1)
(7387,1502,1)
(9026,2893,1)
(3916,8881,1)
(6703,3528,1)
(5608,4204,1)
(4352,4928,1)
(840,5670,1)
(573,8909,1)
(5113,8077,1)
(1942,2574,1)
(716,6587,1)
(4519,51,1)
(3880,4928,1)
(7602,4680,1)
(7072,3390,1)
(2144,1959,1)
(4472,8678,1)
(2472,3278,1)
(2928,5705,1)
(4657,449,1)
(8644,4220,1)
(340,9049,1)
(8486,2242,1)
(8519,5902,1)
(9041,7630,1)
(8199,6047,1)
(1234,8678,1)
(5560,2270,1)
(1742,1171,1)
(3904,7151,1)
(1102,21,1)
(7810,4928,1)
(8749,1306,1)
(9090,4928,1)
(8163,3841,1)
(3658,2812,1)
(6497,4928,1)
(6049,8411,1)
(5696,5644,1)
(7787,2332,1)
(5958,2686,1)
(6871,1502,1)
(2700,1502,1)
(3069,4928,1)
(7824,236,1)
(6299,9148,1)
(1230,2627,1)
(2117,8253,1)
(7424,8608,1)
(7401,8919,1)
(3305,4201,1)
(8494,4928,1)
(3315,6296,1)
(7583,1536,1)
(8728,6179,1)
(8782,7726,1)
(6319,6221,1)
(435,1707,1)
(6465,2866,1)
(5123,4615,1)
(6667,550,1)
(6090,6331,1)
(5482,4610,1)
(4437,7137,1)
(1003,8068,1)
(6367,572,1)
(9037,7100,1)
(7862,3656,1)
(839,1442,1)
(4720,8535,1)
(3759,4331,1)
(2764,8126,1)
(1284,2773,1)
(2074,6728,1)
(1942,8948,1)
(3768,8310,1)
(6237,6231,1)
(455,7100,1)
(847,7589,1)
(2206,5306,1)
(1918,4389,1)
(2708,6058,1)
(4532,8455,1)
(9106,7117,1)
(8313,294,1)
(5448,4928,1)
(7016,3614,1)
(3676,4631,1)
(4171,6681,1)
(3212,6063,1)
(6674,7700,1)
(3562,1874,1)
(2552,1065,1)
(3969,7815,1)
(1225,4853,1)
(8438,6133,1)
(2990,6667,1)
(8605,4426,1)
(6304,932,1)
(730,7697,1)
(3683,1840,1)
(6119,4928,1)
(5655,8585,1)
(6898,6208,1)
(1876,2748,1)
(4049,1502,1)
(4586,7375,1)
(7120,9144,1)
(4510,1200,1)
(2318,3527,1)
(7786,7855,1)
(8128,5043,1)
(5928,8069,1)
(2672,3382,1)
(3854,1145,1)
(8590,1866,1)
(8408,4928,1)
(5280,3085,1)
(8172,1482,1)
(3450,6128,1)
(70,1025,1)
(5015,1458,1)
(7279,6976,1)
(581,9017,1)
(7659,7765,1)
(6008,4358,1)
(6457,7338,1)
(8841,1015,1)
(8969,5906,1)
(7844,6343,1)
(4472,6465,1)
(4591,6130,1)
(8927,3825,1)
(9062,6431,1)
(7651,1502,1)
(2735,7094,1)
(4065,6833,1)
(3674,3262,1)
(6522,7814,1)
(5306,4866,1)
(4688,4517,1)
(1480,1507,1)
(2809,651,1)
(665,5007,1)
(8161,2644,1)
(2417,4744,1)
(5665,4811,1)
(8579,274,1)
(1246,1842,1)
(587,4951,1)
(7019,7908,1)
(7941,6998,1)
(3286,8582,1)
(9098,4420,1)
(6432,407,1)
(2630,5079,1)
(6254,125,1)
(3560,4535,1)
(7608,7674,1)
(2447,6651,1)
(8182,3246,1)
(7163,8964,1)
(7153,2386,1)
(4846,5559,1)
(7067,3473,1)
(4036,6682,1)
(9065,4928,1)
(1764,7309,1)
(9083,4928,1)
(346,4259,1)
(2760,7901,1)
(2869,7106,1)
(6903,3117,1)
(6965,5575,1)
(5294,3907,1)
(1224,2415,1)
(6353,6047,1)
(6518,8975,1)
(2411,5182,1)
(567,4928,1)
(7531,8276,1)
(2419,8701,1)
(2836,4024,1)
(4623,4961,1)
(4929,3730,1)
(6062,2718,1)
(9019,7468,1)
(7946,4190,1)
(750,3226,1)
(5854,372,1)
(3976,4525,1)
(4106,6346,1)
(1692,7556,1)
(5442,7871,1)
(219,3033,1)
(2289,245,1)
(6304,1489,1)
(6167,3690,1)
(2073,6431,1)
(1923,1502,1)
(1503,3060,1)
(2479,3562,1)
(4974,3390,1)
(1081,4928,1)
(6454,2301,1)
(1782,7076,1)
(8151,3399,1)
(2955,1681,1)
(7325,7473,1)
(6768,7157,1)
(8950,7593,1)
(5062,2623,1)
(4722,8062,1)
(6894,886,1)
(2170,826,1)
(2415,150,1)
(8701,4656,1)
(3095,9090,1)
(1607,6747,1)
(6019,4170,1)
(8753,3878,1)
(2320,6988,1)
(5755,5144,1)
(227,3907,1)
(2066,379,1)
(1303,4928,1)
(1727,1515,1)
(8595,4434,1)
(2125,3426,1)
(542,1597,1)
(801,2196,1)
(7687,3582,1)
(6018,4063,1)
(2197,5706,1)
(2735,9082,1)
(5222,6288,1)
(4352,5418,1)
(1132,1502,1)
(1986,6978,1)
(3005,20,1)
(8770,6286,1)
(1088,1502,1)
(7371,4699,1)
(2735,3402,1)
(2822,2713,1)
(2070,8624,1)
(3059,3165,1)
(7413,8839,1)
(182,7004,1)
(3307,854,1)
(7319,3751,1)
(7685,4928,1)
(3587,4833,1)
(753,610,1)
(4614,3453,1)
(7242,7519,1)
(3069,2722,1)
(8466,1518,1)
(2735,8807,1)
(6507,7237,1)
(6034,4689,1)
(2046,1483,1)
(1524,8641,1)
(8463,2819,1)
(3242,1815,1)
(2633,7604,1)
(9037,1228,1)
(7612,5515,1)
(6883,4928,1)
(8276,6047,1)
(3669,2870,1)
(3442,7004,1)
(1062,7290,1)
(1784,3191,1)
(3784,4897,1)
(1904,7306,1)
(2009,1502,1)
(5322,7971,1)
(4781,246,1)
(8504,7624,1)
(4338,8007,1)
(8132,1358,1)
(5614,4747,1)
(6272,9043,1)
(6566,6425,1)
(5668,4928,1)
(2947,2801,1)
(2768,5176,1)
(6358,6709,1)
(66,1126,1)
(7057,7544,1)
(5294,6988,1)
(3379,7583,1)
(2030,8526,1)
(500,1538,1)
(7652,8656,1)
(2320,8037,1)
(1446,8755,1)
(6562,7338,1)
(8480,3934,1)
(207,1264,1)
(3280,6099,1)
(3605,7174,1)
(8011,6745,1)
(691,2436,1)
(3302,5115,1)
(2771,4882,1)
(3194,6562,1)
(7138,227,1)
(2238,6922,1)
(2391,1502,1)
(3839,4156,1)
(2994,2963,1)
(4805,1799,1)
(2484,4356,1)
(2565,4928,1)
(112,3522,1)
(1370,3835,1)
(2953,1502,1)
(1939,8859,1)
(3874,4744,1)
(4175,8171,1)
(5203,898,1)
(6517,6431,1)
(655,7042,1)
(2841,7007,1)
(5340,4665,1)
(8210,3852,1)
(7323,3903,1)
(2178,1588,1)
(1545,3573,1)
(197,1323,1)
(1440,3922,1)
(2978,8023,1)
(3551,5725,1)
(6420,5175,1)
(4682,7315,1)
(5078,1502,1)
(4655,9008,1)
(6938,7575,1)
(3992,3315,1)
(5856,9115,1)
(7984,3905,1)
(971,2599,1)
(5240,3856,1)
(7805,4897,1)
(4424,6773,1)
(3922,2567,1)
(2735,2259,1)
(2708,8032,1)
(2735,5138,1)
(828,5354,1)
(7284,4630,1)
(186,9006,1)
(2193,7276,1)
(2834,4269,1)
(7009,7905,1)
(2565,1502,1)
(5142,4796,1)
(7155,6917,1)
(3085,255,1)
(450,4928,1)
(5052,8362,1)
(3686,676,1)
(1004,7518,1)
(5902,2837,1)
(8778,5628,1)
(4374,3131,1)
(3266,6806,1)
(7781,5622,1)
(8728,3530,1)
(6105,5043,1)
(5726,3736,1)
(8899,3450,1)
(3117,5759,1)
(2883,5135,1)
(7651,4928,1)
(7372,3625,1)
(2656,1712,1)
(6625,7517,1)
(8739,2458,1)
(5614,6568,1)
(3572,2594,1)
(6521,4032,1)
(4899,4241,1)
(8552,1918,1)
(4334,7037,1)
(554,3024,1)
(888,2880,1)
(2363,8482,1)
(1216,8392,1)
(3050,453,1)
(1365,656,1)
(1453,1679,1)
(474,3813,1)
(8891,1502,1)
(8937,632,1)
(2021,8289,1)
(4221,970,1)
(558,7952,1)
(9128,4928,1)
(3789,2931,1)
(8794,8139,1)
(8751,8509,1)
(9037,642,1)
(7702,3064,1)
(3428,9098,1)
(4206,1217,1)
(9031,1502,1)
(8262,4834,1)
(5547,3998,1)
(2406,317,1)
(397,2762,1)
(3899,741,1)
(5075,3530,1)
(1620,1107,1)
(5613,8677,1)
(4569,7597,1)
(679,7023,1)
(3443,391,1)
(3834,6785,1)
(8935,5424,1)
(1180,3750,1)
(3718,5213,1)
(7517,796,1)
(8128,4840,1)
(2690,2585,1)
(3978,6914,1)
(1450,4171,1)
(6508,6052,1)
(9008,1502,1)
(5564,8595,1)
(3930,8724,1)
(7495,1353,1)
(4608,5858,1)
(3160,9116,1)
(672,7533,1)
(575,8047,1)
(9037,5115,1)
(3420,4928,1)
(5918,2632,1)
(419,8603,1)
(4232,5467,1)
(5859,5829,1)
(7805,5902,1)
(2747,5983,1)
(8575,3806,1)
(6840,4155,1)
(4985,6972,1)
(4808,3219,1)
(5407,2758,1)
(3992,6296,1)
(5267,3937,1)
(6747,6702,1)
(3470,2814,1)
(5623,8439,1)
(4896,8689,1)
(9001,3764,1)
(6782,334,1)
(402,7572,1)
(7650,1177,1)
(1253,2893,1)
(7627,7054,1)
(3236,1659,1)
(7976,7826,1)
(6304,4985,1)
(647,7012,1)
(1521,4886,1)
(3674,7460,1)
(1923,4928,1)
(6304,4166,1)
(1219,2299,1)
(6493,2864,1)
(1586,3687,1)
(9077,1591,1)
(6575,3905,1)
(1335,7494,1)
(2667,6345,1)
(7085,3941,1)
(6805,2180,1)
(2582,1220,1)
(2925,4928,1)
(4385,7579,1)
(1342,8294,1)
(8169,2965,1)
(5110,6431,1)
(2132,7718,1)
(7719,5763,1)
(5421,5521,1)
(8,4810,1)
(2932,8997,1)
(4851,3135,1)
(6830,7190,1)
(6246,812,1)
(448,4373,1)
(5513,2858,1)
(7107,1879,1)
(214,5586,1)
(416,7532,1)
(5683,5043,1)
(1041,807,1)
(6518,6573,1)
(6706,5821,1)
(7822,8994,1)
(4490,4599,1)
(6767,4409,1)
(6499,4907,1)
(4681,1643,1)
(7762,4928,1)
(2869,8037,1)
(5939,6166,1)
(6916,3334,1)
(4255,6110,1)
(590,7806,1)
(614,1083,1)
(1292,3188,1)
(5731,7736,1)
(839,5785,1)
(4035,4647,1)
(8671,7339,1)
(4074,46,1)
(2492,5902,1)
(2080,1627,1)
(6304,6853,1)
(5376,8544,1)
(8137,6234,1)
(7426,3909,1)
(7948,43,1)
(5017,1233,1)
(7087,484,1)
(6505,1579,1)
(127,6561,1)
(6998,8908,1)
(3648,7625,1)
(2757,2743,1)
(8183,3527,1)
(3721,1515,1)
(8227,1502,1)
(3267,1509,1)
(8890,1502,1)
(2321,4743,1)
(7248,5355,1)
(175,1794,1)
(7984,339,1)
(611,1502,1)
(5320,8117,1)
(6482,3583,1)
(5391,2290,1)
(4016,4455,1)
(1985,4795,1)
(1810,460,1)
(3926,8634,1)
(9015,7017,1)
(321,6564,1)
(171,4531,1)
(8820,2844,1)
(1387,13,1)
(7314,7868,1)
(2866,2924,1)
(1120,4663,1)
(1871,6409,1)
(5690,8444,1)
(531,7821,1)
(4668,309,1)
(4009,5487,1)
(1217,2417,1)
(3238,6338,1)
(2621,4729,1)
(7681,3599,1)
(1056,4765,1)
(4280,6395,1)
(9015,3217,1)
(213,2248,1)
(7294,2102,1)
(1079,4928,1)
(3652,6162,1)
(1460,4928,1)
(6967,4181,1)
(44,4221,1)
(4396,7546,1)
(2839,1502,1)
(9119,230,1)
(1508,3844,1)
(4933,1835,1)
(6128,5274,1)
(2800,5487,1)
(5040,4166,1)
(5671,7829,1)
(7565,1502,1)
(354,1418,1)
(7048,5322,1)
(7067,369,1)
(717,1716,1)
(8885,4658,1)
(3773,8839,1)
(3523,6629,1)
(3462,87,1)
(8360,8436,1)
(1298,106,1)
(2826,5477,1)
(8532,4952,1)
(2128,4928,1)
(3380,5110,1)
(6304,1314,1)
(1068,1911,1)
(3504,1467,1)
(6329,4271,1)
(9055,5043,1)
(902,7004,1)
(3336,1072,1)
(7172,1502,1)
(1538,1718,1)
(1202,4820,1)
(3940,9015,1)
(8667,6171,1)
(3591,1870,1)
(3127,8809,1)
(1218,2877,1)
(1688,4928,1)
(783,1989,1)
(7382,7086,1)
(290,7330,1)
(6180,7130,1)
(7630,5043,1)
(5294,2978,1)
(2735,1312,1)
(570,8143,1)
(2407,4944,1)
(9040,5043,1)
(7526,5293,1)
(7014,2898,1)
(576,5658,1)
(8560,6179,1)
(4437,707,1)
(1823,1502,1)
(1520,334,1)
(5033,8019,1)
(4879,1423,1)
(5481,5772,1)
(4765,200,1)
(4763,175,1)
(3688,3382,1)
(6565,1377,1)
(7548,1502,1)
(8880,8623,1)
(6304,4986,1)
(7697,4582,1)
(6984,6998,1)
(6282,1625,1)
(1043,5419,1)
(4705,3078,1)
(3153,4928,1)
(7375,4247,1)
(6609,7783,1)
(1364,4950,1)
(7628,6999,1)
(5234,9089,1)
(8873,5197,1)
(5759,3443,1)
(1837,1502,1)
(5693,6110,1)
(1227,1197,1)
(2544,2576,1)
(7339,4477,1)
(1561,7471,1)
(648,1502,1)
(2282,8147,1)
(2699,5043,1)
(7909,4232,1)
(8722,222,1)
(414,2888,1)
(7506,1204,1)
(6775,5971,1)
(4399,2199,1)
(7623,7666,1)
(6469,3547,1)
(5476,7146,1)
(4822,8398,1)
(5636,4928,1)
(2735,4288,1)
(4814,1502,1)
(972,6217,1)
(8029,92,1)
(259,3184,1)
(4163,3819,1)
(2907,1502,1)
(8953,1639,1)
(3359,8034,1)
(3483,5739,1)
(2803,5902,1)
(9083,5537,1)
(5294,7092,1)
(8853,1026,1)
(5874,2848,1)
(1075,4928,1)
(6109,8294,1)
(2264,7155,1)
(4472,4551,1)
(5617,5607,1)
(2982,3848,1)
(6304,707,1)
(4404,545,1)
(7854,5214,1)
(1991,1502,1)
(1634,2425,1)
(5658,7518,1)
(145,1175,1)
(6620,1502,1)
(1079,1502,1)
(6304,1228,1)
(2035,1502,1)
(6478,5114,1)
(6249,2069,1)
(6537,7468,1)
(1456,3110,1)
(5381,7621,1)
(5294,598,1)
(6836,4368,1)
(8897,3826,1)
(5489,5043,1)
(4699,5043,1)
(8177,3098,1)
(8072,1006,1)
(4078,3458,1)
(299,1361,1)
(5830,4064,1)
(6688,6371,1)
(7374,1502,1)
(1989,6048,1)
(221,1638,1)
(4875,2334,1)
(4452,4928,1)
(8491,2650,1)
(2551,7229,1)
(4145,214,1)
(7737,6213,1)
(8199,7886,1)
(3730,1502,1)
(3276,1215,1)
(6202,3259,1)
(1669,7782,1)
(8036,1502,1)
(4391,7961,1)
(3506,8480,1)
(6757,2898,1)
(3662,595,1)
(6398,1441,1)
(7127,6014,1)
(975,2747,1)
(8473,8362,1)
(5275,5014,1)
(6510,4928,1)
(4862,980,1)
(8306,7878,1)
(3278,3902,1)
(3407,5155,1)
(1256,7659,1)
(4717,4928,1)
(4777,4920,1)
(7301,9045,1)
(2290,5894,1)
(4373,5420,1)
(4063,6618,1)
(156,908,1)
(7441,6875,1)
(1431,7325,1)
(8222,9072,1)
(7093,1502,1)
(9073,7112,1)
(6906,4334,1)
(2795,7315,1)
(2960,8188,1)
(8541,4928,1)
(7746,4052,1)
(2024,4928,1)
(4061,1609,1)
(4524,8975,1)
(7748,530,1)
(2109,1502,1)
(3411,4551,1)
(5816,2810,1)
(917,4890,1)
(4496,1712,1)
(5331,4850,1)
(7893,6302,1)
(683,4254,1)
(7991,598,1)
(6345,334,1)
(4437,3313,1)
(3942,6047,1)
(1361,5825,1)
(922,7387,1)
(617,8205,1)
(4437,677,1)
(141,4928,1)
(4582,380,1)
(1352,5920,1)
(5201,6228,1)
(6061,6479,1)
(1343,3510,1)
(6567,5443,1)
(3963,7526,1)
(1591,869,1)
(5294,6930,1)
(899,6839,1)
(1316,451,1)
(7673,4962,1)
(2041,6912,1)
(502,7371,1)
(8126,4215,1)
(1412,7323,1)
(2720,6058,1)
(1355,4095,1)
(4574,2679,1)
(6974,4928,1)
(8675,3202,1)
(6710,1049,1)
(1183,9015,1)
(3098,7562,1)
(7788,1224,1)
(6825,2666,1)
(4130,4744,1)
(7915,703,1)
(8500,5885,1)
(8397,6974,1)
(5440,7484,1)
(6413,5218,1)
(1035,720,1)
(7326,3645,1)
(3937,5109,1)
(7115,5902,1)
(8860,6710,1)
(712,1228,1)
(4150,6812,1)
(1960,8010,1)
(7229,3583,1)
(8516,3067,1)
(4561,7863,1)
(4583,8352,1)
(2601,7939,1)
(3331,5261,1)
(7592,688,1)
(6343,3372,1)
(4463,8174,1)
(2738,8944,1)
(5686,8841,1)
(3665,6622,1)
(5677,133,1)
(4708,8671,1)
(4934,6432,1)
(8759,8550,1)
(3742,7080,1)
(5827,5875,1)
(7653,1613,1)
(3865,9125,1)
(7861,8505,1)
(6849,557,1)
(5294,7148,1)
(2562,3792,1)
(8108,498,1)
(6007,9004,1)
(2084,4442,1)
(4372,1502,1)
(3590,8631,1)
(1321,860,1)
(7449,7887,1)
(3732,324,1)
(9049,4333,1)
(1365,5878,1)
(3547,8737,1)
(7946,1232,1)
(473,5423,1)
(3529,1502,1)
(813,4928,1)
(4313,3093,1)
(6814,6112,1)
(7853,2450,1)
(2088,30,1)
(1828,7468,1)
(245,3000,1)
(2922,3833,1)
(1776,4930,1)
(7607,5262,1)
(2061,8851,1)
(6488,1574,1)
(6421,3752,1)
(4091,3911,1)
(3166,1936,1)
(2613,8301,1)
(471,6639,1)
(5755,1502,1)
(1767,4591,1)
(851,5268,1)
(5912,7545,1)
(3762,7601,1)
(3201,3831,1)
(765,7033,1)
(4859,7528,1)
(504,2894,1)
(1902,1620,1)
(8987,7390,1)
(5244,3179,1)
(354,6431,1)
(4870,3289,1)
(3524,697,1)
(400,6971,1)
(266,6170,1)
(7691,8512,1)
(286,4176,1)
(929,1380,1)
(7014,3812,1)
(6767,9063,1)
(1323,5544,1)
(6801,8237,1)
(2872,62,1)
(3250,1502,1)
(3638,4805,1)
(8368,6317,1)
(3485,199,1)
(7600,769,1)
(4260,7687,1)
(1639,3515,1)
(4697,7492,1)
(6422,8908,1)
(2537,5183,1)
(5928,3990,1)
(9130,4928,1)
(6515,1502,1)
(375,2898,1)
(2821,6592,1)
(2739,190,1)
(8738,920,1)
(4238,8770,1)
(7983,3872,1)
(1138,1873,1)
(656,2309,1)
(7613,8681,1)
(3825,556,1)
(313,985,1)
(2310,3592,1)
(9037,2113,1)
(7922,8611,1)
(1486,8460,1)
(1713,3900,1)
(6466,750,1)
(244,2966,1)
(4848,6429,1)
(1548,2736,1)
(5782,4909,1)
(2772,1502,1)
(2295,1502,1)
(816,1809,1)
(7846,7317,1)
(1825,4928,1)
(658,1502,1)
(4139,7165,1)
(5255,8432,1)
(7988,1811,1)
(4152,131,1)
(1864,7209,1)
(7442,6786,1)
(6552,6392,1)
(8001,8982,1)
(3683,8849,1)
(1084,5198,1)
(2143,8197,1)
(3420,1502,1)
(5409,575,1)
(884,3234,1)
(3372,7992,1)
(1682,8838,1)
(8457,6141,1)
(2410,1502,1)
(677,8275,1)
(3921,1100,1)
(3532,944,1)
(7559,7937,1)
(5347,8858,1)
(7907,8122,1)
(9150,3753,1)
(7192,3438,1)
(9018,5794,1)
(3120,4951,1)
(8928,1638,1)
(4247,4928,1)
(7468,7092,1)
(6674,1516,1)
(4695,1502,1)
(7848,3280,1)
(6027,902,1)
(7446,3084,1)
(7359,1682,1)
(7606,8002,1)
(883,3917,1)
(9075,4245,1)
(1885,6575,1)
(4243,5638,1)
(5070,1101,1)
(3912,2043,1)
(681,4427,1)
(8635,3082,1)
(9093,7831,1)
(4181,382,1)
(8637,8346,1)
(499,4928,1)
(2166,4316,1)
(3798,6404,1)
(2467,5486,1)
(7213,6092,1)
(5972,1842,1)
(1306,3553,1)
(1111,7169,1)
(6899,4791,1)
(5833,4928,1)
(6748,4928,1)
(7351,5341,1)
(8317,4421,1)
(4214,5218,1)
(4437,932,1)
(8568,3102,1)
(5025,5862,1)
(8139,5084,1)
(3745,1352,1)
(8120,3471,1)
(7238,2581,1)
(1289,1502,1)
(5294,7216,1)
(8312,4320,1)
(1523,8041,1)
(9101,8340,1)
(45,119,1)
(5139,6020,1)
(6558,665,1)
(6304,1773,1)
(4702,4928,1)
(6218,743,1)
(867,7885,1)
(1666,892,1)
(8239,2260,1)
(8894,8650,1)
(1220,1800,1)
(4437,4551,1)
(3402,2347,1)
(5646,9036,1)
(7067,1110,1)
(1178,8053,1)
(5134,2055,1)
(2136,6047,1)
(4341,2693,1)
(2105,813,1)
(5651,4101,1)
(7982,6855,1)
(624,2961,1)
(4841,4928,1)
(7240,4928,1)
(297,4928,1)
(3288,4928,1)
(4066,4867,1)
(5241,1762,1)
(37,5462,1)
(5862,2782,1)
(2063,4987,1)
(7189,8225,1)
(6610,2507,1)
(4010,294,1)
(4524,3207,1)
(8527,2052,1)
(6736,1502,1)
(6673,6464,1)
(4949,2190,1)
(2781,1980,1)
(7046,6465,1)
(315,2676,1)
(8335,9132,1)
(504,7100,1)
(4814,4928,1)
(6280,8362,1)
(2332,8362,1)
(762,647,1)
(3994,1839,1)
(3419,4982,1)
(3321,2275,1)
(8752,2406,1)
(6451,835,1)
(7753,7596,1)
(916,1590,1)
(5143,1449,1)
(5077,1515,1)
(2691,3520,1)
(5557,6863,1)
(9008,3583,1)
(8053,2686,1)
(87,151,1)
(4169,4928,1)
(8679,5913,1)
(6810,1947,1)
(1549,1502,1)
(1846,808,1)
(2306,8878,1)
(8400,3470,1)
(8205,5902,1)
(1996,4699,1)
(6764,2544,1)
(1686,1328,1)
(3914,3965,1)
(8811,6105,1)
(9095,1561,1)
(8592,8940,1)
(2684,9018,1)
(7468,4551,1)
(4768,870,1)
(7707,4928,1)
(4747,3915,1)
(8173,1138,1)
(4868,7254,1)
(1572,6088,1)
(7792,4838,1)
(5623,1502,1)
(3699,8975,1)
(5702,2523,1)
(1748,42,1)
(4718,7909,1)
(1278,1502,1)
(3056,1495,1)
(2376,4265,1)
(1763,3092,1)
(6769,3474,1)
(1126,7501,1)
(2728,378,1)
(8037,976,1)
(2020,3647,1)
(8417,7763,1)
(1924,5511,1)
(7732,1047,1)
(2257,818,1)
(3821,765,1)
(7668,8492,1)
(8641,8605,1)
(7742,4898,1)
(2429,1274,1)
(7570,6200,1)
(5683,5784,1)
(9082,3480,1)
(6795,8946,1)
(5294,1489,1)
(4741,8358,1)
(998,2384,1)
(2882,4629,1)
(8782,4928,1)
(5118,4928,1)
(3316,4857,1)
(8294,4453,1)
(4572,1591,1)
(676,3331,1)
(3140,7632,1)
(6671,403,1)
(7359,5383,1)
(5266,1915,1)
(3806,4337,1)
(7311,5902,1)
(1500,385,1)
(6377,953,1)
(2299,1502,1)
(6791,5633,1)
(2952,6599,1)
(4833,6431,1)
(2804,3737,1)
(2912,1502,1)
(1479,1502,1)
(5471,4544,1)
(1687,1502,1)
(5165,5940,1)
(7243,8058,1)
(5389,384,1)
(5363,4052,1)
(8593,6209,1)
(9102,5017,1)
(8126,6241,1)
(6483,6148,1)
(2427,8710,1)
(7535,146,1)
(3302,5559,1)
(4713,6872,1)
(7762,7967,1)
(362,6047,1)
(2602,8521,1)
(3228,6793,1)
(3294,2832,1)
(4818,4509,1)
(3225,7894,1)
(5137,5778,1)
(3895,420,1)
(8858,5043,1)
(9058,22,1)
(2231,4416,1)
(8376,1883,1)
(9084,5037,1)
(2735,7940,1)
(7948,2650,1)
(3970,2886,1)
(594,7609,1)
(2254,1211,1)
(62,1343,1)
(3706,4918,1)
(8626,6757,1)
(7602,6068,1)
(1537,6278,1)
(3031,6687,1)
(7016,1502,1)
(2846,7350,1)
(2220,8918,1)
(1266,5578,1)
(4820,2035,1)
(7028,6851,1)
(1028,5156,1)
(2709,483,1)
(3456,4937,1)
(5950,2611,1)
(2389,4830,1)
(8020,6964,1)
(99,6305,1)
(504,8188,1)
(6050,5712,1)
(7991,5559,1)
(5110,6935,1)
(4076,4744,1)
(4437,4986,1)
(7286,7004,1)
(2859,8882,1)
(5462,3859,1)
(529,6523,1)
(4181,5826,1)
(5149,5682,1)
(1503,1599,1)
(7229,1502,1)
(5154,6850,1)
(1479,5395,1)
(2221,7277,1)
(536,7381,1)
(7878,3719,1)
(3054,4391,1)
(3963,4961,1)
(6401,6686,1)
(4664,973,1)
(2134,1222,1)
(7560,5919,1)
(5102,8989,1)
(2278,3854,1)
(7685,3348,1)
(8886,4573,1)
(1825,1502,1)
(5403,7934,1)
(6746,334,1)
(5285,5295,1)
(9008,3118,1)
(6074,7622,1)
(2280,4928,1)
(5383,5625,1)
(8888,2898,1)
(175,5457,1)
(8554,2552,1)
(544,6369,1)
(4123,1453,1)
(754,5718,1)
(6761,5167,1)
(8217,6721,1)
(592,1473,1)
(6238,7772,1)
(7618,281,1)
(8833,3482,1)
(7190,4625,1)
(5794,5080,1)
(1162,8376,1)
(504,5559,1)
(4370,4150,1)
(174,5796,1)
(964,3305,1)
(2982,7323,1)
(4502,4,1)
(0,8192,1)
(6356,2915,1)
(5111,569,1)
(2124,3660,1)
(5791,2783,1)
(2838,4652,1)
(7234,9101,1)
(6213,5874,1)
(6933,771,1)
(2735,3364,1)
(481,3492,1)
(2937,4928,1)
(3528,2728,1)
(8312,3322,1)
(6126,343,1)
(7214,4540,1)
(3361,1951,1)
(1886,4381,1)
(4778,5226,1)
(7385,4246,1)
(5854,5596,1)
(853,678,1)
(1270,8283,1)
(735,8496,1)
(1507,3641,1)
(1853,2104,1)
(7643,7193,1)
(9037,5559,1)
(6201,2975,1)
(6188,4367,1)
(7332,1406,1)
(4353,5701,1)
(3068,7802,1)
(7950,1736,1)
(1448,4183,1)
(1912,8099,1)
(5294,8188,1)
(6320,3215,1)
(3767,2088,1)
(7571,7670,1)
(4354,108,1)
(5995,4928,1)
(8057,4025,1)
(3386,7890,1)
(3874,3483,1)
(8983,3283,1)
(679,7586,1)
(8604,5672,1)
(2219,6890,1)
(7468,1489,1)
(46,9080,1)
(4060,7733,1)
(756,1984,1)
(6757,2580,1)
(5886,4758,1)
(8360,3958,1)
(8662,3906,1)
(6803,2349,1)
(3163,4006,1)
(8696,7675,1)
(2039,6527,1)
(3622,6472,1)
(6500,2965,1)
(7955,4928,1)
(7522,4928,1)
(4788,2764,1)
(4141,1502,1)
(6746,5651,1)
(6318,832,1)
(4003,254,1)
(829,4571,1)
(7999,4928,1)
(7729,7715,1)
(4413,2433,1)
(2316,263,1)
(1471,7220,1)
(3889,8332,1)
(3133,8690,1)
(203,2765,1)
(1422,5089,1)
(2736,1098,1)
(1598,4928,1)
(6366,55,1)
(1345,3021,1)
(2865,5111,1)
(900,8256,1)
(5065,1502,1)
(5086,5061,1)
(5191,197,1)
(425,109,1)
(263,5902,1)
(7674,329,1)
(6620,1952,1)
(6133,845,1)
(2226,5991,1)
(2461,1028,1)
(2468,5023,1)
(7720,3583,1)
(8668,5347,1)
(6214,9115,1)
(533,1472,1)
(3144,8899,1)
(5411,6047,1)
(5348,603,1)
(4833,4744,1)
(6304,7767,1)
(3911,693,1)
(5882,7253,1)
(748,6660,1)
(1373,3597,1)
(1663,8090,1)
(5036,6047,1)
(2320,7092,1)
(3093,598,1)
(4160,6084,1)
(7063,1530,1)
(234,5691,1)
(3995,6279,1)
(2468,5266,1)
(4090,7892,1)
(5441,3586,1)
(2832,3469,1)
(8014,8286,1)
(8243,3570,1)
(364,4928,1)
(5088,4928,1)
(7357,5273,1)
(1545,5675,1)
(5355,3329,1)
(8185,1466,1)
(3624,1046,1)
(5443,7820,1)
(4151,6953,1)
(8366,6157,1)
(5890,7946,1)
(9089,5137,1)
(8791,5647,1)
(6086,1060,1)
(7833,7717,1)
(5920,8593,1)
(7478,7688,1)
(520,8700,1)
(5416,2803,1)
(532,7842,1)
(5321,6232,1)
(2735,430,1)
(2579,124,1)
(1270,4892,1)
(7728,4237,1)
(7676,4681,1)
(6304,2204,1)
(2603,5754,1)
(3129,7734,1)
(5859,7390,1)
(4691,3051,1)
(2796,1474,1)
(122,5005,1)
(3085,3214,1)
(1762,1502,1)
(8244,1905,1)
(8035,7260,1)
(159,4770,1)
(8540,5821,1)
(1316,8081,1)
(1798,1964,1)
(8912,8636,1)
(6033,2963,1)
(1597,2752,1)
(8310,8998,1)
(7023,1841,1)
(4872,6707,1)
(64,1216,1)
(5153,3079,1)
(2971,2047,1)
(2371,8101,1)
(3348,9087,1)
(2174,996,1)
(585,7002,1)
(759,7388,1)
(2740,9014,1)
(5707,7627,1)
(3949,8948,1)
(1818,1645,1)
(2869,7100,1)
(8636,4928,1)
(5311,615,1)
(1133,3409,1)
(8333,3122,1)
(5757,4928,1)
(998,8015,1)
(3730,6047,1)
(6370,1266,1)
(4310,1193,1)
(5458,6669,1)
(101,1199,1)
(3578,8564,1)
(2660,4997,1)
(5356,1502,1)
(8792,4182,1)
(2656,527,1)
(2674,2669,1)
(8017,1798,1)
(820,5069,1)
(3441,4634,1)
(2280,9005,1)
(464,7392,1)
(6243,5939,1)
(567,1502,1)
(6436,8424,1)
(7537,2619,1)
(4502,2860,1)
(1000,5263,1)
(1584,5027,1)
(254,5591,1)
(1743,9120,1)
(3939,7884,1)
(7005,4920,1)
(4623,7518,1)
(8147,7841,1)
(4963,34,1)
(3595,2404,1)
(4429,5422,1)
(3670,2011,1)
(2749,7419,1)
(2016,8525,1)
(4642,1353,1)
(7649,4545,1)
(6008,1502,1)
(4078,4734,1)
(4400,6297,1)
(5862,5154,1)
(958,4664,1)
(1897,5165,1)
(901,7393,1)
(946,4087,1)
(6440,4874,1)
(7208,8065,1)
(6818,4541,1)
(8829,908,1)
(2705,941,1)
(4418,8474,1)
(3963,481,1)
(9037,1489,1)
(2945,6463,1)
(2864,1058,1)
(8688,3681,1)
(5,6634,1)
(7164,4122,1)
(4252,951,1)
(6445,134,1)
(5802,7396,1)
(3718,7641,1)
(4721,2264,1)
(836,8212,1)
(3669,4928,1)
(2735,8906,1)
(540,4977,1)
(6739,8600,1)
(8606,1858,1)
(4946,7890,1)
(7864,8803,1)
(7117,8588,1)
(7405,6931,1)
(626,4923,1)
(8358,309,1)
(1240,3505,1)
(2856,8799,1)
(5252,6784,1)
(6711,6836,1)
(5683,5902,1)
(2735,7384,1)
(7403,2036,1)
(847,335,1)
(2011,8083,1)
(514,882,1)
(8638,1139,1)
(5988,1502,1)
(4206,2417,1)
(6161,4276,1)
(841,5701,1)
(3159,4928,1)
(9037,7461,1)
(6704,4804,1)
(8310,2177,1)
(2111,5163,1)
(7366,1402,1)
(298,7288,1)
(5741,8687,1)
(7229,4220,1)
(1968,1502,1)
(5968,4980,1)
(5503,2865,1)
(1587,1522,1)
(5049,549,1)
(6504,52,1)
(4313,455,1)
(1603,2030,1)
(8178,6274,1)
(5294,7600,1)
(7344,1651,1)
(3363,4889,1)
(936,6691,1)
(5291,6689,1)
(7655,8757,1)
(967,5168,1)
(994,8786,1)
(2847,4929,1)
(2297,5950,1)
(344,1937,1)
(2619,1755,1)
(7952,38,1)
(3220,2697,1)
(8673,6836,1)
(6375,5472,1)
(1197,1502,1)
(794,2661,1)
(5517,3435,1)
(8329,6355,1)
(4835,5612,1)
(1516,7621,1)
(1004,7526,1)
(3690,6949,1)
(5199,4833,1)
(2555,7196,1)
(4031,5038,1)
(1096,5471,1)
(1760,5043,1)
(2119,495,1)
(3967,817,1)
(5327,1770,1)
(8005,8290,1)
(2491,1623,1)
(3118,5,1)
(303,806,1)
(7260,7251,1)
(7369,4678,1)
(615,2308,1)
(3115,5525,1)
(7080,1502,1)
(6104,3995,1)
(8227,4928,1)
(4699,1341,1)
(4846,7100,1)
(39,6526,1)
(8558,2388,1)
(8074,6222,1)
(6297,5132,1)
(3366,7000,1)
(1709,410,1)
(7496,111,1)
(4629,9146,1)
(7763,8504,1)
(2385,3233,1)
(7257,586,1)
(821,2604,1)
(4183,4928,1)
(6063,764,1)
(8829,598,1)
(8743,8606,1)
(900,8913,1)
(3874,6431,1)
(3832,160,1)
(1539,4928,1)
(4886,1473,1)
(4547,5915,1)
(5085,6513,1)
(2863,1502,1)
(2576,6879,1)
(1667,3112,1)
(4218,1972,1)
(5390,5815,1)
(4371,1502,1)
(5386,6040,1)
(1528,6677,1)
(4442,6699,1)
(8829,3465,1)
(3302,2593,1)
(3618,4928,1)
(466,7451,1)
(6198,1840,1)
(1028,1502,1)
(866,3252,1)
(597,8468,1)
(3698,3083,1)
(4919,5523,1)
(7328,3095,1)
(8601,5111,1)
(6309,7009,1)
(6029,7400,1)
(7368,4701,1)
(4230,6282,1)
(4437,3465,1)
(2428,8619,1)
(220,1438,1)
(7240,1502,1)
(8021,8388,1)
(4277,6614,1)
(9063,3192,1)
(3373,8842,1)
(6564,5549,1)
(7991,988,1)
(2643,217,1)
(4667,6900,1)
(7717,1502,1)
(4709,804,1)
(5362,5122,1)
(8279,7981,1)
(7961,7963,1)
(6351,4928,1)
(2187,358,1)
(6615,2638,1)
(3216,5043,1)
(2663,7343,1)
(2902,7474,1)
(4628,7808,1)
(3119,8299,1)
(7645,5902,1)
(176,149,1)
(5294,8757,1)
(4265,6621,1)
(3135,6434,1)
(5636,2590,1)
(4001,2760,1)
(8790,2689,1)
(7538,2597,1)
(8211,7540,1)
(7092,1826,1)
(8421,6690,1)
(69,6830,1)
(497,6487,1)
(2002,5008,1)
(476,2913,1)
(2383,6026,1)
(2323,7359,1)
(2241,5707,1)
(6690,3446,1)
(5359,1502,1)
(1467,3026,1)
(1170,4596,1)
(4135,5351,1)
(5686,5043,1)
(8273,5975,1)
(8408,7074,1)
(6575,5082,1)
(8838,6962,1)
(4403,9089,1)
(4602,7904,1)
(2961,6698,1)
(3411,2893,1)
(3867,8079,1)
(7278,2536,1)
(4026,7791,1)
(8944,4928,1)
(6652,6938,1)
(2970,285,1)
(5490,1861,1)
(5294,1222,1)
(2374,6137,1)
(7688,6627,1)
(5119,1463,1)
(7811,2133,1)
(6779,4587,1)
(8175,2348,1)
(1551,8629,1)
(574,1076,1)
(2384,229,1)
(3064,7141,1)
(7427,4928,1)
(2050,2767,1)
(1879,9120,1)
(8966,4928,1)
(2731,8159,1)
(7889,4928,1)
(7662,8905,1)
(8563,8774,1)
(5764,7755,1)
(5225,7122,1)
(6579,8642,1)
(9148,7041,1)
(9083,1502,1)
(5294,577,1)
(589,5547,1)
(7229,7468,1)
(8195,935,1)
(1625,4270,1)
(4487,6195,1)
(6146,1787,1)
(5966,5099,1)
(7257,8563,1)
(4082,8599,1)
(3591,5574,1)
(5477,5389,1)
(2771,3810,1)
(3660,8873,1)
(2475,4030,1)
(6196,6452,1)
(1159,3022,1)
(2015,8375,1)
(8868,390,1)
(6617,4551,1)
(7115,5043,1)
(5341,7183,1)
(4598,8239,1)
(6148,4928,1)
(62,1679,1)
(8510,5545,1)
(8101,7875,1)
(7889,5478,1)
(1049,8748,1)
(2202,4928,1)
(1402,8308,1)
(2346,8566,1)
(3291,883,1)
(803,4473,1)
(8502,1930,1)
(5337,6847,1)
(7692,4152,1)
(2735,1758,1)
(242,1502,1)
(7554,2891,1)
(956,2953,1)
(504,932,1)
(6580,7394,1)
(972,1502,1)
(6610,1383,1)
(8966,8613,1)
(8362,6358,1)
(3193,6909,1)
(4252,4991,1)
(7374,4928,1)
(2850,2972,1)
(3249,3526,1)
(5379,7676,1)
(8086,5370,1)
(4389,438,1)
(3522,7214,1)
(588,3600,1)
(8179,1502,1)
(3456,4928,1)
(3121,5407,1)
(9062,7201,1)
(504,8678,1)
(2122,3393,1)
(3277,9003,1)
(7529,1502,1)
(4291,6821,1)
(6382,1904,1)
(3216,5963,1)
(3636,7997,1)
(1929,5686,1)
(9000,544,1)
(5251,5406,1)
(1108,496,1)
(4646,8664,1)
(3847,4667,1)
(4411,8320,1)
(5691,6845,1)
(8811,7032,1)
(8439,6417,1)
(7991,1489,1)
(2064,257,1)
(4640,6047,1)
(8471,4435,1)
(1128,1502,1)
(7585,947,1)
(4553,1209,1)
(8746,2330,1)
(1891,3969,1)
(4812,603,1)
(2839,3756,1)
(6392,8754,1)
(8829,2894,1)
(6988,4386,1)
(5665,3307,1)
(4056,3159,1)
(3770,4049,1)
(2381,1505,1)
(1235,4643,1)
(2313,7745,1)
(63,3626,1)
(7216,6637,1)
(5753,1931,1)
(9071,4928,1)
(3230,77,1)
(2718,5938,1)
(3902,8528,1)
(2483,4612,1)
(4163,7056,1)
(3076,7027,1)
(8678,4669,1)
(2656,5249,1)
(831,8206,1)
(2457,7798,1)
(455,6834,1)
(2721,6246,1)
(4942,5228,1)
(1007,5436,1)
(1218,4928,1)
(1741,7135,1)
(5352,7284,1)
(1688,1502,1)
(7991,6465,1)
(177,5455,1)
(5306,1328,1)
(6705,4928,1)
(2140,6919,1)
(1184,7928,1)
(7377,4928,1)
(4327,3642,1)
(6195,6462,1)
(7172,6237,1)
(2178,4928,1)
(3213,8848,1)
(7868,4497,1)
(2029,8154,1)
(4313,7238,1)
(4590,3583,1)
(284,8867,1)
(4472,7148,1)
(3026,7807,1)
(8122,1731,1)
(831,3698,1)
(4352,1502,1)
(6759,2474,1)
(6527,3961,1)
(6962,1240,1)
(8025,5473,1)
(4712,8657,1)
(3493,1502,1)
(5906,2410,1)
(8925,1910,1)
(9011,6387,1)
(5624,1193,1)
(2277,3247,1)
(4521,3386,1)
(2483,5351,1)
(7377,6047,1)
(2458,9040,1)
(280,1973,1)
(7468,2893,1)
(7773,4928,1)
(8747,6776,1)
(7525,8362,1)
(3549,6075,1)
(8593,4024,1)
(3840,6218,1)
(2869,2894,1)
(7937,6158,1)
(4455,1502,1)
(8728,4220,1)
(3347,290,1)
(3123,1439,1)
(1555,6815,1)
(3663,6392,1)
(1858,5173,1)
(7077,8678,1)
(3972,8278,1)
(2230,4384,1)
(515,6570,1)
(115,8362,1)
(2999,2898,1)
(5984,6577,1)
(743,5661,1)
(5559,7312,1)
(1745,8777,1)
(6964,1062,1)
(2921,5852,1)
(1328,7643,1)
(8879,667,1)
(5523,4278,1)
(8458,1798,1)
(8829,3674,1)
(8136,4928,1)
(5641,1502,1)
(6235,6650,1)
(93,5753,1)
(2044,5552,1)
(8470,8220,1)
(725,5810,1)
(4490,1502,1)
(5205,348,1)
(2102,5024,1)
(2100,4744,1)
(4659,1150,1)
(9116,1502,1)
(7992,49,1)
(5294,4952,1)
(2803,461,1)
(8545,5871,1)
(7549,2760,1)
(5047,512,1)
(2386,4282,1)
(8964,738,1)
(825,4843,1)
(7826,4457,1)
(8755,5724,1)
(5382,5786,1)
(8651,1838,1)
(6672,2369,1)
(7479,2686,1)
(6170,5902,1)
(5489,6134,1)
(5795,4499,1)
(6818,4817,1)
(3561,2007,1)
(3593,8093,1)
(8361,5189,1)
(187,6215,1)
(4397,1554,1)
(6722,2716,1)
(4902,3472,1)
(2441,7347,1)
(862,2311,1)
(5864,2496,1)
(4502,6750,1)
(491,1132,1)
(4699,5902,1)
(1270,2322,1)
(2359,2205,1)
(991,4984,1)
(731,8795,1)
(5314,2081,1)
(5539,5824,1)
(4086,937,1)
(5629,5564,1)
(3843,4803,1)
(6187,2951,1)
(2657,7403,1)
(9100,1502,1)
(6751,3777,1)
(1924,1749,1)
(3591,2507,1)
(5511,1683,1)
(8562,8825,1)
(2869,6465,1)
(2520,1534,1)
(1526,1924,1)
(6895,7920,1)
(153,6611,1)
(3658,9019,1)
(7377,3889,1)
(7196,4553,1)
(2735,8465,1)
(2697,1502,1)
(2081,126,1)
(4657,6047,1)
(7222,7191,1)
(1343,1999,1)
(1152,7628,1)
(6225,7457,1)
(341,2706,1)
(7496,4928,1)
(4119,3622,1)
(2368,2405,1)
(6163,2692,1)
(8810,5943,1)
(7124,6772,1)
(3122,9150,1)
(4313,8829,1)
(669,8778,1)
(4074,4220,1)
(7929,1957,1)
(2489,5467,1)
(226,6006,1)
(1884,4928,1)
(6573,4883,1)
(2870,2617,1)
(6600,336,1)
(4301,2928,1)
(6492,4576,1)
(4313,7077,1)
(6743,2438,1)
(6128,845,1)
(5231,9047,1)
(3816,8923,1)
(2735,9032,1)
(4592,7172,1)
(3719,3918,1)
(1446,6047,1)
(1053,1196,1)
(6304,2894,1)
(7945,4928,1)
(9026,7148,1)
(2266,8647,1)
(522,4598,1)
(708,5581,1)
(1103,2118,1)
(4196,7162,1)
(3712,6150,1)
(6550,3727,1)
(1331,966,1)
(3158,4302,1)
(6977,1020,1)
(9037,2893,1)
(2546,6461,1)
(5105,851,1)
(6392,5902,1)
(3412,4257,1)
(1390,1502,1)
(4325,4959,1)
(7421,1864,1)
(3466,6701,1)
(7957,4176,1)
(1515,7286,1)
(8600,7206,1)
(7831,3971,1)
(3968,6289,1)
(5610,4994,1)
(3838,1502,1)
(8012,3343,1)
(8602,8896,1)
(6640,1502,1)
(5620,1628,1)
(2262,5902,1)
(904,6314,1)
(1592,8850,1)
(1249,5427,1)
(1185,3897,1)
(5509,3169,1)
(1625,4550,1)
(2779,1873,1)
(2788,3193,1)
(1715,418,1)
(4548,354,1)
(7765,6253,1)
(8329,6431,1)
(4157,5771,1)
(712,7100,1)
(3525,2898,1)
(8477,7083,1)
(4337,4343,1)
(7114,7126,1)
(162,1176,1)
(2576,554,1)
(4043,3275,1)
(2829,3902,1)
(5940,4487,1)
(607,5043,1)
(2154,4127,1)
(541,1564,1)
(483,8408,1)
(6982,2284,1)
(7813,5950,1)
(8375,1212,1)
(6500,6994,1)
(7245,7665,1)
(7901,4311,1)
(8452,291,1)
(304,1502,1)
(7321,8150,1)
(7146,2092,1)
(876,8283,1)
(1228,5555,1)
(8692,8719,1)
(7764,3537,1)
(5992,1809,1)
(2943,8464,1)
(6360,2463,1)
(838,997,1)
(375,4627,1)
(7352,4176,1)
(3379,1502,1)
(5294,5559,1)
(2696,3851,1)
(409,3612,1)
(6387,267,1)
(5294,8678,1)
(4390,4928,1)
(6276,2394,1)
(1749,334,1)
(2180,2379,1)
(418,856,1)
(5311,1727,1)
(8513,4928,1)
(232,8543,1)
(8498,1265,1)
(3693,7016,1)
(5957,618,1)
(6159,341,1)
(4740,4928,1)
(328,1524,1)
(7521,7468,1)
(8636,1502,1)
(6099,2734,1)
(874,4258,1)
(1574,1503,1)
(8889,8489,1)
(1006,7004,1)
(554,5840,1)
(6912,872,1)
(5310,4928,1)
(625,3739,1)
(4070,3822,1)
(17,2145,1)
(8233,867,1)
(7168,2994,1)
(3072,8494,1)
(8712,249,1)
(2391,4928,1)
(7928,6489,1)
(9037,677,1)
(9123,2241,1)
(195,5901,1)
(4451,2756,1)
(2464,3380,1)
(5694,2254,1)
(5392,4071,1)
(8030,7571,1)
(4775,1676,1)
(6054,8121,1)
(2152,1039,1)
(6252,491,1)
(3723,3218,1)
(3503,6942,1)
(6979,871,1)
(8829,5115,1)
(181,1213,1)
(2571,8751,1)
(2635,5709,1)
(5294,4037,1)
(4130,6431,1)
(1493,4988,1)
(5667,8775,1)
(1036,726,1)
(7515,1831,1)
(1651,726,1)
(7468,1128,1)
(4332,6047,1)
(4550,2161,1)
(3182,7862,1)
(59,282,1)
(1288,2969,1)
(3334,4827,1)
(5776,7420,1)
(7053,5768,1)
(3458,2228,1)
(8089,8421,1)
(3915,4390,1)
(3779,4092,1)
(1712,201,1)
(6286,1611,1)
(332,5043,1)
(3137,8676,1)
(2168,2538,1)
(8337,7265,1)
(8117,1502,1)
(1289,4928,1)
(1861,662,1)
(7666,6495,1)
(6545,4034,1)
(5927,7615,1)
(5510,962,1)
(2988,3675,1)
(1901,1502,1)
(4401,7092,1)
(1449,2073,1)
(2806,6482,1)
(9021,7961,1)
(5572,7291,1)
(7206,8584,1)
(9002,269,1)
(1354,8581,1)
(6410,4765,1)
(8735,6759,1)
(609,5201,1)
(6715,2300,1)
(1047,8177,1)
(980,6257,1)
(8083,3684,1)
(1528,7725,1)
(6871,7673,1)
(7058,2328,1)
(7641,5213,1)
(1780,4524,1)
(2037,1017,1)
(5286,6785,1)
(7855,2801,1)
(1321,3433,1)
(2498,2425,1)
(7390,2653,1)
(7017,831,1)
(4187,852,1)
(4076,6431,1)
(2440,6731,1)
(3736,3188,1)
(4246,2917,1)
(1888,3143,1)
(7734,8768,1)
(6621,1601,1)
(7012,3046,1)
(8868,8895,1)
(6534,2343,1)
(4437,7461,1)
(6861,6459,1)
(6348,6047,1)
(712,3313,1)
(2278,6256,1)
(8079,5930,1)
(4070,8849,1)
(1988,8678,1)
(2992,5695,1)
(4464,3332,1)
(7076,4928,1)
(2630,3137,1)
(1334,4928,1)
(6712,3141,1)
(8152,7060,1)
(3030,8740,1)
(2320,6465,1)
(4357,8075,1)
(8410,971,1)
(5206,2450,1)
(6373,7021,1)
(1925,8217,1)
(5834,856,1)
(5881,3287,1)
(5497,5184,1)
(1687,2859,1)
(3438,4463,1)
(1901,4309,1)
(4624,740,1)
(8517,8785,1)
(2700,5845,1)
(332,7425,1)
(3169,6413,1)
(2743,6283,1)
(7162,5266,1)
(2915,4781,1)
(4717,1537,1)
(9037,908,1)
(5073,5233,1)
(7141,1932,1)
(1889,1641,1)
(5192,4830,1)
(5832,7592,1)
(6213,6145,1)
(2656,5803,1)
(2730,4056,1)
(4412,8079,1)
(2349,4695,1)
(8036,3576,1)
(6542,6144,1)
(1717,4142,1)
(3486,1502,1)
(7552,3843,1)
(4913,7785,1)
(4610,7917,1)
(6651,1271,1)
(5767,8499,1)
(5419,4126,1)
(1668,4790,1)
(4051,8135,1)
(2073,4744,1)
(251,5215,1)
(4967,5995,1)
(4236,17,1)
(8234,3075,1)
(3963,87,1)
(2869,5559,1)
(3265,5902,1)
(6875,3844,1)
(3236,4905,1)
(7079,2173,1)
(4076,8933,1)
(2392,7881,1)
(2008,4928,1)
(2715,4928,1)
(95,8557,1)
(344,1777,1)
(7783,4744,1)
(345,5669,1)
(242,7585,1)
(6902,1700,1)
(1358,2550,1)
(1339,1357,1)
(7468,2113,1)
(6891,2015,1)
(5499,8300,1)
(8633,4338,1)
(6260,6203,1)
(2459,5902,1)
(5120,1584,1)
(3184,4928,1)
(5294,820,1)
(8988,4674,1)
(593,4628,1)
(360,2528,1)
(6290,3870,1)
(2735,1684,1)
(3289,2126,1)
(2508,3969,1)
(8353,5207,1)
(5043,4534,1)
(6679,4500,1)
(5846,7372,1)
(6525,5562,1)
(3963,7518,1)
(6211,3449,1)
(1482,1728,1)
(7740,7216,1)
(2345,356,1)
(1925,8469,1)
(1930,5411,1)
(4049,299,1)
(2905,452,1)
(2869,598,1)
(3913,825,1)
(1083,1776,1)
(1284,1907,1)
(6315,3415,1)
(2728,1502,1)
(2735,6347,1)
(1553,2810,1)
(7929,6645,1)
(2270,8974,1)
(3923,5674,1)
(341,7790,1)
(7435,1502,1)
(1295,9044,1)
(262,1397,1)
(5932,546,1)
(3452,405,1)
(8888,5606,1)
(6607,5801,1)
(1432,4977,1)
(8155,132,1)
(2445,2626,1)
(3330,6047,1)
(1976,6048,1)
(4850,707,1)
(2272,3391,1)
(3526,2444,1)
(1244,2105,1)
(1786,4322,1)
(1407,4818,1)
(3612,8811,1)
(67,7434,1)
(4467,8606,1)
(2566,4155,1)
(4596,1427,1)
(8304,1694,1)
(6247,2898,1)
(3388,4569,1)
(2956,2814,1)
(5457,2748,1)
(7081,1398,1)
(5618,5230,1)
(288,4995,1)
(6821,7429,1)
(1647,4085,1)
(5384,4518,1)
(6702,7468,1)
(7348,1750,1)
(6563,7767,1)
(6776,2968,1)
(4111,7916,1)
(1190,5380,1)
(3075,3564,1)
(2311,6047,1)
(3966,5115,1)
(4860,1502,1)
(1310,2263,1)
(9037,2204,1)
(6544,7181,1)
(1246,8585,1)
(5743,591,1)
(8166,7566,1)
(8067,8415,1)
(332,5902,1)
(2033,7610,1)
(7275,2070,1)
(910,3301,1)
(4656,7898,1)
(3424,3821,1)
(2908,6443,1)
(4634,2516,1)
(6976,1523,1)
(4025,7014,1)
(3352,7247,1)
(3684,742,1)
(6670,2291,1)
(6119,1502,1)
(459,7877,1)
(8948,5058,1)
(1908,6111,1)
(8230,2088,1)
(557,176,1)
(7244,2285,1)
(6494,393,1)
(6376,1898,1)
(2592,8516,1)
(1387,1502,1)
(4268,97,1)
(4222,4171,1)
(908,226,1)
(7176,5208,1)
(5155,5609,1)
(5294,5115,1)
(7166,4928,1)
(8524,8428,1)
(992,6965,1)
(3462,826,1)
(7516,8779,1)
(1953,1502,1)
(204,7691,1)
(9137,7905,1)
(2782,484,1)
(8987,5829,1)
(3579,8749,1)
(343,4139,1)
(212,2887,1)
(8832,995,1)
(606,5747,1)
(5843,511,1)
(5663,1983,1)
(891,8270,1)
(4541,823,1)
(5209,9133,1)
(551,7058,1)
(8839,3414,1)
(1768,7211,1)
(8032,2507,1)
(1530,4928,1)
(5807,2376,1)
(4763,979,1)
(5957,6299,1)
(2678,287,1)
(5756,4078,1)
(1339,7034,1)
(4131,8984,1)
(7104,1379,1)
(5454,5043,1)
(5646,6966,1)
(1045,6485,1)
(8931,1502,1)
(2742,8938,1)
(4770,7737,1)
(2340,2156,1)
(684,3195,1)
(2422,8020,1)
(3486,8812,1)
(8105,4933,1)
(2040,7063,1)
(9041,6778,1)
(7946,3311,1)
(388,468,1)
(1155,4073,1)
(1919,7000,1)
(560,2943,1)
(8561,4604,1)
(250,6532,1)
(7126,3240,1)
(6224,4056,1)
(561,2198,1)
(3795,5194,1)
(8188,2487,1)
(8147,3609,1)
(7150,8703,1)
(9026,1591,1)
(5929,159,1)
(5778,2565,1)
(8560,3583,1)
(607,4404,1)
(2625,8565,1)
(4572,7100,1)
(7841,1366,1)
(3184,8257,1)
(5917,774,1)
(5757,834,1)
(9091,3940,1)
(9105,2602,1)
(698,1480,1)
(7790,7979,1)
(1661,1528,1)
(1002,6509,1)
(3801,3980,1)
(1955,3982,1)
(5568,5257,1)
(7899,441,1)
(2355,7762,1)
(2136,1502,1)
(284,5085,1)
(615,7111,1)
(2879,2034,1)
(4734,1742,1)
(1170,4928,1)
(5825,5229,1)
(1717,8387,1)
(7960,598,1)
(735,350,1)
(7817,4000,1)
(3383,917,1)
(2440,2834,1)
(8494,8900,1)
(8441,1290,1)
(5071,1502,1)
(75,7413,1)
(4900,1567,1)
(5456,3263,1)
(6995,4497,1)
(7046,7092,1)
(598,1502,1)
(8954,4292,1)
(1945,6047,1)
(3362,1819,1)
(4368,3885,1)
(7750,1502,1)
(2267,9136,1)
(2649,5480,1)
(2835,1502,1)
(2129,6363,1)
(2120,1011,1)
(1698,4928,1)
(6758,737,1)
(8973,6047,1)
(2491,6047,1)
(3234,6617,1)
(8118,5798,1)
(1662,5323,1)
(2911,5567,1)
(7215,4065,1)
(2676,7672,1)
(4328,370,1)
(5011,2806,1)
(7617,7247,1)
(2359,1502,1)
(4222,5902,1)
(4860,5288,1)
(6700,1091,1)
(8179,8693,1)
(2045,4891,1)
(8802,6380,1)
(1563,2936,1)
(1686,6886,1)
(6238,1502,1)
(1136,2420,1)
(6868,164,1)
(28,729,1)
(3604,7635,1)
(4943,5745,1)
(5145,1111,1)
(1158,4928,1)
(4375,3172,1)
(2051,1320,1)
(769,3621,1)
(7682,6277,1)
(4798,547,1)
(1530,6163,1)
(3682,5055,1)
(4811,4860,1)
(6249,3171,1)
(8152,8282,1)
(6150,3,1)
(598,3628,1)
(7727,6251,1)
(6039,6205,1)
(6232,2849,1)
(2606,4315,1)
(4144,8823,1)
(6644,3074,1)
(3777,1502,1)
(251,8459,1)
(6638,8412,1)
(5759,1502,1)
(1168,7232,1)
(7609,8389,1)
(4888,3317,1)
(5024,4422,1)
(4364,7888,1)
(4846,4551,1)
(4128,2854,1)
(1619,283,1)
(4845,1502,1)
(5261,5024,1)
(4732,4448,1)
(4561,4928,1)
(3476,6863,1)
(7150,3238,1)
(4803,4731,1)
(4518,5086,1)
(2023,4821,1)
(6904,7376,1)
(2994,4054,1)
(3775,1421,1)
(3190,5598,1)
(3061,263,1)
(6172,8772,1)
(7092,5937,1)
(7507,1622,1)
(876,7821,1)
(6664,751,1)
(4679,8481,1)
(7829,101,1)
(5291,8299,1)
(1109,8200,1)
(8785,8161,1)
(5737,8476,1)
(3433,1502,1)
(3948,1940,1)
(5865,3396,1)
(5585,1048,1)
(8769,8027,1)
(4022,334,1)
(8508,8646,1)
(988,3860,1)
(91,144,1)
(3632,2929,1)
(7744,6898,1)
(2079,4490,1)
(8433,8084,1)
(8541,1502,1)
(1221,7476,1)
(7195,8637,1)
(5960,8447,1)
(3409,1502,1)
(7169,374,1)
(2320,8678,1)
(426,3500,1)
(74,6956,1)
(6806,4196,1)
(2589,1502,1)
(4890,1698,1)
(4229,4296,1)
(3244,8159,1)
(62,6120,1)
(4572,8188,1)
(2753,1502,1)
(5522,1254,1)
(8894,326,1)
(5294,6247,1)
(9043,1502,1)
(3024,5840,1)
(3827,5973,1)
(6967,2399,1)
(1866,8216,1)
(6199,98,1)
(4378,1891,1)
(9080,2774,1)
(7897,2978,1)
(4318,8119,1)
(5642,1557,1)
(4452,4312,1)
(712,6465,1)
(41,7513,1)
(2469,4878,1)
(6002,2533,1)
(6153,8524,1)
(7433,5524,1)
(8282,626,1)
(5531,3221,1)
(6274,4706,1)
(8916,2703,1)
(4161,3340,1)
(635,933,1)
(5659,7025,1)
(2555,4725,1)
(7905,7405,1)
(8213,3243,1)
(4237,2993,1)
(2568,4928,1)
(6416,5223,1)
(6631,6789,1)
(772,1502,1)
(3661,5108,1)
(5456,5700,1)
(8313,6360,1)
(4455,4928,1)
(8247,7900,1)
(8913,2912,1)
(6561,6364,1)
(5644,1019,1)
(4525,7535,1)
(7060,5335,1)
(6352,3194,1)
(4955,8696,1)
(4437,2113,1)
(2285,8233,1)
(8945,4928,1)
(2911,4178,1)
(4009,1883,1)
(2369,2148,1)
(7165,7682,1)
(5077,1502,1)
(4313,4472,1)
(4559,289,1)
(1518,52,1)
(1119,5662,1)
(442,2472,1)
(5723,2742,1)
(6181,7004,1)
(4297,8091,1)
(4673,1502,1)
(6304,2703,1)
(504,2893,1)
(6568,2678,1)
(6304,3465,1)
(2949,8362,1)
(8835,7102,1)
(4470,1335,1)
(3090,533,1)
(4312,6803,1)
(5664,7996,1)
(2405,2122,1)
(6481,1086,1)
(4499,2685,1)
(7178,1690,1)
(4322,3838,1)
(3250,4928,1)
(4992,3126,1)
(4973,6390,1)
(668,1935,1)
(8316,2660,1)
(3488,2256,1)
(860,7646,1)
(8874,3313,1)
(3505,5397,1)
(4133,6495,1)
(4782,291,1)
(6262,6403,1)
(2381,3905,1)
(8563,9055,1)
(7469,3352,1)
(2677,4602,1)
(5435,8623,1)
(4500,7574,1)
(59,3112,1)
(5215,8459,1)
(1497,8975,1)
(2325,3082,1)
(3797,447,1)
(7115,8591,1)
(1637,3566,1)
(176,6047,1)
(2204,6980,1)
(8189,3225,1)
(1040,1599,1)
(659,1829,1)
(1360,4928,1)
(7013,1938,1)
(4293,4928,1)
(1855,6397,1)
(4185,5403,1)
(1644,6186,1)
(2975,5576,1)
(5967,9117,1)
(47,1548,1)
(5454,4217,1)
(4034,1539,1)
(1698,7120,1)
(6798,2784,1)
(1882,5218,1)
(7563,4928,1)
(5459,3702,1)
(29,260,1)
(6426,3959,1)
(5545,4045,1)
(7261,3724,1)
(3263,5916,1)
(355,3418,1)
(2022,2350,1)
(7033,3360,1)
(6304,8678,1)
(1900,1178,1)
(7577,8802,1)
(949,1005,1)
(8418,1232,1)
(6721,4956,1)
(6739,7206,1)
(5269,2520,1)
(4923,1259,1)
(2751,6324,1)
(3196,6469,1)
(1760,5902,1)
(7089,5579,1)
(3498,8875,1)
(2737,3104,1)
(2465,1693,1)
(1246,997,1)
(5189,3632,1)
(1451,2898,1)
(5871,5802,1)
(2539,4961,1)
(212,8809,1)
(616,1540,1)
(3214,7136,1)
(7521,7582,1)
(7562,6431,1)
(1785,1637,1)
(1835,4509,1)
(1695,1314,1)
(311,6376,1)
(7497,3017,1)
(5715,6096,1)
(4509,1009,1)
(8672,135,1)
(5803,5635,1)
(4959,404,1)
(4437,1228,1)
(2052,7373,1)
(457,6933,1)
(3757,9062,1)
(6308,7823,1)
(3317,3407,1)
(2895,956,1)
(4096,8057,1)
(876,8545,1)
(2245,6625,1)
(9148,1502,1)
(4871,1836,1)
(4437,8037,1)
(58,4880,1)
(1092,3525,1)
(2735,5123,1)
(2012,8601,1)
(7457,1761,1)
(7422,4928,1)
(2735,7334,1)
(2662,1487,1)
(4194,4119,1)
(5097,1502,1)
(8717,9044,1)
(7466,4928,1)
(8149,8855,1)
(3543,1502,1)
(8847,6982,1)
(8690,3173,1)
(4640,8309,1)
(841,4353,1)
(182,8760,1)
(7720,7468,1)
(6830,6047,1)
(5214,5947,1)
(4163,5065,1)
(1311,5187,1)
(4347,1502,1)
(7984,1505,1)
(2900,8978,1)
(6948,298,1)
(7046,8678,1)
(1208,7160,1)
(2430,6557,1)
(2055,3057,1)
(7514,6764,1)
(6636,4256,1)
(1270,7628,1)
(4138,4378,1)
(7764,2708,1)
(7241,6002,1)
(4684,2980,1)
(1883,6767,1)
(7686,6240,1)
(9052,8921,1)
(1965,5991,1)
(6657,3857,1)
(6304,6277,1)
(524,7264,1)
(7836,2120,1)
(7174,8471,1)
(4529,107,1)
(578,4301,1)
(8032,2322,1)
(6374,2903,1)
(5221,2057,1)
(2055,6047,1)
(1627,3029,1)
(5280,8894,1)
(6893,2875,1)
(1405,1861,1)
(3300,1154,1)
(6981,767,1)
(8399,3874,1)
(4916,9101,1)
(433,2204,1)
(7946,1782,1)
(7131,4928,1)
(7415,1000,1)
(1449,5551,1)
(5548,788,1)
(7149,6128,1)
(6971,4935,1)
(5332,4584,1)
(8753,7838,1)
(1931,6131,1)
(5195,1189,1)
(5848,7319,1)
(2802,4349,1)
(7219,3557,1)
(7978,1109,1)
(7797,5289,1)
(3427,1320,1)
(5761,8865,1)
(6411,1499,1)
(4259,3153,1)
(7179,2358,1)
(4156,7936,1)
(8525,7377,1)
(1171,2131,1)
(1615,7743,1)
(2014,7513,1)
(5983,4776,1)
(2494,1502,1)
(2645,5664,1)
(4666,8263,1)
(4313,2677,1)
(248,3350,1)
(7823,2493,1)
(3083,1502,1)
(785,1428,1)
(7237,1735,1)
(7261,1502,1)
(8623,6705,1)
(1025,3288,1)
(6491,1142,1)
(4960,3532,1)
(3111,44,1)
(1718,5400,1)
(514,7304,1)
(6117,2739,1)
(5525,3366,1)
(4125,7590,1)
(3377,5972,1)
(5890,1250,1)
(4344,6692,1)
(5722,4350,1)
(7722,3151,1)
(3529,2553,1)
(4846,6465,1)
(7392,3001,1)
(6428,4906,1)
(7379,2407,1)
(1067,1502,1)
(8123,1904,1)
(8081,7432,1)
(1381,7491,1)
(9007,8809,1)
(5692,4397,1)
(1326,8589,1)
(369,1110,1)
(2838,7079,1)
(5245,6598,1)
(6724,9083,1)
(1774,8792,1)
(4823,8487,1)
(9037,7148,1)
(5075,46,1)
(697,7719,1)
(8650,4072,1)
(5735,4721,1)
(189,911,1)
(1299,4723,1)
(712,7148,1)
(8416,8556,1)
(3142,6631,1)
(1099,1046,1)
(7225,1624,1)
(2379,7280,1)
(5294,8578,1)
(6047,1481,1)
(3343,1502,1)
(4072,1283,1)
(1414,1796,1)
(638,1502,1)
(3033,428,1)
(1793,598,1)
(1884,1502,1)
(4851,405,1)
(382,5826,1)
(5217,7430,1)
(823,1237,1)
(7551,3227,1)
(8498,4176,1)
(8933,3014,1)
(4448,4958,1)
(1269,7732,1)
(642,1502,1)
(1380,1468,1)
(1292,1722,1)
(7346,6584,1)
(876,8934,1)
(7261,4928,1)
(6222,1274,1)
(3352,7617,1)
(2501,1995,1)
(2514,5392,1)
(9042,5043,1)
(6014,7367,1)
(4115,6431,1)
(7061,8335,1)
(1982,8826,1)
(2166,4928,1)
(4912,4928,1)
(5680,1239,1)
(790,2074,1)
(1684,4053,1)
(663,2860,1)
(1501,8699,1)
(2572,4263,1)
(8710,7686,1)
(8877,6818,1)
(3138,5512,1)
(6959,909,1)
(943,930,1)
(4313,3302,1)
(2080,7001,1)
(5211,1892,1)
(4473,9102,1)
(1152,7821,1)
(8851,4928,1)
(5415,3294,1)
(1457,8863,1)
(974,5561,1)
(1290,7353,1)
(8855,4928,1)
(752,4485,1)
(666,3028,1)
(4741,4050,1)
(8255,2403,1)
(5124,9156,1)
(3548,998,1)
(283,4191,1)
(5300,312,1)
(1778,501,1)
(5380,3270,1)
(5474,4075,1)
(6654,1605,1)
(328,1502,1)
(6284,8169,1)
(7963,4757,1)
(5646,9058,1)
(7568,4888,1)
(5551,2073,1)
(6693,3629,1)
(1648,273,1)
(8590,421,1)
(6939,1502,1)
(2612,5712,1)
(5890,3639,1)
(7049,1502,1)
(2152,1502,1)
(1685,5997,1)
(1970,1610,1)
(3907,5140,1)
(4072,3836,1)
(2320,2893,1)
(5329,7468,1)
(5113,1502,1)
(6304,1855,1)
(8840,4588,1)
(5334,9127,1)
(3894,3170,1)
(2398,1244,1)
(1738,2245,1)
(4200,1502,1)
(8700,5248,1)
(8825,2425,1)
(2249,4394,1)
(1091,7693,1)
(4631,7264,1)
(4264,3511,1)
(4764,3025,1)
(2491,4928,1)
(8251,8735,1)
(8459,4482,1)
(1460,1502,1)
(6304,1128,1)
(5535,5444,1)
(9109,8370,1)
(5713,6394,1)
(5002,121,1)
(2236,1494,1)
(5142,1502,1)
(7662,6724,1)
(8813,307,1)
(6044,8636,1)
(6390,9145,1)
(3805,2107,1)
(1142,6431,1)
(6268,4963,1)
(6304,7100,1)
(3274,7462,1)
(9037,8037,1)
(2026,3120,1)
(5118,1665,1)
(5374,8162,1)
(362,8379,1)
(5343,1502,1)
(209,4928,1)
(995,6756,1)
(1727,4756,1)
(1117,5147,1)
(8799,4961,1)
(5426,3358,1)
(7205,624,1)
(3841,8492,1)
(5140,8348,1)
(389,7567,1)
(4196,7281,1)
(7697,4928,1)
(8824,972,1)
(7853,5206,1)
(4302,4808,1)
(8384,5530,1)
(1991,2816,1)
(4970,1573,1)
(181,775,1)
(6359,2994,1)
(2235,1267,1)
(5536,4093,1)
(4139,4744,1)
(6262,4928,1)
(4440,721,1)
(7612,7892,1)
(1337,6428,1)
(5080,1502,1)
(1423,4357,1)
(3831,8835,1)
(4074,1502,1)
(8905,6724,1)
(1530,1502,1)
(8361,1689,1)
(3389,398,1)
(4446,2794,1)
(2299,4928,1)
(6137,5896,1)
(3868,6195,1)
(1512,4696,1)
(2869,8188,1)
(3489,1502,1)
(4414,7011,1)
(9037,8188,1)
(4655,799,1)
(894,5998,1)
(396,3914,1)
(5991,1901,1)
(134,6843,1)
(6523,7463,1)
(5410,5986,1)
(3302,4551,1)
(5604,7816,1)
(7666,4133,1)
(492,7407,1)
(5987,6124,1)
(5439,4229,1)
(8866,1404,1)
(1577,4281,1)
(4196,5266,1)
(8857,2895,1)
(2258,3344,1)
(7402,5314,1)
(6696,4445,1)
(8391,4858,1)
(8044,9025,1)
(612,5969,1)
(326,3727,1)
(8117,2610,1)
(8582,2763,1)
(4874,4928,1)
(7484,7443,1)
(2410,1515,1)
(1293,2069,1)
(5896,6047,1)
(852,4692,1)
(8188,4636,1)
(4247,4020,1)
(8436,1515,1)
(2100,573,1)
(247,2686,1)
(6785,2898,1)
(3489,4928,1)
(1531,2911,1)
(8489,8269,1)
(755,1994,1)
(8068,93,1)
(646,1766,1)
(6735,4849,1)
(8683,2962,1)
(3669,1502,1)
(2038,98,1)
(6714,8038,1)
(8829,6560,1)
(9026,5115,1)
(7563,1502,1)
(7384,2557,1)
(1604,7207,1)
(7750,3948,1)
(3708,5702,1)
(5411,1502,1)
(3319,4928,1)
(5833,2532,1)
(6640,859,1)
(4386,1663,1)
(4572,7148,1)
(890,6047,1)
(6291,2521,1)
(1476,1502,1)
(1244,6177,1)
(2299,1741,1)
(2983,8217,1)
(8687,3546,1)
(3589,4411,1)
(1679,2575,1)
(4409,1276,1)
(3793,1502,1)
(5732,1502,1)
(1200,2294,1)
(3655,8830,1)
(8385,8178,1)
(6683,4318,1)
(2459,417,1)
(7363,8640,1)
(1186,100,1)
(9014,4,1)
(1340,8271,1)
(430,186,1)
(7471,8074,1)
(5257,8416,1)
(1694,8825,1)
(5081,2904,1)
(3376,1502,1)
(3231,3328,1)
(7035,3351,1)
(3520,5477,1)
(4273,1912,1)
(4052,5073,1)
(7309,8197,1)
(291,5683,1)
(2750,6085,1)
(5942,1502,1)
(3210,812,1)
(409,6264,1)
(6773,8741,1)
(3507,2929,1)
(5273,6233,1)
(105,8320,1)
(558,38,1)
(984,4954,1)
(5494,7274,1)
(7919,6373,1)
(7768,6697,1)
(7611,5929,1)
(1470,7937,1)
(9065,1502,1)
(1569,5784,1)
(4955,7675,1)
(8065,2475,1)
(7099,1955,1)
(304,7468,1)
(6169,3978,1)
(4183,1502,1)
(4378,1655,1)
(2735,6623,1)
(4126,490,1)
(467,4986,1)
(3327,2045,1)
(2920,4548,1)
(5786,5461,1)
(633,333,1)
(3960,9008,1)
(2629,1136,1)
(5375,8911,1)
(6834,2483,1)
(8902,7537,1)
(7002,6817,1)
(5294,1591,1)
(378,5338,1)
(3384,6079,1)
(606,8180,1)
(3919,7661,1)
(4364,6366,1)
(2541,2440,1)
(4665,1339,1)
(2952,8891,1)
(2767,5043,1)
(2414,7004,1)
(5662,2867,1)
(8892,1502,1)
(961,3703,1)
(5034,3169,1)
(5176,7389,1)
(687,5944,1)
(6294,4176,1)
(956,5329,1)
(6497,194,1)
(857,5891,1)
(2279,5744,1)
(1110,803,1)
(136,3560,1)
(8010,7241,1)
(6462,1424,1)
(5302,5439,1)
(3479,8060,1)
(7341,7031,1)
(4844,6920,1)
(5506,2691,1)
(5695,2780,1)
(92,760,1)
(197,1090,1)
(8597,4224,1)
(8632,4928,1)
(4228,8602,1)
(8576,8864,1)
(8032,7821,1)
(7143,4928,1)
(1439,711,1)
(3137,7481,1)
(6301,254,1)
(2380,2243,1)
(2019,6988,1)
(2607,8163,1)
(4575,2551,1)
(6140,1128,1)
(7327,68,1)
(6430,960,1)
(527,2372,1)
(4579,4595,1)
(365,252,1)
(8312,4384,1)
(7562,1933,1)
(731,8427,1)
(6783,1329,1)
(6560,2563,1)
(5678,3705,1)
(8898,7769,1)
(7576,4071,1)
(7794,5321,1)
(8309,4231,1)
(4773,6244,1)
(5696,1502,1)
(999,2616,1)
(4099,7608,1)
(1495,7614,1)
(3898,4502,1)
(1270,2507,1)
(7258,1190,1)
(4563,2612,1)
(8479,286,1)
(1613,4968,1)
(5706,2699,1)
(742,8941,1)
(7502,8975,1)
(4190,215,1)
(3610,1565,1)
(3607,6069,1)
(5035,8486,1)
(2214,8366,1)
(7348,4928,1)
(8246,5879,1)
(1380,4928,1)
(7887,304,1)
(2252,5727,1)
(7043,6047,1)
(5402,79,1)
(6515,7038,1)
(1475,4928,1)
(2579,8311,1)
(7894,8125,1)
(7427,1502,1)
(481,7518,1)
(7913,7687,1)
(4684,1502,1)
(5400,7139,1)
(7790,5902,1)
(1250,6232,1)
(4542,6180,1)
(6580,4114,1)
(6978,8370,1)
(6967,6254,1)
(3401,1502,1)
(8850,8314,1)
(3181,2749,1)
(3243,5945,1)
(4623,826,1)
(2364,1328,1)
(915,7467,1)
(3502,1577,1)
(5753,4928,1)
(7832,6362,1)
(895,4242,1)
(2423,8149,1)
(2593,8580,1)
(8730,154,1)
(9025,8027,1)
(5168,284,1)
(6784,598,1)
(3815,66,1)
(5565,5046,1)
(3457,528,1)
(1920,1695,1)
(4808,5711,1)
(4416,6548,1)
(6056,3464,1)
(7313,6290,1)
(6162,8614,1)
(8480,1502,1)
(3991,5072,1)
(2128,1502,1)
(3864,4913,1)
(1302,284,1)
(8571,8005,1)
(45,8998,1)
(3924,1032,1)
(7642,7445,1)
(2342,4932,1)
(8829,7148,1)
(7644,1709,1)
(7130,4505,1)
(7148,3205,1)
(5294,735,1)
(8032,6610,1)
(603,2359,1)
(6410,6723,1)
(1732,7340,1)
(4877,7753,1)
(7852,8609,1)
(1463,4702,1)
(6349,7524,1)
(1254,5043,1)
(4531,1137,1)
(1270,7821,1)
(5670,5143,1)
(3566,4635,1)
(3790,3913,1)
(5106,1515,1)
(2305,8888,1)
(2574,888,1)
(6835,4721,1)
(537,5413,1)
(3280,2734,1)
(3786,3588,1)
(8480,6047,1)
(961,819,1)
(6357,3927,1)
(4769,1502,1)
(5660,3605,1)
(2073,5357,1)
(4267,1727,1)
(5141,7142,1)
(7219,7212,1)
(4572,1489,1)
(3530,6711,1)
(5849,4865,1)
(3357,5603,1)
(8993,8191,1)
(4507,7560,1)
(4768,161,1)
(8733,5290,1)
(7408,2872,1)
(2656,7847,1)
(550,4760,1)
(1311,6522,1)
(1403,5571,1)
(8318,1443,1)
(3079,7056,1)
(1945,4928,1)
(813,1502,1)
(8756,8140,1)
(8156,4404,1)
(5075,3583,1)
(1107,7314,1)
(567,7363,1)
(7736,7004,1)
(5698,7706,1)
(3039,7828,1)
(3529,6047,1)
(2926,8226,1)
(8660,8362,1)
(5167,805,1)
(3614,8013,1)
(8806,4928,1)
(6391,4928,1)
(2650,633,1)
(543,6047,1)
(7443,2039,1)
(4857,1649,1)
(6853,1502,1)
(1802,922,1)
(5921,8954,1)
(1687,4928,1)
(9044,4741,1)
(2656,9002,1)
(9009,6489,1)
(4589,1934,1)
(5896,4928,1)
(2586,5733,1)
(5219,3412,1)
(5683,1569,1)
(7896,1502,1)
(9055,5902,1)
(8505,4428,1)
(8890,4928,1)
(8383,2327,1)
(1465,7454,1)
(8800,5526,1)
(6733,7167,1)
(1959,7849,1)
(5888,8975,1)
(2336,631,1)
(3386,4946,1)
(6792,1257,1)
(6936,7406,1)
(4853,916,1)
(2840,772,1)
(8799,7526,1)
(4942,3485,1)
(3173,5676,1)
(4719,4928,1)
(8992,6560,1)
(956,1227,1)
(1238,3377,1)
(1758,2033,1)
(8832,7341,1)
(2028,2226,1)
(7221,9092,1)
(6799,5730,1)
(5886,2898,1)
(8692,5902,1)
(1001,1808,1)
(7186,6377,1)
(1823,7539,1)
(2844,2707,1)
(6630,3612,1)
(7991,1228,1)
(4672,8495,1)
(1437,8074,1)
(7160,8910,1)
(8654,8806,1)
(1882,1399,1)
(7148,2164,1)
(3575,1502,1)
(3405,507,1)
(452,4354,1)
(7715,1701,1)
(5473,3296,1)
(8757,2898,1)
(8098,3229,1)
(7432,1895,1)
(2230,8681,1)
(7350,3160,1)
(727,6605,1)
(1560,3711,1)
(4472,5115,1)
(3434,6458,1)
(7639,7595,1)
(9092,7744,1)
(1152,8545,1)
(3220,8691,1)
(4030,7282,1)
(8266,140,1)
(2085,5794,1)
(2281,5459,1)
(4853,1590,1)
(5760,1258,1)
(1237,2008,1)
(5000,5365,1)
(4571,1396,1)
(7115,4168,1)
(3467,8563,1)
(4654,4464,1)
(243,686,1)
(3563,2153,1)
(1129,69,1)
(7437,2736,1)
(3145,7035,1)
(3086,5092,1)
(9145,4928,1)
(4981,5885,1)
(5294,2039,1)
(3246,1229,1)
(2928,2526,1)
(4422,8780,1)
(4572,2894,1)
(3463,1502,1)
(3810,1289,1)
(6661,4264,1)
(4078,1087,1)
(8227,897,1)
(5294,1235,1)
(2626,8132,1)
(6858,5749,1)
(2114,8902,1)
(3765,3186,1)
(7229,2097,1)
(7809,912,1)
(6691,3536,1)
(2745,5025,1)
(3985,7912,1)
(6058,7628,1)
(8221,5859,1)
(876,2322,1)
(8278,6453,1)
(1576,730,1)
(5269,1534,1)
(4110,3815,1)
(4944,4323,1)
(3656,6907,1)
(8179,4928,1)
(4001,7549,1)
(6537,5445,1)
(2951,1913,1)
(2055,4928,1)
(2964,3279,1)
(7366,8454,1)
(4102,2269,1)
(7518,2058,1)
(6301,2950,1)
(7044,1231,1)
(3151,7853,1)
(6190,8347,1)
(3888,8694,1)
(6818,7927,1)
(5646,1270,1)
(879,6488,1)
(4786,5434,1)
(5324,5745,1)
(798,3392,1)
(8653,7893,1)
(392,8538,1)
(2224,4842,1)
(1738,1502,1)
(4408,2797,1)
(5032,8393,1)
(772,5278,1)
(8959,3528,1)
(2109,4928,1)
(464,2898,1)
(1103,7581,1)
(311,1249,1)
(4019,3693,1)
(2919,8362,1)
(7955,1502,1)
(1730,3770,1)
(5202,4810,1)
(9019,3583,1)
(4069,5474,1)
(4361,5954,1)
(2420,5978,1)
(1053,2080,1)
(3623,2116,1)
(4793,1279,1)
(5980,1502,1)
(4585,3174,1)
(9130,1502,1)
(3986,99,1)
(108,5844,1)
(2153,5696,1)
(7975,3845,1)
(5175,2172,1)
(3540,3088,1)
(8739,9040,1)
(8643,3180,1)
(1274,3793,1)
(7276,619,1)
(8829,742,1)
(1283,3836,1)
(5371,3802,1)
(1423,7481,1)
(4448,6047,1)
(8875,4222,1)
(1387,4928,1)
(412,635,1)
(933,4737,1)
(6968,1502,1)
(6782,8072,1)
(243,1251,1)
(6881,4645,1)
(7515,8412,1)
(2898,4650,1)
(4644,533,1)
(832,5166,1)
(9037,1919,1)
(508,3633,1)
(3769,640,1)
(4783,7746,1)
(2203,5151,1)
(3433,4928,1)
(1653,4376,1)
(5981,1355,1)
(1945,1502,1)
(4867,5942,1)
(5868,2333,1)
(6805,7892,1)
(8419,8545,1)
(3109,6405,1)
(8984,3634,1)
(2869,2113,1)
(5299,3077,1)
(5290,4934,1)
(1214,1471,1)
(2175,6783,1)
(104,6034,1)
(9033,1502,1)
(5662,8667,1)
(1481,4910,1)
(7521,4220,1)
(6046,483,1)
(3343,4928,1)
(5106,1550,1)
(2873,1014,1)
(3819,1300,1)
(9097,2227,1)
(3651,3808,1)
(5549,98,1)
(3989,4175,1)
(2791,7447,1)
(8078,7859,1)
(5837,339,1)
(6228,672,1)
(4155,68,1)
(2732,1502,1)
(8596,6571,1)
(4336,8131,1)
(4336,1502,1)
(3620,5067,1)
(3239,1502,1)
(4378,7516,1)
(1105,5740,1)
(8780,8462,1)
(8976,2751,1)
(1386,466,1)
(2735,5967,1)
(636,6004,1)
(1659,6328,1)
(5229,4402,1)
(1303,1502,1)
(6791,3794,1)
(1614,5045,1)
(7438,8086,1)
(351,5188,1)
(7005,948,1)
(326,8338,1)
(5625,4432,1)
(7450,3840,1)
(3101,7257,1)
(3473,1552,1)
(8691,2922,1)
(8192,4173,1)
(8174,3715,1)
(3368,1837,1)
(6314,8886,1)
(1934,4928,1)
(2056,4928,1)
(2287,3874,1)
(3001,4269,1)
(8513,1502,1)
(3697,5408,1)
(7322,8893,1)
(6804,2289,1)
(4332,4928,1)
(5176,7489,1)
(3826,3051,1)
(2080,5902,1)
(5914,6368,1)
(3755,1502,1)
(1359,4928,1)
(2892,4720,1)
(9026,598,1)
(6060,2114,1)
(4728,3363,1)
(7764,553,1)
(6283,7447,1)
(1988,1591,1)
(5668,1502,1)
(5867,7547,1)
(3482,6431,1)
(3087,8998,1)
(7004,8765,1)
(8286,4409,1)
(4443,8954,1)
(4542,4928,1)
(3417,1628,1)
(8922,543,1)
(7720,1502,1)
(7197,9058,1)
(7256,6611,1)
(1298,7468,1)
(4964,7768,1)
(5975,4928,1)
(8157,8285,1)
(2504,8337,1)
(6866,3904,1)
(4453,7638,1)
(2243,3228,1)
(5876,7125,1)
(5596,372,1)
(3406,4324,1)
(4485,7478,1)
(2399,5989,1)
(7440,6583,1)
(4724,8746,1)
(8542,6802,1)
(6475,1489,1)
(7180,7450,1)
(7194,2504,1)
(2250,7517,1)
(7670,818,1)
(5330,6047,1)
(5378,5460,1)
(7274,6255,1)
(7951,5710,1)
(2935,5282,1)
(7795,1949,1)
(6450,5147,1)
(295,1986,1)
(4921,7562,1)
(3328,844,1)
(7594,7093,1)
(7454,806,1)
(837,8350,1)
(2035,7792,1)
(6158,8585,1)
(4374,2825,1)
(4456,3579,1)
(4037,2062,1)
(8302,8040,1)
(4020,6149,1)
(5368,5864,1)
(2294,7004,1)
(157,1545,1)
(4971,3722,1)
(3750,5873,1)
(5075,4220,1)
(8531,9061,1)
(4094,4281,1)
(6234,6700,1)
(1795,280,1)
(2349,2370,1)
(7771,6365,1)
(5976,7553,1)
(2414,8039,1)
(7799,5961,1)
(5879,1816,1)
(6847,3791,1)
(8271,1394,1)
(5734,8590,1)
(606,6325,1)
(757,9109,1)
(1714,5548,1)
(2334,2128,1)
(1273,3891,1)
(8932,8738,1)
(2735,7044,1)
(4597,4565,1)
(7646,3433,1)
(976,334,1)
(1388,3086,1)
(4558,3649,1)
(3229,3069,1)
(5358,8337,1)
(6786,5902,1)
(1460,1149,1)
(4437,6853,1)
(7961,4757,1)
(8850,1502,1)
(7032,6105,1)
(2160,6864,1)
(9144,2988,1)
(1406,7095,1)
(2969,2675,1)
(4024,2031,1)
(1168,5747,1)
(4374,997,1)
(1940,4310,1)
(3279,6319,1)
(1130,5475,1)
(620,2380,1)
(2301,1502,1)
(6681,4219,1)
(3288,3271,1)
(7271,2441,1)
(3279,4928,1)
(1847,6907,1)
(6922,6024,1)
(8036,4928,1)
(2828,1502,1)
(8414,8647,1)
(8107,400,1)
(2068,6280,1)
(5833,1502,1)
(7256,1505,1)
(7158,8783,1)
(9080,6430,1)
(6530,1502,1)
(7642,2021,1)
(4057,6449,1)
(2735,5792,1)
(619,5693,1)
(2205,8017,1)
(4931,8409,1)
(4763,6791,1)
(3675,4012,1)
(4869,1673,1)
(2035,4928,1)
(2844,5043,1)
(4286,2898,1)
(1389,1502,1)
(954,3496,1)
(1877,2193,1)
(8140,1502,1)
(7991,7148,1)
(7700,1516,1)
(3053,3537,1)
(9037,4373,1)
(5358,7194,1)
(8624,4857,1)
(4975,4304,1)
(7362,1502,1)
(5208,7900,1)
(4472,5559,1)
(6148,6047,1)
(97,2558,1)
(5525,2304,1)
(4299,8170,1)
(4815,2798,1)
(2481,2823,1)
(7143,1502,1)
(4294,7702,1)
(8327,2754,1)
(1307,5412,1)
(2027,427,1)
(3983,2432,1)
(6987,6922,1)
(8207,8627,1)
(6043,3832,1)
(1385,7468,1)
(5046,2663,1)
(6327,3881,1)
(1936,1261,1)
(5528,1888,1)
(7846,2017,1)
(8744,8596,1)
(2775,1501,1)
(2940,4724,1)
(3110,5078,1)
(5762,6491,1)
(1132,5121,1)
(1410,4744,1)
(5850,803,1)
(2585,3771,1)
(8630,6905,1)
(8426,6053,1)
(9047,4140,1)
(367,5511,1)
(4437,742,1)
(7369,2771,1)
(5847,85,1)
(2171,4928,1)
(5646,6776,1)
(4996,4928,1)
(5210,8542,1)
(5457,1876,1)
(3342,6047,1)
(8970,2206,1)
(4224,7124,1)
(618,7644,1)
(6993,8780,1)
(1468,4885,1)
(5239,2667,1)
(3465,1585,1)
(3077,1360,1)
(6282,3689,1)
(5838,1600,1)
(868,5433,1)
(329,6381,1)
(1941,7326,1)
(4251,7506,1)
(4762,9088,1)
(2991,4290,1)
(9134,5714,1)
(8487,7459,1)
(4278,1502,1)
(3052,2079,1)
(362,1502,1)
(7042,4873,1)
(4641,4286,1)
(7411,4542,1)
(3490,7929,1)
(5693,7150,1)
(3886,302,1)
(8152,4851,1)
(869,8592,1)
(7661,6401,1)
(5394,3567,1)
(12,3796,1)
(5732,2701,1)
(1542,8292,1)
(2425,5234,1)
(7026,3049,1)
(3794,7256,1)
(9130,4111,1)
(6940,8361,1)
(407,7879,1)
(1017,7972,1)
(4846,2893,1)
(8593,4997,1)
(6424,5404,1)
(4749,585,1)
(1849,2012,1)
(3525,3284,1)
(4695,7468,1)
(8944,6211,1)
(1111,4928,1)
(158,7382,1)
(4346,317,1)
(305,4928,1)
(4437,2893,1)
(2707,8713,1)
(7202,4554,1)
(3152,1502,1)
(1773,3040,1)
(2865,6702,1)
(3028,1502,1)
(7985,5839,1)
(5648,6055,1)
(8073,6810,1)
(6017,1908,1)
(6304,5573,1)
(1672,3059,1)
(7413,3773,1)
(5853,6134,1)
(179,7679,1)
(2656,4623,1)
(4979,5465,1)
(424,8583,1)
(3628,5876,1)
(371,1502,1)
(5294,3488,1)
(648,4928,1)
(5884,907,1)
(7808,4141,1)
(5663,334,1)
(6867,1748,1)
(64,4677,1)
(3237,3498,1)
(324,5870,1)
(7230,1617,1)
(6472,8404,1)
(4214,5331,1)
(7774,5313,1)
(7211,2457,1)
(1981,2642,1)
(7041,3748,1)
(7814,3513,1)
(7128,7099,1)
(7777,7069,1)
(6570,262,1)
(4065,1502,1)
(1647,793,1)
(4205,7245,1)
(6285,1502,1)
(819,3703,1)
(3716,7064,1)
(4841,1502,1)
(609,2898,1)
(7618,1502,1)
(1617,644,1)
(809,1033,1)
(4843,1502,1)
(3656,1847,1)
(9037,8678,1)
(8868,5902,1)
(8257,5064,1)
(4538,6153,1)
(878,1609,1)
(3779,2973,1)
(8284,3616,1)
(3751,9134,1)
(8020,7318,1)
(2735,1944,1)
(6444,6111,1)
(7928,5902,1)
(7959,6431,1)
(7088,5601,1)
(2276,8744,1)
(7214,8635,1)
(606,8340,1)
(128,5921,1)
(7544,3710,1)
(3592,6500,1)
(2937,8364,1)
(5409,8047,1)
(905,1423,1)
(1391,8362,1)
(6642,4158,1)
(3965,2413,1)
(7790,5043,1)
(7924,9033,1)
(918,7000,1)
(3822,6547,1)
(5273,7805,1)
(1671,955,1)
(9037,707,1)
(4994,8803,1)
(8829,1855,1)
(6369,2501,1)
(637,3989,1)
(7373,1969,1)
(4746,1170,1)
(2712,3456,1)
(7265,4928,1)
(8914,931,1)
(3342,1502,1)
(3332,8625,1)
(4276,8145,1)
(6520,4648,1)
(9028,526,1)
(8017,5392,1)
(719,6340,1)
(4382,5391,1)
(7834,1764,1)
(6743,9096,1)
(7277,7411,1)
(8355,1181,1)
(2248,8586,1)
(3524,1955,1)
(3640,3115,1)
(7051,2064,1)
(3411,1591,1)
(8447,7248,1)
(6111,397,1)
(2962,3808,1)
(4088,4651,1)
(2535,2234,1)
(6730,4325,1)
(7292,989,1)
(1150,7296,1)
(4595,4014,1)
(7374,7809,1)
(4835,441,1)
(2799,6823,1)
(3370,1502,1)
(774,1632,1)
(3042,7389,1)
(4314,4601,1)
(4472,1591,1)
(7634,7085,1)
(7564,1535,1)
(6845,1804,1)
(6341,6671,1)
(5474,1502,1)
(606,649,1)
(2050,7959,1)
(909,4928,1)
(2786,6101,1)
(5228,8685,1)
(3594,2958,1)
(3017,462,1)
(4632,7628,1)
(6728,6320,1)
(2505,7134,1)
(3722,8221,1)
(4546,6411,1)
(6398,2572,1)
(3190,4928,1)
(5489,5853,1)
(3749,321,1)
(7593,1502,1)
(7083,7065,1)
(2308,1303,1)
(7468,8188,1)
(5211,7171,1)
(7046,6988,1)
(8515,538,1)
(5294,5497,1)
(4131,4928,1)
(2897,4248,1)
(506,6568,1)
(6569,1502,1)
(3029,983,1)
(5294,8794,1)
(1674,8660,1)
(4053,695,1)
(2874,9073,1)
(6238,4928,1)
(6250,3557,1)
(759,8576,1)
(5941,7686,1)
(7854,6032,1)
(4437,7148,1)
(2644,8098,1)
(4962,6136,1)
(5315,1228,1)
(3365,1502,1)
(7191,8120,1)
(7075,1608,1)
(4831,1319,1)
(398,8100,1)
(2934,945,1)
(5672,4742,1)
(2708,5466,1)
(4015,6862,1)
(2050,1048,1)
(8796,1760,1)
(3508,1081,1)
(4758,3249,1)
(694,2114,1)
(6124,3534,1)
(584,2656,1)
(6702,850,1)
(5729,7980,1)
(5294,1128,1)
(4557,4506,1)
(1704,2119,1)
(4300,2394,1)
(8583,7145,1)
(2653,5582,1)
(6160,6752,1)
(3825,2898,1)
(61,4781,1)
(8832,6737,1)
(4846,3154,1)
(48,7847,1)
(2582,4792,1)
(7685,1502,1)
(1739,3114,1)
(5518,2239,1)
(6102,1135,1)
(3906,1502,1)
(6332,3644,1)
(4616,373,1)
(7991,1591,1)
(1272,3426,1)
(3667,5979,1)
(4791,7965,1)
(7565,7701,1)
(2907,4928,1)
(7726,1674,1)
(6186,4779,1)
(6023,5992,1)
(6273,8789,1)
(6077,7670,1)
(7959,6633,1)
(4423,6344,1)
(6471,6903,1)
(1231,5737,1)
(2772,4593,1)
(9026,1489,1)
(3938,4575,1)
(3314,2758,1)
(4818,5319,1)
(5553,842,1)
(230,7051,1)
(1895,1446,1)
(144,192,1)
(6626,5680,1)
(722,557,1)
(1889,3230,1)
(6758,1502,1)
(7117,1502,1)
(3221,6181,1)
(5023,4176,1)
(6738,3500,1)
(2243,4928,1)
(6928,2732,1)
(3252,7882,1)
(7073,846,1)
(6051,6782,1)
(1707,8996,1)
(5259,7053,1)
(3260,549,1)
(6437,2443,1)
(4888,636,1)
(7119,1597,1)
(1173,7649,1)
(1271,4169,1)
(1438,5566,1)
(2168,8442,1)
(5775,2046,1)
(392,4928,1)
(7077,4551,1)
(7593,3551,1)
(6602,8329,1)
(886,8030,1)
(7610,4928,1)
(6745,5264,1)
(2208,807,1)
(5237,5352,1)
(1043,4928,1)
(1749,367,1)
(6391,6123,1)
(7446,5936,1)
(7812,1214,1)
(352,2909,1)
(2362,3179,1)
(2942,4928,1)
(7142,4697,1)
(8281,2025,1)
(6236,805,1)
(4895,3509,1)
(3509,5525,1)
(3791,4928,1)
(4486,5398,1)
(1575,5835,1)
(5077,6196,1)
(2580,3842,1)
(3824,2132,1)
(5294,7100,1)
(4278,4928,1)
(7391,2898,1)
(3043,3066,1)
(4286,7081,1)
(2980,8963,1)
(1937,3342,1)
(1651,5059,1)
(3131,2598,1)
(3411,5559,1)
(3015,338,1)
(2735,4942,1)
(7070,4480,1)
(7883,4686,1)
(312,6751,1)
(7778,1144,1)
(7991,2113,1)
(8230,5965,1)
(2202,1502,1)
(5646,7015,1)
(1800,1502,1)
(3880,2366,1)
(5270,2203,1)
(6304,6988,1)
(9070,2017,1)
(3009,2640,1)
(2375,8962,1)
(2783,463,1)
(775,1213,1)
(8512,6132,1)
(1535,5330,1)
(7991,7092,1)
(7266,4782,1)
(3448,5859,1)
(8591,4168,1)
(3430,1502,1)
(6729,7243,1)
(1125,1546,1)
(7422,1502,1)
(8468,4112,1)
(1430,3794,1)
(9048,5968,1)
(1518,6504,1)
(8647,3398,1)
(3843,6431,1)
(7460,6871,1)
(6215,7174,1)
(6591,6497,1)
(255,6515,1)
(6660,5241,1)
(7805,3784,1)
(6880,6883,1)
(5294,3303,1)
(5658,87,1)
(5752,4403,1)
(2260,8679,1)
(2207,806,1)
(2680,3661,1)
(4231,8985,1)
(3838,4928,1)
(2344,6889,1)
(7768,3817,1)
(1553,8195,1)
(2748,2295,1)
(7753,4544,1)
(2184,5974,1)
(4437,908,1)
(8061,6648,1)
(3899,755,1)
(5829,3654,1)
(5567,782,1)
(3954,5152,1)
(1142,327,1)
(4002,2833,1)
(4935,3345,1)
(2785,6396,1)
(24,5604,1)
(3000,1307,1)
(6271,4947,1)
(3416,8813,1)
(1921,1502,1)
(4492,8898,1)
(6123,7177,1)
(258,3250,1)
(9060,437,1)
(4059,4787,1)
(8498,8217,1)
(8320,423,1)
(6949,1010,1)
(5100,2946,1)
(1120,4928,1)
(1650,1975,1)
(3892,5887,1)
(8581,4836,1)
(198,3610,1)
(1087,4047,1)
(3845,6127,1)
(2416,5699,1)
(3051,7374,1)
(6456,7520,1)
(5717,3890,1)
(4717,1502,1)
(1314,6357,1)
(5515,231,1)
(8060,1668,1)
(2243,1502,1)
(7110,7034,1)
(2262,8726,1)
(1357,2365,1)
(1593,4928,1)
(2156,220,1)
(772,4928,1)
(5007,4714,1)
(1768,4722,1)
(3253,2127,1)
(2111,8370,1)
(5956,5131,1)
(8893,4744,1)
(2346,7450,1)
(5295,6121,1)
(2830,1464,1)
(2675,6902,1)
(4483,7645,1)
(7920,2892,1)
(8627,4199,1)
(7775,3555,1)
(2189,7088,1)
(2372,5367,1)
(4258,8356,1)
(8125,2371,1)
(2901,2821,1)
(705,8497,1)
(1932,1448,1)
(2617,4128,1)
(4027,8994,1)
(7359,5744,1)
(1421,1818,1)
(1512,6002,1)
(8849,6071,1)
(3713,6074,1)
(8400,2719,1)
(4472,2894,1)
(4236,753,1)
(6277,4600,1)
(7520,5584,1)
(5009,4303,1)
(6650,3111,1)
(2827,7324,1)
(8326,150,1)
(8960,7004,1)
(688,6896,1)
(8387,4142,1)
(8164,186,1)
(3500,1502,1)
(5359,6047,1)
(2278,5902,1)
(1435,6133,1)
(4623,7526,1)
(7414,4820,1)
(8310,404,1)
(5493,4928,1)
(1789,3050,1)
(3294,1599,1)
(596,865,1)
(5203,1724,1)
(2801,6205,1)
(5258,8441,1)
(6672,1502,1)
(7007,6849,1)
(7030,1502,1)
(3692,6402,1)
(9090,6047,1)
(8368,398,1)
(5325,7417,1)
(8380,7485,1)
(4167,683,1)
(1027,5946,1)
(8436,1502,1)
(8296,2124,1)
(1329,2898,1)
(4737,5543,1)
(1982,143,1)
(8115,2838,1)
(4838,3081,1)
(2292,3427,1)
(3340,6880,1)
(2812,2077,1)
(2367,5482,1)
(8533,5501,1)
(882,3541,1)
(5505,7416,1)
(2026,7666,1)
(1446,1502,1)
(9090,5272,1)
(2890,8795,1)
(4795,577,1)
(7789,1208,1)
(7994,7910,1)
(5294,908,1)
(2735,4365,1)
(5943,5384,1)
(3032,1506,1)
(8697,5795,1)
(1394,8016,1)
(2985,7436,1)
(2152,4928,1)
(5805,7979,1)
(5946,4659,1)
(4311,6628,1)
(2421,6306,1)
(7489,2579,1)
(8170,6937,1)
(8492,8431,1)
(8445,8810,1)
(891,1502,1)
(4289,5310,1)
(5075,3355,1)
(2810,1795,1)
(7293,516,1)
(4845,4928,1)
(4851,2914,1)
(6350,7270,1)
(3211,1502,1)
(8783,1790,1)
(7778,1502,1)
(5468,5623,1)
(1833,8804,1)
(905,8561,1)
(372,1753,1)
(35,6635,1)
(317,7215,1)
(9120,2955,1)
(4313,712,1)
(6173,7301,1)
(9024,6928,1)
(9017,3168,1)
(2320,7100,1)
(4912,5345,1)
(3040,65,1)
(4692,3704,1)
(1315,5800,1)
(2869,7148,1)
(7201,2250,1)
(3678,3746,1)
(7098,1502,1)
(5012,105,1)
(5294,6757,1)
(4573,6212,1)
(6042,6478,1)
(6435,675,1)
(8476,643,1)
(3600,2761,1)
(7468,1591,1)
(5552,3224,1)
(1123,4928,1)
(6867,5524,1)
(8782,1502,1)
(7112,3199,1)
(8698,4153,1)
(4223,2926,1)
(8981,266,1)
(3399,5902,1)
(9026,6465,1)
(2462,494,1)
(1731,1273,1)
(8718,4554,1)
(2708,3912,1)
(5311,2644,1)
(3647,5043,1)
(7307,5001,1)
(6450,5043,1)
(8451,1502,1)
(4442,6047,1)
(6952,1278,1)
(45,6714,1)
(1079,2408,1)
(5096,8281,1)
(8095,6525,1)
(6304,7148,1)
(966,4364,1)
(8162,4019,1)
(6438,1592,1)
(1440,2567,1)
(2473,3285,1)
(2409,50,1)
(1988,1489,1)
(2776,2820,1)
(4787,7279,1)
(1654,4529,1)
(4903,1563,1)
(4719,1502,1)
(5754,1553,1)
(2529,2899,1)
(431,1502,1)
(1975,5560,1)
(5294,4910,1)
(7299,6685,1)
(3152,5820,1)
(614,1776,1)
(439,6214,1)
(3254,5779,1)
(3645,5277,1)
(5244,2362,1)
(2498,2496,1)
(1201,4775,1)
(8048,2326,1)
(3195,3570,1)
(6304,2893,1)
(7652,6047,1)
(6166,3877,1)
(4787,6047,1)
(2503,2828,1)
(1911,8417,1)
(6432,1080,1)
(495,2124,1)
(1392,1502,1)
(4631,524,1)
(8620,6382,1)
(3696,9023,1)
(4615,6860,1)
(2171,7550,1)
(4032,4492,1)
(9154,8066,1)
(4362,1838,1)
(7759,8701,1)
(9037,4551,1)
(5932,7674,1)
(8897,2051,1)
(2285,2112,1)
(4747,188,1)
(1981,6479,1)
(4619,1188,1)
(9135,838,1)
(7091,297,1)
(4437,4985,1)
(5401,5766,1)
(52,1392,1)
(3494,389,1)
(8499,8329,1)
(1917,7230,1)
(4124,4928,1)
(7523,7543,1)
(8146,1181,1)
(6075,3439,1)
(813,5410,1)
(3756,3879,1)
(658,4340,1)
(5720,4346,1)
(5548,3091,1)
(8455,4336,1)
(8611,3432,1)
(4199,5375,1)
(751,7724,1)
(695,7380,1)
(8829,5244,1)
(5820,6715,1)
(3635,325,1)
(6762,5364,1)
(565,5497,1)
(2119,2124,1)
(7348,1502,1)
(1943,70,1)
(4835,16,1)
(6516,6884,1)
(7362,4928,1)
(8332,6276,1)
(4491,1893,1)
(7763,7624,1)
(1377,936,1)
(7046,5115,1)
(2663,1502,1)
(3792,3213,1)
(5533,3071,1)
(8643,500,1)
(2951,1502,1)
(6178,3712,1)
(511,7983,1)
(6037,5700,1)
(6920,5376,1)
(1008,4347,1)
(3211,191,1)
(5552,5481,1)
(9149,4003,1)
(2510,2658,1)
(2115,800,1)
(3734,8845,1)
(6538,8362,1)
(2200,7388,1)
(320,3070,1)
(5098,7348,1)
(2735,3956,1)
(9091,6952,1)
(5089,573,1)
(6088,8369,1)
(8647,521,1)
(429,4531,1)
(3625,7512,1)
(9037,6988,1)
(4417,8198,1)
(8594,6451,1)
(8958,7596,1)
(1564,6108,1)
(8598,1946,1)
(6223,684,1)
(6336,7525,1)
(5253,1116,1)
(492,4928,1)
(2994,4176,1)
(4236,8497,1)
(5054,1454,1)
(6744,6192,1)
(5190,5723,1)
(8057,2305,1)
(7403,7004,1)
(7006,5762,1)
(7632,8578,1)
(8902,2619,1)
(1163,2053,1)
(4948,9000,1)
(8200,7612,1)
(183,8791,1)
(4098,7161,1)
(3358,5000,1)
(1462,5396,1)
(5582,2560,1)
(5978,4146,1)
(7870,1485,1)
(8066,611,1)
(5356,4928,1)
(5661,8405,1)
(721,7931,1)
(3830,7777,1)
(4647,4446,1)
(4670,4305,1)
(9078,915,1)
(3418,7987,1)
(2995,7957,1)
(3257,4348,1)
(3462,5398,1)
(4600,3888,1)
(9093,3971,1)
(7670,5043,1)
(5432,3695,1)
(4601,7929,1)
(3573,5675,1)
(7056,1687,1)
(1,5817,1)
(415,1407,1)
(1383,8866,1)
(852,6047,1)
(3008,3755,1)
(4178,609,1)
(7132,1502,1)
(8427,5645,1)
(5765,3346,1)
(6307,7426,1)
(5799,6390,1)
(4602,997,1)
(7991,8037,1)
(2981,4115,1)
(6177,2105,1)
(8904,6075,1)
(2719,3470,1)
(3134,1646,1)
(2485,1616,1)
(1549,4928,1)
(2364,4760,1)
(263,5043,1)
(7475,4002,1)
(3542,1367,1)
(5925,3804,1)
(3267,2629,1)
(2116,8665,1)
(7386,1502,1)
(2880,3216,1)
(6158,4418,1)
(2534,7433,1)
(5734,4783,1)
(444,8362,1)
(5294,996,1)
(4986,6520,1)
(8957,6431,1)
(3422,2945,1)
(5646,8619,1)
(8806,757,1)
(5531,997,1)
(4249,411,1)
(3863,4914,1)
(1158,1502,1)
(5831,2381,1)
(6966,5619,1)
(6733,6239,1)
(876,4892,1)
(3420,5713,1)
(4240,5851,1)
(4622,1987,1)
(1230,5888,1)
(2320,1591,1)
(8419,3421,1)
(4201,8975,1)
(5793,276,1)
(8999,5104,1)
(2823,8284,1)
(8034,8305,1)
(322,1270,1)
(1556,9081,1)
(3943,6187,1)
(310,795,1)
(2500,7137,1)
(4902,1084,1)
(2230,7704,1)
(5335,7329,1)
(1913,195,1)
(909,3951,1)
(7945,1502,1)
(5360,3834,1)
(4774,5491,1)
(4938,2322,1)
(4972,8928,1)
(3689,7740,1)
(5945,8403,1)
(2735,7147,1)
(5771,3347,1)
(5792,2621,1)
(8033,3758,1)
(4544,2905,1)
(6485,6431,1)
(209,7781,1)
(6093,6550,1)
(1813,6517,1)
(8058,4160,1)
(3239,4928,1)
(5674,3856,1)
(5021,2325,1)
(4565,1502,1)
(5665,5325,1)
(7031,6885,1)
(5306,4760,1)
(2059,8317,1)
(3362,1788,1)
(5435,8880,1)
(5861,5036,1)
(7439,3486,1)
(6875,7637,1)
(180,8362,1)
(4757,5118,1)
(7887,5077,1)
(5504,1521,1)
(6997,6259,1)
(2735,6406,1)
(6303,809,1)
(889,8362,1)
(8028,4802,1)
(3475,2812,1)
(2451,6676,1)
(3785,493,1)
(8728,6544,1)
(5323,6777,1)
(6197,1182,1)
(8698,4928,1)
(8289,1502,1)
(6354,4031,1)
(9037,932,1)
(3657,4928,1)
(7904,6197,1)
(528,1263,1)
(8087,5309,1)
(6532,5993,1)
(8765,3699,1)
(2058,1365,1)
(8481,2159,1)
(8747,948,1)
(5294,3674,1)
(4807,2040,1)
(5634,1351,1)
(7135,8111,1)
(5546,7844,1)
(8560,3530,1)
(759,7908,1)
(664,3468,1)
(6586,5720,1)
(530,2898,1)
(6218,1502,1)
(2803,5613,1)
(3351,4067,1)
(6874,7118,1)
(2249,670,1)
(6322,5100,1)
(713,2586,1)
(2533,6567,1)
(9116,4928,1)
(3250,6578,1)
(54,334,1)
(6740,6543,1)
(222,1852,1)
(3884,4928,1)
(3387,4224,1)
(7884,3330,1)
(2455,1414,1)
(7479,4149,1)
(6434,2237,1)
(3878,1595,1)
(877,8372,1)
(661,5791,1)
(4279,8282,1)
(2556,5287,1)
(361,1502,1)
(3804,7295,1)
(8648,6958,1)
(7250,1502,1)
(2744,3196,1)
(79,182,1)
(9032,5466,1)
(768,1734,1)
(1371,8865,1)
(8480,4928,1)
(2887,942,1)
(4193,3688,1)
(5109,2863,1)
(8957,5808,1)
(720,8325,1)
(2565,1073,1)
(6877,2049,1)
(1436,7671,1)
(3244,411,1)
(8664,567,1)
(1870,629,1)
(5116,1037,1)
(3406,5781,1)
(2882,5204,1)
(4194,8404,1)
(5728,8071,1)
(6543,1586,1)
(5896,2451,1)
(608,4616,1)
(7288,2898,1)
(3544,6538,1)
(421,1918,1)
(6285,6047,1)
(8829,6988,1)
(3786,7004,1)
(6849,722,1)
(6583,4683,1)
(1417,510,1)
(7486,5949,1)
(3871,8367,1)
(8222,2382,1)
(5642,6074,1)
(1043,1502,1)
(8392,1502,1)
(3705,157,1)
(1024,1113,1)
(2687,3321,1)
(5975,1502,1)
(3861,7669,1)
(2852,7875,1)
(5178,1291,1)
(237,2784,1)
(2104,6673,1)
(577,6666,1)
(8056,9137,1)
(2001,2686,1)
(5313,288,1)
(8994,5158,1)
(3473,3923,1)
(8483,16,1)
(7524,75,1)
(8653,4881,1)
(6057,5098,1)
(5424,364,1)
(2966,7170,1)
(1593,1502,1)
(680,6866,1)
(1593,5238,1)
(2752,5222,1)
(8617,4070,1)
(1538,1502,1)
(403,3800,1)
(9155,5824,1)
(4109,3534,1)
(4275,3535,1)
(8537,1535,1)
(8553,6457,1)
(696,542,1)
(3399,2757,1)
(1491,6640,1)
(7076,1502,1)
(6999,2025,1)
(3344,5348,1)
(8310,119,1)
(5623,7468,1)
(4371,3054,1)
(559,4928,1)
(1548,6517,1)
(4358,8046,1)
(5226,4382,1)
(4731,6730,1)
(6323,5062,1)
(7151,4953,1)
(8075,5518,1)
(1425,5342,1)
(8566,4076,1)
(7704,7613,1)
(808,5773,1)
(6699,708,1)
(9043,6151,1)
(3832,4193,1)
(1699,999,1)
(2367,4610,1)
(3774,3387,1)
(1385,3254,1)
(3167,2001,1)
(1772,1463,1)
(8320,1792,1)
(7707,1502,1)
(4812,5170,1)
(245,4928,1)
(2814,3147,1)
(8724,7176,1)
(4477,6431,1)
(6001,6540,1)
(4432,6281,1)
(7966,7189,1)
(658,4928,1)
(586,1929,1)
(1270,8545,1)
(80,3549,1)
(7522,1502,1)
(6524,2720,1)
(1682,4961,1)
(7991,4551,1)
(6935,6361,1)
(263,3930,1)
(102,5116,1)
(2404,1669,1)
(6500,365,1)
(4663,1416,1)
(522,8249,1)
(2942,3745,1)
(4954,857,1)
(721,1502,1)
(6304,7033,1)
(763,2676,1)
(4888,2124,1)
(2000,7639,1)
(1270,6271,1)
(4436,7526,1)
(2443,1502,1)
(6285,1854,1)
(4972,2361,1)
(6899,3905,1)
(3739,8252,1)
(8692,5043,1)
(2766,3993,1)
(29,8440,1)
(1404,6804,1)
(6293,6565,1)
(3570,7362,1)
(800,8915,1)
(7265,1502,1)
(1065,3882,1)
(7452,3065,1)
(5233,3376,1)
(2265,3299,1)
(6496,8716,1)
(462,5728,1)
(2320,2113,1)
(5489,5902,1)
(2466,2670,1)
(2366,5533,1)
(8593,2804,1)
(7096,5159,1)
(5343,2846,1)
(6142,7497,1)
(2343,1067,1)
(8440,5415,1)
(1623,5764,1)
(4535,2477,1)
(2752,1636,1)
(5491,5608,1)
(6612,7966,1)
(5393,1516,1)
(2008,681,1)
(6317,6375,1)
(2829,6646,1)
(4395,5038,1)
(5998,4939,1)
(6495,7159,1)
(533,1330,1)
(22,5653,1)
(3819,3583,1)
(5016,2898,1)
(1022,219,1)
(8283,7067,1)
(4753,435,1)
(420,1532,1)
(2346,3775,1)
(5188,7896,1)
(4565,1672,1)
(727,1502,1)
(4972,4303,1)
(3279,1502,1)
(8069,3990,1)
(9037,2894,1)
(6072,2396,1)
(8146,8355,1)
(3696,2871,1)
(8990,974,1)
(5443,1502,1)
(4232,2489,1)
(3312,1812,1)
(1476,2090,1)
(8496,5378,1)
(125,2399,1)
(4488,4957,1)
(6304,5914,1)
(2426,1359,1)
(5526,3365,1)
(2545,880,1)
(5097,3583,1)
(2818,589,1)
(6958,2727,1)
(7360,5767,1)
(8789,3493,1)
(8521,5232,1)
(4155,997,1)
(579,7993,1)
(3963,826,1)
(4817,4362,1)
(8106,6892,1)
(294,6604,1)
(1265,7561,1)
(1550,2435,1)
(5894,7989,1)
(7317,8006,1)
(1729,7552,1)
(6868,4512,1)
(168,7982,1)
(8230,475,1)
(8062,488,1)
(7089,1502,1)
(1808,8814,1)
(8454,1502,1)
(6517,4744,1)
(7132,3607,1)
(5934,5774,1)
(2579,4824,1)
(5294,2367,1)
(1540,3973,1)
(1856,8293,1)
(4386,8975,1)
(231,6574,1)
(7285,6936,1)
(7830,8987,1)
(5763,1284,1)
(8102,875,1)
(85,6404,1)
(9038,5145,1)
(4180,5839,1)
(6665,3662,1)
(3527,2322,1)
(7753,4354,1)
(7267,1393,1)
(6363,2042,1)
(9096,9119,1)
(7954,9092,1)
(7303,4794,1)
(408,2350,1)
(3681,1502,1)
(8444,5624,1)
(5740,4765,1)
(8362,6709,1)
(4313,6304,1)
(3499,8729,1)
(6225,1267,1)
(43,3911,1)
(7308,8214,1)
(1651,5426,1)
(7542,1442,1)
(621,6054,1)
(1974,1515,1)
(5294,3017,1)
(2382,3036,1)
(2528,553,1)
(180,3053,1)
(8574,6374,1)
(651,1953,1)
(2794,8461,1)
(3162,4938,1)
(5885,5736,1)
(5650,8864,1)
(6775,3269,1)
(6974,1502,1)
(787,915,1)
(6905,2402,1)
(1014,8617,1)
(2735,7764,1)
(4048,334,1)
(4407,8681,1)
(6855,881,1)
(6152,3405,1)
(5317,8794,1)
(7167,8336,1)
(8585,1440,1)
(952,5895,1)
(4653,4104,1)
(4410,1,1)
(8150,5587,1)
(5329,4203,1)
(640,4005,1)
(4374,7771,1)
(8815,3819,1)
(8408,1502,1)
(7737,5666,1)
(3049,3087,1)
(7960,7100,1)
(8762,4928,1)
(481,5030,1)
(3161,2356,1)
(3592,39,1)
(4179,5451,1)
(4047,4734,1)
(8862,95,1)
(3341,3608,1)
(160,8818,1)
(5115,2193,1)
(2348,5969,1)
(2869,2893,1)
(4750,4328,1)
(8981,940,1)
(1158,6809,1)
(3445,6499,1)
(418,5834,1)
(2496,5673,1)
(136,4535,1)
(7252,5286,1)
(881,522,1)
(8367,5015,1)
(4373,2554,1)
(8560,46,1)
(6816,2335,1)
(1887,7984,1)
(9136,529,1)
(8830,8721,1)
(9108,4195,1)
(1309,8223,1)
(821,1612,1)
(5540,5178,1)
(5029,3354,1)
(3958,3933,1)
(5931,8776,1)
(5223,5527,1)
(1503,943,1)
(1275,1287,1)
(2872,3798,1)
(2186,847,1)
(1004,5030,1)
(8977,418,1)
(1875,2583,1)
(1419,4928,1)
(8578,113,1)
(3308,1102,1)
(898,6175,1)
(1132,4928,1)
(6963,7611,1)
(4272,6410,1)
(1559,4351,1)
(3823,78,1)
(6984,836,1)
(2113,536,1)
(2825,2344,1)
(7729,2133,1)
(6041,8141,1)
(703,1248,1)
(3557,2790,1)
(437,7531,1)
(4139,6431,1)
(1152,492,1)
(6313,1660,1)
(6964,2813,1)
(6325,6475,1)
(4695,5741,1)
(1676,8043,1)
(4039,6113,1)
(7131,963,1)
(6270,4410,1)
(3961,1551,1)
(4961,8064,1)
(5926,4761,1)
(4516,8560,1)
(7822,4711,1)
(1191,5320,1)
(4347,3519,1)
(1175,5393,1)
(5897,6285,1)
(6978,2191,1)
(2097,4589,1)
(4137,1061,1)
(7981,9024,1)
(2735,3356,1)
(2735,5692,1)
(7431,4008,1)
(504,5115,1)
(4419,4863,1)
(8520,4928,1)
(3136,8107,1)
(2735,759,1)
(1040,5254,1)
(4114,7394,1)
(216,5486,1)
(2432,3346,1)
(3083,4928,1)
(1442,7496,1)
(3629,2194,1)
(3639,4880,1)
(7940,3738,1)
(504,1489,1)
(3137,4744,1)
(3837,4928,1)
(8305,7060,1)
(6830,4928,1)
(3985,6090,1)
(6040,3410,1)
(2241,4928,1)
(3471,4619,1)
(7186,3896,1)
(3537,6587,1)
(392,1502,1)
(2801,6039,1)
(3685,2316,1)
(2082,2802,1)
(1276,8692,1)
(6393,1007,1)
(1260,6082,1)
(6004,8529,1)
(2142,4928,1)
(3017,5728,1)
(4207,2364,1)
(7046,1489,1)
(2032,2786,1)
(1241,6049,1)
(642,4107,1)
(3159,596,1)
(3381,1662,1)
(2758,9105,1)
(3385,4928,1)
(5993,3008,1)
(1385,3583,1)
(7359,1316,1)
(8990,1502,1)
(5294,6423,1)
(7132,4928,1)
(1880,7096,1)
(1033,4928,1)
(2400,5019,1)
(9137,4206,1)
(5456,7249,1)
(7690,3996,1)
(2278,5043,1)
(5743,8635,1)
(8343,874,1)
(3639,2789,1)
(4006,5359,1)
(6113,838,1)
(261,1411,1)
(4633,1337,1)
(5609,2207,1)
(3290,2480,1)
(3459,7195,1)
(8747,3251,1)
(5652,8397,1)
(1726,6393,1)
(3411,598,1)
(5712,7707,1)
(5124,8548,1)
(6736,4928,1)
(8842,5216,1)
(7622,1936,1)
(5922,8966,1)
(2167,5922,1)
(3462,5030,1)
(4846,1489,1)
(7937,4928,1)
(5263,4055,1)
(5458,3931,1)
(7079,3357,1)
(6635,4981,1)
(3539,6783,1)
(8703,3238,1)
(5616,8370,1)
(4472,598,1)
(9037,6465,1)
(724,2841,1)
(4343,2056,1)
(4974,7072,1)
(5405,8847,1)
(5107,5373,1)
(4434,2269,1)
(2516,7915,1)
(4437,5559,1)
(1761,7558,1)
(8929,6047,1)
(3876,5486,1)
(8550,8789,1)
(3605,7801,1)
(5736,7973,1)
(8501,3593,1)
(5601,7150,1)
(2679,7945,1)
(5044,4341,1)
(6199,7938,1)
(3833,2697,1)
(5872,4370,1)
(7756,1358,1)
(4572,4551,1)
(3070,9016,1)
(2771,2686,1)
(9142,4928,1)
(2403,1502,1)
(512,3763,1)
(759,9124,1)
(7370,2795,1)
(7679,8362,1)
(6744,6963,1)
(7920,8535,1)
(6008,4928,1)
(7300,3795,1)
(3346,651,1)
(2437,2690,1)
(7308,5172,1)
(7308,8302,1)
(5184,2840,1)
(8073,1974,1)
(4857,4272,1)
(1825,4060,1)
(3585,8362,1)
(428,1494,1)
(8039,334,1)
(2259,1786,1)
(5069,8567,1)
(807,1572,1)
(907,6780,1)
(5754,1973,1)
(7407,7722,1)
(8057,3872,1)
(350,4825,1)
(4313,7960,1)
(3717,8255,1)
(8411,1725,1)
(6980,7774,1)
(8728,7468,1)
(1915,6726,1)
(5310,3598,1)
(4200,4928,1)
(1954,8758,1)
(3971,1993,1)
(7338,3881,1)
(2875,891,1)
(4222,1450,1)
(1794,7955,1)
(8909,932,1)
(2209,5088,1)
(7499,6810,1)
(3219,783,1)
(2433,6408,1)
(5366,471,1)
(8382,4992,1)
(5732,4928,1)
(2431,7354,1)
(5616,6541,1)
(4374,6795,1)
(504,7092,1)
(7474,1817,1)
(3410,5401,1)
(4950,2082,1)
(1495,2898,1)
(8858,6173,1)
(4704,4433,1)
(7849,5944,1)
(5550,7389,1)
(6000,7346,1)
(3752,2050,1)
(3376,4928,1)
(6212,7129,1)
(4878,1214,1)
(7355,4928,1)
(7318,5671,1)
(5411,35,1)
(3230,6925,1)
(1905,5424,1)
(6121,3464,1)
(1289,4767,1)
(1243,5778,1)
(140,2334,1)
(6217,4780,1)
(4348,6337,1)
(8022,4841,1)
(712,1489,1)
(6850,3089,1)
(2813,7318,1)
(5600,6258,1)
(3608,881,1)
(247,1582,1)
(2930,1525,1)
(2364,6268,1)
(4545,5449,1)
(4278,6019,1)
(6810,1294,1)
(8027,4829,1)
(3958,934,1)
(1421,1645,1)
(1476,4928,1)
(8948,1801,1)
(8773,4917,1)
(1873,948,1)
(4780,3977,1)
(1911,7724,1)
(538,3583,1)
(4202,2312,1)
(2471,4928,1)
(1363,3830,1)
(6593,5002,1)
(5988,4458,1)
(5356,6828,1)
(5658,6647,1)
(9065,6047,1)
(2112,7633,1)
(7246,7160,1)
(1210,2047,1)
(8205,5043,1)
(4539,8484,1)
(5531,1514,1)
(8205,2904,1)
(7530,6505,1)
(190,5446,1)
(1489,3921,1)
(6828,5032,1)
(4635,4928,1)
(6080,3514,1)
(7269,7470,1)
(7388,5101,1)
(9037,6853,1)
(7480,5667,1)
(4536,1964,1)
(5749,6396,1)
(693,1502,1)
(2490,6637,1)
(7355,1502,1)
(2505,4503,1)
(3609,1366,1)
(4828,5941,1)
(8049,152,1)
(6884,4369,1)
(6548,3082,1)
(4874,3700,1)
(4363,4547,1)
(6964,1072,1)
(6820,9007,1)
(5817,4762,1)
(3085,8802,1)
(7166,3733,1)
(7767,2481,1)
(1139,7685,1)
(2933,839,1)
(460,1502,1)
(5294,6252,1)
(4071,1739,1)
(8776,2493,1)
(3758,9104,1)
(5682,6929,1)
(2735,715,1)
(7901,4928,1)
(4313,1793,1)
(9004,671,1)
(2295,4928,1)
(5390,6959,1)
(9026,7100,1)
(1554,6139,1)
(1081,1502,1)
(2280,1502,1)
(1369,8502,1)
(3597,5588,1)
(4292,3953,1)
(714,6854,1)
(6012,6693,1)
(1048,7004,1)
(8064,2221,1)
(1890,730,1)
(3114,8158,1)
(2587,4920,1)
(5305,1158,1)
(872,8870,1)
(3692,3325,1)
(7118,4765,1)
(3116,3723,1)
(802,8542,1)
(2248,4928,1)
(1807,145,1)
(8560,4220,1)
(5430,3458,1)
(8453,8091,1)
(1605,9108,1)
(566,4270,1)
(7511,6745,1)
(3185,84,1)
(1654,5202,1)
(4219,3158,1)
(4195,4812,1)
(7125,183,1)
(4313,4572,1)
(7185,2144,1)
(8560,129,1)
(648,5157,1)
(6627,698,1)
(7933,2645,1)
(3702,5904,1)
(7604,4594,1)
(4248,2856,1)
(991,8957,1)
(3837,4931,1)
(2670,5013,1)
(5686,1350,1)
(6079,4620,1)
(7613,4384,1)
(8401,5652,1)
(6718,7004,1)
(5733,4928,1)
(2207,3038,1)
(7263,7784,1)
(364,1502,1)
(2109,992,1)
(6151,1198,1)
(1246,4298,1)
(7462,2543,1)
(5819,3561,1)
(6,8083,1)
(5481,668,1)
(6883,6616,1)
(8829,7100,1)
(3653,359,1)
(1714,3549,1)
(4359,1493,1)
(940,5100,1)
(1831,3362,1)
(6025,4928,1)
(8659,7178,1)
(8342,1134,1)
(2762,7542,1)
(6692,6558,1)
(7965,7386,1)
(1823,4928,1)
(5327,1502,1)
(1873,4920,1)
(718,8643,1)
(9079,3417,1)
(7438,6300,1)
(4999,7594,1)
(3513,6553,1)
(96,6957,1)
(7589,7166,1)
(1433,1005,1)
(3153,1502,1)
(4443,128,1)
(7154,6440,1)
(297,1502,1)
(8918,3590,1)
(7046,8188,1)
(7338,6327,1)
(7094,3950,1)
(4601,1157,1)
(450,1502,1)
(3212,764,1)
(3296,413,1)
(8665,3900,1)
(607,8156,1)
(9073,3199,1)
(1789,4928,1)
(1125,3883,1)
(8693,8801,1)
(3326,929,1)
(8364,472,1)
(3982,3431,1)
(5261,5531,1)
(4930,2902,1)
(1046,8036,1)
(3154,3686,1)
(5413,6341,1)
(8613,5600,1)
(4447,4975,1)
(1701,3386,1)
(670,350,1)
(5058,7379,1)
(1215,6419,1)
(5343,4928,1)
(1910,1369,1)
(5265,1346,1)
(732,582,1)
(7349,6595,1)
(1423,6431,1)
(9073,2686,1)
(8335,4928,1)
(2284,8527,1)
(4873,4928,1)
(3968,8168,1)
(8437,790,1)
(8191,1845,1)
(4515,496,1)
(3995,2271,1)
(455,2893,1)
(4513,3021,1)
(8786,991,1)
(4074,3583,1)
(7046,6560,1)
(3575,3523,1)
(4430,845,1)
(7229,3530,1)
(3184,6047,1)
(786,480,1)
(1058,4366,1)
(7867,7699,1)
(6116,3479,1)
(266,6535,1)
(6992,8991,1)
(6304,5115,1)
(9045,3272,1)
(2995,659,1)
(1206,5703,1)
(32,1502,1)
(2488,8809,1)
(235,7813,1)
(2320,8188,1)
(933,4928,1)
(4572,598,1)
(5562,4287,1)
(1172,1242,1)
(5294,1228,1)
(1375,4765,1)
(4833,2303,1)
(2774,5866,1)
(3114,607,1)
(5761,1371,1)
(9053,1338,1)
(835,4861,1)
(4426,6837,1)
(7959,4744,1)
(6677,7725,1)
(2686,3658,1)
(5576,885,1)
(918,4400,1)
(965,5886,1)
(4562,2606,1)
(2967,4928,1)
(3100,3371,1)
(8352,212,1)
(1761,2410,1)
(7364,3575,1)
(3185,2459,1)
(8599,8675,1)
(4756,1179,1)
(2611,5902,1)
(347,4571,1)
(8967,3129,1)
(3293,2555,1)
(8016,965,1)
(1154,5760,1)
(915,2212,1)
(2714,8400,1)
(8771,680,1)
(4572,3297,1)
(9033,4928,1)
(3020,4813,1)
(1598,8025,1)
(2507,9112,1)
(6055,2037,1)
(7362,6679,1)
(572,3867,1)
(5870,1738,1)
(7750,4928,1)
(3038,1344,1)
(8955,1341,1)
(6105,359,1)
(8736,3678,1)
(2462,4537,1)
(9026,2098,1)
(6073,8031,1)
(1088,4928,1)
(7783,6372,1)
(4645,7826,1)
(8070,6829,1)
(2656,6503,1)
(6258,1256,1)
(1653,4928,1)
(11,6013,1)
(8490,7959,1)
(8506,8089,1)
(7506,7974,1)
(8829,1919,1)
(4450,6895,1)
(3556,7026,1)
(4493,6893,1)
(4089,5148,1)
(6334,8456,1)
(6497,1502,1)
(1261,5514,1)
(1469,4525,1)
(66,443,1)
(3959,4117,1)
(4809,4928,1)
(7265,4872,1)
(2247,1343,1)
(3011,4707,1)
(6519,981,1)
(6914,1704,1)
(3087,8730,1)
(8220,2947,1)
(9145,4261,1)
(890,4928,1)
(2692,2216,1)
(604,3613,1)
(1071,7481,1)
(1998,8833,1)
(6996,7004,1)
(26,7418,1)
(2142,8433,1)
(2101,7485,1)
(4807,7063,1)
(5016,5379,1)
(913,7992,1)
(3659,6825,1)
(4097,6630,1)
(6267,7849,1)
(6569,710,1)
(4444,4557,1)
(5951,7655,1)
(1790,3960,1)
(942,594,1)
(4371,3259,1)
(8948,1335,1)
(4186,7664,1)
(5094,4744,1)
(1653,1502,1)
(3766,1754,1)
(8105,7004,1)
(8861,4634,1)
(3346,2809,1)
(7035,4067,1)
(6771,8149,1)
(2181,1476,1)
(3591,8283,1)
(1322,3008,1)
(6685,4252,1)
(2861,4135,1)
(504,4083,1)
(7790,5805,1)
(7800,7843,1)
(8854,232,1)
(2137,993,1)
(4658,1502,1)
(5479,8436,1)
(6328,1502,1)
(4568,5956,1)
(6304,7461,1)
(3043,2934,1)
(3190,1502,1)
(3150,177,1)
(9085,1502,1)
(2298,1502,1)
(4241,3448,1)
(5783,696,1)
(5281,2468,1)
(6817,3030,1)
(649,2960,1)
(6328,4928,1)
(6139,7427,1)
(2735,1272,1)
(2598,5884,1)
(6395,6762,1)
(4150,2336,1)
(7046,2894,1)
(1156,3648,1)
(908,7000,1)
(354,4744,1)
(3393,7390,1)
(2705,6056,1)
(2274,2068,1)
(5891,1923,1)
(1413,7294,1)
(7746,5363,1)
(5337,8658,1)
(7964,7079,1)
(4775,8043,1)
(7713,57,1)
(7478,5318,1)
(3942,2775,1)
(6031,6820,1)
(1394,5886,1)
(3473,5387,1)
(4957,7907,1)
(2067,5902,1)
(7383,6985,1)
(1680,6431,1)
(7987,2103,1)
(650,848,1)
(4173,6287,1)
(4015,8472,1)
(2179,5545,1)
(7669,6445,1)
(7125,1502,1)
(5408,4754,1)
(4559,1941,1)
(6726,3015,1)
(4760,1686,1)
(2320,7148,1)
(7290,5780,1)
(1379,4974,1)
(3703,5414,1)
(1316,8634,1)
(3153,74,1)
(3880,1502,1)
(7859,2112,1)
(6024,4514,1)
(277,8466,1)
(3855,1990,1)
(5550,3910,1)
(3302,8188,1)
(4837,3211,1)
(5019,171,1)
(377,6749,1)
(7018,353,1)
(339,6530,1)
(3511,3180,1)
(4602,1502,1)
(1774,3097,1)
(7754,5678,1)
(4564,3206,1)
(4442,1502,1)
(8152,3032,1)
(2024,1384,1)
(9036,216,1)
(6511,5566,1)
(6598,2266,1)
(1473,5925,1)
(8816,6334,1)
(7533,2338,1)
(611,6831,1)
(3990,734,1)
(4739,7289,1)
(1577,4094,1)
(504,7148,1)
(3305,54,1)
(5900,5218,1)
(6603,1582,1)
(5408,6234,1)
(1346,6176,1)
(4865,780,1)
(279,3239,1)
(7047,3767,1)
(4347,4928,1)
(257,2129,1)
(4234,1003,1)
(164,4512,1)
(3744,2238,1)
(8446,278,1)
(2495,473,1)
(8998,6746,1)
(8805,4059,1)
(5512,7308,1)
(6304,642,1)
(4155,7004,1)
(6571,4493,1)
(7218,1556,1)
(1302,7854,1)
(8333,9150,1)
(4105,156,1)
(498,3967,1)
(4271,8052,1)
(8949,6770,1)
(4602,334,1)
(8703,5583,1)
(1990,8630,1)
(2117,1502,1)
(4885,2949,1)
(8691,1502,1)
(2835,6542,1)
(7569,6254,1)
(4153,2419,1)
(6900,1123,1)
(3683,1201,1)
(771,2002,1)
(5757,1502,1)
(876,2507,1)
(3726,3452,1)
(7519,4432,1)
(3350,2724,1)
(7984,5082,1)
(461,5613,1)
(6789,7552,1)
(2953,1515,1)
(5371,8868,1)
(6331,6706,1)
(8551,1064,1)
(5800,332,1)
(1167,3185,1)
(5287,701,1)
(5151,1513,1)
(6613,4673,1)
(7468,5115,1)
(4046,8106,1)
(6353,1502,1)
(353,4320,1)
(4437,6465,1)
(3455,4314,1)
(3942,4928,1)
(5365,8268,1)
(486,3884,1)
(2867,8667,1)
(3558,3873,1)
(84,2459,1)
(8534,2261,1)
(326,6732,1)
(8912,6044,1)
(6367,7892,1)
(2732,4417,1)
(4425,8877,1)
(4673,4928,1)
(4009,2461,1)
(8386,8761,1)
(4710,5907,1)
(1124,6051,1)
(8484,658,1)
(538,7468,1)
(7906,8076,1)
(6165,1157,1)
(7647,4807,1)
(1852,895,1)
(9090,1502,1)
(3634,7047,1)
(5721,1608,1)
(6314,6559,1)
(792,5329,1)
(76,2075,1)
(7559,9066,1)
(2925,2151,1)
(5146,5488,1)
(1033,6047,1)
(8381,2779,1)
(746,7906,1)
(6172,4765,1)
(4612,5655,1)
(7548,4928,1)
(3102,4298,1)
(7764,2564,1)
(712,7092,1)
(1374,8949,1)
(3856,4372,1)
(5617,8975,1)
(6108,313,1)
(1429,1603,1)
(606,1844,1)
(2163,628,1)
(2624,574,1)
(3881,1447,1)
(4808,5043,1)
(6461,3306,1)
(7250,4618,1)
(6338,4255,1)
(3780,3929,1)
(2973,1465,1)
(890,1143,1)
(2459,5043,1)
(5486,1061,1)
(6381,3672,1)
(7291,7978,1)
(1705,7215,1)
(2968,4777,1)
(2145,6874,1)
(8280,1502,1)
(3956,7607,1)
(6879,554,1)
(5724,3772,1)
(4517,4928,1)
(4061,878,1)
(8661,2434,1)
(8737,1546,1)
(1194,5660,1)
(1634,2496,1)
(4809,1502,1)
(2067,4831,1)
(2298,5500,1)
(7118,6814,1)
(546,1146,1)
(6706,5043,1)
(1400,3350,1)
(5811,6407,1)
(4721,7155,1)
(7043,1502,1)
(5283,6717,1)
(1176,7619,1)
(4052,5233,1)
(8205,5081,1)
(6886,608,1)
(2228,4928,1)
(8369,2774,1)
(7046,1228,1)
(2637,234,1)
(902,2293,1)
(3687,3694,1)
(2693,679,1)
(5989,3508,1)
(3638,4871,1)
(1534,7042,1)
(6071,2686,1)
(1631,4928,1)
(4784,7004,1)
(5573,3391,1)
(4458,1331,1)
(6756,4377,1)
(7709,3383,1)
(6318,1156,1)
(3430,4928,1)
(3252,2278,1)
(4540,7439,1)
(7599,6050,1)
(2873,2898,1)
(4954,5891,1)
(7668,1860,1)
(8750,6440,1)
(8372,474,1)
(6119,7305,1)
(1988,5115,1)
(89,7970,1)
(6812,7573,1)
(766,4120,1)
(7389,5717,1)
(5336,4928,1)
(9112,9054,1)
(7838,5188,1)
(8464,1502,1)
(8452,8981,1)
(1016,6516,1)
(8734,7787,1)
(2128,6047,1)
(6218,4928,1)
(1724,898,1)
(5758,7275,1)
(278,1598,1)
(7529,7836,1)
(1157,3941,1)
(3522,2199,1)
(6585,8508,1)
(5294,3313,1)
(126,1759,1)
(3105,650,1)
(7807,2130,1)
(4824,223,1)
(8499,6602,1)
(7840,828,1)
(9110,4374,1)
(1010,5011,1)
(4313,9026,1)
(1251,4029,1)
(3189,2766,1)
(8892,4928,1)
(6663,3383,1)
(3074,2249,1)
(5289,8457,1)
(4017,3768,1)
(1212,6066,1)
(400,4928,1)
(1934,1502,1)
(8884,3099,1)
(5542,5952,1)
(305,561,1)
(4695,3583,1)
(6333,3068,1)
(8971,5484,1)
(7486,4468,1)
(6351,1502,1)
(914,6322,1)
(8640,6235,1)
(5693,2189,1)
(8759,3094,1)
(1642,8227,1)
(2834,464,1)
(6817,7004,1)
(6216,5864,1)
(1892,1515,1)
(1832,238,1)
(3302,7100,1)
(1973,3100,1)
(5797,1085,1)
(3092,3481,1)
(1393,4644,1)
(8978,4682,1)
(7657,6368,1)
(7828,9152,1)
(487,2486,1)
(2899,4814,1)
(1923,4568,1)
(4917,7681,1)
(6491,6011,1)
(7512,1921,1)
(931,2723,1)
(1272,5614,1)
(5521,76,1)
(7877,1295,1)
(4350,40,1)
(7466,1502,1)
(7991,6560,1)
(2261,4718,1)
(7939,6678,1)
(2709,6046,1)
(2013,8883,1)
(9025,8769,1)
(3575,4928,1)
(5789,914,1)
(2466,4765,1)
(8312,8681,1)
(3624,1099,1)
(7490,1656,1)
(233,6877,1)
(8865,25,1)
(7239,4670,1)
(7207,2588,1)
(225,5461,1)
(7020,8401,1)
(1221,657,1)
(7618,4928,1)
(6623,3542,1)
(7122,4809,1)
(9031,1275,1)
(228,4143,1)
(5971,5258,1)
(6972,4197,1)
(5914,7657,1)
(3399,6470,1)
(2735,4109,1)
(313,8092,1)
(8032,4892,1)
(4736,4199,1)
(4274,7227,1)
(5823,1890,1)
(4537,494,1)
(7343,2731,1)
(2255,3465,1)
(7971,4233,1)
(3019,1502,1)
(4615,3440,1)
(8530,7856,1)
(7386,4928,1)
(8193,7049,1)
(6311,8021,1)
(7396,5889,1)
(3819,1502,1)
(8929,1502,1)
(4182,4640,1)
(167,1148,1)
(2951,4928,1)
(4861,8214,1)
(4829,1502,1)
(4360,1630,1)
(712,2113,1)
(4951,2898,1)
(41,4036,1)
(7736,3789,1)
(5948,6298,1)
(200,7440,1)
(3302,598,1)
(797,604,1)
(297,8936,1)
(205,2083,1)
(4320,2101,1)
(4405,3048,1)
(1077,7677,1)
(5584,2662,1)
(1447,8190,1)
(8851,3801,1)
(6417,4037,1)
(4291,7429,1)
(2435,1607,1)
(5294,3381,1)
(7046,1128,1)
(8711,440,1)
(4793,3063,1)
(8356,4928,1)
(3869,3631,1)
(6182,7551,1)
(5236,1633,1)
(3748,8587,1)
(2704,4364,1)
(4963,7383,1)
(7991,8188,1)
(1360,5659,1)
(1840,3539,1)
(1085,5522,1)
(1839,6247,1)
(4283,879,1)
(8500,5948,1)
(7602,5264,1)
(6482,1502,1)
(6771,2423,1)
(6328,6030,1)
(1783,8977,1)
(4158,4483,1)
(7900,7186,1)
(3752,2469,1)
(6304,5244,1)
(5051,1775,1)
(8190,8624,1)
(8519,8708,1)
(2839,4928,1)
(7912,5200,1)
(2268,4218,1)
(6052,2998,1)
(1624,5903,1)
(6693,2194,1)
(2649,6455,1)
(1566,7385,1)
(2819,1502,1)
(336,4234,1)
(5294,1855,1)
(2049,5266,1)
(6854,2214,1)
(8249,4413,1)
(1826,5937,1)
(5342,2817,1)
(704,8506,1)
(490,1768,1)
(7917,1502,1)
(930,8485,1)
(4307,7833,1)
(327,833,1)
(8729,2630,1)
(5465,5980,1)
(8519,5346,1)
(6100,1438,1)
(3112,9093,1)
(1336,6098,1)
(9072,1152,1)
(1988,598,1)
(2663,4928,1)
(6713,1502,1)
(1304,3373,1)
(9037,4986,1)
(6911,8726,1)
(5647,3742,1)
(4420,1348,1)
(8729,343,1)
(8829,1591,1)
(4036,8537,1)
(5913,2725,1)
(712,2893,1)
(5527,1044,1)
(1548,7462,1)
(6830,1502,1)
(3901,5513,1)
(1360,1502,1)
(5272,3128,1)
(7886,6448,1)
(6899,7965,1)
(8176,3475,1)
(7910,8514,1)
(1251,6960,1)
(2797,9135,1)
(8263,3178,1)
(972,3583,1)
(7296,7171,1)
(2075,3198,1)
(7427,270,1)
(4858,486,1)
(9046,4844,1)
(9059,4828,1)
(739,4301,1)
(1037,6102,1)
(8015,4719,1)
(3299,4928,1)
(706,1125,1)
(9114,4912,1)
(6355,1714,1)
(4674,271,1)
(4374,3200,1)
(750,4704,1)
(7916,3919,1)
(9028,5750,1)
(9076,2138,1)
(3917,2791,1)
(3338,1502,1)
(5943,4518,1)
(1734,2092,1)
(1819,1788,1)
(9026,5559,1)
(3462,7518,1)
(5486,4137,1)
(2774,173,1)
(7220,3847,1)
(5254,6858,1)
(7224,71,1)
(861,8991,1)
(8132,7756,1)
(1073,7336,1)
(4284,6307,1)
(7725,7507,1)
(3993,2688,1)
(5844,1740,1)
(2998,371,1)
(2196,7709,1)
(3848,4915,1)
(2746,3359,1)
(7193,8124,1)
(8887,4605,1)
(8851,1502,1)
(7960,2893,1)
(1291,1502,1)
(5297,5097,1)
(4472,1489,1)
(6953,5361,1)
(5751,2136,1)
(1949,5722,1)
(5448,1502,1)
(2135,954,1)
(5177,1502,1)
(5973,3312,1)
(460,4928,1)
(5927,4732,1)
(4630,2665,1)
(5716,6252,1)
(8462,8680,1)
(3873,6529,1)
(2373,5716,1)
(1324,207,1)
(6210,862,1)
(7677,923,1)
(6942,7187,1)
(7345,7091,1)
(1380,1502,1)
(3580,5445,1)
(6653,8848,1)
(631,5592,1)
(5013,5608,1)
(3127,3039,1)
(6792,997,1)
(3330,4928,1)
(8870,8438,1)
(7461,2938,1)
(1384,8773,1)
(2938,4103,1)
(5904,4392,1)
(8644,7985,1)
(8666,6244,1)
(6648,8662,1)
(1004,826,1)
(7449,7536,1)
(7553,1385,1)
(4801,1071,1)
(2996,5558,1)
(2857,6636,1)
(8311,5066,1)
(246,4396,1)
(7887,3247,1)
(4472,7100,1)
(4441,6896,1)
(2077,8342,1)
(2099,5350,1)
(8276,1832,1)
(6855,4598,1)
(3338,4928,1)
(8113,8811,1)
(8260,8049,1)
(2658,4232,1)
(5008,6924,1)
(2585,5050,1)
(2944,7891,1)
(2089,5186,1)
(1800,3106,1)
(7286,7259,1)
(9029,4703,1)
(5607,433,1)
(9022,7884,1)
(848,733,1)
(6003,4928,1)
(6594,8479,1)
(2445,3329,1)
(7796,3078,1)
(4393,3866,1)
(5259,6047,1)
(1348,5218,1)
(1755,8533,1)
(7912,4246,1)
(5806,6167,1)
(54,5881,1)
(509,4869,1)
(3754,3674,1)
(6584,5957,1)
(767,139,1)
(1353,1460,1)
(8957,4744,1)
(4626,5631,1)
(6788,3713,1)
(390,7925,1)
(1312,5538,1)
(3755,4928,1)
(6247,3706,1)
(6837,8784,1)
(2376,7822,1)
(5250,4139,1)
(5294,408,1)
(3186,8815,1)
(622,7410,1)
(1291,6047,1)
(3012,763,1)
(2888,9151,1)
(8349,5231,1)
(4125,8527,1)
(1726,4928,1)
(2654,295,1)
(6569,4928,1)
(8228,5831,1)
(8226,8362,1)
(394,4928,1)
(1554,4549,1)
(4064,6263,1)
(6731,3056,1)
(8513,1223,1)
(2831,884,1)
(2076,8259,1)
(205,1502,1)
(7960,9110,1)
(5152,6683,1)
(6434,8725,1)
(260,943,1)
(7471,6613,1)
(3641,7472,1)
(6003,8734,1)
(16,224,1)
(1255,2898,1)
(5065,1012,1)
(3425,4923,1)
(7025,2603,1)
(930,1502,1)
(3464,3916,1)
(5294,3825,1)
(3226,7116,1)
(7798,4722,1)
(6028,2182,1)
(1390,7795,1)
(2715,4210,1)
(1258,6352,1)
(446,4877,1)
(3313,1502,1)
(6289,8513,1)
(6863,918,1)
(9057,8932,1)
(1106,8525,1)
(5084,2249,1)
(5592,6812,1)
(478,6303,1)
(3045,6796,1)
(969,2402,1)
(4176,2222,1)
(3416,334,1)
(3028,6486,1)
(7466,6668,1)
(2772,4928,1)
(2637,7659,1)
(5131,4839,1)
(2188,1245,1)
(3927,3521,1)
(7813,5416,1)
(8241,8968,1)
(5753,1502,1)
(2564,1409,1)
(2227,257,1)
(5538,5897,1)
(6869,264,1)
(2700,4928,1)
(5709,1502,1)
(5571,8287,1)
(972,7468,1)
(2837,509,1)
(1983,4214,1)
(2906,5033,1)
(8442,2364,1)
(7572,8362,1)
(4065,4928,1)
(2791,3399,1)
(7521,6179,1)
(9054,1383,1)
(6295,9126,1)
(7106,8204,1)
(6277,1502,1)
(8152,211,1)
(7991,7100,1)
(7889,1502,1)
(240,5374,1)
(2249,350,1)
(8778,2265,1)
(5191,8628,1)
(6182,598,1)
(5883,6945,1)
(1164,3697,1)
(5948,1369,1)
(165,2437,1)
(7468,7100,1)
(6175,3987,1)
(6259,3163,1)
(5563,3655,1)
(7175,3482,1)
(9071,4511,1)
(2735,4425,1)
(1744,5689,1)
(5319,6435,1)
(4407,4320,1)
(3087,119,1)
(4234,5035,1)
(8266,6849,1)
(1711,8787,1)
(3317,1157,1)
(679,3795,1)
(432,3814,1)
(7136,7577,1)
(1904,1502,1)
(7366,8397,1)
(1896,5520,1)
(4706,8303,1)
(6175,4928,1)
(6191,218,1)
(6292,425,1)
(7943,1502,1)
(2082,7442,1)
(3304,5362,1)
(5875,6431,1)
(2530,727,1)
(3735,6880,1)
(485,7154,1)
(8273,5743,1)
(8420,2448,1)
(771,4555,1)
(7755,315,1)
(3884,766,1)
(7710,5828,1)
(4147,4451,1)
(2954,4928,1)
(5817,1502,1)
(8677,2297,1)
(7898,8402,1)
(5947,6996,1)
(522,9089,1)
(602,6985,1)
(8799,4436,1)
(6578,3734,1)
(6070,508,1)
(7991,2894,1)
(8043,7391,1)
(7473,8698,1)
(1719,4115,1)
(8140,4928,1)
(6302,1502,1)
(1898,5616,1)
(863,6229,1)
(1402,1502,1)
(456,7559,1)
(2301,434,1)
(4164,4928,1)
(609,8311,1)
(8159,468,1)
(2317,4772,1)
(6036,5239,1)
(5459,0,1)
(332,6399,1)
(4846,8188,1)
(1992,8383,1)
(15,8501,1)
(6120,130,1)
(7435,2518,1)
(7308,6103,1)
(1606,4234,1)
(3341,6932,1)
(6934,4774,1)
(4394,670,1)
(3414,8507,1)
(3963,5030,1)
(7064,6882,1)
(6601,7202,1)
(8399,2287,1)
(2642,8452,1)
(5182,8008,1)
(5093,7786,1)
(1779,3125,1)
(1963,2948,1)
(7034,520,1)
(3886,4928,1)
(2537,2605,1)
(1048,8706,1)
(8092,8260,1)
(7217,2517,1)
(1924,7004,1)
(4561,1502,1)
(7839,1666,1)
(1873,523,1)
(4771,6975,1)
(6566,4130,1)
(4313,9037,1)
(8565,4695,1)
(3468,6225,1)
(7943,4928,1)
(4108,213,1)
(2735,6326,1)
(9155,7188,1)
(504,1591,1)
(3740,5242,1)
(3855,1502,1)
(5590,6267,1)
(7226,5927,1)
(252,6994,1)
(131,6523,1)
(5416,4474,1)
(5071,4928,1)
(1189,1677,1)
(8721,4461,1)
(5636,1502,1)
(381,6743,1)
(5351,1086,1)
(8920,749,1)
(5977,1317,1)
(8158,607,1)
(1110,3512,1)
(140,4875,1)
(5950,6695,1)
(4355,6095,1)
(1678,3062,1)
(859,5181,1)
(8119,2071,1)
(331,1810,1)
(5924,5657,1)
(1943,1025,1)
(8557,5047,1)
(9012,6805,1)
(712,5559,1)
(3512,261,1)
(1185,4928,1)
(1901,4928,1)
(143,5297,1)
(760,5769,1)
(333,7846,1)
(2967,6047,1)
(569,1502,1)
(5957,7720,1)
(5606,3954,1)
(5735,4125,1)
(5294,6465,1)
(2605,1853,1)
(4093,4211,1)
(9135,1205,1)
(8884,7364,1)
(1677,6418,1)
(2049,8470,1)
(4675,4018,1)
(1829,1219,1)
(2286,8745,1)
(8051,6873,1)
(5341,1502,1)
(9111,4805,1)
(113,5846,1)
(9066,8201,1)
(3232,3494,1)
(2957,6115,1)
(3420,6047,1)
(1091,5340,1)
(9037,9075,1)
(6330,2342,1)
(3892,7408,1)
(3126,6607,1)
(8218,4847,1)
(8389,8809,1)
(4455,6424,1)
(3860,331,1)
(4033,620,1)
(900,3248,1)
(7997,8324,1)
(466,2927,1)
(2350,5977,1)
(3510,6119,1)
(1938,4022,1)
(7046,7100,1)
(4951,4926,1)
(6219,4274,1)
(8741,6272,1)
(3677,5265,1)
(3504,3026,1)
(7730,5244,1)
(5760,7004,1)
(530,8942,1)
(3586,4042,1)
(1893,2600,1)
(6998,6422,1)
(2055,1502,1)
(2828,4928,1)
(2051,120,1)
(3401,4928,1)
(5294,3613,1)
(6304,598,1)
(5519,8752,1)
(4074,6179,1)
(4638,2411,1)
(601,45,1)
(8258,6600,1)
(4036,5102,1)
(2237,8725,1)
(7430,4998,1)
(1999,3510,1)
(6787,5091,1)
(6850,1720,1)
(5106,1502,1)
(8561,4081,1)
(2138,5489,1)
(2316,3061,1)
(1094,4837,1)
(6708,1916,1)
(3594,2898,1)
(1369,1930,1)
(4997,6510,1)
(480,8862,1)
(3187,4765,1)
(5675,1691,1)
(206,3508,1)
(5144,8042,1)
(3227,3871,1)
(8482,3204,1)
(7336,7830,1)
(5078,9057,1)
(6130,2708,1)
(8240,5572,1)
(3460,2829,1)
(6002,7903,1)
(7434,8532,1)
(3925,3490,1)
(2415,8326,1)
(6482,3554,1)
(1146,8083,1)
(5200,7571,1)
(4719,3861,1)
(3997,8924,1)
(3858,7144,1)
(5080,3020,1)
(8584,4928,1)
(9115,6438,1)
(9142,1502,1)
(1475,6261,1)
(1549,8854,1)
(8875,8943,1)
(6202,1502,1)
(3872,247,1)
(5658,5398,1)
(5132,3640,1)
(5020,4726,1)
(3084,3327,1)
(5919,8756,1)
(6618,6227,1)
(4953,4928,1)
(7522,4789,1)
(318,6612,1)
(7397,2160,1)
(2293,8616,1)
(3730,570,1)
(4437,7092,1)
(3469,4283,1)
(6646,8562,1)
(6962,8810,1)
(8940,3966,1)
(4554,7393,1)
(1193,3105,1)
(5024,7780,1)
(2370,6704,1)
(1334,1502,1)
(7807,1502,1)
(2597,6318,1)
(9141,4299,1)
(8776,5684,1)
(5711,3219,1)
(715,5456,1)
(8481,5026,1)
(2806,5177,1)
(7450,7184,1)
(146,5303,1)
(9067,1745,1)
(8141,5366,1)
(2333,7759,1)
(8944,1502,1)
(134,3174,1)
(891,4928,1)
(7619,2844,1)
(6145,2465,1)
(1533,612,1)
(3870,4928,1)
(2119,2294,1)
(4222,5043,1)
(1762,3444,1)
(3997,8028,1)
(7718,1227,1)
(7062,630,1)
(9050,240,1)
(3564,8451,1)
(1152,3445,1)
(5048,2391,1)
(4462,6031,1)
(7546,7098,1)
(3788,4685,1)
(3349,2067,1)
(5772,668,1)
(5294,3968,1)
(6397,2115,1)
(4687,189,1)
(5359,4928,1)
(504,598,1)
(643,3731,1)
(8131,386,1)
(2365,7110,1)
(6450,5902,1)
(2228,1502,1)
(8442,6755,1)
(493,2996,1)
(1278,4928,1)
(6832,3589,1)
(6752,7521,1)
(8657,2964,1)
(3891,2079,1)
(7590,7269,1)
(7995,8014,1)
(509,7004,1)
(7172,4928,1)
(1206,2091,1)
(5569,5337,1)
(1191,1342,1)
(4313,4846,1)
(2969,4928,1)
(1714,6108,1)
(8232,7674,1)
(3282,2700,1)
(1272,4972,1)
(2703,7050,1)
(5265,2854,1)
(638,5494,1)
(7670,5902,1)
(189,8938,1)
(2823,7626,1)
(4074,3530,1)
(4070,1840,1)
(4304,377,1)
(3432,4727,1)
(8547,2535,1)
(3371,6194,1)
(4637,6161,1)
(3474,8366,1)
(8761,3779,1)
(4503,5988,1)
(6075,5902,1)
(5587,8251,1)
(3411,1489,1)
(1806,3501,1)
(1628,1498,1)
(5271,3647,1)
(734,7504,1)
(1720,3089,1)
(6863,6297,1)
(5967,7472,1)
(3909,602,1)
(2477,4928,1)
(5818,8394,1)
(7856,5573,1)
(5929,4186,1)
(3746,3516,1)
(4886,592,1)
(804,6736,1)
(940,9041,1)
(1728,3290,1)
(4995,6811,1)
(6917,6649,1)
(6953,5437,1)
(4642,7495,1)
(8863,1784,1)
(7377,1502,1)
(4930,7474,1)
(3265,5043,1)
(5684,6308,1)
(4491,6047,1)
(7697,1502,1)
(2553,8661,1)
(7521,1502,1)
(504,6465,1)
(1924,2443,1)
(782,4178,1)
(644,45,1)
(4351,6494,1)
(1753,6080,1)
(3663,6552,1)
(7005,8173,1)
(5166,69,1)
(3988,5748,1)
(7624,3986,1)
(1396,6675,1)
(6404,984,1)
(4148,7653,1)
(7910,1515,1)
(2133,1654,1)
(7629,1478,1)
(4202,4110,1)
(4784,6788,1)
(3753,4501,1)
(1841,5029,1)
(805,1701,1)
(1683,6437,1)
(5282,881,1)
(1321,6770,1)
(8929,4928,1)
(247,6603,1)
(1472,2889,1)
(2314,1814,1)
(2443,4928,1)
(4559,7359,1)
(7890,5787,1)
(6399,7425,1)
(3931,4561,1)
(4147,3280,1)
(2394,1094,1)
(3325,6832,1)
(5502,6060,1)
(1646,1502,1)
(2498,7441,1)
(7999,1502,1)
(1152,2322,1)
(5345,5605,1)
(2829,2498,1)
(5383,1452,1)
(736,1715,1)
(5507,2894,1)
(2735,4716,1)
(6156,2483,1)
(3928,7379,1)
(7871,4397,1)
(7815,3785,1)
(406,5731,1)
(2726,4235,1)
(6938,334,1)
(4707,8663,1)
(4804,2625,1)
(4743,1415,1)
(4284,4928,1)
(4437,598,1)
(6949,4928,1)
(8165,4430,1)
(4437,5573,1)
(4810,392,1)
(1056,9048,1)
(7428,3790,1)
(6170,7231,1)
(9027,15,1)
(5121,1268,1)
(7487,342,1)
(5213,2571,1)
(7440,8975,1)
(4969,5727,1)
(2994,8217,1)
(6908,169,1)
(4356,677,1)
(8965,1236,1)
(7277,8837,1)
(5065,1515,1)
(3067,8297,1)
(9022,3939,1)
(5610,5689,1)
(9126,6034,1)
(4078,2131,1)
(4476,6663,1)
(7793,4928,1)
(548,4447,1)
(3980,9106,1)
(5036,4928,1)
(51,5928,1)
(6305,539,1)
(8197,6008,1)
(5578,4169,1)
(3299,1502,1)
(4316,2885,1)
(7734,9051,1)
(3990,5043,1)
(4509,1425,1)
(2987,614,1)
(3963,5398,1)
(5688,8547,1)
(4922,8666,1)
(8159,388,1)
(5122,4744,1)
(3543,4928,1)
(947,444,1)
(795,3162,1)
(4739,4928,1)
(356,3988,1)
(806,6165,1)
(404,1520,1)
(1860,2830,1)
(8781,2920,1)
(3073,2281,1)
(699,2324,1)
(2874,6150,1)
(2158,3544,1)
(997,6036,1)
(7717,2412,1)
(200,3436,1)
(8529,6383,1)
(2548,6819,1)
(1410,6431,1)
(3679,1105,1)
(5294,3465,1)
(5091,3349,1)
(5704,2223,1)
(9042,5902,1)
(3048,5899,1)
(8071,4928,1)
(4437,2894,1)
(8740,7239,1)
(1708,7302,1)
(814,2381,1)
(3680,4642,1)
(7367,4928,1)
(1738,4928,1)
(5641,4617,1)
(4221,4928,1)
(7603,205,1)
(7231,2095,1)
(2673,4928,1)
(4497,3680,1)
(8528,2200,1)
(4739,1502,1)
(4293,1502,1)
(1081,8889,1)
(2907,2313,1)
(662,1502,1)
(4064,4765,1)
(4445,2843,1)
(6882,6349,1)
(268,4570,1)
(6423,8210,1)
(4623,103,1)
(3,5843,1)
(8760,6537,1)
(2001,560,1)
(2642,5928,1)
(291,3781,1)
(286,4948,1)
(8284,7714,1)
(8356,6047,1)
(77,6925,1)
(4,938,1)
(7333,1354,1)
(1517,4038,1)
(188,3915,1)
(7182,5540,1)
(7602,1063,1)
(8223,1963,1)
(4367,609,1)
(4165,2782,1)
(482,8032,1)
(2392,7004,1)
(4246,237,1)
(8560,1502,1)
(2227,381,1)
(4366,3638,1)
(710,27,1)
(2338,5597,1)
(6159,5209,1)
(4164,1502,1)
(107,1363,1)
(2439,7300,1)
(2842,1903,1)
(7447,6431,1)
(5573,2272,1)
(4437,8678,1)
(5181,3858,1)
(5247,4031,1)
(4031,4395,1)
(7678,3440,1)
(2118,1823,1)
(1039,5070,1)
(7635,882,1)
(8743,4467,1)
(3019,4928,1)
(7154,8750,1)
(7232,2500,1)
(5965,7221,1)
(8494,1502,1)
(1511,4069,1)
(5658,4961,1)
(1658,2219,1)
(8764,1168,1)
(5646,4527,1)
(2656,5510,1)
(7145,6948,1)
(8348,754,1)
(2950,9149,1)
(3239,320,1)
(2563,4344,1)
(5488,4778,1)
(1202,7414,1)
(6637,5259,1)
(2855,3552,1)
(3482,4744,1)
(8891,8059,1)
(7367,1502,1)
(630,3863,1)
(8354,6722,1)
(6705,6047,1)
(5594,2898,1)
(6200,5734,1)
(4341,1556,1)
(5086,6047,1)
(2403,7213,1)
(8336,4928,1)
(6005,4928,1)
(8792,5453,1)
(7849,687,1)
(7270,5043,1)
(260,6692,1)
(1739,5797,1)
(4472,2893,1)
(5329,1502,1)
(6672,4928,1)
(6887,1631,1)
(6668,3970,1)
(7459,3630,1)
(7866,2096,1)
(2341,5430,1)
(600,6427,1)
(1145,4161,1)
(1944,1221,1)
(6436,1288,1)
(2398,1633,1)
(1362,5617,1)
(5129,5358,1)
(116,5951,1)
(7694,7674,1)
(8136,1502,1)
(1392,5536,1)
(3738,5923,1)
(6640,4928,1)
(6996,5054,1)
(4012,936,1)
(8784,5291,1)
(906,3729,1)
(2716,5340,1)
(5666,8884,1)
(2183,6665,1)
(5487,5468,1)
(2018,4291,1)
(8574,1502,1)
(3973,2679,1)
(1060,2750,1)
(7921,7327,1)
(6005,1807,1)
(1988,7148,1)
(3850,8437,1)
(4471,478,1)
(2065,7115,1)
(2038,2935,1)
(6872,4919,1)
(4825,4227,1)
(7622,3166,1)
(7468,598,1)
(8900,1364,1)
(2178,1502,1)
(7233,6813,1)
(6831,3323,1)
(8206,3698,1)
(2208,1041,1)
(7636,861,1)
(379,3968,1)
(7908,3127,1)
(4623,5398,1)
(4376,7950,1)
(1333,2495,1)
(1733,8067,1)
(6487,8061,1)
(8772,1559,1)
(1108,2220,1)
(216,3876,1)
(7556,7487,1)
(4588,3318,1)
(1042,6313,1)
(6629,1165,1)
(4894,5975,1)
(6324,8536,1)
(4505,6508,1)
(2042,1821,1)
(50,7422,1)
(2198,7994,1)
(3721,1502,1)
(7384,8252,1)
(7306,8115,1)
(4117,7371,1)
(7582,5955,1)
(7273,2430,1)
(805,7729,1)
(979,4001,1)
(3060,2785,1)
(6304,1837,1)
(5029,1568,1)
(6022,254,1)
(5529,7640,1)
(1398,1092,1)
(4559,5610,1)
(5294,2462,1)
(270,7825,1)
(522,881,1)
(2136,1560,1)
(6753,773,1)
(6372,1647,1)
(507,4486,1)
(2958,4641,1)
(1817,1502,1)
(1152,2507,1)
(342,1304,1)
(5088,1502,1)
(5665,8254,1)
(8891,7468,1)
(7875,2899,1)
(5125,4496,1)
(4372,4928,1)
(3294,943,1)
(1708,1502,1)
(8891,3583,1)
(8567,5480,1)
(7161,6979,1)
(8732,3232,1)
(1766,967,1)
(4776,5666,1)
(7677,8822,1)
(3407,5609,1)
(618,1502,1)
(4714,1599,1)
(3247,7529,1)
(6431,8960,1)
(3281,2336,1)
(3511,500,1)
(2753,6551,1)
(2701,1054,1)
(1399,3619,1)
(7783,6431,1)
(2986,7587,1)
(4891,1743,1)
(597,1502,1)
(8962,7642,1)
(5075,1502,1)
(5745,3531,1)
(8548,8018,1)
(6873,1769,1)
(2648,2921,1)
(1768,4385,1)
(5544,1502,1)
(6546,3594,1)
(342,5216,1)
(3888,2306,1)
(6365,7004,1)
(6032,646,1)
(2320,6560,1)
(5099,1919,1)
(2275,2937,1)
(8037,4524,1)
(3256,6958,1)
(5812,8747,1)
(7160,3101,1)
(7259,8874,1)
(678,2143,1)
(5905,8856,1)
(2608,4746,1)
(1066,7659,1)
(2751,6301,1)
(2869,3674,1)
(8788,858,1)
(638,4928,1)
(2589,7468,1)
(1397,4407,1)
(8622,829,1)
(7645,7732,1)
(3907,8348,1)
(8136,7942,1)
(6732,8136,1)
(7324,5217,1)
(5696,4928,1)
(121,4608,1)
(7573,3133,1)
(2611,5043,1)
(779,2836,1)
(814,1034,1)
(8795,2649,1)
(8829,4551,1)
(501,4194,1)
(8135,8934,1)
(2849,725,1)
(7793,2648,1)
(7457,8360,1)
(1004,87,1)
(6168,4708,1)
(4846,598,1)
(4494,4928,1)
(5330,4928,1)
(137,6799,1)
(2098,2137,1)
(3104,7975,1)
(7827,2914,1)
(4438,5627,1)
(987,1920,1)
(1954,1328,1)
(5611,1502,1)
(1740,7857,1)
(4452,1502,1)
(1632,2351,1)
(6698,1981,1)
(3753,4928,1)
(7769,2180,1)
(8324,6016,1)
(4966,1002,1)
(983,341,1)
(5294,136,1)
(1240,5397,1)
(4184,6795,1)
(6337,4333,1)
(4809,6047,1)
(4941,506,1)
(6102,1502,1)
(5658,5030,1)
(1660,660,1)
(6780,6642,1)
(6348,1502,1)
(5177,6856,1)
(4785,8182,1)
(7192,7004,1)
(9146,5399,1)
(366,4027,1)
(4972,5517,1)
(4050,2032,1)
(4150,2181,1)
(2735,225,1)
(2533,8852,1)
(8569,458,1)
(1769,7530,1)
(4331,841,1)
(8306,3719,1)
(5312,3454,1)
(7706,2494,1)
(6597,2393,1)
(7318,7829,1)
(877,1502,1)
(8071,1180,1)
(4437,642,1)
(4472,7409,1)
(4379,4955,1)
(5888,2416,1)
(1746,7360,1)
(4693,3702,1)
(7147,6648,1)
(1828,3583,1)
(7079,2404,1)
(2073,7481,1)
(8632,1502,1)
(3500,7599,1)
(6931,2065,1)
(8225,7620,1)
(6489,4577,1)
(141,1502,1)
(6549,5207,1)
(3409,4928,1)
(5258,1502,1)
(3019,7926,1)
(4689,8731,1)
(3576,8138,1)
(3192,617,1)
(3809,2916,1)
(749,5440,1)
(7423,7930,1)
(3360,7234,1)
(7625,8973,1)
(6087,5633,1)
(7764,8797,1)
(1635,6673,1)
(211,3633,1)
(2803,5043,1)
(6687,4465,1)
(9132,5847,1)
(7540,4284,1)
(1630,2738,1)
(4298,7566,1)
(935,2209,1)
(8852,6567,1)
(6605,706,1)
(8946,3131,1)
(9087,664,1)
(1038,7514,1)
(1365,4179,1)
(2324,2643,1)
(408,2022,1)
(5364,3670,1)
(3710,3442,1)
(4147,806,1)
(7111,2308,1)
(6264,8748,1)
(3258,1056,1)
(2765,80,1)
(4070,1201,1)
(5333,8033,1)
(305,1502,1)
(3283,6642,1)
(5898,1400,1)
(7100,1376,1)
(865,4668,1)
(4281,4653,1)
(1160,4498,1)
(6092,816,1)
(5303,4654,1)
(3917,5807,1)
(7633,2735,1)
(3177,840,1)
(1972,4193,1)
(472,7320,1)
(273,48,1)
(2735,2026,1)
(5579,7538,1)
(856,3172,1)
(2735,5280,1)
(4911,7535,1)
(5790,5498,1)
(7468,5315,1)
(2913,3708,1)
(5782,3155,1)
(423,6216,1)
(6051,6388,1)
(4826,8596,1)
(1649,4272,1)
(5963,5849,1)
(4996,1038,1)
(4155,7921,1)
(4299,6937,1)
(6666,8950,1)
(2532,439,1)
(9101,8180,1)
(4475,7322,1)
(9125,4928,1)
(941,7594,1)
(7109,3591,1)
(8686,6439,1)
(2062,6758,1)
(3382,5827,1)
(8727,1296,1)
(6097,5196,1)
(194,4868,1)
(2339,7824,1)
(6371,621,1)
(3695,7932,1)
(5625,344,1)
(6306,5040,1)
(4956,5145,1)
(6051,7004,1)
(3120,4070,1)
(257,7287,1)
(2869,8678,1)
(2244,1231,1)
(6718,2645,1)
(4141,4928,1)
(858,6405,1)
(3304,5122,1)
(7936,6775,1)
(4821,6967,1)
(4725,2768,1)
(2753,4928,1)
(5407,2445,1)
(7508,8362,1)
(8303,2970,1)
(4942,2906,1)
(8973,5298,1)
(1969,6835,1)
(9003,4443,1)
(553,3113,1)
(5689,7557,1)
(8186,6923,1)
(6025,1502,1)
(8982,2800,1)
(372,6846,1)
(9016,6496,1)
(4948,8498,1)
(6811,2385,1)
(3691,5311,1)
(4326,1968,1)
(7409,6042,1)
(7473,2315,1)
(88,1273,1)
(1255,2087,1)
(4678,5334,1)
(3598,396,1)
(8829,8037,1)
(3851,6316,1)
(478,809,1)
(3946,47,1)
(7701,3754,1)
(3542,922,1)
(1726,1502,1)
(8682,720,1)
(6413,7731,1)
(5575,5016,1)
(7077,7100,1)
(5483,2696,1)
(2320,3313,1)
(8488,5304,1)
(8252,8487,1)
(7605,4928,1)
(6915,3786,1)
(4090,6129,1)
(17,6874,1)
(5322,1502,1)
(4048,8827,1)
(1032,713,1)
(2159,1708,1)
(2651,3472,1)
(1333,4527,1)
(4323,2003,1)
(2196,3383,1)
(4742,7548,1)
(9100,4928,1)
(5406,527,1)
(4472,8188,1)
(155,5020,1)
(2953,5649,1)
(4437,4414,1)
(8411,1772,1)
(1817,4145,1)
(1862,1003,1)
(4980,4480,1)
(8868,5043,1)
(4018,6265,1)
(6326,3241,1)
(5060,482,1)
(909,1502,1)
(8941,2168,1)
(7303,7913,1)
(3230,5902,1)
(5944,1549,1)
(30,4238,1)
(2997,2010,1)
(5414,7576,1)
(1359,1502,1)
(591,1387,1)
(812,5255,1)
(1242,5021,1)
(1567,634,1)
(5995,5882,1)
(9031,4928,1)
(2860,7563,1)
(7638,5757,1)
(6304,6427,1)
(870,161,1)
(5773,3757,1)
(7764,8222,1)
(5525,7000,1)
(1793,904,1)
(7689,6062,1)
(7501,4928,1)
(5655,2400,1)
(7046,2113,1)
(6148,1502,1)
(6025,4089,1)
(3462,7526,1)
(7545,4352,1)
(3996,6323,1)
(8363,6461,1)
(7967,8570,1)
(1731,88,1)
(1451,4096,1)
(5151,7140,1)
(7945,5220,1)
(3493,4928,1)
(3733,6761,1)
(3699,532,1)
(7170,6068,1)
(6705,7799,1)
(8705,5218,1)
(2735,7747,1)
(4590,1502,1)
(6758,4928,1)
(8619,1558,1)
(3411,7100,1)
(8780,4744,1)
(3299,3419,1)
(7463,8695,1)
(7882,2278,1)
(3216,5902,1)
(1458,910,1)
(5676,2181,1)
(2792,4744,1)
(7826,900,1)
(2047,7307,1)
(5137,1243,1)
(5454,5902,1)
(2273,5848,1)
(6110,1729,1)
(1375,1241,1)
(7772,8261,1)
(1112,3473,1)
(900,2974,1)
(3342,4928,1)
(3303,9027,1)
(7251,3924,1)
(2417,6309,1)
(5207,9072,1)
(4972,3884,1)
(8708,5346,1)
(7227,4398,1)
(7304,3604,1)
(1915,4176,1)
(2972,3928,1)
(8140,5382,1)
(6905,969,1)
(3332,4928,1)
(6304,7141,1)
(1827,5442,1)
(6278,180,1)
(307,4386,1)
(5537,2029,1)
(7615,4732,1)
(1177,6250,1)
(2201,7162,1)
(6844,4563,1)
(4140,8970,1)
(7640,5372,1)
(2638,8003,1)
(2587,3251,1)
(492,1502,1)
(9128,1502,1)
(4336,4928,1)
(7872,7208,1)
(5802,5889,1)
(6842,3457,1)
(4501,7185,1)
(3887,491,1)
(1691,3563,1)
(1086,8983,1)
(7612,8078,1)
(3292,919,1)
(6932,4598,1)
(7033,1502,1)
(4539,7342,1)
(5122,4564,1)
(2358,2882,1)
(2492,9053,1)
(2869,3313,1)
(7380,6773,1)
(1836,3947,1)
(4270,6353,1)
(5230,6696,1)
(8461,1502,1)
(5784,4519,1)
(4380,2426,1)
(3453,7278,1)
(1111,1502,1)
(719,1502,1)
(4079,7986,1)
(7581,2118,1)
(1043,6047,1)
(4874,1502,1)
(2376,119,1)
(5310,1502,1)
(3306,4928,1)
(4996,1502,1)
(7077,2893,1)
(199,2906,1)
(7046,8037,1)
(658,6047,1)
(829,997,1)
(2223,1533,1)
(5431,3164,1)
(1157,1872,1)
(4210,4476,1)
(1681,1484,1)
(856,4375,1)
(309,5270,1)
(7330,4022,1)
(6304,2113,1)
(5036,5926,1)
(3636,8324,1)
(7386,7716,1)
(2735,3548,1)
(3301,3715,1)
(310,1502,1)
(1005,1626,1)
(1631,1502,1)
(9037,3674,1)
(55,4928,1)
(1472,4226,1)
(1188,7062,1)
(5370,4508,1)
(157,5636,1)
(1144,7834,1)
(1069,2940,1)
(8636,6047,1)
(3535,982,1)
(2636,5377,1)
(5055,6388,1)
(3935,9030,1)
(2410,652,1)
(7272,2167,1)
(2581,4185,1)
(6957,1433,1)
(1971,8362,1)
(2788,5642,1)
(2497,735,1)
(6702,3583,1)
(3393,5829,1)
(6706,5902,1)
(5216,2323,1)
(4148,8733,1)
(7521,3530,1)
(7716,2321,1)
(5255,1502,1)
(6805,7694,1)
(6870,8764,1)
(476,8975,1)
(3664,8037,1)
(5163,1898,1)
(8644,6179,1)
(3681,6047,1)
(1946,6794,1)
(2521,7712,1)
(6304,677,1)
(1492,6672,1)
(3501,8644,1)
(1725,1772,1)
(4802,739,1)
(3063,3319,1)
(363,1889,1)
(6723,5463,1)
(4843,7742,1)
(9107,2221,1)
(8104,4840,1)
(5638,1958,1)
(7397,6864,1)
(2225,590,1)
(3209,3497,1)
(8779,3189,1)
(6647,1692,1)
(7253,7935,1)
(8642,5590,1)
(1064,1155,1)
(1506,6693,1)
(2611,1846,1)
(6856,8435,1)
(8190,5758,1)
(674,5098,1)
(3805,1345,1)
(2644,3229,1)
(7575,837,1)
(5974,8975,1)
(8256,8913,1)
(3591,7628,1)
(3302,7092,1)
(1812,8890,1)
(1089,5793,1)
(8208,3941,1)
(843,5620,1)
(6394,584,1)
(5026,2159,1)
(249,3381,1)
(7093,6934,1)
(1957,6645,1)
(712,7749,1)
(242,4928,1)
(8057,7369,1)
(8241,925,1)
(7905,3252,1)
(7280,3937,1)
(361,4928,1)
(6510,1502,1)
(1280,7870,1)
(7552,8055,1)
(2190,5320,1)
(1044,3556,1)
(2015,6066,1)
(4245,5563,1)
(6852,6415,1)
(3342,465,1)
(4543,8445,1)
(3975,3281,1)
(2412,6878,1)
(8762,1502,1)
(499,2545,1)
(2723,3580,1)
(2745,1306,1)
(4888,303,1)
(3078,8280,1)
(4055,235,1)
(1389,3846,1)
(8829,5559,1)
(6240,7298,1)
(5810,7727,1)
(4595,689,1)
(1824,6890,1)
(7468,3313,1)
(3516,3798,1)
(5658,7526,1)
(5067,3855,1)
(1830,7713,1)
(2131,1462,1)
(5114,7522,1)
(2474,175,1)
(3817,7783,1)
(937,5665,1)
(9055,9001,1)
(6227,8869,1)
(4620,4541,1)
(9033,7452,1)
(3206,6566,1)
(2735,8897,1)
(142,1732,1)
(1688,8318,1)
(7311,5954,1)
(2536,4090,1)
(5774,3504,1)
(1993,691,1)
(1958,4657,1)
(1791,2280,1)
(8252,4823,1)
(1519,1417,1)
(606,5127,1)
(9037,6560,1)
(4556,6169,1)
(6402,5012,1)
(1988,7100,1)
(5396,8763,1)
(5156,4440,1)
(2320,5559,1)
(496,5386,1)
(5288,714,1)
(1021,258,1)
(8348,5718,1)
(3089,308,1)
(4767,3055,1)
(1489,7010,1)
(5449,8467,1)
(1346,7235,1)
(7371,1996,1)
(7881,6140,1)
(7527,8683,1)
(4287,2061,1)
(8336,1502,1)
(8395,3924,1)
(2011,7698,1)
(7707,6076,1)
(3903,7475,1)
(3535,2663,1)
(8566,8184,1)
(3633,3459,1)
(7729,1763,1)
(7764,7207,1)
(6512,2197,1)
(5871,5108,1)
(1254,2638,1)
(5509,5034,1)
(3853,5105,1)
(5162,2898,1)
(4283,943,1)
(1522,7202,1)
(2141,8632,1)
(5496,8671,1)
(702,4730,1)
(7468,8678,1)
(6269,5911,1)
(4290,7852,1)
(2677,598,1)
(109,6563,1)
(8692,8612,1)
(8171,5332,1)
(2825,6889,1)
(5387,8333,1)
(2835,4928,1)
(7156,7962,1)
(3677,7012,1)
(6878,7149,1)
(4602,5695,1)
(6065,338,1)
(5280,6550,1)
(3128,3336,1)
(7501,1502,1)
(3602,1133,1)
(5278,1783,1)
(2589,1881,1)
(9018,2085,1)
(7432,4887,1)
(641,7004,1)
(2296,2792,1)
(3588,705,1)
(5234,2425,1)
(4313,7991,1)
(6150,2898,1)
(7592,485,1)
(8402,4928,1)
(2126,6729,1)
(2488,2573,1)
(8415,1650,1)
(218,6507,1)
(2891,3298,1)
(4491,1502,1)
(9121,8688,1)
(1497,3679,1)
(3795,5409,1)
(1636,3695,1)
(4658,4928,1)
(8787,3484,1)
(6036,8975,1)
(1546,3145,1)
(1420,5484,1)
(2311,1502,1)
(6114,893,1)
(1534,655,1)
(8194,258,1)
(1263,7636,1)
(370,1502,1)
(4650,3602,1)
(6053,4852,1)
(6170,5043,1)
(627,8902,1)
(8404,7133,1)
(8550,6273,1)
(2767,5902,1)
(830,4928,1)
(1092,2777,1)
(2735,7271,1)
(8287,8267,1)
(1259,7428,1)
(7521,46,1)
(4671,7179,1)
(6015,363,1)
(5839,2907,1)
(1477,2428,1)
(7758,7671,1)
(3691,1850,1)
(2239,9091,1)
(6673,2898,1)
(4085,7156,1)
(3397,4297,1)
(5574,5917,1)
(4247,1502,1)
(1608,1042,1)
(3433,1374,1)
(237,5043,1)
(3928,1942,1)
(4437,1591,1)
(3872,3533,1)
(2107,4345,1)
(1997,4819,1)
(553,3434,1)
(8276,59,1)
(6728,4928,1)
(2407,4675,1)
(2798,2142,1)
(2162,7356,1)
(4303,899,1)
(5095,1253,1)
(8799,826,1)
(1700,91,1)
(3728,6506,1)
(4045,1429,1)
(8017,4236,1)
(4197,1168,1)
(4612,171,1)
(5469,2179,1)
(2587,948,1)
(1821,8887,1)
(6383,5388,1)
(2903,8697,1)
(2725,5237,1)
(8878,7250,1)
(7398,7775,1)
(770,2473,1)
(8041,7404,1)
(4989,6158,1)
(4953,1502,1)
(8670,5302,1)
(6632,1782,1)
(1042,4928,1)
(3330,1502,1)
(3152,4928,1)
(1565,1062,1)
(3174,4785,1)
(4087,3817,1)
(3777,2225,1)
(8675,7663,1)
(1977,1806,1)
(2329,1077,1)
(4527,8610,1)
(911,717,1)
(1376,7728,1)
(2979,7949,1)
(4269,7424,1)
(304,3583,1)
(8952,2231,1)
(1239,9059,1)
(4484,8450,1)
(260,8388,1)
(6937,499,1)
(166,4928,1)
(3537,716,1)
(1650,6990,1)
(4437,7100,1)
(4384,9029,1)
(1250,3007,1)
(9128,1699,1)
(4683,641,1)
(3457,1502,1)
(7713,3181,1)
(2646,4399,1)
(7311,5043,1)
(3906,5394,1)
(3365,7332,1)
(7500,9111,1)
(4437,2204,1)
(5866,173,1)
(609,672,1)
(5701,7605,1)
(4034,7705,1)
(4139,7481,1)
(7262,7168,1)
(5907,7369,1)
(8646,8322,1)
(6674,6940,1)
(6819,3031,1)
(1454,6032,1)
(3720,3235,1)
(9131,3744,1)
(2735,6735,1)
(5775,1483,1)
(7008,5060,1)
(5955,5914,1)
(6430,2208,1)
(6441,1713,1)
(850,1849,1)
(8754,1711,1)
(72,6992,1)
(9116,1571,1)
(6493,4928,1)
(7117,4928,1)
(5631,1652,1)
(3654,7390,1)
(2683,7121,1)
(488,4666,1)
(1883,1734,1)
(7083,1366,1)
(4234,5117,1)
(7188,3080,1)
(1034,8422,1)
(6748,1502,1)
(8947,6751,1)
(5840,1088,1)
(1984,889,1)
(1444,8493,1)
(57,3181,1)
(8584,1502,1)
(4136,4151,1)
(8507,1024,1)
(8119,5016,1)
(5516,1916,1)
(1295,4786,1)
(4572,8678,1)
(5436,39,1)
(5915,8114,1)
(4578,732,1)
(1693,7943,1)
(7664,5632,1)
(4422,6993,1)
(3137,573,1)
(3397,8666,1)
(7046,3313,1)
(2146,5465,1)
(7842,8732,1)
(8859,5300,1)
(6060,8230,1)
(4729,3979,1)
(4906,2974,1)
(324,4163,1)
(5270,5151,1)
(1845,6018,1)
(6302,4928,1)
(4772,1871,1)
(4212,894,1)
(543,5529,1)
(1646,114,1)
(6486,4712,1)
(4796,3983,1)
(7566,3187,1)
(4141,3276,1)
(1446,4928,1)
(6129,3441,1)
(8823,957,1)
(7435,4928,1)
(2346,539,1)
(4513,3805,1)
(8148,5221,1)
(5286,5594,1)
(1423,573,1)
(3891,3052,1)
(8825,2496,1)
(6300,4822,1)
(2977,5503,1)
(1075,8575,1)
(8968,925,1)
(6640,6047,1)
(3069,1502,1)
(4101,7461,1)
(6590,5823,1)
(2616,4679,1)
(3302,6465,1)
(6866,7151,1)
(3423,5003,1)
(256,5247,1)
(6068,8070,1)
(6561,3676,1)
(1850,7565,1)
(2735,4249,1)
(3681,4928,1)
(7029,89,1)
(1009,5402,1)
(1925,2049,1)
(3599,4035,1)
(8260,1502,1)
(2016,1106,1)
(7757,7723,1)
(5632,159,1)
(2664,4928,1)
(95,6073,1)
(6264,3397,1)
(8094,4475,1)
(1792,2498,1)
(8120,4928,1)
(3421,8653,1)
(5057,1606,1)
(6774,6850,1)
(4648,701,1)
(6949,1502,1)
(8251,1502,1)
(4313,5294,1)
(1349,2934,1)
(4754,8635,1)
(8510,1603,1)
(1181,4491,1)
(5612,7431,1)
(6967,9129,1)
(253,4268,1)
(6304,908,1)
(8826,8914,1)
(1980,4422,1)
(2241,1502,1)
(1441,5266,1)
(6889,7297,1)
(151,4764,1)
(905,8560,1)
(435,4928,1)
(2335,4994,1)
(8192,1583,1)
(8214,4739,1)
(7137,7161,1)
(6946,1746,1)
(7590,5730,1)
(6792,7239,1)
(6610,8283,1)
(3437,6173,1)
(1777,1937,1)
(2736,1502,1)
(6375,1325,1)
(3862,5755,1)
(8636,2900,1)
(8147,6738,1)
(1602,3225,1)
(6932,881,1)
(387,3394,1)
(7874,2125,1)
(5319,8399,1)
(6304,6560,1)
(5733,1502,1)
(3287,4201,1)
(3319,1502,1)
(7188,259,1)
(5680,4928,1)
(8829,2113,1)
(3637,1234,1)
(8208,3941,2)
(553,2249,2)
(3196,1546,2)
(7011,4733,2)
(3612,8499,2)
(2929,6005,2)
(2312,847,2)
(6517,6431,2)
(8729,720,2)
(4655,5996,2)
(7303,4155,2)
(5233,3376,2)
(4109,3534,2)
(4193,991,2)
(6289,7619,2)
(7085,5025,2)
(6945,7004,2)
(27,5576,2)
(715,8362,2)
(4319,8032,2)
(1357,7826,2)
(3700,802,2)
(1131,212,2)
(812,9025,2)
(4654,1617,2)
(3411,8678,2)
(5327,1502,2)
(1092,3525,2)
(2441,6318,2)
(7566,6158,2)
(6636,4682,2)
(4710,7369,2)
(7390,7674,2)
(8667,250,2)
(5978,5939,2)
(367,2705,2)
(4269,2898,2)
(7256,1505,2)
(4378,5939,2)
(173,1168,2)
(1064,6404,2)
(5679,7985,2)
(3766,8362,2)
(720,6512,2)
(1683,2705,2)
(8458,1798,2)
(3730,6047,2)
(4725,5176,2)
(5569,7060,2)
(7526,5293,2)
(3051,8362,2)
(750,6404,2)
(7562,6323,2)
(5614,9116,2)
(2321,175,2)
(2920,4548,2)
(3399,5902,2)
(6974,4928,2)
(5143,1449,2)
(1116,1168,2)
(2359,1502,2)
(4975,4304,2)
(8834,2426,2)
(6577,6512,2)
(8570,2445,2)
(3181,2749,2)
(4471,478,2)
(3061,7900,2)
(3017,5728,2)
(7193,5525,2)
(7326,7202,2)
(4744,8516,2)
(3260,549,2)
(7995,4409,2)
(8580,533,2)
(7229,1502,2)
(1129,8425,2)
(1209,4725,2)
(5075,1502,2)
(8816,6334,2)
(4846,5559,2)
(8790,7826,2)
(5767,8499,2)
(7751,9091,2)
(5062,279,2)
(4442,6047,2)
(6248,7826,2)
(4253,5969,2)
(7985,7668,2)
(8827,118,2)
(1549,1502,2)
(695,6773,2)
(8056,9137,2)
(8966,8991,2)
(8119,5016,2)
(6900,2325,2)
(2968,6334,2)
(4254,5025,2)
(3499,8729,2)
(6665,3965,2)
(943,930,2)
(2555,4725,2)
(2084,4442,2)
(5920,6404,2)
(8171,466,2)
(1334,6047,2)
(6495,7159,2)
(5710,847,2)
(4703,5576,2)
(5356,4928,2)
(1299,5266,2)
(9037,5559,2)
(8542,175,2)
(5705,847,2)
(6264,3612,2)
(4545,4928,2)
(504,4551,2)
(8182,1321,2)
(6349,720,2)
(2860,7563,2)
(2419,8701,2)
(8829,6988,2)
(8344,8423,2)
(9145,4928,2)
(6203,4232,2)
(2453,3032,2)
(6863,5525,2)
(4587,3798,2)
(5319,6435,2)
(2587,948,2)
(7268,8362,2)
(3768,8310,2)
(772,418,2)
(6304,3313,2)
(551,8032,2)
(5646,3965,2)
(7403,2851,2)
(2548,1502,2)
(7693,3792,2)
(5694,8035,2)
(760,7442,2)
(6444,1617,2)
(1981,6479,2)
(7118,4765,2)
(7762,1502,2)
(7537,7826,2)
(526,8020,2)
(6481,6642,2)
(5929,4186,2)
(7442,6786,2)
(4759,5247,2)
(8912,8636,2)
(1260,6082,2)
(5294,8794,2)
(3301,3715,2)
(7868,4497,2)
(3412,75,2)
(3028,1502,2)
(1883,8499,2)
(7416,847,2)
(6945,8516,2)
(65,6606,2)
(5942,4277,2)
(3370,1502,2)
(3050,8362,2)
(4185,5403,2)
(7801,7062,2)
(1304,7359,2)
(7422,4928,2)
(6812,7826,2)
(5703,8799,2)
(3037,8362,2)
(7328,3095,2)
(2537,2605,2)
(5868,2347,2)
(7407,3965,2)
(6390,9145,2)
(642,9101,2)
(5712,4155,2)
(7629,1478,2)
(7139,6225,2)
(4835,16,2)
(2544,8362,2)
(2753,4928,2)
(8289,3350,2)
(1423,9091,2)
(7932,6195,2)
(435,6195,2)
(4687,189,2)
(3365,7985,2)
(6806,4196,2)
(6899,175,2)
(7498,8020,2)
(7393,7652,2)
(1631,1502,2)
(4834,533,2)
(4169,6343,2)
(8829,3313,2)
(2749,4289,2)
(324,4085,2)
(737,1883,2)
(2491,6047,2)
(451,2585,2)
(8539,1053,2)
(6126,343,2)
(6884,6958,2)
(3244,411,2)
(8171,4584,2)
(5261,5712,2)
(6729,5939,2)
(4712,2964,2)
(6879,554,2)
(2128,6047,2)
(3110,7160,2)
(6148,4928,2)
(6302,1502,2)
(3744,2445,2)
(8178,2898,2)
(8204,7160,2)
(2852,7875,2)
(6737,1050,2)
(354,7450,2)
(8450,5867,2)
(2727,701,2)
(1662,8362,2)
(6144,8362,2)
(5760,6562,2)
(4169,4928,2)
(197,6967,2)
(4972,2125,2)
(3670,2011,2)
(4890,1698,2)
(7500,8362,2)
(5709,4928,2)
(2844,8713,2)
(7248,3329,2)
(2869,8678,2)
(1469,1617,2)
(5665,805,2)
(438,8505,2)
(1748,5524,2)
(5568,5693,2)
(1034,8555,2)
(1170,1502,2)
(7190,5538,2)
(26,5025,2)
(332,5902,2)
(3781,5928,2)
(2039,6527,2)
(7151,3421,2)
(579,7924,2)
(3597,7826,2)
(5724,2585,2)
(4804,411,2)
(71,7941,2)
(2238,2445,2)
(2962,4548,2)
(5106,2347,2)
(7386,4928,2)
(4341,1556,2)
(682,8362,2)
(2189,7552,2)
(9055,6491,2)
(1255,2898,2)
(9128,4928,2)
(1444,2585,2)
(3868,6195,2)
(880,8576,2)
(8466,1518,2)
(7229,46,2)
(5954,266,2)
(1880,4497,2)
(2001,2943,2)
(607,5902,2)
(7043,6047,2)
(4967,3520,2)
(5694,2254,2)
(5226,3702,2)
(4640,1502,2)
(3987,6703,2)
(8037,976,2)
(8241,925,2)
(3652,8614,2)
(8408,4928,2)
(4134,2585,2)
(1507,7472,2)
(3529,1502,2)
(1321,6770,2)
(6685,4252,2)
(4354,7359,2)
(8892,5839,2)
(1930,5411,2)
(3421,8653,2)
(5646,9036,2)
(5544,1502,2)
(4106,3775,2)
(1366,666,2)
(6469,1546,2)
(2953,1515,2)
(6172,393,2)
(5294,3488,2)
(4809,3963,2)
(5966,5525,2)
(3211,4928,2)
(1056,4765,2)
(936,6691,2)
(5317,2249,2)
(2608,7826,2)
(3676,2394,2)
(7670,4246,2)
(6288,91,2)
(4477,6431,2)
(1343,3798,2)
(8229,8362,2)
(1155,5116,2)
(4826,1887,2)
(7621,1103,2)
(2322,7486,2)
(8613,8991,2)
(7815,5939,2)
(1825,4928,2)
(1977,3049,2)
(719,9091,2)
(2842,2994,2)
(4634,8499,2)
(4279,8282,2)
(2708,5466,2)
(7447,5807,2)
(2606,3965,2)
(3136,697,2)
(849,8991,2)
(2050,7959,2)
(3388,4569,2)
(6433,2057,2)
(9026,5559,2)
(6515,4928,2)
(3236,1659,2)
(703,1248,2)
(7523,7826,2)
(6254,936,2)
(898,6703,2)
(3500,5712,2)
(7622,2464,2)
(5992,1809,2)
(2906,8362,2)
(2529,6236,2)
(866,3252,2)
(8972,6404,2)
(5627,2038,2)
(3199,3872,2)
(8757,2898,2)
(4402,680,2)
(5410,533,2)
(2627,2478,2)
(8548,169,2)
(7160,5922,2)
(5535,8799,2)
(9012,4019,2)
(6378,7397,2)
(3985,6090,2)
(4834,9130,2)
(6348,1502,2)
(9085,4928,2)
(6839,2125,2)
(8502,3963,2)
(7335,4969,2)
(7016,1502,2)
(4886,250,2)
(825,4843,2)
(4538,2125,2)
(1005,3937,2)
(5617,4995,2)
(3805,3021,2)
(5413,403,2)
(3202,1390,2)
(2869,7160,2)
(1226,5300,2)
(1863,8902,2)
(2843,1502,2)
(9114,4912,2)
(1932,1617,2)
(6743,6773,2)
(8363,697,2)
(2798,169,2)
(9089,3448,2)
(2144,7849,2)
(2013,4928,2)
(1734,8499,2)
(6133,4934,2)
(5040,6512,2)
(7946,6128,2)
(8916,720,2)
(9019,1502,2)
(6935,2851,2)
(8241,3965,2)
(918,7000,2)
(8682,720,2)
(5390,6959,2)
(7333,8079,2)
(1713,3900,2)
(2080,1627,2)
(1306,5025,2)
(5241,8466,2)
(612,5969,2)
(1062,8425,2)
(1790,8276,2)
(7046,8188,2)
(2622,8020,2)
(5573,3391,2)
(4501,7849,2)
(5932,5525,2)
(3630,1789,2)
(4729,2057,2)
(8725,3190,2)
(2492,5043,2)
(3500,1502,2)
(4392,3963,2)
(3933,1761,2)
(3711,8425,2)
(6465,8516,2)
(8494,1502,2)
(7533,2555,2)
(4265,2696,2)
(287,2125,2)
(5988,4928,2)
(7383,6985,2)
(9055,5902,2)
(2736,3259,2)
(8800,7985,2)
(6240,3527,2)
(3638,8362,2)
(4418,3715,2)
(4272,6410,2)
(2344,6642,2)
(4123,3798,2)
(6881,7826,2)
(5380,1617,2)
(311,1249,2)
(7270,8516,2)
(6277,1502,2)
(2284,8527,2)
(486,2125,2)
(9063,4409,2)
(9148,1502,2)
(3014,2180,2)
(5774,3504,2)
(5756,3636,2)
(3339,5351,2)
(313,8833,2)
(3814,4022,2)
(3942,7438,2)
(3341,6932,2)
(9025,3570,2)
(5189,1516,2)
(4360,6186,2)
(3550,4928,2)
(4301,847,2)
(3327,1502,2)
(6706,5043,2)
(1619,4191,2)
(6053,3527,2)
(6670,8991,2)
(1730,3421,2)
(3844,8825,2)
(851,7826,2)
(4065,4928,2)
(712,2113,2)
(3879,3032,2)
(2127,2705,2)
(8574,1502,2)
(7725,7004,2)
(4437,7100,2)
(2314,832,2)
(7991,1128,2)
(6002,2533,2)
(5426,8032,2)
(7890,2032,2)
(6222,1274,2)
(4868,6334,2)
(8305,7060,2)
(7991,6560,2)
(5366,720,2)
(1519,8271,2)
(3357,2404,2)
(8812,7826,2)
(7493,5807,2)
(3111,8362,2)
(8333,7849,2)
(8438,6133,2)
(998,2384,2)
(4235,3965,2)
(3009,243,2)
(6105,5043,2)
(9072,3965,2)
(8754,1085,2)
(8149,8855,2)
(7517,4085,2)
(1111,4928,2)
(644,720,2)
(2632,697,2)
(45,3233,2)
(7596,1334,2)
(7618,1502,2)
(3562,847,2)
(1500,8499,2)
(7335,5025,2)
(3918,533,2)
(325,169,2)
(5389,539,2)
(4874,1502,2)
(3239,4928,2)
(3354,5939,2)
(310,4928,2)
(1228,5445,2)
(5298,832,2)
(4783,8505,2)
(8492,5839,2)
(4350,5328,2)
(7937,4928,2)
(2705,6056,2)
(6391,1003,2)
(7050,6512,2)
(8854,131,2)
(8144,4304,2)
(4222,5902,2)
(42,5524,2)
(8963,6512,2)
(2812,2077,2)
(7047,2088,2)
(9091,6952,2)
(5735,4721,2)
(5077,1502,2)
(3662,3965,2)
(6938,7768,2)
(1915,4176,2)
(8027,4829,2)
(8560,46,2)
(7900,4085,2)
(7364,3575,2)
(192,6195,2)
(3814,3989,2)
(1477,3965,2)
(5657,2032,2)
(847,805,2)
(6392,1711,2)
(8861,4634,2)
(1528,7725,2)
(8392,4928,2)
(1812,5300,2)
(6687,8362,2)
(1024,720,2)
(4600,720,2)
(6367,8083,2)
(1240,5397,2)
(4981,3963,2)
(4403,3448,2)
(8253,398,2)
(9029,5576,2)
(2705,941,2)
(2779,1873,2)
(9142,4928,2)
(1823,1502,2)
(1547,8991,2)
(1388,4085,2)
(4831,1498,2)
(2391,7666,2)
(6235,8362,2)
(5473,175,2)
(4888,3317,2)
(7991,4551,2)
(6767,1734,2)
(7417,805,2)
(7974,8566,2)
(1005,1626,2)
(7533,4772,2)
(5016,7369,2)
(100,8362,2)
(411,8159,2)
(5503,2347,2)
(5025,5862,2)
(7831,1832,2)
(8416,5693,2)
(4259,3153,2)
(3323,847,2)
(7569,936,2)
(7422,6958,2)
(5582,7674,2)
(1931,7826,2)
(1651,5059,2)
(2272,3775,2)
(3698,3217,2)
(7164,3570,2)
(7733,5025,2)
(8810,5943,2)
(5054,6032,2)
(3212,764,2)
(8849,6071,2)
(7077,598,2)
(5294,6988,2)
(8176,8362,2)
(4437,7137,2)
(8385,3872,2)
(2370,411,2)
(5258,6047,2)
(6133,845,2)
(1977,6958,2)
(4329,9091,2)
(3623,5218,2)
(8991,3511,2)
(5548,788,2)
(3659,5969,2)
(7046,3313,2)
(6706,5821,2)
(6102,4928,2)
(4313,2677,2)
(3721,1515,2)
(3126,2708,2)
(3238,8975,2)
(986,6404,2)
(6373,7826,2)
(6640,5576,2)
(7468,8188,2)
(939,4019,2)
(2406,317,2)
(7913,7687,2)
(6874,7118,2)
(2610,720,2)
(8007,8247,2)
(6271,3965,2)
(4933,4509,2)
(305,1502,2)
(216,4647,2)
(321,2107,2)
(8698,1502,2)
(717,539,2)
(9050,240,2)
(195,1306,2)
(1784,8362,2)
(5971,2441,2)
(3495,847,2)
(8910,3811,2)
(8339,4085,2)
(8132,8447,2)
(8233,2112,2)
(1921,4928,2)
(2999,2898,2)
(6478,3049,2)
(4011,5904,2)
(5467,362,2)
(3125,5867,2)
(4838,5037,2)
(5774,2666,2)
(3819,7468,2)
(8262,533,2)
(1166,9142,2)
(6376,1898,2)
(3972,8278,2)
(1975,5560,2)
(6454,2301,2)
(2140,8799,2)
(464,2898,2)
(3111,44,2)
(3892,6404,2)
(1246,1842,2)
(7553,8362,2)
(5294,2641,2)
(1963,8362,2)
(1968,8425,2)
(7759,2347,2)
(4265,7552,2)
(7432,2585,2)
(3648,7625,2)
(8247,6048,2)
(6939,1502,2)
(6323,279,2)
(680,6866,2)
(8721,3049,2)
(7521,1191,2)
(3343,4928,2)
(6071,6951,2)
(4415,8255,2)
(7709,3383,2)
(6342,243,2)
(5241,1762,2)
(247,1582,2)
(4405,3032,2)
(6243,5939,2)
(1084,3472,2)
(1996,6108,2)
(5075,7468,2)
(5127,720,2)
(5434,2032,2)
(1534,7042,2)
(9071,4443,2)
(3303,9027,2)
(2350,5524,2)
(2128,1502,2)
(1125,8499,2)
(6950,8362,2)
(62,1679,2)
(1548,7462,2)
(5310,3965,2)
(342,1304,2)
(7352,6648,2)
(8575,1955,2)
(1923,8576,2)
(8033,3758,2)
(2340,5091,2)
(3532,847,2)
(1487,1642,2)
(6892,2555,2)
(1248,6958,2)
(3424,9101,2)
(152,8833,2)
(1528,5024,2)
(2152,1502,2)
(2016,2394,2)
(8931,3448,2)
(4518,5086,2)
(8691,1502,2)
(34,550,2)
(8289,4928,2)
(8929,5744,2)
(9031,1502,2)
(4371,4085,2)
(7349,6855,2)
(6304,5914,2)
(4579,4595,2)
(5030,5618,2)
(3156,8799,2)
(6044,4682,2)
(985,8833,2)
(2924,8516,2)
(334,7502,2)
(777,4176,2)
(6842,3457,2)
(679,7023,2)
(5120,7826,2)
(1952,4397,2)
(4884,4007,2)
(8765,3699,2)
(2172,8519,2)
(2241,1502,2)
(821,7674,2)
(8789,317,2)
(1951,1202,2)
(8440,5415,2)
(5294,6930,2)
(3443,6404,2)
(3447,7985,2)
(3667,2057,2)
(1698,1502,2)
(5409,8047,2)
(2620,5939,2)
(3430,4928,2)
(2563,6692,2)
(1568,5939,2)
(1537,8362,2)
(428,8362,2)
(4970,1635,2)
(6343,3372,2)
(3302,1591,2)
(2265,3421,2)
(2062,6758,2)
(338,6648,2)
(8699,7438,2)
(3131,2598,2)
(4945,882,2)
(8555,1884,2)
(2656,4623,2)
(3064,1617,2)
(1442,7496,2)
(3791,4928,2)
(3906,4928,2)
(1622,5024,2)
(830,4928,2)
(7573,7826,2)
(7162,6648,2)
(1028,1502,2)
(6255,2032,2)
(4249,411,2)
(7614,7666,2)
(3501,8499,2)
(5553,2469,2)
(7393,7359,2)
(6270,1,2)
(4997,6510,2)
(7327,3917,2)
(7690,6323,2)
(1324,7438,2)
(5077,1515,2)
(3159,4928,2)
(1647,6048,2)
(6792,1154,2)
(2952,8891,2)
(1548,4085,2)
(1818,8566,2)
(1822,1168,2)
(3968,7619,2)
(572,8079,2)
(5085,7004,2)
(1359,6195,2)
(5797,3114,2)
(2773,1120,2)
(6817,6562,2)
(1693,7943,2)
(1778,1321,2)
(5671,6318,2)
(1891,3969,2)
(3470,2814,2)
(4448,6047,2)
(5735,4125,2)
(7560,5461,2)
(2642,5928,2)
(8381,4647,2)
(4001,2760,2)
(2205,5608,2)
(5141,1502,2)
(2420,5939,2)
(1830,3965,2)
(3591,8545,2)
(507,5969,2)
(4475,4857,2)
(1029,8008,2)
(9054,1383,2)
(6508,2998,2)
(8918,2546,2)
(398,8362,2)
(8324,8362,2)
(2946,266,2)
(6939,4928,2)
(7447,6431,2)
(3876,5486,2)
(6413,1946,2)
(3612,8811,2)
(6613,4673,2)
(4494,4928,2)
(9016,7937,2)
(7186,6377,2)
(5820,419,2)
(4327,8799,2)
(1685,4995,2)
(5770,5969,2)
(8382,3126,2)
(3482,3570,2)
(2712,7941,2)
(2127,1924,2)
(2245,7517,2)
(4437,2113,2)
(375,7666,2)
(8513,7619,2)
(2852,6018,2)
(4836,6367,2)
(7612,2112,2)
(7326,3645,2)
(5125,2394,2)
(4612,5655,2)
(8717,2032,2)
(7240,8362,2)
(6009,4494,2)
(4227,7207,2)
(7224,7941,2)
(7605,4928,2)
(7602,4680,2)
(2715,1502,2)
(1158,4928,2)
(9033,4928,2)
(4490,4928,2)
(4709,5922,2)
(8437,2074,2)
(918,6297,2)
(686,2032,2)
(6249,3171,2)
(7662,1731,2)
(5979,2057,2)
(3303,7207,2)
(2381,5867,2)
(5451,4232,2)
(6158,8585,2)
(6871,5922,2)
(4429,5025,2)
(6721,4956,2)
(5693,7150,2)
(2358,2882,2)
(3410,4928,2)
(4436,1682,2)
(4385,8020,2)
(2972,3928,2)
(1972,4193,2)
(3478,802,2)
(5859,7390,2)
(3718,539,2)
(4695,411,2)
(4659,6264,2)
(4036,8537,2)
(1289,2440,2)
(6140,4878,2)
(7926,8362,2)
(9038,4196,2)
(5963,5371,2)
(7265,1502,2)
(5456,3263,2)
(1635,2537,2)
(6994,39,2)
(209,6047,2)
(3340,4932,2)
(5145,1111,2)
(884,2483,2)
(796,4085,2)
(6696,4445,2)
(7817,1617,2)
(17,5392,2)
(2698,6546,2)
(5744,3241,2)
(7077,4551,2)
(8797,5207,2)
(4928,1246,2)
(8866,1404,2)
(3252,3340,2)
(794,3049,2)
(3527,7628,2)
(3829,279,2)
(9015,720,2)
(5211,1892,2)
(3063,6998,2)
(1022,8362,2)
(9069,952,2)
(4590,3583,2)
(1220,1800,2)
(8615,5091,2)
(1407,4878,2)
(5118,4928,2)
(7563,4928,2)
(846,8423,2)
(8858,5043,2)
(7822,6730,2)
(1486,5744,2)
(7763,7624,2)
(8034,7060,2)
(5498,8425,2)
(2477,385,2)
(2033,7610,2)
(7947,2709,2)
(8061,6648,2)
(8913,8282,2)
(8283,131,2)
(5035,8486,2)
(2034,7369,2)
(7530,8032,2)
(2950,254,2)
(6562,7338,2)
(3676,4631,2)
(6398,2572,2)
(4775,8043,2)
(4437,5115,2)
(6632,6128,2)
(5198,3472,2)
(1879,7446,2)
(4856,5091,2)
(3502,5056,2)
(8641,2057,2)
(4821,6967,2)
(5269,7371,2)
(7685,4928,2)
(967,284,2)
(8369,1168,2)
(6217,8362,2)
(712,5115,2)
(1974,3511,2)
(2970,3872,2)
(2899,4814,2)
(584,7202,2)
(8394,9101,2)
(4334,4934,2)
(6284,39,2)
(1010,7666,2)
(7529,1502,2)
(4771,8362,2)
(7783,6048,2)
(448,250,2)
(5154,2782,2)
(8336,1502,2)
(3308,4022,2)
(8442,2538,2)
(246,7546,2)
(304,1502,2)
(4243,1958,2)
(1287,1761,2)
(7016,2180,2)
(8310,119,2)
(4701,6048,2)
(5294,6981,2)
(1661,5024,2)
(390,8948,2)
(1572,1168,2)
(5286,5594,2)
(2002,2394,2)
(5934,5774,2)
(3123,1439,2)
(2900,4682,2)
(609,8311,2)
(1631,4928,2)
(578,847,2)
(1988,598,2)
(5538,8425,2)
(2303,3382,2)
(5526,7985,2)
(7991,8188,2)
(3554,7666,2)
(4798,7207,2)
(6494,393,2)
(4297,8748,2)
(7186,4085,2)
(4777,6334,2)
(2148,6703,2)
(1556,9081,2)
(5270,5151,2)
(8758,550,2)
(2626,3329,2)
(7957,4176,2)
(5821,8811,2)
(6592,8566,2)
(4966,2783,2)
(5307,7985,2)
(9098,1168,2)
(5838,4579,2)
(6658,8247,2)
(8799,826,2)
(4738,4928,2)
(3055,2440,2)
(6054,805,2)
(3234,2483,2)
(2630,343,2)
(6857,1231,2)
(8519,5902,2)
(8101,6236,2)
(9089,5137,2)
(1849,8701,2)
(4679,2546,2)
(8157,4224,2)
(5993,3008,2)
(3244,8159,2)
(637,3989,2)
(4332,6047,2)
(1530,6047,2)
(4988,7513,2)
(106,7619,2)
(4814,1502,2)
(3681,4928,2)
(3217,2178,2)
(6049,9101,2)
(1469,4525,2)
(5255,4928,2)
(3060,260,2)
(9049,7919,2)
(450,418,2)
(5294,2367,2)
(4489,8830,2)
(4739,2708,2)
(5711,6048,2)
(5176,7666,2)
(5996,8276,2)
(2210,6899,2)
(5531,3221,2)
(2925,1502,2)
(6304,4638,2)
(1506,8362,2)
(8712,8362,2)
(4616,550,2)
(6244,8748,2)
(938,8799,2)
(9062,4744,2)
(331,4019,2)
(1298,7619,2)
(516,3350,2)
(96,3937,2)
(876,2507,2)
(5279,7826,2)
(6397,3448,2)
(8290,8362,2)
(5282,4598,2)
(6451,2708,2)
(4320,5576,2)
(2115,3448,2)
(7737,3350,2)
(4846,1489,2)
(8889,936,2)
(1606,7826,2)
(6047,59,2)
(4936,3963,2)
(8425,5300,2)
(8335,1502,2)
(1008,1306,2)
(485,802,2)
(1425,1009,2)
(7559,6718,2)
(1142,8910,2)
(8585,3715,2)
(7172,4196,2)
(8923,8875,2)
(2498,8825,2)
(1321,3433,2)
(6283,5807,2)
(3040,65,2)
(1206,2091,2)
(4851,7826,2)
(7891,7513,2)
(5601,7552,2)
(5610,6124,2)
(1043,8020,2)
(150,2389,2)
(6239,2709,2)
(9037,3465,2)
(3529,6047,2)
(8747,847,2)
(6731,1495,2)
(2875,5867,2)
(2937,4928,2)
(4761,8499,2)
(7160,8247,2)
(5757,5320,2)
(3529,4928,2)
(5929,159,2)
(4545,8159,2)
(6777,8362,2)
(2117,398,2)
(5496,8671,2)
(6418,6,2)
(4937,7941,2)
(2376,7552,2)
(3085,7619,2)
(8944,1502,2)
(1037,6404,2)
(609,7666,2)
(994,991,2)
(8595,7202,2)
(2865,8701,2)
(417,1889,2)
(2461,5487,2)
(2294,7004,2)
(5802,3421,2)
(1690,1502,2)
(6851,5300,2)
(6940,8361,2)
(3251,1880,2)
(4022,3900,2)
(2214,805,2)
(6768,2394,2)
(6120,2460,2)
(3216,5371,2)
(7032,8499,2)
(4673,8074,2)
(4733,4552,2)
(7676,7369,2)
(1316,2585,2)
(8512,6550,2)
(5359,6047,2)
(712,1128,2)
(2768,7666,2)
(1217,7905,2)
(9119,6773,2)
(5824,2585,2)
(4607,8701,2)
(8100,4979,2)
(2898,4650,2)
(4926,7666,2)
(4602,997,2)
(8123,8620,2)
(2722,8991,2)
(6165,1157,2)
(199,8362,2)
(805,2032,2)
(3344,603,2)
(3285,8991,2)
(999,2546,2)
(412,635,2)
(1560,8425,2)
(3302,2894,2)
(4025,7014,2)
(5075,3530,2)
(4293,4928,2)
(8510,5268,2)
(1237,1193,2)
(435,1502,2)
(1654,243,2)
(1375,4765,2)
(8452,291,2)
(3348,6225,2)
(4202,805,2)
(5365,8032,2)
(9123,6512,2)
(2301,4928,2)
(9133,1053,2)
(2651,3472,2)
(2243,1502,2)
(6716,2585,2)
(6075,2776,2)
(6790,5730,2)
(7867,4443,2)
(602,2180,2)
(3277,4443,2)
(1671,7826,2)
(3683,7666,2)
(3208,1321,2)
(396,3965,2)
(9103,8362,2)
(1001,5867,2)
(2951,1502,2)
(5728,6703,2)
(5183,6673,2)
(838,8494,2)
(7551,3715,2)
(6097,5025,2)
(6622,7826,2)
(5416,5950,2)
(347,7179,2)
(597,1502,2)
(7011,720,2)
(1395,832,2)
(5057,7826,2)
(6304,7033,2)
(7458,8362,2)
(9104,9011,2)
(3464,6718,2)
(1330,701,2)
(7380,6773,2)
(2558,2994,2)
(1510,554,2)
(8968,3965,2)
(2660,6404,2)
(5967,2057,2)
(4894,8362,2)
(8038,720,2)
(3793,4928,2)
(9126,6034,2)
(3257,7826,2)
(8885,7450,2)
(2826,539,2)
(7750,4928,2)
(320,7937,2)
(2448,8362,2)
(991,8957,2)
(468,2471,2)
(1917,1617,2)
(1102,3989,2)
(8483,8425,2)
(2997,1798,2)
(4770,3527,2)
(6999,847,2)
(7653,4934,2)
(5588,7826,2)
(6454,8362,2)
(699,1924,2)
(1040,943,2)
(7901,175,2)
(6885,4934,2)
(7882,3340,2)
(6708,1916,2)
(4535,385,2)
(7744,6208,2)
(674,3350,2)
(1508,3844,2)
(2611,1846,2)
(4313,9037,2)
(2235,1267,2)
(6246,812,2)
(4472,1591,2)
(4184,6642,2)
(4801,701,2)
(5101,549,2)
(1440,2567,2)
(4437,742,2)
(9127,2440,2)
(1738,4928,2)
(5036,1502,2)
(1251,6960,2)
(726,8032,2)
(4047,3636,2)
(6541,8466,2)
(1821,8887,2)
(7056,1687,2)
(8419,6058,2)
(5890,4934,2)
(8114,169,2)
(3833,8362,2)
(2969,4928,2)
(6965,7369,2)
(3426,4304,2)
(3250,1502,2)
(317,4647,2)
(1456,7160,2)
(75,7413,2)
(4809,6047,2)
(428,1494,2)
(3028,2964,2)
(5202,4810,2)
(7637,2498,2)
(7163,1267,2)
(3560,385,2)
(280,6404,2)
(7542,1617,2)
(2590,3937,2)
(5485,2125,2)
(4472,3049,2)
(3855,1502,2)
(64,1216,2)
(4675,4018,2)
(211,3633,2)
(7991,7092,2)
(8490,2469,2)
(250,6532,2)
(592,250,2)
(9026,7100,2)
(7704,2394,2)
(118,393,2)
(3900,1946,2)
(2786,1193,2)
(2977,2347,2)
(3885,1116,2)
(4074,46,2)
(5900,5218,2)
(6302,6058,2)
(5638,6124,2)
(4754,8635,2)
(4594,6562,2)
(3313,4878,2)
(4415,1809,2)
(835,2708,2)
(8693,8748,2)
(2613,8425,2)
(441,8425,2)
(7086,7647,2)
(6978,8466,2)
(8603,8032,2)
(7122,3963,2)
(6367,8079,2)
(3462,4961,2)
(5109,2863,2)
(2851,135,2)
(2041,6912,2)
(8518,2445,2)
(2331,7571,2)
(7046,598,2)
(5904,4392,2)
(3365,4928,2)
(6745,720,2)
(4979,8362,2)
(1411,166,2)
(2211,3421,2)
(7430,2394,2)
(6778,5100,2)
(8593,6209,2)
(8073,6810,2)
(2890,3636,2)
(7177,1003,2)
(9039,8362,2)
(6939,7826,2)
(6285,6047,2)
(446,7359,2)
(4474,5950,2)
(2047,3350,2)
(6304,677,2)
(3607,3417,2)
(9145,6047,2)
(4790,8633,2)
(7928,5902,2)
(8706,2469,2)
(4833,3382,2)
(3272,2180,2)
(1926,2585,2)
(3193,2851,2)
(2874,9073,2)
(119,5693,2)
(7468,7092,2)
(5615,8362,2)
(311,1898,2)
(1471,1306,2)
(5939,1617,2)
(3210,9025,2)
(4847,3346,2)
(8095,8362,2)
(4808,3219,2)
(5371,8868,2)
(1654,5202,2)
(3272,4019,2)
(4740,4928,2)
(406,7736,2)
(807,1168,2)
(8197,5025,2)
(7768,6048,2)
(7103,212,2)
(1837,1502,2)
(2100,6431,2)
(1438,5902,2)
(6191,218,2)
(7915,3049,2)
(7661,6401,2)
(5591,7941,2)
(8872,5992,2)
(1119,250,2)
(1605,5608,2)
(3445,3965,2)
(2535,3282,2)
(4824,124,2)
(2840,418,2)
(1392,1502,2)
(484,8278,2)
(6899,5082,2)
(253,2994,2)
(322,3965,2)
(1248,3049,2)
(1152,4892,2)
(5682,6195,2)
(2453,924,2)
(175,2057,2)
(6521,2180,2)
(1651,6887,2)
(9085,2125,2)
(3858,5576,2)
(7922,8148,2)
(511,3872,2)
(2684,9018,2)
(2738,6186,2)
(4510,5025,2)
(5577,7619,2)
(7927,4541,2)
(2043,8032,2)
(1342,8294,2)
(4144,1506,2)
(3684,5525,2)
(7367,8271,2)
(2738,8944,2)
(1204,8566,2)
(6751,4471,2)
(6289,8513,2)
(7521,6179,2)
(5973,1812,2)
(5243,4485,2)
(2269,3992,2)
(7457,1761,2)
(4278,1502,2)
(2421,6512,2)
(4707,3636,2)
(907,6642,2)
(1363,243,2)
(4251,7506,2)
(3377,6158,2)
(9154,847,2)
(8075,9091,2)
(1767,2708,2)
(6620,1502,2)
(5277,7202,2)
(2465,3350,2)
(7946,1232,2)
(7991,2893,2)
(3775,6592,2)
(9037,6853,2)
(975,3350,2)
(5894,3702,2)
(8800,3721,2)
(5236,533,2)
(6907,9025,2)
(6718,2645,2)
(7265,8362,2)
(7491,805,2)
(7374,8362,2)
(8140,4928,2)
(7661,533,2)
(0,4778,2)
(8587,8423,2)
(1892,1515,2)
(8190,5712,2)
(4072,6550,2)
(984,4299,2)
(733,8362,2)
(8686,8032,2)
(6912,4928,2)
(1219,4196,2)
(6129,4634,2)
(3843,6730,2)
(8338,6550,2)
(7308,8302,2)
(5871,5802,2)
(2097,6160,2)
(2817,5735,2)
(4431,1798,2)
(4031,6318,2)
(3753,4928,2)
(4200,1502,2)
(877,4928,2)
(2479,847,2)
(9106,8362,2)
(4313,455,2)
(4473,131,2)
(2288,212,2)
(6368,1191,2)
(2841,2394,2)
(6182,598,2)
(7046,1128,2)
(6504,5992,2)
(646,284,2)
(6152,5969,2)
(5922,8966,2)
(2771,2440,2)
(6225,1267,2)
(514,8576,2)
(2726,3965,2)
(3022,7826,2)
(123,847,2)
(8252,8487,2)
(3331,5712,2)
(1789,1502,2)
(941,7594,2)
(2387,124,2)
(5021,2325,2)
(739,847,2)
(1804,1256,2)
(5285,6718,2)
(263,8724,2)
(2055,6047,2)
(4139,573,2)
(6492,1506,2)
(7305,3798,2)
(4822,5969,2)
(862,4232,2)
(6736,4928,2)
(8297,4022,2)
(442,7388,2)
(2152,8362,2)
(1811,6745,2)
(6509,7179,2)
(337,6186,2)
(6186,398,2)
(2678,2125,2)
(2320,5115,2)
(5162,7369,2)
(8596,6571,2)
(7937,6158,2)
(1132,4928,2)
(5079,343,2)
(2708,8032,2)
(4517,7179,2)
(307,6938,2)
(4974,3390,2)
(3153,4928,2)
(4809,4928,2)
(2118,7826,2)
(8423,8362,2)
(4554,7393,2)
(1218,4928,2)
(3233,6958,2)
(4355,2325,2)
(4543,2394,2)
(4095,2589,2)
(5936,6195,2)
(878,3537,2)
(8283,7067,2)
(6795,6642,2)
(46,1168,2)
(7269,5730,2)
(90,4738,2)
(3838,4928,2)
(1185,4928,2)
(8230,5965,2)
(6728,847,2)
(1201,1635,2)
(6537,4878,2)
(2734,7778,2)
(3905,2163,2)
(491,1132,2)
(6938,334,2)
(8985,3702,2)
(951,7060,2)
(5203,898,2)
(7076,4928,2)
(456,6718,2)
(4532,4204,2)
(8107,697,2)
(7522,3049,2)
(515,5969,2)
(1882,393,2)
(8814,5867,2)
(6899,1505,2)
(8102,4196,2)
(6886,550,2)
(7888,317,2)
(8720,4196,2)
(7067,131,2)
(4581,1794,2)
(6915,3786,2)
(1421,8566,2)
(5895,7309,2)
(5747,1685,2)
(8067,8415,2)
(3811,1859,2)
(3040,720,2)
(1530,1682,2)
(8960,6323,2)
(672,2555,2)
(5141,8362,2)
(7521,4220,2)
(8035,3924,2)
(4179,4232,2)
(3809,3636,2)
(6392,5902,2)
(4228,7985,2)
(4725,7666,2)
(4437,4986,2)
(5690,1193,2)
(1274,3793,2)
(3246,1321,2)
(4294,1617,2)
(6891,3963,2)
(7705,5300,2)
(3483,6435,2)
(2330,6580,2)
(1441,2801,2)
(5560,4928,2)
(1462,3636,2)
(1381,805,2)
(8247,7900,2)
(6225,7457,2)
(4076,4744,2)
(5119,9101,2)
(7528,4443,2)
(3203,4647,2)
(4175,466,2)
(3591,5574,2)
(7391,1635,2)
(4257,5939,2)
(7539,7826,2)
(114,5969,2)
(3086,4085,2)
(5642,6074,2)
(3535,2663,2)
(8318,8362,2)
(4589,6160,2)
(945,8799,2)
(6222,8701,2)
(3275,7515,2)
(5457,2748,2)
(313,8092,2)
(1676,1635,2)
(9037,4373,2)
(37,5024,2)
(4323,1306,2)
(4519,5928,2)
(7342,6561,2)
(4163,7056,2)
(9031,4928,2)
(8367,3715,2)
(838,4950,2)
(6856,7666,2)
(4726,8362,2)
(4663,8362,2)
(7829,6318,2)
(5896,7202,2)
(7592,802,2)
(7664,3527,2)
(177,5037,2)
(4444,8425,2)
(3002,7309,2)
(6256,3340,2)
(2119,2124,2)
(4472,598,2)
(5016,2898,2)
(7119,5783,2)
(5358,7194,2)
(7150,7552,2)
(3730,1502,2)
(1004,7202,2)
(837,7768,2)
(1045,6323,2)
(4921,7937,2)
(3069,4928,2)
(4131,1502,2)
(8535,3527,2)
(353,5576,2)
(5941,8242,2)
(3838,1502,2)
(3832,4193,2)
(9037,2893,2)
(5462,5024,2)
(2355,2758,2)
(4536,5608,2)
(5456,8223,2)
(7428,3790,2)
(6518,8975,2)
(5472,6620,2)
(7962,2961,2)
(2771,2686,2)
(4572,5115,2)
(4512,7143,2)
(4258,8356,2)
(6616,4932,2)
(1749,2705,2)
(5372,2609,2)
(6780,6642,2)
(2334,2128,2)
(4817,4541,2)
(450,1502,2)
(2822,3937,2)
(2869,6560,2)
(8649,7826,2)
(5917,2708,2)
(5861,5036,2)
(4624,7900,2)
(2485,6512,2)
(2568,4928,2)
(7362,7450,2)
(630,4914,2)
(8782,8362,2)
(1310,2445,2)
(9037,3313,2)
(3322,5969,2)
(2440,7666,2)
(4562,3965,2)
(1904,1502,2)
(5658,7359,2)
(7737,6213,2)
(3591,7821,2)
(4288,3912,2)
(735,2249,2)
(1986,8466,2)
(4347,4928,2)
(2405,3393,2)
(5258,1502,2)
(7737,8962,2)
(5921,8362,2)
(5584,2445,2)
(1866,1918,2)
(6602,3570,2)
(3302,4986,2)
(6648,8362,2)
(2753,1502,2)
(9071,1502,2)
(8829,8037,2)
(8457,2546,2)
(2019,6938,2)
(4373,2554,2)
(7763,539,2)
(1981,2642,2)
(8008,3720,2)
(6304,9075,2)
(4763,2621,2)
(4912,1502,2)
(4961,8064,2)
(326,3727,2)
(5294,8757,2)
(5718,1502,2)
(3182,9025,2)
(2568,8576,2)
(2510,4232,2)
(3583,6027,2)
(4682,2445,2)
(979,4001,2)
(8486,2242,2)
(6318,5538,2)
(2899,6236,2)
(3591,2322,2)
(8170,8576,2)
(383,3125,2)
(4679,8481,2)
(618,1515,2)
(2553,6264,2)
(4682,2758,2)
(3365,1502,2)
(959,6561,2)
(6208,4131,2)
(6188,7666,2)
(5310,4928,2)
(8541,3549,2)
(8551,8809,2)
(7568,5025,2)
(130,3798,2)
(1043,4928,2)
(2218,5445,2)
(222,3350,2)
(5121,8362,2)
(209,4928,2)
(1491,5576,2)
(772,4928,2)
(5105,7826,2)
(1392,4928,2)
(4561,5025,2)
(786,6998,2)
(4992,2708,2)
(1123,1502,2)
(2587,4920,2)
(2973,806,2)
(5294,2113,2)
(8117,1502,2)
(2197,1449,2)
(5971,5258,2)
(7366,8362,2)
(8145,8500,2)
(6090,8811,2)
(702,4730,2)
(8271,3526,2)
(2804,6404,2)
(5324,2609,2)
(2361,2125,2)
(5761,7388,2)
(5886,7389,2)
(5734,8590,2)
(2589,8362,2)
(6533,1589,2)
(135,6431,2)
(8829,3496,2)
(5000,8032,2)
(3393,5859,2)
(7562,7937,2)
(4509,4878,2)
(4996,1502,2)
(3911,693,2)
(2455,8362,2)
(8858,6173,2)
(1263,8991,2)
(6739,7206,2)
(9025,8027,2)
(5255,1502,2)
(7951,847,2)
(6619,3350,2)
(3608,881,2)
(4037,1883,2)
(315,487,2)
(4193,7160,2)
(6849,557,2)
(7807,4928,2)
(7808,6703,2)
(9128,2546,2)
(2359,5608,2)
(1889,3230,2)
(5117,1003,2)
(4343,1955,2)
(3648,832,2)
(4741,2032,2)
(868,4934,2)
(4610,7917,2)
(3860,331,2)
(6744,3527,2)
(5663,334,2)
(6867,2347,2)
(1079,4928,2)
(6675,7179,2)
(7588,4193,2)
(9026,7148,2)
(4697,8362,2)
(3937,4193,2)
(8212,6998,2)
(3852,8362,2)
(171,4531,2)
(6304,1489,2)
(6569,6047,2)
(4627,7666,2)
(2551,7229,2)
(7362,4928,2)
(6001,3989,2)
(5948,6298,2)
(7276,5693,2)
(1137,5351,2)
(8776,2493,2)
(8728,3217,2)
(1063,6745,2)
(50,6958,2)
(2551,6160,2)
(6981,418,2)
(1986,8806,2)
(676,5712,2)
(4012,936,2)
(7608,7674,2)
(2021,3350,2)
(1646,4928,2)
(8675,3202,2)
(5294,996,2)
(4946,2032,2)
(9073,3872,2)
(8030,7571,2)
(5605,6738,2)
(6966,3965,2)
(2851,7937,2)
(6048,8056,2)
(4929,7647,2)
(8342,8362,2)
(372,5043,2)
(8355,2394,2)
(6344,7226,2)
(4389,8505,2)
(8273,8362,2)
(2838,7079,2)
(4270,5247,2)
(4844,7826,2)
(207,7438,2)
(3305,54,2)
(8028,847,2)
(4833,4744,2)
(648,1502,2)
(157,1545,2)
(291,5683,2)
(6810,3511,2)
(2708,3912,2)
(2788,6323,2)
(680,3421,2)
(5504,250,2)
(1723,5969,2)
(4326,5538,2)
(2774,173,2)
(5656,8576,2)
(5935,4085,2)
(5663,1983,2)
(5519,317,2)
(3079,235,2)
(2228,1502,2)
(897,2445,2)
(5786,5461,2)
(1512,9101,2)
(658,6561,2)
(4015,6862,2)
(5273,7805,2)
(4400,6297,2)
(3330,6047,2)
(6436,1288,2)
(6973,3032,2)
(4754,7826,2)
(5479,1761,2)
(5754,1973,2)
(1840,3539,2)
(475,2088,2)
(8642,7849,2)
(3691,5922,2)
(6638,8412,2)
(2368,5829,2)
(2214,8366,2)
(6548,3928,2)
(1218,8362,2)
(8928,1638,2)
(7527,4548,2)
(4141,1502,2)
(5384,2394,2)
(2817,3304,2)
(4878,1306,2)
(257,2129,2)
(946,3817,2)
(8192,1583,2)
(6702,8701,2)
(6732,8136,2)
(5833,1502,2)
(6304,7137,2)
(8516,8297,2)
(4680,5319,2)
(5259,4928,2)
(7366,8397,2)
(6787,5091,2)
(7247,3886,2)
(6341,403,2)
(9040,7571,2)
(4302,6048,2)
(7440,8975,2)
(1617,644,2)
(3307,805,2)
(5124,9156,2)
(8451,6186,2)
(5489,5043,2)
(4564,6566,2)
(8894,6550,2)
(7137,4995,2)
(3990,5043,2)
(4642,1353,2)
(6712,8362,2)
(6484,8362,2)
(1788,7435,2)
(585,6817,2)
(7148,8516,2)
(7118,5392,2)
(7092,2325,2)
(5547,5922,2)
(1510,579,2)
(8858,5902,2)
(3688,3382,2)
(5852,9025,2)
(4713,7179,2)
(5008,2394,2)
(4728,6124,2)
(7723,212,2)
(3735,4932,2)
(940,5100,2)
(7993,554,2)
(2306,9015,2)
(7324,2394,2)
(8410,8576,2)
(6028,3702,2)
(335,805,2)
(2050,2469,2)
(2329,1236,2)
(6156,2483,2)
(7946,1782,2)
(1295,4786,2)
(1901,1502,2)
(6664,539,2)
(3401,4928,2)
(8356,1502,2)
(8294,7638,2)
(212,7388,2)
(3732,4085,2)
(3709,3448,2)
(6076,4155,2)
(7263,6550,2)
(5222,6288,2)
(2801,5266,2)
(2028,6548,2)
(6711,6836,2)
(3422,6561,2)
(6137,5896,2)
(4984,7160,2)
(7565,1502,2)
(4284,1502,2)
(9037,2204,2)
(5249,5576,2)
(6238,3346,2)
(4352,1502,2)
(5701,4878,2)
(2830,5839,2)
(993,3222,2)
(822,1502,2)
(8415,8668,2)
(4074,7468,2)
(7585,8362,2)
(1271,6343,2)
(7967,2758,2)
(1231,8547,2)
(5176,2898,2)
(1726,4928,2)
(3123,3350,2)
(8301,8425,2)
(6702,7468,2)
(3633,7826,2)
(4337,1955,2)
(4514,2445,2)
(5416,2803,2)
(4078,1087,2)
(4721,3304,2)
(6267,7849,2)
(4942,8362,2)
(3669,1502,2)
(6142,6703,2)
(8644,6958,2)
(6899,3905,2)
(8966,1502,2)
(6507,7237,2)
(460,4019,2)
(206,936,2)
(3108,847,2)
(5758,8624,2)
(6355,8566,2)
(6128,6133,2)
(2035,5037,2)
(3930,7900,2)
(8600,8247,2)
(594,7388,2)
(7121,5037,2)
(7301,3272,2)
(371,6047,2)
(5567,2898,2)
(2335,6124,2)
(2003,5458,2)
(7719,8362,2)
(7325,8701,2)
(658,4928,2)
(2704,2505,2)
(7810,4541,2)
(7485,6569,2)
(2481,5939,2)
(8088,6195,2)
(5623,1883,2)
(6693,2194,2)
(7982,6855,2)
(6958,5390,2)
(5995,4928,2)
(4871,8362,2)
(1831,3362,2)
(6114,2621,2)
(7564,7513,2)
(4049,1502,2)
(2381,1505,2)
(303,806,2)
(2373,8362,2)
(2298,2125,2)
(7776,6186,2)
(3959,7371,2)
(2237,7826,2)
(250,7527,2)
(6278,8362,2)
(5918,697,2)
(8899,6128,2)
(6037,8362,2)
(8970,550,2)
(7922,2057,2)
(2345,7202,2)
(750,4704,2)
(2845,1635,2)
(8588,8362,2)
(8268,8032,2)
(1270,8545,2)
(4089,6561,2)
(5435,8623,2)
(49,4928,2)
(2803,5043,2)
(6506,7202,2)
(1385,8362,2)
(1501,7438,2)
(6168,8671,2)
(2576,8362,2)
(6704,411,2)
(15,7207,2)
(3412,5939,2)
(5609,5025,2)
(284,6850,2)
(3687,5525,2)
(7771,6365,2)
(290,4022,2)
(8320,423,2)
(4234,5035,2)
(5586,5939,2)
(8162,4019,2)
(9063,2020,2)
(7711,3826,2)
(3591,2507,2)
(8164,186,2)
(9037,7100,2)
(4110,3815,2)
(5392,1798,2)
(7587,3503,2)
(4026,7619,2)
(4078,3458,2)
(5293,2847,2)
(7345,8032,2)
(3703,6431,2)
(8300,847,2)
(2056,4928,2)
(788,3929,2)
(5784,5928,2)
(1448,1617,2)
(4286,2898,2)
(4278,4928,2)
(1999,3798,2)
(8246,8362,2)
(4018,5025,2)
(5794,5080,2)
(1390,4350,2)
(6500,2965,2)
(924,6733,2)
(3878,3636,2)
(7060,3032,2)
(7460,6871,2)
(1548,2736,2)
(6844,5712,2)
(7809,8362,2)
(7467,5969,2)
(6263,8830,2)
(1506,6693,2)
(5807,8585,2)
(3097,3702,2)
(4437,598,2)
(6606,720,2)
(722,2394,2)
(3082,3502,2)
(2301,8362,2)
(4547,169,2)
(5659,6404,2)
(7410,7619,2)
(5712,3917,2)
(3103,6863,2)
(5673,8083,2)
(5467,7438,2)
(4862,3350,2)
(7457,8360,2)
(3792,7826,2)
(3502,1577,2)
(1036,8032,2)
(7330,4022,2)
(7492,8362,2)
(3188,1141,2)
(3790,825,2)
(8418,6128,2)
(2073,6431,2)
(160,5796,2)
(5341,4928,2)
(1780,6938,2)
(224,5698,2)
(9097,6773,2)
(8354,7826,2)
(4234,1003,2)
(4452,4928,2)
(1579,8032,2)
(7521,46,2)
(5370,5134,2)
(5754,1553,2)
(209,1502,2)
(6626,3527,2)
(2473,5922,2)
(8688,7513,2)
(8312,5969,2)
(838,8225,2)
(8878,9015,2)
(6732,6550,2)
(712,7148,2)
(2184,5974,2)
(429,5351,2)
(5753,7826,2)
(5137,3448,2)
(7728,2464,2)
(4130,1009,2)
(6296,7202,2)
(6314,8886,2)
(7652,4928,2)
(6759,175,2)
(7219,175,2)
(8962,7642,2)
(832,5538,2)
(4138,5939,2)
(4774,5608,2)
(766,2125,2)
(1173,8159,2)
(213,6048,2)
(2399,5989,2)
(7552,3843,2)
(8327,8362,2)
(1067,1502,2)
(5549,6855,2)
(7928,1053,2)
(1941,7202,2)
(1616,6512,2)
(2625,411,2)
(2520,7371,2)
(3564,6186,2)
(4402,669,2)
(1220,6334,2)
(4773,8748,2)
(5689,7557,2)
(4721,7155,2)
(8566,4019,2)
(7418,5025,2)
(2799,2057,2)
(4008,8425,2)
(7020,8362,2)
(3696,6048,2)
(9146,6597,2)
(6268,550,2)
(6605,8499,2)
(5578,6343,2)
(3541,8576,2)
(5255,9025,2)
(1906,805,2)
(1598,1502,2)
(2434,6264,2)
(2656,7202,2)
(6159,341,2)
(6698,1981,2)
(6312,7162,2)
(6298,3963,2)
(3729,8825,2)
(4165,2782,2)
(4795,8362,2)
(7277,2394,2)
(5768,5247,2)
(620,8576,2)
(7466,4928,2)
(4525,7535,2)
(2593,533,2)
(3411,5115,2)
(2490,5247,2)
(8519,5043,2)
(5500,2125,2)
(1458,3715,2)
(7046,7100,2)
(7063,1530,2)
(712,1228,2)
(828,5421,2)
(3910,7666,2)
(6794,393,2)
(6807,847,2)
(3871,3715,2)
(4591,2708,2)
(2882,6597,2)
(3334,3217,2)
(7757,212,2)
(1539,6047,2)
(4523,4443,2)
(4359,7513,2)
(9148,8423,2)
(3810,1289,2)
(214,5939,2)
(6409,2555,2)
(5463,5712,2)
(2468,5023,2)
(8700,5248,2)
(2925,4928,2)
(7046,6988,2)
(9112,1383,2)
(5747,4995,2)
(7082,5525,2)
(2797,4224,2)
(7867,7699,2)
(1680,2316,2)
(1873,4920,2)
(8255,2403,2)
(8778,2265,2)
(5417,2705,2)
(5294,2488,2)
(5559,7552,2)
(2180,3937,2)
(5646,8619,2)
(1270,2322,2)
(5542,266,2)
(8514,8362,2)
(797,2249,2)
(2096,3636,2)
(3493,1502,2)
(8635,3082,2)
(575,5939,2)
(7921,3917,2)
(3155,3417,2)
(5448,5025,2)
(1946,393,2)
(6324,7941,2)
(1221,4934,2)
(2964,6738,2)
(567,4928,2)
(8395,8140,2)
(8829,908,2)
(3317,1157,2)
(8310,8998,2)
(384,5611,2)
(6120,3798,2)
(7317,6195,2)
(8385,8178,2)
(2001,7369,2)
(7209,5266,2)
(6988,3416,2)
(4804,8159,2)
(458,7179,2)
(1163,175,2)
(7586,5939,2)
(6166,1617,2)
(8499,8329,2)
(2847,4929,2)
(8617,7666,2)
(5969,2609,2)
(7630,5100,2)
(3018,2445,2)
(6340,9091,2)
(6410,5712,2)
(2100,4744,2)
(8356,4928,2)
(5493,1502,2)
(4611,5969,2)
(2020,3647,2)
(7984,5867,2)
(8214,4739,2)
(7587,8675,2)
(4223,8362,2)
(2461,1028,2)
(6226,6404,2)
(5677,8362,2)
(28,175,2)
(289,7545,2)
(6107,3963,2)
(1891,5939,2)
(4016,4455,2)
(1708,1502,2)
(5818,9101,2)
(3800,1924,2)
(736,418,2)
(2880,5371,2)
(523,4647,2)
(4998,2394,2)
(841,5701,2)
(573,701,2)
(8582,7826,2)
(9107,2394,2)
(4362,1838,2)
(2582,6334,2)
(2807,3965,2)
(638,2032,2)
(4195,5608,2)
(344,1937,2)
(7881,4878,2)
(9075,4245,2)
(2414,7004,2)
(3120,4070,2)
(8728,3583,2)
(8128,5043,2)
(7859,2112,2)
(7355,4928,2)
(3124,8576,2)
(8654,8466,2)
(4995,6958,2)
(7192,3715,2)
(7602,6068,2)
(6208,2088,2)
(6568,2125,2)
(9037,1919,2)
(2437,2585,2)
(767,418,2)
(3813,6958,2)
(2873,7666,2)
(2057,814,2)
(6369,8498,2)
(7910,1515,2)
(2958,1092,2)
(386,4204,2)
(7575,7768,2)
(7036,6958,2)
(6928,2732,2)
(4407,4384,2)
(6590,1890,2)
(2198,8362,2)
(4136,936,2)
(1353,847,2)
(2574,888,2)
(7853,3965,2)
(5967,2621,2)
(3899,6958,2)
(2402,559,2)
(8756,5461,2)
(3652,720,2)
(6713,3965,2)
(7726,8362,2)
(8189,3225,2)
(9057,7160,2)
(1446,1502,2)
(8337,8362,2)
(1088,1502,2)
(2424,1306,2)
(1108,496,2)
(8605,2057,2)
(6417,1883,2)
(5327,6124,2)
(6479,8875,2)
(7357,5273,2)
(8888,7369,2)
(1731,4974,2)
(1841,5939,2)
(6092,1809,2)
(9037,4634,2)
(6343,4397,2)
(2671,8362,2)
(7427,1502,2)
(3570,7450,2)
(3078,5992,2)
(5478,3520,2)
(8107,400,2)
(257,7287,2)
(5322,1502,2)
(3081,5037,2)
(1495,7666,2)
(1612,7674,2)
(4147,3280,2)
(2517,8362,2)
(6326,3241,2)
(756,8362,2)
(4270,6353,2)
(2118,1823,2)
(4910,1502,2)
(234,1804,2)
(2931,2851,2)
(852,6047,2)
(7838,3636,2)
(4216,8247,2)
(6644,2249,2)
(6871,1502,2)
(2748,2295,2)
(9081,5939,2)
(2571,539,2)
(7648,5568,2)
(2073,4634,2)
(6310,4204,2)
(1208,7160,2)
(551,4928,2)
(1574,1503,2)
(731,8795,2)
(2396,6404,2)
(8701,8362,2)
(4000,1617,2)
(6995,4497,2)
(332,7425,2)
(2537,6673,2)
(90,5867,2)
(3786,5392,2)
(5250,6512,2)
(6987,6922,2)
(990,5867,2)
(7427,4928,2)
(3717,1809,2)
(4875,2394,2)
(707,6958,2)
(3411,1489,2)
(8563,6491,2)
(2337,4509,2)
(354,3570,2)
(3106,6334,2)
(8662,3906,2)
(7646,8362,2)
(2583,3965,2)
(2697,1502,2)
(8981,940,2)
(1410,6431,2)
(6949,1502,2)
(8982,5487,2)
(1280,2057,2)
(3460,212,2)
(8465,8362,2)
(4370,7826,2)
(5668,8362,2)
(8043,7391,2)
(5817,1502,2)
(6229,4196,2)
(1378,3965,2)
(751,7724,2)
(1468,8362,2)
(4139,6431,2)
(8894,326,2)
(2025,8066,2)
(9125,1502,2)
(8722,222,2)
(1267,8060,2)
(8484,658,2)
(387,3421,2)
(3098,6718,2)
(2760,7901,2)
(8750,802,2)
(1295,2032,2)
(7339,6730,2)
(9013,8799,2)
(5715,1256,2)
(2587,847,2)
(1084,5198,2)
(7116,6404,2)
(1098,4085,2)
(4032,2180,2)
(8759,4647,2)
(5745,645,2)
(2261,4232,2)
(1686,1328,2)
(7229,3530,2)
(4347,1502,2)
(1924,5511,2)
(2197,2699,2)
(2136,1502,2)
(3192,8205,2)
(2407,5025,2)
(2425,8825,2)
(6967,2399,2)
(7773,8499,2)
(2366,6318,2)
(103,7202,2)
(1336,8362,2)
(7476,361,2)
(2061,8851,2)
(413,7219,2)
(6115,7207,2)
(7717,6128,2)
(1363,3830,2)
(4190,6128,2)
(186,9006,2)
(2888,7941,2)
(3352,7247,2)
(9148,4928,2)
(621,805,2)
(2785,260,2)
(7243,5939,2)
(3430,5939,2)
(8741,6272,2)
(890,4928,2)
(4070,1201,2)
(4379,7826,2)
(1875,3965,2)
(6299,9148,2)
(609,7252,2)
(4524,8975,2)
(297,1502,2)
(8016,3526,2)
(9153,4974,2)
(791,39,2)
(8011,6745,2)
(3592,847,2)
(1593,4928,2)
(8083,5525,2)
(3308,3989,2)
(5823,1890,2)
(4784,2464,2)
(2320,7100,2)
(69,8425,2)
(1379,4974,2)
(8260,8833,2)
(4595,3520,2)
(5755,7666,2)
(6658,5922,2)
(5776,4050,2)
(3835,8362,2)
(1755,4928,2)
(543,6047,2)
(271,1102,2)
(1604,7207,2)
(5738,243,2)
(4848,8020,2)
(4416,6548,2)
(1157,1872,2)
(4544,7359,2)
(4336,4204,2)
(5763,1284,2)
(3385,8701,2)
(4450,3527,2)
(6101,1193,2)
(3805,2107,2)
(9121,7513,2)
(7790,5043,2)
(8461,4928,2)
(8329,7450,2)
(4529,1363,2)
(3163,4006,2)
(6958,701,2)
(1761,7558,2)
(4191,7097,2)
(5889,3421,2)
(8867,6850,2)
(6387,7388,2)
(3085,255,2)
(343,6512,2)
(6422,8362,2)
(5046,8159,2)
(4793,6998,2)
(8890,6047,2)
(2961,6698,2)
(6491,1142,2)
(8631,2546,2)
(4891,6195,2)
(4695,3583,2)
(6031,212,2)
(1350,8563,2)
(5468,5623,2)
(8728,4220,2)
(1691,2153,2)
(3288,1502,2)
(180,3537,2)
(3832,4019,2)
(5300,312,2)
(499,1502,2)
(4605,6773,2)
(7478,7472,2)
(965,3526,2)
(5775,6404,2)
(7778,4928,2)
(8042,7666,2)
(744,2249,2)
(6322,5100,2)
(6056,3232,2)
(7602,5264,2)
(2981,4115,2)
(8123,1904,2)
(7369,2771,2)
(4895,5525,2)
(5760,7004,2)
(5024,4422,2)
(8832,4934,2)
(3364,8362,2)
(1920,720,2)
(7370,2445,2)
(3575,4928,2)
(2291,8247,2)
(4637,3963,2)
(1738,1502,2)
(2191,8466,2)
(1278,1502,2)
(5571,3963,2)
(1680,6431,2)
(3444,8466,2)
(5840,1088,2)
(8247,4085,2)
(5742,8362,2)
(5427,1898,2)
(6460,805,2)
(4323,5025,2)
(2308,8991,2)
(6787,1498,2)
(9026,1591,2)
(2416,7552,2)
(171,5351,2)
(1370,8362,2)
(757,8466,2)
(5294,1235,2)
(3120,2873,2)
(1904,6967,2)
(5144,7666,2)
(1569,5928,2)
(1132,1502,2)
(2254,8035,2)
(984,8576,2)
(4070,1840,2)
(3967,5025,2)
(3341,6855,2)
(4178,6188,2)
(4867,8362,2)
(2280,4928,2)
(6836,1168,2)
(768,1734,2)
(5620,1628,2)
(6634,8276,2)
(5666,8884,2)
(8282,4252,2)
(6161,3963,2)
(2380,2243,2)
(6766,6236,2)
(7626,5939,2)
(677,8830,2)
(8025,175,2)
(1142,6431,2)
(6866,7151,2)
(2789,6128,2)
(7373,4721,2)
(8664,8362,2)
(4237,2464,2)
(463,4224,2)
(3634,2088,2)
(2647,7647,2)
(4548,354,2)
(8109,385,2)
(5454,5043,2)
(8909,701,2)
(6209,6404,2)
(4610,7826,2)
(4579,3520,2)
(2704,317,2)
(7046,3674,2)
(5294,5573,2)
(3152,1502,2)
(4794,8516,2)
(1348,1168,2)
(7950,6718,2)
(240,4019,2)
(8362,8499,2)
(4452,411,2)
(7401,3940,2)
(411,4016,2)
(3624,1046,2)
(9136,4647,2)
(9037,5573,2)
(7753,4354,2)
(7894,1502,2)
(5314,7062,2)
(6611,6262,2)
(2619,1755,2)
(6930,2898,2)
(6281,2585,2)
(1698,936,2)
(4422,6562,2)
(1859,8247,2)
(4576,1506,2)
(5655,171,2)
(5294,6757,2)
(4843,4252,2)
(5859,5859,2)
(3526,2898,2)
(9026,2893,2)
(1991,3612,2)
(1862,1003,2)
(669,387,2)
(4705,3078,2)
(7131,4928,2)
(1270,3965,2)
(1297,5867,2)
(7592,485,2)
(953,213,2)
(5778,3448,2)
(371,1502,2)
(3147,8008,2)
(2466,4765,2)
(7782,6967,2)
(7707,4155,2)
(8925,3963,2)
(1316,8634,2)
(4949,5320,2)
(3137,4744,2)
(371,2394,2)
(4768,5939,2)
(9037,742,2)
(1607,8701,2)
(6730,2483,2)
(6363,6773,2)
(2672,3382,2)
(7552,6730,2)
(3465,7674,2)
(2296,2180,2)
(5294,6247,2)
(3779,5025,2)
(8356,3702,2)
(5700,8362,2)
(1550,2347,2)
(2829,2498,2)
(6259,3163,2)
(116,1635,2)
(1134,8362,2)
(8263,8020,2)
(988,4019,2)
(1953,1502,2)
(611,847,2)
(4179,5451,2)
(3942,6047,2)
(115,8362,2)
(2981,1628,2)
(9125,1924,2)
(1433,1005,2)
(4851,405,2)
(6304,707,2)
(7908,212,2)
(8482,2681,2)
(8957,4744,2)
(7854,284,2)
(3014,4019,2)
(3459,7826,2)
(3944,3963,2)
(3438,3715,2)
(8487,3630,2)
(5541,8008,2)
(7635,882,2)
(5453,3702,2)
(7849,5944,2)
(959,6025,2)
(2698,1092,2)
(5329,5867,2)
(5196,5025,2)
(7468,598,2)
(9151,7941,2)
(5449,8159,2)
(1435,6133,2)
(3801,8362,2)
(7849,131,2)
(5737,8476,2)
(3467,8563,2)
(7189,4224,2)
(2705,5608,2)
(2869,7148,2)
(242,8362,2)
(2595,7674,2)
(2457,8020,2)
(8998,6746,2)
(8581,8079,2)
(4437,677,2)
(2035,1502,2)
(76,1731,2)
(1138,4647,2)
(4472,2893,2)
(4369,6958,2)
(8957,6431,2)
(32,7826,2)
(9042,1798,2)
(2057,5867,2)
(6323,7937,2)
(8566,2180,2)
(6421,4878,2)
(4572,2894,2)
(2619,7826,2)
(5153,235,2)
(4384,9029,2)
(5886,3526,2)
(1558,3965,2)
(1977,1502,2)
(8310,3233,2)
(7119,1597,2)
(3184,4928,2)
(8770,1611,2)
(903,4140,2)
(2603,6404,2)
(5604,8362,2)
(8776,7826,2)
(1006,403,2)
(238,2445,2)
(558,38,2)
(6137,7202,2)
(6094,8362,2)
(6213,3350,2)
(4050,2032,2)
(3797,131,2)
(961,4071,2)
(5796,2180,2)
(9051,6958,2)
(8219,3125,2)
(5595,2796,2)
(2969,1502,2)
(4212,3872,2)
(5989,3508,2)
(7497,6703,2)
(2081,7062,2)
(1423,573,2)
(7175,8566,2)
(8833,7450,2)
(6717,4050,2)
(7042,7371,2)
(6112,5392,2)
(3661,3421,2)
(403,1924,2)
(2289,245,2)
(6291,7666,2)
(1028,7468,2)
(2296,4019,2)
(3258,1056,2)
(6818,1193,2)
(4846,5115,2)
(7480,2394,2)
(1067,4928,2)
(1521,4886,2)
(3839,2441,2)
(7713,3181,2)
(6264,8748,2)
(7746,8505,2)
(1367,8362,2)
(5159,4497,2)
(6441,3900,2)
(4935,697,2)
(6978,8370,2)
(7548,8576,2)
(5458,1306,2)
(7017,8728,2)
(1505,2005,2)
(9143,243,2)
(3317,5025,2)
(4232,5467,2)
(8864,4061,2)
(1403,3963,2)
(4559,3534,2)
(6668,3965,2)
(1291,4928,2)
(8947,4471,2)
(7108,7359,2)
(8403,8701,2)
(6786,5902,2)
(1027,3583,2)
(7488,3193,2)
(7387,1502,2)
(4874,4928,2)
(5719,186,2)
(8698,4928,2)
(6017,1617,2)
(4256,4682,2)
(6791,5124,2)
(5017,131,2)
(5041,2057,2)
(7606,2609,2)
(5106,1502,2)
(0,3702,2)
(3856,4372,2)
(7773,1502,2)
(4515,2546,2)
(5695,3989,2)
(2074,6728,2)
(941,5608,2)
(2819,4928,2)
(597,4928,2)
(6677,5024,2)
(4437,642,2)
(4064,8830,2)
(2598,6642,2)
(6162,720,2)
(2717,6404,2)
(4437,1591,2)
(2258,603,2)
(8136,4928,2)
(3317,3407,2)
(6786,8285,2)
(6314,6559,2)
(4451,7309,2)
(539,9025,2)
(9075,8830,2)
(1944,4934,2)
(4338,8247,2)
(6850,2782,2)
(9088,8247,2)
(1812,8890,2)
(4303,2125,2)
(5230,6696,2)
(1890,730,2)
(1758,8362,2)
(1588,720,2)
(7292,7619,2)
(3665,7826,2)
(113,1731,2)
(8777,4360,2)
(3564,8451,2)
(4886,1473,2)
(1633,533,2)
(2459,6193,2)
(1293,2057,2)
(3525,2898,2)
(4779,2117,2)
(8848,7826,2)
(7346,8362,2)
(776,2020,2)
(3305,4201,2)
(2336,7826,2)
(3618,1231,2)
(5118,4085,2)
(4207,550,2)
(3489,7309,2)
(7893,6058,2)
(4636,8671,2)
(936,2106,2)
(2199,7826,2)
(4192,8362,2)
(3537,6587,2)
(1480,7472,2)
(1118,8499,2)
(3359,7060,2)
(8329,4744,2)
(4437,4985,2)
(8696,7826,2)
(822,936,2)
(3884,2125,2)
(9145,1502,2)
(3409,1502,2)
(5992,1955,2)
(7438,8086,2)
(3524,697,2)
(3795,5939,2)
(6418,6512,2)
(5302,5693,2)
(7056,235,2)
(2670,5608,2)
(2322,847,2)
(6388,403,2)
(2153,3937,2)
(1520,334,2)
(5636,4928,2)
(5891,1923,2)
(7790,6931,2)
(9066,6323,2)
(5623,7468,2)
(4283,943,2)
(4147,7309,2)
(6591,6334,2)
(8340,8830,2)
(8890,4928,2)
(4150,6812,2)
(1637,8362,2)
(6787,2340,2)
(8748,1991,2)
(6862,209,2)
(3866,720,2)
(6692,7659,2)
(97,2994,2)
(2480,3350,2)
(6247,2898,2)
(848,8362,2)
(8329,3570,2)
(9037,5244,2)
(989,7619,2)
(5337,7060,2)
(4241,3448,2)
(3998,5369,2)
(5219,3412,2)
(3419,3421,2)
(4497,3680,2)
(7371,4699,2)
(3549,7371,2)
(5817,4928,2)
(2278,5902,2)
(2863,1502,2)
(942,7388,2)
(8574,1924,2)
(273,7202,2)
(5531,1528,2)
(7206,8247,2)
(1772,9101,2)
(136,385,2)
(7334,1916,2)
(500,6225,2)
(1879,6195,2)
(6744,6963,2)
(4222,5043,2)
(3870,4928,2)
(6304,7250,2)
(4719,1321,2)
(8310,6512,2)
(6004,5025,2)
(7229,6179,2)
(8560,3530,2)
(252,39,2)
(8468,1191,2)
(7604,6562,2)
(5675,3937,2)
(615,2308,2)
(8580,8262,2)
(6792,7239,2)
(2329,8362,2)
(8967,6958,2)
(1645,3338,2)
(8830,3049,2)
(2179,7826,2)
(542,8032,2)
(2630,3137,2)
(7697,1502,2)
(5036,4928,2)
(49,4397,2)
(1170,4928,2)
(7592,688,2)
(1402,1502,2)
(8048,6730,2)
(5946,6264,2)
(499,4928,2)
(6686,533,2)
(3779,2973,2)
(7929,7309,2)
(1624,8362,2)
(3211,8020,2)
(1762,4928,2)
(1773,720,2)
(155,8362,2)
(220,1438,2)
(4096,7666,2)
(1772,1463,2)
(1397,4407,2)
(8279,2445,2)
(3167,7369,2)
(6461,697,2)
(8037,6938,2)
(4468,847,2)
(5686,5043,2)
(879,260,2)
(2735,8499,2)
(7910,1502,2)
(7645,7732,2)
(7246,7160,2)
(2538,5525,2)
(3262,5922,2)
(2943,8464,2)
(2304,3366,2)
(6187,2951,2)
(4475,8893,2)
(514,7304,2)
(8788,858,2)
(6050,5712,2)
(6830,4928,2)
(506,2125,2)
(4141,6703,2)
(2279,5744,2)
(1432,3775,2)
(1317,5524,2)
(8733,4934,2)
(1817,1502,2)
(8829,5115,2)
(8000,5939,2)
(8862,95,2)
(3563,3937,2)
(5323,8362,2)
(7656,4928,2)
(9060,8276,2)
(839,1617,2)
(7637,3844,2)
(6874,5392,2)
(6587,8762,2)
(8076,8362,2)
(7541,6773,2)
(8807,936,2)
(5796,4019,2)
(7077,2893,2)
(8201,6718,2)
(8325,6512,2)
(3356,5904,2)
(9043,1502,2)
(3432,2057,2)
(4224,7867,2)
(3539,6783,2)
(5217,2394,2)
(4651,6090,2)
(4374,6642,2)
(7433,5524,2)
(6925,5091,2)
(4434,7202,2)
(242,1502,2)
(915,2212,2)
(3830,243,2)
(876,8283,2)
(5686,8563,2)
(4572,598,2)
(8221,5859,2)
(3791,7060,2)
(1328,7643,2)
(1679,3798,2)
(3506,8480,2)
(9037,642,2)
(8829,5559,2)
(2196,936,2)
(5565,8159,2)
(6602,7450,2)
(5818,8394,2)
(4183,4928,2)
(2444,7666,2)
(8409,8074,2)
(2893,7937,2)
(7300,5939,2)
(5157,1890,2)
(777,355,2)
(7801,7191,2)
(3383,936,2)
(4624,2316,2)
(7479,2686,2)
(6357,720,2)
(1266,6343,2)
(567,8362,2)
(1659,6328,2)
(1968,5538,2)
(265,124,2)
(2949,8362,2)
(4407,5969,2)
(1953,2325,2)
(3169,1946,2)
(7031,4934,2)
(8629,7826,2)
(7960,6642,2)
(8910,5922,2)
(6672,4928,2)
(1902,1620,2)
(8921,8499,2)
(838,4224,2)
(8200,2112,2)
(2206,1954,2)
(6033,4196,2)
(3616,4768,2)
(2293,4878,2)
(211,7826,2)
(4598,8239,2)
(3762,3965,2)
(3034,2440,2)
(8285,4224,2)
(4706,3872,2)
(6962,1240,2)
(1032,713,2)
(7906,8362,2)
(9037,2894,2)
(6305,539,2)
(4110,123,2)
(3029,341,2)
(2656,5803,2)
(228,6591,2)
(1251,2032,2)
(6968,4928,2)
(6304,493,2)
(7829,1199,2)
(3658,2812,2)
(2666,5969,2)
(7960,8678,2)
(2982,7323,2)
(2565,3448,2)
(204,6550,2)
(3052,4974,2)
(3278,7388,2)
(3499,720,2)
(1702,7826,2)
(5741,8159,2)
(8806,8466,2)
(6907,7793,2)
(813,4928,2)
(5980,4928,2)
(9129,822,2)
(6906,4934,2)
(974,7937,2)
(1191,5320,2)
(2644,3229,2)
(8089,8421,2)
(4437,2204,2)
(1954,1328,2)
(1073,3448,2)
(5928,6479,2)
(2967,7202,2)
(3605,7174,2)
(8321,7826,2)
(2998,371,2)
(8842,7359,2)
(4866,550,2)
(606,6325,2)
(5751,8425,2)
(6223,3570,2)
(3481,243,2)
(8565,411,2)
(3993,1502,2)
(6653,7826,2)
(6460,6688,2)
(621,5513,2)
(2291,8991,2)
(1025,847,2)
(7930,8074,2)
(7083,1366,2)
(7834,7309,2)
(6405,6713,2)
(1464,5839,2)
(6434,8725,2)
(8508,6404,2)
(583,34,2)
(2602,4928,2)
(569,1502,2)
(5923,1502,2)
(4574,7826,2)
(8827,393,2)
(7470,5730,2)
(7558,1267,2)
(7089,4928,2)
(2459,5902,2)
(631,7826,2)
(1619,6404,2)
(4163,5065,2)
(2117,1502,2)
(1230,2627,2)
(6407,279,2)
(5785,1617,2)
(4545,411,2)
(6337,7826,2)
(8173,4647,2)
(266,6170,2)
(6241,8020,2)
(3366,7674,2)
(6800,3520,2)
(7115,5902,2)
(2516,703,2)
(4548,7450,2)
(346,8067,2)
(8032,2507,2)
(8257,2585,2)
(3933,9031,2)
(1027,6264,2)
(2349,4695,2)
(4368,1168,2)
(8631,9128,2)
(3411,4155,2)
(315,3012,2)
(3938,720,2)
(6691,8362,2)
(4472,2894,2)
(5596,4475,2)
(2530,727,2)
(6436,6195,2)
(5610,5689,2)
(2055,1502,2)
(5732,1502,2)
(1642,2445,2)
(7940,4224,2)
(8809,7388,2)
(3184,1502,2)
(7308,6103,2)
(8017,5608,2)
(3390,8362,2)
(3362,1788,2)
(1770,6124,2)
(5726,3188,2)
(5646,4527,2)
(1231,8362,2)
(2798,2142,2)
(2316,7900,2)
(1945,4928,2)
(3399,5807,2)
(7191,8120,2)
(3168,540,2)
(7919,7021,2)
(6819,8362,2)
(5443,9101,2)
(8630,7826,2)
(8193,7619,2)
(7098,7826,2)
(3989,3900,2)
(2597,6318,2)
(638,4928,2)
(1761,2410,2)
(7012,8032,2)
(8213,3243,2)
(8498,7561,2)
(2724,8183,2)
(3186,235,2)
(8314,131,2)
(1306,3553,2)
(5483,7552,2)
(8266,140,2)
(6215,7062,2)
(2959,8362,2)
(3872,247,2)
(7308,2708,2)
(7084,2325,2)
(5628,3421,2)
(8795,3636,2)
(1004,87,2)
(8828,4155,2)
(6602,3775,2)
(8243,3570,2)
(3512,131,2)
(3503,6942,2)
(45,404,2)
(1921,1731,2)
(3567,8362,2)
(4638,8008,2)
(4685,7179,2)
(8141,6512,2)
(6877,2801,2)
(1471,5025,2)
(3383,4890,2)
(2196,6378,2)
(2249,7207,2)
(4953,3421,2)
(7124,7515,2)
(2412,6128,2)
(1704,5025,2)
(650,8362,2)
(7019,7908,2)
(8576,3537,2)
(6117,6958,2)
(4860,1502,2)
(1479,7647,2)
(3767,2088,2)
(8912,4682,2)
(3304,5122,2)
(7808,4141,2)
(5474,4928,2)
(3647,7995,2)
(8884,7364,2)
(3482,4744,2)
(6356,7826,2)
(5501,7826,2)
(7158,8276,2)
(5048,2391,2)
(6564,5549,2)
(1342,5320,2)
(5102,8989,2)
(6051,6388,2)
(1647,4085,2)
(3769,398,2)
(3337,7438,2)
(7148,2164,2)
(545,3367,2)
(3983,2325,2)
(4053,6773,2)
(2982,3848,2)
(1405,1861,2)
(860,8362,2)
(8987,7390,2)
(5294,820,2)
(6900,1123,2)
(7178,7619,2)
(8304,8825,2)
(3745,6404,2)
(7318,7829,2)
(807,1572,2)
(8829,3674,2)
(982,8159,2)
(900,8913,2)
(9037,1591,2)
(7490,3636,2)
(8445,2394,2)
(7329,3032,2)
(3756,3032,2)
(1863,5721,2)
(453,8362,2)
(2611,5043,2)
(4808,5043,2)
(6618,6236,2)
(9037,8037,2)
(4168,3252,2)
(5898,3350,2)
(3088,7674,2)
(3740,4647,2)
(3650,7867,2)
(6130,2708,2)
(8387,8074,2)
(8306,533,2)
(4853,1590,2)
(6048,4932,2)
(8833,3570,2)
(6063,8425,2)
(6905,7826,2)
(3715,8516,2)
(9030,1916,2)
(3305,3817,2)
(8516,4022,2)
(4196,7281,2)
(2190,5320,2)
(3798,6404,2)
(2459,5043,2)
(811,7488,2)
(6292,5939,2)
(6467,8362,2)
(2098,1924,2)
(8521,2445,2)
(72,8991,2)
(4667,2325,2)
(7077,5693,2)
(5674,7849,2)
(8175,5969,2)
(7175,7450,2)
(3373,7359,2)
(497,6648,2)
(4985,1168,2)
(8064,2221,2)
(857,8576,2)
(2859,235,2)
(8875,4222,2)
(2092,2530,2)
(5812,847,2)
(3540,7674,2)
(5013,5608,2)
(9100,1502,2)
(1605,9108,2)
(1479,1502,2)
(3180,8638,2)
(6296,6348,2)
(4181,936,2)
(1152,8545,2)
(8775,2394,2)
(7774,4995,2)
(3837,8074,2)
(5299,6404,2)
(9149,254,2)
(3230,5043,2)
(5673,7892,2)
(3229,3069,2)
(2186,847,2)
(4559,3241,2)
(2119,2294,2)
(4157,4022,2)
(3616,5939,2)
(8960,7004,2)
(626,4923,2)
(3870,1502,2)
(8730,533,2)
(4280,720,2)
(8493,2585,2)
(1015,8563,2)
(2994,4196,2)
(246,7826,2)
(6615,3114,2)
(2435,2347,2)
(930,1502,2)
(3550,1502,2)
(3367,1798,2)
(7928,6489,2)
(9092,2088,2)
(8993,6236,2)
(3190,7826,2)
(522,4598,2)
(8621,7826,2)
(3398,8362,2)
(1901,4928,2)
(924,2709,2)
(5862,8278,2)
(5560,8668,2)
(2443,1502,2)
(1291,1502,2)
(1348,5218,2)
(3511,8247,2)
(691,1832,2)
(3576,8499,2)
(362,1502,2)
(8062,8020,2)
(3433,8362,2)
(6937,499,2)
(8397,6974,2)
(4322,5904,2)
(7617,7062,2)
(1951,5037,2)
(4386,8975,2)
(5497,2840,2)
(1250,3007,2)
(4463,3715,2)
(6571,4493,2)
(7572,8362,2)
(9040,6894,2)
(6842,8991,2)
(5566,3185,2)
(6697,3305,2)
(5807,5693,2)
(8432,9025,2)
(6697,3817,2)
(449,6124,2)
(3171,2057,2)
(8779,720,2)
(7694,7674,2)
(6783,1329,2)
(7740,5247,2)
(7402,7062,2)
(5113,1502,2)
(7981,2445,2)
(7716,175,2)
(5204,6597,2)
(6016,8362,2)
(2363,8482,2)
(1700,6195,2)
(2764,8020,2)
(4445,2843,2)
(7744,2088,2)
(8356,6047,2)
(2582,1220,2)
(6718,6323,2)
(8763,3636,2)
(3271,847,2)
(4915,2851,2)
(2187,466,2)
(122,5005,2)
(2421,720,2)
(6467,6094,2)
(6238,4928,2)
(747,7202,2)
(5523,7179,2)
(5787,1502,2)
(2814,8008,2)
(1086,6642,2)
(6530,5867,2)
(7753,4544,2)
(1133,7666,2)
(3462,7526,2)
(372,5902,2)
(2244,1231,2)
(2059,3421,2)
(675,8105,2)
(6030,7515,2)
(1446,4928,2)
(4717,3537,2)
(9037,6988,2)
(4191,6404,2)
(3525,2440,2)
(7143,4928,2)
(1344,5025,2)
(3544,8362,2)
(7360,8499,2)
(8146,2394,2)
(4154,8799,2)
(8593,2804,2)
(3530,1168,2)
(4472,8678,2)
(3681,1502,2)
(6659,1617,2)
(3770,4049,2)
(8963,720,2)
(39,847,2)
(4718,4232,2)
(4163,3819,2)
(7875,6236,2)
(7959,2469,2)
(5294,3674,2)
(6514,8020,2)
(7218,5939,2)
(243,2032,2)
(5371,8948,2)
(6473,8516,2)
(5355,3329,2)
(6699,3702,2)
(7048,720,2)
(4347,5025,2)
(8261,3346,2)
(6815,3049,2)
(4671,7179,2)
(5294,6574,2)
(8590,1866,2)
(7762,6047,2)
(9037,707,2)
(727,4928,2)
(4837,8020,2)
(677,5260,2)
(7633,8499,2)
(5866,1168,2)
(1437,8074,2)
(522,9089,2)
(1794,7955,2)
(2498,2496,2)
(1945,1502,2)
(8294,5320,2)
(8510,5545,2)
(4873,1502,2)
(98,6855,2)
(2357,5641,2)
(3551,8362,2)
(4196,6648,2)
(7144,5576,2)
(5580,8830,2)
(794,8499,2)
(8840,6718,2)
(5885,3963,2)
(2610,6512,2)
(5263,235,2)
(6041,6512,2)
(3265,5902,2)
(7502,8975,2)
(971,8576,2)
(3917,5807,2)
(3920,169,2)
(606,6316,2)
(6702,1502,2)
(5358,8337,2)
(7961,4085,2)
(4278,7179,2)
(561,8362,2)
(673,720,2)
(514,882,2)
(4014,3520,2)
(139,418,2)
(6540,3989,2)
(6878,6128,2)
(2248,4928,2)
(4531,5902,2)
(5390,701,2)
(5294,3825,2)
(3725,8425,2)
(1850,5922,2)
(6527,7826,2)
(1042,1502,2)
(4615,8362,2)
(8700,4724,2)
(3220,2697,2)
(1385,3583,2)
(2793,8362,2)
(7256,5082,2)
(2058,2684,2)
(8273,5975,2)
(7652,1502,2)
(3212,8425,2)
(5937,2325,2)
(8093,7207,2)
(5691,1804,2)
(2802,7442,2)
(4557,8425,2)
(4835,8425,2)
(4068,385,2)
(6096,1256,2)
(8950,7593,2)
(6106,2546,2)
(8456,4497,2)
(679,5939,2)
(6058,2322,2)
(2129,6773,2)
(2278,5043,2)
(8687,411,2)
(5650,8362,2)
(5896,4928,2)
(1213,242,2)
(2973,5025,2)
(3753,7849,2)
(7293,3350,2)
(5945,1502,2)
(5461,5694,2)
(2241,4928,2)
(7179,2783,2)
(8121,805,2)
(6993,6562,2)
(1230,5888,2)
(3226,6404,2)
(6598,8362,2)
(7450,3775,2)
(4618,9015,2)
(2952,8362,2)
(4996,8362,2)
(753,5392,2)
(8653,7893,2)
(7544,5024,2)
(5038,6318,2)
(3360,9101,2)
(7501,4928,2)
(7824,7619,2)
(4399,7826,2)
(4139,4744,2)
(2952,1796,2)
(217,1924,2)
(3059,4085,2)
(2683,5037,2)
(4049,4928,2)
(1573,1635,2)
(4649,2967,2)
(950,7450,2)
(8829,7092,2)
(1197,1502,2)
(4739,1502,2)
(3352,7062,2)
(3233,5663,2)
(4085,2961,2)
(4289,3965,2)
(3504,5969,2)
(6485,6718,2)
(6520,701,2)
(1988,1489,2)
(2691,539,2)
(8766,847,2)
(6081,6404,2)
(7499,3511,2)
(7639,2469,2)
(9033,1502,2)
(4632,847,2)
(3533,2898,2)
(7964,6967,2)
(4283,260,2)
(3510,6119,2)
(5173,3193,2)
(6061,6479,2)
(250,4548,2)
(5502,7826,2)
(6304,8037,2)
(4452,1502,2)
(5632,3527,2)
(956,5329,2)
(8455,4204,2)
(305,4928,2)
(1079,1502,2)
(139,450,2)
(6143,3937,2)
(4889,6124,2)
(6253,8991,2)
(355,5266,2)
(6440,802,2)
(8574,4928,2)
(6304,4551,2)
(5654,7450,2)
(2816,3612,2)
(5082,6703,2)
(804,5922,2)
(7878,533,2)
(2017,6195,2)
(3539,8271,2)
(4495,5939,2)
(3021,2249,2)
(7773,4928,2)
(6218,3775,2)
(1913,1306,2)
(2338,2555,2)
(509,7004,2)
(1869,2994,2)
(953,4085,2)
(8199,4928,2)
(4888,2124,2)
(5727,5025,2)
(9028,5750,2)
(3337,3942,2)
(4991,5569,2)
(5520,3872,2)
(6108,3570,2)
(4138,4378,2)
(7920,8535,2)
(8911,2585,2)
(4164,6323,2)
(2751,7941,2)
(7046,3705,2)
(6802,175,2)
(1608,8902,2)
(4102,7202,2)
(5720,317,2)
(8660,8362,2)
(1479,4928,2)
(3165,4085,2)
(8638,1139,2)
(6014,7367,2)
(900,8282,2)
(4180,5839,2)
(781,6404,2)
(2386,6128,2)
(5383,5625,2)
(32,1502,2)
(7444,603,2)
(6213,5874,2)
(267,7388,2)
(7692,131,2)
(8217,4196,2)
(8829,5573,2)
(1609,8362,2)
(2301,1502,2)
(2494,6047,2)
(5258,4928,2)
(2663,1502,2)
(4490,4974,2)
(6682,7513,2)
(327,8910,2)
(1801,4022,2)
(7319,720,2)
(5909,8576,2)
(6887,1631,2)
(2952,6599,2)
(2152,4928,2)
(6962,8810,2)
(3546,8159,2)
(485,7154,2)
(6428,3032,2)
(7778,1502,2)
(3660,5025,2)
(4653,4765,2)
(6313,8902,2)
(7600,8499,2)
(63,7359,2)
(4425,1193,2)
(5610,4243,2)
(8492,1166,2)
(4197,1168,2)
(2586,5733,2)
(7644,8423,2)
(6170,2095,2)
(8944,4928,2)
(2775,7438,2)
(5859,2368,2)
(2961,3158,2)
(7558,8964,2)
(6333,7438,2)
(2040,1682,2)
(689,3520,2)
(1123,2325,2)
(1236,8362,2)
(2840,772,2)
(4313,4846,2)
(5213,539,2)
(622,7619,2)
(954,8079,2)
(3135,7826,2)
(6274,3872,2)
(4074,1502,2)
(8368,4397,2)
(7462,4597,2)
(6830,6047,2)
(2171,5207,2)
(1278,4928,2)
(1934,6160,2)
(7960,2893,2)
(4485,7478,2)
(6870,1168,2)
(8734,8362,2)
(3243,5945,2)
(1785,3566,2)
(4786,2032,2)
(7924,554,2)
(923,8362,2)
(3702,5904,2)
(6733,2709,2)
(1394,5886,2)
(6260,4232,2)
(1091,7693,2)
(8203,3218,2)
(235,7517,2)
(4491,2394,2)
(8439,1883,2)
(6713,4928,2)
(5794,7438,2)
(6353,4928,2)
(5142,4928,2)
(6914,5025,2)
(7323,3903,2)
(5987,6124,2)
(5088,6404,2)
(4101,533,2)
(222,1852,2)
(4863,4019,2)
(7948,43,2)
(8292,8425,2)
(9122,7826,2)
(3897,936,2)
(8957,7160,2)
(2450,8241,2)
(2810,6404,2)
(4842,3130,2)
(7476,4934,2)
(7904,6197,2)
(1246,4298,2)
(817,5025,2)
(36,2585,2)
(8436,1502,2)
(7998,1833,2)
(5825,3421,2)
(8395,3924,2)
(8736,3798,2)
(2240,805,2)
(8601,8701,2)
(3674,5922,2)
(2469,4878,2)
(2656,2223,2)
(1924,2705,2)
(1061,3401,2)
(6921,1924,2)
(1635,6673,2)
(5668,1502,2)
(7277,7411,2)
(6119,1502,2)
(5693,6110,2)
(1659,7515,2)
(493,5939,2)
(4148,7653,2)
(5923,4928,2)
(1536,8362,2)
(2839,4928,2)
(4435,7062,2)
(7229,4220,2)
(8269,936,2)
(2323,7359,2)
(1400,3350,2)
(7202,7359,2)
(7090,3570,2)
(4074,3530,2)
(1969,4721,2)
(6737,5534,2)
(770,5922,2)
(5624,1193,2)
(7648,5693,2)
(7991,5115,2)
(1641,5091,2)
(4921,6718,2)
(5294,4955,2)
(8560,3583,2)
(4367,7666,2)
(5704,5969,2)
(6522,7814,2)
(2142,169,2)
(2684,7438,2)
(6847,3791,2)
(3998,5922,2)
(2909,4647,2)
(4269,6731,2)
(8960,7937,2)
(1725,9101,2)
(5611,1502,2)
(3299,1502,2)
(1224,2057,2)
(2684,207,2)
(7025,6404,2)
(4951,7666,2)
(2219,268,2)
(392,4928,2)
(8865,7388,2)
(823,1193,2)
(2547,3125,2)
(7654,7826,2)
(5737,8362,2)
(7386,1502,2)
(4729,3979,2)
(4351,393,2)
(1985,8362,2)
(8081,7598,2)
(2844,5043,2)
(6639,720,2)
(6361,2851,2)
(2767,5043,2)
(279,3239,2)
(1739,3114,2)
(4999,5608,2)
(3266,4196,2)
(6459,2698,2)
(7778,7309,2)
(4268,2994,2)
(4552,4280,2)
(6986,8425,2)
(8153,4485,2)
(5294,8037,2)
(6058,805,2)
(2607,5839,2)
(3620,7826,2)
(6849,2394,2)
(7350,2125,2)
(6586,317,2)
(2189,404,2)
(1418,8566,2)
(1750,3350,2)
(909,1502,2)
(2730,4050,2)
(7887,3247,2)
(4095,8362,2)
(2673,1502,2)
(1110,131,2)
(7656,7826,2)
(9115,1592,2)
(2200,7388,2)
(2289,1890,2)
(7525,8362,2)
(8266,6849,2)
(2075,1731,2)
(1653,4928,2)
(953,6048,2)
(2035,4928,2)
(3530,6711,2)
(8785,8991,2)
(1158,1502,2)
(1627,341,2)
(5407,2445,2)
(788,3549,2)
(6651,4397,2)
(2843,6047,2)
(8959,3125,2)
(4634,6958,2)
(8933,4019,2)
(5177,1515,2)
(510,8271,2)
(7511,6512,2)
(6792,4594,2)
(5294,3303,2)
(8722,1210,2)
(1308,5481,2)
(8558,4878,2)
(3965,2708,2)
(5612,8425,2)
(799,1502,2)
(538,7619,2)
(6858,6396,2)
(7805,5902,2)
(1884,5867,2)
(5412,1890,2)
(5294,2894,2)
(143,5097,2)
(1375,9101,2)
(8117,6512,2)
(5721,1608,2)
(8813,6938,2)
(6351,1502,2)
(7446,6195,2)
(2177,720,2)
(309,5270,2)
(2562,7826,2)
(5741,411,2)
(6309,7905,2)
(2009,1502,2)
(1763,243,2)
(7115,3252,2)
(1492,6672,2)
(4701,4085,2)
(6553,7826,2)
(8092,8833,2)
(4783,7746,2)
(5443,4928,2)
(4072,3836,2)
(5382,5461,2)
(221,2125,2)
(4221,1502,2)
(1518,52,2)
(2658,4232,2)
(7665,7536,2)
(8805,2585,2)
(8692,5043,2)
(5732,5939,2)
(3619,393,2)
(9065,4928,2)
(1206,5703,2)
(3041,6450,2)
(2936,3702,2)
(4869,2464,2)
(8260,4928,2)
(1337,3032,2)
(5228,8362,2)
(2783,463,2)
(1729,7552,2)
(6105,5902,2)
(5870,7517,2)
(7125,183,2)
(5842,4857,2)
(5544,6967,2)
(7508,8362,2)
(3569,2585,2)
(7383,2364,2)
(6483,6148,2)
(4556,5025,2)
(4472,7148,2)
(6276,2394,2)
(467,701,2)
(6756,4934,2)
(2051,3826,2)
(3507,1516,2)
(549,1064,2)
(6578,7941,2)
(2648,9025,2)
(2058,7438,2)
(3222,8574,2)
(7222,7062,2)
(2492,6048,2)
(5536,5992,2)
(2166,4928,2)
(6623,8362,2)
(1701,2032,2)
(1369,1930,2)
(5024,7780,2)
(5397,2394,2)
(332,8362,2)
(3992,6296,2)
(7712,7666,2)
(462,6703,2)
(7520,2445,2)
(7387,4928,2)
(3928,5025,2)
(6304,1919,2)
(3049,533,2)
(5755,1502,2)
(6962,2394,2)
(7172,1502,2)
(481,8799,2)
(6789,7552,2)
(3283,6642,2)
(6304,2703,2)
(3721,7985,2)
(3963,5398,2)
(1853,6673,2)
(4971,5859,2)
(5896,1502,2)
(3985,7912,2)
(3083,1502,2)
(5689,6124,2)
(1354,8079,2)
(2067,1498,2)
(5098,3350,2)
(8209,7826,2)
(2860,8799,2)
(2291,5922,2)
(4941,2125,2)
(2100,573,2)
(4900,131,2)
(4972,3884,2)
(4943,9022,2)
(4052,5233,2)
(3070,7937,2)
(864,8079,2)
(395,6128,2)
(3926,2585,2)
(8472,7438,2)
(6160,1191,2)
(443,847,2)
(8547,8362,2)
(3786,7004,2)
(9002,7202,2)
(7046,6465,2)
(4546,385,2)
(889,8362,2)
(7030,1502,2)
(3678,3798,2)
(560,7369,2)
(7377,1502,2)
(5531,7057,2)
(455,2483,2)
(632,648,2)
(9131,2445,2)
(7441,8825,2)
(3417,1628,2)
(8965,8362,2)
(5753,1502,2)
(4913,4085,2)
(2604,7674,2)
(6963,3527,2)
(2368,7390,2)
(1687,235,2)
(5151,4050,2)
(5315,5445,2)
(3693,7016,2)
(5561,7937,2)
(4845,4928,2)
(3522,7826,2)
(3028,4928,2)
(4612,171,2)
(6318,1156,2)
(1484,5149,2)
(4963,550,2)
(414,7941,2)
(2422,8020,2)
(81,6855,2)
(2320,8678,2)
(6637,5247,2)
(1417,8271,2)
(2854,7091,2)
(6690,6958,2)
(712,2894,2)
(1042,4928,2)
(1389,4928,2)
(5696,3937,2)
(1149,847,2)
(3463,4928,2)
(6332,7666,2)
(5458,5025,2)
(1631,8032,2)
(5558,614,2)
(2003,1306,2)
(3231,1102,2)
(5670,1449,2)
(765,9101,2)
(4124,398,2)
(6124,3534,2)
(6379,3623,2)
(6353,6047,2)
(3263,8362,2)
(3794,5915,2)
(5736,3963,2)
(8197,6008,2)
(5454,1546,2)
(1541,1617,2)
(3185,1889,2)
(4733,720,2)
(9132,6404,2)
(4422,8780,2)
(3757,7517,2)
(2072,8830,2)
(1264,7438,2)
(7203,805,2)
(6319,6738,2)
(4049,3421,2)
(7869,1798,2)
(5383,8627,2)
(1453,3798,2)
(8214,2708,2)
(4472,5559,2)
(890,1502,2)
(2024,4647,2)
(7863,5025,2)
(711,3350,2)
(2425,5234,2)
(3224,3941,2)
(1004,5398,2)
(2580,2555,2)
(8069,6479,2)
(5052,8362,2)
(1877,5693,2)
(365,39,2)
(3109,3965,2)
(4846,5712,2)
(3775,1421,2)
(1988,1591,2)
(2728,4928,2)
(4384,5576,2)
(8632,3570,2)
(1430,169,2)
(3225,7894,2)
(6919,8799,2)
(1254,5902,2)
(426,5712,2)
(710,5576,2)
(4306,8362,2)
(3953,4928,2)
(3638,4805,2)
(8174,3715,2)
(3299,4928,2)
(2104,6673,2)
(8251,4928,2)
(5766,2546,2)
(8163,5839,2)
(1189,720,2)
(15,8501,2)
(3608,4598,2)
(3693,2180,2)
(1687,4928,2)
(6108,3775,2)
(1574,260,2)
(5683,5902,2)
(1156,832,2)
(577,8950,2)
(7576,4071,2)
(4877,7359,2)
(3468,6225,2)
(7929,6645,2)
(7601,3965,2)
(5294,2039,2)
(8955,6108,2)
(3963,8799,2)
(380,3527,2)
(186,3033,2)
(7214,7439,2)
(7375,4247,2)
(5114,3049,2)
(3647,4409,2)
(2869,1128,2)
(4003,254,2)
(7911,7941,2)
(2961,6048,2)
(4545,1502,2)
(5572,2112,2)
(8787,1085,2)
(4541,1193,2)
(420,2609,2)
(7731,1946,2)
(2137,993,2)
(4426,2057,2)
(6609,6048,2)
(3493,4928,2)
(3329,186,2)
(1292,1722,2)
(8547,2535,2)
(2225,4471,2)
(4739,4928,2)
(315,2676,2)
(2471,4928,2)
(2661,3049,2)
(8728,6179,2)
(7062,4360,2)
(7787,8362,2)
(484,7004,2)
(4716,7867,2)
(2700,4928,2)
(3881,4744,2)
(7595,2469,2)
(7137,7161,2)
(5818,8411,2)
(1598,175,2)
(704,8506,2)
(7936,6775,2)
(2787,3570,2)
(4658,1502,2)
(3635,169,2)
(2843,7438,2)
(1905,4304,2)
(5032,802,2)
(8371,4232,2)
(7446,3084,2)
(2666,3134,2)
(885,6561,2)
(5882,3520,2)
(3139,847,2)
(3521,720,2)
(6069,3417,2)
(3726,7826,2)
(845,8832,2)
(9126,3775,2)
(7991,1489,2)
(6562,9076,2)
(3006,8412,2)
(521,4928,2)
(7133,1321,2)
(5800,8362,2)
(4604,9091,2)
(7762,4928,2)
(4673,4928,2)
(7273,3715,2)
(7489,7666,2)
(1476,7826,2)
(1988,2893,2)
(480,6998,2)
(4539,6561,2)
(1685,5617,2)
(9137,3340,2)
(3963,87,2)
(6432,8362,2)
(9028,8020,2)
(6723,5712,2)
(2942,6404,2)
(712,6465,2)
(1196,341,2)
(5810,6133,2)
(3302,2893,2)
(5499,847,2)
(6903,6404,2)
(3036,2249,2)
(4398,6128,2)
(1402,8362,2)
(606,649,2)
(6116,8247,2)
(1734,2092,2)
(3785,5939,2)
(2044,5025,2)
(4360,2738,2)
(2032,7361,2)
(8944,6186,2)
(559,4928,2)
(2988,936,2)
(4646,8362,2)
(666,2964,2)
(2874,6150,2)
(2349,7649,2)
(5210,175,2)
(4650,1133,2)
(7516,720,2)
(5944,131,2)
(8172,3350,2)
(1132,8362,2)
(464,6731,2)
(3750,6703,2)
(2494,4928,2)
(1017,7442,2)
(7812,1306,2)
(6402,8320,2)
(521,8362,2)
(471,720,2)
(2250,7517,2)
(958,4497,2)
(7612,7892,2)
(809,1033,2)
(8647,2926,2)
(5830,4064,2)
(541,6108,2)
(5522,3114,2)
(3848,2851,2)
(5126,8032,2)
(4841,6323,2)
(606,8340,2)
(8453,8748,2)
(8073,3511,2)
(3225,6236,2)
(642,1502,2)
(8829,1228,2)
(2159,2546,2)
(8184,2180,2)
(7645,5902,2)
(4182,4640,2)
(1043,6047,2)
(118,6172,2)
(7046,2893,2)
(3038,5025,2)
(5441,6195,2)
(8800,5526,2)
(3149,212,2)
(6508,2394,2)
(6047,3112,2)
(3338,1502,2)
(1915,6726,2)
(6746,5651,2)
(6758,1502,2)
(6840,4155,2)
(2360,5693,2)
(7546,7098,2)
(659,4196,2)
(1747,8362,2)
(849,1515,2)
(8776,5684,2)
(1977,4928,2)
(2835,4928,2)
(6570,5969,2)
(7674,4019,2)
(3242,2057,2)
(3302,5115,2)
(8555,5867,2)
(4443,3953,2)
(4542,6047,2)
(606,720,2)
(1386,466,2)
(2414,4674,2)
(4682,7762,2)
(5294,1919,2)
(8741,8362,2)
(6450,5147,2)
(5083,8362,2)
(1760,8923,2)
(3288,4928,2)
(404,2483,2)
(1398,1092,2)
(2873,2898,2)
(7091,8032,2)
(8596,5867,2)
(6574,212,2)
(1554,6139,2)
(6216,1634,2)
(3663,1085,2)
(1883,6767,2)
(5353,7666,2)
(4846,8188,2)
(8066,611,2)
(454,1321,2)
(3209,7619,2)
(3482,7450,2)
(381,6773,2)
(5952,266,2)
(3754,5922,2)
(4695,7468,2)
(7180,7450,2)
(8020,6964,2)
(4645,7826,2)
(829,4571,2)
(8755,2585,2)
(1154,5760,2)
(6346,3775,2)
(2758,2445,2)
(2194,8782,2)
(8743,8606,2)
(6672,6703,2)
(4496,2394,2)
(3704,8799,2)
(1979,8278,2)
(1499,385,2)
(6946,8499,2)
(354,6431,2)
(1476,4928,2)
(8165,4934,2)
(7796,5992,2)
(7150,8703,2)
(5957,7720,2)
(3556,3049,2)
(2714,6512,2)
(7229,3583,2)
(7390,2653,2)
(7942,6550,2)
(8893,4857,2)
(2376,5693,2)
(6670,5922,2)
(6769,805,2)
(1425,6566,2)
(6482,1502,2)
(2656,6260,2)
(6493,4928,2)
(8213,8701,2)
(7565,1515,2)
(8360,8436,2)
(6355,3775,2)
(9011,7388,2)
(3864,4085,2)
(3457,8991,2)
(1652,4934,2)
(7074,3032,2)
(2202,1502,2)
(3032,1420,2)
(1646,5969,2)
(2408,3527,2)
(3379,8362,2)
(3751,720,2)
(4332,4928,2)
(8632,1502,2)
(8728,46,2)
(20,4485,2)
(2554,250,2)
(211,6070,2)
(5469,7826,2)
(3929,8541,2)
(6559,4157,2)
(577,8362,2)
(7843,6264,2)
(7651,4928,2)
(3617,3872,2)
(6139,6186,2)
(2905,7359,2)
(4491,4928,2)
(2417,6431,2)
(2282,5712,2)
(8417,539,2)
(914,5100,2)
(983,341,2)
(1548,3265,2)
(7750,1193,2)
(4540,7826,2)
(2858,805,2)
(1436,3937,2)
(3407,5609,2)
(1888,2394,2)
(828,5354,2)
(1755,7826,2)
(8960,6718,2)
(2833,2851,2)
(6003,4928,2)
(926,243,2)
(9145,2585,2)
(5378,2249,2)
(2073,7481,2)
(7046,5115,2)
(5294,6560,2)
(176,6047,2)
(6500,39,2)
(5294,1591,2)
(402,8362,2)
(1532,2609,2)
(2410,1515,2)
(2067,5043,2)
(2869,1228,2)
(5242,4647,2)
(5692,4397,2)
(754,7619,2)
(1582,6351,2)
(4948,4196,2)
(3042,7666,2)
(7005,948,2)
(4483,3098,2)
(8287,3963,2)
(7762,2758,2)
(5781,8576,2)
(4903,3702,2)
(4952,1540,2)
(223,124,2)
(5551,4634,2)
(6805,4019,2)
(4688,7179,2)
(1045,6718,2)
(7640,2609,2)
(3151,3965,2)
(7324,5217,2)
(4094,3928,2)
(8184,4193,2)
(5419,8020,2)
(8313,294,2)
(4702,9101,2)
(6013,2585,2)
(8041,2585,2)
(8227,2445,2)
(7290,8425,2)
(8393,802,2)
(2699,840,2)
(4472,5115,2)
(7826,8282,2)
(8215,4709,2)
(8376,1883,2)
(1358,8447,2)
(4300,2394,2)
(5623,3583,2)
(5563,8830,2)
(3411,1591,2)
(2467,5486,2)
(1775,7826,2)
(9037,7092,2)
(8786,991,2)
(2073,4744,2)
(679,3795,2)
(9008,3583,2)
(2587,3251,2)
(4872,8362,2)
(5718,7619,2)
(9033,554,2)
(9134,720,2)
(4561,4928,2)
(4280,1502,2)
(7938,2038,2)
(987,6512,2)
(4807,7063,2)
(8620,6967,2)
(2720,6058,2)
(3279,1502,2)
(363,1889,2)
(355,4196,2)
(6329,8400,2)
(7896,4928,2)
(1567,7849,2)
(2183,3965,2)
(8833,8566,2)
(3300,6562,2)
(22,847,2)
(5221,2057,2)
(2832,260,2)
(3771,5744,2)
(8518,2401,2)
(1454,6032,2)
(2803,5613,2)
(1844,720,2)
(432,4022,2)
(6984,8362,2)
(7643,5525,2)
(5071,3636,2)
(4534,8516,2)
(412,7867,2)
(4737,7867,2)
(5328,64,2)
(5696,1502,2)
(4778,3702,2)
(8594,2708,2)
(1282,720,2)
(476,8975,2)
(3934,7202,2)
(5791,2783,2)
(3420,6047,2)
(1489,8671,2)
(5319,8399,2)
(4280,4928,2)
(1786,4322,2)
(4411,8320,2)
(8973,6047,2)
(3904,3421,2)
(3185,2459,2)
(403,2705,2)
(1687,1502,2)
(8431,5839,2)
(2146,8362,2)
(7117,8362,2)
(3217,720,2)
(6285,8425,2)
(5320,6512,2)
(1960,9101,2)
(4758,3526,2)
(528,8991,2)
(4289,5310,2)
(3230,5091,2)
(7485,5576,2)
(1584,7826,2)
(9130,1502,2)
(4930,5939,2)
(2564,1409,2)
(2367,4610,2)
(6706,8811,2)
(2731,8159,2)
(3420,7202,2)
(9138,6648,2)
(2507,1383,2)
(4592,7172,2)
(7507,5024,2)
(2516,8499,2)
(6486,2964,2)
(1095,59,2)
(13,8362,2)
(4666,8020,2)
(5871,3421,2)
(9104,7388,2)
(5991,6548,2)
(8207,2585,2)
(5294,8033,2)
(3376,4928,2)
(4640,3702,2)
(685,2394,2)
(8301,7328,2)
(7106,7160,2)
(6304,5244,2)
(235,7813,2)
(432,4765,2)
(5438,7826,2)
(424,7666,2)
(4426,6837,2)
(2008,1502,2)
(5080,4928,2)
(5539,2585,2)
(3306,697,2)
(6834,2483,2)
(5018,4022,2)
(8661,6264,2)
(6762,720,2)
(7151,4953,2)
(7149,6128,2)
(5975,4928,2)
(9106,7117,2)
(5564,7202,2)
(5884,6642,2)
(8499,7450,2)
(3256,6958,2)
(8074,2347,2)
(4914,4360,2)
(3755,4928,2)
(4404,3367,2)
(4472,8188,2)
(8890,5300,2)
(8761,5025,2)
(3715,334,2)
(6782,8072,2)
(6974,8362,2)
(7211,8020,2)
(6302,4928,2)
(2114,7826,2)
(6220,1191,2)
(4257,425,2)
(6748,4224,2)
(1068,539,2)
(6304,3465,2)
(8908,8362,2)
(949,3937,2)
(4054,4196,2)
(1715,418,2)
(4553,4725,2)
(6967,6953,2)
(8703,7552,2)
(1603,7826,2)
(4980,5702,2)
(2311,4232,2)
(7825,6186,2)
(504,1591,2)
(4768,161,2)
(6158,3715,2)
(9093,1832,2)
(8700,7826,2)
(2889,701,2)
(2765,3549,2)
(456,7937,2)
(8090,6938,2)
(1158,8252,2)
(714,805,2)
(4437,3465,2)
(3190,4928,2)
(1789,8362,2)
(770,8991,2)
(5294,1489,2)
(4437,1919,2)
(5022,2609,2)
(8990,1502,2)
(1538,1515,2)
(636,5025,2)
(7087,8278,2)
(3669,4928,2)
(1734,1828,2)
(2719,8008,2)
(7167,2709,2)
(805,1701,2)
(9019,8362,2)
(3823,6404,2)
(3302,5559,2)
(7764,3537,2)
(6297,5525,2)
(6931,7115,2)
(931,5445,2)
(6550,7619,2)
(8386,5025,2)
(1027,7468,2)
(4252,4991,2)
(3728,7202,2)
(586,5686,2)
(4116,1809,2)
(3733,805,2)
(1072,8425,2)
(1396,7179,2)
(4698,6334,2)
(7524,720,2)
(6175,6703,2)
(3285,5922,2)
(5460,2249,2)
(4064,4765,2)
(7206,8584,2)
(662,1502,2)
(8737,1546,2)
(6741,2673,2)
(2869,4551,2)
(2178,1502,2)
(2370,1502,2)
(7912,5200,2)
(8404,1321,2)
(5264,6512,2)
(5902,2837,2)
(4480,476,2)
(1695,6512,2)
(3784,4422,2)
(148,3570,2)
(5665,3307,2)
(7696,6958,2)
(129,9091,2)
(7067,1110,2)
(8992,6692,2)
(8567,5480,2)
(5115,5693,2)
(7138,7619,2)
(9144,936,2)
(5947,6032,2)
(956,2953,2)
(3891,2079,2)
(6228,7666,2)
(4657,1502,2)
(7136,7619,2)
(4881,6058,2)
(702,243,2)
(5129,8362,2)
(3647,5043,2)
(2884,5939,2)
(5294,6252,2)
(3730,4928,2)
(2002,6924,2)
(3856,7849,2)
(9004,4934,2)
(7836,7536,2)
(2180,3705,2)
(4346,317,2)
(8462,6562,2)
(500,1538,2)
(6201,5576,2)
(6457,7338,2)
(4664,4497,2)
(341,6931,2)
(2122,3393,2)
(6506,4842,2)
(5658,87,2)
(6245,8020,2)
(4977,3775,2)
(2453,2709,2)
(8454,1515,2)
(7687,4155,2)
(2865,6702,2)
(6014,8271,2)
(125,936,2)
(1513,4050,2)
(7538,6318,2)
(8053,6014,2)
(5075,3583,2)
(2588,5207,2)
(494,3636,2)
(7234,9101,2)
(1860,5839,2)
(2320,7148,2)
(1503,260,2)
(6453,1924,2)
(1813,4085,2)
(2160,3383,2)
(748,5241,2)
(6399,8362,2)
(7411,2394,2)
(6182,3715,2)
(5661,3775,2)
(7675,6939,2)
(2375,3350,2)
(1933,6323,2)
(7194,8362,2)
(2227,381,2)
(4956,5145,2)
(6654,5608,2)
(8481,2159,2)
(1460,847,2)
(6876,4725,2)
(7030,4928,2)
(2736,4085,2)
(9128,1502,2)
(6003,1502,2)
(2477,4928,2)
(7571,4246,2)
(1258,6562,2)
(3289,5939,2)
(6060,8230,2)
(1712,2394,2)
(3385,4928,2)
(2665,2249,2)
(343,720,2)
(1193,3105,2)
(5762,6491,2)
(7991,5559,2)
(8822,8362,2)
(2495,8437,2)
(8778,3421,2)
(7668,8492,2)
(1484,6195,2)
(8046,5025,2)
(3008,3755,2)
(1270,7821,2)
(7437,4085,2)
(7159,4928,2)
(4932,841,2)
(2449,6998,2)
(8984,2088,2)
(3956,8362,2)
(8278,3865,2)
(4414,720,2)
(7973,3963,2)
(652,1267,2)
(7991,3313,2)
(8427,3636,2)
(6695,3757,2)
(3167,2001,2)
(7845,3520,2)
(8859,5300,2)
(3815,66,2)
(2977,8701,2)
(3144,6128,2)
(5423,8437,2)
(4987,8362,2)
(950,3570,2)
(861,8991,2)
(388,8362,2)
(2432,2325,2)
(7104,4974,2)
(4162,2316,2)
(785,7369,2)
(617,2020,2)
(408,2350,2)
(209,7438,2)
(45,8998,2)
(1255,8271,2)
(1090,6967,2)
(8436,1761,2)
(4950,4224,2)
(4972,8928,2)
(7729,1763,2)
(9037,8987,2)
(3454,539,2)
(8681,4539,2)
(3221,5024,2)
(504,6958,2)
(2897,8799,2)
(6040,2546,2)
(833,8910,2)
(8,243,2)
(9052,2357,2)
(9096,6773,2)
(6621,7552,2)
(2486,3963,2)
(3087,8998,2)
(3224,5481,2)
(8653,6058,2)
(4815,169,2)
(7852,8362,2)
(508,7826,2)
(4116,4415,2)
(8312,4320,2)
(7235,8032,2)
(4142,8074,2)
(8480,7202,2)
(611,1502,2)
(3913,4252,2)
(1625,5247,2)
(4071,1739,2)
(7371,6108,2)
(7846,2017,2)
(5091,2067,2)
(7682,720,2)
(4090,8083,2)
(7471,8701,2)
(3522,2199,2)
(8064,2230,2)
(8312,8681,2)
(4221,4928,2)
(3407,5025,2)
(3182,7862,2)
(5193,212,2)
(5182,8008,2)
(7077,7100,2)
(7129,4022,2)
(4796,2325,2)
(8633,1502,2)
(7449,8362,2)
(1276,1734,2)
(2320,7092,2)
(1338,6048,2)
(5455,5037,2)
(7169,4196,2)
(5552,5025,2)
(5387,8333,2)
(3896,6048,2)
(8551,1064,2)
(5211,7171,2)
(257,6773,2)
(2575,3798,2)
(364,1502,2)
(5158,6730,2)
(7473,8698,2)
(6663,3383,2)
(4125,7590,2)
(5977,4928,2)
(7536,8362,2)
(408,5524,2)
(5118,1502,2)
(6262,1502,2)
(1002,6509,2)
(6761,805,2)
(8988,1102,2)
(373,4140,2)
(6197,1497,2)
(5903,8362,2)
(7348,1502,2)
(3069,8991,2)
(7324,7113,2)
(4905,7515,2)
(2484,8830,2)
(2506,847,2)
(8119,2071,2)
(4753,435,2)
(8498,4176,2)
(1126,847,2)
(9050,4019,2)
(8962,2747,2)
(6543,5525,2)
(1577,3928,2)
(7033,1502,2)
(8913,2912,2)
(2893,6718,2)
(852,8799,2)
(8551,212,2)
(3465,1585,2)
(3251,4497,2)
(4748,7369,2)
(3012,3963,2)
(1391,8362,2)
(7822,4711,2)
(7649,8159,2)
(5332,466,2)
(7615,8425,2)
(4364,317,2)
(8056,3340,2)
(354,3775,2)
(2022,5524,2)
(466,3900,2)
(1708,2546,2)
(3672,4019,2)
(3914,3965,2)
(4851,3135,2)
(4065,4647,2)
(198,5538,2)
(7155,3304,2)
(4555,2394,2)
(8520,4928,2)
(7035,4067,2)
(6852,8788,2)
(6729,8058,2)
(712,3313,2)
(3152,419,2)
(3361,1951,2)
(5867,1231,2)
(7238,8678,2)
(8579,7985,2)
(4156,2441,2)
(8829,598,2)
(1236,7458,2)
(4437,1228,2)
(1669,6967,2)
(2320,1489,2)
(5587,175,2)
(1040,6396,2)
(7628,847,2)
(4890,936,2)
(6736,5922,2)
(3548,8362,2)
(3280,7309,2)
(2358,3062,2)
(6042,6478,2)
(8496,2249,2)
(9043,8362,2)
(5827,991,2)
(1879,9120,2)
(814,2381,2)
(8120,4928,2)
(5630,6404,2)
(881,522,2)
(5111,2347,2)
(4572,2893,2)
(836,6998,2)
(5608,4204,2)
(3211,1502,2)
(770,2473,2)
(6786,4224,2)
(7468,7148,2)
(2938,533,2)
(3912,2043,2)
(2903,1924,2)
(1063,5075,2)
(1633,8306,2)
(5658,7526,2)
(1626,4928,2)
(9044,2032,2)
(5458,3931,2)
(6833,4647,2)
(8906,2032,2)
(8004,5300,2)
(1342,4074,2)
(8637,7826,2)
(6788,2464,2)
(6344,8425,2)
(498,817,2)
(2661,6958,2)
(2991,8362,2)
(1849,2347,2)
(5259,1502,2)
(5080,1502,2)
(8023,8252,2)
(1540,3973,2)
(3584,6128,2)
(4502,2860,2)
(6437,2705,2)
(4623,7202,2)
(4967,5995,2)
(4060,5025,2)
(7625,832,2)
(259,3184,2)
(7678,8362,2)
(8931,1502,2)
(8987,5829,2)
(7879,8362,2)
(4137,4647,2)
(2295,1502,2)
(487,3963,2)
(4570,847,2)
(5294,5244,2)
(7233,8362,2)
(3939,2609,2)
(3320,2698,2)
(8990,7937,2)
(5644,3937,2)
(8625,1617,2)
(5654,3775,2)
(5253,1168,2)
(455,598,2)
(4602,334,2)
(7284,2249,2)
(4048,334,2)
(3390,2152,2)
(6411,385,2)
(1766,284,2)
(4829,3570,2)
(1143,8425,2)
(8566,4076,2)
(1912,6738,2)
(3795,5409,2)
(4375,3032,2)
(4551,2483,2)
(7597,4085,2)
(4852,3527,2)
(4494,1502,2)
(8743,3193,2)
(1982,8826,2)
(1249,1898,2)
(509,2464,2)
(7516,8779,2)
(8215,5922,2)
(6821,7647,2)
(7924,9033,2)
(4542,1502,2)
(6657,3857,2)
(6500,6994,2)
(6408,2038,2)
(7795,4350,2)
(80,3549,2)
(2297,5950,2)
(8181,6479,2)
(852,4928,2)
(8632,4928,2)
(3995,2271,2)
(1887,5867,2)
(205,1502,2)
(2869,3674,2)
(5329,1502,2)
(5428,3185,2)
(4505,2394,2)
(7518,7438,2)
(6032,284,2)
(3441,4634,2)
(1420,1506,2)
(6052,2394,2)
(5010,4647,2)
(6955,212,2)
(7238,598,2)
(7386,175,2)
(4412,3570,2)
(5420,250,2)
(4972,4303,2)
(7955,1502,2)
(2794,1890,2)
(9082,411,2)
(3701,1617,2)
(1904,4928,2)
(4575,720,2)
(8256,8282,2)
(6304,2204,2)
(6961,5608,2)
(3027,3963,2)
(4477,6730,2)
(7813,3757,2)
(8560,7468,2)
(932,701,2)
(6350,8516,2)
(7322,4857,2)
(5231,4140,2)
(1831,8412,2)
(3134,5969,2)
(2246,2249,2)
(5300,4682,2)
(8672,7937,2)
(7312,7552,2)
(2653,7674,2)
(4732,8425,2)
(6711,3428,2)
(6505,8032,2)
(8914,5445,2)
(504,598,2)
(2171,1502,2)
(4932,4878,2)
(6391,1502,2)
(6707,8362,2)
(3282,2700,2)
(2037,7442,2)
(3765,235,2)
(2907,8499,2)
(5909,2568,2)
(4161,3340,2)
(4486,5969,2)
(865,4050,2)
(4231,3702,2)
(6060,2114,2)
(5859,5829,2)
(4959,2483,2)
(5875,991,2)
(7501,1502,2)
(6301,2950,2)
(6471,6404,2)
(9102,4928,2)
(2762,1617,2)
(4373,250,2)
(2554,2737,2)
(3115,5525,2)
(4939,3872,2)
(3840,6218,2)
(634,7849,2)
(4572,4551,2)
(6404,984,2)
(2061,8362,2)
(7054,6512,2)
(4174,3570,2)
(3031,8362,2)
(4298,7566,2)
(93,5753,2)
(1681,6195,2)
(5408,7826,2)
(6023,5992,2)
(1531,7666,2)
(4674,1102,2)
(6108,313,2)
(2732,4928,2)
(8593,4024,2)
(8484,6561,2)
(1414,8362,2)
(3618,1502,2)
(4313,7046,2)
(5134,5969,2)
(2707,8362,2)
(5343,1502,2)
(802,175,2)
(2869,598,2)
(3963,826,2)
(4139,7481,2)
(344,2585,2)
(955,7826,2)
(2962,3808,2)
(1418,3775,2)
(3017,6703,2)
(3135,6434,2)
(5202,243,2)
(5,8276,2)
(8565,8159,2)
(4778,5226,2)
(8218,4847,2)
(6288,6195,2)
(5934,5969,2)
(9037,1128,2)
(361,4928,2)
(7657,1191,2)
(9042,2997,2)
(8032,2322,2)
(3456,4928,2)
(17,6874,2)
(712,2893,2)
(5094,8516,2)
(6304,8987,2)
(5387,7849,2)
(301,5856,2)
(2917,6090,2)
(8593,6404,2)
(1936,2464,2)
(2819,1502,2)
(844,1102,2)
(6375,5472,2)
(9119,1502,2)
(7132,4928,2)
(7999,1502,2)
(751,539,2)
(5234,9089,2)
(2080,5043,2)
(3332,1617,2)
(8358,4050,2)
(5988,317,2)
(407,8362,2)
(8607,8362,2)
(4275,8159,2)
(7945,1502,2)
(504,7100,2)
(5869,7618,2)
(9142,1502,2)
(6,720,2)
(2431,2698,2)
(6352,6562,2)
(2163,3125,2)
(5272,8425,2)
(5923,4224,2)
(8463,6648,2)
(2869,1591,2)
(2372,2016,2)
(2767,2469,2)
(3799,525,2)
(4037,2062,2)
(3966,5693,2)
(4746,7826,2)
(3862,5755,2)
(7642,3350,2)
(7941,6998,2)
(4312,8159,2)
(3755,4548,2)
(2381,5082,2)
(3402,2347,2)
(7119,8032,2)
(1535,5330,2)
(1345,3021,2)
(6640,4928,2)
(3777,6047,2)
(2927,3900,2)
(2296,4193,2)
(5294,408,2)
(6051,7004,2)
(5102,7513,2)
(8829,3465,2)
(7515,8412,2)
(7793,9025,2)
(5330,4928,2)
(8713,8362,2)
(2083,7062,2)
(4747,2125,2)
(7212,1405,2)
(5544,4928,2)
(5208,7900,2)
(8881,6718,2)
(5531,997,2)
(1989,6048,2)
(8389,7388,2)
(4479,3570,2)
(7145,7666,2)
(3734,7941,2)
(2869,5115,2)
(1860,1464,2)
(7992,49,2)
(8128,4840,2)
(5294,5497,2)
(237,2784,2)
(4665,7826,2)
(5717,3862,2)
(211,8637,2)
(1798,5608,2)
(8833,3482,2)
(6404,8576,2)
(1450,3158,2)
(5658,826,2)
(384,539,2)
(210,941,2)
(3788,7179,2)
(7758,3937,2)
(8350,7768,2)
(9021,4085,2)
(4423,8425,2)
(8156,3367,2)
(2551,1934,2)
(1066,1256,2)
(4124,4928,2)
(658,1502,2)
(2383,8566,2)
(3160,2125,2)
(5294,8029,2)
(5294,735,2)
(694,7826,2)
(4597,4565,2)
(3979,2057,2)
(5454,5902,2)
(1965,6548,2)
(7058,8032,2)
(4210,3383,2)
(3355,6745,2)
(1215,6703,2)
(1991,6047,2)
(2716,7826,2)
(2370,8159,2)
(3332,4928,2)
(2278,3340,2)
(7577,7619,2)
(7310,4647,2)
(1733,8067,2)
(7848,7309,2)
(1789,4928,2)
(176,1502,2)
(6731,7666,2)
(3032,1506,2)
(9037,6465,2)
(3953,1502,2)
(2690,2585,2)
(6771,847,2)
(7458,5104,2)
(7304,882,2)
(8877,1193,2)
(3600,1321,2)
(4247,4928,2)
(1803,3965,2)
(3448,7674,2)
(4293,1502,2)
(9083,4928,2)
(73,7131,2)
(2869,7100,2)
(7240,1502,2)
(318,4224,2)
(5749,6396,2)
(2740,8799,2)
(3621,5861,2)
(9081,5732,2)
(5899,3032,2)
(1577,4281,2)
(5870,1738,2)
(4619,7062,2)
(8780,6562,2)
(3919,533,2)
(8824,8362,2)
(5084,2249,2)
(1412,2851,2)
(470,5867,2)
(1665,4085,2)
(2470,7513,2)
(7797,2546,2)
(4382,3702,2)
(7242,2585,2)
(4002,2851,2)
(1142,4744,2)
(2769,3702,2)
(5465,8362,2)
(4056,3159,2)
(1788,8412,2)
(5811,279,2)
(4478,3350,2)
(8223,8362,2)
(4035,4647,2)
(8532,7826,2)
(2767,5902,2)
(2857,4682,2)
(7264,8199,2)
(8022,6718,2)
(7067,3473,2)
(6748,1502,2)
(2581,6718,2)
(305,8362,2)
(5484,4576,2)
(3358,8032,2)
(8829,1489,2)
(5550,2898,2)
(2883,8647,2)
(5789,5100,2)
(970,8362,2)
(3535,982,2)
(4695,8159,2)
(8858,3272,2)
(2026,8362,2)
(5871,5108,2)
(4472,4551,2)
(6757,2898,2)
(7892,3448,2)
(8199,6047,2)
(1343,3510,2)
(1449,4634,2)
(627,8902,2)
(5418,7202,2)
(3899,755,2)
(3159,4050,2)
(194,6334,2)
(5503,8701,2)
(2782,484,2)
(4220,1512,2)
(263,7900,2)
(5562,8362,2)
(2926,8362,2)
(243,1251,2)
(3458,3636,2)
(4236,5392,2)
(8032,3527,2)
(9062,6431,2)
(1644,6186,2)
(1270,2507,2)
(1110,3512,2)
(8319,5247,2)
(1938,4022,2)
(870,5939,2)
(7540,4284,2)
(4287,8362,2)
(7228,3350,2)
(4473,9102,2)
(3140,1731,2)
(8360,1761,2)
(1909,6186,2)
(2676,3963,2)
(3529,6264,2)
(4427,1193,2)
(5088,4928,2)
(3298,3350,2)
(6108,7450,2)
(1387,1502,2)
(4149,3872,2)
(2808,7160,2)
(3192,2020,2)
(8849,1635,2)
(3066,8799,2)
(7893,6302,2)
(1924,7004,2)
(1988,7100,2)
(4871,5902,2)
(2626,8132,2)
(9058,847,2)
(112,7826,2)
(3213,8848,2)
(8036,1502,2)
(5888,8975,2)
(3227,3871,2)
(1962,4497,2)
(8099,9114,2)
(6642,3098,2)
(8589,8516,2)
(8132,1358,2)
(141,6047,2)
(1947,3511,2)
(2310,847,2)
(45,720,2)
(4516,9091,2)
(8678,1502,2)
(3005,7472,2)
(2863,4193,2)
(2933,1617,2)
(1191,1342,2)
(8289,1502,2)
(135,6323,2)
(5294,8678,2)
(7252,2555,2)
(7397,3383,2)
(5873,6703,2)
(2476,8032,2)
(421,1918,2)
(2907,4928,2)
(3874,6435,2)
(6170,5902,2)
(4684,720,2)
(91,6195,2)
(580,8271,2)
(2585,3771,2)
(7361,1193,2)
(6478,5114,2)
(9017,3168,2)
(512,7941,2)
(5830,8830,2)
(6692,1256,2)
(8506,8089,2)
(3137,6431,2)
(7853,2450,2)
(7747,5867,2)
(3450,6128,2)
(4437,908,2)
(3916,6718,2)
(3921,8671,2)
(5850,131,2)
(656,7438,2)
(5751,2136,2)
(3691,8991,2)
(4172,7941,2)
(5869,8362,2)
(9026,8678,2)
(4727,2057,2)
(957,1506,2)
(2616,2546,2)
(1111,4196,2)
(5750,8020,2)
(4042,6195,2)
(8297,3989,2)
(5587,8251,2)
(304,3583,2)
(6873,6505,2)
(719,1502,2)
(2438,6773,2)
(2346,7450,2)
(6105,359,2)
(1039,8362,2)
(7400,5025,2)
(6304,3674,2)
(7996,6323,2)
(7689,1502,2)
(3362,8412,2)
(2305,8888,2)
(927,6404,2)
(6836,3885,2)
(5929,3527,2)
(21,3989,2)
(6314,4022,2)
(7603,7062,2)
(1419,4928,2)
(4648,701,2)
(1993,1832,2)
(6771,8149,2)
(1823,7826,2)
(6670,8247,2)
(3927,720,2)
(4781,246,2)
(8601,2347,2)
(7519,2585,2)
(5043,8516,2)
(299,3421,2)
(2365,7826,2)
(361,4934,2)
(3877,6659,2)
(7594,5608,2)
(8186,8425,2)
(5795,1924,2)
(4390,1502,2)
(4073,6404,2)
(3942,1502,2)
(3294,260,2)
(4440,5487,2)
(8666,8748,2)
(8765,1966,2)
(2530,8499,2)
(6012,8362,2)
(8746,7826,2)
(2864,8362,2)
(4166,720,2)
(7229,6160,2)
(1608,1042,2)
(829,4685,2)
(2055,4928,2)
(2602,1502,2)
(4158,7645,2)
(3503,4350,2)
(1586,5525,2)
(7980,3826,2)
(6601,7202,2)
(1505,6703,2)
(382,936,2)
(4576,431,2)
(3455,7309,2)
(3306,1502,2)
(2662,1487,2)
(3822,7666,2)
(6366,55,2)
(5948,3963,2)
(2869,2893,2)
(2754,8362,2)
(9003,4443,2)
(8227,1502,2)
(441,3725,2)
(6207,5493,2)
(5849,5371,2)
(7618,8362,2)
(5594,2555,2)
(3134,1646,2)
(4572,8678,2)
(1768,4385,2)
(1305,8825,2)
(1480,1507,2)
(7048,6512,2)
(8326,2057,2)
(1180,6703,2)
(1827,4397,2)
(2042,6773,2)
(8179,4928,2)
(2170,2394,2)
(7239,6562,2)
(2403,1809,2)
(1181,4491,2)
(5268,7826,2)
(2053,175,2)
(6928,2445,2)
(7029,89,2)
(2496,212,2)
(5984,720,2)
(2320,5559,2)
(831,3217,2)
(6316,7552,2)
(8239,7892,2)
(8801,8748,2)
(2316,263,2)
(3533,2698,2)
(6035,5867,2)
(8008,6512,2)
(5294,2893,2)
(1494,8362,2)
(2078,3511,2)
(4669,6158,2)
(7590,7269,2)
(7452,554,2)
(8855,1502,2)
(7093,5608,2)
(7372,1731,2)
(5633,3818,2)
(7512,1921,2)
(4915,7403,2)
(2818,5922,2)
(3900,5509,2)
(8659,7619,2)
(4433,4928,2)
(1447,5712,2)
(4324,8576,2)
(8989,7513,2)
(1470,7937,2)
(5294,577,2)
(1075,1955,2)
(5864,2425,2)
(7991,6988,2)
(8810,2394,2)
(8098,8991,2)
(1249,2111,2)
(4717,4928,2)
(1636,7846,2)
(8234,6186,2)
(8066,847,2)
(3599,4647,2)
(8117,720,2)
(920,2808,2)
(987,720,2)
(3161,4140,2)
(7861,8505,2)
(5151,1513,2)
(8284,3616,2)
(6304,8188,2)
(5058,7379,2)
(716,3965,2)
(4313,3411,2)
(5949,847,2)
(7099,1955,2)
(1986,6978,2)
(5431,847,2)
(5461,8362,2)
(547,7207,2)
(1191,6512,2)
(3096,6998,2)
(1434,6404,2)
(8910,8991,2)
(1362,4995,2)
(4313,1988,2)
(9007,8809,2)
(1440,3715,2)
(7984,339,2)
(8039,7029,2)
(3167,5162,2)
(4363,169,2)
(7323,2851,2)
(4296,7648,2)
(1609,4717,2)
(8471,7062,2)
(8515,7619,2)
(546,5525,2)
(1129,5538,2)
(840,1449,2)
(6709,8499,2)
(8672,6323,2)
(4051,2708,2)
(4738,1502,2)
(3127,7828,2)
(7278,4634,2)
(1321,8362,2)
(21,4022,2)
(8399,6435,2)
(2123,8466,2)
(2661,8499,2)
(2389,4830,2)
(6304,1128,2)
(4944,5025,2)
(5950,2611,2)
(1175,1516,2)
(1070,2555,2)
(7671,3937,2)
(1760,5902,2)
(1488,2057,2)
(7563,6047,2)
(1655,5939,2)
(8829,8678,2)
(3794,7256,2)
(9059,3527,2)
(5192,2057,2)
(8052,8400,2)
(6448,2394,2)
(9116,2125,2)
(1201,4775,2)
(7247,7062,2)
(8032,7628,2)
(1615,2057,2)
(6822,936,2)
(2367,7826,2)
(1858,3193,2)
(5631,4934,2)
(6536,6404,2)
(3527,8545,2)
(1991,4928,2)
(2539,2394,2)
(6197,1182,2)
(669,8778,2)
(7714,5939,2)
(8413,6958,2)
(7000,821,2)
(8225,4224,2)
(6533,7941,2)
(3535,8159,2)
(3644,7666,2)
(16,224,2)
(3695,6195,2)
(7021,7826,2)
(8402,1502,2)
(3872,3533,2)
(5474,1502,2)
(1561,8701,2)
(7760,1075,2)
(7959,6431,2)
(2806,5177,2)
(6148,8799,2)
(3019,8362,2)
(8232,7674,2)
(7674,329,2)
(7769,2180,2)
(2737,4928,2)
(4174,148,2)
(8447,3329,2)
(1829,4196,2)
(8919,3940,2)
(4491,6047,2)
(1653,1502,2)
(3602,7666,2)
(1495,2898,2)
(6128,845,2)
(6304,7092,2)
(1231,5737,2)
(5514,2464,2)
(7468,2893,2)
(5159,1502,2)
(3977,8362,2)
(7566,3187,2)
(621,6054,2)
(2080,5902,2)
(9037,932,2)
(6967,6254,2)
(4625,8425,2)
(7599,5712,2)
(3770,3421,2)
(6025,6561,2)
(8505,1717,2)
(3213,7826,2)
(4572,7148,2)
(3853,7826,2)
(5665,4811,2)
(5274,6133,2)
(7999,4928,2)
(4407,4320,2)
(720,8325,2)
(759,2796,2)
(1156,3648,2)
(5839,8499,2)
(4766,2758,2)
(3830,1502,2)
(9080,1168,2)
(7720,1502,2)
(4150,3975,2)
(5264,720,2)
(8477,7841,2)
(1649,5712,2)
(4390,2125,2)
(3834,2555,2)
(4074,4220,2)
(4246,237,2)
(8850,131,2)
(4039,838,2)
(7905,3340,2)
(7841,1366,2)
(9115,131,2)
(7398,6404,2)
(604,2249,2)
(2882,4629,2)
(5152,7369,2)
(6680,6642,2)
(3790,4252,2)
(2460,3798,2)
(8683,4548,2)
(3471,7062,2)
(9124,7908,2)
(5352,2249,2)
(2119,495,2)
(6803,8159,2)
(7846,7317,2)
(8531,1009,2)
(3239,1502,2)
(2327,1168,2)
(8001,5487,2)
(8802,7619,2)
(8855,4928,2)
(3637,6158,2)
(1925,8469,2)
(4185,6718,2)
(3153,1502,2)
(1538,1502,2)
(504,932,2)
(1165,3350,2)
(4507,5461,2)
(272,8209,2)
(3302,7148,2)
(1592,8850,2)
(391,6404,2)
(6803,411,2)
(415,4878,2)
(7549,175,2)
(7984,3905,2)
(905,8560,2)
(5336,1502,2)
(5454,2744,2)
(8489,936,2)
(5062,3829,2)
(7785,4085,2)
(2999,124,2)
(8937,1890,2)
(6860,8362,2)
(2861,5351,2)
(8188,8671,2)
(6852,3965,2)
(3098,7562,2)
(8166,6158,2)
(3865,2705,2)
(4160,5939,2)
(3748,8423,2)
(3095,8425,2)
(3248,418,2)
(6321,8362,2)
(8518,2758,2)
(3793,1502,2)
(963,8701,2)
(7620,4224,2)
(3591,8283,2)
(2834,464,2)
(1744,6124,2)
(5972,6158,2)
(2715,3383,2)
(6728,1502,2)
(8969,1267,2)
(6078,7849,2)
(972,3583,2)
(4345,7207,2)
(3516,3798,2)
(779,6404,2)
(1420,5484,2)
(1718,6225,2)
(721,4928,2)
(3990,734,2)
(755,6958,2)
(7303,8516,2)
(6937,8576,2)
(6646,8562,2)
(101,6318,2)
(2505,317,2)
(3640,5525,2)
(719,4928,2)
(2806,7666,2)
(1242,2325,2)
(4224,7124,2)
(5868,8701,2)
(6320,847,2)
(1565,8425,2)
(7096,5159,2)
(7847,7202,2)
(4313,7960,2)
(2723,5445,2)
(1485,2057,2)
(7468,1591,2)
(727,1502,2)
(6497,4928,2)
(6029,5025,2)
(7408,6404,2)
(8829,1591,2)
(4911,1617,2)
(4772,2555,2)
(8400,8008,2)
(1502,6191,2)
(4076,2180,2)
(8931,4928,2)
(4922,8748,2)
(1828,8499,2)
(57,3965,2)
(7314,4497,2)
(7062,6186,2)
(7593,8362,2)
(1593,3511,2)
(5357,4634,2)
(4424,6773,2)
(4135,5351,2)
(3292,919,2)
(8933,4193,2)
(2907,1502,2)
(1183,9015,2)
(7765,8991,2)
(6938,7575,2)
(8422,5867,2)
(1269,3098,2)
(7959,4744,2)
(105,8320,2)
(6301,254,2)
(4942,5228,2)
(3882,6160,2)
(8337,7265,2)
(1238,6158,2)
(3489,1502,2)
(7377,2394,2)
(849,1256,2)
(1522,7202,2)
(3131,6642,2)
(8891,8362,2)
(9022,7884,2)
(2194,8362,2)
(6866,3421,2)
(7628,6999,2)
(1847,9025,2)
(5642,2464,2)
(6244,4332,2)
(3883,1546,2)
(4282,6128,2)
(8361,5189,2)
(5362,6566,2)
(18,5025,2)
(6367,7892,2)
(4304,8362,2)
(7955,2057,2)
(8853,8362,2)
(8949,8362,2)
(4242,3350,2)
(4548,8566,2)
(7931,5487,2)
(1479,6047,2)
(7359,3241,2)
(9056,5392,2)
(3205,8516,2)
(1954,4760,2)
(908,7000,2)
(6304,7461,2)
(6336,8362,2)
(6592,4251,2)
(1513,1475,2)
(6082,250,2)
(543,2609,2)
(1113,720,2)
(2643,1924,2)
(4487,6195,2)
(3830,4928,2)
(4095,2793,2)
(164,8197,2)
(7160,8910,2)
(3414,1502,2)
(1038,8362,2)
(8569,7179,2)
(1141,4304,2)
(3090,533,2)
(1743,6195,2)
(4083,6958,2)
(1380,8362,2)
(2038,98,2)
(6238,1502,2)
(5132,5525,2)
(504,5559,2)
(5257,5693,2)
(8639,8362,2)
(6025,6047,2)
(6843,1321,2)
(1515,7286,2)
(4434,2269,2)
(490,8020,2)
(5038,7089,2)
(3327,6195,2)
(151,3025,2)
(7838,5188,2)
(4670,7004,2)
(2800,5487,2)
(2980,720,2)
(8220,2801,2)
(3000,1890,2)
(8159,8362,2)
(5790,8425,2)
(3855,7826,2)
(2662,2445,2)
(1701,3386,2)
(2414,8039,2)
(8179,1502,2)
(5781,8604,2)
(1650,1975,2)
(3302,8188,2)
(131,6523,2)
(1895,2585,2)
(725,6133,2)
(5399,6597,2)
(3549,6075,2)
(934,1761,2)
(3067,3989,2)
(3753,1502,2)
(3527,2322,2)
(769,3621,2)
(1895,1446,2)
(8313,6360,2)
(5291,2057,2)
(1271,4169,2)
(4176,2222,2)
(3330,2609,2)
(570,7647,2)
(809,4682,2)
(3121,2445,2)
(2132,5867,2)
(1168,6958,2)
(7540,2180,2)
(962,2016,2)
(5166,8425,2)
(7738,8799,2)
(4115,4744,2)
(4688,4517,2)
(5308,8362,2)
(3817,4085,2)
(2133,243,2)
(2494,8425,2)
(6043,2180,2)
(496,6040,2)
(4098,4995,2)
(4465,8362,2)
(1097,7674,2)
(6805,2180,2)
(1547,1256,2)
(1720,2782,2)
(8401,8362,2)
(2656,1712,2)
(7179,3062,2)
(3613,2249,2)
(8128,5902,2)
(3463,4360,2)
(8271,7666,2)
(7977,1617,2)
(7983,3872,2)
(1688,4928,2)
(960,1168,2)
(3907,7619,2)
(5504,1521,2)
(7140,4050,2)
(3215,847,2)
(8282,626,2)
(7366,8454,2)
(2032,2786,2)
(6108,8566,2)
(6936,8799,2)
(4276,3963,2)
(1221,657,2)
(3054,4085,2)
(8662,8362,2)
(5896,6047,2)
(6070,7826,2)
(6968,701,2)
(7241,9101,2)
(4643,6703,2)
(2889,6968,2)
(6488,260,2)
(8640,8362,2)
(8398,5969,2)
(5856,9115,2)
(5907,7369,2)
(3719,533,2)
(5318,7472,2)
(4472,7092,2)
(6552,1085,2)
(4845,279,2)
(2483,6642,2)
(6265,1306,2)
(3639,7833,2)
(9021,4371,2)
(215,6128,2)
(7388,549,2)
(5759,6404,2)
(2982,2851,2)
(3385,2347,2)
(6410,4765,2)
(6287,3702,2)
(3538,1498,2)
(9066,8201,2)
(7213,1809,2)
(1911,7724,2)
(8039,334,2)
(4563,5712,2)
(1162,1883,2)
(6353,5247,2)
(1783,418,2)
(2848,3350,2)
(8078,2112,2)
(4410,8247,2)
(5524,8213,2)
(4333,7826,2)
(7055,3125,2)
(2896,8362,2)
(5350,1256,2)
(4164,4928,2)
(4443,128,2)
(2874,3872,2)
(2402,7826,2)
(8650,6550,2)
(7841,2964,2)
(7737,5666,2)
(4442,3702,2)
(6074,7622,2)
(3645,7202,2)
(6513,6850,2)
(8981,291,2)
(6576,8362,2)
(2869,7092,2)
(5787,2032,2)
(5922,8991,2)
(1441,5266,2)
(4899,3448,2)
(4719,4928,2)
(8179,6047,2)
(6597,3062,2)
(5847,6404,2)
(8832,995,2)
(3706,1635,2)
(5330,1502,2)
(2018,7647,2)
(8464,7369,2)
(1228,1502,2)
(4331,4878,2)
(2535,8362,2)
(6286,7826,2)
(5932,7674,2)
(8941,5525,2)
(4170,7179,2)
(4677,175,2)
(1886,7202,2)
(8740,6562,2)
(1094,8020,2)
(5294,5559,2)
(8676,343,2)
(6722,7826,2)
(2984,3350,2)
(7471,2347,2)
(3608,6855,2)
(8627,2585,2)
(6493,1502,2)
(6974,1502,2)
(1512,6002,2)
(3811,8991,2)
(7010,8671,2)
(7046,6560,2)
(3340,6880,2)
(1551,7826,2)
(1256,7659,2)
(8411,9101,2)
(7435,4928,2)
(3311,6128,2)
(1334,4928,2)
(6111,1617,2)
(1553,2810,2)
(2178,6512,2)
(3284,2440,2)
(2427,3527,2)
(95,6073,2)
(8370,748,2)
(7991,8678,2)
(2739,6958,2)
(2518,8412,2)
(3253,1924,2)
(3632,2929,2)
(7605,1502,2)
(4252,7060,2)
(1067,5025,2)
(7666,6495,2)
(2099,1256,2)
(2410,1267,2)
(2143,8197,2)
(7749,4085,2)
(9129,936,2)
(329,3672,2)
(4824,223,2)
(4437,2893,2)
(3647,5902,2)
(348,3965,2)
(1694,8825,2)
(2796,6404,2)
(4791,175,2)
(45,119,2)
(7889,4928,2)
(6568,287,2)
(662,175,2)
(1361,3421,2)
(4140,8970,2)
(4522,2057,2)
(1588,6512,2)
(8797,2171,2)
(4108,4085,2)
(43,6195,2)
(5218,4459,2)
(3324,8576,2)
(8728,7468,2)
(2010,1798,2)
(4792,6334,2)
(4311,175,2)
(504,6465,2)
(1727,8991,2)
(1167,3185,2)
(9120,6195,2)
(2937,3705,2)
(6198,1201,2)
(6977,805,2)
(3688,5199,2)
(4539,8484,2)
(6354,6318,2)
(5067,3855,2)
(6396,260,2)
(998,6501,2)
(5912,7202,2)
(3976,1617,2)
(9027,15,2)
(8760,4878,2)
(5154,6850,2)
(6439,8032,2)
(3049,3087,2)
(3163,6318,2)
(7468,5559,2)
(5108,3770,2)
(8201,8022,2)
(3291,3917,2)
(7707,3917,2)
(1054,5939,2)
(2629,2420,2)
(8590,1918,2)
(6304,1616,2)
(8942,4824,2)
(1214,1306,2)
(5432,6195,2)
(2168,5525,2)
(2108,8425,2)
(2699,5043,2)
(5806,7666,2)
(5322,720,2)
(7734,9051,2)
(1026,8362,2)
(2167,5922,2)
(7274,2032,2)
(5095,6323,2)
(4802,847,2)
(1959,7849,2)
(4633,3032,2)
(3826,8362,2)
(1239,3527,2)
(8487,8362,2)
(597,1191,2)
(6688,805,2)
(7637,3902,2)
(2930,8362,2)
(2878,2020,2)
(9037,1489,2)
(6102,6404,2)
(5619,3965,2)
(5879,8362,2)
(2407,4944,2)
(3241,4187,2)
(4005,398,2)
(950,8566,2)
(4955,7826,2)
(4878,1214,2)
(3488,8362,2)
(6170,5043,2)
(7780,4422,2)
(9066,6718,2)
(1150,6264,2)
(2692,1682,2)
(2080,341,2)
(1874,847,2)
(3585,8362,2)
(3623,3900,2)
(2268,4193,2)
(8110,8020,2)
(7991,2894,2)
(4452,8159,2)
(5676,7826,2)
(6304,3652,2)
(3718,5213,2)
(7205,2961,2)
(191,8020,2)
(920,7160,2)
(7208,8065,2)
(1006,7004,2)
(2393,3062,2)
(7877,2032,2)
(4628,6703,2)
(1686,550,2)
(5283,4050,2)
(1651,726,2)
(8436,1515,2)
(4286,1092,2)
(6988,6938,2)
(7153,6128,2)
(3929,3549,2)
(1838,4541,2)
(8297,432,2)
(6868,8197,2)
(1460,4928,2)
(7157,2394,2)
(7810,4928,2)
(3227,3715,2)
(51,5928,2)
(422,4196,2)
(7015,3965,2)
(5424,4304,2)
(2036,2851,2)
(2709,3032,2)
(5177,1502,2)
(1032,8362,2)
(713,8362,2)
(2912,8282,2)
(3236,7515,2)
(5772,5025,2)
(984,4954,2)
(7753,7596,2)
(8690,7826,2)
(8368,398,2)
(3749,6855,2)
(6951,1635,2)
(8590,8505,2)
(5997,5900,2)
(466,7451,2)
(5680,4928,2)
(2227,257,2)
(6430,2208,2)
(538,1502,2)
(1148,3527,2)
(8545,5871,2)
(3594,2898,2)
(980,3350,2)
(9102,1502,2)
(5951,1635,2)
(1316,8081,2)
(2806,6482,2)
(8792,4182,2)
(285,3872,2)
(2226,5991,2)
(7839,1168,2)
(9027,7207,2)
(4272,5712,2)
(3500,4928,2)
(2459,1889,2)
(4503,317,2)
(4734,3636,2)
(75,720,2)
(8047,5939,2)
(8659,7178,2)
(7912,6090,2)
(1461,6512,2)
(4888,303,2)
(1303,4928,2)
(5340,7826,2)
(3901,805,2)
(1552,131,2)
(269,7202,2)
(961,3703,2)
(2045,6195,2)
(3779,7335,2)
(6210,4232,2)
(3319,6998,2)
(7814,4928,2)
(1323,6967,2)
(7425,8362,2)
(1212,3963,2)
(787,915,2)
(898,6175,2)
(5306,550,2)
(7672,3963,2)
(1405,175,2)
(7768,6697,2)
(3994,1635,2)
(1205,838,2)
(7915,8499,2)
(2473,4928,2)
(2178,720,2)
(3267,2629,2)
(603,2359,2)
(85,6404,2)
(7347,3163,2)
(6455,5480,2)
(3819,1502,2)
(5113,4928,2)
(1307,1890,2)
(1832,2445,2)
(3610,8425,2)
(8877,6818,2)
(8976,7941,2)
(1193,733,2)
(8467,8159,2)
(8948,1335,2)
(1911,539,2)
(8501,7207,2)
(3609,1366,2)
(2612,5712,2)
(4657,6124,2)
(301,131,2)
(9019,7468,2)
(370,2057,2)
(4696,9101,2)
(7296,6264,2)
(2501,8498,2)
(8126,8020,2)
(4615,3440,2)
(8739,7571,2)
(2046,6404,2)
(6394,7202,2)
(1553,8195,2)
(1714,3775,2)
(6372,4085,2)
(2737,1502,2)
(2788,7937,2)
(4,8799,2)
(3519,1306,2)
(8086,5370,2)
(2071,1428,2)
(7727,6133,2)
(5104,8362,2)
(6627,7472,2)
(4075,7619,2)
(6304,6427,2)
(8678,6158,2)
(6003,8362,2)
(8528,7388,2)
(609,672,2)
(65,720,2)
(1642,8227,2)
(5311,615,2)
(4572,7100,2)
(7382,7647,2)
(3240,4548,2)
(5248,7826,2)
(5149,6195,2)
(5294,2462,2)
(2505,4503,2)
(2458,7571,2)
(62,1343,2)
(2062,1883,2)
(5106,8701,2)
(4508,5969,2)
(8005,8362,2)
(8417,7763,2)
(5237,2249,2)
(8481,2546,2)
(3238,7552,2)
(2430,3715,2)
(321,5282,2)
(133,8362,2)
(2401,2758,2)
(5294,4373,2)
(8562,212,2)
(4689,3775,2)
(6153,2125,2)
(4313,4437,2)
(3349,1498,2)
(4742,7548,2)
(6811,6958,2)
(5856,558,2)
(5641,1502,2)
(3963,5030,2)
(1004,7526,2)
(4213,7202,2)
(2574,5371,2)
(1290,2441,2)
(8829,4551,2)
(6325,8671,2)
(6705,4232,2)
(6846,4475,2)
(8902,7826,2)
(5294,598,2)
(7901,1502,2)
(4009,8499,2)
(1373,7826,2)
(3639,2789,2)
(5379,7369,2)
(4070,8849,2)
(345,243,2)
(1628,1498,2)
(457,2394,2)
(4559,1682,2)
(4017,8310,2)
(4247,1502,2)
(5321,6133,2)
(8759,3094,2)
(7459,8362,2)
(3828,7826,2)
(8029,7442,2)
(2851,6323,2)
(734,6479,2)
(3025,4943,2)
(8710,3527,2)
(1176,7619,2)
(6792,997,2)
(799,8276,2)
(7889,1502,2)
(5949,6771,2)
(6949,7666,2)
(8945,4928,2)
(2837,509,2)
(6752,1191,2)
(5945,8701,2)
(6561,3676,2)
(9078,915,2)
(5969,8922,2)
(5764,3963,2)
(7311,5043,2)
(878,8362,2)
(8636,4928,2)
(5991,1901,2)
(5521,1731,2)
(5722,4350,2)
(8092,8260,2)
(4805,8362,2)
(205,4928,2)
(1802,8362,2)
(3417,6048,2)
(8829,2893,2)
(7341,4934,2)
(6355,3570,2)
(1136,5939,2)
(5131,8576,2)
(6899,7965,2)
(5395,7647,2)
(1908,1617,2)
(136,4535,2)
(6738,5712,2)
(2262,8726,2)
(3587,3382,2)
(4046,2555,2)
(5658,5030,2)
(1940,1193,2)
(8032,8283,2)
(2531,1883,2)
(5005,3955,2)
(6896,802,2)
(1474,2942,2)
(3442,5024,2)
(6752,7521,2)
(4258,3702,2)
(7571,7670,2)
(2209,6404,2)
(872,6133,2)
(4704,6404,2)
(2005,4004,2)
(858,6405,2)
(7486,2587,2)
(5294,9007,2)
(5036,6047,2)
(400,697,2)
(7427,6186,2)
(3370,4928,2)
(8122,1731,2)
(5656,5909,2)
(2784,6090,2)
(1949,4350,2)
(5785,1908,2)
(504,8678,2)
(2803,5902,2)
(8230,7826,2)
(712,1591,2)
(5944,1549,2)
(5099,5525,2)
(718,8247,2)
(7697,4928,2)
(1739,5797,2)
(5629,7202,2)
(6783,8271,2)
(3428,1168,2)
(929,8362,2)
(733,1785,2)
(6726,4176,2)
(2839,3032,2)
(793,5782,2)
(6996,6032,2)
(1648,7202,2)
(4458,317,2)
(6561,6364,2)
(1682,4961,2)
(4653,3928,2)
(7069,243,2)
(1449,2073,2)
(3690,7666,2)
(5919,5461,2)
(8509,539,2)
(4164,1502,2)
(841,4878,2)
(7624,539,2)
(1186,8362,2)
(5684,7826,2)
(5927,8425,2)
(242,4928,2)
(1946,1882,2)
(6502,539,2)
(3725,3212,2)
(3330,4928,2)
(521,1502,2)
(1549,131,2)
(2994,4176,2)
(370,4928,2)
(875,4196,2)
(7484,7826,2)
(8703,5583,2)
(4846,2893,2)
(5373,7438,2)
(1376,2464,2)
(2957,7207,2)
(6103,2708,2)
(6461,3306,2)
(3949,8948,2)
(5199,4833,2)
(7546,7826,2)
(871,4995,2)
(7583,8362,2)
(5524,2347,2)
(1185,936,2)
(2082,4224,2)
(4493,5867,2)
(3270,1617,2)
(4357,9091,2)
(1120,1502,2)
(775,8362,2)
(1943,847,2)
(3799,4155,2)
(8081,7432,2)
(4634,2516,2)
(3825,2898,2)
(3472,8252,2)
(876,4892,2)
(2629,5939,2)
(1259,4252,2)
(3218,8032,2)
(328,4928,2)
(1033,1502,2)
(7768,3817,2)
(1438,5566,2)
(7468,1489,2)
(4635,1502,2)
(7550,5207,2)
(869,5693,2)
(4652,6967,2)
(6390,2585,2)
(4590,7468,2)
(1109,2112,2)
(4944,1306,2)
(8136,1502,2)
(2007,6692,2)
(6304,5573,2)
(3629,8362,2)
(7905,3252,2)
(5792,2621,2)
(3658,9019,2)
(7468,1128,2)
(492,4928,2)
(4095,2548,2)
(993,1924,2)
(5023,4196,2)
(7981,9024,2)
(2462,3636,2)
(2346,8566,2)
(6689,2057,2)
(3696,4085,2)
(4675,5025,2)
(4942,3485,2)
(2275,3705,2)
(7887,7536,2)
(7717,1502,2)
(5282,881,2)
(3869,2585,2)
(7512,1731,2)
(7587,4350,2)
(3664,6938,2)
(6987,7520,2)
(8962,3350,2)
(6265,5025,2)
(7265,4928,2)
(4316,4196,2)
(1483,3823,2)
(1688,1502,2)
(3888,720,2)
(2224,7202,2)
(4803,6730,2)
(6880,6883,2)
(7562,6431,2)
(6317,4397,2)
(5600,8991,2)
(3870,3965,2)
(205,7062,2)
(5259,6047,2)
(59,1832,2)
(6889,6642,2)
(3083,4928,2)
(644,606,2)
(7413,8839,2)
(4437,2894,2)
(3865,9125,2)
(6121,6718,2)
(2315,8701,2)
(7182,3963,2)
(7060,7329,2)
(6747,2347,2)
(2795,2445,2)
(6565,936,2)
(5203,6703,2)
(6304,1837,2)
(7590,8527,2)
(7046,4551,2)
(1116,2954,2)
(6192,3527,2)
(2624,7513,2)
(7720,3583,2)
(3386,7890,2)
(2929,1516,2)
(2105,533,2)
(8031,5047,2)
(7899,8425,2)
(1050,4934,2)
(5853,7338,2)
(1385,1502,2)
(8339,9021,2)
(4846,1591,2)
(7196,4725,2)
(681,1193,2)
(5709,1502,2)
(7759,8701,2)
(7309,6868,2)
(6736,1502,2)
(3672,2202,2)
(2953,5867,2)
(5109,4193,2)
(2709,483,2)
(3612,3985,2)
(7760,1955,2)
(5616,8370,2)
(2713,3937,2)
(4131,4928,2)
(7638,5320,2)
(7257,6491,2)
(3836,6550,2)
(3302,7100,2)
(6395,720,2)
(3968,6289,2)
(6629,3350,2)
(44,4221,2)
(1410,4744,2)
(505,8362,2)
(3502,3928,2)
(8544,7523,2)
(929,1380,2)
(6960,2032,2)
(640,398,2)
(8932,7160,2)
(7872,7208,2)
(8451,4928,2)
(3372,7992,2)
(3925,7309,2)
(559,7826,2)
(4892,131,2)
(2609,6483,2)
(3302,7092,2)
(8089,6958,2)
(1833,3965,2)
(4513,2249,2)
(7957,3873,2)
(1026,4928,2)
(3912,8032,2)
(8515,538,2)
(5459,5904,2)
(4328,370,2)
(4155,7921,2)
(5294,3831,2)
(3113,2249,2)
(3094,2704,2)
(7029,1102,2)
(2652,7826,2)
(24,8362,2)
(4115,1628,2)
(3499,6512,2)
(7943,1502,2)
(1942,7379,2)
(3738,5923,2)
(4602,5695,2)
(8961,2994,2)
(9155,2585,2)
(2111,1898,2)
(6830,5538,2)
(4691,8362,2)
(5447,533,2)
(8140,5461,2)
(3127,8809,2)
(7786,2801,2)
(4391,4085,2)
(3566,4635,2)
(752,4485,2)
(1291,6047,2)
(2076,2057,2)
(2985,7436,2)
(1873,4647,2)
(5240,7849,2)
(4104,3928,2)
(854,805,2)
(4283,1599,2)
(3345,697,2)
(5207,9072,2)
(7008,8032,2)
(4394,670,2)
(141,4928,2)
(274,7985,2)
(876,8934,2)
(8275,8830,2)
(496,2546,2)
(2777,2440,2)
(5769,7442,2)
(317,7215,2)
(5001,3350,2)
(4441,802,2)
(6749,3326,2)
(7374,4928,2)
(5356,1502,2)
(1714,7450,2)
(6669,1306,2)
(4766,2445,2)
(1353,1460,2)
(2024,1502,2)
(5293,4291,2)
(3024,8362,2)
(8934,2708,2)
(5874,3350,2)
(3216,5043,2)
(665,1256,2)
(1111,1502,2)
(5309,5445,2)
(721,5487,2)
(7214,7826,2)
(6953,936,2)
(3338,4928,2)
(2341,3636,2)
(166,1502,2)
(7862,9025,2)
(7630,5789,2)
(6700,7826,2)
(5782,3417,2)
(5831,5867,2)
(1410,2961,2)
(7828,212,2)
(5086,4928,2)
(3501,3049,2)
(8799,7526,2)
(5069,5480,2)
(6032,1766,2)
(3917,7552,2)
(8332,2394,2)
(4106,6346,2)
(5543,7867,2)
(4027,6730,2)
(4437,8037,2)
(5233,8505,2)
(3825,4824,2)
(5294,7100,2)
(1625,4270,2)
(3085,1298,2)
(262,5969,2)
(4904,3125,2)
(3418,4196,2)
(1092,2440,2)
(8609,8362,2)
(6710,8748,2)
(131,4647,2)
(5636,3937,2)
(2106,181,2)
(6231,4196,2)
(3917,6730,2)
(1053,341,2)
(8966,4928,2)
(3515,1321,2)
(2262,5043,2)
(4601,806,2)
(1172,2325,2)
(5848,720,2)
(3819,235,2)
(3449,6186,2)
(364,4304,2)
(7764,3965,2)
(3917,5693,2)
(6580,7394,2)
(940,9041,2)
(3543,936,2)
(4690,3937,2)
(8244,4304,2)
(3376,1502,2)
(3958,3933,2)
(623,8079,2)
(6525,8362,2)
(5138,8362,2)
(5761,8865,2)
(606,8180,2)
(2249,350,2)
(5725,8362,2)
(8832,7341,2)
(1634,8825,2)
(7294,5024,2)
(5294,1128,2)
(1475,4928,2)
(8191,6236,2)
(6620,4928,2)
(102,6404,2)
(248,3350,2)
(3269,2441,2)
(7174,8471,2)
(4500,7450,2)
(5571,8287,2)
(6837,2057,2)
(9135,4224,2)
(8151,5807,2)
(2325,3082,2)
(8718,7359,2)
(5424,364,2)
(5319,4509,2)
(3965,8382,2)
(4582,3527,2)
(5996,141,2)
(3811,5922,2)
(8541,1502,2)
(2087,8271,2)
(2206,550,2)
(518,6404,2)
(9137,4206,2)
(2204,4995,2)
(6175,4928,2)
(6676,7202,2)
(5665,8254,2)
(8938,3182,2)
(5338,3125,2)
(1739,3367,2)
(7610,8362,2)
(2877,8362,2)
(7161,4995,2)
(4341,2126,2)
(8208,498,2)
(7308,8214,2)
(3406,8576,2)
(4266,830,2)
(2049,2801,2)
(1311,7826,2)
(3168,3775,2)
(9123,2241,2)
(6200,8074,2)
(3326,8362,2)
(8188,2487,2)
(7299,4252,2)
(819,4071,2)
(3486,1502,2)
(3519,5025,2)
(2442,6404,2)
(4682,7370,2)
(6270,8247,2)
(831,3698,2)
(4602,1502,2)
(5245,8362,2)
(4233,6512,2)
(7543,7826,2)
(1921,1502,2)
(8271,1394,2)
(5683,5784,2)
(6171,250,2)
(1882,5218,2)
(7670,5902,2)
(7994,5869,2)
(1872,2124,2)
(33,6703,2)
(2536,4090,2)
(3401,1502,2)
(1487,2445,2)
(8329,3775,2)
(2779,4647,2)
(8039,1102,2)
(614,1776,2)
(3067,4022,2)
(9037,3674,2)
(2130,5969,2)
(2392,7004,2)
(5348,603,2)
(3655,8830,2)
(7463,5010,2)
(2095,291,2)
(10,5693,2)
(7675,7826,2)
(3886,4928,2)
(6635,3963,2)
(5739,6435,2)
(2849,6133,2)
(581,3775,2)
(2573,212,2)
(4897,4422,2)
(4780,8362,2)
(3677,7012,2)
(6347,2564,2)
(7406,8799,2)
(8856,6642,2)
(6303,4682,2)
(1632,2708,2)
(7207,5207,2)
(8868,8948,2)
(1349,8799,2)
(6338,7552,2)
(6458,3113,2)
(1102,21,2)
(6725,2347,2)
(7261,1502,2)
(3792,3213,2)
(8365,7517,2)
(3391,7999,2)
(4585,1321,2)
(1312,5538,2)
(6368,597,2)
(930,4928,2)
(1621,3826,2)
(3380,2851,2)
(6802,278,2)
(8373,7369,2)
(8794,2249,2)
(3777,1502,2)
(3746,3798,2)
(2791,7447,2)
(7783,4744,2)
(8974,8668,2)
(6523,7463,2)
(1446,2585,2)
(4913,7785,2)
(2475,8008,2)
(2772,1502,2)
(3508,936,2)
(2100,7481,2)
(6285,4928,2)
(569,4928,2)
(3958,1761,2)
(2994,8217,2)
(8863,305,2)
(8199,1502,2)
(147,5939,2)
(4828,3527,2)
(9152,212,2)
(5829,5859,2)
(4873,4928,2)
(6534,5025,2)
(2320,2113,2)
(2969,6195,2)
(3973,7826,2)
(8260,1502,2)
(2020,4409,2)
(8003,3114,2)
(5392,4071,2)
(4236,17,2)
(3486,4928,2)
(8155,7826,2)
(7003,720,2)
(7166,1502,2)
(493,5558,2)
(3409,7666,2)
(4150,2181,2)
(7884,3330,2)
(981,7674,2)
(2109,1502,2)
(3112,9093,2)
(4925,8247,2)
(6008,4928,2)
(1939,5300,2)
(2009,4928,2)
(3164,847,2)
(1597,8032,2)
(5067,7826,2)
(660,8902,2)
(8383,1168,2)
(3319,4928,2)
(156,5525,2)
(6218,4928,2)
(2014,7513,2)
(1152,2507,2)
(3191,8362,2)
(7171,3529,2)
(92,7442,2)
(9036,216,2)
(6998,8362,2)
(4281,4653,2)
(7415,235,2)
(7994,8362,2)
(3128,8425,2)
(5456,5700,2)
(5472,4397,2)
(99,539,2)
(4849,8362,2)
(4657,6047,2)
(8770,7826,2)
(5389,384,2)
(5546,6343,2)
(2664,4485,2)
(8952,6548,2)
(1762,1502,2)
(4048,393,2)
(2901,8566,2)
(905,2262,2)
(174,5796,2)
(4437,7092,2)
(1759,7062,2)
(5170,603,2)
(7819,2298,2)
(7898,8402,2)
(2557,8252,2)
(9122,2753,2)
(8774,6491,2)
(3524,5992,2)
(504,5115,2)
(1268,8362,2)
(7683,2709,2)
(4879,9091,2)
(1069,7826,2)
(1861,662,2)
(279,7937,2)
(3924,1032,2)
(5992,4116,2)
(5941,2427,2)
(4374,2825,2)
(8488,8008,2)
(6497,6334,2)
(3771,8929,2)
(8499,3570,2)
(7579,8020,2)
(9046,7826,2)
(8853,1026,2)
(55,317,2)
(1254,2638,2)
(3848,4915,2)
(4668,4050,2)
(4851,2914,2)
(2839,1502,2)
(1964,5608,2)
(2751,6324,2)
(8591,3252,2)
(1387,4928,2)
(806,5025,2)
(8141,720,2)
(1273,4974,2)
(3838,6047,2)
(813,533,2)
(5403,7934,2)
(6522,7826,2)
(372,4475,2)
(5466,6626,2)
(2828,1502,2)
(6221,6738,2)
(8372,6958,2)
(1566,4246,2)
(1876,1794,2)
(4175,8171,2)
(9117,8448,2)
(6698,3158,2)
(6304,6512,2)
(2415,2057,2)
(2294,5025,2)
(6110,7552,2)
(3988,7202,2)
(4211,5992,2)
(8471,7603,2)
(472,3705,2)
(683,5025,2)
(6661,3511,2)
(3003,2801,2)
(233,2801,2)
(4968,4934,2)
(3546,411,2)
(3133,7826,2)
(4892,301,2)
(3387,4224,2)
(3621,8499,2)
(3758,7388,2)
(3887,8362,2)
(5329,3583,2)
(805,7729,2)
(6237,4196,2)
(2101,7485,2)
(5147,385,2)
(7420,4050,2)
(3138,2708,2)
(21,5018,2)
(6930,2555,2)
(501,1321,2)
(607,5043,2)
(6264,3397,2)
(2271,1375,2)
(5071,1502,2)
(8752,317,2)
(1881,8362,2)
(5941,7686,2)
(8276,2758,2)
(8826,3583,2)
(3259,4878,2)
(1924,1749,2)
(3716,6882,2)
(1978,8425,2)
(3550,3826,2)
(5731,2851,2)
(624,2961,2)
(5755,4928,2)
(6512,4634,2)
(9037,8678,2)
(6791,3794,2)
(8838,8020,2)
(8343,4258,2)
(7645,3098,2)
(7188,259,2)
(5051,7826,2)
(3941,3978,2)
(6953,5437,2)
(1120,4928,2)
(2196,3383,2)
(6855,2249,2)
(8771,3421,2)
(6290,3965,2)
(1859,770,2)
(6072,6404,2)
(1925,2049,2)
(2555,7196,2)
(1797,3775,2)
(3476,7674,2)
(2269,7202,2)
(9095,2347,2)
(3130,4649,2)
(8671,6730,2)
(2024,4928,2)
(9100,4928,2)
(1428,2109,2)
(8320,8825,2)
(3595,2404,2)
(1284,2773,2)
(7514,8362,2)
(1493,7513,2)
(3396,5839,2)
(4763,2057,2)
(2829,8562,2)
(162,7619,2)
(7789,7160,2)
(7105,5922,2)
(5803,5635,2)
(2318,3527,2)
(5618,7438,2)
(7698,720,2)
(3657,2621,2)
(8058,6084,2)
(5100,7311,2)
(7811,2032,2)
(6975,6493,2)
(908,5525,2)
(7064,720,2)
(5646,1270,2)
(2055,5969,2)
(6306,6512,2)
(2125,3426,2)
(5050,5744,2)
(919,1617,2)
(6582,847,2)
(5033,8362,2)
(7810,1502,2)
(5294,6465,2)
(1503,1599,2)
(5942,1502,2)
(3542,1367,2)
(2369,6703,2)
(2601,8183,2)
(1898,5616,2)
(5634,8425,2)
(3346,651,2)
(5878,4232,2)
(2281,5904,2)
(8073,1974,2)
(4644,533,2)
(229,1321,2)
(1233,131,2)
(2605,7389,2)
(4052,8505,2)
(8293,3899,2)
(7061,8335,2)
(4860,805,2)
(801,936,2)
(7858,7202,2)
(4954,5891,2)
(6749,8362,2)
(4265,6621,2)
(3791,1502,2)
(8464,1502,2)
(7814,7826,2)
(1934,1502,2)
(3401,4647,2)
(1524,2057,2)
(4408,4224,2)
(5481,5025,2)
(1279,6998,2)
(3426,8362,2)
(1572,5218,2)
(969,7826,2)
(9037,4986,2)
(8800,4590,2)
(5025,8278,2)
(2954,1502,2)
(8996,6195,2)
(2836,6404,2)
(7946,4190,2)
(3119,2057,2)
(1491,6640,2)
(5122,4744,2)
(4658,4928,2)
(1173,411,2)
(7143,1502,2)
(5280,8362,2)
(742,5525,2)
(948,6334,2)
(1651,8032,2)
(5176,7389,2)
(5251,2394,2)
(4187,852,2)
(3526,7666,2)
(1389,1502,2)
(909,701,2)
(5294,1451,2)
(6021,8362,2)
(8459,7941,2)
(3179,8931,2)
(1456,3110,2)
(4119,1321,2)
(232,131,2)
(5278,418,2)
(5363,8505,2)
(1724,6703,2)
(4077,6648,2)
(1088,8362,2)
(504,2894,2)
(3588,5392,2)
(5482,7826,2)
(5867,7547,2)
(1467,5969,2)
(6558,1256,2)
(3473,5387,2)
(9008,1502,2)
(8829,5244,2)
(721,1502,2)
(618,8423,2)
(1970,7359,2)
(1227,1197,2)
(8454,1502,2)
(6823,2057,2)
(6002,9101,2)
(793,3417,2)
(1257,6562,2)
(2514,5392,2)
(6317,6375,2)
(3397,8666,2)
(4459,8980,2)
(3657,4928,2)
(712,8188,2)
(7991,8037,2)
(6304,4166,2)
(95,5047,2)
(6318,8425,2)
(3543,4928,2)
(1769,8032,2)
(5167,805,2)
(1595,3636,2)
(3553,5025,2)
(1141,8244,2)
(4114,7826,2)
(3099,3350,2)
(8809,5761,2)
(4092,5025,2)
(7378,7450,2)
(4187,8799,2)
(4873,7371,2)
(2156,220,2)
(5981,8362,2)
(675,4509,2)
(1030,212,2)
(3591,2708,2)
(2960,8671,2)
(5116,6404,2)
(4640,6047,2)
(6855,6855,2)
(8255,1809,2)
(2945,6561,2)
(3136,8107,2)
(2994,2963,2)
(4081,719,2)
(2011,7892,2)
(5943,2394,2)
(8537,1535,2)
(2733,720,2)
(6398,8217,2)
(3789,2851,2)
(3881,5712,2)
(916,7202,2)
(8276,2445,2)
(7332,7985,2)
(4437,3313,2)
(1613,4934,2)
(1585,3540,2)
(2751,6533,2)
(8474,3715,2)
(1698,4928,2)
(8242,3527,2)
(799,1515,2)
(8782,4928,2)
(1155,5759,2)
(6781,1306,2)
(4816,3965,2)
(7141,1448,2)
(3094,317,2)
(1817,4928,2)
(278,175,2)
(2204,7774,2)
(3184,2585,2)
(8900,4224,2)
(2650,6195,2)
(6672,1502,2)
(7026,3049,2)
(2243,8576,2)
(1235,6703,2)
(6098,8362,2)
(5625,4432,2)
(3075,3564,2)
(5970,4196,2)
(7887,5077,2)
(5285,6323,2)
(4183,1502,2)
(4575,6512,2)
(917,936,2)
(8542,6802,2)
(1025,3288,2)
(4675,1306,2)
(6365,6642,2)
(1832,8518,2)
(2133,1654,2)
(8187,2851,2)
(8738,7160,2)
(6561,2394,2)
(3063,3319,2)
(3923,7849,2)
(2978,8252,2)
(647,8032,2)
(7991,2113,2)
(4554,7359,2)
(8280,4928,2)
(5486,4647,2)
(5411,4928,2)
(2460,5336,2)
(8633,4928,2)
(7498,4788,2)
(3632,1516,2)
(5415,3294,2)
(332,5043,2)
(899,2125,2)
(2498,2425,2)
(2574,8948,2)
(5148,6561,2)
(6383,5025,2)
(2171,4928,2)
(8779,2766,2)
(7468,3313,2)
(8566,4193,2)
(431,1502,2)
(1898,8466,2)
(2749,3965,2)
(4111,533,2)
(2893,6323,2)
(1483,6404,2)
(7784,6550,2)
(4236,753,2)
(6673,8271,2)
(8043,1635,2)
(6530,4928,2)
(7556,7359,2)
(1964,2466,2)
(8691,1515,2)
(5440,7826,2)
(3591,4892,2)
(7351,5341,2)
(7720,7468,2)
(1130,2394,2)
(304,7468,2)
(4069,5474,2)
(5493,4928,2)
(7922,8611,2)
(618,1502,2)
(4019,2180,2)
(4442,4928,2)
(2644,8991,2)
(4220,9101,2)
(4238,7826,2)
(8670,5693,2)
(4951,2898,2)
(5188,3636,2)
(9073,2686,2)
(52,5992,2)
(1037,6102,2)
(4022,6379,2)
(4846,8678,2)
(7159,1502,2)
(5186,4196,2)
(5567,4178,2)
(2330,7826,2)
(8071,4928,2)
(3970,3965,2)
(1517,1231,2)
(1368,5025,2)
(5107,7438,2)
(7917,7826,2)
(1810,4019,2)
(4115,6431,2)
(4942,2906,2)
(8273,332,2)
(9071,4928,2)
(5425,5969,2)
(8862,251,2)
(2627,7552,2)
(2872,6404,2)
(6724,1731,2)
(8729,6512,2)
(460,4928,2)
(1871,2555,2)
(1451,7666,2)
(7670,5043,2)
(2953,1502,2)
(6242,8362,2)
(2208,807,2)
(1509,5939,2)
(8796,8875,2)
(154,533,2)
(187,7062,2)
(4694,2705,2)
(7570,8074,2)
(5025,2705,2)
(1476,1502,2)
(1365,4179,2)
(8651,4541,2)
(3506,7202,2)
(6569,5576,2)
(447,131,2)
(6982,8527,2)
(3951,701,2)
(5078,1502,2)
(944,847,2)
(6392,5043,2)
(795,847,2)
(8008,8310,2)
(6916,3217,2)
(1383,1890,2)
(4105,5525,2)
(6791,169,2)
(8910,6658,2)
(1260,250,2)
(8805,4059,2)
(1688,8362,2)
(7948,6195,2)
(3680,847,2)
(2487,8671,2)
(6510,4928,2)
(5801,2708,2)
(2030,7826,2)
(4386,6938,2)
(4502,4,2)
(5189,3632,2)
(8694,9015,2)
(2763,7826,2)
(4731,6730,2)
(7984,5082,2)
(7438,6300,2)
(6157,805,2)
(9043,4928,2)
(4031,5038,2)
(688,6896,2)
(3250,7941,2)
(2809,2325,2)
(7473,8701,2)
(5477,5389,2)
(1240,2394,2)
(1423,4744,2)
(1364,4224,2)
(7190,8425,2)
(5200,7571,2)
(165,2585,2)
(3145,7035,2)
(1199,3880,2)
(4823,8362,2)
(1919,7000,2)
(7764,2564,2)
(3542,8362,2)
(8180,2184,2)
(4658,7450,2)
(2074,847,2)
(5525,7000,2)
(2178,4928,2)
(5085,6850,2)
(882,8576,2)
(5333,7388,2)
(4849,155,2)
(3963,7526,2)
(7755,3963,2)
(8560,9091,2)
(3703,4071,2)
(3462,5030,2)
(2752,8032,2)
(2978,5305,2)
(7439,7826,2)
(8010,9101,2)
(1027,1502,2)
(8739,9040,2)
(3937,5109,2)
(182,7004,2)
(4200,4928,2)
(6025,1502,2)
(69,6830,2)
(5797,3663,2)
(7240,4928,2)
(2693,5939,2)
(7303,3917,2)
(336,7826,2)
(1884,4928,2)
(1714,3570,2)
(1837,9015,2)
(343,4139,2)
(522,6855,2)
(4457,8282,2)
(7111,8991,2)
(4206,2417,2)
(4122,3570,2)
(6262,4928,2)
(3555,6404,2)
(9035,8276,2)
(3775,8566,2)
(2368,3393,2)
(4293,720,2)
(1556,5939,2)
(1187,7207,2)
(6306,720,2)
(5484,1506,2)
(7593,1502,2)
(5950,3757,2)
(4762,8247,2)
(1643,7369,2)
(5686,8841,2)
(6304,6853,2)
(6591,6497,2)
(8195,6404,2)
(4043,7515,2)
(2117,4928,2)
(6799,5730,2)
(1053,2080,2)
(5356,802,2)
(1365,5878,2)
(1585,7674,2)
(6547,7666,2)
(7042,4873,2)
(8206,3217,2)
(3710,5024,2)
(8051,8032,2)
(2533,6567,2)
(5191,197,2)
(1232,6128,2)
(169,2621,2)
(2545,8576,2)
(1108,2546,2)
(5759,1502,2)
(7629,5025,2)
(2919,8362,2)
(7479,3872,2)
(3677,5265,2)
(8851,4928,2)
(8892,1502,2)
(5864,2496,2)
(606,5747,2)
(9063,3192,2)
(5097,3583,2)
(9037,4985,2)
(6941,4196,2)
(8829,8188,2)
(8247,4624,2)
(4447,4304,2)
(1974,1515,2)
(9141,8576,2)
(5005,4634,2)
(6024,2445,2)
(1265,2994,2)
(8826,1502,2)
(4063,6236,2)
(2464,5110,2)
(120,3826,2)
(2220,2546,2)
(4969,5025,2)
(5206,3965,2)
(4313,504,2)
(7443,7826,2)
(1521,250,2)
(1283,6550,2)
(4820,5037,2)
(2793,2835,2)
(1654,702,2)
(614,5939,2)
(2136,4928,2)
(3586,6195,2)
(8123,6967,2)
(4178,609,2)
(4036,7513,2)
(5294,742,2)
(2162,7536,2)
(2685,1924,2)
(8875,3158,2)
(7062,630,2)
(4817,4362,2)
(6360,3963,2)
(6980,4995,2)
(1374,8362,2)
(4498,8799,2)
(3001,6731,2)
(5145,4196,2)
(2821,8566,2)
(906,8825,2)
(1794,2057,2)
(1764,7309,2)
(3325,423,2)
(4620,4541,2)
(2773,8362,2)
(4565,4085,2)
(4085,7156,2)
(9018,5794,2)
(7707,4928,2)
(7701,5922,2)
(1270,8283,2)
(1636,6195,2)
(596,4050,2)
(3651,4548,2)
(7384,8362,2)
(4931,8074,2)
(7231,291,2)
(8611,2057,2)
(9096,9119,2)
(693,1502,2)
(4991,7060,2)
(7423,8074,2)
(2599,8576,2)
(329,4019,2)
(3302,598,2)
(8311,4824,2)
(8177,3098,2)
(1980,4422,2)
(4107,9101,2)
(8753,3878,2)
(4125,8527,2)
(905,8561,2)
(9023,6938,2)
(2379,3705,2)
(5229,3421,2)
(263,5902,2)
(3250,4928,2)
(7450,3840,2)
(5049,549,2)
(771,2002,2)
(4750,2057,2)
(4437,6853,2)
(1785,8362,2)
(7364,3350,2)
(2313,8499,2)
(2782,8278,2)
(312,6751,2)
(6207,8362,2)
(2995,6648,2)
(5199,3382,2)
(5769,5648,2)
(2869,6465,2)
(8136,6550,2)
(3484,1085,2)
(8394,3995,2)
(7392,6731,2)
(2012,8701,2)
(7642,2021,2)
(1333,847,2)
(4492,2180,2)
(1411,131,2)
(2803,5950,2)
(1559,393,2)
(7659,8991,2)
(5683,5928,2)
(9090,8425,2)
(3817,6048,2)
(3490,7309,2)
(1202,5037,2)
(3433,1502,2)
(6715,419,2)
(1011,7536,2)
(1526,1924,2)
(2922,8362,2)
(9041,5100,2)
(3319,1502,2)
(6071,2686,2)
(1253,6323,2)
(4271,8400,2)
(5509,3169,2)
(1179,8991,2)
(201,2394,2)
(3440,5668,2)
(6491,8910,2)
(6372,6048,2)
(6427,3716,2)
(2285,8499,2)
(7439,3486,2)
(1416,8362,2)
(3350,1115,2)
(1825,5025,2)
(7671,2925,2)
(4699,5902,2)
(5234,8825,2)
(8200,7612,2)
(891,5867,2)
(1988,8678,2)
(4071,3367,2)
(1133,3409,2)
(1210,6057,2)
(7559,7937,2)
(6257,3350,2)
(8022,6323,2)
(7948,2650,2)
(8226,8362,2)
(1549,4928,2)
(9037,7137,2)
(1677,720,2)
(3423,5003,2)
(4007,8362,2)
(2407,4675,2)
(998,1321,2)
(8650,4072,2)
(4558,7826,2)
(2757,5807,2)
(5611,4928,2)
(1741,4196,2)
(4015,7438,2)
(7991,3674,2)
(9040,5043,2)
(7949,5480,2)
(1746,8499,2)
(1629,3421,2)
(7464,8362,2)
(5771,4022,2)
(3903,7475,2)
(1206,8799,2)
(3137,343,2)
(8358,6224,2)
(5995,1502,2)
(6728,4928,2)
(2401,1502,2)
(3411,2893,2)
(1267,8247,2)
(1520,2483,2)
(236,8659,2)
(6637,5259,2)
(6475,8671,2)
(2567,7192,2)
(2142,4928,2)
(2681,6958,2)
(552,6512,2)
(5172,2708,2)
(2699,5902,2)
(3836,2635,2)
(5957,8423,2)
(3757,9062,2)
(4222,3158,2)
(331,1810,2)
(4757,5118,2)
(7472,2621,2)
(7805,5043,2)
(5943,4518,2)
(153,169,2)
(6423,8362,2)
(2380,8576,2)
(4022,334,2)
(7414,5037,2)
(5489,6134,2)
(5211,1027,2)
(1091,7826,2)
(8205,2020,2)
(2979,5480,2)
(2067,5902,2)
(7602,6745,2)
(3854,3340,2)
(1745,4360,2)
(2320,1128,2)
(2508,5939,2)
(2850,3928,2)
(1592,131,2)
(2471,1502,2)
(8851,1502,2)
(8822,5141,2)
(3313,1502,2)
(1340,8271,2)
(554,5840,2)
(684,3570,2)
(1003,7826,2)
(8203,8032,2)
(5589,5992,2)
(7977,4294,2)
(1248,8499,2)
(905,1423,2)
(371,4928,2)
(1799,8362,2)
(6357,6512,2)
(1246,997,2)
(593,7808,2)
(3777,4471,2)
(9076,7338,2)
(7590,5730,2)
(1352,6404,2)
(4704,4433,2)
(4807,1682,2)
(2700,1502,2)
(2193,5693,2)
(4687,539,2)
(2376,6730,2)
(5369,5922,2)
(6999,2025,2)
(7046,7148,2)
(40,175,2)
(297,8032,2)
(4413,6855,2)
(8606,3193,2)
(7302,2546,2)
(4857,5712,2)
(5044,5939,2)
(1503,943,2)
(2489,7438,2)
(862,2311,2)
(1539,5300,2)
(8576,8362,2)
(3230,5902,2)
(900,2974,2)
(2400,171,2)
(1795,6404,2)
(1660,8902,2)
(4006,5359,2)
(4204,3370,2)
(7181,3217,2)
(2825,6889,2)
(8948,7379,2)
(2687,3321,2)
(2079,4490,2)
(5122,6566,2)
(1558,6290,2)
(5238,3511,2)
(3572,8423,2)
(2109,7369,2)
(8874,4878,2)
(3653,8499,2)
(124,7666,2)
(8124,5525,2)
(5927,4732,2)
(6912,6133,2)
(2541,2440,2)
(1971,8362,2)
(9142,5839,2)
(1856,8293,2)
(712,4085,2)
(2239,9091,2)
(5881,3817,2)
(1924,2443,2)
(2063,8362,2)
(6650,8362,2)
(2265,3299,2)
(2792,4019,2)
(7481,701,2)
(5790,5498,2)
(4502,1160,2)
(2428,3965,2)
(8059,8362,2)
(976,6938,2)
(7411,4542,2)
(9018,7438,2)
(6883,4932,2)
(8522,5867,2)
(6057,3350,2)
(6127,250,2)
(5443,1502,2)
(7970,1102,2)
(2503,2032,2)
(3235,8310,2)
(8032,7821,2)
(8500,3963,2)
(1540,7826,2)
(4193,3688,2)
(9051,877,2)
(1955,697,2)
(179,8362,2)
(7005,4920,2)
(3639,6128,2)
(1516,7621,2)
(4315,3965,2)
(4559,3963,2)
(7132,3417,2)
(8210,8362,2)
(933,7867,2)
(3642,8799,2)
(6792,585,2)
(4108,6048,2)
(2385,6958,2)
(2951,1306,2)
(1045,7937,2)
(4623,5398,2)
(2182,3702,2)
(5359,4928,2)
(450,4928,2)
(6426,7371,2)
(8543,131,2)
(8835,8362,2)
(6546,4286,2)
(326,6732,2)
(1835,4509,2)
(1945,6047,2)
(8586,6048,2)
(6714,720,2)
(1152,7821,2)
(5489,5902,2)
(4829,1502,2)
(12,7826,2)
(7515,1831,2)
(8335,6404,2)
(6584,8362,2)
(2577,8008,2)
(5607,4995,2)
(6020,2057,2)
(406,2851,2)
(8695,4647,2)
(2351,2708,2)
(3873,4196,2)
(5080,6047,2)
(5914,1191,2)
(8402,4928,2)
(4524,6938,2)
(5374,4019,2)
(4776,3350,2)
(940,266,2)
(2756,7309,2)
(8278,1924,2)
(5097,5445,2)
(5976,8362,2)
(379,7619,2)
(3032,8362,2)
(4670,6562,2)
(2348,5969,2)
(9072,1152,2)
(9090,4928,2)
(1334,7359,2)
(4455,4928,2)
(8624,8094,2)
(2895,5867,2)
(1455,1794,2)
(3528,3125,2)
(3630,8362,2)
(3818,169,2)
(8839,3414,2)
(7468,2894,2)
(2718,3350,2)
(3960,8276,2)
(6056,3464,2)
(8672,6718,2)
(8452,5928,2)
(311,8466,2)
(7046,5559,2)
(5998,3872,2)
(1033,6047,2)
(4847,6238,2)
(1243,3448,2)
(4525,1617,2)
(5392,961,2)
(6960,638,2)
(1620,4928,2)
(8576,8864,2)
(1638,9085,2)
(7594,7093,2)
(2311,1502,2)
(2855,8576,2)
(4472,7461,2)
(392,1502,2)
(3457,4928,2)
(315,3963,2)
(1314,720,2)
(4437,6988,2)
(6105,8499,2)
(7710,2708,2)
(7722,3965,2)
(2891,3350,2)
(5209,9133,2)
(4437,8678,2)
(5177,7666,2)
(4010,3963,2)
(6450,385,2)
(2362,3448,2)
(6416,3049,2)
(6057,5098,2)
(3971,1832,2)
(8811,6105,2)
(6967,936,2)
(8862,7941,2)
(4813,7438,2)
(247,2686,2)
(6585,6404,2)
(5835,4928,2)
(5286,2555,2)
(6867,8701,2)
(832,5166,2)
(4521,2032,2)
(3091,3549,2)
(4182,3702,2)
(4273,6738,2)
(1925,2801,2)
(3674,7460,2)
(423,6216,2)
(8791,1502,2)
(7623,7666,2)
(5886,2898,2)
(2320,2894,2)
(2834,6731,2)
(4985,1502,2)
(4074,3583,2)
(4036,5102,2)
(8806,4928,2)
(1311,6522,2)
(850,8701,2)
(2990,550,2)
(1975,8668,2)
(3979,1502,2)
(7574,7450,2)
(6198,2898,2)
(804,6736,2)
(4835,6344,2)
(2126,5939,2)
(7208,8008,2)
(4155,997,2)
(5531,5024,2)
(7143,8197,2)
(5763,8362,2)
(5948,1369,2)
(1918,8505,2)
(8169,39,2)
(8804,3965,2)
(8510,7826,2)
(5828,2708,2)
(4313,4572,2)
(3614,2180,2)
(2669,6133,2)
(3015,338,2)
(2111,8370,2)
(8904,7371,2)
(2124,5025,2)
(1171,3636,2)
(4266,847,2)
(703,6958,2)
(6438,131,2)
(5730,8527,2)
(2622,1043,2)
(3228,8576,2)
(134,1321,2)
(8863,8362,2)
(6062,3350,2)
(7663,4350,2)
(1916,4523,2)
(3997,847,2)
(4246,6090,2)
(237,6090,2)
(1267,6739,2)
(4178,7666,2)
(4548,3570,2)
(2126,3267,2)
(7854,6032,2)
(5461,3924,2)
(7315,2758,2)
(385,9052,2)
(1472,2889,2)
(8105,4509,2)
(1221,7476,2)
(6304,4373,2)
(8818,5796,2)
(5260,8830,2)
(4649,7202,2)
(8296,5025,2)
(6551,7826,2)
(2226,6548,2)
(5805,6931,2)
(3570,7362,2)
(2600,2394,2)
(3280,2734,2)
(1889,5091,2)
(3110,5078,2)
(7687,3582,2)
(853,8197,2)
(5554,7202,2)
(7830,3448,2)
(1793,598,2)
(6633,2469,2)
(731,8427,2)
(4018,1008,2)
(7954,2088,2)
(1339,7034,2)
(6992,8991,2)
(8161,8991,2)
(6841,1267,2)
(8883,2057,2)
(4376,6718,2)
(431,4928,2)
(2527,5807,2)
(4476,3383,2)
(2016,8525,2)
(1846,3757,2)
(4312,411,2)
(4420,1348,2)
(3372,4397,2)
(3296,175,2)
(1103,2118,2)
(7256,3905,2)
(3,3872,2)
(6198,1840,2)
(52,1392,2)
(1246,8585,2)
(7468,5445,2)
(5775,1483,2)
(8480,6047,2)
(6,6512,2)
(44,8362,2)
(3033,8362,2)
(3859,5024,2)
(4859,4443,2)
(1806,6958,2)
(3272,2792,2)
(3865,1924,2)
(3627,4085,2)
(6642,6718,2)
(2161,5247,2)
(4730,1389,2)
(3941,5025,2)
(1806,8499,2)
(5487,1883,2)
(2792,4744,2)
(5904,3963,2)
(2589,1502,2)
(7706,8425,2)
(7318,6318,2)
(212,8809,2)
(8081,2585,2)
(8485,8388,2)
(9037,598,2)
(2320,3313,2)
(6701,7438,2)
(5405,8527,2)
(605,8990,2)
(3793,8701,2)
(4437,707,2)
(3083,3217,2)
(8262,4834,2)
(2579,7666,2)
(4527,8437,2)
(4430,4934,2)
(5931,7826,2)
(207,3337,2)
(6304,642,2)
(251,8459,2)
(1475,4050,2)
(8311,5066,2)
(4634,3049,2)
(8366,805,2)
(1958,6124,2)
(7328,8425,2)
(6783,8053,2)
(5350,8991,2)
(5092,4085,2)
(2987,5939,2)
(8064,2394,2)
(2869,5559,2)
(2642,6479,2)
(7934,6718,2)
(4340,6561,2)
(4938,847,2)
(2298,4928,2)
(3101,6491,2)
(5055,403,2)
(5294,136,2)
(7856,3775,2)
(8882,235,2)
(7361,7750,2)
(228,6334,2)
(69,5538,2)
(6774,6850,2)
(5807,7552,2)
(8973,4928,2)
(8893,4744,2)
(5883,8516,2)
(8495,7666,2)
(893,2057,2)
(4583,212,2)
(8885,4658,2)
(1557,4784,2)
(7007,2394,2)
(2113,4878,2)
(1346,8032,2)
(1776,4930,2)
(3219,6048,2)
(5137,5778,2)
(1988,4551,2)
(144,6195,2)
(3129,2363,2)
(1298,7468,2)
(2440,2834,2)
(2347,73,2)
(7216,6637,2)
(5525,7674,2)
(5294,8188,2)
(1930,3963,2)
(8126,6241,2)
(4673,1502,2)
(7565,5922,2)
(5366,471,2)
(5752,3448,2)
(6724,9083,2)
(4020,533,2)
(8958,7359,2)
(5452,7202,2)
(1589,7941,2)
(7156,2961,2)
(8222,2249,2)
(5802,5889,2)
(5311,1727,2)
(7953,4085,2)
(357,5867,2)
(6355,7450,2)
(1071,701,2)
(3731,8362,2)
(4061,8362,2)
(9037,5115,2)
(2626,8447,2)
(5097,1502,2)
(8067,2180,2)
(5139,2057,2)
(1237,2008,2)
(5325,805,2)
(6968,1502,2)
(4155,7004,2)
(5095,7937,2)
(4048,8827,2)
(1365,7438,2)
(2637,1804,2)
(304,7536,2)
(8826,5445,2)
(2649,3636,2)
(8571,8362,2)
(6895,3527,2)
(2320,598,2)
(7230,1617,2)
(1008,5025,2)
(1369,3963,2)
(6252,8362,2)
(8783,8276,2)
(6179,5818,2)
(7004,8765,2)
(8184,4019,2)
(2942,1502,2)
(8922,543,2)
(5730,8847,2)
(4326,8425,2)
(8347,7202,2)
(1107,4497,2)
(8152,8362,2)
(6528,6642,2)
(4535,2477,2)
(7176,7900,2)
(3900,393,2)
(3153,8067,2)
(1046,8499,2)
(8517,8991,2)
(8536,7941,2)
(5660,6186,2)
(2625,8159,2)
(1765,2585,2)
(1321,860,2)
(7166,4928,2)
(8673,1168,2)
(89,7004,2)
(394,7826,2)
(5066,4824,2)
(2493,7826,2)
(7422,1502,2)
(571,124,2)
(6424,8159,2)
(5658,4961,2)
(8584,1502,2)
(7934,1653,2)
(1399,393,2)
(8380,5576,2)
(354,8566,2)
(1427,7826,2)
(2916,3636,2)
(8014,4409,2)
(8309,3702,2)
(8544,7826,2)
(9091,9015,2)
(5707,6512,2)
(6324,8194,2)
(4493,2875,2)
(5733,4928,2)
(7201,7517,2)
(6606,4293,2)
(6746,533,2)
(7475,2851,2)
(7219,3557,2)
(1679,2575,2)
(9037,7461,2)
(814,5867,2)
(1252,1890,2)
(2496,5673,2)
(1302,6850,2)
(5269,1534,2)
(6318,832,2)
(3811,8247,2)
(2003,5025,2)
(6813,8362,2)
(4754,4746,2)
(3996,6323,2)
(6431,8960,2)
(3286,7826,2)
(3777,4928,2)
(6304,5115,2)
(6853,1168,2)
(7819,2125,2)
(894,3872,2)
(5989,936,2)
(7991,1228,2)
(4909,3417,2)
(4082,4350,2)
(1198,8362,2)
(59,3112,2)
(5961,4232,2)
(1515,4878,2)
(579,554,2)
(4361,266,2)
(7239,4670,2)
(1771,5867,2)
(3172,3032,2)
(2084,3702,2)
(5709,6550,2)
(891,4928,2)
(7563,8799,2)
(6933,2394,2)
(3850,8437,2)
(3927,6512,2)
(5411,6047,2)
(8504,539,2)
(5910,6048,2)
(430,186,2)
(723,3940,2)
(783,6048,2)
(1716,539,2)
(224,8425,2)
(2221,6508,2)
(6889,7004,2)
(3342,4928,2)
(2241,6512,2)
(4255,7552,2)
(5835,603,2)
(8139,2249,2)
(6804,1890,2)
(2546,6461,2)
(8251,175,2)
(6772,7515,2)
(5673,212,2)
(4979,5465,2)
(7582,1191,2)
(5295,6718,2)
(1988,7148,2)
(8545,3421,2)
(7461,533,2)
(2980,6512,2)
(7359,1682,2)
(3816,8875,2)
(7235,3669,2)
(5316,8362,2)
(3435,2125,2)
(461,5950,2)
(8442,2364,2)
(3102,6158,2)
(648,1890,2)
(1393,533,2)
(6380,7619,2)
(544,8498,2)
(5322,7971,2)
(5837,5867,2)
(5906,1267,2)
(4842,7202,2)
(1861,175,2)
(321,5549,2)
(2664,4928,2)
(8945,8362,2)
(1995,8498,2)
(7044,1231,2)
(3697,7826,2)
(2947,2801,2)
(220,3185,2)
(1960,4765,2)
(3101,7257,2)
(8929,6047,2)
(6418,720,2)
(3073,5904,2)
(2398,1633,2)
(4885,8362,2)
(8820,8362,2)
(4437,7461,2)
(6896,5356,2)
(9000,8498,2)
(1295,9044,2)
(7226,5927,2)
(8825,8825,2)
(6850,3089,2)
(1115,8520,2)
(62,6120,2)
(3997,8028,2)
(764,890,2)
(7876,7207,2)
(8231,6745,2)
(8692,8612,2)
(4374,7771,2)
(4614,4634,2)
(1916,4443,2)
(2112,8499,2)
(2005,6703,2)
(5162,2898,2)
(5305,8252,2)
(2599,2380,2)
(6076,3917,2)
(5594,2898,2)
(5559,3142,2)
(2806,5048,2)
(3656,9025,2)
(1028,3583,2)
(8071,6703,2)
(5573,3775,2)
(7353,2441,2)
(3265,4085,2)
(5464,8811,2)
(4640,4928,2)
(706,8499,2)
(5965,2088,2)
(5124,8548,2)
(6503,7202,2)
(5294,3624,2)
(5265,2854,2)
(6198,8849,2)
(4528,3775,2)
(8348,7619,2)
(8994,6730,2)
(1007,39,2)
(5862,5154,2)
(8634,3869,2)
(7589,805,2)
(495,2124,2)
(5990,4224,2)
(4150,2336,2)
(5383,2585,2)
(9021,7961,2)
(2739,190,2)
(8228,5867,2)
(7095,7985,2)
(3302,6465,2)
(7935,3520,2)
(4454,1498,2)
(6595,6855,2)
(8619,1558,2)
(3955,4634,2)
(6571,5867,2)
(1160,8799,2)
(5548,3549,2)
(1529,3114,2)
(8424,6195,2)
(1534,7371,2)
(4577,1053,2)
(3381,8362,2)
(8019,8362,2)
(3482,3775,2)
(3686,676,2)
(7369,2440,2)
(5984,6512,2)
(7356,7536,2)
(7225,5879,2)
(1867,4634,2)
(6718,7004,2)
(270,6186,2)
(8829,1128,2)
(6705,4928,2)
(1684,6773,2)
(8032,4892,2)
(2576,554,2)
(6579,7849,2)
(7689,3350,2)
(3906,8362,2)
(6549,5207,2)
(8036,4928,2)
(1152,8283,2)
(8836,3367,2)
(7394,7826,2)
(6669,5025,2)
(1634,2496,2)
(362,4928,2)
(372,1753,2)
(2560,7674,2)
(6948,7666,2)
(8498,5266,2)
(6985,2180,2)
(7790,5902,2)
(70,847,2)
(8323,7619,2)
(2248,1502,2)
(7925,8948,2)
(5851,2347,2)
(339,6530,2)
(4962,5922,2)
(16,8425,2)
(9102,131,2)
(5112,2709,2)
(2114,8902,2)
(4362,4541,2)
(6693,8362,2)
(7734,6958,2)
(4573,4022,2)
(693,6195,2)
(8414,8647,2)
(8560,1502,2)
(6987,2445,2)
(8361,1516,2)
(3909,2180,2)
(4325,2483,2)
(8441,2441,2)
(7225,8362,2)
(5608,5712,2)
(4152,131,2)
(5259,5247,2)
(5481,668,2)
(3496,8079,2)
(360,553,2)
(32,4928,2)
(2280,6047,2)
(7955,4928,2)
(7051,6773,2)
(919,7977,2)
(7039,3236,2)
(1223,7619,2)
(7014,3872,2)
(418,856,2)
(1460,1502,2)
(3727,7619,2)
(1599,1256,2)
(4238,8770,2)
(8094,4475,2)
(1302,7854,2)
(1164,7826,2)
(4572,1306,2)
(1077,7677,2)
(213,2248,2)
(1079,3527,2)
(8312,4384,2)
(8451,1502,2)
(7438,5969,2)
(2552,6160,2)
(6499,3965,2)
(283,6404,2)
(4313,9026,2)
(2349,8159,2)
(3738,4224,2)
(1058,8362,2)
(7513,4682,2)
(4407,8681,2)
(6218,1502,2)
(7017,3217,2)
(1088,4928,2)
(4437,8188,2)
(8461,1502,2)
(3279,6738,2)
(5523,4278,2)
(1570,2316,2)
(3845,250,2)
(2413,2708,2)
(5386,2546,2)
(2751,6301,2)
(2184,5830,2)
(1873,948,2)
(5223,3049,2)
(3302,1489,2)
(4352,6047,2)
(2286,8020,2)
(2814,3147,2)
(8108,498,2)
(7647,4807,2)
(8891,1502,2)
(2347,8701,2)
(2181,1476,2)
(7267,533,2)
(2491,3963,2)
(4973,2585,2)
(1668,8247,2)
(697,8362,2)
(610,5392,2)
(3963,4961,2)
(8887,6773,2)
(6359,2994,2)
(8578,5846,2)
(5727,5448,2)
(6294,4176,2)
(2035,6047,2)
(8829,7148,2)
(8970,2206,2)
(6075,7371,2)
(2388,4878,2)
(4304,6749,2)
(5993,4548,2)
(3087,119,2)
(3363,6124,2)
(2932,4647,2)
(2139,8020,2)
(8806,1502,2)
(4206,7905,2)
(1800,1502,2)
(770,8247,2)
(5409,5939,2)
(8382,2708,2)
(5517,2125,2)
(4455,8159,2)
(5190,9025,2)
(3220,8691,2)
(8527,7373,2)
(8533,7826,2)
(4954,8576,2)
(7521,7468,2)
(3267,5939,2)
(1009,79,2)
(2210,1415,2)
(1564,6108,2)
(3480,8159,2)
(589,5922,2)
(4601,7929,2)
(3521,6512,2)
(7866,3636,2)
(8020,7318,2)
(5286,6785,2)
(8845,7941,2)
(2433,6855,2)
(2221,2394,2)
(1332,697,2)
(460,1502,2)
(5114,7522,2)
(4388,6738,2)
(5924,2032,2)
(8415,3272,2)
(3046,8032,2)
(4980,4480,2)
(4593,3872,2)
(2320,2893,2)
(5449,411,2)
(8670,5302,2)
(4529,243,2)
(8829,8987,2)
(3931,1306,2)
(5537,1731,2)
(9037,2113,2)
(8680,6562,2)
(1925,8217,2)
(4232,7438,2)
(1230,7552,2)
(5973,5300,2)
(2781,4422,2)
(1294,1593,2)
(7249,8362,2)
(7034,7826,2)
(494,5071,2)
(7219,7212,2)
(1102,4022,2)
(1188,7062,2)
(4365,8362,2)
(419,8032,2)
(5430,3636,2)
(6006,5525,2)
(7306,6967,2)
(5294,4551,2)
(8898,2180,2)
(5065,235,2)
(7009,7905,2)
(9017,3775,2)
(2311,6047,2)
(8464,4928,2)
(1933,6718,2)
(2136,6047,2)
(378,3125,2)
(7259,4878,2)
(8829,3570,2)
(5980,8362,2)
(6611,169,2)
(3440,8362,2)
(1498,6048,2)
(2728,1502,2)
(2379,3937,2)
(6512,1449,2)
(8097,8499,2)
(8407,5047,2)
(603,5608,2)
(6642,6323,2)
(2371,6236,2)
(6308,7826,2)
(5450,7369,2)
(3524,1955,2)
(7017,831,2)
(4299,6937,2)
(600,720,2)
(3453,4634,2)
(803,4473,2)
(8388,6692,2)
(1448,4183,2)
(1816,8362,2)
(3040,6512,2)
(3886,1502,2)
(4550,5247,2)
(4396,7826,2)
(8307,8362,2)
(4702,4928,2)
(5995,3520,2)
(1738,7517,2)
(168,6855,2)
(3085,8802,2)
(256,5247,2)
(838,997,2)
(3043,2934,2)
(8929,4928,2)
(6139,7427,2)
(8511,6931,2)
(4711,6730,2)
(5699,7552,2)
(4140,550,2)
(7619,8362,2)
(8044,9025,2)
(7736,7004,2)
(7286,7004,2)
(6523,4647,2)
(856,3032,2)
(5080,7438,2)
(6785,2898,2)
(2326,6730,2)
(4437,7148,2)
(2646,7826,2)
(4372,4928,2)
(5838,3520,2)
(3458,2228,2)
(5945,4928,2)
(255,7619,2)
(5383,1452,2)
(286,4196,2)
(6378,3383,2)
(8633,8247,2)
(531,4647,2)
(1991,1502,2)
(6431,7937,2)
(8798,3963,2)
(7142,8362,2)
(712,7100,2)
(4699,6108,2)
(3199,2772,2)
(1421,1645,2)
(7409,3049,2)
(3062,2783,2)
(1046,8036,2)
(2445,186,2)
(6721,4196,2)
(1699,2546,2)
(245,1502,2)
(7946,3311,2)
(3011,3636,2)
(175,1794,2)
(2865,5106,2)
(5209,1053,2)
(5897,6285,2)
(8525,7377,2)
(3990,5902,2)
(4635,4928,2)
(2869,2113,2)
(996,3472,2)
(998,8015,2)
(8026,8991,2)
(6040,3410,2)
(6671,403,2)
(157,3937,2)
(7126,4548,2)
(7383,34,2)
(7975,250,2)
(7753,1096,2)
(5429,4155,2)
(1610,7359,2)
(743,3775,2)
(4871,1836,2)
(7506,7974,2)
(8239,2249,2)
(4647,2794,2)
(6403,169,2)
(1836,8362,2)
(9040,5902,2)
(4437,7033,2)
(2992,3989,2)
(6770,8362,2)
(2273,720,2)
(3312,5300,2)
(7244,8499,2)
(176,2394,2)
(4090,7892,2)
(834,5320,2)
(4371,3259,2)
(7217,8362,2)
(1250,2674,2)
(5089,701,2)
(8060,4790,2)
(1286,235,2)
(658,6047,2)
(1602,6236,2)
(563,212,2)
(7898,8362,2)
(2441,7347,2)
(7897,8252,2)
(2466,5608,2)
(7396,3421,2)
(5078,4928,2)
(5048,7666,2)
(5598,7826,2)
(7743,328,2)
(7889,3520,2)
(5803,5969,2)
(8346,7826,2)
(4920,228,2)
(4565,1502,2)
(6304,2893,2)
(5247,4031,2)
(6295,3775,2)
(6679,7450,2)
(5666,3350,2)
(3819,3583,2)
(3075,6186,2)
(4433,1502,2)
(2542,4224,2)
(3174,1321,2)
(3654,5829,2)
(8053,2686,2)
(7220,1306,2)
(7344,8032,2)
(7005,3251,2)
(1525,8362,2)
(3978,5025,2)
(4542,4928,2)
(3842,2555,2)
(5160,6195,2)
(8352,212,2)
(6145,3350,2)
(3223,250,2)
(7307,3350,2)
(7370,2758,2)
(645,2609,2)
(8455,4336,2)
(7596,7359,2)
(6557,3715,2)
(7619,2844,2)
(2332,8362,2)
(1711,1085,2)
(2772,4928,2)
(8094,4857,2)
(7666,8362,2)
(1838,7810,2)
(8135,2708,2)
(746,8362,2)
(8872,4705,2)
(1065,6160,2)
(814,1034,2)
(4888,636,2)
(4678,2440,2)
(3473,3923,2)
(5244,3448,2)
(7221,9092,2)
(5491,5608,2)
(1177,175,2)
(2847,7647,2)
(3626,7359,2)
(7115,4168,2)
(2605,6673,2)
(5509,1946,2)
(4717,8362,2)
(750,3226,2)
(738,1502,2)
(1492,6703,2)
(5769,1017,2)
(7965,7386,2)
(5354,7662,2)
(3270,1469,2)
(166,4928,2)
(8392,1502,2)
(1359,4928,2)
(451,8041,2)
(6464,8271,2)
(5851,3385,2)
(2521,7666,2)
(2172,8499,2)
(7167,8336,2)
(7702,1617,2)
(9042,5043,2)
(7257,8563,2)
(6420,8499,2)
(7216,5247,2)
(2854,8032,2)
(3838,5904,2)
(9080,2774,2)
(2220,8918,2)
(2967,6047,2)
(4584,466,2)
(8033,7388,2)
(5273,4422,2)
(7093,1502,2)
(213,4085,2)
(8668,8858,2)
(5311,2644,2)
(5435,4232,2)
(7256,6611,2)
(5330,6047,2)
(5531,3710,2)
(8442,6985,2)
(3922,3715,2)
(8552,1918,2)
(7960,598,2)
(6488,1574,2)
(5456,7249,2)
(4779,398,2)
(6146,8505,2)
(3254,8362,2)
(6738,3500,2)
(4129,7179,2)
(1181,2394,2)
(7091,297,2)
(5111,8701,2)
(663,8799,2)
(4147,806,2)
(8408,3032,2)
(7166,805,2)
(5646,9058,2)
(8202,3917,2)
(3896,4085,2)
(3410,2546,2)
(3504,3026,2)
(5367,2016,2)
(6077,4246,2)
(3033,428,2)
(4437,5573,2)
(1623,3963,2)
(2823,8284,2)
(8333,9150,2)
(651,1953,2)
(5779,8362,2)
(5234,2425,2)
(1792,8825,2)
(947,8362,2)
(2488,212,2)
(735,350,2)
(1984,8362,2)
(7057,5024,2)
(6051,403,2)
(7113,2394,2)
(5294,1222,2)
(8829,2113,2)
(7317,4753,2)
(5015,3715,2)
(7910,8362,2)
(2356,4140,2)
(4460,3937,2)
(822,4928,2)
(6094,1502,2)
(4769,1916,2)
(9085,1502,2)
(203,3549,2)
(3609,7841,2)
(4419,4019,2)
(6544,3217,2)
(3537,3965,2)
(7359,3963,2)
(5686,5902,2)
(529,4647,2)
(759,6404,2)
(8644,8499,2)
(5698,8425,2)
(8851,8362,2)
(8251,1502,2)
(2011,8083,2)
(1270,4892,2)
(1247,3252,2)
(548,4304,2)
(2592,8516,2)
(4364,6366,2)
(1035,720,2)
(3832,2180,2)
(2744,1546,2)
(933,1502,2)
(8868,5043,2)
(5200,8739,2)
(1124,2705,2)
(6814,5392,2)
(4572,1489,2)
(2145,5392,2)
(2001,2686,2)
(3649,7826,2)
(7354,2698,2)
(1075,1502,2)
(5329,7468,2)
(8395,2985,2)
(8452,8981,2)
(6304,1855,2)
(4597,4085,2)
(4743,175,2)
(7988,6745,2)
(4230,6318,2)
(7589,7166,2)
(3437,3272,2)
(6580,7826,2)
(6328,4928,2)
(7001,341,2)
(439,131,2)
(5351,1086,2)
(5937,5142,2)
(4657,4928,2)
(972,8362,2)
(5729,3826,2)
(1452,1444,2)
(3947,8362,2)
(4393,720,2)
(5658,7518,2)
(3416,334,2)
(2462,494,2)
(7807,5969,2)
(6195,1424,2)
(1128,1502,2)
(5642,1557,2)
(1915,6648,2)
(6529,4196,2)
(3092,243,2)
(7348,4928,2)
(8100,8362,2)
(1197,5867,2)
(6084,5939,2)
(2555,7666,2)
(2424,3943,2)
(2320,1591,2)
(2138,7338,2)
(2399,936,2)
(1693,3350,2)
(4309,6548,2)
(1081,4928,2)
(2673,4928,2)
(2464,2851,2)
(7813,5950,2)
(8936,8032,2)
(7790,7979,2)
(2401,4928,2)
(5783,8032,2)
(6630,3612,2)
(3631,2585,2)
(3302,8678,2)
(6113,838,2)
(6304,2894,2)
(8128,5273,2)
(909,4928,2)
(858,3965,2)
(6290,3870,2)
(8400,3470,2)
(8729,343,2)
(3216,5902,2)
(6450,5043,2)
(504,1489,2)
(7468,4551,2)
(4126,8020,2)
(6366,317,2)
(816,1809,2)
(3053,3537,2)
(1289,4928,2)
(5115,2193,2)
(189,539,2)
(8873,5025,2)
(1796,8362,2)
(2866,8516,2)
(4747,3915,2)
(904,4022,2)
(6487,6648,2)
(6649,3304,2)
(6625,7517,2)
(8549,3527,2)
(6626,5680,2)
(5930,3570,2)
(7214,8635,2)
(2828,2032,2)
(6227,6236,2)
(4943,2609,2)
(7105,8247,2)
(95,7941,2)
(8681,6561,2)
(1076,7513,2)
(5246,6124,2)
(6923,8425,2)
(2320,6465,2)
(4205,7536,2)
(2801,2994,2)
(8280,5992,2)
(6401,533,2)
(549,6404,2)
(222,4862,2)
(8794,350,2)
(2706,6931,2)
(7079,3357,2)
(6224,4056,2)
(3705,3937,2)
(7286,4878,2)
(5757,4928,2)
(712,5559,2)
(4918,1635,2)
(4044,5025,2)
(287,5343,2)
(4199,2585,2)
(47,4085,2)
(703,3049,2)
(6775,2441,2)
(5650,3537,2)
(5974,8975,2)
(1040,1599,2)
(4251,8566,2)
(8433,169,2)
(4858,2125,2)
(1859,8991,2)
(2589,7468,2)
(1611,7826,2)
(7381,4878,2)
(4131,2088,2)
(1533,5969,2)
(3294,943,2)
(6353,1502,2)
(5872,7826,2)
(6334,1902,2)
(4004,6703,2)
(3397,4297,2)
(8079,3570,2)
(61,7826,2)
(6392,1085,2)
(2761,1321,2)
(6163,1682,2)
(2674,6133,2)
(4097,3612,2)
(4595,4014,2)
(2106,8362,2)
(3692,8825,2)
(8647,521,2)
(6435,675,2)
(678,8197,2)
(4730,243,2)
(1415,175,2)
(520,7826,2)
(6782,403,2)
(7018,5576,2)
(7917,1502,2)
(813,1502,2)
(3272,4193,2)
(2142,1502,2)
(7812,5025,2)
(533,1472,2)
(8395,5461,2)
(794,6958,2)
(4074,5320,2)
(4825,7207,2)
(2052,4721,2)
(2013,2057,2)
(1678,3062,2)
(6051,6782,2)
(811,3193,2)
(2212,7043,2)
(2865,5111,2)
(8071,1502,2)
(2492,5902,2)
(6327,5712,2)
(5296,1003,2)
(6236,805,2)
(1284,8362,2)
(5003,6195,2)
(6282,6318,2)
(6987,997,2)
(5664,6323,2)
(377,8362,2)
(901,7359,2)
(6951,7651,2)
(7280,3705,2)
(6058,7628,2)
(2094,8516,2)
(3764,6491,2)
(8972,927,2)
(5905,6642,2)
(1083,5939,2)
(7496,1617,2)
(4837,3211,2)
(282,1832,2)
(3008,4548,2)
(1383,8866,2)
(4277,8362,2)
(7707,8516,2)
(8519,5346,2)
(8604,8576,2)
(4318,7369,2)
(1275,1761,2)
(6645,7309,2)
(6569,4928,2)
(6628,175,2)
(264,3775,2)
(7857,7359,2)
(7124,7039,2)
(9119,4928,2)
(900,3248,2)
(5415,260,2)
(3493,317,2)
(5194,5939,2)
(1452,2585,2)
(1409,7030,2)
(698,7472,2)
(6370,6343,2)
(2274,8362,2)
(3201,8362,2)
(7521,3583,2)
(333,6195,2)
(7073,8423,2)
(4328,2057,2)
(8937,632,2)
(536,4878,2)
(3452,7826,2)
(8154,1731,2)
(7468,7100,2)
(7605,4878,2)
(8929,1502,2)
(4667,6900,2)
(3101,8910,2)
(6462,419,2)
(2783,4224,2)
(312,4471,2)
(5075,6179,2)
(6445,1321,2)
(2760,175,2)
(3686,5712,2)
(4236,8497,2)
(6351,4928,2)
(3713,2464,2)
(5914,6368,2)
(5391,3702,2)
(6377,4085,2)
(4785,1321,2)
(1218,1502,2)
(6640,1502,2)
(7115,5043,2)
(925,7466,2)
(6566,1009,2)
(4537,3636,2)
(7713,3965,2)
(1003,93,2)
(6005,1516,2)
(8137,7826,2)
(8267,3963,2)
(3462,7518,2)
(4061,1609,2)
(400,4928,2)
(4797,4725,2)
(6620,4397,2)
(2451,7202,2)
(2299,4196,2)
(303,5025,2)
(2737,250,2)
(8604,4742,2)
(1870,2708,2)
(3942,4928,2)
(5680,1502,2)
(2135,8079,2)
(671,4934,2)
(644,45,2)
(6868,4512,2)
(7821,8759,2)
(4076,6431,2)
(6048,4878,2)
(7002,6562,2)
(8891,3583,2)
(48,7202,2)
(2747,3350,2)
(7943,3350,2)
(1982,5445,2)
(5753,4928,2)
(5359,1502,2)
(6702,2347,2)
(5988,1502,2)
(3314,2758,2)
(1472,701,2)
(8329,6431,2)
(1983,4214,2)
(2993,2464,2)
(3166,2464,2)
(9026,8188,2)
(5343,2125,2)
(9026,1924,2)
(3625,1731,2)
(5975,8362,2)
(4313,1793,2)
(362,7438,2)
(4225,1731,2)
(2113,1502,2)
(4484,5867,2)
(7046,1228,2)
(1219,2299,2)
(8868,5902,2)
(7160,3101,2)
(3880,6318,2)
(6304,2113,2)
(3188,4304,2)
(697,5763,2)
(3915,2125,2)
(7685,6225,2)
(4214,5218,2)
(6497,1502,2)
(4201,3817,2)
(8467,411,2)
(3198,1731,2)
(5908,6855,2)
(5310,1502,2)
(3007,6133,2)
(7826,900,2)
(1787,8505,2)
(6779,3798,2)
(703,8499,2)
(3923,5674,2)
(5294,3465,2)
(1923,1502,2)
(1598,4928,2)
(8665,3900,2)
(7793,1502,2)
(1727,1502,2)
(6071,1635,2)
(186,8362,2)
(7187,4350,2)
(9026,1489,2)
(740,1680,2)
(6391,4928,2)
(5451,862,2)
(8762,1502,2)
(6530,1502,2)
(933,4928,2)
(827,5969,2)
(6285,1502,2)
(6187,1306,2)
(6443,6128,2)
(4343,2056,2)
(8204,1456,2)
(3501,6958,2)
(6330,4932,2)
(1438,5043,2)
(2015,3963,2)
(9000,544,2)
(8598,1946,2)
(598,1502,2)
(4623,4961,2)
(1272,8362,2)
(5294,4853,2)
(8077,4443,2)
(4884,8362,2)
(7372,7512,2)
(5294,7092,2)
(9130,533,2)
(2070,8624,2)
(4358,5025,2)
(1139,7685,2)
(4461,3049,2)
(2694,7060,2)
(4158,3098,2)
(2126,6729,2)
(350,7207,2)
(3204,6958,2)
(5294,7885,2)
(5857,549,2)
(6095,2325,2)
(8430,212,2)
(3417,2981,2)
(3325,8320,2)
(2689,7826,2)
(8688,3681,2)
(4437,5244,2)
(3682,403,2)
(7636,8991,2)
(6094,4928,2)
(8072,1006,2)
(4745,5025,2)
(4448,4928,2)
(5734,8505,2)
(7496,1502,2)
(5497,418,2)
(8612,1734,2)
(3265,5043,2)
(5489,7338,2)
(6883,1502,2)
(8428,2125,2)
(7000,7674,2)
(3351,8499,2)
(1329,2898,2)
(3823,7061,2)
(3543,1502,2)
(7035,8499,2)
(4420,1168,2)
(724,2394,2)
(778,8576,2)
(4290,8362,2)
(7061,6404,2)
(2210,175,2)
(6538,8362,2)
(5597,2555,2)
(5262,3636,2)
(7833,6128,2)
(3935,4769,2)
(2921,9025,2)
(6733,7167,2)
(8392,175,2)
(237,5043,2)
(7146,8499,2)
(1988,5559,2)
(1475,1502,2)
(3639,7227,2)
(6304,932,2)
(8643,8247,2)
(3759,4878,2)
(7297,6642,2)
(5222,1879,2)
(6775,5971,2)
(4969,5727,2)
(9090,1502,2)
(1128,4878,2)
(6011,8910,2)
(30,7826,2)
(5843,3872,2)
(289,7202,2)
(349,169,2)
(5108,3421,2)
(6249,2057,2)
(4994,8803,2)
(8905,1731,2)
(6532,4548,2)
(753,6915,2)
(3368,9015,2)
(5477,539,2)
(2377,2709,2)
(606,5127,2)
(3861,1321,2)
(2359,4928,2)
(6183,4456,2)
(3510,3798,2)
(5778,2565,2)
(196,7666,2)
(6379,3900,2)
(4695,1502,2)
(4194,1321,2)
(4222,4171,2)
(8391,2125,2)
(3411,8188,2)
(886,7571,2)
(2439,5939,2)
(4074,6179,2)
(8105,7004,2)
(6815,6416,2)
(6148,6047,2)
(4374,3131,2)
(6304,6560,2)
(1331,317,2)
(1537,3537,2)
(3578,5319,2)
(2033,8362,2)
(5625,2585,2)
(5939,3877,2)
(4788,8020,2)
(1303,1502,2)
(7673,5922,2)
(7405,6159,2)
(4437,8987,2)
(5111,569,2)
(3952,2394,2)
(5025,1924,2)
(6170,291,2)
(6674,6940,2)
(9049,4333,2)
(6304,1591,2)
(6119,4928,2)
(1896,3872,2)
(7823,7826,2)
(3371,6404,2)
(2576,1510,2)
(6853,1502,2)
(619,5693,2)
(9026,598,2)
(6659,1502,2)
(6666,8362,2)
(4910,59,2)
(1135,6404,2)
(245,4928,2)
(3654,5859,2)
(557,2394,2)
(5569,5337,2)
(1060,8362,2)
(7094,8362,2)
(2394,8020,2)
(2116,3900,2)
(6246,9025,2)
(4062,9015,2)
(8983,6642,2)
(1983,6958,2)
(227,7619,2)
(7079,2404,2)
(7693,7826,2)
(7288,2898,2)
(2158,8362,2)
(1793,4022,2)
(4034,1539,2)
(3252,2278,2)
(7046,2894,2)
(8525,2394,2)
(1292,3188,2)
(1108,4679,2)
(3705,157,2)
(9125,4928,2)
(8072,403,2)
(3489,4928,2)
(2721,6246,2)
(7960,7100,2)
(5011,7666,2)
(2831,884,2)
(8823,1506,2)
(8118,9015,2)
(9041,7630,2)
(5941,167,2)
(2403,4928,2)
(8671,4477,2)
(7311,5902,2)
(434,8362,2)
(6810,1294,2)
(5200,4246,2)
(1122,8362,2)
(2166,4196,2)
(6025,4928,2)
(7806,4471,2)
(5077,7536,2)
(1768,1791,2)
(1555,3049,2)
(8896,7985,2)
(5895,4740,2)
(8459,2712,2)
(7991,4019,2)
(2202,4019,2)
(3379,4928,2)
(6073,5047,2)
(4880,6128,2)
(5645,3636,2)
(952,5895,2)
(616,7826,2)
(2944,7513,2)
(4086,805,2)
(4378,1891,2)
(984,5656,2)
(1190,1617,2)
(455,7100,2)
(1626,3937,2)
(8012,3343,2)
(5965,7221,2)
(8074,8701,2)
(1768,4722,2)
(1545,5675,2)
(6479,1760,2)
(7285,8799,2)
(9095,8701,2)
(7647,1682,2)
(5518,9091,2)
(2745,1306,2)
(2477,1502,2)
(6087,169,2)
(58,6128,2)
(1360,4928,2)
(5510,2016,2)
(2031,6404,2)
(1821,6773,2)
(3532,4266,2)
(7311,266,2)
(6515,1502,2)
(6485,6323,2)
(2856,8799,2)
(404,1520,2)
(630,4360,2)
(8498,2994,2)
(1842,6158,2)
(2102,5024,2)
(1530,4928,2)
(7005,4647,2)
(7250,9015,2)
(2110,8362,2)
(6482,7468,2)
(3089,7004,2)
(5845,8362,2)
(6798,6090,2)
(3948,1193,2)
(1080,8362,2)
(4234,7826,2)
(4630,2249,2)
(1516,7826,2)
(7298,3527,2)
(9073,3199,2)
(1120,8362,2)
(1736,6718,2)
(4850,6958,2)
(6080,4475,2)
(1656,3636,2)
(551,1502,2)
(6249,3667,2)
(3624,8499,2)
(6088,1168,2)
(108,7359,2)
(2391,1502,2)
(8920,7826,2)
(3405,5969,2)
(4446,1890,2)
(8172,1482,2)
(4490,1502,2)
(7171,6264,2)
(4870,5939,2)
(4509,1009,2)
(46,9080,2)
(7089,6318,2)
(7697,3527,2)
(8623,6705,2)
(2708,6058,2)
(5774,5969,2)
(6079,4541,2)
(3221,6181,2)
(2791,5807,2)
(3051,7374,2)
(5474,7619,2)
(2015,6066,2)
(5864,8825,2)
(6150,3872,2)
(569,2347,2)
(992,7369,2)
(3122,7849,2)
(7742,4252,2)
(8506,6958,2)
(1808,5867,2)
(6252,491,2)
(657,4934,2)
(126,7062,2)
(7098,1502,2)
(8425,5973,2)
(3078,8280,2)
(4814,6236,2)
(3517,7369,2)
(7003,6512,2)
(5135,8647,2)
(4846,7148,2)
(8286,4409,2)
(7890,5787,2)
(5026,2546,2)
(4313,7077,2)
(2364,4760,2)
(6108,8833,2)
(7186,6048,2)
(7209,4196,2)
(1433,3937,2)
(5662,8667,2)
(6043,4193,2)
(7367,4928,2)
(7368,6048,2)
(2202,4928,2)
(7174,7062,2)
(6149,533,2)
(6861,2698,2)
(2041,6133,2)
(7107,6195,2)
(4843,4928,2)
(8868,390,2)
(7762,2445,2)
(3698,3083,2)
(2085,7438,2)
(9053,6048,2)
(5014,7826,2)
(6304,7767,2)
(2641,4793,2)
(292,5273,2)
(7768,4085,2)
(5312,539,2)
(3763,7941,2)
(4590,7985,2)
(3690,6949,2)
(336,4234,2)
(4793,3063,2)
(3497,7619,2)
(4445,7438,2)
(730,3527,2)
(615,8991,2)
(513,8032,2)
(4453,5320,2)
(3984,7867,2)
(7724,9025,2)
(6434,7826,2)
(3720,2100,2)
(8799,1682,2)
(5104,4996,2)
(7472,3657,2)
(2598,7004,2)
(8646,6404,2)
(7488,8743,2)
(8158,3367,2)
(2491,4928,2)
(3815,847,2)
(3508,1081,2)
(1752,1635,2)
(3610,5538,2)
(6718,4164,2)
(670,7207,2)
(8384,1761,2)
(7093,4928,2)
(3194,6562,2)
(2409,6958,2)
(4188,7438,2)
(2280,1502,2)
(5557,6863,2)
(38,5833,2)
(8782,1502,2)
(3105,8362,2)
(3222,1924,2)
(6519,7674,2)
(4472,7100,2)
(8018,169,2)
(1557,2464,2)
(3917,2791,2)
(1937,2585,2)
(8847,8527,2)
(4194,4119,2)
(278,1598,2)
(9100,3032,2)
(3084,3327,2)
(66,1126,2)
(4961,2394,2)
(537,403,2)
(5878,5435,2)
(437,8276,2)
(1974,1502,2)
(7976,7826,2)
(1341,6108,2)
(4417,2445,2)
(2404,6967,2)
(1651,5426,2)
(6453,2705,2)
(9037,1855,2)
(2656,7847,2)
(4693,3702,2)
(4038,1231,2)
(8270,5867,2)
(1112,131,2)
(6093,6550,2)
(9026,6465,2)
(2473,8247,2)
(611,4928,2)
(6869,3775,2)
(7870,2057,2)
(8370,8466,2)
(7336,3448,2)
(3583,4878,2)
(3071,6318,2)
(1299,2994,2)
(3172,2839,2)
(6195,419,2)
(5524,8701,2)
(2333,2347,2)
(2222,6648,2)
(1663,6938,2)
(2796,1474,2)
(3423,8834,2)
(2445,2626,2)
(6216,8825,2)
(2141,8632,2)
(3343,1502,2)
(8839,720,2)
(5714,720,2)
(7487,7359,2)
(6683,7369,2)
(8520,8183,2)
(7006,6491,2)
(7669,1321,2)
(7967,2445,2)
(6304,8678,2)
(3274,4085,2)
(8928,2125,2)
(2578,1794,2)
(5875,4744,2)
(6293,936,2)
(5266,1915,2)
(7559,6323,2)
(3992,7202,2)
(1839,1635,2)
(6041,720,2)
(6516,6958,2)
(1546,8499,2)
(6785,2555,2)
(8610,8437,2)
(3831,8362,2)
(5701,7605,2)
(1976,6048,2)
(6527,3961,2)
(6468,7826,2)
(1554,6186,2)
(3737,6404,2)
(8037,4524,2)
(9049,7826,2)
(966,317,2)
(54,334,2)
(2339,7619,2)
(8780,4744,2)
(4787,2585,2)
(2216,1682,2)
(8385,7479,2)
(5140,7619,2)
(7984,1505,2)
(7780,5273,2)
(3253,2705,2)
(5178,1291,2)
(8194,7941,2)
(1123,4928,2)
(2021,8289,2)
(4469,8362,2)
(6975,8362,2)
(9140,4647,2)
(4378,7516,2)
(8242,1079,2)
(8145,3963,2)
(2869,2894,2)
(4313,712,2)
(2892,3527,2)
(3420,4928,2)
(7188,2585,2)
(7028,5300,2)
(3534,8020,2)
(3129,7734,2)
(3315,7202,2)
(4598,2249,2)
(3389,398,2)
(2131,3636,2)
(8964,738,2)
(7455,3965,2)
(590,4471,2)
(8227,4928,2)
(2767,842,2)
(4381,7202,2)
(1933,7937,2)
(7394,394,2)
(6830,1502,2)
(498,5025,2)
(473,8437,2)
(2463,3963,2)
(818,4246,2)
(8832,6737,2)
(1106,2394,2)
(5693,7552,2)
(769,8499,2)
(2311,4928,2)
(8067,4019,2)
(8924,847,2)
(2363,6958,2)
(2565,1502,2)
(2954,4928,2)
(1614,3636,2)
(4820,2035,2)
(3911,6195,2)
(4437,9075,2)
(8716,7937,2)
(6304,6277,2)
(7196,6198,2)
(3961,7826,2)
(7065,7841,2)
(9150,7849,2)
(4296,5693,2)
(8837,2394,2)
(5932,7000,2)
(556,4824,2)
(4599,4974,2)
(4066,8362,2)
(8954,8362,2)
(4392,2491,2)
(3796,7826,2)
(2533,9101,2)
(277,8466,2)
(748,8466,2)
(2155,8830,2)
(149,2394,2)
(6304,1228,2)
(3411,5559,2)
(4148,8733,2)
(972,7468,2)
(4719,1502,2)
(922,7387,2)
(4142,3837,2)
(352,4647,2)
(4909,7132,2)
(7547,3618,2)
(7901,4928,2)
(6746,334,2)
(4740,1502,2)
(5270,4050,2)
(2742,9025,2)
(8689,5273,2)
(2500,4995,2)
(8864,3537,2)
(8006,6195,2)
(8657,2964,2)
(1973,3100,2)
(6793,8576,2)
(4723,2994,2)
(2429,8701,2)
(2381,90,2)
(26,1306,2)
(183,8791,2)
(1692,7359,2)
(3857,4155,2)
(4076,4019,2)
(2915,4781,2)
(6835,4721,2)
(3462,826,2)
(3084,6195,2)
(7738,4327,2)
(8322,6404,2)
(519,7179,2)
(1377,936,2)
(7076,1502,2)
(4472,6465,2)
(2516,3049,2)
(8015,4719,2)
(601,720,2)
(1910,3963,2)
(8694,4062,2)
(1296,7359,2)
(5178,3963,2)
(315,5178,2)
(5576,959,2)
(2967,4928,2)
(499,8576,2)
(351,3636,2)
(3142,7552,2)
(3406,5781,2)
(3080,2585,2)
(7015,2726,2)
(1298,1502,2)
(5916,8362,2)
(2571,4928,2)
(5175,8499,2)
(6429,8020,2)
(3382,991,2)
(7156,1410,2)
(6179,9101,2)
(3410,1502,2)
(7154,6440,2)
(5201,7666,2)
(1894,5320,2)
(4746,1170,2)
(1998,8833,2)
(4214,6958,2)
(554,8362,2)
(8420,8362,2)
(7855,2801,2)
(2128,2394,2)
(7535,1617,2)
(935,6404,2)
(4600,6512,2)
(3969,5939,2)
(3154,5712,2)
(4320,2101,2)
(8500,5948,2)
(5294,8578,2)
(3072,4224,2)
(7321,5587,2)
(2423,847,2)
(4069,7619,2)
(6159,6931,2)
(3940,9015,2)
(1829,1219,2)
(504,7092,2)
(5122,6431,2)
(3695,7932,2)
(8032,8545,2)
(1004,826,2)
(1988,6465,2)
(1890,3527,2)
(5303,1617,2)
(4485,7472,2)
(7679,8362,2)
(291,5928,2)
(712,8678,2)
(504,7148,2)
(1273,3891,2)
(9105,2602,2)
(2105,813,2)
(4004,5203,2)
(1334,1502,2)
(5020,8362,2)
(2207,806,2)
(6767,4409,2)
(8728,3530,2)
(8772,393,2)
(5651,5836,2)
(2748,1794,2)
(2009,3421,2)
(5641,4928,2)
(5098,7348,2)
(6546,3594,2)
(1390,4928,2)
(2623,279,2)
(2534,5524,2)
(8284,5939,2)
(8894,8650,2)
(4421,3421,2)
(6055,7442,2)
(6294,4196,2)
(4387,1916,2)
(4099,7674,2)
(2357,8499,2)
(7649,4545,2)
(4836,8079,2)
(4790,8247,2)
(943,8388,2)
(8437,847,2)
(9001,6491,2)
(6832,8320,2)
(1081,1502,2)
(3657,1502,2)
(4218,4193,2)
(7281,7162,2)
(6915,5392,2)
(4953,1502,2)
(4057,936,2)
(354,4744,2)
(7766,131,2)
(7288,7666,2)
(1883,1734,2)
(6828,802,2)
(6824,6967,2)
(2392,4878,2)
(5678,3705,2)
(8497,5392,2)
(7529,7536,2)
(2567,3715,2)
(550,5525,2)
(7630,5043,2)
(6204,243,2)
(5300,4471,2)
(8687,8159,2)
(7515,7867,2)
(4957,1731,2)
(5197,5025,2)
(261,131,2)
(7385,4246,2)
(5716,8362,2)
(5439,5693,2)
(141,8276,2)
(1191,720,2)
(3207,6938,2)
(6741,549,2)
(5854,4475,2)
(4030,8008,2)
(7251,3924,2)
(1922,2801,2)
(5045,3636,2)
(3486,7826,2)
(8412,7867,2)
(3523,3350,2)
(7254,6334,2)
(5977,5524,2)
(7963,4085,2)
(4059,2585,2)
(3851,7552,2)
(5029,3354,2)
(8167,3527,2)
(2456,3705,2)
(4775,1635,2)
(8597,4224,2)
(6123,1003,2)
(2869,3313,2)
(7813,5416,2)
(1244,2105,2)
(7387,8362,2)
(3906,1502,2)
(1852,3350,2)
(8056,4932,2)
(5475,2394,2)
(2410,1502,2)
(595,7998,2)
(6674,7826,2)
(2342,4932,2)
(5721,8902,2)
(4181,5826,2)
(7937,3715,2)
(1907,8362,2)
(7961,4757,2)
(2827,2394,2)
(6042,3049,2)
(2586,8362,2)
(7068,5025,2)
(3019,1502,2)
(2951,4928,2)
(538,3583,2)
(0,8192,2)
(6931,3252,2)
(5361,936,2)
(7686,3527,2)
(3286,1502,2)
(4841,6718,2)
(7618,4928,2)
(8568,6158,2)
(6122,8499,2)
(444,8362,2)
(8397,8362,2)
(5214,6032,2)
(4200,4634,2)
(3872,2698,2)
(937,805,2)
(4034,5300,2)
(6447,3989,2)
(5408,4754,2)
(8692,1734,2)
(4829,4928,2)
(2119,5025,2)
(5075,46,2)
(7717,4928,2)
(5096,847,2)
(8834,6195,2)
(4626,4934,2)
(425,5939,2)
(3724,8362,2)
(8055,6730,2)
(3270,4464,2)
(3480,411,2)
(8329,8566,2)
(5651,533,2)
(1791,2280,2)
(7999,3775,2)
(6648,8662,2)
(7050,720,2)
(3989,4175,2)
(3118,8276,2)
(366,6730,2)
(1887,7984,2)
(8727,7359,2)
(1009,4878,2)
(2837,2464,2)
(4917,4647,2)
(3384,4541,2)
(9037,8188,2)
(7250,1502,2)
(6718,3603,2)
(5674,3856,2)
(6510,1502,2)
(2894,5025,2)
(5579,6318,2)
(712,1489,2)
(6905,2402,2)
(9110,6642,2)
(5983,3350,2)
(7625,8973,2)
(4243,6124,2)
(7429,1479,2)
(2811,8362,2)
(5529,2609,2)
(1761,1267,2)
(2870,8032,2)
(3297,1306,2)
(7102,8362,2)
(8058,5939,2)
(2050,1048,2)
(4819,5867,2)
(3145,8499,2)
(5404,8159,2)
(7100,7728,2)
(7724,2721,2)
(4943,5745,2)
(4163,235,2)
(5406,2394,2)
(238,2758,2)
(6249,2069,2)
(6880,4932,2)
(2071,7369,2)
(2267,4647,2)
(416,8362,2)
(2343,5025,2)
(4125,4721,2)
(973,4497,2)
(1489,3921,2)
(4612,5351,2)
(281,8362,2)
(2223,5969,2)
(2048,3826,2)
(3456,7941,2)
(2445,3329,2)
(8866,1890,2)
(6251,6133,2)
(3520,539,2)
(524,2394,2)
(7846,6195,2)
(8679,2249,2)
(211,8544,2)
(2012,2347,2)
(4313,2320,2)
(5060,8032,2)
(2733,6512,2)
(5421,1731,2)
(1594,3527,2)
(6414,6550,2)
(5292,2483,2)
(2956,8008,2)
(5088,1502,2)
(3019,4928,2)
(7718,5867,2)
(7125,1502,2)
(5804,701,2)
(5861,8499,2)
(55,4928,2)
(6758,4928,2)
(8476,8362,2)
(38,131,2)
(5187,7826,2)
(3279,4928,2)
(4203,5867,2)
(6325,5858,2)
(4884,1502,2)
(5826,1185,2)
(3158,6048,2)
(1982,143,2)
(2309,7438,2)
(1110,803,2)
(5733,1502,2)
(4459,6518,2)
(6329,4271,2)
(1,5817,2)
(6890,847,2)
(3456,1502,2)
(398,8100,2)
(2680,3421,2)
(1634,2425,2)
(7966,4224,2)
(2228,4928,2)
(3928,1942,2)
(7732,3098,2)
(2209,5088,2)
(8120,1502,2)
(5480,3636,2)
(5617,8975,2)
(405,7826,2)
(455,8678,2)
(873,2032,2)
(6652,6938,2)
(284,5085,2)
(3712,3872,2)
(2056,1955,2)
(8708,8499,2)
(9156,2798,2)
(522,881,2)
(3892,5887,2)
(3342,6047,2)
(6272,9043,2)
(5940,6195,2)
(1314,6512,2)
(5141,4928,2)
(3975,7826,2)
(5560,1502,2)
(4019,3693,2)
(286,4176,2)
(3894,4019,2)
(5335,3032,2)
(5693,2189,2)
(6875,8825,2)
(2156,1889,2)
(4383,7826,2)
(1423,7481,2)
(1048,2469,2)
(3281,7826,2)
(1768,8020,2)
(5635,915,2)
(7662,6724,2)
(3237,8875,2)
(3893,8576,2)
(7463,4647,2)
(8698,8701,2)
(7348,3350,2)
(173,6009,2)
(1339,1357,2)
(145,1516,2)
(762,8032,2)
(4078,3636,2)
(4738,5867,2)
(4923,7428,2)
(4709,804,2)
(7367,1502,2)
(9114,6738,2)
(613,7826,2)
(3179,3448,2)
(294,3963,2)
(2925,3937,2)
(4261,2585,2)
(7316,8799,2)
(3593,7207,2)
(3806,1955,2)
(7432,1895,2)
(2838,4652,2)
(1,8247,2)
(4642,847,2)
(585,6562,2)
(1261,2464,2)
(1920,6512,2)
(5337,6847,2)
(6647,7359,2)
(7561,2994,2)
(6199,2038,2)
(6323,5062,2)
(4572,6465,2)
(7131,1502,2)
(4851,5279,2)
(259,2585,2)
(5294,2978,2)
(1042,8902,2)
(463,6748,2)
(5064,2585,2)
(2611,5902,2)
(8935,4304,2)
(4835,441,2)
(3130,7202,2)
(5708,6967,2)
(876,2708,2)
(8482,6958,2)
(1346,7235,2)
(3889,2394,2)
(5012,8320,2)
(4401,2325,2)
(6214,131,2)
(8375,3963,2)
(20,2664,2)
(159,3527,2)
(5422,5025,2)
(4061,3537,2)
(7610,1502,2)
(2472,7388,2)
(8421,1502,2)
(8803,6124,2)
(4344,6692,2)
(1751,39,2)
(5034,1946,2)
(2746,7060,2)
(5028,8499,2)
(1786,5904,2)
(8850,1502,2)
(1607,2347,2)
(6480,8701,2)
(4215,8020,2)
(4056,4050,2)
(4647,1890,2)
(7858,6137,2)
(7445,3350,2)
(6735,8362,2)
(7903,9101,2)
(6431,6718,2)
(1078,4085,2)
(1911,8417,2)
(3605,7801,2)
(3888,6512,2)
(3100,6404,2)
(4841,4928,2)
(5900,4995,2)
(308,2782,2)
(4846,7100,2)
(7474,1817,2)
(1708,4928,2)
(5498,5751,2)
(5400,6225,2)
(1587,7202,2)
(3852,7261,2)
(7027,6264,2)
(3462,3626,2)
(4757,4085,2)
(567,1502,2)
(890,8425,2)
(7014,2898,2)
(591,1387,2)
(236,7619,2)
(662,4928,2)
(7165,6512,2)
(839,5785,2)
(5734,4783,2)
(2023,6967,2)
(3511,3180,2)
(109,5939,2)
(4014,7889,2)
(8628,6967,2)
(7429,7647,2)
(7650,175,2)
(9036,4647,2)
(3681,6047,2)
(2965,1751,2)
(4503,5988,2)
(5345,6738,2)
(7886,2394,2)
(29,1256,2)
(1019,3937,2)
(1256,1256,2)
(7486,5949,2)
(645,1945,2)
(4857,4272,2)
(5507,5025,2)
(7775,6404,2)
(4596,7826,2)
(1800,6334,2)
(6009,1168,2)
(4130,4744,2)
(8143,7647,2)
(8563,9055,2)
(440,6195,2)
(2488,8809,2)
(4091,6195,2)
(8168,7619,2)
(8664,567,2)
(6300,5969,2)
(4121,8362,2)
(6371,805,2)
(5466,3527,2)
(237,5902,2)
(7771,6642,2)
(6186,4779,2)
(4005,4124,2)
(84,1889,2)
(2736,1502,2)
(1766,7004,2)
(7368,4085,2)
(7351,4350,2)
(3227,7399,2)
(8065,8008,2)
(5288,805,2)
(2391,4928,2)
(1563,3702,2)
(1600,3520,2)
(181,1213,2)
(7909,4232,2)
(5188,7896,2)
(8020,6318,2)
(8647,3398,2)
(2417,7905,2)
(791,1726,2)
(6183,1306,2)
(2869,6988,2)
(9008,8276,2)
(9101,3049,2)
(1664,7309,2)
(9155,7188,2)
(1943,1025,2)
(4696,1960,2)
(6987,9131,2)
(1406,7985,2)
(1542,8425,2)
(7049,1502,2)
(8084,169,2)
(3411,4551,2)
(6956,8067,2)
(5433,4934,2)
(3411,598,2)
(1673,2464,2)
(1776,5939,2)
(2904,2020,2)
(8507,720,2)
(2955,6195,2)
(6261,4050,2)
(1464,8892,2)
(6726,338,2)
(3431,697,2)
(1146,5525,2)
(6304,7100,2)
(1958,4657,2)
(2089,4196,2)
(8379,7438,2)
(8848,1419,2)
(1478,5025,2)
(758,393,2)
(7377,6047,2)
(7462,4085,2)
(4322,3838,2)
(8829,2894,2)
(5945,2347,2)
(3014,4193,2)
(5209,341,2)
(8704,805,2)
(3772,2585,2)
(7046,8678,2)
(4781,7826,2)
(7280,3937,2)
(5304,8008,2)
(877,6958,2)
(635,933,2)
(578,4301,2)
(3216,5849,2)
(7435,1502,2)
(1834,8516,2)
(7418,1306,2)
(5075,4220,2)
(849,1502,2)
(2426,6195,2)
(2829,3902,2)
(8411,1772,2)
(4221,8362,2)
(2029,1731,2)
(3802,8948,2)
(6967,4181,2)
(258,3250,2)
(1646,1502,2)
(7165,720,2)
(8561,4081,2)
(3946,4085,2)
(5294,8005,2)
(2828,4928,2)
(8510,5469,2)
(5833,4928,2)
(3881,6431,2)
(4531,3339,2)
(5862,2782,2)
(771,2394,2)
(3957,5300,2)
(6269,6334,2)
(895,3350,2)
(8857,5867,2)
(1351,8425,2)
(6678,8183,2)
(7355,4085,2)
(5294,8987,2)
(1620,4497,2)
(6205,2994,2)
(7725,5024,2)
(956,5867,2)
(8448,7472,2)
(3187,6158,2)
(4067,7773,2)
(8624,4857,2)
(1773,6512,2)
(1897,6195,2)
(3638,4871,2)
(979,175,2)
(4724,7826,2)
(3085,8193,2)
(9083,1502,2)
(1988,5115,2)
(3812,3872,2)
(7466,3965,2)
(6755,2538,2)
(8910,8247,2)
(6075,5902,2)
(1807,1516,2)
(4552,720,2)
(3479,8247,2)
(5897,8425,2)
(2175,8271,2)
(8216,1918,2)
(7634,5025,2)
(5081,2020,2)
(132,7826,2)
(1565,5538,2)
(6864,3383,2)
(8753,3636,2)
(5037,2394,2)
(6940,1516,2)
(1481,59,2)
(2305,7369,2)
(2008,4928,2)
(3239,7937,2)
(3287,3817,2)
(8593,4997,2)
(842,2469,2)
(6567,5443,2)
(6920,7826,2)
(6272,8362,2)
(4756,8991,2)
(7788,2057,2)
(6864,2715,2)
(4861,2708,2)
(5888,7552,2)
(3938,6512,2)
(712,598,2)
(300,8516,2)
(4764,3025,2)
(3668,4085,2)
(7399,3715,2)
(1254,3114,2)
(5294,3968,2)
(1384,4647,2)
(6180,2394,2)
(5222,6195,2)
(258,7941,2)
(1935,5025,2)
(4437,6465,2)
(272,5027,2)
(4332,1502,2)
(7063,1682,2)
(4650,7666,2)
(1014,7666,2)
(2275,2937,2)
(3327,4928,2)
(1419,1502,2)
(2071,2686,2)
(6575,5867,2)
(4568,8576,2)
(3973,2679,2)
(1988,5608,2)
(1000,235,2)
(6587,3965,2)
(976,334,2)
(5581,3702,2)
(7729,1701,2)
(161,5939,2)
(7338,3881,2)
(2298,1502,2)
(2187,7904,2)
(3170,4019,2)
(2834,4269,2)
(182,4878,2)
(7220,5025,2)
(4141,4928,2)
(4267,8991,2)
(3605,7469,2)
(6022,254,2)
(1609,3537,2)
(4794,6350,2)
(5635,5969,2)
(9082,8159,2)
(1901,6548,2)
(166,131,2)
(7405,6931,2)
(297,4928,2)
(157,5636,2)
(5957,618,2)
(2364,550,2)
(5124,169,2)
(1081,936,2)
(5265,8032,2)
(393,334,2)
(2276,5867,2)
(4960,847,2)
(2673,549,2)
(3839,7936,2)
(838,318,2)
(1674,8362,2)
(3542,922,2)
(3184,6047,2)
(31,8362,2)
(6288,6436,2)
(7375,533,2)
(4186,3527,2)
(1855,3448,2)
(8692,5902,2)
(381,6743,2)
(3993,4928,2)
(4306,8945,2)
(2091,8799,2)
(1514,5024,2)
(5331,6958,2)
(3520,5477,2)
(2635,6550,2)
(8067,3272,2)
(1638,2125,2)
(1157,5025,2)
(5414,4071,2)
(8825,212,2)
(6932,881,2)
(1366,2964,2)
(2346,3570,2)
(4736,2585,2)
(8198,2445,2)
(7822,8994,2)
(8719,1734,2)
(2976,4725,2)
(730,7697,2)
(7798,8020,2)
(6883,4928,2)
(3837,1502,2)
(7403,7004,2)
(5294,3313,2)
(4155,68,2)
(6546,1092,2)
(1250,2041,2)
(504,8188,2)
(6560,6692,2)
(7089,1502,2)
(4173,2084,2)
(2943,7369,2)
(7088,7552,2)
(6753,3421,2)
(8463,2819,2)
(310,1502,2)
(8218,3346,2)
(6136,5922,2)
(8310,720,2)
(2454,5922,2)
(8991,8073,2)
(7134,317,2)
(7506,8566,2)
(7197,847,2)
(6801,9101,2)
(7807,6047,2)
(8728,1502,2)
(8759,8550,2)
(2350,5977,2)
(4839,8576,2)
(3618,4928,2)
(1446,6047,2)
(6658,8991,2)
(3758,9104,2)
(3173,7826,2)
(3846,243,2)
(6942,7351,2)
(3774,4224,2)
(3710,3442,2)
(2820,7371,2)
(5219,5939,2)
(4024,6404,2)
(9037,7033,2)
(638,1502,2)
(5266,6648,2)
(2656,5510,2)
(7767,2823,2)
(6060,7826,2)
(876,2322,2)
(2203,4050,2)
(5723,9025,2)
(4625,5538,2)
(5933,1890,2)
(7746,4052,2)
(3386,2032,2)
(4117,7371,2)
(4166,6512,2)
(1923,4928,2)
(2300,419,2)
(1322,4548,2)
(328,2057,2)
(1197,4928,2)
(7972,7442,2)
(7807,1502,2)
(8399,3874,2)
(3891,4974,2)
(3249,3526,2)
(7532,8362,2)
(4025,3872,2)
(3989,466,2)
(436,3702,2)
(5662,250,2)
(5393,1516,2)
(802,8542,2)
(1709,8423,2)
(8561,9091,2)
(1630,6186,2)
(8238,3520,2)
(2637,7659,2)
(2813,7318,2)
(5305,1158,2)
(1425,5342,2)
(2292,3826,2)
(3991,8362,2)
(4782,291,2)
(6607,2708,2)
(800,3448,2)
(1774,3097,2)
(7238,6718,2)
(3855,4928,2)
(6036,8975,2)
(5191,6967,2)
(6526,847,2)
(2468,4196,2)
(7989,3702,2)
(688,802,2)
(5819,6692,2)
(7821,4647,2)
(1511,7619,2)
(2028,3082,2)
(3936,7826,2)
(3931,4561,2)
(8550,8789,2)
(2128,4928,2)
(4811,4860,2)
(5844,7359,2)
(4876,3937,2)
(4284,4928,2)
(7730,3448,2)
(8357,5969,2)
(5610,4994,2)
(4682,7315,2)
(5960,8447,2)
(2136,8425,2)
(5891,8576,2)
(3089,2782,2)
(1497,8975,2)
(104,3775,2)
(158,7647,2)
(1294,3511,2)
(5216,7359,2)
(5211,6264,2)
(435,4928,2)
(856,3172,2)
(5787,4928,2)
(7562,6718,2)
(3316,4857,2)
(1806,3049,2)
(2621,4729,2)
(2661,1977,2)
(53,5247,2)
(1997,5867,2)
(741,6958,2)
(4456,1306,2)
(5113,4443,2)
(6262,169,2)
(6773,8741,2)
(4956,4196,2)
(5476,8499,2)
(4087,3817,2)
(4878,5025,2)
(2230,2394,2)
(8764,1168,2)
(1728,3350,2)
(5156,5487,2)
(4374,6795,2)
(2621,2057,2)
(3575,1502,2)
(1717,8074,2)
(4438,2038,2)
(8773,4647,2)
(5207,3965,2)
(5072,8362,2)
(492,3965,2)
(2232,1890,2)
(1096,7359,2)
(6696,7438,2)
(1636,7948,2)
(4511,4443,2)
(3527,6058,2)
(3905,3125,2)
(6747,8701,2)
(423,8825,2)
(3414,4928,2)
(2290,5894,2)
(625,8252,2)
(8469,2801,2)
(8619,3965,2)
(1438,3185,2)
(6202,3259,2)
(883,3917,2)
(7641,539,2)
(2703,6512,2)
(9037,677,2)
(8403,2347,2)
(2295,4928,2)
(5294,1255,2)
(5444,8799,2)
(3057,5969,2)
(6278,3537,2)
(8701,7898,2)
(8626,2555,2)
(8901,3448,2)
(79,4878,2)
(2173,2404,2)
(495,5025,2)
(1235,1492,2)
(4808,5902,2)
(4033,8576,2)
(7915,6958,2)
(4586,533,2)
(4494,1168,2)
(8480,1502,2)
(1159,7826,2)
(2320,4551,2)
(3803,6404,2)
(5214,6996,2)
(8860,8748,2)
(550,550,2)
(847,7589,2)
(8362,6709,2)
(2801,6205,2)
(2056,1502,2)
(7753,7359,2)
(1326,8516,2)
(4760,1686,2)
(3547,1546,2)
(342,7359,2)
(7833,7717,2)
(3871,8367,2)
(7260,3924,2)
(3677,8032,2)
(4171,3158,2)
(8408,1502,2)
(3020,7438,2)
(4974,8362,2)
(8244,1905,2)
(6706,5902,2)
(3385,1502,2)
(9092,7744,2)
(394,4928,2)
(7651,1502,2)
(7200,6128,2)
(7522,4928,2)
(4714,1256,2)
(3475,8362,2)
(5265,1346,2)
(4167,5025,2)
(4291,7429,2)
(8325,9123,2)
(3391,3775,2)
(5666,7554,2)
(4293,6512,2)
(6610,3527,2)
(2745,5025,2)
(7736,2851,2)
(5456,972,2)
(5254,6396,2)
(5614,6568,2)
(5646,7681,2)
(6365,7004,2)
(5244,3179,2)
(5902,2464,2)
(4372,7849,2)
(7377,4928,2)
(1222,383,2)
(2264,3304,2)
(190,6958,2)
(7602,1063,2)
(2320,8188,2)
(705,5392,2)
(7863,1306,2)
(8254,805,2)
(9099,1734,2)
(6258,8991,2)
(751,8938,2)
(956,1227,2)
(1707,6195,2)
(1189,6512,2)
(2758,9105,2)
(7998,3965,2)
(3721,1502,2)
(2247,3798,2)
(346,4259,2)
(2712,3456,2)
(607,3367,2)
(6472,1321,2)
(8336,4928,2)
(6034,3775,2)
(2998,2394,2)
(3415,8466,2)
(8789,3493,2)
(1404,1890,2)
(5294,3907,2)
(821,2604,2)
(2290,3702,2)
(727,8499,2)
(2605,2898,2)
(4124,1502,2)
(2679,7826,2)
(4778,8343,2)
(6430,1168,2)
(3255,8282,2)
(7127,8271,2)
(7800,6264,2)
(3116,8032,2)
(2320,5922,2)
(2544,2576,2)
(7756,8447,2)
(5383,9155,2)
(8938,9025,2)
(5688,8362,2)
(2825,6642,2)
(5602,7826,2)
(2908,6128,2)
(8510,1603,2)
(295,5992,2)
(9042,5902,2)
(6234,7826,2)
(4349,7442,2)
(8336,2709,2)
(7097,6404,2)
(6450,5902,2)
(6280,8362,2)
(1686,4760,2)
(7221,2088,2)
(1465,5025,2)
(8916,6512,2)
(6959,909,2)
(8584,4928,2)
(8780,6431,2)
(6415,3965,2)
(2317,2555,2)
(3884,4928,2)
(7575,8975,2)
(5381,7826,2)
(6406,2783,2)
(4502,8799,2)
(383,7055,2)
(643,8362,2)
(3045,2708,2)
(2792,4193,2)
(4196,5266,2)
(3350,8183,2)
(8049,8833,2)
(1635,8271,2)
(9037,1228,2)
(373,8970,2)
(5247,6318,2)
(465,2585,2)
(2325,2028,2)
(3150,5037,2)
(4226,701,2)
(5490,175,2)
(6304,742,2)
(4846,598,2)
(3580,5445,2)
(5394,8362,2)
(4169,1502,2)
(3971,4928,2)
(6792,6562,2)
(2659,5867,2)
(7548,1502,2)
(65,6512,2)
(3663,6392,2)
(6489,1053,2)
(1147,6404,2)
(6334,4497,2)
(7023,5029,2)
(2703,720,2)
(2436,1832,2)
(268,847,2)
(1298,3583,2)
(431,1506,2)
(8426,3527,2)
(137,5730,2)
(7805,4897,2)
(3285,8247,2)
(6085,8362,2)
(6609,4085,2)
(6569,1502,2)
(8308,8362,2)
(5398,5934,2)
(468,8362,2)
(587,7666,2)
(4765,200,2)
(1044,3049,2)
(8998,533,2)
(2656,527,2)
(7864,6124,2)
(122,4634,2)
(7023,5939,2)
(6529,2166,2)
(5743,8362,2)
(8479,4196,2)
(339,5867,2)
(6509,4688,2)
(7227,6128,2)
(6304,598,2)
(6304,1314,2)
(3433,4928,2)
(5407,2758,2)
(5665,5325,2)
(4217,1546,2)
(7198,3570,2)
(6346,6295,2)
(2324,1924,2)
(5320,720,2)
(8194,258,2)
(7185,7849,2)
(8891,7468,2)
(3370,5712,2)
(7055,1502,2)
(7264,2394,2)
(7389,5717,2)
(5913,2249,2)
(825,4252,2)
(4623,7526,2)
(1717,4142,2)
(9137,7905,2)
(1102,334,2)
(4313,5294,2)
(7997,8362,2)
(5110,2851,2)
(4093,5992,2)
(3180,6225,2)
(7046,7092,2)
(5225,3963,2)
(8784,2057,2)
(6304,6465,2)
(7097,3077,2)
(6100,3185,2)
(8515,236,2)
(124,375,2)
(3397,8748,2)
(8067,4193,2)
(6181,5024,2)
(3193,406,2)
(5073,8505,2)
(2964,3279,2)
(5341,1502,2)
(8940,5693,2)
(7865,3448,2)
(1021,7941,2)
(533,701,2)
(7378,3570,2)
(566,5247,2)
(1942,2574,2)
(7609,7388,2)
(7715,1701,2)
(8147,5712,2)
(4923,4252,2)
(8697,1924,2)
(2611,3757,2)
(43,3911,2)
(5938,3350,2)
(4699,1341,2)
(4103,533,2)
(9019,3583,2)
(6199,98,2)
(9134,5714,2)
(7147,6648,2)
(427,3705,2)
(6704,8159,2)
(1085,3114,2)
(3158,4808,2)
(8278,2705,2)
(6964,1072,2)
(5633,169,2)
(8343,3702,2)
(1328,5525,2)
(1170,7826,2)
(6202,1502,2)
(8299,2057,2)
(552,720,2)
(5658,5398,2)
(7053,5247,2)
(8691,8362,2)
(4292,8362,2)
(544,5266,2)
(4006,6318,2)
(6381,4019,2)
(2473,1502,2)
(1185,1502,2)
(2791,3399,2)
(6027,902,2)
(5047,7941,2)
(5230,7438,2)
(3511,6270,2)
(1178,8271,2)
(5294,7216,2)
(7120,936,2)
(5759,4928,2)
(4356,8830,2)
(1742,3636,2)
(6131,7826,2)
(1423,6431,2)
(167,3527,2)
(7994,1385,2)
(595,3965,2)
(991,7160,2)
(3589,8320,2)
(5780,8425,2)
(6331,8811,2)
(7651,1635,2)
(6967,9129,2)
(1945,2609,2)
(4602,3989,2)
(340,7826,2)
(2483,5351,2)
(397,1617,2)
(3669,8032,2)
(3247,7529,2)
(6934,5608,2)
(235,3757,2)
(5839,2907,2)
(8486,1003,2)
(6485,7937,2)
(5883,6945,2)
(6703,3125,2)
(483,3032,2)
(161,3430,2)
(4437,6560,2)
(1810,460,2)
(4809,1502,2)
(1828,7468,2)
(4070,2898,2)
(3043,8799,2)
(8094,5854,2)
(5997,4995,2)
(7765,6842,2)
(2548,8362,2)
(3093,393,2)
(6613,8074,2)
(1385,7468,2)
(7178,1690,2)
(812,5255,2)
(7110,7826,2)
(4517,1502,2)
(8036,8499,2)
(8658,7060,2)
(8618,8362,2)
(6351,2698,2)
(8880,4232,2)
(6,7892,2)
(7523,9122,2)
(6482,7666,2)
(5086,1502,2)
(1591,5693,2)
(6304,7141,2)
(3598,3965,2)
(4681,7369,2)
(8008,720,2)
(2835,8362,2)
(478,4682,2)
(4592,4196,2)
(9061,1009,2)
(7896,3636,2)
(4920,6334,2)
(2450,3965,2)
(4395,6318,2)
(8310,404,2)
(5091,1498,2)
(4201,8975,2)
(3220,8362,2)
(400,1502,2)
(2256,8362,2)
(6177,533,2)
(8735,175,2)
(7150,3238,2)
(8524,2125,2)
(7039,7515,2)
(9052,8499,2)
(502,7371,2)
(5322,6512,2)
(5859,7674,2)
(902,7004,2)
(2886,3965,2)
(4994,6124,2)
(3681,7513,2)
(4372,1502,2)
(8666,6244,2)
(2403,1502,2)
(1817,5939,2)
(5294,6423,2)
(1103,7826,2)
(1250,6232,2)
(1815,2057,2)
(2051,1320,2)
(8540,8811,2)
(375,2898,2)
(4070,7666,2)
(7256,169,2)
(4964,7768,2)
(7707,1502,2)
(1968,1502,2)
(8530,3775,2)
(7720,8423,2)
(5465,5980,2)
(1214,1471,2)
(9084,2394,2)
(3807,3163,2)
(6211,6186,2)
(1768,7211,2)
(6423,3852,2)
(7896,1502,2)
(578,3997,2)
(5733,8362,2)
(8556,5693,2)
(3826,3051,2)
(478,809,2)
(9015,3217,2)
(6562,5712,2)
(0,1774,2)
(8792,3702,2)
(6567,9101,2)
(2780,3989,2)
(4588,6718,2)
(6066,3963,2)
(9024,2445,2)
(54,3817,2)
(483,8408,2)
(1387,8362,2)
(5095,6718,2)
(336,6674,2)
(323,4022,2)
(2121,7674,2)
(9014,8799,2)
(3141,8362,2)
(7699,4443,2)
(2088,7826,2)
(369,131,2)
(7521,3530,2)
(7114,4548,2)
(1229,1321,2)
(3636,8362,2)
(8195,2209,2)
(5197,7629,2)
(2778,418,2)
(732,582,2)
(2429,2347,2)
(8087,5445,2)
(4955,7675,2)
(2491,1502,2)
(1012,235,2)
(4769,1502,2)
(6952,1278,2)
(6698,8875,2)
(3582,3857,2)
(5712,8516,2)
(6566,4130,2)
(3604,882,2)
(3347,4022,2)
(828,1731,2)
(930,8388,2)
(7780,4896,2)
(4898,4252,2)
(8150,175,2)
(4705,5992,2)
(2473,8991,2)
(1466,2038,2)
(8313,3963,2)
(2230,4320,2)
(4120,2125,2)
(8053,8271,2)
(6304,5559,2)
(5184,418,2)
(7504,6479,2)
(7971,6512,2)
(881,6855,2)
(3880,4928,2)
(4212,4928,2)
(1823,4928,2)
(586,8563,2)
(4986,701,2)
(7511,720,2)
(7767,5939,2)
(891,1502,2)
(5506,539,2)
(7434,7826,2)
(188,2125,2)
(649,8671,2)
(8585,1440,2)
(6909,2851,2)
(5826,936,2)
(3654,7390,2)
(7804,8282,2)
(1303,8991,2)
(1288,2969,2)
(2509,3872,2)
(6645,3489,2)
(2714,720,2)
(8104,5273,2)
(4810,392,2)
(2257,4246,2)
(3304,6566,2)
(4699,5043,2)
(2278,3854,2)
(8131,4204,2)
(492,1502,2)
(4148,4934,2)
(7399,7273,2)
(7611,3527,2)
(5110,6431,2)
(342,5216,2)
(1214,5025,2)
(2565,4928,2)
(8892,4928,2)
(5282,6855,2)
(6181,7004,2)
(4055,235,2)
(7486,847,2)
(1550,8701,2)
(2219,6890,2)
(2299,4928,2)
(5086,2394,2)
(2114,1863,2)
(7612,797,2)
(2394,4837,2)
(9037,6560,2)
(1085,1254,2)
(1667,1832,2)
(3421,6058,2)
(2704,4364,2)
(7688,7472,2)
(6134,7338,2)
(8627,4199,2)
(7442,4224,2)
(2657,2851,2)
(4830,2057,2)
(3670,720,2)
(5471,7359,2)
(3137,7481,2)
(6971,697,2)
(100,1688,2)
(1457,8362,2)
(7444,1575,2)
(8138,8499,2)
(7745,8499,2)
(1682,8020,2)
(3469,260,2)
(664,6225,2)
(9037,9075,2)
(3423,6195,2)
(3290,3350,2)
(5797,1085,2)
(7985,5839,2)
(5590,7849,2)
(7871,4397,2)
(2675,6195,2)
(5294,7148,2)
(7253,3520,2)
(2025,847,2)
(4274,6128,2)
(394,1502,2)
(4624,740,2)
(3874,4744,2)
(4437,1855,2)
(2049,5266,2)
(6818,4541,2)
(2835,1502,2)
(1119,5662,2)
(6764,8362,2)
(1539,4928,2)
(1253,6718,2)
(3540,3088,2)
(3214,7619,2)
(2654,5992,2)
(5446,6958,2)
(661,2783,2)
(6882,720,2)
(1902,4497,2)
(2912,4928,2)
(7215,4647,2)
(6196,7536,2)
(4532,8455,2)
(8050,7202,2)
(3392,8020,2)
(1760,8875,2)
(8529,5025,2)
(3699,8975,2)
(3793,2347,2)
(2090,7826,2)
(0,2290,2)
(4314,7309,2)
(3025,2609,2)
(4313,7238,2)
(6301,7941,2)
(3241,8799,2)
(5402,4878,2)
(632,1890,2)
(6515,7619,2)
(5798,9015,2)
(6964,7318,2)
(2602,2445,2)
(4088,6090,2)
(2697,4928,2)
(2937,1502,2)
(6119,3798,2)
(8099,6738,2)
(2928,5705,2)
(9125,2705,2)
(2983,4196,2)
(2823,5939,2)
(9015,6512,2)
(6607,1502,2)
(7191,7062,2)
(3376,8505,2)
(2381,3905,2)
(1682,826,2)
(2349,411,2)
(8884,3350,2)
(3466,7438,2)
(6299,8423,2)
(5411,3963,2)
(3552,8576,2)
(3126,6607,2)
(6398,1441,2)
(4553,2898,2)
(644,673,2)
(2000,2469,2)
(2642,8452,2)
(2483,4612,2)
(3528,2728,2)
(1992,1168,2)
(5165,6195,2)
(1210,2047,2)
(4571,7179,2)
(1091,5340,2)
(9032,5466,2)
(3874,6431,2)
(5281,4196,2)
(1885,5867,2)
(3739,8252,2)
(8685,8362,2)
(5195,720,2)
(6375,4397,2)
(5949,3532,2)
(4352,7202,2)
(1047,3098,2)
(2677,3989,2)
(6988,4386,2)
(6065,338,2)
(5082,593,2)
(6145,1693,2)
(8829,6465,2)
(1244,533,2)
(1139,6225,2)
(3416,6938,2)
(6132,6550,2)
(6225,8247,2)
(4827,3217,2)
(1986,311,2)
(89,1102,2)
(2728,3125,2)
(7329,9100,2)
(8499,3775,2)
(2219,847,2)
(4437,5559,2)
(4623,826,2)
(2482,6048,2)
(1666,1168,2)
(7105,8991,2)
(1202,4820,2)
(8440,260,2)
(219,8362,2)
(2389,2057,2)
(1471,4765,2)
(5611,539,2)
(4578,6404,2)
(249,8362,2)
(701,4878,2)
(1389,243,2)
(3361,5037,2)
(1245,7826,2)
(6304,4985,2)
(729,175,2)
(135,6718,2)
(2333,8701,2)
(7905,7405,2)
(9130,4928,2)
(6151,8362,2)
(4652,5191,2)
(4313,6304,2)
(5294,1228,2)
(557,176,2)
(5817,8247,2)
(7649,411,2)
(5343,4928,2)
(6767,9063,2)
(7687,3857,2)
(1617,720,2)
(4016,8159,2)
(3487,805,2)
(8415,1650,2)
(972,1502,2)
(7748,4824,2)
(2734,7309,2)
(3498,8875,2)
(4684,6512,2)
(1419,7826,2)
(2750,8362,2)
(6501,1321,2)
(2503,2828,2)
(6466,6404,2)
(6295,9126,2)
(1646,6047,2)
(3399,2757,2)
(5116,1037,2)
(2846,2125,2)
(7598,2585,2)
(8973,832,2)
(6076,8516,2)
(4146,5939,2)
(7275,8624,2)
(5488,3702,2)
(4846,4551,2)
(7816,8362,2)
(2103,4196,2)
(1722,3188,2)
(5795,4499,2)
(2370,1515,2)
(867,2112,2)
(455,2893,2)
(5713,7202,2)
(3950,3019,2)
(5468,1883,2)
(3862,7666,2)
(3847,5025,2)
(135,7937,2)
(7117,1502,2)
(3137,573,2)
(8280,1502,2)
(6277,720,2)
(5799,2585,2)
(6127,5504,2)
(672,7533,2)
(6056,941,2)
(5078,7160,2)
(2696,7552,2)
(3752,4878,2)
(5901,1306,2)
(2230,8681,2)
(1355,8362,2)
(4259,8067,2)
(3162,847,2)
(9065,3163,2)
(9037,908,2)
(3341,3608,2)
(6976,2585,2)
(5065,1515,2)
(2077,8362,2)
(5603,2404,2)
(7046,8037,2)
(2954,1168,2)
(5170,7444,2)
(7621,7826,2)
(8869,6236,2)
(913,4397,2)
(6893,5867,2)
(7545,4352,2)
(8902,2619,2)
(2564,805,2)
(189,8938,2)
(7655,1635,2)
(6427,720,2)
(4472,4986,2)
(6425,1009,2)
(2221,7277,2)
(5351,6642,2)
(693,4928,2)
(3177,1449,2)
(8470,2801,2)
(9026,4551,2)
(8636,1502,2)
(5448,4928,2)
(558,131,2)
(9077,5693,2)
(4635,8362,2)
(216,5486,2)
(4067,8499,2)
(7172,4928,2)
(5511,2705,2)
(7777,243,2)
(829,997,2)
(888,5371,2)
(8086,5969,2)
(8927,4824,2)
(9012,2180,2)
(3074,2249,2)
(5327,4928,2)
(4260,7687,2)
(5295,6323,2)
(2262,9091,2)
(1048,7004,2)
(8149,847,2)
(5368,8825,2)
(5606,7369,2)
(8886,4573,2)
(6873,8032,2)
(9109,8466,2)
(9031,1761,2)
(696,8032,2)
(323,3989,2)
(5164,8576,2)
(5437,3543,2)
(7991,7148,2)
(445,3049,2)
(5700,3379,2)
(2382,2249,2)
(8829,6560,2)
(5436,39,2)
(4058,212,2)
(3688,991,2)
(773,3421,2)
(1380,4928,2)
(2308,1303,2)
(7832,6404,2)
(6674,1516,2)
(8564,5319,2)
(628,3125,2)
(4065,1502,2)
(2963,4196,2)
(5545,7826,2)
(8554,6160,2)
(4572,1591,2)
(1639,1321,2)
(4078,4734,2)
(8781,4548,2)
(3579,1306,2)
(4462,212,2)
(7279,2585,2)
(1200,5025,2)
(7754,3705,2)
(225,8362,2)
(7529,4928,2)
(8421,4928,2)
(358,466,2)
(3605,7062,2)
(6358,8499,2)
(6908,169,2)
(9008,7468,2)
(9105,2445,2)
(7135,4196,2)
(3666,8252,2)
(5180,8362,2)
(1442,1617,2)
(9155,5824,2)
(3292,1617,2)
(5618,5230,2)
(3863,4360,2)
(5526,3365,2)
(7289,2708,2)
(9015,7017,2)
(66,847,2)
(6150,2898,2)
(4615,6860,2)
(2088,4238,2)
(1316,451,2)
(3993,720,2)
(2270,8668,2)
(3409,4928,2)
(4155,3917,2)
(8879,4647,2)
(2965,39,2)
(3884,1502,2)
(6737,4934,2)
(4755,7941,2)
(7658,5867,2)
(843,1628,2)
(7681,4647,2)
(9062,7517,2)
(2415,150,2)
(6612,4224,2)
(68,3917,2)
(6640,6047,2)
(5364,720,2)
(3299,3421,2)
(1777,2585,2)
(3181,3965,2)
(7037,4934,2)
(1339,7826,2)
(7215,4065,2)
(2006,3350,2)
(2532,131,2)
(4229,5693,2)
(3720,8310,2)
(4996,4928,2)
(409,8499,2)
(1912,8099,2)
(2594,8423,2)
(6603,2698,2)
(4176,6648,2)
(3087,404,2)
(2174,3472,2)
(3114,607,2)
(1658,847,2)
(5574,2708,2)
(1828,1502,2)
(1075,4928,2)
(6535,291,2)
(7262,2994,2)
(4907,3965,2)
(1814,832,2)
(8106,2555,2)
(4150,7826,2)
(2771,3810,2)
(6374,1924,2)
(4506,8425,2)
(8886,4022,2)
(7885,2112,2)
(8759,317,2)
(2852,8189,2)
(4749,6562,2)
(2550,8447,2)
(6604,3963,2)
(6019,7179,2)
(876,7821,2)
(7781,7438,2)
(8827,2549,2)
(50,7422,2)
(7545,7202,2)
(6594,5266,2)
(7079,6967,2)
(6983,3757,2)
(5683,5043,2)
(7109,2708,2)
(2212,5969,2)
(1677,6512,2)
(1548,6517,2)
(4341,5939,2)
(7610,4928,2)
(306,8362,2)
(9079,3417,2)
(607,4404,2)
(4371,1502,2)
(5558,5939,2)
(141,1502,2)
(3594,1092,2)
(9029,1491,2)
(1241,9101,2)
(4397,6186,2)
(4919,5523,2)
(3656,6907,2)
(8850,4928,2)
(6304,7148,2)
(4784,7004,2)
(1590,3420,2)
(3877,1617,2)
(7991,598,2)
(2137,1924,2)
(8349,4140,2)
(876,8545,2)
(3333,6931,2)
(1443,8362,2)
(6435,4509,2)
(5941,3527,2)
(79,182,2)
(1929,8563,2)
(1582,2698,2)
(7827,7826,2)
(1211,8035,2)
(8943,3158,2)
(8829,7100,2)
(2414,1102,2)
(2863,4928,2)
(582,6404,2)
(7038,7619,2)
(3509,5525,2)
(9150,3753,2)
(4472,1489,2)
(7521,1502,2)
(8999,8362,2)
(4916,9101,2)
(3169,6413,2)
(543,1502,2)
(3982,697,2)
(6786,5043,2)
(605,7937,2)
(8002,2609,2)
(2401,2445,2)
(2027,427,2)
(6725,8701,2)
(1482,3350,2)
(893,2621,2)
(4686,847,2)
(393,3258,2)
(5294,908,2)
(5470,418,2)
(950,3775,2)
(2248,6048,2)
(6711,1168,2)
(792,5867,2)
(8091,8179,2)
(4561,1502,2)
(3573,3937,2)
(7613,2394,2)
(3575,3350,2)
(4248,8799,2)
(459,2032,2)
(3077,1360,2)
(4167,683,2)
(1782,7076,2)
(1099,8499,2)
(2898,7666,2)
(6304,720,2)
(7043,4928,2)
(2941,554,2)
(1900,8271,2)
(8623,4232,2)
(4518,2394,2)
(8021,8388,2)
(5717,7666,2)
(7468,5115,2)
(310,847,2)
(5396,3636,2)
(7258,1617,2)
(6169,5025,2)
(4353,4878,2)
(5029,5939,2)
(3928,1306,2)
(5294,3017,2)
(5728,8071,2)
(2732,1502,2)
(6039,2994,2)
(2568,1502,2)
(1402,7468,2)
(538,7468,2)
(8240,2112,2)
(5614,8428,2)
(948,2582,2)
(1731,1273,2)
(8252,8362,2)
(5075,6745,2)
(3098,7937,2)
(1518,5992,2)
(4307,6128,2)
(4860,4928,2)
(5023,4176,2)
(5087,2469,2)
(4437,4373,2)
(2996,5939,2)
(1256,849,2)
(1934,4928,2)
(3716,720,2)
(7469,7062,2)
(5652,8362,2)
(5448,1502,2)
(5957,6299,2)
(3880,6047,2)
(5456,8362,2)
(3243,2347,2)
(3143,2394,2)
(6109,5320,2)
(3403,8362,2)
(6075,5043,2)
(8040,2708,2)
(2497,2249,2)
(845,4934,2)
(8266,2394,2)
(7435,8412,2)
(4874,802,2)
(4212,1502,2)
(1043,1502,2)
(4310,1193,2)
(6510,6404,2)
(7117,4928,2)
(4437,1489,2)
(2441,3163,2)
(7320,3705,2)
(2208,1168,2)
(6141,2546,2)
(4029,2032,2)
(4428,1717,2)
(5887,6404,2)
(3985,8811,2)
(8922,2609,2)
(7421,4196,2)
(6705,1502,2)
(1184,1053,2)
(7468,8678,2)
(8833,3775,2)
(2792,6431,2)
(669,3421,2)
(874,3702,2)
(7706,2494,2)
(3780,3549,2)
(7820,9101,2)
(7883,847,2)
(8113,8811,2)
(637,4022,2)
(6924,2394,2)
(8636,4682,2)
(3026,7807,2)
(98,3341,2)
(569,8701,2)
(1227,5867,2)
(8199,2394,2)
(6599,8362,2)
(9037,7148,2)
(1977,8499,2)
(5555,5445,2)
(6114,2057,2)
(1872,5025,2)
(1828,3583,2)
(2914,7826,2)
(3152,4928,2)
(1463,4702,2)
(5061,2394,2)
(8895,8948,2)
(5675,1691,2)
(4692,8799,2)
(1451,2898,2)
(3346,2325,2)
(1072,4835,2)
(8950,8362,2)
(7195,7826,2)
(7405,3252,2)
(1152,3965,2)
(7016,4928,2)
(3622,1321,2)
(6307,2180,2)
(326,6550,2)
(2645,6323,2)
(7059,3963,2)
(4224,7515,2)
(8731,3775,2)
(302,7062,2)
(5437,936,2)
(1850,7565,2)
(5346,8499,2)
(5667,2394,2)
(3412,4257,2)
(3924,8362,2)
(6015,1889,2)
(2440,6731,2)
(2556,701,2)
(9069,7309,2)
(2732,2445,2)
(2320,6560,2)
(5608,4532,2)
(2599,514,2)
(272,7826,2)
(8729,2630,2)
(5669,243,2)
(4958,8425,2)
(936,8362,2)
(8855,847,2)
(3898,8799,2)
(1291,3963,2)
(5599,2708,2)
(4366,8362,2)
(6194,6404,2)
(7338,5712,2)
(2867,250,2)
(1755,1502,2)
(401,59,2)
(5925,250,2)
(7737,8172,2)
(3462,87,2)
(8751,539,2)
(8635,2325,2)
(4767,2440,2)
(4133,8362,2)
(6743,9096,2)
(9065,1502,2)
(6563,5939,2)
(140,2394,2)
(150,2057,2)
(4455,1502,2)
(1292,4304,2)
(251,7941,2)
(4810,243,2)
(7389,7666,2)
(5019,171,2)
(491,8362,2)
(7918,550,2)
(88,4974,2)
(925,3965,2)
(4919,7179,2)
(2548,1515,2)
(8603,3677,2)
(4466,6058,2)
(350,4825,2)
(8726,9091,2)
(5609,2207,2)
(7196,4553,2)
(5230,4015,2)
(78,6404,2)
(5782,4909,2)
(7362,1502,2)
(1691,3937,2)
(3694,5525,2)
(655,7371,2)
(4843,1502,2)
(8586,4085,2)
(3425,4252,2)
(1893,2394,2)
(5986,533,2)
(2697,8362,2)
(4601,7309,2)
(1008,4347,2)
(2753,7826,2)
(3928,7379,2)
(5306,4760,2)
(7077,8678,2)
(2354,5025,2)
(7261,4928,2)
(4826,5867,2)
(7894,4928,2)
(4183,1617,2)
(8644,3049,2)
(4127,8505,2)
(5743,8635,2)
(7041,8423,2)
(7691,6550,2)
(4887,2585,2)
(1494,7240,2)
(4380,6195,2)
(2494,1502,2)
(1302,284,2)
(2512,5025,2)
(3995,9101,2)
(905,9091,2)
(7928,5043,2)
(4572,5559,2)
(774,2708,2)
(2656,5249,2)
(8534,4232,2)
(1213,8362,2)
(4623,5030,2)
(2812,6454,2)
(1840,8271,2)
(1859,5922,2)
(5915,169,2)
(4555,8146,2)
(2985,4507,2)
(5018,3989,2)
(175,5457,2)
(7854,5214,2)
(8716,605,2)
(2340,2156,2)
(5653,847,2)
(5655,8585,2)
(863,4196,2)
(2407,1306,2)
(1903,2994,2)
(6911,9091,2)
(3259,2392,2)
(666,3028,2)
(6449,936,2)
(2329,1077,2)
(5398,5969,2)
(3470,8008,2)
(8182,1778,2)
(8722,3350,2)
(2633,6562,2)
(8148,2057,2)
(2948,8362,2)
(7933,6323,2)
(2566,4155,2)
(4299,8576,2)
(1077,8362,2)
(8624,5712,2)
(8364,3705,2)
(5024,6562,2)
(801,2196,2)
(6250,175,2)
(2411,8008,2)
(2617,8032,2)
(11,2585,2)
(2050,2767,2)
(7772,3346,2)
(4656,8362,2)
(4708,8671,2)
(2069,2057,2)
(8119,7369,2)
(5086,6047,2)
(7920,3527,2)
(385,8499,2)
(8189,6236,2)
(5123,8362,2)
(7794,6133,2)
(8634,2585,2)
(8987,3448,2)
(8674,39,2)
(433,4995,2)
(6476,8035,2)
(6997,3163,2)
(8516,3989,2)
(3463,1502,2)
(3229,8991,2)
(8981,266,2)
(3723,8032,2)
(3837,4928,2)
(820,5480,2)
(7495,847,2)
(4240,2347,2)
(7919,7826,2)
(4437,932,2)
(5658,7556,2)
(7379,2407,2)
(782,4178,2)
(2417,4744,2)
(418,3032,2)
(8893,6431,2)
(7363,8362,2)
(8120,7062,2)
(2043,551,2)
(3195,3570,2)
(2109,4928,2)
(7682,6512,2)
(2698,2440,2)
(9139,2708,2)
(3114,3367,2)
(4313,8829,2)
(8908,6003,2)
(4464,3332,2)
(8272,175,2)
(6902,6195,2)
(4702,1502,2)
(4818,4878,2)
(5142,1502,2)
(7154,802,2)
(3617,4212,2)
(7419,3965,2)
(7900,7186,2)
(1689,1516,2)
(7557,6124,2)
(1100,8671,2)
(2181,7826,2)
(3961,8629,2)
(4678,2898,2)
(2222,8463,2)
(7814,1502,2)
(8222,9072,2)
(8668,3272,2)
(7860,8799,2)
(892,1168,2)
(7179,2358,2)
(3840,3775,2)
(6545,5300,2)
(263,5043,2)
(6247,1635,2)
(8060,8247,2)
(3963,7518,2)
(4402,3421,2)
(5212,7438,2)
(8864,8362,2)
(4942,6975,2)
(633,6195,2)
(1726,1502,2)
(1774,8792,2)
(8513,1502,2)
(8480,4928,2)
(5035,1003,2)
(9028,526,2)
(5222,1484,2)
(2879,7369,2)
(157,1433,2)
(4930,7474,2)
(3420,1502,2)
(7271,6318,2)
(5291,8299,2)
(2027,3705,2)
(2443,2705,2)
(7311,5954,2)
(2215,8701,2)
(4313,6182,2)
(2831,2483,2)
(7978,2112,2)
(254,7941,2)
(4548,3775,2)
(8057,7666,2)
(4313,7991,2)
(2663,8159,2)
(4482,7941,2)
(1791,8020,2)
(5267,3937,2)
(4811,805,2)
(5807,6730,2)
(8614,720,2)
(4297,8091,2)
(6008,5025,2)
(4990,8362,2)
(6964,1062,2)
(2540,3032,2)
(2935,6855,2)
(911,539,2)
(5327,6047,2)
(361,1502,2)
(7130,2394,2)
(749,7826,2)
(2340,1889,2)
(8744,5867,2)
(504,2893,2)
(5646,6776,2)
(7404,2585,2)
(8217,6721,2)
(2967,1502,2)
(1288,6195,2)
(7132,1502,2)
(413,175,2)
(341,7790,2)
(8578,1731,2)
(6102,1502,2)
(6872,7179,2)
(2157,2585,2)
(2942,4928,2)
(4929,3730,2)
(731,3636,2)
(4471,4682,2)
(7454,5025,2)
(260,1256,2)
(8546,8362,2)
(8622,7179,2)
(5974,8830,2)
(2543,4085,2)
(4298,6158,2)
(6249,7743,2)
(3943,1306,2)
(6577,720,2)
(3603,334,2)
(2266,8362,2)
(7257,586,2)
(626,4252,2)
(5815,701,2)
(2852,6236,2)
(5636,1502,2)
(4442,1502,2)
(4760,550,2)
(1942,8948,2)
(1397,8312,2)
(8945,1502,2)
(8303,3872,2)
(830,1502,2)
(4934,8362,2)
(410,8423,2)
(915,5969,2)
(6703,3528,2)
(5159,4928,2)
(6745,6512,2)
(5955,1191,2)
(8360,3958,2)
(5575,7369,2)
(6825,5969,2)
(1473,250,2)
(4921,6323,2)
(7638,5757,2)
(8946,6642,2)
(606,7232,2)
(8306,3719,2)
(62,3798,2)
(3342,2585,2)
(1908,6111,2)
(5408,6234,2)
(6190,7202,2)
(1873,3251,2)
(659,1829,2)
(7261,8362,2)
(6328,7515,2)
(4517,4928,2)
(3979,4928,2)
(7046,1591,2)
(370,1502,2)
(1981,8875,2)
(8115,6967,2)
(1250,6133,2)
(8870,6133,2)
(3907,8348,2)
(8749,1306,2)
(2885,4196,2)
(648,4928,2)
(8237,9101,2)
(1864,4196,2)
(1628,6787,2)
(134,3174,2)
(1616,720,2)
(6660,8466,2)
(3321,3705,2)
(1004,5030,2)
(8991,8247,2)
(4448,1502,2)
(8990,4928,2)
(4409,1734,2)
(2346,3775,2)
(5040,720,2)
(2435,8701,2)
(591,8362,2)
(7700,1516,2)
(5505,847,2)
(1274,2347,2)
(5181,5576,2)
(4377,4934,2)
(8281,847,2)
(6594,4196,2)
(1222,3125,2)
(6758,1883,2)
(3026,5969,2)
(2461,721,2)
(3048,3032,2)
(6304,908,2)
(2794,8461,2)
(2844,8362,2)
(362,6047,2)
(9055,5043,2)
(3076,6264,2)
(198,8425,2)
(218,6507,2)
(6847,7060,2)
(1155,6404,2)
(5342,6566,2)
(1937,3342,2)
(2570,6404,2)
(6517,4744,2)
(7245,7536,2)
(5705,310,2)
(6273,317,2)
(6748,4928,2)
(148,2141,2)
(6178,3872,2)
(8803,5327,2)
(5359,6318,2)
(3056,7666,2)
(7607,3636,2)
(1394,8016,2)
(4753,6195,2)
(1463,9101,2)
(6405,3965,2)
(4830,2013,2)
(4409,8692,2)
(364,4928,2)
(7699,5113,2)
(829,519,2)
(4491,1502,2)
(3931,5025,2)
(2328,8032,2)
(9090,6047,2)
(5330,7513,2)
(6702,3583,2)
(2766,3993,2)
(8973,1502,2)
(1117,385,2)
(8193,7049,2)
(2277,7536,2)
(6751,3777,2)
(4672,7666,2)
(2248,4085,2)
(3903,2851,2)
(2894,806,2)
(5540,3963,2)
(4840,5273,2)
(6377,953,2)
(2934,8799,2)
(772,1502,2)
(1819,8412,2)
(5528,2394,2)
(5268,3286,2)
(5010,2024,2)
(4812,5608,2)
(5290,4934,2)
(1779,3125,2)
(49,1502,2)
(1216,175,2)
(2585,5744,2)
(3120,7666,2)
(8505,8074,2)
(7397,6864,2)
(4833,6431,2)
(8192,4173,2)
(1719,1628,2)
(7496,4928,2)
(2079,4974,2)
(6705,6047,2)
(3824,5867,2)
(5515,212,2)
(3557,175,2)
(3098,6323,2)
(7131,8701,2)
(8629,32,2)
(687,131,2)
(3293,2555,2)
(6348,7202,2)
(7597,7355,2)
(7309,8197,2)
(2184,8830,2)
(1013,2016,2)
(8082,1731,2)
(6018,4063,2)
(7783,4085,2)
(4808,6048,2)
(93,7826,2)
(3190,1502,2)
(1987,4019,2)
(6887,8032,2)
(356,7202,2)
(6952,3940,2)
(1359,1502,2)
(6932,6855,2)
(5696,4928,2)
(5765,3346,2)
(4772,2898,2)
(8659,4069,2)
(3282,8362,2)
(59,282,2)
(7632,1731,2)
(4281,3928,2)
(5735,3304,2)
(2007,7509,2)
(4720,3527,2)
(1329,8271,2)
(7413,720,2)
(839,1442,2)
(7991,6465,2)
(5250,720,2)
(5517,7819,2)
(7517,8339,2)
(2725,2249,2)
(8526,7826,2)
(2099,8991,2)
(6277,6512,2)
(3755,1502,2)
(4499,1924,2)
(2634,697,2)
(4841,1502,2)
(4912,4928,2)
(3310,7202,2)
(5625,344,2)
(392,243,2)
(3558,3873,2)
(7466,1502,2)
(8520,1502,2)
(7479,3617,2)
(5816,6404,2)
(4390,4928,2)
(7013,4022,2)
(2801,8217,2)
(3722,5859,2)
(6972,1168,2)
(8553,7338,2)
(6818,4817,2)
(2743,5807,2)
(146,1617,2)
(488,8020,2)
(2153,5696,2)
(8997,4647,2)
(6328,1502,2)
(5892,8668,2)
(8027,3570,2)
(5370,5969,2)
(245,1890,2)
(3492,5969,2)
(1194,6186,2)
(5614,4747,2)
(3286,4928,2)
(4240,8701,2)
(7043,5969,2)
(8180,8830,2)
(3827,5300,2)
(7563,1502,2)
(7750,1502,2)
(8527,4721,2)
(7266,291,2)
(5851,8701,2)
(2364,1328,2)
(9108,5608,2)
(2252,5025,2)
(5059,8032,2)
(8159,468,2)
(5403,6718,2)
(5294,3613,2)
(4497,2479,2)
(1371,7388,2)
(3817,7783,2)
(3068,7438,2)
(1413,5024,2)
(4204,5712,2)
(8239,8083,2)
(6998,8908,2)
(5036,8499,2)
(7630,5902,2)
(8608,6731,2)
(4437,1128,2)
(3591,7628,2)
(4332,8748,2)
(5616,8466,2)
(9087,6225,2)
(2971,3350,2)
(6432,407,2)
(2066,7619,2)
(5166,5538,2)
(4631,2394,2)
(3691,8247,2)
(6304,6988,2)
(4932,6202,2)
(6493,8362,2)
(4432,2585,2)
(2915,7826,2)
(8466,5992,2)
(8022,4841,2)
(3886,7062,2)
(7952,131,2)
(8405,3775,2)
(140,2334,2)
(1994,6958,2)
(5220,7826,2)
(8205,5043,2)
(7021,1311,2)
(3306,4928,2)
(1274,8701,2)
(2271,9101,2)
(4896,5273,2)
(5694,3924,2)
(876,7628,2)
(5336,4928,2)
(7939,8183,2)
(6311,8388,2)
(4631,7264,2)
(2343,1067,2)
(6872,4919,2)
(7309,5025,2)
(8656,7359,2)
(8638,6225,2)
(1705,4647,2)
(1049,8748,2)
(8560,6179,2)
(2640,243,2)
(763,3963,2)
(7894,6236,2)
(2492,1338,2)
(6483,8799,2)
(6831,847,2)
(7055,4928,2)
(1809,1955,2)
(3986,539,2)
(7670,818,2)
(111,1617,2)
(107,243,2)
(1685,5997,2)
(2259,5904,2)
(7033,9101,2)
(1033,4682,2)
(3895,2609,2)
(6959,701,2)
(74,8067,2)
(7160,8991,2)
(7793,4928,2)
(6929,6195,2)
(5411,1502,2)
(5865,5839,2)
(8570,2758,2)
(3736,3188,2)
(8201,6323,2)
(3482,8566,2)
(6830,8425,2)
(7308,5172,2)
(3095,9090,2)
(7971,720,2)
(64,175,2)
(8249,6855,2)
(8636,6047,2)
(8513,4928,2)
(5840,8362,2)
(7945,4928,2)
(7098,4928,2)
(6503,2345,2)
(771,4555,2)
(6104,9101,2)
(2038,6855,2)
(298,7666,2)
(565,418,2)
(3810,2440,2)
(4572,8188,2)
(4655,9008,2)
(608,550,2)
(4374,997,2)
(8460,5744,2)
(2280,8020,2)
(5146,3702,2)
(1225,7202,2)
(3178,8020,2)
(8627,4973,2)
(559,1502,2)
(7729,2133,2)
(7531,8276,2)
(6121,6323,2)
(7378,3775,2)
(1856,6958,2)
(5215,7941,2)
(4769,4928,2)
(8675,4350,2)
(3414,720,2)
(8757,1635,2)
(5977,1502,2)
(6642,4158,2)
(6559,4022,2)
(3885,1168,2)
(1968,198,2)
(1319,1498,2)
(4882,2440,2)
(4059,4787,2)
(8788,3965,2)
(7887,304,2)
(4448,8425,2)
(1356,2394,2)
(2686,3658,2)
(7457,1267,2)
(7685,1502,2)
(3990,6479,2)
(4313,4472,2)
(8863,1784,2)
(5846,1731,2)
(5880,6404,2)
(181,8362,2)
(2817,6566,2)
(8179,8748,2)
(588,1321,2)
(738,4928,2)
(2234,8362,2)
(5375,2585,2)
(1270,7628,2)
(3077,6404,2)
(6005,4928,2)
(7378,8566,2)
(7917,4928,2)
(2032,1193,2)
(5854,372,2)
(3030,6562,2)
(3843,6431,2)
(6898,2088,2)
(4245,8830,2)
(176,4928,2)
(5264,4684,2)
(8725,7826,2)
(7100,2464,2)
(2134,3125,2)
(3953,8362,2)
(1309,8362,2)
(7379,1306,2)
(5530,1761,2)
(2013,1502,2)
(180,8362,2)
(8762,3965,2)
(451,8805,2)
(6606,6512,2)
(8616,4878,2)
(200,3436,2)
(5748,7202,2)
(1716,3718,2)
(7451,7904,2)
(138,5300,2)
(359,8499,2)
(609,2898,2)
(709,3963,2)
(667,4647,2)
(5313,4995,2)
(2320,6988,2)
(829,7179,2)
(774,1632,2)
(55,1502,2)
(1626,1502,2)
(5336,3798,2)
(1650,8668,2)
(3829,4845,2)
(7668,1860,2)
(877,1502,2)
(6757,2555,2)
(7991,7100,2)
(4497,847,2)
(4464,1617,2)
(6820,212,2)
(6524,6058,2)
(4623,7518,2)
(3574,4155,2)
(830,847,2)
(1905,5424,2)
(2668,3472,2)
(2869,8037,2)
(6692,6558,2)
(1300,235,2)
(7805,4422,2)
(82,1890,2)
(3513,7826,2)
(6074,2464,2)
(1625,4550,2)
(6532,5993,2)
(3326,929,2)
(5585,2469,2)
(6781,5025,2)
(1152,7628,2)
(8339,4993,2)
(2092,8499,2)
(8259,2057,2)
(3206,6566,2)
(9009,1053,2)
(4590,1502,2)
(3047,4409,2)
(3480,4452,2)
(4071,1798,2)
(9116,4928,2)
(4341,679,2)
(4081,9091,2)
(8953,1321,2)
(1066,7659,2)
(5341,4350,2)
(1026,1502,2)
(226,5525,2)
(4549,6186,2)
(1852,4242,2)
(2485,720,2)
(5275,7826,2)
(432,3989,2)
(5070,8362,2)
(7366,1402,2)
(2887,942,2)
(2902,5939,2)
(4001,175,2)
(7081,1092,2)
(1061,4647,2)
(8583,7666,2)
(482,8032,2)
(4512,8197,2)
(8183,3527,2)
(1753,4475,2)
(3639,4880,2)
(5641,8499,2)
(7426,2180,2)
(9065,6047,2)
(7092,5937,2)
(3902,7388,2)
(4153,8701,2)
(2589,3583,2)
(3867,8079,2)
(5646,2495,2)
(5294,8499,2)
(3675,936,2)
(3361,5455,2)
(5928,3990,2)
(2230,4384,2)
(1418,3570,2)
(9006,8362,2)
(3367,9042,2)
(4541,1237,2)
(5829,3654,2)
(5706,1449,2)
(6999,1943,2)
(8324,4306,2)
(4602,7904,2)
(3943,6187,2)
(2263,2445,2)
(3935,1916,2)
(2039,7826,2)
(6871,4928,2)
(1439,3350,2)
(5294,3381,2)
(6969,8825,2)
(4997,6404,2)
(7451,3900,2)
(2101,5576,2)
(7527,2962,2)
(2242,1003,2)
(8494,4224,2)
(8762,4928,2)
(4622,4019,2)
(3328,1102,2)
(1654,4529,2)
(2772,3872,2)
(1152,2322,2)
(635,7867,2)
(1593,1502,2)
(5271,4409,2)
(1832,2758,2)
(5622,7438,2)
(1289,1502,2)
(8977,418,2)
(6455,2979,2)
(4914,3463,2)
(7612,8083,2)
(6949,4928,2)
(1760,5043,2)
(2073,573,2)
(1380,1502,2)
(5808,7160,2)
(1193,8362,2)
(7291,2112,2)
(8421,6958,2)
(8230,2088,2)
(9080,6430,2)
(8358,309,2)
(197,1323,2)
(6224,4050,2)
(4565,4928,2)
(5347,3272,2)
(5311,8991,2)
(7965,175,2)
(4623,87,2)
(4982,3421,2)
(6348,4928,2)
(5457,1794,2)
(8302,2708,2)
(4934,6432,2)
(7460,5922,2)
(7229,7468,2)
(5834,3032,2)
(3955,4200,2)
(2177,6512,2)
(3680,4642,2)
(6631,7552,2)
(5358,8362,2)
(6452,7536,2)
(1320,3826,2)
(3658,8362,2)
(5168,284,2)
(3514,4475,2)
(123,5499,2)
(3087,533,2)
(6148,1502,2)
(5009,2125,2)
(4989,6158,2)
(1086,6431,2)
(2358,6597,2)
(2299,1502,2)
(1553,6404,2)
(8140,1502,2)
(2349,2370,2)
(8205,5902,2)
(4902,8252,2)
(5926,8499,2)
(5663,6958,2)
(7943,4928,2)
(2295,1794,2)
(7991,1591,2)
(4509,1425,2)
(6713,1502,2)
(35,3963,2)
(1474,6404,2)
(2656,6503,2)
(9024,6928,2)
(1415,7321,2)
(8677,5950,2)
(5698,7706,2)
(5294,1855,2)
(5743,591,2)
(2679,7945,2)
(6,8083,2)
(3980,8362,2)
(3703,4744,2)
(7122,4809,2)
(8933,2180,2)
(8192,3702,2)
(1154,6562,2)
(5354,1731,2)
(6854,805,2)
(1424,3152,2)
(8648,6958,2)
(2843,4928,2)
(6159,5209,2)
(2468,5266,2)
(4794,1326,2)
(7985,8499,2)
(4301,2928,2)
(5668,4928,2)
(8111,4196,2)
(7668,5839,2)
(4076,4193,2)
(5654,3570,2)
(7689,4928,2)
(1278,3940,2)
(1880,7096,2)
(4263,2801,2)
(574,7513,2)
(5899,2453,2)
(540,4977,2)
(7518,2058,2)
(2865,2347,2)
(1422,701,2)
(8918,8631,2)
(7049,7619,2)
(2788,6718,2)
(7802,7438,2)
(2871,6938,2)
(3646,7666,2)
(8769,3570,2)
(1575,603,2)
(5294,4910,2)
(808,3757,2)
(2154,8505,2)
(2815,7666,2)
(3531,2609,2)
(2699,1449,2)
(9156,169,2)
(1690,7619,2)
(6198,4725,2)
(1954,550,2)
(6393,39,2)
(5838,1600,2)
(995,4934,2)
(296,802,2)
(6957,3937,2)
(824,8425,2)
(1325,4397,2)
(200,7440,2)
(7347,9065,2)
(4151,936,2)
(4787,1502,2)
(2635,5709,2)
(7526,7647,2)
(2911,7666,2)
(456,6323,2)
(3565,7941,2)
(223,2999,2)
(7840,8362,2)
(4531,5351,2)
(4826,8596,2)
(2320,1228,2)
(7269,6790,2)
(6219,6128,2)
(4481,8008,2)
(7844,6343,2)
(3808,4548,2)
(4313,2869,2)
(5294,4037,2)
(2384,1321,2)
(4264,3511,2)
(1800,4928,2)
(4569,4085,2)
(2334,2394,2)
(8068,7826,2)
(6602,8566,2)
(4717,1502,2)
(5445,4878,2)
(2447,4397,2)
(7875,2899,2)
(1601,7552,2)
(732,6404,2)
(5293,7647,2)
(832,8425,2)
(4433,6404,2)
(4722,8020,2)
(6026,8566,2)
(8178,3872,2)
(5195,6512,2)
(5654,8566,2)
(7365,8499,2)
(3462,7359,2)
(3462,5398,2)
(7548,4928,2)
(7468,2113,2)
(4787,4928,2)
(452,7359,2)
(2869,8188,2)
(5649,5867,2)
(7226,8425,2)
(5492,8362,2)
(7083,7841,2)
(2374,7202,2)
(2064,6773,2)
(7379,5025,2)
(7522,1502,2)
(1020,805,2)
(6000,8362,2)
(3804,250,2)
(4732,4448,2)
(2011,720,2)
(9037,4551,2)
(1028,5487,2)
(9083,1731,2)
(2228,3636,2)
(884,7004,2)
(5134,2055,2)
(7874,2125,2)
(8236,279,2)
(8015,1321,2)
(3603,6323,2)
(7987,4196,2)
(8454,8362,2)
(7089,6047,2)
(4194,8404,2)
(1539,1502,2)
(5222,3423,2)
(3474,805,2)
(6315,8466,2)
(5334,2440,2)
(8273,5743,2)
(5306,1328,2)
(8748,3612,2)
(7770,7450,2)
(8811,8499,2)
(759,8576,2)
(8205,2904,2)
(1535,7513,2)
(8866,8937,2)
(2100,8310,2)
(2912,1502,2)
(9047,4140,2)
(6763,1168,2)
(3288,847,2)
(922,8362,2)
(8948,1801,2)
(7652,6047,2)
(7501,847,2)
(7979,6931,2)
(6922,2445,2)
(4018,1306,2)
(7315,2445,2)
(1749,334,2)
(1145,3340,2)
(127,6561,2)
(7421,4176,2)
(712,4551,2)
(5287,701,2)
(3187,4765,2)
(6542,8362,2)
(6791,5633,2)
(6304,4986,2)
(1538,6225,2)
(6304,4030,2)
(4079,7309,2)
(2528,553,2)
(8971,1506,2)
(4467,3193,2)
(3332,1502,2)
(7884,2609,2)
(8852,9101,2)
(4617,8499,2)
(1645,8566,2)
(1751,791,2)
(5512,2708,2)
(8024,398,2)
(4437,720,2)
(4437,3674,2)
(859,5576,2)
(4313,3302,2)
(8222,350,2)
(2558,1299,2)
(8125,6236,2)
(5717,2686,2)
(4143,6334,2)
(6480,2347,2)
(5205,3965,2)
(7391,2898,2)
(231,212,2)
(8282,7060,2)
(1323,5544,2)
(7468,6465,2)
(4036,6682,2)
(8978,4682,2)
(7659,7765,2)
(713,2586,2)
(2231,6548,2)
(2609,8799,2)
(5377,7666,2)
(8258,7826,2)
(5100,266,2)
(890,6047,2)
(230,6773,2)
(764,8425,2)
(6511,3185,2)
(8348,5718,2)
(7986,7309,2)
(7547,1231,2)
(6165,5025,2)
(8412,412,2)
(4906,3032,2)
(6682,8688,2)
(6377,6048,2)
(1990,7826,2)
(1041,1168,2)
(6398,2801,2)
(4147,1157,2)
(5342,2817,2)
(2120,7536,2)
(374,4196,2)
(8592,5693,2)
(2151,3937,2)
(2853,7826,2)
(5614,2125,2)
(5516,1916,2)
(4130,6431,2)
(25,7388,2)
(6086,8362,2)
(7282,8008,2)
(3379,1502,2)
(328,1502,2)
(7743,2057,2)
(3880,1502,2)
(2851,6718,2)
(7677,8362,2)
(2715,4928,2)
(1854,8425,2)
(7272,5922,2)
(3890,7666,2)
(7900,6048,2)
(4896,8128,2)
(1762,8466,2)
(3112,1832,2)
(3202,4350,2)
(3590,2546,2)
(1845,6236,2)
(5320,8117,2)
(2255,7674,2)
(2338,2898,2)
(8768,6958,2)
(7076,6128,2)
(8538,243,2)
(7159,8362,2)
(2107,7207,2)
(5832,175,2)
(8897,8362,2)
(5294,5115,2)
(1680,4744,2)
(2928,847,2)
(5163,1898,2)
(2156,3185,2)
(6517,4085,2)
(6463,6561,2)
(540,3775,2)
(3211,6047,2)
(1428,7369,2)
(1033,4928,2)
(7424,6731,2)
(9055,3764,2)
(3427,3826,2)
(5007,1256,2)
(7096,4497,2)
(4336,4928,2)
(7656,1502,2)
(6082,1119,2)
(3343,5867,2)
(2985,5461,2)
(6216,5864,2)
(4085,6048,2)
(3104,250,2)
(7175,3570,2)
(1796,1218,2)
(2398,533,2)
(1672,4085,2)
(4090,4634,2)
(1498,2492,2)
(2068,8362,2)
(4751,3125,2)
(2636,7666,2)
(2150,8362,2)
(6043,4019,2)
(2426,1359,2)
(4173,3702,2)
(7603,205,2)
(4236,997,2)
(4139,6512,2)
(8211,2180,2)
(2526,847,2)
(5732,4928,2)
(8091,8748,2)
(4352,4928,2)
(5550,7666,2)
(3439,7371,2)
(6213,6145,2)
(247,2698,2)
(6212,4022,2)
(7343,8159,2)
(8647,8362,2)
(1101,8362,2)
(2443,4928,2)
(7141,1617,2)
(6090,6706,2)
(3426,1292,2)
(3553,1825,2)
(6229,4592,2)
(6008,1502,2)
(1590,7202,2)
(7474,5939,2)
(1714,8566,2)
(6172,4765,2)
(7847,7858,2)
(5680,3527,2)
(593,6703,2)
(7175,3775,2)
(1809,7760,2)
(6809,8252,2)
(2166,1502,2)
(8745,8020,2)
(3512,1411,2)
(8550,317,2)
(2471,8362,2)
(266,291,2)
(8500,5885,2)
(8499,8566,2)
(8829,742,2)
(964,3817,2)
(6222,2347,2)
(780,5371,2)
(2201,7162,2)
(8335,4928,2)
(1216,8392,2)
(6990,8668,2)
(7907,1731,2)
(1034,5867,2)
(6495,8362,2)
(3892,7408,2)
(6607,4928,2)
(1016,6958,2)
(1199,6318,2)
(6991,3775,2)
(1394,3526,2)
(5155,5025,2)
(4584,2187,2)
(4947,3965,2)
(525,4155,2)
(4684,1502,2)
(1653,6718,2)
(7184,3775,2)
(4350,175,2)
(6808,9091,2)
(6617,2483,2)
(7912,4246,2)
(1798,1964,2)
(5875,6431,2)
(7862,3656,2)
(3230,6925,2)
(3978,5197,2)
(3773,720,2)
(690,5100,2)
(8074,6222,2)
(8829,1919,2)
(8841,8563,2)
(7554,3350,2)
(3636,8324,2)
(6816,6124,2)
(3393,7674,2)
(5018,7004,2)
(2058,1365,2)
(7872,8008,2)
(1973,6404,2)
(1941,7326,2)
(708,3702,2)
(7183,4350,2)
(7945,7826,2)
(2065,3252,2)
(740,2316,2)
(4846,6465,2)
(1431,8701,2)
(7677,8822,2)
(7252,5286,2)
(2792,2180,2)
(6496,7937,2)
(9045,3272,2)
(4313,3093,2)
(6298,7122,2)
(4952,7826,2)
(1157,3941,2)
(87,3025,2)
(5388,5025,2)
(912,8362,2)
(7627,6512,2)
(2701,5939,2)
(5294,4952,2)
(73,8701,2)
(2260,2249,2)
(3338,8566,2)
(6005,1502,2)
(6773,8362,2)
(3482,6431,2)
(5185,7309,2)
(7612,5515,2)
(5513,805,2)
(6456,2445,2)
(7232,4995,2)
(1636,3695,2)
(8146,1181,2)
(6614,8362,2)
(124,2636,2)
(4542,2394,2)
(581,9017,2)
(997,6036,2)
(2008,1193,2)
(5889,2009,2)
(4128,8032,2)
(6167,7666,2)
(4871,5043,2)
(2974,418,2)
(7369,4678,2)
(3794,169,2)
(6996,7004,2)
(7936,2441,2)
(888,3216,2)
(4488,1731,2)
(1397,5969,2)
(6917,3304,2)
(2844,5902,2)
(6862,7438,2)
(4112,1191,2)
(8117,4928,2)
(5071,4928,2)
(8541,4928,2)
(3954,7369,2)
(5613,5950,2)
(3294,1599,2)
(5533,6318,2)
(3727,8515,2)
(8815,235,2)
(3434,350,2)
(2940,7826,2)
(8316,6404,2)
(798,8020,2)
(3730,7647,2)
(2664,1502,2)
(4740,7309,2)
(143,5445,2)
(530,4824,2)
(7581,7826,2)
(7128,1955,2)
(5648,7442,2)
(7043,1502,2)
(7192,7004,2)
(3457,1502,2)
(1988,8188,2)
(5213,2571,2)
(41,4682,2)
(1254,5043,2)
(5027,7826,2)
(4443,8362,2)
(2812,8362,2)
(4336,1502,2)
(6512,2197,2)
(8185,2038,2)
(8890,1502,2)
(9117,7472,2)
(2795,2758,2)
(2536,4634,2)
(4569,7597,2)
(8614,5848,2)
(1884,1502,2)
(8494,4928,2)
(8537,7513,2)
(1512,4696,2)
(2207,5025,2)
(7431,8425,2)
(5592,7826,2)
(8724,7900,2)
(1253,7937,2)
(5646,7015,2)
(606,8940,2)
(6233,4422,2)
(3522,7214,2)
(2287,6435,2)
(7212,175,2)
(4814,4928,2)
(8557,5047,2)
(6175,1502,2)
(9147,6225,2)
(3336,8425,2)
(3715,5883,2)
(2776,7371,2)
(2571,1502,2)
(7791,7619,2)
(4601,1157,2)
(6845,1804,2)
(5856,131,2)
(6673,2898,2)
(738,1267,2)
(3971,1502,2)
(2028,2226,2)
(8160,3857,2)
(6440,4874,2)
(5328,175,2)
(3915,4390,2)
(8446,175,2)
(1108,2220,2)
(6431,6323,2)
(288,4995,2)
(3265,3086,2)
(2663,4928,2)
(1436,7671,2)
(9076,5489,2)
(6667,550,2)
(6739,8247,2)
(2206,5306,2)
(5154,1302,2)
(3689,5247,2)
(5289,2546,2)
(2687,3705,2)
(1126,7501,2)
(2188,7826,2)
(4742,8576,2)
(9026,5115,2)
(6419,6703,2)
(1530,1502,2)
(4980,855,2)
(5065,1502,2)
(4972,5517,2)
(4110,847,2)
(4655,8276,2)
(9116,1502,2)
(1600,4967,2)
(2243,4928,2)
(3534,2622,2)
(5232,2445,2)
(7376,7826,2)
(3536,8362,2)
(1360,1502,2)
(3302,4551,2)
(6894,7571,2)
(3330,1502,2)
(8498,8217,2)
(4924,131,2)
(6316,1230,2)
(1004,4961,2)
(826,8266,2)
(910,3715,2)
(777,4196,2)
(8293,6958,2)
(7783,6431,2)
(1246,6158,2)
(1520,2831,2)
(4928,6158,2)
(6912,1502,2)
(2164,8516,2)
(1087,3636,2)
(5234,2496,2)
(5833,131,2)
(6796,2708,2)
(1523,2585,2)
(3430,1502,2)
(852,1502,2)
(803,131,2)
(5626,1731,2)
(543,4928,2)
(6099,7309,2)
(576,7359,2)
(790,847,2)
(7764,2708,2)
(3117,6404,2)
(2686,8362,2)
(4629,6597,2)
(6942,4350,2)
(5672,8576,2)
(3121,2758,2)
(8353,5207,2)
(8599,4350,2)
(6600,7826,2)
(6362,6404,2)
(902,4878,2)
(5527,3049,2)
(527,2016,2)
(7622,1936,2)
(4247,533,2)
(1248,2661,2)
(5360,2555,2)
(4291,7647,2)
(6364,2394,2)
(3217,6512,2)
(7992,4397,2)
(2700,8362,2)
(4348,7826,2)
(5442,4397,2)
(2688,720,2)
(7478,7688,2)
(3841,5839,2)
(6193,1889,2)
(9007,212,2)
(7428,4252,2)
(1210,3350,2)
(1402,3583,2)
(5745,2609,2)
(9005,8020,2)
(6348,6047,2)
(1727,1515,2)
(1545,3937,2)
(3428,4420,2)
(1782,6128,2)
(5258,2441,2)
(3243,8701,2)
(6981,139,2)
(774,4591,2)
(5142,2325,2)
(4523,9071,2)
(2572,2801,2)
(4502,6750,2)
(6496,8716,2)
(3641,7472,2)
(7030,805,2)
(1315,8362,2)
(8829,1855,2)
(8722,3123,2)
(8888,2898,2)
(3065,554,2)
(4305,6562,2)
(1754,8362,2)
(7799,4232,2)
(3566,8362,2)
(3318,6718,2)
(4139,720,2)
(1825,1502,2)
(7533,2338,2)
(9093,3971,2)
(5106,1515,2)
(77,5091,2)
(4789,3049,2)
(2779,7005,2)
(7202,4554,2)
(3159,1502,2)
(1696,7619,2)
(6202,4878,2)
(4219,3158,2)
(3511,500,2)
(6232,6133,2)
(8317,3421,2)
(4845,1502,2)
(5773,3757,2)
(1152,492,2)
(8519,8499,2)
(3200,6642,2)
(2067,4831,2)
(8560,4220,2)
(5911,6334,2)
(3129,6958,2)
(8799,4961,2)
(1409,805,2)
(3657,2057,2)
(6776,6334,2)
(7916,533,2)
(826,2394,2)
(7355,1502,2)
(6382,6967,2)
(8213,2347,2)
(1404,2289,2)
(6279,9101,2)
(850,2347,2)
(7046,2113,2)
(9070,6195,2)
(1320,3550,2)
(998,588,2)
(5623,1502,2)
(8013,2180,2)
(2721,9025,2)
(6470,5807,2)
(5294,7288,2)
(653,8362,2)
(5712,7707,2)
(6482,3583,2)
(1166,5839,2)
(1429,7826,2)
(5550,7389,2)
(2677,598,2)
(1583,3702,2)
(3189,720,2)
(4973,6390,2)
(7469,3352,2)
(7168,2994,2)
(4347,1306,2)
(1392,5992,2)
(1892,6264,2)
(8753,7838,2)
(8012,5867,2)
(4045,7826,2)
(3394,3421,2)
(9022,2609,2)
(2262,5902,2)
(4641,1092,2)
(2159,1708,2)
(6176,8032,2)
(9067,4360,2)
(4561,1306,2)
(3247,7536,2)
(704,6958,2)
(5494,2032,2)
(8602,7985,2)
(1919,5525,2)
(5401,2546,2)
(8663,3636,2)
(6979,4995,2)
(6642,7937,2)
(5958,8362,2)
(1953,4928,2)
(2986,175,2)
(3561,6692,2)
(6740,5525,2)
(1360,6404,2)
(2838,6967,2)
(8584,8247,2)
(5493,8362,2)
(3082,3928,2)
(2766,720,2)
(2975,5576,2)
(651,2325,2)
(1561,2347,2)
(7779,2801,2)
(2325,3928,2)
(2504,8362,2)
(1424,419,2)
(2141,3570,2)
(6782,334,2)
(8444,1193,2)
(6750,8799,2)
(5835,1502,2)
(1628,6048,2)
(1390,1502,2)
(7792,5037,2)
(9133,7928,2)
(863,6229,2)
(6027,4878,2)
(4443,8954,2)
(5576,6561,2)
(1726,39,2)
(3446,6958,2)
(3883,5454,2)
(1695,720,2)
(128,8362,2)
(7593,4928,2)
(8491,6195,2)
(3093,598,2)
(1826,2325,2)
(1576,3527,2)
(2236,8362,2)
(1575,5835,2)
(131,2267,2)
(309,4050,2)
(6046,3032,2)
(1620,1502,2)
(6490,6195,2)
(1740,7359,2)
(8473,8362,2)
(3485,8362,2)
(7075,8902,2)
(3442,7004,2)
(8374,720,2)
(7225,1624,2)
(6681,3158,2)
(5538,5897,2)
(530,2898,2)
(4912,6738,2)
(4787,6047,2)
(7046,1489,2)
(5486,1061,2)
(1115,8183,2)
(5646,1567,2)
(8435,7666,2)
(1256,8991,2)
(2638,3114,2)
(4953,4928,2)
(629,2708,2)
(668,5025,2)
(1144,7309,2)
(8915,3448,2)
(2355,2445,2)
(7473,2315,2)
(3302,533,2)
(1611,7656,2)
(1774,3702,2)
(3069,1502,2)
(1892,1502,2)
(7321,175,2)
(1124,1924,2)
(7374,1502,2)
(3120,5550,2)
(3821,9101,2)
(5757,1502,2)
(2790,175,2)
(5754,6404,2)
(2227,6773,2)
(3847,1306,2)
(4145,5939,2)
(6173,3272,2)
(7072,8362,2)
(2819,6648,2)
(2546,697,2)
(4437,4551,2)
(2320,8037,2)
(4078,2131,2)
(3473,131,2)
(4888,5025,2)
(7994,7910,2)
(5297,5445,2)
(7295,250,2)
(4865,5371,2)
(3685,2316,2)
(3321,2275,2)
(3276,6703,2)
(1571,2125,2)
(3120,4951,2)
(3342,1502,2)
(1657,8566,2)
(6659,4928,2)
(1004,7518,2)
(1234,6158,2)
(7472,2057,2)
(5956,8576,2)
(2242,6391,2)
(952,7309,2)
(806,6165,2)
(7841,6738,2)
(4825,4227,2)
(255,6515,2)
(5942,8362,2)
(1064,1155,2)
(6817,7004,2)
(7313,3965,2)
(4853,7202,2)
(6007,4934,2)
(8964,1267,2)
(5980,1502,2)
(5093,2801,2)
(5846,7372,2)
(6413,5218,2)
(1002,7179,2)
(6932,4598,2)
(5030,7438,2)
(6018,6236,2)
(3741,5939,2)
(2516,6958,2)
(800,8915,2)
(5376,7826,2)
(3805,5282,2)
(5982,3872,2)
(2774,1168,2)
(7509,6692,2)
(1824,847,2)
(1418,7450,2)
(3860,4019,2)
(7652,7359,2)
(7112,3872,2)
(2875,891,2)
(3388,4085,2)
(712,7092,2)
(3148,7202,2)
(3411,7100,2)
(4233,720,2)
(3434,3113,2)
(7186,3896,2)
(2641,6998,2)
(2869,1489,2)
(3041,385,2)
(2474,175,2)
(4284,2180,2)
(474,6958,2)
(6904,7826,2)
(8711,6195,2)
(3039,7828,2)
(4655,799,2)
(67,7826,2)
(1957,7309,2)
(3505,2394,2)
(3382,5875,2)
(2398,1244,2)
(5166,69,2)
(8402,8362,2)
(3950,8362,2)
(9111,8362,2)
(5975,1502,2)
(4397,1554,2)
(8461,1890,2)
(4242,7689,2)
-----------------------------------
(0,ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability \'%s\'/\'%s\' incompatible with our capability \'%s\'.\\n",\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tast_inet_ntoa(sin.sin_addr)
(1,iaxs[fr->callno])
(2,)
(3,name)
(4,ied0.buf)
(5,fr)
(6,ies.vars)
(7,)
(8,exten)
(9,)
(10,LOG_WARNING)
(11,"Rejected connect attempt from %s, requested/capability \'%s\'/\'%s\' incompatible with our capability \'%s\'.\\n")
(12,ied0)
(13,callno)
(14,vh)
(15,sizeof(*varlist)
(16,cid_num = ast_strdupa(iaxs[fr->callno]->cid_num)
(17,ntohs(mh->callno)
(18,ies)
(19,)
(20,iax2_dprequest(dp, fr->callno)
(21,sizeof(*fh)
(22,"mine")
(23,tmp3)
(24,fr)
(25,iax2_variable_datastore_info)
(26,fr)
(27,fr)
(28,"Format for call is %s\\n")
(29,x)
(30,owner)
(31,iaxs)
(32,fr->callno)
(33,iaxs)
(34,prev)
(35,callno)
(36,sin)
(37,ts)
(38,iaxs[fr->callno])
(39,ies.codec_prefs)
(40,id)
(41,break;)
(42,EPERM)
(43,iaxs[fr->callno]->capability)
(44,iaxs[fr->callno])
(45,f.datalen)
(46,fr->ts = (iaxs[fr->callno]->last & 0xFFFF8000L)
(47,iaxs)
(48,VERBOSE_PREFIX_4)
(49,fr->callno)
(50,iax2_vnak(fr->callno)
(51,f)
(52,iaxs[fr->callno])
(53,callno)
(54,res - 1)
(55,fr->callno)
(56,)
(57,IAX_STATE_STARTED)
(58,1)
(59,(new_callno = make_trunk(fr->callno, 1)
(60,if (prev)
(61,IAX_ALREADYGONE)
(62,ast_log(LOG_NOTICE, "Rejected dial attempt from %s, request \'%s@%s\' does not exist\\n", ast_inet_ntoa(sin.sin_addr)
(63,IAX_IE_FORMAT2)
(64,iaxs[fr->callno]->owner)
(65,&iaxsl[fr->callno])
(66,iaxs[fr->callno]->prefs)
(67,iaxs)
(68,&ies)
(69,iaxs[fr->callno])
(70,capability)
(71,sin)
(72,"Received iseqno %d not within window %d->%d\\n")
(73,iaxs[fr->callno])
(74,callno)
(75,connected.id.number.presentation = iaxs[fr->callno]->calling_pres)
(76,0)
(77,integer)
(78,state)
(79,ntohs(fh->dcallno)
(80,iaxs)
(81,var)
(82,iaxs)
(83,if (!iaxs[fr->callno])
(84,IAX_COMMAND_TXACC)
(85,iaxs)
(86,if (decrypt_frame(fr->callno, fh, &f, &res)
(87,format = 0)
(88,transferring)
(89,*fh)
(90,iaxs[fr->callno])
(91,sizeof(tmp3)
(92,sin_family)
(93,iaxs[fr->callno])
(94,if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)
(95,ies.cause ? ies.cause : "<unknown>")
(96,iaxs)
(97,bridged_chan)
(98,*newvar = ast_var_assign(var->name, var->value)
(99,f)
(100,iax2_lock_owner(fr->callno)
(101,exten)
(102,NULL)
(103,format)
(104,format)
(105,LOG_ERROR)
(106,ts)
(107,cid_num)
(108,buf)
(109,id)
(110,)
(111,callno)
(112,iaxs)
(113,transferring)
(114,callno)
(115,f)
(116,historicms)
(117,if (varlist)
(118,sizeof(*mh)
(119,f.datalen = 0)
(120,0)
(121,"mine")
(122,ast_mutex_unlock(&iaxsl[fr->callno])
(123,sizeof(host_pref_buf)
(124,peer->pokeexpire > -1)
(125,ies)
(126,"Hold")
(127,iaxs)
(128,&ies)
(129,ts)
(130,context)
(131,ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)
(132,iaxs[fr->callno]->transferring = TRANSFER_RELEASED)
(133,0)
(134,iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_FACILITY_NOT_SUBSCRIBED)
(135,f.frametype)
(136,iaxs[fr->callno]->first_iax_message)
(137,subclass)
(138,"Rejected connect attempt.  No secret present while force encrypt enabled.\\n")
(139,iaxs[fr->callno])
(140,iaxs[fr->callno]->capability)
(141,fr->callno)
(142,minivid)
(143,fr->ts + test_resync)
(144,tmp3)
(145,fr)
(146,id)
(147,presentation)
(148,&iaxsl[fr->callno])
(149,callno)
(150,&iaxs[fr->callno]->state)
(151,0)
(152,fr)
(153,peerformat)
(154,f)
(155,ies.iax_unknown)
(156,DATASTORE_INHERIT_FOREVER)
(157,ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->chosenformat, NULL,\n\\n\\t\\t\\t\\t\\t\\t  ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED)
(158,fr)
(159,&ied0)
(160,ast_debug(1, "I have IAX variables, but they were not processed\\n")
(161,iaxs[fr->callno])
(162,af)
(163,if (call_to_destroy)
(164,owner)
(165,sin)
(166,fr->callno)
(167,ied0.buf)
(168,var)
(169,authdebug)
(170,if (res < 0)
(171,f.subclass.integer == IAX_COMMAND_ACK)
(172,c)
(173,iaxs[fr->callno]->last)
(174,1)
(175,iaxs[fr->callno] && iaxs[fr->callno]->owner)
(176,fr->callno)
(177,32)
(178,)
(179,fr)
(180,iaxs)
(181,iaxs[fr->callno]->state)
(182,fh->dcallno)
(183,sizeof(*fr)
(184,if (ies.calltoken && ies.calltokendata)
(185,cur)
(186,ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)
(187,fr)
(188,cid_num)
(189,ast_format_cap_destroy(orignative)
(190,ies.vars)
(191,callno)
(192,tmp3)
(193,if (!fr->callno || !iaxs[fr->callno])
(194,callno)
(195,fr)
(196,callno)
(197,iaxs[fr->callno]->addr)
(198,&ies)
(199,1)
(200,(struct ast_iax2_mini_hdr *)
(201,"mine")
(202,decrypted)
(203,callno)
(204,callno)
(205,fr->callno)
(206,addr)
(207,iaxs[fr->callno]->peercapability)
(208,)
(209,fr->callno)
(210,decrypted)
(211,send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied1.buf, ied1.pos, -1)
(212,variablestore && varlist)
(213,iaxs[fr->callno])
(214,fr)
(215,buf)
(216,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(217,LOG_NOTICE)
(218,sizeof(*fr)
(219,IAX_STATE_STARTED)
(220,f.subclass.integer != IAX_COMMAND_VNAK)
(221,context)
(222,iax2_getformatname_multiple(tmp2, sizeof(tmp2)
(223,AST_SCHED_DEL(sched, peer->pokeexpire)
(224,ast_strdupa(iaxs[fr->callno]->cid_num)
(225,break;)
(226,inheritance)
(227,IAX_COMMAND_LAGRP)
(228,iaxs[fr->callno]->rprefs)
(229,1)
(230,callno)
(231,NULL)
(232,fr)
(233,called_number)
(234,x)
(235,(f.frametype != AST_FRAME_IAX)
(236,ts = calc_timestamp(iaxs[fr->callno], 0, &fr->af)
(237,f.subclass.integer)
(238,IAX_TRUNK)
(239,fd)
(240,ies.vars)
(241,for (var = ies.vars; var && var->next; var = var->next)
(242,fr->callno)
(243,strcasecmp(iaxs[fr->callno]->exten, "TBD")
(244,0)
(245,fr->callno)
(246,iaxs[fr->callno]->bridgecallno)
(247,iaxs[fr->callno]->pingtime)
(248,LOG_NOTICE)
(249,0)
(250,f.subclass.format.id != ast_format_id_from_old_bitfield(iaxs[fr->callno]->videoformat)
(251,iaxs[fr->callno]->reg->username)
(252,32)
(253,ies)
(254,ies.cause)
(255,iaxs[fr->callno])
(256,iaxs)
(257,(unsigned char *)
(258,iaxs[fr->callno])
(259,iaxs[fr->callno])
(260,call_to_destroy)
(261,capability)
(262,format)
(263,f.subclass.integer)
(264,iaxs)
(265,pokeexpire)
(266,f.subclass.integer != IAX_COMMAND_UNQUELCH)
(267,1)
(268,sizeof(pref)
(269,VERBOSE_PREFIX_4)
(270,callno)
(271,sin)
(272,memset(&ied1, 0, sizeof(ied1)
(273,caller_pref_buf)
(274,0)
(275,)
(276,res)
(277,moh_suggest)
(278,iaxs[fr->callno])
(279,iaxs[fr->callno])
(280,tmp)
(281,callno)
(282,-1)
(283,IAX_STATE_STARTED)
(284,fh->csub == IAX_COMMAND_REJECT)
(285,EVENT_FLAG_SYSTEM)
(286,ast_channel_unref(owner)
(287,iaxs[fr->callno])
(288,f)
(289,ast_set_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART)
(290,"Rejecting packet from \'%s.%d\' that is flagged as a video frame but is too short\\n")
(291,f.subclass.integer != IAX_COMMAND_TXREL)
(292,subclass)
(293,if (iaxs[fr->callno]->owner && fh->type == AST_FRAME_IAX &&\n\\n\\t\\t\\t(fh->csub == IAX_COMMAND_HANGUP\n\\n\\t\\t\\t|| fh->csub == IAX_COMMAND_REJECT\n\\n\\t\\t\\t|| fh->csub == IAX_COMMAND_REGREJ\n\\n\\t\\t\\t|| fh->csub == IAX_COMMAND_TXREJ)
(294,&ied0)
(295,iaxs)
(296,fr)
(297,fr->callno)
(298,0)
(299,callno)
(300,fh)
(301,iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
(302,callno)
(303,cause_code->code)
(304,fr->ts)
(305,fr->callno)
(306,fr)
(307,res)
(308,csub)
(309,ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr)
(310,fr->callno)
(311,!ast_strlen_zero(moh_suggest)
(312,ast_test_flag64(iaxs[fr->callno], IAX_FORCE_ENCRYPT)
(313,iaxs[fr->callno]->owner)
(314,)
(315,send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1)
(316,call_to_destroy)
(317,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(318,ies.refresh)
(319,)
(320,callno)
(321,ast_free(prev)
(322,VERBOSE_PREFIX_4)
(323,fh)
(324,ies)
(325,sin)
(326,iaxs[fr->callno]->lag)
(327,frametype)
(328,fr->callno)
(329,iaxs[fr->callno]->owner)
(330,if (format)
(331,&iaxsl[fr->callno])
(332,f.subclass.integer)
(333,tmp2)
(334,res = thread->buf_len)
(335,IAX_CODEC_NOPREFS)
(336,ast_verb(3, "Releasing %s and %s\\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner)
(337,callno)
(338,owner)
(339,iaxs[fr->callno])
(340,ied1)
(341,f.subclass.integer != IAX_COMMAND_TXREL)
(342,memset(&ied1, 0, sizeof(ied1)
(343,f.frametype == AST_FRAME_VOICE)
(344,iaxs[fr->callno]->peercapability)
(345,fr)
(346,send_signaling(iaxs[fr->callno])
(347,ies)
(348,"Accepting AUTHENTICATED call from %s:\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t"%srequested format = %s,\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t"%srequested prefs = %s,\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t"%sactual format = %s,\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t"%shost prefs = %s,\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t"%spriority = %s\\n")
(349,iaxs)
(350,variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL)
(351,callno)
(352,fr)
(353,using_prefs)
(354,f.frametype)
(355,ast_channel_name(bridged_chan)
(356,sin_addr)
(357,iaxs)
(358,metacmd)
(359,f.subclass)
(360,ast_free(varlist)
(361,fr->callno)
(362,fr->callno)
(363,f)
(364,fr->callno)
(365,0)
(366,ies)
(367,res)
(368,if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(369,1)
(370,fr->callno)
(371,fr->callno)
(372,f.subclass.integer)
(373,AST_LIST_INSERT_TAIL(varlist, newvar, entries)
(374,fr)
(375,peer->pokeexpire)
(376,if (strcmp(iaxs[fr->callno]->exten, "TBD")
(377,IAX_STATE_TBD)
(378,callno)
(379,ts)
(380,fr)
(381,&iaxs[fr->callno]->dcx)
(382,outkey)
(383,iaxs[fr->callno])
(384,iaxs[fr->callno])
(385,!iaxs[fr->callno]->first_iax_message)
(386,fr)
(387,sizeof(tmp1)
(388,owner)
(389,decrypted)
(390,f.subclass)
(391,fr)
(392,fr->callno)
(393,res < sizeof(*mh)
(394,fr->callno)
(395,pos)
(396,fr)
(397,id)
(398,ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
(399,case IAX_COMMAND_HANGUP:)
(400,fr->callno)
(401,callno)
(402,fr)
(403,decrypted)
(404,f.datalen = res - sizeof(*fh)
(405,ied1.buf)
(406,fh->csub >> 6)
(407,&globalflags)
(408,iaxs[fr->callno]->error)
(409,iaxsl)
(410,0)
(411,!iaxs[fr->callno])
(412,iaxs[fr->callno]->secret)
(413,ast_verb(3, "Format for call is %s\\n", ast_getformatname_multiple(tmp, sizeof(tmp)
(414,iaxs)
(415,callno)
(416,callno)
(417,integer)
(418,iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)
(419,authdebug)
(420,fr)
(421,"<Unknown>")
(422,called_number)
(423,*newvar = ast_var_assign(var->name, var->value)
(424,peer)
(425,connected.id)
(426,0)
(427,ies.vars)
(428,iaxs[fr->callno]->state)
(429,IAX_COMMAND_ACK)
(430,break;)
(431,fr->callno)
(432,mh->callno)
(433,thread)
(434,callno)
(435,fr->callno)
(436,sin)
(437,fr)
(438,ies)
(439,fr)
(440,fr)
(441,exten = ast_strdupa(iaxs[fr->callno]->exten)
(442,varlist)
(443,prefs)
(444,iaxs)
(445,fr)
(446,fr)
(447,fr)
(448,f)
(449,callno)
(450,fr->callno)
(451,iax2_getformatname_multiple(tmp2, sizeof(tmp2)
(452,ied1)
(453,fr)
(454,buf)
(455,return 1;)
(456,frametype)
(457,fr)
(458,fr)
(459,callno)
(460,fr->callno)
(461,integer)
(462,peerformat)
(463,iaxs[fr->callno])
(464,peer->maxms)
(465,callno)
(466,meta->zeros == 0)
(467,AST_FRAME_VOICE)
(468,iaxs[fr->callno])
(469,)
(470,callno)
(471,&connected)
(472,fr)
(473,"disabled")
(474,fr)
(475,"<Unknown>")
(476,thread->iosin)
(477,)
(478,iaxs[fr->callno]->secret)
(479,if ((f.subclass.integer != IAX_COMMAND_ACK)
(480,iaxs)
(481,format)
(482,LOG_ERROR)
(483,iaxs[fr->callno])
(484,fh->type)
(485,ast_channel_writeformat(iaxs[fr->callno]->owner)
(486,iaxs)
(487,ied0.buf)
(488,ied0)
(489,)
(490,iaxs)
(491,iaxs[fr->callno])
(492,fr->callno)
(493,ast_channel_caller(iaxs[fr->callno]->owner)
(494,iaxs[fr->callno])
(495,sizeof(subclass)
(496,iaxs[fr->callno]->owner)
(497,fr)
(498,ies.causecode > 9)
(499,fr->callno)
(500,x = fr->iseqno)
(501,ied0)
(502,f)
(503,)
(504,return 1;)
(505,IAX_COMMAND_ACK)
(506,ies)
(507,"disabled")
(508,1)
(509,fh->csub)
(510,iaxs)
(511,"Peer \'%s\' is now TOO LAGGED (%d ms)
(512,cause)
(513,pos)
(514,ies.called_number ? ies.called_number : "s")
(515,fr)
(516,iaxs)
(517,if (f.subclass.format.id == AST_FORMAT_SLINEAR)
(518,peerformat)
(519,ies.provver)
(520,ied1)
(521,fr->callno)
(522,var->next)
(523,pref)
(524,rprefs)
(525,ies.vars)
(526,sizeof(ied0)
(527,using_prefs = "disabled")
(528,callno)
(529,0)
(530,peer_unref(peer)
(531,caller_pref_buf)
(532,buf)
(533,iaxs[fr->callno]->voiceformat > 0)
(534,)
(535,if (!iaxs[fr->callno] || !iaxs[fr->callno]->owner)
(536,ts)
(537,sin)
(538,fr->ts)
(539,orignative)
(540,f.subclass.format)
(541,subclass)
(542,0)
(543,fr->callno)
(544,ast_channel_name(bridged_chan)
(545,subclass)
(546,variablestore)
(547,variablestore)
(548,callno)
(549,!(c = ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->peerformat, NULL, 1)
(550,var)
(551,fr->callno)
(552,fr)
(553,varlist)
(554,iaxs[fr->callno]->owner)
(555,if (ies.provverpres && ies.serviceident && sin.sin_addr.s_addr)
(556,pokeexpire)
(557,iaxs[fr->callno])
(558,iaxs[fr->callno]->capability)
(559,fr->callno)
(560,pingtime)
(561,callno)
(562,if (fr->callno > 0)
(563,c)
(564,if (!iaxs[fr->callno])
(565,TRANSFER_MREADY)
(566,ies)
(567,fr->callno)
(568,case IAX_COMMAND_REGREL:)
(569,fr->callno)
(570,callno)
(571,sched)
(572,vars)
(573,f.frametype = AST_FRAME_VIDEO)
(574,fr)
(575,name)
(576,ied1)
(577,iaxs[fr->callno]->error)
(578,ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf)
(579,iaxs[fr->callno]->owner)
(580,peer)
(581,iaxs[fr->callno]->voiceformat = ast_format_to_old_bitfield(&f.subclass.format)
(582,&ied0)
(583,prev)
(584,iaxs)
(585,fh->iseqno + 1)
(586,f.subclass.integer != IAX_COMMAND_TXCNT)
(587,peer)
(588,ied0.pos)
(589,fr)
(590,fr)
(591,iaxs[fr->callno])
(592,format)
(593,iaxs[fr->callno]->capability)
(594,ast_debug(1, "I can haz IAX vars? w00t\\n")
(595,ast_verb(3, "Accepted AUTHENTICATED TBD call from %s\\n", ast_inet_ntoa(sin.sin_addr)
(596,callno)
(597,fr->callno)
(598,fr->afdatalen)
(599,case IAX_COMMAND_AUTHREP:)
(600,iaxs)
(601,connected)
(602,varlist)
(603,fr->callno > 0)
(604,NULL)
(605,iaxsl[fr->callno])
(606,f.data.ptr)
(607,f.subclass.integer)
(608,var)
(609,peer->pokeexpire)
(610,~IAX_FLAG_RETRANS)
(611,fr->callno)
(612,using_prefs)
(613,fr)
(614,ast_channel_caller(iaxs[fr->callno]->owner)
(615,iaxs[fr->callno]->oseqno)
(616,transferring)
(617,IAX_COMMAND_LAGRP)
(618,fr->iseqno)
(619,f)
(620,exten)
(621,memset(&ied0, 0, sizeof(ied0)
(622,af)
(623,ies)
(624,f)
(625,transfer)
(626,iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_MREADY)
(627,"<Unknown>")
(628,format)
(629,IAX_IE_FORMAT)
(630,ast_test_flag64(iaxs[fr->callno], IAX_QUELCH)
(631,pos)
(632,iaxs[fr->callno])
(633,tmp2)
(634,"caller")
(635,iaxs[fr->callno])
(636,ies.causecode)
(637,res)
(638,fr->callno)
(639,case IAX_COMMAND_TXREQ:)
(640,iaxs)
(641,mh)
(642,fr->ts)
(643,IAX_STATE_AUTHENTICATED)
(644,ast_connected_line_parse_data(f.data.ptr, f.datalen, &connected)
(645,iaxs[fr->callno])
(646,IAX_COMMAND_REGREJ)
(647,iaxs)
(648,fr->callno)
(649,f.data.ptr = NULL)
(650,IAX_STATE_TBD)
(651,iaxs[fr->callno])
(652,iseqno)
(653,ies)
(654,prev)
(655,owner)
(656,pref)
(657,-1)
(658,fr->callno)
(659,ast_mutex_lock(&iaxsl[fr->callno])
(660,iaxs)
(661,provverpres)
(662,fr->callno)
(663,AST_FRAME_IAX)
(664,iaxs)
(665,oseqno)
(666,iax_pvt_callid_get(fr->callno)
(667,using_prefs)
(668,ies.causecode)
(669,iax2_getformatname_multiple(tmp1, sizeof(tmp1)
(670,variablestore)
(671,iaxs)
(672,peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqok, iax2_poke_peer_s, peer_ref(peer)
(673,&connected)
(674,peerformat)
(675,ntohs(fh->dcallno)
(676,ies.vars)
(677,f.data.ptr)
(678,fr)
(679,S_COR(connected.id.name.valid, connected.id.name.str, "")
(680,iax2_getformatname(iaxs[fr->callno]->peerformat)
(681,callno)
(682,peercallno)
(683,ies.causecode)
(684,fr)
(685,strcpy(caller_pref_buf, "disabled")
(686,"TBD")
(687,IAX_CODEC_USER_FIRST)
(688,iaxs[fr->callno]->owner)
(689,owner)
(690,integer)
(691,fr)
(692,)
(693,fr->callno)
(694,iaxs)
(695,"we\'ve been told to rotate our encryption key, "\n\\n\\t\\t\\t\\t\\t\\t"but this isn\'t an encrypted call. bad things will happen.\\n")
(696,ied0)
(697,ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
(698,dp)
(699,ies)
(700,if (((f.subclass.integer != IAX_COMMAND_INVAL)
(701,minivid)
(702,iaxs[fr->callno]->context)
(703,&iaxs[fr->callno]->state)
(704,ast_mutex_unlock(&iaxsl[fr->callno])
(705,fh)
(706,fr)
(707,f.datalen)
(708,fr)
(709,"Unable to negotiate codec")
(710,callno)
(711,sin_addr)
(712,return 1;)
(713,&frame_queue[fr->callno])
(714,fr)
(715,break;)
(716,IAX_IMMEDIATE)
(717,orignative)
(718,iaxs)
(719,fr->callno)
(720,!ast_test_flag64(iaxs[fr->callno], IAX_RECVCONNECTEDLINE)
(721,fr->callno)
(722,peerformat)
(723,iaxs)
(724,callno)
(725,ied0)
(726,ied0.pos)
(727,fr->callno)
(728,if (authenticate_reply(iaxs[fr->callno], &iaxs[fr->callno]->addr, &ies, iaxs[fr->callno]->secret, iaxs[fr->callno]->outkey)
(729,3)
(730,iaxs[fr->callno])
(731,memset(&ied1, 0, sizeof(ied1)
(732,iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension")
(733,&iaxs[fr->callno]->state)
(734,f.subclass)
(735,variablestore->inheritance)
(736,fr)
(737,callno)
(738,fr->callno)
(739,caller_pref_buf)
(740,f.frametype != AST_FRAME_IAX)
(741,format)
(742,ies.vars)
(743,callno)
(744,vars)
(745,if ((new_callno = make_trunk(fr->callno, 1)
(746,fr)
(747,iaxs)
(748,iaxs[fr->callno]->mohsuggest)
(749,fr)
(750,send_command(iaxs[fr->callno], AST_FRAME_CONTROL, AST_CONTROL_PROGRESS, 0, NULL, 0, -1)
(751,ast_format_cap_copy(native, orignative)
(752,dp)
(753,ntohs(fh->dcallno)
(754,subclass)
(755,f.subclass)
(756,callno)
(757,callno)
(758,1)
(759,break;)
(760,sin)
(761,)
(762,fr)
(763,1)
(764,iaxs[fr->callno])
(765,iaxs)
(766,callno)
(767,transferring)
(768,f)
(769,ast_mutex_unlock(&iaxsl[fr->callno])
(770,iaxs[fr->callno])
(771,ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf)
(772,fr->callno)
(773,fr)
(774,memset(&ied1, 0, sizeof(ied1)
(775,state)
(776,f)
(777,pbx_builtin_setvar_helper(owner, "BLINDTRANSFER", ast_channel_name(bridged_chan)
(778,iaxs)
(779,pos)
(780,f)
(781,callno)
(782,peer)
(783,subclass)
(784,if (iaxs[fr->callno]->pingtime > peer->maxms)
(785,pingtime)
(786,fr)
(787,"reqonly")
(788,iaxs[fr->callno]->owner)
(789,)
(790,IAX_CODEC_NOCAP)
(791,iaxs[fr->callno])
(792,NULL)
(793,iaxs[fr->callno]->iseqno++)
(794,state)
(795,callno)
(796,128)
(797,ies.vars = NULL)
(798,fr)
(799,fr->iseqno)
(800,iaxs[fr->callno]->iaxvars = ies.vars)
(801,ast_log(LOG_WARNING, "Call on %s is already up, can\'t start on it\\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner)
(802,ast_channel_writeformat(iaxs[fr->callno]->owner)
(803,iaxs[fr->callno]->peercapability)
(804,iaxsl[fr->callno])
(805,strcmp(iaxs[fr->callno]->exten, "TBD")
(806,cause_code = ast_alloca(data_size)
(807,ntohs(vh->ts)
(808,subclass)
(809,iaxs[fr->callno])
(810,if (!iaxs[fr->callno]->first_iax_message)
(811,ast_format_set_video_mark(&f.subclass.format)
(812,iaxs[fr->callno])
(813,fr->callno)
(814,iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)
(815,)
(816,iaxs)
(817,ies.causecode)
(818,f.subclass)
(819,AST_FRAME_IAX)
(820,cur->retries)
(821,ast_datastore_alloc(&iax2_variable_datastore_info, NULL)
(822,fr->callno)
(823,owner)
(824,cid_num)
(825,iaxs[fr->callno])
(826,format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)
(827,peercapability)
(828,send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREJ, 0, NULL, 0, -1)
(829,check_provisioning(&sin, fd, ies.serviceident, ies.provver)
(830,fr->callno)
(831,iaxs[fr->callno]->last)
(832,ast_strlen_zero(iaxs[fr->callno]->secret)
(833,f)
(834,callno)
(835,IAX_COMMAND_ACCEPT)
(836,iaxs[fr->callno]->reg->regstate = REG_STATE_REJECTED)
(837,buf_size)
(838,update_registry(&sin, fr->callno, ies.devicetype, fd, ies.refresh)
(839,ast_string_field_set(iaxs[fr->callno], cid_num, connected.id.number.str)
(840,f.subclass)
(841,iaxs[fr->callno]->iseqno)
(842,f.subclass)
(843,frametype)
(844,NULL)
(845,res = iax_firmware_append(&ied0, (unsigned char *)
(846,fr)
(847,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)
(848,IAX_STATE_STARTED)
(849,fr->iseqno)
(850,ts)
(851,AST_FRAME_IAX)
(852,fr->callno)
(853,callno)
(854,1)
(855,sizeof(sin)
(856,iaxs[fr->callno]->transferring)
(857,cid_num)
(858,iaxs[fr->callno]->state)
(859,callno)
(860,&sin)
(861,x)
(862,iaxs[fr->callno])
(863,ast_mutex_unlock(&iaxsl[fr->callno])
(864,vars)
(865,fr)
(866,f)
(867,NULL)
(868,devicetype)
(869,datalen)
(870,owner)
(871,f)
(872,callno)
(873,IAX_COMMAND_REJECT)
(874,peerformat)
(875,"BLINDTRANSFER")
(876,iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format)
(877,fr->callno)
(878,state)
(879,call_to_destroy)
(880,fr)
(881,var = var->next)
(882,ies.called_number)
(883,fh)
(884,*fh)
(885,IAX_CODEC_USER_FIRST)
(886,subclass)
(887,)
(888,f.subclass.integer != IAX_COMMAND_TXACC)
(889,iaxs)
(890,fr->callno)
(891,fr->callno)
(892,iaxs)
(893,fr)
(894,callno)
(895,capability)
(896,)
(897,callno)
(898,iaxs[fr->callno])
(899,called_number)
(900,iaxs[fr->callno]->transferring)
(901,exten)
(902,fh->ts)
(903,LOG_ERROR)
(904,1)
(905,ast_debug(1, "Received out of order packet... (type=%d, subclass %d, ts = %d, last = %d)
(906,next)
(907,fh)
(908,variablestore->inheritance)
(909,fr->callno)
(910,"Rejecting packet from \'%s.%d\' that is flagged as a full frame but is too short\\n")
(911,orignative)
(912,fr)
(913,owner)
(914,subclass)
(915,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(916,chosenformat)
(917,owner)
(918,ast_datastore_free(variablestore)
(919,ast_party_id_presentation(&connected.id)
(920,ast_variables_destroy(ies.vars)
(921,tmp3)
(922,iaxs[fr->callno])
(923,transfer)
(924,ast_channel_name(iaxs[fr->callno]->owner)
(925,iaxs[fr->callno])
(926,1)
(927,&ied0)
(928,if (iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)
(929,iaxs[fr->callno])
(930,fr->callno)
(931,fr)
(932,f.frametype)
(933,fr->callno)
(934,oseqno)
(935,peerformat)
(936,ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)
(937,iaxs)
(938,buf)
(939,iaxsl)
(940,(f.subclass.integer != IAX_COMMAND_TXACC)
(941,ast_test_flag64(iaxs[fr->callno], IAX_ENCRYPTED)
(942,variablestore)
(943,call_to_destroy = fr->callno)
(944,capability)
(945,ied0)
(946,buf)
(947,fr)
(948,pref = iaxs[fr->callno]->prefs)
(949,chosenformat)
(950,AST_FRAME_VIDEO)
(951,TRANSFER_READY)
(952,iaxs[fr->callno]->owner)
(953,iaxs[fr->callno]->addr)
(954,NULL)
(955,fr)
(956,send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
(957,iaxs)
(958,callno)
(959,iaxs[fr->callno])
(960,0x7fff)
(961,f.frametype != AST_FRAME_IAX)
(962,"reqonly")
(963,callno)
(964,\'\\0\')
(965,1)
(966,iaxs)
(967,csub)
(968,)
(969,IAX_ALREADYGONE)
(970,callno)
(971,NULL)
(972,fr->ts)
(973,iaxs)
(974,callno)
(975,iaxs)
(976,res++)
(977,ts)
(978,)
(979,ast_channel_unlock(iaxs[fr->callno]->owner)
(980,tmp2)
(981,ast_debug(1, "No channel, so populating IAXVARs to the pvt, as an intermediate step.\\n")
(982,ies.causecode)
(983,f)
(984,ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num)
(985,owner)
(986,0)
(987,f)
(988,1)
(989,ts)
(990,peerformat)
(991,f.frametype == AST_FRAME_VOICE)
(992,callno)
(993,&iaxsl[fr->callno])
(994,frametype)
(995,&ied0)
(996,cur->retries)
(997,fd = thread->iofd)
(998,send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1)
(999,fr)
(1000,ast_debug(1, "Acking anyway\\n")
(1001,callno)
(1002,ast_mutex_lock(&iaxsl[fr->callno])
(1003,iaxs[fr->callno]->owner)
(1004,iaxs[fr->callno]->chosenformat = format)
(1005,iaxs[fr->callno])
(1006,*fh)
(1007,fr)
(1008,iaxs[fr->callno])
(1009,ntohs(fh->dcallno)
(1010,callno)
(1011,iaxs)
(1012,iseqno)
(1013,using_prefs)
(1014,maxms)
(1015,subclass)
(1016,callno)
(1017,&sin)
(1018,ied0)
(1019,fr)
(1020,ied0)
(1021,reg)
(1022,IAX_STATE_TBD)
(1023,if (ast_strlen_zero(iaxs[fr->callno]->secret)
(1024,fr)
(1025,iaxs[fr->callno])
(1026,fr->callno)
(1027,fr->ts)
(1028,fr->ts)
(1029,f)
(1030,inheritance)
(1031,)
(1032,AST_LIST_LAST(&frame_queue[fr->callno])
(1033,fr->callno)
(1034,iaxs[fr->callno]->capability)
(1035,ies)
(1036,1)
(1037,iaxs[fr->callno])
(1038,callno)
(1039,callno)
(1040,ast_debug(1, "Really destroying %d, having been acked on final message\\n", call_to_destroy)
(1041,test_resync)
(1042,fr->callno)
(1043,fr->callno)
(1044,ast_log(LOG_WARNING, "Datalen < 0?\\n")
(1045,frametype)
(1046,iaxs[fr->callno])
(1047,subclass)
(1048,fh->oseqno)
(1049,iaxs)
(1050,ies.devicetype)
(1051,pingied)
(1052,)
(1053,f.subclass.integer != IAX_COMMAND_UNQUELCH)
(1054,fr)
(1055,var)
(1056,*mh)
(1057,if (iaxs[fr->callno]->peercallno)
(1058,fr)
(1059,tmp3)
(1060,f)
(1061,iaxs[fr->callno])
(1062,exists = 0)
(1063,&fr->ts)
(1064,c = ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->peerformat, NULL, 1)
(1065,"For call=%d, set last=%d\\n")
(1066,x++)
(1067,fr->callno)
(1068,iaxs)
(1069,ied0)
(1070,pokeexpire)
(1071,iaxs)
(1072,exists = ast_exists_extension(NULL, context, exten, 1, cid_num)
(1073,callno)
(1074,tmp)
(1075,fr->callno)
(1076,iaxs)
(1077,sizeof(iaxs[fr->callno]->transfer)
(1078,callno)
(1079,fr->callno)
(1080,IAX_ALLOWFWDOWNLOAD)
(1081,fr->callno)
(1082,if (iaxcompat)
(1083,id)
(1084,cur->retries = -1)
(1085,f.subclass.integer != IAX_COMMAND_TXACC)
(1086,f.frametype)
(1087,-1)
(1088,fr->callno)
(1089,buf_len)
(1090,addr)
(1091,iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno)
(1092,peer->historicms > 0)
(1093,)
(1094,IAX_CODEC_NOPREFS)
(1095,fr)
(1096,-1)
(1097,varlist)
(1098,oseqno)
(1099,last_iax_message)
(1100,data)
(1101,iaxs)
(1102,res >= sizeof(*fh)
(1103,iaxs[fr->callno]->bridgecallno)
(1104,if (ast_parking_ext_valid(ies.called_number, owner, context)
(1105,thread)
(1106,IAX_CODEC_NOCAP)
(1107,callno)
(1108,ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",\n\\n\\t\\t\\t\\t\\t\\t\\t"Status: On\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t"Channel: %s\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t"Uniqueid: %s\\r\\n",\n\\n\\t\\t\\t\\t\\t\\t\\tast_channel_name(iaxs[fr->callno]->owner)
(1109,1)
(1110,iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
(1111,fr->callno)
(1112,iaxs)
(1113,iaxs)
(1114,)
(1115,iaxs[fr->callno])
(1116,iaxs[fr->callno])
(1117,integer)
(1118,subclass)
(1119,&f.subclass.format)
(1120,fr->callno)
(1121,)
(1122,fr)
(1123,fr->callno)
(1124,iaxs)
(1125,iaxs)
(1126,iaxs[fr->callno])
(1127,if (authdebug)
(1128,fr->oseqno)
(1129,secret)
(1130,caller_pref_buf)
(1131,AST_LIST_HEAD_INIT(varlist)
(1132,fr->callno)
(1133,iaxs[fr->callno])
(1134,0)
(1135,callno)
(1136,number)
(1137,integer)
(1138,0)
(1139,iaxs[fr->callno])
(1140,minivid)
(1141,ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
(1142,f.frametype)
(1143,callno)
(1144,callno)
(1145,subclass)
(1146,c)
(1147,AST_CAUSE_NO_ROUTE_DESTINATION)
(1148,buf)
(1149,callno)
(1150,IAX_COMMAND_ACK)
(1151,)
(1152,ast_iax2_new(fr->callno, AST_STATE_RING, format, NULL, 1)
(1153,case IAX_COMMAND_REJECT:)
(1154,ntohs(fh->scallno)
(1155,ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->peerformat, NULL, 1)
(1156,ast_strlen_zero(iaxs[fr->callno]->inkeys)
(1157,data_size += strlen(subclass)
(1158,fr->callno)
(1159,buf)
(1160,-1)
(1161,)
(1162,fr)
(1163,callno)
(1164,fr)
(1165,iaxs)
(1166,iaxs[fr->callno])
(1167,f)
(1168,test_resync)
(1169,)
(1170,fr->callno)
(1171,ied1)
(1172,callno)
(1173,AST_FRAME_IAX)
(1174,)
(1175,iaxs)
(1176,fr)
(1177,fr)
(1178,peer)
(1179,fr)
(1180,callno)
(1181,iaxs[fr->callno])
(1182,struct ast_iax2_meta_hdr *)
(1183,fr)
(1184,IAX_COMMAND_TXACC)
(1185,fr->callno)
(1186,iaxs)
(1187,varlist)
(1188,iaxs)
(1189,fr)
(1190,fr)
(1191,iaxs[fr->callno] && iaxs[fr->callno]->last < fr->ts)
(1192,if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(1193,ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)
(1194,fr)
(1195,case IAX_COMMAND_POKE:)
(1196,IAX_COMMAND_UNQUELCH)
(1197,fr->callno)
(1198,fr)
(1199,iaxs[fr->callno])
(1200,subclass)
(1201,peer->historicms = (0 + peer->historicms)
(1202,iaxs[fr->callno]->rprefs)
(1203,if (strcmp(iaxs[fr->callno]->exten, "TBD")
(1204,format)
(1205,ast_log(LOG_WARNING, "Registry error\\n")
(1206,memset(&ied0, 0, sizeof(ied0)
(1207,)
(1208,ies)
(1209,maxms)
(1210,iax2_getformatname_multiple(tmp1, sizeof(tmp1)
(1211,calltokendata)
(1212,IAX_IE_CAUSECODE)
(1213,iaxs[fr->callno])
(1214,ntohs(mh->callno)
(1215,fr)
(1216,iaxs[fr->callno])
(1217,AST_FRAME_IAX)
(1218,fr->callno)
(1219,iaxsl[fr->callno])
(1220,iaxs[fr->callno])
(1221,send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_UNSUPPORT, 0, NULL, 0, -1)
(1222,iaxs[fr->callno]->peerformat)
(1223,callno)
(1224,fr)
(1225,format)
(1226,ast_log(LOG_WARNING, "Rejected connect attempt.  No secret present while force encrypt enabled.\\n")
(1227,iaxs[fr->callno])
(1228,fr->ts)
(1229,IAX_IE_CAUSE)
(1230,thread->buf + sizeof(struct ast_iax2_full_hdr)
(1231,ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD | IAX_STATE_AUTHENTICATED)
(1232,ied0.pos)
(1233,fr)
(1234,mh)
(1235,iaxs[fr->callno]->peerformat)
(1236,&iaxs[fr->callno]->transfer)
(1237,iaxs[fr->callno])
(1238,1)
(1239,callno)
(1240,sizeof(host_pref_buf)
(1241,ts)
(1242,fr)
(1243,iaxvars)
(1244,iaxs[fr->callno]->voiceformat)
(1245,fr)
(1246,find_callno(ntohs(mh->callno)
(1247,subclass)
(1248,iaxs[fr->callno]->state)
(1249,strlen(moh_suggest)
(1250,send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1)
(1251,iaxs[fr->callno]->exten)
(1252,callno)
(1253,fh)
(1254,f.subclass.integer)
(1255,peer->historicms)
(1256,x != fr->iseqno)
(1257,NULL)
(1258,scallno)
(1259,transferring)
(1260,iaxs[fr->callno]->videoformat = ast_format_to_old_bitfield(&f.subclass.format)
(1261,subclass)
(1262,)
(1263,fr)
(1264,peercapability)
(1265,context)
(1266,NULL)
(1267,iaxs[fr->callno]->rseqno >= iaxs[fr->callno]->oseqno)
(1268,fr)
(1269,integer)
(1270,iax2_getformatname(format)
(1271,iax2_queue_control_data(fr->callno, AST_CONTROL_UNHOLD, NULL, 0)
(1272,break;)
(1273,iaxs[iaxs[fr->callno]->bridgecallno])
(1274,iaxs[fr->callno])
(1275,callno)
(1276,IAX_COMMAND_ACK)
(1277,)
(1278,fr->callno)
(1279,reg)
(1280,callno)
(1281,pref)
(1282,fr)
(1283,sin_addr)
(1284,iaxs[fr->callno]->state)
(1285,if (authdebug)
(1286,fr)
(1287,fr)
(1288,iaxs[fr->callno])
(1289,fr->callno)
(1290,fr)
(1291,fr->callno)
(1292,!ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
(1293,1)
(1294,iaxs[fr->callno])
(1295,memset(&ied0, 0, sizeof(ied0)
(1296,fr)
(1297,fr)
(1298,fr->ts)
(1299,ast_channel_name(bridged_chan)
(1300,ts)
(1301,if (iaxs[fr->callno]->transferring == TRANSFER_READY)
(1302,fh->csub == IAX_COMMAND_REJECT\n\\n\\t\\t\\t|| fh->csub == IAX_COMMAND_REGREJ\n\\n\\t\\t\\t|| fh->csub == IAX_COMMAND_TXREJ)
(1303,fr->callno)
(1304,sizeof(ied1)
(1305,value)
(1306,!iaxs[fr->callno])
(1307,fr)
(1308,data_size)
(1309,1)
(1310,fr)
(1311,iaxs[fr->callno]->bridgecallno)
(1312,break;)
(1313,if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(1314,f.offset)
(1315,callno)
(1316,ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested \'%s\' incompatible with our capability \'%s\'.\\n",\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tast_inet_ntoa(sin.sin_addr)
(1317,callno)
(1318,if (!ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->chosenformat, NULL,\n\\n\\t\\t\\t\\t\\t\\t  ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED)
(1319,subclass)
(1320,iaxs[fr->callno])
(1321,registry_rerequest(&ies, fr->callno, &sin)
(1322,videoformat)
(1323,iaxs[fr->callno])
(1324,iaxs)
(1325,owner)
(1326,sizeof(ies)
(1327,if (prev)
(1328,var = ies.vars)
(1329,peer->historicms)
(1330,0)
(1331,fr)
(1332,IAX_QUELCH)
(1333,format)
(1334,fr->callno)
(1335,minivid = 0)
(1336,fr)
(1337,iaxs)
(1338,f.subclass)
(1339,memset(&ied1, 0, sizeof(ied1)
(1340,peer)
(1341,f.subclass)
(1342,iaxs[fr->callno]->last < fr->ts)
(1343,iaxs[fr->callno]->exten)
(1344,data_size)
(1345,prev)
(1346,iaxs[fr->callno]->capability)
(1347,)
(1348,vh->ts)
(1349,IAX_IE_CAUSECODE)
(1350,integer)
(1351,iaxs)
(1352,fr)
(1353,iaxs[fr->callno])
(1354,"I can haz iaxvars, but they is no good.  :-(\\n")
(1355,fr)
(1356,fr)
(1357,sizeof(ied1)
(1358,sin.sin_addr)
(1359,fr->callno)
(1360,fr->callno)
(1361,fr)
(1362,vh)
(1363,iaxs[fr->callno])
(1364,fr)
(1365,&pref)
(1366,mount_callid = iax_pvt_callid_get(fr->callno)
(1367,&ies)
(1368,cause_code)
(1369,iaxs[fr->callno]->peercapability)
(1370,callno)
(1371,NULL)
(1372,prev)
(1373,callno)
(1374,callno)
(1375,mh->ts)
(1376,integer)
(1377,iaxs)
(1378,VERBOSE_PREFIX_4)
(1379,iaxs)
(1380,fr->callno)
(1381,IAX_COMMAND_REJECT)
(1382,)
(1383,!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)
(1384,callno)
(1385,fr->ts)
(1386,meta)
(1387,fr->callno)
(1388,integer)
(1389,fr->callno)
(1390,fr->callno)
(1391,iaxs)
(1392,fr->callno)
(1393,"Received mini frame before first full voice frame\\n")
(1394,peer->lastms > -1)
(1395,inkeys)
(1396,serviceident)
(1397,memset(&pref, 0, sizeof(pref)
(1398,peer)
(1399,zeros)
(1400,LOG_NOTICE)
(1401,cur)
(1402,fr->ts)
(1403,ied0)
(1404,iaxs[fr->callno]->peerformat)
(1405,iaxs[fr->callno]->owner)
(1406,fr)
(1407,fr)
(1408,)
(1409,iaxs[fr->callno])
(1410,f.frametype)
(1411,iaxs[fr->callno])
(1412,fh)
(1413,scallno)
(1414,AST_FRAME_IAX)
(1415,ast_channel_nativeformats(iaxs[fr->callno]->owner)
(1416,fr)
(1417,fr)
(1418,frametype)
(1419,fr->callno)
(1420,iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)
(1421,iaxs[fr->callno]->voiceformat)
(1422,fr)
(1423,f.frametype)
(1424,iaxs[fr->callno])
(1425,(f.frametype != AST_FRAME_VOICE)
(1426,if (f.subclass.format.id != ast_format_id_from_old_bitfield(iaxs[fr->callno]->videoformat)
(1427,fr)
(1428,iaxs[fr->callno])
(1429,ied0)
(1430,tmp2)
(1431,fr)
(1432,format)
(1433,iaxs[fr->callno]->chosenformat)
(1434,0)
(1435,res)
(1436,ast_clear_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART)
(1437,iaxs)
(1438,f.subclass.integer)
(1439,sin.sin_addr)
(1440,ntohs(fh->dcallno)
(1441,ast_channel_name(bridged_chan)
(1442,iaxs[fr->callno])
(1443,fr)
(1444,sin.sin_addr)
(1445,if (cur->transfer)
(1446,fr->callno)
(1447,frametype)
(1448,iaxs[fr->callno])
(1449,f.frametype == AST_FRAME_CONTROL)
(1450,integer)
(1451,peer->lastms)
(1452,ast_inet_ntoa(sin.sin_addr)
(1453,iaxs)
(1454,fh)
(1455,fr)
(1456,&iaxsl[fr->callno])
(1457,fr)
(1458,sin)
(1459,if (f.datalen < 0)
(1460,fr->callno)
(1461,IAX_RECVCONNECTEDLINE)
(1462,buf)
(1463,iaxs[fr->callno])
(1464,iaxs[fr->callno])
(1465,chan_name)
(1466,LOG_ERROR)
(1467,capability)
(1468,callno)
(1469,connected.id.name.str)
(1470,iaxsl)
(1471,mh->callno)
(1472,iaxs[fr->callno]->voiceformat)
(1473,f.subclass)
(1474,iaxs[fr->callno])
(1475,fr->callno)
(1476,fr->callno)
(1477,caller_pref_buf)
(1478,*cause_code)
(1479,fr->callno)
(1480,AST_LIST_LOCK(&dpcache)
(1481,new_callno)
(1482,sin.sin_addr)
(1483,&iaxs[fr->callno]->state)
(1484,ast_inet_ntoa(sin.sin_addr)
(1485,iaxs)
(1486,callno)
(1487,&iaxsl[fr->callno])
(1488,0)
(1489,f.data.ptr)
(1490,if (delayreject)
(1491,iaxs[fr->callno])
(1492,iaxs[fr->callno])
(1493,fr)
(1494,iaxs[fr->callno])
(1495,peer->lastms)
(1496,)
(1497,thread->buf)
(1498,f.subclass.integer != IAX_COMMAND_ACK)
(1499,iaxs)
(1500,f)
(1501,fr)
(1502,fr = ast_alloca(sizeof(*fr)
(1503,iaxsl[call_to_destroy])
(1504,if (iaxs[fr->callno] && ast_test_flag64(iaxs[fr->callno], IAX_ENCRYPTED)
(1505,iaxs[fr->callno]->peerformat = ast_format_cap_to_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner)
(1506,iaxs[fr->callno]->transferring == TRANSFER_BEGIN)
(1507,&dpcache)
(1508,prev)
(1509,str)
(1510,ast_channel_name(iaxs[fr->callno]->owner)
(1511,0)
(1512,(iaxs[fr->callno]->last & 0xFFFF0000L)
(1513,iaxs[fr->callno])
(1514,NULL)
(1515,fr->iseqno = fh->iseqno)
(1516,iaxs[iaxs[fr->callno]->bridgecallno]->owner)
(1517,callno)
(1518,iaxs[fr->callno]->owner)
(1519,callno)
(1520,res - sizeof(*fh)
(1521,&f.subclass.format)
(1522,iaxs)
(1523,iaxs)
(1524,callno)
(1525,iaxs)
(1526,decrypted)
(1527,if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(1528,fh->iseqno + 1)
(1529,f)
(1530,fr->callno)
(1531,fr)
(1532,iaxs)
(1533,"mine")
(1534,iaxs[fr->callno]->owner)
(1535,iaxs[fr->callno])
(1536,fr)
(1537,callno)
(1538,fr->iseqno)
(1539,fr->callno)
(1540,iaxs[iaxs[fr->callno]->bridgecallno])
(1541,fr)
(1542,callno)
(1543,)
(1544,if (f.subclass.integer == IAX_COMMAND_REGREL)
(1545,ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED)
(1546,iaxdebug)
(1547,iseqno)
(1548,ast_debug(1, "Packet arrived out of order (expecting %d, got %d)
(1549,fr->callno)
(1550,iseqno)
(1551,bridgecallno)
(1552,pref)
(1553,iax2_getformatname_multiple(tmp, sizeof(tmp)
(1554,iaxs[fr->callno]->owner)
(1555,iaxsl)
(1556,iaxs[fr->callno]->owner)
(1557,uncompress_subclass(fh->csub)
(1558,iaxs[fr->callno]->peerformat)
(1559,res)
(1560,callno)
(1561,fr)
(1562,if (!ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
(1563,fr)
(1564,f)
(1565,fr)
(1566,subclass)
(1567,using_prefs = "caller")
(1568,name)
(1569,integer)
(1570,AST_FRAME_IAX)
(1571,callno)
(1572,vh->ts)
(1573,peer)
(1574,&iaxsl[call_to_destroy])
(1575,iaxsl[fr->callno])
(1576,IAX_CODEC_NOCAP)
(1577,ntohs(mh->callno)
(1578,if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)
(1579,ied0)
(1580,cause_code)
(1581,)
(1582,iaxs[fr->callno])
(1583,sizeof(tmp2)
(1584,0)
(1585,ast_calloc(1, sizeof(*varlist)
(1586,"I can haz IAX vars?\\n")
(1587,fr)
(1588,callno)
(1589,sin.sin_addr)
(1590,iaxs[fr->callno])
(1591,f.datalen)
(1592,iaxs[fr->callno])
(1593,fr->callno)
(1594,ied0)
(1595,ied1)
(1596,)
(1597,&ied0)
(1598,fr->callno)
(1599,call_to_destroy = 0)
(1600,iaxs[fr->callno]->owner)
(1601,ies)
(1602,context)
(1603,ied0.buf)
(1604,prev)
(1605,ast_variables_destroy(ies.vars)
(1606,iaxs)
(1607,0)
(1608,iaxs[fr->callno])
(1609,iaxs[fr->callno])
(1610,0)
(1611,iaxs[fr->callno])
(1612,NULL)
(1613,ied0)
(1614,iaxs)
(1615,AST_FRAME_IAX)
(1616,f.mallocd)
(1617,!ast_connected_line_parse_data(f.data.ptr, f.datalen, &connected)
(1618,if (strcasecmp(iaxs[fr->callno]->exten, "TBD")
(1619,ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
(1620,fr->callno)
(1621,0)
(1622,fh)
(1623,callno)
(1624,sizeof(ied0)
(1625,merge_encryption(iaxs[fr->callno],ies.encmethods)
(1626,fr->callno)
(1627,f.subclass)
(1628,(f.subclass.integer != IAX_COMMAND_ACK)
(1629,callno)
(1630,owner)
(1631,fr->callno)
(1632,sizeof(ied1)
(1633,&f.subclass.format)
(1634,var->value)
(1635,peer->smoothing && peer->lastms < 0)
(1636,ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested \'%s\' incompatible with our capability \'%s\'.\\n",\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tast_inet_ntoa(sin.sin_addr)
(1637,state)
(1638,iaxs[fr->callno])
(1639,IAX_COMMAND_REJECT)
(1640,if (strcasecmp(iaxs[fr->callno]->exten, "TBD")
(1641,IAX_COMMAND_TXCNT)
(1642,iaxsl[fr->callno])
(1643,"PeerStatus")
(1644,break;)
(1645,iaxs[fr->callno])
(1646,fr->callno)
(1647,f)
(1648,VERBOSE_PREFIX_4)
(1649,IAX_FLAG_FULL)
(1650,iaxs[fr->callno]->hold_signaling)
(1651,send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1)
(1652,NULL)
(1653,fr->callno)
(1654,ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num)
(1655,presentation)
(1656,cur)
(1657,callno)
(1658,caller_pref_buf)
(1659,iaxs[fr->callno])
(1660,fr)
(1661,fd)
(1662,offset)
(1663,buf)
(1664,owner)
(1665,callno)
(1666,fr)
(1667,1)
(1668,rseqno)
(1669,username)
(1670,if (!format)
(1671,callno)
(1672,callno)
(1673,fh)
(1674,fr)
(1675,)
(1676,2)
(1677,iaxsl)
(1678,ies)
(1679,ast_inet_ntoa(sin.sin_addr)
(1680,f.frametype)
(1681,tmp1)
(1682,!format)
(1683,f)
(1684,break;)
(1685,thread->buf + sizeof(*vh)
(1686,var->next)
(1687,fr->callno)
(1688,fr->callno)
(1689,owner)
(1690,fr->af)
(1691,iaxs[fr->callno]->state)
(1692,IAX_IE_FORMAT)
(1693,iaxs[fr->callno])
(1694,newvar)
(1695,0)
(1696,fr)
(1697,case IAX_COMMAND_TXREADY:)
(1698,fr->callno)
(1699,callno)
(1700,iaxs)
(1701,strcmp(iaxs[fr->callno]->exten, "TBD")
(1702,transferring)
(1703,)
(1704,data_size)
(1705,IAX_CODEC_NOCAP)
(1706,if ((peer->lastms < 0)
(1707,callno)
(1708,fr->callno)
(1709,fr)
(1710,if (iaxs[fr->callno]->voiceformat > 0)
(1711,f.subclass)
(1712,using_prefs = "mine")
(1713,meta)
(1714,f)
(1715,iaxs)
(1716,ast_channel_unlock(iaxs[fr->callno]->owner)
(1717,iaxs[fr->callno]->owner)
(1718,iseqno)
(1719,AST_FRAME_IAX)
(1720,IAX_COMMAND_HANGUP)
(1721,)
(1722,ies.called_number)
(1723,fr)
(1724,owner)
(1725,0xFFFF0000L)
(1726,fr->callno)
(1727,fr->iseqno)
(1728,sin_addr)
(1729,ies)
(1730,peercapability)
(1731,iaxs[iaxs[fr->callno]->bridgecallno]->transferring)
(1732,*c = NULL)
(1733,iaxs)
(1734,iaxs[fr->callno]->last < fr->ts)
(1735,fr)
(1736,iaxsl)
(1737,if (!iaxs[fr->callno])
(1738,fr->callno)
(1739,(f.subclass.integer != IAX_COMMAND_TXCNT)
(1740,0)
(1741,callno)
(1742,pos)
(1743,iaxs)
(1744,iaxs)
(1745,fr)
(1746,fr)
(1747,state)
(1748,iaxs[fr->callno]->error = EPERM)
(1749,&res)
(1750,callno)
(1751,iaxs[fr->callno]->rprefs)
(1752,callno)
(1753,f.subclass)
(1754,iaxs)
(1755,fr->callno)
(1756,)
(1757,if (!(dp->flags & CACHE_FLAG_TRANSMITTED)
(1758,break;)
(1759,EVENT_FLAG_CALL)
(1760,f.subclass.integer)
(1761,fr->iseqno >= iaxs[fr->callno]->rseqno)
(1762,fr->callno)
(1763,exists = 0)
(1764,iaxs)
(1765,capability)
(1766,fh->csub)
(1767,0)
(1768,send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1)
(1769,"Unable to negotiate codec")
(1770,callno)
(1771,callno)
(1772,iaxs[fr->callno]->last)
(1773,1)
(1774,iax2_getformatname_multiple(tmp3, sizeof(tmp3)
(1775,"Releasing %s and %s\\n")
(1776,ast_channel_caller(iaxs[fr->callno]->owner)
(1777,peercapability)
(1778,&ied0)
(1779,iaxs)
(1780,res)
(1781,if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)
(1782,iaxs[fr->callno])
(1783,fr)
(1784,&ies)
(1785,iaxs[fr->callno]->state)
(1786,ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE)
(1787,fr)
(1788,iaxs[fr->callno])
(1789,fr->callno)
(1790,0)
(1791,iaxs[fr->callno])
(1792,newvar)
(1793,return 1;)
(1794,iaxs[fr->callno])
(1795,tmp)
(1796,iaxs[fr->callno])
(1797,"Ooh, voice format changed to \'%s\'\\n")
(1798,ntohs(mh->callno)
(1799,ied0)
(1800,fr->callno)
(1801,minivid = 1)
(1802,ies)
(1803,sin)
(1804,iaxdebug)
(1805,if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)
(1806,callno)
(1807,callno)
(1808,fr)
(1809,!iaxs[fr->callno])
(1810,iaxsl[fr->callno])
(1811,0)
(1812,iaxs[fr->callno])
(1813,f)
(1814,iaxs)
(1815,IAX_IE_CAUSECODE)
(1816,ied0)
(1817,fr->callno)
(1818,voiceformat)
(1819,inkeys)
(1820,if (!newvar)
(1821,IAX_DEBUGDIGEST("Receiving", ies.challenge)
(1822,last)
(1823,fr->callno)
(1824,0)
(1825,fr->callno)
(1826,peercallno)
(1827,callno)
(1828,fr->ts)
(1829,&iaxsl[fr->callno])
(1830,3)
(1831,ast_strlen_zero(iaxs[fr->callno]->inkeys)
(1832,ast_test_flag64(iaxs[fr->callno], IAX_TRUNK)
(1833,sin.sin_addr)
(1834,AST_FRAME_NULL)
(1835,fh)
(1836,f.subclass)
(1837,fr->outoforder)
(1838,iaxs[fr->callno])
(1839,iaxs)
(1840,peer->historicms = (iaxs[fr->callno]->pingtime + peer->historicms)
(1841,str)
(1842,&sin)
(1843,)
(1844,ptr)
(1845,iaxs)
(1846,f.subclass)
(1847,owner)
(1848,)
(1849,fr)
(1850,iaxs[fr->callno]->rseqno = fr->iseqno)
(1851,if (iaxdebug)
(1852,iaxs[fr->callno]->capability)
(1853,lastms)
(1854,callno)
(1855,ies.vars)
(1856,ast_format_set_video_mark(&f.subclass.format)
(1857,if ((fh->csub >> 6)
(1858,subclass)
(1859,iaxs[fr->callno]->addr)
(1860,iaxs[fr->callno]->iseqno)
(1861,iaxs[fr->callno])
(1862,iaxs)
(1863,ast_channel_name(iaxs[fr->callno]->owner)
(1864,owner)
(1865,if (iaxs[fr->callno] && iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno)
(1866,ies.cause)
(1867,1)
(1868,)
(1869,called_number)
(1870,format)
(1871,pokefreqok)
(1872,strlen(subclass)
(1873,&pref)
(1874,0)
(1875,"Accepted AUTHENTICATED TBD call from %s\\n")
(1876,owner)
(1877,ptr)
(1878,)
(1879,iax2_getformatname_multiple(tmp1, sizeof(tmp1)
(1880,iaxs[fr->callno]->prefs)
(1881,ts)
(1882,vh->zeros)
(1883,iaxs[fr->callno]->last < fr->ts &&\n\\n                            f.subclass.integer != IAX_COMMAND_ACK &&\n\\n                            f.subclass.integer != IAX_COMMAND_PONG &&\n\\n                            f.subclass.integer != IAX_COMMAND_LAGRP)
(1884,fr->callno)
(1885,"Call accepted by %s (format %s)
(1886,callno)
(1887,iax2_getformatname(iaxs[fr->callno]->peerformat)
(1888,"disabled")
(1889,f.subclass.integer != IAX_COMMAND_TXCNT)
(1890,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(1891,connected.id.name)
(1892,fr->iseqno)
(1893,callno)
(1894,ts)
(1895,iaxs[fr->callno])
(1896,"IAX2/%s")
(1897,sin_addr)
(1898,!ast_strlen_zero(moh_suggest)
(1899,if (res < sizeof(*vh)
(1900,historicms)
(1901,fr->callno)
(1902,iaxs[fr->callno])
(1903,context)
(1904,fr->callno)
(1905,iaxs[fr->callno]->state)
(1906,0)
(1907,state)
(1908,connected.id.number)
(1909,iaxs)
(1910,iaxs)
(1911,ast_format_cap_set(native, &f.subclass.format)
(1912,ast_mutex_lock(&iaxsl[fr->callno])
(1913,callno)
(1914,)
(1915,owner ? ast_bridged_channel(owner)
(1916,!iaxs[fr->callno])
(1917,fr)
(1918,ies.cause)
(1919,variablestore->data)
(1920,f.offset = 0)
(1921,fr->callno)
(1922,context)
(1923,fr->callno)
(1924,decrypt_frame(fr->callno, fh, &f, &res)
(1925,ast_log(LOG_WARNING,\n\\n\\t\\t\\t\\t\\t\\t\\t\\t"Async goto of \'%s\' to \'%s@%s\' failed\\n",\n\\n\\t\\t\\t\\t\\t\\t\\t\\tast_channel_name(bridged_chan)
(1926,fr)
(1927,if (ies.provverpres && ies.serviceident && sin.sin_addr.s_addr)
(1928,)
(1929,IAX_COMMAND_TXCNT)
(1930,iaxs[fr->callno])
(1931,callno)
(1932,calling_pres)
(1933,frametype)
(1934,fr->callno)
(1935,causecode)
(1936,f.subclass)
(1937,iaxs[fr->callno])
(1938,minivid)
(1939,callno)
(1940,fr)
(1941,ast_verb(3, "Accepted unauthenticated TBD call from %s\\n", ast_inet_ntoa(sin.sin_addr)
(1942,!minivid &&\n\\n\\t\\tf.subclass.integer != IAX_COMMAND_TXCNT &&\\t\\t/* for attended transfer */\n\\n\\t\\tf.subclass.integer != IAX_COMMAND_TXACC)
(1943,iaxs[fr->callno]->capability)
(1944,break;)
(1945,fr->callno)
(1946,vh->zeros == 0)
(1947,oseqno)
(1948,if (iaxs[fr->callno])
(1949,fr)
(1950,)
(1951,&iaxs[fr->callno]->rprefs)
(1952,callno)
(1953,fr->callno)
(1954,var->name)
(1955,ies.musiconhold)
(1956,)
(1957,owner)
(1958,iaxs[fr->callno])
(1959,pref)
(1960,mh->ts)
(1961,)
(1962,prefs)
(1963,pos)
(1964,ntohs(mh->callno)
(1965,peercallno)
(1966,struct ast_iax2_full_hdr *)
(1967,)
(1968,save_osptoken(fr, &ies)
(1969,subclass)
(1970,format)
(1971,1)
(1972,iaxs)
(1973,ast_inet_ntoa(sin.sin_addr)
(1974,fr->iseqno)
(1975,iaxs[fr->callno])
(1976,f)
(1977,fr->callno)
(1978,iaxs)
(1979,type)
(1980,f)
(1981,(f.subclass.integer != IAX_COMMAND_TXCNT)
(1982,ast_debug(1, "Simulating frame ts resync, was %u now %u\\n", fr->ts, fr->ts + test_resync)
(1983,sizeof(*vh)
(1984,fr)
(1985,iaxs[fr->callno]->error = ENOTCONN)
(1986,iax2_queue_control_data(fr->callno, AST_CONTROL_HOLD, \n\\n\\t\\t\\t\\t\\t\\t\\t\\tS_OR(moh_suggest, NULL)
(1987,c)
(1988,return 1;)
(1989,f)
(1990,callno)
(1991,fr->callno)
(1992,callno)
(1993,callno)
(1994,subclass)
(1995,LOG_WARNING)
(1996,AST_CONTROL_BUSY)
(1997,fr)
(1998,iaxs)
(1999,exten)
(2000,fh)
(2001,iaxs[fr->callno]->pingtime)
(2002,sizeof(caller_pref_buf)
(2003,iaxs[fr->callno]->frames_received++)
(2004,)
(2005,ast_format_cap_to_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner)
(2006,fr)
(2007,cur->retries = -1)
(2008,fr->callno)
(2009,fr->callno)
(2010,subclass)
(2011,ies.vars)
(2012,IAX_COMMAND_ACK)
(2013,fr->callno)
(2014,LOG_NOTICE)
(2015,iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL)
(2016,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(2017,sizeof(tmp1)
(2018,iaxs)
(2019,\'\\0\')
(2020,f.subclass.integer != IAX_COMMAND_PONG)
(2021,iaxs[fr->callno])
(2022,error)
(2023,"I don\'t know how to authenticate %s to %s\\n")
(2024,fr->callno)
(2025,iaxs[fr->callno]->peerformat)
(2026,break;)
(2027,ast_variables_destroy(ies.vars)
(2028,new_peercallno != iaxs[fr->callno]->peercallno)
(2029,fr)
(2030,buf)
(2031,buf)
(2032,authenticate_verify(iaxs[fr->callno], &ies)
(2033,iax2_destroy(fr->callno)
(2034,peer)
(2035,fr->callno)
(2036,csub)
(2037,0)
(2038,!newvar)
(2039,iaxs[iaxs[fr->callno]->bridgecallno]->transferring)
(2040,IAX_CODEC_NOCAP)
(2041,iaxs[fr->callno])
(2042,ies)
(2043,iaxs[fr->callno])
(2044,subclass)
(2045,callno)
(2046,IAX_STATE_STARTED)
(2047,sizeof(tmp1)
(2048,NULL)
(2049,ast_channel_name(bridged_chan)
(2050,ast_debug(1, "Received packet %d, (%d, %u)
(2051,send_command_transfer(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXACC, 0, NULL, 0)
(2052,IAX_COMMAND_AUTHREQ)
(2053,fr)
(2054,)
(2055,fr->callno)
(2056,fr->callno)
(2057,!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)
(2058,iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1)
(2059,iaxs)
(2060,)
(2061,iax2_destroy(fr->callno)
(2062,iaxs[fr->callno])
(2063,f.src = "LAGRQ")
(2064,iaxs)
(2065,IAX_COMMAND_TXREADY)
(2066,fr)
(2067,f.subclass.integer)
(2068,frame_queue)
(2069,ied0.pos)
(2070,check_dcallno)
(2071,iaxs[fr->callno]->pingtime)
(2072,f)
(2073,f.frametype)
(2074,iaxs[fr->callno])
(2075,NULL)
(2076,callno)
(2077,&f)
(2078,iseqno)
(2079,iaxs[fr->callno])
(2080,f.subclass.integer)
(2081,"Status: Off\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t"Channel: %s\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t"Uniqueid: %s\\r\\n")
(2082,sin)
(2083,callno)
(2084,iaxs[fr->callno])
(2085,capability)
(2086,)
(2087,historicms)
(2088,iaxs[iaxs[fr->callno]->bridgecallno]->owner)
(2089,"Async goto not applicable on call %d\\n")
(2090,callno)
(2091,&ied0)
(2092,iaxs[fr->callno]->last)
(2093,for (var = ies.vars; var; var = var->next)
(2094,0)
(2095,f.subclass)
(2096,fr)
(2097,ts)
(2098,1)
(2099,fr)
(2100,f.frametype)
(2101,iaxs[fr->callno]->rprefs)
(2102,1)
(2103,owner)
(2104,peer)
(2105,iaxs[fr->callno])
(2106,&iaxs[fr->callno]->state)
(2107,*prev = NULL)
(2108,fr)
(2109,fr->callno)
(2110,iaxs)
(2111,strlen(moh_suggest)
(2112,ies.vars)
(2113,fr->ts)
(2114,iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner)
(2115,ies)
(2116,vh)
(2117,fr->callno)
(2118,iaxs[fr->callno])
(2119,iax_frame_subclass2str(fh->csub, subclass, sizeof(subclass)
(2120,fr)
(2121,"No channel, so populating IAXVARs to the pvt, as an intermediate step.\\n")
(2122,var)
(2123,moh_suggest)
(2124,subclass[40] = "")
(2125,iaxcompat)
(2126,S_COR(connected.id.number.valid, connected.id.number.str, "")
(2127,fr)
(2128,fr->callno)
(2129,ies.challenge)
(2130,callno)
(2131,ied1.buf)
(2132,IAX_COMMAND_ACK)
(2133,exists = ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num)
(2134,ies)
(2135,ies.vars = NULL)
(2136,fr->callno)
(2137,ast_mutex_unlock(&iaxsl[fr->callno])
(2138,IAX_COMMAND_NEW)
(2139,iaxs)
(2140,"Unable to negotiate codec")
(2141,iaxsl[fr->callno])
(2142,fr->callno)
(2143,iaxs)
(2144,iaxs)
(2145,~IAX_FLAG_FULL)
(2146,state)
(2147,if (new_peercallno && new_peercallno != iaxs[fr->callno]->peercallno)
(2148,fr)
(2149,)
(2150,callno)
(2151,callno)
(2152,fr->callno)
(2153,iaxs[fr->callno])
(2154,iaxs)
(2155,ptr)
(2156,(f.subclass.integer != IAX_COMMAND_TXACC)
(2157,tmp3)
(2158,callno)
(2159,iaxs[fr->callno])
(2160,owner)
(2161,encmethods)
(2162,0)
(2163,ies.format)
(2164,f.subclass)
(2165,)
(2166,fr->callno)
(2167,ies)
(2168,ies)
(2169,if (!iaxs[fr->callno])
(2170,pref)
(2171,fr->callno)
(2172,iaxs[fr->callno]->last_iax_message = f.subclass.integer)
(2173,"<unknown>")
(2174,1)
(2175,2)
(2176,)
(2177,datalen)
(2178,fr->callno)
(2179,1)
(2180,ies.vars)
(2181,iaxs[fr->callno])
(2182,tmp3)
(2183,callno)
(2184,thread->buf + sizeof(*mh)
(2185,)
(2186,iaxs)
(2187,meta->metacmd)
(2188,callno)
(2189,f.datalen)
(2190,iaxs)
(2191,NULL)
(2192,)
(2193,f.data)
(2194,iaxs[fr->callno])
(2195,)
(2196,iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner)
(2197,f.subclass.integer == AST_CONTROL_CONNECTED_LINE)
(2198,fr)
(2199,&ied1)
(2200,prev)
(2201,ies)
(2202,fr->callno)
(2203,sin_addr)
(2204,f.data.ptr)
(2205,callno)
(2206,ast_var_assign(var->name, var->value)
(2207,*cause_code)
(2208,ntohs(vh->ts)
(2209,iaxs[fr->callno])
(2210,ast_format_cap_from_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner)
(2211,iaxs)
(2212,iaxs[fr->callno])
(2213,if (iaxdebug)
(2214,iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION)
(2215,causecode)
(2216,iaxs)
(2217,if (f.frametype == AST_FRAME_IAX)
(2218,fr)
(2219,memset(&pref, 0, sizeof(pref)
(2220,ast_channel_uniqueid(iaxs[fr->callno]->owner)
(2221,iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability)
(2222,iaxs[fr->callno]->owner)
(2223,using_prefs = "mine")
(2224,IAX_STATE_STARTED)
(2225,callno)
(2226,iaxs[fr->callno]->peercallno)
(2227,ast_aes_set_decrypt_key((unsigned char *)
(2228,fr->callno)
(2229,default:)
(2230,&pref)
(2231,iaxs)
(2232,fr)
(2233,)
(2234,state)
(2235,fr)
(2236,state)
(2237,bridgecallno)
(2238,ies)
(2239,1)
(2240,"No such context/extension")
(2241,fr->callno)
(2242,iaxs[fr->callno])
(2243,fr->callno)
(2244,iaxs)
(2245,callno)
(2246,ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\\n")
(2247,iaxs)
(2248,fr->callno)
(2249,variablestore && varlist)
(2250,f)
(2251,)
(2252,owner)
(2253,)
(2254,ies.calltokendata)
(2255,variablestore)
(2256,src)
(2257,integer)
(2258,callno)
(2259,break;)
(2260,vars)
(2261,fr)
(2262,f.subclass.integer)
(2263,iaxsl)
(2264,IAX_COMMAND_NEW)
(2265,iaxs[fr->callno])
(2266,iaxs)
(2267,&tmpfmt)
(2268,callno)
(2269,&iaxs[fr->callno]->state)
(2270,callno)
(2271,ntohs(mh->ts)
(2272,voiceformat)
(2273,number)
(2274,fr)
(2275,iaxsl[fr->callno])
(2276,fr)
(2277,AST_FRAME_IAX)
(2278,f.subclass.integer)
(2279,iaxs)
(2280,fr->callno)
(2281,fr)
(2282,callno)
(2283,)
(2284,f)
(2285,f)
(2286,AST_CAUSE_NO_ROUTE_DESTINATION)
(2287,AST_FRAME_VOICE)
(2288,variablestore)
(2289,iaxs[fr->callno])
(2290,ast_inet_ntoa(sin.sin_addr)
(2291,iaxs)
(2292,IAX_COMMAND_TXACC)
(2293,ts)
(2294,fh->csub)
(2295,fr->callno)
(2296,AST_FRAME_IAX)
(2297,f)
(2298,fr->callno)
(2299,fr->callno)
(2300,iaxs)
(2301,fr->callno)
(2302,)
(2303,frametype)
(2304,varlist)
(2305,ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "IAX2/%s", peer->name)
(2306,fr->outoforder = 0)
(2307,)
(2308,iaxs[fr->callno])
(2309,format)
(2310,fr)
(2311,fr->callno)
(2312,strcpy(host_pref_buf, "disabled")
(2313,callno)
(2314,fr)
(2315,ies.causecode)
(2316,f.subclass.integer != IAX_COMMAND_INVAL)
(2317,iax2_poke_peer_s)
(2318,iaxs)
(2319,native)
(2320,return 1;)
(2321,fr)
(2322,format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0)
(2323,ied1)
(2324,ast_log(LOG_NOTICE, "Packet Decrypt Failed!\\n")
(2325,new_peercallno && new_peercallno != iaxs[fr->callno]->peercallno)
(2326,f)
(2327,iaxs)
(2328,fr)
(2329,memset(&iaxs[fr->callno]->transfer, 0, sizeof(iaxs[fr->callno]->transfer)
(2330,stop_stuff(iaxs[fr->callno]->bridgecallno)
(2331,integer)
(2332,iaxs)
(2333,fr)
(2334,iaxs[fr->callno])
(2335,iaxs)
(2336,ied0.pos)
(2337,IAX_FLAG_RETRANS)
(2338,peer_ref(peer)
(2339,fr)
(2340,(f.subclass.integer != IAX_COMMAND_TXCNT)
(2341,IAX_COMMAND_TXREADY)
(2342,iaxs)
(2343,iax2_lock_owner(fr->callno)
(2344,1)
(2345,sin.sin_addr)
(2346,f)
(2347,!iaxs[fr->callno])
(2348,using_prefs)
(2349,send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
(2350,iaxs[fr->callno])
(2351,ied1)
(2352,)
(2353,)
(2354,iaxs)
(2355,sin)
(2356,"Memory allocation error while processing IAX2 variables\\n")
(2357,iaxs[fr->callno])
(2358,ies.serviceident && sin.sin_addr.s_addr)
(2359,fr->callno)
(2360,1)
(2361,1)
(2362,iaxvars)
(2363,&f.subclass.format)
(2364,prev = var)
(2365,ied1)
(2366,callno)
(2367,iaxs[fr->callno]->transferring)
(2368,var->next)
(2369,callno)
(2370,fr->iseqno)
(2371,fr)
(2372,"disabled")
(2373,iaxs[fr->callno]->transferring = 0)
(2374,peerformat)
(2375,tmp3)
(2376,dcallno)
(2377,callno)
(2378,)
(2379,vars)
(2380,iaxs[fr->callno])
(2381,iaxs[fr->callno]->peerformat)
(2382,variablestore)
(2383,subclass)
(2384,-1)
(2385,f)
(2386,0)
(2387,peer)
(2388,fr)
(2389,iaxs[fr->callno]->state)
(2390,tmp2)
(2391,fr->callno)
(2392,fh->oseqno)
(2393,serviceident)
(2394,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)
(2395,tmp)
(2396,IAX_IE_CAUSE)
(2397,if (iaxs[fr->callno]->owner && ast_test_flag64(iaxs[fr->callno], IAX_QUELCH)
(2398,ast_format_from_old_bitfield(&f.subclass.format, iaxs[fr->callno]->voiceformat)
(2399,&iaxs[fr->callno]->addr)
(2400,1)
(2401,fr->callno)
(2402,iaxs[fr->callno])
(2403,fr->callno)
(2404,ies.username)
(2405,next)
(2406,iaxs)
(2407,inaddrcmp(&sin, &iaxs[fr->callno]->addr)
(2408,callno)
(2409,ies)
(2410,fr->iseqno)
(2411,samples)
(2412,callno)
(2413,"TBD")
(2414,iax_outputframe(NULL, fh, 1, &sin, res - sizeof(*fh)
(2415,ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
(2416,buf)
(2417,f.frametype)
(2418,if (authdebug)
(2419,fr)
(2420,connected.id)
(2421,f)
(2422,ied0)
(2423,peercapability)
(2424,ast_mutex_unlock(&iaxsl[fr->callno])
(2425,var = var->next)
(2426,iaxs[fr->callno])
(2427,-1)
(2428,VERBOSE_PREFIX_4)
(2429,IAX_PROVISION)
(2430,sin_port)
(2431,fr)
(2432,iaxs)
(2433,var)
(2434,iaxs)
(2435,fr)
(2436,new_callno)
(2437,"Rejected connect attempt from %s, requested \'%s\' incompatible with our capability \'%s\'.\\n")
(2438,dcx)
(2439,id)
(2440,(peer->lastms < 0)
(2441,!authenticate_request(fr->callno)
(2442,ied0)
(2443,fr->callno)
(2444,smoothing)
(2445,ies.provverpres && ies.serviceident && sin.sin_addr.s_addr)
(2446,if (f.datalen)
(2447,fr)
(2448,"Received VNAK: resending outstanding frames\\n")
(2449,callno)
(2450,&iaxs[fr->callno]->state)
(2451,callno)
(2452,if (!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)
(2453,iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner)
(2454,1)
(2455,IAX_COMMAND_PONG)
(2456,1)
(2457,pos)
(2458,IAX_COMMAND_VNAK)
(2459,f.subclass.integer)
(2460,iaxs[fr->callno])
(2461,ast_debug(1, "For call=%d, set last=%d\\n", fr->callno, fr->ts)
(2462,iaxs[fr->callno]->transferring)
(2463,ied0)
(2464,f.frametype == AST_FRAME_VOICE)
(2465,capability)
(2466,mh->callno)
(2467,"disabled")
(2468,pbx_builtin_setvar_helper(bridged_chan, "BLINDTRANSFER", ast_channel_name(owner)
(2469,iaxdebug)
(2470,"Rejected connect attempt from %s, who was trying to reach \'%s@%s\'\\n")
(2471,fr->callno)
(2472,*varlist)
(2473,fr->callno)
(2474,iaxs)
(2475,f)
(2476,AST_FRAME_IAX)
(2477,fr->callno)
(2478,struct ast_iax2_full_hdr)
(2479,&tmpfmt)
(2480,"Rejected connect attempt from %s, requested/capability \'%s\'/\'%s\' incompatible with our capability \'%s\'.\\n")
(2481,presentation)
(2482,subclass)
(2483,f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_ACK && dcallno == 1)
(2484,buf)
(2485,0)
(2486,buf)
(2487,f.data)
(2488,variablestore->data)
(2489,IAX_CODEC_USER_FIRST)
(2490,encmethods)
(2491,fr->callno)
(2492,f.subclass.integer)
(2493,&ied0)
(2494,fr->callno)
(2495,using_prefs = "disabled")
(2496,var = ies.vars)
(2497,DATASTORE_INHERIT_FOREVER)
(2498,prev = var)
(2499,case IAX_COMMAND_LAGRQ:)
(2500,NULL)
(2501,"Failed to park call \'%s\'\\n")
(2502,if (iaxs[fr->callno]->pingtime <= peer->maxms)
(2503,auth_fail(fr->callno, IAX_COMMAND_REJECT)
(2504,pingied)
(2505,iaxs[fr->callno]->capability)
(2506,1)
(2507,format = 0)
(2508,name)
(2509,peer)
(2510,iaxs)
(2511,if (!ast_test_flag64(&globalflags, IAX_ALLOWFWDOWNLOAD)
(2512,callno)
(2513,ied1)
(2514,sin)
(2515,)
(2516,ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
(2517,fr)
(2518,callno)
(2519,if (prev)
(2520,AST_CAUSE_BUSY)
(2521,fr)
(2522,if (res < thread->buf_size)
(2523,sin)
(2524,if (!ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num)
(2525,)
(2526,rprefs)
(2527,frametype)
(2528,varlist)
(2529,exten)
(2530,iaxs[fr->callno])
(2531,last)
(2532,callno)
(2533,iaxs[fr->callno]->last)
(2534,fr)
(2535,iaxs[fr->callno]->state)
(2536,ast_variables_destroy(ies.vars)
(2537,peer->lastms < 0)
(2538,prev)
(2539,iaxs)
(2540,iaxs)
(2541,peer)
(2542,subclass)
(2543,iseqno)
(2544,ast_verb(3, "Channel \'%s\' unable to transfer\\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner)
(2545,callno)
(2546,iaxs[fr->callno]->owner)
(2547,iaxs)
(2548,fr->iseqno)
(2549,int)
(2550,sin_addr)
(2551,ast_debug(1, "For call=%d, set last=%d\\n", fr->callno, fr->ts)
(2552,fr)
(2553,callno)
(2554,iaxs[fr->callno])
(2555,(peer->lastms < 0)
(2556,frametype)
(2557,iaxs[fr->callno]->transferring = TRANSFER_MEDIAPASS)
(2558,ast_debug(1, "Parking call \'%s\'\\n", ast_channel_name(bridged_chan)
(2559,if (iaxs[fr->callno]->owner)
(2560,ies)
(2561,if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->peerformat, NULL, 1)
(2562,peercallno)
(2563,retries)
(2564,!iaxs[fr->callno])
(2565,fr->callno)
(2566,ies)
(2567,ntohs(fh->dcallno)
(2568,fr->callno)
(2569,)
(2570,3)
(2571,fr->callno)
(2572,ies.called_number)
(2573,data)
(2574,f.subclass.integer != IAX_COMMAND_TXCNT &&\\t\\t/* for attended transfer */\n\\n\\t\\tf.subclass.integer != IAX_COMMAND_TXACC)
(2575,sin.sin_addr)
(2576,iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner)
(2577,f)
(2578,iaxs)
(2579,peer)
(2580,pokeexpire)
(2581,1)
(2582,iaxs[fr->callno]->prefs)
(2583,3)
(2584,)
(2585,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(2586,frame_queue[fr->callno])
(2587,&pref)
(2588,vars)
(2589,fr->ts)
(2590,callno)
(2591,if (iaxs[fr->callno]->rseqno >= iaxs[fr->callno]->oseqno || (fr->iseqno >= iaxs[fr->callno]->rseqno && fr->iseqno < iaxs[fr->callno]->oseqno)
(2592,res)
(2593,1)
(2594,AST_FRAME_IAX)
(2595,iax2_variable_datastore_info)
(2596,if (iaxs[fr->callno]->owner)
(2597,iaxs)
(2598,fh->scallno)
(2599,ast_string_field_set(iaxs[fr->callno], exten, ies.called_number ? ies.called_number : "s")
(2600,fr)
(2601,callno)
(2602,fr->callno)
(2603,iaxs)
(2604,&iax2_variable_datastore_info)
(2605,peer->lastms)
(2606,fr)
(2607,callno)
(2608,peercallno)
(2609,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(2610,callno)
(2611,f.subclass.integer)
(2612,check_dcallno)
(2613,iaxs)
(2614,if (!format)
(2615,if (iaxs[fr->callno] && iaxs[fr->callno]->last < fr->ts)
(2616,iaxs)
(2617,fr)
(2618,)
(2619,iaxs[fr->callno])
(2620,fr)
(2621,!iaxs[fr->callno])
(2622,iaxs[fr->callno])
(2623,IAX_ENCRYPTED)
(2624,callno)
(2625,0)
(2626,ies.serviceident && sin.sin_addr.s_addr)
(2627,sizeof(struct ast_iax2_full_hdr)
(2628,if (f.datalen)
(2629,connected.id.number)
(2630,f.frametype == AST_FRAME_VIDEO)
(2631,if (handle_call_token(fh, &ies, &sin, fd)
(2632,iaxs)
(2633,fh)
(2634,callno)
(2635,iaxs[fr->callno])
(2636,-1)
(2637,ast_debug(1, "Cancelling transmission of packet %d\\n", x)
(2638,f.subclass)
(2639,)
(2640,iaxs)
(2641,iaxs[fr->callno]->reg->regstate)
(2642,(f.subclass.integer != IAX_COMMAND_TXREADY)
(2643,"Packet Decrypt Failed!\\n")
(2644,iaxs[fr->callno]->rseqno)
(2645,&f)
(2646,iaxs)
(2647,capability)
(2648,callno)
(2649,ied1)
(2650,sizeof(tmp2)
(2651,cur)
(2652,iaxs)
(2653,ies.vars)
(2654,fr)
(2655,if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)
(2656,ast_verb(3, "Accepting UNAUTHENTICATED call from %s:\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t"%srequested format = %s,\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t"%srequested prefs = %s,\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t"%sactual format = %s,\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t"%shost prefs = %s,\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t"%spriority = %s\\n",\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tast_inet_ntoa(sin.sin_addr)
(2657,~0x40)
(2658,pref)
(2659,iaxs)
(2660,AST_FRAME_IAX)
(2661,iaxs[fr->callno])
(2662,ast_mutex_unlock(&iaxsl[fr->callno])
(2663,fr->callno)
(2664,fr->callno)
(2665,variablestore->inheritance = DATASTORE_INHERIT_FOREVER)
(2666,iaxs[fr->callno]->peercapability)
(2667,thread)
(2668,retries)
(2669,1)
(2670,callno)
(2671,ies)
(2672,f)
(2673,fr->callno)
(2674,-1)
(2675,callno)
(2676,ied0.pos)
(2677,return socket_process_meta(res, meta, &sin, fd, fr)
(2678,context)
(2679,iaxs[fr->callno])
(2680,fr)
(2681,f.subclass)
(2682,vh)
(2683,codec_prefs)
(2684,iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
(2685,vars)
(2686,iaxs[fr->callno]->pingtime =  calc_timestamp(iaxs[fr->callno], 0, &f)
(2687,ast_mutex_unlock(&iaxsl[fr->callno])
(2688,callno)
(2689,IAX_COMMAND_TXMEDIA)
(2690,LOG_NOTICE)
(2691,native)
(2692,fr)
(2693,NULL)
(2694,transferring)
(2695,)
(2696,&ies)
(2697,fr->callno)
(2698,(peer->historicms > 0)
(2699,f.subclass.integer)
(2700,fr->callno)
(2701,callno)
(2702,)
(2703,f.len)
(2704,iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
(2705,ast_test_flag64(iaxs[fr->callno], IAX_ENCRYPTED)
(2706,IAX_COMMAND_TXREL)
(2707,integer)
(2708,format)
(2709,iaxs[fr->callno]->owner)
(2710,if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(2711,case IAX_COMMAND_ACK:)
(2712,iaxs[fr->callno])
(2713,AST_STATE_RING)
(2714,fr)
(2715,fr->callno)
(2716,IAX_IE_CALLNO)
(2717,"Accepting DIAL from %s, formats = %s\\n")
(2718,fr)
(2719,AST_FORMAT_SLINEAR)
(2720,iaxs)
(2721,ast_channel_nativeformats(iaxs[fr->callno]->owner)
(2722,callno)
(2723,"Simulating frame ts resync, was %u now %u\\n")
(2724,IAX_CODEC_NOCAP)
(2725,ast_debug(1, "I can haz IAX vars? w00t\\n")
(2726,sin.sin_addr)
(2727,0)
(2728,fr->callno)
(2729,)
(2730,username)
(2731,fr)
(2732,fr->callno)
(2733,mallocd)
(2734,iaxs[fr->callno])
(2735,ies)
(2736,fr->oseqno)
(2737,fr->callno)
(2738,iaxs[fr->callno])
(2739,ast_variables_destroy(ies.vars)
(2740,pos)
(2741,)
(2742,native)
(2743,subclass)
(2744,f.subclass)
(2745,iaxs)
(2746,callno)
(2747,sizeof(tmp2)
(2748,iaxs[fr->callno])
(2749,iaxs[fr->callno]->state)
(2750,"Unknown IAX command %d on %d/%d\\n")
(2751,ast_log(LOG_NOTICE, "Registration of \'%s\' rejected: \'%s\' from: \'%s\'\\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>", ast_inet_ntoa(sin.sin_addr)
(2752,ied0)
(2753,fr->callno)
(2754,fr)
(2755,)
(2756,cause_code)
(2757,f.subclass)
(2758,!iaxs[fr->callno])
(2759,)
(2760,iaxs[fr->callno])
(2761,ied0)
(2762,connected)
(2763,fr)
(2764,ied0)
(2765,fr)
(2766,iaxs[fr->callno])
(2767,f.subclass.integer)
(2768,0)
(2769,"Rejected connect attempt from %s, requested/capability \'%s\'/\'%s\' incompatible with our capability \'%s\'.\\n")
(2770,if (authdebug)
(2771,iaxs[fr->callno]->pingtime)
(2772,fr->callno)
(2773,iaxs[fr->callno])
(2774,iaxs[fr->callno]->last & 0xFFFF8000L)
(2775,callno)
(2776,f.subclass)
(2777,0)
(2778,TRANSFER_READY)
(2779,memset(&pref, 0, sizeof(pref)
(2780,sin)
(2781,subclass)
(2782,fh->type == AST_FRAME_IAX)
(2783,!iaxs[fr->callno])
(2784,f.subclass)
(2785,iaxsl)
(2786,&ies)
(2787,ast_debug(1, "Neat, somebody took away the channel at a magical time but i found it!\\n")
(2788,f)
(2789,-1)
(2790,tmp)
(2791,iax2_allow_new(f.frametype, f.subclass.integer, 1)
(2792,f.frametype)
(2793,iaxs[fr->callno])
(2794,iaxs[fr->callno])
(2795,ies)
(2796,!iaxs[fr->callno])
(2797,fr)
(2798,iaxs[fr->callno])
(2799,pos)
(2800,1)
(2801,ast_async_goto(bridged_chan, context, ies.called_number, 1)
(2802,sin.sin_family = AF_INET)
(2803,f.subclass.integer)
(2804,-1)
(2805,res)
(2806,send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
(2807,host_pref_buf)
(2808,ies.vars)
(2809,peercallno)
(2810,sizeof(tmp)
(2811,0)
(2812,calc_timestamp(iaxs[fr->callno], 0, &f)
(2813,exists)
(2814,f.subclass.format)
(2815,peer)
(2816,callno)
(2817,f.frametype == AST_FRAME_IAX &&\n\\n\\t\\t\\t\\t\\t\\t\\t\\t(f.subclass == IAX_COMMAND_NEW ||\n\\n\\t\\t\\t\\t\\t\\t\\t\\t f.subclass == IAX_COMMAND_AUTHREQ ||\n\\n\\t\\t\\t\\t\\t\\t\\t\\t f.subclass == IAX_COMMAND_ACCEPT ||\n\\n\\t\\t\\t\\t\\t\\t\\t\\t f.subclass == IAX_COMMAND_REJECT)
(2818,callno)
(2819,fr->callno)
(2820,subclass)
(2821,iaxs)
(2822,iaxs)
(2823,ast_channel_caller(iaxs[fr->callno]->owner)
(2824,if (decrypt_frame(fr->callno, fh, &f, &res)
(2825,fh->iseqno + 1)
(2826,id)
(2827,caller_pref_buf)
(2828,fr->callno)
(2829,ast_free(prev)
(2830,iseqno)
(2831,sizeof(*fh)
(2832,call_to_destroy)
(2833,f)
(2834,peer->historicms > peer->maxms)
(2835,fr->callno)
(2836,ied0)
(2837,uncompress_subclass(fh->csub)
(2838,ast_log(LOG_WARNING, \n\\n\\t\\t\\t\\t\\t\\t"I don\'t know how to authenticate %s to %s\\n", \n\\n\\t\\t\\t\\t\\t\\ties.username ? ies.username : "<unknown>", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr)
(2839,fr->callno)
(2840,iaxs[fr->callno])
(2841,fr)
(2842,ies)
(2843,fr->callno)
(2844,f.subclass.integer)
(2845,pingtime)
(2846,callno)
(2847,iaxs[fr->callno]->capability)
(2848,tmp3)
(2849,buf)
(2850,mh)
(2851,f.frametype == AST_FRAME_VIDEO)
(2852,ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request \'%s@%s\' does not exist\\n", ast_inet_ntoa(sin.sin_addr)
(2853,iaxs)
(2854,iaxs[fr->callno]->peercapability)
(2855,callno)
(2856,iaxs)
(2857,callno)
(2858,ied0)
(2859,callno)
(2860,iaxs[fr->callno])
(2861,subclass)
(2862,if ((unsigned char)
(2863,fr->callno)
(2864,callno)
(2865,send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK,\n\\n\\t\\t\\t\\t\\t\\t       fr->ts, NULL, 0, fr->iseqno)
(2866,frametype)
(2867,format)
(2868,dcallno)
(2869,return 1;)
(2870,callno)
(2871,thread->buf[res - 1] = \'\\0\')
(2872,ied0)
(2873,peer->maxms)
(2874,ast_log(LOG_NOTICE, "Peer \'%s\' is now TOO LAGGED (%d ms)
(2875,iaxs[fr->callno])
(2876,if (fr->callno > 0)
(2877,callno)
(2878,subclass)
(2879,name)
(2880,IAX_COMMAND_TXACC)
(2881,tmpfmt)
(2882,sin.sin_addr.s_addr)
(2883,ast_log(LOG_WARNING, "Registration failure\\n")
(2884,id)
(2885,fr)
(2886,iaxs)
(2887,varlist)
(2888,"ChannelType: IAX2\\r\\nUsername: %s\\r\\nStatus: Rejected\\r\\nCause: %s\\r\\n")
(2889,iaxs[fr->callno])
(2890,0)
(2891,tmp1)
(2892,AST_CAUSE_BEARERCAPABILITY_NOTAVAIL)
(2893,f.frametype)
(2894,cause_code->ast_cause)
(2895,fr)
(2896,IAX_COMMAND_UNSUPPORT)
(2897,callno)
(2898,peer = iaxs[fr->callno]->peerpoke)
(2899,iaxs[fr->callno])
(2900,callno)
(2901,fr)
(2902,owner)
(2903,fr)
(2904,f.subclass)
(2905,pos)
(2906,ied0.pos)
(2907,fr->callno)
(2908,0)
(2909,iaxs)
(2910,if (f.frametype == AST_FRAME_VIDEO)
(2911,iaxs)
(2912,fr->callno)
(2913,iosin)
(2914,ied1.pos)
(2915,ast_set_flag64(iaxs[iaxs[fr->callno]->bridgecallno], IAX_ALREADYGONE)
(2916,fr)
(2917,IAX_COMMAND_TXACC)
(2918,case IAX_COMMAND_PONG:)
(2919,break;)
(2920,f)
(2921,fr)
(2922,iseqno)
(2923,if (variablestore)
(2924,f)
(2925,fr->callno)
(2926,&ies)
(2927,0)
(2928,iaxs[fr->callno]->rprefs)
(2929,iaxs[fr->callno])
(2930,fr)
(2931,fh)
(2932,host_pref_buf)
(2933,iaxs)
(2934,&ied0)
(2935,newvar)
(2936,iaxs)
(2937,fr->callno)
(2938,datalen)
(2939,)
(2940,0)
(2941,iaxs)
(2942,fr->callno)
(2943,iaxs[fr->callno])
(2944,sin_addr)
(2945,iaxs)
(2946,IAX_COMMAND_TXACC)
(2947,LOG_WARNING)
(2948,pingied)
(2949,iaxs)
(2950,ies.cause)
(2951,fr->callno)
(2952,send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, NULL, 0, -1)
(2953,fr->iseqno)
(2954,fr->callno)
(2955,tmp1)
(2956,id)
(2957,*varlist)
(2958,maxms)
(2959,NULL)
(2960,NULL)
(2961,(f.subclass.integer != IAX_COMMAND_ACK)
(2962,f.subclass.format)
(2963,ies.called_number)
(2964,iaxs[fr->callno])
(2965,&iaxs[fr->callno]->rprefs)
(2966,dcallno)
(2967,fr->callno)
(2968,"caller")
(2969,fr->callno)
(2970,"PeerStatus")
(2971,iaxs)
(2972,new_peercallno)
(2973,cause_code->chan_name)
(2974,iaxs[fr->callno]->transferring = TRANSFER_MREADY)
(2975,pref)
(2976,historicms)
(2977,fr)
(2978,iaxs[fr->callno]->transferring)
(2979,-1)
(2980,fr)
(2981,f.frametype != AST_FRAME_IAX)
(2982,ast_format_from_old_bitfield(&f.subclass.format, (uncompress_subclass(fh->csub & ~0x40)
(2983,owner)
(2984,callno)
(2985,(char *)
(2986,iaxs)
(2987,name)
(2988,iaxs)
(2989,if (iaxs[fr->callno]->bridgecallno)
(2990,var)
(2991,callno)
(2992,fd)
(2993,f)
(2994,ast_parking_ext_valid(ies.called_number, owner, context)
(2995,break;)
(2996,presentation)
(2997,f.subclass)
(2998,iaxs[fr->callno])
(2999,peer->pokeexpire)
(3000,callno)
(3001,peer)
(3002,iaxs)
(3003,context)
(3004,if (!fr->callno)
(3005,dpcache)
(3006,fr)
(3007,ied0.pos)
(3008,iaxs[fr->callno])
(3009,fr)
(3010,case IAX_COMMAND_REGACK:)
(3011,callno)
(3012,-1)
(3013,)
(3014,f)
(3015,owner)
(3016,if (variablestore && varlist)
(3017,iaxs[fr->callno]->peerformat)
(3018,iaxsl)
(3019,fr->callno)
(3020,callno)
(3021,prev)
(3022,ied1)
(3023,if (!iaxs[fr->callno])
(3024,owner)
(3025,!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)
(3026,iaxs[fr->callno])
(3027,callno)
(3028,fr->callno)
(3029,subclass)
(3030,iseqno)
(3031,fr)
(3032,(iaxs[fr->callno]->transferring == TRANSFER_BEGIN)
(3033,&iaxs[fr->callno]->state)
(3034,iaxs)
(3035,)
(3036,c)
(3037,callno)
(3038,cause_code)
(3039,variablestore)
(3040,ast_mutex_unlock(&iaxsl[fr->callno])
(3041,iaxs[fr->callno]->first_iax_message = f.subclass.integer)
(3042,peer)
(3043,iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL)
(3044,if (!iaxs[fr->callno]->owner)
(3045,fr)
(3046,tmp1)
(3047,integer)
(3048,iaxs)
(3049,f.datalen < 0)
(3050,callno)
(3051,iaxs[fr->callno])
(3052,bridgecallno)
(3053,goto immediatedial;)
(3054,oseqno)
(3055,fr)
(3056,0)
(3057,callno)
(3058,)
(3059,fr)
(3060,call_to_destroy)
(3061,IAX_COMMAND_INVAL)
(3062,ies.provverpres)
(3063,iaxs[fr->callno])
(3064,connected)
(3065,fr)
(3066,AST_CAUSE_BEARERCAPABILITY_NOTAVAIL)
(3067,IAX_FLAG_FULL)
(3068,fr)
(3069,fr->callno)
(3070,fr)
(3071,iaxs)
(3072,ies)
(3073,callno)
(3074,LOG_ERROR)
(3075,ast_clear_flag64(iaxs[fr->callno], IAX_QUELCH)
(3076,iseqno)
(3077,iaxs[fr->callno])
(3078,iaxs[fr->callno])
(3079,AST_FRAME_IAX)
(3080,capability)
(3081,iaxs)
(3082,new_peercallno = (unsigned short)
(3083,fr->callno)
(3084,iaxs[fr->callno])
(3085,iax2_send(iaxs[fr->callno], &fr->af, fr->ts, -1, 0, 0, 0)
(3086,f.subclass)
(3087,f.datalen)
(3088,*varlist)
(3089,fh->csub)
(3090,f)
(3091,AST_CAUSE_CONGESTION)
(3092,0)
(3093,return 1;)
(3094,iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
(3095,iaxsl[fr->callno])
(3096,regstate)
(3097,sizeof(tmp3)
(3098,f.frametype == AST_FRAME_IAX)
(3099,peerformat)
(3100,sin.sin_addr)
(3101,(f.frametype != AST_FRAME_IAX)
(3102,dcallno)
(3103,ast_free(varlist)
(3104,callno)
(3105,IAX_STATE_STARTED | IAX_STATE_TBD)
(3106,callno)
(3107,if (prev)
(3108,host_pref_buf)
(3109,state)
(3110,iaxsl[fr->callno])
(3111,ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE)
(3112,new_callno = make_trunk(fr->callno, 1)
(3113,variablestore)
(3114,f.subclass.integer != IAX_COMMAND_TXCNT)
(3115,LOG_ERROR)
(3116,AST_CAUSE_BEARERCAPABILITY_NOTAVAIL)
(3117,AST_STATE_RING)
(3118,ts)
(3119,IAX_IE_CAUSE)
(3120,ast_debug(1, "Peer %s: got pong, lastms %d, historicms %d, maxms %d\\n", peer->name, peer->lastms, peer->historicms, peer->maxms)
(3121,fr)
(3122,prefs)
(3123,ast_inet_ntoa(sin.sin_addr)
(3124,fr)
(3125,ies.format)
(3126,iaxs[fr->callno])
(3127,ast_datastore_free(variablestore)
(3128,fr)
(3129,ast_format_from_old_bitfield(&f.subclass.format, iaxs[fr->callno]->videoformat)
(3130,iaxs[fr->callno]->state)
(3131,ntohs(fh->scallno)
(3132,empty)
(3133,ied0)
(3134,iaxs[fr->callno])
(3135,iaxs[iaxs[fr->callno]->bridgecallno])
(3136,ast_set_flag64(iaxs[fr->callno], IAX_QUELCH)
(3137,f.frametype)
(3138,fr)
(3139,iaxs)
(3140,iaxs[iaxs[fr->callno]->bridgecallno]->transferring = 0)
(3141,iaxs)
(3142,f.data)
(3143,host_pref_buf)
(3144,callno)
(3145,AST_SCHED_DEL(sched, iaxs[fr->callno]->initid)
(3146,context)
(3147,f.subclass)
(3148,VERBOSE_PREFIX_4)
(3149,variablestore)
(3150,0)
(3151,c)
(3152,fr->callno)
(3153,fr->callno)
(3154,1)
(3155,iseqno)
(3156,ied0)
(3157,if ((f.frametype == AST_FRAME_VOICE)
(3158,f.subclass.integer != IAX_COMMAND_ACK)
(3159,fr->callno)
(3160,iaxs)
(3161,ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\\n")
(3162,fr)
(3163,!authenticate_request(fr->callno)
(3164,host_pref_buf)
(3165,iaxs)
(3166,format)
(3167,ast_log(LOG_NOTICE, "Peer \'%s\' is now REACHABLE! Time: %d\\n", peer->name, iaxs[fr->callno]->pingtime)
(3168,&f.subclass.format)
(3169,ntohs(vh->callno)
(3170,fr)
(3171,-1)
(3172,iaxs[fr->callno])
(3173,IAX_COMMAND_TXREL)
(3174,&ied0)
(3175,)
(3176,if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
(3177,integer)
(3178,AST_FRAME_IAX)
(3179,iaxs[fr->callno])
(3180,x = iaxs[fr->callno]->oseqno)
(3181,&iaxs[fr->callno]->state)
(3182,ast_format_cap_dup(ast_channel_nativeformats(iaxs[fr->callno]->owner)
(3183,)
(3184,fr->callno)
(3185,f.subclass.integer != IAX_COMMAND_TXACC)
(3186,0)
(3187,mh->callno)
(3188,!ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
(3189,calling_pres)
(3190,fr->callno)
(3191,ies)
(3192,f.subclass.integer != IAX_COMMAND_LAGRP)
(3193,(fh->csub >> 6)
(3194,1)
(3195,iaxs)
(3196,subclass)
(3197,if (register_verify(fr->callno, &sin, &ies)
(3198,0)
(3199,iaxs[fr->callno])
(3200,NULL)
(3201,0)
(3202,iaxs[fr->callno])
(3203,fr)
(3204,format)
(3205,integer)
(3206,f)
(3207,buf)
(3208,ied0)
(3209,fr)
(3210,owner)
(3211,fr->callno)
(3212,iaxs[fr->callno]->exten)
(3213,iaxs[fr->callno]->bridgecallno)
(3214,0)
(3215,fr)
(3216,f.subclass.integer)
(3217,iaxs[fr->callno])
(3218,&ied0)
(3219,f.subclass)
(3220,vnak_retransmit(fr->callno, fr->iseqno)
(3221,ntohl(fh->ts)
(3222,iaxsl[fr->callno])
(3223,1)
(3224,data_size++)
(3225,iaxs[fr->callno])
(3226,-1)
(3227,ast_log(LOG_WARNING, "Rejecting packet from \'%s.%d\' that is flagged as a full frame but is too short\\n", ast_inet_ntoa(sin.sin_addr)
(3228,callno)
(3229,iaxs[fr->callno])
(3230,f.subclass.integer)
(3231,1)
(3232,decrypted = 0)
(3233,f.datalen = res - sizeof(*vh)
(3234,fh)
(3235,AST_FRAME_VOICE)
(3236,iaxs[fr->callno]->state)
(3237,subclass)
(3238,thread->buf)
(3239,fr->callno)
(3240,iaxs)
(3241,!iaxs[fr->callno])
(3242,AST_CAUSE_BEARERCAPABILITY_NOTAVAIL)
(3243,iaxs[fr->callno])
(3244,iaxs)
(3245,)
(3246,"No authority found")
(3247,iaxs[fr->callno])
(3248,iaxs[fr->callno]->transferring = TRANSFER_READY)
(3249,peer)
(3250,fr->callno)
(3251,pref = iaxs[fr->callno]->prefs)
(3252,f.subclass.integer != IAX_COMMAND_TXCNT)
(3253,callno)
(3254,ts)
(3255,callno)
(3256,f)
(3257,iaxs)
(3258,sizeof(*mh)
(3259,fr->oseqno = fh->oseqno)
(3260,fr)
(3261,mh)
(3262,rseqno)
(3263,pingied.buf)
(3264,if (peer->pokeexpire > -1)
(3265,f.subclass.integer)
(3266,iaxs)
(3267,connected.id.number.str)
(3268,tmpfmt)
(3269,state)
(3270,ast_string_field_set(iaxs[fr->callno], cid_name, connected.id.name.str)
(3271,callno)
(3272,f.frametype == AST_FRAME_IAX)
(3273,if (ast_async_goto(bridged_chan, context, ies.called_number, 1)
(3274,fr)
(3275,iaxs)
(3276,callno)
(3277,fr)
(3278,varlist)
(3279,fr->callno)
(3280,iaxs[fr->callno]->owner)
(3281,1)
(3282,iaxs[fr->callno])
(3283,f)
(3284,historicms)
(3285,callno)
(3286,fr->callno)
(3287,res)
(3288,fr->callno)
(3289,connected)
(3290,sin)
(3291,ies)
(3292,iaxs[fr->callno]->calling_pres = ast_party_id_presentation(&connected.id)
(3293,peer)
(3294,iaxsl[call_to_destroy])
(3295,if (ies.musiconhold)
(3296,iaxs)
(3297,1)
(3298,tmp1)
(3299,fr->callno)
(3300,sin)
(3301,LOG_WARNING)
(3302,return 1;)
(3303,varlist = ast_calloc(1, sizeof(*varlist)
(3304,f.frametype == AST_FRAME_IAX)
(3305,thread->buf[res - 1])
(3306,fr->callno)
(3307,-1)
(3308,mh)
(3309,if (!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)
(3310,host_pref_buf)
(3311,-1)
(3312,exten)
(3313,fr->iseqno)
(3314,break;)
(3315,state)
(3316,f)
(3317,data_size - sizeof(*cause_code)
(3318,LOG_NOTICE)
(3319,fr->callno)
(3320,callno)
(3321,&iaxsl[fr->callno])
(3322,pref)
(3323,fr)
(3324,iaxs)
(3325,AST_LIST_INSERT_TAIL(varlist, newvar, entries)
(3326,iaxs[fr->callno]->state)
(3327,fr->callno)
(3328,fh)
(3329,ies.provverpres)
(3330,fr->callno)
(3331,vars)
(3332,fr->callno)
(3333,subclass)
(3334,fr)
(3335,case IAX_COMMAND_DIAL:)
(3336,iaxsl)
(3337,iaxs[fr->callno])
(3338,fr->callno)
(3339,f.subclass)
(3340,iaxs[fr->callno]->iseqno)
(3341,ast_var_assign(var->name, var->value)
(3342,fr->callno)
(3343,fr->callno)
(3344,fr)
(3345,iaxs)
(3346,iaxs[fr->callno]->peercallno)
(3347,sin)
(3348,callno)
(3349,IAX_COMMAND_INVAL)
(3350,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(3351,initid)
(3352,iaxs[fr->callno]->owner)
(3353,)
(3354,connected.id)
(3355,ts)
(3356,break;)
(3357,ies.username)
(3358,buf)
(3359,fr)
(3360,ts)
(3361,ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0)
(3362,iaxs[fr->callno]->inkeys)
(3363,sin)
(3364,break;)
(3365,fr->callno)
(3366,variablestore)
(3367,f.subclass.integer != IAX_COMMAND_INVAL)
(3368,1)
(3369,if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)
(3370,fr->callno)
(3371,sin_addr)
(3372,iaxs[fr->callno]->owner)
(3373,ied1)
(3374,if (iax_parse_ies(&ies, thread->buf + sizeof(struct ast_iax2_full_hdr)
(3375,)
(3376,fr->callno)
(3377,fd)
(3378,)
(3379,fr->callno)
(3380,AST_FRAME_VOICE)
(3381,f.offset)
(3382,f.frametype == AST_FRAME_VIDEO)
(3383,iaxs[fr->callno]->owner)
(3384,callno)
(3385,fr->callno)
(3386,iaxs[fr->callno]->exten)
(3387,fr)
(3388,ast_mutex_unlock(&iaxsl[fr->callno])
(3389,fr)
(3390,iaxs[fr->callno])
(3391,iaxs[fr->callno])
(3392,iaxs)
(3393,var)
(3394,tmp1)
(3395,if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)
(3396,fr)
(3397,iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno)
(3398,&sin)
(3399,f.subclass.integer)
(3400,if (iaxs[fr->callno]->bridgecallno)
(3401,fr->callno)
(3402,break;)
(3403,iaxs)
(3404,new_peercallno)
(3405,strcpy(caller_pref_buf,"disabled")
(3406,ast_clear_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD)
(3407,sizeof(*cause_code)
(3408,if (ast_test_flag64(iaxs[fr->callno], IAX_IMMEDIATE)
(3409,fr->callno)
(3410,fr->callno)
(3411,return 1;)
(3412,connected.id.number.presentation)
(3413,)
(3414,fr->callno)
(3415,iaxs)
(3416,res - 1)
(3417,((f.subclass.integer != IAX_COMMAND_ACK)
(3418,bridged_chan)
(3419,callno)
(3420,fr->callno)
(3421,!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(3422,fr)
(3423,iax2_getformatname_multiple(tmp2, sizeof(tmp2)
(3424,callno)
(3425,TRANSFER_MREADY)
(3426,ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD)
(3427,AST_FRAME_IAX)
(3428,ntohs(vh->ts)
(3429,)
(3430,fr->callno)
(3431,ies)
(3432,ied0)
(3433,fr->callno)
(3434,ast_datastore_free(variablestore)
(3435,cid_num)
(3436,struct ast_iax2_mini_hdr *)
(3437,integer)
(3438,dcallno)
(3439,integer)
(3440,iaxs[fr->callno])
(3441,ies)
(3442,fh->scallno)
(3443,callno)
(3444,callno)
(3445,1)
(3446,fr)
(3447,iseqno)
(3448,var)
(3449,fr)
(3450,iaxs)
(3451,)
(3452,ied1)
(3453,fr)
(3454,fr)
(3455,fr)
(3456,fr->callno)
(3457,fr->callno)
(3458,iaxs[fr->callno])
(3459,pos)
(3460,ies)
(3461,subclass)
(3462,iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format)
(3463,fr->callno)
(3464,decrypted = 1)
(3465,varlist = ast_calloc(1, sizeof(*varlist)
(3466,iaxs)
(3467,f)
(3468,x)
(3469,iaxsl)
(3470,f.subclass.format.id)
(3471,callno)
(3472,cur->transfer)
(3473,&pref)
(3474,IAX_IE_CAUSECODE)
(3475,fr)
(3476,c)
(3477,if (ast_channel_readformat(iaxs[fr->callno]->owner)
(3478,iaxs)
(3479,iaxs)
(3480,iax2_destroy(fr->callno)
(3481,exists)
(3482,f.frametype)
(3483,frametype)
(3484,f)
(3485,-1)
(3486,fr->callno)
(3487,callno)
(3488,f.src)
(3489,fr->callno)
(3490,cause_code)
(3491,)
(3492,strcpy(host_pref_buf,"disabled")
(3493,fr->callno)
(3494,0)
(3495,iaxs)
(3496,ies.vars)
(3497,iaxs)
(3498,f)
(3499,fr->cacheable = ((f.frametype == AST_FRAME_VOICE)
(3500,fr->callno)
(3501,fr)
(3502,(unsigned short)
(3503,ast_channel_readformat(iaxs[fr->callno]->owner)
(3504,iaxs[fr->callno]->capability)
(3505,1)
(3506,iax_pvt_callid_new(fr->callno)
(3507,bridgecallno)
(3508,iaxs[fr->callno])
(3509,variablestore)
(3510,iaxs[fr->callno])
(3511,x != iaxs[fr->callno]->oseqno)
(3512,iaxs[fr->callno]->capability)
(3513,callno)
(3514,f)
(3515,AST_FRAME_IAX)
(3516,LOG_NOTICE)
(3517,EVENT_FLAG_SYSTEM)
(3518,if (res >= sizeof(*fh)
(3519,callno)
(3520,ast_channel_readformat(iaxs[fr->callno]->owner)
(3521,f.mallocd = 0)
(3522,iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno)
(3523,callno)
(3524,break;)
(3525,peer->historicms)
(3526,peer->smoothing)
(3527,!format)
(3528,iaxs[fr->callno])
(3529,fr->callno)
(3530,fr->ts = (iaxs[fr->callno]->last & 0xFFFF8000L)
(3531,peerformat)
(3532,iaxs[fr->callno]->capability)
(3533,peer->maxms)
(3534,!iaxs[fr->callno])
(3535,set_hangup_source_and_cause(fr->callno, ies.causecode)
(3536,IAX_STATE_TBD)
(3537,ast_test_flag64(iaxs[fr->callno], IAX_IMMEDIATE)
(3538,integer)
(3539,(iaxs[fr->callno]->pingtime + peer->historicms)
(3540,sizeof(*varlist)
(3541,called_number)
(3542,complete_dpreply(iaxs[fr->callno], &ies)
(3543,fr->callno)
(3544,fr)
(3545,)
(3546,IAX_COMMAND_ACK)
(3547,"IAX subclass %d received\\n")
(3548,break;)
(3549,f.subclass.integer == AST_CONTROL_CONGESTION)
(3550,fr->callno)
(3551,callno)
(3552,fr)
(3553,iaxs[fr->callno])
(3554,ts)
(3555,iaxs)
(3556,"Datalen < 0?\\n")
(3557,sizeof(tmp)
(3558,owner)
(3559,if (iaxs[fr->callno]->owner)
(3560,first_iax_message)
(3561,cur)
(3562,tmpfmt)
(3563,state)
(3564,iaxs[fr->callno])
(3565,fr)
(3566,iaxs[fr->callno])
(3567,fr)
(3568,if (ies.codec_prefs)
(3569,tmp3)
(3570,iaxs[fr->callno])
(3571,if ((c = iaxs[fr->callno]->owner)
(3572,IAX_COMMAND_ACK)
(3573,IAX_STATE_AUTHENTICATED)
(3574,calltoken)
(3575,fr->callno)
(3576,callno)
(3577,)
(3578,0)
(3579,vars)
(3580,1)
(3581,)
(3582,ies.calltokendata)
(3583,fr->ts = ntohl(fh->ts)
(3584,ied0)
(3585,iaxs)
(3586,fr)
(3587,AST_FRAME_IAX)
(3588,dcallno)
(3589,newvar)
(3590,owner)
(3591,iax_ie_append_int(&ied1, IAX_IE_FORMAT, format)
(3592,iaxs)
(3593,varlist)
(3594,peer->maxms)
(3595,ies)
(3596,)
(3597,fr)
(3598,callno)
(3599,"mine")
(3600,pos)
(3601,)
(3602,peerpoke)
(3603,&res)
(3604,called_number)
(3605,ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",\n\\n\\t\\t\\t\\t\\t\\t\\t"Status: Off\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t"Channel: %s\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t"Uniqueid: %s\\r\\n",\n\\n\\t\\t\\t\\t\\t\\t\\tast_channel_name(iaxs[fr->callno]->owner)
(3606,if (test_resync)
(3607,callno)
(3608,var->value)
(3609,ast_callid_unref(mount_callid)
(3610,ies)
(3611,)
(3612,(f.subclass.integer != IAX_COMMAND_ACK)
(3613,ies.vars)
(3614,callno)
(3615,if (!format)
(3616,ast_channel_caller(iaxs[fr->callno]->owner)
(3617,iaxs[fr->callno])
(3618,fr->callno)
(3619,vh)
(3620,iaxs)
(3621,&iaxsl[fr->callno])
(3622,ied0)
(3623,*vh)
(3624,iaxs[fr->callno]->last_iax_message)
(3625,bridgecallno)
(3626,&ied1)
(3627,fr)
(3628,afdatalen)
(3629,transferring)
(3630,iaxs[fr->callno])
(3631,sin_addr)
(3632,iaxs[fr->callno]->bridgecallno)
(3633,ied1.pos)
(3634,fr)
(3635,sin_addr)
(3636,iaxs[fr->callno]->transferring == TRANSFER_BEGIN)
(3637,callno)
(3638,iax_ie_append_byte(&ied0, IAX_IE_IAX_UNKNOWN, f.subclass.integer)
(3639,send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1)
(3640,"Memory allocation error while processing IAX2 variables\\n")
(3641,dpcache)
(3642,ied0)
(3643,"")
(3644,IAX_COMMAND_ACK)
(3645,sin.sin_addr)
(3646,AST_FRAME_IAX)
(3647,f.subclass.integer)
(3648,iaxs[fr->callno]->inkeys)
(3649,iaxs)
(3650,secret)
(3651,format)
(3652,connected.id.number.presentation)
(3653,integer)
(3654,var->next)
(3655,f)
(3656,iaxs[fr->callno]->owner)
(3657,fr->callno)
(3658,calc_timestamp(iaxs[fr->callno], 0, &f)
(3659,fr)
(3660,"")
(3661,iaxs)
(3662,iaxs)
(3663,f.subclass.integer != IAX_COMMAND_FWDOWNL)
(3664,\'\\0\')
(3665,fr)
(3666,fr)
(3667,ied0.buf)
(3668,frametype)
(3669,fr->callno)
(3670,ast_variables_destroy(ies.vars)
(3671,if (x == cur->oseqno)
(3672,iaxs[fr->callno])
(3673,)
(3674,iaxs[fr->callno]->rseqno)
(3675,"Call on %s is already up, can\'t start on it\\n")
(3676,&iaxs[fr->callno]->rprefs)
(3677,iax2_getformatname_multiple(tmp1, sizeof(tmp1)
(3678,sin)
(3679,buf)
(3680,&iaxs[fr->callno]->rprefs)
(3681,fr->callno)
(3682,fh)
(3683,peer)
(3684,NULL)
(3685,f)
(3686,ast_variables_destroy(ies.vars)
(3687,1)
(3688,(f.frametype == AST_FRAME_VIDEO)
(3689,iaxs[fr->callno]->encmethods = 0)
(3690,iax2_destroy(fr->callno)
(3691,sin)
(3692,var)
(3693,iaxs[fr->callno])
(3694,AST_LIST_HEAD_INIT(varlist)
(3695,ast_inet_ntoa(sin.sin_addr)
(3696,sin)
(3697,iaxs)
(3698,iaxs[fr->callno])
(3699,thread->buf)
(3700,callno)
(3701,iaxs)
(3702,authdebug)
(3703,f.frametype)
(3704,fr)
(3705,!ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->chosenformat, NULL,\n\\n\\t\\t\\t\\t\\t\\t  ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED)
(3706,historicms)
(3707,case IAX_COMMAND_REGAUTH:)
(3708,thread)
(3709,vars)
(3710,ntohs(fh->scallno)
(3711,fr)
(3712,iaxs)
(3713,fh)
(3714,duped_fr)
(3715,res < sizeof(*fh)
(3716,connected.id.name)
(3717,owner)
(3718,iaxs[fr->callno]->owner)
(3719,f.subclass)
(3720,f.frametype == AST_FRAME_VOICE)
(3721,fr->iseqno)
(3722,var)
(3723,IAX_IE_CAUSECODE)
(3724,callno)
(3725,ast_strdupa(iaxs[fr->callno]->exten)
(3726,pos)
(3727,iaxs[fr->callno]->lag = ts - fr->ts)
(3728,3)
(3729,var)
(3730,fr->callno)
(3731,IAX_STATE_TBD)
(3732,vars)
(3733,callno)
(3734,fr)
(3735,iseqno)
(3736,ies)
(3737,1)
(3738,registry_authrequest(fr->callno)
(3739,cur)
(3740,strcpy(host_pref_buf,"disabled")
(3741,"")
(3742,0)
(3743,if (!iaxs[fr->callno])
(3744,provver)
(3745,callno)
(3746,"Rejected dial attempt from %s, request \'%s@%s\' does not exist\\n")
(3747,if (ast_test_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART)
(3748,fr)
(3749,prev)
(3750,fr)
(3751,connected)
(3752,fr)
(3753,fr->callno)
(3754,fr)
(3755,fr->callno)
(3756,callno)
(3757,f.frametype != AST_FRAME_IAX)
(3758,ast_calloc(1, sizeof(*varlist)
(3759,oseqno)
(3760,mount_callid)
(3761,caller_pref_buf)
(3762,fr)
(3763,ies)
(3764,f.subclass)
(3765,fr)
(3766,fr)
(3767,iaxs)
(3768,f)
(3769,fr)
(3770,iaxs[fr->callno])
(3771,iaxs[fr->callno])
(3772,iaxs)
(3773,calling_pres)
(3774,callno)
(3775,ast_format_to_old_bitfield(&f.subclass.format)
(3776,)
(3777,fr->callno)
(3778,if (ast_test_flag64(iaxs[fr->callno], IAX_ENCRYPTED)
(3779,ast_copy_string(cause_code->chan_name, ast_channel_name(iaxs[fr->callno]->owner)
(3780,owner)
(3781,IAX_COMMAND_TXREL)
(3782,if (!authenticate_request(fr->callno)
(3783,)
(3784,integer)
(3785,connected)
(3786,fh->dcallno)
(3787,)
(3788,fd)
(3789,csub)
(3790,iaxs[fr->callno]->bridgecallno)
(3791,fr->callno)
(3792,iaxs[iaxs[fr->callno]->bridgecallno])
(3793,fr->callno)
(3794,iax2_getformatname_multiple(tmp1, sizeof(tmp1)
(3795,connected.id.name.valid)
(3796,iaxs[fr->callno]->transferring = TRANSFER_MEDIA)
(3797,callno)
(3798,authdebug)
(3799,ast_variables_destroy(ies.vars)
(3800,decrypted = 1)
(3801,callno)
(3802,IAX_COMMAND_TXCNT)
(3803,callno)
(3804,f)
(3805,ast_free(prev)
(3806,fr)
(3807,callno)
(3808,f.subclass)
(3809,callno)
(3810,iaxs[fr->callno])
(3811,&iaxs[fr->callno]->addr)
(3812,name)
(3813,iaxs)
(3814,callno)
(3815,&iaxs[fr->callno]->prefs)
(3816,integer)
(3817,f.frametype == AST_FRAME_TEXT)
(3818,sin.sin_addr)
(3819,fr->ts)
(3820,if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
(3821,fr)
(3822,historicms)
(3823,iaxs[fr->callno]->state)
(3824,fr)
(3825,peer->pokeexpire)
(3826,iaxs[fr->callno]->transferring)
(3827,"TBD")
(3828,fr)
(3829,iaxs[fr->callno])
(3830,fr->callno)
(3831,f.samples)
(3832,f)
(3833,fr)
(3834,iax2_poke_peer_s)
(3835,fr)
(3836,iaxs[fr->callno]->addr)
(3837,fr->callno)
(3838,fr->callno)
(3839,ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED)
(3840,iaxs[fr->callno])
(3841,iaxs)
(3842,peer)
(3843,f.frametype)
(3844,prev)
(3845,iaxs)
(3846,callno)
(3847,mh)
(3848,uncompress_subclass(fh->csub & ~0x40)
(3849,)
(3850,using_prefs)
(3851,ies)
(3852,iaxs[fr->callno])
(3853,0)
(3854,f.subclass)
(3855,fr->callno)
(3856,iaxs[fr->callno])
(3857,ies.calltoken)
(3858,iaxs)
(3859,IAX_COMMAND_REGREJ)
(3860,ast_mutex_unlock(&iaxsl[fr->callno])
(3861,callno)
(3862,iaxs[fr->callno])
(3863,IAX_QUELCH)
(3864,iaxsl)
(3865,iaxs[fr->callno])
(3866,f)
(3867,ies)
(3868,LOG_NOTICE)
(3869,sin.sin_addr)
(3870,fr->callno)
(3871,ast_inet_ntoa(sin.sin_addr)
(3872,iaxs[fr->callno]->pingtime > peer->maxms)
(3873,owner)
(3874,f.frametype)
(3875,if (iaxs[fr->callno]->owner)
(3876,"reqonly")
(3877,iaxs[fr->callno])
(3878,&ied1)
(3879,fr)
(3880,fr->callno)
(3881,f.frametype)
(3882,1)
(3883,ast_debug(1, "IAX subclass %d received\\n", f.subclass.integer)
(3884,fr->callno)
(3885,iaxs[fr->callno]->last)
(3886,fr->callno)
(3887,transferring)
(3888,fr)
(3889,callno)
(3890,pingtime)
(3891,iaxs[fr->callno]->bridgecallno)
(3892,memset(&ied0, 0, sizeof(ied0)
(3893,callno)
(3894,callno)
(3895,callno)
(3896,&sin)
(3897,callno)
(3898,iaxs)
(3899,f.subclass.format)
(3900,(vh->zeros == 0)
(3901,0)
(3902,*prev = NULL)
(3903,f.subclass.format)
(3904,peerformat)
(3905,iaxs[fr->callno]->peerformat = ies.format)
(3906,fr->callno)
(3907,fr->af.subclass.integer)
(3908,if (iaxdebug)
(3909,*varlist)
(3910,lastms)
(3911,iaxs[fr->callno])
(3912,!iaxs[fr->callno])
(3913,bridgecallno)
(3914,iaxs)
(3915,iaxs[fr->callno])
(3916,1)
(3917,!dcallno && iax2_allow_new(f.frametype, f.subclass.integer, 1)
(3918,subclass)
(3919,iaxsl)
(3920,"Rejected call to %s, format %s incompatible with our capability %s.\\n")
(3921,f.data)
(3922,~IAX_FLAG_RETRANS)
(3923,pref = iaxs[fr->callno]->rprefs)
(3924,cur = AST_LIST_LAST(&frame_queue[fr->callno])
(3925,data_size)
(3926,tmp)
(3927,f)
(3928,!inaddrcmp(&sin, &iaxs[fr->callno]->addr)
(3929,iaxs[fr->callno])
(3930,integer)
(3931,iaxs[fr->callno])
(3932,case IAX_COMMAND_UNSUPPORT:)
(3933,iaxs[fr->callno])
(3934,callno)
(3935,auth_fail(fr->callno, IAX_COMMAND_REGREJ)
(3936,AST_FRAME_IAX)
(3937,ast_test_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART)
(3938,vars)
(3939,capability)
(3940,iaxdebug)
(3941,data_size += 3)
(3942,fr->callno)
(3943,&iaxsl[fr->callno])
(3944,IAX_IE_CAUSE)
(3945,)
(3946,fr)
(3947,subclass)
(3948,callno)
(3949,f)
(3950,stop_stuff(fr->callno)
(3951,callno)
(3952,"disabled")
(3953,fr->callno)
(3954,peer)
(3955,iaxsl[fr->callno])
(3956,break;)
(3957,break;)
(3958,iaxs[fr->callno]->oseqno)
(3959,fr)
(3960,NULL)
(3961,iaxs[fr->callno]->bridgecallno)
(3962,)
(3963,!format)
(3964,if (bridged_chan && ies.called_number)
(3965,strcmp(iaxs[fr->callno]->exten, "TBD")
(3966,NULL)
(3967,9)
(3968,iaxs[fr->callno]->lag)
(3969,connected.id)
(3970,fr)
(3971,fr->callno)
(3972,fh)
(3973,iaxs[fr->callno]->bridgecallno)
(3974,case IAX_COMMAND_DPREP:)
(3975,-1)
(3976,str)
(3977,IAX_COMMAND_PONG)
(3978,data_size += 5)
(3979,fr->callno)
(3980,fr)
(3981,)
(3982,musiconhold)
(3983,fr)
(3984,iaxs)
(3985,(f.subclass.integer != IAX_COMMAND_TXCNT)
(3986,subclass)
(3987,callno)
(3988,sin)
(3989,(meta->zeros == 0)
(3990,f.subclass.integer)
(3991,fr)
(3992,iaxs[fr->callno]->state)
(3993,fr->callno)
(3994,fr)
(3995,ntohs(mh->ts)
(3996,fr)
(3997,sizeof(caller_pref_buf)
(3998,ast_variables_destroy(ies.vars)
(3999,)
(4000,fr)
(4001,iaxs[fr->callno]->owner)
(4002,subclass)
(4003,ies)
(4004,ast_channel_nativeformats(iaxs[fr->callno]->owner)
(4005,iax2_lock_owner(fr->callno)
(4006,authenticate_request(fr->callno)
(4007,&ies)
(4008,exten)
(4009,iaxs)
(4010,0)
(4011,IAX_ALREADYGONE)
(4012,LOG_WARNING)
(4013,)
(4014,iaxs[fr->callno])
(4015,iaxs[fr->callno]->peercapability)
(4016,iaxs[fr->callno])
(4017,frametype)
(4018,iaxs[fr->callno]->addr)
(4019,!iaxs[fr->callno])
(4020,callno)
(4021,)
(4022,res < sizeof(*vh)
(4023,)
(4024,ied0.buf)
(4025,ast_devstate_changed(AST_DEVICE_UNAVAILABLE, AST_DEVSTATE_CACHABLE, "IAX2/%s", peer->name)
(4026,af)
(4027,0)
(4028,if (authdebug)
(4029,exten)
(4030,f.samples)
(4031,iaxs[fr->callno]->authmethods)
(4032,prev)
(4033,ies)
(4034,auth_fail(fr->callno, IAX_COMMAND_REJECT)
(4035,using_prefs)
(4036,ast_log(LOG_NOTICE, "Rejected connect attempt from %s, who was trying to reach \'%s@%s\'\\n", ast_inet_ntoa(sin.sin_addr)
(4037,iaxs[fr->callno]->last)
(4038,fr)
(4039,"Registry error\\n")
(4040,case IAX_COMMAND_LAGRP:)
(4041,if (varlist)
(4042,iaxs)
(4043,fr)
(4044,callno)
(4045,pos)
(4046,pokefreqnotok)
(4047,1)
(4048,ast_log(LOG_WARNING, "midget packet received (%d of %d min)
(4049,fr->callno)
(4050,authdebug)
(4051,0)
(4052,iaxs[fr->callno]->addr)
(4053,ast_log(LOG_WARNING, \n\\n\\t\\t\\t\\t\\t\\t"we\'ve been told to rotate our encryption key, "\n\\n\\t\\t\\t\\t\\t\\t"but this isn\'t an encrypted call. bad things will happen.\\n"\n\\n\\t\\t\\t\\t\\t)
(4054,context)
(4055,1)
(4056,iaxs[fr->callno])
(4057,callno)
(4058,var)
(4059,iaxs[fr->callno])
(4060,callno)
(4061,iaxs[fr->callno]->state)
(4062,-1)
(4063,sin.sin_addr)
(4064,*mh)
(4065,fr->callno)
(4066,subclass)
(4067,iaxs[fr->callno])
(4068,f)
(4069,iaxs[fr->callno])
(4070,peer->historicms)
(4071,(f.subclass.integer != IAX_COMMAND_INVAL)
(4072,iaxs[fr->callno]->addr.sin_addr)
(4073,1)
(4074,fr->ts)
(4075,callno)
(4076,f.frametype)
(4077,owner)
(4078,send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREADY, 0, ied1.buf, ied1.pos, -1)
(4079,callno)
(4080,if (!IAX_CALLENCRYPTED(iaxs[fr->callno])
(4081,iaxs[fr->callno])
(4082,fr)
(4083,1)
(4084,variablestore)
(4085,((f.subclass.integer != IAX_COMMAND_ACK)
(4086,fr)
(4087,thread)
(4088,subclass)
(4089,callno)
(4090,ies.vars)
(4091,capability)
(4092,AST_CHANNEL_NAME)
(4093,fr)
(4094,~IAX_FLAG_FULL)
(4095,send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
(4096,lastms)
(4097,fr)
(4098,ptr)
(4099,1)
(4100,)
(4101,res)
(4102,IAX_STATE_TBD)
(4103,f)
(4104,callno)
(4105,variablestore->inheritance = DATASTORE_INHERIT_FOREVER)
(4106,ast_debug(1, "Ooh, voice format changed to \'%s\'\\n", ast_getformatname(&f.subclass.format)
(4107,ts)
(4108,addr)
(4109,break;)
(4110,ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf)
(4111,callno)
(4112,fr)
(4113,)
(4114,bridgecallno)
(4115,f.frametype)
(4116,!iaxs[fr->callno]->owner)
(4117,iaxs)
(4118,if (test_resync)
(4119,sizeof(ied0)
(4120,fr)
(4121,fr)
(4122,fr)
(4123,fr)
(4124,fr->callno)
(4125,f.subclass == IAX_COMMAND_AUTHREQ ||\n\\n\\t\\t\\t\\t\\t\\t\\t\\t f.subclass == IAX_COMMAND_ACCEPT ||\n\\n\\t\\t\\t\\t\\t\\t\\t\\t f.subclass == IAX_COMMAND_REJECT)
(4126,fr)
(4127,"Call rejected by %s: %s\\n")
(4128,iaxs)
(4129,provver)
(4130,f.frametype)
(4131,fr->callno)
(4132,if (ast_channel_readformat(iaxs[fr->callno]->owner)
(4133,peerpoke)
(4134,tmp2)
(4135,f)
(4136,fr)
(4137,IAX_CODEC_NOCAP)
(4138,ast_channel_caller(iaxs[fr->callno]->owner)
(4139,f.frametype)
(4140,!newvar)
(4141,fr->callno)
(4142,iaxs[fr->callno])
(4143,rprefs)
(4144,callno)
(4145,callno)
(4146,connected)
(4147,ast_queue_control_data(iaxs[fr->callno]->owner, AST_CONTROL_PVT_CAUSE_CODE, cause_code, data_size)
(4148,memset(&ied0, 0, sizeof(ied0)
(4149,pingtime)
(4150,send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied0.buf, ied0.pos, -1)
(4151,iaxs)
(4152,format)
(4153,callno)
(4154,0)
(4155,handle_call_token(fh, &ies, &sin, fd)
(4156,IAX_STATE_AUTHENTICATED)
(4157,sin.sin_addr)
(4158,f.subclass.integer == IAX_COMMAND_POKE)
(4159,)
(4160,number)
(4161,f)
(4162,frametype)
(4163,send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
(4164,fr->callno)
(4165,fh)
(4166,f.src)
(4167,cause_code->ast_cause = ies.causecode)
(4168,f.subclass)
(4169,fr->callno)
(4170,fr)
(4171,f.subclass)
(4172,LOG_NOTICE)
(4173,iaxs[fr->callno]->peercapability)
(4174,ast_mutex_unlock(&iaxsl[fr->callno])
(4175,!(ntohs(meta->metacmd)
(4176,owner = iaxs[fr->callno]->owner)
(4177,)
(4178,peer->pokeexpire == -1)
(4179,pref = iaxs[fr->callno]->rprefs)
(4180,iaxs)
(4181,iaxs[fr->callno]->outkey)
(4182,iaxs[fr->callno])
(4183,fr->callno)
(4184,IAX_COMMAND_PONG)
(4185,ast_mutex_unlock(&iaxsl[fr->callno])
(4186,sizeof(ied0)
(4187,iaxs[fr->callno])
(4188,capability)
(4189,)
(4190,ied0.buf)
(4191,&iaxs[fr->callno]->state)
(4192,callno)
(4193,(f.frametype == AST_FRAME_VOICE)
(4194,memset(&ied0, 0, sizeof(ied0)
(4195,vars)
(4196,bridged_chan && ies.called_number)
(4197,fr)
(4198,if (!iaxs[fr->callno])
(4199,sizeof(tmp)
(4200,fr->callno)
(4201,thread->buf)
(4202,format)
(4203,ts)
(4204,!fr->callno)
(4205,ts)
(4206,f.frametype != AST_FRAME_IAX)
(4207,newvar)
(4208,)
(4209,)
(4210,callno)
(4211,iaxs)
(4212,fr->callno)
(4213,fr)
(4214,*vh)
(4215,"No such context/extension")
(4216,iaxs)
(4217,integer)
(4218,fr)
(4219,f)
(4220,fr->ts = (iaxs[fr->callno]->last & 0xFFFF0000L)
(4221,fr->callno)
(4222,f.subclass.integer)
(4223,sin)
(4224,(ast_strlen_zero(iaxs[fr->callno]->secret)
(4225,AST_FRAME_IAX)
(4226,voiceformat)
(4227,&iax2_variable_datastore_info)
(4228,fr)
(4229,ies)
(4230,callno)
(4231,fr)
(4232,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)
(4233,f)
(4234,iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner)
(4235,sin_addr)
(4236,raw_hangup(&sin, ntohs(fh->dcallno)
(4237,subclass)
(4238,iaxs[iaxs[fr->callno]->bridgecallno])
(4239,)
(4240,break;)
(4241,var)
(4242,iaxs[fr->callno])
(4243,iaxs[fr->callno]->context)
(4244,if (iaxs[fr->callno]->transferring)
(4245,f.data)
(4246,f.subclass.integer != IAX_COMMAND_TXACC)
(4247,fr->callno)
(4248,fr)
(4249,break;)
(4250,if (iaxs[fr->callno] && iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno)
(4251,&f.subclass.format)
(4252,iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_READY)
(4253,"disabled")
(4254,causecode)
(4255,thread)
(4256,iaxs)
(4257,connected.id.number)
(4258,iaxs[fr->callno])
(4259,iaxs[fr->callno])
(4260,NEW_ALLOW_CALLTOKEN_VALIDATED)
(4261,callno)
(4262,if (ast_strlen_zero(iaxs[fr->callno]->secret)
(4263,called_number)
(4264,iaxs)
(4265,memset(&ies, 0, sizeof(ies)
(4266,iaxs[fr->callno])
(4267,iaxs)
(4268,owner)
(4269,peer->historicms)
(4270,iaxs[fr->callno])
(4271,&f)
(4272,ntohs(mh->callno)
(4273,iaxs)
(4274,ied0)
(4275,iaxs)
(4276,iaxs)
(4277,&f)
(4278,fr->callno)
(4279,iaxs)
(4280,fr->callno)
(4281,ntohs(mh->callno)
(4282,IAX_COMMAND_FWDATA)
(4283,iax2_destroy(call_to_destroy)
(4284,fr->callno)
(4285,)
(4286,peer->historicms)
(4287,1)
(4288,break;)
(4289,iaxs[fr->callno])
(4290,fr)
(4291,iaxs[fr->callno]->peercapability)
(4292,sin)
(4293,fr->callno)
(4294,connected.id)
(4295,switch(f.subclass.integer)
(4296,ast_log(LOG_WARNING, "Undecodable frame received from \'%s\'\\n", ast_inet_ntoa(sin.sin_addr)
(4297,iaxs[fr->callno]->iseqno)
(4298,ntohs(mh->callno)
(4299,iaxs[fr->callno]->context)
(4300,using_prefs)
(4301,&iaxs[fr->callno]->rprefs)
(4302,IAX_COMMAND_ACK)
(4303,ies.called_number)
(4304,ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD)
(4305,ts)
(4306,iaxs[fr->callno])
(4307,AST_FRAME_IAX)
(4308,)
(4309,callno)
(4310,iaxs)
(4311,callno)
(4312,callno)
(4313,RET)
(4314,iaxs)
(4315,iaxs)
(4316,callno)
(4317,)
(4318,AST_DEVICE_NOT_INUSE)
(4319,ied0)
(4320,pref = iaxs[fr->callno]->rprefs)
(4321,)
(4322,iaxs[fr->callno])
(4323,sin)
(4324,IAX_STATE_TBD)
(4325,datalen)
(4326,iaxs)
(4327,&ied0)
(4328,iax2_lock_owner(fr->callno)
(4329,subclass)
(4330,)
(4331,fr)
(4332,fr->callno)
(4333,&ied0)
(4334,IAX_COMMAND_UNSUPPORT)
(4335,)
(4336,fr->callno)
(4337,iaxs)
(4338,callno)
(4339,)
(4340,callno)
(4341,ast_set_callerid(iaxs[fr->callno]->owner,\n\\n\\t\\t\\t\\t\\tS_COR(connected.id.number.valid, connected.id.number.str, "")
(4342,if (orignative)
(4343,iax2_lock_owner(fr->callno)
(4344,cur)
(4345,NULL)
(4346,iaxs)
(4347,fr->callno)
(4348,iaxs)
(4349,AF_INET)
(4350,ast_channel_readformat(iaxs[fr->callno]->owner)
(4351,"midget packet received (%d of %d min)
(4352,fr->callno)
(4353,iseqno)
(4354,ied1.buf)
(4355,fr)
(4356,thread)
(4357,frametype)
(4358,callno)
(4359,callno)
(4360,iaxs[fr->callno]->owner)
(4361,integer)
(4362,iaxs[fr->callno]->owner)
(4363,fr)
(4364,iaxs[fr->callno]->peercapability)
(4365,break;)
(4366,iaxs)
(4367,1)
(4368,0xFFFF8000L)
(4369,"Received mini frame before first full video frame\\n")
(4370,iaxs)
(4371,fr->oseqno)
(4372,fr->callno)
(4373,iaxs[fr->callno]->videoformat)
(4374,send_apathetic_reply(1, ntohs(fh->scallno)
(4375,transferring)
(4376,callno)
(4377,res)
(4378,connected.id.name.presentation)
(4379,TRANSFER_MEDIA)
(4380,peercapability)
(4381,fr)
(4382,tmp)
(4383,TRANSFER_RELEASED)
(4384,pref = iaxs[fr->callno]->prefs)
(4385,-1)
(4386,thread->buf)
(4387,callno)
(4388,iaxsl)
(4389,cause)
(4390,fr->callno)
(4391,fr)
(4392,iaxs[fr->callno])
(4393,data)
(4394,varlist)
(4395,authmethods)
(4396,bridgecallno)
(4397,!iaxs[fr->callno]->owner)
(4398,buf)
(4399,IAX_IE_CALLNO)
(4400,variablestore)
(4401,new_peercallno)
(4402,ast_debug(1, "We don\'t do requested format %s, falling back to peer capability \'%s\'\\n",\n\\n\\t\\t\\t\\t\\t\\t\\t\\tiax2_getformatname(iaxs[fr->callno]->peerformat)
(4403,iaxs)
(4404,f.subclass)
(4405,fr)
(4406,)
(4407,sizeof(pref)
(4408,callno)
(4409,f.subclass.integer != IAX_COMMAND_ACK)
(4410,oseqno)
(4411,varlist)
(4412,iaxsl)
(4413,var)
(4414,1)
(4415,iaxs[fr->callno]->owner)
(4416,new_peercallno)
(4417,callno)
(4418,1)
(4419,callno)
(4420,ntohs(vh->ts)
(4421,1)
(4422,f.frametype == AST_FRAME_IAX)
(4423,exten)
(4424,"Receiving")
(4425,break;)
(4426,iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL)
(4427,fr)
(4428,authdebug)
(4429,code)
(4430,res)
(4431,integer)
(4432,sizeof(tmp2)
(4433,fr->callno)
(4434,ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD)
(4435,owner)
(4436,format)
(4437,return 1;)
(4438,newvar)
(4439,new_callno)
(4440,fr)
(4441,owner)
(4442,fr->callno)
(4443,register_verify(fr->callno, &sin, &ies)
(4444,context)
(4445,iaxs[fr->callno])
(4446,IAX_CODEC_NOPREFS)
(4447,fr)
(4448,fr->callno)
(4449,if (format)
(4450,fr)
(4451,data_size)
(4452,fr->callno)
(4453,last)
(4454,f)
(4455,fr->callno)
(4456,ies.vars)
(4457,TRANSFER_MREADY)
(4458,callno)
(4459,(struct ast_iax2_video_hdr *)
(4460,callno)
(4461,f)
(4462,varlist)
(4463,fh)
(4464,iaxs[fr->callno])
(4465,NULL)
(4466,callno)
(4467,format)
(4468,0)
(4469,3)
(4470,empty)
(4471,ast_strlen_zero(iaxs[fr->callno]->secret)
(4472,return 1;)
(4473,iaxs[fr->callno])
(4474,IAX_COMMAND_INVAL)
(4475,f.frametype == AST_FRAME_IAX)
(4476,fr)
(4477,f.frametype)
(4478,callno)
(4479,ies)
(4480,&thread->iosin)
(4481,format)
(4482,reg)
(4483,IAX_COMMAND_POKE)
(4484,format)
(4485,!(dp->flags & CACHE_FLAG_TRANSMITTED)
(4486,caller_pref_buf)
(4487,LOG_NOTICE)
(4488,callno)
(4489,NULL)
(4490,fr->callno)
(4491,fr->callno)
(4492,*variablestore = NULL)
(4493,iaxs[fr->callno]->addr)
(4494,fr->callno)
(4495,owner)
(4496,ies)
(4497,ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)
(4498,1)
(4499,ies.vars)
(4500,fr)
(4501,callno)
(4502,send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1)
(4503,iaxs[fr->callno])
(4504,)
(4505,iaxs)
(4506,exists)
(4507,ies.calltokendata)
(4508,rprefs)
(4509,(ntohs(fh->dcallno)
(4510,subclass)
(4511,callno)
(4512,iaxs[fr->callno])
(4513,ies)
(4514,ies)
(4515,EVENT_FLAG_CALL)
(4516,iaxs)
(4517,fr->callno)
(4518,iaxs[fr->callno])
(4519,subclass)
(4520,owner)
(4521,"TBD")
(4522,ied0)
(4523,iaxs[fr->callno])
(4524,thread->buf)
(4525,connected.id.name)
(4526,if (variablestore && varlist)
(4527,using_prefs = "reqonly")
(4528,callno)
(4529,iaxs[fr->callno]->cid_num)
(4530,if (ies.vars)
(4531,f.subclass.integer)
(4532,!iaxs[fr->callno])
(4533,if ((iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_READY)
(4534,0)
(4535,iaxs[fr->callno])
(4536,IAX_FLAG_FULL)
(4537,transferring)
(4538,callno)
(4539,iaxs[fr->callno]->prefs)
(4540,peercallno)
(4541,iaxs[fr->callno]->owner)
(4542,fr->callno)
(4543,host_pref_buf)
(4544,ied1.pos)
(4545,fr->callno)
(4546,callno)
(4547,iaxs)
(4548,f.frametype == AST_FRAME_VIDEO)
(4549,owner)
(4550,ies.encmethods)
(4551,f.datalen)
(4552,iaxsl[fr->callno])
(4553,peer->maxms)
(4554,iaxs[fr->callno]->exten)
(4555,&iaxs[fr->callno]->rprefs)
(4556,3)
(4557,NULL)
(4558,fr)
(4559,break;)
(4560,)
(4561,fr->callno)
(4562,callno)
(4563,0)
(4564,frametype)
(4565,fr->callno)
(4566,if (inaddrcmp(&sin, &iaxs[fr->callno]->addr)
(4567,)
(4568,callno)
(4569,&iaxsl[fr->callno])
(4570,pref)
(4571,ies.serviceident)
(4572,return 1;)
(4573,sin.sin_port)
(4574,bridgecallno)
(4575,ies)
(4576,iaxs[fr->callno])
(4577,subclass)
(4578,ied0)
(4579,ast_channel_readformat(iaxs[fr->callno]->owner)
(4580,if (!newvar)
(4581,callno)
(4582,callno)
(4583,"Memory allocation error while processing IAX2 variables\\n")
(4584,ntohs(meta->metacmd)
(4585,IAX_IE_CAUSECODE)
(4586,ies)
(4587,fr)
(4588,"Packet Decrypt Failed!\\n")
(4589,fr)
(4590,fr->ts)
(4591,&ied1)
(4592,iaxsl[fr->callno])
(4593,callno)
(4594,&sin)
(4595,iaxs[fr->callno]->owner)
(4596,callno)
(4597,iaxs[fr->callno])
(4598,var = ies.vars)
(4599,callno)
(4600,cacheable)
(4601,ast_channel_hangupcause_hash_set(iaxs[fr->callno]->owner, cause_code, data_size)
(4602,socket_process_meta(res, meta, &sin, fd, fr)
(4603,if (f.frametype == AST_FRAME_IAX)
(4604,last)
(4605,challenge)
(4606,exten)
(4607,ies)
(4608,using_prefs)
(4609,tmpfmt)
(4610,iaxs[fr->callno])
(4611,pref)
(4612,f.subclass.integer == IAX_COMMAND_ACK && dcallno == 1)
(4613,)
(4614,callno)
(4615,try_transfer(iaxs[fr->callno], &ies)
(4616,var)
(4617,callno)
(4618,outoforder)
(4619,fr)
(4620,iaxs)
(4621,)
(4622,iaxs)
(4623,iax2_getformatname(format)
(4624,(f.subclass.integer != IAX_COMMAND_INVAL)
(4625,fr)
(4626,1)
(4627,pokeexpire)
(4628,capability)
(4629,sin.sin_addr)
(4630,varlist)
(4631,iaxs[fr->callno]->rprefs)
(4632,pref)
(4633,fr)
(4634,!ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
(4635,fr->callno)
(4636,ptr)
(4637,callno)
(4638,f.samples)
(4639,)
(4640,fr->callno)
(4641,peer)
(4642,iaxs[fr->callno]->rprefs)
(4643,peerformat)
(4644,1)
(4645,3)
(4646,iaxs)
(4647,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)
(4648,f)
(4649,iaxs[fr->callno])
(4650,iaxs[fr->callno]->peerpoke)
(4651,f)
(4652,ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr)
(4653,mh->callno)
(4654,cid_name)
(4655,send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
(4656,owner)
(4657,fr->callno)
(4658,fr->callno)
(4659,fr)
(4660,if (f.datalen)
(4661,variablestore)
(4662,if (iaxs[iaxs[fr->callno]->bridgecallno]->transferring)
(4663,callno)
(4664,fr)
(4665,ied0)
(4666,0)
(4667,store_by_peercallno(iaxs[fr->callno])
(4668,iaxs)
(4669,callno)
(4670,fh->ts)
(4671,iaxsl)
(4672,0)
(4673,fr->callno)
(4674,&sin)
(4675,&iaxs[fr->callno]->addr)
(4676,)
(4677,owner)
(4678,peer->maxms)
(4679,ast_channel_name(iaxs[fr->callno]->owner)
(4680,updatehistory = 0)
(4681,"ChannelType: IAX2\\r\\nPeer: IAX2/%s\\r\\nPeerStatus: Reachable\\r\\nTime: %d\\r\\n")
(4682,check_access(fr->callno, &sin, &ies)
(4683,thread)
(4684,iaxfrdup2(fr)
(4685,&sin)
(4686,fr)
(4687,orignative = ast_format_cap_destroy(orignative)
(4688,iaxsl[fr->callno])
(4689,subclass)
(4690,fr)
(4691,transferring)
(4692,callno)
(4693,LOG_NOTICE)
(4694,callno)
(4695,fr->ts)
(4696,ntohs(mh->ts)
(4697,fr)
(4698,pref)
(4699,f.subclass.integer)
(4700,)
(4701,iaxs)
(4702,fr->callno)
(4703,prefs)
(4704,iaxs[fr->callno])
(4705,iaxs[fr->callno]->owner)
(4706,peer)
(4707,fr)
(4708,f)
(4709,&iaxsl[fr->callno])
(4710,"Peer \'%s\' is now REACHABLE! Time: %d\\n")
(4711,sizeof(ies)
(4712,fr)
(4713,sin)
(4714,x)
(4715,)
(4716,break;)
(4717,fr->callno)
(4718,iaxs)
(4719,fr->callno)
(4720,IAX_IE_CAUSECODE)
(4721,f.subclass == IAX_COMMAND_NEW)
(4722,ied0.buf)
(4723,bridged_chan)
(4724,&ied0)
(4725,peer->lastms < 0)
(4726,ies)
(4727,0)
(4728,sin_addr)
(4729,iaxs[fr->callno])
(4730,iaxs[fr->callno])
(4731,f)
(4732,iaxs[fr->callno])
(4733,&iaxsl[fr->callno])
(4734,ied1.pos)
(4735,)
(4736,iaxs)
(4737,callno)
(4738,fr->callno)
(4739,fr->callno)
(4740,fr->callno)
(4741,ied0)
(4742,iaxs[fr->callno])
(4743,iaxs)
(4744,f.frametype = AST_FRAME_NULL)
(4745,data_size)
(4746,iaxs[fr->callno])
(4747,iaxs[fr->callno]->cid_num)
(4748,callno)
(4749,fd)
(4750,iaxs)
(4751,callno)
(4752,if (!iaxs[fr->callno])
(4753,iaxs[fr->callno])
(4754,iaxs[fr->callno]->peercallno)
(4755,ies)
(4756,iseqno)
(4757,iaxs[fr->callno])
(4758,lastms)
(4759,fr)
(4760,var = var->next)
(4761,fr)
(4762,callno)
(4763,iaxs)
(4764,format)
(4765,*mh = (struct ast_iax2_mini_hdr *)
(4766,callno)
(4767,callno)
(4768,iaxs[fr->callno]->owner)
(4769,fr->callno)
(4770,ied0)
(4771,AST_FRAME_IAX)
(4772,peer->pokefreqok)
(4773,aseqno)
(4774,fr)
(4775,(0 + peer->historicms)
(4776,tmp2)
(4777,using_prefs)
(4778,iax2_getformatname_multiple(tmp, sizeof(tmp)
(4779,iaxs[fr->callno])
(4780,fr)
(4781,iaxs[iaxs[fr->callno]->bridgecallno])
(4782,f)
(4783,ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr)
(4784,fh->csub)
(4785,ied0)
(4786,sizeof(ied0)
(4787,fr->callno)
(4788,&ied0)
(4789,callno)
(4790,iaxs[fr->callno])
(4791,peerformat)
(4792,prefs)
(4793,iaxs[fr->callno]->reg)
(4794,memset(&ies, 0, sizeof(ies)
(4795,ENOTCONN)
(4796,callno)
(4797,peer)
(4798,iax2_variable_datastore_info)
(4799,)
(4800,if (authdebug)
(4801,fr)
(4802,caller_pref_buf)
(4803,frametype)
(4804,fr)
(4805,&ied0)
(4806,case IAX_COMMAND_TXREL:)
(4807,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(4808,f.subclass.integer)
(4809,fr->callno)
(4810,iaxs[fr->callno])
(4811,iaxs[fr->callno])
(4812,ies)
(4813,fr)
(4814,fr->callno)
(4815,capability)
(4816,AST_STATE_RING)
(4817,ast_channel_name(iaxs[fr->callno]->owner)
(4818,iaxs)
(4819,0)
(4820,iaxs[fr->callno])
(4821,LOG_WARNING)
(4822,tmpfmt)
(4823,TRANSFER_READY)
(4824,!AST_SCHED_DEL(sched, peer->pokeexpire)
(4825,ast_datastore_alloc(&iax2_variable_datastore_info, NULL)
(4826,ast_verb(3, "Call accepted by %s (format %s)
(4827,iaxs)
(4828,iaxs)
(4829,fr->callno)
(4830,iaxs[fr->callno])
(4831,f.subclass)
(4832,if (variablestore)
(4833,f.frametype)
(4834,iaxsl[fr->callno])
(4835,ast_exists_extension(NULL, context, exten, 1, cid_num)
(4836,ast_variables_destroy(ies.vars)
(4837,iaxs[fr->callno])
(4838,fr)
(4839,1)
(4840,f.subclass)
(4841,fr->callno)
(4842,&iaxs[fr->callno]->state)
(4843,fr->callno)
(4844,0)
(4845,fr->callno)
(4846,return 1;)
(4847,iaxs[fr->callno])
(4848,ied0)
(4849,ast_log(LOG_NOTICE, "Peer did not understand our iax command \'%d\'\\n", ies.iax_unknown)
(4850,res)
(4851,send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied1.buf, ied1.pos, -1)
(4852,AST_FRAME_IAX)
(4853,iaxs[fr->callno]->chosenformat)
(4854,)
(4855,if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)
(4856,subclass)
(4857,ntohs(mh->callno)
(4858,fr)
(4859,fr)
(4860,fr->callno)
(4861,AST_FRAME_IAX)
(4862,sizeof(tmp2)
(4863,fr)
(4864,updatehistory)
(4865,subclass)
(4866,value)
(4867,f)
(4868,fr)
(4869,csub)
(4870,id)
(4871,f.subclass.integer)
(4872,callno)
(4873,fr->callno)
(4874,fr->callno)
(4875,capability)
(4876,fr)
(4877,iaxs)
(4878,ntohs(mh->callno)
(4879,f)
(4880,ied0.pos)
(4881,IAX_CODEC_NOCAP)
(4882,pingtime)
(4883,thread)
(4884,save_rr(fr, &ies)
(4885,fr)
(4886,f.subclass.format)
(4887,peerformat)
(4888,snprintf(cause_code->code, data_size - sizeof(*cause_code)
(4889,"Rejected connect attempt from %s, request \'%s@%s\' does not exist\\n")
(4890,iaxs[fr->callno])
(4891,fr)
(4892,format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
(4893,)
(4894,iaxs)
(4895,data)
(4896,f.subclass.integer == IAX_COMMAND_REGREL)
(4897,f.subclass)
(4898,fr)
(4899,next)
(4900,format)
(4901,orignative)
(4902,iaxs)
(4903,callno)
(4904,fr)
(4905,state)
(4906,3)
(4907,format)
(4908,if (varlist)
(4909,iaxs[fr->callno])
(4910,fr->callno)
(4911,name)
(4912,fr->callno)
(4913,ast_variables_destroy(ies.vars)
(4914,iaxs[fr->callno])
(4915,fh->csub & ~0x40)
(4916,fr)
(4917,iaxs)
(4918,peer)
(4919,&iaxsl[fr->callno])
(4920,pref = iaxs[fr->callno]->rprefs)
(4921,AST_FRAME_IAX)
(4922,iaxs)
(4923,iaxs[iaxs[fr->callno]->bridgecallno]->transferring)
(4924,peercapability)
(4925,callno)
(4926,name)
(4927,if (!iaxs[fr->callno])
(4928,fr->callno = find_callno(ntohs(mh->callno)
(4929,iaxs[fr->callno])
(4930,iaxs[fr->callno]->owner)
(4931,callno)
(4932,iaxs[fr->callno]->iseqno != fr->oseqno)
(4933,dcallno)
(4934,!ast_test_flag64(&globalflags, IAX_ALLOWFWDOWNLOAD)
(4935,fr)
(4936,0)
(4937,callno)
(4938,iaxs)
(4939,iaxs)
(4940,newvar)
(4941,called_number)
(4942,send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_UNSUPPORT, 0, ied0.buf, ied0.pos, -1)
(4943,iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)
(4944,&sin)
(4945,"s")
(4946,exten)
(4947,VERBOSE_PREFIX_4)
(4948,owner)
(4949,fr)
(4950,&sin)
(4951,peer->name)
(4952,iaxs[iaxs[fr->callno]->bridgecallno]->transferring)
(4953,fr->callno)
(4954,iaxs[fr->callno]->cid_num)
(4955,iaxs[fr->callno]->transferring)
(4956,iaxs[fr->callno]->context)
(4957,fr)
(4958,callno)
(4959,f)
(4960,iaxs)
(4961,format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0)
(4962,fr)
(4963,prev)
(4964,res)
(4965,tmp2)
(4966,break;)
(4967,iaxs[fr->callno])
(4968,0)
(4969,iaxs[fr->callno]->owner)
(4970,historicms)
(4971,next)
(4972,dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num, 1)
(4973,iaxs[fr->callno]->peerformat)
(4974,iaxs[fr->callno]->bridgecallno)
(4975,iaxs)
(4976,tmp)
(4977,f.subclass)
(4978,if (iaxs[fr->callno]->reg)
(4979,iaxs[fr->callno]->state)
(4980,memcpy(&sin, &thread->iosin, sizeof(sin)
(4981,iaxs)
(4982,fr)
(4983,)
(4984,AST_FRAME_VOICE)
(4985,fr->ts)
(4986,f.frametype)
(4987,"LAGRQ")
(4988,iaxs)
(4989,fr)
(4990,f)
(4991,iaxs[iaxs[fr->callno]->bridgecallno]->transferring)
(4992,exten)
(4993,unsigned char)
(4994,iaxs[fr->callno]->exten)
(4995,f.datalen)
(4996,fr->callno)
(4997,iaxs[fr->callno])
(4998,0)
(4999,IAX_ENCRYPTED)
(5000,ied0)
(5001,tmp1)
(5002,*using_prefs = "mine")
(5003,sizeof(tmp2)
(5004,ies)
(5005,&iaxsl[fr->callno])
(5006,if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD)
(5007,cur)
(5008,1)
(5009,iaxs)
(5010,iaxs[fr->callno])
(5011,fr)
(5012,"Memory allocation error while processing IAX2 variables\\n")
(5013,mh)
(5014,fr)
(5015,sin_addr)
(5016,peer->name)
(5017,callno)
(5018,*fh)
(5019,dcallno)
(5020,iax_unknown)
(5021,iaxs)
(5022,IAX_CODEC_NOPREFS)
(5023,ast_channel_name(owner)
(5024,f.frametype == AST_FRAME_IAX && (f.subclass.integer == IAX_COMMAND_REGREQ || f.subclass.integer == IAX_COMMAND_REGREL)
(5025,iaxs[fr->callno]->owner && fh->type == AST_FRAME_IAX &&\n\\n\\t\\t\\t(fh->csub == IAX_COMMAND_HANGUP\n\\n\\t\\t\\t|| fh->csub == IAX_COMMAND_REJECT\n\\n\\t\\t\\t|| fh->csub == IAX_COMMAND_REGREJ\n\\n\\t\\t\\t|| fh->csub == IAX_COMMAND_TXREJ)
(5026,owner)
(5027,&ied1)
(5028,last)
(5029,connected.id.name)
(5030,format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
(5031,)
(5032,fr)
(5033,pos)
(5034,0x8000)
(5035,ast_channel_name(iaxs[fr->callno]->owner)
(5036,fr->callno)
(5037,ies.codec_prefs)
(5038,iaxs[fr->callno])
(5039,)
(5040,"IAX2")
(5041,IAX_COMMAND_REJECT)
(5042,)
(5043,f.subclass.integer = 0)
(5044,iaxs)
(5045,IAX_IE_CALLNO)
(5046,ies)
(5047,ies.cause)
(5048,iaxs[fr->callno])
(5049,ies)
(5050,IAX_CODEC_NOCAP)
(5051,iaxs)
(5052,iaxs)
(5053,if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)
(5054,csub)
(5055,res)
(5056,unsigned short)
(5057,iaxs)
(5058,minivid)
(5059,-1)
(5060,"No best format in %s???\\n")
(5061,callno)
(5062,ast_test_flag64(iaxs[fr->callno], IAX_ENCRYPTED)
(5063,)
(5064,fr)
(5065,fr->iseqno)
(5066,-1)
(5067,stop_stuff(fr->callno)
(5068,if (variablestore)
(5069,retries)
(5070,fr)
(5071,fr->callno)
(5072,iaxs)
(5073,addr)
(5074,if (ast_bridged_channel(iaxs[fr->callno]->owner)
(5075,fr->ts)
(5076,if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)
(5077,fr->iseqno)
(5078,fr->callno)
(5079,AST_FRAME_VIDEO)
(5080,fr->callno)
(5081,integer)
(5082,iaxs[fr->callno]->peerformat = iaxs[fr->callno]->capability)
(5083,fr)
(5084,variablestore)
(5085,fh->csub)
(5086,fr->callno)
(5087,subclass)
(5088,fr->callno)
(5089,iaxs)
(5090,)
(5091,f.subclass.integer != IAX_COMMAND_INVAL)
(5092,subclass)
(5093,bridged_chan)
(5094,f)
(5095,type)
(5096,fr)
(5097,fr->ts)
(5098,iaxs[fr->callno])
(5099,varlist)
(5100,f.subclass.integer != IAX_COMMAND_TXACC)
(5101,vars)
(5102,ast_inet_ntoa(sin.sin_addr)
(5103,)
(5104,iaxs[fr->callno])
(5105,IAX_COMMAND_TXMEDIA)
(5106,fr->iseqno)
(5107,fr)
(5108,iaxs[fr->callno]->peercapability)
(5109,iaxs[fr->callno])
(5110,f.frametype)
(5111,iaxs[fr->callno])
(5112,fr)
(5113,fr->callno)
(5114,iaxsl[fr->callno])
(5115,f.data.ptr)
(5116,iaxs[fr->callno]->peerformat)
(5117,"<Unknown>")
(5118,fr->callno)
(5119,last)
(5120,ied1)
(5121,callno)
(5122,f.frametype)
(5123,break;)
(5124,iax2_getformatname_multiple(tmp2, sizeof(tmp2)
(5125,codec_prefs)
(5126,iaxs)
(5127,f.data)
(5128,)
(5129,iaxs)
(5130,)
(5131,iaxs)
(5132,ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\\n")
(5133,if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_NEW)
(5134,iaxs[fr->callno])
(5135,"Registration failure\\n")
(5136,)
(5137,iaxs[fr->callno]->iaxvars)
(5138,break;)
(5139,fr)
(5140,integer)
(5141,fr->callno)
(5142,fr->callno)
(5143,f)
(5144,callno)
(5145,iaxs[fr->callno])
(5146,tmp2)
(5147,f.subclass)
(5148,fr)
(5149,sin.sin_addr)
(5150,case IAX_COMMAND_INVAL:)
(5151,iaxs[fr->callno]->addr)
(5152,"IAX2/%s")
(5153,IAX_COMMAND_ACK)
(5154,fh->csub == IAX_COMMAND_HANGUP\n\\n\\t\\t\\t|| fh->csub == IAX_COMMAND_REJECT\n\\n\\t\\t\\t|| fh->csub == IAX_COMMAND_REGREJ\n\\n\\t\\t\\t|| fh->csub == IAX_COMMAND_TXREJ)
(5155,1)
(5156,ts)
(5157,callno)
(5158,ies)
(5159,fr->callno)
(5160,tmp1)
(5161,)
(5162,peer->name)
(5163,moh_suggest)
(5164,exten)
(5165,sin)
(5166,iaxs[fr->callno]->secret)
(5167,iaxs)
(5168,fh)
(5169,)
(5170,ast_mutex_unlock(&iaxsl[fr->callno])
(5171,if (\n\\n\\t\\t\\t ((f.subclass.integer != IAX_COMMAND_ACK)
(5172,-1)
(5173,f)
(5174,if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)
(5175,iaxs)
(5176,peer->lastms)
(5177,fr->iseqno)
(5178,iaxs[fr->callno])
(5179,if (iaxdebug)
(5180,f.samples = 0)
(5181,fr)
(5182,f)
(5183,0)
(5184,transferring)
(5185,callno)
(5186,1)
(5187,bridgecallno)
(5188,iaxs[fr->callno])
(5189,iaxs[iaxs[fr->callno]->bridgecallno])
(5190,fr)
(5191,iaxs[fr->callno]->addr.sin_addr)
(5192,state)
(5193,varlist)
(5194,valid)
(5195,callno)
(5196,iaxs)
(5197,data_size = sizeof(*cause_code)
(5198,-1)
(5199,f.frametype == AST_FRAME_IAX)
(5200,(f.subclass.integer != IAX_COMMAND_INVAL)
(5201,pokeexpire)
(5202,iaxs[fr->callno]->exten)
(5203,iaxs[fr->callno]->owner)
(5204,s_addr)
(5205,sin)
(5206,IAX_STATE_STARTED)
(5207,!(c = ast_iax2_new(fr->callno, AST_STATE_RING, format, NULL, 1)
(5208,f)
(5209,(f.subclass.integer != IAX_COMMAND_UNQUELCH )
(5210,id)
(5211,send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
(5212,1)
(5213,iaxs[fr->callno])
(5214,fh->csub == IAX_COMMAND_TXREJ)
(5215,username)
(5216,&ied1)
(5217,sizeof(pref)
(5218,*vh = (struct ast_iax2_video_hdr *)
(5219,ast_channel_caller(iaxs[fr->callno]->owner)
(5220,callno)
(5221,ied0)
(5222,ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability \'%s\'/\'%s\' incompatible with our capability \'%s\'.\\n",\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tast_inet_ntoa(sin.sin_addr)
(5223,vars)
(5224,if (iax_park(bridged_chan, owner, ies.called_number, context)
(5225,capability)
(5226,sizeof(tmp)
(5227,if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(5228,ied0.buf)
(5229,format)
(5230,iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
(5231,newvar)
(5232,fr)
(5233,iaxs[fr->callno])
(5234,var->next)
(5235,case IAX_COMMAND_REGREJ:)
(5236,iaxs)
(5237,"I can haz IAX vars? w00t\\n")
(5238,callno)
(5239,iofd)
(5240,rprefs)
(5241,iaxs[fr->callno])
(5242,"disabled")
(5243,fr)
(5244,iaxs[fr->callno]->iaxvars)
(5245,callno)
(5246,fr)
(5247,iaxs[fr->callno]->authmethods & IAX_AUTH_MD5)
(5248,sizeof(ied0)
(5249,using_prefs = "caller")
(5250,AST_FRAME_VOICE)
(5251,iaxs)
(5252,fr->afdatalen = 4096)
(5253,last)
(5254,call_to_destroy)
(5255,fr->callno)
(5256,if (peer->smoothing && (peer->lastms > -1)
(5257,sin_addr)
(5258,fr->callno)
(5259,fr->callno)
(5260,f.data)
(5261,ies)
(5262,TRANSFER_READY)
(5263,"Acking anyway\\n")
(5264,duped_fr = iaxfrdup2(fr)
(5265,iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
(5266,bridged_chan = owner ? ast_bridged_channel(owner)
(5267,iaxs)
(5268,iaxs[fr->callno])
(5269,ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_BUSY)
(5270,iaxs[fr->callno]->addr.sin_addr)
(5271,IAX_COMMAND_PONG)
(5272,callno)
(5273,f.subclass.integer == IAX_COMMAND_REGREQ)
(5274,0)
(5275,callno)
(5276,if (ast_bridged_channel(iaxs[fr->callno]->owner)
(5277,sin_addr)
(5278,callno)
(5279,-1)
(5280,break;)
(5281,ies)
(5282,prev = var)
(5283,"Host %s failed to authenticate as %s\\n")
(5284,if (ast_test_flag64(iaxs[fr->callno], IAX_TRUNK)
(5285,callno)
(5286,iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_peer_s, peer_ref(peer)
(5287,f)
(5288,callno)
(5289,iaxs)
(5290,ied0)
(5291,iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec")
(5292,datalen)
(5293,iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
(5294,return 1;)
(5295,fr)
(5296,owner)
(5297,test_resync)
(5298,callno)
(5299,state)
(5300,ast_strlen_zero(iaxs[fr->callno]->secret)
(5301,)
(5302,ies.vars)
(5303,connected)
(5304,0)
(5305,iaxs[fr->callno])
(5306,var->value)
(5307,NULL)
(5308,ied0)
(5309,fr)
(5310,fr->callno)
(5311,ast_debug(1, "Received iseqno %d not within window %d->%d\\n", fr->iseqno, iaxs[fr->callno]->rseqno, iaxs[fr->callno]->oseqno)
(5312,callno)
(5313,data)
(5314,iaxs)
(5315,test_resync)
(5316,integer)
(5317,varlist)
(5318,CACHE_FLAG_TRANSMITTED)
(5319,(ntohs(fh->dcallno)
(5320,iaxs[fr->callno])
(5321,ied0)
(5322,iax_frame_wrap(fr, &f)
(5323,f)
(5324,iaxs)
(5325,ied0.pos)
(5326,if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD | IAX_STATE_AUTHENTICATED)
(5327,fr->callno)
(5328,ast_channel_readformat(iaxs[fr->callno]->owner)
(5329,fr->ts)
(5330,fr->callno)
(5331,vh)
(5332,0x8000)
(5333,variablestore)
(5334,maxms)
(5335,bridgecallno)
(5336,fr->callno)
(5337,iaxs[fr->callno]->bridgecallno)
(5338,fr)
(5339,)
(5340,&ied0)
(5341,fr->callno)
(5342,! (f.frametype == AST_FRAME_IAX &&\n\\n\\t\\t\\t\\t\\t\\t\\t\\t(f.subclass == IAX_COMMAND_NEW ||\n\\n\\t\\t\\t\\t\\t\\t\\t\\t f.subclass == IAX_COMMAND_AUTHREQ ||\n\\n\\t\\t\\t\\t\\t\\t\\t\\t f.subclass == IAX_COMMAND_ACCEPT ||\n\\n\\t\\t\\t\\t\\t\\t\\t\\t f.subclass == IAX_COMMAND_REJECT)
(5343,fr->callno)
(5344,if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(5345,callno)
(5346,f.subclass)
(5347,IAX_COMMAND_CALLTOKEN)
(5348,iaxsl)
(5349,)
(5350,x)
(5351,f.frametype == AST_FRAME_IAX)
(5352,1)
(5353,iaxs)
(5354,iaxs[iaxs[fr->callno]->bridgecallno])
(5355,ies)
(5356,fr->callno)
(5357,frametype)
(5358,construct_rr(iaxs[fr->callno], &pingied)
(5359,fr->callno)
(5360,peer)
(5361,secret)
(5362,AST_FRAME_IAX)
(5363,sin_addr)
(5364,iaxsl)
(5365,0)
(5366,ast_party_connected_line_free(&connected)
(5367,using_prefs)
(5368,var)
(5369,ies.vars)
(5370,iaxs[fr->callno]->rprefs)
(5371,f.subclass.integer != IAX_COMMAND_TXCNT)
(5372,iaxs)
(5373,iaxs)
(5374,vars)
(5375,tmp)
(5376,AST_FRAME_IAX)
(5377,1)
(5378,variablestore)
(5379,name)
(5380,iaxs)
(5381,owner)
(5382,callno)
(5383,ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability \'%s\'/\'%s\' incompatible with our capability \'%s\'.\\n",\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tast_inet_ntoa(sin.sin_addr)
(5384,prefs)
(5385,if (strcmp(iaxs[fr->callno]->exten, "TBD")
(5386,owner)
(5387,pref = iaxs[fr->callno]->prefs)
(5388,"IAX2 %s(%d)
(5389,iaxs[fr->callno]->owner)
(5390,iaxs[fr->callno]->videoformat)
(5391,tmp)
(5392,((f.subclass.integer != IAX_COMMAND_INVAL)
(5393,iaxs)
(5394,callno)
(5395,callno)
(5396,ied1)
(5397,sizeof(host_pref_buf)
(5398,format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
(5399,sin)
(5400,fr)
(5401,callno)
(5402,IAX_FLAG_RETRANS)
(5403,&iaxsl[fr->callno])
(5404,fr)
(5405,IAX_COMMAND_ACCEPT)
(5406,format)
(5407,iaxs)
(5408,iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno)
(5409,connected.id.name)
(5410,callno)
(5411,fr->callno)
(5412,iaxs)
(5413,3)
(5414,frametype)
(5415,&iaxsl[call_to_destroy])
(5416,f.subclass.integer != IAX_COMMAND_INVAL)
(5417,fr)
(5418,callno)
(5419,callno)
(5420,videoformat)
(5421,-1)
(5422,cause_code)
(5423,using_prefs)
(5424,iaxs[fr->callno])
(5425,0)
(5426,ied0.buf)
(5427,1)
(5428,subclass)
(5429,vars)
(5430,AST_FRAME_IAX)
(5431,"disabled")
(5432,tmp1)
(5433,ies)
(5434,ied0)
(5435,iaxs[fr->callno]->prefs)
(5436,iaxs)
(5437,iaxs[fr->callno])
(5438,callno)
(5439,vars)
(5440,iaxs)
(5441,callno)
(5442,fr)
(5443,fr->callno)
(5444,IAX_COMMAND_REJECT)
(5445,test_resync)
(5446,vars)
(5447,0)
(5448,fr->callno)
(5449,callno)
(5450,fr)
(5451,iaxs[fr->callno]->rprefs)
(5452,state)
(5453,capability)
(5454,f.subclass.integer)
(5455,ies.codec_prefs)
(5456,send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, pingied.buf, pingied.pos, -1)
(5457,iaxs[fr->callno]->owner)
(5458,iaxs[fr->callno]->frames_received)
(5459,iaxs)
(5460,variablestore->data = varlist)
(5461,(cur = AST_LIST_LAST(&frame_queue[fr->callno])
(5462,fh)
(5463,mh)
(5464,subclass)
(5465,iaxs[fr->callno])
(5466,!iaxs[fr->callno])
(5467,iaxs[fr->callno])
(5468,iaxs[fr->callno]->last = fr->ts)
(5469,-1)
(5470,callno)
(5471,1)
(5472,iaxs[fr->callno])
(5473,fr)
(5474,fr->callno)
(5475,caller_pref_buf)
(5476,ts)
(5477,ast_channel_readformat(iaxs[fr->callno]->owner)
(5478,callno)
(5479,iaxs)
(5480,cur->transfer)
(5481,ies.causecode > 99)
(5482,transferring)
(5483,0)
(5484,iaxs[fr->callno]->transferring)
(5485,fr)
(5486,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(5487,iaxdebug)
(5488,tmp2)
(5489,f.subclass.integer)
(5490,owner)
(5491,iaxs)
(5492,iseqno)
(5493,fr->callno)
(5494,callno)
(5495,data_size)
(5496,f)
(5497,iaxs[fr->callno]->transferring)
(5498,&iaxsl[fr->callno])
(5499,sizeof(host_pref_buf)
(5500,callno)
(5501,fr)
(5502,iaxs)
(5503,iaxs)
(5504,ast_getformatname(&f.subclass.format)
(5505,fr)
(5506,orignative)
(5507,ies)
(5508,case IAX_COMMAND_FWDOWNL:)
(5509,ntohs(vh->callno)
(5510,using_prefs = "reqonly")
(5511,&f)
(5512,iaxs)
(5513,&ied0)
(5514,f)
(5515,ies.vars = NULL)
(5516,break;)
(5517,iaxs[fr->callno]->cid_num)
(5518,"Received out of order packet... (type=%d, subclass %d, ts = %d, last = %d)
(5519,callno)
(5520,AST_DEVSTATE_CACHABLE)
(5521,1)
(5522,IAX_COMMAND_TXACC)
(5523,iaxsl[fr->callno])
(5524,!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)
(5525,variablestore && varlist)
(5526,iaxs[fr->callno])
(5527,ies)
(5528,strcpy(host_pref_buf, "disabled")
(5529,callno)
(5530,fr)
(5531,send_apathetic_reply(1, ntohs(fh->scallno)
(5532,if (ntohs(mh->callno)
(5533,fr)
(5534,unsigned char *)
(5535,0)
(5536,callno)
(5537,callno)
(5538,!iaxs[fr->callno])
(5539,iaxs)
(5540,AST_FRAME_IAX)
(5541,subclass)
(5542,subclass)
(5543,fr)
(5544,fr->callno)
(5545,ied0.pos)
(5546,callno)
(5547,iaxsl)
(5548,ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_CONGESTION)
(5549,prev)
(5550,peer->lastms)
(5551,AST_FRAME_CONTROL)
(5552,data_size)
(5553,integer)
(5554,callno)
(5555,ts)
(5556,)
(5557,varlist)
(5558,ast_channel_caller(iaxs[fr->callno]->owner)
(5559,f.data.ptr)
(5560,fr->callno)
(5561,fr)
(5562,"Destroying call %d\\n")
(5563,data)
(5564,"Accepted unauthenticated TBD call from %s\\n")
(5565,causecode)
(5566,f.subclass)
(5567,peer_unref(peer)
(5568,sin.sin_addr)
(5569,iaxs[iaxs[fr->callno]->bridgecallno])
(5570,if (authdebug)
(5571,iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec")
(5572,ies)
(5573,iaxs[fr->callno]->voiceformat)
(5574,&ied1)
(5575,iaxs)
(5576,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)
(5577,ts)
(5578,AST_CONTROL_UNHOLD)
(5579,callno)
(5580,data)
(5581,iaxs)
(5582,vars)
(5583,struct ast_iax2_full_hdr)
(5584,sin)
(5585,f)
(5586,iaxs)
(5587,iaxs[fr->callno])
(5588,iaxs)
(5589,callno)
(5590,iaxs)
(5591,cause)
(5592,ied0)
(5593,)
(5594,peer_ref(peer)
(5595,break;)
(5596,IAX_COMMAND_ACK)
(5597,peer)
(5598,callno)
(5599,format)
(5600,fr)
(5601,f)
(5602,fr)
(5603,username)
(5604,IAX_COMMAND_ACK)
(5605,fr)
(5606,name)
(5607,buf)
(5608,!fr->callno || !iaxs[fr->callno])
(5609,sizeof(*cause_code)
(5610,ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request \'%s@%s\' does not exist\\n", ast_inet_ntoa(sin.sin_addr)
(5611,fr->callno)
(5612,cid_num)
(5613,f.subclass)
(5614,spawn_dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num)
(5615,callno)
(5616,ast_strlen_zero(moh_suggest)
(5617,thread->buf)
(5618,iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
(5619,VERBOSE_PREFIX_4)
(5620,f)
(5621,if (authenticate_verify(iaxs[fr->callno], &ies)
(5622,fr)
(5623,fr->ts)
(5624,LOG_WARNING)
(5625,iax2_getformatname_multiple(tmp2, sizeof(tmp2)
(5626,iaxs)
(5627,varlist)
(5628,peercapability)
(5629,sin)
(5630,IAX_IE_CAUSECODE)
(5631,0)
(5632,0)
(5633,ast_inet_ntoa(sin.sin_addr)
(5634,fr)
(5635,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(5636,fr->callno)
(5637,)
(5638,context)
(5639,)
(5640,)
(5641,fr->callno)
(5642,ast_format_from_old_bitfield(&f.subclass.format, uncompress_subclass(fh->csub)
(5643,if (f.frametype == AST_FRAME_VOICE)
(5644,callno)
(5645,ied1)
(5646,ast_verb(3, "Accepting AUTHENTICATED call from %s:\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t"%srequested format = %s,\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t"%srequested prefs = %s,\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t"%sactual format = %s,\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t"%shost prefs = %s,\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t"%spriority = %s\\n", \n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tast_inet_ntoa(sin.sin_addr)
(5647,fr)
(5648,sizeof(sin)
(5649,iseqno)
(5650,IAX_STATE_TBD)
(5651,sizeof(struct ast_iax2_mini_hdr)
(5652,AST_FRAME_IAX)
(5653,using_prefs)
(5654,frametype)
(5655,dcallno == 1)
(5656,iaxs[fr->callno]->exten)
(5657,fr)
(5658,iax_ie_append_int(&ied1, IAX_IE_FORMAT, format)
(5659,callno)
(5660,iaxs)
(5661,fr)
(5662,f.subclass.format)
(5663,res - sizeof(*vh)
(5664,f)
(5665,send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1)
(5666,iax2_getformatname_multiple(tmp1, sizeof(tmp1)
(5667,fr)
(5668,fr->callno)
(5669,iaxs)
(5670,subclass)
(5671,"TBD")
(5672,state)
(5673,ies.vars)
(5674,iaxs[fr->callno]->rprefs)
(5675,&iaxs[fr->callno]->state)
(5676,AST_FRAME_IAX)
(5677,fr)
(5678,ies)
(5679,ts)
(5680,fr->callno)
(5681,)
(5682,sin_addr)
(5683,f.subclass.integer)
(5684,sizeof(ied0)
(5685,if (!AST_SCHED_DEL(sched, peer->pokeexpire)
(5686,f.subclass.integer)
(5687,if ((iaxs[fr->callno]->iseqno != fr->oseqno)
(5688,IAX_STATE_STARTED)
(5689,ast_inet_ntoa(sin.sin_addr)
(5690,iaxs)
(5691,"Cancelling transmission of packet %d\\n")
(5692,break;)
(5693,iax_parse_ies(&ies, thread->buf + sizeof(struct ast_iax2_full_hdr)
(5694,ies.calltoken && ies.calltokendata)
(5695,&sin)
(5696,fr->callno)
(5697,exists)
(5698,iaxs[fr->callno]->cid_num)
(5699,thread)
(5700,iaxs[fr->callno])
(5701,iaxs[fr->callno])
(5702,&sin)
(5703,sizeof(ied0)
(5704,iaxs)
(5705,iaxs[fr->callno])
(5706,AST_CONTROL_CONNECTED_LINE)
(5707,callno)
(5708,callno)
(5709,fr->callno)
(5710,"disabled")
(5711,integer)
(5712,!fr->callno)
(5713,callno)
(5714,&connected)
(5715,0)
(5716,0)
(5717,iaxs[fr->callno]->pingtime)
(5718,fr->af)
(5719,provverpres)
(5720,fr)
(5721,iaxs[fr->callno]->owner)
(5722,iaxs)
(5723,iaxs)
(5724,fr)
(5725,fr)
(5726,called_number)
(5727,iaxs[fr->callno])
(5728,iaxs[fr->callno])
(5729,fr)
(5730,f.subclass == IAX_COMMAND_ACCEPT)
(5731,6)
(5732,fr->callno)
(5733,fr->callno)
(5734,ast_log(LOG_WARNING, "Call rejected by %s: %s\\n",\n\\n\\t\\t\\t\\t\\t\\t\\tast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr)
(5735,f.subclass == IAX_COMMAND_NEW ||\n\\n\\t\\t\\t\\t\\t\\t\\t\\t f.subclass == IAX_COMMAND_AUTHREQ ||\n\\n\\t\\t\\t\\t\\t\\t\\t\\t f.subclass == IAX_COMMAND_ACCEPT ||\n\\n\\t\\t\\t\\t\\t\\t\\t\\t f.subclass == IAX_COMMAND_REJECT)
(5736,tmp)
(5737,IAX_STATE_STARTED | IAX_STATE_TBD | IAX_STATE_AUTHENTICATED)
(5738,iaxs)
(5739,f)
(5740,meta)
(5741,ts)
(5742,iaxs)
(5743,iaxs[fr->callno]->peercallno)
(5744,authdebug)
(5745,iaxs[fr->callno]->peerformat)
(5746,if (!iaxs[fr->callno])
(5747,f.data.ptr = thread->buf + sizeof(*vh)
(5748,"Accepting UNAUTHENTICATED call from %s:\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t"%srequested format = %s,\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t"%srequested prefs = %s,\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t"%sactual format = %s,\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t"%shost prefs = %s,\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t"%spriority = %s\\n")
(5749,1)
(5750,&ied0)
(5751,iaxsl[fr->callno])
(5752,fr)
(5753,fr->callno)
(5754,ast_verb(3, "Accepting DIAL from %s, formats = %s\\n",\n\\n\\t\\t\\t\\t\\t\\t\\tast_inet_ntoa(sin.sin_addr)
(5755,fr->callno)
(5756,iaxs)
(5757,fr->callno)
(5758,check_dcallno = 1)
(5759,fr->callno)
(5760,fh->scallno)
(5761,ast_datastore_alloc(&iax2_variable_datastore_info, NULL)
(5762,f)
(5763,&iaxs[fr->callno]->state)
(5764,fr)
(5765,iaxs)
(5766,fr)
(5767,sched)
(5768,fr)
(5769,memset(&sin, 0, sizeof(sin)
(5770,fr)
(5771,sin_addr)
(5772,99)
(5773,f)
(5774,iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
(5775,ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
(5776,fr)
(5777,)
(5778,iaxs[fr->callno])
(5779,fr)
(5780,exists)
(5781,&iaxs[fr->callno]->state)
(5782,iaxs[fr->callno]->iseqno)
(5783,sizeof(ied0)
(5784,f.subclass)
(5785,connected.id.number.str)
(5786,fr)
(5787,fr->callno)
(5788,if (ntohs(mh->callno)
(5789,f.subclass)
(5790,ast_mutex_unlock(&iaxsl[fr->callno])
(5791,ies)
(5792,break;)
(5793,thread)
(5794,iaxs[fr->callno])
(5795,ast_variables_destroy(ies.vars)
(5796,ies.vars)
(5797,(f.subclass.integer != IAX_COMMAND_TXACC)
(5798,fr)
(5799,peerformat)
(5800,fr)
(5801,callno)
(5802,iaxs[fr->callno]->capability)
(5803,using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(5804,callno)
(5805,integer)
(5806,callno)
(5807,!dcallno)
(5808,frametype)
(5809,)
(5810,0)
(5811,fr)
(5812,pref)
(5813,)
(5814,case IAX_COMMAND_DPREQ:)
(5815,videoformat)
(5816,iaxs)
(5817,fr->callno)
(5818,(iaxs[fr->callno]->last & 0xFFFF0000L)
(5819,final)
(5820,callno)
(5821,f.subclass)
(5822,if ((x != iaxs[fr->callno]->oseqno)
(5823,iaxs)
(5824,sizeof(tmp3)
(5825,iaxs)
(5826,iaxs[fr->callno])
(5827,AST_FRAME_VIDEO)
(5828,ied1)
(5829,var = var->next)
(5830,sizeof(*mh)
(5831,iaxs)
(5832,iaxs)
(5833,fr->callno)
(5834,TRANSFER_MBEGIN)
(5835,fr->callno)
(5836,struct ast_iax2_mini_hdr)
(5837,peerformat)
(5838,ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner)
(5839,iaxs[fr->callno])
(5840,iaxs[fr->callno])
(5841,if (!format)
(5842,frametype)
(5843,peer)
(5844,ied1)
(5845,callno)
(5846,iaxs[iaxs[fr->callno]->bridgecallno])
(5847,fr)
(5848,connected.id)
(5849,f.subclass)
(5850,iaxs)
(5851,iax2_destroy(fr->callno)
(5852,iaxs)
(5853,integer)
(5854,f.subclass.integer == IAX_COMMAND_ACK)
(5855,)
(5856,iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
(5857,callno)
(5858,empty[32]="")
(5859,var && var->next)
(5860,)
(5861,iaxsl[fr->callno])
(5862,fh->type == AST_FRAME_IAX &&\n\\n\\t\\t\\t(fh->csub == IAX_COMMAND_HANGUP\n\\n\\t\\t\\t|| fh->csub == IAX_COMMAND_REJECT\n\\n\\t\\t\\t|| fh->csub == IAX_COMMAND_REGREJ\n\\n\\t\\t\\t|| fh->csub == IAX_COMMAND_TXREJ)
(5863,if (iaxs[fr->callno]->owner)
(5864,var->name)
(5865,callno)
(5866,0xFFFF8000L)
(5867,ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)
(5868,callno)
(5869,iaxs[fr->callno])
(5870,iax2_vnak(fr->callno)
(5871,iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
(5872,iaxs)
(5873,iaxs)
(5874,sizeof(tmp3)
(5875,f.frametype)
(5876,fr)
(5877,if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)
(5878,pref = iaxs[fr->callno]->prefs)
(5879,&ied0)
(5880,0)
(5881,1)
(5882,callno)
(5883,sizeof(*fh)
(5884,scallno)
(5885,sizeof(tmp)
(5886,peer->lastms)
(5887,sizeof(ied0)
(5888,thread->buf)
(5889,iaxs[fr->callno])
(5890,break;)
(5891,iaxs[fr->callno])
(5892,iaxs)
(5893,if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)
(5894,sin.sin_addr)
(5895,iaxs[fr->callno])
(5896,fr->callno)
(5897,iaxs[fr->callno])
(5898,"Rejected connect attempt from %s, requested \'%s\' incompatible with our capability \'%s\'.\\n")
(5899,ast_verb(3, "Channel \'%s\' ready to transfer\\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner)
(5900,*vh)
(5901,iaxsl)
(5902,f.subclass.integer = uncompress_subclass(fh->csub)
(5903,ied0)
(5904,!iaxs[fr->callno])
(5905,ts)
(5906,iaxs)
(5907,LOG_NOTICE)
(5908,name)
(5909,iaxs[fr->callno])
(5910,IAX_COMMAND_ACK)
(5911,iaxs)
(5912,IAX_DELAYPBXSTART)
(5913,var)
(5914,iaxs[fr->callno]->last)
(5915,sizeof(tmp1)
(5916,buf)
(5917,ied1)
(5918,fr)
(5919,ies)
(5920,iaxs)
(5921,ies)
(5922,iaxs[fr->callno])
(5923,fr->callno)
(5924,callno)
(5925,subclass)
(5926,callno)
(5927,iaxs[fr->callno]->context)
(5928,f.subclass.integer != IAX_COMMAND_TXREADY)
(5929,memset(&ied0, 0, sizeof(ied0)
(5930,vars)
(5931,ied1)
(5932,ast_channel_datastore_add(c, variablestore)
(5933,capability)
(5934,iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
(5935,"Packet arrived out of order (expecting %d, got %d)
(5936,peerformat)
(5937,iaxs[fr->callno])
(5938,iaxs)
(5939,iaxs[fr->callno]->owner)
(5940,"Rejected connect attempt from %s, requested \'%s\' incompatible with our capability \'%s\'.\\n")
(5941,send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1)
(5942,iax_frame_wrap(fr, &f)
(5943,iaxs[fr->callno]->prefs)
(5944,iaxs[fr->callno])
(5945,fr->callno)
(5946,ts)
(5947,IAX_COMMAND_TXREJ)
(5948,iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
(5949,iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability)
(5950,f.subclass.integer != IAX_COMMAND_ACK)
(5951,peer)
(5952,f)
(5953,)
(5954,f.subclass)
(5955,fr)
(5956,fr)
(5957,send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
(5958,fr)
(5959,if (iaxdebug)
(5960,sin)
(5961,fr)
(5962,)
(5963,integer)
(5964,)
(5965,ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner)
(5966,variablestore->data = varlist)
(5967,break;)
(5968,res)
(5969,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)
(5970,iaxsl)
(5971,iaxs[fr->callno])
(5972,NEW_PREVENT)
(5973,iaxs[fr->callno]->exten)
(5974,thread->buf)
(5975,fr->callno)
(5976,0)
(5977,fr->callno)
(5978,id)
(5979,buf)
(5980,fr->callno)
(5981,callno)
(5982,AST_DEVICE_UNAVAILABLE)
(5983,tmp2)
(5984,f)
(5985,if (ies.format)
(5986,fr)
(5987,LOG_NOTICE)
(5988,fr->callno)
(5989,iaxs[fr->callno]->addr)
(5990,IAX_COMMAND_REGREL)
(5991,iaxs[fr->callno])
(5992,!iaxs[fr->callno] || !iaxs[fr->callno]->owner)
(5993,iaxs[fr->callno]->videoformat)
(5994,)
(5995,fr->callno)
(5996,iaxs[fr->callno])
(5997,sizeof(*vh)
(5998,fr)
(5999,)
(6000,callno)
(6001,meta)
(6002,iaxs[fr->callno]->last & 0xFFFF0000L)
(6003,fr->callno)
(6004,causecode)
(6005,fr->callno)
(6006,variablestore)
(6007,callno)
(6008,fr->callno)
(6009,iaxs[fr->callno])
(6010,)
(6011,AST_FRAME_IAX)
(6012,TRANSFER_BEGIN)
(6013,LOG_NOTICE)
(6014,iaxs[fr->callno])
(6015,subclass)
(6016,transferring)
(6017,str)
(6018,ast_inet_ntoa(sin.sin_addr)
(6019,callno)
(6020,iaxs)
(6021,0)
(6022,"<unknown>")
(6023,break;)
(6024,serviceident)
(6025,fr->callno)
(6026,f)
(6027,ntohl(fh->ts)
(6028,tmp3)
(6029,cause_code)
(6030,callno)
(6031,variablestore->inheritance = DATASTORE_INHERIT_FOREVER)
(6032,fh->csub == IAX_COMMAND_REGREJ)
(6033,owner)
(6034,f.subclass)
(6035,sin_addr)
(6036,thread->iofd)
(6037,AST_FRAME_IAX)
(6038,)
(6039,1)
(6040,iaxs[fr->callno])
(6041,src)
(6042,ast_mutex_unlock(&iaxsl[fr->callno])
(6043,frametype)
(6044,IAX_COMMAND_REJECT)
(6045,)
(6046,owner)
(6047,fr->callno = new_callno)
(6048,(iaxs[fr->callno]->iseqno != fr->oseqno)
(6049,mh)
(6050,fr)
(6051,iax_outputframe(NULL, fh, 3, &sin, res - sizeof(*fh)
(6052,capability)
(6053,IAX_COMMAND_REJECT)
(6054,sizeof(ied0)
(6055,sin)
(6056,!decrypted)
(6057,iaxs[fr->callno]->peerformat)
(6058,!format)
(6059,)
(6060,ast_verb(3, "Attempting media bridge of %s and %s\\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner)
(6061,f)
(6062,callno)
(6063,exten)
(6064,case IAX_COMMAND_ACCEPT:)
(6065,NULL)
(6066,&ied0)
(6067,var)
(6068,updatehistory=1)
(6069,fr)
(6070,-1)
(6071,iaxs[fr->callno]->pingtime)
(6072,"No such context/extension")
(6073,ies.cause)
(6074,&f.subclass.format)
(6075,f.subclass.integer)
(6076,callno)
(6077,IAX_COMMAND_INVAL)
(6078,using_prefs)
(6079,fr)
(6080,subclass)
(6081,ied0)
(6082,ast_format_to_old_bitfield(&f.subclass.format)
(6083,if ((iaxs[fr->callno]->transferring == TRANSFER_BEGIN)
(6084,connected.id)
(6085,1)
(6086,subclass)
(6087,tmp1)
(6088,ts)
(6089,)
(6090,f.subclass.integer != IAX_COMMAND_TXCNT)
(6091,)
(6092,fr)
(6093,1)
(6094,fr->callno)
(6095,iaxs)
(6096,call_to_destroy)
(6097,fr)
(6098,iaxs)
(6099,owner)
(6100,IAX_COMMAND_VNAK)
(6101,ies)
(6102,fr->callno)
(6103,ied1.pos)
(6104,0xffff)
(6105,f.subclass.integer)
(6106,iaxs)
(6107,ied0)
(6108,f.frametype == AST_FRAME_CONTROL && iaxs[fr->callno]->owner)
(6109,fr)
(6110,&ies)
(6111,connected.id)
(6112,mh)
(6113,LOG_WARNING)
(6114,callno)
(6115,varlist)
(6116,fr)
(6117,iaxsl)
(6118,if (ies.vars)
(6119,fr->callno)
(6120,iaxs[fr->callno]->context)
(6121,iaxsl)
(6122,f)
(6123,callno)
(6124,authdebug)
(6125,dp)
(6126,f)
(6127,ast_debug(1, "Ooh, video format changed to %s\\n", ast_getformatname(&f.subclass.format)
(6128,res > 0)
(6129,vars)
(6130,ied1)
(6131,fr)
(6132,"Peer %s lag measured as %dms\\n")
(6133,res < 0)
(6134,f.subclass)
(6135,if ((f.frametype == AST_FRAME_IAX)
(6136,iaxs)
(6137,iaxs[fr->callno])
(6138,if (owner)
(6139,iaxs[fr->callno])
(6140,fh)
(6141,"Hold")
(6142,fr)
(6143,fr)
(6144,fr)
(6145,iaxs[fr->callno]->capability)
(6146,callno)
(6147,)
(6148,fr->callno)
(6149,fr)
(6150,peer->name)
(6151,callno)
(6152,host_pref_buf)
(6153,fr)
(6154,if (iaxs[fr->callno] && iaxs[fr->callno]->owner)
(6155,if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)
(6156,f)
(6157,ied0)
(6158,dcallno != 1)
(6159,(f.subclass.integer != IAX_COMMAND_TXREL)
(6160,iaxdebug)
(6161,fr)
(6162,presentation)
(6163,callno)
(6164,)
(6165,ast_alloca(data_size)
(6166,owner)
(6167,peer)
(6168,data)
(6169,data_size)
(6170,f.subclass.integer)
(6171,subclass)
(6172,*mh)
(6173,f.subclass)
(6174,tmp2)
(6175,fr->callno)
(6176,capability)
(6177,voiceformat)
(6178,fr)
(6179,fr->ts = (iaxs[fr->callno]->last & 0xFFFF0000L)
(6180,callno)
(6181,fh->ts)
(6182,return 1;)
(6183,ast_variables_destroy(ies.vars)
(6184,)
(6185,if ((f.frametype != AST_FRAME_IAX)
(6186,!iaxs[fr->callno])
(6187,iaxsl[fr->callno])
(6188,-1)
(6189,if (ies.codec_prefs)
(6190,fr)
(6191,ast_alloca(sizeof(*fr)
(6192,"Unable to negotiate codec")
(6193,f.subclass)
(6194,sin)
(6195,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(6196,iseqno)
(6197,(struct ast_iax2_meta_hdr *)
(6198,peer->historicms)
(6199,AST_LIST_INSERT_TAIL(varlist, newvar, entries)
(6200,1)
(6201,iaxs)
(6202,fr->oseqno)
(6203,"caller")
(6204,context)
(6205,ies.called_number)
(6206,)
(6207,log_jitterstats(fr->callno)
(6208,iaxs[fr->callno])
(6209,ied0.pos)
(6210,rprefs)
(6211,callno)
(6212,sin_port)
(6213,iax2_getformatname_multiple(tmp3, sizeof(tmp3)
(6214,iaxs)
(6215,iaxs)
(6216,ast_var_assign(var->name, var->value)
(6217,ts)
(6218,fr->callno)
(6219,pos)
(6220,iaxs)
(6221,fr)
(6222,ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)
(6223,callno)
(6224,iaxs[fr->callno]->username)
(6225,iaxs[fr->callno]->rseqno >= iaxs[fr->callno]->oseqno || (fr->iseqno >= iaxs[fr->callno]->rseqno && fr->iseqno < iaxs[fr->callno]->oseqno)
(6226,ied0)
(6227,sin)
(6228,peer)
(6229,&iaxsl[fr->callno])
(6230,if (iaxs[fr->callno]->owner)
(6231,fr)
(6232,ied0.buf)
(6233,IAX_COMMAND_REGREQ)
(6234,&ied1)
(6235,"Immediately destroying %d, having received hangup\\n")
(6236,authdebug)
(6237,callno)
(6238,fr->callno)
(6239,owner)
(6240,pos)
(6241,&ied0)
(6242,fr)
(6243,iaxs)
(6244,iaxs[fr->callno])
(6245,IAX_IE_CAUSE)
(6246,iaxs[fr->callno]->owner)
(6247,peer->historicms)
(6248,fr)
(6249,send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1)
(6250,iaxs)
(6251,AST_FRAME_IAX)
(6252,iaxs[fr->callno]->transferring)
(6253,rseqno)
(6254,&ies)
(6255,iaxs)
(6256,integer)
(6257,tmp2)
(6258,iaxs)
(6259,iaxs)
(6260,using_prefs = "caller")
(6261,callno)
(6262,fr->callno)
(6263,mh)
(6264,iaxs[fr->callno] && iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno)
(6265,addr)
(6266,)
(6267,pref)
(6268,var)
(6269,fr)
(6270,iaxs[fr->callno]->oseqno)
(6271,format)
(6272,iaxs[fr->callno])
(6273,peerformat)
(6274,name)
(6275,)
(6276,iaxs)
(6277,fr->cacheable)
(6278,fr)
(6279,test_resync)
(6280,cur)
(6281,tmp2)
(6282,fr)
(6283,f)
(6284,codec_prefs)
(6285,fr->callno)
(6286,bridgecallno)
(6287,peercapability)
(6288,iax2_getformatname_multiple(tmp3, sizeof(tmp3)
(6289,iaxs[fr->callno])
(6290,iaxs[fr->callno])
(6291,callno)
(6292,number)
(6293,callno)
(6294,ast_channel_ref(owner)
(6295,&f.subclass.format)
(6296,iaxs[fr->callno])
(6297,variablestore)
(6298,iaxs[fr->callno]->capability)
(6299,iaxs[fr->callno])
(6300,&tmpfmt)
(6301,ies.cause ? ies.cause : "<unknown>")
(6302,fr->callno)
(6303,secret)
(6304,return 1;)
(6305,native)
(6306,f.src = "IAX2")
(6307,callno)
(6308,ied0)
(6309,frametype)
(6310,iaxs)
(6311,fr)
(6312,called_number)
(6313,callno)
(6314,ast_log(LOG_WARNING, "Rejecting packet from \'%s.%d\' that is flagged as a video frame but is too short\\n", ast_inet_ntoa(sin.sin_addr)
(6315,fr)
(6316,f.data.ptr = thread->buf + sizeof(struct ast_iax2_full_hdr)
(6317,ast_channel_unlock(iaxs[fr->callno]->owner)
(6318,ast_strlen_zero(iaxs[fr->callno]->secret)
(6319,callno)
(6320,callno)
(6321,fr)
(6322,f)
(6323,iaxs[fr->callno] && ast_test_flag64(iaxs[fr->callno], IAX_ENCRYPTED)
(6324,iaxs[fr->callno]->reg->username)
(6325,f.data.ptr = empty)
(6326,break;)
(6327,AST_FRAME_IAX)
(6328,fr->callno)
(6329,ast_frame_byteswap_be(&f)
(6330,fr)
(6331,IAX_COMMAND_TXCNT)
(6332,fr)
(6333,callno)
(6334,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)
(6335,)
(6336,"Peer did not understand our iax command \'%d\'\\n")
(6337,IAX_IE_CALLNO)
(6338,buf)
(6339,case IAX_COMMAND_AUTHREQ:)
(6340,callno)
(6341,fh)
(6342,NULL)
(6343,ast_bridged_channel(iaxs[fr->callno]->owner)
(6344,context = ast_strdupa(iaxs[fr->callno]->context)
(6345,fd)
(6346,ast_getformatname(&f.subclass.format)
(6347,break;)
(6348,fr->callno)
(6349,id)
(6350,&ies)
(6351,fr->callno)
(6352,fh)
(6353,fr->callno)
(6354,IAX_AUTH_MD5)
(6355,frametype)
(6356,iaxs)
(6357,offset)
(6358,integer)
(6359,bridged_chan)
(6360,sizeof(ied0)
(6361,f)
(6362,iaxs)
(6363,challenge)
(6364,&tmpfmt)
(6365,fh->ts)
(6366,iaxs[fr->callno])
(6367,ies.vars)
(6368,iaxs[fr->callno])
(6369,bridged_chan)
(6370,0)
(6371,ied0)
(6372,frametype)
(6373,peercallno)
(6374,callno)
(6375,iaxs[fr->callno]->owner)
(6376,0)
(6377,&iaxs[fr->callno]->addr)
(6378,ast_channel_name(iaxs[fr->callno]->owner)
(6379,sizeof(*vh)
(6380,1)
(6381,owner)
(6382,hangup_fr)
(6383,subclass)
(6384,)
(6385,)
(6386,if (!ast_test_flag64(iaxs[fr->callno], IAX_RECVCONNECTEDLINE)
(6387,varlist)
(6388,&sin)
(6389,)
(6390,iaxs[fr->callno])
(6391,fr->callno)
(6392,f.subclass.integer)
(6393,callno)
(6394,fr)
(6395,callno)
(6396,iaxdebug)
(6397,vars)
(6398,ast_debug(1, "Async goto of \'%s\' to \'%s@%s\' started\\n",\n\\n\\t\\t\\t\\t\\t\\t\\t\\tast_channel_name(bridged_chan)
(6399,integer)
(6400,connected)
(6401,ies.vars)
(6402,ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\\n")
(6403,callno)
(6404,!ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num)
(6405,iaxs[fr->callno])
(6406,break;)
(6407,iaxs)
(6408,ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\\n")
(6409,peer)
(6410,mh->callno)
(6411,fr)
(6412,tmp2)
(6413,vh->callno)
(6414,addr)
(6415,IAX_STATE_TBD)
(6416,ies.vars)
(6417,fr)
(6418,ast_variables_destroy(ies.vars)
(6419,iaxs)
(6420,fr)
(6421,oseqno)
(6422,reg)
(6423,iaxs[fr->callno]->pingtime)
(6424,callno)
(6425,AST_FRAME_VOICE)
(6426,callno)
(6427,connected.id.name.presentation)
(6428,"Channel \'%s\' ready to transfer\\n")
(6429,0)
(6430,(ntohs(vh->ts)
(6431,f.frametype = fh->type)
(6432,ast_test_flag64(&globalflags, IAX_ALLOWFWDOWNLOAD)
(6433,ied0)
(6434,iaxs[fr->callno]->bridgecallno)
(6435,ntohs(fh->dcallno)
(6436,iaxs[fr->callno]->capability)
(6437,fh)
(6438,peercapability)
(6439,fr)
(6440,iaxs[fr->callno])
(6441,zeros)
(6442,case IAX_COMMAND_TXCNT:)
(6443,IAX_COMMAND_FWDATA)
(6444,number)
(6445,iaxs)
(6446,)
(6447,fr)
(6448,fr)
(6449,fr)
(6450,f.subclass.integer)
(6451,0)
(6452,fr)
(6453,owner)
(6454,iaxs[fr->callno])
(6455,cur->retries = -1)
(6456,fd)
(6457,f)
(6458,variablestore)
(6459,peer)
(6460,iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension")
(6461,iaxs[fr->callno])
(6462,IAX_CODEC_NOCAP)
(6463,pref)
(6464,smoothing)
(6465,f.frametype)
(6466,c)
(6467,ast_debug(1, "Destroying call %d\\n", fr->callno)
(6468,fr)
(6469,f)
(6470,integer)
(6471,fr)
(6472,0)
(6473,subclass)
(6474,)
(6475,empty)
(6476,ies)
(6477,if (f.datalen && (f.frametype == AST_FRAME_VOICE)
(6478,&iaxsl[fr->callno])
(6479,f.subclass.integer != IAX_COMMAND_TXCNT)
(6480,IAX_PROVISION)
(6481,AST_FRAME_IAX)
(6482,fr->ts)
(6483,iaxs[fr->callno])
(6484,fr)
(6485,f)
(6486,callno)
(6487,iaxs)
(6488,ast_mutex_lock(&iaxsl[call_to_destroy])
(6489,f.subclass)
(6490,"Rejected connect attempt from %s, requested/capability \'%s\'/\'%s\' incompatible with our capability \'%s\'.\\n")
(6491,f.frametype != AST_FRAME_IAX)
(6492,transferring)
(6493,fr->callno)
(6494,LOG_WARNING)
(6495,iaxs[fr->callno])
(6496,ast_mutex_lock(&iaxsl[fr->callno])
(6497,fr->callno)
(6498,variablestore)
(6499,NULL)
(6500,ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0)
(6501,ied0.buf)
(6502,owner)
(6503,ast_inet_ntoa(sin.sin_addr)
(6504,owner)
(6505,&ied0)
(6506,ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
(6507,sizeof(*fr)
(6508,iaxs[fr->callno]->capability)
(6509,&iaxsl[fr->callno])
(6510,fr->callno)
(6511,integer)
(6512,f.frametype == AST_FRAME_CONTROL && f.subclass.integer == AST_CONTROL_CONNECTED_LINE)
(6513,csub)
(6514,ied0)
(6515,fr->callno)
(6516,fr)
(6517,f.frametype)
(6518,thread->buf)
(6519,var)
(6520,frametype)
(6521,NULL)
(6522,iaxs[fr->callno])
(6523,&iaxs[fr->callno]->rprefs)
(6524,fr)
(6525,fr)
(6526,codec_prefs)
(6527,iaxs[iaxs[fr->callno]->bridgecallno])
(6528,fh)
(6529,ast_debug(1, "Async goto not applicable on call %d\\n", fr->callno)
(6530,fr->callno)
(6531,sin)
(6532,ast_format_id_from_old_bitfield(iaxs[fr->callno]->videoformat)
(6533,ast_inet_ntoa(sin.sin_addr)
(6534,iaxs)
(6535,IAX_COMMAND_UNQUELCH)
(6536,fr)
(6537,fh)
(6538,iaxs)
(6539,)
(6540,res)
(6541,moh_suggest)
(6542,callno)
(6543,ast_debug(1, "I can haz IAX vars?\\n")
(6544,ts)
(6545,LOG_WARNING)
(6546,peer->historicms <= peer->maxms)
(6547,peer)
(6548,new_peercallno)
(6549,ies)
(6550,iaxdebug)
(6551,callno)
(6552,IAX_COMMAND_FWDOWNL)
(6553,fr)
(6554,)
(6555,)
(6556,for (var = ies.vars; var; var = var->next)
(6557,sin)
(6558,cur->oseqno)
(6559,ast_inet_ntoa(sin.sin_addr)
(6560,cur->retries)
(6561,ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)
(6562,f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_NEW)
(6563,connected)
(6564,prev)
(6565,fr)
(6566,f.frametype != AST_FRAME_VOICE)
(6567,iaxs[fr->callno])
(6568,iaxs[fr->callno]->context)
(6569,fr->callno)
(6570,iaxs)
(6571,iaxs[fr->callno]->addr.sin_addr)
(6572,)
(6573,buf)
(6574,ies.vars)
(6575,3)
(6576,callno)
(6577,f.len = 0)
(6578,callno)
(6579,callno)
(6580,iaxs[fr->callno]->bridgecallno)
(6581,if (cur->final)
(6582,fr)
(6583,buf)
(6584,iaxs)
(6585,NULL)
(6586,callno)
(6587,iaxs[fr->callno])
(6588,)
(6589,)
(6590,fr)
(6591,iaxs[fr->callno])
(6592,ast_format_to_old_bitfield(&f.subclass.format)
(6593,fr)
(6594,ast_channel_unref(bridged_chan)
(6595,var)
(6596,)
(6597,ies.serviceident)
(6598,fr)
(6599,-1)
(6600,iaxs)
(6601,iaxs)
(6602,AST_FRAME_IAX)
(6603,pingtime)
(6604,ied0)
(6605,callno)
(6606,iaxsl[fr->callno])
(6607,fr->callno)
(6608,if (!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)
(6609,AST_FRAME_TEXT)
(6610,format)
(6611,iaxs[fr->callno])
(6612,refresh)
(6613,ast_debug(1, "Immediately destroying %d, having received reject\\n",\n\\n\\t\\t\\t\\t\\t\\tfr->callno)
(6614,f)
(6615,integer)
(6616,callno)
(6617,res)
(6618,sin_addr)
(6619,sin)
(6620,fr->callno)
(6621,sizeof(ies)
(6622,iaxs)
(6623,break;)
(6624,)
(6625,fr)
(6626,iaxs[fr->callno])
(6627,flags)
(6628,fr)
(6629,fr)
(6630,iaxs)
(6631,data)
(6632,AST_FRAME_IAX)
(6633,frametype)
(6634,IAX_COMMAND_ACK)
(6635,fr)
(6636,fr)
(6637,iaxs[fr->callno])
(6638,iaxs)
(6639,connected)
(6640,fr->callno)
(6641,if (update_registry(&sin, fr->callno, ies.devicetype, fd, ies.refresh)
(6642,f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_POKE)
(6643,)
(6644,"Memory allocation error while processing IAX2 variables\\n")
(6645,iaxs[fr->callno])
(6646,prev)
(6647,format)
(6648,!iaxs[fr->callno])
(6649,f)
(6650,1)
(6651,iaxs)
(6652,thread)
(6653,bridgecallno)
(6654,1)
(6655,)
(6656,tmp)
(6657,ies)
(6658,&sin)
(6659,fr->callno)
(6660,mohsuggest)
(6661,fr)
(6662,if (f.frametype == AST_FRAME_TEXT && thread->buf[res - 1] != \'\\0\')
(6663,iaxs)
(6664,iaxs)
(6665,fr)
(6666,error)
(6667,newvar)
(6668,callno)
(6669,frames_received)
(6670,fr)
(6671,NULL)
(6672,fr->callno)
(6673,peer->smoothing)
(6674,iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner)
(6675,ies)
(6676,fr)
(6677,1)
(6678,iaxs)
(6679,callno)
(6680,fd)
(6681,subclass)
(6682,iaxs[fr->callno]->exten)
(6683,AST_DEVSTATE_CACHABLE)
(6684,)
(6685,iaxs)
(6686,vars)
(6687,0)
(6688,&ied0)
(6689,"Unable to negotiate codec")
(6690,callno)
(6691,IAX_STATE_STARTED | IAX_STATE_TBD)
(6692,x == cur->oseqno)
(6693,iaxs[fr->callno]->transferring)
(6694,)
(6695,IAX_COMMAND_ACK)
(6696,iaxs[fr->callno]->capability)
(6697,thread->buf[res - 1] != \'\\0\')
(6698,(f.subclass.integer != IAX_COMMAND_INVAL)
(6699,callno)
(6700,ied1)
(6701,format)
(6702,fr->ts)
(6703,iaxs[fr->callno]->owner)
(6704,iseqno)
(6705,fr->callno)
(6706,f.subclass.integer)
(6707,fr)
(6708,fr)
(6709,f.subclass)
(6710,fr)
(6711,(iaxs[fr->callno]->last & 0xFFFF8000L)
(6712,fr)
(6713,fr->callno)
(6714,datalen)
(6715,fr)
(6716,tmp)
(6717,LOG_NOTICE)
(6718,decrypt_frame(fr->callno, fh, &f, &res)
(6719,if ((vh->zeros == 0)
(6720,)
(6721,ast_strdupa(iaxs[fr->callno]->context)
(6722,iaxs)
(6723,callno)
(6724,iaxs[fr->callno])
(6725,callno)
(6726,ast_bridged_channel(owner)
(6727,if (!iaxs[fr->callno])
(6728,fr->callno)
(6729,connected.id.number.valid)
(6730,f.datalen)
(6731,peer->lastms < 0)
(6732,iaxs[fr->callno])
(6733,iaxs[fr->callno]->owner)
(6734,if (iaxdebug)
(6735,break;)
(6736,fr->callno)
(6737,(unsigned char *)
(6738,fr->callno > 0)
(6739,iaxs[fr->callno]->oseqno)
(6740,var)
(6741,iax2_destroy(fr->callno)
(6742,)
(6743,iaxs[fr->callno]->dcx)
(6744,iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec")
(6745,duped_fr)
(6746,res - sizeof(struct ast_iax2_mini_hdr)
(6747,NULL)
(6748,fr->callno)
(6749,&iaxs[fr->callno]->state)
(6750,ied0.pos)
(6751,iaxs[fr->callno])
(6752,iaxs[fr->callno]->last = fr->ts)
(6753,callno)
(6754,)
(6755,prev)
(6756,ied0)
(6757,peer->pokeexpire)
(6758,fr->callno)
(6759,fr)
(6760,if (delayreject)
(6761,fr)
(6762,fr)
(6763,ts)
(6764,iaxs)
(6765,)
(6766,LOG_NOTICE)
(6767,f.subclass.integer != IAX_COMMAND_ACK &&\n\\n                            f.subclass.integer != IAX_COMMAND_PONG &&\n\\n                            f.subclass.integer != IAX_COMMAND_LAGRP)
(6768,tmpfmt)
(6769,AST_CAUSE_NO_ROUTE_DESTINATION)
(6770,&ies)
(6771,iaxs[fr->callno]->peercapability)
(6772,IAX_STATE_AUTHENTICATED)
(6773,!IAX_CALLENCRYPTED(iaxs[fr->callno])
(6774,fh)
(6775,iaxs[fr->callno]->state)
(6776,using_prefs = "caller")
(6777,f.mallocd = 0)
(6778,IAX_COMMAND_VNAK)
(6779,callno)
(6780,1)
(6781,fr)
(6782,res - sizeof(*fh)
(6783,iaxs[fr->callno]->pingtime + peer->historicms)
(6784,4096)
(6785,peer->pokefreqnotok)
(6786,f.subclass.integer)
(6787,(f.subclass.integer != IAX_COMMAND_INVAL)
(6788,csub)
(6789,f)
(6790,f.subclass)
(6791,ast_log(LOG_NOTICE, "Rejected call to %s, format %s incompatible with our capability %s.\\n",\n\\n\\t\\t\\t\\t\\t\\t\\tast_inet_ntoa(sin.sin_addr)
(6792,send_apathetic_reply(1, ntohs(fh->scallno)
(6793,fr)
(6794,0)
(6795,&sin)
(6796,iaxs)
(6797,if (iaxs[fr->callno]->transferring == TRANSFER_BEGIN)
(6798,integer)
(6799,f)
(6800,fr)
(6801,fr)
(6802,iaxs[fr->callno]->owner)
(6803,fr)
(6804,peerformat)
(6805,ies)
(6806,context)
(6807,callno)
(6808,fr)
(6809,callno)
(6810,iaxs[fr->callno]->oseqno)
(6811,datalen)
(6812,ied0.buf)
(6813,iaxs)
(6814,callno)
(6815,ast_variables_destroy(ies.vars)
(6816,fr)
(6817,fh->iseqno)
(6818,iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner)
(6819,iseqno)
(6820,DATASTORE_INHERIT_FOREVER)
(6821,peercapability)
(6822,break;)
(6823,ied0)
(6824,fr)
(6825,iaxs)
(6826,)
(6827,cid_num)
(6828,callno)
(6829,updatehistory)
(6830,fr->callno)
(6831,callno)
(6832,entries)
(6833,callno)
(6834,1)
(6835,f)
(6836,iaxs[fr->callno]->last & 0xFFFF8000L)
(6837,&ied0)
(6838,)
(6839,ies)
(6840,ies)
(6841,callno)
(6842,iaxs[fr->callno])
(6843,AST_CAUSE_FACILITY_NOT_SUBSCRIBED)
(6844,check_dcallno = 0)
(6845,1)
(6846,integer)
(6847,iaxs[fr->callno])
(6848,tmpfmt)
(6849,iaxs[fr->callno]->peerformat)
(6850,fh->csub == IAX_COMMAND_HANGUP)
(6851,iaxs)
(6852,ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD)
(6853,fr->ts)
(6854,iaxs)
(6855,var)
(6856,iseqno)
(6857,IAX_PROVISION)
(6858,"Really destroying %d, having been acked on final message\\n")
(6859,if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)
(6860,&ies)
(6861,maxms)
(6862,iaxs[fr->callno])
(6863,varlist)
(6864,iaxs[fr->callno])
(6865,fr)
(6866,iaxs[fr->callno]->peerformat)
(6867,fr)
(6868,iaxs[fr->callno]->owner)
(6869,fr)
(6870,ts)
(6871,fr->callno)
(6872,ast_mutex_unlock(&iaxsl[fr->callno])
(6873,iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec")
(6874,ntohs(mh->callno)
(6875,prev)
(6876,peer)
(6877,ies)
(6878,fr)
(6879,"<Unknown>")
(6880,iaxs[fr->callno])
(6881,"Attempting media bridge of %s and %s\\n")
(6882,connected.id)
(6883,fr->callno)
(6884,ast_log(LOG_WARNING, "Received mini frame before first full video frame\\n")
(6885,ies)
(6886,next)
(6887,iaxs[fr->callno])
(6888,)
(6889,fh->iseqno)
(6890,&pref)
(6891,LOG_ERROR)
(6892,sched)
(6893,addr)
(6894,f.subclass)
(6895,iaxs)
(6896,iaxs[fr->callno])
(6897,if (iaxdebug && iaxs[fr->callno])
(6898,bridgecallno)
(6899,iaxs[fr->callno]->peerformat)
(6900,iaxs[fr->callno])
(6901,for (var = ies.vars; var; var = var->next)
(6902,fr)
(6903,iaxs)
(6904,fr)
(6905,ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE)
(6906,0)
(6907,iaxs[fr->callno])
(6908,LOG_NOTICE)
(6909,0x1)
(6910,)
(6911,integer)
(6912,fr->callno)
(6913,if (f.subclass.integer == IAX_COMMAND_LAGRQ)
(6914,5)
(6915,ntohs(fh->dcallno)
(6916,callno)
(6917,subclass)
(6918,if (((f.subclass.integer != IAX_COMMAND_ACK)
(6919,IAX_IE_CAUSE)
(6920,IAX_COMMAND_TXREL)
(6921,1)
(6922,ies.serviceident)
(6923,iaxs)
(6924,sizeof(caller_pref_buf)
(6925,f.subclass)
(6926,)
(6927,if ((ntohs(mh->callno)
(6928,iaxsl[fr->callno])
(6929,sin)
(6930,peer->pokeexpire)
(6931,f.subclass.integer != IAX_COMMAND_TXREADY)
(6932,var->name)
(6933,iaxs)
(6934,callno)
(6935,frametype)
(6936,fr)
(6937,iaxs[fr->callno])
(6938,res < thread->buf_size)
(6939,fr->callno)
(6940,ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner)
(6941,bridged_chan)
(6942,iaxs[fr->callno]->owner)
(6943,if (iaxs[fr->callno])
(6944,if (check_access(fr->callno, &sin, &ies)
(6945,*fh)
(6946,callno)
(6947,if (!iaxs[fr->callno])
(6948,peer->callno = 0)
(6949,fr->callno)
(6950,callno)
(6951,iaxs[fr->callno])
(6952,iaxs[fr->callno])
(6953,iaxs[fr->callno]->secret)
(6954,for (x=iaxs[fr->callno]->rseqno; x != fr->iseqno; x++)
(6955,variablestore)
(6956,fr)
(6957,NULL)
(6958,iaxs[fr->callno]->videoformat > 0)
(6959,iaxs[fr->callno])
(6960,iaxs[fr->callno])
(6961,0)
(6962,ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf)
(6963,&ied0)
(6964,!exists)
(6965,fr)
(6966,using_prefs)
(6967,authenticate_reply(iaxs[fr->callno], &iaxs[fr->callno]->addr, &ies, iaxs[fr->callno]->secret, iaxs[fr->callno]->outkey)
(6968,fr->callno)
(6969,name)
(6970,case IAX_COMMAND_TXACC:)
(6971,callno)
(6972,ts)
(6973,callno)
(6974,fr->callno)
(6975,iaxs[fr->callno])
(6976,fr)
(6977,buf)
(6978,S_OR(moh_suggest, NULL)
(6979,data)
(6980,ptr)
(6981,iaxs[fr->callno]->transferring)
(6982,subclass)
(6983,integer)
(6984,iaxs)
(6985,*prev = NULL)
(6986,context)
(6987,check_provisioning(&sin, fd, ies.serviceident, ies.provver)
(6988,thread->buf[res - 1])
(6989,if (cur->transfer)
(6990,hold_signaling)
(6991,1)
(6992,1)
(6993,AST_FRAME_IAX)
(6994,ies.codec_prefs)
(6995,pref)
(6996,fh->csub)
(6997,fr)
(6998,iaxs[fr->callno]->reg)
(6999,iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)
(7000,variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL)
(7001,integer)
(7002,1)
(7003,fr)
(7004,*fh = (struct ast_iax2_full_hdr *)
(7005,sizeof(pref)
(7006,subclass)
(7007,iaxs)
(7008,tmp1)
(7009,f)
(7010,ptr)
(7011,ast_mutex_unlock(&iaxsl[fr->callno])
(7012,sizeof(tmp1)
(7013,1)
(7014,peer->name)
(7015,ast_inet_ntoa(sin.sin_addr)
(7016,fr->callno)
(7017,iaxs[fr->callno]->last < fr->ts)
(7018,"caller")
(7019,varlist)
(7020,fr)
(7021,iaxs[iaxs[fr->callno]->bridgecallno])
(7022,)
(7023,connected.id.name.str)
(7024,if (peer->pokeexpire == -1)
(7025,fr)
(7026,LOG_WARNING)
(7027,fr)
(7028,fr)
(7029,sizeof(*fh)
(7030,fr->callno)
(7031,fwdesc)
(7032,IAX_COMMAND_ACK)
(7033,fr->ts)
(7034,&ied1)
(7035,iaxs[fr->callno]->initid)
(7036,datalen)
(7037,AST_FRAME_IAX)
(7038,callno)
(7039,&iaxs[fr->callno]->state)
(7040,)
(7041,callno)
(7042,iaxs[fr->callno])
(7043,fr->callno)
(7044,break;)
(7045,if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(7046,return 1;)
(7047,iaxs)
(7048,iaxs)
(7049,fr->af)
(7050,len)
(7051,fr)
(7052,)
(7053,callno)
(7054,iaxs)
(7055,fr->callno)
(7056,iaxs[fr->callno])
(7057,&sin)
(7058,callno)
(7059,"No best format in \'%s\'???\\n")
(7060,iaxs[fr->callno]->bridgecallno)
(7061,iaxs[fr->callno])
(7062,iaxs[fr->callno]->owner && ast_test_flag64(iaxs[fr->callno], IAX_QUELCH)
(7063,iaxs[fr->callno])
(7064,name)
(7065,mount_callid)
(7066,case IAX_COMMAND_VNAK:)
(7067,iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1)
(7068,csub)
(7069,fr)
(7070,sin)
(7071,using_prefs)
(7072,bridgecallno)
(7073,ts)
(7074,callno)
(7075,owner)
(7076,fr->callno)
(7077,return 1;)
(7078,if ((ast_strlen_zero(iaxs[fr->callno]->secret)
(7079,ies.username ? ies.username : "<unknown>")
(7080,fr)
(7081,historicms)
(7082,varlist)
(7083,ast_callid_threadassoc_add(mount_callid)
(7084,callno)
(7085,ies)
(7086,format)
(7087,AST_FRAME_IAX)
(7088,datalen)
(7089,fr->callno)
(7090,"Neat, somebody took away the channel at a magical time but i found it!\\n")
(7091,iaxs[fr->callno])
(7092,iaxs[fr->callno]->peercallno)
(7093,fr->callno)
(7094,break;)
(7095,iaxs)
(7096,iaxs[fr->callno])
(7097,iaxs[fr->callno]->state)
(7098,fr->callno)
(7099,fr)
(7100,f.subclass.integer)
(7101,)
(7102,f)
(7103,variablestore->data = varlist)
(7104,iaxs)
(7105,addr)
(7106,1)
(7107,tmp2)
(7108,iaxs)
(7109,ied1)
(7110,0)
(7111,oseqno)
(7112,pingtime)
(7113,&pref)
(7114,callno)
(7115,f.subclass.integer)
(7116,1)
(7117,fr->callno)
(7118,mh->callno)
(7119,memset(&ied0, 0, sizeof(ied0)
(7120,callno)
(7121,ies)
(7122,iaxs[fr->callno])
(7123,if (!ast_connected_line_parse_data(f.data.ptr, f.datalen, &connected)
(7124,ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED)
(7125,memset(fr, 0, sizeof(*fr)
(7126,fr)
(7127,pingtime)
(7128,callno)
(7129,sin)
(7130,fr)
(7131,fr->callno)
(7132,fr->callno)
(7133,ied0)
(7134,capability)
(7135,fr)
(7136,0)
(7137,f.data.ptr)
(7138,fr->af.subclass.integer = IAX_COMMAND_LAGRP)
(7139,x)
(7140,addr)
(7141,iaxs[fr->callno]->calling_pres)
(7142,callno)
(7143,fr->callno)
(7144,pref)
(7145,1)
(7146,fr)
(7147,break;)
(7148,f.subclass.integer)
(7149,iaxs)
(7150,thread->buf + sizeof(struct ast_iax2_full_hdr)
(7151,iaxs[fr->callno])
(7152,)
(7153,ied0)
(7154,iaxs[fr->callno]->owner)
(7155,f.subclass)
(7156,f.frametype != AST_FRAME_IAX)
(7157,0)
(7158,iseqno)
(7159,fr->callno)
(7160,inaddrcmp(&sin, &iaxs[fr->callno]->addr)
(7161,f.data)
(7162,bridged_chan)
(7163,rseqno)
(7164,callno)
(7165,frametype)
(7166,fr->callno)
(7167,iaxs[fr->callno])
(7168,1)
(7169,callno)
(7170,NEW_PREVENT)
(7171,iaxs[fr->callno])
(7172,fr->callno)
(7173,)
(7174,ast_channel_name(iaxs[fr->callno]->owner)
(7175,AST_FRAME_CONTROL)
(7176,subclass)
(7177,fr)
(7178,&fr->af)
(7179,ies.provverpres && ies.serviceident && sin.sin_addr.s_addr)
(7180,fr)
(7181,fr)
(7182,IAX_COMMAND_REJECT)
(7183,callno)
(7184,owner)
(7185,fr)
(7186,inaddrcmp(&sin, &iaxs[fr->callno]->addr)
(7187,owner)
(7188,iaxs[fr->callno]->capability)
(7189,fd)
(7190,callno)
(7191,iaxs[fr->callno])
(7192,fh->dcallno)
(7193,vars)
(7194,&pingied)
(7195,ied1)
(7196,peer->historicms > peer->maxms)
(7197,ies)
(7198,1)
(7199,)
(7200,ied0)
(7201,frametype)
(7202,strcmp(iaxs[fr->callno]->exten, "TBD")
(7203,IAX_IE_CAUSE)
(7204,if (ies.vars)
(7205,frametype)
(7206,iaxs[fr->callno])
(7207,ies.vars)
(7208,ast_codec_get_samples(&f)
(7209,ast_channel_ref(bridged_chan)
(7210,check_dcallno)
(7211,ied0.pos)
(7212,ast_channel_nativeformats(iaxs[fr->callno]->owner)
(7213,callno)
(7214,iaxs[fr->callno]->peercallno)
(7215,iaxs[fr->callno])
(7216,iaxs[fr->callno]->encmethods)
(7217,callno)
(7218,connected)
(7219,ast_getformatname_multiple(tmp, sizeof(tmp)
(7220,callno)
(7221,iaxs[iaxs[fr->callno]->bridgecallno]->owner)
(7222,owner)
(7223,)
(7224,sin_addr)
(7225,memset(&ied0, 0, sizeof(ied0)
(7226,ast_strdupa(iaxs[fr->callno]->context)
(7227,ied0.buf)
(7228,fr)
(7229,fr->ts)
(7230,iaxs)
(7231,integer)
(7232,f.data.ptr = NULL)
(7233,fr)
(7234,fr)
(7235,iaxs[fr->callno])
(7236,newvar)
(7237,*fr)
(7238,return 1;)
(7239,ntohl(fh->ts)
(7240,fr->callno)
(7241,mh)
(7242,fr)
(7243,valid)
(7244,subclass)
(7245,fr)
(7246,f)
(7247,iaxs[fr->callno])
(7248,serviceident)
(7249,-1)
(7250,fr->outoforder)
(7251,ies)
(7252,peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_peer_s, peer_ref(peer)
(7253,fr)
(7254,iaxs)
(7255,if (iaxs[fr->callno]->videoformat > 0)
(7256,iaxs[fr->callno]->peerformat)
(7257,(f.subclass.integer != IAX_COMMAND_TXACC)
(7258,callno)
(7259,iseqno)
(7260,calltoken)
(7261,fr->callno)
(7262,"Parking call \'%s\'\\n")
(7263,fr)
(7264,iaxs[fr->callno])
(7265,fr->callno)
(7266,subclass)
(7267,ast_debug(1, "Received mini frame before first full voice frame\\n")
(7268,callno)
(7269,f.subclass == IAX_COMMAND_REJECT)
(7270,ies)
(7271,break;)
(7272,vars)
(7273,sin.sin_port)
(7274,fr)
(7275,1)
(7276,data)
(7277,iaxs[fr->callno]->peercapability)
(7278,iaxsl)
(7279,callno)
(7280,ies)
(7281,ies.called_number)
(7282,samples)
(7283,if (iaxs[fr->callno] && iaxs[fr->callno]->owner)
(7284,AST_LIST_HEAD_INIT(varlist)
(7285,callno)
(7286,fh->iseqno)
(7287,unsigned char *)
(7288,peer->callno)
(7289,callno)
(7290,0)
(7291,ast_debug(1, "I can haz IAX vars, but they is no good :-(\\n")
(7292,iaxs)
(7293,fr)
(7294,fh)
(7295,"Ooh, video format changed to %s\\n")
(7296,AST_FRAME_IAX)
(7297,iseqno)
(7298,ied0)
(7299,iaxs)
(7300,connected)
(7301,subclass)
(7302,callno)
(7303,fr)
(7304,ies.called_number)
(7305,callno)
(7306,callno)
(7307,tmp1)
(7308,send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1)
(7309,iaxs[fr->callno] && iaxs[fr->callno]->owner)
(7310,callno)
(7311,f.subclass.integer)
(7312,ptr)
(7313,peerformat)
(7314,fr)
(7315,&sin)
(7316,ied0)
(7317,iaxs[fr->callno]->peerformat)
(7318,strcmp(iaxs[fr->callno]->exten, "TBD")
(7319,id)
(7320,iaxsl)
(7321,iaxs[fr->callno]->owner)
(7322,AST_FRAME_IAX)
(7323,&f.subclass.format)
(7324,memset(&pref, 0, sizeof(pref)
(7325,iaxs)
(7326,ast_inet_ntoa(sin.sin_addr)
(7327,sin)
(7328,&iaxsl[fr->callno])
(7329,iaxs[fr->callno])
(7330,LOG_WARNING)
(7331,if (test_resync)
(7332,callno)
(7333,ast_debug(1, "I can haz iaxvars, but they is no good.  :-(\\n")
(7334,break;)
(7335,ast_channel_name(iaxs[fr->callno]->owner)
(7336,fr)
(7337,)
(7338,f.frametype == AST_FRAME_IAX)
(7339,AST_FRAME_IAX)
(7340,NULL)
(7341,ies.fwdesc)
(7342,prefs)
(7343,callno)
(7344,iaxs)
(7345,peercapability)
(7346,fr)
(7347,iaxs[fr->callno])
(7348,fr->callno)
(7349,value)
(7350,fr)
(7351,iaxs[fr->callno])
(7352,bridged_chan)
(7353,iaxs)
(7354,iaxs)
(7355,fr->callno)
(7356,NULL)
(7357,f)
(7358,if (iaxs[fr->callno] && ((mount_callid = iax_pvt_callid_get(fr->callno)
(7359,format)
(7360,iaxs)
(7361,iaxs[fr->callno])
(7362,fr->callno)
(7363,callno)
(7364,iaxs[fr->callno])
(7365,subclass)
(7366,send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
(7367,fr->callno)
(7368,fr)
(7369,iaxs[fr->callno]->pingtime <= peer->maxms)
(7370,&ies)
(7371,f.subclass.integer == AST_CONTROL_BUSY)
(7372,iaxs[fr->callno]->bridgecallno)
(7373,f.subclass)
(7374,fr->callno)
(7375,iax2_vnak(fr->callno)
(7376,iaxs)
(7377,fr->callno)
(7378,f)
(7379,!inaddrcmp(&sin, &iaxs[fr->callno]->addr)
(7380,LOG_WARNING)
(7381,fr)
(7382,iaxs)
(7383,ast_free(prev)
(7384,break;)
(7385,f)
(7386,fr->callno)
(7387,fr->callno)
(7388,ies.vars)
(7389,peer->lastms = iaxs[fr->callno]->pingtime)
(7390,var = ies.vars)
(7391,peer->historicms)
(7392,maxms)
(7393,iaxs[fr->callno])
(7394,iaxs[fr->callno])
(7395,)
(7396,capability)
(7397,iaxs[fr->callno]->owner)
(7398,callno)
(7399,ntohs(sin.sin_port)
(7400,data_size)
(7401,callno)
(7402,fr)
(7403,fh->csub)
(7404,tmp2)
(7405,(f.subclass.integer != IAX_COMMAND_TXREADY)
(7406,iaxs)
(7407,callno)
(7408,&ied0)
(7409,1)
(7410,fr)
(7411,iaxs[fr->callno])
(7412,)
(7413,iaxs[fr->callno]->calling_pres)
(7414,rprefs)
(7415,iaxs)
(7416,iaxs)
(7417,pos)
(7418,iaxs)
(7419,state)
(7420,iaxs)
(7421,ast_channel_unlock(owner)
(7422,fr->callno)
(7423,callno)
(7424,historicms)
(7425,f.subclass)
(7426,fr)
(7427,fr->callno)
(7428,iaxs[iaxs[fr->callno]->bridgecallno])
(7429,iaxs[fr->callno])
(7430,pref)
(7431,1)
(7432,iaxs[fr->callno]->peerformat)
(7433,iaxs)
(7434,iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_MEDIA)
(7435,fr->callno)
(7436,char *)
(7437,f)
(7438,ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)
(7439,iaxs[fr->callno])
(7440,thread->buf)
(7441,var)
(7442,f.subclass.integer == IAX_COMMAND_REGREL)
(7443,TRANSFER_RELEASED)
(7444,&iaxsl[fr->callno])
(7445,peercapability)
(7446,iaxs[fr->callno]->peerformat)
(7447,f.frametype)
(7448,if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)
(7449,fr)
(7450,iaxs[fr->callno]->owner)
(7451,meta->zeros)
(7452,callno)
(7453,)
(7454,cause_code)
(7455,callno)
(7456,if (ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)
(7457,fr->iseqno >= iaxs[fr->callno]->rseqno && fr->iseqno < iaxs[fr->callno]->oseqno)
(7458,iaxs[fr->callno]->transfer)
(7459,transferring)
(7460,iaxs[fr->callno])
(7461,f.datalen)
(7462,iaxs[fr->callno]->iseqno)
(7463,iaxs[fr->callno]->rprefs)
(7464,NULL)
(7465,case IAX_COMMAND_PING:)
(7466,fr->callno)
(7467,IAX_CODEC_NOCAP)
(7468,fr->ts += test_resync)
(7469,ast_channel_uniqueid(iaxs[fr->callno]->owner)
(7470,IAX_COMMAND_REJECT)
(7471,iaxs)
(7472,iaxs[fr->callno])
(7473,set_hangup_source_and_cause(fr->callno, ies.causecode)
(7474,iaxs[fr->callno])
(7475,f.subclass)
(7476,iaxs[fr->callno])
(7477,)
(7478,dp->flags & CACHE_FLAG_TRANSMITTED)
(7479,iaxs[fr->callno]->pingtime)
(7480,callno)
(7481,f.frametype = AST_FRAME_VOICE)
(7482,case IAX_COMMAND_NEW:)
(7483,meta)
(7484,iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_RELEASED)
(7485,iaxs[fr->callno])
(7486,iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0)
(7487,ied1)
(7488,&f.subclass.format)
(7489,lastms)
(7490,transfer)
(7491,AST_FRAME_IAX)
(7492,iaxs)
(7493,f)
(7494,0)
(7495,rprefs)
(7496,fr->callno)
(7497,iaxs)
(7498,iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION)
(7499,fr)
(7500,f)
(7501,fr->callno)
(7502,thread->buf_len)
(7503,if (delayreject)
(7504,subclass)
(7505,)
(7506,f.subclass.format)
(7507,iseqno)
(7508,iaxs)
(7509,-1)
(7510,if (iaxs[fr->callno]->authmethods & IAX_AUTH_MD5)
(7511,iaxs)
(7512,iaxs[fr->callno])
(7513,authdebug)
(7514,fr)
(7515,ast_strlen_zero(iaxs[fr->callno]->secret)
(7516,connected.id.name.presentation = iaxs[fr->callno]->calling_pres)
(7517,(unsigned char)
(7518,format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1)
(7519,iaxs)
(7520,&sin)
(7521,fr->ts)
(7522,fr->callno)
(7523,iaxs[fr->callno]->bridgecallno)
(7524,connected)
(7525,LOG_NOTICE)
(7526,format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
(7527,f.subclass.format.id)
(7528,iaxs)
(7529,fr->callno)
(7530,IAX_IE_CAUSE)
(7531,iaxs)
(7532,fr)
(7533,iax2_sched_add(sched, peer->pokefreqok, iax2_poke_peer_s, peer_ref(peer)
(7534,)
(7535,connected.id)
(7536,delayreject)
(7537,owner)
(7538,fr)
(7539,callno)
(7540,iax2_lock_owner(fr->callno)
(7541,ies)
(7542,cid_num)
(7543,bridgecallno)
(7544,sin)
(7545,iaxs[fr->callno])
(7546,iaxs[fr->callno])
(7547,iaxs[fr->callno])
(7548,fr->callno)
(7549,owner)
(7550,callno)
(7551,1)
(7552,f.frametype == AST_FRAME_IAX)
(7553,NULL)
(7554,sizeof(tmp1)
(7555,prev)
(7556,&ied1)
(7557,sin.sin_addr)
(7558,iaxs[fr->callno]->rseqno)
(7559,f)
(7560,calltokendata)
(7561,ies.called_number)
(7562,f.frametype)
(7563,fr->callno)
(7564,context)
(7565,fr->iseqno)
(7566,ntohs(mh->callno)
(7567,dcallno = 0)
(7568,fr)
(7569,iaxs)
(7570,"Immediately destroying %d, having received reject\\n")
(7571,f.subclass.integer != IAX_COMMAND_INVAL)
(7572,iaxs)
(7573,buf)
(7574,iaxs)
(7575,thread->buf_size)
(7576,f)
(7577,0)
(7578,if (prev)
(7579,1)
(7580,context)
(7581,bridgecallno)
(7582,ts)
(7583,callno)
(7584,if (registry_rerequest(&ies, fr->callno, &sin)
(7585,callno)
(7586,"")
(7587,ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner)
(7588,IAX_DELAYPBXSTART)
(7589,iaxs[fr->callno])
(7590,f.subclass == IAX_COMMAND_ACCEPT ||\n\\n\\t\\t\\t\\t\\t\\t\\t\\t f.subclass == IAX_COMMAND_REJECT)
(7591,)
(7592,ast_set_write_format(iaxs[fr->callno]->owner, ast_channel_writeformat(iaxs[fr->callno]->owner)
(7593,fr->callno)
(7594,iaxs[fr->callno])
(7595,1)
(7596,iaxs[fr->callno])
(7597,iaxsl[fr->callno])
(7598,sizeof(tmp)
(7599,callno)
(7600,1)
(7601,iaxs)
(7602,schedule_delivery(duped_fr, updatehistory, 0, &fr->ts)
(7603,iaxs[fr->callno])
(7604,IAX_COMMAND_REJECT)
(7605,fr->callno)
(7606,callno)
(7607,iaxs[fr->callno]->transferring = TRANSFER_READY)
(7608,varlist)
(7609,"I can haz IAX vars? w00t\\n")
(7610,fr->callno)
(7611,ied0)
(7612,ies.vars)
(7613,format)
(7614,lastms)
(7615,context)
(7616,if (authdebug)
(7617,owner)
(7618,fr->callno)
(7619,f.subclass.integer == IAX_COMMAND_LAGRQ)
(7620,devicetype)
(7621,iaxs[iaxs[fr->callno]->bridgecallno])
(7622,f.subclass.format)
(7623,peer)
(7624,f.subclass)
(7625,iaxs[fr->callno])
(7626,number)
(7627,fr)
(7628,format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)
(7629,sizeof(*cause_code)
(7630,f.subclass.integer)
(7631,case IAX_COMMAND_REGREQ:)
(7632,0)
(7633,vars)
(7634,causecode)
(7635,ies)
(7636,iaxs)
(7637,ast_free(prev)
(7638,iaxs[fr->callno])
(7639,"Received packet %d, (%d, %u)
(7640,fr)
(7641,owner)
(7642,iaxs[fr->callno]->peercapability)
(7643,ies.vars)
(7644,iseqno)
(7645,f.subclass.integer)
(7646,sin)
(7647,!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(7648,ast_inet_ntoa(sin.sin_addr)
(7649,iaxs[fr->callno])
(7650,callno)
(7651,fr->callno)
(7652,fr->callno)
(7653,sizeof(ied0)
(7654,iaxs)
(7655,0)
(7656,fr->callno)
(7657,last)
(7658,callno)
(7659,x=iaxs[fr->callno]->rseqno)
(7660,if (!iaxs[fr->callno])
(7661,ast_variables_destroy(ies.vars)
(7662,iaxs[fr->callno]->bridgecallno)
(7663,owner)
(7664,ied0)
(7665,IAX_COMMAND_ACK)
(7666,iaxs[fr->callno]->peerpoke)
(7667,)
(7668,iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno)
(7669,fr)
(7670,f.subclass.integer)
(7671,iaxs[fr->callno])
(7672,pos)
(7673,callno)
(7674,c = iaxs[fr->callno]->owner)
(7675,iaxs[fr->callno])
(7676,peer)
(7677,iaxs[fr->callno]->transfer)
(7678,ies)
(7679,iaxs)
(7680,)
(7681,using_prefs = "mine")
(7682,f)
(7683,"<Unknown>")
(7684,4096)
(7685,fr->callno)
(7686,ied0.pos)
(7687,ies.calltoken && ies.calltokendata)
(7688,dp->flags)
(7689,fr->callno)
(7690,callno)
(7691,fr)
(7692,iaxs)
(7693,iaxs[iaxs[fr->callno]->bridgecallno]->peercallno)
(7694,ast_channel_unlock(c)
(7695,)
(7696,subclass)
(7697,fr->callno)
(7698,vars)
(7699,iaxs[fr->callno])
(7700,"<Unknown>")
(7701,iseqno)
(7702,id)
(7703,)
(7704,pref)
(7705,IAX_COMMAND_REJECT)
(7706,iaxs[fr->callno])
(7707,fr->callno)
(7708,)
(7709,"<Unknown>")
(7710,pos)
(7711,callno)
(7712,iaxs)
(7713,ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
(7714,id)
(7715,exists)
(7716,callno)
(7717,fr->callno)
(7718,AST_FRAME_IAX)
(7719,IAX_STATE_STARTED)
(7720,fr->ts)
(7721,case IAX_COMMAND_QUELCH:)
(7722,fr)
(7723,ies)
(7724,*native = ast_channel_nativeformats(iaxs[fr->callno]->owner)
(7725,fh->iseqno)
(7726,callno)
(7727,IAX_COMMAND_REJECT)
(7728,f.subclass)
(7729,!exists)
(7730,ies)
(7731,callno)
(7732,f.subclass)
(7733,fr)
(7734,iaxs[fr->callno]->videoformat)
(7735,if (iaxs[fr->callno])
(7736,fh->csub)
(7737,ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability \'%s\'/\'%s\' incompatible with our capability \'%s\'.\\n",\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tast_inet_ntoa(sin.sin_addr)
(7738,iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec")
(7739,if (iaxs[fr->callno]->owner)
(7740,0)
(7741,)
(7742,callno)
(7743,iaxs[fr->callno])
(7744,iaxs[fr->callno]->bridgecallno)
(7745,fr)
(7746,iaxs[fr->callno]->addr.sin_addr)
(7747,break;)
(7748,peer)
(7749,1)
(7750,fr->callno)
(7751,fr)
(7752,if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD)
(7753,send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1)
(7754,vars)
(7755,iaxs)
(7756,s_addr)
(7757,vars)
(7758,IAX_DELAYPBXSTART)
(7759,iaxs)
(7760,iaxs[fr->callno])
(7761,)
(7762,fr->callno)
(7763,f.subclass.format)
(7764,break;)
(7765,iaxs[fr->callno]->rseqno)
(7766,fr)
(7767,ast_channel_caller(iaxs[fr->callno]->owner)
(7768,f.frametype == AST_FRAME_TEXT && thread->buf[res - 1] != \'\\0\')
(7769,variablestore)
(7770,callno)
(7771,ntohl(fh->ts)
(7772,callno)
(7773,fr->callno)
(7774,f.data)
(7775,fr)
(7776,IAX_QUELCH)
(7777,callno)
(7778,fr->callno)
(7779,ies)
(7780,f.subclass.integer == IAX_COMMAND_REGREQ || f.subclass.integer == IAX_COMMAND_REGREL)
(7781,callno)
(7782,ies)
(7783,f.frametype)
(7784,iaxs)
(7785,ies.vars)
(7786,"Async goto of \'%s\' to \'%s@%s\' started\\n")
(7787,fr)
(7788,callno)
(7789,vars)
(7790,f.subclass.integer)
(7791,fr)
(7792,callno)
(7793,fr->callno)
(7794,pos)
(7795,callno)
(7796,owner)
(7797,fr)
(7798,ied0)
(7799,callno)
(7800,0)
(7801,iaxs[fr->callno]->owner)
(7802,iaxs)
(7803,if (duped_fr)
(7804,fr)
(7805,f.subclass.integer)
(7806,iaxs)
(7807,fr->callno)
(7808,iaxs[fr->callno])
(7809,callno)
(7810,fr->callno)
(7811,iaxs)
(7812,IAX_FLAG_FULL)
(7813,(f.subclass.integer != IAX_COMMAND_ACK)
(7814,fr->callno)
(7815,id)
(7816,AST_FRAME_IAX)
(7817,callno)
(7818,immediatedial:)
(7819,iaxs[fr->callno])
(7820,callno)
(7821,format = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(7822,memset(&ies, 0, sizeof(ies)
(7823,0)
(7824,iaxs)
(7825,fr)
(7826,iaxs[fr->callno]->transferring == TRANSFER_MREADY)
(7827,1)
(7828,variablestore)
(7829,iaxs[fr->callno]->exten)
(7830,iaxs)
(7831,1)
(7832,fr)
(7833,iaxs[fr->callno])
(7834,fr)
(7835,)
(7836,callno)
(7837,case IAX_COMMAND_TRANSFER:)
(7838,iaxs[fr->callno]->callno)
(7839,callno)
(7840,break;)
(7841,iaxs[fr->callno] && ((mount_callid = iax_pvt_callid_get(fr->callno)
(7842,thread)
(7843,NULL)
(7844,fr)
(7845,owner)
(7846,iax2_getformatname_multiple(tmp1, sizeof(tmp1)
(7847,iax2_getformatname(iaxs[fr->callno]->peerformat)
(7848,AST_CONTROL_PVT_CAUSE_CODE)
(7849,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)
(7850,tmp1)
(7851,x)
(7852,iaxs)
(7853,ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
(7854,fh->csub == IAX_COMMAND_REGREJ\n\\n\\t\\t\\t|| fh->csub == IAX_COMMAND_TXREJ)
(7855,1)
(7856,f)
(7857,IAX_COMMAND_ACCEPT)
(7858,iaxs[fr->callno]->peerformat)
(7859,ies)
(7860,ied0)
(7861,LOG_WARNING)
(7862,ast_channel_nativeformats(iaxs[fr->callno]->owner)
(7863,callno)
(7864,exten)
(7865,callno)
(7866,callno)
(7867,!iaxs[fr->callno])
(7868,iaxs)
(7869,IAX_COMMAND_INVAL)
(7870,fr)
(7871,iaxs)
(7872,f.samples = ast_codec_get_samples(&f)
(7873,)
(7874,fr)
(7875,iaxs[fr->callno]->exten)
(7876,NULL)
(7877,fr)
(7878,format)
(7879,globalflags)
(7880,)
(7881,oseqno)
(7882,IAX_COMMAND_TXCNT)
(7883,callno)
(7884,iaxs[fr->callno])
(7885,ies.vars)
(7886,callno)
(7887,send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
(7888,peercapability)
(7889,fr->callno)
(7890,iaxs[fr->callno])
(7891,sin)
(7892,ies.vars = NULL)
(7893,iaxs[fr->callno])
(7894,fr->callno)
(7895,)
(7896,fr->callno)
(7897,TRANSFER_MEDIAPASS)
(7898,iaxs[fr->callno])
(7899,cid_num)
(7900,!inaddrcmp(&sin, &iaxs[fr->callno]->addr)
(7901,fr->callno)
(7902,if (!inaddrcmp(&sin, &iaxs[fr->callno]->addr)
(7903,0xFFFF0000L)
(7904,*meta = (struct ast_iax2_meta_hdr *)
(7905,(f.subclass.integer != IAX_COMMAND_TXCNT)
(7906,"Immediately destroying %d, having received INVAL\\n")
(7907,iaxs)
(7908,varlist)
(7909,pref)
(7910,fr->iseqno)
(7911,"Registration of \'%s\' rejected: \'%s\' from: \'%s\'\\n")
(7912,(f.subclass.integer != IAX_COMMAND_TXACC)
(7913,NEW_ALLOW)
(7914,case IAX_COMMAND_UNQUELCH:)
(7915,IAX_STATE_STARTED)
(7916,fr)
(7917,fr->callno)
(7918,var)
(7919,iaxs[iaxs[fr->callno]->bridgecallno]->peercallno)
(7920,iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL)
(7921,&sin)
(7922,memset(&ied0, 0, sizeof(ied0)
(7923,if (!newvar)
(7924,iaxs[fr->callno])
(7925,subclass)
(7926,callno)
(7927,"<Unknown>")
(7928,f.subclass.integer)
(7929,iaxs[fr->callno]->owner)
(7930,fr)
(7931,callno)
(7932,sin.sin_addr)
(7933,res)
(7934,iaxsl[fr->callno])
(7935,iaxs)
(7936,&iaxs[fr->callno]->state)
(7937,(dcallno != 1)
(7938,entries)
(7939,fr)
(7940,break;)
(7941,authdebug)
(7942,callno)
(7943,fr->callno)
(7944,tmp3)
(7945,fr->callno)
(7946,send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1)
(7947,iaxs)
(7948,iax2_getformatname_multiple(tmp2, sizeof(tmp2)
(7949,1)
(7950,fr)
(7951,strcpy(caller_pref_buf, "disabled")
(7952,capability)
(7953,1)
(7954,owner)
(7955,fr->callno)
(7956,)
(7957,ast_channel_unlock(owner)
(7958,)
(7959,f.frametype)
(7960,return 1;)
(7961,iaxs[fr->callno]->iseqno)
(7962,AST_FRAME_IAX)
(7963,iseqno)
(7964,iaxs)
(7965,iaxs[fr->callno])
(7966,ies)
(7967,callno)
(7968,newvar)
(7969,)
(7970,fh)
(7971,&f)
(7972,sin)
(7973,tmp)
(7974,f.subclass)
(7975,fr)
(7976,3)
(7977,&connected.id)
(7978,"I can haz IAX vars, but they is no good :-(\\n")
(7979,f.subclass)
(7980,iaxs)
(7981,ast_mutex_lock(&iaxsl[fr->callno])
(7982,newvar)
(7983,LOG_NOTICE)
(7984,iaxs[fr->callno]->peerformat)
(7985,iaxs[fr->callno] && iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno)
(7986,fr)
(7987,"BLINDTRANSFER")
(7988,fr)
(7989,sin_addr)
(7990,if (ies.causecode > 9)
(7991,return 1;)
(7992,iaxs[fr->callno])
(7993,owner)
(7994,send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
(7995,f.subclass)
(7996,fh)
(7997,TRANSFER_BEGIN)
(7998,ast_inet_ntoa(sin.sin_addr)
(7999,fr->callno)
(8000,callno)
(8001,fr)
(8002,fr)
(8003,subclass)
(8004,callno)
(8005,f.mallocd)
(8006,peerformat)
(8007,fr)
(8008,f.datalen && (f.frametype == AST_FRAME_VOICE)
(8009,)
(8010,ts)
(8011,duped_fr)
(8012,iax2_destroy(fr->callno)
(8013,fr)
(8014,subclass)
(8015,iaxs[fr->callno])
(8016,-1)
(8017,fr)
(8018,tmp2)
(8019,ied0)
(8020,strcmp(iaxs[fr->callno]->exten, "TBD")
(8021,call_to_destroy)
(8022,iaxsl[fr->callno])
(8023,transferring)
(8024,callno)
(8025,callno)
(8026,fr)
(8027,iaxs[fr->callno])
(8028,sizeof(caller_pref_buf)
(8029,sin.sin_family)
(8030,f)
(8031,cause)
(8032,!format)
(8033,varlist = ast_calloc(1, sizeof(*varlist)
(8034,iaxs)
(8035,ies.calltoken)
(8036,fr->callno)
(8037,thread->buf[res++])
(8038,f)
(8039,res - sizeof(*fh)
(8040,buf)
(8041,sizeof(tmp2)
(8042,fr)
(8043,0 + peer->historicms)
(8044,orignative)
(8045,tmp1)
(8046,fr)
(8047,connected.id)
(8048,frametype)
(8049,callno)
(8050,VERBOSE_PREFIX_4)
(8051,ied0)
(8052,f)
(8053,iaxs[fr->callno]->pingtime)
(8054,if (strcmp(iaxs[fr->callno]->exten, "TBD")
(8055,AST_FRAME_IAX)
(8056,iaxs[fr->callno]->iseqno ||\n\\n\\t\\t\\t\\t((f.subclass.integer != IAX_COMMAND_TXCNT)
(8057,peer)
(8058,connected.id.number)
(8059,ts)
(8060,iaxs[fr->callno]->rseqno)
(8061,owner)
(8062,buf)
(8063,)
(8064,iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0)
(8065,&f)
(8066,iaxs[fr->callno])
(8067,(f.frametype == AST_FRAME_IAX)
(8068,owner)
(8069,IAX_COMMAND_TXREADY)
(8070,1)
(8071,fr->callno)
(8072,sizeof(*fh)
(8073,iaxs[fr->callno]->oseqno == fr->iseqno)
(8074,!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)
(8075,f)
(8076,1)
(8077,callno)
(8078,vars)
(8079,ies.vars)
(8080,if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, format, NULL, 1)
(8081,iax2_getformatname_multiple(tmp, sizeof(tmp)
(8082,IAX_COMMAND_TXREJ)
(8083,ies.vars = NULL)
(8084,fr)
(8085,)
(8086,&iaxs[fr->callno]->rprefs)
(8087,ts)
(8088,tmp2)
(8089,iaxsl[fr->callno])
(8090,thread)
(8091,iaxs[fr->callno])
(8092,iaxs[fr->callno])
(8093,1)
(8094,(f.frametype == AST_FRAME_IAX)
(8095,callno)
(8096,if (iax2_ack_registry(&ies, &sin, fr->callno)
(8097,iaxs)
(8098,rseqno)
(8099,&iaxsl[fr->callno])
(8100,&iaxs[fr->callno]->state)
(8101,iaxs)
(8102,owner)
(8103,)
(8104,integer)
(8105,fh->dcallno)
(8106,peer)
(8107,iaxs[fr->callno])
(8108,data_size)
(8109,subclass)
(8110,fr)
(8111,iaxsl)
(8112,if (iaxdebug)
(8113,f)
(8114,tmp1)
(8115,fr)
(8116,if (res < sizeof(*mh)
(8117,fr->callno)
(8118,outoforder)
(8119,manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\\r\\nPeer: IAX2/%s\\r\\nPeerStatus: Reachable\\r\\nTime: %d\\r\\n", peer->name, iaxs[fr->callno]->pingtime)
(8120,fr->callno)
(8121,ied0)
(8122,iaxs)
(8123,iax2_queue_frame(fr->callno, &hangup_fr)
(8124,ies)
(8125,callno)
(8126,iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension")
(8127,if (f.frametype == AST_FRAME_CONTROL && f.subclass.integer == AST_CONTROL_CONNECTED_LINE)
(8128,f.subclass.integer)
(8129,)
(8130,if (authdebug)
(8131,callno)
(8132,sin.sin_addr.s_addr)
(8133,case IAX_COMMAND_TXREJ:)
(8134,if (f.frametype == AST_FRAME_IAX)
(8135,IAX_IE_FORMAT2)
(8136,fr->callno)
(8137,IAX_IE_CALLNO)
(8138,fr)
(8139,data)
(8140,fr->callno)
(8141,f)
(8142,if ((cur = AST_LIST_LAST(&frame_queue[fr->callno])
(8143,fr)
(8144,IAX_STATE_STARTED)
(8145,ast_log(LOG_ERROR, "No best format in \'%s\'???\\n", iax2_getformatname_multiple(tmp, sizeof(tmp)
(8146,iaxs[fr->callno]->rprefs)
(8147,fr)
(8148,&ied0)
(8149,iaxs[fr->callno])
(8150,owner)
(8151,1)
(8152,break;)
(8153,callno)
(8154,iaxs)
(8155,iaxs)
(8156,integer)
(8157,integer)
(8158,IAX_COMMAND_TXCNT)
(8159,iaxs[fr->callno]->owner)
(8160,calltokendata)
(8161,iaxs)
(8162,ies)
(8163,fr)
(8164,ies)
(8165,0)
(8166,~IAX_FLAG_FULL)
(8167,IAX_IE_CAUSE)
(8168,lag)
(8169,ies)
(8170,context)
(8171,ntohs(meta->metacmd)
(8172,ast_inet_ntoa(sin.sin_addr)
(8173,pref)
(8174,dcallno)
(8175,iaxs)
(8176,ts)
(8177,f)
(8178,peer->name)
(8179,fr->callno)
(8180,f.data.ptr = thread->buf + sizeof(*mh)
(8181,integer)
(8182,iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No authority found")
(8183,authdebug)
(8184,AST_FRAME_VOICE)
(8185,"Memory allocation error while processing IAX2 variables\\n")
(8186,fr)
(8187,format)
(8188,f.data.ptr)
(8189,iaxs[fr->callno]->context)
(8190,f)
(8191,fr)
(8192,iax2_getformatname_multiple(tmp2, sizeof(tmp2)
(8193,&fr->af)
(8194,iaxs[fr->callno]->reg)
(8195,iaxs[fr->callno]->peerformat)
(8196,)
(8197,iaxs[fr->callno])
(8198,fr)
(8199,fr->callno)
(8200,ast_variables_destroy(ies.vars)
(8201,&iaxsl[fr->callno])
(8202,fd)
(8203,iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL)
(8204,ast_mutex_unlock(&iaxsl[fr->callno])
(8205,f.subclass.integer)
(8206,last)
(8207,tmp2)
(8208,data_size++)
(8209,sizeof(ied1)
(8210,pingtime)
(8211,iaxs)
(8212,REG_STATE_REJECTED)
(8213,ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)
(8214,iaxs[fr->callno])
(8215,ast_mutex_unlock(&iaxsl[fr->callno])
(8216,cause)
(8217,context = ast_strdupa(iaxs[fr->callno]->context)
(8218,remove_by_peercallno(iaxs[fr->callno])
(8219,peerformat)
(8220,"Async goto of \'%s\' to \'%s@%s\' failed\\n")
(8221,var)
(8222,ast_channel_datastore_add(c, variablestore)
(8223,pingied.pos)
(8224,)
(8225,ies.devicetype)
(8226,ies)
(8227,fr->callno)
(8228,fr)
(8229,callno)
(8230,iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner)
(8231,updatehistory)
(8232,1)
(8233,ies.vars = NULL)
(8234,iaxs)
(8235,)
(8236,callno)
(8237,iaxs)
(8238,iaxs)
(8239,ies.vars)
(8240,vars)
(8241,iaxs[fr->callno]->state)
(8242,iaxs[fr->callno])
(8243,1)
(8244,&iaxs[fr->callno]->state)
(8245,)
(8246,0)
(8247,!inaddrcmp(&sin, &iaxs[fr->callno]->addr)
(8248,if (iaxs[fr->callno] && iaxs[fr->callno]->last < fr->ts)
(8249,next)
(8250,if (iaxs[fr->callno]->last < fr->ts &&\n\\n                            f.subclass.integer != IAX_COMMAND_ACK &&\n\\n                            f.subclass.integer != IAX_COMMAND_PONG &&\n\\n                            f.subclass.integer != IAX_COMMAND_LAGRP)
(8251,fr->callno)
(8252,iaxs[fr->callno]->transferring == TRANSFER_READY)
(8253,callno)
(8254,ied0.buf)
(8255,iaxs[fr->callno])
(8256,transferring)
(8257,callno)
(8258,iaxs)
(8259,fr)
(8260,fr->callno)
(8261,fr)
(8262,&iaxsl[fr->callno])
(8263,IAX_COMMAND_REJECT)
(8264,)
(8265,)
(8266,iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)
(8267,ied0)
(8268,IAX_COMMAND_REJECT)
(8269,iaxs)
(8270,callno)
(8271,peer->smoothing && (peer->lastms > -1)
(8272,tmp)
(8273,ast_debug(1, "Unknown IAX command %d on %d/%d\\n", f.subclass.integer, fr->callno, iaxs[fr->callno]->peercallno)
(8274,if (iaxs[fr->callno]->peerpoke)
(8275,ptr)
(8276,delayreject)
(8277,moh_suggest)
(8278,iaxs[fr->callno]->owner)
(8279,iaxs)
(8280,fr->callno)
(8281,iaxs)
(8282,(iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_READY)
(8283,format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1)
(8284,ast_channel_caller(iaxs[fr->callno]->owner)
(8285,f.subclass)
(8286,f)
(8287,&ied0)
(8288,)
(8289,fr->callno)
(8290,mallocd)
(8291,if (ntohs(mh->callno)
(8292,fr)
(8293,&f.subclass.format)
(8294,iaxs[fr->callno]->last)
(8295,case IAX_COMMAND_TXMEDIA:)
(8296,fh)
(8297,ntohs(mh->callno)
(8298,)
(8299,&ied0)
(8300,host_pref_buf)
(8301,ast_mutex_lock(&iaxsl[fr->callno])
(8302,ied1.buf)
(8303,"ChannelType: IAX2\\r\\nPeer: IAX2/%s\\r\\nPeerStatus: Lagged\\r\\nTime: %d\\r\\n")
(8304,var)
(8305,iaxs)
(8306,f.subclass.format)
(8307,1)
(8308,ts)
(8309,callno)
(8310,f.datalen)
(8311,peer->pokeexpire = -1)
(8312,&pref)
(8313,memset(&ied0, 0, sizeof(ied0)
(8314,callno)
(8315,fh)
(8316,IAX_COMMAND_REJECT)
(8317,"We don\'t do requested format %s, falling back to peer capability \'%s\'\\n")
(8318,callno)
(8319,iaxs)
(8320,!newvar)
(8321,ied0)
(8322,AST_FRAME_CONTROL)
(8323,fr)
(8324,iaxs[fr->callno]->transferring)
(8325,ast_test_flag64(iaxs[fr->callno], IAX_RECVCONNECTEDLINE)
(8326,IAX_STATE_STARTED)
(8327,callno)
(8328,if (authdebug)
(8329,f.frametype)
(8330,)
(8331,)
(8332,fr)
(8333,iaxs[fr->callno]->prefs)
(8334,)
(8335,fr->callno)
(8336,fr->callno)
(8337,iaxs[fr->callno])
(8338,lag)
(8339,(unsigned char)
(8340,f.data.ptr = NULL)
(8341,tmp1)
(8342,f)
(8343,iaxs[fr->callno]->peerformat)
(8344,NULL)
(8345,if (iaxs[fr->callno]->owner && authdebug)
(8346,buf)
(8347,iaxs)
(8348,fr->af.subclass)
(8349,entries)
(8350,thread)
(8351,if ((dcallno != 1)
(8352,LOG_ERROR)
(8353,fr)
(8354,iaxs)
(8355,rprefs)
(8356,fr->callno)
(8357,callno)
(8358,ast_log(LOG_NOTICE, "Host %s failed to authenticate as %s\\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr)
(8359,if (prev)
(8360,fr->iseqno < iaxs[fr->callno]->oseqno)
(8361,iaxs[iaxs[fr->callno]->bridgecallno]->owner)
(8362,f.subclass.integer)
(8363,owner)
(8364,callno)
(8365,AST_FRAME_IAX)
(8366,&ied0)
(8367,sin.sin_addr)
(8368,break;)
(8369,vh)
(8370,*moh_suggest = iaxs[fr->callno]->mohsuggest)
(8371,using_prefs)
(8372,callno)
(8373,iaxs)
(8374,presentation)
(8375,AST_CAUSE_BEARERCAPABILITY_NOTAVAIL)
(8376,iaxs)
(8377,if (f.frametype == AST_FRAME_CONTROL && iaxs[fr->callno]->owner)
(8378,bridged_chan)
(8379,callno)
(8380,rprefs)
(8381,format)
(8382,iaxs[fr->callno]->exten)
(8383,fr)
(8384,iseqno)
(8385,manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\\r\\nPeer: IAX2/%s\\r\\nPeerStatus: Lagged\\r\\nTime: %d\\r\\n", peer->name, iaxs[fr->callno]->pingtime)
(8386,ast_cause)
(8387,owner)
(8388,cur->final)
(8389,1)
(8390,if (!dcallno && iax2_allow_new(f.frametype, f.subclass.integer, 1)
(8391,callno)
(8392,fr->callno)
(8393,iaxs)
(8394,(ntohs(mh->ts)
(8395,resend_with_token(fr->callno, cur, (char *)
(8396,)
(8397,iaxs[fr->callno])
(8398,0)
(8399,f.frametype != AST_FRAME_VOICE)
(8400,f.subclass.format.id == AST_FORMAT_SLINEAR)
(8401,IAX_COMMAND_ACK)
(8402,fr->callno)
(8403,callno)
(8404,&ied0)
(8405,iaxs)
(8406,)
(8407,ies)
(8408,fr->callno)
(8409,fr)
(8410,iaxs)
(8411,iaxs[fr->callno]->last & 0xFFFF0000L)
(8412,ast_strlen_zero(iaxs[fr->callno]->secret)
(8413,f)
(8414,LOG_WARNING)
(8415,(f.subclass.integer != IAX_COMMAND_CALLTOKEN)
(8416,sin)
(8417,&f.subclass.format)
(8418,1)
(8419,format)
(8420,ast_debug(1, "Received VNAK: resending outstanding frames\\n")
(8421,fr->callno)
(8422,capability)
(8423,delayreject)
(8424,capability)
(8425,strcasecmp(iaxs[fr->callno]->exten, "TBD")
(8426,0)
(8427,sizeof(ied1)
(8428,ies.called_number)
(8429,)
(8430,vars)
(8431,aseqno)
(8432,callno)
(8433,callno)
(8434,if ( (ntohs(fh->dcallno)
(8435,fr)
(8436,fr->iseqno)
(8437,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(8438,iaxs)
(8439,ts)
(8440,ast_mutex_unlock(&iaxsl[call_to_destroy])
(8441,callno)
(8442,ast_free(prev)
(8443,if (!iaxs[fr->callno])
(8444,"Call on %s is already up, can\'t start on it\\n")
(8445,host_pref_buf)
(8446,owner)
(8447,ies.serviceident)
(8448,&dpcache)
(8449,)
(8450,ies)
(8451,fr->callno)
(8452,(f.subclass.integer != IAX_COMMAND_TXREL)
(8453,iseqno)
(8454,fr->iseqno)
(8455,iaxs[fr->callno])
(8456,IAX_CODEC_USER_FIRST)
(8457,"Status: On\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t"Channel: %s\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t"Uniqueid: %s\\r\\n")
(8458,f)
(8459,iaxs[fr->callno]->reg)
(8460,fr)
(8461,fr->callno)
(8462,frametype)
(8463,iaxs[fr->callno])
(8464,fr->callno)
(8465,break;)
(8466,ast_bridged_channel(iaxs[fr->callno]->owner)
(8467,fr)
(8468,callno)
(8469,ies.called_number)
(8470,bridged_chan)
(8471,iaxs[fr->callno]->owner)
(8472,peercapability)
(8473,iaxs)
(8474,dcallno)
(8475,)
(8476,IAX_STATE_TBD | IAX_STATE_AUTHENTICATED)
(8477,mount_callid)
(8478,tmp2)
(8479,bridged_chan)
(8480,fr->callno)
(8481,iaxs[fr->callno]->owner)
(8482,f.subclass.format)
(8483,iaxsl)
(8484,iaxs[fr->callno])
(8485,callno)
(8486,iaxs[fr->callno]->owner)
(8487,iaxs[fr->callno]->transferring)
(8488,f.samples = 0)
(8489,fr)
(8490,f)
(8491,iaxs)
(8492,iaxs[fr->callno]->aseqno)
(8493,sin_addr)
(8494,fr->callno)
(8495,NULL)
(8496,inheritance)
(8497,&sin)
(8498,iax_park(bridged_chan, owner, ies.called_number, context)
(8499,f.frametype == AST_FRAME_IAX)
(8500,iax2_getformatname_multiple(tmp, sizeof(tmp)
(8501,*varlist)
(8502,peercapability)
(8503,case IAX_COMMAND_CALLTOKEN:)
(8504,format)
(8505,iaxs[fr->callno]->owner && authdebug)
(8506,&iaxsl[fr->callno])
(8507,callno)
(8508,0)
(8509,fr)
(8510,send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied0.buf, ied0.pos, -1)
(8511,f)
(8512,iaxs)
(8513,fr->callno)
(8514,iseqno)
(8515,ts - fr->ts)
(8516,ntohs(mh->callno)
(8517,callno)
(8518,iaxs[fr->callno])
(8519,f.subclass.integer)
(8520,fr->callno)
(8521,callno)
(8522,fr)
(8523,if (res < sizeof(*fh)
(8524,iaxs)
(8525,iaxs[fr->callno])
(8526,ied0)
(8527,f.subclass == IAX_COMMAND_AUTHREQ)
(8528,NULL)
(8529,ies)
(8530,subclass)
(8531,frametype)
(8532,TRANSFER_MEDIA)
(8533,callno)
(8534,callno)
(8535,&ied0)
(8536,username)
(8537,iaxs[fr->callno]->context)
(8538,callno)
(8539,f)
(8540,integer)
(8541,fr->callno)
(8542,ast_channel_writeformat(iaxs[fr->callno]->owner)
(8543,iaxs)
(8544,iaxs[iaxs[fr->callno]->bridgecallno])
(8545,format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
(8546,IAX_STATE_STARTED)
(8547,&iaxs[fr->callno]->state)
(8548,sizeof(tmp2)
(8549,ied0)
(8550,iaxs[fr->callno]->peerformat)
(8551,ast_channel_datastore_add(c, variablestore)
(8552,ies)
(8553,subclass)
(8554,callno)
(8555,iaxs[fr->callno])
(8556,"Undecodable frame received from \'%s\'\\n")
(8557,"<unknown>")
(8558,iseqno)
(8559,if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)
(8560,fr->ts)
(8561,iaxs[fr->callno]->last)
(8562,prev)
(8563,f.subclass.integer != IAX_COMMAND_TXACC)
(8564,updatehistory)
(8565,NULL)
(8566,f.frametype == AST_FRAME_VOICE)
(8567,cur)
(8568,sin)
(8569,callno)
(8570,fr)
(8571,0)
(8572,format)
(8573,)
(8574,fr->callno)
(8575,callno)
(8576,ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD)
(8577,)
(8578,iaxs[iaxs[fr->callno]->bridgecallno]->transferring)
(8579,fr)
(8580,ast_mutex_unlock(&iaxsl[fr->callno])
(8581,1)
(8582,callno)
(8583,"Peer %s: got pong, lastms %d, historicms %d, maxms %d\\n")
(8584,fr->callno)
(8585,dcallno = ntohs(fh->dcallno)
(8586,callno)
(8587,iaxs)
(8588,callno)
(8589,ies)
(8590,ies.cause ? ies.cause : "<Unknown>")
(8591,integer)
(8592,f)
(8593,send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1)
(8594,ied1)
(8595,3)
(8596,ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr)
(8597,f)
(8598,vh)
(8599,iaxs)
(8600,oseqno)
(8601,AST_FRAME_IAX)
(8602,IAX_COMMAND_ACK)
(8603,ast_log(LOG_ERROR, "No best format in %s???\\n",\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tiax2_getformatname_multiple(tmp1, sizeof(tmp1)
(8604,iaxs[fr->callno]->state)
(8605,iaxs)
(8606,f.subclass)
(8607,iaxs)
(8608,peer)
(8609,"Channel \'%s\' unable to transfer\\n")
(8610,"reqonly")
(8611,sizeof(ied0)
(8612,f.subclass)
(8613,callno)
(8614,connected.id.number)
(8615,f)
(8616,fh)
(8617,peer)
(8618,IAX_ALREADYGONE)
(8619,iax2_getformatname(iaxs[fr->callno]->peerformat)
(8620,&hangup_fr)
(8621,callno)
(8622,iaxsl)
(8623,iaxs[fr->callno])
(8624,(ntohs(mh->callno)
(8625,callno)
(8626,sched)
(8627,iax2_getformatname_multiple(tmp, sizeof(tmp)
(8628,sin_addr)
(8629,iaxs[fr->callno])
(8630,fr)
(8631,iaxs[fr->callno])
(8632,fr->callno)
(8633,fr->callno)
(8634,ast_inet_ntoa(sin.sin_addr)
(8635,iaxs[fr->callno]->peercallno = new_peercallno)
(8636,fr->callno)
(8637,ied1.buf)
(8638,iaxs[fr->callno]->oseqno)
(8639,IAX_STATE_STARTED)
(8640,fr)
(8641,fr)
(8642,fr)
(8643,x)
(8644,iaxs)
(8645,)
(8646,AST_CONTROL_PROGRESS)
(8647,iax2_ack_registry(&ies, &sin, fr->callno)
(8648,LOG_WARNING)
(8649,callno)
(8650,ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr)
(8651,owner)
(8652,if (ast_channel_writeformat(iaxs[fr->callno]->owner)
(8653,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(8654,AST_CONTROL_HOLD)
(8655,)
(8656,callno)
(8657,mount_callid)
(8658,bridgecallno)
(8659,calc_timestamp(iaxs[fr->callno], 0, &fr->af)
(8660,iaxs)
(8661,fr)
(8662,iaxs[fr->callno])
(8663,iaxs)
(8664,ast_debug(1, "Immediately destroying %d, having received hangup\\n", fr->callno)
(8665,res)
(8666,iaxs[fr->callno]->aseqno)
(8667,f.subclass)
(8668,f.subclass.integer != IAX_COMMAND_CALLTOKEN)
(8669,)
(8670,ast_variables_destroy(ies.vars)
(8671,f.frametype == AST_FRAME_IAX)
(8672,AST_FRAME_VIDEO)
(8673,vh)
(8674,rprefs)
(8675,iaxs[fr->callno]->owner)
(8676,frametype)
(8677,subclass)
(8678,fr->callno)
(8679,ies)
(8680,f)
(8681,pref = iaxs[fr->callno]->prefs)
(8682,connected)
(8683,id)
(8684,if (!iaxs[fr->callno])
(8685,buf)
(8686,callno)
(8687,fr)
(8688,iaxs[fr->callno])
(8689,IAX_COMMAND_REGREL)
(8690,0)
(8691,fr->iseqno)
(8692,f.subclass.integer)
(8693,callno)
(8694,fr->outoforder = -1)
(8695,rprefs)
(8696,transferring)
(8697,iaxsl)
(8698,fr->callno)
(8699,iaxs)
(8700,memset(&ied0, 0, sizeof(ied0)
(8701,iaxs[fr->callno]->owner)
(8702,case IAX_COMMAND_RTKEY:)
(8703,sizeof(struct ast_iax2_full_hdr)
(8704,ied0)
(8705,c)
(8706,oseqno)
(8707,if (authdebug)
(8708,integer)
(8709,if (!iaxs[fr->callno])
(8710,1)
(8711,callno)
(8712,f.offset = 0)
(8713,f.subclass)
(8714,if (!inaddrcmp(&sin, &iaxs[fr->callno]->addr)
(8715,if (!iaxs[fr->callno])
(8716,&iaxsl[fr->callno])
(8717,0)
(8718,"TBD")
(8719,integer)
(8720,bridged_chan)
(8721,datalen)
(8722,ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested \'%s\' incompatible with our capability \'%s\'.\\n", ast_inet_ntoa(sin.sin_addr)
(8723,if (ast_format_to_old_bitfield(&f.subclass.format)
(8724,f.subclass)
(8725,iaxs[fr->callno])
(8726,f.subclass)
(8727,callno)
(8728,fr->ts)
(8729,(f.frametype == AST_FRAME_VOICE)
(8730,datalen)
(8731,f)
(8732,fh)
(8733,&ied0)
(8734,callno)
(8735,callno)
(8736,sin_addr)
(8737,1)
(8738,iaxsl)
(8739,f.subclass.integer != IAX_COMMAND_VNAK)
(8740,fh)
(8741,IAX_CALLENCRYPTED(iaxs[fr->callno])
(8742,if (f.frametype == AST_FRAME_VIDEO)
(8743,f.subclass.format)
(8744,iaxs)
(8745,IAX_IE_CAUSECODE)
(8746,ied0)
(8747,format)
(8748,iaxs[fr->callno])
(8749,ies)
(8750,owner)
(8751,callno)
(8752,fr)
(8753,iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->callno)
(8754,integer)
(8755,callno)
(8756,cur)
(8757,peer->historicms)
(8758,name)
(8759,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(8760,dcallno)
(8761,cause_code)
(8762,fr->callno)
(8763,0)
(8764,fr)
(8765,(struct ast_iax2_full_hdr *)
(8766,callno)
(8767,)
(8768,videoformat)
(8769,owner)
(8770,iaxs[fr->callno]->bridgecallno)
(8771,tmp1)
(8772,mh)
(8773,fr)
(8774,IAX_COMMAND_TXACC)
(8775,iaxs)
(8776,memset(&ied0, 0, sizeof(ied0)
(8777,iaxs)
(8778,iaxs[fr->callno]->peercapability)
(8779,iaxs[fr->callno]->calling_pres)
(8780,f.frametype)
(8781,subclass)
(8782,fr->callno)
(8783,fr)
(8784,ied0)
(8785,fr)
(8786,f)
(8787,subclass)
(8788,&iaxs[fr->callno]->state)
(8789,iaxs[fr->callno])
(8790,0)
(8791,*fr)
(8792,iaxs[fr->callno]->capability)
(8793,if (!iaxs[fr->callno])
(8794,variablestore->data)
(8795,&ied1)
(8796,IAX_COMMAND_TXCNT)
(8797,iax2_destroy(fr->callno)
(8798,ied0)
(8799,!format)
(8800,send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
(8801,fr)
(8802,-1)
(8803,iaxs[fr->callno])
(8804,sin_addr)
(8805,iaxs[fr->callno]->capability)
(8806,fr->callno)
(8807,break;)
(8808,if (!format)
(8809,variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL)
(8810,&iaxs[fr->callno]->prefs)
(8811,f.subclass.integer != IAX_COMMAND_ACK)
(8812,callno)
(8813,1)
(8814,iaxs)
(8815,NULL)
(8816,pref)
(8817,if (ies.vars)
(8818,"I have IAX variables, but they were not processed\\n")
(8819,peer)
(8820,IAX_COMMAND_LAGRQ)
(8821,if (!format)
(8822,iaxs[fr->callno])
(8823,fr)
(8824,pingied)
(8825,var)
(8826,fr->ts)
(8827,(int)
(8828,1)
(8829,return 1;)
(8830,f.datalen)
(8831,)
(8832,iax_firmware_append(&ied0, (unsigned char *)
(8833,f.frametype == AST_FRAME_CONTROL)
(8834,iaxs[fr->callno]->peercapability)
(8835,samples)
(8836,f)
(8837,peercapability)
(8838,format)
(8839,iaxs[fr->callno])
(8840,ast_log(LOG_NOTICE, "Packet Decrypt Failed!\\n")
(8841,f.subclass)
(8842,0)
(8843,)
(8844,if (decrypted)
(8845,iaxs)
(8846,if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(8847,f.subclass)
(8848,iaxs[fr->callno])
(8849,peer->historicms = iaxs[fr->callno]->pingtime)
(8850,fr->callno)
(8851,fr->callno)
(8852,last)
(8853,iax2_destroy(fr->callno)
(8854,callno)
(8855,fr->callno)
(8856,fh)
(8857,callno)
(8858,f.subclass.integer)
(8859,fr)
(8860,callno)
(8861,f)
(8862,manager_event(EVENT_FLAG_SYSTEM, "Registry", "ChannelType: IAX2\\r\\nUsername: %s\\r\\nStatus: Rejected\\r\\nCause: %s\\r\\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>")
(8863,complete_transfer(fr->callno, &ies)
(8864,&iaxs[fr->callno]->state)
(8865,&iax2_variable_datastore_info)
(8866,iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)
(8867,IAX_COMMAND_REJECT)
(8868,f.subclass.integer)
(8869,"Rejected connect attempt from %s, request \'%s@%s\' does not exist\\n")
(8870,fr)
(8871,host_pref_buf)
(8872,ast_channel_unlock(iaxs[fr->callno]->owner)
(8873,subclass)
(8874,fh)
(8875,f.subclass.integer != IAX_COMMAND_INVAL)
(8876,)
(8877,ast_log(LOG_WARNING, "Call on %s is already up, can\'t start on it\\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner)
(8878,0)
(8879,iaxs)
(8880,prefs)
(8881,decrypted)
(8882,fr)
(8883,callno)
(8884,iaxs[fr->callno]->peerformat)
(8885,iax2_lock_owner(fr->callno)
(8886,ntohs(sin.sin_port)
(8887,ies.challenge)
(8888,peer->name)
(8889,callno)
(8890,fr->callno)
(8891,fr->ts)
(8892,fr->callno)
(8893,f.frametype)
(8894,ast_debug(1, "Peer %s lag measured as %dms\\n",\n\\n\\t\\t\\t\\t\\t\\t\\tast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr)
(8895,integer)
(8896,AST_FRAME_IAX)
(8897,break;)
(8898,NULL)
(8899,fr)
(8900,callno)
(8901,NULL)
(8902,iaxs[fr->callno]->owner)
(8903,if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_POKE)
(8904,AST_CONTROL_CONGESTION)
(8905,bridgecallno)
(8906,break;)
(8907,if ((peer->lastms < 0)
(8908,iaxs[fr->callno])
(8909,AST_FRAME_VIDEO)
(8910,inaddrcmp(&sin, &iaxs[fr->callno]->addr)
(8911,tmp)
(8912,auth_fail(fr->callno, IAX_COMMAND_REJECT)
(8913,iaxs[fr->callno])
(8914,ts)
(8915,ies.vars)
(8916,0)
(8917,)
(8918,iaxs[fr->callno]->owner)
(8919,fr)
(8920,callno)
(8921,first_iax_message)
(8922,iaxs[fr->callno])
(8923,f.subclass)
(8924,1)
(8925,fr)
(8926,if (!iaxs[fr->callno])
(8927,1)
(8928,iaxs[fr->callno]->context)
(8929,fr->callno)
(8930,)
(8931,fr->callno)
(8932,fr)
(8933,frametype)
(8934,&ied1)
(8935,state)
(8936,callno)
(8937,iaxs[fr->callno]->capability)
(8938,*orignative = ast_format_cap_dup(ast_channel_nativeformats(iaxs[fr->callno]->owner)
(8939,)
(8940,f.data.ptr = NULL)
(8941,vars)
(8942,peer)
(8943,IAX_COMMAND_INVAL)
(8944,fr->callno)
(8945,fr->callno)
(8946,sin)
(8947,IAX_FORCE_ENCRYPT)
(8948,!minivid)
(8949,fr)
(8950,iaxs[fr->callno])
(8951,if (variablestore && varlist)
(8952,fr)
(8953,0)
(8954,&sin)
(8955,integer)
(8956,if (var)
(8957,f.frametype)
(8958,AST_FRAME_IAX)
(8959,owner)
(8960,fh->type)
(8961,called_number)
(8962,iax2_getformatname_multiple(tmp2, sizeof(tmp2)
(8963,duped_fr)
(8964,iaxs[fr->callno])
(8965,0)
(8966,fr->callno)
(8967,f)
(8968,state)
(8969,fr)
(8970,*newvar = ast_var_assign(var->name, var->value)
(8971,TRANSFER_MBEGIN)
(8972,iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION)
(8973,fr->callno)
(8974,fr)
(8975,struct iax2_thread *thread)
(8976,EVENT_FLAG_SYSTEM)
(8977,iaxs)
(8978,fr)
(8979,)
(8980,struct ast_iax2_video_hdr *)
(8981,(f.subclass.integer != IAX_COMMAND_UNQUELCH )
(8982,"For call=%d, set last=%d\\n")
(8983,frametype)
(8984,callno)
(8985,iaxs)
(8986,)
(8987,var->next)
(8988,res)
(8989,sin.sin_addr)
(8990,fr->callno)
(8991,(x != iaxs[fr->callno]->oseqno)
(8992,1)
(8993,callno)
(8994,&ies)
(8995,)
(8996,fr)
(8997,strcpy(caller_pref_buf,"disabled")
(8998,f.datalen = res - sizeof(struct ast_iax2_mini_hdr)
(8999,transfer)
(9000,ast_log(LOG_WARNING, "Failed to park call \'%s\'\\n",\n\\n\\t\\t\\t\\t\\t\\t\\t\\tast_channel_name(bridged_chan)
(9001,integer)
(9002,using_prefs)
(9003,iaxs)
(9004,fr)
(9005,callno)
(9006,IAX_STATE_STARTED | IAX_STATE_TBD)
(9007,variablestore->inheritance)
(9008,fr->ts)
(9009,integer)
(9010,)
(9011,*varlist)
(9012,vars)
(9013,IAX_CODEC_NOCAP)
(9014,ied0)
(9015,iaxs[fr->callno] && iaxs[fr->callno]->last < fr->ts)
(9016,iaxs)
(9017,ast_format_to_old_bitfield(&f.subclass.format)
(9018,iaxs[fr->callno]->capability)
(9019,fr->ts)
(9020,)
(9021,iaxs[fr->callno]->iseqno - fr->oseqno)
(9022,iaxs[fr->callno]->capability)
(9023,thread->buf[res++] = \'\\0\')
(9024,&iaxsl[fr->callno])
(9025,iaxs[fr->callno]->owner)
(9026,return 1;)
(9027,ast_calloc(1, sizeof(*varlist)
(9028,memset(&ied0, 0, sizeof(ied0)
(9029,iaxs[fr->callno]->prefs)
(9030,IAX_COMMAND_REGREJ)
(9031,fr->callno)
(9032,break;)
(9033,fr->callno)
(9034,var)
(9035,AST_FRAME_IAX)
(9036,using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(9037,return 1;)
(9038,context)
(9039,AST_FRAME_IAX)
(9040,f.subclass.integer)
(9041,f.subclass.integer != IAX_COMMAND_VNAK)
(9042,f.subclass.integer)
(9043,fr->callno)
(9044,&ied0)
(9045,f)
(9046,ied1)
(9047,varlist)
(9048,mh)
(9049,iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno)
(9050,ast_variables_destroy(ies.vars)
(9051,iaxs[fr->callno])
(9052,iaxs[fr->callno]->first_iax_message)
(9053,integer)
(9054,format)
(9055,f.subclass.integer)
(9056,fd)
(9057,callno)
(9058,using_prefs = "mine")
(9059,fr)
(9060,callno)
(9061,f)
(9062,f.frametype)
(9063,f.subclass.integer != IAX_COMMAND_PONG &&\n\\n                            f.subclass.integer != IAX_COMMAND_LAGRP)
(9064,)
(9065,fr->callno)
(9066,ast_mutex_unlock(&iaxsl[fr->callno])
(9067,callno)
(9068,if (ies.causecode > 99)
(9069,ast_channel_unlock(iaxs[fr->callno]->owner)
(9070,iaxs)
(9071,fr->callno)
(9072,c = ast_iax2_new(fr->callno, AST_STATE_RING, format, NULL, 1)
(9073,iaxs[fr->callno]->pingtime)
(9074,)
(9075,f.data.ptr)
(9076,f.subclass.integer == IAX_COMMAND_NEW)
(9077,0)
(9078,"disabled")
(9079,iaxs)
(9080,(iaxs[fr->callno]->last & 0xFFFF8000L)
(9081,iaxs[fr->callno])
(9082,break;)
(9083,fr->callno)
(9084,iaxs)
(9085,fr->callno)
(9086,if (f.subclass.integer == AST_CONTROL_BUSY)
(9087,fr)
(9088,fr)
(9089,var->next = iaxs[fr->callno]->iaxvars)
(9090,fr->callno)
(9091,iaxdebug && iaxs[fr->callno])
(9092,iaxs[iaxs[fr->callno]->bridgecallno])
(9093,make_trunk(fr->callno, 1)
(9094,if (iaxs[fr->callno]->transferring == TRANSFER_MREADY)
(9095,callno)
(9096,iaxs[fr->callno])
(9097,break;)
(9098,0x7fff)
(9099,subclass)
(9100,fr->callno)
(9101,test_resync)
(9102,fr->callno)
(9103,fr)
(9104,sizeof(*varlist)
(9105,iaxs[fr->callno])
(9106,ast_debug(1, "Immediately destroying %d, having received INVAL\\n", fr->callno)
(9107,0)
(9108,ies.vars)
(9109,fr)
(9110,1)
(9111,IAX_IE_IAX_UNKNOWN)
(9112,0)
(9113,)
(9114,iaxsl[fr->callno])
(9115,iaxs[fr->callno]->peercapability)
(9116,fr->callno)
(9117,AST_LIST_UNLOCK(&dpcache)
(9118,)
(9119,fr->callno)
(9120,sizeof(tmp1)
(9121,exten)
(9122,iaxs[fr->callno])
(9123,iaxs[fr->callno])
(9124,ast_free(varlist)
(9125,fr->callno)
(9126,f.subclass.format)
(9127,peer)
(9128,fr->callno)
(9129,iaxs[fr->callno])
(9130,fr->callno)
(9131,ies.provver)
(9132,callno)
(9133,f.subclass.integer != IAX_COMMAND_TXACC)
(9134,ast_party_connected_line_init(&connected)
(9135,iaxs)
(9136,tmpfmt)
(9137,((f.subclass.integer != IAX_COMMAND_TXCNT)
(9138,callno)
(9139,1)
(9140,"disabled")
(9141,iaxs)
(9142,fr->callno)
(9143,exists)
(9144,fr)
(9145,fr->callno)
(9146,sin_addr)
(9147,oseqno)
(9148,fr->callno)
(9149,cause)
(9150,iaxs[fr->callno])
(9151,"Registry")
(9152,ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\\n")
(9153,fr)
(9154,peerformat)
(9155,iax2_getformatname_multiple(tmp3, sizeof(tmp3)
(9156,iaxs[fr->callno]->capability)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^