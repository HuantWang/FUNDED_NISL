-----label-----
1
-----code-----
static int set_member_paused(const char *queuename, const char *interface, const char *reason, int paused)
{
	int found = 0;
	struct call_queue *q;
	struct member *mem;
	struct ao2_iterator queue_iter;
	int failed;

	/* Special event for when all queues are paused - individual events still generated */
	/* XXX In all other cases, we use the membername, but since this affects all queues, we cannot */
	if (ast_strlen_zero(queuename))
		ast_queue_log("NONE", "NONE", interface, (paused ? "PAUSEALL" : "UNPAUSEALL"), "%s", "");

	queue_iter = ao2_iterator_init(queues, 0);
	while ((q = ao2_t_iterator_next(&queue_iter, "Iterate over queues"))) {
		ao2_lock(q);
		if (ast_strlen_zero(queuename) || !strcasecmp(q->name, queuename)) {
			if ((mem = interface_exists(q, interface))) {
				if (mem->paused == paused) {
					ast_debug(1, "%spausing already-%spaused queue member %s:%s\n", (paused ? "" : "un"), (paused ? "" : "un"), q->name, interface);
				}

				failed = 0;
				if (mem->realtime) {
					failed = update_realtime_member_field(mem, q->name, "paused", paused ? "1" : "0");
				}

				if (failed) {
					ast_log(LOG_WARNING, "Failed %spausing realtime queue member %s:%s\n", (paused ? "" : "un"), q->name, interface);
					ao2_ref(mem, -1);
					ao2_unlock(q);
					queue_t_unref(q, "Done with iterator");
					continue;
				}
				found++;
				mem->paused = paused;

				if (queue_persistent_members) {
					dump_queue_members(q);
				}

				if (is_member_available(mem)) {
					ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Queue:%s_avail", q->name);
				} else if (!num_available_members(q)) {
					ast_devstate_changed(AST_DEVICE_INUSE, AST_DEVSTATE_CACHABLE, "Queue:%s_avail", q->name);
				}

				ast_queue_log(q->name, "NONE", mem->membername, (paused ? "PAUSE" : "UNPAUSE"), "%s", S_OR(reason, ""));

				/*** DOCUMENTATION
				<managerEventInstance>
					<synopsis>Raised when a member is paused/unpaused in the queue with a reason.</synopsis>
					<syntax>
						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />
						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Location'])" />
						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='MemberName'])" />
						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Paused'])" />
					</syntax>
					<see-also>
						<ref type="application">PauseQueueMember</ref>
						<ref type="application">UnPauseQueueMember</ref>
					</see-also>
				</managerEventInstance>
				***/
				if (!ast_strlen_zero(reason)) {
					manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",
						"Queue: %s\r\n"
						"Location: %s\r\n"
						"MemberName: %s\r\n"
						"Paused: %d\r\n"
						"Reason: %s\r\n",
							q->name, mem->interface, mem->membername, paused, reason);
				} else {
					/*** DOCUMENTATION
					<managerEventInstance>
						<synopsis>Raised when a member is paused/unpaused in the queue without a reason.</synopsis>
						<syntax>
							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />
							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Location'])" />
							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='MemberName'])" />
							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Paused'])" />
						</syntax>
						<see-also>
							<ref type="application">PauseQueueMember</ref>
							<ref type="application">UnPauseQueueMember</ref>
						</see-also>
					</managerEventInstance>
					***/
					manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",
						"Queue: %s\r\n"
						"Location: %s\r\n"
						"MemberName: %s\r\n"
						"Paused: %d\r\n",
							q->name, mem->interface, mem->membername, paused);
				}
				ao2_ref(mem, -1);
			}
		}

		if (!ast_strlen_zero(queuename) && !strcasecmp(queuename, q->name)) {
			ao2_unlock(q);
			queue_t_unref(q, "Done with iterator");
			break;
		}

		ao2_unlock(q);
		queue_t_unref(q, "Done with iterator");
	}
	ao2_iterator_destroy(&queue_iter);

	return found ? RESULT_SUCCESS : RESULT_FAILURE;
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
3,7
3,8
5,6
5,7
7,8
7,9
10,11
10,12
12,13
12,14
15,16
15,17
17,18
17,19
20,21
20,22
22,23
24,25
24,26
24,27
24,28
24,29
24,30
24,31
24,32
24,33
24,34
25,26
26,27
26,28
28,29
28,30
30,31
32,33
33,34
33,35
34,35
36,37
36,38
39,40
40,41
40,42
41,42
43,44
43,45
46,47
47,48
47,49
48,49
50,51
52,53
53,54
53,55
55,56
57,58
57,59
58,59
58,60
59,60
61,62
63,64
64,65
64,66
64,67
64,68
64,69
64,70
64,71
65,66
69,70
71,72
72,73
72,74
72,75
73,74
79,80
80,81
80,82
81,82
83,84
83,85
83,86
84,85
86,87
89,90
89,91
90,91
91,92
91,93
92,93
94,95
94,96
94,97
95,96
97,98
98,99
101,102
101,103
101,104
101,105
101,106
102,103
103,104
103,105
104,105
106,107
108,109
108,110
109,110
109,111
110,111
110,112
111,112
113,114
115,116
116,117
116,118
116,119
117,118
119,120
119,121
120,121
123,124
125,126
126,127
126,128
127,128
128,129
128,130
129,130
131,132
131,133
131,134
132,133
134,135
136,137
138,139
138,140
138,141
138,142
138,143
138,144
138,145
138,146
138,147
138,148
138,149
139,140
139,141
140,141
140,142
141,142
141,143
142,143
145,146
147,148
148,149
149,150
149,151
149,152
149,153
149,154
149,155
149,156
150,151
154,155
155,156
155,157
155,158
156,157
160,161
161,162
161,163
161,164
162,163
166,167
166,168
167,168
170,171
172,173
173,174
173,175
174,175
177,178
177,179
178,179
178,180
179,180
182,183
183,184
184,185
184,186
185,186
187,188
187,189
187,190
187,191
187,192
188,189
190,191
192,193
192,194
193,194
197,198
197,199
197,200
198,199
202,203
202,204
203,204
205,206
205,207
205,208
205,209
205,210
206,207
207,208
207,209
207,210
207,211
207,212
207,213
208,209
210,211
213,214
214,215
214,216
214,217
215,216
219,220
219,221
220,221
223,224
225,226
226,227
226,228
226,229
227,228
229,230
231,232
233,234
234,235
234,236
235,236
237,238
239,240
240,241
240,242
240,243
241,242
243,244
247,248
248,249
249,250
251,252
252,253
252,254
253,254
253,255
254,255
257,258
259,260
259,261
260,261
262,263
263,264
264,265
264,266
265,266
267,268
269,270
269,271
269,272
270,271
270,272
271,272
273,274
275,276
276,277
277,278
277,279
277,280
277,281
277,282
278,279
280,281
282,283
285,286
285,287
286,287
289,290
289,291
290,291
291,292
291,293
292,293
294,295
296,297
297,298
298,299
298,300
298,301
298,302
298,303
299,300
301,302
303,304
306,307
306,308
307,308
310,311
311,312
311,313
311,314
311,315
311,316
311,317
311,318
312,313
314,315
314,316
315,316
319,320
319,321
320,321
323,324
324,325
324,326
324,327
325,326
330,331
330,332
330,333
331,332
333,334
336,337
336,338
336,339
337,338
338,339
338,340
339,340
341,342
343,344
344,345
345,346
345,347
345,348
345,349
345,350
345,351
345,352
345,353
345,354
346,347
348,349
352,353
352,354
353,354
356,357
356,358
357,358
360,361
360,362
361,362
364,365
366,367
368,369
369,370
370,371
370,372
370,373
370,374
370,375
370,376
370,377
370,378
371,372
373,374
377,378
377,379
378,379
381,382
381,383
382,383
385,386
385,387
386,387
389,390
391,392
392,393
392,394
392,395
393,394
395,396
397,398
399,400
399,401
400,401
400,402
401,402
402,403
402,404
403,404
405,406
407,408
408,409
408,410
408,411
409,410
411,412
413,414
413,415
414,415
417,418
417,419
417,420
418,419
419,420
419,421
420,421
422,423
424,425
425,426
425,427
425,428
426,427
428,429
432,433
433,434
433,435
434,435
436,437
438,439
439,440
439,441
439,442
440,441
442,443
445,446
446,447
446,448
447,448
449,450
450,451
452,453
453,454
453,455
453,456
454,455
456,457
458,459
-----nextToken-----
2,4,6,8,9,11,13,14,16,18,19,21,23,27,29,31,35,37,38,42,44,45,49,51,54,56,60,62,66,67,68,70,74,75,76,77,78,82,85,87,88,93,96,99,100,105,107,112,114,118,121,122,124,130,133,135,137,143,144,146,151,152,153,157,158,159,163,164,165,168,169,171,175,176,180,181,186,189,191,194,195,196,199,200,201,204,209,211,212,216,217,218,221,222,224,228,230,232,236,238,242,244,245,246,250,255,256,258,261,266,268,272,274,279,281,283,284,287,288,293,295,300,302,304,305,308,309,313,316,317,318,321,322,326,327,328,329,332,334,335,340,342,347,349,350,351,354,355,358,359,362,363,365,367,372,374,375,376,379,380,383,384,387,388,390,394,396,398,404,406,410,412,415,416,421,423,427,429,430,431,435,437,441,443,444,448,451,455,457,459
-----computeFrom-----
80,81
80,82
91,92
91,93
109,110
109,111
128,129
128,130
140,141
140,142
173,174
173,175
184,185
184,186
252,253
252,254
400,401
400,402
-----guardedBy-----
121,379
122,380
112,340
146,163
415,429
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;UnaryExpression;ConditionalExpression;IdExpression;Name;LiteralExpression;LiteralExpression;LiteralExpression;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;WhileStatement;UnaryExpression;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;UnaryExpression;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;UnaryExpression;ConditionalExpression;IdExpression;Name;LiteralExpression;LiteralExpression;UnaryExpression;ConditionalExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;ConditionalExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;UnaryExpression;ConditionalExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ContinueStatement;ExpressionStatement;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;ConditionalExpression;IdExpression;Name;LiteralExpression;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;LiteralExpression;IfStatement;BinaryExpression;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;BreakStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ReturnStatement;ConditionalExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;
-----ast_node-----
static int set_member_paused(const char *queuename, const char *interface, const char *reason, int paused){	int found = 0;	struct call_queue *q;	struct member *mem;	struct ao2_iterator queue_iter;	int failed;	/* Special event for when all queues are paused - individual events still generated */	/* XXX In all other cases, we use the membername, but since this affects all queues, we cannot */	if (ast_strlen_zero(queuename))		ast_queue_log("NONE", "NONE", interface, (paused ? "PAUSEALL" : "UNPAUSEALL"), "%s", "");	queue_iter = ao2_iterator_init(queues, 0);	while ((q = ao2_t_iterator_next(&queue_iter, "Iterate over queues"))) {		ao2_lock(q);		if (ast_strlen_zero(queuename) || !strcasecmp(q->name, queuename)) {			if ((mem = interface_exists(q, interface))) {				if (mem->paused == paused) {					ast_debug(1, "%spausing already-%spaused queue member %s:%s\n", (paused ? "" : "un"), (paused ? "" : "un"), q->name, interface);				}				failed = 0;				if (mem->realtime) {					failed = update_realtime_member_field(mem, q->name, "paused", paused ? "1" : "0");				}				if (failed) {					ast_log(LOG_WARNING, "Failed %spausing realtime queue member %s:%s\n", (paused ? "" : "un"), q->name, interface);					ao2_ref(mem, -1);					ao2_unlock(q);					queue_t_unref(q, "Done with iterator");					continue;				}				found++;				mem->paused = paused;				if (queue_persistent_members) {					dump_queue_members(q);				}				if (is_member_available(mem)) {					ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Queue:%s_avail", q->name);				} else if (!num_available_members(q)) {					ast_devstate_changed(AST_DEVICE_INUSE, AST_DEVSTATE_CACHABLE, "Queue:%s_avail", q->name);				}				ast_queue_log(q->name, "NONE", mem->membername, (paused ? "PAUSE" : "UNPAUSE"), "%s", S_OR(reason, ""));				/*** DOCUMENTATION				<managerEventInstance>					<synopsis>Raised when a member is paused/unpaused in the queue with a reason.</synopsis>					<syntax>						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Location'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='MemberName'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Paused'])" />					</syntax>					<see-also>						<ref type="application">PauseQueueMember</ref>						<ref type="application">UnPauseQueueMember</ref>					</see-also>				</managerEventInstance>				***/				if (!ast_strlen_zero(reason)) {					manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n"						"Reason: %s\r\n",							q->name, mem->interface, mem->membername, paused, reason);				} else {					/*** DOCUMENTATION					<managerEventInstance>						<synopsis>Raised when a member is paused/unpaused in the queue without a reason.</synopsis>						<syntax>							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Location'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='MemberName'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Paused'])" />						</syntax>						<see-also>							<ref type="application">PauseQueueMember</ref>							<ref type="application">UnPauseQueueMember</ref>						</see-also>					</managerEventInstance>					***/					manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n",							q->name, mem->interface, mem->membername, paused);				}				ao2_ref(mem, -1);			}		}		if (!ast_strlen_zero(queuename) && !strcasecmp(queuename, q->name)) {			ao2_unlock(q);			queue_t_unref(q, "Done with iterator");			break;		}		ao2_unlock(q);		queue_t_unref(q, "Done with iterator");	}	ao2_iterator_destroy(&queue_iter);	return found ? RESULT_SUCCESS : RESULT_FAILURE;}
static int
set_member_paused(const char *queuename, const char *interface, const char *reason, int paused)
set_member_paused
const char *queuename
const char
*queuename
*
queuename
const char *interface
const char
*interface
*
interface
const char *reason
const char
*reason
*
reason
int paused
int
paused
paused
{	int found = 0;	struct call_queue *q;	struct member *mem;	struct ao2_iterator queue_iter;	int failed;	/* Special event for when all queues are paused - individual events still generated */	/* XXX In all other cases, we use the membername, but since this affects all queues, we cannot */	if (ast_strlen_zero(queuename))		ast_queue_log("NONE", "NONE", interface, (paused ? "PAUSEALL" : "UNPAUSEALL"), "%s", "");	queue_iter = ao2_iterator_init(queues, 0);	while ((q = ao2_t_iterator_next(&queue_iter, "Iterate over queues"))) {		ao2_lock(q);		if (ast_strlen_zero(queuename) || !strcasecmp(q->name, queuename)) {			if ((mem = interface_exists(q, interface))) {				if (mem->paused == paused) {					ast_debug(1, "%spausing already-%spaused queue member %s:%s\n", (paused ? "" : "un"), (paused ? "" : "un"), q->name, interface);				}				failed = 0;				if (mem->realtime) {					failed = update_realtime_member_field(mem, q->name, "paused", paused ? "1" : "0");				}				if (failed) {					ast_log(LOG_WARNING, "Failed %spausing realtime queue member %s:%s\n", (paused ? "" : "un"), q->name, interface);					ao2_ref(mem, -1);					ao2_unlock(q);					queue_t_unref(q, "Done with iterator");					continue;				}				found++;				mem->paused = paused;				if (queue_persistent_members) {					dump_queue_members(q);				}				if (is_member_available(mem)) {					ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Queue:%s_avail", q->name);				} else if (!num_available_members(q)) {					ast_devstate_changed(AST_DEVICE_INUSE, AST_DEVSTATE_CACHABLE, "Queue:%s_avail", q->name);				}				ast_queue_log(q->name, "NONE", mem->membername, (paused ? "PAUSE" : "UNPAUSE"), "%s", S_OR(reason, ""));				/*** DOCUMENTATION				<managerEventInstance>					<synopsis>Raised when a member is paused/unpaused in the queue with a reason.</synopsis>					<syntax>						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Location'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='MemberName'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Paused'])" />					</syntax>					<see-also>						<ref type="application">PauseQueueMember</ref>						<ref type="application">UnPauseQueueMember</ref>					</see-also>				</managerEventInstance>				***/				if (!ast_strlen_zero(reason)) {					manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n"						"Reason: %s\r\n",							q->name, mem->interface, mem->membername, paused, reason);				} else {					/*** DOCUMENTATION					<managerEventInstance>						<synopsis>Raised when a member is paused/unpaused in the queue without a reason.</synopsis>						<syntax>							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Location'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='MemberName'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Paused'])" />						</syntax>						<see-also>							<ref type="application">PauseQueueMember</ref>							<ref type="application">UnPauseQueueMember</ref>						</see-also>					</managerEventInstance>					***/					manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n",							q->name, mem->interface, mem->membername, paused);				}				ao2_ref(mem, -1);			}		}		if (!ast_strlen_zero(queuename) && !strcasecmp(queuename, q->name)) {			ao2_unlock(q);			queue_t_unref(q, "Done with iterator");			break;		}		ao2_unlock(q);		queue_t_unref(q, "Done with iterator");	}	ao2_iterator_destroy(&queue_iter);	return found ? RESULT_SUCCESS : RESULT_FAILURE;}
int found = 0;
int found = 0;
int
found = 0
found
= 0
0
struct call_queue *q;
struct call_queue *q;
struct call_queue
call_queue
*q
*
q
struct member *mem;
struct member *mem;
struct member
member
*mem
*
mem
struct ao2_iterator queue_iter;
struct ao2_iterator queue_iter;
struct ao2_iterator
ao2_iterator
queue_iter
queue_iter
int failed;
int failed;
int
failed
failed
if (ast_strlen_zero(queuename))		ast_queue_log("NONE", "NONE", interface, (paused ? "PAUSEALL" : "UNPAUSEALL"), "%s", "");
ast_strlen_zero(queuename)
ast_strlen_zero
ast_strlen_zero
queuename
queuename
ast_queue_log("NONE", "NONE", interface, (paused ? "PAUSEALL" : "UNPAUSEALL"), "%s", "");
ast_queue_log("NONE", "NONE", interface, (paused ? "PAUSEALL" : "UNPAUSEALL"), "%s", "")
ast_queue_log
ast_queue_log
"NONE"
"NONE"
interface
interface
(paused ? "PAUSEALL" : "UNPAUSEALL")
paused ? "PAUSEALL" : "UNPAUSEALL"
paused
paused
"PAUSEALL"
"UNPAUSEALL"
"%s"
""
queue_iter = ao2_iterator_init(queues, 0);
queue_iter = ao2_iterator_init(queues, 0)
queue_iter
queue_iter
ao2_iterator_init(queues, 0)
ao2_iterator_init
ao2_iterator_init
queues
queues
0
while ((q = ao2_t_iterator_next(&queue_iter, "Iterate over queues"))) {		ao2_lock(q);		if (ast_strlen_zero(queuename) || !strcasecmp(q->name, queuename)) {			if ((mem = interface_exists(q, interface))) {				if (mem->paused == paused) {					ast_debug(1, "%spausing already-%spaused queue member %s:%s\n", (paused ? "" : "un"), (paused ? "" : "un"), q->name, interface);				}				failed = 0;				if (mem->realtime) {					failed = update_realtime_member_field(mem, q->name, "paused", paused ? "1" : "0");				}				if (failed) {					ast_log(LOG_WARNING, "Failed %spausing realtime queue member %s:%s\n", (paused ? "" : "un"), q->name, interface);					ao2_ref(mem, -1);					ao2_unlock(q);					queue_t_unref(q, "Done with iterator");					continue;				}				found++;				mem->paused = paused;				if (queue_persistent_members) {					dump_queue_members(q);				}				if (is_member_available(mem)) {					ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Queue:%s_avail", q->name);				} else if (!num_available_members(q)) {					ast_devstate_changed(AST_DEVICE_INUSE, AST_DEVSTATE_CACHABLE, "Queue:%s_avail", q->name);				}				ast_queue_log(q->name, "NONE", mem->membername, (paused ? "PAUSE" : "UNPAUSE"), "%s", S_OR(reason, ""));				/*** DOCUMENTATION				<managerEventInstance>					<synopsis>Raised when a member is paused/unpaused in the queue with a reason.</synopsis>					<syntax>						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Location'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='MemberName'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Paused'])" />					</syntax>					<see-also>						<ref type="application">PauseQueueMember</ref>						<ref type="application">UnPauseQueueMember</ref>					</see-also>				</managerEventInstance>				***/				if (!ast_strlen_zero(reason)) {					manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n"						"Reason: %s\r\n",							q->name, mem->interface, mem->membername, paused, reason);				} else {					/*** DOCUMENTATION					<managerEventInstance>						<synopsis>Raised when a member is paused/unpaused in the queue without a reason.</synopsis>						<syntax>							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Location'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='MemberName'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Paused'])" />						</syntax>						<see-also>							<ref type="application">PauseQueueMember</ref>							<ref type="application">UnPauseQueueMember</ref>						</see-also>					</managerEventInstance>					***/					manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n",							q->name, mem->interface, mem->membername, paused);				}				ao2_ref(mem, -1);			}		}		if (!ast_strlen_zero(queuename) && !strcasecmp(queuename, q->name)) {			ao2_unlock(q);			queue_t_unref(q, "Done with iterator");			break;		}		ao2_unlock(q);		queue_t_unref(q, "Done with iterator");	}
(q = ao2_t_iterator_next(&queue_iter, "Iterate over queues"))
q = ao2_t_iterator_next(&queue_iter, "Iterate over queues")
q
q
ao2_t_iterator_next(&queue_iter, "Iterate over queues")
ao2_t_iterator_next
ao2_t_iterator_next
&queue_iter
queue_iter
queue_iter
"Iterate over queues"
{		ao2_lock(q);		if (ast_strlen_zero(queuename) || !strcasecmp(q->name, queuename)) {			if ((mem = interface_exists(q, interface))) {				if (mem->paused == paused) {					ast_debug(1, "%spausing already-%spaused queue member %s:%s\n", (paused ? "" : "un"), (paused ? "" : "un"), q->name, interface);				}				failed = 0;				if (mem->realtime) {					failed = update_realtime_member_field(mem, q->name, "paused", paused ? "1" : "0");				}				if (failed) {					ast_log(LOG_WARNING, "Failed %spausing realtime queue member %s:%s\n", (paused ? "" : "un"), q->name, interface);					ao2_ref(mem, -1);					ao2_unlock(q);					queue_t_unref(q, "Done with iterator");					continue;				}				found++;				mem->paused = paused;				if (queue_persistent_members) {					dump_queue_members(q);				}				if (is_member_available(mem)) {					ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Queue:%s_avail", q->name);				} else if (!num_available_members(q)) {					ast_devstate_changed(AST_DEVICE_INUSE, AST_DEVSTATE_CACHABLE, "Queue:%s_avail", q->name);				}				ast_queue_log(q->name, "NONE", mem->membername, (paused ? "PAUSE" : "UNPAUSE"), "%s", S_OR(reason, ""));				/*** DOCUMENTATION				<managerEventInstance>					<synopsis>Raised when a member is paused/unpaused in the queue with a reason.</synopsis>					<syntax>						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Location'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='MemberName'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Paused'])" />					</syntax>					<see-also>						<ref type="application">PauseQueueMember</ref>						<ref type="application">UnPauseQueueMember</ref>					</see-also>				</managerEventInstance>				***/				if (!ast_strlen_zero(reason)) {					manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n"						"Reason: %s\r\n",							q->name, mem->interface, mem->membername, paused, reason);				} else {					/*** DOCUMENTATION					<managerEventInstance>						<synopsis>Raised when a member is paused/unpaused in the queue without a reason.</synopsis>						<syntax>							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Location'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='MemberName'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Paused'])" />						</syntax>						<see-also>							<ref type="application">PauseQueueMember</ref>							<ref type="application">UnPauseQueueMember</ref>						</see-also>					</managerEventInstance>					***/					manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n",							q->name, mem->interface, mem->membername, paused);				}				ao2_ref(mem, -1);			}		}		if (!ast_strlen_zero(queuename) && !strcasecmp(queuename, q->name)) {			ao2_unlock(q);			queue_t_unref(q, "Done with iterator");			break;		}		ao2_unlock(q);		queue_t_unref(q, "Done with iterator");	}
ao2_lock(q);
ao2_lock(q)
ao2_lock
ao2_lock
q
q
if (ast_strlen_zero(queuename) || !strcasecmp(q->name, queuename)) {			if ((mem = interface_exists(q, interface))) {				if (mem->paused == paused) {					ast_debug(1, "%spausing already-%spaused queue member %s:%s\n", (paused ? "" : "un"), (paused ? "" : "un"), q->name, interface);				}				failed = 0;				if (mem->realtime) {					failed = update_realtime_member_field(mem, q->name, "paused", paused ? "1" : "0");				}				if (failed) {					ast_log(LOG_WARNING, "Failed %spausing realtime queue member %s:%s\n", (paused ? "" : "un"), q->name, interface);					ao2_ref(mem, -1);					ao2_unlock(q);					queue_t_unref(q, "Done with iterator");					continue;				}				found++;				mem->paused = paused;				if (queue_persistent_members) {					dump_queue_members(q);				}				if (is_member_available(mem)) {					ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Queue:%s_avail", q->name);				} else if (!num_available_members(q)) {					ast_devstate_changed(AST_DEVICE_INUSE, AST_DEVSTATE_CACHABLE, "Queue:%s_avail", q->name);				}				ast_queue_log(q->name, "NONE", mem->membername, (paused ? "PAUSE" : "UNPAUSE"), "%s", S_OR(reason, ""));				/*** DOCUMENTATION				<managerEventInstance>					<synopsis>Raised when a member is paused/unpaused in the queue with a reason.</synopsis>					<syntax>						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Location'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='MemberName'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Paused'])" />					</syntax>					<see-also>						<ref type="application">PauseQueueMember</ref>						<ref type="application">UnPauseQueueMember</ref>					</see-also>				</managerEventInstance>				***/				if (!ast_strlen_zero(reason)) {					manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n"						"Reason: %s\r\n",							q->name, mem->interface, mem->membername, paused, reason);				} else {					/*** DOCUMENTATION					<managerEventInstance>						<synopsis>Raised when a member is paused/unpaused in the queue without a reason.</synopsis>						<syntax>							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Location'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='MemberName'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Paused'])" />						</syntax>						<see-also>							<ref type="application">PauseQueueMember</ref>							<ref type="application">UnPauseQueueMember</ref>						</see-also>					</managerEventInstance>					***/					manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n",							q->name, mem->interface, mem->membername, paused);				}				ao2_ref(mem, -1);			}		}
ast_strlen_zero(queuename) || !strcasecmp(q->name, queuename)
ast_strlen_zero(queuename)
ast_strlen_zero
ast_strlen_zero
queuename
queuename
!strcasecmp(q->name, queuename)
strcasecmp(q->name, queuename)
strcasecmp
strcasecmp
q->name
q
q
name
queuename
queuename
{			if ((mem = interface_exists(q, interface))) {				if (mem->paused == paused) {					ast_debug(1, "%spausing already-%spaused queue member %s:%s\n", (paused ? "" : "un"), (paused ? "" : "un"), q->name, interface);				}				failed = 0;				if (mem->realtime) {					failed = update_realtime_member_field(mem, q->name, "paused", paused ? "1" : "0");				}				if (failed) {					ast_log(LOG_WARNING, "Failed %spausing realtime queue member %s:%s\n", (paused ? "" : "un"), q->name, interface);					ao2_ref(mem, -1);					ao2_unlock(q);					queue_t_unref(q, "Done with iterator");					continue;				}				found++;				mem->paused = paused;				if (queue_persistent_members) {					dump_queue_members(q);				}				if (is_member_available(mem)) {					ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Queue:%s_avail", q->name);				} else if (!num_available_members(q)) {					ast_devstate_changed(AST_DEVICE_INUSE, AST_DEVSTATE_CACHABLE, "Queue:%s_avail", q->name);				}				ast_queue_log(q->name, "NONE", mem->membername, (paused ? "PAUSE" : "UNPAUSE"), "%s", S_OR(reason, ""));				/*** DOCUMENTATION				<managerEventInstance>					<synopsis>Raised when a member is paused/unpaused in the queue with a reason.</synopsis>					<syntax>						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Location'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='MemberName'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Paused'])" />					</syntax>					<see-also>						<ref type="application">PauseQueueMember</ref>						<ref type="application">UnPauseQueueMember</ref>					</see-also>				</managerEventInstance>				***/				if (!ast_strlen_zero(reason)) {					manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n"						"Reason: %s\r\n",							q->name, mem->interface, mem->membername, paused, reason);				} else {					/*** DOCUMENTATION					<managerEventInstance>						<synopsis>Raised when a member is paused/unpaused in the queue without a reason.</synopsis>						<syntax>							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Location'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='MemberName'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Paused'])" />						</syntax>						<see-also>							<ref type="application">PauseQueueMember</ref>							<ref type="application">UnPauseQueueMember</ref>						</see-also>					</managerEventInstance>					***/					manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n",							q->name, mem->interface, mem->membername, paused);				}				ao2_ref(mem, -1);			}		}
if ((mem = interface_exists(q, interface))) {				if (mem->paused == paused) {					ast_debug(1, "%spausing already-%spaused queue member %s:%s\n", (paused ? "" : "un"), (paused ? "" : "un"), q->name, interface);				}				failed = 0;				if (mem->realtime) {					failed = update_realtime_member_field(mem, q->name, "paused", paused ? "1" : "0");				}				if (failed) {					ast_log(LOG_WARNING, "Failed %spausing realtime queue member %s:%s\n", (paused ? "" : "un"), q->name, interface);					ao2_ref(mem, -1);					ao2_unlock(q);					queue_t_unref(q, "Done with iterator");					continue;				}				found++;				mem->paused = paused;				if (queue_persistent_members) {					dump_queue_members(q);				}				if (is_member_available(mem)) {					ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Queue:%s_avail", q->name);				} else if (!num_available_members(q)) {					ast_devstate_changed(AST_DEVICE_INUSE, AST_DEVSTATE_CACHABLE, "Queue:%s_avail", q->name);				}				ast_queue_log(q->name, "NONE", mem->membername, (paused ? "PAUSE" : "UNPAUSE"), "%s", S_OR(reason, ""));				/*** DOCUMENTATION				<managerEventInstance>					<synopsis>Raised when a member is paused/unpaused in the queue with a reason.</synopsis>					<syntax>						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Location'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='MemberName'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Paused'])" />					</syntax>					<see-also>						<ref type="application">PauseQueueMember</ref>						<ref type="application">UnPauseQueueMember</ref>					</see-also>				</managerEventInstance>				***/				if (!ast_strlen_zero(reason)) {					manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n"						"Reason: %s\r\n",							q->name, mem->interface, mem->membername, paused, reason);				} else {					/*** DOCUMENTATION					<managerEventInstance>						<synopsis>Raised when a member is paused/unpaused in the queue without a reason.</synopsis>						<syntax>							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Location'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='MemberName'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Paused'])" />						</syntax>						<see-also>							<ref type="application">PauseQueueMember</ref>							<ref type="application">UnPauseQueueMember</ref>						</see-also>					</managerEventInstance>					***/					manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n",							q->name, mem->interface, mem->membername, paused);				}				ao2_ref(mem, -1);			}
(mem = interface_exists(q, interface))
mem = interface_exists(q, interface)
mem
mem
interface_exists(q, interface)
interface_exists
interface_exists
q
q
interface
interface
{				if (mem->paused == paused) {					ast_debug(1, "%spausing already-%spaused queue member %s:%s\n", (paused ? "" : "un"), (paused ? "" : "un"), q->name, interface);				}				failed = 0;				if (mem->realtime) {					failed = update_realtime_member_field(mem, q->name, "paused", paused ? "1" : "0");				}				if (failed) {					ast_log(LOG_WARNING, "Failed %spausing realtime queue member %s:%s\n", (paused ? "" : "un"), q->name, interface);					ao2_ref(mem, -1);					ao2_unlock(q);					queue_t_unref(q, "Done with iterator");					continue;				}				found++;				mem->paused = paused;				if (queue_persistent_members) {					dump_queue_members(q);				}				if (is_member_available(mem)) {					ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Queue:%s_avail", q->name);				} else if (!num_available_members(q)) {					ast_devstate_changed(AST_DEVICE_INUSE, AST_DEVSTATE_CACHABLE, "Queue:%s_avail", q->name);				}				ast_queue_log(q->name, "NONE", mem->membername, (paused ? "PAUSE" : "UNPAUSE"), "%s", S_OR(reason, ""));				/*** DOCUMENTATION				<managerEventInstance>					<synopsis>Raised when a member is paused/unpaused in the queue with a reason.</synopsis>					<syntax>						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Location'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='MemberName'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Paused'])" />					</syntax>					<see-also>						<ref type="application">PauseQueueMember</ref>						<ref type="application">UnPauseQueueMember</ref>					</see-also>				</managerEventInstance>				***/				if (!ast_strlen_zero(reason)) {					manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n"						"Reason: %s\r\n",							q->name, mem->interface, mem->membername, paused, reason);				} else {					/*** DOCUMENTATION					<managerEventInstance>						<synopsis>Raised when a member is paused/unpaused in the queue without a reason.</synopsis>						<syntax>							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Location'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='MemberName'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Paused'])" />						</syntax>						<see-also>							<ref type="application">PauseQueueMember</ref>							<ref type="application">UnPauseQueueMember</ref>						</see-also>					</managerEventInstance>					***/					manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n",							q->name, mem->interface, mem->membername, paused);				}				ao2_ref(mem, -1);			}
if (mem->paused == paused) {					ast_debug(1, "%spausing already-%spaused queue member %s:%s\n", (paused ? "" : "un"), (paused ? "" : "un"), q->name, interface);				}
mem->paused == paused
mem->paused
mem
mem
paused
paused
paused
{					ast_debug(1, "%spausing already-%spaused queue member %s:%s\n", (paused ? "" : "un"), (paused ? "" : "un"), q->name, interface);				}
ast_debug(1, "%spausing already-%spaused queue member %s:%s\n", (paused ? "" : "un"), (paused ? "" : "un"), q->name, interface);
ast_debug(1, "%spausing already-%spaused queue member %s:%s\n", (paused ? "" : "un"), (paused ? "" : "un"), q->name, interface)
ast_debug
ast_debug
1
"%spausing already-%spaused queue member %s:%s\n"
(paused ? "" : "un")
paused ? "" : "un"
paused
paused
""
"un"
(paused ? "" : "un")
paused ? "" : "un"
paused
paused
""
"un"
q->name
q
q
name
interface
interface
failed = 0;
failed = 0
failed
failed
0
if (mem->realtime) {					failed = update_realtime_member_field(mem, q->name, "paused", paused ? "1" : "0");				}
mem->realtime
mem
mem
realtime
{					failed = update_realtime_member_field(mem, q->name, "paused", paused ? "1" : "0");				}
failed = update_realtime_member_field(mem, q->name, "paused", paused ? "1" : "0");
failed = update_realtime_member_field(mem, q->name, "paused", paused ? "1" : "0")
failed
failed
update_realtime_member_field(mem, q->name, "paused", paused ? "1" : "0")
update_realtime_member_field
update_realtime_member_field
mem
mem
q->name
q
q
name
"paused"
paused ? "1" : "0"
paused
paused
"1"
"0"
if (failed) {					ast_log(LOG_WARNING, "Failed %spausing realtime queue member %s:%s\n", (paused ? "" : "un"), q->name, interface);					ao2_ref(mem, -1);					ao2_unlock(q);					queue_t_unref(q, "Done with iterator");					continue;				}
failed
failed
{					ast_log(LOG_WARNING, "Failed %spausing realtime queue member %s:%s\n", (paused ? "" : "un"), q->name, interface);					ao2_ref(mem, -1);					ao2_unlock(q);					queue_t_unref(q, "Done with iterator");					continue;				}
ast_log(LOG_WARNING, "Failed %spausing realtime queue member %s:%s\n", (paused ? "" : "un"), q->name, interface);
ast_log(LOG_WARNING, "Failed %spausing realtime queue member %s:%s\n", (paused ? "" : "un"), q->name, interface)
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"Failed %spausing realtime queue member %s:%s\n"
(paused ? "" : "un")
paused ? "" : "un"
paused
paused
""
"un"
q->name
q
q
name
interface
interface
ao2_ref(mem, -1);
ao2_ref(mem, -1)
ao2_ref
ao2_ref
mem
mem
-1
1
ao2_unlock(q);
ao2_unlock(q)
ao2_unlock
ao2_unlock
q
q
queue_t_unref(q, "Done with iterator");
queue_t_unref(q, "Done with iterator")
queue_t_unref
queue_t_unref
q
q
"Done with iterator"
continue;
found++;
found++
found
found
mem->paused = paused;
mem->paused = paused
mem->paused
mem
mem
paused
paused
paused
if (queue_persistent_members) {					dump_queue_members(q);				}
queue_persistent_members
queue_persistent_members
{					dump_queue_members(q);				}
dump_queue_members(q);
dump_queue_members(q)
dump_queue_members
dump_queue_members
q
q
if (is_member_available(mem)) {					ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Queue:%s_avail", q->name);				} else if (!num_available_members(q)) {					ast_devstate_changed(AST_DEVICE_INUSE, AST_DEVSTATE_CACHABLE, "Queue:%s_avail", q->name);				}
is_member_available(mem)
is_member_available
is_member_available
mem
mem
{					ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Queue:%s_avail", q->name);				}
ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Queue:%s_avail", q->name);
ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Queue:%s_avail", q->name)
ast_devstate_changed
ast_devstate_changed
AST_DEVICE_NOT_INUSE
AST_DEVICE_NOT_INUSE
AST_DEVSTATE_CACHABLE
AST_DEVSTATE_CACHABLE
"Queue:%s_avail"
q->name
q
q
name
if (!num_available_members(q)) {					ast_devstate_changed(AST_DEVICE_INUSE, AST_DEVSTATE_CACHABLE, "Queue:%s_avail", q->name);				}
!num_available_members(q)
num_available_members(q)
num_available_members
num_available_members
q
q
{					ast_devstate_changed(AST_DEVICE_INUSE, AST_DEVSTATE_CACHABLE, "Queue:%s_avail", q->name);				}
ast_devstate_changed(AST_DEVICE_INUSE, AST_DEVSTATE_CACHABLE, "Queue:%s_avail", q->name);
ast_devstate_changed(AST_DEVICE_INUSE, AST_DEVSTATE_CACHABLE, "Queue:%s_avail", q->name)
ast_devstate_changed
ast_devstate_changed
AST_DEVICE_INUSE
AST_DEVICE_INUSE
AST_DEVSTATE_CACHABLE
AST_DEVSTATE_CACHABLE
"Queue:%s_avail"
q->name
q
q
name
ast_queue_log(q->name, "NONE", mem->membername, (paused ? "PAUSE" : "UNPAUSE"), "%s", S_OR(reason, ""));
ast_queue_log(q->name, "NONE", mem->membername, (paused ? "PAUSE" : "UNPAUSE"), "%s", S_OR(reason, ""))
ast_queue_log
ast_queue_log
q->name
q
q
name
"NONE"
mem->membername
mem
mem
membername
(paused ? "PAUSE" : "UNPAUSE")
paused ? "PAUSE" : "UNPAUSE"
paused
paused
"PAUSE"
"UNPAUSE"
"%s"
S_OR(reason, "")
S_OR
S_OR
reason
reason
""
if (!ast_strlen_zero(reason)) {					manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n"						"Reason: %s\r\n",							q->name, mem->interface, mem->membername, paused, reason);				} else {					/*** DOCUMENTATION					<managerEventInstance>						<synopsis>Raised when a member is paused/unpaused in the queue without a reason.</synopsis>						<syntax>							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Location'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='MemberName'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Paused'])" />						</syntax>						<see-also>							<ref type="application">PauseQueueMember</ref>							<ref type="application">UnPauseQueueMember</ref>						</see-also>					</managerEventInstance>					***/					manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n",							q->name, mem->interface, mem->membername, paused);				}
!ast_strlen_zero(reason)
ast_strlen_zero(reason)
ast_strlen_zero
ast_strlen_zero
reason
reason
{					manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n"						"Reason: %s\r\n",							q->name, mem->interface, mem->membername, paused, reason);				}
manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n"						"Reason: %s\r\n",							q->name, mem->interface, mem->membername, paused, reason);
manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n"						"Reason: %s\r\n",							q->name, mem->interface, mem->membername, paused, reason)
manager_event
manager_event
EVENT_FLAG_AGENT
EVENT_FLAG_AGENT
"QueueMemberPaused"
"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n"						"Reason: %s\r\n"
q->name
q
q
name
mem->interface
mem
mem
interface
mem->membername
mem
mem
membername
paused
paused
reason
reason
{					/*** DOCUMENTATION					<managerEventInstance>						<synopsis>Raised when a member is paused/unpaused in the queue without a reason.</synopsis>						<syntax>							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Location'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='MemberName'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Paused'])" />						</syntax>						<see-also>							<ref type="application">PauseQueueMember</ref>							<ref type="application">UnPauseQueueMember</ref>						</see-also>					</managerEventInstance>					***/					manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n",							q->name, mem->interface, mem->membername, paused);				}
manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n",							q->name, mem->interface, mem->membername, paused);
manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n",							q->name, mem->interface, mem->membername, paused)
manager_event
manager_event
EVENT_FLAG_AGENT
EVENT_FLAG_AGENT
"QueueMemberPaused"
"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n"
q->name
q
q
name
mem->interface
mem
mem
interface
mem->membername
mem
mem
membername
paused
paused
ao2_ref(mem, -1);
ao2_ref(mem, -1)
ao2_ref
ao2_ref
mem
mem
-1
1
if (!ast_strlen_zero(queuename) && !strcasecmp(queuename, q->name)) {			ao2_unlock(q);			queue_t_unref(q, "Done with iterator");			break;		}
!ast_strlen_zero(queuename) && !strcasecmp(queuename, q->name)
!ast_strlen_zero(queuename)
ast_strlen_zero(queuename)
ast_strlen_zero
ast_strlen_zero
queuename
queuename
!strcasecmp(queuename, q->name)
strcasecmp(queuename, q->name)
strcasecmp
strcasecmp
queuename
queuename
q->name
q
q
name
{			ao2_unlock(q);			queue_t_unref(q, "Done with iterator");			break;		}
ao2_unlock(q);
ao2_unlock(q)
ao2_unlock
ao2_unlock
q
q
queue_t_unref(q, "Done with iterator");
queue_t_unref(q, "Done with iterator")
queue_t_unref
queue_t_unref
q
q
"Done with iterator"
break;
ao2_unlock(q);
ao2_unlock(q)
ao2_unlock
ao2_unlock
q
q
queue_t_unref(q, "Done with iterator");
queue_t_unref(q, "Done with iterator")
queue_t_unref
queue_t_unref
q
q
"Done with iterator"
ao2_iterator_destroy(&queue_iter);
ao2_iterator_destroy(&queue_iter)
ao2_iterator_destroy
ao2_iterator_destroy
&queue_iter
queue_iter
queue_iter
return found ? RESULT_SUCCESS : RESULT_FAILURE;
found ? RESULT_SUCCESS : RESULT_FAILURE
found
found
RESULT_SUCCESS
RESULT_SUCCESS
RESULT_FAILURE
RESULT_FAILURE
-----joern-----
(187,183,0)
(112,154,0)
(99,149,0)
(165,18,0)
(85,102,0)
(151,222,0)
(118,92,0)
(105,183,0)
(139,241,0)
(126,148,0)
(129,61,0)
(230,95,0)
(172,183,0)
(211,212,0)
(108,171,0)
(51,171,0)
(154,212,0)
(183,68,0)
(118,61,0)
(69,142,0)
(124,5,0)
(202,227,0)
(216,171,0)
(98,209,0)
(75,220,0)
(49,104,0)
(46,26,0)
(47,149,0)
(195,44,0)
(170,191,0)
(220,44,0)
(95,44,0)
(156,217,0)
(146,191,0)
(4,197,0)
(1,145,0)
(57,36,0)
(16,196,0)
(194,130,0)
(224,142,0)
(3,146,0)
(175,123,0)
(32,134,0)
(17,104,0)
(197,142,0)
(222,151,0)
(182,142,0)
(14,191,0)
(82,191,0)
(231,130,0)
(109,241,0)
(163,194,0)
(211,133,0)
(154,112,0)
(130,44,0)
(113,195,0)
(40,59,0)
(181,142,0)
(110,194,0)
(204,15,0)
(144,14,0)
(64,126,0)
(106,91,0)
(222,15,0)
(85,7,0)
(161,118,0)
(53,142,0)
(239,18,0)
(208,82,0)
(160,15,0)
(117,104,0)
(6,162,0)
(156,94,0)
(11,85,0)
(97,181,0)
(165,122,0)
(104,66,0)
(212,211,0)
(118,220,0)
(177,94,0)
(237,165,0)
(189,124,0)
(104,13,0)
(48,195,0)
(60,195,0)
(46,10,0)
(170,178,0)
(77,61,0)
(222,164,0)
(104,178,0)
(74,87,0)
(58,117,0)
(5,124,0)
(67,162,0)
(165,237,0)
(158,146,0)
(198,56,0)
(63,15,0)
(43,123,0)
(164,142,0)
(95,145,0)
(95,146,0)
(31,44,0)
(227,191,0)
(116,242,0)
(199,117,0)
(214,33,0)
(142,170,0)
(205,130,0)
(84,85,0)
(31,15,0)
(95,197,0)
(153,145,0)
(176,221,0)
(234,215,0)
(138,224,0)
(137,239,0)
(183,44,0)
(120,67,0)
(136,164,0)
(2,126,0)
(152,242,0)
(181,33,0)
(94,191,0)
(215,142,0)
(232,118,0)
(169,102,0)
(126,191,0)
(28,27,0)
(26,191,0)
(183,182,0)
(167,111,0)
(45,220,0)
(66,104,0)
(164,222,0)
(119,92,0)
(91,15,0)
(81,133,0)
(24,130,0)
(223,82,0)
(239,112,0)
(201,241,0)
(128,218,0)
(83,56,0)
(5,185,0)
(27,162,0)
(59,191,0)
(100,237,0)
(181,31,0)
(204,142,0)
(150,215,0)
(235,15,0)
(122,225,0)
(119,87,0)
(25,191,0)
(124,195,0)
(61,191,0)
(29,169,0)
(115,7,0)
(14,92,0)
(36,191,0)
(228,5,0)
(171,44,0)
(34,217,0)
(242,241,0)
(93,117,0)
(200,56,0)
(195,124,0)
(180,148,0)
(157,15,0)
(242,191,0)
(82,222,0)
(183,123,0)
(211,18,0)
(143,183,0)
(127,31,0)
(218,18,0)
(0,194,0)
(194,178,0)
(233,124,0)
(146,95,0)
(37,85,0)
(207,222,0)
(173,181,0)
(212,154,0)
(79,102,0)
(25,162,0)
(133,211,0)
(78,221,0)
(124,142,0)
(179,95,0)
(243,15,0)
(222,82,0)
(117,44,0)
(169,15,0)
(23,66,0)
(30,56,0)
(26,46,0)
(132,49,0)
(204,209,0)
(171,222,0)
(8,170,0)
(217,134,0)
(55,183,0)
(170,142,0)
(112,239,0)
(66,44,0)
(182,183,0)
(9,46,0)
(90,91,0)
(135,25,0)
(217,56,0)
(193,133,0)
(140,102,0)
(215,183,0)
(225,218,0)
(35,220,0)
(123,183,0)
(221,124,0)
(203,46,0)
(130,194,0)
(209,204,0)
(119,142,0)
(236,188,0)
(218,225,0)
(104,117,0)
(151,219,0)
(196,217,0)
(101,27,0)
(30,196,0)
(149,47,0)
(221,191,0)
(227,92,0)
(121,26,0)
(54,194,0)
(145,95,0)
(222,171,0)
(94,156,0)
(118,178,0)
(238,118,0)
(19,227,0)
(71,165,0)
(192,164,0)
(41,56,0)
(183,215,0)
(124,221,0)
(166,69,0)
(133,191,0)
(220,118,0)
(168,222,0)
(89,156,0)
(59,70,0)
(104,49,0)
(206,151,0)
(131,46,0)
(22,86,0)
(21,104,0)
(155,56,0)
(147,95,0)
(67,191,0)
(134,217,0)
(86,191,0)
(123,191,0)
(42,162,0)
(183,219,0)
(50,197,0)
(33,181,0)
(52,237,0)
(237,191,0)
(36,148,0)
(190,204,0)
(62,151,0)
(7,56,0)
(95,174,0)
(38,104,0)
(39,66,0)
(20,56,0)
(72,95,0)
(213,211,0)
(114,182,0)
(33,44,0)
(186,182,0)
(7,224,0)
(197,95,0)
(210,170,0)
(80,86,0)
(122,165,0)
(87,119,0)
(141,92,0)
(159,245,0)
(73,119,0)
(107,66,0)
(65,49,0)
(224,31,0)
(27,191,0)
(103,224,0)
(102,56,0)
(88,134,0)
(245,142,0)
(12,26,0)
(241,242,0)
(196,30,0)
(226,56,0)
(96,191,0)
(61,118,0)
(49,191,0)
(191,94,0)
(229,245,0)
(244,15,0)
(145,142,0)
(240,194,0)
(86,80,0)
(225,122,0)
(149,219,0)
(241,125,0)
(188,18,0)
(50,4,1)
(183,44,1)
(38,17,1)
(179,230,1)
(238,76,1)
(218,18,1)
(171,44,1)
(212,211,1)
(181,173,1)
(171,216,1)
(201,109,1)
(33,181,1)
(149,219,1)
(170,178,1)
(81,193,1)
(202,19,1)
(206,62,1)
(2,36,1)
(88,32,1)
(96,141,1)
(27,191,1)
(3,179,1)
(227,191,1)
(51,108,1)
(85,37,1)
(163,240,1)
(101,28,1)
(164,142,1)
(69,166,1)
(28,25,1)
(95,72,1)
(245,142,1)
(1,146,1)
(197,50,1)
(22,69,1)
(205,24,1)
(145,142,1)
(123,191,1)
(126,64,1)
(53,225,1)
(71,237,1)
(217,134,1)
(211,133,1)
(43,175,1)
(194,0,1)
(225,218,1)
(52,218,1)
(87,74,1)
(75,35,1)
(98,190,1)
(9,80,1)
(104,66,1)
(102,79,1)
(133,81,1)
(26,191,1)
(27,101,1)
(216,108,1)
(182,142,1)
(82,191,1)
(19,14,1)
(147,47,1)
(187,172,1)
(146,158,1)
(154,112,1)
(222,151,1)
(195,60,1)
(95,44,1)
(146,191,1)
(59,191,1)
(186,123,1)
(84,11,1)
(106,104,1)
(183,215,1)
(96,217,1)
(165,71,1)
(26,12,1)
(220,45,1)
(74,73,1)
(195,44,1)
(95,146,1)
(49,191,1)
(104,21,1)
(127,224,1)
(106,33,1)
(8,53,1)
(233,228,1)
(7,85,1)
(33,214,1)
(40,184,1)
(175,55,1)
(159,91,1)
(158,3,1)
(73,118,1)
(190,183,1)
(4,145,1)
(191,94,1)
(58,199,1)
(0,110,1)
(151,219,1)
(62,168,1)
(124,221,1)
(119,87,1)
(76,245,1)
(107,23,1)
(188,18,1)
(204,209,1)
(120,191,1)
(119,142,1)
(121,131,1)
(136,207,1)
(199,66,1)
(100,52,1)
(130,231,1)
(60,113,1)
(220,75,1)
(66,107,1)
(192,136,1)
(172,47,1)
(197,142,1)
(117,44,1)
(183,123,1)
(5,124,1)
(76,5,1)
(170,210,1)
(128,67,1)
(194,178,1)
(104,117,1)
(213,112,1)
(11,30,1)
(180,126,1)
(196,16,1)
(232,238,1)
(209,98,1)
(166,59,1)
(138,169,1)
(215,150,1)
(124,142,1)
(69,142,1)
(16,180,1)
(168,171,1)
(223,208,1)
(95,145,1)
(14,144,1)
(194,130,1)
(48,113,1)
(203,9,1)
(29,76,1)
(93,199,1)
(228,245,1)
(126,191,1)
(169,29,1)
(112,239,1)
(139,69,1)
(86,22,1)
(123,43,1)
(86,191,1)
(129,77,1)
(31,127,1)
(165,18,1)
(153,1,1)
(14,191,1)
(222,164,1)
(208,241,1)
(85,84,1)
(30,196,1)
(12,121,1)
(64,2,1)
(130,44,1)
(210,8,1)
(236,102,1)
(37,11,1)
(177,156,1)
(242,116,1)
(109,139,1)
(90,106,1)
(104,49,1)
(103,138,1)
(165,237,1)
(34,194,1)
(104,178,1)
(47,149,1)
(222,82,1)
(218,128,1)
(224,103,1)
(96,27,1)
(234,182,1)
(89,96,1)
(183,105,1)
(131,203,1)
(67,120,1)
(181,142,1)
(171,51,1)
(222,171,1)
(117,58,1)
(220,44,1)
(36,57,1)
(156,217,1)
(164,192,1)
(195,48,1)
(67,191,1)
(114,186,1)
(188,236,1)
(221,191,1)
(173,97,1)
(115,7,1)
(237,191,1)
(207,82,1)
(110,130,1)
(241,242,1)
(240,54,1)
(161,61,1)
(135,154,1)
(61,191,1)
(211,18,1)
(134,88,1)
(132,65,1)
(36,191,1)
(221,78,1)
(182,114,1)
(97,142,1)
(61,129,1)
(91,90,1)
(225,122,1)
(122,165,1)
(137,204,1)
(80,86,1)
(130,205,1)
(117,93,1)
(82,223,1)
(190,95,1)
(242,191,1)
(108,164,1)
(113,189,1)
(133,191,1)
(208,46,1)
(35,232,1)
(189,221,1)
(94,156,1)
(57,154,1)
(78,176,1)
(124,195,1)
(54,188,1)
(149,99,1)
(227,202,1)
(152,201,1)
(46,26,1)
(215,142,1)
(21,49,1)
(224,142,1)
(66,44,1)
(99,222,1)
(208,80,1)
(181,31,1)
(231,24,1)
(118,161,1)
(156,89,1)
(116,152,1)
(145,153,1)
(17,33,1)
(55,187,1)
(176,233,1)
(25,135,1)
(66,39,1)
(170,191,1)
(237,100,1)
(31,44,1)
(154,212,1)
(137,142,1)
(239,18,1)
(24,163,1)
(32,34,1)
(204,142,1)
(34,188,1)
(65,117,1)
(25,191,1)
(7,224,1)
(144,119,1)
(214,181,1)
(95,197,1)
(183,182,1)
(150,234,1)
(16,191,1)
(85,102,1)
(230,147,1)
(245,229,1)
(105,143,1)
(151,206,1)
(193,213,1)
(142,170,1)
(77,220,1)
(229,159,1)
(33,44,1)
(23,38,1)
(39,23,1)
(72,197,1)
(184,31,1)
(143,215,1)
(196,217,1)
(137,225,1)
(141,227,1)
(183,219,1)
(166,184,1)
(118,61,1)
(169,102,1)
(94,177,1)
(118,220,1)
(59,40,1)
(49,132,1)
(118,178,1)
(79,140,1)
(45,35,1)
(239,137,1)
(100,218,2)
(215,142,2)
(112,142,2)
(206,76,2)
(126,191,2)
(57,154,2)
(80,69,2)
(35,76,2)
(121,80,2)
(69,76,2)
(209,76,2)
(181,142,2)
(22,69,2)
(184,76,2)
(4,47,2)
(30,196,2)
(191,94,2)
(192,76,2)
(218,18,2)
(119,76,2)
(242,191,2)
(210,225,2)
(113,245,2)
(80,86,2)
(239,142,2)
(112,76,2)
(177,76,2)
(104,66,2)
(14,191,2)
(126,154,2)
(33,142,2)
(225,218,2)
(118,76,2)
(74,76,2)
(211,133,2)
(228,245,2)
(123,47,2)
(137,76,2)
(64,154,2)
(183,47,2)
(94,156,2)
(73,76,2)
(225,122,2)
(169,102,2)
(133,191,2)
(135,154,2)
(137,225,2)
(204,76,2)
(40,184,2)
(201,69,2)
(49,33,2)
(183,123,2)
(142,170,2)
(61,76,2)
(82,76,2)
(207,76,2)
(170,191,2)
(112,225,2)
(38,33,2)
(105,47,2)
(171,76,2)
(27,154,2)
(146,47,2)
(7,224,2)
(52,218,2)
(118,220,2)
(223,76,2)
(227,76,2)
(114,47,2)
(183,44,2)
(234,47,2)
(164,76,2)
(245,142,2)
(112,239,2)
(240,188,2)
(156,154,2)
(211,112,2)
(86,69,2)
(82,191,2)
(61,191,2)
(149,76,2)
(208,76,2)
(25,154,2)
(117,44,2)
(2,154,2)
(145,142,2)
(17,33,2)
(180,154,2)
(69,142,2)
(33,44,2)
(89,154,2)
(146,191,2)
(43,47,2)
(101,154,2)
(104,178,2)
(95,44,2)
(151,219,2)
(1,47,2)
(139,69,2)
(96,76,2)
(122,218,2)
(227,191,2)
(122,165,2)
(67,191,2)
(58,199,2)
(171,44,2)
(183,219,2)
(190,76,2)
(9,80,2)
(197,142,2)
(23,33,2)
(237,191,2)
(81,112,2)
(220,44,2)
(60,113,2)
(106,142,2)
(12,80,2)
(104,117,2)
(103,76,2)
(183,215,2)
(120,191,2)
(156,76,2)
(130,44,2)
(33,181,2)
(36,191,2)
(86,191,2)
(232,76,2)
(164,142,2)
(196,217,2)
(36,154,2)
(222,171,2)
(159,142,2)
(45,35,2)
(154,76,2)
(194,188,2)
(154,142,2)
(117,33,2)
(156,217,2)
(95,146,2)
(118,178,2)
(14,76,2)
(47,76,2)
(3,47,2)
(90,142,2)
(130,188,2)
(194,178,2)
(231,24,2)
(212,211,2)
(204,209,2)
(78,245,2)
(203,80,2)
(222,151,2)
(215,47,2)
(26,191,2)
(5,245,2)
(224,76,2)
(222,164,2)
(124,142,2)
(173,142,2)
(96,154,2)
(95,47,2)
(222,76,2)
(216,108,2)
(8,225,2)
(31,76,2)
(145,47,2)
(97,142,2)
(65,33,2)
(128,191,2)
(27,191,2)
(177,154,2)
(239,225,2)
(25,191,2)
(21,33,2)
(72,47,2)
(165,218,2)
(5,124,2)
(129,76,2)
(87,76,2)
(193,112,2)
(95,197,2)
(154,225,2)
(124,195,2)
(165,18,2)
(176,245,2)
(218,191,2)
(138,76,2)
(39,23,2)
(132,33,2)
(91,142,2)
(179,47,2)
(89,76,2)
(221,245,2)
(161,76,2)
(54,188,2)
(49,191,2)
(153,47,2)
(115,7,2)
(212,112,2)
(186,47,2)
(59,184,2)
(48,113,2)
(195,245,2)
(133,112,2)
(213,112,2)
(154,212,2)
(165,237,2)
(136,76,2)
(191,154,2)
(51,108,2)
(53,225,2)
(77,76,2)
(241,69,2)
(109,69,2)
(124,221,2)
(119,142,2)
(76,142,2)
(94,76,2)
(137,142,2)
(107,23,2)
(141,76,2)
(154,112,2)
(230,47,2)
(31,44,2)
(189,245,2)
(181,31,2)
(24,188,2)
(147,47,2)
(28,154,2)
(221,191,2)
(158,47,2)
(0,188,2)
(71,218,2)
(169,76,2)
(104,33,2)
(104,49,2)
(47,149,2)
(237,218,2)
(205,24,2)
(143,47,2)
(170,178,2)
(66,44,2)
(110,188,2)
(217,134,2)
(75,35,2)
(182,142,2)
(50,47,2)
(241,242,2)
(214,142,2)
(19,76,2)
(172,47,2)
(188,18,2)
(220,76,2)
(85,102,2)
(152,69,2)
(163,188,2)
(94,154,2)
(29,76,2)
(99,76,2)
(98,76,2)
(142,225,2)
(131,80,2)
(149,219,2)
(66,33,2)
(119,87,2)
(182,47,2)
(151,76,2)
(191,76,2)
(211,18,2)
(238,76,2)
(59,191,2)
(222,82,2)
(183,182,2)
(124,245,2)
(187,47,2)
(168,76,2)
(84,11,2)
(118,61,2)
(166,76,2)
(95,145,2)
(123,191,2)
(37,11,2)
(197,47,2)
(55,47,2)
(46,80,2)
(242,69,2)
(204,142,2)
(127,76,2)
(195,44,2)
(229,142,2)
(239,18,2)
(170,225,2)
(175,47,2)
(194,130,2)
(199,33,2)
(202,76,2)
(150,47,2)
(116,69,2)
(233,245,2)
(93,199,2)
(224,142,2)
(108,76,2)
(144,76,2)
(62,76,2)
(239,76,2)
(46,26,2)
(225,191,2)
(26,80,2)
-----------------------------------
(0,"")
(1,mem)
(2,q)
(3,q)
(4,mem)
(5,failed = update_realtime_member_field(mem, q->name, "paused", paused ? "1" : "0")
(6,if (ast_strlen_zero(queuename)
(7,return found ? RESULT_SUCCESS : RESULT_FAILURE;)
(8,q)
(9,AST_DEVICE_INUSE)
(10,)
(11,found)
(12,name)
(13,)
(14,ao2_unlock(q)
(15,)
(16,queue_iter)
(17,1)
(18,const char *queuename)
(19,q)
(20,queue_iter)
(21,interface)
(22,q)
(23,paused)
(24,paused)
(25,ao2_unlock(q)
(26,q->name)
(27,queue_t_unref(q, "Done with iterator")
(28,q)
(29,found)
(30,ao2_iterator_destroy(&queue_iter)
(31,mem->paused = paused)
(32,queues)
(33,mem->paused == paused)
(34,queue_iter)
(35,paused)
(36,ao2_unlock(q)
(37,RESULT_SUCCESS)
(38,"%spausing already-%spaused queue member %s:%s\\n")
(39,"un")
(40,q)
(41,while ((q = ao2_t_iterator_next(&queue_iter, "Iterate over queues")
(42,if (!ast_strlen_zero(queuename)
(43,name)
(44,int paused)
(45,"un")
(46,ast_devstate_changed(AST_DEVICE_INUSE, AST_DEVSTATE_CACHABLE, "Queue:%s_avail", q->name)
(47,!ast_strlen_zero(reason)
(48,"1")
(49,q->name)
(50,membername)
(51,"UNPAUSE")
(52,q)
(53,mem)
(54,"NONE")
(55,"Queue: %s\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t"Location: %s\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t"MemberName: %s\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t"Paused: %d\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t"Reason: %s\\r\\n")
(56,)
(57,q)
(58,"un")
(59,dump_queue_members(q)
(60,"0")
(61,q->name)
(62,reason)
(63,if (failed)
(64,"Done with iterator")
(65,q)
(66,paused ? "" : "un")
(67,ao2_lock(q)
(68,)
(69,is_member_available(mem)
(70,)
(71,queuename)
(72,paused)
(73,mem)
(74,1)
(75,"")
(76,failed)
(77,q)
(78,name)
(79,0)
(80,!num_available_members(q)
(81,name)
(82,q->name)
(83,if (ast_strlen_zero(queuename)
(84,RESULT_FAILURE)
(85,found ? RESULT_SUCCESS : RESULT_FAILURE)
(86,num_available_members(q)
(87,-1)
(88,0)
(89,queue_iter)
(90,0)
(91,failed = 0)
(92,)
(93,"")
(94,ao2_t_iterator_next(&queue_iter, "Iterate over queues")
(95,manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",\n\\n\\t\\t\\t\\t\\t\\t"Queue: %s\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t"Location: %s\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t"MemberName: %s\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t"Paused: %d\\r\\n",\n\\n\\t\\t\\t\\t\\t\\t\\tq->name, mem->interface, mem->membername, paused)
(96,q)
(97,mem)
(98,1)
(99,reason)
(100,name)
(101,"Done with iterator")
(102,found = 0)
(103,paused)
(104,ast_debug(1, "%spausing already-%spaused queue member %s:%s\\n", (paused ? "" : "un")
(105,reason)
(106,failed)
(107,"")
(108,paused)
(109,AST_DEVSTATE_CACHABLE)
(110,"%s")
(111,)
(112,!ast_strlen_zero(queuename)
(113,paused)
(114,interface)
(115,RET)
(116,name)
(117,paused ? "" : "un")
(118,ast_log(LOG_WARNING, "Failed %spausing realtime queue member %s:%s\\n", (paused ? "" : "un")
(119,ao2_ref(mem, -1)
(120,q)
(121,q)
(122,!strcasecmp(q->name, queuename)
(123,q->name)
(124,update_realtime_member_field(mem, q->name, "paused", paused ? "1" : "0")
(125,)
(126,queue_t_unref(q, "Done with iterator")
(127,paused)
(128,queuename)
(129,name)
(130,paused ? "PAUSEALL" : "UNPAUSEALL")
(131,"Queue:%s_avail")
(132,name)
(133,q->name)
(134,ao2_iterator_init(queues, 0)
(135,q)
(136,mem)
(137,queuename)
(138,mem)
(139,AST_DEVICE_NOT_INUSE)
(140,found)
(141,continue;)
(142,mem = interface_exists(q, interface)
(143,paused)
(144,q)
(145,mem->interface)
(146,q->name)
(147,EVENT_FLAG_AGENT)
(148,)
(149,ast_strlen_zero(reason)
(150,membername)
(151,S_OR(reason, "")
(152,q)
(153,interface)
(154,!ast_strlen_zero(queuename)
(155,failed)
(156,&queue_iter)
(157,if (mem->realtime)
(158,name)
(159,mem)
(160,if (is_member_available(mem)
(161,interface)
(162,)
(163,interface)
(164,mem->membername)
(165,strcasecmp(q->name, queuename)
(166,mem)
(167,if ((mem = interface_exists(q, interface)
(168,"%s")
(169,found++)
(170,interface_exists(q, interface)
(171,paused ? "PAUSE" : "UNPAUSE")
(172,EVENT_FLAG_AGENT)
(173,paused)
(174,)
(175,q)
(176,q)
(177,"Iterate over queues")
(178,const char *interface)
(179,"Queue: %s\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t"Location: %s\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t"MemberName: %s\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t"Paused: %d\\r\\n")
(180,break;)
(181,mem->paused)
(182,mem->interface)
(183,manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",\n\\n\\t\\t\\t\\t\\t\\t"Queue: %s\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t"Location: %s\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t"MemberName: %s\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t"Paused: %d\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t"Reason: %s\\r\\n",\n\\n\\t\\t\\t\\t\\t\\t\\tq->name, mem->interface, mem->membername, paused, reason)
(184,queue_persistent_members)
(185,)
(186,mem)
(187,"QueueMemberPaused")
(188,ast_strlen_zero(queuename)
(189,"paused")
(190,mem)
(191,q = ao2_t_iterator_next(&queue_iter, "Iterate over queues")
(192,membername)
(193,q)
(194,ast_queue_log("NONE", "NONE", interface, (paused ? "PAUSEALL" : "UNPAUSEALL")
(195,paused ? "1" : "0")
(196,&queue_iter)
(197,mem->membername)
(198,q)
(199,paused)
(200,found)
(201,"Queue:%s_avail")
(202,"Done with iterator")
(203,AST_DEVSTATE_CACHABLE)
(204,ao2_ref(mem, -1)
(205,"PAUSEALL")
(206,"")
(207,"NONE")
(208,q)
(209,-1)
(210,interface)
(211,strcasecmp(queuename, q->name)
(212,!strcasecmp(queuename, q->name)
(213,queuename)
(214,paused)
(215,mem->membername)
(216,"PAUSE")
(217,queue_iter = ao2_iterator_init(queues, 0)
(218,ast_strlen_zero(queuename)
(219,const char *reason)
(220,paused ? "" : "un")
(221,q->name)
(222,ast_queue_log(q->name, "NONE", mem->membername, (paused ? "PAUSE" : "UNPAUSE")
(223,name)
(224,mem->paused)
(225,ast_strlen_zero(queuename)
(226,mem)
(227,queue_t_unref(q, "Done with iterator")
(228,failed)
(229,realtime)
(230,"QueueMemberPaused")
(231,"UNPAUSEALL")
(232,"Failed %spausing realtime queue member %s:%s\\n")
(233,mem)
(234,mem)
(235,if (queue_persistent_members)
(236,queuename)
(237,q->name)
(238,LOG_WARNING)
(239,ast_strlen_zero(queuename)
(240,"NONE")
(241,ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Queue:%s_avail", q->name)
(242,q->name)
(243,if (mem->paused == paused)
(244,if (!ast_strlen_zero(reason)
(245,mem->realtime)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^