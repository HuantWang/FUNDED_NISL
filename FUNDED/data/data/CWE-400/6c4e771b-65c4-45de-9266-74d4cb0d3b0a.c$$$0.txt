-----label-----
1
-----code-----
static int
riemann_send(struct riemann_host *host, Msg const *msg)
{
	int status = 0;
	pthread_mutex_lock (&host->lock);

	status = riemann_send_msg(host, msg);

	if (status != 0) {
		riemann_disconnect (host);
		pthread_mutex_unlock (&host->lock);
		return status;
	}

	/*
	 * For TCP we need to receive message acknowledgemenent.
	 */
	if (host->use_tcp)
	{
		status = riemann_recv_ack(host);

		if (status != 0)
		{
			riemann_disconnect (host);
			pthread_mutex_unlock (&host->lock);
			return status;
		}
	}

	pthread_mutex_unlock (&host->lock);
	return 0;
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
5,6
5,7
6,7
8,9
8,10
11,12
11,13
12,13
14,15
14,16
17,18
17,19
17,20
17,21
17,22
17,23
17,24
18,19
19,20
19,21
21,22
21,23
23,24
25,26
26,27
26,28
27,28
29,30
30,31
30,32
31,32
34,35
35,36
35,37
36,37
38,39
38,40
38,41
39,40
41,42
43,44
45,46
45,47
46,47
46,48
47,48
50,51
50,52
50,53
51,52
52,53
52,54
53,54
55,56
57,58
58,59
58,60
59,60
61,62
62,63
62,64
63,64
66,67
67,68
69,70
69,71
70,71
70,72
71,72
74,75
74,76
75,76
76,77
76,78
77,78
79,80
79,81
80,81
82,83
84,85
84,86
85,86
85,87
86,87
89,90
89,91
89,92
90,91
91,92
91,93
92,93
94,95
96,97
97,98
97,99
98,99
100,101
101,102
101,103
102,103
105,106
106,107
108,109
109,110
109,111
110,111
112,113
113,114
113,115
114,115
117,118
-----nextToken-----
2,4,7,9,10,13,15,16,20,22,24,28,32,33,37,40,42,44,48,49,54,56,60,64,65,68,72,73,78,81,83,87,88,93,95,99,103,104,107,111,115,116,118
-----computeFrom-----
35,36
35,37
46,47
46,48
76,77
76,78
85,86
85,87
-----guardedBy-----
48,68
87,107
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ReturnStatement;IdExpression;Name;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ReturnStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ReturnStatement;LiteralExpression;
-----ast_node-----
static intriemann_send(struct riemann_host *host, Msg const *msg){	int status = 0;	pthread_mutex_lock (&host->lock);	status = riemann_send_msg(host, msg);	if (status != 0) {		riemann_disconnect (host);		pthread_mutex_unlock (&host->lock);		return status;	}	/*	 * For TCP we need to receive message acknowledgemenent.	 */	if (host->use_tcp)	{		status = riemann_recv_ack(host);		if (status != 0)		{			riemann_disconnect (host);			pthread_mutex_unlock (&host->lock);			return status;		}	}	pthread_mutex_unlock (&host->lock);	return 0;}
static int
riemann_send(struct riemann_host *host, Msg const *msg)
riemann_send
struct riemann_host *host
struct riemann_host
riemann_host
*host
*
host
Msg const *msg
Msg const
Msg
*msg
*
msg
{	int status = 0;	pthread_mutex_lock (&host->lock);	status = riemann_send_msg(host, msg);	if (status != 0) {		riemann_disconnect (host);		pthread_mutex_unlock (&host->lock);		return status;	}	/*	 * For TCP we need to receive message acknowledgemenent.	 */	if (host->use_tcp)	{		status = riemann_recv_ack(host);		if (status != 0)		{			riemann_disconnect (host);			pthread_mutex_unlock (&host->lock);			return status;		}	}	pthread_mutex_unlock (&host->lock);	return 0;}
int status = 0;
int status = 0;
int
status = 0
status
= 0
0
pthread_mutex_lock (&host->lock);
pthread_mutex_lock (&host->lock)
pthread_mutex_lock
pthread_mutex_lock
&host->lock
host->lock
host
host
lock
status = riemann_send_msg(host, msg);
status = riemann_send_msg(host, msg)
status
status
riemann_send_msg(host, msg)
riemann_send_msg
riemann_send_msg
host
host
msg
msg
if (status != 0) {		riemann_disconnect (host);		pthread_mutex_unlock (&host->lock);		return status;	}
status != 0
status
status
0
{		riemann_disconnect (host);		pthread_mutex_unlock (&host->lock);		return status;	}
riemann_disconnect (host);
riemann_disconnect (host)
riemann_disconnect
riemann_disconnect
host
host
pthread_mutex_unlock (&host->lock);
pthread_mutex_unlock (&host->lock)
pthread_mutex_unlock
pthread_mutex_unlock
&host->lock
host->lock
host
host
lock
return status;
status
status
if (host->use_tcp)	{		status = riemann_recv_ack(host);		if (status != 0)		{			riemann_disconnect (host);			pthread_mutex_unlock (&host->lock);			return status;		}	}
host->use_tcp
host
host
use_tcp
{		status = riemann_recv_ack(host);		if (status != 0)		{			riemann_disconnect (host);			pthread_mutex_unlock (&host->lock);			return status;		}	}
status = riemann_recv_ack(host);
status = riemann_recv_ack(host)
status
status
riemann_recv_ack(host)
riemann_recv_ack
riemann_recv_ack
host
host
if (status != 0)		{			riemann_disconnect (host);			pthread_mutex_unlock (&host->lock);			return status;		}
status != 0
status
status
0
{			riemann_disconnect (host);			pthread_mutex_unlock (&host->lock);			return status;		}
riemann_disconnect (host);
riemann_disconnect (host)
riemann_disconnect
riemann_disconnect
host
host
pthread_mutex_unlock (&host->lock);
pthread_mutex_unlock (&host->lock)
pthread_mutex_unlock
pthread_mutex_unlock
&host->lock
host->lock
host
host
lock
return status;
status
status
pthread_mutex_unlock (&host->lock);
pthread_mutex_unlock (&host->lock)
pthread_mutex_unlock
pthread_mutex_unlock
&host->lock
host->lock
host
host
lock
return 0;
0
-----joern-----
(0,13,0)
(30,0,0)
(38,60,0)
(9,52,0)
(34,13,0)
(54,26,0)
(10,59,0)
(20,5,0)
(31,55,0)
(1,6,0)
(57,14,0)
(42,26,0)
(16,2,0)
(21,29,0)
(10,9,0)
(13,59,0)
(15,25,0)
(2,51,0)
(48,28,0)
(24,28,0)
(47,25,0)
(46,3,0)
(55,28,0)
(13,0,0)
(14,57,0)
(18,13,0)
(27,6,0)
(12,59,0)
(19,26,0)
(36,28,0)
(14,59,0)
(55,46,0)
(15,5,0)
(61,34,0)
(53,12,0)
(6,59,0)
(46,55,0)
(35,52,0)
(26,28,0)
(36,57,0)
(33,34,0)
(0,44,0)
(8,15,0)
(29,28,0)
(3,51,0)
(7,24,0)
(32,5,0)
(40,29,0)
(5,39,0)
(37,55,0)
(60,51,0)
(3,46,0)
(5,24,0)
(0,28,0)
(45,36,0)
(47,42,0)
(43,39,0)
(9,10,0)
(53,60,0)
(50,12,0)
(17,59,0)
(11,36,0)
(58,59,0)
(52,28,0)
(53,15,0)
(42,47,0)
(41,0,0)
(49,48,0)
(26,42,0)
(56,20,0)
(24,5,0)
(57,36,0)
(52,9,0)
(22,52,0)
(2,28,0)
(60,13,0)
(48,25,0)
(4,59,0)
(23,20,0)
(56,23,1)
(0,30,1)
(11,29,1)
(22,6,1)
(5,24,1)
(45,11,1)
(6,1,1)
(0,28,1)
(36,28,1)
(21,34,1)
(15,8,1)
(53,15,1)
(34,61,1)
(29,28,1)
(50,14,1)
(48,28,1)
(54,19,1)
(61,33,1)
(12,50,1)
(53,12,1)
(57,36,1)
(26,54,1)
(41,18,1)
(36,45,1)
(47,42,1)
(24,7,1)
(3,46,1)
(7,32,1)
(19,48,1)
(60,38,1)
(2,16,1)
(26,28,1)
(11,20,1)
(16,34,1)
(55,28,1)
(2,28,1)
(46,55,1)
(31,2,1)
(38,3,1)
(60,13,1)
(20,5,1)
(52,35,1)
(35,22,1)
(14,57,1)
(53,60,1)
(34,13,1)
(49,20,1)
(10,9,1)
(8,47,1)
(15,5,1)
(55,37,1)
(29,40,1)
(24,28,1)
(32,29,1)
(30,41,1)
(37,31,1)
(13,0,1)
(1,27,1)
(52,28,1)
(0,44,1)
(9,52,1)
(42,26,1)
(20,56,1)
(23,5,1)
(40,21,1)
(18,10,1)
(48,49,1)
(33,13,1)
(7,29,2)
(57,36,2)
(26,28,2)
(3,34,2)
(24,28,2)
(36,29,2)
(55,34,2)
(12,29,2)
(47,42,2)
(14,20,2)
(55,28,2)
(5,24,2)
(16,34,2)
(21,34,2)
(14,57,2)
(20,29,2)
(38,34,2)
(36,20,2)
(9,52,2)
(45,29,2)
(14,29,2)
(47,20,2)
(60,34,2)
(20,5,2)
(49,20,2)
(40,34,2)
(0,28,2)
(48,20,2)
(11,29,2)
(34,13,2)
(23,29,2)
(2,28,2)
(60,13,2)
(57,29,2)
(48,28,2)
(42,20,2)
(10,9,2)
(37,34,2)
(13,0,2)
(50,29,2)
(36,28,2)
(50,20,2)
(32,29,2)
(53,12,2)
(12,20,2)
(8,20,2)
(57,20,2)
(29,34,2)
(46,34,2)
(46,55,2)
(29,28,2)
(26,20,2)
(56,29,2)
(52,28,2)
(5,29,2)
(53,15,2)
(15,5,2)
(24,29,2)
(11,20,2)
(31,34,2)
(42,26,2)
(53,60,2)
(3,46,2)
(0,44,2)
(19,20,2)
(2,34,2)
(15,20,2)
(45,20,2)
(54,20,2)
-----------------------------------
(0,riemann_send_msg(host, msg)
(1,0)
(2,riemann_disconnect (host)
(3,pthread_mutex_unlock (&host->lock)
(4,if (host->use_tcp)
(5,status = riemann_recv_ack(host)
(6,status = 0)
(7,host)
(8,status)
(9,&host->lock)
(10,pthread_mutex_lock (&host->lock)
(11,host)
(12,return 0;)
(13,status = riemann_send_msg(host, msg)
(14,pthread_mutex_unlock (&host->lock)
(15,return status;)
(16,host)
(17,status)
(18,status)
(19,host)
(20,status != 0)
(21,host)
(22,host)
(23,status)
(24,riemann_recv_ack(host)
(25,)
(26,host->lock)
(27,status)
(28,struct riemann_host *host)
(29,host->use_tcp)
(30,msg)
(31,host)
(32,status)
(33,status)
(34,status != 0)
(35,lock)
(36,host->lock)
(37,lock)
(38,status)
(39,)
(40,use_tcp)
(41,host)
(42,&host->lock)
(43,if (status != 0)
(44,Msg const *msg)
(45,lock)
(46,&host->lock)
(47,pthread_mutex_unlock (&host->lock)
(48,riemann_disconnect (host)
(49,host)
(50,0)
(51,)
(52,host->lock)
(53,RET)
(54,lock)
(55,host->lock)
(56,0)
(57,&host->lock)
(58,if (status != 0)
(59,)
(60,return status;)
(61,0)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^