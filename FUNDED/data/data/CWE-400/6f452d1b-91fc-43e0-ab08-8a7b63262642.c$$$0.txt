-----label-----
0
-----code-----
static int socket_process_helper(struct iax2_thread *thread)
{
	struct sockaddr_in sin;
	int res;
	int updatehistory=1;
	int new = NEW_PREVENT;
	int dcallno = 0;
	char decrypted = 0;
	struct ast_iax2_full_hdr *fh = (struct ast_iax2_full_hdr *)thread->buf;
	struct ast_iax2_mini_hdr *mh = (struct ast_iax2_mini_hdr *)thread->buf;
	struct ast_iax2_meta_hdr *meta = (struct ast_iax2_meta_hdr *)thread->buf;
	struct ast_iax2_video_hdr *vh = (struct ast_iax2_video_hdr *)thread->buf;
	struct iax_frame *fr;
	struct iax_frame *cur;
	struct ast_frame f = { 0, };
	struct ast_channel *c = NULL;
	struct iax2_dpcache *dp;
	struct iax2_peer *peer;
	struct iax_ies ies;
	struct iax_ie_data ied0, ied1;
	iax2_format format;
	int fd;
	int exists;
	int minivid = 0;
	char empty[32]="";		/* Safety measure */
	struct iax_frame *duped_fr;
	char host_pref_buf[128];
	char caller_pref_buf[128];
	struct ast_codec_pref pref;
	char *using_prefs = "mine";

	/* allocate an iax_frame with 4096 bytes of data buffer */
	fr = ast_alloca(sizeof(*fr) + 4096);
	memset(fr, 0, sizeof(*fr));
	fr->afdatalen = 4096; /* From ast_alloca() above */

	/* Copy frequently used parameters to the stack */
	res = thread->buf_len;
	fd = thread->iofd;
	memcpy(&sin, &thread->iosin, sizeof(sin));

	if (res < sizeof(*mh)) {
		ast_log(LOG_WARNING, "midget packet received (%d of %d min)\n", res, (int) sizeof(*mh));
		return 1;
	}
	if ((vh->zeros == 0) && (ntohs(vh->callno) & 0x8000)) {
		if (res < sizeof(*vh)) {
			ast_log(LOG_WARNING, "Rejecting packet from '%s.%d' that is flagged as a video frame but is too short\n", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));
			return 1;
		}

		/* This is a video frame, get call number */
		fr->callno = find_callno(ntohs(vh->callno) & ~0x8000, dcallno, &sin, new, fd, 0);
		minivid = 1;
	} else if ((meta->zeros == 0) && !(ntohs(meta->metacmd) & 0x8000))
		return socket_process_meta(res, meta, &sin, fd, fr);

#ifdef DEBUG_SUPPORT
	if (res >= sizeof(*fh))
		iax_outputframe(NULL, fh, 1, &sin, res - sizeof(*fh));
#endif
	if (ntohs(mh->callno) & IAX_FLAG_FULL) {
		if (res < sizeof(*fh)) {
			ast_log(LOG_WARNING, "Rejecting packet from '%s.%d' that is flagged as a full frame but is too short\n", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));
			return 1;
		}

		/* Get the destination call number */
		dcallno = ntohs(fh->dcallno) & ~IAX_FLAG_RETRANS;


		/* check to make sure this full frame isn't encrypted before we attempt
 		 * to look inside of it. If it is encrypted, decrypt it first. Its ok if the
		 * callno is not found here, that just means one hasn't been allocated for
		 * this connection yet. */
		if ((dcallno != 1) && (fr->callno = find_callno(ntohs(mh->callno) & ~IAX_FLAG_FULL, dcallno, &sin, NEW_PREVENT, fd, 1))) {
			ast_mutex_lock(&iaxsl[fr->callno]);
			if (iaxs[fr->callno] && ast_test_flag64(iaxs[fr->callno], IAX_ENCRYPTED)) {
				if (decrypt_frame(fr->callno, fh, &f, &res)) {
					ast_log(LOG_NOTICE, "Packet Decrypt Failed!\n");
					ast_mutex_unlock(&iaxsl[fr->callno]);
					return 1;
				}
				decrypted = 1;
			}
			ast_mutex_unlock(&iaxsl[fr->callno]);
		}

		/* Retrieve the type and subclass */
		f.frametype = fh->type;
		if (f.frametype == AST_FRAME_VIDEO) {
			ast_format_from_old_bitfield(&f.subclass.format, (uncompress_subclass(fh->csub & ~0x40)));
			if ((fh->csub >> 6) & 0x1) {
				ast_format_set_video_mark(&f.subclass.format);
			}
		} else if (f.frametype == AST_FRAME_VOICE) {
			ast_format_from_old_bitfield(&f.subclass.format, uncompress_subclass(fh->csub));
		} else {
			f.subclass.integer = uncompress_subclass(fh->csub);
		}

		/* Deal with POKE/PONG without allocating a callno */
		if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_POKE) {
			/* Reply back with a PONG, but don't care about the result. */
			send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_PONG, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);
			return 1;
		} else if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_ACK && dcallno == 1) {
			/* Ignore */
			return 1;
		}

		f.datalen = res - sizeof(*fh);
		if (f.datalen) {
			if (f.frametype == AST_FRAME_IAX) {
				if (iax_parse_ies(&ies, thread->buf + sizeof(struct ast_iax2_full_hdr), f.datalen)) {
					ast_log(LOG_WARNING, "Undecodable frame received from '%s'\n", ast_inet_ntoa(sin.sin_addr));
					ast_variables_destroy(ies.vars);
					return 1;
				}
				f.data.ptr = NULL;
				f.datalen = 0;
			} else {
				f.data.ptr = thread->buf + sizeof(struct ast_iax2_full_hdr);
				memset(&ies, 0, sizeof(ies));
			}
		} else {
			if (f.frametype == AST_FRAME_IAX)
				f.data.ptr = NULL;
			else
				f.data.ptr = empty;
			memset(&ies, 0, sizeof(ies));
		}

		if (!dcallno && iax2_allow_new(f.frametype, f.subclass.integer, 1)) {
			/* only set NEW_ALLOW if calltoken checks out */
			if (handle_call_token(fh, &ies, &sin, fd)) {
				ast_variables_destroy(ies.vars);
				return 1;
			}

			if (ies.calltoken && ies.calltokendata) {
				/* if we've gotten this far, and the calltoken ie data exists,
				 * then calltoken validation _MUST_ have taken place.  If calltoken
				 * data is provided, it is always validated reguardless of any
				 * calltokenoptional or requirecalltoken options */
				new = NEW_ALLOW_CALLTOKEN_VALIDATED;
			} else {
				new = NEW_ALLOW;
			}
		}
	} else {
		/* Don't know anything about it yet */
		f.frametype = AST_FRAME_NULL;
		f.subclass.integer = 0;
		memset(&ies, 0, sizeof(ies));
	}

	if (!fr->callno) {
		int check_dcallno = 0;

		/*
		 * We enforce accurate destination call numbers for ACKs.  This forces the other
		 * end to know the destination call number before call setup can complete.
		 *
		 * Discussed in the following thread:
		 *    http://lists.digium.com/pipermail/asterisk-dev/2008-May/033217.html 
		 */

		if ((ntohs(mh->callno) & IAX_FLAG_FULL) && ((f.frametype == AST_FRAME_IAX) && (f.subclass.integer == IAX_COMMAND_ACK))) {
			check_dcallno = 1;
		}

		if (!(fr->callno = find_callno(ntohs(mh->callno) & ~IAX_FLAG_FULL, dcallno, &sin, new, fd, check_dcallno))) {
			if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_NEW) {
				send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REJECT, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);
			} else if (f.frametype == AST_FRAME_IAX && (f.subclass.integer == IAX_COMMAND_REGREQ || f.subclass.integer == IAX_COMMAND_REGREL)) {
				send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REGREJ, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);
			}
			ast_variables_destroy(ies.vars);
			return 1;
		}
	}

	if (fr->callno > 0) {
		struct ast_callid *mount_callid;
		ast_mutex_lock(&iaxsl[fr->callno]);
		if (iaxs[fr->callno] && ((mount_callid = iax_pvt_callid_get(fr->callno)))) {
			/* Bind to thread */
			ast_callid_threadassoc_add(mount_callid);
			ast_callid_unref(mount_callid);
		}
	}

	if (!fr->callno || !iaxs[fr->callno]) {
		/* A call arrived for a nonexistent destination.  Unless it's an "inval"
		   frame, reply with an inval */
		if (ntohs(mh->callno) & IAX_FLAG_FULL) {
			/* We can only raw hangup control frames */
			if (((f.subclass.integer != IAX_COMMAND_INVAL) &&
				 (f.subclass.integer != IAX_COMMAND_TXCNT) &&
				 (f.subclass.integer != IAX_COMMAND_TXACC) &&
				 (f.subclass.integer != IAX_COMMAND_FWDOWNL))||
			    (f.frametype != AST_FRAME_IAX))
				raw_hangup(&sin, ntohs(fh->dcallno) & ~IAX_FLAG_RETRANS, ntohs(mh->callno) & ~IAX_FLAG_FULL,
				fd);
		}
		if (fr->callno > 0) 
			ast_mutex_unlock(&iaxsl[fr->callno]);
		ast_variables_destroy(ies.vars);
		return 1;
	}
	if (ast_test_flag64(iaxs[fr->callno], IAX_ENCRYPTED) && !decrypted) {
		if (decrypt_frame(fr->callno, fh, &f, &res)) {
			ast_log(LOG_NOTICE, "Packet Decrypt Failed!\n");
			ast_variables_destroy(ies.vars);
			ast_mutex_unlock(&iaxsl[fr->callno]);
			return 1;
		}
		decrypted = 1;
	}

#ifdef DEBUG_SUPPORT
	if (decrypted) {
		iax_outputframe(NULL, fh, 3, &sin, res - sizeof(*fh));
	}
#endif

	if (iaxs[fr->callno]->owner && fh->type == AST_FRAME_IAX &&
			(fh->csub == IAX_COMMAND_HANGUP
			|| fh->csub == IAX_COMMAND_REJECT
			|| fh->csub == IAX_COMMAND_REGREJ
			|| fh->csub == IAX_COMMAND_TXREJ)) {
		struct ast_control_pvt_cause_code *cause_code;
		int data_size = sizeof(*cause_code);
		char subclass[40] = "";

		/* get subclass text */
		iax_frame_subclass2str(fh->csub, subclass, sizeof(subclass));

		/* add length of "IAX2 " */
		data_size += 5;
		/* for IAX hangup frames, add length of () and number */
		data_size += 3;
		if (ies.causecode > 9) {
			data_size++;
		}
		if (ies.causecode > 99) {
			data_size++;
		}
		/* add length of subclass */
		data_size += strlen(subclass);

		cause_code = ast_alloca(data_size);
		ast_copy_string(cause_code->chan_name, ast_channel_name(iaxs[fr->callno]->owner), AST_CHANNEL_NAME);

		cause_code->ast_cause = ies.causecode;
		snprintf(cause_code->code, data_size - sizeof(*cause_code) + 1, "IAX2 %s(%d)", subclass, ies.causecode);

		iax2_lock_owner(fr->callno);
		if (iaxs[fr->callno] && iaxs[fr->callno]->owner) {
			ast_queue_control_data(iaxs[fr->callno]->owner, AST_CONTROL_PVT_CAUSE_CODE, cause_code, data_size);
			ast_channel_hangupcause_hash_set(iaxs[fr->callno]->owner, cause_code, data_size);
			ast_channel_unlock(iaxs[fr->callno]->owner);
		}
		if (!iaxs[fr->callno]) {
			ast_variables_destroy(ies.vars);
			ast_mutex_unlock(&iaxsl[fr->callno]);
			return 1;
		}
	}

	/* count this frame */
	iaxs[fr->callno]->frames_received++;

	if (!inaddrcmp(&sin, &iaxs[fr->callno]->addr) && !minivid &&
		f.subclass.integer != IAX_COMMAND_TXCNT &&		/* for attended transfer */
		f.subclass.integer != IAX_COMMAND_TXACC) {		/* for attended transfer */
		unsigned short new_peercallno;

		new_peercallno = (unsigned short) (ntohs(mh->callno) & ~IAX_FLAG_FULL);
		if (new_peercallno && new_peercallno != iaxs[fr->callno]->peercallno) {
			if (iaxs[fr->callno]->peercallno) {
				remove_by_peercallno(iaxs[fr->callno]);
			}
			iaxs[fr->callno]->peercallno = new_peercallno;
			store_by_peercallno(iaxs[fr->callno]);
		}
	}
	if (ntohs(mh->callno) & IAX_FLAG_FULL) {
		if (iaxdebug)
			ast_debug(1, "Received packet %d, (%d, %u)\n", fh->oseqno, f.frametype, f.subclass.integer);
		/* Check if it's out of order (and not an ACK or INVAL) */
		fr->oseqno = fh->oseqno;
		fr->iseqno = fh->iseqno;
		fr->ts = ntohl(fh->ts);
#ifdef IAXTESTS
		if (test_resync) {
			ast_debug(1, "Simulating frame ts resync, was %u now %u\n", fr->ts, fr->ts + test_resync);
			fr->ts += test_resync;
		}
#endif /* IAXTESTS */
#if 0
		if ( (ntohs(fh->dcallno) & IAX_FLAG_RETRANS) ||
		     ( (f.frametype != AST_FRAME_VOICE) && ! (f.frametype == AST_FRAME_IAX &&
								(f.subclass == IAX_COMMAND_NEW ||
								 f.subclass == IAX_COMMAND_AUTHREQ ||
								 f.subclass == IAX_COMMAND_ACCEPT ||
								 f.subclass == IAX_COMMAND_REJECT))      ) )
#endif
		if ((ntohs(fh->dcallno) & IAX_FLAG_RETRANS) || (f.frametype != AST_FRAME_VOICE))
			updatehistory = 0;
		if ((iaxs[fr->callno]->iseqno != fr->oseqno) &&
			(iaxs[fr->callno]->iseqno ||
				((f.subclass.integer != IAX_COMMAND_TXCNT) &&
				(f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */
				(f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */
				(f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */
				(f.subclass.integer != IAX_COMMAND_TXACC)) ||
				(f.frametype != AST_FRAME_IAX))) {
			if (
			 ((f.subclass.integer != IAX_COMMAND_ACK) &&
			  (f.subclass.integer != IAX_COMMAND_INVAL) &&
			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&
			  (f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */
			  (f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */
			  (f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */
			  (f.subclass.integer != IAX_COMMAND_TXACC) &&
			  (f.subclass.integer != IAX_COMMAND_VNAK)) ||
			  (f.frametype != AST_FRAME_IAX)) {
				/* If it's not an ACK packet, it's out of order. */
				ast_debug(1, "Packet arrived out of order (expecting %d, got %d) (frametype = %d, subclass = %d)\n",
					iaxs[fr->callno]->iseqno, fr->oseqno, f.frametype, f.subclass.integer);
				/* Check to see if we need to request retransmission,
				 * and take sequence number wraparound into account */
				if ((unsigned char) (iaxs[fr->callno]->iseqno - fr->oseqno) < 128) {
					/* If we've already seen it, ack it XXX There's a border condition here XXX */
					if ((f.frametype != AST_FRAME_IAX) ||
							((f.subclass.integer != IAX_COMMAND_ACK) && (f.subclass.integer != IAX_COMMAND_INVAL))) {
						ast_debug(1, "Acking anyway\n");
						/* XXX Maybe we should handle its ack to us, but then again, it's probably outdated anyway, and if
						   we have anything to send, we'll retransmit and get an ACK back anyway XXX */
						send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
					}
				} else {
					/* Send a VNAK requesting retransmission */
					iax2_vnak(fr->callno);
				}
				ast_variables_destroy(ies.vars);
				ast_mutex_unlock(&iaxsl[fr->callno]);
				return 1;
			}
		} else {
			/* Increment unless it's an ACK or VNAK */
			if (((f.subclass.integer != IAX_COMMAND_ACK) &&
			    (f.subclass.integer != IAX_COMMAND_INVAL) &&
			    (f.subclass.integer != IAX_COMMAND_TXCNT) &&
			    (f.subclass.integer != IAX_COMMAND_TXACC) &&
				(f.subclass.integer != IAX_COMMAND_VNAK)) ||
			    (f.frametype != AST_FRAME_IAX))
				iaxs[fr->callno]->iseqno++;
		}
		/* Ensure text frames are NULL-terminated */
		if (f.frametype == AST_FRAME_TEXT && thread->buf[res - 1] != '\0') {
			if (res < thread->buf_size)
				thread->buf[res++] = '\0';
			else /* Trims one character from the text message, but that's better than overwriting the end of the buffer. */
				thread->buf[res - 1] = '\0';
		}

		/* Handle implicit ACKing unless this is an INVAL, and only if this is 
		   from the real peer, not the transfer peer */
		if (!inaddrcmp(&sin, &iaxs[fr->callno]->addr) &&
		    ((f.subclass.integer != IAX_COMMAND_INVAL) ||
		     (f.frametype != AST_FRAME_IAX))) {
			unsigned char x;
			int call_to_destroy;
			/* First we have to qualify that the ACKed value is within our window */
			if (iaxs[fr->callno]->rseqno >= iaxs[fr->callno]->oseqno || (fr->iseqno >= iaxs[fr->callno]->rseqno && fr->iseqno < iaxs[fr->callno]->oseqno))
				x = fr->iseqno;
			else
				x = iaxs[fr->callno]->oseqno;
			if ((x != iaxs[fr->callno]->oseqno) || (iaxs[fr->callno]->oseqno == fr->iseqno)) {
				/* The acknowledgement is within our window.  Time to acknowledge everything
				   that it says to */
				for (x=iaxs[fr->callno]->rseqno; x != fr->iseqno; x++) {
					/* Ack the packet with the given timestamp */
					if (iaxdebug)
						ast_debug(1, "Cancelling transmission of packet %d\n", x);
					call_to_destroy = 0;
					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {
						/* If it's our call, and our timestamp, mark -1 retries */
						if (x == cur->oseqno) {
							cur->retries = -1;
							/* Destroy call if this is the end */
							if (cur->final)
								call_to_destroy = fr->callno;
						}
					}
					if (call_to_destroy) {
						if (iaxdebug)
							ast_debug(1, "Really destroying %d, having been acked on final message\n", call_to_destroy);
						ast_mutex_lock(&iaxsl[call_to_destroy]);
						iax2_destroy(call_to_destroy);
						ast_mutex_unlock(&iaxsl[call_to_destroy]);
					}
				}
				/* Note how much we've received acknowledgement for */
				if (iaxs[fr->callno])
					iaxs[fr->callno]->rseqno = fr->iseqno;
				else {
					/* Stop processing now */
					ast_variables_destroy(ies.vars);
					ast_mutex_unlock(&iaxsl[fr->callno]);
					return 1;
				}
			} else {
				ast_debug(1, "Received iseqno %d not within window %d->%d\n", fr->iseqno, iaxs[fr->callno]->rseqno, iaxs[fr->callno]->oseqno);
			}
		}
		if (inaddrcmp(&sin, &iaxs[fr->callno]->addr) &&
			((f.frametype != AST_FRAME_IAX) ||
			 ((f.subclass.integer != IAX_COMMAND_TXACC) &&
			  (f.subclass.integer != IAX_COMMAND_TXCNT)))) {
			/* Only messages we accept from a transfer host are TXACC and TXCNT */
			ast_variables_destroy(ies.vars);
			ast_mutex_unlock(&iaxsl[fr->callno]);
			return 1;
		}

		/* when we receive the first full frame for a new incoming channel,
		   it is safe to start the PBX on the channel because we have now
		   completed a 3-way handshake with the peer */
		if ((f.frametype == AST_FRAME_VOICE) ||
		    (f.frametype == AST_FRAME_VIDEO) ||
		    (f.frametype == AST_FRAME_IAX)) {
			if (ast_test_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART)) {
				ast_clear_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);
				if (!ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->chosenformat, NULL)) {
					ast_variables_destroy(ies.vars);
					ast_mutex_unlock(&iaxsl[fr->callno]);
					return 1;
				}
			}

			if (ies.vars) {
				struct ast_datastore *variablestore = NULL;
				struct ast_variable *var, *prev = NULL;
				AST_LIST_HEAD(, ast_var_t) *varlist;

				iax2_lock_owner(fr->callno);
				if (!iaxs[fr->callno]) {
					ast_variables_destroy(ies.vars);
					ast_mutex_unlock(&iaxsl[fr->callno]);
					return 1;
				}
				if ((c = iaxs[fr->callno]->owner)) {
					varlist = ast_calloc(1, sizeof(*varlist));
					variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);

					if (variablestore && varlist) {
						variablestore->data = varlist;
						variablestore->inheritance = DATASTORE_INHERIT_FOREVER;
						AST_LIST_HEAD_INIT(varlist);
						ast_debug(1, "I can haz IAX vars?\n");
						for (var = ies.vars; var; var = var->next) {
							struct ast_var_t *newvar = ast_var_assign(var->name, var->value);
							if (prev) {
								ast_free(prev);
							}
							prev = var;
							if (!newvar) {
								/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */
								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");
							} else {
								AST_LIST_INSERT_TAIL(varlist, newvar, entries);
							}
						}
						if (prev) {
							ast_free(prev);
						}
						ies.vars = NULL;
						ast_channel_datastore_add(c, variablestore);
					} else {
						ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");
						if (variablestore) {
							ast_datastore_free(variablestore);
						}
						if (varlist) {
							ast_free(varlist);
						}
					}
					ast_channel_unlock(c);
				} else {
					/* No channel yet, so transfer the variables directly over to the pvt,
					 * for later inheritance. */
					ast_debug(1, "No channel, so populating IAXVARs to the pvt, as an intermediate step.\n");
					for (var = ies.vars; var && var->next; var = var->next);
					if (var) {
						var->next = iaxs[fr->callno]->iaxvars;
						iaxs[fr->callno]->iaxvars = ies.vars;
						ies.vars = NULL;
					}
				}
			}

			if (ies.vars) {
				ast_debug(1, "I have IAX variables, but they were not processed\n");
			}
		}

		/* once we receive our first IAX Full Frame that is not CallToken related, send all
		 * queued signaling frames that were being held. */
		if ((f.frametype == AST_FRAME_IAX) && (f.subclass.integer != IAX_COMMAND_CALLTOKEN) && iaxs[fr->callno]->hold_signaling) {
			send_signaling(iaxs[fr->callno]);
		}

		if (f.frametype == AST_FRAME_VOICE) {
			if (ast_format_to_old_bitfield(&f.subclass.format) != iaxs[fr->callno]->voiceformat) {
					iaxs[fr->callno]->voiceformat = ast_format_to_old_bitfield(&f.subclass.format);
					ast_debug(1, "Ooh, voice format changed to '%s'\n", ast_getformatname(&f.subclass.format));
					if (iaxs[fr->callno]->owner) {
						iax2_lock_owner(fr->callno);
						if (iaxs[fr->callno]) {
							if (iaxs[fr->callno]->owner) {
								struct ast_format_cap *orignative = ast_format_cap_dup(ast_channel_nativeformats(iaxs[fr->callno]->owner));
								struct ast_format_cap *native = ast_channel_nativeformats(iaxs[fr->callno]->owner);
								if (orignative) {
									ast_format_cap_set(native, &f.subclass.format);
									if (ast_channel_readformat(iaxs[fr->callno]->owner)->id) {
										ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));
									}
									ast_format_cap_copy(native, orignative);
									ast_channel_unlock(iaxs[fr->callno]->owner);
									orignative = ast_format_cap_destroy(orignative);
								}
							}
						} else {
							ast_debug(1, "Neat, somebody took away the channel at a magical time but i found it!\n");
							/* Free remote variables (if any) */
							if (ies.vars) {
								ast_variables_destroy(ies.vars);
								ast_debug(1, "I can haz iaxvars, but they is no good.  :-(\n");
								ies.vars = NULL;
							}
							ast_mutex_unlock(&iaxsl[fr->callno]);
							return 1;
						}
					}
			}
		}
		if (f.frametype == AST_FRAME_VIDEO) {
			if (f.subclass.format.id != ast_format_id_from_old_bitfield(iaxs[fr->callno]->videoformat)) {
				ast_debug(1, "Ooh, video format changed to %s\n", ast_getformatname(&f.subclass.format));
				iaxs[fr->callno]->videoformat = ast_format_to_old_bitfield(&f.subclass.format);
			}
		}
		if (f.frametype == AST_FRAME_CONTROL && iaxs[fr->callno]->owner) {
			if (f.subclass.integer == AST_CONTROL_BUSY) {
				ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_BUSY);
			} else if (f.subclass.integer == AST_CONTROL_CONGESTION) {
				ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_CONGESTION);
			}
		}
		if (f.frametype == AST_FRAME_IAX) {
			AST_SCHED_DEL(sched, iaxs[fr->callno]->initid);
			/* Handle the IAX pseudo frame itself */
			if (iaxdebug)
				ast_debug(1, "IAX subclass %d received\n", f.subclass.integer);

                        /* Update last ts unless the frame's timestamp originated with us. */
			if (iaxs[fr->callno]->last < fr->ts &&
                            f.subclass.integer != IAX_COMMAND_ACK &&
                            f.subclass.integer != IAX_COMMAND_PONG &&
                            f.subclass.integer != IAX_COMMAND_LAGRP) {
				iaxs[fr->callno]->last = fr->ts;
				if (iaxdebug)
					ast_debug(1, "For call=%d, set last=%d\n", fr->callno, fr->ts);
			}
			iaxs[fr->callno]->last_iax_message = f.subclass.integer;
			if (!iaxs[fr->callno]->first_iax_message) {
				iaxs[fr->callno]->first_iax_message = f.subclass.integer;
			}
			switch(f.subclass.integer) {
			case IAX_COMMAND_ACK:
				/* Do nothing */
				break;
			case IAX_COMMAND_QUELCH:
				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {
				        /* Generate Manager Hold event, if necessary*/
					if (iaxs[fr->callno]->owner) {
						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",
							"Status: On\r\n"
							"Channel: %s\r\n"
							"Uniqueid: %s\r\n",
							ast_channel_name(iaxs[fr->callno]->owner),
							ast_channel_uniqueid(iaxs[fr->callno]->owner));
					}

					ast_set_flag64(iaxs[fr->callno], IAX_QUELCH);
					if (ies.musiconhold) {
						iax2_lock_owner(fr->callno);
						if (!iaxs[fr->callno] || !iaxs[fr->callno]->owner) {
							break;
						}
						if (ast_bridged_channel(iaxs[fr->callno]->owner)) {
							const char *moh_suggest = iaxs[fr->callno]->mohsuggest;

							/*
							 * We already hold the owner lock so we do not
							 * need to check iaxs[fr->callno] after it returns.
							 */
							iax2_queue_control_data(fr->callno, AST_CONTROL_HOLD, 
								S_OR(moh_suggest, NULL),
								!ast_strlen_zero(moh_suggest) ? strlen(moh_suggest) + 1 : 0);
						}
						ast_channel_unlock(iaxs[fr->callno]->owner);
					}
				}
				break;
			case IAX_COMMAND_UNQUELCH:
				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {
					iax2_lock_owner(fr->callno);
					if (!iaxs[fr->callno]) {
						break;
					}
					/* Generate Manager Unhold event, if necessary */
					if (iaxs[fr->callno]->owner && ast_test_flag64(iaxs[fr->callno], IAX_QUELCH)) {
						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",
							"Status: Off\r\n"
							"Channel: %s\r\n"
							"Uniqueid: %s\r\n",
							ast_channel_name(iaxs[fr->callno]->owner),
							ast_channel_uniqueid(iaxs[fr->callno]->owner));
					}

					ast_clear_flag64(iaxs[fr->callno], IAX_QUELCH);
					if (!iaxs[fr->callno]->owner) {
						break;
					}
					if (ast_bridged_channel(iaxs[fr->callno]->owner)) {
						/*
						 * We already hold the owner lock so we do not
						 * need to check iaxs[fr->callno] after it returns.
						 */
						iax2_queue_control_data(fr->callno, AST_CONTROL_UNHOLD, NULL, 0);
					}
					ast_channel_unlock(iaxs[fr->callno]->owner);
				}
				break;
			case IAX_COMMAND_TXACC:
				if (iaxs[fr->callno]->transferring == TRANSFER_BEGIN) {
					/* Ack the packet with the given timestamp */
					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {
						/* Cancel any outstanding txcnt's */
						if (cur->transfer) {
							cur->retries = -1;
						}
					}
					memset(&ied1, 0, sizeof(ied1));
					iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->callno);
					send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREADY, 0, ied1.buf, ied1.pos, -1);
					iaxs[fr->callno]->transferring = TRANSFER_READY;
				}
				break;
			case IAX_COMMAND_NEW:
				/* Ignore if it's already up */
				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD))
					break;
				if (ies.provverpres && ies.serviceident && sin.sin_addr.s_addr) {
					ast_mutex_unlock(&iaxsl[fr->callno]);
					check_provisioning(&sin, fd, ies.serviceident, ies.provver);
					ast_mutex_lock(&iaxsl[fr->callno]);
					if (!iaxs[fr->callno]) {
						break;
					}
				}
				/* If we're in trunk mode, do it now, and update the trunk number in our frame before continuing */
				if (ast_test_flag64(iaxs[fr->callno], IAX_TRUNK)) {
					int new_callno;
					if ((new_callno = make_trunk(fr->callno, 1)) != -1)
						fr->callno = new_callno;
				}
				/* For security, always ack immediately */
				if (delayreject)
					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
				if (check_access(fr->callno, &sin, &ies)) {
					/* They're not allowed on */
					auth_fail(fr->callno, IAX_COMMAND_REJECT);
					if (authdebug)
						ast_log(LOG_NOTICE, "Rejected connect attempt from %s, who was trying to reach '%s@%s'\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);
					break;
				}
				if (ast_strlen_zero(iaxs[fr->callno]->secret) && ast_test_flag64(iaxs[fr->callno], IAX_FORCE_ENCRYPT)) {
					auth_fail(fr->callno, IAX_COMMAND_REJECT);
					ast_log(LOG_WARNING, "Rejected connect attempt.  No secret present while force encrypt enabled.\n");
					break;
				}
				if (strcasecmp(iaxs[fr->callno]->exten, "TBD")) {
					const char *context, *exten, *cid_num;

					context = ast_strdupa(iaxs[fr->callno]->context);
					exten = ast_strdupa(iaxs[fr->callno]->exten);
					cid_num = ast_strdupa(iaxs[fr->callno]->cid_num);

					/* This might re-enter the IAX code and need the lock */
					ast_mutex_unlock(&iaxsl[fr->callno]);
					exists = ast_exists_extension(NULL, context, exten, 1, cid_num);
					ast_mutex_lock(&iaxsl[fr->callno]);

					if (!iaxs[fr->callno]) {
						break;
					}
				} else
					exists = 0;
				/* Get OSP token if it does exist */
				save_osptoken(fr, &ies);
				if (ast_strlen_zero(iaxs[fr->callno]->secret) && ast_strlen_zero(iaxs[fr->callno]->inkeys)) {
					if (strcmp(iaxs[fr->callno]->exten, "TBD") && !exists) {
						memset(&ied0, 0, sizeof(ied0));
						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");
						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);
						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);
						if (!iaxs[fr->callno]) {
							break;
						}
						if (authdebug)
							ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);
					} else {
						/* Select an appropriate format */

						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {
							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {
								using_prefs = "reqonly";
							} else {
								using_prefs = "disabled";
							}
							format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;
							memset(&pref, 0, sizeof(pref));
							strcpy(caller_pref_buf, "disabled");
							strcpy(host_pref_buf, "disabled");
						} else {
							struct ast_format tmpfmt;
							using_prefs = "mine";
							/* If the information elements are in here... use them */
							if (ies.codec_prefs)
								ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);
							if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {
								/* If we are codec_first_choice we let the caller have the 1st shot at picking the codec.*/
								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {
									pref = iaxs[fr->callno]->rprefs;
									using_prefs = "caller";
								} else {
									pref = iaxs[fr->callno]->prefs;
								}
							} else
								pref = iaxs[fr->callno]->prefs;

							format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);
							ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);
							ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);
						}
						if (!format) {
							if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP))
								format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;
							if (!format) {
								memset(&ied0, 0, sizeof(ied0));
								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");
								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);
								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);
								if (!iaxs[fr->callno]) {
									break;
								}
								if (authdebug) {
									char tmp[256], tmp2[256], tmp3[256];
									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {
										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",
											ast_inet_ntoa(sin.sin_addr),
											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),
											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));
									} else {
										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",
											ast_inet_ntoa(sin.sin_addr),
											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),
											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),
											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));
									}
								}
							} else {
								/* Pick one... */
								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {
									if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))
										format = 0;
								} else {
									if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {
										using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";
										memset(&pref, 0, sizeof(pref));
										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);
										strcpy(caller_pref_buf,"disabled");
										strcpy(host_pref_buf,"disabled");
									} else {
										struct ast_format tmpfmt;
										using_prefs = "mine";
										if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {
											/* Do the opposite of what we tried above. */
											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {
												pref = iaxs[fr->callno]->prefs;
											} else {
												pref = iaxs[fr->callno]->rprefs;
												using_prefs = "caller";
											}
											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);
										} else /* if no codec_prefs IE do it the old way */
											format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);
									}
								}

								if (!format) {
									char tmp[256], tmp2[256], tmp3[256];
									memset(&ied0, 0, sizeof(ied0));
									iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");
									iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);
									ast_log(LOG_ERROR, "No best format in '%s'???\n", iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));
									send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);
									if (!iaxs[fr->callno]) {
										break;
									}
									if (authdebug) {
										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",
											ast_inet_ntoa(sin.sin_addr),
											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),
											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),
											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));
									}
									ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);
									break;
								}
							}
						}
						if (format) {
							/* No authentication required, let them in */
							memset(&ied1, 0, sizeof(ied1));
							iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);
							iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);
							send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);
							if (strcmp(iaxs[fr->callno]->exten, "TBD")) {
								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);
								ast_verb(3, "Accepting UNAUTHENTICATED call from %s:\n"
												"%srequested format = %s,\n"
												"%srequested prefs = %s,\n"
												"%sactual format = %s,\n"
												"%shost prefs = %s,\n"
												"%spriority = %s\n",
												ast_inet_ntoa(sin.sin_addr), 
												VERBOSE_PREFIX_4,
												iax2_getformatname(iaxs[fr->callno]->peerformat), 
												VERBOSE_PREFIX_4,
												caller_pref_buf,
												VERBOSE_PREFIX_4,
												iax2_getformatname(format), 
												VERBOSE_PREFIX_4,
												host_pref_buf, 
												VERBOSE_PREFIX_4,
												using_prefs);

								iaxs[fr->callno]->chosenformat = format;

								/* Since this is a new call, we should go ahead and set the callid for it. */
								iax_pvt_callid_new(fr->callno);
								ast_set_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);
							} else {
								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);
								/* If this is a TBD call, we're ready but now what...  */
								ast_verb(3, "Accepted unauthenticated TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));
							}
						}
					}
					break;
				}
				if (iaxs[fr->callno]->authmethods & IAX_AUTH_MD5)
					merge_encryption(iaxs[fr->callno],ies.encmethods);
				else
					iaxs[fr->callno]->encmethods = 0;
				if (!authenticate_request(fr->callno) && iaxs[fr->callno])
					ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED);
				break;
			case IAX_COMMAND_DPREQ:
				/* Request status in the dialplan */
				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD) &&
					!ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED) && ies.called_number) {
					if (iaxcompat) {
						/* Spawn a thread for the lookup */
						spawn_dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num);
					} else {
						/* Just look it up */
						dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num, 1);
					}
				}
				break;
			case IAX_COMMAND_HANGUP:
				ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);
				ast_debug(1, "Immediately destroying %d, having received hangup\n", fr->callno);
				/* Set hangup cause according to remote and hangupsource */
				if (iaxs[fr->callno]->owner) {
					set_hangup_source_and_cause(fr->callno, ies.causecode);
					if (!iaxs[fr->callno]) {
						break;
					}
				}

				/* Send ack immediately, before we destroy */
				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
				iax2_destroy(fr->callno);
				break;
			case IAX_COMMAND_REJECT:
				/* Set hangup cause according to remote and hangup source */
				if (iaxs[fr->callno]->owner) {
					set_hangup_source_and_cause(fr->callno, ies.causecode);
					if (!iaxs[fr->callno]) {
						break;
					}
				}

				if (!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)) {
					if (iaxs[fr->callno]->owner && authdebug)
						ast_log(LOG_WARNING, "Call rejected by %s: %s\n",
							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr),
							ies.cause ? ies.cause : "<Unknown>");
					ast_debug(1, "Immediately destroying %d, having received reject\n",
						fr->callno);
				}
				/* Send ack immediately, before we destroy */
				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK,
						       fr->ts, NULL, 0, fr->iseqno);
				if (!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION))
					iaxs[fr->callno]->error = EPERM;
				iax2_destroy(fr->callno);
				break;
			case IAX_COMMAND_TRANSFER:
			{
				struct ast_channel *bridged_chan;
				struct ast_channel *owner;

				iax2_lock_owner(fr->callno);
				if (!iaxs[fr->callno]) {
					/* Initiating call went away before we could transfer. */
					break;
				}
				owner = iaxs[fr->callno]->owner;
				bridged_chan = owner ? ast_bridged_channel(owner) : NULL;
				if (bridged_chan && ies.called_number) {
					const char *context;

					context = ast_strdupa(iaxs[fr->callno]->context);

					ast_channel_ref(owner);
					ast_channel_ref(bridged_chan);
					ast_channel_unlock(owner);
					ast_mutex_unlock(&iaxsl[fr->callno]);

					/* Set BLINDTRANSFER channel variables */
					pbx_builtin_setvar_helper(owner, "BLINDTRANSFER", ast_channel_name(bridged_chan));
					pbx_builtin_setvar_helper(bridged_chan, "BLINDTRANSFER", ast_channel_name(owner));

					/* DO NOT hold any locks while calling ast_parking_ext_valid() */
					if (ast_parking_ext_valid(ies.called_number, owner, context)) {
						ast_debug(1, "Parking call '%s'\n", ast_channel_name(bridged_chan));
						if (iax_park(bridged_chan, owner, ies.called_number, context)) {
							ast_log(LOG_WARNING, "Failed to park call '%s'\n",
								ast_channel_name(bridged_chan));
						}
					} else {
						if (ast_async_goto(bridged_chan, context, ies.called_number, 1)) {
							ast_log(LOG_WARNING,
								"Async goto of '%s' to '%s@%s' failed\n",
								ast_channel_name(bridged_chan), ies.called_number, context);
						} else {
							ast_debug(1, "Async goto of '%s' to '%s@%s' started\n",
								ast_channel_name(bridged_chan), ies.called_number, context);
						}
					}
					ast_channel_unref(owner);
					ast_channel_unref(bridged_chan);

					ast_mutex_lock(&iaxsl[fr->callno]);
				} else {
					ast_debug(1, "Async goto not applicable on call %d\n", fr->callno);
					if (owner) {
						ast_channel_unlock(owner);
					}
				}

				break;
			}
			case IAX_COMMAND_ACCEPT:
				/* Ignore if call is already up or needs authentication or is a TBD */
				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD | IAX_STATE_AUTHENTICATED))
					break;
				if (ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)) {
					/* Send ack immediately, before we destroy */
					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
					iax2_destroy(fr->callno);
					break;
				}
				if (ies.format) {
					iaxs[fr->callno]->peerformat = ies.format;
				} else {
					if (iaxs[fr->callno]->owner)
						iaxs[fr->callno]->peerformat = ast_format_cap_to_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner));
					else
						iaxs[fr->callno]->peerformat = iaxs[fr->callno]->capability;
				}
				ast_verb(3, "Call accepted by %s (format %s)\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iax2_getformatname(iaxs[fr->callno]->peerformat));
				if (!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)) {
					memset(&ied0, 0, sizeof(ied0));
					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");
					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);
					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);
					if (!iaxs[fr->callno]) {
						break;
					}
					if (authdebug) {
						char tmp1[256], tmp2[256];
						ast_log(LOG_NOTICE, "Rejected call to %s, format %s incompatible with our capability %s.\n",
							ast_inet_ntoa(sin.sin_addr),
							iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),
							iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));
					}
				} else {
					ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);
					iax2_lock_owner(fr->callno);
					if (iaxs[fr->callno] && iaxs[fr->callno]->owner) {
						char tmp[256];
						/* Switch us to use a compatible format */
						ast_format_cap_from_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner), iaxs[fr->callno]->peerformat);
						ast_verb(3, "Format for call is %s\n", ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(iaxs[fr->callno]->owner)));

						/* Setup read/write formats properly. */
						if (ast_channel_writeformat(iaxs[fr->callno]->owner)->id)
							ast_set_write_format(iaxs[fr->callno]->owner, ast_channel_writeformat(iaxs[fr->callno]->owner));
						if (ast_channel_readformat(iaxs[fr->callno]->owner)->id)
							ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));
						ast_channel_unlock(iaxs[fr->callno]->owner);
					}
				}
				if (iaxs[fr->callno]) {
					AST_LIST_LOCK(&dpcache);
					AST_LIST_TRAVERSE(&iaxs[fr->callno]->dpentries, dp, peer_list)
						if (!(dp->flags & CACHE_FLAG_TRANSMITTED))
							iax2_dprequest(dp, fr->callno);
					AST_LIST_UNLOCK(&dpcache);
				}
				break;
			case IAX_COMMAND_POKE:
				/* Send back a pong packet with the original timestamp */
				send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, NULL, 0, -1);
				break;
			case IAX_COMMAND_PING:
			{
				struct iax_ie_data pingied;
				construct_rr(iaxs[fr->callno], &pingied);
				/* Send back a pong packet with the original timestamp */
				send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, pingied.buf, pingied.pos, -1);
			}
				break;
			case IAX_COMMAND_PONG:
				/* Calculate ping time */
				iaxs[fr->callno]->pingtime =  calc_timestamp(iaxs[fr->callno], 0, &f) - fr->ts;
				/* save RR info */
				save_rr(fr, &ies);

				/* Good time to write jb stats for this call */
				log_jitterstats(fr->callno);

				if (iaxs[fr->callno]->peerpoke) {
					peer = iaxs[fr->callno]->peerpoke;
					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms)) {
						if (iaxs[fr->callno]->pingtime <= peer->maxms) {
							ast_log(LOG_NOTICE, "Peer '%s' is now REACHABLE! Time: %d\n", peer->name, iaxs[fr->callno]->pingtime);
							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Reachable\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 
							ast_devstate_changed(AST_DEVICE_NOT_INUSE, "IAX2/%s", peer->name); /* Activate notification */
						}
					} else if ((peer->historicms > 0) && (peer->historicms <= peer->maxms)) {
						if (iaxs[fr->callno]->pingtime > peer->maxms) {
							ast_log(LOG_NOTICE, "Peer '%s' is now TOO LAGGED (%d ms)!\n", peer->name, iaxs[fr->callno]->pingtime);
							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Lagged\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 
							ast_devstate_changed(AST_DEVICE_UNAVAILABLE, "IAX2/%s", peer->name); /* Activate notification */
						}
					}
					peer->lastms = iaxs[fr->callno]->pingtime;
					if (peer->smoothing && (peer->lastms > -1))
						peer->historicms = (iaxs[fr->callno]->pingtime + peer->historicms) / 2;
					else if (peer->smoothing && peer->lastms < 0)
						peer->historicms = (0 + peer->historicms) / 2;
					else					
						peer->historicms = iaxs[fr->callno]->pingtime;

					/* Remove scheduled iax2_poke_noanswer */
					if (peer->pokeexpire > -1) {
						if (!AST_SCHED_DEL(sched, peer->pokeexpire)) {
							peer_unref(peer);
							peer->pokeexpire = -1;
						}
					}
					/* Schedule the next cycle */
					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms))
						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_peer_s, peer_ref(peer));
					else
						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqok, iax2_poke_peer_s, peer_ref(peer));
					if (peer->pokeexpire == -1)
						peer_unref(peer);
					/* and finally send the ack */
					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
					/* And wrap up the qualify call */
					iax2_destroy(fr->callno);
					peer->callno = 0;
					ast_debug(1, "Peer %s: got pong, lastms %d, historicms %d, maxms %d\n", peer->name, peer->lastms, peer->historicms, peer->maxms);
				}
				break;
			case IAX_COMMAND_LAGRQ:
			case IAX_COMMAND_LAGRP:
				f.src = "LAGRQ";
				f.mallocd = 0;
				f.offset = 0;
				f.samples = 0;
				iax_frame_wrap(fr, &f);
				if (f.subclass.integer == IAX_COMMAND_LAGRQ) {
					/* Received a LAGRQ - echo back a LAGRP */
					fr->af.subclass.integer = IAX_COMMAND_LAGRP;
					iax2_send(iaxs[fr->callno], &fr->af, fr->ts, -1, 0, 0, 0);
				} else {
					/* Received LAGRP in response to our LAGRQ */
					unsigned int ts;
					/* This is a reply we've been given, actually measure the difference */
					ts = calc_timestamp(iaxs[fr->callno], 0, &fr->af);
					iaxs[fr->callno]->lag = ts - fr->ts;
					if (iaxdebug)
						ast_debug(1, "Peer %s lag measured as %dms\n",
							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->lag);
				}
				break;
			case IAX_COMMAND_AUTHREQ:
				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)) {
					ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");
					break;
				}
				if (authenticate_reply(iaxs[fr->callno], &iaxs[fr->callno]->addr, &ies, iaxs[fr->callno]->secret, iaxs[fr->callno]->outkey)) {
					struct ast_frame hangup_fr = { .frametype = AST_FRAME_CONTROL,
								.subclass.integer = AST_CONTROL_HANGUP,
					};
					ast_log(LOG_WARNING, 
						"I don't know how to authenticate %s to %s\n", 
						ies.username ? ies.username : "<unknown>", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr));
					iax2_queue_frame(fr->callno, &hangup_fr);
				}
				break;
			case IAX_COMMAND_AUTHREP:
				/* For security, always ack immediately */
				if (delayreject)
					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
				/* Ignore once we've started */
				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)) {
					ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");
					break;
				}
				if (authenticate_verify(iaxs[fr->callno], &ies)) {
					if (authdebug)
						ast_log(LOG_NOTICE, "Host %s failed to authenticate as %s\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->username);
					memset(&ied0, 0, sizeof(ied0));
					auth_fail(fr->callno, IAX_COMMAND_REJECT);
					break;
				}
				if (strcasecmp(iaxs[fr->callno]->exten, "TBD")) {
					/* This might re-enter the IAX code and need the lock */
					exists = ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num);
				} else
					exists = 0;
				if (strcmp(iaxs[fr->callno]->exten, "TBD") && !exists) {
					if (authdebug)
						ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);
					memset(&ied0, 0, sizeof(ied0));
					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");
					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);
					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);
					if (!iaxs[fr->callno]) {
						break;
					}
				} else {
					/* Select an appropriate format */
					if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {
						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {
							using_prefs = "reqonly";
						} else {
							using_prefs = "disabled";
						}
						format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;
						memset(&pref, 0, sizeof(pref));
						strcpy(caller_pref_buf, "disabled");
						strcpy(host_pref_buf, "disabled");
					} else {
						struct ast_format tmpfmt;
						using_prefs = "mine";
						if (ies.codec_prefs)
							ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);
						if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {
							if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {
								pref = iaxs[fr->callno]->rprefs;
								using_prefs = "caller";
							} else {
								pref = iaxs[fr->callno]->prefs;
							}
						} else /* if no codec_prefs IE do it the old way */
							pref = iaxs[fr->callno]->prefs;
						format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);
						ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);
						ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);
					}
					if (!format) {
						char tmp1[256], tmp2[256], tmp3[256];
						if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {
							ast_debug(1, "We don't do requested format %s, falling back to peer capability '%s'\n",
								iax2_getformatname(iaxs[fr->callno]->peerformat),
								iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability));
							format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;
						}
						if (!format) {
							if (authdebug) {
								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {
									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n", ast_inet_ntoa(sin.sin_addr),
										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),
										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));
								} else {
									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",
										ast_inet_ntoa(sin.sin_addr),
										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),
										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),
										iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));
								}
							}
							memset(&ied0, 0, sizeof(ied0));
							iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");
							iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);
							send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);
							if (!iaxs[fr->callno]) {
								break;
							}
						} else {
							/* Pick one... */
							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {
								if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))
									format = 0;
							} else {
								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {
									using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";
									memset(&pref, 0, sizeof(pref));
									format = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ?
										iaxs[fr->callno]->peerformat : iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);
									strcpy(caller_pref_buf,"disabled");
									strcpy(host_pref_buf,"disabled");
								} else {
									struct ast_format tmpfmt;
									using_prefs = "mine";
									if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {
										/* Do the opposite of what we tried above. */
										if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {
											pref = iaxs[fr->callno]->prefs;
										} else {
											pref = iaxs[fr->callno]->rprefs;
											using_prefs = "caller";
										}
										format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);
									} else /* if no codec_prefs IE do it the old way */
										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);	
								}
							}
							if (!format) {
								char tmp1[256], tmp2[256], tmp3[256];
								ast_log(LOG_ERROR, "No best format in %s???\n",
									iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));
								if (authdebug) {
									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {
										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",
											ast_inet_ntoa(sin.sin_addr),
											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),
											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));
									} else {
										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",
											ast_inet_ntoa(sin.sin_addr),
											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),
											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),
											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));
									}
								}
								memset(&ied0, 0, sizeof(ied0));
								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");
								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);
								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);
								if (!iaxs[fr->callno]) {
									break;
								}
							}
						}
					}
					if (format) {
						/* Authentication received */
						memset(&ied1, 0, sizeof(ied1));
						iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);
						iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);
						send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);
						if (strcmp(iaxs[fr->callno]->exten, "TBD")) {
							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);
							ast_verb(3, "Accepting AUTHENTICATED call from %s:\n"
											"%srequested format = %s,\n"
											"%srequested prefs = %s,\n"
											"%sactual format = %s,\n"
											"%shost prefs = %s,\n"
											"%spriority = %s\n", 
											ast_inet_ntoa(sin.sin_addr), 
											VERBOSE_PREFIX_4,
											iax2_getformatname(iaxs[fr->callno]->peerformat),
											VERBOSE_PREFIX_4,
											caller_pref_buf,
											VERBOSE_PREFIX_4,
											iax2_getformatname(format),
											VERBOSE_PREFIX_4,
											host_pref_buf,
											VERBOSE_PREFIX_4,
											using_prefs);

							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);
							if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, format, NULL)))
								iax2_destroy(fr->callno);
							else if (ies.vars) {
								struct ast_datastore *variablestore;
								struct ast_variable *var, *prev = NULL;
								AST_LIST_HEAD(, ast_var_t) *varlist;
								varlist = ast_calloc(1, sizeof(*varlist));
								variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);
								if (variablestore && varlist) {
									variablestore->data = varlist;
									variablestore->inheritance = DATASTORE_INHERIT_FOREVER;
									AST_LIST_HEAD_INIT(varlist);
									ast_debug(1, "I can haz IAX vars? w00t\n");
									for (var = ies.vars; var; var = var->next) {
										struct ast_var_t *newvar = ast_var_assign(var->name, var->value);
										if (prev)
											ast_free(prev);
										prev = var;
										if (!newvar) {
											/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */
											ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");
										} else {
											AST_LIST_INSERT_TAIL(varlist, newvar, entries);
										}
									}
									if (prev)
										ast_free(prev);
									ies.vars = NULL;
									ast_channel_datastore_add(c, variablestore);
								} else {
									ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");
									if (variablestore)
										ast_datastore_free(variablestore);
									if (varlist)
										ast_free(varlist);
								}
							}
						} else {
							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);
							/* If this is a TBD call, we're ready but now what...  */
							ast_verb(3, "Accepted AUTHENTICATED TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));
							if (ast_test_flag64(iaxs[fr->callno], IAX_IMMEDIATE)) {
								goto immediatedial;
							}
						}
					}
				}
				break;
			case IAX_COMMAND_DIAL:
immediatedial:
				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD)) {
					ast_clear_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);
					ast_string_field_set(iaxs[fr->callno], exten, ies.called_number ? ies.called_number : "s");
					if (!ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num)) {
						if (authdebug)
							ast_log(LOG_NOTICE, "Rejected dial attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);
						memset(&ied0, 0, sizeof(ied0));
						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");
						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);
						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);
						if (!iaxs[fr->callno]) {
							break;
						}
					} else {
						char tmp[256];
						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);
						ast_verb(3, "Accepting DIAL from %s, formats = %s\n",
							ast_inet_ntoa(sin.sin_addr),
							iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat));
						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);
						send_command(iaxs[fr->callno], AST_FRAME_CONTROL, AST_CONTROL_PROGRESS, 0, NULL, 0, -1);
						if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->peerformat, NULL)))
							iax2_destroy(fr->callno);
						else if (ies.vars) {
							struct ast_datastore *variablestore;
							struct ast_variable *var, *prev = NULL;
							AST_LIST_HEAD(, ast_var_t) *varlist;
							varlist = ast_calloc(1, sizeof(*varlist));
							variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);
							ast_debug(1, "I can haz IAX vars? w00t\n");
							if (variablestore && varlist) {
								variablestore->data = varlist;
								variablestore->inheritance = DATASTORE_INHERIT_FOREVER;
								AST_LIST_HEAD_INIT(varlist);
								for (var = ies.vars; var; var = var->next) {
									struct ast_var_t *newvar = ast_var_assign(var->name, var->value);
									if (prev)
										ast_free(prev);
									prev = var;
									if (!newvar) {
										/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */
										ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");
									} else {
										AST_LIST_INSERT_TAIL(varlist, newvar, entries);
									}
								}
								if (prev)
									ast_free(prev);
								ies.vars = NULL;
								ast_channel_datastore_add(c, variablestore);
							} else {
								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");
								if (variablestore)
									ast_datastore_free(variablestore);
								if (varlist)
									ast_free(varlist);
							}
						}
					}
				}
				break;
			case IAX_COMMAND_INVAL:
				iaxs[fr->callno]->error = ENOTCONN;
				ast_debug(1, "Immediately destroying %d, having received INVAL\n", fr->callno);
				iax2_destroy(fr->callno);
				ast_debug(1, "Destroying call %d\n", fr->callno);
				break;
			case IAX_COMMAND_VNAK:
				ast_debug(1, "Received VNAK: resending outstanding frames\n");
				/* Force retransmission */
				vnak_retransmit(fr->callno, fr->iseqno);
				break;
			case IAX_COMMAND_REGREQ:
			case IAX_COMMAND_REGREL:
				/* For security, always ack immediately */
				if (delayreject)
					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
				if (register_verify(fr->callno, &sin, &ies)) {
					if (!iaxs[fr->callno]) {
						break;
					}
					/* Send delayed failure */
					auth_fail(fr->callno, IAX_COMMAND_REGREJ);
					break;
				}
				if (!iaxs[fr->callno]) {
					break;
				}
				if ((ast_strlen_zero(iaxs[fr->callno]->secret) && ast_strlen_zero(iaxs[fr->callno]->inkeys)) ||
						ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED)) {

					if (f.subclass.integer == IAX_COMMAND_REGREL) {
						memset(&sin, 0, sizeof(sin));
						sin.sin_family = AF_INET;
					}
					if (update_registry(&sin, fr->callno, ies.devicetype, fd, ies.refresh)) {
						ast_log(LOG_WARNING, "Registry error\n");
					}
					if (!iaxs[fr->callno]) {
						break;
					}
					if (ies.provverpres && ies.serviceident && sin.sin_addr.s_addr) {
						ast_mutex_unlock(&iaxsl[fr->callno]);
						check_provisioning(&sin, fd, ies.serviceident, ies.provver);
						ast_mutex_lock(&iaxsl[fr->callno]);
					}
					break;
				}
				registry_authrequest(fr->callno);
				break;
			case IAX_COMMAND_REGACK:
				if (iax2_ack_registry(&ies, &sin, fr->callno)) 
					ast_log(LOG_WARNING, "Registration failure\n");
				/* Send ack immediately, before we destroy */
				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
				iax2_destroy(fr->callno);
				break;
			case IAX_COMMAND_REGREJ:
				if (iaxs[fr->callno]->reg) {
					if (authdebug) {
						ast_log(LOG_NOTICE, "Registration of '%s' rejected: '%s' from: '%s'\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>", ast_inet_ntoa(sin.sin_addr));
						manager_event(EVENT_FLAG_SYSTEM, "Registry", "ChannelType: IAX2\r\nUsername: %s\r\nStatus: Rejected\r\nCause: %s\r\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>");
					}
					iaxs[fr->callno]->reg->regstate = REG_STATE_REJECTED;
				}
				/* Send ack immediately, before we destroy */
				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
				iax2_destroy(fr->callno);
				break;
			case IAX_COMMAND_REGAUTH:
				/* Authentication request */
				if (registry_rerequest(&ies, fr->callno, &sin)) {
					memset(&ied0, 0, sizeof(ied0));
					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No authority found");
					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_FACILITY_NOT_SUBSCRIBED);
					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);
				}
				break;
			case IAX_COMMAND_TXREJ:
				iaxs[fr->callno]->transferring = 0;
				ast_verb(3, "Channel '%s' unable to transfer\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");
				memset(&iaxs[fr->callno]->transfer, 0, sizeof(iaxs[fr->callno]->transfer));
				if (iaxs[fr->callno]->bridgecallno) {
					if (iaxs[iaxs[fr->callno]->bridgecallno]->transferring) {
						iaxs[iaxs[fr->callno]->bridgecallno]->transferring = 0;
						send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREJ, 0, NULL, 0, -1);
					}
				}
				break;
			case IAX_COMMAND_TXREADY:
				if ((iaxs[fr->callno]->transferring == TRANSFER_BEGIN) ||
				    (iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)) {
					if (iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)
						iaxs[fr->callno]->transferring = TRANSFER_MREADY;
					else
						iaxs[fr->callno]->transferring = TRANSFER_READY;
					ast_verb(3, "Channel '%s' ready to transfer\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");
					if (iaxs[fr->callno]->bridgecallno) {
						if ((iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_READY) ||
						    (iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_MREADY)) {
							/* They're both ready, now release them. */
							if (iaxs[fr->callno]->transferring == TRANSFER_MREADY) {
								ast_verb(3, "Attempting media bridge of %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",
										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");

								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_MEDIA;
								iaxs[fr->callno]->transferring = TRANSFER_MEDIA;

								memset(&ied0, 0, sizeof(ied0));
								memset(&ied1, 0, sizeof(ied1));
								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);
								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);
								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied0.buf, ied0.pos, -1);
								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied1.buf, ied1.pos, -1);
							} else {
								ast_verb(3, "Releasing %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",
										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");

								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_RELEASED;
								iaxs[fr->callno]->transferring = TRANSFER_RELEASED;
								ast_set_flag64(iaxs[iaxs[fr->callno]->bridgecallno], IAX_ALREADYGONE);
								ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);

								/* Stop doing lag & ping requests */
								stop_stuff(fr->callno);
								stop_stuff(iaxs[fr->callno]->bridgecallno);

								memset(&ied0, 0, sizeof(ied0));
								memset(&ied1, 0, sizeof(ied1));
								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);
								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);
								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied0.buf, ied0.pos, -1);
								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied1.buf, ied1.pos, -1);
							}

						}
					}
				}
				break;
			case IAX_COMMAND_TXREQ:
				try_transfer(iaxs[fr->callno], &ies);
				break;
			case IAX_COMMAND_TXCNT:
				if (iaxs[fr->callno]->transferring)
					send_command_transfer(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXACC, 0, NULL, 0);
				break;
			case IAX_COMMAND_TXREL:
				/* Send ack immediately, rather than waiting until we've changed addresses */
				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
				complete_transfer(fr->callno, &ies);
				stop_stuff(fr->callno);	/* for attended transfer to work with libiax */
				break;	
			case IAX_COMMAND_TXMEDIA:
				if (iaxs[fr->callno]->transferring == TRANSFER_READY) {
					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {
						/* Cancel any outstanding frames and start anew */
						if (cur->transfer) {
							cur->retries = -1;
						}
					}
					/* Start sending our media to the transfer address, but otherwise leave the call as-is */
					iaxs[fr->callno]->transferring = TRANSFER_MEDIAPASS;
				}
				break;
			case IAX_COMMAND_RTKEY:
				if (!IAX_CALLENCRYPTED(iaxs[fr->callno])) {
					ast_log(LOG_WARNING, 
						"we've been told to rotate our encryption key, "
						"but this isn't an encrypted call. bad things will happen.\n"
					);
					break;
				}

				IAX_DEBUGDIGEST("Receiving", ies.challenge);

				ast_aes_set_decrypt_key((unsigned char *) ies.challenge, &iaxs[fr->callno]->dcx);
				break;
			case IAX_COMMAND_DPREP:
				complete_dpreply(iaxs[fr->callno], &ies);
				break;
			case IAX_COMMAND_UNSUPPORT:
				ast_log(LOG_NOTICE, "Peer did not understand our iax command '%d'\n", ies.iax_unknown);
				break;
			case IAX_COMMAND_FWDOWNL:
				/* Firmware download */
				if (!ast_test_flag64(&globalflags, IAX_ALLOWFWDOWNLOAD)) {
					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_UNSUPPORT, 0, NULL, 0, -1);
					break;
				}
				memset(&ied0, 0, sizeof(ied0));
				res = iax_firmware_append(&ied0, (unsigned char *)ies.devicetype, ies.fwdesc);
				if (res < 0)
					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);
				else if (res > 0)
					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1);
				else
					send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1);
				break;
			case IAX_COMMAND_CALLTOKEN:
			{
				struct iax_frame *cur;
				/* find last sent frame */
				if ((cur = AST_LIST_LAST(&frame_queue[fr->callno])) && ies.calltoken && ies.calltokendata) {
					resend_with_token(fr->callno, cur, (char *) ies.calltokendata);
				}
				break;
			}
			default:
				ast_debug(1, "Unknown IAX command %d on %d/%d\n", f.subclass.integer, fr->callno, iaxs[fr->callno]->peercallno);
				memset(&ied0, 0, sizeof(ied0));
				iax_ie_append_byte(&ied0, IAX_IE_IAX_UNKNOWN, f.subclass.integer);
				send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_UNSUPPORT, 0, ied0.buf, ied0.pos, -1);
			}
			/* Free remote variables (if any) */
			if (ies.vars) {
				ast_variables_destroy(ies.vars);
				ast_debug(1, "I can haz IAX vars, but they is no good :-(\n");
				ies.vars = NULL;
			}

			/* Don't actually pass these frames along */
			if ((f.subclass.integer != IAX_COMMAND_ACK) &&
			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&
			  (f.subclass.integer != IAX_COMMAND_TXACC) &&
			  (f.subclass.integer != IAX_COMMAND_INVAL) &&
			  (f.subclass.integer != IAX_COMMAND_VNAK)) {
				if (iaxs[fr->callno] && iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno)
					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
			}
			ast_mutex_unlock(&iaxsl[fr->callno]);
			return 1;
		}
		/* Unless this is an ACK or INVAL frame, ack it */
		if (iaxs[fr->callno] && iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno)
			send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
	}
-----children-----
1,2
1,3
1,4
3,4
3,5
5,6
5,7
6,7
8,9
8,10
11,12
11,13
11,14
11,15
11,16
11,17
11,18
11,19
11,20
11,21
11,22
11,23
11,24
11,25
11,26
11,27
11,28
11,29
11,30
11,31
11,32
11,33
11,34
11,35
11,36
11,37
11,38
11,39
11,40
11,41
11,42
11,43
11,44
11,45
11,46
11,47
11,48
11,49
11,50
11,51
11,52
11,53
11,54
11,55
11,56
11,57
12,13
13,14
13,15
14,15
16,17
18,19
19,20
19,21
21,22
23,24
24,25
24,26
26,27
26,28
28,29
30,31
31,32
32,33
32,34
34,35
34,36
36,37
38,39
39,40
39,41
41,42
41,43
43,44
45,46
46,47
46,48
47,48
49,50
49,51
49,52
52,53
53,54
53,55
54,55
54,56
55,56
57,58
59,60
59,61
60,61
63,64
64,65
64,66
65,66
67,68
67,69
67,70
70,71
71,72
71,73
72,73
72,74
73,74
75,76
77,78
77,79
78,79
81,82
82,83
82,84
83,84
85,86
85,87
85,88
88,89
89,90
89,91
90,91
90,92
91,92
93,94
95,96
95,97
96,97
99,100
100,101
100,102
101,102
103,104
103,105
103,106
106,107
107,108
107,109
108,109
108,110
109,110
111,112
113,114
113,115
114,115
117,118
118,119
118,120
119,120
121,122
121,123
124,125
125,126
125,127
126,127
128,129
128,130
131,132
132,133
132,134
133,134
135,136
135,137
137,138
138,139
140,141
141,142
141,143
142,143
144,145
144,146
144,147
147,148
148,149
150,151
151,152
151,153
152,153
154,155
154,156
157,158
158,159
158,160
159,160
161,162
161,163
164,165
165,166
165,167
166,167
168,169
170,171
171,172
171,173
171,174
172,173
174,175
176,177
178,179
179,180
179,181
180,181
182,183
184,185
185,186
185,187
187,188
189,190
190,191
190,192
192,193
194,195
195,196
195,197
197,198
197,199
199,200
201,202
202,203
202,204
204,205
204,206
204,207
206,207
208,209
210,211
211,212
211,213
212,213
214,215
214,216
217,218
218,219
218,220
220,221
220,222
222,223
224,225
225,226
225,227
227,228
227,229
229,230
231,232
232,233
232,234
233,234
235,236
237,238
238,239
238,240
240,241
240,242
240,243
243,244
245,246
246,247
246,248
247,248
249,250
249,251
250,251
252,253
252,254
253,254
254,255
255,256
256,257
259,260
260,261
260,262
260,263
260,264
261,262
263,264
266,267
267,268
268,269
269,270
271,272
272,273
272,274
273,274
273,275
274,275
278,279
279,280
279,281
280,281
282,283
282,284
283,284
286,287
287,288
287,289
288,289
290,291
290,292
291,292
294,295
295,296
295,297
295,298
295,299
296,297
298,299
299,300
301,302
302,303
302,304
303,304
306,307
307,308
308,309
310,311
310,312
311,312
311,313
312,313
314,315
315,316
316,317
317,318
319,320
319,321
320,321
321,322
321,323
321,324
321,325
321,326
322,323
324,325
327,328
329,330
329,331
330,331
330,332
333,334
334,335
335,336
336,337
338,339
340,341
340,342
340,343
341,342
341,343
342,343
343,344
343,345
344,345
344,346
345,346
349,350
350,351
350,352
351,352
351,353
352,353
354,355
354,356
355,356
359,360
359,361
359,362
360,361
360,362
361,362
361,363
362,363
364,365
365,366
366,367
367,368
369,370
369,371
370,371
371,372
371,373
371,374
371,375
371,376
372,373
374,375
377,378
377,379
378,379
380,381
380,382
381,382
384,385
384,386
385,386
387,388
387,389
388,389
391,392
393,394
394,395
395,396
395,397
396,397
399,400
399,401
400,401
400,402
401,402
402,403
402,404
403,404
403,405
404,405
408,409
409,410
410,411
410,412
411,412
411,413
412,413
414,415
414,416
415,416
419,420
420,421
420,422
420,423
420,424
420,425
420,426
421,422
423,424
425,426
427,428
428,429
430,431
432,433
434,435
434,436
434,437
435,436
435,437
436,437
436,438
437,438
439,440
439,441
440,441
443,444
445,446
445,447
445,448
445,449
445,450
445,451
445,452
445,453
445,454
446,447
446,448
447,448
447,449
448,449
450,451
451,452
452,453
453,454
455,456
455,457
456,457
457,458
457,459
457,460
457,461
457,462
458,459
460,461
463,464
463,465
464,465
466,467
466,468
467,468
470,471
470,472
471,472
473,474
473,475
474,475
477,478
479,480
480,481
480,482
481,482
483,484
483,485
484,485
484,486
485,486
487,488
487,489
488,489
491,492
492,493
494,495
494,496
495,496
495,497
496,497
497,498
497,499
498,499
501,502
502,503
502,504
503,504
503,505
504,505
507,508
507,509
507,510
507,511
507,512
507,513
507,514
508,509
510,511
510,512
511,512
511,513
512,513
514,515
514,516
515,516
518,519
519,520
521,522
523,524
524,525
526,527
528,529
531,532
531,533
531,534
532,533
533,534
533,535
534,535
536,537
537,538
537,539
537,540
540,541
541,542
541,543
542,543
545,546
545,547
546,547
546,548
547,548
547,549
548,549
550,551
550,552
551,552
554,555
554,556
554,557
555,556
557,558
557,559
558,559
560,561
560,562
561,562
564,565
566,567
566,568
567,568
567,569
568,569
568,570
568,571
568,572
568,573
569,570
571,572
571,573
572,573
575,576
577,578
578,579
580,581
581,582
583,584
583,585
583,586
584,585
585,586
585,587
585,588
586,587
588,589
591,592
592,593
592,594
593,594
595,596
596,597
596,598
597,598
599,600
599,601
600,601
603,604
605,606
606,607
606,608
607,608
610,611
611,612
611,613
612,613
614,615
615,616
615,617
616,617
618,619
618,620
619,620
622,623
623,624
623,625
624,625
624,626
625,626
628,629
628,630
629,630
632,633
632,634
632,635
633,634
633,635
634,635
634,636
635,636
638,639
640,641
640,642
641,642
642,643
642,644
642,645
643,644
645,646
646,647
646,648
647,648
647,649
648,649
652,653
653,654
653,655
654,655
656,657
656,658
657,658
657,659
658,659
661,662
663,664
663,665
664,665
664,666
665,666
666,667
666,668
667,668
667,669
668,669
673,674
674,675
675,676
675,677
676,677
678,679
679,680
679,681
680,681
680,682
681,682
685,686
685,687
685,688
686,687
686,688
687,688
687,689
688,689
691,692
693,694
694,695
695,696
695,697
695,698
696,697
698,699
699,700
699,701
700,701
700,702
701,702
705,706
705,707
706,707
708,709
708,710
709,710
712,713
713,714
714,715
714,716
715,716
715,717
716,717
716,718
717,718
721,722
721,723
722,723
724,725
724,726
725,726
728,729
728,730
728,731
729,730
729,731
730,731
730,732
731,732
731,733
732,733
735,736
737,738
737,739
738,739
738,740
739,740
739,741
740,741
744,745
746,747
746,748
747,748
748,749
748,750
748,751
748,752
748,753
748,754
748,755
748,756
748,757
749,750
752,753
752,754
753,754
755,756
755,757
756,757
759,760
760,761
762,763
764,765
764,766
765,766
767,768
767,769
768,769
771,772
771,773
772,773
772,774
773,774
777,778
779,780
781,782
783,784
783,785
784,785
784,786
785,786
785,787
786,787
786,788
787,788
787,789
788,789
791,792
793,794
793,795
794,795
794,796
795,796
795,797
796,797
800,801
802,803
802,804
803,804
806,807
807,808
809,810
810,811
810,812
811,812
811,813
812,813
815,816
815,817
816,817
818,819
819,820
820,821
821,822
823,824
823,825
823,826
824,825
824,826
825,826
828,829
829,830
829,831
829,832
830,831
830,832
831,832
831,833
832,833
835,836
837,838
837,839
837,840
838,839
838,840
839,840
839,841
839,842
839,843
840,841
842,843
843,844
845,846
845,847
846,847
846,848
847,848
850,851
851,852
851,853
852,853
855,856
855,857
856,857
859,860
859,861
859,862
860,861
861,862
861,863
861,864
861,865
862,863
864,865
867,868
867,869
868,869
870,871
870,872
871,872
874,875
875,876
875,877
876,877
878,879
878,880
879,880
882,883
884,885
885,886
885,887
886,887
886,888
887,888
887,889
888,889
892,893
894,895
895,896
895,897
896,897
896,898
897,898
901,902
901,903
902,903
903,904
903,905
904,905
904,906
905,906
905,907
906,907
910,911
910,912
911,912
911,913
912,913
915,916
916,917
916,918
917,918
920,921
921,922
921,923
921,924
921,925
922,923
924,925
925,926
928,929
929,930
930,931
932,933
932,934
933,934
933,935
933,936
934,935
934,936
935,936
935,937
936,937
939,940
941,942
942,943
942,944
943,944
943,945
944,945
944,946
945,946
949,950
951,952
952,953
952,954
953,954
953,955
954,955
954,956
955,956
959,960
961,962
962,963
962,964
962,965
962,966
963,964
965,966
966,967
969,970
970,971
971,972
973,974
973,975
974,975
974,976
975,976
976,977
978,979
978,980
978,981
978,982
979,980
981,982
981,983
982,983
985,986
985,987
986,987
986,988
987,988
992,993
992,994
993,994
993,995
994,995
994,996
994,997
994,998
994,999
995,996
997,998
999,1000
1000,1001
1002,1003
1003,1004
1005,1006
1007,1008
1007,1009
1008,1009
1009,1010
1009,1011
1010,1011
1012,1013
1012,1014
1013,1014
1016,1017
1018,1019
1018,1020
1018,1021
1019,1020
1019,1021
1020,1021
1020,1022
1021,1022
1024,1025
1024,1026
1025,1026
1028,1029
1029,1030
1030,1031
1031,1032
1032,1033
1032,1034
1032,1035
1033,1034
1034,1035
1034,1036
1035,1036
1035,1037
1036,1037
1039,1040
1041,1042
1042,1043
1042,1044
1043,1044
1043,1045
1044,1045
1044,1046
1045,1046
1050,1051
1051,1052
1051,1053
1051,1054
1051,1055
1052,1053
1054,1055
1055,1056
1058,1059
1059,1060
1060,1061
1062,1063
1062,1064
1063,1064
1064,1065
1064,1066
1065,1066
1068,1069
1068,1070
1068,1071
1069,1070
1070,1071
1070,1072
1072,1073
1072,1074
1074,1075
1076,1077
1076,1078
1077,1078
1077,1079
1078,1079
1079,1080
1079,1081
1080,1081
1080,1082
1081,1082
1083,1084
1083,1085
1084,1085
1087,1088
1089,1090
1090,1091
1090,1092
1091,1092
1092,1093
1092,1094
1093,1094
1093,1095
1094,1095
1097,1098
1099,1100
1100,1101
1100,1102
1101,1102
1101,1103
1102,1103
1102,1104
1103,1104
1107,1108
1109,1110
1110,1111
1111,1112
1111,1113
1112,1113
1115,1116
1115,1117
1116,1117
1117,1118
1117,1119
1117,1120
1118,1119
1118,1120
1118,1121
1119,1120
1119,1121
1120,1121
1120,1122
1121,1122
1121,1123
1122,1123
1125,1126
1127,1128
1127,1129
1128,1129
1128,1130
1129,1130
1129,1131
1130,1131
1134,1135
1136,1137
1137,1138
1138,1139
1138,1140
1138,1141
1138,1142
1138,1143
1138,1144
1138,1145
1138,1146
1138,1147
1139,1140
1142,1143
1142,1144
1143,1144
1145,1146
1145,1147
1146,1147
1149,1150
1150,1151
1152,1153
1154,1155
1154,1156
1155,1156
1157,1158
1157,1159
1158,1159
1161,1162
1161,1163
1162,1163
1162,1164
1163,1164
1167,1168
1169,1170
1171,1172
1171,1173
1172,1173
1172,1174
1173,1174
1173,1175
1174,1175
1174,1176
1175,1176
1178,1179
1180,1181
1181,1182
1181,1183
1182,1183
1182,1184
1183,1184
1183,1185
1184,1185
1184,1186
1185,1186
1189,1190
1191,1192
1191,1193
1192,1193
1192,1194
1193,1194
1193,1195
1194,1195
1198,1199
1200,1201
1201,1202
1202,1203
1202,1204
1202,1205
1202,1206
1202,1207
1202,1208
1202,1209
1202,1210
1202,1211
1203,1204
1206,1207
1206,1208
1207,1208
1209,1210
1209,1211
1210,1211
1213,1214
1214,1215
1216,1217
1218,1219
1218,1220
1219,1220
1221,1222
1221,1223
1222,1223
1225,1226
1225,1227
1226,1227
1226,1228
1227,1228
1231,1232
1233,1234
1235,1236
1236,1237
1236,1238
1237,1238
1239,1240
1239,1241
1240,1241
1243,1244
1245,1246
1245,1247
1246,1247
1246,1248
1247,1248
1247,1249
1248,1249
1252,1253
1252,1254
1252,1255
1253,1254
1254,1255
1254,1256
1255,1256
1257,1258
1257,1259
1260,1261
1261,1262
1261,1263
1262,1263
1264,1265
1265,1266
1265,1267
1265,1268
1268,1269
1269,1270
1269,1271
1270,1271
1273,1274
1273,1275
1274,1275
1274,1276
1275,1276
1275,1277
1276,1277
1278,1279
1278,1280
1279,1280
1282,1283
1283,1284
1284,1285
1284,1286
1285,1286
1287,1288
1287,1289
1288,1289
1290,1291
1290,1292
1291,1292
1294,1295
1294,1296
1295,1296
1296,1297
1296,1298
1297,1298
1299,1300
1301,1302
1302,1303
1302,1304
1303,1304
1305,1306
1307,1308
1307,1309
1308,1309
1308,1310
1309,1310
1310,1311
1310,1312
1311,1312
1314,1315
1315,1316
1315,1317
1316,1317
1318,1319
1318,1320
1319,1320
1322,1323
1322,1324
1322,1325
1322,1326
1323,1324
1323,1325
1324,1325
1324,1326
1325,1326
1325,1327
1326,1327
1328,1329
1328,1330
1329,1330
1332,1333
1334,1335
1335,1336
1335,1337
1336,1337
1336,1338
1337,1338
1338,1339
1338,1340
1339,1340
1339,1341
1340,1341
1340,1342
1341,1342
1342,1343
1342,1344
1343,1344
1343,1345
1344,1345
1344,1346
1345,1346
1349,1350
1351,1352
1352,1353
1352,1354
1353,1354
1353,1355
1354,1355
1354,1356
1355,1356
1359,1360
1361,1362
1362,1363
1362,1364
1363,1364
1363,1365
1364,1365
1364,1366
1365,1366
1369,1370
1371,1372
1372,1373
1372,1374
1373,1374
1373,1375
1374,1375
1374,1376
1375,1376
1379,1380
1381,1382
1382,1383
1382,1384
1383,1384
1383,1385
1384,1385
1387,1388
1389,1390
1390,1391
1390,1392
1390,1393
1390,1394
1390,1395
1391,1392
1393,1394
1394,1395
1396,1397
1396,1398
1397,1398
1397,1399
1398,1399
1400,1401
1400,1402
1401,1402
1404,1405
1405,1406
1407,1408
1407,1409
1408,1409
1408,1410
1409,1410
1411,1412
1411,1413
1412,1413
1415,1416
1416,1417
1418,1419
1420,1421
1420,1422
1421,1422
1421,1423
1422,1423
1422,1424
1423,1424
1427,1428
1428,1429
1428,1430
1429,1430
1431,1432
1432,1433
1432,1434
1432,1435
1435,1436
1436,1437
1436,1438
1437,1438
1440,1441
1441,1442
1441,1443
1442,1443
1444,1445
1444,1446
1445,1446
1448,1449
1450,1451
1450,1452
1451,1452
1451,1453
1452,1453
1452,1454
1452,1455
1453,1454
1455,1456
1455,1457
1456,1457
1458,1459
1458,1460
1459,1460
1462,1463
1464,1465
1465,1466
1467,1468
1467,1469
1468,1469
1468,1470
1469,1470
1469,1471
1469,1472
1469,1473
1469,1474
1470,1471
1472,1473
1472,1474
1473,1474
1476,1477
1478,1479
1479,1480
1481,1482
1482,1483
1484,1485
1484,1486
1484,1487
1484,1488
1485,1486
1486,1487
1486,1488
1486,1489
1487,1488
1489,1490
1492,1493
1493,1494
1493,1495
1494,1495
1496,1497
1496,1498
1497,1498
1500,1501
1501,1502
1501,1503
1502,1503
1504,1505
1505,1506
1505,1507
1505,1508
1508,1509
1509,1510
1509,1511
1510,1511
1513,1514
1515,1516
1516,1517
1516,1518
1517,1518
1520,1521
1520,1522
1521,1522
1521,1523
1522,1523
1522,1524
1523,1524
1523,1525
1524,1525
1524,1526
1525,1526
1527,1528
1527,1529
1528,1529
1532,1533
1532,1534
1533,1534
1533,1535
1534,1535
1537,1538
1539,1540
1540,1541
1540,1542
1541,1542
1541,1543
1542,1543
1542,1544
1543,1544
1543,1545
1544,1545
1544,1546
1545,1546
1548,1549
1550,1551
1550,1552
1551,1552
1551,1553
1552,1553
1555,1556
1557,1558
1557,1559
1558,1559
1558,1560
1559,1560
1562,1563
1564,1565
1564,1566
1565,1566
1565,1567
1566,1567
1569,1570
1571,1572
1571,1573
1571,1574
1571,1575
1571,1576
1571,1577
1571,1578
1571,1579
1571,1580
1571,1581
1571,1582
1571,1583
1571,1584
1571,1585
1571,1586
1571,1587
1572,1573
1573,1574
1573,1575
1574,1575
1576,1577
1576,1578
1579,1580
1580,1581
1580,1582
1582,1583
1582,1584
1584,1585
1585,1586
1586,1587
1587,1588
1588,1589
1590,1591
1591,1592
1591,1593
1593,1594
1593,1595
1593,1596
1595,1596
1597,1598
1599,1600
1600,1601
1600,1602
1600,1603
1600,1604
1601,1602
1603,1604
1603,1605
1604,1605
1607,1608
1609,1610
1610,1611
1611,1612
1613,1614
1614,1615
1614,1616
1615,1616
1618,1619
1619,1620
1619,1621
1620,1621
1623,1624
1623,1625
1624,1625
1624,1626
1625,1626
1625,1627
1626,1627
1630,1631
1631,1632
1632,1633
1633,1634
1635,1636
1635,1637
1636,1637
1636,1638
1637,1638
1637,1639
1638,1639
1642,1643
1643,1644
1644,1645
1645,1646
1647,1648
1648,1649
1648,1650
1649,1650
1651,1652
1651,1653
1652,1653
1654,1655
1656,1657
1657,1658
1657,1659
1658,1659
1660,1661
1660,1662
1661,1662
1663,1664
1665,1666
1666,1667
1666,1668
1666,1669
1666,1670
1667,1668
1669,1670
1669,1671
1670,1671
1673,1674
1673,1675
1674,1675
1676,1677
1676,1678
1677,1678
1677,1679
1678,1679
1680,1681
1680,1682
1681,1682
1685,1686
1687,1688
1688,1689
1688,1690
1689,1690
1689,1691
1690,1691
1693,1694
1693,1695
1694,1695
1697,1698
1698,1699
1698,1700
1698,1701
1698,1702
1698,1703
1698,1704
1699,1700
1701,1702
1701,1703
1702,1703
1705,1706
1705,1707
1706,1707
1706,1708
1707,1708
1709,1710
1710,1711
1711,1712
1712,1713
1716,1717
1718,1719
1718,1720
1719,1720
1722,1723
1723,1724
1723,1725
1724,1725
1726,1727
1726,1728
1727,1728
1730,1731
1730,1732
1731,1732
1731,1733
1732,1733
1732,1734
1733,1734
1735,1736
1735,1737
1736,1737
1739,1740
1739,1741
1740,1741
1740,1742
1741,1742
1743,1744
1743,1745
1744,1745
1748,1749
1748,1750
1748,1751
1749,1750
1750,1751
1750,1752
1750,1753
1750,1754
1750,1755
1751,1752
1753,1754
1753,1755
1754,1755
1754,1756
1755,1756
1757,1758
1757,1759
1758,1759
1762,1763
1764,1765
1766,1767
1768,1769
1769,1770
1769,1771
1769,1772
1769,1773
1770,1771
1772,1773
1772,1774
1773,1774
1773,1775
1774,1775
1776,1777
1776,1778
1777,1778
1781,1782
1783,1784
1785,1786
1786,1787
1786,1788
1787,1788
1789,1790
1789,1791
1790,1791
1790,1792
1791,1792
1793,1794
1793,1795
1794,1795
1798,1799
1798,1800
1799,1800
1800,1801
1800,1802
1801,1802
1803,1804
1803,1805
1804,1805
1807,1808
1807,1809
1807,1810
1808,1809
1809,1810
1809,1811
1810,1811
1812,1813
1812,1814
1813,1814
1816,1817
1817,1818
1817,1819
1818,1819
1820,1821
1821,1822
1821,1823
1821,1824
1824,1825
1825,1826
1825,1827
1826,1827
1829,1830
1831,1832
1832,1833
1833,1834
1833,1835
1834,1835
1834,1836
1835,1836
1837,1838
1837,1839
1838,1839
1842,1843
1842,1844
1843,1844
1843,1845
1844,1845
1844,1846
1845,1846
1845,1847
1846,1847
1847,1848
1847,1849
1847,1850
1848,1849
1850,1851
1851,1852
1853,1854
1854,1855
1854,1856
1855,1856
1855,1857
1856,1857
1858,1859
1858,1860
1859,1860
1863,1864
1864,1865
1866,1867
1866,1868
1867,1868
1867,1869
1868,1869
1868,1870
1869,1870
1873,1874
1875,1876
1875,1877
1876,1877
1876,1878
1877,1878
1877,1879
1878,1879
1882,1883
1884,1885
1884,1886
1884,1887
1885,1886
1886,1887
1886,1888
1888,1889
1890,1891
1891,1892
1891,1893
1892,1893
1894,1895
1894,1896
1895,1896
1895,1897
1898,1899
1899,1900
1899,1901
1900,1901
1900,1902
1901,1902
1903,1904
1903,1905
1904,1905
1907,1908
1908,1909
1910,1911
1910,1912
1911,1912
1911,1913
1912,1913
1914,1915
1914,1916
1915,1916
1917,1918
1917,1919
1918,1919
1918,1920
1919,1920
1921,1922
1921,1923
1922,1923
1926,1927
1926,1928
1926,1929
1927,1928
1927,1929
1928,1929
1928,1930
1929,1930
1929,1931
1930,1931
1932,1933
1932,1934
1933,1934
1937,1938
1938,1939
1939,1940
1939,1941
1940,1941
1942,1943
1943,1944
1943,1945
1945,1946
1946,1947
1946,1948
1947,1948
1950,1951
1951,1952
1951,1953
1952,1953
1952,1954
1953,1954
1953,1955
1954,1955
1956,1957
1956,1958
1957,1958
1961,1962
1963,1964
1964,1965
1964,1966
1965,1966
1967,1968
1968,1969
1968,1970
1970,1971
1971,1972
1971,1973
1972,1973
1975,1976
1975,1977
1976,1977
1976,1978
1977,1978
1977,1979
1978,1979
1980,1981
1980,1982
1981,1982
1984,1985
1986,1987
1986,1988
1986,1989
1986,1990
1986,1991
1986,1992
1986,1993
1986,1994
1986,1995
1986,1996
1986,1997
1986,1998
1986,1999
1986,2000
1986,2001
1986,2002
1986,2003
1986,2004
1986,2005
1987,1988
1987,1989
1988,1989
1990,1991
1991,1992
1991,1993
1991,1994
1991,1995
1991,1996
1991,1997
1992,1993
1996,1997
1996,1998
1997,1998
2000,2001
2000,2002
2001,2002
2004,2005
2004,2006
2005,2006
2005,2007
2006,2007
2010,2011
2011,2012
2011,2013
2012,2013
2012,2014
2013,2014
2016,2017
2016,2018
2017,2018
2020,2021
2021,2022
2021,2023
2022,2023
2022,2024
2023,2024
2026,2027
2026,2028
2027,2028
2030,2031
2031,2032
2031,2033
2032,2033
2032,2034
2033,2034
2036,2037
2036,2038
2037,2038
2039,2040
2039,2041
2040,2041
2043,2044
2043,2045
2044,2045
2044,2046
2045,2046
2046,2047
2046,2048
2047,2048
2047,2049
2048,2049
2050,2051
2050,2052
2051,2052
2054,2055
2056,2057
2057,2058
2057,2059
2058,2059
2058,2060
2059,2060
2062,2063
2064,2065
2065,2066
2065,2067
2066,2067
2069,2070
2069,2071
2069,2072
2070,2071
2070,2072
2071,2072
2072,2073
2072,2074
2073,2074
2073,2075
2074,2075
2074,2076
2075,2076
2077,2078
2077,2079
2078,2079
2082,2083
2082,2084
2083,2084
2086,2087
2087,2088
2087,2089
2088,2089
2088,2090
2089,2090
2089,2091
2090,2091
2090,2092
2091,2092
2093,2094
2093,2095
2094,2095
2098,2099
2099,2100
2099,2101
2100,2101
2100,2102
2101,2102
2101,2103
2102,2103
2102,2104
2103,2104
2104,2105
2104,2106
2105,2106
2105,2107
2106,2107
2106,2108
2107,2108
2111,2112
2113,2114
2114,2115
2114,2116
2115,2116
2115,2117
2116,2117
2116,2118
2117,2118
2121,2122
2123,2124
2124,2125
2124,2126
2125,2126
2125,2127
2126,2127
2126,2128
2127,2128
2131,2132
2133,2134
2134,2135
2134,2136
2135,2136
2135,2137
2136,2137
2136,2138
2137,2138
2141,2142
2143,2144
2144,2145
2144,2146
2145,2146
2145,2147
2146,2147
2146,2148
2147,2148
2151,2152
2153,2154
2154,2155
2154,2156
2155,2156
2155,2157
2156,2157
2159,2160
2161,2162
2162,2163
2162,2164
2163,2164
2163,2165
2164,2165
2165,2166
2165,2167
2166,2167
2166,2168
2167,2168
2167,2169
2168,2169
2168,2170
2169,2170
2169,2171
2170,2171
2170,2172
2171,2172
2171,2173
2172,2173
2173,2174
2173,2175
2174,2175
2174,2176
2175,2176
2175,2177
2176,2177
2180,2181
2182,2183
2183,2184
2183,2185
2184,2185
2184,2186
2185,2186
2185,2187
2186,2187
2190,2191
2192,2193
2193,2194
2193,2195
2194,2195
2194,2196
2195,2196
2195,2197
2196,2197
2200,2201
2202,2203
2203,2204
2203,2205
2204,2205
2204,2206
2205,2206
2205,2207
2206,2207
2210,2211
2212,2213
2213,2214
2213,2215
2214,2215
2214,2216
2215,2216
2215,2217
2216,2217
2220,2221
2222,2223
2223,2224
2223,2225
2224,2225
2224,2226
2225,2226
2225,2227
2226,2227
2230,2231
2232,2233
2233,2234
2233,2235
2234,2235
2234,2236
2235,2236
2235,2237
2236,2237
2240,2241
2242,2243
2243,2244
2243,2245
2244,2245
2244,2246
2245,2246
2245,2247
2246,2247
2250,2251
2252,2253
2253,2254
2253,2255
2254,2255
2254,2256
2255,2256
2258,2259
2260,2261
2260,2262
2260,2263
2260,2264
2260,2265
2261,2262
2262,2263
2262,2264
2262,2265
2262,2266
2262,2267
2262,2268
2262,2269
2263,2264
2267,2268
2267,2269
2268,2269
2268,2270
2269,2270
2271,2272
2271,2273
2272,2273
2276,2277
2276,2278
2277,2278
2280,2281
2280,2282
2281,2282
2284,2285
2284,2286
2285,2286
2285,2287
2286,2287
2290,2291
2290,2292
2290,2293
2291,2292
2291,2293
2292,2293
2292,2294
2293,2294
2293,2295
2296,2297
2297,2298
2297,2299
2298,2299
2298,2300
2299,2300
2299,2301
2300,2301
2302,2303
2302,2304
2303,2304
2307,2308
2307,2309
2308,2309
2312,2313
2313,2314
2313,2315
2314,2315
2314,2316
2315,2316
2316,2317
2316,2318
2317,2318
2317,2319
2318,2319
2321,2322
2323,2324
2324,2325
2324,2326
2325,2326
2326,2327
2326,2328
2327,2328
2327,2329
2328,2329
2328,2330
2329,2330
2333,2334
2335,2336
2336,2337
2336,2338
2337,2338
2337,2339
2338,2339
2338,2340
2339,2340
2343,2344
2345,2346
2345,2347
2346,2347
2347,2348
2347,2349
2347,2350
2348,2349
2352,2353
2353,2354
2353,2355
2353,2356
2353,2357
2353,2358
2353,2359
2353,2360
2353,2361
2354,2355
2356,2357
2356,2358
2357,2358
2359,2360
2359,2361
2360,2361
2363,2364
2365,2366
2367,2368
2367,2369
2368,2369
2371,2372
2374,2375
2374,2376
2375,2376
2378,2379
2379,2380
2380,2381
2380,2382
2381,2382
2383,2384
2383,2385
2384,2385
2387,2388
2388,2389
2388,2390
2389,2390
2391,2392
2391,2393
2392,2393
2395,2396
2396,2397
2396,2398
2397,2398
2399,2400
2400,2401
2400,2402
2400,2403
2403,2404
2404,2405
2404,2406
2405,2406
2408,2409
2410,2411
2411,2412
2411,2413
2412,2413
2412,2414
2413,2414
2414,2415
2414,2416
2415,2416
2415,2417
2416,2417
2416,2418
2417,2418
2417,2419
2418,2419
2419,2420
2419,2421
2420,2421
2420,2422
2421,2422
2421,2423
2422,2423
2426,2427
2428,2429
2429,2430
2429,2431
2430,2431
2430,2432
2431,2432
2431,2433
2432,2433
2436,2437
2438,2439
2439,2440
2439,2441
2440,2441
2440,2442
2441,2442
2441,2443
2442,2443
2446,2447
2448,2449
2449,2450
2449,2451
2450,2451
2450,2452
2451,2452
2451,2453
2452,2453
2456,2457
2458,2459
2459,2460
2459,2461
2460,2461
2460,2462
2461,2462
2461,2463
2462,2463
2466,2467
2468,2469
2469,2470
2469,2471
2470,2471
2470,2472
2471,2472
2474,2475
2476,2477
2477,2478
2478,2479
2478,2480
2479,2480
2479,2481
2480,2481
2482,2483
2482,2484
2483,2484
2487,2488
2487,2489
2488,2489
2488,2490
2489,2490
2489,2491
2490,2491
2490,2492
2491,2492
2494,2495
2496,2497
2496,2498
2497,2498
2497,2499
2498,2499
2498,2500
2499,2500
2502,2503
2502,2504
2503,2504
2507,2508
2508,2509
2508,2510
2508,2511
2509,2510
2509,2511
2510,2511
2512,2513
2512,2514
2513,2514
2516,2517
2517,2518
2517,2519
2518,2519
2518,2520
2519,2520
2519,2521
2520,2521
2523,2524
2524,2525
2527,2528
2528,2529
2528,2530
2529,2530
2529,2531
2530,2531
2530,2532
2531,2532
2534,2535
2534,2536
2535,2536
2539,2540
2539,2541
2540,2541
2540,2542
2541,2542
2542,2543
2542,2544
2542,2545
2543,2544
2545,2546
2546,2547
2548,2549
2549,2550
2549,2551
2550,2551
2550,2552
2551,2552
2553,2554
2553,2555
2554,2555
2558,2559
2559,2560
2559,2561
2560,2561
2561,2562
2561,2563
2562,2563
2562,2564
2563,2564
2563,2565
2564,2565
2568,2569
2570,2571
2571,2572
2571,2573
2572,2573
2572,2574
2573,2574
2576,2577
2578,2579
2578,2580
2578,2581
2578,2582
2579,2580
2580,2581
2580,2582
2582,2583
2584,2585
2585,2586
2585,2587
2587,2588
2589,2590
2589,2591
2589,2592
2590,2591
2590,2592
2591,2592
2591,2593
2592,2593
2592,2594
2593,2594
2593,2595
2594,2595
2596,2597
2596,2598
2597,2598
2601,2602
2601,2603
2602,2603
2602,2604
2603,2604
2605,2606
2605,2607
2606,2607
2610,2611
2611,2612
2611,2613
2612,2613
2612,2614
2613,2614
2613,2615
2614,2615
2617,2618
2617,2619
2618,2619
2618,2620
2619,2620
2621,2622
2621,2623
2622,2623
2626,2627
2626,2628
2627,2628
2627,2629
2628,2629
2631,2632
2631,2633
2632,2633
2632,2634
2633,2634
2635,2636
2635,2637
2636,2637
2640,2641
2641,2642
2641,2643
2642,2643
2644,2645
2644,2646
2645,2646
2648,2649
2649,2650
2649,2651
2650,2651
2652,2653
2652,2654
2653,2654
2653,2655
2654,2655
2656,2657
2656,2658
2657,2658
2661,2662
2661,2663
2661,2664
2662,2663
2662,2664
2663,2664
2664,2665
2664,2666
2665,2666
2667,2668
2667,2669
2668,2669
2668,2670
2669,2670
2671,2672
2671,2673
2672,2673
2676,2677
2677,2678
2677,2679
2678,2679
2678,2680
2679,2680
2679,2681
2680,2681
2682,2683
2682,2684
2683,2684
2687,2688
2687,2689
2688,2689
2691,2692
2691,2693
2692,2693
2692,2694
2692,2695
2692,2696
2693,2694
2694,2695
2694,2696
2695,2696
2697,2698
2697,2699
2698,2699
2698,2700
2699,2700
2701,2702
2701,2703
2702,2703
2706,2707
2706,2708
2707,2708
2709,2710
2709,2711
2710,2711
2713,2714
2714,2715
2716,2717
2716,2718
2716,2719
2716,2720
2716,2721
2716,2722
2717,2718
2717,2719
2718,2719
2720,2721
2721,2722
2721,2723
2721,2724
2721,2725
2722,2723
2726,2727
2728,2729
2729,2730
2729,2731
2730,2731
2733,2734
2734,2735
2734,2736
2734,2737
2734,2738
2735,2736
2737,2738
2738,2739
2738,2740
2739,2740
2741,2742
2741,2743
2742,2743
2745,2746
2747,2748
2749,2750
2750,2751
2751,2752
2751,2753
2752,2753
2752,2754
2753,2754
2755,2756
2755,2757
2756,2757
2759,2760
2759,2761
2760,2761
2761,2762
2761,2763
2762,2763
2762,2764
2763,2764
2766,2767
2768,2769
2768,2770
2769,2770
2769,2771
2770,2771
2773,2774
2774,2775
2774,2776
2775,2776
2777,2778
2777,2779
2778,2779
2781,2782
2781,2783
2782,2783
2784,2785
2784,2786
2784,2787
2784,2788
2785,2786
2785,2787
2786,2787
2788,2789
2789,2790
2789,2791
2789,2792
2789,2793
2790,2791
2794,2795
2796,2797
2797,2798
2797,2799
2798,2799
2800,2801
2801,2802
2801,2803
2801,2804
2804,2805
2805,2806
2807,2808
2808,2809
2808,2810
2809,2810
2811,2812
2813,2814
2814,2815
2814,2816
2815,2816
2817,2818
2818,2819
2818,2820
2819,2820
2821,2822
2823,2824
2823,2825
2823,2826
2824,2825
2824,2826
2825,2826
2827,2828
2827,2829
2828,2829
2831,2832
2832,2833
2832,2834
2833,2834
2833,2835
2834,2835
2834,2836
2835,2836
2837,2838
2837,2839
2838,2839
2842,2843
2842,2844
2843,2844
2846,2847
2846,2848
2846,2849
2847,2848
2848,2849
2848,2850
2849,2850
2851,2852
2851,2853
2852,2853
2855,2856
2856,2857
2856,2858
2857,2858
2859,2860
2860,2861
2860,2862
2860,2863
2863,2864
2864,2865
2864,2866
2865,2866
2868,2869
2870,2871
2871,2872
2872,2873
2872,2874
2872,2875
2872,2876
2872,2877
2872,2878
2873,2874
2877,2878
2877,2879
2878,2879
2881,2882
2881,2883
2882,2883
2882,2884
2883,2884
2885,2886
2885,2887
2886,2887
2890,2891
2890,2892
2891,2892
2891,2893
2892,2893
2894,2895
2894,2896
2895,2896
2899,2900
2899,2901
2900,2901
2900,2902
2901,2902
2901,2903
2901,2904
2902,2903
2904,2905
2905,2906
2907,2908
2908,2909
2908,2910
2909,2910
2909,2911
2910,2911
2912,2913
2912,2914
2913,2914
2917,2918
2918,2919
2918,2920
2919,2920
2920,2921
2920,2922
2921,2922
2921,2923
2922,2923
2925,2926
2927,2928
2928,2929
2928,2930
2929,2930
2930,2931
2930,2932
2931,2932
2931,2933
2932,2933
2932,2934
2933,2934
2937,2938
2939,2940
2940,2941
2940,2942
2941,2942
2941,2943
2942,2943
2942,2944
2943,2944
2947,2948
2949,2950
2949,2951
2949,2952
2950,2951
2951,2952
2951,2953
2952,2953
2954,2955
2954,2956
2955,2956
2958,2959
2959,2960
2959,2961
2960,2961
2962,2963
2963,2964
2963,2965
2963,2966
2966,2967
2967,2968
2967,2969
2968,2969
2971,2972
2973,2974
2973,2975
2974,2975
2974,2976
2975,2976
2975,2977
2976,2977
2977,2978
2977,2979
2978,2979
2978,2980
2979,2980
2982,2983
2984,2985
2985,2986
2985,2987
2986,2987
2986,2988
2987,2988
2990,2991
2992,2993
2993,2994
2993,2995
2994,2995
2994,2996
2995,2996
2998,2999
3000,3001
3000,3002
3000,3003
3001,3002
3001,3003
3002,3003
3002,3004
3002,3005
3003,3004
3005,3006
3005,3007
3006,3007
3008,3009
3008,3010
3009,3010
3012,3013
3014,3015
3014,3016
3015,3016
3016,3017
3016,3018
3016,3019
3017,3018
3019,3020
3019,3021
3020,3021
3022,3023
3022,3024
3023,3024
3026,3027
3028,3029
3028,3030
3029,3030
3030,3031
3030,3032
3030,3033
3030,3034
3030,3035
3031,3032
3033,3034
3033,3035
3034,3035
3037,3038
3039,3040
3039,3041
3040,3041
3040,3042
3041,3042
3043,3044
3043,3045
3044,3045
3048,3049
3050,3051
3050,3052
3050,3053
3051,3052
3052,3053
3052,3054
3053,3054
3055,3056
3055,3057
3056,3057
3059,3060
3060,3061
3060,3062
3061,3062
3063,3064
3064,3065
3064,3066
3064,3067
3067,3068
3068,3069
3068,3070
3069,3070
3072,3073
3074,3075
3074,3076
3075,3076
3075,3077
3076,3077
3079,3080
3079,3081
3079,3082
3079,3083
3079,3084
3079,3085
3080,3081
3081,3082
3081,3083
3082,3083
3084,3085
3084,3086
3084,3087
3087,3088
3088,3089
3090,3091
3091,3092
3091,3093
3091,3094
3092,3093
3094,3095
3094,3096
3097,3098
3097,3099
3097,3100
3100,3101
3101,3102
3103,3104
3104,3105
3105,3106
3105,3107
3106,3107
3108,3109
3108,3110
3109,3110
3112,3113
3112,3114
3113,3114
3114,3115
3114,3116
3115,3116
3117,3118
3117,3119
3118,3119
3121,3122
3121,3123
3121,3124
3122,3123
3123,3124
3123,3125
3124,3125
3126,3127
3126,3128
3127,3128
3130,3131
3131,3132
3131,3133
3132,3133
3134,3135
3135,3136
3135,3137
3135,3138
3138,3139
3139,3140
3139,3141
3140,3141
3143,3144
3145,3146
3145,3147
3145,3148
3146,3147
3147,3148
3147,3149
3148,3149
3150,3151
3150,3152
3151,3152
3151,3153
3152,3153
3154,3155
3154,3156
3155,3156
3159,3160
3159,3161
3159,3162
3159,3163
3160,3161
3161,3162
3161,3163
3162,3163
3164,3165
3164,3166
3164,3167
3165,3166
3168,3169
3169,3170
3170,3171
3171,3172
3173,3174
3174,3175
3174,3176
3175,3176
3177,3178
3177,3179
3177,3180
3178,3179
3180,3181
3181,3182
3183,3184
3185,3186
3185,3187
3185,3188
3186,3187
3186,3188
3187,3188
3189,3190
3191,3192
3191,3193
3191,3194
3191,3195
3191,3196
3191,3197
3191,3198
3191,3199
3192,3193
3193,3194
3193,3195
3194,3195
3194,3196
3195,3196
3198,3199
3200,3201
3201,3202
3201,3203
3202,3203
3202,3204
3203,3204
3206,3207
3208,3209
3209,3210
3209,3211
3210,3211
3212,3213
3213,3214
3215,3216
3216,3217
3216,3218
3216,3219
3217,3218
3221,3222
3221,3223
3221,3224
3221,3225
3222,3223
3223,3224
3223,3225
3224,3225
3226,3227
3226,3228
3227,3228
3230,3231
3232,3233
3232,3234
3233,3234
3235,3236
3235,3237
3236,3237
3239,3240
3239,3241
3239,3242
3239,3243
3240,3241
3241,3242
3241,3243
3242,3243
3244,3245
3244,3246
3244,3247
3247,3248
3248,3249
3248,3250
3248,3251
3249,3250
3251,3252
3251,3253
3252,3253
3255,3256
3255,3257
3256,3257
3259,3260
3259,3261
3260,3261
3262,3263
3263,3264
3264,3265
3264,3266
3265,3266
3267,3268
3269,3270
3270,3271
3270,3272
3271,3272
3273,3274
3275,3276
3275,3277
3275,3278
3276,3277
3277,3278
3279,3280
3280,3281
3281,3282
3281,3283
3281,3284
3282,3283
3284,3285
3287,3288
3288,3289
3289,3290
3289,3291
3289,3292
3289,3293
3290,3291
3292,3293
3294,3295
3296,3297
3298,3299
3298,3300
3299,3300
3301,3302
3302,3303
3303,3304
3303,3305
3304,3305
3306,3307
3308,3309
3309,3310
3309,3311
3310,3311
3310,3312
3311,3312
3314,3315
3316,3317
3317,3318
3317,3319
3317,3320
3318,3319
3320,3321
3322,3323
3324,3325
3324,3326
3324,3327
3325,3326
3326,3327
3326,3328
3326,3329
3327,3328
3329,3330
3332,3333
3332,3334
3333,3334
3335,3336
3336,3337
3337,3338
3337,3339
3338,3339
3340,3341
3342,3343
3342,3344
3343,3344
3345,3346
3346,3347
3347,3348
3347,3349
3348,3349
3350,3351
3351,3352
3353,3354
3354,3355
3354,3356
3355,3356
3357,3358
3359,3360
3359,3361
3359,3362
3360,3361
3361,3362
3361,3363
3361,3364
3362,3363
3366,3367
3366,3368
3366,3369
3366,3370
3367,3368
3368,3369
3368,3370
3369,3370
3371,3372
3371,3373
3372,3373
3375,3376
3375,3377
3376,3377
3378,3379
3378,3380
3379,3380
3382,3383
3382,3384
3383,3384
3385,3386
3385,3387
3386,3387
3390,3391
3390,3392
3391,3392
3393,3394
3393,3395
3393,3396
3394,3395
3395,3396
3395,3397
3396,3397
3396,3398
3397,3398
3400,3401
3400,3402
3401,3402
3401,3403
3402,3403
3404,3405
3404,3406
3405,3406
3409,3410
3410,3411
3410,3412
3411,3412
3411,3413
3412,3413
3412,3414
3413,3414
3415,3416
3415,3417
3416,3417
3420,3421
3420,3422
3421,3422
3424,3425
3425,3426
3425,3427
3426,3427
3426,3428
3427,3428
3430,3431
3432,3433
3432,3434
3433,3434
3433,3435
3434,3435
3437,3438
3438,3439
3439,3440
3439,3441
3439,3442
3440,3441
3444,3445
3444,3446
3445,3446
3445,3447
3446,3447
3446,3448
3447,3448
3448,3449
3448,3450
3449,3450
3449,3451
3450,3451
3453,3454
3455,3456
3456,3457
3456,3458
3457,3458
3457,3459
3458,3459
3458,3460
3459,3460
3463,3464
3465,3466
3465,3467
3466,3467
3466,3468
3467,3468
3469,3470
3469,3471
3470,3471
3474,3475
3475,3476
3476,3477
3476,3478
3477,3478
3479,3480
3480,3481
3480,3482
3482,3483
3483,3484
3483,3485
3484,3485
3487,3488
3487,3489
3488,3489
3488,3490
3489,3490
3489,3491
3490,3491
3493,3494
3495,3496
3496,3497
3496,3498
3497,3498
3497,3499
3498,3499
3498,3500
3499,3500
3501,3502
3502,3503
3502,3504
3503,3504
3503,3505
3504,3505
3508,3509
3508,3510
3509,3510
3509,3511
3510,3511
3512,3513
3512,3514
3513,3514
3517,3518
3517,3519
3517,3520
3518,3519
3519,3520
3519,3521
3520,3521
3520,3522
3521,3522
3521,3523
3522,3523
3524,3525
3524,3526
3525,3526
3529,3530
3529,3531
3530,3531
3532,3533
3533,3534
3533,3535
3534,3535
3534,3536
3535,3536
3539,3540
3540,3541
3540,3542
3540,3543
3540,3544
3541,3542
3545,3546
3545,3547
3546,3547
3548,3549
3549,3550
3549,3551
3550,3551
3550,3552
3551,3552
3555,3556
3555,3557
3556,3557
3556,3558
3557,3558
3557,3559
3558,3559
3560,3561
3560,3562
3561,3562
3565,3566
3565,3567
3566,3567
3567,3568
3567,3569
3568,3569
3570,3571
3570,3572
3571,3572
3574,3575
3574,3576
3574,3577
3575,3576
3575,3577
3576,3577
3578,3579
3578,3580
3579,3580
3582,3583
3583,3584
3583,3585
3584,3585
3584,3586
3585,3586
3585,3587
3586,3587
3588,3589
3588,3590
3589,3590
3593,3594
3593,3595
3593,3596
3594,3595
3595,3596
3595,3597
3596,3597
3598,3599
3598,3600
3598,3601
3601,3602
3602,3603
3602,3604
3603,3604
3605,3606
3605,3607
3606,3607
3608,3609
3608,3610
3609,3610
3609,3611
3610,3611
3612,3613
3612,3614
3613,3614
3617,3618
3618,3619
3618,3620
3619,3620
3621,3622
3621,3623
3621,3624
3624,3625
3625,3626
3625,3627
3626,3627
3628,3629
3628,3630
3629,3630
3629,3631
3630,3631
3632,3633
3632,3634
3633,3634
3637,3638
3637,3639
3638,3639
3640,3641
3640,3642
3640,3643
3640,3644
3640,3645
3641,3642
3642,3643
3642,3644
3642,3645
3643,3644
3645,3646
3647,3648
3648,3649
3648,3650
3649,3650
3649,3651
3650,3651
3654,3655
3654,3656
3655,3656
3655,3657
3656,3657
3656,3658
3657,3658
3659,3660
3659,3661
3660,3661
3660,3662
3661,3662
3663,3664
3663,3665
3664,3665
3669,3670
3670,3671
3671,3672
3671,3673
3671,3674
3672,3673
3674,3675
3674,3676
3675,3676
3675,3677
3676,3677
3678,3679
3678,3680
3679,3680
3683,3684
3683,3685
3684,3685
3686,3687
3686,3688
3687,3688
3687,3689
3688,3689
3690,3691
3690,3692
3691,3692
3695,3696
3696,3697
3696,3698
3696,3699
3697,3698
3699,3700
3701,3702
3703,3704
3704,3705
3704,3706
3705,3706
3707,3708
3707,3709
3708,3709
3708,3710
3709,3710
3711,3712
3711,3713
3712,3713
3716,3717
3717,3718
3717,3719
3718,3719
3720,3721
3720,3722
3721,3722
3723,3724
3725,3726
3725,3727
3725,3728
3725,3729
3726,3727
3727,3728
3727,3729
3727,3730
3728,3729
3732,3733
3732,3734
3733,3734
3733,3735
3734,3735
3737,3738
3737,3739
3737,3740
3738,3739
3739,3740
3739,3741
3740,3741
3742,3743
3742,3744
3743,3744
3746,3747
3747,3748
3747,3749
3747,3750
3748,3749
3752,3753
3753,3754
3753,3755
3754,3755
3754,3756
3755,3756
3758,3759
3760,3761
3761,3762
3761,3763
3762,3763
3764,3765
3765,3766
3765,3767
3765,3768
3768,3769
3769,3770
3769,3771
3770,3771
3773,3774
3775,3776
3775,3777
3776,3777
3776,3778
3777,3778
3777,3779
3778,3779
3781,3782
3783,3784
3784,3785
3784,3786
3785,3786
3785,3787
3786,3787
3786,3788
3787,3788
3787,3789
3788,3789
3788,3790
3789,3790
3794,3795
3794,3796
3795,3796
3797,3798
3797,3799
3798,3799
3798,3800
3799,3800
3801,3802
3801,3803
3802,3803
3806,3807
3806,3808
3807,3808
3808,3809
3808,3810
3808,3811
3808,3812
3809,3810
3813,3814
3813,3815
3814,3815
3816,3817
3817,3818
3817,3819
3818,3819
3818,3820
3819,3820
3823,3824
3824,3825
3824,3826
3825,3826
3825,3827
3826,3827
3826,3828
3827,3828
3829,3830
3829,3831
3830,3831
3834,3835
3834,3836
3835,3836
3837,3838
3838,3839
3838,3840
3839,3840
3839,3841
3840,3841
3844,3845
3844,3846
3845,3846
3845,3847
3846,3847
3846,3848
3847,3848
3847,3849
3848,3849
3851,3852
3853,3854
3853,3855
3854,3855
3854,3856
3855,3856
3857,3858
3857,3859
3858,3859
3862,3863
3863,3864
3863,3865
3863,3866
3864,3865
3864,3866
3865,3866
3865,3867
3866,3867
3866,3868
3867,3868
3871,3872
3873,3874
3874,3875
3875,3876
3875,3877
3875,3878
3876,3877
3878,3879
3878,3880
3879,3880
3879,3881
3880,3881
3882,3883
3882,3884
3883,3884
3887,3888
3889,3890
3889,3891
3890,3891
3890,3892
3891,3892
3891,3893
3892,3893
3892,3894
3893,3894
3897,3898
3899,3900
3900,3901
3901,3902
3901,3903
3901,3904
3902,3903
3904,3905
3904,3906
3905,3906
3905,3907
3906,3907
3908,3909
3908,3910
3909,3910
3913,3914
3915,3916
3915,3917
3916,3917
3916,3918
3917,3918
3917,3919
3918,3919
3921,3922
3923,3924
3923,3925
3923,3926
3923,3927
3923,3928
3923,3929
3923,3930
3923,3931
3923,3932
3923,3933
3923,3934
3923,3935
3923,3936
3923,3937
3923,3938
3923,3939
3923,3940
3923,3941
3923,3942
3923,3943
3923,3944
3923,3945
3923,3946
3923,3947
3923,3948
3923,3949
3923,3950
3923,3951
3923,3952
3923,3953
3923,3954
3923,3955
3923,3956
3923,3957
3923,3958
3923,3959
3923,3960
3923,3961
3923,3962
3923,3963
3923,3964
3923,3965
3923,3966
3923,3967
3923,3968
3923,3969
3923,3970
3923,3971
3923,3972
3923,3973
3923,3974
3923,3975
3923,3976
3923,3977
3923,3978
3923,3979
3923,3980
3923,3981
3923,3982
3923,3983
3923,3984
3923,3985
3923,3986
3923,3987
3923,3988
3923,3989
3923,3990
3923,3991
3923,3992
3923,3993
3923,3994
3923,3995
3923,3996
3923,3997
3923,3998
3923,3999
3923,4000
3923,4001
3923,4002
3923,4003
3923,4004
3923,4005
3923,4006
3923,4007
3923,4008
3923,4009
3923,4010
3923,4011
3923,4012
3923,4013
3923,4014
3923,4015
3923,4016
3923,4017
3923,4018
3924,3925
3925,3926
3925,3927
3925,3928
3926,3927
3928,3929
3930,3931
3930,3932
3931,3932
3931,3933
3932,3933
3934,3935
3934,3936
3935,3936
3939,3940
3939,3941
3940,3941
3942,3943
3943,3944
3943,3945
3943,3946
3943,3947
3944,3945
3948,3949
3948,3950
3949,3950
3949,3951
3950,3951
3954,3955
3954,3956
3955,3956
3955,3957
3956,3957
3956,3958
3957,3958
3957,3959
3958,3959
3958,3960
3959,3960
3959,3961
3960,3961
3960,3962
3961,3962
3963,3964
3963,3965
3964,3965
3968,3969
3968,3970
3969,3970
3972,3973
3972,3974
3973,3974
3973,3975
3974,3975
3974,3976
3975,3976
3979,3980
3981,3982
3981,3983
3982,3983
3982,3984
3983,3984
3983,3985
3984,3985
3988,3989
3990,3991
3990,3992
3991,3992
3991,3993
3992,3993
3992,3994
3993,3994
3997,3998
3999,4000
3999,4001
4000,4001
4001,4002
4001,4003
4002,4003
4002,4004
4003,4004
4003,4005
4004,4005
4006,4007
4006,4008
4007,4008
4011,4012
4011,4013
4012,4013
4015,4016
4015,4017
4016,4017
4018,4019
4019,4020
4019,4021
4019,4022
4019,4023
4019,4024
4020,4021
4024,4025
4024,4026
4025,4026
4028,4029
4028,4030
4029,4030
4032,4033
4033,4034
4033,4035
4034,4035
4034,4036
4035,4036
4035,4037
4036,4037
4038,4039
4038,4040
4039,4040
4043,4044
4043,4045
4044,4045
4044,4046
4045,4046
4049,4050
4049,4051
4050,4051
4051,4052
4051,4053
4052,4053
4052,4054
4053,4054
4055,4056
4055,4057
4056,4057
4060,4061
4061,4062
4062,4063
4062,4064
4063,4064
4063,4065
4064,4065
4064,4066
4065,4066
4067,4068
4067,4069
4068,4069
4072,4073
4072,4074
4073,4074
4073,4075
4074,4075
4078,4079
4078,4080
4079,4080
4079,4081
4080,4081
4080,4082
4081,4082
4085,4086
4085,4087
4085,4088
4085,4089
4085,4090
4085,4091
4085,4092
4085,4093
4085,4094
4085,4095
4085,4096
4085,4097
4085,4098
4085,4099
4085,4100
4085,4101
4085,4102
4085,4103
4085,4104
4085,4105
4085,4106
4085,4107
4085,4108
4085,4109
4085,4110
4085,4111
4085,4112
4085,4113
4085,4114
4085,4115
4085,4116
4085,4117
4085,4118
4085,4119
4085,4120
4085,4121
4085,4122
4085,4123
4085,4124
4085,4125
4085,4126
4085,4127
4085,4128
4085,4129
4085,4130
4085,4131
4085,4132
4085,4133
4085,4134
4085,4135
4085,4136
4085,4137
4085,4138
4085,4139
4085,4140
4085,4141
4085,4142
4085,4143
4085,4144
4085,4145
4085,4146
4085,4147
4085,4148
4085,4149
4085,4150
4085,4151
4085,4152
4085,4153
4085,4154
4085,4155
4085,4156
4085,4157
4085,4158
4085,4159
4085,4160
4085,4161
4085,4162
4085,4163
4086,4087
4087,4088
4090,4091
4091,4092
4093,4094
4093,4095
4094,4095
4094,4096
4094,4097
4095,4096
4097,4098
4098,4099
4098,4100
4099,4100
4099,4101
4100,4101
4102,4103
4102,4104
4103,4104
4107,4108
4109,4110
4109,4111
4109,4112
4110,4111
4110,4112
4111,4112
4111,4113
4112,4113
4112,4114
4113,4114
4115,4116
4115,4117
4116,4117
4120,4121
4121,4122
4122,4123
4122,4124
4122,4125
4122,4126
4122,4127
4122,4128
4122,4129
4123,4124
4125,4126
4125,4127
4126,4127
4126,4128
4127,4128
4129,4130
4129,4131
4130,4131
4134,4135
4138,4139
4138,4140
4139,4140
4141,4142
4141,4143
4142,4143
4142,4144
4143,4144
4145,4146
4145,4147
4146,4147
4150,4151
4150,4152
4151,4152
4153,4154
4153,4155
4154,4155
4154,4156
4155,4156
4157,4158
4157,4159
4158,4159
4162,4163
4163,4164
4163,4165
4163,4166
4164,4165
4166,4167
4166,4168
4167,4168
4169,4170
4169,4171
4170,4171
4173,4174
4175,4176
4175,4177
4176,4177
4176,4178
4177,4178
4180,4181
4180,4182
4180,4183
4180,4184
4181,4182
4182,4183
4182,4184
4183,4184
4185,4186
4185,4187
4186,4187
4189,4190
4189,4191
4190,4191
4190,4192
4191,4192
4192,4193
4192,4194
4193,4194
4195,4196
4195,4197
4196,4197
4199,4200
4200,4201
4200,4202
4201,4202
4201,4203
4202,4203
4204,4205
4204,4206
4205,4206
4209,4210
4211,4212
4211,4213
4212,4213
4212,4214
4213,4214
4215,4216
4215,4217
4216,4217
4216,4218
4217,4218
4219,4220
4219,4221
4220,4221
4224,4225
4224,4226
4225,4226
4226,4227
4226,4228
4228,4229
4228,4230
4228,4231
4231,4232
4232,4233
4232,4234
4233,4234
4233,4235
4234,4235
4236,4237
4236,4238
4237,4238
4241,4242
4242,4243
4242,4244
4242,4245
4242,4246
4242,4247
4243,4244
4245,4246
4245,4247
4246,4247
4249,4250
4251,4252
4251,4253
4251,4254
4252,4253
4254,4255
4256,4257
4258,4259
4258,4260
4258,4261
4259,4260
4260,4261
4260,4262
4261,4262
4263,4264
4265,4266
4265,4267
4266,4267
4266,4268
4267,4268
4269,4270
4273,4274
4274,4275
4274,4276
4275,4276
4277,4278
4277,4279
4278,4279
4278,4280
4279,4280
4281,4282
4281,4283
4282,4283
4287,4288
4288,4289
4290,4291
4290,4292
4291,4292
4291,4293
4291,4294
4292,4293
4294,4295
4295,4296
4295,4297
4296,4297
4296,4298
4297,4298
4299,4300
4299,4301
4300,4301
4304,4305
4306,4307
4306,4308
4306,4309
4306,4310
4306,4311
4306,4312
4306,4313
4307,4308
4308,4309
4308,4310
4309,4310
4311,4312
4311,4313
4312,4313
4315,4316
4315,4317
4316,4317
4317,4318
4317,4319
4318,4319
4320,4321
4320,4322
4321,4322
4324,4325
4326,4327
4326,4328
4327,4328
4327,4329
4328,4329
4328,4330
4329,4330
4329,4331
4330,4331
4332,4333
4332,4334
4333,4334
4337,4338
4337,4339
4337,4340
4338,4339
4340,4341
4340,4342
4341,4342
4343,4344
4343,4345
4344,4345
4347,4348
4349,4350
4350,4351
4351,4352
4351,4353
4351,4354
4351,4355
4351,4356
4351,4357
4351,4358
4352,4353
4354,4355
4354,4356
4355,4356
4355,4357
4356,4357
4358,4359
4358,4360
4359,4360
4363,4364
4367,4368
4367,4369
4368,4369
4370,4371
4370,4372
4371,4372
4371,4373
4372,4373
4374,4375
4374,4376
4375,4376
4379,4380
4379,4381
4380,4381
4382,4383
4382,4384
4383,4384
4383,4385
4384,4385
4386,4387
4386,4388
4387,4388
4391,4392
4392,4393
4392,4394
4392,4395
4393,4394
4395,4396
4395,4397
4396,4397
4398,4399
4398,4400
4399,4400
4402,4403
4404,4405
4404,4406
4405,4406
4406,4407
4406,4408
4407,4408
4407,4409
4408,4409
4410,4411
4410,4412
4411,4412
4415,4416
4417,4418
4417,4419
4418,4419
4418,4420
4419,4420
4421,4422
4421,4423
4422,4423
4422,4424
4423,4424
4425,4426
4425,4427
4426,4427
4430,4431
4431,4432
4432,4433
4432,4434
4432,4435
4432,4436
4432,4437
4433,4434
4435,4436
4435,4437
4436,4437
4439,4440
4441,4442
4444,4445
4445,4446
4445,4447
4446,4447
4448,4449
4448,4450
4449,4450
4449,4451
4450,4451
4452,4453
4452,4454
4453,4454
4458,4459
4459,4460
4461,4462
4461,4463
4462,4463
4462,4464
4463,4464
4463,4465
4464,4465
4464,4466
4465,4466
4467,4468
4467,4469
4468,4469
4472,4473
4474,4475
4474,4476
4474,4477
4474,4478
4474,4479
4474,4480
4474,4481
4475,4476
4476,4477
4476,4478
4476,4479
4476,4480
4477,4478
4479,4480
4480,4481
4480,4482
4481,4482
4483,4484
4483,4485
4484,4485
4487,4488
4489,4490
4491,4492
4492,4493
4493,4494
4493,4495
4494,4495
4494,4496
4495,4496
4498,4499
4499,4500
4500,4501
4500,4502
4501,4502
4501,4503
4502,4503
4505,4506
4507,4508
4508,4509
4508,4510
4508,4511
4508,4512
4509,4510
4511,4512
4512,4513
4515,4516
4516,4517
4517,4518
4519,4520
4520,4521
4520,4522
4520,4523
4520,4524
4521,4522
4523,4524
4524,4525
4526,4527
4528,4529
4528,4530
4529,4530
4529,4531
4530,4531
4532,4533
4532,4534
4533,4534
4537,4538
4538,4539
4538,4540
4538,4541
4538,4542
4538,4543
4538,4544
4538,4545
4538,4546
4539,4540
4541,4542
4541,4543
4542,4543
4544,4545
4544,4546
4545,4546
4548,4549
4550,4551
4553,4554
4553,4555
4554,4555
4557,4558
4557,4559
4558,4559
4561,4562
4563,4564
4564,4565
4564,4566
4565,4566
4565,4567
4566,4567
4566,4568
4567,4568
4569,4570
4569,4571
4570,4571
4574,4575
4577,4578
4578,4579
4580,4581
4580,4582
4581,4582
4581,4583
4581,4584
4582,4583
4584,4585
4585,4586
4585,4587
4586,4587
4586,4588
4587,4588
4589,4590
4589,4591
4590,4591
4594,4595
4594,4596
4595,4596
4597,4598
4600,4601
4600,4602
4601,4602
4601,4603
4602,4603
4602,4604
4603,4604
4603,4605
4604,4605
4607,4608
4607,4609
4608,4609
4611,4612
4611,4613
4612,4613
4612,4614
4613,4614
4617,4618
4617,4619
4617,4620
4617,4621
4618,4619
4619,4620
4619,4621
4620,4621
4622,4623
4623,4624
4623,4625
4623,4626
4626,4627
4627,4628
4627,4629
4628,4629
4631,4632
4632,4633
4632,4634
4632,4635
4632,4636
4632,4637
4633,4634
4635,4636
4636,4637
4638,4639
4640,4641
4640,4642
4641,4642
4644,4645
4644,4646
4645,4646
4648,4649
4649,4650
4649,4651
4650,4651
4652,4653
4653,4654
4653,4655
4654,4655
4656,4657
4656,4658
4657,4658
4660,4661
4660,4662
4661,4662
4662,4663
4662,4664
4663,4664
4665,4666
4665,4667
4666,4667
4669,4670
4671,4672
4671,4673
4672,4673
4672,4674
4672,4675
4673,4674
4675,4676
4675,4677
4676,4677
4678,4679
4678,4680
4679,4680
4682,4683
4684,4685
4684,4686
4685,4686
4686,4687
4686,4688
4688,4689
4690,4691
4690,4692
4691,4692
4691,4693
4692,4693
4693,4694
4693,4695
4694,4695
4696,4697
4696,4698
4696,4699
4697,4698
4699,4700
4699,4701
4700,4701
4704,4705
4706,4707
4707,4708
4707,4709
4708,4709
4708,4710
4709,4710
4712,4713
4714,4715
4714,4716
4715,4716
4717,4718
4718,4719
4718,4720
4718,4721
4718,4722
4718,4723
4718,4724
4718,4725
4718,4726
4719,4720
4721,4722
4721,4723
4722,4723
4724,4725
4724,4726
4725,4726
4728,4729
4730,4731
4732,4733
4732,4734
4733,4734
4736,4737
4739,4740
4739,4741
4740,4741
4743,4744
4743,4745
4744,4745
4744,4746
4744,4747
4744,4748
4745,4746
4747,4748
4747,4749
4748,4749
4751,4752
4752,4753
4754,4755
4755,4756
4757,4758
4757,4759
4757,4760
4758,4759
4759,4760
4759,4761
4759,4762
4760,4761
4762,4763
4762,4764
4763,4764
4766,4767
4768,4769
4768,4770
4769,4770
4771,4772
4772,4773
4772,4774
4772,4775
4772,4776
4772,4777
4772,4778
4773,4774
4775,4776
4778,4779
4778,4780
4779,4780
4781,4782
4781,4783
4782,4783
4785,4786
4785,4787
4786,4787
4786,4788
4787,4788
4789,4790
4789,4791
4790,4791
4794,4795
4794,4796
4795,4796
4795,4797
4796,4797
4798,4799
4798,4800
4799,4800
4804,4805
4804,4806
4805,4806
4805,4807
4806,4807
4806,4808
4807,4808
4809,4810
4809,4811
4810,4811
4810,4812
4811,4812
4813,4814
4813,4815
4814,4815
4818,4819
4818,4820
4818,4821
4819,4820
4821,4822
4821,4823
4822,4823
4824,4825
4824,4826
4825,4826
4828,4829
4830,4831
4830,4832
4830,4833
4831,4832
4832,4833
4832,4834
4832,4835
4833,4834
4835,4836
4835,4837
4836,4837
4839,4840
4841,4842
4842,4843
4842,4844
4842,4845
4843,4844
4845,4846
4849,4850
4849,4851
4849,4852
4850,4851
4850,4852
4850,4853
4851,4852
4853,4854
4853,4855
4854,4855
4854,4856
4855,4856
4857,4858
4857,4859
4858,4859
4863,4864
4863,4865
4863,4866
4863,4867
4863,4868
4863,4869
4863,4870
4863,4871
4864,4865
4865,4866
4865,4867
4865,4868
4865,4869
4867,4868
4867,4869
4870,4871
4870,4872
4873,4874
4873,4875
4876,4877
4877,4878
4877,4879
4878,4879
4880,4881
4880,4882
4881,4882
4883,4884
4883,4885
4884,4885
4884,4886
4885,4886
4887,4888
4887,4889
4888,4889
4892,4893
4893,4894
4893,4895
4894,4895
4896,4897
4896,4898
4897,4898
4899,4900
4899,4901
4900,4901
4900,4902
4901,4902
4903,4904
4903,4905
4904,4905
4908,4909
4909,4910
4909,4911
4910,4911
4912,4913
4912,4914
4913,4914
4915,4916
4915,4917
4916,4917
4916,4918
4917,4918
4919,4920
4919,4921
4920,4921
4924,4925
4925,4926
4925,4927
4926,4927
4928,4929
4929,4930
4929,4931
4929,4932
4932,4933
4933,4934
4933,4935
4934,4935
4937,4938
4938,4939
4938,4940
4939,4940
4941,4942
4941,4943
4941,4944
4941,4945
4941,4946
4941,4947
4942,4943
4944,4945
4946,4947
4948,4949
4951,4952
4953,4954
4954,4955
4954,4956
4955,4956
4957,4958
4958,4959
4958,4960
4959,4960
4961,4962
4961,4963
4962,4963
4965,4966
4965,4967
4966,4967
4967,4968
4967,4969
4968,4969
4970,4971
4970,4972
4971,4972
4974,4975
4976,4977
4977,4978
4977,4979
4978,4979
4981,4982
4982,4983
4982,4984
4982,4985
4983,4984
4985,4986
4987,4988
4988,4989
4990,4991
4990,4992
4991,4992
4991,4993
4992,4993
4992,4994
4993,4994
4995,4996
4995,4997
4996,4997
4996,4998
4997,4998
4999,5000
4999,5001
5000,5001
5004,5005
5004,5006
5005,5006
5007,5008
5007,5009
5008,5009
5008,5010
5009,5010
5011,5012
5011,5013
5012,5013
5016,5017
5016,5018
5017,5018
5017,5019
5017,5020
5018,5019
5018,5020
5019,5020
5019,5021
5019,5022
5020,5021
5022,5023
5022,5024
5023,5024
5023,5025
5024,5025
5026,5027
5026,5028
5027,5028
5032,5033
5033,5034
5035,5036
5035,5037
5035,5038
5035,5039
5035,5040
5035,5041
5036,5037
5037,5038
5037,5039
5037,5040
5037,5041
5038,5039
5040,5041
5041,5042
5044,5045
5045,5046
5046,5047
5048,5049
5049,5050
5049,5051
5049,5052
5049,5053
5050,5051
5052,5053
5053,5054
5055,5056
5058,5059
5059,5060
5059,5061
5059,5062
5059,5063
5060,5061
5062,5063
5063,5064
5065,5066
5067,5068
5069,5070
5070,5071
5070,5072
5070,5073
5070,5074
5070,5075
5070,5076
5070,5077
5070,5078
5071,5072
5073,5074
5073,5075
5074,5075
5076,5077
5076,5078
5077,5078
5080,5081
5082,5083
5085,5086
5085,5087
5086,5087
5089,5090
5089,5091
5090,5091
5093,5094
5095,5096
5095,5097
5096,5097
5097,5098
5097,5099
5098,5099
5100,5101
5100,5102
5101,5102
5104,5105
5106,5107
5106,5108
5107,5108
5109,5110
5110,5111
5110,5112
5110,5113
5110,5114
5110,5115
5110,5116
5111,5112
5113,5114
5116,5117
5116,5118
5117,5118
5119,5120
5119,5121
5120,5121
5123,5124
5123,5125
5124,5125
5124,5126
5125,5126
5127,5128
5127,5129
5128,5129
5132,5133
5132,5134
5133,5134
5133,5135
5134,5135
5136,5137
5136,5138
5137,5138
5141,5142
5141,5143
5141,5144
5142,5143
5142,5144
5142,5145
5143,5144
5143,5145
5143,5146
5144,5145
5146,5147
5146,5148
5147,5148
5149,5150
5149,5151
5150,5151
5153,5154
5155,5156
5155,5157
5155,5158
5155,5159
5155,5160
5156,5157
5156,5158
5156,5159
5157,5158
5157,5159
5157,5160
5158,5159
5160,5161
5160,5162
5161,5162
5163,5164
5163,5165
5164,5165
5167,5168
5169,5170
5170,5171
5171,5172
5171,5173
5172,5173
5175,5176
5176,5177
5177,5178
5177,5179
5178,5179
5181,5182
5182,5183
5182,5184
5183,5184
5185,5186
5185,5187
5186,5187
5186,5188
5187,5188
5187,5189
5188,5189
5190,5191
5190,5192
5191,5192
5195,5196
5195,5197
5196,5197
5196,5198
5197,5198
5199,5200
5199,5201
5200,5201
5204,5205
5205,5206
5205,5207
5205,5208
5205,5209
5206,5207
5208,5209
5209,5210
5212,5213
5213,5214
5214,5215
5216,5217
5217,5218
5217,5219
5217,5220
5218,5219
5220,5221
5223,5224
5224,5225
5224,5226
5224,5227
5225,5226
5227,5228
5230,5231
5230,5232
5230,5233
5230,5234
5230,5235
5230,5236
5230,5237
5231,5232
5232,5233
5232,5234
5233,5234
5235,5236
5237,5238
5238,5239
5238,5240
5239,5240
5242,5243
5242,5244
5243,5244
5243,5245
5244,5245
5247,5248
5248,5249
5248,5250
5248,5251
5248,5252
5248,5253
5249,5250
5251,5252
5252,5253
5252,5254
5253,5254
5253,5255
5254,5255
5256,5257
5256,5258
5257,5258
5261,5262
5261,5263
5262,5263
5267,5268
5267,5269
5267,5270
5268,5269
5268,5270
5268,5271
5268,5272
5269,5270
5271,5272
5272,5273
5272,5274
5273,5274
5273,5275
5274,5275
5276,5277
5276,5278
5277,5278
5282,5283
5283,5284
5285,5286
5286,5287
5286,5288
5286,5289
5287,5288
5287,5289
5287,5290
5288,5289
5290,5291
5290,5292
5291,5292
5293,5294
5293,5295
5294,5295
5297,5298
5299,5300
5299,5301
5300,5301
5301,5302
5301,5303
5302,5303
5304,5305
5304,5306
5305,5306
5305,5307
5306,5307
5308,5309
5308,5310
5309,5310
5313,5314
5314,5315
5314,5316
5315,5316
5318,5319
5319,5320
5320,5321
5320,5322
5321,5322
5323,5324
5323,5325
5324,5325
5324,5326
5325,5326
5327,5328
5327,5329
5328,5329
5332,5333
5333,5334
5333,5335
5334,5335
5336,5337
5336,5338
5337,5338
5337,5339
5338,5339
5340,5341
5340,5342
5341,5342
5345,5346
5346,5347
5346,5348
5347,5348
5349,5350
5349,5351
5349,5352
5349,5353
5350,5351
5352,5353
5353,5354
5355,5356
5355,5357
5356,5357
5356,5358
5357,5358
5357,5359
5358,5359
5360,5361
5360,5362
5361,5362
5365,5366
5365,5367
5366,5367
5366,5368
5367,5368
5369,5370
5369,5371
5370,5371
5375,5376
5376,5377
5376,5378
5376,5379
5376,5380
5377,5378
5379,5380
5380,5381
5380,5382
5381,5382
5381,5383
5382,5383
5384,5385
5384,5386
5385,5386
5389,5390
5391,5392
5391,5393
5392,5393
5393,5394
5394,5395
5397,5398
5398,5399
5398,5400
5398,5401
5398,5402
5399,5400
5401,5402
5402,5403
5402,5404
5403,5404
5403,5405
5404,5405
5406,5407
5406,5408
5407,5408
5411,5412
5413,5414
5413,5415
5414,5415
5415,5416
5416,5417
5419,5420
5419,5421
5420,5421
5421,5422
5423,5424
5423,5425
5424,5425
5424,5426
5425,5426
5426,5427
5426,5428
5426,5429
5427,5428
5429,5430
5429,5431
5430,5431
5432,5433
5432,5434
5433,5434
5436,5437
5438,5439
5439,5440
5439,5441
5440,5441
5442,5443
5442,5444
5443,5444
5443,5445
5444,5445
5444,5446
5445,5446
5447,5448
5447,5449
5448,5449
5452,5453
5452,5454
5453,5454
5453,5455
5454,5455
5456,5457
5456,5458
5457,5458
5461,5462
5461,5463
5461,5464
5462,5463
5463,5464
5465,5466
5465,5467
5465,5468
5465,5469
5465,5470
5465,5471
5466,5467
5467,5468
5467,5469
5467,5470
5467,5471
5468,5469
5470,5471
5471,5472
5474,5475
5475,5476
5476,5477
5478,5479
5479,5480
5479,5481
5479,5482
5479,5483
5480,5481
5482,5483
5483,5484
5485,5486
5488,5489
5489,5490
5489,5491
5489,5492
5489,5493
5490,5491
5492,5493
5493,5494
5495,5496
5497,5498
5499,5500
5500,5501
5500,5502
5500,5503
5500,5504
5500,5505
5500,5506
5500,5507
5500,5508
5501,5502
5503,5504
5503,5505
5504,5505
5506,5507
5506,5508
5507,5508
5510,5511
5512,5513
5515,5516
5515,5517
5516,5517
5519,5520
5519,5521
5520,5521
5523,5524
5525,5526
5525,5527
5526,5527
5527,5528
5527,5529
5528,5529
5530,5531
5530,5532
5531,5532
5534,5535
5536,5537
5536,5538
5537,5538
5539,5540
5539,5541
5540,5541
5541,5542
5541,5543
5541,5544
5541,5545
5543,5544
5543,5545
5545,5546
5547,5548
5547,5549
5549,5550
5551,5552
5551,5553
5553,5554
5555,5556
5555,5557
5555,5558
5556,5557
5556,5558
5556,5559
5557,5558
5559,5560
5559,5561
5560,5561
5562,5563
5562,5564
5563,5564
5566,5567
5568,5569
5569,5570
5570,5571
5570,5572
5570,5573
5570,5574
5570,5575
5570,5576
5571,5572
5573,5574
5576,5577
5576,5578
5577,5578
5579,5580
5579,5581
5580,5581
5583,5584
5583,5585
5583,5586
5583,5587
5584,5585
5586,5587
5588,5589
5589,5590
5590,5591
5592,5593
5592,5594
5593,5594
5593,5595
5594,5595
5596,5597
5596,5598
5597,5598
5601,5602
5601,5603
5601,5604
5601,5605
5602,5603
5604,5605
5606,5607
5607,5608
5608,5609
5610,5611
5610,5612
5611,5612
5611,5613
5612,5613
5614,5615
5614,5616
5615,5616
5619,5620
5620,5621
5621,5622
5621,5623
5621,5624
5621,5625
5621,5626
5621,5627
5621,5628
5622,5623
5624,5625
5627,5628
5627,5629
5628,5629
5630,5631
5630,5632
5631,5632
5634,5635
5634,5636
5634,5637
5634,5638
5635,5636
5637,5638
5639,5640
5640,5641
5641,5642
5643,5644
5643,5645
5644,5645
5644,5646
5645,5646
5647,5648
5647,5649
5648,5649
5652,5653
5652,5654
5652,5655
5652,5656
5653,5654
5655,5656
5657,5658
5658,5659
5659,5660
5661,5662
5661,5663
5662,5663
5662,5664
5663,5664
5665,5666
5665,5667
5666,5667
5670,5671
5670,5672
5670,5673
5670,5674
5671,5672
5673,5674
5675,5676
5676,5677
5677,5678
5679,5680
5679,5681
5680,5681
5680,5682
5681,5682
5683,5684
5683,5685
5684,5685
5688,5689
5688,5690
5689,5690
5689,5691
5689,5692
5690,5691
5690,5692
5690,5693
5691,5692
5693,5694
5693,5695
5694,5695
5696,5697
5696,5698
5697,5698
5700,5701
5702,5703
5703,5704
5703,5705
5704,5705
5705,5706
5706,5707
5706,5708
5707,5708
5707,5709
5708,5709
5708,5710
5709,5710
5711,5712
5711,5713
5712,5713
5716,5717
5716,5718
5717,5718
5717,5719
5718,5719
5720,5721
5720,5722
5721,5722
5725,5726
5726,5727
5726,5728
5727,5728
5730,5731
5731,5732
5731,5733
5731,5734
5732,5733
5732,5734
5732,5735
5733,5734
5735,5736
5735,5737
5736,5737
5738,5739
5738,5740
5739,5740
5742,5743
5744,5745
5744,5746
5744,5747
5744,5748
5744,5749
5745,5746
5746,5747
5746,5748
5747,5748
5749,5750
5749,5751
5749,5752
5750,5751
5750,5752
5750,5753
5751,5752
5753,5754
5753,5755
5754,5755
5756,5757
5756,5758
5757,5758
5760,5761
5764,5765
5765,5766
5765,5767
5765,5768
5765,5769
5766,5767
5768,5769
5769,5770
5772,5773
5773,5774
5774,5775
5776,5777
5777,5778
5777,5779
5778,5779
5780,5781
5780,5782
5781,5782
5783,5784
5783,5785
5784,5785
5784,5786
5785,5786
5785,5787
5786,5787
5788,5789
5788,5790
5789,5790
5793,5794
5793,5795
5794,5795
5794,5796
5795,5796
5797,5798
5797,5799
5798,5799
5802,5803
5803,5804
5803,5805
5803,5806
5804,5805
5806,5807
5809,5810
5810,5811
5810,5812
5810,5813
5811,5812
5813,5814
5816,5817
5816,5818
5816,5819
5817,5818
5818,5819
5818,5820
5819,5820
5821,5822
5823,5824
5824,5825
5824,5826
5825,5826
5828,5829
5828,5830
5828,5831
5829,5830
5829,5831
5829,5832
5829,5833
5830,5831
5832,5833
5833,5834
5833,5835
5834,5835
5834,5836
5835,5836
5837,5838
5837,5839
5838,5839
5843,5844
5844,5845
5846,5847
5846,5848
5847,5848
5847,5849
5847,5850
5848,5849
5848,5850
5848,5851
5849,5850
5851,5852
5851,5853
5852,5853
5854,5855
5854,5856
5855,5856
5858,5859
5860,5861
5861,5862
5862,5863
5862,5864
5863,5864
5865,5866
5865,5867
5866,5867
5866,5868
5867,5868
5869,5870
5869,5871
5870,5871
5874,5875
5874,5876
5875,5876
5876,5877
5876,5878
5877,5878
5879,5880
5879,5881
5880,5881
5880,5882
5881,5882
5883,5884
5883,5885
5884,5885
5888,5889
5889,5890
5889,5891
5890,5891
5893,5894
5894,5895
5894,5896
5895,5896
5897,5898
5897,5899
5897,5900
5897,5901
5898,5899
5900,5901
5901,5902
5903,5904
5903,5905
5904,5905
5904,5906
5905,5906
5905,5907
5906,5907
5908,5909
5908,5910
5909,5910
5913,5914
5913,5915
5914,5915
5914,5916
5915,5916
5917,5918
5917,5919
5918,5919
5923,5924
5924,5925
5924,5926
5925,5926
5927,5928
5927,5929
5928,5929
5930,5931
5930,5932
5931,5932
5931,5933
5932,5933
5932,5934
5933,5934
5935,5936
5935,5937
5936,5937
5940,5941
5940,5942
5941,5942
5941,5943
5942,5943
5944,5945
5944,5946
5945,5946
5949,5950
5949,5951
5950,5951
5951,5952
5953,5954
5953,5955
5953,5956
5953,5957
5953,5958
5953,5959
5953,5960
5953,5961
5953,5962
5953,5963
5954,5955
5955,5956
5955,5957
5955,5958
5955,5959
5957,5958
5957,5959
5959,5960
5961,5962
5961,5963
5963,5964
5965,5966
5965,5967
5967,5968
5969,5970
5970,5971
5970,5972
5970,5973
5970,5974
5971,5972
5973,5974
5974,5975
5977,5978
5978,5979
5979,5980
5981,5982
5982,5983
5982,5984
5982,5985
5982,5986
5983,5984
5985,5986
5986,5987
5988,5989
5991,5992
5992,5993
5992,5994
5992,5995
5992,5996
5993,5994
5995,5996
5996,5997
5998,5999
6000,6001
6002,6003
6003,6004
6003,6005
6003,6006
6003,6007
6004,6005
6006,6007
6009,6010
6009,6011
6009,6012
6009,6013
6010,6011
6012,6013
6014,6015
6015,6016
6016,6017
6018,6019
6018,6020
6019,6020
6019,6021
6020,6021
6020,6022
6021,6022
6023,6024
6023,6025
6024,6025
6028,6029
6028,6030
6029,6030
6029,6031
6030,6031
6032,6033
6032,6034
6033,6034
6037,6038
6038,6039
6038,6040
6038,6041
6038,6042
6038,6043
6038,6044
6038,6045
6038,6046
6039,6040
6041,6042
6041,6043
6042,6043
6044,6045
6044,6046
6045,6046
6048,6049
6050,6051
6053,6054
6053,6055
6054,6055
6057,6058
6057,6059
6058,6059
6061,6062
6063,6064
6063,6065
6064,6065
6065,6066
6065,6067
6066,6067
6068,6069
6068,6070
6069,6070
6072,6073
6074,6075
6074,6076
6075,6076
6077,6078
6078,6079
6079,6080
6079,6081
6079,6082
6079,6083
6079,6084
6079,6085
6079,6086
6080,6081
6082,6083
6085,6086
6085,6087
6086,6087
6088,6089
6088,6090
6089,6090
6092,6093
6092,6094
6092,6095
6092,6096
6093,6094
6095,6096
6097,6098
6098,6099
6099,6100
6101,6102
6101,6103
6102,6103
6102,6104
6103,6104
6105,6106
6105,6107
6106,6107
6110,6111
6110,6112
6110,6113
6110,6114
6111,6112
6113,6114
6115,6116
6116,6117
6117,6118
6119,6120
6119,6121
6120,6121
6120,6122
6121,6122
6123,6124
6123,6125
6124,6125
6128,6129
6128,6130
6128,6131
6128,6132
6129,6130
6131,6132
6133,6134
6134,6135
6135,6136
6137,6138
6137,6139
6138,6139
6138,6140
6139,6140
6141,6142
6141,6143
6142,6143
6146,6147
6147,6148
6147,6149
6147,6150
6148,6149
6150,6151
6150,6152
6151,6152
6153,6154
6153,6155
6154,6155
6157,6158
6160,6161
6160,6162
6161,6162
6163,6164
6163,6165
6163,6166
6163,6167
6163,6168
6164,6165
6165,6166
6165,6167
6165,6168
6165,6169
6166,6167
6168,6169
6169,6170
6172,6173
6173,6174
6174,6175
6176,6177
6177,6178
6177,6179
6177,6180
6177,6181
6178,6179
6180,6181
6181,6182
6183,6184
6185,6186
6187,6188
6188,6189
6188,6190
6188,6191
6188,6192
6188,6193
6189,6190
6191,6192
6192,6193
6194,6195
6197,6198
6199,6200
6200,6201
6200,6202
6200,6203
6200,6204
6200,6205
6200,6206
6200,6207
6200,6208
6201,6202
6203,6204
6203,6205
6204,6205
6206,6207
6206,6208
6207,6208
6210,6211
6212,6213
6215,6216
6215,6217
6216,6217
6219,6220
6219,6221
6220,6221
6223,6224
6225,6226
6225,6227
6225,6228
6226,6227
6226,6228
6226,6229
6227,6228
6229,6230
6229,6231
6230,6231
6230,6232
6231,6232
6233,6234
6233,6235
6234,6235
6239,6240
6239,6241
6239,6242
6239,6243
6239,6244
6240,6241
6241,6242
6241,6243
6241,6244
6242,6243
6244,6245
6245,6246
6245,6247
6246,6247
6246,6248
6247,6248
6249,6250
6249,6251
6250,6251
6254,6255
6256,6257
6257,6258
6257,6259
6257,6260
6257,6261
6257,6262
6257,6263
6257,6264
6257,6265
6257,6266
6257,6267
6257,6268
6257,6269
6257,6270
6257,6271
6258,6259
6262,6263
6262,6264
6263,6264
6265,6266
6265,6267
6266,6267
6269,6270
6271,6272
6271,6273
6272,6273
6274,6275
6274,6276
6275,6276
6275,6277
6276,6277
6278,6279
6278,6280
6279,6280
6283,6284
6285,6286
6287,6288
6289,6290
6289,6291
6290,6291
6292,6293
6294,6295
6296,6297
6298,6299
6300,6301
6302,6303
6303,6304
6303,6305
6304,6305
6304,6306
6305,6306
6305,6307
6306,6307
6308,6309
6308,6310
6309,6310
6313,6314
6315,6316
6316,6317
6316,6318
6317,6318
6319,6320
6319,6321
6320,6321
6323,6324
6324,6325
6324,6326
6324,6327
6325,6326
6327,6328
6327,6329
6328,6329
6330,6331
6330,6332
6331,6332
6334,6335
6336,6337
6336,6338
6337,6338
6338,6339
6338,6340
6338,6341
6339,6340
6341,6342
6342,6343
6342,6344
6343,6344
6343,6345
6344,6345
6346,6347
6346,6348
6347,6348
6351,6352
6353,6354
6354,6355
6354,6356
6354,6357
6354,6358
6355,6356
6359,6360
6359,6361
6360,6361
6362,6363
6362,6364
6363,6364
6367,6368
6367,6369
6367,6370
6368,6369
6368,6370
6369,6370
6369,6371
6370,6371
6370,6372
6371,6372
6373,6374
6373,6375
6374,6375
6378,6379
6380,6381
6381,6382
6381,6383
6381,6384
6382,6383
6384,6385
6384,6386
6385,6386
6387,6388
6387,6389
6388,6389
6391,6392
6391,6393
6392,6393
6395,6396
6396,6397
6396,6398
6397,6398
6397,6399
6398,6399
6398,6400
6399,6400
6401,6402
6401,6403
6402,6403
6407,6408
6407,6409
6408,6409
6408,6410
6409,6410
6410,6411
6410,6412
6411,6412
6413,6414
6413,6415
6414,6415
6417,6418
6417,6419
6418,6419
6420,6421
6420,6422
6421,6422
6424,6425
6425,6426
6425,6427
6425,6428
6426,6427
6428,6429
6429,6430
6429,6431
6430,6431
6430,6432
6431,6432
6433,6434
6433,6435
6434,6435
6438,6439
6441,6442
6442,6443
6444,6445
6444,6446
6445,6446
6445,6447
6446,6447
6446,6448
6447,6448
6447,6449
6447,6450
6448,6449
6450,6451
6451,6452
6451,6453
6452,6453
6452,6454
6453,6454
6455,6456
6455,6457
6456,6457
6460,6461
6462,6463
6463,6464
6463,6465
6463,6466
6464,6465
6466,6467
6467,6468
6467,6469
6468,6469
6468,6470
6469,6470
6471,6472
6471,6473
6472,6473
6476,6477
6478,6479
6478,6480
6479,6480
6482,6483
6483,6484
6483,6485
6483,6486
6484,6485
6486,6487
6487,6488
6488,6489
6488,6490
6488,6491
6488,6492
6488,6493
6489,6490
6491,6492
6491,6493
6492,6493
6495,6496
6495,6497
6496,6497
6496,6498
6497,6498
6499,6500
6499,6501
6500,6501
6504,6505
6504,6506
6505,6506
6508,6509
6508,6510
6509,6510
6509,6511
6510,6511
6512,6513
6512,6514
6513,6514
6517,6518
6518,6519
6519,6520
6519,6521
6519,6522
6519,6523
6519,6524
6519,6525
6520,6521
6522,6523
6522,6524
6523,6524
6526,6527
6526,6528
6527,6528
6527,6529
6528,6529
6530,6531
6530,6532
6531,6532
6535,6536
6535,6537
6536,6537
6539,6540
6539,6541
6540,6541
6540,6542
6541,6542
6543,6544
6543,6545
6544,6545
6550,6551
6551,6552
6553,6554
6554,6555
6554,6556
6554,6557
6555,6556
6557,6558
6557,6559
6558,6559
6560,6561
6560,6562
6561,6562
6564,6565
6566,6567
6567,6568
6567,6569
6567,6570
6567,6571
6568,6569
6572,6573
6572,6574
6573,6574
6576,6577
6576,6578
6577,6578
6577,6579
6578,6579
6578,6580
6579,6580
6581,6582
6581,6583
6582,6583
6586,6587
6586,6588
6587,6588
6588,6589
6588,6590
6588,6591
6589,6590
6591,6592
6591,6593
6592,6593
6595,6596
6595,6597
6596,6597
6599,6600
6599,6601
6600,6601
6601,6602
6601,6603
6602,6603
6604,6605
6604,6606
6605,6606
6608,6609
6610,6611
6611,6612
6611,6613
6611,6614
6611,6615
6611,6616
6611,6617
6611,6618
6611,6619
6612,6613
6614,6615
6614,6616
6615,6616
6617,6618
6617,6619
6618,6619
6621,6622
6623,6624
6625,6626
6625,6627
6626,6627
6629,6630
6632,6633
6632,6634
6633,6634
6636,6637
6637,6638
6637,6639
6638,6639
6640,6641
6640,6642
6641,6642
6645,6646
6646,6647
6648,6649
6648,6650
6649,6650
6649,6651
6650,6651
6650,6652
6651,6652
6653,6654
6653,6655
6654,6655
6658,6659
6658,6660
6659,6660
6660,6661
6660,6662
6660,6663
6661,6662
6663,6664
6663,6665
6664,6665
6667,6668
6667,6669
6668,6669
6671,6672
6671,6673
6672,6673
6673,6674
6673,6675
6674,6675
6676,6677
6676,6678
6677,6678
6680,6681
6682,6683
6682,6684
6683,6684
6684,6685
6684,6686
6684,6687
6685,6686
6687,6688
6687,6689
6688,6689
6690,6691
6690,6692
6691,6692
6694,6695
6696,6697
6696,6698
6697,6698
6697,6699
6698,6699
6698,6700
6699,6700
6699,6701
6700,6701
6700,6702
6701,6702
6703,6704
6703,6705
6704,6705
6708,6709
6710,6711
6711,6712
6711,6713
6711,6714
6711,6715
6711,6716
6712,6713
6714,6715
6717,6718
6717,6719
6718,6719
6720,6721
6720,6722
6721,6722
6721,6723
6722,6723
6722,6724
6723,6724
6725,6726
6725,6727
6726,6727
6731,6732
6731,6733
6731,6734
6732,6733
6732,6734
6733,6734
6736,6737
6736,6738
6737,6738
6741,6742
6742,6743
6742,6744
6742,6745
6742,6746
6743,6744
6747,6748
6747,6749
6748,6749
6751,6752
6752,6753
6752,6754
6752,6755
6752,6756
6752,6757
6752,6758
6752,6759
6752,6760
6753,6754
6755,6756
6755,6757
6756,6757
6758,6759
6758,6760
6759,6760
6762,6763
6764,6765
6766,6767
6766,6768
6767,6768
6770,6771
6773,6774
6773,6775
6774,6775
6777,6778
6777,6779
6778,6779
6779,6780
6779,6781
6779,6782
6780,6781
6782,6783
6782,6784
6783,6784
6785,6786
6785,6787
6786,6787
6789,6790
6791,6792
6792,6793
6792,6794
6793,6794
6793,6795
6794,6795
6794,6796
6795,6796
6797,6798
6797,6799
6798,6799
6802,6803
6804,6805
6805,6806
6805,6807
6806,6807
6808,6809
6808,6810
6809,6810
6813,6814
6814,6815
6816,6817
6816,6818
6816,6819
6816,6820
6816,6821
6816,6822
6816,6823
6816,6824
6817,6818
6818,6819
6818,6820
6819,6820
6821,6822
6821,6823
6824,6825
6825,6826
6825,6827
6826,6827
6828,6829
6828,6830
6831,6832
6832,6833
6832,6834
6833,6834
6835,6836
6835,6837
6836,6837
6839,6840
6839,6841
6840,6841
6841,6842
6841,6843
6842,6843
6844,6845
6844,6846
6845,6846
6848,6849
6850,6851
6851,6852
6851,6853
6852,6853
6854,6855
6854,6856
6855,6856
6855,6857
6856,6857
6858,6859
6858,6860
6859,6860
6863,6864
6864,6865
6864,6866
6865,6866
6867,6868
6867,6869
6867,6870
6868,6869
6870,6871
6870,6872
6871,6872
6873,6874
6875,6876
6877,6878
6877,6879
6877,6880
6878,6879
6878,6880
6879,6880
6881,6882
6881,6883
6882,6883
6885,6886
6885,6887
6885,6888
6885,6889
6885,6890
6885,6891
6885,6892
6885,6893
6885,6894
6885,6895
6885,6896
6885,6897
6886,6887
6887,6888
6887,6889
6889,6890
6889,6891
6892,6893
6893,6894
6893,6895
6894,6895
6896,6897
6896,6898
6897,6898
6899,6900
6899,6901
6900,6901
6900,6902
6901,6902
6903,6904
6903,6905
6904,6905
6908,6909
6909,6910
6909,6911
6910,6911
6912,6913
6914,6915
6915,6916
6915,6917
6916,6917
6918,6919
6920,6921
6921,6922
6921,6923
6922,6923
6924,6925
6926,6927
6927,6928
6927,6929
6928,6929
6930,6931
6931,6932
6931,6933
6931,6934
6934,6935
6935,6936
6935,6937
6936,6937
6939,6940
6940,6941
6940,6942
6940,6943
6940,6944
6941,6942
6943,6944
6946,6947
6946,6948
6947,6948
6949,6950
6951,6952
6952,6953
6952,6954
6952,6955
6952,6956
6953,6954
6955,6956
6958,6959
6958,6960
6959,6960
6961,6962
6963,6964
6963,6965
6963,6966
6964,6965
6964,6966
6964,6967
6964,6968
6965,6966
6967,6968
6967,6969
6968,6969
6971,6972
6973,6974
6975,6976
6975,6977
6976,6977
6977,6978
6977,6979
6977,6980
6977,6981
6978,6979
6982,6983
6982,6984
6983,6984
6985,6986
6987,6988
6987,6989
6988,6989
6988,6990
6988,6991
6988,6992
6988,6993
6989,6990
6991,6992
6993,6994
6995,6996
6995,6997
6996,6997
6999,7000
7001,7002
7002,7003
7003,7004
7003,7005
7003,7006
7003,7007
7004,7005
7006,7007
7009,7010
7009,7011
7010,7011
7012,7013
7014,7015
7015,7016
7015,7017
7015,7018
7016,7017
7016,7018
7016,7019
7016,7020
7016,7021
7017,7018
7019,7020
7021,7022
7023,7024
7023,7025
7024,7025
7028,7029
7029,7030
7030,7031
7030,7032
7030,7033
7030,7034
7030,7035
7030,7036
7031,7032
7033,7034
7036,7037
7036,7038
7037,7038
7039,7040
7041,7042
7041,7043
7042,7043
7045,7046
7047,7048
7048,7049
7049,7050
7049,7051
7049,7052
7049,7053
7049,7054
7049,7055
7050,7051
7054,7055
7054,7056
7055,7056
7057,7058
7059,7060
7059,7061
7060,7061
7063,7064
7065,7066
7066,7067
7066,7068
7067,7068
7069,7070
7071,7072
7072,7073
7072,7074
7073,7074
7075,7076
7077,7078
7078,7079
7078,7080
7079,7080
7081,7082
7082,7083
7082,7084
7083,7084
7085,7086
7085,7087
7086,7087
7089,7090
7089,7091
7090,7091
7091,7092
7091,7093
7091,7094
7091,7095
7092,7093
7096,7097
7096,7098
7097,7098
7100,7101
7100,7102
7101,7102
7103,7104
7104,7105
7105,7106
7105,7107
7106,7107
7108,7109
7111,7112
7112,7113
7114,7115
7114,7116
7115,7116
7115,7117
7115,7118
7116,7117
7118,7119
7119,7120
7119,7121
7120,7121
7120,7122
7121,7122
7123,7124
7123,7125
7124,7125
7128,7129
7128,7130
7129,7130
7129,7131
7130,7131
7132,7133
7134,7135
7137,7138
7137,7139
7138,7139
7138,7140
7138,7141
7139,7140
7141,7142
7141,7143
7142,7143
7144,7145
7144,7146
7145,7146
7148,7149
7150,7151
7150,7152
7150,7153
7151,7152
7152,7153
7152,7154
7152,7155
7152,7156
7152,7157
7152,7158
7152,7159
7152,7160
7153,7154
7155,7156
7155,7157
7156,7157
7158,7159
7158,7160
7159,7160
7162,7163
7164,7165
7166,7167
7166,7168
7167,7168
7170,7171
7173,7174
7173,7175
7174,7175
7177,7178
7178,7179
7178,7180
7179,7180
7181,7182
7181,7183
7182,7183
7186,7187
7186,7188
7186,7189
7187,7188
7187,7189
7188,7189
7191,7192
7192,7193
7193,7194
7193,7195
7194,7195
7194,7196
7195,7196
7195,7197
7196,7197
7198,7199
7198,7200
7199,7200
7203,7204
7203,7205
7204,7205
7207,7208
7208,7209
7208,7210
7208,7211
7209,7210
7209,7211
7210,7211
7210,7212
7211,7212
7213,7214
7213,7215
7214,7215
7218,7219
7219,7220
7219,7221
7220,7221
7220,7222
7221,7222
7221,7223
7222,7223
7224,7225
7224,7226
7225,7226
7229,7230
7229,7231
7230,7231
7232,7233
7232,7234
7233,7234
7235,7236
7235,7237
7236,7237
7236,7238
7237,7238
7239,7240
7239,7241
7240,7241
7244,7245
7245,7246
7245,7247
7246,7247
7246,7248
7247,7248
7247,7249
7248,7249
7250,7251
7250,7252
7251,7252
7255,7256
7255,7257
7256,7257
7256,7258
7257,7258
7259,7260
7259,7261
7260,7261
7264,7265
7265,7266
7265,7267
7265,7268
7265,7269
7265,7270
7266,7267
7270,7271
7270,7272
7271,7272
7273,7274
7273,7275
7274,7275
7274,7276
7275,7276
7275,7277
7276,7277
7278,7279
7278,7280
7279,7280
7284,7285
7284,7286
7285,7286
7287,7288
7287,7289
7288,7289
7288,7290
7289,7290
7291,7292
7291,7293
7292,7293
7296,7297
7296,7298
7296,7299
7297,7298
7298,7299
7299,7300
7299,7301
7300,7301
7300,7302
7301,7302
7301,7303
7302,7303
7304,7305
7304,7306
7305,7306
7309,7310
7309,7311
7310,7311
7310,7312
7311,7312
7313,7314
7313,7315
7314,7315
7318,7319
7318,7320
7318,7321
7318,7322
7318,7323
7318,7324
7319,7320
7320,7321
7320,7322
7320,7323
7320,7324
7321,7322
7323,7324
7324,7325
7327,7328
7328,7329
7329,7330
7331,7332
7332,7333
7332,7334
7332,7335
7332,7336
7333,7334
7335,7336
7336,7337
7338,7339
7341,7342
7342,7343
7342,7344
7342,7345
7342,7346
7343,7344
7345,7346
7346,7347
7348,7349
7350,7351
7352,7353
7353,7354
7353,7355
7353,7356
7353,7357
7353,7358
7353,7359
7353,7360
7353,7361
7354,7355
7356,7357
7356,7358
7357,7358
7359,7360
7359,7361
7360,7361
7363,7364
7365,7366
7368,7369
7368,7370
7369,7370
7372,7373
7372,7374
7373,7374
7376,7377
7378,7379
7378,7380
7379,7380
7380,7381
7380,7382
7381,7382
7383,7384
7383,7385
7384,7385
7387,7388
7389,7390
7389,7391
7390,7391
7392,7393
7392,7394
7393,7394
7394,7395
7394,7396
7394,7397
7396,7397
7396,7398
7398,7399
7400,7401
7400,7402
7402,7403
7404,7405
7405,7406
7405,7407
7405,7408
7405,7409
7405,7410
7405,7411
7406,7407
7408,7409
7411,7412
7411,7413
7412,7413
7414,7415
7414,7416
7415,7416
7418,7419
7418,7420
7418,7421
7418,7422
7419,7420
7421,7422
7423,7424
7424,7425
7425,7426
7427,7428
7427,7429
7428,7429
7428,7430
7429,7430
7431,7432
7431,7433
7432,7433
7436,7437
7436,7438
7436,7439
7436,7440
7437,7438
7439,7440
7441,7442
7442,7443
7443,7444
7445,7446
7445,7447
7446,7447
7446,7448
7447,7448
7449,7450
7449,7451
7450,7451
7454,7455
7454,7456
7454,7457
7455,7456
7456,7457
7456,7458
7456,7459
7457,7458
7459,7460
7460,7461
7460,7462
7461,7462
7461,7463
7462,7463
7464,7465
7464,7466
7465,7466
7469,7470
7471,7472
7472,7473
7472,7474
7473,7474
7475,7476
7475,7477
7476,7477
7479,7480
7479,7481
7480,7481
7480,7482
7481,7482
7481,7483
7482,7483
7484,7485
7484,7486
7485,7486
7488,7489
7488,7490
7489,7490
7489,7491
7490,7491
7492,7493
7492,7494
7493,7494
7497,7498
7497,7499
7497,7500
7497,7501
7497,7502
7497,7503
7498,7499
7499,7500
7499,7501
7501,7502
7501,7503
7503,7504
7505,7506
7506,7507
7506,7508
7506,7509
7507,7508
7509,7510
7509,7511
7510,7511
7512,7513
7512,7514
7513,7514
7513,7515
7514,7515
7516,7517
7516,7518
7517,7518
7521,7522
7521,7523
7522,7523
7522,7524
7523,7524
7525,7526
7525,7527
7526,7527
7530,7531
7531,7532
7531,7533
7531,7534
7531,7535
7532,7533
7536,7537
7536,7538
7536,7539
7536,7540
7537,7538
7539,7540
7541,7542
7542,7543
7543,7544
7545,7546
7545,7547
7546,7547
7548,7549
7548,7550
7549,7550
7549,7551
7550,7551
7552,7553
7552,7554
7553,7554
7557,7558
7557,7559
7558,7559
7558,7560
7559,7560
7559,7561
7560,7561
7562,7563
7562,7564
7563,7564
7563,7565
7564,7565
7566,7567
7566,7568
7567,7568
7572,7573
7573,7574
7573,7575
7573,7576
7574,7575
7576,7577
7576,7578
7577,7578
7577,7579
7578,7579
7580,7581
7580,7582
7581,7582
7585,7586
7585,7587
7586,7587
7588,7589
7588,7590
7589,7590
7589,7591
7590,7591
7592,7593
7592,7594
7593,7594
7597,7598
7597,7599
7598,7599
7598,7600
7599,7600
7599,7601
7600,7601
7602,7603
7602,7604
7603,7604
7603,7605
7604,7605
7606,7607
7606,7608
7607,7608
7612,7613
7613,7614
7613,7615
7613,7616
7614,7615
7616,7617
7616,7618
7617,7618
7617,7619
7618,7619
7620,7621
7620,7622
7621,7622
7625,7626
7625,7627
7626,7627
7628,7629
7628,7630
7629,7630
7629,7631
7630,7631
7632,7633
7632,7634
7633,7634
7637,7638
7638,7639
7638,7640
7639,7640
7641,7642
7641,7643
7642,7643
7642,7644
7643,7644
7645,7646
7645,7647
7646,7647
7650,7651
7650,7652
7651,7652
7651,7653
7652,7653
7654,7655
7654,7656
7655,7656
7658,7659
7658,7660
7658,7661
7658,7662
7658,7663
7659,7660
7660,7661
7660,7662
7661,7662
7663,7664
7664,7665
7664,7666
7667,7668
7668,7669
7668,7670
7668,7671
7668,7672
7669,7670
7671,7672
7672,7673
7672,7674
7673,7674
7673,7675
7674,7675
7676,7677
7676,7678
7677,7678
7681,7682
7683,7684
7685,7686
7686,7687
7686,7688
7687,7688
7688,7689
7689,7690
7689,7691
7690,7691
7690,7692
7691,7692
7694,7695
7696,7697
7697,7698
7697,7699
7697,7700
7698,7699
7700,7701
7702,7703
7702,7704
7703,7704
7706,7707
7707,7708
7707,7709
7708,7709
7710,7711
7711,7712
7714,7715
7715,7716
7717,7718
7718,7719
7718,7720
7718,7721
7718,7722
7718,7723
7718,7724
7718,7725
7718,7726
7719,7720
7721,7722
7721,7723
7722,7723
7724,7725
7724,7726
7725,7726
7728,7729
7730,7731
7732,7733
7732,7734
7733,7734
7736,7737
7739,7740
7742,7743
7743,7744
7745,7746
7745,7747
7745,7748
7746,7747
7747,7748
7747,7749
7748,7749
7750,7751
7752,7753
7753,7754
7753,7755
7753,7756
7754,7755
7756,7757
7756,7758
7757,7758
7759,7760
7759,7761
7760,7761
7763,7764
7764,7765
7766,7767
7767,7768
7767,7769
7767,7770
7767,7771
7767,7772
7767,7773
7767,7774
7767,7775
7768,7769
7770,7771
7770,7772
7771,7772
7773,7774
7773,7775
7774,7775
7777,7778
7779,7780
7781,7782
7781,7783
7782,7783
7785,7786
7785,7787
7786,7787
7789,7790
7789,7791
7790,7791
7793,7794
7796,7797
7797,7798
7799,7800
7800,7801
7800,7802
7801,7802
7801,7803
7802,7803
7802,7804
7803,7804
7805,7806
7805,7807
7806,7807
7810,7811
7810,7812
7811,7812
7811,7813
7811,7814
7811,7815
7812,7813
7814,7815
7814,7816
7815,7816
7817,7818
7817,7819
7818,7819
7822,7823
7823,7824
7825,7826
7825,7827
7826,7827
7829,7830
7830,7831
7830,7832
7830,7833
7831,7832
7833,7834
7835,7836
7836,7837
7838,7839
7839,7840
7839,7841
7840,7841
7842,7843
7842,7844
7843,7844
7846,7847
7846,7848
7847,7848
7847,7849
7848,7849
7848,7850
7849,7850
7851,7852
7851,7853
7852,7853
7856,7857
7856,7858
7856,7859
7856,7860
7856,7861
7856,7862
7856,7863
7856,7864
7856,7865
7856,7866
7856,7867
7857,7858
7858,7859
7858,7860
7859,7860
7861,7862
7861,7863
7862,7863
7862,7864
7863,7864
7865,7866
7865,7867
7866,7867
7870,7871
7870,7872
7870,7873
7871,7872
7871,7873
7872,7873
7873,7874
7873,7875
7874,7875
7874,7876
7875,7876
7879,7880
7880,7881
7880,7882
7881,7882
7881,7883
7882,7883
7885,7886
7885,7887
7886,7887
7889,7890
7890,7891
7890,7892
7891,7892
7891,7893
7892,7893
7892,7894
7893,7894
7893,7895
7894,7895
7896,7897
7896,7898
7897,7898
7901,7902
7901,7903
7902,7903
7905,7906
7905,7907
7905,7908
7906,7907
7907,7908
7907,7909
7907,7910
7907,7911
7907,7912
7908,7909
7910,7911
7913,7914
7913,7915
7914,7915
7917,7918
7917,7919
7918,7919
7918,7920
7919,7920
7921,7922
7921,7923
7922,7923
7926,7927
7927,7928
7927,7929
7927,7930
7927,7931
7927,7932
7927,7933
7928,7929
7930,7931
7934,7935
7934,7936
7935,7936
7938,7939
7938,7940
7939,7940
7939,7941
7940,7941
7942,7943
7942,7944
7943,7944
7947,7948
7948,7949
7948,7950
7948,7951
7948,7952
7949,7950
7951,7952
7954,7955
7954,7956
7955,7956
7958,7959
7958,7960
7959,7960
7959,7961
7960,7961
7961,7962
7961,7963
7962,7963
7962,7964
7963,7964
7967,7968
7968,7969
7968,7970
7969,7970
7969,7971
7970,7971
7973,7974
7973,7975
7974,7975
7977,7978
7978,7979
7978,7980
7979,7980
7979,7981
7980,7981
7980,7982
7981,7982
7981,7983
7982,7983
7984,7985
7984,7986
7985,7986
7989,7990
7989,7991
7990,7991
7993,7994
7993,7995
7993,7996
7994,7995
7995,7996
7995,7997
7995,7998
7995,7999
7995,8000
7996,7997
7998,7999
8001,8002
8001,8003
8002,8003
8005,8006
8005,8007
8006,8007
8006,8008
8007,8008
8009,8010
8009,8011
8010,8011
8014,8015
8015,8016
8015,8017
8015,8018
8015,8019
8015,8020
8015,8021
8016,8017
8018,8019
8022,8023
8022,8024
8023,8024
8026,8027
8026,8028
8027,8028
8027,8029
8028,8029
8030,8031
8030,8032
8031,8032
8035,8036
8036,8037
8036,8038
8036,8039
8036,8040
8037,8038
8039,8040
8042,8043
8042,8044
8043,8044
8046,8047
8047,8048
8047,8049
8048,8049
8048,8050
8049,8050
8052,8053
8052,8054
8053,8054
8053,8055
8054,8055
8056,8057
8056,8058
8057,8058
8061,8062
8061,8063
8061,8064
8062,8063
8062,8064
8063,8064
8063,8065
8064,8065
8067,8068
8068,8069
8068,8070
8069,8070
8069,8071
8070,8071
8073,8074
8075,8076
8076,8077
8076,8078
8077,8078
8077,8079
8078,8079
8081,8082
8081,8083
8082,8083
8083,8084
8083,8085
8084,8085
8084,8086
8085,8086
8085,8087
8086,8087
8088,8089
8088,8090
8089,8090
8093,8094
8093,8095
8094,8095
8098,8099
8098,8100
8098,8101
8099,8100
8099,8101
8100,8101
8100,8102
8101,8102
8104,8105
8104,8106
8105,8106
8105,8107
8106,8107
8110,8111
8111,8112
8111,8113
8112,8113
8112,8114
8113,8114
8116,8117
8116,8118
8117,8118
8118,8119
8118,8120
8120,8121
8120,8122
8121,8122
8125,8126
8126,8127
8126,8128
8127,8128
8127,8129
8128,8129
8131,8132
8131,8133
8132,8133
8132,8134
8133,8134
8135,8136
8135,8137
8136,8137
8140,8141
8140,8142
8141,8142
8141,8143
8142,8143
8142,8144
8143,8144
8146,8147
8148,8149
8149,8150
8149,8151
8150,8151
8151,8152
8151,8153
8151,8154
8152,8153
8154,8155
8156,8157
8156,8158
8157,8158
8160,8161
8160,8162
8161,8162
8162,8163
8162,8164
8163,8164
8165,8166
8167,8168
8168,8169
8168,8170
8169,8170
8169,8171
8170,8171
8173,8174
8175,8176
8175,8177
8175,8178
8176,8177
8176,8178
8177,8178
8178,8179
8178,8180
8179,8180
8179,8181
8180,8181
8184,8185
8185,8186
8185,8187
8186,8187
8186,8188
8187,8188
8190,8191
8190,8192
8191,8192
8194,8195
8195,8196
8195,8197
8196,8197
8196,8198
8197,8198
8200,8201
8200,8202
8200,8203
8200,8204
8200,8205
8201,8202
8203,8204
8205,8206
8205,8207
8206,8207
8209,8210
8211,8212
8211,8213
8212,8213
8214,8215
8216,8217
8217,8218
8217,8219
8218,8219
8218,8220
8219,8220
8222,8223
8222,8224
8222,8225
8222,8226
8222,8227
8223,8224
8225,8226
8227,8228
8227,8229
8228,8229
8231,8232
8233,8234
8233,8235
8234,8235
8236,8237
8238,8239
8238,8240
8239,8240
8239,8241
8240,8241
8240,8242
8241,8242
8244,8245
8246,8247
8247,8248
8247,8249
8248,8249
8250,8251
8252,8253
8253,8254
8253,8255
8253,8256
8253,8257
8253,8258
8253,8259
8253,8260
8253,8261
8254,8255
8256,8257
8256,8258
8257,8258
8259,8260
8259,8261
8260,8261
8263,8264
8265,8266
8267,8268
8267,8269
8268,8269
8271,8272
8274,8275
8274,8276
8275,8276
8278,8279
8279,8280
8279,8281
8280,8281
8282,8283
8282,8284
8283,8284
8286,8287
8287,8288
8287,8289
8288,8289
8288,8290
8289,8290
8293,8294
8294,8295
8294,8296
8294,8297
8294,8298
8294,8299
8294,8300
8294,8301
8295,8296
8299,8300
8299,8301
8300,8301
8303,8304
8303,8305
8304,8305
8307,8308
8307,8309
8308,8309
8311,8312
8311,8313
8312,8313
8316,8317
8317,8318
8319,8320
8320,8321
8322,8323
8323,8324
8323,8325
8324,8325
8324,8326
8325,8326
8329,8330
8330,8331
8330,8332
8331,8332
8331,8333
8332,8333
8336,8337
8337,8338
8337,8339
8338,8339
8338,8340
8339,8340
8343,8344
8344,8345
8344,8346
8345,8346
8345,8347
8346,8347
8350,8351
8351,8352
8351,8353
8351,8354
8352,8353
8354,8355
8356,8357
8357,8358
8359,8360
8359,8361
8359,8362
8360,8361
8360,8362
8361,8362
8361,8363
8362,8363
8362,8364
8363,8364
8367,8368
8369,8370
8369,8371
8370,8371
8371,8372
8371,8373
8372,8373
8372,8374
8373,8374
8373,8375
8374,8375
8374,8376
8375,8376
8380,8381
8382,8383
8383,8384
8383,8385
8383,8386
8383,8387
8383,8388
8383,8389
8383,8390
8383,8391
8384,8385
8386,8387
8386,8388
8387,8388
8389,8390
8389,8391
8390,8391
8393,8394
8394,8395
8394,8396
8395,8396
8398,8399
8398,8400
8399,8400
8402,8403
8407,8408
8407,8409
8407,8410
8407,8411
8408,8409
8409,8410
8409,8411
8411,8412
8413,8414
8414,8415
8414,8416
8415,8416
8417,8418
8417,8419
8417,8420
8417,8421
8418,8419
8420,8421
8420,8422
8421,8422
8423,8424
8423,8425
8424,8425
8428,8429
8429,8430
8429,8431
8430,8431
8433,8434
8434,8435
8434,8436
8435,8436
8435,8437
8436,8437
8436,8438
8437,8438
8439,8440
8439,8441
8440,8441
8444,8445
8444,8446
8445,8446
8447,8448
8447,8449
8448,8449
8451,8452
8451,8453
8452,8453
8454,8455
8455,8456
8455,8457
8455,8458
8455,8459
8455,8460
8456,8457
8460,8461
8460,8462
8461,8462
8463,8464
8463,8465
8464,8465
8464,8466
8465,8466
8465,8467
8466,8467
8468,8469
8468,8470
8469,8470
8474,8475
8474,8476
8475,8476
8475,8477
8476,8477
8478,8479
8478,8480
8479,8480
8484,8485
8485,8486
8487,8488
8487,8489
8488,8489
8488,8490
8488,8491
8489,8490
8491,8492
8492,8493
8492,8494
8493,8494
8493,8495
8494,8495
8496,8497
8496,8498
8497,8498
8501,8502
8501,8503
8502,8503
8504,8505
8506,8507
8506,8508
8507,8508
8508,8509
8508,8510
8508,8511
8508,8512
8509,8510
8511,8512
8514,8515
8514,8516
8514,8517
8515,8516
8515,8517
8516,8517
8516,8518
8517,8518
8519,8520
8519,8521
8520,8521
8524,8525
8524,8526
8525,8526
8527,8528
8527,8529
8528,8529
8528,8530
8529,8530
8531,8532
8531,8533
8532,8533
8538,8539
8538,8540
8539,8540
8539,8541
8539,8542
8539,8543
8539,8544
8539,8545
8540,8541
8542,8543
8542,8544
8543,8544
8545,8546
8545,8547
8546,8547
8549,8550
8550,8551
8550,8552
8551,8552
8551,8553
8552,8553
8554,8555
8554,8556
8555,8556
8559,8560
8560,8561
8562,8563
8562,8564
8563,8564
8563,8565
8564,8565
8566,8567
8566,8568
8567,8568
8571,8572
8571,8573
8572,8573
8572,8574
8573,8574
8575,8576
8575,8577
8576,8577
8580,8581
8581,8582
8583,8584
8584,8585
8584,8586
8584,8587
8584,8588
8584,8589
8585,8586
8587,8588
8590,8591
8590,8592
8590,8593
8591,8592
8591,8593
8592,8593
8595,8596
8595,8597
8596,8597
8600,8601
8600,8602
8601,8602
8603,8604
8603,8605
8604,8605
8604,8606
8605,8606
8605,8607
8606,8607
8608,8609
8608,8610
8609,8610
8614,8615
8615,8616
8615,8617
8615,8618
8616,8617
8618,8619
8618,8620
8619,8620
8622,8623
8623,8624
8626,8627
8627,8628
8629,8630
8629,8631
8630,8631
8632,8633
8633,8634
8633,8635
8633,8636
8633,8637
8633,8638
8633,8639
8633,8640
8633,8641
8634,8635
8636,8637
8636,8638
8637,8638
8639,8640
8639,8641
8640,8641
8643,8644
8645,8646
8647,8648
8647,8649
8648,8649
8651,8652
8654,8655
8654,8656
8655,8656
8658,8659
8658,8660
8659,8660
8659,8661
8659,8662
8660,8661
8662,8663
8663,8664
8663,8665
8664,8665
8664,8666
8665,8666
8667,8668
8667,8669
8668,8669
8672,8673
8672,8674
8673,8674
8675,8676
8677,8678
8677,8679
8678,8679
8679,8680
8679,8681
8679,8682
8679,8683
8680,8681
8682,8683
8685,8686
8685,8687
8685,8688
8686,8687
8686,8688
8687,8688
8687,8689
8688,8689
8690,8691
8690,8692
8691,8692
8695,8696
8695,8697
8696,8697
8698,8699
8698,8700
8699,8700
8699,8701
8700,8701
8702,8703
8702,8704
8703,8704
8709,8710
8709,8711
8710,8711
8710,8712
8710,8713
8711,8712
8713,8714
8713,8715
8714,8715
8716,8717
8716,8718
8717,8718
8720,8721
8721,8722
8723,8724
8723,8725
8723,8726
8723,8727
8724,8725
8724,8726
8725,8726
8727,8728
8728,8729
8728,8730
8728,8731
8728,8732
8728,8733
8729,8730
8731,8732
8734,8735
8734,8736
8735,8736
8737,8738
8737,8739
8738,8739
8738,8740
8739,8740
8739,8741
8740,8741
8742,8743
8742,8744
8743,8744
8748,8749
8748,8750
8749,8750
8749,8751
8750,8751
8752,8753
8752,8754
8753,8754
8757,8758
8758,8759
8758,8760
8758,8761
8758,8762
8759,8760
8761,8762
8762,8763
8765,8766
8766,8767
8767,8768
8769,8770
8770,8771
8770,8772
8770,8773
8771,8772
8773,8774
8773,8775
8774,8775
8777,8778
8780,8781
8780,8782
8780,8783
8781,8782
8781,8783
8781,8784
8782,8783
8784,8785
8784,8786
8785,8786
8785,8787
8786,8787
8788,8789
8788,8790
8789,8790
8794,8795
8795,8796
8796,8797
8796,8798
8797,8798
8799,8800
8799,8801
8799,8802
8799,8803
8799,8804
8799,8805
8800,8801
8802,8803
8804,8805
8804,8806
8805,8806
8805,8807
8806,8807
8808,8809
8808,8810
8809,8810
8813,8814
8813,8815
8814,8815
8814,8816
8815,8816
8817,8818
8817,8819
8818,8819
8823,8824
8823,8825
8824,8825
8824,8826
8825,8826
8827,8828
8827,8829
8828,8829
8832,8833
8833,8834
8833,8835
8834,8835
8837,8838
8837,8839
8837,8840
8838,8839
8838,8840
8839,8840
8839,8841
8839,8842
8840,8841
8842,8843
8842,8844
8843,8844
8843,8845
8844,8845
8846,8847
8846,8848
8847,8848
8852,8853
8853,8854
8855,8856
8855,8857
8855,8858
8855,8859
8855,8860
8855,8861
8856,8857
8856,8858
8857,8858
8859,8860
8860,8861
8860,8862
8860,8863
8860,8864
8860,8865
8860,8866
8861,8862
8863,8864
8866,8867
8866,8868
8867,8868
8869,8870
8869,8871
8870,8871
8873,8874
8873,8875
8874,8875
8874,8876
8875,8876
8877,8878
8877,8879
8878,8879
8882,8883
8882,8884
8883,8884
8883,8885
8884,8885
8886,8887
8886,8888
8887,8888
8891,8892
8892,8893
8892,8894
8892,8895
8892,8896
8893,8894
8895,8896
8896,8897
8899,8900
8900,8901
8901,8902
8903,8904
8904,8905
8904,8906
8904,8907
8904,8908
8905,8906
8907,8908
8908,8909
8910,8911
8913,8914
8914,8915
8914,8916
8914,8917
8914,8918
8915,8916
8917,8918
8918,8919
8920,8921
8922,8923
8924,8925
8925,8926
8925,8927
8925,8928
8925,8929
8925,8930
8925,8931
8925,8932
8925,8933
8926,8927
8928,8929
8928,8930
8929,8930
8931,8932
8931,8933
8932,8933
8935,8936
8937,8938
8940,8941
8940,8942
8941,8942
8944,8945
8944,8946
8945,8946
8948,8949
8950,8951
8950,8952
8951,8952
8952,8953
8952,8954
8953,8954
8955,8956
8955,8957
8956,8957
8959,8960
8961,8962
8961,8963
8961,8964
8962,8963
8962,8964
8962,8965
8963,8964
8963,8965
8963,8966
8964,8965
8966,8967
8966,8968
8967,8968
8969,8970
8969,8971
8970,8971
8973,8974
8975,8976
8975,8977
8975,8978
8975,8979
8975,8980
8976,8977
8976,8978
8976,8979
8977,8978
8977,8979
8977,8980
8978,8979
8980,8981
8980,8982
8981,8982
8983,8984
8983,8985
8984,8985
8987,8988
8989,8990
8990,8991
8991,8992
8991,8993
8992,8993
8995,8996
8996,8997
8997,8998
8997,8999
8998,8999
9001,9002
9002,9003
9002,9004
9003,9004
9005,9006
9005,9007
9006,9007
9006,9008
9007,9008
9007,9009
9008,9009
9010,9011
9010,9012
9011,9012
9015,9016
9015,9017
9016,9017
9016,9018
9017,9018
9019,9020
9019,9021
9020,9021
9024,9025
9025,9026
9025,9027
9025,9028
9025,9029
9026,9027
9028,9029
9029,9030
9032,9033
9033,9034
9034,9035
9036,9037
9037,9038
9037,9039
9037,9040
9038,9039
9040,9041
9043,9044
9044,9045
9044,9046
9044,9047
9045,9046
9047,9048
9050,9051
9050,9052
9050,9053
9050,9054
9050,9055
9050,9056
9050,9057
9051,9052
9052,9053
9052,9054
9053,9054
9055,9056
9057,9058
9058,9059
9058,9060
9059,9060
9062,9063
9062,9064
9063,9064
9063,9065
9064,9065
9067,9068
9068,9069
9068,9070
9068,9071
9068,9072
9068,9073
9069,9070
9071,9072
9072,9073
9072,9074
9073,9074
9073,9075
9074,9075
9076,9077
9076,9078
9077,9078
9081,9082
9081,9083
9082,9083
9087,9088
9087,9089
9087,9090
9088,9089
9088,9090
9088,9091
9088,9092
9089,9090
9091,9092
9092,9093
9092,9094
9093,9094
9093,9095
9094,9095
9096,9097
9096,9098
9097,9098
9102,9103
9103,9104
9105,9106
9106,9107
9106,9108
9106,9109
9107,9108
9107,9109
9107,9110
9108,9109
9110,9111
9110,9112
9111,9112
9113,9114
9113,9115
9114,9115
9117,9118
9119,9120
9119,9121
9120,9121
9121,9122
9121,9123
9122,9123
9124,9125
9124,9126
9125,9126
9125,9127
9126,9127
9128,9129
9128,9130
9129,9130
9133,9134
9134,9135
9134,9136
9135,9136
9138,9139
9139,9140
9140,9141
9140,9142
9141,9142
9143,9144
9143,9145
9144,9145
9144,9146
9145,9146
9147,9148
9147,9149
9148,9149
9152,9153
9153,9154
9153,9155
9154,9155
9156,9157
9156,9158
9157,9158
9157,9159
9158,9159
9160,9161
9160,9162
9161,9162
9165,9166
9166,9167
9166,9168
9167,9168
9169,9170
9169,9171
9169,9172
9169,9173
9170,9171
9172,9173
9173,9174
9175,9176
9175,9177
9176,9177
9176,9178
9177,9178
9177,9179
9178,9179
9180,9181
9180,9182
9181,9182
9185,9186
9185,9187
9186,9187
9186,9188
9187,9188
9189,9190
9189,9191
9190,9191
9195,9196
9196,9197
9196,9198
9196,9199
9196,9200
9197,9198
9199,9200
9200,9201
9200,9202
9201,9202
9201,9203
9202,9203
9204,9205
9204,9206
9205,9206
9209,9210
9211,9212
9211,9213
9212,9213
9213,9214
9214,9215
9217,9218
9218,9219
9218,9220
9218,9221
9218,9222
9219,9220
9221,9222
9222,9223
9222,9224
9223,9224
9223,9225
9224,9225
9226,9227
9226,9228
9227,9228
9231,9232
9233,9234
9233,9235
9234,9235
9235,9236
9236,9237
9239,9240
9239,9241
9240,9241
9241,9242
9243,9244
9243,9245
9243,9246
9244,9245
9245,9246
9245,9247
9245,9248
9245,9249
9247,9248
9247,9249
9249,9250
9251,9252
9251,9253
9253,9254
9255,9256
9255,9257
9257,9258
9259,9260
9259,9261
9260,9261
9261,9262
9261,9263
9261,9264
9262,9263
9264,9265
9264,9266
9265,9266
9267,9268
9267,9269
9268,9269
9271,9272
9273,9274
9273,9275
9274,9275
9275,9276
9275,9277
9275,9278
9275,9279
9275,9280
9276,9277
9280,9281
9280,9282
9281,9282
9283,9284
9283,9285
9284,9285
9284,9286
9285,9286
9287,9288
9287,9289
9288,9289
9292,9293
9292,9294
9292,9295
9292,9296
9293,9294
9295,9296
9297,9298
9298,9299
9299,9300
9301,9302
9301,9303
9302,9303
9302,9304
9303,9304
9305,9306
9305,9307
9306,9307
9310,9311
9311,9312
9311,9313
9312,9313
9314,9315
9314,9316
9315,9316
9315,9317
9316,9317
9316,9318
9317,9318
9319,9320
9319,9321
9320,9321
9324,9325
9324,9326
9325,9326
9325,9327
9326,9327
9328,9329
9328,9330
9329,9330
9333,9334
9333,9335
9333,9336
9334,9335
9335,9336
9337,9338
9337,9339
9337,9340
9337,9341
9337,9342
9337,9343
9338,9339
9338,9340
9339,9340
9341,9342
9342,9343
9342,9344
9342,9345
9343,9344
9343,9345
9343,9346
9344,9345
9346,9347
9346,9348
9347,9348
9349,9350
9349,9351
9350,9351
9353,9354
9355,9356
9356,9357
9357,9358
9357,9359
9357,9360
9357,9361
9357,9362
9357,9363
9358,9359
9360,9361
9363,9364
9363,9365
9364,9365
9366,9367
9366,9368
9367,9368
9370,9371
9370,9372
9370,9373
9370,9374
9371,9372
9373,9374
9375,9376
9376,9377
9377,9378
9379,9380
9379,9381
9380,9381
9380,9382
9381,9382
9383,9384
9383,9385
9384,9385
9388,9389
9388,9390
9388,9391
9388,9392
9389,9390
9391,9392
9393,9394
9394,9395
9395,9396
9397,9398
9397,9399
9398,9399
9398,9400
9399,9400
9401,9402
9401,9403
9402,9403
9406,9407
9407,9408
9408,9409
9408,9410
9408,9411
9408,9412
9408,9413
9408,9414
9408,9415
9409,9410
9411,9412
9414,9415
9414,9416
9415,9416
9417,9418
9417,9419
9418,9419
9421,9422
9421,9423
9421,9424
9421,9425
9422,9423
9424,9425
9426,9427
9427,9428
9428,9429
9430,9431
9430,9432
9431,9432
9431,9433
9432,9433
9434,9435
9434,9436
9435,9436
9439,9440
9439,9441
9439,9442
9439,9443
9440,9441
9442,9443
9444,9445
9445,9446
9446,9447
9448,9449
9448,9450
9449,9450
9449,9451
9450,9451
9452,9453
9452,9454
9453,9454
9457,9458
9457,9459
9457,9460
9457,9461
9458,9459
9460,9461
9462,9463
9463,9464
9464,9465
9466,9467
9466,9468
9467,9468
9467,9469
9468,9469
9470,9471
9470,9472
9471,9472
9475,9476
9476,9477
9476,9478
9476,9479
9476,9480
9477,9478
9479,9480
9480,9481
9483,9484
9484,9485
9485,9486
9487,9488
9488,9489
9488,9490
9488,9491
9488,9492
9489,9490
9491,9492
9492,9493
9494,9495
9497,9498
9498,9499
9498,9500
9498,9501
9498,9502
9499,9500
9501,9502
9502,9503
9504,9505
9506,9507
9508,9509
9509,9510
9509,9511
9509,9512
9509,9513
9509,9514
9509,9515
9509,9516
9509,9517
9510,9511
9512,9513
9512,9514
9513,9514
9515,9516
9515,9517
9516,9517
9519,9520
9521,9522
9524,9525
9524,9526
9525,9526
9528,9529
9528,9530
9529,9530
9532,9533
9534,9535
9534,9536
9535,9536
9536,9537
9536,9538
9537,9538
9539,9540
9539,9541
9540,9541
9543,9544
9545,9546
9545,9547
9546,9547
9546,9548
9546,9549
9547,9548
9547,9549
9547,9550
9548,9549
9550,9551
9550,9552
9551,9552
9553,9554
9553,9555
9554,9555
9557,9558
9559,9560
9560,9561
9560,9562
9561,9562
9562,9563
9563,9564
9563,9565
9564,9565
9564,9566
9565,9566
9565,9567
9566,9567
9568,9569
9568,9570
9569,9570
9573,9574
9573,9575
9574,9575
9574,9576
9575,9576
9577,9578
9577,9579
9578,9579
9582,9583
9583,9584
9583,9585
9584,9585
9587,9588
9588,9589
9588,9590
9588,9591
9589,9590
9589,9591
9589,9592
9590,9591
9592,9593
9592,9594
9593,9594
9595,9596
9595,9597
9596,9597
9599,9600
9601,9602
9601,9603
9601,9604
9601,9605
9601,9606
9602,9603
9603,9604
9603,9605
9604,9605
9606,9607
9606,9608
9606,9609
9607,9608
9607,9609
9607,9610
9608,9609
9610,9611
9610,9612
9611,9612
9613,9614
9613,9615
9614,9615
9617,9618
9621,9622
9622,9623
9622,9624
9622,9625
9622,9626
9623,9624
9625,9626
9626,9627
9629,9630
9630,9631
9631,9632
9633,9634
9634,9635
9634,9636
9635,9636
9637,9638
9637,9639
9637,9640
9638,9639
9638,9640
9638,9641
9639,9640
9641,9642
9641,9643
9642,9643
9644,9645
9644,9646
9645,9646
9648,9649
9650,9651
9650,9652
9651,9652
9651,9653
9652,9653
9654,9655
9654,9656
9655,9656
9659,9660
9659,9661
9660,9661
9662,9663
9662,9664
9663,9664
9663,9665
9664,9665
9664,9666
9665,9666
9667,9668
9667,9669
9668,9669
9672,9673
9672,9674
9673,9674
9673,9675
9674,9675
9676,9677
9676,9678
9677,9678
9681,9682
9682,9683
9682,9684
9682,9685
9683,9684
9685,9686
9688,9689
9689,9690
9689,9691
9689,9692
9690,9691
9692,9693
9695,9696
9695,9697
9695,9698
9696,9697
9697,9698
9697,9699
9698,9699
9700,9701
9702,9703
9703,9704
9703,9705
9704,9705
9707,9708
9707,9709
9707,9710
9708,9709
9708,9710
9708,9711
9708,9712
9709,9710
9711,9712
9712,9713
9712,9714
9713,9714
9713,9715
9714,9715
9716,9717
9716,9718
9717,9718
9722,9723
9723,9724
9725,9726
9725,9727
9726,9727
9726,9728
9726,9729
9727,9728
9727,9729
9727,9730
9728,9729
9730,9731
9730,9732
9731,9732
9733,9734
9733,9735
9734,9735
9737,9738
9739,9740
9740,9741
9741,9742
9741,9743
9742,9743
9744,9745
9744,9746
9745,9746
9745,9747
9746,9747
9748,9749
9748,9750
9749,9750
9753,9754
9753,9755
9754,9755
9755,9756
9755,9757
9756,9757
9758,9759
9758,9760
9759,9760
9759,9761
9760,9761
9762,9763
9762,9764
9763,9764
9767,9768
9768,9769
9768,9770
9769,9770
9772,9773
9773,9774
9773,9775
9774,9775
9776,9777
9776,9778
9776,9779
9776,9780
9777,9778
9779,9780
9780,9781
9782,9783
9782,9784
9783,9784
9783,9785
9784,9785
9784,9786
9785,9786
9787,9788
9787,9789
9788,9789
9792,9793
9792,9794
9793,9794
9793,9795
9794,9795
9796,9797
9796,9798
9797,9798
9802,9803
9803,9804
9803,9805
9804,9805
9806,9807
9806,9808
9807,9808
9809,9810
9809,9811
9810,9811
9810,9812
9811,9812
9811,9813
9812,9813
9814,9815
9814,9816
9815,9816
9819,9820
9819,9821
9820,9821
9820,9822
9821,9822
9823,9824
9823,9825
9824,9825
9828,9829
9828,9830
9829,9830
9830,9831
9832,9833
9832,9834
9832,9835
9832,9836
9832,9837
9832,9838
9832,9839
9832,9840
9833,9834
9834,9835
9834,9836
9834,9837
9834,9838
9836,9837
9836,9838
9838,9839
9840,9841
9840,9842
9842,9843
9844,9845
9844,9846
9846,9847
9848,9849
9849,9850
9849,9851
9849,9852
9849,9853
9850,9851
9852,9853
9855,9856
9855,9857
9855,9858
9855,9859
9856,9857
9858,9859
9860,9861
9861,9862
9862,9863
9864,9865
9864,9866
9865,9866
9865,9867
9866,9867
9866,9868
9867,9868
9869,9870
9869,9871
9870,9871
9874,9875
9874,9876
9875,9876
9875,9877
9876,9877
9878,9879
9878,9880
9879,9880
9883,9884
9883,9885
9884,9885
9886,9887
9887,9888
9887,9889
9887,9890
9888,9889
9888,9890
9888,9891
9889,9890
9891,9892
9891,9893
9892,9893
9894,9895
9894,9896
9895,9896
9898,9899
9900,9901
9901,9902
9902,9903
9902,9904
9902,9905
9902,9906
9902,9907
9902,9908
9903,9904
9905,9906
9908,9909
9908,9910
9909,9910
9911,9912
9911,9913
9912,9913
9915,9916
9915,9917
9915,9918
9915,9919
9916,9917
9918,9919
9920,9921
9921,9922
9922,9923
9924,9925
9924,9926
9925,9926
9925,9927
9926,9927
9928,9929
9928,9930
9929,9930
9933,9934
9933,9935
9933,9936
9933,9937
9934,9935
9936,9937
9938,9939
9939,9940
9940,9941
9942,9943
9942,9944
9943,9944
9943,9945
9944,9945
9946,9947
9946,9948
9947,9948
9951,9952
9952,9953
9953,9954
9953,9955
9953,9956
9953,9957
9953,9958
9953,9959
9953,9960
9954,9955
9956,9957
9959,9960
9959,9961
9960,9961
9962,9963
9962,9964
9963,9964
9966,9967
9966,9968
9966,9969
9966,9970
9967,9968
9969,9970
9971,9972
9972,9973
9973,9974
9975,9976
9975,9977
9976,9977
9976,9978
9977,9978
9979,9980
9979,9981
9980,9981
9984,9985
9984,9986
9984,9987
9984,9988
9985,9986
9987,9988
9989,9990
9990,9991
9991,9992
9993,9994
9993,9995
9994,9995
9994,9996
9995,9996
9997,9998
9997,9999
9998,9999
10002,10003
10002,10004
10002,10005
10002,10006
10003,10004
10005,10006
10007,10008
10008,10009
10009,10010
10011,10012
10011,10013
10012,10013
10012,10014
10013,10014
10015,10016
10015,10017
10016,10017
10020,10021
10021,10022
10021,10023
10021,10024
10021,10025
10022,10023
10024,10025
10025,10026
10028,10029
10029,10030
10030,10031
10032,10033
10033,10034
10033,10035
10033,10036
10033,10037
10034,10035
10036,10037
10037,10038
10039,10040
10042,10043
10043,10044
10043,10045
10043,10046
10043,10047
10044,10045
10046,10047
10047,10048
10049,10050
10051,10052
10053,10054
10054,10055
10054,10056
10054,10057
10054,10058
10054,10059
10054,10060
10054,10061
10054,10062
10055,10056
10057,10058
10057,10059
10058,10059
10060,10061
10060,10062
10061,10062
10064,10065
10066,10067
10069,10070
10069,10071
10070,10071
10073,10074
10073,10075
10074,10075
10077,10078
10079,10080
10079,10081
10080,10081
10081,10082
10081,10083
10082,10083
10084,10085
10084,10086
10085,10086
10088,10089
10090,10091
10090,10092
10091,10092
10093,10094
10093,10095
10093,10096
10093,10097
10093,10098
10094,10095
10095,10096
10095,10097
10095,10098
10095,10099
10096,10097
10098,10099
10099,10100
10102,10103
10103,10104
10104,10105
10106,10107
10107,10108
10107,10109
10107,10110
10107,10111
10108,10109
10110,10111
10111,10112
10113,10114
10115,10116
10117,10118
10118,10119
10118,10120
10118,10121
10118,10122
10118,10123
10119,10120
10121,10122
10122,10123
10124,10125
10127,10128
10129,10130
10130,10131
10130,10132
10130,10133
10130,10134
10130,10135
10130,10136
10130,10137
10130,10138
10131,10132
10133,10134
10133,10135
10134,10135
10136,10137
10136,10138
10137,10138
10140,10141
10142,10143
10145,10146
10145,10147
10146,10147
10149,10150
10149,10151
10150,10151
10153,10154
10155,10156
10155,10157
10155,10158
10156,10157
10156,10158
10156,10159
10157,10158
10159,10160
10159,10161
10160,10161
10160,10162
10161,10162
10163,10164
10163,10165
10164,10165
10169,10170
10169,10171
10169,10172
10169,10173
10170,10171
10171,10172
10171,10173
10171,10174
10172,10173
10174,10175
10175,10176
10175,10177
10176,10177
10176,10178
10177,10178
10179,10180
10179,10181
10180,10181
10184,10185
10186,10187
10187,10188
10187,10189
10187,10190
10187,10191
10187,10192
10187,10193
10187,10194
10187,10195
10187,10196
10187,10197
10187,10198
10187,10199
10187,10200
10187,10201
10188,10189
10192,10193
10192,10194
10193,10194
10195,10196
10195,10197
10196,10197
10199,10200
10201,10202
10201,10203
10202,10203
10204,10205
10204,10206
10205,10206
10205,10207
10206,10207
10208,10209
10208,10210
10209,10210
10213,10214
10215,10216
10217,10218
10219,10220
10219,10221
10220,10221
10222,10223
10224,10225
10226,10227
10228,10229
10230,10231
10232,10233
10233,10234
10233,10235
10233,10236
10234,10235
10236,10237
10237,10238
10237,10239
10238,10239
10238,10240
10239,10240
10241,10242
10241,10243
10242,10243
10246,10247
10248,10249
10248,10250
10248,10251
10249,10250
10250,10251
10251,10252
10251,10253
10252,10253
10254,10255
10254,10256
10254,10257
10254,10258
10254,10259
10255,10256
10257,10258
10257,10259
10258,10259
10261,10262
10263,10264
10265,10266
10267,10268
10268,10269
10268,10270
10269,10270
10271,10272
10271,10273
10272,10273
10275,10276
10275,10277
10276,10277
10276,10278
10277,10278
10280,10281
10280,10282
10280,10283
10280,10284
10280,10285
10280,10286
10281,10282
10282,10283
10282,10284
10283,10284
10285,10286
10285,10287
10288,10289
10289,10290
10289,10291
10289,10292
10290,10291
10292,10293
10292,10294
10295,10296
10295,10297
10295,10298
10298,10299
10299,10300
10301,10302
10302,10303
10303,10304
10303,10305
10304,10305
10306,10307
10306,10308
10306,10309
10307,10308
10310,10311
10311,10312
10312,10313
10313,10314
10315,10316
10316,10317
10316,10318
10317,10318
10319,10320
10319,10321
10319,10322
10320,10321
10322,10323
10323,10324
10325,10326
10327,10328
10327,10329
10327,10330
10328,10329
10328,10330
10329,10330
10331,10332
10333,10334
10333,10335
10333,10336
10333,10337
10333,10338
10333,10339
10333,10340
10333,10341
10334,10335
10335,10336
10335,10337
10336,10337
10336,10338
10337,10338
10340,10341
10342,10343
10343,10344
10343,10345
10344,10345
10344,10346
10345,10346
10348,10349
10350,10351
10351,10352
10351,10353
10352,10353
10354,10355
10355,10356
10357,10358
10358,10359
10358,10360
10358,10361
10359,10360
10363,10364
10363,10365
10363,10366
10363,10367
10364,10365
10365,10366
10365,10367
10366,10367
10368,10369
10368,10370
10369,10370
10372,10373
10374,10375
10374,10376
10375,10376
10377,10378
10377,10379
10378,10379
10381,10382
10381,10383
10381,10384
10381,10385
10382,10383
10383,10384
10383,10385
10384,10385
10386,10387
10386,10388
10386,10389
10389,10390
10390,10391
10390,10392
10390,10393
10391,10392
10393,10394
10393,10395
10394,10395
10397,10398
10397,10399
10398,10399
10401,10402
10401,10403
10402,10403
10404,10405
10405,10406
10405,10407
10406,10407
10408,10409
10410,10411
10411,10412
10411,10413
10412,10413
10414,10415
10416,10417
10416,10418
10416,10419
10417,10418
10418,10419
10420,10421
10421,10422
10422,10423
10422,10424
10422,10425
10423,10424
10425,10426
10428,10429
10429,10430
10430,10431
10430,10432
10430,10433
10430,10434
10431,10432
10433,10434
10435,10436
10437,10438
10439,10440
10439,10441
10440,10441
10442,10443
10443,10444
10443,10445
10444,10445
10446,10447
10448,10449
10449,10450
10449,10451
10450,10451
10450,10452
10451,10452
10454,10455
10456,10457
10457,10458
10457,10459
10457,10460
10458,10459
10460,10461
10462,10463
10464,10465
10464,10466
10464,10467
10465,10466
10466,10467
10466,10468
10466,10469
10467,10468
10469,10470
10472,10473
10472,10474
10473,10474
10475,10476
10476,10477
10476,10478
10477,10478
10479,10480
10481,10482
10481,10483
10482,10483
10484,10485
10485,10486
10485,10487
10486,10487
10488,10489
10489,10490
10491,10492
10491,10493
10491,10494
10492,10493
10493,10494
10493,10495
10493,10496
10494,10495
10496,10497
10497,10498
10497,10499
10498,10499
10498,10500
10499,10500
10501,10502
10501,10503
10502,10503
10506,10507
10508,10509
10509,10510
10509,10511
10509,10512
10509,10513
10510,10511
10514,10515
10514,10516
10515,10516
10517,10518
10517,10519
10518,10519
10521,10522
10521,10523
10522,10523
10522,10524
10522,10525
10523,10524
10525,10526
10525,10527
10526,10527
10528,10529
10528,10530
10529,10530
10532,10533
10534,10535
10535,10536
10538,10539
10539,10540
10541,10542
10541,10543
10543,10544
10543,10545
10544,10545
10544,10546
10544,10547
10545,10546
10547,10548
10548,10549
10548,10550
10549,10550
10549,10551
10550,10551
10552,10553
10552,10554
10553,10554
10557,10558
10559,10560
10559,10561
10559,10562
10560,10561
10561,10562
10561,10563
10561,10564
10562,10563
10564,10565
10565,10566
10565,10567
10566,10567
10566,10568
10567,10568
10569,10570
10569,10571
10570,10571
10574,10575
10576,10577
10577,10578
10577,10579
10577,10580
10577,10581
10578,10579
10580,10581
10580,10582
10581,10582
10583,10584
10583,10585
10584,10585
10587,10588
10589,10590
10589,10591
10589,10592
10590,10591
10590,10592
10591,10592
10594,10595
10594,10596
10595,10596
10599,10600
10599,10601
10599,10602
10600,10601
10601,10602
10601,10603
10601,10604
10601,10605
10601,10606
10601,10607
10602,10603
10604,10605
10606,10607
10606,10608
10607,10608
10607,10609
10608,10609
10610,10611
10610,10612
10611,10612
10615,10616
10615,10617
10616,10617
10616,10618
10617,10618
10619,10620
10619,10621
10620,10621
10625,10626
10625,10627
10626,10627
10626,10628
10627,10628
10629,10630
10629,10631
10630,10631
10634,10635
10634,10636
10634,10637
10634,10638
10634,10639
10634,10640
10635,10636
10635,10637
10636,10637
10638,10639
10639,10640
10639,10641
10639,10642
10639,10643
10639,10644
10639,10645
10640,10641
10642,10643
10645,10646
10645,10647
10646,10647
10648,10649
10648,10650
10649,10650
10652,10653
10652,10654
10653,10654
10653,10655
10654,10655
10656,10657
10656,10658
10657,10658
10661,10662
10661,10663
10662,10663
10662,10664
10663,10664
10665,10666
10665,10667
10666,10667
10670,10671
10671,10672
10671,10673
10671,10674
10671,10675
10672,10673
10674,10675
10675,10676
10678,10679
10679,10680
10680,10681
10682,10683
10683,10684
10683,10685
10683,10686
10683,10687
10684,10685
10686,10687
10687,10688
10689,10690
10692,10693
10693,10694
10693,10695
10693,10696
10693,10697
10694,10695
10696,10697
10697,10698
10699,10700
10701,10702
10703,10704
10704,10705
10704,10706
10704,10707
10704,10708
10704,10709
10704,10710
10704,10711
10704,10712
10705,10706
10707,10708
10707,10709
10708,10709
10710,10711
10710,10712
10711,10712
10714,10715
10716,10717
10719,10720
10719,10721
10720,10721
10723,10724
10723,10725
10724,10725
10727,10728
10729,10730
10729,10731
10730,10731
10731,10732
10731,10733
10732,10733
10734,10735
10734,10736
10735,10736
10738,10739
10740,10741
10740,10742
10740,10743
10740,10744
10740,10745
10740,10746
10741,10742
10742,10743
10742,10744
10744,10745
10744,10746
10746,10747
10748,10749
10749,10750
10749,10751
10749,10752
10750,10751
10752,10753
10753,10754
10753,10755
10754,10755
10754,10756
10755,10756
10757,10758
10757,10759
10758,10759
10762,10763
10764,10765
10765,10766
10765,10767
10765,10768
10765,10769
10765,10770
10766,10767
10770,10771
10770,10772
10771,10772
10773,10774
10773,10775
10774,10775
10777,10778
10777,10779
10777,10780
10777,10781
10778,10779
10780,10781
10782,10783
10783,10784
10784,10785
10786,10787
10786,10788
10787,10788
10787,10789
10788,10789
10790,10791
10790,10792
10791,10792
10795,10796
10796,10797
10796,10798
10796,10799
10797,10798
10799,10800
10800,10801
10800,10802
10801,10802
10801,10803
10802,10803
10804,10805
10804,10806
10805,10806
10809,10810
10811,10812
10812,10813
10812,10814
10812,10815
10812,10816
10812,10817
10812,10818
10812,10819
10812,10820
10813,10814
10815,10816
10815,10817
10816,10817
10818,10819
10818,10820
10819,10820
10822,10823
10824,10825
10827,10828
10830,10831
10832,10833
10832,10834
10832,10835
10833,10834
10834,10835
10835,10836
10835,10837
10836,10837
10838,10839
10838,10840
10838,10841
10838,10842
10838,10843
10839,10840
10841,10842
10841,10843
10842,10843
10845,10846
10847,10848
10847,10849
10848,10849
10848,10850
10849,10850
10851,10852
10851,10853
10852,10853
10856,10857
10858,10859
10859,10860
10859,10861
10860,10861
10862,10863
10862,10864
10863,10864
10866,10867
10866,10868
10867,10868
10867,10869
10868,10869
10871,10872
10871,10873
10871,10874
10871,10875
10871,10876
10871,10877
10871,10878
10872,10873
10873,10874
10873,10875
10874,10875
10876,10877
10876,10878
10879,10880
10880,10881
10880,10882
10880,10883
10881,10882
10883,10884
10883,10885
10886,10887
10886,10888
10886,10889
10889,10890
10890,10891
10892,10893
10893,10894
10894,10895
10894,10896
10895,10896
10897,10898
10897,10899
10897,10900
10898,10899
10901,10902
10902,10903
10903,10904
10904,10905
10906,10907
10907,10908
10907,10909
10908,10909
10910,10911
10910,10912
10910,10913
10911,10912
10913,10914
10914,10915
10916,10917
10918,10919
10919,10920
10919,10921
10919,10922
10920,10921
10924,10925
10924,10926
10924,10927
10925,10926
10925,10927
10926,10927
10928,10929
10930,10931
10930,10932
10930,10933
10930,10934
10930,10935
10930,10936
10930,10937
10931,10932
10932,10933
10932,10934
10933,10934
10933,10935
10934,10935
10937,10938
10939,10940
10940,10941
10940,10942
10941,10942
10941,10943
10942,10943
10945,10946
10947,10948
10948,10949
10948,10950
10949,10950
10951,10952
10952,10953
10954,10955
10954,10956
10954,10957
10954,10958
10955,10956
10956,10957
10956,10958
10957,10958
10959,10960
10959,10961
10960,10961
10963,10964
10965,10966
10965,10967
10966,10967
10968,10969
10968,10970
10969,10970
10972,10973
10972,10974
10972,10975
10972,10976
10973,10974
10974,10975
10974,10976
10975,10976
10977,10978
10977,10979
10977,10980
10980,10981
10981,10982
10981,10983
10981,10984
10982,10983
10984,10985
10984,10986
10985,10986
10988,10989
10988,10990
10989,10990
10992,10993
10992,10994
10993,10994
10995,10996
10996,10997
10996,10998
10997,10998
10999,11000
11001,11002
11002,11003
11002,11004
11003,11004
11005,11006
11007,11008
11007,11009
11007,11010
11008,11009
11009,11010
11011,11012
11012,11013
11013,11014
11013,11015
11013,11016
11014,11015
11016,11017
11019,11020
11020,11021
11021,11022
11021,11023
11021,11024
11021,11025
11022,11023
11024,11025
11026,11027
11028,11029
11030,11031
11030,11032
11031,11032
11033,11034
11034,11035
11034,11036
11035,11036
11037,11038
11039,11040
11040,11041
11040,11042
11041,11042
11041,11043
11042,11043
11045,11046
11047,11048
11048,11049
11048,11050
11048,11051
11049,11050
11051,11052
11053,11054
11055,11056
11055,11057
11055,11058
11056,11057
11057,11058
11057,11059
11057,11060
11058,11059
11060,11061
11063,11064
11063,11065
11064,11065
11066,11067
11067,11068
11067,11069
11068,11069
11070,11071
11072,11073
11072,11074
11073,11074
11075,11076
11076,11077
11076,11078
11077,11078
11079,11080
11080,11081
11083,11084
11084,11085
11086,11087
11087,11088
11087,11089
11088,11089
11088,11090
11089,11090
11089,11091
11090,11091
11092,11093
11092,11094
11093,11094
11097,11098
11099,11100
11100,11101
11100,11102
11100,11103
11100,11104
11101,11102
11105,11106
11105,11107
11106,11107
11109,11110
11110,11111
11110,11112
11111,11112
11113,11114
11113,11115
11114,11115
11117,11118
11118,11119
11118,11120
11118,11121
11118,11122
11119,11120
11123,11124
11123,11125
11124,11125
11128,11129
11129,11130
11131,11132
11132,11133
11132,11134
11132,11135
11133,11134
11137,11138
11138,11139
11138,11140
11138,11141
11139,11140
11141,11142
11141,11143
11142,11143
11145,11146
11145,11147
11146,11147
11150,11151
11151,11152
11153,11154
11154,11155
11156,11157
11156,11158
11157,11158
11159,11160
11160,11161
11160,11162
11160,11163
11160,11164
11160,11165
11160,11166
11160,11167
11160,11168
11161,11162
11163,11164
11163,11165
11164,11165
11166,11167
11166,11168
11167,11168
11170,11171
11172,11173
11174,11175
11174,11176
11175,11176
11178,11179
11181,11182
11181,11183
11182,11183
11185,11186
11185,11187
11186,11187
11186,11188
11186,11189
11186,11190
11187,11188
11189,11190
11189,11191
11190,11191
11193,11194
11194,11195
11196,11197
11197,11198
11199,11200
11199,11201
11199,11202
11200,11201
11200,11202
11201,11202
11202,11203
11202,11204
11203,11204
11205,11206
11205,11207
11206,11207
11209,11210
11211,11212
11212,11213
11212,11214
11212,11215
11213,11214
11215,11216
11215,11217
11216,11217
11219,11220
11222,11223
11222,11224
11223,11224
11224,11225
11224,11226
11225,11226
11227,11228
11227,11229
11228,11229
11231,11232
11233,11234
11233,11235
11234,11235
11234,11236
11235,11236
11236,11237
11236,11238
11237,11238
11237,11239
11238,11239
11240,11241
11240,11242
11241,11242
11241,11243
11242,11243
11244,11245
11244,11246
11245,11246
11249,11250
11249,11251
11250,11251
11252,11253
11252,11254
11253,11254
11253,11255
11254,11255
11256,11257
11256,11258
11257,11258
11261,11262
11261,11263
11261,11264
11262,11263
11264,11265
11265,11266
11265,11267
11266,11267
11266,11268
11267,11268
11269,11270
11269,11271
11270,11271
11274,11275
11276,11277
11276,11278
11276,11279
11276,11280
11276,11281
11277,11278
11277,11279
11278,11279
11278,11280
11279,11280
11279,11281
11280,11281
11280,11282
11281,11282
11285,11286
11287,11288
11287,11289
11288,11289
11289,11290
11289,11291
11289,11292
11289,11293
11290,11291
11292,11293
11293,11294
11296,11297
11297,11298
11298,11299
11300,11301
11301,11302
11301,11303
11302,11303
11302,11304
11303,11304
11306,11307
11308,11309
11308,11310
11309,11310
11309,11311
11309,11312
11309,11313
11309,11314
11309,11315
11310,11311
11312,11313
11313,11314
11315,11316
11315,11317
11316,11317
11319,11320
11319,11321
11320,11321
11323,11324
11325,11326
11325,11327
11326,11327
11329,11330
11330,11331
11331,11332
11331,11333
11331,11334
11332,11333
11334,11335
11337,11338
11337,11339
11338,11339
11339,11340
11339,11341
11340,11341
11342,11343
11342,11344
11343,11344
11346,11347
11348,11349
11348,11350
11349,11350
11349,11351
11350,11351
11350,11352
11351,11352
11351,11353
11352,11353
11355,11356
11355,11357
11356,11357
11359,11360
11359,11361
11360,11361
11360,11362
11361,11362
11365,11366
11365,11367
11365,11368
11366,11367
11367,11368
11367,11369
11368,11369
11370,11371
11371,11372
11371,11373
11371,11374
11374,11375
11375,11376
11375,11377
11376,11377
11379,11380
11380,11381
11380,11382
11380,11383
11380,11384
11380,11385
11381,11382
11383,11384
11384,11385
11386,11387
11388,11389
11388,11390
11389,11390
11392,11393
11392,11394
11393,11394
11396,11397
11397,11398
11397,11399
11398,11399
11400,11401
11401,11402
11401,11403
11402,11403
11404,11405
11404,11406
11405,11406
11409,11410
11410,11411
11410,11412
11411,11412
11413,11414
11413,11415
11414,11415
11418,11419
11419,11420
11421,11422
11421,11423
11422,11423
11422,11424
11422,11425
11422,11426
11423,11424
11425,11426
11426,11427
11428,11429
11429,11430
11431,11432
11431,11433
11432,11433
11435,11436
11436,11437
11436,11438
11436,11439
11437,11438
11439,11440
11442,11443
11443,11444
11443,11445
11443,11446
11443,11447
11443,11448
11443,11449
11443,11450
11443,11451
11444,11445
11446,11447
11446,11448
11447,11448
11449,11450
11449,11451
11450,11451
11453,11454
11455,11456
11457,11458
11457,11459
11458,11459
11461,11462
11464,11465
11464,11466
11465,11466
11468,11469
11469,11470
11469,11471
11470,11471
11472,11473
11472,11474
11473,11474
11477,11478
11478,11479
11480,11481
11480,11482
11481,11482
11481,11483
11482,11483
11482,11484
11483,11484
11485,11486
11485,11487
11486,11487
11490,11491
11490,11492
11491,11492
11491,11493
11492,11493
11494,11495
11494,11496
11495,11496
11496,11497
11496,11498
11496,11499
11496,11500
11496,11501
11496,11502
11497,11498
11499,11500
11502,11503
11502,11504
11503,11504
11503,11505
11504,11505
11504,11506
11505,11506
11507,11508
11507,11509
11508,11509
11513,11514
11513,11515
11513,11516
11514,11515
11514,11516
11515,11516
11518,11519
11518,11520
11519,11520
11523,11524
11523,11525
11524,11525
11526,11527
11526,11528
11527,11528
11530,11531
11531,11532
11531,11533
11531,11534
11531,11535
11531,11536
11531,11537
11532,11533
11534,11535
11538,11539
11538,11540
11539,11540
11539,11541
11540,11541
11540,11542
11541,11542
11543,11544
11543,11545
11544,11545
11549,11550
11549,11551
11549,11552
11550,11551
11550,11552
11551,11552
11554,11555
11554,11556
11555,11556
11559,11560
11560,11561
11560,11562
11561,11562
11561,11563
11562,11563
11562,11564
11563,11564
11563,11565
11564,11565
11566,11567
11566,11568
11567,11568
11572,11573
11574,11575
11575,11576
11575,11577
11575,11578
11575,11579
11575,11580
11575,11581
11575,11582
11575,11583
11576,11577
11578,11579
11578,11580
11579,11580
11581,11582
11581,11583
11582,11583
11585,11586
11587,11588
11589,11590
11589,11591
11590,11591
11593,11594
11596,11597
11596,11598
11597,11598
11600,11601
11601,11602
11601,11603
11602,11603
11604,11605
11604,11606
11605,11606
11609,11610
11610,11611
11612,11613
11612,11614
11613,11614
11613,11615
11613,11616
11613,11617
11614,11615
11616,11617
11617,11618
11619,11620
11619,11621
11620,11621
11623,11624
11624,11625
11626,11627
11626,11628
11626,11629
11626,11630
11627,11628
11628,11629
11628,11630
11628,11631
11628,11632
11629,11630
11631,11632
11632,11633
11635,11636
11636,11637
11637,11638
11639,11640
11640,11641
11640,11642
11640,11643
11640,11644
11641,11642
11643,11644
11644,11645
11646,11647
11649,11650
11650,11651
11650,11652
11650,11653
11650,11654
11651,11652
11653,11654
11654,11655
11656,11657
11658,11659
11660,11661
11661,11662
11661,11663
11661,11664
11661,11665
11661,11666
11661,11667
11661,11668
11661,11669
11662,11663
11664,11665
11664,11666
11665,11666
11667,11668
11667,11669
11668,11669
11671,11672
11673,11674
11676,11677
11676,11678
11677,11678
11680,11681
11680,11682
11681,11682
11684,11685
11687,11688
11688,11689
11690,11691
11691,11692
11691,11693
11692,11693
11692,11694
11693,11694
11693,11695
11694,11695
11696,11697
11696,11698
11697,11698
11702,11703
11703,11704
11703,11705
11703,11706
11703,11707
11704,11705
11708,11709
11708,11710
11708,11711
11709,11710
11709,11711
11710,11711
11710,11712
11711,11712
11713,11714
11713,11715
11714,11715
11718,11719
11718,11720
11719,11720
11721,11722
11721,11723
11722,11723
11722,11724
11723,11724
11725,11726
11725,11727
11726,11727
11731,11732
11732,11733
11732,11734
11732,11735
11732,11736
11733,11734
11735,11736
11736,11737
11736,11738
11737,11738
11737,11739
11738,11739
11740,11741
11740,11742
11741,11742
11746,11747
11747,11748
11748,11749
11748,11750
11749,11750
11749,11751
11750,11751
11752,11753
11752,11754
11753,11754
11757,11758
11757,11759
11758,11759
11758,11760
11759,11760
11759,11761
11760,11761
11762,11763
11762,11764
11763,11764
11767,11768
11768,11769
11768,11770
11769,11770
11769,11771
11770,11771
11770,11772
11771,11772
11773,11774
11773,11775
11774,11775
11774,11776
11775,11776
11777,11778
11777,11779
11778,11779
11783,11784
11783,11785
11784,11785
11785,11786
11785,11787
11786,11787
11786,11788
11787,11788
11787,11789
11788,11789
11790,11791
11790,11792
11791,11792
11791,11793
11792,11793
11794,11795
11794,11796
11795,11796
11801,11802
11802,11803
11802,11804
11802,11805
11802,11806
11802,11807
11802,11808
11802,11809
11802,11810
11803,11804
11805,11806
11805,11807
11806,11807
11808,11809
11808,11810
11809,11810
11809,11811
11810,11811
11812,11813
11812,11814
11813,11814
11817,11818
11819,11820
11822,11823
11825,11826
11828,11829
11829,11830
11831,11832
11831,11833
11832,11833
11832,11834
11833,11834
11834,11835
11834,11836
11835,11836
11835,11837
11836,11837
11836,11838
11837,11838
11839,11840
11839,11841
11840,11841
11844,11845
11846,11847
11847,11848
11847,11849
11848,11849
11848,11850
11849,11850
11849,11851
11850,11851
11852,11853
11852,11854
11853,11854
11857,11858
11859,11860
11859,11861
11859,11862
11860,11861
11860,11862
11860,11863
11861,11862
11861,11863
11862,11863
11862,11864
11863,11864
11863,11865
11864,11865
11866,11867
11866,11868
11867,11868
11871,11872
11873,11874
11874,11875
11874,11876
11875,11876
11875,11877
11876,11877
11876,11878
11877,11878
11879,11880
11879,11881
11880,11881
11884,11885
11886,11887
11887,11888
11887,11889
11888,11889
11888,11890
11889,11890
11889,11891
11890,11891
11892,11893
11892,11894
11893,11894
11897,11898
11899,11900
11900,11901
11900,11902
11900,11903
11900,11904
11901,11902
11905,11906
11905,11907
11905,11908
11906,11907
11906,11908
11907,11908
11907,11909
11908,11909
11910,11911
11910,11912
11911,11912
11915,11916
11915,11917
11916,11917
11918,11919
11918,11920
11919,11920
11919,11921
11920,11921
11922,11923
11922,11924
11923,11924
11928,11929
11928,11930
11929,11930
11929,11931
11930,11931
11930,11932
11931,11932
11933,11934
11933,11935
11934,11935
11938,11939
11939,11940
11939,11941
11940,11941
11940,11942
11941,11942
11942,11943
11942,11944
11943,11944
11943,11945
11944,11945
11944,11946
11945,11946
11947,11948
11947,11949
11948,11949
11948,11950
11949,11950
11951,11952
11951,11953
11952,11953
11957,11958
11959,11960
11960,11961
11960,11962
11961,11962
11961,11963
11962,11963
11962,11964
11963,11964
11965,11966
11965,11967
11966,11967
11966,11968
11967,11968
11969,11970
11969,11971
11970,11971
11975,11976
11977,11978
11978,11979
11978,11980
11978,11981
11979,11980
11979,11981
11980,11981
11980,11982
11981,11982
11981,11983
11982,11983
11984,11985
11984,11986
11985,11986
11989,11990
11991,11992
11991,11993
11991,11994
11991,11995
11991,11996
11991,11997
11991,11998
11991,11999
11991,12000
11992,11993
11993,11994
11993,11995
11993,11996
11993,11997
11993,11998
11994,11995
11998,11999
11998,12000
11998,12001
11999,12000
11999,12001
12000,12001
12000,12002
12001,12002
12003,12004
12003,12005
12004,12005
12008,12009
12008,12010
12009,12010
12011,12012
12011,12013
12012,12013
12012,12014
12013,12014
12015,12016
12015,12017
12016,12017
12021,12022
12021,12023
12021,12024
12022,12023
12022,12024
12023,12024
12023,12025
12024,12025
12026,12027
12026,12028
12027,12028
12027,12029
12028,12029
12030,12031
12030,12032
12031,12032
12036,12037
12036,12038
12037,12038
12039,12040
12039,12041
12040,12041
12040,12042
12041,12042
12043,12044
12043,12045
12044,12045
12044,12046
12045,12046
12047,12048
12047,12049
12048,12049
12054,12055
12055,12056
12055,12057
12056,12057
12056,12058
12057,12058
12057,12059
12058,12059
12060,12061
12060,12062
12061,12062
12061,12063
12062,12063
12064,12065
12064,12066
12065,12066
12070,12071
12072,12073
12073,12074
12073,12075
12074,12075
12074,12076
12075,12076
12075,12077
12076,12077
12078,12079
12078,12080
12079,12080
12083,12084
12085,12086
12086,12087
12086,12088
12086,12089
12086,12090
12087,12088
12089,12090
12090,12091
12093,12094
12094,12095
12095,12096
12097,12098
12098,12099
12098,12100
12098,12101
12098,12102
12099,12100
12101,12102
12102,12103
12105,12106
12106,12107
12107,12108
12109,12110
12110,12111
12110,12112
12110,12113
12110,12114
12111,12112
12113,12114
12114,12115
12116,12117
12118,12119
12118,12120
12119,12120
12119,12121
12120,12121
12122,12123
12122,12124
12123,12124
12123,12125
12124,12125
12126,12127
12126,12128
12127,12128
12132,12133
12133,12134
12133,12135
12133,12136
12133,12137
12134,12135
12136,12137
12137,12138
12139,12140
12141,12142
12141,12143
12142,12143
12142,12144
12143,12144
12145,12146
12145,12147
12146,12147
12150,12151
12151,12152
12151,12153
12151,12154
12151,12155
12151,12156
12151,12157
12151,12158
12151,12159
12152,12153
12154,12155
12154,12156
12155,12156
12157,12158
12157,12159
12158,12159
12161,12162
12163,12164
12166,12167
12166,12168
12167,12168
12170,12171
12170,12172
12171,12172
12174,12175
12176,12177
12177,12178
12177,12179
12177,12180
12177,12181
12177,12182
12177,12183
12177,12184
12177,12185
12178,12179
12180,12181
12180,12182
12181,12182
12183,12184
12183,12185
12184,12185
12184,12186
12185,12186
12187,12188
12187,12189
12188,12189
12192,12193
12194,12195
12197,12198
12197,12199
12198,12199
12201,12202
12201,12203
12202,12203
12205,12206
12207,12208
12207,12209
12207,12210
12207,12211
12207,12212
12207,12213
12207,12214
12207,12215
12207,12216
12207,12217
12207,12218
12207,12219
12207,12220
12208,12209
12209,12210
12209,12211
12209,12212
12209,12213
12209,12214
12210,12211
12214,12215
12214,12216
12214,12217
12215,12216
12215,12217
12216,12217
12216,12218
12217,12218
12219,12220
12219,12221
12220,12221
12224,12225
12224,12226
12225,12226
12227,12228
12227,12229
12228,12229
12228,12230
12229,12230
12231,12232
12231,12233
12232,12233
12237,12238
12237,12239
12237,12240
12238,12239
12238,12240
12239,12240
12239,12241
12240,12241
12242,12243
12242,12244
12243,12244
12243,12245
12244,12245
12246,12247
12246,12248
12247,12248
12252,12253
12252,12254
12253,12254
12255,12256
12255,12257
12256,12257
12256,12258
12257,12258
12259,12260
12259,12261
12260,12261
12260,12262
12261,12262
12263,12264
12263,12265
12264,12265
12270,12271
12271,12272
12271,12273
12272,12273
12272,12274
12273,12274
12273,12275
12274,12275
12276,12277
12276,12278
12277,12278
12277,12279
12278,12279
12280,12281
12280,12282
12281,12282
12286,12287
12288,12289
12289,12290
12289,12291
12290,12291
12290,12292
12291,12292
12291,12293
12292,12293
12294,12295
12294,12296
12295,12296
12299,12300
12301,12302
12302,12303
12302,12304
12302,12305
12303,12304
12305,12306
12305,12307
12306,12307
12308,12309
12308,12310
12309,12310
12309,12311
12310,12311
12312,12313
12312,12314
12313,12314
12317,12318
12319,12320
12320,12321
12320,12322
12320,12323
12321,12322
12323,12324
12323,12325
12324,12325
12326,12327
12326,12328
12327,12328
12330,12331
12332,12333
12333,12334
12333,12335
12334,12335
12336,12337
12336,12338
12337,12338
12340,12341
12341,12342
12341,12343
12342,12343
12344,12345
12344,12346
12345,12346
12345,12347
12346,12347
12348,12349
12348,12350
12349,12350
12353,12354
12354,12355
12354,12356
12354,12357
12354,12358
12355,12356
12357,12358
12358,12359
12361,12362
12362,12363
12363,12364
12365,12366
12366,12367
12366,12368
12366,12369
12366,12370
12367,12368
12369,12370
12370,12371
12373,12374
12374,12375
12375,12376
12377,12378
12378,12379
12378,12380
12378,12381
12378,12382
12379,12380
12381,12382
12382,12383
12384,12385
12386,12387
12386,12388
12387,12388
12387,12389
12388,12389
12390,12391
12390,12392
12391,12392
12391,12393
12392,12393
12394,12395
12394,12396
12395,12396
12400,12401
12401,12402
12401,12403
12401,12404
12401,12405
12402,12403
12404,12405
12405,12406
12407,12408
12409,12410
12409,12411
12410,12411
12410,12412
12411,12412
12413,12414
12413,12415
12414,12415
12418,12419
12419,12420
12419,12421
12419,12422
12419,12423
12419,12424
12419,12425
12419,12426
12419,12427
12420,12421
12422,12423
12422,12424
12423,12424
12425,12426
12425,12427
12426,12427
12429,12430
12431,12432
12434,12435
12434,12436
12435,12436
12438,12439
12438,12440
12439,12440
12442,12443
12444,12445
12445,12446
12445,12447
12445,12448
12445,12449
12445,12450
12445,12451
12445,12452
12445,12453
12446,12447
12448,12449
12448,12450
12449,12450
12451,12452
12451,12453
12452,12453
12452,12454
12453,12454
12455,12456
12455,12457
12456,12457
12460,12461
12462,12463
12465,12466
12465,12467
12466,12467
12469,12470
12469,12471
12470,12471
12473,12474
12476,12477
12477,12478
12479,12480
12480,12481
12480,12482
12480,12483
12481,12482
12483,12484
12483,12485
12484,12485
12486,12487
12486,12488
12487,12488
12490,12491
12491,12492
12494,12495
12495,12496
12497,12498
12497,12499
12498,12499
12498,12500
12499,12500
12499,12501
12500,12501
12502,12503
12502,12504
12503,12504
12507,12508
12508,12509
12508,12510
12508,12511
12508,12512
12508,12513
12508,12514
12508,12515
12509,12510
12511,12512
12511,12513
12512,12513
12514,12515
12514,12516
12515,12516
12518,12519
12520,12521
12523,12524
12527,12528
12528,12529
12530,12531
12531,12532
12531,12533
12531,12534
12531,12535
12531,12536
12531,12537
12531,12538
12531,12539
12532,12533
12534,12535
12534,12536
12535,12536
12537,12538
12537,12539
12538,12539
12541,12542
12543,12544
12545,12546
12545,12547
12546,12547
12549,12550
12552,12553
12552,12554
12553,12554
12556,12557
12557,12558
12557,12559
12557,12560
12558,12559
12560,12561
12560,12562
12561,12562
12564,12565
12565,12566
12567,12568
12568,12569
12568,12570
12569,12570
12571,12572
12571,12573
12572,12573
12576,12577
12577,12578
12579,12580
12579,12581
12580,12581
12580,12582
12581,12582
12581,12583
12582,12583
12582,12584
12583,12584
12585,12586
12585,12587
12586,12587
12590,12591
12592,12593
12592,12594
12592,12595
12592,12596
12593,12594
12594,12595
12594,12596
12594,12597
12594,12598
12595,12596
12597,12598
12598,12599
12598,12600
12599,12600
12601,12602
12601,12603
12602,12603
12605,12606
12607,12608
12609,12610
12610,12611
12611,12612
12611,12613
12612,12613
12612,12614
12613,12614
12616,12617
12617,12618
12618,12619
12618,12620
12619,12620
12619,12621
12620,12621
12623,12624
12625,12626
12626,12627
12626,12628
12627,12628
12627,12629
12628,12629
12628,12630
12629,12630
12631,12632
12631,12633
12632,12633
12636,12637
12639,12640
12640,12641
12642,12643
12642,12644
12643,12644
12644,12645
12644,12646
12645,12646
12647,12648
12647,12649
12648,12649
12650,12651
12650,12652
12651,12652
12654,12655
12654,12656
12655,12656
12656,12657
12656,12658
12656,12659
12657,12658
12659,12660
12663,12664
12664,12665
12664,12666
12664,12667
12665,12666
12668,12669
12668,12670
12669,12670
12672,12673
12673,12674
12673,12675
12673,12676
12674,12675
12676,12677
12676,12678
12677,12678
12677,12679
12679,12680
12681,12682
12681,12683
12682,12683
12685,12686
12686,12687
12686,12688
12687,12688
12687,12689
12688,12689
12690,12691
12690,12692
12691,12692
12696,12697
12697,12698
12699,12700
12700,12701
12700,12702
12700,12703
12701,12702
12703,12704
12703,12705
12704,12705
12706,12707
12706,12708
12707,12708
12710,12711
12711,12712
12714,12715
12715,12716
12717,12718
12718,12719
12718,12720
12718,12721
12718,12722
12719,12720
12721,12722
12724,12725
12724,12726
12725,12726
12729,12730
12730,12731
12732,12733
12732,12734
12733,12734
12734,12735
12734,12736
12734,12737
12735,12736
12737,12738
12738,12739
12740,12741
12742,12743
12742,12744
12743,12744
12744,12745
12744,12746
12744,12747
12744,12748
12744,12749
12744,12750
12744,12751
12744,12752
12745,12746
12747,12748
12747,12749
12748,12749
12750,12751
12750,12752
12751,12752
12754,12755
12756,12757
12759,12760
12762,12763
12765,12766
12766,12767
12766,12768
12766,12769
12766,12770
12767,12768
12769,12770
12770,12771
12773,12774
12774,12775
12775,12776
12777,12778
12778,12779
12778,12780
12779,12780
12781,12782
12781,12783
12781,12784
12781,12785
12782,12783
12784,12785
12785,12786
12787,12788
12787,12789
12788,12789
12788,12790
12790,12791
12792,12793
12792,12794
12793,12794
12796,12797
12796,12798
12797,12798
12800,12801
12800,12802
12800,12803
12801,12802
12801,12803
12802,12803
12805,12806
12806,12807
12806,12808
12806,12809
12806,12810
12806,12811
12806,12812
12806,12813
12806,12814
12807,12808
12809,12810
12809,12811
12810,12811
12812,12813
12812,12814
12813,12814
12816,12817
12818,12819
12821,12822
12821,12823
12822,12823
12825,12826
12825,12827
12826,12827
12829,12830
12831,12832
12831,12833
12831,12834
12832,12833
12832,12834
12833,12834
12836,12837
12837,12838
12837,12839
12837,12840
12837,12841
12837,12842
12837,12843
12837,12844
12837,12845
12838,12839
12840,12841
12840,12842
12841,12842
12843,12844
12843,12845
12844,12845
12847,12848
12849,12850
12852,12853
12852,12854
12853,12854
12856,12857
12856,12858
12857,12858
12860,12861
12862,12863
12863,12864
12863,12865
12863,12866
12863,12867
12863,12868
12863,12869
12863,12870
12863,12871
12864,12865
12866,12867
12866,12868
12867,12868
12869,12870
12869,12871
12870,12871
12873,12874
12875,12876
12878,12879
12878,12880
12879,12880
12882,12883
12882,12884
12883,12884
12886,12887
12889,12890
12890,12891
12892,12893
12892,12894
12892,12895
12893,12894
12894,12895
12894,12896
12895,12896
12897,12898
12897,12899
12900,12901
12900,12902
12901,12902
12901,12903
12902,12903
12902,12904
12903,12904
12904,12905
12904,12906
12905,12906
12907,12908
12907,12909
12908,12909
12910,12911
12911,12912
12911,12913
12912,12913
12914,12915
12914,12916
12915,12916
12918,12919
12918,12920
12919,12920
12922,12923
12922,12924
12923,12924
12926,12927
12927,12928
12928,12929
12928,12930
12928,12931
12928,12932
12929,12930
12931,12932
12931,12933
12932,12933
12935,12936
12937,12938
12937,12939
12938,12939
12938,12940
12940,12941
12942,12943
12942,12944
12943,12944
12948,12949
12949,12950
12949,12951
12949,12952
12949,12953
12949,12954
12949,12955
12950,12951
12954,12955
12954,12956
12955,12956
12955,12957
12956,12957
12960,12961
12960,12962
12961,12962
12964,12965
12964,12966
12965,12966
12965,12967
12966,12967
12968,12969
12968,12970
12969,12970
12973,12974
12974,12975
12974,12976
12974,12977
12974,12978
12975,12976
12977,12978
12978,12979
12981,12982
12982,12983
12983,12984
12985,12986
12986,12987
12986,12988
12986,12989
12986,12990
12987,12988
12989,12990
12990,12991
12992,12993
12994,12995
12994,12996
12995,12996
12995,12997
12996,12997
13000,13001
13001,13002
13001,13003
13001,13004
13001,13005
13001,13006
13001,13007
13001,13008
13001,13009
13002,13003
13004,13005
13004,13006
13005,13006
13007,13008
13007,13009
13008,13009
13011,13012
13013,13014
13016,13017
13016,13018
13017,13018
13020,13021
13020,13022
13021,13022
13024,13025
13026,13027
13026,13028
13027,13028
13027,13029
13028,13029
13031,13032
13031,13033
13031,13034
13032,13033
13033,13034
13033,13035
13034,13035
13036,13037
13036,13038
13037,13038
13040,13041
13041,13042
13041,13043
13041,13044
13042,13043
13046,13047
13047,13048
13047,13049
13048,13049
13048,13050
13049,13050
13052,13053
13054,13055
13054,13056
13055,13056
13055,13057
13056,13057
13056,13058
13057,13058
13057,13059
13058,13059
13058,13060
13059,13060
13060,13061
13060,13062
13061,13062
13061,13063
13062,13063
13062,13064
13063,13064
13067,13068
13069,13070
13070,13071
13070,13072
13071,13072
13071,13073
13072,13073
13072,13074
13073,13074
13077,13078
13079,13080
13080,13081
13080,13082
13081,13082
13081,13083
13082,13083
13082,13084
13083,13084
13087,13088
13089,13090
13090,13091
13090,13092
13091,13092
13091,13093
13092,13093
13092,13094
13093,13094
13097,13098
13099,13100
13100,13101
13100,13102
13101,13102
13101,13103
13102,13103
13102,13104
13103,13104
13107,13108
13109,13110
13110,13111
13110,13112
13111,13112
13111,13113
13112,13113
13112,13114
13113,13114
13115,13116
13115,13117
13116,13117
13119,13120
13119,13121
13120,13121
13120,13122
13121,13122
13121,13123
13122,13123
13124,13125
13124,13126
13125,13126
13129,13130
13129,13131
13130,13131
13130,13132
13131,13132
13133,13134
13133,13135
13134,13135
13138,13139
13139,13140
13139,13141
13139,13142
13139,13143
13139,13144
13139,13145
13139,13146
13139,13147
13140,13141
13142,13143
13142,13144
13143,13144
13145,13146
13145,13147
13146,13147
13149,13150
13151,13152
13153,13154
13153,13155
13154,13155
13157,13158
13160,13161
13160,13162
13161,13162
13164,13165
13165,13166
13165,13167
13166,13167
13168,13169
13169,13170
13169,13171
13169,13172
13172,13173
13173,13174
13173,13175
13174,13175
13177,13178
13179,13180
13179,13181
13180,13181
13180,13182
13181,13182
13181,13183
13182,13183
13184,13185
13184,13186
13185,13186
13188,13189
13188,13190
13189,13190
13189,13191
13190,13191
13190,13192
13191,13192
13193,13194
13193,13195
13194,13195
13198,13199
13198,13200
13199,13200
13199,13201
13200,13201
13202,13203
13202,13204
13203,13204
13207,13208
13208,13209
13208,13210
13208,13211
13208,13212
13208,13213
13208,13214
13208,13215
13208,13216
13209,13210
13211,13212
13211,13213
13212,13213
13214,13215
13214,13216
13215,13216
13218,13219
13220,13221
13222,13223
13222,13224
13223,13224
13226,13227
13229,13230
13229,13231
13230,13231
-----nextToken-----
2,4,7,9,10,15,17,20,22,25,27,29,33,35,37,40,42,44,48,50,51,56,58,61,62,66,68,69,74,76,79,80,84,86,87,92,94,97,98,102,104,105,110,112,115,116,120,122,123,127,129,130,134,136,139,143,145,146,149,153,155,156,160,162,163,167,169,173,175,177,181,183,186,188,191,193,196,198,200,203,205,207,209,213,215,216,219,221,223,226,228,230,234,236,239,241,242,244,248,251,257,258,262,264,265,270,275,276,277,281,284,285,289,292,293,297,300,304,305,309,313,318,323,325,326,328,331,332,337,339,346,347,348,353,356,357,358,363,368,373,375,376,379,382,383,386,389,390,392,397,398,405,406,407,413,416,417,418,422,424,426,429,431,433,438,441,442,444,449,454,459,461,462,465,468,469,472,475,476,478,482,486,489,490,493,499,500,505,506,509,513,516,517,520,522,525,527,529,530,535,538,539,543,544,549,552,553,556,559,562,563,565,570,573,574,576,579,582,587,589,590,594,598,601,602,604,608,609,613,617,620,621,626,627,630,631,636,637,639,644,649,650,651,655,659,660,662,669,670,671,672,677,682,683,684,689,690,692,697,702,703,704,707,710,711,718,719,720,723,726,727,733,734,736,741,742,743,745,750,751,754,757,758,761,763,766,769,770,774,775,776,778,780,782,789,790,792,797,798,799,801,804,805,808,813,814,817,822,826,827,833,834,836,841,844,848,849,853,854,857,858,863,865,866,869,872,873,877,880,881,883,889,890,891,893,898,899,900,907,908,909,913,914,918,919,923,926,927,931,937,938,940,946,947,948,950,956,957,958,960,964,967,968,972,977,980,983,984,988,989,990,991,996,998,1001,1004,1006,1011,1014,1015,1017,1022,1023,1026,1027,1037,1038,1040,1046,1047,1048,1049,1053,1056,1057,1061,1066,1067,1071,1073,1075,1082,1085,1086,1088,1095,1096,1098,1104,1105,1106,1108,1113,1114,1123,1124,1126,1131,1132,1133,1135,1140,1141,1144,1147,1148,1151,1153,1156,1159,1160,1164,1165,1166,1168,1170,1176,1177,1179,1186,1187,1188,1190,1195,1196,1197,1199,1204,1205,1208,1211,1212,1215,1217,1220,1223,1224,1228,1229,1230,1232,1234,1238,1241,1242,1244,1249,1250,1251,1256,1258,1259,1263,1266,1267,1271,1272,1277,1280,1281,1286,1289,1292,1293,1298,1300,1304,1306,1312,1313,1317,1320,1321,1327,1330,1331,1333,1346,1347,1348,1350,1356,1357,1358,1360,1366,1367,1368,1370,1376,1377,1378,1380,1385,1386,1388,1392,1395,1399,1402,1403,1406,1410,1413,1414,1417,1419,1424,1425,1426,1430,1433,1434,1438,1439,1443,1446,1447,1449,1454,1457,1460,1461,1463,1466,1471,1474,1475,1477,1480,1483,1488,1490,1491,1495,1498,1499,1503,1506,1507,1511,1512,1514,1518,1519,1526,1529,1530,1531,1535,1536,1538,1546,1547,1549,1553,1554,1556,1560,1561,1563,1567,1568,1570,1575,1577,1578,1581,1583,1589,1592,1594,1596,1598,1602,1605,1606,1608,1612,1616,1617,1621,1622,1627,1628,1629,1634,1639,1640,1641,1646,1650,1653,1655,1659,1662,1664,1668,1671,1672,1675,1679,1682,1683,1684,1686,1691,1692,1695,1696,1700,1703,1704,1708,1713,1714,1715,1717,1720,1721,1725,1728,1729,1734,1737,1738,1742,1745,1746,1747,1752,1756,1759,1760,1761,1763,1765,1767,1771,1775,1778,1779,1780,1782,1784,1788,1792,1795,1796,1797,1802,1805,1806,1811,1814,1815,1819,1822,1823,1827,1828,1830,1836,1839,1840,1841,1849,1852,1857,1860,1861,1862,1865,1870,1871,1872,1874,1879,1880,1881,1883,1887,1889,1893,1896,1897,1902,1905,1906,1909,1913,1916,1920,1923,1924,1925,1931,1934,1935,1936,1941,1944,1948,1949,1955,1958,1959,1960,1962,1966,1969,1973,1974,1979,1982,1983,1985,1989,1993,1994,1995,1998,1999,2002,2003,2007,2008,2009,2014,2015,2018,2019,2024,2025,2028,2029,2034,2035,2038,2041,2042,2049,2052,2053,2055,2060,2061,2063,2067,2068,2076,2079,2080,2081,2084,2085,2092,2095,2096,2097,2108,2109,2110,2112,2118,2119,2120,2122,2128,2129,2130,2132,2138,2139,2140,2142,2148,2149,2150,2152,2157,2158,2160,2177,2178,2179,2181,2187,2188,2189,2191,2197,2198,2199,2201,2207,2208,2209,2211,2217,2218,2219,2221,2227,2228,2229,2231,2237,2238,2239,2241,2247,2248,2249,2251,2256,2257,2259,2264,2265,2266,2270,2273,2274,2275,2278,2279,2282,2283,2287,2288,2289,2294,2295,2301,2304,2305,2306,2309,2310,2311,2319,2320,2322,2330,2331,2332,2334,2340,2341,2342,2344,2349,2350,2351,2355,2358,2361,2362,2364,2366,2369,2370,2372,2373,2376,2377,2382,2385,2386,2390,2393,2394,2398,2401,2402,2406,2407,2409,2423,2424,2425,2427,2433,2434,2435,2437,2443,2444,2445,2447,2453,2454,2455,2457,2463,2464,2465,2467,2472,2473,2475,2481,2484,2485,2486,2492,2493,2495,2500,2501,2504,2505,2506,2511,2514,2515,2521,2522,2525,2526,2532,2533,2536,2537,2538,2544,2547,2552,2555,2556,2557,2565,2566,2567,2569,2574,2575,2577,2581,2583,2586,2588,2595,2598,2599,2600,2604,2607,2608,2609,2615,2616,2620,2623,2624,2625,2629,2630,2634,2637,2638,2639,2643,2646,2647,2651,2655,2658,2659,2660,2666,2670,2673,2674,2675,2681,2684,2685,2686,2689,2690,2696,2700,2703,2704,2705,2708,2711,2712,2715,2719,2723,2724,2725,2727,2731,2732,2736,2740,2743,2744,2746,2748,2754,2757,2758,2764,2765,2767,2771,2772,2776,2779,2780,2783,2787,2791,2792,2793,2795,2799,2802,2803,2806,2810,2812,2816,2820,2822,2826,2829,2830,2836,2839,2840,2841,2844,2845,2850,2853,2854,2858,2861,2862,2866,2867,2869,2874,2875,2876,2879,2880,2884,2887,2888,2889,2893,2896,2897,2898,2903,2906,2911,2914,2915,2916,2923,2924,2926,2934,2935,2936,2938,2944,2945,2946,2948,2953,2956,2957,2961,2964,2965,2969,2970,2972,2980,2981,2983,2988,2989,2991,2996,2997,2999,3004,3007,3010,3011,3013,3018,3021,3024,3025,3027,3032,3035,3036,3038,3042,3045,3046,3047,3049,3054,3057,3058,3062,3065,3066,3070,3071,3073,3077,3078,3083,3085,3086,3089,3093,3095,3096,3098,3099,3102,3107,3110,3111,3116,3119,3120,3125,3128,3129,3133,3136,3137,3141,3142,3144,3149,3153,3156,3157,3158,3163,3166,3167,3172,3176,3179,3182,3184,3188,3190,3196,3197,3199,3204,3205,3207,3211,3214,3218,3219,3220,3225,3228,3229,3231,3234,3237,3238,3243,3245,3246,3250,3253,3254,3257,3258,3261,3266,3268,3272,3274,3278,3283,3285,3286,3291,3293,3295,3297,3300,3305,3307,3312,3313,3315,3319,3321,3323,3328,3330,3331,3334,3339,3341,3344,3349,3352,3356,3358,3363,3364,3365,3370,3373,3374,3377,3380,3381,3384,3387,3388,3389,3392,3398,3399,3403,3406,3407,3408,3414,3417,3418,3419,3422,3423,3428,3429,3431,3435,3436,3441,3442,3443,3451,3452,3454,3460,3461,3462,3464,3468,3471,3472,3473,3478,3481,3485,3486,3491,3492,3494,3500,3505,3506,3507,3511,3514,3515,3516,3523,3526,3527,3528,3531,3536,3537,3538,3542,3543,3544,3547,3552,3553,3554,3559,3562,3563,3564,3569,3572,3573,3577,3580,3581,3587,3590,3591,3592,3597,3599,3600,3604,3607,3611,3614,3615,3616,3620,3622,3623,3627,3631,3634,3635,3636,3639,3644,3646,3651,3652,3653,3658,3662,3665,3666,3667,3668,3673,3677,3680,3681,3682,3685,3689,3692,3693,3694,3698,3700,3702,3706,3710,3713,3714,3715,3719,3722,3724,3729,3730,3731,3735,3736,3741,3744,3745,3749,3750,3751,3756,3757,3759,3763,3766,3767,3771,3772,3774,3779,3780,3782,3790,3791,3792,3793,3796,3800,3803,3804,3805,3810,3811,3812,3815,3820,3821,3822,3828,3831,3832,3833,3836,3841,3842,3843,3849,3850,3852,3856,3859,3860,3861,3868,3869,3870,3872,3877,3881,3884,3885,3886,3888,3894,3895,3896,3898,3903,3907,3910,3911,3912,3914,3919,3920,3922,3927,3929,3933,3936,3937,3938,3941,3945,3946,3947,3951,3952,3953,3962,3965,3966,3967,3970,3971,3976,3977,3978,3980,3985,3986,3987,3989,3994,3995,3996,3998,4005,4008,4009,4010,4013,4014,4017,4021,4022,4023,4026,4027,4030,4031,4037,4040,4041,4042,4046,4047,4048,4054,4057,4058,4059,4066,4069,4070,4071,4075,4076,4077,4082,4083,4084,4088,4089,4092,4096,4101,4104,4105,4106,4108,4114,4117,4118,4119,4124,4128,4131,4132,4133,4135,4136,4137,4140,4144,4147,4148,4149,4152,4156,4159,4160,4161,4165,4168,4171,4172,4174,4178,4179,4184,4187,4188,4194,4197,4198,4203,4206,4207,4208,4210,4214,4218,4221,4222,4223,4227,4229,4230,4235,4238,4239,4240,4244,4247,4248,4250,4253,4255,4257,4262,4264,4268,4270,4271,4272,4276,4280,4283,4284,4285,4286,4289,4293,4298,4301,4302,4303,4305,4310,4313,4314,4319,4322,4323,4325,4331,4334,4335,4336,4339,4342,4345,4346,4348,4353,4357,4360,4361,4362,4364,4365,4366,4369,4373,4376,4377,4378,4381,4385,4388,4389,4390,4394,4397,4400,4401,4403,4409,4412,4413,4414,4416,4420,4424,4427,4428,4429,4434,4437,4438,4440,4442,4443,4447,4451,4454,4455,4456,4457,4460,4466,4469,4470,4471,4473,4478,4482,4485,4486,4488,4490,4496,4497,4503,4504,4506,4510,4513,4514,4518,4522,4525,4527,4531,4534,4535,4536,4540,4543,4546,4547,4549,4551,4552,4555,4556,4559,4560,4562,4568,4571,4572,4573,4575,4576,4579,4583,4588,4591,4592,4593,4596,4598,4599,4605,4606,4609,4610,4614,4615,4616,4621,4624,4625,4629,4630,4634,4637,4639,4642,4643,4646,4647,4651,4655,4658,4659,4664,4667,4668,4670,4674,4677,4680,4681,4683,4687,4689,4695,4698,4701,4702,4703,4705,4710,4711,4713,4716,4720,4723,4726,4727,4729,4731,4734,4735,4737,4738,4741,4742,4746,4749,4750,4753,4756,4761,4764,4765,4767,4770,4774,4776,4777,4780,4783,4784,4788,4791,4792,4793,4797,4800,4801,4802,4803,4808,4812,4815,4816,4817,4820,4823,4826,4827,4829,4834,4837,4838,4840,4844,4846,4847,4848,4852,4856,4859,4860,4861,4862,4866,4868,4869,4871,4872,4874,4875,4879,4882,4886,4889,4890,4891,4895,4898,4902,4905,4906,4907,4911,4914,4918,4921,4922,4923,4927,4930,4931,4935,4936,4940,4943,4945,4947,4949,4950,4952,4956,4960,4963,4964,4969,4972,4973,4975,4979,4980,4984,4986,4989,4994,4998,5001,5002,5003,5006,5010,5013,5014,5015,5021,5025,5028,5029,5030,5031,5034,5039,5042,5043,5047,5051,5054,5056,5057,5061,5064,5066,5068,5072,5075,5078,5079,5081,5083,5084,5087,5088,5091,5092,5094,5099,5102,5103,5105,5108,5112,5114,5115,5118,5121,5122,5126,5129,5130,5131,5135,5138,5139,5140,5145,5148,5151,5152,5154,5159,5162,5165,5166,5168,5173,5174,5179,5180,5184,5189,5192,5193,5194,5198,5201,5202,5203,5207,5210,5211,5215,5219,5221,5222,5226,5228,5229,5234,5236,5240,5241,5245,5246,5250,5255,5258,5259,5260,5263,5264,5265,5266,5270,5275,5278,5279,5280,5281,5284,5289,5292,5295,5296,5298,5303,5307,5310,5311,5312,5316,5317,5322,5326,5329,5330,5331,5335,5339,5342,5343,5344,5348,5351,5354,5359,5362,5363,5364,5368,5371,5372,5373,5374,5378,5383,5386,5387,5388,5390,5395,5396,5400,5405,5408,5409,5410,5412,5417,5418,5422,5428,5431,5434,5435,5437,5441,5446,5449,5450,5451,5455,5458,5459,5460,5464,5469,5472,5473,5477,5481,5484,5486,5487,5491,5494,5496,5498,5502,5505,5508,5509,5511,5513,5514,5517,5518,5521,5522,5524,5529,5532,5533,5535,5538,5542,5544,5546,5548,5550,5552,5554,5558,5561,5564,5565,5567,5572,5574,5575,5578,5581,5582,5585,5587,5591,5595,5598,5599,5600,5603,5605,5609,5613,5616,5617,5618,5623,5625,5626,5629,5632,5633,5636,5638,5642,5646,5649,5650,5651,5654,5656,5660,5664,5667,5668,5669,5672,5674,5678,5682,5685,5686,5687,5692,5695,5698,5699,5701,5710,5713,5714,5715,5719,5722,5723,5724,5728,5729,5734,5737,5740,5741,5743,5748,5752,5755,5758,5759,5761,5762,5763,5767,5770,5771,5775,5779,5782,5787,5790,5791,5792,5796,5799,5800,5801,5805,5807,5808,5812,5814,5815,5820,5822,5826,5827,5831,5836,5839,5840,5841,5842,5845,5850,5853,5856,5857,5859,5864,5868,5871,5872,5873,5878,5882,5885,5886,5887,5891,5892,5896,5899,5902,5907,5910,5911,5912,5916,5919,5920,5921,5922,5926,5929,5934,5937,5938,5939,5943,5946,5947,5948,5952,5956,5958,5960,5962,5964,5966,5968,5972,5975,5976,5980,5984,5987,5989,5990,5994,5997,5999,6001,6005,6007,6008,6011,6013,6017,6022,6025,6026,6027,6031,6034,6035,6036,6040,6043,6046,6047,6049,6051,6052,6055,6056,6059,6060,6062,6067,6070,6071,6073,6076,6081,6083,6084,6087,6090,6091,6094,6096,6100,6104,6107,6108,6109,6112,6114,6118,6122,6125,6126,6127,6130,6132,6136,6140,6143,6144,6145,6149,6152,6155,6156,6158,6159,6162,6167,6170,6171,6175,6179,6182,6184,6186,6190,6193,6195,6196,6198,6202,6205,6208,6209,6211,6213,6214,6217,6218,6221,6222,6224,6228,6232,6235,6236,6237,6238,6243,6248,6251,6252,6253,6255,6259,6260,6261,6264,6267,6268,6270,6273,6277,6280,6281,6282,6284,6286,6288,6291,6293,6295,6297,6299,6301,6307,6310,6311,6312,6314,6318,6321,6322,6326,6329,6332,6333,6335,6340,6345,6348,6349,6350,6352,6356,6357,6358,6361,6364,6365,6366,6372,6375,6376,6377,6379,6383,6386,6389,6390,6393,6394,6400,6403,6404,6405,6406,6412,6415,6416,6419,6422,6423,6427,6432,6435,6436,6437,6439,6440,6443,6449,6454,6457,6458,6459,6461,6465,6470,6473,6474,6475,6477,6480,6481,6485,6490,6493,6494,6498,6501,6502,6503,6506,6507,6511,6514,6515,6516,6521,6524,6525,6529,6532,6533,6534,6537,6538,6542,6545,6546,6547,6548,6549,6552,6556,6559,6562,6563,6565,6569,6570,6571,6574,6575,6580,6583,6584,6585,6590,6593,6594,6597,6598,6603,6606,6607,6609,6613,6616,6619,6620,6622,6624,6627,6628,6630,6631,6634,6635,6639,6642,6643,6644,6647,6652,6655,6656,6657,6662,6665,6666,6669,6670,6675,6678,6679,6681,6686,6689,6692,6693,6695,6702,6705,6706,6707,6709,6713,6715,6716,6719,6724,6727,6728,6729,6730,6734,6735,6738,6739,6740,6744,6745,6746,6749,6750,6754,6757,6760,6761,6763,6765,6768,6769,6771,6772,6775,6776,6781,6784,6787,6788,6790,6796,6799,6800,6801,6803,6807,6810,6811,6812,6815,6820,6822,6823,6827,6829,6830,6834,6837,6838,6843,6846,6847,6849,6853,6857,6860,6861,6862,6866,6869,6872,6874,6876,6880,6883,6884,6888,6890,6891,6895,6898,6902,6905,6906,6907,6911,6913,6917,6919,6923,6925,6929,6932,6933,6937,6938,6942,6944,6945,6948,6950,6954,6956,6957,6960,6962,6966,6969,6970,6972,6974,6979,6980,6981,6984,6986,6990,6992,6994,6997,6998,7000,7005,7007,7008,7011,7013,7018,7020,7022,7025,7026,7027,7032,7034,7035,7038,7040,7043,7044,7046,7051,7052,7053,7056,7058,7061,7062,7064,7068,7070,7074,7076,7080,7084,7087,7088,7093,7094,7095,7098,7099,7102,7107,7109,7110,7113,7117,7122,7125,7126,7127,7131,7133,7135,7136,7140,7143,7146,7147,7149,7154,7157,7160,7161,7163,7165,7168,7169,7171,7172,7175,7176,7180,7183,7184,7185,7189,7190,7197,7200,7201,7202,7205,7206,7212,7215,7216,7217,7223,7226,7227,7228,7231,7234,7238,7241,7242,7243,7249,7252,7253,7254,7258,7261,7262,7263,7267,7268,7269,7272,7277,7280,7281,7282,7283,7286,7290,7293,7294,7295,7303,7306,7307,7308,7312,7315,7316,7317,7322,7325,7326,7330,7334,7337,7339,7340,7344,7347,7349,7351,7355,7358,7361,7362,7364,7366,7367,7370,7371,7374,7375,7377,7382,7385,7386,7388,7391,7395,7397,7399,7401,7403,7407,7409,7410,7413,7416,7417,7420,7422,7426,7430,7433,7434,7435,7438,7440,7444,7448,7451,7452,7453,7458,7463,7466,7467,7468,7470,7474,7477,7478,7483,7486,7487,7491,7494,7495,7496,7500,7502,7504,7508,7511,7515,7518,7519,7520,7524,7527,7528,7529,7533,7534,7535,7538,7540,7544,7547,7551,7554,7555,7556,7561,7565,7568,7569,7570,7571,7575,7579,7582,7583,7584,7587,7591,7594,7595,7596,7601,7605,7608,7609,7610,7611,7615,7619,7622,7623,7624,7627,7631,7634,7635,7636,7640,7644,7647,7648,7649,7653,7656,7657,7662,7665,7666,7670,7675,7678,7679,7680,7682,7684,7692,7693,7695,7699,7701,7704,7705,7709,7712,7713,7716,7720,7723,7726,7727,7729,7731,7734,7735,7737,7738,7740,7741,7744,7749,7751,7755,7758,7761,7762,7765,7769,7772,7775,7776,7778,7780,7783,7784,7787,7788,7791,7792,7794,7795,7798,7804,7807,7808,7809,7813,7816,7819,7820,7821,7824,7827,7828,7832,7834,7837,7841,7844,7845,7850,7853,7854,7855,7860,7864,7867,7868,7869,7876,7877,7878,7883,7884,7887,7888,7895,7898,7899,7900,7903,7904,7909,7911,7912,7915,7916,7920,7923,7924,7925,7929,7931,7932,7933,7936,7937,7941,7944,7945,7946,7950,7952,7953,7956,7957,7964,7965,7966,7971,7972,7975,7976,7983,7986,7987,7988,7991,7992,7997,7999,8000,8003,8004,8008,8011,8012,8013,8017,8019,8020,8021,8024,8025,8029,8032,8033,8034,8038,8040,8041,8044,8045,8050,8051,8055,8058,8059,8060,8065,8066,8071,8072,8074,8079,8080,8087,8090,8091,8092,8095,8096,8097,8102,8103,8107,8108,8109,8114,8115,8119,8122,8123,8124,8129,8130,8134,8137,8138,8139,8144,8145,8147,8153,8155,8158,8159,8164,8166,8171,8172,8174,8181,8182,8183,8188,8189,8192,8193,8198,8199,8202,8204,8207,8208,8210,8213,8215,8220,8221,8224,8226,8229,8230,8232,8235,8237,8242,8243,8245,8249,8251,8255,8258,8261,8262,8264,8266,8269,8270,8272,8273,8276,8277,8281,8284,8285,8290,8291,8292,8296,8297,8298,8301,8302,8305,8306,8309,8310,8313,8314,8315,8318,8321,8326,8327,8328,8333,8334,8335,8340,8341,8342,8347,8348,8349,8353,8355,8358,8364,8365,8366,8368,8376,8377,8378,8379,8381,8385,8388,8391,8392,8396,8397,8400,8401,8403,8404,8405,8406,8410,8412,8416,8419,8422,8425,8426,8427,8431,8432,8438,8441,8442,8443,8446,8449,8450,8453,8457,8458,8459,8462,8467,8470,8471,8472,8473,8477,8480,8481,8482,8483,8486,8490,8495,8498,8499,8500,8503,8505,8510,8512,8513,8518,8521,8522,8523,8526,8530,8533,8534,8535,8536,8537,8541,8544,8547,8548,8553,8556,8557,8558,8561,8565,8568,8569,8570,8574,8577,8578,8579,8582,8586,8588,8589,8593,8594,8597,8598,8599,8602,8607,8610,8611,8612,8613,8617,8620,8621,8624,8625,8628,8631,8635,8638,8641,8642,8644,8646,8649,8650,8652,8653,8656,8657,8661,8666,8669,8670,8671,8674,8676,8681,8683,8684,8689,8692,8693,8694,8697,8701,8704,8705,8706,8707,8708,8712,8715,8718,8719,8722,8726,8730,8732,8733,8736,8741,8744,8745,8746,8747,8751,8754,8755,8756,8760,8763,8764,8768,8772,8775,8776,8778,8779,8783,8787,8790,8791,8792,8793,8798,8801,8803,8807,8810,8811,8812,8816,8819,8820,8821,8822,8826,8829,8830,8831,8835,8836,8841,8845,8848,8849,8850,8851,8854,8858,8862,8864,8865,8868,8871,8872,8876,8879,8880,8881,8885,8888,8889,8890,8894,8897,8898,8902,8906,8909,8911,8912,8916,8919,8921,8923,8927,8930,8933,8934,8936,8938,8939,8942,8943,8946,8947,8949,8954,8957,8958,8960,8965,8968,8971,8972,8974,8979,8982,8985,8986,8988,8993,8994,8999,9000,9004,9009,9012,9013,9014,9018,9021,9022,9023,9027,9030,9031,9035,9039,9041,9042,9046,9048,9049,9054,9056,9060,9061,9065,9066,9070,9075,9078,9079,9080,9083,9084,9085,9086,9090,9095,9098,9099,9100,9101,9104,9109,9112,9115,9116,9118,9123,9127,9130,9131,9132,9136,9137,9142,9146,9149,9150,9151,9155,9159,9162,9163,9164,9168,9171,9174,9179,9182,9183,9184,9188,9191,9192,9193,9194,9198,9203,9206,9207,9208,9210,9215,9216,9220,9225,9228,9229,9230,9232,9237,9238,9242,9246,9248,9250,9252,9254,9256,9258,9263,9266,9269,9270,9272,9277,9278,9279,9282,9286,9289,9290,9291,9294,9296,9300,9304,9307,9308,9309,9313,9318,9321,9322,9323,9327,9330,9331,9332,9336,9340,9345,9348,9351,9352,9354,9359,9361,9362,9365,9368,9369,9372,9374,9378,9382,9385,9386,9387,9390,9392,9396,9400,9403,9404,9405,9410,9412,9413,9416,9419,9420,9423,9425,9429,9433,9436,9437,9438,9441,9443,9447,9451,9454,9455,9456,9459,9461,9465,9469,9472,9473,9474,9478,9481,9482,9486,9490,9493,9495,9496,9500,9503,9505,9507,9511,9514,9517,9518,9520,9522,9523,9526,9527,9530,9531,9533,9538,9541,9542,9544,9549,9552,9555,9556,9558,9567,9570,9571,9572,9576,9579,9580,9581,9585,9586,9591,9594,9597,9598,9600,9605,9609,9612,9615,9616,9618,9619,9620,9624,9627,9628,9632,9636,9640,9643,9646,9647,9649,9653,9656,9657,9658,9661,9666,9669,9670,9671,9675,9678,9679,9680,9684,9686,9687,9691,9693,9694,9699,9701,9705,9706,9710,9715,9718,9719,9720,9721,9724,9729,9732,9735,9736,9738,9743,9747,9750,9751,9752,9757,9761,9764,9765,9766,9770,9771,9775,9778,9781,9786,9789,9790,9791,9795,9798,9799,9800,9801,9805,9808,9813,9816,9817,9818,9822,9825,9826,9827,9831,9835,9837,9839,9841,9843,9845,9847,9851,9853,9854,9857,9859,9863,9868,9871,9872,9873,9877,9880,9881,9882,9885,9890,9893,9896,9897,9899,9904,9906,9907,9910,9913,9914,9917,9919,9923,9927,9930,9931,9932,9935,9937,9941,9945,9948,9949,9950,9955,9957,9958,9961,9964,9965,9968,9970,9974,9978,9981,9982,9983,9986,9988,9992,9996,9999,10000,10001,10004,10006,10010,10014,10017,10018,10019,10023,10026,10027,10031,10035,10038,10040,10041,10045,10048,10050,10052,10056,10059,10062,10063,10065,10067,10068,10071,10072,10075,10076,10078,10083,10086,10087,10089,10092,10097,10100,10101,10105,10109,10112,10114,10116,10120,10123,10125,10126,10128,10132,10135,10138,10139,10141,10143,10144,10147,10148,10151,10152,10154,10158,10162,10165,10166,10167,10168,10173,10178,10181,10182,10183,10185,10189,10190,10191,10194,10197,10198,10200,10203,10207,10210,10211,10212,10214,10216,10218,10221,10223,10225,10227,10229,10231,10235,10240,10243,10244,10245,10247,10253,10256,10259,10260,10262,10264,10266,10270,10273,10274,10278,10279,10284,10286,10287,10291,10293,10294,10296,10297,10300,10305,10308,10309,10314,10318,10321,10324,10326,10330,10332,10338,10339,10341,10346,10347,10349,10353,10356,10360,10361,10362,10367,10370,10371,10373,10376,10379,10380,10385,10387,10388,10392,10395,10396,10399,10400,10403,10407,10409,10413,10415,10419,10424,10426,10427,10432,10434,10436,10438,10441,10445,10447,10452,10453,10455,10459,10461,10463,10468,10470,10471,10474,10478,10480,10483,10487,10490,10495,10500,10503,10504,10505,10507,10511,10512,10513,10516,10519,10520,10524,10527,10530,10531,10533,10536,10537,10540,10542,10546,10551,10554,10555,10556,10558,10563,10568,10571,10572,10573,10575,10579,10582,10585,10586,10588,10592,10593,10596,10597,10598,10603,10605,10609,10612,10613,10614,10618,10621,10622,10623,10624,10628,10631,10632,10633,10637,10641,10643,10644,10647,10650,10651,10655,10658,10659,10660,10664,10667,10668,10669,10673,10676,10677,10681,10685,10688,10690,10691,10695,10698,10700,10702,10706,10709,10712,10713,10715,10717,10718,10721,10722,10725,10726,10728,10733,10736,10737,10739,10743,10745,10747,10751,10756,10759,10760,10761,10763,10767,10768,10769,10772,10775,10776,10779,10781,10785,10789,10792,10793,10794,10798,10803,10806,10807,10808,10810,10814,10817,10820,10821,10823,10825,10826,10828,10829,10831,10837,10840,10843,10844,10846,10850,10853,10854,10855,10857,10861,10864,10865,10869,10870,10875,10877,10878,10882,10884,10885,10887,10888,10891,10896,10899,10900,10905,10909,10912,10915,10917,10921,10922,10923,10927,10929,10935,10936,10938,10943,10944,10946,10950,10953,10958,10961,10962,10964,10967,10970,10971,10976,10978,10979,10983,10986,10987,10990,10991,10994,10998,11000,11004,11006,11010,11015,11017,11018,11023,11025,11027,11029,11032,11036,11038,11043,11044,11046,11050,11052,11054,11059,11061,11062,11065,11069,11071,11074,11078,11081,11082,11085,11091,11094,11095,11096,11098,11102,11103,11104,11107,11108,11112,11115,11116,11120,11121,11122,11125,11126,11127,11130,11134,11135,11136,11140,11143,11144,11147,11148,11149,11152,11155,11158,11162,11165,11168,11169,11171,11173,11176,11177,11179,11180,11183,11184,11188,11191,11192,11195,11198,11204,11207,11208,11210,11214,11217,11218,11220,11221,11226,11229,11230,11232,11239,11243,11246,11247,11248,11251,11255,11258,11259,11260,11263,11268,11271,11272,11273,11275,11282,11283,11284,11286,11291,11294,11295,11299,11304,11305,11307,11311,11314,11317,11318,11321,11322,11324,11327,11328,11333,11335,11336,11341,11344,11345,11347,11353,11354,11357,11358,11362,11363,11364,11369,11372,11373,11377,11378,11382,11385,11387,11390,11391,11394,11395,11399,11403,11406,11407,11408,11412,11415,11416,11417,11420,11424,11427,11430,11433,11434,11438,11440,11441,11445,11448,11451,11452,11454,11456,11459,11460,11462,11463,11466,11467,11471,11474,11475,11476,11479,11484,11487,11488,11489,11493,11498,11500,11501,11506,11509,11510,11511,11512,11516,11517,11520,11521,11522,11525,11528,11529,11533,11535,11536,11537,11542,11545,11546,11547,11548,11552,11553,11556,11557,11558,11565,11568,11569,11570,11571,11573,11577,11580,11583,11584,11586,11588,11591,11592,11594,11595,11598,11599,11603,11606,11607,11608,11611,11615,11618,11621,11622,11625,11630,11633,11634,11638,11642,11645,11647,11648,11652,11655,11657,11659,11663,11666,11669,11670,11672,11674,11675,11678,11679,11682,11683,11685,11686,11689,11695,11698,11699,11700,11701,11705,11706,11707,11712,11715,11716,11717,11720,11724,11727,11728,11729,11730,11734,11739,11742,11743,11744,11745,11751,11754,11755,11756,11761,11764,11765,11766,11772,11776,11779,11780,11781,11782,11789,11793,11796,11797,11798,11799,11800,11804,11807,11811,11814,11815,11816,11818,11820,11821,11823,11824,11826,11827,11830,11838,11841,11842,11843,11845,11851,11854,11855,11856,11858,11865,11868,11869,11870,11872,11878,11881,11882,11883,11885,11891,11894,11895,11896,11898,11902,11903,11904,11909,11912,11913,11914,11917,11921,11924,11925,11926,11927,11932,11935,11936,11937,11946,11950,11953,11954,11955,11956,11958,11964,11968,11971,11972,11973,11974,11976,11983,11986,11987,11988,11990,11995,11996,11997,12002,12005,12006,12007,12010,12014,12017,12018,12019,12020,12025,12029,12032,12033,12034,12035,12038,12042,12046,12049,12050,12051,12052,12053,12059,12063,12066,12067,12068,12069,12071,12077,12080,12081,12082,12084,12088,12091,12092,12096,12100,12103,12104,12108,12112,12115,12117,12121,12125,12128,12129,12130,12131,12135,12138,12140,12144,12147,12148,12149,12153,12156,12159,12160,12162,12164,12165,12168,12169,12172,12173,12175,12179,12182,12186,12189,12190,12191,12193,12195,12196,12199,12200,12203,12204,12206,12211,12212,12213,12218,12221,12222,12223,12226,12230,12233,12234,12235,12236,12241,12245,12248,12249,12250,12251,12254,12258,12262,12265,12266,12267,12268,12269,12275,12279,12282,12283,12284,12285,12287,12293,12296,12297,12298,12300,12304,12307,12311,12314,12315,12316,12318,12322,12325,12328,12329,12331,12335,12338,12339,12343,12347,12350,12351,12352,12356,12359,12360,12364,12368,12371,12372,12376,12380,12383,12385,12389,12393,12396,12397,12398,12399,12403,12406,12408,12412,12415,12416,12417,12421,12424,12427,12428,12430,12432,12433,12436,12437,12440,12441,12443,12447,12450,12454,12457,12458,12459,12461,12463,12464,12467,12468,12471,12472,12474,12475,12478,12482,12485,12488,12489,12492,12493,12496,12501,12504,12505,12506,12510,12513,12516,12517,12519,12521,12522,12524,12525,12526,12529,12533,12536,12539,12540,12542,12544,12547,12548,12550,12551,12554,12555,12559,12562,12563,12566,12570,12573,12574,12575,12578,12584,12587,12588,12589,12591,12596,12600,12603,12604,12606,12608,12614,12615,12621,12622,12624,12630,12633,12634,12635,12637,12638,12641,12646,12649,12652,12653,12658,12660,12661,12662,12666,12667,12670,12671,12675,12678,12680,12683,12684,12689,12692,12693,12694,12695,12698,12702,12705,12708,12709,12712,12713,12716,12720,12722,12723,12726,12727,12728,12731,12736,12739,12741,12746,12749,12752,12753,12755,12757,12758,12760,12761,12763,12764,12768,12771,12772,12776,12780,12783,12786,12789,12791,12794,12795,12798,12799,12803,12804,12808,12811,12814,12815,12817,12819,12820,12823,12824,12827,12828,12830,12834,12835,12839,12842,12845,12846,12848,12850,12851,12854,12855,12858,12859,12861,12865,12868,12871,12872,12874,12876,12877,12880,12881,12884,12885,12887,12888,12891,12896,12898,12899,12906,12909,12913,12916,12917,12920,12921,12924,12925,12930,12933,12934,12936,12939,12941,12944,12945,12946,12947,12951,12952,12953,12957,12958,12959,12962,12963,12967,12970,12971,12972,12976,12979,12980,12984,12988,12991,12993,12997,12998,12999,13003,13006,13009,13010,13012,13014,13015,13018,13019,13022,13023,13025,13029,13030,13035,13038,13039,13043,13044,13045,13050,13051,13053,13064,13065,13066,13068,13074,13075,13076,13078,13084,13085,13086,13088,13094,13095,13096,13098,13104,13105,13106,13108,13114,13117,13118,13123,13126,13127,13128,13132,13135,13136,13137,13141,13144,13147,13148,13150,13152,13155,13156,13158,13159,13162,13163,13167,13170,13171,13175,13176,13178,13183,13186,13187,13192,13195,13196,13197,13201,13204,13205,13206,13210,13213,13216,13217,13219,13221,13224,13225,13227,13228,13231,13232
-----computeFrom-----
246,247
246,248
252,253
252,254
272,273
272,274
279,280
279,281
287,288
287,289
311,312
311,313
341,342
341,343
343,344
343,345
350,351
350,352
361,362
361,363
395,396
395,397
400,401
400,402
402,403
402,404
410,411
410,412
435,436
435,437
447,448
447,449
480,481
480,482
483,484
483,485
495,496
495,497
497,498
497,499
502,503
502,504
510,511
510,512
546,547
546,548
606,607
606,608
623,624
623,625
633,634
633,635
656,657
656,658
664,665
664,666
666,667
666,668
686,687
686,688
714,715
714,716
729,730
729,731
730,731
730,732
737,738
737,739
771,772
771,773
784,785
784,786
785,786
785,787
786,787
786,788
793,794
793,795
802,803
802,804
810,811
810,812
815,816
815,817
830,831
830,832
845,846
845,847
885,886
885,887
895,896
895,897
903,904
903,905
910,911
910,912
934,935
934,936
942,943
942,944
952,953
952,954
974,975
974,976
1019,1020
1019,1021
1034,1035
1034,1036
1042,1043
1042,1044
1077,1078
1077,1079
1079,1080
1079,1081
1090,1091
1090,1092
1092,1093
1092,1094
1100,1101
1100,1102
1111,1112
1111,1113
1119,1120
1119,1121
1120,1121
1120,1122
1127,1128
1127,1129
1161,1162
1161,1163
1172,1173
1172,1174
1173,1174
1173,1175
1181,1182
1181,1183
1182,1183
1182,1184
1191,1192
1191,1193
1225,1226
1225,1227
1246,1247
1246,1248
1274,1275
1274,1276
1284,1285
1284,1286
1308,1309
1308,1310
1324,1325
1324,1326
1336,1337
1336,1338
1338,1339
1338,1340
1339,1340
1339,1341
1340,1341
1340,1342
1342,1343
1342,1344
1352,1353
1352,1354
1362,1363
1362,1364
1372,1373
1372,1374
1382,1383
1382,1384
1396,1397
1396,1398
1407,1408
1407,1409
1421,1422
1421,1423
1451,1452
1451,1453
1516,1517
1516,1518
1521,1522
1521,1523
1522,1523
1522,1524
1532,1533
1532,1534
1540,1541
1540,1542
1541,1542
1541,1543
1542,1543
1542,1544
1543,1544
1543,1545
1550,1551
1550,1552
1557,1558
1557,1559
1564,1565
1564,1566
1614,1615
1614,1616
1619,1620
1619,1621
1624,1625
1624,1626
1636,1637
1636,1638
1648,1649
1648,1650
1657,1658
1657,1659
1688,1689
1688,1690
1705,1706
1705,1707
1706,1707
1706,1708
1731,1732
1731,1733
1843,1844
1843,1845
1844,1845
1844,1846
1845,1846
1845,1847
1866,1867
1866,1868
1875,1876
1875,1877
1891,1892
1891,1893
1899,1900
1899,1901
1911,1912
1911,1913
1914,1915
1914,1916
1951,1952
1951,1953
1976,1977
1976,1978
2011,2012
2011,2013
2021,2022
2021,2023
2031,2032
2031,2033
2044,2045
2044,2046
2046,2047
2046,2048
2057,2058
2057,2059
2065,2066
2065,2067
2070,2071
2070,2072
2072,2073
2072,2074
2087,2088
2087,2089
2088,2089
2088,2090
2099,2100
2099,2101
2100,2101
2100,2102
2101,2102
2101,2103
2102,2103
2102,2104
2104,2105
2104,2106
2114,2115
2114,2116
2124,2125
2124,2126
2134,2135
2134,2136
2144,2145
2144,2146
2154,2155
2154,2156
2163,2164
2163,2165
2165,2166
2165,2167
2166,2167
2166,2168
2167,2168
2167,2169
2168,2169
2168,2170
2169,2170
2169,2171
2170,2171
2170,2172
2171,2172
2171,2173
2173,2174
2173,2175
2183,2184
2183,2185
2193,2194
2193,2195
2203,2204
2203,2205
2213,2214
2213,2215
2223,2224
2223,2225
2233,2234
2233,2235
2243,2244
2243,2245
2253,2254
2253,2255
2291,2292
2291,2293
2297,2298
2297,2299
2314,2315
2314,2316
2316,2317
2316,2318
2324,2325
2324,2326
2326,2327
2326,2328
2336,2337
2336,2338
2412,2413
2412,2414
2414,2415
2414,2416
2415,2416
2415,2417
2416,2417
2416,2418
2417,2418
2417,2419
2419,2420
2419,2421
2429,2430
2429,2431
2439,2440
2439,2441
2449,2450
2449,2451
2459,2460
2459,2461
2469,2470
2469,2471
2488,2489
2488,2490
2489,2490
2489,2491
2496,2497
2496,2498
2502,2503
2502,2504
2509,2510
2509,2511
2517,2518
2517,2519
2528,2529
2528,2530
2534,2535
2534,2536
2540,2541
2540,2542
2559,2560
2559,2561
2561,2562
2561,2563
2571,2572
2571,2573
2590,2591
2590,2592
2591,2592
2591,2593
2611,2612
2611,2613
2612,2613
2612,2614
2626,2627
2626,2628
2641,2642
2641,2643
2649,2650
2649,2651
2662,2663
2662,2664
2664,2665
2664,2666
2677,2678
2677,2679
2694,2695
2694,2696
2706,2707
2706,2708
2729,2730
2729,2731
2752,2753
2752,2754
2761,2762
2761,2763
2774,2775
2774,2776
2832,2833
2832,2834
2900,2901
2900,2902
2918,2919
2918,2920
2920,2921
2920,2922
2928,2929
2928,2930
2930,2931
2930,2932
2940,2941
2940,2942
2974,2975
2974,2976
2975,2976
2975,2977
2977,2978
2977,2979
2985,2986
2985,2987
2993,2994
2993,2995
3147,3148
3147,3149
3161,3162
3161,3163
3174,3175
3174,3176
3186,3187
3186,3188
3193,3194
3193,3195
3201,3202
3201,3203
3223,3224
3223,3225
3232,3233
3232,3234
3270,3271
3270,3272
3309,3310
3309,3311
3368,3369
3368,3370
3375,3376
3375,3377
3382,3383
3382,3384
3395,3396
3395,3397
3410,3411
3410,3412
3425,3426
3425,3427
3445,3446
3445,3447
3446,3447
3446,3448
3448,3449
3448,3450
3456,3457
3456,3458
3488,3489
3488,3490
3497,3498
3497,3499
3519,3520
3519,3521
3717,3718
3717,3719
3753,3754
3753,3755
3776,3777
3776,3778
3785,3786
3785,3787
3824,3825
3824,3826
3845,3846
3845,3847
3846,3847
3846,3848
3864,3865
3864,3866
3890,3891
3890,3892
3916,3917
3916,3918
3955,3956
3955,3957
3956,3957
3956,3958
3957,3958
3957,3959
3958,3959
3958,3960
3972,3973
3972,3974
3981,3982
3981,3983
3990,3991
3990,3992
4001,4002
4001,4003
4033,4034
4033,4035
4062,4063
4062,4064
4190,4191
4190,4192
4265,4266
4265,4267
4327,4328
4327,4329
4462,4463
4462,4464
4500,4501
4500,4502
4564,4565
4564,4566
4594,4595
4594,4596
4601,4602
4601,4603
4602,4603
4602,4604
4691,4692
4691,4693
4693,4694
4693,4695
4707,4708
4707,4709
4805,4806
4805,4807
4877,4878
4877,4879
4893,4894
4893,4895
4909,4910
4909,4911
4938,4939
4938,4940
4977,4978
4977,4979
4991,4992
4991,4993
5018,5019
5018,5020
5171,5172
5171,5173
5177,5178
5177,5179
5182,5183
5182,5184
5185,5186
5185,5187
5238,5239
5238,5240
5301,5302
5301,5303
5314,5315
5314,5316
5320,5321
5320,5322
5333,5334
5333,5335
5346,5347
5346,5348
5355,5356
5355,5357
5391,5392
5391,5393
5413,5414
5413,5415
5439,5440
5439,5441
5442,5443
5442,5444
5706,5707
5706,5708
5726,5727
5726,5728
5746,5747
5746,5748
5777,5778
5777,5779
5783,5784
5783,5785
5824,5825
5824,5826
5862,5863
5862,5864
5876,5877
5876,5878
5889,5890
5889,5891
5894,5895
5894,5896
5903,5904
5903,5905
5924,5925
5924,5926
5930,5931
5930,5932
6018,6019
6018,6020
6303,6304
6303,6305
6368,6369
6368,6370
6396,6397
6396,6398
6408,6409
6408,6410
6445,6446
6445,6447
6446,6447
6446,6448
6698,6699
6698,6700
6792,6793
6792,6794
6851,6852
6851,6853
6864,6865
6864,6866
6878,6879
6878,6880
6893,6894
6893,6895
7128,7129
7128,7130
7129,7130
7129,7131
7193,7194
7193,7195
7219,7220
7219,7221
7245,7246
7245,7247
7299,7300
7299,7301
7480,7481
7480,7482
7689,7690
7689,7691
7800,7801
7800,7802
7810,7811
7810,7812
7858,7859
7858,7860
7871,7872
7871,7873
7873,7874
7873,7875
7880,7881
7880,7882
7891,7892
7891,7893
7959,7960
7959,7961
7961,7962
7961,7963
7968,7969
7968,7970
7979,7980
7979,7981
8047,8048
8047,8049
8062,8063
8062,8064
8068,8069
8068,8070
8076,8077
8076,8078
8081,8082
8081,8083
8083,8084
8083,8085
8099,8100
8099,8101
8104,8105
8104,8106
8111,8112
8111,8113
8116,8117
8116,8118
8118,8119
8118,8120
8126,8127
8126,8128
8141,8142
8141,8143
8168,8169
8168,8170
8176,8177
8176,8178
8178,8179
8178,8180
8185,8186
8185,8187
8195,8196
8195,8197
8217,8218
8217,8219
8239,8240
8239,8241
8287,8288
8287,8289
8323,8324
8323,8325
8330,8331
8330,8332
8337,8338
8337,8339
8344,8345
8344,8346
8360,8361
8360,8362
8371,8372
8371,8373
8414,8415
8414,8416
8434,8435
8434,8436
8444,8445
8444,8446
8501,8502
8501,8503
8672,8673
8672,8674
8796,8797
8796,8798
8833,8834
8833,8835
8838,8839
8838,8840
8991,8992
8991,8993
8997,8998
8997,8999
9002,9003
9002,9004
9005,9006
9005,9007
9058,9059
9058,9060
9121,9122
9121,9123
9134,9135
9134,9136
9140,9141
9140,9142
9153,9154
9153,9155
9166,9167
9166,9168
9175,9176
9175,9177
9211,9212
9211,9213
9233,9234
9233,9235
9311,9312
9311,9313
9314,9315
9314,9316
9563,9564
9563,9565
9583,9584
9583,9585
9603,9604
9603,9605
9634,9635
9634,9636
9662,9663
9662,9664
9703,9704
9703,9705
9741,9742
9741,9743
9755,9756
9755,9757
9768,9769
9768,9770
9773,9774
9773,9775
9782,9783
9782,9784
9803,9804
9803,9805
9809,9810
9809,9811
9864,9865
9864,9866
10251,10252
10251,10253
10303,10304
10303,10305
10316,10317
10316,10318
10328,10329
10328,10330
10335,10336
10335,10337
10343,10344
10343,10345
10365,10366
10365,10367
10374,10375
10374,10376
10411,10412
10411,10413
10449,10450
10449,10451
10835,10836
10835,10837
10894,10895
10894,10896
10907,10908
10907,10909
10925,10926
10925,10927
10932,10933
10932,10934
10940,10941
10940,10942
10956,10957
10956,10958
10965,10966
10965,10967
11002,11003
11002,11004
11040,11041
11040,11042
11087,11088
11087,11089
11234,11235
11234,11236
11236,11237
11236,11238
11278,11279
11278,11280
11301,11302
11301,11303
11349,11350
11349,11351
11350,11351
11350,11352
11560,11561
11560,11562
11691,11692
11691,11693
11785,11786
11785,11787
11832,11833
11832,11834
11834,11835
11834,11836
11847,11848
11847,11849
11861,11862
11861,11863
11874,11875
11874,11876
11887,11888
11887,11889
11940,11941
11940,11942
11942,11943
11942,11944
11960,11961
11960,11962
11979,11980
11979,11981
12055,12056
12055,12057
12073,12074
12073,12075
12271,12272
12271,12273
12289,12290
12289,12291
12580,12581
12580,12582
12618,12619
12618,12620
12626,12627
12626,12628
12778,12779
12778,12780
12801,12802
12801,12803
12832,12833
12832,12834
12901,12902
12901,12903
12902,12903
12902,12904
12904,12905
12904,12906
13047,13048
13047,13049
13055,13056
13055,13057
13056,13057
13056,13058
13057,13058
13057,13059
13058,13059
13058,13060
13060,13061
13060,13062
13070,13071
13070,13072
13080,13081
13080,13082
13090,13091
13090,13092
13100,13101
13100,13102
13111,13112
13111,13113
13119,13120
13119,13121
13180,13181
13180,13182
13188,13189
13188,13190
-----guardedBy-----
313,328
318,337
353,386
356,368
416,426
438,754
442,621
441,516
444,520
517,621
505,620
563,602
562,601
636,682
689,702
833,898
937,946
1250,1293
1249,1292
1286,1306
1321,1439
1320,1438
1327,1410
1331,1414
1330,1413
1333,1417
1425,1439
1424,1438
1461,1512
1460,1511
1466,1518
1531,1797
1526,1802
1567,1605
1568,1606
1530,1828
1529,1827
1747,1797
1742,1792
1746,1796
1745,1795
1857,1969
1861,1974
1860,1973
1920,1969
1924,1974
1925,1960
1916,1962
1923,1973
1979,2049
1983,13176
2092,2358
2160,2364
2096,2407
2097,2377
2157,2340
2142,2231
2112,2201
2122,2211
2150,2342
2158,2320
2095,2406
2152,2241
2149,2341
2132,2221
2085,2310
2259,2364
2256,2340
2249,2342
2257,2320
2181,2366
2191,2344
2248,2341
2301,2358
2305,2362
2306,2377
2309,2376
2334,2366
2322,2364
2504,2536
2501,2533
2500,2532
2511,2525
2514,2521
2552,2893
2556,2897
2555,2896
2630,2647
2637,2646
2681,2836
2685,2867
2690,2845
2666,2754
2689,2866
2686,2758
2757,2771
2915,2970
2914,2969
3188,3323
3190,3293
3468,3481
3472,3486
3471,3485
3491,3651
3500,3531
3511,3710
3516,3528
3505,3651
3515,3772
3506,3652
3507,3653
3514,3771
3779,3841
3800,3828
3790,3841
3804,3832
3791,3842
3792,3843
3803,3831
3805,3833
3861,3912
3856,3907
3849,3894
3860,3911
3859,3910
3922,13012
3919,12997
3962,4005
3967,4010
3966,4027
3970,4030
3971,4031
4336,4390
4342,4385
4346,4389
4345,4388
4471,4573
4466,4568
4470,4572
4469,4571
4610,4643
4609,4646
4614,4637
4702,4711
4701,4710
4695,4713
4827,4838
4826,4837
5010,6345
5014,6349
5013,6348
5025,5135
5029,5139
5028,5138
5030,5131
6372,6386
6376,6390
6375,6389
6419,6432
6423,6436
6422,6435
6470,6542
6474,6546
6480,6537
6481,6538
6473,6545
6702,6724
6706,6728
6705,6727
6880,7076
6883,7061
6884,7062
7496,7649
7491,7644
7495,7648
7494,7647
7887,7956
7888,7904
7895,7941
7899,7945
7903,7956
7900,7946
7898,7944
7975,8044
7976,7992
7983,8029
7987,8033
7991,8044
7988,8034
7986,8032
8071,8095
8107,8122
8145,8172
8144,8171
8192,8215
8242,8251
8365,8378
8366,8379
8845,8954
8849,8958
8848,8957
8850,8881
10330,10463
10332,10434
10927,11054
10929,11025
11268,11341
11272,11407
11271,11406
11358,11391
11357,11394
11362,11385
11856,12298
11851,12454
11858,11872
11855,12458
11854,12457
11870,11883
11865,11878
11869,11882
11868,11881
11974,12298
11968,12454
11973,12459
11972,12458
11971,12457
11976,11990
11988,12082
11983,12186
11987,12190
11986,12189
12589,12635
12584,12630
12588,12634
12587,12633
12906,12936
12917,12934
12924,12944
12916,12933
12925,12945
13068,13152
13132,13144
13136,13148
13137,13163
13135,13162
13201,13213
13205,13217
13206,13232
13204,13231
-----guardedByNegation-----
353,413
347,406
636,718
637,690
689,718
736,792
741,797
742,798
734,790
743,799
833,907
937,956
1126,1179
1131,1195
1132,1196
1124,1177
1133,1197
2092,2481
2160,2475
2096,2485
2097,2486
2157,2472
2112,2447
2150,2465
2158,2473
2095,2484
2152,2457
2149,2464
2305,2386
2309,2385
2511,2536
2514,2532
2634,2655
2638,2659
2637,2658
2639,2660
2681,2893
2685,2897
2690,2880
2689,2896
2686,2898
3188,3341
3190,3352
3868,3894
3869,3895
3870,3896
5021,6228
5025,6345
5029,6349
5028,6348
5030,6237
6372,6400
6376,6404
6375,6403
7887,8044
7884,7972
7888,7992
8072,8108
8071,8129
8066,8103
8107,8129
8192,8237
8841,10158
8845,10527
8849,10531
8848,10530
8850,10167
10330,10480
10332,10490
10927,11071
10929,11081
11870,11896
11865,11891
11869,11895
11868,11894
11988,12298
11983,12454
11987,12458
11986,12457
12803,12834
-----lastLexicalUse-----
353,413
636,718
689,718
833,907
937,956
2112,2447
2150,2465
2095,2484
2092,2481
2160,2475
2157,2472
2096,2485
2097,2486
2158,2473
2152,2457
2149,2464
2305,2386
2309,2385
2511,2536
2514,2532
2637,2658
2681,2893
2685,2897
2690,2880
2689,2896
2686,2898
3190,3352
3188,3341
5025,6345
5029,6349
5028,6348
5030,6237
6372,6400
6376,6404
6375,6403
7888,7992
7887,8044
8071,8129
8107,8129
8192,8237
8845,10527
8849,10531
8848,10530
8850,10167
10332,10490
10330,10480
10927,11071
10929,11081
11870,11896
11865,11891
11869,11895
11868,11894
11983,12454
11987,12458
11986,12457
11988,12298
-----jump-----
353,413
636,718
689,718
833,907
937,956
2112,2447
2150,2465
2095,2484
2092,2481
2160,2475
2157,2472
2096,2485
2097,2486
2158,2473
2152,2457
2149,2464
2305,2386
2309,2385
2511,2536
2514,2532
2637,2658
2681,2893
2685,2897
2690,2880
2689,2896
2686,2898
3190,3352
3188,3341
5025,6345
5029,6349
5028,6348
5030,6237
6372,6400
6376,6404
6375,6403
7888,7992
7887,8044
8071,8129
8107,8129
8192,8237
8845,10527
8849,10531
8848,10530
8850,10167
10332,10490
10330,10480
10927,11071
10929,11081
11870,11896
11865,11891
11869,11895
11868,11894
11983,12454
11987,12458
11986,12457
11988,12298
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;ProblemStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;CastExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;Pointer;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;CastExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;Pointer;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;CastExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;Pointer;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;CastExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;Pointer;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;InitializerList;LiteralExpression;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;BinaryExpression;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ReturnStatement;LiteralExpression;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;UnaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;IfStatement;BinaryExpression;IdExpression;Name;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ReturnStatement;LiteralExpression;ProblemStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;UnaryExpression;UnaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;ReturnStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;IdExpression;Name;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ReturnStatement;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ArrayDeclarator;ReferenceOperator;Name;ArrayModifier;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ReturnStatement;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;UnaryExpression;FunctionCallExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ReturnStatement;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;IdExpression;Name;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;TypeIdExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ReturnStatement;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;TypeIdExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;UnaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ReturnStatement;LiteralExpression;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ProblemStatement;CompoundStatement;ProblemStatement;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;IfStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;ProblemExpression;CompoundStatement;IfStatement;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ReturnStatement;LiteralExpression;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ArrayDeclarator;ReferenceOperator;Name;ArrayModifier;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ArrayDeclarator;ReferenceOperator;Name;ArrayModifier;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ReturnStatement;LiteralExpression;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ArrayDeclarator;ReferenceOperator;Name;ArrayModifier;FieldReference;IdExpression;Name;Name;ReturnStatement;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;EqualsInitializer;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BinaryExpression;BinaryExpression;IdExpression;Name;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IfStatement;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ArrayDeclarator;ReferenceOperator;Name;ArrayModifier;FieldReference;IdExpression;Name;Name;ReturnStatement;LiteralExpression;ExpressionStatement;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;UnaryExpression;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;UnaryExpression;IdExpression;Name;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;UnaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;IfStatement;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ArrayDeclarator;Name;ArrayModifier;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ArrayDeclarator;Name;ArrayModifier;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;UnaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;IfStatement;BinaryExpression;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;UnaryExpression;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ArrayDeclarator;ReferenceOperator;Name;ArrayModifier;FieldReference;IdExpression;Name;Name;ReturnStatement;LiteralExpression;CompoundStatement;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IfStatement;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;CompoundStatement;IfStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IfStatement;BinaryExpression;UnaryExpression;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;UnaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;IfStatement;BinaryExpression;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;UnaryExpression;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;UnaryExpression;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;ProblemStatement;CompoundStatement;IfStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;IfStatement;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;IdExpression;Name;CompoundStatement;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ArrayDeclarator;ReferenceOperator;Name;ArrayModifier;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;IfStatement;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ArrayDeclarator;ReferenceOperator;Name;ArrayModifier;FieldReference;IdExpression;Name;Name;ReturnStatement;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;UnaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ArrayDeclarator;ReferenceOperator;Name;ArrayModifier;FieldReference;IdExpression;Name;Name;ReturnStatement;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ArrayDeclarator;ReferenceOperator;Name;ArrayModifier;FieldReference;IdExpression;Name;Name;ReturnStatement;LiteralExpression;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;ProblemStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ArrayDeclarator;ReferenceOperator;Name;ArrayModifier;FieldReference;IdExpression;Name;Name;ReturnStatement;LiteralExpression;IfStatement;UnaryExpression;BinaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;NullStatement;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ArrayDeclarator;Name;ArrayModifier;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IfStatement;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;IfStatement;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IfStatement;FieldReference;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ArrayDeclarator;ReferenceOperator;Name;ArrayModifier;FieldReference;IdExpression;Name;Name;ReturnStatement;LiteralExpression;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IfStatement;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;IfStatement;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;SwitchStatement;FieldReference;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;CaseStatement;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;BreakStatement;IfStatement;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ConditionalExpression;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;BreakStatement;IfStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;BreakStatement;IfStatement;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;ProblemStatement;CompoundStatement;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;BreakStatement;IfStatement;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ArrayDeclarator;ReferenceOperator;Name;ArrayModifier;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;BreakStatement;IfStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;UnaryExpression;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;IfStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;BreakStatement;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;BreakStatement;IfStatement;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;Declarator;Pointer;Name;Declarator;Pointer;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ArrayDeclarator;ReferenceOperator;Name;ArrayModifier;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;BreakStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;IfStatement;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;BreakStatement;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;IfStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;BinaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;BinaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;IfStatement;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;BreakStatement;IfStatement;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;IfStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;UnaryExpression;UnaryExpression;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;ConditionalExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;IfStatement;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;BreakStatement;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;BreakStatement;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;IfStatement;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BreakStatement;IfStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;IfStatement;BinaryExpression;UnaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;IfStatement;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IfStatement;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;BreakStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;IfStatement;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IfStatement;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;BreakStatement;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;ConditionalExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;BreakStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;ConditionalExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ArrayDeclarator;ReferenceOperator;Name;ArrayModifier;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;BinaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;BreakStatement;IfStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BreakStatement;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;IfStatement;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IfStatement;UnaryExpression;UnaryExpression;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;IfStatement;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;BreakStatement;IfStatement;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IfStatement;FieldReference;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IfStatement;FieldReference;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IfStatement;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;ReferenceOperator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;IdExpression;Name;ProblemStatement;IfStatement;UnaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;UnaryExpression;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;UnaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;UnaryExpression;BinaryExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;CompoundStatement;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;LiteralExpression;LiteralExpression;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ConditionalExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;BreakStatement;IfStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ProblemStatement;NullStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ConditionalExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;IfStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ConditionalExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;BreakStatement;IfStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;BreakStatement;IfStatement;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;IfStatement;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;BreakStatement;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;IfStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;BinaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;BinaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;IdExpression;Name;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;IfStatement;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;BreakStatement;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;UnaryExpression;UnaryExpression;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;ConditionalExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;ConditionalExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IfStatement;IdExpression;Name;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;IfStatement;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;BreakStatement;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;IfStatement;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;IfStatement;UnaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;ProblemStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;GotoStatement;Name;BreakStatement;CaseStatement;IdExpression;Name;LabelStatement;Name;IfStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;ConditionalExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;IfStatement;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;BreakStatement;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;LiteralExpression;UnaryExpression;LiteralExpression;IfStatement;UnaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;ProblemStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;IfStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;BreakStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;BreakStatement;IfStatement;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;BreakStatement;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IfStatement;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;BreakStatement;IfStatement;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ArrayDeclarator;ReferenceOperator;Name;ArrayModifier;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BreakStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;IfStatement;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;ConditionalExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;ConditionalExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ConditionalExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;UnaryExpression;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IfStatement;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;IfStatement;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;LiteralExpression;UnaryExpression;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ConditionalExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;IfStatement;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ConditionalExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;ConditionalExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ConditionalExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;ConditionalExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;IfStatement;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;ProblemStatement;CompoundStatement;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;BreakStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FieldReference;IdExpression;Name;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;LiteralExpression;UnaryExpression;LiteralExpression;BreakStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;IfStatement;BinaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FieldReference;IdExpression;Name;Name;BreakStatement;DefaultStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ArrayDeclarator;ReferenceOperator;Name;ArrayModifier;FieldReference;IdExpression;Name;Name;ReturnStatement;LiteralExpression;IfStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;
-----ast_node-----
static int socket_process_helper(struct iax2_thread *thread){	struct sockaddr_in sin;	int res;	int updatehistory=1;	int new = NEW_PREVENT;	int dcallno = 0;	char decrypted = 0;	struct ast_iax2_full_hdr *fh = (struct ast_iax2_full_hdr *)thread->buf;	struct ast_iax2_mini_hdr *mh = (struct ast_iax2_mini_hdr *)thread->buf;	struct ast_iax2_meta_hdr *meta = (struct ast_iax2_meta_hdr *)thread->buf;	struct ast_iax2_video_hdr *vh = (struct ast_iax2_video_hdr *)thread->buf;	struct iax_frame *fr;	struct iax_frame *cur;	struct ast_frame f = { 0, };	struct ast_channel *c = NULL;	struct iax2_dpcache *dp;	struct iax2_peer *peer;	struct iax_ies ies;	struct iax_ie_data ied0, ied1;	iax2_format format;	int fd;	int exists;	int minivid = 0;	char empty[32]="";		/* Safety measure */	struct iax_frame *duped_fr;	char host_pref_buf[128];	char caller_pref_buf[128];	struct ast_codec_pref pref;	char *using_prefs = "mine";	/* allocate an iax_frame with 4096 bytes of data buffer */	fr = ast_alloca(sizeof(*fr) + 4096);	memset(fr, 0, sizeof(*fr));	fr->afdatalen = 4096; /* From ast_alloca() above */	/* Copy frequently used parameters to the stack */	res = thread->buf_len;	fd = thread->iofd;	memcpy(&sin, &thread->iosin, sizeof(sin));	if (res < sizeof(*mh)) {		ast_log(LOG_WARNING, "midget packet received (%d of %d min)\n", res, (int) sizeof(*mh));		return 1;	}	if ((vh->zeros == 0) && (ntohs(vh->callno) & 0x8000)) {		if (res < sizeof(*vh)) {			ast_log(LOG_WARNING, "Rejecting packet from '%s.%d' that is flagged as a video frame but is too short\n", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));			return 1;		}		/* This is a video frame, get call number */		fr->callno = find_callno(ntohs(vh->callno) & ~0x8000, dcallno, &sin, new, fd, 0);		minivid = 1;	} else if ((meta->zeros == 0) && !(ntohs(meta->metacmd) & 0x8000))		return socket_process_meta(res, meta, &sin, fd, fr);#ifdef DEBUG_SUPPORT	if (res >= sizeof(*fh))		iax_outputframe(NULL, fh, 1, &sin, res - sizeof(*fh));#endif	if (ntohs(mh->callno) & IAX_FLAG_FULL) {		if (res < sizeof(*fh)) {			ast_log(LOG_WARNING, "Rejecting packet from '%s.%d' that is flagged as a full frame but is too short\n", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));			return 1;		}		/* Get the destination call number */		dcallno = ntohs(fh->dcallno) & ~IAX_FLAG_RETRANS;		/* check to make sure this full frame isn't encrypted before we attempt 		 * to look inside of it. If it is encrypted, decrypt it first. Its ok if the		 * callno is not found here, that just means one hasn't been allocated for		 * this connection yet. */		if ((dcallno != 1) && (fr->callno = find_callno(ntohs(mh->callno) & ~IAX_FLAG_FULL, dcallno, &sin, NEW_PREVENT, fd, 1))) {			ast_mutex_lock(&iaxsl[fr->callno]);			if (iaxs[fr->callno] && ast_test_flag64(iaxs[fr->callno], IAX_ENCRYPTED)) {				if (decrypt_frame(fr->callno, fh, &f, &res)) {					ast_log(LOG_NOTICE, "Packet Decrypt Failed!\n");					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}				decrypted = 1;			}			ast_mutex_unlock(&iaxsl[fr->callno]);		}		/* Retrieve the type and subclass */		f.frametype = fh->type;		if (f.frametype == AST_FRAME_VIDEO) {			ast_format_from_old_bitfield(&f.subclass.format, (uncompress_subclass(fh->csub & ~0x40)));			if ((fh->csub >> 6) & 0x1) {				ast_format_set_video_mark(&f.subclass.format);			}		} else if (f.frametype == AST_FRAME_VOICE) {			ast_format_from_old_bitfield(&f.subclass.format, uncompress_subclass(fh->csub));		} else {			f.subclass.integer = uncompress_subclass(fh->csub);		}		/* Deal with POKE/PONG without allocating a callno */		if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_POKE) {			/* Reply back with a PONG, but don't care about the result. */			send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_PONG, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			return 1;		} else if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_ACK && dcallno == 1) {			/* Ignore */			return 1;		}		f.datalen = res - sizeof(*fh);		if (f.datalen) {			if (f.frametype == AST_FRAME_IAX) {				if (iax_parse_ies(&ies, thread->buf + sizeof(struct ast_iax2_full_hdr), f.datalen)) {					ast_log(LOG_WARNING, "Undecodable frame received from '%s'\n", ast_inet_ntoa(sin.sin_addr));					ast_variables_destroy(ies.vars);					return 1;				}				f.data.ptr = NULL;				f.datalen = 0;			} else {				f.data.ptr = thread->buf + sizeof(struct ast_iax2_full_hdr);				memset(&ies, 0, sizeof(ies));			}		} else {			if (f.frametype == AST_FRAME_IAX)				f.data.ptr = NULL;			else				f.data.ptr = empty;			memset(&ies, 0, sizeof(ies));		}		if (!dcallno && iax2_allow_new(f.frametype, f.subclass.integer, 1)) {			/* only set NEW_ALLOW if calltoken checks out */			if (handle_call_token(fh, &ies, &sin, fd)) {				ast_variables_destroy(ies.vars);				return 1;			}			if (ies.calltoken && ies.calltokendata) {				/* if we've gotten this far, and the calltoken ie data exists,				 * then calltoken validation _MUST_ have taken place.  If calltoken				 * data is provided, it is always validated reguardless of any				 * calltokenoptional or requirecalltoken options */				new = NEW_ALLOW_CALLTOKEN_VALIDATED;			} else {				new = NEW_ALLOW;			}		}	} else {		/* Don't know anything about it yet */		f.frametype = AST_FRAME_NULL;		f.subclass.integer = 0;		memset(&ies, 0, sizeof(ies));	}	if (!fr->callno) {		int check_dcallno = 0;		/*		 * We enforce accurate destination call numbers for ACKs.  This forces the other		 * end to know the destination call number before call setup can complete.		 *		 * Discussed in the following thread:		 *    http://lists.digium.com/pipermail/asterisk-dev/2008-May/033217.html 		 */		if ((ntohs(mh->callno) & IAX_FLAG_FULL) && ((f.frametype == AST_FRAME_IAX) && (f.subclass.integer == IAX_COMMAND_ACK))) {			check_dcallno = 1;		}		if (!(fr->callno = find_callno(ntohs(mh->callno) & ~IAX_FLAG_FULL, dcallno, &sin, new, fd, check_dcallno))) {			if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_NEW) {				send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REJECT, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			} else if (f.frametype == AST_FRAME_IAX && (f.subclass.integer == IAX_COMMAND_REGREQ || f.subclass.integer == IAX_COMMAND_REGREL)) {				send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REGREJ, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			}			ast_variables_destroy(ies.vars);			return 1;		}	}	if (fr->callno > 0) {		struct ast_callid *mount_callid;		ast_mutex_lock(&iaxsl[fr->callno]);		if (iaxs[fr->callno] && ((mount_callid = iax_pvt_callid_get(fr->callno)))) {			/* Bind to thread */			ast_callid_threadassoc_add(mount_callid);			ast_callid_unref(mount_callid);		}	}	if (!fr->callno || !iaxs[fr->callno]) {		/* A call arrived for a nonexistent destination.  Unless it's an "inval"		   frame, reply with an inval */		if (ntohs(mh->callno) & IAX_FLAG_FULL) {			/* We can only raw hangup control frames */			if (((f.subclass.integer != IAX_COMMAND_INVAL) &&				 (f.subclass.integer != IAX_COMMAND_TXCNT) &&				 (f.subclass.integer != IAX_COMMAND_TXACC) &&				 (f.subclass.integer != IAX_COMMAND_FWDOWNL))||			    (f.frametype != AST_FRAME_IAX))				raw_hangup(&sin, ntohs(fh->dcallno) & ~IAX_FLAG_RETRANS, ntohs(mh->callno) & ~IAX_FLAG_FULL,				fd);		}		if (fr->callno > 0) 			ast_mutex_unlock(&iaxsl[fr->callno]);		ast_variables_destroy(ies.vars);		return 1;	}	if (ast_test_flag64(iaxs[fr->callno], IAX_ENCRYPTED) && !decrypted) {		if (decrypt_frame(fr->callno, fh, &f, &res)) {			ast_log(LOG_NOTICE, "Packet Decrypt Failed!\n");			ast_variables_destroy(ies.vars);			ast_mutex_unlock(&iaxsl[fr->callno]);			return 1;		}		decrypted = 1;	}#ifdef DEBUG_SUPPORT	if (decrypted) {		iax_outputframe(NULL, fh, 3, &sin, res - sizeof(*fh));	}#endif	if (iaxs[fr->callno]->owner && fh->type == AST_FRAME_IAX &&			(fh->csub == IAX_COMMAND_HANGUP			|| fh->csub == IAX_COMMAND_REJECT			|| fh->csub == IAX_COMMAND_REGREJ			|| fh->csub == IAX_COMMAND_TXREJ)) {		struct ast_control_pvt_cause_code *cause_code;		int data_size = sizeof(*cause_code);		char subclass[40] = "";		/* get subclass text */		iax_frame_subclass2str(fh->csub, subclass, sizeof(subclass));		/* add length of "IAX2 " */		data_size += 5;		/* for IAX hangup frames, add length of () and number */		data_size += 3;		if (ies.causecode > 9) {			data_size++;		}		if (ies.causecode > 99) {			data_size++;		}		/* add length of subclass */		data_size += strlen(subclass);		cause_code = ast_alloca(data_size);		ast_copy_string(cause_code->chan_name, ast_channel_name(iaxs[fr->callno]->owner), AST_CHANNEL_NAME);		cause_code->ast_cause = ies.causecode;		snprintf(cause_code->code, data_size - sizeof(*cause_code) + 1, "IAX2 %s(%d)", subclass, ies.causecode);		iax2_lock_owner(fr->callno);		if (iaxs[fr->callno] && iaxs[fr->callno]->owner) {			ast_queue_control_data(iaxs[fr->callno]->owner, AST_CONTROL_PVT_CAUSE_CODE, cause_code, data_size);			ast_channel_hangupcause_hash_set(iaxs[fr->callno]->owner, cause_code, data_size);			ast_channel_unlock(iaxs[fr->callno]->owner);		}		if (!iaxs[fr->callno]) {			ast_variables_destroy(ies.vars);			ast_mutex_unlock(&iaxsl[fr->callno]);			return 1;		}	}	/* count this frame */	iaxs[fr->callno]->frames_received++;	if (!inaddrcmp(&sin, &iaxs[fr->callno]->addr) && !minivid &&		f.subclass.integer != IAX_COMMAND_TXCNT &&		/* for attended transfer */		f.subclass.integer != IAX_COMMAND_TXACC) {		/* for attended transfer */		unsigned short new_peercallno;		new_peercallno = (unsigned short) (ntohs(mh->callno) & ~IAX_FLAG_FULL);		if (new_peercallno && new_peercallno != iaxs[fr->callno]->peercallno) {			if (iaxs[fr->callno]->peercallno) {				remove_by_peercallno(iaxs[fr->callno]);			}			iaxs[fr->callno]->peercallno = new_peercallno;			store_by_peercallno(iaxs[fr->callno]);		}	}	if (ntohs(mh->callno) & IAX_FLAG_FULL) {		if (iaxdebug)			ast_debug(1, "Received packet %d, (%d, %u)\n", fh->oseqno, f.frametype, f.subclass.integer);		/* Check if it's out of order (and not an ACK or INVAL) */		fr->oseqno = fh->oseqno;		fr->iseqno = fh->iseqno;		fr->ts = ntohl(fh->ts);#ifdef IAXTESTS		if (test_resync) {			ast_debug(1, "Simulating frame ts resync, was %u now %u\n", fr->ts, fr->ts + test_resync);			fr->ts += test_resync;		}#endif /* IAXTESTS */#if 0		if ( (ntohs(fh->dcallno) & IAX_FLAG_RETRANS) ||		     ( (f.frametype != AST_FRAME_VOICE) && ! (f.frametype == AST_FRAME_IAX &&								(f.subclass == IAX_COMMAND_NEW ||								 f.subclass == IAX_COMMAND_AUTHREQ ||								 f.subclass == IAX_COMMAND_ACCEPT ||								 f.subclass == IAX_COMMAND_REJECT))      ) )#endif		if ((ntohs(fh->dcallno) & IAX_FLAG_RETRANS) || (f.frametype != AST_FRAME_VOICE))			updatehistory = 0;		if ((iaxs[fr->callno]->iseqno != fr->oseqno) &&			(iaxs[fr->callno]->iseqno ||				((f.subclass.integer != IAX_COMMAND_TXCNT) &&				(f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXACC)) ||				(f.frametype != AST_FRAME_IAX))) {			if (			 ((f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_INVAL) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&			  (f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_VNAK)) ||			  (f.frametype != AST_FRAME_IAX)) {				/* If it's not an ACK packet, it's out of order. */				ast_debug(1, "Packet arrived out of order (expecting %d, got %d) (frametype = %d, subclass = %d)\n",					iaxs[fr->callno]->iseqno, fr->oseqno, f.frametype, f.subclass.integer);				/* Check to see if we need to request retransmission,				 * and take sequence number wraparound into account */				if ((unsigned char) (iaxs[fr->callno]->iseqno - fr->oseqno) < 128) {					/* If we've already seen it, ack it XXX There's a border condition here XXX */					if ((f.frametype != AST_FRAME_IAX) ||							((f.subclass.integer != IAX_COMMAND_ACK) && (f.subclass.integer != IAX_COMMAND_INVAL))) {						ast_debug(1, "Acking anyway\n");						/* XXX Maybe we should handle its ack to us, but then again, it's probably outdated anyway, and if						   we have anything to send, we'll retransmit and get an ACK back anyway XXX */						send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					}				} else {					/* Send a VNAK requesting retransmission */					iax2_vnak(fr->callno);				}				ast_variables_destroy(ies.vars);				ast_mutex_unlock(&iaxsl[fr->callno]);				return 1;			}		} else {			/* Increment unless it's an ACK or VNAK */			if (((f.subclass.integer != IAX_COMMAND_ACK) &&			    (f.subclass.integer != IAX_COMMAND_INVAL) &&			    (f.subclass.integer != IAX_COMMAND_TXCNT) &&			    (f.subclass.integer != IAX_COMMAND_TXACC) &&				(f.subclass.integer != IAX_COMMAND_VNAK)) ||			    (f.frametype != AST_FRAME_IAX))				iaxs[fr->callno]->iseqno++;		}		/* Ensure text frames are NULL-terminated */		if (f.frametype == AST_FRAME_TEXT && thread->buf[res - 1] != '\0') {			if (res < thread->buf_size)				thread->buf[res++] = '\0';			else /* Trims one character from the text message, but that's better than overwriting the end of the buffer. */				thread->buf[res - 1] = '\0';		}		/* Handle implicit ACKing unless this is an INVAL, and only if this is 		   from the real peer, not the transfer peer */		if (!inaddrcmp(&sin, &iaxs[fr->callno]->addr) &&		    ((f.subclass.integer != IAX_COMMAND_INVAL) ||		     (f.frametype != AST_FRAME_IAX))) {			unsigned char x;			int call_to_destroy;			/* First we have to qualify that the ACKed value is within our window */			if (iaxs[fr->callno]->rseqno >= iaxs[fr->callno]->oseqno || (fr->iseqno >= iaxs[fr->callno]->rseqno && fr->iseqno < iaxs[fr->callno]->oseqno))				x = fr->iseqno;			else				x = iaxs[fr->callno]->oseqno;			if ((x != iaxs[fr->callno]->oseqno) || (iaxs[fr->callno]->oseqno == fr->iseqno)) {				/* The acknowledgement is within our window.  Time to acknowledge everything				   that it says to */				for (x=iaxs[fr->callno]->rseqno; x != fr->iseqno; x++) {					/* Ack the packet with the given timestamp */					if (iaxdebug)						ast_debug(1, "Cancelling transmission of packet %d\n", x);					call_to_destroy = 0;					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* If it's our call, and our timestamp, mark -1 retries */						if (x == cur->oseqno) {							cur->retries = -1;							/* Destroy call if this is the end */							if (cur->final)								call_to_destroy = fr->callno;						}					}					if (call_to_destroy) {						if (iaxdebug)							ast_debug(1, "Really destroying %d, having been acked on final message\n", call_to_destroy);						ast_mutex_lock(&iaxsl[call_to_destroy]);						iax2_destroy(call_to_destroy);						ast_mutex_unlock(&iaxsl[call_to_destroy]);					}				}				/* Note how much we've received acknowledgement for */				if (iaxs[fr->callno])					iaxs[fr->callno]->rseqno = fr->iseqno;				else {					/* Stop processing now */					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}			} else {				ast_debug(1, "Received iseqno %d not within window %d->%d\n", fr->iseqno, iaxs[fr->callno]->rseqno, iaxs[fr->callno]->oseqno);			}		}		if (inaddrcmp(&sin, &iaxs[fr->callno]->addr) &&			((f.frametype != AST_FRAME_IAX) ||			 ((f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT)))) {			/* Only messages we accept from a transfer host are TXACC and TXCNT */			ast_variables_destroy(ies.vars);			ast_mutex_unlock(&iaxsl[fr->callno]);			return 1;		}		/* when we receive the first full frame for a new incoming channel,		   it is safe to start the PBX on the channel because we have now		   completed a 3-way handshake with the peer */		if ((f.frametype == AST_FRAME_VOICE) ||		    (f.frametype == AST_FRAME_VIDEO) ||		    (f.frametype == AST_FRAME_IAX)) {			if (ast_test_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART)) {				ast_clear_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);				if (!ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->chosenformat, NULL)) {					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}			}			if (ies.vars) {				struct ast_datastore *variablestore = NULL;				struct ast_variable *var, *prev = NULL;				AST_LIST_HEAD(, ast_var_t) *varlist;				iax2_lock_owner(fr->callno);				if (!iaxs[fr->callno]) {					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}				if ((c = iaxs[fr->callno]->owner)) {					varlist = ast_calloc(1, sizeof(*varlist));					variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);					if (variablestore && varlist) {						variablestore->data = varlist;						variablestore->inheritance = DATASTORE_INHERIT_FOREVER;						AST_LIST_HEAD_INIT(varlist);						ast_debug(1, "I can haz IAX vars?\n");						for (var = ies.vars; var; var = var->next) {							struct ast_var_t *newvar = ast_var_assign(var->name, var->value);							if (prev) {								ast_free(prev);							}							prev = var;							if (!newvar) {								/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");							} else {								AST_LIST_INSERT_TAIL(varlist, newvar, entries);							}						}						if (prev) {							ast_free(prev);						}						ies.vars = NULL;						ast_channel_datastore_add(c, variablestore);					} else {						ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");						if (variablestore) {							ast_datastore_free(variablestore);						}						if (varlist) {							ast_free(varlist);						}					}					ast_channel_unlock(c);				} else {					/* No channel yet, so transfer the variables directly over to the pvt,					 * for later inheritance. */					ast_debug(1, "No channel, so populating IAXVARs to the pvt, as an intermediate step.\n");					for (var = ies.vars; var && var->next; var = var->next);					if (var) {						var->next = iaxs[fr->callno]->iaxvars;						iaxs[fr->callno]->iaxvars = ies.vars;						ies.vars = NULL;					}				}			}			if (ies.vars) {				ast_debug(1, "I have IAX variables, but they were not processed\n");			}		}		/* once we receive our first IAX Full Frame that is not CallToken related, send all		 * queued signaling frames that were being held. */		if ((f.frametype == AST_FRAME_IAX) && (f.subclass.integer != IAX_COMMAND_CALLTOKEN) && iaxs[fr->callno]->hold_signaling) {			send_signaling(iaxs[fr->callno]);		}		if (f.frametype == AST_FRAME_VOICE) {			if (ast_format_to_old_bitfield(&f.subclass.format) != iaxs[fr->callno]->voiceformat) {					iaxs[fr->callno]->voiceformat = ast_format_to_old_bitfield(&f.subclass.format);					ast_debug(1, "Ooh, voice format changed to '%s'\n", ast_getformatname(&f.subclass.format));					if (iaxs[fr->callno]->owner) {						iax2_lock_owner(fr->callno);						if (iaxs[fr->callno]) {							if (iaxs[fr->callno]->owner) {								struct ast_format_cap *orignative = ast_format_cap_dup(ast_channel_nativeformats(iaxs[fr->callno]->owner));								struct ast_format_cap *native = ast_channel_nativeformats(iaxs[fr->callno]->owner);								if (orignative) {									ast_format_cap_set(native, &f.subclass.format);									if (ast_channel_readformat(iaxs[fr->callno]->owner)->id) {										ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));									}									ast_format_cap_copy(native, orignative);									ast_channel_unlock(iaxs[fr->callno]->owner);									orignative = ast_format_cap_destroy(orignative);								}							}						} else {							ast_debug(1, "Neat, somebody took away the channel at a magical time but i found it!\n");							/* Free remote variables (if any) */							if (ies.vars) {								ast_variables_destroy(ies.vars);								ast_debug(1, "I can haz iaxvars, but they is no good.  :-(\n");								ies.vars = NULL;							}							ast_mutex_unlock(&iaxsl[fr->callno]);							return 1;						}					}			}		}		if (f.frametype == AST_FRAME_VIDEO) {			if (f.subclass.format.id != ast_format_id_from_old_bitfield(iaxs[fr->callno]->videoformat)) {				ast_debug(1, "Ooh, video format changed to %s\n", ast_getformatname(&f.subclass.format));				iaxs[fr->callno]->videoformat = ast_format_to_old_bitfield(&f.subclass.format);			}		}		if (f.frametype == AST_FRAME_CONTROL && iaxs[fr->callno]->owner) {			if (f.subclass.integer == AST_CONTROL_BUSY) {				ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_BUSY);			} else if (f.subclass.integer == AST_CONTROL_CONGESTION) {				ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_CONGESTION);			}		}		if (f.frametype == AST_FRAME_IAX) {			AST_SCHED_DEL(sched, iaxs[fr->callno]->initid);			/* Handle the IAX pseudo frame itself */			if (iaxdebug)				ast_debug(1, "IAX subclass %d received\n", f.subclass.integer);                        /* Update last ts unless the frame's timestamp originated with us. */			if (iaxs[fr->callno]->last < fr->ts &&                            f.subclass.integer != IAX_COMMAND_ACK &&                            f.subclass.integer != IAX_COMMAND_PONG &&                            f.subclass.integer != IAX_COMMAND_LAGRP) {				iaxs[fr->callno]->last = fr->ts;				if (iaxdebug)					ast_debug(1, "For call=%d, set last=%d\n", fr->callno, fr->ts);			}			iaxs[fr->callno]->last_iax_message = f.subclass.integer;			if (!iaxs[fr->callno]->first_iax_message) {				iaxs[fr->callno]->first_iax_message = f.subclass.integer;			}			switch(f.subclass.integer) {			case IAX_COMMAND_ACK:				/* Do nothing */				break;			case IAX_COMMAND_QUELCH:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {				        /* Generate Manager Hold event, if necessary*/					if (iaxs[fr->callno]->owner) {						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: On\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}					ast_set_flag64(iaxs[fr->callno], IAX_QUELCH);					if (ies.musiconhold) {						iax2_lock_owner(fr->callno);						if (!iaxs[fr->callno] || !iaxs[fr->callno]->owner) {							break;						}						if (ast_bridged_channel(iaxs[fr->callno]->owner)) {							const char *moh_suggest = iaxs[fr->callno]->mohsuggest;							/*							 * We already hold the owner lock so we do not							 * need to check iaxs[fr->callno] after it returns.							 */							iax2_queue_control_data(fr->callno, AST_CONTROL_HOLD, 								S_OR(moh_suggest, NULL),								!ast_strlen_zero(moh_suggest) ? strlen(moh_suggest) + 1 : 0);						}						ast_channel_unlock(iaxs[fr->callno]->owner);					}				}				break;			case IAX_COMMAND_UNQUELCH:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {					iax2_lock_owner(fr->callno);					if (!iaxs[fr->callno]) {						break;					}					/* Generate Manager Unhold event, if necessary */					if (iaxs[fr->callno]->owner && ast_test_flag64(iaxs[fr->callno], IAX_QUELCH)) {						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: Off\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}					ast_clear_flag64(iaxs[fr->callno], IAX_QUELCH);					if (!iaxs[fr->callno]->owner) {						break;					}					if (ast_bridged_channel(iaxs[fr->callno]->owner)) {						/*						 * We already hold the owner lock so we do not						 * need to check iaxs[fr->callno] after it returns.						 */						iax2_queue_control_data(fr->callno, AST_CONTROL_UNHOLD, NULL, 0);					}					ast_channel_unlock(iaxs[fr->callno]->owner);				}				break;			case IAX_COMMAND_TXACC:				if (iaxs[fr->callno]->transferring == TRANSFER_BEGIN) {					/* Ack the packet with the given timestamp */					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* Cancel any outstanding txcnt's */						if (cur->transfer) {							cur->retries = -1;						}					}					memset(&ied1, 0, sizeof(ied1));					iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->callno);					send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREADY, 0, ied1.buf, ied1.pos, -1);					iaxs[fr->callno]->transferring = TRANSFER_READY;				}				break;			case IAX_COMMAND_NEW:				/* Ignore if it's already up */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD))					break;				if (ies.provverpres && ies.serviceident && sin.sin_addr.s_addr) {					ast_mutex_unlock(&iaxsl[fr->callno]);					check_provisioning(&sin, fd, ies.serviceident, ies.provver);					ast_mutex_lock(&iaxsl[fr->callno]);					if (!iaxs[fr->callno]) {						break;					}				}				/* If we're in trunk mode, do it now, and update the trunk number in our frame before continuing */				if (ast_test_flag64(iaxs[fr->callno], IAX_TRUNK)) {					int new_callno;					if ((new_callno = make_trunk(fr->callno, 1)) != -1)						fr->callno = new_callno;				}				/* For security, always ack immediately */				if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				if (check_access(fr->callno, &sin, &ies)) {					/* They're not allowed on */					auth_fail(fr->callno, IAX_COMMAND_REJECT);					if (authdebug)						ast_log(LOG_NOTICE, "Rejected connect attempt from %s, who was trying to reach '%s@%s'\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					break;				}				if (ast_strlen_zero(iaxs[fr->callno]->secret) && ast_test_flag64(iaxs[fr->callno], IAX_FORCE_ENCRYPT)) {					auth_fail(fr->callno, IAX_COMMAND_REJECT);					ast_log(LOG_WARNING, "Rejected connect attempt.  No secret present while force encrypt enabled.\n");					break;				}				if (strcasecmp(iaxs[fr->callno]->exten, "TBD")) {					const char *context, *exten, *cid_num;					context = ast_strdupa(iaxs[fr->callno]->context);					exten = ast_strdupa(iaxs[fr->callno]->exten);					cid_num = ast_strdupa(iaxs[fr->callno]->cid_num);					/* This might re-enter the IAX code and need the lock */					ast_mutex_unlock(&iaxsl[fr->callno]);					exists = ast_exists_extension(NULL, context, exten, 1, cid_num);					ast_mutex_lock(&iaxsl[fr->callno]);					if (!iaxs[fr->callno]) {						break;					}				} else					exists = 0;				/* Get OSP token if it does exist */				save_osptoken(fr, &ies);				if (ast_strlen_zero(iaxs[fr->callno]->secret) && ast_strlen_zero(iaxs[fr->callno]->inkeys)) {					if (strcmp(iaxs[fr->callno]->exten, "TBD") && !exists) {						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}						if (authdebug)							ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					} else {						/* Select an appropriate format */						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								using_prefs = "reqonly";							} else {								using_prefs = "disabled";							}							format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;							memset(&pref, 0, sizeof(pref));							strcpy(caller_pref_buf, "disabled");							strcpy(host_pref_buf, "disabled");						} else {							struct ast_format tmpfmt;							using_prefs = "mine";							/* If the information elements are in here... use them */							if (ies.codec_prefs)								ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);							if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {								/* If we are codec_first_choice we let the caller have the 1st shot at picking the codec.*/								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {									pref = iaxs[fr->callno]->rprefs;									using_prefs = "caller";								} else {									pref = iaxs[fr->callno]->prefs;								}							} else								pref = iaxs[fr->callno]->prefs;							format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);							ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);							ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);						}						if (!format) {							if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP))								format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;							if (!format) {								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}								if (authdebug) {									char tmp[256], tmp2[256], tmp3[256];									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}							} else {								/* Pick one... */								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))										format = 0;								} else {									if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {										using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";										memset(&pref, 0, sizeof(pref));										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);										strcpy(caller_pref_buf,"disabled");										strcpy(host_pref_buf,"disabled");									} else {										struct ast_format tmpfmt;										using_prefs = "mine";										if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {											/* Do the opposite of what we tried above. */											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);										} else /* if no codec_prefs IE do it the old way */											format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}								}								if (!format) {									char tmp[256], tmp2[256], tmp3[256];									memset(&ied0, 0, sizeof(ied0));									iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");									iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);									ast_log(LOG_ERROR, "No best format in '%s'???\n", iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));									send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);									if (!iaxs[fr->callno]) {										break;									}									if (authdebug) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}									ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);									break;								}							}						}						if (format) {							/* No authentication required, let them in */							memset(&ied1, 0, sizeof(ied1));							iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);							iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);							send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);							if (strcmp(iaxs[fr->callno]->exten, "TBD")) {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);								ast_verb(3, "Accepting UNAUTHENTICATED call from %s:\n"												"%srequested format = %s,\n"												"%srequested prefs = %s,\n"												"%sactual format = %s,\n"												"%shost prefs = %s,\n"												"%spriority = %s\n",												ast_inet_ntoa(sin.sin_addr), 												VERBOSE_PREFIX_4,												iax2_getformatname(iaxs[fr->callno]->peerformat), 												VERBOSE_PREFIX_4,												caller_pref_buf,												VERBOSE_PREFIX_4,												iax2_getformatname(format), 												VERBOSE_PREFIX_4,												host_pref_buf, 												VERBOSE_PREFIX_4,												using_prefs);								iaxs[fr->callno]->chosenformat = format;								/* Since this is a new call, we should go ahead and set the callid for it. */								iax_pvt_callid_new(fr->callno);								ast_set_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);							} else {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);								/* If this is a TBD call, we're ready but now what...  */								ast_verb(3, "Accepted unauthenticated TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							}						}					}					break;				}				if (iaxs[fr->callno]->authmethods & IAX_AUTH_MD5)					merge_encryption(iaxs[fr->callno],ies.encmethods);				else					iaxs[fr->callno]->encmethods = 0;				if (!authenticate_request(fr->callno) && iaxs[fr->callno])					ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED);				break;			case IAX_COMMAND_DPREQ:				/* Request status in the dialplan */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD) &&					!ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED) && ies.called_number) {					if (iaxcompat) {						/* Spawn a thread for the lookup */						spawn_dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num);					} else {						/* Just look it up */						dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num, 1);					}				}				break;			case IAX_COMMAND_HANGUP:				ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);				ast_debug(1, "Immediately destroying %d, having received hangup\n", fr->callno);				/* Set hangup cause according to remote and hangupsource */				if (iaxs[fr->callno]->owner) {					set_hangup_source_and_cause(fr->callno, ies.causecode);					if (!iaxs[fr->callno]) {						break;					}				}				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_REJECT:				/* Set hangup cause according to remote and hangup source */				if (iaxs[fr->callno]->owner) {					set_hangup_source_and_cause(fr->callno, ies.causecode);					if (!iaxs[fr->callno]) {						break;					}				}				if (!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)) {					if (iaxs[fr->callno]->owner && authdebug)						ast_log(LOG_WARNING, "Call rejected by %s: %s\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr),							ies.cause ? ies.cause : "<Unknown>");					ast_debug(1, "Immediately destroying %d, having received reject\n",						fr->callno);				}				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK,						       fr->ts, NULL, 0, fr->iseqno);				if (!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION))					iaxs[fr->callno]->error = EPERM;				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_TRANSFER:			{				struct ast_channel *bridged_chan;				struct ast_channel *owner;				iax2_lock_owner(fr->callno);				if (!iaxs[fr->callno]) {					/* Initiating call went away before we could transfer. */					break;				}				owner = iaxs[fr->callno]->owner;				bridged_chan = owner ? ast_bridged_channel(owner) : NULL;				if (bridged_chan && ies.called_number) {					const char *context;					context = ast_strdupa(iaxs[fr->callno]->context);					ast_channel_ref(owner);					ast_channel_ref(bridged_chan);					ast_channel_unlock(owner);					ast_mutex_unlock(&iaxsl[fr->callno]);					/* Set BLINDTRANSFER channel variables */					pbx_builtin_setvar_helper(owner, "BLINDTRANSFER", ast_channel_name(bridged_chan));					pbx_builtin_setvar_helper(bridged_chan, "BLINDTRANSFER", ast_channel_name(owner));					/* DO NOT hold any locks while calling ast_parking_ext_valid() */					if (ast_parking_ext_valid(ies.called_number, owner, context)) {						ast_debug(1, "Parking call '%s'\n", ast_channel_name(bridged_chan));						if (iax_park(bridged_chan, owner, ies.called_number, context)) {							ast_log(LOG_WARNING, "Failed to park call '%s'\n",								ast_channel_name(bridged_chan));						}					} else {						if (ast_async_goto(bridged_chan, context, ies.called_number, 1)) {							ast_log(LOG_WARNING,								"Async goto of '%s' to '%s@%s' failed\n",								ast_channel_name(bridged_chan), ies.called_number, context);						} else {							ast_debug(1, "Async goto of '%s' to '%s@%s' started\n",								ast_channel_name(bridged_chan), ies.called_number, context);						}					}					ast_channel_unref(owner);					ast_channel_unref(bridged_chan);					ast_mutex_lock(&iaxsl[fr->callno]);				} else {					ast_debug(1, "Async goto not applicable on call %d\n", fr->callno);					if (owner) {						ast_channel_unlock(owner);					}				}				break;			}			case IAX_COMMAND_ACCEPT:				/* Ignore if call is already up or needs authentication or is a TBD */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD | IAX_STATE_AUTHENTICATED))					break;				if (ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)) {					/* Send ack immediately, before we destroy */					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					iax2_destroy(fr->callno);					break;				}				if (ies.format) {					iaxs[fr->callno]->peerformat = ies.format;				} else {					if (iaxs[fr->callno]->owner)						iaxs[fr->callno]->peerformat = ast_format_cap_to_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner));					else						iaxs[fr->callno]->peerformat = iaxs[fr->callno]->capability;				}				ast_verb(3, "Call accepted by %s (format %s)\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iax2_getformatname(iaxs[fr->callno]->peerformat));				if (!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)) {					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);					if (!iaxs[fr->callno]) {						break;					}					if (authdebug) {						char tmp1[256], tmp2[256];						ast_log(LOG_NOTICE, "Rejected call to %s, format %s incompatible with our capability %s.\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),							iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));					}				} else {					ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);					iax2_lock_owner(fr->callno);					if (iaxs[fr->callno] && iaxs[fr->callno]->owner) {						char tmp[256];						/* Switch us to use a compatible format */						ast_format_cap_from_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner), iaxs[fr->callno]->peerformat);						ast_verb(3, "Format for call is %s\n", ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(iaxs[fr->callno]->owner)));						/* Setup read/write formats properly. */						if (ast_channel_writeformat(iaxs[fr->callno]->owner)->id)							ast_set_write_format(iaxs[fr->callno]->owner, ast_channel_writeformat(iaxs[fr->callno]->owner));						if (ast_channel_readformat(iaxs[fr->callno]->owner)->id)							ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));						ast_channel_unlock(iaxs[fr->callno]->owner);					}				}				if (iaxs[fr->callno]) {					AST_LIST_LOCK(&dpcache);					AST_LIST_TRAVERSE(&iaxs[fr->callno]->dpentries, dp, peer_list)						if (!(dp->flags & CACHE_FLAG_TRANSMITTED))							iax2_dprequest(dp, fr->callno);					AST_LIST_UNLOCK(&dpcache);				}				break;			case IAX_COMMAND_POKE:				/* Send back a pong packet with the original timestamp */				send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, NULL, 0, -1);				break;			case IAX_COMMAND_PING:			{				struct iax_ie_data pingied;				construct_rr(iaxs[fr->callno], &pingied);				/* Send back a pong packet with the original timestamp */				send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, pingied.buf, pingied.pos, -1);			}				break;			case IAX_COMMAND_PONG:				/* Calculate ping time */				iaxs[fr->callno]->pingtime =  calc_timestamp(iaxs[fr->callno], 0, &f) - fr->ts;				/* save RR info */				save_rr(fr, &ies);				/* Good time to write jb stats for this call */				log_jitterstats(fr->callno);				if (iaxs[fr->callno]->peerpoke) {					peer = iaxs[fr->callno]->peerpoke;					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms)) {						if (iaxs[fr->callno]->pingtime <= peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now REACHABLE! Time: %d\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Reachable\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_NOT_INUSE, "IAX2/%s", peer->name); /* Activate notification */						}					} else if ((peer->historicms > 0) && (peer->historicms <= peer->maxms)) {						if (iaxs[fr->callno]->pingtime > peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now TOO LAGGED (%d ms)!\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Lagged\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_UNAVAILABLE, "IAX2/%s", peer->name); /* Activate notification */						}					}					peer->lastms = iaxs[fr->callno]->pingtime;					if (peer->smoothing && (peer->lastms > -1))						peer->historicms = (iaxs[fr->callno]->pingtime + peer->historicms) / 2;					else if (peer->smoothing && peer->lastms < 0)						peer->historicms = (0 + peer->historicms) / 2;					else											peer->historicms = iaxs[fr->callno]->pingtime;					/* Remove scheduled iax2_poke_noanswer */					if (peer->pokeexpire > -1) {						if (!AST_SCHED_DEL(sched, peer->pokeexpire)) {							peer_unref(peer);							peer->pokeexpire = -1;						}					}					/* Schedule the next cycle */					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms))						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_peer_s, peer_ref(peer));					else						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqok, iax2_poke_peer_s, peer_ref(peer));					if (peer->pokeexpire == -1)						peer_unref(peer);					/* and finally send the ack */					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					/* And wrap up the qualify call */					iax2_destroy(fr->callno);					peer->callno = 0;					ast_debug(1, "Peer %s: got pong, lastms %d, historicms %d, maxms %d\n", peer->name, peer->lastms, peer->historicms, peer->maxms);				}				break;			case IAX_COMMAND_LAGRQ:			case IAX_COMMAND_LAGRP:				f.src = "LAGRQ";				f.mallocd = 0;				f.offset = 0;				f.samples = 0;				iax_frame_wrap(fr, &f);				if (f.subclass.integer == IAX_COMMAND_LAGRQ) {					/* Received a LAGRQ - echo back a LAGRP */					fr->af.subclass.integer = IAX_COMMAND_LAGRP;					iax2_send(iaxs[fr->callno], &fr->af, fr->ts, -1, 0, 0, 0);				} else {					/* Received LAGRP in response to our LAGRQ */					unsigned int ts;					/* This is a reply we've been given, actually measure the difference */					ts = calc_timestamp(iaxs[fr->callno], 0, &fr->af);					iaxs[fr->callno]->lag = ts - fr->ts;					if (iaxdebug)						ast_debug(1, "Peer %s lag measured as %dms\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->lag);				}				break;			case IAX_COMMAND_AUTHREQ:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)) {					ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					break;				}				if (authenticate_reply(iaxs[fr->callno], &iaxs[fr->callno]->addr, &ies, iaxs[fr->callno]->secret, iaxs[fr->callno]->outkey)) {					struct ast_frame hangup_fr = { .frametype = AST_FRAME_CONTROL,								.subclass.integer = AST_CONTROL_HANGUP,					};					ast_log(LOG_WARNING, 						"I don't know how to authenticate %s to %s\n", 						ies.username ? ies.username : "<unknown>", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr));					iax2_queue_frame(fr->callno, &hangup_fr);				}				break;			case IAX_COMMAND_AUTHREP:				/* For security, always ack immediately */				if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				/* Ignore once we've started */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)) {					ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					break;				}				if (authenticate_verify(iaxs[fr->callno], &ies)) {					if (authdebug)						ast_log(LOG_NOTICE, "Host %s failed to authenticate as %s\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->username);					memset(&ied0, 0, sizeof(ied0));					auth_fail(fr->callno, IAX_COMMAND_REJECT);					break;				}				if (strcasecmp(iaxs[fr->callno]->exten, "TBD")) {					/* This might re-enter the IAX code and need the lock */					exists = ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num);				} else					exists = 0;				if (strcmp(iaxs[fr->callno]->exten, "TBD") && !exists) {					if (authdebug)						ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);					if (!iaxs[fr->callno]) {						break;					}				} else {					/* Select an appropriate format */					if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {							using_prefs = "reqonly";						} else {							using_prefs = "disabled";						}						format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;						memset(&pref, 0, sizeof(pref));						strcpy(caller_pref_buf, "disabled");						strcpy(host_pref_buf, "disabled");					} else {						struct ast_format tmpfmt;						using_prefs = "mine";						if (ies.codec_prefs)							ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);						if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {							if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {								pref = iaxs[fr->callno]->rprefs;								using_prefs = "caller";							} else {								pref = iaxs[fr->callno]->prefs;							}						} else /* if no codec_prefs IE do it the old way */							pref = iaxs[fr->callno]->prefs;						format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);						ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);						ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);					}					if (!format) {						char tmp1[256], tmp2[256], tmp3[256];						if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {							ast_debug(1, "We don't do requested format %s, falling back to peer capability '%s'\n",								iax2_getformatname(iaxs[fr->callno]->peerformat),								iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability));							format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;						}						if (!format) {							if (authdebug) {								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n", ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));								} else {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",										ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),										iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));								}							}							memset(&ied0, 0, sizeof(ied0));							iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");							iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);							send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);							if (!iaxs[fr->callno]) {								break;							}						} else {							/* Pick one... */							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))									format = 0;							} else {								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {									using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";									memset(&pref, 0, sizeof(pref));									format = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ?										iaxs[fr->callno]->peerformat : iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									strcpy(caller_pref_buf,"disabled");									strcpy(host_pref_buf,"disabled");								} else {									struct ast_format tmpfmt;									using_prefs = "mine";									if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {										/* Do the opposite of what we tried above. */										if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {											pref = iaxs[fr->callno]->prefs;										} else {											pref = iaxs[fr->callno]->rprefs;											using_prefs = "caller";										}										format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);									} else /* if no codec_prefs IE do it the old way */										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}							}							if (!format) {								char tmp1[256], tmp2[256], tmp3[256];								ast_log(LOG_ERROR, "No best format in %s???\n",									iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));								if (authdebug) {									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}							}						}					}					if (format) {						/* Authentication received */						memset(&ied1, 0, sizeof(ied1));						iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);						iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);						send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);						if (strcmp(iaxs[fr->callno]->exten, "TBD")) {							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							ast_verb(3, "Accepting AUTHENTICATED call from %s:\n"											"%srequested format = %s,\n"											"%srequested prefs = %s,\n"											"%sactual format = %s,\n"											"%shost prefs = %s,\n"											"%spriority = %s\n", 											ast_inet_ntoa(sin.sin_addr), 											VERBOSE_PREFIX_4,											iax2_getformatname(iaxs[fr->callno]->peerformat),											VERBOSE_PREFIX_4,											caller_pref_buf,											VERBOSE_PREFIX_4,											iax2_getformatname(format),											VERBOSE_PREFIX_4,											host_pref_buf,											VERBOSE_PREFIX_4,											using_prefs);							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, format, NULL)))								iax2_destroy(fr->callno);							else if (ies.vars) {								struct ast_datastore *variablestore;								struct ast_variable *var, *prev = NULL;								AST_LIST_HEAD(, ast_var_t) *varlist;								varlist = ast_calloc(1, sizeof(*varlist));								variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);								if (variablestore && varlist) {									variablestore->data = varlist;									variablestore->inheritance = DATASTORE_INHERIT_FOREVER;									AST_LIST_HEAD_INIT(varlist);									ast_debug(1, "I can haz IAX vars? w00t\n");									for (var = ies.vars; var; var = var->next) {										struct ast_var_t *newvar = ast_var_assign(var->name, var->value);										if (prev)											ast_free(prev);										prev = var;										if (!newvar) {											/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */											ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");										} else {											AST_LIST_INSERT_TAIL(varlist, newvar, entries);										}									}									if (prev)										ast_free(prev);									ies.vars = NULL;									ast_channel_datastore_add(c, variablestore);								} else {									ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									if (variablestore)										ast_datastore_free(variablestore);									if (varlist)										ast_free(varlist);								}							}						} else {							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);							/* If this is a TBD call, we're ready but now what...  */							ast_verb(3, "Accepted AUTHENTICATED TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							if (ast_test_flag64(iaxs[fr->callno], IAX_IMMEDIATE)) {								goto immediatedial;							}						}					}				}				break;			case IAX_COMMAND_DIAL:immediatedial:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD)) {					ast_clear_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);					ast_string_field_set(iaxs[fr->callno], exten, ies.called_number ? ies.called_number : "s");					if (!ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num)) {						if (authdebug)							ast_log(LOG_NOTICE, "Rejected dial attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}					} else {						char tmp[256];						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);						ast_verb(3, "Accepting DIAL from %s, formats = %s\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat));						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);						send_command(iaxs[fr->callno], AST_FRAME_CONTROL, AST_CONTROL_PROGRESS, 0, NULL, 0, -1);						if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->peerformat, NULL)))							iax2_destroy(fr->callno);						else if (ies.vars) {							struct ast_datastore *variablestore;							struct ast_variable *var, *prev = NULL;							AST_LIST_HEAD(, ast_var_t) *varlist;							varlist = ast_calloc(1, sizeof(*varlist));							variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);							ast_debug(1, "I can haz IAX vars? w00t\n");							if (variablestore && varlist) {								variablestore->data = varlist;								variablestore->inheritance = DATASTORE_INHERIT_FOREVER;								AST_LIST_HEAD_INIT(varlist);								for (var = ies.vars; var; var = var->next) {									struct ast_var_t *newvar = ast_var_assign(var->name, var->value);									if (prev)										ast_free(prev);									prev = var;									if (!newvar) {										/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */										ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									} else {										AST_LIST_INSERT_TAIL(varlist, newvar, entries);									}								}								if (prev)									ast_free(prev);								ies.vars = NULL;								ast_channel_datastore_add(c, variablestore);							} else {								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");								if (variablestore)									ast_datastore_free(variablestore);								if (varlist)									ast_free(varlist);							}						}					}				}				break;			case IAX_COMMAND_INVAL:				iaxs[fr->callno]->error = ENOTCONN;				ast_debug(1, "Immediately destroying %d, having received INVAL\n", fr->callno);				iax2_destroy(fr->callno);				ast_debug(1, "Destroying call %d\n", fr->callno);				break;			case IAX_COMMAND_VNAK:				ast_debug(1, "Received VNAK: resending outstanding frames\n");				/* Force retransmission */				vnak_retransmit(fr->callno, fr->iseqno);				break;			case IAX_COMMAND_REGREQ:			case IAX_COMMAND_REGREL:				/* For security, always ack immediately */				if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				if (register_verify(fr->callno, &sin, &ies)) {					if (!iaxs[fr->callno]) {						break;					}					/* Send delayed failure */					auth_fail(fr->callno, IAX_COMMAND_REGREJ);					break;				}				if (!iaxs[fr->callno]) {					break;				}				if ((ast_strlen_zero(iaxs[fr->callno]->secret) && ast_strlen_zero(iaxs[fr->callno]->inkeys)) ||						ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED)) {					if (f.subclass.integer == IAX_COMMAND_REGREL) {						memset(&sin, 0, sizeof(sin));						sin.sin_family = AF_INET;					}					if (update_registry(&sin, fr->callno, ies.devicetype, fd, ies.refresh)) {						ast_log(LOG_WARNING, "Registry error\n");					}					if (!iaxs[fr->callno]) {						break;					}					if (ies.provverpres && ies.serviceident && sin.sin_addr.s_addr) {						ast_mutex_unlock(&iaxsl[fr->callno]);						check_provisioning(&sin, fd, ies.serviceident, ies.provver);						ast_mutex_lock(&iaxsl[fr->callno]);					}					break;				}				registry_authrequest(fr->callno);				break;			case IAX_COMMAND_REGACK:				if (iax2_ack_registry(&ies, &sin, fr->callno)) 					ast_log(LOG_WARNING, "Registration failure\n");				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_REGREJ:				if (iaxs[fr->callno]->reg) {					if (authdebug) {						ast_log(LOG_NOTICE, "Registration of '%s' rejected: '%s' from: '%s'\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>", ast_inet_ntoa(sin.sin_addr));						manager_event(EVENT_FLAG_SYSTEM, "Registry", "ChannelType: IAX2\r\nUsername: %s\r\nStatus: Rejected\r\nCause: %s\r\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>");					}					iaxs[fr->callno]->reg->regstate = REG_STATE_REJECTED;				}				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_REGAUTH:				/* Authentication request */				if (registry_rerequest(&ies, fr->callno, &sin)) {					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No authority found");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_FACILITY_NOT_SUBSCRIBED);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);				}				break;			case IAX_COMMAND_TXREJ:				iaxs[fr->callno]->transferring = 0;				ast_verb(3, "Channel '%s' unable to transfer\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");				memset(&iaxs[fr->callno]->transfer, 0, sizeof(iaxs[fr->callno]->transfer));				if (iaxs[fr->callno]->bridgecallno) {					if (iaxs[iaxs[fr->callno]->bridgecallno]->transferring) {						iaxs[iaxs[fr->callno]->bridgecallno]->transferring = 0;						send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREJ, 0, NULL, 0, -1);					}				}				break;			case IAX_COMMAND_TXREADY:				if ((iaxs[fr->callno]->transferring == TRANSFER_BEGIN) ||				    (iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)) {					if (iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)						iaxs[fr->callno]->transferring = TRANSFER_MREADY;					else						iaxs[fr->callno]->transferring = TRANSFER_READY;					ast_verb(3, "Channel '%s' ready to transfer\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					if (iaxs[fr->callno]->bridgecallno) {						if ((iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_READY) ||						    (iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_MREADY)) {							/* They're both ready, now release them. */							if (iaxs[fr->callno]->transferring == TRANSFER_MREADY) {								ast_verb(3, "Attempting media bridge of %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_MEDIA;								iaxs[fr->callno]->transferring = TRANSFER_MEDIA;								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied1.buf, ied1.pos, -1);							} else {								ast_verb(3, "Releasing %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_RELEASED;								iaxs[fr->callno]->transferring = TRANSFER_RELEASED;								ast_set_flag64(iaxs[iaxs[fr->callno]->bridgecallno], IAX_ALREADYGONE);								ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);								/* Stop doing lag & ping requests */								stop_stuff(fr->callno);								stop_stuff(iaxs[fr->callno]->bridgecallno);								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied1.buf, ied1.pos, -1);							}						}					}				}				break;			case IAX_COMMAND_TXREQ:				try_transfer(iaxs[fr->callno], &ies);				break;			case IAX_COMMAND_TXCNT:				if (iaxs[fr->callno]->transferring)					send_command_transfer(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXACC, 0, NULL, 0);				break;			case IAX_COMMAND_TXREL:				/* Send ack immediately, rather than waiting until we've changed addresses */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				complete_transfer(fr->callno, &ies);				stop_stuff(fr->callno);	/* for attended transfer to work with libiax */				break;				case IAX_COMMAND_TXMEDIA:				if (iaxs[fr->callno]->transferring == TRANSFER_READY) {					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* Cancel any outstanding frames and start anew */						if (cur->transfer) {							cur->retries = -1;						}					}					/* Start sending our media to the transfer address, but otherwise leave the call as-is */					iaxs[fr->callno]->transferring = TRANSFER_MEDIAPASS;				}				break;			case IAX_COMMAND_RTKEY:				if (!IAX_CALLENCRYPTED(iaxs[fr->callno])) {					ast_log(LOG_WARNING, 						"we've been told to rotate our encryption key, "						"but this isn't an encrypted call. bad things will happen.\n"					);					break;				}				IAX_DEBUGDIGEST("Receiving", ies.challenge);				ast_aes_set_decrypt_key((unsigned char *) ies.challenge, &iaxs[fr->callno]->dcx);				break;			case IAX_COMMAND_DPREP:				complete_dpreply(iaxs[fr->callno], &ies);				break;			case IAX_COMMAND_UNSUPPORT:				ast_log(LOG_NOTICE, "Peer did not understand our iax command '%d'\n", ies.iax_unknown);				break;			case IAX_COMMAND_FWDOWNL:				/* Firmware download */				if (!ast_test_flag64(&globalflags, IAX_ALLOWFWDOWNLOAD)) {					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_UNSUPPORT, 0, NULL, 0, -1);					break;				}				memset(&ied0, 0, sizeof(ied0));				res = iax_firmware_append(&ied0, (unsigned char *)ies.devicetype, ies.fwdesc);				if (res < 0)					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);				else if (res > 0)					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1);				else					send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1);				break;			case IAX_COMMAND_CALLTOKEN:			{				struct iax_frame *cur;				/* find last sent frame */				if ((cur = AST_LIST_LAST(&frame_queue[fr->callno])) && ies.calltoken && ies.calltokendata) {					resend_with_token(fr->callno, cur, (char *) ies.calltokendata);				}				break;			}			default:				ast_debug(1, "Unknown IAX command %d on %d/%d\n", f.subclass.integer, fr->callno, iaxs[fr->callno]->peercallno);				memset(&ied0, 0, sizeof(ied0));				iax_ie_append_byte(&ied0, IAX_IE_IAX_UNKNOWN, f.subclass.integer);				send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_UNSUPPORT, 0, ied0.buf, ied0.pos, -1);			}			/* Free remote variables (if any) */			if (ies.vars) {				ast_variables_destroy(ies.vars);				ast_debug(1, "I can haz IAX vars, but they is no good :-(\n");				ies.vars = NULL;			}			/* Don't actually pass these frames along */			if ((f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&			  (f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_INVAL) &&			  (f.subclass.integer != IAX_COMMAND_VNAK)) {				if (iaxs[fr->callno] && iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);			}			ast_mutex_unlock(&iaxsl[fr->callno]);			return 1;		}		/* Unless this is an ACK or INVAL frame, ack it */		if (iaxs[fr->callno] && iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno)			send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);	}
static int
socket_process_helper(struct iax2_thread *thread)
socket_process_helper
struct iax2_thread *thread
struct iax2_thread
iax2_thread
*thread
*
thread
{	struct sockaddr_in sin;	int res;	int updatehistory=1;	int new = NEW_PREVENT;	int dcallno = 0;	char decrypted = 0;	struct ast_iax2_full_hdr *fh = (struct ast_iax2_full_hdr *)thread->buf;	struct ast_iax2_mini_hdr *mh = (struct ast_iax2_mini_hdr *)thread->buf;	struct ast_iax2_meta_hdr *meta = (struct ast_iax2_meta_hdr *)thread->buf;	struct ast_iax2_video_hdr *vh = (struct ast_iax2_video_hdr *)thread->buf;	struct iax_frame *fr;	struct iax_frame *cur;	struct ast_frame f = { 0, };	struct ast_channel *c = NULL;	struct iax2_dpcache *dp;	struct iax2_peer *peer;	struct iax_ies ies;	struct iax_ie_data ied0, ied1;	iax2_format format;	int fd;	int exists;	int minivid = 0;	char empty[32]="";		/* Safety measure */	struct iax_frame *duped_fr;	char host_pref_buf[128];	char caller_pref_buf[128];	struct ast_codec_pref pref;	char *using_prefs = "mine";	/* allocate an iax_frame with 4096 bytes of data buffer */	fr = ast_alloca(sizeof(*fr) + 4096);	memset(fr, 0, sizeof(*fr));	fr->afdatalen = 4096; /* From ast_alloca() above */	/* Copy frequently used parameters to the stack */	res = thread->buf_len;	fd = thread->iofd;	memcpy(&sin, &thread->iosin, sizeof(sin));	if (res < sizeof(*mh)) {		ast_log(LOG_WARNING, "midget packet received (%d of %d min)\n", res, (int) sizeof(*mh));		return 1;	}	if ((vh->zeros == 0) && (ntohs(vh->callno) & 0x8000)) {		if (res < sizeof(*vh)) {			ast_log(LOG_WARNING, "Rejecting packet from '%s.%d' that is flagged as a video frame but is too short\n", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));			return 1;		}		/* This is a video frame, get call number */		fr->callno = find_callno(ntohs(vh->callno) & ~0x8000, dcallno, &sin, new, fd, 0);		minivid = 1;	} else if ((meta->zeros == 0) && !(ntohs(meta->metacmd) & 0x8000))		return socket_process_meta(res, meta, &sin, fd, fr);#ifdef DEBUG_SUPPORT	if (res >= sizeof(*fh))		iax_outputframe(NULL, fh, 1, &sin, res - sizeof(*fh));#endif	if (ntohs(mh->callno) & IAX_FLAG_FULL) {		if (res < sizeof(*fh)) {			ast_log(LOG_WARNING, "Rejecting packet from '%s.%d' that is flagged as a full frame but is too short\n", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));			return 1;		}		/* Get the destination call number */		dcallno = ntohs(fh->dcallno) & ~IAX_FLAG_RETRANS;		/* check to make sure this full frame isn't encrypted before we attempt 		 * to look inside of it. If it is encrypted, decrypt it first. Its ok if the		 * callno is not found here, that just means one hasn't been allocated for		 * this connection yet. */		if ((dcallno != 1) && (fr->callno = find_callno(ntohs(mh->callno) & ~IAX_FLAG_FULL, dcallno, &sin, NEW_PREVENT, fd, 1))) {			ast_mutex_lock(&iaxsl[fr->callno]);			if (iaxs[fr->callno] && ast_test_flag64(iaxs[fr->callno], IAX_ENCRYPTED)) {				if (decrypt_frame(fr->callno, fh, &f, &res)) {					ast_log(LOG_NOTICE, "Packet Decrypt Failed!\n");					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}				decrypted = 1;			}			ast_mutex_unlock(&iaxsl[fr->callno]);		}		/* Retrieve the type and subclass */		f.frametype = fh->type;		if (f.frametype == AST_FRAME_VIDEO) {			ast_format_from_old_bitfield(&f.subclass.format, (uncompress_subclass(fh->csub & ~0x40)));			if ((fh->csub >> 6) & 0x1) {				ast_format_set_video_mark(&f.subclass.format);			}		} else if (f.frametype == AST_FRAME_VOICE) {			ast_format_from_old_bitfield(&f.subclass.format, uncompress_subclass(fh->csub));		} else {			f.subclass.integer = uncompress_subclass(fh->csub);		}		/* Deal with POKE/PONG without allocating a callno */		if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_POKE) {			/* Reply back with a PONG, but don't care about the result. */			send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_PONG, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			return 1;		} else if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_ACK && dcallno == 1) {			/* Ignore */			return 1;		}		f.datalen = res - sizeof(*fh);		if (f.datalen) {			if (f.frametype == AST_FRAME_IAX) {				if (iax_parse_ies(&ies, thread->buf + sizeof(struct ast_iax2_full_hdr), f.datalen)) {					ast_log(LOG_WARNING, "Undecodable frame received from '%s'\n", ast_inet_ntoa(sin.sin_addr));					ast_variables_destroy(ies.vars);					return 1;				}				f.data.ptr = NULL;				f.datalen = 0;			} else {				f.data.ptr = thread->buf + sizeof(struct ast_iax2_full_hdr);				memset(&ies, 0, sizeof(ies));			}		} else {			if (f.frametype == AST_FRAME_IAX)				f.data.ptr = NULL;			else				f.data.ptr = empty;			memset(&ies, 0, sizeof(ies));		}		if (!dcallno && iax2_allow_new(f.frametype, f.subclass.integer, 1)) {			/* only set NEW_ALLOW if calltoken checks out */			if (handle_call_token(fh, &ies, &sin, fd)) {				ast_variables_destroy(ies.vars);				return 1;			}			if (ies.calltoken && ies.calltokendata) {				/* if we've gotten this far, and the calltoken ie data exists,				 * then calltoken validation _MUST_ have taken place.  If calltoken				 * data is provided, it is always validated reguardless of any				 * calltokenoptional or requirecalltoken options */				new = NEW_ALLOW_CALLTOKEN_VALIDATED;			} else {				new = NEW_ALLOW;			}		}	} else {		/* Don't know anything about it yet */		f.frametype = AST_FRAME_NULL;		f.subclass.integer = 0;		memset(&ies, 0, sizeof(ies));	}	if (!fr->callno) {		int check_dcallno = 0;		/*		 * We enforce accurate destination call numbers for ACKs.  This forces the other		 * end to know the destination call number before call setup can complete.		 *		 * Discussed in the following thread:		 *    http://lists.digium.com/pipermail/asterisk-dev/2008-May/033217.html 		 */		if ((ntohs(mh->callno) & IAX_FLAG_FULL) && ((f.frametype == AST_FRAME_IAX) && (f.subclass.integer == IAX_COMMAND_ACK))) {			check_dcallno = 1;		}		if (!(fr->callno = find_callno(ntohs(mh->callno) & ~IAX_FLAG_FULL, dcallno, &sin, new, fd, check_dcallno))) {			if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_NEW) {				send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REJECT, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			} else if (f.frametype == AST_FRAME_IAX && (f.subclass.integer == IAX_COMMAND_REGREQ || f.subclass.integer == IAX_COMMAND_REGREL)) {				send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REGREJ, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			}			ast_variables_destroy(ies.vars);			return 1;		}	}	if (fr->callno > 0) {		struct ast_callid *mount_callid;		ast_mutex_lock(&iaxsl[fr->callno]);		if (iaxs[fr->callno] && ((mount_callid = iax_pvt_callid_get(fr->callno)))) {			/* Bind to thread */			ast_callid_threadassoc_add(mount_callid);			ast_callid_unref(mount_callid);		}	}	if (!fr->callno || !iaxs[fr->callno]) {		/* A call arrived for a nonexistent destination.  Unless it's an "inval"		   frame, reply with an inval */		if (ntohs(mh->callno) & IAX_FLAG_FULL) {			/* We can only raw hangup control frames */			if (((f.subclass.integer != IAX_COMMAND_INVAL) &&				 (f.subclass.integer != IAX_COMMAND_TXCNT) &&				 (f.subclass.integer != IAX_COMMAND_TXACC) &&				 (f.subclass.integer != IAX_COMMAND_FWDOWNL))||			    (f.frametype != AST_FRAME_IAX))				raw_hangup(&sin, ntohs(fh->dcallno) & ~IAX_FLAG_RETRANS, ntohs(mh->callno) & ~IAX_FLAG_FULL,				fd);		}		if (fr->callno > 0) 			ast_mutex_unlock(&iaxsl[fr->callno]);		ast_variables_destroy(ies.vars);		return 1;	}	if (ast_test_flag64(iaxs[fr->callno], IAX_ENCRYPTED) && !decrypted) {		if (decrypt_frame(fr->callno, fh, &f, &res)) {			ast_log(LOG_NOTICE, "Packet Decrypt Failed!\n");			ast_variables_destroy(ies.vars);			ast_mutex_unlock(&iaxsl[fr->callno]);			return 1;		}		decrypted = 1;	}#ifdef DEBUG_SUPPORT	if (decrypted) {		iax_outputframe(NULL, fh, 3, &sin, res - sizeof(*fh));	}#endif	if (iaxs[fr->callno]->owner && fh->type == AST_FRAME_IAX &&			(fh->csub == IAX_COMMAND_HANGUP			|| fh->csub == IAX_COMMAND_REJECT			|| fh->csub == IAX_COMMAND_REGREJ			|| fh->csub == IAX_COMMAND_TXREJ)) {		struct ast_control_pvt_cause_code *cause_code;		int data_size = sizeof(*cause_code);		char subclass[40] = "";		/* get subclass text */		iax_frame_subclass2str(fh->csub, subclass, sizeof(subclass));		/* add length of "IAX2 " */		data_size += 5;		/* for IAX hangup frames, add length of () and number */		data_size += 3;		if (ies.causecode > 9) {			data_size++;		}		if (ies.causecode > 99) {			data_size++;		}		/* add length of subclass */		data_size += strlen(subclass);		cause_code = ast_alloca(data_size);		ast_copy_string(cause_code->chan_name, ast_channel_name(iaxs[fr->callno]->owner), AST_CHANNEL_NAME);		cause_code->ast_cause = ies.causecode;		snprintf(cause_code->code, data_size - sizeof(*cause_code) + 1, "IAX2 %s(%d)", subclass, ies.causecode);		iax2_lock_owner(fr->callno);		if (iaxs[fr->callno] && iaxs[fr->callno]->owner) {			ast_queue_control_data(iaxs[fr->callno]->owner, AST_CONTROL_PVT_CAUSE_CODE, cause_code, data_size);			ast_channel_hangupcause_hash_set(iaxs[fr->callno]->owner, cause_code, data_size);			ast_channel_unlock(iaxs[fr->callno]->owner);		}		if (!iaxs[fr->callno]) {			ast_variables_destroy(ies.vars);			ast_mutex_unlock(&iaxsl[fr->callno]);			return 1;		}	}	/* count this frame */	iaxs[fr->callno]->frames_received++;	if (!inaddrcmp(&sin, &iaxs[fr->callno]->addr) && !minivid &&		f.subclass.integer != IAX_COMMAND_TXCNT &&		/* for attended transfer */		f.subclass.integer != IAX_COMMAND_TXACC) {		/* for attended transfer */		unsigned short new_peercallno;		new_peercallno = (unsigned short) (ntohs(mh->callno) & ~IAX_FLAG_FULL);		if (new_peercallno && new_peercallno != iaxs[fr->callno]->peercallno) {			if (iaxs[fr->callno]->peercallno) {				remove_by_peercallno(iaxs[fr->callno]);			}			iaxs[fr->callno]->peercallno = new_peercallno;			store_by_peercallno(iaxs[fr->callno]);		}	}	if (ntohs(mh->callno) & IAX_FLAG_FULL) {		if (iaxdebug)			ast_debug(1, "Received packet %d, (%d, %u)\n", fh->oseqno, f.frametype, f.subclass.integer);		/* Check if it's out of order (and not an ACK or INVAL) */		fr->oseqno = fh->oseqno;		fr->iseqno = fh->iseqno;		fr->ts = ntohl(fh->ts);#ifdef IAXTESTS		if (test_resync) {			ast_debug(1, "Simulating frame ts resync, was %u now %u\n", fr->ts, fr->ts + test_resync);			fr->ts += test_resync;		}#endif /* IAXTESTS */#if 0		if ( (ntohs(fh->dcallno) & IAX_FLAG_RETRANS) ||		     ( (f.frametype != AST_FRAME_VOICE) && ! (f.frametype == AST_FRAME_IAX &&								(f.subclass == IAX_COMMAND_NEW ||								 f.subclass == IAX_COMMAND_AUTHREQ ||								 f.subclass == IAX_COMMAND_ACCEPT ||								 f.subclass == IAX_COMMAND_REJECT))      ) )#endif		if ((ntohs(fh->dcallno) & IAX_FLAG_RETRANS) || (f.frametype != AST_FRAME_VOICE))			updatehistory = 0;		if ((iaxs[fr->callno]->iseqno != fr->oseqno) &&			(iaxs[fr->callno]->iseqno ||				((f.subclass.integer != IAX_COMMAND_TXCNT) &&				(f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXACC)) ||				(f.frametype != AST_FRAME_IAX))) {			if (			 ((f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_INVAL) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&			  (f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_VNAK)) ||			  (f.frametype != AST_FRAME_IAX)) {				/* If it's not an ACK packet, it's out of order. */				ast_debug(1, "Packet arrived out of order (expecting %d, got %d) (frametype = %d, subclass = %d)\n",					iaxs[fr->callno]->iseqno, fr->oseqno, f.frametype, f.subclass.integer);				/* Check to see if we need to request retransmission,				 * and take sequence number wraparound into account */				if ((unsigned char) (iaxs[fr->callno]->iseqno - fr->oseqno) < 128) {					/* If we've already seen it, ack it XXX There's a border condition here XXX */					if ((f.frametype != AST_FRAME_IAX) ||							((f.subclass.integer != IAX_COMMAND_ACK) && (f.subclass.integer != IAX_COMMAND_INVAL))) {						ast_debug(1, "Acking anyway\n");						/* XXX Maybe we should handle its ack to us, but then again, it's probably outdated anyway, and if						   we have anything to send, we'll retransmit and get an ACK back anyway XXX */						send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					}				} else {					/* Send a VNAK requesting retransmission */					iax2_vnak(fr->callno);				}				ast_variables_destroy(ies.vars);				ast_mutex_unlock(&iaxsl[fr->callno]);				return 1;			}		} else {			/* Increment unless it's an ACK or VNAK */			if (((f.subclass.integer != IAX_COMMAND_ACK) &&			    (f.subclass.integer != IAX_COMMAND_INVAL) &&			    (f.subclass.integer != IAX_COMMAND_TXCNT) &&			    (f.subclass.integer != IAX_COMMAND_TXACC) &&				(f.subclass.integer != IAX_COMMAND_VNAK)) ||			    (f.frametype != AST_FRAME_IAX))				iaxs[fr->callno]->iseqno++;		}		/* Ensure text frames are NULL-terminated */		if (f.frametype == AST_FRAME_TEXT && thread->buf[res - 1] != '\0') {			if (res < thread->buf_size)				thread->buf[res++] = '\0';			else /* Trims one character from the text message, but that's better than overwriting the end of the buffer. */				thread->buf[res - 1] = '\0';		}		/* Handle implicit ACKing unless this is an INVAL, and only if this is 		   from the real peer, not the transfer peer */		if (!inaddrcmp(&sin, &iaxs[fr->callno]->addr) &&		    ((f.subclass.integer != IAX_COMMAND_INVAL) ||		     (f.frametype != AST_FRAME_IAX))) {			unsigned char x;			int call_to_destroy;			/* First we have to qualify that the ACKed value is within our window */			if (iaxs[fr->callno]->rseqno >= iaxs[fr->callno]->oseqno || (fr->iseqno >= iaxs[fr->callno]->rseqno && fr->iseqno < iaxs[fr->callno]->oseqno))				x = fr->iseqno;			else				x = iaxs[fr->callno]->oseqno;			if ((x != iaxs[fr->callno]->oseqno) || (iaxs[fr->callno]->oseqno == fr->iseqno)) {				/* The acknowledgement is within our window.  Time to acknowledge everything				   that it says to */				for (x=iaxs[fr->callno]->rseqno; x != fr->iseqno; x++) {					/* Ack the packet with the given timestamp */					if (iaxdebug)						ast_debug(1, "Cancelling transmission of packet %d\n", x);					call_to_destroy = 0;					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* If it's our call, and our timestamp, mark -1 retries */						if (x == cur->oseqno) {							cur->retries = -1;							/* Destroy call if this is the end */							if (cur->final)								call_to_destroy = fr->callno;						}					}					if (call_to_destroy) {						if (iaxdebug)							ast_debug(1, "Really destroying %d, having been acked on final message\n", call_to_destroy);						ast_mutex_lock(&iaxsl[call_to_destroy]);						iax2_destroy(call_to_destroy);						ast_mutex_unlock(&iaxsl[call_to_destroy]);					}				}				/* Note how much we've received acknowledgement for */				if (iaxs[fr->callno])					iaxs[fr->callno]->rseqno = fr->iseqno;				else {					/* Stop processing now */					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}			} else {				ast_debug(1, "Received iseqno %d not within window %d->%d\n", fr->iseqno, iaxs[fr->callno]->rseqno, iaxs[fr->callno]->oseqno);			}		}		if (inaddrcmp(&sin, &iaxs[fr->callno]->addr) &&			((f.frametype != AST_FRAME_IAX) ||			 ((f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT)))) {			/* Only messages we accept from a transfer host are TXACC and TXCNT */			ast_variables_destroy(ies.vars);			ast_mutex_unlock(&iaxsl[fr->callno]);			return 1;		}		/* when we receive the first full frame for a new incoming channel,		   it is safe to start the PBX on the channel because we have now		   completed a 3-way handshake with the peer */		if ((f.frametype == AST_FRAME_VOICE) ||		    (f.frametype == AST_FRAME_VIDEO) ||		    (f.frametype == AST_FRAME_IAX)) {			if (ast_test_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART)) {				ast_clear_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);				if (!ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->chosenformat, NULL)) {					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}			}			if (ies.vars) {				struct ast_datastore *variablestore = NULL;				struct ast_variable *var, *prev = NULL;				AST_LIST_HEAD(, ast_var_t) *varlist;				iax2_lock_owner(fr->callno);				if (!iaxs[fr->callno]) {					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}				if ((c = iaxs[fr->callno]->owner)) {					varlist = ast_calloc(1, sizeof(*varlist));					variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);					if (variablestore && varlist) {						variablestore->data = varlist;						variablestore->inheritance = DATASTORE_INHERIT_FOREVER;						AST_LIST_HEAD_INIT(varlist);						ast_debug(1, "I can haz IAX vars?\n");						for (var = ies.vars; var; var = var->next) {							struct ast_var_t *newvar = ast_var_assign(var->name, var->value);							if (prev) {								ast_free(prev);							}							prev = var;							if (!newvar) {								/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");							} else {								AST_LIST_INSERT_TAIL(varlist, newvar, entries);							}						}						if (prev) {							ast_free(prev);						}						ies.vars = NULL;						ast_channel_datastore_add(c, variablestore);					} else {						ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");						if (variablestore) {							ast_datastore_free(variablestore);						}						if (varlist) {							ast_free(varlist);						}					}					ast_channel_unlock(c);				} else {					/* No channel yet, so transfer the variables directly over to the pvt,					 * for later inheritance. */					ast_debug(1, "No channel, so populating IAXVARs to the pvt, as an intermediate step.\n");					for (var = ies.vars; var && var->next; var = var->next);					if (var) {						var->next = iaxs[fr->callno]->iaxvars;						iaxs[fr->callno]->iaxvars = ies.vars;						ies.vars = NULL;					}				}			}			if (ies.vars) {				ast_debug(1, "I have IAX variables, but they were not processed\n");			}		}		/* once we receive our first IAX Full Frame that is not CallToken related, send all		 * queued signaling frames that were being held. */		if ((f.frametype == AST_FRAME_IAX) && (f.subclass.integer != IAX_COMMAND_CALLTOKEN) && iaxs[fr->callno]->hold_signaling) {			send_signaling(iaxs[fr->callno]);		}		if (f.frametype == AST_FRAME_VOICE) {			if (ast_format_to_old_bitfield(&f.subclass.format) != iaxs[fr->callno]->voiceformat) {					iaxs[fr->callno]->voiceformat = ast_format_to_old_bitfield(&f.subclass.format);					ast_debug(1, "Ooh, voice format changed to '%s'\n", ast_getformatname(&f.subclass.format));					if (iaxs[fr->callno]->owner) {						iax2_lock_owner(fr->callno);						if (iaxs[fr->callno]) {							if (iaxs[fr->callno]->owner) {								struct ast_format_cap *orignative = ast_format_cap_dup(ast_channel_nativeformats(iaxs[fr->callno]->owner));								struct ast_format_cap *native = ast_channel_nativeformats(iaxs[fr->callno]->owner);								if (orignative) {									ast_format_cap_set(native, &f.subclass.format);									if (ast_channel_readformat(iaxs[fr->callno]->owner)->id) {										ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));									}									ast_format_cap_copy(native, orignative);									ast_channel_unlock(iaxs[fr->callno]->owner);									orignative = ast_format_cap_destroy(orignative);								}							}						} else {							ast_debug(1, "Neat, somebody took away the channel at a magical time but i found it!\n");							/* Free remote variables (if any) */							if (ies.vars) {								ast_variables_destroy(ies.vars);								ast_debug(1, "I can haz iaxvars, but they is no good.  :-(\n");								ies.vars = NULL;							}							ast_mutex_unlock(&iaxsl[fr->callno]);							return 1;						}					}			}		}		if (f.frametype == AST_FRAME_VIDEO) {			if (f.subclass.format.id != ast_format_id_from_old_bitfield(iaxs[fr->callno]->videoformat)) {				ast_debug(1, "Ooh, video format changed to %s\n", ast_getformatname(&f.subclass.format));				iaxs[fr->callno]->videoformat = ast_format_to_old_bitfield(&f.subclass.format);			}		}		if (f.frametype == AST_FRAME_CONTROL && iaxs[fr->callno]->owner) {			if (f.subclass.integer == AST_CONTROL_BUSY) {				ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_BUSY);			} else if (f.subclass.integer == AST_CONTROL_CONGESTION) {				ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_CONGESTION);			}		}		if (f.frametype == AST_FRAME_IAX) {			AST_SCHED_DEL(sched, iaxs[fr->callno]->initid);			/* Handle the IAX pseudo frame itself */			if (iaxdebug)				ast_debug(1, "IAX subclass %d received\n", f.subclass.integer);                        /* Update last ts unless the frame's timestamp originated with us. */			if (iaxs[fr->callno]->last < fr->ts &&                            f.subclass.integer != IAX_COMMAND_ACK &&                            f.subclass.integer != IAX_COMMAND_PONG &&                            f.subclass.integer != IAX_COMMAND_LAGRP) {				iaxs[fr->callno]->last = fr->ts;				if (iaxdebug)					ast_debug(1, "For call=%d, set last=%d\n", fr->callno, fr->ts);			}			iaxs[fr->callno]->last_iax_message = f.subclass.integer;			if (!iaxs[fr->callno]->first_iax_message) {				iaxs[fr->callno]->first_iax_message = f.subclass.integer;			}			switch(f.subclass.integer) {			case IAX_COMMAND_ACK:				/* Do nothing */				break;			case IAX_COMMAND_QUELCH:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {				        /* Generate Manager Hold event, if necessary*/					if (iaxs[fr->callno]->owner) {						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: On\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}					ast_set_flag64(iaxs[fr->callno], IAX_QUELCH);					if (ies.musiconhold) {						iax2_lock_owner(fr->callno);						if (!iaxs[fr->callno] || !iaxs[fr->callno]->owner) {							break;						}						if (ast_bridged_channel(iaxs[fr->callno]->owner)) {							const char *moh_suggest = iaxs[fr->callno]->mohsuggest;							/*							 * We already hold the owner lock so we do not							 * need to check iaxs[fr->callno] after it returns.							 */							iax2_queue_control_data(fr->callno, AST_CONTROL_HOLD, 								S_OR(moh_suggest, NULL),								!ast_strlen_zero(moh_suggest) ? strlen(moh_suggest) + 1 : 0);						}						ast_channel_unlock(iaxs[fr->callno]->owner);					}				}				break;			case IAX_COMMAND_UNQUELCH:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {					iax2_lock_owner(fr->callno);					if (!iaxs[fr->callno]) {						break;					}					/* Generate Manager Unhold event, if necessary */					if (iaxs[fr->callno]->owner && ast_test_flag64(iaxs[fr->callno], IAX_QUELCH)) {						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: Off\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}					ast_clear_flag64(iaxs[fr->callno], IAX_QUELCH);					if (!iaxs[fr->callno]->owner) {						break;					}					if (ast_bridged_channel(iaxs[fr->callno]->owner)) {						/*						 * We already hold the owner lock so we do not						 * need to check iaxs[fr->callno] after it returns.						 */						iax2_queue_control_data(fr->callno, AST_CONTROL_UNHOLD, NULL, 0);					}					ast_channel_unlock(iaxs[fr->callno]->owner);				}				break;			case IAX_COMMAND_TXACC:				if (iaxs[fr->callno]->transferring == TRANSFER_BEGIN) {					/* Ack the packet with the given timestamp */					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* Cancel any outstanding txcnt's */						if (cur->transfer) {							cur->retries = -1;						}					}					memset(&ied1, 0, sizeof(ied1));					iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->callno);					send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREADY, 0, ied1.buf, ied1.pos, -1);					iaxs[fr->callno]->transferring = TRANSFER_READY;				}				break;			case IAX_COMMAND_NEW:				/* Ignore if it's already up */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD))					break;				if (ies.provverpres && ies.serviceident && sin.sin_addr.s_addr) {					ast_mutex_unlock(&iaxsl[fr->callno]);					check_provisioning(&sin, fd, ies.serviceident, ies.provver);					ast_mutex_lock(&iaxsl[fr->callno]);					if (!iaxs[fr->callno]) {						break;					}				}				/* If we're in trunk mode, do it now, and update the trunk number in our frame before continuing */				if (ast_test_flag64(iaxs[fr->callno], IAX_TRUNK)) {					int new_callno;					if ((new_callno = make_trunk(fr->callno, 1)) != -1)						fr->callno = new_callno;				}				/* For security, always ack immediately */				if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				if (check_access(fr->callno, &sin, &ies)) {					/* They're not allowed on */					auth_fail(fr->callno, IAX_COMMAND_REJECT);					if (authdebug)						ast_log(LOG_NOTICE, "Rejected connect attempt from %s, who was trying to reach '%s@%s'\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					break;				}				if (ast_strlen_zero(iaxs[fr->callno]->secret) && ast_test_flag64(iaxs[fr->callno], IAX_FORCE_ENCRYPT)) {					auth_fail(fr->callno, IAX_COMMAND_REJECT);					ast_log(LOG_WARNING, "Rejected connect attempt.  No secret present while force encrypt enabled.\n");					break;				}				if (strcasecmp(iaxs[fr->callno]->exten, "TBD")) {					const char *context, *exten, *cid_num;					context = ast_strdupa(iaxs[fr->callno]->context);					exten = ast_strdupa(iaxs[fr->callno]->exten);					cid_num = ast_strdupa(iaxs[fr->callno]->cid_num);					/* This might re-enter the IAX code and need the lock */					ast_mutex_unlock(&iaxsl[fr->callno]);					exists = ast_exists_extension(NULL, context, exten, 1, cid_num);					ast_mutex_lock(&iaxsl[fr->callno]);					if (!iaxs[fr->callno]) {						break;					}				} else					exists = 0;				/* Get OSP token if it does exist */				save_osptoken(fr, &ies);				if (ast_strlen_zero(iaxs[fr->callno]->secret) && ast_strlen_zero(iaxs[fr->callno]->inkeys)) {					if (strcmp(iaxs[fr->callno]->exten, "TBD") && !exists) {						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}						if (authdebug)							ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					} else {						/* Select an appropriate format */						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								using_prefs = "reqonly";							} else {								using_prefs = "disabled";							}							format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;							memset(&pref, 0, sizeof(pref));							strcpy(caller_pref_buf, "disabled");							strcpy(host_pref_buf, "disabled");						} else {							struct ast_format tmpfmt;							using_prefs = "mine";							/* If the information elements are in here... use them */							if (ies.codec_prefs)								ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);							if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {								/* If we are codec_first_choice we let the caller have the 1st shot at picking the codec.*/								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {									pref = iaxs[fr->callno]->rprefs;									using_prefs = "caller";								} else {									pref = iaxs[fr->callno]->prefs;								}							} else								pref = iaxs[fr->callno]->prefs;							format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);							ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);							ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);						}						if (!format) {							if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP))								format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;							if (!format) {								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}								if (authdebug) {									char tmp[256], tmp2[256], tmp3[256];									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}							} else {								/* Pick one... */								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))										format = 0;								} else {									if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {										using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";										memset(&pref, 0, sizeof(pref));										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);										strcpy(caller_pref_buf,"disabled");										strcpy(host_pref_buf,"disabled");									} else {										struct ast_format tmpfmt;										using_prefs = "mine";										if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {											/* Do the opposite of what we tried above. */											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);										} else /* if no codec_prefs IE do it the old way */											format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}								}								if (!format) {									char tmp[256], tmp2[256], tmp3[256];									memset(&ied0, 0, sizeof(ied0));									iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");									iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);									ast_log(LOG_ERROR, "No best format in '%s'???\n", iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));									send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);									if (!iaxs[fr->callno]) {										break;									}									if (authdebug) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}									ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);									break;								}							}						}						if (format) {							/* No authentication required, let them in */							memset(&ied1, 0, sizeof(ied1));							iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);							iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);							send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);							if (strcmp(iaxs[fr->callno]->exten, "TBD")) {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);								ast_verb(3, "Accepting UNAUTHENTICATED call from %s:\n"												"%srequested format = %s,\n"												"%srequested prefs = %s,\n"												"%sactual format = %s,\n"												"%shost prefs = %s,\n"												"%spriority = %s\n",												ast_inet_ntoa(sin.sin_addr), 												VERBOSE_PREFIX_4,												iax2_getformatname(iaxs[fr->callno]->peerformat), 												VERBOSE_PREFIX_4,												caller_pref_buf,												VERBOSE_PREFIX_4,												iax2_getformatname(format), 												VERBOSE_PREFIX_4,												host_pref_buf, 												VERBOSE_PREFIX_4,												using_prefs);								iaxs[fr->callno]->chosenformat = format;								/* Since this is a new call, we should go ahead and set the callid for it. */								iax_pvt_callid_new(fr->callno);								ast_set_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);							} else {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);								/* If this is a TBD call, we're ready but now what...  */								ast_verb(3, "Accepted unauthenticated TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							}						}					}					break;				}				if (iaxs[fr->callno]->authmethods & IAX_AUTH_MD5)					merge_encryption(iaxs[fr->callno],ies.encmethods);				else					iaxs[fr->callno]->encmethods = 0;				if (!authenticate_request(fr->callno) && iaxs[fr->callno])					ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED);				break;			case IAX_COMMAND_DPREQ:				/* Request status in the dialplan */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD) &&					!ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED) && ies.called_number) {					if (iaxcompat) {						/* Spawn a thread for the lookup */						spawn_dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num);					} else {						/* Just look it up */						dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num, 1);					}				}				break;			case IAX_COMMAND_HANGUP:				ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);				ast_debug(1, "Immediately destroying %d, having received hangup\n", fr->callno);				/* Set hangup cause according to remote and hangupsource */				if (iaxs[fr->callno]->owner) {					set_hangup_source_and_cause(fr->callno, ies.causecode);					if (!iaxs[fr->callno]) {						break;					}				}				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_REJECT:				/* Set hangup cause according to remote and hangup source */				if (iaxs[fr->callno]->owner) {					set_hangup_source_and_cause(fr->callno, ies.causecode);					if (!iaxs[fr->callno]) {						break;					}				}				if (!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)) {					if (iaxs[fr->callno]->owner && authdebug)						ast_log(LOG_WARNING, "Call rejected by %s: %s\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr),							ies.cause ? ies.cause : "<Unknown>");					ast_debug(1, "Immediately destroying %d, having received reject\n",						fr->callno);				}				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK,						       fr->ts, NULL, 0, fr->iseqno);				if (!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION))					iaxs[fr->callno]->error = EPERM;				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_TRANSFER:			{				struct ast_channel *bridged_chan;				struct ast_channel *owner;				iax2_lock_owner(fr->callno);				if (!iaxs[fr->callno]) {					/* Initiating call went away before we could transfer. */					break;				}				owner = iaxs[fr->callno]->owner;				bridged_chan = owner ? ast_bridged_channel(owner) : NULL;				if (bridged_chan && ies.called_number) {					const char *context;					context = ast_strdupa(iaxs[fr->callno]->context);					ast_channel_ref(owner);					ast_channel_ref(bridged_chan);					ast_channel_unlock(owner);					ast_mutex_unlock(&iaxsl[fr->callno]);					/* Set BLINDTRANSFER channel variables */					pbx_builtin_setvar_helper(owner, "BLINDTRANSFER", ast_channel_name(bridged_chan));					pbx_builtin_setvar_helper(bridged_chan, "BLINDTRANSFER", ast_channel_name(owner));					/* DO NOT hold any locks while calling ast_parking_ext_valid() */					if (ast_parking_ext_valid(ies.called_number, owner, context)) {						ast_debug(1, "Parking call '%s'\n", ast_channel_name(bridged_chan));						if (iax_park(bridged_chan, owner, ies.called_number, context)) {							ast_log(LOG_WARNING, "Failed to park call '%s'\n",								ast_channel_name(bridged_chan));						}					} else {						if (ast_async_goto(bridged_chan, context, ies.called_number, 1)) {							ast_log(LOG_WARNING,								"Async goto of '%s' to '%s@%s' failed\n",								ast_channel_name(bridged_chan), ies.called_number, context);						} else {							ast_debug(1, "Async goto of '%s' to '%s@%s' started\n",								ast_channel_name(bridged_chan), ies.called_number, context);						}					}					ast_channel_unref(owner);					ast_channel_unref(bridged_chan);					ast_mutex_lock(&iaxsl[fr->callno]);				} else {					ast_debug(1, "Async goto not applicable on call %d\n", fr->callno);					if (owner) {						ast_channel_unlock(owner);					}				}				break;			}			case IAX_COMMAND_ACCEPT:				/* Ignore if call is already up or needs authentication or is a TBD */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD | IAX_STATE_AUTHENTICATED))					break;				if (ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)) {					/* Send ack immediately, before we destroy */					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					iax2_destroy(fr->callno);					break;				}				if (ies.format) {					iaxs[fr->callno]->peerformat = ies.format;				} else {					if (iaxs[fr->callno]->owner)						iaxs[fr->callno]->peerformat = ast_format_cap_to_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner));					else						iaxs[fr->callno]->peerformat = iaxs[fr->callno]->capability;				}				ast_verb(3, "Call accepted by %s (format %s)\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iax2_getformatname(iaxs[fr->callno]->peerformat));				if (!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)) {					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);					if (!iaxs[fr->callno]) {						break;					}					if (authdebug) {						char tmp1[256], tmp2[256];						ast_log(LOG_NOTICE, "Rejected call to %s, format %s incompatible with our capability %s.\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),							iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));					}				} else {					ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);					iax2_lock_owner(fr->callno);					if (iaxs[fr->callno] && iaxs[fr->callno]->owner) {						char tmp[256];						/* Switch us to use a compatible format */						ast_format_cap_from_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner), iaxs[fr->callno]->peerformat);						ast_verb(3, "Format for call is %s\n", ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(iaxs[fr->callno]->owner)));						/* Setup read/write formats properly. */						if (ast_channel_writeformat(iaxs[fr->callno]->owner)->id)							ast_set_write_format(iaxs[fr->callno]->owner, ast_channel_writeformat(iaxs[fr->callno]->owner));						if (ast_channel_readformat(iaxs[fr->callno]->owner)->id)							ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));						ast_channel_unlock(iaxs[fr->callno]->owner);					}				}				if (iaxs[fr->callno]) {					AST_LIST_LOCK(&dpcache);					AST_LIST_TRAVERSE(&iaxs[fr->callno]->dpentries, dp, peer_list)						if (!(dp->flags & CACHE_FLAG_TRANSMITTED))							iax2_dprequest(dp, fr->callno);					AST_LIST_UNLOCK(&dpcache);				}				break;			case IAX_COMMAND_POKE:				/* Send back a pong packet with the original timestamp */				send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, NULL, 0, -1);				break;			case IAX_COMMAND_PING:			{				struct iax_ie_data pingied;				construct_rr(iaxs[fr->callno], &pingied);				/* Send back a pong packet with the original timestamp */				send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, pingied.buf, pingied.pos, -1);			}				break;			case IAX_COMMAND_PONG:				/* Calculate ping time */				iaxs[fr->callno]->pingtime =  calc_timestamp(iaxs[fr->callno], 0, &f) - fr->ts;				/* save RR info */				save_rr(fr, &ies);				/* Good time to write jb stats for this call */				log_jitterstats(fr->callno);				if (iaxs[fr->callno]->peerpoke) {					peer = iaxs[fr->callno]->peerpoke;					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms)) {						if (iaxs[fr->callno]->pingtime <= peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now REACHABLE! Time: %d\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Reachable\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_NOT_INUSE, "IAX2/%s", peer->name); /* Activate notification */						}					} else if ((peer->historicms > 0) && (peer->historicms <= peer->maxms)) {						if (iaxs[fr->callno]->pingtime > peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now TOO LAGGED (%d ms)!\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Lagged\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_UNAVAILABLE, "IAX2/%s", peer->name); /* Activate notification */						}					}					peer->lastms = iaxs[fr->callno]->pingtime;					if (peer->smoothing && (peer->lastms > -1))						peer->historicms = (iaxs[fr->callno]->pingtime + peer->historicms) / 2;					else if (peer->smoothing && peer->lastms < 0)						peer->historicms = (0 + peer->historicms) / 2;					else											peer->historicms = iaxs[fr->callno]->pingtime;					/* Remove scheduled iax2_poke_noanswer */					if (peer->pokeexpire > -1) {						if (!AST_SCHED_DEL(sched, peer->pokeexpire)) {							peer_unref(peer);							peer->pokeexpire = -1;						}					}					/* Schedule the next cycle */					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms))						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_peer_s, peer_ref(peer));					else						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqok, iax2_poke_peer_s, peer_ref(peer));					if (peer->pokeexpire == -1)						peer_unref(peer);					/* and finally send the ack */					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					/* And wrap up the qualify call */					iax2_destroy(fr->callno);					peer->callno = 0;					ast_debug(1, "Peer %s: got pong, lastms %d, historicms %d, maxms %d\n", peer->name, peer->lastms, peer->historicms, peer->maxms);				}				break;			case IAX_COMMAND_LAGRQ:			case IAX_COMMAND_LAGRP:				f.src = "LAGRQ";				f.mallocd = 0;				f.offset = 0;				f.samples = 0;				iax_frame_wrap(fr, &f);				if (f.subclass.integer == IAX_COMMAND_LAGRQ) {					/* Received a LAGRQ - echo back a LAGRP */					fr->af.subclass.integer = IAX_COMMAND_LAGRP;					iax2_send(iaxs[fr->callno], &fr->af, fr->ts, -1, 0, 0, 0);				} else {					/* Received LAGRP in response to our LAGRQ */					unsigned int ts;					/* This is a reply we've been given, actually measure the difference */					ts = calc_timestamp(iaxs[fr->callno], 0, &fr->af);					iaxs[fr->callno]->lag = ts - fr->ts;					if (iaxdebug)						ast_debug(1, "Peer %s lag measured as %dms\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->lag);				}				break;			case IAX_COMMAND_AUTHREQ:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)) {					ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					break;				}				if (authenticate_reply(iaxs[fr->callno], &iaxs[fr->callno]->addr, &ies, iaxs[fr->callno]->secret, iaxs[fr->callno]->outkey)) {					struct ast_frame hangup_fr = { .frametype = AST_FRAME_CONTROL,								.subclass.integer = AST_CONTROL_HANGUP,					};					ast_log(LOG_WARNING, 						"I don't know how to authenticate %s to %s\n", 						ies.username ? ies.username : "<unknown>", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr));					iax2_queue_frame(fr->callno, &hangup_fr);				}				break;			case IAX_COMMAND_AUTHREP:				/* For security, always ack immediately */				if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				/* Ignore once we've started */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)) {					ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					break;				}				if (authenticate_verify(iaxs[fr->callno], &ies)) {					if (authdebug)						ast_log(LOG_NOTICE, "Host %s failed to authenticate as %s\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->username);					memset(&ied0, 0, sizeof(ied0));					auth_fail(fr->callno, IAX_COMMAND_REJECT);					break;				}				if (strcasecmp(iaxs[fr->callno]->exten, "TBD")) {					/* This might re-enter the IAX code and need the lock */					exists = ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num);				} else					exists = 0;				if (strcmp(iaxs[fr->callno]->exten, "TBD") && !exists) {					if (authdebug)						ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);					if (!iaxs[fr->callno]) {						break;					}				} else {					/* Select an appropriate format */					if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {							using_prefs = "reqonly";						} else {							using_prefs = "disabled";						}						format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;						memset(&pref, 0, sizeof(pref));						strcpy(caller_pref_buf, "disabled");						strcpy(host_pref_buf, "disabled");					} else {						struct ast_format tmpfmt;						using_prefs = "mine";						if (ies.codec_prefs)							ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);						if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {							if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {								pref = iaxs[fr->callno]->rprefs;								using_prefs = "caller";							} else {								pref = iaxs[fr->callno]->prefs;							}						} else /* if no codec_prefs IE do it the old way */							pref = iaxs[fr->callno]->prefs;						format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);						ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);						ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);					}					if (!format) {						char tmp1[256], tmp2[256], tmp3[256];						if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {							ast_debug(1, "We don't do requested format %s, falling back to peer capability '%s'\n",								iax2_getformatname(iaxs[fr->callno]->peerformat),								iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability));							format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;						}						if (!format) {							if (authdebug) {								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n", ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));								} else {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",										ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),										iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));								}							}							memset(&ied0, 0, sizeof(ied0));							iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");							iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);							send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);							if (!iaxs[fr->callno]) {								break;							}						} else {							/* Pick one... */							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))									format = 0;							} else {								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {									using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";									memset(&pref, 0, sizeof(pref));									format = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ?										iaxs[fr->callno]->peerformat : iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									strcpy(caller_pref_buf,"disabled");									strcpy(host_pref_buf,"disabled");								} else {									struct ast_format tmpfmt;									using_prefs = "mine";									if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {										/* Do the opposite of what we tried above. */										if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {											pref = iaxs[fr->callno]->prefs;										} else {											pref = iaxs[fr->callno]->rprefs;											using_prefs = "caller";										}										format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);									} else /* if no codec_prefs IE do it the old way */										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}							}							if (!format) {								char tmp1[256], tmp2[256], tmp3[256];								ast_log(LOG_ERROR, "No best format in %s???\n",									iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));								if (authdebug) {									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}							}						}					}					if (format) {						/* Authentication received */						memset(&ied1, 0, sizeof(ied1));						iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);						iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);						send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);						if (strcmp(iaxs[fr->callno]->exten, "TBD")) {							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							ast_verb(3, "Accepting AUTHENTICATED call from %s:\n"											"%srequested format = %s,\n"											"%srequested prefs = %s,\n"											"%sactual format = %s,\n"											"%shost prefs = %s,\n"											"%spriority = %s\n", 											ast_inet_ntoa(sin.sin_addr), 											VERBOSE_PREFIX_4,											iax2_getformatname(iaxs[fr->callno]->peerformat),											VERBOSE_PREFIX_4,											caller_pref_buf,											VERBOSE_PREFIX_4,											iax2_getformatname(format),											VERBOSE_PREFIX_4,											host_pref_buf,											VERBOSE_PREFIX_4,											using_prefs);							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, format, NULL)))								iax2_destroy(fr->callno);							else if (ies.vars) {								struct ast_datastore *variablestore;								struct ast_variable *var, *prev = NULL;								AST_LIST_HEAD(, ast_var_t) *varlist;								varlist = ast_calloc(1, sizeof(*varlist));								variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);								if (variablestore && varlist) {									variablestore->data = varlist;									variablestore->inheritance = DATASTORE_INHERIT_FOREVER;									AST_LIST_HEAD_INIT(varlist);									ast_debug(1, "I can haz IAX vars? w00t\n");									for (var = ies.vars; var; var = var->next) {										struct ast_var_t *newvar = ast_var_assign(var->name, var->value);										if (prev)											ast_free(prev);										prev = var;										if (!newvar) {											/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */											ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");										} else {											AST_LIST_INSERT_TAIL(varlist, newvar, entries);										}									}									if (prev)										ast_free(prev);									ies.vars = NULL;									ast_channel_datastore_add(c, variablestore);								} else {									ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									if (variablestore)										ast_datastore_free(variablestore);									if (varlist)										ast_free(varlist);								}							}						} else {							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);							/* If this is a TBD call, we're ready but now what...  */							ast_verb(3, "Accepted AUTHENTICATED TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							if (ast_test_flag64(iaxs[fr->callno], IAX_IMMEDIATE)) {								goto immediatedial;							}						}					}				}				break;			case IAX_COMMAND_DIAL:immediatedial:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD)) {					ast_clear_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);					ast_string_field_set(iaxs[fr->callno], exten, ies.called_number ? ies.called_number : "s");					if (!ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num)) {						if (authdebug)							ast_log(LOG_NOTICE, "Rejected dial attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}					} else {						char tmp[256];						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);						ast_verb(3, "Accepting DIAL from %s, formats = %s\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat));						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);						send_command(iaxs[fr->callno], AST_FRAME_CONTROL, AST_CONTROL_PROGRESS, 0, NULL, 0, -1);						if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->peerformat, NULL)))							iax2_destroy(fr->callno);						else if (ies.vars) {							struct ast_datastore *variablestore;							struct ast_variable *var, *prev = NULL;							AST_LIST_HEAD(, ast_var_t) *varlist;							varlist = ast_calloc(1, sizeof(*varlist));							variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);							ast_debug(1, "I can haz IAX vars? w00t\n");							if (variablestore && varlist) {								variablestore->data = varlist;								variablestore->inheritance = DATASTORE_INHERIT_FOREVER;								AST_LIST_HEAD_INIT(varlist);								for (var = ies.vars; var; var = var->next) {									struct ast_var_t *newvar = ast_var_assign(var->name, var->value);									if (prev)										ast_free(prev);									prev = var;									if (!newvar) {										/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */										ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									} else {										AST_LIST_INSERT_TAIL(varlist, newvar, entries);									}								}								if (prev)									ast_free(prev);								ies.vars = NULL;								ast_channel_datastore_add(c, variablestore);							} else {								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");								if (variablestore)									ast_datastore_free(variablestore);								if (varlist)									ast_free(varlist);							}						}					}				}				break;			case IAX_COMMAND_INVAL:				iaxs[fr->callno]->error = ENOTCONN;				ast_debug(1, "Immediately destroying %d, having received INVAL\n", fr->callno);				iax2_destroy(fr->callno);				ast_debug(1, "Destroying call %d\n", fr->callno);				break;			case IAX_COMMAND_VNAK:				ast_debug(1, "Received VNAK: resending outstanding frames\n");				/* Force retransmission */				vnak_retransmit(fr->callno, fr->iseqno);				break;			case IAX_COMMAND_REGREQ:			case IAX_COMMAND_REGREL:				/* For security, always ack immediately */				if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				if (register_verify(fr->callno, &sin, &ies)) {					if (!iaxs[fr->callno]) {						break;					}					/* Send delayed failure */					auth_fail(fr->callno, IAX_COMMAND_REGREJ);					break;				}				if (!iaxs[fr->callno]) {					break;				}				if ((ast_strlen_zero(iaxs[fr->callno]->secret) && ast_strlen_zero(iaxs[fr->callno]->inkeys)) ||						ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED)) {					if (f.subclass.integer == IAX_COMMAND_REGREL) {						memset(&sin, 0, sizeof(sin));						sin.sin_family = AF_INET;					}					if (update_registry(&sin, fr->callno, ies.devicetype, fd, ies.refresh)) {						ast_log(LOG_WARNING, "Registry error\n");					}					if (!iaxs[fr->callno]) {						break;					}					if (ies.provverpres && ies.serviceident && sin.sin_addr.s_addr) {						ast_mutex_unlock(&iaxsl[fr->callno]);						check_provisioning(&sin, fd, ies.serviceident, ies.provver);						ast_mutex_lock(&iaxsl[fr->callno]);					}					break;				}				registry_authrequest(fr->callno);				break;			case IAX_COMMAND_REGACK:				if (iax2_ack_registry(&ies, &sin, fr->callno)) 					ast_log(LOG_WARNING, "Registration failure\n");				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_REGREJ:				if (iaxs[fr->callno]->reg) {					if (authdebug) {						ast_log(LOG_NOTICE, "Registration of '%s' rejected: '%s' from: '%s'\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>", ast_inet_ntoa(sin.sin_addr));						manager_event(EVENT_FLAG_SYSTEM, "Registry", "ChannelType: IAX2\r\nUsername: %s\r\nStatus: Rejected\r\nCause: %s\r\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>");					}					iaxs[fr->callno]->reg->regstate = REG_STATE_REJECTED;				}				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_REGAUTH:				/* Authentication request */				if (registry_rerequest(&ies, fr->callno, &sin)) {					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No authority found");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_FACILITY_NOT_SUBSCRIBED);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);				}				break;			case IAX_COMMAND_TXREJ:				iaxs[fr->callno]->transferring = 0;				ast_verb(3, "Channel '%s' unable to transfer\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");				memset(&iaxs[fr->callno]->transfer, 0, sizeof(iaxs[fr->callno]->transfer));				if (iaxs[fr->callno]->bridgecallno) {					if (iaxs[iaxs[fr->callno]->bridgecallno]->transferring) {						iaxs[iaxs[fr->callno]->bridgecallno]->transferring = 0;						send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREJ, 0, NULL, 0, -1);					}				}				break;			case IAX_COMMAND_TXREADY:				if ((iaxs[fr->callno]->transferring == TRANSFER_BEGIN) ||				    (iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)) {					if (iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)						iaxs[fr->callno]->transferring = TRANSFER_MREADY;					else						iaxs[fr->callno]->transferring = TRANSFER_READY;					ast_verb(3, "Channel '%s' ready to transfer\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					if (iaxs[fr->callno]->bridgecallno) {						if ((iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_READY) ||						    (iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_MREADY)) {							/* They're both ready, now release them. */							if (iaxs[fr->callno]->transferring == TRANSFER_MREADY) {								ast_verb(3, "Attempting media bridge of %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_MEDIA;								iaxs[fr->callno]->transferring = TRANSFER_MEDIA;								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied1.buf, ied1.pos, -1);							} else {								ast_verb(3, "Releasing %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_RELEASED;								iaxs[fr->callno]->transferring = TRANSFER_RELEASED;								ast_set_flag64(iaxs[iaxs[fr->callno]->bridgecallno], IAX_ALREADYGONE);								ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);								/* Stop doing lag & ping requests */								stop_stuff(fr->callno);								stop_stuff(iaxs[fr->callno]->bridgecallno);								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied1.buf, ied1.pos, -1);							}						}					}				}				break;			case IAX_COMMAND_TXREQ:				try_transfer(iaxs[fr->callno], &ies);				break;			case IAX_COMMAND_TXCNT:				if (iaxs[fr->callno]->transferring)					send_command_transfer(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXACC, 0, NULL, 0);				break;			case IAX_COMMAND_TXREL:				/* Send ack immediately, rather than waiting until we've changed addresses */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				complete_transfer(fr->callno, &ies);				stop_stuff(fr->callno);	/* for attended transfer to work with libiax */				break;				case IAX_COMMAND_TXMEDIA:				if (iaxs[fr->callno]->transferring == TRANSFER_READY) {					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* Cancel any outstanding frames and start anew */						if (cur->transfer) {							cur->retries = -1;						}					}					/* Start sending our media to the transfer address, but otherwise leave the call as-is */					iaxs[fr->callno]->transferring = TRANSFER_MEDIAPASS;				}				break;			case IAX_COMMAND_RTKEY:				if (!IAX_CALLENCRYPTED(iaxs[fr->callno])) {					ast_log(LOG_WARNING, 						"we've been told to rotate our encryption key, "						"but this isn't an encrypted call. bad things will happen.\n"					);					break;				}				IAX_DEBUGDIGEST("Receiving", ies.challenge);				ast_aes_set_decrypt_key((unsigned char *) ies.challenge, &iaxs[fr->callno]->dcx);				break;			case IAX_COMMAND_DPREP:				complete_dpreply(iaxs[fr->callno], &ies);				break;			case IAX_COMMAND_UNSUPPORT:				ast_log(LOG_NOTICE, "Peer did not understand our iax command '%d'\n", ies.iax_unknown);				break;			case IAX_COMMAND_FWDOWNL:				/* Firmware download */				if (!ast_test_flag64(&globalflags, IAX_ALLOWFWDOWNLOAD)) {					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_UNSUPPORT, 0, NULL, 0, -1);					break;				}				memset(&ied0, 0, sizeof(ied0));				res = iax_firmware_append(&ied0, (unsigned char *)ies.devicetype, ies.fwdesc);				if (res < 0)					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);				else if (res > 0)					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1);				else					send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1);				break;			case IAX_COMMAND_CALLTOKEN:			{				struct iax_frame *cur;				/* find last sent frame */				if ((cur = AST_LIST_LAST(&frame_queue[fr->callno])) && ies.calltoken && ies.calltokendata) {					resend_with_token(fr->callno, cur, (char *) ies.calltokendata);				}				break;			}			default:				ast_debug(1, "Unknown IAX command %d on %d/%d\n", f.subclass.integer, fr->callno, iaxs[fr->callno]->peercallno);				memset(&ied0, 0, sizeof(ied0));				iax_ie_append_byte(&ied0, IAX_IE_IAX_UNKNOWN, f.subclass.integer);				send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_UNSUPPORT, 0, ied0.buf, ied0.pos, -1);			}			/* Free remote variables (if any) */			if (ies.vars) {				ast_variables_destroy(ies.vars);				ast_debug(1, "I can haz IAX vars, but they is no good :-(\n");				ies.vars = NULL;			}			/* Don't actually pass these frames along */			if ((f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&			  (f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_INVAL) &&			  (f.subclass.integer != IAX_COMMAND_VNAK)) {				if (iaxs[fr->callno] && iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);			}			ast_mutex_unlock(&iaxsl[fr->callno]);			return 1;		}		/* Unless this is an ACK or INVAL frame, ack it */		if (iaxs[fr->callno] && iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno)			send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);	}
struct sockaddr_in sin;
struct sockaddr_in sin;
struct sockaddr_in
sockaddr_in
sin
sin
int res;
int res;
int
res
res
int updatehistory=1;
int updatehistory=1;
int
updatehistory=1
updatehistory
=1
1
int new = NEW_PREVENT;
int dcallno = 0;
int dcallno = 0;
int
dcallno = 0
dcallno
= 0
0
char decrypted = 0;
char decrypted = 0;
char
decrypted = 0
decrypted
= 0
0
struct ast_iax2_full_hdr *fh = (struct ast_iax2_full_hdr *)thread->buf;
struct ast_iax2_full_hdr *fh = (struct ast_iax2_full_hdr *)thread->buf;
struct ast_iax2_full_hdr
ast_iax2_full_hdr
*fh = (struct ast_iax2_full_hdr *)thread->buf
*
fh
= (struct ast_iax2_full_hdr *)thread->buf
(struct ast_iax2_full_hdr *)thread->buf
struct ast_iax2_full_hdr *
struct ast_iax2_full_hdr
ast_iax2_full_hdr
*
*
thread->buf
thread
thread
buf
struct ast_iax2_mini_hdr *mh = (struct ast_iax2_mini_hdr *)thread->buf;
struct ast_iax2_mini_hdr *mh = (struct ast_iax2_mini_hdr *)thread->buf;
struct ast_iax2_mini_hdr
ast_iax2_mini_hdr
*mh = (struct ast_iax2_mini_hdr *)thread->buf
*
mh
= (struct ast_iax2_mini_hdr *)thread->buf
(struct ast_iax2_mini_hdr *)thread->buf
struct ast_iax2_mini_hdr *
struct ast_iax2_mini_hdr
ast_iax2_mini_hdr
*
*
thread->buf
thread
thread
buf
struct ast_iax2_meta_hdr *meta = (struct ast_iax2_meta_hdr *)thread->buf;
struct ast_iax2_meta_hdr *meta = (struct ast_iax2_meta_hdr *)thread->buf;
struct ast_iax2_meta_hdr
ast_iax2_meta_hdr
*meta = (struct ast_iax2_meta_hdr *)thread->buf
*
meta
= (struct ast_iax2_meta_hdr *)thread->buf
(struct ast_iax2_meta_hdr *)thread->buf
struct ast_iax2_meta_hdr *
struct ast_iax2_meta_hdr
ast_iax2_meta_hdr
*
*
thread->buf
thread
thread
buf
struct ast_iax2_video_hdr *vh = (struct ast_iax2_video_hdr *)thread->buf;
struct ast_iax2_video_hdr *vh = (struct ast_iax2_video_hdr *)thread->buf;
struct ast_iax2_video_hdr
ast_iax2_video_hdr
*vh = (struct ast_iax2_video_hdr *)thread->buf
*
vh
= (struct ast_iax2_video_hdr *)thread->buf
(struct ast_iax2_video_hdr *)thread->buf
struct ast_iax2_video_hdr *
struct ast_iax2_video_hdr
ast_iax2_video_hdr
*
*
thread->buf
thread
thread
buf
struct iax_frame *fr;
struct iax_frame *fr;
struct iax_frame
iax_frame
*fr
*
fr
struct iax_frame *cur;
struct iax_frame *cur;
struct iax_frame
iax_frame
*cur
*
cur
struct ast_frame f = { 0, };
struct ast_frame f = { 0, };
struct ast_frame
ast_frame
f = { 0, }
f
= { 0, }
{ 0, }
0
struct ast_channel *c = NULL;
struct ast_channel *c = NULL;
struct ast_channel
ast_channel
*c = NULL
*
c
= NULL
NULL
NULL
struct iax2_dpcache *dp;
struct iax2_dpcache *dp;
struct iax2_dpcache
iax2_dpcache
*dp
*
dp
struct iax2_peer *peer;
struct iax2_peer *peer;
struct iax2_peer
iax2_peer
*peer
*
peer
struct iax_ies ies;
struct iax_ies ies;
struct iax_ies
iax_ies
ies
ies
struct iax_ie_data ied0, ied1;
struct iax_ie_data ied0, ied1;
struct iax_ie_data
iax_ie_data
ied0
ied0
ied1
ied1
iax2_format format;
iax2_format format;
iax2_format
iax2_format
format
format
int fd;
int fd;
int
fd
fd
int exists;
int exists;
int
exists
exists
int minivid = 0;
int minivid = 0;
int
minivid = 0
minivid
= 0
0
char empty[32]="";
char empty[32]="";
char
empty[32]=""
empty
[32]
32
=""
""
struct iax_frame *duped_fr;
struct iax_frame *duped_fr;
struct iax_frame
iax_frame
*duped_fr
*
duped_fr
char host_pref_buf[128];
char host_pref_buf[128];
char
host_pref_buf[128]
host_pref_buf
[128]
128
char caller_pref_buf[128];
char caller_pref_buf[128];
char
caller_pref_buf[128]
caller_pref_buf
[128]
128
struct ast_codec_pref pref;
struct ast_codec_pref pref;
struct ast_codec_pref
ast_codec_pref
pref
pref
char *using_prefs = "mine";
char *using_prefs = "mine";
char
*using_prefs = "mine"
*
using_prefs
= "mine"
"mine"
fr = ast_alloca(sizeof(*fr) + 4096);
fr = ast_alloca(sizeof(*fr) + 4096)
fr
fr
ast_alloca(sizeof(*fr) + 4096)
ast_alloca
ast_alloca
sizeof(*fr) + 4096
sizeof(*fr)
(*fr)
*fr
fr
fr
4096
memset(fr, 0, sizeof(*fr));
memset(fr, 0, sizeof(*fr))
memset
memset
fr
fr
0
sizeof(*fr)
(*fr)
*fr
fr
fr
fr->afdatalen = 4096;
fr->afdatalen = 4096
fr->afdatalen
fr
fr
afdatalen
4096
res = thread->buf_len;
res = thread->buf_len
res
res
thread->buf_len
thread
thread
buf_len
fd = thread->iofd;
fd = thread->iofd
fd
fd
thread->iofd
thread
thread
iofd
memcpy(&sin, &thread->iosin, sizeof(sin));
memcpy(&sin, &thread->iosin, sizeof(sin))
memcpy
memcpy
&sin
sin
sin
&thread->iosin
thread->iosin
thread
thread
iosin
sizeof(sin)
(sin)
sin
sin
if (res < sizeof(*mh)) {		ast_log(LOG_WARNING, "midget packet received (%d of %d min)\n", res, (int) sizeof(*mh));		return 1;	}
res < sizeof(*mh)
res
res
sizeof(*mh)
(*mh)
*mh
mh
mh
{		ast_log(LOG_WARNING, "midget packet received (%d of %d min)\n", res, (int) sizeof(*mh));		return 1;	}
ast_log(LOG_WARNING, "midget packet received (%d of %d min)\n", res, (int) sizeof(*mh));
ast_log(LOG_WARNING, "midget packet received (%d of %d min)\n", res, (int) sizeof(*mh))
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"midget packet received (%d of %d min)\n"
res
res
(int) sizeof(*mh)
int
int

sizeof(*mh)
(*mh)
*mh
mh
mh
return 1;
1
if ((vh->zeros == 0) && (ntohs(vh->callno) & 0x8000)) {		if (res < sizeof(*vh)) {			ast_log(LOG_WARNING, "Rejecting packet from '%s.%d' that is flagged as a video frame but is too short\n", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));			return 1;		}		/* This is a video frame, get call number */		fr->callno = find_callno(ntohs(vh->callno) & ~0x8000, dcallno, &sin, new, fd, 0);		minivid = 1;	} else if ((meta->zeros == 0) && !(ntohs(meta->metacmd) & 0x8000))		return socket_process_meta(res, meta, &sin, fd, fr);
(vh->zeros == 0) && (ntohs(vh->callno) & 0x8000)
(vh->zeros == 0)
vh->zeros == 0
vh->zeros
vh
vh
zeros
0
(ntohs(vh->callno) & 0x8000)
ntohs(vh->callno) & 0x8000
ntohs(vh->callno)
ntohs
ntohs
vh->callno
vh
vh
callno
0x8000
{		if (res < sizeof(*vh)) {			ast_log(LOG_WARNING, "Rejecting packet from '%s.%d' that is flagged as a video frame but is too short\n", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));			return 1;		}		/* This is a video frame, get call number */		fr->callno = find_callno(ntohs(vh->callno) & ~0x8000, dcallno, &sin, new, fd, 0);		minivid = 1;	}
if (res < sizeof(*vh)) {			ast_log(LOG_WARNING, "Rejecting packet from '%s.%d' that is flagged as a video frame but is too short\n", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));			return 1;		}
res < sizeof(*vh)
res
res
sizeof(*vh)
(*vh)
*vh
vh
vh
{			ast_log(LOG_WARNING, "Rejecting packet from '%s.%d' that is flagged as a video frame but is too short\n", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));			return 1;		}
ast_log(LOG_WARNING, "Rejecting packet from '%s.%d' that is flagged as a video frame but is too short\n", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));
ast_log(LOG_WARNING, "Rejecting packet from '%s.%d' that is flagged as a video frame but is too short\n", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port))
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"Rejecting packet from '%s.%d' that is flagged as a video frame but is too short\n"
ast_inet_ntoa(sin.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
sin.sin_addr
sin
sin
sin_addr
ntohs(sin.sin_port)
ntohs
ntohs
sin.sin_port
sin
sin
sin_port
return 1;
1
fr->callno = find_callno(ntohs(vh->callno) & ~0x8000, dcallno, &sin, new, fd, 0);
minivid = 1;
minivid = 1
minivid
minivid
1
if ((meta->zeros == 0) && !(ntohs(meta->metacmd) & 0x8000))		return socket_process_meta(res, meta, &sin, fd, fr);
(meta->zeros == 0) && !(ntohs(meta->metacmd) & 0x8000)
(meta->zeros == 0)
meta->zeros == 0
meta->zeros
meta
meta
zeros
0
!(ntohs(meta->metacmd) & 0x8000)
(ntohs(meta->metacmd) & 0x8000)
ntohs(meta->metacmd) & 0x8000
ntohs(meta->metacmd)
ntohs
ntohs
meta->metacmd
meta
meta
metacmd
0x8000
return socket_process_meta(res, meta, &sin, fd, fr);
socket_process_meta(res, meta, &sin, fd, fr)
socket_process_meta
socket_process_meta
res
res
meta
meta
&sin
sin
sin
fd
fd
fr
fr
if (ntohs(mh->callno) & IAX_FLAG_FULL) {		if (res < sizeof(*fh)) {			ast_log(LOG_WARNING, "Rejecting packet from '%s.%d' that is flagged as a full frame but is too short\n", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));			return 1;		}		/* Get the destination call number */		dcallno = ntohs(fh->dcallno) & ~IAX_FLAG_RETRANS;		/* check to make sure this full frame isn't encrypted before we attempt 		 * to look inside of it. If it is encrypted, decrypt it first. Its ok if the		 * callno is not found here, that just means one hasn't been allocated for		 * this connection yet. */		if ((dcallno != 1) && (fr->callno = find_callno(ntohs(mh->callno) & ~IAX_FLAG_FULL, dcallno, &sin, NEW_PREVENT, fd, 1))) {			ast_mutex_lock(&iaxsl[fr->callno]);			if (iaxs[fr->callno] && ast_test_flag64(iaxs[fr->callno], IAX_ENCRYPTED)) {				if (decrypt_frame(fr->callno, fh, &f, &res)) {					ast_log(LOG_NOTICE, "Packet Decrypt Failed!\n");					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}				decrypted = 1;			}			ast_mutex_unlock(&iaxsl[fr->callno]);		}		/* Retrieve the type and subclass */		f.frametype = fh->type;		if (f.frametype == AST_FRAME_VIDEO) {			ast_format_from_old_bitfield(&f.subclass.format, (uncompress_subclass(fh->csub & ~0x40)));			if ((fh->csub >> 6) & 0x1) {				ast_format_set_video_mark(&f.subclass.format);			}		} else if (f.frametype == AST_FRAME_VOICE) {			ast_format_from_old_bitfield(&f.subclass.format, uncompress_subclass(fh->csub));		} else {			f.subclass.integer = uncompress_subclass(fh->csub);		}		/* Deal with POKE/PONG without allocating a callno */		if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_POKE) {			/* Reply back with a PONG, but don't care about the result. */			send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_PONG, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			return 1;		} else if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_ACK && dcallno == 1) {			/* Ignore */			return 1;		}		f.datalen = res - sizeof(*fh);		if (f.datalen) {			if (f.frametype == AST_FRAME_IAX) {				if (iax_parse_ies(&ies, thread->buf + sizeof(struct ast_iax2_full_hdr), f.datalen)) {					ast_log(LOG_WARNING, "Undecodable frame received from '%s'\n", ast_inet_ntoa(sin.sin_addr));					ast_variables_destroy(ies.vars);					return 1;				}				f.data.ptr = NULL;				f.datalen = 0;			} else {				f.data.ptr = thread->buf + sizeof(struct ast_iax2_full_hdr);				memset(&ies, 0, sizeof(ies));			}		} else {			if (f.frametype == AST_FRAME_IAX)				f.data.ptr = NULL;			else				f.data.ptr = empty;			memset(&ies, 0, sizeof(ies));		}		if (!dcallno && iax2_allow_new(f.frametype, f.subclass.integer, 1)) {			/* only set NEW_ALLOW if calltoken checks out */			if (handle_call_token(fh, &ies, &sin, fd)) {				ast_variables_destroy(ies.vars);				return 1;			}			if (ies.calltoken && ies.calltokendata) {				/* if we've gotten this far, and the calltoken ie data exists,				 * then calltoken validation _MUST_ have taken place.  If calltoken				 * data is provided, it is always validated reguardless of any				 * calltokenoptional or requirecalltoken options */				new = NEW_ALLOW_CALLTOKEN_VALIDATED;			} else {				new = NEW_ALLOW;			}		}	} else {		/* Don't know anything about it yet */		f.frametype = AST_FRAME_NULL;		f.subclass.integer = 0;		memset(&ies, 0, sizeof(ies));	}
ntohs(mh->callno) & IAX_FLAG_FULL
ntohs(mh->callno)
ntohs
ntohs
mh->callno
mh
mh
callno
IAX_FLAG_FULL
IAX_FLAG_FULL
{		if (res < sizeof(*fh)) {			ast_log(LOG_WARNING, "Rejecting packet from '%s.%d' that is flagged as a full frame but is too short\n", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));			return 1;		}		/* Get the destination call number */		dcallno = ntohs(fh->dcallno) & ~IAX_FLAG_RETRANS;		/* check to make sure this full frame isn't encrypted before we attempt 		 * to look inside of it. If it is encrypted, decrypt it first. Its ok if the		 * callno is not found here, that just means one hasn't been allocated for		 * this connection yet. */		if ((dcallno != 1) && (fr->callno = find_callno(ntohs(mh->callno) & ~IAX_FLAG_FULL, dcallno, &sin, NEW_PREVENT, fd, 1))) {			ast_mutex_lock(&iaxsl[fr->callno]);			if (iaxs[fr->callno] && ast_test_flag64(iaxs[fr->callno], IAX_ENCRYPTED)) {				if (decrypt_frame(fr->callno, fh, &f, &res)) {					ast_log(LOG_NOTICE, "Packet Decrypt Failed!\n");					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}				decrypted = 1;			}			ast_mutex_unlock(&iaxsl[fr->callno]);		}		/* Retrieve the type and subclass */		f.frametype = fh->type;		if (f.frametype == AST_FRAME_VIDEO) {			ast_format_from_old_bitfield(&f.subclass.format, (uncompress_subclass(fh->csub & ~0x40)));			if ((fh->csub >> 6) & 0x1) {				ast_format_set_video_mark(&f.subclass.format);			}		} else if (f.frametype == AST_FRAME_VOICE) {			ast_format_from_old_bitfield(&f.subclass.format, uncompress_subclass(fh->csub));		} else {			f.subclass.integer = uncompress_subclass(fh->csub);		}		/* Deal with POKE/PONG without allocating a callno */		if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_POKE) {			/* Reply back with a PONG, but don't care about the result. */			send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_PONG, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			return 1;		} else if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_ACK && dcallno == 1) {			/* Ignore */			return 1;		}		f.datalen = res - sizeof(*fh);		if (f.datalen) {			if (f.frametype == AST_FRAME_IAX) {				if (iax_parse_ies(&ies, thread->buf + sizeof(struct ast_iax2_full_hdr), f.datalen)) {					ast_log(LOG_WARNING, "Undecodable frame received from '%s'\n", ast_inet_ntoa(sin.sin_addr));					ast_variables_destroy(ies.vars);					return 1;				}				f.data.ptr = NULL;				f.datalen = 0;			} else {				f.data.ptr = thread->buf + sizeof(struct ast_iax2_full_hdr);				memset(&ies, 0, sizeof(ies));			}		} else {			if (f.frametype == AST_FRAME_IAX)				f.data.ptr = NULL;			else				f.data.ptr = empty;			memset(&ies, 0, sizeof(ies));		}		if (!dcallno && iax2_allow_new(f.frametype, f.subclass.integer, 1)) {			/* only set NEW_ALLOW if calltoken checks out */			if (handle_call_token(fh, &ies, &sin, fd)) {				ast_variables_destroy(ies.vars);				return 1;			}			if (ies.calltoken && ies.calltokendata) {				/* if we've gotten this far, and the calltoken ie data exists,				 * then calltoken validation _MUST_ have taken place.  If calltoken				 * data is provided, it is always validated reguardless of any				 * calltokenoptional or requirecalltoken options */				new = NEW_ALLOW_CALLTOKEN_VALIDATED;			} else {				new = NEW_ALLOW;			}		}	}
if (res < sizeof(*fh)) {			ast_log(LOG_WARNING, "Rejecting packet from '%s.%d' that is flagged as a full frame but is too short\n", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));			return 1;		}
res < sizeof(*fh)
res
res
sizeof(*fh)
(*fh)
*fh
fh
fh
{			ast_log(LOG_WARNING, "Rejecting packet from '%s.%d' that is flagged as a full frame but is too short\n", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));			return 1;		}
ast_log(LOG_WARNING, "Rejecting packet from '%s.%d' that is flagged as a full frame but is too short\n", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));
ast_log(LOG_WARNING, "Rejecting packet from '%s.%d' that is flagged as a full frame but is too short\n", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port))
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"Rejecting packet from '%s.%d' that is flagged as a full frame but is too short\n"
ast_inet_ntoa(sin.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
sin.sin_addr
sin
sin
sin_addr
ntohs(sin.sin_port)
ntohs
ntohs
sin.sin_port
sin
sin
sin_port
return 1;
1
dcallno = ntohs(fh->dcallno) & ~IAX_FLAG_RETRANS;
dcallno = ntohs(fh->dcallno) & ~IAX_FLAG_RETRANS
dcallno
dcallno
ntohs(fh->dcallno) & ~IAX_FLAG_RETRANS
ntohs(fh->dcallno)
ntohs
ntohs
fh->dcallno
fh
fh
dcallno
~IAX_FLAG_RETRANS
IAX_FLAG_RETRANS
IAX_FLAG_RETRANS
if ((dcallno != 1) && (fr->callno = find_callno(ntohs(mh->callno) & ~IAX_FLAG_FULL, dcallno, &sin, NEW_PREVENT, fd, 1))) {			ast_mutex_lock(&iaxsl[fr->callno]);			if (iaxs[fr->callno] && ast_test_flag64(iaxs[fr->callno], IAX_ENCRYPTED)) {				if (decrypt_frame(fr->callno, fh, &f, &res)) {					ast_log(LOG_NOTICE, "Packet Decrypt Failed!\n");					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}				decrypted = 1;			}			ast_mutex_unlock(&iaxsl[fr->callno]);		}
(dcallno != 1) && (fr->callno = find_callno(ntohs(mh->callno) & ~IAX_FLAG_FULL, dcallno, &sin, NEW_PREVENT, fd, 1))
(dcallno != 1)
dcallno != 1
dcallno
dcallno
1
(fr->callno = find_callno(ntohs(mh->callno) & ~IAX_FLAG_FULL, dcallno, &sin, NEW_PREVENT, fd, 1))
fr->callno = find_callno(ntohs(mh->callno) & ~IAX_FLAG_FULL, dcallno, &sin, NEW_PREVENT, fd, 1)
fr->callno
fr
fr
callno
find_callno(ntohs(mh->callno) & ~IAX_FLAG_FULL, dcallno, &sin, NEW_PREVENT, fd, 1)
find_callno
find_callno
ntohs(mh->callno) & ~IAX_FLAG_FULL
ntohs(mh->callno)
ntohs
ntohs
mh->callno
mh
mh
callno
~IAX_FLAG_FULL
IAX_FLAG_FULL
IAX_FLAG_FULL
dcallno
dcallno
&sin
sin
sin
NEW_PREVENT
NEW_PREVENT
fd
fd
1
{			ast_mutex_lock(&iaxsl[fr->callno]);			if (iaxs[fr->callno] && ast_test_flag64(iaxs[fr->callno], IAX_ENCRYPTED)) {				if (decrypt_frame(fr->callno, fh, &f, &res)) {					ast_log(LOG_NOTICE, "Packet Decrypt Failed!\n");					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}				decrypted = 1;			}			ast_mutex_unlock(&iaxsl[fr->callno]);		}
ast_mutex_lock(&iaxsl[fr->callno]);
ast_mutex_lock(&iaxsl[fr->callno]);
ast_mutex_lock
ast_mutex_lock
(&iaxsl[fr->callno])
&iaxsl[fr->callno]
&
iaxsl
[fr->callno]
fr->callno
fr
fr
callno
if (iaxs[fr->callno] && ast_test_flag64(iaxs[fr->callno], IAX_ENCRYPTED)) {				if (decrypt_frame(fr->callno, fh, &f, &res)) {					ast_log(LOG_NOTICE, "Packet Decrypt Failed!\n");					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}				decrypted = 1;			}
iaxs[fr->callno] && ast_test_flag64(iaxs[fr->callno], IAX_ENCRYPTED)
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
ast_test_flag64(iaxs[fr->callno], IAX_ENCRYPTED)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_ENCRYPTED
IAX_ENCRYPTED
{				if (decrypt_frame(fr->callno, fh, &f, &res)) {					ast_log(LOG_NOTICE, "Packet Decrypt Failed!\n");					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}				decrypted = 1;			}
if (decrypt_frame(fr->callno, fh, &f, &res)) {					ast_log(LOG_NOTICE, "Packet Decrypt Failed!\n");					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}
decrypt_frame(fr->callno, fh, &f, &res)
decrypt_frame
decrypt_frame
fr->callno
fr
fr
callno
fh
fh
&f
f
f
&res
res
res
{					ast_log(LOG_NOTICE, "Packet Decrypt Failed!\n");					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}
ast_log(LOG_NOTICE, "Packet Decrypt Failed!\n");
ast_log(LOG_NOTICE, "Packet Decrypt Failed!\n")
ast_log
ast_log
LOG_NOTICE
LOG_NOTICE
"Packet Decrypt Failed!\n"
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock(&iaxsl[fr->callno])
ast_mutex_unlock
ast_mutex_unlock
&iaxsl[fr->callno]
iaxsl[fr->callno]
iaxsl
iaxsl
fr->callno
fr
fr
callno
return 1;
1
decrypted = 1;
decrypted = 1
decrypted
decrypted
1
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock(&iaxsl[fr->callno])
ast_mutex_unlock
ast_mutex_unlock
&iaxsl[fr->callno]
iaxsl[fr->callno]
iaxsl
iaxsl
fr->callno
fr
fr
callno
f.frametype = fh->type;
f.frametype = fh->type
f.frametype
f
f
frametype
fh->type
fh
fh
type
if (f.frametype == AST_FRAME_VIDEO) {			ast_format_from_old_bitfield(&f.subclass.format, (uncompress_subclass(fh->csub & ~0x40)));			if ((fh->csub >> 6) & 0x1) {				ast_format_set_video_mark(&f.subclass.format);			}		} else if (f.frametype == AST_FRAME_VOICE) {			ast_format_from_old_bitfield(&f.subclass.format, uncompress_subclass(fh->csub));		} else {			f.subclass.integer = uncompress_subclass(fh->csub);		}
f.frametype == AST_FRAME_VIDEO
f.frametype
f
f
frametype
AST_FRAME_VIDEO
AST_FRAME_VIDEO
{			ast_format_from_old_bitfield(&f.subclass.format, (uncompress_subclass(fh->csub & ~0x40)));			if ((fh->csub >> 6) & 0x1) {				ast_format_set_video_mark(&f.subclass.format);			}		}
ast_format_from_old_bitfield(&f.subclass.format, (uncompress_subclass(fh->csub & ~0x40)));
ast_format_from_old_bitfield(&f.subclass.format, (uncompress_subclass(fh->csub & ~0x40)))
ast_format_from_old_bitfield
ast_format_from_old_bitfield
&f.subclass.format
f.subclass.format
f.subclass
f
f
subclass
format
(uncompress_subclass(fh->csub & ~0x40))
uncompress_subclass(fh->csub & ~0x40)
uncompress_subclass
uncompress_subclass
fh->csub & ~0x40
fh->csub
fh
fh
csub
~0x40
0x40
if ((fh->csub >> 6) & 0x1) {				ast_format_set_video_mark(&f.subclass.format);			}
(fh->csub >> 6) & 0x1
(fh->csub >> 6)
fh->csub >> 6
fh->csub
fh
fh
csub
6
0x1
{				ast_format_set_video_mark(&f.subclass.format);			}
ast_format_set_video_mark(&f.subclass.format);
ast_format_set_video_mark(&f.subclass.format)
ast_format_set_video_mark
ast_format_set_video_mark
&f.subclass.format
f.subclass.format
f.subclass
f
f
subclass
format
if (f.frametype == AST_FRAME_VOICE) {			ast_format_from_old_bitfield(&f.subclass.format, uncompress_subclass(fh->csub));		} else {			f.subclass.integer = uncompress_subclass(fh->csub);		}
f.frametype == AST_FRAME_VOICE
f.frametype
f
f
frametype
AST_FRAME_VOICE
AST_FRAME_VOICE
{			ast_format_from_old_bitfield(&f.subclass.format, uncompress_subclass(fh->csub));		}
ast_format_from_old_bitfield(&f.subclass.format, uncompress_subclass(fh->csub));
ast_format_from_old_bitfield(&f.subclass.format, uncompress_subclass(fh->csub))
ast_format_from_old_bitfield
ast_format_from_old_bitfield
&f.subclass.format
f.subclass.format
f.subclass
f
f
subclass
format
uncompress_subclass(fh->csub)
uncompress_subclass
uncompress_subclass
fh->csub
fh
fh
csub
{			f.subclass.integer = uncompress_subclass(fh->csub);		}
f.subclass.integer = uncompress_subclass(fh->csub);
f.subclass.integer = uncompress_subclass(fh->csub)
f.subclass.integer
f.subclass
f
f
subclass
integer
uncompress_subclass(fh->csub)
uncompress_subclass
uncompress_subclass
fh->csub
fh
fh
csub
if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_POKE) {			/* Reply back with a PONG, but don't care about the result. */			send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_PONG, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			return 1;		} else if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_ACK && dcallno == 1) {			/* Ignore */			return 1;		}
f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_POKE
f.frametype == AST_FRAME_IAX
f.frametype
f
f
frametype
AST_FRAME_IAX
AST_FRAME_IAX
f.subclass.integer == IAX_COMMAND_POKE
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_POKE
IAX_COMMAND_POKE
{			/* Reply back with a PONG, but don't care about the result. */			send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_PONG, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			return 1;		}
send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_PONG, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);
send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_PONG, ntohl(fh->ts), fh->iseqno + 1, fd, NULL)
send_apathetic_reply
send_apathetic_reply
1
ntohs(fh->scallno)
ntohs
ntohs
fh->scallno
fh
fh
scallno
&sin
sin
sin
IAX_COMMAND_PONG
IAX_COMMAND_PONG
ntohl(fh->ts)
ntohl
ntohl
fh->ts
fh
fh
ts
fh->iseqno + 1
fh->iseqno
fh
fh
iseqno
1
fd
fd
NULL
NULL
return 1;
1
if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_ACK && dcallno == 1) {			/* Ignore */			return 1;		}
f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_ACK && dcallno == 1
f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_ACK
f.frametype == AST_FRAME_IAX
f.frametype
f
f
frametype
AST_FRAME_IAX
AST_FRAME_IAX
f.subclass.integer == IAX_COMMAND_ACK
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_ACK
IAX_COMMAND_ACK
dcallno == 1
dcallno
dcallno
1
{			/* Ignore */			return 1;		}
return 1;
1
f.datalen = res - sizeof(*fh);
f.datalen = res - sizeof(*fh)
f.datalen
f
f
datalen
res - sizeof(*fh)
res
res
sizeof(*fh)
(*fh)
*fh
fh
fh
if (f.datalen) {			if (f.frametype == AST_FRAME_IAX) {				if (iax_parse_ies(&ies, thread->buf + sizeof(struct ast_iax2_full_hdr), f.datalen)) {					ast_log(LOG_WARNING, "Undecodable frame received from '%s'\n", ast_inet_ntoa(sin.sin_addr));					ast_variables_destroy(ies.vars);					return 1;				}				f.data.ptr = NULL;				f.datalen = 0;			} else {				f.data.ptr = thread->buf + sizeof(struct ast_iax2_full_hdr);				memset(&ies, 0, sizeof(ies));			}		} else {			if (f.frametype == AST_FRAME_IAX)				f.data.ptr = NULL;			else				f.data.ptr = empty;			memset(&ies, 0, sizeof(ies));		}
f.datalen
f
f
datalen
{			if (f.frametype == AST_FRAME_IAX) {				if (iax_parse_ies(&ies, thread->buf + sizeof(struct ast_iax2_full_hdr), f.datalen)) {					ast_log(LOG_WARNING, "Undecodable frame received from '%s'\n", ast_inet_ntoa(sin.sin_addr));					ast_variables_destroy(ies.vars);					return 1;				}				f.data.ptr = NULL;				f.datalen = 0;			} else {				f.data.ptr = thread->buf + sizeof(struct ast_iax2_full_hdr);				memset(&ies, 0, sizeof(ies));			}		}
if (f.frametype == AST_FRAME_IAX) {				if (iax_parse_ies(&ies, thread->buf + sizeof(struct ast_iax2_full_hdr), f.datalen)) {					ast_log(LOG_WARNING, "Undecodable frame received from '%s'\n", ast_inet_ntoa(sin.sin_addr));					ast_variables_destroy(ies.vars);					return 1;				}				f.data.ptr = NULL;				f.datalen = 0;			} else {				f.data.ptr = thread->buf + sizeof(struct ast_iax2_full_hdr);				memset(&ies, 0, sizeof(ies));			}
f.frametype == AST_FRAME_IAX
f.frametype
f
f
frametype
AST_FRAME_IAX
AST_FRAME_IAX
{				if (iax_parse_ies(&ies, thread->buf + sizeof(struct ast_iax2_full_hdr), f.datalen)) {					ast_log(LOG_WARNING, "Undecodable frame received from '%s'\n", ast_inet_ntoa(sin.sin_addr));					ast_variables_destroy(ies.vars);					return 1;				}				f.data.ptr = NULL;				f.datalen = 0;			}
if (iax_parse_ies(&ies, thread->buf + sizeof(struct ast_iax2_full_hdr), f.datalen)) {					ast_log(LOG_WARNING, "Undecodable frame received from '%s'\n", ast_inet_ntoa(sin.sin_addr));					ast_variables_destroy(ies.vars);					return 1;				}
iax_parse_ies(&ies, thread->buf + sizeof(struct ast_iax2_full_hdr), f.datalen)
iax_parse_ies
iax_parse_ies
&ies
ies
ies
thread->buf + sizeof(struct ast_iax2_full_hdr)
thread->buf
thread
thread
buf
sizeof(struct ast_iax2_full_hdr)
struct ast_iax2_full_hdr
struct ast_iax2_full_hdr
ast_iax2_full_hdr

f.datalen
f
f
datalen
{					ast_log(LOG_WARNING, "Undecodable frame received from '%s'\n", ast_inet_ntoa(sin.sin_addr));					ast_variables_destroy(ies.vars);					return 1;				}
ast_log(LOG_WARNING, "Undecodable frame received from '%s'\n", ast_inet_ntoa(sin.sin_addr));
ast_log(LOG_WARNING, "Undecodable frame received from '%s'\n", ast_inet_ntoa(sin.sin_addr))
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"Undecodable frame received from '%s'\n"
ast_inet_ntoa(sin.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
sin.sin_addr
sin
sin
sin_addr
ast_variables_destroy(ies.vars);
ast_variables_destroy(ies.vars)
ast_variables_destroy
ast_variables_destroy
ies.vars
ies
ies
vars
return 1;
1
f.data.ptr = NULL;
f.data.ptr = NULL
f.data.ptr
f.data
f
f
data
ptr
NULL
NULL
f.datalen = 0;
f.datalen = 0
f.datalen
f
f
datalen
0
{				f.data.ptr = thread->buf + sizeof(struct ast_iax2_full_hdr);				memset(&ies, 0, sizeof(ies));			}
f.data.ptr = thread->buf + sizeof(struct ast_iax2_full_hdr);
f.data.ptr = thread->buf + sizeof(struct ast_iax2_full_hdr)
f.data.ptr
f.data
f
f
data
ptr
thread->buf + sizeof(struct ast_iax2_full_hdr)
thread->buf
thread
thread
buf
sizeof(struct ast_iax2_full_hdr)
struct ast_iax2_full_hdr
struct ast_iax2_full_hdr
ast_iax2_full_hdr

memset(&ies, 0, sizeof(ies));
memset(&ies, 0, sizeof(ies))
memset
memset
&ies
ies
ies
0
sizeof(ies)
(ies)
ies
ies
{			if (f.frametype == AST_FRAME_IAX)				f.data.ptr = NULL;			else				f.data.ptr = empty;			memset(&ies, 0, sizeof(ies));		}
if (f.frametype == AST_FRAME_IAX)				f.data.ptr = NULL;			else				f.data.ptr = empty;
f.frametype == AST_FRAME_IAX
f.frametype
f
f
frametype
AST_FRAME_IAX
AST_FRAME_IAX
f.data.ptr = NULL;
f.data.ptr = NULL
f.data.ptr
f.data
f
f
data
ptr
NULL
NULL
f.data.ptr = empty;
f.data.ptr = empty
f.data.ptr
f.data
f
f
data
ptr
empty
empty
memset(&ies, 0, sizeof(ies));
memset(&ies, 0, sizeof(ies))
memset
memset
&ies
ies
ies
0
sizeof(ies)
(ies)
ies
ies
if (!dcallno && iax2_allow_new(f.frametype, f.subclass.integer, 1)) {			/* only set NEW_ALLOW if calltoken checks out */			if (handle_call_token(fh, &ies, &sin, fd)) {				ast_variables_destroy(ies.vars);				return 1;			}			if (ies.calltoken && ies.calltokendata) {				/* if we've gotten this far, and the calltoken ie data exists,				 * then calltoken validation _MUST_ have taken place.  If calltoken				 * data is provided, it is always validated reguardless of any				 * calltokenoptional or requirecalltoken options */				new = NEW_ALLOW_CALLTOKEN_VALIDATED;			} else {				new = NEW_ALLOW;			}		}
!dcallno && iax2_allow_new(f.frametype, f.subclass.integer, 1)
!dcallno
dcallno
dcallno
iax2_allow_new(f.frametype, f.subclass.integer, 1)
iax2_allow_new
iax2_allow_new
f.frametype
f
f
frametype
f.subclass.integer
f.subclass
f
f
subclass
integer
1
{			/* only set NEW_ALLOW if calltoken checks out */			if (handle_call_token(fh, &ies, &sin, fd)) {				ast_variables_destroy(ies.vars);				return 1;			}			if (ies.calltoken && ies.calltokendata) {				/* if we've gotten this far, and the calltoken ie data exists,				 * then calltoken validation _MUST_ have taken place.  If calltoken				 * data is provided, it is always validated reguardless of any				 * calltokenoptional or requirecalltoken options */				new = NEW_ALLOW_CALLTOKEN_VALIDATED;			} else {				new = NEW_ALLOW;			}		}
if (handle_call_token(fh, &ies, &sin, fd)) {				ast_variables_destroy(ies.vars);				return 1;			}
handle_call_token(fh, &ies, &sin, fd)
handle_call_token
handle_call_token
fh
fh
&ies
ies
ies
&sin
sin
sin
fd
fd
{				ast_variables_destroy(ies.vars);				return 1;			}
ast_variables_destroy(ies.vars);
ast_variables_destroy(ies.vars)
ast_variables_destroy
ast_variables_destroy
ies.vars
ies
ies
vars
return 1;
1
if (ies.calltoken && ies.calltokendata) {				/* if we've gotten this far, and the calltoken ie data exists,				 * then calltoken validation _MUST_ have taken place.  If calltoken				 * data is provided, it is always validated reguardless of any				 * calltokenoptional or requirecalltoken options */				new = NEW_ALLOW_CALLTOKEN_VALIDATED;			} else {				new = NEW_ALLOW;			}
ies.calltoken && ies.calltokendata
ies.calltoken
ies
ies
calltoken
ies.calltokendata
ies
ies
calltokendata
{				/* if we've gotten this far, and the calltoken ie data exists,				 * then calltoken validation _MUST_ have taken place.  If calltoken				 * data is provided, it is always validated reguardless of any				 * calltokenoptional or requirecalltoken options */				new = NEW_ALLOW_CALLTOKEN_VALIDATED;			}
new = NEW_ALLOW_CALLTOKEN_VALIDATED;
{				new = NEW_ALLOW;			}
new = NEW_ALLOW;
{		/* Don't know anything about it yet */		f.frametype = AST_FRAME_NULL;		f.subclass.integer = 0;		memset(&ies, 0, sizeof(ies));	}
f.frametype = AST_FRAME_NULL;
f.frametype = AST_FRAME_NULL
f.frametype
f
f
frametype
AST_FRAME_NULL
AST_FRAME_NULL
f.subclass.integer = 0;
f.subclass.integer = 0
f.subclass.integer
f.subclass
f
f
subclass
integer
0
memset(&ies, 0, sizeof(ies));
memset(&ies, 0, sizeof(ies))
memset
memset
&ies
ies
ies
0
sizeof(ies)
(ies)
ies
ies
if (!fr->callno) {		int check_dcallno = 0;		/*		 * We enforce accurate destination call numbers for ACKs.  This forces the other		 * end to know the destination call number before call setup can complete.		 *		 * Discussed in the following thread:		 *    http://lists.digium.com/pipermail/asterisk-dev/2008-May/033217.html 		 */		if ((ntohs(mh->callno) & IAX_FLAG_FULL) && ((f.frametype == AST_FRAME_IAX) && (f.subclass.integer == IAX_COMMAND_ACK))) {			check_dcallno = 1;		}		if (!(fr->callno = find_callno(ntohs(mh->callno) & ~IAX_FLAG_FULL, dcallno, &sin, new, fd, check_dcallno))) {			if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_NEW) {				send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REJECT, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			} else if (f.frametype == AST_FRAME_IAX && (f.subclass.integer == IAX_COMMAND_REGREQ || f.subclass.integer == IAX_COMMAND_REGREL)) {				send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REGREJ, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			}			ast_variables_destroy(ies.vars);			return 1;		}	}
!fr->callno
fr->callno
fr
fr
callno
{		int check_dcallno = 0;		/*		 * We enforce accurate destination call numbers for ACKs.  This forces the other		 * end to know the destination call number before call setup can complete.		 *		 * Discussed in the following thread:		 *    http://lists.digium.com/pipermail/asterisk-dev/2008-May/033217.html 		 */		if ((ntohs(mh->callno) & IAX_FLAG_FULL) && ((f.frametype == AST_FRAME_IAX) && (f.subclass.integer == IAX_COMMAND_ACK))) {			check_dcallno = 1;		}		if (!(fr->callno = find_callno(ntohs(mh->callno) & ~IAX_FLAG_FULL, dcallno, &sin, new, fd, check_dcallno))) {			if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_NEW) {				send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REJECT, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			} else if (f.frametype == AST_FRAME_IAX && (f.subclass.integer == IAX_COMMAND_REGREQ || f.subclass.integer == IAX_COMMAND_REGREL)) {				send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REGREJ, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			}			ast_variables_destroy(ies.vars);			return 1;		}	}
int check_dcallno = 0;
int check_dcallno = 0;
int
check_dcallno = 0
check_dcallno
= 0
0
if ((ntohs(mh->callno) & IAX_FLAG_FULL) && ((f.frametype == AST_FRAME_IAX) && (f.subclass.integer == IAX_COMMAND_ACK))) {			check_dcallno = 1;		}
(ntohs(mh->callno) & IAX_FLAG_FULL) && ((f.frametype == AST_FRAME_IAX) && (f.subclass.integer == IAX_COMMAND_ACK))
(ntohs(mh->callno) & IAX_FLAG_FULL)
ntohs(mh->callno) & IAX_FLAG_FULL
ntohs(mh->callno)
ntohs
ntohs
mh->callno
mh
mh
callno
IAX_FLAG_FULL
IAX_FLAG_FULL
((f.frametype == AST_FRAME_IAX) && (f.subclass.integer == IAX_COMMAND_ACK))
(f.frametype == AST_FRAME_IAX) && (f.subclass.integer == IAX_COMMAND_ACK)
(f.frametype == AST_FRAME_IAX)
f.frametype == AST_FRAME_IAX
f.frametype
f
f
frametype
AST_FRAME_IAX
AST_FRAME_IAX
(f.subclass.integer == IAX_COMMAND_ACK)
f.subclass.integer == IAX_COMMAND_ACK
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_ACK
IAX_COMMAND_ACK
{			check_dcallno = 1;		}
check_dcallno = 1;
check_dcallno = 1
check_dcallno
check_dcallno
1
if (!(fr->callno = find_callno(ntohs(mh->callno) & ~IAX_FLAG_FULL, dcallno, &sin, new, fd, check_dcallno))) {			if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_NEW) {				send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REJECT, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			} else if (f.frametype == AST_FRAME_IAX && (f.subclass.integer == IAX_COMMAND_REGREQ || f.subclass.integer == IAX_COMMAND_REGREL)) {				send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REGREJ, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			}			ast_variables_destroy(ies.vars);			return 1;		}
!(fr->callno = find_callno(ntohs(mh->callno) & ~IAX_FLAG_FULL, dcallno, &sin, new, fd, check_dcallno))
{			if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_NEW) {				send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REJECT, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			} else if (f.frametype == AST_FRAME_IAX && (f.subclass.integer == IAX_COMMAND_REGREQ || f.subclass.integer == IAX_COMMAND_REGREL)) {				send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REGREJ, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			}			ast_variables_destroy(ies.vars);			return 1;		}
if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_NEW) {				send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REJECT, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			} else if (f.frametype == AST_FRAME_IAX && (f.subclass.integer == IAX_COMMAND_REGREQ || f.subclass.integer == IAX_COMMAND_REGREL)) {				send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REGREJ, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			}
f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_NEW
f.frametype == AST_FRAME_IAX
f.frametype
f
f
frametype
AST_FRAME_IAX
AST_FRAME_IAX
f.subclass.integer == IAX_COMMAND_NEW
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_NEW
IAX_COMMAND_NEW
{				send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REJECT, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			}
send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REJECT, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);
send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REJECT, ntohl(fh->ts), fh->iseqno + 1, fd, NULL)
send_apathetic_reply
send_apathetic_reply
1
ntohs(fh->scallno)
ntohs
ntohs
fh->scallno
fh
fh
scallno
&sin
sin
sin
IAX_COMMAND_REJECT
IAX_COMMAND_REJECT
ntohl(fh->ts)
ntohl
ntohl
fh->ts
fh
fh
ts
fh->iseqno + 1
fh->iseqno
fh
fh
iseqno
1
fd
fd
NULL
NULL
if (f.frametype == AST_FRAME_IAX && (f.subclass.integer == IAX_COMMAND_REGREQ || f.subclass.integer == IAX_COMMAND_REGREL)) {				send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REGREJ, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			}
f.frametype == AST_FRAME_IAX && (f.subclass.integer == IAX_COMMAND_REGREQ || f.subclass.integer == IAX_COMMAND_REGREL)
f.frametype == AST_FRAME_IAX
f.frametype
f
f
frametype
AST_FRAME_IAX
AST_FRAME_IAX
(f.subclass.integer == IAX_COMMAND_REGREQ || f.subclass.integer == IAX_COMMAND_REGREL)
f.subclass.integer == IAX_COMMAND_REGREQ || f.subclass.integer == IAX_COMMAND_REGREL
f.subclass.integer == IAX_COMMAND_REGREQ
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_REGREQ
IAX_COMMAND_REGREQ
f.subclass.integer == IAX_COMMAND_REGREL
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_REGREL
IAX_COMMAND_REGREL
{				send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REGREJ, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);			}
send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REGREJ, ntohl(fh->ts), fh->iseqno + 1, fd, NULL);
send_apathetic_reply(1, ntohs(fh->scallno), &sin, IAX_COMMAND_REGREJ, ntohl(fh->ts), fh->iseqno + 1, fd, NULL)
send_apathetic_reply
send_apathetic_reply
1
ntohs(fh->scallno)
ntohs
ntohs
fh->scallno
fh
fh
scallno
&sin
sin
sin
IAX_COMMAND_REGREJ
IAX_COMMAND_REGREJ
ntohl(fh->ts)
ntohl
ntohl
fh->ts
fh
fh
ts
fh->iseqno + 1
fh->iseqno
fh
fh
iseqno
1
fd
fd
NULL
NULL
ast_variables_destroy(ies.vars);
ast_variables_destroy(ies.vars)
ast_variables_destroy
ast_variables_destroy
ies.vars
ies
ies
vars
return 1;
1
if (fr->callno > 0) {		struct ast_callid *mount_callid;		ast_mutex_lock(&iaxsl[fr->callno]);		if (iaxs[fr->callno] && ((mount_callid = iax_pvt_callid_get(fr->callno)))) {			/* Bind to thread */			ast_callid_threadassoc_add(mount_callid);			ast_callid_unref(mount_callid);		}	}
fr->callno > 0
fr->callno
fr
fr
callno
0
{		struct ast_callid *mount_callid;		ast_mutex_lock(&iaxsl[fr->callno]);		if (iaxs[fr->callno] && ((mount_callid = iax_pvt_callid_get(fr->callno)))) {			/* Bind to thread */			ast_callid_threadassoc_add(mount_callid);			ast_callid_unref(mount_callid);		}	}
struct ast_callid *mount_callid;
struct ast_callid *mount_callid;
struct ast_callid
ast_callid
*mount_callid
*
mount_callid
ast_mutex_lock(&iaxsl[fr->callno]);
ast_mutex_lock(&iaxsl[fr->callno]);
ast_mutex_lock
ast_mutex_lock
(&iaxsl[fr->callno])
&iaxsl[fr->callno]
&
iaxsl
[fr->callno]
fr->callno
fr
fr
callno
if (iaxs[fr->callno] && ((mount_callid = iax_pvt_callid_get(fr->callno)))) {			/* Bind to thread */			ast_callid_threadassoc_add(mount_callid);			ast_callid_unref(mount_callid);		}
iaxs[fr->callno] && ((mount_callid = iax_pvt_callid_get(fr->callno)))
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
((mount_callid = iax_pvt_callid_get(fr->callno)))
(mount_callid = iax_pvt_callid_get(fr->callno))
mount_callid = iax_pvt_callid_get(fr->callno)
mount_callid
mount_callid
iax_pvt_callid_get(fr->callno)
iax_pvt_callid_get
iax_pvt_callid_get
fr->callno
fr
fr
callno
{			/* Bind to thread */			ast_callid_threadassoc_add(mount_callid);			ast_callid_unref(mount_callid);		}
ast_callid_threadassoc_add(mount_callid);
ast_callid_threadassoc_add(mount_callid)
ast_callid_threadassoc_add
ast_callid_threadassoc_add
mount_callid
mount_callid
ast_callid_unref(mount_callid);
ast_callid_unref(mount_callid)
ast_callid_unref
ast_callid_unref
mount_callid
mount_callid
if (!fr->callno || !iaxs[fr->callno]) {		/* A call arrived for a nonexistent destination.  Unless it's an "inval"		   frame, reply with an inval */		if (ntohs(mh->callno) & IAX_FLAG_FULL) {			/* We can only raw hangup control frames */			if (((f.subclass.integer != IAX_COMMAND_INVAL) &&				 (f.subclass.integer != IAX_COMMAND_TXCNT) &&				 (f.subclass.integer != IAX_COMMAND_TXACC) &&				 (f.subclass.integer != IAX_COMMAND_FWDOWNL))||			    (f.frametype != AST_FRAME_IAX))				raw_hangup(&sin, ntohs(fh->dcallno) & ~IAX_FLAG_RETRANS, ntohs(mh->callno) & ~IAX_FLAG_FULL,				fd);		}		if (fr->callno > 0) 			ast_mutex_unlock(&iaxsl[fr->callno]);		ast_variables_destroy(ies.vars);		return 1;	}
!fr->callno || !iaxs[fr->callno]
!fr->callno
fr->callno
fr
fr
callno
!iaxs[fr->callno]
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{		/* A call arrived for a nonexistent destination.  Unless it's an "inval"		   frame, reply with an inval */		if (ntohs(mh->callno) & IAX_FLAG_FULL) {			/* We can only raw hangup control frames */			if (((f.subclass.integer != IAX_COMMAND_INVAL) &&				 (f.subclass.integer != IAX_COMMAND_TXCNT) &&				 (f.subclass.integer != IAX_COMMAND_TXACC) &&				 (f.subclass.integer != IAX_COMMAND_FWDOWNL))||			    (f.frametype != AST_FRAME_IAX))				raw_hangup(&sin, ntohs(fh->dcallno) & ~IAX_FLAG_RETRANS, ntohs(mh->callno) & ~IAX_FLAG_FULL,				fd);		}		if (fr->callno > 0) 			ast_mutex_unlock(&iaxsl[fr->callno]);		ast_variables_destroy(ies.vars);		return 1;	}
if (ntohs(mh->callno) & IAX_FLAG_FULL) {			/* We can only raw hangup control frames */			if (((f.subclass.integer != IAX_COMMAND_INVAL) &&				 (f.subclass.integer != IAX_COMMAND_TXCNT) &&				 (f.subclass.integer != IAX_COMMAND_TXACC) &&				 (f.subclass.integer != IAX_COMMAND_FWDOWNL))||			    (f.frametype != AST_FRAME_IAX))				raw_hangup(&sin, ntohs(fh->dcallno) & ~IAX_FLAG_RETRANS, ntohs(mh->callno) & ~IAX_FLAG_FULL,				fd);		}
ntohs(mh->callno) & IAX_FLAG_FULL
ntohs(mh->callno)
ntohs
ntohs
mh->callno
mh
mh
callno
IAX_FLAG_FULL
IAX_FLAG_FULL
{			/* We can only raw hangup control frames */			if (((f.subclass.integer != IAX_COMMAND_INVAL) &&				 (f.subclass.integer != IAX_COMMAND_TXCNT) &&				 (f.subclass.integer != IAX_COMMAND_TXACC) &&				 (f.subclass.integer != IAX_COMMAND_FWDOWNL))||			    (f.frametype != AST_FRAME_IAX))				raw_hangup(&sin, ntohs(fh->dcallno) & ~IAX_FLAG_RETRANS, ntohs(mh->callno) & ~IAX_FLAG_FULL,				fd);		}
if (((f.subclass.integer != IAX_COMMAND_INVAL) &&				 (f.subclass.integer != IAX_COMMAND_TXCNT) &&				 (f.subclass.integer != IAX_COMMAND_TXACC) &&				 (f.subclass.integer != IAX_COMMAND_FWDOWNL))||			    (f.frametype != AST_FRAME_IAX))				raw_hangup(&sin, ntohs(fh->dcallno) & ~IAX_FLAG_RETRANS, ntohs(mh->callno) & ~IAX_FLAG_FULL,				fd);
((f.subclass.integer != IAX_COMMAND_INVAL) &&				 (f.subclass.integer != IAX_COMMAND_TXCNT) &&				 (f.subclass.integer != IAX_COMMAND_TXACC) &&				 (f.subclass.integer != IAX_COMMAND_FWDOWNL))||			    (f.frametype != AST_FRAME_IAX)
((f.subclass.integer != IAX_COMMAND_INVAL) &&				 (f.subclass.integer != IAX_COMMAND_TXCNT) &&				 (f.subclass.integer != IAX_COMMAND_TXACC) &&				 (f.subclass.integer != IAX_COMMAND_FWDOWNL))
(f.subclass.integer != IAX_COMMAND_INVAL) &&				 (f.subclass.integer != IAX_COMMAND_TXCNT) &&				 (f.subclass.integer != IAX_COMMAND_TXACC) &&				 (f.subclass.integer != IAX_COMMAND_FWDOWNL)
(f.subclass.integer != IAX_COMMAND_INVAL) &&				 (f.subclass.integer != IAX_COMMAND_TXCNT) &&				 (f.subclass.integer != IAX_COMMAND_TXACC)
(f.subclass.integer != IAX_COMMAND_INVAL) &&				 (f.subclass.integer != IAX_COMMAND_TXCNT)
(f.subclass.integer != IAX_COMMAND_INVAL)
f.subclass.integer != IAX_COMMAND_INVAL
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_INVAL
IAX_COMMAND_INVAL
(f.subclass.integer != IAX_COMMAND_TXCNT)
f.subclass.integer != IAX_COMMAND_TXCNT
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_TXCNT
IAX_COMMAND_TXCNT
(f.subclass.integer != IAX_COMMAND_TXACC)
f.subclass.integer != IAX_COMMAND_TXACC
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_TXACC
IAX_COMMAND_TXACC
(f.subclass.integer != IAX_COMMAND_FWDOWNL)
f.subclass.integer != IAX_COMMAND_FWDOWNL
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_FWDOWNL
IAX_COMMAND_FWDOWNL
(f.frametype != AST_FRAME_IAX)
f.frametype != AST_FRAME_IAX
f.frametype
f
f
frametype
AST_FRAME_IAX
AST_FRAME_IAX
raw_hangup(&sin, ntohs(fh->dcallno) & ~IAX_FLAG_RETRANS, ntohs(mh->callno) & ~IAX_FLAG_FULL,				fd);
raw_hangup(&sin, ntohs(fh->dcallno) & ~IAX_FLAG_RETRANS, ntohs(mh->callno) & ~IAX_FLAG_FULL,				fd)
raw_hangup
raw_hangup
&sin
sin
sin
ntohs(fh->dcallno) & ~IAX_FLAG_RETRANS
ntohs(fh->dcallno)
ntohs
ntohs
fh->dcallno
fh
fh
dcallno
~IAX_FLAG_RETRANS
IAX_FLAG_RETRANS
IAX_FLAG_RETRANS
ntohs(mh->callno) & ~IAX_FLAG_FULL
ntohs(mh->callno)
ntohs
ntohs
mh->callno
mh
mh
callno
~IAX_FLAG_FULL
IAX_FLAG_FULL
IAX_FLAG_FULL
fd
fd
if (fr->callno > 0) 			ast_mutex_unlock(&iaxsl[fr->callno]);
fr->callno > 0
fr->callno
fr
fr
callno
0
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock
ast_mutex_unlock
(&iaxsl[fr->callno])
&iaxsl[fr->callno]
&
iaxsl
[fr->callno]
fr->callno
fr
fr
callno
ast_variables_destroy(ies.vars);
ast_variables_destroy(ies.vars)
ast_variables_destroy
ast_variables_destroy
ies.vars
ies
ies
vars
return 1;
1
if (ast_test_flag64(iaxs[fr->callno], IAX_ENCRYPTED) && !decrypted) {		if (decrypt_frame(fr->callno, fh, &f, &res)) {			ast_log(LOG_NOTICE, "Packet Decrypt Failed!\n");			ast_variables_destroy(ies.vars);			ast_mutex_unlock(&iaxsl[fr->callno]);			return 1;		}		decrypted = 1;	}
ast_test_flag64(iaxs[fr->callno], IAX_ENCRYPTED) && !decrypted
ast_test_flag64(iaxs[fr->callno], IAX_ENCRYPTED)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_ENCRYPTED
IAX_ENCRYPTED
!decrypted
decrypted
decrypted
{		if (decrypt_frame(fr->callno, fh, &f, &res)) {			ast_log(LOG_NOTICE, "Packet Decrypt Failed!\n");			ast_variables_destroy(ies.vars);			ast_mutex_unlock(&iaxsl[fr->callno]);			return 1;		}		decrypted = 1;	}
if (decrypt_frame(fr->callno, fh, &f, &res)) {			ast_log(LOG_NOTICE, "Packet Decrypt Failed!\n");			ast_variables_destroy(ies.vars);			ast_mutex_unlock(&iaxsl[fr->callno]);			return 1;		}
decrypt_frame(fr->callno, fh, &f, &res)
decrypt_frame
decrypt_frame
fr->callno
fr
fr
callno
fh
fh
&f
f
f
&res
res
res
{			ast_log(LOG_NOTICE, "Packet Decrypt Failed!\n");			ast_variables_destroy(ies.vars);			ast_mutex_unlock(&iaxsl[fr->callno]);			return 1;		}
ast_log(LOG_NOTICE, "Packet Decrypt Failed!\n");
ast_log(LOG_NOTICE, "Packet Decrypt Failed!\n")
ast_log
ast_log
LOG_NOTICE
LOG_NOTICE
"Packet Decrypt Failed!\n"
ast_variables_destroy(ies.vars);
ast_variables_destroy(ies.vars)
ast_variables_destroy
ast_variables_destroy
ies.vars
ies
ies
vars
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock
ast_mutex_unlock
(&iaxsl[fr->callno])
&iaxsl[fr->callno]
&
iaxsl
[fr->callno]
fr->callno
fr
fr
callno
return 1;
1
decrypted = 1;
decrypted = 1
decrypted
decrypted
1
if (iaxs[fr->callno]->owner && fh->type == AST_FRAME_IAX &&			(fh->csub == IAX_COMMAND_HANGUP			|| fh->csub == IAX_COMMAND_REJECT			|| fh->csub == IAX_COMMAND_REGREJ			|| fh->csub == IAX_COMMAND_TXREJ)) {		struct ast_control_pvt_cause_code *cause_code;		int data_size = sizeof(*cause_code);		char subclass[40] = "";		/* get subclass text */		iax_frame_subclass2str(fh->csub, subclass, sizeof(subclass));		/* add length of "IAX2 " */		data_size += 5;		/* for IAX hangup frames, add length of () and number */		data_size += 3;		if (ies.causecode > 9) {			data_size++;		}		if (ies.causecode > 99) {			data_size++;		}		/* add length of subclass */		data_size += strlen(subclass);		cause_code = ast_alloca(data_size);		ast_copy_string(cause_code->chan_name, ast_channel_name(iaxs[fr->callno]->owner), AST_CHANNEL_NAME);		cause_code->ast_cause = ies.causecode;		snprintf(cause_code->code, data_size - sizeof(*cause_code) + 1, "IAX2 %s(%d)", subclass, ies.causecode);		iax2_lock_owner(fr->callno);		if (iaxs[fr->callno] && iaxs[fr->callno]->owner) {			ast_queue_control_data(iaxs[fr->callno]->owner, AST_CONTROL_PVT_CAUSE_CODE, cause_code, data_size);			ast_channel_hangupcause_hash_set(iaxs[fr->callno]->owner, cause_code, data_size);			ast_channel_unlock(iaxs[fr->callno]->owner);		}		if (!iaxs[fr->callno]) {			ast_variables_destroy(ies.vars);			ast_mutex_unlock(&iaxsl[fr->callno]);			return 1;		}	}
iaxs[fr->callno]->owner && fh->type == AST_FRAME_IAX &&			(fh->csub == IAX_COMMAND_HANGUP			|| fh->csub == IAX_COMMAND_REJECT			|| fh->csub == IAX_COMMAND_REGREJ			|| fh->csub == IAX_COMMAND_TXREJ)
iaxs[fr->callno]->owner && fh->type == AST_FRAME_IAX
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
fh->type == AST_FRAME_IAX
fh->type
fh
fh
type
AST_FRAME_IAX
AST_FRAME_IAX
(fh->csub == IAX_COMMAND_HANGUP			|| fh->csub == IAX_COMMAND_REJECT			|| fh->csub == IAX_COMMAND_REGREJ			|| fh->csub == IAX_COMMAND_TXREJ)
fh->csub == IAX_COMMAND_HANGUP			|| fh->csub == IAX_COMMAND_REJECT			|| fh->csub == IAX_COMMAND_REGREJ			|| fh->csub == IAX_COMMAND_TXREJ
fh->csub == IAX_COMMAND_HANGUP			|| fh->csub == IAX_COMMAND_REJECT			|| fh->csub == IAX_COMMAND_REGREJ
fh->csub == IAX_COMMAND_HANGUP			|| fh->csub == IAX_COMMAND_REJECT
fh->csub == IAX_COMMAND_HANGUP
fh->csub
fh
fh
csub
IAX_COMMAND_HANGUP
IAX_COMMAND_HANGUP
fh->csub == IAX_COMMAND_REJECT
fh->csub
fh
fh
csub
IAX_COMMAND_REJECT
IAX_COMMAND_REJECT
fh->csub == IAX_COMMAND_REGREJ
fh->csub
fh
fh
csub
IAX_COMMAND_REGREJ
IAX_COMMAND_REGREJ
fh->csub == IAX_COMMAND_TXREJ
fh->csub
fh
fh
csub
IAX_COMMAND_TXREJ
IAX_COMMAND_TXREJ
{		struct ast_control_pvt_cause_code *cause_code;		int data_size = sizeof(*cause_code);		char subclass[40] = "";		/* get subclass text */		iax_frame_subclass2str(fh->csub, subclass, sizeof(subclass));		/* add length of "IAX2 " */		data_size += 5;		/* for IAX hangup frames, add length of () and number */		data_size += 3;		if (ies.causecode > 9) {			data_size++;		}		if (ies.causecode > 99) {			data_size++;		}		/* add length of subclass */		data_size += strlen(subclass);		cause_code = ast_alloca(data_size);		ast_copy_string(cause_code->chan_name, ast_channel_name(iaxs[fr->callno]->owner), AST_CHANNEL_NAME);		cause_code->ast_cause = ies.causecode;		snprintf(cause_code->code, data_size - sizeof(*cause_code) + 1, "IAX2 %s(%d)", subclass, ies.causecode);		iax2_lock_owner(fr->callno);		if (iaxs[fr->callno] && iaxs[fr->callno]->owner) {			ast_queue_control_data(iaxs[fr->callno]->owner, AST_CONTROL_PVT_CAUSE_CODE, cause_code, data_size);			ast_channel_hangupcause_hash_set(iaxs[fr->callno]->owner, cause_code, data_size);			ast_channel_unlock(iaxs[fr->callno]->owner);		}		if (!iaxs[fr->callno]) {			ast_variables_destroy(ies.vars);			ast_mutex_unlock(&iaxsl[fr->callno]);			return 1;		}	}
struct ast_control_pvt_cause_code *cause_code;
struct ast_control_pvt_cause_code *cause_code;
struct ast_control_pvt_cause_code
ast_control_pvt_cause_code
*cause_code
*
cause_code
int data_size = sizeof(*cause_code);
int data_size = sizeof(*cause_code);
int
data_size = sizeof(*cause_code)
data_size
= sizeof(*cause_code)
sizeof(*cause_code)
(*cause_code)
*cause_code
cause_code
cause_code
char subclass[40] = "";
char subclass[40] = "";
char
subclass[40] = ""
subclass
[40]
40
= ""
""
iax_frame_subclass2str(fh->csub, subclass, sizeof(subclass));
iax_frame_subclass2str(fh->csub, subclass, sizeof(subclass))
iax_frame_subclass2str
iax_frame_subclass2str
fh->csub
fh
fh
csub
subclass
subclass
sizeof(subclass)
(subclass)
subclass
subclass
data_size += 5;
data_size += 5
data_size
data_size
5
data_size += 3;
data_size += 3
data_size
data_size
3
if (ies.causecode > 9) {			data_size++;		}
ies.causecode > 9
ies.causecode
ies
ies
causecode
9
{			data_size++;		}
data_size++;
data_size++
data_size
data_size
if (ies.causecode > 99) {			data_size++;		}
ies.causecode > 99
ies.causecode
ies
ies
causecode
99
{			data_size++;		}
data_size++;
data_size++
data_size
data_size
data_size += strlen(subclass);
data_size += strlen(subclass)
data_size
data_size
strlen(subclass)
strlen
strlen
subclass
subclass
cause_code = ast_alloca(data_size);
cause_code = ast_alloca(data_size)
cause_code
cause_code
ast_alloca(data_size)
ast_alloca
ast_alloca
data_size
data_size
ast_copy_string(cause_code->chan_name, ast_channel_name(iaxs[fr->callno]->owner), AST_CHANNEL_NAME);
ast_copy_string(cause_code->chan_name, ast_channel_name(iaxs[fr->callno]->owner), AST_CHANNEL_NAME)
ast_copy_string
ast_copy_string
cause_code->chan_name
cause_code
cause_code
chan_name
ast_channel_name(iaxs[fr->callno]->owner)
ast_channel_name
ast_channel_name
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
AST_CHANNEL_NAME
AST_CHANNEL_NAME
cause_code->ast_cause = ies.causecode;
cause_code->ast_cause = ies.causecode
cause_code->ast_cause
cause_code
cause_code
ast_cause
ies.causecode
ies
ies
causecode
snprintf(cause_code->code, data_size - sizeof(*cause_code) + 1, "IAX2 %s(%d)", subclass, ies.causecode);
snprintf(cause_code->code, data_size - sizeof(*cause_code) + 1, "IAX2 %s(%d)", subclass, ies.causecode)
snprintf
snprintf
cause_code->code
cause_code
cause_code
code
data_size - sizeof(*cause_code) + 1
data_size - sizeof(*cause_code)
data_size
data_size
sizeof(*cause_code)
(*cause_code)
*cause_code
cause_code
cause_code
1
"IAX2 %s(%d)"
subclass
subclass
ies.causecode
ies
ies
causecode
iax2_lock_owner(fr->callno);
iax2_lock_owner(fr->callno)
iax2_lock_owner
iax2_lock_owner
fr->callno
fr
fr
callno
if (iaxs[fr->callno] && iaxs[fr->callno]->owner) {			ast_queue_control_data(iaxs[fr->callno]->owner, AST_CONTROL_PVT_CAUSE_CODE, cause_code, data_size);			ast_channel_hangupcause_hash_set(iaxs[fr->callno]->owner, cause_code, data_size);			ast_channel_unlock(iaxs[fr->callno]->owner);		}
iaxs[fr->callno] && iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
{			ast_queue_control_data(iaxs[fr->callno]->owner, AST_CONTROL_PVT_CAUSE_CODE, cause_code, data_size);			ast_channel_hangupcause_hash_set(iaxs[fr->callno]->owner, cause_code, data_size);			ast_channel_unlock(iaxs[fr->callno]->owner);		}
ast_queue_control_data(iaxs[fr->callno]->owner, AST_CONTROL_PVT_CAUSE_CODE, cause_code, data_size);
ast_queue_control_data(iaxs[fr->callno]->owner, AST_CONTROL_PVT_CAUSE_CODE, cause_code, data_size)
ast_queue_control_data
ast_queue_control_data
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
AST_CONTROL_PVT_CAUSE_CODE
AST_CONTROL_PVT_CAUSE_CODE
cause_code
cause_code
data_size
data_size
ast_channel_hangupcause_hash_set(iaxs[fr->callno]->owner, cause_code, data_size);
ast_channel_hangupcause_hash_set(iaxs[fr->callno]->owner, cause_code, data_size)
ast_channel_hangupcause_hash_set
ast_channel_hangupcause_hash_set
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
cause_code
cause_code
data_size
data_size
ast_channel_unlock(iaxs[fr->callno]->owner);
ast_channel_unlock(iaxs[fr->callno]->owner)
ast_channel_unlock
ast_channel_unlock
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
if (!iaxs[fr->callno]) {			ast_variables_destroy(ies.vars);			ast_mutex_unlock(&iaxsl[fr->callno]);			return 1;		}
!iaxs[fr->callno]
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{			ast_variables_destroy(ies.vars);			ast_mutex_unlock(&iaxsl[fr->callno]);			return 1;		}
ast_variables_destroy(ies.vars);
ast_variables_destroy(ies.vars)
ast_variables_destroy
ast_variables_destroy
ies.vars
ies
ies
vars
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock
ast_mutex_unlock
(&iaxsl[fr->callno])
&iaxsl[fr->callno]
&
iaxsl
[fr->callno]
fr->callno
fr
fr
callno
return 1;
1
iaxs[fr->callno]->frames_received++;
iaxs[fr->callno]->frames_received++
iaxs[fr->callno]->frames_received
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
frames_received
if (!inaddrcmp(&sin, &iaxs[fr->callno]->addr) && !minivid &&		f.subclass.integer != IAX_COMMAND_TXCNT &&		/* for attended transfer */		f.subclass.integer != IAX_COMMAND_TXACC) {		/* for attended transfer */		unsigned short new_peercallno;		new_peercallno = (unsigned short) (ntohs(mh->callno) & ~IAX_FLAG_FULL);		if (new_peercallno && new_peercallno != iaxs[fr->callno]->peercallno) {			if (iaxs[fr->callno]->peercallno) {				remove_by_peercallno(iaxs[fr->callno]);			}			iaxs[fr->callno]->peercallno = new_peercallno;			store_by_peercallno(iaxs[fr->callno]);		}	}
!inaddrcmp(&sin, &iaxs[fr->callno]->addr) && !minivid &&		f.subclass.integer != IAX_COMMAND_TXCNT &&		/* for attended transfer */		f.subclass.integer != IAX_COMMAND_TXACC
!inaddrcmp(&sin, &iaxs[fr->callno]->addr) && !minivid &&		f.subclass.integer != IAX_COMMAND_TXCNT
!inaddrcmp(&sin, &iaxs[fr->callno]->addr) && !minivid
!inaddrcmp(&sin, &iaxs[fr->callno]->addr)
inaddrcmp(&sin, &iaxs[fr->callno]->addr)
inaddrcmp
inaddrcmp
&sin
sin
sin
&iaxs[fr->callno]->addr
iaxs[fr->callno]->addr
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
addr
!minivid
minivid
minivid
f.subclass.integer != IAX_COMMAND_TXCNT
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_TXCNT
IAX_COMMAND_TXCNT
f.subclass.integer != IAX_COMMAND_TXACC
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_TXACC
IAX_COMMAND_TXACC
{		/* for attended transfer */		unsigned short new_peercallno;		new_peercallno = (unsigned short) (ntohs(mh->callno) & ~IAX_FLAG_FULL);		if (new_peercallno && new_peercallno != iaxs[fr->callno]->peercallno) {			if (iaxs[fr->callno]->peercallno) {				remove_by_peercallno(iaxs[fr->callno]);			}			iaxs[fr->callno]->peercallno = new_peercallno;			store_by_peercallno(iaxs[fr->callno]);		}	}
unsigned short new_peercallno;
unsigned short new_peercallno;
unsigned short
new_peercallno
new_peercallno
new_peercallno = (unsigned short) (ntohs(mh->callno) & ~IAX_FLAG_FULL);
new_peercallno = (unsigned short) (ntohs(mh->callno) & ~IAX_FLAG_FULL)
new_peercallno
new_peercallno
(unsigned short) (ntohs(mh->callno) & ~IAX_FLAG_FULL)
unsigned short
unsigned short

(ntohs(mh->callno) & ~IAX_FLAG_FULL)
ntohs(mh->callno) & ~IAX_FLAG_FULL
ntohs(mh->callno)
ntohs
ntohs
mh->callno
mh
mh
callno
~IAX_FLAG_FULL
IAX_FLAG_FULL
IAX_FLAG_FULL
if (new_peercallno && new_peercallno != iaxs[fr->callno]->peercallno) {			if (iaxs[fr->callno]->peercallno) {				remove_by_peercallno(iaxs[fr->callno]);			}			iaxs[fr->callno]->peercallno = new_peercallno;			store_by_peercallno(iaxs[fr->callno]);		}
new_peercallno && new_peercallno != iaxs[fr->callno]->peercallno
new_peercallno
new_peercallno
new_peercallno != iaxs[fr->callno]->peercallno
new_peercallno
new_peercallno
iaxs[fr->callno]->peercallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercallno
{			if (iaxs[fr->callno]->peercallno) {				remove_by_peercallno(iaxs[fr->callno]);			}			iaxs[fr->callno]->peercallno = new_peercallno;			store_by_peercallno(iaxs[fr->callno]);		}
if (iaxs[fr->callno]->peercallno) {				remove_by_peercallno(iaxs[fr->callno]);			}
iaxs[fr->callno]->peercallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercallno
{				remove_by_peercallno(iaxs[fr->callno]);			}
remove_by_peercallno(iaxs[fr->callno]);
remove_by_peercallno(iaxs[fr->callno]);
remove_by_peercallno
remove_by_peercallno
(iaxs[fr->callno])
iaxs[fr->callno]
iaxs
[fr->callno]
fr->callno
fr
fr
callno
iaxs[fr->callno]->peercallno = new_peercallno;
iaxs[fr->callno]->peercallno = new_peercallno
iaxs[fr->callno]->peercallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercallno
new_peercallno
new_peercallno
store_by_peercallno(iaxs[fr->callno]);
store_by_peercallno(iaxs[fr->callno]);
store_by_peercallno
store_by_peercallno
(iaxs[fr->callno])
iaxs[fr->callno]
iaxs
[fr->callno]
fr->callno
fr
fr
callno
if (ntohs(mh->callno) & IAX_FLAG_FULL) {		if (iaxdebug)			ast_debug(1, "Received packet %d, (%d, %u)\n", fh->oseqno, f.frametype, f.subclass.integer);		/* Check if it's out of order (and not an ACK or INVAL) */		fr->oseqno = fh->oseqno;		fr->iseqno = fh->iseqno;		fr->ts = ntohl(fh->ts);#ifdef IAXTESTS		if (test_resync) {			ast_debug(1, "Simulating frame ts resync, was %u now %u\n", fr->ts, fr->ts + test_resync);			fr->ts += test_resync;		}#endif /* IAXTESTS */#if 0		if ( (ntohs(fh->dcallno) & IAX_FLAG_RETRANS) ||		     ( (f.frametype != AST_FRAME_VOICE) && ! (f.frametype == AST_FRAME_IAX &&								(f.subclass == IAX_COMMAND_NEW ||								 f.subclass == IAX_COMMAND_AUTHREQ ||								 f.subclass == IAX_COMMAND_ACCEPT ||								 f.subclass == IAX_COMMAND_REJECT))      ) )#endif		if ((ntohs(fh->dcallno) & IAX_FLAG_RETRANS) || (f.frametype != AST_FRAME_VOICE))			updatehistory = 0;		if ((iaxs[fr->callno]->iseqno != fr->oseqno) &&			(iaxs[fr->callno]->iseqno ||				((f.subclass.integer != IAX_COMMAND_TXCNT) &&				(f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXACC)) ||				(f.frametype != AST_FRAME_IAX))) {			if (			 ((f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_INVAL) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&			  (f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_VNAK)) ||			  (f.frametype != AST_FRAME_IAX)) {				/* If it's not an ACK packet, it's out of order. */				ast_debug(1, "Packet arrived out of order (expecting %d, got %d) (frametype = %d, subclass = %d)\n",					iaxs[fr->callno]->iseqno, fr->oseqno, f.frametype, f.subclass.integer);				/* Check to see if we need to request retransmission,				 * and take sequence number wraparound into account */				if ((unsigned char) (iaxs[fr->callno]->iseqno - fr->oseqno) < 128) {					/* If we've already seen it, ack it XXX There's a border condition here XXX */					if ((f.frametype != AST_FRAME_IAX) ||							((f.subclass.integer != IAX_COMMAND_ACK) && (f.subclass.integer != IAX_COMMAND_INVAL))) {						ast_debug(1, "Acking anyway\n");						/* XXX Maybe we should handle its ack to us, but then again, it's probably outdated anyway, and if						   we have anything to send, we'll retransmit and get an ACK back anyway XXX */						send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					}				} else {					/* Send a VNAK requesting retransmission */					iax2_vnak(fr->callno);				}				ast_variables_destroy(ies.vars);				ast_mutex_unlock(&iaxsl[fr->callno]);				return 1;			}		} else {			/* Increment unless it's an ACK or VNAK */			if (((f.subclass.integer != IAX_COMMAND_ACK) &&			    (f.subclass.integer != IAX_COMMAND_INVAL) &&			    (f.subclass.integer != IAX_COMMAND_TXCNT) &&			    (f.subclass.integer != IAX_COMMAND_TXACC) &&				(f.subclass.integer != IAX_COMMAND_VNAK)) ||			    (f.frametype != AST_FRAME_IAX))				iaxs[fr->callno]->iseqno++;		}		/* Ensure text frames are NULL-terminated */		if (f.frametype == AST_FRAME_TEXT && thread->buf[res - 1] != '\0') {			if (res < thread->buf_size)				thread->buf[res++] = '\0';			else /* Trims one character from the text message, but that's better than overwriting the end of the buffer. */				thread->buf[res - 1] = '\0';		}		/* Handle implicit ACKing unless this is an INVAL, and only if this is 		   from the real peer, not the transfer peer */		if (!inaddrcmp(&sin, &iaxs[fr->callno]->addr) &&		    ((f.subclass.integer != IAX_COMMAND_INVAL) ||		     (f.frametype != AST_FRAME_IAX))) {			unsigned char x;			int call_to_destroy;			/* First we have to qualify that the ACKed value is within our window */			if (iaxs[fr->callno]->rseqno >= iaxs[fr->callno]->oseqno || (fr->iseqno >= iaxs[fr->callno]->rseqno && fr->iseqno < iaxs[fr->callno]->oseqno))				x = fr->iseqno;			else				x = iaxs[fr->callno]->oseqno;			if ((x != iaxs[fr->callno]->oseqno) || (iaxs[fr->callno]->oseqno == fr->iseqno)) {				/* The acknowledgement is within our window.  Time to acknowledge everything				   that it says to */				for (x=iaxs[fr->callno]->rseqno; x != fr->iseqno; x++) {					/* Ack the packet with the given timestamp */					if (iaxdebug)						ast_debug(1, "Cancelling transmission of packet %d\n", x);					call_to_destroy = 0;					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* If it's our call, and our timestamp, mark -1 retries */						if (x == cur->oseqno) {							cur->retries = -1;							/* Destroy call if this is the end */							if (cur->final)								call_to_destroy = fr->callno;						}					}					if (call_to_destroy) {						if (iaxdebug)							ast_debug(1, "Really destroying %d, having been acked on final message\n", call_to_destroy);						ast_mutex_lock(&iaxsl[call_to_destroy]);						iax2_destroy(call_to_destroy);						ast_mutex_unlock(&iaxsl[call_to_destroy]);					}				}				/* Note how much we've received acknowledgement for */				if (iaxs[fr->callno])					iaxs[fr->callno]->rseqno = fr->iseqno;				else {					/* Stop processing now */					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}			} else {				ast_debug(1, "Received iseqno %d not within window %d->%d\n", fr->iseqno, iaxs[fr->callno]->rseqno, iaxs[fr->callno]->oseqno);			}		}		if (inaddrcmp(&sin, &iaxs[fr->callno]->addr) &&			((f.frametype != AST_FRAME_IAX) ||			 ((f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT)))) {			/* Only messages we accept from a transfer host are TXACC and TXCNT */			ast_variables_destroy(ies.vars);			ast_mutex_unlock(&iaxsl[fr->callno]);			return 1;		}		/* when we receive the first full frame for a new incoming channel,		   it is safe to start the PBX on the channel because we have now		   completed a 3-way handshake with the peer */		if ((f.frametype == AST_FRAME_VOICE) ||		    (f.frametype == AST_FRAME_VIDEO) ||		    (f.frametype == AST_FRAME_IAX)) {			if (ast_test_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART)) {				ast_clear_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);				if (!ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->chosenformat, NULL)) {					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}			}			if (ies.vars) {				struct ast_datastore *variablestore = NULL;				struct ast_variable *var, *prev = NULL;				AST_LIST_HEAD(, ast_var_t) *varlist;				iax2_lock_owner(fr->callno);				if (!iaxs[fr->callno]) {					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}				if ((c = iaxs[fr->callno]->owner)) {					varlist = ast_calloc(1, sizeof(*varlist));					variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);					if (variablestore && varlist) {						variablestore->data = varlist;						variablestore->inheritance = DATASTORE_INHERIT_FOREVER;						AST_LIST_HEAD_INIT(varlist);						ast_debug(1, "I can haz IAX vars?\n");						for (var = ies.vars; var; var = var->next) {							struct ast_var_t *newvar = ast_var_assign(var->name, var->value);							if (prev) {								ast_free(prev);							}							prev = var;							if (!newvar) {								/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");							} else {								AST_LIST_INSERT_TAIL(varlist, newvar, entries);							}						}						if (prev) {							ast_free(prev);						}						ies.vars = NULL;						ast_channel_datastore_add(c, variablestore);					} else {						ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");						if (variablestore) {							ast_datastore_free(variablestore);						}						if (varlist) {							ast_free(varlist);						}					}					ast_channel_unlock(c);				} else {					/* No channel yet, so transfer the variables directly over to the pvt,					 * for later inheritance. */					ast_debug(1, "No channel, so populating IAXVARs to the pvt, as an intermediate step.\n");					for (var = ies.vars; var && var->next; var = var->next);					if (var) {						var->next = iaxs[fr->callno]->iaxvars;						iaxs[fr->callno]->iaxvars = ies.vars;						ies.vars = NULL;					}				}			}			if (ies.vars) {				ast_debug(1, "I have IAX variables, but they were not processed\n");			}		}		/* once we receive our first IAX Full Frame that is not CallToken related, send all		 * queued signaling frames that were being held. */		if ((f.frametype == AST_FRAME_IAX) && (f.subclass.integer != IAX_COMMAND_CALLTOKEN) && iaxs[fr->callno]->hold_signaling) {			send_signaling(iaxs[fr->callno]);		}		if (f.frametype == AST_FRAME_VOICE) {			if (ast_format_to_old_bitfield(&f.subclass.format) != iaxs[fr->callno]->voiceformat) {					iaxs[fr->callno]->voiceformat = ast_format_to_old_bitfield(&f.subclass.format);					ast_debug(1, "Ooh, voice format changed to '%s'\n", ast_getformatname(&f.subclass.format));					if (iaxs[fr->callno]->owner) {						iax2_lock_owner(fr->callno);						if (iaxs[fr->callno]) {							if (iaxs[fr->callno]->owner) {								struct ast_format_cap *orignative = ast_format_cap_dup(ast_channel_nativeformats(iaxs[fr->callno]->owner));								struct ast_format_cap *native = ast_channel_nativeformats(iaxs[fr->callno]->owner);								if (orignative) {									ast_format_cap_set(native, &f.subclass.format);									if (ast_channel_readformat(iaxs[fr->callno]->owner)->id) {										ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));									}									ast_format_cap_copy(native, orignative);									ast_channel_unlock(iaxs[fr->callno]->owner);									orignative = ast_format_cap_destroy(orignative);								}							}						} else {							ast_debug(1, "Neat, somebody took away the channel at a magical time but i found it!\n");							/* Free remote variables (if any) */							if (ies.vars) {								ast_variables_destroy(ies.vars);								ast_debug(1, "I can haz iaxvars, but they is no good.  :-(\n");								ies.vars = NULL;							}							ast_mutex_unlock(&iaxsl[fr->callno]);							return 1;						}					}			}		}		if (f.frametype == AST_FRAME_VIDEO) {			if (f.subclass.format.id != ast_format_id_from_old_bitfield(iaxs[fr->callno]->videoformat)) {				ast_debug(1, "Ooh, video format changed to %s\n", ast_getformatname(&f.subclass.format));				iaxs[fr->callno]->videoformat = ast_format_to_old_bitfield(&f.subclass.format);			}		}		if (f.frametype == AST_FRAME_CONTROL && iaxs[fr->callno]->owner) {			if (f.subclass.integer == AST_CONTROL_BUSY) {				ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_BUSY);			} else if (f.subclass.integer == AST_CONTROL_CONGESTION) {				ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_CONGESTION);			}		}		if (f.frametype == AST_FRAME_IAX) {			AST_SCHED_DEL(sched, iaxs[fr->callno]->initid);			/* Handle the IAX pseudo frame itself */			if (iaxdebug)				ast_debug(1, "IAX subclass %d received\n", f.subclass.integer);                        /* Update last ts unless the frame's timestamp originated with us. */			if (iaxs[fr->callno]->last < fr->ts &&                            f.subclass.integer != IAX_COMMAND_ACK &&                            f.subclass.integer != IAX_COMMAND_PONG &&                            f.subclass.integer != IAX_COMMAND_LAGRP) {				iaxs[fr->callno]->last = fr->ts;				if (iaxdebug)					ast_debug(1, "For call=%d, set last=%d\n", fr->callno, fr->ts);			}			iaxs[fr->callno]->last_iax_message = f.subclass.integer;			if (!iaxs[fr->callno]->first_iax_message) {				iaxs[fr->callno]->first_iax_message = f.subclass.integer;			}			switch(f.subclass.integer) {			case IAX_COMMAND_ACK:				/* Do nothing */				break;			case IAX_COMMAND_QUELCH:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {				        /* Generate Manager Hold event, if necessary*/					if (iaxs[fr->callno]->owner) {						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: On\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}					ast_set_flag64(iaxs[fr->callno], IAX_QUELCH);					if (ies.musiconhold) {						iax2_lock_owner(fr->callno);						if (!iaxs[fr->callno] || !iaxs[fr->callno]->owner) {							break;						}						if (ast_bridged_channel(iaxs[fr->callno]->owner)) {							const char *moh_suggest = iaxs[fr->callno]->mohsuggest;							/*							 * We already hold the owner lock so we do not							 * need to check iaxs[fr->callno] after it returns.							 */							iax2_queue_control_data(fr->callno, AST_CONTROL_HOLD, 								S_OR(moh_suggest, NULL),								!ast_strlen_zero(moh_suggest) ? strlen(moh_suggest) + 1 : 0);						}						ast_channel_unlock(iaxs[fr->callno]->owner);					}				}				break;			case IAX_COMMAND_UNQUELCH:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {					iax2_lock_owner(fr->callno);					if (!iaxs[fr->callno]) {						break;					}					/* Generate Manager Unhold event, if necessary */					if (iaxs[fr->callno]->owner && ast_test_flag64(iaxs[fr->callno], IAX_QUELCH)) {						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: Off\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}					ast_clear_flag64(iaxs[fr->callno], IAX_QUELCH);					if (!iaxs[fr->callno]->owner) {						break;					}					if (ast_bridged_channel(iaxs[fr->callno]->owner)) {						/*						 * We already hold the owner lock so we do not						 * need to check iaxs[fr->callno] after it returns.						 */						iax2_queue_control_data(fr->callno, AST_CONTROL_UNHOLD, NULL, 0);					}					ast_channel_unlock(iaxs[fr->callno]->owner);				}				break;			case IAX_COMMAND_TXACC:				if (iaxs[fr->callno]->transferring == TRANSFER_BEGIN) {					/* Ack the packet with the given timestamp */					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* Cancel any outstanding txcnt's */						if (cur->transfer) {							cur->retries = -1;						}					}					memset(&ied1, 0, sizeof(ied1));					iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->callno);					send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREADY, 0, ied1.buf, ied1.pos, -1);					iaxs[fr->callno]->transferring = TRANSFER_READY;				}				break;			case IAX_COMMAND_NEW:				/* Ignore if it's already up */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD))					break;				if (ies.provverpres && ies.serviceident && sin.sin_addr.s_addr) {					ast_mutex_unlock(&iaxsl[fr->callno]);					check_provisioning(&sin, fd, ies.serviceident, ies.provver);					ast_mutex_lock(&iaxsl[fr->callno]);					if (!iaxs[fr->callno]) {						break;					}				}				/* If we're in trunk mode, do it now, and update the trunk number in our frame before continuing */				if (ast_test_flag64(iaxs[fr->callno], IAX_TRUNK)) {					int new_callno;					if ((new_callno = make_trunk(fr->callno, 1)) != -1)						fr->callno = new_callno;				}				/* For security, always ack immediately */				if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				if (check_access(fr->callno, &sin, &ies)) {					/* They're not allowed on */					auth_fail(fr->callno, IAX_COMMAND_REJECT);					if (authdebug)						ast_log(LOG_NOTICE, "Rejected connect attempt from %s, who was trying to reach '%s@%s'\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					break;				}				if (ast_strlen_zero(iaxs[fr->callno]->secret) && ast_test_flag64(iaxs[fr->callno], IAX_FORCE_ENCRYPT)) {					auth_fail(fr->callno, IAX_COMMAND_REJECT);					ast_log(LOG_WARNING, "Rejected connect attempt.  No secret present while force encrypt enabled.\n");					break;				}				if (strcasecmp(iaxs[fr->callno]->exten, "TBD")) {					const char *context, *exten, *cid_num;					context = ast_strdupa(iaxs[fr->callno]->context);					exten = ast_strdupa(iaxs[fr->callno]->exten);					cid_num = ast_strdupa(iaxs[fr->callno]->cid_num);					/* This might re-enter the IAX code and need the lock */					ast_mutex_unlock(&iaxsl[fr->callno]);					exists = ast_exists_extension(NULL, context, exten, 1, cid_num);					ast_mutex_lock(&iaxsl[fr->callno]);					if (!iaxs[fr->callno]) {						break;					}				} else					exists = 0;				/* Get OSP token if it does exist */				save_osptoken(fr, &ies);				if (ast_strlen_zero(iaxs[fr->callno]->secret) && ast_strlen_zero(iaxs[fr->callno]->inkeys)) {					if (strcmp(iaxs[fr->callno]->exten, "TBD") && !exists) {						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}						if (authdebug)							ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					} else {						/* Select an appropriate format */						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								using_prefs = "reqonly";							} else {								using_prefs = "disabled";							}							format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;							memset(&pref, 0, sizeof(pref));							strcpy(caller_pref_buf, "disabled");							strcpy(host_pref_buf, "disabled");						} else {							struct ast_format tmpfmt;							using_prefs = "mine";							/* If the information elements are in here... use them */							if (ies.codec_prefs)								ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);							if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {								/* If we are codec_first_choice we let the caller have the 1st shot at picking the codec.*/								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {									pref = iaxs[fr->callno]->rprefs;									using_prefs = "caller";								} else {									pref = iaxs[fr->callno]->prefs;								}							} else								pref = iaxs[fr->callno]->prefs;							format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);							ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);							ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);						}						if (!format) {							if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP))								format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;							if (!format) {								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}								if (authdebug) {									char tmp[256], tmp2[256], tmp3[256];									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}							} else {								/* Pick one... */								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))										format = 0;								} else {									if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {										using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";										memset(&pref, 0, sizeof(pref));										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);										strcpy(caller_pref_buf,"disabled");										strcpy(host_pref_buf,"disabled");									} else {										struct ast_format tmpfmt;										using_prefs = "mine";										if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {											/* Do the opposite of what we tried above. */											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);										} else /* if no codec_prefs IE do it the old way */											format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}								}								if (!format) {									char tmp[256], tmp2[256], tmp3[256];									memset(&ied0, 0, sizeof(ied0));									iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");									iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);									ast_log(LOG_ERROR, "No best format in '%s'???\n", iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));									send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);									if (!iaxs[fr->callno]) {										break;									}									if (authdebug) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}									ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);									break;								}							}						}						if (format) {							/* No authentication required, let them in */							memset(&ied1, 0, sizeof(ied1));							iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);							iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);							send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);							if (strcmp(iaxs[fr->callno]->exten, "TBD")) {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);								ast_verb(3, "Accepting UNAUTHENTICATED call from %s:\n"												"%srequested format = %s,\n"												"%srequested prefs = %s,\n"												"%sactual format = %s,\n"												"%shost prefs = %s,\n"												"%spriority = %s\n",												ast_inet_ntoa(sin.sin_addr), 												VERBOSE_PREFIX_4,												iax2_getformatname(iaxs[fr->callno]->peerformat), 												VERBOSE_PREFIX_4,												caller_pref_buf,												VERBOSE_PREFIX_4,												iax2_getformatname(format), 												VERBOSE_PREFIX_4,												host_pref_buf, 												VERBOSE_PREFIX_4,												using_prefs);								iaxs[fr->callno]->chosenformat = format;								/* Since this is a new call, we should go ahead and set the callid for it. */								iax_pvt_callid_new(fr->callno);								ast_set_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);							} else {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);								/* If this is a TBD call, we're ready but now what...  */								ast_verb(3, "Accepted unauthenticated TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							}						}					}					break;				}				if (iaxs[fr->callno]->authmethods & IAX_AUTH_MD5)					merge_encryption(iaxs[fr->callno],ies.encmethods);				else					iaxs[fr->callno]->encmethods = 0;				if (!authenticate_request(fr->callno) && iaxs[fr->callno])					ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED);				break;			case IAX_COMMAND_DPREQ:				/* Request status in the dialplan */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD) &&					!ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED) && ies.called_number) {					if (iaxcompat) {						/* Spawn a thread for the lookup */						spawn_dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num);					} else {						/* Just look it up */						dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num, 1);					}				}				break;			case IAX_COMMAND_HANGUP:				ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);				ast_debug(1, "Immediately destroying %d, having received hangup\n", fr->callno);				/* Set hangup cause according to remote and hangupsource */				if (iaxs[fr->callno]->owner) {					set_hangup_source_and_cause(fr->callno, ies.causecode);					if (!iaxs[fr->callno]) {						break;					}				}				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_REJECT:				/* Set hangup cause according to remote and hangup source */				if (iaxs[fr->callno]->owner) {					set_hangup_source_and_cause(fr->callno, ies.causecode);					if (!iaxs[fr->callno]) {						break;					}				}				if (!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)) {					if (iaxs[fr->callno]->owner && authdebug)						ast_log(LOG_WARNING, "Call rejected by %s: %s\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr),							ies.cause ? ies.cause : "<Unknown>");					ast_debug(1, "Immediately destroying %d, having received reject\n",						fr->callno);				}				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK,						       fr->ts, NULL, 0, fr->iseqno);				if (!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION))					iaxs[fr->callno]->error = EPERM;				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_TRANSFER:			{				struct ast_channel *bridged_chan;				struct ast_channel *owner;				iax2_lock_owner(fr->callno);				if (!iaxs[fr->callno]) {					/* Initiating call went away before we could transfer. */					break;				}				owner = iaxs[fr->callno]->owner;				bridged_chan = owner ? ast_bridged_channel(owner) : NULL;				if (bridged_chan && ies.called_number) {					const char *context;					context = ast_strdupa(iaxs[fr->callno]->context);					ast_channel_ref(owner);					ast_channel_ref(bridged_chan);					ast_channel_unlock(owner);					ast_mutex_unlock(&iaxsl[fr->callno]);					/* Set BLINDTRANSFER channel variables */					pbx_builtin_setvar_helper(owner, "BLINDTRANSFER", ast_channel_name(bridged_chan));					pbx_builtin_setvar_helper(bridged_chan, "BLINDTRANSFER", ast_channel_name(owner));					/* DO NOT hold any locks while calling ast_parking_ext_valid() */					if (ast_parking_ext_valid(ies.called_number, owner, context)) {						ast_debug(1, "Parking call '%s'\n", ast_channel_name(bridged_chan));						if (iax_park(bridged_chan, owner, ies.called_number, context)) {							ast_log(LOG_WARNING, "Failed to park call '%s'\n",								ast_channel_name(bridged_chan));						}					} else {						if (ast_async_goto(bridged_chan, context, ies.called_number, 1)) {							ast_log(LOG_WARNING,								"Async goto of '%s' to '%s@%s' failed\n",								ast_channel_name(bridged_chan), ies.called_number, context);						} else {							ast_debug(1, "Async goto of '%s' to '%s@%s' started\n",								ast_channel_name(bridged_chan), ies.called_number, context);						}					}					ast_channel_unref(owner);					ast_channel_unref(bridged_chan);					ast_mutex_lock(&iaxsl[fr->callno]);				} else {					ast_debug(1, "Async goto not applicable on call %d\n", fr->callno);					if (owner) {						ast_channel_unlock(owner);					}				}				break;			}			case IAX_COMMAND_ACCEPT:				/* Ignore if call is already up or needs authentication or is a TBD */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD | IAX_STATE_AUTHENTICATED))					break;				if (ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)) {					/* Send ack immediately, before we destroy */					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					iax2_destroy(fr->callno);					break;				}				if (ies.format) {					iaxs[fr->callno]->peerformat = ies.format;				} else {					if (iaxs[fr->callno]->owner)						iaxs[fr->callno]->peerformat = ast_format_cap_to_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner));					else						iaxs[fr->callno]->peerformat = iaxs[fr->callno]->capability;				}				ast_verb(3, "Call accepted by %s (format %s)\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iax2_getformatname(iaxs[fr->callno]->peerformat));				if (!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)) {					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);					if (!iaxs[fr->callno]) {						break;					}					if (authdebug) {						char tmp1[256], tmp2[256];						ast_log(LOG_NOTICE, "Rejected call to %s, format %s incompatible with our capability %s.\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),							iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));					}				} else {					ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);					iax2_lock_owner(fr->callno);					if (iaxs[fr->callno] && iaxs[fr->callno]->owner) {						char tmp[256];						/* Switch us to use a compatible format */						ast_format_cap_from_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner), iaxs[fr->callno]->peerformat);						ast_verb(3, "Format for call is %s\n", ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(iaxs[fr->callno]->owner)));						/* Setup read/write formats properly. */						if (ast_channel_writeformat(iaxs[fr->callno]->owner)->id)							ast_set_write_format(iaxs[fr->callno]->owner, ast_channel_writeformat(iaxs[fr->callno]->owner));						if (ast_channel_readformat(iaxs[fr->callno]->owner)->id)							ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));						ast_channel_unlock(iaxs[fr->callno]->owner);					}				}				if (iaxs[fr->callno]) {					AST_LIST_LOCK(&dpcache);					AST_LIST_TRAVERSE(&iaxs[fr->callno]->dpentries, dp, peer_list)						if (!(dp->flags & CACHE_FLAG_TRANSMITTED))							iax2_dprequest(dp, fr->callno);					AST_LIST_UNLOCK(&dpcache);				}				break;			case IAX_COMMAND_POKE:				/* Send back a pong packet with the original timestamp */				send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, NULL, 0, -1);				break;			case IAX_COMMAND_PING:			{				struct iax_ie_data pingied;				construct_rr(iaxs[fr->callno], &pingied);				/* Send back a pong packet with the original timestamp */				send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, pingied.buf, pingied.pos, -1);			}				break;			case IAX_COMMAND_PONG:				/* Calculate ping time */				iaxs[fr->callno]->pingtime =  calc_timestamp(iaxs[fr->callno], 0, &f) - fr->ts;				/* save RR info */				save_rr(fr, &ies);				/* Good time to write jb stats for this call */				log_jitterstats(fr->callno);				if (iaxs[fr->callno]->peerpoke) {					peer = iaxs[fr->callno]->peerpoke;					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms)) {						if (iaxs[fr->callno]->pingtime <= peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now REACHABLE! Time: %d\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Reachable\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_NOT_INUSE, "IAX2/%s", peer->name); /* Activate notification */						}					} else if ((peer->historicms > 0) && (peer->historicms <= peer->maxms)) {						if (iaxs[fr->callno]->pingtime > peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now TOO LAGGED (%d ms)!\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Lagged\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_UNAVAILABLE, "IAX2/%s", peer->name); /* Activate notification */						}					}					peer->lastms = iaxs[fr->callno]->pingtime;					if (peer->smoothing && (peer->lastms > -1))						peer->historicms = (iaxs[fr->callno]->pingtime + peer->historicms) / 2;					else if (peer->smoothing && peer->lastms < 0)						peer->historicms = (0 + peer->historicms) / 2;					else											peer->historicms = iaxs[fr->callno]->pingtime;					/* Remove scheduled iax2_poke_noanswer */					if (peer->pokeexpire > -1) {						if (!AST_SCHED_DEL(sched, peer->pokeexpire)) {							peer_unref(peer);							peer->pokeexpire = -1;						}					}					/* Schedule the next cycle */					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms))						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_peer_s, peer_ref(peer));					else						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqok, iax2_poke_peer_s, peer_ref(peer));					if (peer->pokeexpire == -1)						peer_unref(peer);					/* and finally send the ack */					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					/* And wrap up the qualify call */					iax2_destroy(fr->callno);					peer->callno = 0;					ast_debug(1, "Peer %s: got pong, lastms %d, historicms %d, maxms %d\n", peer->name, peer->lastms, peer->historicms, peer->maxms);				}				break;			case IAX_COMMAND_LAGRQ:			case IAX_COMMAND_LAGRP:				f.src = "LAGRQ";				f.mallocd = 0;				f.offset = 0;				f.samples = 0;				iax_frame_wrap(fr, &f);				if (f.subclass.integer == IAX_COMMAND_LAGRQ) {					/* Received a LAGRQ - echo back a LAGRP */					fr->af.subclass.integer = IAX_COMMAND_LAGRP;					iax2_send(iaxs[fr->callno], &fr->af, fr->ts, -1, 0, 0, 0);				} else {					/* Received LAGRP in response to our LAGRQ */					unsigned int ts;					/* This is a reply we've been given, actually measure the difference */					ts = calc_timestamp(iaxs[fr->callno], 0, &fr->af);					iaxs[fr->callno]->lag = ts - fr->ts;					if (iaxdebug)						ast_debug(1, "Peer %s lag measured as %dms\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->lag);				}				break;			case IAX_COMMAND_AUTHREQ:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)) {					ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					break;				}				if (authenticate_reply(iaxs[fr->callno], &iaxs[fr->callno]->addr, &ies, iaxs[fr->callno]->secret, iaxs[fr->callno]->outkey)) {					struct ast_frame hangup_fr = { .frametype = AST_FRAME_CONTROL,								.subclass.integer = AST_CONTROL_HANGUP,					};					ast_log(LOG_WARNING, 						"I don't know how to authenticate %s to %s\n", 						ies.username ? ies.username : "<unknown>", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr));					iax2_queue_frame(fr->callno, &hangup_fr);				}				break;			case IAX_COMMAND_AUTHREP:				/* For security, always ack immediately */				if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				/* Ignore once we've started */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)) {					ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					break;				}				if (authenticate_verify(iaxs[fr->callno], &ies)) {					if (authdebug)						ast_log(LOG_NOTICE, "Host %s failed to authenticate as %s\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->username);					memset(&ied0, 0, sizeof(ied0));					auth_fail(fr->callno, IAX_COMMAND_REJECT);					break;				}				if (strcasecmp(iaxs[fr->callno]->exten, "TBD")) {					/* This might re-enter the IAX code and need the lock */					exists = ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num);				} else					exists = 0;				if (strcmp(iaxs[fr->callno]->exten, "TBD") && !exists) {					if (authdebug)						ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);					if (!iaxs[fr->callno]) {						break;					}				} else {					/* Select an appropriate format */					if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {							using_prefs = "reqonly";						} else {							using_prefs = "disabled";						}						format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;						memset(&pref, 0, sizeof(pref));						strcpy(caller_pref_buf, "disabled");						strcpy(host_pref_buf, "disabled");					} else {						struct ast_format tmpfmt;						using_prefs = "mine";						if (ies.codec_prefs)							ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);						if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {							if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {								pref = iaxs[fr->callno]->rprefs;								using_prefs = "caller";							} else {								pref = iaxs[fr->callno]->prefs;							}						} else /* if no codec_prefs IE do it the old way */							pref = iaxs[fr->callno]->prefs;						format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);						ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);						ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);					}					if (!format) {						char tmp1[256], tmp2[256], tmp3[256];						if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {							ast_debug(1, "We don't do requested format %s, falling back to peer capability '%s'\n",								iax2_getformatname(iaxs[fr->callno]->peerformat),								iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability));							format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;						}						if (!format) {							if (authdebug) {								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n", ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));								} else {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",										ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),										iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));								}							}							memset(&ied0, 0, sizeof(ied0));							iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");							iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);							send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);							if (!iaxs[fr->callno]) {								break;							}						} else {							/* Pick one... */							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))									format = 0;							} else {								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {									using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";									memset(&pref, 0, sizeof(pref));									format = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ?										iaxs[fr->callno]->peerformat : iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									strcpy(caller_pref_buf,"disabled");									strcpy(host_pref_buf,"disabled");								} else {									struct ast_format tmpfmt;									using_prefs = "mine";									if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {										/* Do the opposite of what we tried above. */										if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {											pref = iaxs[fr->callno]->prefs;										} else {											pref = iaxs[fr->callno]->rprefs;											using_prefs = "caller";										}										format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);									} else /* if no codec_prefs IE do it the old way */										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}							}							if (!format) {								char tmp1[256], tmp2[256], tmp3[256];								ast_log(LOG_ERROR, "No best format in %s???\n",									iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));								if (authdebug) {									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}							}						}					}					if (format) {						/* Authentication received */						memset(&ied1, 0, sizeof(ied1));						iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);						iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);						send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);						if (strcmp(iaxs[fr->callno]->exten, "TBD")) {							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							ast_verb(3, "Accepting AUTHENTICATED call from %s:\n"											"%srequested format = %s,\n"											"%srequested prefs = %s,\n"											"%sactual format = %s,\n"											"%shost prefs = %s,\n"											"%spriority = %s\n", 											ast_inet_ntoa(sin.sin_addr), 											VERBOSE_PREFIX_4,											iax2_getformatname(iaxs[fr->callno]->peerformat),											VERBOSE_PREFIX_4,											caller_pref_buf,											VERBOSE_PREFIX_4,											iax2_getformatname(format),											VERBOSE_PREFIX_4,											host_pref_buf,											VERBOSE_PREFIX_4,											using_prefs);							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, format, NULL)))								iax2_destroy(fr->callno);							else if (ies.vars) {								struct ast_datastore *variablestore;								struct ast_variable *var, *prev = NULL;								AST_LIST_HEAD(, ast_var_t) *varlist;								varlist = ast_calloc(1, sizeof(*varlist));								variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);								if (variablestore && varlist) {									variablestore->data = varlist;									variablestore->inheritance = DATASTORE_INHERIT_FOREVER;									AST_LIST_HEAD_INIT(varlist);									ast_debug(1, "I can haz IAX vars? w00t\n");									for (var = ies.vars; var; var = var->next) {										struct ast_var_t *newvar = ast_var_assign(var->name, var->value);										if (prev)											ast_free(prev);										prev = var;										if (!newvar) {											/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */											ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");										} else {											AST_LIST_INSERT_TAIL(varlist, newvar, entries);										}									}									if (prev)										ast_free(prev);									ies.vars = NULL;									ast_channel_datastore_add(c, variablestore);								} else {									ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									if (variablestore)										ast_datastore_free(variablestore);									if (varlist)										ast_free(varlist);								}							}						} else {							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);							/* If this is a TBD call, we're ready but now what...  */							ast_verb(3, "Accepted AUTHENTICATED TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							if (ast_test_flag64(iaxs[fr->callno], IAX_IMMEDIATE)) {								goto immediatedial;							}						}					}				}				break;			case IAX_COMMAND_DIAL:immediatedial:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD)) {					ast_clear_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);					ast_string_field_set(iaxs[fr->callno], exten, ies.called_number ? ies.called_number : "s");					if (!ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num)) {						if (authdebug)							ast_log(LOG_NOTICE, "Rejected dial attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}					} else {						char tmp[256];						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);						ast_verb(3, "Accepting DIAL from %s, formats = %s\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat));						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);						send_command(iaxs[fr->callno], AST_FRAME_CONTROL, AST_CONTROL_PROGRESS, 0, NULL, 0, -1);						if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->peerformat, NULL)))							iax2_destroy(fr->callno);						else if (ies.vars) {							struct ast_datastore *variablestore;							struct ast_variable *var, *prev = NULL;							AST_LIST_HEAD(, ast_var_t) *varlist;							varlist = ast_calloc(1, sizeof(*varlist));							variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);							ast_debug(1, "I can haz IAX vars? w00t\n");							if (variablestore && varlist) {								variablestore->data = varlist;								variablestore->inheritance = DATASTORE_INHERIT_FOREVER;								AST_LIST_HEAD_INIT(varlist);								for (var = ies.vars; var; var = var->next) {									struct ast_var_t *newvar = ast_var_assign(var->name, var->value);									if (prev)										ast_free(prev);									prev = var;									if (!newvar) {										/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */										ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									} else {										AST_LIST_INSERT_TAIL(varlist, newvar, entries);									}								}								if (prev)									ast_free(prev);								ies.vars = NULL;								ast_channel_datastore_add(c, variablestore);							} else {								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");								if (variablestore)									ast_datastore_free(variablestore);								if (varlist)									ast_free(varlist);							}						}					}				}				break;			case IAX_COMMAND_INVAL:				iaxs[fr->callno]->error = ENOTCONN;				ast_debug(1, "Immediately destroying %d, having received INVAL\n", fr->callno);				iax2_destroy(fr->callno);				ast_debug(1, "Destroying call %d\n", fr->callno);				break;			case IAX_COMMAND_VNAK:				ast_debug(1, "Received VNAK: resending outstanding frames\n");				/* Force retransmission */				vnak_retransmit(fr->callno, fr->iseqno);				break;			case IAX_COMMAND_REGREQ:			case IAX_COMMAND_REGREL:				/* For security, always ack immediately */				if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				if (register_verify(fr->callno, &sin, &ies)) {					if (!iaxs[fr->callno]) {						break;					}					/* Send delayed failure */					auth_fail(fr->callno, IAX_COMMAND_REGREJ);					break;				}				if (!iaxs[fr->callno]) {					break;				}				if ((ast_strlen_zero(iaxs[fr->callno]->secret) && ast_strlen_zero(iaxs[fr->callno]->inkeys)) ||						ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED)) {					if (f.subclass.integer == IAX_COMMAND_REGREL) {						memset(&sin, 0, sizeof(sin));						sin.sin_family = AF_INET;					}					if (update_registry(&sin, fr->callno, ies.devicetype, fd, ies.refresh)) {						ast_log(LOG_WARNING, "Registry error\n");					}					if (!iaxs[fr->callno]) {						break;					}					if (ies.provverpres && ies.serviceident && sin.sin_addr.s_addr) {						ast_mutex_unlock(&iaxsl[fr->callno]);						check_provisioning(&sin, fd, ies.serviceident, ies.provver);						ast_mutex_lock(&iaxsl[fr->callno]);					}					break;				}				registry_authrequest(fr->callno);				break;			case IAX_COMMAND_REGACK:				if (iax2_ack_registry(&ies, &sin, fr->callno)) 					ast_log(LOG_WARNING, "Registration failure\n");				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_REGREJ:				if (iaxs[fr->callno]->reg) {					if (authdebug) {						ast_log(LOG_NOTICE, "Registration of '%s' rejected: '%s' from: '%s'\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>", ast_inet_ntoa(sin.sin_addr));						manager_event(EVENT_FLAG_SYSTEM, "Registry", "ChannelType: IAX2\r\nUsername: %s\r\nStatus: Rejected\r\nCause: %s\r\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>");					}					iaxs[fr->callno]->reg->regstate = REG_STATE_REJECTED;				}				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_REGAUTH:				/* Authentication request */				if (registry_rerequest(&ies, fr->callno, &sin)) {					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No authority found");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_FACILITY_NOT_SUBSCRIBED);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);				}				break;			case IAX_COMMAND_TXREJ:				iaxs[fr->callno]->transferring = 0;				ast_verb(3, "Channel '%s' unable to transfer\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");				memset(&iaxs[fr->callno]->transfer, 0, sizeof(iaxs[fr->callno]->transfer));				if (iaxs[fr->callno]->bridgecallno) {					if (iaxs[iaxs[fr->callno]->bridgecallno]->transferring) {						iaxs[iaxs[fr->callno]->bridgecallno]->transferring = 0;						send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREJ, 0, NULL, 0, -1);					}				}				break;			case IAX_COMMAND_TXREADY:				if ((iaxs[fr->callno]->transferring == TRANSFER_BEGIN) ||				    (iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)) {					if (iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)						iaxs[fr->callno]->transferring = TRANSFER_MREADY;					else						iaxs[fr->callno]->transferring = TRANSFER_READY;					ast_verb(3, "Channel '%s' ready to transfer\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					if (iaxs[fr->callno]->bridgecallno) {						if ((iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_READY) ||						    (iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_MREADY)) {							/* They're both ready, now release them. */							if (iaxs[fr->callno]->transferring == TRANSFER_MREADY) {								ast_verb(3, "Attempting media bridge of %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_MEDIA;								iaxs[fr->callno]->transferring = TRANSFER_MEDIA;								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied1.buf, ied1.pos, -1);							} else {								ast_verb(3, "Releasing %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_RELEASED;								iaxs[fr->callno]->transferring = TRANSFER_RELEASED;								ast_set_flag64(iaxs[iaxs[fr->callno]->bridgecallno], IAX_ALREADYGONE);								ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);								/* Stop doing lag & ping requests */								stop_stuff(fr->callno);								stop_stuff(iaxs[fr->callno]->bridgecallno);								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied1.buf, ied1.pos, -1);							}						}					}				}				break;			case IAX_COMMAND_TXREQ:				try_transfer(iaxs[fr->callno], &ies);				break;			case IAX_COMMAND_TXCNT:				if (iaxs[fr->callno]->transferring)					send_command_transfer(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXACC, 0, NULL, 0);				break;			case IAX_COMMAND_TXREL:				/* Send ack immediately, rather than waiting until we've changed addresses */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				complete_transfer(fr->callno, &ies);				stop_stuff(fr->callno);	/* for attended transfer to work with libiax */				break;				case IAX_COMMAND_TXMEDIA:				if (iaxs[fr->callno]->transferring == TRANSFER_READY) {					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* Cancel any outstanding frames and start anew */						if (cur->transfer) {							cur->retries = -1;						}					}					/* Start sending our media to the transfer address, but otherwise leave the call as-is */					iaxs[fr->callno]->transferring = TRANSFER_MEDIAPASS;				}				break;			case IAX_COMMAND_RTKEY:				if (!IAX_CALLENCRYPTED(iaxs[fr->callno])) {					ast_log(LOG_WARNING, 						"we've been told to rotate our encryption key, "						"but this isn't an encrypted call. bad things will happen.\n"					);					break;				}				IAX_DEBUGDIGEST("Receiving", ies.challenge);				ast_aes_set_decrypt_key((unsigned char *) ies.challenge, &iaxs[fr->callno]->dcx);				break;			case IAX_COMMAND_DPREP:				complete_dpreply(iaxs[fr->callno], &ies);				break;			case IAX_COMMAND_UNSUPPORT:				ast_log(LOG_NOTICE, "Peer did not understand our iax command '%d'\n", ies.iax_unknown);				break;			case IAX_COMMAND_FWDOWNL:				/* Firmware download */				if (!ast_test_flag64(&globalflags, IAX_ALLOWFWDOWNLOAD)) {					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_UNSUPPORT, 0, NULL, 0, -1);					break;				}				memset(&ied0, 0, sizeof(ied0));				res = iax_firmware_append(&ied0, (unsigned char *)ies.devicetype, ies.fwdesc);				if (res < 0)					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);				else if (res > 0)					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1);				else					send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1);				break;			case IAX_COMMAND_CALLTOKEN:			{				struct iax_frame *cur;				/* find last sent frame */				if ((cur = AST_LIST_LAST(&frame_queue[fr->callno])) && ies.calltoken && ies.calltokendata) {					resend_with_token(fr->callno, cur, (char *) ies.calltokendata);				}				break;			}			default:				ast_debug(1, "Unknown IAX command %d on %d/%d\n", f.subclass.integer, fr->callno, iaxs[fr->callno]->peercallno);				memset(&ied0, 0, sizeof(ied0));				iax_ie_append_byte(&ied0, IAX_IE_IAX_UNKNOWN, f.subclass.integer);				send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_UNSUPPORT, 0, ied0.buf, ied0.pos, -1);			}			/* Free remote variables (if any) */			if (ies.vars) {				ast_variables_destroy(ies.vars);				ast_debug(1, "I can haz IAX vars, but they is no good :-(\n");				ies.vars = NULL;			}			/* Don't actually pass these frames along */			if ((f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&			  (f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_INVAL) &&			  (f.subclass.integer != IAX_COMMAND_VNAK)) {				if (iaxs[fr->callno] && iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);			}			ast_mutex_unlock(&iaxsl[fr->callno]);			return 1;		}
ntohs(mh->callno) & IAX_FLAG_FULL
ntohs(mh->callno)
ntohs
ntohs
mh->callno
mh
mh
callno
IAX_FLAG_FULL
IAX_FLAG_FULL
{		if (iaxdebug)			ast_debug(1, "Received packet %d, (%d, %u)\n", fh->oseqno, f.frametype, f.subclass.integer);		/* Check if it's out of order (and not an ACK or INVAL) */		fr->oseqno = fh->oseqno;		fr->iseqno = fh->iseqno;		fr->ts = ntohl(fh->ts);#ifdef IAXTESTS		if (test_resync) {			ast_debug(1, "Simulating frame ts resync, was %u now %u\n", fr->ts, fr->ts + test_resync);			fr->ts += test_resync;		}#endif /* IAXTESTS */#if 0		if ( (ntohs(fh->dcallno) & IAX_FLAG_RETRANS) ||		     ( (f.frametype != AST_FRAME_VOICE) && ! (f.frametype == AST_FRAME_IAX &&								(f.subclass == IAX_COMMAND_NEW ||								 f.subclass == IAX_COMMAND_AUTHREQ ||								 f.subclass == IAX_COMMAND_ACCEPT ||								 f.subclass == IAX_COMMAND_REJECT))      ) )#endif		if ((ntohs(fh->dcallno) & IAX_FLAG_RETRANS) || (f.frametype != AST_FRAME_VOICE))			updatehistory = 0;		if ((iaxs[fr->callno]->iseqno != fr->oseqno) &&			(iaxs[fr->callno]->iseqno ||				((f.subclass.integer != IAX_COMMAND_TXCNT) &&				(f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXACC)) ||				(f.frametype != AST_FRAME_IAX))) {			if (			 ((f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_INVAL) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&			  (f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_VNAK)) ||			  (f.frametype != AST_FRAME_IAX)) {				/* If it's not an ACK packet, it's out of order. */				ast_debug(1, "Packet arrived out of order (expecting %d, got %d) (frametype = %d, subclass = %d)\n",					iaxs[fr->callno]->iseqno, fr->oseqno, f.frametype, f.subclass.integer);				/* Check to see if we need to request retransmission,				 * and take sequence number wraparound into account */				if ((unsigned char) (iaxs[fr->callno]->iseqno - fr->oseqno) < 128) {					/* If we've already seen it, ack it XXX There's a border condition here XXX */					if ((f.frametype != AST_FRAME_IAX) ||							((f.subclass.integer != IAX_COMMAND_ACK) && (f.subclass.integer != IAX_COMMAND_INVAL))) {						ast_debug(1, "Acking anyway\n");						/* XXX Maybe we should handle its ack to us, but then again, it's probably outdated anyway, and if						   we have anything to send, we'll retransmit and get an ACK back anyway XXX */						send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					}				} else {					/* Send a VNAK requesting retransmission */					iax2_vnak(fr->callno);				}				ast_variables_destroy(ies.vars);				ast_mutex_unlock(&iaxsl[fr->callno]);				return 1;			}		} else {			/* Increment unless it's an ACK or VNAK */			if (((f.subclass.integer != IAX_COMMAND_ACK) &&			    (f.subclass.integer != IAX_COMMAND_INVAL) &&			    (f.subclass.integer != IAX_COMMAND_TXCNT) &&			    (f.subclass.integer != IAX_COMMAND_TXACC) &&				(f.subclass.integer != IAX_COMMAND_VNAK)) ||			    (f.frametype != AST_FRAME_IAX))				iaxs[fr->callno]->iseqno++;		}		/* Ensure text frames are NULL-terminated */		if (f.frametype == AST_FRAME_TEXT && thread->buf[res - 1] != '\0') {			if (res < thread->buf_size)				thread->buf[res++] = '\0';			else /* Trims one character from the text message, but that's better than overwriting the end of the buffer. */				thread->buf[res - 1] = '\0';		}		/* Handle implicit ACKing unless this is an INVAL, and only if this is 		   from the real peer, not the transfer peer */		if (!inaddrcmp(&sin, &iaxs[fr->callno]->addr) &&		    ((f.subclass.integer != IAX_COMMAND_INVAL) ||		     (f.frametype != AST_FRAME_IAX))) {			unsigned char x;			int call_to_destroy;			/* First we have to qualify that the ACKed value is within our window */			if (iaxs[fr->callno]->rseqno >= iaxs[fr->callno]->oseqno || (fr->iseqno >= iaxs[fr->callno]->rseqno && fr->iseqno < iaxs[fr->callno]->oseqno))				x = fr->iseqno;			else				x = iaxs[fr->callno]->oseqno;			if ((x != iaxs[fr->callno]->oseqno) || (iaxs[fr->callno]->oseqno == fr->iseqno)) {				/* The acknowledgement is within our window.  Time to acknowledge everything				   that it says to */				for (x=iaxs[fr->callno]->rseqno; x != fr->iseqno; x++) {					/* Ack the packet with the given timestamp */					if (iaxdebug)						ast_debug(1, "Cancelling transmission of packet %d\n", x);					call_to_destroy = 0;					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* If it's our call, and our timestamp, mark -1 retries */						if (x == cur->oseqno) {							cur->retries = -1;							/* Destroy call if this is the end */							if (cur->final)								call_to_destroy = fr->callno;						}					}					if (call_to_destroy) {						if (iaxdebug)							ast_debug(1, "Really destroying %d, having been acked on final message\n", call_to_destroy);						ast_mutex_lock(&iaxsl[call_to_destroy]);						iax2_destroy(call_to_destroy);						ast_mutex_unlock(&iaxsl[call_to_destroy]);					}				}				/* Note how much we've received acknowledgement for */				if (iaxs[fr->callno])					iaxs[fr->callno]->rseqno = fr->iseqno;				else {					/* Stop processing now */					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}			} else {				ast_debug(1, "Received iseqno %d not within window %d->%d\n", fr->iseqno, iaxs[fr->callno]->rseqno, iaxs[fr->callno]->oseqno);			}		}		if (inaddrcmp(&sin, &iaxs[fr->callno]->addr) &&			((f.frametype != AST_FRAME_IAX) ||			 ((f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT)))) {			/* Only messages we accept from a transfer host are TXACC and TXCNT */			ast_variables_destroy(ies.vars);			ast_mutex_unlock(&iaxsl[fr->callno]);			return 1;		}		/* when we receive the first full frame for a new incoming channel,		   it is safe to start the PBX on the channel because we have now		   completed a 3-way handshake with the peer */		if ((f.frametype == AST_FRAME_VOICE) ||		    (f.frametype == AST_FRAME_VIDEO) ||		    (f.frametype == AST_FRAME_IAX)) {			if (ast_test_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART)) {				ast_clear_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);				if (!ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->chosenformat, NULL)) {					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}			}			if (ies.vars) {				struct ast_datastore *variablestore = NULL;				struct ast_variable *var, *prev = NULL;				AST_LIST_HEAD(, ast_var_t) *varlist;				iax2_lock_owner(fr->callno);				if (!iaxs[fr->callno]) {					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}				if ((c = iaxs[fr->callno]->owner)) {					varlist = ast_calloc(1, sizeof(*varlist));					variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);					if (variablestore && varlist) {						variablestore->data = varlist;						variablestore->inheritance = DATASTORE_INHERIT_FOREVER;						AST_LIST_HEAD_INIT(varlist);						ast_debug(1, "I can haz IAX vars?\n");						for (var = ies.vars; var; var = var->next) {							struct ast_var_t *newvar = ast_var_assign(var->name, var->value);							if (prev) {								ast_free(prev);							}							prev = var;							if (!newvar) {								/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");							} else {								AST_LIST_INSERT_TAIL(varlist, newvar, entries);							}						}						if (prev) {							ast_free(prev);						}						ies.vars = NULL;						ast_channel_datastore_add(c, variablestore);					} else {						ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");						if (variablestore) {							ast_datastore_free(variablestore);						}						if (varlist) {							ast_free(varlist);						}					}					ast_channel_unlock(c);				} else {					/* No channel yet, so transfer the variables directly over to the pvt,					 * for later inheritance. */					ast_debug(1, "No channel, so populating IAXVARs to the pvt, as an intermediate step.\n");					for (var = ies.vars; var && var->next; var = var->next);					if (var) {						var->next = iaxs[fr->callno]->iaxvars;						iaxs[fr->callno]->iaxvars = ies.vars;						ies.vars = NULL;					}				}			}			if (ies.vars) {				ast_debug(1, "I have IAX variables, but they were not processed\n");			}		}		/* once we receive our first IAX Full Frame that is not CallToken related, send all		 * queued signaling frames that were being held. */		if ((f.frametype == AST_FRAME_IAX) && (f.subclass.integer != IAX_COMMAND_CALLTOKEN) && iaxs[fr->callno]->hold_signaling) {			send_signaling(iaxs[fr->callno]);		}		if (f.frametype == AST_FRAME_VOICE) {			if (ast_format_to_old_bitfield(&f.subclass.format) != iaxs[fr->callno]->voiceformat) {					iaxs[fr->callno]->voiceformat = ast_format_to_old_bitfield(&f.subclass.format);					ast_debug(1, "Ooh, voice format changed to '%s'\n", ast_getformatname(&f.subclass.format));					if (iaxs[fr->callno]->owner) {						iax2_lock_owner(fr->callno);						if (iaxs[fr->callno]) {							if (iaxs[fr->callno]->owner) {								struct ast_format_cap *orignative = ast_format_cap_dup(ast_channel_nativeformats(iaxs[fr->callno]->owner));								struct ast_format_cap *native = ast_channel_nativeformats(iaxs[fr->callno]->owner);								if (orignative) {									ast_format_cap_set(native, &f.subclass.format);									if (ast_channel_readformat(iaxs[fr->callno]->owner)->id) {										ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));									}									ast_format_cap_copy(native, orignative);									ast_channel_unlock(iaxs[fr->callno]->owner);									orignative = ast_format_cap_destroy(orignative);								}							}						} else {							ast_debug(1, "Neat, somebody took away the channel at a magical time but i found it!\n");							/* Free remote variables (if any) */							if (ies.vars) {								ast_variables_destroy(ies.vars);								ast_debug(1, "I can haz iaxvars, but they is no good.  :-(\n");								ies.vars = NULL;							}							ast_mutex_unlock(&iaxsl[fr->callno]);							return 1;						}					}			}		}		if (f.frametype == AST_FRAME_VIDEO) {			if (f.subclass.format.id != ast_format_id_from_old_bitfield(iaxs[fr->callno]->videoformat)) {				ast_debug(1, "Ooh, video format changed to %s\n", ast_getformatname(&f.subclass.format));				iaxs[fr->callno]->videoformat = ast_format_to_old_bitfield(&f.subclass.format);			}		}		if (f.frametype == AST_FRAME_CONTROL && iaxs[fr->callno]->owner) {			if (f.subclass.integer == AST_CONTROL_BUSY) {				ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_BUSY);			} else if (f.subclass.integer == AST_CONTROL_CONGESTION) {				ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_CONGESTION);			}		}		if (f.frametype == AST_FRAME_IAX) {			AST_SCHED_DEL(sched, iaxs[fr->callno]->initid);			/* Handle the IAX pseudo frame itself */			if (iaxdebug)				ast_debug(1, "IAX subclass %d received\n", f.subclass.integer);                        /* Update last ts unless the frame's timestamp originated with us. */			if (iaxs[fr->callno]->last < fr->ts &&                            f.subclass.integer != IAX_COMMAND_ACK &&                            f.subclass.integer != IAX_COMMAND_PONG &&                            f.subclass.integer != IAX_COMMAND_LAGRP) {				iaxs[fr->callno]->last = fr->ts;				if (iaxdebug)					ast_debug(1, "For call=%d, set last=%d\n", fr->callno, fr->ts);			}			iaxs[fr->callno]->last_iax_message = f.subclass.integer;			if (!iaxs[fr->callno]->first_iax_message) {				iaxs[fr->callno]->first_iax_message = f.subclass.integer;			}			switch(f.subclass.integer) {			case IAX_COMMAND_ACK:				/* Do nothing */				break;			case IAX_COMMAND_QUELCH:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {				        /* Generate Manager Hold event, if necessary*/					if (iaxs[fr->callno]->owner) {						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: On\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}					ast_set_flag64(iaxs[fr->callno], IAX_QUELCH);					if (ies.musiconhold) {						iax2_lock_owner(fr->callno);						if (!iaxs[fr->callno] || !iaxs[fr->callno]->owner) {							break;						}						if (ast_bridged_channel(iaxs[fr->callno]->owner)) {							const char *moh_suggest = iaxs[fr->callno]->mohsuggest;							/*							 * We already hold the owner lock so we do not							 * need to check iaxs[fr->callno] after it returns.							 */							iax2_queue_control_data(fr->callno, AST_CONTROL_HOLD, 								S_OR(moh_suggest, NULL),								!ast_strlen_zero(moh_suggest) ? strlen(moh_suggest) + 1 : 0);						}						ast_channel_unlock(iaxs[fr->callno]->owner);					}				}				break;			case IAX_COMMAND_UNQUELCH:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {					iax2_lock_owner(fr->callno);					if (!iaxs[fr->callno]) {						break;					}					/* Generate Manager Unhold event, if necessary */					if (iaxs[fr->callno]->owner && ast_test_flag64(iaxs[fr->callno], IAX_QUELCH)) {						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: Off\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}					ast_clear_flag64(iaxs[fr->callno], IAX_QUELCH);					if (!iaxs[fr->callno]->owner) {						break;					}					if (ast_bridged_channel(iaxs[fr->callno]->owner)) {						/*						 * We already hold the owner lock so we do not						 * need to check iaxs[fr->callno] after it returns.						 */						iax2_queue_control_data(fr->callno, AST_CONTROL_UNHOLD, NULL, 0);					}					ast_channel_unlock(iaxs[fr->callno]->owner);				}				break;			case IAX_COMMAND_TXACC:				if (iaxs[fr->callno]->transferring == TRANSFER_BEGIN) {					/* Ack the packet with the given timestamp */					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* Cancel any outstanding txcnt's */						if (cur->transfer) {							cur->retries = -1;						}					}					memset(&ied1, 0, sizeof(ied1));					iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->callno);					send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREADY, 0, ied1.buf, ied1.pos, -1);					iaxs[fr->callno]->transferring = TRANSFER_READY;				}				break;			case IAX_COMMAND_NEW:				/* Ignore if it's already up */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD))					break;				if (ies.provverpres && ies.serviceident && sin.sin_addr.s_addr) {					ast_mutex_unlock(&iaxsl[fr->callno]);					check_provisioning(&sin, fd, ies.serviceident, ies.provver);					ast_mutex_lock(&iaxsl[fr->callno]);					if (!iaxs[fr->callno]) {						break;					}				}				/* If we're in trunk mode, do it now, and update the trunk number in our frame before continuing */				if (ast_test_flag64(iaxs[fr->callno], IAX_TRUNK)) {					int new_callno;					if ((new_callno = make_trunk(fr->callno, 1)) != -1)						fr->callno = new_callno;				}				/* For security, always ack immediately */				if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				if (check_access(fr->callno, &sin, &ies)) {					/* They're not allowed on */					auth_fail(fr->callno, IAX_COMMAND_REJECT);					if (authdebug)						ast_log(LOG_NOTICE, "Rejected connect attempt from %s, who was trying to reach '%s@%s'\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					break;				}				if (ast_strlen_zero(iaxs[fr->callno]->secret) && ast_test_flag64(iaxs[fr->callno], IAX_FORCE_ENCRYPT)) {					auth_fail(fr->callno, IAX_COMMAND_REJECT);					ast_log(LOG_WARNING, "Rejected connect attempt.  No secret present while force encrypt enabled.\n");					break;				}				if (strcasecmp(iaxs[fr->callno]->exten, "TBD")) {					const char *context, *exten, *cid_num;					context = ast_strdupa(iaxs[fr->callno]->context);					exten = ast_strdupa(iaxs[fr->callno]->exten);					cid_num = ast_strdupa(iaxs[fr->callno]->cid_num);					/* This might re-enter the IAX code and need the lock */					ast_mutex_unlock(&iaxsl[fr->callno]);					exists = ast_exists_extension(NULL, context, exten, 1, cid_num);					ast_mutex_lock(&iaxsl[fr->callno]);					if (!iaxs[fr->callno]) {						break;					}				} else					exists = 0;				/* Get OSP token if it does exist */				save_osptoken(fr, &ies);				if (ast_strlen_zero(iaxs[fr->callno]->secret) && ast_strlen_zero(iaxs[fr->callno]->inkeys)) {					if (strcmp(iaxs[fr->callno]->exten, "TBD") && !exists) {						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}						if (authdebug)							ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					} else {						/* Select an appropriate format */						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								using_prefs = "reqonly";							} else {								using_prefs = "disabled";							}							format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;							memset(&pref, 0, sizeof(pref));							strcpy(caller_pref_buf, "disabled");							strcpy(host_pref_buf, "disabled");						} else {							struct ast_format tmpfmt;							using_prefs = "mine";							/* If the information elements are in here... use them */							if (ies.codec_prefs)								ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);							if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {								/* If we are codec_first_choice we let the caller have the 1st shot at picking the codec.*/								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {									pref = iaxs[fr->callno]->rprefs;									using_prefs = "caller";								} else {									pref = iaxs[fr->callno]->prefs;								}							} else								pref = iaxs[fr->callno]->prefs;							format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);							ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);							ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);						}						if (!format) {							if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP))								format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;							if (!format) {								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}								if (authdebug) {									char tmp[256], tmp2[256], tmp3[256];									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}							} else {								/* Pick one... */								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))										format = 0;								} else {									if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {										using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";										memset(&pref, 0, sizeof(pref));										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);										strcpy(caller_pref_buf,"disabled");										strcpy(host_pref_buf,"disabled");									} else {										struct ast_format tmpfmt;										using_prefs = "mine";										if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {											/* Do the opposite of what we tried above. */											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);										} else /* if no codec_prefs IE do it the old way */											format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}								}								if (!format) {									char tmp[256], tmp2[256], tmp3[256];									memset(&ied0, 0, sizeof(ied0));									iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");									iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);									ast_log(LOG_ERROR, "No best format in '%s'???\n", iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));									send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);									if (!iaxs[fr->callno]) {										break;									}									if (authdebug) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}									ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);									break;								}							}						}						if (format) {							/* No authentication required, let them in */							memset(&ied1, 0, sizeof(ied1));							iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);							iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);							send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);							if (strcmp(iaxs[fr->callno]->exten, "TBD")) {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);								ast_verb(3, "Accepting UNAUTHENTICATED call from %s:\n"												"%srequested format = %s,\n"												"%srequested prefs = %s,\n"												"%sactual format = %s,\n"												"%shost prefs = %s,\n"												"%spriority = %s\n",												ast_inet_ntoa(sin.sin_addr), 												VERBOSE_PREFIX_4,												iax2_getformatname(iaxs[fr->callno]->peerformat), 												VERBOSE_PREFIX_4,												caller_pref_buf,												VERBOSE_PREFIX_4,												iax2_getformatname(format), 												VERBOSE_PREFIX_4,												host_pref_buf, 												VERBOSE_PREFIX_4,												using_prefs);								iaxs[fr->callno]->chosenformat = format;								/* Since this is a new call, we should go ahead and set the callid for it. */								iax_pvt_callid_new(fr->callno);								ast_set_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);							} else {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);								/* If this is a TBD call, we're ready but now what...  */								ast_verb(3, "Accepted unauthenticated TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							}						}					}					break;				}				if (iaxs[fr->callno]->authmethods & IAX_AUTH_MD5)					merge_encryption(iaxs[fr->callno],ies.encmethods);				else					iaxs[fr->callno]->encmethods = 0;				if (!authenticate_request(fr->callno) && iaxs[fr->callno])					ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED);				break;			case IAX_COMMAND_DPREQ:				/* Request status in the dialplan */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD) &&					!ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED) && ies.called_number) {					if (iaxcompat) {						/* Spawn a thread for the lookup */						spawn_dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num);					} else {						/* Just look it up */						dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num, 1);					}				}				break;			case IAX_COMMAND_HANGUP:				ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);				ast_debug(1, "Immediately destroying %d, having received hangup\n", fr->callno);				/* Set hangup cause according to remote and hangupsource */				if (iaxs[fr->callno]->owner) {					set_hangup_source_and_cause(fr->callno, ies.causecode);					if (!iaxs[fr->callno]) {						break;					}				}				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_REJECT:				/* Set hangup cause according to remote and hangup source */				if (iaxs[fr->callno]->owner) {					set_hangup_source_and_cause(fr->callno, ies.causecode);					if (!iaxs[fr->callno]) {						break;					}				}				if (!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)) {					if (iaxs[fr->callno]->owner && authdebug)						ast_log(LOG_WARNING, "Call rejected by %s: %s\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr),							ies.cause ? ies.cause : "<Unknown>");					ast_debug(1, "Immediately destroying %d, having received reject\n",						fr->callno);				}				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK,						       fr->ts, NULL, 0, fr->iseqno);				if (!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION))					iaxs[fr->callno]->error = EPERM;				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_TRANSFER:			{				struct ast_channel *bridged_chan;				struct ast_channel *owner;				iax2_lock_owner(fr->callno);				if (!iaxs[fr->callno]) {					/* Initiating call went away before we could transfer. */					break;				}				owner = iaxs[fr->callno]->owner;				bridged_chan = owner ? ast_bridged_channel(owner) : NULL;				if (bridged_chan && ies.called_number) {					const char *context;					context = ast_strdupa(iaxs[fr->callno]->context);					ast_channel_ref(owner);					ast_channel_ref(bridged_chan);					ast_channel_unlock(owner);					ast_mutex_unlock(&iaxsl[fr->callno]);					/* Set BLINDTRANSFER channel variables */					pbx_builtin_setvar_helper(owner, "BLINDTRANSFER", ast_channel_name(bridged_chan));					pbx_builtin_setvar_helper(bridged_chan, "BLINDTRANSFER", ast_channel_name(owner));					/* DO NOT hold any locks while calling ast_parking_ext_valid() */					if (ast_parking_ext_valid(ies.called_number, owner, context)) {						ast_debug(1, "Parking call '%s'\n", ast_channel_name(bridged_chan));						if (iax_park(bridged_chan, owner, ies.called_number, context)) {							ast_log(LOG_WARNING, "Failed to park call '%s'\n",								ast_channel_name(bridged_chan));						}					} else {						if (ast_async_goto(bridged_chan, context, ies.called_number, 1)) {							ast_log(LOG_WARNING,								"Async goto of '%s' to '%s@%s' failed\n",								ast_channel_name(bridged_chan), ies.called_number, context);						} else {							ast_debug(1, "Async goto of '%s' to '%s@%s' started\n",								ast_channel_name(bridged_chan), ies.called_number, context);						}					}					ast_channel_unref(owner);					ast_channel_unref(bridged_chan);					ast_mutex_lock(&iaxsl[fr->callno]);				} else {					ast_debug(1, "Async goto not applicable on call %d\n", fr->callno);					if (owner) {						ast_channel_unlock(owner);					}				}				break;			}			case IAX_COMMAND_ACCEPT:				/* Ignore if call is already up or needs authentication or is a TBD */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD | IAX_STATE_AUTHENTICATED))					break;				if (ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)) {					/* Send ack immediately, before we destroy */					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					iax2_destroy(fr->callno);					break;				}				if (ies.format) {					iaxs[fr->callno]->peerformat = ies.format;				} else {					if (iaxs[fr->callno]->owner)						iaxs[fr->callno]->peerformat = ast_format_cap_to_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner));					else						iaxs[fr->callno]->peerformat = iaxs[fr->callno]->capability;				}				ast_verb(3, "Call accepted by %s (format %s)\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iax2_getformatname(iaxs[fr->callno]->peerformat));				if (!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)) {					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);					if (!iaxs[fr->callno]) {						break;					}					if (authdebug) {						char tmp1[256], tmp2[256];						ast_log(LOG_NOTICE, "Rejected call to %s, format %s incompatible with our capability %s.\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),							iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));					}				} else {					ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);					iax2_lock_owner(fr->callno);					if (iaxs[fr->callno] && iaxs[fr->callno]->owner) {						char tmp[256];						/* Switch us to use a compatible format */						ast_format_cap_from_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner), iaxs[fr->callno]->peerformat);						ast_verb(3, "Format for call is %s\n", ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(iaxs[fr->callno]->owner)));						/* Setup read/write formats properly. */						if (ast_channel_writeformat(iaxs[fr->callno]->owner)->id)							ast_set_write_format(iaxs[fr->callno]->owner, ast_channel_writeformat(iaxs[fr->callno]->owner));						if (ast_channel_readformat(iaxs[fr->callno]->owner)->id)							ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));						ast_channel_unlock(iaxs[fr->callno]->owner);					}				}				if (iaxs[fr->callno]) {					AST_LIST_LOCK(&dpcache);					AST_LIST_TRAVERSE(&iaxs[fr->callno]->dpentries, dp, peer_list)						if (!(dp->flags & CACHE_FLAG_TRANSMITTED))							iax2_dprequest(dp, fr->callno);					AST_LIST_UNLOCK(&dpcache);				}				break;			case IAX_COMMAND_POKE:				/* Send back a pong packet with the original timestamp */				send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, NULL, 0, -1);				break;			case IAX_COMMAND_PING:			{				struct iax_ie_data pingied;				construct_rr(iaxs[fr->callno], &pingied);				/* Send back a pong packet with the original timestamp */				send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, pingied.buf, pingied.pos, -1);			}				break;			case IAX_COMMAND_PONG:				/* Calculate ping time */				iaxs[fr->callno]->pingtime =  calc_timestamp(iaxs[fr->callno], 0, &f) - fr->ts;				/* save RR info */				save_rr(fr, &ies);				/* Good time to write jb stats for this call */				log_jitterstats(fr->callno);				if (iaxs[fr->callno]->peerpoke) {					peer = iaxs[fr->callno]->peerpoke;					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms)) {						if (iaxs[fr->callno]->pingtime <= peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now REACHABLE! Time: %d\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Reachable\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_NOT_INUSE, "IAX2/%s", peer->name); /* Activate notification */						}					} else if ((peer->historicms > 0) && (peer->historicms <= peer->maxms)) {						if (iaxs[fr->callno]->pingtime > peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now TOO LAGGED (%d ms)!\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Lagged\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_UNAVAILABLE, "IAX2/%s", peer->name); /* Activate notification */						}					}					peer->lastms = iaxs[fr->callno]->pingtime;					if (peer->smoothing && (peer->lastms > -1))						peer->historicms = (iaxs[fr->callno]->pingtime + peer->historicms) / 2;					else if (peer->smoothing && peer->lastms < 0)						peer->historicms = (0 + peer->historicms) / 2;					else											peer->historicms = iaxs[fr->callno]->pingtime;					/* Remove scheduled iax2_poke_noanswer */					if (peer->pokeexpire > -1) {						if (!AST_SCHED_DEL(sched, peer->pokeexpire)) {							peer_unref(peer);							peer->pokeexpire = -1;						}					}					/* Schedule the next cycle */					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms))						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_peer_s, peer_ref(peer));					else						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqok, iax2_poke_peer_s, peer_ref(peer));					if (peer->pokeexpire == -1)						peer_unref(peer);					/* and finally send the ack */					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					/* And wrap up the qualify call */					iax2_destroy(fr->callno);					peer->callno = 0;					ast_debug(1, "Peer %s: got pong, lastms %d, historicms %d, maxms %d\n", peer->name, peer->lastms, peer->historicms, peer->maxms);				}				break;			case IAX_COMMAND_LAGRQ:			case IAX_COMMAND_LAGRP:				f.src = "LAGRQ";				f.mallocd = 0;				f.offset = 0;				f.samples = 0;				iax_frame_wrap(fr, &f);				if (f.subclass.integer == IAX_COMMAND_LAGRQ) {					/* Received a LAGRQ - echo back a LAGRP */					fr->af.subclass.integer = IAX_COMMAND_LAGRP;					iax2_send(iaxs[fr->callno], &fr->af, fr->ts, -1, 0, 0, 0);				} else {					/* Received LAGRP in response to our LAGRQ */					unsigned int ts;					/* This is a reply we've been given, actually measure the difference */					ts = calc_timestamp(iaxs[fr->callno], 0, &fr->af);					iaxs[fr->callno]->lag = ts - fr->ts;					if (iaxdebug)						ast_debug(1, "Peer %s lag measured as %dms\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->lag);				}				break;			case IAX_COMMAND_AUTHREQ:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)) {					ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					break;				}				if (authenticate_reply(iaxs[fr->callno], &iaxs[fr->callno]->addr, &ies, iaxs[fr->callno]->secret, iaxs[fr->callno]->outkey)) {					struct ast_frame hangup_fr = { .frametype = AST_FRAME_CONTROL,								.subclass.integer = AST_CONTROL_HANGUP,					};					ast_log(LOG_WARNING, 						"I don't know how to authenticate %s to %s\n", 						ies.username ? ies.username : "<unknown>", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr));					iax2_queue_frame(fr->callno, &hangup_fr);				}				break;			case IAX_COMMAND_AUTHREP:				/* For security, always ack immediately */				if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				/* Ignore once we've started */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)) {					ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					break;				}				if (authenticate_verify(iaxs[fr->callno], &ies)) {					if (authdebug)						ast_log(LOG_NOTICE, "Host %s failed to authenticate as %s\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->username);					memset(&ied0, 0, sizeof(ied0));					auth_fail(fr->callno, IAX_COMMAND_REJECT);					break;				}				if (strcasecmp(iaxs[fr->callno]->exten, "TBD")) {					/* This might re-enter the IAX code and need the lock */					exists = ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num);				} else					exists = 0;				if (strcmp(iaxs[fr->callno]->exten, "TBD") && !exists) {					if (authdebug)						ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);					if (!iaxs[fr->callno]) {						break;					}				} else {					/* Select an appropriate format */					if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {							using_prefs = "reqonly";						} else {							using_prefs = "disabled";						}						format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;						memset(&pref, 0, sizeof(pref));						strcpy(caller_pref_buf, "disabled");						strcpy(host_pref_buf, "disabled");					} else {						struct ast_format tmpfmt;						using_prefs = "mine";						if (ies.codec_prefs)							ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);						if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {							if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {								pref = iaxs[fr->callno]->rprefs;								using_prefs = "caller";							} else {								pref = iaxs[fr->callno]->prefs;							}						} else /* if no codec_prefs IE do it the old way */							pref = iaxs[fr->callno]->prefs;						format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);						ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);						ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);					}					if (!format) {						char tmp1[256], tmp2[256], tmp3[256];						if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {							ast_debug(1, "We don't do requested format %s, falling back to peer capability '%s'\n",								iax2_getformatname(iaxs[fr->callno]->peerformat),								iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability));							format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;						}						if (!format) {							if (authdebug) {								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n", ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));								} else {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",										ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),										iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));								}							}							memset(&ied0, 0, sizeof(ied0));							iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");							iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);							send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);							if (!iaxs[fr->callno]) {								break;							}						} else {							/* Pick one... */							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))									format = 0;							} else {								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {									using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";									memset(&pref, 0, sizeof(pref));									format = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ?										iaxs[fr->callno]->peerformat : iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									strcpy(caller_pref_buf,"disabled");									strcpy(host_pref_buf,"disabled");								} else {									struct ast_format tmpfmt;									using_prefs = "mine";									if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {										/* Do the opposite of what we tried above. */										if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {											pref = iaxs[fr->callno]->prefs;										} else {											pref = iaxs[fr->callno]->rprefs;											using_prefs = "caller";										}										format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);									} else /* if no codec_prefs IE do it the old way */										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}							}							if (!format) {								char tmp1[256], tmp2[256], tmp3[256];								ast_log(LOG_ERROR, "No best format in %s???\n",									iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));								if (authdebug) {									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}							}						}					}					if (format) {						/* Authentication received */						memset(&ied1, 0, sizeof(ied1));						iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);						iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);						send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);						if (strcmp(iaxs[fr->callno]->exten, "TBD")) {							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							ast_verb(3, "Accepting AUTHENTICATED call from %s:\n"											"%srequested format = %s,\n"											"%srequested prefs = %s,\n"											"%sactual format = %s,\n"											"%shost prefs = %s,\n"											"%spriority = %s\n", 											ast_inet_ntoa(sin.sin_addr), 											VERBOSE_PREFIX_4,											iax2_getformatname(iaxs[fr->callno]->peerformat),											VERBOSE_PREFIX_4,											caller_pref_buf,											VERBOSE_PREFIX_4,											iax2_getformatname(format),											VERBOSE_PREFIX_4,											host_pref_buf,											VERBOSE_PREFIX_4,											using_prefs);							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, format, NULL)))								iax2_destroy(fr->callno);							else if (ies.vars) {								struct ast_datastore *variablestore;								struct ast_variable *var, *prev = NULL;								AST_LIST_HEAD(, ast_var_t) *varlist;								varlist = ast_calloc(1, sizeof(*varlist));								variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);								if (variablestore && varlist) {									variablestore->data = varlist;									variablestore->inheritance = DATASTORE_INHERIT_FOREVER;									AST_LIST_HEAD_INIT(varlist);									ast_debug(1, "I can haz IAX vars? w00t\n");									for (var = ies.vars; var; var = var->next) {										struct ast_var_t *newvar = ast_var_assign(var->name, var->value);										if (prev)											ast_free(prev);										prev = var;										if (!newvar) {											/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */											ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");										} else {											AST_LIST_INSERT_TAIL(varlist, newvar, entries);										}									}									if (prev)										ast_free(prev);									ies.vars = NULL;									ast_channel_datastore_add(c, variablestore);								} else {									ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									if (variablestore)										ast_datastore_free(variablestore);									if (varlist)										ast_free(varlist);								}							}						} else {							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);							/* If this is a TBD call, we're ready but now what...  */							ast_verb(3, "Accepted AUTHENTICATED TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							if (ast_test_flag64(iaxs[fr->callno], IAX_IMMEDIATE)) {								goto immediatedial;							}						}					}				}				break;			case IAX_COMMAND_DIAL:immediatedial:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD)) {					ast_clear_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);					ast_string_field_set(iaxs[fr->callno], exten, ies.called_number ? ies.called_number : "s");					if (!ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num)) {						if (authdebug)							ast_log(LOG_NOTICE, "Rejected dial attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}					} else {						char tmp[256];						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);						ast_verb(3, "Accepting DIAL from %s, formats = %s\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat));						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);						send_command(iaxs[fr->callno], AST_FRAME_CONTROL, AST_CONTROL_PROGRESS, 0, NULL, 0, -1);						if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->peerformat, NULL)))							iax2_destroy(fr->callno);						else if (ies.vars) {							struct ast_datastore *variablestore;							struct ast_variable *var, *prev = NULL;							AST_LIST_HEAD(, ast_var_t) *varlist;							varlist = ast_calloc(1, sizeof(*varlist));							variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);							ast_debug(1, "I can haz IAX vars? w00t\n");							if (variablestore && varlist) {								variablestore->data = varlist;								variablestore->inheritance = DATASTORE_INHERIT_FOREVER;								AST_LIST_HEAD_INIT(varlist);								for (var = ies.vars; var; var = var->next) {									struct ast_var_t *newvar = ast_var_assign(var->name, var->value);									if (prev)										ast_free(prev);									prev = var;									if (!newvar) {										/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */										ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									} else {										AST_LIST_INSERT_TAIL(varlist, newvar, entries);									}								}								if (prev)									ast_free(prev);								ies.vars = NULL;								ast_channel_datastore_add(c, variablestore);							} else {								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");								if (variablestore)									ast_datastore_free(variablestore);								if (varlist)									ast_free(varlist);							}						}					}				}				break;			case IAX_COMMAND_INVAL:				iaxs[fr->callno]->error = ENOTCONN;				ast_debug(1, "Immediately destroying %d, having received INVAL\n", fr->callno);				iax2_destroy(fr->callno);				ast_debug(1, "Destroying call %d\n", fr->callno);				break;			case IAX_COMMAND_VNAK:				ast_debug(1, "Received VNAK: resending outstanding frames\n");				/* Force retransmission */				vnak_retransmit(fr->callno, fr->iseqno);				break;			case IAX_COMMAND_REGREQ:			case IAX_COMMAND_REGREL:				/* For security, always ack immediately */				if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				if (register_verify(fr->callno, &sin, &ies)) {					if (!iaxs[fr->callno]) {						break;					}					/* Send delayed failure */					auth_fail(fr->callno, IAX_COMMAND_REGREJ);					break;				}				if (!iaxs[fr->callno]) {					break;				}				if ((ast_strlen_zero(iaxs[fr->callno]->secret) && ast_strlen_zero(iaxs[fr->callno]->inkeys)) ||						ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED)) {					if (f.subclass.integer == IAX_COMMAND_REGREL) {						memset(&sin, 0, sizeof(sin));						sin.sin_family = AF_INET;					}					if (update_registry(&sin, fr->callno, ies.devicetype, fd, ies.refresh)) {						ast_log(LOG_WARNING, "Registry error\n");					}					if (!iaxs[fr->callno]) {						break;					}					if (ies.provverpres && ies.serviceident && sin.sin_addr.s_addr) {						ast_mutex_unlock(&iaxsl[fr->callno]);						check_provisioning(&sin, fd, ies.serviceident, ies.provver);						ast_mutex_lock(&iaxsl[fr->callno]);					}					break;				}				registry_authrequest(fr->callno);				break;			case IAX_COMMAND_REGACK:				if (iax2_ack_registry(&ies, &sin, fr->callno)) 					ast_log(LOG_WARNING, "Registration failure\n");				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_REGREJ:				if (iaxs[fr->callno]->reg) {					if (authdebug) {						ast_log(LOG_NOTICE, "Registration of '%s' rejected: '%s' from: '%s'\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>", ast_inet_ntoa(sin.sin_addr));						manager_event(EVENT_FLAG_SYSTEM, "Registry", "ChannelType: IAX2\r\nUsername: %s\r\nStatus: Rejected\r\nCause: %s\r\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>");					}					iaxs[fr->callno]->reg->regstate = REG_STATE_REJECTED;				}				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_REGAUTH:				/* Authentication request */				if (registry_rerequest(&ies, fr->callno, &sin)) {					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No authority found");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_FACILITY_NOT_SUBSCRIBED);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);				}				break;			case IAX_COMMAND_TXREJ:				iaxs[fr->callno]->transferring = 0;				ast_verb(3, "Channel '%s' unable to transfer\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");				memset(&iaxs[fr->callno]->transfer, 0, sizeof(iaxs[fr->callno]->transfer));				if (iaxs[fr->callno]->bridgecallno) {					if (iaxs[iaxs[fr->callno]->bridgecallno]->transferring) {						iaxs[iaxs[fr->callno]->bridgecallno]->transferring = 0;						send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREJ, 0, NULL, 0, -1);					}				}				break;			case IAX_COMMAND_TXREADY:				if ((iaxs[fr->callno]->transferring == TRANSFER_BEGIN) ||				    (iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)) {					if (iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)						iaxs[fr->callno]->transferring = TRANSFER_MREADY;					else						iaxs[fr->callno]->transferring = TRANSFER_READY;					ast_verb(3, "Channel '%s' ready to transfer\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					if (iaxs[fr->callno]->bridgecallno) {						if ((iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_READY) ||						    (iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_MREADY)) {							/* They're both ready, now release them. */							if (iaxs[fr->callno]->transferring == TRANSFER_MREADY) {								ast_verb(3, "Attempting media bridge of %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_MEDIA;								iaxs[fr->callno]->transferring = TRANSFER_MEDIA;								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied1.buf, ied1.pos, -1);							} else {								ast_verb(3, "Releasing %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_RELEASED;								iaxs[fr->callno]->transferring = TRANSFER_RELEASED;								ast_set_flag64(iaxs[iaxs[fr->callno]->bridgecallno], IAX_ALREADYGONE);								ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);								/* Stop doing lag & ping requests */								stop_stuff(fr->callno);								stop_stuff(iaxs[fr->callno]->bridgecallno);								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied1.buf, ied1.pos, -1);							}						}					}				}				break;			case IAX_COMMAND_TXREQ:				try_transfer(iaxs[fr->callno], &ies);				break;			case IAX_COMMAND_TXCNT:				if (iaxs[fr->callno]->transferring)					send_command_transfer(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXACC, 0, NULL, 0);				break;			case IAX_COMMAND_TXREL:				/* Send ack immediately, rather than waiting until we've changed addresses */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				complete_transfer(fr->callno, &ies);				stop_stuff(fr->callno);	/* for attended transfer to work with libiax */				break;				case IAX_COMMAND_TXMEDIA:				if (iaxs[fr->callno]->transferring == TRANSFER_READY) {					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* Cancel any outstanding frames and start anew */						if (cur->transfer) {							cur->retries = -1;						}					}					/* Start sending our media to the transfer address, but otherwise leave the call as-is */					iaxs[fr->callno]->transferring = TRANSFER_MEDIAPASS;				}				break;			case IAX_COMMAND_RTKEY:				if (!IAX_CALLENCRYPTED(iaxs[fr->callno])) {					ast_log(LOG_WARNING, 						"we've been told to rotate our encryption key, "						"but this isn't an encrypted call. bad things will happen.\n"					);					break;				}				IAX_DEBUGDIGEST("Receiving", ies.challenge);				ast_aes_set_decrypt_key((unsigned char *) ies.challenge, &iaxs[fr->callno]->dcx);				break;			case IAX_COMMAND_DPREP:				complete_dpreply(iaxs[fr->callno], &ies);				break;			case IAX_COMMAND_UNSUPPORT:				ast_log(LOG_NOTICE, "Peer did not understand our iax command '%d'\n", ies.iax_unknown);				break;			case IAX_COMMAND_FWDOWNL:				/* Firmware download */				if (!ast_test_flag64(&globalflags, IAX_ALLOWFWDOWNLOAD)) {					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_UNSUPPORT, 0, NULL, 0, -1);					break;				}				memset(&ied0, 0, sizeof(ied0));				res = iax_firmware_append(&ied0, (unsigned char *)ies.devicetype, ies.fwdesc);				if (res < 0)					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);				else if (res > 0)					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1);				else					send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1);				break;			case IAX_COMMAND_CALLTOKEN:			{				struct iax_frame *cur;				/* find last sent frame */				if ((cur = AST_LIST_LAST(&frame_queue[fr->callno])) && ies.calltoken && ies.calltokendata) {					resend_with_token(fr->callno, cur, (char *) ies.calltokendata);				}				break;			}			default:				ast_debug(1, "Unknown IAX command %d on %d/%d\n", f.subclass.integer, fr->callno, iaxs[fr->callno]->peercallno);				memset(&ied0, 0, sizeof(ied0));				iax_ie_append_byte(&ied0, IAX_IE_IAX_UNKNOWN, f.subclass.integer);				send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_UNSUPPORT, 0, ied0.buf, ied0.pos, -1);			}			/* Free remote variables (if any) */			if (ies.vars) {				ast_variables_destroy(ies.vars);				ast_debug(1, "I can haz IAX vars, but they is no good :-(\n");				ies.vars = NULL;			}			/* Don't actually pass these frames along */			if ((f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&			  (f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_INVAL) &&			  (f.subclass.integer != IAX_COMMAND_VNAK)) {				if (iaxs[fr->callno] && iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);			}			ast_mutex_unlock(&iaxsl[fr->callno]);			return 1;		}
if (iaxdebug)			ast_debug(1, "Received packet %d, (%d, %u)\n", fh->oseqno, f.frametype, f.subclass.integer);
iaxdebug
iaxdebug
ast_debug(1, "Received packet %d, (%d, %u)\n", fh->oseqno, f.frametype, f.subclass.integer);
ast_debug(1, "Received packet %d, (%d, %u)\n", fh->oseqno, f.frametype, f.subclass.integer)
ast_debug
ast_debug
1
"Received packet %d, (%d, %u)\n"
fh->oseqno
fh
fh
oseqno
f.frametype
f
f
frametype
f.subclass.integer
f.subclass
f
f
subclass
integer
fr->oseqno = fh->oseqno;
fr->oseqno = fh->oseqno
fr->oseqno
fr
fr
oseqno
fh->oseqno
fh
fh
oseqno
fr->iseqno = fh->iseqno;
fr->iseqno = fh->iseqno
fr->iseqno
fr
fr
iseqno
fh->iseqno
fh
fh
iseqno
fr->ts = ntohl(fh->ts);
fr->ts = ntohl(fh->ts)
fr->ts
fr
fr
ts
ntohl(fh->ts)
ntohl
ntohl
fh->ts
fh
fh
ts
if ((ntohs(fh->dcallno) & IAX_FLAG_RETRANS) || (f.frametype != AST_FRAME_VOICE))			updatehistory = 0;
(ntohs(fh->dcallno) & IAX_FLAG_RETRANS) || (f.frametype != AST_FRAME_VOICE)
(ntohs(fh->dcallno) & IAX_FLAG_RETRANS)
ntohs(fh->dcallno) & IAX_FLAG_RETRANS
ntohs(fh->dcallno)
ntohs
ntohs
fh->dcallno
fh
fh
dcallno
IAX_FLAG_RETRANS
IAX_FLAG_RETRANS
(f.frametype != AST_FRAME_VOICE)
f.frametype != AST_FRAME_VOICE
f.frametype
f
f
frametype
AST_FRAME_VOICE
AST_FRAME_VOICE
updatehistory = 0;
updatehistory = 0
updatehistory
updatehistory
0
if ((iaxs[fr->callno]->iseqno != fr->oseqno) &&			(iaxs[fr->callno]->iseqno ||				((f.subclass.integer != IAX_COMMAND_TXCNT) &&				(f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXACC)) ||				(f.frametype != AST_FRAME_IAX))) {			if (			 ((f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_INVAL) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&			  (f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_VNAK)) ||			  (f.frametype != AST_FRAME_IAX)) {				/* If it's not an ACK packet, it's out of order. */				ast_debug(1, "Packet arrived out of order (expecting %d, got %d) (frametype = %d, subclass = %d)\n",					iaxs[fr->callno]->iseqno, fr->oseqno, f.frametype, f.subclass.integer);				/* Check to see if we need to request retransmission,				 * and take sequence number wraparound into account */				if ((unsigned char) (iaxs[fr->callno]->iseqno - fr->oseqno) < 128) {					/* If we've already seen it, ack it XXX There's a border condition here XXX */					if ((f.frametype != AST_FRAME_IAX) ||							((f.subclass.integer != IAX_COMMAND_ACK) && (f.subclass.integer != IAX_COMMAND_INVAL))) {						ast_debug(1, "Acking anyway\n");						/* XXX Maybe we should handle its ack to us, but then again, it's probably outdated anyway, and if						   we have anything to send, we'll retransmit and get an ACK back anyway XXX */						send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					}				} else {					/* Send a VNAK requesting retransmission */					iax2_vnak(fr->callno);				}				ast_variables_destroy(ies.vars);				ast_mutex_unlock(&iaxsl[fr->callno]);				return 1;			}		} else {			/* Increment unless it's an ACK or VNAK */			if (((f.subclass.integer != IAX_COMMAND_ACK) &&			    (f.subclass.integer != IAX_COMMAND_INVAL) &&			    (f.subclass.integer != IAX_COMMAND_TXCNT) &&			    (f.subclass.integer != IAX_COMMAND_TXACC) &&				(f.subclass.integer != IAX_COMMAND_VNAK)) ||			    (f.frametype != AST_FRAME_IAX))				iaxs[fr->callno]->iseqno++;		}
(iaxs[fr->callno]->iseqno != fr->oseqno) &&			(iaxs[fr->callno]->iseqno ||				((f.subclass.integer != IAX_COMMAND_TXCNT) &&				(f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXACC)) ||				(f.frametype != AST_FRAME_IAX))
(iaxs[fr->callno]->iseqno != fr->oseqno)
iaxs[fr->callno]->iseqno != fr->oseqno
iaxs[fr->callno]->iseqno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
iseqno
fr->oseqno
fr
fr
oseqno
(iaxs[fr->callno]->iseqno ||				((f.subclass.integer != IAX_COMMAND_TXCNT) &&				(f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXACC)) ||				(f.frametype != AST_FRAME_IAX))
iaxs[fr->callno]->iseqno ||				((f.subclass.integer != IAX_COMMAND_TXCNT) &&				(f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXACC)) ||				(f.frametype != AST_FRAME_IAX)
iaxs[fr->callno]->iseqno ||				((f.subclass.integer != IAX_COMMAND_TXCNT) &&				(f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXACC))
iaxs[fr->callno]->iseqno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
iseqno
((f.subclass.integer != IAX_COMMAND_TXCNT) &&				(f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXACC))
(f.subclass.integer != IAX_COMMAND_TXCNT) &&				(f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXACC)
(f.subclass.integer != IAX_COMMAND_TXCNT) &&				(f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_UNQUELCH )
(f.subclass.integer != IAX_COMMAND_TXCNT) &&				(f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */				(f.subclass.integer != IAX_COMMAND_TXREL)
(f.subclass.integer != IAX_COMMAND_TXCNT) &&				(f.subclass.integer != IAX_COMMAND_TXREADY)
(f.subclass.integer != IAX_COMMAND_TXCNT)
f.subclass.integer != IAX_COMMAND_TXCNT
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_TXCNT
IAX_COMMAND_TXCNT
(f.subclass.integer != IAX_COMMAND_TXREADY)
f.subclass.integer != IAX_COMMAND_TXREADY
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_TXREADY
IAX_COMMAND_TXREADY
(f.subclass.integer != IAX_COMMAND_TXREL)
f.subclass.integer != IAX_COMMAND_TXREL
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_TXREL
IAX_COMMAND_TXREL
(f.subclass.integer != IAX_COMMAND_UNQUELCH )
f.subclass.integer != IAX_COMMAND_UNQUELCH
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_UNQUELCH
IAX_COMMAND_UNQUELCH
(f.subclass.integer != IAX_COMMAND_TXACC)
f.subclass.integer != IAX_COMMAND_TXACC
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_TXACC
IAX_COMMAND_TXACC
(f.frametype != AST_FRAME_IAX)
f.frametype != AST_FRAME_IAX
f.frametype
f
f
frametype
AST_FRAME_IAX
AST_FRAME_IAX
{			if (			 ((f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_INVAL) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&			  (f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_VNAK)) ||			  (f.frametype != AST_FRAME_IAX)) {				/* If it's not an ACK packet, it's out of order. */				ast_debug(1, "Packet arrived out of order (expecting %d, got %d) (frametype = %d, subclass = %d)\n",					iaxs[fr->callno]->iseqno, fr->oseqno, f.frametype, f.subclass.integer);				/* Check to see if we need to request retransmission,				 * and take sequence number wraparound into account */				if ((unsigned char) (iaxs[fr->callno]->iseqno - fr->oseqno) < 128) {					/* If we've already seen it, ack it XXX There's a border condition here XXX */					if ((f.frametype != AST_FRAME_IAX) ||							((f.subclass.integer != IAX_COMMAND_ACK) && (f.subclass.integer != IAX_COMMAND_INVAL))) {						ast_debug(1, "Acking anyway\n");						/* XXX Maybe we should handle its ack to us, but then again, it's probably outdated anyway, and if						   we have anything to send, we'll retransmit and get an ACK back anyway XXX */						send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					}				} else {					/* Send a VNAK requesting retransmission */					iax2_vnak(fr->callno);				}				ast_variables_destroy(ies.vars);				ast_mutex_unlock(&iaxsl[fr->callno]);				return 1;			}		}
if (			 ((f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_INVAL) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&			  (f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_VNAK)) ||			  (f.frametype != AST_FRAME_IAX)) {				/* If it's not an ACK packet, it's out of order. */				ast_debug(1, "Packet arrived out of order (expecting %d, got %d) (frametype = %d, subclass = %d)\n",					iaxs[fr->callno]->iseqno, fr->oseqno, f.frametype, f.subclass.integer);				/* Check to see if we need to request retransmission,				 * and take sequence number wraparound into account */				if ((unsigned char) (iaxs[fr->callno]->iseqno - fr->oseqno) < 128) {					/* If we've already seen it, ack it XXX There's a border condition here XXX */					if ((f.frametype != AST_FRAME_IAX) ||							((f.subclass.integer != IAX_COMMAND_ACK) && (f.subclass.integer != IAX_COMMAND_INVAL))) {						ast_debug(1, "Acking anyway\n");						/* XXX Maybe we should handle its ack to us, but then again, it's probably outdated anyway, and if						   we have anything to send, we'll retransmit and get an ACK back anyway XXX */						send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					}				} else {					/* Send a VNAK requesting retransmission */					iax2_vnak(fr->callno);				}				ast_variables_destroy(ies.vars);				ast_mutex_unlock(&iaxsl[fr->callno]);				return 1;			}
((f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_INVAL) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&			  (f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_VNAK)) ||			  (f.frametype != AST_FRAME_IAX)
((f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_INVAL) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&			  (f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_VNAK))
(f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_INVAL) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&			  (f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_VNAK)
(f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_INVAL) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&			  (f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_UNQUELCH ) &&	/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXACC)
(f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_INVAL) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&			  (f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXREL) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_UNQUELCH )
(f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_INVAL) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&			  (f.subclass.integer != IAX_COMMAND_TXREADY) &&		/* for attended transfer */			  (f.subclass.integer != IAX_COMMAND_TXREL)
(f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_INVAL) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&			  (f.subclass.integer != IAX_COMMAND_TXREADY)
(f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_INVAL) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT)
(f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_INVAL)
(f.subclass.integer != IAX_COMMAND_ACK)
f.subclass.integer != IAX_COMMAND_ACK
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_ACK
IAX_COMMAND_ACK
(f.subclass.integer != IAX_COMMAND_INVAL)
f.subclass.integer != IAX_COMMAND_INVAL
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_INVAL
IAX_COMMAND_INVAL
(f.subclass.integer != IAX_COMMAND_TXCNT)
f.subclass.integer != IAX_COMMAND_TXCNT
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_TXCNT
IAX_COMMAND_TXCNT
(f.subclass.integer != IAX_COMMAND_TXREADY)
f.subclass.integer != IAX_COMMAND_TXREADY
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_TXREADY
IAX_COMMAND_TXREADY
(f.subclass.integer != IAX_COMMAND_TXREL)
f.subclass.integer != IAX_COMMAND_TXREL
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_TXREL
IAX_COMMAND_TXREL
(f.subclass.integer != IAX_COMMAND_UNQUELCH )
f.subclass.integer != IAX_COMMAND_UNQUELCH
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_UNQUELCH
IAX_COMMAND_UNQUELCH
(f.subclass.integer != IAX_COMMAND_TXACC)
f.subclass.integer != IAX_COMMAND_TXACC
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_TXACC
IAX_COMMAND_TXACC
(f.subclass.integer != IAX_COMMAND_VNAK)
f.subclass.integer != IAX_COMMAND_VNAK
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_VNAK
IAX_COMMAND_VNAK
(f.frametype != AST_FRAME_IAX)
f.frametype != AST_FRAME_IAX
f.frametype
f
f
frametype
AST_FRAME_IAX
AST_FRAME_IAX
{				/* If it's not an ACK packet, it's out of order. */				ast_debug(1, "Packet arrived out of order (expecting %d, got %d) (frametype = %d, subclass = %d)\n",					iaxs[fr->callno]->iseqno, fr->oseqno, f.frametype, f.subclass.integer);				/* Check to see if we need to request retransmission,				 * and take sequence number wraparound into account */				if ((unsigned char) (iaxs[fr->callno]->iseqno - fr->oseqno) < 128) {					/* If we've already seen it, ack it XXX There's a border condition here XXX */					if ((f.frametype != AST_FRAME_IAX) ||							((f.subclass.integer != IAX_COMMAND_ACK) && (f.subclass.integer != IAX_COMMAND_INVAL))) {						ast_debug(1, "Acking anyway\n");						/* XXX Maybe we should handle its ack to us, but then again, it's probably outdated anyway, and if						   we have anything to send, we'll retransmit and get an ACK back anyway XXX */						send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					}				} else {					/* Send a VNAK requesting retransmission */					iax2_vnak(fr->callno);				}				ast_variables_destroy(ies.vars);				ast_mutex_unlock(&iaxsl[fr->callno]);				return 1;			}
ast_debug(1, "Packet arrived out of order (expecting %d, got %d) (frametype = %d, subclass = %d)\n",					iaxs[fr->callno]->iseqno, fr->oseqno, f.frametype, f.subclass.integer);
ast_debug(1, "Packet arrived out of order (expecting %d, got %d) (frametype = %d, subclass = %d)\n",					iaxs[fr->callno]->iseqno, fr->oseqno, f.frametype, f.subclass.integer)
ast_debug
ast_debug
1
"Packet arrived out of order (expecting %d, got %d) (frametype = %d, subclass = %d)\n"
iaxs[fr->callno]->iseqno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
iseqno
fr->oseqno
fr
fr
oseqno
f.frametype
f
f
frametype
f.subclass.integer
f.subclass
f
f
subclass
integer
if ((unsigned char) (iaxs[fr->callno]->iseqno - fr->oseqno) < 128) {					/* If we've already seen it, ack it XXX There's a border condition here XXX */					if ((f.frametype != AST_FRAME_IAX) ||							((f.subclass.integer != IAX_COMMAND_ACK) && (f.subclass.integer != IAX_COMMAND_INVAL))) {						ast_debug(1, "Acking anyway\n");						/* XXX Maybe we should handle its ack to us, but then again, it's probably outdated anyway, and if						   we have anything to send, we'll retransmit and get an ACK back anyway XXX */						send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					}				} else {					/* Send a VNAK requesting retransmission */					iax2_vnak(fr->callno);				}
(unsigned char) (iaxs[fr->callno]->iseqno - fr->oseqno) < 128
(unsigned char) (iaxs[fr->callno]->iseqno - fr->oseqno)
unsigned char
unsigned char

(iaxs[fr->callno]->iseqno - fr->oseqno)
iaxs[fr->callno]->iseqno - fr->oseqno
iaxs[fr->callno]->iseqno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
iseqno
fr->oseqno
fr
fr
oseqno
128
{					/* If we've already seen it, ack it XXX There's a border condition here XXX */					if ((f.frametype != AST_FRAME_IAX) ||							((f.subclass.integer != IAX_COMMAND_ACK) && (f.subclass.integer != IAX_COMMAND_INVAL))) {						ast_debug(1, "Acking anyway\n");						/* XXX Maybe we should handle its ack to us, but then again, it's probably outdated anyway, and if						   we have anything to send, we'll retransmit and get an ACK back anyway XXX */						send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					}				}
if ((f.frametype != AST_FRAME_IAX) ||							((f.subclass.integer != IAX_COMMAND_ACK) && (f.subclass.integer != IAX_COMMAND_INVAL))) {						ast_debug(1, "Acking anyway\n");						/* XXX Maybe we should handle its ack to us, but then again, it's probably outdated anyway, and if						   we have anything to send, we'll retransmit and get an ACK back anyway XXX */						send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					}
(f.frametype != AST_FRAME_IAX) ||							((f.subclass.integer != IAX_COMMAND_ACK) && (f.subclass.integer != IAX_COMMAND_INVAL))
(f.frametype != AST_FRAME_IAX)
f.frametype != AST_FRAME_IAX
f.frametype
f
f
frametype
AST_FRAME_IAX
AST_FRAME_IAX
((f.subclass.integer != IAX_COMMAND_ACK) && (f.subclass.integer != IAX_COMMAND_INVAL))
(f.subclass.integer != IAX_COMMAND_ACK) && (f.subclass.integer != IAX_COMMAND_INVAL)
(f.subclass.integer != IAX_COMMAND_ACK)
f.subclass.integer != IAX_COMMAND_ACK
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_ACK
IAX_COMMAND_ACK
(f.subclass.integer != IAX_COMMAND_INVAL)
f.subclass.integer != IAX_COMMAND_INVAL
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_INVAL
IAX_COMMAND_INVAL
{						ast_debug(1, "Acking anyway\n");						/* XXX Maybe we should handle its ack to us, but then again, it's probably outdated anyway, and if						   we have anything to send, we'll retransmit and get an ACK back anyway XXX */						send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					}
ast_debug(1, "Acking anyway\n");
ast_debug(1, "Acking anyway\n")
ast_debug
ast_debug
1
"Acking anyway\n"
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
send_command_immediate
send_command_immediate
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_ACK
IAX_COMMAND_ACK
fr->ts
fr
fr
ts
NULL
NULL
0
fr->iseqno
fr
fr
iseqno
{					/* Send a VNAK requesting retransmission */					iax2_vnak(fr->callno);				}
iax2_vnak(fr->callno);
iax2_vnak(fr->callno)
iax2_vnak
iax2_vnak
fr->callno
fr
fr
callno
ast_variables_destroy(ies.vars);
ast_variables_destroy(ies.vars)
ast_variables_destroy
ast_variables_destroy
ies.vars
ies
ies
vars
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock
ast_mutex_unlock
(&iaxsl[fr->callno])
&iaxsl[fr->callno]
&
iaxsl
[fr->callno]
fr->callno
fr
fr
callno
return 1;
1
{			/* Increment unless it's an ACK or VNAK */			if (((f.subclass.integer != IAX_COMMAND_ACK) &&			    (f.subclass.integer != IAX_COMMAND_INVAL) &&			    (f.subclass.integer != IAX_COMMAND_TXCNT) &&			    (f.subclass.integer != IAX_COMMAND_TXACC) &&				(f.subclass.integer != IAX_COMMAND_VNAK)) ||			    (f.frametype != AST_FRAME_IAX))				iaxs[fr->callno]->iseqno++;		}
if (((f.subclass.integer != IAX_COMMAND_ACK) &&			    (f.subclass.integer != IAX_COMMAND_INVAL) &&			    (f.subclass.integer != IAX_COMMAND_TXCNT) &&			    (f.subclass.integer != IAX_COMMAND_TXACC) &&				(f.subclass.integer != IAX_COMMAND_VNAK)) ||			    (f.frametype != AST_FRAME_IAX))				iaxs[fr->callno]->iseqno++;
((f.subclass.integer != IAX_COMMAND_ACK) &&			    (f.subclass.integer != IAX_COMMAND_INVAL) &&			    (f.subclass.integer != IAX_COMMAND_TXCNT) &&			    (f.subclass.integer != IAX_COMMAND_TXACC) &&				(f.subclass.integer != IAX_COMMAND_VNAK)) ||			    (f.frametype != AST_FRAME_IAX)
((f.subclass.integer != IAX_COMMAND_ACK) &&			    (f.subclass.integer != IAX_COMMAND_INVAL) &&			    (f.subclass.integer != IAX_COMMAND_TXCNT) &&			    (f.subclass.integer != IAX_COMMAND_TXACC) &&				(f.subclass.integer != IAX_COMMAND_VNAK))
(f.subclass.integer != IAX_COMMAND_ACK) &&			    (f.subclass.integer != IAX_COMMAND_INVAL) &&			    (f.subclass.integer != IAX_COMMAND_TXCNT) &&			    (f.subclass.integer != IAX_COMMAND_TXACC) &&				(f.subclass.integer != IAX_COMMAND_VNAK)
(f.subclass.integer != IAX_COMMAND_ACK) &&			    (f.subclass.integer != IAX_COMMAND_INVAL) &&			    (f.subclass.integer != IAX_COMMAND_TXCNT) &&			    (f.subclass.integer != IAX_COMMAND_TXACC)
(f.subclass.integer != IAX_COMMAND_ACK) &&			    (f.subclass.integer != IAX_COMMAND_INVAL) &&			    (f.subclass.integer != IAX_COMMAND_TXCNT)
(f.subclass.integer != IAX_COMMAND_ACK) &&			    (f.subclass.integer != IAX_COMMAND_INVAL)
(f.subclass.integer != IAX_COMMAND_ACK)
f.subclass.integer != IAX_COMMAND_ACK
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_ACK
IAX_COMMAND_ACK
(f.subclass.integer != IAX_COMMAND_INVAL)
f.subclass.integer != IAX_COMMAND_INVAL
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_INVAL
IAX_COMMAND_INVAL
(f.subclass.integer != IAX_COMMAND_TXCNT)
f.subclass.integer != IAX_COMMAND_TXCNT
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_TXCNT
IAX_COMMAND_TXCNT
(f.subclass.integer != IAX_COMMAND_TXACC)
f.subclass.integer != IAX_COMMAND_TXACC
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_TXACC
IAX_COMMAND_TXACC
(f.subclass.integer != IAX_COMMAND_VNAK)
f.subclass.integer != IAX_COMMAND_VNAK
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_VNAK
IAX_COMMAND_VNAK
(f.frametype != AST_FRAME_IAX)
f.frametype != AST_FRAME_IAX
f.frametype
f
f
frametype
AST_FRAME_IAX
AST_FRAME_IAX
iaxs[fr->callno]->iseqno++;
iaxs[fr->callno]->iseqno++
iaxs[fr->callno]->iseqno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
iseqno
if (f.frametype == AST_FRAME_TEXT && thread->buf[res - 1] != '\0') {			if (res < thread->buf_size)				thread->buf[res++] = '\0';			else /* Trims one character from the text message, but that's better than overwriting the end of the buffer. */				thread->buf[res - 1] = '\0';		}
f.frametype == AST_FRAME_TEXT && thread->buf[res - 1] != '\0'
f.frametype == AST_FRAME_TEXT
f.frametype
f
f
frametype
AST_FRAME_TEXT
AST_FRAME_TEXT
thread->buf[res - 1] != '\0'
thread->buf[res - 1]
thread->buf
thread
thread
buf
res - 1
res
res
1
'\0'
{			if (res < thread->buf_size)				thread->buf[res++] = '\0';			else /* Trims one character from the text message, but that's better than overwriting the end of the buffer. */				thread->buf[res - 1] = '\0';		}
if (res < thread->buf_size)				thread->buf[res++] = '\0';			else /* Trims one character from the text message, but that's better than overwriting the end of the buffer. */				thread->buf[res - 1] = '\0';
res < thread->buf_size
res
res
thread->buf_size
thread
thread
buf_size
thread->buf[res++] = '\0';
thread->buf[res++] = '\0'
thread->buf[res++]
thread->buf
thread
thread
buf
res++
res
res
'\0'
thread->buf[res - 1] = '\0';
thread->buf[res - 1] = '\0'
thread->buf[res - 1]
thread->buf
thread
thread
buf
res - 1
res
res
1
'\0'
if (!inaddrcmp(&sin, &iaxs[fr->callno]->addr) &&		    ((f.subclass.integer != IAX_COMMAND_INVAL) ||		     (f.frametype != AST_FRAME_IAX))) {			unsigned char x;			int call_to_destroy;			/* First we have to qualify that the ACKed value is within our window */			if (iaxs[fr->callno]->rseqno >= iaxs[fr->callno]->oseqno || (fr->iseqno >= iaxs[fr->callno]->rseqno && fr->iseqno < iaxs[fr->callno]->oseqno))				x = fr->iseqno;			else				x = iaxs[fr->callno]->oseqno;			if ((x != iaxs[fr->callno]->oseqno) || (iaxs[fr->callno]->oseqno == fr->iseqno)) {				/* The acknowledgement is within our window.  Time to acknowledge everything				   that it says to */				for (x=iaxs[fr->callno]->rseqno; x != fr->iseqno; x++) {					/* Ack the packet with the given timestamp */					if (iaxdebug)						ast_debug(1, "Cancelling transmission of packet %d\n", x);					call_to_destroy = 0;					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* If it's our call, and our timestamp, mark -1 retries */						if (x == cur->oseqno) {							cur->retries = -1;							/* Destroy call if this is the end */							if (cur->final)								call_to_destroy = fr->callno;						}					}					if (call_to_destroy) {						if (iaxdebug)							ast_debug(1, "Really destroying %d, having been acked on final message\n", call_to_destroy);						ast_mutex_lock(&iaxsl[call_to_destroy]);						iax2_destroy(call_to_destroy);						ast_mutex_unlock(&iaxsl[call_to_destroy]);					}				}				/* Note how much we've received acknowledgement for */				if (iaxs[fr->callno])					iaxs[fr->callno]->rseqno = fr->iseqno;				else {					/* Stop processing now */					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}			} else {				ast_debug(1, "Received iseqno %d not within window %d->%d\n", fr->iseqno, iaxs[fr->callno]->rseqno, iaxs[fr->callno]->oseqno);			}		}
!inaddrcmp(&sin, &iaxs[fr->callno]->addr) &&		    ((f.subclass.integer != IAX_COMMAND_INVAL) ||		     (f.frametype != AST_FRAME_IAX))
!inaddrcmp(&sin, &iaxs[fr->callno]->addr)
inaddrcmp(&sin, &iaxs[fr->callno]->addr)
inaddrcmp
inaddrcmp
&sin
sin
sin
&iaxs[fr->callno]->addr
iaxs[fr->callno]->addr
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
addr
((f.subclass.integer != IAX_COMMAND_INVAL) ||		     (f.frametype != AST_FRAME_IAX))
(f.subclass.integer != IAX_COMMAND_INVAL) ||		     (f.frametype != AST_FRAME_IAX)
(f.subclass.integer != IAX_COMMAND_INVAL)
f.subclass.integer != IAX_COMMAND_INVAL
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_INVAL
IAX_COMMAND_INVAL
(f.frametype != AST_FRAME_IAX)
f.frametype != AST_FRAME_IAX
f.frametype
f
f
frametype
AST_FRAME_IAX
AST_FRAME_IAX
{			unsigned char x;			int call_to_destroy;			/* First we have to qualify that the ACKed value is within our window */			if (iaxs[fr->callno]->rseqno >= iaxs[fr->callno]->oseqno || (fr->iseqno >= iaxs[fr->callno]->rseqno && fr->iseqno < iaxs[fr->callno]->oseqno))				x = fr->iseqno;			else				x = iaxs[fr->callno]->oseqno;			if ((x != iaxs[fr->callno]->oseqno) || (iaxs[fr->callno]->oseqno == fr->iseqno)) {				/* The acknowledgement is within our window.  Time to acknowledge everything				   that it says to */				for (x=iaxs[fr->callno]->rseqno; x != fr->iseqno; x++) {					/* Ack the packet with the given timestamp */					if (iaxdebug)						ast_debug(1, "Cancelling transmission of packet %d\n", x);					call_to_destroy = 0;					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* If it's our call, and our timestamp, mark -1 retries */						if (x == cur->oseqno) {							cur->retries = -1;							/* Destroy call if this is the end */							if (cur->final)								call_to_destroy = fr->callno;						}					}					if (call_to_destroy) {						if (iaxdebug)							ast_debug(1, "Really destroying %d, having been acked on final message\n", call_to_destroy);						ast_mutex_lock(&iaxsl[call_to_destroy]);						iax2_destroy(call_to_destroy);						ast_mutex_unlock(&iaxsl[call_to_destroy]);					}				}				/* Note how much we've received acknowledgement for */				if (iaxs[fr->callno])					iaxs[fr->callno]->rseqno = fr->iseqno;				else {					/* Stop processing now */					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}			} else {				ast_debug(1, "Received iseqno %d not within window %d->%d\n", fr->iseqno, iaxs[fr->callno]->rseqno, iaxs[fr->callno]->oseqno);			}		}
unsigned char x;
unsigned char x;
unsigned char
x
x
int call_to_destroy;
int call_to_destroy;
int
call_to_destroy
call_to_destroy
if (iaxs[fr->callno]->rseqno >= iaxs[fr->callno]->oseqno || (fr->iseqno >= iaxs[fr->callno]->rseqno && fr->iseqno < iaxs[fr->callno]->oseqno))				x = fr->iseqno;			else				x = iaxs[fr->callno]->oseqno;
iaxs[fr->callno]->rseqno >= iaxs[fr->callno]->oseqno || (fr->iseqno >= iaxs[fr->callno]->rseqno && fr->iseqno < iaxs[fr->callno]->oseqno)
iaxs[fr->callno]->rseqno >= iaxs[fr->callno]->oseqno
iaxs[fr->callno]->rseqno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
rseqno
iaxs[fr->callno]->oseqno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
oseqno
(fr->iseqno >= iaxs[fr->callno]->rseqno && fr->iseqno < iaxs[fr->callno]->oseqno)
fr->iseqno >= iaxs[fr->callno]->rseqno && fr->iseqno < iaxs[fr->callno]->oseqno
fr->iseqno >= iaxs[fr->callno]->rseqno
fr->iseqno
fr
fr
iseqno
iaxs[fr->callno]->rseqno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
rseqno
fr->iseqno < iaxs[fr->callno]->oseqno
fr->iseqno
fr
fr
iseqno
iaxs[fr->callno]->oseqno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
oseqno
x = fr->iseqno;
x = fr->iseqno
x
x
fr->iseqno
fr
fr
iseqno
x = iaxs[fr->callno]->oseqno;
x = iaxs[fr->callno]->oseqno
x
x
iaxs[fr->callno]->oseqno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
oseqno
if ((x != iaxs[fr->callno]->oseqno) || (iaxs[fr->callno]->oseqno == fr->iseqno)) {				/* The acknowledgement is within our window.  Time to acknowledge everything				   that it says to */				for (x=iaxs[fr->callno]->rseqno; x != fr->iseqno; x++) {					/* Ack the packet with the given timestamp */					if (iaxdebug)						ast_debug(1, "Cancelling transmission of packet %d\n", x);					call_to_destroy = 0;					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* If it's our call, and our timestamp, mark -1 retries */						if (x == cur->oseqno) {							cur->retries = -1;							/* Destroy call if this is the end */							if (cur->final)								call_to_destroy = fr->callno;						}					}					if (call_to_destroy) {						if (iaxdebug)							ast_debug(1, "Really destroying %d, having been acked on final message\n", call_to_destroy);						ast_mutex_lock(&iaxsl[call_to_destroy]);						iax2_destroy(call_to_destroy);						ast_mutex_unlock(&iaxsl[call_to_destroy]);					}				}				/* Note how much we've received acknowledgement for */				if (iaxs[fr->callno])					iaxs[fr->callno]->rseqno = fr->iseqno;				else {					/* Stop processing now */					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}			} else {				ast_debug(1, "Received iseqno %d not within window %d->%d\n", fr->iseqno, iaxs[fr->callno]->rseqno, iaxs[fr->callno]->oseqno);			}
(x != iaxs[fr->callno]->oseqno) || (iaxs[fr->callno]->oseqno == fr->iseqno)
(x != iaxs[fr->callno]->oseqno)
x != iaxs[fr->callno]->oseqno
x
x
iaxs[fr->callno]->oseqno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
oseqno
(iaxs[fr->callno]->oseqno == fr->iseqno)
iaxs[fr->callno]->oseqno == fr->iseqno
iaxs[fr->callno]->oseqno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
oseqno
fr->iseqno
fr
fr
iseqno
{				/* The acknowledgement is within our window.  Time to acknowledge everything				   that it says to */				for (x=iaxs[fr->callno]->rseqno; x != fr->iseqno; x++) {					/* Ack the packet with the given timestamp */					if (iaxdebug)						ast_debug(1, "Cancelling transmission of packet %d\n", x);					call_to_destroy = 0;					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* If it's our call, and our timestamp, mark -1 retries */						if (x == cur->oseqno) {							cur->retries = -1;							/* Destroy call if this is the end */							if (cur->final)								call_to_destroy = fr->callno;						}					}					if (call_to_destroy) {						if (iaxdebug)							ast_debug(1, "Really destroying %d, having been acked on final message\n", call_to_destroy);						ast_mutex_lock(&iaxsl[call_to_destroy]);						iax2_destroy(call_to_destroy);						ast_mutex_unlock(&iaxsl[call_to_destroy]);					}				}				/* Note how much we've received acknowledgement for */				if (iaxs[fr->callno])					iaxs[fr->callno]->rseqno = fr->iseqno;				else {					/* Stop processing now */					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}			}
for (x=iaxs[fr->callno]->rseqno; x != fr->iseqno; x++) {					/* Ack the packet with the given timestamp */					if (iaxdebug)						ast_debug(1, "Cancelling transmission of packet %d\n", x);					call_to_destroy = 0;					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* If it's our call, and our timestamp, mark -1 retries */						if (x == cur->oseqno) {							cur->retries = -1;							/* Destroy call if this is the end */							if (cur->final)								call_to_destroy = fr->callno;						}					}					if (call_to_destroy) {						if (iaxdebug)							ast_debug(1, "Really destroying %d, having been acked on final message\n", call_to_destroy);						ast_mutex_lock(&iaxsl[call_to_destroy]);						iax2_destroy(call_to_destroy);						ast_mutex_unlock(&iaxsl[call_to_destroy]);					}				}
x=iaxs[fr->callno]->rseqno;
x=iaxs[fr->callno]->rseqno
x
x
iaxs[fr->callno]->rseqno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
rseqno
x != fr->iseqno
x
x
fr->iseqno
fr
fr
iseqno
x++
x
x
{					/* Ack the packet with the given timestamp */					if (iaxdebug)						ast_debug(1, "Cancelling transmission of packet %d\n", x);					call_to_destroy = 0;					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* If it's our call, and our timestamp, mark -1 retries */						if (x == cur->oseqno) {							cur->retries = -1;							/* Destroy call if this is the end */							if (cur->final)								call_to_destroy = fr->callno;						}					}					if (call_to_destroy) {						if (iaxdebug)							ast_debug(1, "Really destroying %d, having been acked on final message\n", call_to_destroy);						ast_mutex_lock(&iaxsl[call_to_destroy]);						iax2_destroy(call_to_destroy);						ast_mutex_unlock(&iaxsl[call_to_destroy]);					}				}
if (iaxdebug)						ast_debug(1, "Cancelling transmission of packet %d\n", x);
iaxdebug
iaxdebug
ast_debug(1, "Cancelling transmission of packet %d\n", x);
ast_debug(1, "Cancelling transmission of packet %d\n", x)
ast_debug
ast_debug
1
"Cancelling transmission of packet %d\n"
x
x
call_to_destroy = 0;
call_to_destroy = 0
call_to_destroy
call_to_destroy
0
AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list)
AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list)
AST_LIST_TRAVERSE
AST_LIST_TRAVERSE
&frame_queue[fr->callno]
frame_queue[fr->callno]
frame_queue
frame_queue
fr->callno
fr
fr
callno
cur
cur
list
list
)
{						/* If it's our call, and our timestamp, mark -1 retries */						if (x == cur->oseqno) {							cur->retries = -1;							/* Destroy call if this is the end */							if (cur->final)								call_to_destroy = fr->callno;						}					}
if (x == cur->oseqno) {							cur->retries = -1;							/* Destroy call if this is the end */							if (cur->final)								call_to_destroy = fr->callno;						}
x == cur->oseqno
x
x
cur->oseqno
cur
cur
oseqno
{							cur->retries = -1;							/* Destroy call if this is the end */							if (cur->final)								call_to_destroy = fr->callno;						}
cur->retries = -1;
cur->retries = -1
cur->retries
cur
cur
retries
-1
1
if (cur->final)								call_to_destroy = fr->callno;
cur->final
cur
cur
final
call_to_destroy = fr->callno;
call_to_destroy = fr->callno
call_to_destroy
call_to_destroy
fr->callno
fr
fr
callno
if (call_to_destroy) {						if (iaxdebug)							ast_debug(1, "Really destroying %d, having been acked on final message\n", call_to_destroy);						ast_mutex_lock(&iaxsl[call_to_destroy]);						iax2_destroy(call_to_destroy);						ast_mutex_unlock(&iaxsl[call_to_destroy]);					}
call_to_destroy
call_to_destroy
{						if (iaxdebug)							ast_debug(1, "Really destroying %d, having been acked on final message\n", call_to_destroy);						ast_mutex_lock(&iaxsl[call_to_destroy]);						iax2_destroy(call_to_destroy);						ast_mutex_unlock(&iaxsl[call_to_destroy]);					}
if (iaxdebug)							ast_debug(1, "Really destroying %d, having been acked on final message\n", call_to_destroy);
iaxdebug
iaxdebug
ast_debug(1, "Really destroying %d, having been acked on final message\n", call_to_destroy);
ast_debug(1, "Really destroying %d, having been acked on final message\n", call_to_destroy)
ast_debug
ast_debug
1
"Really destroying %d, having been acked on final message\n"
call_to_destroy
call_to_destroy
ast_mutex_lock(&iaxsl[call_to_destroy]);
ast_mutex_lock(&iaxsl[call_to_destroy]);
ast_mutex_lock
ast_mutex_lock
(&iaxsl[call_to_destroy])
&iaxsl[call_to_destroy]
&
iaxsl
[call_to_destroy]
call_to_destroy
call_to_destroy
iax2_destroy(call_to_destroy);
iax2_destroy(call_to_destroy)
iax2_destroy
iax2_destroy
call_to_destroy
call_to_destroy
ast_mutex_unlock(&iaxsl[call_to_destroy]);
ast_mutex_unlock(&iaxsl[call_to_destroy])
ast_mutex_unlock
ast_mutex_unlock
&iaxsl[call_to_destroy]
iaxsl[call_to_destroy]
iaxsl
iaxsl
call_to_destroy
call_to_destroy
if (iaxs[fr->callno])					iaxs[fr->callno]->rseqno = fr->iseqno;				else {					/* Stop processing now */					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
iaxs[fr->callno]->rseqno = fr->iseqno;
iaxs[fr->callno]->rseqno = fr->iseqno
iaxs[fr->callno]->rseqno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
rseqno
fr->iseqno
fr
fr
iseqno
{					/* Stop processing now */					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}
ast_variables_destroy(ies.vars);
ast_variables_destroy(ies.vars)
ast_variables_destroy
ast_variables_destroy
ies.vars
ies
ies
vars
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock
ast_mutex_unlock
(&iaxsl[fr->callno])
&iaxsl[fr->callno]
&
iaxsl
[fr->callno]
fr->callno
fr
fr
callno
return 1;
1
{				ast_debug(1, "Received iseqno %d not within window %d->%d\n", fr->iseqno, iaxs[fr->callno]->rseqno, iaxs[fr->callno]->oseqno);			}
ast_debug(1, "Received iseqno %d not within window %d->%d\n", fr->iseqno, iaxs[fr->callno]->rseqno, iaxs[fr->callno]->oseqno);
ast_debug(1, "Received iseqno %d not within window %d->%d\n", fr->iseqno, iaxs[fr->callno]->rseqno, iaxs[fr->callno]->oseqno)
ast_debug
ast_debug
1
"Received iseqno %d not within window %d->%d\n"
fr->iseqno
fr
fr
iseqno
iaxs[fr->callno]->rseqno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
rseqno
iaxs[fr->callno]->oseqno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
oseqno
if (inaddrcmp(&sin, &iaxs[fr->callno]->addr) &&			((f.frametype != AST_FRAME_IAX) ||			 ((f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT)))) {			/* Only messages we accept from a transfer host are TXACC and TXCNT */			ast_variables_destroy(ies.vars);			ast_mutex_unlock(&iaxsl[fr->callno]);			return 1;		}
inaddrcmp(&sin, &iaxs[fr->callno]->addr) &&			((f.frametype != AST_FRAME_IAX) ||			 ((f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT)))
inaddrcmp(&sin, &iaxs[fr->callno]->addr)
inaddrcmp
inaddrcmp
&sin
sin
sin
&iaxs[fr->callno]->addr
iaxs[fr->callno]->addr
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
addr
((f.frametype != AST_FRAME_IAX) ||			 ((f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT)))
(f.frametype != AST_FRAME_IAX) ||			 ((f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT))
(f.frametype != AST_FRAME_IAX)
f.frametype != AST_FRAME_IAX
f.frametype
f
f
frametype
AST_FRAME_IAX
AST_FRAME_IAX
((f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT))
(f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT)
(f.subclass.integer != IAX_COMMAND_TXACC)
f.subclass.integer != IAX_COMMAND_TXACC
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_TXACC
IAX_COMMAND_TXACC
(f.subclass.integer != IAX_COMMAND_TXCNT)
f.subclass.integer != IAX_COMMAND_TXCNT
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_TXCNT
IAX_COMMAND_TXCNT
{			/* Only messages we accept from a transfer host are TXACC and TXCNT */			ast_variables_destroy(ies.vars);			ast_mutex_unlock(&iaxsl[fr->callno]);			return 1;		}
ast_variables_destroy(ies.vars);
ast_variables_destroy(ies.vars)
ast_variables_destroy
ast_variables_destroy
ies.vars
ies
ies
vars
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock
ast_mutex_unlock
(&iaxsl[fr->callno])
&iaxsl[fr->callno]
&
iaxsl
[fr->callno]
fr->callno
fr
fr
callno
return 1;
1
if ((f.frametype == AST_FRAME_VOICE) ||		    (f.frametype == AST_FRAME_VIDEO) ||		    (f.frametype == AST_FRAME_IAX)) {			if (ast_test_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART)) {				ast_clear_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);				if (!ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->chosenformat, NULL)) {					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}			}			if (ies.vars) {				struct ast_datastore *variablestore = NULL;				struct ast_variable *var, *prev = NULL;				AST_LIST_HEAD(, ast_var_t) *varlist;				iax2_lock_owner(fr->callno);				if (!iaxs[fr->callno]) {					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}				if ((c = iaxs[fr->callno]->owner)) {					varlist = ast_calloc(1, sizeof(*varlist));					variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);					if (variablestore && varlist) {						variablestore->data = varlist;						variablestore->inheritance = DATASTORE_INHERIT_FOREVER;						AST_LIST_HEAD_INIT(varlist);						ast_debug(1, "I can haz IAX vars?\n");						for (var = ies.vars; var; var = var->next) {							struct ast_var_t *newvar = ast_var_assign(var->name, var->value);							if (prev) {								ast_free(prev);							}							prev = var;							if (!newvar) {								/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");							} else {								AST_LIST_INSERT_TAIL(varlist, newvar, entries);							}						}						if (prev) {							ast_free(prev);						}						ies.vars = NULL;						ast_channel_datastore_add(c, variablestore);					} else {						ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");						if (variablestore) {							ast_datastore_free(variablestore);						}						if (varlist) {							ast_free(varlist);						}					}					ast_channel_unlock(c);				} else {					/* No channel yet, so transfer the variables directly over to the pvt,					 * for later inheritance. */					ast_debug(1, "No channel, so populating IAXVARs to the pvt, as an intermediate step.\n");					for (var = ies.vars; var && var->next; var = var->next);					if (var) {						var->next = iaxs[fr->callno]->iaxvars;						iaxs[fr->callno]->iaxvars = ies.vars;						ies.vars = NULL;					}				}			}			if (ies.vars) {				ast_debug(1, "I have IAX variables, but they were not processed\n");			}		}
(f.frametype == AST_FRAME_VOICE) ||		    (f.frametype == AST_FRAME_VIDEO) ||		    (f.frametype == AST_FRAME_IAX)
(f.frametype == AST_FRAME_VOICE) ||		    (f.frametype == AST_FRAME_VIDEO)
(f.frametype == AST_FRAME_VOICE)
f.frametype == AST_FRAME_VOICE
f.frametype
f
f
frametype
AST_FRAME_VOICE
AST_FRAME_VOICE
(f.frametype == AST_FRAME_VIDEO)
f.frametype == AST_FRAME_VIDEO
f.frametype
f
f
frametype
AST_FRAME_VIDEO
AST_FRAME_VIDEO
(f.frametype == AST_FRAME_IAX)
f.frametype == AST_FRAME_IAX
f.frametype
f
f
frametype
AST_FRAME_IAX
AST_FRAME_IAX
{			if (ast_test_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART)) {				ast_clear_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);				if (!ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->chosenformat, NULL)) {					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}			}			if (ies.vars) {				struct ast_datastore *variablestore = NULL;				struct ast_variable *var, *prev = NULL;				AST_LIST_HEAD(, ast_var_t) *varlist;				iax2_lock_owner(fr->callno);				if (!iaxs[fr->callno]) {					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}				if ((c = iaxs[fr->callno]->owner)) {					varlist = ast_calloc(1, sizeof(*varlist));					variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);					if (variablestore && varlist) {						variablestore->data = varlist;						variablestore->inheritance = DATASTORE_INHERIT_FOREVER;						AST_LIST_HEAD_INIT(varlist);						ast_debug(1, "I can haz IAX vars?\n");						for (var = ies.vars; var; var = var->next) {							struct ast_var_t *newvar = ast_var_assign(var->name, var->value);							if (prev) {								ast_free(prev);							}							prev = var;							if (!newvar) {								/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");							} else {								AST_LIST_INSERT_TAIL(varlist, newvar, entries);							}						}						if (prev) {							ast_free(prev);						}						ies.vars = NULL;						ast_channel_datastore_add(c, variablestore);					} else {						ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");						if (variablestore) {							ast_datastore_free(variablestore);						}						if (varlist) {							ast_free(varlist);						}					}					ast_channel_unlock(c);				} else {					/* No channel yet, so transfer the variables directly over to the pvt,					 * for later inheritance. */					ast_debug(1, "No channel, so populating IAXVARs to the pvt, as an intermediate step.\n");					for (var = ies.vars; var && var->next; var = var->next);					if (var) {						var->next = iaxs[fr->callno]->iaxvars;						iaxs[fr->callno]->iaxvars = ies.vars;						ies.vars = NULL;					}				}			}			if (ies.vars) {				ast_debug(1, "I have IAX variables, but they were not processed\n");			}		}
if (ast_test_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART)) {				ast_clear_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);				if (!ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->chosenformat, NULL)) {					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}			}
ast_test_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_DELAYPBXSTART
IAX_DELAYPBXSTART
{				ast_clear_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);				if (!ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->chosenformat, NULL)) {					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}			}
ast_clear_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);
ast_clear_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART)
ast_clear_flag64
ast_clear_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_DELAYPBXSTART
IAX_DELAYPBXSTART
if (!ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->chosenformat, NULL)) {					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}
!ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->chosenformat, NULL)
ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->chosenformat, NULL)
ast_iax2_new
ast_iax2_new
fr->callno
fr
fr
callno
AST_STATE_RING
AST_STATE_RING
iaxs[fr->callno]->chosenformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
chosenformat
NULL
NULL
{					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}
ast_variables_destroy(ies.vars);
ast_variables_destroy(ies.vars)
ast_variables_destroy
ast_variables_destroy
ies.vars
ies
ies
vars
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock
ast_mutex_unlock
(&iaxsl[fr->callno])
&iaxsl[fr->callno]
&
iaxsl
[fr->callno]
fr->callno
fr
fr
callno
return 1;
1
if (ies.vars) {				struct ast_datastore *variablestore = NULL;				struct ast_variable *var, *prev = NULL;				AST_LIST_HEAD(, ast_var_t) *varlist;				iax2_lock_owner(fr->callno);				if (!iaxs[fr->callno]) {					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}				if ((c = iaxs[fr->callno]->owner)) {					varlist = ast_calloc(1, sizeof(*varlist));					variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);					if (variablestore && varlist) {						variablestore->data = varlist;						variablestore->inheritance = DATASTORE_INHERIT_FOREVER;						AST_LIST_HEAD_INIT(varlist);						ast_debug(1, "I can haz IAX vars?\n");						for (var = ies.vars; var; var = var->next) {							struct ast_var_t *newvar = ast_var_assign(var->name, var->value);							if (prev) {								ast_free(prev);							}							prev = var;							if (!newvar) {								/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");							} else {								AST_LIST_INSERT_TAIL(varlist, newvar, entries);							}						}						if (prev) {							ast_free(prev);						}						ies.vars = NULL;						ast_channel_datastore_add(c, variablestore);					} else {						ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");						if (variablestore) {							ast_datastore_free(variablestore);						}						if (varlist) {							ast_free(varlist);						}					}					ast_channel_unlock(c);				} else {					/* No channel yet, so transfer the variables directly over to the pvt,					 * for later inheritance. */					ast_debug(1, "No channel, so populating IAXVARs to the pvt, as an intermediate step.\n");					for (var = ies.vars; var && var->next; var = var->next);					if (var) {						var->next = iaxs[fr->callno]->iaxvars;						iaxs[fr->callno]->iaxvars = ies.vars;						ies.vars = NULL;					}				}			}
ies.vars
ies
ies
vars
{				struct ast_datastore *variablestore = NULL;				struct ast_variable *var, *prev = NULL;				AST_LIST_HEAD(, ast_var_t) *varlist;				iax2_lock_owner(fr->callno);				if (!iaxs[fr->callno]) {					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}				if ((c = iaxs[fr->callno]->owner)) {					varlist = ast_calloc(1, sizeof(*varlist));					variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);					if (variablestore && varlist) {						variablestore->data = varlist;						variablestore->inheritance = DATASTORE_INHERIT_FOREVER;						AST_LIST_HEAD_INIT(varlist);						ast_debug(1, "I can haz IAX vars?\n");						for (var = ies.vars; var; var = var->next) {							struct ast_var_t *newvar = ast_var_assign(var->name, var->value);							if (prev) {								ast_free(prev);							}							prev = var;							if (!newvar) {								/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");							} else {								AST_LIST_INSERT_TAIL(varlist, newvar, entries);							}						}						if (prev) {							ast_free(prev);						}						ies.vars = NULL;						ast_channel_datastore_add(c, variablestore);					} else {						ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");						if (variablestore) {							ast_datastore_free(variablestore);						}						if (varlist) {							ast_free(varlist);						}					}					ast_channel_unlock(c);				} else {					/* No channel yet, so transfer the variables directly over to the pvt,					 * for later inheritance. */					ast_debug(1, "No channel, so populating IAXVARs to the pvt, as an intermediate step.\n");					for (var = ies.vars; var && var->next; var = var->next);					if (var) {						var->next = iaxs[fr->callno]->iaxvars;						iaxs[fr->callno]->iaxvars = ies.vars;						ies.vars = NULL;					}				}			}
struct ast_datastore *variablestore = NULL;
struct ast_datastore *variablestore = NULL;
struct ast_datastore
ast_datastore
*variablestore = NULL
*
variablestore
= NULL
NULL
NULL
struct ast_variable *var, *prev = NULL;
struct ast_variable *var, *prev = NULL;
struct ast_variable
ast_variable
*var
*
var
*prev = NULL
*
prev
= NULL
NULL
NULL
AST_LIST_HEAD(, ast_var_t) *varlist;
iax2_lock_owner(fr->callno);
iax2_lock_owner(fr->callno)
iax2_lock_owner
iax2_lock_owner
fr->callno
fr
fr
callno
if (!iaxs[fr->callno]) {					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}
!iaxs[fr->callno]
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{					ast_variables_destroy(ies.vars);					ast_mutex_unlock(&iaxsl[fr->callno]);					return 1;				}
ast_variables_destroy(ies.vars);
ast_variables_destroy(ies.vars)
ast_variables_destroy
ast_variables_destroy
ies.vars
ies
ies
vars
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock
ast_mutex_unlock
(&iaxsl[fr->callno])
&iaxsl[fr->callno]
&
iaxsl
[fr->callno]
fr->callno
fr
fr
callno
return 1;
1
if ((c = iaxs[fr->callno]->owner)) {					varlist = ast_calloc(1, sizeof(*varlist));					variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);					if (variablestore && varlist) {						variablestore->data = varlist;						variablestore->inheritance = DATASTORE_INHERIT_FOREVER;						AST_LIST_HEAD_INIT(varlist);						ast_debug(1, "I can haz IAX vars?\n");						for (var = ies.vars; var; var = var->next) {							struct ast_var_t *newvar = ast_var_assign(var->name, var->value);							if (prev) {								ast_free(prev);							}							prev = var;							if (!newvar) {								/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");							} else {								AST_LIST_INSERT_TAIL(varlist, newvar, entries);							}						}						if (prev) {							ast_free(prev);						}						ies.vars = NULL;						ast_channel_datastore_add(c, variablestore);					} else {						ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");						if (variablestore) {							ast_datastore_free(variablestore);						}						if (varlist) {							ast_free(varlist);						}					}					ast_channel_unlock(c);				} else {					/* No channel yet, so transfer the variables directly over to the pvt,					 * for later inheritance. */					ast_debug(1, "No channel, so populating IAXVARs to the pvt, as an intermediate step.\n");					for (var = ies.vars; var && var->next; var = var->next);					if (var) {						var->next = iaxs[fr->callno]->iaxvars;						iaxs[fr->callno]->iaxvars = ies.vars;						ies.vars = NULL;					}				}
(c = iaxs[fr->callno]->owner)
c = iaxs[fr->callno]->owner
c
c
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
{					varlist = ast_calloc(1, sizeof(*varlist));					variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);					if (variablestore && varlist) {						variablestore->data = varlist;						variablestore->inheritance = DATASTORE_INHERIT_FOREVER;						AST_LIST_HEAD_INIT(varlist);						ast_debug(1, "I can haz IAX vars?\n");						for (var = ies.vars; var; var = var->next) {							struct ast_var_t *newvar = ast_var_assign(var->name, var->value);							if (prev) {								ast_free(prev);							}							prev = var;							if (!newvar) {								/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");							} else {								AST_LIST_INSERT_TAIL(varlist, newvar, entries);							}						}						if (prev) {							ast_free(prev);						}						ies.vars = NULL;						ast_channel_datastore_add(c, variablestore);					} else {						ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");						if (variablestore) {							ast_datastore_free(variablestore);						}						if (varlist) {							ast_free(varlist);						}					}					ast_channel_unlock(c);				}
varlist = ast_calloc(1, sizeof(*varlist));
varlist = ast_calloc(1, sizeof(*varlist))
varlist
varlist
ast_calloc(1, sizeof(*varlist))
ast_calloc
ast_calloc
1
sizeof(*varlist)
(*varlist)
*varlist
varlist
varlist
variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);
variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL)
variablestore
variablestore
ast_datastore_alloc(&iax2_variable_datastore_info, NULL)
ast_datastore_alloc
ast_datastore_alloc
&iax2_variable_datastore_info
iax2_variable_datastore_info
iax2_variable_datastore_info
NULL
NULL
if (variablestore && varlist) {						variablestore->data = varlist;						variablestore->inheritance = DATASTORE_INHERIT_FOREVER;						AST_LIST_HEAD_INIT(varlist);						ast_debug(1, "I can haz IAX vars?\n");						for (var = ies.vars; var; var = var->next) {							struct ast_var_t *newvar = ast_var_assign(var->name, var->value);							if (prev) {								ast_free(prev);							}							prev = var;							if (!newvar) {								/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");							} else {								AST_LIST_INSERT_TAIL(varlist, newvar, entries);							}						}						if (prev) {							ast_free(prev);						}						ies.vars = NULL;						ast_channel_datastore_add(c, variablestore);					} else {						ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");						if (variablestore) {							ast_datastore_free(variablestore);						}						if (varlist) {							ast_free(varlist);						}					}
variablestore && varlist
variablestore
variablestore
varlist
varlist
{						variablestore->data = varlist;						variablestore->inheritance = DATASTORE_INHERIT_FOREVER;						AST_LIST_HEAD_INIT(varlist);						ast_debug(1, "I can haz IAX vars?\n");						for (var = ies.vars; var; var = var->next) {							struct ast_var_t *newvar = ast_var_assign(var->name, var->value);							if (prev) {								ast_free(prev);							}							prev = var;							if (!newvar) {								/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");							} else {								AST_LIST_INSERT_TAIL(varlist, newvar, entries);							}						}						if (prev) {							ast_free(prev);						}						ies.vars = NULL;						ast_channel_datastore_add(c, variablestore);					}
variablestore->data = varlist;
variablestore->data = varlist
variablestore->data
variablestore
variablestore
data
varlist
varlist
variablestore->inheritance = DATASTORE_INHERIT_FOREVER;
variablestore->inheritance = DATASTORE_INHERIT_FOREVER
variablestore->inheritance
variablestore
variablestore
inheritance
DATASTORE_INHERIT_FOREVER
DATASTORE_INHERIT_FOREVER
AST_LIST_HEAD_INIT(varlist);
AST_LIST_HEAD_INIT(varlist);
AST_LIST_HEAD_INIT
AST_LIST_HEAD_INIT
(varlist)
varlist
varlist
ast_debug(1, "I can haz IAX vars?\n");
ast_debug(1, "I can haz IAX vars?\n")
ast_debug
ast_debug
1
"I can haz IAX vars?\n"
for (var = ies.vars; var; var = var->next) {							struct ast_var_t *newvar = ast_var_assign(var->name, var->value);							if (prev) {								ast_free(prev);							}							prev = var;							if (!newvar) {								/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");							} else {								AST_LIST_INSERT_TAIL(varlist, newvar, entries);							}						}
var = ies.vars;
var = ies.vars
var
var
ies.vars
ies
ies
vars
var
var
var = var->next
var
var
var->next
var
var
next
{							struct ast_var_t *newvar = ast_var_assign(var->name, var->value);							if (prev) {								ast_free(prev);							}							prev = var;							if (!newvar) {								/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");							} else {								AST_LIST_INSERT_TAIL(varlist, newvar, entries);							}						}
struct ast_var_t *newvar = ast_var_assign(var->name, var->value);
struct ast_var_t *newvar = ast_var_assign(var->name, var->value);
struct ast_var_t
ast_var_t
*newvar = ast_var_assign(var->name, var->value)
*
newvar
= ast_var_assign(var->name, var->value)
ast_var_assign(var->name, var->value)
ast_var_assign
ast_var_assign
var->name
var
var
name
var->value
var
var
value
if (prev) {								ast_free(prev);							}
prev
prev
{								ast_free(prev);							}
ast_free(prev);
ast_free(prev)
ast_free
ast_free
prev
prev
prev = var;
prev = var
prev
prev
var
var
if (!newvar) {								/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");							} else {								AST_LIST_INSERT_TAIL(varlist, newvar, entries);							}
!newvar
newvar
newvar
{								/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");							}
ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");
ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n")
ast_log
ast_log
LOG_ERROR
LOG_ERROR
"Memory allocation error while processing IAX2 variables\n"
{								AST_LIST_INSERT_TAIL(varlist, newvar, entries);							}
AST_LIST_INSERT_TAIL(varlist, newvar, entries);
AST_LIST_INSERT_TAIL(varlist, newvar, entries)
AST_LIST_INSERT_TAIL
AST_LIST_INSERT_TAIL
varlist
varlist
newvar
newvar
entries
entries
if (prev) {							ast_free(prev);						}
prev
prev
{							ast_free(prev);						}
ast_free(prev);
ast_free(prev)
ast_free
ast_free
prev
prev
ies.vars = NULL;
ies.vars = NULL
ies.vars
ies
ies
vars
NULL
NULL
ast_channel_datastore_add(c, variablestore);
ast_channel_datastore_add(c, variablestore)
ast_channel_datastore_add
ast_channel_datastore_add
c
c
variablestore
variablestore
{						ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");						if (variablestore) {							ast_datastore_free(variablestore);						}						if (varlist) {							ast_free(varlist);						}					}
ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");
ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n")
ast_log
ast_log
LOG_ERROR
LOG_ERROR
"Memory allocation error while processing IAX2 variables\n"
if (variablestore) {							ast_datastore_free(variablestore);						}
variablestore
variablestore
{							ast_datastore_free(variablestore);						}
ast_datastore_free(variablestore);
ast_datastore_free(variablestore)
ast_datastore_free
ast_datastore_free
variablestore
variablestore
if (varlist) {							ast_free(varlist);						}
varlist
varlist
{							ast_free(varlist);						}
ast_free(varlist);
ast_free(varlist);
ast_free
ast_free
(varlist)
varlist
varlist
ast_channel_unlock(c);
ast_channel_unlock(c)
ast_channel_unlock
ast_channel_unlock
c
c
{					/* No channel yet, so transfer the variables directly over to the pvt,					 * for later inheritance. */					ast_debug(1, "No channel, so populating IAXVARs to the pvt, as an intermediate step.\n");					for (var = ies.vars; var && var->next; var = var->next);					if (var) {						var->next = iaxs[fr->callno]->iaxvars;						iaxs[fr->callno]->iaxvars = ies.vars;						ies.vars = NULL;					}				}
ast_debug(1, "No channel, so populating IAXVARs to the pvt, as an intermediate step.\n");
ast_debug(1, "No channel, so populating IAXVARs to the pvt, as an intermediate step.\n")
ast_debug
ast_debug
1
"No channel, so populating IAXVARs to the pvt, as an intermediate step.\n"
for (var = ies.vars; var && var->next; var = var->next);
var = ies.vars;
var = ies.vars
var
var
ies.vars
ies
ies
vars
var && var->next
var
var
var->next
var
var
next
var = var->next
var
var
var->next
var
var
next
;
if (var) {						var->next = iaxs[fr->callno]->iaxvars;						iaxs[fr->callno]->iaxvars = ies.vars;						ies.vars = NULL;					}
var
var
{						var->next = iaxs[fr->callno]->iaxvars;						iaxs[fr->callno]->iaxvars = ies.vars;						ies.vars = NULL;					}
var->next = iaxs[fr->callno]->iaxvars;
var->next = iaxs[fr->callno]->iaxvars
var->next
var
var
next
iaxs[fr->callno]->iaxvars
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
iaxvars
iaxs[fr->callno]->iaxvars = ies.vars;
iaxs[fr->callno]->iaxvars = ies.vars
iaxs[fr->callno]->iaxvars
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
iaxvars
ies.vars
ies
ies
vars
ies.vars = NULL;
ies.vars = NULL
ies.vars
ies
ies
vars
NULL
NULL
if (ies.vars) {				ast_debug(1, "I have IAX variables, but they were not processed\n");			}
ies.vars
ies
ies
vars
{				ast_debug(1, "I have IAX variables, but they were not processed\n");			}
ast_debug(1, "I have IAX variables, but they were not processed\n");
ast_debug(1, "I have IAX variables, but they were not processed\n")
ast_debug
ast_debug
1
"I have IAX variables, but they were not processed\n"
if ((f.frametype == AST_FRAME_IAX) && (f.subclass.integer != IAX_COMMAND_CALLTOKEN) && iaxs[fr->callno]->hold_signaling) {			send_signaling(iaxs[fr->callno]);		}
(f.frametype == AST_FRAME_IAX) && (f.subclass.integer != IAX_COMMAND_CALLTOKEN) && iaxs[fr->callno]->hold_signaling
(f.frametype == AST_FRAME_IAX) && (f.subclass.integer != IAX_COMMAND_CALLTOKEN)
(f.frametype == AST_FRAME_IAX)
f.frametype == AST_FRAME_IAX
f.frametype
f
f
frametype
AST_FRAME_IAX
AST_FRAME_IAX
(f.subclass.integer != IAX_COMMAND_CALLTOKEN)
f.subclass.integer != IAX_COMMAND_CALLTOKEN
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_CALLTOKEN
IAX_COMMAND_CALLTOKEN
iaxs[fr->callno]->hold_signaling
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
hold_signaling
{			send_signaling(iaxs[fr->callno]);		}
send_signaling(iaxs[fr->callno]);
send_signaling(iaxs[fr->callno]);
send_signaling
send_signaling
(iaxs[fr->callno])
iaxs[fr->callno]
iaxs
[fr->callno]
fr->callno
fr
fr
callno
if (f.frametype == AST_FRAME_VOICE) {			if (ast_format_to_old_bitfield(&f.subclass.format) != iaxs[fr->callno]->voiceformat) {					iaxs[fr->callno]->voiceformat = ast_format_to_old_bitfield(&f.subclass.format);					ast_debug(1, "Ooh, voice format changed to '%s'\n", ast_getformatname(&f.subclass.format));					if (iaxs[fr->callno]->owner) {						iax2_lock_owner(fr->callno);						if (iaxs[fr->callno]) {							if (iaxs[fr->callno]->owner) {								struct ast_format_cap *orignative = ast_format_cap_dup(ast_channel_nativeformats(iaxs[fr->callno]->owner));								struct ast_format_cap *native = ast_channel_nativeformats(iaxs[fr->callno]->owner);								if (orignative) {									ast_format_cap_set(native, &f.subclass.format);									if (ast_channel_readformat(iaxs[fr->callno]->owner)->id) {										ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));									}									ast_format_cap_copy(native, orignative);									ast_channel_unlock(iaxs[fr->callno]->owner);									orignative = ast_format_cap_destroy(orignative);								}							}						} else {							ast_debug(1, "Neat, somebody took away the channel at a magical time but i found it!\n");							/* Free remote variables (if any) */							if (ies.vars) {								ast_variables_destroy(ies.vars);								ast_debug(1, "I can haz iaxvars, but they is no good.  :-(\n");								ies.vars = NULL;							}							ast_mutex_unlock(&iaxsl[fr->callno]);							return 1;						}					}			}		}
f.frametype == AST_FRAME_VOICE
f.frametype
f
f
frametype
AST_FRAME_VOICE
AST_FRAME_VOICE
{			if (ast_format_to_old_bitfield(&f.subclass.format) != iaxs[fr->callno]->voiceformat) {					iaxs[fr->callno]->voiceformat = ast_format_to_old_bitfield(&f.subclass.format);					ast_debug(1, "Ooh, voice format changed to '%s'\n", ast_getformatname(&f.subclass.format));					if (iaxs[fr->callno]->owner) {						iax2_lock_owner(fr->callno);						if (iaxs[fr->callno]) {							if (iaxs[fr->callno]->owner) {								struct ast_format_cap *orignative = ast_format_cap_dup(ast_channel_nativeformats(iaxs[fr->callno]->owner));								struct ast_format_cap *native = ast_channel_nativeformats(iaxs[fr->callno]->owner);								if (orignative) {									ast_format_cap_set(native, &f.subclass.format);									if (ast_channel_readformat(iaxs[fr->callno]->owner)->id) {										ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));									}									ast_format_cap_copy(native, orignative);									ast_channel_unlock(iaxs[fr->callno]->owner);									orignative = ast_format_cap_destroy(orignative);								}							}						} else {							ast_debug(1, "Neat, somebody took away the channel at a magical time but i found it!\n");							/* Free remote variables (if any) */							if (ies.vars) {								ast_variables_destroy(ies.vars);								ast_debug(1, "I can haz iaxvars, but they is no good.  :-(\n");								ies.vars = NULL;							}							ast_mutex_unlock(&iaxsl[fr->callno]);							return 1;						}					}			}		}
if (ast_format_to_old_bitfield(&f.subclass.format) != iaxs[fr->callno]->voiceformat) {					iaxs[fr->callno]->voiceformat = ast_format_to_old_bitfield(&f.subclass.format);					ast_debug(1, "Ooh, voice format changed to '%s'\n", ast_getformatname(&f.subclass.format));					if (iaxs[fr->callno]->owner) {						iax2_lock_owner(fr->callno);						if (iaxs[fr->callno]) {							if (iaxs[fr->callno]->owner) {								struct ast_format_cap *orignative = ast_format_cap_dup(ast_channel_nativeformats(iaxs[fr->callno]->owner));								struct ast_format_cap *native = ast_channel_nativeformats(iaxs[fr->callno]->owner);								if (orignative) {									ast_format_cap_set(native, &f.subclass.format);									if (ast_channel_readformat(iaxs[fr->callno]->owner)->id) {										ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));									}									ast_format_cap_copy(native, orignative);									ast_channel_unlock(iaxs[fr->callno]->owner);									orignative = ast_format_cap_destroy(orignative);								}							}						} else {							ast_debug(1, "Neat, somebody took away the channel at a magical time but i found it!\n");							/* Free remote variables (if any) */							if (ies.vars) {								ast_variables_destroy(ies.vars);								ast_debug(1, "I can haz iaxvars, but they is no good.  :-(\n");								ies.vars = NULL;							}							ast_mutex_unlock(&iaxsl[fr->callno]);							return 1;						}					}			}
ast_format_to_old_bitfield(&f.subclass.format) != iaxs[fr->callno]->voiceformat
ast_format_to_old_bitfield(&f.subclass.format)
ast_format_to_old_bitfield
ast_format_to_old_bitfield
&f.subclass.format
f.subclass.format
f.subclass
f
f
subclass
format
iaxs[fr->callno]->voiceformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
voiceformat
{					iaxs[fr->callno]->voiceformat = ast_format_to_old_bitfield(&f.subclass.format);					ast_debug(1, "Ooh, voice format changed to '%s'\n", ast_getformatname(&f.subclass.format));					if (iaxs[fr->callno]->owner) {						iax2_lock_owner(fr->callno);						if (iaxs[fr->callno]) {							if (iaxs[fr->callno]->owner) {								struct ast_format_cap *orignative = ast_format_cap_dup(ast_channel_nativeformats(iaxs[fr->callno]->owner));								struct ast_format_cap *native = ast_channel_nativeformats(iaxs[fr->callno]->owner);								if (orignative) {									ast_format_cap_set(native, &f.subclass.format);									if (ast_channel_readformat(iaxs[fr->callno]->owner)->id) {										ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));									}									ast_format_cap_copy(native, orignative);									ast_channel_unlock(iaxs[fr->callno]->owner);									orignative = ast_format_cap_destroy(orignative);								}							}						} else {							ast_debug(1, "Neat, somebody took away the channel at a magical time but i found it!\n");							/* Free remote variables (if any) */							if (ies.vars) {								ast_variables_destroy(ies.vars);								ast_debug(1, "I can haz iaxvars, but they is no good.  :-(\n");								ies.vars = NULL;							}							ast_mutex_unlock(&iaxsl[fr->callno]);							return 1;						}					}			}
iaxs[fr->callno]->voiceformat = ast_format_to_old_bitfield(&f.subclass.format);
iaxs[fr->callno]->voiceformat = ast_format_to_old_bitfield(&f.subclass.format)
iaxs[fr->callno]->voiceformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
voiceformat
ast_format_to_old_bitfield(&f.subclass.format)
ast_format_to_old_bitfield
ast_format_to_old_bitfield
&f.subclass.format
f.subclass.format
f.subclass
f
f
subclass
format
ast_debug(1, "Ooh, voice format changed to '%s'\n", ast_getformatname(&f.subclass.format));
ast_debug(1, "Ooh, voice format changed to '%s'\n", ast_getformatname(&f.subclass.format))
ast_debug
ast_debug
1
"Ooh, voice format changed to '%s'\n"
ast_getformatname(&f.subclass.format)
ast_getformatname
ast_getformatname
&f.subclass.format
f.subclass.format
f.subclass
f
f
subclass
format
if (iaxs[fr->callno]->owner) {						iax2_lock_owner(fr->callno);						if (iaxs[fr->callno]) {							if (iaxs[fr->callno]->owner) {								struct ast_format_cap *orignative = ast_format_cap_dup(ast_channel_nativeformats(iaxs[fr->callno]->owner));								struct ast_format_cap *native = ast_channel_nativeformats(iaxs[fr->callno]->owner);								if (orignative) {									ast_format_cap_set(native, &f.subclass.format);									if (ast_channel_readformat(iaxs[fr->callno]->owner)->id) {										ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));									}									ast_format_cap_copy(native, orignative);									ast_channel_unlock(iaxs[fr->callno]->owner);									orignative = ast_format_cap_destroy(orignative);								}							}						} else {							ast_debug(1, "Neat, somebody took away the channel at a magical time but i found it!\n");							/* Free remote variables (if any) */							if (ies.vars) {								ast_variables_destroy(ies.vars);								ast_debug(1, "I can haz iaxvars, but they is no good.  :-(\n");								ies.vars = NULL;							}							ast_mutex_unlock(&iaxsl[fr->callno]);							return 1;						}					}
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
{						iax2_lock_owner(fr->callno);						if (iaxs[fr->callno]) {							if (iaxs[fr->callno]->owner) {								struct ast_format_cap *orignative = ast_format_cap_dup(ast_channel_nativeformats(iaxs[fr->callno]->owner));								struct ast_format_cap *native = ast_channel_nativeformats(iaxs[fr->callno]->owner);								if (orignative) {									ast_format_cap_set(native, &f.subclass.format);									if (ast_channel_readformat(iaxs[fr->callno]->owner)->id) {										ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));									}									ast_format_cap_copy(native, orignative);									ast_channel_unlock(iaxs[fr->callno]->owner);									orignative = ast_format_cap_destroy(orignative);								}							}						} else {							ast_debug(1, "Neat, somebody took away the channel at a magical time but i found it!\n");							/* Free remote variables (if any) */							if (ies.vars) {								ast_variables_destroy(ies.vars);								ast_debug(1, "I can haz iaxvars, but they is no good.  :-(\n");								ies.vars = NULL;							}							ast_mutex_unlock(&iaxsl[fr->callno]);							return 1;						}					}
iax2_lock_owner(fr->callno);
iax2_lock_owner(fr->callno)
iax2_lock_owner
iax2_lock_owner
fr->callno
fr
fr
callno
if (iaxs[fr->callno]) {							if (iaxs[fr->callno]->owner) {								struct ast_format_cap *orignative = ast_format_cap_dup(ast_channel_nativeformats(iaxs[fr->callno]->owner));								struct ast_format_cap *native = ast_channel_nativeformats(iaxs[fr->callno]->owner);								if (orignative) {									ast_format_cap_set(native, &f.subclass.format);									if (ast_channel_readformat(iaxs[fr->callno]->owner)->id) {										ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));									}									ast_format_cap_copy(native, orignative);									ast_channel_unlock(iaxs[fr->callno]->owner);									orignative = ast_format_cap_destroy(orignative);								}							}						} else {							ast_debug(1, "Neat, somebody took away the channel at a magical time but i found it!\n");							/* Free remote variables (if any) */							if (ies.vars) {								ast_variables_destroy(ies.vars);								ast_debug(1, "I can haz iaxvars, but they is no good.  :-(\n");								ies.vars = NULL;							}							ast_mutex_unlock(&iaxsl[fr->callno]);							return 1;						}
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{							if (iaxs[fr->callno]->owner) {								struct ast_format_cap *orignative = ast_format_cap_dup(ast_channel_nativeformats(iaxs[fr->callno]->owner));								struct ast_format_cap *native = ast_channel_nativeformats(iaxs[fr->callno]->owner);								if (orignative) {									ast_format_cap_set(native, &f.subclass.format);									if (ast_channel_readformat(iaxs[fr->callno]->owner)->id) {										ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));									}									ast_format_cap_copy(native, orignative);									ast_channel_unlock(iaxs[fr->callno]->owner);									orignative = ast_format_cap_destroy(orignative);								}							}						}
if (iaxs[fr->callno]->owner) {								struct ast_format_cap *orignative = ast_format_cap_dup(ast_channel_nativeformats(iaxs[fr->callno]->owner));								struct ast_format_cap *native = ast_channel_nativeformats(iaxs[fr->callno]->owner);								if (orignative) {									ast_format_cap_set(native, &f.subclass.format);									if (ast_channel_readformat(iaxs[fr->callno]->owner)->id) {										ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));									}									ast_format_cap_copy(native, orignative);									ast_channel_unlock(iaxs[fr->callno]->owner);									orignative = ast_format_cap_destroy(orignative);								}							}
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
{								struct ast_format_cap *orignative = ast_format_cap_dup(ast_channel_nativeformats(iaxs[fr->callno]->owner));								struct ast_format_cap *native = ast_channel_nativeformats(iaxs[fr->callno]->owner);								if (orignative) {									ast_format_cap_set(native, &f.subclass.format);									if (ast_channel_readformat(iaxs[fr->callno]->owner)->id) {										ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));									}									ast_format_cap_copy(native, orignative);									ast_channel_unlock(iaxs[fr->callno]->owner);									orignative = ast_format_cap_destroy(orignative);								}							}
struct ast_format_cap *orignative = ast_format_cap_dup(ast_channel_nativeformats(iaxs[fr->callno]->owner));
struct ast_format_cap *orignative = ast_format_cap_dup(ast_channel_nativeformats(iaxs[fr->callno]->owner));
struct ast_format_cap
ast_format_cap
*orignative = ast_format_cap_dup(ast_channel_nativeformats(iaxs[fr->callno]->owner))
*
orignative
= ast_format_cap_dup(ast_channel_nativeformats(iaxs[fr->callno]->owner))
ast_format_cap_dup(ast_channel_nativeformats(iaxs[fr->callno]->owner))
ast_format_cap_dup
ast_format_cap_dup
ast_channel_nativeformats(iaxs[fr->callno]->owner)
ast_channel_nativeformats
ast_channel_nativeformats
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
struct ast_format_cap *native = ast_channel_nativeformats(iaxs[fr->callno]->owner);
struct ast_format_cap *native = ast_channel_nativeformats(iaxs[fr->callno]->owner);
struct ast_format_cap
ast_format_cap
*native = ast_channel_nativeformats(iaxs[fr->callno]->owner)
*
native
= ast_channel_nativeformats(iaxs[fr->callno]->owner)
ast_channel_nativeformats(iaxs[fr->callno]->owner)
ast_channel_nativeformats
ast_channel_nativeformats
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
if (orignative) {									ast_format_cap_set(native, &f.subclass.format);									if (ast_channel_readformat(iaxs[fr->callno]->owner)->id) {										ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));									}									ast_format_cap_copy(native, orignative);									ast_channel_unlock(iaxs[fr->callno]->owner);									orignative = ast_format_cap_destroy(orignative);								}
orignative
orignative
{									ast_format_cap_set(native, &f.subclass.format);									if (ast_channel_readformat(iaxs[fr->callno]->owner)->id) {										ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));									}									ast_format_cap_copy(native, orignative);									ast_channel_unlock(iaxs[fr->callno]->owner);									orignative = ast_format_cap_destroy(orignative);								}
ast_format_cap_set(native, &f.subclass.format);
ast_format_cap_set(native, &f.subclass.format)
ast_format_cap_set
ast_format_cap_set
native
native
&f.subclass.format
f.subclass.format
f.subclass
f
f
subclass
format
if (ast_channel_readformat(iaxs[fr->callno]->owner)->id) {										ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));									}
ast_channel_readformat(iaxs[fr->callno]->owner)->id
ast_channel_readformat(iaxs[fr->callno]->owner)
ast_channel_readformat
ast_channel_readformat
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
id
{										ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));									}
ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));
ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner))
ast_set_read_format
ast_set_read_format
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
ast_channel_readformat(iaxs[fr->callno]->owner)
ast_channel_readformat
ast_channel_readformat
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
ast_format_cap_copy(native, orignative);
ast_format_cap_copy(native, orignative)
ast_format_cap_copy
ast_format_cap_copy
native
native
orignative
orignative
ast_channel_unlock(iaxs[fr->callno]->owner);
ast_channel_unlock(iaxs[fr->callno]->owner)
ast_channel_unlock
ast_channel_unlock
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
orignative = ast_format_cap_destroy(orignative);
orignative = ast_format_cap_destroy(orignative)
orignative
orignative
ast_format_cap_destroy(orignative)
ast_format_cap_destroy
ast_format_cap_destroy
orignative
orignative
{							ast_debug(1, "Neat, somebody took away the channel at a magical time but i found it!\n");							/* Free remote variables (if any) */							if (ies.vars) {								ast_variables_destroy(ies.vars);								ast_debug(1, "I can haz iaxvars, but they is no good.  :-(\n");								ies.vars = NULL;							}							ast_mutex_unlock(&iaxsl[fr->callno]);							return 1;						}
ast_debug(1, "Neat, somebody took away the channel at a magical time but i found it!\n");
ast_debug(1, "Neat, somebody took away the channel at a magical time but i found it!\n")
ast_debug
ast_debug
1
"Neat, somebody took away the channel at a magical time but i found it!\n"
if (ies.vars) {								ast_variables_destroy(ies.vars);								ast_debug(1, "I can haz iaxvars, but they is no good.  :-(\n");								ies.vars = NULL;							}
ies.vars
ies
ies
vars
{								ast_variables_destroy(ies.vars);								ast_debug(1, "I can haz iaxvars, but they is no good.  :-(\n");								ies.vars = NULL;							}
ast_variables_destroy(ies.vars);
ast_variables_destroy(ies.vars)
ast_variables_destroy
ast_variables_destroy
ies.vars
ies
ies
vars
ast_debug(1, "I can haz iaxvars, but they is no good.  :-(\n");
ast_debug(1, "I can haz iaxvars, but they is no good.  :-(\n")
ast_debug
ast_debug
1
"I can haz iaxvars, but they is no good.  :-(\n"
ies.vars = NULL;
ies.vars = NULL
ies.vars
ies
ies
vars
NULL
NULL
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock
ast_mutex_unlock
(&iaxsl[fr->callno])
&iaxsl[fr->callno]
&
iaxsl
[fr->callno]
fr->callno
fr
fr
callno
return 1;
1
if (f.frametype == AST_FRAME_VIDEO) {			if (f.subclass.format.id != ast_format_id_from_old_bitfield(iaxs[fr->callno]->videoformat)) {				ast_debug(1, "Ooh, video format changed to %s\n", ast_getformatname(&f.subclass.format));				iaxs[fr->callno]->videoformat = ast_format_to_old_bitfield(&f.subclass.format);			}		}
f.frametype == AST_FRAME_VIDEO
f.frametype
f
f
frametype
AST_FRAME_VIDEO
AST_FRAME_VIDEO
{			if (f.subclass.format.id != ast_format_id_from_old_bitfield(iaxs[fr->callno]->videoformat)) {				ast_debug(1, "Ooh, video format changed to %s\n", ast_getformatname(&f.subclass.format));				iaxs[fr->callno]->videoformat = ast_format_to_old_bitfield(&f.subclass.format);			}		}
if (f.subclass.format.id != ast_format_id_from_old_bitfield(iaxs[fr->callno]->videoformat)) {				ast_debug(1, "Ooh, video format changed to %s\n", ast_getformatname(&f.subclass.format));				iaxs[fr->callno]->videoformat = ast_format_to_old_bitfield(&f.subclass.format);			}
f.subclass.format.id != ast_format_id_from_old_bitfield(iaxs[fr->callno]->videoformat)
f.subclass.format.id
f.subclass.format
f.subclass
f
f
subclass
format
id
ast_format_id_from_old_bitfield(iaxs[fr->callno]->videoformat)
ast_format_id_from_old_bitfield
ast_format_id_from_old_bitfield
iaxs[fr->callno]->videoformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
videoformat
{				ast_debug(1, "Ooh, video format changed to %s\n", ast_getformatname(&f.subclass.format));				iaxs[fr->callno]->videoformat = ast_format_to_old_bitfield(&f.subclass.format);			}
ast_debug(1, "Ooh, video format changed to %s\n", ast_getformatname(&f.subclass.format));
ast_debug(1, "Ooh, video format changed to %s\n", ast_getformatname(&f.subclass.format))
ast_debug
ast_debug
1
"Ooh, video format changed to %s\n"
ast_getformatname(&f.subclass.format)
ast_getformatname
ast_getformatname
&f.subclass.format
f.subclass.format
f.subclass
f
f
subclass
format
iaxs[fr->callno]->videoformat = ast_format_to_old_bitfield(&f.subclass.format);
iaxs[fr->callno]->videoformat = ast_format_to_old_bitfield(&f.subclass.format)
iaxs[fr->callno]->videoformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
videoformat
ast_format_to_old_bitfield(&f.subclass.format)
ast_format_to_old_bitfield
ast_format_to_old_bitfield
&f.subclass.format
f.subclass.format
f.subclass
f
f
subclass
format
if (f.frametype == AST_FRAME_CONTROL && iaxs[fr->callno]->owner) {			if (f.subclass.integer == AST_CONTROL_BUSY) {				ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_BUSY);			} else if (f.subclass.integer == AST_CONTROL_CONGESTION) {				ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_CONGESTION);			}		}
f.frametype == AST_FRAME_CONTROL && iaxs[fr->callno]->owner
f.frametype == AST_FRAME_CONTROL
f.frametype
f
f
frametype
AST_FRAME_CONTROL
AST_FRAME_CONTROL
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
{			if (f.subclass.integer == AST_CONTROL_BUSY) {				ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_BUSY);			} else if (f.subclass.integer == AST_CONTROL_CONGESTION) {				ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_CONGESTION);			}		}
if (f.subclass.integer == AST_CONTROL_BUSY) {				ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_BUSY);			} else if (f.subclass.integer == AST_CONTROL_CONGESTION) {				ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_CONGESTION);			}
f.subclass.integer == AST_CONTROL_BUSY
f.subclass.integer
f.subclass
f
f
subclass
integer
AST_CONTROL_BUSY
AST_CONTROL_BUSY
{				ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_BUSY);			}
ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_BUSY);
ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_BUSY)
ast_channel_hangupcause_set
ast_channel_hangupcause_set
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
AST_CAUSE_BUSY
AST_CAUSE_BUSY
if (f.subclass.integer == AST_CONTROL_CONGESTION) {				ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_CONGESTION);			}
f.subclass.integer == AST_CONTROL_CONGESTION
f.subclass.integer
f.subclass
f
f
subclass
integer
AST_CONTROL_CONGESTION
AST_CONTROL_CONGESTION
{				ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_CONGESTION);			}
ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_CONGESTION);
ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_CONGESTION)
ast_channel_hangupcause_set
ast_channel_hangupcause_set
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
AST_CAUSE_CONGESTION
AST_CAUSE_CONGESTION
if (f.frametype == AST_FRAME_IAX) {			AST_SCHED_DEL(sched, iaxs[fr->callno]->initid);			/* Handle the IAX pseudo frame itself */			if (iaxdebug)				ast_debug(1, "IAX subclass %d received\n", f.subclass.integer);                        /* Update last ts unless the frame's timestamp originated with us. */			if (iaxs[fr->callno]->last < fr->ts &&                            f.subclass.integer != IAX_COMMAND_ACK &&                            f.subclass.integer != IAX_COMMAND_PONG &&                            f.subclass.integer != IAX_COMMAND_LAGRP) {				iaxs[fr->callno]->last = fr->ts;				if (iaxdebug)					ast_debug(1, "For call=%d, set last=%d\n", fr->callno, fr->ts);			}			iaxs[fr->callno]->last_iax_message = f.subclass.integer;			if (!iaxs[fr->callno]->first_iax_message) {				iaxs[fr->callno]->first_iax_message = f.subclass.integer;			}			switch(f.subclass.integer) {			case IAX_COMMAND_ACK:				/* Do nothing */				break;			case IAX_COMMAND_QUELCH:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {				        /* Generate Manager Hold event, if necessary*/					if (iaxs[fr->callno]->owner) {						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: On\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}					ast_set_flag64(iaxs[fr->callno], IAX_QUELCH);					if (ies.musiconhold) {						iax2_lock_owner(fr->callno);						if (!iaxs[fr->callno] || !iaxs[fr->callno]->owner) {							break;						}						if (ast_bridged_channel(iaxs[fr->callno]->owner)) {							const char *moh_suggest = iaxs[fr->callno]->mohsuggest;							/*							 * We already hold the owner lock so we do not							 * need to check iaxs[fr->callno] after it returns.							 */							iax2_queue_control_data(fr->callno, AST_CONTROL_HOLD, 								S_OR(moh_suggest, NULL),								!ast_strlen_zero(moh_suggest) ? strlen(moh_suggest) + 1 : 0);						}						ast_channel_unlock(iaxs[fr->callno]->owner);					}				}				break;			case IAX_COMMAND_UNQUELCH:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {					iax2_lock_owner(fr->callno);					if (!iaxs[fr->callno]) {						break;					}					/* Generate Manager Unhold event, if necessary */					if (iaxs[fr->callno]->owner && ast_test_flag64(iaxs[fr->callno], IAX_QUELCH)) {						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: Off\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}					ast_clear_flag64(iaxs[fr->callno], IAX_QUELCH);					if (!iaxs[fr->callno]->owner) {						break;					}					if (ast_bridged_channel(iaxs[fr->callno]->owner)) {						/*						 * We already hold the owner lock so we do not						 * need to check iaxs[fr->callno] after it returns.						 */						iax2_queue_control_data(fr->callno, AST_CONTROL_UNHOLD, NULL, 0);					}					ast_channel_unlock(iaxs[fr->callno]->owner);				}				break;			case IAX_COMMAND_TXACC:				if (iaxs[fr->callno]->transferring == TRANSFER_BEGIN) {					/* Ack the packet with the given timestamp */					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* Cancel any outstanding txcnt's */						if (cur->transfer) {							cur->retries = -1;						}					}					memset(&ied1, 0, sizeof(ied1));					iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->callno);					send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREADY, 0, ied1.buf, ied1.pos, -1);					iaxs[fr->callno]->transferring = TRANSFER_READY;				}				break;			case IAX_COMMAND_NEW:				/* Ignore if it's already up */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD))					break;				if (ies.provverpres && ies.serviceident && sin.sin_addr.s_addr) {					ast_mutex_unlock(&iaxsl[fr->callno]);					check_provisioning(&sin, fd, ies.serviceident, ies.provver);					ast_mutex_lock(&iaxsl[fr->callno]);					if (!iaxs[fr->callno]) {						break;					}				}				/* If we're in trunk mode, do it now, and update the trunk number in our frame before continuing */				if (ast_test_flag64(iaxs[fr->callno], IAX_TRUNK)) {					int new_callno;					if ((new_callno = make_trunk(fr->callno, 1)) != -1)						fr->callno = new_callno;				}				/* For security, always ack immediately */				if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				if (check_access(fr->callno, &sin, &ies)) {					/* They're not allowed on */					auth_fail(fr->callno, IAX_COMMAND_REJECT);					if (authdebug)						ast_log(LOG_NOTICE, "Rejected connect attempt from %s, who was trying to reach '%s@%s'\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					break;				}				if (ast_strlen_zero(iaxs[fr->callno]->secret) && ast_test_flag64(iaxs[fr->callno], IAX_FORCE_ENCRYPT)) {					auth_fail(fr->callno, IAX_COMMAND_REJECT);					ast_log(LOG_WARNING, "Rejected connect attempt.  No secret present while force encrypt enabled.\n");					break;				}				if (strcasecmp(iaxs[fr->callno]->exten, "TBD")) {					const char *context, *exten, *cid_num;					context = ast_strdupa(iaxs[fr->callno]->context);					exten = ast_strdupa(iaxs[fr->callno]->exten);					cid_num = ast_strdupa(iaxs[fr->callno]->cid_num);					/* This might re-enter the IAX code and need the lock */					ast_mutex_unlock(&iaxsl[fr->callno]);					exists = ast_exists_extension(NULL, context, exten, 1, cid_num);					ast_mutex_lock(&iaxsl[fr->callno]);					if (!iaxs[fr->callno]) {						break;					}				} else					exists = 0;				/* Get OSP token if it does exist */				save_osptoken(fr, &ies);				if (ast_strlen_zero(iaxs[fr->callno]->secret) && ast_strlen_zero(iaxs[fr->callno]->inkeys)) {					if (strcmp(iaxs[fr->callno]->exten, "TBD") && !exists) {						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}						if (authdebug)							ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					} else {						/* Select an appropriate format */						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								using_prefs = "reqonly";							} else {								using_prefs = "disabled";							}							format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;							memset(&pref, 0, sizeof(pref));							strcpy(caller_pref_buf, "disabled");							strcpy(host_pref_buf, "disabled");						} else {							struct ast_format tmpfmt;							using_prefs = "mine";							/* If the information elements are in here... use them */							if (ies.codec_prefs)								ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);							if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {								/* If we are codec_first_choice we let the caller have the 1st shot at picking the codec.*/								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {									pref = iaxs[fr->callno]->rprefs;									using_prefs = "caller";								} else {									pref = iaxs[fr->callno]->prefs;								}							} else								pref = iaxs[fr->callno]->prefs;							format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);							ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);							ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);						}						if (!format) {							if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP))								format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;							if (!format) {								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}								if (authdebug) {									char tmp[256], tmp2[256], tmp3[256];									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}							} else {								/* Pick one... */								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))										format = 0;								} else {									if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {										using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";										memset(&pref, 0, sizeof(pref));										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);										strcpy(caller_pref_buf,"disabled");										strcpy(host_pref_buf,"disabled");									} else {										struct ast_format tmpfmt;										using_prefs = "mine";										if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {											/* Do the opposite of what we tried above. */											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);										} else /* if no codec_prefs IE do it the old way */											format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}								}								if (!format) {									char tmp[256], tmp2[256], tmp3[256];									memset(&ied0, 0, sizeof(ied0));									iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");									iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);									ast_log(LOG_ERROR, "No best format in '%s'???\n", iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));									send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);									if (!iaxs[fr->callno]) {										break;									}									if (authdebug) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}									ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);									break;								}							}						}						if (format) {							/* No authentication required, let them in */							memset(&ied1, 0, sizeof(ied1));							iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);							iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);							send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);							if (strcmp(iaxs[fr->callno]->exten, "TBD")) {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);								ast_verb(3, "Accepting UNAUTHENTICATED call from %s:\n"												"%srequested format = %s,\n"												"%srequested prefs = %s,\n"												"%sactual format = %s,\n"												"%shost prefs = %s,\n"												"%spriority = %s\n",												ast_inet_ntoa(sin.sin_addr), 												VERBOSE_PREFIX_4,												iax2_getformatname(iaxs[fr->callno]->peerformat), 												VERBOSE_PREFIX_4,												caller_pref_buf,												VERBOSE_PREFIX_4,												iax2_getformatname(format), 												VERBOSE_PREFIX_4,												host_pref_buf, 												VERBOSE_PREFIX_4,												using_prefs);								iaxs[fr->callno]->chosenformat = format;								/* Since this is a new call, we should go ahead and set the callid for it. */								iax_pvt_callid_new(fr->callno);								ast_set_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);							} else {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);								/* If this is a TBD call, we're ready but now what...  */								ast_verb(3, "Accepted unauthenticated TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							}						}					}					break;				}				if (iaxs[fr->callno]->authmethods & IAX_AUTH_MD5)					merge_encryption(iaxs[fr->callno],ies.encmethods);				else					iaxs[fr->callno]->encmethods = 0;				if (!authenticate_request(fr->callno) && iaxs[fr->callno])					ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED);				break;			case IAX_COMMAND_DPREQ:				/* Request status in the dialplan */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD) &&					!ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED) && ies.called_number) {					if (iaxcompat) {						/* Spawn a thread for the lookup */						spawn_dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num);					} else {						/* Just look it up */						dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num, 1);					}				}				break;			case IAX_COMMAND_HANGUP:				ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);				ast_debug(1, "Immediately destroying %d, having received hangup\n", fr->callno);				/* Set hangup cause according to remote and hangupsource */				if (iaxs[fr->callno]->owner) {					set_hangup_source_and_cause(fr->callno, ies.causecode);					if (!iaxs[fr->callno]) {						break;					}				}				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_REJECT:				/* Set hangup cause according to remote and hangup source */				if (iaxs[fr->callno]->owner) {					set_hangup_source_and_cause(fr->callno, ies.causecode);					if (!iaxs[fr->callno]) {						break;					}				}				if (!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)) {					if (iaxs[fr->callno]->owner && authdebug)						ast_log(LOG_WARNING, "Call rejected by %s: %s\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr),							ies.cause ? ies.cause : "<Unknown>");					ast_debug(1, "Immediately destroying %d, having received reject\n",						fr->callno);				}				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK,						       fr->ts, NULL, 0, fr->iseqno);				if (!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION))					iaxs[fr->callno]->error = EPERM;				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_TRANSFER:			{				struct ast_channel *bridged_chan;				struct ast_channel *owner;				iax2_lock_owner(fr->callno);				if (!iaxs[fr->callno]) {					/* Initiating call went away before we could transfer. */					break;				}				owner = iaxs[fr->callno]->owner;				bridged_chan = owner ? ast_bridged_channel(owner) : NULL;				if (bridged_chan && ies.called_number) {					const char *context;					context = ast_strdupa(iaxs[fr->callno]->context);					ast_channel_ref(owner);					ast_channel_ref(bridged_chan);					ast_channel_unlock(owner);					ast_mutex_unlock(&iaxsl[fr->callno]);					/* Set BLINDTRANSFER channel variables */					pbx_builtin_setvar_helper(owner, "BLINDTRANSFER", ast_channel_name(bridged_chan));					pbx_builtin_setvar_helper(bridged_chan, "BLINDTRANSFER", ast_channel_name(owner));					/* DO NOT hold any locks while calling ast_parking_ext_valid() */					if (ast_parking_ext_valid(ies.called_number, owner, context)) {						ast_debug(1, "Parking call '%s'\n", ast_channel_name(bridged_chan));						if (iax_park(bridged_chan, owner, ies.called_number, context)) {							ast_log(LOG_WARNING, "Failed to park call '%s'\n",								ast_channel_name(bridged_chan));						}					} else {						if (ast_async_goto(bridged_chan, context, ies.called_number, 1)) {							ast_log(LOG_WARNING,								"Async goto of '%s' to '%s@%s' failed\n",								ast_channel_name(bridged_chan), ies.called_number, context);						} else {							ast_debug(1, "Async goto of '%s' to '%s@%s' started\n",								ast_channel_name(bridged_chan), ies.called_number, context);						}					}					ast_channel_unref(owner);					ast_channel_unref(bridged_chan);					ast_mutex_lock(&iaxsl[fr->callno]);				} else {					ast_debug(1, "Async goto not applicable on call %d\n", fr->callno);					if (owner) {						ast_channel_unlock(owner);					}				}				break;			}			case IAX_COMMAND_ACCEPT:				/* Ignore if call is already up or needs authentication or is a TBD */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD | IAX_STATE_AUTHENTICATED))					break;				if (ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)) {					/* Send ack immediately, before we destroy */					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					iax2_destroy(fr->callno);					break;				}				if (ies.format) {					iaxs[fr->callno]->peerformat = ies.format;				} else {					if (iaxs[fr->callno]->owner)						iaxs[fr->callno]->peerformat = ast_format_cap_to_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner));					else						iaxs[fr->callno]->peerformat = iaxs[fr->callno]->capability;				}				ast_verb(3, "Call accepted by %s (format %s)\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iax2_getformatname(iaxs[fr->callno]->peerformat));				if (!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)) {					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);					if (!iaxs[fr->callno]) {						break;					}					if (authdebug) {						char tmp1[256], tmp2[256];						ast_log(LOG_NOTICE, "Rejected call to %s, format %s incompatible with our capability %s.\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),							iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));					}				} else {					ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);					iax2_lock_owner(fr->callno);					if (iaxs[fr->callno] && iaxs[fr->callno]->owner) {						char tmp[256];						/* Switch us to use a compatible format */						ast_format_cap_from_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner), iaxs[fr->callno]->peerformat);						ast_verb(3, "Format for call is %s\n", ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(iaxs[fr->callno]->owner)));						/* Setup read/write formats properly. */						if (ast_channel_writeformat(iaxs[fr->callno]->owner)->id)							ast_set_write_format(iaxs[fr->callno]->owner, ast_channel_writeformat(iaxs[fr->callno]->owner));						if (ast_channel_readformat(iaxs[fr->callno]->owner)->id)							ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));						ast_channel_unlock(iaxs[fr->callno]->owner);					}				}				if (iaxs[fr->callno]) {					AST_LIST_LOCK(&dpcache);					AST_LIST_TRAVERSE(&iaxs[fr->callno]->dpentries, dp, peer_list)						if (!(dp->flags & CACHE_FLAG_TRANSMITTED))							iax2_dprequest(dp, fr->callno);					AST_LIST_UNLOCK(&dpcache);				}				break;			case IAX_COMMAND_POKE:				/* Send back a pong packet with the original timestamp */				send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, NULL, 0, -1);				break;			case IAX_COMMAND_PING:			{				struct iax_ie_data pingied;				construct_rr(iaxs[fr->callno], &pingied);				/* Send back a pong packet with the original timestamp */				send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, pingied.buf, pingied.pos, -1);			}				break;			case IAX_COMMAND_PONG:				/* Calculate ping time */				iaxs[fr->callno]->pingtime =  calc_timestamp(iaxs[fr->callno], 0, &f) - fr->ts;				/* save RR info */				save_rr(fr, &ies);				/* Good time to write jb stats for this call */				log_jitterstats(fr->callno);				if (iaxs[fr->callno]->peerpoke) {					peer = iaxs[fr->callno]->peerpoke;					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms)) {						if (iaxs[fr->callno]->pingtime <= peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now REACHABLE! Time: %d\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Reachable\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_NOT_INUSE, "IAX2/%s", peer->name); /* Activate notification */						}					} else if ((peer->historicms > 0) && (peer->historicms <= peer->maxms)) {						if (iaxs[fr->callno]->pingtime > peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now TOO LAGGED (%d ms)!\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Lagged\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_UNAVAILABLE, "IAX2/%s", peer->name); /* Activate notification */						}					}					peer->lastms = iaxs[fr->callno]->pingtime;					if (peer->smoothing && (peer->lastms > -1))						peer->historicms = (iaxs[fr->callno]->pingtime + peer->historicms) / 2;					else if (peer->smoothing && peer->lastms < 0)						peer->historicms = (0 + peer->historicms) / 2;					else											peer->historicms = iaxs[fr->callno]->pingtime;					/* Remove scheduled iax2_poke_noanswer */					if (peer->pokeexpire > -1) {						if (!AST_SCHED_DEL(sched, peer->pokeexpire)) {							peer_unref(peer);							peer->pokeexpire = -1;						}					}					/* Schedule the next cycle */					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms))						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_peer_s, peer_ref(peer));					else						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqok, iax2_poke_peer_s, peer_ref(peer));					if (peer->pokeexpire == -1)						peer_unref(peer);					/* and finally send the ack */					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					/* And wrap up the qualify call */					iax2_destroy(fr->callno);					peer->callno = 0;					ast_debug(1, "Peer %s: got pong, lastms %d, historicms %d, maxms %d\n", peer->name, peer->lastms, peer->historicms, peer->maxms);				}				break;			case IAX_COMMAND_LAGRQ:			case IAX_COMMAND_LAGRP:				f.src = "LAGRQ";				f.mallocd = 0;				f.offset = 0;				f.samples = 0;				iax_frame_wrap(fr, &f);				if (f.subclass.integer == IAX_COMMAND_LAGRQ) {					/* Received a LAGRQ - echo back a LAGRP */					fr->af.subclass.integer = IAX_COMMAND_LAGRP;					iax2_send(iaxs[fr->callno], &fr->af, fr->ts, -1, 0, 0, 0);				} else {					/* Received LAGRP in response to our LAGRQ */					unsigned int ts;					/* This is a reply we've been given, actually measure the difference */					ts = calc_timestamp(iaxs[fr->callno], 0, &fr->af);					iaxs[fr->callno]->lag = ts - fr->ts;					if (iaxdebug)						ast_debug(1, "Peer %s lag measured as %dms\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->lag);				}				break;			case IAX_COMMAND_AUTHREQ:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)) {					ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					break;				}				if (authenticate_reply(iaxs[fr->callno], &iaxs[fr->callno]->addr, &ies, iaxs[fr->callno]->secret, iaxs[fr->callno]->outkey)) {					struct ast_frame hangup_fr = { .frametype = AST_FRAME_CONTROL,								.subclass.integer = AST_CONTROL_HANGUP,					};					ast_log(LOG_WARNING, 						"I don't know how to authenticate %s to %s\n", 						ies.username ? ies.username : "<unknown>", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr));					iax2_queue_frame(fr->callno, &hangup_fr);				}				break;			case IAX_COMMAND_AUTHREP:				/* For security, always ack immediately */				if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				/* Ignore once we've started */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)) {					ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					break;				}				if (authenticate_verify(iaxs[fr->callno], &ies)) {					if (authdebug)						ast_log(LOG_NOTICE, "Host %s failed to authenticate as %s\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->username);					memset(&ied0, 0, sizeof(ied0));					auth_fail(fr->callno, IAX_COMMAND_REJECT);					break;				}				if (strcasecmp(iaxs[fr->callno]->exten, "TBD")) {					/* This might re-enter the IAX code and need the lock */					exists = ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num);				} else					exists = 0;				if (strcmp(iaxs[fr->callno]->exten, "TBD") && !exists) {					if (authdebug)						ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);					if (!iaxs[fr->callno]) {						break;					}				} else {					/* Select an appropriate format */					if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {							using_prefs = "reqonly";						} else {							using_prefs = "disabled";						}						format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;						memset(&pref, 0, sizeof(pref));						strcpy(caller_pref_buf, "disabled");						strcpy(host_pref_buf, "disabled");					} else {						struct ast_format tmpfmt;						using_prefs = "mine";						if (ies.codec_prefs)							ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);						if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {							if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {								pref = iaxs[fr->callno]->rprefs;								using_prefs = "caller";							} else {								pref = iaxs[fr->callno]->prefs;							}						} else /* if no codec_prefs IE do it the old way */							pref = iaxs[fr->callno]->prefs;						format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);						ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);						ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);					}					if (!format) {						char tmp1[256], tmp2[256], tmp3[256];						if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {							ast_debug(1, "We don't do requested format %s, falling back to peer capability '%s'\n",								iax2_getformatname(iaxs[fr->callno]->peerformat),								iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability));							format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;						}						if (!format) {							if (authdebug) {								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n", ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));								} else {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",										ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),										iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));								}							}							memset(&ied0, 0, sizeof(ied0));							iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");							iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);							send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);							if (!iaxs[fr->callno]) {								break;							}						} else {							/* Pick one... */							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))									format = 0;							} else {								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {									using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";									memset(&pref, 0, sizeof(pref));									format = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ?										iaxs[fr->callno]->peerformat : iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									strcpy(caller_pref_buf,"disabled");									strcpy(host_pref_buf,"disabled");								} else {									struct ast_format tmpfmt;									using_prefs = "mine";									if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {										/* Do the opposite of what we tried above. */										if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {											pref = iaxs[fr->callno]->prefs;										} else {											pref = iaxs[fr->callno]->rprefs;											using_prefs = "caller";										}										format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);									} else /* if no codec_prefs IE do it the old way */										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}							}							if (!format) {								char tmp1[256], tmp2[256], tmp3[256];								ast_log(LOG_ERROR, "No best format in %s???\n",									iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));								if (authdebug) {									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}							}						}					}					if (format) {						/* Authentication received */						memset(&ied1, 0, sizeof(ied1));						iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);						iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);						send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);						if (strcmp(iaxs[fr->callno]->exten, "TBD")) {							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							ast_verb(3, "Accepting AUTHENTICATED call from %s:\n"											"%srequested format = %s,\n"											"%srequested prefs = %s,\n"											"%sactual format = %s,\n"											"%shost prefs = %s,\n"											"%spriority = %s\n", 											ast_inet_ntoa(sin.sin_addr), 											VERBOSE_PREFIX_4,											iax2_getformatname(iaxs[fr->callno]->peerformat),											VERBOSE_PREFIX_4,											caller_pref_buf,											VERBOSE_PREFIX_4,											iax2_getformatname(format),											VERBOSE_PREFIX_4,											host_pref_buf,											VERBOSE_PREFIX_4,											using_prefs);							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, format, NULL)))								iax2_destroy(fr->callno);							else if (ies.vars) {								struct ast_datastore *variablestore;								struct ast_variable *var, *prev = NULL;								AST_LIST_HEAD(, ast_var_t) *varlist;								varlist = ast_calloc(1, sizeof(*varlist));								variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);								if (variablestore && varlist) {									variablestore->data = varlist;									variablestore->inheritance = DATASTORE_INHERIT_FOREVER;									AST_LIST_HEAD_INIT(varlist);									ast_debug(1, "I can haz IAX vars? w00t\n");									for (var = ies.vars; var; var = var->next) {										struct ast_var_t *newvar = ast_var_assign(var->name, var->value);										if (prev)											ast_free(prev);										prev = var;										if (!newvar) {											/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */											ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");										} else {											AST_LIST_INSERT_TAIL(varlist, newvar, entries);										}									}									if (prev)										ast_free(prev);									ies.vars = NULL;									ast_channel_datastore_add(c, variablestore);								} else {									ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									if (variablestore)										ast_datastore_free(variablestore);									if (varlist)										ast_free(varlist);								}							}						} else {							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);							/* If this is a TBD call, we're ready but now what...  */							ast_verb(3, "Accepted AUTHENTICATED TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							if (ast_test_flag64(iaxs[fr->callno], IAX_IMMEDIATE)) {								goto immediatedial;							}						}					}				}				break;			case IAX_COMMAND_DIAL:immediatedial:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD)) {					ast_clear_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);					ast_string_field_set(iaxs[fr->callno], exten, ies.called_number ? ies.called_number : "s");					if (!ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num)) {						if (authdebug)							ast_log(LOG_NOTICE, "Rejected dial attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}					} else {						char tmp[256];						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);						ast_verb(3, "Accepting DIAL from %s, formats = %s\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat));						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);						send_command(iaxs[fr->callno], AST_FRAME_CONTROL, AST_CONTROL_PROGRESS, 0, NULL, 0, -1);						if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->peerformat, NULL)))							iax2_destroy(fr->callno);						else if (ies.vars) {							struct ast_datastore *variablestore;							struct ast_variable *var, *prev = NULL;							AST_LIST_HEAD(, ast_var_t) *varlist;							varlist = ast_calloc(1, sizeof(*varlist));							variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);							ast_debug(1, "I can haz IAX vars? w00t\n");							if (variablestore && varlist) {								variablestore->data = varlist;								variablestore->inheritance = DATASTORE_INHERIT_FOREVER;								AST_LIST_HEAD_INIT(varlist);								for (var = ies.vars; var; var = var->next) {									struct ast_var_t *newvar = ast_var_assign(var->name, var->value);									if (prev)										ast_free(prev);									prev = var;									if (!newvar) {										/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */										ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									} else {										AST_LIST_INSERT_TAIL(varlist, newvar, entries);									}								}								if (prev)									ast_free(prev);								ies.vars = NULL;								ast_channel_datastore_add(c, variablestore);							} else {								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");								if (variablestore)									ast_datastore_free(variablestore);								if (varlist)									ast_free(varlist);							}						}					}				}				break;			case IAX_COMMAND_INVAL:				iaxs[fr->callno]->error = ENOTCONN;				ast_debug(1, "Immediately destroying %d, having received INVAL\n", fr->callno);				iax2_destroy(fr->callno);				ast_debug(1, "Destroying call %d\n", fr->callno);				break;			case IAX_COMMAND_VNAK:				ast_debug(1, "Received VNAK: resending outstanding frames\n");				/* Force retransmission */				vnak_retransmit(fr->callno, fr->iseqno);				break;			case IAX_COMMAND_REGREQ:			case IAX_COMMAND_REGREL:				/* For security, always ack immediately */				if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				if (register_verify(fr->callno, &sin, &ies)) {					if (!iaxs[fr->callno]) {						break;					}					/* Send delayed failure */					auth_fail(fr->callno, IAX_COMMAND_REGREJ);					break;				}				if (!iaxs[fr->callno]) {					break;				}				if ((ast_strlen_zero(iaxs[fr->callno]->secret) && ast_strlen_zero(iaxs[fr->callno]->inkeys)) ||						ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED)) {					if (f.subclass.integer == IAX_COMMAND_REGREL) {						memset(&sin, 0, sizeof(sin));						sin.sin_family = AF_INET;					}					if (update_registry(&sin, fr->callno, ies.devicetype, fd, ies.refresh)) {						ast_log(LOG_WARNING, "Registry error\n");					}					if (!iaxs[fr->callno]) {						break;					}					if (ies.provverpres && ies.serviceident && sin.sin_addr.s_addr) {						ast_mutex_unlock(&iaxsl[fr->callno]);						check_provisioning(&sin, fd, ies.serviceident, ies.provver);						ast_mutex_lock(&iaxsl[fr->callno]);					}					break;				}				registry_authrequest(fr->callno);				break;			case IAX_COMMAND_REGACK:				if (iax2_ack_registry(&ies, &sin, fr->callno)) 					ast_log(LOG_WARNING, "Registration failure\n");				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_REGREJ:				if (iaxs[fr->callno]->reg) {					if (authdebug) {						ast_log(LOG_NOTICE, "Registration of '%s' rejected: '%s' from: '%s'\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>", ast_inet_ntoa(sin.sin_addr));						manager_event(EVENT_FLAG_SYSTEM, "Registry", "ChannelType: IAX2\r\nUsername: %s\r\nStatus: Rejected\r\nCause: %s\r\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>");					}					iaxs[fr->callno]->reg->regstate = REG_STATE_REJECTED;				}				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_REGAUTH:				/* Authentication request */				if (registry_rerequest(&ies, fr->callno, &sin)) {					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No authority found");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_FACILITY_NOT_SUBSCRIBED);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);				}				break;			case IAX_COMMAND_TXREJ:				iaxs[fr->callno]->transferring = 0;				ast_verb(3, "Channel '%s' unable to transfer\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");				memset(&iaxs[fr->callno]->transfer, 0, sizeof(iaxs[fr->callno]->transfer));				if (iaxs[fr->callno]->bridgecallno) {					if (iaxs[iaxs[fr->callno]->bridgecallno]->transferring) {						iaxs[iaxs[fr->callno]->bridgecallno]->transferring = 0;						send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREJ, 0, NULL, 0, -1);					}				}				break;			case IAX_COMMAND_TXREADY:				if ((iaxs[fr->callno]->transferring == TRANSFER_BEGIN) ||				    (iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)) {					if (iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)						iaxs[fr->callno]->transferring = TRANSFER_MREADY;					else						iaxs[fr->callno]->transferring = TRANSFER_READY;					ast_verb(3, "Channel '%s' ready to transfer\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					if (iaxs[fr->callno]->bridgecallno) {						if ((iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_READY) ||						    (iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_MREADY)) {							/* They're both ready, now release them. */							if (iaxs[fr->callno]->transferring == TRANSFER_MREADY) {								ast_verb(3, "Attempting media bridge of %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_MEDIA;								iaxs[fr->callno]->transferring = TRANSFER_MEDIA;								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied1.buf, ied1.pos, -1);							} else {								ast_verb(3, "Releasing %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_RELEASED;								iaxs[fr->callno]->transferring = TRANSFER_RELEASED;								ast_set_flag64(iaxs[iaxs[fr->callno]->bridgecallno], IAX_ALREADYGONE);								ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);								/* Stop doing lag & ping requests */								stop_stuff(fr->callno);								stop_stuff(iaxs[fr->callno]->bridgecallno);								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied1.buf, ied1.pos, -1);							}						}					}				}				break;			case IAX_COMMAND_TXREQ:				try_transfer(iaxs[fr->callno], &ies);				break;			case IAX_COMMAND_TXCNT:				if (iaxs[fr->callno]->transferring)					send_command_transfer(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXACC, 0, NULL, 0);				break;			case IAX_COMMAND_TXREL:				/* Send ack immediately, rather than waiting until we've changed addresses */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				complete_transfer(fr->callno, &ies);				stop_stuff(fr->callno);	/* for attended transfer to work with libiax */				break;				case IAX_COMMAND_TXMEDIA:				if (iaxs[fr->callno]->transferring == TRANSFER_READY) {					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* Cancel any outstanding frames and start anew */						if (cur->transfer) {							cur->retries = -1;						}					}					/* Start sending our media to the transfer address, but otherwise leave the call as-is */					iaxs[fr->callno]->transferring = TRANSFER_MEDIAPASS;				}				break;			case IAX_COMMAND_RTKEY:				if (!IAX_CALLENCRYPTED(iaxs[fr->callno])) {					ast_log(LOG_WARNING, 						"we've been told to rotate our encryption key, "						"but this isn't an encrypted call. bad things will happen.\n"					);					break;				}				IAX_DEBUGDIGEST("Receiving", ies.challenge);				ast_aes_set_decrypt_key((unsigned char *) ies.challenge, &iaxs[fr->callno]->dcx);				break;			case IAX_COMMAND_DPREP:				complete_dpreply(iaxs[fr->callno], &ies);				break;			case IAX_COMMAND_UNSUPPORT:				ast_log(LOG_NOTICE, "Peer did not understand our iax command '%d'\n", ies.iax_unknown);				break;			case IAX_COMMAND_FWDOWNL:				/* Firmware download */				if (!ast_test_flag64(&globalflags, IAX_ALLOWFWDOWNLOAD)) {					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_UNSUPPORT, 0, NULL, 0, -1);					break;				}				memset(&ied0, 0, sizeof(ied0));				res = iax_firmware_append(&ied0, (unsigned char *)ies.devicetype, ies.fwdesc);				if (res < 0)					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);				else if (res > 0)					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1);				else					send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1);				break;			case IAX_COMMAND_CALLTOKEN:			{				struct iax_frame *cur;				/* find last sent frame */				if ((cur = AST_LIST_LAST(&frame_queue[fr->callno])) && ies.calltoken && ies.calltokendata) {					resend_with_token(fr->callno, cur, (char *) ies.calltokendata);				}				break;			}			default:				ast_debug(1, "Unknown IAX command %d on %d/%d\n", f.subclass.integer, fr->callno, iaxs[fr->callno]->peercallno);				memset(&ied0, 0, sizeof(ied0));				iax_ie_append_byte(&ied0, IAX_IE_IAX_UNKNOWN, f.subclass.integer);				send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_UNSUPPORT, 0, ied0.buf, ied0.pos, -1);			}
f.frametype == AST_FRAME_IAX
f.frametype
f
f
frametype
AST_FRAME_IAX
AST_FRAME_IAX
{			AST_SCHED_DEL(sched, iaxs[fr->callno]->initid);			/* Handle the IAX pseudo frame itself */			if (iaxdebug)				ast_debug(1, "IAX subclass %d received\n", f.subclass.integer);                        /* Update last ts unless the frame's timestamp originated with us. */			if (iaxs[fr->callno]->last < fr->ts &&                            f.subclass.integer != IAX_COMMAND_ACK &&                            f.subclass.integer != IAX_COMMAND_PONG &&                            f.subclass.integer != IAX_COMMAND_LAGRP) {				iaxs[fr->callno]->last = fr->ts;				if (iaxdebug)					ast_debug(1, "For call=%d, set last=%d\n", fr->callno, fr->ts);			}			iaxs[fr->callno]->last_iax_message = f.subclass.integer;			if (!iaxs[fr->callno]->first_iax_message) {				iaxs[fr->callno]->first_iax_message = f.subclass.integer;			}			switch(f.subclass.integer) {			case IAX_COMMAND_ACK:				/* Do nothing */				break;			case IAX_COMMAND_QUELCH:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {				        /* Generate Manager Hold event, if necessary*/					if (iaxs[fr->callno]->owner) {						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: On\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}					ast_set_flag64(iaxs[fr->callno], IAX_QUELCH);					if (ies.musiconhold) {						iax2_lock_owner(fr->callno);						if (!iaxs[fr->callno] || !iaxs[fr->callno]->owner) {							break;						}						if (ast_bridged_channel(iaxs[fr->callno]->owner)) {							const char *moh_suggest = iaxs[fr->callno]->mohsuggest;							/*							 * We already hold the owner lock so we do not							 * need to check iaxs[fr->callno] after it returns.							 */							iax2_queue_control_data(fr->callno, AST_CONTROL_HOLD, 								S_OR(moh_suggest, NULL),								!ast_strlen_zero(moh_suggest) ? strlen(moh_suggest) + 1 : 0);						}						ast_channel_unlock(iaxs[fr->callno]->owner);					}				}				break;			case IAX_COMMAND_UNQUELCH:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {					iax2_lock_owner(fr->callno);					if (!iaxs[fr->callno]) {						break;					}					/* Generate Manager Unhold event, if necessary */					if (iaxs[fr->callno]->owner && ast_test_flag64(iaxs[fr->callno], IAX_QUELCH)) {						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: Off\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}					ast_clear_flag64(iaxs[fr->callno], IAX_QUELCH);					if (!iaxs[fr->callno]->owner) {						break;					}					if (ast_bridged_channel(iaxs[fr->callno]->owner)) {						/*						 * We already hold the owner lock so we do not						 * need to check iaxs[fr->callno] after it returns.						 */						iax2_queue_control_data(fr->callno, AST_CONTROL_UNHOLD, NULL, 0);					}					ast_channel_unlock(iaxs[fr->callno]->owner);				}				break;			case IAX_COMMAND_TXACC:				if (iaxs[fr->callno]->transferring == TRANSFER_BEGIN) {					/* Ack the packet with the given timestamp */					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* Cancel any outstanding txcnt's */						if (cur->transfer) {							cur->retries = -1;						}					}					memset(&ied1, 0, sizeof(ied1));					iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->callno);					send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREADY, 0, ied1.buf, ied1.pos, -1);					iaxs[fr->callno]->transferring = TRANSFER_READY;				}				break;			case IAX_COMMAND_NEW:				/* Ignore if it's already up */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD))					break;				if (ies.provverpres && ies.serviceident && sin.sin_addr.s_addr) {					ast_mutex_unlock(&iaxsl[fr->callno]);					check_provisioning(&sin, fd, ies.serviceident, ies.provver);					ast_mutex_lock(&iaxsl[fr->callno]);					if (!iaxs[fr->callno]) {						break;					}				}				/* If we're in trunk mode, do it now, and update the trunk number in our frame before continuing */				if (ast_test_flag64(iaxs[fr->callno], IAX_TRUNK)) {					int new_callno;					if ((new_callno = make_trunk(fr->callno, 1)) != -1)						fr->callno = new_callno;				}				/* For security, always ack immediately */				if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				if (check_access(fr->callno, &sin, &ies)) {					/* They're not allowed on */					auth_fail(fr->callno, IAX_COMMAND_REJECT);					if (authdebug)						ast_log(LOG_NOTICE, "Rejected connect attempt from %s, who was trying to reach '%s@%s'\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					break;				}				if (ast_strlen_zero(iaxs[fr->callno]->secret) && ast_test_flag64(iaxs[fr->callno], IAX_FORCE_ENCRYPT)) {					auth_fail(fr->callno, IAX_COMMAND_REJECT);					ast_log(LOG_WARNING, "Rejected connect attempt.  No secret present while force encrypt enabled.\n");					break;				}				if (strcasecmp(iaxs[fr->callno]->exten, "TBD")) {					const char *context, *exten, *cid_num;					context = ast_strdupa(iaxs[fr->callno]->context);					exten = ast_strdupa(iaxs[fr->callno]->exten);					cid_num = ast_strdupa(iaxs[fr->callno]->cid_num);					/* This might re-enter the IAX code and need the lock */					ast_mutex_unlock(&iaxsl[fr->callno]);					exists = ast_exists_extension(NULL, context, exten, 1, cid_num);					ast_mutex_lock(&iaxsl[fr->callno]);					if (!iaxs[fr->callno]) {						break;					}				} else					exists = 0;				/* Get OSP token if it does exist */				save_osptoken(fr, &ies);				if (ast_strlen_zero(iaxs[fr->callno]->secret) && ast_strlen_zero(iaxs[fr->callno]->inkeys)) {					if (strcmp(iaxs[fr->callno]->exten, "TBD") && !exists) {						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}						if (authdebug)							ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					} else {						/* Select an appropriate format */						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								using_prefs = "reqonly";							} else {								using_prefs = "disabled";							}							format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;							memset(&pref, 0, sizeof(pref));							strcpy(caller_pref_buf, "disabled");							strcpy(host_pref_buf, "disabled");						} else {							struct ast_format tmpfmt;							using_prefs = "mine";							/* If the information elements are in here... use them */							if (ies.codec_prefs)								ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);							if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {								/* If we are codec_first_choice we let the caller have the 1st shot at picking the codec.*/								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {									pref = iaxs[fr->callno]->rprefs;									using_prefs = "caller";								} else {									pref = iaxs[fr->callno]->prefs;								}							} else								pref = iaxs[fr->callno]->prefs;							format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);							ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);							ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);						}						if (!format) {							if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP))								format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;							if (!format) {								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}								if (authdebug) {									char tmp[256], tmp2[256], tmp3[256];									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}							} else {								/* Pick one... */								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))										format = 0;								} else {									if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {										using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";										memset(&pref, 0, sizeof(pref));										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);										strcpy(caller_pref_buf,"disabled");										strcpy(host_pref_buf,"disabled");									} else {										struct ast_format tmpfmt;										using_prefs = "mine";										if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {											/* Do the opposite of what we tried above. */											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);										} else /* if no codec_prefs IE do it the old way */											format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}								}								if (!format) {									char tmp[256], tmp2[256], tmp3[256];									memset(&ied0, 0, sizeof(ied0));									iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");									iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);									ast_log(LOG_ERROR, "No best format in '%s'???\n", iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));									send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);									if (!iaxs[fr->callno]) {										break;									}									if (authdebug) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}									ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);									break;								}							}						}						if (format) {							/* No authentication required, let them in */							memset(&ied1, 0, sizeof(ied1));							iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);							iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);							send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);							if (strcmp(iaxs[fr->callno]->exten, "TBD")) {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);								ast_verb(3, "Accepting UNAUTHENTICATED call from %s:\n"												"%srequested format = %s,\n"												"%srequested prefs = %s,\n"												"%sactual format = %s,\n"												"%shost prefs = %s,\n"												"%spriority = %s\n",												ast_inet_ntoa(sin.sin_addr), 												VERBOSE_PREFIX_4,												iax2_getformatname(iaxs[fr->callno]->peerformat), 												VERBOSE_PREFIX_4,												caller_pref_buf,												VERBOSE_PREFIX_4,												iax2_getformatname(format), 												VERBOSE_PREFIX_4,												host_pref_buf, 												VERBOSE_PREFIX_4,												using_prefs);								iaxs[fr->callno]->chosenformat = format;								/* Since this is a new call, we should go ahead and set the callid for it. */								iax_pvt_callid_new(fr->callno);								ast_set_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);							} else {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);								/* If this is a TBD call, we're ready but now what...  */								ast_verb(3, "Accepted unauthenticated TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							}						}					}					break;				}				if (iaxs[fr->callno]->authmethods & IAX_AUTH_MD5)					merge_encryption(iaxs[fr->callno],ies.encmethods);				else					iaxs[fr->callno]->encmethods = 0;				if (!authenticate_request(fr->callno) && iaxs[fr->callno])					ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED);				break;			case IAX_COMMAND_DPREQ:				/* Request status in the dialplan */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD) &&					!ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED) && ies.called_number) {					if (iaxcompat) {						/* Spawn a thread for the lookup */						spawn_dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num);					} else {						/* Just look it up */						dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num, 1);					}				}				break;			case IAX_COMMAND_HANGUP:				ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);				ast_debug(1, "Immediately destroying %d, having received hangup\n", fr->callno);				/* Set hangup cause according to remote and hangupsource */				if (iaxs[fr->callno]->owner) {					set_hangup_source_and_cause(fr->callno, ies.causecode);					if (!iaxs[fr->callno]) {						break;					}				}				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_REJECT:				/* Set hangup cause according to remote and hangup source */				if (iaxs[fr->callno]->owner) {					set_hangup_source_and_cause(fr->callno, ies.causecode);					if (!iaxs[fr->callno]) {						break;					}				}				if (!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)) {					if (iaxs[fr->callno]->owner && authdebug)						ast_log(LOG_WARNING, "Call rejected by %s: %s\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr),							ies.cause ? ies.cause : "<Unknown>");					ast_debug(1, "Immediately destroying %d, having received reject\n",						fr->callno);				}				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK,						       fr->ts, NULL, 0, fr->iseqno);				if (!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION))					iaxs[fr->callno]->error = EPERM;				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_TRANSFER:			{				struct ast_channel *bridged_chan;				struct ast_channel *owner;				iax2_lock_owner(fr->callno);				if (!iaxs[fr->callno]) {					/* Initiating call went away before we could transfer. */					break;				}				owner = iaxs[fr->callno]->owner;				bridged_chan = owner ? ast_bridged_channel(owner) : NULL;				if (bridged_chan && ies.called_number) {					const char *context;					context = ast_strdupa(iaxs[fr->callno]->context);					ast_channel_ref(owner);					ast_channel_ref(bridged_chan);					ast_channel_unlock(owner);					ast_mutex_unlock(&iaxsl[fr->callno]);					/* Set BLINDTRANSFER channel variables */					pbx_builtin_setvar_helper(owner, "BLINDTRANSFER", ast_channel_name(bridged_chan));					pbx_builtin_setvar_helper(bridged_chan, "BLINDTRANSFER", ast_channel_name(owner));					/* DO NOT hold any locks while calling ast_parking_ext_valid() */					if (ast_parking_ext_valid(ies.called_number, owner, context)) {						ast_debug(1, "Parking call '%s'\n", ast_channel_name(bridged_chan));						if (iax_park(bridged_chan, owner, ies.called_number, context)) {							ast_log(LOG_WARNING, "Failed to park call '%s'\n",								ast_channel_name(bridged_chan));						}					} else {						if (ast_async_goto(bridged_chan, context, ies.called_number, 1)) {							ast_log(LOG_WARNING,								"Async goto of '%s' to '%s@%s' failed\n",								ast_channel_name(bridged_chan), ies.called_number, context);						} else {							ast_debug(1, "Async goto of '%s' to '%s@%s' started\n",								ast_channel_name(bridged_chan), ies.called_number, context);						}					}					ast_channel_unref(owner);					ast_channel_unref(bridged_chan);					ast_mutex_lock(&iaxsl[fr->callno]);				} else {					ast_debug(1, "Async goto not applicable on call %d\n", fr->callno);					if (owner) {						ast_channel_unlock(owner);					}				}				break;			}			case IAX_COMMAND_ACCEPT:				/* Ignore if call is already up or needs authentication or is a TBD */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD | IAX_STATE_AUTHENTICATED))					break;				if (ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)) {					/* Send ack immediately, before we destroy */					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					iax2_destroy(fr->callno);					break;				}				if (ies.format) {					iaxs[fr->callno]->peerformat = ies.format;				} else {					if (iaxs[fr->callno]->owner)						iaxs[fr->callno]->peerformat = ast_format_cap_to_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner));					else						iaxs[fr->callno]->peerformat = iaxs[fr->callno]->capability;				}				ast_verb(3, "Call accepted by %s (format %s)\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iax2_getformatname(iaxs[fr->callno]->peerformat));				if (!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)) {					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);					if (!iaxs[fr->callno]) {						break;					}					if (authdebug) {						char tmp1[256], tmp2[256];						ast_log(LOG_NOTICE, "Rejected call to %s, format %s incompatible with our capability %s.\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),							iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));					}				} else {					ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);					iax2_lock_owner(fr->callno);					if (iaxs[fr->callno] && iaxs[fr->callno]->owner) {						char tmp[256];						/* Switch us to use a compatible format */						ast_format_cap_from_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner), iaxs[fr->callno]->peerformat);						ast_verb(3, "Format for call is %s\n", ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(iaxs[fr->callno]->owner)));						/* Setup read/write formats properly. */						if (ast_channel_writeformat(iaxs[fr->callno]->owner)->id)							ast_set_write_format(iaxs[fr->callno]->owner, ast_channel_writeformat(iaxs[fr->callno]->owner));						if (ast_channel_readformat(iaxs[fr->callno]->owner)->id)							ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));						ast_channel_unlock(iaxs[fr->callno]->owner);					}				}				if (iaxs[fr->callno]) {					AST_LIST_LOCK(&dpcache);					AST_LIST_TRAVERSE(&iaxs[fr->callno]->dpentries, dp, peer_list)						if (!(dp->flags & CACHE_FLAG_TRANSMITTED))							iax2_dprequest(dp, fr->callno);					AST_LIST_UNLOCK(&dpcache);				}				break;			case IAX_COMMAND_POKE:				/* Send back a pong packet with the original timestamp */				send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, NULL, 0, -1);				break;			case IAX_COMMAND_PING:			{				struct iax_ie_data pingied;				construct_rr(iaxs[fr->callno], &pingied);				/* Send back a pong packet with the original timestamp */				send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, pingied.buf, pingied.pos, -1);			}				break;			case IAX_COMMAND_PONG:				/* Calculate ping time */				iaxs[fr->callno]->pingtime =  calc_timestamp(iaxs[fr->callno], 0, &f) - fr->ts;				/* save RR info */				save_rr(fr, &ies);				/* Good time to write jb stats for this call */				log_jitterstats(fr->callno);				if (iaxs[fr->callno]->peerpoke) {					peer = iaxs[fr->callno]->peerpoke;					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms)) {						if (iaxs[fr->callno]->pingtime <= peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now REACHABLE! Time: %d\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Reachable\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_NOT_INUSE, "IAX2/%s", peer->name); /* Activate notification */						}					} else if ((peer->historicms > 0) && (peer->historicms <= peer->maxms)) {						if (iaxs[fr->callno]->pingtime > peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now TOO LAGGED (%d ms)!\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Lagged\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_UNAVAILABLE, "IAX2/%s", peer->name); /* Activate notification */						}					}					peer->lastms = iaxs[fr->callno]->pingtime;					if (peer->smoothing && (peer->lastms > -1))						peer->historicms = (iaxs[fr->callno]->pingtime + peer->historicms) / 2;					else if (peer->smoothing && peer->lastms < 0)						peer->historicms = (0 + peer->historicms) / 2;					else											peer->historicms = iaxs[fr->callno]->pingtime;					/* Remove scheduled iax2_poke_noanswer */					if (peer->pokeexpire > -1) {						if (!AST_SCHED_DEL(sched, peer->pokeexpire)) {							peer_unref(peer);							peer->pokeexpire = -1;						}					}					/* Schedule the next cycle */					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms))						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_peer_s, peer_ref(peer));					else						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqok, iax2_poke_peer_s, peer_ref(peer));					if (peer->pokeexpire == -1)						peer_unref(peer);					/* and finally send the ack */					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					/* And wrap up the qualify call */					iax2_destroy(fr->callno);					peer->callno = 0;					ast_debug(1, "Peer %s: got pong, lastms %d, historicms %d, maxms %d\n", peer->name, peer->lastms, peer->historicms, peer->maxms);				}				break;			case IAX_COMMAND_LAGRQ:			case IAX_COMMAND_LAGRP:				f.src = "LAGRQ";				f.mallocd = 0;				f.offset = 0;				f.samples = 0;				iax_frame_wrap(fr, &f);				if (f.subclass.integer == IAX_COMMAND_LAGRQ) {					/* Received a LAGRQ - echo back a LAGRP */					fr->af.subclass.integer = IAX_COMMAND_LAGRP;					iax2_send(iaxs[fr->callno], &fr->af, fr->ts, -1, 0, 0, 0);				} else {					/* Received LAGRP in response to our LAGRQ */					unsigned int ts;					/* This is a reply we've been given, actually measure the difference */					ts = calc_timestamp(iaxs[fr->callno], 0, &fr->af);					iaxs[fr->callno]->lag = ts - fr->ts;					if (iaxdebug)						ast_debug(1, "Peer %s lag measured as %dms\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->lag);				}				break;			case IAX_COMMAND_AUTHREQ:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)) {					ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					break;				}				if (authenticate_reply(iaxs[fr->callno], &iaxs[fr->callno]->addr, &ies, iaxs[fr->callno]->secret, iaxs[fr->callno]->outkey)) {					struct ast_frame hangup_fr = { .frametype = AST_FRAME_CONTROL,								.subclass.integer = AST_CONTROL_HANGUP,					};					ast_log(LOG_WARNING, 						"I don't know how to authenticate %s to %s\n", 						ies.username ? ies.username : "<unknown>", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr));					iax2_queue_frame(fr->callno, &hangup_fr);				}				break;			case IAX_COMMAND_AUTHREP:				/* For security, always ack immediately */				if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				/* Ignore once we've started */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)) {					ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					break;				}				if (authenticate_verify(iaxs[fr->callno], &ies)) {					if (authdebug)						ast_log(LOG_NOTICE, "Host %s failed to authenticate as %s\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->username);					memset(&ied0, 0, sizeof(ied0));					auth_fail(fr->callno, IAX_COMMAND_REJECT);					break;				}				if (strcasecmp(iaxs[fr->callno]->exten, "TBD")) {					/* This might re-enter the IAX code and need the lock */					exists = ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num);				} else					exists = 0;				if (strcmp(iaxs[fr->callno]->exten, "TBD") && !exists) {					if (authdebug)						ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);					if (!iaxs[fr->callno]) {						break;					}				} else {					/* Select an appropriate format */					if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {							using_prefs = "reqonly";						} else {							using_prefs = "disabled";						}						format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;						memset(&pref, 0, sizeof(pref));						strcpy(caller_pref_buf, "disabled");						strcpy(host_pref_buf, "disabled");					} else {						struct ast_format tmpfmt;						using_prefs = "mine";						if (ies.codec_prefs)							ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);						if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {							if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {								pref = iaxs[fr->callno]->rprefs;								using_prefs = "caller";							} else {								pref = iaxs[fr->callno]->prefs;							}						} else /* if no codec_prefs IE do it the old way */							pref = iaxs[fr->callno]->prefs;						format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);						ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);						ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);					}					if (!format) {						char tmp1[256], tmp2[256], tmp3[256];						if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {							ast_debug(1, "We don't do requested format %s, falling back to peer capability '%s'\n",								iax2_getformatname(iaxs[fr->callno]->peerformat),								iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability));							format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;						}						if (!format) {							if (authdebug) {								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n", ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));								} else {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",										ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),										iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));								}							}							memset(&ied0, 0, sizeof(ied0));							iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");							iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);							send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);							if (!iaxs[fr->callno]) {								break;							}						} else {							/* Pick one... */							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))									format = 0;							} else {								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {									using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";									memset(&pref, 0, sizeof(pref));									format = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ?										iaxs[fr->callno]->peerformat : iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									strcpy(caller_pref_buf,"disabled");									strcpy(host_pref_buf,"disabled");								} else {									struct ast_format tmpfmt;									using_prefs = "mine";									if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {										/* Do the opposite of what we tried above. */										if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {											pref = iaxs[fr->callno]->prefs;										} else {											pref = iaxs[fr->callno]->rprefs;											using_prefs = "caller";										}										format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);									} else /* if no codec_prefs IE do it the old way */										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}							}							if (!format) {								char tmp1[256], tmp2[256], tmp3[256];								ast_log(LOG_ERROR, "No best format in %s???\n",									iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));								if (authdebug) {									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}							}						}					}					if (format) {						/* Authentication received */						memset(&ied1, 0, sizeof(ied1));						iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);						iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);						send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);						if (strcmp(iaxs[fr->callno]->exten, "TBD")) {							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							ast_verb(3, "Accepting AUTHENTICATED call from %s:\n"											"%srequested format = %s,\n"											"%srequested prefs = %s,\n"											"%sactual format = %s,\n"											"%shost prefs = %s,\n"											"%spriority = %s\n", 											ast_inet_ntoa(sin.sin_addr), 											VERBOSE_PREFIX_4,											iax2_getformatname(iaxs[fr->callno]->peerformat),											VERBOSE_PREFIX_4,											caller_pref_buf,											VERBOSE_PREFIX_4,											iax2_getformatname(format),											VERBOSE_PREFIX_4,											host_pref_buf,											VERBOSE_PREFIX_4,											using_prefs);							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, format, NULL)))								iax2_destroy(fr->callno);							else if (ies.vars) {								struct ast_datastore *variablestore;								struct ast_variable *var, *prev = NULL;								AST_LIST_HEAD(, ast_var_t) *varlist;								varlist = ast_calloc(1, sizeof(*varlist));								variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);								if (variablestore && varlist) {									variablestore->data = varlist;									variablestore->inheritance = DATASTORE_INHERIT_FOREVER;									AST_LIST_HEAD_INIT(varlist);									ast_debug(1, "I can haz IAX vars? w00t\n");									for (var = ies.vars; var; var = var->next) {										struct ast_var_t *newvar = ast_var_assign(var->name, var->value);										if (prev)											ast_free(prev);										prev = var;										if (!newvar) {											/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */											ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");										} else {											AST_LIST_INSERT_TAIL(varlist, newvar, entries);										}									}									if (prev)										ast_free(prev);									ies.vars = NULL;									ast_channel_datastore_add(c, variablestore);								} else {									ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									if (variablestore)										ast_datastore_free(variablestore);									if (varlist)										ast_free(varlist);								}							}						} else {							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);							/* If this is a TBD call, we're ready but now what...  */							ast_verb(3, "Accepted AUTHENTICATED TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							if (ast_test_flag64(iaxs[fr->callno], IAX_IMMEDIATE)) {								goto immediatedial;							}						}					}				}				break;			case IAX_COMMAND_DIAL:immediatedial:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD)) {					ast_clear_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);					ast_string_field_set(iaxs[fr->callno], exten, ies.called_number ? ies.called_number : "s");					if (!ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num)) {						if (authdebug)							ast_log(LOG_NOTICE, "Rejected dial attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}					} else {						char tmp[256];						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);						ast_verb(3, "Accepting DIAL from %s, formats = %s\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat));						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);						send_command(iaxs[fr->callno], AST_FRAME_CONTROL, AST_CONTROL_PROGRESS, 0, NULL, 0, -1);						if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->peerformat, NULL)))							iax2_destroy(fr->callno);						else if (ies.vars) {							struct ast_datastore *variablestore;							struct ast_variable *var, *prev = NULL;							AST_LIST_HEAD(, ast_var_t) *varlist;							varlist = ast_calloc(1, sizeof(*varlist));							variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);							ast_debug(1, "I can haz IAX vars? w00t\n");							if (variablestore && varlist) {								variablestore->data = varlist;								variablestore->inheritance = DATASTORE_INHERIT_FOREVER;								AST_LIST_HEAD_INIT(varlist);								for (var = ies.vars; var; var = var->next) {									struct ast_var_t *newvar = ast_var_assign(var->name, var->value);									if (prev)										ast_free(prev);									prev = var;									if (!newvar) {										/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */										ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									} else {										AST_LIST_INSERT_TAIL(varlist, newvar, entries);									}								}								if (prev)									ast_free(prev);								ies.vars = NULL;								ast_channel_datastore_add(c, variablestore);							} else {								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");								if (variablestore)									ast_datastore_free(variablestore);								if (varlist)									ast_free(varlist);							}						}					}				}				break;			case IAX_COMMAND_INVAL:				iaxs[fr->callno]->error = ENOTCONN;				ast_debug(1, "Immediately destroying %d, having received INVAL\n", fr->callno);				iax2_destroy(fr->callno);				ast_debug(1, "Destroying call %d\n", fr->callno);				break;			case IAX_COMMAND_VNAK:				ast_debug(1, "Received VNAK: resending outstanding frames\n");				/* Force retransmission */				vnak_retransmit(fr->callno, fr->iseqno);				break;			case IAX_COMMAND_REGREQ:			case IAX_COMMAND_REGREL:				/* For security, always ack immediately */				if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				if (register_verify(fr->callno, &sin, &ies)) {					if (!iaxs[fr->callno]) {						break;					}					/* Send delayed failure */					auth_fail(fr->callno, IAX_COMMAND_REGREJ);					break;				}				if (!iaxs[fr->callno]) {					break;				}				if ((ast_strlen_zero(iaxs[fr->callno]->secret) && ast_strlen_zero(iaxs[fr->callno]->inkeys)) ||						ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED)) {					if (f.subclass.integer == IAX_COMMAND_REGREL) {						memset(&sin, 0, sizeof(sin));						sin.sin_family = AF_INET;					}					if (update_registry(&sin, fr->callno, ies.devicetype, fd, ies.refresh)) {						ast_log(LOG_WARNING, "Registry error\n");					}					if (!iaxs[fr->callno]) {						break;					}					if (ies.provverpres && ies.serviceident && sin.sin_addr.s_addr) {						ast_mutex_unlock(&iaxsl[fr->callno]);						check_provisioning(&sin, fd, ies.serviceident, ies.provver);						ast_mutex_lock(&iaxsl[fr->callno]);					}					break;				}				registry_authrequest(fr->callno);				break;			case IAX_COMMAND_REGACK:				if (iax2_ack_registry(&ies, &sin, fr->callno)) 					ast_log(LOG_WARNING, "Registration failure\n");				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_REGREJ:				if (iaxs[fr->callno]->reg) {					if (authdebug) {						ast_log(LOG_NOTICE, "Registration of '%s' rejected: '%s' from: '%s'\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>", ast_inet_ntoa(sin.sin_addr));						manager_event(EVENT_FLAG_SYSTEM, "Registry", "ChannelType: IAX2\r\nUsername: %s\r\nStatus: Rejected\r\nCause: %s\r\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>");					}					iaxs[fr->callno]->reg->regstate = REG_STATE_REJECTED;				}				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_REGAUTH:				/* Authentication request */				if (registry_rerequest(&ies, fr->callno, &sin)) {					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No authority found");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_FACILITY_NOT_SUBSCRIBED);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);				}				break;			case IAX_COMMAND_TXREJ:				iaxs[fr->callno]->transferring = 0;				ast_verb(3, "Channel '%s' unable to transfer\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");				memset(&iaxs[fr->callno]->transfer, 0, sizeof(iaxs[fr->callno]->transfer));				if (iaxs[fr->callno]->bridgecallno) {					if (iaxs[iaxs[fr->callno]->bridgecallno]->transferring) {						iaxs[iaxs[fr->callno]->bridgecallno]->transferring = 0;						send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREJ, 0, NULL, 0, -1);					}				}				break;			case IAX_COMMAND_TXREADY:				if ((iaxs[fr->callno]->transferring == TRANSFER_BEGIN) ||				    (iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)) {					if (iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)						iaxs[fr->callno]->transferring = TRANSFER_MREADY;					else						iaxs[fr->callno]->transferring = TRANSFER_READY;					ast_verb(3, "Channel '%s' ready to transfer\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					if (iaxs[fr->callno]->bridgecallno) {						if ((iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_READY) ||						    (iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_MREADY)) {							/* They're both ready, now release them. */							if (iaxs[fr->callno]->transferring == TRANSFER_MREADY) {								ast_verb(3, "Attempting media bridge of %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_MEDIA;								iaxs[fr->callno]->transferring = TRANSFER_MEDIA;								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied1.buf, ied1.pos, -1);							} else {								ast_verb(3, "Releasing %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_RELEASED;								iaxs[fr->callno]->transferring = TRANSFER_RELEASED;								ast_set_flag64(iaxs[iaxs[fr->callno]->bridgecallno], IAX_ALREADYGONE);								ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);								/* Stop doing lag & ping requests */								stop_stuff(fr->callno);								stop_stuff(iaxs[fr->callno]->bridgecallno);								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied1.buf, ied1.pos, -1);							}						}					}				}				break;			case IAX_COMMAND_TXREQ:				try_transfer(iaxs[fr->callno], &ies);				break;			case IAX_COMMAND_TXCNT:				if (iaxs[fr->callno]->transferring)					send_command_transfer(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXACC, 0, NULL, 0);				break;			case IAX_COMMAND_TXREL:				/* Send ack immediately, rather than waiting until we've changed addresses */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				complete_transfer(fr->callno, &ies);				stop_stuff(fr->callno);	/* for attended transfer to work with libiax */				break;				case IAX_COMMAND_TXMEDIA:				if (iaxs[fr->callno]->transferring == TRANSFER_READY) {					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* Cancel any outstanding frames and start anew */						if (cur->transfer) {							cur->retries = -1;						}					}					/* Start sending our media to the transfer address, but otherwise leave the call as-is */					iaxs[fr->callno]->transferring = TRANSFER_MEDIAPASS;				}				break;			case IAX_COMMAND_RTKEY:				if (!IAX_CALLENCRYPTED(iaxs[fr->callno])) {					ast_log(LOG_WARNING, 						"we've been told to rotate our encryption key, "						"but this isn't an encrypted call. bad things will happen.\n"					);					break;				}				IAX_DEBUGDIGEST("Receiving", ies.challenge);				ast_aes_set_decrypt_key((unsigned char *) ies.challenge, &iaxs[fr->callno]->dcx);				break;			case IAX_COMMAND_DPREP:				complete_dpreply(iaxs[fr->callno], &ies);				break;			case IAX_COMMAND_UNSUPPORT:				ast_log(LOG_NOTICE, "Peer did not understand our iax command '%d'\n", ies.iax_unknown);				break;			case IAX_COMMAND_FWDOWNL:				/* Firmware download */				if (!ast_test_flag64(&globalflags, IAX_ALLOWFWDOWNLOAD)) {					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_UNSUPPORT, 0, NULL, 0, -1);					break;				}				memset(&ied0, 0, sizeof(ied0));				res = iax_firmware_append(&ied0, (unsigned char *)ies.devicetype, ies.fwdesc);				if (res < 0)					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);				else if (res > 0)					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1);				else					send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1);				break;			case IAX_COMMAND_CALLTOKEN:			{				struct iax_frame *cur;				/* find last sent frame */				if ((cur = AST_LIST_LAST(&frame_queue[fr->callno])) && ies.calltoken && ies.calltokendata) {					resend_with_token(fr->callno, cur, (char *) ies.calltokendata);				}				break;			}			default:				ast_debug(1, "Unknown IAX command %d on %d/%d\n", f.subclass.integer, fr->callno, iaxs[fr->callno]->peercallno);				memset(&ied0, 0, sizeof(ied0));				iax_ie_append_byte(&ied0, IAX_IE_IAX_UNKNOWN, f.subclass.integer);				send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_UNSUPPORT, 0, ied0.buf, ied0.pos, -1);			}
AST_SCHED_DEL(sched, iaxs[fr->callno]->initid);
AST_SCHED_DEL(sched, iaxs[fr->callno]->initid)
AST_SCHED_DEL
AST_SCHED_DEL
sched
sched
iaxs[fr->callno]->initid
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
initid
if (iaxdebug)				ast_debug(1, "IAX subclass %d received\n", f.subclass.integer);
iaxdebug
iaxdebug
ast_debug(1, "IAX subclass %d received\n", f.subclass.integer);
ast_debug(1, "IAX subclass %d received\n", f.subclass.integer)
ast_debug
ast_debug
1
"IAX subclass %d received\n"
f.subclass.integer
f.subclass
f
f
subclass
integer
if (iaxs[fr->callno]->last < fr->ts &&                            f.subclass.integer != IAX_COMMAND_ACK &&                            f.subclass.integer != IAX_COMMAND_PONG &&                            f.subclass.integer != IAX_COMMAND_LAGRP) {				iaxs[fr->callno]->last = fr->ts;				if (iaxdebug)					ast_debug(1, "For call=%d, set last=%d\n", fr->callno, fr->ts);			}
iaxs[fr->callno]->last < fr->ts &&                            f.subclass.integer != IAX_COMMAND_ACK &&                            f.subclass.integer != IAX_COMMAND_PONG &&                            f.subclass.integer != IAX_COMMAND_LAGRP
iaxs[fr->callno]->last < fr->ts &&                            f.subclass.integer != IAX_COMMAND_ACK &&                            f.subclass.integer != IAX_COMMAND_PONG
iaxs[fr->callno]->last < fr->ts &&                            f.subclass.integer != IAX_COMMAND_ACK
iaxs[fr->callno]->last < fr->ts
iaxs[fr->callno]->last
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
last
fr->ts
fr
fr
ts
f.subclass.integer != IAX_COMMAND_ACK
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_ACK
IAX_COMMAND_ACK
f.subclass.integer != IAX_COMMAND_PONG
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_PONG
IAX_COMMAND_PONG
f.subclass.integer != IAX_COMMAND_LAGRP
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_LAGRP
IAX_COMMAND_LAGRP
{				iaxs[fr->callno]->last = fr->ts;				if (iaxdebug)					ast_debug(1, "For call=%d, set last=%d\n", fr->callno, fr->ts);			}
iaxs[fr->callno]->last = fr->ts;
iaxs[fr->callno]->last = fr->ts
iaxs[fr->callno]->last
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
last
fr->ts
fr
fr
ts
if (iaxdebug)					ast_debug(1, "For call=%d, set last=%d\n", fr->callno, fr->ts);
iaxdebug
iaxdebug
ast_debug(1, "For call=%d, set last=%d\n", fr->callno, fr->ts);
ast_debug(1, "For call=%d, set last=%d\n", fr->callno, fr->ts)
ast_debug
ast_debug
1
"For call=%d, set last=%d\n"
fr->callno
fr
fr
callno
fr->ts
fr
fr
ts
iaxs[fr->callno]->last_iax_message = f.subclass.integer;
iaxs[fr->callno]->last_iax_message = f.subclass.integer
iaxs[fr->callno]->last_iax_message
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
last_iax_message
f.subclass.integer
f.subclass
f
f
subclass
integer
if (!iaxs[fr->callno]->first_iax_message) {				iaxs[fr->callno]->first_iax_message = f.subclass.integer;			}
!iaxs[fr->callno]->first_iax_message
iaxs[fr->callno]->first_iax_message
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
first_iax_message
{				iaxs[fr->callno]->first_iax_message = f.subclass.integer;			}
iaxs[fr->callno]->first_iax_message = f.subclass.integer;
iaxs[fr->callno]->first_iax_message = f.subclass.integer
iaxs[fr->callno]->first_iax_message
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
first_iax_message
f.subclass.integer
f.subclass
f
f
subclass
integer
switch(f.subclass.integer) {			case IAX_COMMAND_ACK:				/* Do nothing */				break;			case IAX_COMMAND_QUELCH:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {				        /* Generate Manager Hold event, if necessary*/					if (iaxs[fr->callno]->owner) {						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: On\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}					ast_set_flag64(iaxs[fr->callno], IAX_QUELCH);					if (ies.musiconhold) {						iax2_lock_owner(fr->callno);						if (!iaxs[fr->callno] || !iaxs[fr->callno]->owner) {							break;						}						if (ast_bridged_channel(iaxs[fr->callno]->owner)) {							const char *moh_suggest = iaxs[fr->callno]->mohsuggest;							/*							 * We already hold the owner lock so we do not							 * need to check iaxs[fr->callno] after it returns.							 */							iax2_queue_control_data(fr->callno, AST_CONTROL_HOLD, 								S_OR(moh_suggest, NULL),								!ast_strlen_zero(moh_suggest) ? strlen(moh_suggest) + 1 : 0);						}						ast_channel_unlock(iaxs[fr->callno]->owner);					}				}				break;			case IAX_COMMAND_UNQUELCH:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {					iax2_lock_owner(fr->callno);					if (!iaxs[fr->callno]) {						break;					}					/* Generate Manager Unhold event, if necessary */					if (iaxs[fr->callno]->owner && ast_test_flag64(iaxs[fr->callno], IAX_QUELCH)) {						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: Off\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}					ast_clear_flag64(iaxs[fr->callno], IAX_QUELCH);					if (!iaxs[fr->callno]->owner) {						break;					}					if (ast_bridged_channel(iaxs[fr->callno]->owner)) {						/*						 * We already hold the owner lock so we do not						 * need to check iaxs[fr->callno] after it returns.						 */						iax2_queue_control_data(fr->callno, AST_CONTROL_UNHOLD, NULL, 0);					}					ast_channel_unlock(iaxs[fr->callno]->owner);				}				break;			case IAX_COMMAND_TXACC:				if (iaxs[fr->callno]->transferring == TRANSFER_BEGIN) {					/* Ack the packet with the given timestamp */					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* Cancel any outstanding txcnt's */						if (cur->transfer) {							cur->retries = -1;						}					}					memset(&ied1, 0, sizeof(ied1));					iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->callno);					send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREADY, 0, ied1.buf, ied1.pos, -1);					iaxs[fr->callno]->transferring = TRANSFER_READY;				}				break;			case IAX_COMMAND_NEW:				/* Ignore if it's already up */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD))					break;				if (ies.provverpres && ies.serviceident && sin.sin_addr.s_addr) {					ast_mutex_unlock(&iaxsl[fr->callno]);					check_provisioning(&sin, fd, ies.serviceident, ies.provver);					ast_mutex_lock(&iaxsl[fr->callno]);					if (!iaxs[fr->callno]) {						break;					}				}				/* If we're in trunk mode, do it now, and update the trunk number in our frame before continuing */				if (ast_test_flag64(iaxs[fr->callno], IAX_TRUNK)) {					int new_callno;					if ((new_callno = make_trunk(fr->callno, 1)) != -1)						fr->callno = new_callno;				}				/* For security, always ack immediately */				if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				if (check_access(fr->callno, &sin, &ies)) {					/* They're not allowed on */					auth_fail(fr->callno, IAX_COMMAND_REJECT);					if (authdebug)						ast_log(LOG_NOTICE, "Rejected connect attempt from %s, who was trying to reach '%s@%s'\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					break;				}				if (ast_strlen_zero(iaxs[fr->callno]->secret) && ast_test_flag64(iaxs[fr->callno], IAX_FORCE_ENCRYPT)) {					auth_fail(fr->callno, IAX_COMMAND_REJECT);					ast_log(LOG_WARNING, "Rejected connect attempt.  No secret present while force encrypt enabled.\n");					break;				}				if (strcasecmp(iaxs[fr->callno]->exten, "TBD")) {					const char *context, *exten, *cid_num;					context = ast_strdupa(iaxs[fr->callno]->context);					exten = ast_strdupa(iaxs[fr->callno]->exten);					cid_num = ast_strdupa(iaxs[fr->callno]->cid_num);					/* This might re-enter the IAX code and need the lock */					ast_mutex_unlock(&iaxsl[fr->callno]);					exists = ast_exists_extension(NULL, context, exten, 1, cid_num);					ast_mutex_lock(&iaxsl[fr->callno]);					if (!iaxs[fr->callno]) {						break;					}				} else					exists = 0;				/* Get OSP token if it does exist */				save_osptoken(fr, &ies);				if (ast_strlen_zero(iaxs[fr->callno]->secret) && ast_strlen_zero(iaxs[fr->callno]->inkeys)) {					if (strcmp(iaxs[fr->callno]->exten, "TBD") && !exists) {						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}						if (authdebug)							ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					} else {						/* Select an appropriate format */						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								using_prefs = "reqonly";							} else {								using_prefs = "disabled";							}							format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;							memset(&pref, 0, sizeof(pref));							strcpy(caller_pref_buf, "disabled");							strcpy(host_pref_buf, "disabled");						} else {							struct ast_format tmpfmt;							using_prefs = "mine";							/* If the information elements are in here... use them */							if (ies.codec_prefs)								ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);							if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {								/* If we are codec_first_choice we let the caller have the 1st shot at picking the codec.*/								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {									pref = iaxs[fr->callno]->rprefs;									using_prefs = "caller";								} else {									pref = iaxs[fr->callno]->prefs;								}							} else								pref = iaxs[fr->callno]->prefs;							format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);							ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);							ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);						}						if (!format) {							if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP))								format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;							if (!format) {								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}								if (authdebug) {									char tmp[256], tmp2[256], tmp3[256];									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}							} else {								/* Pick one... */								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))										format = 0;								} else {									if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {										using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";										memset(&pref, 0, sizeof(pref));										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);										strcpy(caller_pref_buf,"disabled");										strcpy(host_pref_buf,"disabled");									} else {										struct ast_format tmpfmt;										using_prefs = "mine";										if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {											/* Do the opposite of what we tried above. */											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);										} else /* if no codec_prefs IE do it the old way */											format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}								}								if (!format) {									char tmp[256], tmp2[256], tmp3[256];									memset(&ied0, 0, sizeof(ied0));									iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");									iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);									ast_log(LOG_ERROR, "No best format in '%s'???\n", iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));									send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);									if (!iaxs[fr->callno]) {										break;									}									if (authdebug) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}									ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);									break;								}							}						}						if (format) {							/* No authentication required, let them in */							memset(&ied1, 0, sizeof(ied1));							iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);							iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);							send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);							if (strcmp(iaxs[fr->callno]->exten, "TBD")) {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);								ast_verb(3, "Accepting UNAUTHENTICATED call from %s:\n"												"%srequested format = %s,\n"												"%srequested prefs = %s,\n"												"%sactual format = %s,\n"												"%shost prefs = %s,\n"												"%spriority = %s\n",												ast_inet_ntoa(sin.sin_addr), 												VERBOSE_PREFIX_4,												iax2_getformatname(iaxs[fr->callno]->peerformat), 												VERBOSE_PREFIX_4,												caller_pref_buf,												VERBOSE_PREFIX_4,												iax2_getformatname(format), 												VERBOSE_PREFIX_4,												host_pref_buf, 												VERBOSE_PREFIX_4,												using_prefs);								iaxs[fr->callno]->chosenformat = format;								/* Since this is a new call, we should go ahead and set the callid for it. */								iax_pvt_callid_new(fr->callno);								ast_set_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);							} else {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);								/* If this is a TBD call, we're ready but now what...  */								ast_verb(3, "Accepted unauthenticated TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							}						}					}					break;				}				if (iaxs[fr->callno]->authmethods & IAX_AUTH_MD5)					merge_encryption(iaxs[fr->callno],ies.encmethods);				else					iaxs[fr->callno]->encmethods = 0;				if (!authenticate_request(fr->callno) && iaxs[fr->callno])					ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED);				break;			case IAX_COMMAND_DPREQ:				/* Request status in the dialplan */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD) &&					!ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED) && ies.called_number) {					if (iaxcompat) {						/* Spawn a thread for the lookup */						spawn_dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num);					} else {						/* Just look it up */						dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num, 1);					}				}				break;			case IAX_COMMAND_HANGUP:				ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);				ast_debug(1, "Immediately destroying %d, having received hangup\n", fr->callno);				/* Set hangup cause according to remote and hangupsource */				if (iaxs[fr->callno]->owner) {					set_hangup_source_and_cause(fr->callno, ies.causecode);					if (!iaxs[fr->callno]) {						break;					}				}				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_REJECT:				/* Set hangup cause according to remote and hangup source */				if (iaxs[fr->callno]->owner) {					set_hangup_source_and_cause(fr->callno, ies.causecode);					if (!iaxs[fr->callno]) {						break;					}				}				if (!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)) {					if (iaxs[fr->callno]->owner && authdebug)						ast_log(LOG_WARNING, "Call rejected by %s: %s\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr),							ies.cause ? ies.cause : "<Unknown>");					ast_debug(1, "Immediately destroying %d, having received reject\n",						fr->callno);				}				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK,						       fr->ts, NULL, 0, fr->iseqno);				if (!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION))					iaxs[fr->callno]->error = EPERM;				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_TRANSFER:			{				struct ast_channel *bridged_chan;				struct ast_channel *owner;				iax2_lock_owner(fr->callno);				if (!iaxs[fr->callno]) {					/* Initiating call went away before we could transfer. */					break;				}				owner = iaxs[fr->callno]->owner;				bridged_chan = owner ? ast_bridged_channel(owner) : NULL;				if (bridged_chan && ies.called_number) {					const char *context;					context = ast_strdupa(iaxs[fr->callno]->context);					ast_channel_ref(owner);					ast_channel_ref(bridged_chan);					ast_channel_unlock(owner);					ast_mutex_unlock(&iaxsl[fr->callno]);					/* Set BLINDTRANSFER channel variables */					pbx_builtin_setvar_helper(owner, "BLINDTRANSFER", ast_channel_name(bridged_chan));					pbx_builtin_setvar_helper(bridged_chan, "BLINDTRANSFER", ast_channel_name(owner));					/* DO NOT hold any locks while calling ast_parking_ext_valid() */					if (ast_parking_ext_valid(ies.called_number, owner, context)) {						ast_debug(1, "Parking call '%s'\n", ast_channel_name(bridged_chan));						if (iax_park(bridged_chan, owner, ies.called_number, context)) {							ast_log(LOG_WARNING, "Failed to park call '%s'\n",								ast_channel_name(bridged_chan));						}					} else {						if (ast_async_goto(bridged_chan, context, ies.called_number, 1)) {							ast_log(LOG_WARNING,								"Async goto of '%s' to '%s@%s' failed\n",								ast_channel_name(bridged_chan), ies.called_number, context);						} else {							ast_debug(1, "Async goto of '%s' to '%s@%s' started\n",								ast_channel_name(bridged_chan), ies.called_number, context);						}					}					ast_channel_unref(owner);					ast_channel_unref(bridged_chan);					ast_mutex_lock(&iaxsl[fr->callno]);				} else {					ast_debug(1, "Async goto not applicable on call %d\n", fr->callno);					if (owner) {						ast_channel_unlock(owner);					}				}				break;			}			case IAX_COMMAND_ACCEPT:				/* Ignore if call is already up or needs authentication or is a TBD */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD | IAX_STATE_AUTHENTICATED))					break;				if (ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)) {					/* Send ack immediately, before we destroy */					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					iax2_destroy(fr->callno);					break;				}				if (ies.format) {					iaxs[fr->callno]->peerformat = ies.format;				} else {					if (iaxs[fr->callno]->owner)						iaxs[fr->callno]->peerformat = ast_format_cap_to_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner));					else						iaxs[fr->callno]->peerformat = iaxs[fr->callno]->capability;				}				ast_verb(3, "Call accepted by %s (format %s)\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iax2_getformatname(iaxs[fr->callno]->peerformat));				if (!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)) {					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);					if (!iaxs[fr->callno]) {						break;					}					if (authdebug) {						char tmp1[256], tmp2[256];						ast_log(LOG_NOTICE, "Rejected call to %s, format %s incompatible with our capability %s.\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),							iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));					}				} else {					ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);					iax2_lock_owner(fr->callno);					if (iaxs[fr->callno] && iaxs[fr->callno]->owner) {						char tmp[256];						/* Switch us to use a compatible format */						ast_format_cap_from_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner), iaxs[fr->callno]->peerformat);						ast_verb(3, "Format for call is %s\n", ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(iaxs[fr->callno]->owner)));						/* Setup read/write formats properly. */						if (ast_channel_writeformat(iaxs[fr->callno]->owner)->id)							ast_set_write_format(iaxs[fr->callno]->owner, ast_channel_writeformat(iaxs[fr->callno]->owner));						if (ast_channel_readformat(iaxs[fr->callno]->owner)->id)							ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));						ast_channel_unlock(iaxs[fr->callno]->owner);					}				}				if (iaxs[fr->callno]) {					AST_LIST_LOCK(&dpcache);					AST_LIST_TRAVERSE(&iaxs[fr->callno]->dpentries, dp, peer_list)						if (!(dp->flags & CACHE_FLAG_TRANSMITTED))							iax2_dprequest(dp, fr->callno);					AST_LIST_UNLOCK(&dpcache);				}				break;			case IAX_COMMAND_POKE:				/* Send back a pong packet with the original timestamp */				send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, NULL, 0, -1);				break;			case IAX_COMMAND_PING:			{				struct iax_ie_data pingied;				construct_rr(iaxs[fr->callno], &pingied);				/* Send back a pong packet with the original timestamp */				send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, pingied.buf, pingied.pos, -1);			}				break;			case IAX_COMMAND_PONG:				/* Calculate ping time */				iaxs[fr->callno]->pingtime =  calc_timestamp(iaxs[fr->callno], 0, &f) - fr->ts;				/* save RR info */				save_rr(fr, &ies);				/* Good time to write jb stats for this call */				log_jitterstats(fr->callno);				if (iaxs[fr->callno]->peerpoke) {					peer = iaxs[fr->callno]->peerpoke;					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms)) {						if (iaxs[fr->callno]->pingtime <= peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now REACHABLE! Time: %d\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Reachable\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_NOT_INUSE, "IAX2/%s", peer->name); /* Activate notification */						}					} else if ((peer->historicms > 0) && (peer->historicms <= peer->maxms)) {						if (iaxs[fr->callno]->pingtime > peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now TOO LAGGED (%d ms)!\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Lagged\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_UNAVAILABLE, "IAX2/%s", peer->name); /* Activate notification */						}					}					peer->lastms = iaxs[fr->callno]->pingtime;					if (peer->smoothing && (peer->lastms > -1))						peer->historicms = (iaxs[fr->callno]->pingtime + peer->historicms) / 2;					else if (peer->smoothing && peer->lastms < 0)						peer->historicms = (0 + peer->historicms) / 2;					else											peer->historicms = iaxs[fr->callno]->pingtime;					/* Remove scheduled iax2_poke_noanswer */					if (peer->pokeexpire > -1) {						if (!AST_SCHED_DEL(sched, peer->pokeexpire)) {							peer_unref(peer);							peer->pokeexpire = -1;						}					}					/* Schedule the next cycle */					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms))						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_peer_s, peer_ref(peer));					else						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqok, iax2_poke_peer_s, peer_ref(peer));					if (peer->pokeexpire == -1)						peer_unref(peer);					/* and finally send the ack */					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					/* And wrap up the qualify call */					iax2_destroy(fr->callno);					peer->callno = 0;					ast_debug(1, "Peer %s: got pong, lastms %d, historicms %d, maxms %d\n", peer->name, peer->lastms, peer->historicms, peer->maxms);				}				break;			case IAX_COMMAND_LAGRQ:			case IAX_COMMAND_LAGRP:				f.src = "LAGRQ";				f.mallocd = 0;				f.offset = 0;				f.samples = 0;				iax_frame_wrap(fr, &f);				if (f.subclass.integer == IAX_COMMAND_LAGRQ) {					/* Received a LAGRQ - echo back a LAGRP */					fr->af.subclass.integer = IAX_COMMAND_LAGRP;					iax2_send(iaxs[fr->callno], &fr->af, fr->ts, -1, 0, 0, 0);				} else {					/* Received LAGRP in response to our LAGRQ */					unsigned int ts;					/* This is a reply we've been given, actually measure the difference */					ts = calc_timestamp(iaxs[fr->callno], 0, &fr->af);					iaxs[fr->callno]->lag = ts - fr->ts;					if (iaxdebug)						ast_debug(1, "Peer %s lag measured as %dms\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->lag);				}				break;			case IAX_COMMAND_AUTHREQ:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)) {					ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					break;				}				if (authenticate_reply(iaxs[fr->callno], &iaxs[fr->callno]->addr, &ies, iaxs[fr->callno]->secret, iaxs[fr->callno]->outkey)) {					struct ast_frame hangup_fr = { .frametype = AST_FRAME_CONTROL,								.subclass.integer = AST_CONTROL_HANGUP,					};					ast_log(LOG_WARNING, 						"I don't know how to authenticate %s to %s\n", 						ies.username ? ies.username : "<unknown>", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr));					iax2_queue_frame(fr->callno, &hangup_fr);				}
f.subclass.integer
f.subclass
f
f
subclass
integer
{			case IAX_COMMAND_ACK:				/* Do nothing */				break;			case IAX_COMMAND_QUELCH:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {				        /* Generate Manager Hold event, if necessary*/					if (iaxs[fr->callno]->owner) {						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: On\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}					ast_set_flag64(iaxs[fr->callno], IAX_QUELCH);					if (ies.musiconhold) {						iax2_lock_owner(fr->callno);						if (!iaxs[fr->callno] || !iaxs[fr->callno]->owner) {							break;						}						if (ast_bridged_channel(iaxs[fr->callno]->owner)) {							const char *moh_suggest = iaxs[fr->callno]->mohsuggest;							/*							 * We already hold the owner lock so we do not							 * need to check iaxs[fr->callno] after it returns.							 */							iax2_queue_control_data(fr->callno, AST_CONTROL_HOLD, 								S_OR(moh_suggest, NULL),								!ast_strlen_zero(moh_suggest) ? strlen(moh_suggest) + 1 : 0);						}						ast_channel_unlock(iaxs[fr->callno]->owner);					}				}				break;			case IAX_COMMAND_UNQUELCH:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {					iax2_lock_owner(fr->callno);					if (!iaxs[fr->callno]) {						break;					}					/* Generate Manager Unhold event, if necessary */					if (iaxs[fr->callno]->owner && ast_test_flag64(iaxs[fr->callno], IAX_QUELCH)) {						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: Off\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}					ast_clear_flag64(iaxs[fr->callno], IAX_QUELCH);					if (!iaxs[fr->callno]->owner) {						break;					}					if (ast_bridged_channel(iaxs[fr->callno]->owner)) {						/*						 * We already hold the owner lock so we do not						 * need to check iaxs[fr->callno] after it returns.						 */						iax2_queue_control_data(fr->callno, AST_CONTROL_UNHOLD, NULL, 0);					}					ast_channel_unlock(iaxs[fr->callno]->owner);				}				break;			case IAX_COMMAND_TXACC:				if (iaxs[fr->callno]->transferring == TRANSFER_BEGIN) {					/* Ack the packet with the given timestamp */					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* Cancel any outstanding txcnt's */						if (cur->transfer) {							cur->retries = -1;						}					}					memset(&ied1, 0, sizeof(ied1));					iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->callno);					send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREADY, 0, ied1.buf, ied1.pos, -1);					iaxs[fr->callno]->transferring = TRANSFER_READY;				}				break;			case IAX_COMMAND_NEW:				/* Ignore if it's already up */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD))					break;				if (ies.provverpres && ies.serviceident && sin.sin_addr.s_addr) {					ast_mutex_unlock(&iaxsl[fr->callno]);					check_provisioning(&sin, fd, ies.serviceident, ies.provver);					ast_mutex_lock(&iaxsl[fr->callno]);					if (!iaxs[fr->callno]) {						break;					}				}				/* If we're in trunk mode, do it now, and update the trunk number in our frame before continuing */				if (ast_test_flag64(iaxs[fr->callno], IAX_TRUNK)) {					int new_callno;					if ((new_callno = make_trunk(fr->callno, 1)) != -1)						fr->callno = new_callno;				}				/* For security, always ack immediately */				if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				if (check_access(fr->callno, &sin, &ies)) {					/* They're not allowed on */					auth_fail(fr->callno, IAX_COMMAND_REJECT);					if (authdebug)						ast_log(LOG_NOTICE, "Rejected connect attempt from %s, who was trying to reach '%s@%s'\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					break;				}				if (ast_strlen_zero(iaxs[fr->callno]->secret) && ast_test_flag64(iaxs[fr->callno], IAX_FORCE_ENCRYPT)) {					auth_fail(fr->callno, IAX_COMMAND_REJECT);					ast_log(LOG_WARNING, "Rejected connect attempt.  No secret present while force encrypt enabled.\n");					break;				}				if (strcasecmp(iaxs[fr->callno]->exten, "TBD")) {					const char *context, *exten, *cid_num;					context = ast_strdupa(iaxs[fr->callno]->context);					exten = ast_strdupa(iaxs[fr->callno]->exten);					cid_num = ast_strdupa(iaxs[fr->callno]->cid_num);					/* This might re-enter the IAX code and need the lock */					ast_mutex_unlock(&iaxsl[fr->callno]);					exists = ast_exists_extension(NULL, context, exten, 1, cid_num);					ast_mutex_lock(&iaxsl[fr->callno]);					if (!iaxs[fr->callno]) {						break;					}				} else					exists = 0;				/* Get OSP token if it does exist */				save_osptoken(fr, &ies);				if (ast_strlen_zero(iaxs[fr->callno]->secret) && ast_strlen_zero(iaxs[fr->callno]->inkeys)) {					if (strcmp(iaxs[fr->callno]->exten, "TBD") && !exists) {						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}						if (authdebug)							ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					} else {						/* Select an appropriate format */						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								using_prefs = "reqonly";							} else {								using_prefs = "disabled";							}							format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;							memset(&pref, 0, sizeof(pref));							strcpy(caller_pref_buf, "disabled");							strcpy(host_pref_buf, "disabled");						} else {							struct ast_format tmpfmt;							using_prefs = "mine";							/* If the information elements are in here... use them */							if (ies.codec_prefs)								ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);							if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {								/* If we are codec_first_choice we let the caller have the 1st shot at picking the codec.*/								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {									pref = iaxs[fr->callno]->rprefs;									using_prefs = "caller";								} else {									pref = iaxs[fr->callno]->prefs;								}							} else								pref = iaxs[fr->callno]->prefs;							format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);							ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);							ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);						}						if (!format) {							if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP))								format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;							if (!format) {								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}								if (authdebug) {									char tmp[256], tmp2[256], tmp3[256];									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}							} else {								/* Pick one... */								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))										format = 0;								} else {									if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {										using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";										memset(&pref, 0, sizeof(pref));										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);										strcpy(caller_pref_buf,"disabled");										strcpy(host_pref_buf,"disabled");									} else {										struct ast_format tmpfmt;										using_prefs = "mine";										if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {											/* Do the opposite of what we tried above. */											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);										} else /* if no codec_prefs IE do it the old way */											format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}								}								if (!format) {									char tmp[256], tmp2[256], tmp3[256];									memset(&ied0, 0, sizeof(ied0));									iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");									iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);									ast_log(LOG_ERROR, "No best format in '%s'???\n", iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));									send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);									if (!iaxs[fr->callno]) {										break;									}									if (authdebug) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}									ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);									break;								}							}						}						if (format) {							/* No authentication required, let them in */							memset(&ied1, 0, sizeof(ied1));							iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);							iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);							send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);							if (strcmp(iaxs[fr->callno]->exten, "TBD")) {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);								ast_verb(3, "Accepting UNAUTHENTICATED call from %s:\n"												"%srequested format = %s,\n"												"%srequested prefs = %s,\n"												"%sactual format = %s,\n"												"%shost prefs = %s,\n"												"%spriority = %s\n",												ast_inet_ntoa(sin.sin_addr), 												VERBOSE_PREFIX_4,												iax2_getformatname(iaxs[fr->callno]->peerformat), 												VERBOSE_PREFIX_4,												caller_pref_buf,												VERBOSE_PREFIX_4,												iax2_getformatname(format), 												VERBOSE_PREFIX_4,												host_pref_buf, 												VERBOSE_PREFIX_4,												using_prefs);								iaxs[fr->callno]->chosenformat = format;								/* Since this is a new call, we should go ahead and set the callid for it. */								iax_pvt_callid_new(fr->callno);								ast_set_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);							} else {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);								/* If this is a TBD call, we're ready but now what...  */								ast_verb(3, "Accepted unauthenticated TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							}						}					}					break;				}				if (iaxs[fr->callno]->authmethods & IAX_AUTH_MD5)					merge_encryption(iaxs[fr->callno],ies.encmethods);				else					iaxs[fr->callno]->encmethods = 0;				if (!authenticate_request(fr->callno) && iaxs[fr->callno])					ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED);				break;			case IAX_COMMAND_DPREQ:				/* Request status in the dialplan */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD) &&					!ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED) && ies.called_number) {					if (iaxcompat) {						/* Spawn a thread for the lookup */						spawn_dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num);					} else {						/* Just look it up */						dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num, 1);					}				}				break;			case IAX_COMMAND_HANGUP:				ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);				ast_debug(1, "Immediately destroying %d, having received hangup\n", fr->callno);				/* Set hangup cause according to remote and hangupsource */				if (iaxs[fr->callno]->owner) {					set_hangup_source_and_cause(fr->callno, ies.causecode);					if (!iaxs[fr->callno]) {						break;					}				}				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_REJECT:				/* Set hangup cause according to remote and hangup source */				if (iaxs[fr->callno]->owner) {					set_hangup_source_and_cause(fr->callno, ies.causecode);					if (!iaxs[fr->callno]) {						break;					}				}				if (!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)) {					if (iaxs[fr->callno]->owner && authdebug)						ast_log(LOG_WARNING, "Call rejected by %s: %s\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr),							ies.cause ? ies.cause : "<Unknown>");					ast_debug(1, "Immediately destroying %d, having received reject\n",						fr->callno);				}				/* Send ack immediately, before we destroy */				send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK,						       fr->ts, NULL, 0, fr->iseqno);				if (!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION))					iaxs[fr->callno]->error = EPERM;				iax2_destroy(fr->callno);				break;			case IAX_COMMAND_TRANSFER:			{				struct ast_channel *bridged_chan;				struct ast_channel *owner;				iax2_lock_owner(fr->callno);				if (!iaxs[fr->callno]) {					/* Initiating call went away before we could transfer. */					break;				}				owner = iaxs[fr->callno]->owner;				bridged_chan = owner ? ast_bridged_channel(owner) : NULL;				if (bridged_chan && ies.called_number) {					const char *context;					context = ast_strdupa(iaxs[fr->callno]->context);					ast_channel_ref(owner);					ast_channel_ref(bridged_chan);					ast_channel_unlock(owner);					ast_mutex_unlock(&iaxsl[fr->callno]);					/* Set BLINDTRANSFER channel variables */					pbx_builtin_setvar_helper(owner, "BLINDTRANSFER", ast_channel_name(bridged_chan));					pbx_builtin_setvar_helper(bridged_chan, "BLINDTRANSFER", ast_channel_name(owner));					/* DO NOT hold any locks while calling ast_parking_ext_valid() */					if (ast_parking_ext_valid(ies.called_number, owner, context)) {						ast_debug(1, "Parking call '%s'\n", ast_channel_name(bridged_chan));						if (iax_park(bridged_chan, owner, ies.called_number, context)) {							ast_log(LOG_WARNING, "Failed to park call '%s'\n",								ast_channel_name(bridged_chan));						}					} else {						if (ast_async_goto(bridged_chan, context, ies.called_number, 1)) {							ast_log(LOG_WARNING,								"Async goto of '%s' to '%s@%s' failed\n",								ast_channel_name(bridged_chan), ies.called_number, context);						} else {							ast_debug(1, "Async goto of '%s' to '%s@%s' started\n",								ast_channel_name(bridged_chan), ies.called_number, context);						}					}					ast_channel_unref(owner);					ast_channel_unref(bridged_chan);					ast_mutex_lock(&iaxsl[fr->callno]);				} else {					ast_debug(1, "Async goto not applicable on call %d\n", fr->callno);					if (owner) {						ast_channel_unlock(owner);					}				}				break;			}			case IAX_COMMAND_ACCEPT:				/* Ignore if call is already up or needs authentication or is a TBD */				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD | IAX_STATE_AUTHENTICATED))					break;				if (ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)) {					/* Send ack immediately, before we destroy */					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					iax2_destroy(fr->callno);					break;				}				if (ies.format) {					iaxs[fr->callno]->peerformat = ies.format;				} else {					if (iaxs[fr->callno]->owner)						iaxs[fr->callno]->peerformat = ast_format_cap_to_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner));					else						iaxs[fr->callno]->peerformat = iaxs[fr->callno]->capability;				}				ast_verb(3, "Call accepted by %s (format %s)\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iax2_getformatname(iaxs[fr->callno]->peerformat));				if (!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)) {					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);					if (!iaxs[fr->callno]) {						break;					}					if (authdebug) {						char tmp1[256], tmp2[256];						ast_log(LOG_NOTICE, "Rejected call to %s, format %s incompatible with our capability %s.\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),							iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));					}				} else {					ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);					iax2_lock_owner(fr->callno);					if (iaxs[fr->callno] && iaxs[fr->callno]->owner) {						char tmp[256];						/* Switch us to use a compatible format */						ast_format_cap_from_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner), iaxs[fr->callno]->peerformat);						ast_verb(3, "Format for call is %s\n", ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(iaxs[fr->callno]->owner)));						/* Setup read/write formats properly. */						if (ast_channel_writeformat(iaxs[fr->callno]->owner)->id)							ast_set_write_format(iaxs[fr->callno]->owner, ast_channel_writeformat(iaxs[fr->callno]->owner));						if (ast_channel_readformat(iaxs[fr->callno]->owner)->id)							ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));						ast_channel_unlock(iaxs[fr->callno]->owner);					}				}				if (iaxs[fr->callno]) {					AST_LIST_LOCK(&dpcache);					AST_LIST_TRAVERSE(&iaxs[fr->callno]->dpentries, dp, peer_list)						if (!(dp->flags & CACHE_FLAG_TRANSMITTED))							iax2_dprequest(dp, fr->callno);					AST_LIST_UNLOCK(&dpcache);				}				break;			case IAX_COMMAND_POKE:				/* Send back a pong packet with the original timestamp */				send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, NULL, 0, -1);				break;			case IAX_COMMAND_PING:			{				struct iax_ie_data pingied;				construct_rr(iaxs[fr->callno], &pingied);				/* Send back a pong packet with the original timestamp */				send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, pingied.buf, pingied.pos, -1);			}				break;			case IAX_COMMAND_PONG:				/* Calculate ping time */				iaxs[fr->callno]->pingtime =  calc_timestamp(iaxs[fr->callno], 0, &f) - fr->ts;				/* save RR info */				save_rr(fr, &ies);				/* Good time to write jb stats for this call */				log_jitterstats(fr->callno);				if (iaxs[fr->callno]->peerpoke) {					peer = iaxs[fr->callno]->peerpoke;					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms)) {						if (iaxs[fr->callno]->pingtime <= peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now REACHABLE! Time: %d\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Reachable\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_NOT_INUSE, "IAX2/%s", peer->name); /* Activate notification */						}					} else if ((peer->historicms > 0) && (peer->historicms <= peer->maxms)) {						if (iaxs[fr->callno]->pingtime > peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now TOO LAGGED (%d ms)!\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Lagged\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_UNAVAILABLE, "IAX2/%s", peer->name); /* Activate notification */						}					}					peer->lastms = iaxs[fr->callno]->pingtime;					if (peer->smoothing && (peer->lastms > -1))						peer->historicms = (iaxs[fr->callno]->pingtime + peer->historicms) / 2;					else if (peer->smoothing && peer->lastms < 0)						peer->historicms = (0 + peer->historicms) / 2;					else											peer->historicms = iaxs[fr->callno]->pingtime;					/* Remove scheduled iax2_poke_noanswer */					if (peer->pokeexpire > -1) {						if (!AST_SCHED_DEL(sched, peer->pokeexpire)) {							peer_unref(peer);							peer->pokeexpire = -1;						}					}					/* Schedule the next cycle */					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms))						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_peer_s, peer_ref(peer));					else						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqok, iax2_poke_peer_s, peer_ref(peer));					if (peer->pokeexpire == -1)						peer_unref(peer);					/* and finally send the ack */					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					/* And wrap up the qualify call */					iax2_destroy(fr->callno);					peer->callno = 0;					ast_debug(1, "Peer %s: got pong, lastms %d, historicms %d, maxms %d\n", peer->name, peer->lastms, peer->historicms, peer->maxms);				}				break;			case IAX_COMMAND_LAGRQ:			case IAX_COMMAND_LAGRP:				f.src = "LAGRQ";				f.mallocd = 0;				f.offset = 0;				f.samples = 0;				iax_frame_wrap(fr, &f);				if (f.subclass.integer == IAX_COMMAND_LAGRQ) {					/* Received a LAGRQ - echo back a LAGRP */					fr->af.subclass.integer = IAX_COMMAND_LAGRP;					iax2_send(iaxs[fr->callno], &fr->af, fr->ts, -1, 0, 0, 0);				} else {					/* Received LAGRP in response to our LAGRQ */					unsigned int ts;					/* This is a reply we've been given, actually measure the difference */					ts = calc_timestamp(iaxs[fr->callno], 0, &fr->af);					iaxs[fr->callno]->lag = ts - fr->ts;					if (iaxdebug)						ast_debug(1, "Peer %s lag measured as %dms\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->lag);				}				break;			case IAX_COMMAND_AUTHREQ:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)) {					ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					break;				}				if (authenticate_reply(iaxs[fr->callno], &iaxs[fr->callno]->addr, &ies, iaxs[fr->callno]->secret, iaxs[fr->callno]->outkey)) {					struct ast_frame hangup_fr = { .frametype = AST_FRAME_CONTROL,								.subclass.integer = AST_CONTROL_HANGUP,					};					ast_log(LOG_WARNING, 						"I don't know how to authenticate %s to %s\n", 						ies.username ? ies.username : "<unknown>", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr));					iax2_queue_frame(fr->callno, &hangup_fr);				}
case IAX_COMMAND_ACK:
IAX_COMMAND_ACK
IAX_COMMAND_ACK
break;
case IAX_COMMAND_QUELCH:
IAX_COMMAND_QUELCH
IAX_COMMAND_QUELCH
if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {				        /* Generate Manager Hold event, if necessary*/					if (iaxs[fr->callno]->owner) {						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: On\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}					ast_set_flag64(iaxs[fr->callno], IAX_QUELCH);					if (ies.musiconhold) {						iax2_lock_owner(fr->callno);						if (!iaxs[fr->callno] || !iaxs[fr->callno]->owner) {							break;						}						if (ast_bridged_channel(iaxs[fr->callno]->owner)) {							const char *moh_suggest = iaxs[fr->callno]->mohsuggest;							/*							 * We already hold the owner lock so we do not							 * need to check iaxs[fr->callno] after it returns.							 */							iax2_queue_control_data(fr->callno, AST_CONTROL_HOLD, 								S_OR(moh_suggest, NULL),								!ast_strlen_zero(moh_suggest) ? strlen(moh_suggest) + 1 : 0);						}						ast_channel_unlock(iaxs[fr->callno]->owner);					}				}
ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
ast_test_flag
ast_test_flag
&iaxs[fr->callno]->state
iaxs[fr->callno]->state
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
state
IAX_STATE_STARTED
IAX_STATE_STARTED
{				        /* Generate Manager Hold event, if necessary*/					if (iaxs[fr->callno]->owner) {						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: On\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}					ast_set_flag64(iaxs[fr->callno], IAX_QUELCH);					if (ies.musiconhold) {						iax2_lock_owner(fr->callno);						if (!iaxs[fr->callno] || !iaxs[fr->callno]->owner) {							break;						}						if (ast_bridged_channel(iaxs[fr->callno]->owner)) {							const char *moh_suggest = iaxs[fr->callno]->mohsuggest;							/*							 * We already hold the owner lock so we do not							 * need to check iaxs[fr->callno] after it returns.							 */							iax2_queue_control_data(fr->callno, AST_CONTROL_HOLD, 								S_OR(moh_suggest, NULL),								!ast_strlen_zero(moh_suggest) ? strlen(moh_suggest) + 1 : 0);						}						ast_channel_unlock(iaxs[fr->callno]->owner);					}				}
if (iaxs[fr->callno]->owner) {						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: On\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
{						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: On\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}
ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: On\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));
ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: On\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner))
ast_manager_event
ast_manager_event
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
EVENT_FLAG_CALL
EVENT_FLAG_CALL
"Hold"
"Status: On\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n"
ast_channel_name(iaxs[fr->callno]->owner)
ast_channel_name
ast_channel_name
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
ast_channel_uniqueid(iaxs[fr->callno]->owner)
ast_channel_uniqueid
ast_channel_uniqueid
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
ast_set_flag64(iaxs[fr->callno], IAX_QUELCH);
ast_set_flag64(iaxs[fr->callno], IAX_QUELCH)
ast_set_flag64
ast_set_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_QUELCH
IAX_QUELCH
if (ies.musiconhold) {						iax2_lock_owner(fr->callno);						if (!iaxs[fr->callno] || !iaxs[fr->callno]->owner) {							break;						}						if (ast_bridged_channel(iaxs[fr->callno]->owner)) {							const char *moh_suggest = iaxs[fr->callno]->mohsuggest;							/*							 * We already hold the owner lock so we do not							 * need to check iaxs[fr->callno] after it returns.							 */							iax2_queue_control_data(fr->callno, AST_CONTROL_HOLD, 								S_OR(moh_suggest, NULL),								!ast_strlen_zero(moh_suggest) ? strlen(moh_suggest) + 1 : 0);						}						ast_channel_unlock(iaxs[fr->callno]->owner);					}
ies.musiconhold
ies
ies
musiconhold
{						iax2_lock_owner(fr->callno);						if (!iaxs[fr->callno] || !iaxs[fr->callno]->owner) {							break;						}						if (ast_bridged_channel(iaxs[fr->callno]->owner)) {							const char *moh_suggest = iaxs[fr->callno]->mohsuggest;							/*							 * We already hold the owner lock so we do not							 * need to check iaxs[fr->callno] after it returns.							 */							iax2_queue_control_data(fr->callno, AST_CONTROL_HOLD, 								S_OR(moh_suggest, NULL),								!ast_strlen_zero(moh_suggest) ? strlen(moh_suggest) + 1 : 0);						}						ast_channel_unlock(iaxs[fr->callno]->owner);					}
iax2_lock_owner(fr->callno);
iax2_lock_owner(fr->callno)
iax2_lock_owner
iax2_lock_owner
fr->callno
fr
fr
callno
if (!iaxs[fr->callno] || !iaxs[fr->callno]->owner) {							break;						}
!iaxs[fr->callno] || !iaxs[fr->callno]->owner
!iaxs[fr->callno]
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
!iaxs[fr->callno]->owner
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
{							break;						}
break;
if (ast_bridged_channel(iaxs[fr->callno]->owner)) {							const char *moh_suggest = iaxs[fr->callno]->mohsuggest;							/*							 * We already hold the owner lock so we do not							 * need to check iaxs[fr->callno] after it returns.							 */							iax2_queue_control_data(fr->callno, AST_CONTROL_HOLD, 								S_OR(moh_suggest, NULL),								!ast_strlen_zero(moh_suggest) ? strlen(moh_suggest) + 1 : 0);						}
ast_bridged_channel(iaxs[fr->callno]->owner)
ast_bridged_channel
ast_bridged_channel
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
{							const char *moh_suggest = iaxs[fr->callno]->mohsuggest;							/*							 * We already hold the owner lock so we do not							 * need to check iaxs[fr->callno] after it returns.							 */							iax2_queue_control_data(fr->callno, AST_CONTROL_HOLD, 								S_OR(moh_suggest, NULL),								!ast_strlen_zero(moh_suggest) ? strlen(moh_suggest) + 1 : 0);						}
const char *moh_suggest = iaxs[fr->callno]->mohsuggest;
const char *moh_suggest = iaxs[fr->callno]->mohsuggest;
const char
*moh_suggest = iaxs[fr->callno]->mohsuggest
*
moh_suggest
= iaxs[fr->callno]->mohsuggest
iaxs[fr->callno]->mohsuggest
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
mohsuggest
iax2_queue_control_data(fr->callno, AST_CONTROL_HOLD, 								S_OR(moh_suggest, NULL),								!ast_strlen_zero(moh_suggest) ? strlen(moh_suggest) + 1 : 0);
iax2_queue_control_data(fr->callno, AST_CONTROL_HOLD, 								S_OR(moh_suggest, NULL),								!ast_strlen_zero(moh_suggest) ? strlen(moh_suggest) + 1 : 0)
iax2_queue_control_data
iax2_queue_control_data
fr->callno
fr
fr
callno
AST_CONTROL_HOLD
AST_CONTROL_HOLD
S_OR(moh_suggest, NULL)
S_OR
S_OR
moh_suggest
moh_suggest
NULL
NULL
!ast_strlen_zero(moh_suggest) ? strlen(moh_suggest) + 1 : 0
!ast_strlen_zero(moh_suggest)
ast_strlen_zero(moh_suggest)
ast_strlen_zero
ast_strlen_zero
moh_suggest
moh_suggest
strlen(moh_suggest) + 1
strlen(moh_suggest)
strlen
strlen
moh_suggest
moh_suggest
1
0
ast_channel_unlock(iaxs[fr->callno]->owner);
ast_channel_unlock(iaxs[fr->callno]->owner)
ast_channel_unlock
ast_channel_unlock
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
break;
case IAX_COMMAND_UNQUELCH:
IAX_COMMAND_UNQUELCH
IAX_COMMAND_UNQUELCH
if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {					iax2_lock_owner(fr->callno);					if (!iaxs[fr->callno]) {						break;					}					/* Generate Manager Unhold event, if necessary */					if (iaxs[fr->callno]->owner && ast_test_flag64(iaxs[fr->callno], IAX_QUELCH)) {						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: Off\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}					ast_clear_flag64(iaxs[fr->callno], IAX_QUELCH);					if (!iaxs[fr->callno]->owner) {						break;					}					if (ast_bridged_channel(iaxs[fr->callno]->owner)) {						/*						 * We already hold the owner lock so we do not						 * need to check iaxs[fr->callno] after it returns.						 */						iax2_queue_control_data(fr->callno, AST_CONTROL_UNHOLD, NULL, 0);					}					ast_channel_unlock(iaxs[fr->callno]->owner);				}
ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
ast_test_flag
ast_test_flag
&iaxs[fr->callno]->state
iaxs[fr->callno]->state
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
state
IAX_STATE_STARTED
IAX_STATE_STARTED
{					iax2_lock_owner(fr->callno);					if (!iaxs[fr->callno]) {						break;					}					/* Generate Manager Unhold event, if necessary */					if (iaxs[fr->callno]->owner && ast_test_flag64(iaxs[fr->callno], IAX_QUELCH)) {						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: Off\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}					ast_clear_flag64(iaxs[fr->callno], IAX_QUELCH);					if (!iaxs[fr->callno]->owner) {						break;					}					if (ast_bridged_channel(iaxs[fr->callno]->owner)) {						/*						 * We already hold the owner lock so we do not						 * need to check iaxs[fr->callno] after it returns.						 */						iax2_queue_control_data(fr->callno, AST_CONTROL_UNHOLD, NULL, 0);					}					ast_channel_unlock(iaxs[fr->callno]->owner);				}
iax2_lock_owner(fr->callno);
iax2_lock_owner(fr->callno)
iax2_lock_owner
iax2_lock_owner
fr->callno
fr
fr
callno
if (!iaxs[fr->callno]) {						break;					}
!iaxs[fr->callno]
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{						break;					}
break;
if (iaxs[fr->callno]->owner && ast_test_flag64(iaxs[fr->callno], IAX_QUELCH)) {						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: Off\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}
iaxs[fr->callno]->owner && ast_test_flag64(iaxs[fr->callno], IAX_QUELCH)
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
ast_test_flag64(iaxs[fr->callno], IAX_QUELCH)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_QUELCH
IAX_QUELCH
{						ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: Off\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));					}
ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: Off\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner));
ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",							"Status: Off\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n",							ast_channel_name(iaxs[fr->callno]->owner),							ast_channel_uniqueid(iaxs[fr->callno]->owner))
ast_manager_event
ast_manager_event
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
EVENT_FLAG_CALL
EVENT_FLAG_CALL
"Hold"
"Status: Off\r\n"							"Channel: %s\r\n"							"Uniqueid: %s\r\n"
ast_channel_name(iaxs[fr->callno]->owner)
ast_channel_name
ast_channel_name
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
ast_channel_uniqueid(iaxs[fr->callno]->owner)
ast_channel_uniqueid
ast_channel_uniqueid
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
ast_clear_flag64(iaxs[fr->callno], IAX_QUELCH);
ast_clear_flag64(iaxs[fr->callno], IAX_QUELCH)
ast_clear_flag64
ast_clear_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_QUELCH
IAX_QUELCH
if (!iaxs[fr->callno]->owner) {						break;					}
!iaxs[fr->callno]->owner
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
{						break;					}
break;
if (ast_bridged_channel(iaxs[fr->callno]->owner)) {						/*						 * We already hold the owner lock so we do not						 * need to check iaxs[fr->callno] after it returns.						 */						iax2_queue_control_data(fr->callno, AST_CONTROL_UNHOLD, NULL, 0);					}
ast_bridged_channel(iaxs[fr->callno]->owner)
ast_bridged_channel
ast_bridged_channel
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
{						/*						 * We already hold the owner lock so we do not						 * need to check iaxs[fr->callno] after it returns.						 */						iax2_queue_control_data(fr->callno, AST_CONTROL_UNHOLD, NULL, 0);					}
iax2_queue_control_data(fr->callno, AST_CONTROL_UNHOLD, NULL, 0);
iax2_queue_control_data(fr->callno, AST_CONTROL_UNHOLD, NULL, 0)
iax2_queue_control_data
iax2_queue_control_data
fr->callno
fr
fr
callno
AST_CONTROL_UNHOLD
AST_CONTROL_UNHOLD
NULL
NULL
0
ast_channel_unlock(iaxs[fr->callno]->owner);
ast_channel_unlock(iaxs[fr->callno]->owner)
ast_channel_unlock
ast_channel_unlock
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
break;
case IAX_COMMAND_TXACC:
IAX_COMMAND_TXACC
IAX_COMMAND_TXACC
if (iaxs[fr->callno]->transferring == TRANSFER_BEGIN) {					/* Ack the packet with the given timestamp */					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* Cancel any outstanding txcnt's */						if (cur->transfer) {							cur->retries = -1;						}					}					memset(&ied1, 0, sizeof(ied1));					iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->callno);					send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREADY, 0, ied1.buf, ied1.pos, -1);					iaxs[fr->callno]->transferring = TRANSFER_READY;				}
iaxs[fr->callno]->transferring == TRANSFER_BEGIN
iaxs[fr->callno]->transferring
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
transferring
TRANSFER_BEGIN
TRANSFER_BEGIN
{					/* Ack the packet with the given timestamp */					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* Cancel any outstanding txcnt's */						if (cur->transfer) {							cur->retries = -1;						}					}					memset(&ied1, 0, sizeof(ied1));					iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->callno);					send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREADY, 0, ied1.buf, ied1.pos, -1);					iaxs[fr->callno]->transferring = TRANSFER_READY;				}
AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list)
AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list)
AST_LIST_TRAVERSE
AST_LIST_TRAVERSE
&frame_queue[fr->callno]
frame_queue[fr->callno]
frame_queue
frame_queue
fr->callno
fr
fr
callno
cur
cur
list
list
)
{						/* Cancel any outstanding txcnt's */						if (cur->transfer) {							cur->retries = -1;						}					}
if (cur->transfer) {							cur->retries = -1;						}
cur->transfer
cur
cur
transfer
{							cur->retries = -1;						}
cur->retries = -1;
cur->retries = -1
cur->retries
cur
cur
retries
-1
1
memset(&ied1, 0, sizeof(ied1));
memset(&ied1, 0, sizeof(ied1))
memset
memset
&ied1
ied1
ied1
0
sizeof(ied1)
(ied1)
ied1
ied1
iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->callno);
iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->callno)
iax_ie_append_short
iax_ie_append_short
&ied1
ied1
ied1
IAX_IE_CALLNO
IAX_IE_CALLNO
iaxs[fr->callno]->callno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
callno
send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREADY, 0, ied1.buf, ied1.pos, -1);
send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREADY, 0, ied1.buf, ied1.pos, -1)
send_command
send_command
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_TXREADY
IAX_COMMAND_TXREADY
0
ied1.buf
ied1
ied1
buf
ied1.pos
ied1
ied1
pos
-1
1
iaxs[fr->callno]->transferring = TRANSFER_READY;
iaxs[fr->callno]->transferring = TRANSFER_READY
iaxs[fr->callno]->transferring
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
transferring
TRANSFER_READY
TRANSFER_READY
break;
case IAX_COMMAND_NEW:
IAX_COMMAND_NEW
IAX_COMMAND_NEW
if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD))					break;
ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)
ast_test_flag
ast_test_flag
&iaxs[fr->callno]->state
iaxs[fr->callno]->state
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
state
IAX_STATE_STARTED | IAX_STATE_TBD
IAX_STATE_STARTED
IAX_STATE_STARTED
IAX_STATE_TBD
IAX_STATE_TBD
break;
if (ies.provverpres && ies.serviceident && sin.sin_addr.s_addr) {					ast_mutex_unlock(&iaxsl[fr->callno]);					check_provisioning(&sin, fd, ies.serviceident, ies.provver);					ast_mutex_lock(&iaxsl[fr->callno]);					if (!iaxs[fr->callno]) {						break;					}				}
ies.provverpres && ies.serviceident && sin.sin_addr.s_addr
ies.provverpres && ies.serviceident
ies.provverpres
ies
ies
provverpres
ies.serviceident
ies
ies
serviceident
sin.sin_addr.s_addr
sin.sin_addr
sin
sin
sin_addr
s_addr
{					ast_mutex_unlock(&iaxsl[fr->callno]);					check_provisioning(&sin, fd, ies.serviceident, ies.provver);					ast_mutex_lock(&iaxsl[fr->callno]);					if (!iaxs[fr->callno]) {						break;					}				}
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock
ast_mutex_unlock
(&iaxsl[fr->callno])
&iaxsl[fr->callno]
&
iaxsl
[fr->callno]
fr->callno
fr
fr
callno
check_provisioning(&sin, fd, ies.serviceident, ies.provver);
check_provisioning(&sin, fd, ies.serviceident, ies.provver)
check_provisioning
check_provisioning
&sin
sin
sin
fd
fd
ies.serviceident
ies
ies
serviceident
ies.provver
ies
ies
provver
ast_mutex_lock(&iaxsl[fr->callno]);
ast_mutex_lock(&iaxsl[fr->callno])
ast_mutex_lock
ast_mutex_lock
&iaxsl[fr->callno]
iaxsl[fr->callno]
iaxsl
iaxsl
fr->callno
fr
fr
callno
if (!iaxs[fr->callno]) {						break;					}
!iaxs[fr->callno]
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{						break;					}
break;
if (ast_test_flag64(iaxs[fr->callno], IAX_TRUNK)) {					int new_callno;					if ((new_callno = make_trunk(fr->callno, 1)) != -1)						fr->callno = new_callno;				}
ast_test_flag64(iaxs[fr->callno], IAX_TRUNK)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_TRUNK
IAX_TRUNK
{					int new_callno;					if ((new_callno = make_trunk(fr->callno, 1)) != -1)						fr->callno = new_callno;				}
int new_callno;
int new_callno;
int
new_callno
new_callno
if ((new_callno = make_trunk(fr->callno, 1)) != -1)						fr->callno = new_callno;
(new_callno = make_trunk(fr->callno, 1)) != -1
(new_callno = make_trunk(fr->callno, 1))
new_callno = make_trunk(fr->callno, 1)
new_callno
new_callno
make_trunk(fr->callno, 1)
make_trunk
make_trunk
fr->callno
fr
fr
callno
1
-1
1
fr->callno = new_callno;
fr->callno = new_callno
fr->callno
fr
fr
callno
new_callno
new_callno
if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
delayreject
delayreject
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
send_command_immediate
send_command_immediate
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_ACK
IAX_COMMAND_ACK
fr->ts
fr
fr
ts
NULL
NULL
0
fr->iseqno
fr
fr
iseqno
if (check_access(fr->callno, &sin, &ies)) {					/* They're not allowed on */					auth_fail(fr->callno, IAX_COMMAND_REJECT);					if (authdebug)						ast_log(LOG_NOTICE, "Rejected connect attempt from %s, who was trying to reach '%s@%s'\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					break;				}
check_access(fr->callno, &sin, &ies)
check_access
check_access
fr->callno
fr
fr
callno
&sin
sin
sin
&ies
ies
ies
{					/* They're not allowed on */					auth_fail(fr->callno, IAX_COMMAND_REJECT);					if (authdebug)						ast_log(LOG_NOTICE, "Rejected connect attempt from %s, who was trying to reach '%s@%s'\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					break;				}
auth_fail(fr->callno, IAX_COMMAND_REJECT);
auth_fail(fr->callno, IAX_COMMAND_REJECT)
auth_fail
auth_fail
fr->callno
fr
fr
callno
IAX_COMMAND_REJECT
IAX_COMMAND_REJECT
if (authdebug)						ast_log(LOG_NOTICE, "Rejected connect attempt from %s, who was trying to reach '%s@%s'\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);
authdebug
authdebug
ast_log(LOG_NOTICE, "Rejected connect attempt from %s, who was trying to reach '%s@%s'\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);
ast_log(LOG_NOTICE, "Rejected connect attempt from %s, who was trying to reach '%s@%s'\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context)
ast_log
ast_log
LOG_NOTICE
LOG_NOTICE
"Rejected connect attempt from %s, who was trying to reach '%s@%s'\n"
ast_inet_ntoa(sin.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
sin.sin_addr
sin
sin
sin_addr
iaxs[fr->callno]->exten
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
exten
iaxs[fr->callno]->context
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
context
break;
if (ast_strlen_zero(iaxs[fr->callno]->secret) && ast_test_flag64(iaxs[fr->callno], IAX_FORCE_ENCRYPT)) {					auth_fail(fr->callno, IAX_COMMAND_REJECT);					ast_log(LOG_WARNING, "Rejected connect attempt.  No secret present while force encrypt enabled.\n");					break;				}
ast_strlen_zero(iaxs[fr->callno]->secret) && ast_test_flag64(iaxs[fr->callno], IAX_FORCE_ENCRYPT)
ast_strlen_zero(iaxs[fr->callno]->secret)
ast_strlen_zero
ast_strlen_zero
iaxs[fr->callno]->secret
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
secret
ast_test_flag64(iaxs[fr->callno], IAX_FORCE_ENCRYPT)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_FORCE_ENCRYPT
IAX_FORCE_ENCRYPT
{					auth_fail(fr->callno, IAX_COMMAND_REJECT);					ast_log(LOG_WARNING, "Rejected connect attempt.  No secret present while force encrypt enabled.\n");					break;				}
auth_fail(fr->callno, IAX_COMMAND_REJECT);
auth_fail(fr->callno, IAX_COMMAND_REJECT)
auth_fail
auth_fail
fr->callno
fr
fr
callno
IAX_COMMAND_REJECT
IAX_COMMAND_REJECT
ast_log(LOG_WARNING, "Rejected connect attempt.  No secret present while force encrypt enabled.\n");
ast_log(LOG_WARNING, "Rejected connect attempt.  No secret present while force encrypt enabled.\n")
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"Rejected connect attempt.  No secret present while force encrypt enabled.\n"
break;
if (strcasecmp(iaxs[fr->callno]->exten, "TBD")) {					const char *context, *exten, *cid_num;					context = ast_strdupa(iaxs[fr->callno]->context);					exten = ast_strdupa(iaxs[fr->callno]->exten);					cid_num = ast_strdupa(iaxs[fr->callno]->cid_num);					/* This might re-enter the IAX code and need the lock */					ast_mutex_unlock(&iaxsl[fr->callno]);					exists = ast_exists_extension(NULL, context, exten, 1, cid_num);					ast_mutex_lock(&iaxsl[fr->callno]);					if (!iaxs[fr->callno]) {						break;					}				} else					exists = 0;
strcasecmp(iaxs[fr->callno]->exten, "TBD")
strcasecmp
strcasecmp
iaxs[fr->callno]->exten
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
exten
"TBD"
{					const char *context, *exten, *cid_num;					context = ast_strdupa(iaxs[fr->callno]->context);					exten = ast_strdupa(iaxs[fr->callno]->exten);					cid_num = ast_strdupa(iaxs[fr->callno]->cid_num);					/* This might re-enter the IAX code and need the lock */					ast_mutex_unlock(&iaxsl[fr->callno]);					exists = ast_exists_extension(NULL, context, exten, 1, cid_num);					ast_mutex_lock(&iaxsl[fr->callno]);					if (!iaxs[fr->callno]) {						break;					}				}
const char *context, *exten, *cid_num;
const char *context, *exten, *cid_num;
const char
*context
*
context
*exten
*
exten
*cid_num
*
cid_num
context = ast_strdupa(iaxs[fr->callno]->context);
context = ast_strdupa(iaxs[fr->callno]->context)
context
context
ast_strdupa(iaxs[fr->callno]->context)
ast_strdupa
ast_strdupa
iaxs[fr->callno]->context
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
context
exten = ast_strdupa(iaxs[fr->callno]->exten);
exten = ast_strdupa(iaxs[fr->callno]->exten)
exten
exten
ast_strdupa(iaxs[fr->callno]->exten)
ast_strdupa
ast_strdupa
iaxs[fr->callno]->exten
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
exten
cid_num = ast_strdupa(iaxs[fr->callno]->cid_num);
cid_num = ast_strdupa(iaxs[fr->callno]->cid_num)
cid_num
cid_num
ast_strdupa(iaxs[fr->callno]->cid_num)
ast_strdupa
ast_strdupa
iaxs[fr->callno]->cid_num
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
cid_num
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock
ast_mutex_unlock
(&iaxsl[fr->callno])
&iaxsl[fr->callno]
&
iaxsl
[fr->callno]
fr->callno
fr
fr
callno
exists = ast_exists_extension(NULL, context, exten, 1, cid_num);
exists = ast_exists_extension(NULL, context, exten, 1, cid_num)
exists
exists
ast_exists_extension(NULL, context, exten, 1, cid_num)
ast_exists_extension
ast_exists_extension
NULL
NULL
context
context
exten
exten
1
cid_num
cid_num
ast_mutex_lock(&iaxsl[fr->callno]);
ast_mutex_lock(&iaxsl[fr->callno])
ast_mutex_lock
ast_mutex_lock
&iaxsl[fr->callno]
iaxsl[fr->callno]
iaxsl
iaxsl
fr->callno
fr
fr
callno
if (!iaxs[fr->callno]) {						break;					}
!iaxs[fr->callno]
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{						break;					}
break;
exists = 0;
exists = 0
exists
exists
0
save_osptoken(fr, &ies);
save_osptoken(fr, &ies)
save_osptoken
save_osptoken
fr
fr
&ies
ies
ies
if (ast_strlen_zero(iaxs[fr->callno]->secret) && ast_strlen_zero(iaxs[fr->callno]->inkeys)) {					if (strcmp(iaxs[fr->callno]->exten, "TBD") && !exists) {						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}						if (authdebug)							ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					} else {						/* Select an appropriate format */						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								using_prefs = "reqonly";							} else {								using_prefs = "disabled";							}							format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;							memset(&pref, 0, sizeof(pref));							strcpy(caller_pref_buf, "disabled");							strcpy(host_pref_buf, "disabled");						} else {							struct ast_format tmpfmt;							using_prefs = "mine";							/* If the information elements are in here... use them */							if (ies.codec_prefs)								ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);							if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {								/* If we are codec_first_choice we let the caller have the 1st shot at picking the codec.*/								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {									pref = iaxs[fr->callno]->rprefs;									using_prefs = "caller";								} else {									pref = iaxs[fr->callno]->prefs;								}							} else								pref = iaxs[fr->callno]->prefs;							format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);							ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);							ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);						}						if (!format) {							if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP))								format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;							if (!format) {								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}								if (authdebug) {									char tmp[256], tmp2[256], tmp3[256];									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}							} else {								/* Pick one... */								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))										format = 0;								} else {									if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {										using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";										memset(&pref, 0, sizeof(pref));										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);										strcpy(caller_pref_buf,"disabled");										strcpy(host_pref_buf,"disabled");									} else {										struct ast_format tmpfmt;										using_prefs = "mine";										if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {											/* Do the opposite of what we tried above. */											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);										} else /* if no codec_prefs IE do it the old way */											format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}								}								if (!format) {									char tmp[256], tmp2[256], tmp3[256];									memset(&ied0, 0, sizeof(ied0));									iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");									iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);									ast_log(LOG_ERROR, "No best format in '%s'???\n", iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));									send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);									if (!iaxs[fr->callno]) {										break;									}									if (authdebug) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}									ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);									break;								}							}						}						if (format) {							/* No authentication required, let them in */							memset(&ied1, 0, sizeof(ied1));							iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);							iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);							send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);							if (strcmp(iaxs[fr->callno]->exten, "TBD")) {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);								ast_verb(3, "Accepting UNAUTHENTICATED call from %s:\n"												"%srequested format = %s,\n"												"%srequested prefs = %s,\n"												"%sactual format = %s,\n"												"%shost prefs = %s,\n"												"%spriority = %s\n",												ast_inet_ntoa(sin.sin_addr), 												VERBOSE_PREFIX_4,												iax2_getformatname(iaxs[fr->callno]->peerformat), 												VERBOSE_PREFIX_4,												caller_pref_buf,												VERBOSE_PREFIX_4,												iax2_getformatname(format), 												VERBOSE_PREFIX_4,												host_pref_buf, 												VERBOSE_PREFIX_4,												using_prefs);								iaxs[fr->callno]->chosenformat = format;								/* Since this is a new call, we should go ahead and set the callid for it. */								iax_pvt_callid_new(fr->callno);								ast_set_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);							} else {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);								/* If this is a TBD call, we're ready but now what...  */								ast_verb(3, "Accepted unauthenticated TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							}						}					}					break;				}
ast_strlen_zero(iaxs[fr->callno]->secret) && ast_strlen_zero(iaxs[fr->callno]->inkeys)
ast_strlen_zero(iaxs[fr->callno]->secret)
ast_strlen_zero
ast_strlen_zero
iaxs[fr->callno]->secret
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
secret
ast_strlen_zero(iaxs[fr->callno]->inkeys)
ast_strlen_zero
ast_strlen_zero
iaxs[fr->callno]->inkeys
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
inkeys
{					if (strcmp(iaxs[fr->callno]->exten, "TBD") && !exists) {						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}						if (authdebug)							ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					} else {						/* Select an appropriate format */						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								using_prefs = "reqonly";							} else {								using_prefs = "disabled";							}							format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;							memset(&pref, 0, sizeof(pref));							strcpy(caller_pref_buf, "disabled");							strcpy(host_pref_buf, "disabled");						} else {							struct ast_format tmpfmt;							using_prefs = "mine";							/* If the information elements are in here... use them */							if (ies.codec_prefs)								ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);							if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {								/* If we are codec_first_choice we let the caller have the 1st shot at picking the codec.*/								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {									pref = iaxs[fr->callno]->rprefs;									using_prefs = "caller";								} else {									pref = iaxs[fr->callno]->prefs;								}							} else								pref = iaxs[fr->callno]->prefs;							format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);							ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);							ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);						}						if (!format) {							if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP))								format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;							if (!format) {								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}								if (authdebug) {									char tmp[256], tmp2[256], tmp3[256];									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}							} else {								/* Pick one... */								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))										format = 0;								} else {									if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {										using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";										memset(&pref, 0, sizeof(pref));										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);										strcpy(caller_pref_buf,"disabled");										strcpy(host_pref_buf,"disabled");									} else {										struct ast_format tmpfmt;										using_prefs = "mine";										if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {											/* Do the opposite of what we tried above. */											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);										} else /* if no codec_prefs IE do it the old way */											format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}								}								if (!format) {									char tmp[256], tmp2[256], tmp3[256];									memset(&ied0, 0, sizeof(ied0));									iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");									iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);									ast_log(LOG_ERROR, "No best format in '%s'???\n", iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));									send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);									if (!iaxs[fr->callno]) {										break;									}									if (authdebug) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}									ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);									break;								}							}						}						if (format) {							/* No authentication required, let them in */							memset(&ied1, 0, sizeof(ied1));							iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);							iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);							send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);							if (strcmp(iaxs[fr->callno]->exten, "TBD")) {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);								ast_verb(3, "Accepting UNAUTHENTICATED call from %s:\n"												"%srequested format = %s,\n"												"%srequested prefs = %s,\n"												"%sactual format = %s,\n"												"%shost prefs = %s,\n"												"%spriority = %s\n",												ast_inet_ntoa(sin.sin_addr), 												VERBOSE_PREFIX_4,												iax2_getformatname(iaxs[fr->callno]->peerformat), 												VERBOSE_PREFIX_4,												caller_pref_buf,												VERBOSE_PREFIX_4,												iax2_getformatname(format), 												VERBOSE_PREFIX_4,												host_pref_buf, 												VERBOSE_PREFIX_4,												using_prefs);								iaxs[fr->callno]->chosenformat = format;								/* Since this is a new call, we should go ahead and set the callid for it. */								iax_pvt_callid_new(fr->callno);								ast_set_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);							} else {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);								/* If this is a TBD call, we're ready but now what...  */								ast_verb(3, "Accepted unauthenticated TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							}						}					}					break;				}
if (strcmp(iaxs[fr->callno]->exten, "TBD") && !exists) {						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}						if (authdebug)							ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					} else {						/* Select an appropriate format */						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								using_prefs = "reqonly";							} else {								using_prefs = "disabled";							}							format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;							memset(&pref, 0, sizeof(pref));							strcpy(caller_pref_buf, "disabled");							strcpy(host_pref_buf, "disabled");						} else {							struct ast_format tmpfmt;							using_prefs = "mine";							/* If the information elements are in here... use them */							if (ies.codec_prefs)								ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);							if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {								/* If we are codec_first_choice we let the caller have the 1st shot at picking the codec.*/								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {									pref = iaxs[fr->callno]->rprefs;									using_prefs = "caller";								} else {									pref = iaxs[fr->callno]->prefs;								}							} else								pref = iaxs[fr->callno]->prefs;							format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);							ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);							ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);						}						if (!format) {							if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP))								format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;							if (!format) {								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}								if (authdebug) {									char tmp[256], tmp2[256], tmp3[256];									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}							} else {								/* Pick one... */								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))										format = 0;								} else {									if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {										using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";										memset(&pref, 0, sizeof(pref));										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);										strcpy(caller_pref_buf,"disabled");										strcpy(host_pref_buf,"disabled");									} else {										struct ast_format tmpfmt;										using_prefs = "mine";										if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {											/* Do the opposite of what we tried above. */											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);										} else /* if no codec_prefs IE do it the old way */											format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}								}								if (!format) {									char tmp[256], tmp2[256], tmp3[256];									memset(&ied0, 0, sizeof(ied0));									iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");									iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);									ast_log(LOG_ERROR, "No best format in '%s'???\n", iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));									send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);									if (!iaxs[fr->callno]) {										break;									}									if (authdebug) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}									ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);									break;								}							}						}						if (format) {							/* No authentication required, let them in */							memset(&ied1, 0, sizeof(ied1));							iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);							iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);							send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);							if (strcmp(iaxs[fr->callno]->exten, "TBD")) {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);								ast_verb(3, "Accepting UNAUTHENTICATED call from %s:\n"												"%srequested format = %s,\n"												"%srequested prefs = %s,\n"												"%sactual format = %s,\n"												"%shost prefs = %s,\n"												"%spriority = %s\n",												ast_inet_ntoa(sin.sin_addr), 												VERBOSE_PREFIX_4,												iax2_getformatname(iaxs[fr->callno]->peerformat), 												VERBOSE_PREFIX_4,												caller_pref_buf,												VERBOSE_PREFIX_4,												iax2_getformatname(format), 												VERBOSE_PREFIX_4,												host_pref_buf, 												VERBOSE_PREFIX_4,												using_prefs);								iaxs[fr->callno]->chosenformat = format;								/* Since this is a new call, we should go ahead and set the callid for it. */								iax_pvt_callid_new(fr->callno);								ast_set_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);							} else {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);								/* If this is a TBD call, we're ready but now what...  */								ast_verb(3, "Accepted unauthenticated TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							}						}					}
strcmp(iaxs[fr->callno]->exten, "TBD") && !exists
strcmp(iaxs[fr->callno]->exten, "TBD")
strcmp
strcmp
iaxs[fr->callno]->exten
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
exten
"TBD"
!exists
exists
exists
{						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}						if (authdebug)							ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					}
memset(&ied0, 0, sizeof(ied0));
memset(&ied0, 0, sizeof(ied0))
memset
memset
&ied0
ied0
ied0
0
sizeof(ied0)
(ied0)
ied0
ied0
iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");
iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension")
iax_ie_append_str
iax_ie_append_str
&ied0
ied0
ied0
IAX_IE_CAUSE
IAX_IE_CAUSE
"No such context/extension"
iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);
iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION)
iax_ie_append_byte
iax_ie_append_byte
&ied0
ied0
ied0
IAX_IE_CAUSECODE
IAX_IE_CAUSECODE
AST_CAUSE_NO_ROUTE_DESTINATION
AST_CAUSE_NO_ROUTE_DESTINATION
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1)
send_command_final
send_command_final
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_REJECT
IAX_COMMAND_REJECT
0
ied0.buf
ied0
ied0
buf
ied0.pos
ied0
ied0
pos
-1
1
if (!iaxs[fr->callno]) {							break;						}
!iaxs[fr->callno]
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{							break;						}
break;
if (authdebug)							ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);
authdebug
authdebug
ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);
ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context)
ast_log
ast_log
LOG_NOTICE
LOG_NOTICE
"Rejected connect attempt from %s, request '%s@%s' does not exist\n"
ast_inet_ntoa(sin.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
sin.sin_addr
sin
sin
sin_addr
iaxs[fr->callno]->exten
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
exten
iaxs[fr->callno]->context
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
context
{						/* Select an appropriate format */						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								using_prefs = "reqonly";							} else {								using_prefs = "disabled";							}							format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;							memset(&pref, 0, sizeof(pref));							strcpy(caller_pref_buf, "disabled");							strcpy(host_pref_buf, "disabled");						} else {							struct ast_format tmpfmt;							using_prefs = "mine";							/* If the information elements are in here... use them */							if (ies.codec_prefs)								ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);							if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {								/* If we are codec_first_choice we let the caller have the 1st shot at picking the codec.*/								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {									pref = iaxs[fr->callno]->rprefs;									using_prefs = "caller";								} else {									pref = iaxs[fr->callno]->prefs;								}							} else								pref = iaxs[fr->callno]->prefs;							format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);							ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);							ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);						}						if (!format) {							if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP))								format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;							if (!format) {								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}								if (authdebug) {									char tmp[256], tmp2[256], tmp3[256];									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}							} else {								/* Pick one... */								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))										format = 0;								} else {									if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {										using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";										memset(&pref, 0, sizeof(pref));										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);										strcpy(caller_pref_buf,"disabled");										strcpy(host_pref_buf,"disabled");									} else {										struct ast_format tmpfmt;										using_prefs = "mine";										if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {											/* Do the opposite of what we tried above. */											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);										} else /* if no codec_prefs IE do it the old way */											format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}								}								if (!format) {									char tmp[256], tmp2[256], tmp3[256];									memset(&ied0, 0, sizeof(ied0));									iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");									iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);									ast_log(LOG_ERROR, "No best format in '%s'???\n", iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));									send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);									if (!iaxs[fr->callno]) {										break;									}									if (authdebug) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}									ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);									break;								}							}						}						if (format) {							/* No authentication required, let them in */							memset(&ied1, 0, sizeof(ied1));							iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);							iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);							send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);							if (strcmp(iaxs[fr->callno]->exten, "TBD")) {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);								ast_verb(3, "Accepting UNAUTHENTICATED call from %s:\n"												"%srequested format = %s,\n"												"%srequested prefs = %s,\n"												"%sactual format = %s,\n"												"%shost prefs = %s,\n"												"%spriority = %s\n",												ast_inet_ntoa(sin.sin_addr), 												VERBOSE_PREFIX_4,												iax2_getformatname(iaxs[fr->callno]->peerformat), 												VERBOSE_PREFIX_4,												caller_pref_buf,												VERBOSE_PREFIX_4,												iax2_getformatname(format), 												VERBOSE_PREFIX_4,												host_pref_buf, 												VERBOSE_PREFIX_4,												using_prefs);								iaxs[fr->callno]->chosenformat = format;								/* Since this is a new call, we should go ahead and set the callid for it. */								iax_pvt_callid_new(fr->callno);								ast_set_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);							} else {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);								/* If this is a TBD call, we're ready but now what...  */								ast_verb(3, "Accepted unauthenticated TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							}						}					}
if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								using_prefs = "reqonly";							} else {								using_prefs = "disabled";							}							format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;							memset(&pref, 0, sizeof(pref));							strcpy(caller_pref_buf, "disabled");							strcpy(host_pref_buf, "disabled");						} else {							struct ast_format tmpfmt;							using_prefs = "mine";							/* If the information elements are in here... use them */							if (ies.codec_prefs)								ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);							if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {								/* If we are codec_first_choice we let the caller have the 1st shot at picking the codec.*/								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {									pref = iaxs[fr->callno]->rprefs;									using_prefs = "caller";								} else {									pref = iaxs[fr->callno]->prefs;								}							} else								pref = iaxs[fr->callno]->prefs;							format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);							ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);							ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);						}
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_CODEC_NOPREFS
IAX_CODEC_NOPREFS
{							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								using_prefs = "reqonly";							} else {								using_prefs = "disabled";							}							format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;							memset(&pref, 0, sizeof(pref));							strcpy(caller_pref_buf, "disabled");							strcpy(host_pref_buf, "disabled");						}
if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								using_prefs = "reqonly";							} else {								using_prefs = "disabled";							}
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_CODEC_NOCAP
IAX_CODEC_NOCAP
{								using_prefs = "reqonly";							}
using_prefs = "reqonly";
using_prefs = "reqonly"
using_prefs
using_prefs
"reqonly"
{								using_prefs = "disabled";							}
using_prefs = "disabled";
using_prefs = "disabled"
using_prefs
using_prefs
"disabled"
format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;
format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability
format
format
iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
memset(&pref, 0, sizeof(pref));
memset(&pref, 0, sizeof(pref))
memset
memset
&pref
pref
pref
0
sizeof(pref)
(pref)
pref
pref
strcpy(caller_pref_buf, "disabled");
strcpy(caller_pref_buf, "disabled")
strcpy
strcpy
caller_pref_buf
caller_pref_buf
"disabled"
strcpy(host_pref_buf, "disabled");
strcpy(host_pref_buf, "disabled")
strcpy
strcpy
host_pref_buf
host_pref_buf
"disabled"
{							struct ast_format tmpfmt;							using_prefs = "mine";							/* If the information elements are in here... use them */							if (ies.codec_prefs)								ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);							if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {								/* If we are codec_first_choice we let the caller have the 1st shot at picking the codec.*/								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {									pref = iaxs[fr->callno]->rprefs;									using_prefs = "caller";								} else {									pref = iaxs[fr->callno]->prefs;								}							} else								pref = iaxs[fr->callno]->prefs;							format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);							ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);							ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);						}
struct ast_format tmpfmt;
struct ast_format tmpfmt;
struct ast_format
ast_format
tmpfmt
tmpfmt
using_prefs = "mine";
using_prefs = "mine"
using_prefs
using_prefs
"mine"
if (ies.codec_prefs)								ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);
ies.codec_prefs
ies
ies
codec_prefs
ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);
ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0)
ast_codec_pref_convert
ast_codec_pref_convert
&iaxs[fr->callno]->rprefs
iaxs[fr->callno]->rprefs
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
rprefs
ies.codec_prefs
ies
ies
codec_prefs
32
0
if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {								/* If we are codec_first_choice we let the caller have the 1st shot at picking the codec.*/								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {									pref = iaxs[fr->callno]->rprefs;									using_prefs = "caller";								} else {									pref = iaxs[fr->callno]->prefs;								}							} else								pref = iaxs[fr->callno]->prefs;
ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)
ast_codec_pref_index
ast_codec_pref_index
&iaxs[fr->callno]->rprefs
iaxs[fr->callno]->rprefs
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
rprefs
0
&tmpfmt
tmpfmt
tmpfmt
{								/* If we are codec_first_choice we let the caller have the 1st shot at picking the codec.*/								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {									pref = iaxs[fr->callno]->rprefs;									using_prefs = "caller";								} else {									pref = iaxs[fr->callno]->prefs;								}							}
if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {									pref = iaxs[fr->callno]->rprefs;									using_prefs = "caller";								} else {									pref = iaxs[fr->callno]->prefs;								}
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_CODEC_USER_FIRST
IAX_CODEC_USER_FIRST
{									pref = iaxs[fr->callno]->rprefs;									using_prefs = "caller";								}
pref = iaxs[fr->callno]->rprefs;
pref = iaxs[fr->callno]->rprefs
pref
pref
iaxs[fr->callno]->rprefs
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
rprefs
using_prefs = "caller";
using_prefs = "caller"
using_prefs
using_prefs
"caller"
{									pref = iaxs[fr->callno]->prefs;								}
pref = iaxs[fr->callno]->prefs;
pref = iaxs[fr->callno]->prefs
pref
pref
iaxs[fr->callno]->prefs
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
prefs
pref = iaxs[fr->callno]->prefs;
pref = iaxs[fr->callno]->prefs
pref
pref
iaxs[fr->callno]->prefs
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
prefs
format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);
format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0)
format
format
iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0)
iax2_codec_choose
iax2_codec_choose
&pref
pref
pref
iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
iaxs[fr->callno]->peercapability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercapability
0
ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);
ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1)
ast_codec_pref_string
ast_codec_pref_string
&iaxs[fr->callno]->rprefs
iaxs[fr->callno]->rprefs
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
rprefs
caller_pref_buf
caller_pref_buf
sizeof(caller_pref_buf) - 1
sizeof(caller_pref_buf)
(caller_pref_buf)
caller_pref_buf
caller_pref_buf
1
ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);
ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1)
ast_codec_pref_string
ast_codec_pref_string
&iaxs[fr->callno]->prefs
iaxs[fr->callno]->prefs
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
prefs
host_pref_buf
host_pref_buf
sizeof(host_pref_buf) - 1
sizeof(host_pref_buf)
(host_pref_buf)
host_pref_buf
host_pref_buf
1
if (!format) {							if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP))								format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;							if (!format) {								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}								if (authdebug) {									char tmp[256], tmp2[256], tmp3[256];									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}							} else {								/* Pick one... */								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))										format = 0;								} else {									if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {										using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";										memset(&pref, 0, sizeof(pref));										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);										strcpy(caller_pref_buf,"disabled");										strcpy(host_pref_buf,"disabled");									} else {										struct ast_format tmpfmt;										using_prefs = "mine";										if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {											/* Do the opposite of what we tried above. */											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);										} else /* if no codec_prefs IE do it the old way */											format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}								}								if (!format) {									char tmp[256], tmp2[256], tmp3[256];									memset(&ied0, 0, sizeof(ied0));									iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");									iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);									ast_log(LOG_ERROR, "No best format in '%s'???\n", iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));									send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);									if (!iaxs[fr->callno]) {										break;									}									if (authdebug) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}									ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);									break;								}							}						}
!format
format
format
{							if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP))								format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;							if (!format) {								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}								if (authdebug) {									char tmp[256], tmp2[256], tmp3[256];									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}							} else {								/* Pick one... */								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))										format = 0;								} else {									if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {										using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";										memset(&pref, 0, sizeof(pref));										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);										strcpy(caller_pref_buf,"disabled");										strcpy(host_pref_buf,"disabled");									} else {										struct ast_format tmpfmt;										using_prefs = "mine";										if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {											/* Do the opposite of what we tried above. */											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);										} else /* if no codec_prefs IE do it the old way */											format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}								}								if (!format) {									char tmp[256], tmp2[256], tmp3[256];									memset(&ied0, 0, sizeof(ied0));									iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");									iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);									ast_log(LOG_ERROR, "No best format in '%s'???\n", iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));									send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);									if (!iaxs[fr->callno]) {										break;									}									if (authdebug) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}									ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);									break;								}							}						}
if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP))								format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;
!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_CODEC_NOCAP
IAX_CODEC_NOCAP
format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;
format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability
format
format
iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability
iaxs[fr->callno]->peercapability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercapability
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
if (!format) {								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}								if (authdebug) {									char tmp[256], tmp2[256], tmp3[256];									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}							} else {								/* Pick one... */								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))										format = 0;								} else {									if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {										using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";										memset(&pref, 0, sizeof(pref));										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);										strcpy(caller_pref_buf,"disabled");										strcpy(host_pref_buf,"disabled");									} else {										struct ast_format tmpfmt;										using_prefs = "mine";										if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {											/* Do the opposite of what we tried above. */											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);										} else /* if no codec_prefs IE do it the old way */											format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}								}								if (!format) {									char tmp[256], tmp2[256], tmp3[256];									memset(&ied0, 0, sizeof(ied0));									iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");									iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);									ast_log(LOG_ERROR, "No best format in '%s'???\n", iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));									send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);									if (!iaxs[fr->callno]) {										break;									}									if (authdebug) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}									ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);									break;								}							}
!format
format
format
{								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}								if (authdebug) {									char tmp[256], tmp2[256], tmp3[256];									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}							}
memset(&ied0, 0, sizeof(ied0));
memset(&ied0, 0, sizeof(ied0))
memset
memset
&ied0
ied0
ied0
0
sizeof(ied0)
(ied0)
ied0
ied0
iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");
iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec")
iax_ie_append_str
iax_ie_append_str
&ied0
ied0
ied0
IAX_IE_CAUSE
IAX_IE_CAUSE
"Unable to negotiate codec"
iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);
iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL)
iax_ie_append_byte
iax_ie_append_byte
&ied0
ied0
ied0
IAX_IE_CAUSECODE
IAX_IE_CAUSECODE
AST_CAUSE_BEARERCAPABILITY_NOTAVAIL
AST_CAUSE_BEARERCAPABILITY_NOTAVAIL
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1)
send_command_final
send_command_final
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_REJECT
IAX_COMMAND_REJECT
0
ied0.buf
ied0
ied0
buf
ied0.pos
ied0
ied0
pos
-1
1
if (!iaxs[fr->callno]) {									break;								}
!iaxs[fr->callno]
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{									break;								}
break;
if (authdebug) {									char tmp[256], tmp2[256], tmp3[256];									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}
authdebug
authdebug
{									char tmp[256], tmp2[256], tmp3[256];									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}
char tmp[256], tmp2[256], tmp3[256];
char tmp[256], tmp2[256], tmp3[256];
char
tmp[256]
tmp
[256]
256
tmp2[256]
tmp2
[256]
256
tmp3[256]
tmp3
[256]
256
if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_CODEC_NOCAP
IAX_CODEC_NOCAP
{										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									}
ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));
ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability))
ast_log
ast_log
LOG_NOTICE
LOG_NOTICE
"Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n"
ast_inet_ntoa(sin.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
sin.sin_addr
sin
sin
sin_addr
iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp
tmp
sizeof(tmp)
(tmp)
tmp
tmp
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp2
tmp2
sizeof(tmp2)
(tmp2)
tmp2
tmp2
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
{										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}
ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));
ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability))
ast_log
ast_log
LOG_NOTICE
LOG_NOTICE
"Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n"
ast_inet_ntoa(sin.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
sin.sin_addr
sin
sin
sin_addr
iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp
tmp
sizeof(tmp)
(tmp)
tmp
tmp
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp2
tmp2
sizeof(tmp2)
(tmp2)
tmp2
tmp2
iaxs[fr->callno]->peercapability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercapability
iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp3
tmp3
sizeof(tmp3)
(tmp3)
tmp3
tmp3
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
{								/* Pick one... */								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))										format = 0;								} else {									if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {										using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";										memset(&pref, 0, sizeof(pref));										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);										strcpy(caller_pref_buf,"disabled");										strcpy(host_pref_buf,"disabled");									} else {										struct ast_format tmpfmt;										using_prefs = "mine";										if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {											/* Do the opposite of what we tried above. */											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);										} else /* if no codec_prefs IE do it the old way */											format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}								}								if (!format) {									char tmp[256], tmp2[256], tmp3[256];									memset(&ied0, 0, sizeof(ied0));									iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");									iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);									ast_log(LOG_ERROR, "No best format in '%s'???\n", iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));									send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);									if (!iaxs[fr->callno]) {										break;									}									if (authdebug) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}									ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);									break;								}							}
if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))										format = 0;								} else {									if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {										using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";										memset(&pref, 0, sizeof(pref));										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);										strcpy(caller_pref_buf,"disabled");										strcpy(host_pref_buf,"disabled");									} else {										struct ast_format tmpfmt;										using_prefs = "mine";										if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {											/* Do the opposite of what we tried above. */											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);										} else /* if no codec_prefs IE do it the old way */											format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}								}
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_CODEC_NOCAP
IAX_CODEC_NOCAP
{									if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))										format = 0;								}
if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))										format = 0;
!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)
(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)
iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
format = 0;
format = 0
format
format
0
{									if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {										using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";										memset(&pref, 0, sizeof(pref));										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);										strcpy(caller_pref_buf,"disabled");										strcpy(host_pref_buf,"disabled");									} else {										struct ast_format tmpfmt;										using_prefs = "mine";										if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {											/* Do the opposite of what we tried above. */											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);										} else /* if no codec_prefs IE do it the old way */											format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}								}
if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {										using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";										memset(&pref, 0, sizeof(pref));										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);										strcpy(caller_pref_buf,"disabled");										strcpy(host_pref_buf,"disabled");									} else {										struct ast_format tmpfmt;										using_prefs = "mine";										if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {											/* Do the opposite of what we tried above. */											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);										} else /* if no codec_prefs IE do it the old way */											format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_CODEC_NOPREFS
IAX_CODEC_NOPREFS
{										using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";										memset(&pref, 0, sizeof(pref));										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);										strcpy(caller_pref_buf,"disabled");										strcpy(host_pref_buf,"disabled");									}
using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";
using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled"
using_prefs
using_prefs
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled"
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_CODEC_NOCAP
IAX_CODEC_NOCAP
"reqonly"
"disabled"
memset(&pref, 0, sizeof(pref));
memset(&pref, 0, sizeof(pref))
memset
memset
&pref
pref
pref
0
sizeof(pref)
(pref)
pref
pref
format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);
format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
format
format
iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
iax2_best_codec
iax2_best_codec
iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability
iaxs[fr->callno]->peercapability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercapability
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
strcpy(caller_pref_buf,"disabled");
strcpy(caller_pref_buf,"disabled")
strcpy
strcpy
caller_pref_buf
caller_pref_buf
"disabled"
strcpy(host_pref_buf,"disabled");
strcpy(host_pref_buf,"disabled")
strcpy
strcpy
host_pref_buf
host_pref_buf
"disabled"
{										struct ast_format tmpfmt;										using_prefs = "mine";										if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {											/* Do the opposite of what we tried above. */											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);										} else /* if no codec_prefs IE do it the old way */											format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}
struct ast_format tmpfmt;
struct ast_format tmpfmt;
struct ast_format
ast_format
tmpfmt
tmpfmt
using_prefs = "mine";
using_prefs = "mine"
using_prefs
using_prefs
"mine"
if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {											/* Do the opposite of what we tried above. */											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);										} else /* if no codec_prefs IE do it the old way */											format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);
ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)
ast_codec_pref_index
ast_codec_pref_index
&iaxs[fr->callno]->rprefs
iaxs[fr->callno]->rprefs
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
rprefs
0
&tmpfmt
tmpfmt
tmpfmt
{											/* Do the opposite of what we tried above. */											if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}											format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);										}
if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {												pref = iaxs[fr->callno]->prefs;											} else {												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_CODEC_USER_FIRST
IAX_CODEC_USER_FIRST
{												pref = iaxs[fr->callno]->prefs;											}
pref = iaxs[fr->callno]->prefs;
pref = iaxs[fr->callno]->prefs
pref
pref
iaxs[fr->callno]->prefs
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
prefs
{												pref = iaxs[fr->callno]->rprefs;												using_prefs = "caller";											}
pref = iaxs[fr->callno]->rprefs;
pref = iaxs[fr->callno]->rprefs
pref
pref
iaxs[fr->callno]->rprefs
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
rprefs
using_prefs = "caller";
using_prefs = "caller"
using_prefs
using_prefs
"caller"
format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);
format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1)
format
format
iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1)
iax2_codec_choose
iax2_codec_choose
&pref
pref
pref
iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability
iaxs[fr->callno]->peercapability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercapability
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
1
format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);
format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
format
format
iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
iax2_best_codec
iax2_best_codec
iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability
iaxs[fr->callno]->peercapability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercapability
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
if (!format) {									char tmp[256], tmp2[256], tmp3[256];									memset(&ied0, 0, sizeof(ied0));									iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");									iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);									ast_log(LOG_ERROR, "No best format in '%s'???\n", iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));									send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);									if (!iaxs[fr->callno]) {										break;									}									if (authdebug) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}									ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);									break;								}
!format
format
format
{									char tmp[256], tmp2[256], tmp3[256];									memset(&ied0, 0, sizeof(ied0));									iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");									iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);									ast_log(LOG_ERROR, "No best format in '%s'???\n", iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));									send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);									if (!iaxs[fr->callno]) {										break;									}									if (authdebug) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}									ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);									break;								}
char tmp[256], tmp2[256], tmp3[256];
char tmp[256], tmp2[256], tmp3[256];
char
tmp[256]
tmp
[256]
256
tmp2[256]
tmp2
[256]
256
tmp3[256]
tmp3
[256]
256
memset(&ied0, 0, sizeof(ied0));
memset(&ied0, 0, sizeof(ied0))
memset
memset
&ied0
ied0
ied0
0
sizeof(ied0)
(ied0)
ied0
ied0
iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");
iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec")
iax_ie_append_str
iax_ie_append_str
&ied0
ied0
ied0
IAX_IE_CAUSE
IAX_IE_CAUSE
"Unable to negotiate codec"
iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);
iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL)
iax_ie_append_byte
iax_ie_append_byte
&ied0
ied0
ied0
IAX_IE_CAUSECODE
IAX_IE_CAUSECODE
AST_CAUSE_BEARERCAPABILITY_NOTAVAIL
AST_CAUSE_BEARERCAPABILITY_NOTAVAIL
ast_log(LOG_ERROR, "No best format in '%s'???\n", iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));
ast_log(LOG_ERROR, "No best format in '%s'???\n", iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability))
ast_log
ast_log
LOG_ERROR
LOG_ERROR
"No best format in '%s'???\n"
iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp
tmp
sizeof(tmp)
(tmp)
tmp
tmp
iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability
iaxs[fr->callno]->peercapability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercapability
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1)
send_command_final
send_command_final
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_REJECT
IAX_COMMAND_REJECT
0
ied0.buf
ied0
ied0
buf
ied0.pos
ied0
ied0
pos
-1
1
if (!iaxs[fr->callno]) {										break;									}
!iaxs[fr->callno]
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{										break;									}
break;
if (authdebug) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}
authdebug
authdebug
{										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}
ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));
ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability))
ast_log
ast_log
LOG_NOTICE
LOG_NOTICE
"Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n"
ast_inet_ntoa(sin.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
sin.sin_addr
sin
sin
sin_addr
iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp
tmp
sizeof(tmp)
(tmp)
tmp
tmp
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp2
tmp2
sizeof(tmp2)
(tmp2)
tmp2
tmp2
iaxs[fr->callno]->peercapability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercapability
iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp3
tmp3
sizeof(tmp3)
(tmp3)
tmp3
tmp3
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);
ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE)
ast_set_flag64
ast_set_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_ALREADYGONE
IAX_ALREADYGONE
break;
if (format) {							/* No authentication required, let them in */							memset(&ied1, 0, sizeof(ied1));							iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);							iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);							send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);							if (strcmp(iaxs[fr->callno]->exten, "TBD")) {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);								ast_verb(3, "Accepting UNAUTHENTICATED call from %s:\n"												"%srequested format = %s,\n"												"%srequested prefs = %s,\n"												"%sactual format = %s,\n"												"%shost prefs = %s,\n"												"%spriority = %s\n",												ast_inet_ntoa(sin.sin_addr), 												VERBOSE_PREFIX_4,												iax2_getformatname(iaxs[fr->callno]->peerformat), 												VERBOSE_PREFIX_4,												caller_pref_buf,												VERBOSE_PREFIX_4,												iax2_getformatname(format), 												VERBOSE_PREFIX_4,												host_pref_buf, 												VERBOSE_PREFIX_4,												using_prefs);								iaxs[fr->callno]->chosenformat = format;								/* Since this is a new call, we should go ahead and set the callid for it. */								iax_pvt_callid_new(fr->callno);								ast_set_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);							} else {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);								/* If this is a TBD call, we're ready but now what...  */								ast_verb(3, "Accepted unauthenticated TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							}						}
format
format
{							/* No authentication required, let them in */							memset(&ied1, 0, sizeof(ied1));							iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);							iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);							send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);							if (strcmp(iaxs[fr->callno]->exten, "TBD")) {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);								ast_verb(3, "Accepting UNAUTHENTICATED call from %s:\n"												"%srequested format = %s,\n"												"%srequested prefs = %s,\n"												"%sactual format = %s,\n"												"%shost prefs = %s,\n"												"%spriority = %s\n",												ast_inet_ntoa(sin.sin_addr), 												VERBOSE_PREFIX_4,												iax2_getformatname(iaxs[fr->callno]->peerformat), 												VERBOSE_PREFIX_4,												caller_pref_buf,												VERBOSE_PREFIX_4,												iax2_getformatname(format), 												VERBOSE_PREFIX_4,												host_pref_buf, 												VERBOSE_PREFIX_4,												using_prefs);								iaxs[fr->callno]->chosenformat = format;								/* Since this is a new call, we should go ahead and set the callid for it. */								iax_pvt_callid_new(fr->callno);								ast_set_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);							} else {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);								/* If this is a TBD call, we're ready but now what...  */								ast_verb(3, "Accepted unauthenticated TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							}						}
memset(&ied1, 0, sizeof(ied1));
memset(&ied1, 0, sizeof(ied1))
memset
memset
&ied1
ied1
ied1
0
sizeof(ied1)
(ied1)
ied1
ied1
iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);
iax_ie_append_int(&ied1, IAX_IE_FORMAT, format)
iax_ie_append_int
iax_ie_append_int
&ied1
ied1
ied1
IAX_IE_FORMAT
IAX_IE_FORMAT
format
format
iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);
iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format)
iax_ie_append_versioned_uint64
iax_ie_append_versioned_uint64
&ied1
ied1
ied1
IAX_IE_FORMAT2
IAX_IE_FORMAT2
0
format
format
send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);
send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1)
send_command
send_command
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_ACCEPT
IAX_COMMAND_ACCEPT
0
ied1.buf
ied1
ied1
buf
ied1.pos
ied1
ied1
pos
-1
1
if (strcmp(iaxs[fr->callno]->exten, "TBD")) {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);								ast_verb(3, "Accepting UNAUTHENTICATED call from %s:\n"												"%srequested format = %s,\n"												"%srequested prefs = %s,\n"												"%sactual format = %s,\n"												"%shost prefs = %s,\n"												"%spriority = %s\n",												ast_inet_ntoa(sin.sin_addr), 												VERBOSE_PREFIX_4,												iax2_getformatname(iaxs[fr->callno]->peerformat), 												VERBOSE_PREFIX_4,												caller_pref_buf,												VERBOSE_PREFIX_4,												iax2_getformatname(format), 												VERBOSE_PREFIX_4,												host_pref_buf, 												VERBOSE_PREFIX_4,												using_prefs);								iaxs[fr->callno]->chosenformat = format;								/* Since this is a new call, we should go ahead and set the callid for it. */								iax_pvt_callid_new(fr->callno);								ast_set_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);							} else {								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);								/* If this is a TBD call, we're ready but now what...  */								ast_verb(3, "Accepted unauthenticated TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							}
strcmp(iaxs[fr->callno]->exten, "TBD")
strcmp
strcmp
iaxs[fr->callno]->exten
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
exten
"TBD"
{								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);								ast_verb(3, "Accepting UNAUTHENTICATED call from %s:\n"												"%srequested format = %s,\n"												"%srequested prefs = %s,\n"												"%sactual format = %s,\n"												"%shost prefs = %s,\n"												"%spriority = %s\n",												ast_inet_ntoa(sin.sin_addr), 												VERBOSE_PREFIX_4,												iax2_getformatname(iaxs[fr->callno]->peerformat), 												VERBOSE_PREFIX_4,												caller_pref_buf,												VERBOSE_PREFIX_4,												iax2_getformatname(format), 												VERBOSE_PREFIX_4,												host_pref_buf, 												VERBOSE_PREFIX_4,												using_prefs);								iaxs[fr->callno]->chosenformat = format;								/* Since this is a new call, we should go ahead and set the callid for it. */								iax_pvt_callid_new(fr->callno);								ast_set_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);							}
ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);
ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
ast_set_flag
ast_set_flag
&iaxs[fr->callno]->state
iaxs[fr->callno]->state
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
state
IAX_STATE_STARTED
IAX_STATE_STARTED
ast_verb(3, "Accepting UNAUTHENTICATED call from %s:\n"												"%srequested format = %s,\n"												"%srequested prefs = %s,\n"												"%sactual format = %s,\n"												"%shost prefs = %s,\n"												"%spriority = %s\n",												ast_inet_ntoa(sin.sin_addr), 												VERBOSE_PREFIX_4,												iax2_getformatname(iaxs[fr->callno]->peerformat), 												VERBOSE_PREFIX_4,												caller_pref_buf,												VERBOSE_PREFIX_4,												iax2_getformatname(format), 												VERBOSE_PREFIX_4,												host_pref_buf, 												VERBOSE_PREFIX_4,												using_prefs);
ast_verb(3, "Accepting UNAUTHENTICATED call from %s:\n"												"%srequested format = %s,\n"												"%srequested prefs = %s,\n"												"%sactual format = %s,\n"												"%shost prefs = %s,\n"												"%spriority = %s\n",												ast_inet_ntoa(sin.sin_addr), 												VERBOSE_PREFIX_4,												iax2_getformatname(iaxs[fr->callno]->peerformat), 												VERBOSE_PREFIX_4,												caller_pref_buf,												VERBOSE_PREFIX_4,												iax2_getformatname(format), 												VERBOSE_PREFIX_4,												host_pref_buf, 												VERBOSE_PREFIX_4,												using_prefs)
ast_verb
ast_verb
3
"Accepting UNAUTHENTICATED call from %s:\n"												"%srequested format = %s,\n"												"%srequested prefs = %s,\n"												"%sactual format = %s,\n"												"%shost prefs = %s,\n"												"%spriority = %s\n"
ast_inet_ntoa(sin.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
sin.sin_addr
sin
sin
sin_addr
VERBOSE_PREFIX_4
VERBOSE_PREFIX_4
iax2_getformatname(iaxs[fr->callno]->peerformat)
iax2_getformatname
iax2_getformatname
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
VERBOSE_PREFIX_4
VERBOSE_PREFIX_4
caller_pref_buf
caller_pref_buf
VERBOSE_PREFIX_4
VERBOSE_PREFIX_4
iax2_getformatname(format)
iax2_getformatname
iax2_getformatname
format
format
VERBOSE_PREFIX_4
VERBOSE_PREFIX_4
host_pref_buf
host_pref_buf
VERBOSE_PREFIX_4
VERBOSE_PREFIX_4
using_prefs
using_prefs
iaxs[fr->callno]->chosenformat = format;
iaxs[fr->callno]->chosenformat = format
iaxs[fr->callno]->chosenformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
chosenformat
format
format
iax_pvt_callid_new(fr->callno);
iax_pvt_callid_new(fr->callno)
iax_pvt_callid_new
iax_pvt_callid_new
fr->callno
fr
fr
callno
ast_set_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART);
ast_set_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART)
ast_set_flag64
ast_set_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_DELAYPBXSTART
IAX_DELAYPBXSTART
{								ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);								/* If this is a TBD call, we're ready but now what...  */								ast_verb(3, "Accepted unauthenticated TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							}
ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);
ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD)
ast_set_flag
ast_set_flag
&iaxs[fr->callno]->state
iaxs[fr->callno]->state
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
state
IAX_STATE_TBD
IAX_STATE_TBD
ast_verb(3, "Accepted unauthenticated TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));
ast_verb(3, "Accepted unauthenticated TBD call from %s\n", ast_inet_ntoa(sin.sin_addr))
ast_verb
ast_verb
3
"Accepted unauthenticated TBD call from %s\n"
ast_inet_ntoa(sin.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
sin.sin_addr
sin
sin
sin_addr
break;
if (iaxs[fr->callno]->authmethods & IAX_AUTH_MD5)					merge_encryption(iaxs[fr->callno],ies.encmethods);				else					iaxs[fr->callno]->encmethods = 0;
iaxs[fr->callno]->authmethods & IAX_AUTH_MD5
iaxs[fr->callno]->authmethods
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
authmethods
IAX_AUTH_MD5
IAX_AUTH_MD5
merge_encryption(iaxs[fr->callno],ies.encmethods);
merge_encryption(iaxs[fr->callno],ies.encmethods)
merge_encryption
merge_encryption
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
ies.encmethods
ies
ies
encmethods
iaxs[fr->callno]->encmethods = 0;
iaxs[fr->callno]->encmethods = 0
iaxs[fr->callno]->encmethods
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
encmethods
0
if (!authenticate_request(fr->callno) && iaxs[fr->callno])					ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED);
!authenticate_request(fr->callno) && iaxs[fr->callno]
!authenticate_request(fr->callno)
authenticate_request(fr->callno)
authenticate_request
authenticate_request
fr->callno
fr
fr
callno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED);
ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED)
ast_set_flag
ast_set_flag
&iaxs[fr->callno]->state
iaxs[fr->callno]->state
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
state
IAX_STATE_AUTHENTICATED
IAX_STATE_AUTHENTICATED
break;
case IAX_COMMAND_DPREQ:
IAX_COMMAND_DPREQ
IAX_COMMAND_DPREQ
if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD) &&					!ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED) && ies.called_number) {					if (iaxcompat) {						/* Spawn a thread for the lookup */						spawn_dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num);					} else {						/* Just look it up */						dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num, 1);					}				}
ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD) &&					!ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED) && ies.called_number
ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD) &&					!ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD)
ast_test_flag
ast_test_flag
&iaxs[fr->callno]->state
iaxs[fr->callno]->state
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
state
IAX_STATE_TBD
IAX_STATE_TBD
!ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
ast_test_flag
ast_test_flag
&iaxs[fr->callno]->state
iaxs[fr->callno]->state
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
state
IAX_STATE_STARTED
IAX_STATE_STARTED
ies.called_number
ies
ies
called_number
{					if (iaxcompat) {						/* Spawn a thread for the lookup */						spawn_dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num);					} else {						/* Just look it up */						dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num, 1);					}				}
if (iaxcompat) {						/* Spawn a thread for the lookup */						spawn_dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num);					} else {						/* Just look it up */						dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num, 1);					}
iaxcompat
iaxcompat
{						/* Spawn a thread for the lookup */						spawn_dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num);					}
spawn_dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num);
spawn_dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num)
spawn_dp_lookup
spawn_dp_lookup
fr->callno
fr
fr
callno
iaxs[fr->callno]->context
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
context
ies.called_number
ies
ies
called_number
iaxs[fr->callno]->cid_num
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
cid_num
{						/* Just look it up */						dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num, 1);					}
dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num, 1);
dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num, 1)
dp_lookup
dp_lookup
fr->callno
fr
fr
callno
iaxs[fr->callno]->context
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
context
ies.called_number
ies
ies
called_number
iaxs[fr->callno]->cid_num
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
cid_num
1
break;
case IAX_COMMAND_HANGUP:
IAX_COMMAND_HANGUP
IAX_COMMAND_HANGUP
ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);
ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE)
ast_set_flag64
ast_set_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_ALREADYGONE
IAX_ALREADYGONE
ast_debug(1, "Immediately destroying %d, having received hangup\n", fr->callno);
ast_debug(1, "Immediately destroying %d, having received hangup\n", fr->callno)
ast_debug
ast_debug
1
"Immediately destroying %d, having received hangup\n"
fr->callno
fr
fr
callno
if (iaxs[fr->callno]->owner) {					set_hangup_source_and_cause(fr->callno, ies.causecode);					if (!iaxs[fr->callno]) {						break;					}				}
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
{					set_hangup_source_and_cause(fr->callno, ies.causecode);					if (!iaxs[fr->callno]) {						break;					}				}
set_hangup_source_and_cause(fr->callno, ies.causecode);
set_hangup_source_and_cause(fr->callno, ies.causecode)
set_hangup_source_and_cause
set_hangup_source_and_cause
fr->callno
fr
fr
callno
ies.causecode
ies
ies
causecode
if (!iaxs[fr->callno]) {						break;					}
!iaxs[fr->callno]
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{						break;					}
break;
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
send_command_immediate
send_command_immediate
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_ACK
IAX_COMMAND_ACK
fr->ts
fr
fr
ts
NULL
NULL
0
fr->iseqno
fr
fr
iseqno
iax2_destroy(fr->callno);
iax2_destroy(fr->callno)
iax2_destroy
iax2_destroy
fr->callno
fr
fr
callno
break;
case IAX_COMMAND_REJECT:
IAX_COMMAND_REJECT
IAX_COMMAND_REJECT
if (iaxs[fr->callno]->owner) {					set_hangup_source_and_cause(fr->callno, ies.causecode);					if (!iaxs[fr->callno]) {						break;					}				}
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
{					set_hangup_source_and_cause(fr->callno, ies.causecode);					if (!iaxs[fr->callno]) {						break;					}				}
set_hangup_source_and_cause(fr->callno, ies.causecode);
set_hangup_source_and_cause(fr->callno, ies.causecode)
set_hangup_source_and_cause
set_hangup_source_and_cause
fr->callno
fr
fr
callno
ies.causecode
ies
ies
causecode
if (!iaxs[fr->callno]) {						break;					}
!iaxs[fr->callno]
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{						break;					}
break;
if (!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)) {					if (iaxs[fr->callno]->owner && authdebug)						ast_log(LOG_WARNING, "Call rejected by %s: %s\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr),							ies.cause ? ies.cause : "<Unknown>");					ast_debug(1, "Immediately destroying %d, having received reject\n",						fr->callno);				}
!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)
ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_PROVISION
IAX_PROVISION
{					if (iaxs[fr->callno]->owner && authdebug)						ast_log(LOG_WARNING, "Call rejected by %s: %s\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr),							ies.cause ? ies.cause : "<Unknown>");					ast_debug(1, "Immediately destroying %d, having received reject\n",						fr->callno);				}
if (iaxs[fr->callno]->owner && authdebug)						ast_log(LOG_WARNING, "Call rejected by %s: %s\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr),							ies.cause ? ies.cause : "<Unknown>");
iaxs[fr->callno]->owner && authdebug
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
authdebug
authdebug
ast_log(LOG_WARNING, "Call rejected by %s: %s\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr),							ies.cause ? ies.cause : "<Unknown>");
ast_log(LOG_WARNING, "Call rejected by %s: %s\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr),							ies.cause ? ies.cause : "<Unknown>")
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"Call rejected by %s: %s\n"
ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
iaxs[fr->callno]->addr.sin_addr
iaxs[fr->callno]->addr
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
addr
sin_addr
ies.cause ? ies.cause : "<Unknown>"
ies.cause
ies
ies
cause
ies.cause
ies
ies
cause
"<Unknown>"
ast_debug(1, "Immediately destroying %d, having received reject\n",						fr->callno);
ast_debug(1, "Immediately destroying %d, having received reject\n",						fr->callno)
ast_debug
ast_debug
1
"Immediately destroying %d, having received reject\n"
fr->callno
fr
fr
callno
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK,						       fr->ts, NULL, 0, fr->iseqno);
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK,						       fr->ts, NULL, 0, fr->iseqno)
send_command_immediate
send_command_immediate
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_ACK
IAX_COMMAND_ACK
fr->ts
fr
fr
ts
NULL
NULL
0
fr->iseqno
fr
fr
iseqno
if (!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION))					iaxs[fr->callno]->error = EPERM;
!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)
ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_PROVISION
IAX_PROVISION
iaxs[fr->callno]->error = EPERM;
iaxs[fr->callno]->error = EPERM
iaxs[fr->callno]->error
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
error
EPERM
EPERM
iax2_destroy(fr->callno);
iax2_destroy(fr->callno)
iax2_destroy
iax2_destroy
fr->callno
fr
fr
callno
break;
case IAX_COMMAND_TRANSFER:
IAX_COMMAND_TRANSFER
IAX_COMMAND_TRANSFER
{				struct ast_channel *bridged_chan;				struct ast_channel *owner;				iax2_lock_owner(fr->callno);				if (!iaxs[fr->callno]) {					/* Initiating call went away before we could transfer. */					break;				}				owner = iaxs[fr->callno]->owner;				bridged_chan = owner ? ast_bridged_channel(owner) : NULL;				if (bridged_chan && ies.called_number) {					const char *context;					context = ast_strdupa(iaxs[fr->callno]->context);					ast_channel_ref(owner);					ast_channel_ref(bridged_chan);					ast_channel_unlock(owner);					ast_mutex_unlock(&iaxsl[fr->callno]);					/* Set BLINDTRANSFER channel variables */					pbx_builtin_setvar_helper(owner, "BLINDTRANSFER", ast_channel_name(bridged_chan));					pbx_builtin_setvar_helper(bridged_chan, "BLINDTRANSFER", ast_channel_name(owner));					/* DO NOT hold any locks while calling ast_parking_ext_valid() */					if (ast_parking_ext_valid(ies.called_number, owner, context)) {						ast_debug(1, "Parking call '%s'\n", ast_channel_name(bridged_chan));						if (iax_park(bridged_chan, owner, ies.called_number, context)) {							ast_log(LOG_WARNING, "Failed to park call '%s'\n",								ast_channel_name(bridged_chan));						}					} else {						if (ast_async_goto(bridged_chan, context, ies.called_number, 1)) {							ast_log(LOG_WARNING,								"Async goto of '%s' to '%s@%s' failed\n",								ast_channel_name(bridged_chan), ies.called_number, context);						} else {							ast_debug(1, "Async goto of '%s' to '%s@%s' started\n",								ast_channel_name(bridged_chan), ies.called_number, context);						}					}					ast_channel_unref(owner);					ast_channel_unref(bridged_chan);					ast_mutex_lock(&iaxsl[fr->callno]);				} else {					ast_debug(1, "Async goto not applicable on call %d\n", fr->callno);					if (owner) {						ast_channel_unlock(owner);					}				}				break;			}
struct ast_channel *bridged_chan;
struct ast_channel *bridged_chan;
struct ast_channel
ast_channel
*bridged_chan
*
bridged_chan
struct ast_channel *owner;
struct ast_channel *owner;
struct ast_channel
ast_channel
*owner
*
owner
iax2_lock_owner(fr->callno);
iax2_lock_owner(fr->callno)
iax2_lock_owner
iax2_lock_owner
fr->callno
fr
fr
callno
if (!iaxs[fr->callno]) {					/* Initiating call went away before we could transfer. */					break;				}
!iaxs[fr->callno]
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{					/* Initiating call went away before we could transfer. */					break;				}
break;
owner = iaxs[fr->callno]->owner;
owner = iaxs[fr->callno]->owner
owner
owner
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
bridged_chan = owner ? ast_bridged_channel(owner) : NULL;
bridged_chan = owner ? ast_bridged_channel(owner) : NULL
bridged_chan
bridged_chan
owner ? ast_bridged_channel(owner) : NULL
owner
owner
ast_bridged_channel(owner)
ast_bridged_channel
ast_bridged_channel
owner
owner
NULL
NULL
if (bridged_chan && ies.called_number) {					const char *context;					context = ast_strdupa(iaxs[fr->callno]->context);					ast_channel_ref(owner);					ast_channel_ref(bridged_chan);					ast_channel_unlock(owner);					ast_mutex_unlock(&iaxsl[fr->callno]);					/* Set BLINDTRANSFER channel variables */					pbx_builtin_setvar_helper(owner, "BLINDTRANSFER", ast_channel_name(bridged_chan));					pbx_builtin_setvar_helper(bridged_chan, "BLINDTRANSFER", ast_channel_name(owner));					/* DO NOT hold any locks while calling ast_parking_ext_valid() */					if (ast_parking_ext_valid(ies.called_number, owner, context)) {						ast_debug(1, "Parking call '%s'\n", ast_channel_name(bridged_chan));						if (iax_park(bridged_chan, owner, ies.called_number, context)) {							ast_log(LOG_WARNING, "Failed to park call '%s'\n",								ast_channel_name(bridged_chan));						}					} else {						if (ast_async_goto(bridged_chan, context, ies.called_number, 1)) {							ast_log(LOG_WARNING,								"Async goto of '%s' to '%s@%s' failed\n",								ast_channel_name(bridged_chan), ies.called_number, context);						} else {							ast_debug(1, "Async goto of '%s' to '%s@%s' started\n",								ast_channel_name(bridged_chan), ies.called_number, context);						}					}					ast_channel_unref(owner);					ast_channel_unref(bridged_chan);					ast_mutex_lock(&iaxsl[fr->callno]);				} else {					ast_debug(1, "Async goto not applicable on call %d\n", fr->callno);					if (owner) {						ast_channel_unlock(owner);					}				}
bridged_chan && ies.called_number
bridged_chan
bridged_chan
ies.called_number
ies
ies
called_number
{					const char *context;					context = ast_strdupa(iaxs[fr->callno]->context);					ast_channel_ref(owner);					ast_channel_ref(bridged_chan);					ast_channel_unlock(owner);					ast_mutex_unlock(&iaxsl[fr->callno]);					/* Set BLINDTRANSFER channel variables */					pbx_builtin_setvar_helper(owner, "BLINDTRANSFER", ast_channel_name(bridged_chan));					pbx_builtin_setvar_helper(bridged_chan, "BLINDTRANSFER", ast_channel_name(owner));					/* DO NOT hold any locks while calling ast_parking_ext_valid() */					if (ast_parking_ext_valid(ies.called_number, owner, context)) {						ast_debug(1, "Parking call '%s'\n", ast_channel_name(bridged_chan));						if (iax_park(bridged_chan, owner, ies.called_number, context)) {							ast_log(LOG_WARNING, "Failed to park call '%s'\n",								ast_channel_name(bridged_chan));						}					} else {						if (ast_async_goto(bridged_chan, context, ies.called_number, 1)) {							ast_log(LOG_WARNING,								"Async goto of '%s' to '%s@%s' failed\n",								ast_channel_name(bridged_chan), ies.called_number, context);						} else {							ast_debug(1, "Async goto of '%s' to '%s@%s' started\n",								ast_channel_name(bridged_chan), ies.called_number, context);						}					}					ast_channel_unref(owner);					ast_channel_unref(bridged_chan);					ast_mutex_lock(&iaxsl[fr->callno]);				}
const char *context;
const char *context;
const char
*context
*
context
context = ast_strdupa(iaxs[fr->callno]->context);
context = ast_strdupa(iaxs[fr->callno]->context)
context
context
ast_strdupa(iaxs[fr->callno]->context)
ast_strdupa
ast_strdupa
iaxs[fr->callno]->context
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
context
ast_channel_ref(owner);
ast_channel_ref(owner)
ast_channel_ref
ast_channel_ref
owner
owner
ast_channel_ref(bridged_chan);
ast_channel_ref(bridged_chan)
ast_channel_ref
ast_channel_ref
bridged_chan
bridged_chan
ast_channel_unlock(owner);
ast_channel_unlock(owner)
ast_channel_unlock
ast_channel_unlock
owner
owner
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock
ast_mutex_unlock
(&iaxsl[fr->callno])
&iaxsl[fr->callno]
&
iaxsl
[fr->callno]
fr->callno
fr
fr
callno
pbx_builtin_setvar_helper(owner, "BLINDTRANSFER", ast_channel_name(bridged_chan));
pbx_builtin_setvar_helper(owner, "BLINDTRANSFER", ast_channel_name(bridged_chan))
pbx_builtin_setvar_helper
pbx_builtin_setvar_helper
owner
owner
"BLINDTRANSFER"
ast_channel_name(bridged_chan)
ast_channel_name
ast_channel_name
bridged_chan
bridged_chan
pbx_builtin_setvar_helper(bridged_chan, "BLINDTRANSFER", ast_channel_name(owner));
pbx_builtin_setvar_helper(bridged_chan, "BLINDTRANSFER", ast_channel_name(owner))
pbx_builtin_setvar_helper
pbx_builtin_setvar_helper
bridged_chan
bridged_chan
"BLINDTRANSFER"
ast_channel_name(owner)
ast_channel_name
ast_channel_name
owner
owner
if (ast_parking_ext_valid(ies.called_number, owner, context)) {						ast_debug(1, "Parking call '%s'\n", ast_channel_name(bridged_chan));						if (iax_park(bridged_chan, owner, ies.called_number, context)) {							ast_log(LOG_WARNING, "Failed to park call '%s'\n",								ast_channel_name(bridged_chan));						}					} else {						if (ast_async_goto(bridged_chan, context, ies.called_number, 1)) {							ast_log(LOG_WARNING,								"Async goto of '%s' to '%s@%s' failed\n",								ast_channel_name(bridged_chan), ies.called_number, context);						} else {							ast_debug(1, "Async goto of '%s' to '%s@%s' started\n",								ast_channel_name(bridged_chan), ies.called_number, context);						}					}
ast_parking_ext_valid(ies.called_number, owner, context)
ast_parking_ext_valid
ast_parking_ext_valid
ies.called_number
ies
ies
called_number
owner
owner
context
context
{						ast_debug(1, "Parking call '%s'\n", ast_channel_name(bridged_chan));						if (iax_park(bridged_chan, owner, ies.called_number, context)) {							ast_log(LOG_WARNING, "Failed to park call '%s'\n",								ast_channel_name(bridged_chan));						}					}
ast_debug(1, "Parking call '%s'\n", ast_channel_name(bridged_chan));
ast_debug(1, "Parking call '%s'\n", ast_channel_name(bridged_chan))
ast_debug
ast_debug
1
"Parking call '%s'\n"
ast_channel_name(bridged_chan)
ast_channel_name
ast_channel_name
bridged_chan
bridged_chan
if (iax_park(bridged_chan, owner, ies.called_number, context)) {							ast_log(LOG_WARNING, "Failed to park call '%s'\n",								ast_channel_name(bridged_chan));						}
iax_park(bridged_chan, owner, ies.called_number, context)
iax_park
iax_park
bridged_chan
bridged_chan
owner
owner
ies.called_number
ies
ies
called_number
context
context
{							ast_log(LOG_WARNING, "Failed to park call '%s'\n",								ast_channel_name(bridged_chan));						}
ast_log(LOG_WARNING, "Failed to park call '%s'\n",								ast_channel_name(bridged_chan));
ast_log(LOG_WARNING, "Failed to park call '%s'\n",								ast_channel_name(bridged_chan))
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"Failed to park call '%s'\n"
ast_channel_name(bridged_chan)
ast_channel_name
ast_channel_name
bridged_chan
bridged_chan
{						if (ast_async_goto(bridged_chan, context, ies.called_number, 1)) {							ast_log(LOG_WARNING,								"Async goto of '%s' to '%s@%s' failed\n",								ast_channel_name(bridged_chan), ies.called_number, context);						} else {							ast_debug(1, "Async goto of '%s' to '%s@%s' started\n",								ast_channel_name(bridged_chan), ies.called_number, context);						}					}
if (ast_async_goto(bridged_chan, context, ies.called_number, 1)) {							ast_log(LOG_WARNING,								"Async goto of '%s' to '%s@%s' failed\n",								ast_channel_name(bridged_chan), ies.called_number, context);						} else {							ast_debug(1, "Async goto of '%s' to '%s@%s' started\n",								ast_channel_name(bridged_chan), ies.called_number, context);						}
ast_async_goto(bridged_chan, context, ies.called_number, 1)
ast_async_goto
ast_async_goto
bridged_chan
bridged_chan
context
context
ies.called_number
ies
ies
called_number
1
{							ast_log(LOG_WARNING,								"Async goto of '%s' to '%s@%s' failed\n",								ast_channel_name(bridged_chan), ies.called_number, context);						}
ast_log(LOG_WARNING,								"Async goto of '%s' to '%s@%s' failed\n",								ast_channel_name(bridged_chan), ies.called_number, context);
ast_log(LOG_WARNING,								"Async goto of '%s' to '%s@%s' failed\n",								ast_channel_name(bridged_chan), ies.called_number, context)
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"Async goto of '%s' to '%s@%s' failed\n"
ast_channel_name(bridged_chan)
ast_channel_name
ast_channel_name
bridged_chan
bridged_chan
ies.called_number
ies
ies
called_number
context
context
{							ast_debug(1, "Async goto of '%s' to '%s@%s' started\n",								ast_channel_name(bridged_chan), ies.called_number, context);						}
ast_debug(1, "Async goto of '%s' to '%s@%s' started\n",								ast_channel_name(bridged_chan), ies.called_number, context);
ast_debug(1, "Async goto of '%s' to '%s@%s' started\n",								ast_channel_name(bridged_chan), ies.called_number, context)
ast_debug
ast_debug
1
"Async goto of '%s' to '%s@%s' started\n"
ast_channel_name(bridged_chan)
ast_channel_name
ast_channel_name
bridged_chan
bridged_chan
ies.called_number
ies
ies
called_number
context
context
ast_channel_unref(owner);
ast_channel_unref(owner)
ast_channel_unref
ast_channel_unref
owner
owner
ast_channel_unref(bridged_chan);
ast_channel_unref(bridged_chan)
ast_channel_unref
ast_channel_unref
bridged_chan
bridged_chan
ast_mutex_lock(&iaxsl[fr->callno]);
ast_mutex_lock(&iaxsl[fr->callno])
ast_mutex_lock
ast_mutex_lock
&iaxsl[fr->callno]
iaxsl[fr->callno]
iaxsl
iaxsl
fr->callno
fr
fr
callno
{					ast_debug(1, "Async goto not applicable on call %d\n", fr->callno);					if (owner) {						ast_channel_unlock(owner);					}				}
ast_debug(1, "Async goto not applicable on call %d\n", fr->callno);
ast_debug(1, "Async goto not applicable on call %d\n", fr->callno)
ast_debug
ast_debug
1
"Async goto not applicable on call %d\n"
fr->callno
fr
fr
callno
if (owner) {						ast_channel_unlock(owner);					}
owner
owner
{						ast_channel_unlock(owner);					}
ast_channel_unlock(owner);
ast_channel_unlock(owner)
ast_channel_unlock
ast_channel_unlock
owner
owner
break;
case IAX_COMMAND_ACCEPT:
IAX_COMMAND_ACCEPT
IAX_COMMAND_ACCEPT
if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD | IAX_STATE_AUTHENTICATED))					break;
ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD | IAX_STATE_AUTHENTICATED)
ast_test_flag
ast_test_flag
&iaxs[fr->callno]->state
iaxs[fr->callno]->state
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
state
IAX_STATE_STARTED | IAX_STATE_TBD | IAX_STATE_AUTHENTICATED
IAX_STATE_STARTED | IAX_STATE_TBD
IAX_STATE_STARTED
IAX_STATE_STARTED
IAX_STATE_TBD
IAX_STATE_TBD
IAX_STATE_AUTHENTICATED
IAX_STATE_AUTHENTICATED
break;
if (ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)) {					/* Send ack immediately, before we destroy */					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					iax2_destroy(fr->callno);					break;				}
ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_PROVISION
IAX_PROVISION
{					/* Send ack immediately, before we destroy */					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					iax2_destroy(fr->callno);					break;				}
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
send_command_immediate
send_command_immediate
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_ACK
IAX_COMMAND_ACK
fr->ts
fr
fr
ts
NULL
NULL
0
fr->iseqno
fr
fr
iseqno
iax2_destroy(fr->callno);
iax2_destroy(fr->callno)
iax2_destroy
iax2_destroy
fr->callno
fr
fr
callno
break;
if (ies.format) {					iaxs[fr->callno]->peerformat = ies.format;				} else {					if (iaxs[fr->callno]->owner)						iaxs[fr->callno]->peerformat = ast_format_cap_to_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner));					else						iaxs[fr->callno]->peerformat = iaxs[fr->callno]->capability;				}
ies.format
ies
ies
format
{					iaxs[fr->callno]->peerformat = ies.format;				}
iaxs[fr->callno]->peerformat = ies.format;
iaxs[fr->callno]->peerformat = ies.format
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
ies.format
ies
ies
format
{					if (iaxs[fr->callno]->owner)						iaxs[fr->callno]->peerformat = ast_format_cap_to_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner));					else						iaxs[fr->callno]->peerformat = iaxs[fr->callno]->capability;				}
if (iaxs[fr->callno]->owner)						iaxs[fr->callno]->peerformat = ast_format_cap_to_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner));					else						iaxs[fr->callno]->peerformat = iaxs[fr->callno]->capability;
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
iaxs[fr->callno]->peerformat = ast_format_cap_to_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner));
iaxs[fr->callno]->peerformat = ast_format_cap_to_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner))
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
ast_format_cap_to_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner))
ast_format_cap_to_old_bitfield
ast_format_cap_to_old_bitfield
ast_channel_nativeformats(iaxs[fr->callno]->owner)
ast_channel_nativeformats
ast_channel_nativeformats
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
iaxs[fr->callno]->peerformat = iaxs[fr->callno]->capability;
iaxs[fr->callno]->peerformat = iaxs[fr->callno]->capability
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
ast_verb(3, "Call accepted by %s (format %s)\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iax2_getformatname(iaxs[fr->callno]->peerformat));
ast_verb(3, "Call accepted by %s (format %s)\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iax2_getformatname(iaxs[fr->callno]->peerformat))
ast_verb
ast_verb
3
"Call accepted by %s (format %s)\n"
ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
iaxs[fr->callno]->addr.sin_addr
iaxs[fr->callno]->addr
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
addr
sin_addr
iax2_getformatname(iaxs[fr->callno]->peerformat)
iax2_getformatname
iax2_getformatname
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
if (!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)) {					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);					if (!iaxs[fr->callno]) {						break;					}					if (authdebug) {						char tmp1[256], tmp2[256];						ast_log(LOG_NOTICE, "Rejected call to %s, format %s incompatible with our capability %s.\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),							iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));					}				} else {					ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);					iax2_lock_owner(fr->callno);					if (iaxs[fr->callno] && iaxs[fr->callno]->owner) {						char tmp[256];						/* Switch us to use a compatible format */						ast_format_cap_from_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner), iaxs[fr->callno]->peerformat);						ast_verb(3, "Format for call is %s\n", ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(iaxs[fr->callno]->owner)));						/* Setup read/write formats properly. */						if (ast_channel_writeformat(iaxs[fr->callno]->owner)->id)							ast_set_write_format(iaxs[fr->callno]->owner, ast_channel_writeformat(iaxs[fr->callno]->owner));						if (ast_channel_readformat(iaxs[fr->callno]->owner)->id)							ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));						ast_channel_unlock(iaxs[fr->callno]->owner);					}				}
!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)
(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)
iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
{					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);					if (!iaxs[fr->callno]) {						break;					}					if (authdebug) {						char tmp1[256], tmp2[256];						ast_log(LOG_NOTICE, "Rejected call to %s, format %s incompatible with our capability %s.\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),							iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));					}				}
memset(&ied0, 0, sizeof(ied0));
memset(&ied0, 0, sizeof(ied0))
memset
memset
&ied0
ied0
ied0
0
sizeof(ied0)
(ied0)
ied0
ied0
iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");
iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec")
iax_ie_append_str
iax_ie_append_str
&ied0
ied0
ied0
IAX_IE_CAUSE
IAX_IE_CAUSE
"Unable to negotiate codec"
iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);
iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL)
iax_ie_append_byte
iax_ie_append_byte
&ied0
ied0
ied0
IAX_IE_CAUSECODE
IAX_IE_CAUSECODE
AST_CAUSE_BEARERCAPABILITY_NOTAVAIL
AST_CAUSE_BEARERCAPABILITY_NOTAVAIL
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1)
send_command_final
send_command_final
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_REJECT
IAX_COMMAND_REJECT
0
ied0.buf
ied0
ied0
buf
ied0.pos
ied0
ied0
pos
-1
1
if (!iaxs[fr->callno]) {						break;					}
!iaxs[fr->callno]
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{						break;					}
break;
if (authdebug) {						char tmp1[256], tmp2[256];						ast_log(LOG_NOTICE, "Rejected call to %s, format %s incompatible with our capability %s.\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),							iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));					}
authdebug
authdebug
{						char tmp1[256], tmp2[256];						ast_log(LOG_NOTICE, "Rejected call to %s, format %s incompatible with our capability %s.\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),							iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));					}
char tmp1[256], tmp2[256];
char tmp1[256], tmp2[256];
char
tmp1[256]
tmp1
[256]
256
tmp2[256]
tmp2
[256]
256
ast_log(LOG_NOTICE, "Rejected call to %s, format %s incompatible with our capability %s.\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),							iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));
ast_log(LOG_NOTICE, "Rejected call to %s, format %s incompatible with our capability %s.\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),							iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability))
ast_log
ast_log
LOG_NOTICE
LOG_NOTICE
"Rejected call to %s, format %s incompatible with our capability %s.\n"
ast_inet_ntoa(sin.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
sin.sin_addr
sin
sin
sin_addr
iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp1
tmp1
sizeof(tmp1)
(tmp1)
tmp1
tmp1
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp2
tmp2
sizeof(tmp2)
(tmp2)
tmp2
tmp2
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
{					ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);					iax2_lock_owner(fr->callno);					if (iaxs[fr->callno] && iaxs[fr->callno]->owner) {						char tmp[256];						/* Switch us to use a compatible format */						ast_format_cap_from_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner), iaxs[fr->callno]->peerformat);						ast_verb(3, "Format for call is %s\n", ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(iaxs[fr->callno]->owner)));						/* Setup read/write formats properly. */						if (ast_channel_writeformat(iaxs[fr->callno]->owner)->id)							ast_set_write_format(iaxs[fr->callno]->owner, ast_channel_writeformat(iaxs[fr->callno]->owner));						if (ast_channel_readformat(iaxs[fr->callno]->owner)->id)							ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));						ast_channel_unlock(iaxs[fr->callno]->owner);					}				}
ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);
ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
ast_set_flag
ast_set_flag
&iaxs[fr->callno]->state
iaxs[fr->callno]->state
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
state
IAX_STATE_STARTED
IAX_STATE_STARTED
iax2_lock_owner(fr->callno);
iax2_lock_owner(fr->callno)
iax2_lock_owner
iax2_lock_owner
fr->callno
fr
fr
callno
if (iaxs[fr->callno] && iaxs[fr->callno]->owner) {						char tmp[256];						/* Switch us to use a compatible format */						ast_format_cap_from_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner), iaxs[fr->callno]->peerformat);						ast_verb(3, "Format for call is %s\n", ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(iaxs[fr->callno]->owner)));						/* Setup read/write formats properly. */						if (ast_channel_writeformat(iaxs[fr->callno]->owner)->id)							ast_set_write_format(iaxs[fr->callno]->owner, ast_channel_writeformat(iaxs[fr->callno]->owner));						if (ast_channel_readformat(iaxs[fr->callno]->owner)->id)							ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));						ast_channel_unlock(iaxs[fr->callno]->owner);					}
iaxs[fr->callno] && iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
{						char tmp[256];						/* Switch us to use a compatible format */						ast_format_cap_from_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner), iaxs[fr->callno]->peerformat);						ast_verb(3, "Format for call is %s\n", ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(iaxs[fr->callno]->owner)));						/* Setup read/write formats properly. */						if (ast_channel_writeformat(iaxs[fr->callno]->owner)->id)							ast_set_write_format(iaxs[fr->callno]->owner, ast_channel_writeformat(iaxs[fr->callno]->owner));						if (ast_channel_readformat(iaxs[fr->callno]->owner)->id)							ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));						ast_channel_unlock(iaxs[fr->callno]->owner);					}
char tmp[256];
char tmp[256];
char
tmp[256]
tmp
[256]
256
ast_format_cap_from_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner), iaxs[fr->callno]->peerformat);
ast_format_cap_from_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner), iaxs[fr->callno]->peerformat)
ast_format_cap_from_old_bitfield
ast_format_cap_from_old_bitfield
ast_channel_nativeformats(iaxs[fr->callno]->owner)
ast_channel_nativeformats
ast_channel_nativeformats
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
ast_verb(3, "Format for call is %s\n", ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(iaxs[fr->callno]->owner)));
ast_verb(3, "Format for call is %s\n", ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(iaxs[fr->callno]->owner)))
ast_verb
ast_verb
3
"Format for call is %s\n"
ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(iaxs[fr->callno]->owner))
ast_getformatname_multiple
ast_getformatname_multiple
tmp
tmp
sizeof(tmp)
(tmp)
tmp
tmp
ast_channel_nativeformats(iaxs[fr->callno]->owner)
ast_channel_nativeformats
ast_channel_nativeformats
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
if (ast_channel_writeformat(iaxs[fr->callno]->owner)->id)							ast_set_write_format(iaxs[fr->callno]->owner, ast_channel_writeformat(iaxs[fr->callno]->owner));
ast_channel_writeformat(iaxs[fr->callno]->owner)->id
ast_channel_writeformat(iaxs[fr->callno]->owner)
ast_channel_writeformat
ast_channel_writeformat
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
id
ast_set_write_format(iaxs[fr->callno]->owner, ast_channel_writeformat(iaxs[fr->callno]->owner));
ast_set_write_format(iaxs[fr->callno]->owner, ast_channel_writeformat(iaxs[fr->callno]->owner))
ast_set_write_format
ast_set_write_format
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
ast_channel_writeformat(iaxs[fr->callno]->owner)
ast_channel_writeformat
ast_channel_writeformat
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
if (ast_channel_readformat(iaxs[fr->callno]->owner)->id)							ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));
ast_channel_readformat(iaxs[fr->callno]->owner)->id
ast_channel_readformat(iaxs[fr->callno]->owner)
ast_channel_readformat
ast_channel_readformat
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
id
ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));
ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner))
ast_set_read_format
ast_set_read_format
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
ast_channel_readformat(iaxs[fr->callno]->owner)
ast_channel_readformat
ast_channel_readformat
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
ast_channel_unlock(iaxs[fr->callno]->owner);
ast_channel_unlock(iaxs[fr->callno]->owner)
ast_channel_unlock
ast_channel_unlock
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
if (iaxs[fr->callno]) {					AST_LIST_LOCK(&dpcache);					AST_LIST_TRAVERSE(&iaxs[fr->callno]->dpentries, dp, peer_list)						if (!(dp->flags & CACHE_FLAG_TRANSMITTED))							iax2_dprequest(dp, fr->callno);					AST_LIST_UNLOCK(&dpcache);				}
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{					AST_LIST_LOCK(&dpcache);					AST_LIST_TRAVERSE(&iaxs[fr->callno]->dpentries, dp, peer_list)						if (!(dp->flags & CACHE_FLAG_TRANSMITTED))							iax2_dprequest(dp, fr->callno);					AST_LIST_UNLOCK(&dpcache);				}
AST_LIST_LOCK(&dpcache);
AST_LIST_LOCK(&dpcache);
AST_LIST_LOCK
AST_LIST_LOCK
(&dpcache)
&dpcache
&
dpcache
AST_LIST_TRAVERSE(&iaxs[fr->callno]->dpentries, dp, peer_list)
AST_LIST_TRAVERSE(&iaxs[fr->callno]->dpentries, dp, peer_list)
AST_LIST_TRAVERSE
AST_LIST_TRAVERSE
&iaxs[fr->callno]->dpentries
iaxs[fr->callno]->dpentries
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
dpentries
dp
dp
peer_list
peer_list
)
if (!(dp->flags & CACHE_FLAG_TRANSMITTED))							iax2_dprequest(dp, fr->callno);
!(dp->flags & CACHE_FLAG_TRANSMITTED)
(dp->flags & CACHE_FLAG_TRANSMITTED)
dp->flags & CACHE_FLAG_TRANSMITTED
dp->flags
dp
dp
flags
CACHE_FLAG_TRANSMITTED
CACHE_FLAG_TRANSMITTED
iax2_dprequest(dp, fr->callno);
iax2_dprequest(dp, fr->callno)
iax2_dprequest
iax2_dprequest
dp
dp
fr->callno
fr
fr
callno
AST_LIST_UNLOCK(&dpcache);
AST_LIST_UNLOCK(&dpcache)
AST_LIST_UNLOCK
AST_LIST_UNLOCK
&dpcache
dpcache
dpcache
break;
case IAX_COMMAND_POKE:
IAX_COMMAND_POKE
IAX_COMMAND_POKE
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, NULL, 0, -1);
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, NULL, 0, -1)
send_command_final
send_command_final
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_PONG
IAX_COMMAND_PONG
fr->ts
fr
fr
ts
NULL
NULL
0
-1
1
break;
case IAX_COMMAND_PING:
IAX_COMMAND_PING
IAX_COMMAND_PING
{				struct iax_ie_data pingied;				construct_rr(iaxs[fr->callno], &pingied);				/* Send back a pong packet with the original timestamp */				send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, pingied.buf, pingied.pos, -1);			}
struct iax_ie_data pingied;
struct iax_ie_data pingied;
struct iax_ie_data
iax_ie_data
pingied
pingied
construct_rr(iaxs[fr->callno], &pingied);
construct_rr(iaxs[fr->callno], &pingied)
construct_rr
construct_rr
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
&pingied
pingied
pingied
send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, pingied.buf, pingied.pos, -1);
send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, pingied.buf, pingied.pos, -1)
send_command
send_command
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_PONG
IAX_COMMAND_PONG
fr->ts
fr
fr
ts
pingied.buf
pingied
pingied
buf
pingied.pos
pingied
pingied
pos
-1
1
break;
case IAX_COMMAND_PONG:
IAX_COMMAND_PONG
IAX_COMMAND_PONG
iaxs[fr->callno]->pingtime =  calc_timestamp(iaxs[fr->callno], 0, &f) - fr->ts;
iaxs[fr->callno]->pingtime =  calc_timestamp(iaxs[fr->callno], 0, &f) - fr->ts
iaxs[fr->callno]->pingtime
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
pingtime
calc_timestamp(iaxs[fr->callno], 0, &f) - fr->ts
calc_timestamp(iaxs[fr->callno], 0, &f)
calc_timestamp
calc_timestamp
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
0
&f
f
f
fr->ts
fr
fr
ts
save_rr(fr, &ies);
save_rr(fr, &ies)
save_rr
save_rr
fr
fr
&ies
ies
ies
log_jitterstats(fr->callno);
log_jitterstats(fr->callno)
log_jitterstats
log_jitterstats
fr->callno
fr
fr
callno
if (iaxs[fr->callno]->peerpoke) {					peer = iaxs[fr->callno]->peerpoke;					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms)) {						if (iaxs[fr->callno]->pingtime <= peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now REACHABLE! Time: %d\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Reachable\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_NOT_INUSE, "IAX2/%s", peer->name); /* Activate notification */						}					} else if ((peer->historicms > 0) && (peer->historicms <= peer->maxms)) {						if (iaxs[fr->callno]->pingtime > peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now TOO LAGGED (%d ms)!\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Lagged\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_UNAVAILABLE, "IAX2/%s", peer->name); /* Activate notification */						}					}					peer->lastms = iaxs[fr->callno]->pingtime;					if (peer->smoothing && (peer->lastms > -1))						peer->historicms = (iaxs[fr->callno]->pingtime + peer->historicms) / 2;					else if (peer->smoothing && peer->lastms < 0)						peer->historicms = (0 + peer->historicms) / 2;					else											peer->historicms = iaxs[fr->callno]->pingtime;					/* Remove scheduled iax2_poke_noanswer */					if (peer->pokeexpire > -1) {						if (!AST_SCHED_DEL(sched, peer->pokeexpire)) {							peer_unref(peer);							peer->pokeexpire = -1;						}					}					/* Schedule the next cycle */					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms))						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_peer_s, peer_ref(peer));					else						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqok, iax2_poke_peer_s, peer_ref(peer));					if (peer->pokeexpire == -1)						peer_unref(peer);					/* and finally send the ack */					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					/* And wrap up the qualify call */					iax2_destroy(fr->callno);					peer->callno = 0;					ast_debug(1, "Peer %s: got pong, lastms %d, historicms %d, maxms %d\n", peer->name, peer->lastms, peer->historicms, peer->maxms);				}
iaxs[fr->callno]->peerpoke
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerpoke
{					peer = iaxs[fr->callno]->peerpoke;					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms)) {						if (iaxs[fr->callno]->pingtime <= peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now REACHABLE! Time: %d\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Reachable\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_NOT_INUSE, "IAX2/%s", peer->name); /* Activate notification */						}					} else if ((peer->historicms > 0) && (peer->historicms <= peer->maxms)) {						if (iaxs[fr->callno]->pingtime > peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now TOO LAGGED (%d ms)!\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Lagged\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_UNAVAILABLE, "IAX2/%s", peer->name); /* Activate notification */						}					}					peer->lastms = iaxs[fr->callno]->pingtime;					if (peer->smoothing && (peer->lastms > -1))						peer->historicms = (iaxs[fr->callno]->pingtime + peer->historicms) / 2;					else if (peer->smoothing && peer->lastms < 0)						peer->historicms = (0 + peer->historicms) / 2;					else											peer->historicms = iaxs[fr->callno]->pingtime;					/* Remove scheduled iax2_poke_noanswer */					if (peer->pokeexpire > -1) {						if (!AST_SCHED_DEL(sched, peer->pokeexpire)) {							peer_unref(peer);							peer->pokeexpire = -1;						}					}					/* Schedule the next cycle */					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms))						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_peer_s, peer_ref(peer));					else						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqok, iax2_poke_peer_s, peer_ref(peer));					if (peer->pokeexpire == -1)						peer_unref(peer);					/* and finally send the ack */					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);					/* And wrap up the qualify call */					iax2_destroy(fr->callno);					peer->callno = 0;					ast_debug(1, "Peer %s: got pong, lastms %d, historicms %d, maxms %d\n", peer->name, peer->lastms, peer->historicms, peer->maxms);				}
peer = iaxs[fr->callno]->peerpoke;
peer = iaxs[fr->callno]->peerpoke
peer
peer
iaxs[fr->callno]->peerpoke
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerpoke
if ((peer->lastms < 0)  || (peer->historicms > peer->maxms)) {						if (iaxs[fr->callno]->pingtime <= peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now REACHABLE! Time: %d\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Reachable\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_NOT_INUSE, "IAX2/%s", peer->name); /* Activate notification */						}					} else if ((peer->historicms > 0) && (peer->historicms <= peer->maxms)) {						if (iaxs[fr->callno]->pingtime > peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now TOO LAGGED (%d ms)!\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Lagged\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_UNAVAILABLE, "IAX2/%s", peer->name); /* Activate notification */						}					}
(peer->lastms < 0)  || (peer->historicms > peer->maxms)
(peer->lastms < 0)
peer->lastms < 0
peer->lastms
peer
peer
lastms
0
(peer->historicms > peer->maxms)
peer->historicms > peer->maxms
peer->historicms
peer
peer
historicms
peer->maxms
peer
peer
maxms
{						if (iaxs[fr->callno]->pingtime <= peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now REACHABLE! Time: %d\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Reachable\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_NOT_INUSE, "IAX2/%s", peer->name); /* Activate notification */						}					}
if (iaxs[fr->callno]->pingtime <= peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now REACHABLE! Time: %d\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Reachable\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_NOT_INUSE, "IAX2/%s", peer->name); /* Activate notification */						}
iaxs[fr->callno]->pingtime <= peer->maxms
iaxs[fr->callno]->pingtime
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
pingtime
peer->maxms
peer
peer
maxms
{							ast_log(LOG_NOTICE, "Peer '%s' is now REACHABLE! Time: %d\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Reachable\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_NOT_INUSE, "IAX2/%s", peer->name); /* Activate notification */						}
ast_log(LOG_NOTICE, "Peer '%s' is now REACHABLE! Time: %d\n", peer->name, iaxs[fr->callno]->pingtime);
ast_log(LOG_NOTICE, "Peer '%s' is now REACHABLE! Time: %d\n", peer->name, iaxs[fr->callno]->pingtime)
ast_log
ast_log
LOG_NOTICE
LOG_NOTICE
"Peer '%s' is now REACHABLE! Time: %d\n"
peer->name
peer
peer
name
iaxs[fr->callno]->pingtime
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
pingtime
manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Reachable\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime);
manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Reachable\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime)
manager_event
manager_event
EVENT_FLAG_SYSTEM
EVENT_FLAG_SYSTEM
"PeerStatus"
"ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Reachable\r\nTime: %d\r\n"
peer->name
peer
peer
name
iaxs[fr->callno]->pingtime
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
pingtime
ast_devstate_changed(AST_DEVICE_NOT_INUSE, "IAX2/%s", peer->name);
ast_devstate_changed(AST_DEVICE_NOT_INUSE, "IAX2/%s", peer->name)
ast_devstate_changed
ast_devstate_changed
AST_DEVICE_NOT_INUSE
AST_DEVICE_NOT_INUSE
"IAX2/%s"
peer->name
peer
peer
name
if ((peer->historicms > 0) && (peer->historicms <= peer->maxms)) {						if (iaxs[fr->callno]->pingtime > peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now TOO LAGGED (%d ms)!\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Lagged\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_UNAVAILABLE, "IAX2/%s", peer->name); /* Activate notification */						}					}
(peer->historicms > 0) && (peer->historicms <= peer->maxms)
(peer->historicms > 0)
peer->historicms > 0
peer->historicms
peer
peer
historicms
0
(peer->historicms <= peer->maxms)
peer->historicms <= peer->maxms
peer->historicms
peer
peer
historicms
peer->maxms
peer
peer
maxms
{						if (iaxs[fr->callno]->pingtime > peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now TOO LAGGED (%d ms)!\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Lagged\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_UNAVAILABLE, "IAX2/%s", peer->name); /* Activate notification */						}					}
if (iaxs[fr->callno]->pingtime > peer->maxms) {							ast_log(LOG_NOTICE, "Peer '%s' is now TOO LAGGED (%d ms)!\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Lagged\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_UNAVAILABLE, "IAX2/%s", peer->name); /* Activate notification */						}
iaxs[fr->callno]->pingtime > peer->maxms
iaxs[fr->callno]->pingtime
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
pingtime
peer->maxms
peer
peer
maxms
{							ast_log(LOG_NOTICE, "Peer '%s' is now TOO LAGGED (%d ms)!\n", peer->name, iaxs[fr->callno]->pingtime);							manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Lagged\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime); 							ast_devstate_changed(AST_DEVICE_UNAVAILABLE, "IAX2/%s", peer->name); /* Activate notification */						}
ast_log(LOG_NOTICE, "Peer '%s' is now TOO LAGGED (%d ms)!\n", peer->name, iaxs[fr->callno]->pingtime);
ast_log(LOG_NOTICE, "Peer '%s' is now TOO LAGGED (%d ms)!\n", peer->name, iaxs[fr->callno]->pingtime)
ast_log
ast_log
LOG_NOTICE
LOG_NOTICE
"Peer '%s' is now TOO LAGGED (%d ms)!\n"
peer->name
peer
peer
name
iaxs[fr->callno]->pingtime
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
pingtime
manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Lagged\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime);
manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Lagged\r\nTime: %d\r\n", peer->name, iaxs[fr->callno]->pingtime)
manager_event
manager_event
EVENT_FLAG_SYSTEM
EVENT_FLAG_SYSTEM
"PeerStatus"
"ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Lagged\r\nTime: %d\r\n"
peer->name
peer
peer
name
iaxs[fr->callno]->pingtime
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
pingtime
ast_devstate_changed(AST_DEVICE_UNAVAILABLE, "IAX2/%s", peer->name);
ast_devstate_changed(AST_DEVICE_UNAVAILABLE, "IAX2/%s", peer->name)
ast_devstate_changed
ast_devstate_changed
AST_DEVICE_UNAVAILABLE
AST_DEVICE_UNAVAILABLE
"IAX2/%s"
peer->name
peer
peer
name
peer->lastms = iaxs[fr->callno]->pingtime;
peer->lastms = iaxs[fr->callno]->pingtime
peer->lastms
peer
peer
lastms
iaxs[fr->callno]->pingtime
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
pingtime
if (peer->smoothing && (peer->lastms > -1))						peer->historicms = (iaxs[fr->callno]->pingtime + peer->historicms) / 2;					else if (peer->smoothing && peer->lastms < 0)						peer->historicms = (0 + peer->historicms) / 2;					else											peer->historicms = iaxs[fr->callno]->pingtime;
peer->smoothing && (peer->lastms > -1)
peer->smoothing
peer
peer
smoothing
(peer->lastms > -1)
peer->lastms > -1
peer->lastms
peer
peer
lastms
-1
1
peer->historicms = (iaxs[fr->callno]->pingtime + peer->historicms) / 2;
peer->historicms = (iaxs[fr->callno]->pingtime + peer->historicms) / 2
peer->historicms
peer
peer
historicms
(iaxs[fr->callno]->pingtime + peer->historicms) / 2
(iaxs[fr->callno]->pingtime + peer->historicms)
iaxs[fr->callno]->pingtime + peer->historicms
iaxs[fr->callno]->pingtime
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
pingtime
peer->historicms
peer
peer
historicms
2
if (peer->smoothing && peer->lastms < 0)						peer->historicms = (0 + peer->historicms) / 2;					else											peer->historicms = iaxs[fr->callno]->pingtime;
peer->smoothing && peer->lastms < 0
peer->smoothing
peer
peer
smoothing
peer->lastms < 0
peer->lastms
peer
peer
lastms
0
peer->historicms = (0 + peer->historicms) / 2;
peer->historicms = (0 + peer->historicms) / 2
peer->historicms
peer
peer
historicms
(0 + peer->historicms) / 2
(0 + peer->historicms)
0 + peer->historicms
0
peer->historicms
peer
peer
historicms
2
peer->historicms = iaxs[fr->callno]->pingtime;
peer->historicms = iaxs[fr->callno]->pingtime
peer->historicms
peer
peer
historicms
iaxs[fr->callno]->pingtime
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
pingtime
if (peer->pokeexpire > -1) {						if (!AST_SCHED_DEL(sched, peer->pokeexpire)) {							peer_unref(peer);							peer->pokeexpire = -1;						}					}
peer->pokeexpire > -1
peer->pokeexpire
peer
peer
pokeexpire
-1
1
{						if (!AST_SCHED_DEL(sched, peer->pokeexpire)) {							peer_unref(peer);							peer->pokeexpire = -1;						}					}
if (!AST_SCHED_DEL(sched, peer->pokeexpire)) {							peer_unref(peer);							peer->pokeexpire = -1;						}
!AST_SCHED_DEL(sched, peer->pokeexpire)
AST_SCHED_DEL(sched, peer->pokeexpire)
AST_SCHED_DEL
AST_SCHED_DEL
sched
sched
peer->pokeexpire
peer
peer
pokeexpire
{							peer_unref(peer);							peer->pokeexpire = -1;						}
peer_unref(peer);
peer_unref(peer)
peer_unref
peer_unref
peer
peer
peer->pokeexpire = -1;
peer->pokeexpire = -1
peer->pokeexpire
peer
peer
pokeexpire
-1
1
if ((peer->lastms < 0)  || (peer->historicms > peer->maxms))						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_peer_s, peer_ref(peer));					else						peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqok, iax2_poke_peer_s, peer_ref(peer));
(peer->lastms < 0)  || (peer->historicms > peer->maxms)
(peer->lastms < 0)
peer->lastms < 0
peer->lastms
peer
peer
lastms
0
(peer->historicms > peer->maxms)
peer->historicms > peer->maxms
peer->historicms
peer
peer
historicms
peer->maxms
peer
peer
maxms
peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_peer_s, peer_ref(peer));
peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_peer_s, peer_ref(peer))
peer->pokeexpire
peer
peer
pokeexpire
iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_peer_s, peer_ref(peer))
iax2_sched_add
iax2_sched_add
sched
sched
peer->pokefreqnotok
peer
peer
pokefreqnotok
iax2_poke_peer_s
iax2_poke_peer_s
peer_ref(peer)
peer_ref
peer_ref
peer
peer
peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqok, iax2_poke_peer_s, peer_ref(peer));
peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqok, iax2_poke_peer_s, peer_ref(peer))
peer->pokeexpire
peer
peer
pokeexpire
iax2_sched_add(sched, peer->pokefreqok, iax2_poke_peer_s, peer_ref(peer))
iax2_sched_add
iax2_sched_add
sched
sched
peer->pokefreqok
peer
peer
pokefreqok
iax2_poke_peer_s
iax2_poke_peer_s
peer_ref(peer)
peer_ref
peer_ref
peer
peer
if (peer->pokeexpire == -1)						peer_unref(peer);
peer->pokeexpire == -1
peer->pokeexpire
peer
peer
pokeexpire
-1
1
peer_unref(peer);
peer_unref(peer)
peer_unref
peer_unref
peer
peer
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
send_command_immediate
send_command_immediate
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_ACK
IAX_COMMAND_ACK
fr->ts
fr
fr
ts
NULL
NULL
0
fr->iseqno
fr
fr
iseqno
iax2_destroy(fr->callno);
iax2_destroy(fr->callno)
iax2_destroy
iax2_destroy
fr->callno
fr
fr
callno
peer->callno = 0;
peer->callno = 0
peer->callno
peer
peer
callno
0
ast_debug(1, "Peer %s: got pong, lastms %d, historicms %d, maxms %d\n", peer->name, peer->lastms, peer->historicms, peer->maxms);
ast_debug(1, "Peer %s: got pong, lastms %d, historicms %d, maxms %d\n", peer->name, peer->lastms, peer->historicms, peer->maxms)
ast_debug
ast_debug
1
"Peer %s: got pong, lastms %d, historicms %d, maxms %d\n"
peer->name
peer
peer
name
peer->lastms
peer
peer
lastms
peer->historicms
peer
peer
historicms
peer->maxms
peer
peer
maxms
break;
case IAX_COMMAND_LAGRQ:
IAX_COMMAND_LAGRQ
IAX_COMMAND_LAGRQ
case IAX_COMMAND_LAGRP:
IAX_COMMAND_LAGRP
IAX_COMMAND_LAGRP
f.src = "LAGRQ";
f.src = "LAGRQ"
f.src
f
f
src
"LAGRQ"
f.mallocd = 0;
f.mallocd = 0
f.mallocd
f
f
mallocd
0
f.offset = 0;
f.offset = 0
f.offset
f
f
offset
0
f.samples = 0;
f.samples = 0
f.samples
f
f
samples
0
iax_frame_wrap(fr, &f);
iax_frame_wrap(fr, &f)
iax_frame_wrap
iax_frame_wrap
fr
fr
&f
f
f
if (f.subclass.integer == IAX_COMMAND_LAGRQ) {					/* Received a LAGRQ - echo back a LAGRP */					fr->af.subclass.integer = IAX_COMMAND_LAGRP;					iax2_send(iaxs[fr->callno], &fr->af, fr->ts, -1, 0, 0, 0);				} else {					/* Received LAGRP in response to our LAGRQ */					unsigned int ts;					/* This is a reply we've been given, actually measure the difference */					ts = calc_timestamp(iaxs[fr->callno], 0, &fr->af);					iaxs[fr->callno]->lag = ts - fr->ts;					if (iaxdebug)						ast_debug(1, "Peer %s lag measured as %dms\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->lag);				}
f.subclass.integer == IAX_COMMAND_LAGRQ
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_LAGRQ
IAX_COMMAND_LAGRQ
{					/* Received a LAGRQ - echo back a LAGRP */					fr->af.subclass.integer = IAX_COMMAND_LAGRP;					iax2_send(iaxs[fr->callno], &fr->af, fr->ts, -1, 0, 0, 0);				}
fr->af.subclass.integer = IAX_COMMAND_LAGRP;
fr->af.subclass.integer = IAX_COMMAND_LAGRP
fr->af.subclass.integer
fr->af.subclass
fr->af
fr
fr
af
subclass
integer
IAX_COMMAND_LAGRP
IAX_COMMAND_LAGRP
iax2_send(iaxs[fr->callno], &fr->af, fr->ts, -1, 0, 0, 0);
iax2_send(iaxs[fr->callno], &fr->af, fr->ts, -1, 0, 0, 0)
iax2_send
iax2_send
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
&fr->af
fr->af
fr
fr
af
fr->ts
fr
fr
ts
-1
1
0
0
0
{					/* Received LAGRP in response to our LAGRQ */					unsigned int ts;					/* This is a reply we've been given, actually measure the difference */					ts = calc_timestamp(iaxs[fr->callno], 0, &fr->af);					iaxs[fr->callno]->lag = ts - fr->ts;					if (iaxdebug)						ast_debug(1, "Peer %s lag measured as %dms\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->lag);				}
unsigned int ts;
unsigned int ts;
unsigned int
ts
ts
ts = calc_timestamp(iaxs[fr->callno], 0, &fr->af);
ts = calc_timestamp(iaxs[fr->callno], 0, &fr->af)
ts
ts
calc_timestamp(iaxs[fr->callno], 0, &fr->af)
calc_timestamp
calc_timestamp
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
0
&fr->af
fr->af
fr
fr
af
iaxs[fr->callno]->lag = ts - fr->ts;
iaxs[fr->callno]->lag = ts - fr->ts
iaxs[fr->callno]->lag
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
lag
ts - fr->ts
ts
ts
fr->ts
fr
fr
ts
if (iaxdebug)						ast_debug(1, "Peer %s lag measured as %dms\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->lag);
iaxdebug
iaxdebug
ast_debug(1, "Peer %s lag measured as %dms\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->lag);
ast_debug(1, "Peer %s lag measured as %dms\n",							ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->lag)
ast_debug
ast_debug
1
"Peer %s lag measured as %dms\n"
ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
iaxs[fr->callno]->addr.sin_addr
iaxs[fr->callno]->addr
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
addr
sin_addr
iaxs[fr->callno]->lag
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
lag
break;
case IAX_COMMAND_AUTHREQ:
IAX_COMMAND_AUTHREQ
IAX_COMMAND_AUTHREQ
if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)) {					ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					break;				}
ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)
ast_test_flag
ast_test_flag
&iaxs[fr->callno]->state
iaxs[fr->callno]->state
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
state
IAX_STATE_STARTED | IAX_STATE_TBD
IAX_STATE_STARTED
IAX_STATE_STARTED
IAX_STATE_TBD
IAX_STATE_TBD
{					ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					break;				}
ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");
ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>")
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"Call on %s is already up, can't start on it\n"
iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>"
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
ast_channel_name(iaxs[fr->callno]->owner)
ast_channel_name
ast_channel_name
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
"<Unknown>"
break;
if (authenticate_reply(iaxs[fr->callno], &iaxs[fr->callno]->addr, &ies, iaxs[fr->callno]->secret, iaxs[fr->callno]->outkey)) {					struct ast_frame hangup_fr = { .frametype = AST_FRAME_CONTROL,								.subclass.integer = AST_CONTROL_HANGUP,					}
authenticate_reply(iaxs[fr->callno], &iaxs[fr->callno]->addr, &ies, iaxs[fr->callno]->secret, iaxs[fr->callno]->outkey)
authenticate_reply
authenticate_reply
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
&iaxs[fr->callno]->addr
iaxs[fr->callno]->addr
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
addr
&ies
ies
ies
iaxs[fr->callno]->secret
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
secret
iaxs[fr->callno]->outkey
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
outkey
{					struct ast_frame hangup_fr = { .frametype = AST_FRAME_CONTROL,								.subclass.integer = AST_CONTROL_HANGUP,					}
struct ast_frame hangup_fr = { .frametype = AST_FRAME_CONTROL,								.subclass.integer = AST_CONTROL_HANGUP,
;
ast_log(LOG_WARNING, 						"I don't know how to authenticate %s to %s\n", 						ies.username ? ies.username : "<unknown>", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr));
ast_log(LOG_WARNING, 						"I don't know how to authenticate %s to %s\n", 						ies.username ? ies.username : "<unknown>", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr))
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"I don't know how to authenticate %s to %s\n"
ies.username ? ies.username : "<unknown>"
ies.username
ies
ies
username
ies.username
ies
ies
username
"<unknown>"
ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
iaxs[fr->callno]->addr.sin_addr
iaxs[fr->callno]->addr
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
addr
sin_addr
iax2_queue_frame(fr->callno, &hangup_fr);
iax2_queue_frame(fr->callno, &hangup_fr)
iax2_queue_frame
iax2_queue_frame
fr->callno
fr
fr
callno
&hangup_fr
hangup_fr
hangup_fr
break;
case IAX_COMMAND_AUTHREP:
IAX_COMMAND_AUTHREP
IAX_COMMAND_AUTHREP
if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
delayreject
delayreject
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
send_command_immediate
send_command_immediate
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_ACK
IAX_COMMAND_ACK
fr->ts
fr
fr
ts
NULL
NULL
0
fr->iseqno
fr
fr
iseqno
if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)) {					ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					break;				}
ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)
ast_test_flag
ast_test_flag
&iaxs[fr->callno]->state
iaxs[fr->callno]->state
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
state
IAX_STATE_STARTED | IAX_STATE_TBD
IAX_STATE_STARTED
IAX_STATE_STARTED
IAX_STATE_TBD
IAX_STATE_TBD
{					ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					break;				}
ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");
ast_log(LOG_WARNING, "Call on %s is already up, can't start on it\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>")
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"Call on %s is already up, can't start on it\n"
iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>"
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
ast_channel_name(iaxs[fr->callno]->owner)
ast_channel_name
ast_channel_name
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
"<Unknown>"
break;
if (authenticate_verify(iaxs[fr->callno], &ies)) {					if (authdebug)						ast_log(LOG_NOTICE, "Host %s failed to authenticate as %s\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->username);					memset(&ied0, 0, sizeof(ied0));					auth_fail(fr->callno, IAX_COMMAND_REJECT);					break;				}
authenticate_verify(iaxs[fr->callno], &ies)
authenticate_verify
authenticate_verify
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
&ies
ies
ies
{					if (authdebug)						ast_log(LOG_NOTICE, "Host %s failed to authenticate as %s\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->username);					memset(&ied0, 0, sizeof(ied0));					auth_fail(fr->callno, IAX_COMMAND_REJECT);					break;				}
if (authdebug)						ast_log(LOG_NOTICE, "Host %s failed to authenticate as %s\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->username);
authdebug
authdebug
ast_log(LOG_NOTICE, "Host %s failed to authenticate as %s\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->username);
ast_log(LOG_NOTICE, "Host %s failed to authenticate as %s\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr), iaxs[fr->callno]->username)
ast_log
ast_log
LOG_NOTICE
LOG_NOTICE
"Host %s failed to authenticate as %s\n"
ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
iaxs[fr->callno]->addr.sin_addr
iaxs[fr->callno]->addr
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
addr
sin_addr
iaxs[fr->callno]->username
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
username
memset(&ied0, 0, sizeof(ied0));
memset(&ied0, 0, sizeof(ied0))
memset
memset
&ied0
ied0
ied0
0
sizeof(ied0)
(ied0)
ied0
ied0
auth_fail(fr->callno, IAX_COMMAND_REJECT);
auth_fail(fr->callno, IAX_COMMAND_REJECT)
auth_fail
auth_fail
fr->callno
fr
fr
callno
IAX_COMMAND_REJECT
IAX_COMMAND_REJECT
break;
if (strcasecmp(iaxs[fr->callno]->exten, "TBD")) {					/* This might re-enter the IAX code and need the lock */					exists = ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num);				} else					exists = 0;
strcasecmp(iaxs[fr->callno]->exten, "TBD")
strcasecmp
strcasecmp
iaxs[fr->callno]->exten
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
exten
"TBD"
{					/* This might re-enter the IAX code and need the lock */					exists = ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num);				}
exists = ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num);
exists = ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num)
exists
exists
ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num)
ast_exists_extension
ast_exists_extension
NULL
NULL
iaxs[fr->callno]->context
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
context
iaxs[fr->callno]->exten
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
exten
1
iaxs[fr->callno]->cid_num
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
cid_num
exists = 0;
exists = 0
exists
exists
0
if (strcmp(iaxs[fr->callno]->exten, "TBD") && !exists) {					if (authdebug)						ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);					if (!iaxs[fr->callno]) {						break;					}				} else {					/* Select an appropriate format */					if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {							using_prefs = "reqonly";						} else {							using_prefs = "disabled";						}						format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;						memset(&pref, 0, sizeof(pref));						strcpy(caller_pref_buf, "disabled");						strcpy(host_pref_buf, "disabled");					} else {						struct ast_format tmpfmt;						using_prefs = "mine";						if (ies.codec_prefs)							ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);						if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {							if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {								pref = iaxs[fr->callno]->rprefs;								using_prefs = "caller";							} else {								pref = iaxs[fr->callno]->prefs;							}						} else /* if no codec_prefs IE do it the old way */							pref = iaxs[fr->callno]->prefs;						format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);						ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);						ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);					}					if (!format) {						char tmp1[256], tmp2[256], tmp3[256];						if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {							ast_debug(1, "We don't do requested format %s, falling back to peer capability '%s'\n",								iax2_getformatname(iaxs[fr->callno]->peerformat),								iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability));							format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;						}						if (!format) {							if (authdebug) {								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n", ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));								} else {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",										ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),										iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));								}							}							memset(&ied0, 0, sizeof(ied0));							iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");							iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);							send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);							if (!iaxs[fr->callno]) {								break;							}						} else {							/* Pick one... */							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))									format = 0;							} else {								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {									using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";									memset(&pref, 0, sizeof(pref));									format = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ?										iaxs[fr->callno]->peerformat : iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									strcpy(caller_pref_buf,"disabled");									strcpy(host_pref_buf,"disabled");								} else {									struct ast_format tmpfmt;									using_prefs = "mine";									if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {										/* Do the opposite of what we tried above. */										if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {											pref = iaxs[fr->callno]->prefs;										} else {											pref = iaxs[fr->callno]->rprefs;											using_prefs = "caller";										}										format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);									} else /* if no codec_prefs IE do it the old way */										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}							}							if (!format) {								char tmp1[256], tmp2[256], tmp3[256];								ast_log(LOG_ERROR, "No best format in %s???\n",									iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));								if (authdebug) {									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}							}						}					}					if (format) {						/* Authentication received */						memset(&ied1, 0, sizeof(ied1));						iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);						iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);						send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);						if (strcmp(iaxs[fr->callno]->exten, "TBD")) {							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							ast_verb(3, "Accepting AUTHENTICATED call from %s:\n"											"%srequested format = %s,\n"											"%srequested prefs = %s,\n"											"%sactual format = %s,\n"											"%shost prefs = %s,\n"											"%spriority = %s\n", 											ast_inet_ntoa(sin.sin_addr), 											VERBOSE_PREFIX_4,											iax2_getformatname(iaxs[fr->callno]->peerformat),											VERBOSE_PREFIX_4,											caller_pref_buf,											VERBOSE_PREFIX_4,											iax2_getformatname(format),											VERBOSE_PREFIX_4,											host_pref_buf,											VERBOSE_PREFIX_4,											using_prefs);							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, format, NULL)))								iax2_destroy(fr->callno);							else if (ies.vars) {								struct ast_datastore *variablestore;								struct ast_variable *var, *prev = NULL;								AST_LIST_HEAD(, ast_var_t) *varlist;								varlist = ast_calloc(1, sizeof(*varlist));								variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);								if (variablestore && varlist) {									variablestore->data = varlist;									variablestore->inheritance = DATASTORE_INHERIT_FOREVER;									AST_LIST_HEAD_INIT(varlist);									ast_debug(1, "I can haz IAX vars? w00t\n");									for (var = ies.vars; var; var = var->next) {										struct ast_var_t *newvar = ast_var_assign(var->name, var->value);										if (prev)											ast_free(prev);										prev = var;										if (!newvar) {											/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */											ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");										} else {											AST_LIST_INSERT_TAIL(varlist, newvar, entries);										}									}									if (prev)										ast_free(prev);									ies.vars = NULL;									ast_channel_datastore_add(c, variablestore);								} else {									ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									if (variablestore)										ast_datastore_free(variablestore);									if (varlist)										ast_free(varlist);								}							}						} else {							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);							/* If this is a TBD call, we're ready but now what...  */							ast_verb(3, "Accepted AUTHENTICATED TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							if (ast_test_flag64(iaxs[fr->callno], IAX_IMMEDIATE)) {								goto immediatedial;							}						}					}				}
strcmp(iaxs[fr->callno]->exten, "TBD") && !exists
strcmp(iaxs[fr->callno]->exten, "TBD")
strcmp
strcmp
iaxs[fr->callno]->exten
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
exten
"TBD"
!exists
exists
exists
{					if (authdebug)						ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);					if (!iaxs[fr->callno]) {						break;					}				}
if (authdebug)						ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);
authdebug
authdebug
ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);
ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context)
ast_log
ast_log
LOG_NOTICE
LOG_NOTICE
"Rejected connect attempt from %s, request '%s@%s' does not exist\n"
ast_inet_ntoa(sin.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
sin.sin_addr
sin
sin
sin_addr
iaxs[fr->callno]->exten
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
exten
iaxs[fr->callno]->context
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
context
memset(&ied0, 0, sizeof(ied0));
memset(&ied0, 0, sizeof(ied0))
memset
memset
&ied0
ied0
ied0
0
sizeof(ied0)
(ied0)
ied0
ied0
iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");
iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension")
iax_ie_append_str
iax_ie_append_str
&ied0
ied0
ied0
IAX_IE_CAUSE
IAX_IE_CAUSE
"No such context/extension"
iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);
iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION)
iax_ie_append_byte
iax_ie_append_byte
&ied0
ied0
ied0
IAX_IE_CAUSECODE
IAX_IE_CAUSECODE
AST_CAUSE_NO_ROUTE_DESTINATION
AST_CAUSE_NO_ROUTE_DESTINATION
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1)
send_command_final
send_command_final
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_REJECT
IAX_COMMAND_REJECT
0
ied0.buf
ied0
ied0
buf
ied0.pos
ied0
ied0
pos
-1
1
if (!iaxs[fr->callno]) {						break;					}
!iaxs[fr->callno]
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{						break;					}
break;
{					/* Select an appropriate format */					if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {							using_prefs = "reqonly";						} else {							using_prefs = "disabled";						}						format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;						memset(&pref, 0, sizeof(pref));						strcpy(caller_pref_buf, "disabled");						strcpy(host_pref_buf, "disabled");					} else {						struct ast_format tmpfmt;						using_prefs = "mine";						if (ies.codec_prefs)							ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);						if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {							if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {								pref = iaxs[fr->callno]->rprefs;								using_prefs = "caller";							} else {								pref = iaxs[fr->callno]->prefs;							}						} else /* if no codec_prefs IE do it the old way */							pref = iaxs[fr->callno]->prefs;						format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);						ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);						ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);					}					if (!format) {						char tmp1[256], tmp2[256], tmp3[256];						if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {							ast_debug(1, "We don't do requested format %s, falling back to peer capability '%s'\n",								iax2_getformatname(iaxs[fr->callno]->peerformat),								iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability));							format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;						}						if (!format) {							if (authdebug) {								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n", ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));								} else {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",										ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),										iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));								}							}							memset(&ied0, 0, sizeof(ied0));							iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");							iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);							send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);							if (!iaxs[fr->callno]) {								break;							}						} else {							/* Pick one... */							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))									format = 0;							} else {								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {									using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";									memset(&pref, 0, sizeof(pref));									format = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ?										iaxs[fr->callno]->peerformat : iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									strcpy(caller_pref_buf,"disabled");									strcpy(host_pref_buf,"disabled");								} else {									struct ast_format tmpfmt;									using_prefs = "mine";									if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {										/* Do the opposite of what we tried above. */										if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {											pref = iaxs[fr->callno]->prefs;										} else {											pref = iaxs[fr->callno]->rprefs;											using_prefs = "caller";										}										format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);									} else /* if no codec_prefs IE do it the old way */										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}							}							if (!format) {								char tmp1[256], tmp2[256], tmp3[256];								ast_log(LOG_ERROR, "No best format in %s???\n",									iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));								if (authdebug) {									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}							}						}					}					if (format) {						/* Authentication received */						memset(&ied1, 0, sizeof(ied1));						iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);						iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);						send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);						if (strcmp(iaxs[fr->callno]->exten, "TBD")) {							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							ast_verb(3, "Accepting AUTHENTICATED call from %s:\n"											"%srequested format = %s,\n"											"%srequested prefs = %s,\n"											"%sactual format = %s,\n"											"%shost prefs = %s,\n"											"%spriority = %s\n", 											ast_inet_ntoa(sin.sin_addr), 											VERBOSE_PREFIX_4,											iax2_getformatname(iaxs[fr->callno]->peerformat),											VERBOSE_PREFIX_4,											caller_pref_buf,											VERBOSE_PREFIX_4,											iax2_getformatname(format),											VERBOSE_PREFIX_4,											host_pref_buf,											VERBOSE_PREFIX_4,											using_prefs);							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, format, NULL)))								iax2_destroy(fr->callno);							else if (ies.vars) {								struct ast_datastore *variablestore;								struct ast_variable *var, *prev = NULL;								AST_LIST_HEAD(, ast_var_t) *varlist;								varlist = ast_calloc(1, sizeof(*varlist));								variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);								if (variablestore && varlist) {									variablestore->data = varlist;									variablestore->inheritance = DATASTORE_INHERIT_FOREVER;									AST_LIST_HEAD_INIT(varlist);									ast_debug(1, "I can haz IAX vars? w00t\n");									for (var = ies.vars; var; var = var->next) {										struct ast_var_t *newvar = ast_var_assign(var->name, var->value);										if (prev)											ast_free(prev);										prev = var;										if (!newvar) {											/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */											ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");										} else {											AST_LIST_INSERT_TAIL(varlist, newvar, entries);										}									}									if (prev)										ast_free(prev);									ies.vars = NULL;									ast_channel_datastore_add(c, variablestore);								} else {									ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									if (variablestore)										ast_datastore_free(variablestore);									if (varlist)										ast_free(varlist);								}							}						} else {							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);							/* If this is a TBD call, we're ready but now what...  */							ast_verb(3, "Accepted AUTHENTICATED TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							if (ast_test_flag64(iaxs[fr->callno], IAX_IMMEDIATE)) {								goto immediatedial;							}						}					}				}
if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {							using_prefs = "reqonly";						} else {							using_prefs = "disabled";						}						format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;						memset(&pref, 0, sizeof(pref));						strcpy(caller_pref_buf, "disabled");						strcpy(host_pref_buf, "disabled");					} else {						struct ast_format tmpfmt;						using_prefs = "mine";						if (ies.codec_prefs)							ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);						if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {							if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {								pref = iaxs[fr->callno]->rprefs;								using_prefs = "caller";							} else {								pref = iaxs[fr->callno]->prefs;							}						} else /* if no codec_prefs IE do it the old way */							pref = iaxs[fr->callno]->prefs;						format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);						ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);						ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);					}
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_CODEC_NOPREFS
IAX_CODEC_NOPREFS
{						if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {							using_prefs = "reqonly";						} else {							using_prefs = "disabled";						}						format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;						memset(&pref, 0, sizeof(pref));						strcpy(caller_pref_buf, "disabled");						strcpy(host_pref_buf, "disabled");					}
if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {							using_prefs = "reqonly";						} else {							using_prefs = "disabled";						}
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_CODEC_NOCAP
IAX_CODEC_NOCAP
{							using_prefs = "reqonly";						}
using_prefs = "reqonly";
using_prefs = "reqonly"
using_prefs
using_prefs
"reqonly"
{							using_prefs = "disabled";						}
using_prefs = "disabled";
using_prefs = "disabled"
using_prefs
using_prefs
"disabled"
format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability;
format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability
format
format
iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
memset(&pref, 0, sizeof(pref));
memset(&pref, 0, sizeof(pref))
memset
memset
&pref
pref
pref
0
sizeof(pref)
(pref)
pref
pref
strcpy(caller_pref_buf, "disabled");
strcpy(caller_pref_buf, "disabled")
strcpy
strcpy
caller_pref_buf
caller_pref_buf
"disabled"
strcpy(host_pref_buf, "disabled");
strcpy(host_pref_buf, "disabled")
strcpy
strcpy
host_pref_buf
host_pref_buf
"disabled"
{						struct ast_format tmpfmt;						using_prefs = "mine";						if (ies.codec_prefs)							ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);						if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {							if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {								pref = iaxs[fr->callno]->rprefs;								using_prefs = "caller";							} else {								pref = iaxs[fr->callno]->prefs;							}						} else /* if no codec_prefs IE do it the old way */							pref = iaxs[fr->callno]->prefs;						format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);						ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);						ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);					}
struct ast_format tmpfmt;
struct ast_format tmpfmt;
struct ast_format
ast_format
tmpfmt
tmpfmt
using_prefs = "mine";
using_prefs = "mine"
using_prefs
using_prefs
"mine"
if (ies.codec_prefs)							ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);
ies.codec_prefs
ies
ies
codec_prefs
ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0);
ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0)
ast_codec_pref_convert
ast_codec_pref_convert
&iaxs[fr->callno]->rprefs
iaxs[fr->callno]->rprefs
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
rprefs
ies.codec_prefs
ies
ies
codec_prefs
32
0
if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {							if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {								pref = iaxs[fr->callno]->rprefs;								using_prefs = "caller";							} else {								pref = iaxs[fr->callno]->prefs;							}						} else /* if no codec_prefs IE do it the old way */							pref = iaxs[fr->callno]->prefs;
ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)
ast_codec_pref_index
ast_codec_pref_index
&iaxs[fr->callno]->rprefs
iaxs[fr->callno]->rprefs
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
rprefs
0
&tmpfmt
tmpfmt
tmpfmt
{							if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {								pref = iaxs[fr->callno]->rprefs;								using_prefs = "caller";							} else {								pref = iaxs[fr->callno]->prefs;							}						}
if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {								pref = iaxs[fr->callno]->rprefs;								using_prefs = "caller";							} else {								pref = iaxs[fr->callno]->prefs;							}
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_CODEC_USER_FIRST
IAX_CODEC_USER_FIRST
{								pref = iaxs[fr->callno]->rprefs;								using_prefs = "caller";							}
pref = iaxs[fr->callno]->rprefs;
pref = iaxs[fr->callno]->rprefs
pref
pref
iaxs[fr->callno]->rprefs
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
rprefs
using_prefs = "caller";
using_prefs = "caller"
using_prefs
using_prefs
"caller"
{								pref = iaxs[fr->callno]->prefs;							}
pref = iaxs[fr->callno]->prefs;
pref = iaxs[fr->callno]->prefs
pref
pref
iaxs[fr->callno]->prefs
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
prefs
pref = iaxs[fr->callno]->prefs;
pref = iaxs[fr->callno]->prefs
pref
pref
iaxs[fr->callno]->prefs
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
prefs
format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0);
format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0)
format
format
iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0)
iax2_codec_choose
iax2_codec_choose
&pref
pref
pref
iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
iaxs[fr->callno]->peercapability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercapability
0
ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1);
ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf) - 1)
ast_codec_pref_string
ast_codec_pref_string
&iaxs[fr->callno]->rprefs
iaxs[fr->callno]->rprefs
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
rprefs
caller_pref_buf
caller_pref_buf
sizeof(caller_pref_buf) - 1
sizeof(caller_pref_buf)
(caller_pref_buf)
caller_pref_buf
caller_pref_buf
1
ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1);
ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf) - 1)
ast_codec_pref_string
ast_codec_pref_string
&iaxs[fr->callno]->prefs
iaxs[fr->callno]->prefs
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
prefs
host_pref_buf
host_pref_buf
sizeof(host_pref_buf) - 1
sizeof(host_pref_buf)
(host_pref_buf)
host_pref_buf
host_pref_buf
1
if (!format) {						char tmp1[256], tmp2[256], tmp3[256];						if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {							ast_debug(1, "We don't do requested format %s, falling back to peer capability '%s'\n",								iax2_getformatname(iaxs[fr->callno]->peerformat),								iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability));							format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;						}						if (!format) {							if (authdebug) {								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n", ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));								} else {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",										ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),										iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));								}							}							memset(&ied0, 0, sizeof(ied0));							iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");							iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);							send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);							if (!iaxs[fr->callno]) {								break;							}						} else {							/* Pick one... */							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))									format = 0;							} else {								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {									using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";									memset(&pref, 0, sizeof(pref));									format = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ?										iaxs[fr->callno]->peerformat : iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									strcpy(caller_pref_buf,"disabled");									strcpy(host_pref_buf,"disabled");								} else {									struct ast_format tmpfmt;									using_prefs = "mine";									if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {										/* Do the opposite of what we tried above. */										if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {											pref = iaxs[fr->callno]->prefs;										} else {											pref = iaxs[fr->callno]->rprefs;											using_prefs = "caller";										}										format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);									} else /* if no codec_prefs IE do it the old way */										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}							}							if (!format) {								char tmp1[256], tmp2[256], tmp3[256];								ast_log(LOG_ERROR, "No best format in %s???\n",									iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));								if (authdebug) {									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}							}						}					}
!format
format
format
{						char tmp1[256], tmp2[256], tmp3[256];						if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {							ast_debug(1, "We don't do requested format %s, falling back to peer capability '%s'\n",								iax2_getformatname(iaxs[fr->callno]->peerformat),								iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability));							format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;						}						if (!format) {							if (authdebug) {								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n", ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));								} else {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",										ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),										iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));								}							}							memset(&ied0, 0, sizeof(ied0));							iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");							iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);							send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);							if (!iaxs[fr->callno]) {								break;							}						} else {							/* Pick one... */							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))									format = 0;							} else {								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {									using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";									memset(&pref, 0, sizeof(pref));									format = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ?										iaxs[fr->callno]->peerformat : iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									strcpy(caller_pref_buf,"disabled");									strcpy(host_pref_buf,"disabled");								} else {									struct ast_format tmpfmt;									using_prefs = "mine";									if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {										/* Do the opposite of what we tried above. */										if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {											pref = iaxs[fr->callno]->prefs;										} else {											pref = iaxs[fr->callno]->rprefs;											using_prefs = "caller";										}										format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);									} else /* if no codec_prefs IE do it the old way */										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}							}							if (!format) {								char tmp1[256], tmp2[256], tmp3[256];								ast_log(LOG_ERROR, "No best format in %s???\n",									iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));								if (authdebug) {									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}							}						}					}
char tmp1[256], tmp2[256], tmp3[256];
char tmp1[256], tmp2[256], tmp3[256];
char
tmp1[256]
tmp1
[256]
256
tmp2[256]
tmp2
[256]
256
tmp3[256]
tmp3
[256]
256
if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {							ast_debug(1, "We don't do requested format %s, falling back to peer capability '%s'\n",								iax2_getformatname(iaxs[fr->callno]->peerformat),								iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability));							format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;						}
!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_CODEC_NOCAP
IAX_CODEC_NOCAP
{							ast_debug(1, "We don't do requested format %s, falling back to peer capability '%s'\n",								iax2_getformatname(iaxs[fr->callno]->peerformat),								iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability));							format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;						}
ast_debug(1, "We don't do requested format %s, falling back to peer capability '%s'\n",								iax2_getformatname(iaxs[fr->callno]->peerformat),								iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability));
ast_debug(1, "We don't do requested format %s, falling back to peer capability '%s'\n",								iax2_getformatname(iaxs[fr->callno]->peerformat),								iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability))
ast_debug
ast_debug
1
"We don't do requested format %s, falling back to peer capability '%s'\n"
iax2_getformatname(iaxs[fr->callno]->peerformat)
iax2_getformatname
iax2_getformatname
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp1
tmp1
sizeof(tmp1)
(tmp1)
tmp1
tmp1
iaxs[fr->callno]->peercapability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercapability
format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability;
format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability
format
format
iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability
iaxs[fr->callno]->peercapability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercapability
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
if (!format) {							if (authdebug) {								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n", ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));								} else {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",										ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),										iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));								}							}							memset(&ied0, 0, sizeof(ied0));							iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");							iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);							send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);							if (!iaxs[fr->callno]) {								break;							}						} else {							/* Pick one... */							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))									format = 0;							} else {								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {									using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";									memset(&pref, 0, sizeof(pref));									format = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ?										iaxs[fr->callno]->peerformat : iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									strcpy(caller_pref_buf,"disabled");									strcpy(host_pref_buf,"disabled");								} else {									struct ast_format tmpfmt;									using_prefs = "mine";									if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {										/* Do the opposite of what we tried above. */										if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {											pref = iaxs[fr->callno]->prefs;										} else {											pref = iaxs[fr->callno]->rprefs;											using_prefs = "caller";										}										format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);									} else /* if no codec_prefs IE do it the old way */										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}							}							if (!format) {								char tmp1[256], tmp2[256], tmp3[256];								ast_log(LOG_ERROR, "No best format in %s???\n",									iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));								if (authdebug) {									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}							}						}
!format
format
format
{							if (authdebug) {								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n", ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));								} else {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",										ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),										iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));								}							}							memset(&ied0, 0, sizeof(ied0));							iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");							iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);							send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);							if (!iaxs[fr->callno]) {								break;							}						}
if (authdebug) {								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n", ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));								} else {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",										ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),										iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));								}							}
authdebug
authdebug
{								if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n", ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));								} else {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",										ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),										iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));								}							}
if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n", ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));								} else {									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",										ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),										iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));								}
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_CODEC_NOCAP
IAX_CODEC_NOCAP
{									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n", ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));								}
ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n", ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));
ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n", ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability))
ast_log
ast_log
LOG_NOTICE
LOG_NOTICE
"Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n"
ast_inet_ntoa(sin.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
sin.sin_addr
sin
sin
sin_addr
iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp1
tmp1
sizeof(tmp1)
(tmp1)
tmp1
tmp1
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp2
tmp2
sizeof(tmp2)
(tmp2)
tmp2
tmp2
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
{									ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",										ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),										iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));								}
ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",										ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),										iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));
ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",										ast_inet_ntoa(sin.sin_addr),										iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),										iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),										iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability))
ast_log
ast_log
LOG_NOTICE
LOG_NOTICE
"Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n"
ast_inet_ntoa(sin.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
sin.sin_addr
sin
sin
sin_addr
iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp1
tmp1
sizeof(tmp1)
(tmp1)
tmp1
tmp1
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp2
tmp2
sizeof(tmp2)
(tmp2)
tmp2
tmp2
iaxs[fr->callno]->peercapability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercapability
iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp3
tmp3
sizeof(tmp3)
(tmp3)
tmp3
tmp3
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
memset(&ied0, 0, sizeof(ied0));
memset(&ied0, 0, sizeof(ied0))
memset
memset
&ied0
ied0
ied0
0
sizeof(ied0)
(ied0)
ied0
ied0
iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");
iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec")
iax_ie_append_str
iax_ie_append_str
&ied0
ied0
ied0
IAX_IE_CAUSE
IAX_IE_CAUSE
"Unable to negotiate codec"
iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);
iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL)
iax_ie_append_byte
iax_ie_append_byte
&ied0
ied0
ied0
IAX_IE_CAUSECODE
IAX_IE_CAUSECODE
AST_CAUSE_BEARERCAPABILITY_NOTAVAIL
AST_CAUSE_BEARERCAPABILITY_NOTAVAIL
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1)
send_command_final
send_command_final
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_REJECT
IAX_COMMAND_REJECT
0
ied0.buf
ied0
ied0
buf
ied0.pos
ied0
ied0
pos
-1
1
if (!iaxs[fr->callno]) {								break;							}
!iaxs[fr->callno]
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{								break;							}
break;
{							/* Pick one... */							if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))									format = 0;							} else {								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {									using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";									memset(&pref, 0, sizeof(pref));									format = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ?										iaxs[fr->callno]->peerformat : iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									strcpy(caller_pref_buf,"disabled");									strcpy(host_pref_buf,"disabled");								} else {									struct ast_format tmpfmt;									using_prefs = "mine";									if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {										/* Do the opposite of what we tried above. */										if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {											pref = iaxs[fr->callno]->prefs;										} else {											pref = iaxs[fr->callno]->rprefs;											using_prefs = "caller";										}										format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);									} else /* if no codec_prefs IE do it the old way */										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}							}							if (!format) {								char tmp1[256], tmp2[256], tmp3[256];								ast_log(LOG_ERROR, "No best format in %s???\n",									iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));								if (authdebug) {									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}							}						}
if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {								if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))									format = 0;							} else {								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {									using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";									memset(&pref, 0, sizeof(pref));									format = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ?										iaxs[fr->callno]->peerformat : iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									strcpy(caller_pref_buf,"disabled");									strcpy(host_pref_buf,"disabled");								} else {									struct ast_format tmpfmt;									using_prefs = "mine";									if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {										/* Do the opposite of what we tried above. */										if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {											pref = iaxs[fr->callno]->prefs;										} else {											pref = iaxs[fr->callno]->rprefs;											using_prefs = "caller";										}										format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);									} else /* if no codec_prefs IE do it the old way */										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}							}
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_CODEC_NOCAP
IAX_CODEC_NOCAP
{								if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))									format = 0;							}
if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability))									format = 0;
!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)
(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)
iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
format = 0;
format = 0
format
format
0
{								if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {									using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";									memset(&pref, 0, sizeof(pref));									format = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ?										iaxs[fr->callno]->peerformat : iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									strcpy(caller_pref_buf,"disabled");									strcpy(host_pref_buf,"disabled");								} else {									struct ast_format tmpfmt;									using_prefs = "mine";									if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {										/* Do the opposite of what we tried above. */										if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {											pref = iaxs[fr->callno]->prefs;										} else {											pref = iaxs[fr->callno]->rprefs;											using_prefs = "caller";										}										format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);									} else /* if no codec_prefs IE do it the old way */										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}							}
if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)) {									using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";									memset(&pref, 0, sizeof(pref));									format = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ?										iaxs[fr->callno]->peerformat : iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									strcpy(caller_pref_buf,"disabled");									strcpy(host_pref_buf,"disabled");								} else {									struct ast_format tmpfmt;									using_prefs = "mine";									if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {										/* Do the opposite of what we tried above. */										if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {											pref = iaxs[fr->callno]->prefs;										} else {											pref = iaxs[fr->callno]->rprefs;											using_prefs = "caller";										}										format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);									} else /* if no codec_prefs IE do it the old way */										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_CODEC_NOPREFS
IAX_CODEC_NOPREFS
{									using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";									memset(&pref, 0, sizeof(pref));									format = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ?										iaxs[fr->callno]->peerformat : iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									strcpy(caller_pref_buf,"disabled");									strcpy(host_pref_buf,"disabled");								}
using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled";
using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled"
using_prefs
using_prefs
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ? "reqonly" : "disabled"
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_CODEC_NOCAP
IAX_CODEC_NOCAP
"reqonly"
"disabled"
memset(&pref, 0, sizeof(pref));
memset(&pref, 0, sizeof(pref))
memset
memset
&pref
pref
pref
0
sizeof(pref)
(pref)
pref
pref
format = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ?										iaxs[fr->callno]->peerformat : iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);
format = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ?										iaxs[fr->callno]->peerformat : iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
format
format
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP) ?										iaxs[fr->callno]->peerformat : iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_CODEC_NOCAP
IAX_CODEC_NOCAP
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
iax2_best_codec
iax2_best_codec
iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability
iaxs[fr->callno]->peercapability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercapability
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
strcpy(caller_pref_buf,"disabled");
strcpy(caller_pref_buf,"disabled")
strcpy
strcpy
caller_pref_buf
caller_pref_buf
"disabled"
strcpy(host_pref_buf,"disabled");
strcpy(host_pref_buf,"disabled")
strcpy
strcpy
host_pref_buf
host_pref_buf
"disabled"
{									struct ast_format tmpfmt;									using_prefs = "mine";									if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {										/* Do the opposite of what we tried above. */										if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {											pref = iaxs[fr->callno]->prefs;										} else {											pref = iaxs[fr->callno]->rprefs;											using_prefs = "caller";										}										format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);									} else /* if no codec_prefs IE do it the old way */										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);									}
struct ast_format tmpfmt;
struct ast_format tmpfmt;
struct ast_format
ast_format
tmpfmt
tmpfmt
using_prefs = "mine";
using_prefs = "mine"
using_prefs
using_prefs
"mine"
if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)) {										/* Do the opposite of what we tried above. */										if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {											pref = iaxs[fr->callno]->prefs;										} else {											pref = iaxs[fr->callno]->rprefs;											using_prefs = "caller";										}										format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);									} else /* if no codec_prefs IE do it the old way */										format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);
ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)
ast_codec_pref_index
ast_codec_pref_index
&iaxs[fr->callno]->rprefs
iaxs[fr->callno]->rprefs
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
rprefs
0
&tmpfmt
tmpfmt
tmpfmt
{										/* Do the opposite of what we tried above. */										if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {											pref = iaxs[fr->callno]->prefs;										} else {											pref = iaxs[fr->callno]->rprefs;											using_prefs = "caller";										}										format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);									}
if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)) {											pref = iaxs[fr->callno]->prefs;										} else {											pref = iaxs[fr->callno]->rprefs;											using_prefs = "caller";										}
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_CODEC_USER_FIRST
IAX_CODEC_USER_FIRST
{											pref = iaxs[fr->callno]->prefs;										}
pref = iaxs[fr->callno]->prefs;
pref = iaxs[fr->callno]->prefs
pref
pref
iaxs[fr->callno]->prefs
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
prefs
{											pref = iaxs[fr->callno]->rprefs;											using_prefs = "caller";										}
pref = iaxs[fr->callno]->rprefs;
pref = iaxs[fr->callno]->rprefs
pref
pref
iaxs[fr->callno]->rprefs
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
rprefs
using_prefs = "caller";
using_prefs = "caller"
using_prefs
using_prefs
"caller"
format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1);
format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1)
format
format
iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1)
iax2_codec_choose
iax2_codec_choose
&pref
pref
pref
iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability
iaxs[fr->callno]->peercapability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercapability
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
1
format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability);
format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
format
format
iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
iax2_best_codec
iax2_best_codec
iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability
iaxs[fr->callno]->peercapability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercapability
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
if (!format) {								char tmp1[256], tmp2[256], tmp3[256];								ast_log(LOG_ERROR, "No best format in %s???\n",									iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));								if (authdebug) {									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}							}
!format
format
format
{								char tmp1[256], tmp2[256], tmp3[256];								ast_log(LOG_ERROR, "No best format in %s???\n",									iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));								if (authdebug) {									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}								memset(&ied0, 0, sizeof(ied0));								iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");								iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);								send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);								if (!iaxs[fr->callno]) {									break;								}							}
char tmp1[256], tmp2[256], tmp3[256];
char tmp1[256], tmp2[256], tmp3[256];
char
tmp1[256]
tmp1
[256]
256
tmp2[256]
tmp2
[256]
256
tmp3[256]
tmp3
[256]
256
ast_log(LOG_ERROR, "No best format in %s???\n",									iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability));
ast_log(LOG_ERROR, "No best format in %s???\n",									iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability))
ast_log
ast_log
LOG_ERROR
LOG_ERROR
"No best format in %s???\n"
iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp1
tmp1
sizeof(tmp1)
(tmp1)
tmp1
tmp1
iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability
iaxs[fr->callno]->peercapability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercapability
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
if (authdebug) {									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}
authdebug
authdebug
{									if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}								}
if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)) {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									} else {										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}
ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_CODEC_NOCAP
IAX_CODEC_NOCAP
{										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));									}
ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability));
ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability))
ast_log
ast_log
LOG_NOTICE
LOG_NOTICE
"Rejected connect attempt from %s, requested '%s' incompatible with our capability '%s'.\n"
ast_inet_ntoa(sin.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
sin.sin_addr
sin
sin
sin_addr
iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp1
tmp1
sizeof(tmp1)
(tmp1)
tmp1
tmp1
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->capability)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp2
tmp2
sizeof(tmp2)
(tmp2)
tmp2
tmp2
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
{										ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));									}
ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability));
ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n",											ast_inet_ntoa(sin.sin_addr),											iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat),											iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability),											iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability))
ast_log
ast_log
LOG_NOTICE
LOG_NOTICE
"Rejected connect attempt from %s, requested/capability '%s'/'%s' incompatible with our capability '%s'.\n"
ast_inet_ntoa(sin.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
sin.sin_addr
sin
sin
sin_addr
iax2_getformatname_multiple(tmp1, sizeof(tmp1), iaxs[fr->callno]->peerformat)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp1
tmp1
sizeof(tmp1)
(tmp1)
tmp1
tmp1
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
iax2_getformatname_multiple(tmp2, sizeof(tmp2), iaxs[fr->callno]->peercapability)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp2
tmp2
sizeof(tmp2)
(tmp2)
tmp2
tmp2
iaxs[fr->callno]->peercapability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercapability
iax2_getformatname_multiple(tmp3, sizeof(tmp3), iaxs[fr->callno]->capability)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp3
tmp3
sizeof(tmp3)
(tmp3)
tmp3
tmp3
iaxs[fr->callno]->capability
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
capability
memset(&ied0, 0, sizeof(ied0));
memset(&ied0, 0, sizeof(ied0))
memset
memset
&ied0
ied0
ied0
0
sizeof(ied0)
(ied0)
ied0
ied0
iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec");
iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec")
iax_ie_append_str
iax_ie_append_str
&ied0
ied0
ied0
IAX_IE_CAUSE
IAX_IE_CAUSE
"Unable to negotiate codec"
iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);
iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL)
iax_ie_append_byte
iax_ie_append_byte
&ied0
ied0
ied0
IAX_IE_CAUSECODE
IAX_IE_CAUSECODE
AST_CAUSE_BEARERCAPABILITY_NOTAVAIL
AST_CAUSE_BEARERCAPABILITY_NOTAVAIL
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1)
send_command_final
send_command_final
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_REJECT
IAX_COMMAND_REJECT
0
ied0.buf
ied0
ied0
buf
ied0.pos
ied0
ied0
pos
-1
1
if (!iaxs[fr->callno]) {									break;								}
!iaxs[fr->callno]
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{									break;								}
break;
if (format) {						/* Authentication received */						memset(&ied1, 0, sizeof(ied1));						iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);						iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);						send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);						if (strcmp(iaxs[fr->callno]->exten, "TBD")) {							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							ast_verb(3, "Accepting AUTHENTICATED call from %s:\n"											"%srequested format = %s,\n"											"%srequested prefs = %s,\n"											"%sactual format = %s,\n"											"%shost prefs = %s,\n"											"%spriority = %s\n", 											ast_inet_ntoa(sin.sin_addr), 											VERBOSE_PREFIX_4,											iax2_getformatname(iaxs[fr->callno]->peerformat),											VERBOSE_PREFIX_4,											caller_pref_buf,											VERBOSE_PREFIX_4,											iax2_getformatname(format),											VERBOSE_PREFIX_4,											host_pref_buf,											VERBOSE_PREFIX_4,											using_prefs);							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, format, NULL)))								iax2_destroy(fr->callno);							else if (ies.vars) {								struct ast_datastore *variablestore;								struct ast_variable *var, *prev = NULL;								AST_LIST_HEAD(, ast_var_t) *varlist;								varlist = ast_calloc(1, sizeof(*varlist));								variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);								if (variablestore && varlist) {									variablestore->data = varlist;									variablestore->inheritance = DATASTORE_INHERIT_FOREVER;									AST_LIST_HEAD_INIT(varlist);									ast_debug(1, "I can haz IAX vars? w00t\n");									for (var = ies.vars; var; var = var->next) {										struct ast_var_t *newvar = ast_var_assign(var->name, var->value);										if (prev)											ast_free(prev);										prev = var;										if (!newvar) {											/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */											ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");										} else {											AST_LIST_INSERT_TAIL(varlist, newvar, entries);										}									}									if (prev)										ast_free(prev);									ies.vars = NULL;									ast_channel_datastore_add(c, variablestore);								} else {									ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									if (variablestore)										ast_datastore_free(variablestore);									if (varlist)										ast_free(varlist);								}							}						} else {							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);							/* If this is a TBD call, we're ready but now what...  */							ast_verb(3, "Accepted AUTHENTICATED TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							if (ast_test_flag64(iaxs[fr->callno], IAX_IMMEDIATE)) {								goto immediatedial;							}						}					}
format
format
{						/* Authentication received */						memset(&ied1, 0, sizeof(ied1));						iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);						iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);						send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);						if (strcmp(iaxs[fr->callno]->exten, "TBD")) {							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							ast_verb(3, "Accepting AUTHENTICATED call from %s:\n"											"%srequested format = %s,\n"											"%srequested prefs = %s,\n"											"%sactual format = %s,\n"											"%shost prefs = %s,\n"											"%spriority = %s\n", 											ast_inet_ntoa(sin.sin_addr), 											VERBOSE_PREFIX_4,											iax2_getformatname(iaxs[fr->callno]->peerformat),											VERBOSE_PREFIX_4,											caller_pref_buf,											VERBOSE_PREFIX_4,											iax2_getformatname(format),											VERBOSE_PREFIX_4,											host_pref_buf,											VERBOSE_PREFIX_4,											using_prefs);							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, format, NULL)))								iax2_destroy(fr->callno);							else if (ies.vars) {								struct ast_datastore *variablestore;								struct ast_variable *var, *prev = NULL;								AST_LIST_HEAD(, ast_var_t) *varlist;								varlist = ast_calloc(1, sizeof(*varlist));								variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);								if (variablestore && varlist) {									variablestore->data = varlist;									variablestore->inheritance = DATASTORE_INHERIT_FOREVER;									AST_LIST_HEAD_INIT(varlist);									ast_debug(1, "I can haz IAX vars? w00t\n");									for (var = ies.vars; var; var = var->next) {										struct ast_var_t *newvar = ast_var_assign(var->name, var->value);										if (prev)											ast_free(prev);										prev = var;										if (!newvar) {											/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */											ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");										} else {											AST_LIST_INSERT_TAIL(varlist, newvar, entries);										}									}									if (prev)										ast_free(prev);									ies.vars = NULL;									ast_channel_datastore_add(c, variablestore);								} else {									ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									if (variablestore)										ast_datastore_free(variablestore);									if (varlist)										ast_free(varlist);								}							}						} else {							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);							/* If this is a TBD call, we're ready but now what...  */							ast_verb(3, "Accepted AUTHENTICATED TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							if (ast_test_flag64(iaxs[fr->callno], IAX_IMMEDIATE)) {								goto immediatedial;							}						}					}
memset(&ied1, 0, sizeof(ied1));
memset(&ied1, 0, sizeof(ied1))
memset
memset
&ied1
ied1
ied1
0
sizeof(ied1)
(ied1)
ied1
ied1
iax_ie_append_int(&ied1, IAX_IE_FORMAT, format);
iax_ie_append_int(&ied1, IAX_IE_FORMAT, format)
iax_ie_append_int
iax_ie_append_int
&ied1
ied1
ied1
IAX_IE_FORMAT
IAX_IE_FORMAT
format
format
iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format);
iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format)
iax_ie_append_versioned_uint64
iax_ie_append_versioned_uint64
&ied1
ied1
ied1
IAX_IE_FORMAT2
IAX_IE_FORMAT2
0
format
format
send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1);
send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1)
send_command
send_command
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_ACCEPT
IAX_COMMAND_ACCEPT
0
ied1.buf
ied1
ied1
buf
ied1.pos
ied1
ied1
pos
-1
1
if (strcmp(iaxs[fr->callno]->exten, "TBD")) {							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							ast_verb(3, "Accepting AUTHENTICATED call from %s:\n"											"%srequested format = %s,\n"											"%srequested prefs = %s,\n"											"%sactual format = %s,\n"											"%shost prefs = %s,\n"											"%spriority = %s\n", 											ast_inet_ntoa(sin.sin_addr), 											VERBOSE_PREFIX_4,											iax2_getformatname(iaxs[fr->callno]->peerformat),											VERBOSE_PREFIX_4,											caller_pref_buf,											VERBOSE_PREFIX_4,											iax2_getformatname(format),											VERBOSE_PREFIX_4,											host_pref_buf,											VERBOSE_PREFIX_4,											using_prefs);							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, format, NULL)))								iax2_destroy(fr->callno);							else if (ies.vars) {								struct ast_datastore *variablestore;								struct ast_variable *var, *prev = NULL;								AST_LIST_HEAD(, ast_var_t) *varlist;								varlist = ast_calloc(1, sizeof(*varlist));								variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);								if (variablestore && varlist) {									variablestore->data = varlist;									variablestore->inheritance = DATASTORE_INHERIT_FOREVER;									AST_LIST_HEAD_INIT(varlist);									ast_debug(1, "I can haz IAX vars? w00t\n");									for (var = ies.vars; var; var = var->next) {										struct ast_var_t *newvar = ast_var_assign(var->name, var->value);										if (prev)											ast_free(prev);										prev = var;										if (!newvar) {											/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */											ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");										} else {											AST_LIST_INSERT_TAIL(varlist, newvar, entries);										}									}									if (prev)										ast_free(prev);									ies.vars = NULL;									ast_channel_datastore_add(c, variablestore);								} else {									ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									if (variablestore)										ast_datastore_free(variablestore);									if (varlist)										ast_free(varlist);								}							}						} else {							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);							/* If this is a TBD call, we're ready but now what...  */							ast_verb(3, "Accepted AUTHENTICATED TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							if (ast_test_flag64(iaxs[fr->callno], IAX_IMMEDIATE)) {								goto immediatedial;							}						}
strcmp(iaxs[fr->callno]->exten, "TBD")
strcmp
strcmp
iaxs[fr->callno]->exten
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
exten
"TBD"
{							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							ast_verb(3, "Accepting AUTHENTICATED call from %s:\n"											"%srequested format = %s,\n"											"%srequested prefs = %s,\n"											"%sactual format = %s,\n"											"%shost prefs = %s,\n"											"%spriority = %s\n", 											ast_inet_ntoa(sin.sin_addr), 											VERBOSE_PREFIX_4,											iax2_getformatname(iaxs[fr->callno]->peerformat),											VERBOSE_PREFIX_4,											caller_pref_buf,											VERBOSE_PREFIX_4,											iax2_getformatname(format),											VERBOSE_PREFIX_4,											host_pref_buf,											VERBOSE_PREFIX_4,											using_prefs);							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);							if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, format, NULL)))								iax2_destroy(fr->callno);							else if (ies.vars) {								struct ast_datastore *variablestore;								struct ast_variable *var, *prev = NULL;								AST_LIST_HEAD(, ast_var_t) *varlist;								varlist = ast_calloc(1, sizeof(*varlist));								variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);								if (variablestore && varlist) {									variablestore->data = varlist;									variablestore->inheritance = DATASTORE_INHERIT_FOREVER;									AST_LIST_HEAD_INIT(varlist);									ast_debug(1, "I can haz IAX vars? w00t\n");									for (var = ies.vars; var; var = var->next) {										struct ast_var_t *newvar = ast_var_assign(var->name, var->value);										if (prev)											ast_free(prev);										prev = var;										if (!newvar) {											/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */											ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");										} else {											AST_LIST_INSERT_TAIL(varlist, newvar, entries);										}									}									if (prev)										ast_free(prev);									ies.vars = NULL;									ast_channel_datastore_add(c, variablestore);								} else {									ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									if (variablestore)										ast_datastore_free(variablestore);									if (varlist)										ast_free(varlist);								}							}						}
ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);
ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
ast_set_flag
ast_set_flag
&iaxs[fr->callno]->state
iaxs[fr->callno]->state
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
state
IAX_STATE_STARTED
IAX_STATE_STARTED
ast_verb(3, "Accepting AUTHENTICATED call from %s:\n"											"%srequested format = %s,\n"											"%srequested prefs = %s,\n"											"%sactual format = %s,\n"											"%shost prefs = %s,\n"											"%spriority = %s\n", 											ast_inet_ntoa(sin.sin_addr), 											VERBOSE_PREFIX_4,											iax2_getformatname(iaxs[fr->callno]->peerformat),											VERBOSE_PREFIX_4,											caller_pref_buf,											VERBOSE_PREFIX_4,											iax2_getformatname(format),											VERBOSE_PREFIX_4,											host_pref_buf,											VERBOSE_PREFIX_4,											using_prefs);
ast_verb(3, "Accepting AUTHENTICATED call from %s:\n"											"%srequested format = %s,\n"											"%srequested prefs = %s,\n"											"%sactual format = %s,\n"											"%shost prefs = %s,\n"											"%spriority = %s\n", 											ast_inet_ntoa(sin.sin_addr), 											VERBOSE_PREFIX_4,											iax2_getformatname(iaxs[fr->callno]->peerformat),											VERBOSE_PREFIX_4,											caller_pref_buf,											VERBOSE_PREFIX_4,											iax2_getformatname(format),											VERBOSE_PREFIX_4,											host_pref_buf,											VERBOSE_PREFIX_4,											using_prefs)
ast_verb
ast_verb
3
"Accepting AUTHENTICATED call from %s:\n"											"%srequested format = %s,\n"											"%srequested prefs = %s,\n"											"%sactual format = %s,\n"											"%shost prefs = %s,\n"											"%spriority = %s\n"
ast_inet_ntoa(sin.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
sin.sin_addr
sin
sin
sin_addr
VERBOSE_PREFIX_4
VERBOSE_PREFIX_4
iax2_getformatname(iaxs[fr->callno]->peerformat)
iax2_getformatname
iax2_getformatname
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
VERBOSE_PREFIX_4
VERBOSE_PREFIX_4
caller_pref_buf
caller_pref_buf
VERBOSE_PREFIX_4
VERBOSE_PREFIX_4
iax2_getformatname(format)
iax2_getformatname
iax2_getformatname
format
format
VERBOSE_PREFIX_4
VERBOSE_PREFIX_4
host_pref_buf
host_pref_buf
VERBOSE_PREFIX_4
VERBOSE_PREFIX_4
using_prefs
using_prefs
ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);
ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
ast_set_flag
ast_set_flag
&iaxs[fr->callno]->state
iaxs[fr->callno]->state
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
state
IAX_STATE_STARTED
IAX_STATE_STARTED
if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, format, NULL)))								iax2_destroy(fr->callno);							else if (ies.vars) {								struct ast_datastore *variablestore;								struct ast_variable *var, *prev = NULL;								AST_LIST_HEAD(, ast_var_t) *varlist;								varlist = ast_calloc(1, sizeof(*varlist));								variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);								if (variablestore && varlist) {									variablestore->data = varlist;									variablestore->inheritance = DATASTORE_INHERIT_FOREVER;									AST_LIST_HEAD_INIT(varlist);									ast_debug(1, "I can haz IAX vars? w00t\n");									for (var = ies.vars; var; var = var->next) {										struct ast_var_t *newvar = ast_var_assign(var->name, var->value);										if (prev)											ast_free(prev);										prev = var;										if (!newvar) {											/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */											ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");										} else {											AST_LIST_INSERT_TAIL(varlist, newvar, entries);										}									}									if (prev)										ast_free(prev);									ies.vars = NULL;									ast_channel_datastore_add(c, variablestore);								} else {									ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									if (variablestore)										ast_datastore_free(variablestore);									if (varlist)										ast_free(varlist);								}							}
!(c = ast_iax2_new(fr->callno, AST_STATE_RING, format, NULL))
(c = ast_iax2_new(fr->callno, AST_STATE_RING, format, NULL))
c = ast_iax2_new(fr->callno, AST_STATE_RING, format, NULL)
c
c
ast_iax2_new(fr->callno, AST_STATE_RING, format, NULL)
ast_iax2_new
ast_iax2_new
fr->callno
fr
fr
callno
AST_STATE_RING
AST_STATE_RING
format
format
NULL
NULL
iax2_destroy(fr->callno);
iax2_destroy(fr->callno)
iax2_destroy
iax2_destroy
fr->callno
fr
fr
callno
if (ies.vars) {								struct ast_datastore *variablestore;								struct ast_variable *var, *prev = NULL;								AST_LIST_HEAD(, ast_var_t) *varlist;								varlist = ast_calloc(1, sizeof(*varlist));								variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);								if (variablestore && varlist) {									variablestore->data = varlist;									variablestore->inheritance = DATASTORE_INHERIT_FOREVER;									AST_LIST_HEAD_INIT(varlist);									ast_debug(1, "I can haz IAX vars? w00t\n");									for (var = ies.vars; var; var = var->next) {										struct ast_var_t *newvar = ast_var_assign(var->name, var->value);										if (prev)											ast_free(prev);										prev = var;										if (!newvar) {											/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */											ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");										} else {											AST_LIST_INSERT_TAIL(varlist, newvar, entries);										}									}									if (prev)										ast_free(prev);									ies.vars = NULL;									ast_channel_datastore_add(c, variablestore);								} else {									ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									if (variablestore)										ast_datastore_free(variablestore);									if (varlist)										ast_free(varlist);								}							}
ies.vars
ies
ies
vars
{								struct ast_datastore *variablestore;								struct ast_variable *var, *prev = NULL;								AST_LIST_HEAD(, ast_var_t) *varlist;								varlist = ast_calloc(1, sizeof(*varlist));								variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);								if (variablestore && varlist) {									variablestore->data = varlist;									variablestore->inheritance = DATASTORE_INHERIT_FOREVER;									AST_LIST_HEAD_INIT(varlist);									ast_debug(1, "I can haz IAX vars? w00t\n");									for (var = ies.vars; var; var = var->next) {										struct ast_var_t *newvar = ast_var_assign(var->name, var->value);										if (prev)											ast_free(prev);										prev = var;										if (!newvar) {											/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */											ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");										} else {											AST_LIST_INSERT_TAIL(varlist, newvar, entries);										}									}									if (prev)										ast_free(prev);									ies.vars = NULL;									ast_channel_datastore_add(c, variablestore);								} else {									ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									if (variablestore)										ast_datastore_free(variablestore);									if (varlist)										ast_free(varlist);								}							}
struct ast_datastore *variablestore;
struct ast_datastore *variablestore;
struct ast_datastore
ast_datastore
*variablestore
*
variablestore
struct ast_variable *var, *prev = NULL;
struct ast_variable *var, *prev = NULL;
struct ast_variable
ast_variable
*var
*
var
*prev = NULL
*
prev
= NULL
NULL
NULL
AST_LIST_HEAD(, ast_var_t) *varlist;
varlist = ast_calloc(1, sizeof(*varlist));
varlist = ast_calloc(1, sizeof(*varlist))
varlist
varlist
ast_calloc(1, sizeof(*varlist))
ast_calloc
ast_calloc
1
sizeof(*varlist)
(*varlist)
*varlist
varlist
varlist
variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);
variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL)
variablestore
variablestore
ast_datastore_alloc(&iax2_variable_datastore_info, NULL)
ast_datastore_alloc
ast_datastore_alloc
&iax2_variable_datastore_info
iax2_variable_datastore_info
iax2_variable_datastore_info
NULL
NULL
if (variablestore && varlist) {									variablestore->data = varlist;									variablestore->inheritance = DATASTORE_INHERIT_FOREVER;									AST_LIST_HEAD_INIT(varlist);									ast_debug(1, "I can haz IAX vars? w00t\n");									for (var = ies.vars; var; var = var->next) {										struct ast_var_t *newvar = ast_var_assign(var->name, var->value);										if (prev)											ast_free(prev);										prev = var;										if (!newvar) {											/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */											ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");										} else {											AST_LIST_INSERT_TAIL(varlist, newvar, entries);										}									}									if (prev)										ast_free(prev);									ies.vars = NULL;									ast_channel_datastore_add(c, variablestore);								} else {									ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									if (variablestore)										ast_datastore_free(variablestore);									if (varlist)										ast_free(varlist);								}
variablestore && varlist
variablestore
variablestore
varlist
varlist
{									variablestore->data = varlist;									variablestore->inheritance = DATASTORE_INHERIT_FOREVER;									AST_LIST_HEAD_INIT(varlist);									ast_debug(1, "I can haz IAX vars? w00t\n");									for (var = ies.vars; var; var = var->next) {										struct ast_var_t *newvar = ast_var_assign(var->name, var->value);										if (prev)											ast_free(prev);										prev = var;										if (!newvar) {											/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */											ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");										} else {											AST_LIST_INSERT_TAIL(varlist, newvar, entries);										}									}									if (prev)										ast_free(prev);									ies.vars = NULL;									ast_channel_datastore_add(c, variablestore);								}
variablestore->data = varlist;
variablestore->data = varlist
variablestore->data
variablestore
variablestore
data
varlist
varlist
variablestore->inheritance = DATASTORE_INHERIT_FOREVER;
variablestore->inheritance = DATASTORE_INHERIT_FOREVER
variablestore->inheritance
variablestore
variablestore
inheritance
DATASTORE_INHERIT_FOREVER
DATASTORE_INHERIT_FOREVER
AST_LIST_HEAD_INIT(varlist);
AST_LIST_HEAD_INIT(varlist);
AST_LIST_HEAD_INIT
AST_LIST_HEAD_INIT
(varlist)
varlist
varlist
ast_debug(1, "I can haz IAX vars? w00t\n");
ast_debug(1, "I can haz IAX vars? w00t\n")
ast_debug
ast_debug
1
"I can haz IAX vars? w00t\n"
for (var = ies.vars; var; var = var->next) {										struct ast_var_t *newvar = ast_var_assign(var->name, var->value);										if (prev)											ast_free(prev);										prev = var;										if (!newvar) {											/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */											ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");										} else {											AST_LIST_INSERT_TAIL(varlist, newvar, entries);										}									}
var = ies.vars;
var = ies.vars
var
var
ies.vars
ies
ies
vars
var
var
var = var->next
var
var
var->next
var
var
next
{										struct ast_var_t *newvar = ast_var_assign(var->name, var->value);										if (prev)											ast_free(prev);										prev = var;										if (!newvar) {											/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */											ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");										} else {											AST_LIST_INSERT_TAIL(varlist, newvar, entries);										}									}
struct ast_var_t *newvar = ast_var_assign(var->name, var->value);
struct ast_var_t *newvar = ast_var_assign(var->name, var->value);
struct ast_var_t
ast_var_t
*newvar = ast_var_assign(var->name, var->value)
*
newvar
= ast_var_assign(var->name, var->value)
ast_var_assign(var->name, var->value)
ast_var_assign
ast_var_assign
var->name
var
var
name
var->value
var
var
value
if (prev)											ast_free(prev);
prev
prev
ast_free(prev);
ast_free(prev)
ast_free
ast_free
prev
prev
prev = var;
prev = var
prev
prev
var
var
if (!newvar) {											/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */											ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");										} else {											AST_LIST_INSERT_TAIL(varlist, newvar, entries);										}
!newvar
newvar
newvar
{											/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */											ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");										}
ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");
ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n")
ast_log
ast_log
LOG_ERROR
LOG_ERROR
"Memory allocation error while processing IAX2 variables\n"
{											AST_LIST_INSERT_TAIL(varlist, newvar, entries);										}
AST_LIST_INSERT_TAIL(varlist, newvar, entries);
AST_LIST_INSERT_TAIL(varlist, newvar, entries)
AST_LIST_INSERT_TAIL
AST_LIST_INSERT_TAIL
varlist
varlist
newvar
newvar
entries
entries
if (prev)										ast_free(prev);
prev
prev
ast_free(prev);
ast_free(prev)
ast_free
ast_free
prev
prev
ies.vars = NULL;
ies.vars = NULL
ies.vars
ies
ies
vars
NULL
NULL
ast_channel_datastore_add(c, variablestore);
ast_channel_datastore_add(c, variablestore)
ast_channel_datastore_add
ast_channel_datastore_add
c
c
variablestore
variablestore
{									ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									if (variablestore)										ast_datastore_free(variablestore);									if (varlist)										ast_free(varlist);								}
ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");
ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n")
ast_log
ast_log
LOG_ERROR
LOG_ERROR
"Memory allocation error while processing IAX2 variables\n"
if (variablestore)										ast_datastore_free(variablestore);
variablestore
variablestore
ast_datastore_free(variablestore);
ast_datastore_free(variablestore)
ast_datastore_free
ast_datastore_free
variablestore
variablestore
if (varlist)										ast_free(varlist);
varlist
varlist
ast_free(varlist);
ast_free(varlist);
ast_free
ast_free
(varlist)
varlist
varlist
{							ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);							/* If this is a TBD call, we're ready but now what...  */							ast_verb(3, "Accepted AUTHENTICATED TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));							if (ast_test_flag64(iaxs[fr->callno], IAX_IMMEDIATE)) {								goto immediatedial;							}						}
ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);
ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD)
ast_set_flag
ast_set_flag
&iaxs[fr->callno]->state
iaxs[fr->callno]->state
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
state
IAX_STATE_TBD
IAX_STATE_TBD
ast_verb(3, "Accepted AUTHENTICATED TBD call from %s\n", ast_inet_ntoa(sin.sin_addr));
ast_verb(3, "Accepted AUTHENTICATED TBD call from %s\n", ast_inet_ntoa(sin.sin_addr))
ast_verb
ast_verb
3
"Accepted AUTHENTICATED TBD call from %s\n"
ast_inet_ntoa(sin.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
sin.sin_addr
sin
sin
sin_addr
if (ast_test_flag64(iaxs[fr->callno], IAX_IMMEDIATE)) {								goto immediatedial;							}
ast_test_flag64(iaxs[fr->callno], IAX_IMMEDIATE)
ast_test_flag64
ast_test_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_IMMEDIATE
IAX_IMMEDIATE
{								goto immediatedial;							}
goto immediatedial;
immediatedial
break;
case IAX_COMMAND_DIAL:
IAX_COMMAND_DIAL
IAX_COMMAND_DIAL
immediatedial:				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD)) {					ast_clear_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);					ast_string_field_set(iaxs[fr->callno], exten, ies.called_number ? ies.called_number : "s");					if (!ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num)) {						if (authdebug)							ast_log(LOG_NOTICE, "Rejected dial attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}					} else {						char tmp[256];						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);						ast_verb(3, "Accepting DIAL from %s, formats = %s\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat));						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);						send_command(iaxs[fr->callno], AST_FRAME_CONTROL, AST_CONTROL_PROGRESS, 0, NULL, 0, -1);						if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->peerformat, NULL)))							iax2_destroy(fr->callno);						else if (ies.vars) {							struct ast_datastore *variablestore;							struct ast_variable *var, *prev = NULL;							AST_LIST_HEAD(, ast_var_t) *varlist;							varlist = ast_calloc(1, sizeof(*varlist));							variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);							ast_debug(1, "I can haz IAX vars? w00t\n");							if (variablestore && varlist) {								variablestore->data = varlist;								variablestore->inheritance = DATASTORE_INHERIT_FOREVER;								AST_LIST_HEAD_INIT(varlist);								for (var = ies.vars; var; var = var->next) {									struct ast_var_t *newvar = ast_var_assign(var->name, var->value);									if (prev)										ast_free(prev);									prev = var;									if (!newvar) {										/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */										ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									} else {										AST_LIST_INSERT_TAIL(varlist, newvar, entries);									}								}								if (prev)									ast_free(prev);								ies.vars = NULL;								ast_channel_datastore_add(c, variablestore);							} else {								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");								if (variablestore)									ast_datastore_free(variablestore);								if (varlist)									ast_free(varlist);							}						}					}				}
immediatedial
if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD)) {					ast_clear_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);					ast_string_field_set(iaxs[fr->callno], exten, ies.called_number ? ies.called_number : "s");					if (!ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num)) {						if (authdebug)							ast_log(LOG_NOTICE, "Rejected dial attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}					} else {						char tmp[256];						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);						ast_verb(3, "Accepting DIAL from %s, formats = %s\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat));						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);						send_command(iaxs[fr->callno], AST_FRAME_CONTROL, AST_CONTROL_PROGRESS, 0, NULL, 0, -1);						if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->peerformat, NULL)))							iax2_destroy(fr->callno);						else if (ies.vars) {							struct ast_datastore *variablestore;							struct ast_variable *var, *prev = NULL;							AST_LIST_HEAD(, ast_var_t) *varlist;							varlist = ast_calloc(1, sizeof(*varlist));							variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);							ast_debug(1, "I can haz IAX vars? w00t\n");							if (variablestore && varlist) {								variablestore->data = varlist;								variablestore->inheritance = DATASTORE_INHERIT_FOREVER;								AST_LIST_HEAD_INIT(varlist);								for (var = ies.vars; var; var = var->next) {									struct ast_var_t *newvar = ast_var_assign(var->name, var->value);									if (prev)										ast_free(prev);									prev = var;									if (!newvar) {										/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */										ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									} else {										AST_LIST_INSERT_TAIL(varlist, newvar, entries);									}								}								if (prev)									ast_free(prev);								ies.vars = NULL;								ast_channel_datastore_add(c, variablestore);							} else {								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");								if (variablestore)									ast_datastore_free(variablestore);								if (varlist)									ast_free(varlist);							}						}					}				}
ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD)
ast_test_flag
ast_test_flag
&iaxs[fr->callno]->state
iaxs[fr->callno]->state
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
state
IAX_STATE_TBD
IAX_STATE_TBD
{					ast_clear_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);					ast_string_field_set(iaxs[fr->callno], exten, ies.called_number ? ies.called_number : "s");					if (!ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num)) {						if (authdebug)							ast_log(LOG_NOTICE, "Rejected dial attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}					} else {						char tmp[256];						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);						ast_verb(3, "Accepting DIAL from %s, formats = %s\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat));						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);						send_command(iaxs[fr->callno], AST_FRAME_CONTROL, AST_CONTROL_PROGRESS, 0, NULL, 0, -1);						if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->peerformat, NULL)))							iax2_destroy(fr->callno);						else if (ies.vars) {							struct ast_datastore *variablestore;							struct ast_variable *var, *prev = NULL;							AST_LIST_HEAD(, ast_var_t) *varlist;							varlist = ast_calloc(1, sizeof(*varlist));							variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);							ast_debug(1, "I can haz IAX vars? w00t\n");							if (variablestore && varlist) {								variablestore->data = varlist;								variablestore->inheritance = DATASTORE_INHERIT_FOREVER;								AST_LIST_HEAD_INIT(varlist);								for (var = ies.vars; var; var = var->next) {									struct ast_var_t *newvar = ast_var_assign(var->name, var->value);									if (prev)										ast_free(prev);									prev = var;									if (!newvar) {										/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */										ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									} else {										AST_LIST_INSERT_TAIL(varlist, newvar, entries);									}								}								if (prev)									ast_free(prev);								ies.vars = NULL;								ast_channel_datastore_add(c, variablestore);							} else {								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");								if (variablestore)									ast_datastore_free(variablestore);								if (varlist)									ast_free(varlist);							}						}					}				}
ast_clear_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD);
ast_clear_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD)
ast_clear_flag
ast_clear_flag
&iaxs[fr->callno]->state
iaxs[fr->callno]->state
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
state
IAX_STATE_TBD
IAX_STATE_TBD
ast_string_field_set(iaxs[fr->callno], exten, ies.called_number ? ies.called_number : "s");
ast_string_field_set(iaxs[fr->callno], exten, ies.called_number ? ies.called_number : "s")
ast_string_field_set
ast_string_field_set
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
exten
exten
ies.called_number ? ies.called_number : "s"
ies.called_number
ies
ies
called_number
ies.called_number
ies
ies
called_number
"s"
if (!ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num)) {						if (authdebug)							ast_log(LOG_NOTICE, "Rejected dial attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}					} else {						char tmp[256];						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);						ast_verb(3, "Accepting DIAL from %s, formats = %s\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat));						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);						send_command(iaxs[fr->callno], AST_FRAME_CONTROL, AST_CONTROL_PROGRESS, 0, NULL, 0, -1);						if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->peerformat, NULL)))							iax2_destroy(fr->callno);						else if (ies.vars) {							struct ast_datastore *variablestore;							struct ast_variable *var, *prev = NULL;							AST_LIST_HEAD(, ast_var_t) *varlist;							varlist = ast_calloc(1, sizeof(*varlist));							variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);							ast_debug(1, "I can haz IAX vars? w00t\n");							if (variablestore && varlist) {								variablestore->data = varlist;								variablestore->inheritance = DATASTORE_INHERIT_FOREVER;								AST_LIST_HEAD_INIT(varlist);								for (var = ies.vars; var; var = var->next) {									struct ast_var_t *newvar = ast_var_assign(var->name, var->value);									if (prev)										ast_free(prev);									prev = var;									if (!newvar) {										/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */										ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									} else {										AST_LIST_INSERT_TAIL(varlist, newvar, entries);									}								}								if (prev)									ast_free(prev);								ies.vars = NULL;								ast_channel_datastore_add(c, variablestore);							} else {								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");								if (variablestore)									ast_datastore_free(variablestore);								if (varlist)									ast_free(varlist);							}						}					}
!ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num)
ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num)
ast_exists_extension
ast_exists_extension
NULL
NULL
iaxs[fr->callno]->context
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
context
iaxs[fr->callno]->exten
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
exten
1
iaxs[fr->callno]->cid_num
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
cid_num
{						if (authdebug)							ast_log(LOG_NOTICE, "Rejected dial attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);						memset(&ied0, 0, sizeof(ied0));						iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");						iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);						send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);						if (!iaxs[fr->callno]) {							break;						}					}
if (authdebug)							ast_log(LOG_NOTICE, "Rejected dial attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);
authdebug
authdebug
ast_log(LOG_NOTICE, "Rejected dial attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context);
ast_log(LOG_NOTICE, "Rejected dial attempt from %s, request '%s@%s' does not exist\n", ast_inet_ntoa(sin.sin_addr), iaxs[fr->callno]->exten, iaxs[fr->callno]->context)
ast_log
ast_log
LOG_NOTICE
LOG_NOTICE
"Rejected dial attempt from %s, request '%s@%s' does not exist\n"
ast_inet_ntoa(sin.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
sin.sin_addr
sin
sin
sin_addr
iaxs[fr->callno]->exten
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
exten
iaxs[fr->callno]->context
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
context
memset(&ied0, 0, sizeof(ied0));
memset(&ied0, 0, sizeof(ied0))
memset
memset
&ied0
ied0
ied0
0
sizeof(ied0)
(ied0)
ied0
ied0
iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension");
iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension")
iax_ie_append_str
iax_ie_append_str
&ied0
ied0
ied0
IAX_IE_CAUSE
IAX_IE_CAUSE
"No such context/extension"
iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION);
iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION)
iax_ie_append_byte
iax_ie_append_byte
&ied0
ied0
ied0
IAX_IE_CAUSECODE
IAX_IE_CAUSECODE
AST_CAUSE_NO_ROUTE_DESTINATION
AST_CAUSE_NO_ROUTE_DESTINATION
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1)
send_command_final
send_command_final
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_REJECT
IAX_COMMAND_REJECT
0
ied0.buf
ied0
ied0
buf
ied0.pos
ied0
ied0
pos
-1
1
if (!iaxs[fr->callno]) {							break;						}
!iaxs[fr->callno]
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{							break;						}
break;
{						char tmp[256];						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);						ast_verb(3, "Accepting DIAL from %s, formats = %s\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat));						ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);						send_command(iaxs[fr->callno], AST_FRAME_CONTROL, AST_CONTROL_PROGRESS, 0, NULL, 0, -1);						if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->peerformat, NULL)))							iax2_destroy(fr->callno);						else if (ies.vars) {							struct ast_datastore *variablestore;							struct ast_variable *var, *prev = NULL;							AST_LIST_HEAD(, ast_var_t) *varlist;							varlist = ast_calloc(1, sizeof(*varlist));							variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);							ast_debug(1, "I can haz IAX vars? w00t\n");							if (variablestore && varlist) {								variablestore->data = varlist;								variablestore->inheritance = DATASTORE_INHERIT_FOREVER;								AST_LIST_HEAD_INIT(varlist);								for (var = ies.vars; var; var = var->next) {									struct ast_var_t *newvar = ast_var_assign(var->name, var->value);									if (prev)										ast_free(prev);									prev = var;									if (!newvar) {										/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */										ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									} else {										AST_LIST_INSERT_TAIL(varlist, newvar, entries);									}								}								if (prev)									ast_free(prev);								ies.vars = NULL;								ast_channel_datastore_add(c, variablestore);							} else {								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");								if (variablestore)									ast_datastore_free(variablestore);								if (varlist)									ast_free(varlist);							}						}					}
char tmp[256];
char tmp[256];
char
tmp[256]
tmp
[256]
256
ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);
ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
ast_set_flag
ast_set_flag
&iaxs[fr->callno]->state
iaxs[fr->callno]->state
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
state
IAX_STATE_STARTED
IAX_STATE_STARTED
ast_verb(3, "Accepting DIAL from %s, formats = %s\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat));
ast_verb(3, "Accepting DIAL from %s, formats = %s\n",							ast_inet_ntoa(sin.sin_addr),							iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat))
ast_verb
ast_verb
3
"Accepting DIAL from %s, formats = %s\n"
ast_inet_ntoa(sin.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
sin.sin_addr
sin
sin
sin_addr
iax2_getformatname_multiple(tmp, sizeof(tmp), iaxs[fr->callno]->peerformat)
iax2_getformatname_multiple
iax2_getformatname_multiple
tmp
tmp
sizeof(tmp)
(tmp)
tmp
tmp
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED);
ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
ast_set_flag
ast_set_flag
&iaxs[fr->callno]->state
iaxs[fr->callno]->state
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
state
IAX_STATE_STARTED
IAX_STATE_STARTED
send_command(iaxs[fr->callno], AST_FRAME_CONTROL, AST_CONTROL_PROGRESS, 0, NULL, 0, -1);
send_command(iaxs[fr->callno], AST_FRAME_CONTROL, AST_CONTROL_PROGRESS, 0, NULL, 0, -1)
send_command
send_command
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_CONTROL
AST_FRAME_CONTROL
AST_CONTROL_PROGRESS
AST_CONTROL_PROGRESS
0
NULL
NULL
0
-1
1
if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->peerformat, NULL)))							iax2_destroy(fr->callno);						else if (ies.vars) {							struct ast_datastore *variablestore;							struct ast_variable *var, *prev = NULL;							AST_LIST_HEAD(, ast_var_t) *varlist;							varlist = ast_calloc(1, sizeof(*varlist));							variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);							ast_debug(1, "I can haz IAX vars? w00t\n");							if (variablestore && varlist) {								variablestore->data = varlist;								variablestore->inheritance = DATASTORE_INHERIT_FOREVER;								AST_LIST_HEAD_INIT(varlist);								for (var = ies.vars; var; var = var->next) {									struct ast_var_t *newvar = ast_var_assign(var->name, var->value);									if (prev)										ast_free(prev);									prev = var;									if (!newvar) {										/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */										ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									} else {										AST_LIST_INSERT_TAIL(varlist, newvar, entries);									}								}								if (prev)									ast_free(prev);								ies.vars = NULL;								ast_channel_datastore_add(c, variablestore);							} else {								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");								if (variablestore)									ast_datastore_free(variablestore);								if (varlist)									ast_free(varlist);							}						}
!(c = ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->peerformat, NULL))
(c = ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->peerformat, NULL))
c = ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->peerformat, NULL)
c
c
ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->peerformat, NULL)
ast_iax2_new
ast_iax2_new
fr->callno
fr
fr
callno
AST_STATE_RING
AST_STATE_RING
iaxs[fr->callno]->peerformat
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peerformat
NULL
NULL
iax2_destroy(fr->callno);
iax2_destroy(fr->callno)
iax2_destroy
iax2_destroy
fr->callno
fr
fr
callno
if (ies.vars) {							struct ast_datastore *variablestore;							struct ast_variable *var, *prev = NULL;							AST_LIST_HEAD(, ast_var_t) *varlist;							varlist = ast_calloc(1, sizeof(*varlist));							variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);							ast_debug(1, "I can haz IAX vars? w00t\n");							if (variablestore && varlist) {								variablestore->data = varlist;								variablestore->inheritance = DATASTORE_INHERIT_FOREVER;								AST_LIST_HEAD_INIT(varlist);								for (var = ies.vars; var; var = var->next) {									struct ast_var_t *newvar = ast_var_assign(var->name, var->value);									if (prev)										ast_free(prev);									prev = var;									if (!newvar) {										/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */										ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									} else {										AST_LIST_INSERT_TAIL(varlist, newvar, entries);									}								}								if (prev)									ast_free(prev);								ies.vars = NULL;								ast_channel_datastore_add(c, variablestore);							} else {								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");								if (variablestore)									ast_datastore_free(variablestore);								if (varlist)									ast_free(varlist);							}						}
ies.vars
ies
ies
vars
{							struct ast_datastore *variablestore;							struct ast_variable *var, *prev = NULL;							AST_LIST_HEAD(, ast_var_t) *varlist;							varlist = ast_calloc(1, sizeof(*varlist));							variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);							ast_debug(1, "I can haz IAX vars? w00t\n");							if (variablestore && varlist) {								variablestore->data = varlist;								variablestore->inheritance = DATASTORE_INHERIT_FOREVER;								AST_LIST_HEAD_INIT(varlist);								for (var = ies.vars; var; var = var->next) {									struct ast_var_t *newvar = ast_var_assign(var->name, var->value);									if (prev)										ast_free(prev);									prev = var;									if (!newvar) {										/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */										ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									} else {										AST_LIST_INSERT_TAIL(varlist, newvar, entries);									}								}								if (prev)									ast_free(prev);								ies.vars = NULL;								ast_channel_datastore_add(c, variablestore);							} else {								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");								if (variablestore)									ast_datastore_free(variablestore);								if (varlist)									ast_free(varlist);							}						}
struct ast_datastore *variablestore;
struct ast_datastore *variablestore;
struct ast_datastore
ast_datastore
*variablestore
*
variablestore
struct ast_variable *var, *prev = NULL;
struct ast_variable *var, *prev = NULL;
struct ast_variable
ast_variable
*var
*
var
*prev = NULL
*
prev
= NULL
NULL
NULL
AST_LIST_HEAD(, ast_var_t) *varlist;
varlist = ast_calloc(1, sizeof(*varlist));
varlist = ast_calloc(1, sizeof(*varlist))
varlist
varlist
ast_calloc(1, sizeof(*varlist))
ast_calloc
ast_calloc
1
sizeof(*varlist)
(*varlist)
*varlist
varlist
varlist
variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);
variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL)
variablestore
variablestore
ast_datastore_alloc(&iax2_variable_datastore_info, NULL)
ast_datastore_alloc
ast_datastore_alloc
&iax2_variable_datastore_info
iax2_variable_datastore_info
iax2_variable_datastore_info
NULL
NULL
ast_debug(1, "I can haz IAX vars? w00t\n");
ast_debug(1, "I can haz IAX vars? w00t\n")
ast_debug
ast_debug
1
"I can haz IAX vars? w00t\n"
if (variablestore && varlist) {								variablestore->data = varlist;								variablestore->inheritance = DATASTORE_INHERIT_FOREVER;								AST_LIST_HEAD_INIT(varlist);								for (var = ies.vars; var; var = var->next) {									struct ast_var_t *newvar = ast_var_assign(var->name, var->value);									if (prev)										ast_free(prev);									prev = var;									if (!newvar) {										/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */										ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									} else {										AST_LIST_INSERT_TAIL(varlist, newvar, entries);									}								}								if (prev)									ast_free(prev);								ies.vars = NULL;								ast_channel_datastore_add(c, variablestore);							} else {								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");								if (variablestore)									ast_datastore_free(variablestore);								if (varlist)									ast_free(varlist);							}
variablestore && varlist
variablestore
variablestore
varlist
varlist
{								variablestore->data = varlist;								variablestore->inheritance = DATASTORE_INHERIT_FOREVER;								AST_LIST_HEAD_INIT(varlist);								for (var = ies.vars; var; var = var->next) {									struct ast_var_t *newvar = ast_var_assign(var->name, var->value);									if (prev)										ast_free(prev);									prev = var;									if (!newvar) {										/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */										ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									} else {										AST_LIST_INSERT_TAIL(varlist, newvar, entries);									}								}								if (prev)									ast_free(prev);								ies.vars = NULL;								ast_channel_datastore_add(c, variablestore);							}
variablestore->data = varlist;
variablestore->data = varlist
variablestore->data
variablestore
variablestore
data
varlist
varlist
variablestore->inheritance = DATASTORE_INHERIT_FOREVER;
variablestore->inheritance = DATASTORE_INHERIT_FOREVER
variablestore->inheritance
variablestore
variablestore
inheritance
DATASTORE_INHERIT_FOREVER
DATASTORE_INHERIT_FOREVER
AST_LIST_HEAD_INIT(varlist);
AST_LIST_HEAD_INIT(varlist);
AST_LIST_HEAD_INIT
AST_LIST_HEAD_INIT
(varlist)
varlist
varlist
for (var = ies.vars; var; var = var->next) {									struct ast_var_t *newvar = ast_var_assign(var->name, var->value);									if (prev)										ast_free(prev);									prev = var;									if (!newvar) {										/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */										ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									} else {										AST_LIST_INSERT_TAIL(varlist, newvar, entries);									}								}
var = ies.vars;
var = ies.vars
var
var
ies.vars
ies
ies
vars
var
var
var = var->next
var
var
var->next
var
var
next
{									struct ast_var_t *newvar = ast_var_assign(var->name, var->value);									if (prev)										ast_free(prev);									prev = var;									if (!newvar) {										/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */										ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									} else {										AST_LIST_INSERT_TAIL(varlist, newvar, entries);									}								}
struct ast_var_t *newvar = ast_var_assign(var->name, var->value);
struct ast_var_t *newvar = ast_var_assign(var->name, var->value);
struct ast_var_t
ast_var_t
*newvar = ast_var_assign(var->name, var->value)
*
newvar
= ast_var_assign(var->name, var->value)
ast_var_assign(var->name, var->value)
ast_var_assign
ast_var_assign
var->name
var
var
name
var->value
var
var
value
if (prev)										ast_free(prev);
prev
prev
ast_free(prev);
ast_free(prev)
ast_free
ast_free
prev
prev
prev = var;
prev = var
prev
prev
var
var
if (!newvar) {										/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */										ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									} else {										AST_LIST_INSERT_TAIL(varlist, newvar, entries);									}
!newvar
newvar
newvar
{										/* Don't abort list traversal, as this would leave ies.vars in an inconsistent state. */										ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");									}
ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");
ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n")
ast_log
ast_log
LOG_ERROR
LOG_ERROR
"Memory allocation error while processing IAX2 variables\n"
{										AST_LIST_INSERT_TAIL(varlist, newvar, entries);									}
AST_LIST_INSERT_TAIL(varlist, newvar, entries);
AST_LIST_INSERT_TAIL(varlist, newvar, entries)
AST_LIST_INSERT_TAIL
AST_LIST_INSERT_TAIL
varlist
varlist
newvar
newvar
entries
entries
if (prev)									ast_free(prev);
prev
prev
ast_free(prev);
ast_free(prev)
ast_free
ast_free
prev
prev
ies.vars = NULL;
ies.vars = NULL
ies.vars
ies
ies
vars
NULL
NULL
ast_channel_datastore_add(c, variablestore);
ast_channel_datastore_add(c, variablestore)
ast_channel_datastore_add
ast_channel_datastore_add
c
c
variablestore
variablestore
{								ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");								if (variablestore)									ast_datastore_free(variablestore);								if (varlist)									ast_free(varlist);							}
ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");
ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n")
ast_log
ast_log
LOG_ERROR
LOG_ERROR
"Memory allocation error while processing IAX2 variables\n"
if (variablestore)									ast_datastore_free(variablestore);
variablestore
variablestore
ast_datastore_free(variablestore);
ast_datastore_free(variablestore)
ast_datastore_free
ast_datastore_free
variablestore
variablestore
if (varlist)									ast_free(varlist);
varlist
varlist
ast_free(varlist);
ast_free(varlist);
ast_free
ast_free
(varlist)
varlist
varlist
break;
case IAX_COMMAND_INVAL:
IAX_COMMAND_INVAL
IAX_COMMAND_INVAL
iaxs[fr->callno]->error = ENOTCONN;
iaxs[fr->callno]->error = ENOTCONN
iaxs[fr->callno]->error
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
error
ENOTCONN
ENOTCONN
ast_debug(1, "Immediately destroying %d, having received INVAL\n", fr->callno);
ast_debug(1, "Immediately destroying %d, having received INVAL\n", fr->callno)
ast_debug
ast_debug
1
"Immediately destroying %d, having received INVAL\n"
fr->callno
fr
fr
callno
iax2_destroy(fr->callno);
iax2_destroy(fr->callno)
iax2_destroy
iax2_destroy
fr->callno
fr
fr
callno
ast_debug(1, "Destroying call %d\n", fr->callno);
ast_debug(1, "Destroying call %d\n", fr->callno)
ast_debug
ast_debug
1
"Destroying call %d\n"
fr->callno
fr
fr
callno
break;
case IAX_COMMAND_VNAK:
IAX_COMMAND_VNAK
IAX_COMMAND_VNAK
ast_debug(1, "Received VNAK: resending outstanding frames\n");
ast_debug(1, "Received VNAK: resending outstanding frames\n")
ast_debug
ast_debug
1
"Received VNAK: resending outstanding frames\n"
vnak_retransmit(fr->callno, fr->iseqno);
vnak_retransmit(fr->callno, fr->iseqno)
vnak_retransmit
vnak_retransmit
fr->callno
fr
fr
callno
fr->iseqno
fr
fr
iseqno
break;
case IAX_COMMAND_REGREQ:
IAX_COMMAND_REGREQ
IAX_COMMAND_REGREQ
case IAX_COMMAND_REGREL:
IAX_COMMAND_REGREL
IAX_COMMAND_REGREL
if (delayreject)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
delayreject
delayreject
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
send_command_immediate
send_command_immediate
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_ACK
IAX_COMMAND_ACK
fr->ts
fr
fr
ts
NULL
NULL
0
fr->iseqno
fr
fr
iseqno
if (register_verify(fr->callno, &sin, &ies)) {					if (!iaxs[fr->callno]) {						break;					}					/* Send delayed failure */					auth_fail(fr->callno, IAX_COMMAND_REGREJ);					break;				}
register_verify(fr->callno, &sin, &ies)
register_verify
register_verify
fr->callno
fr
fr
callno
&sin
sin
sin
&ies
ies
ies
{					if (!iaxs[fr->callno]) {						break;					}					/* Send delayed failure */					auth_fail(fr->callno, IAX_COMMAND_REGREJ);					break;				}
if (!iaxs[fr->callno]) {						break;					}
!iaxs[fr->callno]
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{						break;					}
break;
auth_fail(fr->callno, IAX_COMMAND_REGREJ);
auth_fail(fr->callno, IAX_COMMAND_REGREJ)
auth_fail
auth_fail
fr->callno
fr
fr
callno
IAX_COMMAND_REGREJ
IAX_COMMAND_REGREJ
break;
if (!iaxs[fr->callno]) {					break;				}
!iaxs[fr->callno]
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{					break;				}
break;
if ((ast_strlen_zero(iaxs[fr->callno]->secret) && ast_strlen_zero(iaxs[fr->callno]->inkeys)) ||						ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED)) {					if (f.subclass.integer == IAX_COMMAND_REGREL) {						memset(&sin, 0, sizeof(sin));						sin.sin_family = AF_INET;					}					if (update_registry(&sin, fr->callno, ies.devicetype, fd, ies.refresh)) {						ast_log(LOG_WARNING, "Registry error\n");					}					if (!iaxs[fr->callno]) {						break;					}					if (ies.provverpres && ies.serviceident && sin.sin_addr.s_addr) {						ast_mutex_unlock(&iaxsl[fr->callno]);						check_provisioning(&sin, fd, ies.serviceident, ies.provver);						ast_mutex_lock(&iaxsl[fr->callno]);					}					break;				}
(ast_strlen_zero(iaxs[fr->callno]->secret) && ast_strlen_zero(iaxs[fr->callno]->inkeys)) ||						ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED)
(ast_strlen_zero(iaxs[fr->callno]->secret) && ast_strlen_zero(iaxs[fr->callno]->inkeys))
ast_strlen_zero(iaxs[fr->callno]->secret) && ast_strlen_zero(iaxs[fr->callno]->inkeys)
ast_strlen_zero(iaxs[fr->callno]->secret)
ast_strlen_zero
ast_strlen_zero
iaxs[fr->callno]->secret
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
secret
ast_strlen_zero(iaxs[fr->callno]->inkeys)
ast_strlen_zero
ast_strlen_zero
iaxs[fr->callno]->inkeys
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
inkeys
ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED)
ast_test_flag
ast_test_flag
&iaxs[fr->callno]->state
iaxs[fr->callno]->state
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
state
IAX_STATE_AUTHENTICATED
IAX_STATE_AUTHENTICATED
{					if (f.subclass.integer == IAX_COMMAND_REGREL) {						memset(&sin, 0, sizeof(sin));						sin.sin_family = AF_INET;					}					if (update_registry(&sin, fr->callno, ies.devicetype, fd, ies.refresh)) {						ast_log(LOG_WARNING, "Registry error\n");					}					if (!iaxs[fr->callno]) {						break;					}					if (ies.provverpres && ies.serviceident && sin.sin_addr.s_addr) {						ast_mutex_unlock(&iaxsl[fr->callno]);						check_provisioning(&sin, fd, ies.serviceident, ies.provver);						ast_mutex_lock(&iaxsl[fr->callno]);					}					break;				}
if (f.subclass.integer == IAX_COMMAND_REGREL) {						memset(&sin, 0, sizeof(sin));						sin.sin_family = AF_INET;					}
f.subclass.integer == IAX_COMMAND_REGREL
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_REGREL
IAX_COMMAND_REGREL
{						memset(&sin, 0, sizeof(sin));						sin.sin_family = AF_INET;					}
memset(&sin, 0, sizeof(sin));
memset(&sin, 0, sizeof(sin))
memset
memset
&sin
sin
sin
0
sizeof(sin)
(sin)
sin
sin
sin.sin_family = AF_INET;
sin.sin_family = AF_INET
sin.sin_family
sin
sin
sin_family
AF_INET
AF_INET
if (update_registry(&sin, fr->callno, ies.devicetype, fd, ies.refresh)) {						ast_log(LOG_WARNING, "Registry error\n");					}
update_registry(&sin, fr->callno, ies.devicetype, fd, ies.refresh)
update_registry
update_registry
&sin
sin
sin
fr->callno
fr
fr
callno
ies.devicetype
ies
ies
devicetype
fd
fd
ies.refresh
ies
ies
refresh
{						ast_log(LOG_WARNING, "Registry error\n");					}
ast_log(LOG_WARNING, "Registry error\n");
ast_log(LOG_WARNING, "Registry error\n")
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"Registry error\n"
if (!iaxs[fr->callno]) {						break;					}
!iaxs[fr->callno]
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{						break;					}
break;
if (ies.provverpres && ies.serviceident && sin.sin_addr.s_addr) {						ast_mutex_unlock(&iaxsl[fr->callno]);						check_provisioning(&sin, fd, ies.serviceident, ies.provver);						ast_mutex_lock(&iaxsl[fr->callno]);					}
ies.provverpres && ies.serviceident && sin.sin_addr.s_addr
ies.provverpres && ies.serviceident
ies.provverpres
ies
ies
provverpres
ies.serviceident
ies
ies
serviceident
sin.sin_addr.s_addr
sin.sin_addr
sin
sin
sin_addr
s_addr
{						ast_mutex_unlock(&iaxsl[fr->callno]);						check_provisioning(&sin, fd, ies.serviceident, ies.provver);						ast_mutex_lock(&iaxsl[fr->callno]);					}
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock
ast_mutex_unlock
(&iaxsl[fr->callno])
&iaxsl[fr->callno]
&
iaxsl
[fr->callno]
fr->callno
fr
fr
callno
check_provisioning(&sin, fd, ies.serviceident, ies.provver);
check_provisioning(&sin, fd, ies.serviceident, ies.provver)
check_provisioning
check_provisioning
&sin
sin
sin
fd
fd
ies.serviceident
ies
ies
serviceident
ies.provver
ies
ies
provver
ast_mutex_lock(&iaxsl[fr->callno]);
ast_mutex_lock(&iaxsl[fr->callno])
ast_mutex_lock
ast_mutex_lock
&iaxsl[fr->callno]
iaxsl[fr->callno]
iaxsl
iaxsl
fr->callno
fr
fr
callno
break;
registry_authrequest(fr->callno);
registry_authrequest(fr->callno)
registry_authrequest
registry_authrequest
fr->callno
fr
fr
callno
break;
case IAX_COMMAND_REGACK:
IAX_COMMAND_REGACK
IAX_COMMAND_REGACK
if (iax2_ack_registry(&ies, &sin, fr->callno)) 					ast_log(LOG_WARNING, "Registration failure\n");
iax2_ack_registry(&ies, &sin, fr->callno)
iax2_ack_registry
iax2_ack_registry
&ies
ies
ies
&sin
sin
sin
fr->callno
fr
fr
callno
ast_log(LOG_WARNING, "Registration failure\n");
ast_log(LOG_WARNING, "Registration failure\n")
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"Registration failure\n"
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
send_command_immediate
send_command_immediate
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_ACK
IAX_COMMAND_ACK
fr->ts
fr
fr
ts
NULL
NULL
0
fr->iseqno
fr
fr
iseqno
iax2_destroy(fr->callno);
iax2_destroy(fr->callno)
iax2_destroy
iax2_destroy
fr->callno
fr
fr
callno
break;
case IAX_COMMAND_REGREJ:
IAX_COMMAND_REGREJ
IAX_COMMAND_REGREJ
if (iaxs[fr->callno]->reg) {					if (authdebug) {						ast_log(LOG_NOTICE, "Registration of '%s' rejected: '%s' from: '%s'\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>", ast_inet_ntoa(sin.sin_addr));						manager_event(EVENT_FLAG_SYSTEM, "Registry", "ChannelType: IAX2\r\nUsername: %s\r\nStatus: Rejected\r\nCause: %s\r\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>");					}					iaxs[fr->callno]->reg->regstate = REG_STATE_REJECTED;				}
iaxs[fr->callno]->reg
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
reg
{					if (authdebug) {						ast_log(LOG_NOTICE, "Registration of '%s' rejected: '%s' from: '%s'\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>", ast_inet_ntoa(sin.sin_addr));						manager_event(EVENT_FLAG_SYSTEM, "Registry", "ChannelType: IAX2\r\nUsername: %s\r\nStatus: Rejected\r\nCause: %s\r\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>");					}					iaxs[fr->callno]->reg->regstate = REG_STATE_REJECTED;				}
if (authdebug) {						ast_log(LOG_NOTICE, "Registration of '%s' rejected: '%s' from: '%s'\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>", ast_inet_ntoa(sin.sin_addr));						manager_event(EVENT_FLAG_SYSTEM, "Registry", "ChannelType: IAX2\r\nUsername: %s\r\nStatus: Rejected\r\nCause: %s\r\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>");					}
authdebug
authdebug
{						ast_log(LOG_NOTICE, "Registration of '%s' rejected: '%s' from: '%s'\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>", ast_inet_ntoa(sin.sin_addr));						manager_event(EVENT_FLAG_SYSTEM, "Registry", "ChannelType: IAX2\r\nUsername: %s\r\nStatus: Rejected\r\nCause: %s\r\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>");					}
ast_log(LOG_NOTICE, "Registration of '%s' rejected: '%s' from: '%s'\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>", ast_inet_ntoa(sin.sin_addr));
ast_log(LOG_NOTICE, "Registration of '%s' rejected: '%s' from: '%s'\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>", ast_inet_ntoa(sin.sin_addr))
ast_log
ast_log
LOG_NOTICE
LOG_NOTICE
"Registration of '%s' rejected: '%s' from: '%s'\n"
iaxs[fr->callno]->reg->username
iaxs[fr->callno]->reg
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
reg
username
ies.cause ? ies.cause : "<unknown>"
ies.cause
ies
ies
cause
ies.cause
ies
ies
cause
"<unknown>"
ast_inet_ntoa(sin.sin_addr)
ast_inet_ntoa
ast_inet_ntoa
sin.sin_addr
sin
sin
sin_addr
manager_event(EVENT_FLAG_SYSTEM, "Registry", "ChannelType: IAX2\r\nUsername: %s\r\nStatus: Rejected\r\nCause: %s\r\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>");
manager_event(EVENT_FLAG_SYSTEM, "Registry", "ChannelType: IAX2\r\nUsername: %s\r\nStatus: Rejected\r\nCause: %s\r\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>")
manager_event
manager_event
EVENT_FLAG_SYSTEM
EVENT_FLAG_SYSTEM
"Registry"
"ChannelType: IAX2\r\nUsername: %s\r\nStatus: Rejected\r\nCause: %s\r\n"
iaxs[fr->callno]->reg->username
iaxs[fr->callno]->reg
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
reg
username
ies.cause ? ies.cause : "<unknown>"
ies.cause
ies
ies
cause
ies.cause
ies
ies
cause
"<unknown>"
iaxs[fr->callno]->reg->regstate = REG_STATE_REJECTED;
iaxs[fr->callno]->reg->regstate = REG_STATE_REJECTED
iaxs[fr->callno]->reg->regstate
iaxs[fr->callno]->reg
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
reg
regstate
REG_STATE_REJECTED
REG_STATE_REJECTED
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
send_command_immediate
send_command_immediate
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_ACK
IAX_COMMAND_ACK
fr->ts
fr
fr
ts
NULL
NULL
0
fr->iseqno
fr
fr
iseqno
iax2_destroy(fr->callno);
iax2_destroy(fr->callno)
iax2_destroy
iax2_destroy
fr->callno
fr
fr
callno
break;
case IAX_COMMAND_REGAUTH:
IAX_COMMAND_REGAUTH
IAX_COMMAND_REGAUTH
if (registry_rerequest(&ies, fr->callno, &sin)) {					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No authority found");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_FACILITY_NOT_SUBSCRIBED);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);				}
registry_rerequest(&ies, fr->callno, &sin)
registry_rerequest
registry_rerequest
&ies
ies
ies
fr->callno
fr
fr
callno
&sin
sin
sin
{					memset(&ied0, 0, sizeof(ied0));					iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No authority found");					iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_FACILITY_NOT_SUBSCRIBED);					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);				}
memset(&ied0, 0, sizeof(ied0));
memset(&ied0, 0, sizeof(ied0))
memset
memset
&ied0
ied0
ied0
0
sizeof(ied0)
(ied0)
ied0
ied0
iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No authority found");
iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No authority found")
iax_ie_append_str
iax_ie_append_str
&ied0
ied0
ied0
IAX_IE_CAUSE
IAX_IE_CAUSE
"No authority found"
iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_FACILITY_NOT_SUBSCRIBED);
iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_FACILITY_NOT_SUBSCRIBED)
iax_ie_append_byte
iax_ie_append_byte
&ied0
ied0
ied0
IAX_IE_CAUSECODE
IAX_IE_CAUSECODE
AST_CAUSE_FACILITY_NOT_SUBSCRIBED
AST_CAUSE_FACILITY_NOT_SUBSCRIBED
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1)
send_command_final
send_command_final
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_REJECT
IAX_COMMAND_REJECT
0
ied0.buf
ied0
ied0
buf
ied0.pos
ied0
ied0
pos
-1
1
break;
case IAX_COMMAND_TXREJ:
IAX_COMMAND_TXREJ
IAX_COMMAND_TXREJ
iaxs[fr->callno]->transferring = 0;
iaxs[fr->callno]->transferring = 0
iaxs[fr->callno]->transferring
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
transferring
0
ast_verb(3, "Channel '%s' unable to transfer\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");
ast_verb(3, "Channel '%s' unable to transfer\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>")
ast_verb
ast_verb
3
"Channel '%s' unable to transfer\n"
iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>"
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
ast_channel_name(iaxs[fr->callno]->owner)
ast_channel_name
ast_channel_name
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
"<Unknown>"
memset(&iaxs[fr->callno]->transfer, 0, sizeof(iaxs[fr->callno]->transfer));
memset(&iaxs[fr->callno]->transfer, 0, sizeof(iaxs[fr->callno]->transfer))
memset
memset
&iaxs[fr->callno]->transfer
iaxs[fr->callno]->transfer
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
transfer
0
sizeof(iaxs[fr->callno]->transfer)
(iaxs[fr->callno]->transfer)
iaxs[fr->callno]->transfer
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
transfer
if (iaxs[fr->callno]->bridgecallno) {					if (iaxs[iaxs[fr->callno]->bridgecallno]->transferring) {						iaxs[iaxs[fr->callno]->bridgecallno]->transferring = 0;						send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREJ, 0, NULL, 0, -1);					}				}
iaxs[fr->callno]->bridgecallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
bridgecallno
{					if (iaxs[iaxs[fr->callno]->bridgecallno]->transferring) {						iaxs[iaxs[fr->callno]->bridgecallno]->transferring = 0;						send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREJ, 0, NULL, 0, -1);					}				}
if (iaxs[iaxs[fr->callno]->bridgecallno]->transferring) {						iaxs[iaxs[fr->callno]->bridgecallno]->transferring = 0;						send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREJ, 0, NULL, 0, -1);					}
iaxs[iaxs[fr->callno]->bridgecallno]->transferring
iaxs[iaxs[fr->callno]->bridgecallno]
iaxs
iaxs
iaxs[fr->callno]->bridgecallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
bridgecallno
transferring
{						iaxs[iaxs[fr->callno]->bridgecallno]->transferring = 0;						send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREJ, 0, NULL, 0, -1);					}
iaxs[iaxs[fr->callno]->bridgecallno]->transferring = 0;
iaxs[iaxs[fr->callno]->bridgecallno]->transferring = 0
iaxs[iaxs[fr->callno]->bridgecallno]->transferring
iaxs[iaxs[fr->callno]->bridgecallno]
iaxs
iaxs
iaxs[fr->callno]->bridgecallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
bridgecallno
transferring
0
send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREJ, 0, NULL, 0, -1);
send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREJ, 0, NULL, 0, -1)
send_command
send_command
iaxs[iaxs[fr->callno]->bridgecallno]
iaxs
iaxs
iaxs[fr->callno]->bridgecallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
bridgecallno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_TXREJ
IAX_COMMAND_TXREJ
0
NULL
NULL
0
-1
1
break;
case IAX_COMMAND_TXREADY:
IAX_COMMAND_TXREADY
IAX_COMMAND_TXREADY
if ((iaxs[fr->callno]->transferring == TRANSFER_BEGIN) ||				    (iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)) {					if (iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)						iaxs[fr->callno]->transferring = TRANSFER_MREADY;					else						iaxs[fr->callno]->transferring = TRANSFER_READY;					ast_verb(3, "Channel '%s' ready to transfer\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					if (iaxs[fr->callno]->bridgecallno) {						if ((iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_READY) ||						    (iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_MREADY)) {							/* They're both ready, now release them. */							if (iaxs[fr->callno]->transferring == TRANSFER_MREADY) {								ast_verb(3, "Attempting media bridge of %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_MEDIA;								iaxs[fr->callno]->transferring = TRANSFER_MEDIA;								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied1.buf, ied1.pos, -1);							} else {								ast_verb(3, "Releasing %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_RELEASED;								iaxs[fr->callno]->transferring = TRANSFER_RELEASED;								ast_set_flag64(iaxs[iaxs[fr->callno]->bridgecallno], IAX_ALREADYGONE);								ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);								/* Stop doing lag & ping requests */								stop_stuff(fr->callno);								stop_stuff(iaxs[fr->callno]->bridgecallno);								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied1.buf, ied1.pos, -1);							}						}					}				}
(iaxs[fr->callno]->transferring == TRANSFER_BEGIN) ||				    (iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)
(iaxs[fr->callno]->transferring == TRANSFER_BEGIN)
iaxs[fr->callno]->transferring == TRANSFER_BEGIN
iaxs[fr->callno]->transferring
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
transferring
TRANSFER_BEGIN
TRANSFER_BEGIN
(iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)
iaxs[fr->callno]->transferring == TRANSFER_MBEGIN
iaxs[fr->callno]->transferring
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
transferring
TRANSFER_MBEGIN
TRANSFER_MBEGIN
{					if (iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)						iaxs[fr->callno]->transferring = TRANSFER_MREADY;					else						iaxs[fr->callno]->transferring = TRANSFER_READY;					ast_verb(3, "Channel '%s' ready to transfer\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");					if (iaxs[fr->callno]->bridgecallno) {						if ((iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_READY) ||						    (iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_MREADY)) {							/* They're both ready, now release them. */							if (iaxs[fr->callno]->transferring == TRANSFER_MREADY) {								ast_verb(3, "Attempting media bridge of %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_MEDIA;								iaxs[fr->callno]->transferring = TRANSFER_MEDIA;								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied1.buf, ied1.pos, -1);							} else {								ast_verb(3, "Releasing %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_RELEASED;								iaxs[fr->callno]->transferring = TRANSFER_RELEASED;								ast_set_flag64(iaxs[iaxs[fr->callno]->bridgecallno], IAX_ALREADYGONE);								ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);								/* Stop doing lag & ping requests */								stop_stuff(fr->callno);								stop_stuff(iaxs[fr->callno]->bridgecallno);								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied1.buf, ied1.pos, -1);							}						}					}				}
if (iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)						iaxs[fr->callno]->transferring = TRANSFER_MREADY;					else						iaxs[fr->callno]->transferring = TRANSFER_READY;
iaxs[fr->callno]->transferring == TRANSFER_MBEGIN
iaxs[fr->callno]->transferring
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
transferring
TRANSFER_MBEGIN
TRANSFER_MBEGIN
iaxs[fr->callno]->transferring = TRANSFER_MREADY;
iaxs[fr->callno]->transferring = TRANSFER_MREADY
iaxs[fr->callno]->transferring
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
transferring
TRANSFER_MREADY
TRANSFER_MREADY
iaxs[fr->callno]->transferring = TRANSFER_READY;
iaxs[fr->callno]->transferring = TRANSFER_READY
iaxs[fr->callno]->transferring
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
transferring
TRANSFER_READY
TRANSFER_READY
ast_verb(3, "Channel '%s' ready to transfer\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>");
ast_verb(3, "Channel '%s' ready to transfer\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>")
ast_verb
ast_verb
3
"Channel '%s' ready to transfer\n"
iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>"
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
ast_channel_name(iaxs[fr->callno]->owner)
ast_channel_name
ast_channel_name
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
"<Unknown>"
if (iaxs[fr->callno]->bridgecallno) {						if ((iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_READY) ||						    (iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_MREADY)) {							/* They're both ready, now release them. */							if (iaxs[fr->callno]->transferring == TRANSFER_MREADY) {								ast_verb(3, "Attempting media bridge of %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_MEDIA;								iaxs[fr->callno]->transferring = TRANSFER_MEDIA;								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied1.buf, ied1.pos, -1);							} else {								ast_verb(3, "Releasing %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_RELEASED;								iaxs[fr->callno]->transferring = TRANSFER_RELEASED;								ast_set_flag64(iaxs[iaxs[fr->callno]->bridgecallno], IAX_ALREADYGONE);								ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);								/* Stop doing lag & ping requests */								stop_stuff(fr->callno);								stop_stuff(iaxs[fr->callno]->bridgecallno);								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied1.buf, ied1.pos, -1);							}						}					}
iaxs[fr->callno]->bridgecallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
bridgecallno
{						if ((iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_READY) ||						    (iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_MREADY)) {							/* They're both ready, now release them. */							if (iaxs[fr->callno]->transferring == TRANSFER_MREADY) {								ast_verb(3, "Attempting media bridge of %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_MEDIA;								iaxs[fr->callno]->transferring = TRANSFER_MEDIA;								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied1.buf, ied1.pos, -1);							} else {								ast_verb(3, "Releasing %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_RELEASED;								iaxs[fr->callno]->transferring = TRANSFER_RELEASED;								ast_set_flag64(iaxs[iaxs[fr->callno]->bridgecallno], IAX_ALREADYGONE);								ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);								/* Stop doing lag & ping requests */								stop_stuff(fr->callno);								stop_stuff(iaxs[fr->callno]->bridgecallno);								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied1.buf, ied1.pos, -1);							}						}					}
if ((iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_READY) ||						    (iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_MREADY)) {							/* They're both ready, now release them. */							if (iaxs[fr->callno]->transferring == TRANSFER_MREADY) {								ast_verb(3, "Attempting media bridge of %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_MEDIA;								iaxs[fr->callno]->transferring = TRANSFER_MEDIA;								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied1.buf, ied1.pos, -1);							} else {								ast_verb(3, "Releasing %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_RELEASED;								iaxs[fr->callno]->transferring = TRANSFER_RELEASED;								ast_set_flag64(iaxs[iaxs[fr->callno]->bridgecallno], IAX_ALREADYGONE);								ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);								/* Stop doing lag & ping requests */								stop_stuff(fr->callno);								stop_stuff(iaxs[fr->callno]->bridgecallno);								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied1.buf, ied1.pos, -1);							}						}
(iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_READY) ||						    (iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_MREADY)
(iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_READY)
iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_READY
iaxs[iaxs[fr->callno]->bridgecallno]->transferring
iaxs[iaxs[fr->callno]->bridgecallno]
iaxs
iaxs
iaxs[fr->callno]->bridgecallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
bridgecallno
transferring
TRANSFER_READY
TRANSFER_READY
(iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_MREADY)
iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_MREADY
iaxs[iaxs[fr->callno]->bridgecallno]->transferring
iaxs[iaxs[fr->callno]->bridgecallno]
iaxs
iaxs
iaxs[fr->callno]->bridgecallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
bridgecallno
transferring
TRANSFER_MREADY
TRANSFER_MREADY
{							/* They're both ready, now release them. */							if (iaxs[fr->callno]->transferring == TRANSFER_MREADY) {								ast_verb(3, "Attempting media bridge of %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_MEDIA;								iaxs[fr->callno]->transferring = TRANSFER_MEDIA;								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied1.buf, ied1.pos, -1);							} else {								ast_verb(3, "Releasing %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_RELEASED;								iaxs[fr->callno]->transferring = TRANSFER_RELEASED;								ast_set_flag64(iaxs[iaxs[fr->callno]->bridgecallno], IAX_ALREADYGONE);								ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);								/* Stop doing lag & ping requests */								stop_stuff(fr->callno);								stop_stuff(iaxs[fr->callno]->bridgecallno);								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied1.buf, ied1.pos, -1);							}						}
if (iaxs[fr->callno]->transferring == TRANSFER_MREADY) {								ast_verb(3, "Attempting media bridge of %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_MEDIA;								iaxs[fr->callno]->transferring = TRANSFER_MEDIA;								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied1.buf, ied1.pos, -1);							} else {								ast_verb(3, "Releasing %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_RELEASED;								iaxs[fr->callno]->transferring = TRANSFER_RELEASED;								ast_set_flag64(iaxs[iaxs[fr->callno]->bridgecallno], IAX_ALREADYGONE);								ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);								/* Stop doing lag & ping requests */								stop_stuff(fr->callno);								stop_stuff(iaxs[fr->callno]->bridgecallno);								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied1.buf, ied1.pos, -1);							}
iaxs[fr->callno]->transferring == TRANSFER_MREADY
iaxs[fr->callno]->transferring
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
transferring
TRANSFER_MREADY
TRANSFER_MREADY
{								ast_verb(3, "Attempting media bridge of %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_MEDIA;								iaxs[fr->callno]->transferring = TRANSFER_MEDIA;								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied1.buf, ied1.pos, -1);							}
ast_verb(3, "Attempting media bridge of %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");
ast_verb(3, "Attempting media bridge of %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>")
ast_verb
ast_verb
3
"Attempting media bridge of %s and %s\n"
iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>"
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
ast_channel_name(iaxs[fr->callno]->owner)
ast_channel_name
ast_channel_name
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
"<Unknown>"
iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>"
iaxs[iaxs[fr->callno]->bridgecallno]->owner
iaxs[iaxs[fr->callno]->bridgecallno]
iaxs
iaxs
iaxs[fr->callno]->bridgecallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
bridgecallno
owner
ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner)
ast_channel_name
ast_channel_name
iaxs[iaxs[fr->callno]->bridgecallno]->owner
iaxs[iaxs[fr->callno]->bridgecallno]
iaxs
iaxs
iaxs[fr->callno]->bridgecallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
bridgecallno
owner
"<Unknown>"
iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_MEDIA;
iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_MEDIA
iaxs[iaxs[fr->callno]->bridgecallno]->transferring
iaxs[iaxs[fr->callno]->bridgecallno]
iaxs
iaxs
iaxs[fr->callno]->bridgecallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
bridgecallno
transferring
TRANSFER_MEDIA
TRANSFER_MEDIA
iaxs[fr->callno]->transferring = TRANSFER_MEDIA;
iaxs[fr->callno]->transferring = TRANSFER_MEDIA
iaxs[fr->callno]->transferring
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
transferring
TRANSFER_MEDIA
TRANSFER_MEDIA
memset(&ied0, 0, sizeof(ied0));
memset(&ied0, 0, sizeof(ied0))
memset
memset
&ied0
ied0
ied0
0
sizeof(ied0)
(ied0)
ied0
ied0
memset(&ied1, 0, sizeof(ied1));
memset(&ied1, 0, sizeof(ied1))
memset
memset
&ied1
ied1
ied1
0
sizeof(ied1)
(ied1)
ied1
ied1
iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);
iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno)
iax_ie_append_short
iax_ie_append_short
&ied0
ied0
ied0
IAX_IE_CALLNO
IAX_IE_CALLNO
iaxs[iaxs[fr->callno]->bridgecallno]->peercallno
iaxs[iaxs[fr->callno]->bridgecallno]
iaxs
iaxs
iaxs[fr->callno]->bridgecallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
bridgecallno
peercallno
iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);
iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno)
iax_ie_append_short
iax_ie_append_short
&ied1
ied1
ied1
IAX_IE_CALLNO
IAX_IE_CALLNO
iaxs[fr->callno]->peercallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercallno
send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied0.buf, ied0.pos, -1);
send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied0.buf, ied0.pos, -1)
send_command
send_command
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_TXMEDIA
IAX_COMMAND_TXMEDIA
0
ied0.buf
ied0
ied0
buf
ied0.pos
ied0
ied0
pos
-1
1
send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied1.buf, ied1.pos, -1);
send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied1.buf, ied1.pos, -1)
send_command
send_command
iaxs[iaxs[fr->callno]->bridgecallno]
iaxs
iaxs
iaxs[fr->callno]->bridgecallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
bridgecallno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_TXMEDIA
IAX_COMMAND_TXMEDIA
0
ied1.buf
ied1
ied1
buf
ied1.pos
ied1
ied1
pos
-1
1
{								ast_verb(3, "Releasing %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");								iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_RELEASED;								iaxs[fr->callno]->transferring = TRANSFER_RELEASED;								ast_set_flag64(iaxs[iaxs[fr->callno]->bridgecallno], IAX_ALREADYGONE);								ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);								/* Stop doing lag & ping requests */								stop_stuff(fr->callno);								stop_stuff(iaxs[fr->callno]->bridgecallno);								memset(&ied0, 0, sizeof(ied0));								memset(&ied1, 0, sizeof(ied1));								iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);								iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);								send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied0.buf, ied0.pos, -1);								send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied1.buf, ied1.pos, -1);							}
ast_verb(3, "Releasing %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>");
ast_verb(3, "Releasing %s and %s\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>",										iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>")
ast_verb
ast_verb
3
"Releasing %s and %s\n"
iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner) : "<Unknown>"
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
ast_channel_name(iaxs[fr->callno]->owner)
ast_channel_name
ast_channel_name
iaxs[fr->callno]->owner
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
owner
"<Unknown>"
iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner) : "<Unknown>"
iaxs[iaxs[fr->callno]->bridgecallno]->owner
iaxs[iaxs[fr->callno]->bridgecallno]
iaxs
iaxs
iaxs[fr->callno]->bridgecallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
bridgecallno
owner
ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner)
ast_channel_name
ast_channel_name
iaxs[iaxs[fr->callno]->bridgecallno]->owner
iaxs[iaxs[fr->callno]->bridgecallno]
iaxs
iaxs
iaxs[fr->callno]->bridgecallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
bridgecallno
owner
"<Unknown>"
iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_RELEASED;
iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_RELEASED
iaxs[iaxs[fr->callno]->bridgecallno]->transferring
iaxs[iaxs[fr->callno]->bridgecallno]
iaxs
iaxs
iaxs[fr->callno]->bridgecallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
bridgecallno
transferring
TRANSFER_RELEASED
TRANSFER_RELEASED
iaxs[fr->callno]->transferring = TRANSFER_RELEASED;
iaxs[fr->callno]->transferring = TRANSFER_RELEASED
iaxs[fr->callno]->transferring
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
transferring
TRANSFER_RELEASED
TRANSFER_RELEASED
ast_set_flag64(iaxs[iaxs[fr->callno]->bridgecallno], IAX_ALREADYGONE);
ast_set_flag64(iaxs[iaxs[fr->callno]->bridgecallno], IAX_ALREADYGONE)
ast_set_flag64
ast_set_flag64
iaxs[iaxs[fr->callno]->bridgecallno]
iaxs
iaxs
iaxs[fr->callno]->bridgecallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
bridgecallno
IAX_ALREADYGONE
IAX_ALREADYGONE
ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE);
ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE)
ast_set_flag64
ast_set_flag64
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
IAX_ALREADYGONE
IAX_ALREADYGONE
stop_stuff(fr->callno);
stop_stuff(fr->callno)
stop_stuff
stop_stuff
fr->callno
fr
fr
callno
stop_stuff(iaxs[fr->callno]->bridgecallno);
stop_stuff(iaxs[fr->callno]->bridgecallno)
stop_stuff
stop_stuff
iaxs[fr->callno]->bridgecallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
bridgecallno
memset(&ied0, 0, sizeof(ied0));
memset(&ied0, 0, sizeof(ied0))
memset
memset
&ied0
ied0
ied0
0
sizeof(ied0)
(ied0)
ied0
ied0
memset(&ied1, 0, sizeof(ied1));
memset(&ied1, 0, sizeof(ied1))
memset
memset
&ied1
ied1
ied1
0
sizeof(ied1)
(ied1)
ied1
ied1
iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno);
iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno)
iax_ie_append_short
iax_ie_append_short
&ied0
ied0
ied0
IAX_IE_CALLNO
IAX_IE_CALLNO
iaxs[iaxs[fr->callno]->bridgecallno]->peercallno
iaxs[iaxs[fr->callno]->bridgecallno]
iaxs
iaxs
iaxs[fr->callno]->bridgecallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
bridgecallno
peercallno
iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno);
iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno)
iax_ie_append_short
iax_ie_append_short
&ied1
ied1
ied1
IAX_IE_CALLNO
IAX_IE_CALLNO
iaxs[fr->callno]->peercallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercallno
send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied0.buf, ied0.pos, -1);
send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied0.buf, ied0.pos, -1)
send_command
send_command
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_TXREL
IAX_COMMAND_TXREL
0
ied0.buf
ied0
ied0
buf
ied0.pos
ied0
ied0
pos
-1
1
send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied1.buf, ied1.pos, -1);
send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied1.buf, ied1.pos, -1)
send_command
send_command
iaxs[iaxs[fr->callno]->bridgecallno]
iaxs
iaxs
iaxs[fr->callno]->bridgecallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
bridgecallno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_TXREL
IAX_COMMAND_TXREL
0
ied1.buf
ied1
ied1
buf
ied1.pos
ied1
ied1
pos
-1
1
break;
case IAX_COMMAND_TXREQ:
IAX_COMMAND_TXREQ
IAX_COMMAND_TXREQ
try_transfer(iaxs[fr->callno], &ies);
try_transfer(iaxs[fr->callno], &ies)
try_transfer
try_transfer
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
&ies
ies
ies
break;
case IAX_COMMAND_TXCNT:
IAX_COMMAND_TXCNT
IAX_COMMAND_TXCNT
if (iaxs[fr->callno]->transferring)					send_command_transfer(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXACC, 0, NULL, 0);
iaxs[fr->callno]->transferring
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
transferring
send_command_transfer(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXACC, 0, NULL, 0);
send_command_transfer(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXACC, 0, NULL, 0)
send_command_transfer
send_command_transfer
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_TXACC
IAX_COMMAND_TXACC
0
NULL
NULL
0
break;
case IAX_COMMAND_TXREL:
IAX_COMMAND_TXREL
IAX_COMMAND_TXREL
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
send_command_immediate
send_command_immediate
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_ACK
IAX_COMMAND_ACK
fr->ts
fr
fr
ts
NULL
NULL
0
fr->iseqno
fr
fr
iseqno
complete_transfer(fr->callno, &ies);
complete_transfer(fr->callno, &ies)
complete_transfer
complete_transfer
fr->callno
fr
fr
callno
&ies
ies
ies
stop_stuff(fr->callno);
stop_stuff(fr->callno)
stop_stuff
stop_stuff
fr->callno
fr
fr
callno
break;
case IAX_COMMAND_TXMEDIA:
IAX_COMMAND_TXMEDIA
IAX_COMMAND_TXMEDIA
if (iaxs[fr->callno]->transferring == TRANSFER_READY) {					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* Cancel any outstanding frames and start anew */						if (cur->transfer) {							cur->retries = -1;						}					}					/* Start sending our media to the transfer address, but otherwise leave the call as-is */					iaxs[fr->callno]->transferring = TRANSFER_MEDIAPASS;				}
iaxs[fr->callno]->transferring == TRANSFER_READY
iaxs[fr->callno]->transferring
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
transferring
TRANSFER_READY
TRANSFER_READY
{					AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list) {						/* Cancel any outstanding frames and start anew */						if (cur->transfer) {							cur->retries = -1;						}					}					/* Start sending our media to the transfer address, but otherwise leave the call as-is */					iaxs[fr->callno]->transferring = TRANSFER_MEDIAPASS;				}
AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list)
AST_LIST_TRAVERSE(&frame_queue[fr->callno], cur, list)
AST_LIST_TRAVERSE
AST_LIST_TRAVERSE
&frame_queue[fr->callno]
frame_queue[fr->callno]
frame_queue
frame_queue
fr->callno
fr
fr
callno
cur
cur
list
list
)
{						/* Cancel any outstanding frames and start anew */						if (cur->transfer) {							cur->retries = -1;						}					}
if (cur->transfer) {							cur->retries = -1;						}
cur->transfer
cur
cur
transfer
{							cur->retries = -1;						}
cur->retries = -1;
cur->retries = -1
cur->retries
cur
cur
retries
-1
1
iaxs[fr->callno]->transferring = TRANSFER_MEDIAPASS;
iaxs[fr->callno]->transferring = TRANSFER_MEDIAPASS
iaxs[fr->callno]->transferring
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
transferring
TRANSFER_MEDIAPASS
TRANSFER_MEDIAPASS
break;
case IAX_COMMAND_RTKEY:
IAX_COMMAND_RTKEY
IAX_COMMAND_RTKEY
if (!IAX_CALLENCRYPTED(iaxs[fr->callno])) {					ast_log(LOG_WARNING, 						"we've been told to rotate our encryption key, "						"but this isn't an encrypted call. bad things will happen.\n"					);					break;				}
!IAX_CALLENCRYPTED(iaxs[fr->callno])
IAX_CALLENCRYPTED(iaxs[fr->callno])
IAX_CALLENCRYPTED
IAX_CALLENCRYPTED
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
{					ast_log(LOG_WARNING, 						"we've been told to rotate our encryption key, "						"but this isn't an encrypted call. bad things will happen.\n"					);					break;				}
ast_log(LOG_WARNING, 						"we've been told to rotate our encryption key, "						"but this isn't an encrypted call. bad things will happen.\n"					);
ast_log(LOG_WARNING, 						"we've been told to rotate our encryption key, "						"but this isn't an encrypted call. bad things will happen.\n"					)
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"we've been told to rotate our encryption key, "						"but this isn't an encrypted call. bad things will happen.\n"
break;
IAX_DEBUGDIGEST("Receiving", ies.challenge);
IAX_DEBUGDIGEST("Receiving", ies.challenge)
IAX_DEBUGDIGEST
IAX_DEBUGDIGEST
"Receiving"
ies.challenge
ies
ies
challenge
ast_aes_set_decrypt_key((unsigned char *) ies.challenge, &iaxs[fr->callno]->dcx);
ast_aes_set_decrypt_key((unsigned char *) ies.challenge, &iaxs[fr->callno]->dcx)
ast_aes_set_decrypt_key
ast_aes_set_decrypt_key
(unsigned char *) ies.challenge
unsigned char *
unsigned char
*
*
ies.challenge
ies
ies
challenge
&iaxs[fr->callno]->dcx
iaxs[fr->callno]->dcx
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
dcx
break;
case IAX_COMMAND_DPREP:
IAX_COMMAND_DPREP
IAX_COMMAND_DPREP
complete_dpreply(iaxs[fr->callno], &ies);
complete_dpreply(iaxs[fr->callno], &ies)
complete_dpreply
complete_dpreply
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
&ies
ies
ies
break;
case IAX_COMMAND_UNSUPPORT:
IAX_COMMAND_UNSUPPORT
IAX_COMMAND_UNSUPPORT
ast_log(LOG_NOTICE, "Peer did not understand our iax command '%d'\n", ies.iax_unknown);
ast_log(LOG_NOTICE, "Peer did not understand our iax command '%d'\n", ies.iax_unknown)
ast_log
ast_log
LOG_NOTICE
LOG_NOTICE
"Peer did not understand our iax command '%d'\n"
ies.iax_unknown
ies
ies
iax_unknown
break;
case IAX_COMMAND_FWDOWNL:
IAX_COMMAND_FWDOWNL
IAX_COMMAND_FWDOWNL
if (!ast_test_flag64(&globalflags, IAX_ALLOWFWDOWNLOAD)) {					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_UNSUPPORT, 0, NULL, 0, -1);					break;				}
!ast_test_flag64(&globalflags, IAX_ALLOWFWDOWNLOAD)
ast_test_flag64(&globalflags, IAX_ALLOWFWDOWNLOAD)
ast_test_flag64
ast_test_flag64
&globalflags
globalflags
globalflags
IAX_ALLOWFWDOWNLOAD
IAX_ALLOWFWDOWNLOAD
{					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_UNSUPPORT, 0, NULL, 0, -1);					break;				}
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_UNSUPPORT, 0, NULL, 0, -1);
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_UNSUPPORT, 0, NULL, 0, -1)
send_command_final
send_command_final
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_UNSUPPORT
IAX_COMMAND_UNSUPPORT
0
NULL
NULL
0
-1
1
break;
memset(&ied0, 0, sizeof(ied0));
memset(&ied0, 0, sizeof(ied0))
memset
memset
&ied0
ied0
ied0
0
sizeof(ied0)
(ied0)
ied0
ied0
res = iax_firmware_append(&ied0, (unsigned char *)ies.devicetype, ies.fwdesc);
res = iax_firmware_append(&ied0, (unsigned char *)ies.devicetype, ies.fwdesc)
res
res
iax_firmware_append(&ied0, (unsigned char *)ies.devicetype, ies.fwdesc)
iax_firmware_append
iax_firmware_append
&ied0
ied0
ied0
(unsigned char *)ies.devicetype
unsigned char *
unsigned char
*
*
ies.devicetype
ies
ies
devicetype
ies.fwdesc
ies
ies
fwdesc
if (res < 0)					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);				else if (res > 0)					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1);				else					send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1);
res < 0
res
res
0
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1);
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1)
send_command_final
send_command_final
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_REJECT
IAX_COMMAND_REJECT
0
ied0.buf
ied0
ied0
buf
ied0.pos
ied0
ied0
pos
-1
1
if (res > 0)					send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1);				else					send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1);
res > 0
res
res
0
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1);
send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1)
send_command_final
send_command_final
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_FWDATA
IAX_COMMAND_FWDATA
0
ied0.buf
ied0
ied0
buf
ied0.pos
ied0
ied0
pos
-1
1
send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1);
send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1)
send_command
send_command
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_FWDATA
IAX_COMMAND_FWDATA
0
ied0.buf
ied0
ied0
buf
ied0.pos
ied0
ied0
pos
-1
1
break;
case IAX_COMMAND_CALLTOKEN:
IAX_COMMAND_CALLTOKEN
IAX_COMMAND_CALLTOKEN
{				struct iax_frame *cur;				/* find last sent frame */				if ((cur = AST_LIST_LAST(&frame_queue[fr->callno])) && ies.calltoken && ies.calltokendata) {					resend_with_token(fr->callno, cur, (char *) ies.calltokendata);				}				break;			}
struct iax_frame *cur;
struct iax_frame *cur;
struct iax_frame
iax_frame
*cur
*
cur
if ((cur = AST_LIST_LAST(&frame_queue[fr->callno])) && ies.calltoken && ies.calltokendata) {					resend_with_token(fr->callno, cur, (char *) ies.calltokendata);				}
(cur = AST_LIST_LAST(&frame_queue[fr->callno])) && ies.calltoken && ies.calltokendata
(cur = AST_LIST_LAST(&frame_queue[fr->callno])) && ies.calltoken
(cur = AST_LIST_LAST(&frame_queue[fr->callno]))
cur = AST_LIST_LAST(&frame_queue[fr->callno])
cur
cur
AST_LIST_LAST(&frame_queue[fr->callno])
AST_LIST_LAST
AST_LIST_LAST
&frame_queue[fr->callno]
frame_queue[fr->callno]
frame_queue
frame_queue
fr->callno
fr
fr
callno
ies.calltoken
ies
ies
calltoken
ies.calltokendata
ies
ies
calltokendata
{					resend_with_token(fr->callno, cur, (char *) ies.calltokendata);				}
resend_with_token(fr->callno, cur, (char *) ies.calltokendata);
resend_with_token(fr->callno, cur, (char *) ies.calltokendata)
resend_with_token
resend_with_token
fr->callno
fr
fr
callno
cur
cur
(char *) ies.calltokendata
char *
char
*
*
ies.calltokendata
ies
ies
calltokendata
break;
default:
ast_debug(1, "Unknown IAX command %d on %d/%d\n", f.subclass.integer, fr->callno, iaxs[fr->callno]->peercallno);
ast_debug(1, "Unknown IAX command %d on %d/%d\n", f.subclass.integer, fr->callno, iaxs[fr->callno]->peercallno)
ast_debug
ast_debug
1
"Unknown IAX command %d on %d/%d\n"
f.subclass.integer
f.subclass
f
f
subclass
integer
fr->callno
fr
fr
callno
iaxs[fr->callno]->peercallno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
peercallno
memset(&ied0, 0, sizeof(ied0));
memset(&ied0, 0, sizeof(ied0))
memset
memset
&ied0
ied0
ied0
0
sizeof(ied0)
(ied0)
ied0
ied0
iax_ie_append_byte(&ied0, IAX_IE_IAX_UNKNOWN, f.subclass.integer);
iax_ie_append_byte(&ied0, IAX_IE_IAX_UNKNOWN, f.subclass.integer)
iax_ie_append_byte
iax_ie_append_byte
&ied0
ied0
ied0
IAX_IE_IAX_UNKNOWN
IAX_IE_IAX_UNKNOWN
f.subclass.integer
f.subclass
f
f
subclass
integer
send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_UNSUPPORT, 0, ied0.buf, ied0.pos, -1);
send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_UNSUPPORT, 0, ied0.buf, ied0.pos, -1)
send_command
send_command
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_UNSUPPORT
IAX_COMMAND_UNSUPPORT
0
ied0.buf
ied0
ied0
buf
ied0.pos
ied0
ied0
pos
-1
1
if (ies.vars) {				ast_variables_destroy(ies.vars);				ast_debug(1, "I can haz IAX vars, but they is no good :-(\n");				ies.vars = NULL;			}
ies.vars
ies
ies
vars
{				ast_variables_destroy(ies.vars);				ast_debug(1, "I can haz IAX vars, but they is no good :-(\n");				ies.vars = NULL;			}
ast_variables_destroy(ies.vars);
ast_variables_destroy(ies.vars)
ast_variables_destroy
ast_variables_destroy
ies.vars
ies
ies
vars
ast_debug(1, "I can haz IAX vars, but they is no good :-(\n");
ast_debug(1, "I can haz IAX vars, but they is no good :-(\n")
ast_debug
ast_debug
1
"I can haz IAX vars, but they is no good :-(\n"
ies.vars = NULL;
ies.vars = NULL
ies.vars
ies
ies
vars
NULL
NULL
if ((f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&			  (f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_INVAL) &&			  (f.subclass.integer != IAX_COMMAND_VNAK)) {				if (iaxs[fr->callno] && iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);			}
(f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&			  (f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_INVAL) &&			  (f.subclass.integer != IAX_COMMAND_VNAK)
(f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&			  (f.subclass.integer != IAX_COMMAND_TXACC) &&			  (f.subclass.integer != IAX_COMMAND_INVAL)
(f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&			  (f.subclass.integer != IAX_COMMAND_TXACC)
(f.subclass.integer != IAX_COMMAND_ACK) &&			  (f.subclass.integer != IAX_COMMAND_TXCNT)
(f.subclass.integer != IAX_COMMAND_ACK)
f.subclass.integer != IAX_COMMAND_ACK
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_ACK
IAX_COMMAND_ACK
(f.subclass.integer != IAX_COMMAND_TXCNT)
f.subclass.integer != IAX_COMMAND_TXCNT
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_TXCNT
IAX_COMMAND_TXCNT
(f.subclass.integer != IAX_COMMAND_TXACC)
f.subclass.integer != IAX_COMMAND_TXACC
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_TXACC
IAX_COMMAND_TXACC
(f.subclass.integer != IAX_COMMAND_INVAL)
f.subclass.integer != IAX_COMMAND_INVAL
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_INVAL
IAX_COMMAND_INVAL
(f.subclass.integer != IAX_COMMAND_VNAK)
f.subclass.integer != IAX_COMMAND_VNAK
f.subclass.integer
f.subclass
f
f
subclass
integer
IAX_COMMAND_VNAK
IAX_COMMAND_VNAK
{				if (iaxs[fr->callno] && iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);			}
if (iaxs[fr->callno] && iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno)					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
iaxs[fr->callno] && iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno
iaxs[fr->callno]->aseqno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
aseqno
iaxs[fr->callno]->iseqno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
iseqno
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
send_command_immediate
send_command_immediate
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_ACK
IAX_COMMAND_ACK
fr->ts
fr
fr
ts
NULL
NULL
0
fr->iseqno
fr
fr
iseqno
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock(&iaxsl[fr->callno]);
ast_mutex_unlock
ast_mutex_unlock
(&iaxsl[fr->callno])
&iaxsl[fr->callno]
&
iaxsl
[fr->callno]
fr->callno
fr
fr
callno
return 1;
1
if (iaxs[fr->callno] && iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno)			send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
iaxs[fr->callno] && iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno
iaxs[fr->callno]->aseqno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
aseqno
iaxs[fr->callno]->iseqno
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
iseqno
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
send_command_immediate
send_command_immediate
iaxs[fr->callno]
iaxs
iaxs
fr->callno
fr
fr
callno
AST_FRAME_IAX
AST_FRAME_IAX
IAX_COMMAND_ACK
IAX_COMMAND_ACK
fr->ts
fr
fr
ts
NULL
NULL
0
fr->iseqno
fr
fr
iseqno
-----joern-----
(7429,123,0)
(5062,2930,0)
(7583,5584,0)
(528,5077,0)
(8838,8391,0)
(1785,8318,0)
(2900,2752,0)
(1421,6055,0)
(2544,1280,0)
(6310,324,0)
(4535,2423,0)
(9081,9073,0)
(6339,5085,0)
(3731,7595,0)
(78,3727,0)
(1103,8391,0)
(7531,5671,0)
(2370,4828,0)
(7224,115,0)
(1294,197,0)
(5834,7439,0)
(3887,7957,0)
(5036,3023,0)
(9125,4481,0)
(3621,3215,0)
(177,6732,0)
(4155,8391,0)
(643,1676,0)
(7566,3230,0)
(3236,7832,0)
(4240,4812,0)
(4989,7254,0)
(8391,4785,0)
(5669,8391,0)
(7980,474,0)
(3571,115,0)
(4951,5602,0)
(6782,5871,0)
(2249,8366,0)
(1755,8226,0)
(4295,5802,0)
(7689,8479,0)
(6576,8391,0)
(8047,8373,0)
(1680,3340,0)
(2054,1079,0)
(7987,7552,0)
(8456,1829,0)
(8284,6889,0)
(8989,100,0)
(4811,3545,0)
(5719,8391,0)
(3752,1488,0)
(5361,3944,0)
(4375,489,0)
(6055,4859,0)
(1956,6360,0)
(2631,6627,0)
(1609,895,0)
(632,624,0)
(2974,8010,0)
(4692,1985,0)
(758,8553,0)
(764,6758,0)
(6715,115,0)
(5870,34,0)
(2482,6577,0)
(8023,973,0)
(4375,3215,0)
(2660,3730,0)
(5997,7866,0)
(3102,2674,0)
(5812,7060,0)
(8291,3037,0)
(7476,5387,0)
(4620,6041,0)
(1954,7577,0)
(3072,4188,0)
(711,5193,0)
(8032,1826,0)
(2660,4963,0)
(5421,750,0)
(2487,115,0)
(6101,3906,0)
(2395,1628,0)
(213,2189,0)
(9098,6934,0)
(2148,4393,0)
(4541,378,0)
(7339,477,0)
(4204,3313,0)
(8803,5373,0)
(1385,6836,0)
(4733,6087,0)
(3907,8447,0)
(5782,5218,0)
(5567,6223,0)
(8024,3331,0)
(5038,7489,0)
(7370,5874,0)
(119,115,0)
(6373,6715,0)
(1524,4785,0)
(7431,2894,0)
(5119,939,0)
(3536,3534,0)
(9097,1727,0)
(4644,4619,0)
(8365,325,0)
(5638,6968,0)
(8038,1158,0)
(4378,8391,0)
(6367,6665,0)
(1535,2789,0)
(6346,4214,0)
(2177,6851,0)
(727,228,0)
(527,1360,0)
(489,2965,0)
(1530,5964,0)
(6221,4100,0)
(8245,6971,0)
(2873,8391,0)
(3625,115,0)
(161,8391,0)
(3370,6671,0)
(463,8996,0)
(8321,3174,0)
(7097,4445,0)
(2467,8457,0)
(8112,3889,0)
(6208,2479,0)
(2391,2401,0)
(2044,2060,0)
(3875,7393,0)
(8832,6582,0)
(4029,2845,0)
(4873,3215,0)
(5327,3055,0)
(5593,8458,0)
(5239,7735,0)
(4561,8568,0)
(8160,4273,0)
(7390,4949,0)
(6299,777,0)
(6127,8784,0)
(6063,115,0)
(3016,2128,0)
(2270,8131,0)
(3806,5757,0)
(6508,5007,0)
(8972,1900,0)
(2620,4126,0)
(5654,3438,0)
(9124,7711,0)
(589,1206,0)
(4375,2955,0)
(2909,6912,0)
(8811,8391,0)
(6618,2620,0)
(4962,4620,0)
(6620,5867,0)
(2118,813,0)
(7040,1065,0)
(2145,7515,0)
(398,1754,0)
(7363,5434,0)
(700,6073,0)
(6847,980,0)
(1552,9090,0)
(7198,115,0)
(2096,6503,0)
(714,5094,0)
(1712,8866,0)
(458,2774,0)
(6932,115,0)
(6146,2511,0)
(2482,5047,0)
(1646,4219,0)
(3072,4353,0)
(4089,8391,0)
(7274,8884,0)
(3456,3820,0)
(6678,5755,0)
(4588,3397,0)
(7771,8445,0)
(3648,7945,0)
(4079,161,0)
(4508,8856,0)
(3804,7140,0)
(2788,7196,0)
(3240,4769,0)
(3632,6784,0)
(2759,665,0)
(7522,8911,0)
(6811,8827,0)
(1373,3483,0)
(8398,5258,0)
(8359,8391,0)
(2978,8391,0)
(5800,1310,0)
(3847,88,0)
(4009,6027,0)
(7319,6347,0)
(2117,115,0)
(1879,7280,0)
(8744,7046,0)
(1566,7199,0)
(1011,6355,0)
(8710,8806,0)
(5101,2089,0)
(8210,3403,0)
(2,4549,0)
(5157,2721,0)
(6312,5132,0)
(3300,115,0)
(7097,7079,0)
(5593,5797,0)
(5950,5156,0)
(254,4799,0)
(1829,4051,0)
(1641,241,0)
(4027,4449,0)
(3681,2937,0)
(3076,115,0)
(7416,4245,0)
(1096,6570,0)
(1363,3911,0)
(1483,2452,0)
(8474,4785,0)
(1006,7880,0)
(5510,6321,0)
(3354,7034,0)
(4008,115,0)
(4651,4321,0)
(5256,2043,0)
(2058,904,0)
(3755,6425,0)
(8165,6820,0)
(8250,7306,0)
(2210,459,0)
(2522,115,0)
(7577,5332,0)
(4659,7075,0)
(3877,2788,0)
(5850,7634,0)
(7569,6657,0)
(537,4647,0)
(8658,4919,0)
(2643,7595,0)
(8648,115,0)
(6830,8920,0)
(7966,7039,0)
(6253,7180,0)
(2298,149,0)
(3628,5499,0)
(5959,1250,0)
(8340,115,0)
(3368,680,0)
(2211,542,0)
(2288,115,0)
(7919,4408,0)
(1855,5375,0)
(1640,350,0)
(5857,6886,0)
(200,2035,0)
(5220,2049,0)
(966,5156,0)
(4420,4982,0)
(6415,7263,0)
(6407,8781,0)
(389,989,0)
(6461,9077,0)
(3804,7039,0)
(5642,8820,0)
(42,3376,0)
(7978,1231,0)
(7023,6623,0)
(6208,6993,0)
(2814,115,0)
(7099,6485,0)
(2530,6402,0)
(6254,5463,0)
(3266,6596,0)
(6267,6681,0)
(7070,4672,0)
(272,2879,0)
(637,8543,0)
(1109,2358,0)
(4696,6671,0)
(8873,4394,0)
(8103,7541,0)
(2257,1488,0)
(5496,4473,0)
(5295,3831,0)
(5790,4725,0)
(5938,6508,0)
(6069,3636,0)
(665,2759,0)
(5868,5829,0)
(95,6671,0)
(4188,6603,0)
(6833,580,0)
(6225,932,0)
(6296,3911,0)
(4250,7198,0)
(8974,5037,0)
(9105,2788,0)
(680,3368,0)
(6419,3889,0)
(5355,8391,0)
(997,2384,0)
(6196,6719,0)
(1047,1145,0)
(6469,4792,0)
(994,6452,0)
(4271,5613,0)
(5302,777,0)
(2079,2536,0)
(4109,5434,0)
(2053,6337,0)
(4818,8862,0)
(5758,5611,0)
(7597,7145,0)
(6735,616,0)
(1907,6157,0)
(7657,1560,0)
(4937,7495,0)
(4246,4344,0)
(8559,1282,0)
(2814,4125,0)
(5058,838,0)
(7866,5997,0)
(1509,2367,0)
(5448,6602,0)
(1314,5245,0)
(6125,8391,0)
(424,718,0)
(2127,2866,0)
(1779,115,0)
(3837,8391,0)
(1412,3103,0)
(8130,3431,0)
(1657,8061,0)
(4373,5349,0)
(238,2714,0)
(4078,1087,0)
(3028,7683,0)
(6474,8074,0)
(1927,2814,0)
(110,2058,0)
(3406,6214,0)
(6992,2119,0)
(4629,2042,0)
(3804,929,0)
(8248,8430,0)
(3474,1077,0)
(3552,1992,0)
(5669,4824,0)
(3853,655,0)
(2695,7097,0)
(7766,4809,0)
(4646,4108,0)
(5132,6671,0)
(5986,3114,0)
(1623,2475,0)
(8933,2254,0)
(2948,8777,0)
(4726,5435,0)
(6750,115,0)
(7916,8845,0)
(7974,1329,0)
(3543,1419,0)
(6014,7316,0)
(7163,2309,0)
(3448,3012,0)
(7358,4470,0)
(2965,489,0)
(8935,7296,0)
(5177,6671,0)
(7294,257,0)
(7237,7409,0)
(87,105,0)
(2576,2360,0)
(1038,1931,0)
(6660,1546,0)
(4268,8359,0)
(955,28,0)
(7872,1966,0)
(6554,5507,0)
(115,1850,0)
(300,7150,0)
(5967,8379,0)
(8276,8415,0)
(4098,7844,0)
(8155,4583,0)
(938,6475,0)
(264,6016,0)
(6087,8423,0)
(8646,3543,0)
(602,1967,0)
(1362,7415,0)
(4758,8391,0)
(8354,1013,0)
(7205,6194,0)
(1377,161,0)
(7463,301,0)
(311,2303,0)
(1144,482,0)
(1825,6711,0)
(6090,8695,0)
(721,7363,0)
(1867,1331,0)
(2287,8111,0)
(1359,4018,0)
(158,115,0)
(6249,7475,0)
(5858,446,0)
(3625,8391,0)
(5256,5829,0)
(2271,3386,0)
(600,1969,0)
(1982,5156,0)
(7889,4942,0)
(4873,700,0)
(1948,8391,0)
(2542,5971,0)
(8470,8391,0)
(428,2254,0)
(5583,111,0)
(8719,8391,0)
(1114,4397,0)
(3897,1861,0)
(2466,4499,0)
(5192,4184,0)
(1062,1396,0)
(8591,4385,0)
(5838,4499,0)
(3443,3714,0)
(811,1962,0)
(6329,3757,0)
(3514,1246,0)
(4212,6259,0)
(2157,115,0)
(9134,4920,0)
(7267,6671,0)
(9050,6109,0)
(218,3878,0)
(5271,4204,0)
(3084,4658,0)
(7280,5416,0)
(333,2035,0)
(705,4307,0)
(6959,3454,0)
(322,4121,0)
(8146,6047,0)
(3658,7572,0)
(6721,2117,0)
(5882,7959,0)
(579,2845,0)
(4720,2966,0)
(6404,8222,0)
(805,2695,0)
(5951,7025,0)
(2923,768,0)
(4411,1233,0)
(6246,115,0)
(5037,1488,0)
(6689,3165,0)
(6559,7100,0)
(3621,3565,0)
(61,2630,0)
(6005,1322,0)
(6502,4873,0)
(7679,7219,0)
(5363,104,0)
(1438,115,0)
(143,1923,0)
(6465,6430,0)
(7376,6560,0)
(2139,746,0)
(3943,1899,0)
(232,3877,0)
(5096,1299,0)
(7321,5441,0)
(568,1135,0)
(4135,4283,0)
(2068,8660,0)
(5964,1530,0)
(8144,1493,0)
(893,1526,0)
(4775,5084,0)
(2379,6076,0)
(6609,2845,0)
(6345,6046,0)
(652,1348,0)
(8990,1935,0)
(5050,6346,0)
(3932,5801,0)
(4636,5855,0)
(3615,6471,0)
(1868,5982,0)
(3243,3249,0)
(3673,8391,0)
(3168,8026,0)
(793,794,0)
(7374,115,0)
(6899,646,0)
(5371,8391,0)
(5843,6442,0)
(8908,6111,0)
(3940,6993,0)
(409,5109,0)
(3324,2538,0)
(6557,3580,0)
(2527,3141,0)
(7176,7356,0)
(8851,908,0)
(1498,3434,0)
(966,2862,0)
(8148,115,0)
(5352,544,0)
(8276,8144,0)
(810,8822,0)
(3686,155,0)
(3659,1800,0)
(4180,8507,0)
(3711,3564,0)
(6093,6596,0)
(4083,8201,0)
(4375,7045,0)
(1415,1280,0)
(7541,8103,0)
(981,1748,0)
(969,7883,0)
(7167,3151,0)
(2761,1861,0)
(3884,8927,0)
(4751,5640,0)
(654,6829,0)
(6724,639,0)
(8321,3962,0)
(6620,115,0)
(8558,4594,0)
(8546,3806,0)
(8303,6807,0)
(4917,9008,0)
(3213,6649,0)
(5285,7100,0)
(8217,8738,0)
(2245,7510,0)
(1415,7757,0)
(7761,8505,0)
(7605,5369,0)
(6420,7346,0)
(4023,2953,0)
(3714,3443,0)
(5899,6866,0)
(5274,8200,0)
(8541,3727,0)
(443,5861,0)
(9008,6775,0)
(6385,6535,0)
(3804,4524,0)
(5030,7251,0)
(4650,2359,0)
(2431,9004,0)
(519,230,0)
(8500,115,0)
(9121,8955,0)
(7444,4876,0)
(3507,5027,0)
(5764,1121,0)
(4729,2379,0)
(4065,5166,0)
(7108,115,0)
(8454,1769,0)
(8488,3513,0)
(7061,469,0)
(1731,2776,0)
(8242,8391,0)
(8270,4068,0)
(4616,2685,0)
(2856,1246,0)
(7629,2768,0)
(7190,1613,0)
(267,1158,0)
(9126,491,0)
(5543,1001,0)
(2216,1223,0)
(1207,2411,0)
(5301,769,0)
(2786,6009,0)
(2352,4836,0)
(4236,306,0)
(502,1149,0)
(4253,3983,0)
(5805,2731,0)
(4088,4745,0)
(2776,6314,0)
(2401,2906,0)
(2953,4023,0)
(8009,115,0)
(167,5739,0)
(123,8902,0)
(990,644,0)
(6275,581,0)
(7833,5829,0)
(2956,6431,0)
(8697,8400,0)
(8776,7352,0)
(7966,3215,0)
(5034,347,0)
(1852,6577,0)
(1375,3774,0)
(6535,719,0)
(170,8391,0)
(5457,2034,0)
(7894,8817,0)
(1910,864,0)
(7453,5690,0)
(8376,7653,0)
(6064,2896,0)
(1670,8211,0)
(7065,5648,0)
(1358,1329,0)
(7591,1869,0)
(5477,6692,0)
(5054,1039,0)
(8406,7238,0)
(1815,8598,0)
(6057,8297,0)
(3318,2987,0)
(8362,7293,0)
(1889,6189,0)
(6364,8628,0)
(4468,5829,0)
(563,6529,0)
(5234,8339,0)
(4553,616,0)
(7847,3759,0)
(3169,5538,0)
(1415,8451,0)
(6274,8277,0)
(3357,7408,0)
(8127,2146,0)
(1457,2234,0)
(6795,8391,0)
(8006,20,0)
(1601,8391,0)
(7797,7821,0)
(7400,415,0)
(171,1742,0)
(3995,6278,0)
(7777,8014,0)
(2182,5214,0)
(4758,8377,0)
(6470,3561,0)
(3744,8852,0)
(6069,2896,0)
(5549,3170,0)
(7355,2385,0)
(4375,2112,0)
(4592,1831,0)
(5326,8391,0)
(5140,360,0)
(744,3075,0)
(5747,7532,0)
(2501,1780,0)
(9096,6776,0)
(3839,4337,0)
(774,8527,0)
(4640,1850,0)
(656,7473,0)
(1078,8552,0)
(3333,1365,0)
(3550,1931,0)
(6729,6474,0)
(5640,5036,0)
(6502,2544,0)
(7770,1923,0)
(6318,115,0)
(7131,926,0)
(1415,6968,0)
(8285,4785,0)
(7802,8865,0)
(6061,2172,0)
(4506,2796,0)
(7426,6434,0)
(844,1708,0)
(2410,115,0)
(831,8666,0)
(780,115,0)
(6458,1305,0)
(6644,2047,0)
(4452,952,0)
(5194,4614,0)
(5728,8664,0)
(3610,7834,0)
(736,2788,0)
(4245,3703,0)
(2896,7588,0)
(4549,2,0)
(6419,1405,0)
(8190,8043,0)
(1921,6467,0)
(8297,1956,0)
(5638,3215,0)
(2888,8102,0)
(1415,4386,0)
(6986,8252,0)
(3178,405,0)
(4184,4861,0)
(7966,8111,0)
(4883,933,0)
(31,4672,0)
(1134,7489,0)
(7653,7630,0)
(559,102,0)
(7511,8048,0)
(4187,3242,0)
(6220,115,0)
(7913,3675,0)
(3330,1283,0)
(2738,5297,0)
(5780,7789,0)
(4638,4225,0)
(4765,7210,0)
(7731,7841,0)
(4965,2972,0)
(4253,5961,0)
(7962,5829,0)
(439,5139,0)
(8880,9034,0)
(5109,3451,0)
(530,6582,0)
(4241,4435,0)
(1462,115,0)
(1671,6666,0)
(3994,4473,0)
(1326,8836,0)
(8797,4167,0)
(155,8391,0)
(823,1235,0)
(7127,1873,0)
(3187,7982,0)
(1013,8741,0)
(853,122,0)
(3031,682,0)
(402,5829,0)
(3430,5098,0)
(3046,1591,0)
(8786,3831,0)
(1268,2370,0)
(4513,4506,0)
(5844,289,0)
(1767,2805,0)
(8155,4876,0)
(4809,448,0)
(2544,8021,0)
(617,2585,0)
(5802,4295,0)
(3735,9069,0)
(1191,4793,0)
(159,573,0)
(1241,8391,0)
(2504,365,0)
(933,1500,0)
(325,8941,0)
(2367,2756,0)
(6843,2401,0)
(5110,8673,0)
(6419,7039,0)
(65,3299,0)
(7240,4750,0)
(6748,6838,0)
(5296,3298,0)
(6502,3509,0)
(5957,4494,0)
(4625,8391,0)
(6802,7029,0)
(4870,212,0)
(4824,5669,0)
(7980,8391,0)
(6460,3580,0)
(5755,4974,0)
(3337,6844,0)
(9119,3769,0)
(7561,115,0)
(7988,115,0)
(3522,4619,0)
(2293,3549,0)
(3351,610,0)
(2488,885,0)
(794,6847,0)
(6268,4216,0)
(7763,7451,0)
(7714,7856,0)
(5108,5432,0)
(6324,3279,0)
(7507,6671,0)
(7179,6687,0)
(2254,9125,0)
(2919,8909,0)
(1380,2450,0)
(2357,732,0)
(4580,2845,0)
(2299,7392,0)
(2204,171,0)
(4606,7440,0)
(9107,4340,0)
(6342,8844,0)
(4070,8391,0)
(6974,4394,0)
(8337,3456,0)
(7599,4520,0)
(4160,4209,0)
(4544,2993,0)
(1497,8043,0)
(6854,1638,0)
(2953,4167,0)
(3029,8738,0)
(1331,2677,0)
(1471,5374,0)
(2570,4627,0)
(2209,1878,0)
(1439,416,0)
(3478,3122,0)
(7943,3347,0)
(5414,2845,0)
(3934,2468,0)
(1819,8421,0)
(1775,4672,0)
(8395,1171,0)
(349,3527,0)
(5763,5452,0)
(8399,7257,0)
(1931,115,0)
(6594,8391,0)
(5915,5537,0)
(1505,3438,0)
(5608,205,0)
(205,7156,0)
(3886,2217,0)
(1326,8391,0)
(3583,6975,0)
(6565,7191,0)
(6685,6916,0)
(1236,8338,0)
(3922,8697,0)
(874,7461,0)
(4708,148,0)
(1415,3565,0)
(5250,6677,0)
(5874,8391,0)
(2772,73,0)
(6139,1943,0)
(4956,2053,0)
(6591,2914,0)
(4404,7257,0)
(8209,5156,0)
(8547,347,0)
(6804,6142,0)
(1415,3657,0)
(4934,6402,0)
(7241,7646,0)
(1908,3333,0)
(4906,4404,0)
(8777,2948,0)
(4375,929,0)
(7228,5726,0)
(7248,1607,0)
(6928,4968,0)
(1779,8391,0)
(6952,4520,0)
(7883,3589,0)
(1561,6388,0)
(430,8069,0)
(8883,2449,0)
(7103,856,0)
(8322,4954,0)
(3827,5117,0)
(843,5394,0)
(3507,7250,0)
(2287,2955,0)
(3673,115,0)
(3284,6063,0)
(5494,4515,0)
(4891,6671,0)
(7991,8924,0)
(5620,860,0)
(4218,7005,0)
(6227,8421,0)
(5072,6520,0)
(8317,4468,0)
(5096,1149,0)
(7362,5391,0)
(8715,1488,0)
(4604,6821,0)
(7871,8391,0)
(6887,2314,0)
(413,8391,0)
(3125,3690,0)
(5638,8471,0)
(1126,3944,0)
(1415,7499,0)
(2538,8391,0)
(429,5602,0)
(183,8450,0)
(2421,7393,0)
(971,4704,0)
(3761,8833,0)
(3729,2868,0)
(2903,2468,0)
(2104,5156,0)
(8664,8391,0)
(783,5226,0)
(4040,2133,0)
(2473,1220,0)
(1087,777,0)
(8021,6614,0)
(5729,1732,0)
(1601,8680,0)
(7822,1001,0)
(3509,6649,0)
(6190,115,0)
(978,6177,0)
(1862,1523,0)
(2669,6671,0)
(4927,7760,0)
(3303,2666,0)
(7218,6188,0)
(8142,2858,0)
(5774,4231,0)
(2082,2522,0)
(3311,1708,0)
(6384,250,0)
(1266,1048,0)
(8303,2737,0)
(5488,331,0)
(2190,5402,0)
(1271,4785,0)
(4972,2368,0)
(9059,3401,0)
(4668,924,0)
(8966,8391,0)
(6284,1158,0)
(2099,8391,0)
(5861,6834,0)
(523,8391,0)
(5166,5734,0)
(2847,2146,0)
(4746,1357,0)
(4766,5166,0)
(6907,2644,0)
(2583,3193,0)
(6108,8031,0)
(8366,3231,0)
(3409,2617,0)
(333,6570,0)
(240,3396,0)
(3087,1664,0)
(3953,4329,0)
(493,8302,0)
(4324,505,0)
(1204,4842,0)
(8702,2983,0)
(6666,2133,0)
(5563,6031,0)
(5482,515,0)
(7626,3215,0)
(5126,6495,0)
(8432,5983,0)
(8332,4350,0)
(4003,3792,0)
(5607,4764,0)
(7222,8940,0)
(3473,2151,0)
(6575,191,0)
(6502,3213,0)
(2049,3184,0)
(6467,8375,0)
(3842,8134,0)
(6109,3534,0)
(1415,3242,0)
(8038,1280,0)
(2313,107,0)
(8578,9039,0)
(7976,8742,0)
(8383,4070,0)
(3740,8391,0)
(5597,8977,0)
(4626,5588,0)
(2544,8471,0)
(1071,2167,0)
(3203,845,0)
(1245,5204,0)
(6011,2895,0)
(9080,5736,0)
(5574,8296,0)
(6865,5420,0)
(335,3067,0)
(478,1225,0)
(1586,4764,0)
(8459,6397,0)
(3540,4320,0)
(2221,390,0)
(775,2845,0)
(1846,8010,0)
(6433,3772,0)
(3989,8461,0)
(8402,1468,0)
(6156,718,0)
(7443,1038,0)
(519,7139,0)
(4852,6060,0)
(9049,8391,0)
(9112,4802,0)
(19,4624,0)
(5048,6349,0)
(3235,3138,0)
(240,8975,0)
(9053,5139,0)
(2899,1048,0)
(995,5893,0)
(1900,7384,0)
(5706,6336,0)
(7773,1986,0)
(4116,115,0)
(9064,5085,0)
(718,424,0)
(148,8391,0)
(8113,5687,0)
(1293,5346,0)
(6937,6435,0)
(5059,1076,0)
(6019,7791,0)
(8033,5851,0)
(9090,115,0)
(2733,2386,0)
(5117,4949,0)
(1985,4692,0)
(4342,9048,0)
(5307,7944,0)
(7609,1322,0)
(1832,115,0)
(519,2459,0)
(1598,5164,0)
(5128,8365,0)
(5649,4918,0)
(6495,1572,0)
(5894,3680,0)
(2133,8570,0)
(7946,9130,0)
(6657,7569,0)
(3865,1410,0)
(2626,3599,0)
(5449,7923,0)
(126,8209,0)
(5327,1422,0)
(562,115,0)
(8833,8713,0)
(2036,284,0)
(2008,7835,0)
(8548,555,0)
(1454,6772,0)
(3104,3150,0)
(2147,1952,0)
(5705,4959,0)
(6772,1454,0)
(6827,8391,0)
(1208,115,0)
(43,4064,0)
(2208,8108,0)
(9089,6226,0)
(4130,5432,0)
(2735,5315,0)
(2541,8719,0)
(717,6483,0)
(1804,5937,0)
(1397,301,0)
(6008,466,0)
(7242,474,0)
(3737,5991,0)
(2276,3628,0)
(5103,1128,0)
(676,2665,0)
(7829,7604,0)
(4315,6910,0)
(2307,8548,0)
(4293,5580,0)
(862,1077,0)
(9052,1012,0)
(6710,4209,0)
(7891,5107,0)
(662,2497,0)
(6635,7120,0)
(201,7929,0)
(4249,5854,0)
(1898,5608,0)
(7702,2683,0)
(7524,178,0)
(504,6521,0)
(7069,8282,0)
(7393,3875,0)
(6576,115,0)
(1649,3819,0)
(2855,8935,0)
(1254,6896,0)
(2477,8600,0)
(4536,6577,0)
(1418,7271,0)
(8035,4467,0)
(9013,3968,0)
(8695,4785,0)
(6171,3224,0)
(6337,8789,0)
(693,8784,0)
(5492,6080,0)
(1787,8150,0)
(8884,8391,0)
(6055,1962,0)
(3005,5851,0)
(6507,4008,0)
(4711,8391,0)
(591,6844,0)
(7393,6820,0)
(5249,4692,0)
(3059,7569,0)
(8550,115,0)
(1069,777,0)
(9069,3735,0)
(8510,4876,0)
(6174,8749,0)
(2479,6208,0)
(2539,1488,0)
(1415,2065,0)
(3509,3215,0)
(1105,1779,0)
(1452,1303,0)
(3804,489,0)
(644,115,0)
(8527,774,0)
(3463,1975,0)
(1194,6662,0)
(1787,3732,0)
(4574,4444,0)
(4314,5145,0)
(3889,202,0)
(1935,2536,0)
(3236,5012,0)
(3804,2065,0)
(1872,424,0)
(387,8355,0)
(148,7416,0)
(4413,4876,0)
(9116,4785,0)
(1612,520,0)
(8008,2845,0)
(5953,1149,0)
(8229,1680,0)
(7430,2043,0)
(2358,651,0)
(4533,89,0)
(6394,8967,0)
(3429,3175,0)
(7519,8307,0)
(3455,1234,0)
(6327,2929,0)
(6184,3701,0)
(1637,4282,0)
(877,8359,0)
(1947,115,0)
(5398,2265,0)
(431,7046,0)
(2261,646,0)
(2913,9049,0)
(5638,1158,0)
(4555,416,0)
(1546,2308,0)
(4699,6671,0)
(7661,9068,0)
(3739,2580,0)
(814,4307,0)
(6031,1488,0)
(6838,6201,0)
(8038,3565,0)
(3765,2250,0)
(4799,6671,0)
(7358,6236,0)
(784,2116,0)
(7980,3621,0)
(5441,109,0)
(849,6731,0)
(5342,115,0)
(2556,8054,0)
(2287,4515,0)
(8969,1221,0)
(8882,6513,0)
(3332,2840,0)
(6655,6995,0)
(7909,8282,0)
(1022,6426,0)
(4231,5774,0)
(7660,115,0)
(3730,115,0)
(8282,2231,0)
(552,1619,0)
(5077,528,0)
(4414,2020,0)
(8857,6292,0)
(4734,7003,0)
(4026,115,0)
(1802,8827,0)
(2876,3130,0)
(2915,1376,0)
(2996,390,0)
(1687,3076,0)
(4922,6627,0)
(2214,6665,0)
(8290,7149,0)
(5679,3313,0)
(6705,8500,0)
(5337,4095,0)
(5688,8074,0)
(5293,7796,0)
(8306,5228,0)
(6030,2776,0)
(2287,4524,0)
(9133,499,0)
(2649,5834,0)
(2449,7571,0)
(5205,2533,0)
(8377,5859,0)
(7126,2265,0)
(6926,8391,0)
(4091,7974,0)
(6701,4497,0)
(7219,8578,0)
(3244,4337,0)
(6612,1054,0)
(6637,4982,0)
(2794,1760,0)
(1250,6907,0)
(8248,2414,0)
(2896,4146,0)
(6714,6880,0)
(349,5598,0)
(1116,6671,0)
(3300,8391,0)
(7864,4801,0)
(796,8628,0)
(1310,3867,0)
(9036,7210,0)
(1984,4558,0)
(7664,7897,0)
(606,5868,0)
(6255,14,0)
(6523,8391,0)
(6454,8391,0)
(1111,5533,0)
(3278,3197,0)
(3933,3512,0)
(2252,8680,0)
(6260,8287,0)
(214,2988,0)
(1368,2874,0)
(3279,1488,0)
(3738,5315,0)
(5360,2158,0)
(3801,544,0)
(5572,3126,0)
(8154,4505,0)
(6971,7493,0)
(3205,6910,0)
(8871,3717,0)
(5054,6038,0)
(8142,4522,0)
(921,2845,0)
(903,115,0)
(6386,524,0)
(85,6663,0)
(7709,1208,0)
(2492,1077,0)
(1583,5690,0)
(7171,1857,0)
(6703,115,0)
(3179,4672,0)
(6687,3992,0)
(2587,5349,0)
(7295,7880,0)
(90,8594,0)
(1970,4838,0)
(4101,7199,0)
(1378,607,0)
(2158,5391,0)
(3997,7026,0)
(3813,7493,0)
(3798,848,0)
(7444,5156,0)
(6344,4785,0)
(8361,2751,0)
(6785,8986,0)
(2314,81,0)
(4712,4579,0)
(8024,1082,0)
(9002,8985,0)
(6989,8441,0)
(3227,1707,0)
(7035,2679,0)
(350,1640,0)
(3804,6474,0)
(3194,8806,0)
(4456,2534,0)
(2679,1046,0)
(1576,6686,0)
(5955,5197,0)
(6762,1685,0)
(3458,4632,0)
(4967,3932,0)
(7653,8391,0)
(223,5229,0)
(1153,7114,0)
(4972,3424,0)
(848,6046,0)
(9047,6053,0)
(1415,8111,0)
(1217,5156,0)
(8096,3215,0)
(2566,4079,0)
(2961,5559,0)
(4125,8677,0)
(1366,2518,0)
(7036,6825,0)
(8244,3866,0)
(1468,8128,0)
(4934,4861,0)
(7703,5129,0)
(3837,2111,0)
(2424,8372,0)
(6148,3278,0)
(2511,6146,0)
(8505,1605,0)
(2510,4715,0)
(8161,8497,0)
(6278,7888,0)
(2813,7819,0)
(8039,359,0)
(5007,2754,0)
(2641,8503,0)
(522,1616,0)
(6104,115,0)
(853,4406,0)
(5383,7353,0)
(1127,4709,0)
(741,7577,0)
(7003,7415,0)
(2153,7707,0)
(2059,1916,0)
(6932,8391,0)
(5593,4587,0)
(4843,8475,0)
(4585,3463,0)
(818,6402,0)
(8540,7058,0)
(2513,2870,0)
(1247,6952,0)
(2866,8936,0)
(8087,6851,0)
(9086,4023,0)
(7567,636,0)
(6509,4445,0)
(1602,115,0)
(7791,6047,0)
(5501,4723,0)
(361,6865,0)
(1217,4876,0)
(8435,935,0)
(7418,4117,0)
(8174,4886,0)
(6582,530,0)
(1415,8495,0)
(4847,7089,0)
(1875,6198,0)
(2414,3537,0)
(3260,883,0)
(1415,7950,0)
(497,7272,0)
(5946,5228,0)
(108,3776,0)
(3759,4759,0)
(2715,2354,0)
(9067,6173,0)
(1243,3331,0)
(798,7849,0)
(921,115,0)
(2746,7182,0)
(1491,4012,0)
(7322,6723,0)
(2611,7722,0)
(432,2677,0)
(2938,159,0)
(3774,6068,0)
(1112,3847,0)
(8224,2183,0)
(4056,8391,0)
(1415,4149,0)
(7380,7891,0)
(1766,8391,0)
(1077,8249,0)
(8794,1874,0)
(5790,7007,0)
(5851,1151,0)
(3214,8391,0)
(8495,6719,0)
(4381,8391,0)
(82,8131,0)
(1635,1011,0)
(6128,4398,0)
(7477,7660,0)
(8485,6019,0)
(8396,4422,0)
(8545,4785,0)
(7924,8658,0)
(8038,4515,0)
(1415,2135,0)
(2060,2044,0)
(5638,4515,0)
(7124,6571,0)
(461,2832,0)
(8170,3384,0)
(6412,5829,0)
(5459,8894,0)
(1113,874,0)
(5186,5721,0)
(8178,6269,0)
(3428,1167,0)
(1967,8391,0)
(3128,5856,0)
(2613,2171,0)
(7080,1599,0)
(5893,3640,0)
(3349,8233,0)
(3019,4362,0)
(6868,1488,0)
(8108,6582,0)
(0,7930,0)
(8502,6656,0)
(1591,456,0)
(1587,1094,0)
(6064,7079,0)
(5466,1171,0)
(6242,3059,0)
(6524,283,0)
(1843,3064,0)
(4710,6620,0)
(8586,8423,0)
(2493,8186,0)
(7357,115,0)
(1567,4475,0)
(1516,8873,0)
(2287,2861,0)
(392,5602,0)
(9008,4444,0)
(7484,6744,0)
(3027,900,0)
(4836,115,0)
(7780,6006,0)
(8596,7532,0)
(553,6510,0)
(1077,5531,0)
(8204,5776,0)
(7966,4587,0)
(1476,2974,0)
(7700,2777,0)
(3173,5660,0)
(6512,6298,0)
(1419,3543,0)
(4739,6087,0)
(9120,6063,0)
(2929,8811,0)
(7716,8391,0)
(2281,7224,0)
(4913,3690,0)
(3345,5248,0)
(3404,1488,0)
(4146,2089,0)
(4836,5646,0)
(96,5355,0)
(8612,7790,0)
(1754,3451,0)
(5280,2924,0)
(6969,1162,0)
(5511,6671,0)
(2632,8529,0)
(6433,2239,0)
(4252,5742,0)
(674,181,0)
(7196,2788,0)
(5931,3575,0)
(5637,4056,0)
(6419,2112,0)
(7630,7653,0)
(1019,5096,0)
(3720,1001,0)
(5958,6544,0)
(7191,8391,0)
(2785,2597,0)
(5932,9083,0)
(1602,8391,0)
(6863,2030,0)
(6949,3165,0)
(8457,2467,0)
(1273,115,0)
(4658,3784,0)
(8105,115,0)
(2789,9010,0)
(1349,115,0)
(4168,8391,0)
(3888,1078,0)
(3186,5040,0)
(3375,7647,0)
(8123,314,0)
(6069,4340,0)
(6990,9098,0)
(6822,6844,0)
(4214,6346,0)
(5414,115,0)
(5365,6503,0)
(8812,8497,0)
(9093,4785,0)
(2698,7963,0)
(3878,1680,0)
(6035,4186,0)
(6609,115,0)
(373,8976,0)
(394,5629,0)
(8770,9064,0)
(6688,6214,0)
(1781,7110,0)
(2866,2397,0)
(4306,1682,0)
(3373,8369,0)
(4125,2814,0)
(8881,8117,0)
(6931,6254,0)
(1857,7135,0)
(538,6084,0)
(4059,2836,0)
(8378,3126,0)
(6506,4501,0)
(143,280,0)
(9044,8857,0)
(2365,6114,0)
(574,8008,0)
(7910,115,0)
(5768,5445,0)
(123,7938,0)
(6419,4149,0)
(8488,4153,0)
(7887,3713,0)
(806,2176,0)
(5494,3889,0)
(6257,740,0)
(1980,4593,0)
(2095,4818,0)
(2498,1153,0)
(1415,5375,0)
(3354,1810,0)
(7797,8296,0)
(2937,8149,0)
(8121,4617,0)
(6207,6223,0)
(3452,4994,0)
(29,1216,0)
(3826,3297,0)
(6723,8391,0)
(8806,8710,0)
(3949,2832,0)
(7696,3170,0)
(786,7352,0)
(7513,5195,0)
(9110,2929,0)
(1748,981,0)
(8626,6609,0)
(6658,413,0)
(1654,3792,0)
(8333,4070,0)
(5775,5139,0)
(5112,8313,0)
(4183,4995,0)
(7216,6726,0)
(2217,3886,0)
(6929,7544,0)
(6795,675,0)
(5447,2468,0)
(6946,6101,0)
(6454,6536,0)
(7067,115,0)
(6190,8391,0)
(277,7139,0)
(2985,6269,0)
(3437,8484,0)
(6110,4231,0)
(509,272,0)
(5356,8727,0)
(425,7223,0)
(1541,1948,0)
(2677,1331,0)
(5198,3696,0)
(88,3847,0)
(5638,2065,0)
(3521,1619,0)
(6630,6155,0)
(5468,3070,0)
(2627,1409,0)
(8749,6174,0)
(1132,7230,0)
(4745,4088,0)
(8450,4000,0)
(952,3621,0)
(6556,8391,0)
(3807,115,0)
(6117,704,0)
(4772,6252,0)
(4965,7693,0)
(8833,2091,0)
(5505,6807,0)
(895,115,0)
(6862,6795,0)
(5332,5913,0)
(6188,7218,0)
(5095,7067,0)
(1260,3116,0)
(6892,7912,0)
(3482,5671,0)
(6502,2687,0)
(1740,6576,0)
(6015,2543,0)
(3483,1373,0)
(2835,5463,0)
(3713,8902,0)
(368,3819,0)
(2503,8433,0)
(6364,9125,0)
(1778,9138,0)
(930,115,0)
(8675,1234,0)
(4976,8677,0)
(2181,6671,0)
(1672,2164,0)
(3350,3865,0)
(5831,9069,0)
(3130,8391,0)
(1380,8391,0)
(4375,2681,0)
(8704,4475,0)
(1589,3902,0)
(3963,3108,0)
(6132,6746,0)
(3794,5545,0)
(1244,6227,0)
(3047,2720,0)
(4208,6308,0)
(716,6348,0)
(4552,6772,0)
(5723,221,0)
(8008,574,0)
(3734,2647,0)
(5682,7135,0)
(2958,1848,0)
(4114,6209,0)
(8471,6919,0)
(4021,4383,0)
(1605,8068,0)
(2882,1850,0)
(4073,8257,0)
(5343,8995,0)
(1344,5386,0)
(586,7718,0)
(129,8864,0)
(3867,1310,0)
(8883,4921,0)
(2056,4433,0)
(7357,8391,0)
(6284,4515,0)
(4375,8471,0)
(2678,5096,0)
(7451,7763,0)
(3166,1493,0)
(4873,4587,0)
(2545,6671,0)
(6790,6632,0)
(3430,115,0)
(7503,2085,0)
(8996,3454,0)
(255,5679,0)
(2767,872,0)
(5485,1128,0)
(615,6671,0)
(2219,2604,0)
(6134,7367,0)
(5145,4314,0)
(3957,54,0)
(5735,795,0)
(219,8391,0)
(6077,3663,0)
(7915,5419,0)
(5009,379,0)
(8380,2298,0)
(5228,881,0)
(1265,6842,0)
(7572,3658,0)
(2714,848,0)
(3509,4515,0)
(8104,7014,0)
(6808,7480,0)
(4455,1105,0)
(93,4292,0)
(2162,8391,0)
(7509,1220,0)
(6844,6950,0)
(7506,6360,0)
(2932,5856,0)
(1965,2111,0)
(2067,8286,0)
(5616,7625,0)
(7483,4066,0)
(6972,4876,0)
(5776,7979,0)
(4798,2701,0)
(841,2940,0)
(3868,115,0)
(7759,8391,0)
(6189,6912,0)
(4025,4934,0)
(2012,8354,0)
(1949,352,0)
(6878,2135,0)
(3467,1546,0)
(4704,1246,0)
(1512,4014,0)
(1045,9066,0)
(1839,7242,0)
(2199,6565,0)
(3687,7268,0)
(2980,1633,0)
(284,2036,0)
(2174,6671,0)
(892,6351,0)
(8350,4452,0)
(6656,8391,0)
(992,4785,0)
(8920,8695,0)
(1438,2845,0)
(7143,8251,0)
(3788,1911,0)
(1519,9112,0)
(1444,5054,0)
(163,5156,0)
(8481,7730,0)
(9066,274,0)
(689,3758,0)
(3518,5652,0)
(5573,8527,0)
(4329,3953,0)
(6774,4381,0)
(8147,7579,0)
(2782,115,0)
(2763,8391,0)
(8465,6912,0)
(817,6671,0)
(7088,3288,0)
(1040,5208,0)
(3867,4641,0)
(1105,8568,0)
(8315,6048,0)
(1780,2501,0)
(1614,3166,0)
(6502,5214,0)
(7139,277,0)
(7951,5244,0)
(14,6255,0)
(1789,8328,0)
(1912,4136,0)
(4394,8873,0)
(7794,7707,0)
(5270,6336,0)
(642,5950,0)
(5715,6137,0)
(1400,8352,0)
(6234,4932,0)
(182,5540,0)
(1936,6884,0)
(5578,5719,0)
(3630,6149,0)
(8751,6354,0)
(2287,2065,0)
(5861,5156,0)
(8351,6660,0)
(2404,3660,0)
(8818,4785,0)
(4440,1870,0)
(1276,3046,0)
(3865,5851,0)
(7890,4632,0)
(8091,2954,0)
(5414,8391,0)
(1413,8391,0)
(3496,8499,0)
(2711,7094,0)
(4867,4785,0)
(6760,7754,0)
(3115,3858,0)
(5464,7980,0)
(8523,6367,0)
(402,2043,0)
(7063,8391,0)
(212,115,0)
(7197,8391,0)
(7415,7003,0)
(8875,2720,0)
(6407,882,0)
(4222,1110,0)
(4041,8021,0)
(6147,4472,0)
(5465,4184,0)
(5088,2660,0)
(6477,3419,0)
(8212,6671,0)
(4501,87,0)
(640,3170,0)
(3891,2520,0)
(300,6580,0)
(1301,8723,0)
(4963,5484,0)
(1415,8727,0)
(2303,2604,0)
(7373,6494,0)
(3988,2152,0)
(7460,8247,0)
(3816,7063,0)
(962,6199,0)
(1001,8391,0)
(7350,7659,0)
(5224,3062,0)
(5102,248,0)
(3780,6068,0)
(1261,2287,0)
(2294,1085,0)
(7150,7258,0)
(738,727,0)
(2259,8521,0)
(3010,105,0)
(3707,8068,0)
(2287,87,0)
(7009,3064,0)
(8012,1262,0)
(8578,4876,0)
(3028,4705,0)
(8176,4095,0)
(358,115,0)
(3641,8057,0)
(8140,9019,0)
(6817,4118,0)
(5201,4001,0)
(5148,1652,0)
(7866,3997,0)
(2924,3549,0)
(7635,8085,0)
(7461,4580,0)
(9124,3792,0)
(5240,2654,0)
(524,2348,0)
(5602,3119,0)
(3556,5141,0)
(5554,3251,0)
(2333,8238,0)
(1231,115,0)
(6944,4837,0)
(7109,4815,0)
(5290,5156,0)
(7277,3774,0)
(9018,4758,0)
(2687,6649,0)
(2340,444,0)
(1121,6064,0)
(111,5583,0)
(3750,5851,0)
(6388,8740,0)
(9094,4630,0)
(5936,4818,0)
(965,8048,0)
(7970,4118,0)
(6814,3579,0)
(6910,5550,0)
(7188,4785,0)
(6502,5593,0)
(7966,700,0)
(5640,115,0)
(1479,2565,0)
(630,5467,0)
(3804,2681,0)
(7676,377,0)
(9141,7938,0)
(4465,4576,0)
(120,2104,0)
(1873,8391,0)
(5164,115,0)
(2021,7080,0)
(1270,3362,0)
(4717,7866,0)
(377,4865,0)
(8478,6671,0)
(3281,8496,0)
(8921,2582,0)
(2178,7989,0)
(8442,4154,0)
(8877,8901,0)
(4008,901,0)
(7115,6360,0)
(5745,3913,0)
(2205,6703,0)
(8526,5583,0)
(4866,5387,0)
(4818,2433,0)
(1766,7014,0)
(4995,4183,0)
(5666,3862,0)
(1218,1601,0)
(956,6829,0)
(6245,8578,0)
(4410,4876,0)
(2385,115,0)
(2091,5696,0)
(5977,2952,0)
(2926,2895,0)
(7893,2735,0)
(162,4830,0)
(5887,1915,0)
(904,2058,0)
(860,3051,0)
(5430,477,0)
(286,6556,0)
(8192,7453,0)
(4940,0,0)
(290,4750,0)
(2274,4883,0)
(1874,8794,0)
(5739,1432,0)
(7514,4434,0)
(594,8862,0)
(9014,4821,0)
(8246,6508,0)
(3992,4388,0)
(7431,3664,0)
(6593,8451,0)
(3625,2845,0)
(2968,3664,0)
(3318,8391,0)
(5577,8391,0)
(2657,1461,0)
(5355,9021,0)
(8716,6687,0)
(1222,5156,0)
(4014,1512,0)
(2531,1250,0)
(3501,6007,0)
(741,6575,0)
(3609,3807,0)
(2954,6428,0)
(7888,8423,0)
(2792,2642,0)
(4399,3663,0)
(2959,7042,0)
(7998,4444,0)
(2024,8352,0)
(4744,4157,0)
(8863,330,0)
(8204,5268,0)
(284,2947,0)
(1600,5752,0)
(5404,7718,0)
(5239,660,0)
(6266,6356,0)
(8608,5327,0)
(9038,115,0)
(7760,6908,0)
(3469,6534,0)
(5830,6973,0)
(2372,5408,0)
(6495,7647,0)
(1712,4876,0)
(2727,7201,0)
(6236,7358,0)
(4879,2610,0)
(8537,835,0)
(1536,7775,0)
(5989,4236,0)
(751,8851,0)
(8561,3815,0)
(8188,7912,0)
(1637,3842,0)
(7352,8776,0)
(1298,3823,0)
(6967,7608,0)
(7969,8391,0)
(4628,9017,0)
(6564,6737,0)
(2120,5926,0)
(8848,8683,0)
(8879,5078,0)
(7587,548,0)
(6284,3565,0)
(7744,4564,0)
(4828,2370,0)
(1675,115,0)
(8625,5555,0)
(329,6513,0)
(8482,595,0)
(7275,6634,0)
(7043,4068,0)
(8414,9004,0)
(3963,4919,0)
(7711,4672,0)
(4690,9068,0)
(4506,1020,0)
(2024,6985,0)
(3541,691,0)
(8957,7497,0)
(1115,7090,0)
(339,115,0)
(2470,1283,0)
(6545,2912,0)
(1432,5739,0)
(8959,512,0)
(2775,2845,0)
(1210,115,0)
(3250,115,0)
(6550,2859,0)
(4049,1551,0)
(3394,1238,0)
(1619,552,0)
(104,202,0)
(6104,581,0)
(5263,7097,0)
(1406,3087,0)
(4550,154,0)
(307,9007,0)
(4782,2231,0)
(1599,7080,0)
(1840,6279,0)
(3665,4650,0)
(4831,6866,0)
(1152,8391,0)
(3772,6433,0)
(7835,4472,0)
(5402,8391,0)
(1415,8799,0)
(8736,1122,0)
(3077,4605,0)
(8657,8757,0)
(8048,965,0)
(7534,2243,0)
(7457,902,0)
(3375,8009,0)
(7516,7858,0)
(1162,6000,0)
(902,2476,0)
(824,115,0)
(7317,7871,0)
(7006,7630,0)
(1993,3356,0)
(1613,8313,0)
(4148,3326,0)
(8405,8894,0)
(2037,2477,0)
(3713,8391,0)
(3161,3530,0)
(1260,6150,0)
(3834,4750,0)
(581,6275,0)
(2144,8763,0)
(3071,6750,0)
(4642,9023,0)
(4517,3873,0)
(3786,6070,0)
(3067,8391,0)
(1282,115,0)
(470,7347,0)
(5433,8388,0)
(533,3636,0)
(2831,2166,0)
(1406,8964,0)
(3537,2414,0)
(766,8426,0)
(2287,7140,0)
(1151,3353,0)
(2585,2326,0)
(8961,7667,0)
(4229,9019,0)
(8648,8391,0)
(1125,1407,0)
(3652,4087,0)
(6552,6560,0)
(4433,2056,0)
(258,3004,0)
(3799,8532,0)
(8038,4149,0)
(6434,1259,0)
(2506,8391,0)
(8328,115,0)
(8607,8499,0)
(4136,794,0)
(188,6671,0)
(5026,3460,0)
(6479,3857,0)
(2030,1891,0)
(1133,3969,0)
(1967,115,0)
(5089,3258,0)
(6194,2520,0)
(3107,79,0)
(7361,1122,0)
(7005,8391,0)
(746,8103,0)
(4662,7672,0)
(1520,5649,0)
(8490,2457,0)
(3806,4183,0)
(5593,8111,0)
(6563,5147,0)
(1648,8577,0)
(4375,8595,0)
(5001,6979,0)
(6037,7552,0)
(2976,9015,0)
(6228,3537,0)
(1456,4672,0)
(5909,2945,0)
(1099,1435,0)
(2017,7724,0)
(2553,8426,0)
(2747,610,0)
(3889,8730,0)
(3464,4785,0)
(1610,4108,0)
(7538,592,0)
(5729,890,0)
(8846,7089,0)
(4446,1628,0)
(3857,6479,0)
(4367,4088,0)
(8886,7664,0)
(2306,6603,0)
(2495,2717,0)
(1282,8391,0)
(8729,6847,0)
(3930,7187,0)
(2930,6335,0)
(2254,807,0)
(7590,1484,0)
(8987,393,0)
(7326,2350,0)
(7771,1644,0)
(6137,3773,0)
(3722,3735,0)
(2725,1280,0)
(2368,4972,0)
(2206,4167,0)
(219,6596,0)
(6964,4118,0)
(1838,9010,0)
(7708,5705,0)
(8035,5156,0)
(1832,8391,0)
(3338,4586,0)
(552,5089,0)
(6359,8150,0)
(6572,4785,0)
(2337,881,0)
(7160,2823,0)
(6580,300,0)
(7265,393,0)
(2940,2229,0)
(4375,2186,0)
(7592,1745,0)
(5853,7213,0)
(1556,3363,0)
(8267,1266,0)
(2540,6826,0)
(748,2360,0)
(1786,5003,0)
(59,5451,0)
(6663,8391,0)
(7,1708,0)
(2924,5280,0)
(2972,5388,0)
(3733,7292,0)
(4155,4346,0)
(986,6762,0)
(4281,2892,0)
(144,2118,0)
(579,115,0)
(1042,5665,0)
(4856,2458,0)
(7271,1418,0)
(1530,2701,0)
(657,8674,0)
(3824,7488,0)
(5027,3507,0)
(800,115,0)
(5648,7065,0)
(6349,5048,0)
(2397,2866,0)
(2648,4773,0)
(3403,2891,0)
(3666,8257,0)
(8142,7779,0)
(7296,750,0)
(3632,2948,0)
(2639,4210,0)
(7412,914,0)
(3919,5359,0)
(5166,6717,0)
(7257,4404,0)
(132,7566,0)
(5213,6214,0)
(8259,115,0)
(6485,4403,0)
(8038,700,0)
(7640,4774,0)
(3990,1420,0)
(3004,7000,0)
(3621,1158,0)
(45,8391,0)
(7108,8391,0)
(6632,8391,0)
(7722,777,0)
(807,7253,0)
(8128,264,0)
(6457,4122,0)
(8674,2879,0)
(8681,8691,0)
(8928,8445,0)
(7636,6097,0)
(3291,669,0)
(6300,1482,0)
(8034,5156,0)
(7904,5854,0)
(418,8797,0)
(2720,8391,0)
(3150,546,0)
(9035,6724,0)
(7517,7059,0)
(1546,6660,0)
(6159,3621,0)
(8722,4015,0)
(4526,550,0)
(8934,2804,0)
(901,3007,0)
(4859,6803,0)
(6483,717,0)
(8405,2818,0)
(4018,3819,0)
(7496,5483,0)
(4959,5705,0)
(8420,5608,0)
(3844,8391,0)
(2064,8521,0)
(8061,4628,0)
(4437,7191,0)
(8176,3661,0)
(1448,262,0)
(7730,2052,0)
(4687,3043,0)
(3723,2867,0)
(2323,4630,0)
(5992,5223,0)
(8855,5577,0)
(570,3752,0)
(4020,918,0)
(2172,8523,0)
(2565,1479,0)
(1870,2432,0)
(4942,7889,0)
(6449,2845,0)
(6235,4823,0)
(775,8391,0)
(6577,5947,0)
(8820,115,0)
(5851,2444,0)
(2477,2037,0)
(913,3001,0)
(1287,4445,0)
(6112,3123,0)
(3885,2119,0)
(6778,3007,0)
(2098,4824,0)
(269,6033,0)
(784,5633,0)
(5627,4682,0)
(3776,8601,0)
(5542,469,0)
(7001,7413,0)
(6150,3663,0)
(3715,7707,0)
(7820,115,0)
(2229,2940,0)
(5344,8195,0)
(7712,4475,0)
(5003,4582,0)
(2707,5499,0)
(5525,5178,0)
(2788,3877,0)
(5984,3625,0)
(9063,5554,0)
(2544,4149,0)
(2955,5309,0)
(6284,7039,0)
(908,8851,0)
(5534,6026,0)
(5538,3169,0)
(8952,1742,0)
(1128,5485,0)
(483,1517,0)
(6057,8391,0)
(2650,7626,0)
(727,115,0)
(4043,8391,0)
(4792,4356,0)
(5811,5033,0)
(3808,1808,0)
(4720,8846,0)
(855,3783,0)
(4936,8047,0)
(8995,5254,0)
(1957,1599,0)
(7141,2862,0)
(3876,115,0)
(1154,5107,0)
(8967,6394,0)
(3640,5893,0)
(8876,6734,0)
(414,2005,0)
(3768,6535,0)
(2674,595,0)
(2598,845,0)
(7038,115,0)
(567,3012,0)
(8189,4473,0)
(2041,8680,0)
(7771,4333,0)
(2081,1542,0)
(2275,4055,0)
(4848,6995,0)
(4918,743,0)
(5172,8391,0)
(765,784,0)
(1694,8391,0)
(1479,6417,0)
(3736,4014,0)
(4320,7400,0)
(1953,3278,0)
(6417,1479,0)
(8418,6825,0)
(2781,158,0)
(5593,2112,0)
(3333,5254,0)
(5785,2366,0)
(4794,6793,0)
(2622,2843,0)
(5290,8131,0)
(4023,9086,0)
(1938,3801,0)
(6627,115,0)
(3914,1169,0)
(1783,3942,0)
(549,8176,0)
(3590,5840,0)
(2108,3087,0)
(170,115,0)
(2937,5251,0)
(3101,115,0)
(379,6968,0)
(5140,7210,0)
(4487,1121,0)
(186,506,0)
(8015,3673,0)
(6098,3992,0)
(6913,2966,0)
(1939,3512,0)
(5743,7670,0)
(5173,5586,0)
(4378,8560,0)
(8696,8238,0)
(715,6088,0)
(8497,8812,0)
(588,1319,0)
(6049,7541,0)
(5810,1389,0)
(1647,8386,0)
(433,5823,0)
(510,4694,0)
(562,1247,0)
(1017,8391,0)
(8432,8840,0)
(454,6103,0)
(635,6215,0)
(6456,4522,0)
(5555,8391,0)
(5435,1150,0)
(6091,115,0)
(5545,2047,0)
(3003,213,0)
(7000,1996,0)
(6223,8391,0)
(2710,8088,0)
(5638,489,0)
(6318,7714,0)
(3553,6677,0)
(7134,8548,0)
(8038,8021,0)
(5659,7296,0)
(895,8391,0)
(3621,1280,0)
(6049,3171,0)
(416,8391,0)
(3432,2139,0)
(2034,6004,0)
(6074,6198,0)
(3842,1637,0)
(4758,2845,0)
(5638,6563,0)
(8147,7670,0)
(4016,1685,0)
(1036,1087,0)
(8825,6900,0)
(9062,8777,0)
(3804,1405,0)
(3528,1020,0)
(4347,1808,0)
(1555,115,0)
(4919,6541,0)
(1415,2681,0)
(905,7025,0)
(2487,7030,0)
(2389,2477,0)
(8580,448,0)
(6378,8391,0)
(3380,9043,0)
(3842,2036,0)
(4551,3088,0)
(3892,482,0)
(5405,5238,0)
(8307,7519,0)
(8581,7874,0)
(1205,2295,0)
(5150,6534,0)
(4701,7167,0)
(8635,2037,0)
(3379,4626,0)
(1504,7216,0)
(4042,3501,0)
(1540,3153,0)
(3218,3487,0)
(283,4897,0)
(4298,7571,0)
(5884,1008,0)
(5630,8601,0)
(4735,3445,0)
(4779,3023,0)
(6265,1273,0)
(4331,3230,0)
(3157,6699,0)
(173,7889,0)
(1436,3773,0)
(2287,6649,0)
(5961,4670,0)
(7561,2845,0)
(7594,3183,0)
(1028,1303,0)
(2203,2043,0)
(7996,2330,0)
(816,5422,0)
(4137,7546,0)
(217,5817,0)
(4954,1488,0)
(641,8957,0)
(8411,2764,0)
(7264,7711,0)
(8865,7802,0)
(8812,3714,0)
(7201,4448,0)
(7111,7577,0)
(1275,4711,0)
(7947,7340,0)
(6291,7411,0)
(3065,5268,0)
(6328,2591,0)
(8433,6067,0)
(4289,4690,0)
(4346,4155,0)
(6551,4026,0)
(6314,2776,0)
(2685,4880,0)
(3866,8244,0)
(6083,6708,0)
(2895,2288,0)
(3251,3346,0)
(2500,8723,0)
(8018,2235,0)
(2427,5109,0)
(6387,292,0)
(8706,1784,0)
(3866,4968,0)
(4434,7514,0)
(1245,3538,0)
(5335,7844,0)
(5755,6678,0)
(2147,8391,0)
(3621,9130,0)
(2591,115,0)
(1367,2286,0)
(2239,115,0)
(7604,7829,0)
(5965,2043,0)
(9004,8391,0)
(7762,8289,0)
(1967,7485,0)
(8021,8391,0)
(3969,8889,0)
(1461,2657,0)
(8080,1055,0)
(3722,4840,0)
(7981,3101,0)
(8220,6671,0)
(6534,3469,0)
(6710,4861,0)
(2026,4785,0)
(762,4560,0)
(5991,8222,0)
(664,5748,0)
(636,1591,0)
(6907,1250,0)
(2046,6333,0)
(9028,8340,0)
(8467,6358,0)
(9122,7222,0)
(4495,1800,0)
(1168,115,0)
(2458,7210,0)
(6886,6671,0)
(6099,8553,0)
(7710,8391,0)
(1806,8097,0)
(3097,250,0)
(3874,8500,0)
(7798,8778,0)
(2467,115,0)
(6716,2914,0)
(3621,8948,0)
(4590,8594,0)
(6893,4831,0)
(8085,972,0)
(3441,4934,0)
(6540,973,0)
(3708,873,0)
(8466,3897,0)
(4417,8601,0)
(7928,6868,0)
(121,8391,0)
(5978,350,0)
(4087,115,0)
(2140,6713,0)
(5159,4378,0)
(8183,1969,0)
(1877,2211,0)
(1106,7291,0)
(1780,8648,0)
(7062,6234,0)
(3752,989,0)
(6412,2043,0)
(8118,2735,0)
(104,2035,0)
(8403,7085,0)
(1908,191,0)
(836,1717,0)
(4052,2381,0)
(6636,6846,0)
(6831,2497,0)
(2881,1121,0)
(4901,573,0)
(7003,5532,0)
(2713,1039,0)
(501,514,0)
(5891,1350,0)
(3831,7500,0)
(425,115,0)
(5147,1899,0)
(4375,7280,0)
(3199,6935,0)
(4886,1725,0)
(146,3529,0)
(4677,3397,0)
(4849,3358,0)
(4024,5212,0)
(3725,5223,0)
(8901,7561,0)
(7966,8458,0)
(701,2003,0)
(6866,3058,0)
(6084,538,0)
(2518,4920,0)
(2544,4515,0)
(7922,6462,0)
(5586,6298,0)
(302,7859,0)
(4099,6278,0)
(8891,4624,0)
(5085,9064,0)
(4474,3895,0)
(2599,2027,0)
(3477,1878,0)
(8297,6057,0)
(141,119,0)
(92,1764,0)
(7060,7357,0)
(1937,3169,0)
(7793,300,0)
(6205,4785,0)
(8844,4909,0)
(2621,8435,0)
(5357,7039,0)
(1357,4746,0)
(5944,8593,0)
(5867,6620,0)
(7938,9141,0)
(1285,6468,0)
(2300,7972,0)
(8119,1351,0)
(1840,3313,0)
(5829,1246,0)
(8846,4720,0)
(4388,7724,0)
(7156,4511,0)
(4702,6525,0)
(6427,8055,0)
(4506,925,0)
(6783,1061,0)
(9098,1062,0)
(1800,4726,0)
(7413,7001,0)
(1420,3090,0)
(5495,4836,0)
(4617,8121,0)
(393,988,0)
(408,8247,0)
(3276,8415,0)
(150,1648,0)
(121,115,0)
(6919,2520,0)
(234,3054,0)
(6629,6646,0)
(6486,2217,0)
(8205,5164,0)
(2348,524,0)
(8986,4620,0)
(2162,5532,0)
(795,8391,0)
(2987,1077,0)
(7728,5684,0)
(1924,8391,0)
(6677,5250,0)
(3372,4470,0)
(4872,4402,0)
(2623,115,0)
(1210,8251,0)
(9036,1189,0)
(7910,5317,0)
(8307,9034,0)
(450,7197,0)
(548,7587,0)
(4400,8975,0)
(7785,909,0)
(4649,4798,0)
(7288,3001,0)
(5532,7003,0)
(6049,4252,0)
(1764,111,0)
(5499,3313,0)
(4398,4470,0)
(2227,2549,0)
(2622,3075,0)
(6703,3439,0)
(5638,6921,0)
(3773,7711,0)
(7182,115,0)
(1852,6968,0)
(1005,6347,0)
(1773,6671,0)
(4153,8488,0)
(8670,8273,0)
(8325,2256,0)
(3315,6428,0)
(6544,7929,0)
(1937,8391,0)
(4352,3098,0)
(3335,1488,0)
(5981,5486,0)
(851,7207,0)
(2970,3342,0)
(1418,5829,0)
(9010,115,0)
(4667,2111,0)
(1283,2470,0)
(8105,8391,0)
(8567,8479,0)
(573,159,0)
(4652,5886,0)
(2044,2316,0)
(5290,7859,0)
(5603,3128,0)
(8543,7968,0)
(9016,1210,0)
(1735,7710,0)
(1860,6458,0)
(4182,5829,0)
(8910,8764,0)
(5894,356,0)
(3738,1453,0)
(7491,8989,0)
(8259,1376,0)
(4822,3513,0)
(872,4452,0)
(4577,9036,0)
(1955,8391,0)
(5394,115,0)
(8572,1564,0)
(5069,1013,0)
(4840,8391,0)
(6073,700,0)
(4398,8391,0)
(5638,7280,0)
(2198,8362,0)
(7633,4475,0)
(8552,7586,0)
(2273,5991,0)
(8053,5099,0)
(6298,5586,0)
(2369,8955,0)
(7555,8768,0)
(6006,7046,0)
(7191,6565,0)
(6880,4095,0)
(8659,4570,0)
(2979,469,0)
(4484,2570,0)
(9012,8341,0)
(108,720,0)
(202,4307,0)
(4174,8649,0)
(4861,5926,0)
(2009,6023,0)
(7488,202,0)
(1962,811,0)
(7825,5749,0)
(2332,108,0)
(3048,2788,0)
(917,5594,0)
(6450,6199,0)
(4862,118,0)
(6352,3259,0)
(8496,3858,0)
(3309,6671,0)
(1886,6608,0)
(7634,847,0)
(2414,1794,0)
(2189,213,0)
(5646,4836,0)
(4344,7711,0)
(3970,491,0)
(8430,1162,0)
(5807,4064,0)
(7966,7659,0)
(541,386,0)
(4974,5755,0)
(3316,8582,0)
(5016,2481,0)
(8944,6557,0)
(4631,5859,0)
(2094,7337,0)
(4361,4466,0)
(3574,2093,0)
(58,996,0)
(4375,4705,0)
(3928,7799,0)
(5965,5829,0)
(7059,3024,0)
(6419,700,0)
(6241,1086,0)
(6881,4876,0)
(5841,1026,0)
(6993,3940,0)
(2496,2151,0)
(8488,3008,0)
(2035,7718,0)
(6627,4922,0)
(75,5516,0)
(7502,8726,0)
(9003,6891,0)
(6419,1270,0)
(2018,4809,0)
(4634,8527,0)
(3621,3889,0)
(8908,1365,0)
(3746,2354,0)
(7528,7060,0)
(3732,1787,0)
(7890,932,0)
(6508,8246,0)
(2526,4604,0)
(7945,3648,0)
(2544,8150,0)
(1415,6571,0)
(7152,5829,0)
(2959,4258,0)
(457,392,0)
(2647,2536,0)
(5195,3313,0)
(1300,9076,0)
(1896,3764,0)
(7339,6349,0)
(437,115,0)
(5656,3062,0)
(4705,567,0)
(370,8600,0)
(9108,4763,0)
(7185,3096,0)
(7187,5484,0)
(8296,3875,0)
(3171,6049,0)
(3069,5795,0)
(1286,9001,0)
(4350,3243,0)
(6665,6367,0)
(2200,4172,0)
(5259,8138,0)
(4429,1070,0)
(7672,4516,0)
(4453,3983,0)
(7524,1149,0)
(5515,5847,0)
(610,115,0)
(5260,4452,0)
(5040,1725,0)
(3153,5926,0)
(4924,555,0)
(5887,7463,0)
(8845,7375,0)
(8991,6671,0)
(3465,5483,0)
(4641,3867,0)
(6261,4619,0)
(4122,1278,0)
(2154,8014,0)
(2752,7940,0)
(7869,6114,0)
(953,6865,0)
(2287,4149,0)
(5546,1500,0)
(1392,115,0)
(6678,115,0)
(4037,2295,0)
(3265,5785,0)
(2299,8391,0)
(8099,4767,0)
(6897,5991,0)
(253,3346,0)
(5345,5413,0)
(4494,8391,0)
(2798,6445,0)
(6350,7675,0)
(3831,2220,0)
(5342,6060,0)
(8149,2937,0)
(8932,8641,0)
(6792,477,0)
(2287,2681,0)
(5388,2972,0)
(3066,4785,0)
(914,5156,0)
(4104,8487,0)
(7863,8391,0)
(616,4553,0)
(3678,8393,0)
(1478,115,0)
(3899,115,0)
(5230,779,0)
(8247,408,0)
(3596,5829,0)
(6419,8458,0)
(5809,3215,0)
(7737,124,0)
(4998,5927,0)
(4680,6146,0)
(675,6795,0)
(1489,1612,0)
(7571,2449,0)
(976,5594,0)
(30,5774,0)
(4903,3004,0)
(4375,7380,0)
(7480,6808,0)
(6132,3569,0)
(3213,4515,0)
(6198,8391,0)
(4661,3548,0)
(885,924,0)
(4192,3970,0)
(6561,8293,0)
(4789,2845,0)
(977,6293,0)
(5699,9038,0)
(4198,115,0)
(3046,517,0)
(5168,3947,0)
(6510,553,0)
(5591,1029,0)
(1578,4452,0)
(2543,149,0)
(2851,3713,0)
(8335,4490,0)
(8769,212,0)
(3483,5156,0)
(2986,2775,0)
(813,6871,0)
(5385,3415,0)
(402,8712,0)
(8619,8148,0)
(1471,4876,0)
(5809,9130,0)
(4332,2686,0)
(3977,1603,0)
(4189,8824,0)
(4565,462,0)
(5972,8807,0)
(8669,4470,0)
(2754,40,0)
(5272,5086,0)
(5599,1061,0)
(1221,2920,0)
(1372,578,0)
(1070,164,0)
(4219,2375,0)
(7405,6081,0)
(6691,8844,0)
(2802,1220,0)
(7790,4581,0)
(4993,5914,0)
(8598,1516,0)
(6663,2845,0)
(6320,5744,0)
(859,7841,0)
(883,3260,0)
(39,5337,0)
(3430,8391,0)
(1796,6671,0)
(908,2415,0)
(5507,3868,0)
(2391,4605,0)
(4757,2167,0)
(7626,7280,0)
(299,2183,0)
(984,8585,0)
(1526,2206,0)
(1560,577,0)
(9088,8391,0)
(743,4918,0)
(2585,617,0)
(7025,3941,0)
(8787,8198,0)
(460,9141,0)
(3353,3381,0)
(8789,6337,0)
(6271,5249,0)
(6430,4272,0)
(5701,5335,0)
(6029,3849,0)
(2020,8143,0)
(1760,2794,0)
(7338,2482,0)
(970,348,0)
(3863,8567,0)
(1543,6321,0)
(5519,8391,0)
(583,4785,0)
(1659,1082,0)
(6051,6649,0)
(648,1245,0)
(6592,611,0)
(5638,3889,0)
(4923,8205,0)
(2688,8391,0)
(25,8391,0)
(5983,8432,0)
(1873,7127,0)
(8512,5383,0)
(6575,2481,0)
(7010,8477,0)
(6323,7286,0)
(6837,6196,0)
(7236,7398,0)
(99,4005,0)
(5490,5848,0)
(2744,1349,0)
(5602,392,0)
(1435,135,0)
(6121,1813,0)
(7225,1045,0)
(9060,5077,0)
(3294,5993,0)
(5046,8377,0)
(3287,7066,0)
(9091,771,0)
(6209,2690,0)
(3984,2906,0)
(2633,4785,0)
(4089,3621,0)
(1537,6799,0)
(1136,6592,0)
(3591,577,0)
(7792,330,0)
(8798,6623,0)
(779,8977,0)
(4154,345,0)
(6905,3278,0)
(3917,7196,0)
(1880,944,0)
(6537,1694,0)
(1214,3661,0)
(4714,7714,0)
(7029,6080,0)
(6031,8398,0)
(989,3752,0)
(7671,2136,0)
(1939,1382,0)
(8535,4560,0)
(6808,7857,0)
(5910,4672,0)
(2616,8862,0)
(3294,4006,0)
(725,1564,0)
(8111,2116,0)
(2175,4161,0)
(1471,4119,0)
(1568,1394,0)
(1039,7871,0)
(2766,7065,0)
(5725,7357,0)
(8703,7510,0)
(6002,5058,0)
(966,3932,0)
(8418,2224,0)
(6614,4672,0)
(4748,5998,0)
(5507,6554,0)
(4389,115,0)
(5120,3166,0)
(6919,5667,0)
(7623,8354,0)
(7951,143,0)
(3108,3963,0)
(747,3904,0)
(6151,5317,0)
(9019,8391,0)
(7300,5898,0)
(3170,1284,0)
(3307,6000,0)
(4771,1560,0)
(3847,115,0)
(4873,4882,0)
(3651,7754,0)
(6502,2287,0)
(8367,1535,0)
(1900,6664,0)
(1177,8391,0)
(2539,8373,0)
(7565,7046,0)
(8929,4410,0)
(694,8776,0)
(8296,3451,0)
(359,3512,0)
(7058,8540,0)
(2472,1708,0)
(529,1008,0)
(1079,697,0)
(8134,3842,0)
(7745,6609,0)
(8978,1881,0)
(7119,2445,0)
(6052,8054,0)
(1075,7515,0)
(4294,8570,0)
(5483,8074,0)
(885,2488,0)
(296,6939,0)
(7282,2041,0)
(8102,7541,0)
(6282,4957,0)
(191,882,0)
(7966,9130,0)
(7626,8111,0)
(6548,154,0)
(3675,4401,0)
(5093,3680,0)
(8550,671,0)
(3393,6855,0)
(8190,7863,0)
(7782,5953,0)
(2680,8824,0)
(2317,1296,0)
(7989,6464,0)
(3952,7499,0)
(2909,8391,0)
(175,3031,0)
(6678,8391,0)
(1623,799,0)
(9119,8391,0)
(911,5315,0)
(7365,8616,0)
(1707,115,0)
(7580,4540,0)
(3623,3259,0)
(2686,4332,0)
(7494,5615,0)
(524,6386,0)
(8063,5128,0)
(7553,8790,0)
(7556,4150,0)
(4793,7888,0)
(8500,8391,0)
(371,8198,0)
(2793,437,0)
(5007,6355,0)
(8330,2900,0)
(4704,1679,0)
(2615,3932,0)
(6700,8391,0)
(4419,3738,0)
(2488,92,0)
(8541,6671,0)
(7085,8403,0)
(3886,506,0)
(6609,8626,0)
(8038,6968,0)
(3778,1899,0)
(8186,6671,0)
(6516,7250,0)
(5439,866,0)
(3942,1783,0)
(4850,115,0)
(2665,2623,0)
(304,7638,0)
(5716,6652,0)
(5419,5810,0)
(6526,6103,0)
(7097,4340,0)
(8841,1907,0)
(773,2961,0)
(5189,1329,0)
(7510,8391,0)
(5823,4704,0)
(4133,7675,0)
(8570,2133,0)
(5226,8567,0)
(1828,7531,0)
(697,1079,0)
(2415,908,0)
(3285,1401,0)
(4230,5684,0)
(5195,4505,0)
(8576,7203,0)
(973,2481,0)
(7172,2446,0)
(1270,5727,0)
(5348,5383,0)
(6709,5870,0)
(3308,4785,0)
(3530,5433,0)
(5828,1478,0)
(3527,349,0)
(1968,836,0)
(1004,2315,0)
(1547,7065,0)
(7136,4805,0)
(8768,2416,0)
(2297,8391,0)
(8648,1780,0)
(2243,8391,0)
(4410,7387,0)
(8685,8245,0)
(560,706,0)
(3757,202,0)
(360,5140,0)
(3272,8323,0)
(4566,2538,0)
(1945,2446,0)
(4926,6140,0)
(2109,1783,0)
(6555,115,0)
(1624,6881,0)
(6713,2140,0)
(5673,4420,0)
(9028,4977,0)
(5877,7962,0)
(197,7622,0)
(4287,2873,0)
(8254,3483,0)
(2877,4670,0)
(7169,3899,0)
(8994,1555,0)
(8622,5140,0)
(7652,5960,0)
(1175,8478,0)
(2709,4116,0)
(6419,8111,0)
(2140,8319,0)
(6840,8790,0)
(598,202,0)
(8819,6736,0)
(6819,5556,0)
(4604,2526,0)
(1122,115,0)
(8592,115,0)
(4221,8655,0)
(4299,7262,0)
(3114,8391,0)
(907,1380,0)
(76,7339,0)
(7454,51,0)
(8895,8768,0)
(2345,5605,0)
(3363,7293,0)
(8259,8391,0)
(5656,1833,0)
(6425,8757,0)
(6419,6649,0)
(7759,3451,0)
(900,7366,0)
(6431,1972,0)
(647,4745,0)
(490,7903,0)
(6175,6808,0)
(1231,8391,0)
(1289,835,0)
(3431,8130,0)
(5823,5294,0)
(6283,8335,0)
(2684,6174,0)
(3299,7054,0)
(4290,3268,0)
(1900,2653,0)
(8008,115,0)
(1741,2059,0)
(6491,6088,0)
(9026,115,0)
(5917,3569,0)
(1198,8217,0)
(7656,3621,0)
(1799,6995,0)
(4183,3806,0)
(989,115,0)
(8304,2585,0)
(2281,8134,0)
(6131,5042,0)
(1707,3538,0)
(2386,5881,0)
(2287,7039,0)
(6528,3138,0)
(5652,4309,0)
(2693,7293,0)
(3282,6299,0)
(8105,3435,0)
(7198,2845,0)
(3577,895,0)
(4186,4100,0)
(6378,4741,0)
(1958,1055,0)
(1394,7816,0)
(48,7897,0)
(468,528,0)
(8486,4012,0)
(1411,1708,0)
(1464,3507,0)
(4319,115,0)
(7363,838,0)
(4285,3192,0)
(6956,4068,0)
(5452,6084,0)
(653,474,0)
(57,2996,0)
(8444,4785,0)
(6977,6671,0)
(7090,7909,0)
(2198,4191,0)
(2487,8391,0)
(446,5530,0)
(1461,2527,0)
(2870,7588,0)
(8791,465,0)
(299,4876,0)
(2347,4205,0)
(2386,2043,0)
(4422,3512,0)
(8386,713,0)
(2470,2311,0)
(2971,3619,0)
(7262,4299,0)
(6306,8799,0)
(1628,3248,0)
(897,115,0)
(152,7210,0)
(8437,1876,0)
(211,8742,0)
(2452,1150,0)
(3549,2293,0)
(6495,5126,0)
(3248,1907,0)
(9029,3629,0)
(5851,3865,0)
(8884,115,0)
(7385,6419,0)
(2099,4464,0)
(8397,3596,0)
(4089,3451,0)
(7145,7597,0)
(4675,6146,0)
(3747,7207,0)
(5643,5297,0)
(5032,5597,0)
(8499,3496,0)
(7203,8719,0)
(4391,115,0)
(2464,4475,0)
(8860,7790,0)
(3883,598,0)
(6858,784,0)
(1850,6033,0)
(1441,785,0)
(3085,5402,0)
(6968,379,0)
(4985,2593,0)
(8480,1452,0)
(1084,3986,0)
(7910,2845,0)
(7880,7346,0)
(3396,240,0)
(2428,8225,0)
(7699,7980,0)
(1575,396,0)
(5934,5396,0)
(9004,115,0)
(228,4032,0)
(6889,8391,0)
(4346,8825,0)
(1134,7054,0)
(6694,3053,0)
(3742,3902,0)
(9112,1311,0)
(41,8818,0)
(8581,1265,0)
(7579,2690,0)
(7649,7320,0)
(1369,5156,0)
(6220,8391,0)
(1437,4899,0)
(3532,6657,0)
(1283,2335,0)
(8133,5614,0)
(246,727,0)
(7003,5849,0)
(4769,3240,0)
(8699,3193,0)
(4610,1340,0)
(4375,5655,0)
(4452,3668,0)
(8335,4718,0)
(7815,6815,0)
(6244,6194,0)
(573,7159,0)
(8940,7527,0)
(8088,2258,0)
(1220,4619,0)
(8737,629,0)
(6589,2904,0)
(8059,1551,0)
(2676,1387,0)
(2166,4564,0)
(3090,1420,0)
(7626,8471,0)
(3979,3278,0)
(850,670,0)
(6641,7461,0)
(5477,8391,0)
(7133,1149,0)
(5815,7373,0)
(7168,8766,0)
(7573,1039,0)
(646,6520,0)
(847,7634,0)
(4818,2396,0)
(3854,5351,0)
(2437,7638,0)
(9142,1107,0)
(4995,8113,0)
(2630,5812,0)
(2504,1890,0)
(4690,268,0)
(5855,3911,0)
(6317,2845,0)
(5914,8108,0)
(8248,202,0)
(6419,1158,0)
(6617,6528,0)
(4275,7110,0)
(8506,4864,0)
(2011,4319,0)
(5614,4453,0)
(8579,6995,0)
(1032,502,0)
(9070,1906,0)
(7980,2309,0)
(5622,9086,0)
(3602,3313,0)
(4466,6746,0)
(8389,6649,0)
(3969,4704,0)
(2952,5498,0)
(3840,392,0)
(1041,6021,0)
(5624,4711,0)
(2376,2253,0)
(8761,8702,0)
(5808,636,0)
(7230,1611,0)
(891,8732,0)
(2735,7291,0)
(1620,6671,0)
(6599,3288,0)
(8377,4758,0)
(9078,81,0)
(6838,2907,0)
(1925,6545,0)
(3148,504,0)
(5871,6782,0)
(5463,2835,0)
(912,218,0)
(7784,1181,0)
(5950,4876,0)
(8279,8391,0)
(3619,1488,0)
(636,3165,0)
(780,8391,0)
(6453,951,0)
(1982,5422,0)
(215,750,0)
(1831,5256,0)
(7208,6896,0)
(4620,6159,0)
(825,245,0)
(301,1488,0)
(160,4224,0)
(8975,240,0)
(6951,5670,0)
(2668,248,0)
(6661,1573,0)
(6695,4843,0)
(5131,6259,0)
(4780,5752,0)
(1645,7005,0)
(6920,8683,0)
(9117,115,0)
(8388,2059,0)
(2552,7108,0)
(8173,2867,0)
(2945,5553,0)
(6882,3801,0)
(2994,3008,0)
(2225,6341,0)
(7466,4785,0)
(8268,1282,0)
(9079,4785,0)
(4360,6092,0)
(5257,5655,0)
(3603,5078,0)
(8069,3663,0)
(2020,8184,0)
(8209,3501,0)
(6156,8849,0)
(1695,124,0)
(5702,655,0)
(6146,3240,0)
(3255,7707,0)
(6502,5809,0)
(2995,7257,0)
(6087,4733,0)
(2418,3663,0)
(8697,5156,0)
(455,573,0)
(209,4884,0)
(5868,8074,0)
(9050,1511,0)
(4172,6614,0)
(2304,8585,0)
(3831,3096,0)
(7364,9012,0)
(7346,7880,0)
(1438,3597,0)
(1719,0,0)
(5983,6577,0)
(7219,7679,0)
(2426,6457,0)
(2748,753,0)
(7072,7042,0)
(616,1792,0)
(580,3815,0)
(6303,8616,0)
(6430,8391,0)
(4337,529,0)
(2902,555,0)
(5418,5085,0)
(8159,3250,0)
(6982,9048,0)
(1401,3285,0)
(7398,3128,0)
(549,3153,0)
(4391,8391,0)
(3521,4800,0)
(1008,2210,0)
(2688,115,0)
(5708,8989,0)
(5419,115,0)
(4536,2116,0)
(2113,6671,0)
(4475,7264,0)
(3621,700,0)
(2543,8111,0)
(1693,2825,0)
(7383,3719,0)
(6669,6566,0)
(4557,8279,0)
(5593,4515,0)
(7378,1967,0)
(7749,8738,0)
(6723,4616,0)
(8914,5419,0)
(8364,6975,0)
(2483,6173,0)
(996,2748,0)
(3968,9013,0)
(7906,7927,0)
(7555,7549,0)
(6315,1172,0)
(2946,1478,0)
(3283,8041,0)
(1878,115,0)
(5101,8211,0)
(5618,7897,0)
(7157,1694,0)
(1530,1744,0)
(6399,6159,0)
(5975,4239,0)
(4375,6356,0)
(6043,1840,0)
(5074,1038,0)
(4559,5251,0)
(6236,8391,0)
(1474,1158,0)
(1924,6346,0)
(4594,292,0)
(4773,8391,0)
(8252,6986,0)
(5887,3950,0)
(3102,8899,0)
(1511,9050,0)
(2475,1623,0)
(2432,1870,0)
(2342,2346,0)
(5980,2573,0)
(7891,7380,0)
(3961,8109,0)
(6713,115,0)
(6925,4672,0)
(2049,2466,0)
(207,1607,0)
(1188,3602,0)
(3343,4424,0)
(6259,4212,0)
(8392,7830,0)
(5164,8391,0)
(1812,4089,0)
(8101,241,0)
(5200,4470,0)
(2258,7354,0)
(6666,115,0)
(4310,6090,0)
(1012,6009,0)
(909,2845,0)
(2420,6671,0)
(8772,358,0)
(2190,6916,0)
(7935,5543,0)
(5868,2043,0)
(927,6995,0)
(2623,2665,0)
(5409,6069,0)
(6881,5156,0)
(8673,3701,0)
(5258,6076,0)
(7863,8190,0)
(1328,8595,0)
(1558,6671,0)
(8528,5332,0)
(2260,8233,0)
(1986,7536,0)
(4796,8994,0)
(7535,1304,0)
(6237,2724,0)
(8823,1227,0)
(1493,3166,0)
(7820,8391,0)
(7730,8481,0)
(7995,2172,0)
(8867,176,0)
(3797,8050,0)
(2176,2457,0)
(5075,3539,0)
(774,115,0)
(2822,7363,0)
(5912,2737,0)
(5261,7050,0)
(5497,2640,0)
(1400,8391,0)
(5143,8923,0)
(3674,1145,0)
(309,115,0)
(7323,1043,0)
(2398,5193,0)
(7293,8362,0)
(5752,1600,0)
(1076,7019,0)
(7234,8175,0)
(4260,3969,0)
(6953,6750,0)
(7639,4641,0)
(3668,8723,0)
(1940,2186,0)
(8176,7316,0)
(719,6535,0)
(4341,823,0)
(3466,4707,0)
(18,8000,0)
(7056,2808,0)
(4731,6611,0)
(7031,8391,0)
(7718,2035,0)
(2246,3175,0)
(8797,3561,0)
(4441,45,0)
(2597,6167,0)
(5052,8946,0)
(6080,8391,0)
(9118,2160,0)
(400,930,0)
(4072,3650,0)
(3405,2381,0)
(2265,5829,0)
(7701,8258,0)
(8273,1840,0)
(7031,4593,0)
(8739,3145,0)
(5906,8683,0)
(792,7485,0)
(2085,6227,0)
(530,4632,0)
(4242,6317,0)
(8479,8567,0)
(5869,7888,0)
(5851,6358,0)
(4366,1544,0)
(7499,8391,0)
(5789,6805,0)
(6525,2628,0)
(158,8391,0)
(3859,5712,0)
(8762,8111,0)
(6793,295,0)
(8688,6198,0)
(3062,5656,0)
(4457,3067,0)
(4410,5156,0)
(914,4393,0)
(7767,2111,0)
(7226,6452,0)
(7372,8041,0)
(1429,9096,0)
(5856,3128,0)
(2025,1825,0)
(1415,3889,0)
(723,5804,0)
(3983,7741,0)
(6063,3284,0)
(3096,3831,0)
(3898,4228,0)
(9021,1110,0)
(771,1149,0)
(7035,2329,0)
(516,8738,0)
(7221,5537,0)
(3783,855,0)
(3621,8458,0)
(6547,6952,0)
(4868,8801,0)
(8047,8677,0)
(1227,3487,0)
(5082,3980,0)
(5852,438,0)
(2231,8200,0)
(8513,8830,0)
(6287,6671,0)
(926,8391,0)
(8225,7187,0)
(8985,7449,0)
(3804,6435,0)
(406,5550,0)
(5483,1048,0)
(2434,7851,0)
(1975,3463,0)
(8261,5337,0)
(4515,8175,0)
(2841,7724,0)
(7375,7041,0)
(6234,115,0)
(145,7449,0)
(2156,3424,0)
(9117,8391,0)
(3542,8815,0)
(3804,9130,0)
(6926,115,0)
(4548,2768,0)
(2984,7638,0)
(7486,2047,0)
(1062,7545,0)
(4322,4451,0)
(1135,4076,0)
(6509,3780,0)
(3285,968,0)
(6581,2567,0)
(7354,2258,0)
(7671,3403,0)
(118,3512,0)
(7217,5998,0)
(1607,207,0)
(8822,2751,0)
(4067,3138,0)
(7292,638,0)
(5833,2111,0)
(2237,8391,0)
(7432,2220,0)
(2938,115,0)
(6985,2024,0)
(768,8391,0)
(3298,4785,0)
(2384,115,0)
(6752,8439,0)
(7783,4801,0)
(6360,3621,0)
(8084,6791,0)
(4125,2131,0)
(4401,3675,0)
(2757,2729,0)
(8379,53,0)
(7084,9043,0)
(7626,4587,0)
(6366,4076,0)
(6042,8544,0)
(207,1917,0)
(6502,8038,0)
(5694,8222,0)
(8227,2189,0)
(11,3347,0)
(8296,6084,0)
(8718,2677,0)
(827,6288,0)
(2732,8626,0)
(6586,2311,0)
(1411,3962,0)
(868,1046,0)
(3014,6091,0)
(6918,7757,0)
(603,1241,0)
(4841,3512,0)
(9024,79,0)
(1034,942,0)
(965,8628,0)
(68,9003,0)
(4834,7930,0)
(6311,362,0)
(4470,6671,0)
(270,7672,0)
(1590,1729,0)
(1680,3878,0)
(4949,2869,0)
(3090,2651,0)
(8090,6333,0)
(2256,4002,0)
(3828,8391,0)
(7923,4900,0)
(9021,5355,0)
(7584,6671,0)
(853,1204,0)
(1206,2381,0)
(5239,3424,0)
(5928,4307,0)
(7162,4307,0)
(6627,8391,0)
(1720,4765,0)
(5245,9043,0)
(4988,8289,0)
(2239,8391,0)
(1029,7866,0)
(2305,8852,0)
(1122,8391,0)
(6961,4697,0)
(2920,7349,0)
(1415,8021,0)
(6674,6087,0)
(9067,115,0)
(2893,8610,0)
(7198,2460,0)
(1415,5057,0)
(7493,6971,0)
(4058,2072,0)
(6592,5829,0)
(731,5704,0)
(3202,3149,0)
(2151,6665,0)
(7287,2845,0)
(5288,2476,0)
(5471,170,0)
(2287,8458,0)
(5183,1293,0)
(2237,7711,0)
(4855,903,0)
(7966,1158,0)
(2299,115,0)
(4665,4976,0)
(3469,3493,0)
(5580,2927,0)
(5355,115,0)
(852,9015,0)
(1219,8454,0)
(5549,504,0)
(1177,115,0)
(7222,115,0)
(4805,7136,0)
(8626,2518,0)
(5646,114,0)
(4424,4371,0)
(8293,6561,0)
(4732,7546,0)
(6190,5184,0)
(2737,7741,0)
(4,2918,0)
(7159,3621,0)
(2697,6048,0)
(7704,1525,0)
(7969,115,0)
(8966,115,0)
(988,7248,0)
(1746,6708,0)
(3835,6993,0)
(3216,4307,0)
(8906,7166,0)
(1573,2961,0)
(7291,2735,0)
(6064,4445,0)
(7493,2116,0)
(7400,7328,0)
(5433,6533,0)
(4742,3292,0)
(655,3054,0)
(2588,7586,0)
(832,8156,0)
(5615,1488,0)
(6214,487,0)
(427,6671,0)
(8038,3889,0)
(4760,3941,0)
(3447,9141,0)
(444,3539,0)
(3802,2342,0)
(3604,4876,0)
(191,6575,0)
(8637,5138,0)
(5181,5629,0)
(1435,1099,0)
(9111,87,0)
(1931,1038,0)
(9003,2567,0)
(3671,7116,0)
(2207,6625,0)
(316,6671,0)
(1857,1286,0)
(8401,3742,0)
(8637,7199,0)
(1292,3786,0)
(558,7223,0)
(9071,1283,0)
(6201,8899,0)
(7181,8899,0)
(9019,115,0)
(252,4785,0)
(1274,3425,0)
(1584,6671,0)
(3819,8391,0)
(8035,8455,0)
(4168,6614,0)
(5639,5373,0)
(1281,8840,0)
(7189,7166,0)
(8355,387,0)
(8968,5766,0)
(2438,7432,0)
(5680,6053,0)
(5801,6919,0)
(4970,6530,0)
(4282,1637,0)
(1564,8572,0)
(3213,4149,0)
(536,5949,0)
(7755,5499,0)
(7690,5435,0)
(6322,1431,0)
(4131,4149,0)
(4477,7953,0)
(1732,5729,0)
(7436,1400,0)
(8432,1488,0)
(5869,1410,0)
(7231,3582,0)
(5064,5851,0)
(7810,115,0)
(8193,1777,0)
(8765,6522,0)
(5696,7892,0)
(4864,115,0)
(6196,4159,0)
(6038,115,0)
(2751,8822,0)
(7491,5346,0)
(2960,7595,0)
(2957,4715,0)
(6198,115,0)
(564,3844,0)
(3568,410,0)
(309,8391,0)
(437,8391,0)
(5068,6671,0)
(7037,5366,0)
(1173,6577,0)
(724,3621,0)
(2952,5977,0)
(6924,4672,0)
(5767,944,0)
(4602,4295,0)
(8248,6996,0)
(7966,3565,0)
(8432,5577,0)
(8646,4232,0)
(7334,3338,0)
(3699,8391,0)
(46,4190,0)
(4597,4995,0)
(7977,4383,0)
(6981,3871,0)
(7839,9008,0)
(2467,8391,0)
(4175,3614,0)
(4375,1270,0)
(2975,6820,0)
(5067,5446,0)
(8102,3333,0)
(633,8962,0)
(1859,5689,0)
(6820,8165,0)
(1450,9029,0)
(5302,1117,0)
(8740,2549,0)
(62,1040,0)
(8941,325,0)
(2753,1354,0)
(8393,1092,0)
(7294,4477,0)
(5570,5,0)
(4624,19,0)
(91,1351,0)
(8050,3797,0)
(4172,8391,0)
(9077,2161,0)
(1947,845,0)
(1947,8391,0)
(8409,8057,0)
(5861,1165,0)
(6642,6671,0)
(1283,3330,0)
(7314,4500,0)
(6912,2909,0)
(4438,7775,0)
(649,151,0)
(3691,7133,0)
(3379,7035,0)
(8617,7045,0)
(8981,6457,0)
(8992,3487,0)
(2218,5431,0)
(6293,7229,0)
(718,6671,0)
(2265,5398,0)
(6670,5496,0)
(8728,4178,0)
(1790,6776,0)
(7994,6030,0)
(7289,5057,0)
(4087,4595,0)
(6912,6189,0)
(3208,6834,0)
(171,6996,0)
(3384,7857,0)
(7840,2763,0)
(8198,371,0)
(5941,4937,0)
(1956,8297,0)
(1861,3897,0)
(7050,822,0)
(7384,3184,0)
(6381,5647,0)
(4641,5774,0)
(5519,258,0)
(6348,6336,0)
(4325,2818,0)
(1632,4309,0)
(1057,570,0)
(4682,4620,0)
(2608,6981,0)
(623,7199,0)
(7510,4682,0)
(3160,3878,0)
(1151,5851,0)
(9068,4767,0)
(8003,88,0)
(4660,7707,0)
(1168,7535,0)
(1529,780,0)
(4924,1922,0)
(3800,4401,0)
(8358,3530,0)
(4620,8286,0)
(3278,6148,0)
(1363,115,0)
(137,7953,0)
(3266,5548,0)
(7984,115,0)
(154,6548,0)
(6111,115,0)
(2995,7765,0)
(7621,6386,0)
(4567,2656,0)
(2052,7730,0)
(5006,4875,0)
(695,3277,0)
(1201,4024,0)
(3105,8844,0)
(6539,8391,0)
(6211,8186,0)
(5116,846,0)
(4206,5739,0)
(5417,8070,0)
(5856,2932,0)
(45,4441,0)
(6022,8391,0)
(2000,4785,0)
(993,7962,0)
(9090,8391,0)
(5239,8194,0)
(8892,43,0)
(2001,4205,0)
(2823,7160,0)
(5638,8441,0)
(5061,8783,0)
(2335,1283,0)
(11,4231,0)
(6870,7451,0)
(8384,2652,0)
(811,50,0)
(8985,1265,0)
(4650,3621,0)
(7776,3012,0)
(6763,2870,0)
(6422,3732,0)
(3804,3889,0)
(3913,6995,0)
(7781,1619,0)
(2610,3052,0)
(1474,8357,0)
(5811,4876,0)
(4375,6474,0)
(4555,546,0)
(3979,8774,0)
(8185,741,0)
(7912,7917,0)
(5421,4821,0)
(6138,2316,0)
(8806,8391,0)
(4129,8200,0)
(1065,7040,0)
(5132,7862,0)
(8933,6443,0)
(8173,1679,0)
(7211,7375,0)
(8666,1912,0)
(3771,348,0)
(6751,5817,0)
(2966,4720,0)
(6655,3512,0)
(7312,3867,0)
(225,4718,0)
(7632,8391,0)
(6647,8362,0)
(2186,3298,0)
(2791,3764,0)
(7626,3565,0)
(8452,1149,0)
(5247,719,0)
(2883,4785,0)
(2859,8047,0)
(8093,6209,0)
(1801,7107,0)
(3157,150,0)
(7742,7384,0)
(6935,8391,0)
(392,457,0)
(7005,115,0)
(7933,6926,0)
(5697,2099,0)
(7249,5687,0)
(7420,3902,0)
(8237,6625,0)
(5698,1848,0)
(348,2553,0)
(6994,5129,0)
(449,8658,0)
(158,3843,0)
(4723,3454,0)
(6267,5970,0)
(5398,1063,0)
(5991,2343,0)
(250,3097,0)
(8499,7525,0)
(6000,115,0)
(4644,3913,0)
(2241,5631,0)
(1726,7114,0)
(1202,7432,0)
(6936,968,0)
(3507,5156,0)
(3064,1843,0)
(4096,3046,0)
(7007,5790,0)
(614,6541,0)
(2179,3055,0)
(4934,6208,0)
(4774,3699,0)
(1809,3878,0)
(1125,4076,0)
(7408,2044,0)
(5187,691,0)
(5228,5946,0)
(3034,7863,0)
(8109,6868,0)
(1873,115,0)
(3456,115,0)
(4912,3312,0)
(3130,1199,0)
(7387,8915,0)
(334,5475,0)
(1906,3604,0)
(3811,8477,0)
(7656,3451,0)
(8748,2112,0)
(8571,6442,0)
(5300,6070,0)
(1321,8348,0)
(2651,6577,0)
(8184,6975,0)
(1854,8113,0)
(7394,8550,0)
(6743,6671,0)
(5133,579,0)
(8323,3272,0)
(6993,1410,0)
(1349,8391,0)
(5870,8031,0)
(2918,4,0)
(6875,1348,0)
(6532,6189,0)
(8752,2814,0)
(3533,774,0)
(7950,6259,0)
(5499,4084,0)
(3558,53,0)
(5510,7698,0)
(3378,8681,0)
(3011,2912,0)
(2544,7280,0)
(5696,2091,0)
(6577,4785,0)
(7384,1312,0)
(2115,4270,0)
(4291,1369,0)
(6219,2219,0)
(8476,5269,0)
(2544,9130,0)
(8569,6671,0)
(4932,5804,0)
(1473,4034,0)
(3438,5654,0)
(8552,1551,0)
(5500,2423,0)
(4505,8427,0)
(1346,7973,0)
(437,2845,0)
(3253,2518,0)
(6187,3830,0)
(34,2421,0)
(4480,2587,0)
(7747,4672,0)
(9103,2454,0)
(6252,6711,0)
(4963,2660,0)
(2287,6921,0)
(6682,5342,0)
(1336,3272,0)
(4964,7493,0)
(3463,4585,0)
(5350,349,0)
(8206,3449,0)
(6993,7888,0)
(3508,6986,0)
(7343,4725,0)
(6712,1121,0)
(2803,3242,0)
(8144,8276,0)
(2035,4307,0)
(33,4157,0)
(4669,5248,0)
(6666,8391,0)
(8362,6647,0)
(8840,8432,0)
(2339,743,0)
(1670,8391,0)
(4507,4957,0)
(538,6446,0)
(6430,115,0)
(6262,1645,0)
(424,8391,0)
(1250,1149,0)
(3782,1644,0)
(2534,8391,0)
(1232,373,0)
(931,739,0)
(3079,1410,0)
(3920,6597,0)
(5576,6554,0)
(6496,7930,0)
(3895,4474,0)
(2859,4224,0)
(1685,4016,0)
(6318,8391,0)
(2406,8359,0)
(5012,3236,0)
(325,8365,0)
(2314,8048,0)
(8275,8811,0)
(2250,8018,0)
(4263,6700,0)
(3766,7046,0)
(3510,3586,0)
(3980,7462,0)
(1039,4846,0)
(4705,3028,0)
(6900,6483,0)
(4628,4379,0)
(8338,3672,0)
(4583,8155,0)
(7327,2444,0)
(8938,8452,0)
(1864,6671,0)
(942,5144,0)
(4759,1064,0)
(6419,8471,0)
(6064,6575,0)
(1432,1149,0)
(6278,5961,0)
(6909,7433,0)
(3823,2007,0)
(5861,4876,0)
(5373,4899,0)
(280,143,0)
(869,7365,0)
(7545,1062,0)
(4800,3521,0)
(6210,6671,0)
(5407,5727,0)
(1626,3792,0)
(8634,7349,0)
(275,4773,0)
(1544,882,0)
(7777,178,0)
(1472,5196,0)
(7860,7354,0)
(4983,2401,0)
(3152,7660,0)
(7501,8277,0)
(2491,3119,0)
(4720,2123,0)
(5987,1980,0)
(4739,5011,0)
(4817,7807,0)
(3730,2660,0)
(779,5431,0)
(3690,2845,0)
(170,3122,0)
(320,1054,0)
(5494,3215,0)
(6273,3638,0)
(2951,8501,0)
(5222,7910,0)
(6806,2912,0)
(1625,5086,0)
(7331,7219,0)
(6668,7578,0)
(5556,5312,0)
(5387,3941,0)
(8126,2948,0)
(8572,3833,0)
(3052,3149,0)
(390,2221,0)
(4890,4785,0)
(1845,339,0)
(4375,6968,0)
(2597,7404,0)
(7396,5086,0)
(1783,3817,0)
(5023,5172,0)
(2399,4729,0)
(5777,4390,0)
(499,9133,0)
(4405,7389,0)
(1064,10,0)
(2996,6671,0)
(8296,3621,0)
(1345,4850,0)
(9073,115,0)
(5438,1288,0)
(4722,8047,0)
(7333,6842,0)
(7261,6022,0)
(5298,3986,0)
(4894,6565,0)
(5530,7410,0)
(9099,1280,0)
(795,8078,0)
(7235,8168,0)
(6239,3999,0)
(4757,5997,0)
(486,7271,0)
(3559,3175,0)
(6223,5567,0)
(8541,7927,0)
(8641,7410,0)
(1220,2473,0)
(3207,8391,0)
(5638,6649,0)
(6154,5573,0)
(5655,8391,0)
(726,444,0)
(6736,6348,0)
(4147,6671,0)
(1413,6056,0)
(7196,8391,0)
(5577,115,0)
(7316,272,0)
(1081,6288,0)
(7210,8018,0)
(3020,3859,0)
(4781,4876,0)
(3445,5836,0)
(5279,5037,0)
(6841,456,0)
(3134,7251,0)
(4733,2041,0)
(7772,644,0)
(2926,1149,0)
(3786,115,0)
(5527,2935,0)
(5510,8677,0)
(5105,3157,0)
(6129,6220,0)
(9073,9015,0)
(293,9106,0)
(6502,6374,0)
(3203,4038,0)
(7983,453,0)
(2454,9103,0)
(2854,3793,0)
(2087,5461,0)
(1452,115,0)
(5202,4785,0)
(3442,1852,0)
(4598,8047,0)
(4034,8391,0)
(8345,6125,0)
(7467,4119,0)
(2661,2698,0)
(3906,6101,0)
(1493,8144,0)
(535,7294,0)
(8355,4451,0)
(2220,7432,0)
(5732,6292,0)
(5136,4423,0)
(8505,1203,0)
(1969,1360,0)
(5388,1213,0)
(3785,115,0)
(5341,3732,0)
(6972,823,0)
(5565,4239,0)
(958,559,0)
(2047,5545,0)
(8148,6182,0)
(2729,4966,0)
(2117,6062,0)
(1005,824,0)
(1259,7337,0)
(4321,4792,0)
(7790,8612,0)
(4405,4057,0)
(7743,5829,0)
(2775,7548,0)
(6360,3451,0)
(2900,8419,0)
(4355,241,0)
(1548,3953,0)
(7905,2299,0)
(4821,115,0)
(5258,8398,0)
(3133,3271,0)
(3415,981,0)
(7287,8391,0)
(4343,4064,0)
(4631,3055,0)
(8966,2845,0)
(5757,3806,0)
(5078,8879,0)
(7733,5475,0)
(3278,3490,0)
(4224,2859,0)
(3450,3983,0)
(8888,2174,0)
(2324,2907,0)
(6514,6664,0)
(7881,6649,0)
(6922,4453,0)
(8311,3586,0)
(5420,6865,0)
(3924,2520,0)
(338,5530,0)
(4280,8391,0)
(7892,5696,0)
(1874,3660,0)
(165,2424,0)
(503,2896,0)
(1912,8666,0)
(6708,4147,0)
(6538,876,0)
(269,5297,0)
(4334,3924,0)
(1029,8391,0)
(6215,8391,0)
(8079,3318,0)
(903,7874,0)
(8319,1770,0)
(2504,8817,0)
(1398,7222,0)
(4707,3466,0)
(3637,2596,0)
(5927,3386,0)
(7848,785,0)
(562,8391,0)
(8658,7924,0)
(6744,3330,0)
(4311,5604,0)
(1617,6746,0)
(9095,1452,0)
(1415,929,0)
(4828,115,0)
(3237,6671,0)
(6462,1149,0)
(6397,8158,0)
(6451,115,0)
(2331,9047,0)
(7989,115,0)
(604,1121,0)
(3319,2592,0)
(7140,5248,0)
(3801,1938,0)
(8405,3342,0)
(2508,6671,0)
(4842,8189,0)
(1766,115,0)
(3858,8496,0)
(4230,4785,0)
(205,4326,0)
(5181,4565,0)
(6248,7367,0)
(9005,4011,0)
(6293,4950,0)
(6968,1852,0)
(8257,3666,0)
(8034,4876,0)
(5925,4212,0)
(1350,8242,0)
(6285,6692,0)
(3614,1385,0)
(1706,4785,0)
(6289,6771,0)
(1555,2845,0)
(8391,5025,0)
(6606,4344,0)
(1628,115,0)
(4470,7358,0)
(4567,6522,0)
(6993,2858,0)
(3336,1012,0)
(5962,5277,0)
(3222,1974,0)
(6582,8108,0)
(6361,2671,0)
(4628,8061,0)
(4954,8322,0)
(5902,135,0)
(7080,4965,0)
(7204,6038,0)
(1569,8219,0)
(6938,2424,0)
(5999,219,0)
(5110,8391,0)
(842,3868,0)
(2135,4204,0)
(2993,8291,0)
(3099,548,0)
(8790,8391,0)
(8843,228,0)
(7207,6402,0)
(6490,3759,0)
(8750,6932,0)
(8869,4426,0)
(6884,1526,0)
(2004,4560,0)
(1082,8024,0)
(25,8415,0)
(7294,535,0)
(8711,8570,0)
(4666,8302,0)
(5389,6104,0)
(2523,3201,0)
(3881,1809,0)
(5007,6508,0)
(5227,115,0)
(259,2506,0)
(3500,197,0)
(7501,1041,0)
(153,741,0)
(3804,2861,0)
(8956,6536,0)
(1371,1167,0)
(5470,1128,0)
(3130,7711,0)
(7515,4038,0)
(8286,4620,0)
(8445,8928,0)
(4117,7418,0)
(3433,777,0)
(7025,5523,0)
(7643,6778,0)
(6080,2845,0)
(8441,6634,0)
(7408,6084,0)
(8623,4831,0)
(6286,8730,0)
(2072,115,0)
(2782,3147,0)
(8296,9059,0)
(1462,2845,0)
(2544,700,0)
(4815,3902,0)
(5953,4352,0)
(1704,1524,0)
(194,1409,0)
(5609,1349,0)
(4873,8111,0)
(8817,4026,0)
(3774,2845,0)
(8730,4307,0)
(8835,6541,0)
(8124,565,0)
(8139,3480,0)
(3877,7711,0)
(1404,8247,0)
(4889,1199,0)
(5070,4773,0)
(1870,8874,0)
(5255,6805,0)
(6454,7711,0)
(5353,2388,0)
(1805,562,0)
(2972,4965,0)
(4106,6611,0)
(4024,4732,0)
(8838,5485,0)
(3626,2808,0)
(8913,8391,0)
(8018,2250,0)
(3687,7947,0)
(8520,7779,0)
(837,3970,0)
(424,3621,0)
(7819,5025,0)
(4375,1158,0)
(7433,8819,0)
(8516,8609,0)
(2647,115,0)
(2069,4876,0)
(5689,7346,0)
(5025,7819,0)
(4902,1213,0)
(1534,1502,0)
(9037,1725,0)
(6007,7233,0)
(7934,4448,0)
(8686,859,0)
(7870,9001,0)
(7243,7418,0)
(477,115,0)
(699,3300,0)
(6711,4785,0)
(353,115,0)
(4829,6159,0)
(2284,6808,0)
(4020,5298,0)
(4944,791,0)
(2867,1488,0)
(9056,6576,0)
(8851,610,0)
(4309,1632,0)
(6574,3552,0)
(1944,8863,0)
(5966,2938,0)
(1883,7405,0)
(801,8318,0)
(7117,2206,0)
(5501,2844,0)
(1865,8048,0)
(287,3377,0)
(7546,4732,0)
(9104,8110,0)
(6895,5428,0)
(5904,5507,0)
(3485,5744,0)
(7596,6182,0)
(9001,1286,0)
(3696,7211,0)
(6069,6575,0)
(3240,6146,0)
(2988,214,0)
(6836,1385,0)
(4820,6414,0)
(2254,515,0)
(4375,7625,0)
(8153,6671,0)
(5314,211,0)
(3511,1808,0)
(5548,3451,0)
(7444,994,0)
(2037,2242,0)
(5312,5556,0)
(4497,115,0)
(7127,7218,0)
(3531,7218,0)
(7974,1149,0)
(1095,3752,0)
(1798,4198,0)
(2525,7063,0)
(5660,8273,0)
(3804,9138,0)
(1260,2879,0)
(1974,3222,0)
(1725,5040,0)
(4217,2183,0)
(8362,2198,0)
(6419,3215,0)
(4094,1632,0)
(4415,3362,0)
(3621,4587,0)
(3657,306,0)
(3197,3278,0)
(2099,9059,0)
(1063,1427,0)
(7962,8233,0)
(8218,7541,0)
(4329,306,0)
(1494,7046,0)
(14,7840,0)
(862,3621,0)
(5898,7186,0)
(448,4809,0)
(4375,7140,0)
(5880,2578,0)
(3878,1809,0)
(6960,3222,0)
(3251,8515,0)
(109,1121,0)
(7000,3004,0)
(1179,2279,0)
(5900,1501,0)
(8829,4356,0)
(597,6190,0)
(3144,1273,0)
(1821,4371,0)
(5227,8391,0)
(2654,5076,0)
(3278,3979,0)
(3554,6555,0)
(634,7452,0)
(3297,6351,0)
(6199,9043,0)
(6894,3254,0)
(7685,8156,0)
(8713,115,0)
(4133,476,0)
(3288,115,0)
(4684,6646,0)
(3501,8209,0)
(2377,2057,0)
(4768,2023,0)
(5048,3055,0)
(4284,6995,0)
(369,2681,0)
(4310,829,0)
(8181,2673,0)
(8958,8117,0)
(7296,8935,0)
(7410,8641,0)
(6157,1907,0)
(1186,4098,0)
(3793,5145,0)
(6772,5324,0)
(7030,2487,0)
(5600,3512,0)
(7882,1808,0)
(8834,4433,0)
(7195,5688,0)
(4922,8585,0)
(5163,365,0)
(3704,95,0)
(6284,2112,0)
(4538,8623,0)
(2027,7242,0)
(655,8391,0)
(7600,5197,0)
(4620,8986,0)
(3906,771,0)
(4728,1944,0)
(7768,4136,0)
(2317,115,0)
(5713,2212,0)
(2005,7033,0)
(8007,1956,0)
(3090,7964,0)
(7113,8391,0)
(6222,6671,0)
(64,7670,0)
(6130,5825,0)
(8719,115,0)
(1181,930,0)
(5214,3215,0)
(9084,425,0)
(2203,5629,0)
(6699,3157,0)
(4398,7711,0)
(1974,5178,0)
(1352,1041,0)
(800,769,0)
(2375,4219,0)
(4072,8391,0)
(7743,2043,0)
(7660,8391,0)
(3999,1458,0)
(5683,6478,0)
(4910,8667,0)
(4514,8616,0)
(205,5608,0)
(6409,7863,0)
(7472,7923,0)
(2099,3451,0)
(8379,4876,0)
(6565,2199,0)
(961,903,0)
(8779,2221,0)
(3891,3924,0)
(5976,8837,0)
(3230,6744,0)
(7165,6627,0)
(3522,6995,0)
(3213,1280,0)
(8953,2257,0)
(1807,6125,0)
(7693,4965,0)
(6464,6896,0)
(3621,8111,0)
(8407,9068,0)
(3323,637,0)
(607,2285,0)
(6412,8793,0)
(4664,1915,0)
(7647,3375,0)
(4956,680,0)
(102,559,0)
(1061,8391,0)
(4145,4954,0)
(5387,484,0)
(4864,54,0)
(7075,7050,0)
(2533,939,0)
(3494,7777,0)
(1172,6671,0)
(8756,3145,0)
(6455,4401,0)
(4285,4571,0)
(4075,8352,0)
(918,4020,0)
(6847,3440,0)
(2287,2497,0)
(1985,7341,0)
(7403,4668,0)
(2047,7486,0)
(5638,4587,0)
(5784,4822,0)
(7793,2347,0)
(8638,2299,0)
(3804,700,0)
(8163,1675,0)
(1946,4959,0)
(251,2825,0)
(8455,8035,0)
(8844,4066,0)
(4418,3876,0)
(8528,661,0)
(5149,8595,0)
(2037,6154,0)
(6891,9003,0)
(2543,3215,0)
(4982,4420,0)
(1348,5683,0)
(1289,6847,0)
(7485,7458,0)
(1882,6443,0)
(6240,8510,0)
(2408,7903,0)
(742,3381,0)
(5281,5510,0)
(857,8732,0)
(1392,6424,0)
(2989,403,0)
(8309,2688,0)
(802,4912,0)
(3022,6592,0)
(1518,680,0)
(7332,2366,0)
(910,1462,0)
(5124,5315,0)
(7452,1985,0)
(6023,8391,0)
(1415,4449,0)
(4945,1765,0)
(4641,3814,0)
(8825,4346,0)
(3621,8021,0)
(7058,8935,0)
(1121,8995,0)
(3347,8391,0)
(5063,8677,0)
(4287,7280,0)
(6616,8055,0)
(5289,2549,0)
(6995,386,0)
(5653,2141,0)
(6980,3548,0)
(5036,5640,0)
(3790,7129,0)
(1799,7083,0)
(5759,2162,0)
(8478,1175,0)
(7993,3661,0)
(7386,111,0)
(1290,5124,0)
(2502,2256,0)
(9072,3145,0)
(584,4068,0)
(2381,1206,0)
(6679,5172,0)
(1340,4610,0)
(2312,4470,0)
(8102,4252,0)
(531,2879,0)
(8209,2141,0)
(3553,5324,0)
(7102,6272,0)
(7859,5290,0)
(7264,4475,0)
(5598,349,0)
(7561,8391,0)
(6750,2707,0)
(3905,3742,0)
(2265,2043,0)
(2002,8493,0)
(3140,8158,0)
(5871,1356,0)
(579,8698,0)
(7193,2679,0)
(7408,9059,0)
(6391,3714,0)
(5588,4626,0)
(3818,5326,0)
(1117,6830,0)
(3291,19,0)
(4596,5730,0)
(4086,5126,0)
(4191,2198,0)
(7153,2056,0)
(3677,405,0)
(3121,9073,0)
(1415,1412,0)
(299,5156,0)
(6757,8864,0)
(6357,8391,0)
(671,8550,0)
(8561,8391,0)
(2445,7119,0)
(3774,8391,0)
(3534,6109,0)
(7828,1479,0)
(1086,1149,0)
(1999,1555,0)
(2921,6048,0)
(2801,2453,0)
(6947,1800,0)
(8828,5684,0)
(8454,2788,0)
(5115,5056,0)
(8616,2845,0)
(2424,115,0)
(5167,3192,0)
(3880,8038,0)
(1360,1969,0)
(6659,2007,0)
(7276,6412,0)
(342,639,0)
(2125,1712,0)
(8009,2845,0)
(7764,8391,0)
(3902,1525,0)
(2005,1409,0)
(8162,2224,0)
(7152,1488,0)
(4125,8852,0)
(8088,8391,0)
(7798,5156,0)
(3773,6137,0)
(6809,8497,0)
(4569,8909,0)
(6354,6182,0)
(3252,7602,0)
(69,7871,0)
(6727,8496,0)
(8247,6525,0)
(2932,3358,0)
(8697,4876,0)
(8896,3876,0)
(5290,4876,0)
(7888,2342,0)
(4011,9005,0)
(3456,8391,0)
(4570,8659,0)
(6209,1149,0)
(3538,1245,0)
(5340,6023,0)
(6899,5932,0)
(4945,7233,0)
(5098,1467,0)
(6237,2840,0)
(4176,115,0)
(187,3825,0)
(354,6430,0)
(9043,4076,0)
(7861,171,0)
(6377,7089,0)
(2289,8790,0)
(7205,4856,0)
(4960,4111,0)
(2356,2325,0)
(4534,12,0)
(8341,5829,0)
(2983,8702,0)
(8808,2623,0)
(8610,7413,0)
(8340,9028,0)
(6719,6402,0)
(8501,8391,0)
(6993,2303,0)
(2961,3271,0)
(3139,3781,0)
(692,6190,0)
(3769,9119,0)
(7005,1645,0)
(1167,5598,0)
(7449,8985,0)
(452,1260,0)
(7047,8802,0)
(109,5441,0)
(8692,1894,0)
(6502,2543,0)
(3486,7016,0)
(5432,2433,0)
(4117,4531,0)
(7602,4574,0)
(2952,8126,0)
(7797,7104,0)
(4556,358,0)
(3229,828,0)
(3425,107,0)
(1761,3513,0)
(8698,3792,0)
(9112,218,0)
(3939,3303,0)
(1415,3986,0)
(6607,1246,0)
(8289,7762,0)
(3129,3902,0)
(6728,4444,0)
(3605,1530,0)
(5993,3294,0)
(5090,5494,0)
(6284,8000,0)
(8061,4007,0)
(1299,565,0)
(5553,2187,0)
(7250,3507,0)
(3412,6671,0)
(5638,4350,0)
(3804,1994,0)
(8475,4843,0)
(7965,8947,0)
(4856,7205,0)
(7759,3621,0)
(3565,5099,0)
(6816,1149,0)
(7752,7692,0)
(226,7223,0)
(7416,4785,0)
(5379,3443,0)
(6348,6707,0)
(4571,5971,0)
(272,6150,0)
(5733,4785,0)
(459,1085,0)
(2931,4587,0)
(5304,3542,0)
(2193,3439,0)
(4447,339,0)
(7080,7832,0)
(5494,6474,0)
(1544,4366,0)
(9125,1180,0)
(1447,4222,0)
(2072,8391,0)
(6449,115,0)
(8671,8592,0)
(7299,1427,0)
(4371,4424,0)
(1259,6434,0)
(1008,529,0)
(6500,4625,0)
(3217,4522,0)
(8816,1260,0)
(7425,1446,0)
(7307,862,0)
(5799,7643,0)
(4581,7790,0)
(2362,5566,0)
(8328,8391,0)
(6238,7560,0)
(7183,5302,0)
(1044,457,0)
(4356,4792,0)
(3285,5156,0)
(5297,7210,0)
(3285,4876,0)
(5287,5648,0)
(2981,6649,0)
(3228,6926,0)
(3893,6678,0)
(8687,10,0)
(6519,4785,0)
(2364,5640,0)
(6686,1664,0)
(5099,3565,0)
(7493,1411,0)
(124,1477,0)
(3689,7318,0)
(573,7707,0)
(5024,4449,0)
(142,3862,0)
(3770,5256,0)
(482,1144,0)
(548,8830,0)
(8720,5101,0)
(660,5829,0)
(5033,5811,0)
(9100,2522,0)
(2810,447,0)
(8137,1438,0)
(7145,3571,0)
(6383,4666,0)
(159,2938,0)
(965,807,0)
(7820,9103,0)
(2690,7707,0)
(8766,7168,0)
(4950,6293,0)
(7821,6289,0)
(4008,8391,0)
(8438,3845,0)
(9054,1462,0)
(2544,1405,0)
(2945,3612,0)
(1128,5470,0)
(2287,3215,0)
(4174,6062,0)
(8604,5522,0)
(1996,233,0)
(1296,5441,0)
(2940,8391,0)
(1701,3003,0)
(7923,115,0)
(3509,9130,0)
(6621,8340,0)
(6778,7643,0)
(8278,2002,0)
(1559,3496,0)
(1098,1122,0)
(4365,6598,0)
(8689,4968,0)
(9043,2746,0)
(7739,8952,0)
(6502,267,0)
(401,25,0)
(181,5679,0)
(7648,746,0)
(2410,8391,0)
(498,2003,0)
(2610,4879,0)
(1121,5362,0)
(6351,3297,0)
(5922,2537,0)
(6013,3782,0)
(6025,6671,0)
(7057,115,0)
(680,4956,0)
(4486,2645,0)
(1387,115,0)
(2048,6121,0)
(5128,8063,0)
(3620,115,0)
(8946,5052,0)
(8595,2408,0)
(730,5227,0)
(9087,4283,0)
(9010,2845,0)
(593,3868,0)
(4225,1895,0)
(3277,8552,0)
(2666,5156,0)
(4233,989,0)
(6089,6556,0)
(3754,438,0)
(1871,241,0)
(514,8391,0)
(599,7499,0)
(4421,489,0)
(1199,4889,0)
(2235,8018,0)
(8061,1657,0)
(5317,7910,0)
(6823,8910,0)
(4610,4344,0)
(7258,2666,0)
(6513,115,0)
(6834,5861,0)
(5523,7025,0)
(463,8391,0)
(5921,6689,0)
(8045,3461,0)
(6459,4724,0)
(1130,977,0)
(4309,4876,0)
(5809,6649,0)
(6197,7389,0)
(8445,7771,0)
(314,8123,0)
(8207,309,0)
(8645,6717,0)
(7224,8391,0)
(6603,4188,0)
(8394,836,0)
(1725,5670,0)
(8597,5414,0)
(4490,3055,0)
(6168,1765,0)
(3340,1680,0)
(7222,8391,0)
(4258,2959,0)
(4685,1732,0)
(6828,9049,0)
(2130,7572,0)
(1651,5962,0)
(3902,3742,0)
(2213,3877,0)
(718,2243,0)
(8660,8726,0)
(3001,115,0)
(4301,497,0)
(3772,716,0)
(7395,6671,0)
(2408,1502,0)
(6523,115,0)
(6664,1900,0)
(4375,5452,0)
(1307,7196,0)
(8588,7643,0)
(8110,2130,0)
(3992,6098,0)
(8566,3800,0)
(4053,2731,0)
(2083,6671,0)
(7110,6402,0)
(8713,8391,0)
(7128,6671,0)
(8295,115,0)
(3653,121,0)
(891,8444,0)
(6364,4495,0)
(2459,4977,0)
(4022,718,0)
(2544,3215,0)
(2808,1641,0)
(6072,115,0)
(2682,6671,0)
(4068,3024,0)
(7867,1231,0)
(7988,7026,0)
(18,2825,0)
(2194,5212,0)
(4266,6299,0)
(6196,8740,0)
(6133,1779,0)
(8721,6536,0)
(5338,895,0)
(5543,1396,0)
(3417,7160,0)
(3878,4614,0)
(8799,3684,0)
(1104,7664,0)
(6003,6731,0)
(7078,6849,0)
(1068,8285,0)
(5226,4472,0)
(6620,8391,0)
(3865,3983,0)
(3502,6671,0)
(1510,3260,0)
(5144,942,0)
(8338,2962,0)
(2126,2263,0)
(50,811,0)
(6594,115,0)
(7431,8030,0)
(3509,3889,0)
(8070,1488,0)
(2787,5849,0)
(4085,5235,0)
(7091,5153,0)
(3328,7862,0)
(4375,700,0)
(3722,8948,0)
(324,6310,0)
(2287,1280,0)
(6634,3663,0)
(6826,8246,0)
(7827,412,0)
(7433,6889,0)
(3861,299,0)
(8113,4995,0)
(6544,5958,0)
(1114,4500,0)
(6227,2085,0)
(943,573,0)
(5593,1158,0)
(5166,3054,0)
(7681,2432,0)
(7808,189,0)
(5521,3114,0)
(8830,115,0)
(7348,6545,0)
(5106,700,0)
(6741,2043,0)
(8853,7127,0)
(171,2414,0)
(8305,988,0)
(4245,7416,0)
(3491,6529,0)
(7445,3051,0)
(1168,8391,0)
(5664,2830,0)
(5367,151,0)
(5453,8966,0)
(3604,5156,0)
(326,2457,0)
(3435,8105,0)
(3543,8646,0)
(4327,4081,0)
(7299,4028,0)
(3329,5069,0)
(520,1612,0)
(4172,5239,0)
(7900,1405,0)
(914,6580,0)
(8830,548,0)
(2858,4547,0)
(776,1675,0)
(3600,3679,0)
(4394,3636,0)
(8827,241,0)
(7252,1158,0)
(6855,51,0)
(8759,3223,0)
(2918,2253,0)
(4476,7283,0)
(3242,95,0)
(6782,3397,0)
(6158,115,0)
(3192,4285,0)
(366,4698,0)
(7031,2845,0)
(1270,1087,0)
(2534,2845,0)
(3887,8710,0)
(8864,8483,0)
(1324,8628,0)
(3773,8391,0)
(438,4444,0)
(7104,7797,0)
(2004,1304,0)
(4044,1583,0)
(7956,1247,0)
(8560,4378,0)
(5411,7145,0)
(5508,8756,0)
(6354,3103,0)
(1220,1013,0)
(7871,1039,0)
(3869,7691,0)
(116,8947,0)
(3565,5382,0)
(4012,2845,0)
(8742,211,0)
(6288,115,0)
(3032,8838,0)
(8999,6671,0)
(8733,5239,0)
(7532,3621,0)
(8055,6616,0)
(6336,1389,0)
(8629,3886,0)
(2874,1368,0)
(4276,3549,0)
(3804,6649,0)
(1941,1670,0)
(3213,1405,0)
(6928,115,0)
(8038,2112,0)
(4184,5192,0)
(2232,6671,0)
(3940,8391,0)
(5494,6649,0)
(1634,8561,0)
(2954,8091,0)
(3149,8391,0)
(1026,2979,0)
(932,7890,0)
(5564,1994,0)
(8344,6671,0)
(9027,2665,0)
(6898,1567,0)
(5901,2487,0)
(386,6671,0)
(4655,7005,0)
(5330,1435,0)
(6478,1597,0)
(6072,8391,0)
(2784,6671,0)
(6054,115,0)
(1079,8391,0)
(5963,5698,0)
(1662,8495,0)
(7811,670,0)
(8782,519,0)
(5197,4781,0)
(2448,1284,0)
(7570,5645,0)
(7873,626,0)
(138,4576,0)
(9012,1306,0)
(177,7004,0)
(6686,115,0)
(6100,5598,0)
(7421,7833,0)
(728,4672,0)
(4932,6234,0)
(2087,6007,0)
(2343,5991,0)
(6085,1354,0)
(1942,2976,0)
(8092,219,0)
(6723,115,0)
(4519,6438,0)
(4238,1850,0)
(6665,2151,0)
(5638,4449,0)
(5463,6254,0)
(1467,5098,0)
(2897,253,0)
(8447,3907,0)
(8427,8664,0)
(4278,8259,0)
(100,115,0)
(8461,9077,0)
(1182,4784,0)
(8067,5346,0)
(7085,115,0)
(2287,4350,0)
(6408,6464,0)
(2712,7656,0)
(6537,6364,0)
(5703,4694,0)
(3410,6671,0)
(4762,5345,0)
(1565,1685,0)
(7146,5545,0)
(5822,7287,0)
(8298,3067,0)
(8014,7777,0)
(5008,2386,0)
(6442,8571,0)
(8338,4785,0)
(724,3451,0)
(5431,779,0)
(6874,7611,0)
(1319,4547,0)
(7775,8391,0)
(5085,4444,0)
(2152,2891,0)
(5204,1245,0)
(942,8641,0)
(2287,7280,0)
(7296,7475,0)
(5663,3579,0)
(6702,6671,0)
(5880,7656,0)
(6847,1289,0)
(4002,8391,0)
(1713,1900,0)
(5638,1280,0)
(1756,7611,0)
(6559,1149,0)
(4997,1873,0)
(8274,567,0)
(1676,8458,0)
(7310,6695,0)
(6826,540,0)
(1881,6671,0)
(6855,5428,0)
(6767,119,0)
(3843,1454,0)
(7304,1850,0)
(4895,2534,0)
(2165,5779,0)
(7033,2005,0)
(6498,2094,0)
(3165,4746,0)
(3549,2924,0)
(2726,2458,0)
(719,8391,0)
(2090,4056,0)
(5291,5477,0)
(8266,4785,0)
(5113,2157,0)
(1892,3820,0)
(948,3785,0)
(1923,143,0)
(391,3451,0)
(5057,626,0)
(466,6008,0)
(5480,5139,0)
(4711,115,0)
(2831,1311,0)
(6744,3230,0)
(7052,3747,0)
(6414,2718,0)
(5726,7168,0)
(8136,115,0)
(1502,2408,0)
(2320,3052,0)
(2734,7693,0)
(6604,6715,0)
(1572,6495,0)
(5310,4095,0)
(2228,2481,0)
(8362,8360,0)
(1329,5189,0)
(7278,3703,0)
(4864,8391,0)
(7422,8749,0)
(6584,5489,0)
(901,4008,0)
(6152,6141,0)
(2173,4128,0)
(770,8674,0)
(5256,1831,0)
(7836,7864,0)
(813,2118,0)
(1574,8198,0)
(2072,5768,0)
(6167,8433,0)
(2646,1840,0)
(7371,8225,0)
(474,7980,0)
(3673,5244,0)
(2558,5335,0)
(4877,3285,0)
(2466,2049,0)
(8279,115,0)
(3044,8164,0)
(8595,8391,0)
(3058,6866,0)
(4805,1169,0)
(1743,6671,0)
(4616,6723,0)
(526,429,0)
(9007,3637,0)
(172,4161,0)
(7857,3384,0)
(8582,115,0)
(161,4079,0)
(5716,6737,0)
(167,1312,0)
(2608,3214,0)
(119,7497,0)
(2355,675,0)
(3518,4503,0)
(1594,6664,0)
(7923,8391,0)
(2771,3274,0)
(8400,8697,0)
(661,4043,0)
(1526,6884,0)
(708,7835,0)
(6753,7411,0)
(7279,3806,0)
(465,8683,0)
(2826,7511,0)
(3136,933,0)
(8167,4494,0)
(1669,5949,0)
(5472,8142,0)
(4167,2953,0)
(7830,6932,0)
(9055,902,0)
(4424,5156,0)
(6884,115,0)
(6088,4148,0)
(154,3586,0)
(7688,3792,0)
(7578,8020,0)
(8022,6369,0)
(930,1181,0)
(1890,2504,0)
(7019,1076,0)
(1167,8391,0)
(2702,2981,0)
(3690,115,0)
(8890,7003,0)
(5037,6742,0)
(1308,1099,0)
(2028,1135,0)
(822,4397,0)
(7060,5812,0)
(3509,5174,0)
(4002,2256,0)
(5091,8189,0)
(3529,21,0)
(5638,700,0)
(1628,8391,0)
(1237,3007,0)
(7142,2818,0)
(7703,4210,0)
(834,356,0)
(4786,6888,0)
(3546,3043,0)
(1415,7544,0)
(3576,3571,0)
(5359,2914,0)
(8419,8391,0)
(5554,9063,0)
(7001,6815,0)
(1769,8391,0)
(5219,2591,0)
(3054,655,0)
(4628,5382,0)
(6246,2845,0)
(2629,5353,0)
(6622,2751,0)
(8551,6671,0)
(2823,8391,0)
(5512,2123,0)
(743,2339,0)
(4104,347,0)
(1121,8864,0)
(5548,3621,0)
(1395,2607,0)
(4060,248,0)
(2665,676,0)
(3956,8176,0)
(7027,5252,0)
(8735,3847,0)
(8419,2845,0)
(4459,7984,0)
(7657,4221,0)
(2904,115,0)
(8328,4521,0)
(8319,2140,0)
(319,7812,0)
(6502,4375,0)
(3078,5968,0)
(3269,6922,0)
(8360,8362,0)
(9076,280,0)
(7800,3630,0)
(5593,6649,0)
(3064,5801,0)
(8694,4658,0)
(7982,115,0)
(3477,2191,0)
(3718,1293,0)
(3727,115,0)
(8200,8391,0)
(4105,2812,0)
(83,2696,0)
(6945,5532,0)
(482,115,0)
(8783,3873,0)
(8126,8254,0)
(7077,897,0)
(3983,4453,0)
(9041,5484,0)
(6305,6378,0)
(9000,2198,0)
(7064,3602,0)
(3095,5445,0)
(8443,2418,0)
(673,1984,0)
(9051,3730,0)
(5269,530,0)
(4051,2363,0)
(3132,6504,0)
(3870,1246,0)
(5266,6656,0)
(2526,8288,0)
(3804,6921,0)
(7313,1282,0)
(2843,2622,0)
(7349,115,0)
(7990,6575,0)
(1023,8165,0)
(1009,4705,0)
(8403,2498,0)
(5635,4417,0)
(2827,1278,0)
(8510,6855,0)
(5949,1354,0)
(1992,3552,0)
(1415,1158,0)
(3119,8391,0)
(1415,1405,0)
(2222,2608,0)
(2022,3699,0)
(2891,3403,0)
(8209,4876,0)
(4375,1280,0)
(7959,8391,0)
(2132,1732,0)
(684,7781,0)
(4463,6657,0)
(1415,8594,0)
(2288,2895,0)
(7090,306,0)
(5154,7918,0)
(2474,429,0)
(5378,6023,0)
(712,8167,0)
(1991,4774,0)
(8040,9063,0)
(5144,8391,0)
(3793,2854,0)
(422,8573,0)
(3777,2191,0)
(2463,897,0)
(6761,6671,0)
(823,6972,0)
(8366,8391,0)
(264,496,0)
(6795,2845,0)
(2091,8833,0)
(2979,1611,0)
(3423,4191,0)
(5098,3430,0)
(8272,1022,0)
(4188,3072,0)
(4327,5828,0)
(4628,3936,0)
(1857,5156,0)
(3588,2317,0)
(3100,7210,0)
(378,4541,0)
(1353,1987,0)
(1878,8391,0)
(151,5196,0)
(8274,88,0)
(5321,1633,0)
(4375,8441,0)
(6570,333,0)
(6458,5665,0)
(4274,43,0)
(7017,871,0)
(3007,6778,0)
(8155,6829,0)
(1836,8398,0)
(7810,2682,0)
(4150,4921,0)
(6663,115,0)
(3242,2803,0)
(4741,2161,0)
(4105,3941,0)
(2185,3596,0)
(4648,1039,0)
(2657,115,0)
(4992,8695,0)
(6948,7216,0)
(545,2909,0)
(3070,7909,0)
(8055,8391,0)
(1769,115,0)
(2544,1270,0)
(6076,5258,0)
(8909,2919,0)
(9074,5588,0)
(6363,3993,0)
(8198,2501,0)
(8206,6632,0)
(2921,8593,0)
(185,4785,0)
(3520,6539,0)
(6999,1062,0)
(4765,5575,0)
(2544,3889,0)
(5744,5924,0)
(6693,83,0)
(9075,2657,0)
(534,7431,0)
(3539,444,0)
(5166,5315,0)
(405,777,0)
(1253,1168,0)
(8052,812,0)
(3213,7039,0)
(5094,3580,0)
(491,4785,0)
(39,6014,0)
(8796,7579,0)
(4402,4872,0)
(8341,2043,0)
(6649,2266,0)
(7552,5712,0)
(6176,4442,0)
(7144,2601,0)
(1119,6570,0)
(6307,2518,0)
(4498,4228,0)
(8335,5327,0)
(6310,2410,0)
(995,1501,0)
(5265,3657,0)
(2033,8920,0)
(6983,5982,0)
(6278,1410,0)
(4543,1891,0)
(7980,3451,0)
(4628,105,0)
(1661,4147,0)
(1969,8391,0)
(7479,5433,0)
(4603,4277,0)
(7036,6505,0)
(2671,3932,0)
(7090,3663,0)
(8099,3103,0)
(7239,4614,0)
(8295,7667,0)
(3758,689,0)
(7306,8391,0)
(7624,1266,0)
(6529,3491,0)
(8038,9130,0)
(6726,3415,0)
(7298,5237,0)
(3030,4236,0)
(9130,5633,0)
(6017,3028,0)
(967,3833,0)
(3215,5829,0)
(1329,3098,0)
(5144,115,0)
(9019,8532,0)
(197,8391,0)
(7920,4853,0)
(2096,3436,0)
(6263,6713,0)
(5684,4230,0)
(4308,2344,0)
(5753,2237,0)
(1173,7722,0)
(7896,4436,0)
(2359,4650,0)
(7398,8391,0)
(9141,6671,0)
(4417,2845,0)
(1318,8258,0)
(2101,4284,0)
(8616,8391,0)
(5629,2203,0)
(6645,8786,0)
(4539,258,0)
(3589,5922,0)
(2168,1149,0)
(4282,4182,0)
(8114,5588,0)
(2909,115,0)
(1013,3512,0)
(1092,2566,0)
(2151,115,0)
(8767,3312,0)
(1730,8699,0)
(8702,5243,0)
(5012,3828,0)
(4966,4689,0)
(3439,6703,0)
(6001,2440,0)
(3680,5894,0)
(2147,115,0)
(2556,2965,0)
(6284,6649,0)
(3108,5414,0)
(3297,1350,0)
(4154,5052,0)
(4628,3106,0)
(4048,4650,0)
(3539,8391,0)
(5809,1158,0)
(2396,4818,0)
(867,4320,0)
(2821,1340,0)
(1885,3800,0)
(2518,8626,0)
(1668,3207,0)
(6807,8303,0)
(3596,2043,0)
(2130,8110,0)
(4844,2674,0)
(4445,6509,0)
(3804,2112,0)
(8359,2406,0)
(4965,7080,0)
(6881,474,0)
(3667,718,0)
(2087,8778,0)
(690,7516,0)
(3509,7039,0)
(6856,2764,0)
(6956,6494,0)
(3491,3647,0)
(1681,3353,0)
(2860,9044,0)
(5733,2226,0)
(2212,3859,0)
(7852,6722,0)
(5872,4672,0)
(3509,8458,0)
(4792,2625,0)
(448,8580,0)
(7033,2446,0)
(2416,5776,0)
(1225,4830,0)
(1208,6986,0)
(5168,8517,0)
(2478,6031,0)
(1431,4570,0)
(4458,7982,0)
(2128,1172,0)
(8870,5359,0)
(6758,3295,0)
(5798,6736,0)
(3503,812,0)
(856,7103,0)
(7716,115,0)
(6193,8618,0)
(1685,6762,0)
(7871,7711,0)
(5056,115,0)
(2997,1104,0)
(8866,1712,0)
(803,6663,0)
(1636,3326,0)
(6115,8365,0)
(3167,4189,0)
(3942,7793,0)
(419,4436,0)
(8539,3318,0)
(987,2934,0)
(3820,3456,0)
(1145,5151,0)
(717,2059,0)
(6769,3012,0)
(5414,3108,0)
(3335,7711,0)
(1217,4333,0)
(3395,4307,0)
(101,8391,0)
(1521,8029,0)
(8042,3512,0)
(111,1764,0)
(3419,7652,0)
(8353,5011,0)
(7963,2698,0)
(2092,4824,0)
(2027,9049,0)
(4077,2419,0)
(7930,0,0)
(6706,386,0)
(7662,4801,0)
(5866,8182,0)
(517,3046,0)
(4426,4618,0)
(5956,4785,0)
(6568,4158,0)
(3454,8996,0)
(3369,6671,0)
(7691,1114,0)
(8776,115,0)
(1305,3791,0)
(2951,3059,0)
(1103,115,0)
(6142,3023,0)
(7526,7820,0)
(8754,2740,0)
(554,4510,0)
(4770,3825,0)
(6923,7129,0)
(3009,5900,0)
(618,2706,0)
(2039,1216,0)
(7411,115,0)
(7878,6671,0)
(2544,8111,0)
(1086,6241,0)
(220,1514,0)
(8283,9114,0)
(7644,4687,0)
(7536,1986,0)
(7684,1361,0)
(2295,4619,0)
(6126,5876,0)
(7548,5126,0)
(1266,8074,0)
(102,4283,0)
(9090,7921,0)
(1405,3621,0)
(7456,4560,0)
(4029,8391,0)
(5209,9086,0)
(3775,1357,0)
(2373,1952,0)
(8674,6150,0)
(3050,2043,0)
(1499,3941,0)
(49,1474,0)
(1221,8969,0)
(1410,8863,0)
(2607,5656,0)
(7050,7075,0)
(8722,9117,0)
(3595,1488,0)
(2940,115,0)
(3693,3072,0)
(339,8178,0)
(1980,6509,0)
(5235,4085,0)
(5080,6469,0)
(7892,1370,0)
(9026,3386,0)
(4344,8391,0)
(8189,4842,0)
(8352,1400,0)
(5132,8219,0)
(5450,2094,0)
(2933,1912,0)
(1046,2679,0)
(5665,1042,0)
(5117,115,0)
(3936,252,0)
(7149,4558,0)
(2720,115,0)
(2799,6555,0)
(546,4555,0)
(2269,1982,0)
(788,8500,0)
(7953,3014,0)
(1666,3058,0)
(8289,1149,0)
(945,3457,0)
(8103,746,0)
(6234,8391,0)
(8086,425,0)
(3911,5855,0)
(6364,6537,0)
(3810,7468,0)
(2683,8391,0)
(6214,6688,0)
(6111,8391,0)
(4270,2115,0)
(8179,775,0)
(2704,5856,0)
(1204,4473,0)
(282,8403,0)
(3876,4383,0)
(4847,115,0)
(4038,7515,0)
(7452,2422,0)
(340,7486,0)
(6206,8726,0)
(4270,4876,0)
(5809,2112,0)
(7405,4586,0)
(1123,6539,0)
(6664,1149,0)
(8917,3780,0)
(5559,2961,0)
(2763,7840,0)
(7187,8225,0)
(339,2845,0)
(2773,6671,0)
(7256,866,0)
(924,4668,0)
(1405,8391,0)
(539,8391,0)
(5413,8043,0)
(5096,72,0)
(5722,5796,0)
(2676,6671,0)
(7809,800,0)
(8322,3451,0)
(4612,6357,0)
(9043,6199,0)
(7856,7714,0)
(7089,8846,0)
(5829,7152,0)
(1185,81,0)
(7381,2854,0)
(163,4876,0)
(5820,5140,0)
(4857,3656,0)
(5161,3889,0)
(171,202,0)
(1077,862,0)
(8600,2477,0)
(5451,115,0)
(1911,3788,0)
(6410,7138,0)
(7080,2770,0)
(809,4384,0)
(6213,1186,0)
(5638,4149,0)
(6113,864,0)
(1210,8391,0)
(4474,4420,0)
(7814,7643,0)
(7726,8766,0)
(4878,7970,0)
(7186,4311,0)
(2894,7431,0)
(6932,7830,0)
(7549,7555,0)
(2350,3621,0)
(7632,115,0)
(7180,2168,0)
(8863,1944,0)
(7337,2094,0)
(3937,4126,0)
(4485,7003,0)
(2480,1701,0)
(6226,3356,0)
(8954,6067,0)
(3859,2212,0)
(532,7498,0)
(7177,8552,0)
(6330,1065,0)
(5393,1111,0)
(7980,3875,0)
(163,507,0)
(3274,2771,0)
(1737,5342,0)
(5420,691,0)
(4809,7210,0)
(8242,1350,0)
(8809,6799,0)
(3397,6782,0)
(8666,115,0)
(5708,5346,0)
(6689,1276,0)
(5461,2087,0)
(391,8391,0)
(203,1412,0)
(1022,8391,0)
(1102,4679,0)
(7106,860,0)
(7092,4664,0)
(4843,6695,0)
(2184,6844,0)
(2795,6855,0)
(7363,7495,0)
(8505,4915,0)
(3647,3491,0)
(4873,1158,0)
(7890,5156,0)
(3038,5748,0)
(7301,6081,0)
(4323,2363,0)
(4799,6325,0)
(1415,2112,0)
(6012,5402,0)
(1400,115,0)
(4911,8995,0)
(6362,6426,0)
(8633,5932,0)
(2007,3823,0)
(6539,8450,0)
(8998,1121,0)
(4255,6435,0)
(3008,8488,0)
(1147,1603,0)
(5362,864,0)
(3175,8391,0)
(7637,4333,0)
(3879,115,0)
(3091,2297,0)
(363,5244,0)
(4413,4819,0)
(4452,872,0)
(7138,6148,0)
(3849,115,0)
(199,4444,0)
(6812,1259,0)
(542,8820,0)
(6364,807,0)
(2240,2004,0)
(7973,7870,0)
(3654,8248,0)
(5188,5302,0)
(7673,7054,0)
(8889,115,0)
(4377,3818,0)
(2139,115,0)
(4531,8854,0)
(6998,7374,0)
(7049,6462,0)
(8519,1026,0)
(8342,1413,0)
(6053,4153,0)
(5489,115,0)
(6798,5871,0)
(2518,6517,0)
(5172,115,0)
(4093,7781,0)
(5214,4515,0)
(3358,7828,0)
(7146,1223,0)
(8665,2475,0)
(2462,1719,0)
(2288,8391,0)
(6170,952,0)
(6979,6972,0)
(4337,115,0)
(8211,5101,0)
(4614,7239,0)
(6290,1908,0)
(4190,46,0)
(2832,461,0)
(1379,6910,0)
(954,6671,0)
(2736,921,0)
(6212,6671,0)
(5244,3673,0)
(3582,8751,0)
(466,2934,0)
(713,5056,0)
(2775,8391,0)
(4520,5315,0)
(2490,4280,0)
(4679,4861,0)
(2571,8279,0)
(7516,8391,0)
(6194,7205,0)
(4374,5498,0)
(5251,2937,0)
(7911,7056,0)
(7147,6816,0)
(5246,264,0)
(3024,4068,0)
(1902,5209,0)
(1203,8505,0)
(839,7239,0)
(6963,8940,0)
(3461,4,0)
(4639,1978,0)
(489,3872,0)
(6258,2298,0)
(8356,4819,0)
(8171,6114,0)
(2065,2126,0)
(2416,4071,0)
(2620,7016,0)
(3433,2731,0)
(2045,386,0)
(5604,4311,0)
(4051,409,0)
(8702,4876,0)
(2059,717,0)
(3562,3254,0)
(2114,7969,0)
(5214,8471,0)
(8365,5128,0)
(1891,2211,0)
(1177,2464,0)
(5339,4043,0)
(8862,4553,0)
(2088,5477,0)
(6821,4610,0)
(6596,219,0)
(4050,1937,0)
(1056,4015,0)
(6868,7928,0)
(3902,4815,0)
(1694,115,0)
(520,2335,0)
(5677,4167,0)
(3596,2330,0)
(6452,7226,0)
(926,2153,0)
(6600,5084,0)
(6820,7393,0)
(2349,6483,0)
(2260,6916,0)
(8097,2604,0)
(1884,4909,0)
(3649,5129,0)
(3589,7883,0)
(9129,8074,0)
(1440,6454,0)
(8068,1605,0)
(5854,2842,0)
(9068,1149,0)
(3909,4524,0)
(8138,6825,0)
(2071,2454,0)
(6333,8381,0)
(2536,1935,0)
(2161,4741,0)
(3635,1347,0)
(3480,8139,0)
(6888,8391,0)
(3555,3942,0)
(2595,8340,0)
(4232,8646,0)
(8614,6649,0)
(2342,7888,0)
(716,3772,0)
(7883,115,0)
(915,5867,0)
(5087,1852,0)
(2735,7893,0)
(6357,115,0)
(608,8204,0)
(4510,1411,0)
(4742,4876,0)
(6317,8391,0)
(8947,116,0)
(8365,2481,0)
(2656,4567,0)
(6483,6900,0)
(8640,6200,0)
(4977,2459,0)
(1559,881,0)
(3020,7263,0)
(4504,6075,0)
(7012,2844,0)
(5927,8247,0)
(7902,1047,0)
(8923,7293,0)
(5530,446,0)
(345,115,0)
(8009,3375,0)
(8458,9017,0)
(4337,8391,0)
(5847,5515,0)
(7481,8664,0)
(8800,2612,0)
(2359,3800,0)
(4029,115,0)
(8647,280,0)
(3213,9130,0)
(3890,1238,0)
(5470,6096,0)
(3180,2375,0)
(4445,555,0)
(1094,848,0)
(1415,4630,0)
(2548,6928,0)
(1794,7611,0)
(6571,4055,0)
(8656,4924,0)
(5337,39,0)
(8028,6981,0)
(6690,2168,0)
(1644,4016,0)
(3062,8391,0)
(6672,4149,0)
(1235,8712,0)
(3834,5156,0)
(5055,2622,0)
(6270,6536,0)
(4633,8055,0)
(2464,1177,0)
(2821,8531,0)
(1488,4785,0)
(5086,7396,0)
(6021,1041,0)
(5391,6056,0)
(8947,7965,0)
(4693,3831,0)
(1389,6336,0)
(5483,3703,0)
(5665,5397,0)
(3118,8427,0)
(2754,5007,0)
(461,3012,0)
(4426,8391,0)
(4638,556,0)
(8510,5156,0)
(1742,8952,0)
(8518,3207,0)
(2354,115,0)
(7833,1298,0)
(577,1560,0)
(3810,8020,0)
(8440,3347,0)
(6001,3439,0)
(5654,5346,0)
(7985,2339,0)
(1492,2219,0)
(3631,4637,0)
(1443,718,0)
(7619,4821,0)
(6630,8807,0)
(5801,3064,0)
(8242,115,0)
(4173,5633,0)
(8228,2160,0)
(1427,1063,0)
(8644,2775,0)
(5203,8388,0)
(2287,1158,0)
(5795,8391,0)
(3857,3231,0)
(8251,1210,0)
(2366,5785,0)
(5537,5971,0)
(2104,5526,0)
(508,1975,0)
(6585,4232,0)
(5954,4444,0)
(5214,9130,0)
(5524,6347,0)
(722,8295,0)
(6429,8391,0)
(195,4838,0)
(2003,701,0)
(202,598,0)
(8343,8778,0)
(7206,7041,0)
(1833,5656,0)
(1263,8068,0)
(2334,1525,0)
(3377,1149,0)
(8817,2504,0)
(388,8302,0)
(8081,1956,0)
(3621,7039,0)
(5843,6443,0)
(6700,4503,0)
(4391,2582,0)
(8751,3582,0)
(2056,5,0)
(7844,4098,0)
(4580,7461,0)
(7736,7040,0)
(1415,8471,0)
(377,8824,0)
(5593,3215,0)
(2416,8768,0)
(8842,6092,0)
(2836,3076,0)
(4153,6053,0)
(3359,1788,0)
(6746,4466,0)
(8085,4872,0)
(6818,4032,0)
(7674,2187,0)
(1079,115,0)
(4682,7510,0)
(2524,5491,0)
(8746,3783,0)
(2748,996,0)
(5779,3542,0)
(3962,8321,0)
(7751,8358,0)
(8534,8540,0)
(151,8549,0)
(5435,4726,0)
(828,1178,0)
(7622,6137,0)
(3248,1628,0)
(8963,6671,0)
(6555,3679,0)
(1266,5829,0)
(3821,2057,0)
(417,2707,0)
(5757,5104,0)
(4169,1929,0)
(5018,7925,0)
(5930,2752,0)
(4150,2176,0)
(2151,8391,0)
(579,8391,0)
(8487,7575,0)
(5638,1262,0)
(218,5039,0)
(3302,8908,0)
(3517,7097,0)
(8601,4417,0)
(7211,1724,0)
(7858,7516,0)
(3946,1017,0)
(1707,8391,0)
(2105,2243,0)
(2411,3051,0)
(219,115,0)
(8340,8391,0)
(1696,5501,0)
(4222,1447,0)
(8709,8391,0)
(7498,8391,0)
(7409,4057,0)
(8527,5573,0)
(2110,1304,0)
(4545,930,0)
(5070,7055,0)
(1832,8743,0)
(3894,1523,0)
(1616,5829,0)
(8311,2845,0)
(1003,3649,0)
(1611,7230,0)
(6906,8088,0)
(740,7531,0)
(7377,6678,0)
(4946,5655,0)
(5590,1047,0)
(6337,2053,0)
(2382,2295,0)
(267,5754,0)
(8533,4249,0)
(873,8138,0)
(7595,115,0)
(4814,7711,0)
(5580,5632,0)
(8213,980,0)
(3682,8786,0)
(6369,3250,0)
(6069,7577,0)
(306,3872,0)
(4244,3335,0)
(6597,3035,0)
(5386,5556,0)
(660,2043,0)
(7028,8031,0)
(7054,1134,0)
(8368,3147,0)
(6348,7019,0)
(6060,8670,0)
(3804,8021,0)
(7638,3075,0)
(1295,6196,0)
(6400,5118,0)
(4397,822,0)
(2701,1530,0)
(7284,5688,0)
(6901,8098,0)
(3875,5773,0)
(6241,1212,0)
(2935,7588,0)
(409,4051,0)
(4190,7969,0)
(4632,530,0)
(7034,5584,0)
(1682,6405,0)
(4697,6202,0)
(4015,4883,0)
(8517,4201,0)
(8715,559,0)
(8451,1299,0)
(3083,1985,0)
(4396,2861,0)
(2718,8199,0)
(4390,2370,0)
(8121,1917,0)
(2118,144,0)
(4185,7807,0)
(7966,3889,0)
(7409,6292,0)
(2677,8391,0)
(8919,8801,0)
(4493,2995,0)
(6004,8964,0)
(272,7316,0)
(6680,1586,0)
(988,393,0)
(541,2160,0)
(547,1392,0)
(4417,115,0)
(5661,5526,0)
(8249,1077,0)
(4383,7977,0)
(5316,3891,0)
(2402,7108,0)
(2963,3171,0)
(3780,6509,0)
(3703,5483,0)
(6040,4783,0)
(7995,473,0)
(2247,7328,0)
(7408,3451,0)
(8939,4340,0)
(1350,3297,0)
(4816,7004,0)
(3174,8321,0)
(8964,6004,0)
(7309,34,0)
(3398,2823,0)
(1045,115,0)
(4118,7970,0)
(4385,4125,0)
(3597,1438,0)
(8552,8677,0)
(2379,4729,0)
(4826,5388,0)
(5979,8030,0)
(7227,5469,0)
(1800,4495,0)
(1602,5928,0)
(3896,5506,0)
(6194,6244,0)
(7100,6559,0)
(7655,7891,0)
(3262,8891,0)
(2663,4128,0)
(6602,4785,0)
(3415,6726,0)
(7041,4413,0)
(7847,115,0)
(5817,6751,0)
(8872,1077,0)
(3955,8743,0)
(274,499,0)
(7765,2995,0)
(2837,437,0)
(3151,7167,0)
(9015,9073,0)
(1765,4945,0)
(6183,5058,0)
(5638,7039,0)
(6975,3583,0)
(5690,7453,0)
(6643,67,0)
(8615,6047,0)
(7765,6985,0)
(4605,2391,0)
(6877,2120,0)
(3758,1511,0)
(2069,2892,0)
(6173,8194,0)
(4479,7743,0)
(8554,8355,0)
(3705,7925,0)
(8043,8190,0)
(1688,4051,0)
(4707,4536,0)
(1415,2652,0)
(6048,8695,0)
(473,115,0)
(54,5003,0)
(1053,2610,0)
(8654,8677,0)
(8175,4515,0)
(2842,115,0)
(4189,115,0)
(4805,6671,0)
(5700,5145,0)
(1415,7039,0)
(624,4711,0)
(940,972,0)
(3945,543,0)
(2287,9138,0)
(5809,8458,0)
(3522,4848,0)
(1197,572,0)
(7347,3784,0)
(1269,1149,0)
(1222,4876,0)
(2176,4150,0)
(1324,6142,0)
(5887,5754,0)
(6209,6400,0)
(7493,5633,0)
(8701,6671,0)
(707,8712,0)
(3868,5507,0)
(977,6158,0)
(5719,2845,0)
(3804,7625,0)
(5994,5193,0)
(6319,6671,0)
(3713,115,0)
(1213,115,0)
(6734,115,0)
(8652,6026,0)
(6220,4038,0)
(9117,2845,0)
(3804,6563,0)
(5484,4963,0)
(8865,2887,0)
(507,7233,0)
(7030,2111,0)
(1486,8581,0)
(2591,2845,0)
(7959,4332,0)
(7226,8580,0)
(922,2596,0)
(5244,7951,0)
(2737,8303,0)
(2295,4037,0)
(6571,3102,0)
(5184,5704,0)
(6419,1280,0)
(6875,8391,0)
(7579,8147,0)
(2122,8430,0)
(5311,2683,0)
(1286,1857,0)
(4254,2203,0)
(8957,6904,0)
(6000,1162,0)
(5359,8870,0)
(4159,1869,0)
(1911,1054,0)
(7404,2597,0)
(8578,5156,0)
(2006,7791,0)
(7939,8757,0)
(5479,6760,0)
(1044,8391,0)
(6737,5716,0)
(7470,8913,0)
(7595,3731,0)
(2998,661,0)
(8904,3940,0)
(5840,7798,0)
(3073,1482,0)
(6027,5124,0)
(1208,8391,0)
(8793,6412,0)
(416,115,0)
(782,6348,0)
(358,8391,0)
(8204,7042,0)
(4863,6341,0)
(523,115,0)
(8199,2718,0)
(3676,1623,0)
(8331,3602,0)
(25,115,0)
(1555,8391,0)
(8057,8391,0)
(2505,8444,0)
(2717,4277,0)
(8584,5144,0)
(8062,7085,0)
(7925,5018,0)
(3601,1766,0)
(2518,3941,0)
(4126,2620,0)
(3690,8391,0)
(6425,7260,0)
(3680,2604,0)
(7711,3335,0)
(8313,115,0)
(3207,115,0)
(3175,115,0)
(351,2836,0)
(6024,4950,0)
(3509,700,0)
(587,2336,0)
(5029,3829,0)
(3444,116,0)
(4497,7136,0)
(8462,5810,0)
(3250,8391,0)
(1416,6908,0)
(5669,115,0)
(345,4154,0)
(1532,7328,0)
(4201,2385,0)
(8441,306,0)
(2162,115,0)
(7628,7667,0)
(8975,8654,0)
(5626,8781,0)
(8478,2805,0)
(6356,1523,0)
(617,8391,0)
(8857,5196,0)
(4032,228,0)
(3960,1052,0)
(5571,6734,0)
(2040,2782,0)
(5859,4631,0)
(6732,177,0)
(2456,1126,0)
(8780,2399,0)
(6144,1103,0)
(8064,1126,0)
(2635,8258,0)
(70,2706,0)
(6411,5422,0)
(4443,7939,0)
(4349,1103,0)
(343,3257,0)
(6181,6640,0)
(3213,8471,0)
(1430,8573,0)
(2804,1944,0)
(1500,933,0)
(8603,3987,0)
(3525,3341,0)
(6631,6454,0)
(4284,118,0)
(8042,4619,0)
(4454,309,0)
(610,8851,0)
(4013,6875,0)
(698,6554,0)
(930,8391,0)
(1530,944,0)
(1415,7524,0)
(1792,8391,0)
(1031,8391,0)
(622,2161,0)
(8532,9019,0)
(1415,6478,0)
(7732,8257,0)
(4975,3090,0)
(3712,5123,0)
(4628,1858,0)
(3401,2630,0)
(1415,7404,0)
(8194,6173,0)
(3792,1754,0)
(2231,8282,0)
(1311,2831,0)
(6523,515,0)
(4409,5147,0)
(7119,5965,0)
(706,4445,0)
(7668,1324,0)
(7446,6412,0)
(4245,5237,0)
(6891,3036,0)
(8139,115,0)
(6935,1829,0)
(4873,8458,0)
(7056,8391,0)
(8909,115,0)
(2739,2224,0)
(1142,4043,0)
(1553,6578,0)
(2080,800,0)
(8419,115,0)
(965,9125,0)
(3662,1029,0)
(4656,7113,0)
(7198,8391,0)
(7347,6423,0)
(8464,8822,0)
(3001,5038,0)
(4797,5523,0)
(5709,5611,0)
(1463,226,0)
(4070,115,0)
(7727,2965,0)
(334,5315,0)
(3122,170,0)
(2243,7711,0)
(8678,4700,0)
(7626,700,0)
(5961,2422,0)
(2723,43,0)
(6914,8883,0)
(4006,3294,0)
(5672,1379,0)
(4880,6386,0)
(6284,8111,0)
(4664,1488,0)
(7122,5027,0)
(279,7590,0)
(4311,7186,0)
(6091,8391,0)
(3586,8311,0)
(5855,5776,0)
(7912,5829,0)
(7886,5708,0)
(5461,3151,0)
(1157,916,0)
(2346,6351,0)
(7014,5235,0)
(5299,4314,0)
(7694,9010,0)
(2566,1092,0)
(6791,1982,0)
(2287,9130,0)
(3646,3582,0)
(3607,4890,0)
(8804,7810,0)
(4375,3193,0)
(1124,170,0)
(1725,4886,0)
(1961,1125,0)
(7254,3110,0)
(7579,3103,0)
(7678,8819,0)
(7634,3924,0)
(3119,5602,0)
(7523,3657,0)
(7559,6374,0)
(3855,4207,0)
(5416,3594,0)
(4220,2403,0)
(8354,2012,0)
(7554,1166,0)
(1973,5953,0)
(4473,5496,0)
(709,3463,0)
(5165,1925,0)
(6336,6348,0)
(8849,115,0)
(4888,5559,0)
(1,8009,0)
(264,8128,0)
(5602,8613,0)
(155,7711,0)
(881,2481,0)
(7924,3690,0)
(7564,6376,0)
(937,306,0)
(6033,269,0)
(7664,1104,0)
(3507,4876,0)
(2102,2858,0)
(1739,7413,0)
(5844,5369,0)
(2409,4765,0)
(4234,1273,0)
(5604,5084,0)
(4074,1276,0)
(2457,2176,0)
(8837,7792,0)
(5071,7759,0)
(2423,8391,0)
(7532,3451,0)
(4441,8439,0)
(3757,8393,0)
(8025,7003,0)
(1723,2162,0)
(1277,6067,0)
(7804,8311,0)
(2962,8338,0)
(8414,3498,0)
(670,2664,0)
(6440,9127,0)
(3212,5719,0)
(6030,115,0)
(7525,115,0)
(1415,6981,0)
(4389,8391,0)
(4369,4475,0)
(127,3878,0)
(6355,5007,0)
(741,7079,0)
(2195,8205,0)
(2164,1672,0)
(1226,4900,0)
(4030,6063,0)
(8582,8391,0)
(6353,6273,0)
(8269,5906,0)
(1438,8391,0)
(8076,3660,0)
(4625,115,0)
(3551,7392,0)
(1554,6220,0)
(5107,7891,0)
(5243,8702,0)
(1363,8391,0)
(6004,2034,0)
(6494,6956,0)
(5806,7995,0)
(2920,1221,0)
(879,6485,0)
(5476,4864,0)
(7874,8581,0)
(2775,115,0)
(4607,3295,0)
(1215,5346,0)
(6908,5829,0)
(6502,1474,0)
(2381,8391,0)
(5044,1093,0)
(3862,5076,0)
(3804,8458,0)
(7485,1967,0)
(8775,373,0)
(3149,115,0)
(425,8391,0)
(3264,7735,0)
(3346,3251,0)
(7311,9124,0)
(5555,8182,0)
(1729,8391,0)
(7666,2401,0)
(3980,1233,0)
(310,1782,0)
(1754,8391,0)
(6036,9063,0)
(4678,3108,0)
(2410,6310,0)
(268,4690,0)
(5874,2907,0)
(8935,7058,0)
(2577,5828,0)
(2450,4889,0)
(2944,6762,0)
(6570,1096,0)
(6178,3998,0)
(3138,6528,0)
(1141,2688,0)
(5214,6649,0)
(6174,4618,0)
(1729,115,0)
(965,4521,0)
(5214,8458,0)
(1644,3782,0)
(2476,902,0)
(2084,7080,0)
(7452,5470,0)
(1500,4029,0)
(4746,3165,0)
(7735,3717,0)
(2485,6799,0)
(1239,4117,0)
(1954,4445,0)
(8500,3874,0)
(2258,8088,0)
(3859,3020,0)
(1480,1891,0)
(1384,2421,0)
(881,1559,0)
(2099,3621,0)
(5406,5094,0)
(8372,2424,0)
(3847,8391,0)
(5317,6151,0)
(5839,1379,0)
(227,5583,0)
(4553,8862,0)
(2153,926,0)
(166,2012,0)
(4885,7849,0)
(7175,3266,0)
(5885,6111,0)
(4004,8008,0)
(2453,2801,0)
(7213,4882,0)
(2487,2845,0)
(341,8143,0)
(2278,1121,0)
(1272,4889,0)
(3260,115,0)
(7223,425,0)
(1417,7939,0)
(1100,1241,0)
(8120,1061,0)
(9042,546,0)
(3940,115,0)
(8712,1235,0)
(7855,6594,0)
(6967,2592,0)
(894,5667,0)
(2461,4011,0)
(4378,115,0)
(3819,115,0)
(4912,4001,0)
(5403,7491,0)
(4195,9128,0)
(5268,8204,0)
(7224,2281,0)
(2987,3318,0)
(40,2754,0)
(2535,4596,0)
(8785,4182,0)
(4424,4876,0)
(7832,176,0)
(8138,753,0)
(7862,5132,0)
(3326,778,0)
(4915,8505,0)
(8799,4,0)
(1866,6889,0)
(1415,4515,0)
(2015,6671,0)
(3003,1717,0)
(8723,8391,0)
(6413,8637,0)
(7302,3574,0)
(8562,7035,0)
(1844,4843,0)
(4095,6880,0)
(426,3788,0)
(1831,5181,0)
(6740,932,0)
(7687,8528,0)
(9029,8391,0)
(4645,6325,0)
(3650,3197,0)
(4883,2274,0)
(7031,115,0)
(1757,7458,0)
(3057,617,0)
(4092,2258,0)
(1025,4582,0)
(7329,6919,0)
(315,8710,0)
(2264,6366,0)
(6850,3097,0)
(5533,1111,0)
(1088,8341,0)
(373,8775,0)
(8095,6215,0)
(4225,4638,0)
(1903,5312,0)
(5973,2416,0)
(6019,8485,0)
(4196,6014,0)
(9135,3248,0)
(4511,7156,0)
(3616,8495,0)
(7626,4350,0)
(4792,925,0)
(437,5178,0)
(1630,2520,0)
(1291,7764,0)
(5372,8419,0)
(92,2488,0)
(8469,3075,0)
(3193,8699,0)
(2415,4882,0)
(6609,8391,0)
(1189,2057,0)
(6885,968,0)
(620,353,0)
(704,2679,0)
(8820,8391,0)
(7292,3733,0)
(7962,2043,0)
(3698,2385,0)
(8590,2938,0)
(5298,4020,0)
(8036,3187,0)
(6510,4666,0)
(7428,1484,0)
(6030,8391,0)
(1966,1222,0)
(5010,2717,0)
(3222,6960,0)
(7432,115,0)
(655,115,0)
(1643,835,0)
(5425,7587,0)
(7791,6019,0)
(3431,8587,0)
(5436,3377,0)
(2752,2900,0)
(525,8446,0)
(6484,1779,0)
(6069,4445,0)
(1719,8470,0)
(8235,8503,0)
(4149,3451,0)
(5919,6671,0)
(3151,4876,0)
(9106,2845,0)
(3112,7135,0)
(3672,8338,0)
(6489,5926,0)
(6502,6419,0)
(2688,2845,0)
(6504,8193,0)
(1267,7079,0)
(4121,6839,0)
(2254,8628,0)
(1348,6875,0)
(4763,8453,0)
(6165,3751,0)
(2818,8391,0)
(1655,6671,0)
(6151,7796,0)
(1557,1188,0)
(1276,6689,0)
(6088,115,0)
(4666,6510,0)
(4249,3633,0)
(5294,7963,0)
(4295,3552,0)
(767,7561,0)
(6521,1152,0)
(118,4619,0)
(4375,9130,0)
(2070,5817,0)
(1453,3738,0)
(2653,1149,0)
(8655,3306,0)
(6880,7316,0)
(8937,1208,0)
(6556,286,0)
(5021,2314,0)
(2315,8391,0)
(5945,2626,0)
(2041,4733,0)
(350,8010,0)
(6250,4672,0)
(3484,8021,0)
(4915,9128,0)
(6855,8510,0)
(8191,1180,0)
(6288,8391,0)
(4618,6174,0)
(2287,2112,0)
(1410,8010,0)
(7368,1329,0)
(5326,6671,0)
(1639,4423,0)
(5796,5722,0)
(2922,1153,0)
(4062,5038,0)
(7212,8429,0)
(6109,9050,0)
(2857,334,0)
(462,6741,0)
(7849,798,0)
(6418,1606,0)
(677,8713,0)
(4999,5545,0)
(1306,9012,0)
(4395,2955,0)
(4055,6926,0)
(6492,4066,0)
(1577,3804,0)
(7489,5038,0)
(6230,5547,0)
(8196,2239,0)
(2592,6967,0)
(4627,2570,0)
(6522,4567,0)
(7022,4876,0)
(7531,732,0)
(4781,5156,0)
(1571,2892,0)
(1125,4752,0)
(7653,115,0)
(6313,4393,0)
(4064,3257,0)
(2612,2146,0)
(6768,719,0)
(2203,5829,0)
(4410,8026,0)
(7396,3286,0)
(3595,6614,0)
(7493,5775,0)
(1122,8736,0)
(5651,4026,0)
(1783,5156,0)
(8051,2473,0)
(5998,8391,0)
(4969,7140,0)
(7464,4304,0)
(7883,2845,0)
(7735,4876,0)
(8734,5638,0)
(1161,6559,0)
(2942,1729,0)
(5208,8585,0)
(314,1542,0)
(8043,5413,0)
(340,8391,0)
(5375,5919,0)
(3618,190,0)
(7540,8691,0)
(5396,4560,0)
(2267,5556,0)
(1641,3103,0)
(8057,115,0)
(2967,2293,0)
(3461,4313,0)
(3534,8391,0)
(6372,5110,0)
(6442,5843,0)
(8967,5315,0)
(4286,2972,0)
(3175,2246,0)
(3238,7703,0)
(4375,4587,0)
(539,1938,0)
(3479,5768,0)
(514,5852,0)
(8632,3747,0)
(2397,2656,0)
(7786,573,0)
(3791,1305,0)
(1061,6783,0)
(7374,6998,0)
(1223,7146,0)
(6836,8426,0)
(4081,5454,0)
(5679,181,0)
(4959,929,0)
(3776,108,0)
(6331,4105,0)
(3962,6577,0)
(6121,4876,0)
(4792,4321,0)
(2030,1055,0)
(1165,2445,0)
(5739,167,0)
(1533,7462,0)
(8935,3580,0)
(5632,5580,0)
(6137,7622,0)
(5458,3286,0)
(402,1048,0)
(7746,741,0)
(5377,5184,0)
(3617,5109,0)
(7850,51,0)
(8830,8391,0)
(4573,7046,0)
(3176,5331,0)
(5232,7400,0)
(8288,6598,0)
(6256,5479,0)
(2691,8587,0)
(610,8391,0)
(8731,3483,0)
(6755,2701,0)
(4159,6196,0)
(1415,3223,0)
(7832,7080,0)
(3807,4581,0)
(1212,6241,0)
(7215,7449,0)
(8680,1601,0)
(2243,718,0)
(5057,1149,0)
(7196,3621,0)
(950,1727,0)
(2522,8391,0)
(8312,7363,0)
(4725,7306,0)
(5433,3530,0)
(7817,8923,0)
(2544,1158,0)
(2341,3340,0)
(4674,911,0)
(4079,2566,0)
(8496,115,0)
(2886,2666,0)
(8876,6671,0)
(2527,1461,0)
(2818,8405,0)
(6538,2396,0)
(4521,8328,0)
(1026,1998,0)
(1415,6708,0)
(7548,2775,0)
(228,727,0)
(3751,1712,0)
(7984,1564,0)
(3645,2823,0)
(265,5069,0)
(1264,4673,0)
(4847,8391,0)
(4510,5633,0)
(7683,3028,0)
(1073,2460,0)
(2934,466,0)
(3756,743,0)
(189,3984,0)
(3834,8479,0)
(5687,2845,0)
(6448,9043,0)
(1258,8683,0)
(6334,7119,0)
(6429,3634,0)
(3439,6001,0)
(4011,6426,0)
(3213,3424,0)
(862,8391,0)
(4657,7810,0)
(4388,3992,0)
(7664,5156,0)
(8436,2868,0)
(3334,2867,0)
(8211,1670,0)
(3634,6429,0)
(7856,980,0)
(1117,5302,0)
(8398,6031,0)
(6436,8136,0)
(2287,4449,0)
(697,796,0)
(5446,4360,0)
(6032,4273,0)
(5584,8391,0)
(5498,8697,0)
(5552,6109,0)
(5851,3811,0)
(3699,4774,0)
(4752,1125,0)
(5874,115,0)
(5196,8674,0)
(3440,1745,0)
(6683,5223,0)
(2465,4865,0)
(7482,1931,0)
(8977,5597,0)
(71,3436,0)
(6148,7138,0)
(3728,6655,0)
(7664,4876,0)
(6717,5166,0)
(1694,6537,0)
(5109,8391,0)
(9110,4966,0)
(4547,2858,0)
(6962,6671,0)
(5968,3078,0)
(2955,1858,0)
(3868,8391,0)
(8493,2002,0)
(6435,2309,0)
(4703,268,0)
(7638,2984,0)
(2666,4876,0)
(523,3873,0)
(6908,7760,0)
(4070,3340,0)
(8295,8391,0)
(384,965,0)
(5688,2043,0)
(4761,6001,0)
(1605,5156,0)
(7660,4564,0)
(5208,1040,0)
(7792,8837,0)
(6179,6097,0)
(8061,4510,0)
(8837,115,0)
(5126,7548,0)
(1908,4252,0)
(365,2504,0)
(5346,6026,0)
(7154,2293,0)
(5916,6179,0)
(8142,732,0)
(769,800,0)
(8820,542,0)
(6254,8391,0)
(4057,2724,0)
(6915,7555,0)
(5371,115,0)
(2538,115,0)
(6746,6132,0)
(4736,3375,0)
(6528,951,0)
(2310,5722,0)
(3804,4515,0)
(6598,8288,0)
(631,1017,0)
(7113,4544,0)
(3570,4792,0)
(4475,1567,0)
(980,7856,0)
(248,115,0)
(8320,8123,0)
(2233,6062,0)
(8203,5512,0)
(5454,4081,0)
(2560,1707,0)
(876,6538,0)
(178,7777,0)
(395,3817,0)
(2526,2092,0)
(1241,2279,0)
(9047,115,0)
(6697,7229,0)
(7366,8391,0)
(1394,8431,0)
(3851,3954,0)
(6189,1889,0)
(1698,1121,0)
(5583,115,0)
(36,8149,0)
(8200,2231,0)
(8439,5602,0)
(7132,8793,0)
(5223,1488,0)
(6903,7866,0)
(771,3906,0)
(8552,3277,0)
(3515,3815,0)
(2401,2391,0)
(8628,8199,0)
(4381,1206,0)
(4793,3983,0)
(6997,6254,0)
(1960,1641,0)
(8421,6227,0)
(7120,8391,0)
(8241,7799,0)
(7194,2035,0)
(4026,8817,0)
(6788,6333,0)
(3804,1158,0)
(1733,6236,0)
(477,8391,0)
(4280,115,0)
(2674,6201,0)
(7748,1152,0)
(2783,5361,0)
(7527,8940,0)
(2308,6279,0)
(7500,3831,0)
(6299,378,0)
(1822,3830,0)
(323,618,0)
(2460,5104,0)
(7883,8391,0)
(4620,7229,0)
(3182,3477,0)
(7448,4823,0)
(4632,7890,0)
(6521,504,0)
(2338,6671,0)
(4055,6571,0)
(7618,6795,0)
(7988,8391,0)
(2287,6563,0)
(3006,8683,0)
(3931,1373,0)
(8753,6090,0)
(3223,8208,0)
(4057,4405,0)
(6284,700,0)
(5828,4327,0)
(4071,2416,0)
(2157,1758,0)
(671,2403,0)
(5770,9069,0)
(4924,8656,0)
(3774,115,0)
(8776,8391,0)
(3804,3657,0)
(5381,7201,0)
(628,5057,0)
(4161,1891,0)
(5995,2869,0)
(1850,115,0)
(8802,115,0)
(1152,115,0)
(2547,3218,0)
(8599,7893,0)
(567,8274,0)
(7086,1542,0)
(6910,3122,0)
(8091,6358,0)
(7088,20,0)
(6534,4307,0)
(8244,7163,0)
(212,3139,0)
(4909,4619,0)
(3268,2803,0)
(9015,2976,0)
(6896,6464,0)
(4300,6094,0)
(3986,5298,0)
(7957,2617,0)
(1222,7453,0)
(4741,6378,0)
(2347,7793,0)
(5506,6736,0)
(2884,5914,0)
(2051,1612,0)
(8723,3668,0)
(5494,3565,0)
(91,8538,0)
(1748,5374,0)
(4503,3518,0)
(4351,1370,0)
(3316,8738,0)
(4202,2934,0)
(3124,2874,0)
(4676,3076,0)
(3648,4128,0)
(6231,9138,0)
(3036,4442,0)
(4472,5226,0)
(3374,25,0)
(7626,890,0)
(2687,9061,0)
(4527,4763,0)
(6750,8391,0)
(8982,3006,0)
(727,8391,0)
(1764,92,0)
(5662,7764,0)
(5819,2327,0)
(9086,5209,0)
(3362,1270,0)
(1788,6545,0)
(8838,115,0)
(2788,8454,0)
(4619,3522,0)
(6580,914,0)
(1302,2326,0)
(4990,371,0)
(6137,724,0)
(1116,3844,0)
(2119,6992,0)
(1644,7771,0)
(1121,4077,0)
(112,8579,0)
(8979,8190,0)
(3800,4292,0)
(177,5315,0)
(2534,8484,0)
(3445,8117,0)
(7480,2074,0)
(5923,7982,0)
(8485,8438,0)
(8177,3430,0)
(8811,2929,0)
(6272,286,0)
(35,2796,0)
(8296,7797,0)
(5104,2460,0)
(4695,2458,0)
(3213,8111,0)
(5658,6438,0)
(1471,5156,0)
(6496,2714,0)
(528,115,0)
(6531,524,0)
(9001,4467,0)
(8742,8391,0)
(5950,4205,0)
(5494,8471,0)
(4650,3875,0)
(1166,1600,0)
(4248,2298,0)
(286,6272,0)
(5596,3151,0)
(4986,918,0)
(4210,7703,0)
(1407,1125,0)
(7929,6544,0)
(8792,457,0)
(5801,3932,0)
(4869,1911,0)
(6429,2845,0)
(6371,741,0)
(7163,8593,0)
(8983,8996,0)
(4010,4585,0)
(4690,4289,0)
(6724,7812,0)
(3126,8378,0)
(1914,7991,0)
(4043,115,0)
(3947,5168,0)
(3572,780,0)
(7525,8499,0)
(3548,5531,0)
(7462,8391,0)
(1213,5388,0)
(5499,1603,0)
(4320,2549,0)
(1900,6816,0)
(6536,6671,0)
(1849,3684,0)
(4212,115,0)
(4031,3740,0)
(3791,115,0)
(800,8391,0)
(4018,1324,0)
(998,6888,0)
(8907,3496,0)
(351,3738,0)
(6159,3451,0)
(2112,8391,0)
(8158,6815,0)
(5811,4380,0)
(7945,8027,0)
(333,2414,0)
(2782,8391,0)
(6265,4925,0)
(921,4558,0)
(3534,115,0)
(7780,211,0)
(3087,1406,0)
(6539,115,0)
(4393,914,0)
(5756,6671,0)
(7434,8646,0)
(5895,6425,0)
(5879,2714,0)
(8339,2459,0)
(6582,8832,0)
(4781,5197,0)
(4837,8549,0)
(8126,2952,0)
(2520,8503,0)
(7715,6431,0)
(8182,5555,0)
(6660,786,0)
(8583,21,0)
(4653,7411,0)
(7865,868,0)
(7408,8391,0)
(2287,489,0)
(7973,4468,0)
(1089,5421,0)
(3815,8561,0)
(1825,1069,0)
(2375,3904,0)
(9083,5932,0)
(2297,5862,0)
(2450,1380,0)
(7083,1799,0)
(6993,6208,0)
(4178,8728,0)
(3082,4162,0)
(1018,2283,0)
(2630,3401,0)
(2521,6033,0)
(5267,6921,0)
(7521,4076,0)
(596,798,0)
(8318,1785,0)
(8201,1869,0)
(1697,7977,0)
(1954,5512,0)
(3899,4724,0)
(1759,4758,0)
(2600,6671,0)
(8299,1516,0)
(5333,5801,0)
(125,6710,0)
(1969,115,0)
(5233,2422,0)
(1368,3254,0)
(6446,3053,0)
(8226,1755,0)
(4353,8429,0)
(2811,5577,0)
(5481,3130,0)
(7013,6824,0)
(6557,1049,0)
(1039,7532,0)
(3804,2497,0)
(477,7339,0)
(4547,1319,0)
(6513,2845,0)
(7834,7139,0)
(7324,8966,0)
(5922,3589,0)
(941,7966,0)
(8587,2591,0)
(3063,8570,0)
(2292,2566,0)
(4814,8391,0)
(3709,4820,0)
(1842,8582,0)
(8205,2195,0)
(3523,267,0)
(8680,2041,0)
(4827,8043,0)
(3614,1347,0)
(23,9127,0)
(1354,5949,0)
(6143,592,0)
(7647,6495,0)
(4738,7199,0)
(6941,8585,0)
(8695,378,0)
(3261,9067,0)
(4422,6995,0)
(7849,8802,0)
(82,3632,0)
(6595,7970,0)
(682,3031,0)
(7532,8391,0)
(1907,3248,0)
(4071,3719,0)
(1085,115,0)
(7785,8063,0)
(72,6566,0)
(7578,8391,0)
(5969,4494,0)
(2698,4875,0)
(1616,3192,0)
(8348,6776,0)
(5598,1167,0)
(283,6524,0)
(5938,1171,0)
(5907,8891,0)
(6692,5477,0)
(7663,2136,0)
(5887,6742,0)
(5445,5768,0)
(5369,5844,0)
(5297,269,0)
(6049,3333,0)
(1251,5693,0)
(8624,665,0)
(8994,1184,0)
(6392,9004,0)
(8329,3997,0)
(5595,2241,0)
(2620,179,0)
(6759,4224,0)
(5634,6671,0)
(3239,3106,0)
(8775,3300,0)
(8038,8471,0)
(8558,5027,0)
(8110,5829,0)
(8960,4560,0)
(4288,2756,0)
(3932,6671,0)
(704,2329,0)
(1951,2656,0)
(4051,1829,0)
(4148,6088,0)
(6922,1758,0)
(1418,2043,0)
(8131,5290,0)
(3804,4449,0)
(6630,3679,0)
(7384,1149,0)
(6789,5448,0)
(5383,8391,0)
(8620,8187,0)
(5107,8391,0)
(2150,5631,0)
(1755,8391,0)
(5354,4785,0)
(5977,4583,0)
(2517,3491,0)
(301,7463,0)
(5440,8570,0)
(7079,1446,0)
(3169,1937,0)
(5510,10,0)
(3470,550,0)
(4108,4646,0)
(4593,1980,0)
(2141,8209,0)
(8783,1049,0)
(7957,3887,0)
(3913,3512,0)
(256,1086,0)
(1241,115,0)
(3658,4239,0)
(4038,8378,0)
(6900,8825,0)
(5604,102,0)
(2421,34,0)
(3151,5461,0)
(7409,5196,0)
(7253,4601,0)
(1323,2285,0)
(7603,424,0)
(7652,3419,0)
(1495,3169,0)
(6258,6438,0)
(345,8391,0)
(1017,8677,0)
(1638,6854,0)
(9088,7711,0)
(6784,3632,0)
(8984,2763,0)
(1171,5938,0)
(6368,1227,0)
(6651,2168,0)
(1415,2993,0)
(6991,8423,0)
(7140,3106,0)
(1856,3820,0)
(8487,4104,0)
(926,115,0)
(2800,7161,0)
(1030,6671,0)
(2756,2367,0)
(6664,2690,0)
(4524,8391,0)
(6405,1682,0)
(5110,115,0)
(1320,2467,0)
(248,2668,0)
(1430,2329,0)
(7777,8452,0)
(897,7077,0)
(2606,163,0)
(7505,8738,0)
(2253,2918,0)
(3973,5913,0)
(1795,5366,0)
(1674,8517,0)
(8749,7422,0)
(1711,6671,0)
(3621,8471,0)
(3170,5549,0)
(6232,8838,0)
(6438,6258,0)
(6482,7468,0)
(2981,2112,0)
(4584,4501,0)
(4259,9083,0)
(3171,8102,0)
(8427,4505,0)
(3165,456,0)
(1337,5428,0)
(1512,6957,0)
(4570,6671,0)
(7486,340,0)
(2904,8623,0)
(8313,1613,0)
(7672,270,0)
(7539,5204,0)
(3462,724,0)
(2250,777,0)
(5047,2482,0)
(4818,6917,0)
(2246,6671,0)
(4198,5283,0)
(3171,7588,0)
(6797,7764,0)
(3932,966,0)
(6736,8819,0)
(6080,7029,0)
(1699,6049,0)
(5721,5123,0)
(7411,6753,0)
(4168,3141,0)
(3113,6523,0)
(3025,3266,0)
(8758,4191,0)
(7735,5156,0)
(4142,8935,0)
(928,5018,0)
(5817,1488,0)
(2593,4349,0)
(5533,5516,0)
(1918,1166,0)
(663,2885,0)
(2769,8335,0)
(4873,4515,0)
(4431,8391,0)
(438,5852,0)
(4563,6137,0)
(8366,115,0)
(7280,4287,0)
(3466,1488,0)
(1629,8633,0)
(7841,859,0)
(2836,351,0)
(2760,1792,0)
(8320,5174,0)
(8531,8391,0)
(3557,5192,0)
(7960,4785,0)
(6440,8585,0)
(8388,5315,0)
(1470,5351,0)
(2058,4272,0)
(6803,4859,0)
(7705,2645,0)
(412,7827,0)
(4836,8391,0)
(8418,7203,0)
(6795,115,0)
(5152,4029,0)
(7478,2748,0)
(6434,7426,0)
(2003,8532,0)
(6236,115,0)
(6499,5445,0)
(6529,8057,0)
(212,8391,0)
(2390,345,0)
(2116,1246,0)
(1725,8182,0)
(5303,3058,0)
(7283,115,0)
(9101,1782,0)
(9020,4837,0)
(1895,4225,0)
(5528,6104,0)
(4428,7847,0)
(8642,8673,0)
(4038,3203,0)
(3804,4587,0)
(5262,523,0)
(804,3899,0)
(4904,1107,0)
(3460,1135,0)
(6849,8293,0)
(5556,5386,0)
(2644,6907,0)
(1863,8986,0)
(4392,6666,0)
(8314,1220,0)
(8778,2087,0)
(1236,2689,0)
(6424,6842,0)
(1087,1270,0)
(3050,5829,0)
(7917,7912,0)
(6502,7881,0)
(6950,644,0)
(595,3621,0)
(5490,1361,0)
(1907,8156,0)
(551,7820,0)
(581,6104,0)
(9058,3806,0)
(6463,4001,0)
(1273,6265,0)
(1380,115,0)
(624,5614,0)
(1265,8985,0)
(7232,1011,0)
(6301,6156,0)
(895,3577,0)
(5556,5988,0)
(4620,4682,0)
(114,8870,0)
(1670,115,0)
(2287,6435,0)
(5428,6855,0)
(4987,5834,0)
(8239,6956,0)
(8318,4718,0)
(8793,6452,0)
(5509,994,0)
(1664,3087,0)
(6503,6671,0)
(4107,6202,0)
(7569,3059,0)
(6321,5510,0)
(8013,6949,0)
(4773,5070,0)
(8673,5110,0)
(308,6692,0)
(6406,6671,0)
(8618,8391,0)
(2143,8837,0)
(336,7182,0)
(6733,9077,0)
(4375,4350,0)
(2280,9048,0)
(7285,4567,0)
(7608,3147,0)
(808,7856,0)
(5193,711,0)
(2842,5854,0)
(3876,8391,0)
(6160,7965,0)
(840,829,0)
(3643,7031,0)
(786,6660,0)
(8903,3031,0)
(3362,6577,0)
(6097,6179,0)
(8811,115,0)
(1823,4028,0)
(3389,6354,0)
(3056,8561,0)
(2034,3435,0)
(6169,7116,0)
(7846,5844,0)
(8413,5683,0)
(6094,5757,0)
(8593,7163,0)
(8850,207,0)
(1010,7489,0)
(870,499,0)
(1878,2845,0)
(1907,8874,0)
(1242,3543,0)
(5914,5829,0)
(8479,3834,0)
(2287,929,0)
(972,1231,0)
(6902,8866,0)
(118,4284,0)
(407,7104,0)
(1647,7983,0)
(5595,6854,0)
(7866,1029,0)
(6360,1956,0)
(5349,5829,0)
(6191,4176,0)
(5428,2043,0)
(3904,1705,0)
(4921,2422,0)
(8827,1149,0)
(6608,5779,0)
(8263,7356,0)
(94,5491,0)
(3873,523,0)
(1381,8475,0)
(6366,6488,0)
(7003,7199,0)
(4587,4053,0)
(4320,4,0)
(3829,8985,0)
(1750,3837,0)
(6111,2845,0)
(3762,6521,0)
(7107,6748,0)
(4600,5906,0)
(6563,6237,0)
(1303,3223,0)
(480,5919,0)
(2912,6545,0)
(6742,5887,0)
(1027,7553,0)
(3996,1329,0)
(5573,6154,0)
(89,665,0)
(4560,8535,0)
(2180,1039,0)
(3021,161,0)
(2872,7067,0)
(5017,2459,0)
(8824,377,0)
(4790,9043,0)
(4012,115,0)
(5434,7363,0)
(2195,3636,0)
(3195,1672,0)
(5172,3612,0)
(7558,1924,0)
(7004,177,0)
(8200,115,0)
(8038,1270,0)
(3902,7016,0)
(2168,7180,0)
(358,4556,0)
(3356,6226,0)
(3290,2157,0)
(2283,4783,0)
(6451,8391,0)
(4177,7316,0)
(2670,8249,0)
(1190,865,0)
(5210,901,0)
(7991,1204,0)
(2287,8441,0)
(7176,8391,0)
(6846,8695,0)
(7827,5545,0)
(8369,4976,0)
(1228,8694,0)
(6513,2189,0)
(4265,5913,0)
(8031,8391,0)
(8408,7586,0)
(2721,8354,0)
(2780,5881,0)
(8387,4292,0)
(9034,5871,0)
(4386,3597,0)
(3209,4555,0)
(2007,5977,0)
(7159,3451,0)
(4132,4468,0)
(1679,4704,0)
(3539,115,0)
(3830,6187,0)
(360,4579,0)
(1922,4924,0)
(5970,6803,0)
(4116,2804,0)
(6259,7950,0)
(8529,8789,0)
(3810,6957,0)
(8108,5914,0)
(1952,2147,0)
(2174,4162,0)
(107,3425,0)
(7073,3640,0)
(6028,1600,0)
(5212,4024,0)
(375,3773,0)
(1516,8598,0)
(6288,5785,0)
(576,4840,0)
(5308,5893,0)
(7349,8391,0)
(512,8959,0)
(1683,9090,0)
(659,3078,0)
(1905,7100,0)
(3908,8201,0)
(4806,3620,0)
(6594,9127,0)
(4610,6821,0)
(7057,8391,0)
(7455,7075,0)
(982,2578,0)
(8293,505,0)
(206,4023,0)
(557,6234,0)
(5178,437,0)
(4028,1488,0)
(473,7995,0)
(8709,115,0)
(5331,5562,0)
(7283,8391,0)
(4152,8715,0)
(4586,7405,0)
(3347,115,0)
(1203,5829,0)
(5494,700,0)
(4033,7349,0)
(8002,4626,0)
(4469,3101,0)
(1721,4182,0)
(6783,2580,0)
(609,778,0)
(7120,873,0)
(2741,6097,0)
(6952,1247,0)
(580,7575,0)
(514,115,0)
(4155,115,0)
(3804,7280,0)
(4595,4846,0)
(4491,1418,0)
(1415,8458,0)
(7536,115,0)
(1403,5605,0)
(5638,2617,0)
(513,4819,0)
(5454,1876,0)
(3119,115,0)
(4243,6446,0)
(3638,3012,0)
(6473,5358,0)
(2868,7210,0)
(8651,3735,0)
(3058,1666,0)
(4919,8658,0)
(8802,8391,0)
(8412,4429,0)
(3041,376,0)
(1889,7938,0)
(1511,3758,0)
(2074,7480,0)
(4830,1225,0)
(4858,6993,0)
(8431,1394,0)
(8078,505,0)
(1751,7950,0)
(1857,4876,0)
(5370,1427,0)
(3036,6891,0)
(6375,5706,0)
(5720,594,0)
(56,4079,0)
(7830,277,0)
(1505,7675,0)
(7833,2043,0)
(4143,6111,0)
(675,1435,0)
(1357,5227,0)
(7931,1418,0)
(2803,3268,0)
(1686,4828,0)
(2111,2350,0)
(1043,584,0)
(136,1432,0)
(7104,3858,0)
(9128,4915,0)
(6771,8391,0)
(6541,4919,0)
(2029,7710,0)
(2367,1509,0)
(8030,1149,0)
(745,4389,0)
(515,2254,0)
(8295,2845,0)
(1469,4521,0)
(8056,3384,0)
(5474,5229,0)
(2938,8391,0)
(7303,4880,0)
(6698,5168,0)
(9090,2845,0)
(4375,4515,0)
(7677,8288,0)
(3049,3828,0)
(4772,2052,0)
(5825,3051,0)
(8279,4014,0)
(7136,4497,0)
(2823,115,0)
(4871,8909,0)
(8912,8139,0)
(4909,8844,0)
(1413,115,0)
(9073,8391,0)
(2044,7408,0)
(1916,3150,0)
(6142,1324,0)
(5796,8098,0)
(477,2845,0)
(6317,2358,0)
(8494,2501,0)
(1641,2808,0)
(2977,8648,0)
(8373,2539,0)
(1249,8293,0)
(2796,4506,0)
(4505,6919,0)
(4461,1077,0)
(5214,3889,0)
(3897,4069,0)
(4375,8021,0)
(5862,2297,0)
(5548,3266,0)
(2339,6425,0)
(6827,2845,0)
(3,6091,0)
(2885,5748,0)
(2238,1471,0)
(6688,4619,0)
(592,8391,0)
(8158,6397,0)
(7812,3451,0)
(1415,3215,0)
(7034,3354,0)
(300,7793,0)
(573,9088,0)
(866,2817,0)
(9123,1924,0)
(1923,920,0)
(6656,115,0)
(2236,909,0)
(6765,8105,0)
(6800,2399,0)
(5151,3810,0)
(3639,7191,0)
(6400,6209,0)
(2666,3303,0)
(2057,1189,0)
(4194,2368,0)
(7176,6671,0)
(7393,2421,0)
(2287,3565,0)
(3569,6132,0)
(8178,339,0)
(7799,1149,0)
(180,8111,0)
(7725,8614,0)
(5890,6407,0)
(2256,2502,0)
(3958,5887,0)
(3286,7396,0)
(1670,2845,0)
(3419,6246,0)
(288,9067,0)
(1843,115,0)
(5489,6333,0)
(3296,177,0)
(6326,4357,0)
(4996,8866,0)
(1718,5887,0)
(4053,7680,0)
(5494,8458,0)
(6868,8109,0)
(7519,3114,0)
(6533,4000,0)
(5491,4359,0)
(875,5124,0)
(3974,6998,0)
(8980,4619,0)
(3475,1907,0)
(2563,4119,0)
(5241,5094,0)
(4451,8355,0)
(7764,6797,0)
(5881,3863,0)
(1601,115,0)
(6341,8391,0)
(1038,5074,0)
(2690,7579,0)
(2890,413,0)
(7612,6671,0)
(7620,8637,0)
(4719,8509,0)
(5164,2845,0)
(3526,8391,0)
(6034,4942,0)
(1254,3769,0)
(3147,2782,0)
(1070,4429,0)
(4966,9110,0)
(2804,4116,0)
(994,7444,0)
(6524,698,0)
(3792,8698,0)
(4831,8623,0)
(6608,8391,0)
(1435,675,0)
(4488,4673,0)
(5612,2052,0)
(6545,1788,0)
(1134,2342,0)
(2814,8391,0)
(3726,8029,0)
(7578,115,0)
(8410,4072,0)
(6616,6671,0)
(351,6919,0)
(2335,520,0)
(2061,7929,0)
(2612,5394,0)
(6536,6454,0)
(3649,2158,0)
(876,5795,0)
(2978,115,0)
(8172,2782,0)
(8215,1954,0)
(7168,5726,0)
(985,2687,0)
(6973,115,0)
(6560,1488,0)
(4900,7923,0)
(9066,1045,0)
(3164,4515,0)
(2757,413,0)
(1419,5408,0)
(130,7743,0)
(8627,379,0)
(5221,2250,0)
(6815,8158,0)
(3613,8928,0)
(5077,588,0)
(1304,2004,0)
(113,8531,0)
(3699,115,0)
(1527,6355,0)
(4628,4053,0)
(3782,1369,0)
(4063,4012,0)
(8110,2043,0)
(4001,4912,0)
(6851,6150,0)
(1633,103,0)
(5876,8445,0)
(7349,2920,0)
(6770,2317,0)
(51,1488,0)
(3254,115,0)
(3731,4301,0)
(467,1764,0)
(6007,3501,0)
(6218,3740,0)
(7063,115,0)
(9022,5988,0)
(7245,6038,0)
(3453,1042,0)
(4615,2729,0)
(2751,8361,0)
(8546,4673,0)
(4850,2794,0)
(8326,9028,0)
(6389,1212,0)
(4201,8517,0)
(3506,3055,0)
(1777,8193,0)
(6739,7548,0)
(741,5512,0)
(3787,4531,0)
(7561,8901,0)
(423,1400,0)
(1793,8328,0)
(2360,289,0)
(3926,2115,0)
(7251,5030,0)
(5137,8535,0)
(7402,3938,0)
(9049,2027,0)
(6198,1875,0)
(3260,8391,0)
(4468,7973,0)
(421,7198,0)
(8602,4850,0)
(2171,8391,0)
(8448,8134,0)
(5769,5776,0)
(295,556,0)
(5575,4765,0)
(8214,3062,0)
(6102,4785,0)
(6050,6577,0)
(4335,5479,0)
(2171,3436,0)
(883,6428,0)
(6162,6671,0)
(2370,4390,0)
(4583,5977,0)
(8532,2003,0)
(3149,3052,0)
(989,8391,0)
(7604,1943,0)
(7019,6348,0)
(6188,4785,0)
(4326,785,0)
(7220,8213,0)
(7941,3727,0)
(3067,8298,0)
(4375,148,0)
(3137,1144,0)
(6429,115,0)
(960,5852,0)
(6653,1938,0)
(5313,3784,0)
(5835,1430,0)
(3026,4452,0)
(3472,5646,0)
(7593,6429,0)
(8434,7366,0)
(3923,8451,0)
(2442,4897,0)
(8047,2859,0)
(6886,1948,0)
(5100,6844,0)
(6958,1602,0)
(7492,4212,0)
(4125,4385,0)
(3606,6907,0)
(4375,2497,0)
(5175,2131,0)
(5911,2539,0)
(355,2774,0)
(9077,8461,0)
(396,3901,0)
(184,6559,0)
(2618,6824,0)
(1121,109,0)
(4115,2227,0)
(3399,8034,0)
(8390,1401,0)
(8251,7143,0)
(3383,5349,0)
(2160,541,0)
(3138,2845,0)
(8810,3828,0)
(6554,698,0)
(2,2060,0)
(3650,4072,0)
(133,966,0)
(7557,9131,0)
(689,1535,0)
(8336,5997,0)
(5584,115,0)
(724,6137,0)
(2849,6671,0)
(4753,8050,0)
(6122,4429,0)
(1190,8654,0)
(278,4785,0)
(835,1289,0)
(2425,6799,0)
(588,5077,0)
(5452,8391,0)
(8083,1062,0)
(2908,3240,0)
(6741,5829,0)
(3679,6555,0)
(1591,3046,0)
(6619,1769,0)
(4609,7176,0)
(1840,8273,0)
(7982,3187,0)
(5597,7921,0)
(4558,921,0)
(7076,5326,0)
(4182,2043,0)
(7938,123,0)
(3573,3936,0)
(3400,3538,0)
(3587,5312,0)
(1212,1149,0)
(6067,8433,0)
(5,8391,0)
(6,4982,0)
(1462,6960,0)
(3647,2303,0)
(2642,1370,0)
(6845,6057,0)
(4749,7711,0)
(7432,8391,0)
(1077,2987,0)
(3247,861,0)
(5991,6897,0)
(7340,7947,0)
(3932,2671,0)
(5705,8391,0)
(8472,6671,0)
(824,1005,0)
(3785,4783,0)
(2217,115,0)
(1906,82,0)
(4617,6964,0)
(3396,7210,0)
(5479,7210,0)
(8593,2921,0)
(1550,8976,0)
(9031,7426,0)
(871,4176,0)
(1952,781,0)
(8893,6847,0)
(5592,7431,0)
(2459,8339,0)
(8148,8391,0)
(5160,8577,0)
(4742,292,0)
(4136,1912,0)
(1054,1911,0)
(1465,8980,0)
(787,7650,0)
(7440,4800,0)
(2579,2817,0)
(7914,3266,0)
(2544,7039,0)
(5252,6026,0)
(8667,1907,0)
(1383,3003,0)
(7406,3303,0)
(1933,6286,0)
(5613,6016,0)
(6555,8391,0)
(3656,925,0)
(2171,115,0)
(6161,4800,0)
(2689,1236,0)
(4572,8388,0)
(1792,2845,0)
(1183,7146,0)
(7889,4434,0)
(6097,2043,0)
(1158,5156,0)
(20,6394,0)
(5517,6671,0)
(1045,8391,0)
(4758,115,0)
(1280,8391,0)
(6713,8391,0)
(4792,6469,0)
(4554,4258,0)
(7444,73,0)
(8544,4646,0)
(4375,6435,0)
(198,1725,0)
(5460,7263,0)
(2777,3752,0)
(9106,1896,0)
(1996,7000,0)
(7373,8391,0)
(4386,6069,0)
(1562,7085,0)
(966,4876,0)
(7427,7549,0)
(918,780,0)
(1126,2456,0)
(681,1875,0)
(2640,6614,0)
(8038,8111,0)
(8707,4802,0)
(1935,164,0)
(3220,5164,0)
(8794,7013,0)
(9139,2943,0)
(6847,794,0)
(3547,8361,0)
(1415,866,0)
(7345,8136,0)
(7926,1086,0)
(8878,8254,0)
(6467,1921,0)
(2619,1407,0)
(5380,5243,0)
(1501,5900,0)
(6278,2303,0)
(2497,9059,0)
(8618,115,0)
(5089,552,0)
(481,7940,0)
(6654,7031,0)
(5788,8585,0)
(6419,4350,0)
(7929,8391,0)
(8059,5538,0)
(1712,5156,0)
(6185,4785,0)
(778,3326,0)
(5991,3075,0)
(8444,8391,0)
(2593,4985,0)
(8428,1448,0)
(4499,2466,0)
(3173,7553,0)
(4949,5117,0)
(7821,7797,0)
(8826,3370,0)
(276,7088,0)
(5096,178,0)
(8027,2126,0)
(5638,3565,0)
(8856,3725,0)
(8746,6577,0)
(6543,8047,0)
(3509,8471,0)
(8538,2093,0)
(3714,8812,0)
(1948,115,0)
(7574,6908,0)
(5413,5345,0)
(4047,3757,0)
(6930,3055,0)
(7156,205,0)
(8925,4490,0)
(669,2476,0)
(4706,8008,0)
(2847,3845,0)
(4205,5950,0)
(7812,9059,0)
(8517,5168,0)
(4375,3657,0)
(7626,3889,0)
(1433,875,0)
(6502,2981,0)
(2674,3102,0)
(2112,115,0)
(880,7306,0)
(8054,2556,0)
(944,1530,0)
(6297,2418,0)
(8845,2104,0)
(367,5499,0)
(8292,5166,0)
(3856,542,0)
(2223,2406,0)
(7543,4161,0)
(6813,1955,0)
(4787,7910,0)
(2740,1017,0)
(6502,3804,0)
(2317,8391,0)
(790,4304,0)
(5478,6223,0)
(3416,8559,0)
(4345,1262,0)
(4404,3740,0)
(8768,7555,0)
(8038,3215,0)
(4127,716,0)
(1399,5981,0)
(1365,8908,0)
(2642,5813,0)
(7879,4942,0)
(2976,3258,0)
(566,6671,0)
(4431,3640,0)
(4253,2303,0)
(3879,6135,0)
(2440,7103,0)
(3158,2763,0)
(7520,4776,0)
(7366,115,0)
(3592,410,0)
(476,7491,0)
(3967,4924,0)
(8524,8248,0)
(8630,2518,0)
(5593,3565,0)
(1339,1454,0)
(1422,5327,0)
(6988,784,0)
(9030,6474,0)
(7375,7211,0)
(3018,1972,0)
(7453,1222,0)
(1135,3460,0)
(7120,115,0)
(1238,115,0)
(3951,4037,0)
(5235,7014,0)
(3509,2112,0)
(5640,8391,0)
(6852,6158,0)
(2226,8226,0)
(6848,3213,0)
(1206,4381,0)
(1853,8391,0)
(952,8391,0)
(8379,79,0)
(3748,2453,0)
(2497,8391,0)
(1619,7781,0)
(292,4742,0)
(1415,8441,0)
(441,5556,0)
(3865,7888,0)
(4224,1488,0)
(6502,5494,0)
(2501,8198,0)
(8677,405,0)
(5135,4299,0)
(6522,8391,0)
(3230,7566,0)
(2746,9043,0)
(4971,6784,0)
(5428,5829,0)
(5,115,0)
(4412,3595,0)
(572,115,0)
(507,163,0)
(4360,5446,0)
(4472,7835,0)
(8282,7909,0)
(4336,1111,0)
(4865,2465,0)
(598,2414,0)
(5214,3565,0)
(8795,8715,0)
(5675,351,0)
(7877,8354,0)
(291,1082,0)
(1531,6730,0)
(3454,4723,0)
(2423,115,0)
(5575,538,0)
(6805,253,0)
(7656,5880,0)
(963,8789,0)
(2346,2342,0)
(4072,115,0)
(3860,8391,0)
(8030,7431,0)
(8837,8391,0)
(1393,3051,0)
(1422,1184,0)
(3499,5693,0)
(2790,4405,0)
(1943,7604,0)
(1110,9021,0)
(6101,6462,0)
(8714,6732,0)
(3877,8391,0)
(1664,6686,0)
(3185,8178,0)
(5368,4343,0)
(8323,7199,0)
(280,9076,0)
(6294,574,0)
(2353,6580,0)
(6638,3050,0)
(9119,115,0)
(5783,862,0)
(2838,7527,0)
(7380,7036,0)
(3664,1149,0)
(5494,7039,0)
(5171,8078,0)
(3425,1274,0)
(3090,1488,0)
(4897,283,0)
(2706,618,0)
(8424,4349,0)
(4205,2347,0)
(7328,5516,0)
(2191,3477,0)
(702,2281,0)
(4618,4426,0)
(4650,2309,0)
(7757,5880,0)
(2224,8418,0)
(8451,1149,0)
(5538,8059,0)
(8859,846,0)
(4961,8811,0)
(4492,6000,0)
(7885,9103,0)
(2290,1121,0)
(8167,712,0)
(3800,2359,0)
(7007,1994,0)
(4380,5811,0)
(4840,3722,0)
(2381,3621,0)
(3804,8471,0)
(1605,8505,0)
(975,2689,0)
(1784,177,0)
(5215,4190,0)
(2603,1826,0)
(7980,6084,0)
(1385,3614,0)
(6610,3111,0)
(5535,739,0)
(4222,2737,0)
(7182,2746,0)
(4630,7591,0)
(6125,115,0)
(924,885,0)
(6087,4739,0)
(1729,8149,0)
(8226,2226,0)
(3791,8391,0)
(3321,8000,0)
(1948,6886,0)
(6289,7821,0)
(44,1922,0)
(6760,5479,0)
(4732,5156,0)
(7499,2845,0)
(1150,2452,0)
(4935,1326,0)
(4000,6533,0)
(1876,5454,0)
(5129,2869,0)
(346,1326,0)
(2844,5501,0)
(3225,3493,0)
(7942,670,0)
(5722,1853,0)
(1928,1524,0)
(2596,3637,0)
(339,8391,0)
(2850,7486,0)
(2718,6414,0)
(7410,5530,0)
(5670,1725,0)
(3127,7090,0)
(6628,1947,0)
(3177,387,0)
(5864,4002,0)
(5484,7187,0)
(3305,6347,0)
(8900,3719,0)
(4189,8391,0)
(577,2043,0)
(247,1367,0)
(2484,4847,0)
(3620,3583,0)
(3577,2316,0)
(19,3291,0)
(3604,3938,0)
(1341,7500,0)
(5628,8277,0)
(3629,9029,0)
(6515,2842,0)
(7365,6545,0)
(3089,1435,0)
(7063,3299,0)
(1895,3526,0)
(402,8074,0)
(6910,6518,0)
(1317,5309,0)
(8457,8281,0)
(6722,7852,0)
(7764,115,0)
(2628,6525,0)
(4749,8391,0)
(8435,1149,0)
(7103,2440,0)
(2812,4105,0)
(6686,8391,0)
(4587,2931,0)
(8447,5848,0)
(2242,7979,0)
(6880,4057,0)
(5329,6252,0)
(2241,5595,0)
(1335,3860,0)
(5122,7113,0)
(4953,2410,0)
(1415,3747,0)
(8930,4785,0)
(706,7577,0)
(3621,2112,0)
(4613,4785,0)
(2728,6405,0)
(2586,4859,0)
(1997,590,0)
(6114,7869,0)
(7373,115,0)
(8611,4672,0)
(4007,8061,0)
(3438,1505,0)
(607,4784,0)
(1631,1813,0)
(2907,6838,0)
(5442,1956,0)
(4054,774,0)
(572,1992,0)
(15,3469,0)
(533,7287,0)
(6676,1177,0)
(617,2845,0)
(2129,822,0)
(7414,6671,0)
(6493,7671,0)
(3764,8925,0)
(4311,5515,0)
(3797,7858,0)
(3219,2651,0)
(7369,5797,0)
(2224,8162,0)
(5242,2626,0)
(5397,5665,0)
(8654,5358,0)
(7180,4289,0)
(8676,2285,0)
(7218,7127,0)
(781,5474,0)
(7542,2069,0)
(191,1908,0)
(1907,8667,0)
(862,3451,0)
(8230,8319,0)
(7510,115,0)
(7102,822,0)
(878,6091,0)
(8453,4763,0)
(7441,1149,0)
(7631,3834,0)
(7075,8391,0)
(8130,8877,0)
(5328,697,0)
(2287,7625,0)
(1581,4350,0)
(1061,2845,0)
(1248,6734,0)
(3233,6141,0)
(2092,2526,0)
(7816,6611,0)
(2429,7159,0)
(4928,2917,0)
(7832,3236,0)
(8694,739,0)
(6972,6979,0)
(4599,8259,0)
(7346,5689,0)
(3792,9124,0)
(8508,391,0)
(6487,3300,0)
(8073,9106,0)
(7847,8391,0)
(6502,6284,0)
(1826,4890,0)
(3716,4620,0)
(2287,8471,0)
(8102,3171,0)
(4344,4610,0)
(644,6950,0)
(8316,7083,0)
(5182,4883,0)
(2123,4720,0)
(7212,6471,0)
(1667,3370,0)
(281,5954,0)
(1167,115,0)
(3388,7161,0)
(8115,5117,0)
(8694,7129,0)
(5326,3818,0)
(6865,8391,0)
(8577,85,0)
(5942,3589,0)
(3823,1298,0)
(1376,3902,0)
(6022,2181,0)
(592,4820,0)
(2257,5847,0)
(1753,724,0)
(7796,1785,0)
(45,115,0)
(6423,5074,0)
(2614,7890,0)
(6758,2315,0)
(1972,6431,0)
(2457,115,0)
(3786,8391,0)
(2948,8126,0)
(5473,5324,0)
(5594,4932,0)
(1387,8391,0)
(6976,5486,0)
(1016,347,0)
(4158,8699,0)
(536,5294,0)
(2745,6318,0)
(1892,3403,0)
(4496,46,0)
(5142,4883,0)
(6842,1265,0)
(8650,3509,0)
(3991,5937,0)
(4164,8311,0)
(189,7057,0)
(3743,8341,0)
(4722,3619,0)
(9106,115,0)
(5076,2654,0)
(3035,8247,0)
(305,1679,0)
(9011,3673,0)
(9045,7698,0)
(2815,4583,0)
(4740,8941,0)
(1129,7858,0)
(2572,4084,0)
(7210,4785,0)
(2673,8757,0)
(6054,8391,0)
(4510,5775,0)
(5079,4008,0)
(5168,925,0)
(3234,169,0)
(8047,7158,0)
(6304,1632,0)
(3291,5033,0)
(9025,402,0)
(6993,4522,0)
(5693,8738,0)
(7710,115,0)
(3103,409,0)
(98,6366,0)
(1744,1530,0)
(8035,4876,0)
(6502,7626,0)
(5211,8164,0)
(4611,6265,0)
(6394,20,0)
(1774,9039,0)
(2948,3632,0)
(3051,860,0)
(8358,7646,0)
(2927,5580,0)
(7626,1270,0)
(8260,1509,0)
(2679,347,0)
(4873,9130,0)
(756,1110,0)
(8815,6821,0)
(6020,4413,0)
(5710,8802,0)
(8966,4366,0)
(1186,2263,0)
(2183,299,0)
(8496,8391,0)
(4938,2288,0)
(28,5744,0)
(2433,4818,0)
(2655,4606,0)
(4450,466,0)
(6255,4884,0)
(5991,6475,0)
(838,5058,0)
(7344,1206,0)
(8980,6181,0)
(6715,4464,0)
(1415,3518,0)
(5164,8205,0)
(7413,8610,0)
(1724,338,0)
(7244,4994,0)
(262,149,0)
(1771,4732,0)
(1560,7657,0)
(4556,2947,0)
(1415,6563,0)
(2677,115,0)
(1592,633,0)
(3059,2951,0)
(3882,6357,0)
(5681,5331,0)
(3214,115,0)
(2295,1013,0)
(8819,7433,0)
(7097,3271,0)
(7251,115,0)
(2291,5489,0)
(8727,8865,0)
(7251,8391,0)
(1121,836,0)
(3126,353,0)
(815,4222,0)
(4151,1108,0)
(3483,4876,0)
(1054,8391,0)
(5282,6625,0)
(2161,3103,0)
(3280,2473,0)
(1522,8884,0)
(4215,7159,0)
(2297,7711,0)
(7040,6536,0)
(7537,6846,0)
(4767,8099,0)
(3385,8501,0)
(6124,7622,0)
(9113,8400,0)
(8152,7883,0)
(8568,1216,0)
(1164,2983,0)
(506,2565,0)
(991,7152,0)
(5107,115,0)
(1051,6671,0)
(6475,5991,0)
(8122,45,0)
(4920,2518,0)
(3295,6758,0)
(6446,538,0)
(5134,4346,0)
(2551,6520,0)
(5391,2158,0)
(5589,7646,0)
(6741,462,0)
(99,7819,0)
(1340,2821,0)
(7611,4307,0)
(1728,7105,0)
(8836,1326,0)
(5785,6288,0)
(396,1575,0)
(2447,6424,0)
(6046,848,0)
(5692,6671,0)
(3685,5926,0)
(4426,115,0)
(2833,779,0)
(5193,8391,0)
(784,1411,0)
(7616,2533,0)
(4,8683,0)
(4650,8391,0)
(7186,5898,0)
(5369,2845,0)
(1029,7711,0)
(4339,1664,0)
(190,8857,0)
(4372,3879,0)
(8549,4837,0)
(2714,6496,0)
(1020,4506,0)
(8117,1149,0)
(6224,1788,0)
(6549,1555,0)
(1111,8391,0)
(5974,1225,0)
(3183,1217,0)
(239,5362,0)
(2468,3934,0)
(5003,54,0)
(3002,8501,0)
(7571,115,0)
(8618,6737,0)
(530,5269,0)
(5052,4154,0)
(3901,5926,0)
(8453,4882,0)
(4562,177,0)
(8180,5825,0)
(122,8738,0)
(2582,4391,0)
(7831,4580,0)
(463,115,0)
(5887,8677,0)
(5712,3859,0)
(6904,8957,0)
(1187,3874,0)
(5513,1834,0)
(7342,3722,0)
(80,2295,0)
(8149,1729,0)
(2295,6995,0)
(8415,8276,0)
(3583,3620,0)
(1065,8391,0)
(5514,4148,0)
(2134,2618,0)
(8897,3968,0)
(4303,3380,0)
(1392,8391,0)
(3735,3722,0)
(5878,386,0)
(8965,5371,0)
(4840,3451,0)
(7435,1340,0)
(3471,4965,0)
(7038,8391,0)
(1024,8580,0)
(6973,7389,0)
(3844,1116,0)
(4582,5003,0)
(4472,5156,0)
(2383,1296,0)
(6462,2690,0)
(6201,6838,0)
(1937,115,0)
(8379,5156,0)
(3422,6640,0)
(8664,8427,0)
(387,1108,0)
(3865,2303,0)
(7238,4785,0)
(7255,8849,0)
(1370,7892,0)
(780,918,0)
(2336,9013,0)
(8041,555,0)
(190,5906,0)
(900,5556,0)
(6734,8391,0)
(3154,7792,0)
(7114,1153,0)
(5123,5721,0)
(1913,3431,0)
(1800,6671,0)
(4921,8883,0)
(4624,8891,0)
(147,4352,0)
(2167,8391,0)
(4375,4785,0)
(3414,6442,0)
(8241,5836,0)
(1204,469,0)
(781,1952,0)
(2403,6417,0)
(5074,6423,0)
(3204,3772,0)
(4424,8777,0)
(6921,4057,0)
(6481,7546,0)
(4270,6784,0)
(2169,8899,0)
(1455,7497,0)
(2553,331,0)
(1508,3565,0)
(3193,6154,0)
(4591,909,0)
(5069,6995,0)
(6010,1813,0)
(1820,6671,0)
(2170,5420,0)
(2758,4108,0)
(6545,1925,0)
(1330,6671,0)
(3666,3808,0)
(5437,3236,0)
(4318,7525,0)
(3268,8391,0)
(9127,6440,0)
(6216,8043,0)
(3821,3401,0)
(1591,7716,0)
(4524,3875,0)
(1064,4759,0)
(2201,1165,0)
(3632,82,0)
(8216,5227,0)
(7613,2152,0)
(405,8677,0)
(3948,5645,0)
(5002,7253,0)
(6726,4876,0)
(3804,8441,0)
(5541,8713,0)
(2316,2044,0)
(718,6156,0)
(1169,4805,0)
(3833,8572,0)
(6293,977,0)
(2157,8391,0)
(7626,6968,0)
(3796,595,0)
(7003,4734,0)
(719,115,0)
(5494,9130,0)
(2078,5750,0)
(981,6530,0)
(2475,115,0)
(2146,2612,0)
(5419,8391,0)
(5014,7924,0)
(7692,8256,0)
(4747,4593,0)
(5269,2069,0)
(5824,5679,0)
(3348,539,0)
(6419,4587,0)
(2867,8173,0)
(5155,340,0)
(2343,2688,0)
(712,4237,0)
(2737,4222,0)
(2069,5269,0)
(3058,7260,0)
(2116,4536,0)
(3411,7373,0)
(2929,9110,0)
(4370,7268,0)
(7823,6671,0)
(4375,4449,0)
(3163,5887,0)
(7270,8258,0)
(7223,226,0)
(8429,4353,0)
(3435,2034,0)
(5795,876,0)
(7042,8204,0)
(8538,91,0)
(574,7200,0)
(13,4006,0)
(5952,2774,0)
(7796,6151,0)
(4650,6084,0)
(3933,676,0)
(4861,4184,0)
(847,7498,0)
(4810,6077,0)
(916,6279,0)
(7065,6518,0)
(2424,8391,0)
(6684,5669,0)
(4793,1410,0)
(9115,6719,0)
(1305,6458,0)
(8521,5069,0)
(2287,5452,0)
(231,3791,0)
(8048,7511,0)
(6370,7777,0)
(8764,8910,0)
(7901,2931,0)
(3213,2112,0)
(7056,115,0)
(3745,5056,0)
(5320,4500,0)
(7721,5869,0)
(7308,7491,0)
(3637,9007,0)
(5875,7812,0)
(9039,8578,0)
(5913,5332,0)
(1101,1286,0)
(5560,7535,0)
(6195,2139,0)
(4333,1217,0)
(7641,6289,0)
(1932,3556,0)
(3150,1916,0)
(7581,391,0)
(1920,5,0)
(6425,2339,0)
(7209,8432,0)
(735,1907,0)
(4028,7299,0)
(8849,6156,0)
(4824,2092,0)
(6062,2117,0)
(4354,4828,0)
(9008,4917,0)
(1118,1742,0)
(4199,4319,0)
(1297,4029,0)
(4494,8167,0)
(3008,4382,0)
(3938,3604,0)
(5475,334,0)
(5636,5499,0)
(8950,4198,0)
(6177,1126,0)
(1769,8454,0)
(6457,2879,0)
(5719,115,0)
(4966,2729,0)
(9048,4342,0)
(8971,5705,0)
(174,768,0)
(4375,5366,0)
(6397,115,0)
(8038,4350,0)
(2575,1387,0)
(2749,3493,0)
(6993,3983,0)
(658,514,0)
(2016,2862,0)
(4601,6451,0)
(3692,4553,0)
(561,8728,0)
(4046,6694,0)
(4277,4876,0)
(6854,5595,0)
(7805,5946,0)
(1052,8391,0)
(2451,4812,0)
(8922,6317,0)
(1853,5722,0)
(1184,8994,0)
(8063,7785,0)
(6382,8360,0)
(1722,6671,0)
(5852,514,0)
(4540,1955,0)
(2892,2069,0)
(617,115,0)
(2060,2,0)
(2440,6001,0)
(1724,7211,0)
(6202,4697,0)
(434,6726,0)
(8679,8242,0)
(4319,2002,0)
(5638,8111,0)
(8594,1149,0)
(4582,5566,0)
(2685,4616,0)
(5519,115,0)
(4737,6671,0)
(4898,3539,0)
(3086,7013,0)
(5971,5537,0)
(7576,9,0)
(7651,6561,0)
(156,2174,0)
(8662,4581,0)
(4012,1491,0)
(5539,8978,0)
(5111,6671,0)
(381,7168,0)
(3668,4452,0)
(6403,6935,0)
(1428,2118,0)
(4466,115,0)
(5547,3055,0)
(2013,473,0)
(5019,6216,0)
(3545,3224,0)
(4575,704,0)
(8324,7847,0)
(3407,8666,0)
(4389,7545,0)
(241,1641,0)
(4495,6364,0)
(3814,4641,0)
(1172,2128,0)
(4277,2717,0)
(5426,4380,0)
(2354,6002,0)
(4112,2475,0)
(4253,2858,0)
(3694,980,0)
(7875,8400,0)
(37,7974,0)
(4181,3214,0)
(1349,2628,0)
(3060,6537,0)
(2848,4873,0)
(578,8391,0)
(2279,1241,0)
(6135,3879,0)
(4718,3055,0)
(512,2089,0)
(4773,115,0)
(3593,4371,0)
(8099,5968,0)
(77,8452,0)
(2475,8391,0)
(1762,6671,0)
(5323,2092,0)
(6252,4772,0)
(5467,1369,0)
(6367,8523,0)
(2514,4089,0)
(152,8624,0)
(4921,4150,0)
(7734,7064,0)
(2384,3457,0)
(3638,6273,0)
(8747,1173,0)
(8361,6671,0)
(102,5604,0)
(442,7716,0)
(8301,5371,0)
(1107,8510,0)
(2468,115,0)
(2906,3984,0)
(5900,3480,0)
(3513,8488,0)
(3846,6609,0)
(2164,519,0)
(1752,7972,0)
(474,1266,0)
(4453,5614,0)
(5400,2410,0)
(8997,7422,0)
(7463,5887,0)
(7367,115,0)
(6119,651,0)
(6480,3594,0)
(1435,3271,0)
(7465,5922,0)
(2050,6443,0)
(1415,3461,0)
(4272,2058,0)
(8005,1435,0)
(8742,115,0)
(3214,2608,0)
(3288,7088,0)
(572,8391,0)
(6851,5564,0)
(1047,115,0)
(9077,3098,0)
(3972,8531,0)
(4379,682,0)
(2489,3699,0)
(6203,8162,0)
(2155,9007,0)
(794,4136,0)
(4497,8391,0)
(1848,8391,0)
(3330,6744,0)
(8730,6286,0)
(16,811,0)
(3492,2456,0)
(2319,4116,0)
(729,4785,0)
(3571,8391,0)
(4451,6449,0)
(3043,115,0)
(3221,3518,0)
(7051,345,0)
(8489,1943,0)
(4375,6471,0)
(8293,6849,0)
(1954,7079,0)
(2504,5647,0)
(6452,994,0)
(7094,6977,0)
(6576,8571,0)
(3985,252,0)
(213,3003,0)
(2720,3733,0)
(4709,3825,0)
(5494,8111,0)
(403,2229,0)
(8654,1190,0)
(7419,8736,0)
(1962,7979,0)
(980,8213,0)
(3327,4378,0)
(6478,5683,0)
(2852,4954,0)
(4742,5156,0)
(20,7088,0)
(89,6577,0)
(6038,8391,0)
(5688,1048,0)
(3594,7711,0)
(2668,7272,0)
(8511,8155,0)
(6821,4604,0)
(4176,871,0)
(1060,5550,0)
(2840,6237,0)
(3804,3565,0)
(1209,7572,0)
(2580,3440,0)
(6007,2087,0)
(3594,8391,0)
(1069,1825,0)
(7407,1706,0)
(3657,6077,0)
(627,2449,0)
(7972,5950,0)
(4213,4785,0)
(2163,4897,0)
(6437,6620,0)
(1322,115,0)
(2731,5805,0)
(1978,1794,0)
(257,7294,0)
(5345,8391,0)
(3806,387,0)
(1460,7004,0)
(9128,4704,0)
(8166,4232,0)
(2708,274,0)
(8815,155,0)
(6121,4423,0)
(2160,8391,0)
(8771,5298,0)
(8931,1041,0)
(542,2211,0)
(8659,8136,0)
(2454,1319,0)
(2864,6384,0)
(2996,1810,0)
(4745,7238,0)
(6715,8391,0)
(2457,8391,0)
(8017,5510,0)
(7468,3810,0)
(2104,8845,0)
(5854,4249,0)
(4332,8609,0)
(8549,4064,0)
(8142,3983,0)
(2401,8672,0)
(6910,2830,0)
(5011,4739,0)
(1176,1567,0)
(4614,3878,0)
(4068,584,0)
(5369,115,0)
(7233,4945,0)
(2730,3866,0)
(7984,8391,0)
(3043,4687,0)
(7071,4875,0)
(492,6056,0)
(6341,115,0)
(2928,5431,0)
(7586,8552,0)
(8945,3266,0)
(8927,3153,0)
(8169,6797,0)
(4558,7149,0)
(4417,8391,0)
(7281,4544,0)
(2901,3153,0)
(100,8989,0)
(3172,1026,0)
(5898,1488,0)
(519,2164,0)
(1988,4847,0)
(1818,3183,0)
(6830,1117,0)
(7996,1209,0)
(5851,6187,0)
(2139,8391,0)
(7138,6500,0)
(6278,732,0)
(1660,2112,0)
(1959,5851,0)
(2220,3831,0)
(1991,2827,0)
(1342,3257,0)
(1370,2642,0)
(3352,8960,0)
(5897,2831,0)
(6625,5282,0)
(6159,4620,0)
(3962,1411,0)
(5374,1471,0)
(7105,208,0)
(5871,9034,0)
(1938,539,0)
(3504,1246,0)
(7844,5335,0)
(8029,1611,0)
(7066,1891,0)
(2544,4587,0)
(6047,7791,0)
(4239,5975,0)
(1015,9017,0)
(2160,115,0)
(6159,8391,0)
(1376,8259,0)
(9106,8391,0)
(838,7363,0)
(1542,115,0)
(4462,1013,0)
(6452,8793,0)
(3145,8756,0)
(1324,807,0)
(5776,5855,0)
(3831,8786,0)
(5502,4282,0)
(983,5486,0)
(6832,7045,0)
(6625,8237,0)
(2035,3493,0)
(5124,875,0)
(3660,8695,0)
(4781,8928,0)
(8157,4644,0)
(5276,412,0)
(6904,5632,0)
(7775,115,0)
(8708,4362,0)
(8863,1410,0)
(6771,6289,0)
(8233,7962,0)
(3901,396,0)
(2828,529,0)
(502,2894,0)
(3451,8322,0)
(1638,7038,0)
(257,1705,0)
(2342,1134,0)
(678,4963,0)
(5644,6469,0)
(5779,6608,0)
(5851,3680,0)
(2089,512,0)
(6726,7216,0)
(4942,8391,0)
(5206,7656,0)
(7373,2845,0)
(5772,5375,0)
(3513,4822,0)
(6842,6424,0)
(2449,8883,0)
(6181,8980,0)
(7512,4327,0)
(1944,2804,0)
(8724,6671,0)
(1797,2498,0)
(6808,8677,0)
(6086,660,0)
(6847,5903,0)
(4803,3360,0)
(2124,2141,0)
(7137,3849,0)
(737,3203,0)
(713,8386,0)
(1684,67,0)
(4732,4876,0)
(5736,7968,0)
(2936,4574,0)
(204,6367,0)
(1121,3636,0)
(6935,115,0)
(6202,2683,0)
(2287,1405,0)
(208,7105,0)
(6910,1379,0)
(8556,7519,0)
(435,122,0)
(6851,2879,0)
(8141,6985,0)
(7925,7016,0)
(6141,1149,0)
(2146,2847,0)
(8885,8418,0)
(6725,1916,0)
(5561,2147,0)
(8784,8164,0)
(7982,8391,0)
(2658,7374,0)
(687,3545,0)
(3795,7337,0)
(8726,8660,0)
(9088,573,0)
(267,6649,0)
(7969,4190,0)
(4743,2481,0)
(2302,4366,0)
(6883,5757,0)
(7996,8246,0)
(2966,8836,0)
(5845,6723,0)
(4784,607,0)
(959,3808,0)
(8421,115,0)
(2543,1158,0)
(5129,1449,0)
(5748,115,0)
(7626,8458,0)
(1225,7680,0)
(1200,781,0)
(3141,3999,0)
(1269,3184,0)
(5005,6671,0)
(4647,8391,0)
(4531,4117,0)
(2750,3417,0)
(6600,1488,0)
(3783,8746,0)
(1415,502,0)
(3403,1892,0)
(8439,4441,0)
(7100,1905,0)
(2701,4798,0)
(4128,3648,0)
(4295,2314,0)
(3579,8854,0)
(8821,2212,0)
(82,1906,0)
(5836,8241,0)
(3274,4992,0)
(4483,6022,0)
(2055,3119,0)
(5652,7046,0)
(8691,3661,0)
(3741,6137,0)
(7535,1168,0)
(7895,7182,0)
(4579,360,0)
(8623,2904,0)
(2272,2023,0)
(796,697,0)
(7053,9013,0)
(585,4625,0)
(7868,7587,0)
(5494,4587,0)
(6056,1413,0)
(6284,8458,0)
(155,8815,0)
(1415,6710,0)
(4375,4149,0)
(5684,6150,0)
(4490,8925,0)
(6059,5107,0)
(8970,2843,0)
(3544,3006,0)
(8877,8130,0)
(6753,868,0)
(7566,8391,0)
(1145,1047,0)
(6155,6630,0)
(1621,6150,0)
(2978,2667,0)
(2344,4308,0)
(5047,8070,0)
(5494,556,0)
(6807,711,0)
(4847,2845,0)
(7035,3379,0)
(6624,7380,0)
(372,584,0)
(2935,5960,0)
(6731,6003,0)
(7955,4467,0)
(9076,6827,0)
(4299,4980,0)
(3545,8391,0)
(6111,8908,0)
(2731,4053,0)
(5868,5237,0)
(4375,1405,0)
(514,2845,0)
(3624,9036,0)
(8993,8843,0)
(2460,7198,0)
(1091,5952,0)
(2287,4587,0)
(1140,5119,0)
(2317,2845,0)
(3387,4382,0)
(236,1947,0)
(3035,6597,0)
(237,5894,0)
(3785,8391,0)
(795,115,0)
(8247,3035,0)
(3367,3292,0)
(6756,85,0)
(8726,8874,0)
(3981,6041,0)
(1597,169,0)
(3701,8673,0)
(2555,7888,0)
(4066,8844,0)
(898,7366,0)
(4958,5461,0)
(6656,7340,0)
(3729,682,0)
(7626,4515,0)
(1665,924,0)
(8862,4818,0)
(515,6523,0)
(4219,5156,0)
(8046,3260,0)
(2455,5961,0)
(2321,8936,0)
(7398,115,0)
(1612,8391,0)
(8790,7553,0)
(8969,9133,0)
(1814,5030,0)
(8273,5660,0)
(2507,330,0)
(1007,478,0)
(5650,753,0)
(2293,115,0)
(7610,4307,0)
(66,4861,0)
(1692,1366,0)
(4304,1148,0)
(1702,7094,0)
(1199,3814,0)
(5158,8335,0)
(6414,4820,0)
(344,2988,0)
(3903,7038,0)
(3725,8856,0)
(7679,5690,0)
(8824,4189,0)
(3054,5166,0)
(8836,2966,0)
(8461,1149,0)
(6419,4515,0)
(4601,7253,0)
(1424,8588,0)
(6003,6505,0)
(3696,1524,0)
(6354,8751,0)
(1591,636,0)
(5214,1158,0)
(3459,2388,0)
(8916,7716,0)
(3344,8913,0)
(7686,2265,0)
(754,4746,0)
(5301,6359,0)
(3837,7711,0)
(8031,5870,0)
(7404,911,0)
(8460,7167,0)
(1727,8598,0)
(7643,8588,0)
(3804,3215,0)
(8425,6699,0)
(4510,8061,0)
(277,7830,0)
(7014,1766,0)
(3031,777,0)
(2805,8478,0)
(3366,2627,0)
(9010,2789,0)
(2138,6246,0)
(2422,5961,0)
(4467,9001,0)
(3198,6998,0)
(7392,2299,0)
(2797,507,0)
(7461,874,0)
(2927,121,0)
(3347,11,0)
(2042,4,0)
(7074,8444,0)
(7184,6897,0)
(1777,1551,0)
(4179,358,0)
(5462,6880,0)
(1648,150,0)
(4726,1800,0)
(2086,4435,0)
(5740,5932,0)
(176,7832,0)
(4219,4876,0)
(4403,5156,0)
(7096,2166,0)
(7723,2384,0)
(2035,333,0)
(4301,3731,0)
(6378,115,0)
(1299,935,0)
(2801,1120,0)
(3852,6886,0)
(1309,3461,0)
(3865,4522,0)
(8702,5156,0)
(4228,6577,0)
(2763,115,0)
(168,4679,0)
(3675,8391,0)
(6663,85,0)
(3304,3597,0)
(8926,8471,0)
(923,6054,0)
(5,2056,0)
(4056,6681,0)
(8677,4785,0)
(3402,3035,0)
(1727,2845,0)
(7418,5250,0)
(1224,2074,0)
(7200,574,0)
(1754,3621,0)
(1213,8391,0)
(2700,2978,0)
(2910,6671,0)
(6608,115,0)
(3964,3580,0)
(1507,5386,0)
(7039,2043,0)
(8927,8176,0)
(6069,5512,0)
(3213,3565,0)
(7892,1633,0)
(3843,158,0)
(5516,5533,0)
(8106,371,0)
(8594,1312,0)
(5913,3973,0)
(3078,115,0)
(1454,3843,0)
(8815,3542,0)
(7173,8147,0)
(7097,6575,0)
(3300,8775,0)
(7544,5361,0)
(2172,7995,0)
(6981,2608,0)
(4838,7369,0)
(5547,6230,0)
(4764,1586,0)
(4342,5268,0)
(6546,9117,0)
(8393,4307,0)
(5748,2885,0)
(3649,4210,0)
(5073,2096,0)
(2729,2757,0)
(3162,578,0)
(2036,3842,0)
(9127,6594,0)
(4981,2686,0)
(4261,6671,0)
(6984,7722,0)
(6072,4382,0)
(5130,3786,0)
(957,5823,0)
(7048,6544,0)
(3457,2384,0)
(27,5926,0)
(2445,1165,0)
(6187,5851,0)
(8038,1405,0)
(4943,1468,0)
(1986,6384,0)
(2255,6405,0)
(3703,4245,0)
(6308,4628,0)
(3245,1892,0)
(294,6816,0)
(826,6522,0)
(8563,2506,0)
(683,8366,0)
(6103,8391,0)
(2371,6722,0)
(5441,1296,0)
(1567,3621,0)
(3487,1227,0)
(8388,5433,0)
(6423,7347,0)
(6336,5706,0)
(5809,8111,0)
(7045,6102,0)
(2192,4391,0)
(5371,2706,0)
(3538,1707,0)
(1108,387,0)
(1316,7536,0)
(1017,6711,0)
(6196,2879,0)
(2135,2406,0)
(3226,8529,0)
(7626,2112,0)
(8348,115,0)
(8311,115,0)
(7828,3358,0)
(4283,102,0)
(4647,2570,0)
(1052,7239,0)
(8732,8391,0)
(1791,12,0)
(6229,7077,0)
(625,5848,0)
(3647,2283,0)
(2406,2135,0)
(1900,7707,0)
(8781,3625,0)
(2248,6286,0)
(3655,3526,0)
(1415,1851,0)
(6700,115,0)
(4312,4957,0)
(1978,1080,0)
(6718,4692,0)
(3727,8541,0)
(2498,8403,0)
(5494,2112,0)
(2982,5250,0)
(704,4104,0)
(6395,996,0)
(899,5317,0)
(8561,115,0)
(3863,5881,0)
(140,2288,0)
(5264,8237,0)
(55,473,0)
(1050,1758,0)
(6064,7577,0)
(1360,8471,0)
(3767,2538,0)
(855,7210,0)
(8504,1725,0)
(1850,4704,0)
(6396,769,0)
(4102,6858,0)
(7259,505,0)
(8578,7219,0)
(4309,5156,0)
(5633,8195,0)
(3224,3427,0)
(5094,1894,0)
(590,7588,0)
(258,5519,0)
(3878,218,0)
(8078,795,0)
(8531,115,0)
(5587,8913,0)
(2097,7988,0)
(5813,2642,0)
(2314,4295,0)
(5687,115,0)
(1074,5983,0)
(7021,7160,0)
(7966,4515,0)
(6649,8391,0)
(1415,4587,0)
(1919,314,0)
(6279,916,0)
(471,4516,0)
(2553,348,0)
(4407,520,0)
(6316,6703,0)
(1396,1062,0)
(83,7077,0)
(4507,7272,0)
(3807,8391,0)
(1749,6671,0)
(139,883,0)
(3421,8354,0)
(8580,7226,0)
(5689,4044,0)
(4875,2698,0)
(4401,4785,0)
(4134,412,0)
(4439,5965,0)
(298,2593,0)
(3263,6838,0)
(4305,5118,0)
(7357,7060,0)
(2444,8423,0)
(7606,609,0)
(2322,2367,0)
(7812,8391,0)
(868,6753,0)
(8616,115,0)
(8083,6934,0)
(411,7917,0)
(4416,1389,0)
(5593,9130,0)
(6781,8812,0)
(7029,1484,0)
(6968,385,0)
(2512,4445,0)
(3848,121,0)
(2137,1120,0)
(8050,177,0)
(5726,8612,0)
(500,6445,0)
(3156,1896,0)
(8663,7186,0)
(7971,6671,0)
(8858,6510,0)
(1673,2072,0)
(261,535,0)
(53,7679,0)
(8481,1682,0)
(5744,28,0)
(3187,3574,0)
(4931,7444,0)
(3800,3155,0)
(4756,6671,0)
(6230,651,0)
(2007,6659,0)
(6536,7040,0)
(3301,4189,0)
(6908,2043,0)
(5688,8245,0)
(528,8391,0)
(5860,6671,0)
(5704,5184,0)
(5851,5491,0)
(2562,8775,0)
(2529,5795,0)
(8116,8540,0)
(2827,1991,0)
(1479,7828,0)
(8131,82,0)
(5686,1666,0)
(263,929,0)
(2393,7632,0)
(2638,4798,0)
(3822,588,0)
(2363,4051,0)
(2778,7938,0)
(4413,5156,0)
(6993,5961,0)
(7572,2130,0)
(7801,718,0)
(1195,5369,0)
(7011,40,0)
(5347,1670,0)
(4977,9028,0)
(5518,3648,0)
(7315,7628,0)
(3268,115,0)
(906,2297,0)
(3094,2653,0)
(5335,2558,0)
(8901,8877,0)
(2202,8560,0)
(3902,1376,0)
(3051,5981,0)
(4375,6563,0)
(4368,167,0)
(266,4321,0)
(4503,6700,0)
(292,4594,0)
(1848,115,0)
(8222,5991,0)
(3814,1199,0)
(7750,7691,0)
(1369,3782,0)
(8098,925,0)
(7853,7057,0)
(4820,592,0)
(9109,5851,0)
(4500,1114,0)
(6091,3014,0)
(5886,3243,0)
(4166,7802,0)
(7575,580,0)
(5176,6741,0)
(6449,4451,0)
(1989,6429,0)
(4036,7852,0)
(4622,4375,0)
(5970,6267,0)
(2230,793,0)
(4357,163,0)
(1423,6284,0)
(6861,6181,0)
(2107,4785,0)
(7306,115,0)
(7626,6649,0)
(7669,6146,0)
(6374,6649,0)
(621,6009,0)
(3578,4672,0)
(32,6977,0)
(4564,2166,0)
(5809,4515,0)
(6504,3860,0)
(5550,6910,0)
(1331,1042,0)
(7703,6351,0)
(5990,8426,0)
(5199,1706,0)
(6141,4596,0)
(2385,8391,0)
(5058,6002,0)
(5190,3333,0)
(4560,2004,0)
(1322,2181,0)
(5084,6600,0)
(4494,115,0)
(1542,8391,0)
(8778,7798,0)
(4375,3970,0)
(6722,7710,0)
(8655,4221,0)
(6587,7859,0)
(7067,8952,0)
(371,1149,0)
(2880,2764,0)
(3526,1895,0)
(3804,4350,0)
(3897,8874,0)
(3476,462,0)
(6295,8142,0)
(8234,152,0)
(7101,3650,0)
(4235,540,0)
(8445,5876,0)
(1227,115,0)
(3197,3650,0)
(669,3291,0)
(2743,5355,0)
(2287,3889,0)
(7130,8256,0)
(7450,5874,0)
(8066,4785,0)
(4138,8458,0)
(8117,3445,0)
(6146,1488,0)
(4843,3075,0)
(1324,9125,0)
(2094,115,0)
(660,5239,0)
(4625,6500,0)
(581,3564,0)
(3860,115,0)
(6995,1799,0)
(7857,6808,0)
(1054,115,0)
(1322,8391,0)
(5013,2803,0)
(2475,2845,0)
(3630,3457,0)
(7598,8687,0)
(4002,115,0)
(101,8186,0)
(5092,6671,0)
(4647,115,0)
(3833,916,0)
(5195,2943,0)
(4317,562,0)
(7899,2919,0)
(1976,5851,0)
(3070,3872,0)
(6233,340,0)
(8125,926,0)
(9069,3451,0)
(6062,4174,0)
(5364,4596,0)
(6566,72,0)
(5881,2386,0)
(946,8535,0)
(6103,115,0)
(436,2167,0)
(8300,5089,0)
(2916,9023,0)
(5349,2587,0)
(5145,3793,0)
(1964,8764,0)
(5427,1979,0)
(5649,8391,0)
(7851,4687,0)
(605,8194,0)
(1166,8391,0)
(4362,6098,0)
(8854,3579,0)
(3640,4431,0)
(2234,2845,0)
(331,2553,0)
(1701,7975,0)
(332,7016,0)
(4516,4900,0)
(7626,4149,0)
(5156,7550,0)
(543,3945,0)
(1758,6922,0)
(9049,115,0)
(8236,8969,0)
(7898,569,0)
(7306,4725,0)
(3612,2945,0)
(1066,2203,0)
(378,8695,0)
(7992,1873,0)
(5566,4582,0)
(5178,1974,0)
(749,5847,0)
(4413,7041,0)
(3213,8458,0)
(2430,8571,0)
(1758,2157,0)
(750,5421,0)
(8346,7363,0)
(2751,6622,0)
(2254,8933,0)
(706,6575,0)
(1595,8348,0)
(8359,115,0)
(3838,8206,0)
(4358,4556,0)
(3751,2347,0)
(4851,671,0)
(8560,1987,0)
(8501,115,0)
(1893,8470,0)
(9068,4690,0)
(4694,1158,0)
(8898,7525,0)
(7328,7400,0)
(2885,7650,0)
(550,2286,0)
(6662,2874,0)
(2969,6545,0)
(8697,5498,0)
(8134,2281,0)
(1545,7683,0)
(7497,119,0)
(117,1363,0)
(5750,6105,0)
(4532,3629,0)
(4939,7653,0)
(7440,4606,0)
(7536,8391,0)
(6949,517,0)
(8363,2653,0)
(909,8391,0)
(5577,8432,0)
(1415,7094,0)
(7197,7318,0)
(8373,8047,0)
(8920,6830,0)
(51,6855,0)
(5655,483,0)
(3306,777,0)
(3581,7250,0)
(6180,3907,0)
(7458,7485,0)
(2244,2131,0)
(8416,2171,0)
(8031,115,0)
(3864,1022,0)
(1612,115,0)
(1875,1851,0)
(7866,5273,0)
(2309,7163,0)
(8034,1930,0)
(4979,7840,0)
(4873,7039,0)
(8123,8320,0)
(5865,4431,0)
(6136,6711,0)
(6090,4310,0)
(7757,8736,0)
(7020,4792,0)
(6060,5342,0)
(4219,7807,0)
(8760,7959,0)
(612,7034,0)
(5793,4785,0)
(390,2996,0)
(8668,7358,0)
(3545,115,0)
(665,8624,0)
(676,3933,0)
(4089,4470,0)
(4564,7660,0)
(1227,8391,0)
(1487,8241,0)
(7474,6545,0)
(2905,2335,0)
(3050,747,0)
(7807,4219,0)
(4375,8111,0)
(356,7318,0)
(8313,8391,0)
(8598,1727,0)
(3594,5416,0)
(1149,2926,0)
(7391,3306,0)
(1682,8481,0)
(3449,8206,0)
(8143,2020,0)
(5179,1121,0)
(6824,2618,0)
(3621,6649,0)
(6070,3786,0)
(3825,4709,0)
(5632,6476,0)
(63,272,0)
(7963,5294,0)
(8805,2195,0)
(1014,6201,0)
(5771,6073,0)
(794,793,0)
(2237,3266,0)
(4641,5862,0)
(8273,8670,0)
(1474,2112,0)
(6158,8391,0)
(4397,1114,0)
(4367,7470,0)
(4605,2279,0)
(8699,4158,0)
(8654,8975,0)
(5656,2607,0)
(8631,4221,0)
(949,8763,0)
(5486,8391,0)
(3524,5811,0)
(4084,5499,0)
(8470,1719,0)
(4804,6325,0)
(1382,8559,0)
(5451,2845,0)
(7575,8487,0)
(5146,8047,0)
(3509,6474,0)
(6871,813,0)
(8382,9083,0)
(3633,4249,0)
(9124,8391,0)
(8558,1748,0)
(3997,7866,0)
(1785,7796,0)
(7114,4937,0)
(6764,6671,0)
(4774,1991,0)
(8743,1832,0)
(3841,4749,0)
(8655,4228,0)
(8643,8042,0)
(8891,2043,0)
(666,202,0)
(6104,8391,0)
(5638,2681,0)
(672,5099,0)
(6044,2788,0)
(3924,3891,0)
(8639,2618,0)
(7698,5510,0)
(4881,5965,0)
(2618,8695,0)
(1415,5796,0)
(6421,1458,0)
(3670,6073,0)
(5056,713,0)
(2875,7707,0)
(3810,5151,0)
(8240,9047,0)
(3759,7847,0)
(5104,5757,0)
(2528,7166,0)
(6675,9110,0)
(6379,1878,0)
(6588,4920,0)
(578,6699,0)
(2315,115,0)
(1256,1755,0)
(3013,6536,0)
(3629,3123,0)
(6500,7138,0)
(1908,7541,0)
(4039,4172,0)
(7396,3058,0)
(4381,115,0)
(1165,5861,0)
(1017,7881,0)
(6986,1208,0)
(274,9066,0)
(3468,8572,0)
(8525,2974,0)
(6462,6101,0)
(3213,3215,0)
(6779,9021,0)
(1374,2220,0)
(5775,829,0)
(9038,1310,0)
(5674,158,0)
(4892,6600,0)
(3534,2845,0)
(5334,7224,0)
(3033,3250,0)
(6502,1415,0)
(8280,5463,0)
(741,2896,0)
(4833,5947,0)
(4403,6485,0)
(1539,6700,0)
(9035,6797,0)
(7763,5174,0)
(4038,6276,0)
(3649,6351,0)
(739,8694,0)
(1894,5094,0)
(1343,1044,0)
(8404,7921,0)
(8318,6445,0)
(2574,1138,0)
(4256,8618,0)
(7487,2920,0)
(2506,4314,0)
(4097,50,0)
(1193,7383,0)
(7151,5809,0)
(9136,3268,0)
(4375,6055,0)
(3516,2012,0)
(4724,3899,0)
(7283,2756,0)
(1001,5543,0)
(1956,6671,0)
(5982,8391,0)
(8238,2690,0)
(5544,8103,0)
(4692,5249,0)
(7105,1675,0)
(4713,1447,0)
(285,3634,0)
(5776,8204,0)
(115,8889,0)
(3690,7924,0)
(4822,6357,0)
(8728,6577,0)
(3310,1833,0)
(3749,2005,0)
(1755,115,0)
(4968,6928,0)
(5811,5156,0)
(1255,4799,0)
(4536,4707,0)
(3114,7519,0)
(4433,8834,0)
(3834,4876,0)
(3007,901,0)
(5214,700,0)
(1402,385,0)
(7254,2085,0)
(9040,1366,0)
(6603,115,0)
(3312,4912,0)
(6120,4002,0)
(4375,4524,0)
(6734,8876,0)
(3717,7735,0)
(7328,3849,0)
(2895,2926,0)
(1528,549,0)
(2374,89,0)
(3101,8391,0)
(3318,115,0)
(3598,4812,0)
(1273,8391,0)
(6810,5396,0)
(4723,5501,0)
(1813,6121,0)
(668,3380,0)
(1415,373,0)
(453,7983,0)
(9138,1048,0)
(8277,7501,0)
(6435,8391,0)
(8463,1956,0)
(1851,8807,0)
(7527,3103,0)
(495,986,0)
(6673,7785,0)
(7658,2186,0)
(1583,4044,0)
(5795,115,0)
(3622,4549,0)
(2536,2647,0)
(2111,3837,0)
(4795,7498,0)
(6648,2617,0)
(2452,309,0)
(2819,5094,0)
(6097,5829,0)
(8135,148,0)
(1282,8559,0)
(4637,4976,0)
(8610,8391,0)
(2543,2112,0)
(9133,8969,0)
(5451,8391,0)
(5083,4976,0)
(1092,8393,0)
(3959,7057,0)
(6082,2512,0)
(8743,7789,0)
(6254,115,0)
(4364,8175,0)
(8713,8833,0)
(6681,6267,0)
(1435,2573,0)
(4529,3215,0)
(5851,2645,0)
(7645,3197,0)
(8361,3547,0)
(8507,350,0)
(5638,9130,0)
(2330,3596,0)
(6667,8421,0)
(4140,2919,0)
(1347,3614,0)
(5933,2329,0)
(5690,1583,0)
(7611,1274,0)
(1843,8391,0)
(1848,5698,0)
(5486,5981,0)
(1954,6575,0)
(2961,1573,0)
(8757,6425,0)
(1452,2845,0)
(1387,2676,0)
(4326,569,0)
(1389,5810,0)
(6419,3565,0)
(6000,8391,0)
(8719,7203,0)
(6602,5448,0)
(1779,1105,0)
(5078,6671,0)
(8049,5750,0)
(8985,3829,0)
(1478,8391,0)
(1065,115,0)
(391,8043,0)
(2879,2724,0)
(6163,4587,0)
(2459,519,0)
(6023,2009,0)
(4333,7771,0)
(3849,8391,0)
(6309,2951,0)
(9046,7470,0)
(2871,5968,0)
(4947,268,0)
(6349,7339,0)
(1530,732,0)
(2031,1616,0)
(902,8391,0)
(6955,4309,0)
(9082,6688,0)
(1645,2988,0)
(4689,3647,0)
(7411,8391,0)
(6069,7079,0)
(5676,5691,0)
(4464,2099,0)
(4673,8546,0)
(2075,2234,0)
(8037,2667,0)
(6869,4729,0)
(3574,3187,0)
(2557,8323,0)
(2590,6671,0)
(5332,7577,0)
(1811,3577,0)
(3497,3620,0)
(4044,4034,0)
(7533,5593,0)
(1040,3874,0)
(4835,1298,0)
(5965,7119,0)
(2168,2690,0)
(2076,7746,0)
(4801,7864,0)
(4470,4089,0)
(6573,8911,0)
(4309,5652,0)
(1899,5147,0)
(5184,6190,0)
(8567,5226,0)
(8616,7365,0)
(2907,5874,0)
(6598,3101,0)
(3381,7367,0)
(6006,7780,0)
(8806,115,0)
(3181,6825,0)
(2137,7597,0)
(6623,2274,0)
(6535,6385,0)
(380,2567,0)
(8199,8628,0)
(2672,2840,0)
(4297,6713,0)
(4120,7415,0)
(2009,5094,0)
(6118,3817,0)
(328,4307,0)
(651,2358,0)
(7097,2896,0)
(7968,629,0)
(8151,1766,0)
(5837,1017,0)
(8870,114,0)
(2683,115,0)
(2567,9003,0)
(6014,4095,0)
(6081,7405,0)
(6405,6711,0)
(2580,6783,0)
(5236,6600,0)
(8254,8126,0)
(6888,5249,0)
(1408,7524,0)
(1515,8836,0)
(2520,6194,0)
(1059,1453,0)
(7202,2947,0)
(4974,4627,0)
(2089,4146,0)
(1166,115,0)
(7840,14,0)
(6889,115,0)
(7055,5540,0)
(5826,5452,0)
(4267,4792,0)
(6626,8877,0)
(1279,2511,0)
(2570,4647,0)
(2121,6046,0)
(1146,4357,0)
(5076,3862,0)
(2657,8391,0)
(6928,8391,0)
(3443,7032,0)
(2512,6575,0)
(1096,7488,0)
(374,5015,0)
(362,3313,0)
(3660,1874,0)
(4434,7889,0)
(7829,2847,0)
(4905,5654,0)
(8565,3672,0)
(1538,5110,0)
(5494,2861,0)
(3386,9026,0)
(6562,2757,0)
(2839,3480,0)
(2159,8211,0)
(8744,4186,0)
(7426,6358,0)
(7842,1210,0)
(7948,4785,0)
(4991,4618,0)
(7459,7451,0)
(5744,6320,0)
(8088,115,0)
(8341,9012,0)
(4375,8458,0)
(2582,9023,0)
(8014,1149,0)
(4942,115,0)
(9029,115,0)
(4968,3866,0)
(8128,1468,0)
(7626,9130,0)
(5306,1204,0)
(2809,4616,0)
(9038,8391,0)
(8614,496,0)
(4210,3649,0)
(4889,2450,0)
(3644,9026,0)
(5691,8764,0)
(5638,8021,0)
(8094,4381,0)
(8745,5470,0)
(5556,2285,0)
(8082,7136,0)
(4982,8391,0)
(6808,6751,0)
(8832,7103,0)
(3966,4037,0)
(3992,6687,0)
(2361,3962,0)
(106,6527,0)
(6426,1022,0)
(6639,1834,0)
(5342,8391,0)
(1715,4444,0)
(4560,8960,0)
(7057,189,0)
(350,8507,0)
(5415,6449,0)
(7952,8857,0)
(7462,3980,0)
(2742,607,0)
(3299,7063,0)
(6317,115,0)
(769,5301,0)
(6611,8391,0)
(4467,8035,0)
(4518,1853,0)
(3067,115,0)
(1727,115,0)
(3288,8391,0)
(4034,4044,0)
(1567,8391,0)
(6797,9035,0)
(3950,5887,0)
(7529,103,0)
(8308,590,0)
(5423,4408,0)
(7625,5775,0)
(3120,8820,0)
(8484,2534,0)
(7880,8391,0)
(6558,6517,0)
(1825,2025,0)
(5284,6098,0)
(701,2627,0)
(6602,8391,0)
(8038,6649,0)
(8198,5730,0)
(5189,5283,0)
(6488,6366,0)
(7112,6157,0)
(8038,7039,0)
(6926,4055,0)
(6398,6394,0)
(2229,403,0)
(3122,6910,0)
(4157,8391,0)
(3509,4587,0)
(8636,5573,0)
(6186,1853,0)
(5791,9117,0)
(6502,5638,0)
(244,2754,0)
(5096,2894,0)
(1482,7568,0)
(4015,8722,0)
(6960,1462,0)
(1607,7248,0)
(9013,2336,0)
(4026,8391,0)
(2407,1419,0)
(6899,8633,0)
(1415,3901,0)
(1235,823,0)
(3924,7634,0)
(3769,1254,0)
(5214,7272,0)
(3552,4295,0)
(4375,87,0)
(5564,6851,0)
(661,8528,0)
(3213,4587,0)
(1386,2504,0)
(820,1843,0)
(4505,5195,0)
(886,8654,0)
(2167,115,0)
(3206,3090,0)
(3621,4515,0)
(7042,2959,0)
(8202,8297,0)
(5553,2945,0)
(2722,6900,0)
(1501,995,0)
(1262,1367,0)
(7079,7975,0)
(3915,2918,0)
(86,3612,0)
(2282,539,0)
(951,6528,0)
(2074,1488,0)
(6796,1530,0)
(6927,2873,0)
(633,306,0)
(7408,2309,0)
(5127,6402,0)
(7774,1480,0)
(2221,5867,0)
(8612,5726,0)
(8582,3316,0)
(8849,8391,0)
(582,5926,0)
(6601,5243,0)
(4854,5098,0)
(4626,3379,0)
(3159,3556,0)
(399,8148,0)
(2166,2831,0)
(3865,2858,0)
(4586,3338,0)
(7325,325,0)
(1046,868,0)
(1608,8901,0)
(5985,8237,0)
(5309,2955,0)
(8542,7591,0)
(8889,3969,0)
(1765,7743,0)
(8444,891,0)
(3730,8391,0)
(4375,3565,0)
(5617,1406,0)
(1361,5490,0)
(3293,8251,0)
(8802,7849,0)
(177,8050,0)
(7816,1394,0)
(1990,6444,0)
(8296,8391,0)
(1792,616,0)
(7150,1306,0)
(8925,3764,0)
(3804,2955,0)
(8879,1238,0)
(6281,4785,0)
(1355,6397,0)
(7927,8541,0)
(6068,3774,0)
(1899,115,0)
(1981,191,0)
(7103,8832,0)
(1415,7280,0)
(3353,1151,0)
(289,5844,0)
(1901,7490,0)
(6318,2845,0)
(921,8391,0)
(4537,1512,0)
(8029,4473,0)
(34,5870,0)
(1058,6663,0)
(2762,6449,0)
(4735,1149,0)
(881,5228,0)
(5545,7146,0)
(7203,8418,0)
(6787,3661,0)
(8349,7396,0)
(9,1575,0)
(5180,4735,0)
(8139,8391,0)
(242,5851,0)
(6106,6275,0)
(4273,8160,0)
(1816,3830,0)
(6957,1512,0)
(5714,1152,0)
(6704,6320,0)
(5324,3553,0)
(7953,4477,0)
(1083,3901,0)
(267,3215,0)
(6954,5337,0)
(6067,8391,0)
(6536,7759,0)
(4821,5421,0)
(7568,1482,0)
(5278,660,0)
(2538,4566,0)
(6080,115,0)
(7553,3173,0)
(716,6939,0)
(6340,4000,0)
(4157,115,0)
(7819,99,0)
(1829,6935,0)
(5665,6458,0)
(3213,8021,0)
(1152,6521,0)
(6545,7365,0)
(2283,3647,0)
(4725,5790,0)
(3673,2845,0)
(506,3886,0)
(7921,5597,0)
(2515,8441,0)
(4578,8744,0)
(2403,671,0)
(5147,6563,0)
(1982,4876,0)
(3284,5174,0)
(4472,4876,0)
(1881,8391,0)
(4273,7632,0)
(2537,5922,0)
(5451,3973,0)
(711,6807,0)
(6272,7102,0)
(7305,4980,0)
(1415,4350,0)
(7910,8391,0)
(5717,6167,0)
(5374,1748,0)
(8684,7892,0)
(8559,1382,0)
(5851,5331,0)
(5390,6753,0)
(3535,1530,0)
(5084,5604,0)
(6838,6748,0)
(6002,2354,0)
(8905,8208,0)
(4688,6659,0)
(7713,7578,0)
(2965,2556,0)
(6525,8247,0)
(1110,4222,0)
(936,2130,0)
(5392,2917,0)
(8468,386,0)
(4044,5689,0)
(8732,891,0)
(2423,6694,0)
(3223,1303,0)
(3146,6181,0)
(2943,5195,0)
(5151,1145,0)
(2189,6513,0)
(5718,3214,0)
(85,8577,0)
(2351,116,0)
(3058,7396,0)
(210,5623,0)
(952,4452,0)
(9032,2978,0)
(3446,4785,0)
(4251,6671,0)
(4560,5396,0)
(5402,2190,0)
(1478,5828,0)
(7018,1368,0)
(479,2465,0)
(5602,8439,0)
(3495,3872,0)
(3258,2976,0)
(4848,3522,0)
(2683,6202,0)
(1274,4307,0)
(2652,5030,0)
(475,2984,0)
(3916,543,0)
(6522,2845,0)
(4716,4077,0)
(5483,5829,0)
(2206,1526,0)
(1955,115,0)
(3254,1368,0)
(222,365,0)
(8265,8774,0)
(863,3934,0)
(413,2757,0)
(5638,2112,0)
(1312,167,0)
(1090,5669,0)
(5504,1848,0)
(440,8648,0)
(5294,5823,0)
(8264,4005,0)
(8221,7264,0)
(1415,9130,0)
(7812,6724,0)
(5485,8838,0)
(4732,4024,0)
(3052,2610,0)
(5028,3249,0)
(1542,314,0)
(1490,7409,0)
(7497,8957,0)
(2234,614,0)
(6657,1149,0)
(3925,4125,0)
(5337,7316,0)
(1022,115,0)
(8029,4842,0)
(5185,2979,0)
(3809,2450,0)
(4253,7888,0)
(3338,3634,0)
(2266,4785,0)
(7242,2027,0)
(1280,7711,0)
(8839,6538,0)
(4349,2593,0)
(6076,2379,0)
(6095,6364,0)
(3289,8047,0)
(6821,8815,0)
(6365,771,0)
(214,5315,0)
(4606,2667,0)
(8764,5691,0)
(338,1724,0)
(497,4301,0)
(5399,2671,0)
(5867,2221,0)
(2161,9077,0)
(7447,3278,0)
(7788,6443,0)
(3267,1213,0)
(5305,6602,0)
(3976,6629,0)
(6067,115,0)
(3911,1363,0)
(2303,3647,0)
(5641,5533,0)
(6023,115,0)
(7818,7462,0)
(4269,8633,0)
(5118,6400,0)
(6348,716,0)
(4383,3876,0)
(6596,3266,0)
(6835,5548,0)
(4589,7799,0)
(3053,6694,0)
(1364,3980,0)
(5583,8391,0)
(775,115,0)
(2126,8027,0)
(114,5646,0)
(3376,4183,0)
(6636,8165,0)
(2133,6666,0)
(2023,556,0)
(1426,1065,0)
(7351,6068,0)
(2816,4162,0)
(8492,283,0)
(4700,865,0)
(3427,3224,0)
(873,7120,0)
(2346,2158,0)
(2167,4757,0)
(8774,7630,0)
(2904,8391,0)
(3390,4176,0)
(52,2388,0)
(143,7951,0)
(6916,2190,0)
(4167,2206,0)
(3258,5089,0)
(7239,1052,0)
(3982,3595,0)
(1776,1870,0)
(1111,115,0)
(2675,4028,0)
(759,4842,0)
(5445,3095,0)
(211,7780,0)
(4510,2116,0)
(1196,5851,0)
(5631,2917,0)
(3339,2330,0)
(521,482,0)
(3061,4977,0)
(4387,8289,0)
(861,6149,0)
(4390,5777,0)
(7491,476,0)
(6116,8719,0)
(5124,6027,0)
(4100,7775,0)
(6066,2640,0)
(1415,3377,0)
(17,2009,0)
(4671,6500,0)
(2274,6623,0)
(229,5871,0)
(5237,4245,0)
(733,101,0)
(6501,3725,0)
(747,3050,0)
(8298,221,0)
(4580,115,0)
(2103,7384,0)
(4270,5156,0)
(6916,2260,0)
(1615,333,0)
(7812,3621,0)
(538,5575,0)
(903,8391,0)
(6533,5433,0)
(614,2234,0)
(5971,5156,0)
(1139,9088,0)
(5031,1602,0)
(1736,469,0)
(8605,4444,0)
(7041,7375,0)
(772,6158,0)
(7870,7973,0)
(6014,39,0)
(4088,4367,0)
(920,1923,0)
(4568,7566,0)
(1827,794,0)
(3138,115,0)
(4017,7975,0)
(8933,6652,0)
(8271,3096,0)
(4571,4285,0)
(7826,179,0)
(8873,1516,0)
(7532,1039,0)
(4402,618,0)
(6815,7001,0)
(3804,1280,0)
(3401,9059,0)
(4929,1780,0)
(6681,4056,0)
(789,3335,0)
(250,6384,0)
(6278,4522,0)
(7266,1406,0)
(1475,1755,0)
(539,115,0)
(6400,7762,0)
(5283,5189,0)
(241,5730,0)
(8422,9026,0)
(3207,7083,0)
(8338,1236,0)
(3364,5290,0)
(2506,115,0)
(5809,3565,0)
(1809,1181,0)
(2698,5156,0)
(5671,7531,0)
(571,6793,0)
(7002,7925,0)
(4623,6775,0)
(1048,5139,0)
(1442,8874,0)
(645,4884,0)
(1163,8291,0)
(6556,115,0)
(1138,1488,0)
(6846,6636,0)
(626,7707,0)
(1189,9036,0)
(6182,6354,0)
(8705,4918,0)
(6348,6736,0)
(4812,6671,0)
(1689,3050,0)
(5494,1158,0)
(5358,8654,0)
(3899,8391,0)
(5069,8521,0)
(7729,3668,0)
(6857,8799,0)
(39,8691,0)
(7949,6717,0)
(1222,1966,0)
(3828,115,0)
(3331,8024,0)
(2544,3565,0)
(3927,2789,0)
(2439,4785,0)
(4139,7832,0)
(741,4445,0)
(5555,115,0)
(7735,5239,0)
(3068,8244,0)
(4745,7201,0)
(8942,4111,0)
(9069,8391,0)
(7950,6468,0)
(119,8391,0)
(7389,4405,0)
(4144,5074,0)
(4069,3897,0)
(2939,7989,0)
(1114,7691,0)
(2099,3875,0)
(3392,1085,0)
(4080,8825,0)
(6123,3232,0)
(1351,5998,0)
(1881,8978,0)
(7178,7692,0)
(2640,8391,0)
(8579,5842,0)
(4727,4342,0)
(3371,2119,0)
(1555,8994,0)
(2287,6356,0)
(3619,4722,0)
(3496,1559,0)
(2756,7283,0)
(5429,6308,0)
(2544,6649,0)
(6447,7937,0)
(9004,8414,0)
(1041,7501,0)
(3384,1488,0)
(445,7224,0)
(9063,1488,0)
(6859,2470,0)
(5695,3201,0)
(3420,4524,0)
(4338,2559,0)
(8606,5382,0)
(3727,8391,0)
(499,274,0)
(4375,2861,0)
(4423,6121,0)
(8237,115,0)
(8077,2909,0)
(565,1299,0)
(3815,580,0)
(9043,3380,0)
(7473,6808,0)
(6808,5657,0)
(4163,1694,0)
(2703,853,0)
(3243,5886,0)
(8690,8307,0)
(8691,39,0)
(4992,3274,0)
(4375,5736,0)
(7551,3633,0)
(4683,7408,0)
(5868,1048,0)
(8430,8248,0)
(7714,6318,0)
(7667,8295,0)
(8011,100,0)
(8048,2314,0)
(4382,6072,0)
(6703,8391,0)
(4876,5924,0)
(4038,6220,0)
(4313,2549,0)
(4872,8085,0)
(6053,9047,0)
(2501,3103,0)
(5982,115,0)
(3365,6979,0)
(5731,3456,0)
(4277,5156,0)
(8009,8391,0)
(7812,3875,0)
(299,5876,0)
(4749,1956,0)
(1326,2845,0)
(7854,4252,0)
(8055,115,0)
(4582,5871,0)
(6338,1794,0)
(3664,7431,0)
(1710,2812,0)
(4865,377,0)
(3999,6239,0)
(4005,99,0)
(865,4700,0)
(1963,8273,0)
(4839,2128,0)
(7050,4502,0)
(1627,8659,0)
(7367,3381,0)
(1600,1166,0)
(6784,4270,0)
(2251,8009,0)
(8536,5519,0)
(5294,536,0)
(5975,6560,0)
(4521,965,0)
(379,777,0)
(1415,8238,0)
(1677,4752,0)
(939,5119,0)
(243,1895,0)
(9010,8391,0)
(7595,8391,0)
(4198,8391,0)
(7936,3356,0)
(2519,1094,0)
(72,5096,0)
(4982,115,0)
(1396,5543,0)
(4976,8369,0)
(2554,9088,0)
(2038,4785,0)
(2401,324,0)
(8471,1360,0)
(3051,2411,0)
(8653,4700,0)
(6374,4686,0)
(7197,115,0)
(340,115,0)
(3753,786,0)
(5602,429,0)
(829,5775,0)
(8020,7578,0)
(6426,4011,0)
(4754,8727,0)
(2326,2585,0)
(5214,8111,0)
(5708,7675,0)
(6215,115,0)
(8026,4410,0)
(4783,2283,0)
(4425,1203,0)
(7566,115,0)
(2394,6064,0)
(3040,6671,0)
(8624,152,0)
(3076,2836,0)
(8044,4474,0)
(313,3090,0)
(7787,6910,0)
(2696,2329,0)
(8557,2842,0)
(128,2486,0)
(8310,6671,0)
(8058,7625,0)
(7880,115,0)
(999,1387,0)
(7498,115,0)
(3519,7759,0)
(8834,3424,0)
(8184,2020,0)
(5813,115,0)
(6471,7212,0)
(2234,115,0)
(5410,3913,0)
(6376,6881,0)
(459,2210,0)
(6803,5970,0)
(696,8478,0)
(4319,8391,0)
(6292,7409,0)
(97,617,0)
(5319,9124,0)
(3602,1188,0)
(1319,2454,0)
(6494,7373,0)
(4330,2504,0)
(6987,8109,0)
(6827,9076,0)
(2198,9000,0)
(4646,8544,0)
(7837,1832,0)
(3608,2622,0)
(295,6793,0)
(8790,115,0)
(4807,5796,0)
(7350,3449,0)
(3800,8285,0)
(7366,900,0)
(9065,8522,0)
(3246,6451,0)
(4654,6433,0)
(6776,9096,0)
(1987,8560,0)
(6611,115,0)
(6970,4698,0)
(2550,7632,0)
(3865,5961,0)
(5249,6888,0)
(710,207,0)
(6278,245,0)
(416,4555,0)
(7384,1900,0)
(274,3102,0)
(4755,5414,0)
(2688,2343,0)
(1085,8391,0)
(6401,7983,0)
(284,2640,0)
(3292,4742,0)
(3436,2171,0)
(5510,8017,0)
(8288,2526,0)
(8057,6529,0)
(4477,7294,0)
(6466,4071,0)
(5056,8391,0)
(6173,9067,0)
(6646,6629,0)
(5532,2162,0)
(1481,7107,0)
(3781,3139,0)
(1754,3792,0)
(4239,3658,0)
(5503,5898,0)
(5209,115,0)
(88,8274,0)
(2287,700,0)
(578,2845,0)
(8777,4424,0)
(8621,6440,0)
(6534,3493,0)
(3634,3338,0)
(7598,1613,0)
(482,8391,0)
(121,2927,0)
(7055,5070,0)
(6751,6808,0)
(2807,8902,0)
(5156,4403,0)
(5499,3628,0)
(6534,1138,0)
(5474,781,0)
(327,6054,0)
(8959,775,0)
(2911,4734,0)
(6748,7107,0)
(1063,5398,0)
(8755,5952,0)
(7233,6007,0)
(5678,9119,0)
(7608,6967,0)
(337,1079,0)
(8470,115,0)
(8911,812,0)
(5238,5166,0)
(1103,4349,0)
(1052,115,0)
(3779,4313,0)
(1580,1881,0)
(3213,1158,0)
(8089,7857,0)
(6992,8197,0)
(7508,1832,0)
(8426,6836,0)
(1956,4749,0)
(5751,3051,0)
(5688,5829,0)
(2147,2845,0)
(8034,6530,0)
(5818,3522,0)
(7813,8335,0)
(619,8455,0)
(7650,3547,0)
(4332,7959,0)
(6063,8391,0)
(5081,7287,0)
(4375,6649,0)
(1001,115,0)
(7387,4410,0)
(909,115,0)
(6844,8522,0)
(5248,7140,0)
(4436,7789,0)
(1474,3215,0)
(8386,1647,0)
(4001,8391,0)
(5395,66,0)
(6417,2403,0)
(2628,1349,0)
(6629,1921,0)
(3509,1158,0)
(5809,3808,0)
(5239,4172,0)
(6560,5975,0)
(8311,8391,0)
(2073,4069,0)
(8573,1430,0)
(330,7792,0)
(7626,1280,0)
(4156,3435,0)
(2466,7527,0)
(2298,6258,0)
(7795,4188,0)
(1143,6710,0)
(7716,1591,0)
(618,4402,0)
(1618,7283,0)
(6215,6200,0)
(5757,6094,0)
(420,5894,0)
(5787,463,0)
(2287,8021,0)
(7527,2466,0)
(7646,8358,0)
(1365,3333,0)
(4880,2685,0)
(7192,4647,0)
(3368,768,0)
(8452,7777,0)
(7562,579,0)
(1319,588,0)
(6355,1011,0)
(4808,4441,0)
(2567,8391,0)
(2776,6030,0)
(3804,1270,0)
(665,89,0)
(6346,1924,0)
(5408,1419,0)
(7125,1596,0)
(4759,3759,0)
(3526,115,0)
(1044,115,0)
(1666,5686,0)
(4449,6150,0)
(8571,6576,0)
(1217,3183,0)
(5318,2927,0)
(2651,6352,0)
(7068,1672,0)
(1700,747,0)
(2990,4076,0)
(1503,2539,0)
(7571,8391,0)
(4001,115,0)
(5943,2861,0)
(3401,3821,0)
(7798,4876,0)
(1734,2237,0)
(8894,8405,0)
(4471,927,0)
(2002,4319,0)
(8020,3810,0)
(3224,3545,0)
(822,7102,0)
(584,1043,0)
(7097,5512,0)
(1415,796,0)
(8788,2099,0)
(1923,5954,0)
(1415,489,0)
(5888,3288,0)
(6940,6208,0)
(5193,115,0)
(6866,4831,0)
(4123,5862,0)
(904,5515,0)
(6530,981,0)
(5114,4464,0)
(8100,6337,0)
(4873,6649,0)
(1293,8989,0)
(6431,5829,0)
(1738,1605,0)
(6332,45,0)
(1915,5887,0)
(7148,2117,0)
(2581,897,0)
(6864,2654,0)
(3747,4861,0)
(2346,5129,0)
(2136,8592,0)
(3017,5144,0)
(1238,8391,0)
(8781,6407,0)
(1931,8391,0)
(4635,7056,0)
(5526,2104,0)
(8670,6060,0)
(1415,7114,0)
(6502,7966,0)
(4643,5100,0)
(601,2673,0)
(1513,4785,0)
(8385,5613,0)
(7991,122,0)
(3081,6298,0)
(1311,9112,0)
(5883,3020,0)
(897,8391,0)
(8592,2136,0)
(2053,4956,0)
(2287,3657,0)
(7799,8241,0)
(488,9039,0)
(3913,4644,0)
(1484,7590,0)
(5950,7972,0)
(6773,3277,0)
(9006,5686,0)
(3803,8176,0)
(7803,5097,0)
(7359,4757,0)
(6352,2651,0)
(4326,205,0)
(6393,1591,0)
(6145,5647,0)
(7670,8391,0)
(3530,8358,0)
(8649,4174,0)
(5734,5166,0)
(297,3511,0)
(3251,5554,0)
(2544,4350,0)
(7724,4388,0)
(8136,8659,0)
(3804,6968,0)
(5162,1491,0)
(854,1017,0)
(135,1435,0)
(7026,3997,0)
(4360,4853,0)
(1153,2498,0)
(7983,1647,0)
(197,115,0)
(6541,614,0)
(3806,5125,0)
(3929,7816,0)
(6865,115,0)
(3023,6142,0)
(3294,7050,0)
(8698,579,0)
(8854,4531,0)
(4100,4186,0)
(2671,8391,0)
(8951,4781,0)
(4087,8391,0)
(7720,7951,0)
(4363,1948,0)
(3043,8391,0)
(4925,6265,0)
(2624,8698,0)
(4296,286,0)
(4528,2768,0)
(2069,5156,0)
(4540,1412,0)
(5456,8989,0)
(9137,3585,0)
(7174,9130,0)
(6416,3807,0)
(8247,5927,0)
(8426,2553,0)
(3563,6808,0)
(3361,6827,0)
(6419,6968,0)
(8887,3628,0)
(3975,1744,0)
(2808,7056,0)
(8844,2865,0)
(1425,8857,0)
(1841,1186,0)
(164,1070,0)
(9017,8195,0)
(6079,4668,0)
(7191,115,0)
(2123,5512,0)
(848,2714,0)
(5581,7046,0)
(6520,646,0)
(8421,8391,0)
(8531,2821,0)
(6978,5716,0)
(4090,7230,0)
(8262,1203,0)
(5711,1996,0)
(161,115,0)
(5558,3621,0)
(7582,5964,0)
(4873,3565,0)
(7810,8391,0)
(3612,5172,0)
(5971,4571,0)
(1388,6414,0)
(1415,144,0)
(5579,6834,0)
(6472,7909,0)
(3850,669,0)
(1585,252,0)
(611,6592,0)
(2988,1645,0)
(6808,7473,0)
(540,6826,0)
(1252,6252,0)
(4896,1784,0)
(9114,4105,0)
(6016,5613,0)
(8741,1013,0)
(6749,2396,0)
(2671,115,0)
(5332,8528,0)
(4594,8558,0)
(8555,3440,0)
(1575,9,0)
(3669,540,0)
(7253,807,0)
(8038,4587,0)
(4430,6932,0)
(2436,8160,0)
(260,7647,0)
(6021,8763,0)
(7008,1478,0)
(8225,2428,0)
(7196,3451,0)
(2863,6928,0)
(1041,4686,0)
(4687,7851,0)
(3879,8391,0)
(3426,4155,0)
(6451,4601,0)
(5035,3879,0)
(457,1044,0)
(6016,264,0)
(2441,6647,0)
(4596,6141,0)
(484,5387,0)
(6022,7711,0)
(4061,4664,0)
(6356,4379,0)
(6167,2597,0)
(8027,7945,0)
(7968,8543,0)
(5812,2630,0)
(7654,2573,0)
(1369,5467,0)
(1412,4540,0)
(3819,4018,0)
(5960,7652,0)
(8943,876,0)
(8491,4823,0)
(8138,873,0)
(74,8378,0)
(6517,2518,0)
(4478,7212,0)
(2605,6264,0)
(7697,6671,0)
(3789,4886,0)
(1266,474,0)
(2350,2111,0)
(4729,2399,0)
(2561,3529,0)
(5814,8226,0)
(472,9087,0)
(7869,2314,0)
(2636,8097,0)
(859,871,0)
(5704,8741,0)
(4162,2174,0)
(9033,3427,0)
(8038,7280,0)
(2136,7671,0)
(7471,1204,0)
(7753,8248,0)
(8233,2260,0)
(2516,6630,0)
(3080,5151,0)
(6692,6285,0)
(5981,3051,0)
(9103,7820,0)
(682,3729,0)
(524,5315,0)
(7597,2137,0)
(5776,2416,0)
(821,6671,0)
(8156,1907,0)
(7442,8776,0)
(6957,3810,0)
(2210,1008,0)
(979,5813,0)
(1296,2317,0)
(6766,2147,0)
(2623,8391,0)
(5760,1966,0)
(6605,5887,0)
(4487,67,0)
(8019,3286,0)
(3117,8806,0)
(6611,7816,0)
(5214,7039,0)
(8142,2303,0)
(1642,1184,0)
(1904,4734,0)
(1727,8391,0)
(8687,7598,0)
(2584,8110,0)
(3440,6847,0)
(4119,1471,0)
(8246,6826,0)
(888,5374,0)
(6889,7433,0)
(3719,7383,0)
(3597,4386,0)
(2825,18,0)
(7083,3207,0)
(934,4386,0)
(2217,8391,0)
(3051,5825,0)
(4035,213,0)
(2518,1366,0)
(785,2116,0)
(981,3415,0)
(3135,2689,0)
(7975,8130,0)
(858,8959,0)
(7498,847,0)
(5227,1357,0)
(2287,1278,0)
(1415,7046,0)
(7489,1134,0)
(3763,3055,0)
(8763,6021,0)
(4475,2464,0)
(6973,8391,0)
(8142,5961,0)
(2242,2037,0)
(4257,6603,0)
(7087,4020,0)
(3128,7398,0)
(5997,4757,0)
(5726,8423,0)
(5477,115,0)
(4034,3621,0)
(6738,324,0)
(3076,8391,0)
(3340,4070,0)
(8354,2602,0)
(2818,115,0)
(8,1150,0)
(1850,6527,0)
(2494,8295,0)
(1158,4694,0)
(5376,4466,0)
(1768,7213,0)
(8335,5547,0)
(2328,4917,0)
(1184,1422,0)
(8047,6543,0)
(761,9066,0)
(4801,6518,0)
(3760,7874,0)
(2131,4125,0)
(1391,8139,0)
(882,191,0)
(3231,3857,0)
(2721,4619,0)
(1067,7544,0)
(2640,284,0)
(778,609,0)
(7082,6671,0)
(1525,3902,0)
(1745,3440,0)
(6247,6875,0)
(3151,5156,0)
(4470,4398,0)
(8523,2172,0)
(1491,5162,0)
(6921,5932,0)
(2820,1760,0)
(253,6805,0)
(6742,5037,0)
(3874,1040,0)
(7374,8391,0)
(1934,6140,0)
(3116,1260,0)
(529,4337,0)
(73,7444,0)
(6065,6720,0)
(8043,391,0)
(6200,6215,0)
(700,4876,0)
(7352,786,0)
(5519,2845,0)
(1916,2059,0)
(1170,8000,0)
(5499,2707,0)
(5584,7034,0)
(8996,463,0)
(5207,7988,0)
(2869,4949,0)
(3752,2777,0)
(7330,3769,0)
(2215,3043,0)
(6278,3983,0)
(4289,7180,0)
(8814,483,0)
(7269,7238,0)
(3093,4814,0)
(8497,8391,0)
(318,3844,0)
(8417,8020,0)
(2947,284,0)
(4316,5362,0)
(845,3203,0)
(2019,6884,0)
(2779,6310,0)
(3752,570,0)
(1327,9119,0)
(5819,1794,0)
(3322,9038,0)
(4232,8391,0)
(9044,5906,0)
(6333,5489,0)
(3192,1616,0)
(2314,7869,0)
(7743,1765,0)
(8891,5829,0)
(3724,40,0)
(741,3271,0)
(474,7242,0)
(7123,2681,0)
(6457,6150,0)
(6971,8245,0)
(356,5894,0)
(3971,4104,0)
(3621,4149,0)
(1763,1221,0)
(3451,4672,0)
(4000,8450,0)
(2414,4307,0)
(9059,3391,0)
(2591,8391,0)
(7884,4580,0)
(8249,7711,0)
(3695,3594,0)
(89,9061,0)
(929,4959,0)
(4853,4360,0)
(1303,1452,0)
(6998,3198,0)
(6875,115,0)
(3250,6369,0)
(4221,7657,0)
(5030,2652,0)
(7263,3020,0)
(3620,8391,0)
(4056,115,0)
(4468,2043,0)
(6860,952,0)
(4509,4499,0)
(6277,396,0)
(3138,8391,0)
(8194,5239,0)
(3092,4846,0)
(4068,6956,0)
(1458,3999,0)
(2412,3776,0)
(7961,5654,0)
(7287,533,0)
(1832,2845,0)
(3381,3353,0)
(3463,7199,0)
(5982,2625,0)
(7230,4473,0)
(8348,8391,0)
(2417,8063,0)
(4353,3072,0)
(3489,376,0)
(3973,5451,0)
(6762,986,0)
(746,2139,0)
(6172,5960,0)
(2318,6002,0)
(6943,3526,0)
(7525,8391,0)
(7075,115,0)
(1265,8581,0)
(2845,6174,0)
(4427,5840,0)
(3191,5309,0)
(2347,3751,0)
(7469,7038,0)
(3377,4767,0)
(4170,640,0)
(5905,1246,0)
(1298,7833,0)
(7401,3583,0)
(5687,8391,0)
(1835,2199,0)
(6505,6003,0)
(150,3157,0)
(4183,3376,0)
(2950,2444,0)
(3679,6630,0)
(7929,115,0)
(7297,4628,0)
(6088,8391,0)
(3189,6681,0)
(1415,3331,0)
(3188,6348,0)
(1847,1052,0)
(1284,6443,0)
(1950,1876,0)
(5977,2007,0)
(9034,8307,0)
(5871,4582,0)
(909,7785,0)
(7587,7868,0)
(6039,4398,0)
(7980,9059,0)
(7530,1915,0)
(6603,8391,0)
(1149,7707,0)
(4108,1149,0)
(1434,528,0)
(8976,5277,0)
(5286,4749,0)
(7516,115,0)
(6251,5812,0)
(2869,5129,0)
(5540,7055,0)
(6243,4739,0)
(6182,8148,0)
(830,3843,0)
(267,2112,0)
(8610,115,0)
(1679,8173,0)
(7423,8105,0)
(887,3664,0)
(5038,3001,0)
(1983,1851,0)
(1619,3521,0)
(2065,1144,0)
(6103,1762,0)
(9085,8446,0)
(8649,7268,0)
(262,1448,0)
(1072,855,0)
(670,8691,0)
(4907,1491,0)
(157,1405,0)
(8757,7939,0)
(6390,5670,0)
(7793,3942,0)
(8861,4121,0)
(3109,4389,0)
(2731,3433,0)
(3858,7104,0)
(4783,3785,0)
(4574,7602,0)
(6278,2858,0)
(5486,115,0)
(9005,6996,0)
(4658,6369,0)
(3408,4426,0)
(8710,3887,0)
(4167,8797,0)
(5792,828,0)
(1658,5398,0)
(5873,1992,0)
(6890,4601,0)
(4464,6715,0)
(2681,2879,0)
(4750,3834,0)
(4226,7698,0)
(8004,6671,0)
(517,6949,0)
(1712,3751,0)
(3483,8254,0)
(824,8391,0)
(3170,640,0)
(1415,1269,0)
(3509,8111,0)
(8550,8391,0)
(391,3621,0)
(2546,7652,0)
(5475,4280,0)
(1675,8391,0)
(3999,3141,0)
(1716,1392,0)
(2682,7810,0)
(7679,53,0)
(7762,6400,0)
(6246,3419,0)
(248,8391,0)
(2239,6433,0)
(4348,4287,0)
(6737,8618,0)
(306,4329,0)
(6471,2242,0)
(3305,1586,0)
(5214,2112,0)
(3331,7387,0)
(3046,1276,0)
(6054,4764,0)
(1474,6649,0)
(1445,1380,0)
(5586,4619,0)
(755,2768,0)
(6279,2308,0)
(4918,5649,0)
(7097,2695,0)
(1810,3354,0)
(9001,7870,0)
(4034,3451,0)
(179,2620,0)
(6302,2527,0)
(7975,7079,0)
(5322,856,0)
(7118,7561,0)
(352,4724,0)
(1851,1875,0)
(8238,1149,0)
(6508,5938,0)
(7965,233,0)
(6816,1900,0)
(4110,4183,0)
(1604,1937,0)
(8552,1078,0)
(4228,8655,0)
(7129,8694,0)
(7360,6041,0)
(3849,7328,0)
(7897,7664,0)
(1332,1212,0)
(7932,8249,0)
(947,2368,0)
(4798,115,0)
(4788,1044,0)
(2771,6577,0)
(2446,7033,0)
(6343,4168,0)
(4900,4516,0)
(6369,4658,0)
(6876,5043,0)
(5283,4198,0)
(1762,6103,0)
(289,2360,0)
(2589,5127,0)
(4264,5964,0)
(2666,7258,0)
(3023,5036,0)
(2981,4442,0)
(7531,740,0)
(8664,115,0)
(4930,6478,0)
(5487,2074,0)
(4941,177,0)
(6965,1365,0)
(952,3451,0)
(2287,1270,0)
(7121,3292,0)
(3200,2464,0)
(3141,2527,0)
(353,3126,0)
(3481,474,0)
(1415,8160,0)
(4730,8274,0)
(7695,8879,0)
(1772,7969,0)
(7287,115,0)
(8182,1725,0)
(164,1935,0)
(7719,2559,0)
(5166,5238,0)
(7547,4497,0)
(1150,5435,0)
(1977,2987,0)
(5282,5667,0)
(410,4,0)
(8232,3522,0)
(2142,6102,0)
(3326,4148,0)
(1783,4876,0)
(882,1544,0)
(4850,8391,0)
(2089,5101,0)
(768,115,0)
(8723,115,0)
(3045,6376,0)
(5515,904,0)
(2378,7536,0)
(2187,5553,0)
(8510,1107,0)
(1834,8010,0)
(3584,2217,0)
(7458,4252,0)
(2705,1874,0)
(1284,3170,0)
(7779,8142,0)
(1223,6125,0)
(6771,115,0)
(1049,8783,0)
(4549,8391,0)
(7182,8391,0)
(577,5829,0)
(4711,624,0)
(3918,577,0)
(5996,6267,0)
(2829,2737,0)
(7397,2257,0)
(2396,447,0)
(6884,8391,0)
(7626,1158,0)
(1334,7984,0)
(2637,5141,0)
(79,8379,0)
(2847,7829,0)
(8223,8243,0)
(4200,3717,0)
(8249,8391,0)
(1415,6952,0)
(4860,4280,0)
(5033,3291,0)
(2594,5687,0)
(6246,8391,0)
(4658,8694,0)
(1055,2030,0)
(5109,3621,0)
(819,3733,0)
(3804,8111,0)
(3647,4689,0)
(750,7296,0)
(6107,1709,0)
(5805,7024,0)
(3014,7953,0)
(7632,4273,0)
(447,2396,0)
(2716,4742,0)
(6098,4362,0)
(6844,5100,0)
(5181,1831,0)
(3024,7059,0)
(3231,8366,0)
(650,611,0)
(4595,4087,0)
(2534,115,0)
(6950,6844,0)
(753,2748,0)
(5384,2350,0)
(8913,7470,0)
(5795,2845,0)
(5631,2241,0)
(8577,1648,0)
(5336,6030,0)
(1878,3477,0)
(4980,4299,0)
(5748,8391,0)
(7336,8742,0)
(5719,5645,0)
(5231,9131,0)
(3306,8655,0)
(5141,3556,0)
(7843,5070,0)
(2386,5829,0)
(7650,2885,0)
(383,3139,0)
(6522,115,0)
(7630,8774,0)
(2653,1900,0)
(2293,8391,0)
(1611,8029,0)
(2949,8167,0)
(5889,3837,0)
(9034,3585,0)
(4420,4474,0)
(7139,7834,0)
(364,6594,0)
(2656,2397,0)
(1611,2979,0)
(2941,3095,0)
(2385,4201,0)
(462,4565,0)
(3828,5012,0)
(8038,8458,0)
(6745,5485,0)
(1484,7029,0)
(4821,8391,0)
(3213,700,0)
(4197,1415,0)
(1351,91,0)
(1496,3511,0)
(424,3451,0)
(741,7746,0)
(5483,2043,0)
(5687,8113,0)
(2568,2311,0)
(7392,134,0)
(7081,208,0)
(1603,5499,0)
(1390,6608,0)
(8294,5734,0)
(67,4487,0)
(1810,2996,0)
(8918,2993,0)
(387,3806,0)
(1326,115,0)
(3256,8024,0)
(6428,883,0)
(4482,4840,0)
(47,6686,0)
(4933,1284,0)
(2388,7016,0)
(6192,3811,0)
(2696,83,0)
(3509,3565,0)
(4523,2959,0)
(4499,1149,0)
(7959,115,0)
(7930,6496,0)
(8070,5047,0)
(2106,4380,0)
(6279,1840,0)
(5761,6176,0)
(4887,1448,0)
(5610,7798,0)
(3358,2932,0)
(5567,6671,0)
(6632,8206,0)
(303,4536,0)
(2443,5721,0)
(8498,4155,0)
(8237,8391,0)
(7504,847,0)
(5004,104,0)
(5794,5584,0)
(5557,7030,0)
(5707,4270,0)
(5153,4785,0)
(1156,3014,0)
(3074,5138,0)
(1043,2522,0)
(6341,1347,0)
(896,4802,0)
(8949,519,0)
(8666,8391,0)
(4558,1984,0)
(3418,5736,0)
(5859,8377,0)
(2544,8458,0)
(1794,4307,0)
(1162,8430,0)
(474,6881,0)
(5781,1363,0)
(829,6577,0)
(2387,7516,0)
(6545,4444,0)
(2544,6968,0)
(5851,4121,0)
(5551,3553,0)
(3004,258,0)
(7050,3294,0)
(2469,3354,0)
(4302,6671,0)
(927,3512,0)
(2476,669,0)
(6217,6921,0)
(5632,6904,0)
(8281,8457,0)
(404,2685,0)
(2043,5924,0)
(6223,115,0)
(546,3150,0)
(6048,2921,0)
(4721,9087,0)
(5629,5181,0)
(5928,1602,0)
(409,3103,0)
(1613,7598,0)
(9132,3938,0)
(6711,1825,0)
(5908,6671,0)
(3487,3218,0)
(2652,9125,0)
(3259,6352,0)
(845,1947,0)
(7876,2625,0)
(2035,104,0)
(784,6858,0)
(8145,2263,0)
(2692,3947,0)
(6972,5156,0)
(3053,6446,0)
(6747,7340,0)
(8354,2721,0)
(2564,7055,0)
(4081,4327,0)
(5394,2612,0)
(2400,1601,0)
(5170,8550,0)
(5214,4587,0)
(4211,4006,0)
(5660,3173,0)
(8186,101,0)
(2350,3451,0)
(6873,6731,0)
(7382,6993,0)
(192,8313,0)
(2830,6910,0)
(5803,1121,0)
(8327,7059,0)
(6149,861,0)
(2699,6632,0)
(8736,7757,0)
(2330,7996,0)
(7921,9090,0)
(5209,8391,0)
(4724,352,0)
(101,115,0)
(8047,4722,0)
(8370,8091,0)
(2925,7965,0)
(1992,572,0)
(1042,1331,0)
(8741,5704,0)
(228,8843,0)
(1415,2096,0)
(5401,775,0)
(4628,6308,0)
(216,7357,0)
(7670,115,0)
(8764,2285,0)
(7907,3231,0)
(9087,1488,0)
(6142,6804,0)
(7462,115,0)
(3266,2237,0)
(8831,1438,0)
(2644,6241,0)
(2973,6671,0)
(3059,3103,0)
(871,859,0)
(4976,4637,0)
(4253,4522,0)
(163,4357,0)
(5638,1405,0)
(6153,8830,0)
(3275,1794,0)
(6879,5451,0)
(2471,5526,0)
(3141,4168,0)
(2262,1217,0)
(4874,6899,0)
(2817,6671,0)
(8601,3776,0)
(5929,8017,0)
(2846,3306,0)
(916,3833,0)
(1338,7205,0)
(5394,8391,0)
(5217,2657,0)
(3904,2375,0)
(8952,7067,0)
(1701,108,0)
(2014,8276,0)
(811,567,0)
(8334,499,0)
(2991,6236,0)
(7044,8026,0)
(4203,6671,0)
(592,115,0)
(6284,3215,0)
(3457,3630,0)
(4082,6803,0)
(914,4876,0)
(2139,2845,0)
(5045,2962,0)
(5189,3103,0)
(4650,9059,0)
(7214,1792,0)
(2853,6004,0)
(1414,824,0)
(1817,3871,0)
(4691,921,0)
(7812,6084,0)
(5275,713,0)
(3904,747,0)
(2707,6750,0)
(6530,8034,0)
(1924,115,0)
(224,3663,0)
(797,2940,0)
(4182,4282,0)
(4431,115,0)
(7233,507,0)
(9068,1312,0)
(667,1413,0)
(8589,5649,0)
(4103,4072,0)
(5809,4587,0)
(1921,6629,0)
(3547,7650,0)
(2279,4605,0)
(4098,1186,0)
(1415,2533,0)
(1663,7199,0)
(4525,1175,0)
(3566,6771,0)
(929,8121,0)
(6196,6150,0)
(5455,4007,0)
(2226,5733,0)
(6614,3595,0)
(9068,3184,0)
(3585,9034,0)
(1995,277,0)
(1211,3940,0)
(7246,5033,0)
(6964,4617,0)
(7384,4767,0)
(1599,1957,0)
(3232,2979,0)
(2085,7254,0)
(1703,1676,0)
(3346,253,0)
(7572,1209,0)
(3147,7608,0)
(6432,1930,0)
(6694,2423,0)
(7257,2995,0)
(833,4308,0)
(3633,5871,0)
(6511,8967,0)
(939,5832,0)
(9102,4861,0)
(774,8391,0)
(8458,1676,0)
(2522,2845,0)
(6149,3630,0)
(4432,4034,0)
(7754,6760,0)
(3042,7352,0)
(4064,8549,0)
(7164,2467,0)
(353,8391,0)
(177,1784,0)
(7778,6995,0)
(1415,6921,0)
(359,4619,0)
(1017,6577,0)
(6567,8423,0)
(3001,8391,0)
(8450,6539,0)
(644,8391,0)
(2627,701,0)
(6357,4822,0)
(3116,2286,0)
(151,6292,0)
(4914,6543,0)
(4375,9035,0)
(8038,8197,0)
(5737,5686,0)
(8530,2024,0)
(8661,6671,0)
(2569,2930,0)
(4859,6055,0)
(7161,5174,0)
(1837,6488,0)
(6881,6376,0)
(4122,6457,0)
(1967,2845,0)
(7318,356,0)
(703,155,0)
(1523,6356,0)
(1899,8391,0)
(5847,2257,0)
(7015,7404,0)
(2458,4856,0)
(2993,4544,0)
(7518,4444,0)
(3062,115,0)
(5608,777,0)
(1310,9038,0)
(451,3403,0)
(8155,5156,0)
(9117,8722,0)
(4619,386,0)
(2435,2091,0)
(7438,3599,0)
(7417,502,0)
(382,4158,0)
(7999,8484,0)
(7353,5383,0)
(5536,4201,0)
(5369,8391,0)
(4593,7031,0)
(3733,2720,0)
(1514,8725,0)
(7389,6973,0)
(8372,5315,0)
(7159,573,0)
(6505,7036,0)
(6419,9130,0)
(964,8709,0)
(3627,11,0)
(3836,5467,0)
(5520,4329,0)
(5679,255,0)
(1593,1799,0)
(8988,3541,0)
(7806,2771,0)
(8484,7999,0)
(8075,8242,0)
(6736,5506,0)
(980,6847,0)
(7318,7197,0)
(8774,3979,0)
(2544,2112,0)
(1462,8391,0)
(8219,5132,0)
(5094,2009,0)
(7264,8391,0)
(2509,463,0)
(3103,6671,0)
(6942,4785,0)
(6896,1254,0)
(6058,512,0)
(2499,711,0)
(1354,5829,0)
(415,7400,0)
(5216,6648,0)
(763,5012,0)
(6630,3871,0)
(2384,8391,0)
(1225,478,0)
(5412,2140,0)
(2234,8391,0)
(1382,1939,0)
(4113,2428,0)
(2388,5353,0)
(6419,8021,0)
(4141,7039,0)
(8193,6504,0)
(3860,6504,0)
(3537,3493,0)
(4837,6292,0)
(1588,2549,0)
(5827,8187,0)
(8245,5688,0)
(6590,7683,0)
(6485,1488,0)
(2573,1435,0)
(6775,9008,0)
(5324,6772,0)
(1229,5547,0)
(3921,1754,0)
(1691,8709,0)
(5849,7003,0)
(6921,646,0)
(7682,824,0)
(1415,700,0)
(1452,8391,0)
(8813,2346,0)
(5647,2504,0)
(8060,3058,0)
(9057,2821,0)
(3436,2096,0)
(9026,8391,0)
(7293,6671,0)
(8347,986,0)
(5920,6563,0)
(7706,4848,0)
(3683,553,0)
(1488,6868,0)
(6696,7374,0)
(5988,5556,0)
(6038,5054,0)
(5568,6646,0)
(5515,4311,0)
(4883,4015,0)
(1954,4340,0)
(1121,2935,0)
(5893,995,0)
(7525,2845,0)
(8225,3313,0)
(8130,7975,0)
(8374,8746,0)
(5649,115,0)
(4157,4308,0)
(476,4133,0)
(4899,5373,0)
(4366,8966,0)
(3493,4307,0)
(3505,5960,0)
(7038,1638,0)
(6872,8457,0)
(3445,4735,0)
(8909,8391,0)
(578,115,0)
(8016,2239,0)
(865,1190,0)
(1082,8391,0)
(1085,459,0)
(5741,6275,0)
(7940,2752,0)
(7646,8391,0)
(7135,1857,0)
(5066,3396,0)
(24,5345,0)
(3740,4404,0)
(5871,3633,0)
(5060,73,0)
(268,1149,0)
(378,6299,0)
(2422,4921,0)
(1650,2873,0)
(5366,7944,0)
(7247,8610,0)
(8246,7996,0)
(144,8683,0)
(4560,3313,0)
(7989,8391,0)
(4715,7272,0)
(6827,115,0)
(8742,2845,0)
(3386,5927,0)
(473,8391,0)
(1369,4876,0)
(760,8570,0)
(2468,8391,0)
(2999,4391,0)
(2093,3574,0)
(1037,2487,0)
(698,6524,0)
(485,7383,0)
(7717,100,0)
(7798,5840,0)
(2117,8391,0)
(1415,6388,0)
(5809,700,0)
(4791,5256,0)
(4283,9087,0)
(3740,115,0)
(7947,3687,0)
(3314,1180,0)
(6045,5189,0)
(5621,6176,0)
(5705,115,0)
(4778,1769,0)
(5638,1270,0)
(5498,2952,0)
(7488,1096,0)
(5214,9138,0)
(6380,3433,0)
(6397,8391,0)
(2878,7026,0)
(309,2452,0)
(6284,9130,0)
(8132,7258,0)
(7967,8874,0)
(249,1138,0)
(1304,7535,0)
(3560,614,0)
(4029,1500,0)
(8712,402,0)
(7399,459,0)
(8940,7222,0)
(5940,1168,0)
(3579,115,0)
(1180,9125,0)
(1742,171,0)
(3241,6151,0)
(6513,8391,0)
(4516,7672,0)
(974,6494,0)
(8162,8446,0)
(4314,2506,0)
(4580,8391,0)
(5949,536,0)
(6284,4587,0)
(3702,6671,0)
(6351,5562,0)
(8693,3173,0)
(8255,4464,0)
(3355,3800,0)
(4375,1826,0)
(5548,8391,0)
(7379,4258,0)
(5724,8656,0)
(6502,8614,0)
(3710,2558,0)
(6154,3012,0)
(752,6523,0)
(3279,4769,0)
(22,2824,0)
(4530,4434,0)
(4837,5196,0)
(5809,7039,0)
(691,3541,0)
(3567,3534,0)
(4231,11,0)
(7563,3604,0)
(8165,6636,0)
(5778,6648,0)
(241,8827,0)
(330,8863,0)
(4893,8477,0)
(757,6671,0)
(5896,2647,0)
(7098,1190,0)
(7054,3299,0)
(2755,3821,0)
(273,4510,0)
(5225,796,0)
(8296,2309,0)
(2609,8419,0)
(7775,4100,0)
(3317,2926,0)
(6166,1076,0)
(6652,8933,0)
(8902,123,0)
(7738,3368,0)
(6164,6388,0)
(4253,1410,0)
(7874,903,0)
(7108,6716,0)
(2062,1930,0)
(444,726,0)
(686,5283,0)
(2689,777,0)
(5424,2504,0)
(4382,3008,0)
(3810,3788,0)
(6057,115,0)
(4375,7039,0)
(7672,8709,0)
(3642,1293,0)
(2806,1461,0)
(5998,115,0)
(3440,2580,0)
(8977,779,0)
(6125,1223,0)
(972,8085,0)
(7437,2414,0)
(1690,6072,0)
(6975,8184,0)
(413,115,0)
(5638,3657,0)
(8709,7672,0)
(8008,8391,0)
(4328,5036,0)
(595,3451,0)
(7388,3625,0)
(7758,8695,0)
(4186,8744,0)
(9009,2537,0)
(4453,6922,0)
(5645,5719,0)
(3844,115,0)
(6325,115,0)
(4650,3451,0)
(882,6407,0)
(1039,5054,0)
(6801,1274,0)
(6579,6827,0)
(6762,4876,0)
(799,1623,0)
(4681,6137,0)
(7475,7296,0)
(4247,5209,0)
(6041,4620,0)
(3721,2904,0)
(7229,6671,0)
(8043,6216,0)
(753,8138,0)
(1803,484,0)
(8928,4781,0)
(2392,3165,0)
(1887,6671,0)
(2842,8391,0)
(1705,257,0)
(685,2553,0)
(8449,1544,0)
(3788,3810,0)
(6553,6318,0)
(235,4253,0)
(3039,1069,0)
(6933,6846,0)
(595,8391,0)
(1909,2628,0)
(6064,1121,0)
(3978,5991,0)
(5960,2935,0)
(775,8959,0)
(1126,6177,0)
(1325,89,0)
(3273,3619,0)
(7097,7577,0)
(6056,5391,0)
(1315,3466,0)
(6650,4735,0)
(682,4379,0)
(7067,8391,0)
(3611,4814,0)
(5443,4417,0)
(5954,1923,0)
(8592,8391,0)
(1930,8034,0)
(6569,2794,0)
(5738,2315,0)
(2301,8386,0)
(87,4501,0)
(5493,4390,0)
(3413,8683,0)
(1675,7105,0)
(1451,4571,0)
(7845,6278,0)
(6064,5512,0)
(5998,1351,0)
(4565,5181,0)
(6677,3553,0)
(5223,3725,0)
(1138,6534,0)
(2659,8582,0)
(6726,5156,0)
(8902,3713,0)
(6441,6671,0)
(8946,890,0)
(4016,1637,0)
(5253,5821,0)
(5582,4624,0)
(3804,6356,0)
(8641,942,0)
(5025,8391,0)
(1792,115,0)
(4165,3781,0)
(4308,4157,0)
(1035,5947,0)
(6384,1986,0)
(7248,988,0)
(5545,7827,0)
(8549,151,0)
(4149,8391,0)
(6419,1120,0)
(7756,5153,0)
(7066,4814,0)
(2316,3577,0)
(4043,2845,0)
(7722,1173,0)
(4375,3889,0)
(848,1094,0)
(7367,8391,0)
(4252,7458,0)
(53,8379,0)
(861,3580,0)
(4955,5548,0)
(768,3368,0)
(4813,7608,0)
(5229,5474,0)
(312,3797,0)
(7958,6155,0)
(6439,331,0)
(2308,1546,0)
(1570,8360,0)
(3114,115,0)
(7710,6722,0)
(6386,4880,0)
(2794,4850,0)
(2358,6317,0)
(4272,6430,0)
(7545,4389,0)
(8018,7210,0)
(8633,6899,0)
(2565,506,0)
(8501,2951,0)
(679,4,0)
(8043,3037,0)
(5027,8558,0)
(3259,1488,0)
(741,4340,0)
(4466,8391,0)
(2422,7452,0)
(1000,6783,0)
(5863,6321,0)
(6652,5716,0)
(1231,972,0)
(2868,3729,0)
(5556,900,0)
(1747,8738,0)
(8415,25,0)
(2919,791,0)
(5948,3811,0)
(2873,4287,0)
(8789,8529,0)
(4016,1644,0)
(43,5846,0)
(4952,7549,0)
(2010,4503,0)
(4689,4966,0)
(1159,2405,0)
(2181,6022,0)
(4178,5615,0)
(7160,3417,0)
(7340,6656,0)
(1897,6671,0)
(5768,2072,0)
(4118,6964,0)
(4279,8592,0)
(1333,8854,0)
(4105,9114,0)
(2917,5631,0)
(1047,8391,0)
(3873,8783,0)
(6121,5156,0)
(7139,519,0)
(5947,6577,0)
(60,5094,0)
(4014,8279,0)
(5444,1099,0)
(6325,4799,0)
(4549,115,0)
(193,2,0)
(5000,8189,0)
(8142,7888,0)
(691,5420,0)
(7670,8147,0)
(7622,197,0)
(1705,3904,0)
(4045,8285,0)
(2032,6897,0)
(4621,6556,0)
(3356,8391,0)
(1306,7150,0)
(4819,4413,0)
(7812,2309,0)
(8371,159,0)
(1347,6341,0)
(9013,6518,0)
(4957,4507,0)
(7975,1701,0)
(2543,6649,0)
(4043,661,0)
(7093,8043,0)
(6360,8391,0)
(5685,8849,0)
(5638,8458,0)
(4828,8391,0)
(1033,1269,0)
(1586,3305,0)
(5041,1640,0)
(4800,7440,0)
(50,5351,0)
(4919,3963,0)
(5614,624,0)
(1144,2065,0)
(3571,7145,0)
(7230,4842,0)
(6754,3257,0)
(1824,5851,0)
(4932,5594,0)
(7163,8244,0)
(5351,50,0)
(724,8391,0)
(8868,6799,0)
(7408,3875,0)
(8568,1105,0)
(1174,6057,0)
(785,4326,0)
(7627,2348,0)
(3832,1385,0)
(1535,689,0)
(4512,8323,0)
(1926,8801,0)
(3602,7064,0)
(5292,3860,0)
(2066,4360,0)
(6071,6950,0)
(4176,8391,0)
(5683,1348,0)
(5049,6014,0)
(5935,2544,0)
(559,8715,0)
(1247,562,0)
(9067,8391,0)
(7170,8846,0)
(7938,1889,0)
(1622,8035,0)
(7769,2343,0)
(1853,115,0)
(8142,1410,0)
(8682,6671,0)
(2413,3571,0)
(8071,5868,0)
(3804,87,0)
(1155,2558,0)
(2719,301,0)
(4227,1103,0)
(8852,4125,0)
(8253,5813,0)
(3697,6730,0)
(1117,1858,0)
(4663,1709,0)
(7615,5065,0)
(7908,118,0)
(7273,7139,0)
(2667,4606,0)
(3625,8781,0)
(5422,1982,0)
(2104,4876,0)
(9047,8391,0)
(4814,7066,0)
(1266,2043,0)
(8587,3431,0)
(3211,264,0)
(734,1843,0)
(7077,83,0)
(4627,4974,0)
(7667,7628,0)
(2645,6096,0)
(7211,3696,0)
(3817,1783,0)
(5585,1957,0)
(8072,402,0)
(4570,1431,0)
(2789,1535,0)
(8857,3257,0)
(8964,1406,0)
(6985,7765,0)
(569,4326,0)
(6464,7989,0)
(4375,2065,0)
(7449,7199,0)
(4280,5475,0)
(2947,4556,0)
(7470,4367,0)
(4973,101,0)
(1061,115,0)
(2077,7363,0)
(2111,7030,0)
(1770,8319,0)
(1121,4487,0)
(2667,2978,0)
(4489,2115,0)
(7890,4876,0)
(1415,1270,0)
(2063,122,0)
(3139,212,0)
(3403,7671,0)
(504,5549,0)
(3696,2626,0)
(2057,3821,0)
(4542,114,0)
(7986,4785,0)
(7159,8391,0)
(464,3430,0)
(4012,8391,0)
(2197,3633,0)
(26,7197,0)
(2714,8609,0)
(8573,4104,0)
(2647,8391,0)
(6527,1850,0)
(3131,9029,0)
(3480,5900,0)
(6428,2954,0)
(3986,362,0)
(5138,8637,0)
(933,4883,0)
(4769,3279,0)
(4146,2896,0)
(6018,1069,0)
(2396,6538,0)
(2099,2309,0)
(3604,1906,0)
(2873,115,0)
(2788,6671,0)
(6424,1392,0)
(1850,8677,0)
(2099,6084,0)
(4024,6671,0)
(7617,795,0)
(5022,1955,0)
(2651,3090,0)
(1564,7984,0)
(8773,8670,0)
(5606,7604,0)
(2181,1322,0)
(4277,6659,0)
(5530,338,0)
(1971,3433,0)
(2634,1957,0)
(3804,4149,0)
(902,115,0)
(3449,7350,0)
(494,6671,0)
(4832,6844,0)
(4352,5953,0)
(3254,8391,0)
(2188,2229,0)
(1199,3130,0)
(3806,8546,0)
(2381,3451,0)
(7838,6972,0)
(6716,7108,0)
(5876,299,0)
(1329,7974,0)
(84,4625,0)
(317,5394,0)
(919,5954,0)
(54,4864,0)
(1021,7551,0)
(1017,2740,0)
(4845,1638,0)
(1121,973,0)
(4019,2065,0)
(3910,8588,0)
(1549,1432,0)
(2522,1043,0)
(2898,3984,0)
(1582,8335,0)
(613,2453,0)
(1579,4785,0)
(8473,255,0)
(3196,416,0)
(5121,5496,0)
(6615,6671,0)
(100,8391,0)
(4116,8391,0)
(6520,5932,0)
(4718,8335,0)
(7646,115,0)
(8514,6246,0)
(5615,4178,0)
(8378,4038,0)
(5762,8667,0)
(3912,7398,0)
(4460,2190,0)
(8884,6597,0)
(5654,8989,0)
(4223,4077,0)
(5402,115,0)
(1082,115,0)
(4262,920,0)
(1209,7996,0)
(4212,8391,0)
(0,1719,0)
(2287,6474,0)
(9007,7210,0)
(6597,8884,0)
(2296,5938,0)
(4777,1177,0)
(3900,9050,0)
(3101,6598,0)
(5836,3445,0)
(6241,2644,0)
(3764,1896,0)
(5786,8455,0)
(5601,8083,0)
(8446,8162,0)
(1982,6791,0)
(2211,1891,0)
(7095,9035,0)
(8497,115,0)
(4608,2266,0)
(271,6741,0)
(7337,1259,0)
(5053,7524,0)
(1238,8879,0)
(4210,2604,0)
(7759,6536,0)
(7424,4574,0)
(5918,6385,0)
(6888,115,0)
(6699,578,0)
(829,4310,0)
(2093,8538,0)
(7626,1405,0)
(4232,115,0)
(5109,409,0)
(6076,5749,0)
(5516,7328,0)
(7024,5805,0)
(2891,2152,0)
(8666,2845,0)
(8074,1708,0)
(8575,8797,0)
(2889,3730,0)
(7585,3791,0)
(4798,8391,0)
(1415,6649,0)
(7335,3396,0)
(2094,8391,0)
(3684,2549,0)
(2268,144,0)
(3000,8722,0)
(2287,6968,0)
(4978,523,0)
(3805,7152,0)
(7626,7039,0)
(595,2674,0)
(7568,7659,0)
(1725,6671,0)
(6939,716,0)
(968,3285,0)
(7954,5104,0)
(3738,351,0)
(3184,2049,0)
(3123,3629,0)
(6853,386,0)
(2100,4352,0)
(2625,4792,0)
(1049,6557,0)
(6204,6378,0)
(3015,7571,0)
(357,353,0)
(2350,8391,0)
(3542,5779,0)
(4209,6402,0)
(8847,8296,0)
(3210,2835,0)
(2591,8587,0)
(5569,4560,0)
(1160,4785,0)
(2196,7251,0)
(7966,2112,0)
(7369,4838,0)
(5690,7679,0)
(1954,2896,0)
(7858,3797,0)
(1714,4741,0)
(1915,4664,0)
(6794,4992,0)
(2861,1411,0)
(4825,1597,0)
(7258,7150,0)
(3700,1890,0)
(6632,115,0)
(5325,6080,0)
(1324,4018,0)
(6064,4340,0)
(1748,8558,0)
(3356,115,0)
(5051,4272,0)
(7085,8391,0)
(7997,3363,0)
(8574,8740,0)
(7150,300,0)
(5383,115,0)
(2992,6808,0)
(8433,6167,0)
(2315,6758,0)
(5810,5419,0)
(1896,9106,0)
(5968,8099,0)
(8862,594,0)
(6033,1850,0)
(2532,4431,0)
(8543,637,0)
(5237,5868,0)
(2862,966,0)
(5250,7418,0)
(511,7672,0)
(8231,3950,0)
(7026,7988,0)
(397,1373,0)
(3586,154,0)
(5721,115,0)
(3633,7551,0)
(6966,8801,0)
(1506,6269,0)
(7089,4847,0)
(4546,5819,0)
(3582,1149,0)
(3688,1269,0)
(6829,8155,0)
(3804,5452,0)
(2052,4772,0)
(4193,5802,0)
(889,6425,0)
(8109,777,0)
(8001,2931,0)
(3579,8391,0)
(8674,5196,0)
(2380,1045,0)
(1181,1809,0)
(6780,8461,0)
(5721,8391,0)
(6449,8391,0)
(688,6072,0)
(7824,7963,0)
(3719,4071,0)
(6633,6871,0)
(6158,977,0)
(2874,6662,0)
(2567,115,0)
(6777,1222,0)
(5813,8391,0)
(2625,5982,0)
(4452,6671,0)
(38,6854,0)
(1567,3451,0)
(1678,3053,0)
(5816,7264,0)
(7375,8845,0)
(884,8099,0)
(5712,7552,0)
(3820,1892,0)
(1427,7299,0)
(4375,9138,0)
(4544,7113,0)
(7703,2158,0)
(5268,4342,0)
(2662,4549,0)
(1313,3973,0)
(3190,5555,0)
(4375,6921,0)
(1858,1117,0)
(2777,6577,0)
(5684,2879,0)
(5280,8197,0)
(3270,2623,0)
(5191,5239,0)
(6325,8391,0)
(9043,5245,0)
(5117,8391,0)
(6542,572,0)
(7356,7176,0)
(5489,8391,0)
(1257,3785,0)
(8717,3831,0)
(1137,6771,0)
(3078,8391,0)
(245,6278,0)
(1955,4540,0)
(651,6230,0)
(8352,2024,0)
(5619,7833,0)
(7626,8021,0)
(5529,6671,0)
(4873,2112,0)
(6078,1305,0)
(1230,6973,0)
(8393,3757,0)
(3213,3889,0)
(5020,4087,0)
(4515,3936,0)
(3240,6577,0)
(5625,3731,0)
(4171,2746,0)
(8136,8391,0)
(5914,2043,0)
(7107,8391,0)
(7656,8391,0)
(8844,1013,0)
(8419,2900,0)
(324,2401,0)
(4976,1488,0)
(321,6451,0)
(6509,1980,0)
(4764,6054,0)
(6359,5301,0)
(8160,807,0)
(7290,2470,0)
(3556,2285,0)
(6659,4277,0)
(7408,3621,0)
(3143,4367,0)
(7607,8818,0)
(196,8429,0)
(2059,8388,0)
(6776,8348,0)
(3935,4490,0)
(7863,115,0)
(8302,4666,0)
(518,7120,0)
(1097,5162,0)
(6824,7013,0)
(4700,1488,0)
(5169,838,0)
(7740,5238,0)
(7013,8794,0)
(8973,3078,0)
(8429,7212,0)
(6068,3780,0)
(2433,5432,0)
(8936,2866,0)
(1637,4016,0)
(2694,8258,0)
(8564,3722,0)
(1131,4168,0)
(5892,8600,0)
(2354,8391,0)
(1633,7892,0)
(8757,2673,0)
(7966,6649,0)
(3899,2845,0)
(4581,3807,0)
(6786,3149,0)
(8633,646,0)
(5947,777,0)
(9092,6279,0)
(134,7392,0)
(2906,2401,0)
(5645,7570,0)
(8913,115,0)
(3325,5519,0)
(2706,5371,0)
(3342,8405,0)
(8567,3863,0)
(6762,5156,0)
(8700,8470,0)
(3984,189,0)
(6338,7611,1)
(503,3171,1)
(8161,6781,1)
(751,8453,1)
(8746,3783,1)
(301,2719,1)
(3051,5981,1)
(8967,6511,1)
(33,4744,1)
(3043,115,1)
(4725,7306,1)
(4072,115,1)
(4138,1676,1)
(5390,7193,1)
(7444,5156,1)
(8451,1149,1)
(8044,4420,1)
(3454,8996,1)
(5693,1251,1)
(5711,7000,1)
(5117,8115,1)
(7288,913,1)
(1680,8229,1)
(6044,3048,1)
(5394,8391,1)
(1336,8637,1)
(1332,1086,1)
(5444,5330,1)
(7965,8947,1)
(6384,1986,1)
(4283,4135,1)
(4408,5423,1)
(2017,726,1)
(4634,3193,1)
(6146,1488,1)
(6649,6051,1)
(5638,2065,1)
(3804,8111,1)
(5118,4305,1)
(5132,8219,1)
(7875,9113,1)
(1390,2165,1)
(4116,8391,1)
(6389,1332,1)
(7264,8221,1)
(2909,115,1)
(747,1700,1)
(6988,1411,1)
(2904,115,1)
(6310,2410,1)
(8794,1874,1)
(126,2141,1)
(3291,5033,1)
(3260,115,1)
(304,2984,1)
(5556,5988,1)
(2769,6283,1)
(6108,7028,1)
(7198,421,1)
(1063,5398,1)
(1269,1149,1)
(1542,8391,1)
(1851,1983,1)
(1086,1149,1)
(4418,4021,1)
(2144,1352,1)
(2346,8813,1)
(4674,7404,1)
(6429,8391,1)
(4806,3497,1)
(3886,2217,1)
(453,7983,1)
(1930,6432,1)
(6053,9047,1)
(4158,382,1)
(3868,115,1)
(2636,2219,1)
(4305,6209,1)
(7651,1249,1)
(1210,7842,1)
(8645,7949,1)
(5598,1167,1)
(6571,7124,1)
(1017,5837,1)
(2480,1267,1)
(1546,3467,1)
(3579,5663,1)
(1238,8391,1)
(5869,1410,1)
(6419,8458,1)
(3611,3093,1)
(2544,1158,1)
(6731,6873,1)
(7828,1479,1)
(5540,182,1)
(4157,33,1)
(6050,2266,1)
(798,7849,1)
(4089,8391,1)
(6764,4934,1)
(5953,1149,1)
(4182,5829,1)
(129,6757,1)
(1014,2983,1)
(2729,2757,1)
(6626,8901,1)
(4758,115,1)
(2261,6899,1)
(9124,7311,1)
(5251,2937,1)
(699,6487,1)
(8396,8354,1)
(3243,5886,1)
(3048,7196,1)
(3028,6017,1)
(7703,5129,1)
(2825,251,1)
(8744,4186,1)
(5592,502,1)
(1042,1331,1)
(6365,7762,1)
(832,735,1)
(8263,4609,1)
(5604,102,1)
(2326,2585,1)
(7398,8391,1)
(8259,4599,1)
(2281,7224,1)
(7230,4842,1)
(6875,8391,1)
(805,2961,1)
(1240,2512,1)
(1644,3782,1)
(5478,6207,1)
(2041,7282,1)
(8343,7798,1)
(2288,115,1)
(6695,7310,1)
(9014,7619,1)
(1943,8489,1)
(6207,6468,1)
(4001,8391,1)
(3785,948,1)
(1079,8391,1)
(6340,8450,1)
(4291,5467,1)
(94,7851,1)
(8413,1348,1)
(3431,8587,1)
(6246,2138,1)
(595,3796,1)
(5555,8391,1)
(5664,1379,1)
(5827,3541,1)
(4711,115,1)
(8656,5724,1)
(6196,1295,1)
(8697,8400,1)
(2287,1280,1)
(1520,8589,1)
(1970,195,1)
(4323,1688,1)
(5419,8391,1)
(8648,8391,1)
(8355,8554,1)
(1925,5165,1)
(327,5607,1)
(4529,8096,1)
(1031,8818,1)
(4919,6541,1)
(7554,1918,1)
(87,9111,1)
(6502,6374,1)
(8471,1360,1)
(4505,6919,1)
(5530,446,1)
(1898,569,1)
(6369,3250,1)
(3897,4069,1)
(8378,3126,1)
(8698,579,1)
(2543,6649,1)
(3046,4096,1)
(6632,115,1)
(6488,1837,1)
(6726,434,1)
(2335,2905,1)
(2526,2092,1)
(5107,1154,1)
(8275,4961,1)
(7885,588,1)
(5893,3640,1)
(7904,7551,1)
(6138,3577,1)
(1567,6898,1)
(8136,7345,1)
(5436,3906,1)
(1023,6636,1)
(5391,7362,1)
(7810,4657,1)
(5451,6879,1)
(4421,7909,1)
(7054,3299,1)
(4560,8535,1)
(7131,8125,1)
(4105,2812,1)
(5965,2043,1)
(5946,7805,1)
(4454,1483,1)
(8742,2845,1)
(6013,1369,1)
(8782,8949,1)
(830,4552,1)
(4572,6155,1)
(2495,5010,1)
(8041,3283,1)
(6412,7276,1)
(25,115,1)
(4122,6457,1)
(6715,8391,1)
(2234,8391,1)
(6215,115,1)
(8584,3017,1)
(6748,7107,1)
(1832,8391,1)
(3963,4919,1)
(7294,535,1)
(6710,125,1)
(1245,648,1)
(5451,115,1)
(112,6497,1)
(741,2896,1)
(8142,2303,1)
(6878,2406,1)
(3529,2561,1)
(8232,6261,1)
(3228,7933,1)
(3783,855,1)
(8210,451,1)
(930,400,1)
(5195,4505,1)
(6816,7147,1)
(5073,3436,1)
(4417,2845,1)
(1326,8391,1)
(6795,8391,1)
(8464,810,1)
(5338,1609,1)
(8259,115,1)
(6502,2544,1)
(8121,4617,1)
(5824,255,1)
(239,4316,1)
(5142,575,1)
(6325,8391,1)
(6688,9082,1)
(2224,2739,1)
(2465,479,1)
(4813,3147,1)
(7641,6602,1)
(9065,6844,1)
(2541,8576,1)
(2255,8794,1)
(6425,2339,1)
(1486,7874,1)
(8366,115,1)
(7532,8596,1)
(1935,2536,1)
(4375,7140,1)
(6552,2765,1)
(5687,2594,1)
(5371,8391,1)
(7396,5086,1)
(7983,6401,1)
(6137,7622,1)
(6847,980,1)
(5871,9034,1)
(8743,1832,1)
(3657,306,1)
(7076,6445,1)
(594,5720,1)
(5424,1386,1)
(3201,5695,1)
(1234,3455,1)
(6659,4688,1)
(6956,8239,1)
(41,252,1)
(5628,6021,1)
(5419,115,1)
(1187,3527,1)
(6318,115,1)
(7244,1498,1)
(3138,4067,1)
(6831,8107,1)
(7124,4055,1)
(7197,8391,1)
(1876,1950,1)
(4662,8709,1)
(5548,8391,1)
(5656,3062,1)
(1986,7536,1)
(2346,5129,1)
(6148,7138,1)
(5239,660,1)
(5747,7573,1)
(7539,1245,1)
(4375,6921,1)
(7058,8540,1)
(5398,2265,1)
(2873,6927,1)
(2306,7795,1)
(3553,5551,1)
(7980,3875,1)
(6259,4212,1)
(5898,7300,1)
(4073,3863,1)
(8497,8391,1)
(784,1411,1)
(5066,1190,1)
(7951,7720,1)
(7050,7075,1)
(2669,7841,1)
(1568,7816,1)
(3236,5437,1)
(1354,5829,1)
(2371,8756,1)
(6829,654,1)
(8657,7939,1)
(2477,8600,1)
(8633,5932,1)
(3265,4435,1)
(4048,3665,1)
(3758,689,1)
(6657,1149,1)
(2322,2756,1)
(4705,1009,1)
(100,8391,1)
(8367,2789,1)
(8144,8276,1)
(5406,60,1)
(7851,4687,1)
(6267,5996,1)
(2287,2955,1)
(5290,5156,1)
(2314,8048,1)
(909,2845,1)
(8264,1031,1)
(3225,1274,1)
(3158,8984,1)
(741,7577,1)
(2926,2895,1)
(3131,1450,1)
(7614,1311,1)
(7079,7975,1)
(2397,2656,1)
(7656,8391,1)
(5922,7465,1)
(1316,2378,1)
(649,5367,1)
(2669,8098,1)
(3804,1405,1)
(5450,6498,1)
(4124,5880,1)
(7941,78,1)
(3077,2279,1)
(3164,8175,1)
(2307,4924,1)
(2094,115,1)
(5784,6053,1)
(65,2346,1)
(7030,2487,1)
(5997,4757,1)
(3691,72,1)
(717,6483,1)
(3972,9057,1)
(1052,3960,1)
(8562,1653,1)
(8012,550,1)
(4136,7768,1)
(1669,1354,1)
(1368,3254,1)
(5684,6150,1)
(7246,5811,1)
(3629,9029,1)
(5638,8471,1)
(4424,4371,1)
(602,7378,1)
(8578,5156,1)
(6898,1176,1)
(8013,636,1)
(4103,8410,1)
(960,8065,1)
(1135,3460,1)
(1227,8823,1)
(6969,2210,1)
(2190,5402,1)
(1183,1223,1)
(2189,6513,1)
(8843,8993,1)
(5468,1514,1)
(6655,6995,1)
(3949,46,1)
(6502,6284,1)
(5248,3345,1)
(4417,8391,1)
(381,8766,1)
(1552,1683,1)
(5709,4883,1)
(4798,4649,1)
(6428,3315,1)
(6762,2944,1)
(4562,4941,1)
(1099,1308,1)
(311,4210,1)
(8431,1394,1)
(3378,8176,1)
(578,115,1)
(3298,5296,1)
(8819,7678,1)
(8641,8932,1)
(7947,7340,1)
(547,2447,1)
(2221,5867,1)
(5101,8211,1)
(2751,6622,1)
(8336,4757,1)
(8435,1149,1)
(4375,2861,1)
(6802,3758,1)
(8142,3983,1)
(904,2058,1)
(6455,7416,1)
(5,8391,1)
(3804,3215,1)
(6371,8185,1)
(5936,874,1)
(5237,7298,1)
(6663,115,1)
(5705,7708,1)
(3545,8391,1)
(7980,6084,1)
(4477,7953,1)
(7421,2007,1)
(5376,4361,1)
(2621,1905,1)
(4731,3929,1)
(2951,8501,1)
(1597,4825,1)
(7280,4287,1)
(8114,9074,1)
(7233,507,1)
(7676,8824,1)
(7966,8458,1)
(887,5592,1)
(109,5441,1)
(7613,8210,1)
(7043,1656,1)
(6038,8391,1)
(6888,4786,1)
(8716,7724,1)
(924,4668,1)
(3804,4449,1)
(3362,6577,1)
(5290,3364,1)
(1904,2911,1)
(4038,6220,1)
(8980,1465,1)
(2379,4729,1)
(6449,115,1)
(6360,3621,1)
(2632,3226,1)
(2618,8695,1)
(2333,4352,1)
(2173,2065,1)
(7708,8971,1)
(5332,8528,1)
(1444,6385,1)
(8155,8511,1)
(2344,4308,1)
(1719,8470,1)
(5823,4704,1)
(7273,2459,1)
(7535,1168,1)
(8726,8660,1)
(5785,6288,1)
(6478,5683,1)
(2135,6878,1)
(2696,83,1)
(3476,6741,1)
(8198,2501,1)
(7906,3727,1)
(8860,4581,1)
(504,6521,1)
(1328,5149,1)
(3043,8391,1)
(4651,266,1)
(8038,4149,1)
(616,1792,1)
(378,4541,1)
(3104,5433,1)
(351,2836,1)
(7988,8391,1)
(3664,2968,1)
(1415,3377,1)
(700,6073,1)
(1829,6935,1)
(7391,2846,1)
(3318,8539,1)
(8152,969,1)
(8592,8391,1)
(1944,2804,1)
(2930,5062,1)
(291,3256,1)
(3576,2413,1)
(7958,6630,1)
(2512,6575,1)
(3703,7278,1)
(7292,3733,1)
(6689,3165,1)
(8307,8690,1)
(1909,1404,1)
(5770,5831,1)
(2197,9034,1)
(6958,2035,1)
(3193,8699,1)
(1290,6027,1)
(5186,8654,1)
(2324,1014,1)
(5490,1361,1)
(7180,6253,1)
(8669,5200,1)
(5613,4271,1)
(1833,3310,1)
(1224,5487,1)
(897,2581,1)
(6793,571,1)
(1383,5162,1)
(3358,2932,1)
(8238,8696,1)
(4924,8656,1)
(3151,4876,1)
(9113,4583,1)
(8921,4391,1)
(7626,2650,1)
(923,327,1)
(8616,2845,1)
(1510,139,1)
(3913,4644,1)
(3871,1817,1)
(5022,7580,1)
(3507,5156,1)
(1920,7153,1)
(6721,7148,1)
(1754,3451,1)
(6931,8280,1)
(620,5572,1)
(3389,6182,1)
(1394,1568,1)
(8944,1049,1)
(6886,1948,1)
(4687,3043,1)
(5631,2917,1)
(2665,2623,1)
(8880,6782,1)
(4976,8369,1)
(569,7898,1)
(4510,554,1)
(8379,79,1)
(5751,7445,1)
(6733,6461,1)
(822,7102,1)
(2655,2667,1)
(4620,6159,1)
(3812,3106,1)
(5561,6766,1)
(3400,1530,1)
(6859,8807,1)
(891,8732,1)
(4222,1110,1)
(4114,8289,1)
(4604,6821,1)
(7735,3717,1)
(7801,4022,1)
(5757,6094,1)
(642,7972,1)
(5202,8285,1)
(7325,8941,1)
(688,3387,1)
(223,5474,1)
(2317,115,1)
(4041,1002,1)
(8009,115,1)
(3690,115,1)
(7099,879,1)
(6927,1650,1)
(262,1448,1)
(6137,724,1)
(2393,2550,1)
(8578,9039,1)
(5801,3064,1)
(7844,5335,1)
(7796,6151,1)
(736,9105,1)
(7244,22,1)
(8271,8786,1)
(6960,1462,1)
(8097,1806,1)
(8131,5290,1)
(6855,5428,1)
(994,7444,1)
(6417,2403,1)
(9019,8140,1)
(965,9125,1)
(598,2414,1)
(6442,8571,1)
(3705,5018,1)
(6972,7838,1)
(8709,115,1)
(1380,8391,1)
(5401,858,1)
(4167,2953,1)
(237,356,1)
(1559,3496,1)
(3598,7050,1)
(3509,3889,1)
(2334,7704,1)
(2537,9009,1)
(5189,5283,1)
(7001,7413,1)
(4147,1661,1)
(4671,7447,1)
(3294,4006,1)
(6198,8391,1)
(3151,5156,1)
(3072,4188,1)
(2677,115,1)
(928,2620,1)
(7568,1482,1)
(6419,8021,1)
(1792,2845,1)
(8871,4200,1)
(269,5297,1)
(2744,1909,1)
(784,2116,1)
(1643,8537,1)
(775,115,1)
(4976,1488,1)
(4186,6035,1)
(8572,3468,1)
(3318,8391,1)
(8913,8391,1)
(7943,3627,1)
(9010,8391,1)
(8078,5171,1)
(2299,8391,1)
(5640,8391,1)
(2333,5836,1)
(3792,1754,1)
(7367,115,1)
(1967,8391,1)
(8361,2751,1)
(5580,2927,1)
(6636,6846,1)
(6883,387,1)
(4342,4727,1)
(8439,6752,1)
(3007,1237,1)
(2587,4480,1)
(2446,7172,1)
(9040,1692,1)
(4792,4321,1)
(2372,1419,1)
(8165,6636,1)
(2503,2785,1)
(6788,2046,1)
(1873,115,1)
(4558,1984,1)
(5041,1410,1)
(7141,4967,1)
(1231,8391,1)
(4467,7955,1)
(2395,4446,1)
(8105,6765,1)
(6662,1194,1)
(2171,2613,1)
(2732,7025,1)
(1205,6181,1)
(980,7856,1)
(5950,642,1)
(8430,2122,1)
(7295,6420,1)
(2337,1559,1)
(626,7873,1)
(7458,1757,1)
(8055,115,1)
(6881,4876,1)
(2064,118,1)
(5532,2162,1)
(684,4093,1)
(7861,2204,1)
(7328,5516,1)
(7437,5819,1)
(2640,6066,1)
(9008,6775,1)
(6928,2548,1)
(8791,5906,1)
(7184,8222,1)
(1908,4252,1)
(2035,333,1)
(3866,2730,1)
(4265,3973,1)
(665,8624,1)
(3908,4159,1)
(1041,7501,1)
(7486,340,1)
(2823,8391,1)
(5491,2524,1)
(1056,8722,1)
(6842,6424,1)
(5300,7066,1)
(1107,4904,1)
(2388,5353,1)
(2089,5101,1)
(4293,2927,1)
(7075,8391,1)
(1610,3184,1)
(6027,4009,1)
(2683,8391,1)
(7990,4252,1)
(2283,1018,1)
(3242,2803,1)
(6973,115,1)
(5748,8391,1)
(4764,6054,1)
(7790,8860,1)
(2698,4875,1)
(2661,4875,1)
(1259,7337,1)
(1385,3614,1)
(7927,7906,1)
(6608,8391,1)
(3881,1181,1)
(7038,115,1)
(4898,2340,1)
(8101,8198,1)
(4732,5156,1)
(1906,9070,1)
(3859,3020,1)
(4313,3779,1)
(4828,4354,1)
(4745,7238,1)
(6480,3695,1)
(610,3351,1)
(7242,2027,1)
(8188,6892,1)
(7172,1945,1)
(5502,4182,1)
(6800,7917,1)
(7354,7860,1)
(936,8110,1)
(8006,7088,1)
(348,970,1)
(7991,1204,1)
(6128,8669,1)
(92,1764,1)
(1508,5099,1)
(3534,8391,1)
(5519,2845,1)
(6727,3115,1)
(7278,5483,1)
(1528,4948,1)
(2415,908,1)
(5325,6802,1)
(2271,3035,1)
(7750,4500,1)
(2234,115,1)
(8749,7422,1)
(395,6580,1)
(8608,5547,1)
(7728,6583,1)
(6734,1248,1)
(4904,9142,1)
(3915,2253,1)
(6896,7208,1)
(7753,8524,1)
(4627,2570,1)
(7678,7433,1)
(208,7105,1)
(3733,2720,1)
(1742,1118,1)
(6410,6500,1)
(2099,9059,1)
(3259,3623,1)
(7149,8290,1)
(1999,6549,1)
(6432,2062,1)
(6882,1938,1)
(4928,2150,1)
(207,1607,1)
(7569,6657,1)
(6457,6150,1)
(6764,8252,1)
(5978,1640,1)
(861,3247,1)
(5183,3718,1)
(8201,4083,1)
(7920,3936,1)
(4298,3015,1)
(7988,115,1)
(5851,1151,1)
(333,6570,1)
(2104,4876,1)
(1090,2098,1)
(1492,6219,1)
(4910,5762,1)
(5776,5855,1)
(3692,616,1)
(2818,8391,1)
(4574,7602,1)
(8038,8021,1)
(3699,8391,1)
(7198,8391,1)
(3268,8391,1)
(2984,475,1)
(3054,655,1)
(4522,6456,1)
(3000,2274,1)
(539,115,1)
(5603,1479,1)
(5055,2843,1)
(8578,4876,1)
(1795,6971,1)
(3989,6780,1)
(2350,7326,1)
(7019,1076,1)
(3658,4239,1)
(398,1654,1)
(8325,5656,1)
(3537,3493,1)
(5597,7921,1)
(7488,202,1)
(4881,5834,1)
(6200,6215,1)
(4024,4732,1)
(8760,2714,1)
(1525,2334,1)
(5239,4172,1)
(6737,8618,1)
(1490,5732,1)
(5759,1723,1)
(4749,7711,1)
(2094,5450,1)
(8324,6490,1)
(5155,2850,1)
(1270,1087,1)
(3509,2112,1)
(1118,8952,1)
(6552,3621,1)
(2387,690,1)
(8719,6116,1)
(2516,3679,1)
(2979,1611,1)
(6549,4796,1)
(6993,2858,1)
(7434,2407,1)
(2983,1164,1)
(1562,282,1)
(6118,395,1)
(4219,7807,1)
(823,4341,1)
(6632,6790,1)
(675,6795,1)
(7710,115,1)
(8299,8598,1)
(5632,6904,1)
(6847,794,1)
(6364,807,1)
(2348,7627,1)
(384,4521,1)
(3151,7167,1)
(588,3822,1)
(2081,7086,1)
(2124,5653,1)
(7579,8147,1)
(7925,7002,1)
(5013,8756,1)
(3698,7355,1)
(1589,3129,1)
(8972,1713,1)
(1114,4500,1)
(7147,294,1)
(8085,7635,1)
(7462,8391,1)
(1275,632,1)
(3650,4072,1)
(3694,794,1)
(552,1619,1)
(3654,7753,1)
(4619,3522,1)
(1225,4830,1)
(7581,8508,1)
(6998,7374,1)
(6312,8219,1)
(944,1880,1)
(8702,5156,1)
(4692,6718,1)
(2544,1280,1)
(4398,6039,1)
(3579,8391,1)
(2243,7534,1)
(352,4724,1)
(3119,2055,1)
(4847,115,1)
(4915,9128,1)
(502,1032,1)
(2417,7785,1)
(257,7294,1)
(508,5871,1)
(7650,787,1)
(3456,8391,1)
(2198,9000,1)
(8437,4081,1)
(3076,115,1)
(8564,7342,1)
(3786,8391,1)
(4155,3426,1)
(7366,115,1)
(1066,4254,1)
(990,7772,1)
(8353,6674,1)
(6908,2043,1)
(873,7120,1)
(4027,853,1)
(1250,1149,1)
(6808,7473,1)
(318,564,1)
(7048,541,1)
(5639,1978,1)
(5070,4773,1)
(4470,4089,1)
(863,1888,1)
(5369,1195,1)
(1121,8995,1)
(5025,7819,1)
(8570,2133,1)
(6812,7337,1)
(2763,3158,1)
(1454,1339,1)
(8323,3272,1)
(1241,603,1)
(5841,8519,1)
(3804,2955,1)
(3649,2158,1)
(4375,3215,1)
(4958,3151,1)
(2544,8458,1)
(2159,512,1)
(1282,115,1)
(482,8391,1)
(8352,1400,1)
(3622,2662,1)
(1616,5829,1)
(2676,1387,1)
(1535,2789,1)
(9117,6546,1)
(7996,8246,1)
(8788,5697,1)
(2430,2465,1)
(5609,2744,1)
(1633,7892,1)
(1982,2269,1)
(446,5858,1)
(6641,6280,1)
(4460,8233,1)
(3119,115,1)
(1878,2845,1)
(6364,8628,1)
(4183,3376,1)
(6556,115,1)
(205,5608,1)
(4208,5429,1)
(8311,4164,1)
(8721,3013,1)
(1125,1407,1)
(4375,5655,1)
(2287,7280,1)
(2250,777,1)
(396,1575,1)
(6332,8122,1)
(5214,1158,1)
(2152,3988,1)
(6017,7683,1)
(6159,3621,1)
(3513,4822,1)
(7771,8445,1)
(186,3886,1)
(4157,8391,1)
(5214,700,1)
(6278,3983,1)
(3093,3287,1)
(9010,1838,1)
(3924,7634,1)
(7087,918,1)
(5809,6649,1)
(6502,5593,1)
(4628,9017,1)
(6151,3241,1)
(8219,1569,1)
(7059,8327,1)
(4837,5196,1)
(7355,5536,1)
(8802,7047,1)
(5922,3589,1)
(3435,8105,1)
(7306,880,1)
(534,3664,1)
(4981,7959,1)
(1257,6040,1)
(9117,2845,1)
(8567,8479,1)
(1197,5873,1)
(7206,4413,1)
(1701,108,1)
(3681,8149,1)
(2822,721,1)
(2022,7640,1)
(8434,3027,1)
(6741,271,1)
(9043,5245,1)
(2106,4624,1)
(154,4550,1)
(4579,4712,1)
(7716,8391,1)
(4396,698,1)
(2798,2537,1)
(137,3014,1)
(7938,1889,1)
(1387,8391,1)
(3986,5298,1)
(5847,2257,1)
(4231,6110,1)
(999,6536,1)
(6718,5249,1)
(1901,5076,1)
(1947,115,1)
(8293,6561,1)
(5057,7289,1)
(1948,8391,1)
(4367,3143,1)
(2562,939,1)
(1721,4016,1)
(958,8715,1)
(2639,3649,1)
(3078,8973,1)
(5593,8458,1)
(1848,2958,1)
(3278,3197,1)
(2422,7452,1)
(7244,7128,1)
(4192,837,1)
(3254,8391,1)
(6758,2315,1)
(8694,739,1)
(4695,1630,1)
(3892,3137,1)
(5991,2343,1)
(4732,4876,1)
(8620,5827,1)
(5949,1354,1)
(4739,5011,1)
(2204,1742,1)
(5494,1158,1)
(4993,7103,1)
(3050,5829,1)
(4872,4402,1)
(7880,8391,1)
(5056,8391,1)
(3918,4879,1)
(1724,7211,1)
(3213,4515,1)
(2996,390,1)
(6584,3527,1)
(6254,115,1)
(6387,4742,1)
(1415,6708,1)
(8517,1674,1)
(2720,3047,1)
(6779,1447,1)
(4375,6356,1)
(1938,539,1)
(8338,3672,1)
(4850,115,1)
(1594,6514,1)
(3300,8391,1)
(4870,8769,1)
(1084,5298,1)
(6283,225,1)
(3857,3231,1)
(7996,2330,1)
(1415,9130,1)
(1457,2075,1)
(3372,2312,1)
(8388,2059,1)
(2131,5175,1)
(6158,115,1)
(3861,2183,1)
(4262,7770,1)
(7025,5523,1)
(1880,5767,1)
(2105,1443,1)
(2385,115,1)
(8606,3565,1)
(5075,4898,1)
(3567,5552,1)
(3432,6195,1)
(8498,5134,1)
(528,8391,1)
(666,2414,1)
(1489,4407,1)
(1593,7083,1)
(8303,6807,1)
(4326,569,1)
(4224,1488,1)
(1036,4078,1)
(2287,7625,1)
(8328,115,1)
(6141,1149,1)
(192,7190,1)
(7876,5168,1)
(1416,7254,1)
(3865,1410,1)
(514,8391,1)
(1786,54,1)
(1867,6458,1)
(7444,73,1)
(768,8391,1)
(351,5675,1)
(325,7325,1)
(3517,2695,1)
(7690,1150,1)
(5899,4831,1)
(657,770,1)
(2003,498,1)
(8020,7578,1)
(1324,7668,1)
(4253,2858,1)
(6915,7549,1)
(2045,6497,1)
(4445,6509,1)
(4366,8966,1)
(6490,5510,1)
(1415,8495,1)
(6744,3230,1)
(7013,3086,1)
(4931,73,1)
(4979,6200,1)
(7491,7308,1)
(7090,7909,1)
(8764,8910,1)
(7931,6179,1)
(7642,1012,1)
(2239,8391,1)
(6890,8160,1)
(4628,105,1)
(7401,4408,1)
(2688,115,1)
(3878,1809,1)
(1731,8059,1)
(866,5439,1)
(6875,4013,1)
(8575,5454,1)
(8026,3168,1)
(5819,1794,1)
(8573,422,1)
(6755,6278,1)
(5983,1074,1)
(1195,7605,1)
(5649,115,1)
(7000,3004,1)
(6252,5329,1)
(3031,777,1)
(2531,5959,1)
(5896,3734,1)
(1055,1958,1)
(3980,7462,1)
(2445,1165,1)
(3751,1712,1)
(5169,4937,1)
(3724,7011,1)
(1415,6649,1)
(5683,1348,1)
(158,115,1)
(7455,4659,1)
(1812,3372,1)
(2073,8466,1)
(948,1257,1)
(2041,8680,1)
(3572,4986,1)
(3771,6836,1)
(4781,5156,1)
(6806,1788,1)
(7222,115,1)
(7244,3855,1)
(2670,8872,1)
(5960,6172,1)
(7475,6249,1)
(5074,1038,1)
(6502,6419,1)
(8442,5729,1)
(4257,2306,1)
(4793,3983,1)
(794,793,1)
(1063,1427,1)
(6678,115,1)
(7157,4163,1)
(3832,3614,1)
(5407,1270,1)
(2870,6763,1)
(1415,2112,1)
(1760,2820,1)
(3730,115,1)
(7244,6728,1)
(796,697,1)
(8644,2986,1)
(2241,5595,1)
(6341,2225,1)
(4389,115,1)
(7722,777,1)
(5302,777,1)
(6677,5250,1)
(785,7848,1)
(8892,4343,1)
(7999,8484,1)
(7373,8391,1)
(6291,5390,1)
(8484,2534,1)
(4574,7424,1)
(1915,7530,1)
(2052,5612,1)
(5925,5131,1)
(1841,2126,1)
(12,1791,1)
(3553,5324,1)
(7510,115,1)
(1026,2979,1)
(8226,1755,1)
(5267,3965,1)
(1034,446,1)
(6993,1410,1)
(4003,1754,1)
(1321,1790,1)
(7578,115,1)
(8993,727,1)
(6155,6630,1)
(7740,5405,1)
(211,8742,1)
(9012,7364,1)
(290,5226,1)
(5741,6106,1)
(8444,8391,1)
(2678,1019,1)
(907,1445,1)
(474,6881,1)
(5822,5081,1)
(8674,2879,1)
(570,1057,1)
(403,2229,1)
(2380,761,1)
(2287,4449,1)
(1572,6495,1)
(7759,3621,1)
(3723,971,1)
(4749,3841,1)
(4375,4449,1)
(4391,115,1)
(592,8391,1)
(1422,1184,1)
(1317,2559,1)
(671,8550,1)
(3865,7888,1)
(4763,9108,1)
(5497,2947,1)
(4317,1805,1)
(6049,3333,1)
(1961,1407,1)
(7204,7245,1)
(2422,4921,1)
(2192,134,1)
(1988,6377,1)
(6807,5505,1)
(3582,7231,1)
(377,8824,1)
(8927,8176,1)
(235,8097,1)
(7090,306,1)
(8739,7387,1)
(8203,2866,1)
(7410,8641,1)
(1086,7926,1)
(2308,1546,1)
(6767,1455,1)
(3213,4587,1)
(4336,5393,1)
(5580,4293,1)
(3442,5087,1)
(5366,7037,1)
(334,2857,1)
(8955,9121,1)
(7120,8391,1)
(7540,9140,1)
(1479,2565,1)
(6666,1671,1)
(3188,782,1)
(8852,3744,1)
(5392,4928,1)
(6887,1888,1)
(7608,4813,1)
(1136,3022,1)
(4398,7711,1)
(7909,8282,1)
(9081,3121,1)
(6189,6912,1)
(6501,5223,1)
(3943,4409,1)
(6980,4661,1)
(9106,8391,1)
(3325,8536,1)
(7244,4169,1)
(5974,4830,1)
(4292,93,1)
(78,1956,1)
(6575,191,1)
(539,8391,1)
(8481,1682,1)
(7595,8391,1)
(6431,2956,1)
(5409,4386,1)
(2287,8471,1)
(7745,2732,1)
(3568,3006,1)
(5966,8371,1)
(9088,8391,1)
(2973,7363,1)
(543,3916,1)
(1061,8391,1)
(609,778,1)
(4026,8391,1)
(9016,3293,1)
(5030,7251,1)
(3865,4522,1)
(2252,5726,1)
(7626,1280,1)
(1900,7384,1)
(6678,3893,1)
(1057,1095,1)
(3686,703,1)
(6713,115,1)
(4375,8595,1)
(8334,7155,1)
(2138,8514,1)
(9043,3380,1)
(5486,8391,1)
(6892,5829,1)
(464,4854,1)
(2254,428,1)
(4381,8391,1)
(3792,8698,1)
(870,8334,1)
(1267,836,1)
(3796,8482,1)
(5550,406,1)
(5195,2943,1)
(6904,8957,1)
(6954,6014,1)
(943,7159,1)
(508,4376,1)
(6526,454,1)
(7361,7419,1)
(6343,1131,1)
(7672,4516,1)
(2338,7155,1)
(8202,8756,1)
(340,115,1)
(3804,2065,1)
(6880,7316,1)
(6676,4777,1)
(1199,4889,1)
(3481,653,1)
(8893,8729,1)
(1392,1716,1)
(5694,3978,1)
(7187,5484,1)
(1052,8391,1)
(7140,5248,1)
(1487,7799,1)
(3782,6013,1)
(4729,2399,1)
(4675,2482,1)
(2386,5829,1)
(6808,2992,1)
(7982,115,1)
(8549,151,1)
(315,12,1)
(3816,2525,1)
(5602,429,1)
(8162,8446,1)
(924,1665,1)
(4826,7693,1)
(8964,6004,1)
(5607,3895,1)
(6326,7754,1)
(6292,7409,1)
(3509,8111,1)
(3747,4861,1)
(989,389,1)
(8935,7296,1)
(8973,659,1)
(1609,1811,1)
(402,5829,1)
(6284,1423,1)
(579,7562,1)
(1735,2029,1)
(8108,2208,1)
(7843,8074,1)
(2109,3817,1)
(1615,104,1)
(8806,8391,1)
(8627,5009,1)
(8393,3757,1)
(7148,2233,1)
(8651,9069,1)
(3485,28,1)
(704,4104,1)
(1826,2603,1)
(3063,2133,1)
(2161,3103,1)
(5686,9006,1)
(4523,4258,1)
(8236,1221,1)
(2030,1055,1)
(5374,888,1)
(1152,8391,1)
(6497,2919,1)
(8369,3373,1)
(3223,8759,1)
(3089,675,1)
(3804,3565,1)
(7406,2036,1)
(7244,7803,1)
(4015,8722,1)
(4375,1405,1)
(426,1911,1)
(8780,6800,1)
(8148,8391,1)
(6378,6204,1)
(2045,3933,1)
(7244,1584,1)
(4289,7180,1)
(1560,4771,1)
(7481,3118,1)
(6375,5270,1)
(4290,5013,1)
(6796,3605,1)
(3397,4588,1)
(4238,2882,1)
(3052,3149,1)
(1019,178,1)
(1555,2845,1)
(5496,5121,1)
(1872,7603,1)
(361,953,1)
(3064,1843,1)
(3221,4503,1)
(1217,5156,1)
(5887,1915,1)
(4099,245,1)
(1857,7135,1)
(3175,8391,1)
(2287,6921,1)
(9126,3970,1)
(1207,860,1)
(5147,1899,1)
(4464,2099,1)
(2461,6426,1)
(1698,4394,1)
(3824,1615,1)
(1283,9071,1)
(3441,4025,1)
(6926,8391,1)
(5121,6670,1)
(2139,2845,1)
(1843,115,1)
(38,1638,1)
(6926,3228,1)
(1186,4098,1)
(3002,3385,1)
(1886,1390,1)
(3745,5115,1)
(8456,1412,1)
(4407,7290,1)
(8021,3484,1)
(4995,4597,1)
(2468,2903,1)
(7826,6618,1)
(2095,5936,1)
(6766,2373,1)
(4036,6722,1)
(2795,1002,1)
(708,5881,1)
(8857,6292,1)
(8896,4418,1)
(313,3206,1)
(8853,904,1)
(3806,387,1)
(1292,5300,1)
(392,457,1)
(2118,813,1)
(6036,8040,1)
(6937,4255,1)
(8759,1303,1)
(7991,122,1)
(2090,3189,1)
(418,8575,1)
(2347,4205,1)
(54,4864,1)
(4992,8695,1)
(4360,4853,1)
(3583,3620,1)
(3750,1196,1)
(2467,7164,1)
(8927,3153,1)
(970,3771,1)
(2145,8378,1)
(785,2116,1)
(2113,846,1)
(1363,8391,1)
(8269,1709,1)
(5388,1213,1)
(1862,3894,1)
(2172,6061,1)
(1814,4435,1)
(3774,7277,1)
(5886,4652,1)
(3070,7909,1)
(5007,2754,1)
(4954,1488,1)
(6866,5899,1)
(9128,4704,1)
(1199,3130,1)
(148,8391,1)
(7244,5438,1)
(8908,6111,1)
(4470,4398,1)
(1839,2027,1)
(289,2360,1)
(4221,8631,1)
(7095,6797,1)
(6633,1428,1)
(391,7581,1)
(6278,7888,1)
(4724,3899,1)
(5620,7106,1)
(6348,716,1)
(8330,1435,1)
(5374,1471,1)
(2818,115,1)
(4029,1297,1)
(7896,8743,1)
(7176,8391,1)
(5593,7533,1)
(1121,2278,1)
(2574,3493,1)
(2231,8200,1)
(8099,3103,1)
(8008,4004,1)
(4013,6247,1)
(4650,6084,1)
(1584,6910,1)
(4873,6649,1)
(9063,6036,1)
(7100,6559,1)
(8810,763,1)
(8705,5895,1)
(7102,6272,1)
(1158,7252,1)
(1954,4340,1)
(5621,5761,1)
(888,1471,1)
(7294,4477,1)
(2991,8668,1)
(6471,7212,1)
(424,8391,1)
(2873,115,1)
(6386,4880,1)
(4956,680,1)
(4060,5102,1)
(635,8095,1)
(7985,743,1)
(8430,1162,1)
(5898,1488,1)
(6724,7812,1)
(2644,6241,1)
(8565,8677,1)
(5451,2845,1)
(7097,2695,1)
(8047,6543,1)
(1054,6612,1)
(1823,3658,1)
(4390,5493,1)
(7742,2103,1)
(8070,5417,1)
(6157,7112,1)
(7247,1739,1)
(9062,4424,1)
(7545,4389,1)
(8412,164,1)
(7764,115,1)
(716,6939,1)
(7830,6932,1)
(4277,2717,1)
(323,2706,1)
(834,7318,1)
(4125,4385,1)
(4008,8391,1)
(7404,2597,1)
(7672,8709,1)
(6038,115,1)
(1079,337,1)
(3527,349,1)
(5326,8391,1)
(1924,8391,1)
(8934,330,1)
(3935,5327,1)
(3343,4371,1)
(3969,1133,1)
(4789,7499,1)
(6794,7806,1)
(6502,4873,1)
(1150,8,1)
(2538,8391,1)
(4113,5679,1)
(1511,9050,1)
(6696,2658,1)
(7976,5314,1)
(6893,8623,1)
(1322,6005,1)
(3539,5075,1)
(6736,5506,1)
(7091,5202,1)
(7314,5320,1)
(5684,2879,1)
(5386,1507,1)
(1703,4326,1)
(7113,8391,1)
(1139,7786,1)
(6867,5869,1)
(6398,4520,1)
(1308,5444,1)
(6381,4330,1)
(6910,5550,1)
(8687,7598,1)
(6284,1158,1)
(437,2793,1)
(1022,115,1)
(1110,756,1)
(2918,2253,1)
(3632,6784,1)
(3727,8391,1)
(6278,1410,1)
(2269,5422,1)
(8497,115,1)
(1415,7094,1)
(1811,2,1)
(3151,5596,1)
(2403,671,1)
(8102,3333,1)
(4117,4531,1)
(3600,6677,1)
(1111,4336,1)
(4708,2408,1)
(3649,5129,1)
(3004,258,1)
(8757,8657,1)
(7721,6087,1)
(6063,115,1)
(2934,987,1)
(7851,2434,1)
(8183,600,1)
(1387,2575,1)
(1696,4723,1)
(8530,8352,1)
(7409,7237,1)
(918,780,1)
(4589,3928,1)
(8018,2250,1)
(5998,8391,1)
(3668,8723,1)
(5659,7058,1)
(5945,2771,1)
(7778,5958,1)
(1222,5156,1)
(1809,1181,1)
(3675,7913,1)
(2295,6995,1)
(6462,1149,1)
(6656,8391,1)
(2076,7097,1)
(656,6751,1)
(1954,8215,1)
(8031,6108,1)
(4757,2167,1)
(3841,5286,1)
(6993,3940,1)
(2045,8579,1)
(1707,115,1)
(1991,4774,1)
(3213,700,1)
(7423,4156,1)
(8155,5156,1)
(7408,8391,1)
(3035,6597,1)
(7586,8408,1)
(1472,2227,1)
(4149,6672,1)
(5433,7479,1)
(6993,3835,1)
(960,3806,1)
(4356,8829,1)
(6427,4633,1)
(34,7309,1)
(806,7452,1)
(4894,609,1)
(1725,8182,1)
(1406,8964,1)
(2973,1760,1)
(1859,7346,1)
(724,8391,1)
(8923,5143,1)
(2998,5913,1)
(8426,6836,1)
(7015,2597,1)
(7812,3451,1)
(7926,256,1)
(6112,3629,1)
(5750,2078,1)
(6620,6437,1)
(1362,4485,1)
(4369,7712,1)
(3010,87,1)
(7279,8065,1)
(5389,3781,1)
(247,1262,1)
(3778,3943,1)
(6203,8446,1)
(4682,7510,1)
(6761,3097,1)
(5876,6126,1)
(5638,8734,1)
(7339,477,1)
(8708,3019,1)
(4484,5755,1)
(1612,115,1)
(854,8481,1)
(8117,8958,1)
(4809,2018,1)
(1563,8784,1)
(178,7777,1)
(6970,7977,1)
(8505,1203,1)
(8155,4876,1)
(4132,8317,1)
(50,4097,1)
(4375,4587,1)
(3384,1488,1)
(1967,2845,1)
(7583,612,1)
(2566,2292,1)
(6463,5201,1)
(3632,82,1)
(5251,4559,1)
(2720,8391,1)
(4729,6869,1)
(7632,2393,1)
(3123,6112,1)
(6240,1107,1)
(7878,6616,1)
(4065,4766,1)
(5348,8512,1)
(5950,4876,1)
(7895,4171,1)
(6419,1280,1)
(1310,9038,1)
(4934,3441,1)
(6502,7881,1)
(5868,2043,1)
(8421,115,1)
(2408,1502,1)
(4161,2175,1)
(7384,1312,1)
(4179,4358,1)
(6124,4984,1)
(7532,3621,1)
(4869,5151,1)
(6523,3113,1)
(6838,2907,1)
(7566,115,1)
(5423,7919,1)
(4314,2506,1)
(4902,3267,1)
(4458,8036,1)
(3726,1521,1)
(5861,5156,1)
(8240,5680,1)
(2757,413,1)
(1463,7821,1)
(6535,719,1)
(5556,900,1)
(1300,7951,1)
(4320,7400,1)
(7727,4421,1)
(8405,2818,1)
(5670,6951,1)
(306,4329,1)
(161,1377,1)
(7940,2752,1)
(1799,1593,1)
(4058,1673,1)
(803,6756,1)
(2366,5785,1)
(176,8867,1)
(2894,7431,1)
(1675,8391,1)
(8975,240,1)
(4375,1158,1)
(2944,986,1)
(1724,338,1)
(1908,3333,1)
(8354,2012,1)
(5658,4519,1)
(8215,4340,1)
(6318,8391,1)
(6029,5232,1)
(2468,115,1)
(4024,5212,1)
(2139,8391,1)
(2893,7247,1)
(5907,8955,1)
(1783,5156,1)
(8713,8391,1)
(6149,3630,1)
(3144,4234,1)
(965,384,1)
(5676,1964,1)
(5737,7396,1)
(6367,204,1)
(261,385,1)
(7378,792,1)
(7251,3134,1)
(7071,5006,1)
(3145,9072,1)
(8371,72,1)
(618,323,1)
(606,148,1)
(741,4340,1)
(6453,6528,1)
(1800,4495,1)
(603,1100,1)
(3712,5721,1)
(4859,6803,1)
(4650,4048,1)
(1001,3720,1)
(6867,4214,1)
(5809,8458,1)
(8998,6064,1)
(8520,7531,1)
(6953,417,1)
(8105,115,1)
(4819,513,1)
(4543,3814,1)
(8390,3285,1)
(6146,2511,1)
(7523,5265,1)
(7309,5870,1)
(3737,2273,1)
(8856,4508,1)
(8861,7851,1)
(3813,4890,1)
(295,6793,1)
(5817,217,1)
(8056,8170,1)
(6253,2168,1)
(3079,4121,1)
(8351,916,1)
(8285,1068,1)
(1570,2198,1)
(4875,7071,1)
(8099,884,1)
(171,202,1)
(147,1329,1)
(8225,2428,1)
(712,8167,1)
(6448,4790,1)
(6576,8391,1)
(677,5541,1)
(6223,8391,1)
(4391,8391,1)
(8118,7893,1)
(2016,7141,1)
(841,2188,1)
(2994,4382,1)
(921,8391,1)
(4865,377,1)
(7774,1830,1)
(5570,1920,1)
(8658,449,1)
(7382,3940,1)
(2778,123,1)
(4166,8727,1)
(6125,8391,1)
(8475,1381,1)
(4431,8391,1)
(718,424,1)
(8249,7932,1)
(1415,4350,1)
(4540,1955,1)
(6083,6977,1)
(5529,4620,1)
(6710,4861,1)
(6686,1576,1)
(8767,4912,1)
(1071,436,1)
(909,115,1)
(2291,6584,1)
(813,6871,1)
(4553,3692,1)
(6940,8091,1)
(7277,1375,1)
(3491,6529,1)
(5091,5000,1)
(7347,470,1)
(2554,1139,1)
(5551,5324,1)
(980,8213,1)
(6193,6564,1)
(6786,2320,1)
(3680,5894,1)
(575,7999,1)
(7444,4931,1)
(917,6234,1)
(8038,4587,1)
(3601,8151,1)
(6069,5409,1)
(3073,3198,1)
(3105,4066,1)
(3402,6597,1)
(8445,5876,1)
(749,2257,1)
(7624,3481,1)
(6609,3846,1)
(3030,5989,1)
(5359,3919,1)
(3976,6646,1)
(3988,7613,1)
(6784,4270,1)
(7003,7415,1)
(686,7974,1)
(350,1640,1)
(6899,5932,1)
(7005,8391,1)
(1690,688,1)
(8215,5512,1)
(4818,2396,1)
(2381,3621,1)
(7746,2076,1)
(6400,6209,1)
(2399,8780,1)
(3207,115,1)
(5809,1158,1)
(8318,4718,1)
(6739,7647,1)
(3085,6012,1)
(3757,4047,1)
(8507,4180,1)
(5938,1171,1)
(1430,8573,1)
(5638,1270,1)
(7666,324,1)
(4426,115,1)
(1963,8670,1)
(2686,4981,1)
(1024,448,1)
(863,1254,1)
(9132,8131,1)
(8633,646,1)
(8913,115,1)
(4720,2966,1)
(8057,8409,1)
(2904,3721,1)
(1779,6484,1)
(8009,2845,1)
(3644,2271,1)
(3360,4803,1)
(3649,6351,1)
(289,5844,1)
(1546,6660,1)
(4524,3420,1)
(4390,2370,1)
(6817,7970,1)
(114,4542,1)
(5102,4715,1)
(1443,3667,1)
(6385,6535,1)
(62,3874,1)
(8292,3054,1)
(3304,1121,1)
(3276,3266,1)
(5783,3474,1)
(5927,4998,1)
(9111,4501,1)
(150,1648,1)
(1404,5927,1)
(1748,5374,1)
(460,95,1)
(6360,7115,1)
(8458,1676,1)
(3579,115,1)
(8568,1105,1)
(3394,3890,1)
(5917,6746,1)
(5324,5473,1)
(1861,2761,1)
(3483,8731,1)
(7782,2100,1)
(433,957,1)
(531,2681,1)
(2506,259,1)
(7657,4221,1)
(4740,6115,1)
(9054,8208,1)
(1291,5662,1)
(559,958,1)
(848,6046,1)
(7025,905,1)
(4617,6964,1)
(2631,3097,1)
(2287,4350,1)
(467,111,1)
(514,2845,1)
(7167,8460,1)
(8246,6508,1)
(3963,3108,1)
(4375,5452,1)
(8541,3727,1)
(8845,7916,1)
(3206,4975,1)
(401,3374,1)
(549,1528,1)
(6889,8391,1)
(4616,6723,1)
(3427,9033,1)
(4326,785,1)
(598,3883,1)
(2063,5693,1)
(4329,3953,1)
(6135,3879,1)
(7911,4635,1)
(7863,115,1)
(2780,2386,1)
(4109,2822,1)
(8029,3726,1)
(5618,7828,1)
(5696,2091,1)
(7726,7228,1)
(1313,7111,1)
(1471,2238,1)
(2846,1560,1)
(1369,5467,1)
(5124,6027,1)
(7244,5068,1)
(5596,7167,1)
(5371,8301,1)
(4087,115,1)
(6392,1458,1)
(8110,2043,1)
(7774,4133,1)
(7703,2158,1)
(8778,7798,1)
(8057,115,1)
(8296,6084,1)
(4071,3719,1)
(3719,8900,1)
(2896,4146,1)
(3042,8351,1)
(2963,6049,1)
(5721,115,1)
(1307,3917,1)
(573,9088,1)
(8247,3035,1)
(4599,4278,1)
(5084,6600,1)
(1438,2845,1)
(8654,8975,1)
(3584,8629,1)
(1954,5512,1)
(8526,227,1)
(929,4959,1)
(3981,8986,1)
(6364,9125,1)
(6117,5632,1)
(8140,4229,1)
(6551,7894,1)
(557,3218,1)
(1956,6360,1)
(7980,8391,1)
(8103,746,1)
(2354,2715,1)
(4451,6449,1)
(5900,3009,1)
(1169,3914,1)
(3057,97,1)
(1041,6021,1)
(7626,700,1)
(3679,6555,1)
(7785,909,1)
(4587,2931,1)
(4836,5495,1)
(5296,2186,1)
(7661,8407,1)
(5305,553,1)
(2317,8391,1)
(767,7118,1)
(3335,4244,1)
(3791,231,1)
(1754,8391,1)
(6919,7329,1)
(4353,3072,1)
(2195,8205,1)
(7120,115,1)
(3752,1488,1)
(8186,101,1)
(6603,4257,1)
(3178,3677,1)
(799,1623,1)
(5229,5474,1)
(752,5482,1)
(3051,2411,1)
(1059,524,1)
(2117,115,1)
(4650,8391,1)
(151,5196,1)
(6076,5258,1)
(6462,2690,1)
(1964,8910,1)
(6251,7060,1)
(5203,4572,1)
(3338,3634,1)
(4142,2855,1)
(7703,3238,1)
(7254,2085,1)
(1749,6677,1)
(9088,7711,1)
(6908,5829,1)
(768,2923,1)
(3744,2305,1)
(4212,115,1)
(8911,6573,1)
(8348,8391,1)
(8088,8391,1)
(337,2054,1)
(5518,4128,1)
(4333,7637,1)
(1996,5711,1)
(7981,4469,1)
(4450,2934,1)
(7174,7946,1)
(4557,3736,1)
(2725,6614,1)
(5548,3621,1)
(7384,1149,1)
(4282,5502,1)
(32,7094,1)
(4593,7031,1)
(1621,4449,1)
(6399,3716,1)
(1750,5889,1)
(4788,8792,1)
(1122,115,1)
(2816,8888,1)
(8578,6245,1)
(1076,5059,1)
(261,7657,1)
(6022,8391,1)
(966,4876,1)
(981,6530,1)
(6764,208,1)
(5085,5418,1)
(8337,5731,1)
(8591,1104,1)
(8845,2104,1)
(2952,5498,1)
(5894,356,1)
(1890,3700,1)
(5796,5722,1)
(2199,1835,1)
(4196,7540,1)
(5177,5567,1)
(2518,6517,1)
(1464,7250,1)
(8426,2553,1)
(3842,8134,1)
(7253,4601,1)
(4001,6463,1)
(6209,8093,1)
(1149,2926,1)
(4749,8391,1)
(7222,1398,1)
(4825,6478,1)
(1204,4473,1)
(3383,4373,1)
(3493,2749,1)
(2838,8940,1)
(3518,3221,1)
(1483,6947,1)
(2401,2391,1)
(253,6805,1)
(3477,1878,1)
(2175,172,1)
(8582,8391,1)
(6608,1886,1)
(4628,1858,1)
(5385,6726,1)
(2161,4741,1)
(4691,2736,1)
(6465,354,1)
(867,3540,1)
(5669,6684,1)
(8885,7203,1)
(3318,115,1)
(2161,622,1)
(6154,5573,1)
(4468,2043,1)
(2097,2878,1)
(1959,5064,1)
(480,5375,1)
(5637,2090,1)
(7297,6308,1)
(7155,3102,1)
(3606,1250,1)
(477,8391,1)
(4034,3621,1)
(599,8749,1)
(3261,288,1)
(5812,6251,1)
(4,2918,1)
(4592,5256,1)
(2610,1053,1)
(7608,3147,1)
(6132,6746,1)
(5607,1591,1)
(2823,3398,1)
(1601,8391,1)
(7860,2258,1)
(7626,8111,1)
(1240,6847,1)
(6394,20,1)
(7663,1892,1)
(3127,1115,1)
(2057,2377,1)
(2440,6001,1)
(5454,4081,1)
(5304,5779,1)
(472,4721,1)
(70,8085,1)
(246,738,1)
(6764,4566,1)
(4800,7440,1)
(5671,3482,1)
(8295,115,1)
(2575,999,1)
(6659,4277,1)
(8762,180,1)
(5194,7239,1)
(3751,6165,1)
(274,2708,1)
(5482,6652,1)
(7232,1635,1)
(3222,6960,1)
(8709,8391,1)
(6852,772,1)
(6405,6711,1)
(3148,6521,1)
(6267,6681,1)
(7618,6862,1)
(4096,517,1)
(8029,4473,1)
(1452,2845,1)
(1554,6613,1)
(4226,9045,1)
(7284,7195,1)
(6237,2840,1)
(8111,8762,1)
(322,8861,1)
(4170,7696,1)
(3550,7443,1)
(95,3704,1)
(1704,1928,1)
(1969,8391,1)
(7203,8719,1)
(375,3741,1)
(2251,4736,1)
(7632,8391,1)
(6299,777,1)
(537,4484,1)
(2551,2261,1)
(1944,4728,1)
(7373,3411,1)
(1602,115,1)
(2674,595,1)
(1541,5857,1)
(7274,3920,1)
(5712,7552,1)
(2001,5950,1)
(8985,3829,1)
(2999,2192,1)
(8920,8695,1)
(4897,2163,1)
(100,8011,1)
(7636,2741,1)
(6502,3213,1)
(4085,5235,1)
(7819,99,1)
(7084,2746,1)
(8419,8391,1)
(8519,3232,1)
(3392,2294,1)
(1670,2845,1)
(4668,6079,1)
(7366,898,1)
(4536,6577,1)
(4873,700,1)
(9095,1028,1)
(4556,358,1)
(5467,3836,1)
(1408,5053,1)
(6196,2879,1)
(504,3148,1)
(5033,7246,1)
(2624,3963,1)
(3914,7136,1)
(2222,6662,1)
(8776,115,1)
(8091,2954,1)
(8786,6645,1)
(687,4811,1)
(5007,6355,1)
(7866,3997,1)
(6198,8688,1)
(6513,115,1)
(3534,115,1)
(6993,2303,1)
(5396,6810,1)
(2287,2861,1)
(3773,8391,1)
(2166,4564,1)
(8895,7555,1)
(4119,2563,1)
(1001,115,1)
(6863,5346,1)
(7656,2712,1)
(184,1161,1)
(3508,3902,1)
(2068,3897,1)
(310,6858,1)
(3342,2970,1)
(7822,7935,1)
(6345,5879,1)
(2580,3739,1)
(8776,8391,1)
(3899,804,1)
(6854,1638,1)
(5355,2743,1)
(5656,1833,1)
(6140,1934,1)
(3176,5681,1)
(4181,5718,1)
(7585,6078,1)
(7398,3912,1)
(1728,2005,1)
(305,8173,1)
(122,435,1)
(1471,4119,1)
(4472,6147,1)
(8653,8678,1)
(839,3160,1)
(1842,2659,1)
(6263,5412,1)
(1439,3196,1)
(572,8391,1)
(3891,5316,1)
(6412,2043,1)
(7491,8989,1)
(5710,4885,1)
(1358,3996,1)
(4345,8012,1)
(7847,8391,1)
(7496,5237,1)
(2689,975,1)
(3628,2276,1)
(6349,7339,1)
(6502,7626,1)
(3703,5483,1)
(8966,115,1)
(4713,815,1)
(3978,3737,1)
(1305,3791,1)
(4475,7264,1)
(7002,3705,1)
(4494,115,1)
(3069,8943,1)
(1580,3103,1)
(329,8227,1)
(9139,8225,1)
(1585,1524,1)
(9098,6990,1)
(4755,4678,1)
(9031,6434,1)
(2698,2661,1)
(7510,8703,1)
(2463,6229,1)
(979,8253,1)
(5463,6254,1)
(3776,2412,1)
(1265,6842,1)
(7347,6423,1)
(3033,8159,1)
(1838,7694,1)
(947,7870,1)
(8512,8604,1)
(3023,5036,1)
(2335,520,1)
(2794,4850,1)
(1972,3018,1)
(5545,2047,1)
(2945,5909,1)
(7719,4338,1)
(3285,4876,1)
(9117,8391,1)
(5442,8297,1)
(3096,7185,1)
(775,8391,1)
(7602,3252,1)
(8244,3068,1)
(8031,115,1)
(8815,155,1)
(4780,1600,1)
(2241,5631,1)
(5887,7463,1)
(5768,2072,1)
(4309,6955,1)
(72,5096,1)
(6452,8793,1)
(5281,8017,1)
(6770,3588,1)
(2857,5475,1)
(4975,8129,1)
(98,2264,1)
(3418,9080,1)
(1893,2462,1)
(4667,7030,1)
(5250,7418,1)
(4694,5703,1)
(2449,7571,1)
(9043,2746,1)
(5373,8803,1)
(4328,1324,1)
(7316,272,1)
(6715,6373,1)
(7609,3370,1)
(1045,8391,1)
(217,2070,1)
(443,6834,1)
(4432,1473,1)
(861,6149,1)
(2163,2442,1)
(7365,8616,1)
(9101,310,1)
(5528,5389,1)
(6316,2193,1)
(1797,8403,1)
(8470,115,1)
(3541,8988,1)
(1505,3438,1)
(8034,5156,1)
(2708,9066,1)
(1729,115,1)
(5161,8112,1)
(7493,4964,1)
(2215,7644,1)
(7506,8081,1)
(8809,1064,1)
(2735,7893,1)
(3804,1577,1)
(1,2251,1)
(4479,130,1)
(1415,6571,1)
(4803,2277,1)
(5564,6851,1)
(3860,1335,1)
(7975,1701,1)
(7989,8391,1)
(1061,2845,1)
(8607,8365,1)
(5038,3001,1)
(6502,1415,1)
(1748,981,1)
(6556,6089,1)
(8595,8391,1)
(5516,5533,1)
(6195,7648,1)
(7959,5882,1)
(6690,1905,1)
(8378,74,1)
(5874,8391,1)
(2940,115,1)
(1060,3205,1)
(3139,212,1)
(8711,3063,1)
(3284,6063,1)
(5508,3145,1)
(7338,8481,1)
(4417,5443,1)
(578,8391,1)
(7447,1953,1)
(8496,115,1)
(5636,7755,1)
(4389,3109,1)
(2428,4113,1)
(2328,1954,1)
(2287,6474,1)
(232,2213,1)
(5548,4955,1)
(8270,7043,1)
(3867,7312,1)
(6827,2845,1)
(444,3539,1)
(6810,5934,1)
(1281,7209,1)
(7621,4880,1)
(1340,2821,1)
(8311,8391,1)
(2384,115,1)
(7244,5709,1)
(3117,315,1)
(5629,2203,1)
(1848,115,1)
(1420,3990,1)
(7710,8391,1)
(865,4700,1)
(1467,5098,1)
(1333,1239,1)
(5209,8391,1)
(3814,1199,1)
(7814,8588,1)
(1382,8559,1)
(853,1204,1)
(2336,587,1)
(8023,7628,1)
(1046,868,1)
(1165,5861,1)
(4325,7142,1)
(264,6016,1)
(7656,3451,1)
(7236,5603,1)
(5616,8058,1)
(2864,1986,1)
(1391,8912,1)
(683,2249,1)
(7003,5849,1)
(6068,3774,1)
(3123,3629,1)
(7211,3696,1)
(2556,8054,1)
(1539,2010,1)
(145,7215,1)
(7628,7667,1)
(4188,6603,1)
(3213,1405,1)
(4866,484,1)
(1126,2456,1)
(3492,8064,1)
(3534,3536,1)
(4318,8607,1)
(4856,2458,1)
(523,8391,1)
(3125,4913,1)
(6688,4619,1)
(7244,5782,1)
(5214,8111,1)
(3480,8139,1)
(1805,7956,1)
(6007,3501,1)
(6494,7373,1)
(9041,7371,1)
(5595,6854,1)
(2756,7283,1)
(5461,3151,1)
(5256,4791,1)
(4375,6563,1)
(3406,2295,1)
(5557,2834,1)
(115,1850,1)
(3734,2079,1)
(7527,2838,1)
(1339,3843,1)
(2690,7579,1)
(6270,7040,1)
(4925,6265,1)
(3788,1911,1)
(2406,8359,1)
(5387,7476,1)
(2687,985,1)
(2410,115,1)
(3253,8630,1)
(3113,752,1)
(1912,8666,1)
(1239,3553,1)
(4715,2510,1)
(7820,115,1)
(5012,3828,1)
(6054,923,1)
(5379,3714,1)
(2119,3885,1)
(6573,7522,1)
(482,115,1)
(5452,8391,1)
(7161,3388,1)
(7031,6654,1)
(6082,881,1)
(8751,3582,1)
(6990,8083,1)
(1140,2533,1)
(6159,8391,1)
(3459,52,1)
(438,3754,1)
(7984,115,1)
(7577,5332,1)
(2560,3400,1)
(5660,3173,1)
(2209,6379,1)
(2647,5896,1)
(998,6271,1)
(4524,8391,1)
(7035,3379,1)
(6478,4930,1)
(3785,115,1)
(1065,8391,1)
(7198,2845,1)
(5227,115,1)
(3092,4595,1)
(4720,8846,1)
(7589,7642,1)
(2340,828,1)
(4480,5349,1)
(7383,1193,1)
(1770,8319,1)
(7142,3342,1)
(6400,5118,1)
(7440,4606,1)
(5869,7888,1)
(9129,6474,1)
(8849,7255,1)
(7430,7039,1)
(3571,115,1)
(6973,8391,1)
(6293,977,1)
(1458,6421,1)
(3591,3918,1)
(1415,8727,1)
(4684,8856,1)
(3696,2626,1)
(3621,9130,1)
(7567,6393,1)
(1122,1098,1)
(810,1172,1)
(3700,365,1)
(3254,3562,1)
(6952,1247,1)
(5839,5550,1)
(4195,5633,1)
(6471,3615,1)
(383,4799,1)
(4778,1219,1)
(4466,5376,1)
(5081,6069,1)
(2867,3334,1)
(8499,7525,1)
(2287,2497,1)
(1121,4487,1)
(1306,9012,1)
(862,3451,1)
(3251,5554,1)
(4071,6466,1)
(1415,4630,1)
(3672,8565,1)
(6838,6748,1)
(8995,5343,1)
(8480,9095,1)
(2178,2939,1)
(3983,4453,1)
(3331,1243,1)
(8773,6060,1)
(5063,6577,1)
(7818,5082,1)
(4139,1599,1)
(35,8865,1)
(8086,558,1)
(2722,1916,1)
(2187,5553,1)
(2543,8111,1)
(4281,1571,1)
(2555,5129,1)
(6805,5789,1)
(6834,5579,1)
(6762,986,1)
(3059,6242,1)
(7983,1647,1)
(1042,3453,1)
(8432,1488,1)
(695,6773,1)
(7590,1484,1)
(1533,7818,1)
(2096,5073,1)
(6407,5890,1)
(6055,1421,1)
(5738,764,1)
(1211,6940,1)
(4781,8951,1)
(3804,6435,1)
(3859,2212,1)
(6965,8908,1)
(3232,2979,1)
(8902,3713,1)
(520,1612,1)
(4849,2932,1)
(1348,6875,1)
(7435,2821,1)
(3381,7367,1)
(5494,700,1)
(3141,2527,1)
(2728,2255,1)
(7580,8756,1)
(5474,781,1)
(8034,3399,1)
(6752,4441,1)
(8976,1550,1)
(1418,2043,1)
(1254,6896,1)
(3804,4149,1)
(3018,6431,1)
(171,1742,1)
(1958,8080,1)
(2755,2057,1)
(6200,8640,1)
(8566,1885,1)
(191,1908,1)
(8572,1564,1)
(1141,8309,1)
(4989,2085,1)
(236,2598,1)
(3370,1667,1)
(2915,2388,1)
(8424,5652,1)
(2127,2397,1)
(2750,7160,1)
(1954,2896,1)
(5412,2344,1)
(1634,3515,1)
(6908,7574,1)
(4073,8047,1)
(8038,7039,1)
(1453,1059,1)
(1693,4085,1)
(8209,5156,1)
(1226,4662,1)
(5198,338,1)
(470,6423,1)
(2542,5537,1)
(8598,1727,1)
(7244,4551,1)
(1471,4876,1)
(7848,1441,1)
(8048,7511,1)
(7942,7811,1)
(2829,5912,1)
(7054,7673,1)
(6643,1684,1)
(4165,3139,1)
(6141,6152,1)
(6507,5079,1)
(8455,5786,1)
(7679,53,1)
(6245,9039,1)
(4862,7908,1)
(6791,1982,1)
(5503,5847,1)
(7884,7831,1)
(1415,8441,1)
(1022,8272,1)
(473,115,1)
(7779,8520,1)
(4332,2686,1)
(6656,115,1)
(4303,6199,1)
(1571,4632,1)
(3780,8917,1)
(8479,7689,1)
(8242,8391,1)
(0,4940,1)
(1077,2987,1)
(8616,6303,1)
(9026,115,1)
(1190,7098,1)
(546,9042,1)
(6117,2854,1)
(8691,39,1)
(1142,2998,1)
(7418,7243,1)
(1662,8927,1)
(5995,4949,1)
(5915,3192,1)
(2092,5323,1)
(4248,4326,1)
(4977,3061,1)
(681,6662,1)
(7062,557,1)
(5646,4836,1)
(7264,8391,1)
(3621,5558,1)
(5414,8391,1)
(7689,3834,1)
(5546,4015,1)
(6935,8391,1)
(3390,7017,1)
(1433,1290,1)
(1230,5830,1)
(8428,4887,1)
(3281,6727,1)
(201,2061,1)
(8563,5299,1)
(7743,5829,1)
(6565,7191,1)
(914,7412,1)
(6973,1230,1)
(2134,8639,1)
(5601,1396,1)
(7804,3510,1)
(1325,8746,1)
(5144,8584,1)
(8276,2014,1)
(2275,6201,1)
(4739,6243,1)
(4563,7622,1)
(1782,9101,1)
(1274,3425,1)
(1496,297,1)
(3678,1092,1)
(1895,3526,1)
(8199,2718,1)
(7905,8638,1)
(8147,7670,1)
(3793,5145,1)
(4393,6313,1)
(413,115,1)
(2805,1767,1)
(3922,8400,1)
(5137,946,1)
(8237,115,1)
(3945,543,1)
(6687,7179,1)
(349,5350,1)
(5164,2845,1)
(2135,2406,1)
(8151,8104,1)
(177,6732,1)
(5729,1732,1)
(1694,115,1)
(2527,6302,1)
(6357,4612,1)
(4455,2401,1)
(8139,1391,1)
(7300,5503,1)
(277,7830,1)
(4092,4793,1)
(4358,1063,1)
(2677,8391,1)
(2224,8162,1)
(2018,7766,1)
(8612,7790,1)
(4828,8391,1)
(1324,8628,1)
(3461,1309,1)
(1638,7038,1)
(7950,1751,1)
(8933,6652,1)
(1415,8021,1)
(4223,4716,1)
(4580,7884,1)
(2671,115,1)
(1365,8908,1)
(7732,4073,1)
(8429,196,1)
(4272,6430,1)
(1601,115,1)
(6246,2845,1)
(5641,2247,1)
(1683,8404,1)
(3431,1913,1)
(2287,8441,1)
(4452,3668,1)
(1937,115,1)
(4864,8506,1)
(6482,6957,1)
(4735,6650,1)
(7244,7130,1)
(1208,8937,1)
(2455,1985,1)
(1760,2794,1)
(4641,5862,1)
(8445,8928,1)
(2140,6713,1)
(2906,3984,1)
(2645,4486,1)
(721,2077,1)
(4602,8048,1)
(6306,410,1)
(528,1434,1)
(8596,5747,1)
(5519,115,1)
(5996,6681,1)
(2459,4977,1)
(2477,2389,1)
(8335,5547,1)
(1996,7000,1)
(4794,2023,1)
(4309,1632,1)
(2101,4862,1)
(4031,6218,1)
(765,6988,1)
(5553,2945,1)
(592,6143,1)
(74,3126,1)
(896,8707,1)
(5,5570,1)
(3713,2851,1)
(419,7896,1)
(3310,2607,1)
(1191,8431,1)
(8345,1807,1)
(2848,2415,1)
(3735,9069,1)
(5383,115,1)
(5266,8502,1)
(4171,6366,1)
(3541,691,1)
(6910,1379,1)
(1459,408,1)
(4797,5387,1)
(1523,1862,1)
(3937,5545,1)
(3849,7137,1)
(6708,1746,1)
(1165,2201,1)
(1670,8391,1)
(855,7210,1)
(2248,1933,1)
(6730,1531,1)
(1473,5689,1)
(4164,7804,1)
(3662,5591,1)
(8107,105,1)
(6015,262,1)
(8847,5574,1)
(410,3568,1)
(5204,1245,1)
(437,115,1)
(3540,8740,1)
(8288,7677,1)
(2496,2214,1)
(9011,363,1)
(4279,8671,1)
(1360,1969,1)
(3843,158,1)
(2521,269,1)
(4276,6992,1)
(2584,4239,1)
(6928,8391,1)
(5319,7688,1)
(4762,8190,1)
(2947,7202,1)
(6933,7537,1)
(6911,4064,1)
(3767,2479,1)
(5687,2845,1)
(7220,3694,1)
(1989,7593,1)
(4921,4150,1)
(6280,7200,1)
(5110,1538,1)
(988,393,1)
(4153,6053,1)
(7384,4767,1)
(860,5620,1)
(1889,6189,1)
(5761,3752,1)
(5666,2654,1)
(5585,2084,1)
(4570,1431,1)
(3903,7469,1)
(3776,8601,1)
(4424,3343,1)
(2294,7399,1)
(143,7951,1)
(9119,1327,1)
(7360,3981,1)
(7737,1695,1)
(8958,8881,1)
(4915,8505,1)
(3447,460,1)
(1415,8799,1)
(2058,110,1)
(6729,9030,1)
(5472,6295,1)
(45,8391,1)
(1870,4440,1)
(171,7861,1)
(4711,5624,1)
(1712,2125,1)
(8341,5829,1)
(2028,3460,1)
(9036,7210,1)
(1115,6150,1)
(2911,7415,1)
(6647,2441,1)
(1978,4639,1)
(2343,2688,1)
(7809,6396,1)
(6355,1527,1)
(5625,4507,1)
(8746,6577,1)
(6680,4764,1)
(309,8207,1)
(3896,5798,1)
(8965,70,1)
(2980,5321,1)
(354,5051,1)
(5275,6084,1)
(168,1102,1)
(1008,529,1)
(564,8186,1)
(2939,6408,1)
(7244,7259,1)
(3208,7119,1)
(7974,37,1)
(7244,1990,1)
(3499,4698,1)
(4505,8427,1)
(5190,951,1)
(5563,2379,1)
(6525,2628,1)
(1366,9040,1)
(1482,6300,1)
(9056,1740,1)
(5040,3186,1)
(349,5598,1)
(706,7577,1)
(5019,391,1)
(5705,8391,1)
(6808,7857,1)
(2956,7715,1)
(2835,3210,1)
(393,7265,1)
(2913,2599,1)
(8851,610,1)
(7754,6760,1)
(7310,706,1)
(6037,7987,1)
(3323,5736,1)
(6324,2908,1)
(6072,8391,1)
(4555,416,1)
(3393,2795,1)
(595,8391,1)
(6808,8677,1)
(8347,495,1)
(2800,5540,1)
(966,5156,1)
(3699,115,1)
(8771,1840,1)
(3210,5463,1)
(4567,6522,1)
(4425,8262,1)
(9030,3488,1)
(3605,2701,1)
(3185,339,1)
(8084,1982,1)
(197,3500,1)
(7828,3358,1)
(660,2043,1)
(3693,4188,1)
(3785,8391,1)
(4608,6649,1)
(4081,4327,1)
(3274,4992,1)
(788,6705,1)
(7763,7451,1)
(394,2203,1)
(5548,3451,1)
(6014,7316,1)
(524,6386,1)
(741,153,1)
(578,2845,1)
(1415,7499,1)
(5473,6772,1)
(3587,5386,1)
(1220,4619,1)
(6846,8695,1)
(5494,3565,1)
(1977,3548,1)
(7376,6552,1)
(4499,4509,1)
(4069,2073,1)
(1306,7150,1)
(1665,4668,1)
(6618,4126,1)
(8346,838,1)
(6949,3165,1)
(3804,8471,1)
(6728,438,1)
(3862,142,1)
(1924,115,1)
(4062,7054,1)
(8393,1092,1)
(190,5906,1)
(1521,5185,1)
(1415,5796,1)
(8943,447,1)
(457,1044,1)
(1415,6478,1)
(6459,706,1)
(3994,2418,1)
(299,4876,1)
(6378,8391,1)
(6570,1119,1)
(5811,5156,1)
(5487,2284,1)
(187,4770,1)
(3748,613,1)
(8062,1562,1)
(5090,4638,1)
(6458,1860,1)
(5133,2624,1)
(5971,5156,1)
(1004,5738,1)
(1268,6440,1)
(1712,5156,1)
(1104,7664,1)
(6928,115,1)
(1734,5753,1)
(4792,6469,1)
(3453,1331,1)
(6121,4876,1)
(9006,5737,1)
(167,5739,1)
(8733,3823,1)
(3631,5083,1)
(8200,5274,1)
(1953,6905,1)
(897,8391,1)
(8433,6067,1)
(1503,5911,1)
(3664,1149,1)
(6874,1756,1)
(2819,5241,1)
(7929,115,1)
(6341,115,1)
(584,372,1)
(7908,3913,1)
(5116,8568,1)
(5499,1603,1)
(987,4202,1)
(2627,3366,1)
(6223,115,1)
(6383,8302,1)
(7640,4122,1)
(7493,5775,1)
(47,4339,1)
(4606,2655,1)
(7902,3674,1)
(6457,8981,1)
(403,2989,1)
(5787,2509,1)
(3563,7857,1)
(8879,1238,1)
(7191,8391,1)
(4256,6193,1)
(1179,6843,1)
(5369,115,1)
(8077,545,1)
(2128,3016,1)
(4466,115,1)
(5089,8300,1)
(1907,3248,1)
(4417,115,1)
(6206,7502,1)
(5583,8391,1)
(1324,807,1)
(1787,3732,1)
(5414,8597,1)
(1684,6712,1)
(4204,5271,1)
(1200,1952,1)
(5535,3084,1)
(7219,7331,1)
(3869,7750,1)
(8242,8679,1)
(1364,1509,1)
(7655,8138,1)
(1650,4348,1)
(1438,8391,1)
(2845,4789,1)
(5489,115,1)
(7616,5205,1)
(3516,2721,1)
(7706,8232,1)
(586,7194,1)
(4143,3302,1)
(7990,7541,1)
(5887,8677,1)
(7842,9016,1)
(3327,2202,1)
(8996,463,1)
(4792,4356,1)
(5096,1149,1)
(52,5353,1)
(7152,3805,1)
(1907,8156,1)
(2565,506,1)
(5619,7421,1)
(4319,4199,1)
(8570,5440,1)
(8241,7799,1)
(6560,1488,1)
(819,3701,1)
(4647,115,1)
(1885,3355,1)
(673,7149,1)
(4004,4706,1)
(6632,8391,1)
(3738,351,1)
(6593,3923,1)
(7898,611,1)
(8406,7269,1)
(3213,8471,1)
(3543,1242,1)
(5377,4462,1)
(8803,5639,1)
(6431,5829,1)
(3931,5498,1)
(7507,4320,1)
(2087,8778,1)
(2836,3076,1)
(3899,8391,1)
(2544,4515,1)
(1675,8163,1)
(358,8391,1)
(8953,2058,1)
(6672,4131,1)
(6298,3081,1)
(2974,1476,1)
(824,8391,1)
(4544,7281,1)
(4046,5452,1)
(5555,115,1)
(2368,4194,1)
(5523,4797,1)
(6508,5938,1)
(3240,6577,1)
(2315,8391,1)
(6006,7780,1)
(5949,1669,1)
(5232,5094,1)
(5538,3169,1)
(7386,2488,1)
(7522,4236,1)
(3647,2283,1)
(4464,6715,1)
(8671,7663,1)
(9024,3107,1)
(3552,6574,1)
(8410,7101,1)
(4219,5156,1)
(4375,3970,1)
(5014,6541,1)
(5605,2345,1)
(3220,4923,1)
(3696,1524,1)
(4327,7512,1)
(4097,5351,1)
(283,4897,1)
(8028,2608,1)
(4916,8756,1)
(1918,6028,1)
(2995,7257,1)
(79,9024,1)
(8674,6150,1)
(1612,2051,1)
(1878,2209,1)
(3973,5451,1)
(6918,8736,1)
(6599,276,1)
(7596,5836,1)
(7619,1089,1)
(6815,8158,1)
(4178,5615,1)
(7230,4473,1)
(4424,5156,1)
(6094,4300,1)
(1402,6968,1)
(536,5294,1)
(3263,2907,1)
(8107,4379,1)
(1610,1312,1)
(829,6577,1)
(4683,2316,1)
(4005,8264,1)
(5882,8760,1)
(8723,115,1)
(8688,6074,1)
(2423,8391,1)
(1619,7781,1)
(827,3265,1)
(1982,5422,1)
(7752,6479,1)
(1254,3769,1)
(715,6491,1)
(5589,7241,1)
(7004,1460,1)
(6354,6182,1)
(3574,3187,1)
(4375,4524,1)
(3107,7453,1)
(6385,5918,1)
(7192,537,1)
(3361,1300,1)
(6063,8391,1)
(7293,8362,1)
(1524,1704,1)
(364,23,1)
(150,3157,1)
(1664,6686,1)
(1415,8111,1)
(738,4032,1)
(5665,1042,1)
(6408,3769,1)
(2558,3710,1)
(7939,1417,1)
(1484,7428,1)
(8138,753,1)
(253,2897,1)
(303,8111,1)
(6378,115,1)
(5721,8391,1)
(7833,5829,1)
(8648,115,1)
(939,5119,1)
(5027,3507,1)
(3602,7064,1)
(4653,6291,1)
(4006,4211,1)
(7258,2666,1)
(2657,9075,1)
(8618,8391,1)
(5510,8017,1)
(3877,8391,1)
(5365,2096,1)
(4011,6426,1)
(8230,2140,1)
(5635,5630,1)
(3130,5481,1)
(3683,6510,1)
(7126,7686,1)
(607,4784,1)
(2620,179,1)
(3762,640,1)
(6502,4375,1)
(4643,6822,1)
(9120,4030,1)
(1583,4044,1)
(1656,8178,1)
(7085,8062,1)
(8751,6354,1)
(7335,5066,1)
(6231,3488,1)
(1415,6981,1)
(5288,5033,1)
(956,6659,1)
(83,6693,1)
(5391,6056,1)
(3129,7420,1)
(7150,300,1)
(8075,5891,1)
(8374,8338,1)
(2957,3095,1)
(1426,7736,1)
(1888,4925,1)
(8717,4693,1)
(2346,6351,1)
(7571,115,1)
(1394,7816,1)
(3804,1270,1)
(7685,832,1)
(7055,2564,1)
(2059,717,1)
(5226,4472,1)
(796,5225,1)
(1373,397,1)
(7674,5553,1)
(5110,115,1)
(7364,8341,1)
(1450,4532,1)
(1474,3215,1)
(8742,7336,1)
(539,3348,1)
(9138,1778,1)
(1955,8391,1)
(1235,823,1)
(260,3375,1)
(1654,1626,1)
(7408,2309,1)
(1435,135,1)
(5944,2921,1)
(2293,115,1)
(6949,8013,1)
(8305,393,1)
(7353,5383,1)
(5615,7494,1)
(2881,8998,1)
(7841,7731,1)
(7921,9090,1)
(8033,6187,1)
(4378,115,1)
(674,5824,1)
(5481,2876,1)
(6300,3073,1)
(7063,115,1)
(5624,1275,1)
(6102,2142,1)
(7558,5050,1)
(7393,6820,1)
(1017,6711,1)
(5656,2607,1)
(8008,115,1)
(5575,4765,1)
(527,7292,1)
(6091,8391,1)
(2067,6041,1)
(3346,253,1)
(9058,7279,1)
(4700,1488,1)
(2749,3225,1)
(2889,9051,1)
(3566,7641,1)
(8035,4876,1)
(1709,6107,1)
(3419,6246,1)
(1836,6031,1)
(8580,448,1)
(8914,8462,1)
(1605,1738,1)
(8761,5243,1)
(1212,6389,1)
(5998,4748,1)
(7394,5170,1)
(7408,3451,1)
(5375,1855,1)
(9123,7558,1)
(1124,3478,1)
(6851,2879,1)
(1777,8193,1)
(2210,459,1)
(61,5812,1)
(3146,5069,1)
(1641,1960,1)
(5728,7481,1)
(8818,7607,1)
(2369,3965,1)
(2775,8644,1)
(5565,5975,1)
(4836,115,1)
(7013,6824,1)
(4517,408,1)
(5654,5346,1)
(8867,4139,1)
(3333,1365,1)
(8928,4781,1)
(1936,2019,1)
(1772,2114,1)
(7702,5311,1)
(4304,7464,1)
(248,8391,1)
(694,3042,1)
(5685,6301,1)
(8648,2977,1)
(7328,1532,1)
(8510,1107,1)
(7662,7864,1)
(6255,14,1)
(8985,1265,1)
(2683,7702,1)
(5663,6814,1)
(2572,1603,1)
(3296,8050,1)
(2030,1891,1)
(2315,1004,1)
(133,2862,1)
(4443,2339,1)
(8125,573,1)
(7057,115,1)
(6652,5716,1)
(3011,6806,1)
(3821,2057,1)
(6064,6575,1)
(3617,4051,1)
(1997,2896,1)
(8811,115,1)
(6781,6791,1)
(3873,523,1)
(7042,7072,1)
(807,7253,1)
(3068,3866,1)
(5718,2222,1)
(5294,7963,1)
(3004,4903,1)
(6667,1244,1)
(8245,5688,1)
(4107,4908,1)
(1343,4788,1)
(6977,32,1)
(5494,3889,1)
(3213,7039,1)
(1707,3227,1)
(1168,115,1)
(6069,7577,1)
(267,1158,1)
(5293,6151,1)
(3173,8693,1)
(7205,4856,1)
(7796,5293,1)
(3900,6109,1)
(1942,9015,1)
(877,2223,1)
(9049,6828,1)
(4530,7889,1)
(2201,5861,1)
(1824,3750,1)
(416,115,1)
(8234,4533,1)
(7432,115,1)
(3356,8391,1)
(1642,8994,1)
(4909,4619,1)
(6184,8673,1)
(1283,3330,1)
(5638,2681,1)
(8030,5979,1)
(3792,9124,1)
(4988,2690,1)
(3625,2845,1)
(3818,4377,1)
(2332,5162,1)
(5857,3852,1)
(9104,2584,1)
(7756,7091,1)
(5394,115,1)
(2287,4149,1)
(3213,6649,1)
(1506,4068,1)
(5911,4936,1)
(6284,7039,1)
(3571,3576,1)
(8160,2436,1)
(2293,2967,1)
(163,2606,1)
(3109,745,1)
(8134,8448,1)
(8251,1210,1)
(2966,6913,1)
(3166,1614,1)
(6865,361,1)
(1751,6259,1)
(4136,1912,1)
(1260,2879,1)
(6606,8815,1)
(5844,5369,1)
(5197,5955,1)
(4847,2845,1)
(3067,4457,1)
(4173,9130,1)
(8621,9127,1)
(5809,7039,1)
(4510,5633,1)
(8296,3875,1)
(3804,1280,1)
(4364,2587,1)
(3756,4918,1)
(6570,1096,1)
(3610,7273,1)
(7151,3666,1)
(3,1156,1)
(3630,3457,1)
(4008,6507,1)
(6732,8714,1)
(4666,8302,1)
(1432,1149,1)
(1117,5302,1)
(8806,115,1)
(6564,1254,1)
(7290,6859,1)
(7498,532,1)
(2842,8391,1)
(7812,3621,1)
(1827,3440,1)
(2287,7039,1)
(6454,1440,1)
(69,7317,1)
(3800,4292,1)
(3758,1511,1)
(3191,1317,1)
(3423,8758,1)
(7526,7885,1)
(3290,1050,1)
(1875,6198,1)
(4280,8391,1)
(9013,3968,1)
(8894,5459,1)
(2582,8921,1)
(521,3892,1)
(5849,2787,1)
(6502,3804,1)
(4174,6062,1)
(8556,3585,1)
(8859,5116,1)
(5209,1902,1)
(267,6649,1)
(8637,5138,1)
(1556,7997,1)
(7146,1183,1)
(4742,2716,1)
(8298,3067,1)
(2931,8001,1)
(6495,7647,1)
(7493,2116,1)
(2411,1207,1)
(7057,7853,1)
(6049,1699,1)
(7790,4581,1)
(5533,1111,1)
(916,3833,1)
(5569,762,1)
(7775,8391,1)
(6508,5007,1)
(6256,4335,1)
(3294,5993,1)
(8718,1867,1)
(2295,4037,1)
(1967,115,1)
(5652,4309,1)
(3511,1496,1)
(7097,4340,1)
(2976,1942,1)
(5247,3768,1)
(193,7665,1)
(7083,3207,1)
(8038,8471,1)
(3788,426,1)
(782,4697,1)
(3275,6338,1)
(3950,8231,1)
(3138,2845,1)
(7097,7079,1)
(719,6768,1)
(2243,8391,1)
(2945,3612,1)
(1739,3687,1)
(6548,154,1)
(8497,6809,1)
(2489,2022,1)
(405,777,1)
(6367,6665,1)
(8747,7657,1)
(6859,3871,1)
(6762,5156,1)
(7656,3621,1)
(3288,5888,1)
(6502,267,1)
(3646,6354,1)
(6031,1488,1)
(5279,6605,1)
(2688,8391,1)
(1319,2454,1)
(1361,7684,1)
(1250,2531,1)
(5334,445,1)
(8142,5472,1)
(8005,3089,1)
(4538,8060,1)
(7163,8593,1)
(5837,631,1)
(9037,198,1)
(6532,6912,1)
(215,5421,1)
(7592,8555,1)
(3645,7021,1)
(8487,7575,1)
(707,402,1)
(245,825,1)
(3956,3803,1)
(8194,6173,1)
(3878,1680,1)
(2005,7033,1)
(6901,5796,1)
(7721,1834,1)
(6302,1461,1)
(7626,3889,1)
(4807,5722,1)
(8248,202,1)
(3509,4515,1)
(5752,4780,1)
(2623,115,1)
(3213,8458,1)
(9073,115,1)
(4775,6600,1)
(7866,5997,1)
(2274,6623,1)
(2034,3435,1)
(6088,8391,1)
(2435,8833,1)
(3805,991,1)
(2416,4071,1)
(8518,8316,1)
(4855,961,1)
(4230,5684,1)
(6095,6537,1)
(2835,5463,1)
(8338,2962,1)
(4172,4039,1)
(77,8938,1)
(5673,8538,1)
(4942,8391,1)
(7665,4401,1)
(6368,8992,1)
(1628,2395,1)
(5184,6190,1)
(2024,8530,1)
(808,7714,1)
(1352,8931,1)
(1415,3986,1)
(1285,7950,1)
(4509,5838,1)
(2287,3889,1)
(4333,1217,1)
(2272,6858,1)
(6764,4576,1)
(90,4590,1)
(2265,7126,1)
(3509,6474,1)
(3549,2293,1)
(6289,6771,1)
(4654,6939,1)
(6327,2283,1)
(9073,9081,1)
(473,8391,1)
(932,6740,1)
(6691,6342,1)
(2162,8391,1)
(4239,5565,1)
(6057,6845,1)
(1756,6534,1)
(9059,3401,1)
(3740,4031,1)
(1147,3977,1)
(5510,8677,1)
(6914,2449,1)
(5602,392,1)
(2126,8027,1)
(2741,19,1)
(450,3689,1)
(7966,700,1)
(6611,4106,1)
(6038,7204,1)
(4070,8383,1)
(3217,5397,1)
(1670,115,1)
(7620,5138,1)
(5947,777,1)
(4742,4876,1)
(2206,1526,1)
(2168,6651,1)
(3621,2112,1)
(2512,4445,1)
(8981,2426,1)
(7454,3393,1)
(2667,2978,1)
(4180,5978,1)
(3344,5587,1)
(2147,115,1)
(6323,6285,1)
(3559,1881,1)
(1221,1763,1)
(5465,5192,1)
(6220,6129,1)
(2113,3305,1)
(4793,1191,1)
(5590,7902,1)
(6663,8391,1)
(6821,4610,1)
(7973,1346,1)
(2475,115,1)
(1919,7763,1)
(4536,4707,1)
(7977,1697,1)
(1853,6186,1)
(6961,6202,1)
(6984,2611,1)
(2868,7210,1)
(8756,3145,1)
(4295,5802,1)
(4799,6325,1)
(2059,1741,1)
(2975,8165,1)
(234,3738,1)
(6664,2690,1)
(1765,6168,1)
(2208,5914,1)
(8289,4387,1)
(8837,8391,1)
(7243,4117,1)
(3669,2330,1)
(1192,9140,1)
(1415,3889,1)
(5428,5829,1)
(2978,8391,1)
(4947,9068,1)
(4625,84,1)
(2535,5364,1)
(7303,6531,1)
(352,1949,1)
(4344,8391,1)
(3433,777,1)
(2843,8970,1)
(5345,24,1)
(4338,5775,1)
(3443,5379,1)
(6631,8721,1)
(3807,8391,1)
(5380,6601,1)
(906,3091,1)
(9090,2845,1)
(5835,2696,1)
(6303,4514,1)
(3022,5605,1)
(4847,2484,1)
(8205,5164,1)
(3213,8021,1)
(4582,5566,1)
(2245,5627,1)
(2194,5132,1)
(1116,3844,1)
(3621,8021,1)
(4748,7217,1)
(6993,3983,1)
(1204,4842,1)
(3241,5317,1)
(300,6580,1)
(5638,1158,1)
(6317,2845,1)
(7120,6635,1)
(8316,7778,1)
(8884,1522,1)
(4337,8391,1)
(7373,2845,1)
(1208,8391,1)
(7096,4564,1)
(7372,8548,1)
(4497,7547,1)
(7196,8391,1)
(5887,3163,1)
(7590,279,1)
(8542,4630,1)
(5638,7039,1)
(4820,592,1)
(633,306,1)
(571,4794,1)
(4629,7642,1)
(2718,6414,1)
(6967,7608,1)
(3248,1628,1)
(3505,7652,1)
(7759,5071,1)
(4398,8391,1)
(8560,4378,1)
(986,8347,1)
(7643,6778,1)
(3992,6687,1)
(8820,8391,1)
(3774,2845,1)
(4125,2814,1)
(4225,1895,1)
(7857,3384,1)
(1241,8391,1)
(1727,9097,1)
(7735,5156,1)
(6807,711,1)
(8011,7717,1)
(3147,2782,1)
(6088,115,1)
(3507,4876,1)
(8787,1574,1)
(3348,2282,1)
(2287,4524,1)
(3049,8810,1)
(5779,6608,1)
(8740,8574,1)
(8088,6906,1)
(6716,7108,1)
(7802,4166,1)
(2354,115,1)
(6290,7990,1)
(7263,6415,1)
(4380,5426,1)
(6018,3039,1)
(2487,115,1)
(6854,38,1)
(6284,4515,1)
(3801,1938,1)
(5342,6682,1)
(4127,7019,1)
(9035,7095,1)
(4864,115,1)
(5851,4121,1)
(2094,8391,1)
(7820,551,1)
(1535,8367,1)
(2061,7048,1)
(130,7233,1)
(389,4233,1)
(2055,2491,1)
(6215,635,1)
(1415,1851,1)
(8313,8391,1)
(3791,115,1)
(5321,1493,1)
(8405,3342,1)
(2504,8817,1)
(5668,633,1)
(8582,115,1)
(2498,1797,1)
(1177,6676,1)
(7867,7978,1)
(5632,5580,1)
(6121,1813,1)
(5868,8071,1)
(3594,8391,1)
(420,356,1)
(1686,1268,1)
(4172,8391,1)
(4066,7483,1)
(6555,2799,1)
(8743,3955,1)
(7525,2845,1)
(5977,4583,1)
(4871,4569,1)
(7068,8782,1)
(1557,8331,1)
(1166,7554,1)
(8417,5454,1)
(1401,8390,1)
(2538,3324,1)
(2065,1144,1)
(8763,949,1)
(5989,306,1)
(5146,2859,1)
(9001,4467,1)
(4644,8157,1)
(6646,5568,1)
(6987,3961,1)
(3497,7401,1)
(920,4262,1)
(6010,5136,1)
(1427,5370,1)
(5539,1580,1)
(5716,6737,1)
(4141,2596,1)
(7555,7549,1)
(921,4691,1)
(2532,7073,1)
(5069,6995,1)
(3817,6118,1)
(5638,3657,1)
(3491,2517,1)
(4199,2011,1)
(1806,2636,1)
(2702,3036,1)
(244,40,1)
(902,115,1)
(2674,6201,1)
(922,3637,1)
(8490,326,1)
(8846,7170,1)
(402,2043,1)
(8561,115,1)
(3368,768,1)
(4470,7358,1)
(309,115,1)
(5259,873,1)
(612,57,1)
(7821,7797,1)
(3244,2828,1)
(4452,952,1)
(5317,7910,1)
(1276,4074,1)
(1906,3604,1)
(1346,4468,1)
(8579,112,1)
(5164,115,1)
(4322,1108,1)
(8640,6215,1)
(4515,3164,1)
(6795,7618,1)
(815,8303,1)
(6782,3397,1)
(7336,7976,1)
(2919,8909,1)
(3982,4412,1)
(2964,6292,1)
(2854,3793,1)
(5419,7915,1)
(6330,1426,1)
(2381,8391,1)
(3515,3971,1)
(1398,9122,1)
(17,861,1)
(3840,457,1)
(3483,1373,1)
(5855,3911,1)
(2701,4798,1)
(3293,581,1)
(3247,6149,1)
(7631,4750,1)
(7276,7446,1)
(1995,7830,1)
(5980,1099,1)
(5461,4958,1)
(3213,3889,1)
(6505,6003,1)
(5192,3557,1)
(6559,184,1)
(5113,3290,1)
(6929,1126,1)
(4633,8541,1)
(4596,6141,1)
(9028,8340,1)
(7499,8391,1)
(3938,7402,1)
(334,5475,1)
(7244,7971,1)
(6466,3719,1)
(9097,950,1)
(5679,255,1)
(3377,1149,1)
(4987,2649,1)
(4462,5586,1)
(1047,8391,1)
(994,5509,1)
(3078,8391,1)
(8789,8529,1)
(6601,7176,1)
(157,3722,1)
(1802,6811,1)
(1048,2899,1)
(7358,6236,1)
(6384,2864,1)
(1531,3697,1)
(7890,4876,1)
(1089,7475,1)
(8162,6203,1)
(5059,6166,1)
(8290,921,1)
(6101,6946,1)
(3800,4401,1)
(8221,5816,1)
(6409,3034,1)
(4508,3725,1)
(7605,7846,1)
(7824,2698,1)
(7644,403,1)
(4157,115,1)
(5214,3565,1)
(2065,4019,1)
(8284,6909,1)
(7140,4969,1)
(2643,2960,1)
(2305,3925,1)
(824,115,1)
(163,4357,1)
(1400,115,1)
(6229,704,1)
(8362,8360,1)
(8262,9128,1)
(1050,5614,1)
(2501,3103,1)
(173,1235,1)
(3524,4380,1)
(6069,4445,1)
(9087,472,1)
(1282,8391,1)
(6284,8458,1)
(415,7400,1)
(276,6398,1)
(2002,4319,1)
(8905,3223,1)
(7716,442,1)
(6866,4831,1)
(3906,6101,1)
(7085,8391,1)
(9034,3585,1)
(6734,8391,1)
(1947,8391,1)
(3058,6866,1)
(3590,4427,1)
(4861,4184,1)
(7883,8391,1)
(7626,9130,1)
(6446,4243,1)
(8087,453,1)
(4976,8677,1)
(513,8356,1)
(6370,7524,1)
(9090,8391,1)
(4890,3607,1)
(523,115,1)
(5762,8156,1)
(8206,6632,1)
(8901,7561,1)
(2713,2180,1)
(8296,3621,1)
(8109,6987,1)
(4151,3177,1)
(5291,2088,1)
(587,228,1)
(8104,5123,1)
(2454,2071,1)
(7699,5464,1)
(8552,1078,1)
(6502,3509,1)
(5879,238,1)
(2031,8856,1)
(4274,8892,1)
(118,4284,1)
(6913,8836,1)
(5431,2218,1)
(3365,5001,1)
(5791,3000,1)
(3899,115,1)
(668,4303,1)
(5498,4374,1)
(5186,4945,1)
(2084,2021,1)
(1672,3195,1)
(1227,115,1)
(775,8179,1)
(1326,346,1)
(1992,572,1)
(3024,7059,1)
(4025,6719,1)
(5074,4144,1)
(2257,1488,1)
(1700,3050,1)
(1462,910,1)
(8148,115,1)
(8321,2361,1)
(8224,4217,1)
(117,6296,1)
(2085,6227,1)
(5593,8111,1)
(5255,1972,1)
(4461,2987,1)
(3902,3742,1)
(6275,5741,1)
(8127,2612,1)
(3190,8625,1)
(8047,8677,1)
(2482,6577,1)
(1415,8594,1)
(8018,2235,1)
(277,1995,1)
(4474,8044,1)
(171,2414,1)
(1423,18,1)
(5614,8133,1)
(6864,4976,1)
(7244,1749,1)
(7349,115,1)
(1694,8391,1)
(8449,4366,1)
(5507,3868,1)
(8828,7728,1)
(4539,7940,1)
(8925,3764,1)
(8884,115,1)
(4821,9014,1)
(7458,7485,1)
(3849,8391,1)
(2603,8032,1)
(5099,672,1)
(5224,8214,1)
(3362,4415,1)
(43,4064,1)
(8209,2141,1)
(2089,512,1)
(8397,2130,1)
(4604,2526,1)
(8229,3340,1)
(3804,5452,1)
(6844,6950,1)
(163,4876,1)
(5080,3570,1)
(7104,3858,1)
(6317,8922,1)
(7716,115,1)
(8889,3969,1)
(4833,6050,1)
(2557,3272,1)
(1774,488,1)
(9117,115,1)
(5418,6339,1)
(5076,3862,1)
(7923,8391,1)
(2860,5765,1)
(2287,3215,1)
(1954,7079,1)
(6143,7538,1)
(7470,8913,1)
(562,115,1)
(7725,264,1)
(2964,5196,1)
(5566,2362,1)
(4344,7711,1)
(5110,8391,1)
(750,215,1)
(7600,4333,1)
(7415,4120,1)
(502,1149,1)
(5057,1149,1)
(5682,4467,1)
(4609,5919,1)
(842,593,1)
(7652,2546,1)
(1217,2262,1)
(1171,8395,1)
(4706,6294,1)
(6993,5961,1)
(7320,7649,1)
(3955,1832,1)
(2057,1189,1)
(2078,8049,1)
(4622,5733,1)
(7524,1149,1)
(218,3878,1)
(5638,489,1)
(6419,7385,1)
(2010,1583,1)
(1415,3223,1)
(7005,115,1)
(853,2703,1)
(8720,8211,1)
(5129,2869,1)
(4344,4246,1)
(1471,5156,1)
(8383,8333,1)
(268,1149,1)
(3047,8875,1)
(3604,3938,1)
(6057,8391,1)
(2247,3849,1)
(3827,7390,1)
(7244,6615,1)
(274,9066,1)
(1225,478,1)
(919,281,1)
(5574,7104,1)
(2478,5563,1)
(2748,7478,1)
(2321,2127,1)
(1601,1218,1)
(2414,3537,1)
(3119,8391,1)
(6216,5019,1)
(8677,405,1)
(5109,3621,1)
(1210,8391,1)
(3831,8786,1)
(5988,9022,1)
(3844,318,1)
(307,6146,1)
(7754,3651,1)
(4822,6357,1)
(302,6784,1)
(2403,4220,1)
(5119,1140,1)
(800,115,1)
(1866,8284,1)
(5433,3530,1)
(5414,2845,1)
(4229,3799,1)
(2202,6314,1)
(1428,2268,1)
(4104,8487,1)
(7736,1597,1)
(4834,0,1)
(6234,8391,1)
(1706,5199,1)
(5991,6475,1)
(8096,8649,1)
(4146,2089,1)
(6190,692,1)
(2828,459,1)
(1713,626,1)
(3081,6512,1)
(4978,4517,1)
(5249,6888,1)
(402,9025,1)
(8185,7746,1)
(7907,8756,1)
(3283,7372,1)
(345,8391,1)
(8382,5740,1)
(8866,4996,1)
(7133,1149,1)
(6328,2691,1)
(2171,8391,1)
(1516,8598,1)
(2716,3292,1)
(567,8274,1)
(2223,362,1)
(4358,3658,1)
(3701,6184,1)
(6868,7928,1)
(3819,8391,1)
(8297,6057,1)
(6545,2912,1)
(2537,5922,1)
(2543,1158,1)
(5207,2097,1)
(678,2660,1)
(3604,7563,1)
(6132,3569,1)
(3639,4894,1)
(8282,2231,1)
(6926,115,1)
(5136,1639,1)
(5186,7754,1)
(3985,1585,1)
(6943,3655,1)
(339,115,1)
(713,5056,1)
(1644,7771,1)
(526,8439,1)
(7424,2936,1)
(563,2283,1)
(8977,5597,1)
(5957,2949,1)
(4334,5316,1)
(5263,3517,1)
(7226,8580,1)
(5777,4390,1)
(3804,2497,1)
(2296,1171,1)
(3855,5958,1)
(8949,2835,1)
(492,5360,1)
(3642,5183,1)
(8143,341,1)
(6813,5022,1)
(6464,7989,1)
(1947,6628,1)
(104,202,1)
(549,3153,1)
(1545,6154,1)
(997,945,1)
(7703,6351,1)
(8742,8391,1)
(9130,7174,1)
(3513,1761,1)
(7298,5868,1)
(5335,5701,1)
(658,501,1)
(7840,2763,1)
(144,2118,1)
(8883,6914,1)
(4335,4974,1)
(161,115,1)
(2594,7249,1)
(5948,3123,1)
(3140,7413,1)
(5868,1048,1)
(2703,5939,1)
(263,4959,1)
(1049,8783,1)
(1969,8183,1)
(7813,5158,1)
(6155,7958,1)
(2566,4079,1)
(4234,4611,1)
(663,2751,1)
(2338,499,1)
(1091,7909,1)
(3942,1783,1)
(5744,6320,1)
(1873,8391,1)
(5246,3211,1)
(2739,8162,1)
(5920,5147,1)
(3256,4985,1)
(1052,115,1)
(4039,2200,1)
(402,1048,1)
(3009,3480,1)
(4150,7556,1)
(2653,8363,1)
(6449,8391,1)
(4603,2717,1)
(4280,115,1)
(6111,8391,1)
(6795,115,1)
(9008,4917,1)
(7123,369,1)
(1725,5040,1)
(7134,2307,1)
(7194,200,1)
(4889,2450,1)
(573,159,1)
(273,4628,1)
(9032,8037,1)
(7682,1414,1)
(3585,9137,1)
(3754,5852,1)
(5212,2194,1)
(5713,7552,1)
(7664,7897,1)
(1937,8391,1)
(4459,1334,1)
(5545,7827,1)
(1586,6680,1)
(3603,8879,1)
(2895,2288,1)
(4811,6171,1)
(4482,8564,1)
(5140,7210,1)
(4287,2873,1)
(6130,8180,1)
(25,8391,1)
(7244,8968,1)
(5109,8391,1)
(8396,6214,1)
(949,2144,1)
(8815,3542,1)
(7256,8756,1)
(9114,8283,1)
(5803,109,1)
(8531,8391,1)
(4758,9018,1)
(7432,1202,1)
(7333,6424,1)
(2352,3472,1)
(1584,228,1)
(3317,2895,1)
(6024,977,1)
(7035,2679,1)
(2347,3751,1)
(5941,7114,1)
(4320,4,1)
(4805,7136,1)
(750,5421,1)
(7653,8376,1)
(3463,1975,1)
(3803,4948,1)
(1738,8068,1)
(5311,4107,1)
(363,920,1)
(884,5968,1)
(2954,6428,1)
(6056,1413,1)
(3743,7150,1)
(1730,4158,1)
(706,4445,1)
(5275,9059,1)
(6948,5374,1)
(9043,6199,1)
(2468,8391,1)
(3353,3381,1)
(6520,5932,1)
(2640,6614,1)
(5778,5216,1)
(2544,8111,1)
(7820,8391,1)
(5180,8117,1)
(1801,3263,1)
(5885,4143,1)
(2100,147,1)
(5403,5708,1)
(4311,7186,1)
(2278,5764,1)
(8876,6734,1)
(8715,1488,1)
(3714,8812,1)
(4816,1784,1)
(7507,2187,1)
(6279,9092,1)
(1167,115,1)
(6088,715,1)
(3141,4168,1)
(966,2862,1)
(148,8135,1)
(6970,270,1)
(3838,7568,1)
(6320,6704,1)
(8233,7962,1)
(1415,4197,1)
(6090,8695,1)
(3376,42,1)
(8956,6270,1)
(8635,2477,1)
(2424,6938,1)
(6771,1137,1)
(550,4526,1)
(7471,7991,1)
(1112,8735,1)
(3596,2185,1)
(4253,1410,1)
(4410,8026,1)
(6217,5267,1)
(7638,2984,1)
(463,115,1)
(7419,1583,1)
(7262,4299,1)
(6080,8391,1)
(4566,2538,1)
(3804,2861,1)
(3192,5167,1)
(1766,115,1)
(2972,5388,1)
(5188,7183,1)
(6963,1269,1)
(385,1402,1)
(8180,5751,1)
(1193,485,1)
(1223,6125,1)
(5000,759,1)
(162,4053,1)
(7692,7178,1)
(1982,4876,1)
(2907,5874,1)
(5819,4546,1)
(2847,2146,1)
(5593,1158,1)
(910,9054,1)
(7966,9130,1)
(1194,2874,1)
(4911,3333,1)
(7093,6216,1)
(5367,4837,1)
(4021,4565,1)
(3371,270,1)
(1379,5672,1)
(4089,3451,1)
(1765,7743,1)
(3197,3650,1)
(7345,6436,1)
(1138,1488,1)
(4576,138,1)
(1032,7417,1)
(5294,5823,1)
(3621,6649,1)
(13,5261,1)
(4666,6383,1)
(435,2063,1)
(7080,7832,1)
(8273,5660,1)
(4038,8378,1)
(4808,3119,1)
(8817,4026,1)
(878,3,1)
(2165,155,1)
(3203,845,1)
(2203,2043,1)
(5257,4946,1)
(8091,8370,1)
(3522,6995,1)
(2431,6392,1)
(6921,5932,1)
(6419,9130,1)
(8427,8664,1)
(4935,1515,1)
(9091,6365,1)
(3484,4041,1)
(413,2890,1)
(123,8902,1)
(5138,3074,1)
(8505,7761,1)
(6545,1925,1)
(7994,5336,1)
(1932,5141,1)
(5483,1048,1)
(6609,8391,1)
(7551,1021,1)
(1776,2432,1)
(8798,7023,1)
(4594,292,1)
(1831,5256,1)
(4206,8594,1)
(8617,3298,1)
(882,1544,1)
(4228,3898,1)
(7498,8391,1)
(3834,5156,1)
(2362,1025,1)
(7940,481,1)
(8940,7222,1)
(1074,8840,1)
(3306,7391,1)
(4375,4622,1)
(367,5636,1)
(3942,3555,1)
(2771,6577,1)
(1500,4029,1)
(2904,8391,1)
(9134,6588,1)
(8891,3262,1)
(6266,1523,1)
(4752,1677,1)
(5172,6679,1)
(8398,6031,1)
(6756,4558,1)
(2233,7001,1)
(4580,8391,1)
(7962,2043,1)
(3833,8572,1)
(189,7057,1)
(4083,3908,1)
(6835,7914,1)
(2992,3563,1)
(6104,115,1)
(4709,3825,1)
(4774,3699,1)
(6084,538,1)
(6596,219,1)
(2287,2065,1)
(6520,5072,1)
(8317,1458,1)
(7139,277,1)
(4873,3215,1)
(6808,6751,1)
(8435,2621,1)
(1266,8267,1)
(6938,165,1)
(7088,3288,1)
(3050,1689,1)
(535,261,1)
(2012,166,1)
(2342,2346,1)
(6985,2024,1)
(4746,754,1)
(562,8391,1)
(3507,7250,1)
(4843,8475,1)
(1298,7833,1)
(1850,6527,1)
(3876,8391,1)
(4297,6263,1)
(7431,8030,1)
(1462,8391,1)
(2499,2829,1)
(5250,2982,1)
(5227,8216,1)
(100,115,1)
(8139,8391,1)
(4439,4881,1)
(2314,4295,1)
(3350,1824,1)
(4100,7775,1)
(3902,1525,1)
(7733,8967,1)
(2811,8855,1)
(8421,1819,1)
(7101,8523,1)
(2021,4697,1)
(4306,6405,1)
(8247,6525,1)
(4955,6835,1)
(4375,7045,1)
(8396,8844,1)
(7072,2959,1)
(2400,2252,1)
(330,7792,1)
(2580,6783,1)
(795,5735,1)
(5031,6958,1)
(8849,8391,1)
(7210,8018,1)
(3804,7280,1)
(8878,3483,1)
(1608,3431,1)
(5812,7060,1)
(3364,7859,1)
(5501,2844,1)
(5492,5325,1)
(5612,4772,1)
(1201,5212,1)
(447,2810,1)
(7244,6319,1)
(8059,5538,1)
(2293,8391,1)
(8616,8391,1)
(3084,6369,1)
(3214,8391,1)
(7773,8756,1)
(530,5269,1)
(985,89,1)
(2672,3332,1)
(6545,7365,1)
(4106,4731,1)
(7489,1010,1)
(7075,7455,1)
(4388,3992,1)
(3363,1556,1)
(5593,4587,1)
(7670,8391,1)
(5130,1292,1)
(2162,5759,1)
(2136,8592,1)
(3765,3100,1)
(9073,8391,1)
(4012,8391,1)
(8279,115,1)
(204,6665,1)
(6775,4623,1)
(2142,7045,1)
(7561,8391,1)
(1940,491,1)
(1857,7171,1)
(6104,5528,1)
(1415,1158,1)
(4883,2274,1)
(3269,1758,1)
(5512,2123,1)
(7444,4876,1)
(1027,8670,1)
(3405,4052,1)
(5614,624,1)
(4397,1114,1)
(2259,2064,1)
(9052,410,1)
(7683,6590,1)
(8313,115,1)
(9022,5312,1)
(2091,8833,1)
(2529,3069,1)
(3250,8391,1)
(2823,115,1)
(3026,952,1)
(1131,2527,1)
(5069,8521,1)
(7186,5898,1)
(6284,4587,1)
(8888,156,1)
(7442,694,1)
(151,6292,1)
(5644,5080,1)
(339,2845,1)
(268,4703,1)
(1542,2081,1)
(7954,2460,1)
(2533,7616,1)
(697,1079,1)
(124,7737,1)
(7622,197,1)
(8103,5544,1)
(8215,7079,1)
(7074,2505,1)
(1418,4491,1)
(1667,8826,1)
(2761,7080,1)
(8038,1405,1)
(116,3444,1)
(5593,6649,1)
(1188,1557,1)
(6902,4205,1)
(4626,5588,1)
(1908,6290,1)
(2751,8822,1)
(8296,9059,1)
(5525,3222,1)
(7938,2778,1)
(892,9096,1)
(2421,34,1)
(711,5193,1)
(1612,8391,1)
(6098,5284,1)
(3509,3565,1)
(793,2230,1)
(15,5150,1)
(5568,4684,1)
(8543,637,1)
(6740,6225,1)
(6420,131,1)
(1794,3275,1)
(2745,4714,1)
(1241,115,1)
(1720,2409,1)
(5830,6197,1)
(6081,7301,1)
(6067,1277,1)
(7930,4834,1)
(8110,9104,1)
(4973,733,1)
(1784,8706,1)
(3539,115,1)
(7810,8391,1)
(7853,3959,1)
(2519,6046,1)
(8552,8677,1)
(5795,8391,1)
(5268,3065,1)
(2707,6750,1)
(387,8355,1)
(3510,2512,1)
(5901,1037,1)
(1725,5670,1)
(3810,8020,1)
(7483,6492,1)
(4648,5054,1)
(1301,7729,1)
(4080,4346,1)
(1762,6103,1)
(1249,6849,1)
(7051,2390,1)
(6644,7486,1)
(7815,8158,1)
(2287,2681,1)
(5314,3792,1)
(5132,7862,1)
(6101,6462,1)
(5239,7735,1)
(3804,4587,1)
(243,295,1)
(6554,5576,1)
(2240,5499,1)
(3165,4746,1)
(6916,2190,1)
(4413,5156,1)
(5172,115,1)
(7626,4149,1)
(961,3760,1)
(6576,115,1)
(3879,8391,1)
(795,8391,1)
(4383,3876,1)
(5222,4787,1)
(6380,1971,1)
(8038,3565,1)
(5088,9041,1)
(4872,8085,1)
(7354,2258,1)
(1830,6730,1)
(5458,6866,1)
(3802,1134,1)
(6534,3493,1)
(7133,3691,1)
(8862,594,1)
(4337,115,1)
(8774,8265,1)
(371,1149,1)
(4952,5855,1)
(2120,6877,1)
(3860,8391,1)
(2230,1827,1)
(6555,8391,1)
(6889,1866,1)
(3720,7822,1)
(883,3260,1)
(4864,8391,1)
(643,1703,1)
(272,6150,1)
(7160,2823,1)
(1228,739,1)
(5792,3229,1)
(6199,962,1)
(7031,115,1)
(3828,3049,1)
(2775,115,1)
(6462,7922,1)
(953,2170,1)
(6910,2830,1)
(4606,2667,1)
(5083,4915,1)
(5571,4470,1)
(228,4032,1)
(8752,4385,1)
(1238,3394,1)
(6064,7079,1)
(6790,2699,1)
(4620,8286,1)
(390,2221,1)
(1415,3565,1)
(3965,6899,1)
(67,6643,1)
(2353,914,1)
(5774,4231,1)
(7798,5840,1)
(1955,115,1)
(848,1094,1)
(6403,8456,1)
(6079,7403,1)
(8156,7685,1)
(4488,1264,1)
(455,4901,1)
(2777,6577,1)
(4810,3657,1)
(8211,1670,1)
(6870,3284,1)
(8377,4758,1)
(353,8391,1)
(5626,1908,1)
(2398,2499,1)
(2504,1890,1)
(7063,3816,1)
(8452,77,1)
(2936,7602,1)
(3534,2845,1)
(3626,8827,1)
(1286,1101,1)
(2287,4587,1)
(6577,5947,1)
(4624,8891,1)
(8907,8499,1)
(2394,604,1)
(8252,6986,1)
(1039,5054,1)
(214,2988,1)
(1956,4749,1)
(3382,6132,1)
(3820,3456,1)
(8774,7630,1)
(4818,8862,1)
(4000,6340,1)
(2522,115,1)
(1907,6157,1)
(2630,61,1)
(1899,3778,1)
(2,4549,1)
(5939,3320,1)
(4095,6880,1)
(7388,5984,1)
(8392,7834,1)
(2053,4956,1)
(1217,3183,1)
(7138,6500,1)
(5486,115,1)
(2986,6739,1)
(8493,2002,1)
(7980,3621,1)
(5270,716,1)
(1837,1135,1)
(7697,8876,1)
(3856,4543,1)
(6362,171,1)
(8142,7888,1)
(6621,8326,1)
(6442,3414,1)
(4403,6485,1)
(6513,2845,1)
(9039,1774,1)
(5275,4153,1)
(6183,6002,1)
(6955,1632,1)
(7664,4876,1)
(485,8768,1)
(9012,8341,1)
(8454,1769,1)
(7107,8391,1)
(3849,115,1)
(6393,7716,1)
(4818,2433,1)
(3844,115,1)
(7128,5752,1)
(2283,4783,1)
(5109,3451,1)
(5690,7679,1)
(7396,8349,1)
(2681,7123,1)
(3749,414,1)
(138,4465,1)
(9055,5288,1)
(1295,6837,1)
(8249,8391,1)
(7524,1408,1)
(6167,5717,1)
(1279,7669,1)
(5894,237,1)
(473,2013,1)
(8898,4318,1)
(8057,8391,1)
(4275,5127,1)
(4765,1720,1)
(8212,552,1)
(4232,115,1)
(1583,5690,1)
(879,1158,1)
(4423,6121,1)
(1447,4713,1)
(7338,2626,1)
(7626,1270,1)
(8700,1893,1)
(4853,7920,1)
(542,8820,1)
(4183,4995,1)
(3713,115,1)
(346,4935,1)
(3835,4858,1)
(4610,4344,1)
(170,115,1)
(4661,7870,1)
(2113,609,1)
(7397,8953,1)
(8881,8241,1)
(7500,1341,1)
(6648,5778,1)
(1415,7114,1)
(7385,2137,1)
(5078,8879,1)
(5577,115,1)
(7883,8152,1)
(5576,5507,1)
(3810,6957,1)
(1380,907,1)
(2330,3339,1)
(2198,4191,1)
(5836,8241,1)
(6057,115,1)
(5104,7954,1)
(2358,6317,1)
(2287,8021,1)
(1436,375,1)
(3509,8458,1)
(3001,7288,1)
(9140,7316,1)
(4185,4817,1)
(360,5140,1)
(3595,3982,1)
(1374,3363,1)
(780,1529,1)
(3730,2889,1)
(7969,1772,1)
(4645,254,1)
(6089,4621,1)
(692,597,1)
(4027,5939,1)
(5726,8612,1)
(4343,4064,1)
(4253,5961,1)
(6840,1027,1)
(235,2858,1)
(6023,5340,1)
(5811,4876,1)
(1475,5814,1)
(5098,3430,1)
(857,7074,1)
(3960,1847,1)
(1653,2679,1)
(5813,979,1)
(4905,7961,1)
(9038,8391,1)
(2598,7515,1)
(1047,5590,1)
(3830,1816,1)
(3999,3141,1)
(1215,8067,1)
(4568,132,1)
(6773,7177,1)
(2859,6550,1)
(7067,8391,1)
(2295,80,1)
(8036,91,1)
(4966,9110,1)
(6546,5791,1)
(1415,5057,1)
(1145,1047,1)
(1624,6376,1)
(2168,1149,1)
(7130,7692,1)
(2442,5540,1)
(3729,2868,1)
(3095,2941,1)
(4510,1411,1)
(3266,2237,1)
(6502,2543,1)
(5884,529,1)
(1403,2116,1)
(4140,7899,1)
(5627,6293,1)
(1911,1054,1)
(7759,8391,1)
(1778,6231,1)
(2254,8628,1)
(3834,7631,1)
(5552,689,1)
(8799,4,1)
(1844,6695,1)
(5256,2043,1)
(4308,4157,1)
(716,3772,1)
(8588,3910,1)
(3347,115,1)
(4781,5197,1)
(4243,3053,1)
(8372,2424,1)
(3169,1937,1)
(9044,5906,1)
(2099,8788,1)
(5477,115,1)
(8777,4424,1)
(5037,1488,1)
(9017,1015,1)
(4072,4103,1)
(3347,8391,1)
(3332,6563,1)
(4319,8391,1)
(7103,2440,1)
(3689,5093,1)
(1210,115,1)
(7177,1078,1)
(1749,3312,1)
(5527,2191,1)
(2544,6968,1)
(4929,371,1)
(3722,3735,1)
(4690,268,1)
(4547,1319,1)
(8268,7313,1)
(5126,4086,1)
(7265,8987,1)
(1740,2430,1)
(93,8387,1)
(3193,2583,1)
(5859,8377,1)
(7959,8391,1)
(8573,4104,1)
(6615,2181,1)
(8854,3579,1)
(6850,250,1)
(3589,7883,1)
(4631,5859,1)
(6884,115,1)
(1840,6279,1)
(8581,7874,1)
(4850,8602,1)
(4375,4705,1)
(197,8391,1)
(7371,2428,1)
(8748,1660,1)
(6764,3360,1)
(7626,3215,1)
(783,4472,1)
(4899,1437,1)
(2143,5976,1)
(2295,1013,1)
(4980,7305,1)
(3804,489,1)
(4969,5248,1)
(7599,6952,1)
(6082,8041,1)
(2709,8934,1)
(3925,2131,1)
(8836,1326,1)
(1392,115,1)
(3135,3672,1)
(6319,3831,1)
(4814,7711,1)
(7224,115,1)
(5746,2979,1)
(7443,2187,1)
(4088,4367,1)
(6879,59,1)
(6627,8391,1)
(6098,4362,1)
(5643,2738,1)
(4802,896,1)
(2037,6154,1)
(704,4575,1)
(4026,5651,1)
(2729,4615,1)
(7520,4214,1)
(5817,1488,1)
(3090,1488,1)
(8294,5238,1)
(7359,1029,1)
(4650,3451,1)
(6296,46,1)
(3095,5445,1)
(2611,8747,1)
(8714,7004,1)
(6880,4057,1)
(5417,7338,1)
(6087,4733,1)
(8348,1595,1)
(2338,8043,1)
(1164,8702,1)
(8510,4876,1)
(7938,123,1)
(754,1357,1)
(3898,4498,1)
(7775,1536,1)
(267,3215,1)
(4475,1567,1)
(4294,8711,1)
(2961,1573,1)
(2213,6044,1)
(4554,7379,1)
(19,3291,1)
(1017,6577,1)
(4982,115,1)
(8986,6785,1)
(7237,1490,1)
(1763,2920,1)
(6333,5489,1)
(382,6568,1)
(811,16,1)
(3157,6699,1)
(5757,5104,1)
(6561,7651,1)
(2211,1877,1)
(2099,3451,1)
(1662,1192,1)
(5459,8756,1)
(7224,8391,1)
(3501,8209,1)
(2569,4343,1)
(1158,4694,1)
(1280,9099,1)
(1414,846,1)
(5314,4594,1)
(8085,972,1)
(2965,2556,1)
(6284,3215,1)
(4212,7492,1)
(7135,3112,1)
(2526,8288,1)
(23,8523,1)
(7224,5334,1)
(2968,887,1)
(8009,1,1)
(1415,7039,1)
(1529,3572,1)
(1614,5120,1)
(780,115,1)
(1202,2438,1)
(7739,8248,1)
(6700,4263,1)
(3451,8322,1)
(6964,4118,1)
(2162,115,1)
(1488,6868,1)
(4848,6995,1)
(3556,3159,1)
(6959,8996,1)
(7399,5928,1)
(3860,115,1)
(2807,3447,1)
(1123,183,1)
(1132,4090,1)
(3456,8337,1)
(2409,6446,1)
(701,2003,1)
(8514,6477,1)
(3154,3079,1)
(1176,4369,1)
(8800,7829,1)
(5665,6458,1)
(7212,8429,1)
(468,9060,1)
(7980,7699,1)
(8668,7143,1)
(336,7895,1)
(2174,4162,1)
(5228,8306,1)
(1635,2754,1)
(6419,3889,1)
(408,8247,1)
(886,8975,1)
(2730,4968,1)
(5661,2471,1)
(1039,7532,1)
(2462,848,1)
(7357,115,1)
(8388,5433,1)
(6257,6867,1)
(3403,1892,1)
(1163,2993,1)
(8622,5820,1)
(6048,8695,1)
(2544,6649,1)
(651,2358,1)
(3417,7160,1)
(2940,8391,1)
(9110,6675,1)
(3100,1488,1)
(6379,3182,1)
(158,5674,1)
(312,7858,1)
(4040,798,1)
(3288,115,1)
(6121,2048,1)
(2287,6356,1)
(3138,115,1)
(8638,3551,1)
(3067,115,1)
(4195,4360,1)
(3339,3596,1)
(7847,4428,1)
(6630,3871,1)
(4388,7724,1)
(3430,8177,1)
(6430,6465,1)
(3307,6969,1)
(3487,1227,1)
(8048,965,1)
(5692,8570,1)
(2898,189,1)
(8917,6068,1)
(6278,4522,1)
(5708,8989,1)
(8702,5243,1)
(7626,8458,1)
(465,8791,1)
(6059,7655,1)
(3287,1480,1)
(2298,6258,1)
(780,8391,1)
(1853,115,1)
(2383,2290,1)
(2752,2900,1)
(8105,8391,1)
(8764,5691,1)
(8067,4161,1)
(3436,2171,1)
(6241,1212,1)
(8158,6397,1)
(9103,7820,1)
(5811,4380,1)
(4594,8558,1)
(7988,5207,1)
(1501,5900,1)
(6313,2148,1)
(1415,8458,1)
(5485,8838,1)
(4620,8986,1)
(5954,1923,1)
(7532,3451,1)
(212,8391,1)
(4070,115,1)
(8335,5327,1)
(5433,6533,1)
(2581,2463,1)
(4360,5446,1)
(6167,8433,1)
(3708,8418,1)
(3721,6589,1)
(5871,6782,1)
(1255,5078,1)
(4946,7821,1)
(1927,8752,1)
(4924,1922,1)
(1407,2619,1)
(1396,1062,1)
(7991,1914,1)
(579,115,1)
(135,5902,1)
(5688,8074,1)
(4375,6471,1)
(7146,1223,1)
(3224,3545,1)
(499,274,1)
(8579,6995,1)
(2587,5349,1)
(8008,8391,1)
(3609,6416,1)
(1068,4045,1)
(2983,8702,1)
(9077,2161,1)
(2292,4079,1)
(3479,1048,1)
(5323,4824,1)
(1415,6968,1)
(7879,6034,1)
(5489,8391,1)
(6750,8391,1)
(5106,6073,1)
(5050,7003,1)
(4375,9138,1)
(8063,2417,1)
(331,5488,1)
(7897,48,1)
(8128,1468,1)
(8400,7875,1)
(399,7596,1)
(8684,1370,1)
(3062,8391,1)
(7411,4653,1)
(8047,8373,1)
(5089,3258,1)
(7912,8188,1)
(6258,6438,1)
(1987,8560,1)
(4711,8391,1)
(1085,115,1)
(7412,4393,1)
(3755,3058,1)
(3554,3600,1)
(5951,5523,1)
(7183,2955,1)
(2339,743,1)
(7831,6641,1)
(691,5420,1)
(7516,115,1)
(7658,1940,1)
(1384,34,1)
(2170,8756,1)
(3297,3826,1)
(5347,2159,1)
(8333,2341,1)
(2688,2845,1)
(8017,5929,1)
(5172,8391,1)
(3458,7890,1)
(3552,1992,1)
(662,6831,1)
(92,2488,1)
(2254,807,1)
(6452,994,1)
(3684,1849,1)
(8783,5061,1)
(2227,4115,1)
(8080,6863,1)
(3913,6995,1)
(3807,115,1)
(7299,4028,1)
(1011,7232,1)
(3276,4916,1)
(8245,8685,1)
(413,8391,1)
(6536,7040,1)
(8936,2321,1)
(6668,7713,1)
(1474,2112,1)
(7501,8277,1)
(5154,1467,1)
(4758,2845,1)
(430,6077,1)
(1111,115,1)
(4560,8960,1)
(700,5106,1)
(7910,8391,1)
(4135,9087,1)
(2511,1279,1)
(3710,1155,1)
(2553,331,1)
(1657,8061,1)
(1329,7974,1)
(2365,5021,1)
(6196,6150,1)
(8034,4876,1)
(7342,2765,1)
(9072,8739,1)
(8837,115,1)
(4690,9068,1)
(6750,115,1)
(6849,7078,1)
(6261,6995,1)
(7328,3849,1)
(4918,5649,1)
(2317,2845,1)
(1206,4381,1)
(6318,6553,1)
(5168,8517,1)
(2978,115,1)
(8319,8230,1)
(1220,1013,1)
(1668,8518,1)
(6004,2853,1)
(3407,2933,1)
(4614,7239,1)
(8674,657,1)
(1212,1149,1)
(3020,5883,1)
(8776,7442,1)
(9027,359,1)
(107,2313,1)
(1156,535,1)
(6905,3197,1)
(190,3618,1)
(3586,8311,1)
(962,6450,1)
(4130,2095,1)
(518,3708,1)
(1789,1469,1)
(7057,8391,1)
(8633,4269,1)
(3065,4342,1)
(2506,115,1)
(7571,8391,1)
(1415,7757,1)
(283,8492,1)
(8295,2494,1)
(7114,1726,1)
(2852,4145,1)
(5322,7866,1)
(1746,6083,1)
(8466,1861,1)
(8794,7013,1)
(1203,5829,1)
(6855,8510,1)
(7930,0,1)
(102,559,1)
(4365,1705,1)
(5851,3865,1)
(7862,3328,1)
(3051,5825,1)
(8154,8427,1)
(1217,4876,1)
(7005,4218,1)
(2467,8391,1)
(3810,5151,1)
(2217,6486,1)
(2873,8391,1)
(3369,4570,1)
(4054,4634,1)
(4156,7266,1)
(2606,4357,1)
(6147,7835,1)
(5214,8471,1)
(3266,5548,1)
(5921,517,1)
(2476,902,1)
(7003,5532,1)
(7877,1220,1)
(3094,8972,1)
(3355,7665,1)
(2498,8403,1)
(3060,4726,1)
(300,7793,1)
(7984,4459,1)
(9124,8391,1)
(7566,8391,1)
(4184,5465,1)
(545,8465,1)
(5851,6187,1)
(5123,5721,1)
(3648,4128,1)
(4840,576,1)
(1954,6575,1)
(5044,134,1)
(4498,3306,1)
(2340,4125,1)
(8533,5854,1)
(7457,9055,1)
(412,5276,1)
(8408,2588,1)
(8664,115,1)
(3736,8020,1)
(8602,1345,1)
(4535,5500,1)
(4449,5024,1)
(1701,2480,1)
(4521,8328,1)
(4079,161,1)
(4575,6117,1)
(4697,6961,1)
(1070,164,1)
(7428,7029,1)
(1415,3461,1)
(1631,6010,1)
(2103,6664,1)
(7593,285,1)
(4028,2675,1)
(3652,1039,1)
(2971,4598,1)
(2369,4698,1)
(3569,5917,1)
(8713,677,1)
(3297,1350,1)
(2350,3621,1)
(4781,4876,1)
(9124,7711,1)
(3433,6380,1)
(6339,9064,1)
(3536,3567,1)
(1627,8756,1)
(279,1484,1)
(8058,2847,1)
(2507,7792,1)
(3509,7039,1)
(5900,3480,1)
(6666,115,1)
(1619,3521,1)
(6064,4340,1)
(1026,3172,1)
(4001,115,1)
(6628,236,1)
(3570,4267,1)
(4621,4296,1)
(6336,1389,1)
(6723,115,1)
(1480,7774,1)
(19,4624,1)
(7108,2402,1)
(4144,1038,1)
(5394,317,1)
(2385,3698,1)
(7548,2775,1)
(7966,4587,1)
(771,1149,1)
(5753,7175,1)
(5583,115,1)
(2342,1134,1)
(6177,978,1)
(441,2267,1)
(759,1026,1)
(1010,5038,1)
(7850,7454,1)
(497,4301,1)
(6698,3947,1)
(6741,5829,1)
(2869,4949,1)
(6875,115,1)
(3214,4181,1)
(5239,8194,1)
(7306,8391,1)
(2410,8391,1)
(7492,5925,1)
(7468,6482,1)
(3625,115,1)
(2091,2435,1)
(7502,8660,1)
(2003,8532,1)
(2066,4853,1)
(320,4869,1)
(4175,1347,1)
(1497,4827,1)
(6600,5236,1)
(4534,6648,1)
(1213,115,1)
(7244,2113,1)
(7207,851,1)
(7445,1393,1)
(696,2805,1)
(5476,3957,1)
(6726,7216,1)
(1299,565,1)
(568,2028,1)
(6521,1152,1)
(6467,1921,1)
(2704,3128,1)
(4873,3565,1)
(1260,452,1)
(6694,2423,1)
(5494,7039,1)
(7453,8192,1)
(1311,9112,1)
(45,115,1)
(1286,1857,1)
(4624,5582,1)
(101,115,1)
(8734,7957,1)
(680,1518,1)
(3795,5204,1)
(787,2885,1)
(6336,5706,1)
(9110,2929,1)
(4837,6944,1)
(6354,3389,1)
(7034,5584,1)
(6120,5864,1)
(5850,847,1)
(1729,8391,1)
(26,450,1)
(3769,9119,1)
(5610,5840,1)
(3704,3242,1)
(7915,8914,1)
(3270,8808,1)
(5586,5173,1)
(5462,6714,1)
(1349,8391,1)
(4368,5739,1)
(5831,4840,1)
(3657,7523,1)
(3345,4669,1)
(3272,1336,1)
(4732,1771,1)
(8208,8905,1)
(7244,1773,1)
(4883,933,1)
(6999,5543,1)
(8937,7709,1)
(3804,8458,1)
(235,5961,1)
(9106,2845,1)
(8681,3378,1)
(7709,3508,1)
(3918,3823,1)
(4029,2845,1)
(4628,3106,1)
(9141,7938,1)
(5735,7617,1)
(4676,1687,1)
(579,2845,1)
(5510,6321,1)
(804,7169,1)
(5268,4342,1)
(2571,4557,1)
(2407,1760,1)
(1370,2642,1)
(2214,2172,1)
(3149,8391,1)
(572,115,1)
(561,2596,1)
(4702,2628,1)
(2010,1206,1)
(7039,5357,1)
(8349,3286,1)
(7244,2916,1)
(1851,1875,1)
(6469,5644,1)
(8471,8926,1)
(2046,8090,1)
(5897,2166,1)
(4986,8771,1)
(4815,7109,1)
(8610,115,1)
(5489,2291,1)
(1819,6667,1)
(3879,5035,1)
(3854,6055,1)
(4801,7864,1)
(1401,3285,1)
(2656,1951,1)
(2733,2445,1)
(921,115,1)
(7244,1864,1)
(7713,8417,1)
(5494,8471,1)
(3351,2747,1)
(5262,4978,1)
(4205,2001,1)
(7173,8238,1)
(1065,6330,1)
(2501,1780,1)
(519,2164,1)
(6179,6097,1)
(8462,5706,1)
(893,418,1)
(7244,3410,1)
(3312,4912,1)
(1073,6094,1)
(3660,2404,1)
(4510,2116,1)
(2781,830,1)
(5243,5380,1)
(7080,4965,1)
(5199,7407,1)
(1509,8260,1)
(4422,8396,1)
(7109,1525,1)
(8690,7519,1)
(7723,997,1)
(89,6577,1)
(423,7436,1)
(7798,4876,1)
(835,1643,1)
(926,7131,1)
(2364,4751,1)
(1038,1931,1)
(362,6311,1)
(7323,3024,1)
(3352,8535,1)
(4646,8544,1)
(6616,8055,1)
(8753,840,1)
(1972,6431,1)
(7969,8391,1)
(1236,2689,1)
(8482,4844,1)
(1924,9123,1)
(8093,4114,1)
(9090,1552,1)
(7244,1506,1)
(8850,2053,1)
(6360,3451,1)
(1714,8461,1)
(288,2483,1)
(4260,4704,1)
(5638,4149,1)
(8379,4876,1)
(7191,115,1)
(6804,6142,1)
(1273,115,1)
(1873,4997,1)
(6588,3253,1)
(7527,8940,1)
(1335,5292,1)
(3331,8024,1)
(3180,4219,1)
(1923,920,1)
(5213,3406,1)
(6481,1201,1)
(6502,8614,1)
(4839,6315,1)
(308,4922,1)
(8966,5453,1)
(7966,2112,1)
(152,8234,1)
(6703,115,1)
(1341,3096,1)
(8802,8391,1)
(7033,2446,1)
(3877,232,1)
(5593,2112,1)
(2054,5328,1)
(8591,5361,1)
(724,1753,1)
(8550,115,1)
(2937,3681,1)
(514,115,1)
(7223,425,1)
(604,5179,1)
(8864,129,1)
(8339,5234,1)
(3883,666,1)
(1251,3499,1)
(8666,115,1)
(8702,4876,1)
(3952,599,1)
(1415,4149,1)
(6064,2896,1)
(8862,4553,1)
(1879,4287,1)
(1788,6224,1)
(4936,2445,1)
(644,115,1)
(7751,5203,1)
(5498,8697,1)
(2367,2756,1)
(1349,5609,1)
(1103,115,1)
(1261,2827,1)
(4494,5969,1)
(868,6753,1)
(8984,4979,1)
(4072,8391,1)
(2491,6613,1)
(2882,7304,1)
(741,4445,1)
(6063,9120,1)
(3804,6921,1)
(405,3178,1)
(6136,7210,1)
(1693,5123,1)
(4386,3597,1)
(1103,8391,1)
(3850,2476,1)
(7176,7356,1)
(2806,5239,1)
(216,7528,1)
(820,734,1)
(3530,3161,1)
(7269,5153,1)
(2841,2017,1)
(7890,932,1)
(2382,1205,1)
(7910,5222,1)
(2640,8391,1)
(4315,7787,1)
(101,4973,1)
(6413,7620,1)
(59,1313,1)
(3053,6694,1)
(8038,3880,1)
(7450,7370,1)
(4878,6595,1)
(9007,2155,1)
(3961,3404,1)
(7249,1854,1)
(1766,8391,1)
(8249,7711,1)
(7009,2671,1)
(7380,6624,1)
(3120,3856,1)
(5851,5331,1)
(6510,8858,1)
(978,1104,1)
(1737,4852,1)
(7472,5449,1)
(6630,3679,1)
(8909,115,1)
(20,7088,1)
(7132,6412,1)
(3924,2520,1)
(1555,8391,1)
(2793,2837,1)
(8386,2301,1)
(3815,8561,1)
(6818,8756,1)
(8146,8615,1)
(1122,8391,1)
(7812,3875,1)
(3722,4840,1)
(4385,8591,1)
(4635,3626,1)
(4873,8458,1)
(9077,8461,1)
(2110,7535,1)
(1415,4449,1)
(7401,7643,1)
(3596,5829,1)
(8595,1328,1)
(5638,700,1)
(8295,2845,1)
(8014,1149,1)
(4717,3814,1)
(3175,115,1)
(1515,8203,1)
(5909,3612,1)
(9004,2431,1)
(4375,3889,1)
(2705,3660,1)
(2916,2582,1)
(3592,3568,1)
(8792,429,1)
(1272,2450,1)
(6865,115,1)
(7053,2336,1)
(6028,2246,1)
(8043,391,1)
(6090,8753,1)
(71,8756,1)
(4457,335,1)
(8488,3008,1)
(7251,115,1)
(8222,6404,1)
(7287,5822,1)
(1440,6631,1)
(4067,3235,1)
(5003,1786,1)
(590,8308,1)
(4161,1891,1)
(1675,115,1)
(7601,2241,1)
(5093,3123,1)
(3910,1424,1)
(2938,115,1)
(7244,5780,1)
(875,1433,1)
(4387,4988,1)
(1017,2740,1)
(4847,8391,1)
(8819,7433,1)
(6341,8391,1)
(1415,4587,1)
(7669,4680,1)
(3865,3350,1)
(6603,115,1)
(2685,4616,1)
(7966,8111,1)
(5011,8353,1)
(8319,2140,1)
(912,5251,1)
(7852,4036,1)
(120,5526,1)
(5638,4350,1)
(2184,4832,1)
(1154,6059,1)
(3199,6403,1)
(1641,3103,1)
(3130,8391,1)
(4044,5689,1)
(4434,4530,1)
(6851,6150,1)
(63,4177,1)
(8228,8756,1)
(3687,7947,1)
(2377,1189,1)
(5244,3673,1)
(5929,8687,1)
(5143,7817,1)
(837,1235,1)
(1415,1270,1)
(5115,5275,1)
(1415,7950,1)
(5843,6442,1)
(3450,2737,1)
(7712,2464,1)
(8505,1605,1)
(6982,2416,1)
(7193,4104,1)
(8309,7769,1)
(2544,3889,1)
(8488,3513,1)
(1758,2157,1)
(5003,54,1)
(7891,5107,1)
(5739,1432,1)
(3627,30,1)
(6579,3361,1)
(6947,3659,1)
(4889,1272,1)
(3384,8056,1)
(3937,7614,1)
(858,503,1)
(5163,222,1)
(2341,127,1)
(2099,2309,1)
(2203,5829,1)
(4270,2115,1)
(2457,8490,1)
(8666,831,1)
(8465,123,1)
(8237,8391,1)
(798,596,1)
(8043,6216,1)
(1044,115,1)
(5051,3090,1)
(3482,1828,1)
(2579,866,1)
(155,8391,1)
(8441,6989,1)
(6014,4095,1)
(8215,2870,1)
(5971,2542,1)
(8571,6576,1)
(4326,205,1)
(6454,7711,1)
(4681,4563,1)
(895,5338,1)
(6401,1647,1)
(6430,115,1)
(6397,115,1)
(7164,1320,1)
(4133,476,1)
(8422,3644,1)
(1413,8342,1)
(8113,5687,1)
(7407,8695,1)
(1481,1801,1)
(6871,6633,1)
(2861,5943,1)
(1755,8391,1)
(181,674,1)
(4093,3521,1)
(2301,713,1)
(2122,1162,1)
(2946,7008,1)
(5834,4987,1)
(601,7939,1)
(7688,4003,1)
(3616,1662,1)
(4753,5166,1)
(2901,1540,1)
(2523,973,1)
(679,144,1)
(7597,7145,1)
(7165,2631,1)
(3103,409,1)
(7728,4464,1)
(1109,1229,1)
(4485,8025,1)
(5802,4193,1)
(379,8627,1)
(1266,2043,1)
(5104,2460,1)
(414,2627,1)
(2771,3274,1)
(317,843,1)
(7324,2302,1)
(5887,3950,1)
(731,5184,1)
(1412,203,1)
(1385,3832,1)
(4284,6995,1)
(640,4170,1)
(4375,7039,1)
(6582,530,1)
(7036,6505,1)
(4394,6974,1)
(2011,8278,1)
(4881,7226,1)
(8840,1281,1)
(3804,6649,1)
(8666,8391,1)
(5638,4515,1)
(3162,1372,1)
(2475,2845,1)
(4673,4488,1)
(2953,4023,1)
(3156,3935,1)
(2141,2124,1)
(1270,3362,1)
(4742,5156,1)
(5558,1405,1)
(9054,289,1)
(7287,8391,1)
(1967,602,1)
(2897,6805,1)
(4513,2796,1)
(1082,1659,1)
(6226,3356,1)
(6952,6547,1)
(2644,6907,1)
(2172,7995,1)
(2926,3317,1)
(3277,695,1)
(6333,6788,1)
(5058,6002,1)
(2314,7869,1)
(2048,1813,1)
(2004,1304,1)
(5173,4619,1)
(7047,5710,1)
(6475,938,1)
(6757,2326,1)
(2297,8391,1)
(7384,7742,1)
(8198,371,1)
(3897,1861,1)
(6190,115,1)
(8739,4985,1)
(8957,641,1)
(2522,2082,1)
(1085,3392,1)
(6715,115,1)
(1273,8391,1)
(4693,2220,1)
(4350,8332,1)
(676,2665,1)
(8629,6417,1)
(3336,9052,1)
(3239,7140,1)
(7949,4065,1)
(6744,7484,1)
(5985,2207,1)
(7003,4734,1)
(7910,115,1)
(2518,1366,1)
(4708,483,1)
(7168,381,1)
(1468,4943,1)
(4679,4861,1)
(1377,3021,1)
(3108,5414,1)
(6284,9130,1)
(741,7746,1)
(4232,8391,1)
(2726,4695,1)
(8834,4433,1)
(2458,2726,1)
(8601,4417,1)
(1237,901,1)
(4845,8756,1)
(477,6792,1)
(3798,6046,1)
(3868,842,1)
(3863,8567,1)
(7857,8089,1)
(7959,115,1)
(9076,6827,1)
(7671,6493,1)
(369,6237,1)
(5214,2112,1)
(8278,3316,1)
(4108,2758,1)
(1354,6085,1)
(7797,7104,1)
(9082,5213,1)
(2391,4605,1)
(5330,8005,1)
(428,515,1)
(5004,5363,1)
(1530,5964,1)
(1647,8386,1)
(4270,5156,1)
(3621,8458,1)
(4020,918,1)
(7105,1675,1)
(8189,4473,1)
(8980,4619,1)
(2524,94,1)
(4767,8099,1)
(1242,8646,1)
(2287,7140,1)
(7114,1153,1)
(2115,4489,1)
(7195,7493,1)
(4073,6808,1)
(7460,4658,1)
(2401,324,1)
(66,4861,1)
(8217,1198,1)
(2040,8368,1)
(3387,3513,1)
(205,7156,1)
(5318,2854,1)
(1304,2110,1)
(9105,8454,1)
(34,5870,1)
(7963,7824,1)
(8021,8391,1)
(5602,8439,1)
(2492,862,1)
(6910,3122,1)
(8559,1282,1)
(2147,5561,1)
(5278,4172,1)
(7437,4899,1)
(6594,8391,1)
(3804,929,1)
(6286,2248,1)
(6795,2845,1)
(3770,5629,1)
(4375,8111,1)
(197,115,1)
(9026,8422,1)
(3302,5190,1)
(5324,6772,1)
(548,8830,1)
(1793,1789,1)
(1914,5746,1)
(3177,4183,1)
(3128,7398,1)
(4551,5777,1)
(2071,9103,1)
(4829,6399,1)
(2287,1405,1)
(2597,6167,1)
(4042,8209,1)
(2217,8391,1)
(8327,7517,1)
(3300,699,1)
(9046,4974,1)
(8340,2595,1)
(6325,115,1)
(3324,3767,1)
(8457,2467,1)
(7760,6908,1)
(7429,8902,1)
(4843,6695,1)
(2454,9103,1)
(6612,320,1)
(2593,4349,1)
(3250,3033,1)
(836,1968,1)
(2356,6314,1)
(7591,8542,1)
(6899,8633,1)
(2814,8391,1)
(6515,7904,1)
(6397,1355,1)
(7380,7891,1)
(172,7543,1)
(392,3840,1)
(7218,7127,1)
(2243,7711,1)
(2219,1492,1)
(8678,5358,1)
(7821,6289,1)
(4121,322,1)
(3839,3244,1)
(7006,6148,1)
(4002,8391,1)
(1273,3144,1)
(6295,7779,1)
(1933,3889,1)
(7971,4805,1)
(5828,1478,1)
(4650,2309,1)
(6474,6729,1)
(7856,7714,1)
(1012,3336,1)
(5597,5032,1)
(8387,1063,1)
(5573,8636,1)
(400,4545,1)
(6880,5462,1)
(2890,6658,1)
(9057,4344,1)
(4363,1541,1)
(153,6371,1)
(7253,5002,1)
(1645,7005,1)
(901,4008,1)
(4483,1322,1)
(8163,776,1)
(6211,2493,1)
(4571,5971,1)
(1815,7940,1)
(6419,1270,1)
(3936,3573,1)
(483,8814,1)
(3714,6391,1)
(3804,7039,1)
(6872,5556,1)
(1363,5781,1)
(1768,8432,1)
(1121,109,1)
(3469,15,1)
(8047,3289,1)
(2625,5982,1)
(868,7865,1)
(6085,2753,1)
(5159,3327,1)
(737,845,1)
(8419,2845,1)
(5500,4046,1)
(7291,1106,1)
(4382,6072,1)
(5214,7039,1)
(1309,8045,1)
(4244,789,1)
(2313,6801,1)
(7887,2807,1)
(3182,352,1)
(5189,3103,1)
(270,7672,1)
(6445,500,1)
(8246,6826,1)
(7363,838,1)
(5593,3565,1)
(5809,8111,1)
(3810,7468,1)
(4744,833,1)
(1209,7996,1)
(7125,726,1)
(7562,5133,1)
(1578,3668,1)
(226,7223,1)
(591,2184,1)
(1415,3901,1)
(774,3533,1)
(442,8916,1)
(280,9076,1)
(6164,1561,1)
(3928,2644,1)
(2132,4685,1)
(8214,6137,1)
(8979,8291,1)
(7806,8794,1)
(7441,5752,1)
(8662,7888,1)
(1054,8391,1)
(1220,8314,1)
(1416,1401,1)
(2504,365,1)
(163,5156,1)
(6103,115,1)
(1648,8577,1)
(4330,5424,1)
(8247,5927,1)
(3837,1750,1)
(5765,2964,1)
(8142,7779,1)
(5517,8361,1)
(3927,5326,1)
(6491,5514,1)
(6994,9096,1)
(2591,2845,1)
(718,2243,1)
(6764,2277,1)
(4883,4015,1)
(8110,5829,1)
(2763,115,1)
(4938,6011,1)
(8042,4619,1)
(266,6469,1)
(5170,4851,1)
(121,3848,1)
(2660,3730,1)
(2596,922,1)
(8148,8619,1)
(2384,7723,1)
(3834,4750,1)
(3968,8897,1)
(634,2455,1)
(2388,3459,1)
(6774,8094,1)
(6252,6711,1)
(5851,3680,1)
(1611,8029,1)
(5990,1509,1)
(6713,8391,1)
(6574,1992,1)
(151,649,1)
(6888,115,1)
(1415,8160,1)
(2466,4499,1)
(5867,6620,1)
(2527,1461,1)
(6364,6095,1)
(3919,8870,1)
(5715,724,1)
(851,3747,1)
(8495,3616,1)
(1874,2705,1)
(220,5668,1)
(3768,2241,1)
(4410,5156,1)
(2077,8312,1)
(4515,8175,1)
(8531,113,1)
(1512,4014,1)
(945,8935,1)
(6111,115,1)
(7513,2943,1)
(3542,5779,1)
(2534,115,1)
(8133,624,1)
(4236,5989,1)
(3465,7496,1)
(6419,8111,1)
(315,1367,1)
(881,1559,1)
(6617,7405,1)
(2766,5648,1)
(1828,740,1)
(4718,8335,1)
(5335,2558,1)
(3483,4876,1)
(6789,5305,1)
(618,2706,1)
(4664,7092,1)
(2317,6770,1)
(4475,2464,1)
(6968,1852,1)
(4531,3787,1)
(7966,3565,1)
(6204,6305,1)
(3837,7711,1)
(801,7796,1)
(6033,269,1)
(4466,8391,1)
(6196,6719,1)
(345,7051,1)
(5307,5366,1)
(4607,6758,1)
(55,5806,1)
(2287,6563,1)
(3328,6312,1)
(4389,8391,1)
(8418,7203,1)
(3122,170,1)
(2540,540,1)
(5887,6742,1)
(8825,4346,1)
(7912,5829,1)
(2351,2925,1)
(8173,2867,1)
(5591,6903,1)
(5991,6897,1)
(2619,6804,1)
(7705,5470,1)
(8712,402,1)
(4650,3875,1)
(4375,2681,1)
(5214,4515,1)
(7044,3331,1)
(1976,3005,1)
(7730,2052,1)
(8904,1211,1)
(1534,8595,1)
(84,585,1)
(64,7173,1)
(1527,1011,1)
(2099,6084,1)
(6895,51,1)
(5869,7721,1)
(3466,1488,1)
(1931,7482,1)
(5023,86,1)
(5223,1488,1)
(1435,2573,1)
(2866,8936,1)
(8320,8123,1)
(3032,6745,1)
(3735,8651,1)
(5767,3535,1)
(1792,8391,1)
(8922,4242,1)
(2559,7719,1)
(8838,115,1)
(4478,8429,1)
(5965,4439,1)
(9047,115,1)
(3189,2242,1)
(3143,7470,1)
(4082,5970,1)
(6322,8659,1)
(8732,8391,1)
(6520,646,1)
(1289,835,1)
(7695,8756,1)
(8142,4522,1)
(5820,3891,1)
(4277,4876,1)
(7791,6047,1)
(2096,3436,1)
(9038,5699,1)
(5353,2629,1)
(7883,115,1)
(633,1592,1)
(7366,8391,1)
(6613,552,1)
(1029,8391,1)
(4992,6794,1)
(2831,5897,1)
(7066,4814,1)
(8354,3421,1)
(4580,115,1)
(1783,2109,1)
(3773,7711,1)
(330,2507,1)
(3804,9130,1)
(8988,691,1)
(1287,4077,1)
(3741,5715,1)
(5655,5257,1)
(5408,2372,1)
(7287,2845,1)
(5506,3896,1)
(2760,7214,1)
(8590,5966,1)
(3916,553,1)
(6558,1366,1)
(4726,5435,1)
(3804,87,1)
(8618,115,1)
(952,3621,1)
(8512,1901,1)
(4901,159,1)
(2287,9130,1)
(1173,6577,1)
(4375,3657,1)
(7462,115,1)
(7693,2734,1)
(4426,8869,1)
(5275,3875,1)
(7793,3942,1)
(1820,1974,1)
(8909,8391,1)
(1134,7489,1)
(6248,742,1)
(5567,6223,1)
(3015,627,1)
(2608,3214,1)
(3496,8499,1)
(6709,4524,1)
(7617,8293,1)
(6016,5613,1)
(2264,6488,1)
(8557,6515,1)
(5329,1252,1)
(6530,4970,1)
(1616,522,1)
(7536,8391,1)
(8959,775,1)
(5684,8828,1)
(8558,1748,1)
(2080,7809,1)
(7775,115,1)
(3823,1298,1)
(2458,7210,1)
(2133,6666,1)
(1196,1151,1)
(1628,115,1)
(8063,7785,1)
(6502,5214,1)
(5961,2422,1)
(2921,6048,1)
(7811,8681,1)
(8038,2112,1)
(7244,9065,1)
(5223,6683,1)
(2563,7467,1)
(2850,7146,1)
(4605,2279,1)
(88,3847,1)
(298,4349,1)
(4644,4619,1)
(2562,8187,1)
(2544,7280,1)
(3727,7941,1)
(2299,7905,1)
(6247,652,1)
(3545,115,1)
(5456,6730,1)
(5193,8391,1)
(4790,7084,1)
(2072,8391,1)
(4506,2796,1)
(2783,7544,1)
(1344,6819,1)
(1020,3528,1)
(646,6520,1)
(2193,856,1)
(6776,8348,1)
(7989,2178,1)
(7244,6962,1)
(6581,380,1)
(8043,1497,1)
(335,3427,1)
(6035,4100,1)
(6650,5180,1)
(7924,3690,1)
(321,3246,1)
(7966,941,1)
(8273,1963,1)
(7870,7973,1)
(741,7079,1)
(4094,3518,1)
(3951,3966,1)
(3232,6123,1)
(3728,8042,1)
(1658,2265,1)
(3891,2520,1)
(7660,8391,1)
(2244,2814,1)
(3574,7302,1)
(6419,1158,1)
(3522,4848,1)
(3804,8021,1)
(7503,6227,1)
(8989,100,1)
(143,280,1)
(4410,4876,1)
(742,8033,1)
(6145,6381,1)
(1640,5041,1)
(4798,8391,1)
(9092,916,1)
(947,1077,1)
(4038,3203,1)
(5856,3128,1)
(2237,8391,1)
(2544,4587,1)
(9112,4802,1)
(6714,5310,1)
(2891,2152,1)
(3213,1158,1)
(824,7682,1)
(1550,373,1)
(1676,643,1)
(8365,325,1)
(7113,5122,1)
(2237,1734,1)
(4379,682,1)
(8625,5866,1)
(4848,7706,1)
(1822,1976,1)
(4942,7879,1)
(5214,3215,1)
(6429,1989,1)
(2657,8391,1)
(4598,6543,1)
(8797,4167,1)
(7055,5070,1)
(1785,7796,1)
(248,4060,1)
(7493,5633,1)
(7755,2707,1)
(8008,2845,1)
(8939,1572,1)
(8204,608,1)
(5415,4322,1)
(5883,7263,1)
(8311,115,1)
(7858,7516,1)
(437,8391,1)
(5638,1405,1)
(3303,3939,1)
(404,4616,1)
(7838,6979,1)
(250,6384,1)
(6686,115,1)
(6692,5477,1)
(8259,8391,1)
(1602,5031,1)
(1137,3566,1)
(2753,4285,1)
(2392,3895,1)
(2049,5220,1)
(4873,4587,1)
(2647,8391,1)
(6820,8165,1)
(981,3415,1)
(6007,2087,1)
(1349,115,1)
(3287,1891,1)
(6559,1149,1)
(8157,5410,1)
(8373,2539,1)
(7664,5156,1)
(5256,5829,1)
(8478,2805,1)
(7393,2421,1)
(903,115,1)
(2158,5391,1)
(8703,2245,1)
(5369,8391,1)
(4367,7470,1)
(5719,115,1)
(3149,3202,1)
(212,115,1)
(6922,1758,1)
(8177,464,1)
(1971,4587,1)
(4312,2668,1)
(6329,202,1)
(7589,2042,1)
(2253,2376,1)
(8957,7497,1)
(2267,900,1)
(8923,7293,1)
(5494,6474,1)
(6764,6867,1)
(7469,4845,1)
(196,4353,1)
(8757,2673,1)
(525,9085,1)
(6726,4876,1)
(6645,3682,1)
(3865,5961,1)
(6682,1737,1)
(2804,4116,1)
(4255,3812,1)
(3469,3493,1)
(121,115,1)
(9089,6008,1)
(2626,5242,1)
(292,6387,1)
(97,8304,1)
(519,7139,1)
(2434,4687,1)
(7962,5829,1)
(7933,2275,1)
(2181,6022,1)
(5453,7324,1)
(4805,1169,1)
(3819,1649,1)
(6348,7019,1)
(6171,1186,1)
(4982,6,1)
(2280,6982,1)
(2544,4149,1)
(1937,4050,1)
(4012,115,1)
(6021,8763,1)
(8289,1149,1)
(5877,2053,1)
(1128,5485,1)
(8176,3956,1)
(8873,1516,1)
(4967,2615,1)
(7892,8684,1)
(9127,6594,1)
(1075,2145,1)
(8341,2043,1)
(3828,115,1)
(5547,6230,1)
(4288,1770,1)
(5493,2370,1)
(6666,8391,1)
(8279,2571,1)
(7531,740,1)
(2544,7039,1)
(5214,6649,1)
(1320,6872,1)
(4102,784,1)
(1903,3587,1)
(5404,586,1)
(5153,7756,1)
(6690,4646,1)
(4641,3867,1)
(2483,5191,1)
(4271,8385,1)
(843,8800,1)
(6609,115,1)
(1850,4704,1)
(4680,4675,1)
(5776,5769,1)
(8176,4095,1)
(952,3451,1)
(3452,7244,1)
(1850,6033,1)
(6433,2239,1)
(5126,7548,1)
(8478,1175,1)
(9128,4195,1)
(7736,7852,1)
(8283,1785,1)
(7264,7711,1)
(4254,462,1)
(6196,8740,1)
(5851,1959,1)
(82,1906,1)
(6209,1149,1)
(8065,7570,1)
(6538,8839,1)
(2036,3842,1)
(6523,8391,1)
(2863,8689,1)
(3999,6239,1)
(5638,2112,1)
(5381,2727,1)
(5302,5188,1)
(7929,201,1)
(3214,115,1)
(2698,5156,1)
(1265,8581,1)
(8689,6435,1)
(4965,2972,1)
(4041,6855,1)
(8359,4268,1)
(8839,876,1)
(3984,189,1)
(8600,370,1)
(3474,4461,1)
(6288,115,1)
(6,6637,1)
(3772,6433,1)
(1955,6813,1)
(5640,2364,1)
(6278,2858,1)
(2652,8384,1)
(2121,6345,1)
(2075,3560,1)
(66,5395,1)
(8446,525,1)
(5479,7210,1)
(5477,5291,1)
(1590,36,1)
(6587,302,1)
(471,4900,1)
(5275,4475,1)
(4658,8694,1)
(4886,3789,1)
(1767,7262,1)
(1415,489,1)
(6215,8391,1)
(8248,3654,1)
(2093,3574,1)
(9136,4290,1)
(4375,2065,1)
(1232,8775,1)
(8061,4007,1)
(7178,7752,1)
(5179,5803,1)
(1083,2120,1)
(8952,7067,1)
(6109,3534,1)
(4035,2189,1)
(1415,8238,1)
(3752,570,1)
(1951,4567,1)
(2534,2845,1)
(3526,6943,1)
(2457,8391,1)
(1948,115,1)
(1266,8074,1)
(4800,6161,1)
(4985,2593,1)
(5397,5665,1)
(6873,849,1)
(885,924,1)
(7159,8391,1)
(1915,4664,1)
(7321,1296,1)
(7863,6409,1)
(1415,6921,1)
(6819,441,1)
(7073,5900,1)
(3638,6273,1)
(4499,1149,1)
(7244,2973,1)
(3444,2351,1)
(5058,6183,1)
(4873,8111,1)
(7594,1818,1)
(4923,533,1)
(1799,7083,1)
(9067,115,1)
(7978,940,1)
(3114,115,1)
(5475,4280,1)
(9067,3261,1)
(2506,8391,1)
(4827,7093,1)
(2647,115,1)
(6563,5147,1)
(8679,8075,1)
(5164,8391,1)
(6419,6649,1)
(2741,712,1)
(5280,2924,1)
(5086,1625,1)
(2812,1710,1)
(7411,115,1)
(2466,7527,1)
(2465,4865,1)
(4371,1821,1)
(3137,92,1)
(1410,8863,1)
(7467,5027,1)
(4558,7149,1)
(2727,3752,1)
(628,2153,1)
(3836,630,1)
(8288,6598,1)
(3038,664,1)
(4105,9114,1)
(7065,1547,1)
(1591,636,1)
(1816,1822,1)
(3967,8656,1)
(2923,174,1)
(3624,4577,1)
(7961,1293,1)
(2772,8793,1)
(2691,1701,1)
(448,4809,1)
(2287,6435,1)
(6334,5965,1)
(6684,1090,1)
(8749,6174,1)
(2758,1610,1)
(6213,1841,1)
(2316,6138,1)
(6103,8391,1)
(9108,4527,1)
(4120,1362,1)
(553,6510,1)
(5780,4436,1)
(359,8039,1)
(3651,6760,1)
(3612,5172,1)
(474,7980,1)
(7238,8406,1)
(380,68,1)
(4995,8113,1)
(4340,9107,1)
(7564,3045,1)
(8757,7939,1)
(4837,6292,1)
(3804,6356,1)
(7923,7472,1)
(8176,7316,1)
(2033,5302,1)
(7576,6277,1)
(950,1815,1)
(8415,25,1)
(8549,4837,1)
(4195,1225,1)
(9068,7661,1)
(3445,8117,1)
(6932,8391,1)
(2010,4124,1)
(4465,2479,1)
(191,1981,1)
(7643,5799,1)
(6165,1712,1)
(4963,2660,1)
(8630,6307,1)
(5341,6422,1)
(6624,7891,1)
(1081,827,1)
(4056,8391,1)
(1452,8480,1)
(9094,2323,1)
(6008,466,1)
(4172,6614,1)
(4217,8928,1)
(1015,8458,1)
(6297,8069,1)
(3099,718,1)
(2654,5240,1)
(5221,3765,1)
(3023,4779,1)
(2845,6174,1)
(5638,8441,1)
(5622,2206,1)
(6319,2504,1)
(1438,8831,1)
(2997,7664,1)
(5484,4963,1)
(7494,561,1)
(7182,336,1)
(5290,7859,1)
(5140,8622,1)
(7308,5403,1)
(2052,4772,1)
(4750,7240,1)
(2736,2834,1)
(5881,2780,1)
(1177,115,1)
(4840,3451,1)
(5193,5994,1)
(5795,2529,1)
(5838,7527,1)
(5320,822,1)
(434,7216,1)
(1415,144,1)
(6129,1554,1)
(4029,115,1)
(2736,2111,1)
(4873,9130,1)
(9021,5355,1)
(4176,115,1)
(5455,4510,1)
(1114,7691,1)
(3043,3546,1)
(5810,5419,1)
(7534,2105,1)
(5078,3603,1)
(45,6332,1)
(4402,618,1)
(5604,5084,1)
(3932,5801,1)
(7757,6918,1)
(4542,5646,1)
(7482,3550,1)
(2287,700,1)
(1359,1800,1)
(4289,4690,1)
(3847,8391,1)
(4259,8382,1)
(5297,5643,1)
(6458,1305,1)
(2484,1988,1)
(5813,115,1)
(5669,115,1)
(8095,7353,1)
(2924,3549,1)
(7570,5645,1)
(2423,115,1)
(664,663,1)
(4964,3813,1)
(22,2344,1)
(5998,115,1)
(377,7676,1)
(2242,2037,1)
(1121,4077,1)
(7735,4876,1)
(2112,8391,1)
(5840,3590,1)
(6122,8412,1)
(1742,8952,1)
(837,461,1)
(1479,6417,1)
(2762,5415,1)
(7552,6037,1)
(2333,4596,1)
(477,2845,1)
(7311,5319,1)
(6005,7609,1)
(2256,4002,1)
(5755,6678,1)
(2596,3637,1)
(3732,5341,1)
(653,226,1)
(3665,8566,1)
(6419,4587,1)
(8293,6849,1)
(6962,2676,1)
(6331,9114,1)
(2116,4536,1)
(8631,8655,1)
(6042,4108,1)
(7108,8391,1)
(96,6779,1)
(6243,5011,1)
(4997,7992,1)
(6669,5096,1)
(6023,115,1)
(7244,7878,1)
(3466,1315,1)
(722,8961,1)
(8799,6857,1)
(6771,8391,1)
(3932,2671,1)
(4376,7449,1)
(4913,5014,1)
(1831,4592,1)
(6483,2349,1)
(4974,4627,1)
(4518,2310,1)
(5854,2842,1)
(4301,3731,1)
(6972,6979,1)
(718,6156,1)
(6530,8034,1)
(1858,1117,1)
(9125,1180,1)
(445,702,1)
(7080,1599,1)
(4198,8391,1)
(2680,4872,1)
(7170,7089,1)
(7041,4413,1)
(1432,136,1)
(756,9021,1)
(3949,1962,1)
(6897,2032,1)
(6225,8108,1)
(8312,8346,1)
(7845,4099,1)
(5149,474,1)
(8532,9019,1)
(1469,7511,1)
(5991,8222,1)
(831,3407,1)
(6862,2355,1)
(6186,4518,1)
(4008,115,1)
(900,7366,1)
(2276,8887,1)
(1322,115,1)
(8051,2802,1)
(2544,8471,1)
(8207,4454,1)
(7759,3451,1)
(1530,944,1)
(2623,3270,1)
(8863,1944,1)
(2688,1141,1)
(8512,5744,1)
(8061,4628,1)
(5825,6130,1)
(8775,3300,1)
(3620,115,1)
(3326,4148,1)
(988,8305,1)
(1167,8391,1)
(4580,2845,1)
(792,7854,1)
(8200,115,1)
(5688,2043,1)
(3969,4704,1)
(9045,5281,1)
(5789,5255,1)
(9109,242,1)
(5305,7944,1)
(8450,6539,1)
(3747,7052,1)
(425,115,1)
(4373,5605,1)
(1415,3215,1)
(5216,5698,1)
(8830,115,1)
(7037,1795,1)
(114,5646,1)
(4951,392,1)
(8035,8455,1)
(2279,1241,1)
(3071,6953,1)
(1660,3969,1)
(1840,8273,1)
(2993,4544,1)
(2982,7418,1)
(287,5436,1)
(4564,7660,1)
(5448,6789,1)
(2350,8391,1)
(1262,4345,1)
(8130,8877,1)
(1103,4227,1)
(7244,7520,1)
(432,8718,1)
(1493,3166,1)
(3725,5223,1)
(3560,3108,1)
(7525,115,1)
(4245,3703,1)
(6629,6646,1)
(76,4718,1)
(7115,7506,1)
(6921,6217,1)
(8811,8275,1)
(4934,4861,1)
(5200,4089,1)
(4381,115,1)
(7865,6753,1)
(654,956,1)
(1324,9125,1)
(8736,1122,1)
(9051,5088,1)
(7374,8391,1)
(1981,882,1)
(8326,8339,1)
(7379,5268,1)
(790,8681,1)
(8741,5704,1)
(1908,7541,1)
(8001,7901,1)
(8649,4174,1)
(4233,7001,1)
(4919,8658,1)
(7331,8578,1)
(6087,4739,1)
(183,3530,1)
(8038,1158,1)
(8865,7802,1)
(1682,6405,1)
(4546,4899,1)
(7827,412,1)
(8527,774,1)
(6735,594,1)
(7159,3621,1)
(8307,7519,1)
(8184,6975,1)
(8510,5156,1)
(3278,6148,1)
(2918,3915,1)
(3701,8673,1)
(7213,5853,1)
(2266,4608,1)
(7587,548,1)
(6513,8391,1)
(4560,5396,1)
(6419,1405,1)
(3865,2303,1)
(424,3621,1)
(2955,4395,1)
(7765,6985,1)
(8358,7646,1)
(8646,4232,1)
(2972,4286,1)
(6000,4492,1)
(4625,115,1)
(3408,2684,1)
(2147,2845,1)
(1543,7698,1)
(1725,4886,1)
(2818,4325,1)
(7626,2112,1)
(1222,4876,1)
(4250,1073,1)
(6279,916,1)
(4068,3024,1)
(1832,2845,1)
(1978,1794,1)
(899,3758,1)
(5763,8107,1)
(3602,1188,1)
(1694,7157,1)
(1173,7722,1)
(8323,4512,1)
(1415,6952,1)
(5445,5768,1)
(3483,5156,1)
(1415,7524,1)
(6397,8391,1)
(6536,6454,1)
(5062,2569,1)
(3607,1826,1)
(5299,7035,1)
(1868,7876,1)
(6827,6579,1)
(2287,489,1)
(8832,7103,1)
(2234,2845,1)
(6602,8391,1)
(6288,8391,1)
(6127,693,1)
(248,115,1)
(7222,8391,1)
(1637,4282,1)
(5573,8527,1)
(8966,2845,1)
(9068,3184,1)
(4378,5159,1)
(1754,3921,1)
(48,5618,1)
(1478,8391,1)
(8971,1946,1)
(3207,1668,1)
(7020,2625,1)
(898,8434,1)
(325,8941,1)
(1135,568,1)
(733,6211,1)
(5196,8674,1)
(2866,2397,1)
(6374,6649,1)
(7136,4497,1)
(2333,7569,1)
(4286,5388,1)
(1854,3376,1)
(5536,6698,1)
(7743,4479,1)
(3420,3909,1)
(4618,4426,1)
(7512,5828,1)
(5210,4408,1)
(8793,7132,1)
(2978,2700,1)
(7067,115,1)
(8142,5961,1)
(5541,3761,1)
(2043,7430,1)
(7097,5263,1)
(7244,2045,1)
(4700,8653,1)
(1923,143,1)
(7950,6259,1)
(3374,3276,1)
(2333,8751,1)
(4043,115,1)
(6351,3297,1)
(7929,8391,1)
(5107,115,1)
(5672,5839,1)
(641,7497,1)
(5820,5282,1)
(3707,1263,1)
(2355,741,1)
(1415,1280,1)
(5649,8391,1)
(5760,4044,1)
(2254,515,1)
(5719,3212,1)
(7704,3742,1)
(5494,3215,1)
(2738,2112,1)
(4786,998,1)
(1969,115,1)
(7990,8995,1)
(4329,5520,1)
(7050,822,1)
(1954,7577,1)
(9074,8562,1)
(6513,8882,1)
(6611,8391,1)
(7244,2149,1)
(3509,700,1)
(4903,258,1)
(4587,6163,1)
(6011,7441,1)
(8960,3352,1)
(6725,3150,1)
(1960,2808,1)
(3087,1664,1)
(4630,9094,1)
(51,7850,1)
(8359,8391,1)
(121,8391,1)
(4446,9135,1)
(4116,2319,1)
(3804,3657,1)
(6168,7743,1)
(4922,6627,1)
(7968,8543,1)
(3149,115,1)
(8863,330,1)
(4798,115,1)
(212,4870,1)
(5736,3418,1)
(3962,6577,1)
(8501,3002,1)
(530,4632,1)
(8673,5110,1)
(7970,4878,1)
(4264,7582,1)
(8754,3946,1)
(160,4722,1)
(333,2414,1)
(7917,7912,1)
(8827,1802,1)
(2421,1384,1)
(4167,2206,1)
(6972,5156,1)
(869,5954,1)
(8654,5358,1)
(940,2592,1)
(1591,3046,1)
(6223,5478,1)
(5814,4230,1)
(7456,2004,1)
(4486,7705,1)
(8311,2845,1)
(5638,8111,1)
(3846,7745,1)
(592,115,1)
(5638,4587,1)
(6022,7711,1)
(3250,115,1)
(7480,2074,1)
(6701,8082,1)
(4375,8021,1)
(1121,2935,1)
(7375,7041,1)
(6451,115,1)
(4821,115,1)
(3509,9130,1)
(6603,8391,1)
(7403,6179,1)
(2475,4112,1)
(5775,829,1)
(3666,8257,1)
(7812,2309,1)
(3356,115,1)
(4571,1451,1)
(8909,4871,1)
(6158,6852,1)
(6419,3215,1)
(7242,1839,1)
(437,2845,1)
(8933,2254,1)
(7107,1481,1)
(2287,9138,1)
(16,50,1)
(1783,3817,1)
(4375,4350,1)
(1340,7435,1)
(8856,3725,1)
(3017,1034,1)
(5372,2609,1)
(775,2845,1)
(4873,1158,1)
(3016,4839,1)
(7244,7507,1)
(1180,3314,1)
(1108,4151,1)
(7337,2094,1)
(8255,5114,1)
(39,5337,1)
(5342,115,1)
(424,1872,1)
(5166,5734,1)
(3233,2535,1)
(3984,2898,1)
(219,8092,1)
(5724,4445,1)
(4487,67,1)
(3613,4781,1)
(8394,3003,1)
(6272,286,1)
(3025,5548,1)
(5582,8891,1)
(6356,6266,1)
(6067,8391,1)
(1190,865,1)
(5127,2589,1)
(902,7457,1)
(5168,3947,1)
(51,1488,1)
(7657,1560,1)
(8239,6494,1)
(6156,8849,1)
(3082,2816,1)
(7894,3363,1)
(6832,8617,1)
(6502,8038,1)
(5405,6717,1)
(7571,4298,1)
(5272,3286,1)
(1843,820,1)
(4791,3770,1)
(3966,2382,1)
(8315,2697,1)
(1037,5557,1)
(5526,5661,1)
(240,3396,1)
(170,8391,1)
(8544,6042,1)
(4168,6614,1)
(8846,7089,1)
(6364,6537,1)
(1095,989,1)
(6978,6737,1)
(7374,115,1)
(7531,5671,1)
(8045,3684,1)
(7488,3824,1)
(5432,5108,1)
(600,527,1)
(3429,3559,1)
(5027,7122,1)
(6419,6968,1)
(6734,115,1)
(4176,6191,1)
(1143,7207,1)
(5164,1598,1)
(7344,589,1)
(4346,4155,1)
(577,2043,1)
(7679,7219,1)
(7453,1222,1)
(4362,8708,1)
(1338,4856,1)
(3621,4515,1)
(344,1645,1)
(3936,252,1)
(3106,3239,1)
(6543,4914,1)
(2929,8811,1)
(8038,3889,1)
(1712,8866,1)
(714,2819,1)
(7798,5610,1)
(4641,5774,1)
(8966,8391,1)
(7720,5244,1)
(7327,2950,1)
(1415,6563,1)
(6780,6733,1)
(8897,7053,1)
(863,5843,1)
(36,6132,1)
(2452,309,1)
(2652,5030,1)
(136,1549,1)
(338,5530,1)
(4553,616,1)
(5145,4314,1)
(6884,8391,1)
(5151,1145,1)
(7735,3264,1)
(5877,8121,1)
(2543,6015,1)
(4646,4108,1)
(9019,115,1)
(7718,5404,1)
(6542,1197,1)
(4009,2735,1)
(4414,8184,1)
(3192,1616,1)
(8212,4038,1)
(213,4035,1)
(1941,5347,1)
(4212,8391,1)
(1219,6140,1)
(4214,6346,1)
(5602,3119,1)
(6722,7710,1)
(8295,8391,1)
(2042,4,1)
(2315,115,1)
(8155,6829,1)
(2515,4236,1)
(8680,1601,1)
(3725,6501,1)
(5688,7284,1)
(2932,5856,1)
(7097,6575,1)
(7757,8736,1)
(8577,85,1)
(9085,8885,1)
(7764,1291,1)
(1852,6577,1)
(8300,3258,1)
(5577,8391,1)
(3168,7044,1)
(1514,220,1)
(3807,3609,1)
(2339,7985,1)
(8637,6413,1)
(4824,5669,1)
(511,4516,1)
(7812,8391,1)
(7793,2347,1)
(1025,3633,1)
(3358,4849,1)
(4939,7006,1)
(6366,98,1)
(4012,8486,1)
(4707,3466,1)
(4472,5156,1)
(2376,679,1)
(8830,6153,1)
(7626,4515,1)
(1260,6150,1)
(402,8074,1)
(8189,5091,1)
(7023,5182,1)
(6133,4455,1)
(2555,5331,1)
(9020,5807,1)
(559,8715,1)
(6583,6724,1)
(7859,6587,1)
(4016,1644,1)
(252,3985,1)
(18,2825,1)
(6525,4702,1)
(8947,116,1)
(9068,4767,1)
(2988,344,1)
(3673,115,1)
(3864,6362,1)
(2287,1158,1)
(8286,2067,1)
(3933,676,1)
(2577,8756,1)
(1945,3749,1)
(8855,4088,1)
(3764,2791,1)
(6690,1299,1)
(2668,248,1)
(6768,5247,1)
(9013,2336,1)
(8395,5466,1)
(6814,1333,1)
(451,1459,1)
(5928,1602,1)
(1110,9021,1)
(3268,115,1)
(123,7429,1)
(8368,1284,1)
(2088,308,1)
(8476,2069,1)
(7198,115,1)
(6172,7652,1)
(7995,473,1)
(5105,6699,1)
(3019,6687,1)
(976,917,1)
(1813,1631,1)
(449,7924,1)
(5934,5569,1)
(8171,2365,1)
(7275,8441,1)
(2591,115,1)
(1905,7100,1)
(5709,1240,1)
(8844,3105,1)
(6749,8862,1)
(3675,8391,1)
(6353,7514,1)
(2087,5461,1)
(6745,8745,1)
(5871,4582,1)
(3844,8391,1)
(7370,2324,1)
(8920,2033,1)
(1592,1466,1)
(4319,115,1)
(2006,6047,1)
(5707,2115,1)
(353,115,1)
(6457,2879,1)
(2832,3949,1)
(6390,4886,1)
(1415,3747,1)
(5068,2174,1)
(3273,2971,1)
(9083,4259,1)
(3556,5141,1)
(1716,547,1)
(6151,5317,1)
(6293,4950,1)
(9002,145,1)
(1415,7404,1)
(7883,2845,1)
(286,6556,1)
(3160,912,1)
(3398,3645,1)
(862,7307,1)
(5638,3565,1)
(4804,4645,1)
(5499,4084,1)
(2544,1270,1)
(8807,5972,1)
(8216,730,1)
(2595,6621,1)
(2871,3377,1)
(5687,115,1)
(8654,1190,1)
(8149,1729,1)
(3690,3125,1)
(3252,5085,1)
(3062,5224,1)
(4030,7161,1)
(259,8563,1)
(769,800,1)
(5284,4362,1)
(4395,5309,1)
(3403,7671,1)
(6504,3860,1)
(3637,9007,1)
(1364,8426,1)
(8129,3529,1)
(1798,686,1)
(3472,6804,1)
(231,7585,1)
(4896,4562,1)
(3285,5156,1)
(6030,7994,1)
(6602,5448,1)
(1240,6280,1)
(2710,4092,1)
(9,7576,1)
(6388,6164,1)
(8079,1977,1)
(8765,7285,1)
(7855,364,1)
(2874,1368,1)
(7459,6870,1)
(2153,926,1)
(6419,2112,1)
(7252,4694,1)
(7724,2841,1)
(5295,8717,1)
(8418,2224,1)
(1896,9106,1)
(2258,8088,1)
(4914,8373,1)
(4405,2790,1)
(8581,1486,1)
(4991,4426,1)
(2775,2845,1)
(3363,7293,1)
(8361,3547,1)
(7449,8985,1)
(7452,5470,1)
(4688,4277,1)
(4909,1884,1)
(1415,3331,1)
(4962,4682,1)
(3690,2845,1)
(4652,4350,1)
(7664,8886,1)
(828,5792,1)
(698,6554,1)
(8770,9008,1)
(2522,2845,1)
(6278,3995,1)
(1375,7351,1)
(2955,5309,1)
(4579,360,1)
(2164,1672,1)
(3887,8710,1)
(5809,700,1)
(6468,1285,1)
(3058,1666,1)
(1949,4724,1)
(1092,2566,1)
(1151,3353,1)
(6824,2618,1)
(6160,1996,1)
(6983,1868,1)
(6828,2913,1)
(5851,2645,1)
(4917,2328,1)
(8280,4376,1)
(7984,8391,1)
(1294,6124,1)
(5017,2164,1)
(524,2348,1)
(644,990,1)
(3740,8391,1)
(7363,5434,1)
(7871,7711,1)
(5096,178,1)
(655,5702,1)
(5930,2900,1)
(7914,8945,1)
(267,3523,1)
(4600,8269,1)
(7228,8612,1)
(6346,1924,1)
(1168,1253,1)
(8451,6593,1)
(8366,683,1)
(4125,8677,1)
(4089,3621,1)
(3198,6998,1)
(9069,8391,1)
(3604,5156,1)
(942,5144,1)
(7097,5512,1)
(6855,51,1)
(3558,8379,1)
(5178,437,1)
(3619,3273,1)
(611,650,1)
(53,8379,1)
(1395,3062,1)
(8393,3678,1)
(8699,4158,1)
(4002,6120,1)
(2302,6407,1)
(42,4110,1)
(2019,893,1)
(5312,1903,1)
(9049,8391,1)
(4152,5084,1)
(5483,8074,1)
(4375,9130,1)
(6503,5365,1)
(7852,6722,1)
(3547,7650,1)
(565,8124,1)
(7812,9059,1)
(4698,366,1)
(1916,3150,1)
(5947,1035,1)
(9086,5209,1)
(6173,9067,1)
(5935,6359,1)
(4746,1357,1)
(7473,656,1)
(1702,2817,1)
(6653,7977,1)
(7992,8853,1)
(914,4876,1)
(2234,1457,1)
(1825,2025,1)
(4309,5156,1)
(4375,9035,1)
(5942,150,1)
(7283,8391,1)
(6868,8109,1)
(2221,8779,1)
(5107,8391,1)
(933,3136,1)
(3786,115,1)
(2432,7681,1)
(235,5397,1)
(2074,1488,1)
(5809,4515,1)
(825,8142,1)
(4219,4876,1)
(8463,8007,1)
(4162,3082,1)
(6307,8626,1)
(6809,8161,1)
(56,3757,1)
(3114,5521,1)
(8628,8199,1)
(853,122,1)
(8654,886,1)
(7777,8452,1)
(5486,983,1)
(2977,440,1)
(6867,1467,1)
(4375,2112,1)
(2714,6496,1)
(6415,5460,1)
(8667,4910,1)
(7408,6084,1)
(5959,1149,1)
(7945,3648,1)
(8550,7394,1)
(105,3010,1)
(1372,8425,1)
(3917,736,1)
(1974,3222,1)
(5303,3142,1)
(4270,5707,1)
(1752,3942,1)
(1604,1495,1)
(3087,2108,1)
(725,967,1)
(7835,2008,1)
(4650,9059,1)
(838,5058,1)
(8328,1793,1)
(8616,115,1)
(8604,5076,1)
(4873,7039,1)
(3227,2560,1)
(2220,7432,1)
(4375,1826,1)
(9038,115,1)
(7418,4117,1)
(8182,5555,1)
(5131,7868,1)
(2295,4619,1)
(6541,614,1)
(6946,6462,1)
(285,3201,1)
(6487,2562,1)
(5264,5985,1)
(5655,8391,1)
(7872,5760,1)
(3746,2318,1)
(1749,7765,1)
(8296,8391,1)
(1753,3462,1)
(2833,5230,1)
(1006,7295,1)
(3775,2392,1)
(7660,115,1)
(8265,7630,1)
(6837,4994,1)
(1577,7007,1)
(127,1809,1)
(7477,7744,1)
(4342,9048,1)
(2830,5664,1)
(7159,4215,1)
(5881,2386,1)
(6945,8323,1)
(2981,2702,1)
(2543,2112,1)
(5675,2836,1)
(3028,7683,1)
(307,2482,1)
(6126,299,1)
(372,1043,1)
(6284,700,1)
(8524,8430,1)
(3428,6100,1)
(4730,88,1)
(4405,7389,1)
(8967,6394,1)
(3597,1438,1)
(7925,5018,1)
(219,8391,1)
(2666,5156,1)
(6844,5100,1)
(6197,6921,1)
(8882,329,1)
(7239,1052,1)
(9137,8880,1)
(3865,2858,1)
(991,3215,1)
(3034,8979,1)
(7408,3875,1)
(8534,4142,1)
(6600,1488,1)
(7833,2043,1)
(1766,3601,1)
(9007,7210,1)
(7579,3103,1)
(4605,3077,1)
(538,5575,1)
(2277,66,1)
(856,5322,1)
(6851,2177,1)
(5982,115,1)
(3847,115,1)
(4489,3926,1)
(272,509,1)
(607,1378,1)
(8409,3641,1)
(3782,1369,1)
(573,7159,1)
(6703,2205,1)
(7920,5382,1)
(6509,3780,1)
(7892,1370,1)
(1687,4059,1)
(8511,6829,1)
(8844,1013,1)
(2349,6900,1)
(2663,2173,1)
(2250,5221,1)
(2854,7381,1)
(340,6233,1)
(7910,2845,1)
(3468,1564,1)
(5853,1768,1)
(2069,7542,1)
(7064,7734,1)
(3658,7572,1)
(5955,7600,1)
(3001,115,1)
(4998,3386,1)
(4773,115,1)
(7766,3511,1)
(8366,8391,1)
(5337,4095,1)
(3811,6192,1)
(4361,1617,1)
(6180,3934,1)
(1175,4525,1)
(2666,4876,1)
(299,2183,1)
(847,7498,1)
(1646,7807,1)
(4595,4087,1)
(3338,7334,1)
(8536,4539,1)
(2586,6803,1)
(4394,8873,1)
(4375,1280,1)
(4015,1056,1)
(3475,8841,1)
(5893,5308,1)
(8302,388,1)
(5477,8391,1)
(797,841,1)
(3230,7566,1)
(5687,8391,1)
(8196,4654,1)
(8215,1572,1)
(6110,11,1)
(6861,3146,1)
(5,115,1)
(3863,5881,1)
(5554,9063,1)
(2471,3696,1)
(1113,7461,1)
(4933,2448,1)
(1415,4386,1)
(4375,7380,1)
(7504,4334,1)
(8891,2043,1)
(9098,1062,1)
(340,8391,1)
(9049,115,1)
(49,536,1)
(2386,5008,1)
(8941,4740,1)
(3990,313,1)
(7296,7475,1)
(1204,5306,1)
(1980,4593,1)
(6580,2353,1)
(3124,1368,1)
(848,3798,1)
(4453,6922,1)
(1129,4753,1)
(3621,4587,1)
(2839,2465,1)
(5382,8606,1)
(1574,8751,1)
(222,5647,1)
(611,6592,1)
(6158,8391,1)
(1415,2993,1)
(5258,8398,1)
(2455,2645,1)
(2721,5157,1)
(540,4235,1)
(7244,7529,1)
(927,4471,1)
(2612,5394,1)
(3804,7140,1)
(8035,5156,1)
(3320,4842,1)
(6495,5126,1)
(8832,6582,1)
(794,4136,1)
(2706,5371,1)
(872,2767,1)
(8405,8894,1)
(3899,2845,1)
(2007,6659,1)
(177,7004,1)
(6569,2996,1)
(6046,2121,1)
(6104,8391,1)
(2104,5156,1)
(14,7840,1)
(5269,2069,1)
(507,2797,1)
(2967,7154,1)
(5587,9046,1)
(597,5377,1)
(6547,1247,1)
(3518,4503,1)
(5927,3386,1)
(3329,8521,1)
(1850,4238,1)
(859,871,1)
(8123,314,1)
(4578,7760,1)
(2622,3608,1)
(5238,7740,1)
(8194,605,1)
(1415,700,1)
(8643,927,1)
(2168,2690,1)
(3412,4332,1)
(4874,646,1)
(2721,4619,1)
(1386,8817,1)
(99,4005,1)
(6772,1454,1)
(2470,1283,1)
(9029,115,1)
(2185,8397,1)
(773,1573,1)
(7646,115,1)
(3620,8391,1)
(826,8765,1)
(6627,115,1)
(4520,7599,1)
(6357,8391,1)
(8825,4080,1)
(2995,4493,1)
(8558,5027,1)
(6522,826,1)
(2855,6557,1)
(3412,3810,1)
(6461,7569,1)
(1276,6689,1)
(3787,8854,1)
(3934,2468,1)
(8929,8026,1)
(2257,7397,1)
(5285,4646,1)
(909,2236,1)
(2671,8391,1)
(8658,7924,1)
(8038,1270,1)
(7574,1416,1)
(7404,7015,1)
(1470,3854,1)
(5889,1965,1)
(515,6523,1)
(3659,9125,1)
(1347,6341,1)
(4638,4225,1)
(5152,5546,1)
(5229,223,1)
(4793,1410,1)
(2412,8601,1)
(4759,3759,1)
(1821,3593,1)
(3170,640,1)
(9067,8391,1)
(4832,3337,1)
(4961,6327,1)
(5690,7453,1)
(3401,3821,1)
(1088,3743,1)
(9026,8391,1)
(6045,5283,1)
(8659,8136,1)
(8049,3232,1)
(4258,4554,1)
(8209,4876,1)
(3921,398,1)
(8015,9011,1)
(7150,7258,1)
(50,5351,1)
(7604,1943,1)
(4874,5932,1)
(4422,6995,1)
(1966,7872,1)
(6396,1787,1)
(4558,921,1)
(9096,1429,1)
(5345,8391,1)
(1982,5156,1)
(5240,6864,1)
(5479,6256,1)
(3875,7393,1)
(4950,6024,1)
(6274,5628,1)
(1899,8391,1)
(8267,7624,1)
(2799,3554,1)
(7892,5696,1)
(3150,546,1)
(8067,1485,1)
(6654,3643,1)
(2940,797,1)
(3647,3491,1)
(1252,1682,1)
(2592,3319,1)
(6048,8315,1)
(5638,6921,1)
(3865,3983,1)
(3593,8254,1)
(6142,1324,1)
(7889,4942,1)
(8722,9117,1)
(7800,3457,1)
(3421,2012,1)
(1162,6000,1)
(6477,5527,1)
(4873,2112,1)
(6705,1187,1)
(7660,3152,1)
(3697,3243,1)
(995,5893,1)
(6386,7621,1)
(2695,805,1)
(6348,6736,1)
(8539,8079,1)
(4187,2803,1)
(3285,968,1)
(8102,4252,1)
(8237,5264,1)
(3997,7026,1)
(9142,5428,1)
(3660,8695,1)
(8654,8677,1)
(5509,7444,1)
(3804,2112,1)
(7021,5501,1)
(7972,2300,1)
(8486,4063,1)
(6555,115,1)
(1130,8756,1)
(495,8134,1)
(5584,115,1)
(5468,5668,1)
(1948,4363,1)
(5560,2240,1)
(3760,3829,1)
(1891,2211,1)
(6456,3217,1)
(1415,3518,1)
(6472,8493,1)
(4932,5594,1)
(8528,7687,1)
(6815,7815,1)
(8296,2309,1)
(8681,8691,1)
(5520,3953,1)
(4850,8391,1)
(210,8281,1)
(2808,7056,1)
(6663,2845,1)
(6419,4515,1)
(5370,7299,1)
(2058,4272,1)
(4456,4895,1)
(2303,3647,1)
(532,4795,1)
(5451,8391,1)
(421,4250,1)
(6842,7333,1)
(1993,9089,1)
(1298,4835,1)
(6891,9003,1)
(476,7491,1)
(1415,2533,1)
(261,5727,1)
(5237,5868,1)
(4026,115,1)
(6686,8391,1)
(5045,1236,1)
(5982,8391,1)
(7031,8391,1)
(609,7606,1)
(7839,4917,1)
(5786,619,1)
(1009,3028,1)
(6106,6104,1)
(7837,7508,1)
(3279,6324,1)
(1337,6895,1)
(4401,3675,1)
(4495,6364,1)
(8568,4561,1)
(8108,5914,1)
(5327,1422,1)
(1727,8391,1)
(7722,6984,1)
(7728,2060,1)
(4773,8391,1)
(9112,1519,1)
(7356,8263,1)
(3804,6474,1)
(2182,497,1)
(4705,3028,1)
(463,8391,1)
(3790,739,1)
(784,765,1)
(5228,5946,1)
(8778,8343,1)
(6658,6562,1)
(2437,304,1)
(5809,7151,1)
(1900,2653,1)
(2614,932,1)
(8655,3306,1)
(2268,465,1)
(3648,5518,1)
(206,9086,1)
(8139,115,1)
(5907,124,1)
(1485,7066,1)
(6865,8391,1)
(8877,8901,1)
(5483,3465,1)
(1628,8391,1)
(8978,5539,1)
(6451,321,1)
(1412,4540,1)
(3183,7594,1)
(1283,2335,1)
(8795,4152,1)
(7670,115,1)
(7367,8391,1)
(8632,4679,1)
(1021,2197,1)
(2099,3875,1)
(4723,3454,1)
(3621,7039,1)
(5826,5763,1)
(7026,7988,1)
(2360,2576,1)
(1415,3657,1)
(7315,7667,1)
(4310,6090,1)
(3027,607,1)
(6062,2117,1)
(7179,8716,1)
(3538,1707,1)
(7234,4364,1)
(6975,3583,1)
(4375,7280,1)
(4034,4432,1)
(429,2474,1)
(5638,7280,1)
(2203,1066,1)
(5776,8204,1)
(957,7963,1)
(1564,7984,1)
(5845,2809,1)
(6359,5301,1)
(4253,235,1)
(1405,8391,1)
(2650,8946,1)
(2782,8172,1)
(6022,7261,1)
(4795,7504,1)
(2844,7012,1)
(5982,6983,1)
(6234,115,1)
(546,4555,1)
(3021,56,1)
(2938,8590,1)
(2345,1403,1)
(538,6446,1)
(6348,6336,1)
(5796,4807,1)
(533,7287,1)
(6649,8391,1)
(91,1351,1)
(1878,8391,1)
(5215,7036,1)
(1284,3170,1)
(8242,115,1)
(8204,7042,1)
(5726,7168,1)
(6004,2034,1)
(5069,1013,1)
(5971,5537,1)
(2742,4784,1)
(1874,3660,1)
(2497,8391,1)
(2195,8805,1)
(7691,3869,1)
(297,7353,1)
(1790,2020,1)
(3473,2496,1)
(1474,1158,1)
(8166,7434,1)
(4320,867,1)
(4253,4522,1)
(5429,567,1)
(3102,2674,1)
(5875,319,1)
(7334,3634,1)
(7244,2669,1)
(365,5163,1)
(5704,731,1)
(7849,8802,1)
(4628,4379,1)
(7280,1879,1)
(2464,1177,1)
(4427,3501,1)
(368,1359,1)
(134,7392,1)
(8122,4808,1)
(8025,8890,1)
(8024,1082,1)
(5851,2444,1)
(9099,2725,1)
(5158,2769,1)
(7628,7315,1)
(1421,4859,1)
(113,3972,1)
(2618,2134,1)
(4268,877,1)
(2176,2457,1)
(5752,1600,1)
(1674,4201,1)
(5322,5416,1)
(5940,5560,1)
(8838,6232,1)
(1565,6762,1)
(5895,889,1)
(5051,8129,1)
(7098,865,1)
(8574,6388,1)
(5540,7055,1)
(7714,6318,1)
(8809,4388,1)
(6524,283,1)
(1400,8391,1)
(3438,5654,1)
(2539,1503,1)
(1928,1706,1)
(2072,115,1)
(8190,7863,1)
(8793,6412,1)
(1847,839,1)
(5823,433,1)
(1240,1954,1)
(6030,115,1)
(3219,1420,1)
(6072,115,1)
(947,8414,1)
(4639,4709,1)
(1957,2634,1)
(7587,5425,1)
(7758,6711,1)
(4669,2559,1)
(5422,816,1)
(3138,8391,1)
(3819,115,1)
(6899,646,1)
(6971,8245,1)
(7864,7836,1)
(3359,7474,1)
(2497,662,1)
(6656,5266,1)
(1121,6064,1)
(6357,115,1)
(3912,7236,1)
(3097,6850,1)
(5346,1215,1)
(1389,5810,1)
(4510,5775,1)
(2441,2693,1)
(6797,7764,1)
(6242,2951,1)
(1435,1099,1)
(2513,590,1)
(7868,7587,1)
(5114,6583,1)
(8355,4451,1)
(8582,1842,1)
(4490,8925,1)
(3430,8391,1)
(6771,115,1)
(1677,1961,1)
(4419,1453,1)
(8660,2068,1)
(7257,4404,1)
(4976,4637,1)
(2330,3596,1)
(6060,5342,1)
(1259,6812,1)
(7547,6701,1)
(2422,5233,1)
(1755,115,1)
(6125,115,1)
(726,444,1)
(8552,7586,1)
(3614,1347,1)
(3696,5198,1)
(5877,7271,1)
(6670,3994,1)
(6405,2728,1)
(4701,8778,1)
(1007,5974,1)
(7717,5456,1)
(2323,8201,1)
(8891,5829,1)
(4063,4907,1)
(3205,4315,1)
(7187,3930,1)
(6534,3469,1)
(3594,6480,1)
(8038,3215,1)
(9044,8857,1)
(4084,2572,1)
(2585,617,1)
(2316,3577,1)
(2146,8127,1)
(7647,3375,1)
(4189,8391,1)
(8768,7555,1)
(7409,5196,1)
(180,536,1)
(1670,1941,1)
(1067,6929,1)
(527,3701,1)
(5537,7221,1)
(7799,4589,1)
(6556,8391,1)
(8702,8761,1)
(4544,7113,1)
(7250,3581,1)
(3306,777,1)
(8626,6609,1)
(5654,8989,1)
(3774,115,1)
(2433,5432,1)
(6592,5829,1)
(1166,115,1)
(4851,2502,1)
(3375,8009,1)
(5460,2212,1)
(5378,17,1)
(4252,7458,1)
(4043,5339,1)
(8444,891,1)
(9033,3224,1)
(9140,4095,1)
(786,7352,1)
(7944,5307,1)
(8494,1780,1)
(3349,7962,1)
(3882,5784,1)
(5874,7450,1)
(7578,8391,1)
(4249,5854,1)
(8022,7347,1)
(6425,8757,1)
(3251,3346,1)
(2501,8494,1)
(7546,4137,1)
(2989,2229,1)
(1245,3538,1)
(2157,115,1)
(2583,8699,1)
(8624,152,1)
(6422,8832,1)
(3264,3717,1)
(7090,3127,1)
(7497,119,1)
(8403,7085,1)
(1155,6213,1)
(5717,8433,1)
(2564,5070,1)
(8554,4451,1)
(3614,4175,1)
(927,6995,1)
(2429,455,1)
(486,1418,1)
(3203,737,1)
(908,8851,1)
(4253,3983,1)
(8552,3277,1)
(1603,1147,1)
(2723,4274,1)
(8174,8504,1)
(9115,8495,1)
(4721,559,1)
(8385,5246,1)
(8969,1221,1)
(7582,944,1)
(8279,8391,1)
(1097,1491,1)
(5049,4196,1)
(5645,5719,1)
(1208,115,1)
(5297,7210,1)
(8594,1149,1)
(2008,708,1)
(3295,6758,1)
(1952,2147,1)
(1256,1475,1)
(7244,3092,1)
(6932,8750,1)
(727,115,1)
(5809,3215,1)
(702,284,1)
(3810,3788,1)
(4375,5736,1)
(5772,4147,1)
(6284,3565,1)
(282,2922,1)
(7208,6464,1)
(5084,4775,1)
(1641,2808,1)
(8665,3676,1)
(4766,8292,1)
(528,115,1)
(6894,7018,1)
(3532,3059,1)
(1718,1915,1)
(2424,8391,1)
(5122,4656,1)
(5165,2912,1)
(1462,115,1)
(1632,6304,1)
(8461,1149,1)
(4565,462,1)
(4957,6282,1)
(5430,76,1)
(6361,5399,1)
(2776,6030,1)
(104,5004,1)
(8332,1581,1)
(5829,7152,1)
(7283,4476,1)
(4860,2490,1)
(7077,897,1)
(1094,1587,1)
(781,1200,1)
(4514,869,1)
(5725,216,1)
(7710,1735,1)
(1484,7029,1)
(3132,5712,1)
(7056,115,1)
(8811,8391,1)
(6557,1049,1)
(4232,6585,1)
(6726,5156,1)
(7579,8796,1)
(4375,6055,1)
(6531,2348,1)
(1803,4105,1)
(8510,6240,1)
(4949,5117,1)
(7575,580,1)
(462,6741,1)
(7563,3938,1)
(8200,8391,1)
(4497,115,1)
(8069,430,1)
(1082,8391,1)
(667,492,1)
(7245,1444,1)
(5556,5312,1)
(8354,1013,1)
(5950,5156,1)
(2367,2322,1)
(7997,8923,1)
(4754,5356,1)
(3470,3116,1)
(2879,531,1)
(3853,234,1)
(8538,2093,1)
(7854,951,1)
(9029,8391,1)
(3946,854,1)
(6899,4874,1)
(1605,5156,1)
(1678,6694,1)
(1018,4783,1)
(8889,115,1)
(6221,4578,1)
(1900,6664,1)
(2300,1752,1)
(1287,8864,1)
(7744,218,1)
(6012,4460,1)
(7931,92,1)
(8853,3198,1)
(8253,2792,1)
(2354,8391,1)
(6528,3138,1)
(5873,5802,1)
(7729,8756,1)
(5094,1894,1)
(3301,3167,1)
(7121,7591,1)
(7532,8391,1)
(4086,7548,1)
(4655,6262,1)
(5393,5641,1)
(2539,1488,1)
(2869,5995,1)
(3008,4382,1)
(2475,8391,1)
(8072,453,1)
(7834,3610,1)
(2550,6032,1)
(7761,1605,1)
(6833,3815,1)
(2438,1374,1)
(2543,3215,1)
(2146,2612,1)
(5103,5485,1)
(4953,2779,1)
(579,8391,1)
(1581,2030,1)
(745,6999,1)
(4163,3060,1)
(3373,4637,1)
(3877,7711,1)
(6228,7437,1)
(3786,5130,1)
(931,5535,1)
(8485,6019,1)
(5698,1848,1)
(6074,681,1)
(4583,8155,1)
(2592,6967,1)
(3537,6228,1)
(1625,5272,1)
(7202,4556,1)
(8189,4842,1)
(1975,508,1)
(5638,9130,1)
(8831,8137,1)
(5923,4458,1)
(1133,4260,1)
(7182,115,1)
(7953,137,1)
(2509,8983,1)
(2318,5169,1)
(2638,6755,1)
(4236,3030,1)
(5021,6887,1)
(6054,8391,1)
(6932,115,1)
(5847,749,1)
(2885,5748,1)
(8525,350,1)
(6537,1694,1)
(1078,3888,1)
(4926,8405,1)
(1435,675,1)
(2277,1563,1)
(4424,4876,1)
(2684,1987,1)
(5699,3322,1)
(4506,1020,1)
(2413,5411,1)
(8877,6626,1)
(7866,1029,1)
(241,1641,1)
(6909,5506,1)
(7869,6114,1)
(4010,709,1)
(3890,7695,1)
(3354,7034,1)
(4650,3621,1)
(8296,3451,1)
(4612,3882,1)
(5494,4515,1)
(8038,4515,1)
(1519,2831,1)
(8212,5602,1)
(72,6566,1)
(706,560,1)
(1415,7544,1)
(7517,8270,1)
(4412,8021,1)
(4863,3635,1)
(2282,6653,1)
(577,5829,1)
(4742,3292,1)
(8179,5401,1)
(8452,1149,1)
(5205,8187,1)
(5586,4619,1)
(2157,5113,1)
(4118,7970,1)
(1934,4926,1)
(8910,6823,1)
(8130,3431,1)
(3670,5771,1)
(8697,4876,1)
(1506,1656,1)
(562,4317,1)
(8453,4763,1)
(3625,7388,1)
(4628,7297,1)
(4299,4980,1)
(1047,115,1)
(1087,777,1)
(1461,2657,1)
(7556,2176,1)
(2815,8155,1)
(6188,7218,1)
(3167,2680,1)
(6660,786,1)
(7049,771,1)
(1636,4148,1)
(3467,6660,1)
(8175,7234,1)
(1415,796,1)
(5808,7567,1)
(1761,4822,1)
(3902,4815,1)
(4433,2056,1)
(1167,1371,1)
(5615,1488,1)
(6675,2929,1)
(5124,875,1)
(6278,2303,1)
(1474,49,1)
(6189,6532,1)
(3112,5682,1)
(5801,5333,1)
(2536,2647,1)
(3440,1745,1)
(8982,4,1)
(4722,3619,1)
(4332,7959,1)
(5504,5963,1)
(1029,3662,1)
(3194,3117,1)
(3326,1636,1)
(951,6528,1)
(4615,2757,1)
(7400,7328,1)
(933,1500,1)
(3509,4587,1)
(1705,3904,1)
(6847,1289,1)
(6064,7577,1)
(7119,5965,1)
(4377,7076,1)
(8589,8705,1)
(1849,8799,1)
(6492,4909,1)
(1415,373,1)
(903,8391,1)
(6674,4733,1)
(7038,3903,1)
(7326,5384,1)
(2675,1823,1)
(6437,4710,1)
(1331,2677,1)
(9133,8969,1)
(1954,4445,1)
(5446,5067,1)
(2167,115,1)
(6544,7929,1)
(680,3368,1)
(1987,1353,1)
(7566,4568,1)
(6366,6488,1)
(3604,4876,1)
(2609,8330,1)
(6317,8391,1)
(5494,8111,1)
(7803,799,1)
(2426,7514,1)
(8900,7383,1)
(5858,6188,1)
(2731,3433,1)
(3173,7553,1)
(6097,7636,1)
(2642,5813,1)
(5744,28,1)
(508,519,1)
(7031,2845,1)
(484,1803,1)
(3641,563,1)
(5932,9083,1)
(5328,2366,1)
(902,8391,1)
(3097,250,1)
(685,348,1)
(280,8647,1)
(7225,2380,1)
(7244,5044,1)
(2036,284,1)
(6498,3795,1)
(2593,298,1)
(8470,8700,1)
(3633,4249,1)
(6765,7423,1)
(7632,115,1)
(8419,5372,1)
(2062,3415,1)
(6517,6558,1)
(242,3865,1)
(5669,8391,1)
(1466,8911,1)
(5579,3208,1)
(387,1108,1)
(5689,7346,1)
(3292,3367,1)
(3690,8391,1)
(2754,40,1)
(5488,6439,1)
(8719,115,1)
(1544,4366,1)
(159,2938,1)
(1064,4759,1)
(1744,3975,1)
(2188,1311,1)
(191,882,1)
(5769,8204,1)
(1399,8923,1)
(2834,2845,1)
(3014,6091,1)
(5984,5626,1)
(3500,1294,1)
(6271,3083,1)
(2216,7827,1)
(8756,5508,1)
(4112,8665,1)
(7244,7584,1)
(5888,6599,1)
(1416,2260,1)
(915,9141,1)
(6426,1022,1)
(2310,4792,1)
(4647,7192,1)
(249,2574,1)
(6061,7995,1)
(1618,4288,1)
(2385,8391,1)
(2797,163,1)
(314,1542,1)
(2858,4547,1)
(7241,7751,1)
(6069,4340,1)
(1512,4537,1)
(7387,4410,1)
(1138,249,1)
(5383,5348,1)
(1191,3983,1)
(4002,115,1)
(5357,4141,1)
(5733,2226,1)
(1415,7280,1)
(4249,8533,1)
(2044,2316,1)
(8038,6968,1)
(2284,7473,1)
(5033,5811,1)
(4375,489,1)
(926,115,1)
(7420,1376,1)
(1900,6816,1)
(8241,1487,1)
(2966,8836,1)
(256,6907,1)
(1277,8954,1)
(6069,2896,1)
(4783,3785,1)
(5301,769,1)
(6723,7322,1)
(6470,8797,1)
(6550,4224,1)
(3213,3215,1)
(5220,2466,1)
(7799,1149,1)
(5960,7652,1)
(5144,115,1)
(2031,5156,1)
(636,3165,1)
(4068,584,1)
(8710,8806,1)
(4413,4819,1)
(2908,2511,1)
(7287,115,1)
(5894,420,1)
(5805,7024,1)
(6557,8944,1)
(7900,157,1)
(1607,7248,1)
(1476,8525,1)
(3507,1464,1)
(7056,7911,1)
(6391,8812,1)
(647,4367,1)
(1121,5362,1)
(7498,115,1)
(5965,5829,1)
(4657,8804,1)
(6337,8789,1)
(378,6299,1)
(3975,5964,1)
(5371,115,1)
(6069,7079,1)
(1424,6778,1)
(4236,306,1)
(6163,2931,1)
(2666,3303,1)
(7731,859,1)
(3940,8391,1)
(1369,5156,1)
(1576,47,1)
(5128,8063,1)
(8209,126,1)
(2525,65,1)
(1555,1999,1)
(4809,7210,1)
(2888,2963,1)
(3992,6098,1)
(2899,9138,1)
(6030,8391,1)
(578,3162,1)
(897,115,1)
(1540,4576,1)
(5071,3519,1)
(8597,4755,1)
(4632,7890,1)
(4765,7210,1)
(8728,6577,1)
(5714,3762,1)
(4434,7889,1)
(6174,4618,1)
(5586,6298,1)
(6069,5512,1)
(7623,7877,1)
(5602,4951,1)
(4710,915,1)
(1623,2475,1)
(3445,4735,1)
(3800,2359,1)
(6502,2687,1)
(5219,6328,1)
(1507,1344,1)
(4842,8189,1)
(8178,3185,1)
(730,3775,1)
(4381,6774,1)
(6450,6448,1)
(6711,1825,1)
(6808,7480,1)
(2320,1306,1)
(4733,2041,1)
(5716,6978,1)
(7980,9059,1)
(2544,700,1)
(1764,467,1)
(7871,69,1)
(4831,6893,1)
(3259,1488,1)
(5654,4905,1)
(5519,8391,1)
(7244,3412,1)
(4892,7186,1)
(8887,367,1)
(7244,6470,1)
(3713,8391,1)
(5688,1048,1)
(7932,2670,1)
(4549,115,1)
(2180,7532,1)
(9119,8391,1)
(7931,3427,1)
(5588,8114,1)
(1045,7225,1)
(1017,8391,1)
(5688,5829,1)
(3213,3565,1)
(4685,8493,1)
(7244,210,1)
(1098,7361,1)
(7094,2711,1)
(6182,8148,1)
(2981,2112,1)
(5968,3078,1)
(165,334,1)
(6419,4149,1)
(4218,4655,1)
(9102,3901,1)
(8537,8893,1)
(5214,4587,1)
(6663,1058,1)
(7684,6226,1)
(6414,4820,1)
(5530,7410,1)
(7097,7577,1)
(4018,3819,1)
(6019,7791,1)
(1864,4452,1)
(5648,5287,1)
(2297,7711,1)
(5331,3176,1)
(5421,4821,1)
(8213,7220,1)
(4640,6033,1)
(1974,5178,1)
(5650,2748,1)
(862,8391,1)
(952,8391,1)
(553,3683,1)
(7681,8726,1)
(967,8273,1)
(8723,2500,1)
(8132,2666,1)
(6935,115,1)
(8523,2172,1)
(7626,1405,1)
(1438,115,1)
(58,6395,1)
(7485,1967,1)
(2111,7030,1)
(4500,7314,1)
(8362,6647,1)
(4735,1149,1)
(3074,3463,1)
(5807,2964,1)
(913,4062,1)
(7086,1919,1)
(3083,3417,1)
(4637,3631,1)
(1692,4920,1)
(2909,8391,1)
(35,1234,1)
(4779,5036,1)
(5181,5629,1)
(1764,111,1)
(2544,3215,1)
(2139,115,1)
(2233,7201,1)
(7110,1781,1)
(1378,2742,1)
(3621,700,1)
(4074,6689,1)
(2544,5935,1)
(4712,360,1)
(8260,2367,1)
(6511,6394,1)
(2210,1008,1)
(8592,4279,1)
(4032,6818,1)
(5704,5184,1)
(5225,697,1)
(3996,7368,1)
(2474,526,1)
(267,2112,1)
(9069,3451,1)
(7422,8997,1)
(1427,7299,1)
(491,9126,1)
(119,8391,1)
(6665,2151,1)
(605,6173,1)
(650,6592,1)
(4241,6385,1)
(2591,5219,1)
(5790,4725,1)
(1883,4586,1)
(146,8432,1)
(8592,115,1)
(6041,7360,1)
(6152,3233,1)
(4154,345,1)
(6376,7564,1)
(1595,1321,1)
(4270,4876,1)
(3674,7468,1)
(4022,6156,1)
(8169,2060,1)
(5349,5829,1)
(5454,1876,1)
(3659,8628,1)
(3213,1280,1)
(670,8691,1)
(5583,8526,1)
(6153,8513,1)
(2092,4824,1)
(6052,7727,1)
(2717,2495,1)
(2796,35,1)
(1591,7716,1)
(7289,628,1)
(6166,3188,1)
(4354,1686,1)
(3114,8391,1)
(7050,3294,1)
(5227,8391,1)
(8421,8391,1)
(4210,3649,1)
(6502,1474,1)
(2200,8194,1)
(3153,2901,1)
(2909,8077,1)
(4921,8883,1)
(8032,6102,1)
(6522,8391,1)
(3621,4149,1)
(1458,3999,1)
(1695,8955,1)
(24,4762,1)
(1415,2652,1)
(2937,8149,1)
(6746,4466,1)
(5805,3433,1)
(2607,1395,1)
(4056,5637,1)
(5141,2637,1)
(941,7350,1)
(8281,8457,1)
(1856,2891,1)
(9106,293,1)
(8502,6747,1)
(8555,1289,1)
(2032,7184,1)
(889,3755,1)
(4559,2937,1)
(8116,8534,1)
(7808,2391,1)
(1415,1269,1)
(7559,1041,1)
(5175,2244,1)
(3414,8571,1)
(4468,5829,1)
(1741,1916,1)
(1769,6619,1)
(1028,7590,1)
(46,4496,1)
(2053,6337,1)
(6071,7262,1)
(2183,8224,1)
(2456,3492,1)
(6439,348,1)
(6594,115,1)
(3822,5077,1)
(6080,2845,1)
(6040,311,1)
(8038,9130,1)
(1315,303,1)
(519,2459,1)
(6356,1523,1)
(937,489,1)
(6039,6128,1)
(3285,4877,1)
(7777,8014,1)
(3901,396,1)
(5340,5378,1)
(6625,8237,1)
(3211,2771,1)
(2518,4920,1)
(1712,4876,1)
(7381,3793,1)
(397,3931,1)
(966,133,1)
(2874,3124,1)
(6299,4266,1)
(5608,8420,1)
(7317,2713,1)
(7398,115,1)
(5695,2523,1)
(8040,3346,1)
(6220,115,1)
(5400,4953,1)
(7065,5648,1)
(1405,7900,1)
(5691,5676,1)
(7408,3621,1)
(6753,7411,1)
(2366,7332,1)
(2069,5156,1)
(608,7042,1)
(2653,1149,1)
(5283,4198,1)
(2561,146,1)
(4052,4381,1)
(5647,6145,1)
(8458,4138,1)
(500,2798,1)
(4505,8154,1)
(5108,4130,1)
(554,273,1)
(7544,1067,1)
(8257,7732,1)
(6076,2379,1)
(7216,1504,1)
(3223,1303,1)
(9090,115,1)
(5764,2881,1)
(4912,4001,1)
(3979,8774,1)
(8003,4705,1)
(5519,3325,1)
(7489,5038,1)
(7285,5362,1)
(8054,6052,1)
(1745,7592,1)
(1182,3556,1)
(4210,7703,1)
(5024,4027,1)
(388,493,1)
(7549,7427,1)
(5617,3382,1)
(3647,4689,1)
(1639,131,1)
(7200,574,1)
(7154,4276,1)
(255,8473,1)
(6000,8391,1)
(6236,8391,1)
(4526,3470,1)
(5584,8391,1)
(7085,115,1)
(7244,5692,1)
(6170,5260,1)
(425,9084,1)
(3526,115,1)
(3874,8500,1)
(6826,2540,1)
(7507,1709,1)
(8727,4754,1)
(4061,6742,1)
(4585,4010,1)
(589,4124,1)
(974,584,1)
(740,6257,1)
(9035,6797,1)
(7409,4057,1)
(5986,8556,1)
(3076,4676,1)
(1602,8391,1)
(7491,5346,1)
(6337,8100,1)
(8192,1222,1)
(7626,1158,1)
(3640,4431,1)
(4773,2648,1)
(4468,4132,1)
(7474,7348,1)
(4954,2852,1)
(1855,5772,1)
(174,7738,1)
(373,8775,1)
(3546,2215,1)
(760,4294,1)
(655,8391,1)
(1599,1957,1)
(4137,6481,1)
(7282,8680,1)
(7744,4802,1)
(6078,7354,1)
(2820,2794,1)
(8814,5655,1)
(4309,4876,1)
(1857,4876,1)
(2444,7327,1)
(8391,5025,1)
(4056,115,1)
(6598,3101,1)
(2790,7389,1)
(4907,2866,1)
(2685,404,1)
(5441,7321,1)
(1491,4012,1)
(1587,2519,1)
(5214,8458,1)
(6097,5829,1)
(8429,4353,1)
(2976,9015,1)
(1549,4206,1)
(5734,8294,1)
(2700,9032,1)
(2123,4720,1)
(1415,1412,1)
(8951,5197,1)
(7584,5490,1)
(1244,1401,1)
(8755,1091,1)
(299,5156,1)
(719,115,1)
(4404,3740,1)
(4996,6902,1)
(6784,4971,1)
(7648,8218,1)
(1968,8394,1)
(6002,2354,1)
(2207,6919,1)
(5709,2195,1)
(8481,7730,1)
(2082,9100,1)
(8994,1555,1)
(1146,6326,1)
(2867,1488,1)
(6159,4829,1)
(140,4938,1)
(7987,1070,1)
(6845,1174,1)
(6981,8028,1)
(8697,5156,1)
(1415,6710,1)
(7626,4350,1)
(580,3815,1)
(101,8391,1)
(7612,6886,1)
(3904,2375,1)
(5638,6563,1)
(4817,257,1)
(6762,4876,1)
(6411,2260,1)
(2651,6352,1)
(3806,5757,1)
(4745,7201,1)
(802,2470,1)
(1530,2701,1)
(6798,229,1)
(2959,4523,1)
(4770,1794,1)
(7805,2337,1)
(3884,1192,1)
(8402,6016,1)
(131,8744,1)
(5440,760,1)
(7244,7125,1)
(1127,3825,1)
(1184,1642,1)
(5117,115,1)
(909,8391,1)
(1365,6965,1)
(1723,6945,1)
(7873,5057,1)
(6100,5777,1)
(549,8176,1)
(1293,5346,1)
(7955,8035,1)
(5973,4071,1)
(7734,4204,1)
(8538,91,1)
(7197,26,1)
(5543,1001,1)
(8461,3989,1)
(3676,5048,1)
(3953,1548,1)
(8857,7952,1)
(1759,5046,1)
(2102,5501,1)
(5692,798,1)
(4167,5677,1)
(5702,3853,1)
(811,567,1)
(4971,4270,1)
(6201,6838,1)
(6202,2683,1)
(7572,1209,1)
(3170,5549,1)
(574,8008,1)
(7832,3236,1)
(3101,115,1)
(4565,5181,1)
(6080,5492,1)
(2450,1380,1)
(8550,8391,1)
(5056,115,1)
(4341,6972,1)
(8170,7480,1)
(4375,87,1)
(8735,8003,1)
(182,7055,1)
(1573,6661,1)
(3804,1158,1)
(1327,5678,1)
(8083,5601,1)
(1555,115,1)
(5516,75,1)
(4431,5865,1)
(3437,2518,1)
(3379,4626,1)
(4453,5614,1)
(874,1113,1)
(8580,1024,1)
(5001,8712,1)
(4941,3296,1)
(6916,6685,1)
(8745,3417,1)
(6534,1138,1)
(1121,836,1)
(2962,5045,1)
(3246,6890,1)
(6944,9020,1)
(6827,115,1)
(4277,5156,1)
(1907,8667,1)
(2746,7182,1)
(5144,8391,1)
(7377,6200,1)
(8160,4273,1)
(5931,208,1)
(8399,4404,1)
(2436,4273,1)
(1222,1966,1)
(3172,5841,1)
(2099,3621,1)
(5987,4593,1)
(4793,7888,1)
(6187,3830,1)
(7698,4226,1)
(2056,5,1)
(8875,819,1)
(5260,1578,1)
(2473,3280,1)
(2072,4058,1)
(5387,484,1)
(7670,5743,1)
(905,5951,1)
(689,1535,1)
(7306,115,1)
(4836,8391,1)
(4531,8854,1)
(1101,1857,1)
(8338,1236,1)
(969,5942,1)
(2517,6529,1)
(3823,2007,1)
(1809,3881,1)
(6246,115,1)
(8946,5052,1)
(776,1728,1)
(3929,5869,1)
(1334,725,1)
(2555,2158,1)
(741,6575,1)
(5892,6471,1)
(6208,6993,1)
(4516,471,1)
(1448,8428,1)
(3157,5105,1)
(2666,2886,1)
(2779,2199,1)
(8884,8391,1)
(6803,4082,1)
(8425,1648,1)
(7104,407,1)
(5064,9109,1)
(281,4574,1)
(6502,5494,1)
(8615,3095,1)
(6539,115,1)
(2051,1489,1)
(3521,4800,1)
(7538,3709,1)
(488,53,1)
(724,3451,1)
(3565,1508,1)
(584,1043,1)
(6921,646,1)
(5150,1138,1)
(8655,4228,1)
(309,8391,1)
(9135,1870,1)
(7244,5177,1)
(3003,213,1)
(670,850,1)
(4447,4558,1)
(1474,6649,1)
(1870,2432,1)
(6301,3980,1)
(2287,3657,1)
(6677,3553,1)
(2547,3487,1)
(1857,5156,1)
(373,1232,1)
(2777,7700,1)
(2629,7925,1)
(83,7077,1)
(5651,6551,1)
(4125,8852,1)
(1504,6948,1)
(8136,8391,1)
(1729,2942,1)
(3633,7551,1)
(5135,4980,1)
(7543,1485,1)
(4068,6956,1)
(4430,8392,1)
(7812,6084,1)
(481,2752,1)
(6637,5673,1)
(2167,8391,1)
(4125,2131,1)
(4999,3794,1)
(8096,8889,1)
(7349,8391,1)
(7426,9031,1)
(648,3538,1)
(6760,5479,1)
(6629,3976,1)
(8389,8444,1)
(8359,115,1)
(3905,1589,1)
(7271,486,1)
(4463,3532,1)
(3058,7396,1)
(6054,115,1)
(5310,4304,1)
(8142,2858,1)
(6419,7039,1)
(1172,2128,1)
(6778,3007,1)
(3078,115,1)
(7464,790,1)
(6420,4423,1)
(4375,2186,1)
(8291,1163,1)
(8126,8254,1)
(4873,2848,1)
(2070,6175,1)
(811,50,1)
(5494,9130,1)
(2943,9139,1)
(660,6086,1)
(4182,8785,1)
(8460,4701,1)
(8254,3483,1)
(3440,2580,1)
(5282,6625,1)
(6634,7275,1)
(4664,1488,1)
(7180,2168,1)
(7542,2892,1)
(7042,2959,1)
(8384,5030,1)
(8014,2154,1)
(512,8959,1)
(5851,3811,1)
(2589,4209,1)
(3366,701,1)
(8047,2859,1)
(2567,6581,1)
(5466,6826,1)
(7089,4847,1)
(2905,520,1)
(3056,1634,1)
(8766,7726,1)
(8728,4178,1)
(1732,2132,1)
(3902,1376,1)
(2487,5901,1)
(8639,1874,1)
(3759,7847,1)
(2060,2,1)
(2949,19,1)
(1369,4291,1)
(622,4741,1)
(489,2965,1)
(3659,807,1)
(1415,866,1)
(6502,5638,1)
(4415,1087,1)
(840,7625,1)
(6935,3199,1)
(7635,972,1)
(6449,2762,1)
(1353,8560,1)
(5544,746,1)
(7871,8391,1)
(1899,115,1)
(6638,2375,1)
(2679,1046,1)
(6836,1385,1)
(341,4414,1)
(5096,1299,1)
(5109,2427,1)
(1240,4818,1)
(5782,8252,1)
(4792,2625,1)
(3357,4683,1)
(7687,661,1)
(6395,5259,1)
(1415,2135,1)
(4227,6144,1)
(294,7384,1)
(916,1157,1)
(2649,7226,1)
(779,2833,1)
(2020,8184,1)
(7040,1065,1)
(4927,6908,1)
(1984,673,1)
(6407,8781,1)
(7762,6400,1)
(5800,7639,1)
(5275,2309,1)
(8060,5303,1)
(416,8391,1)
(8360,6382,1)
(8261,6954,1)
(1235,8712,1)
(2927,121,1)
(6317,115,1)
(665,2759,1)
(1536,4438,1)
(2401,2906,1)
(4316,2191,1)
(4247,5622,1)
(8038,4350,1)
(8046,1510,1)
(6134,6248,1)
(4043,2845,1)
(9107,8939,1)
(3539,8391,1)
(391,8391,1)
(761,9133,1)
(1848,8391,1)
(2167,1071,1)
(285,779,1)
(89,665,1)
(1054,115,1)
(7076,799,1)
(43,2723,1)
(5358,6473,1)
(141,6767,1)
(193,3800,1)
(1727,2845,1)
(5316,2520,1)
(5470,1128,1)
(7653,115,1)
(5245,1314,1)
(8473,3602,1)
(8322,4954,1)
(2007,5977,1)
(2993,8918,1)
(5226,783,1)
(3653,5318,1)
(7982,8391,1)
(9047,2331,1)
(3101,8391,1)
(5809,9130,1)
(4285,3192,1)
(2148,7258,1)
(4215,2429,1)
(6436,1627,1)
(3995,7845,1)
(8470,8391,1)
(8501,8391,1)
(409,5109,1)
(3197,7645,1)
(8055,8391,1)
(930,8391,1)
(7966,4515,1)
(1069,6018,1)
(9096,6776,1)
(1033,3688,1)
(8610,8391,1)
(1749,4560,1)
(3880,5280,1)
(8535,5137,1)
(8335,4490,1)
(7218,3531,1)
(4618,4991,1)
(7426,6434,1)
(5384,7767,1)
(1613,8313,1)
(1569,3932,1)
(1794,7611,1)
(2831,2166,1)
(4168,8391,1)
(7106,5825,1)
(2740,8754,1)
(2418,8443,1)
(7511,2826,1)
(4357,1146,1)
(1985,4692,1)
(4582,5003,1)
(5214,9130,1)
(704,2679,1)
(7633,1567,1)
(2648,275,1)
(7507,6135,1)
(4831,8623,1)
(2996,1810,1)
(5356,1234,1)
(2682,7810,1)
(2287,87,1)
(4019,1144,1)
(2788,8454,1)
(3184,2049,1)
(5265,6634,1)
(2817,2579,1)
(3804,8441,1)
(6107,4663,1)
(4625,8391,1)
(2950,403,1)
(8916,3165,1)
(3461,4,1)
(4885,8756,1)
(8331,7064,1)
(8561,3056,1)
(8577,5160,1)
(8098,6901,1)
(7975,4017,1)
(3209,3104,1)
(358,115,1)
(2390,8442,1)
(3939,7406,1)
(5447,863,1)
(5638,3215,1)
(7639,5862,1)
(6997,6931,1)
(324,6310,1)
(9118,8228,1)
(4070,8391,1)
(8306,5946,1)
(7762,8289,1)
(8043,5413,1)
(1001,8391,1)
(425,8391,1)
(1853,8391,1)
(6192,5948,1)
(4876,7022,1)
(852,8756,1)
(2117,8391,1)
(106,4640,1)
(7645,3650,1)
(2375,3180,1)
(7212,4478,1)
(6896,6464,1)
(3187,7982,1)
(5235,7014,1)
(1800,4726,1)
(2125,8866,1)
(3316,8582,1)
(7197,115,1)
(4745,647,1)
(5167,1616,1)
(5904,6524,1)
(6858,784,1)
(2239,115,1)
(5333,3064,1)
(6091,878,1)
(7493,1411,1)
(3986,1084,1)
(7743,2043,1)
(1478,115,1)
(6919,2520,1)
(2712,5206,1)
(8071,606,1)
(2884,4993,1)
(8918,4544,1)
(410,3592,1)
(552,5089,1)
(6848,8834,1)
(2423,4535,1)
(4231,11,1)
(7832,176,1)
(2544,3565,1)
(7668,4018,1)
(8362,2198,1)
(1755,1256,1)
(862,3621,1)
(4375,3193,1)
(3268,9136,1)
(5969,5957,1)
(1415,6388,1)
(6412,5829,1)
(2108,1664,1)
(617,3057,1)
(7696,4933,1)
(3315,883,1)
(2782,115,1)
(8398,1836,1)
(6803,5970,1)
(9005,4011,1)
(3801,6882,1)
(200,333,1)
(370,5892,1)
(2761,6348,1)
(2699,3838,1)
(3388,2800,1)
(6785,1863,1)
(3260,8046,1)
(6430,8391,1)
(8340,8391,1)
(5809,2112,1)
(5732,43,1)
(7017,8756,1)
(7112,8667,1)
(3623,3219,1)
(2225,4863,1)
(5818,8232,1)
(1189,9036,1)
(8448,2281,1)
(3799,5204,1)
(8870,114,1)
(619,7973,1)
(4601,6451,1)
(1810,3354,1)
(3907,6180,1)
(580,6833,1)
(7507,8281,1)
(8313,5112,1)
(8732,857,1)
(5906,4600,1)
(3142,7852,1)
(8561,8391,1)
(3625,8391,1)
(7436,4075,1)
(7598,1613,1)
(6304,4094,1)
(7028,6709,1)
(4426,8391,1)
(4628,3936,1)
(2576,748,1)
(845,1947,1)
(87,4501,1)
(3804,4350,1)
(293,8073,1)
(6218,4906,1)
(6499,5768,1)
(8593,5944,1)
(4211,13,1)
(5638,8021,1)
(7254,4989,1)
(2381,3405,1)
(1415,2681,1)
(4168,6343,1)
(2402,2552,1)
(5151,3080,1)
(8181,601,1)
(7111,6548,1)
(911,4674,1)
(652,6425,1)
(506,3886,1)
(2469,7034,1)
(3488,4579,1)
(5719,2845,1)
(6308,4208,1)
(595,3451,1)
(1389,4416,1)
(8954,2503,1)
(5181,1831,1)
(1682,4306,1)
(7433,6889,1)
(462,3476,1)
(3926,8777,1)
(3667,424,1)
(1567,3621,1)
(3717,8871,1)
(6683,5992,1)
(4963,678,1)
(7673,3299,1)
(3727,115,1)
(3354,2469,1)
(7653,8391,1)
(764,5698,1)
(5457,3435,1)
(2378,7773,1)
(2735,7291,1)
(7899,5586,1)
(2448,8933,1)
(7555,6915,1)
(8496,3281,1)
(4658,6369,1)
(5483,5829,1)
(8670,6060,1)
(1222,6777,1)
(9087,1488,1)
(6582,8108,1)
(9010,115,1)
(7553,8790,1)
(2952,8126,1)
(3229,4125,1)
(3279,1488,1)
(2206,7117,1)
(6822,591,1)
(3932,966,1)
(5326,3818,1)
(560,7577,1)
(1117,6830,1)
(5771,2043,1)
(4472,4876,1)
(6974,8873,1)
(7244,3598,1)
(903,4855,1)
(691,5187,1)
(8990,2536,1)
(2346,2158,1)
(1465,6861,1)
(4777,3200,1)
(475,4843,1)
(4549,3622,1)
(8341,1088,1)
(8614,7725,1)
(5363,8730,1)
(4758,8391,1)
(8089,3384,1)
(9047,8391,1)
(6678,8391,1)
(1783,4876,1)
(577,3591,1)
(529,4337,1)
(7637,1217,1)
(1884,6691,1)
(6623,8798,1)
(4153,8488,1)
(7654,5980,1)
(6139,8485,1)
(8318,801,1)
(4375,1270,1)
(7527,3103,1)
(6485,1488,1)
(1077,862,1)
(1106,8118,1)
(5035,4372,1)
(2765,3451,1)
(746,2139,1)
(8838,8391,1)
(5171,795,1)
(1781,4275,1)
(4413,6020,1)
(1152,7748,1)
(3530,8358,1)
(8254,8878,1)
(5856,2704,1)
(651,6119,1)
(4202,8447,1)
(6502,7966,1)
(965,8628,1)
(7244,8153,1)
(1415,3242,1)
(3509,8471,1)
(1754,3621,1)
(6576,9056,1)
(7626,7039,1)
(7595,115,1)
(952,6860,1)
(8082,8756,1)
(2958,5504,1)
(3347,8440,1)
(6992,2119,1)
(5593,3215,1)
(3367,7121,1)
(3399,1930,1)
(9068,1312,1)
(5036,5640,1)
(3403,2891,1)
(6759,160,1)
(3573,4515,1)
(4467,8035,1)
(2720,115,1)
(7205,1338,1)
(964,3801,1)
(4930,5683,1)
(4064,8549,1)
(8248,8430,1)
(30,4604,1)
(7672,511,1)
(1263,1203,1)
(1509,2367,1)
(6993,4522,1)
(5443,5635,1)
(5855,4636,1)
(5727,5407,1)
(5026,1125,1)
(3305,1586,1)
(5010,2036,1)
(8459,3140,1)
(2130,936,1)
(2059,1916,1)
(4689,4966,1)
(3115,6289,1)
(7138,6410,1)
(4375,4149,1)
(4091,1358,1)
(4838,1970,1)
(3885,3371,1)
(1085,8391,1)
(8706,4896,1)
(6125,8345,1)
(3867,1310,1)
(5494,6649,1)
(632,3450,1)
(3213,8111,1)
(3535,6796,1)
(7159,3451,1)
(9100,7323,1)
(7626,7280,1)
(2381,3451,1)
(581,6104,1)
(6907,1250,1)
(4455,2199,1)
(8328,8391,1)
(7215,4253,1)
(3804,700,1)
(6093,4916,1)
(7770,919,1)
(7484,3230,1)
(1053,3052,1)
(4525,696,1)
(8035,1622,1)
(6342,1220,1)
(581,6275,1)
(2785,8388,1)
(4974,5755,1)
(6877,3153,1)
(4420,4982,1)
(6072,1690,1)
(235,4522,1)
(110,4272,1)
(4769,3279,1)
(1749,177,1)
(1166,8391,1)
(4077,4223,1)
(8675,7841,1)
(108,3776,1)
(2171,115,1)
(345,115,1)
(3335,1488,1)
(409,4051,1)
(8227,1383,1)
(5435,7690,1)
(6533,4000,1)
(9066,1045,1)
(5864,8325,1)
(2166,7096,1)
(7389,6973,1)
(5874,115,1)
(9080,6971,1)
(8912,2839,1)
(8928,3613,1)
(6590,1545,1)
(6318,2845,1)
(7231,3646,1)
(8078,795,1)
(6279,2308,1)
(800,2080,1)
(5913,3973,1)
(177,8050,1)
(1894,8692,1)
(5776,2416,1)
(1153,2498,1)
(3831,2220,1)
(7768,1912,1)
(161,8391,1)
(7791,2006,1)
(1044,1343,1)
(5795,2845,1)
(6741,2043,1)
(175,6356,1)
(7765,2995,1)
(8432,8840,1)
(655,115,1)
(5079,5210,1)
(9050,6109,1)
(3101,7981,1)
(3831,7500,1)
(1561,9044,1)
(9050,3900,1)
(1369,4876,1)
(4545,7784,1)
(6736,8819,1)
(2079,8756,1)
(8841,3248,1)
(5997,8336,1)
(7128,1900,1)
(7611,1274,1)
(6884,1936,1)
(7856,808,1)
(6609,2845,1)
(5441,1296,1)
(7081,7105,1)
(299,3861,1)
(7196,3451,1)
(7956,911,1)
(4452,872,1)
(1415,929,1)
(4787,899,1)
(8668,3781,1)
(3121,852,1)
(8496,8391,1)
(8120,5599,1)
(7196,3621,1)
(6523,115,1)
(2548,2863,1)
(719,8391,1)
(929,263,1)
(2599,7980,1)
(7510,8391,1)
(6429,2845,1)
(5914,2043,1)
(2359,4650,1)
(5438,7999,1)
(4155,8391,1)
(3159,1932,1)
(5798,6336,1)
(8081,5442,1)
(5408,1419,1)
(8594,90,1)
(523,5262,1)
(8699,1730,1)
(4016,1685,1)
(8614,6649,1)
(4586,3338,1)
(8100,8789,1)
(3260,8391,1)
(8420,1898,1)
(4747,3780,1)
(1040,62,1)
(6823,3403,1)
(1304,7535,1)
(3761,1370,1)
(6639,2974,1)
(8479,3834,1)
(4552,3312,1)
(3620,4806,1)
(1679,8173,1)
(3396,7335,1)
(8835,614,1)
(2239,8016,1)
(7516,2387,1)
(2801,2453,1)
(4375,3565,1)
(4123,4604,1)
(8277,6274,1)
(7258,8132,1)
(2747,751,1)
(6070,3786,1)
(3126,353,1)
(5794,7583,1)
(1264,9058,1)
(6885,6936,1)
(734,7009,1)
(7396,3286,1)
(4375,6968,1)
(1685,1565,1)
(5494,8458,1)
(463,5787,1)
(4491,7931,1)
(4512,2557,1)
(2656,4567,1)
(4968,6928,1)
(7625,5616,1)
(6301,1770,1)
(3739,6783,1)
(1956,8297,1)
(1238,115,1)
(3334,3723,1)
(2111,3837,1)
(208,7081,1)
(4115,4313,1)
(8636,8527,1)
(1396,5543,1)
(1830,2030,1)
(5866,4024,1)
(7244,2356,1)
(6273,6353,1)
(4374,8697,1)
(3035,3402,1)
(2151,3473,1)
(7313,3416,1)
(6232,3032,1)
(3386,9026,1)
(6049,7541,1)
(7416,4245,1)
(5008,2733,1)
(1679,305,1)
(5977,2952,1)
(5322,1705,1)
(6230,651,1)
(8931,8728,1)
(1791,4534,1)
(5426,2106,1)
(7219,8578,1)
(1913,8587,1)
(7014,1766,1)
(8789,963,1)
(351,6919,1)
(7810,115,1)
(6713,4297,1)
(5052,4154,1)
(8623,2904,1)
(4327,5828,1)
(3300,115,1)
(111,5583,1)
(6077,4810,1)
(6190,8391,1)
(3742,8401,1)
(4678,4594,1)
(1771,7546,1)
(8031,8391,1)
(190,8857,1)
(993,5877,1)
(75,5533,1)
(1079,115,1)
(2035,104,1)
(8218,7405,1)
(7373,115,1)
(25,401,1)
(7626,4587,1)
(4584,1782,1)
(965,807,1)
(5513,6639,1)
(6065,4925,1)
(753,5650,1)
(2031,6467,1)
(6563,5920,1)
(2842,115,1)
(6064,5512,1)
(1931,115,1)
(3226,7271,1)
(2309,7163,1)
(763,176,1)
(9121,2369,1)
(5781,117,1)
(8178,339,1)
(3240,4769,1)
(2714,848,1)
(5355,115,1)
(5559,4888,1)
(7171,7135,1)
(2487,8391,1)
(7283,115,1)
(9112,218,1)
(6421,3999,1)
(7694,3927,1)
(3673,2845,1)
(7244,6761,1)
(4801,7783,1)
(3213,4149,1)
(6846,6933,1)
(1247,562,1)
(6150,1621,1)
(8500,788,1)
(6435,8391,1)
(8432,5983,1)
(3974,9005,1)
(973,6540,1)
(3116,1260,1)
(2237,7711,1)
(1100,1179,1)
(4059,4419,1)
(1022,8391,1)
(152,7210,1)
(7792,8837,1)
(1096,7488,1)
(7409,6292,1)
(7881,6649,1)
(8053,2587,1)
(8512,4915,1)
(4761,3439,1)
(6429,115,1)
(1065,115,1)
(3090,1420,1)
(6424,1392,1)
(459,1085,1)
(1280,8391,1)
(7041,7206,1)
(6435,6937,1)
(5912,8431,1)
(8068,3707,1)
(1406,3087,1)
(6419,8471,1)
(5206,7757,1)
(5578,3948,1)
(2287,8458,1)
(3039,6136,1)
(2049,2466,1)
(68,6176,1)
(4088,4745,1)
(6449,2845,1)
(8396,2295,1)
(7686,1427,1)
(8102,7541,1)
(1437,5373,1)
(5633,4173,1)
(2453,3748,1)
(6750,3071,1)
(2034,5457,1)
(498,8532,1)
(5683,8413,1)
(5999,6093,1)
(6115,5128,1)
(5970,6267,1)
(6979,3365,1)
(2375,4219,1)
(4150,2176,1)
(4880,2685,1)
(8364,3583,1)
(4532,7354,1)
(2410,5400,1)
(3797,7858,1)
(1206,2381,1)
(2544,1405,1)
(229,2835,1)
(7607,41,1)
(8548,7134,1)
(8099,5968,1)
(275,7843,1)
(3415,6726,1)
(1415,2096,1)
(8730,6286,1)
(3204,6433,1)
(422,5835,1)
(2350,3451,1)
(7103,856,1)
(2331,8240,1)
(5868,8074,1)
(8790,8391,1)
(1935,8990,1)
(4263,1539,1)
(5495,2352,1)
(7901,611,1)
(1144,482,1)
(8231,7463,1)
(7784,4614,1)
(6595,929,1)
(8666,2845,1)
(479,4865,1)
(203,4540,1)
(8826,8756,1)
(7650,2885,1)
(1044,8391,1)
(5414,115,1)
(4614,5194,1)
(5242,5945,1)
(3072,3693,1)
(4940,1719,1)
(2157,8391,1)
(882,6407,1)
(482,521,1)
(7890,2614,1)
(2287,4515,1)
(3773,1436,1)
(7348,2969,1)
(5020,3652,1)
(3831,3096,1)
(8314,2473,1)
(7537,2421,1)
(9119,115,1)
(7185,8271,1)
(6791,8084,1)
(8074,9129,1)
(7798,5156,1)
(5471,1124,1)
(669,2476,1)
(5958,6544,1)
(6479,3857,1)
(6355,1011,1)
(3443,3714,1)
(7781,684,1)
(6700,115,1)
(3051,860,1)
(3791,8391,1)
(4796,8608,1)
(1452,8391,1)
(8869,3408,1)
(7008,2577,1)
(4784,1182,1)
(454,2788,1)
(6069,6575,1)
(1518,3368,1)
(1220,2473,1)
(6627,7165,1)
(2582,4391,1)
(823,6972,1)
(8504,9037,1)
(8102,2888,1)
(1282,8268,1)
(1480,1891,1)
(7974,1149,1)
(5290,4876,1)
(6001,4761,1)
(139,5851,1)
(7139,7834,1)
(6903,4717,1)
(1121,8864,1)
(7097,4445,1)
(3619,1488,1)
(5865,2532,1)
(4970,8034,1)
(5439,7256,1)
(3695,7280,1)
(4858,7382,1)
(3779,3461,1)
(4118,6817,1)
(5801,6919,1)
(1425,190,1)
(8790,115,1)
(7259,8078,1)
(1416,3443,1)
(7226,6452,1)
(474,7242,1)
(2628,1349,1)
(4145,4149,1)
(1070,4429,1)
(8070,1488,1)
(5871,3633,1)
(3635,766,1)
(8833,8713,1)
(228,8843,1)
(4198,8950,1)
(1061,115,1)
(8827,1149,1)
(3501,4042,1)
(319,9035,1)
(3974,2210,1)
(5410,5745,1)
(8576,1657,1)
(5668,1466,1)
(7413,8610,1)
(2013,55,1)
(5157,7623,1)
(3286,8019,1)
(2074,1224,1)
(6194,7205,1)
(7893,8599,1)
(2443,5186,1)
(2246,3175,1)
(326,806,1)
(3621,8111,1)
(5337,8261,1)
(9071,2335,1)
(3866,4968,1)
(3930,5484,1)
(3045,1266,1)
(5292,3132,1)
(1502,1534,1)
(4098,7844,1)
(627,4150,1)
(2202,5712,1)
(5706,6375,1)
(1213,8391,1)
(1121,973,1)
(6314,2776,1)
(2137,7597,1)
(3752,989,1)
(5037,8974,1)
(4159,6196,1)
(4184,5192,1)
(3163,1718,1)
(5891,892,1)
(3949,1657,1)
(86,8756,1)
(8950,1798,1)
(7931,1653,1)
(6227,8421,1)
(3889,202,1)
(706,6575,1)
(2767,8350,1)
(6693,7077,1)
(5332,5913,1)
(4116,115,1)
(8401,3905,1)
(1710,6331,1)
(8,2452,1)
(4375,2497,1)
(880,8250,1)
(4372,415,1)
(3509,6649,1)
(4023,9086,1)
(4110,8546,1)
(7922,7049,1)
(7169,6459,1)
(2020,8143,1)
(8664,5728,1)
(4228,6577,1)
(493,7968,1)
(6589,4538,1)
(5876,299,1)
(5101,8720,1)
(3282,7758,1)
(6014,5049,1)
(6723,8391,1)
(7244,6764,1)
(6972,4876,1)
(1707,8391,1)
(1302,2585,1)
(6630,8807,1)
(8729,874,1)
(6689,5921,1)
(2775,8391,1)
(5740,5952,1)
(7561,115,1)
(1567,8391,1)
(3643,4747,1)
(3682,5295,1)
(1367,247,1)
(6419,3565,1)
(3904,747,1)
(3533,4054,1)
(339,8391,1)
(8508,5413,1)
(8119,1005,1)
(895,115,1)
(7508,150,1)
(7980,2309,1)
(3562,6894,1)
(3291,669,1)
(4493,7257,1)
(4012,2845,1)
(3136,1500,1)
(6073,3670,1)
(6502,5809,1)
(4943,8402,1)
(7330,6716,1)
(2249,7907,1)
(9064,8770,1)
(1429,6776,1)
(8233,3349,1)
(3059,3103,1)
(4051,2363,1)
(3070,5468,1)
(7244,3369,1)
(7362,6056,1)
(7966,1158,1)
(1319,588,1)
(6826,540,1)
(2488,885,1)
(1227,8391,1)
(4966,2729,1)
(6761,5208,1)
(1229,2537,1)
(6114,8171,1)
(4519,8380,1)
(6906,2710,1)
(6502,2287,1)
(1493,8144,1)
(1168,8391,1)
(7916,2104,1)
(53,3558,1)
(2370,4828,1)
(6605,3950,1)
(4220,671,1)
(7405,4586,1)
(7528,2497,1)
(4155,115,1)
(1324,4018,1)
(739,931,1)
(3356,7936,1)
(747,3050,1)
(3834,4876,1)
(7769,2622,1)
(3215,4529,1)
(5193,115,1)
(8117,1149,1)
(8567,5226,1)
(7012,1696,1)
(8844,4909,1)
(8379,5967,1)
(1830,8989,1)
(8016,8196,1)
(6655,3728,1)
(6981,2608,1)
(5638,4449,1)
(2959,4258,1)
(2731,5805,1)
(1878,115,1)
(951,6453,1)
(3598,4397,1)
(7060,7357,1)
(1069,777,1)
(5914,2884,1)
(4014,8279,1)
(1303,1452,1)
(507,163,1)
(3213,2112,1)
(4438,6221,1)
(7684,6008,1)
(2552,5359,1)
(1357,5227,1)
(3007,901,1)
(1326,115,1)
(7812,5875,1)
(5134,2722,1)
(9075,5217,1)
(5606,1943,1)
(2396,6538,1)
(2512,6082,1)
(7196,1307,1)
(6198,115,1)
(3457,2384,1)
(863,2314,1)
(8129,4088,1)
(7029,6080,1)
(7092,4061,1)
(3753,7352,1)
(5361,2783,1)
(6703,8391,1)
(7349,4033,1)
(5077,528,1)
(4375,700,1)
(2104,120,1)
(85,6663,1)
(3548,6980,1)
(4296,2129,1)
(871,4176,1)
(5336,1731,1)
(2149,1070,1)
(6319,3051,1)
(6560,7376,1)
(7214,6735,1)
(7471,5746,1)
(5048,6349,1)
(5680,7760,1)
(5712,3859,1)
(5638,3889,1)
(1293,8989,1)
(778,3326,1)
(3202,6786,1)
(1035,4833,1)
(4128,2663,1)
(5360,2020,1)
(6121,5156,1)
(6354,3103,1)
(9048,2280,1)
(6262,8372,1)
(5938,2296,1)
(5411,2801,1)
(2414,1794,1)
(1441,205,1)
(551,7526,1)
(8634,7487,1)
(8489,6139,1)
(1326,2845,1)
(3494,8452,1)
(7357,5725,1)
(2098,8288,1)
(478,1007,1)
(3594,7711,1)
(5868,5829,1)
(7807,4185,1)
(1705,257,1)
(1043,2522,1)
(2147,8391,1)
(6630,2516,1)
(1622,8455,1)
(4888,773,1)
(774,8391,1)
(5306,7471,1)
(1105,1779,1)
(4051,1829,1)
(1532,5516,1)
(3031,8903,1)
(2903,5447,1)
(3565,5099,1)
(6860,6170,1)
(2312,7358,1)
(4375,2955,1)
(4628,6308,1)
(6792,5430,1)
(2634,5585,1)
(4044,4034,1)
(5096,2678,1)
(4507,4957,1)
(1417,4443,1)
(2847,7829,1)
(7989,115,1)
(3320,4473,1)
(6311,3986,1)
(5069,265,1)
(7604,5606,1)
(7244,8212,1)
(7890,5156,1)
(7118,1608,1)
(7377,9098,1)
(4873,4515,1)
(5189,6045,1)
(4942,115,1)
(9015,9073,1)
(7357,8391,1)
(630,1685,1)
(8823,6368,1)
(8165,1023,1)
(7626,8021,1)
(2567,115,1)
(4283,9087,1)
(829,4310,1)
(7913,6455,1)
(7329,8471,1)
(1329,5189,1)
(2687,6649,1)
(4887,2298,1)
(4278,2915,1)
(2060,2044,1)
(3804,7625,1)
(7795,5776,1)
(4474,4420,1)
(5053,4289,1)
(4246,6606,1)
(724,3621,1)
(28,955,1)
(164,1935,1)
(4900,7923,1)
(1253,5940,1)
(6382,1570,1)
(7244,6323,1)
(4285,4571,1)
(6066,5497,1)
(789,1280,1)
(1980,5987,1)
(7966,3215,1)
(6181,8980,1)
(6123,1204,1)
(5002,4601,1)
(4527,7213,1)
(1125,4752,1)
(118,4619,1)
(5914,5829,1)
(5640,115,1)
(3582,1149,1)
(1455,5580,1)
(3258,2976,1)
(4126,3937,1)
(5006,5949,1)
(2042,4629,1)
(3608,5055,1)
(5852,514,1)
(5435,1150,1)
(8696,2333,1)
(4273,7632,1)
(7671,2136,1)
(914,4393,1)
(3781,3139,1)
(7829,7604,1)
(4087,5020,1)
(8802,115,1)
(4727,9048,1)
(2922,5408,1)
(6847,3440,1)
(4007,5455,1)
(5494,2112,1)
(271,5176,1)
(512,6058,1)
(8513,3099,1)
(7332,5785,1)
(759,5750,1)
(6419,700,1)
(2973,5408,1)
(2319,2709,1)
(3542,5304,1)
(8137,3304,1)
(4017,8130,1)
(6604,8255,1)
(9063,1488,1)
(5060,2772,1)
(8407,7180,1)
(8440,7943,1)
(2851,7887,1)
(560,6548,1)
(8225,7187,1)
(7190,4388,1)
(7322,5845,1)
(7417,4289,1)
(7374,6696,1)
(177,1784,1)
(5187,5420,1)
(3425,107,1)
(1187,6333,1)
(5298,4020,1)
(6485,7099,1)
(8187,8620,1)
(6176,5621,1)
(3557,9102,1)
(3463,4585,1)
(6801,904,1)
(5120,8144,1)
(1495,8552,1)
(9036,3624,1)
(5515,5847,1)
(5861,443,1)
(6976,1399,1)
(1881,8978,1)
(4089,2514,1)
(1388,4820,1)
(5274,4129,1)
(2262,3183,1)
(1152,115,1)
(8824,4189,1)
(7163,8244,1)
(7953,3014,1)
(1017,8677,1)
(8968,7570,1)
(5870,8031,1)
(6179,5916,1)
(2748,996,1)
(195,4976,1)
(7001,6815,1)
(2270,5290,1)
(1661,6708,1)
(6033,2521,1)
(5339,1142,1)
(9025,8072,1)
(5483,2043,1)
(2027,9049,1)
(5096,2894,1)
(7108,115,1)
(5234,5017,1)
(7182,8391,1)
(3911,1363,1)
(3804,9138,1)
(198,8182,1)
(2715,3746,1)
(7367,6134,1)
(6175,3863,1)
(8587,2591,1)
(1445,3809,1)
(963,8529,1)
(4704,1679,1)
(7509,5069,1)
(727,8391,1)
(407,3858,1)
(7969,115,1)
(5689,1859,1)
(1415,8471,1)
(1161,5285,1)
(5368,8857,1)
(3404,7238,1)
(7606,778,1)
(1400,423,1)
(693,4679,1)
(5166,6717,1)
(6857,6306,1)
(170,5471,1)
(7507,7320,1)
(5269,8476,1)
(3449,8206,1)
(4679,168,1)
(2813,99,1)
(2384,8391,1)
(3130,7711,1)
(7561,2845,1)
(241,8827,1)
(274,3102,1)
(2673,8181,1)
(6020,4819,1)
(5976,3154,1)
(6249,5659,1)
(593,5904,1)
(8945,6596,1)
(2809,7303,1)
(6144,8424,1)
(4437,3639,1)
(3076,8391,1)
(6254,8391,1)
(6700,8391,1)
(7888,2342,1)
(7487,870,1)
(6032,2366,1)
(3555,1783,1)
(4131,7711,1)
(5815,974,1)
(2912,3011,1)
(6869,2399,1)
(1355,8459,1)
(371,4990,1)
(7261,4483,1)
(3879,115,1)
(57,390,1)
(1111,8391,1)
(4375,8441,1)
(7191,4437,1)
(1666,5686,1)
(2788,3877,1)
(4537,4014,1)
(7780,211,1)
(6496,7930,1)
(5918,6535,1)
(7923,115,1)
(8593,2921,1)
(2761,4908,1)
(2196,1814,1)
(5287,9013,1)
(904,5515,1)
(3006,3544,1)
(1671,4392,1)
(7819,2813,1)
(5162,1491,1)
(743,4918,1)
(1773,1762,1)
(8523,6367,1)
(5261,7075,1)
(5678,7330,1)
(7152,1488,1)
(6512,5173,1)
(4972,2368,1)
(6538,876,1)
(8282,7069,1)
(2236,4591,1)
(5383,8391,1)
(5555,3190,1)
(7402,9132,1)
(3454,6959,1)
(636,5808,1)
(5721,2443,1)
(9106,115,1)
(3380,668,1)
(4561,1105,1)
(8837,2143,1)
(9069,5770,1)
(6194,6244,1)
(6777,1966,1)
(4129,4782,1)
(1267,108,1)
(3053,1678,1)
(4011,2461,1)
(7302,3187,1)
(2386,2043,1)
(1916,6725,1)
(5994,2398,1)
(6111,5885,1)
(8650,8320,1)
(1780,8648,1)
(8821,5713,1)
(8813,2555,1)
(7519,3114,1)
(5950,7972,1)
(7452,634,1)
(4177,7110,1)
(5230,5431,1)
(2504,5647,1)
(4435,2086,1)
(2024,8352,1)
(8038,6649,1)
(1825,1069,1)
(1293,3642,1)
(3571,8391,1)
(2788,7196,1)
(461,2832,1)
(3377,287,1)
(1538,6372,1)
(6539,8391,1)
(8273,8670,1)
(2047,6644,1)
(3918,1306,1)
(4611,9043,1)
(4436,419,1)
(8193,6504,1)
(541,2160,1)
(7863,8391,1)
(5861,4876,1)
(7833,5619,1)
(6597,8884,1)
(4134,4999,1)
(5638,8458,1)
(2763,8391,1)
(4610,1340,1)
(8073,3156,1)
(5629,394,1)
(6484,6133,1)
(7244,5154,1)
(3699,2489,1)
(6699,578,1)
(5204,7539,1)
(8686,871,1)
(6536,7759,1)
(8447,3907,1)
(690,1129,1)
(4038,7515,1)
(2510,2957,1)
(2651,6577,1)
(20,8006,1)
(7340,6656,1)
(4034,3451,1)
(2299,115,1)
(1181,930,1)
(3731,7595,1)
(7266,5617,1)
(5992,6076,1)
(7836,7065,1)
(4033,8634,1)
(631,2740,1)
(5795,115,1)
(3456,115,1)
(6679,5023,1)
(1659,291,1)
(4771,577,1)
(3878,4614,1)
(1478,2946,1)
(5342,8391,1)
(1393,5981,1)
(7067,2872,1)
(7352,8776,1)
(6058,8959,1)
(5499,2707,1)
(8758,6647,1)
(938,6897,1)
(3894,1782,1)
(2287,6968,1)
(8308,1997,1)
(3977,3628,1)
(9068,1149,1)
(968,6885,1)
(4937,5941,1)
(3460,5026,1)
(7233,6007,1)
(3522,5818,1)
(7479,3530,1)
(4222,1447,1)
(119,141,1)
(6438,5658,1)
(2538,115,1)
(2969,7365,1)
(4492,3307,1)
(4581,3807,1)
(6284,8111,1)
(3134,2196,1)
(1397,3958,1)
(4854,1907,1)
(499,9133,1)
(3417,2750,1)
(786,3753,1)
(3523,5887,1)
(5809,3565,1)
(132,4331,1)
(5162,1097,1)
(4906,8756,1)
(5468,7090,1)
(2573,7654,1)
(7251,8391,1)
(3971,3295,1)
(3426,8498,1)
(7764,8391,1)
(8064,6177,1)
(6209,2690,1)
(3008,2994,1)
(3267,4826,1)
(3889,5161,1)
(167,4368,1)
(4200,660,1)
(4728,2804,1)
(4428,8324,1)
(4299,5135,1)
(2181,1322,1)
(5799,7814,1)
(7377,1396,1)
(2591,8391,1)
(7595,2643,1)
(5072,2551,1)
(264,8128,1)
(4709,1127,1)
(4198,115,1)
(6419,4350,1)
(1243,8024,1)
(7156,5608,1)
(2287,3565,1)
(6473,4945,1)
(5599,1000,1)
(6783,1061,1)
(2935,5960,1)
(6446,3053,1)
(5811,3524,1)
(8961,1785,1)
(8386,713,1)
(7931,1430,1)
(4375,6649,1)
(8034,1930,1)
(4550,3586,1)
(8641,942,1)
(9060,2102,1)
(7603,7801,1)
(6614,3595,1)
(709,1975,1)
(3314,8191,1)
(2447,8581,1)
(155,7711,1)
(8816,12,1)
(3806,4183,1)
(5149,226,1)
(1516,8299,1)
(2150,5595,1)
(6522,2845,1)
(7711,3335,1)
(3888,1777,1)
(5464,6881,1)
(4830,162,1)
(5630,2332,1)
(8501,115,1)
(3716,4962,1)
(6502,2981,1)
(5349,3383,1)
(4597,8113,1)
(1769,8391,1)
(8695,378,1)
(7452,1985,1)
(7078,3382,1)
(4840,8391,1)
(7982,5923,1)
(6881,5156,1)
(3581,6516,1)
(3005,7426,1)
(610,8391,1)
(6416,8662,1)
(7137,6029,1)
(8790,2289,1)
(6867,4253,1)
(5964,4264,1)
(7647,260,1)
(4879,2610,1)
(6440,8621,1)
(2031,3251,1)
(3152,7477,1)
(8088,115,1)
(4663,415,1)
(7630,7653,1)
(5700,4314,1)
(102,4283,1)
(4626,8002,1)
(7980,3451,1)
(5236,4892,1)
(4201,2385,1)
(6493,2136,1)
(5364,241,1)
(3615,7212,1)
(3852,1116,1)
(5029,9002,1)
(4588,4677,1)
(3630,7800,1)
(5836,3445,1)
(3804,6563,1)
(1501,995,1)
(4375,4515,1)
(5593,4515,1)
(4501,6506,1)
(356,7318,1)
(2834,8749,1)
(2035,7718,1)
(4679,1102,1)
(7963,2698,1)
(4358,4292,1)
(1863,6159,1)
(800,8391,1)
(1297,5152,1)
(7304,6527,1)
(3543,8646,1)
(3509,3215,1)
(2287,929,1)
(8693,7553,1)
(8750,4430,1)
(6023,8391,1)
(4300,6883,1)
(5351,1470,1)
(7533,7369,1)
(762,7456,1)
(4569,4140,1)
(8992,8756,1)
(2416,5973,1)
(5863,1543,1)
(3520,1123,1)
(7516,8391,1)
(1451,5971,1)
(3673,8015,1)
(2862,2016,1)
(1779,115,1)
(1231,115,1)
(1008,5884,1)
(3649,1003,1)
(5708,7886,1)
(1931,8391,1)
(4591,6673,1)
(5085,9064,1)
(6986,1208,1)
(8404,3201,1)
(2570,4647,1)
(6881,1624,1)
(2646,6155,1)
(2265,2043,1)
(6284,2112,1)
(7244,7612,1)
(3868,8391,1)
(7572,2130,1)
(1785,8318,1)
(8135,4708,1)
(5208,1040,1)
(8112,8393,1)
(8354,2721,1)
(1350,8242,1)
(7772,6071,1)
(7168,8766,1)
(2546,3419,1)
(4343,5368,1)
(3948,6545,1)
(7186,8663,1)
(7244,1722,1)
(5402,115,1)
(1072,8374,1)
(8191,2652,1)
(4590,3906,1)
(7431,3664,1)
(7573,4648,1)
(3195,7068,1)
(5425,548,1)
(7530,4664,1)
(3730,8391,1)
(2987,3318,1)
(3086,6824,1)
(8969,8236,1)
(7127,1873,1)
(5594,976,1)
(1431,6322,1)
(1221,2920,1)
(8858,4666,1)
(4934,6208,1)
(2505,8391,1)
(2217,115,1)
(3416,6655,1)
(2834,1987,1)
(8927,3884,1)
(4583,2815,1)
(5953,1973,1)
(1082,115,1)
(6811,1871,1)
(2814,1927,1)
(5963,8298,1)
(1418,5829,1)
(4431,115,1)
(7244,5517,1)
(1498,7143,1)
(3847,1112,1)
(3621,3889,1)
(3280,8051,1)
(652,3142,1)
(5305,3945,1)
(8642,3891,1)
(225,4631,1)
(4034,8391,1)
(258,5519,1)
(1637,4016,1)
(4649,2638,1)
(7738,6337,1)
(5608,777,1)
(7318,7197,1)
(5907,4565,1)
(8726,6206,1)
(8890,5532,1)
(2287,5452,1)
(6900,8825,1)
(9001,1286,1)
(5018,928,1)
(9122,6963,1)
(3764,1896,1)
(5743,64,1)
(8214,4984,1)
(438,5852,1)
(2160,9118,1)
(2265,5829,1)
(7045,6832,1)
(972,1231,1)
(710,8850,1)
(6509,1980,1)
(2151,8391,1)
(8844,4066,1)
(2938,8391,1)
(7652,3419,1)
(2948,3632,1)
(4632,3458,1)
(5545,7146,1)
(8970,7638,1)
(8321,3174,1)
(4782,6472,1)
(2014,8415,1)
(7129,6923,1)
(8061,4510,1)
(2814,115,1)
(3118,7513,1)
(5806,6285,1)
(2289,6840,1)
(7271,1418,1)
(2069,2892,1)
(1322,8391,1)
(37,4091,1)
(8712,707,1)
(6529,8057,1)
(7525,8898,1)
(8820,5642,1)
(1965,5833,1)
(8039,4422,1)
(5719,8391,1)
(2374,1325,1)
(366,6970,1)
(5056,3745,1)
(1820,5229,1)
(6751,5817,1)
(8796,8147,1)
(2754,244,1)
(1722,8756,1)
(7973,4468,1)
(410,4,1)
(23,3278,1)
(4355,8101,1)
(2111,2350,1)
(8731,1373,1)
(3803,549,1)
(876,5795,1)
(6971,7493,1)
(7966,3889,1)
(1104,2997,1)
(3236,5012,1)
(3777,3477,1)
(576,4482,1)
(1689,6638,1)
(3161,8358,1)
(3340,4070,1)
(6747,8889,1)
(2389,8600,1)
(1939,1382,1)
(2487,2845,1)
(4108,1149,1)
(4497,8391,1)
(2467,115,1)
(2514,1812,1)
(4348,6070,1)
(2416,8768,1)
(8804,7828,1)
(1102,4861,1)
(3814,4641,1)
(8029,4842,1)
(6219,2303,1)
(4945,1765,1)
(6423,5074,1)
(4429,6122,1)
(4057,4405,1)
(8030,1149,1)
(5047,8070,1)
(6685,2190,1)
(3551,5656,1)
(3062,115,1)
(6907,3606,1)
(637,3323,1)
(7919,2444,1)
(4277,4603,1)
(779,5431,1)
(6191,3390,1)
(8694,7129,1)
(6989,2515,1)
(5402,3085,1)
(8697,3922,1)
(4410,8929,1)
(930,115,1)
(6939,296,1)
(7760,4927,1)
(5642,3120,1)
(8131,2270,1)
(4090,8029,1)
(8356,8845,1)
(1000,1745,1)
(5217,2806,1)
(5638,1280,1)
(698,6524,1)
(0,1719,1)
(3858,8496,1)
(6233,5155,1)
(8610,2893,1)
(4375,8458,1)
(6553,2745,1)
(2155,307,1)
(2212,8821,1)
(6620,115,1)
(5514,8756,1)
(7301,1883,1)
(8439,4441,1)
(501,960,1)
(7063,8391,1)
(2970,8894,1)
(6440,9127,1)
(1699,2935,1)
(2029,2371,1)
(7350,3449,1)
(2620,4126,1)
(5521,5986,1)
(7066,1891,1)
(2659,8217,1)
(4703,4947,1)
(3621,1158,1)
(7569,3059,1)
(4253,2303,1)
(8599,214,1)
(1029,7711,1)
(155,3686,1)
(2037,2477,1)
(6506,4584,1)
(4959,5705,1)
(3213,9130,1)
(7244,8809,1)
(5156,4403,1)
(1946,207,1)
(6858,4102,1)
(7097,2896,1)
(2544,9130,1)
(6510,4666,1)
(7117,1526,1)
(2287,1261,1)
(8777,9062,1)
(6661,1240,1)
(125,1143,1)
(6003,6731,1)
(4205,5950,1)
(2273,2343,1)
(5681,6351,1)
(5960,3505,1)
(6516,292,1)
(8106,8787,1)
(779,8977,1)
(2683,115,1)
(7446,8580,1)
(833,4932,1)
(1834,5513,1)
(7626,6649,1)
(6377,2966,1)
(1058,803,1)
(8055,6427,1)
(2160,115,1)
(4976,4665,1)
(5449,1226,1)
(5705,115,1)
(5399,966,1)
(466,4450,1)
(5916,6097,1)
(5549,504,1)
(5402,8391,1)
(2494,722,1)
(5271,2135,1)
(7351,1287,1)
(2658,3974,1)
(8142,1410,1)
(3175,3429,1)
(3804,4524,1)
(766,5990,1)
(1363,115,1)
(5067,2066,1)
(8938,6370,1)
(3478,4801,1)
(4496,4190,1)
(6968,379,1)
(6995,1799,1)
(1892,3820,1)
(6454,8391,1)
(7626,3565,1)
(6064,4445,1)
(3385,6309,1)
(2942,1590,1)
(46,4190,1)
(1462,2845,1)
(3634,6429,1)
(9019,8391,1)
(4623,7839,1)
(2187,7674,1)
(3595,1488,1)
(2662,193,1)
(3772,3204,1)
(6414,1388,1)
(7627,5124,1)
(7462,1533,1)
(2842,8557,1)
(5362,239,1)
(8090,5489,1)
(2211,542,1)
(3588,2383,1)
(3797,312,1)
(3242,4187,1)
(5355,8391,1)
(2782,8391,1)
(5494,4587,1)
(9004,8391,1)
(2840,2672,1)
(2104,5526,1)
(7390,6994,1)
(4734,1904,1)
(5233,4921,1)
(1865,7869,1)
(1219,8405,1)
(7748,5714,1)
(741,5512,1)
(4920,9134,1)
(8517,4201,1)
(2553,685,1)
(6912,2909,1)
(2826,1865,1)
(8857,5196,1)
(8238,1149,1)
(8540,8116,1)
(7638,2437,1)
(855,1072,1)
(1605,8068,1)
(202,598,1)
(8296,8847,1)
(5337,7316,1)
(522,2031,1)
(6224,3359,1)
(7935,6255,1)
(5286,8463,1)
(8370,2954,1)
(1039,7871,1)
(1376,8259,1)
(2802,7509,1)
(5653,507,1)
(7369,4838,1)
(4732,7546,1)
(1902,4247,1)
(6704,3485,1)
(4835,7833,1)
(3079,5491,1)
(8935,7058,1)
(8159,8022,1)
(142,5666,1)
(6500,4625,1)
(3396,7210,1)
(5556,5386,1)
(2191,3477,1)
(3213,6848,1)
(4375,5366,1)
(5708,5346,1)
(9044,2860,1)
(3789,8174,1)
(4253,7888,1)
(1726,1153,1)
(7639,5774,1)
(6571,4055,1)
(5434,4109,1)
(254,1255,1)
(2518,8626,1)
(6288,1081,1)
(703,2526,1)
(6717,8645,1)
(466,2934,1)
(8849,115,1)
(4440,1776,1)
(895,8391,1)
(1701,3003,1)
(7307,5783,1)
(391,3621,1)
(2424,115,1)
(2326,1302,1)
(4242,1109,1)
(3804,2681,1)
(1150,2452,1)
(3046,1276,1)
(5983,6577,1)
(4965,7693,1)
(1003,3680,1)
(3080,1145,1)
(8500,8391,1)
(1266,1048,1)
(6294,5991,1)
(7626,6968,1)
(1345,6569,1)
(357,620,1)
(3427,3224,1)
(7886,1505,1)
(1877,542,1)
(2787,4734,1)
(5185,3320,1)
(7022,700,1)
(416,1439,1)
(8038,8111,1)
(4043,8391,1)
(4409,4057,1)
(6080,115,1)
(436,7359,1)
(7870,9001,1)
(1134,7054,1)
(8663,5898,1)
(2743,96,1)
(228,727,1)
(7797,8296,1)
(595,3621,1)
(8820,115,1)
(7018,7765,1)
(8872,2492,1)
(6137,3773,1)
(3895,4474,1)
(5437,5012,1)
(324,6738,1)
(9070,3604,1)
(1892,3245,1)
(8419,115,1)
(8903,175,1)
(5943,4396,1)
(8806,3194,1)
(1184,8994,1)
(5722,1853,1)
(8783,3873,1)
(5902,2573,1)
(219,115,1)
(7392,2299,1)
(1852,3442,1)
(6539,3520,1)
(2892,4281,1)
(6285,6692,1)
(558,1463,1)
(8379,5156,1)
(6922,3269,1)
(5677,2206,1)
(3940,115,1)
(772,1130,1)
(8002,5588,1)
(5649,1520,1)
(4337,3839,1)
(1266,5829,1)
(3528,4513,1)
(4169,7200,1)
(4020,7087,1)
(2502,2256,1)
(1040,3874,1)
(781,1952,1)
(8707,5251,1)
(4844,6571,1)
(4647,8391,1)
(8541,7927,1)
(2099,8391,1)
(2191,3777,1)
(5009,1173,1)
(4351,2642,1)
(6214,6688,1)
(1617,1493,1)
(8506,5476,1)
(8342,667,1)
(4570,8659,1)
(8772,4179,1)
(5880,7656,1)
(3806,8546,1)
(6282,4312,1)
(2290,4487,1)
(8808,9027,1)
(4295,3552,1)
(1733,2991,1)
(474,1266,1)
(406,1060,1)
(6664,1149,1)
(5452,5826,1)
(2288,140,1)
(8038,1280,1)
(3893,7377,1)
(3800,8285,1)
(8272,3864,1)
(644,8391,1)
(1727,115,1)
(3295,4607,1)
(3829,5029,1)
(1213,4902,1)
(265,3329,1)
(5501,4723,1)
(1198,122,1)
(4391,2999,1)
(8376,4939,1)
(8380,4248,1)
(7221,5915,1)
(227,7386,1)
(3262,5907,1)
(6635,518,1)
(7946,9017,1)
(3947,2692,1)
(3812,1858,1)
(660,5829,1)
(2810,6749,1)
(8883,2449,1)
(7244,6065,1)
(1598,3220,1)
(669,3850,1)
(4000,8450,1)
(6830,8920,1)
(8335,1582,1)
(6483,6900,1)
(6309,2644,1)
(3848,3653,1)
(4311,5604,1)
(7240,290,1)
(4494,8391,1)
(6956,6494,1)
(1586,4764,1)
(6034,173,1)
(3774,8391,1)
(1452,115,1)
(3509,1158,1)
(2803,3268,1)
(2047,7486,1)
(1685,6762,1)
(1351,5998,1)
(2853,2034,1)
(1218,2400,1)
(8007,6360,1)
(3401,2630,1)
(3673,8391,1)
(1013,8741,1)
(3496,8907,1)
(7038,8391,1)
(4416,5810,1)
(5919,480,1)
(7408,9059,1)
(440,4929,1)
(2226,8226,1)
(6236,1733,1)
(5679,181,1)
(795,115,1)
(8092,5999,1)
(7649,7589,1)
(7584,3934,1)
(7143,8251,1)
(2288,8391,1)
(2693,8478,1)
(3531,7127,1)
(6161,7440,1)
(154,3586,1)
(1561,5765,1)
(7515,1075,1)
(2868,8436,1)
(4549,8391,1)
(3231,8366,1)
(8318,6445,1)
(5674,2781,1)
(350,8507,1)
(1691,964,1)
(3655,243,1)
(6000,115,1)
(3962,8321,1)
(3618,6911,1)
(6657,4463,1)
(5214,3889,1)
(1248,5571,1)
(7248,988,1)
(6620,8391,1)
(7451,7459,1)
(4191,3423,1)
(1548,937,1)
(6742,5037,1)
(3794,7614,1)
(4814,8391,1)
(7201,5381,1)
(1415,1405,1)
(2981,6649,1)
(3020,7263,1)
(2199,6565,1)
(238,3810,1)
(7244,2338,1)
(1413,8391,1)
(7917,411,1)
(4413,4876,1)
(156,8756,1)
(3738,1453,1)
(7646,8391,1)
(8432,5577,1)
(2947,4556,1)
(6827,8391,1)
(6975,8364,1)
(1611,7230,1)
(1983,1875,1)
(617,115,1)
(8141,2024,1)
(8932,942,1)
(8276,8415,1)
(1019,2894,1)
(6673,6575,1)
(4375,8471,1)
(3828,8391,1)
(7432,8391,1)
(3577,895,1)
(8528,661,1)
(7209,5577,1)
(1434,468,1)
(8172,2040,1)
(743,3756,1)
(5201,802,1)
(1387,115,1)
(8047,4722,1)
(6103,6526,1)
(1850,8677,1)
(4078,1173,1)
(1370,4351,1)
(5310,670,1)
(6067,115,1)
(2925,6160,1)
(60,714,1)
(3706,1830,1)
(379,777,1)
(7368,9077,1)
(6568,3638,1)
(7880,115,1)
(2680,2592,1)
(2671,6361,1)
(2009,6023,1)
(5413,5345,1)
(4209,4160,1)
(2948,8777,1)
(7611,6874,1)
(4087,8391,1)
(617,8391,1)
(7536,115,1)
(8009,8391,1)
(2878,5997,1)
(8975,4400,1)
(2396,447,1)
(6047,8146,1)
(2085,7503,1)
(5094,2009,1)
(9034,8307,1)
(7931,3295,1)
(5082,1364,1)
(4239,5975,1)
(6580,914,1)
(411,7912,1)
(8546,4673,1)
(7951,5244,1)
(975,3135,1)
(5359,8870,1)
(2218,2928,1)
(2719,1397,1)
(272,2879,1)
(536,5949,1)
(9010,2845,1)
(3278,3979,1)
(5369,2845,1)
(7156,4511,1)
(301,1488,1)
(4472,7835,1)
(8167,4494,1)
(2961,5559,1)
(7646,5589,1)
(6993,7888,1)
(6820,2975,1)
(5732,2930,1)
(6880,4095,1)
(5701,2558,1)
(1077,8249,1)
(3238,2639,1)
(1860,1305,1)
(8301,8965,1)
(1392,8391,1)
(5720,2616,1)
(7578,6668,1)
(4828,115,1)
(1311,2831,1)
(1871,4355,1)
(5577,2811,1)
(2616,2433,1)
(6428,883,1)
(5160,85,1)
(7007,5790,1)
(8244,3866,1)
(7281,7113,1)
(3876,8896,1)
(9029,3131,1)
(8926,1360,1)
(8692,5406,1)
(158,8391,1)
(6823,1459,1)
(2789,9010,1)
(613,6070,1)
(5428,1337,1)
(4193,4602,1)
(4375,7625,1)
(8436,3031,1)
(2205,6316,1)
(7841,859,1)
(5191,8733,1)
(3254,115,1)
(3471,7832,1)
(7463,301,1)
(8830,8391,1)
(7626,8471,1)
(6146,3240,1)
(1157,3833,1)
(8153,2682,1)
(8805,8205,1)
(4471,1013,1)
(7962,993,1)
(3186,5670,1)
(1769,115,1)
(2500,1301,1)
(3411,5815,1)
(9009,5922,1)
(3289,5146,1)
(4055,6926,1)
(4375,929,1)
(4267,7020,1)
(2610,3052,1)
(8997,6174,1)
(5032,7921,1)
(983,6976,1)
(8704,7633,1)
(8779,5867,1)
(5176,8832,1)
(1269,1033,1)
(8042,8643,1)
(7255,5685,1)
(4859,2586,1)
(4392,4040,1)
(3621,3215,1)
(1415,502,1)
(4736,352,1)
(517,6949,1)
(7846,7590,1)
(1582,7813,1)
(2459,8339,1)
(3780,6068,1)
(6277,1083,1)
(6241,1086,1)
(3621,1280,1)
(2297,906,1)
(4983,7666,1)
(6651,6690,1)
(7427,4952,1)
(9084,8086,1)
(6957,1512,1)
(3740,115,1)
(8094,7344,1)
(7667,8295,1)
(7408,3357,1)
(4741,6378,1)
(7541,8103,1)
(8115,3827,1)
(8038,7280,1)
(7634,847,1)
(5398,1658,1)
(2287,1270,1)
(4282,4182,1)
(2988,1645,1)
(3757,202,1)
(1610,4767,1)
(921,2845,1)
(4375,6435,1)
(6843,4983,1)
(3959,7808,1)
(6001,3439,1)
(6360,8391,1)
(859,8686,1)
(6514,2653,1)
(1629,4874,1)
(7525,8391,1)
(8886,7897,1)
(816,6411,1)
(8822,8464,1)
(8340,115,1)
(6545,1788,1)
(4469,4365,1)
(8713,115,1)
(8083,1062,1)
(3837,8391,1)
(1697,4383,1)
(1415,2065,1)
(1649,368,1)
(452,8816,1)
(1381,1844,1)
(5967,79,1)
(358,8772,1)
(8348,115,1)
(8685,5688,1)
(3235,6617,1)
(2917,5392,1)
(4620,4682,1)
(7536,1316,1)
(5913,4265,1)
(119,115,1)
(4053,2731,1)
(1312,167,1)
(5813,8391,1)
(2544,8021,1)
(4994,3452,1)
(5117,8391,1)
(5420,6865,1)
(5214,2182,1)
(2615,8756,1)
(6585,8166,1)
(6881,6376,1)
(5314,3963,1)
(8365,5128,1)
(3067,8391,1)
(4821,8391,1)
(353,357,1)
(5412,3218,1)
(7715,7917,1)
(1673,3479,1)
(3958,4285,1)
(2534,4456,1)
(9018,1759,1)
(6278,245,1)
(5593,9130,1)
(296,4127,1)
(5709,575,1)
(86,5931,1)
(3906,771,1)
(8204,5268,1)
(1126,6177,1)
(7874,903,1)
(3940,8904,1)
(2229,2940,1)
(4877,968,1)
(5572,6220,1)
(4697,6202,1)
(4772,6252,1)
(3781,4165,1)
(4692,5249,1)
(1807,2216,1)
(7343,5564,1)
(7244,7601,1)
(6554,5507,1)
(40,3724,1)
(5638,6968,1)
(572,6542,1)
(4899,5373,1)
(5095,7739,1)
(4221,8655,1)
(1680,3340,1)
(3430,115,1)
(4560,2004,1)
(1544,8449,1)
(2287,8111,1)
(7384,3184,1)
(3891,3924,1)
(4473,5496,1)
(2520,6194,1)
(8274,88,1)
(4050,1604,1)
(1817,6981,1)
(4977,9028,1)
(2588,3277,1)
(4516,4900,1)
(2287,6649,1)
(6097,2043,1)
(82,8131,1)
(914,5156,1)
(5748,3038,1)
(4768,2272,1)
(3171,6049,1)
(2821,8531,1)
(8618,4256,1)
(946,5396,1)
(3462,4681,1)
(7244,7697,1)
(6451,8391,1)
(284,2640,1)
(166,3516,1)
(5343,4911,1)
(8521,2259,1)
(6434,1259,1)
(391,3451,1)
(7966,7039,1)
(5820,1724,1)
(510,1972,1)
(2238,4119,1)
(3526,8391,1)
(284,2947,1)
(3059,2951,1)
(213,2189,1)
(4656,2983,1)
(7411,8391,1)
(2177,8087,1)
(2260,6916,1)
(3920,7460,1)
(1419,3543,1)
(7217,8119,1)
(2373,1974,1)
(6592,1136,1)
(356,834,1)
(2692,4506,1)
(6611,115,1)
(1415,5375,1)
(784,5633,1)
(2567,8391,1)
(8913,3344,1)
(7312,1310,1)
(6372,8642,1)
(6142,3023,1)
(2139,3432,1)
(1119,1096,1)
(614,2234,1)
(5703,510,1)
(5638,1262,1)
(2752,5930,1)
(8274,4730,1)
(7643,8588,1)
(5209,115,1)
(6889,115,1)
(3061,9028,1)
(5979,534,1)
(989,115,1)
(2117,6721,1)
(8529,2632,1)
(6662,2874,1)
(2711,1702,1)
(846,8859,1)
(661,4043,1)
(1296,2317,1)
(8416,71,1)
(1530,1744,1)
(6055,4859,1)
(5851,5491,1)
(6486,3584,1)
(8038,8458,1)
(2069,4876,1)
(2677,432,1)
(4182,2043,1)
(6719,9115,1)
(5515,4311,1)
(80,4037,1)
(1779,8391,1)
(7069,2231,1)
(8050,3797,1)
(7244,1820,1)
(1045,115,1)
(1380,115,1)
(2490,7733,1)
(5952,8755,1)
(1973,7782,1)
(4659,4397,1)
(7211,7375,1)
(1835,6565,1)
(5639,4709,1)
(8987,710,1)
(2613,8416,1)
(6207,7868,1)
(3909,3812,1)
(8019,5458,1)
(850,7942,1)
(5087,379,1)
(1547,2766,1)
(3050,2043,1)
(3353,1681,1)
(3036,6891,1)
(6220,8391,1)
(6265,1273,1)
(3997,8329,1)
(179,7826,1)
(4375,6474,1)
(6352,3259,1)
(2941,5445,1)
(7700,570,1)
(8037,5089,1)
(6321,5863,1)
(1087,1036,1)
(7514,4434,1)
(6594,7855,1)
(1921,6629,1)
(4628,4053,1)
(3439,6703,1)
(3688,7762,1)
(4023,206,1)
(8829,4321,1)
(7175,3025,1)
(6315,6479,1)
(3804,6968,1)
(1626,8698,1)
(1560,577,1)
(3544,8982,1)
(1567,3451,1)
(7961,3706,1)
(1231,7867,1)
(682,3031,1)
(5166,5238,1)
(4190,7969,1)
(5709,7965,1)
(6111,2845,1)
(8500,115,1)
(424,3451,1)
(934,3597,1)
(8531,115,1)
(4628,5382,1)
(3804,4515,1)
(1128,5103,1)
(2160,8391,1)
(2872,5095,1)
(7977,4383,1)
(6985,8141,1)
(7119,6334,1)
(3957,5566,1)
(3001,8391,1)
(8492,4897,1)
(8664,8391,1)
(3509,8650,1)
(4219,1646,1)
(6763,2513,1)
(3207,8391,1)
(6951,6390,1)
(3821,2755,1)
(2151,115,1)
(7257,8399,1)
(2044,7408,1)
(965,4521,1)
(7816,6611,1)
(3519,8956,1)
(7677,6598,1)
(2445,7119,1)
(6043,2646,1)
(3545,687,1)
(3719,7383,1)
(2859,4224,1)
(6664,1594,1)
(5809,4587,1)
(7244,5529,1)
(996,58,1)
(7405,6081,1)
(5748,115,1)
(9042,4555,1)
(4375,148,1)
(3752,2777,1)
(3923,8435,1)
(8785,1721,1)
(955,4876,1)
(2493,6503,1)
(8038,700,1)
(7078,1406,1)
(5182,5142,1)
(8027,7945,1)
(2827,1991,1)
(6086,5278,1)
(2657,115,1)
(2430,1501,1)
(3804,3889,1)
(2254,9125,1)
(3842,1637,1)
(5584,5794,1)
(4352,5953,1)
(8371,7133,1)
(4714,8213,1)
(4852,6043,1)
(1005,824,1)
(8715,8795,1)
(1526,6884,1)
(4224,6759,1)
(8043,8190,1)
(6619,4778,1)
(4665,8369,1)
(3218,2547,1)
(2900,8419,1)
(2697,8244,1)
(2553,348,1)
(1600,1166,1)
(5494,2861,1)
(2112,8748,1)
(4677,6798,1)
(8719,8391,1)
(8974,5279,1)
(8126,2948,1)
(1818,3782,1)
(8329,7026,1)
(6404,5694,1)
(2734,3471,1)
(5505,711,1)
(4990,8106,1)
(8768,8895,1)
(5214,9138,1)
(5862,2297,1)
(2129,8756,1)
(3046,517,1)
(1002,4579,1)
(2920,7349,1)
(5395,1563,1)
(7011,5938,1)
(6562,9110,1)
(6923,3790,1)
(5981,5486,1)
(2023,4768,1)
(1792,2760,1)
(5816,8704,1)
(9004,115,1)
(5499,3628,1)
(1061,8120,1)
(2154,3494,1)
(3218,3487,1)
(4197,6006,1)
(1962,811,1)
(4533,2374,1)
(6325,4804,1)
(4149,8391,1)
(2622,2843,1)
(7230,1132,1)
(6064,2394,1)
(7957,3887,1)
(5428,2043,1)
(251,1693,1)
(8784,6127,1)
(6527,106,1)
(8983,3811,1)
(8769,383,1)
(5145,5700,1)
(7478,996,1)
(5833,2350,1)
(6091,115,1)
(8250,7343,1)
(588,5077,1)
(4160,6710,1)
(2479,6208,1)
(4984,8756,1)
(7817,7293,1)
(8138,873,1)
(7529,1633,1)
(4476,1618,1)
(1371,3428,1)
(1411,3962,1)
(5662,8169,1)
(4266,3282,1)
(6236,115,1)
(4620,6041,1)
(2933,793,1)
(1425,6911,1)
(2404,8076,1)
(5745,1939,1)
(3330,6744,1)
(2260,8233,1)
(5975,6560,1)
(3718,3706,1)
(5061,3873,1)
(682,3729,1)
(2130,8110,1)
(3013,7759,1)
(2630,5812,1)
(2427,3617,1)
(3200,4153,1)
(6284,6649,1)
(2186,7658,1)
(6540,8023,1)
(5861,6834,1)
(874,7461,1)
(4895,3437,1)
(4235,3669,1)
(11,3347,1)
(4397,822,1)
(1460,4816,1)
(3410,3541,1)
(6051,8389,1)
(6950,644,1)
(1688,1829,1)
(5076,2654,1)
(1757,7485,1)
(7767,4667,1)
(4948,8691,1)
(1845,4447,1)
(7783,7662,1)
(8076,8746,1)
(3312,8767,1)
(2361,2861,1)
(2623,8391,1)
(7122,3507,1)
(4716,2326,1)
(7346,7880,1)
(7305,8756,1)
(6374,7559,1)
(1413,115,1)
(4751,4328,1)
(2886,3303,1)
(4982,8391,1)
(3299,7063,1)
(3337,6950,1)
(770,1472,1)
(596,7849,1)
(7075,115,1)
(2544,2112,1)
(477,115,1)
(2534,8391,1)
(2689,777,1)
(5697,6715,1)
(3455,8675,1)
(39,6014,1)
(1681,3381,1)
(6816,1149,1)
(7052,8632,1)
(2457,115,1)
(3596,2043,1)
(8723,8391,1)
(8647,9076,1)
(5731,1856,1)
(4037,3951,1)
(2287,2112,1)
(4908,4793,1)
(1177,8391,1)
(4189,115,1)
(4321,4651,1)
(8109,777,1)
(8363,3094,1)
(2637,8764,1)
(4331,2335,1)
(3196,3209,1)
(4386,934,1)
(5972,1851,1)
(4636,3911,1)
(7461,4580,1)
(9088,2554,1)
(3319,6967,1)
(1314,3380,1)
(672,8053,1)
(509,63,1)
(2037,8635,1)
(4932,6234,1)
(8414,9004,1)
(5112,192,1)
(6159,3451,1)
(6254,6997,1)
(1990,8538,1)
(5494,5090,1)
(1522,7274,1)
(514,658,1)
(8441,306,1)
(8248,2414,1)
(1454,3843,1)
(624,4711,1)
(5510,7698,1)
(8619,399,1)
(4148,6088,1)
(4028,1488,1)
(774,115,1)
(1203,4425,1)
(4339,8964,1)
(2369,3070,1)
(6566,6669,1)
(8812,8497,1)
(2086,4241,1)
(2544,4350,1)
(8134,2281,1)
(3288,8391,1)
(4400,240,1)
(6373,6604,1)
(6522,115,1)
(339,1845,1)
(727,246,1)
(7296,750,1)
(7787,3122,1)
(1950,8437,1)
(5890,8781,1)
(226,1463,1)
(6876,2502,1)
(2460,7198,1)
(1062,7545,1)
(5054,6038,1)
(6681,4056,1)
(8124,8451,1)
(3970,4192,1)
(6116,2541,1)
(2035,3493,1)
(5123,3712,1)
(4814,3611,1)
(4075,2995,1)
(4194,947,1)
(7056,8391,1)
(7244,1725,1)
(4378,8391,1)
(3212,5578,1)
(7936,1993,1)
(8742,115,1)
(659,2871,1)
(8709,1691,1)
(44,3967,1)
(6821,8815,1)
(1542,115,1)
(6712,1698,1)
(2792,2980,1)
(6888,8391,1)
(2627,701,1)
(971,8728,1)
(3266,6596,1)
(610,115,1)
(6936,6791,1)
(4269,1629,1)
(7561,767,1)
(8443,6297,1)
(3876,115,1)
(7499,3952,1)
(4029,8391,1)
(7786,943,1)
(3090,2651,1)
(7375,8845,1)
(7881,1017,1)
(6031,2478,1)
(5350,5598,1)
(1843,8391,1)
(3709,796,1)
(8694,1228,1)
(7145,3571,1)
(2791,1896,1)
(3171,8102,1)
(73,5060,1)
(8781,3625,1)
(8136,115,1)
(9003,2567,1)
(3621,3565,1)
(6608,115,1)
(6049,4252,1)
(6278,5961,1)
(1881,8391,1)
(7244,6876,1)
(5416,3594,1)
(6738,6310,1)
(5309,3191,1)
(2737,8303,1)
(2960,5625,1)
(735,3475,1)
(5100,4643,1)
(3410,8976,1)
(2876,4889,1)
(977,6158,1)
(5638,6649,1)
(6246,8391,1)
(7771,4333,1)
(3245,3820,1)
(2369,2879,1)
(6234,7062,1)
(8350,3026,1)
(4349,1103,1)
(2114,5215,1)
(7507,7589,1)
(768,115,1)
(3621,8471,1)
(4176,8391,1)
(849,7380,1)
(4047,6329,1)
(771,9091,1)
(1792,115,1)
(1922,44,1)
(1415,4515,1)
(5241,2009,1)
(5166,3054,1)
(926,8391,1)
(585,4671,1)
(4189,3301,1)
(1174,8202,1)
(3322,5800,1)
(748,5844,1)
(1630,1724,1)
(4945,7233,1)
(359,4619,1)
(5046,4490,1)
(3809,4641,1)
(4284,2101,1)
(617,2845,1)
(506,186,1)
(753,2748,1)
(1832,7837,1)
(7634,5850,1)
(6541,8835,1)
(6305,1714,1)
(8670,8773,1)
(5445,6499,1)
(4186,4100,1)
(2482,5047,1)
(1575,9,1)
(4280,4860,1)
(3825,187,1)
(4503,6700,1)
(6119,2358,1)
(881,5228,1)
(3415,5385,1)
(3091,4123,1)
(7465,3589,1)
(4441,45,1)
(1415,8451,1)
(8304,7628,1)
(4245,5237,1)
(7847,115,1)
(7880,1006,1)
(2342,3802,1)
(5308,3640,1)
(4577,2630,1)
(2928,8977,1)
(3677,5063,1)
(7153,4972,1)
(2522,8391,1)
(7121,4994,1)
(7975,8130,1)
(1832,115,1)
(7952,1425,1)
(2737,4222,1)
(7966,6649,1)
(989,8391,1)
(2837,5525,1)
(5276,4134,1)
(292,4742,1)
(417,5195,1)
(2363,4323,1)
(7476,4866,1)
(3826,1350,1)
(2112,8391,2)
(7579,3103,2)
(5151,1145,2)
(5748,115,2)
(6121,131,2)
(7280,6070,2)
(1020,7841,2)
(7182,6804,2)
(6478,7852,2)
(7837,150,2)
(4449,4236,2)
(5916,4565,2)
(4,2918,2)
(5861,5156,2)
(8071,1235,2)
(6016,5613,2)
(976,3218,2)
(5140,3198,2)
(7491,1830,2)
(674,6155,2)
(4130,874,2)
(3620,115,2)
(6818,8756,2)
(8135,1235,2)
(6879,6548,2)
(95,8756,2)
(7910,8391,2)
(4162,8756,2)
(6097,4698,2)
(1167,115,2)
(157,2765,2)
(2135,2406,2)
(3700,3363,2)
(5074,1038,2)
(1283,3330,2)
(6425,8757,2)
(6069,2896,2)
(2195,7940,2)
(3405,4124,2)
(3752,1488,2)
(4202,3934,2)
(1408,4289,2)
(6686,8391,2)
(6682,6155,2)
(4233,7001,2)
(7778,5958,2)
(2827,1991,2)
(706,4445,2)
(4749,8756,2)
(6034,1235,2)
(3090,1420,2)
(8690,2835,2)
(7168,403,2)
(5916,8493,2)
(5740,7909,2)
(6510,4666,2)
(8608,2537,2)
(8063,7628,2)
(6491,8756,2)
(5084,7186,2)
(5751,8923,2)
(5332,5913,2)
(7392,5656,2)
(6846,8695,2)
(1122,8391,2)
(8488,3008,2)
(4547,1319,2)
(6795,1240,2)
(6568,7514,2)
(4763,8432,2)
(5593,4515,2)
(7176,8391,2)
(5332,6548,2)
(6038,8391,2)
(91,846,2)
(6692,5477,2)
(5201,7765,2)
(1612,115,2)
(5433,6155,2)
(2685,6155,2)
(7350,3198,2)
(1968,5162,2)
(2988,6155,2)
(5530,904,2)
(5057,5752,2)
(5660,8670,2)
(930,8391,2)
(1305,7354,2)
(2504,1890,2)
(4644,5586,2)
(646,6520,2)
(2287,4515,2)
(7673,403,2)
(423,2995,2)
(8776,8391,2)
(5355,115,2)
(8432,8840,2)
(3781,3139,2)
(4816,6155,2)
(4125,8852,2)
(5638,2112,2)
(7003,5532,2)
(4925,6804,2)
(4507,3095,2)
(2359,7665,2)
(3470,12,2)
(2287,6356,2)
(3238,3123,2)
(1675,115,2)
(5223,1488,2)
(7519,3114,2)
(6070,3814,2)
(6602,8391,2)
(2699,3198,2)
(3649,3123,2)
(7153,3823,2)
(3647,3491,2)
(1572,352,2)
(7403,6179,2)
(7996,2330,2)
(8888,8756,2)
(4927,92,2)
(2818,8391,2)
(1458,3823,2)
(7630,7653,2)
(4579,360,2)
(2142,1235,2)
(5947,777,2)
(1412,4540,2)
(1538,3891,2)
(7389,6973,2)
(6691,1220,2)
(7457,5033,2)
(1438,8391,2)
(904,4088,2)
(6164,410,2)
(5940,6155,2)
(2260,92,2)
(4757,3814,2)
(967,6155,2)
(4177,4679,2)
(2570,5755,2)
(9115,4679,2)
(2030,1891,2)
(1416,6179,2)
(5010,2036,2)
(5500,8107,2)
(7636,4565,2)
(3537,904,2)
(816,2260,2)
(6505,6003,2)
(4678,4594,2)
(8880,2835,2)
(3474,7870,2)
(5867,8756,2)
(5256,5629,2)
(715,8756,2)
(5572,6613,2)
(3829,4253,2)
(7912,5829,2)
(1924,4253,2)
(3536,689,2)
(4366,8966,2)
(605,3823,2)
(7056,8751,2)
(3076,8391,2)
(1892,3820,2)
(9071,2335,2)
(5977,2952,2)
(4740,7628,2)
(3723,8728,2)
(1363,46,2)
(4473,5496,2)
(3093,7066,2)
(5251,2937,2)
(6911,2964,2)
(2254,515,2)
(2069,5156,2)
(1204,4842,2)
(3431,8587,2)
(6589,3142,2)
(19,3291,2)
(1230,3965,2)
(6098,6687,2)
(4311,5604,2)
(2387,6155,2)
(5609,2187,2)
(7173,5752,2)
(5789,1972,2)
(4176,115,2)
(7358,6236,2)
(5460,2212,2)
(3719,7383,2)
(3595,1488,2)
(8366,8391,2)
(7296,7475,2)
(7966,6649,2)
(4650,7665,2)
(8366,115,2)
(1106,6155,2)
(53,8379,2)
(5809,3565,2)
(1616,5829,2)
(7377,7353,2)
(1128,3417,2)
(1415,6708,2)
(7063,8391,2)
(4821,408,2)
(3797,7858,2)
(8142,1410,2)
(1647,8386,2)
(8457,408,2)
(3099,2344,2)
(2698,5949,2)
(798,7849,2)
(1583,5690,2)
(6842,4253,2)
(981,6530,2)
(311,3123,2)
(6445,2537,2)
(1896,9106,2)
(1150,6385,2)
(2214,2172,2)
(359,5586,2)
(663,6479,2)
(7242,226,2)
(698,6524,2)
(3323,6971,2)
(8273,8670,2)
(1415,3461,2)
(1931,2187,2)
(7085,8391,2)
(2215,403,2)
(319,2060,2)
(8167,19,2)
(3831,3363,2)
(8403,5408,2)
(4840,2765,2)
(6792,2537,2)
(8035,5156,2)
(2044,7408,2)
(1602,115,2)
(8659,8756,2)
(1907,4793,2)
(6080,115,2)
(1515,2866,2)
(4364,2587,2)
(589,4124,2)
(6284,4587,2)
(8624,152,2)
(7820,115,2)
(4095,6880,2)
(1041,6021,2)
(4718,2537,2)
(6022,8391,2)
(4614,5251,2)
(4875,5949,2)
(4487,7940,2)
(3565,2587,2)
(1316,8756,2)
(6091,115,2)
(7309,3812,2)
(3213,1405,2)
(952,8756,2)
(3193,7514,2)
(8640,7353,2)
(8361,2751,2)
(8206,6632,2)
(6220,8391,2)
(2475,2537,2)
(8697,4583,2)
(3906,7762,2)
(6371,1240,2)
(4610,4344,2)
(293,2537,2)
(6360,3451,2)
(3043,403,2)
(4174,6062,2)
(7541,8103,2)
(8249,7870,2)
(1898,611,2)
(8820,8391,2)
(358,4579,2)
(2956,7917,2)
(7136,8756,2)
(2789,9010,2)
(349,5777,2)
(8122,6613,2)
(3814,4641,2)
(242,5204,2)
(7555,7549,2)
(9026,8391,2)
(6294,706,2)
(568,6804,2)
(9068,1149,2)
(1070,4429,2)
(7910,115,2)
(178,7777,2)
(7193,3295,2)
(4542,6804,2)
(3509,4587,2)
(1790,2020,2)
(1005,824,2)
(991,3752,2)
(8711,798,2)
(2917,8756,2)
(7703,6351,2)
(9044,5906,2)
(4900,7977,2)
(4316,2191,2)
(6634,4236,2)
(782,4697,2)
(1415,6571,2)
(7451,5540,2)
(8543,637,2)
(2831,2166,2)
(5431,3201,2)
(1129,6155,2)
(4666,8302,2)
(4759,4388,2)
(1490,2964,2)
(1167,5777,2)
(5259,1657,2)
(3980,1770,2)
(13,4397,2)
(6022,8756,2)
(4402,2592,2)
(7218,7127,2)
(3543,8646,2)
(6985,2995,2)
(290,5226,2)
(6580,7258,2)
(1820,3758,2)
(753,2748,2)
(6903,3814,2)
(1213,4697,2)
(699,3541,2)
(4913,3108,2)
(1493,3166,2)
(2466,7762,2)
(7271,5698,2)
(1121,973,2)
(4923,7940,2)
(92,6179,2)
(6397,7413,2)
(3579,3553,2)
(8108,7103,2)
(6502,3509,2)
(2869,4949,2)
(4337,115,2)
(4560,5396,2)
(4464,2099,2)
(5966,5752,2)
(1506,4558,2)
(3035,2187,2)
(5282,3891,2)
(7163,3812,2)
(8654,8677,2)
(5672,228,2)
(5250,7418,2)
(813,1709,2)
(8429,46,2)
(680,7271,2)
(2468,8391,2)
(604,7940,2)
(1542,8391,2)
(4626,5588,2)
(2396,447,2)
(2283,3123,2)
(7224,115,2)
(8398,6031,2)
(2815,6659,2)
(6582,530,2)
(62,5777,2)
(2464,4153,2)
(1011,2754,2)
(7198,115,2)
(6277,4576,2)
(5541,1370,2)
(2830,228,2)
(6899,6899,2)
(1370,2642,2)
(5279,4285,2)
(862,8391,2)
(4905,1830,2)
(143,1954,2)
(983,8923,2)
(3214,115,2)
(7464,8681,2)
(3542,2526,2)
(7191,115,2)
(6405,6711,2)
(1075,6613,2)
(2927,2854,2)
(8290,5712,2)
(8783,3873,2)
(4762,2983,2)
(4281,4632,2)
(9,4576,2)
(3860,115,2)
(8538,91,2)
(4813,1254,2)
(8165,3812,2)
(1905,4646,2)
(6860,8756,2)
(1310,9038,2)
(1646,257,2)
(7540,9140,2)
(3804,87,2)
(8012,12,2)
(7811,8681,2)
(1641,8751,2)
(640,1254,2)
(6536,7759,2)
(7564,226,2)
(4356,7841,2)
(4001,8391,2)
(8787,8751,2)
(8451,1149,2)
(7344,4124,2)
(3244,459,2)
(3213,6649,2)
(977,6158,2)
(2904,115,2)
(2539,1488,2)
(6498,5204,2)
(8780,7917,2)
(7863,115,2)
(2022,7514,2)
(6955,7760,2)
(8746,6577,2)
(3679,6555,2)
(4468,1458,2)
(8062,5408,2)
(2322,1770,2)
(3051,5825,2)
(3000,575,2)
(1329,5189,2)
(3781,8756,2)
(822,8756,2)
(2576,7590,2)
(1282,115,2)
(7896,150,2)
(8272,2210,2)
(3704,8756,2)
(1105,609,2)
(1348,7852,2)
(6737,8618,2)
(4570,8659,2)
(1319,2454,2)
(3794,7614,2)
(914,4876,2)
(8751,5836,2)
(3356,115,2)
(7288,403,2)
(8959,2191,2)
(1939,1382,2)
(1063,5398,2)
(2287,6921,2)
(3879,8391,2)
(825,6867,2)
(8790,115,2)
(4013,7852,2)
(300,7793,2)
(3549,270,2)
(6008,3934,2)
(165,6155,2)
(1340,8815,2)
(58,1657,2)
(3248,1628,2)
(3761,1370,2)
(3478,228,2)
(2580,874,2)
(6504,5712,2)
(2396,6538,2)
(4011,6426,2)
(4360,5605,2)
(9044,5765,2)
(8550,8391,2)
(2519,6046,2)
(7832,3236,2)
(6736,4697,2)
(7488,202,2)
(2265,2043,2)
(8523,6285,2)
(7678,4697,2)
(2497,8391,2)
(5349,5605,2)
(531,3965,2)
(1526,6884,2)
(2287,2681,2)
(6555,115,2)
(3245,1459,2)
(3621,3565,2)
(4534,5698,2)
(379,1173,2)
(1039,5054,2)
(2467,8391,2)
(8454,8756,2)
(6502,4375,2)
(7940,1240,2)
(4732,8756,2)
(6719,4679,2)
(214,2988,2)
(6741,8832,2)
(3288,6155,2)
(8273,5660,2)
(5347,2191,2)
(8026,4985,2)
(4383,4565,2)
(2920,7349,2)
(4999,7614,2)
(4026,115,2)
(6916,2190,2)
(4048,7665,2)
(6700,7760,2)
(8365,7628,2)
(6001,3814,2)
(7539,6867,2)
(6689,3165,2)
(3828,115,2)
(8114,1653,2)
(921,8391,2)
(6585,1760,2)
(2976,8756,2)
(4262,1954,2)
(1862,1782,2)
(2671,8756,2)
(5477,115,2)
(1077,8249,2)
(2048,131,2)
(797,1311,2)
(2092,4824,2)
(8499,7628,2)
(6795,8391,2)
(3866,4968,2)
(6279,6155,2)
(5870,3812,2)
(6170,8756,2)
(5257,7821,2)
(7795,46,2)
(7545,5543,2)
(8575,5454,2)
(3810,7468,2)
(3372,3781,2)
(785,611,2)
(6074,6662,2)
(2023,6858,2)
(2308,1546,2)
(665,8746,2)
(8183,3891,2)
(1464,292,2)
(7888,2342,2)
(2347,3751,2)
(7179,7724,2)
(6566,5752,2)
(418,5454,2)
(250,6384,2)
(495,8134,2)
(7762,8289,2)
(5472,6867,2)
(4105,1785,2)
(5108,874,2)
(5003,2835,2)
(579,8391,2)
(1922,7628,2)
(5869,1410,2)
(9038,1705,2)
(2442,5540,2)
(184,4646,2)
(7949,6155,2)
(4105,9114,2)
(739,2187,2)
(1491,4012,2)
(3406,2295,2)
(6556,115,2)
(5416,3594,2)
(5499,3628,2)
(6999,5543,2)
(6949,3165,2)
(5382,2587,2)
(7657,3823,2)
(6181,8980,2)
(2581,1653,2)
(784,5540,2)
(1311,6132,2)
(2543,6649,2)
(7315,1785,2)
(7100,6559,2)
(404,6155,2)
(4864,2835,2)
(6878,6155,2)
(1045,8391,2)
(6908,2043,2)
(8046,5204,2)
(482,115,2)
(5495,6804,2)
(4243,8107,2)
(7050,7075,2)
(1484,3758,2)
(6155,6630,2)
(150,3157,2)
(1154,1657,2)
(8215,706,2)
(201,8756,2)
(25,8756,2)
(4806,403,2)
(1240,1954,2)
(7408,9059,2)
(7893,6155,2)
(4375,6055,2)
(3801,7977,2)
(4873,8458,2)
(8592,115,2)
(8914,4697,2)
(6455,7514,2)
(5880,1583,2)
(7077,1653,2)
(4617,6964,2)
(6318,874,2)
(4604,6821,2)
(4023,2206,2)
(8420,611,2)
(2622,2843,2)
(648,6867,2)
(7379,46,2)
(4138,4326,2)
(1583,7760,2)
(8317,1458,2)
(5607,8538,2)
(1936,5454,2)
(4053,2731,2)
(6677,5250,2)
(3864,2210,2)
(8815,3542,2)
(4433,3823,2)
(900,408,2)
(5018,1311,2)
(3873,523,2)
(1067,1104,2)
(8641,3198,2)
(7597,7145,2)
(333,6570,2)
(1573,1240,2)
(4152,5084,2)
(5388,4697,2)
(2276,6155,2)
(2197,2835,2)
(7576,4576,2)
(4549,8391,2)
(5914,2043,2)
(8464,6479,2)
(5636,6155,2)
(7239,5251,2)
(5857,8756,2)
(9139,6155,2)
(2076,1240,2)
(885,924,2)
(7410,8641,2)
(8009,352,2)
(4968,3812,2)
(718,424,2)
(1333,3553,2)
(5285,4646,2)
(7859,6784,2)
(1624,226,2)
(3396,4945,2)
(153,1240,2)
(546,4555,2)
(3256,4985,2)
(3713,115,2)
(4248,4326,2)
(7258,2666,2)
(3272,4253,2)
(7634,847,2)
(1826,1235,2)
(5294,5949,2)
(4527,8432,2)
(5642,3814,2)
(3310,8756,2)
(4510,2116,2)
(1961,6804,2)
(2060,7514,2)
(4115,410,2)
(3751,1712,2)
(413,2283,2)
(115,1850,2)
(7996,2130,2)
(2482,2771,2)
(4997,904,2)
(7646,8391,2)
(2151,115,2)
(6357,8391,2)
(4790,6804,2)
(8641,942,2)
(1103,8391,2)
(5326,3818,2)
(5595,8756,2)
(8247,3035,2)
(5874,8391,2)
(9039,53,2)
(4710,8756,2)
(7999,8484,2)
(519,7139,2)
(2863,3812,2)
(1382,5586,2)
(7036,6505,2)
(2938,8391,2)
(1298,7833,2)
(1800,4495,2)
(502,1149,2)
(1875,6662,2)
(6397,115,2)
(1602,8391,2)
(4434,1235,2)
(2074,1488,2)
(7241,6155,2)
(1056,575,2)
(651,2358,2)
(2283,4783,2)
(7295,7760,2)
(262,1448,2)
(8500,8391,2)
(971,8728,2)
(7231,5836,2)
(7575,3295,2)
(8794,8746,2)
(3826,9096,2)
(2538,8391,2)
(8839,874,2)
(3126,353,2)
(7601,2241,2)
(3906,771,2)
(6181,5069,2)
(2993,4544,2)
(1343,6613,2)
(1415,7544,2)
(6069,4445,2)
(616,1792,2)
(2867,8728,2)
(6159,8756,2)
(8733,3823,2)
(5678,6804,2)
(4521,8328,2)
(2449,5501,2)
(2717,2036,2)
(7139,2835,2)
(8422,2187,2)
(8534,408,2)
(901,4408,2)
(3842,1637,2)
(1459,408,2)
(5714,1254,2)
(3438,5654,2)
(4006,4397,2)
(1461,2657,2)
(4060,3095,2)
(2676,1387,2)
(6900,8825,2)
(2788,7196,2)
(3713,8391,2)
(1322,115,2)
(3810,8020,2)
(7632,2366,2)
(5082,1770,2)
(2517,2283,2)
(7526,5501,2)
(4704,8728,2)
(8975,4945,2)
(8038,3889,2)
(8377,4758,2)
(5540,3488,2)
(6219,3123,2)
(34,3812,2)
(8038,1405,2)
(6819,408,2)
(5033,5811,2)
(2642,5813,2)
(5117,8391,2)
(1085,8391,2)
(527,3891,2)
(5414,8391,2)
(533,7287,2)
(1445,4641,2)
(4309,4876,2)
(7337,5204,2)
(68,3752,2)
(5548,8391,2)
(4914,2445,2)
(4089,3781,2)
(4651,7841,2)
(1047,5454,2)
(5214,6649,2)
(4899,904,2)
(2746,6804,2)
(993,5698,2)
(7735,4876,2)
(1041,8728,2)
(6602,5448,2)
(8138,873,2)
(6097,2043,2)
(6283,2537,2)
(703,2526,2)
(2408,7821,2)
(2318,5408,2)
(8525,403,2)
(2208,7103,2)
(426,5454,2)
(7075,115,2)
(474,6881,2)
(6412,2043,2)
(1670,2191,2)
(3053,6694,2)
(4927,5698,2)
(7172,5204,2)
(7764,115,2)
(356,7318,2)
(7482,2187,2)
(7348,1954,2)
(56,904,2)
(5151,5454,2)
(7777,4289,2)
(5928,1602,2)
(8405,8756,2)
(1017,8391,2)
(4563,4984,2)
(8684,1370,2)
(210,8281,2)
(4299,8756,2)
(1005,846,2)
(7253,4601,2)
(6535,719,2)
(4880,6155,2)
(6068,3774,2)
(6171,92,2)
(6370,4289,2)
(4427,3501,2)
(7880,115,2)
(1240,2512,2)
(7904,2835,2)
(3946,8481,2)
(5779,2526,2)
(45,115,2)
(2403,2502,2)
(1217,4876,2)
(1396,6200,2)
(6038,6385,2)
(3979,8774,2)
(7980,6084,2)
(4977,2835,2)
(4414,403,2)
(300,6580,2)
(8779,8756,2)
(2093,91,2)
(7543,1485,2)
(795,6132,2)
(2352,6804,2)
(5157,1220,2)
(100,8391,2)
(7326,2834,2)
(3439,6703,2)
(8764,5691,2)
(5454,1876,2)
(5654,1830,2)
(4734,4253,2)
(7546,8756,2)
(6705,5777,2)
(7445,8923,2)
(3907,3934,2)
(1095,7001,2)
(6360,8391,2)
(3436,8756,2)
(5721,115,2)
(8838,115,2)
(3107,7453,2)
(2450,4641,2)
(3466,536,2)
(5383,2596,2)
(7690,6385,2)
(306,4329,2)
(8311,8391,2)
(4429,8756,2)
(2563,5027,2)
(9110,2929,2)
(7536,8756,2)
(2892,4632,2)
(3747,4679,2)
(154,2512,2)
(4285,3752,2)
(5656,8756,2)
(8124,1905,2)
(7849,8756,2)
(5829,7152,2)
(607,408,2)
(1415,7404,2)
(5708,8989,2)
(5809,1158,2)
(3284,5540,2)
(8038,7280,2)
(4566,2479,2)
(6194,1724,2)
(7097,1240,2)
(6373,6583,2)
(1213,8391,2)
(2603,1235,2)
(3867,1705,2)
(5179,7940,2)
(353,6613,2)
(6147,5881,2)
(4070,115,2)
(1792,874,2)
(4326,611,2)
(4031,8756,2)
(4189,1254,2)
(3483,5498,2)
(6312,8756,2)
(4425,9128,2)
(5931,208,2)
(6582,8108,2)
(5284,6687,2)
(6993,3983,2)
(1825,2025,2)
(962,6804,2)
(3093,3814,2)
(5932,7909,2)
(5056,8391,2)
(6732,6155,2)
(7866,5997,2)
(3268,8391,2)
(1390,2526,2)
(1183,7614,2)
(7307,7870,2)
(7991,122,2)
(1369,1685,2)
(1410,8863,2)
(7775,8391,2)
(8246,6826,2)
(1273,8391,2)
(107,904,2)
(1119,904,2)
(1954,2896,2)
(922,8481,2)
(7532,8391,2)
(8579,6995,2)
(1415,1405,2)
(1043,1656,2)
(3511,7353,2)
(5854,2842,2)
(3810,5454,2)
(5491,7851,2)
(1555,8391,2)
(3995,6867,2)
(198,8756,2)
(3207,8391,2)
(1415,700,2)
(3415,6726,2)
(1787,8832,2)
(5828,8756,2)
(3443,3714,2)
(286,6556,2)
(4022,2344,2)
(4576,2479,2)
(6004,3382,2)
(5913,3973,2)
(1087,777,2)
(7413,8889,2)
(1126,2456,2)
(1644,1685,2)
(7354,4793,2)
(5533,408,2)
(7444,73,2)
(2287,87,2)
(7768,874,2)
(7135,4467,2)
(940,2592,2)
(7387,4985,2)
(272,4679,2)
(3806,8065,2)
(7781,3521,2)
(2736,6314,2)
(4627,5755,2)
(8361,6479,2)
(179,1311,2)
(688,6053,2)
(7369,4838,2)
(1754,8391,2)
(4164,2512,2)
(4679,4576,2)
(317,3095,2)
(482,8391,2)
(6899,7909,2)
(8615,3095,2)
(6431,7917,2)
(584,1043,2)
(6057,8391,2)
(4375,8471,2)
(7063,403,2)
(4664,1488,2)
(2370,6285,2)
(2750,5501,2)
(7373,8391,2)
(3161,6155,2)
(5794,8756,2)
(3612,208,2)
(6855,1002,2)
(3371,270,2)
(780,6155,2)
(1591,3895,2)
(6803,46,2)
(6844,7262,2)
(8200,8493,2)
(8064,1104,2)
(8925,2537,2)
(413,8391,2)
(1415,2652,2)
(5166,6717,2)
(939,5119,2)
(2661,5949,2)
(5638,1158,2)
(6452,994,2)
(2823,5501,2)
(7760,3427,2)
(4156,3382,2)
(741,4445,2)
(4968,6928,2)
(4493,8756,2)
(2634,4697,2)
(8572,6155,2)
(1133,8728,2)
(3102,2674,2)
(5638,3889,2)
(5006,5949,2)
(3346,253,2)
(3260,115,2)
(2993,2983,2)
(6095,6385,2)
(3602,6155,2)
(1052,8391,2)
(8713,115,2)
(824,8391,2)
(6257,6867,2)
(322,7851,2)
(7180,5752,2)
(6374,6649,2)
(2873,6070,2)
(5555,115,2)
(6032,2366,2)
(7631,5226,2)
(2968,4289,2)
(1415,1270,2)
(7089,2866,2)
(1460,6155,2)
(8742,2845,2)
(8405,3342,2)
(661,6548,2)
(1062,5543,2)
(1177,8391,2)
(1679,8728,2)
(353,115,2)
(4600,1709,2)
(2440,1705,2)
(7988,8391,2)
(4943,2771,2)
(5121,4236,2)
(1691,7977,2)
(1422,1184,2)
(8002,1653,2)
(7973,1458,2)
(8973,3906,2)
(7005,6155,2)
(8989,100,2)
(8742,115,2)
(1435,2573,2)
(1090,1705,2)
(3300,3541,2)
(4253,1410,2)
(2242,46,2)
(3349,5698,2)
(1413,2020,2)
(2198,4191,2)
(9140,4679,2)
(1125,6804,2)
(1008,529,2)
(8070,1488,2)
(5881,2386,2)
(2972,5388,2)
(8341,7150,2)
(6293,4950,2)
(2847,3095,2)
(7053,228,2)
(2924,3549,2)
(3865,1410,2)
(786,7352,2)
(7626,1405,2)
(3859,7552,2)
(424,3451,2)
(2313,904,2)
(3803,9140,2)
(3189,46,2)
(6609,115,2)
(2522,8391,2)
(6091,2036,2)
(3714,6791,2)
(2638,6867,2)
(9059,3401,2)
(6446,3053,2)
(2538,115,2)
(7865,3295,2)
(22,2344,2)
(87,1782,2)
(4420,4982,2)
(302,6784,2)
(4701,8778,2)
(4487,67,2)
(2614,8108,2)
(2937,6132,2)
(8409,2283,2)
(8282,8493,2)
(6207,3218,2)
(1203,5829,2)
(551,5501,2)
(308,3097,2)
(6502,7626,2)
(7929,115,2)
(7866,1029,2)
(3190,8756,2)
(5757,6094,2)
(7217,846,2)
(6089,8756,2)
(1257,3123,2)
(5098,3430,2)
(2697,3812,2)
(2932,5856,2)
(3192,3752,2)
(550,12,2)
(6246,8391,2)
(6659,4277,2)
(2410,2199,2)
(5593,8458,2)
(5396,6155,2)
(5679,255,2)
(7651,6132,2)
(2371,8756,2)
(5002,2366,2)
(2950,403,2)
(6146,3240,2)
(6504,3860,2)
(3477,1878,2)
(7468,5454,2)
(2035,904,2)
(1900,5752,2)
(2019,5454,2)
(1685,6762,2)
(6961,4908,2)
(2729,2757,2)
(6928,115,2)
(4682,7510,2)
(8237,8391,2)
(1340,2821,2)
(3403,7671,2)
(1015,4326,2)
(5575,4765,2)
(7510,115,2)
(6024,8756,2)
(822,7102,2)
(1768,8432,2)
(1591,636,2)
(191,882,2)
(3693,46,2)
(4375,7280,2)
(9037,8756,2)
(9073,8756,2)
(3109,5543,2)
(4784,408,2)
(3927,799,2)
(4692,5249,2)
(4919,3108,2)
(6149,408,2)
(9088,7711,2)
(8445,5876,2)
(4793,5869,2)
(7138,8523,2)
(8055,8756,2)
(966,4876,2)
(572,1888,2)
(3899,2845,2)
(3947,7841,2)
(2467,115,2)
(7821,7797,2)
(1419,1760,2)
(6048,3812,2)
(2036,3842,2)
(4687,403,2)
(6539,8391,2)
(2737,4222,2)
(7493,1235,2)
(5115,6858,2)
(7211,338,2)
(3863,5881,2)
(3366,5204,2)
(8479,3834,2)
(2980,1493,2)
(5423,403,2)
(3970,7514,2)
(7553,8790,2)
(3974,904,2)
(3924,2520,2)
(5638,8021,2)
(597,5586,2)
(1365,951,2)
(5412,3218,2)
(277,2835,2)
(3463,1975,2)
(4832,7262,2)
(961,4253,2)
(6288,8391,2)
(2260,3427,2)
(2763,8391,2)
(7722,7657,2)
(339,4558,2)
(8387,1063,2)
(1977,7870,2)
(4108,1149,2)
(6803,5970,2)
(2116,4536,2)
(7957,5698,2)
(1081,4435,2)
(3001,115,2)
(1785,8318,2)
(8772,4579,2)
(2978,8391,2)
(2331,7760,2)
(3379,4626,2)
(1406,3087,2)
(592,2366,2)
(7097,4445,2)
(382,7514,2)
(6946,771,2)
(4405,3965,2)
(4565,8832,2)
(8142,2858,2)
(8655,4228,2)
(1145,1047,2)
(334,6155,2)
(2728,8794,2)
(6076,2379,2)
(7424,1954,2)
(8338,3672,2)
(936,4239,2)
(2737,8431,2)
(7452,5501,2)
(5814,1235,2)
(4394,8873,2)
(525,1657,2)
(1244,1401,2)
(5080,7841,2)
(8082,8756,2)
(8185,1240,2)
(518,1657,2)
(3083,3417,2)
(5532,4253,2)
(8840,4088,2)
(4100,7775,2)
(4782,8493,2)
(3170,1254,2)
(4339,3382,2)
(8193,5712,2)
(6200,7353,2)
(3769,9119,2)
(6608,115,2)
(1415,1851,2)
(6068,7628,2)
(7313,5586,2)
(3173,8670,2)
(2540,2330,2)
(6348,716,2)
(2295,4037,2)
(3753,916,2)
(8147,7670,2)
(8029,4473,2)
(3247,408,2)
(7277,7628,2)
(853,122,2)
(1122,1583,2)
(5638,6968,2)
(7833,5829,2)
(1430,8573,2)
(5891,9096,2)
(2931,611,2)
(4438,7760,2)
(4398,3781,2)
(7966,3889,2)
(4252,951,2)
(3369,8756,2)
(6196,4994,2)
(7094,8756,2)
(8347,8134,2)
(2842,115,2)
(2911,4253,2)
(8113,8065,2)
(4087,6385,2)
(7467,5027,2)
(8204,46,2)
(1567,4153,2)
(1957,4697,2)
(993,3427,2)
(299,4876,2)
(3891,3924,2)
(6247,7852,2)
(7219,8578,2)
(6502,6284,2)
(4618,4426,2)
(9016,3781,2)
(5771,2596,2)
(8478,7262,2)
(5693,4698,2)
(807,2366,2)
(1850,6033,2)
(8928,4781,2)
(5567,6223,2)
(9068,4767,2)
(345,8391,2)
(3138,8391,2)
(2129,8756,2)
(5973,46,2)
(6757,2326,2)
(72,6566,2)
(7423,3382,2)
(2346,2158,2)
(2671,8391,2)
(3545,92,2)
(1300,1954,2)
(4375,4705,2)
(2124,507,2)
(7100,4646,2)
(4974,7353,2)
(3804,3565,2)
(5019,2983,2)
(5775,829,2)
(711,5193,2)
(7995,6285,2)
(2829,8431,2)
(4549,1235,2)
(3104,6155,2)
(3823,1298,2)
(8673,5110,2)
(1832,150,2)
(3138,2845,2)
(1033,7762,2)
(8296,2309,2)
(2366,5785,2)
(4375,5655,2)
(4605,2279,2)
(6616,8756,2)
(7561,2845,2)
(3094,5752,2)
(9126,1235,2)
(2339,743,2)
(3213,8471,2)
(4966,9110,2)
(4921,4150,2)
(6953,6155,2)
(1063,3658,2)
(4375,8458,2)
(292,4742,2)
(5852,7570,2)
(3203,6613,2)
(3124,7765,2)
(1935,2536,2)
(6145,3363,2)
(7018,7765,2)
(6341,115,2)
(1852,6577,2)
(9006,3142,2)
(1457,3108,2)
(3163,4285,2)
(2679,1046,2)
(493,6971,2)
(5628,8728,2)
(7969,1657,2)
(5813,8391,2)
(8820,3814,2)
(8955,8493,2)
(1682,8794,2)
(9124,7711,2)
(3328,8756,2)
(7202,4579,2)
(4389,5543,2)
(3295,5698,2)
(5708,1830,2)
(697,1079,2)
(6815,7413,2)
(3469,3493,2)
(488,53,2)
(5173,5958,2)
(4667,2834,2)
(5837,8481,2)
(7716,8391,2)
(2027,9049,2)
(1988,2866,2)
(3873,408,2)
(8294,6155,2)
(2,4549,2)
(6428,5204,2)
(2894,7431,2)
(824,846,2)
(3945,543,2)
(8990,8756,2)
(6399,8756,2)
(5046,2537,2)
(4901,5752,2)
(2237,7711,2)
(4853,5605,2)
(2544,2112,2)
(2574,904,2)
(3849,8391,2)
(9049,115,2)
(6464,3769,2)
(4845,8756,2)
(2467,408,2)
(8741,5586,2)
(2195,8205,2)
(6774,4124,2)
(4859,6803,2)
(5917,1493,2)
(6595,2053,2)
(4503,6700,2)
(7493,1411,2)
(3242,8756,2)
(6199,6804,2)
(6545,7365,2)
(4549,115,2)
(1200,1974,2)
(7638,2984,2)
(2113,8538,2)
(9013,3968,2)
(965,1888,2)
(6677,3312,2)
(2287,700,2)
(2379,4729,2)
(7908,5586,2)
(5475,4280,2)
(7959,3810,2)
(8639,1874,2)
(5801,3064,2)
(5847,2257,2)
(1969,3891,2)
(5331,9096,2)
(3101,8391,2)
(8671,1459,2)
(6316,6070,2)
(7845,6867,2)
(6401,3095,2)
(5140,904,2)
(2328,1954,2)
(2122,2210,2)
(3202,1306,2)
(1645,6155,2)
(1787,3732,2)
(3157,1648,2)
(82,1906,2)
(3276,8756,2)
(7777,8014,2)
(6436,8756,2)
(3697,2030,2)
(226,7821,2)
(539,8391,2)
(4019,92,2)
(1697,4565,2)
(1197,1888,2)
(3815,3295,2)
(3279,2482,2)
(8552,7586,2)
(6248,5204,2)
(4843,8475,2)
(8173,2867,2)
(8343,3501,2)
(4647,5755,2)
(6776,8348,2)
(7506,8756,2)
(4192,7514,2)
(8434,408,2)
(6456,5397,2)
(949,8728,2)
(6932,115,2)
(6950,644,2)
(4389,8391,2)
(2185,2130,2)
(7375,8845,2)
(4317,6155,2)
(7836,228,2)
(6808,3863,2)
(6847,1289,2)
(2330,3596,2)
(2742,408,2)
(360,3198,2)
(7289,5752,2)
(7989,8391,2)
(7485,951,2)
(8475,706,2)
(1127,904,2)
(8542,4994,2)
(1700,2375,2)
(6653,7977,2)
(2819,408,2)
(7435,8815,2)
(1110,9021,2)
(8159,2187,2)
(6751,3863,2)
(8217,4698,2)
(4357,7754,2)
(8324,4388,2)
(5655,7821,2)
(4941,6155,2)
(3151,5156,2)
(5515,4311,2)
(571,6858,2)
(5162,1491,2)
(1636,8756,2)
(8073,2537,2)
(8407,7180,2)
(267,3215,2)
(5052,4154,2)
(2009,6023,2)
(526,6613,2)
(6632,3198,2)
(8482,2983,2)
(7372,7628,2)
(9043,2746,2)
(930,115,2)
(7929,8391,2)
(6497,5586,2)
(6062,2117,2)
(1054,5454,2)
(137,3823,2)
(2507,403,2)
(2816,8756,2)
(8007,8756,2)
(7632,8391,2)
(1173,7657,2)
(8249,8391,2)
(4299,4980,2)
(8889,3969,2)
(309,6385,2)
(2010,7760,2)
(1912,874,2)
(2876,4641,2)
(4839,6479,2)
(2042,4,2)
(5276,7614,2)
(3053,8107,2)
(140,5752,2)
(4650,8391,2)
(274,7155,2)
(8946,5052,2)
(6470,5454,2)
(2396,874,2)
(5447,6804,2)
(4062,403,2)
(7871,7711,2)
(8669,7143,2)
(5386,408,2)
(1783,4876,2)
(4195,611,2)
(3865,2858,2)
(4590,3906,2)
(7535,6155,2)
(6496,3810,2)
(3127,4236,2)
(4716,2326,2)
(2165,2526,2)
(1630,1724,2)
(3716,8756,2)
(4679,4861,2)
(6875,115,2)
(6735,874,2)
(6462,771,2)
(4858,5204,2)
(4310,3095,2)
(4092,4793,2)
(6910,2830,2)
(6703,6070,2)
(6816,5752,2)
(8912,2465,2)
(5690,7679,2)
(523,8391,2)
(7871,6385,2)
(2423,115,2)
(660,2043,2)
(6588,1785,2)
(7672,4516,2)
(3058,7396,2)
(8456,8756,2)
(4018,6385,2)
(289,5844,2)
(4167,5454,2)
(5501,4723,2)
(2003,8532,2)
(4873,6649,2)
(6545,1788,2)
(1900,6816,2)
(1411,5540,2)
(4336,408,2)
(1036,1173,2)
(4769,3279,2)
(6467,1921,2)
(8226,1235,2)
(999,8756,2)
(8571,6576,2)
(3425,107,2)
(1605,9128,2)
(4983,2199,2)
(5068,8756,2)
(8902,3713,2)
(2915,1311,2)
(4245,3703,2)
(432,7354,2)
(6412,8580,2)
(5638,6921,2)
(6332,6613,2)
(4602,1888,2)
(7205,4856,2)
(3509,7039,2)
(5176,8832,2)
(8952,2210,2)
(8618,8391,2)
(2230,874,2)
(2544,7039,2)
(6225,8108,2)
(515,1254,2)
(2690,5752,2)
(1227,8756,2)
(6139,3095,2)
(5566,2835,2)
(5539,8756,2)
(2964,2964,2)
(34,5870,2)
(3786,115,2)
(5811,4624,2)
(1474,1158,2)
(545,123,2)
(6059,1657,2)
(4957,3095,2)
(7722,777,2)
(3692,874,2)
(7760,6179,2)
(2656,2191,2)
(3288,115,2)
(2072,8391,2)
(8121,2053,2)
(187,904,2)
(7373,2845,2)
(5590,5454,2)
(3758,799,2)
(6545,1925,2)
(6921,5932,2)
(3623,8129,2)
(6899,646,2)
(6895,1002,2)
(6352,8129,2)
(4620,4682,2)
(6984,7657,2)
(6662,2874,2)
(7471,3320,2)
(6086,3823,2)
(5031,904,2)
(338,5530,2)
(6410,8523,2)
(2065,1144,2)
(4154,8493,2)
(657,410,2)
(8247,6525,2)
(3955,150,2)
(8927,1192,2)
(8791,1709,2)
(7405,7628,2)
(2308,916,2)
(5859,8377,2)
(3558,7453,2)
(2395,4793,2)
(7255,2344,2)
(9010,799,2)
(1415,9130,2)
(8976,3541,2)
(2570,4647,2)
(2113,609,2)
(6000,2210,2)
(3792,1754,2)
(2660,3730,2)
(6367,2172,2)
(7983,7760,2)
(3965,7909,2)
(7942,8681,2)
(8813,403,2)
(6986,1208,2)
(5554,1972,2)
(7384,3184,2)
(7149,5712,2)
(1628,8391,2)
(9119,115,2)
(4220,2502,2)
(8882,5162,2)
(2111,2350,2)
(8731,5498,2)
(5327,2537,2)
(8102,7541,2)
(1382,8559,2)
(4155,115,2)
(5640,115,2)
(2168,5752,2)
(8303,6807,2)
(6333,5489,2)
(5405,6155,2)
(108,3776,2)
(4282,4016,2)
(2544,3889,2)
(806,5501,2)
(2952,8126,2)
(3050,2043,2)
(2354,8391,2)
(4544,7113,2)
(2436,2366,2)
(968,6791,2)
(3139,212,2)
(1326,115,2)
(2636,3123,2)
(8909,5586,2)
(4922,6627,2)
(4934,4861,2)
(3320,3320,2)
(6259,7868,2)
(832,4793,2)
(6249,408,2)
(2882,3969,2)
(5813,1493,2)
(7760,6908,2)
(1735,8756,2)
(6650,8241,2)
(8419,8391,2)
(8670,6155,2)
(2440,3814,2)
(6522,2191,2)
(8862,594,2)
(8014,1149,2)
(1781,4679,2)
(2751,6622,2)
(1947,6613,2)
(4536,4707,2)
(4684,8856,2)
(1987,6314,2)
(3526,8391,2)
(8909,115,2)
(1415,1412,2)
(628,5752,2)
(2804,403,2)
(1865,1888,2)
(3508,1311,2)
(965,4521,2)
(344,6155,2)
(3621,4149,2)
(8427,6155,2)
(4106,5869,2)
(1152,8391,2)
(4510,7514,2)
(170,8391,2)
(3752,7001,2)
(3800,2359,2)
(7212,8429,2)
(7420,1311,2)
(7969,115,2)
(20,7088,2)
(1416,92,2)
(8883,2449,2)
(152,8746,2)
(391,8391,2)
(819,3701,2)
(2144,8728,2)
(7389,3965,2)
(6815,8158,2)
(8342,2020,2)
(3606,5752,2)
(7728,1235,2)
(3660,8695,2)
(452,12,2)
(7852,6722,2)
(4109,5408,2)
(2161,7569,2)
(3842,284,2)
(1365,8908,2)
(4809,7210,2)
(7292,3733,2)
(4720,8846,2)
(4708,7514,2)
(9113,4583,2)
(8298,3427,2)
(3583,3620,2)
(4898,7828,2)
(1415,3242,2)
(1564,7984,2)
(1476,403,2)
(1169,8756,2)
(5597,3201,2)
(2653,1149,2)
(4221,8655,2)
(6620,8756,2)
(4783,3123,2)
(1629,4874,2)
(351,6155,2)
(2476,5033,2)
(324,6310,2)
(8177,4793,2)
(5632,2854,2)
(1511,9050,2)
(1283,2335,2)
(1022,8391,2)
(751,8432,2)
(5626,7628,2)
(5928,904,2)
(7793,3942,2)
(7696,1254,2)
(102,559,2)
(3289,2445,2)
(71,8756,2)
(9041,6155,2)
(7021,5501,2)
(2459,4977,2)
(881,1559,2)
(6645,3363,2)
(4071,3719,2)
(7080,4697,2)
(1199,3130,2)
(6594,115,2)
(8487,3295,2)
(6967,7608,2)
(5109,3451,2)
(3643,7628,2)
(7245,6385,2)
(1714,7569,2)
(7102,8756,2)
(581,6275,2)
(3804,2497,2)
(4872,4402,2)
(1353,5712,2)
(8043,8190,2)
(9067,3823,2)
(3539,115,2)
(2111,3837,2)
(4272,6430,2)
(1054,8391,2)
(2287,5452,2)
(1149,2926,2)
(6502,1474,2)
(4001,115,2)
(1436,4984,2)
(7047,8756,2)
(284,4579,2)
(5643,3969,2)
(2904,8391,2)
(6748,2983,2)
(2743,8431,2)
(1474,3215,2)
(3748,6070,2)
(4426,115,2)
(2498,5408,2)
(2649,7226,2)
(4469,1705,2)
(6512,5173,2)
(2718,6414,2)
(2820,8756,2)
(1991,7514,2)
(866,8756,2)
(2589,4679,2)
(1954,4445,2)
(6228,904,2)
(4836,8391,2)
(8362,8360,2)
(2287,3889,2)
(7129,739,2)
(8765,2191,2)
(3879,115,2)
(6108,3812,2)
(8689,3812,2)
(3164,2587,2)
(3740,8391,2)
(7294,535,2)
(2471,3696,2)
(6336,1389,2)
(4153,6053,2)
(7809,8832,2)
(4897,5540,2)
(420,356,2)
(1125,4752,2)
(2030,7066,2)
(2961,1240,2)
(8032,1235,2)
(520,1612,2)
(8648,8391,2)
(4277,2717,2)
(228,8756,2)
(5654,5346,2)
(3177,8065,2)
(1581,2030,2)
(223,1974,2)
(730,3895,2)
(6179,8493,2)
(7210,8018,2)
(8099,5968,2)
(5656,2607,2)
(2836,6155,2)
(2462,3810,2)
(8907,7628,2)
(573,5752,2)
(161,8391,2)
(2490,6155,2)
(1874,8746,2)
(7653,8391,2)
(8570,798,2)
(4883,2274,2)
(1096,7488,2)
(8696,5752,2)
(6203,1657,2)
(3605,6867,2)
(9065,7262,2)
(951,7405,2)
(7428,3758,2)
(5638,4587,2)
(3785,115,2)
(6826,540,2)
(6390,8756,2)
(8567,5226,2)
(6563,3965,2)
(489,7909,2)
(7123,3965,2)
(4412,4579,2)
(8577,85,2)
(9076,6827,2)
(3625,7628,2)
(2252,403,2)
(2559,3095,2)
(8426,6836,2)
(18,2825,2)
(598,904,2)
(3231,8756,2)
(2596,8481,2)
(8355,4451,2)
(8038,3215,2)
(7437,904,2)
(8870,6804,2)
(3791,115,2)
(6808,7480,2)
(1973,7569,2)
(3306,1560,2)
(3833,6155,2)
(1293,8989,2)
(8459,7413,2)
(1306,2036,2)
(7931,92,2)
(6947,6385,2)
(4855,4253,2)
(428,1254,2)
(3067,3427,2)
(5291,3097,2)
(2167,115,2)
(3063,798,2)
(4139,4697,2)
(7174,4326,2)
(1870,2432,2)
(507,163,2)
(6573,4236,2)
(33,3218,2)
(519,2835,2)
(65,403,2)
(7965,7940,2)
(3563,3863,2)
(1111,115,2)
(6675,2283,2)
(4942,8391,2)
(2445,1165,2)
(2201,7119,2)
(8366,8756,2)
(7396,3142,2)
(3927,2537,2)
(3013,8756,2)
(197,4984,2)
(2806,3823,2)
(7139,277,2)
(5127,4679,2)
(8485,3095,2)
(1720,8107,2)
(1104,7828,2)
(3522,4848,2)
(2250,777,2)
(8348,8391,2)
(7102,6272,2)
(8018,2235,2)
(1618,1770,2)
(6284,9130,2)
(4850,8391,2)
(5390,3295,2)
(8616,115,2)
(3843,158,2)
(4589,2644,2)
(5052,8493,2)
(8097,3123,2)
(6198,115,2)
(7076,2537,2)
(3574,91,2)
(7620,4253,2)
(123,8756,2)
(3360,2277,2)
(1013,8741,2)
(1474,536,2)
(2620,179,2)
(4479,7233,2)
(1889,6189,2)
(2130,8110,2)
(8587,2591,2)
(7511,1888,2)
(2049,2466,2)
(4818,874,2)
(8618,1254,2)
(5665,1042,2)
(5907,8493,2)
(8922,2537,2)
(6892,8889,2)
(3526,115,2)
(7273,2835,2)
(8229,5251,2)
(3028,7683,2)
(8636,7514,2)
(191,7628,2)
(8268,5586,2)
(6111,115,2)
(7335,4945,2)
(2003,5204,2)
(8975,240,2)
(938,706,2)
(5089,8756,2)
(1932,408,2)
(3032,3417,2)
(6021,8728,2)
(3114,115,2)
(5207,3814,2)
(4773,115,2)
(3054,655,2)
(1718,4285,2)
(1350,9096,2)
(120,3696,2)
(8362,2198,2)
(4601,2366,2)
(3076,6155,2)
(5204,1245,2)
(6148,7138,2)
(829,6577,2)
(2842,2835,2)
(4759,3759,2)
(3383,5605,2)
(5990,1509,2)
(2431,1458,2)
(2981,2112,2)
(4295,5802,2)
(2236,7628,2)
(8354,2012,2)
(6626,2866,2)
(5132,7862,2)
(4122,6457,2)
(1770,2344,2)
(1959,5204,2)
(3522,5958,2)
(4188,6603,2)
(3534,8391,2)
(6090,3095,2)
(719,2241,2)
(5721,8391,2)
(4691,5712,2)
(5510,6321,2)
(2249,8756,2)
(6995,5958,2)
(1840,6279,2)
(4102,5540,2)
(929,4959,2)
(876,874,2)
(7472,7977,2)
(8128,2771,2)
(6202,4908,2)
(6057,8756,2)
(8311,2845,2)
(4410,5156,2)
(8388,5433,2)
(3267,4697,2)
(8069,4236,2)
(1972,7917,2)
(387,8355,2)
(8629,6417,2)
(779,8977,2)
(4904,1002,2)
(8626,1785,2)
(4386,3597,2)
(4375,1270,2)
(438,7570,2)
(577,2043,2)
(405,777,2)
(5969,19,2)
(2939,3769,2)
(5991,8222,2)
(2259,5586,2)
(2087,5461,2)
(6802,3758,2)
(6755,6867,2)
(8341,5829,2)
(3331,4985,2)
(5438,7999,2)
(9106,2537,2)
(4032,8756,2)
(8269,1709,2)
(5602,392,2)
(3786,8391,2)
(4424,5156,2)
(712,8167,2)
(8099,3103,2)
(1540,4576,2)
(2061,8756,2)
(345,115,2)
(3571,6070,2)
(4798,8391,2)
(4346,1916,2)
(6271,3417,2)
(8289,1149,2)
(913,403,2)
(5047,8070,2)
(1415,3986,2)
(7054,403,2)
(8421,115,2)
(4641,5862,2)
(42,8065,2)
(2705,8746,2)
(8329,3814,2)
(8447,3907,2)
(1121,8995,2)
(5593,6649,2)
(6667,1401,2)
(7688,3963,2)
(6746,4466,2)
(7585,7354,2)
(8035,8455,2)
(6173,3823,2)
(823,8712,2)
(6846,3812,2)
(3549,2293,2)
(1837,6804,2)
(2217,8391,2)
(6906,4793,2)
(685,348,2)
(8449,7628,2)
(6835,4916,2)
(5548,3621,2)
(2644,5752,2)
(1082,8391,2)
(3696,2626,2)
(8616,8391,2)
(6742,5037,2)
(8388,2059,2)
(7159,3621,2)
(7013,6824,2)
(7975,8130,2)
(4807,7841,2)
(8875,3701,2)
(6545,1954,2)
(859,871,2)
(3749,5204,2)
(3214,6662,2)
(5424,3363,2)
(5412,2344,2)
(6711,1825,2)
(669,5033,2)
(6608,8391,2)
(5510,7698,2)
(5547,6230,2)
(8136,115,2)
(1415,8458,2)
(19,8493,2)
(2335,7765,2)
(2698,4875,2)
(7287,115,2)
(8597,4594,2)
(7824,5949,2)
(2119,270,2)
(7985,3142,2)
(1918,8756,2)
(5538,3169,2)
(5719,8391,2)
(1242,1760,2)
(7240,5226,2)
(8614,6649,2)
(3953,7909,2)
(5938,6826,2)
(4417,2845,2)
(166,1220,2)
(6894,7765,2)
(1206,4381,2)
(5069,6995,2)
(514,8391,2)
(4792,7841,2)
(8758,7262,2)
(1393,8923,2)
(1001,8391,2)
(5053,4289,2)
(8139,8391,2)
(6580,914,2)
(2470,1283,2)
(6993,4522,2)
(2053,7271,2)
(1096,904,2)
(6998,7374,2)
(6462,2690,2)
(3952,8749,2)
(4515,2587,2)
(9024,7453,2)
(6385,2241,2)
(1285,7868,2)
(4081,4327,2)
(4990,8751,2)
(7458,951,2)
(4382,6053,2)
(3151,8778,2)
(467,6179,2)
(8488,3513,2)
(227,6179,2)
(3218,8756,2)
(8836,2866,2)
(7219,53,2)
(2422,5501,2)
(3604,3938,2)
(7347,6423,2)
(7043,1656,2)
(6627,8391,2)
(7432,8391,2)
(6334,7353,2)
(6972,4876,2)
(8471,1360,2)
(771,1149,2)
(1721,4016,2)
(8415,8756,2)
(8978,8756,2)
(8552,3277,2)
(1324,807,2)
(3299,7063,2)
(6286,904,2)
(4909,4619,2)
(741,5512,2)
(6968,1173,2)
(1373,5498,2)
(5181,462,2)
(7885,5501,2)
(2040,1254,2)
(6976,8923,2)
(3983,4453,2)
(8419,1240,2)
(8798,575,2)
(3858,8496,2)
(840,3095,2)
(4954,1488,2)
(2468,4925,2)
(5994,8431,2)
(4383,3876,2)
(1971,611,2)
(8709,7977,2)
(2771,6577,2)
(327,8538,2)
(6196,2879,2)
(2279,1241,2)
(4044,4034,2)
(5835,1653,2)
(5475,6155,2)
(1664,3382,2)
(2628,2187,2)
(3890,8756,2)
(3828,8391,2)
(6069,5512,2)
(8602,8756,2)
(965,9125,2)
(429,6613,2)
(4643,7262,2)
(2117,7001,2)
(4624,4698,2)
(2278,7940,2)
(4088,4745,2)
(3509,9130,2)
(5593,9130,2)
(4231,11,2)
(7050,822,2)
(6142,1324,2)
(4180,403,2)
(3638,6273,2)
(5922,3589,2)
(3717,3823,2)
(3929,5869,2)
(1648,8577,2)
(4270,2115,2)
(4075,2995,2)
(4000,8450,2)
(7145,3571,2)
(1252,1682,2)
(3415,5374,2)
(713,5056,2)
(3463,4253,2)
(8500,5777,2)
(8691,9140,2)
(5679,181,2)
(7818,1770,2)
(4658,2187,2)
(2544,8471,2)
(4086,352,2)
(1386,3363,2)
(8528,661,2)
(3064,8756,2)
(3275,904,2)
(6994,9096,2)
(7287,7940,2)
(5478,2344,2)
(1535,2537,2)
(2440,6001,2)
(4562,6155,2)
(281,1954,2)
(6149,3630,2)
(3305,8538,2)
(4783,3785,2)
(5866,8756,2)
(2303,3647,2)
(5026,6804,2)
(1415,6952,2)
(4249,2835,2)
(7140,5248,2)
(7538,2366,2)
(1741,1916,2)
(943,5752,2)
(2936,1954,2)
(3509,6474,2)
(926,115,2)
(3377,3906,2)
(9133,7155,2)
(8242,9096,2)
(5720,874,2)
(4559,6132,2)
(7622,197,2)
(3457,2384,2)
(7968,6971,2)
(7922,771,2)
(89,665,2)
(1712,4205,2)
(3906,6101,2)
(5690,7453,2)
(212,8756,2)
(4424,4371,2)
(6364,6537,2)
(1800,6385,2)
(6502,3804,2)
(3618,6911,2)
(8078,795,2)
(4143,951,2)
(8664,8391,2)
(1415,8238,2)
(2719,4285,2)
(1832,2845,2)
(5451,2845,2)
(9059,8107,2)
(7774,7066,2)
(6875,8391,2)
(6851,453,2)
(2202,6314,2)
(8372,2424,2)
(3367,7760,2)
(2468,115,2)
(7493,5775,2)
(5204,6867,2)
(8716,7724,2)
(357,6613,2)
(3496,7628,2)
(1763,7155,2)
(6609,2845,2)
(1587,6046,2)
(3175,8756,2)
(3621,6649,2)
(2221,5867,2)
(7652,3419,2)
(8196,4697,2)
(1009,7514,2)
(8775,3541,2)
(687,92,2)
(8038,7039,2)
(6796,6867,2)
(6778,4408,2)
(5419,4697,2)
(6902,4205,2)
(6694,2423,2)
(4288,1770,2)
(7064,6155,2)
(5189,7569,2)
(3624,8107,2)
(5103,3417,2)
(5471,228,2)
(4632,8108,2)
(114,5646,2)
(351,2836,2)
(8646,4232,2)
(4865,1254,2)
(8857,2964,2)
(5365,8756,2)
(2909,8391,2)
(3644,2187,2)
(167,5739,2)
(5710,8756,2)
(6455,1235,2)
(1227,8391,2)
(9056,1254,2)
(7222,7762,2)
(690,6155,2)
(8047,8677,2)
(8032,7514,2)
(9106,8391,2)
(3139,8756,2)
(6971,7493,2)
(5160,4558,2)
(8204,5268,2)
(8520,6867,2)
(1336,4253,2)
(7201,3752,2)
(5729,1732,2)
(4319,8391,2)
(3143,4974,2)
(6357,115,2)
(4797,1785,2)
(8812,6791,2)
(6208,5204,2)
(7571,8391,2)
(6834,7119,2)
(5300,3814,2)
(6908,5829,2)
(7742,5752,2)
(2109,6580,2)
(7905,5656,2)
(499,274,2)
(2074,3863,2)
(7959,8391,2)
(5638,3657,2)
(2761,4793,2)
(6259,4212,2)
(884,3906,2)
(5786,7973,2)
(7801,2344,2)
(9075,3823,2)
(5312,408,2)
(312,6155,2)
(4491,5698,2)
(8490,5501,2)
(1444,6385,2)
(2504,8817,2)
(7169,706,2)
(3382,6132,2)
(863,4925,2)
(4583,8155,2)
(6762,986,2)
(3739,874,2)
(5827,3541,2)
(4625,8523,2)
(3206,8129,2)
(3482,6867,2)
(1032,4289,2)
(5899,3142,2)
(479,1254,2)
(552,1619,2)
(558,1463,2)
(2707,6750,2)
(433,7963,2)
(1415,4630,2)
(6352,3259,2)
(3627,4604,2)
(4767,3906,2)
(4360,5446,2)
(3147,2782,2)
(7057,2199,2)
(7975,1701,2)
(1293,5346,2)
(8430,1162,2)
(1415,8495,2)
(7984,8391,2)
(8732,8391,2)
(5494,8458,2)
(9117,8391,2)
(4712,3198,2)
(4536,536,2)
(8747,7657,2)
(6742,4285,2)
(4368,3906,2)
(7069,8493,2)
(1326,2845,2)
(4690,7180,2)
(4297,2344,2)
(8320,8123,2)
(7870,7973,2)
(292,7760,2)
(4397,822,2)
(731,5586,2)
(3604,8131,2)
(200,904,2)
(476,7491,2)
(5107,1657,2)
(30,4604,2)
(9090,115,2)
(2698,5156,2)
(6355,2754,2)
(6466,46,2)
(9135,4793,2)
(1916,6155,2)
(3666,8257,2)
(1634,3295,2)
(1523,1782,2)
(5433,6533,2)
(9141,7938,2)
(8281,408,2)
(1818,3782,2)
(4518,7841,2)
(7869,1888,2)
(4420,8538,2)
(1405,2765,2)
(6699,1648,2)
(4984,8756,2)
(5584,8391,2)
(3545,8391,2)
(7334,7628,2)
(3260,5204,2)
(8112,904,2)
(2735,7893,2)
(3839,459,2)
(3804,9130,2)
(4926,8405,2)
(3788,1911,2)
(5269,4632,2)
(5088,6155,2)
(392,457,2)
(7050,3294,2)
(3260,8391,2)
(2744,2187,2)
(4566,2538,2)
(9068,1312,2)
(5556,5988,2)
(919,1954,2)
(4020,918,2)
(8023,7628,2)
(1468,2771,2)
(1911,5454,2)
(4229,5204,2)
(1022,2210,2)
(3945,553,2)
(8038,270,2)
(1363,115,2)
(5070,3488,2)
(3047,3701,2)
(5543,1001,2)
(1703,4326,2)
(5079,4408,2)
(403,2229,2)
(5877,5698,2)
(6880,4095,2)
(8510,1107,2)
(4824,1705,2)
(529,4337,2)
(1147,6155,2)
(4214,4253,2)
(596,8756,2)
(1266,1048,2)
(4946,7821,2)
(4362,6687,2)
(9043,6199,2)
(581,6104,2)
(2487,2834,2)
(6710,4861,2)
(524,6386,2)
(746,2139,2)
(6552,4579,2)
(1419,3543,2)
(7068,2835,2)
(6153,2344,2)
(5809,3215,2)
(2640,8391,2)
(4980,8756,2)
(1956,8297,2)
(4172,3823,2)
(946,6155,2)
(4838,4976,2)
(105,1782,2)
(4931,8793,2)
(4452,872,2)
(8573,4104,2)
(8997,1987,2)
(3484,4579,2)
(6758,5698,2)
(8836,1326,2)
(3871,6662,2)
(1564,6155,2)
(5113,8431,2)
(4501,1782,2)
(5537,3192,2)
(4454,6385,2)
(7330,6804,2)
(7328,5516,2)
(5219,2866,2)
(4814,8391,2)
(4113,6155,2)
(3254,7765,2)
(6944,2964,2)
(2287,3565,2)
(6816,1149,2)
(1121,109,2)
(5739,3906,2)
(803,4558,2)
(8142,7888,2)
(8289,5752,2)
(740,6867,2)
(3312,4912,2)
(5435,6385,2)
(7453,1222,2)
(9094,4994,2)
(7392,2299,2)
(5545,7146,2)
(8845,2104,2)
(5249,6888,2)
(1231,2592,2)
(2098,1705,2)
(4375,929,2)
(3804,8111,2)
(7611,1274,2)
(7861,2210,2)
(3101,115,2)
(6224,1954,2)
(1607,2053,2)
(6983,7841,2)
(5689,7760,2)
(5377,5586,2)
(7063,115,2)
(9004,115,2)
(4249,5854,2)
(6230,2537,2)
(90,3906,2)
(2541,1657,2)
(6886,1948,2)
(8496,6289,2)
(914,7258,2)
(3335,1488,2)
(6430,8391,2)
(5914,7103,2)
(8828,1235,2)
(3126,6613,2)
(4628,6308,2)
(358,115,2)
(3793,5145,2)
(3300,115,2)
(3546,403,2)
(1471,5027,2)
(6854,1638,2)
(8305,2053,2)
(4052,4124,2)
(7489,403,2)
(7097,5512,2)
(4725,453,2)
(5698,3427,2)
(5144,904,2)
(8189,3320,2)
(8030,4289,2)
(474,7242,2)
(2454,5501,2)
(5454,8756,2)
(4650,6084,2)
(8199,2366,2)
(7750,4500,2)
(3652,6385,2)
(8191,4435,2)
(4646,4108,2)
(7486,340,2)
(6413,4253,2)
(2273,706,2)
(2004,1304,2)
(8966,2845,2)
(2731,3433,2)
(1647,3095,2)
(6528,7405,2)
(4959,2053,2)
(745,5543,2)
(5649,8391,2)
(8512,4976,2)
(2808,7056,2)
(5621,3752,2)
(4385,7828,2)
(7367,8391,2)
(8335,4490,2)
(1549,3906,2)
(4001,7765,2)
(3440,2580,2)
(8713,8391,2)
(354,8432,2)
(8170,3863,2)
(4697,4908,2)
(1644,3782,2)
(9021,8431,2)
(2504,5647,2)
(2667,2978,2)
(1391,2465,2)
(4561,609,2)
(7142,8756,2)
(3878,5251,2)
(2869,9096,2)
(2434,403,2)
(8140,5204,2)
(6597,2187,2)
(1471,4876,2)
(6764,8252,2)
(5220,7762,2)
(2099,9059,2)
(3554,6677,2)
(257,7294,2)
(1784,6155,2)
(2513,2191,2)
(3024,1656,2)
(3804,8458,2)
(7098,4945,2)
(5533,1111,2)
(4009,6155,2)
(7373,1656,2)
(2809,6155,2)
(9026,2187,2)
(7523,4236,2)
(8296,8391,2)
(4580,8391,2)
(3501,8209,2)
(4900,7923,2)
(1415,2681,2)
(4638,6858,2)
(6459,706,2)
(3824,904,2)
(1017,2740,2)
(6884,115,2)
(1785,3758,2)
(6766,1974,2)
(2136,1459,2)
(7127,3198,2)
(2961,1573,2)
(1204,3320,2)
(1008,459,2)
(8214,8756,2)
(2688,2845,2)
(1247,6155,2)
(1184,8994,2)
(1452,7590,2)
(6049,7541,2)
(5884,459,2)
(2002,4319,2)
(5938,1171,2)
(689,1535,2)
(6791,2260,2)
(537,5755,2)
(8723,115,2)
(4173,4326,2)
(6384,1986,2)
(3278,8523,2)
(8154,6155,2)
(5452,8107,2)
(5481,4641,2)
(8982,1709,2)
(159,2938,2)
(4089,8391,2)
(6713,3218,2)
(8510,4876,2)
(1121,2935,2)
(1282,5586,2)
(8370,5204,2)
(1392,8391,2)
(5893,3640,2)
(4768,6858,2)
(5456,6730,2)
(6317,115,2)
(5765,410,2)
(7616,8187,2)
(8259,115,2)
(8108,5914,2)
(6159,3621,2)
(2618,8695,2)
(158,3312,2)
(654,6659,2)
(794,793,2)
(3805,7001,2)
(2823,8391,2)
(4805,7136,2)
(7980,3875,2)
(3005,5204,2)
(2116,536,2)
(8038,6968,2)
(2361,5540,2)
(2004,6155,2)
(6726,5156,2)
(6828,226,2)
(662,8107,2)
(5958,6544,2)
(511,7977,2)
(9043,3380,2)
(3625,8391,2)
(8125,5752,2)
(6886,8756,2)
(4664,4285,2)
(6313,7258,2)
(2996,8756,2)
(5764,7940,2)
(1829,6935,2)
(7391,1560,2)
(5986,2835,2)
(7626,8021,2)
(5810,4697,2)
(5688,7493,2)
(538,6446,2)
(3194,5698,2)
(2254,807,2)
(7278,5237,2)
(7883,8391,2)
(618,2706,2)
(101,115,2)
(1819,1401,2)
(6158,115,2)
(8242,8391,2)
(6121,5156,2)
(7660,115,2)
(2679,3295,2)
(94,7851,2)
(7057,8391,2)
(5271,6155,2)
(8617,1235,2)
(6509,1980,2)
(6656,115,2)
(572,115,2)
(933,1500,2)
(928,1311,2)
(8454,1769,2)
(1234,7841,2)
(2763,6200,2)
(3445,8241,2)
(1322,8391,2)
(6039,7143,2)
(1369,4876,2)
(6575,191,2)
(6605,4285,2)
(4054,7514,2)
(8505,1605,2)
(2005,7033,2)
(3637,9007,2)
(5403,1830,2)
(6280,7200,2)
(1245,6867,2)
(6844,6950,2)
(1773,8756,2)
(3353,3381,2)
(2424,6155,2)
(2858,4547,2)
(7785,7628,2)
(3198,6998,2)
(4160,4679,2)
(3327,5712,2)
(1415,4386,2)
(1130,8756,2)
(8397,2130,2)
(9068,7180,2)
(8710,8806,2)
(2475,8391,2)
(6485,1972,2)
(3285,4876,2)
(5027,3507,2)
(1134,7054,2)
(1332,6907,2)
(4065,6155,2)
(4421,7909,2)
(4488,8065,2)
(5193,115,2)
(9109,5204,2)
(2081,5540,2)
(5214,8458,2)
(8655,3306,2)
(849,1657,2)
(2226,8226,2)
(1799,7083,2)
(7318,7197,2)
(773,1240,2)
(8036,91,2)
(2544,1405,2)
(2166,6132,2)
(853,1204,2)
(2238,5027,2)
(7404,6155,2)
(5062,4343,2)
(3649,2158,2)
(7230,4842,2)
(6724,2060,2)
(2293,115,2)
(497,4301,2)
(3265,4435,2)
(1013,5586,2)
(4043,8391,2)
(4948,9140,2)
(7296,750,2)
(491,7514,2)
(7773,8756,2)
(6453,7405,2)
(4423,6121,2)
(1612,7765,2)
(1040,3874,2)
(4419,6155,2)
(3430,8391,2)
(5604,7186,2)
(2929,8811,2)
(8471,3891,2)
(8549,4837,2)
(649,2964,2)
(8891,8493,2)
(7833,2043,2)
(4529,8889,2)
(5577,4088,2)
(5932,9083,2)
(4400,4945,2)
(6449,2845,2)
(8107,6858,2)
(6592,5605,2)
(3621,1158,2)
(7541,7405,2)
(8726,8660,2)
(461,2832,2)
(5224,8756,2)
(4378,8391,2)
(7029,6080,2)
(5260,8756,2)
(8581,7874,2)
(9010,115,2)
(7150,2036,2)
(6360,3621,2)
(810,6479,2)
(5425,2344,2)
(1186,92,2)
(6454,8391,2)
(7255,3218,2)
(3199,8756,2)
(7821,6289,2)
(1600,1166,2)
(7709,1311,2)
(4389,115,2)
(6223,8391,2)
(4277,2036,2)
(4861,4576,2)
(7002,1311,2)
(6217,3965,2)
(4174,3752,2)
(2745,874,2)
(2780,2445,2)
(783,5881,2)
(5420,6865,2)
(1411,3962,2)
(5369,8391,2)
(5688,1048,2)
(5568,8856,2)
(3,2036,2)
(8873,7940,2)
(3992,6687,2)
(4532,7354,2)
(2965,2556,2)
(7947,8889,2)
(351,6919,2)
(862,3621,2)
(611,6592,2)
(8531,8815,2)
(2608,6662,2)
(455,5752,2)
(7962,5698,2)
(3922,4583,2)
(7409,2964,2)
(325,7628,2)
(4584,1782,2)
(8693,8670,2)
(5871,4582,2)
(4625,115,2)
(4516,7977,2)
(5003,54,2)
(6123,3320,2)
(2967,270,2)
(1956,4749,2)
(7532,3621,2)
(4247,2206,2)
(353,8391,2)
(3106,2559,2)
(7462,1770,2)
(2281,7224,2)
(5494,9130,2)
(4043,2845,2)
(8838,3417,2)
(1858,2559,2)
(6479,8756,2)
(5507,3868,2)
(7264,7711,2)
(3339,2130,2)
(3213,8458,2)
(4916,8756,2)
(6348,6336,2)
(5781,46,2)
(7164,408,2)
(5504,3427,2)
(5385,5374,2)
(8718,7354,2)
(1769,115,2)
(1967,8391,2)
(7545,4389,2)
(1044,115,2)
(3262,8493,2)
(2603,7514,2)
(3649,5129,2)
(4552,3312,2)
(4918,5649,2)
(1182,408,2)
(3855,5958,2)
(6950,7262,2)
(1362,4253,2)
(2113,846,2)
(3820,3456,2)
(9008,1954,2)
(4056,115,2)
(5810,5419,2)
(2034,3382,2)
(3170,5549,2)
(4230,5684,2)
(3691,72,2)
(1647,7760,2)
(5907,4698,2)
(7771,4333,2)
(1115,4236,2)
(8628,2366,2)
(1997,2191,2)
(4650,3875,2)
(5167,7001,2)
(1987,8560,2)
(267,6649,2)
(8476,4632,2)
(5608,777,2)
(4375,148,2)
(1448,4326,2)
(7790,4581,2)
(4674,6155,2)
(388,6971,2)
(698,5540,2)
(3278,6148,2)
(7857,3384,2)
(1694,6385,2)
(1121,8864,2)
(2084,4697,2)
(3530,8358,2)
(8749,1987,2)
(6254,4376,2)
(7626,1158,2)
(1259,5204,2)
(1748,5374,2)
(6970,7977,2)
(1070,164,2)
(8332,2030,2)
(5428,1002,2)
(7159,8391,2)
(841,1311,2)
(333,904,2)
(895,2,2)
(3425,904,2)
(2502,2256,2)
(2498,8403,2)
(8799,4,2)
(6354,6182,2)
(1418,92,2)
(5830,3965,2)
(8660,4793,2)
(2730,3812,2)
(2977,8751,2)
(8833,1370,2)
(171,1742,2)
(2543,3215,2)
(7509,5069,2)
(459,1085,2)
(3347,8391,2)
(1462,2845,2)
(6600,7186,2)
(6419,4515,2)
(7790,403,2)
(4818,2396,2)
(1039,6385,2)
(5901,2834,2)
(2293,270,2)
(4375,6356,2)
(2765,4579,2)
(1050,8431,2)
(5719,115,2)
(5101,2191,2)
(6316,3814,2)
(2066,5605,2)
(6502,7966,2)
(7645,8523,2)
(1853,7841,2)
(4038,7515,2)
(3992,7724,2)
(3416,5586,2)
(4030,5540,2)
(5776,46,2)
(7106,8923,2)
(7196,3621,2)
(1794,7611,2)
(5497,4579,2)
(8061,4007,2)
(7888,403,2)
(1937,115,2)
(5337,7316,2)
(6800,7917,2)
(1613,4388,2)
(1597,7852,2)
(980,874,2)
(7752,6479,2)
(4751,6385,2)
(7652,2191,2)
(2139,115,2)
(3883,904,2)
(7695,8756,2)
(5416,6070,2)
(6135,3879,2)
(2216,7614,2)
(5684,2879,2)
(5096,1299,2)
(5812,8107,2)
(5950,4876,2)
(1836,7917,2)
(4958,8778,2)
(6327,2283,2)
(5869,7888,2)
(8429,4353,2)
(4758,2845,2)
(5573,8527,2)
(4947,7180,2)
(3988,1459,2)
(7171,4467,2)
(6814,3553,2)
(3877,8756,2)
(6251,8107,2)
(895,115,2)
(5521,2835,2)
(1772,1657,2)
(5787,3123,2)
(6329,904,2)
(4064,8549,2)
(4477,3823,2)
(1969,8391,2)
(7940,2752,2)
(8650,5540,2)
(6097,4565,2)
(2237,4916,2)
(1212,1149,2)
(4681,4984,2)
(6138,2,2)
(4416,4697,2)
(7056,8391,2)
(8014,4289,2)
(5048,2537,2)
(1337,1002,2)
(6007,507,2)
(8373,2539,2)
(3222,3758,2)
(1293,3706,2)
(362,6155,2)
(3861,8928,2)
(7962,6179,2)
(2687,8746,2)
(2381,4124,2)
(5817,3863,2)
(4753,6155,2)
(8291,2983,2)
(3119,115,2)
(6892,3752,2)
(4178,5615,2)
(2272,6858,2)
(7972,3942,2)
(1022,115,2)
(868,3295,2)
(3270,5586,2)
(2748,1657,2)
(3130,4641,2)
(1273,6804,2)
(8018,2250,2)
(205,7156,2)
(4840,8391,2)
(6435,8391,2)
(2947,4556,2)
(702,284,2)
(1873,8391,2)
(9098,1062,2)
(6396,8832,2)
(8830,115,2)
(1125,1407,2)
(7531,740,2)
(4408,403,2)
(2187,208,2)
(118,4619,2)
(2984,706,2)
(5409,7940,2)
(3278,3979,2)
(4326,785,2)
(8432,1488,2)
(7947,7340,2)
(8719,8391,2)
(4167,2206,2)
(2558,92,2)
(727,8391,2)
(1378,408,2)
(7782,7569,2)
(4828,6285,2)
(8244,3812,2)
(2670,7870,2)
(1017,8481,2)
(8633,4874,2)
(9069,2765,2)
(695,5712,2)
(5653,507,2)
(3046,517,2)
(5243,8756,2)
(4095,9140,2)
(2597,6155,2)
(4628,9017,2)
(6430,4088,2)
(5961,2422,2)
(7847,115,2)
(6721,7001,2)
(4522,5397,2)
(498,5204,2)
(55,6285,2)
(6064,7577,2)
(1235,823,2)
(6522,8391,2)
(7812,8391,2)
(1701,2866,2)
(2075,3108,2)
(3867,1310,2)
(5008,2445,2)
(2288,115,2)
(7104,6289,2)
(4506,1020,2)
(4375,7625,2)
(2341,5251,2)
(2224,8162,2)
(4371,8254,2)
(6465,4088,2)
(2143,403,2)
(4773,8391,2)
(1982,2260,2)
(5646,6804,2)
(694,916,2)
(2406,6155,2)
(4462,5586,2)
(2987,3318,2)
(2866,2397,2)
(4551,5777,2)
(3301,1254,2)
(8865,7802,2)
(274,9066,2)
(3933,5586,2)
(5078,8756,2)
(4346,4155,2)
(1139,5752,2)
(1908,7541,2)
(4253,5961,2)
(163,4357,2)
(7367,115,2)
(2315,5698,2)
(7220,874,2)
(5914,5829,2)
(6530,8034,2)
(8929,4985,2)
(6267,46,2)
(5358,4945,2)
(8742,7760,2)
(5256,5829,2)
(2149,1070,2)
(2020,8184,2)
(2368,3823,2)
(4332,7959,2)
(8633,646,2)
(7215,4253,2)
(535,3823,2)
(7735,3823,2)
(5658,4326,2)
(4620,6041,2)
(7067,115,2)
(6962,8756,2)
(4805,1169,2)
(5593,3565,2)
(8428,4326,2)
(4196,9140,2)
(6285,3097,2)
(7350,3449,2)
(6301,2344,2)
(7569,2644,2)
(8889,115,2)
(4453,6922,2)
(4365,1705,2)
(5560,6155,2)
(2385,8391,2)
(9090,3201,2)
(4577,8107,2)
(1632,7760,2)
(7198,2845,2)
(8115,9096,2)
(7983,3095,2)
(774,115,2)
(6137,4984,2)
(3250,2187,2)
(1222,5156,2)
(8085,2592,2)
(8319,2344,2)
(6795,2845,2)
(3800,4401,2)
(4470,4398,2)
(8249,7711,2)
(121,8391,2)
(1282,8391,2)
(8935,408,2)
(7507,2187,2)
(6003,6731,2)
(7617,6132,2)
(1554,6613,2)
(1217,5156,2)
(5071,8756,2)
(4375,2186,2)
(7396,3286,2)
(9050,6109,2)
(8470,8391,2)
(5145,1653,2)
(6753,7411,2)
(5378,408,2)
(1563,4679,2)
(1045,115,2)
(2469,8756,2)
(2535,8751,2)
(5897,6132,2)
(3585,2835,2)
(7931,5698,2)
(1370,1493,2)
(4497,115,2)
(5047,2771,2)
(8318,7796,2)
(3062,115,2)
(6284,3215,2)
(6849,6132,2)
(6376,226,2)
(7910,3758,2)
(5564,6851,2)
(5474,781,2)
(6102,7514,2)
(7759,8756,2)
(5346,7066,2)
(1710,1785,2)
(4413,5156,2)
(5987,7628,2)
(1623,2537,2)
(3731,3095,2)
(228,4032,2)
(5593,3215,2)
(4375,6649,2)
(331,348,2)
(1415,8160,2)
(150,4558,2)
(4927,6179,2)
(8544,5752,2)
(3751,4205,2)
(6570,1096,2)
(2099,6583,2)
(1626,3963,2)
(5950,5156,2)
(2091,8833,2)
(2647,8756,2)
(6055,46,2)
(6072,6053,2)
(5156,4403,2)
(8006,6155,2)
(248,8391,2)
(3509,8111,2)
(595,8391,2)
(871,8756,2)
(6534,904,2)
(7384,1312,2)
(7798,5156,2)
(2203,462,2)
(117,46,2)
(4183,4995,2)
(2168,2690,2)
(6366,6488,2)
(5195,2943,2)
(548,8830,2)
(8541,7927,2)
(6369,3250,2)
(6483,1916,2)
(1760,8756,2)
(8455,7973,2)
(6213,92,2)
(2287,4524,2)
(2096,3436,2)
(5638,700,2)
(9077,8461,2)
(3904,2375,2)
(6529,2283,2)
(6464,7989,2)
(8037,5089,2)
(5761,3752,2)
(4530,1235,2)
(1924,8391,2)
(2666,5156,2)
(9119,6804,2)
(5432,874,2)
(3791,8391,2)
(1368,3254,2)
(5496,4236,2)
(5799,4408,2)
(3646,5836,2)
(2372,1760,2)
(6458,7354,2)
(6598,1705,2)
(3740,8756,2)
(6214,2295,2)
(4506,2796,2)
(3647,2283,2)
(7554,8756,2)
(1238,8391,2)
(6111,951,2)
(2788,8454,2)
(5494,3215,2)
(7771,3782,2)
(6502,8614,2)
(2118,813,2)
(5796,7841,2)
(1415,7114,2)
(5135,8756,2)
(9035,6797,2)
(7088,3288,2)
(3877,8391,2)
(536,5294,2)
(3822,5501,2)
(1792,115,2)
(3847,115,2)
(2068,4793,2)
(4253,2858,2)
(3835,5204,2)
(4468,2043,2)
(3184,7762,2)
(2287,7039,2)
(7363,5434,2)
(2693,7262,2)
(4276,270,2)
(5868,8074,2)
(7891,1657,2)
(5,8391,2)
(2089,5101,2)
(4413,4819,2)
(5920,3965,2)
(918,780,2)
(8947,116,2)
(8120,874,2)
(641,2854,2)
(1550,3541,2)
(1496,7353,2)
(6471,46,2)
(6666,798,2)
(3342,8756,2)
(2353,7258,2)
(3481,226,2)
(3834,5156,2)
(4430,2835,2)
(7477,6132,2)
(774,7514,2)
(7452,5470,2)
(5711,7940,2)
(6539,3530,2)
(1895,3526,2)
(5529,8756,2)
(1312,3906,2)
(3756,3142,2)
(3742,1311,2)
(5871,2835,2)
(1915,4664,2)
(5726,7168,2)
(2334,1311,2)
(6494,7373,2)
(1974,3758,2)
(1850,8677,2)
(8308,2191,2)
(8830,3218,2)
(3509,700,2)
(2220,7432,2)
(2615,8756,2)
(8935,7058,2)
(5944,3812,2)
(5879,3810,2)
(7148,3752,2)
(3557,4576,2)
(5819,1794,2)
(5171,6132,2)
(3792,3963,2)
(1317,2559,2)
(549,8176,2)
(3718,3706,2)
(6348,4697,2)
(2194,8756,2)
(8610,8889,2)
(1724,904,2)
(1174,8756,2)
(7456,6155,2)
(1017,8677,2)
(2035,3493,2)
(2312,3781,2)
(557,3218,2)
(4219,5156,2)
(1712,4876,2)
(713,7760,2)
(1848,3427,2)
(5227,115,2)
(396,4576,2)
(7097,7577,2)
(741,6575,2)
(4020,6155,2)
(6635,1657,2)
(6386,4880,2)
(7300,5847,2)
(7304,3969,2)
(6001,1705,2)
(2114,1657,2)
(8641,904,2)
(129,2326,2)
(2862,8756,2)
(7957,3887,2)
(5223,7917,2)
(7328,408,2)
(7075,8391,2)
(3774,8391,2)
(3250,115,2)
(850,8681,2)
(3285,6791,2)
(4844,2983,2)
(5907,4565,2)
(4174,7001,2)
(3768,2241,2)
(3596,5829,2)
(5275,7760,2)
(1534,7821,2)
(2771,3274,2)
(148,1235,2)
(2483,3823,2)
(4774,7514,2)
(3804,7280,2)
(480,8756,2)
(7000,3004,2)
(8806,5698,2)
(3291,669,2)
(422,1653,2)
(2452,309,2)
(2958,3427,2)
(4517,408,2)
(3128,7398,2)
(6529,8057,2)
(7751,6155,2)
(228,8843,2)
(2161,3103,2)
(882,6407,2)
(536,5949,2)
(5466,6826,2)
(3928,2644,2)
(2089,2191,2)
(133,8756,2)
(5391,2020,2)
(7140,2559,2)
(5486,115,2)
(8273,6155,2)
(1792,2845,2)
(8126,5498,2)
(2593,4349,2)
(4351,1493,2)
(4021,4565,2)
(3934,2468,2)
(6193,1254,2)
(4687,3043,2)
(6442,1254,2)
(411,3752,2)
(8694,7129,2)
(4873,4587,2)
(5715,4984,2)
(7038,8391,2)
(3981,8756,2)
(3243,5886,2)
(2358,6317,2)
(5983,6577,2)
(7081,5204,2)
(6014,4095,2)
(4802,5251,2)
(3732,8832,2)
(8065,7570,2)
(5958,8756,2)
(6558,1785,2)
(5767,6867,2)
(8951,4333,2)
(6993,2858,2)
(5055,706,2)
(8712,402,2)
(7429,8756,2)
(6847,794,2)
(6531,6155,2)
(4822,6357,2)
(5538,5712,2)
(4403,6485,2)
(565,1905,2)
(8326,2835,2)
(268,7180,2)
(9097,7940,2)
(8734,5698,2)
(4765,8107,2)
(2520,6194,2)
(1259,7337,2)
(5510,4388,2)
(2053,6337,2)
(716,4697,2)
(5946,7628,2)
(6543,2445,2)
(2365,1888,2)
(6215,8391,2)
(1719,8470,2)
(4182,5829,2)
(2480,2866,2)
(5461,3151,2)
(1843,8756,2)
(1607,7248,2)
(3804,2861,2)
(3909,3812,2)
(7900,2765,2)
(3217,5397,2)
(4042,507,2)
(5617,3382,2)
(1087,1173,2)
(8715,1488,2)
(3176,9096,2)
(3150,546,2)
(8884,2187,2)
(6931,4376,2)
(3595,4579,2)
(6340,3530,2)
(3059,3103,2)
(5547,2537,2)
(3758,689,2)
(6593,1905,2)
(5317,3758,2)
(5755,7353,2)
(8105,3382,2)
(7532,6385,2)
(6299,777,2)
(5661,3696,2)
(1415,8471,2)
(7130,6479,2)
(5982,115,2)
(3396,7210,2)
(8568,1105,2)
(7418,3553,2)
(8837,403,2)
(1354,4285,2)
(486,6179,2)
(4063,2866,2)
(5408,1419,2)
(7626,1280,2)
(7097,7079,2)
(8293,6132,2)
(3865,4522,2)
(2957,3095,2)
(8523,6367,2)
(3004,7940,2)
(8415,25,2)
(3082,8756,2)
(1380,8391,2)
(3293,3781,2)
(3544,1709,2)
(2802,5069,2)
(6482,5454,2)
(4628,4379,2)
(4693,3363,2)
(5645,5719,2)
(1657,8061,2)
(4989,1401,2)
(4988,5752,2)
(1511,689,2)
(4720,2866,2)
(6644,7614,2)
(5887,8677,2)
(8128,1468,2)
(3069,874,2)
(7931,6179,2)
(2429,5752,2)
(7254,1401,2)
(7912,7001,2)
(2305,7828,2)
(3854,46,2)
(870,7155,2)
(9036,8107,2)
(6008,466,2)
(2569,4343,2)
(5935,8832,2)
(2217,6417,2)
(3804,489,2)
(3138,7405,2)
(756,8431,2)
(787,6479,2)
(1319,588,2)
(5881,2445,2)
(7878,8756,2)
(4894,609,2)
(5216,5698,2)
(6907,1250,2)
(7427,46,2)
(2954,5204,2)
(3918,2036,2)
(1004,5698,2)
(2543,1158,2)
(5194,5251,2)
(6877,4576,2)
(5428,2043,2)
(3398,5501,2)
(307,2771,2)
(1705,2036,2)
(8589,3142,2)
(2212,7552,2)
(4607,5698,2)
(1986,7536,2)
(4781,4333,2)
(446,3198,2)
(5977,6659,2)
(3782,1685,2)
(453,3095,2)
(5258,8398,2)
(7012,3123,2)
(3408,1987,2)
(2268,1709,2)
(3875,7393,2)
(8050,6155,2)
(354,4088,2)
(1572,6495,2)
(8538,2093,2)
(5359,6804,2)
(1415,4587,2)
(2150,8756,2)
(7306,8391,2)
(5326,2537,2)
(2953,2206,2)
(2376,1709,2)
(4601,6451,2)
(3774,7628,2)
(3708,1657,2)
(2288,5752,2)
(8432,4088,2)
(7577,5332,2)
(2947,4579,2)
(1501,5900,2)
(2132,8493,2)
(6078,7354,2)
(4975,8129,2)
(5583,6179,2)
(5951,1785,2)
(7693,4697,2)
(4222,1110,2)
(7634,5316,2)
(397,5498,2)
(7483,1220,2)
(2859,2445,2)
(8497,115,2)
(1065,8756,2)
(4774,3699,2)
(1415,3889,2)
(966,8756,2)
(7276,8580,2)
(3594,6070,2)
(8254,5498,2)
(1867,7354,2)
(5366,6971,2)
(8,6385,2)
(5722,1853,2)
(3213,3889,2)
(50,5351,2)
(6391,6791,2)
(5733,1235,2)
(502,4289,2)
(1803,1785,2)
(574,8008,2)
(7045,7514,2)
(5268,4342,2)
(6971,7514,2)
(3868,115,2)
(360,904,2)
(1613,8313,2)
(5862,4604,2)
(6891,9003,2)
(8131,6784,2)
(3804,1405,2)
(2298,6258,2)
(827,4435,2)
(5494,1158,2)
(3036,6891,2)
(6888,115,2)
(4724,3899,2)
(8024,1082,2)
(1861,4793,2)
(2775,2845,2)
(8654,4945,2)
(3233,8751,2)
(5056,115,2)
(6632,115,2)
(5755,6678,2)
(111,6179,2)
(2382,5069,2)
(5394,115,2)
(4209,4679,2)
(7152,3752,2)
(4862,5586,2)
(4992,8794,2)
(1118,2210,2)
(3451,8322,2)
(1516,8598,2)
(482,92,2)
(2921,6048,2)
(2610,3052,2)
(6725,6155,2)
(2797,7754,2)
(6922,8431,2)
(3456,115,2)
(595,2983,2)
(6993,7888,2)
(6736,5506,2)
(6749,874,2)
(530,8108,2)
(5166,3054,2)
(3288,8391,2)
(1628,4793,2)
(859,8756,2)
(713,6858,2)
(1222,4876,2)
(6006,7760,2)
(4314,2506,2)
(522,7001,2)
(4309,7760,2)
(280,1954,2)
(5118,8289,2)
(2534,2845,2)
(2246,3175,2)
(9081,8756,2)
(577,5829,2)
(8859,609,2)
(2826,1888,2)
(9122,7762,2)
(5501,2844,2)
(8769,8756,2)
(8815,155,2)
(4932,3218,2)
(669,2476,2)
(4472,5881,2)
(5041,403,2)
(8155,5156,2)
(4800,5089,2)
(1546,6660,2)
(7646,115,2)
(6798,2835,2)
(4431,115,2)
(272,6150,2)
(1415,7757,2)
(295,6858,2)
(8184,6975,2)
(8628,8199,2)
(5494,7039,2)
(5713,7552,2)
(6198,6662,2)
(6838,2907,2)
(4125,4385,2)
(2258,8088,2)
(4594,292,2)
(6109,689,2)
(8523,2172,2)
(4375,8111,2)
(3251,1972,2)
(7643,6778,2)
(3705,1311,2)
(2115,8777,2)
(5558,2765,2)
(2317,8391,2)
(1158,1972,2)
(1960,8751,2)
(4272,4088,2)
(2677,115,2)
(8774,7630,2)
(1857,4467,2)
(4061,4285,2)
(6155,6677,2)
(4912,4001,2)
(5800,1705,2)
(7626,1270,2)
(1415,3518,2)
(385,1173,2)
(5984,7628,2)
(6422,8832,2)
(5395,1563,2)
(1765,7233,2)
(3673,1954,2)
(7419,1583,2)
(1083,4576,2)
(5383,8391,2)
(8057,8391,2)
(5123,5721,2)
(5640,8391,2)
(4245,5237,2)
(6003,1657,2)
(3460,6804,2)
(240,4945,2)
(3433,777,2)
(3607,7514,2)
(1762,6103,2)
(5638,6563,2)
(5076,4976,2)
(7889,4942,2)
(7587,548,2)
(437,2845,2)
(255,6155,2)
(534,4289,2)
(1420,8129,2)
(4149,4579,2)
(5,3823,2)
(2630,8107,2)
(8424,7760,2)
(7810,7828,2)
(8479,5226,2)
(1014,2983,2)
(5684,6150,2)
(5605,536,2)
(7656,3451,2)
(2301,6858,2)
(6495,5126,2)
(567,7514,2)
(7492,7868,2)
(4723,3454,2)
(618,2592,2)
(1021,2835,2)
(2211,542,2)
(5161,904,2)
(874,6280,2)
(1698,7940,2)
(4892,7186,2)
(4345,12,2)
(2814,7828,2)
(2895,2288,2)
(624,4711,2)
(2157,115,2)
(8481,7730,2)
(5499,2707,2)
(8493,4698,2)
(8612,7790,2)
(5120,8756,2)
(2069,2892,2)
(3986,5298,2)
(6740,8108,2)
(3630,408,2)
(9034,8307,2)
(4396,5540,2)
(8891,5829,2)
(8901,2866,2)
(3401,3821,2)
(763,4697,2)
(7735,5156,2)
(3837,8391,2)
(8935,7296,2)
(1507,408,2)
(4836,6804,2)
(336,6804,2)
(1737,6155,2)
(4459,6155,2)
(8878,5498,2)
(9017,4326,2)
(2668,3095,2)
(8057,115,2)
(7980,9059,2)
(4375,1280,2)
(5631,8756,2)
(6870,5540,2)
(5156,1972,2)
(4641,3867,2)
(4877,6791,2)
(5556,5312,2)
(2244,7828,2)
(2317,115,2)
(4039,3823,2)
(8072,453,2)
(6404,706,2)
(2623,115,2)
(7461,4580,2)
(2925,7940,2)
(2210,1008,2)
(4074,517,2)
(6513,5162,2)
(1811,2,2)
(7881,6649,2)
(892,9096,2)
(1684,7940,2)
(3725,5223,2)
(101,8756,2)
(8096,7001,2)
(7595,3095,2)
(4245,7514,2)
(1809,1181,2)
(3402,2187,2)
(8218,7405,2)
(5461,8778,2)
(1727,115,2)
(8771,6155,2)
(6935,8756,2)
(2260,5698,2)
(5839,228,2)
(5325,3758,2)
(8970,706,2)
(8437,8756,2)
(567,8274,2)
(2344,4308,2)
(9063,1488,2)
(3621,1280,2)
(8687,4388,2)
(1156,2036,2)
(5083,4915,2)
(6921,646,2)
(593,5540,2)
(5437,4697,2)
(2120,4576,2)
(7224,284,2)
(8623,2904,2)
(7856,7714,2)
(4051,8756,2)
(4263,7760,2)
(1376,8259,2)
(2299,5656,2)
(7735,3717,2)
(1276,517,2)
(903,4253,2)
(3354,7034,2)
(7244,7760,2)
(1877,3814,2)
(6661,1240,2)
(3905,1311,2)
(7406,2036,2)
(2758,5752,2)
(909,7628,2)
(1874,3660,2)
(6338,904,2)
(8441,306,2)
(3356,6008,2)
(4883,575,2)
(3844,8756,2)
(3318,115,2)
(7797,6289,2)
(8412,8756,2)
(8327,1656,2)
(1029,8391,2)
(6234,115,2)
(3080,5454,2)
(5975,4579,2)
(3821,8107,2)
(7233,6007,2)
(595,3451,2)
(6823,408,2)
(5697,6583,2)
(8949,2835,2)
(6762,8134,2)
(3108,4594,2)
(4622,1235,2)
(6366,6804,2)
(6263,3218,2)
(1872,2344,2)
(7187,6155,2)
(8834,3823,2)
(3804,3889,2)
(1171,6826,2)
(6971,8245,2)
(4284,5586,2)
(1418,6179,2)
(8634,7155,2)
(7105,5204,2)
(2389,46,2)
(3579,8391,2)
(5478,3218,2)
(1438,115,2)
(1729,115,2)
(2662,7514,2)
(5614,624,2)
(8756,7760,2)
(7150,7258,2)
(8318,4718,2)
(3551,5656,2)
(1947,8391,2)
(2444,403,2)
(47,3382,2)
(1582,2537,2)
(5269,2069,2)
(6681,4056,2)
(257,3823,2)
(1754,3621,2)
(4114,8289,2)
(5586,5958,2)
(410,4,2)
(3633,4249,2)
(1788,1954,2)
(1324,6385,2)
(3699,7514,2)
(5320,822,2)
(2839,2465,2)
(4750,5226,2)
(7298,1235,2)
(838,5058,2)
(6601,8756,2)
(6501,7917,2)
(3727,8756,2)
(1418,5829,2)
(7913,7514,2)
(532,5316,2)
(8193,6504,2)
(5638,1262,2)
(5037,4285,2)
(5733,2226,2)
(990,7262,2)
(4974,5755,2)
(6121,4876,2)
(7666,2199,2)
(6031,7917,2)
(8359,115,2)
(9014,408,2)
(2296,6826,2)
(1730,7514,2)
(6509,7628,2)
(2295,6995,2)
(2316,3577,2)
(4655,6155,2)
(383,8756,2)
(8300,8756,2)
(2342,2346,2)
(5702,6155,2)
(6854,8756,2)
(3621,8021,2)
(8021,4579,2)
(3924,7634,2)
(1209,7996,2)
(3207,115,2)
(7056,115,2)
(4085,5123,2)
(8564,2765,2)
(5029,4253,2)
(6419,700,2)
(4246,8815,2)
(7897,7828,2)
(6867,4214,2)
(6666,8391,2)
(4017,2866,2)
(1504,5374,2)
(2775,8391,2)
(5998,8391,2)
(6284,6649,2)
(3591,3823,2)
(4344,8815,2)
(1863,8756,2)
(2323,4994,2)
(1029,3814,2)
(1509,2367,2)
(7224,8391,2)
(6318,8391,2)
(8838,8391,2)
(1758,2157,2)
(4208,7514,2)
(5868,2043,2)
(8980,5069,2)
(8155,4876,2)
(5805,611,2)
(6103,8756,2)
(535,2036,2)
(4788,6613,2)
(7067,8391,2)
(4453,8431,2)
(6576,1254,2)
(2146,3095,2)
(553,6510,2)
(8075,9096,2)
(8861,7851,2)
(197,8391,2)
(6898,4153,2)
(2731,611,2)
(8549,151,2)
(1415,3377,2)
(1355,7413,2)
(1744,6867,2)
(6142,3023,2)
(3773,8391,2)
(2630,5812,2)
(241,8827,2)
(8047,4722,2)
(6245,53,2)
(7981,1705,2)
(6378,7569,2)
(8799,410,2)
(3370,8756,2)
(6440,6285,2)
(5887,4285,2)
(7626,6968,2)
(4761,6070,2)
(2591,8391,2)
(2041,403,2)
(951,6528,2)
(2351,7940,2)
(2295,1013,2)
(8889,8728,2)
(1530,6867,2)
(1415,2533,2)
(7317,6385,2)
(7338,2771,2)
(7346,7760,2)
(6343,3823,2)
(301,1488,2)
(4888,1240,2)
(2193,1705,2)
(7257,4404,2)
(584,1656,2)
(4439,7353,2)
(7602,1954,2)
(8667,4793,2)
(6308,7514,2)
(6614,3595,2)
(6255,6200,2)
(6762,5156,2)
(904,8432,2)
(3973,5451,2)
(5557,2834,2)
(2089,512,2)
(8117,1149,2)
(882,7628,2)
(4976,4637,2)
(1387,8391,2)
(3814,1705,2)
(5638,8441,2)
(6808,7473,2)
(3746,5408,2)
(7977,4565,2)
(3318,8391,2)
(5625,3095,2)
(3800,4292,2)
(686,7569,2)
(700,6073,2)
(569,611,2)
(5698,1848,2)
(4390,2370,2)
(8688,6662,2)
(3236,5012,2)
(7421,2007,2)
(5893,2465,2)
(8505,1203,2)
(2907,5874,2)
(2402,6804,2)
(4945,1765,2)
(889,3142,2)
(3884,1192,2)
(2961,5559,2)
(1770,3218,2)
(8059,5538,2)
(5298,6155,2)
(8800,3095,2)
(2776,5712,2)
(7626,8458,2)
(7281,2983,2)
(137,2036,2)
(6899,5932,2)
(3440,874,2)
(6723,115,2)
(3170,640,2)
(8463,8756,2)
(2644,6907,2)
(4409,3965,2)
(4329,7909,2)
(8238,1149,2)
(1526,5454,2)
(4326,569,2)
(4107,4908,2)
(2735,7291,2)
(1725,4886,2)
(2162,4253,2)
(2465,4865,2)
(9138,3488,2)
(8025,4253,2)
(4452,8756,2)
(3850,5033,2)
(2523,7628,2)
(8205,7940,2)
(1674,7841,2)
(2269,2260,2)
(9055,5033,2)
(2326,7628,2)
(7234,2587,2)
(4253,3983,2)
(3932,5801,2)
(5556,408,2)
(2817,8756,2)
(4415,1173,2)
(5536,7841,2)
(7007,5790,2)
(4465,2479,2)
(3346,1972,2)
(5321,1493,2)
(3534,115,2)
(4531,3553,2)
(5733,7514,2)
(6325,8756,2)
(725,6155,2)
(26,3123,2)
(4847,115,2)
(7239,1052,2)
(8567,8479,2)
(4531,8854,2)
(9072,7760,2)
(6777,4044,2)
(7980,3451,2)
(7931,3427,2)
(1810,3354,2)
(1206,2381,2)
(8441,4236,2)
(675,6795,2)
(4079,904,2)
(2850,7614,2)
(4703,7180,2)
(258,7940,2)
(4148,8756,2)
(4889,2450,2)
(4379,1782,2)
(5575,8107,2)
(1018,3123,2)
(6668,5454,2)
(7408,3875,2)
(5631,2917,2)
(3793,1653,2)
(5945,2771,2)
(7725,2771,2)
(5299,1653,2)
(2121,3810,2)
(8866,4205,2)
(7664,5156,2)
(3175,115,2)
(2506,115,2)
(4210,3123,2)
(8659,8136,2)
(5699,1705,2)
(2837,3222,2)
(1315,536,2)
(1272,4641,2)
(6744,2335,2)
(1454,3843,2)
(3783,855,2)
(6689,517,2)
(4558,7149,2)
(8947,7940,2)
(4971,8777,2)
(3103,8756,2)
(5096,2894,2)
(6457,7514,2)
(2741,8493,2)
(3857,8756,2)
(3183,3782,2)
(4863,1509,2)
(1637,8134,2)
(9018,2537,2)
(6082,1785,2)
(5100,7262,2)
(5790,4725,2)
(5921,517,2)
(1696,3123,2)
(918,6155,2)
(2537,150,2)
(6109,3534,2)
(1341,3363,2)
(6993,5204,2)
(4212,115,2)
(1440,8756,2)
(9034,2835,2)
(7253,2366,2)
(6509,3780,2)
(3735,2765,2)
(7044,4985,2)
(1759,2537,2)
(2448,1254,2)
(7552,1070,2)
(1995,2835,2)
(7398,8391,2)
(6246,115,2)
(5911,2445,2)
(1415,7760,2)
(5868,7514,2)
(895,8391,2)
(4181,6662,2)
(7647,3375,2)
(9112,218,2)
(5970,46,2)
(1303,7590,2)
(4464,6583,2)
(8270,1656,2)
(2932,1479,2)
(7265,2053,2)
(8879,8756,2)
(2935,2191,2)
(1155,92,2)
(1100,2199,2)
(4919,8658,2)
(958,5084,2)
(7374,8391,2)
(1750,2834,2)
(5144,8391,2)
(9074,1653,2)
(6118,6580,2)
(578,1648,2)
(3612,5172,2)
(7561,2866,2)
(5968,3906,2)
(3560,3108,2)
(7653,8523,2)
(4327,5828,2)
(6912,123,2)
(1309,410,2)
(8579,6497,2)
(2801,2453,2)
(424,3621,2)
(378,4541,2)
(2058,4272,2)
(8580,448,2)
(8077,123,2)
(7037,6971,2)
(7547,8756,2)
(2397,2191,2)
(8303,8431,2)
(4805,8756,2)
(1275,8431,2)
(7223,1463,2)
(1902,2206,2)
(1757,951,2)
(3632,6784,2)
(2987,7870,2)
(6727,6289,2)
(7006,8523,2)
(3356,8391,2)
(7626,4515,2)
(1764,111,2)
(559,5084,2)
(8279,5454,2)
(6809,6791,2)
(7759,3621,2)
(2401,2391,2)
(4036,8756,2)
(735,4793,2)
(6167,8433,2)
(7117,5454,2)
(2844,3123,2)
(7055,5070,2)
(727,8756,2)
(6914,5501,2)
(5506,4697,2)
(3832,1509,2)
(2922,5408,2)
(960,7570,2)
(8827,8751,2)
(67,7940,2)
(2468,6804,2)
(7494,2596,2)
(2969,1954,2)
(5263,1240,2)
(7657,4221,2)
(8203,2866,2)
(1724,338,2)
(915,8756,2)
(9099,4579,2)
(7211,7375,2)
(7156,611,2)
(2348,6155,2)
(6229,1653,2)
(6311,6155,2)
(1168,115,2)
(1175,7262,2)
(1712,8866,2)
(3459,1311,2)
(709,4253,2)
(5214,3889,2)
(1992,1888,2)
(6620,115,2)
(3123,7354,2)
(7031,2845,2)
(1208,115,2)
(3437,1785,2)
(5397,7354,2)
(266,7841,2)
(3001,403,2)
(3931,5498,2)
(4127,4697,2)
(2247,408,2)
(5519,2845,2)
(5923,91,2)
(3930,6155,2)
(7128,8756,2)
(2954,6428,2)
(1305,3791,2)
(367,6155,2)
(8169,2060,2)
(8925,3764,2)
(3804,8441,2)
(2139,8391,2)
(5574,6289,2)
(7366,408,2)
(1824,5204,2)
(2544,7280,2)
(2557,4253,2)
(5887,1915,2)
(5499,1603,2)
(533,7940,2)
(7821,7514,2)
(4369,4153,2)
(2782,115,2)
(4599,1311,2)
(6141,1149,2)
(8319,3218,2)
(6067,8391,2)
(4375,489,2)
(2260,8233,2)
(1238,8756,2)
(8788,6583,2)
(6112,7354,2)
(7514,1235,2)
(3336,410,2)
(3902,1525,2)
(4088,4974,2)
(7834,2835,2)
(7113,8391,2)
(8165,6636,2)
(8038,4515,2)
(2874,7765,2)
(3353,5204,2)
(5023,8756,2)
(6927,6070,2)
(6216,2983,2)
(5769,46,2)
(831,874,2)
(7886,1830,2)
(7090,4236,2)
(6821,8815,2)
(1657,7514,2)
(424,2344,2)
(6256,4974,2)
(7146,1223,2)
(1061,2845,2)
(32,8756,2)
(6933,3812,2)
(2624,3963,2)
(6080,3758,2)
(9126,7514,2)
(802,7765,2)
(2831,6132,2)
(2709,403,2)
(4230,7514,2)
(6528,3138,2)
(2086,6385,2)
(6808,6751,2)
(3960,5251,2)
(256,6907,2)
(3895,4474,2)
(1699,2191,2)
(3956,9140,2)
(7497,119,2)
(3858,6289,2)
(1371,5777,2)
(6419,8471,2)
(43,4343,2)
(7670,8391,2)
(6649,8391,2)
(5353,1311,2)
(5145,4314,2)
(66,1563,2)
(1726,5408,2)
(8694,2187,2)
(5072,6899,2)
(3807,8391,2)
(927,6995,2)
(6973,3965,2)
(8548,7628,2)
(2512,1785,2)
(7183,2559,2)
(4620,8986,2)
(1783,5156,2)
(299,2183,2)
(3213,700,2)
(2332,5162,2)
(942,5144,2)
(8832,6070,2)
(3760,4253,2)
(2951,2644,2)
(5275,6858,2)
(7297,7514,2)
(4565,5181,2)
(7104,3858,2)
(4491,92,2)
(7040,1065,2)
(1223,6125,2)
(4772,1682,2)
(7760,92,2)
(5805,7024,2)
(389,7001,2)
(1719,3810,2)
(6570,904,2)
(7991,1204,2)
(6807,8431,2)
(6056,2020,2)
(5435,1150,2)
(3968,228,2)
(8247,2187,2)
(11,3347,2)
(9092,916,2)
(6480,6070,2)
(4193,1888,2)
(4015,8722,2)
(7784,5251,2)
(5656,3062,2)
(5638,8111,2)
(8295,1785,2)
(837,7514,2)
(1415,7950,2)
(8807,6662,2)
(3014,6091,2)
(956,6659,2)
(3268,115,2)
(8812,8497,2)
(2524,7851,2)
(5862,2297,2)
(5280,2924,2)
(7626,8471,2)
(2055,6613,2)
(7816,6611,2)
(1841,92,2)
(5867,6620,2)
(9110,2283,2)
(2187,5553,2)
(9013,2336,2)
(7329,3891,2)
(7353,4915,2)
(2392,3895,2)
(3278,3197,2)
(402,5829,2)
(1978,1794,2)
(2585,7628,2)
(540,2330,2)
(4210,3649,2)
(3101,1705,2)
(8309,706,2)
(754,3895,2)
(274,3102,2)
(965,807,2)
(718,3218,2)
(3475,4793,2)
(7624,226,2)
(8311,115,2)
(6830,8920,2)
(4583,6659,2)
(2011,4698,2)
(1832,115,2)
(7796,6151,2)
(2060,1235,2)
(1516,7940,2)
(1531,2030,2)
(1079,8391,2)
(8307,2835,2)
(1168,6155,2)
(2270,6784,2)
(1535,799,2)
(6734,7143,2)
(3149,1306,2)
(922,2771,2)
(8936,2191,2)
(7650,2885,2)
(1189,9036,2)
(3684,410,2)
(4424,8254,2)
(3306,777,2)
(1113,6280,2)
(7266,3382,2)
(6258,6438,2)
(2350,3451,2)
(7516,115,2)
(6970,270,2)
(3675,8391,2)
(7097,4340,2)
(4764,8538,2)
(4375,6474,2)
(7120,115,2)
(1385,3614,2)
(4646,5752,2)
(4330,3363,2)
(5012,3828,2)
(248,115,2)
(8856,3725,2)
(8293,6561,2)
(2155,2771,2)
(6502,6374,2)
(3046,3895,2)
(2335,520,2)
(4570,1431,2)
(4873,700,2)
(2951,8501,2)
(7879,1235,2)
(6938,6155,2)
(4586,3338,2)
(3035,6597,2)
(2459,2835,2)
(2440,6070,2)
(2814,115,2)
(3219,8129,2)
(2979,1611,2)
(6838,6748,2)
(682,3729,2)
(5391,6056,2)
(4450,3934,2)
(1240,7200,2)
(7665,7514,2)
(2686,3810,2)
(9103,7820,2)
(6400,6209,2)
(842,5540,2)
(5868,1235,2)
(8001,611,2)
(4375,6921,2)
(2587,5349,2)
(7409,5196,2)
(2948,8254,2)
(7194,904,2)
(6490,4388,2)
(1085,115,2)
(3542,5779,2)
(8372,6155,2)
(6788,3527,2)
(7410,904,2)
(8702,4876,2)
(1512,5454,2)
(1077,2987,2)
(8030,1149,2)
(5613,2771,2)
(446,904,2)
(6729,3488,2)
(7401,403,2)
(7820,5501,2)
(607,4784,2)
(6973,115,2)
(6734,115,2)
(5368,2964,2)
(6020,8845,2)
(6302,3823,2)
(6471,7212,2)
(5411,6070,2)
(5745,5586,2)
(5673,8538,2)
(539,115,2)
(4057,3965,2)
(4272,8432,2)
(8699,4158,2)
(8016,4697,2)
(163,5156,2)
(6204,7569,2)
(678,6155,2)
(3545,115,2)
(2172,7995,2)
(6715,8391,2)
(2587,5605,2)
(2072,3488,2)
(898,408,2)
(4761,3814,2)
(8533,2835,2)
(7840,2763,2)
(4692,3417,2)
(785,2116,2)
(4333,3782,2)
(2111,2834,2)
(291,4985,2)
(54,4864,2)
(4663,415,2)
(6575,7628,2)
(8773,6155,2)
(665,2759,2)
(145,4253,2)
(1426,8756,2)
(7501,8277,2)
(7767,2834,2)
(4873,9130,2)
(1954,4340,2)
(1488,6868,2)
(207,2053,2)
(6449,8391,2)
(6132,3569,2)
(7022,2596,2)
(3064,1843,2)
(6038,115,2)
(1220,4619,2)
(2189,5162,2)
(3621,8458,2)
(3885,270,2)
(5992,7917,2)
(5638,9130,2)
(7574,3427,2)
(2940,115,2)
(711,8431,2)
(8176,9140,2)
(2002,4698,2)
(1956,6360,2)
(4015,575,2)
(2735,6155,2)
(3834,4876,2)
(617,7628,2)
(8961,1785,2)
(3804,4524,2)
(9134,1785,2)
(6536,7040,2)
(5630,5162,2)
(4477,2036,2)
(1609,2,2)
(2094,8391,2)
(5056,6858,2)
(1478,8756,2)
(1600,8756,2)
(2287,8441,2)
(8377,2537,2)
(197,115,2)
(463,8391,2)
(5400,2199,2)
(6783,874,2)
(4494,8391,2)
(9028,8340,2)
(7827,412,2)
(5058,5408,2)
(3797,6155,2)
(4257,46,2)
(7551,2835,2)
(6132,6746,2)
(7966,3198,2)
(7829,7604,2)
(8778,7798,2)
(5925,7868,2)
(902,5033,2)
(7507,8281,2)
(2920,7155,2)
(2416,8768,2)
(717,1916,2)
(267,2112,2)
(4475,1567,2)
(2531,5752,2)
(1038,1931,2)
(3539,7828,2)
(1063,1427,2)
(1226,7977,2)
(3804,2065,2)
(4874,6899,2)
(1738,9128,2)
(3521,5089,2)
(2260,6916,2)
(8517,7841,2)
(6091,8391,2)
(110,4088,2)
(462,8832,2)
(2060,2,2)
(8027,7945,2)
(914,4393,2)
(8116,408,2)
(6057,115,2)
(6309,2644,2)
(1415,8021,2)
(5408,1760,2)
(2495,2036,2)
(3969,4704,2)
(4475,4153,2)
(4375,2065,2)
(4083,4994,2)
(7643,4408,2)
(5244,3673,2)
(2544,4515,2)
(5272,3286,2)
(3062,8756,2)
(6948,5374,2)
(4937,5408,2)
(1149,5752,2)
(5646,4836,2)
(1536,7760,2)
(6548,154,2)
(6279,916,2)
(5737,3142,2)
(1358,7569,2)
(6560,4579,2)
(5129,9096,2)
(6137,7622,2)
(5200,3781,2)
(3541,691,2)
(3775,3895,2)
(1274,3425,2)
(7697,3781,2)
(5085,1954,2)
(2384,8391,2)
(8698,579,2)
(4431,8391,2)
(8379,4876,2)
(4952,46,2)
(3535,6867,2)
(4008,8391,2)
(989,7001,2)
(12,5698,2)
(8510,5156,2)
(2085,1401,2)
(7481,6155,2)
(6064,7079,2)
(3856,3814,2)
(7534,3218,2)
(1283,7765,2)
(8873,1516,2)
(7157,6385,2)
(7413,8610,2)
(1755,1235,2)
(2138,2191,2)
(6954,9140,2)
(2065,92,2)
(733,8756,2)
(8408,5712,2)
(6978,1254,2)
(1422,2537,2)
(8182,8756,2)
(7556,5501,2)
(5567,2344,2)
(3365,8712,2)
(7529,1493,2)
(5671,6867,2)
(585,8523,2)
(8664,115,2)
(6686,115,2)
(2952,5498,2)
(5398,1427,2)
(1599,4697,2)
(2147,2845,2)
(3778,3965,2)
(177,8050,2)
(6845,8756,2)
(712,19,2)
(6782,2835,2)
(3134,4435,2)
(7221,3192,2)
(2343,2688,2)
(3913,4644,2)
(4012,2866,2)
(6753,3295,2)
(4620,6159,2)
(4349,1103,2)
(3417,7160,2)
(8358,7646,2)
(3429,8756,2)
(2708,7155,2)
(7829,3095,2)
(4225,1895,2)
(7035,1653,2)
(5489,8391,2)
(609,8756,2)
(7357,8391,2)
(8554,8065,2)
(6121,1813,2)
(6394,6155,2)
(4544,2983,2)
(1489,7765,2)
(8080,7066,2)
(3892,92,2)
(800,115,2)
(8985,1265,2)
(9128,5605,2)
(7426,6434,2)
(776,5204,2)
(7944,6971,2)
(8834,4433,2)
(1153,5408,2)
(689,799,2)
(3901,396,2)
(7088,6155,2)
(1905,7100,2)
(1304,7535,2)
(4928,8756,2)
(8419,2845,2)
(2354,115,2)
(4934,4679,2)
(3616,4679,2)
(8031,3812,2)
(6865,115,2)
(8576,1657,2)
(3688,7762,2)
(1934,8405,2)
(3621,8471,2)
(1289,835,2)
(2452,6385,2)
(5240,4976,2)
(6069,6575,2)
(1933,904,2)
(245,6867,2)
(3362,1173,2)
(3986,6155,2)
(716,6939,2)
(3172,3232,2)
(7357,8107,2)
(8163,5204,2)
(464,4793,2)
(1069,777,2)
(3801,1938,2)
(1161,4646,2)
(7898,611,2)
(5493,6285,2)
(1347,6341,2)
(7810,8391,2)
(3210,4376,2)
(5571,7143,2)
(2701,4798,2)
(7366,8391,2)
(6316,1705,2)
(1351,846,2)
(4927,3427,2)
(5976,403,2)
(8587,2866,2)
(7665,1235,2)
(1381,706,2)
(4688,2036,2)
(1924,115,2)
(4982,115,2)
(8299,7940,2)
(3621,3215,2)
(4775,7186,2)
(3440,1745,2)
(6429,115,2)
(1173,6577,2)
(8132,2036,2)
(5876,299,2)
(2868,1782,2)
(1729,8391,2)
(2955,5309,2)
(352,4724,2)
(8314,5069,2)
(8319,2140,2)
(3596,2043,2)
(1478,115,2)
(3804,1270,2)
(4581,403,2)
(3804,6921,2)
(6674,403,2)
(5376,1493,2)
(504,6521,2)
(6524,283,2)
(2426,7514,2)
(2526,2092,2)
(4151,8065,2)
(5509,8793,2)
(3294,5993,2)
(4008,115,2)
(6405,8794,2)
(2561,8432,2)
(6101,6462,2)
(2199,6565,2)
(8201,4994,2)
(4554,46,2)
(7963,2698,2)
(2567,3752,2)
(2092,1705,2)
(7463,301,2)
(4280,115,2)
(6166,4697,2)
(4029,575,2)
(3119,8391,2)
(4413,8845,2)
(4230,1235,2)
(5665,7354,2)
(1184,2537,2)
(6365,7762,2)
(7966,3215,2)
(6982,46,2)
(8501,2644,2)
(6615,8756,2)
(2102,5501,2)
(7109,1311,2)
(6940,5204,2)
(5036,5640,2)
(6771,115,2)
(4955,4916,2)
(5128,7628,2)
(7242,2027,2)
(8891,4698,2)
(1594,5752,2)
(2206,5454,2)
(7915,4697,2)
(750,408,2)
(7980,8391,2)
(5772,8756,2)
(1053,1306,2)
(7125,726,2)
(6054,115,2)
(6826,2330,2)
(6143,2366,2)
(3694,874,2)
(4372,415,2)
(269,5297,2)
(7489,5038,2)
(1660,3969,2)
(7184,706,2)
(2572,6155,2)
(167,3906,2)
(3924,5316,2)
(4614,7239,2)
(2737,8303,2)
(264,2771,2)
(7359,3814,2)
(2254,8628,2)
(1225,611,2)
(3979,8523,2)
(2653,5752,2)
(2992,3863,2)
(6779,8431,2)
(7874,903,2)
(5824,6155,2)
(2974,403,2)
(6005,8756,2)
(3043,115,2)
(8517,4201,2)
(5322,3814,2)
(2487,115,2)
(6325,8391,2)
(2414,1794,2)
(6503,8756,2)
(4002,115,2)
(3804,4350,2)
(5996,46,2)
(2297,8391,2)
(5110,8391,2)
(5348,4976,2)
(215,408,2)
(6493,1459,2)
(8776,115,2)
(6806,1954,2)
(3997,3814,2)
(6536,8756,2)
(7791,3095,2)
(5556,5386,2)
(8644,352,2)
(4289,4690,2)
(375,4984,2)
(7691,4500,2)
(5214,9138,2)
(5975,6560,2)
(3433,611,2)
(7449,8985,2)
(5784,6053,2)
(7626,3889,2)
(4309,5156,2)
(1064,4388,2)
(1023,3812,2)
(5454,4081,2)
(784,1411,2)
(5688,2043,2)
(6750,115,2)
(8674,6150,2)
(6081,7628,2)
(6031,1488,2)
(2948,8777,2)
(6319,7262,2)
(5854,2835,2)
(4524,3812,2)
(7668,6385,2)
(51,1488,2)
(6159,8391,2)
(5489,3527,2)
(5922,150,2)
(466,3934,2)
(5851,3680,2)
(3888,5712,2)
(8276,8415,2)
(7598,1613,2)
(2726,1724,2)
(8106,8751,2)
(7566,2335,2)
(4335,4974,2)
(8142,5961,2)
(7143,3781,2)
(5551,3312,2)
(1026,3232,2)
(2983,8702,2)
(2998,6548,2)
(7440,5089,2)
(1612,8391,2)
(1633,7892,2)
(5602,8439,2)
(781,1974,2)
(6333,3527,2)
(741,2896,2)
(1190,865,2)
(8226,7514,2)
(5164,8391,2)
(8248,202,2)
(7895,6804,2)
(3805,8889,2)
(7646,6155,2)
(775,8391,2)
(4535,8107,2)
(7892,1370,2)
(5776,8204,2)
(7762,6400,2)
(8227,5162,2)
(5119,8187,2)
(2408,1502,2)
(3853,6155,2)
(8624,8746,2)
(6772,3312,2)
(8110,2043,2)
(8959,775,2)
(6915,46,2)
(6043,6155,2)
(1191,5869,2)
(3875,3812,2)
(3621,3889,2)
(5007,2754,2)
(4837,2964,2)
(53,7453,2)
(2287,7625,2)
(743,3142,2)
(4176,8756,2)
(1501,2465,2)
(5203,6155,2)
(5887,7463,2)
(6028,8756,2)
(6076,7917,2)
(3213,8111,2)
(8740,410,2)
(4730,7514,2)
(2482,5047,2)
(2264,6804,2)
(7587,2344,2)
(6289,7514,2)
(2153,926,2)
(4283,9087,2)
(5795,874,2)
(6234,3218,2)
(6857,410,2)
(4505,6155,2)
(7941,8756,2)
(1769,8391,2)
(2176,2457,2)
(7206,8845,2)
(1166,115,2)
(6227,8421,2)
(72,5752,2)
(168,1102,2)
(2024,8352,2)
(1913,2866,2)
(6437,8756,2)
(300,7258,2)
(6908,92,2)
(4758,8391,2)
(7627,6155,2)
(2461,2210,2)
(8541,3727,2)
(3721,3142,2)
(4954,4579,2)
(530,4632,2)
(7145,6070,2)
(8255,6583,2)
(1765,7743,2)
(4172,8391,2)
(8501,8391,2)
(4799,8756,2)
(3123,3629,2)
(3942,1783,2)
(5380,8756,2)
(9117,575,2)
(6781,6791,2)
(3553,3312,2)
(204,2172,2)
(7917,7912,2)
(4391,8391,2)
(7397,2058,2)
(2385,115,2)
(4828,115,2)
(3516,1220,2)
(1953,8523,2)
(4068,584,2)
(6150,4236,2)
(6734,8391,2)
(5853,8432,2)
(6963,7762,2)
(8130,8877,2)
(3326,8756,2)
(2287,9130,2)
(7461,6280,2)
(2555,403,2)
(1812,7143,2)
(6952,6155,2)
(3970,1235,2)
(8923,7262,2)
(7478,1657,2)
(7443,2187,2)
(4997,3198,2)
(9107,1572,2)
(3333,951,2)
(5948,3123,2)
(8890,4253,2)
(3226,7271,2)
(4326,205,2)
(424,3218,2)
(6419,4149,2)
(2069,4876,2)
(4084,6155,2)
(2466,7527,2)
(3304,7940,2)
(1302,7628,2)
(2625,5982,2)
(399,5836,2)
(4320,4,2)
(6972,5156,2)
(202,904,2)
(6759,2445,2)
(5571,3781,2)
(2835,5463,2)
(1196,5204,2)
(3727,115,2)
(2432,4793,2)
(7411,8391,2)
(3607,1235,2)
(5528,3781,2)
(4274,4343,2)
(1599,1957,2)
(4713,8431,2)
(7178,6479,2)
(1766,8391,2)
(3132,5712,2)
(5362,2191,2)
(8029,3320,2)
(1603,6155,2)
(3167,1254,2)
(4041,4579,2)
(1575,9,2)
(6965,951,2)
(6211,8756,2)
(2994,6053,2)
(1608,2866,2)
(2277,4679,2)
(4705,7514,2)
(484,1785,2)
(3785,3123,2)
(7346,7880,2)
(7216,5374,2)
(7248,2053,2)
(7779,6867,2)
(4144,2187,2)
(8832,3814,2)
(2565,6417,2)
(8450,6539,2)
(4881,7353,2)
(8883,5501,2)
(6638,2375,2)
(7251,4435,2)
(2864,8756,2)
(8723,8756,2)
(1297,575,2)
(2047,7486,2)
(4375,700,2)
(2042,7642,2)
(6723,8391,2)
(1007,611,2)
(8047,2445,2)
(5268,46,2)
(7800,408,2)
(673,6314,2)
(3819,8391,2)
(340,8391,2)
(1978,4709,2)
(1950,8756,2)
(2646,6155,2)
(4269,4874,2)
(1117,5302,2)
(2234,115,2)
(1821,8254,2)
(874,7461,2)
(6176,3752,2)
(7592,874,2)
(1709,415,2)
(4962,8756,2)
(5345,8391,2)
(5809,8458,2)
(5644,7841,2)
(1530,2701,2)
(106,3969,2)
(5550,228,2)
(8110,4239,2)
(3479,3488,2)
(7280,4287,2)
(1539,7760,2)
(7712,4153,2)
(1406,3382,2)
(7984,6155,2)
(684,3521,2)
(4221,1560,2)
(3403,1892,2)
(8950,7569,2)
(6629,8856,2)
(4761,1705,2)
(5955,4333,2)
(5919,8756,2)
(813,6871,2)
(5369,2845,2)
(7374,904,2)
(8511,6659,2)
(5440,798,2)
(5106,2596,2)
(1057,7001,2)
(741,1240,2)
(5638,4149,2)
(2407,1760,2)
(8209,4876,2)
(8821,7552,2)
(3669,2330,2)
(3200,4153,2)
(893,5454,2)
(8466,4793,2)
(7685,4793,2)
(325,8941,2)
(1349,115,2)
(4976,1488,2)
(4860,6155,2)
(8546,8065,2)
(7250,292,2)
(1060,228,2)
(3910,4408,2)
(4707,3466,2)
(6666,115,2)
(7520,4214,2)
(3738,6155,2)
(7034,5584,2)
(5820,3198,2)
(3058,3142,2)
(793,874,2)
(5483,5829,2)
(7079,2866,2)
(4500,822,2)
(3232,3320,2)
(1217,3183,2)
(6351,9096,2)
(3863,8567,2)
(8921,134,2)
(5519,115,2)
(1672,2835,2)
(3530,6155,2)
(3076,115,2)
(8904,5204,2)
(5820,904,2)
(1740,1254,2)
(1186,4098,2)
(7041,8845,2)
(8803,904,2)
(4116,8391,2)
(2845,6174,2)
(1920,3823,2)
(5916,4698,2)
(680,3368,2)
(3180,257,2)
(5991,6897,2)
(1942,8756,2)
(2885,6479,2)
(1878,8391,2)
(2800,5540,2)
(2287,6968,2)
(2689,777,2)
(1891,3814,2)
(7868,2344,2)
(5811,4380,2)
(8708,6687,2)
(8292,6155,2)
(5095,2210,2)
(2184,7262,2)
(177,6155,2)
(38,8756,2)
(4232,1760,2)
(6174,1987,2)
(2421,34,2)
(8691,39,2)
(7595,115,2)
(614,3108,2)
(131,7760,2)
(726,7828,2)
(1180,4435,2)
(4245,1235,2)
(8398,7917,2)
(7479,3530,2)
(3911,1363,2)
(5278,3823,2)
(2504,3363,2)
(8202,8756,2)
(1561,410,2)
(771,7762,2)
(7966,4515,2)
(1064,4759,2)
(6293,8756,2)
(5503,5847,2)
(9062,8254,2)
(2879,3965,2)
(5369,7590,2)
(8142,3983,2)
(9118,8756,2)
(1220,5069,2)
(7766,7353,2)
(4851,2502,2)
(7890,8108,2)
(7441,5752,2)
(3849,115,2)
(3240,4769,2)
(4742,7760,2)
(284,2947,2)
(972,2592,2)
(8416,8756,2)
(7875,4583,2)
(2346,5129,2)
(5950,3942,2)
(5629,462,2)
(4103,8523,2)
(4736,352,2)
(6472,8493,2)
(7408,8391,2)
(1611,7230,2)
(1970,4976,2)
(9142,1002,2)
(3647,3123,2)
(7442,916,2)
(6960,1462,2)
(3602,7064,2)
(8531,8391,2)
(3052,3149,2)
(2591,2845,2)
(5490,3934,2)
(7813,2537,2)
(2729,2283,2)
(7830,2835,2)
(1298,2007,2)
(1881,8756,2)
(7410,3198,2)
(1135,3460,2)
(6454,8756,2)
(87,4501,2)
(4211,4397,2)
(7729,8756,2)
(7953,3014,2)
(7264,4153,2)
(2525,403,2)
(1798,7569,2)
(8088,8391,2)
(1024,7353,2)
(1415,796,2)
(4375,1826,2)
(5184,5586,2)
(8439,6613,2)
(4582,5566,2)
(6973,8391,2)
(3358,2932,2)
(2606,7754,2)
(978,1104,2)
(8804,7828,2)
(8350,8756,2)
(3462,4984,2)
(260,352,2)
(6600,1488,2)
(1797,5408,2)
(7527,3103,2)
(4749,7711,2)
(1207,8923,2)
(673,5712,2)
(465,1709,2)
(8312,5408,2)
(5638,3215,2)
(8147,5752,2)
(1301,8756,2)
(4777,4153,2)
(2117,115,2)
(5076,2654,2)
(5943,5540,2)
(4814,7066,2)
(7165,3097,2)
(481,1240,2)
(8844,4066,2)
(7324,7628,2)
(6128,3781,2)
(5610,3501,2)
(6242,2644,2)
(1006,7760,2)
(181,6155,2)
(1886,2526,2)
(6033,269,2)
(5811,4876,2)
(8274,7514,2)
(8205,5164,2)
(6959,3123,2)
(4852,6155,2)
(610,8432,2)
(6421,3823,2)
(1352,8728,2)
(501,7570,2)
(8590,5752,2)
(5483,5237,2)
(5363,904,2)
(5507,5540,2)
(5861,4876,2)
(8093,8289,2)
(4445,7628,2)
(2243,2344,2)
(1235,453,2)
(4499,7762,2)
(7814,4408,2)
(3259,8129,2)
(4187,8756,2)
(5419,115,2)
(6198,8391,2)
(3483,4876,2)
(6672,4579,2)
(6701,8756,2)
(5687,115,2)
(8680,1601,2)
(1091,7909,2)
(100,115,2)
(6133,609,2)
(5811,5156,2)
(5803,7940,2)
(3268,8756,2)
(2625,7841,2)
(5356,1234,2)
(4285,8889,2)
(8288,1705,2)
(3572,6155,2)
(7626,4350,2)
(8954,6155,2)
(8048,1888,2)
(5182,575,2)
(528,8391,2)
(891,8732,2)
(4560,6155,2)
(4451,6449,2)
(7310,706,2)
(3619,2445,2)
(8730,6286,2)
(2013,6285,2)
(7365,8616,2)
(3522,6995,2)
(6748,7107,2)
(6663,115,2)
(6652,1254,2)
(1694,8391,2)
(448,4809,2)
(5850,5316,2)
(3776,5162,2)
(9026,115,2)
(2479,6208,2)
(6194,6244,2)
(8042,4619,2)
(6454,7711,2)
(5061,408,2)
(3898,1560,2)
(5075,7828,2)
(7051,8493,2)
(6620,8391,2)
(1350,8242,2)
(778,3326,2)
(3914,8756,2)
(1919,5540,2)
(5049,9140,2)
(6047,3095,2)
(3472,6804,2)
(1749,8756,2)
(574,706,2)
(4495,6385,2)
(5638,8471,2)
(5413,5345,2)
(3351,8432,2)
(2881,7940,2)
(2919,5586,2)
(7590,3758,2)
(8811,2283,2)
(8399,8756,2)
(1873,3198,2)
(2463,1653,2)
(5237,5868,2)
(246,8756,2)
(5739,1432,2)
(6168,7233,2)
(3033,2187,2)
(2140,3218,2)
(2711,8756,2)
(692,5586,2)
(4920,1785,2)
(5158,2537,2)
(7591,4994,2)
(7203,1657,2)
(2544,4149,2)
(9125,4435,2)
(5549,1254,2)
(4090,3320,2)
(3741,4984,2)
(411,7001,2)
(3933,676,2)
(6087,403,2)
(4011,2210,2)
(994,8793,2)
(8338,1236,2)
(4961,2283,2)
(449,3108,2)
(144,2118,2)
(3230,7566,2)
(8171,1888,2)
(3701,8673,2)
(1638,8756,2)
(3733,2720,2)
(477,8391,2)
(627,5501,2)
(4232,8391,2)
(2707,6155,2)
(8221,4153,2)
(1493,8756,2)
(4658,6369,2)
(6046,3810,2)
(8194,3823,2)
(523,408,2)
(8301,2592,2)
(1221,2920,2)
(2783,1104,2)
(5227,3895,2)
(3144,6804,2)
(5457,3382,2)
(6604,6583,2)
(2383,7940,2)
(707,453,2)
(5705,8391,2)
(160,2445,2)
(61,8107,2)
(7988,115,2)
(3347,4604,2)
(8778,3501,2)
(6855,5428,2)
(3022,5605,2)
(2971,2445,2)
(1339,3312,2)
(7243,3553,2)
(5077,5501,2)
(8638,5656,2)
(4658,8694,2)
(144,1709,2)
(6820,3812,2)
(8841,4793,2)
(1438,2845,2)
(3345,2559,2)
(2379,7917,2)
(4146,2089,2)
(2087,3501,2)
(4375,2497,2)
(2292,904,2)
(2522,2845,2)
(4375,7380,2)
(6797,7764,2)
(2986,352,2)
(3664,1149,2)
(8680,403,2)
(1954,5512,2)
(4705,3028,2)
(4826,4697,2)
(7182,8391,2)
(3193,8699,2)
(1528,4948,2)
(7453,4044,2)
(5979,4289,2)
(478,611,2)
(3926,8777,2)
(3188,4697,2)
(8233,92,2)
(2476,902,2)
(1658,1427,2)
(3023,6385,2)
(659,3906,2)
(932,8108,2)
(1758,8431,2)
(2547,8756,2)
(1656,4558,2)
(8792,6613,2)
(7930,3810,2)
(3389,5836,2)
(5479,7210,2)
(236,6613,2)
(9001,1286,2)
(3500,4984,2)
(4287,6070,2)
(3527,349,2)
(6690,5752,2)
(453,6858,2)
(5624,8431,2)
(6325,115,2)
(3454,8996,2)
(3087,3382,2)
(3799,5204,2)
(7450,2983,2)
(7163,8593,2)
(6536,6454,2)
(4558,5712,2)
(5308,2465,2)
(7524,1149,2)
(4135,559,2)
(7969,8391,2)
(3121,8756,2)
(6218,8756,2)
(6502,5593,2)
(6058,2191,2)
(4471,5586,2)
(1746,8756,2)
(6223,3218,2)
(7632,115,2)
(4024,5212,2)
(5442,8756,2)
(5283,7569,2)
(5982,7841,2)
(4555,416,2)
(5305,7514,2)
(4872,2592,2)
(3034,2983,2)
(4044,5689,2)
(6419,6070,2)
(5670,8756,2)
(5593,2112,2)
(6236,8391,2)
(6023,115,2)
(8335,5327,2)
(4631,5859,2)
(7571,115,2)
(5517,6479,2)
(3401,2630,2)
(2533,8187,2)
(5597,7921,2)
(4476,1770,2)
(5414,2845,2)
(309,8391,2)
(1079,2366,2)
(3169,1937,2)
(4818,8862,2)
(7658,7514,2)
(5159,5712,2)
(7060,7357,2)
(1047,8391,2)
(3900,689,2)
(2034,3435,2)
(3674,5454,2)
(1615,904,2)
(6056,1413,2)
(1387,8756,2)
(7536,8391,2)
(9096,6776,2)
(1140,8187,2)
(7038,115,2)
(5402,8391,2)
(3166,8756,2)
(3131,7354,2)
(6111,2845,2)
(7703,2158,2)
(3701,3891,2)
(7040,8756,2)
(603,2199,2)
(9029,8391,2)
(8348,2020,2)
(258,5519,2)
(6064,7940,2)
(6475,706,2)
(3407,874,2)
(9128,4704,2)
(5583,115,2)
(3197,8523,2)
(552,8756,2)
(6159,3451,2)
(7388,7628,2)
(7694,2537,2)
(4158,7514,2)
(8846,2866,2)
(6804,6142,2)
(7312,1705,2)
(7924,3108,2)
(1059,6155,2)
(7966,4587,2)
(4056,46,2)
(3932,2671,2)
(7233,507,2)
(3755,3142,2)
(7343,453,2)
(4340,1572,2)
(8952,7067,2)
(9080,6971,2)
(8707,5251,2)
(4295,1888,2)
(7209,4088,2)
(2465,1254,2)
(4596,6141,2)
(5999,4916,2)
(3537,3493,2)
(653,226,2)
(5255,1972,2)
(6430,115,2)
(7863,8391,2)
(147,7569,2)
(2512,6575,2)
(4593,7031,2)
(1954,706,2)
(8113,5687,2)
(3031,1782,2)
(2181,1322,2)
(2756,1770,2)
(8974,4285,2)
(4475,7264,2)
(3547,6479,2)
(82,8131,2)
(4966,2729,2)
(6741,5829,2)
(8508,2983,2)
(2487,2845,2)
(6868,8109,2)
(3028,7514,2)
(1267,2866,2)
(1569,8756,2)
(8043,391,2)
(182,3488,2)
(1046,3295,2)
(4311,5847,2)
(2167,8391,2)
(3290,8431,2)
(1843,115,2)
(3097,8756,2)
(1802,8751,2)
(3171,6049,2)
(5213,2295,2)
(3027,408,2)
(3141,3823,2)
(2058,8432,2)
(5675,6155,2)
(6101,771,2)
(6872,408,2)
(2680,1254,2)
(3621,9130,2)
(5577,8391,2)
(284,2640,2)
(234,6155,2)
(3205,228,2)
(1487,2644,2)
(83,1653,2)
(2394,7940,2)
(792,951,2)
(2417,7628,2)
(3019,6687,2)
(474,226,2)
(2338,8756,2)
(6502,5494,2)
(100,6730,2)
(2854,3793,2)
(6935,115,2)
(6297,4236,2)
(3745,3095,2)
(1682,6405,2)
(708,5881,2)
(1967,2845,2)
(7003,7415,2)
(3499,4698,2)
(5069,5586,2)
(1079,115,2)
(5748,8391,2)
(6584,3527,2)
(4234,6804,2)
(5050,4253,2)
(683,8756,2)
(8728,6577,2)
(3865,5204,2)
(4352,5953,2)
(3201,7628,2)
(5167,3752,2)
(7139,7834,2)
(8436,1782,2)
(8872,7870,2)
(5712,3859,2)
(6785,8756,2)
(3403,1459,2)
(7812,3451,2)
(7718,904,2)
(6314,5712,2)
(1560,577,2)
(8862,4553,2)
(839,5251,2)
(5309,2559,2)
(845,1947,2)
(8809,726,2)
(7980,3621,2)
(2027,226,2)
(4480,5605,2)
(6362,2210,2)
(4098,92,2)
(7167,8778,2)
(6922,1758,2)
(4145,4579,2)
(1974,3222,2)
(2596,2771,2)
(3592,3568,2)
(8394,5162,2)
(7370,2983,2)
(6037,1070,2)
(3327,6314,2)
(96,8431,2)
(7152,8889,2)
(4304,8681,2)
(4560,2004,2)
(2944,8134,2)
(1527,2754,2)
(7923,115,2)
(7831,6280,2)
(1823,3658,2)
(7005,115,2)
(1415,8799,2)
(2030,1055,2)
(4539,7940,2)
(4413,4876,2)
(6764,5204,2)
(8038,9130,2)
(4739,5011,2)
(8316,5958,2)
(8782,2835,2)
(4547,5501,2)
(8053,2587,2)
(211,8742,2)
(2908,2482,2)
(2295,5069,2)
(453,7760,2)
(6142,6385,2)
(6875,7852,2)
(8530,2995,2)
(2199,609,2)
(2714,848,2)
(7011,5938,2)
(1348,6875,2)
(2287,6435,2)
(2489,7514,2)
(5615,1488,2)
(4605,2199,2)
(3414,1254,2)
(6717,6155,2)
(2681,3965,2)
(8340,2835,2)
(7003,4734,2)
(6603,8391,2)
(7031,7628,2)
(6523,1254,2)
(7285,2191,2)
(6525,2628,2)
(743,4918,2)
(2303,3123,2)
(1567,8391,2)
(5953,1149,2)
(8320,5540,2)
(3476,8832,2)
(6289,6771,2)
(7371,6155,2)
(2146,2612,2)
(7499,8749,2)
(3259,1488,2)
(330,403,2)
(3457,408,2)
(1108,8065,2)
(2900,8419,2)
(1228,739,2)
(6678,8391,2)
(637,6971,2)
(7727,7909,2)
(111,5583,2)
(3213,3565,2)
(1512,4014,2)
(6526,8756,2)
(8283,1785,2)
(1948,8391,2)
(4942,1235,2)
(7730,2052,2)
(691,8756,2)
(972,1231,2)
(7753,2210,2)
(1092,2566,2)
(3729,2868,2)
(2213,8756,2)
(1415,3657,2)
(7097,6575,2)
(3316,8582,2)
(3804,4515,2)
(3603,8756,2)
(3225,904,2)
(988,2053,2)
(2170,8756,2)
(7065,228,2)
(472,559,2)
(3483,1373,2)
(7327,403,2)
(2715,5408,2)
(701,2003,2)
(3804,700,2)
(1908,3333,2)
(6154,7514,2)
(1458,3999,2)
(2139,2845,2)
(4375,6435,2)
(5688,8074,2)
(7999,1785,2)
(1669,4285,2)
(636,3895,2)
(5177,3218,2)
(6063,115,2)
(171,2210,2)
(548,3218,2)
(1364,1770,2)
(1707,6867,2)
(5162,2866,2)
(7408,3451,2)
(6351,3297,2)
(4344,8391,2)
(2812,1785,2)
(3038,6479,2)
(2035,333,2)
(3690,3108,2)
(2189,6513,2)
(6230,651,2)
(6125,7614,2)
(3521,4800,2)
(5494,6649,2)
(2891,2152,2)
(4769,2482,2)
(4137,8756,2)
(4494,19,2)
(5051,8432,2)
(8886,7828,2)
(9103,5501,2)
(1838,2537,2)
(5912,8431,2)
(3847,8391,2)
(8445,8928,2)
(6342,1220,2)
(6001,3439,2)
(3095,5445,2)
(3831,2220,2)
(2104,4876,2)
(7945,92,2)
(4155,8391,2)
(445,284,2)
(3962,8321,2)
(6652,5716,2)
(5913,6548,2)
(7812,6084,2)
(6379,352,2)
(4055,6926,2)
(7042,2959,2)
(1210,3781,2)
(941,3198,2)
(8034,3415,2)
(5294,5823,2)
(902,8391,2)
(1688,8756,2)
(3488,4579,2)
(1486,4253,2)
(3796,2983,2)
(2317,2845,2)
(3673,115,2)
(1204,4473,2)
(8146,3095,2)
(6305,7569,2)
(579,115,2)
(6419,6968,2)
(7120,8391,2)
(6928,8391,2)
(2287,2497,2)
(5985,3891,2)
(3962,5540,2)
(163,7754,2)
(3833,8572,2)
(592,8391,2)
(1179,2199,2)
(2287,1270,2)
(6988,5540,2)
(5009,1173,2)
(3804,1280,2)
(9002,4253,2)
(1131,3823,2)
(4641,1705,2)
(5620,8923,2)
(3825,904,2)
(3184,2049,2)
(205,611,2)
(3116,1260,2)
(3899,8391,2)
(6278,245,2)
(5795,2845,2)
(808,874,2)
(2433,874,2)
(4715,3095,2)
(587,228,2)
(7730,1682,2)
(2099,3875,2)
(5142,575,2)
(796,2366,2)
(4745,4367,2)
(4821,8391,2)
(2623,8391,2)
(2224,1657,2)
(6761,5777,2)
(4808,6613,2)
(6066,4579,2)
(6036,1972,2)
(2410,115,2)
(8038,4587,2)
(6683,7917,2)
(2470,7765,2)
(3388,5540,2)
(6267,6681,2)
(7387,4410,2)
(7783,228,2)
(7966,8111,2)
(3117,5698,2)
(5757,8065,2)
(9088,8391,2)
(4072,115,2)
(3805,3752,2)
(3844,8391,2)
(1270,1173,2)
(6458,1305,2)
(8570,2133,2)
(1692,1785,2)
(2991,3781,2)
(4843,706,2)
(4810,4236,2)
(6234,8391,2)
(6684,1705,2)
(6686,3382,2)
(218,3878,2)
(3221,7760,2)
(848,1094,2)
(7589,410,2)
(3743,7150,2)
(3074,4253,2)
(910,3758,2)
(5988,408,2)
(3730,6155,2)
(1299,565,2)
(4275,4679,2)
(3030,5989,2)
(7328,3849,2)
(5147,3965,2)
(4694,1972,2)
(6083,8756,2)
(7542,4632,2)
(7970,2053,2)
(542,8820,2)
(2937,8149,2)
(1725,8756,2)
(5426,4624,2)
(6542,1888,2)
(2832,7514,2)
(7375,3696,2)
(815,8431,2)
(5070,4773,2)
(885,6179,2)
(5104,2460,2)
(1397,4285,2)
(7924,3690,2)
(8559,5586,2)
(6908,6179,2)
(1112,7514,2)
(2801,6070,2)
(4198,115,2)
(313,8129,2)
(7553,8670,2)
(3657,4236,2)
(4457,3427,2)
(4789,8749,2)
(2629,1311,2)
(5694,706,2)
(2028,6804,2)
(1777,8193,2)
(8983,3123,2)
(6407,7628,2)
(8393,1092,2)
(8702,5156,2)
(6196,6150,2)
(6284,700,2)
(8245,7493,2)
(3859,2212,2)
(3556,408,2)
(6559,1149,2)
(7851,403,2)
(7226,6452,2)
(2054,2366,2)
(7386,6179,2)
(2890,2283,2)
(1761,6053,2)
(6474,3488,2)
(4440,4793,2)
(6452,8793,2)
(1583,4044,2)
(1878,115,2)
(7498,115,2)
(6237,2840,2)
(2518,1366,2)
(6301,3218,2)
(3932,8756,2)
(2140,2344,2)
(3604,4876,2)
(7257,8756,2)
(5598,5777,2)
(3819,6385,2)
(1944,403,2)
(5383,115,2)
(1754,3963,2)
(4308,3218,2)
(4742,5156,2)
(7748,1254,2)
(24,2983,2)
(5829,8889,2)
(7989,115,2)
(2031,3752,2)
(8853,3198,2)
(7160,2823,2)
(4136,1912,2)
(1415,2096,2)
(1132,3320,2)
(5952,7909,2)
(8307,7519,2)
(49,536,2)
(5124,6027,2)
(9008,6775,2)
(4482,2765,2)
(1152,115,2)
(8619,5836,2)
(8934,403,2)
(4228,1560,2)
(3655,6858,2)
(3242,2803,2)
(7196,8756,2)
(2087,8778,2)
(8231,4285,2)
(3363,8923,2)
(1590,6132,2)
(6713,115,2)
(9096,2020,2)
(6398,6155,2)
(1331,7354,2)
(1017,6577,2)
(8898,7628,2)
(691,5420,2)
(2474,6613,2)
(5032,3201,2)
(7507,408,2)
(4529,7001,2)
(7604,3095,2)
(7362,2020,2)
(5638,489,2)
(1989,7628,2)
(6867,4253,2)
(3294,4006,2)
(14,6200,2)
(3587,408,2)
(2671,115,2)
(7462,8391,2)
(5639,904,2)
(43,4064,2)
(2685,4616,2)
(2858,5501,2)
(6190,5586,2)
(8386,3095,2)
(1742,2210,2)
(4353,46,2)
(2337,7628,2)
(4490,2537,2)
(6090,8695,2)
(1346,1458,2)
(3477,352,2)
(8559,1282,2)
(7514,4434,2)
(6770,7940,2)
(7530,4285,2)
(2749,904,2)
(2307,7628,2)
(390,2221,2)
(7935,6200,2)
(6419,2112,2)
(6869,7917,2)
(8362,7262,2)
(1110,8431,2)
(6977,8756,2)
(8920,2559,2)
(4647,115,2)
(979,1493,2)
(7862,8756,2)
(3103,409,2)
(4491,6179,2)
(40,5938,2)
(1907,8667,2)
(530,5269,2)
(3269,8431,2)
(4741,7569,2)
(212,115,2)
(5117,9096,2)
(6855,51,2)
(6417,2502,2)
(856,1705,2)
(6017,7514,2)
(178,4289,2)
(1311,9112,2)
(6226,3356,2)
(8225,2428,2)
(4520,6155,2)
(8521,5586,2)
(9066,7155,2)
(2534,8391,2)
(8236,7155,2)
(4804,8756,2)
(192,4388,2)
(591,7262,2)
(6355,1011,2)
(7876,7841,2)
(8061,4628,2)
(2657,8391,2)
(8043,5413,2)
(2734,4697,2)
(6861,5069,2)
(8670,6060,2)
(7577,6548,2)
(7454,1002,2)
(1778,3488,2)
(1510,5204,2)
(2157,8391,2)
(1225,4830,2)
(6381,3363,2)
(7020,7841,2)
(2051,7765,2)
(9051,6155,2)
(4610,1340,2)
(3695,6070,2)
(2996,1810,2)
(4390,6285,2)
(5425,3218,2)
(6517,1785,2)
(339,2845,2)
(6324,2482,2)
(523,115,2)
(4422,5586,2)
(6012,8233,2)
(5483,2043,2)
(6888,3417,2)
(1319,5501,2)
(8087,453,2)
(8578,9039,2)
(7817,7262,2)
(3632,8777,2)
(8535,6155,2)
(3531,904,2)
(6070,3786,2)
(4745,7201,2)
(6207,2344,2)
(5302,777,2)
(7891,5107,2)
(2401,324,2)
(66,4861,2)
(5858,904,2)
(1097,2866,2)
(868,6753,2)
(7674,8756,2)
(5889,2834,2)
(421,8065,2)
(4290,8756,2)
(5840,3501,2)
(1082,4985,2)
(337,2366,2)
(9117,115,2)
(903,8391,2)
(2682,7828,2)
(2202,5712,2)
(37,7569,2)
(4089,3451,2)
(7079,7975,2)
(1359,6385,2)
(4985,7760,2)
(650,5605,2)
(8443,4236,2)
(4338,3095,2)
(4280,8391,2)
(4966,2283,2)
(1985,3417,2)
(3449,8206,2)
(8695,378,2)
(9058,8065,2)
(3683,6971,2)
(4903,7940,2)
(989,115,2)
(2554,5752,2)
(2964,410,2)
(3085,8233,2)
(3014,3823,2)
(3571,115,2)
(6502,7881,2)
(5229,1974,2)
(9069,8391,2)
(846,609,2)
(3007,901,2)
(4376,4253,2)
(6428,883,2)
(2713,6385,2)
(7159,5752,2)
(7146,7614,2)
(2696,1653,2)
(8252,6986,2)
(6233,7614,2)
(6699,578,2)
(8492,5540,2)
(6346,4253,2)
(8234,8746,2)
(28,2596,2)
(4499,1149,2)
(3921,3963,2)
(3648,4128,2)
(1903,408,2)
(8563,1653,2)
(7763,5540,2)
(7761,9128,2)
(5265,4236,2)
(5718,6662,2)
(6275,3781,2)
(2696,83,2)
(3302,951,2)
(6419,4350,2)
(4874,7909,2)
(2218,3201,2)
(2484,2866,2)
(7819,99,2)
(9008,4917,2)
(5690,4044,2)
(4588,2835,2)
(5683,1348,2)
(1143,4679,2)
(1501,995,2)
(4706,706,2)
(6733,7569,2)
(177,1784,2)
(4367,4974,2)
(698,6554,2)
(1224,3863,2)
(1980,4593,2)
(4002,5656,2)
(8328,115,2)
(4466,115,2)
(4918,3142,2)
(3633,7551,2)
(7574,5698,2)
(261,3823,2)
(5949,1354,2)
(4495,6364,2)
(1907,3248,2)
(468,5501,2)
(3699,8391,2)
(7833,2007,2)
(5228,7628,2)
(5553,2945,2)
(4163,6385,2)
(6502,5214,2)
(7294,2036,2)
(6632,8391,2)
(175,1782,2)
(3891,1724,2)
(3569,1493,2)
(8167,4494,2)
(713,3095,2)
(635,7353,2)
(5618,7828,2)
(1146,7754,2)
(6678,7353,2)
(4505,6919,2)
(1982,5156,2)
(8704,4153,2)
(4305,8289,2)
(2367,1770,2)
(4375,3970,2)
(4184,4576,2)
(1438,7940,2)
(2683,115,2)
(8746,3783,2)
(4270,8777,2)
(4353,3072,2)
(9066,1045,2)
(2667,5089,2)
(5719,2845,2)
(3355,7665,2)
(784,2116,2)
(4820,2366,2)
(1360,1969,2)
(248,3095,2)
(5030,7251,2)
(4297,3218,2)
(5819,4899,2)
(7847,8391,2)
(7793,6580,2)
(8630,1785,2)
(6771,8391,2)
(2147,8391,2)
(9067,8391,2)
(1483,6385,2)
(4417,8391,2)
(5261,4397,2)
(2894,4289,2)
(2401,2906,2)
(3731,7595,2)
(1046,868,2)
(1664,6686,2)
(190,5906,2)
(8282,2231,2)
(4172,6614,2)
(7950,7868,2)
(1077,862,2)
(1166,8391,2)
(5836,8241,2)
(217,3863,2)
(7558,4253,2)
(5222,3758,2)
(4186,7760,2)
(3118,6155,2)
(7594,3782,2)
(5137,6155,2)
(8871,3823,2)
(4003,3963,2)
(5054,6038,2)
(1142,6548,2)
(5417,8481,2)
(4778,8756,2)
(3258,2976,2)
(6385,6535,2)
(1255,8756,2)
(6734,3781,2)
(1074,4088,2)
(3519,8756,2)
(3070,7909,2)
(579,3963,2)
(5394,3095,2)
(682,3031,2)
(7055,3488,2)
(25,8391,2)
(8591,7828,2)
(8104,5123,2)
(8823,8756,2)
(2904,3142,2)
(155,8391,2)
(6660,916,2)
(4375,3215,2)
(2174,8756,2)
(2752,1240,2)
(5355,8391,2)
(8610,8391,2)
(4375,3657,2)
(1455,2854,2)
(4410,8026,2)
(2766,228,2)
(5348,2596,2)
(2464,1177,2)
(6992,270,2)
(39,5337,2)
(1896,2537,2)
(1248,7143,2)
(724,4984,2)
(1955,8391,2)
(3050,5829,2)
(3935,2537,2)
(8216,3895,2)
(7608,1254,2)
(5513,403,2)
(253,6805,2)
(1208,1311,2)
(3996,7569,2)
(6278,7888,2)
(7365,1954,2)
(4645,8756,2)
(8497,6791,2)
(2147,115,2)
(6587,6784,2)
(4702,2187,2)
(9050,689,2)
(151,6292,2)
(7512,8756,2)
(7408,6084,2)
(998,3417,2)
(2424,115,2)
(9098,1396,2)
(6981,2608,2)
(969,150,2)
(2210,459,2)
(8253,1493,2)
(8445,4333,2)
(2822,5408,2)
(7572,4239,2)
(4277,5156,2)
(2889,6155,2)
(7661,7180,2)
(7211,3696,2)
(8260,2367,2)
(4140,5586,2)
(7938,8756,2)
(3877,7711,2)
(6146,2511,2)
(8794,1874,2)
(2650,8493,2)
(3350,5204,2)
(4550,2512,2)
(5169,5408,2)
(5514,8756,2)
(5604,102,2)
(7374,115,2)
(4757,2167,2)
(5249,3417,2)
(4567,6522,2)
(2052,4772,2)
(3428,5777,2)
(1592,1466,2)
(6731,1657,2)
(5516,5533,2)
(486,92,2)
(2446,5204,2)
(8510,1002,2)
(6424,1392,2)
(9124,3963,2)
(5578,1954,2)
(1707,8391,2)
(4161,1891,2)
(1482,3198,2)
(8304,7628,2)
(7641,7514,2)
(7486,7614,2)
(5317,7910,2)
(8697,5156,2)
(9083,7909,2)
(2945,8756,2)
(8876,3781,2)
(3757,904,2)
(7378,951,2)
(4077,2326,2)
(7090,306,2)
(5604,5084,2)
(1673,3488,2)
(547,4253,2)
(2833,3201,2)
(2393,2366,2)
(7832,4697,2)
(4924,7628,2)
(710,2053,2)
(5704,5586,2)
(5909,208,2)
(1065,8391,2)
(4148,6088,2)
(1415,5796,2)
(1940,7514,2)
(6304,7760,2)
(5778,5698,2)
(2852,4579,2)
(5027,292,2)
(2180,6385,2)
(2657,115,2)
(6433,2239,2)
(5763,8107,2)
(6341,8391,2)
(5494,8471,2)
(580,3815,2)
(6614,4579,2)
(3528,7841,2)
(6500,4625,2)
(5212,8756,2)
(4360,4853,2)
(6576,115,2)
(3600,6677,2)
(1854,8065,2)
(4153,7760,2)
(5563,7917,2)
(8526,6179,2)
(8730,904,2)
(1437,904,2)
(7762,5752,2)
(4219,4876,2)
(5530,446,2)
(1467,4793,2)
(5192,4576,2)
(8501,115,2)
(218,5251,2)
(666,904,2)
(269,3969,2)
(8050,3797,2)
(3026,8756,2)
(414,5204,2)
(123,8902,2)
(8927,8176,2)
(4592,5629,2)
(7984,115,2)
(1478,8391,2)
(3509,8458,2)
(341,403,2)
(2297,4604,2)
(4911,951,2)
(8325,5656,2)
(5094,408,2)
(4315,228,2)
(6715,6583,2)
(1165,7119,2)
(3534,689,2)
(508,4253,2)
(2647,115,2)
(7003,4253,2)
(7754,6760,2)
(5649,3142,2)
(1432,3906,2)
(8877,2866,2)
(2007,5977,2)
(7626,6649,2)
(2510,3095,2)
(4068,1656,2)
(6220,6613,2)
(4398,8391,2)
(4410,4985,2)
(6843,2199,2)
(8581,4253,2)
(6303,1954,2)
(2903,6804,2)
(3403,2891,2)
(3215,8889,2)
(1245,3538,2)
(8557,2835,2)
(1500,4029,2)
(2036,284,2)
(6030,115,2)
(598,2414,2)
(6246,2191,2)
(6202,2683,2)
(2727,3752,2)
(3622,7514,2)
(1375,7628,2)
(4375,7045,2)
(6663,4558,2)
(5915,3192,2)
(2499,8431,2)
(7801,3218,2)
(5081,7940,2)
(5078,8879,2)
(373,8775,2)
(6654,7628,2)
(1474,2112,2)
(4793,1410,2)
(4310,6090,2)
(5030,4435,2)
(2330,2130,2)
(2053,4956,2)
(3326,4148,2)
(1134,7489,2)
(5855,3911,2)
(8593,2921,2)
(1471,4119,2)
(6130,8923,2)
(7962,5829,2)
(8323,3272,2)
(8722,575,2)
(4391,115,2)
(1443,3218,2)
(1349,2187,2)
(8552,5712,2)
(2175,1485,2)
(1976,5204,2)
(6630,8807,2)
(2090,46,2)
(7191,609,2)
(6865,8391,2)
(5451,115,2)
(9005,2210,2)
(3920,2187,2)
(6563,5147,2)
(2293,8391,2)
(3913,5586,2)
(6688,4619,2)
(6655,6995,2)
(463,3123,2)
(6298,5173,2)
(7626,7280,2)
(5681,9096,2)
(7670,5752,2)
(15,904,2)
(608,46,2)
(8560,5712,2)
(1576,3382,2)
(2158,5391,2)
(4285,3192,2)
(6087,4739,2)
(7133,72,2)
(8246,6508,2)
(9101,6858,2)
(1676,4326,2)
(6451,2366,2)
(4659,4397,2)
(3617,8756,2)
(4034,3621,2)
(1866,4697,2)
(4673,8065,2)
(4375,8441,2)
(212,8391,2)
(8714,6155,2)
(146,8432,2)
(359,4619,2)
(6502,2687,2)
(1739,8889,2)
(1415,144,2)
(5022,8756,2)
(5209,115,2)
(2795,1002,2)
(5430,2537,2)
(5833,2834,2)
(5136,131,2)
(7338,8481,2)
(6726,4876,2)
(907,4641,2)
(8111,536,2)
(4375,7514,2)
(8211,2191,2)
(7222,8391,2)
(5180,8241,2)
(1884,1220,2)
(6523,115,2)
(2287,489,2)
(5654,8989,2)
(3720,6200,2)
(5851,2444,2)
(4558,1984,2)
(6537,1694,2)
(5292,5712,2)
(9073,115,2)
(617,2845,2)
(3054,6155,2)
(3800,8285,2)
(2673,7939,2)
(1001,115,2)
(1451,3192,2)
(2409,8107,2)
(5638,4515,2)
(1266,8074,2)
(5895,3142,2)
(7009,8756,2)
(5296,7514,2)
(7959,115,2)
(4510,5775,2)
(2787,4253,2)
(8527,7514,2)
(2946,8756,2)
(5357,2596,2)
(5809,8111,2)
(4662,7977,2)
(1266,226,2)
(5210,4408,2)
(7025,1785,2)
(6282,3095,2)
(2924,270,2)
(4443,3142,2)
(1681,5204,2)
(7872,4044,2)
(2315,8391,2)
(6739,352,2)
(2110,6155,2)
(7321,7940,2)
(1748,981,2)
(8188,8889,2)
(4976,8677,2)
(3978,706,2)
(6926,8391,2)
(8041,7628,2)
(8226,1755,2)
(6910,1379,2)
(8815,2526,2)
(4580,2845,2)
(1753,4984,2)
(7236,1479,2)
(9120,5540,2)
(5716,6737,2)
(7353,4976,2)
(3057,7628,2)
(491,1235,2)
(7412,7258,2)
(3357,2,2)
(2118,1709,2)
(7699,226,2)
(5991,6475,2)
(3932,966,2)
(6431,5829,2)
(5869,1311,2)
(8063,7785,2)
(8537,874,2)
(7080,1599,2)
(8254,3483,2)
(408,2187,2)
(19,4698,2)
(390,8756,2)
(1638,7038,2)
(1213,115,2)
(3622,1235,2)
(8089,3863,2)
(4620,8756,2)
(1167,8391,2)
(7455,4397,2)
(3359,1954,2)
(5266,8889,2)
(6714,9140,2)
(6901,7841,2)
(4915,611,2)
(2854,1653,2)
(8198,2501,2)
(5686,3142,2)
(3573,2587,2)
(795,8391,2)
(4873,2112,2)
(5000,3320,2)
(4683,2,2)
(2821,8531,2)
(7041,4413,2)
(9127,6594,2)
(8011,6730,2)
(6745,3417,2)
(7503,1401,2)
(1639,131,2)
(6737,1254,2)
(4525,7262,2)
(3792,8698,2)
(7938,1889,2)
(7743,7233,2)
(2363,8756,2)
(851,4679,2)
(2243,7711,2)
(6129,6613,2)
(7955,7973,2)
(8891,2043,2)
(5056,7760,2)
(3804,453,2)
(4200,3823,2)
(3509,1158,2)
(7618,1240,2)
(6636,3812,2)
(991,7001,2)
(1766,115,2)
(2823,115,2)
(7493,7514,2)
(5379,6791,2)
(6887,1888,2)
(2550,2366,2)
(151,5196,2)
(1732,8493,2)
(1177,115,2)
(2428,6155,2)
(4994,7760,2)
(833,3218,2)
(5152,575,2)
(378,6299,2)
(1812,3781,2)
(2260,6179,2)
(8825,4346,2)
(2369,4698,2)
(2347,3942,2)
(1135,6804,2)
(4709,904,2)
(102,4283,2)
(2261,6899,2)
(6132,1493,2)
(5332,8528,2)
(9127,6285,2)
(7284,7493,2)
(6547,6155,2)
(5760,4044,2)
(8741,5704,2)
(4271,2771,2)
(6865,8756,2)
(5492,3758,2)
(4765,7210,2)
(5434,5408,2)
(8616,1954,2)
(957,7963,2)
(8837,115,2)
(5638,3565,2)
(2688,706,2)
(5744,2596,2)
(3297,9096,2)
(1403,536,2)
(4848,6995,2)
(1173,7722,2)
(6478,5683,2)
(8247,5927,2)
(5235,7014,2)
(6896,3769,2)
(6306,410,2)
(4669,2559,2)
(2360,7590,2)
(4044,7760,2)
(5086,3286,2)
(1384,3812,2)
(277,7830,2)
(8835,3108,2)
(7101,8523,2)
(1619,5089,2)
(564,8756,2)
(3919,6804,2)
(1868,7841,2)
(7197,115,2)
(4976,8369,2)
(1567,3621,2)
(2106,4624,2)
(8612,403,2)
(2536,8756,2)
(8083,1062,2)
(8757,3142,2)
(9086,2206,2)
(7536,115,2)
(5553,208,2)
(3266,4916,2)
(5997,3814,2)
(3349,92,2)
(3251,5554,2)
(4985,2593,2)
(8876,6734,2)
(5871,9034,2)
(2895,5752,2)
(7996,8246,2)
(8099,3906,2)
(3804,929,2)
(4267,7841,2)
(5286,8756,2)
(2544,1280,2)
(324,2199,2)
(2666,3303,2)
(6538,874,2)
(6030,8391,2)
(1413,115,2)
(7195,7493,2)
(4467,7973,2)
(3058,1666,2)
(6357,6053,2)
(2582,4391,2)
(5178,437,2)
(5887,3950,2)
(5580,2927,2)
(7821,1235,2)
(4691,6314,2)
(2637,408,2)
(5982,8391,2)
(953,8756,2)
(5505,8431,2)
(3419,6246,2)
(4575,1653,2)
(5746,3320,2)
(8038,8111,2)
(6346,1924,2)
(6730,2030,2)
(6071,7262,2)
(4496,1657,2)
(3513,6053,2)
(5296,1235,2)
(6180,3934,2)
(4375,8595,2)
(6912,2909,2)
(5553,8756,2)
(340,115,2)
(1605,8068,2)
(7827,7614,2)
(5140,7210,2)
(46,1657,2)
(3837,7711,2)
(3253,1785,2)
(6111,8391,2)
(4921,8883,2)
(1491,2866,2)
(7936,6008,2)
(5594,3218,2)
(7626,2112,2)
(8905,7590,2)
(5545,7827,2)
(6555,6677,2)
(3621,2112,2)
(656,3863,2)
(2403,671,2)
(4949,9096,2)
(7899,5586,2)
(5502,4016,2)
(8600,46,2)
(8578,4876,2)
(7868,3218,2)
(3972,8815,2)
(6555,8391,2)
(5226,4472,2)
(3804,6563,2)
(6502,2981,2)
(1250,5752,2)
(7274,2187,2)
(973,7628,2)
(4253,2303,2)
(3151,4876,2)
(4028,3658,2)
(8928,4333,2)
(6117,1653,2)
(3759,4388,2)
(7409,6292,2)
(473,115,2)
(3496,8499,2)
(4587,2931,2)
(4058,3488,2)
(8385,2771,2)
(6611,115,2)
(3791,7354,2)
(2151,8391,2)
(7114,1153,2)
(4922,3097,2)
(6721,3752,2)
(333,2414,2)
(9060,5501,2)
(4192,1235,2)
(3090,8129,2)
(6663,2845,2)
(6995,1799,2)
(6599,6155,2)
(1779,609,2)
(4543,3814,2)
(3937,1311,2)
(4472,5156,2)
(7353,2596,2)
(3497,403,2)
(7316,4679,2)
(3130,7711,2)
(6921,3965,2)
(3232,2979,2)
(369,3965,2)
(8497,8391,2)
(5818,8232,2)
(909,115,2)
(7605,7590,2)
(3666,7353,2)
(8513,3218,2)
(8627,1173,2)
(8674,410,2)
(1637,4016,2)
(2077,5408,2)
(1484,7029,2)
(7271,3427,2)
(3611,3814,2)
(2274,575,2)
(5181,1831,2)
(8186,101,2)
(6935,8391,2)
(1241,115,2)
(6560,1488,2)
(7775,115,2)
(1899,115,2)
(3984,2199,2)
(8649,7001,2)
(3780,6068,2)
(4375,4587,2)
(5516,408,2)
(8250,453,2)
(2647,8391,2)
(2234,3108,2)
(360,5140,2)
(8117,8241,2)
(3969,8728,2)
(130,7233,2)
(3136,575,2)
(3687,7947,2)
(2241,5631,2)
(1643,874,2)
(8040,1972,2)
(5085,9064,2)
(1421,46,2)
(8500,115,2)
(73,8793,2)
(4089,7143,2)
(2148,7258,2)
(5809,4515,2)
(1209,2130,2)
(2458,1724,2)
(944,6867,2)
(6278,2303,2)
(5909,8756,2)
(4624,8891,2)
(4232,115,2)
(570,7001,2)
(1462,115,2)
(6908,5698,2)
(6284,4515,2)
(7606,8756,2)
(3213,9130,2)
(7218,3198,2)
(8745,3417,2)
(9009,150,2)
(3908,4994,2)
(6060,5342,2)
(1443,2344,2)
(8876,7143,2)
(151,2964,2)
(2690,7579,2)
(6703,115,2)
(4100,7760,2)
(7574,92,2)
(5305,1235,2)
(5748,6479,2)
(8674,2879,2)
(4170,1254,2)
(1888,4925,2)
(6768,2241,2)
(5977,4583,2)
(7929,8756,2)
(1791,5698,2)
(4987,7226,2)
(1838,799,2)
(3141,4168,2)
(7911,8751,2)
(7721,1311,2)
(6805,1972,2)
(3142,7852,2)
(6254,8391,2)
(8395,6826,2)
(8031,8391,2)
(8242,115,2)
(4665,4915,2)
(6643,7940,2)
(5570,3823,2)
(8038,700,2)
(4292,1063,2)
(4279,1459,2)
(5844,7590,2)
(3680,3123,2)
(4919,6541,2)
(5433,3530,2)
(8937,1311,2)
(6158,8391,2)
(2627,701,2)
(6392,1458,2)
(5004,904,2)
(7349,8391,2)
(8071,7514,2)
(7108,6804,2)
(4190,7969,2)
(3228,2983,2)
(9046,4974,2)
(4773,3488,2)
(865,4700,2)
(1353,6314,2)
(7682,846,2)
(5863,4388,2)
(4570,8756,2)
(7452,1985,2)
(286,8756,2)
(2771,8794,2)
(6862,1240,2)
(7842,3781,2)
(5048,6349,2)
(6318,2845,2)
(4565,462,2)
(2142,7514,2)
(5953,7569,2)
(320,5454,2)
(6067,6155,2)
(4142,408,2)
(658,7570,2)
(6722,7710,2)
(6874,904,2)
(7398,115,2)
(5582,4698,2)
(4533,8746,2)
(5214,4515,2)
(9045,4388,2)
(2100,7569,2)
(1786,2835,2)
(9028,2835,2)
(8009,115,2)
(85,4558,2)
(5556,900,2)
(9104,4239,2)
(912,5251,2)
(1412,8756,2)
(3963,4594,2)
(2343,706,2)
(3613,4333,2)
(6188,3198,2)
(3439,1705,2)
(6594,8391,2)
(235,4793,2)
(655,115,2)
(6165,4205,2)
(942,3198,2)
(1822,5204,2)
(3686,2526,2)
(7299,4028,2)
(6939,4697,2)
(1635,2754,2)
(4056,8391,2)
(4508,7917,2)
(7408,2,2)
(7369,4976,2)
(4470,7143,2)
(5775,3095,2)
(561,2596,2)
(1641,2808,2)
(8190,2983,2)
(1435,135,2)
(4477,7953,2)
(7764,2060,2)
(88,3847,2)
(2543,4326,2)
(2140,6713,2)
(2612,3095,2)
(7549,46,2)
(5494,2112,2)
(8697,8400,2)
(4969,2559,2)
(4176,8391,2)
(8460,8778,2)
(8884,8391,2)
(4375,9035,2)
(1497,2983,2)
(6241,1212,2)
(4067,7405,2)
(4291,1685,2)
(6609,8391,2)
(7917,8889,2)
(4195,4326,2)
(8601,5162,2)
(7992,904,2)
(5375,8756,2)
(8552,8677,2)
(4869,5454,2)
(8531,115,2)
(5762,4793,2)
(4256,1254,2)
(1415,373,2)
(2757,2283,2)
(6980,7870,2)
(8832,6582,2)
(8854,3553,2)
(4735,8241,2)
(1415,4515,2)
(7710,115,2)
(1771,8756,2)
(3463,4585,2)
(8768,46,2)
(4587,611,2)
(926,8391,2)
(6864,4976,2)
(2616,874,2)
(7404,2597,2)
(1722,8756,2)
(6473,4945,2)
(7880,8391,2)
(6847,980,2)
(116,7940,2)
(6918,1583,2)
(3804,8471,2)
(8295,8391,2)
(1144,92,2)
(7380,7891,2)
(8642,3891,2)
(2995,7257,2)
(5829,7001,2)
(2456,1104,2)
(4668,6179,2)
(8038,2112,2)
(6064,4340,2)
(5498,8697,2)
(7107,8391,2)
(3513,4822,2)
(262,4326,2)
(8340,115,2)
(3966,5069,2)
(4361,1493,2)
(8764,408,2)
(6594,6285,2)
(5463,6254,2)
(1392,115,2)
(2916,134,2)
(4472,4876,2)
(9063,1972,2)
(8558,292,2)
(5350,5777,2)
(4616,6723,2)
(2687,6649,2)
(1357,3895,2)
(5885,951,2)
(3187,91,2)
(2460,8065,2)
(1937,5712,2)
(6960,3758,2)
(2082,1656,2)
(1925,1954,2)
(764,5698,2)
(1734,4916,2)
(7305,8756,2)
(7856,874,2)
(2342,1134,2)
(6808,8677,2)
(368,6385,2)
(7108,115,2)
(3387,6053,2)
(8352,2995,2)
(3771,1509,2)
(2427,8756,2)
(2582,134,2)
(1793,1888,2)
(8857,6292,2)
(1181,930,2)
(3772,6433,2)
(8102,3333,2)
(3444,7940,2)
(8055,115,2)
(2350,8391,2)
(4264,6867,2)
(2155,8481,2)
(3125,3108,2)
(8595,8391,2)
(3445,4735,2)
(8008,115,2)
(1241,8391,2)
(4000,3530,2)
(7792,8837,2)
(4830,611,2)
(8338,2962,2)
(7983,6858,2)
(760,798,2)
(4205,5950,2)
(6866,3142,2)
(1415,1280,2)
(5450,5204,2)
(4677,2835,2)
(3540,410,2)
(4746,3895,2)
(7561,8391,2)
(7743,2043,2)
(7880,7760,2)
(7826,1311,2)
(8123,314,2)
(6521,1152,2)
(6188,904,2)
(143,280,2)
(6681,46,2)
(3834,5226,2)
(6882,7977,2)
(3614,1347,2)
(2059,6155,2)
(1745,874,2)
(134,7392,2)
(273,7514,2)
(1481,2983,2)
(447,874,2)
(9123,4253,2)
(4873,3215,2)
(4880,2685,2)
(1357,5227,2)
(8149,1729,2)
(6195,7405,2)
(5851,5204,2)
(4650,3451,2)
(8867,4697,2)
(6873,1657,2)
(6007,2087,2)
(1254,3769,2)
(876,5795,2)
(7812,2060,2)
(3491,2283,2)
(911,6155,2)
(3487,8756,2)
(3948,1954,2)
(578,8391,2)
(7067,2210,2)
(670,8681,2)
(2302,7628,2)
(5110,3891,2)
(309,115,2)
(1254,6804,2)
(606,7514,2)
(3509,3565,2)
(4521,1888,2)
(5208,5777,2)
(4925,6265,2)
(1206,4124,2)
(7988,3814,2)
(2287,2112,2)
(8996,3123,2)
(2275,2983,2)
(4117,4531,2)
(8944,408,2)
(9003,3752,2)
(2251,352,2)
(2496,2172,2)
(6502,5809,2)
(4066,1220,2)
(8155,6659,2)
(826,2191,2)
(3337,7262,2)
(6184,3891,2)
(8739,7760,2)
(6190,8391,2)
(610,8391,2)
(7416,1235,2)
(4824,5669,2)
(5525,3222,2)
(7812,3621,2)
(5795,115,2)
(7095,2060,2)
(577,2036,2)
(1101,4467,2)
(917,3218,2)
(3128,1479,2)
(3787,3553,2)
(5038,3001,2)
(4627,2570,2)
(4908,4793,2)
(4447,4558,2)
(196,46,2)
(8353,403,2)
(1000,874,2)
(1062,7545,2)
(1465,5069,2)
(3262,4565,2)
(624,8431,2)
(7854,951,2)
(5622,2206,2)
(8833,8713,2)
(8452,4289,2)
(5584,8756,2)
(845,6613,2)
(4827,2983,2)
(8313,115,2)
(5877,3427,2)
(4278,1311,2)
(1044,8391,2)
(3451,4579,2)
(435,4698,2)
(6784,8777,2)
(1415,7094,2)
(2534,1785,2)
(4972,3823,2)
(244,5938,2)
(213,2189,2)
(4972,2368,2)
(8594,3906,2)
(929,2053,2)
(4864,115,2)
(7807,257,2)
(1122,115,2)
(4932,5594,2)
(8057,2283,2)
(2995,8756,2)
(7306,115,2)
(4917,1954,2)
(1,352,2)
(939,8187,2)
(3049,4697,2)
(5960,2191,2)
(6424,4253,2)
(208,7105,2)
(2037,2477,2)
(1415,8727,2)
(1417,3142,2)
(779,3201,2)
(6793,6858,2)
(4886,8756,2)
(1982,4876,2)
(307,8481,2)
(4523,46,2)
(4333,1217,2)
(7966,8458,2)
(8623,3142,2)
(6330,8756,2)
(6190,115,2)
(2123,4720,2)
(7971,8756,2)
(7115,8756,2)
(3220,7940,2)
(5237,1235,2)
(6665,2172,2)
(3949,7514,2)
(4197,7760,2)
(4741,6378,2)
(1418,2043,2)
(3806,8546,2)
(2137,7597,2)
(6773,5712,2)
(3322,1705,2)
(8984,6200,2)
(6926,115,2)
(4325,8756,2)
(7710,8756,2)
(2672,3965,2)
(765,5540,2)
(3213,7039,2)
(402,8074,2)
(8932,3198,2)
(7921,9090,2)
(7282,403,2)
(7912,8889,2)
(8241,7799,2)
(8572,1564,2)
(4016,1644,2)
(1955,115,2)
(2621,1905,2)
(7626,3215,2)
(4332,2686,2)
(7163,8244,2)
(6582,7103,2)
(7283,1770,2)
(5337,4095,2)
(3526,6858,2)
(265,5586,2)
(297,7353,2)
(5595,6854,2)
(2257,1488,2)
(5283,4198,2)
(5239,660,2)
(2777,7001,2)
(1168,8391,2)
(4027,4236,2)
(3316,4698,2)
(5448,7514,2)
(4603,2036,2)
(9004,1458,2)
(3122,170,2)
(1203,9128,2)
(2398,8431,2)
(5476,2835,2)
(7973,4468,2)
(1967,115,2)
(7001,7413,2)
(4378,6314,2)
(3912,1479,2)
(5602,429,2)
(2751,6479,2)
(5817,1488,2)
(7463,4285,2)
(1779,8391,2)
(7975,2866,2)
(191,1908,2)
(1577,453,2)
(8666,8391,2)
(3222,6960,2)
(8496,115,2)
(8816,12,2)
(2164,2835,2)
(241,8751,2)
(4819,8845,2)
(5709,1954,2)
(7430,2596,2)
(3081,5173,2)
(1225,478,2)
(529,459,2)
(6194,7205,2)
(4473,4236,2)
(7739,2210,2)
(8448,284,2)
(4157,8391,2)
(3214,8391,2)
(7271,1418,2)
(1631,131,2)
(4254,462,2)
(6496,7930,2)
(5809,2112,2)
(6637,8538,2)
(6469,7841,2)
(8770,1954,2)
(601,7939,2)
(878,2036,2)
(3168,4985,2)
(5397,5665,2)
(4752,6804,2)
(3461,410,2)
(4993,7103,2)
(2127,2191,2)
(2205,1705,2)
(7706,8232,2)
(2381,3451,2)
(3062,8391,2)
(497,3095,2)
(7649,7589,2)
(5719,1954,2)
(3973,6548,2)
(3725,7917,2)
(2592,1254,2)
(2021,4697,2)
(8192,4044,2)
(5144,115,2)
(1195,7590,2)
(8702,8756,2)
(5316,1724,2)
(5991,706,2)
(8715,5084,2)
(8144,8756,2)
(5664,228,2)
(5484,4963,2)
(3384,3863,2)
(7956,6155,2)
(1873,115,2)
(2548,3812,2)
(7092,4285,2)
(7636,4698,2)
(6665,2151,2)
(9019,5204,2)
(828,4125,2)
(208,5204,2)
(1665,6179,2)
(5796,5722,2)
(8143,403,2)
(2287,6563,2)
(2960,3095,2)
(5591,3814,2)
(6314,2776,2)
(3203,845,2)
(6419,4587,2)
(3052,1306,2)
(8495,4679,2)
(4729,7917,2)
(8038,4149,2)
(6822,7262,2)
(1748,5027,2)
(4104,3295,2)
(7352,916,2)
(1806,3123,2)
(4047,904,2)
(8967,6394,2)
(1124,228,2)
(3501,507,2)
(271,8832,2)
(5770,2765,2)
(8248,8430,2)
(2141,507,2)
(3713,8756,2)
(3703,5237,2)
(8209,2141,2)
(8958,8241,2)
(1413,8391,2)
(671,8550,2)
(318,8756,2)
(7473,3863,2)
(5666,2654,2)
(7112,4793,2)
(1215,7066,2)
(6511,6155,2)
(315,5698,2)
(6080,8391,2)
(1326,2866,2)
(1500,575,2)
(2618,1874,2)
(8239,1656,2)
(9015,9073,2)
(8322,4579,2)
(2130,4239,2)
(39,6014,2)
(1616,3752,2)
(142,2654,2)
(5337,9140,2)
(4556,358,2)
(4793,3983,2)
(8960,6155,2)
(424,8391,2)
(6322,8756,2)
(4432,7760,2)
(2435,1370,2)
(240,3396,2)
(321,2366,2)
(5606,3095,2)
(1679,8173,2)
(7127,1873,2)
(6858,5540,2)
(5586,4619,2)
(2482,8481,2)
(5051,4088,2)
(1742,8952,2)
(7890,932,2)
(4456,1785,2)
(6549,2537,2)
(8265,8523,2)
(4856,2458,2)
(408,8247,2)
(4033,7155,2)
(4650,3621,2)
(1329,7974,2)
(4580,6280,2)
(5662,2060,2)
(270,7977,2)
(2166,4564,2)
(4014,8279,2)
(486,5698,2)
(2943,6155,2)
(8577,4558,2)
(2139,7405,2)
(5813,115,2)
(8345,7614,2)
(1066,462,2)
(8380,4326,2)
(3523,4285,2)
(1685,8134,2)
(8552,1078,2)
(4632,7890,2)
(7568,3198,2)
(5094,1894,2)
(7385,6070,2)
(8401,1311,2)
(7569,6657,2)
(3785,8391,2)
(3925,7828,2)
(5235,5123,2)
(5727,1173,2)
(8067,7066,2)
(916,6155,2)
(655,8391,2)
(1061,115,2)
(2036,4579,2)
(1241,2199,2)
(2125,4205,2)
(2219,3123,2)
(8932,904,2)
(5341,8832,2)
(9064,1954,2)
(2336,228,2)
(7363,5408,2)
(8844,4909,2)
(3090,1488,2)
(6571,2983,2)
(6485,1488,2)
(2233,3752,2)
(425,115,2)
(3492,1104,2)
(1162,2210,2)
(9013,228,2)
(2799,6677,2)
(4239,5975,2)
(4486,3417,2)
(4195,5605,2)
(1321,2020,2)
(3112,4467,2)
(6284,7039,2)
(3654,2210,2)
(7927,8756,2)
(8061,7514,2)
(8805,7940,2)
(5677,2206,2)
(2359,4650,2)
(5196,8674,2)
(7137,408,2)
(6919,3891,2)
(2154,4289,2)
(8425,1648,2)
(4604,2526,2)
(5384,2834,2)
(6278,6867,2)
(2112,3969,2)
(4628,105,2)
(6419,8021,2)
(4899,5373,2)
(7745,1785,2)
(6670,4236,2)
(926,5752,2)
(7991,5746,2)
(5709,7999,2)
(1058,4558,2)
(99,4005,2)
(393,2053,2)
(6293,977,2)
(4131,4579,2)
(3629,7354,2)
(3435,3382,2)
(2622,706,2)
(2099,3451,2)
(1222,1966,2)
(8665,2537,2)
(6523,8391,2)
(7849,8802,2)
(2607,8756,2)
(8208,7590,2)
(3375,352,2)
(1844,706,2)
(4628,5382,2)
(3246,2366,2)
(4996,4205,2)
(5301,769,2)
(8756,3145,2)
(6359,8832,2)
(4124,1583,2)
(4417,5162,2)
(3868,5540,2)
(3589,7883,2)
(1530,5964,2)
(3130,8391,2)
(249,904,2)
(8450,3530,2)
(5214,9130,2)
(3435,8105,2)
(4840,3451,2)
(2287,7140,2)
(4553,874,2)
(521,92,2)
(8194,6173,2)
(3747,4861,2)
(1260,12,2)
(1923,920,2)
(2288,8391,2)
(3804,3657,2)
(549,4948,2)
(7470,4974,2)
(4633,8756,2)
(3385,2644,2)
(5593,8111,2)
(330,7792,2)
(8757,2673,2)
(5371,8391,2)
(5436,3906,2)
(5543,6200,2)
(7333,4253,2)
(6520,646,2)
(5214,2112,2)
(2381,3621,2)
(7662,228,2)
(8371,5752,2)
(9073,8391,2)
(5783,7870,2)
(903,115,2)
(6889,4697,2)
(8110,5829,2)
(8318,6445,2)
(7347,2187,2)
(9119,8391,2)
(2651,6352,2)
(7883,2845,2)
(434,5374,2)
(4402,618,2)
(3818,2537,2)
(4091,7569,2)
(613,6070,2)
(1881,8391,2)
(6993,1410,2)
(7925,5018,2)
(416,115,2)
(4964,7514,2)
(6462,1149,2)
(1416,5698,2)
(8091,2954,2)
(6450,6804,2)
(5873,1888,2)
(7906,8756,2)
(1849,410,2)
(1621,4236,2)
(8802,8391,2)
(3625,2845,2)
(7504,5316,2)
(6072,8391,2)
(5239,4172,2)
(3591,2036,2)
(3547,7650,2)
(7493,2116,2)
(1996,7940,2)
(1729,6132,2)
(2997,7828,2)
(5311,4908,2)
(2791,2537,2)
(8560,6314,2)
(7380,1657,2)
(7031,115,2)
(880,453,2)
(7355,7841,2)
(993,92,2)
(6628,6613,2)
(7218,904,2)
(4342,46,2)
(8573,1653,2)
(7513,6155,2)
(2,1235,2)
(8853,904,2)
(7148,7001,2)
(6492,1220,2)
(8506,2835,2)
(1712,5156,2)
(865,4945,2)
(2152,1459,2)
(8181,7939,2)
(8775,3300,2)
(1198,4698,2)
(5190,951,2)
(152,7210,2)
(6611,5869,2)
(7765,8756,2)
(7901,611,2)
(7197,3123,2)
(6339,1954,2)
(2702,3752,2)
(1856,1459,2)
(5729,8493,2)
(6564,1254,2)
(6035,7760,2)
(8348,115,2)
(3874,5777,2)
(8123,5540,2)
(3231,8366,2)
(7851,4687,2)
(3750,5204,2)
(716,3772,2)
(1157,6155,2)
(5708,5346,2)
(8481,1682,2)
(4375,2955,2)
(5638,1280,2)
(3633,2835,2)
(7525,2845,2)
(4650,2309,2)
(7568,1482,2)
(9100,1656,2)
(3213,3823,2)
(7578,115,2)
(2171,8756,2)
(8246,2330,2)
(3445,8117,2)
(7340,8889,2)
(8410,8523,2)
(6844,5100,2)
(6678,115,2)
(4022,3218,2)
(8735,7514,2)
(7603,3218,2)
(9012,8341,2)
(9007,2771,2)
(5633,4326,2)
(5936,874,2)
(6296,46,2)
(4982,8391,2)
(5168,7841,2)
(5094,2009,2)
(7119,5965,2)
(180,536,2)
(5998,846,2)
(4921,5501,2)
(8055,8391,2)
(6813,8756,2)
(8814,7821,2)
(8892,4343,2)
(3343,8254,2)
(5499,6155,2)
(5638,1405,2)
(7714,874,2)
(7650,6479,2)
(8618,115,2)
(2522,1656,2)
(7622,4984,2)
(7840,6200,2)
(4654,4697,2)
(1987,5712,2)
(5705,2053,2)
(1232,3541,2)
(4375,8021,2)
(5214,700,2)
(7254,2085,2)
(1839,226,2)
(6457,2879,2)
(2151,2172,2)
(3586,2512,2)
(3197,3650,2)
(6069,7940,2)
(3349,6179,2)
(2754,40,2)
(646,6899,2)
(8786,3363,2)
(3809,4641,2)
(2898,2199,2)
(4337,8391,2)
(6639,403,2)
(7868,7587,2)
(1253,6155,2)
(154,3586,2)
(3577,2,2)
(1251,4698,2)
(4698,270,2)
(1165,5861,2)
(1249,6132,2)
(2494,1785,2)
(2805,7262,2)
(492,2020,2)
(3831,7500,2)
(2340,7828,2)
(226,7223,2)
(8968,7570,2)
(4378,5712,2)
(8967,6155,2)
(8673,3891,2)
(143,7951,2)
(4970,3415,2)
(4452,3668,2)
(3804,6649,2)
(5233,5501,2)
(559,8715,2)
(5785,4435,2)
(4489,8777,2)
(6507,4408,2)
(4569,5586,2)
(3664,4289,2)
(2763,115,2)
(3024,7059,2)
(6135,415,2)
(6284,8111,2)
(3529,8432,2)
(2612,5394,2)
(3431,2866,2)
(610,115,2)
(1805,6155,2)
(1415,1158,2)
(522,3752,2)
(1049,408,2)
(4024,4732,2)
(8432,5983,2)
(2537,5922,2)
(5044,134,2)
(3187,7982,2)
(4375,5366,2)
(2314,1888,2)
(1705,3904,2)
(3001,8391,2)
(3266,5548,2)
(6415,2212,2)
(6241,1086,2)
(417,6155,2)
(1810,8756,2)
(8837,8391,2)
(8582,4698,2)
(4341,8712,2)
(6641,6280,2)
(2834,5712,2)
(9077,2161,2)
(6630,3871,2)
(5067,5605,2)
(5314,7760,2)
(1562,5408,2)
(1116,3844,2)
(4779,6385,2)
(4308,4157,2)
(1637,4282,2)
(2071,5501,2)
(8966,7628,2)
(7493,5633,2)
(8275,2283,2)
(8306,7628,2)
(4375,7039,2)
(2378,8756,2)
(7844,5335,2)
(3333,1365,2)
(7780,7760,2)
(8933,1254,2)
(6679,208,2)
(8760,3810,2)
(0,3810,2)
(7491,5346,2)
(4624,8493,2)
(7802,1234,2)
(3657,306,2)
(8996,463,2)
(8418,1657,2)
(5339,6548,2)
(7205,1724,2)
(8126,8254,2)
(4323,8756,2)
(5494,6858,2)
(7223,425,2)
(4798,6867,2)
(5422,2260,2)
(2355,1240,2)
(3213,2112,2)
(7136,4497,2)
(1546,916,2)
(5868,1048,2)
(1012,410,2)
(6227,1401,2)
(4205,3942,2)
(1951,2191,2)
(8783,408,2)
(6014,7316,2)
(8927,3153,2)
(848,3810,2)
(1851,1875,2)
(2488,6179,2)
(1939,5586,2)
(8986,8756,2)
(1415,6388,2)
(7638,706,2)
(2721,4619,2)
(3266,6596,2)
(3812,3095,2)
(988,393,2)
(7798,3501,2)
(6288,4435,2)
(4977,9028,2)
(6764,208,2)
(1937,8391,2)
(2399,7917,2)
(5512,2123,2)
(5059,4697,2)
(7005,8391,2)
(1415,2135,2)
(4722,2445,2)
(7089,4847,2)
(8019,3142,2)
(1039,7532,2)
(6120,5656,2)
(1777,5712,2)
(5603,1479,2)
(1570,7262,2)
(4165,8756,2)
(4973,8756,2)
(4375,9138,2)
(3614,1509,2)
(4817,257,2)
(1807,7614,2)
(6868,7928,2)
(1434,5501,2)
(4648,6385,2)
(1532,408,2)
(1814,4435,2)
(2756,7283,2)
(1650,6070,2)
(2460,7198,2)
(8761,8756,2)
(4616,6155,2)
(3658,4239,2)
(3696,1524,2)
(8054,7909,2)
(1733,7143,2)
(7498,8391,2)
(7418,4117,2)
(768,115,2)
(6527,3969,2)
(2245,8756,2)
(9043,6804,2)
(4201,7841,2)
(2181,6022,2)
(7336,7760,2)
(6054,8391,2)
(4089,3621,2)
(1082,115,2)
(8681,9140,2)
(7422,1987,2)
(7013,1874,2)
(2301,3095,2)
(2514,3781,2)
(3804,2112,2)
(586,904,2)
(3896,4697,2)
(4464,6715,2)
(1425,2964,2)
(2243,3218,2)
(4125,7828,2)
(8666,115,2)
(5965,2043,2)
(5293,3758,2)
(2287,2955,2)
(5649,115,2)
(6069,4340,2)
(6262,6155,2)
(8038,6649,2)
(8774,8523,2)
(6700,115,2)
(7059,1656,2)
(8938,4289,2)
(7590,1484,2)
(2733,2445,2)
(5991,2343,2)
(517,6949,2)
(8182,5555,2)
(8138,753,2)
(1306,7150,2)
(5172,115,2)
(1415,3565,2)
(6502,6419,2)
(3453,7354,2)
(4560,8535,2)
(6533,3530,2)
(7623,1220,2)
(8009,8391,2)
(883,5204,2)
(3990,8129,2)
(7003,5849,2)
(2445,7353,2)
(3097,250,2)
(6274,8728,2)
(7951,5244,2)
(6278,5961,2)
(4375,1158,2)
(5927,3386,2)
(3881,5251,2)
(766,1509,2)
(4184,5192,2)
(2588,5712,2)
(3792,9124,2)
(4215,5752,2)
(7982,8391,2)
(1415,3223,2)
(8750,2835,2)
(8274,88,2)
(3815,8561,2)
(6979,8712,2)
(8060,3142,2)
(5402,115,2)
(6932,8391,2)
(1220,2473,2)
(4253,4522,2)
(7803,799,2)
(8562,1653,2)
(4878,2053,2)
(8897,228,2)
(3752,989,2)
(5592,4289,2)
(1415,6981,2)
(8088,4793,2)
(8024,4985,2)
(339,115,2)
(838,5408,2)
(6326,7754,2)
(1415,3901,2)
(7858,6155,2)
(636,3165,2)
(3550,2187,2)
(57,8756,2)
(3324,2479,2)
(4828,8391,2)
(7799,1149,2)
(356,3123,2)
(7077,897,2)
(834,3123,2)
(3102,2983,2)
(4932,6234,2)
(2482,6577,2)
(2678,5752,2)
(510,1972,2)
(7683,7514,2)
(7909,8282,2)
(6331,1785,2)
(3392,904,2)
(5954,1954,2)
(1435,1240,2)
(2807,8756,2)
(6141,8751,2)
(2788,8756,2)
(3213,4515,2)
(724,8391,2)
(7698,4388,2)
(401,8756,2)
(5290,4876,2)
(2279,2199,2)
(1109,2537,2)
(5288,5033,2)
(4873,7039,2)
(5680,7760,2)
(6923,739,2)
(7863,2983,2)
(8047,2859,2)
(974,1656,2)
(2173,92,2)
(7982,91,2)
(5322,1705,2)
(3675,1235,2)
(3744,7828,2)
(3338,7628,2)
(6115,7628,2)
(2567,8391,2)
(6571,4055,2)
(2097,3814,2)
(4801,7864,2)
(7376,4579,2)
(413,115,2)
(101,8391,2)
(7744,6132,2)
(4004,706,2)
(338,3198,2)
(1303,1452,2)
(2527,1461,2)
(2057,8107,2)
(4034,7760,2)
(7076,799,2)
(2172,6285,2)
(5918,2241,2)
(8806,8391,2)
(8359,6155,2)
(6881,6376,2)
(2287,4350,2)
(8453,4763,2)
(924,6179,2)
(2598,6613,2)
(5586,6298,2)
(696,7262,2)
(8748,3969,2)
(4661,7870,2)
(1492,3123,2)
(1728,5204,2)
(5874,2983,2)
(1324,4018,2)
(3283,7628,2)
(3317,5752,2)
(2948,3632,2)
(5131,7868,2)
(5593,4976,2)
(2078,3232,2)
(1716,4253,2)
(5856,1479,2)
(1670,2845,2)
(6908,3427,2)
(2544,700,2)
(6633,1709,2)
(5258,7917,2)
(8486,2866,2)
(7066,7066,2)
(7014,1766,2)
(6349,2537,2)
(4161,1485,2)
(2583,7514,2)
(7857,3863,2)
(2227,410,2)
(2131,7828,2)
(1331,2677,2)
(575,7999,2)
(6401,6858,2)
(7738,7271,2)
(5181,5629,2)
(5660,3173,2)
(3810,5151,2)
(2099,3621,2)
(1794,904,2)
(1923,143,2)
(2287,9138,2)
(7394,2502,2)
(5722,7841,2)
(8719,1657,2)
(7561,115,2)
(7968,8543,2)
(8863,403,2)
(2415,908,2)
(3377,1149,2)
(3137,92,2)
(6949,3895,2)
(3804,6474,2)
(1840,6155,2)
(437,8391,2)
(2191,352,2)
(2044,2316,2)
(8953,2058,2)
(454,8756,2)
(4628,3106,2)
(8098,7841,2)
(4168,8391,2)
(3084,2187,2)
(7086,5540,2)
(5410,5586,2)
(996,1657,2)
(285,7628,2)
(706,7577,2)
(8558,5027,2)
(718,2243,2)
(2918,1709,2)
(126,507,2)
(171,2414,2)
(3538,6867,2)
(1969,115,2)
(8768,7555,2)
(2866,2191,2)
(4055,2983,2)
(3332,3965,2)
(5882,3810,2)
(8910,408,2)
(8161,6791,2)
(2972,4697,2)
(7258,2036,2)
(8433,6155,2)
(7399,904,2)
(3752,570,2)
(1648,4558,2)
(7976,7760,2)
(7679,7453,2)
(282,5408,2)
(1415,1269,2)
(392,6613,2)
(1686,6285,2)
(3814,1199,2)
(7965,8947,2)
(4458,91,2)
(8593,3812,2)
(4497,8756,2)
(3411,1656,2)
(1831,5256,2)
(2441,7262,2)
(6377,2866,2)
(1885,7665,2)
(3059,2951,2)
(8330,1240,2)
(8009,2845,2)
(1407,6804,2)
(4441,6613,2)
(1260,6150,2)
(8956,8756,2)
(5364,8751,2)
(4322,8065,2)
(7198,8065,2)
(867,410,2)
(7103,1705,2)
(4666,6971,2)
(5898,5847,2)
(1853,115,2)
(1048,3488,2)
(7839,1954,2)
(7519,2835,2)
(8763,8728,2)
(6369,2187,2)
(8662,403,2)
(3733,3701,2)
(9086,5209,2)
(1360,3891,2)
(5298,4020,2)
(8096,3752,2)
(3804,6968,2)
(724,3451,2)
(1151,5204,2)
(6881,4876,2)
(98,6804,2)
(6272,286,2)
(4367,7470,2)
(6863,7066,2)
(6484,609,2)
(3610,2835,2)
(905,1785,2)
(5371,2592,2)
(676,2665,2)
(8100,7271,2)
(2298,4326,2)
(738,8756,2)
(6647,7262,2)
(7797,8296,2)
(4461,7870,2)
(869,1954,2)
(3934,6804,2)
(737,6613,2)
(7563,8131,2)
(6060,6155,2)
(5421,408,2)
(4082,46,2)
(741,7577,2)
(9019,8391,2)
(1387,115,2)
(7657,1560,2)
(1466,4236,2)
(5187,8756,2)
(1211,5204,2)
(3773,7711,2)
(6613,552,2)
(7732,7353,2)
(6695,706,2)
(4098,7844,2)
(4885,8756,2)
(539,7977,2)
(1889,123,2)
(1114,4500,2)
(8091,5204,2)
(4337,459,2)
(6091,3823,2)
(3976,8856,2)
(89,6577,2)
(3601,5123,2)
(4982,8538,2)
(5647,3363,2)
(986,8134,2)
(7611,904,2)
(7152,1488,2)
(2591,115,2)
(3115,6289,2)
(5602,6613,2)
(4873,8111,2)
(4474,4420,2)
(8964,6004,2)
(7054,3299,2)
(4117,3553,2)
(3754,7570,2)
(3552,1888,2)
(1675,5204,2)
(202,598,2)
(6419,3889,2)
(2847,2146,2)
(402,1048,2)
(8664,6155,2)
(1138,904,2)
(8257,7353,2)
(4253,4793,2)
(1394,7816,2)
(7687,6548,2)
(6097,5829,2)
(1432,1149,2)
(3659,6385,2)
(8259,1311,2)
(1906,3604,2)
(1622,7973,2)
(3299,403,2)
(8013,3895,2)
(4732,5156,2)
(7966,7039,2)
(5585,4697,2)
(4253,7888,2)
(4513,7841,2)
(7528,8107,2)
(6827,8391,2)
(2190,8233,2)
(7252,1972,2)
(6429,2845,2)
(8419,115,2)
(563,2283,2)
(6848,3823,2)
(1641,3103,2)
(5978,403,2)
(2168,1149,2)
(2385,7841,2)
(3344,4974,2)
(3552,1992,2)
(6307,1785,2)
(6477,2191,2)
(2798,2537,2)
(2688,115,2)
(7320,7589,2)
(7793,2347,2)
(2683,8391,2)
(6125,115,2)
(5959,5752,2)
(8103,746,2)
(4690,268,2)
(3138,115,2)
(2514,7143,2)
(4118,2053,2)
(1199,4889,2)
(2226,7514,2)
(3171,8102,2)
(799,2537,2)
(2035,104,2)
(7864,228,2)
(4010,4253,2)
(1415,6968,2)
(2226,1235,2)
(2192,134,2)
(5981,5486,2)
(2289,8670,2)
(6430,8432,2)
(6998,904,2)
(6295,6867,2)
(6042,5752,2)
(7475,408,2)
(2104,3696,2)
(3608,706,2)
(5132,8756,2)
(115,3969,2)
(77,4289,2)
(2855,408,2)
(6196,8740,2)
(6535,2241,2)
(8331,6155,2)
(2663,92,2)
(3319,1254,2)
(6488,6804,2)
(2056,3823,2)
(6449,115,2)
(5655,8391,2)
(2401,2199,2)
(3984,189,2)
(5689,7346,2)
(8561,115,2)
(4936,2445,2)
(4781,5156,2)
(1574,8751,2)
(7367,5204,2)
(4728,403,2)
(440,8751,2)
(2861,5540,2)
(5484,6155,2)
(6544,7929,2)
(5012,4697,2)
(1463,7821,2)
(4798,115,2)
(371,1149,2)
(6910,5550,2)
(7704,1311,2)
(1907,6157,2)
(1878,352,2)
(3198,904,2)
(4580,115,2)
(6310,2199,2)
(5851,6187,2)
(7480,2074,2)
(5887,6742,2)
(5193,8431,2)
(3650,4072,2)
(5338,2,2)
(189,2199,2)
(7031,8391,2)
(5523,1785,2)
(6540,7628,2)
(7902,5454,2)
(1555,2537,2)
(2789,2537,2)
(84,8523,2)
(7332,4435,2)
(1418,3427,2)
(6063,8391,2)
(843,3095,2)
(6891,3752,2)
(2231,8200,2)
(8549,2964,2)
(8566,7665,2)
(856,6070,2)
(5175,7828,2)
(5374,1471,2)
(8439,4441,2)
(2256,5656,2)
(775,2845,2)
(7777,8452,2)
(1274,904,2)
(5334,284,2)
(9047,8391,2)
(346,2866,2)
(6907,5752,2)
(1452,2845,2)
(476,1830,2)
(1974,5178,2)
(4649,6867,2)
(4597,8065,2)
(7107,2983,2)
(4909,1220,2)
(6852,8756,2)
(6943,6858,2)
(5166,5238,2)
(8263,8756,2)
(6004,2034,2)
(1471,5156,2)
(5520,7909,2)
(8884,115,2)
(8219,8756,2)
(675,1240,2)
(7702,4908,2)
(295,6793,2)
(3509,5540,2)
(6479,3857,2)
(7118,2866,2)
(8279,115,2)
(7733,6155,2)
(1799,5958,2)
(7196,8391,2)
(3594,8391,2)
(3175,8391,2)
(546,6155,2)
(4133,1830,2)
(5587,4974,2)
(5369,115,2)
(4108,5752,2)
(2643,3095,2)
(1061,874,2)
(4306,8794,2)
(7847,4388,2)
(1398,7762,2)
(5428,5829,2)
(1415,4449,2)
(301,4285,2)
(8200,8391,2)
(5132,8219,2)
(9054,3758,2)
(2592,6967,2)
(5801,6919,2)
(1602,904,2)
(8038,3565,2)
(6625,3891,2)
(668,6804,2)
(1231,8391,2)
(606,1235,2)
(2234,8391,2)
(5608,611,2)
(7154,270,2)
(1268,6285,2)
(6451,8391,2)
(4879,2610,2)
(3942,6580,2)
(3676,2537,2)
(2191,3477,2)
(3235,7405,2)
(4468,5829,2)
(1028,7590,2)
(4604,1705,2)
(3667,3218,2)
(4146,2191,2)
(6502,2287,2)
(6710,4679,2)
(3509,8471,2)
(4656,2983,2)
(8811,115,2)
(8824,1254,2)
(4012,8391,2)
(2893,8889,2)
(1762,8756,2)
(2301,7760,2)
(4697,6202,2)
(6400,8289,2)
(4225,6858,2)
(6375,4697,2)
(3762,1254,2)
(5663,3553,2)
(2312,7143,2)
(2271,2187,2)
(2108,3382,2)
(4141,2596,2)
(2859,4224,2)
(1295,4994,2)
(2310,7841,2)
(6557,1049,2)
(8426,1509,2)
(4883,933,2)
(474,1266,2)
(3852,8756,2)
(1070,8756,2)
(8136,8756,2)
(4387,5752,2)
(3698,7841,2)
(326,5501,2)
(9049,226,2)
(211,7760,2)
(3950,4285,2)
(3421,1220,2)
(1447,8431,2)
(6013,1685,2)
(7625,3095,2)
(6433,4697,2)
(7001,8889,2)
(5983,4088,2)
(6581,3752,2)
(416,6155,2)
(6119,2537,2)
(6820,8165,2)
(1190,4945,2)
(345,8493,2)
(8038,1270,2)
(8129,4088,2)
(92,2488,2)
(8527,774,2)
(1126,1104,2)
(4260,8728,2)
(3318,7870,2)
(4069,4793,2)
(9076,1954,2)
(2492,7870,2)
(1954,7079,2)
(7204,6385,2)
(8296,6084,2)
(3758,1511,2)
(1901,5076,2)
(4404,3740,2)
(6412,5829,2)
(6981,6662,2)
(8977,3201,2)
(5237,7514,2)
(947,3823,2)
(3417,5501,2)
(7316,272,2)
(3239,2559,2)
(3818,799,2)
(2788,3877,2)
(8403,7085,2)
(3670,2596,2)
(8175,2587,2)
(7237,2964,2)
(6892,7001,2)
(7160,5501,2)
(2237,8391,2)
(5981,8923,2)
(2487,8391,2)
(2193,3814,2)
(6972,6979,2)
(5184,6190,2)
(1404,2187,2)
(5232,408,2)
(4873,4515,2)
(873,7120,2)
(6214,6688,2)
(8830,8391,2)
(3860,5712,2)
(500,2537,2)
(6693,1653,2)
(5892,46,2)
(6500,8523,2)
(6505,1657,2)
(1189,8107,2)
(7409,4057,2)
(8119,846,2)
(5294,7963,2)
(4155,1916,2)
(1379,228,2)
(8452,1149,2)
(2258,4793,2)
(7569,3059,2)
(7966,2112,2)
(3740,115,2)
(2747,8432,2)
(1912,8666,2)
(3629,9029,2)
(3994,4236,2)
(8499,7525,2)
(1895,6858,2)
(7866,3997,2)
(4104,8487,2)
(7808,2199,2)
(726,444,2)
(5851,1151,2)
(3325,7940,2)
(6158,8756,2)
(3182,352,2)
(3442,1173,2)
(6532,123,2)
(1415,6649,2)
(7524,4289,2)
(3758,2537,2)
(620,6613,2)
(1502,7821,2)
(3804,2955,2)
(2683,4908,2)
(8008,8391,2)
(2044,2,2)
(1410,403,2)
(2906,3984,2)
(1042,7354,2)
(4628,7514,2)
(3810,6957,2)
(3412,5454,2)
(3073,3198,2)
(4212,7868,2)
(5779,6608,2)
(6790,3198,2)
(7892,5696,2)
(1522,2187,2)
(7626,8493,2)
(6804,6385,2)
(5584,115,2)
(4837,5196,2)
(2522,115,2)
(2164,1672,2)
(994,7444,2)
(4072,8523,2)
(2217,115,2)
(1103,7760,2)
(2488,885,2)
(3653,2854,2)
(948,3123,2)
(8364,403,2)
(6289,1235,2)
(2803,3268,2)
(2176,5501,2)
(4375,4515,2)
(6791,1982,2)
(5455,7514,2)
(8430,2210,2)
(296,4697,2)
(6140,8405,2)
(5274,8493,2)
(2769,2537,2)
(9121,8493,2)
(8484,1785,2)
(2265,1427,2)
(264,8128,2)
(6065,4925,2)
(4516,4900,2)
(5215,1657,2)
(7654,1240,2)
(3374,8756,2)
(8923,7293,2)
(2416,4071,2)
(5208,1040,2)
(6851,2879,2)
(6006,7780,2)
(6801,904,2)
(4178,2596,2)
(8044,8538,2)
(5444,1240,2)
(1367,12,2)
(4558,921,2)
(6836,1509,2)
(2536,2647,2)
(8393,3757,2)
(8966,115,2)
(9128,4326,2)
(3639,609,2)
(6040,3123,2)
(36,6132,2)
(5809,4587,2)
(6243,403,2)
(4623,1954,2)
(430,4236,2)
(6904,2854,2)
(1860,7354,2)
(8277,8728,2)
(8568,609,2)
(704,2679,2)
(7353,5383,2)
(4555,6155,2)
(5164,2845,2)
(1908,7628,2)
(8158,6397,2)
(1034,3198,2)
(3621,4587,2)
(7049,771,2)
(5324,6772,2)
(5214,3095,2)
(8989,6730,2)
(8228,8756,2)
(6425,3142,2)
(4574,1954,2)
(7279,8065,2)
(6102,1235,2)
(7657,2036,2)
(48,7828,2)
(3483,5156,2)
(6348,6736,2)
(6419,3565,2)
(1661,8756,2)
(3997,7026,2)
(8988,8756,2)
(1104,7664,2)
(8189,4473,2)
(5532,2162,2)
(5802,1888,2)
(2666,4876,2)
(2287,8471,2)
(952,3621,2)
(1707,115,2)
(719,8391,2)
(6712,7940,2)
(3378,9140,2)
(1208,8391,2)
(1415,2112,2)
(7770,1954,2)
(3830,5204,2)
(769,8832,2)
(3658,4579,2)
(4273,7632,2)
(8442,8493,2)
(7007,453,2)
(2808,8751,2)
(6265,1273,2)
(3730,115,2)
(6916,8233,2)
(6574,1888,2)
(4231,4604,2)
(7042,46,2)
(2981,6649,2)
(5447,4925,2)
(5864,5656,2)
(7796,3758,2)
(8045,410,2)
(8034,4876,2)
(8504,8756,2)
(1415,2065,2)
(1266,2043,2)
(499,7155,2)
(930,5251,2)
(1202,3363,2)
(1335,5712,2)
(6419,1270,2)
(1785,7796,2)
(3989,7569,2)
(3820,1459,2)
(862,7870,2)
(6201,6838,2)
(2406,8359,2)
(4965,7693,2)
(933,575,2)
(4436,150,2)
(2162,8391,2)
(796,697,2)
(2842,8391,2)
(377,8824,2)
(3230,2335,2)
(1324,8628,2)
(609,778,2)
(6209,2690,2)
(7962,92,2)
(7832,176,2)
(7613,1459,2)
(7945,3648,2)
(3668,8723,2)
(1880,6867,2)
(8793,6412,2)
(8238,5752,2)
(8933,6652,2)
(3386,2187,2)
(3779,410,2)
(3804,7625,2)
(3072,46,2)
(6795,115,2)
(2926,5752,2)
(9085,1657,2)
(1002,4579,2)
(1842,4698,2)
(6223,115,2)
(3774,2845,2)
(6104,8391,2)
(5965,5829,2)
(7635,2592,2)
(7765,6985,2)
(113,8815,2)
(4628,3936,2)
(1114,822,2)
(8160,4273,2)
(920,1954,2)
(8727,1234,2)
(8130,3431,2)
(5583,8391,2)
(9112,2831,2)
(6223,2344,2)
(3340,4070,2)
(2473,5069,2)
(6414,4820,2)
(746,7405,2)
(4388,726,2)
(2369,8493,2)
(6290,7628,2)
(1077,7870,2)
(8843,8756,2)
(4300,8065,2)
(2567,115,2)
(5342,6155,2)
(4865,377,2)
(4820,592,2)
(2866,8936,2)
(8346,5408,2)
(4512,4253,2)
(8038,1158,2)
(4097,46,2)
(7393,3812,2)
(7033,2446,2)
(6328,2866,2)
(5961,5501,2)
(578,2845,2)
(2716,7760,2)
(5736,6971,2)
(5545,2047,2)
(5957,19,2)
(3373,4915,2)
(626,5752,2)
(1415,7524,2)
(7626,7039,2)
(8606,2587,2)
(7914,4916,2)
(6703,1705,2)
(5214,3215,2)
(340,7614,2)
(8028,6662,2)
(9114,1785,2)
(8233,3427,2)
(5464,226,2)
(4388,3992,2)
(7841,859,2)
(8796,5752,2)
(3675,7514,2)
(3261,3823,2)
(5214,3565,2)
(9029,7354,2)
(7071,5949,2)
(1601,8391,2)
(6263,2344,2)
(1256,1235,2)
(2455,5501,2)
(2938,5752,2)
(7917,3752,2)
(6021,8763,2)
(8512,2596,2)
(6619,8756,2)
(3291,5033,2)
(860,8923,2)
(2930,4343,2)
(8465,123,2)
(750,5421,2)
(5133,3963,2)
(3631,4915,2)
(2909,115,2)
(1296,7940,2)
(2196,4435,2)
(3165,3895,2)
(1520,3142,2)
(5637,46,2)
(6416,403,2)
(3050,2375,2)
(3567,689,2)
(1954,7577,2)
(1826,7514,2)
(2631,3097,2)
(5768,2072,2)
(7363,838,2)
(8278,4698,2)
(8038,8021,2)
(70,2592,2)
(89,8746,2)
(6179,4698,2)
(5490,1361,2)
(3582,5836,2)
(3874,8500,2)
(6850,8756,2)
(1270,3362,2)
(4182,2043,2)
(3543,1760,2)
(1399,8923,2)
(6817,2053,2)
(8943,874,2)
(3296,6155,2)
(3897,4069,2)
(2073,4793,2)
(5701,92,2)
(7108,8391,2)
(8856,7917,2)
(1830,7066,2)
(6337,7271,2)
(2872,2210,2)
(5814,7514,2)
(2162,115,2)
(1552,3201,2)
(8049,3232,2)
(8887,6155,2)
(3002,2644,2)
(3999,3823,2)
(8322,4954,2)
(2688,8391,2)
(1264,8065,2)
(6502,4873,2)
(5822,7940,2)
(1931,115,2)
(4431,2465,2)
(6345,3810,2)
(8280,4376,2)
(8029,4842,2)
(4375,7140,2)
(8705,3142,2)
(1001,6200,2)
(9090,8391,2)
(8190,7863,2)
(5281,4388,2)
(4068,6956,2)
(4252,7458,2)
(2147,1974,2)
(1921,8856,2)
(9007,7210,2)
(6827,2845,2)
(2287,1158,2)
(2246,8756,2)
(1647,6858,2)
(1834,403,2)
(8776,916,2)
(7226,8580,2)
(4598,2445,2)
(4217,8928,2)
(881,7628,2)
(6832,1235,2)
(3638,7514,2)
(1904,4253,2)
(8622,3198,2)
(4283,559,2)
(1098,1583,2)
(9032,5089,2)
(6685,8233,2)
(1003,3123,2)
(6069,7079,2)
(6002,2354,2)
(5808,3895,2)
(8857,5196,2)
(8528,6548,2)
(4652,2030,2)
(7889,1235,2)
(4328,6385,2)
(7570,5645,2)
(2778,123,2)
(1347,1509,2)
(4087,8391,2)
(5014,3108,2)
(2596,3637,2)
(6698,7841,2)
(6534,3493,2)
(8478,2805,2)
(6741,2043,2)
(6807,711,2)
(2867,1488,2)
(541,8756,2)
(8854,3579,2)
(881,5228,2)
(2358,2537,2)
(7843,3488,2)
(8096,8889,2)
(8251,1210,2)
(1396,1062,2)
(3745,7760,2)
(6534,1138,2)
(2503,6155,2)
(4227,7760,2)
(361,8756,2)
(1291,2060,2)
(7670,115,2)
(1430,1653,2)
(3534,2845,2)
(562,115,2)
(1415,7499,2)
(8920,8695,2)
(3774,115,2)
(7714,6318,2)
(2103,5752,2)
(689,2537,2)
(6395,1657,2)
(8152,150,2)
(365,3363,2)
(1659,4985,2)
(1519,2831,2)
(1429,2020,2)
(697,2366,2)
(5564,453,2)
(6029,408,2)
(2198,7262,2)
(9029,115,2)
(409,8756,2)
(3006,1709,2)
(5227,8391,2)
(109,7940,2)
(4046,8107,2)
(8743,1832,2)
(2101,5586,2)
(409,5109,2)
(174,7271,2)
(1774,53,2)
(3667,2344,2)
(8766,403,2)
(2178,3769,2)
(1121,6064,2)
(5441,7940,2)
(451,1459,2)
(1907,8156,2)
(8539,7870,2)
(1601,115,2)
(2457,8391,2)
(6502,8038,2)
(1156,3823,2)
(6900,1916,2)
(86,8756,2)
(6442,8571,2)
(2544,1270,2)
(770,410,2)
(1833,8756,2)
(1938,7977,2)
(4189,8391,2)
(5855,46,2)
(489,2965,2)
(1701,3003,2)
(5,115,2)
(4375,3565,2)
(7642,410,2)
(2410,8391,2)
(0,1719,2)
(2565,506,2)
(6189,123,2)
(2553,348,2)
(7111,6548,2)
(5638,1270,2)
(8135,7514,2)
(6971,1235,2)
(8121,4617,2)
(2241,5595,2)
(2248,904,2)
(3876,115,2)
(8339,2835,2)
(7626,8111,2)
(7595,8391,2)
(5295,3363,2)
(4320,410,2)
(1589,1311,2)
(4219,257,2)
(4733,2041,2)
(5870,8031,2)
(4714,874,2)
(1525,1311,2)
(7855,6285,2)
(7578,8391,2)
(4375,9130,2)
(2350,2834,2)
(7677,1705,2)
(524,2348,2)
(1555,115,2)
(2005,5204,2)
(1544,7628,2)
(4771,2036,2)
(4363,8756,2)
(3745,6858,2)
(6064,6575,2)
(7311,3963,2)
(5836,3445,2)
(1733,3781,2)
(4498,1560,2)
(1181,5251,2)
(4742,3292,2)
(5417,2771,2)
(6692,3097,2)
(7351,7628,2)
(6888,8391,2)
(8038,1280,2)
(6958,904,2)
(7614,1311,2)
(4889,4641,2)
(665,8624,2)
(2080,8832,2)
(2282,7977,2)
(5099,2587,2)
(9036,7210,2)
(6847,3440,2)
(8176,4095,2)
(1311,2831,2)
(4546,4899,2)
(1176,4153,2)
(5333,8756,2)
(2104,5526,2)
(3804,9138,2)
(7799,2644,2)
(6106,3781,2)
(4725,7306,2)
(250,8756,2)
(8790,8670,2)
(7213,8432,2)
(7997,8923,2)
(4872,8085,2)
(5894,3123,2)
(520,7765,2)
(7910,2845,2)
(6957,1512,2)
(379,777,2)
(5967,7453,2)
(1503,2445,2)
(335,3427,2)
(6374,8728,2)
(23,6285,2)
(4708,1235,2)
(1725,8182,2)
(8567,5881,2)
(3938,8131,2)
(1586,8538,2)
(2746,7182,2)
(644,8391,2)
(1380,4641,2)
(4123,4604,2)
(4549,7514,2)
(5652,7760,2)
(5264,3891,2)
(2662,1235,2)
(7099,1972,2)
(7263,2212,2)
(6660,786,2)
(5965,7353,2)
(3284,6063,2)
(3878,1809,2)
(7246,4624,2)
(7015,6155,2)
(8035,4876,2)
(2413,6070,2)
(1943,3095,2)
(7871,8391,2)
(6975,403,2)
(2857,6155,2)
(3577,895,2)
(6602,1235,2)
(466,2934,2)
(5126,352,2)
(8777,8254,2)
(6055,4859,2)
(5214,7039,2)
(2544,8111,2)
(3790,739,2)
(8022,2187,2)
(5638,7039,2)
(415,408,2)
(4309,1632,2)
(6310,2410,2)
(7535,1168,2)
(6434,1259,2)
(3020,2212,2)
(1857,5156,2)
(5545,7614,2)
(3454,3123,2)
(4945,7754,2)
(3469,904,2)
(4121,7851,2)
(1199,4641,2)
(4707,536,2)
(3158,6200,2)
(3468,6155,2)
(3023,5036,2)
(6880,9140,2)
(5780,150,2)
(4169,7200,2)
(3804,6435,2)
(4956,7271,2)
(2776,6030,2)
(1276,6689,2)
(4995,8065,2)
(7939,3142,2)
(4848,8232,2)
(8757,7939,2)
(3923,1905,2)
(902,115,2)
(205,5608,2)
(2811,4088,2)
(5326,8391,2)
(6520,5932,2)
(7757,1583,2)
(6723,6155,2)
(1222,4044,2)
(5665,6458,2)
(7785,909,2)
(6831,8107,2)
(4375,6471,2)
(900,7366,2)
(6756,4558,2)
(2965,7909,2)
(6608,2526,2)
(2105,2344,2)
(1248,3781,2)
(4460,8233,2)
(3153,4576,2)
(7408,2309,2)
(8088,115,2)
(267,4285,2)
(514,7570,2)
(7711,3335,2)
(1544,4366,2)
(2163,5540,2)
(2706,5371,2)
(8432,5577,2)
(775,115,2)
(4375,2861,2)
(7919,403,2)
(1827,874,2)
(2691,2866,2)
(5997,4757,2)
(2174,4162,2)
(5196,410,2)
(2677,8391,2)
(6039,3781,2)
(8478,1175,2)
(4311,7186,2)
(952,8391,2)
(1601,403,2)
(8048,7511,2)
(4329,3953,2)
(5747,6385,2)
(3598,8756,2)
(908,8851,2)
(8865,1234,2)
(6354,5836,2)
(4381,8391,2)
(4284,6995,2)
(8712,453,2)
(1325,8746,2)
(5927,2187,2)
(6191,8756,2)
(1751,7868,2)
(5225,2366,2)
(872,8756,2)
(6525,2187,2)
(7083,5958,2)
(3285,968,2)
(1915,4285,2)
(4622,7514,2)
(6270,8756,2)
(4080,1916,2)
(3902,1311,2)
(3738,1453,2)
(5776,5855,2)
(4150,2176,2)
(1944,2804,2)
(4564,7660,2)
(7548,2775,2)
(4721,559,2)
(298,7760,2)
(3879,415,2)
(1881,8978,2)
(1470,46,2)
(8543,6971,2)
(3113,1254,2)
(4404,8756,2)
(3862,2654,2)
(3393,1002,2)
(6019,7791,2)
(6842,6424,2)
(7001,6815,2)
(7989,3769,2)
(1591,7716,2)
(7122,292,2)
(4451,8065,2)
(3368,768,2)
(5143,7262,2)
(8985,4253,2)
(1071,3814,2)
(3865,5961,2)
(5238,6155,2)
(93,1063,2)
(8156,4793,2)
(5306,3320,2)
(1369,5156,2)
(4050,5712,2)
(6630,6677,2)
(8703,8756,2)
(4801,228,2)
(1756,904,2)
(7405,6081,2)
(4018,3819,2)
(5287,228,2)
(1111,408,2)
(5589,6155,2)
(1086,6907,2)
(1875,6198,2)
(3335,4579,2)
(3911,46,2)
(5399,8756,2)
(3236,4697,2)
(114,6804,2)
(6097,8493,2)
(5612,1682,2)
(5828,1478,2)
(5782,8252,2)
(3589,150,2)
(2509,3123,2)
(8336,3814,2)
(6221,7760,2)
(2873,8391,2)
(882,1544,2)
(4995,8113,2)
(8335,2537,2)
(4626,1653,2)
(3280,5069,2)
(1792,8391,2)
(8654,8975,2)
(3681,6132,2)
(8139,115,2)
(592,115,2)
(2229,1311,2)
(8849,8391,2)
(6252,1682,2)
(283,5540,2)
(4423,131,2)
(8261,9140,2)
(4934,6208,2)
(216,8107,2)
(6272,8756,2)
(3902,3742,2)
(177,7004,2)
(4695,1724,2)
(2324,2983,2)
(7155,2983,2)
(6738,2199,2)
(8153,7828,2)
(633,1466,2)
(9010,2845,2)
(5798,4697,2)
(7850,1002,2)
(2516,6677,2)
(1193,46,2)
(6502,2544,2)
(6041,8756,2)
(7292,3701,2)
(5467,1685,2)
(1086,1149,2)
(3352,6155,2)
(1029,7711,2)
(644,7262,2)
(5683,7852,2)
(6975,3583,2)
(1931,8391,2)
(4320,7400,2)
(8043,2983,2)
(5166,6155,2)
(576,2765,2)
(8396,5586,2)
(6000,115,2)
(2626,2771,2)
(2721,1220,2)
(514,2845,2)
(4136,874,2)
(853,5939,2)
(3897,1861,2)
(1383,5162,2)
(3151,7167,2)
(5744,28,2)
(7637,3782,2)
(801,7796,2)
(6696,904,2)
(4942,115,2)
(4890,1235,2)
(6679,8756,2)
(2818,115,2)
(5107,8391,2)
(5838,7762,2)
(3334,8728,2)
(7527,8940,2)
(794,874,2)
(475,706,2)
(7364,7150,2)
(4313,410,2)
(8685,7493,2)
(4579,904,2)
(8444,891,2)
(8720,2191,2)
(17,408,2)
(6840,8670,2)
(3804,1158,2)
(2287,6474,2)
(1219,8756,2)
(459,904,2)
(3004,258,2)
(6030,5712,2)
(4224,2445,2)
(1855,8756,2)
(7035,2679,2)
(9011,1954,2)
(3494,4289,2)
(800,8832,2)
(5809,6649,2)
(504,1254,2)
(5280,270,2)
(6080,2845,2)
(5494,3889,2)
(7132,8580,2)
(4026,8391,2)
(6694,8107,2)
(6426,1022,2)
(6545,2912,2)
(5193,8391,2)
(8802,8756,2)
(3841,8756,2)
(2740,8481,2)
(3788,5454,2)
(2870,2191,2)
(1265,8581,2)
(3665,7665,2)
(1250,1149,2)
(2186,1235,2)
(5939,4236,2)
(3642,3706,2)
(110,8432,2)
(7812,9059,2)
(7180,2168,2)
(4625,8391,2)
(5970,6267,2)
(4578,7760,2)
(7628,7667,2)
(6986,1311,2)
(6812,5204,2)
(995,5893,2)
(5098,4793,2)
(8313,4388,2)
(8494,8751,2)
(6700,8391,2)
(7447,8523,2)
(5074,2187,2)
(7562,3963,2)
(993,6179,2)
(2851,8756,2)
(4199,4698,2)
(2046,3527,2)
(8781,7628,2)
(4615,2283,2)
(5843,1254,2)
(519,2459,2)
(4375,4449,2)
(538,5575,2)
(470,2187,2)
(2933,874,2)
(7396,5086,2)
(3224,92,2)
(2364,6385,2)
(4809,7353,2)
(3213,8021,2)
(2714,3810,2)
(9137,2835,2)
(7926,6907,2)
(5214,4587,2)
(2736,5712,2)
(5117,115,2)
(5115,7760,2)
(966,2862,2)
(8595,7821,2)
(5443,5162,2)
(7953,3823,2)
(2037,6154,2)
(1851,6662,2)
(5297,3969,2)
(4902,4697,2)
(7883,115,2)
(7734,6155,2)
(2418,4236,2)
(4175,1509,2)
(8822,6479,2)
(6215,7353,2)
(4382,6072,2)
(3798,6046,2)
(4331,2335,2)
(5809,7353,2)
(7124,2983,2)
(6554,5507,2)
(1983,6662,2)
(6603,115,2)
(2896,2191,2)
(1543,4388,2)
(7259,6132,2)
(437,3222,2)
(6361,8756,2)
(1099,1240,2)
(4043,6548,2)
(759,3320,2)
(3777,352,2)
(4506,7841,2)
(1848,8391,2)
(119,115,2)
(6156,8849,2)
(1281,4088,2)
(5851,2645,2)
(6061,6285,2)
(7248,988,2)
(1137,7514,2)
(4698,7977,2)
(1813,131,2)
(8998,7940,2)
(3597,1438,2)
(6360,8756,2)
(1956,8756,2)
(4505,8427,2)
(7381,1653,2)
(8908,6111,2)
(964,7977,2)
(3065,46,2)
(193,7514,2)
(4796,2537,2)
(3789,8756,2)
(8832,7103,2)
(3699,115,2)
(4435,6385,2)
(4620,8286,2)
(1416,3427,2)
(9025,453,2)
(987,3934,2)
(3846,1785,2)
(6253,5752,2)
(8817,3363,2)
(6451,115,2)
(9130,4326,2)
(8433,6067,2)
(7097,2695,2)
(8502,8889,2)
(660,3823,2)
(1414,846,2)
(299,8928,2)
(2840,3965,2)
(8488,6053,2)
(856,3814,2)
(3480,8139,2)
(4242,2537,2)
(6516,292,2)
(3423,7262,2)
(407,6289,2)
(1927,7828,2)
(1415,4149,2)
(4380,4624,2)
(2388,1311,2)
(2543,8111,2)
(4375,6563,2)
(1850,6527,2)
(339,8391,2)
(2782,8391,2)
(6546,575,2)
(183,3530,2)
(8237,115,2)
(8458,4326,2)
(4392,798,2)
(5342,8391,2)
(4485,4253,2)
(622,7569,2)
(8726,4793,2)
(5195,6155,2)
(6655,5586,2)
(8365,325,2)
(6556,8756,2)
(5806,6285,2)
(2339,3142,2)
(2223,6155,2)
(7982,115,2)
(2838,7762,2)
(8717,3363,2)
(8212,8756,2)
(2291,3527,2)
(6258,4326,2)
(8095,7353,2)
(1872,3218,2)
(5129,2869,2)
(6910,228,2)
(6438,4326,2)
(14,7840,2)
(7867,2592,2)
(4611,6804,2)
(4222,8431,2)
(1955,8756,2)
(6419,3215,2)
(2692,7841,2)
(6049,4252,2)
(5076,3862,2)
(5453,7628,2)
(524,6155,2)
(5149,7821,2)
(3017,904,2)
(6364,9125,2)
(8538,846,2)
(8237,3891,2)
(299,5156,2)
(6062,7001,2)
(8142,7779,2)
(3156,2537,2)
(2041,8680,2)
(6288,115,2)
(6893,3142,2)
(3418,6971,2)
(6156,3218,2)
(6240,1002,2)
(3361,1954,2)
(706,6575,2)
(8911,4236,2)
(5387,1785,2)
(562,8391,2)
(6486,6417,2)
(8806,115,2)
(1256,7514,2)
(4012,115,2)
(774,8391,2)
(1952,2147,2)
(6419,8111,2)
(1780,8648,2)
(7516,6155,2)
(2267,408,2)
(6411,2260,2)
(5084,6600,2)
(1338,1724,2)
(170,228,2)
(2669,8756,2)
(3375,8009,2)
(6098,4362,2)
(7656,8391,2)
(8789,7271,2)
(7626,700,2)
(1310,1705,2)
(5141,408,2)
(8356,8845,2)
(5054,6385,2)
(3017,3198,2)
(1800,4726,2)
(4870,8756,2)
(6429,8391,2)
(7648,7405,2)
(6124,4984,2)
(5058,6002,2)
(4675,2482,2)
(78,8756,2)
(1085,904,2)
(4386,7940,2)
(7349,115,2)
(7586,5712,2)
(824,115,2)
(5954,1923,2)
(8677,405,2)
(7974,7569,2)
(2035,7718,2)
(4617,2053,2)
(158,8391,2)
(3149,8391,2)
(3223,1303,2)
(7647,352,2)
(8637,4253,2)
(4746,1357,2)
(4680,2482,2)
(6187,3830,2)
(897,8391,2)
(3876,8391,2)
(7469,8756,2)
(5330,1240,2)
(189,7057,2)
(1286,1857,2)
(6284,2112,2)
(2732,1785,2)
(3959,2199,2)
(6881,5156,2)
(5251,6132,2)
(854,8481,2)
(2287,7280,2)
(1454,3312,2)
(5033,4624,2)
(1752,3942,2)
(2952,4583,2)
(7416,7514,2)
(9012,7150,2)
(5995,9096,2)
(2566,904,2)
(1480,1891,2)
(3240,6577,2)
(7349,7155,2)
(542,3814,2)
(4650,9059,2)
(279,3758,2)
(3703,5483,2)
(8767,7765,2)
(5601,1396,2)
(7476,1785,2)
(8354,1220,2)
(3307,2210,2)
(5861,6834,2)
(190,8857,2)
(3532,2644,2)
(7185,3363,2)
(3211,2771,2)
(4149,8391,2)
(3480,2465,2)
(4537,5454,2)
(5890,7628,2)
(7462,115,2)
(125,4679,2)
(6611,8391,2)
(1893,3810,2)
(2088,3097,2)
(3838,3198,2)
(6356,1782,2)
(3207,5958,2)
(548,2344,2)
(6561,6132,2)
(8541,8756,2)
(5732,2964,2)
(2654,4976,2)
(7294,4477,2)
(6824,2618,2)
(8414,1458,2)
(4781,4876,2)
(6657,2644,2)
(7066,1891,2)
(4524,8391,2)
(8092,4916,2)
(1653,3295,2)
(6630,3679,2)
(3215,3752,2)
(4348,6070,2)
(18,4974,2)
(6782,3397,2)
(6786,1306,2)
(3067,8391,2)
(4965,2972,2)
(8209,507,2)
(6658,2283,2)
(8281,8457,2)
(509,4679,2)
(4294,798,2)
(6487,3541,2)
(8617,7514,2)
(8604,5076,2)
(1593,5958,2)
(7431,4289,2)
(2704,1479,2)
(350,403,2)
(8369,4915,2)
(85,6663,2)
(2959,4258,2)
(254,8756,2)
(8414,9004,2)
(8794,7013,2)
(5752,8756,2)
(7444,5156,2)
(7373,115,2)
(4028,1488,2)
(1396,5543,2)
(8426,2553,2)
(4924,8656,2)
(4568,2335,2)
(7228,403,2)
(8271,3363,2)
(5124,6155,2)
(9136,8756,2)
(7759,8391,2)
(8351,916,2)
(7008,8756,2)
(4637,4915,2)
(370,46,2)
(5155,7614,2)
(4265,6548,2)
(7913,1235,2)
(3213,4587,2)
(2657,3823,2)
(7251,8391,2)
(8561,3295,2)
(2757,413,2)
(1415,8594,2)
(7810,115,2)
(5577,115,2)
(6775,1954,2)
(6292,7409,2)
(2094,5204,2)
(2093,3574,2)
(7639,1705,2)
(8992,8756,2)
(4295,3552,2)
(6659,2036,2)
(2934,3934,2)
(677,1370,2)
(2099,2309,2)
(2919,8909,2)
(3510,2512,2)
(5077,528,2)
(8666,874,2)
(19,4624,2)
(5367,2964,2)
(2983,8756,2)
(2695,1240,2)
(1431,8756,2)
(5552,689,2)
(8678,4945,2)
(2518,8626,2)
(8198,8751,2)
(3048,8756,2)
(416,8391,2)
(8335,5547,2)
(5348,4915,2)
(2923,7271,2)
(323,2592,2)
(4976,4915,2)
(3943,3965,2)
(1619,7781,2)
(158,115,2)
(2632,7271,2)
(7230,3320,2)
(2299,8391,2)
(225,2537,2)
(2020,8143,2)
(5741,3781,2)
(1991,4774,2)
(349,5598,2)
(7724,726,2)
(7544,1104,2)
(2599,226,2)
(7126,1427,2)
(6767,2854,2)
(3620,403,2)
(3821,2057,2)
(7119,7353,2)
(4629,7642,2)
(1984,5712,2)
(3963,3108,2)
(1690,6053,2)
(5844,5369,2)
(5856,3128,2)
(4786,3417,2)
(2665,2623,2)
(855,7210,2)
(7697,7143,2)
(634,5501,2)
(3507,4876,2)
(8109,777,2)
(7858,7516,2)
(5934,6155,2)
(7262,8756,2)
(9001,4467,2)
(1038,2187,2)
(8560,4378,2)
(8819,4697,2)
(3456,1459,2)
(2518,4920,2)
(3427,92,2)
(2287,3657,2)
(4879,1306,2)
(7916,3696,2)
(6378,8391,2)
(6789,1235,2)
(1776,4793,2)
(8723,8391,2)
(5242,2771,2)
(1220,1013,2)
(2991,7143,2)
(5526,3696,2)
(1265,6842,2)
(3286,3142,2)
(1461,3823,2)
(7198,8391,2)
(8230,2344,2)
(2314,8048,2)
(7943,4604,2)
(1475,7514,2)
(4619,5958,2)
(7708,2053,2)
(5602,3119,2)
(8749,7422,2)
(4795,5316,2)
(2457,115,2)
(3844,115,2)
(1857,4876,2)
(3940,8391,2)
(5336,5712,2)
(2404,8746,2)
(4915,4326,2)
(830,3312,2)
(8058,3095,2)
(3274,8794,2)
(7578,5454,2)
(5107,115,2)
(7828,1479,2)
(7764,8391,2)
(8744,7760,2)
(1580,8756,2)
(1963,8670,2)
(7405,4586,2)
(6000,8391,2)
(1530,944,2)
(8172,1254,2)
(2878,3814,2)
(3116,12,2)
(1138,1488,2)
(1123,3530,2)
(670,8691,2)
(5963,3427,2)
(4979,6200,2)
(1415,8441,2)
(6530,3415,2)
(6855,8510,2)
(7792,403,2)
(1415,866,2)
(1479,2565,2)
(8561,8391,2)
(5477,8391,2)
(220,5668,2)
(3773,4984,2)
(6167,6155,2)
(7573,6385,2)
(7621,6155,2)
(6508,6826,2)
(7664,7897,2)
(5865,2465,2)
(6932,2835,2)
(3539,8391,2)
(7787,228,2)
(6629,6646,2)
(1261,7514,2)
(7869,6114,2)
(798,8756,2)
(2161,4741,2)
(2287,7514,2)
(8033,5204,2)
(52,1311,2)
(7537,3812,2)
(7515,6613,2)
(5704,5184,2)
(4709,3825,2)
(2564,3488,2)
(4585,4253,2)
(6680,8538,2)
(8584,3198,2)
(2515,4236,2)
(3251,3346,2)
(6502,1415,2)
(4929,8751,2)
(4150,5501,2)
(6048,8695,2)
(6236,3781,2)
(1153,2498,2)
(4381,4124,2)
(4159,6196,2)
(3315,5204,2)
(2203,5829,2)
(7772,7262,2)
(5717,6155,2)
(86,208,2)
(5716,1254,2)
(1164,8756,2)
(4671,8523,2)
(3728,5586,2)
(7028,3812,2)
(4375,5452,2)
(1598,7940,2)
(7103,3814,2)
(4375,4149,2)
(8797,5454,2)
(7873,5752,2)
(1689,2375,2)
(2945,208,2)
(2544,8832,2)
(3901,4576,2)
(643,4326,2)
(2157,8431,2)
(8550,2502,2)
(3579,115,2)
(1126,6177,2)
(4388,7724,2)
(2613,8756,2)
(5485,3417,2)
(5567,3218,2)
(8295,2845,2)
(5355,8431,2)
(7256,8756,2)
(8755,7909,2)
(3078,8391,2)
(2579,8756,2)
(4228,6577,2)
(6062,3752,2)
(6765,3382,2)
(4791,5629,2)
(2659,4698,2)
(8621,6285,2)
(4910,4793,2)
(2793,3222,2)
(164,8756,2)
(6341,1509,2)
(4116,115,2)
(3009,2465,2)
(7176,7356,2)
(2674,595,2)
(8378,3126,2)
(7203,8719,2)
(8386,7760,2)
(2573,1240,2)
(7812,2309,2)
(1479,6417,2)
(6827,1954,2)
(1322,8756,2)
(995,2465,2)
(334,5475,2)
(7746,1240,2)
(1415,6478,2)
(3863,2445,2)
(5650,1657,2)
(1177,4153,2)
(3817,6580,2)
(5239,7735,2)
(6292,2964,2)
(506,3886,2)
(8083,1396,2)
(5342,115,2)
(1372,1648,2)
(7149,6314,2)
(4859,46,2)
(8061,4510,2)
(3886,2217,2)
(4226,4388,2)
(8321,5540,2)
(2032,706,2)
(3051,2411,2)
(8742,8391,2)
(4850,8756,2)
(5093,3123,2)
(6836,1385,2)
(92,1764,2)
(1296,2317,2)
(3507,7250,2)
(7890,5156,2)
(5768,3488,2)
(5282,6625,2)
(594,874,2)
(2973,8756,2)
(5168,8517,2)
(1921,6629,2)
(7058,408,2)
(6088,8391,2)
(8031,115,2)
(8034,5156,2)
(7290,7765,2)
(7574,6179,2)
(1392,4253,2)
(4553,616,2)
(8386,713,2)
(6928,3812,2)
(1667,8756,2)
(2135,6155,2)
(4509,7762,2)
(4497,8391,2)
(7633,4153,2)
(398,3963,2)
(2422,4921,2)
(4349,7760,2)
(8086,1463,2)
(1949,706,2)
(2231,8493,2)
(381,403,2)
(8368,1254,2)
(6192,3123,2)
(4732,4876,2)
(1847,5251,2)
(1344,408,2)
(4375,4350,2)
(8574,410,2)
(350,8507,2)
(6278,4522,2)
(7485,1967,2)
(5614,8431,2)
(8784,4679,2)
(4002,8391,2)
(8594,1149,2)
(8131,5290,2)
(1363,8391,2)
(3218,3487,2)
(8969,1221,2)
(8913,8391,2)
(1649,6385,2)
(4122,7514,2)
(5451,8391,2)
(4433,2056,2)
(7667,1785,2)
(4296,8756,2)
(5371,115,2)
(7681,4793,2)
(3507,292,2)
(5123,4974,2)
(8955,4698,2)
(2845,8749,2)
(1671,798,2)
(5494,2861,2)
(6522,2845,2)
(5753,4916,2)
(6541,3108,2)
(2390,8493,2)
(6905,8523,2)
(5712,7552,2)
(1415,5375,2)
(3254,115,2)
(7302,91,2)
(4289,7180,2)
(3538,1707,2)
(2014,8756,2)
(2644,6241,2)
(945,408,2)
(4119,5027,2)
(7581,2983,2)
(3813,1235,2)
(963,7271,2)
(965,8628,2)
(8405,2818,2)
(6968,379,2)
(6187,5204,2)
(7555,46,2)
(5847,2058,2)
(3807,403,2)
(1616,7001,2)
(4088,4367,2)
(3827,9096,2)
(2560,6867,2)
(4540,1955,2)
(3381,5204,2)
(4595,4087,2)
(719,115,2)
(259,1653,2)
(5785,6288,2)
(4998,2187,2)
(338,904,2)
(3186,8756,2)
(2594,8065,2)
(543,553,2)
(5404,904,2)
(1555,2845,2)
(5449,7977,2)
(5619,2007,2)
(1369,5467,2)
(8379,79,2)
(7705,3417,2)
(1816,5204,2)
(2128,6479,2)
(499,9133,2)
(1611,3320,2)
(5851,3811,2)
(2868,7210,2)
(4179,4579,2)
(2929,2283,2)
(7978,2592,2)
(8068,9128,2)
(2551,6899,2)
(5498,4583,2)
(1509,1770,2)
(3904,747,2)
(2501,1780,2)
(1361,3934,2)
(8059,5712,2)
(5638,2065,2)
(661,4043,2)
(2841,726,2)
(1137,1235,2)
(4393,7258,2)
(7805,7628,2)
(3586,8311,2)
(3046,1276,2)
(4375,1235,2)
(937,7909,2)
(3562,7765,2)
(219,115,2)
(8802,115,2)
(4507,4957,2)
(5501,3123,2)
(2229,2940,2)
(6265,6804,2)
(5852,514,2)
(7994,5712,2)
(6279,2308,2)
(1999,2537,2)
(3491,6529,2)
(5109,8756,2)
(1277,6155,2)
(3305,1586,2)
(8957,2854,2)
(4545,5251,2)
(8860,403,2)
(2739,1657,2)
(6811,8751,2)
(1693,4974,2)
(2240,6155,2)
(2940,1311,2)
(4636,46,2)
(2891,1459,2)
(7390,9096,2)
(747,3050,2)
(6598,3101,2)
(5441,1296,2)
(1610,5752,2)
(1948,8756,2)
(4711,8391,2)
(7360,8756,2)
(2648,3488,2)
(7527,7762,2)
(7510,8756,2)
(406,228,2)
(8480,7590,2)
(7058,8540,2)
(2529,874,2)
(2752,2900,2)
(8681,8691,2)
(3576,6070,2)
(4358,4579,2)
(4153,8488,2)
(304,706,2)
(2354,5408,2)
(588,5077,2)
(3507,5156,2)
(4081,8756,2)
(7375,7041,2)
(8895,46,2)
(6664,2690,2)
(5883,2212,2)
(5616,3095,2)
(267,1158,2)
(3593,8254,2)
(8418,7203,2)
(4618,1987,2)
(4803,2277,2)
(83,7077,2)
(2534,115,2)
(2963,2191,2)
(5189,5283,2)
(1105,1779,2)
(6495,7647,2)
(8580,7353,2)
(1415,6710,2)
(6434,5204,2)
(7096,6132,2)
(4992,8695,2)
(2200,3823,2)
(3619,1488,2)
(1900,6664,2)
(3051,8923,2)
(8039,5586,2)
(2608,3214,2)
(2415,8432,2)
(579,2845,2)
(4653,3295,2)
(5682,4467,2)
(3509,4515,2)
(6397,8391,2)
(3722,4840,2)
(921,115,2)
(3358,1479,2)
(2945,3612,2)
(402,453,2)
(5188,2559,2)
(2386,5829,2)
(2067,8756,2)
(3087,1664,2)
(8296,3621,2)
(2182,3095,2)
(6067,115,2)
(5656,1833,2)
(693,4679,2)
(2712,1583,2)
(6002,5408,2)
(3897,4793,2)
(1405,8391,2)
(6364,8628,2)
(7501,8728,2)
(8614,2771,2)
(1187,5777,2)
(3447,8756,2)
(486,3427,2)
(1368,7765,2)
(7977,4383,2)
(2350,3621,2)
(7262,4299,2)
(7019,1076,2)
(5858,3198,2)
(8158,7413,2)
(2789,799,2)
(1890,3363,2)
(1415,6563,2)
(6019,3095,2)
(5474,1974,2)
(829,4310,2)
(7525,8391,2)
(4087,115,2)
(8596,6385,2)
(6968,1852,2)
(4319,4698,2)
(3983,8431,2)
(3621,2765,2)
(1755,8391,2)
(6389,6907,2)
(1832,8391,2)
(747,2375,2)
(3581,292,2)
(9140,9140,2)
(5487,3863,2)
(2491,6613,2)
(4974,4627,2)
(8296,3875,2)
(8582,8391,2)
(931,2187,2)
(2454,9103,2)
(8939,1572,2)
(6945,4253,2)
(1780,8751,2)
(701,5204,2)
(8736,1583,2)
(5712,1070,2)
(5214,8471,2)
(5725,8107,2)
(8206,3198,2)
(366,270,2)
(4008,4408,2)
(60,408,2)
(1568,5869,2)
(5638,5698,2)
(4560,8960,2)
(443,7119,2)
(8148,8391,2)
(4185,257,2)
(283,4897,2)
(384,1888,2)
(5329,1682,2)
(6746,1493,2)
(8625,8756,2)
(7933,2983,2)
(6053,7760,2)
(3706,1830,2)
(155,7711,2)
(6100,5777,2)
(8349,3286,2)
(1121,836,2)
(5972,6662,2)
(7127,904,2)
(7141,8756,2)
(4366,7628,2)
(2414,904,2)
(203,8756,2)
(5874,115,2)
(5479,4974,2)
(8130,2866,2)
(1027,8670,2)
(4912,7765,2)
(8616,2845,2)
(5036,6385,2)
(7187,5484,2)
(2544,8021,2)
(1078,5712,2)
(7689,5226,2)
(8363,5752,2)
(6609,1785,2)
(118,4284,2)
(2544,8458,2)
(1644,7771,2)
(8858,6971,2)
(3770,5629,2)
(5468,7909,2)
(5089,3258,2)
(7186,5898,2)
(9091,7762,2)
(7838,8712,2)
(7232,2754,2)
(522,8889,2)
(288,3823,2)
(4514,1954,2)
(2287,1405,2)
(7474,1954,2)
(3767,2479,2)
(7415,4253,2)
(1783,3817,2)
(997,408,2)
(7966,700,2)
(2897,1972,2)
(7797,7104,2)
(4915,9128,2)
(4244,4579,2)
(4034,8391,2)
(3173,7553,2)
(7966,9130,2)
(5112,4388,2)
(1954,6575,2)
(4157,115,2)
(19,4565,2)
(3330,2335,2)
(2794,8756,2)
(2254,1254,2)
(2909,123,2)
(8916,3895,2)
(7628,1785,2)
(3571,8391,2)
(9089,6008,2)
(7444,4876,2)
(8162,1657,2)
(2981,3752,2)
(2760,874,2)
(6151,5317,2)
(6144,7760,2)
(4873,3565,2)
(1782,6858,2)
(2423,8107,2)
(3859,3020,2)
(2466,4499,2)
(7323,1656,2)
(6810,6155,2)
(3213,4149,2)
(3836,1685,2)
(5494,8111,2)
(4472,7835,2)
(8360,7262,2)
(7322,6155,2)
(2239,8391,2)
(5452,8391,2)
(7583,8756,2)
(6182,8148,2)
(4781,5197,2)
(4538,3142,2)
(727,115,2)
(2753,4285,2)
(7150,300,2)
(3363,7293,2)
(4025,4679,2)
(5565,4579,2)
(7196,3451,2)
(8241,2644,2)
(3380,6804,2)
(9121,4698,2)
(1547,228,2)
(5530,3198,2)
(1237,4408,2)
(8210,1459,2)
(4222,1447,2)
(2656,4567,2)
(553,6971,2)
(7030,2487,2)
(5735,6132,2)
(3061,2835,2)
(3250,8391,2)
(3621,700,2)
(6467,8856,2)
(2642,1493,2)
(5989,7909,2)
(2447,4253,2)
(847,7498,2)
(5001,8712,2)
(6022,7711,2)
(45,6613,2)
(3455,7841,2)
(7612,8756,2)
(8103,7405,2)
(6419,7039,2)
(8687,7598,2)
(8027,92,2)
(3582,1149,2)
(9070,8131,2)
(3640,4431,2)
(7261,8756,2)
(8461,1149,2)
(6016,2771,2)
(6913,2866,2)
(7177,5712,2)
(5105,1648,2)
(7331,53,2)
(7249,8065,2)
(5462,9140,2)
(1254,6896,2)
(8162,8446,2)
(8702,5243,2)
(3962,6577,2)
(3707,9128,2)
(7912,3752,2)
(4186,4100,2)
(4571,3192,2)
(8831,7940,2)
(2906,2199,2)
(7080,4965,2)
(3140,7413,2)
(59,6548,2)
(394,462,2)
(3160,5251,2)
(2181,8756,2)
(2720,8391,2)
(8379,5156,2)
(4842,8189,2)
(8390,6791,2)
(3014,2036,2)
(4478,46,2)
(1677,6804,2)
(4639,4709,2)
(2159,2191,2)
(6494,1656,2)
(207,1607,2)
(6596,4916,2)
(2374,8746,2)
(5900,3480,2)
(5104,8065,2)
(3690,2845,2)
(5446,5605,2)
(7147,5752,2)
(8646,1760,2)
(3640,2465,2)
(8232,5958,2)
(76,2537,2)
(6420,7760,2)
(6784,4270,2)
(5414,115,2)
(7247,8889,2)
(985,8746,2)
(6703,3814,2)
(2007,2036,2)
(6425,2339,2)
(2052,1682,2)
(6323,6285,2)
(1817,6662,2)
(8245,5688,2)
(1210,8391,2)
(4939,8523,2)
(3394,8756,2)
(8141,2995,2)
(2538,2479,2)
(74,6613,2)
(5024,4236,2)
(2459,8339,2)
(3384,1488,2)
(5998,115,2)
(1727,7940,2)
(2206,1526,2)
(2907,2983,2)
(3068,3812,2)
(5130,3814,2)
(2500,8756,2)
(8418,2224,2)
(1474,6649,2)
(1542,5540,2)
(8719,115,2)
(1666,5686,2)
(8940,7762,2)
(1958,7066,2)
(6772,1454,2)
(7599,6155,2)
(6015,4326,2)
(1891,2211,2)
(6266,1782,2)
(8302,6971,2)
(7619,408,2)
(503,2191,2)
(5548,4916,2)
(4375,2681,2)
(2918,2253,2)
(4079,161,2)
(3726,3320,2)
(3285,5156,2)
(512,2191,2)
(7728,7514,2)
(4375,4524,2)
(1911,1054,2)
(7780,211,2)
(7103,856,2)
(8151,5123,2)
(2772,8793,2)
(8094,4124,2)
(9001,7973,2)
(6087,4733,2)
(7062,3218,2)
(3509,3889,2)
(655,6155,2)
(7192,5755,2)
(1247,562,2)
(7434,1760,2)
(425,1463,2)
(4896,6155,2)
(7271,92,2)
(883,3260,2)
(7983,1647,2)
(1345,8756,2)
(1111,8391,2)
(2345,536,2)
(8358,6155,2)
(9015,8756,2)
(3449,3198,2)
(4594,8558,2)
(5017,2835,2)
(5073,8756,2)
(3840,6613,2)
(6196,6719,2)
(6808,7857,2)
(3628,6155,2)
(1262,12,2)
(1433,6155,2)
(306,7909,2)
(3541,8756,2)
(5757,5104,2)
(4040,798,2)
(952,3451,2)
(3802,403,2)
(6231,3488,2)
(6027,6155,2)
(3427,3224,2)
(396,1575,2)
(718,6156,2)
(3122,228,2)
(3376,8065,2)
(2031,7001,2)
(171,202,2)
(437,115,2)
(2375,257,2)
(8902,8756,2)
(3951,5069,2)
(2287,8021,2)
(8632,4679,2)
(7175,4916,2)
(8251,3781,2)
(4749,8391,2)
(5056,3095,2)
(8977,5597,2)
(4676,6155,2)
(6969,2210,2)
(7798,5840,2)
(8648,8751,2)
(1584,8756,2)
(231,7354,2)
(122,4698,2)
(441,408,2)
(1725,5040,2)
(8571,1254,2)
(3918,3823,2)
(5688,5829,2)
(108,5162,2)
(8017,4388,2)
(7636,8493,2)
(573,159,2)
(1328,7821,2)
(3105,1220,2)
(3086,1874,2)
(1535,2789,2)
(4129,8493,2)
(5692,8756,2)
(8909,8391,2)
(6859,7765,2)
(3505,7652,2)
(1453,6155,2)
(7754,4974,2)
(4864,8391,2)
(4831,8623,2)
(6023,408,2)
(4837,6292,2)
(5126,7548,2)
(5554,9063,2)
(8447,3934,2)
(5527,2191,2)
(8819,7433,2)
(3051,860,2)
(2518,1785,2)
(4631,2537,2)
(1916,3150,2)
(4029,115,2)
(20,6155,2)
(2306,46,2)
(163,4876,2)
(5096,5752,2)
(7097,2896,2)
(8136,8391,2)
(161,115,2)
(270,7672,2)
(2316,2,2)
(1591,3046,2)
(2777,6577,2)
(1366,1785,2)
(6188,7218,2)
(6284,4974,2)
(75,408,2)
(3857,3231,2)
(1239,3553,2)
(7962,2043,2)
(2512,4445,2)
(7283,8391,2)
(1217,3782,2)
(3722,2765,2)
(6284,3565,2)
(1415,7280,2)
(5629,2203,2)
(1076,4697,2)
(3273,2445,2)
(170,115,2)
(5256,2043,2)
(5898,1488,2)
(5209,8391,2)
(1192,4679,2)
(1843,8391,2)
(6952,1247,2)
(4887,4326,2)
(2566,4079,2)
(2836,3076,2)
(4742,4876,2)
(8558,1748,2)
(8913,4974,2)
(5515,5847,2)
(8901,7561,2)
(5486,8923,2)
(1724,3198,2)
(2552,6804,2)
(8550,115,2)
(8754,8481,2)
(7293,8362,2)
(4085,5235,2)
(8118,6155,2)
(1472,410,2)
(7925,1311,2)
(2211,3814,2)
(8188,3752,2)
(3769,6804,2)
(6183,5408,2)
(2367,2756,2)
(722,1785,2)
(3690,115,2)
(4171,6804,2)
(4434,7889,2)
(2171,115,2)
(8373,2445,2)
(1575,4576,2)
(8189,4842,2)
(4023,9086,2)
(3869,4500,2)
(6186,7841,2)
(1136,5605,2)
(4321,7841,2)
(2346,403,2)
(921,2845,2)
(3843,3312,2)
(2873,115,2)
(2315,115,2)
(7812,3875,2)
(3690,8391,2)
(4634,7514,2)
(2814,8391,2)
(5728,6155,2)
(4873,1158,2)
(7283,115,2)
(8820,115,2)
(3141,2527,2)
(1263,9128,2)
(5845,6155,2)
(2544,3215,2)
(7630,8523,2)
(6592,5829,2)
(1754,3451,2)
(6551,3363,2)
(7080,7832,2)
(3940,5204,2)
(2430,1254,2)
(4105,2812,2)
(190,6911,2)
(2834,6314,2)
(1092,904,2)
(7048,8756,2)
(6513,8391,2)
(3213,1280,2)
(5168,3947,2)
(2942,6132,2)
(4739,403,2)
(3621,8111,2)
(8777,4424,2)
(3042,916,2)
(8074,3488,2)
(3430,4793,2)
(5851,4121,2)
(966,5156,2)
(4689,4966,2)
(1280,8391,2)
(4407,7765,2)
(5064,5204,2)
(667,2020,2)
(8129,8432,2)
(9035,2060,2)
(3982,4579,2)
(5684,1235,2)
(8601,4417,2)
(6126,8928,2)
(7431,3664,2)
(2287,8111,2)
(54,2835,2)
(4876,2596,2)
(671,2502,2)
(4287,2873,2)
(50,46,2)
(5823,7963,2)
(8981,7514,2)
(3298,1235,2)
(6179,4565,2)
(7014,5123,2)
(970,1509,2)
(3258,8756,2)
(1415,3747,2)
(5849,4253,2)
(6776,2020,2)
(3298,7514,2)
(1815,7940,2)
(8200,115,2)
(8651,2765,2)
(4375,6968,2)
(5217,3823,2)
(5134,1916,2)
(8297,8756,2)
(2373,1974,2)
(4125,2131,2)
(8079,7870,2)
(2414,3537,2)
(4190,1657,2)
(1427,3658,2)
(4822,6053,2)
(7296,408,2)
(1611,8029,2)
(6318,115,2)
(5494,4587,2)
(1941,2191,2)
(4452,952,2)
(3963,4919,2)
(5324,3312,2)
(4373,5605,2)
(9048,46,2)
(135,1240,2)
(3597,7940,2)
(1415,502,2)
(8832,1705,2)
(4747,7628,2)
(3712,4974,2)
(8038,8458,2)
(3980,7462,2)
(7723,408,2)
(6821,4610,2)
(8649,4174,2)
(7264,8391,2)
(1899,3965,2)
(1312,167,2)
(4771,3823,2)
(921,5712,2)
(8877,8901,2)
(305,8728,2)
(8248,2210,2)
(8337,1459,2)
(6964,2053,2)
(3772,4697,2)
(162,611,2)
(4818,2433,2)
(213,5162,2)
(3709,2366,2)
(5851,5491,2)
(4250,8065,2)
(5859,2537,2)
(6107,415,2)
(9068,3184,2)
(219,8391,2)
(1514,5668,2)
(8134,2281,2)
(7736,8756,2)
(8354,2721,2)
(3831,8786,2)
(7584,4925,2)
(3865,2303,2)
(1152,1254,2)
(2651,6577,2)
(8885,1657,2)
(6744,3230,2)
(794,4136,2)
(7820,8391,2)
(7325,7628,2)
(2912,1954,2)
(9038,8391,2)
(3819,115,2)
(6401,7760,2)
(4582,5003,2)
(409,4051,2)
(8252,1311,2)
(1205,5069,2)
(9082,2295,2)
(6821,2526,2)
(879,1972,2)
(8102,2191,2)
(7251,115,2)
(9095,7590,2)
(1578,8756,2)
(2333,5752,2)
(8869,1987,2)
(139,5204,2)
(4606,2667,2)
(5290,7859,2)
(5515,2058,2)
(172,1485,2)
(8224,8928,2)
(8666,2845,2)
(2828,459,2)
(3625,115,2)
(391,2983,2)
(4038,3203,2)
(2059,1916,2)
(5122,2983,2)
(2928,3201,2)
(7339,477,2)
(5596,8778,2)
(4236,7909,2)
(8891,4565,2)
(8826,8756,2)
(3149,115,2)
(1141,706,2)
(6063,5540,2)
(528,5501,2)
(6394,20,2)
(8599,6155,2)
(5128,8063,2)
(4394,7940,2)
(5069,1013,2)
(4847,8391,2)
(6751,5817,2)
(2720,115,2)
(4285,7001,2)
(7449,4253,2)
(4986,6155,2)
(2896,4146,2)
(7417,4289,2)
(1435,675,2)
(7342,2765,2)
(2453,6070,2)
(6146,1488,2)
(5971,5156,2)
(1859,7760,2)
(2874,1368,2)
(8334,7155,2)
(3294,4397,2)
(8578,5156,2)
(3660,8746,2)
(8178,339,2)
(243,6858,2)
(7294,3823,2)
(4236,306,2)
(6884,8391,2)
(6364,807,2)
(4835,2007,2)
(6502,5638,2)
(1724,7211,2)
(8296,3451,2)
(820,8756,2)
(4689,2283,2)
(104,202,2)
(3192,8889,2)
(4343,2964,2)
(1789,1888,2)
(4895,1785,2)
(3420,3812,2)
(3146,5069,2)
(7176,8756,2)
(4024,8756,2)
(5638,6649,2)
(676,5586,2)
(4591,7628,2)
(4586,7628,2)
(741,7079,2)
(4907,2866,2)
(2188,1311,2)
(8489,3095,2)
(8367,2537,2)
(7775,7760,2)
(7587,3218,2)
(4964,1235,2)
(1229,2537,2)
(2096,8756,2)
(2521,3969,2)
(8844,1013,2)
(784,5633,2)
(7072,46,2)
(2790,3965,2)
(8793,8580,2)
(5239,8194,2)
(6380,611,2)
(5851,5331,2)
(2741,4698,2)
(6579,1954,2)
(4029,8391,2)
(8393,904,2)
(8187,3541,2)
(4582,2835,2)
(2595,2835,2)
(1766,5123,2)
(8675,7841,2)
(1559,3496,2)
(6597,8884,2)
(1121,5362,2)
(3527,5777,2)
(2520,1724,2)
(7566,115,2)
(6317,2537,2)
(5831,2765,2)
(5483,1048,2)
(6317,2845,2)
(8133,8431,2)
(6336,4697,2)
(2976,9015,2)
(1415,8451,2)
(6173,9067,2)
(7716,115,2)
(1231,115,2)
(4792,4356,2)
(6763,2191,2)
(229,2835,2)
(4282,4182,2)
(5638,8458,2)
(823,6972,2)
(2422,7452,2)
(5066,4945,2)
(852,8756,2)
(6909,4697,2)
(8903,1782,2)
(2577,8756,2)
(1864,8756,2)
(5950,7972,2)
(4059,6155,2)
(4183,3376,2)
(2160,115,2)
(2421,3812,2)
(1475,1235,2)
(1441,611,2)
(8444,8391,2)
(7921,3201,2)
(8879,1238,2)
(7214,874,2)
(8186,8756,2)
(8797,4167,2)
(8362,6647,2)
(1314,6804,2)
(7640,7514,2)
(6209,8289,2)
(7170,2866,2)
(4593,7628,2)
(1324,9125,2)
(4378,115,2)
(6215,115,2)
(829,3095,2)
(1980,7628,2)
(3300,8391,2)
(4191,7262,2)
(8137,7940,2)
(9031,5204,2)
(1628,115,2)
(310,6858,2)
(8313,8391,2)
(8328,1888,2)
(1518,7271,2)
(8972,5752,2)
(5393,408,2)
(3804,4587,2)
(4068,3024,2)
(6426,2210,2)
(1150,2452,2)
(5374,5027,2)
(4189,115,2)
(3466,1488,2)
(1415,4350,2)
(8240,7760,2)
(7835,5881,2)
(2160,8756,2)
(6937,3812,2)
(3078,115,2)
(7626,9130,2)
(8199,2718,2)
(3602,1188,2)
(5877,6179,2)
(3834,4750,2)
(1400,115,2)
(4558,6314,2)
(4758,2537,2)
(6116,1657,2)
(6624,1657,2)
(1567,3451,2)
(1320,408,2)
(6548,2512,2)
(9005,4011,2)
(2720,3701,2)
(8361,3547,2)
(7726,403,2)
(7384,5752,2)
(1400,2995,2)
(6261,5958,2)
(3800,7665,2)
(5679,6155,2)
(2416,46,2)
(6241,6907,2)
(5544,7405,2)
(5641,408,2)
(4594,7760,2)
(4273,2366,2)
(6889,115,2)
(3148,1254,2)
(602,951,2)
(2001,3942,2)
(2754,5938,2)
(64,5752,2)
(3165,4746,2)
(573,9088,2)
(2913,226,2)
(3473,2172,2)
(6957,5454,2)
(1840,8273,2)
(6728,7570,2)
(3025,4916,2)
(580,3295,2)
(7110,4679,2)
(2620,1311,2)
(4352,7569,2)
(8657,7939,2)
(1505,3438,2)
(1996,7000,2)
(6419,1405,2)
(4967,8756,2)
(590,2191,2)
(4949,5117,2)
(4644,4619,2)
(6621,2835,2)
(6291,3295,2)
(121,2854,2)
(7686,1427,2)
(3566,1235,2)
(2300,3942,2)
(5228,5946,2)
(2803,8756,2)
(897,115,2)
(7757,8736,2)
(2885,5748,2)
(1560,2036,2)
(150,1648,2)
(512,8959,2)
(3632,82,2)
(6053,9047,2)
(6252,6711,2)
(3977,6155,2)
(7881,8481,2)
(1061,8391,2)
(6317,8391,2)
(5638,7280,2)
(1334,6155,2)
(7848,611,2)
(6337,8789,2)
(573,7159,2)
(4536,6577,2)
(4166,1234,2)
(2287,1280,2)
(4787,3758,2)
(4154,345,2)
(1559,7628,2)
(7570,1954,2)
(6127,4679,2)
(4285,4571,2)
(5101,8211,2)
(8481,8794,2)
(159,5752,2)
(8295,115,2)
(923,8538,2)
(1385,1509,2)
(8810,4697,2)
(5234,2835,2)
(5685,2344,2)
(4441,45,2)
(363,1954,2)
(1505,1830,2)
(6174,4618,2)
(1212,6907,2)
(4053,611,2)
(5825,8923,2)
(8941,7628,2)
(3915,1709,2)
(5109,8391,2)
(7036,1657,2)
(9111,1782,2)
(3730,8391,2)
(6951,8756,2)
(5439,8756,2)
(6554,5540,2)
(4510,1411,2)
(1055,7066,2)
(5021,1888,2)
(4571,5971,2)
(2751,8822,2)
(1614,8756,2)
(3621,7039,2)
(2682,7810,2)
(6499,3488,2)
(4574,7602,2)
(6997,4376,2)
(2242,2037,2)
(1128,5485,2)
(6627,115,2)
(7444,8793,2)
(8038,8471,2)
(5880,7656,2)
(1114,7691,2)
(7026,3814,2)
(4467,8035,2)
(8946,8493,2)
(9084,1463,2)
(3196,6155,2)
(5896,8756,2)
(2966,2866,2)
(4619,3522,2)
(2287,4449,2)
(2620,4126,2)
(909,8391,2)
(6794,8794,2)
(7200,574,2)
(5795,8391,2)
(7719,3095,2)
(4930,7852,2)
(8487,7575,2)
(7660,6132,2)
(7093,2983,2)
(7440,4606,2)
(5319,3963,2)
(1966,4044,2)
(6618,1311,2)
(871,4176,2)
(7113,2983,2)
(3971,3295,2)
(7393,6820,2)
(8817,4026,2)
(4016,8134,2)
(6557,408,2)
(6662,7765,2)
(4312,3095,2)
(6736,8819,2)
(8498,1916,2)
(5674,3312,2)
(7980,2309,2)
(3329,5586,2)
(921,6314,2)
(6403,8756,2)
(3680,5894,2)
(9128,611,2)
(8035,7973,2)
(8386,6858,2)
(3615,46,2)
(1158,4694,2)
(5494,700,2)
(3848,2854,2)
(7920,5605,2)
(6502,3213,2)
(6069,7577,2)
(1604,5712,2)
(6871,1709,2)
(5695,7628,2)
(1423,4974,2)
(1172,6479,2)
(8607,7628,2)
(371,8751,2)
(3524,4624,2)
(6550,2445,2)
(3570,7841,2)
(5214,1158,2)
(380,3752,2)
(6539,115,2)
(681,6662,2)
(5638,4350,2)
(2091,1370,2)
(5154,1467,2)
(2518,6517,2)
(7716,3895,2)
(5599,874,2)
(8084,2260,2)
(7138,6500,2)
(616,874,2)
(8825,1916,2)
(811,567,2)
(5247,2241,2)
(3003,213,2)
(329,5162,2)
(8749,6174,2)
(7337,2094,2)
(1873,904,2)
(6847,874,2)
(3724,5938,2)
(2284,3863,2)
(63,4679,2)
(1981,7628,2)
(2017,726,2)
(7143,8251,2)
(7400,7328,2)
(5114,6583,2)
(2045,5958,2)
(8174,8756,2)
(8635,46,2)
(8649,3752,2)
(1666,3142,2)
(7966,1158,2)
(5791,575,2)
(2975,3812,2)
(8102,4252,2)
(7222,115,2)
(8933,2254,2)
(4012,2845,2)
(6407,8781,2)
(3795,5204,2)
(7510,8391,2)
(4792,2625,2)
(6049,3333,2)
(3092,6385,2)
(7060,8107,2)
(1349,8391,2)
(8458,1676,2)
(980,8213,2)
(4453,5614,2)
(6910,3122,2)
(8213,874,2)
(3443,6791,2)
(2007,6659,2)
(5351,46,2)
(8994,1555,2)
(8166,1760,2)
(7987,1070,2)
(6085,4285,2)
(6657,1149,2)
(8656,7628,2)
(3467,916,2)
(314,1542,2)
(4375,3889,2)
(8540,408,2)
(2623,5586,2)
(4194,3823,2)
(1269,7762,2)
(79,7453,2)
(5359,8870,2)
(6064,5512,2)
(4924,1922,2)
(2043,2596,2)
(6627,3097,2)
(4223,2326,2)
(7084,6804,2)
(5774,4604,2)
(8105,115,2)
(8262,9128,2)
(5407,1173,2)
(8473,6155,2)
(5307,6971,2)
(2158,2020,2)
(4567,2191,2)
(289,2360,2)
(2049,7762,2)
(1039,7871,2)
(1695,8955,2)
(5744,6320,2)
(7458,7485,2)
(6177,1104,2)
(1595,2020,2)
(448,7353,2)
(8470,115,2)
(5458,3142,2)
(3737,706,2)
(5851,3865,2)
(652,7852,2)
(5372,1240,2)
(1633,1493,2)
(7608,3147,2)
(706,2512,2)
(2676,8756,2)
(5743,5752,2)
(4410,4876,2)
(1755,115,2)
(4343,4064,2)
(9003,2567,2)
(3967,7628,2)
(8127,3095,2)
(3804,7140,2)
(1400,8391,2)
(2160,8391,2)
(1848,115,2)
(5868,5829,2)
(8402,2771,2)
(7226,7353,2)
(2287,3215,2)
(9088,5752,2)
(8015,1954,2)
(3340,5251,2)
(8288,6598,2)
(904,5515,2)
(1964,408,2)
(1424,4408,2)
(6153,3218,2)
(5750,3232,2)
(8392,2835,2)
(5200,7143,2)
(5011,403,2)
(1052,5251,2)
(3171,2191,2)
(5096,1149,2)
(8367,799,2)
(6713,2344,2)
(8384,4435,2)
(1210,115,2)
(5696,1370,2)
(3436,2171,2)
(7656,1583,2)
(6590,7514,2)
(4,1709,2)
(8654,5358,2)
(7532,3451,2)
(5512,2866,2)
(7710,8391,2)
(6880,7316,2)
(5968,3078,2)
(4093,3521,2)
(2281,284,2)
(8043,6216,2)
(473,8391,2)
(7830,6932,2)
(7293,7262,2)
(155,2526,2)
(2677,7354,2)
(3734,8756,2)
(2056,5,2)
(3831,3096,2)
(5146,2445,2)
(4270,4876,2)
(1835,609,2)
(9087,559,2)
(5147,1899,2)
(4685,8493,2)
(3689,3123,2)
(8993,8756,2)
(4014,5454,2)
(237,356,2)
(5415,8065,2)
(5206,1583,2)
(3059,2644,2)
(25,115,2)
(1727,2845,2)
(1705,257,2)
(264,6016,2)
(1871,8751,2)
(4377,2537,2)
(9010,2537,2)
(4612,6053,2)
(767,2866,2)
(3120,3814,2)
(6534,3469,2)
(4630,4994,2)
(1065,115,2)
(6137,724,2)
(6718,3417,2)
(7679,53,2)
(9108,8432,2)
(6883,8065,2)
(4491,3427,2)
(4940,3810,2)
(2424,8391,2)
(8451,1905,2)
(3804,8021,2)
(2475,2845,2)
(6409,2983,2)
(672,2587,2)
(8505,9128,2)
(4241,6385,2)
(741,7746,2)
(875,6155,2)
(9004,8391,2)
(6783,1061,2)
(1986,8756,2)
(6929,1104,2)
(3645,5501,2)
(4395,2559,2)
(3648,92,2)
(811,46,2)
(2241,8756,2)
(6236,7143,2)
(5488,348,2)
(5394,8391,2)
(1975,4253,2)
(5518,92,2)
(3078,3906,2)
(1117,2559,2)
(3729,1782,2)
(1731,5712,2)
(1415,5057,2)
(6088,8756,2)
(8785,4016,2)
(7531,6867,2)
(588,5501,2)
(3880,270,2)
(4510,5633,2)
(3553,5324,2)
(8139,2465,2)
(2243,8391,2)
(2099,8391,2)
(7314,822,2)
(5383,4915,2)
(6724,7812,2)
(9019,115,2)
(8222,706,2)
(8752,7828,2)
(9038,115,2)
(6461,7569,2)
(1930,3415,2)
(1565,8134,2)
(8259,8391,2)
(8751,3582,2)
(3295,6758,2)
(1801,2983,2)
(2457,5501,2)
(7917,7001,2)
(366,7977,2)
(5582,8493,2)
(786,916,2)
(4711,115,2)
(6427,8756,2)
(2586,46,2)
(7658,1235,2)
(3185,4558,2)
(6827,115,2)
(8980,4619,2)
(4953,2199,2)
(4800,7440,2)
(1627,8756,2)
(6151,3758,2)
(5275,3095,2)
(7356,8756,2)
(7877,1220,2)
(2700,5089,2)
(934,7940,2)
(1395,8756,2)
(8470,3810,2)
(5290,6784,2)
(6353,7514,2)
(8722,9117,2)
(6612,5454,2)
(7230,4473,2)
(4303,6804,2)
(7653,115,2)
(1469,1888,2)
(138,2479,2)
(5930,1240,2)
(5836,2644,2)
(3590,3501,2)
(5398,2265,2)
(2274,6623,2)
(4038,6220,2)
(7432,3363,2)
(5250,3553,2)
(3509,2112,2)
(1829,8756,2)
(4126,1311,2)
(1121,4487,2)
(7308,1830,2)
(560,2512,2)
(239,2191,2)
(51,1002,2)
(8081,8756,2)
(9049,8391,2)
(3209,6155,2)
(790,8681,2)
(2651,8129,2)
(4871,5586,2)
(3456,8391,2)
(7954,8065,2)
(7874,4253,2)
(3992,6098,2)
(2610,1306,2)
(7822,6200,2)
(4463,2644,2)
(4963,6155,2)
(6829,6659,2)
(6088,115,2)
(1052,115,2)
(7672,8709,2)
(241,1641,2)
(2966,8836,2)
(8507,403,2)
(3089,1240,2)
(1899,8391,2)
(7152,7001,2)
(5060,8793,2)
(7663,1459,2)
(6603,46,2)
(1675,8391,2)
(2639,3123,2)
(7660,8391,2)
(141,2854,2)
(7408,3621,2)
(4293,2854,2)
(2205,6070,2)
(6364,6385,2)
(2117,3752,2)
(1380,115,2)
(1163,2983,2)
(294,5752,2)
(8376,8523,2)
(552,5089,2)
(3902,1376,2)
(3913,6995,2)
(2506,1653,2)
(4854,4793,2)
(16,46,2)
(8987,2053,2)
(1102,4576,2)
(3419,2191,2)
(4422,6995,2)
(6189,6912,2)
(6936,6791,2)
(219,4916,2)
(7291,6155,2)
(7508,150,2)
(3999,6239,2)
(1144,482,2)
(6206,4793,2)
(3860,8391,2)
(8669,3781,2)
(257,2036,2)
(858,2191,2)
(3043,8391,2)
(5546,575,2)
(5576,5540,2)
(1625,3286,2)
(4238,3969,2)
(3816,403,2)
(4375,3193,2)
(119,8391,2)
(3804,6356,2)
(6993,3940,2)
(3635,1509,2)
(5025,7819,2)
(8728,4178,2)
(3533,7514,2)
(7208,3769,2)
(8142,2303,2)
(2458,7210,2)
(6964,4118,2)
(2785,6155,2)
(2287,2861,2)
(7671,2136,2)
(6208,6993,2)
(1415,3215,2)
(8957,7497,2)
(7664,7828,2)
(2502,5656,2)
(980,7856,2)
(7000,7940,2)
(7643,8588,2)
(3108,5414,2)
(5777,4390,2)
(391,3451,2)
(7103,6070,2)
(4700,1488,2)
(6726,7216,2)
(7159,3451,2)
(3806,5757,2)
(1107,1002,2)
(4700,4945,2)
(519,2164,2)
(8851,610,2)
(8435,1905,2)
(4474,8538,2)
(9044,8857,2)
(2375,4219,2)
(4951,6613,2)
(5448,1235,2)
(835,874,2)
(7525,7628,2)
(3878,4614,2)
(3011,1954,2)
(6320,2596,2)
(2506,8391,2)
(7484,2335,2)
(2501,3103,2)
(8038,4350,2)
(718,2344,2)
(1938,539,2)
(3262,4698,2)
(5651,3363,2)
(3312,7765,2)
(3904,257,2)
(3204,4697,2)
(4094,7760,2)
(6093,4916,2)
(45,8391,2)
(8555,874,2)
(1680,5251,2)
(8126,2948,2)
(1680,3340,2)
(6651,5752,2)
(3330,6744,2)
(7974,1149,2)
(3349,3427,2)
(2544,4587,2)
(3071,6155,2)
(3786,3814,2)
(3804,5452,2)
(7358,7143,2)
(4116,403,2)
(6899,8633,2)
(2111,7030,2)
(8850,2053,2)
(2123,2866,2)
(2257,2058,2)
(4255,3812,2)
(3439,3814,2)
(909,2845,2)
(8048,965,2)
(3386,9026,2)
(4038,6613,2)
(5582,4565,2)
(3714,8812,2)
(457,1044,2)
(1415,8111,2)
(161,904,2)
(6372,3891,2)
(1670,8391,2)
(8276,8756,2)
(7168,8766,2)
(7953,2036,2)
(3899,706,2)
(3227,6867,2)
(2900,1240,2)
(8713,1370,2)
(6541,614,2)
(7075,4397,2)
(6457,6150,2)
(6565,7191,2)
(2640,6614,2)
(5090,6858,2)
(6023,8391,2)
(4991,1987,2)
(5445,5768,2)
(5463,4376,2)
(3958,4285,2)
(8728,2596,2)
(4125,2814,2)
(1545,7514,2)
(2741,4565,2)
(2438,3363,2)
(2848,8432,2)
(8979,2983,2)
(4377,799,2)
(1073,8065,2)
(3509,3215,2)
(4125,8677,2)
(6432,3415,2)
(4159,4994,2)
(8383,5251,2)
(7151,7353,2)
(863,6804,2)
(1354,5829,2)
(2346,6351,2)
(372,1656,2)
(7626,4149,2)
(4890,7514,2)
(7497,2854,2)
(3060,6385,2)
(4883,4015,2)
(6134,5204,2)
(8598,1727,2)
(6716,7108,2)
(4814,3814,2)
(5116,609,2)
(3191,2559,2)
(8047,8373,2)
(4219,7807,2)
(7743,5829,2)
(5477,3097,2)
(2314,7869,2)
(2009,408,2)
(3223,7590,2)
(2479,5204,2)
(3195,2835,2)
(2921,3812,2)
(8849,3218,2)
(611,5605,2)
(3727,8391,2)
(6623,575,2)
(2450,1380,2)
(6209,1149,2)
(3287,7066,2)
(9087,1488,2)
(4764,6054,2)
(6160,7940,2)
(6926,2983,2)
(5776,2416,2)
(2024,2995,2)
(7860,4793,2)
(5886,2030,2)
(1940,1235,2)
(5214,8111,2)
(2899,3488,2)
(7517,1656,2)
(5262,408,2)
(2779,2199,2)
(6001,6070,2)
(9007,8481,2)
(6273,7514,2)
(6510,6971,2)
(7023,575,2)
(8148,5836,2)
(2209,352,2)
(2684,1987,2)
(2012,1220,2)
(6356,1523,2)
(457,6613,2)
(1450,7354,2)
(148,7514,2)
(632,8431,2)
(4780,8756,2)
(2718,2366,2)
(2183,8928,2)
(4758,115,2)
(8321,3174,2)
(4034,3451,2)
(1329,7569,2)
(8582,115,2)
(2738,3969,2)
(9067,115,2)
(1952,1974,2)
(8142,6867,2)
(8790,8391,2)
(7271,6179,2)
(906,4604,2)
(3936,252,2)
(8913,115,2)
(3154,403,2)
(3604,5156,2)
(8699,7514,2)
(4836,115,2)
(3804,4449,2)
(7572,1209,2)
(6602,7514,2)
(1945,5204,2)
(1223,7614,2)
(1755,7514,2)
(3430,115,2)
(7866,3814,2)
(2294,904,2)
(5871,6782,2)
(4405,7389,2)
(1121,7940,2)
(358,8391,2)
(5580,2854,2)
(4270,5156,2)
(4735,1149,2)
(6175,3863,2)
(7488,904,2)
(4945,7233,2)
(8008,2845,2)
(7626,3565,2)
(7026,7988,2)
(6778,3007,2)
(8827,1149,2)
(4212,8391,2)
(836,5162,2)
(8536,7940,2)
(8417,5454,2)
(8631,1560,2)
(3637,2771,2)
(724,3621,2)
(2544,6968,2)
(4723,3123,2)
(9125,1180,2)
(2171,8391,2)
(4397,8756,2)
(897,1653,2)
(6556,8391,2)
(5691,408,2)
(1260,2879,2)
(7841,8756,2)
(5290,5156,2)
(4470,3781,2)
(778,8756,2)
(2205,3814,2)
(2782,1254,2)
(5340,408,2)
(7433,4697,2)
(272,2879,2)
(6993,5961,2)
(1879,6070,2)
(8352,1400,2)
(924,4668,2)
(7534,2344,2)
(2539,2445,2)
(2714,6496,2)
(3192,1616,2)
(7884,6280,2)
(436,3814,2)
(2722,1916,2)
(2527,3823,2)
(2501,8751,2)
(5197,4333,2)
(6400,5118,2)
(3015,5501,2)
(7580,8756,2)
(6064,4445,2)
(2221,8756,2)
(7465,150,2)
(2256,4002,2)
(7962,3427,2)
(7852,8756,2)
(6544,8756,2)
(8286,8756,2)
(1857,7135,2)
(5669,8391,2)
(7791,6047,2)
(2835,4376,2)
(2884,7103,2)
(2320,1306,2)
(981,3415,2)
(6007,3501,2)
(5191,3823,2)
(2349,1916,2)
(2280,46,2)
(800,8391,2)
(5007,6355,2)
(8284,4697,2)
(6559,4646,2)
(6011,5752,2)
(5941,5408,2)
(8512,4915,2)
(5904,5540,2)
(6726,5374,2)
(3936,2587,2)
(3887,8710,2)
(2412,5162,2)
(5035,415,2)
(6703,8391,2)
(7626,4587,2)
(5177,2344,2)
(444,3539,2)
(4374,4583,2)
(156,8756,2)
(5724,7628,2)
(5826,8107,2)
(7431,8030,2)
(3213,1158,2)
(4978,408,2)
(8829,7841,2)
(8881,8241,2)
(4035,5162,2)
(7004,6155,2)
(5172,8756,2)
(4118,7970,2)
(3241,3758,2)
(5327,1422,2)
(3620,8391,2)
(8180,8923,2)
(3439,6070,2)
(8311,2512,2)
(5790,453,2)
(4606,5089,2)
(8328,8391,2)
(7306,453,2)
(4398,7143,2)
(9020,2964,2)
(3893,7353,2)
(5096,178,2)
(2927,121,2)
(442,3895,2)
(4354,6285,2)
(8592,1459,2)
(4490,8925,2)
(8744,4186,2)
(4767,8099,2)
(8003,7514,2)
(3916,553,2)
(7368,7569,2)
(5645,1954,2)
(6094,8065,2)
(4391,134,2)
(3804,3215,2)
(8845,3696,2)
(4821,115,2)
(7603,2344,2)
(647,4367,2)
(799,1623,2)
(6114,1888,2)
(2478,7917,2)
(5267,3965,2)
(4933,1254,2)
(7522,4236,2)
(6656,8889,2)
(4720,2966,2)
(1151,3353,2)
(3651,4974,2)
(6439,348,2)
(6387,7760,2)
(7737,8955,2)
(4754,1234,2)
(7034,8756,2)
(6890,2366,2)
(8341,2043,2)
(6064,2896,2)
(8413,7852,2)
(2016,8756,2)
(2400,403,2)
(7352,8776,2)
(8461,7569,2)
(7398,1479,2)
(7114,5408,2)
(4355,8751,2)
(4729,2399,2)
(7844,92,2)
(4375,1405,2)
(91,1351,2)
(1428,1709,2)
(2314,4295,2)
(8900,46,2)
(2297,7711,2)
(4168,3823,2)
(2821,8815,2)
(2710,4793,2)
(4375,5736,2)
(5519,8391,2)
(2611,7657,2)
(8610,115,2)
(7384,1149,2)
(1043,2522,2)
(1299,1905,2)
(483,7821,2)
(614,2234,2)
(4596,8751,2)
(4965,4697,2)
(1985,4692,2)
(5323,1705,2)
(2423,8391,2)
(5792,4125,2)
(3975,6867,2)
(5494,3565,2)
(8225,6155,2)
(1273,115,2)
(8851,8432,2)
(8204,7042,2)
(5150,904,2)
(6837,4994,2)
(1415,929,2)
(7713,5454,2)
(5159,6314,2)
(7694,799,2)
(981,5374,2)
(3710,92,2)
(5726,403,2)
(8173,8728,2)
(1201,8756,2)
(5829,3752,2)
(8005,1240,2)
(5246,2771,2)
(8781,3625,2)
(5731,1459,2)
(438,5852,2)
(2584,4239,2)
(425,8391,2)
(7318,3123,2)
(6045,7569,2)
(5195,4505,2)
(5205,8187,2)
(7980,226,2)
(7593,7628,2)
(5414,4594,2)
(7755,6155,2)
(4286,4697,2)
(8969,7155,2)
(3940,115,2)
(4834,3810,2)
(769,800,2)
(1037,2834,2)
(2804,4116,2)
(9069,3451,2)
(8721,8756,2)
(9112,4802,2)
(2126,8027,2)
(8532,5204,2)
(4732,7546,2)
(1713,5752,2)
(8894,8756,2)
(5843,6442,2)
(5508,7760,2)
(742,5204,2)
(5499,4084,2)
(7828,3358,2)
(2381,8391,2)
(908,8432,2)
(6506,1782,2)
(811,50,2)
(7066,3814,2)
(5091,3320,2)
(3254,8391,2)
(6254,115,2)
(5485,8838,2)
(5809,9130,2)
(7923,8391,2)
(1670,115,2)
(1783,6580,2)
(4711,8431,2)
(6747,8889,2)
(6349,7339,2)
(3876,4565,2)
(5172,8391,2)
(4289,5752,2)
(5632,6904,2)
(6616,8055,2)
(5470,1128,2)
(6716,6804,2)
(4334,5316,2)
(3493,904,2)
(7951,1954,2)
(7853,2199,2)
(5387,484,2)
(578,115,2)
(5473,3312,2)
(8355,8065,2)
(5809,700,2)
(6631,8756,2)
(2437,706,2)
(2287,2065,2)
(4494,115,2)
(4417,115,2)
(1415,3331,2)
(2640,4579,2)
(8896,4565,2)
(2204,2210,2)
(8862,874,2)
(7499,8391,2)
(247,12,2)
(3010,1782,2)
(5040,8756,2)
(6956,1656,2)
(3397,2835,2)
(8751,6354,2)
(1845,4558,2)
(1605,5156,2)
(8267,226,2)
(7078,6132,2)
(1923,1954,2)
(7190,4388,2)
(6423,2187,2)
(1825,1069,2)
(3630,3457,2)
(1221,7155,2)
(6179,6097,2)
(6110,4604,2)
(1017,6711,2)
(276,6155,2)
(1019,5752,2)
(4437,609,2)
(1687,6155,2)
(4483,8756,2)
(69,6385,2)
(3077,2199,2)
(7566,8391,2)
(600,3891,2)
(1418,5698,2)
(6408,3769,2)
(8514,2191,2)
(2556,7909,2)
(7065,5648,2)
(977,8756,2)
(2725,4579,2)
(1026,2979,2)
(7582,6867,2)
(7500,3363,2)
(6569,8756,2)
(3650,8523,2)
(2703,5939,2)
(4344,7711,2)
(5555,8391,2)
(3485,2596,2)
(3279,1488,2)
(2137,6070,2)
(2321,2191,2)
(2177,453,2)
(7870,9001,2)
(6300,3198,2)
(2344,3218,2)
(6904,8957,2)
(4428,4388,2)
(7411,3295,2)
(4259,7909,2)
(8706,6155,2)
(7073,2465,2)
(2062,3415,2)
(7571,5501,2)
(193,1235,2)
(3438,1830,2)
(8692,408,2)
(9034,3585,2)
(450,3123,2)
(942,904,2)
(7909,8493,2)
(4770,904,2)
(5451,6548,2)
(991,8889,2)
(7771,8445,2)
(3292,7760,2)
(6419,8458,2)
(3045,226,2)
(5038,403,2)
(4733,403,2)
(4204,6155,2)
(1485,7066,2)
(7191,8391,2)
(5638,4449,2)
(1025,2835,2)
(8020,5454,2)
(8622,904,2)
(2319,403,2)
(3828,4697,2)
(1292,3814,2)
(7597,6070,2)
(768,7271,2)
(5809,7039,2)
(506,6417,2)
(780,8391,2)
(8155,6829,2)
(1560,3823,2)
(2593,7760,2)
(263,2053,2)
(6236,115,2)
(5815,1656,2)
(7676,1254,2)
(4401,3675,2)
(7717,6730,2)
(8244,3866,2)
(2767,8756,2)
(3957,2835,2)
(2326,2585,2)
(3031,777,2)
(1586,4764,2)
(7674,208,2)
(4628,4053,2)
(5709,2512,2)
(6885,6791,2)
(3895,8538,2)
(8209,5156,2)
(7966,3565,2)
(1906,8131,2)
(1054,115,2)
(3266,2237,2)
(3509,6649,2)
(8315,3812,2)
(7950,6259,2)
(1946,2053,2)
(8847,6289,2)
(6246,2845,2)
(403,1311,2)
(3450,8431,2)
(6452,8580,2)
(6713,8391,2)
(5888,6155,2)
(3837,2834,2)
(1269,1149,2)
(5676,408,2)
(3806,387,2)
(8524,2210,2)
(3364,6784,2)
(2810,874,2)
(581,3781,2)
(2445,7119,2)
(3067,115,2)
(3738,351,2)
(3736,5454,2)
(7572,2130,2)
(2935,5960,2)
(3849,408,2)
(8653,4945,2)
(11,4604,2)
(6889,8391,2)
(1284,1254,2)
(8382,7909,2)
(2886,2036,2)
(6502,267,2)
(4906,8756,2)
(554,7514,2)
(780,115,2)
(4426,8391,2)
(4470,4089,2)
(5138,4253,2)
(419,150,2)
(5170,2502,2)
(3152,6132,2)
(721,5408,2)
(4072,8391,2)
(4657,7828,2)
(2775,115,2)
(6182,5836,2)
(6656,8391,2)
(4956,680,2)
(5335,92,2)
(6237,3965,2)
(1042,1331,2)
(8698,3963,2)
(6884,5454,2)
(7207,4679,2)
(3147,1254,2)
(8811,8391,2)
(3520,3530,2)
(848,6046,2)
(7354,2258,2)
(5023,208,2)
(6562,2283,2)
(8400,4583,2)
(1640,403,2)
(7923,7977,2)
(7182,115,2)
(5906,1709,2)
(7200,706,2)
(6508,5007,2)
(5413,2983,2)
(6758,2315,2)
(1654,3963,2)
(6076,5258,2)
(6446,8107,2)
(4466,8391,2)
(3090,2651,2)
(789,4579,2)
(4188,46,2)
(6220,115,2)
(3556,5141,2)
(8078,6132,2)
(5627,8756,2)
(3079,403,2)
(4581,3807,2)
(3372,7143,2)
(3594,7711,2)
(7575,580,2)
(7760,5698,2)
(4873,8432,2)
(1116,8756,2)
(8051,5069,2)
(1351,5998,2)
(4120,4253,2)
(7990,7628,2)
(268,1149,2)
(9057,8815,2)
(7656,3621,2)
(5402,8233,2)
(2979,3320,2)
(2658,904,2)
(1479,2502,2)
(2222,6662,2)
(6521,1254,2)
(5669,115,2)
(1965,2834,2)
(7083,3207,2)
(1529,6155,2)
(1495,5712,2)
(5322,6070,2)
(251,4974,2)
(5241,408,2)
(1045,7155,2)
(6200,6215,2)
(2234,2845,2)
(8230,3218,2)
(4595,6385,2)
(3823,2007,2)
(6128,7143,2)
(2362,2835,2)
(3157,6699,2)
(5389,3781,2)
(8070,8481,2)
(2225,1509,2)
(3804,4149,2)
(8188,7001,2)
(222,3363,2)
(2477,46,2)
(5239,3823,2)
(3465,5237,2)
(3894,1782,2)
(214,6155,2)
(5381,3752,2)
(5226,5881,2)
(1270,1087,2)
(3458,8108,2)
(5144,3198,2)
(4235,2330,2)
(788,5777,2)
(6989,4236,2)
(3224,3545,2)
(80,5069,2)
(8225,7187,2)
(6419,1158,2)
(4646,8544,2)
(2675,3658,2)
(3722,3735,2)
(528,115,2)
(1645,7005,2)
(5709,7200,2)
(4915,5605,2)
(5087,1173,2)
(1304,6155,2)
(1809,5251,2)
(3776,8601,2)
(3555,6580,2)
(5124,875,2)
(7769,706,2)
(7339,2537,2)
(1853,8391,2)
(134,5656,2)
(1993,6008,2)
(1498,7143,2)
(4831,3142,2)
(4418,4565,2)
(9129,3488,2)
(7275,4236,2)
(5530,7410,2)
(238,3810,2)
(6764,6867,2)
(5687,2845,2)
(2198,9000,2)
(7567,3895,2)
(5549,504,2)
(5165,1954,2)
(6077,4236,2)
(4043,115,2)
(1705,3823,2)
(5189,3103,2)
(3303,2036,2)
(1084,6155,2)
(6990,1396,2)
(8647,1954,2)
(2072,115,2)
(644,115,2)
(4210,7703,2)
(3842,8134,2)
(1473,7760,2)
(127,5251,2)
(473,6285,2)
(2085,6227,2)
(1388,2366,2)
(7301,7628,2)
(4029,2845,2)
(3637,8481,2)
(6676,4153,2)
(3,3823,2)
(4915,8505,2)
(1266,5829,2)
(232,8756,2)
(3612,8756,2)
(2190,5402,2)
(2580,6783,2)
(2079,8756,2)
(6384,8756,2)
(485,46,2)
(6359,5301,2)
(5489,115,2)
(119,2854,2)
(5752,1600,2)
(4206,3906,2)
(35,7841,2)
(4727,46,2)
(2553,331,2)
(2504,365,2)
(8179,2191,2)
(3634,7628,2)
(1521,3320,2)
(3548,7870,2)
(6072,115,2)
(2064,5586,2)
(3903,8756,2)
(2748,996,2)
(477,115,2)
(1900,7384,2)
(6867,5869,2)
(7460,2187,2)
(8971,2053,2)
(1900,2653,2)
(2366,4435,2)
(4847,2866,2)
(2871,3906,2)
(4621,8756,2)
(8966,8391,2)
(2133,798,2)
(6468,7868,2)
(463,115,2)
(6463,7765,2)
(2860,5765,2)
(2104,5156,2)
(2099,6084,2)
(9021,5355,2)
(2105,3218,2)
(3095,3488,2)
(7131,5752,2)
(2938,115,2)
(8686,8756,2)
(1462,3758,2)
(753,1657,2)
(9106,2845,2)
(7035,3379,2)
(2775,352,2)
(2388,5353,2)
(3878,1680,2)
(3248,4793,2)
(1533,1770,2)
(1858,1117,2)
(4470,7358,2)
(5373,904,2)
(7804,2512,2)
(6974,7940,2)
(4398,7711,2)
(3003,5162,2)
(7992,3198,2)
(7664,4876,2)
(3150,6155,2)
(2287,4587,2)
(8340,8391,2)
(8700,3810,2)
(5335,2558,2)
(5816,4153,2)
(9124,8391,2)
(1727,8391,2)
(2029,8756,2)
(1548,7909,2)
(2970,8756,2)
(3229,4125,2)
(4350,2030,2)
(8440,4604,2)
(377,1254,2)
(6382,7262,2)
(8298,3067,2)
(7052,4679,2)
(1377,904,2)
(5013,8756,2)
(3804,7039,2)
(6515,2835,2)
(8279,8391,2)
(102,5084,2)
(1702,8756,2)
(5304,2526,2)
(5172,208,2)
(7298,7514,2)
(4712,904,2)
(7498,5316,2)
(617,115,2)
(8391,5025,2)
(7134,7628,2)
(5902,1240,2)
(6708,8756,2)
(7786,5752,2)
(1094,6046,2)
(6232,3417,2)
(2254,9125,2)
(6419,1280,2)
(3847,7514,2)
(2762,8065,2)
(3114,8391,2)
(837,1235,2)
(5971,3192,2)
(9033,92,2)
(4794,6858,2)
(2265,5829,2)
(350,1640,2)
(2391,4605,2)
(8178,4558,2)
(8844,1220,2)
(4724,706,2)
(7019,4697,2)
(8762,536,2)
(8138,1657,2)
(3899,115,2)
(97,7628,2)
(1876,8756,2)
(8493,2002,2)
(4397,1114,2)
(9030,3488,2)
(1662,4679,2)
(1402,1173,2)
(8296,6289,2)
(4628,1858,2)
(4755,4594,2)
(6513,2845,2)
(5167,8889,2)
(2018,7353,2)
(4168,6614,2)
(6750,6155,2)
(4564,6132,2)
(8149,6132,2)
(1542,115,2)
(5579,7119,2)
(5244,1954,2)
(3682,3363,2)
(899,3758,2)
(660,5829,2)
(6354,3103,2)
(4726,6385,2)
(4718,8335,2)
(1467,5098,2)
(2059,717,2)
(6367,6665,2)
(8645,6155,2)
(2609,1240,2)
(4073,7353,2)
(916,3833,2)
(4445,6509,2)
(1435,1099,2)
(3679,6677,2)
(352,706,2)
(1914,5746,2)
(7361,1583,2)
(2309,7163,2)
(2511,2482,2)
(7894,3363,2)
(4466,1493,2)
(2058,4088,2)
(5726,8612,2)
(1134,403,2)
(6750,8391,2)
(6103,115,2)
(562,6155,2)
(1313,6548,2)
(3902,4815,2)
(7525,115,2)
(7938,123,2)
(5109,3621,2)
(1415,2993,2)
(1040,5777,2)
(7045,1235,2)
(2999,134,2)
(8160,2366,2)
(6137,3773,2)
(6285,6692,2)
(173,1235,2)
(8484,2534,2)
(1619,3521,2)
(1909,2187,2)
(6508,5938,2)
(3243,2030,2)
(1307,8756,2)
(5687,8065,2)
(8047,6543,2)
(7740,6155,2)
(5183,3706,2)
(7496,5237,2)
(4198,7569,2)
(2888,2191,2)
(5470,3417,2)
(3566,7514,2)
(4112,2537,2)
(3641,2283,2)
(1279,2482,2)
(7932,7870,2)
(633,306,2)
(7432,115,2)
(5705,115,2)
(1493,8144,2)
(3780,7628,2)
(7672,7977,2)
(5370,3658,2)
(7340,6656,2)
(8931,8728,2)
(8323,4253,2)
(7480,3863,2)
(6321,4388,2)
(4057,4405,2)
(5303,3142,2)
(2187,8756,2)
(4071,46,2)
(6084,8107,2)
(7533,4976,2)
(2057,1189,2)
(3807,115,2)
(3297,1350,2)
(679,1709,2)
(8918,2983,2)
(3320,4236,2)
(3658,7572,2)
(5638,2681,2)
(7679,7219,2)
(5007,5938,2)
(8855,4088,2)
(2847,7829,2)
(7038,8756,2)
(8849,2344,2)
(4690,9068,2)
(3647,4689,2)
(6054,8538,2)
(7212,46,2)
(2153,5752,2)
(8940,7222,2)
(7828,2502,2)
(2562,3541,2)
(2905,7765,2)
(2575,8756,2)
(878,3823,2)
(2070,3863,2)
(400,5251,2)
(1725,5670,2)
(46,4190,2)
(2585,617,2)
(1049,8783,2)
(3368,7271,2)
(124,8955,2)
(7641,1235,2)
(3889,202,2)
(5037,1488,2)
(5510,8677,2)
(6419,9130,2)
(8846,7089,2)
(3008,6053,2)
(2655,5089,2)
(2996,390,2)
(5419,8391,2)
(1427,7299,2)
(6824,1874,2)
(4319,115,2)
(4051,1829,2)
(8421,1401,2)
(6866,4831,2)
(1767,7262,2)
(2526,8288,2)
(444,7828,2)
(6414,2366,2)
(3021,904,2)
(3426,1916,2)
(5392,8756,2)
(8431,1394,2)
(1326,8391,2)
(7765,2995,2)
(3568,1709,2)
(6688,2295,2)
(1265,4253,2)
(5297,7210,2)
(2411,8923,2)
(1723,4253,2)
(8926,3891,2)
(3662,3814,2)
(1883,7628,2)
(7025,5523,2)
(7345,8756,2)
(4301,3095,2)
(7039,2596,2)
(2207,3891,2)
(5401,2191,2)
(2989,1311,2)
(4182,4016,2)
(1508,2587,2)
(411,8889,2)
(2233,7001,2)
(2033,2559,2)
(2386,2043,2)
(5861,7119,2)
(8663,5847,2)
(5185,3320,2)
(7930,0,2)
(3764,1896,2)
(3574,3187,2)
(2475,115,2)
(3129,1311,2)
(572,8391,2)
(8529,7271,2)
(5178,3222,2)
(5707,8777,2)
(6881,226,2)
(9040,1785,2)
(5510,8017,2)
(4866,1785,2)
(9052,410,2)
(4635,8751,2)
(7816,5869,2)
(3559,8756,2)
(6617,7405,2)
(2356,6314,2)
(2287,6649,2)
(5483,8074,2)
(4133,476,2)
(642,3942,2)
(1892,1459,2)
(4268,6155,2)
(82,6784,2)
(1290,6155,2)
(6985,2024,2)
(904,2058,2)
(7907,8756,2)
(1406,8964,2)
(3917,8756,2)
(8207,6385,2)
(6465,8432,2)
(303,536,2)
(3757,202,2)
(8824,4189,2)
(8985,3829,2)
(8513,2344,2)
(1962,46,2)
(3668,8756,2)
(6789,7514,2)
(4744,3218,2)
(2117,8391,2)
(6993,2303,2)
(5230,3201,2)
(8404,3201,2)
(7700,7001,2)
(6278,1410,2)
(9117,2845,2)
(4766,6155,2)
(2287,4149,2)
(5110,115,2)
(3401,8107,2)
(4492,2210,2)
(1701,108,2)
(3432,7405,2)
(5343,951,2)
(3036,3752,2)
(3752,2777,2)
(3277,5712,2)
(8518,5958,2)
(5841,3232,2)
(3347,115,2)
(9106,115,2)
(8134,284,2)
(775,2191,2)
(2959,46,2)
(8828,7514,2)
(9047,115,2)
(1145,5454,2)
(2731,5805,2)
(901,4008,2)
(6867,1467,2)
(4849,1479,2)
(4157,3218,2)
(6481,8756,2)
(4799,6325,2)
(2706,2592,2)
(7671,1459,2)
(6761,3097,2)
(5535,2187,2)
(1235,8712,2)
(3882,6053,2)
(5894,356,2)
(3583,403,2)
(515,6523,2)
(7596,5836,2)
(3810,3788,2)
(2792,1493,2)
(8668,7143,2)
(2370,4828,2)
(3119,6613,2)
(5964,6867,2)
(6553,874,2)
(5102,3095,2)
(5801,8756,2)
(6052,7909,2)
(8142,4522,2)
(1287,7628,2)
(164,1935,2)
(2794,4850,2)
(4519,4326,2)
(5445,3488,2)
(612,8756,2)
(1992,572,2)
(8863,1944,2)
(4815,1311,2)
(3531,3198,2)
(8995,951,2)
(88,7514,2)
(549,3153,2)
(861,6149,2)
(651,2537,2)
(3263,2983,2)
(7030,2834,2)
(4342,9048,2)
(1678,8107,2)
(1452,115,2)
(8697,4876,2)
(410,1709,2)
(6084,538,2)
(2386,2445,2)
(3865,7888,2)
(7644,403,2)
(3008,4382,2)
(804,706,2)
(2210,904,2)
(2342,403,2)
(5198,338,2)
(5684,7514,2)
(39,9140,2)
(6533,4000,2)
(3515,3295,2)
(7684,3934,2)
(3887,5698,2)
(5209,2206,2)
(7087,6155,2)
(5593,1158,2)
(6687,7724,2)
(3390,8756,2)
(2186,7514,2)
(4772,6252,2)
(9047,7760,2)
(8764,8910,2)
(1935,8756,2)
(6762,4876,2)
(4745,7238,2)
(1047,115,2)
(3264,3823,2)
(7233,7754,2)
(6033,3969,2)
(3811,3123,2)
(1401,3285,2)
(2723,4343,2)
(8994,2537,2)
(888,5027,2)
(6771,7514,2)
(7763,7451,2)
(2497,8107,2)
(6,8538,2)
(3410,8756,2)
(8709,8391,2)
(461,7514,2)
(2133,6666,2)
(514,115,2)
(5807,2964,2)
(9133,8969,2)
(8042,5586,2)
(8297,6057,2)
(387,1108,2)
(2253,1709,2)
(2380,7155,2)
(5421,4821,2)
(5302,2559,2)
(6897,706,2)
(6992,2119,2)
(2544,1158,2)
(3162,1648,2)
(177,6732,2)
(7393,2421,2)
(4375,87,2)
(3518,4503,2)
(3934,4925,2)
(477,2845,2)
(3016,6479,2)
(5519,7940,2)
(7667,8295,2)
(7963,5949,2)
(6154,5573,2)
(5388,1213,2)
(1541,8756,2)
(4843,6695,2)
(5974,611,2)
(8485,6019,2)
(1795,6971,2)
(2903,4925,2)
(6876,2502,2)
(4277,4876,2)
(132,2335,2)
(6760,4974,2)
(7426,5204,2)
(6172,7652,2)
(3314,4435,2)
(6483,6900,2)
(748,7590,2)
(3518,7760,2)
(7085,5408,2)
(8864,2326,2)
(364,6285,2)
(682,1782,2)
(3889,904,2)
(7579,5752,2)
(3719,46,2)
(2006,3095,2)
(6760,5479,2)
(5465,4576,2)
(6440,9127,2)
(1308,1240,2)
(8945,4916,2)
(5700,1653,2)
(8020,7578,2)
(8519,3232,2)
(1694,115,2)
(1284,3170,2)
(6722,8756,2)
(4401,1235,2)
(1034,904,2)
(261,2036,2)
(7416,4245,2)
(4959,5705,2)
(2069,4632,2)
(9105,8756,2)
(314,5540,2)
(1289,874,2)
(7287,8391,2)
(2391,2199,2)
(6435,3812,2)
(4842,3320,2)
(5361,1104,2)
(5834,7226,2)
(1616,8889,2)
(4327,8756,2)
(4609,8756,2)
(6851,6150,2)
(6625,8237,2)
(3461,4,2)
(2047,7614,2)
(7516,8391,2)
(7548,352,2)
(2063,4698,2)
(2665,5586,2)
(4825,7852,2)
(5875,2060,2)
(2193,6070,2)
(2397,2656,2)
(453,7983,2)
(6858,784,2)
(2,7514,2)
(704,1653,2)
(2825,4974,2)
(3886,6417,2)
(1831,5629,2)
(4318,7628,2)
(896,5251,2)
(7303,6155,2)
(4214,6346,2)
(1948,115,2)
(887,4289,2)
(989,8391,2)
(8379,7453,2)
(1452,8391,2)
(7502,4793,2)
(772,8756,2)
(4426,1987,2)
(7197,8391,2)
(3399,3415,2)
(4038,8378,2)
(1947,115,2)
(6393,3895,2)
(471,7977,2)
(5383,4976,2)
(1870,4793,2)
(2818,8756,2)
(779,5431,2)
(228,727,2)
(2978,115,2)
(2591,2866,2)
(7033,5204,2)
(4110,8065,2)
(2287,8458,2)
(2037,46,2)
(8233,5698,2)
(4147,8756,2)
(5248,2559,2)
(2941,3488,2)
(280,9076,2)
(44,7628,2)
(5310,9140,2)
(2666,2036,2)
(6104,115,2)
(9141,8756,2)
(741,4340,2)
(5229,5474,2)
(6669,5752,2)
(7584,6804,2)
(9010,8391,2)
(289,7590,2)
(4078,1173,2)
(6648,5698,2)
(6664,1149,2)
(3891,2520,2)
(9102,4576,2)
(3596,2130,2)
(3169,5712,2)
(5668,4236,2)
(148,8391,2)
(4455,609,2)
(6956,6494,2)
(6278,2858,2)
(3634,6429,2)
(2262,3782,2)
(807,7253,2)
(9043,5245,2)
(8034,1930,2)
(3487,1227,2)
(2060,2044,2)
(4856,1724,2)
(8333,5251,2)
(8710,5698,2)
(6201,2983,2)
(402,2043,2)
(6967,1254,2)
(2953,4023,2)
(1286,4467,2)
(7133,1149,2)
(1172,2128,2)
(3823,2036,2)
(1668,5958,2)
(5871,3633,2)
(630,1685,2)
(1770,8319,2)
(4557,5454,2)
(1374,3363,2)
(8852,7828,2)
(781,1952,2)
(3215,7001,2)
(2433,5432,2)
(1121,4077,2)
(3649,6351,2)
(7120,1657,2)
(5318,2854,2)
(7459,5540,2)
(373,3541,2)
(2477,8600,2)
(5971,5537,2)
(6383,6971,2)
(4682,8756,2)
(805,1240,2)
(6255,14,2)
(109,5441,2)
(2628,1349,2)
(5659,408,2)
(8388,6155,2)
(5669,1705,2)
(5615,2596,2)
(5774,4231,2)
(8056,3863,2)
(2781,3312,2)
(2095,874,2)
(8431,5869,2)
(6049,2191,2)
(3611,7066,2)
(6388,410,2)
(6771,1235,2)
(8148,115,2)
(4375,2112,2)
(847,5316,2)
(7806,8794,2)
(7287,2845,2)
(4540,8756,2)
(391,3621,2)
(9027,5586,2)
(5494,4515,2)
(914,5156,2)
(1556,8923,2)
(7731,8756,2)
(1041,7501,2)
(6157,4793,2)
(7384,4767,2)
(4963,2660,2)
(5486,8391,2)
(3565,5099,2)
(5420,8756,2)
(7759,3451,2)
(3208,7119,2)
(8157,5586,2)
(3866,3812,2)
(8637,5138,2)
(6636,6846,2)
(6514,5752,2)
(7846,7590,2)
(477,2537,2)
(8789,8529,2)
(5648,228,2)
(7358,3781,2)
(7382,5204,2)
(2220,3363,2)
(4128,92,2)
(762,6155,2)
(3735,9069,2)
(2645,3417,2)
(7400,408,2)
(7017,8756,2)
(541,2160,2)
(7411,115,2)
(8008,706,2)
(6663,8391,2)
(7600,4333,2)
(6104,3781,2)
(8808,5586,2)
(2660,6155,2)
(752,1254,2)
(877,6155,2)
(3678,904,2)
(6378,115,2)
(3759,7847,2)
(3588,7940,2)
(3804,2681,2)
(3381,7367,2)
(4793,7888,2)
(2309,3812,2)
(5876,8928,2)
(4064,2964,2)
(7161,5540,2)
(7531,5671,2)
(2674,6201,2)
(595,3621,2)
(4258,46,2)
(3114,2835,2)
(474,7980,2)
(2239,4697,2)
(1480,7066,2)
(462,6741,2)
(1760,2794,2)
(2597,6167,2)
(3696,338,2)
(4007,7514,2)
(3865,3983,2)
(6079,6179,2)
(3058,6866,2)
(9077,7569,2)
(8917,7628,2)
(5057,1149,2)
(5687,8391,2)
(8248,2414,2)
(8457,2467,2)
(4016,1685,2)
(3621,4515,2)
(2008,5881,2)
(3673,8391,2)
(2384,408,2)
(5706,4697,2)
(1530,1744,2)
(176,4697,2)
(8592,8391,2)
(5494,6474,2)
(6226,6008,2)
(2674,2983,2)
(2955,2559,2)
(7892,1493,2)
(2978,5089,2)
(7156,4511,2)
(7798,4876,2)
(768,8391,2)
(7703,5129,2)
(2239,115,2)
(6780,7569,2)
(4722,3619,2)
(2532,2465,2)
(4526,12,2)
(3584,6417,2)
(1188,6155,2)
(1103,115,2)
(700,2596,2)
(5115,3095,2)
(6832,7514,2)
(7299,3658,2)
(4201,2385,2)
(6830,2559,2)
(2347,4205,2)
(7579,8147,2)
(6423,5074,2)
(8144,8276,2)
(536,4285,2)
(136,3906,2)
(664,6479,2)
(6197,3965,2)
(6386,6155,2)
(6152,8751,2)
(861,408,2)
(7715,7917,2)
(2544,4350,2)
(2299,115,2)
(1967,951,2)
(1117,6830,2)
(4647,8391,2)
(1044,6613,2)
(2796,7841,2)
(1238,115,2)
(5301,8832,2)
(7711,4579,2)
(7103,2440,2)
(7225,7155,2)
(9132,8131,2)
(6284,1158,2)
(2449,7571,2)
(4198,8391,2)
(2668,248,2)
(538,8107,2)
(4134,7614,2)
(6148,8523,2)
(2526,1705,2)
(1982,5422,2)
(4218,6155,2)
(6896,6464,2)
(4572,6155,2)
(2553,1509,2)
(5540,7055,2)
(1327,6804,2)
(7066,4814,2)
(415,7400,2)
(2556,8054,2)
(5777,6285,2)
(7559,8728,2)
(5980,1240,2)
(5186,4974,2)
(6664,5752,2)
(195,4976,2)
(2571,5454,2)
(3051,5981,2)
(6919,2520,2)
(8759,7590,2)
(4298,5501,2)
(8435,1149,2)
(2652,5030,2)
(5559,1240,2)
(4847,2845,2)
(5270,4697,2)
(6677,3553,2)
(1088,7150,2)
(714,408,2)
(206,2206,2)
(8654,1190,2)
(5877,92,2)
(287,3906,2)
(6010,131,2)
(8365,5128,2)
(4981,3810,2)
(2982,3553,2)
(4332,3810,2)
(72,5096,2)
(8496,8391,2)
(6146,2482,2)
(7946,4326,2)
(3240,2482,2)
(7366,115,2)
(2544,6649,2)
(2094,115,2)
(761,7155,2)
(6336,5706,2)
(4475,2464,2)
(3999,3141,2)
(4239,4579,2)
(5561,1974,2)
(8584,904,2)
(4070,8391,2)
(8198,371,2)
(3291,4624,2)
(1010,403,2)
(7085,115,2)
(118,5586,2)
(5635,5162,2)
(8021,8391,2)
(2901,4576,2)
(1850,3969,2)
(9022,408,2)
(7655,1657,2)
(7883,150,2)
(4529,3752,2)
(9042,6155,2)
(1089,408,2)
(460,8756,2)
(7720,1954,2)
(6429,7628,2)
(5166,5734,2)
(3673,2845,2)
(717,6483,2)
(5569,6155,2)
(8546,4673,2)
(6044,8756,2)
(7815,7413,2)
(5429,7514,2)
(5020,6385,2)
(6524,5540,2)
(2542,3192,2)
(7050,4397,2)
(5734,6155,2)
(5406,408,2)
(4401,7514,2)
(3609,403,2)
(2145,6613,2)
(395,6580,2)
(7958,6677,2)
(2126,92,2)
(4301,3731,2)
(1623,2475,2)
(631,8481,2)
(7446,8580,2)
(3159,408,2)
(6513,115,2)
(2701,6867,2)
(4167,2953,2)
(4638,4225,2)
(7995,473,2)
(5759,4253,2)
(3379,1653,2)
(6704,2596,2)
(6537,6385,2)
(8648,115,2)
(517,3895,2)
(6880,4057,2)
(2846,1560,2)
(8643,5586,2)
(6538,876,2)
(387,8065,2)
(7703,3123,2)
(5236,7186,2)
(6103,8391,2)
(6972,8712,2)
(5812,7060,2)
(6715,115,2)
(4811,92,2)
(5482,1254,2)
(4640,3969,2)
(3868,8391,2)
(5555,8756,2)
(6577,5947,2)
(2167,3814,2)
(1683,3201,2)
(4096,517,2)
(6278,3983,2)
(2546,2191,2)
(1162,6000,2)
(5696,2091,2)
(2377,8107,2)
(8598,7940,2)
(1306,9012,2)
(8233,7962,2)
(3782,1369,2)
(1415,6921,2)
(8532,9019,2)
(3056,3295,2)
(7402,8131,2)
(4579,3198,2)
(8453,8432,2)
(5164,115,2)
(5345,2983,2)
(3517,1240,2)
(5163,3363,2)
(6797,2060,2)
(1236,2689,2)
(8736,1122,2)
(8070,2771,2)
(1571,4632,2)
(1642,2537,2)
(8293,6849,2)
(4850,115,2)
(3099,3218,2)
(8908,951,2)
(5960,7652,2)
(4484,5755,2)
(4938,5752,2)
(599,8749,2)
(6368,8756,2)
(3441,4679,2)
(1990,8538,2)
(3939,2036,2)
(886,4945,2)
(5598,1167,2)
(8354,1013,2)
(7121,7760,2)
(1769,8756,2)
(6709,3812,2)
(4641,5774,2)
(2255,8794,2)
(2988,1645,2)
(3192,7001,2)
(4070,5251,2)
(3362,6577,2)
(2543,2112,2)
(8729,874,2)
(8694,739,2)
(8290,6314,2)
(4314,1653,2)
(8421,8391,2)
(8556,2835,2)
(7491,8989,2)
(3331,8024,2)
(4099,6867,2)
(4726,5435,2)
(3471,4697,2)
(6284,8458,2)
(2493,8756,2)
(5573,7514,2)
(8378,6613,2)
(186,6417,2)
(1389,5810,2)
(3626,8751,2)
(8753,3095,2)
(5900,2465,2)
(3806,4183,2)
(8076,8746,2)
(1166,8756,2)
(1294,4984,2)
(1462,8391,2)
(1243,4985,2)
(1389,4697,2)
(4026,3363,2)
(8709,115,2)
(5640,6385,2)
(795,115,2)
(6520,6899,2)
(7186,5847,2)
(7870,1458,2)
(4935,2866,2)
(2134,1874,2)
(5738,5698,2)
(8863,330,2)
(5949,4285,2)
(7383,46,2)
(8176,7316,2)
(4424,4876,2)
(253,1972,2)
(7105,1675,2)
(6522,115,2)
(8184,403,2)
(8233,6179,2)
(2853,3382,2)
(3007,4408,2)
(7887,8756,2)
(4379,682,2)
(2619,6804,2)
(8965,2592,2)
(6606,8815,2)
(112,6497,2)
(6156,2344,2)
(4446,4793,2)
(7433,6889,2)
(513,8845,2)
(4731,5869,2)
(3212,1954,2)
(6449,8065,2)
(8085,972,2)
(3274,4992,2)
(8090,3527,2)
(6583,2060,2)
(4814,7711,2)
(4717,3814,2)
(1764,6179,2)
(1984,6314,2)
(7357,115,2)
(6576,8391,2)
(6833,3295,2)
(6419,6649,2)
(3400,6867,2)
(6596,219,2)
(1878,2845,2)
(1850,4704,2)
(4610,8815,2)
(4624,4565,2)
(4132,1458,2)
(1376,1311,2)
(3018,7917,2)
(4861,4184,2)
(6495,352,2)
(734,8756,2)
(5548,3451,2)
(8101,8751,2)
(6673,7628,2)
(7961,1830,2)
(1852,1173,2)
(7952,2964,2)
(5349,5829,2)
(412,7614,2)
(577,3823,2)
(1394,5869,2)
(8743,150,2)
(348,1509,2)
(3281,6289,2)
(5721,4974,2)
(2317,7940,2)
(8870,114,2)
(2384,115,2)
(1894,408,2)
(1962,811,2)
(5593,4587,2)
(6646,8856,2)
(704,4104,2)
(4704,1679,2)
(2544,3565,2)
(1779,115,2)
(6014,9140,2)
(6348,7019,2)
(8296,9059,2)
(8578,53,2)
(6752,6613,2)
(4748,846,2)
(7090,7909,2)
(6125,8391,2)
(950,7940,2)
(507,7754,2)
(7890,4876,2)
(2136,8592,2)
(5459,8756,2)
(2287,929,2)
(7692,6479,2)
(7487,7155,2)
(2031,8889,2)
(1401,6791,2)
(5360,2020,2)
(3338,3634,2)
(7669,2482,2)
(8633,5932,2)
(4224,1488,2)
(121,115,2)
(3072,4188,2)
(3452,7760,2)
(8446,1657,2)
(4556,4579,2)
(2290,7940,2)
(4792,4321,2)
(736,8756,2)
(8679,9096,2)
(5588,1653,2)
(4280,6155,2)
(3348,7977,2)
(5632,5580,2)
(8427,8664,2)
(5685,3218,2)
(1828,6867,2)
(104,904,2)
(8893,874,2)
(3252,1954,2)
(1908,4252,2)
(1439,6155,2)
(1218,403,2)
(3020,7263,2)
(6838,2983,2)
(6502,2543,2)
(4381,115,2)
(3096,3363,2)
(8658,7924,2)
(5929,4388,2)
(7057,115,2)
(3813,7514,2)
(8964,3382,2)
(8588,4408,2)
(8105,8391,2)
(2940,8391,2)
(2020,403,2)
(5652,4309,2)
(7436,2995,2)
(6565,609,2)
(8405,8894,2)
(862,3451,2)
(4829,8756,2)
(2949,19,2)
(3354,8756,2)
(8462,4697,2)
(5328,2366,2)
(2443,4974,2)
(1415,7039,2)
(4950,8756,2)
(5823,4704,2)
(8655,1560,2)
(8849,115,2)
(8211,1670,2)
(1280,4579,2)
(3091,4604,2)
(5245,6804,2)
(4515,8175,2)
(8658,3108,2)
(3213,3215,2)
(7604,1943,2)
(3145,7760,2)
(3687,8889,2)
(6073,2596,2)
(2295,4619,2)
(6122,8756,2)
(5418,1954,2)
(5047,8481,2)
(2755,8107,2)
(8795,5084,2)
(873,1657,2)
(7609,8756,2)
(5942,150,2)
(8620,3541,2)
(3764,2537,2)
(1227,115,2)
(2544,9130,2)
(7470,8913,2)
(1617,1493,2)
(927,5586,2)
(1194,7765,2)
(4037,5069,2)
(8626,6609,2)
(9090,2845,2)
(8359,8391,2)
(5703,1972,2)
(4183,8065,2)
(8668,3781,2)
(7598,4388,2)
(8830,2344,2)
(619,7973,2)
(2843,706,2)
(5326,799,2)
(7029,3758,2)
(6315,6479,2)
(2627,5204,2)
(6417,2403,2)
(2827,7514,2)
(3287,3814,2)
(4503,7760,2)
(4051,2363,2)
(1415,489,2)
(4403,1972,2)
(6161,5089,2)
(2926,2895,2)
(617,8391,2)
(1557,6155,2)
(275,3488,2)
(749,2058,2)
(4792,6469,2)
(1972,6431,2)
(6163,611,2)
(955,2596,2)
(2203,2043,2)
(5069,8521,2)
(6448,6804,2)
(5164,7940,2)
(2652,4435,2)
-----------------------------------
(0,iaxs[fr->callno]->addr)
(1,callno)
(2,iaxs[fr->callno])
(3,fr)
(4,variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL)
(5,fr->callno)
(6,callno)
(7,if (iaxs[fr->callno]->voiceformat > 0)
(8,addr)
(9,*varlist)
(10,)
(11,iaxs[fr->callno])
(12,ies.vars)
(13,ies)
(14,&iaxsl[fr->callno])
(15,subclass)
(16,presentation)
(17,iaxs)
(18,ast_variables_destroy(ies.vars)
(19,(f.frametype == AST_FRAME_IAX)
(20,iaxs[fr->callno]->bridgecallno)
(21,)
(22,break;)
(23,iaxs)
(24,af)
(25,fr->callno)
(26,callno)
(27,if (variablestore && varlist)
(28,&ies)
(29,if (iaxs[fr->callno]->owner)
(30,x)
(31,if (f.frametype == AST_FRAME_TEXT && thread->buf[res - 1] != \'\\0\')
(32,0)
(33,callno)
(34,iaxs[fr->callno]->last)
(35,ied1)
(36,iaxs)
(37,name)
(38,state)
(39,ast_var_assign(var->name, var->value)
(40,f.subclass)
(41,using_prefs)
(42,tmp)
(43,AST_LIST_INSERT_TAIL(varlist, newvar, entries)
(44,pref)
(45,fr->callno)
(46,iaxs[fr->callno]->owner)
(47,fr)
(48,subclass)
(49,1)
(50,connected.id.name)
(51,fh->oseqno)
(52,IAX_IE_CAUSECODE)
(53,f.subclass.integer != IAX_COMMAND_PONG)
(54,iaxs[fr->callno])
(55,fr)
(56,iaxs)
(57,0)
(58,id)
(59,fr)
(60,NULL)
(61,0xFFFF0000L)
(62,owner)
(63,ies)
(64,fr)
(65,iaxs)
(66,ast_datastore_free(variablestore)
(67,sin.sin_addr)
(68,iaxsl)
(69,iseqno)
(70,iaxs)
(71,iaxs)
(72,peer->pokeexpire == -1)
(73,f.subclass)
(74,context)
(75,peerformat)
(76,iaxsl)
(77,pokefreqnotok)
(78,fr)
(79,f.subclass)
(80,context)
(81,)
(82,(f.subclass.integer != IAX_COMMAND_TXACC)
(83,iaxs[fr->callno]->owner)
(84,callno)
(85,iaxs[fr->callno])
(86,iaxs)
(87,f.data.ptr)
(88,iaxs[fr->callno])
(89,ast_log(LOG_WARNING, "midget packet received (%d of %d min)
(90,historicms)
(91,!iaxs[fr->callno])
(92,ast_format_to_old_bitfield(&f.subclass.format)
(93,0)
(94,using_prefs)
(95,iaxs[fr->callno]->transferring = 0)
(96,fr)
(97,fr)
(98,AST_CAUSE_BEARERCAPABILITY_NOTAVAIL)
(99,sizeof(*fr)
(100,fr->callno)
(101,fr->callno)
(102,fh->csub == IAX_COMMAND_REGREJ\n\\n\\t\\t\\t|| fh->csub == IAX_COMMAND_TXREJ)
(103,)
(104,cause_code->code)
(105,f.data.ptr = NULL)
(106,sin)
(107,*cause_code)
(108,pref = iaxs[fr->callno]->prefs)
(109,iax2_getformatname(iaxs[fr->callno]->peerformat)
(110,owner)
(111,iaxs[fr->callno])
(112,owner)
(113,callno)
(114,iaxs[fr->callno]->state)
(115,fr->callno = find_callno(ntohs(mh->callno)
(116,sin.sin_addr)
(117,fr)
(118,pbx_builtin_setvar_helper(bridged_chan, "BLINDTRANSFER", ast_channel_name(owner)
(119,fr->callno)
(120,integer)
(121,fr->callno)
(122,*prev = NULL)
(123,iaxs[fr->callno]->owner)
(124,ast_debug(1, "I have IAX variables, but they were not processed\\n")
(125,inheritance)
(126,integer)
(127,1)
(128,if (ast_format_to_old_bitfield(&f.subclass.format)
(129,"disabled")
(130,f)
(131,iaxdebug)
(132,fr)
(133,integer)
(134,!iaxs[fr->callno])
(135,-1)
(136,historicms)
(137,addr)
(138,vars)
(139,iaxs)
(140,callno)
(141,callno)
(142,calltokendata)
(143,iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
(144,varlist = ast_calloc(1, sizeof(*varlist)
(145,"No best format in %s???\\n")
(146,decrypted)
(147,AST_DEVICE_NOT_INUSE)
(148,fr->cacheable)
(149,)
(150,ast_strlen_zero(iaxs[fr->callno]->secret)
(151,var->value)
(152,*mh)
(153,format)
(154,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(155,fr->iseqno)
(156,LOG_NOTICE)
(157,fr)
(158,fr->callno)
(159,iaxs[fr->callno])
(160,fh)
(161,fr->callno)
(162,ies)
(163,f.subclass.integer)
(164,&iaxs[fr->callno]->state)
(165,fr)
(166,called_number)
(167,(0 + peer->historicms)
(168,varlist)
(169,)
(170,fr->callno)
(171,ast_channel_hangupcause_hash_set(iaxs[fr->callno]->owner, cause_code, data_size)
(172,"Cancelling transmission of packet %d\\n")
(173,iaxs)
(174,fr)
(175,thread)
(176,sizeof(tmp1)
(177,send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied1.buf, ied1.pos, -1)
(178,peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_peer_s, peer_ref(peer)
(179,sizeof(ied0)
(180,f)
(181,sizeof(ied1)
(182,0)
(183,iaxs)
(184,pokeexpire)
(185,ies)
(186,inkeys)
(187,causecode)
(188,if ((ast_strlen_zero(iaxs[fr->callno]->secret)
(189,iaxs[fr->callno])
(190,ast_free(prev)
(191,iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0)
(192,fr)
(193,iaxs)
(194,if (ast_test_flag64(iaxs[fr->callno], IAX_IMMEDIATE)
(195,ies)
(196,id)
(197,fr->callno)
(198,AST_FRAME_IAX)
(199,tmp)
(200,"IAX2 %s(%d)
(201,callno)
(202,cause_code = ast_alloca(data_size)
(203,pingtime)
(204,IAX_QUELCH)
(205,thread->buf + sizeof(struct ast_iax2_full_hdr)
(206,owner)
(207,ast_debug(1, "Ooh, video format changed to %s\\n", ast_getformatname(&f.subclass.format)
(208,ast_test_flag64(iaxs[fr->callno], IAX_IMMEDIATE)
(209,mount_callid)
(210,break;)
(211,iaxsl[fr->callno])
(212,fr->callno)
(213,iaxs[fr->callno]->rprefs)
(214,stop_stuff(iaxs[fr->callno]->bridgecallno)
(215,peerformat)
(216,fr)
(217,scallno)
(218,exists = ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num)
(219,fr->callno)
(220,varlist)
(221,)
(222,ied0)
(223,IAX_STATE_AUTHENTICATED)
(224,for (var = ies.vars; var; var = var->next)
(225,exists)
(226,iaxdebug && iaxs[fr->callno])
(227,fr)
(228,registry_rerequest(&ies, fr->callno, &sin)
(229,LOG_NOTICE)
(230,)
(231,callno)
(232,iseqno)
(233,)
(234,iaxs)
(235,format)
(236,fr)
(237,"reqonly")
(238,LOG_WARNING)
(239,"mine")
(240,ntohs(mh->callno)
(241,manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\\r\\nPeer: IAX2/%s\\r\\nPeerStatus: Lagged\\r\\nTime: %d\\r\\n", peer->name, iaxs[fr->callno]->pingtime)
(242,VERBOSE_PREFIX_4)
(243,iaxsl)
(244,IAX_COMMAND_ACCEPT)
(245,&ied1)
(246,callno)
(247,NULL)
(248,fr->callno)
(249,csub)
(250,&iaxs[fr->callno]->state)
(251,vars)
(252,empty[32]="")
(253,f.subclass.format)
(254,"Immediately destroying %d, having received hangup\\n")
(255,&ied1)
(256,peer)
(257,!inaddrcmp(&sin, &iaxs[fr->callno]->addr)
(258,iaxs[fr->callno])
(259,callno)
(260,peerformat)
(261,sin)
(262,ast_variables_destroy(ies.vars)
(263,videoformat)
(264,ast_log(LOG_WARNING, "Rejecting packet from \'%s.%d\' that is flagged as a video frame but is too short\\n", ast_inet_ntoa(sin.sin_addr)
(265,context)
(266,ied1)
(267,return 1;)
(268,peer->maxms)
(269,ntohs(mh->callno)
(270,!ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->chosenformat, NULL)
(271,frametype)
(272,ies.vars)
(273,f)
(274,iaxs[fr->callno]->lag)
(275,fr)
(276,iaxs)
(277,iaxs[fr->callno]->capability)
(278,c)
(279,IAX_AUTH_MD5)
(280,iaxs[fr->callno]->capability)
(281,LOG_ERROR)
(282,iaxs)
(283,f.subclass.format)
(284,iaxs[fr->callno]->iseqno != fr->oseqno)
(285,iaxs)
(286,frame_queue[fr->callno])
(287,historicms)
(288,fr)
(289,merge_encryption(iaxs[fr->callno],ies.encmethods)
(290,f)
(291,fr)
(292,f.subclass.integer != IAX_COMMAND_ACK)
(293,callno)
(294,peer)
(295,ast_variables_destroy(ies.vars)
(296,tmp1)
(297,check_dcallno)
(298,first_iax_message)
(299,f.subclass.integer)
(300,(f.subclass.integer != IAX_COMMAND_INVAL)
(301,fh->scallno)
(302,f)
(303,res)
(304,IAX_IE_CAUSE)
(305,~IAX_FLAG_RETRANS)
(306,variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL)
(307,mh)
(308,iaxs)
(309,fr->callno)
(310,f)
(311,format)
(312,bridgecallno)
(313,3)
(314,iaxsl[fr->callno])
(315,iaxsl)
(316,case IAX_COMMAND_AUTHREQ:)
(317,callno)
(318,callno)
(319,fr)
(320,fr)
(321,callno)
(322,"disabled")
(323,owner)
(324,iaxs[fr->callno]->owner)
(325,sizeof(caller_pref_buf)
(326,fr)
(327,fr)
(328,if (iaxs[fr->callno] && iaxs[fr->callno]->owner)
(329,fr)
(330,iaxs[fr->callno]->peerformat)
(331,ies.cause)
(332,if (authdebug)
(333,data_size - sizeof(*cause_code)
(334,ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE)
(335,fr)
(336,callno)
(337,callno)
(338,!inaddrcmp(&sin, &iaxs[fr->callno]->addr)
(339,fr->callno)
(340,fr->callno)
(341,tmpfmt)
(342,if (iaxdebug)
(343,newvar)
(344,bridgecallno)
(345,fr->callno)
(346,callno)
(347,)
(348,ies.cause)
(349,iaxs[fr->callno]->owner)
(350,memset(&pref, 0, sizeof(pref)
(351,iaxs[fr->callno]->peercallno)
(352,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(353,fr->callno)
(354,fr)
(355,if (var)
(356,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(357,callno)
(358,fr->callno)
(359,ast_channel_unref(bridged_chan)
(360,ntohs(mh->callno)
(361,callno)
(362,iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_MEDIA)
(363,iaxs)
(364,fr)
(365,ied0.pos)
(366,vars)
(367,0)
(368,fr)
(369,ies)
(370,id)
(371,peer->name)
(372,exten)
(373,iaxs[fr->callno]->transferring)
(374,if ((f.frametype != AST_FRAME_IAX)
(375,fr)
(376,)
(377,iaxs[fr->callno]->owner)
(378,(struct ast_iax2_video_hdr *)
(379,thread->buf)
(380,fr)
(381,1)
(382,id)
(383,iaxs)
(384,peerformat)
(385,thread->buf[res - 1] = \'\\0\')
(386,)
(387,iax2_getformatname_multiple(tmp2, sizeof(tmp2)
(388,subclass)
(389,callno)
(390,&iaxs[fr->callno]->transfer)
(391,fr->ts)
(392,iaxs[fr->callno]->cid_num)
(393,f.subclass)
(394,AST_FRAME_VIDEO)
(395,f)
(396,ast_calloc(1, sizeof(*varlist)
(397,subclass)
(398,fr)
(399,fr)
(400,callno)
(401,callno)
(402,f.frametype)
(403,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)
(404,bridgecallno)
(405,thread->iofd)
(406,buf)
(407,last)
(408,!ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num)
(409,calc_timestamp(iaxs[fr->callno], 0, &f)
(410,variablestore && varlist)
(411,AST_FRAME_VIDEO)
(412,sin.sin_addr)
(413,fr->callno)
(414,3)
(415,!(c = ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->peerformat, NULL)
(416,fr->callno)
(417,iaxs)
(418,"Call on %s is already up, can\'t start on it\\n")
(419,"Rejected connect attempt.  No secret present while force encrypt enabled.\\n")
(420,"disabled")
(421,callno)
(422,orignative)
(423,callno)
(424,fr->ts)
(425,fr->callno)
(426,outkey)
(427,case IAX_COMMAND_DIAL:)
(428,peerformat)
(429,ies.called_number)
(430,varlist)
(431,switch(f.subclass.integer)
(432,callno)
(433,1)
(434,integer)
(435,NULL)
(436,fr)
(437,fr->callno)
(438,ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE)
(439,if (f.datalen)
(440,fr)
(441,IAX_COMMAND_REJECT)
(442,callno)
(443,integer)
(444,iaxs[fr->callno])
(445,fr)
(446,&sin)
(447,sizeof(tmp2)
(448,ntohs(mh->callno)
(449,iseqno)
(450,fr)
(451,LOG_NOTICE)
(452,vars)
(453,!ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
(454,fr)
(455,IAX_COMMAND_ACK)
(456,)
(457,iaxs[fr->callno])
(458,for (var = ies.vars; var && var->next; var = var->next)
(459,iaxs[fr->callno])
(460,3)
(461,ast_party_connected_line_free(&connected)
(462,f.frametype == AST_FRAME_VOICE)
(463,fr->callno)
(464,fr)
(465,*varlist)
(466,dp->flags & CACHE_FLAG_TRANSMITTED)
(467,voiceformat)
(468,fr)
(469,)
(470,IAX_STATE_TBD)
(471,chosenformat)
(472,csub)
(473,fr->callno)
(474,ast_debug(1, "Received out of order packet... (type=%d, subclass %d, ts = %d, last = %d)
(475,ied0)
(476,&iaxsl[call_to_destroy])
(477,fr->callno)
(478,sizeof(ies)
(479,id)
(480,0)
(481,"TBD")
(482,fr->callno)
(483,fr->outoforder = 0)
(484,&ied0)
(485,connected)
(486,AST_FRAME_VIDEO)
(487,)
(488,f)
(489,varlist = ast_calloc(1, sizeof(*varlist)
(490,if (iaxdebug && iaxs[fr->callno])
(491,f.src = "IAX2")
(492,iaxs)
(493,f)
(494,if (iaxs[fr->callno]->bridgecallno)
(495,f)
(496,)
(497,ast_mutex_unlock(&iaxsl[fr->callno])
(498,state)
(499,ast_debug(1, "Peer %s lag measured as %dms\\n",\n\\n\\t\\t\\t\\t\\t\\t\\tast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr)
(500,0)
(501,fr)
(502,peer->pokeexpire)
(503,format)
(504,iaxs[fr->callno]->owner)
(505,)
(506,iaxs[fr->callno]->inkeys)
(507,f.subclass.integer != IAX_COMMAND_INVAL)
(508,ied0)
(509,vars)
(510,f)
(511,NULL)
(512,iaxs[fr->callno]->peercapability)
(513,subclass)
(514,fr->callno)
(515,iaxs[fr->callno])
(516,prev)
(517,!ast_strlen_zero(moh_suggest)
(518,fr)
(519,ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested \'%s\' incompatible with our capability \'%s\'.\\n",\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tast_inet_ntoa(sin.sin_addr)
(520,iaxs[fr->callno])
(521,callno)
(522,frametype)
(523,fr->callno)
(524,iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno)
(525,id)
(526,ies)
(527,iaxs)
(528,fr->callno)
(529,iaxs[fr->callno])
(530,(f.subclass.integer != IAX_COMMAND_TXACC)
(531,NULL)
(532,callno)
(533,iax_pvt_callid_new(fr->callno)
(534,iax2_poke_peer_s)
(535,&sin)
(536,f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_ACK && dcallno == 1)
(537,fr)
(538,(iaxs[fr->callno]->last & 0xFFFF0000L)
(539,fr->callno)
(540,f.subclass)
(541,iax2_lock_owner(fr->callno)
(542,iaxs[fr->callno])
(543,&f)
(544,)
(545,fr)
(546,iaxs[fr->callno]->bridgecallno)
(547,fr)
(548,iaxs[fr->callno])
(549,ast_free(prev)
(550,ast_debug(1, "I can haz iaxvars, but they is no good.  :-(\\n")
(551,callno)
(552,ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD)
(553,f.subclass.format.id == AST_FORMAT_SLINEAR)
(554,datalen)
(555,)
(556,)
(557,fr)
(558,iaxs)
(559,fh->csub == IAX_COMMAND_REGREJ)
(560,format)
(561,res)
(562,fr->callno)
(563,iaxs)
(564,fr)
(565,-1)
(566,default:)
(567,connected.id.name.presentation = iaxs[fr->callno]->calling_pres)
(568,"Unable to negotiate codec")
(569,&ies)
(570,&f)
(571,vars)
(572,fr->callno)
(573,send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
(574,iaxs[fr->callno])
(575,authdebug)
(576,ts)
(577,f.frametype)
(578,fr->callno)
(579,fr->callno)
(580,iaxs[fr->callno]->owner)
(581,set_hangup_source_and_cause(fr->callno, ies.causecode)
(582,variablestore)
(583,exists)
(584,iaxs[fr->callno]->exten)
(585,fr)
(586,ies)
(587,ied0)
(588,iaxs[fr->callno]->peercapability)
(589,1)
(590,strcpy(caller_pref_buf,"disabled")
(591,NULL)
(592,fr->callno)
(593,fr)
(594,sizeof(tmp)
(595,fr->ts)
(596,transferring)
(597,fr)
(598,ast_alloca(data_size)
(599,fr)
(600,fr)
(601,ies)
(602,callno)
(603,callno)
(604,VERBOSE_PREFIX_4)
(605,iseqno)
(606,f)
(607,iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION)
(608,"")
(609,ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
(610,fr->callno)
(611,f.frametype == AST_FRAME_IAX)
(612,iaxs)
(613,ies)
(614,iaxs[fr->callno])
(615,if (authenticate_reply(iaxs[fr->callno], &iaxs[fr->callno]->addr, &ies, iaxs[fr->callno]->secret, iaxs[fr->callno]->outkey)
(616,iaxs[fr->callno])
(617,fr->callno)
(618,iaxs[fr->callno]->owner)
(619,f)
(620,fr)
(621,if (variablestore)
(622,pingtime)
(623,tmp3)
(624,iaxs[fr->callno])
(625,if (!(dp->flags & CACHE_FLAG_TRANSMITTED)
(626,peer->callno = 0)
(627,iaxs)
(628,peer)
(629,)
(630,f)
(631,fd)
(632,iaxs)
(633,ast_datastore_free(variablestore)
(634,pref)
(635,callno)
(636,S_OR(moh_suggest, NULL)
(637,&f)
(638,)
(639,)
(640,sizeof(tmp)
(641,owner)
(642,integer)
(643,data)
(644,fr->callno)
(645,if (iaxs[fr->callno] && ((mount_callid = iax_pvt_callid_get(fr->callno)
(646,var = var->next)
(647,decrypted)
(648,exten)
(649,value)
(650,AST_FRAME_IAX)
(651,iaxs[fr->callno]->context)
(652,iaxs)
(653,1)
(654,subclass)
(655,fr->callno)
(656,sin)
(657,vars)
(658,callno)
(659,fr)
(660,f.frametype)
(661,iaxs[fr->callno])
(662,ts)
(663,iaxs)
(664,fr)
(665,(int)
(666,cause_code)
(667,fr)
(668,pos)
(669,iaxs[fr->callno]->hold_signaling)
(670,AST_LIST_INSERT_TAIL(varlist, newvar, entries)
(671,iaxs[fr->callno])
(672,data)
(673,ies)
(674,ied1)
(675,iaxs[fr->callno])
(676,&iaxsl[fr->callno])
(677,callno)
(678,bridgecallno)
(679,variablestore)
(680,iaxs[fr->callno]->videoformat)
(681,iaxs)
(682,thread->buf + sizeof(*mh)
(683,callno)
(684,called_number)
(685,"<Unknown>")
(686,iaxs)
(687,callno)
(688,fr)
(689,ast_strlen_zero(iaxs[fr->callno]->secret)
(690,fr)
(691,iaxs[fr->callno]->transferring)
(692,callno)
(693,LOG_ERROR)
(694,fr)
(695,serviceident)
(696,0)
(697,iaxs[fr->callno])
(698,ast_format_from_old_bitfield(&f.subclass.format, iaxs[fr->callno]->voiceformat)
(699,callno)
(700,f.subclass.integer)
(701,&iaxs[fr->callno]->state)
(702,iaxs)
(703,fr)
(704,ast_format_cap_copy(native, orignative)
(705,if (ies.causecode > 9)
(706,!format)
(707,AST_FRAME_CONTROL)
(708,f)
(709,0)
(710,"Ooh, video format changed to %s\\n")
(711,iaxs[fr->callno])
(712,send_signaling(iaxs[fr->callno])
(713,iaxs[fr->callno])
(714,0)
(715,callno)
(716,iax2_getformatname_multiple(tmp1, sizeof(tmp1)
(717,ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner)
(718,send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK,\n\\n\\t\\t\\t\\t\\t\\t       fr->ts, NULL, 0, fr->iseqno)
(719,fr->callno)
(720,)
(721,NULL)
(722,fr)
(723,if (!iaxs[fr->callno])
(724,fr->ts)
(725,iaxs)
(726,!iaxs[fr->callno])
(727,fr->callno)
(728,if (f.frametype == AST_FRAME_VOICE)
(729,if (fr->callno > 0)
(730,fr)
(731,context)
(732,)
(733,fr)
(734,fr)
(735,0)
(736,IAX_COMMAND_ACK)
(737,cid_num)
(738,fr)
(739,ies.called_number)
(740,&ied1)
(741,iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format)
(742,iaxs)
(743,iaxs[fr->callno]->reg)
(744,if (authdebug)
(745,fr)
(746,iaxs[fr->callno])
(747,f.frametype != AST_FRAME_IAX)
(748,ies)
(749,AST_FRAME_IAX)
(750,iaxs[fr->callno]->peerformat)
(751,iaxsl)
(752,fr)
(753,connected.id.name.str)
(754,mohsuggest)
(755,x)
(756,peercapability)
(757,if (ies.format)
(758,if (!format)
(759,var)
(760,NULL)
(761,iaxs)
(762,IAX_COMMAND_TXMEDIA)
(763,iaxs)
(764,iaxs)
(765,datalen)
(766,"Call rejected by %s: %s\\n")
(767,callno)
(768,fr->callno)
(769,iaxsl[fr->callno])
(770,ies)
(771,peer->smoothing)
(772,fr)
(773,0)
(774,fr->callno)
(775,fr->callno)
(776,fr)
(777,struct iax2_thread *thread)
(778,&iaxs[fr->callno]->state)
(779,ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0)
(780,fr->callno)
(781,iaxs[fr->callno]->state)
(782,LOG_NOTICE)
(783,IAX_COMMAND_REGREQ)
(784,f.datalen)
(785,f.datalen)
(786,iaxs[fr->callno]->bridgecallno)
(787,dcx)
(788,callno)
(789,fh)
(790,LOG_ERROR)
(791,)
(792,iaxs)
(793,sizeof(tmp2)
(794,iax2_getformatname_multiple(tmp2, sizeof(tmp2)
(795,fr->callno)
(796,iaxs[fr->callno]->peerformat)
(797,callno)
(798,iaxs[fr->callno]->transferring)
(799,!iaxs[fr->callno])
(800,fr->callno)
(801,exists)
(802,iaxs)
(803,fr)
(804,callno)
(805,ied1)
(806,iaxs)
(807,iaxs[fr->callno]->peerformat = iaxs[fr->callno]->capability)
(808,capability)
(809,if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)
(810,ies)
(811,connected.id.name.presentation)
(812,)
(813,sizeof(*varlist)
(814,subclass)
(815,tmp1)
(816,subclass)
(817,case IAX_COMMAND_UNSUPPORT:)
(818,if (prev)
(819,iaxs)
(820,callno)
(821,case IAX_COMMAND_TXREJ:)
(822,cur = AST_LIST_LAST(&frame_queue[fr->callno])
(823,f.subclass.integer == AST_CONTROL_CONNECTED_LINE)
(824,fr->callno)
(825,ied1)
(826,callno)
(827,fr)
(828,ast_log(LOG_WARNING, "Registry error\\n")
(829,res - sizeof(*vh)
(830,iaxs)
(831,callno)
(832,ied0)
(833,iaxs)
(834,IAX_CODEC_NOCAP)
(835,sin.sin_addr)
(836,using_prefs = "caller")
(837,f)
(838,iaxs[iaxs[fr->callno]->bridgecallno])
(839,iaxs)
(840,res)
(841,fr)
(842,callno)
(843,fr)
(844,if (f.datalen < 0)
(845,iaxs[fr->callno])
(846,ies.musiconhold)
(847,iaxs[fr->callno])
(848,ies.username ? ies.username : "<unknown>")
(849,connected)
(850,entries)
(851,varlist)
(852,iaxs)
(853,ast_free(prev)
(854,res)
(855,*mh)
(856,&sin)
(857,fr)
(858,iaxs)
(859,iaxs[fr->callno]->transferring)
(860,ied0.pos)
(861,ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
(862,fr->ts)
(863,iaxs)
(864,)
(865,ntohs(fh->dcallno)
(866,f.src)
(867,variablestore)
(868,iaxs[fr->callno]->owner)
(869,iaxs)
(870,"Peer %s lag measured as %dms\\n")
(871,iaxs[fr->callno])
(872,-1)
(873,iaxs[fr->callno])
(874,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(875,sizeof(ied1)
(876,iaxs[fr->callno])
(877,fr)
(878,callno)
(879,fh)
(880,callno)
(881,ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf)
(882,iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability)
(883,iaxs[fr->callno])
(884,pingtime)
(885,&f.subclass.format)
(886,fd)
(887,peer)
(888,IAX_COMMAND_TXACC)
(889,"Registry")
(890,)
(891,sizeof(*fr)
(892,pref)
(893,iaxs)
(894,if (iaxs[fr->callno]->peercallno)
(895,fr->callno)
(896,0)
(897,fr->callno)
(898,callno)
(899,iaxs)
(900,iaxs[fr->callno])
(901,iaxs[fr->callno])
(902,fr->callno)
(903,fr->callno)
(904,iaxs[fr->callno]->owner && fh->type == AST_FRAME_IAX &&\n\\n\\t\\t\\t(fh->csub == IAX_COMMAND_HANGUP\n\\n\\t\\t\\t|| fh->csub == IAX_COMMAND_REJECT\n\\n\\t\\t\\t|| fh->csub == IAX_COMMAND_REGREJ\n\\n\\t\\t\\t|| fh->csub == IAX_COMMAND_TXREJ)
(905,AST_CAUSE_NO_ROUTE_DESTINATION)
(906,iseqno)
(907,callno)
(908,&iaxsl[fr->callno])
(909,fr->callno)
(910,callno)
(911,iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_RELEASED)
(912,exists)
(913,fr)
(914,f.subclass.integer)
(915,iaxs)
(916,iaxs[iaxs[fr->callno]->bridgecallno]->owner)
(917,ies)
(918,iaxs[fr->callno])
(919,"No best format in \'%s\'???\\n")
(920,sizeof(tmp)
(921,fr->callno)
(922,IAX_FLAG_FULL)
(923,callno)
(924,f.subclass.format)
(925,)
(926,fr->callno)
(927,ast_channel_ref(owner)
(928,ied0)
(929,iaxs[fr->callno]->videoformat)
(930,fr->callno)
(931,called_number)
(932,f.subclass)
(933,iaxs[fr->callno]->context)
(934,chosenformat)
(935,)
(936,AST_FRAME_VOICE)
(937,variablestore)
(938,1)
(939,cur->retries = -1)
(940,iaxs)
(941,1)
(942,iaxs[fr->callno])
(943,NULL)
(944,ied1.buf)
(945,iaxs)
(946,ied1)
(947,ies)
(948,callno)
(949,sin_addr)
(950,fr)
(951,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)
(952,fr->ts)
(953,fr)
(954,if (ast_strlen_zero(iaxs[fr->callno]->secret)
(955,ies)
(956,f)
(957,dcallno)
(958,IAX_COMMAND_REGREJ)
(959,if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_NEW)
(960,iaxs)
(961,fr)
(962,buf)
(963,format)
(964,fr)
(965,iaxs[fr->callno]->peerformat)
(966,f.subclass.integer)
(967,iaxs)
(968,f.subclass)
(969,fr)
(970,cause)
(971,dcallno)
(972,iaxs[fr->callno])
(973,using_prefs = "mine")
(974,iaxs)
(975,iosin)
(976,causecode)
(977,iaxs[fr->callno])
(978,sin)
(979,callno)
(980,iax2_getformatname_multiple(tmp3, sizeof(tmp3)
(981,(f.subclass.integer != IAX_COMMAND_INVAL)
(982,if (iaxdebug)
(983,callno)
(984,if (!iaxs[fr->callno]->owner)
(985,1)
(986,f.subclass)
(987,flags)
(988,f.subclass.format)
(989,fr->callno)
(990,callno)
(991,fh)
(992,duped_fr)
(993,frametype)
(994,f.subclass.integer == IAX_COMMAND_ACK)
(995,ast_channel_readformat(iaxs[fr->callno]->owner)
(996,connected.id)
(997,fr)
(998,fr)
(999,fr)
(1000,iaxs)
(1001,fr->callno)
(1002,iaxdebug)
(1003,pref)
(1004,callno)
(1005,iax2_lock_owner(fr->callno)
(1006,callno)
(1007,ies)
(1008,iaxs[fr->callno]->owner)
(1009,presentation)
(1010,peercapability)
(1011,f.subclass)
(1012,ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\\n")
(1013,context = ast_strdupa(iaxs[fr->callno]->context)
(1014,ts)
(1015,NULL)
(1016,native)
(1017,socket_process_meta(res, meta, &sin, fd, fr)
(1018,IAX_CODEC_NOCAP)
(1019,peer)
(1020,sizeof(ied1)
(1021,tmp2)
(1022,fr->callno)
(1023,test_resync)
(1024,IAX_FLAG_FULL)
(1025,tmp3)
(1026,AST_LIST_INSERT_TAIL(varlist, newvar, entries)
(1027,iaxs)
(1028,iaxs)
(1029,fr->iseqno)
(1030,case IAX_COMMAND_LAGRP:)
(1031,fr)
(1032,pokeexpire)
(1033,historicms)
(1034,iaxs)
(1035,buf_len)
(1036,buf)
(1037,fr)
(1038,iaxs[fr->callno])
(1039,send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
(1040,iaxs[fr->callno]->owner)
(1041,ast_log(LOG_WARNING, "Rejecting packet from \'%s.%d\' that is flagged as a full frame but is too short\\n", ast_inet_ntoa(sin.sin_addr)
(1042,iaxs[fr->callno]->capability)
(1043,iaxs[fr->callno])
(1044,fr->callno)
(1045,fr->callno)
(1046,ast_channel_nativeformats(iaxs[fr->callno]->owner)
(1047,fr->callno)
(1048,f.frametype = AST_FRAME_VIDEO)
(1049,&iaxs[fr->callno]->state)
(1050,iaxs)
(1051,if (delayreject)
(1052,fr->callno)
(1053,iseqno)
(1054,fr->callno)
(1055,cur->oseqno)
(1056,exten)
(1057,f)
(1058,callno)
(1059,ied1)
(1060,ied0)
(1061,fr->callno)
(1062,mount_callid = iax_pvt_callid_get(fr->callno)
(1063,(ntohs(fh->dcallno)
(1064,ast_mutex_lock(&iaxsl[fr->callno])
(1065,fr->callno)
(1066,frametype)
(1067,sin_family)
(1068,1)
(1069,thread->buf)
(1070,ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)
(1071,callno)
(1072,mh)
(1073,iaxs)
(1074,res)
(1075,called_number)
(1076,sin.sin_addr)
(1077,send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
(1078,&sin)
(1079,fr->callno)
(1080,)
(1081,callno)
(1082,fr->callno)
(1083,varlist)
(1084,transferring)
(1085,fr->callno)
(1086,peer->historicms)
(1087,thread->buf)
(1088,frametype)
(1089,iaxs)
(1090,fr)
(1091,1)
(1092,ast_channel_name(iaxs[fr->callno]->owner)
(1093,)
(1094,ies.username)
(1095,fh)
(1096,sizeof(*cause_code)
(1097,IAX_CODEC_USER_FIRST)
(1098,callno)
(1099,ied1.buf)
(1100,fr)
(1101,IAX_COMMAND_INVAL)
(1102,variablestore)
(1103,fr->callno)
(1104,f.subclass.integer == IAX_COMMAND_REGREL)
(1105,iaxs[fr->callno])
(1106,ied0)
(1107,f.subclass)
(1108,sizeof(tmp2)
(1109,iaxs)
(1110,iaxs[fr->callno]->peercapability)
(1111,fr->callno)
(1112,callno)
(1113,IAX_CODEC_NOCAP)
(1114,ies.calltoken && ies.calltokendata)
(1115,c)
(1116,iax2_destroy(fr->callno)
(1117,thread->buf + sizeof(*vh)
(1118,owner)
(1119,1)
(1120,)
(1121,ast_verb(3, "Accepting UNAUTHENTICATED call from %s:\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t"%srequested format = %s,\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t"%srequested prefs = %s,\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t"%sactual format = %s,\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t"%shost prefs = %s,\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t"%spriority = %s\\n",\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tast_inet_ntoa(sin.sin_addr)
(1122,fr->callno)
(1123,fr)
(1124,fr)
(1125,memset(&ied0, 0, sizeof(ied0)
(1126,memset(&sin, 0, sizeof(sin)
(1127,9)
(1128,iaxs[fr->callno]->rprefs)
(1129,iaxs)
(1130,iaxs)
(1131,fr)
(1132,value)
(1133,1)
(1134,iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability)
(1135,iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec")
(1136,frametype)
(1137,callno)
(1138,fh->csub)
(1139,fr)
(1140,1)
(1141,callno)
(1142,fr)
(1143,variablestore)
(1144,iaxs[fr->callno])
(1145,iaxs[fr->callno])
(1146,subclass)
(1147,pos)
(1148,)
(1149,peer = iaxs[fr->callno]->peerpoke)
(1150,iaxs[fr->callno]->addr)
(1151,iax2_getformatname(iaxs[fr->callno]->peerformat)
(1152,fr->callno)
(1153,iaxs[iaxs[fr->callno]->bridgecallno])
(1154,callno)
(1155,f)
(1156,iaxs)
(1157,owner)
(1158,f.subclass.integer)
(1159,if (iaxcompat)
(1160,if (ast_test_flag64(iaxs[fr->callno], IAX_ENCRYPTED)
(1161,peer)
(1162,iaxs[fr->callno])
(1163,IAX_COMMAND_LAGRP)
(1164,IAX_COMMAND_LAGRQ)
(1165,f.subclass.integer == IAX_COMMAND_NEW)
(1166,fr->callno)
(1167,fr->callno)
(1168,fr->callno)
(1169,&ies)
(1170,if (fr->callno > 0)
(1171,f.subclass)
(1172,IAX_DEBUGDIGEST("Receiving", ies.challenge)
(1173,res < thread->buf_size)
(1174,fr)
(1175,sizeof(ied0)
(1176,fr)
(1177,fr->callno)
(1178,)
(1179,iaxs)
(1180,ies.format)
(1181,iaxs[fr->callno])
(1182,ied0)
(1183,exten)
(1184,iaxs[fr->callno]->exten)
(1185,tmp2)
(1186,ast_debug(1, "Ooh, voice format changed to \'%s\'\\n", ast_getformatname(&f.subclass.format)
(1187,iaxs)
(1188,sizeof(ied0)
(1189,ntohs(mh->ts)
(1190,ntohs(fh->dcallno)
(1191,format)
(1192,prev)
(1193,id)
(1194,TRANSFER_MBEGIN)
(1195,callno)
(1196,VERBOSE_PREFIX_4)
(1197,fr)
(1198,varlist)
(1199,iaxs[fr->callno]->oseqno == fr->iseqno)
(1200,state)
(1201,IAX_IE_IAX_UNKNOWN)
(1202,callno)
(1203,f.frametype)
(1204,prev = var)
(1205,bridged_chan)
(1206,ast_debug(1, "For call=%d, set last=%d\\n", fr->callno, fr->ts)
(1207,1)
(1208,fr->callno)
(1209,! (f.frametype == AST_FRAME_IAX &&\n\\n\\t\\t\\t\\t\\t\\t\\t\\t(f.subclass == IAX_COMMAND_NEW ||\n\\n\\t\\t\\t\\t\\t\\t\\t\\t f.subclass == IAX_COMMAND_AUTHREQ ||\n\\n\\t\\t\\t\\t\\t\\t\\t\\t f.subclass == IAX_COMMAND_ACCEPT ||\n\\n\\t\\t\\t\\t\\t\\t\\t\\t f.subclass == IAX_COMMAND_REJECT)
(1210,fr->callno)
(1211,fr)
(1212,peer->maxms)
(1213,fr->callno)
(1214,if (!newvar)
(1215,0)
(1216,)
(1217,f.subclass.integer)
(1218,callno)
(1219,iaxs)
(1220,ast_async_goto(bridged_chan, context, ies.called_number, 1)
(1221,iaxs[fr->callno]->addr)
(1222,f.subclass.integer)
(1223,iaxs[fr->callno])
(1224,ts)
(1225,memset(&ies, 0, sizeof(ies)
(1226,iaxs)
(1227,fr->callno)
(1228,"s")
(1229,context)
(1230,callno)
(1231,fr->callno)
(1232,transferring)
(1233,)
(1234,cur->transfer)
(1235,f.frametype == AST_FRAME_CONTROL && f.subclass.integer == AST_CONTROL_CONNECTED_LINE)
(1236,&thread->iosin)
(1237,rprefs)
(1238,fr->callno)
(1239,iaxs)
(1240,format)
(1241,fr->callno)
(1242,bridgecallno)
(1243,first_iax_message)
(1244,iaxs)
(1245,iaxs[fr->callno]->exten)
(1246,)
(1247,iaxs[fr->callno])
(1248,callno)
(1249,0)
(1250,peer->lastms)
(1251,NULL)
(1252,meta)
(1253,callno)
(1254,iaxs[fr->callno] && iaxs[fr->callno]->owner)
(1255,1)
(1256,callno)
(1257,fr)
(1258,var)
(1259,iaxs[fr->callno]->state)
(1260,ies.vars)
(1261,1)
(1262,ies.vars)
(1263,f)
(1264,sin)
(1265,iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
(1266,f.frametype)
(1267,format)
(1268,iaxs)
(1269,peer->historicms)
(1270,thread->buf[res++])
(1271,meta)
(1272,oseqno)
(1273,fr->callno)
(1274,data_size = sizeof(*cause_code)
(1275,fr)
(1276,strlen(moh_suggest)
(1277,callno)
(1278,)
(1279,sin)
(1280,fr->iseqno)
(1281,f)
(1282,fr->callno)
(1283,iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner)
(1284,ast_verb(3, "Format for call is %s\\n", ast_getformatname_multiple(tmp, sizeof(tmp)
(1285,EPERM)
(1286,f.subclass.integer != IAX_COMMAND_INVAL)
(1287,format)
(1288,)
(1289,ast_inet_ntoa(sin.sin_addr)
(1290,0)
(1291,callno)
(1292,fr)
(1293,ast_debug(1, "Really destroying %d, having been acked on final message\\n", call_to_destroy)
(1294,fr)
(1295,vars)
(1296,iaxs[fr->callno])
(1297,callno)
(1298,f.frametype != AST_FRAME_IAX)
(1299,peer->pokeexpire = -1)
(1300,iaxs)
(1301,fr)
(1302,IAX_CODEC_NOCAP)
(1303,iaxs[fr->callno])
(1304,iaxs[fr->callno]->bridgecallno)
(1305,iaxs[fr->callno])
(1306,((f.subclass.integer != IAX_COMMAND_ACK)
(1307,ts)
(1308,buf)
(1309,inheritance)
(1310,iaxs[fr->callno])
(1311,strcmp(iaxs[fr->callno]->exten, "TBD")
(1312,peer->historicms = (0 + peer->historicms)
(1313,iaxs)
(1314,1)
(1315,fh)
(1316,callno)
(1317,f)
(1318,if (!format)
(1319,iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
(1320,fr)
(1321,fr)
(1322,fr->callno)
(1323,if (authdebug)
(1324,iaxs[fr->callno]->peerformat)
(1325,LOG_WARNING)
(1326,fr->callno)
(1327,callno)
(1328,outoforder)
(1329,manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\\r\\nPeer: IAX2/%s\\r\\nPeerStatus: Reachable\\r\\nTime: %d\\r\\n", peer->name, iaxs[fr->callno]->pingtime)
(1330,if (iaxs[fr->callno])
(1331,iaxs[fr->callno])
(1332,peer)
(1333,iaxs)
(1334,fr)
(1335,callno)
(1336,ied0)
(1337,frametype)
(1338,~IAX_FLAG_FULL)
(1339,bridgecallno)
(1340,iaxs[fr->callno]->oseqno)
(1341,1)
(1342,if (!newvar)
(1343,callno)
(1344,ied0)
(1345,fr)
(1346,AST_FRAME_IAX)
(1347,iaxs[fr->callno])
(1348,iaxs[fr->callno])
(1349,fr->callno)
(1350,iaxs[fr->callno])
(1351,iaxs[fr->callno])
(1352,"Rejecting packet from \'%s.%d\' that is flagged as a full frame but is too short\\n")
(1353,IAX_TRUNK)
(1354,f.frametype)
(1355,callno)
(1356,)
(1357,iaxs[fr->callno])
(1358,"ChannelType: IAX2\\r\\nPeer: IAX2/%s\\r\\nPeerStatus: Reachable\\r\\nTime: %d\\r\\n")
(1359,iaxs)
(1360,iaxs[fr->callno])
(1361,&dpcache)
(1362,ied0)
(1363,fr->callno)
(1364,1)
(1365,iaxs[fr->callno]->rprefs)
(1366,ied0.pos)
(1367,ies.vars = NULL)
(1368,iaxs[fr->callno])
(1369,f.subclass.integer)
(1370,iaxs[fr->callno]->owner)
(1371,callno)
(1372,fr)
(1373,f.subclass)
(1374,iaxs)
(1375,fr)
(1376,iaxs[fr->callno])
(1377,callno)
(1378,AST_CAUSE_NO_ROUTE_DESTINATION)
(1379,ied0.pos)
(1380,fr->callno)
(1381,ied0)
(1382,&iaxsl[fr->callno])
(1383,pref)
(1384,0xFFFF8000L)
(1385,iaxs[fr->callno]->addr.sin_addr)
(1386,AST_FRAME_IAX)
(1387,fr->callno)
(1388,owner)
(1389,iaxs[fr->callno]->peercapability)
(1390,fr)
(1391,callno)
(1392,fr->callno)
(1393,AST_FRAME_IAX)
(1394,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(1395,sin)
(1396,iaxs[fr->callno] && ((mount_callid = iax_pvt_callid_get(fr->callno)
(1397,fh)
(1398,callno)
(1399,iaxs)
(1400,fr->callno)
(1401,f.subclass.integer == AST_CONTROL_CONGESTION)
(1402,\'\\0\')
(1403,f)
(1404,1)
(1405,fr->ts)
(1406,ast_log(LOG_NOTICE, "Host %s failed to authenticate as %s\\n", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr)
(1407,&ied0)
(1408,pokeexpire)
(1409,)
(1410,format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)
(1411,f.datalen = res - sizeof(struct ast_iax2_mini_hdr)
(1412,iaxs[fr->callno]->pingtime)
(1413,fr->callno)
(1414,fr)
(1415,return 1;)
(1416,f)
(1417,cause)
(1418,f.frametype)
(1419,iaxs[iaxs[fr->callno]->bridgecallno])
(1420,&sin)
(1421,presentation)
(1422,ast_strdupa(iaxs[fr->callno]->exten)
(1423,1)
(1424,ies)
(1425,prev)
(1426,fr)
(1427,ntohs(fh->dcallno)
(1428,1)
(1429,IAX_CODEC_USER_FIRST)
(1430,orignative = ast_format_cap_destroy(orignative)
(1431,&ies)
(1432,peer->historicms)
(1433,ied1)
(1434,callno)
(1435,send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1)
(1436,iseqno)
(1437,99)
(1438,fr->callno)
(1439,callno)
(1440,iseqno)
(1441,f)
(1442,if (authdebug)
(1443,0)
(1444,iaxs)
(1445,fr)
(1446,)
(1447,sizeof(tmp1)
(1448,ies.vars)
(1449,)
(1450,fr)
(1451,IAX_COMMAND_POKE)
(1452,fr->callno)
(1453,&ied1)
(1454,iaxs[fr->callno]->bridgecallno)
(1455,iaxs)
(1456,if (iaxs[fr->callno] && iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno)
(1457,callno)
(1458,(unsigned char)
(1459,authdebug)
(1460,pos)
(1461,iaxs[fr->callno])
(1462,fr->callno)
(1463,iaxdebug)
(1464,integer)
(1465,bridged_chan)
(1466,variablestore)
(1467,!iaxs[fr->callno])
(1468,sin.sin_port)
(1469,iaxs)
(1470,id)
(1471,f.subclass.integer)
(1472,var)
(1473,fr)
(1474,return 1;)
(1475,fr)
(1476,"disabled")
(1477,)
(1478,fr->callno)
(1479,ast_strlen_zero(iaxs[fr->callno]->secret)
(1480,x++)
(1481,af)
(1482,ies.vars)
(1483,iaxs)
(1484,iaxs[fr->callno]->authmethods)
(1485,iaxdebug)
(1486,peercapability)
(1487,0)
(1488,*fh = (struct ast_iax2_full_hdr *)
(1489,fr)
(1490,var)
(1491,iaxs[fr->callno])
(1492,"disabled")
(1493,ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)
(1494,if ((f.subclass.integer != IAX_COMMAND_ACK)
(1495,iaxsl)
(1496,0)
(1497,0)
(1498,break;)
(1499,if (authdebug)
(1500,iaxs[fr->callno])
(1501,ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner)
(1502,-1)
(1503,scallno)
(1504,subclass)
(1505,ast_mutex_lock(&iaxsl[call_to_destroy])
(1506,break;)
(1507,buf)
(1508,ptr)
(1509,iaxs[fr->callno]->owner && authdebug)
(1510,fr)
(1511,ast_strlen_zero(iaxs[fr->callno]->inkeys)
(1512,iaxs[fr->callno]->addr)
(1513,empty)
(1514,ast_free(varlist)
(1515,iaxs)
(1516,iaxs[fr->callno]->state)
(1517,)
(1518,videoformat)
(1519,exists)
(1520,callno)
(1521,var)
(1522,callno)
(1523,f.data)
(1524,minivid = 0)
(1525,ied0.pos)
(1526,iaxs[fr->callno])
(1527,IAX_COMMAND_REJECT)
(1528,prev)
(1529,callno)
(1530,send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACCEPT, 0, ied1.buf, ied1.pos, -1)
(1531,final)
(1532,NULL)
(1533,callno)
(1534,1)
(1535,iaxs[fr->callno]->secret)
(1536,callno)
(1537,if (f.subclass.integer == IAX_COMMAND_REGREL)
(1538,callno)
(1539,fr)
(1540,prev)
(1541,fr)
(1542,fr->callno)
(1543,ies)
(1544,iaxs[fr->callno]->peercapability)
(1545,connected)
(1546,iaxs[iaxs[fr->callno]->bridgecallno]->owner)
(1547,"No authority found")
(1548,iax2_variable_datastore_info)
(1549,peer)
(1550,TRANSFER_MEDIAPASS)
(1551,)
(1552,callno)
(1553,if (f.subclass.format.id != ast_format_id_from_old_bitfield(iaxs[fr->callno]->videoformat)
(1554,fr)
(1555,fr->callno)
(1556,0)
(1557,ied0)
(1558,if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
(1559,&iaxs[fr->callno]->prefs)
(1560,f.frametype == AST_FRAME_TEXT)
(1561,ies)
(1562,fr)
(1563,variablestore)
(1564,iaxs[fr->callno])
(1565,IAX_COMMAND_TXCNT)
(1566,if (authdebug)
(1567,fr->ts)
(1568,IAX_CODEC_NOCAP)
(1569,ied0)
(1570,ies)
(1571,f)
(1572,!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)
(1573,&ied1)
(1574,LOG_NOTICE)
(1575,sizeof(*varlist)
(1576,callno)
(1577,1)
(1578,AST_FRAME_IAX)
(1579,)
(1580,fr)
(1581,cur)
(1582,cid_num)
(1583,iaxs[fr->callno]->last < fr->ts &&\n\\n                            f.subclass.integer != IAX_COMMAND_ACK &&\n\\n                            f.subclass.integer != IAX_COMMAND_PONG &&\n\\n                            f.subclass.integer != IAX_COMMAND_LAGRP)
(1584,break;)
(1585,empty)
(1586,iaxs[fr->callno]->owner)
(1587,username)
(1588,for (var = ies.vars; var; var = var->next)
(1589,0)
(1590,fr)
(1591,iax2_queue_control_data(fr->callno, AST_CONTROL_HOLD, \n\\n\\t\\t\\t\\t\\t\\t\\t\\tS_OR(moh_suggest, NULL)
(1592,variablestore)
(1593,owner)
(1594,lastms)
(1595,callno)
(1596,)
(1597,iaxs[fr->callno]->reg->regstate = REG_STATE_REJECTED)
(1598,callno)
(1599,ast_inet_ntoa(sin.sin_addr)
(1600,iaxs[fr->callno])
(1601,fr->callno)
(1602,fr->callno)
(1603,ied0.pos)
(1604,fr)
(1605,f.subclass.integer)
(1606,)
(1607,ast_getformatname(&f.subclass.format)
(1608,iaxs)
(1609,fr)
(1610,peer)
(1611,ast_var_assign(var->name, var->value)
(1612,fr->callno)
(1613,iaxsl[fr->callno])
(1614,IAX_STATE_TBD)
(1615,data_size)
(1616,f.frametype)
(1617,iaxs)
(1618,fr)
(1619,!ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
(1620,if ((iaxs[fr->callno]->transferring == TRANSFER_BEGIN)
(1621,NULL)
(1622,integer)
(1623,iaxs[fr->callno])
(1624,integer)
(1625,cause)
(1626,AST_FRAME_IAX)
(1627,iaxs)
(1628,fr->callno)
(1629,var)
(1630,new_peercallno)
(1631,subclass)
(1632,f.subclass)
(1633,ast_log(LOG_WARNING, "Call on %s is already up, can\'t start on it\\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner)
(1634,fr)
(1635,f)
(1636,state)
(1637,((f.subclass.integer != IAX_COMMAND_TXCNT)
(1638,iaxs[fr->callno])
(1639,1)
(1640,&pref)
(1641,iaxs[fr->callno]->pingtime)
(1642,exten)
(1643,sin_addr)
(1644,(f.subclass.integer != IAX_COMMAND_TXREADY)
(1645,iaxs[fr->callno])
(1646,integer)
(1647,&iaxs[fr->callno]->state)
(1648,ast_strlen_zero(iaxs[fr->callno]->secret)
(1649,callno)
(1650,fr)
(1651,if (cur->transfer)
(1652,)
(1653,orignative)
(1654,IAX_COMMAND_ACK)
(1655,case IAX_COMMAND_POKE:)
(1656,authdebug)
(1657,!ast_connected_line_parse_data(f.data.ptr, f.datalen, &connected)
(1658,AST_FRAME_VOICE)
(1659,callno)
(1660,fr)
(1661,0)
(1662,ies)
(1663,if (!iaxs[fr->callno])
(1664,iaxs[fr->callno])
(1665,format)
(1666,ast_inet_ntoa(sin.sin_addr)
(1667,"Received VNAK: resending outstanding frames\\n")
(1668,callno)
(1669,AST_FRAME_IAX)
(1670,fr->callno)
(1671,callno)
(1672,sin.sin_addr)
(1673,fr)
(1674,callno)
(1675,fr->callno)
(1676,f.data)
(1677,ied0)
(1678,last)
(1679,ntohs(fh->dcallno)
(1680,iaxs[fr->callno]->cid_num)
(1681,peerformat)
(1682,meta->zeros == 0)
(1683,fr)
(1684,sin)
(1685,f.subclass.integer != IAX_COMMAND_TXCNT)
(1686,fr)
(1687,fr)
(1688,0)
(1689,frametype)
(1690,callno)
(1691,callno)
(1692,ied0)
(1693,ies)
(1694,fr->callno)
(1695,1)
(1696,0)
(1697,IAX_DELAYPBXSTART)
(1698,3)
(1699,pref)
(1700,AST_FRAME_IAX)
(1701,&pref)
(1702,f)
(1703,f)
(1704,0)
(1705,!inaddrcmp(&sin, &iaxs[fr->callno]->addr)
(1706,*c = NULL)
(1707,fr->callno)
(1708,)
(1709,ies.vars)
(1710,ied0)
(1711,case IAX_COMMAND_TRANSFER:)
(1712,f.subclass.integer)
(1713,1)
(1714,iaxs)
(1715,if (!iaxs[fr->callno])
(1716,callno)
(1717,)
(1718,fd)
(1719,iaxs[fr->callno])
(1720,ts)
(1721,f)
(1722,break;)
(1723,fr)
(1724,!inaddrcmp(&sin, &iaxs[fr->callno]->addr)
(1725,send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_UNSUPPORT, 0, ied0.buf, ied0.pos, -1)
(1726,transferring)
(1727,fr->callno)
(1728,iaxs)
(1729,fr->callno)
(1730,number)
(1731,iaxs)
(1732,ies.vars)
(1733,callno)
(1734,iseqno)
(1735,callno)
(1736,newvar)
(1737,fr)
(1738,integer)
(1739,iaxs)
(1740,fr)
(1741,"<Unknown>")
(1742,iaxs[fr->callno]->owner)
(1743,if (!iaxs[fr->callno])
(1744,-1)
(1745,sizeof(tmp)
(1746,offset)
(1747,var)
(1748,(f.subclass.integer != IAX_COMMAND_TXACC)
(1749,break;)
(1750,iseqno)
(1751,error)
(1752,f)
(1753,ts)
(1754,fr->ts)
(1755,fr->callno)
(1756,data_size)
(1757,prefs)
(1758,iaxs[fr->callno])
(1759,fr)
(1760,iaxs[fr->callno]->bridgecallno)
(1761,aseqno)
(1762,iax2_destroy(fr->callno)
(1763,addr)
(1764,iaxs[fr->callno]->voiceformat)
(1765,f.frametype != AST_FRAME_IAX)
(1766,fr->callno)
(1767,ied0)
(1768,LOG_NOTICE)
(1769,fr->callno)
(1770,!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)
(1771,integer)
(1772,callno)
(1773,break;)
(1774,subclass)
(1775,if ((f.frametype == AST_FRAME_VOICE)
(1776,IAX_IE_CAUSECODE)
(1777,ast_mutex_unlock(&iaxsl[fr->callno])
(1778,frametype)
(1779,fr->callno)
(1780,iaxs[fr->callno])
(1781,"I can haz IAX vars? w00t\\n")
(1782,f.datalen)
(1783,f.subclass.integer)
(1784,ied1.buf)
(1785,strcmp(iaxs[fr->callno]->exten, "TBD")
(1786,capability)
(1787,ast_variables_destroy(ies.vars)
(1788,ied0.buf)
(1789,fr)
(1790,iaxs)
(1791,vars)
(1792,fr->callno)
(1793,callno)
(1794,data_size += 3)
(1795,f)
(1796,case IAX_COMMAND_TXMEDIA:)
(1797,bridgecallno)
(1798,fr)
(1799,iaxs[fr->callno]->owner)
(1800,ast_verb(3, "Call accepted by %s (format %s)
(1801,fr)
(1802,name)
(1803,ied0)
(1804,if (handle_call_token(fh, &ies, &sin, fd)
(1805,fr)
(1806,"disabled")
(1807,fr)
(1808,)
(1809,iaxs[fr->callno]->exten)
(1810,sizeof(iaxs[fr->callno]->transfer)
(1811,iaxs)
(1812,fr)
(1813,f.subclass)
(1814,iaxs)
(1815,iaxs)
(1816,sin_addr)
(1817,TRANSFER_MREADY)
(1818,f)
(1819,callno)
(1820,break;)
(1821,subclass)
(1822,sin)
(1823,fh)
(1824,VERBOSE_PREFIX_4)
(1825,(struct ast_iax2_meta_hdr *)
(1826,f.len)
(1827,tmp2)
(1828,0)
(1829,iaxs[fr->callno])
(1830,call_to_destroy)
(1831,f.frametype == AST_FRAME_IAX)
(1832,fr->callno)
(1833,&ies)
(1834,strcpy(host_pref_buf, "disabled")
(1835,owner)
(1836,~0x40)
(1837,ied0)
(1838,callno)
(1839,last)
(1840,ast_verb(3, "Attempting media bridge of %s and %s\\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner)
(1841,1)
(1842,callno)
(1843,fr->callno)
(1844,0)
(1845,callno)
(1846,if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(1847,fr)
(1848,fr->callno)
(1849,varlist)
(1850,find_callno(ntohs(mh->callno)
(1851,iaxs[fr->callno]->transferring)
(1852,res - 1)
(1853,fr->callno)
(1854,iaxs)
(1855,samples)
(1856,iaxs)
(1857,f.subclass.integer)
(1858,f.data.ptr = thread->buf + sizeof(*vh)
(1859,last)
(1860,peerformat)
(1861,&ied0)
(1862,data)
(1863,pingied)
(1864,break;)
(1865,tmp1)
(1866,callno)
(1867,iaxs)
(1868,fr)
(1869,)
(1870,iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL)
(1871,"ChannelType: IAX2\\r\\nPeer: IAX2/%s\\r\\nPeerStatus: Lagged\\r\\nTime: %d\\r\\n")
(1872,ts)
(1873,fr->callno)
(1874,vh->zeros == 0)
(1875,iaxs[fr->callno])
(1876,IAX_STATE_STARTED | IAX_STATE_TBD)
(1877,rseqno)
(1878,fr->callno)
(1879,rseqno)
(1880,buf)
(1881,save_rr(fr, &ies)
(1882,if (ast_channel_writeformat(iaxs[fr->callno]->owner)
(1883,0)
(1884,bridged_chan)
(1885,updatehistory)
(1886,callno)
(1887,case IAX_COMMAND_TXREADY:)
(1888,authdebug)
(1889,ast_channel_name(iaxs[fr->callno]->owner)
(1890,-1)
(1891,x=iaxs[fr->callno]->rseqno)
(1892,iaxs[fr->callno]->exten)
(1893,fr)
(1894,-1)
(1895,iaxsl[fr->callno])
(1896,iaxs[fr->callno])
(1897,if (iaxs[fr->callno]->transferring)
(1898,thread)
(1899,fr->callno)
(1900,ast_debug(1, "Peer %s: got pong, lastms %d, historicms %d, maxms %d\\n", peer->name, peer->lastms, peer->historicms, peer->maxms)
(1901,NEW_ALLOW_CALLTOKEN_VALIDATED)
(1902,callno)
(1903,pos)
(1904,pos)
(1905,!AST_SCHED_DEL(sched, peer->pokeexpire)
(1906,f.subclass.integer != IAX_COMMAND_VNAK)
(1907,send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1)
(1908,&pref)
(1909,iaxs)
(1910,if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)
(1911,iaxs[fr->callno])
(1912,iaxs[fr->callno])
(1913,peercapability)
(1914,prev)
(1915,fh->iseqno + 1)
(1916,iaxs[iaxs[fr->callno]->bridgecallno]->owner)
(1917,)
(1918,fr)
(1919,iaxsl)
(1920,fr)
(1921,&f.subclass.format)
(1922,sizeof(pref)
(1923,iax2_getformatname_multiple(tmp, sizeof(tmp)
(1924,fr->callno)
(1925,-1)
(1926,tmp)
(1927,callno)
(1928,minivid)
(1929,)
(1930,f.subclass)
(1931,fr->callno)
(1932,IAX_IE_CAUSE)
(1933,ies)
(1934,"Registration failure\\n")
(1935,iaxs[fr->callno]->state)
(1936,callno)
(1937,fr->callno)
(1938,iaxs[fr->callno])
(1939,ast_mutex_unlock(&iaxsl[fr->callno])
(1940,f)
(1941,callno)
(1942,state)
(1943,f.subclass)
(1944,iaxs[fr->callno]->capability)
(1945,sin)
(1946,iaxs)
(1947,fr->callno)
(1948,fr->callno)
(1949,IAX_CODEC_NOCAP)
(1950,IAX_STATE_TBD)
(1951,rprefs)
(1952,iaxs[fr->callno])
(1953,"Hold")
(1954,!format)
(1955,fr->callno)
(1956,send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
(1957,sin.sin_addr)
(1958,oseqno)
(1959,using_prefs)
(1960,pingtime)
(1961,0)
(1962,ast_channel_caller(iaxs[fr->callno]->owner)
(1963,"<Unknown>")
(1964,0)
(1965,0)
(1966,f.subclass)
(1967,fr->callno)
(1968,"caller")
(1969,fr->callno)
(1970,vars)
(1971,thread)
(1972,f.frametype == AST_FRAME_VOICE)
(1973,name)
(1974,!authenticate_request(fr->callno)
(1975,&ied0)
(1976,"Accepting AUTHENTICATED call from %s:\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t"%srequested format = %s,\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t"%srequested prefs = %s,\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t"%sactual format = %s,\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t"%shost prefs = %s,\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t"%spriority = %s\\n")
(1977,iaxs)
(1978,data_size++)
(1979,)
(1980,iaxs[fr->callno]->capability)
(1981,0)
(1982,f.subclass.integer)
(1983,transferring)
(1984,&ies)
(1985,pref = iaxs[fr->callno]->prefs)
(1986,iaxs[fr->callno])
(1987,ast_test_flag64(iaxs[fr->callno], IAX_TRUNK)
(1988,fr)
(1989,callno)
(1990,break;)
(1991,&iaxsl[fr->callno])
(1992,iaxs[fr->callno])
(1993,fr)
(1994,)
(1995,capability)
(1996,ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD)
(1997,caller_pref_buf)
(1998,)
(1999,callno)
(2000,format)
(2001,IAX_COMMAND_TXACC)
(2002,iaxs[fr->callno])
(2003,iaxs[fr->callno]->state)
(2004,iaxs[iaxs[fr->callno]->bridgecallno])
(2005,ast_verb(3, "Accepted AUTHENTICATED TBD call from %s\\n", ast_inet_ntoa(sin.sin_addr)
(2006,format)
(2007,(f.subclass.integer != IAX_COMMAND_ACK)
(2008,subclass)
(2009,iaxs[fr->callno])
(2010,iaxs)
(2011,fr)
(2012,ies.called_number)
(2013,callno)
(2014,state)
(2015,case IAX_COMMAND_DPREQ:)
(2016,subclass)
(2017,ies)
(2018,callno)
(2019,fr)
(2020,ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)
(2021,LOG_NOTICE)
(2022,fr)
(2023,ast_log(LOG_WARNING, "Datalen < 0?\\n")
(2024,iaxs[fr->callno]->transferring)
(2025,struct ast_iax2_meta_hdr *)
(2026,fd)
(2027,iaxs[fr->callno])
(2028,IAX_IE_CAUSE)
(2029,fr)
(2030,x == cur->oseqno)
(2031,f)
(2032,pos)
(2033,vh)
(2034,iaxs[fr->callno]->addr)
(2035,snprintf(cause_code->code, data_size - sizeof(*cause_code)
(2036,(iaxs[fr->callno]->iseqno != fr->oseqno)
(2037,connected.id.number.presentation)
(2038,if (res >= sizeof(*fh)
(2039,if (ies.musiconhold)
(2040,fr)
(2041,iaxs[fr->callno]->prefs)
(2042,ast_datastore_free(variablestore)
(2043,f.frametype = AST_FRAME_NULL)
(2044,iaxs[fr->callno]->last < fr->ts)
(2045,break;)
(2046,NULL)
(2047,iaxs[fr->callno]->context)
(2048,integer)
(2049,(iaxs[fr->callno]->pingtime + peer->historicms)
(2050,tmp)
(2051,callno)
(2052,ntohs(meta->metacmd)
(2053,f.subclass.format.id != ast_format_id_from_old_bitfield(iaxs[fr->callno]->videoformat)
(2054,fr)
(2055,callno)
(2056,iaxsl[fr->callno])
(2057,ntohs(mh->ts)
(2058,iaxs[fr->callno]->owner)
(2059,iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner)
(2060,iaxs[fr->callno] && iaxs[fr->callno]->last < fr->ts)
(2061,fr)
(2062,f)
(2063,prev)
(2064,ies)
(2065,iaxs[fr->callno]->voiceformat)
(2066,0)
(2067,1)
(2068,ied0)
(2069,f.subclass.integer)
(2070,fh)
(2071,capability)
(2072,fr->callno)
(2073,ied0)
(2074,fh->ts)
(2075,fr)
(2076,ied1)
(2077,0)
(2078,"Memory allocation error while processing IAX2 variables\\n")
(2079,iaxs)
(2080,callno)
(2081,callno)
(2082,callno)
(2083,if (iax2_ack_registry(&ies, &sin, fr->callno)
(2084,"Rejected connect attempt from %s, requested \'%s\' incompatible with our capability \'%s\'.\\n")
(2085,iaxs[fr->callno]->owner)
(2086,format)
(2087,(f.subclass.integer != IAX_COMMAND_TXACC)
(2088,fr)
(2089,iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
(2090,fr)
(2091,iaxs[fr->callno]->owner)
(2092,iaxs[fr->callno]->oseqno)
(2093,!iaxs[fr->callno]->owner)
(2094,fr->callno)
(2095,"Rejected connect attempt from %s, requested \'%s\' incompatible with our capability \'%s\'.\\n")
(2096,iaxs[fr->callno]->error)
(2097,fr)
(2098,iaxs)
(2099,fr->ts)
(2100,"IAX2/%s")
(2101,owner)
(2102,format)
(2103,peer)
(2104,f.subclass.integer)
(2105,fr)
(2106,f)
(2107,if (f.frametype == AST_FRAME_CONTROL && f.subclass.integer == AST_CONTROL_CONNECTED_LINE)
(2108,username)
(2109,integer)
(2110,bridgecallno)
(2111,send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
(2112,fr->callno)
(2113,break;)
(2114,fr)
(2115,f.subclass)
(2116,f.datalen = res - sizeof(*fh)
(2117,fr->callno)
(2118,ast_calloc(1, sizeof(*varlist)
(2119,ies.vars)
(2120,*varlist)
(2121,username)
(2122,owner)
(2123,iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
(2124,subclass)
(2125,integer)
(2126,iaxs[fr->callno]->voiceformat = ast_format_to_old_bitfield(&f.subclass.format)
(2127,0)
(2128,ies.challenge)
(2129,cur)
(2130,f.frametype != AST_FRAME_VOICE)
(2131,ies.devicetype)
(2132,vars)
(2133,iaxs[fr->callno])
(2134,callno)
(2135,iaxs[fr->callno]->transferring)
(2136,iaxs[fr->callno])
(2137,ast_mutex_unlock(&iaxsl[fr->callno])
(2138,callno)
(2139,fr->callno)
(2140,iaxs[fr->callno])
(2141,f.subclass)
(2142,0)
(2143,callno)
(2144,sin)
(2145,ies)
(2146,iaxs[fr->callno]->videoformat)
(2147,fr->callno)
(2148,f)
(2149,break;)
(2150,IAX_STATE_STARTED)
(2151,fr->callno)
(2152,sin.sin_addr)
(2153,iax2_destroy(fr->callno)
(2154,peer)
(2155,callno)
(2156,if ((unsigned char)
(2157,fr->callno)
(2158,pref = iaxs[fr->callno]->prefs)
(2159,iaxs)
(2160,fr->callno)
(2161,iaxs[fr->callno]->pingtime)
(2162,fr->callno)
(2163,subclass)
(2164,ast_inet_ntoa(sin.sin_addr)
(2165,iaxs)
(2166,iaxs[fr->callno]->exten)
(2167,fr->callno)
(2168,peer->lastms)
(2169,if (iaxdebug)
(2170,iaxs)
(2171,fr->callno)
(2172,iaxs[fr->callno]->owner)
(2173,f)
(2174,ast_log(LOG_NOTICE, "Peer did not understand our iax command \'%d\'\\n", ies.iax_unknown)
(2175,x)
(2176,iaxs[fr->callno])
(2177,vars)
(2178,callno)
(2179,cid_num)
(2180,NULL)
(2181,vnak_retransmit(fr->callno, fr->iseqno)
(2182,1)
(2183,f.subclass)
(2184,0)
(2185,frametype)
(2186,f.mallocd)
(2187,ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD)
(2188,iaxs)
(2189,iaxs[fr->callno])
(2190,iaxs[fr->callno])
(2191,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)
(2192,fr)
(2193,iaxs)
(2194,ied0)
(2195,ast_set_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART)
(2196,fr)
(2197,tmp2)
(2198,(unsigned char *)
(2199,iaxs[fr->callno]->owner)
(2200,fr)
(2201,IAX_COMMAND_NEW)
(2202,iaxs)
(2203,f.frametype)
(2204,cause_code)
(2205,callno)
(2206,iaxs[fr->callno]->owner)
(2207,iaxs)
(2208,AST_FRAME_IAX)
(2209,callno)
(2210,iaxs[fr->callno] && iaxs[fr->callno]->owner)
(2211,iaxs[fr->callno]->rseqno)
(2212,ies.serviceident)
(2213,fr)
(2214,iaxs)
(2215,fr)
(2216,iaxs)
(2217,fr->callno)
(2218,codec_prefs)
(2219,strcpy(caller_pref_buf,"disabled")
(2220,iaxs[fr->callno])
(2221,iaxs[fr->callno]->transfer)
(2222,iaxs)
(2223,iaxs)
(2224,connected.id.number.str)
(2225,callno)
(2226,&iaxsl[fr->callno])
(2227,AST_LIST_HEAD_INIT(varlist)
(2228,if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)
(2229,iaxs[fr->callno])
(2230,tmp2)
(2231,iaxs[fr->callno])
(2232,case IAX_COMMAND_INVAL:)
(2233,iaxsl)
(2234,fr->callno)
(2235,struct ast_iax2_mini_hdr *)
(2236,callno)
(2237,fr->iseqno)
(2238,integer)
(2239,fr->callno)
(2240,iaxs)
(2241,ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD | IAX_STATE_AUTHENTICATED)
(2242,ast_channel_caller(iaxs[fr->callno]->owner)
(2243,fr->iseqno)
(2244,ies)
(2245,fr)
(2246,log_jitterstats(fr->callno)
(2247,AST_STATE_RING)
(2248,causecode)
(2249,fr)
(2250,thread->buf)
(2251,fr)
(2252,iaxs)
(2253,&iax2_variable_datastore_info)
(2254,iaxs[fr->callno]->peerformat)
(2255,meta)
(2256,iaxs[fr->callno])
(2257,fh->type)
(2258,iaxs[fr->callno])
(2259,called_number)
(2260,f.frametype == AST_FRAME_CONTROL && iaxs[fr->callno]->owner)
(2261,var)
(2262,integer)
(2263,)
(2264,IAX_IE_CAUSECODE)
(2265,f.frametype)
(2266,fr->afdatalen = 4096)
(2267,AST_FRAME_IAX)
(2268,varlist)
(2269,integer)
(2270,IAX_COMMAND_TXACC)
(2271,iaxs)
(2272,LOG_WARNING)
(2273,AST_FRAME_IAX)
(2274,ast_inet_ntoa(sin.sin_addr)
(2275,iaxs)
(2276,buf)
(2277,varlist)
(2278,using_prefs)
(2279,iaxs[fr->callno])
(2280,id)
(2281,iaxs[fr->callno])
(2282,fr)
(2283,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(2284,IAX_COMMAND_REGREJ)
(2285,)
(2286,)
(2287,return 1;)
(2288,fr->callno)
(2289,callno)
(2290,VERBOSE_PREFIX_4)
(2291,callno)
(2292,owner)
(2293,fr->callno)
(2294,fr)
(2295,iax_park(bridged_chan, owner, ies.called_number, context)
(2296,IAX_COMMAND_AUTHREQ)
(2297,fr->iseqno)
(2298,ast_log(LOG_WARNING, "Undecodable frame received from \'%s\'\\n", ast_inet_ntoa(sin.sin_addr)
(2299,fr->callno)
(2300,subclass)
(2301,state)
(2302,iaxs)
(2303,format = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(2304,if (iaxs[fr->callno]->owner && ast_test_flag64(iaxs[fr->callno], IAX_QUELCH)
(2305,ies)
(2306,fr)
(2307,caller_pref_buf)
(2308,ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner)
(2309,fr->ts = (iaxs[fr->callno]->last & 0xFFFF8000L)
(2310,iaxs)
(2311,)
(2312,AST_FRAME_IAX)
(2313,cause_code)
(2314,ast_log(LOG_NOTICE, "Rejected call to %s, format %s incompatible with our capability %s.\\n",\n\\n\\t\\t\\t\\t\\t\\t\\tast_inet_ntoa(sin.sin_addr)
(2315,fr->callno)
(2316,iaxs[fr->callno]->last)
(2317,fr->callno)
(2318,iaxs)
(2319,callno)
(2320,iaxs)
(2321,tmpfmt)
(2322,owner)
(2323,ies)
(2324,iaxs)
(2325,)
(2326,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(2327,)
(2328,ied0)
(2329,)
(2330,f.frametype == AST_FRAME_IAX)
(2331,callno)
(2332,pref)
(2333,peer)
(2334,pos)
(2335,iaxs[fr->callno]->owner)
(2336,&ied0)
(2337,host_pref_buf)
(2338,break;)
(2339,iaxs[fr->callno]->reg->username)
(2340,iaxs)
(2341,iaxs)
(2342,iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0)
(2343,iaxs[fr->callno])
(2344,!iaxs[fr->callno])
(2345,datalen)
(2346,&pref)
(2347,(f.subclass.integer != IAX_COMMAND_TXACC)
(2348,&ied0)
(2349,owner)
(2350,fr->ts)
(2351,sin)
(2352,fr)
(2353,IAX_COMMAND_INVAL)
(2354,fr->callno)
(2355,iaxs)
(2356,break;)
(2357,if (strcmp(iaxs[fr->callno]->exten, "TBD")
(2358,iaxs[fr->callno])
(2359,&fr->ts)
(2360,ies.encmethods)
(2361,res)
(2362,tmp3)
(2363,&f)
(2364,callno)
(2365,sin)
(2366,iaxs[fr->callno]->owner)
(2367,iaxs[fr->callno]->owner)
(2368,ies.vars)
(2369,ies)
(2370,iaxs[fr->callno])
(2371,iaxs)
(2372,transferring)
(2373,iaxs)
(2374,"midget packet received (%d of %d min)
(2375,f.subclass.integer != IAX_COMMAND_INVAL)
(2376,iax2_variable_datastore_info)
(2377,test_resync)
(2378,fr)
(2379,&f.subclass.format)
(2380,fr)
(2381,fr->ts)
(2382,owner)
(2383,iaxs)
(2384,fr->callno)
(2385,fr->callno)
(2386,f.frametype)
(2387,callno)
(2388,iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION)
(2389,number)
(2390,fr)
(2391,ast_channel_name(iaxs[fr->callno]->owner)
(2392,moh_suggest)
(2393,callno)
(2394,format)
(2395,callno)
(2396,iax2_getformatname_multiple(tmp2, sizeof(tmp2)
(2397,&iaxs[fr->callno]->rprefs)
(2398,fr)
(2399,f.subclass)
(2400,fr)
(2401,ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",\n\\n\\t\\t\\t\\t\\t\\t\\t"Status: On\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t"Channel: %s\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t"Uniqueid: %s\\r\\n",\n\\n\\t\\t\\t\\t\\t\\t\\tast_channel_name(iaxs[fr->callno]->owner)
(2402,callno)
(2403,iaxs[fr->callno]->secret)
(2404,zeros)
(2405,)
(2406,iaxs[fr->callno])
(2407,iaxs)
(2408,fr->outoforder = -1)
(2409,mh)
(2410,fr->callno)
(2411,-1)
(2412,prefs)
(2413,fr)
(2414,data_size += strlen(subclass)
(2415,ast_mutex_unlock(&iaxsl[fr->callno])
(2416,S_COR(connected.id.number.valid, connected.id.number.str, "")
(2417,rprefs)
(2418,ast_debug(1, "I can haz IAX vars?\\n")
(2419,)
(2420,if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)
(2421,iaxs[fr->callno]->last & 0xFFFF8000L)
(2422,iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1)
(2423,fr->callno)
(2424,fr->callno)
(2425,if (update_registry(&sin, fr->callno, ies.devicetype, fd, ies.refresh)
(2426,ies)
(2427,ts)
(2428,&ied0)
(2429,fr)
(2430,iaxs)
(2431,callno)
(2432,&ied0)
(2433,ast_inet_ntoa(sin.sin_addr)
(2434,IAX_CODEC_NOCAP)
(2435,owner)
(2436,peerformat)
(2437,"Unable to negotiate codec")
(2438,fr)
(2439,if (ntohs(mh->callno)
(2440,&iaxs[fr->callno]->addr)
(2441,ied0)
(2442,f)
(2443,callno)
(2444,using_prefs = "mine")
(2445,f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_NEW)
(2446,sin.sin_addr)
(2447,iaxs)
(2448,3)
(2449,iaxs[fr->callno])
(2450,iaxs[fr->callno])
(2451,cur)
(2452,iaxs[fr->callno])
(2453,ies.vars)
(2454,iaxs[fr->callno]->capability)
(2455,format)
(2456,sizeof(sin)
(2457,fr->callno)
(2458,mh->callno)
(2459,iax2_getformatname_multiple(tmp1, sizeof(tmp1)
(2460,iaxs[fr->callno])
(2461,owner)
(2462,iaxs)
(2463,fr)
(2464,iaxs[fr->callno])
(2465,ast_channel_readformat(iaxs[fr->callno]->owner)
(2466,iaxs[fr->callno]->pingtime + peer->historicms)
(2467,fr->callno)
(2468,fr->callno)
(2469,transfer)
(2470,ast_verb(3, "Channel \'%s\' ready to transfer\\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner)
(2471,f)
(2472,if (f.datalen)
(2473,ies.called_number)
(2474,called_number)
(2475,fr->callno)
(2476,iaxs[fr->callno])
(2477,connected.id.number)
(2478,csub)
(2479,!(c = ast_iax2_new(fr->callno, AST_STATE_RING, format, NULL)
(2480,pref)
(2481,)
(2482,res >= sizeof(*fh)
(2483,iaxs)
(2484,callno)
(2485,if (ies.provverpres && ies.serviceident && sin.sin_addr.s_addr)
(2486,)
(2487,fr->callno)
(2488,ast_format_to_old_bitfield(&f.subclass.format)
(2489,callno)
(2490,fr)
(2491,fr)
(2492,NULL)
(2493,1)
(2494,callno)
(2495,subclass)
(2496,fr)
(2497,fr->ts)
(2498,iaxs[fr->callno]->bridgecallno)
(2499,iaxs)
(2500,callno)
(2501,iaxs[fr->callno]->pingtime)
(2502,!iaxs[fr->callno])
(2503,iaxs)
(2504,send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1)
(2505,fr)
(2506,fr->callno)
(2507,peerformat)
(2508,if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)
(2509,fr)
(2510,"Received mini frame before first full video frame\\n")
(2511,&sin)
(2512,!format)
(2513,host_pref_buf)
(2514,ts)
(2515,variablestore)
(2516,transferring)
(2517,peerformat)
(2518,send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1)
(2519,ies)
(2520,new_peercallno = (unsigned short)
(2521,~IAX_FLAG_FULL)
(2522,fr->callno)
(2523,ies)
(2524,"reqonly")
(2525,fr)
(2526,iaxs[fr->callno]->rseqno >= iaxs[fr->callno]->oseqno)
(2527,iaxs[fr->callno]->iseqno)
(2528,if (format)
(2529,callno)
(2530,for (var = ies.vars; var; var = var->next)
(2531,lastms)
(2532,fr)
(2533,cur->retries)
(2534,fr->callno)
(2535,"IAX2/%s")
(2536,iaxs[fr->callno])
(2537,strcasecmp(iaxs[fr->callno]->exten, "TBD")
(2538,fr->callno)
(2539,fh->scallno)
(2540,IAX_COMMAND_NEW)
(2541,fr)
(2542,integer)
(2543,return 1;)
(2544,return 1;)
(2545,if (res < 0)
(2546,IAX_CODEC_NOCAP)
(2547,owner)
(2548,callno)
(2549,)
(2550,fr)
(2551,var)
(2552,fr)
(2553,ies.cause ? ies.cause : "<Unknown>")
(2554,iseqno)
(2555,format)
(2556,sizeof(*varlist)
(2557,IAX_IE_CAUSECODE)
(2558,f.subclass)
(2559,f.datalen)
(2560,fr)
(2561,1)
(2562,iaxs)
(2563,subclass)
(2564,voiceformat)
(2565,ast_strlen_zero(iaxs[fr->callno]->inkeys)
(2566,iaxs[fr->callno]->owner)
(2567,fr->callno)
(2568,if (iaxs[fr->callno]->bridgecallno)
(2569,LOG_ERROR)
(2570,iaxs[fr->callno])
(2571,callno)
(2572,1)
(2573,ied1.pos)
(2574,fh)
(2575,callno)
(2576,encmethods)
(2577,iaxs)
(2578,)
(2579,"LAGRQ")
(2580,iaxs[fr->callno]->peerformat)
(2581,callno)
(2582,auth_fail(fr->callno, IAX_COMMAND_REGREJ)
(2583,presentation)
(2584,f)
(2585,iaxs[fr->callno])
(2586,name)
(2587,f.frametype == AST_FRAME_IAX)
(2588,ies)
(2589,varlist)
(2590,if (iaxs[fr->callno]->transferring == TRANSFER_BEGIN)
(2591,fr->callno)
(2592,ast_channel_writeformat(iaxs[fr->callno]->owner)
(2593,iaxs[fr->callno]->first_iax_message)
(2594,callno)
(2595,callno)
(2596,ntohs(mh->callno)
(2597,iaxs[iaxs[fr->callno]->bridgecallno])
(2598,iaxs)
(2599,iaxs)
(2600,if (strcasecmp(iaxs[fr->callno]->exten, "TBD")
(2601,)
(2602,)
(2603,len)
(2604,)
(2605,if (f.subclass.integer == AST_CONTROL_BUSY)
(2606,integer)
(2607,&sin)
(2608,iaxs[fr->callno])
(2609,fr)
(2610,iaxs[fr->callno]->iseqno)
(2611,thread)
(2612,iaxs[fr->callno])
(2613,callno)
(2614,integer)
(2615,1)
(2616,tmp)
(2617,)
(2618,vh->callno)
(2619,ied0)
(2620,memset(&ied0, 0, sizeof(ied0)
(2621,peer)
(2622,iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL)
(2623,fr->callno)
(2624,iaxs)
(2625,iaxs[fr->callno])
(2626,minivid = 1)
(2627,ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD)
(2628,iaxs[fr->callno])
(2629,ied0)
(2630,iaxs[fr->callno]->last & 0xFFFF0000L)
(2631,fr)
(2632,subclass)
(2633,peer)
(2634,sin_addr)
(2635,if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(2636,host_pref_buf)
(2637,ied0)
(2638,fr)
(2639,0)
(2640,fr->oseqno)
(2641,if (new_peercallno && new_peercallno != iaxs[fr->callno]->peercallno)
(2642,iaxs[fr->callno])
(2643,callno)
(2644,(peer->lastms < 0)
(2645,using_prefs = "caller")
(2646,3)
(2647,fr->callno)
(2648,callno)
(2649,check_dcallno)
(2650,1)
(2651,res - sizeof(*fh)
(2652,iaxs[fr->callno]->peerformat)
(2653,peer->name)
(2654,ies.calltoken)
(2655,state)
(2656,iaxs[fr->callno]->rprefs)
(2657,fr->callno)
(2658,fr)
(2659,fr)
(2660,iaxs[fr->callno])
(2661,integer)
(2662,fr)
(2663,subclass)
(2664,)
(2665,iaxsl[fr->callno])
(2666,f.subclass.integer)
(2667,iaxs[fr->callno])
(2668,iax2_vnak(fr->callno)
(2669,break;)
(2670,fr)
(2671,fr->callno)
(2672,vars)
(2673,ies.cause)
(2674,ts - fr->ts)
(2675,dcallno)
(2676,iax2_destroy(fr->callno)
(2677,fr->callno)
(2678,pokeexpire)
(2679,*native = ast_channel_nativeformats(iaxs[fr->callno]->owner)
(2680,iaxs)
(2681,ies.vars)
(2682,registry_authrequest(fr->callno)
(2683,fr->callno)
(2684,new_callno)
(2685,iaxs[fr->callno]->bridgecallno)
(2686,&hangup_fr)
(2687,return 1;)
(2688,fr->callno)
(2689,thread->iosin)
(2690,peer->lastms = iaxs[fr->callno]->pingtime)
(2691,iaxs)
(2692,ied1)
(2693,res)
(2694,tmp3)
(2695,&ied1)
(2696,ast_channel_unlock(iaxs[fr->callno]->owner)
(2697,vh)
(2698,f.subclass.integer)
(2699,fr)
(2700,callno)
(2701,iaxs[fr->callno])
(2702,1)
(2703,prev)
(2704,state)
(2705,0)
(2706,iaxs[fr->callno])
(2707,iaxs[fr->callno])
(2708,lag)
(2709,fr)
(2710,fr)
(2711,mallocd)
(2712,ts)
(2713,0)
(2714,ast_log(LOG_WARNING, \n\\n\\t\\t\\t\\t\\t\\t"I don\'t know how to authenticate %s to %s\\n", \n\\n\\t\\t\\t\\t\\t\\ties.username ? ies.username : "<unknown>", ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr)
(2715,callno)
(2716,integer)
(2717,f.subclass)
(2718,ast_channel_nativeformats(iaxs[fr->callno]->owner)
(2719,scallno)
(2720,fr->callno)
(2721,ast_channel_name(bridged_chan)
(2722,iaxs)
(2723,entries)
(2724,)
(2725,fr)
(2726,callno)
(2727,decrypted)
(2728,zeros)
(2729,iaxs[fr->callno]->capability)
(2730,last)
(2731,thread->buf + sizeof(struct ast_iax2_full_hdr)
(2732,iaxs)
(2733,f)
(2734,tmp2)
(2735,memset(&ied0, 0, sizeof(ied0)
(2736,fr)
(2737,ast_debug(1, "We don\'t do requested format %s, falling back to peer capability \'%s\'\\n",\n\\n\\t\\t\\t\\t\\t\\t\\t\\tiax2_getformatname(iaxs[fr->callno]->peerformat)
(2738,mh)
(2739,str)
(2740,&sin)
(2741,f)
(2742,IAX_IE_CAUSECODE)
(2743,callno)
(2744,fr)
(2745,fr)
(2746,iaxs[fr->callno])
(2747,fr)
(2748,connected.id.name)
(2749,"")
(2750,IAX_CODEC_USER_FIRST)
(2751,(unsigned char *)
(2752,iaxs[fr->callno]->exten)
(2753,f)
(2754,f.subclass == IAX_COMMAND_ACCEPT)
(2755,0xffff)
(2756,iaxs[fr->callno])
(2757,iaxs[fr->callno])
(2758,pokeexpire)
(2759,int)
(2760,callno)
(2761,ied0)
(2762,callno)
(2763,fr->callno)
(2764,)
(2765,test_resync)
(2766,IAX_IE_CAUSE)
(2767,1)
(2768,)
(2769,context)
(2770,)
(2771,res < sizeof(*vh)
(2772,f)
(2773,case IAX_COMMAND_REGREJ:)
(2774,)
(2775,fr->callno)
(2776,iaxs[fr->callno])
(2777,&res)
(2778,"<Unknown>")
(2779,iaxs)
(2780,AST_FRAME_IAX)
(2781,fr)
(2782,fr->callno)
(2783,AF_INET)
(2784,case IAX_COMMAND_PONG:)
(2785,iaxs)
(2786,if (varlist)
(2787,1)
(2788,send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
(2789,iaxs[fr->callno])
(2790,iaxvars)
(2791,cid_num)
(2792,iaxs)
(2793,callno)
(2794,iaxs[fr->callno])
(2795,1)
(2796,&ied1)
(2797,IAX_COMMAND_INVAL)
(2798,exists)
(2799,callno)
(2800,1)
(2801,ast_variables_destroy(ies.vars)
(2802,context)
(2803,iaxs[fr->callno])
(2804,iaxs[fr->callno])
(2805,&ied0)
(2806,iaxs)
(2807,iaxs)
(2808,iaxs[fr->callno])
(2809,iaxs)
(2810,tmp2)
(2811,callno)
(2812,sizeof(ied0)
(2813,4096)
(2814,fr->callno)
(2815,IAX_COMMAND_INVAL)
(2816,ies)
(2817,f.src = "LAGRQ")
(2818,fr->callno)
(2819,AST_CONTROL_PROGRESS)
(2820,bridgecallno)
(2821,iaxs[fr->callno])
(2822,0)
(2823,fr->callno)
(2824,)
(2825,ies.vars)
(2826,tmp1)
(2827,ast_mutex_unlock(&iaxsl[fr->callno])
(2828,iaxs)
(2829,"We don\'t do requested format %s, falling back to peer capability \'%s\'\\n")
(2830,-1)
(2831,strcmp(iaxs[fr->callno]->exten, "TBD")
(2832,&connected)
(2833,0)
(2834,delayreject)
(2835,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(2836,iaxs[fr->callno])
(2837,fr)
(2838,pingtime)
(2839,iaxs)
(2840,ies.vars)
(2841,provverpres)
(2842,fr->callno)
(2843,&ied0)
(2844,&tmpfmt)
(2845,fr->callno = new_callno)
(2846,thread)
(2847,ast_format_from_old_bitfield(&f.subclass.format, iaxs[fr->callno]->videoformat)
(2848,1)
(2849,if (iaxs[fr->callno]->peerpoke)
(2850,iaxs)
(2851,callno)
(2852,ts)
(2853,sin_addr)
(2854,ast_channel_readformat(iaxs[fr->callno]->owner)
(2855,3)
(2856,if (f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_POKE)
(2857,IAX_ALREADYGONE)
(2858,format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
(2859,fh->iseqno + 1)
(2860,prev)
(2861,f.datalen)
(2862,f.subclass)
(2863,fr)
(2864,state)
(2865,)
(2866,ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)
(2867,fh->dcallno)
(2868,*mh)
(2869,iaxs[fr->callno]->prefs)
(2870,strcpy(host_pref_buf,"disabled")
(2871,iaxs)
(2872,callno)
(2873,fr->callno)
(2874,iaxs[fr->callno]->transferring)
(2875,if (peer->smoothing && (peer->lastms > -1)
(2876,fr)
(2877,if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)
(2878,iaxs)
(2879,ies.vars = NULL)
(2880,if (ies.vars)
(2881,host_pref_buf)
(2882,fd)
(2883,vh)
(2884,frametype)
(2885,iaxs[fr->callno])
(2886,integer)
(2887,)
(2888,pref)
(2889,callno)
(2890,callno)
(2891,ast_inet_ntoa(sin.sin_addr)
(2892,f.subclass)
(2893,callno)
(2894,peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqok, iax2_poke_peer_s, peer_ref(peer)
(2895,iaxs[fr->callno])
(2896,format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
(2897,format)
(2898,owner)
(2899,AST_FRAME_VIDEO)
(2900,iaxs[fr->callno])
(2901,NULL)
(2902,if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(2903,callno)
(2904,fr->callno)
(2905,owner)
(2906,ast_channel_uniqueid(iaxs[fr->callno]->owner)
(2907,iaxs[fr->callno])
(2908,res)
(2909,fr->callno)
(2910,if (delayreject)
(2911,ied0)
(2912,ied0.pos)
(2913,fr)
(2914,)
(2915,iaxs)
(2916,break;)
(2917,IAX_STATE_TBD | IAX_STATE_AUTHENTICATED)
(2918,ast_datastore_alloc(&iax2_variable_datastore_info, NULL)
(2919,ast_debug(1, "Async goto not applicable on call %d\\n", fr->callno)
(2920,iaxs[fr->callno])
(2921,ntohs(vh->ts)
(2922,iaxs)
(2923,callno)
(2924,&iaxsl[fr->callno])
(2925,"Accepted unauthenticated TBD call from %s\\n")
(2926,iaxs[fr->callno]->peerpoke)
(2927,iaxs[fr->callno])
(2928,ies)
(2929,iaxs[fr->callno])
(2930,ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\\n")
(2931,f.data)
(2932,&iaxs[fr->callno]->state)
(2933,iaxs)
(2934,dp->flags)
(2935,using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(2936,IAX_IE_CAUSECODE)
(2937,iaxs[fr->callno]->exten)
(2938,fr->callno)
(2939,fr)
(2940,fr->callno)
(2941,0)
(2942,callno)
(2943,&ied1)
(2944,integer)
(2945,iaxs[fr->callno]->state)
(2946,callno)
(2947,iaxs[fr->callno]->iseqno)
(2948,(f.subclass.integer != IAX_COMMAND_TXREL)
(2949,iaxs)
(2950,using_prefs)
(2951,iaxs[fr->callno])
(2952,(f.subclass.integer != IAX_COMMAND_TXCNT)
(2953,ast_channel_name(iaxs[fr->callno]->owner)
(2954,&iaxs[fr->callno]->state)
(2955,f.data.ptr)
(2956,frametype)
(2957,LOG_WARNING)
(2958,callno)
(2959,connected.id.name)
(2960,fr)
(2961,memset(&ied1, 0, sizeof(ied1)
(2962,sizeof(sin)
(2963,0)
(2964,var)
(2965,ast_calloc(1, sizeof(*varlist)
(2966,iaxs[fr->callno]->peercapability)
(2967,callno)
(2968,pokefreqok)
(2969,AST_FRAME_IAX)
(2970,sin)
(2971,fh)
(2972,iaxs[fr->callno]->capability)
(2973,break;)
(2974,strcpy(caller_pref_buf, "disabled")
(2975,0x7fff)
(2976,iaxs[fr->callno]->state)
(2977,callno)
(2978,fr->callno)
(2979,*newvar = ast_var_assign(var->name, var->value)
(2980,"Call on %s is already up, can\'t start on it\\n")
(2981,return 1;)
(2982,TRANSFER_MREADY)
(2983,f.subclass.integer == IAX_COMMAND_LAGRQ)
(2984,&ied0)
(2985,if (authdebug)
(2986,fr)
(2987,iaxs[fr->callno])
(2988,iaxs[fr->callno]->bridgecallno)
(2989,IAX_CODEC_NOPREFS)
(2990,if (authdebug)
(2991,fr)
(2992,NULL)
(2993,fr->af.subclass.integer)
(2994,iseqno)
(2995,iaxs[fr->callno]->transferring == TRANSFER_BEGIN)
(2996,memset(&iaxs[fr->callno]->transfer, 0, sizeof(iaxs[fr->callno]->transfer)
(2997,IAX_COMMAND_REGREL)
(2998,iaxs)
(2999,callno)
(3000,iaxs)
(3001,fr->callno)
(3002,callno)
(3003,pref = iaxs[fr->callno]->rprefs)
(3004,iaxs[fr->callno]->state)
(3005,3)
(3006,ast_debug(1, "I can haz IAX vars? w00t\\n")
(3007,iaxs[fr->callno]->rprefs)
(3008,iaxs[fr->callno]->iseqno)
(3009,owner)
(3010,NULL)
(3011,pos)
(3012,)
(3013,NULL)
(3014,iaxs[fr->callno])
(3015,fr)
(3016,challenge)
(3017,fr)
(3018,AST_FRAME_VOICE)
(3019,sin)
(3020,sin.sin_addr.s_addr)
(3021,fr)
(3022,f)
(3023,iaxs[fr->callno]->capability)
(3024,ast_inet_ntoa(sin.sin_addr)
(3025,NULL)
(3026,NULL)
(3027,iaxs)
(3028,connected.id.name)
(3029,if (!iaxs[fr->callno])
(3030,varlist)
(3031,thread->buf)
(3032,fr)
(3033,callno)
(3034,fr)
(3035,iaxs[fr->callno]->context)
(3036,ast_mutex_unlock(&iaxsl[fr->callno])
(3037,)
(3038,callno)
(3039,thread)
(3040,case IAX_COMMAND_VNAK:)
(3041,new_callno)
(3042,iaxs)
(3043,fr->callno)
(3044,if (varlist)
(3045,f)
(3046,!ast_strlen_zero(moh_suggest)
(3047,callno)
(3048,NULL)
(3049,callno)
(3050,f.frametype)
(3051,send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1)
(3052,iaxs[fr->callno])
(3053,iaxs[fr->callno]->last)
(3054,iaxs[fr->callno])
(3055,)
(3056,callno)
(3057,callno)
(3058,ast_log(LOG_NOTICE, "Registration of \'%s\' rejected: \'%s\' from: \'%s\'\\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>", ast_inet_ntoa(sin.sin_addr)
(3059,iaxs[fr->callno]->pingtime)
(3060,iaxs)
(3061,peerformat)
(3062,fr->callno)
(3063,AST_FRAME_IAX)
(3064,iaxs[fr->callno])
(3065,valid)
(3066,if (iaxs[fr->callno] && iaxs[fr->callno]->last < fr->ts)
(3067,fr->callno)
(3068,0xFFFF8000L)
(3069,fr)
(3070,ast_channel_unlock(c)
(3071,callno)
(3072,iaxs[fr->callno]->owner)
(3073,ies)
(3074,ied0)
(3075,)
(3076,fr->callno)
(3077,owner)
(3078,fr->callno)
(3079,format)
(3080,secret)
(3081,called_number)
(3082,iax_unknown)
(3083,pref)
(3084,exten)
(3085,callno)
(3086,0x8000)
(3087,iaxs[fr->callno]->username)
(3088,)
(3089,AST_FRAME_IAX)
(3090,iax_outputframe(NULL, fh, 3, &sin, res - sizeof(*fh)
(3091,fr)
(3092,break;)
(3093,fr)
(3094,peer)
(3095,iaxs[fr->callno]->videoformat > 0)
(3096,ied0.pos)
(3097,ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
(3098,)
(3099,iaxs)
(3100,mh)
(3101,fr->callno)
(3102,iaxs[fr->callno]->lag = ts - fr->ts)
(3103,iaxs[fr->callno]->pingtime =  calc_timestamp(iaxs[fr->callno], 0, &f)
(3104,iaxs)
(3105,context)
(3106,f.data.ptr = NULL)
(3107,f)
(3108,iaxs[fr->callno])
(3109,callno)
(3110,)
(3111,)
(3112,subclass)
(3113,callno)
(3114,fr->callno)
(3115,iaxs)
(3116,ast_variables_destroy(ies.vars)
(3117,fr)
(3118,iaxs)
(3119,fr->callno)
(3120,fr)
(3121,fr)
(3122,iaxs[fr->callno])
(3123,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)
(3124,transferring)
(3125,callno)
(3126,iaxs[fr->callno])
(3127,variablestore)
(3128,iaxs[fr->callno])
(3129,IAX_COMMAND_REJECT)
(3130,fr->iseqno)
(3131,callno)
(3132,iaxsl)
(3133,if (strcmp(iaxs[fr->callno]->exten, "TBD")
(3134,callno)
(3135,thread)
(3136,context)
(3137,iaxs)
(3138,fr->callno)
(3139,iaxs[fr->callno])
(3140,iaxs)
(3141,iaxs[fr->callno]->iseqno - fr->oseqno)
(3142,authdebug)
(3143,IAX_ENCRYPTED)
(3144,callno)
(3145,f.subclass)
(3146,1)
(3147,iaxs[fr->callno])
(3148,owner)
(3149,fr->callno)
(3150,iaxs[iaxs[fr->callno]->bridgecallno])
(3151,f.subclass.integer)
(3152,callno)
(3153,*prev = NULL)
(3154,iaxs)
(3155,)
(3156,iaxs)
(3157,ast_test_flag64(iaxs[fr->callno], IAX_FORCE_ENCRYPT)
(3158,callno)
(3159,"No such context/extension")
(3160,NULL)
(3161,owner)
(3162,callno)
(3163,NULL)
(3164,ptr)
(3165,*moh_suggest = iaxs[fr->callno]->mohsuggest)
(3166,IAX_STATE_STARTED | IAX_STATE_TBD)
(3167,fr)
(3168,subclass)
(3169,iaxsl[fr->callno])
(3170,ast_getformatname_multiple(tmp, sizeof(tmp)
(3171,memset(&pref, 0, sizeof(pref)
(3172,entries)
(3173,iaxs[fr->callno]->owner)
(3174,struct ast_iax2_mini_hdr)
(3175,fr->callno)
(3176,"caller")
(3177,tmp2)
(3178,iofd)
(3179,if (f.frametype == AST_FRAME_CONTROL && iaxs[fr->callno]->owner)
(3180,IAX_COMMAND_INVAL)
(3181,if (iaxs[fr->callno]->owner)
(3182,iaxs)
(3183,f.subclass)
(3184,peer->historicms = (iaxs[fr->callno]->pingtime + peer->historicms)
(3185,IAX_COMMAND_REJECT)
(3186,1)
(3187,iaxs[fr->callno])
(3188,"Rejected connect attempt from %s, requested/capability \'%s\'/\'%s\' incompatible with our capability \'%s\'.\\n")
(3189,iaxs)
(3190,callno)
(3191,data)
(3192,f.frametype == AST_FRAME_IAX)
(3193,connected.id.number.presentation)
(3194,callno)
(3195,sin_addr)
(3196,fr)
(3197,iaxs[fr->callno]->owner)
(3198,!iaxs[fr->callno])
(3199,callno)
(3200,iaxs)
(3201,ies.codec_prefs)
(3202,callno)
(3203,iaxs[fr->callno]->cid_num)
(3204,peerformat)
(3205,0)
(3206,fh)
(3207,fr->callno)
(3208,f)
(3209,iaxs)
(3210,IAX_CODEC_NOCAP)
(3211,LOG_WARNING)
(3212,callno)
(3213,return 1;)
(3214,fr->callno)
(3215,f.frametype)
(3216,data_size)
(3217,format)
(3218,iaxs[fr->callno]->owner)
(3219,res)
(3220,fr)
(3221,last_iax_message)
(3222,!authenticate_request(fr->callno)
(3223,iaxs[fr->callno]->encmethods)
(3224,iaxs[fr->callno])
(3225,subclass)
(3226,f)
(3227,callno)
(3228,callno)
(3229,LOG_WARNING)
(3230,iaxs[fr->callno])
(3231,iaxs[fr->callno])
(3232,!newvar)
(3233,peer)
(3234,if (authdebug)
(3235,fr)
(3236,iaxs[fr->callno]->peerformat)
(3237,if (authenticate_verify(iaxs[fr->callno], &ies)
(3238,pref)
(3239,NULL)
(3240,res - sizeof(*fh)
(3241,exten)
(3242,iaxs[fr->callno]->transferring)
(3243,cur->retries = -1)
(3244,fr)
(3245,exten)
(3246,fr)
(3247,IAX_STATE_STARTED)
(3248,iaxs[fr->callno])
(3249,)
(3250,fr->callno)
(3251,ast_format_from_old_bitfield(&f.subclass.format, uncompress_subclass(fh->csub)
(3252,ied0)
(3253,0)
(3254,fr->callno)
(3255,if ((peer->lastms < 0)
(3256,iaxs)
(3257,)
(3258,&iaxs[fr->callno]->state)
(3259,*fh)
(3260,fr->callno)
(3261,callno)
(3262,frametype)
(3263,0)
(3264,integer)
(3265,iaxs)
(3266,send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
(3267,fr)
(3268,fr->callno)
(3269,capability)
(3270,callno)
(3271,)
(3272,&ied0)
(3273,ts)
(3274,sizeof(*vh)
(3275,3)
(3276,iaxs)
(3277,ies.serviceident)
(3278,ast_manager_event(iaxs[fr->callno]->owner, EVENT_FLAG_CALL, "Hold",\n\\n\\t\\t\\t\\t\\t\\t\\t"Status: Off\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t"Channel: %s\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t"Uniqueid: %s\\r\\n",\n\\n\\t\\t\\t\\t\\t\\t\\tast_channel_name(iaxs[fr->callno]->owner)
(3279,*fh)
(3280,called_number)
(3281,callno)
(3282,thread)
(3283,"disabled")
(3284,iax2_vnak(fr->callno)
(3285,f.subclass.integer)
(3286,ies.cause)
(3287,x)
(3288,fr->callno)
(3289,NULL)
(3290,fr)
(3291,(f.subclass.integer != IAX_COMMAND_CALLTOKEN)
(3292,f.subclass)
(3293,iaxs)
(3294,(char *)
(3295,iaxs[fr->callno]->owner)
(3296,AST_FRAME_IAX)
(3297,iaxs[fr->callno]->rprefs)
(3298,f.mallocd = 0)
(3299,iaxs[fr->callno])
(3300,fr->callno)
(3301,callno)
(3302,iaxs)
(3303,f.subclass)
(3304,iaxs)
(3305,ast_channel_unlock(iaxs[fr->callno]->owner)
(3306,thread->buf)
(3307,fr)
(3308,host_pref_buf)
(3309,case IAX_COMMAND_UNQUELCH:)
(3310,ies)
(3311,if (test_resync)
(3312,iaxs[fr->callno]->bridgecallno)
(3313,)
(3314,format)
(3315,state)
(3316,iax2_lock_owner(fr->callno)
(3317,peerpoke)
(3318,fr->callno)
(3319,id)
(3320,var)
(3321,if (ntohs(mh->callno)
(3322,fr)
(3323,f)
(3324,callno)
(3325,callno)
(3326,iaxs[fr->callno]->state)
(3327,fr)
(3328,ied0)
(3329,owner)
(3330,ast_channel_name(iaxs[fr->callno]->owner)
(3331,iaxs[fr->callno]->first_iax_message)
(3332,ies)
(3333,pref = iaxs[fr->callno]->rprefs)
(3334,dcallno)
(3335,fh->iseqno)
(3336,"Memory allocation error while processing IAX2 variables\\n")
(3337,AST_FRAME_IAX)
(3338,iaxs[fr->callno]->rprefs)
(3339,AST_FRAME_IAX)
(3340,iaxs[fr->callno])
(3341,)
(3342,&sin)
(3343,integer)
(3344,callno)
(3345,data)
(3346,&f.subclass.format)
(3347,fr->callno)
(3348,callno)
(3349,AST_FRAME_CONTROL)
(3350,format)
(3351,callno)
(3352,1)
(3353,iaxs[fr->callno]->peerformat)
(3354,iaxs[fr->callno]->transfer)
(3355,duped_fr)
(3356,fr->callno)
(3357,ts)
(3358,ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED)
(3359,ied0)
(3360,ast_free(varlist)
(3361,fr)
(3362,res++)
(3363,res > 0)
(3364,integer)
(3365,subclass)
(3366,IAX_STATE_TBD)
(3367,subclass)
(3368,iaxs[fr->callno])
(3369,break;)
(3370,ast_debug(1, "Received VNAK: resending outstanding frames\\n")
(3371,ies)
(3372,IAX_COMMAND_ACK)
(3373,sin)
(3374,fr)
(3375,iaxs[fr->callno])
(3376,sizeof(tmp)
(3377,peer->historicms)
(3378,newvar)
(3379,&f.subclass.format)
(3380,ied0.pos)
(3381,iaxs[fr->callno])
(3382,authdebug)
(3383,frametype)
(3384,fh->iseqno)
(3385,fr)
(3386,iaxs[fr->callno])
(3387,iaxs)
(3388,"Received mini frame before first full voice frame\\n")
(3389,pingtime)
(3390,fr)
(3391,)
(3392,callno)
(3393,"Received packet %d, (%d, %u)
(3394,callno)
(3395,if (ies.causecode > 99)
(3396,mh->callno)
(3397,sin.sin_addr)
(3398,callno)
(3399,integer)
(3400,iaxs)
(3401,(iaxs[fr->callno]->last & 0xFFFF0000L)
(3402,context)
(3403,ast_log(LOG_NOTICE, "Rejected dial attempt from %s, request \'%s@%s\' does not exist\\n", ast_inet_ntoa(sin.sin_addr)
(3404,fh)
(3405,ts)
(3406,LOG_WARNING)
(3407,fr)
(3408,fr)
(3409,if (ies.vars)
(3410,break;)
(3411,callno)
(3412,break;)
(3413,prev)
(3414,owner)
(3415,f.subclass.integer != IAX_COMMAND_INVAL)
(3416,iaxsl)
(3417,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)
(3418,samples)
(3419,iaxs[fr->callno])
(3420,ts)
(3421,context)
(3422,if (iax_park(bridged_chan, owner, ies.called_number, context)
(3423,devicetype)
(3424,)
(3425,sizeof(*cause_code)
(3426,callno)
(3427,iaxs[fr->callno]->owner)
(3428,fr)
(3429,callno)
(3430,fr->callno)
(3431,iaxs[fr->callno]->peercapability)
(3432,callno)
(3433,thread->buf)
(3434,)
(3435,iaxs[fr->callno])
(3436,iaxs[fr->callno])
(3437,iaxs)
(3438,&iaxsl[call_to_destroy])
(3439,iaxs[fr->callno])
(3440,iax2_getformatname_multiple(tmp, sizeof(tmp)
(3441,variablestore)
(3442,1)
(3443,ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_BUSY)
(3444,sin_addr)
(3445,peer->historicms <= peer->maxms)
(3446,if (decrypted)
(3447,"Channel \'%s\' unable to transfer\\n")
(3448,if (!ast_test_flag64(iaxs[fr->callno], IAX_RECVCONNECTEDLINE)
(3449,&iaxsl[fr->callno])
(3450,format)
(3451,fr->ts = ntohl(fh->ts)
(3452,vars)
(3453,capability)
(3454,iaxs[fr->callno]->rprefs)
(3455,transfer)
(3456,fr->callno)
(3457,iaxs[fr->callno])
(3458,IAX_COMMAND_TXACC)
(3459,AST_CAUSE_NO_ROUTE_DESTINATION)
(3460,&ied0)
(3461,variablestore->inheritance)
(3462,fr)
(3463,memset(&ied0, 0, sizeof(ied0)
(3464,if (iaxs[fr->callno] && iaxs[fr->callno]->last < fr->ts)
(3465,frametype)
(3466,*fh)
(3467,owner)
(3468,bridgecallno)
(3469,sizeof(subclass)
(3470,1)
(3471,tmp2)
(3472,iaxs)
(3473,callno)
(3474,IAX_COMMAND_ACK)
(3475,IAX_COMMAND_REJECT)
(3476,AST_FRAME_VOICE)
(3477,iaxs[fr->callno])
(3478,iaxs)
(3479,iaxs)
(3480,iaxs[fr->callno])
(3481,"Received out of order packet... (type=%d, subclass %d, ts = %d, last = %d)
(3482,ied1)
(3483,f.subclass.integer)
(3484,oseqno)
(3485,0)
(3486,if (!iaxs[fr->callno])
(3487,iaxs[fr->callno])
(3488,minivid)
(3489,if ((new_callno = make_trunk(fr->callno, 1)
(3490,)
(3491,iaxs[fr->callno]->peerformat)
(3492,sin)
(3493,subclass[40] = "")
(3494,iax2_poke_peer_s)
(3495,if (variablestore && varlist)
(3496,iaxs[fr->callno]->prefs)
(3497,fr)
(3498,)
(3499,variablestore)
(3500,callno)
(3501,f.subclass.integer != IAX_COMMAND_TXCNT)
(3502,if (iaxs[fr->callno]->transferring == TRANSFER_READY)
(3503,if (varlist)
(3504,if (res < sizeof(*fh)
(3505,"disabled")
(3506,if (!iaxs[fr->callno])
(3507,f.subclass.integer)
(3508,iaxs)
(3509,return 1;)
(3510,iaxs)
(3511,check_dcallno = 0)
(3512,)
(3513,iaxs[fr->callno]->aseqno)
(3514,if (f.frametype == AST_FRAME_VIDEO)
(3515,iaxs)
(3516,ies)
(3517,IAX_IE_FORMAT)
(3518,iaxs[fr->callno]->last_iax_message)
(3519,fr)
(3520,callno)
(3521,!ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
(3522,owner ? ast_bridged_channel(owner)
(3523,1)
(3524,integer)
(3525,if (iaxs[fr->callno]->pingtime <= peer->maxms)
(3526,fr->callno)
(3527,ast_bridged_channel(iaxs[fr->callno]->owner)
(3528,ied1)
(3529,decrypted = 1)
(3530,iaxs[fr->callno]->owner)
(3531,frames_received)
(3532,peer)
(3533,callno)
(3534,fr->callno)
(3535,0)
(3536,callno)
(3537,strlen(subclass)
(3538,iaxs[fr->callno])
(3539,fr->callno)
(3540,c)
(3541,iaxs[fr->callno]->transferring == TRANSFER_READY)
(3542,iaxs[fr->callno]->rseqno)
(3543,iaxs[fr->callno]->bridgecallno)
(3544,"I can haz IAX vars? w00t\\n")
(3545,fr->callno)
(3546,callno)
(3547,&iaxs[fr->callno]->dcx)
(3548,ast_debug(1, "Acking anyway\\n")
(3549,iaxsl[fr->callno])
(3550,fr)
(3551,iaxs)
(3552,iaxs[fr->callno]->capability)
(3553,iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_READY)
(3554,fr)
(3555,IAX_COMMAND_TXCNT)
(3556,iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension")
(3557,iax2_variable_datastore_info)
(3558,IAX_COMMAND_PONG)
(3559,fr)
(3560,iaxs)
(3561,)
(3562,callno)
(3563,fd)
(3564,)
(3565,f.data.ptr)
(3566,fr)
(3567,fr)
(3568,variablestore)
(3569,&ies)
(3570,0)
(3571,fr->callno)
(3572,fr)
(3573,empty)
(3574,iaxs[fr->callno]->owner)
(3575,)
(3576,callno)
(3577,iaxs[fr->callno])
(3578,if (inaddrcmp(&sin, &iaxs[fr->callno]->addr)
(3579,fr->callno)
(3580,)
(3581,subclass)
(3582,peer->maxms)
(3583,iaxs[fr->callno])
(3584,fr)
(3585,sizeof(tmp1)
(3586,iaxs[fr->callno])
(3587,ied0)
(3588,fr)
(3589,iaxs[fr->callno])
(3590,subclass)
(3591,frametype)
(3592,varlist)
(3593,f)
(3594,fr->iseqno)
(3595,fh->oseqno)
(3596,f.frametype)
(3597,iaxs[fr->callno])
(3598,break;)
(3599,)
(3600,iaxs)
(3601,callno)
(3602,memset(&ied0, 0, sizeof(ied0)
(3603,IAX_ALREADYGONE)
(3604,f.subclass.integer)
(3605,AST_FRAME_IAX)
(3606,0)
(3607,0)
(3608,AST_CAUSE_BEARERCAPABILITY_NOTAVAIL)
(3609,callno)
(3610,tmp2)
(3611,iseqno)
(3612,iaxs[fr->callno])
(3613,IAX_COMMAND_UNQUELCH)
(3614,iaxs[fr->callno]->addr)
(3615,presentation)
(3616,vars)
(3617,fr)
(3618,prev)
(3619,fh->ts)
(3620,fr->callno)
(3621,fr->ts += test_resync)
(3622,callno)
(3623,fh)
(3624,ts)
(3625,fr->callno)
(3626,iaxs)
(3627,iaxs)
(3628,ied0.buf)
(3629,iaxs[fr->callno])
(3630,iaxs[fr->callno]->state)
(3631,ies)
(3632,(f.subclass.integer != IAX_COMMAND_UNQUELCH )
(3633,iax2_getformatname_multiple(tmp2, sizeof(tmp2)
(3634,iaxs[fr->callno])
(3635,iaxs)
(3636,)
(3637,ntohs(mh->callno)
(3638,ast_party_connected_line_init(&connected)
(3639,fr)
(3640,iaxs[fr->callno])
(3641,fr)
(3642,call_to_destroy)
(3643,fr)
(3644,fr)
(3645,fr)
(3646,peer)
(3647,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(3648,f.subclass.format)
(3649,&pref)
(3650,iaxs[fr->callno])
(3651,IAX_FLAG_FULL)
(3652,fr)
(3653,fr)
(3654,data_size)
(3655,fr)
(3656,)
(3657,variablestore->inheritance)
(3658,(ntohs(fh->dcallno)
(3659,3)
(3660,vh->zeros)
(3661,)
(3662,iseqno)
(3663,)
(3664,peer->pokefreqok)
(3665,fr)
(3666,ast_variables_destroy(ies.vars)
(3667,NULL)
(3668,iaxs[fr->callno])
(3669,f)
(3670,subclass)
(3671,if(!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(3672,&sin)
(3673,fr->callno)
(3674,iaxs)
(3675,iaxfrdup2(fr)
(3676,iaxs)
(3677,thread)
(3678,AST_CHANNEL_NAME)
(3679,iaxs[fr->callno])
(3680,using_prefs = ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(3681,exten)
(3682,ied0)
(3683,AST_FORMAT_SLINEAR)
(3684,variablestore->data = varlist)
(3685,var)
(3686,iseqno)
(3687,ast_mutex_lock(&iaxsl[fr->callno])
(3688,peer)
(3689,iaxs)
(3690,fr->callno)
(3691,peer)
(3692,peerformat)
(3693,owner)
(3694,tmp3)
(3695,fr)
(3696,!minivid)
(3697,cur)
(3698,callno)
(3699,fr->callno)
(3700,1)
(3701,iaxs[fr->callno]->peercallno)
(3702,if (strcasecmp(iaxs[fr->callno]->exten, "TBD")
(3703,f.frametype == AST_FRAME_VIDEO)
(3704,0)
(3705,IAX_IE_CAUSE)
(3706,iaxdebug)
(3707,subclass)
(3708,iaxs)
(3709,iaxs)
(3710,subclass)
(3711,if (!iaxs[fr->callno])
(3712,0)
(3713,fr->callno)
(3714,iaxs[fr->callno]->owner)
(3715,if ((peer->lastms < 0)
(3716,IAX_COMMAND_PONG)
(3717,f.subclass)
(3718,1)
(3719,connected.id.number)
(3720,callno)
(3721,callno)
(3722,ast_debug(1, "Simulating frame ts resync, was %u now %u\\n", fr->ts, fr->ts + test_resync)
(3723,fh)
(3724,subclass)
(3725,fh->csub >> 6)
(3726,name)
(3727,fr->callno)
(3728,owner)
(3729,sizeof(*mh)
(3730,fr->callno)
(3731,iaxsl[fr->callno])
(3732,ies.vars)
(3733,iaxs[fr->callno])
(3734,fr)
(3735,fr->ts + test_resync)
(3736,iaxs)
(3737,IAX_COMMAND_REJECT)
(3738,iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno)
(3739,peerformat)
(3740,fr->callno)
(3741,0)
(3742,ied0.buf)
(3743,f)
(3744,refresh)
(3745,callno)
(3746,fr)
(3747,variablestore->data)
(3748,vars)
(3749,"Accepted AUTHENTICATED TBD call from %s\\n")
(3750,caller_pref_buf)
(3751,f.subclass.integer != IAX_COMMAND_VNAK)
(3752,decrypt_frame(fr->callno, fh, &f, &res)
(3753,bridgecallno)
(3754,IAX_ALREADYGONE)
(3755,EVENT_FLAG_SYSTEM)
(3756,reg)
(3757,cause_code->chan_name)
(3758,ast_strlen_zero(iaxs[fr->callno]->secret)
(3759,iaxsl[fr->callno])
(3760,iaxs)
(3761,iaxs)
(3762,iaxs)
(3763,context)
(3764,iaxs[fr->callno]->cid_num)
(3765,thread)
(3766,if (ies.vars)
(3767,fr)
(3768,iaxs)
(3769,iaxs[fr->callno])
(3770,f)
(3771,ies)
(3772,iaxs[fr->callno]->peerformat)
(3773,fr->iseqno)
(3774,fr->callno)
(3775,iaxs)
(3776,iaxs[fr->callno]->prefs)
(3777,IAX_CODEC_NOPREFS)
(3778,callno)
(3779,DATASTORE_INHERIT_FOREVER)
(3780,iaxs[fr->callno]->peerformat)
(3781,iaxs[fr->callno]->owner)
(3782,f.subclass.integer != IAX_COMMAND_TXREADY)
(3783,sizeof(*mh)
(3784,)
(3785,fr->callno)
(3786,fr->callno)
(3787,bridgecallno)
(3788,iaxs[fr->callno]->outkey)
(3789,buf)
(3790,ies)
(3791,fr->callno)
(3792,send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
(3793,ast_channel_readformat(iaxs[fr->callno]->owner)
(3794,LOG_NOTICE)
(3795,iaxs)
(3796,ts)
(3797,iaxs[fr->callno]->bridgecallno)
(3798,"<unknown>")
(3799,iaxs)
(3800,schedule_delivery(duped_fr, updatehistory, 0, &fr->ts)
(3801,ast_clear_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART)
(3802,0)
(3803,prev)
(3804,return 1;)
(3805,type)
(3806,ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability \'%s\'/\'%s\' incompatible with our capability \'%s\'.\\n",\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tast_inet_ntoa(sin.sin_addr)
(3807,fr->callno)
(3808,)
(3809,iaxs)
(3810,authenticate_reply(iaxs[fr->callno], &iaxs[fr->callno]->addr, &ies, iaxs[fr->callno]->secret, iaxs[fr->callno]->outkey)
(3811,using_prefs = "mine")
(3812,test_resync)
(3813,f)
(3814,(x != iaxs[fr->callno]->oseqno)
(3815,iaxs[fr->callno])
(3816,callno)
(3817,f.subclass)
(3818,&ies)
(3819,fr->callno)
(3820,iaxs[fr->callno])
(3821,(ntohs(mh->ts)
(3822,peercapability)
(3823,((f.subclass.integer != IAX_COMMAND_ACK)
(3824,cause_code)
(3825,ies.causecode)
(3826,rprefs)
(3827,fr)
(3828,fr->callno)
(3829,sizeof(tmp1)
(3830,sin.sin_addr)
(3831,send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_FWDATA, 0, ied0.buf, ied0.pos, -1)
(3832,sin_addr)
(3833,iaxs[iaxs[fr->callno]->bridgecallno])
(3834,f.subclass.integer)
(3835,NULL)
(3836,subclass)
(3837,fr->iseqno)
(3838,iaxsl)
(3839,callno)
(3840,cid_num)
(3841,iseqno)
(3842,iaxs[fr->callno]->iseqno ||\n\\n\\t\\t\\t\\t((f.subclass.integer != IAX_COMMAND_TXCNT)
(3843,iaxs[fr->callno])
(3844,fr->callno)
(3845,)
(3846,callno)
(3847,fr->callno)
(3848,callno)
(3849,fr->callno)
(3850,hold_signaling)
(3851,if (iaxs[fr->callno]->pingtime > peer->maxms)
(3852,1)
(3853,fr)
(3854,connected)
(3855,break;)
(3856,iaxs)
(3857,IAX_CALLENCRYPTED(iaxs[fr->callno])
(3858,iaxs[fr->callno])
(3859,ies.serviceident && sin.sin_addr.s_addr)
(3860,fr->callno)
(3861,integer)
(3862,ies.calltokendata)
(3863,f.frametype == AST_FRAME_IAX && (f.subclass.integer == IAX_COMMAND_REGREQ || f.subclass.integer == IAX_COMMAND_REGREL)
(3864,fr)
(3865,iax2_getformatname(format)
(3866,iaxs[fr->callno]->last)
(3867,iaxs[fr->callno]->oseqno)
(3868,fr->callno)
(3869,calltokendata)
(3870,if (!dcallno && iax2_allow_new(f.frametype, f.subclass.integer, 1)
(3871,iaxs[fr->callno]->transferring = TRANSFER_MREADY)
(3872,)
(3873,iaxs[fr->callno])
(3874,iaxs[fr->callno])
(3875,fr->ts = (iaxs[fr->callno]->last & 0xFFFF8000L)
(3876,fr->callno)
(3877,fr->iseqno)
(3878,ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num)
(3879,fr->callno)
(3880,1)
(3881,exten)
(3882,fr)
(3883,data_size)
(3884,prev)
(3885,vars)
(3886,iaxs[fr->callno])
(3887,&iaxsl[fr->callno])
(3888,sin)
(3889,cause_code->ast_cause)
(3890,fr)
(3891,new_peercallno && new_peercallno != iaxs[fr->callno]->peercallno)
(3892,fr)
(3893,callno)
(3894,f)
(3895,ast_bridged_channel(iaxs[fr->callno]->owner)
(3896,tmp3)
(3897,memset(&ied0, 0, sizeof(ied0)
(3898,1)
(3899,fr->callno)
(3900,inkeys)
(3901,varlist = ast_calloc(1, sizeof(*varlist)
(3902,send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1)
(3903,callno)
(3904,(f.subclass.integer != IAX_COMMAND_INVAL)
(3905,ied0)
(3906,peer->smoothing && peer->lastms < 0)
(3907,&dpcache)
(3908,1)
(3909,fr)
(3910,codec_prefs)
(3911,iaxs[fr->callno])
(3912,callno)
(3913,pbx_builtin_setvar_helper(owner, "BLINDTRANSFER", ast_channel_name(bridged_chan)
(3914,ies)
(3915,NULL)
(3916,f)
(3917,fr)
(3918,f)
(3919,IAX_STATE_STARTED)
(3920,iaxs)
(3921,ts)
(3922,integer)
(3923,peer)
(3924,new_peercallno != iaxs[fr->callno]->peercallno)
(3925,fd)
(3926,f)
(3927,iaxs)
(3928,peer)
(3929,iaxs)
(3930,peercallno)
(3931,f)
(3932,ast_debug(1, "Unknown IAX command %d on %d/%d\\n", f.subclass.integer, fr->callno, iaxs[fr->callno]->peercallno)
(3933,ast_mutex_lock(&iaxsl[fr->callno])
(3934,iaxs[fr->callno])
(3935,cid_num)
(3936,f.data.ptr = empty)
(3937,ied0)
(3938,f.subclass)
(3939,subclass)
(3940,fr->callno)
(3941,)
(3942,f.subclass.integer != IAX_COMMAND_TXCNT)
(3943,fr)
(3944,)
(3945,ast_frame_byteswap_be(&f)
(3946,meta)
(3947,&ied1)
(3948,iaxs)
(3949,connected)
(3950,&sin)
(3951,called_number)
(3952,callno)
(3953,&iax2_variable_datastore_info)
(3954,)
(3955,IAX_COMMAND_REJECT)
(3956,var)
(3957,iaxs)
(3958,1)
(3959,fr)
(3960,callno)
(3961,thread)
(3962,res - sizeof(struct ast_iax2_mini_hdr)
(3963,iaxs[fr->callno] && iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno)
(3964,tmp)
(3965,var)
(3966,ies)
(3967,0)
(3968,sizeof(ied0)
(3969,dcallno != 1)
(3970,f.src)
(3971,orignative)
(3972,fr)
(3973,iaxs[fr->callno])
(3974,iaxs)
(3975,1)
(3976,format)
(3977,ied0)
(3978,0)
(3979,ast_channel_uniqueid(iaxs[fr->callno]->owner)
(3980,ast_debug(1, "Immediately destroying %d, having received reject\\n",\n\\n\\t\\t\\t\\t\\t\\tfr->callno)
(3981,pingied)
(3982,oseqno)
(3983,format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
(3984,iaxs[fr->callno]->owner)
(3985,"")
(3986,iaxs[iaxs[fr->callno]->bridgecallno]->transferring)
(3987,)
(3988,sin_addr)
(3989,name)
(3990,sin)
(3991,if (ies.calltoken && ies.calltokendata)
(3992,ies.serviceident && sin.sin_addr.s_addr)
(3993,)
(3994,var)
(3995,format)
(3996,"PeerStatus")
(3997,iaxs[fr->callno]->oseqno)
(3998,)
(3999,(unsigned char)
(4000,iaxs[fr->callno]->owner)
(4001,fr->callno)
(4002,fr->callno)
(4003,NULL)
(4004,callno)
(4005,*fr)
(4006,ies.calltokendata)
(4007,&connected)
(4008,fr->callno)
(4009,ied1)
(4010,ied0)
(4011,iaxs[fr->callno]->owner)
(4012,fr->callno)
(4013,callno)
(4014,iaxs[fr->callno])
(4015,iaxs[fr->callno]->exten)
(4016,(f.subclass.integer != IAX_COMMAND_TXCNT)
(4017,1)
(4018,iaxs[fr->callno])
(4019,voiceformat)
(4020,iaxs[fr->callno]->bridgecallno)
(4021,iaxs)
(4022,AST_FRAME_IAX)
(4023,iaxs[fr->callno]->owner)
(4024,iax_ie_append_byte(&ied0, IAX_IE_IAX_UNKNOWN, f.subclass.integer)
(4025,c)
(4026,fr->callno)
(4027,ies)
(4028,fh->dcallno)
(4029,fr->callno)
(4030,fr)
(4031,callno)
(4032,&ies)
(4033,callno)
(4034,fr->ts)
(4035,rprefs)
(4036,reg)
(4037,ies.called_number)
(4038,spawn_dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num)
(4039,oseqno)
(4040,iaxs)
(4041,fr)
(4042,IAX_COMMAND_TXCNT)
(4043,fr->callno)
(4044,iaxs[fr->callno]->last < fr->ts)
(4045,updatehistory)
(4046,iaxs)
(4047,chan_name)
(4048,ts)
(4049,if (!iaxs[fr->callno])
(4050,callno)
(4051,calc_timestamp(iaxs[fr->callno], 0, &f)
(4052,fr)
(4053,f.data.ptr = thread->buf + sizeof(struct ast_iax2_full_hdr)
(4054,fr)
(4055,iaxs[fr->callno])
(4056,fr->callno)
(4057,var->next = iaxs[fr->callno]->iaxvars)
(4058,callno)
(4059,iaxs)
(4060,callno)
(4061,fh)
(4062,iaxs)
(4063,fr)
(4064,*newvar = ast_var_assign(var->name, var->value)
(4065,0)
(4066,ies.called_number)
(4067,callno)
(4068,ast_log(LOG_NOTICE, "Rejected connect attempt from %s, who was trying to reach \'%s@%s\'\\n", ast_inet_ntoa(sin.sin_addr)
(4069,sizeof(ied0)
(4070,fr->callno)
(4071,connected.id.number.str)
(4072,fr->callno)
(4073,ies)
(4074,1)
(4075,iaxs)
(4076,)
(4077,using_prefs = "reqonly")
(4078,thread)
(4079,iaxs[fr->callno])
(4080,bridgecallno)
(4081,&iaxs[fr->callno]->state)
(4082,id)
(4083,"I can haz IAX vars, but they is no good :-(\\n")
(4084,-1)
(4085,ast_mutex_unlock(&iaxsl[fr->callno])
(4086,capability)
(4087,fr->callno)
(4088,ast_test_flag64(iaxs[fr->callno], IAX_ENCRYPTED)
(4089,fr->ts)
(4090,var)
(4091,peer)
(4092,iaxs)
(4093,ies)
(4094,f)
(4095,var = var->next)
(4096,0)
(4097,name)
(4098,ast_getformatname(&f.subclass.format)
(4099,IAX_IE_FORMAT2)
(4100,iaxs[fr->callno])
(4101,tmp2)
(4102,0)
(4103,callno)
(4104,*orignative = ast_format_cap_dup(ast_channel_nativeformats(iaxs[fr->callno]->owner)
(4105,memset(&ied0, 0, sizeof(ied0)
(4106,callno)
(4107,iaxs)
(4108,peer->pokeexpire)
(4109,1)
(4110,tmp)
(4111,)
(4112,callno)
(4113,ied0)
(4114,peer)
(4115,varlist)
(4116,fr->callno)
(4117,iaxs[iaxs[fr->callno]->bridgecallno])
(4118,f.subclass.format)
(4119,f.subclass)
(4120,buf)
(4121,using_prefs = "disabled")
(4122,ast_variables_destroy(ies.vars)
(4123,x)
(4124,iaxdebug)
(4125,update_registry(&sin, fr->callno, ies.devicetype, fd, ies.refresh)
(4126,&ied0)
(4127,tmp1)
(4128,f.subclass)
(4129,fr)
(4130,sin)
(4131,fr)
(4132,frametype)
(4133,ast_mutex_unlock(&iaxsl[call_to_destroy])
(4134,sin)
(4135,IAX_COMMAND_TXREJ)
(4136,iaxs[fr->callno]->peercapability)
(4137,subclass)
(4138,ptr)
(4139,tmp1)
(4140,"Async goto not applicable on call %d\\n")
(4141,f)
(4142,"Accepting DIAL from %s, formats = %s\\n")
(4143,fr)
(4144,state)
(4145,fh)
(4146,iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
(4147,f.offset = 0)
(4148,iaxs[fr->callno])
(4149,fr->ts)
(4150,iaxs[fr->callno]->peercapability)
(4151,tmp2)
(4152,fh)
(4153,iaxs[fr->callno] && iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno)
(4154,iaxsl[fr->callno])
(4155,fr->callno)
(4156,iaxs)
(4157,fr->callno)
(4158,connected.id)
(4159,ast_variables_destroy(ies.vars)
(4160,DATASTORE_INHERIT_FOREVER)
(4161,ast_debug(1, "Cancelling transmission of packet %d\\n", x)
(4162,ies.iax_unknown)
(4163,fr)
(4164,callno)
(4165,owner)
(4166,1)
(4167,iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner)
(4168,fr->oseqno)
(4169,break;)
(4170,tmp)
(4171,iaxs)
(4172,fr->oseqno)
(4173,0)
(4174,&iaxsl[fr->callno])
(4175,addr)
(4176,fr->callno)
(4177,var)
(4178,sizeof(*fh)
(4179,fr)
(4180,pref)
(4181,callno)
(4182,f.frametype)
(4183,iax2_getformatname_multiple(tmp, sizeof(tmp)
(4184,ast_datastore_alloc(&iax2_variable_datastore_info, NULL)
(4185,subclass)
(4186,iaxs[fr->callno]->initid)
(4187,transferring)
(4188,iaxs[fr->callno])
(4189,fr->callno)
(4190,iaxs[fr->callno])
(4191,ies.devicetype)
(4192,src)
(4193,tmp2)
(4194,vars)
(4195,dcallno)
(4196,var)
(4197,1)
(4198,fr->callno)
(4199,callno)
(4200,f)
(4201,iaxs[fr->callno])
(4202,dp)
(4203,case IAX_COMMAND_PING:)
(4204,iaxs[fr->callno]->transferring = TRANSFER_MEDIA)
(4205,f.subclass.integer != IAX_COMMAND_TXACC)
(4206,0)
(4207,)
(4208,data)
(4209,variablestore->inheritance = DATASTORE_INHERIT_FOREVER)
(4210,memset(&pref, 0, sizeof(pref)
(4211,calltokendata)
(4212,fr->callno)
(4213,ied1)
(4214,!iaxs[fr->callno])
(4215,ts)
(4216,)
(4217,f)
(4218,callno)
(4219,f.subclass.integer)
(4220,secret)
(4221,thread->buf[res - 1] != \'\\0\')
(4222,iax2_getformatname_multiple(tmp1, sizeof(tmp1)
(4223,"reqonly")
(4224,fh->iseqno)
(4225,&iaxsl[fr->callno])
(4226,serviceident)
(4227,callno)
(4228,res - 1)
(4229,fr)
(4230,ast_variables_destroy(ies.vars)
(4231,iaxs[fr->callno]->oseqno)
(4232,fr->callno)
(4233,fr)
(4234,fr)
(4235,subclass)
(4236,variablestore && varlist)
(4237,)
(4238,1)
(4239,ntohs(fh->dcallno)
(4240,if ((cur = AST_LIST_LAST(&frame_queue[fr->callno])
(4241,ies)
(4242,fr)
(4243,0xFFFF0000L)
(4244,iseqno)
(4245,(f.frametype == AST_FRAME_VOICE)
(4246,iseqno)
(4247,fr)
(4248,LOG_WARNING)
(4249,iaxs[fr->callno]->peercapability)
(4250,fr)
(4251,case IAX_COMMAND_ACK:)
(4252,pref = iaxs[fr->callno]->prefs)
(4253,!format)
(4254,f)
(4255,fr)
(4256,callno)
(4257,callno)
(4258,connected.id)
(4259,vars)
(4260,dcallno)
(4261,case IAX_COMMAND_TXACC:)
(4262,tmp)
(4263,callno)
(4264,pos)
(4265,peercapability)
(4266,buf)
(4267,IAX_COMMAND_TXREADY)
(4268,callno)
(4269,next)
(4270,f.subclass.integer)
(4271,sin_addr)
(4272,iaxs[fr->callno])
(4273,iaxs[fr->callno])
(4274,newvar)
(4275,1)
(4276,iaxsl)
(4277,f.subclass.integer)
(4278,fr)
(4279,callno)
(4280,fr->callno)
(4281,subclass)
(4282,f.frametype != AST_FRAME_IAX)
(4283,fh->csub == IAX_COMMAND_TXREJ)
(4284,ast_channel_name(owner)
(4285,f.frametype == AST_FRAME_IAX && f.subclass.integer == IAX_COMMAND_POKE)
(4286,capability)
(4287,iaxs[fr->callno])
(4288,iaxs)
(4289,(peer->lastms < 0)
(4290,fr)
(4291,integer)
(4292,updatehistory = 0)
(4293,owner)
(4294,0)
(4295,iax2_getformatname_multiple(tmp2, sizeof(tmp2)
(4296,frame_queue)
(4297,callno)
(4298,callno)
(4299,ast_test_flag64(&globalflags, IAX_ALLOWFWDOWNLOAD)
(4300,tmp3)
(4301,&iaxsl[fr->callno])
(4302,if (iaxs[fr->callno]->owner)
(4303,ied0)
(4304,ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\\n")
(4305,1)
(4306,0)
(4307,)
(4308,iaxs[fr->callno])
(4309,f.subclass.integer)
(4310,sizeof(*vh)
(4311,fh->csub == IAX_COMMAND_HANGUP\n\\n\\t\\t\\t|| fh->csub == IAX_COMMAND_REJECT\n\\n\\t\\t\\t|| fh->csub == IAX_COMMAND_REGREJ\n\\n\\t\\t\\t|| fh->csub == IAX_COMMAND_TXREJ)
(4312,ies)
(4313,variablestore->inheritance = DATASTORE_INHERIT_FOREVER)
(4314,iaxs[fr->callno])
(4315,IAX_COMMAND_REJECT)
(4316,using_prefs)
(4317,callno)
(4318,fr)
(4319,fr->callno)
(4320,ast_channel_datastore_add(c, variablestore)
(4321,ied1.pos)
(4322,iaxs)
(4323,f)
(4324,if (authdebug)
(4325,callno)
(4326,iax_parse_ies(&ies, thread->buf + sizeof(struct ast_iax2_full_hdr)
(4327,iaxs[fr->callno]->state)
(4328,iaxs)
(4329,ast_datastore_alloc(&iax2_variable_datastore_info, NULL)
(4330,0)
(4331,iaxs)
(4332,iax2_queue_frame(fr->callno, &hangup_fr)
(4333,f.subclass.integer != IAX_COMMAND_TXREL)
(4334,new_peercallno)
(4335,mh)
(4336,callno)
(4337,fr->callno)
(4338,f)
(4339,iaxs)
(4340,format = 0)
(4341,AST_CONTROL_CONNECTED_LINE)
(4342,connected.id.name)
(4343,!newvar)
(4344,fr->iseqno)
(4345,vars)
(4346,iaxs[fr->callno])
(4347,if ((ntohs(mh->callno)
(4348,iaxs)
(4349,iaxs[fr->callno])
(4350,cur->retries)
(4351,owner)
(4352,ast_devstate_changed(AST_DEVICE_NOT_INUSE, "IAX2/%s", peer->name)
(4353,ast_channel_caller(iaxs[fr->callno]->owner)
(4354,callno)
(4355,"PeerStatus")
(4356,-1)
(4357,f.subclass)
(4358,iaxs)
(4359,)
(4360,memset(&ies, 0, sizeof(ies)
(4361,fr)
(4362,sin.sin_addr)
(4363,callno)
(4364,f)
(4365,iaxs)
(4366,iaxs[fr->callno])
(4367,ast_test_flag64(iaxs[fr->callno], IAX_ENCRYPTED)
(4368,2)
(4369,IAX_COMMAND_ACK)
(4370,if (iaxs[fr->callno] && ast_test_flag64(iaxs[fr->callno], IAX_ENCRYPTED)
(4371,f.subclass)
(4372,fr)
(4373,f)
(4374,IAX_COMMAND_TXCNT)
(4375,return 1;)
(4376,authdebug)
(4377,ies)
(4378,fr->callno)
(4379,f.data.ptr = thread->buf + sizeof(*mh)
(4380,f.subclass)
(4381,fr->callno)
(4382,iaxs[fr->callno])
(4383,iaxs[fr->callno])
(4384,)
(4385,&sin)
(4386,iaxs[fr->callno]->chosenformat)
(4387,smoothing)
(4388,ies.provverpres && ies.serviceident && sin.sin_addr.s_addr)
(4389,fr->callno)
(4390,iaxs[fr->callno]->owner)
(4391,fr->callno)
(4392,fr)
(4393,f.subclass)
(4394,ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
(4395,ptr)
(4396,f)
(4397,(cur = AST_LIST_LAST(&frame_queue[fr->callno])
(4398,fr->iseqno)
(4399,if (prev)
(4400,~IAX_FLAG_FULL)
(4401,duped_fr = iaxfrdup2(fr)
(4402,ast_channel_writeformat(iaxs[fr->callno]->owner)
(4403,uncompress_subclass(fh->csub)
(4404,iaxs[fr->callno])
(4405,iaxs[fr->callno]->iaxvars)
(4406,)
(4407,iaxs)
(4408,ies.codec_prefs)
(4409,iaxs)
(4410,f.subclass.integer)
(4411,if (iaxs[fr->callno]->owner && authdebug)
(4412,fh)
(4413,f.subclass.integer)
(4414,0)
(4415,res)
(4416,peercapability)
(4417,fr->callno)
(4418,fr)
(4419,IAX_IE_CALLNO)
(4420,iaxs[fr->callno])
(4421,varlist)
(4422,ast_channel_unref(owner)
(4423,ast_debug(1, "IAX subclass %d received\\n", f.subclass.integer)
(4424,f.subclass.integer)
(4425,frametype)
(4426,fr->callno)
(4427,f)
(4428,callno)
(4429,IAX_STATE_STARTED | IAX_STATE_TBD)
(4430,fr)
(4431,fr->callno)
(4432,ts)
(4433,&iaxsl[fr->callno])
(4434,ast_test_flag64(iaxs[fr->callno], IAX_RECVCONNECTEDLINE)
(4435,ies.format)
(4436,ast_log(LOG_WARNING, "Rejected connect attempt.  No secret present while force encrypt enabled.\\n")
(4437,callno)
(4438,fr)
(4439,frametype)
(4440,AST_CAUSE_BEARERCAPABILITY_NOTAVAIL)
(4441,iaxs[fr->callno])
(4442,)
(4443,ies)
(4444,)
(4445,format = iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)
(4446,fr)
(4447,fr)
(4448,)
(4449,ies.vars)
(4450,CACHE_FLAG_TRANSMITTED)
(4451,iaxs[fr->callno])
(4452,send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, NULL, 0, -1)
(4453,iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
(4454,fr)
(4455,iaxs)
(4456,callno)
(4457,callno)
(4458,fr)
(4459,callno)
(4460,iaxs)
(4461,AST_FRAME_IAX)
(4462,context)
(4463,maxms)
(4464,ast_debug(1, "For call=%d, set last=%d\\n", fr->callno, fr->ts)
(4465,ies)
(4466,fr->callno)
(4467,f.subclass.integer != IAX_COMMAND_ACK)
(4468,f.frametype)
(4469,fr)
(4470,send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
(4471,owner)
(4472,f.subclass.integer)
(4473,var = ies.vars)
(4474,iaxs[fr->callno]->owner)
(4475,send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
(4476,callno)
(4477,&iaxs[fr->callno]->addr)
(4478,number)
(4479,frametype)
(4480,AST_FRAME_IAX)
(4481,)
(4482,fr)
(4483,fr)
(4484,iaxs)
(4485,0)
(4486,"caller")
(4487,ast_inet_ntoa(sin.sin_addr)
(4488,sin_addr)
(4489,subclass)
(4490,cid_num = ast_strdupa(iaxs[fr->callno]->cid_num)
(4491,frametype)
(4492,callno)
(4493,TRANSFER_BEGIN)
(4494,fr->callno)
(4495,iax2_getformatname(iaxs[fr->callno]->peerformat)
(4496,owner)
(4497,fr->callno)
(4498,res)
(4499,peer->historicms)
(4500,ies.calltoken)
(4501,f.data)
(4502,)
(4503,iaxs[fr->callno])
(4504,if (res < thread->buf_size)
(4505,iaxs[fr->callno]->peercallno)
(4506,memset(&ied1, 0, sizeof(ied1)
(4507,ast_variables_destroy(ies.vars)
(4508,0x1)
(4509,historicms)
(4510,f.datalen)
(4511,struct ast_iax2_full_hdr)
(4512,AST_CAUSE_BEARERCAPABILITY_NOTAVAIL)
(4513,0)
(4514,fr)
(4515,f.data.ptr)
(4516,iaxs[fr->callno]->chosenformat)
(4517,iaxs)
(4518,fr)
(4519,sin)
(4520,iaxs[fr->callno]->transferring = TRANSFER_RELEASED)
(4521,iaxs[fr->callno])
(4522,format = 0)
(4523,name)
(4524,fr->ts)
(4525,ied0)
(4526,"I can haz iaxvars, but they is no good.  :-(\\n")
(4527,ies)
(4528,if ((x != iaxs[fr->callno]->oseqno)
(4529,frametype)
(4530,IAX_RECVCONNECTEDLINE)
(4531,iaxs[fr->callno]->bridgecallno)
(4532,iaxs)
(4533,res)
(4534,ies)
(4535,callno)
(4536,res - sizeof(*fh)
(4537,addr)
(4538,iaxs)
(4539,iaxs)
(4540,iaxs[fr->callno])
(4541,struct ast_iax2_video_hdr *)
(4542,state)
(4543,x)
(4544,fr->af.subclass)
(4545,fr)
(4546,data_size)
(4547,iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
(4548,if (iaxs[fr->callno]->rseqno >= iaxs[fr->callno]->oseqno || (fr->iseqno >= iaxs[fr->callno]->rseqno && fr->iseqno < iaxs[fr->callno]->oseqno)
(4549,fr->callno)
(4550,IAX_CODEC_NOCAP)
(4551,break;)
(4552,iaxs)
(4553,iaxs[fr->callno]->peerformat)
(4554,id)
(4555,iaxs[fr->callno])
(4556,iaxs[fr->callno])
(4557,fr)
(4558,check_access(fr->callno, &sin, &ies)
(4559,"TBD")
(4560,send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied1.buf, ied1.pos, -1)
(4561,IAX_QUELCH)
(4562,0)
(4563,AST_FRAME_IAX)
(4564,iaxs[fr->callno])
(4565,(f.frametype == AST_FRAME_VOICE)
(4566,iax2_destroy(fr->callno)
(4567,iaxs[fr->callno])
(4568,callno)
(4569,fr)
(4570,complete_dpreply(iaxs[fr->callno], &ies)
(4571,f.subclass.integer == IAX_COMMAND_POKE)
(4572,3)
(4573,if (iaxdebug)
(4574,iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL)
(4575,orignative)
(4576,ies.vars)
(4577,mh)
(4578,sched)
(4579,ntohs(mh->callno)
(4580,fr->callno)
(4581,iaxs[fr->callno])
(4582,iax2_getformatname_multiple(tmp3, sizeof(tmp3)
(4583,f.subclass.integer != IAX_COMMAND_INVAL)
(4584,f)
(4585,sizeof(ied0)
(4586,&iaxs[fr->callno]->rprefs)
(4587,f.data.ptr)
(4588,sin_addr)
(4589,historicms)
(4590,peer)
(4591,fr)
(4592,AST_FRAME_IAX)
(4593,iaxs[fr->callno])
(4594,(f.subclass.integer != IAX_COMMAND_ACK)
(4595,iax2_destroy(fr->callno)
(4596,ast_devstate_changed(AST_DEVICE_UNAVAILABLE, "IAX2/%s", peer->name)
(4597,peerformat)
(4598,IAX_COMMAND_REJECT)
(4599,callno)
(4600,NULL)
(4601,iaxs[fr->callno])
(4602,tmp2)
(4603,integer)
(4604,iaxs[fr->callno]->rseqno >= iaxs[fr->callno]->oseqno || (fr->iseqno >= iaxs[fr->callno]->rseqno && fr->iseqno < iaxs[fr->callno]->oseqno)
(4605,iaxs[fr->callno]->owner)
(4606,iaxs[fr->callno]->state)
(4607,owner)
(4608,4096)
(4609,fr)
(4610,fr->iseqno < iaxs[fr->callno]->oseqno)
(4611,iaxs)
(4612,callno)
(4613,if (!fr->callno)
(4614,iaxs[fr->callno]->context)
(4615,capability)
(4616,iaxs[fr->callno])
(4617,ast_format_to_old_bitfield(&f.subclass.format)
(4618,make_trunk(fr->callno, 1)
(4619,bridged_chan = owner ? ast_bridged_channel(owner)
(4620,send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_PONG, fr->ts, pingied.buf, pingied.pos, -1)
(4621,fr)
(4622,1)
(4623,ied0)
(4624,f.frametype == AST_FRAME_IAX)
(4625,fr->callno)
(4626,f.subclass.format)
(4627,!iaxs[fr->callno])
(4628,f.data.ptr)
(4629,variablestore)
(4630,ies.vars)
(4631,ast_mutex_unlock(&iaxsl[fr->callno])
(4632,f.subclass.integer != IAX_COMMAND_TXACC)
(4633,fr)
(4634,iaxs)
(4635,fr)
(4636,owner)
(4637,&ies)
(4638,ast_mutex_unlock(&iaxsl[fr->callno])
(4639,data_size)
(4640,dcallno)
(4641,x != iaxs[fr->callno]->oseqno)
(4642,if (!iaxs[fr->callno])
(4643,1)
(4644,ast_channel_name(bridged_chan)
(4645,fr)
(4646,peer->pokeexpire > -1)
(4647,fr->callno)
(4648,AST_FRAME_IAX)
(4649,callno)
(4650,fr->ts)
(4651,pos)
(4652,1)
(4653,callno)
(4654,iaxs)
(4655,fr)
(4656,fr)
(4657,callno)
(4658,ast_string_field_set(iaxs[fr->callno], exten, ies.called_number ? ies.called_number : "s")
(4659,fr)
(4660,if (peer->pokeexpire == -1)
(4661,1)
(4662,AST_STATE_RING)
(4663,ies)
(4664,fh->iseqno)
(4665,fd)
(4666,f.subclass.format)
(4667,AST_FRAME_IAX)
(4668,f.subclass)
(4669,f)
(4670,)
(4671,iaxs)
(4672,)
(4673,sin.sin_addr)
(4674,TRANSFER_RELEASED)
(4675,NULL)
(4676,callno)
(4677,sin)
(4678,iaxs)
(4679,variablestore && varlist)
(4680,fh)
(4681,IAX_COMMAND_ACK)
(4682,iaxs[fr->callno])
(4683,fr)
(4684,f)
(4685,ies)
(4686,)
(4687,iaxs[fr->callno])
(4688,IAX_COMMAND_ACK)
(4689,iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
(4690,peer->historicms > peer->maxms)
(4691,callno)
(4692,iaxs[fr->callno]->prefs)
(4693,AST_FRAME_IAX)
(4694,f.subclass)
(4695,mh)
(4696,if (check_access(fr->callno, &sin, &ies)
(4697,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(4698,ies.vars)
(4699,if (!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)
(4700,fh->dcallno)
(4701,f)
(4702,cid_num)
(4703,maxms)
(4704,dcallno = ntohs(fh->dcallno)
(4705,connected.id.name.presentation)
(4706,fr)
(4707,sizeof(*fh)
(4708,fr)
(4709,ies.causecode > 9)
(4710,fr)
(4711,fr->callno)
(4712,IAX_FLAG_FULL)
(4713,tmp1)
(4714,iaxs)
(4715,ast_log(LOG_WARNING, "Received mini frame before first full video frame\\n")
(4716,using_prefs)
(4717,1)
(4718,exists = ast_exists_extension(NULL, context, exten, 1, cid_num)
(4719,if (((f.subclass.integer != IAX_COMMAND_ACK)
(4720,iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
(4721,fh)
(4722,ntohl(fh->ts)
(4723,&iaxs[fr->callno]->rprefs)
(4724,iaxs[fr->callno])
(4725,iaxsl[fr->callno])
(4726,ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr)
(4727,name)
(4728,capability)
(4729,f.subclass.format)
(4730,calling_pres)
(4731,fr)
(4732,f.subclass.integer)
(4733,&iaxs[fr->callno]->prefs)
(4734,ied0.pos)
(4735,peer->maxms)
(4736,iaxs)
(4737,if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD)
(4738,tmp1)
(4739,sizeof(host_pref_buf)
(4740,caller_pref_buf)
(4741,iaxs[fr->callno])
(4742,f.subclass.integer)
(4743,if (ies.codec_prefs)
(4744,fr)
(4745,!decrypted)
(4746,iaxs[fr->callno]->mohsuggest)
(4747,iaxs)
(4748,callno)
(4749,fr->iseqno)
(4750,f.subclass)
(4751,fr)
(4752,sizeof(ied0)
(4753,iaxs)
(4754,retries)
(4755,fr)
(4756,if (strcmp(iaxs[fr->callno]->exten, "TBD")
(4757,iaxs[fr->callno])
(4758,fr->callno)
(4759,&iaxsl[fr->callno])
(4760,if (!iaxs[fr->callno])
(4761,addr)
(4762,fr)
(4763,ies.vars)
(4764,iaxs[fr->callno])
(4765,mh->ts)
(4766,IAX_COMMAND_TXREL)
(4767,peer->historicms = iaxs[fr->callno]->pingtime)
(4768,"Datalen < 0?\\n")
(4769,sizeof(*fh)
(4770,ies)
(4771,AST_FRAME_TEXT)
(4772,ntohs(meta->metacmd)
(4773,fr->callno)
(4774,iaxsl[fr->callno])
(4775,IAX_COMMAND_REJECT)
(4776,)
(4777,fr)
(4778,fr)
(4779,capability)
(4780,peerpoke)
(4781,f.subclass.integer)
(4782,iaxs)
(4783,iaxs[fr->callno])
(4784,&ied0)
(4785,)
(4786,callno)
(4787,fr)
(4788,fr)
(4789,new_callno)
(4790,IAX_COMMAND_REJECT)
(4791,frametype)
(4792,send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREADY, 0, ied1.buf, ied1.pos, -1)
(4793,!format)
(4794,ies)
(4795,fr)
(4796,iaxs)
(4797,ied0)
(4798,fr->callno)
(4799,ast_debug(1, "Immediately destroying %d, having received hangup\\n", fr->callno)
(4800,ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
(4801,iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_FACILITY_NOT_SUBSCRIBED)
(4802,exists = 0)
(4803,varlist)
(4804,callno)
(4805,try_transfer(iaxs[fr->callno], &ies)
(4806,callno)
(4807,transferring)
(4808,iaxs)
(4809,mh->callno)
(4810,DATASTORE_INHERIT_FOREVER)
(4811,fr)
(4812,)
(4813,owner)
(4814,fr->iseqno)
(4815,-1)
(4816,ied1)
(4817,f)
(4818,ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested \'%s\' incompatible with our capability \'%s\'.\\n",\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tast_inet_ntoa(sin.sin_addr)
(4819,f.subclass)
(4820,iaxs[fr->callno])
(4821,fr->callno)
(4822,iaxs[fr->callno])
(4823,)
(4824,iaxs[fr->callno])
(4825,REG_STATE_REJECTED)
(4826,iaxs)
(4827,0)
(4828,fr->callno)
(4829,ts)
(4830,&ies)
(4831,iaxs[fr->callno]->reg)
(4832,IAX_COMMAND_UNSUPPORT)
(4833,thread)
(4834,sin_addr)
(4835,AST_FRAME_IAX)
(4836,fr->callno)
(4837,var->name)
(4838,ies.vars)
(4839,ies)
(4840,fr->ts)
(4841,context)
(4842,var = var->next)
(4843,memset(&ied0, 0, sizeof(ied0)
(4844,ts)
(4845,iaxs)
(4846,)
(4847,fr->callno)
(4848,ast_bridged_channel(owner)
(4849,IAX_STATE_AUTHENTICATED)
(4850,fr->callno)
(4851,iaxs)
(4852,iaxs)
(4853,&ies)
(4854,iaxs)
(4855,callno)
(4856,ntohs(mh->callno)
(4857,if (cur->transfer)
(4858,format)
(4859,ast_channel_caller(iaxs[fr->callno]->owner)
(4860,callno)
(4861,variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL)
(4862,"BLINDTRANSFER")
(4863,fr)
(4864,fr->callno)
(4865,ast_channel_readformat(iaxs[fr->callno]->owner)
(4866,IAX_IE_CAUSE)
(4867,pref)
(4868,tmp3)
(4869,iaxs)
(4870,callno)
(4871,callno)
(4872,ast_set_write_format(iaxs[fr->callno]->owner, ast_channel_writeformat(iaxs[fr->callno]->owner)
(4873,return 1;)
(4874,var)
(4875,f.subclass)
(4876,f.subclass.integer = 0)
(4877,integer)
(4878,subclass)
(4879,iaxs[fr->callno]->iseqno++)
(4880,iaxs[iaxs[fr->callno]->bridgecallno])
(4881,f)
(4882,)
(4883,ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request \'%s@%s\' does not exist\\n", ast_inet_ntoa(sin.sin_addr)
(4884,)
(4885,iaxs)
(4886,ied0.buf)
(4887,ies)
(4888,ied1)
(4889,iaxs[fr->callno]->oseqno)
(4890,f.len = 0)
(4891,case IAX_COMMAND_AUTHREP:)
(4892,fh)
(4893,tmpfmt)
(4894,iaxs)
(4895,fr)
(4896,ied1)
(4897,f.subclass)
(4898,fr)
(4899,ies.causecode > 99)
(4900,iaxs[fr->callno])
(4901,AST_FRAME_IAX)
(4902,callno)
(4903,state)
(4904,subclass)
(4905,call_to_destroy)
(4906,iaxs)
(4907,iaxs)
(4908,authdebug)
(4909,ast_channel_name(bridged_chan)
(4910,pos)
(4911,using_prefs)
(4912,iaxs[fr->callno])
(4913,fr)
(4914,sin)
(4915,!dcallno && iax2_allow_new(f.frametype, f.subclass.integer, 1)
(4916,delayreject)
(4917,&ied0)
(4918,iaxs[fr->callno])
(4919,iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno)
(4920,ied0.buf)
(4921,iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
(4922,iax2_lock_owner(fr->callno)
(4923,iaxs)
(4924,memset(&pref, 0, sizeof(pref)
(4925,!iaxs[fr->callno])
(4926,LOG_WARNING)
(4927,AST_FRAME_IAX)
(4928,IAX_STATE_TBD)
(4929,iaxs)
(4930,regstate)
(4931,integer)
(4932,set_hangup_source_and_cause(fr->callno, ies.causecode)
(4933,"Format for call is %s\\n")
(4934,ast_channel_datastore_add(c, variablestore)
(4935,fr)
(4936,1)
(4937,iaxs[iaxs[fr->callno]->bridgecallno]->transferring = 0)
(4938,fr)
(4939,fr)
(4940,addr)
(4941,IAX_COMMAND_TXREL)
(4942,fr->callno)
(4943,sin_port)
(4944,if (owner)
(4945,((f.subclass.integer != IAX_COMMAND_INVAL)
(4946,fr)
(4947,peer)
(4948,prev)
(4949,iaxs[fr->callno])
(4950,&pingied)
(4951,1)
(4952,connected)
(4953,fr)
(4954,fh->ts)
(4955,ts)
(4956,ast_format_id_from_old_bitfield(iaxs[fr->callno]->videoformat)
(4957,ies.vars)
(4958,IAX_COMMAND_FWDOWNL)
(4959,iaxs[fr->callno])
(4960,for (x=iaxs[fr->callno]->rseqno; x != fr->iseqno; x++)
(4961,fr)
(4962,AST_FRAME_IAX)
(4963,iaxs[fr->callno]->bridgecallno)
(4964,datalen)
(4965,iax2_getformatname_multiple(tmp2, sizeof(tmp2)
(4966,iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
(4967,"Unknown IAX command %d on %d/%d\\n")
(4968,iaxs[fr->callno])
(4969,ptr)
(4970,IAX_COMMAND_VNAK)
(4971,IAX_COMMAND_UNQUELCH)
(4972,ast_variables_destroy(ies.vars)
(4973,callno)
(4974,!fr->callno || !iaxs[fr->callno])
(4975,NULL)
(4976,handle_call_token(fh, &ies, &sin, fd)
(4977,iaxs[fr->callno]->peerformat)
(4978,fr)
(4979,iaxsl)
(4980,&globalflags)
(4981,hangup_fr)
(4982,fr->callno)
(4983,"Hold")
(4984,delayreject)
(4985,!iaxs[fr->callno]->first_iax_message)
(4986,iaxs)
(4987,1)
(4988,peer)
(4989,AST_CAUSE_CONGESTION)
(4990,name)
(4991,1)
(4992,*vh)
(4993,f)
(4994,ies.vars)
(4995,iaxs[fr->callno]->peerformat)
(4996,subclass)
(4997,callno)
(4998,exten)
(4999,"Rejected connect attempt from %s, request \'%s@%s\' does not exist\\n")
(5000,var)
(5001,f)
(5002,capability)
(5003,iaxs[fr->callno]->capability)
(5004,code)
(5005,if (!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)
(5006,f)
(5007,f.subclass == IAX_COMMAND_ACCEPT ||\n\\n\\t\\t\\t\\t\\t\\t\\t\\t f.subclass == IAX_COMMAND_REJECT)
(5008,frametype)
(5009,thread)
(5010,f)
(5011,sizeof(host_pref_buf)
(5012,iaxs[fr->callno])
(5013,iaxs)
(5014,iaxs)
(5015,)
(5016,tmpfmt)
(5017,tmp1)
(5018,&ied0)
(5019,1)
(5020,callno)
(5021,"Rejected call to %s, format %s incompatible with our capability %s.\\n")
(5022,fr)
(5023,fr)
(5024,vars)
(5025,ast_alloca(sizeof(*fr)
(5026,ied0)
(5027,f.subclass.integer != IAX_COMMAND_TXCNT)
(5028,if (cur->final)
(5029,tmp1)
(5030,iaxs[fr->callno])
(5031,callno)
(5032,rprefs)
(5033,f.subclass.integer != IAX_COMMAND_CALLTOKEN)
(5034,orignative)
(5035,callno)
(5036,iaxs[fr->callno])
(5037,fh->ts)
(5038,iaxs[fr->callno])
(5039,)
(5040,-1)
(5041,pref)
(5042,)
(5043,)
(5044,break;)
(5045,sin)
(5046,iaxsl)
(5047,sizeof(*fh)
(5048,ast_mutex_lock(&iaxsl[fr->callno])
(5049,name)
(5050,iaxs)
(5051,iaxs)
(5052,&iaxsl[fr->callno])
(5053,peer)
(5054,iaxs[fr->callno])
(5055,IAX_IE_CAUSECODE)
(5056,fr->callno)
(5057,peer->callno)
(5058,iaxs[fr->callno]->bridgecallno)
(5059,sin_addr)
(5060,subclass)
(5061,state)
(5062,"Memory allocation error while processing IAX2 variables\\n")
(5063,fd)
(5064,VERBOSE_PREFIX_4)
(5065,)
(5066,mh)
(5067,ies)
(5068,break;)
(5069,ast_parking_ext_valid(ies.called_number, owner, context)
(5070,iaxs[fr->callno])
(5071,ts)
(5072,next)
(5073,error)
(5074,iaxs[fr->callno]->state)
(5075,callno)
(5076,ies.calltoken && ies.calltokendata)
(5077,iaxs[fr->callno])
(5078,ast_set_flag64(iaxs[fr->callno], IAX_ALREADYGONE)
(5079,fr)
(5080,ied1)
(5081,fr)
(5082,"Immediately destroying %d, having received reject\\n")
(5083,fh)
(5084,fh->csub == IAX_COMMAND_REJECT)
(5085,iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec")
(5086,ies.cause)
(5087,res)
(5088,iaxs)
(5089,ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD)
(5090,1)
(5091,next)
(5092,case IAX_COMMAND_CALLTOKEN:)
(5093,using_prefs)
(5094,send_command(iaxs[fr->callno], AST_FRAME_CONTROL, AST_CONTROL_PROGRESS, 0, NULL, 0, -1)
(5095,fr)
(5096,peer->pokeexpire)
(5097,)
(5098,iaxs[fr->callno])
(5099,f.data)
(5100,-1)
(5101,iaxs[fr->callno]->capability)
(5102,fr)
(5103,rprefs)
(5104,iaxs[fr->callno]->capability)
(5105,IAX_FORCE_ENCRYPT)
(5106,integer)
(5107,fr->callno)
(5108,sin_addr)
(5109,fr->ts)
(5110,fr->callno)
(5111,case IAX_COMMAND_HANGUP:)
(5112,callno)
(5113,callno)
(5114,1)
(5115,fr)
(5116,ies)
(5117,fr->callno)
(5118,-1)
(5119,-1)
(5120,IAX_STATE_STARTED)
(5121,vars)
(5122,af)
(5123,fr->callno > 0)
(5124,memset(&ied1, 0, sizeof(ied1)
(5125,)
(5126,iaxs[fr->callno]->capability)
(5127,AST_LIST_HEAD_INIT(varlist)
(5128,&iaxs[fr->callno]->rprefs)
(5129,pref = iaxs[fr->callno]->prefs)
(5130,callno)
(5131,iaxs)
(5132,memset(&ied0, 0, sizeof(ied0)
(5133,fr)
(5134,iaxs)
(5135,IAX_ALLOWFWDOWNLOAD)
(5136,"IAX subclass %d received\\n")
(5137,pos)
(5138,&ied0)
(5139,)
(5140,mh->callno)
(5141,&ied0)
(5142,LOG_NOTICE)
(5143,0)
(5144,fr->callno)
(5145,iaxs[fr->callno]->owner)
(5146,fd)
(5147,iaxs[fr->callno])
(5148,if (iaxs[iaxs[fr->callno]->bridgecallno]->transferring)
(5149,fr)
(5150,subclass)
(5151,iaxs[fr->callno]->secret)
(5152,fr)
(5153,dcallno = 0)
(5154,break;)
(5155,fr)
(5156,f.subclass.integer = uncompress_subclass(fh->csub)
(5157,bridged_chan)
(5158,exten)
(5159,callno)
(5160,secret)
(5161,ast_cause)
(5162,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)
(5163,pos)
(5164,fr->callno)
(5165,1)
(5166,send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXREL, 0, ied0.buf, ied0.pos, -1)
(5167,AST_FRAME_IAX)
(5168,iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->callno)
(5169,iaxs)
(5170,fr)
(5171,IAX_COMMAND_REJECT)
(5172,fr->callno)
(5173,bridged_chan)
(5174,)
(5175,devicetype)
(5176,f)
(5177,break;)
(5178,iaxs[fr->callno])
(5179,caller_pref_buf)
(5180,peer)
(5181,(f.frametype == AST_FRAME_VIDEO)
(5182,"Rejected connect attempt from %s, request \'%s@%s\' does not exist\\n")
(5183,"Really destroying %d, having been acked on final message\\n")
(5184,iaxs[fr->callno])
(5185,newvar)
(5186,fr)
(5187,transferring)
(5188,buf)
(5189,iaxs[fr->callno]->pingtime)
(5190,pref)
(5191,"Packet arrived out of order (expecting %d, got %d)
(5192,&iax2_variable_datastore_info)
(5193,fr->callno)
(5194,context)
(5195,iax_ie_append_short(&ied1, IAX_IE_CALLNO, iaxs[fr->callno]->peercallno)
(5196,var = ies.vars)
(5197,f.subclass)
(5198,minivid)
(5199,NULL)
(5200,NULL)
(5201,fr)
(5202,NEW_PREVENT)
(5203,"Releasing %s and %s\\n")
(5204,strcmp(iaxs[fr->callno]->exten, "TBD")
(5205,cur)
(5206,fr)
(5207,callno)
(5208,ast_channel_unlock(iaxs[fr->callno]->owner)
(5209,fr->callno)
(5210,iaxs)
(5211,if (variablestore)
(5212,&ied0)
(5213,"Failed to park call \'%s\'\\n")
(5214,return 1;)
(5215,iaxs)
(5216,1)
(5217,fr)
(5218,)
(5219,callno)
(5220,2)
(5221,buf)
(5222,callno)
(5223,fh->csub)
(5224,callno)
(5225,peerformat)
(5226,f.subclass.integer == IAX_COMMAND_REGREQ)
(5227,fr->callno)
(5228,sizeof(host_pref_buf)
(5229,ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_AUTHENTICATED)
(5230,32)
(5231,if (!format)
(5232,c)
(5233,1)
(5234,tmp1)
(5235,&iaxsl[fr->callno])
(5236,csub)
(5237,f.frametype == AST_FRAME_VOICE)
(5238,ied0.pos)
(5239,ast_debug(1, "Packet arrived out of order (expecting %d, got %d)
(5240,calltoken)
(5241,AST_FRAME_CONTROL)
(5242,1)
(5243,f.subclass)
(5244,iaxs[fr->callno])
(5245,-1)
(5246,"Rejecting packet from \'%s.%d\' that is flagged as a video frame but is too short\\n")
(5247,fr)
(5248,f.data)
(5249,iaxs[fr->callno])
(5250,iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_MREADY)
(5251,strcasecmp(iaxs[fr->callno]->exten, "TBD")
(5252,)
(5253,if ((iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_READY)
(5254,)
(5255,f)
(5256,f.frametype)
(5257,outoforder)
(5258,uncompress_subclass(fh->csub & ~0x40)
(5259,cid_name)
(5260,IAX_COMMAND_PONG)
(5261,cur)
(5262,callno)
(5263,format)
(5264,callno)
(5265,variablestore)
(5266,callno)
(5267,var)
(5268,connected.id.name.valid)
(5269,f.subclass.integer != IAX_COMMAND_TXCNT)
(5270,tmp2)
(5271,TRANSFER_MEDIA)
(5272,ies)
(5273,)
(5274,callno)
(5275,iaxs)
(5276,sin_addr)
(5277,)
(5278,f)
(5279,fh)
(5280,ast_mutex_unlock(&iaxsl[fr->callno])
(5281,fd)
(5282,store_by_peercallno(iaxs[fr->callno])
(5283,iaxs[fr->callno])
(5284,s_addr)
(5285,sched)
(5286,fr)
(5287,ied0)
(5288,iaxs)
(5289,if (prev)
(5290,f.subclass.integer)
(5291,callno)
(5292,fr)
(5293,"TBD")
(5294,f.subclass.integer == IAX_COMMAND_ACK && dcallno == 1)
(5295,0)
(5296,0)
(5297,mh->callno)
(5298,iaxs[iaxs[fr->callno]->bridgecallno])
(5299,iaxs)
(5300,iaxs)
(5301,&iaxsl[fr->callno])
(5302,thread->buf)
(5303,LOG_NOTICE)
(5304,rseqno)
(5305,fr)
(5306,var)
(5307,0)
(5308,owner)
(5309,f.data)
(5310,var)
(5311,fr)
(5312,ied0.pos)
(5313,if (!ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num)
(5314,iaxsl)
(5315,)
(5316,new_peercallno)
(5317,iaxs[fr->callno])
(5318,iaxs)
(5319,fr)
(5320,ies)
(5321,LOG_WARNING)
(5322,sin)
(5323,oseqno)
(5324,iaxs[iaxs[fr->callno]->bridgecallno]->transferring)
(5325,fr)
(5326,save_osptoken(fr, &ies)
(5327,exten = ast_strdupa(iaxs[fr->callno]->exten)
(5328,iaxs)
(5329,metacmd)
(5330,0)
(5331,using_prefs = "caller")
(5332,iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
(5333,peercallno)
(5334,callno)
(5335,f.subclass.format)
(5336,fr)
(5337,var->value)
(5338,callno)
(5339,callno)
(5340,callno)
(5341,vars)
(5342,fr->callno)
(5343,"caller")
(5344,if (iax_parse_ies(&ies, thread->buf + sizeof(struct ast_iax2_full_hdr)
(5345,fr->af)
(5346,call_to_destroy = 0)
(5347,fr)
(5348,callno)
(5349,f.frametype)
(5350,owner)
(5351,connected.id)
(5352,if (!ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->chosenformat, NULL)
(5353,&ied0)
(5354,ied0)
(5355,fr->callno)
(5356,cur)
(5357,frametype)
(5358,&sin)
(5359,ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
(5360,pref)
(5361,sin.sin_family = AF_INET)
(5362,using_prefs = "mine")
(5363,cause_code)
(5364,AST_DEVICE_UNAVAILABLE)
(5365,ENOTCONN)
(5366,f.samples)
(5367,var)
(5368,newvar)
(5369,fr->callno)
(5370,IAX_FLAG_RETRANS)
(5371,fr->callno)
(5372,callno)
(5373,ies.causecode)
(5374,f.subclass.integer != IAX_COMMAND_TXACC)
(5375,f.samples)
(5376,callno)
(5377,iaxs)
(5378,fr)
(5379,AST_CAUSE_BUSY)
(5380,subclass)
(5381,1)
(5382,f.data.ptr = NULL)
(5383,fr->callno)
(5384,fr)
(5385,IAX_COMMAND_INVAL)
(5386,ied0.buf)
(5387,iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension")
(5388,iaxs[fr->callno])
(5389,fr)
(5390,iaxs)
(5391,iaxs[fr->callno]->prefs)
(5392,IAX_STATE_AUTHENTICATED)
(5393,fr)
(5394,fr->callno)
(5395,variablestore)
(5396,ied1.buf)
(5397,!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)
(5398,f.frametype != AST_FRAME_VOICE)
(5399,fr)
(5400,callno)
(5401,fr)
(5402,fr->callno)
(5403,iaxsl)
(5404,causecode)
(5405,ied0)
(5406,0)
(5407,\'\\0\')
(5408,iaxs[iaxs[fr->callno]->bridgecallno]->transferring)
(5409,format)
(5410,"BLINDTRANSFER")
(5411,iaxsl)
(5412,iaxs)
(5413,&fr->af)
(5414,fr->callno)
(5415,fr)
(5416,iaxs[fr->callno]->rseqno = fr->iseqno)
(5417,fh)
(5418,"Unable to negotiate codec")
(5419,fr->callno)
(5420,iaxs[fr->callno])
(5421,iaxs[fr->callno])
(5422,f.subclass)
(5423,codec_prefs)
(5424,IAX_COMMAND_FWDATA)
(5425,IAX_PROVISION)
(5426,subclass)
(5427,if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)
(5428,f.frametype)
(5429,f)
(5430,fr)
(5431,ies.codec_prefs)
(5432,sin.sin_addr)
(5433,iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner)
(5434,-1)
(5435,iaxs[fr->callno]->addr.sin_addr)
(5436,peer)
(5437,peerformat)
(5438,break;)
(5439,src)
(5440,0)
(5441,iaxs[fr->callno]->peerformat)
(5442,AST_FRAME_IAX)
(5443,callno)
(5444,ied1)
(5445,iaxs[fr->callno]->videoformat)
(5446,sizeof(ies)
(5447,fr)
(5448,&f)
(5449,fr)
(5450,callno)
(5451,fr->callno)
(5452,fr->ts)
(5453,callno)
(5454,ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)
(5455,connected)
(5456,call_to_destroy)
(5457,addr)
(5458,ies)
(5459,ies)
(5460,sin)
(5461,f.subclass.integer != IAX_COMMAND_FWDOWNL)
(5462,next)
(5463,iaxs[fr->callno])
(5464,fr)
(5465,NULL)
(5466,f)
(5467,f.subclass)
(5468,c)
(5469,)
(5470,pref = iaxs[fr->callno]->rprefs)
(5471,callno)
(5472,format)
(5473,transferring)
(5474,&iaxs[fr->callno]->state)
(5475,iaxs[fr->callno])
(5476,fr)
(5477,fr->callno)
(5478,callno)
(5479,mh->callno)
(5480,if (test_resync)
(5481,iseqno)
(5482,iaxs)
(5483,f.frametype)
(5484,iaxs[iaxs[fr->callno]->bridgecallno])
(5485,iaxs[fr->callno])
(5486,fr->callno)
(5487,fh)
(5488,cause)
(5489,fr->callno)
(5490,AST_LIST_UNLOCK(&dpcache)
(5491,using_prefs = "reqonly")
(5492,callno)
(5493,owner)
(5494,return 1;)
(5495,callno)
(5496,ies.vars)
(5497,fr)
(5498,f.subclass.integer != IAX_COMMAND_TXCNT)
(5499,send_command(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXMEDIA, 0, ied0.buf, ied0.pos, -1)
(5500,fr)
(5501,ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)
(5502,AST_FRAME_IAX)
(5503,fh)
(5504,fr)
(5505,peerformat)
(5506,sizeof(tmp3)
(5507,iaxs[fr->callno])
(5508,integer)
(5509,IAX_COMMAND_ACK)
(5510,check_provisioning(&sin, fd, ies.serviceident, ies.provver)
(5511,if (iaxs[fr->callno]->owner)
(5512,format = iax2_best_codec(iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
(5513,"disabled")
(5514,iaxs)
(5515,fh->type == AST_FRAME_IAX &&\n\\n\\t\\t\\t(fh->csub == IAX_COMMAND_HANGUP\n\\n\\t\\t\\t|| fh->csub == IAX_COMMAND_REJECT\n\\n\\t\\t\\t|| fh->csub == IAX_COMMAND_REGREJ\n\\n\\t\\t\\t|| fh->csub == IAX_COMMAND_TXREJ)
(5516,iaxs[fr->callno]->peerformat)
(5517,break;)
(5518,format)
(5519,fr->callno)
(5520,NULL)
(5521,callno)
(5522,)
(5523,&ied0)
(5524,if (!iaxs[fr->callno] || !iaxs[fr->callno]->owner)
(5525,iaxs)
(5526,f.subclass)
(5527,using_prefs)
(5528,callno)
(5529,break;)
(5530,inaddrcmp(&sin, &iaxs[fr->callno]->addr)
(5531,)
(5532,iaxs[fr->callno])
(5533,iaxs[fr->callno])
(5534,if (call_to_destroy)
(5535,ies)
(5536,iaxs)
(5537,f.subclass)
(5538,&iaxsl[fr->callno])
(5539,ies)
(5540,iaxs[fr->callno]->voiceformat > 0)
(5541,fr)
(5542,if (!newvar)
(5543,iaxs[fr->callno])
(5544,prefs)
(5545,ast_log(LOG_NOTICE, "Rejected connect attempt from %s, request \'%s@%s\' does not exist\\n", ast_inet_ntoa(sin.sin_addr)
(5546,iaxs)
(5547,context = ast_strdupa(iaxs[fr->callno]->context)
(5548,fr->ts)
(5549,ast_channel_nativeformats(iaxs[fr->callno]->owner)
(5550,ied0.buf)
(5551,TRANSFER_READY)
(5552,iaxs)
(5553,&iaxs[fr->callno]->state)
(5554,uncompress_subclass(fh->csub)
(5555,fr->callno)
(5556,send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1)
(5557,iaxs)
(5558,test_resync)
(5559,sizeof(ied1)
(5560,iaxs)
(5561,callno)
(5562,)
(5563,fh)
(5564,ast_variables_destroy(ies.vars)
(5565,IAX_FLAG_RETRANS)
(5566,sizeof(tmp3)
(5567,iax2_destroy(fr->callno)
(5568,subclass)
(5569,0)
(5570,callno)
(5571,fr)
(5572,iaxs)
(5573,iaxs[fr->callno]->calling_pres)
(5574,fr)
(5575,ntohs(mh->ts)
(5576,voiceformat)
(5577,fr->callno)
(5578,fr)
(5579,subclass)
(5580,iaxs[fr->callno]->owner)
(5581,if (iaxs[fr->callno]->last < fr->ts &&\n\\n                            f.subclass.integer != IAX_COMMAND_ACK &&\n\\n                            f.subclass.integer != IAX_COMMAND_PONG &&\n\\n                            f.subclass.integer != IAX_COMMAND_LAGRP)
(5582,AST_FRAME_IAX)
(5583,fr->callno)
(5584,fr->callno)
(5585,sin)
(5586,bridged_chan && ies.called_number)
(5587,fr)
(5588,f.subclass)
(5589,callno)
(5590,callno)
(5591,fr)
(5592,sched)
(5593,return 1;)
(5594,ies.causecode)
(5595,&iaxs[fr->callno]->state)
(5596,integer)
(5597,iaxs[fr->callno]->rprefs)
(5598,iaxs[fr->callno])
(5599,fr)
(5600,if (ast_parking_ext_valid(ies.called_number, owner, context)
(5601,mount_callid)
(5602,dp_lookup(fr->callno, iaxs[fr->callno]->context, ies.called_number, iaxs[fr->callno]->cid_num, 1)
(5603,iaxs)
(5604,fh->csub == IAX_COMMAND_REJECT\n\\n\\t\\t\\t|| fh->csub == IAX_COMMAND_REGREJ\n\\n\\t\\t\\t|| fh->csub == IAX_COMMAND_TXREJ)
(5605,f.datalen)
(5606,format)
(5607,iaxs)
(5608,thread->buf)
(5609,callno)
(5610,integer)
(5611,)
(5612,0x8000)
(5613,sin.sin_addr)
(5614,iaxs[fr->callno]->peercapability)
(5615,*fh)
(5616,datalen)
(5617,LOG_NOTICE)
(5618,f)
(5619,frametype)
(5620,pos)
(5621,"Packet Decrypt Failed!\\n")
(5622,iaxs)
(5623,)
(5624,callno)
(5625,iaxsl)
(5626,iaxs)
(5627,iaxs)
(5628,sin)
(5629,f.frametype == AST_FRAME_VIDEO)
(5630,iaxs)
(5631,IAX_STATE_STARTED | IAX_STATE_TBD | IAX_STATE_AUTHENTICATED)
(5632,ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner)
(5633,f.datalen = 0)
(5634,case IAX_COMMAND_DPREP:)
(5635,fr)
(5636,IAX_COMMAND_TXMEDIA)
(5637,callno)
(5638,return 1;)
(5639,ies)
(5640,fr->callno)
(5641,iaxs)
(5642,callno)
(5643,callno)
(5644,buf)
(5645,iaxs[fr->callno])
(5646,iaxs[fr->callno])
(5647,ied0.buf)
(5648,&ied0)
(5649,fr->callno)
(5650,str)
(5651,callno)
(5652,iaxs[fr->callno]->last_iax_message = f.subclass.integer)
(5653,f)
(5654,iaxsl[call_to_destroy])
(5655,fr->outoforder)
(5656,register_verify(fr->callno, &sin, &ies)
(5657,)
(5658,sin_addr)
(5659,tmp)
(5660,ast_channel_name(iaxs[fr->callno]->owner)
(5661,subclass)
(5662,fr)
(5663,callno)
(5664,1)
(5665,iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)
(5666,ies)
(5667,)
(5668,varlist)
(5669,fr->callno)
(5670,ied0.pos)
(5671,sizeof(ied1)
(5672,pos)
(5673,iaxs)
(5674,callno)
(5675,peercallno)
(5676,ied0)
(5677,"<Unknown>")
(5678,fr)
(5679,memset(&ied1, 0, sizeof(ied1)
(5680,iaxs)
(5681,using_prefs)
(5682,f)
(5683,iaxs[fr->callno]->reg)
(5684,ies.vars)
(5685,fr)
(5686,sin.sin_addr)
(5687,fr->callno)
(5688,f.frametype)
(5689,iaxs[fr->callno]->last)
(5690,f.subclass.integer != IAX_COMMAND_ACK &&\n\\n                            f.subclass.integer != IAX_COMMAND_PONG &&\n\\n                            f.subclass.integer != IAX_COMMAND_LAGRP)
(5691,sizeof(ied0)
(5692,break;)
(5693,*variablestore = NULL)
(5694,ied0)
(5695,codec_prefs)
(5696,ast_channel_name(iaxs[fr->callno]->owner)
(5697,fr)
(5698,iaxs[fr->callno])
(5699,callno)
(5700,owner)
(5701,format)
(5702,callno)
(5703,subclass)
(5704,iaxs[fr->callno]->context)
(5705,fr->callno)
(5706,sizeof(tmp2)
(5707,integer)
(5708,iax2_destroy(call_to_destroy)
(5709,break;)
(5710,fr)
(5711,IAX_STATE_TBD)
(5712,ies.provverpres && ies.serviceident && sin.sin_addr.s_addr)
(5713,ies)
(5714,fr)
(5715,NULL)
(5716,iaxs[fr->callno]->owner)
(5717,bridgecallno)
(5718,fr)
(5719,fr->callno)
(5720,tmp)
(5721,fr->callno)
(5722,iaxs[fr->callno])
(5723,if (iaxs[fr->callno])
(5724,pref)
(5725,callno)
(5726,ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf)
(5727,thread->buf[res++] = \'\\0\')
(5728,callno)
(5729,ast_variables_destroy(ies.vars)
(5730,)
(5731,fr)
(5732,var)
(5733,ast_mutex_unlock(&iaxsl[fr->callno])
(5734,-1)
(5735,callno)
(5736,f.samples)
(5737,sin)
(5738,fr)
(5739,0 + peer->historicms)
(5740,var)
(5741,causecode)
(5742,)
(5743,callno)
(5744,memset(&ies, 0, sizeof(ies)
(5745,owner)
(5746,prev)
(5747,fr)
(5748,fr->callno)
(5749,)
(5750,ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\\n")
(5751,0)
(5752,iaxs[fr->callno]->peerpoke)
(5753,fr)
(5754,)
(5755,!fr->callno)
(5756,if (ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)
(5757,iax2_getformatname_multiple(tmp3, sizeof(tmp3)
(5758,if (strcmp(iaxs[fr->callno]->exten, "TBD")
(5759,callno)
(5760,f)
(5761,LOG_NOTICE)
(5762,ied0)
(5763,fr)
(5764,VERBOSE_PREFIX_4)
(5765,prev)
(5766,)
(5767,ied1)
(5768,iaxs[fr->callno])
(5769,NULL)
(5770,ts)
(5771,f)
(5772,f)
(5773,)
(5774,x = iaxs[fr->callno]->oseqno)
(5775,f.datalen = res - sizeof(*vh)
(5776,ast_set_callerid(iaxs[fr->callno]->owner,\n\\n\\t\\t\\t\\t\\tS_COR(connected.id.number.valid, connected.id.number.str, "")
(5777,!iaxs[fr->callno]->owner)
(5778,"Neat, somebody took away the channel at a magical time but i found it!\\n")
(5779,iaxs[fr->callno])
(5780,break;)
(5781,callno)
(5782,break;)
(5783,fr)
(5784,iaxs)
(5785,iaxs[fr->callno])
(5786,subclass)
(5787,callno)
(5788,if (!iaxs[fr->callno])
(5789,subclass)
(5790,&iaxsl[fr->callno])
(5791,fr)
(5792,"Registry error\\n")
(5793,fh)
(5794,callno)
(5795,fr->callno)
(5796,iaxs[fr->callno]->transferring)
(5797,)
(5798,tmp3)
(5799,0)
(5800,iaxs)
(5801,iaxs[fr->callno]->peercallno)
(5802,sizeof(tmp2)
(5803,VERBOSE_PREFIX_4)
(5804,)
(5805,sizeof(struct ast_iax2_full_hdr)
(5806,iaxs)
(5807,newvar)
(5808,NULL)
(5809,return 1;)
(5810,iaxs[fr->callno])
(5811,f.subclass.integer)
(5812,iaxs[fr->callno]->last)
(5813,fr->callno)
(5814,iaxsl)
(5815,fr)
(5816,fr)
(5817,fh->scallno)
(5818,NULL)
(5819,data_size++)
(5820,mh)
(5821,)
(5822,callno)
(5823,dcallno == 1)
(5824,0)
(5825,ied0.buf)
(5826,ts)
(5827,cur)
(5828,iaxs[fr->callno])
(5829,f.frametype = fh->type)
(5830,fr)
(5831,fr)
(5832,)
(5833,NULL)
(5834,check_dcallno = 1)
(5835,orignative)
(5836,(peer->historicms > 0)
(5837,fr)
(5838,peer)
(5839,ied0)
(5840,f.subclass)
(5841,newvar)
(5842,)
(5843,ast_channel_unlock(iaxs[fr->callno]->owner)
(5844,iaxs[fr->callno])
(5845,fr)
(5846,)
(5847,fh->type == AST_FRAME_IAX)
(5848,)
(5849,-1)
(5850,peercallno)
(5851,ast_verb(3, "Accepting AUTHENTICATED call from %s:\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t"%srequested format = %s,\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t"%srequested prefs = %s,\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t"%sactual format = %s,\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t"%shost prefs = %s,\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t"%spriority = %s\\n", \n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tast_inet_ntoa(sin.sin_addr)
(5852,iaxs[fr->callno])
(5853,"Packet Decrypt Failed!\\n")
(5854,iaxs[fr->callno])
(5855,iaxs[fr->callno]->owner)
(5856,iaxs[fr->callno]->state)
(5857,"Destroying call %d\\n")
(5858,sin)
(5859,&iaxsl[fr->callno])
(5860,if (f.subclass.integer == IAX_COMMAND_LAGRQ)
(5861,f.subclass.integer)
(5862,x = fr->iseqno)
(5863,provver)
(5864,fr)
(5865,callno)
(5866,iaxs)
(5867,iaxs[fr->callno])
(5868,f.frametype)
(5869,!format)
(5870,iaxs[fr->callno])
(5871,ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability \'%s\'/\'%s\' incompatible with our capability \'%s\'.\\n",\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tast_inet_ntoa(sin.sin_addr)
(5872,if (!inaddrcmp(&sin, &iaxs[fr->callno]->addr)
(5873,iaxs)
(5874,fr->callno)
(5875,ts)
(5876,f.subclass.integer != IAX_COMMAND_TXACC)
(5877,f)
(5878,bridged_chan)
(5879,"I don\'t know how to authenticate %s to %s\\n")
(5880,iaxs[fr->callno]->last = fr->ts)
(5881,f.frametype == AST_FRAME_IAX)
(5882,callno)
(5883,s_addr)
(5884,owner)
(5885,callno)
(5886,-1)
(5887,send_apathetic_reply(1, ntohs(fh->scallno)
(5888,callno)
(5889,fr)
(5890,capability)
(5891,iaxs)
(5892,connected)
(5893,iaxs[fr->callno]->owner)
(5894,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(5895,"ChannelType: IAX2\\r\\nUsername: %s\\r\\nStatus: Rejected\\r\\nCause: %s\\r\\n")
(5896,callno)
(5897,"TBD")
(5898,fh->csub)
(5899,username)
(5900,iaxs[fr->callno]->owner)
(5901,callno)
(5902,1)
(5903,)
(5904,iaxs)
(5905,if (f.datalen)
(5906,*prev = NULL)
(5907,f)
(5908,case IAX_COMMAND_REGACK:)
(5909,state)
(5910,if ((iaxs[fr->callno]->iseqno != fr->oseqno)
(5911,fh)
(5912,1)
(5913,iaxs[fr->callno]->peercapability)
(5914,f.frametype)
(5915,f)
(5916,AST_FRAME_VOICE)
(5917,ies)
(5918,IAX_PROVISION)
(5919,f.samples = 0)
(5920,iaxvars)
(5921,moh_suggest)
(5922,iaxs[fr->callno]->exten)
(5923,callno)
(5924,)
(5925,fr)
(5926,)
(5927,iaxs[fr->callno]->exten)
(5928,iax2_lock_owner(fr->callno)
(5929,sin)
(5930,exten)
(5931,goto immediatedial;)
(5932,var = ies.vars)
(5933,if (ast_channel_readformat(iaxs[fr->callno]->owner)
(5934,ied1)
(5935,1)
(5936,LOG_NOTICE)
(5937,)
(5938,f.subclass == IAX_COMMAND_AUTHREQ)
(5939,prev)
(5940,fr)
(5941,0)
(5942,iaxs)
(5943,datalen)
(5944,0x7fff)
(5945,minivid)
(5946,sizeof(host_pref_buf)
(5947,thread->buf_len)
(5948,using_prefs)
(5949,f.frametype == AST_FRAME_IAX)
(5950,f.subclass.integer)
(5951,IAX_IE_CAUSECODE)
(5952,ast_debug(1, "No channel, so populating IAXVARs to the pvt, as an intermediate step.\\n")
(5953,peer->name)
(5954,ast_log(LOG_ERROR, "No best format in \'%s\'???\\n", iax2_getformatname_multiple(tmp, sizeof(tmp)
(5955,subclass)
(5956,decrypted)
(5957,fr)
(5958,!iaxs[fr->callno])
(5959,peer)
(5960,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(5961,format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1)
(5962,)
(5963,iaxs)
(5964,ied1.pos)
(5965,f.frametype)
(5966,fr)
(5967,integer)
(5968,iaxs[fr->callno])
(5969,callno)
(5970,ast_channel_caller(iaxs[fr->callno]->owner)
(5971,f.subclass.integer)
(5972,TRANSFER_READY)
(5973,"")
(5974,0)
(5975,ntohs(fh->dcallno)
(5976,fr)
(5977,(f.subclass.integer != IAX_COMMAND_INVAL)
(5978,0)
(5979,peer)
(5980,ied1)
(5981,iaxs[fr->callno])
(5982,fr->callno)
(5983,&res)
(5984,fr)
(5985,fr)
(5986,fr)
(5987,capability)
(5988,-1)
(5989,variablestore)
(5990,LOG_WARNING)
(5991,send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1)
(5992,fh)
(5993,char *)
(5994,callno)
(5995,prefs)
(5996,owner)
(5997,iaxs[fr->callno]->rseqno)
(5998,fr->callno)
(5999,fr)
(6000,fr->callno)
(6001,iaxs[fr->callno]->addr)
(6002,iaxs[fr->callno])
(6003,&connected.id)
(6004,iaxs[fr->callno]->addr.sin_addr)
(6005,callno)
(6006,ast_mutex_unlock(&iaxsl[fr->callno])
(6007,(f.subclass.integer != IAX_COMMAND_TXCNT)
(6008,!(dp->flags & CACHE_FLAG_TRANSMITTED)
(6009,)
(6010,f)
(6011,iaxs)
(6012,fr)
(6013,IAX_COMMAND_TXREADY)
(6014,var->name)
(6015,1)
(6016,ast_inet_ntoa(sin.sin_addr)
(6017,name)
(6018,buf)
(6019,&f.subclass.format)
(6020,integer)
(6021,ast_inet_ntoa(sin.sin_addr)
(6022,fr->iseqno)
(6023,fr->callno)
(6024,pingied)
(6025,case IAX_COMMAND_REJECT:)
(6026,)
(6027,&ied1)
(6028,iaxs)
(6029,fr)
(6030,fr->callno)
(6031,fh->csub)
(6032,iaxs)
(6033,ntohs(mh->callno)
(6034,fr)
(6035,initid)
(6036,csub)
(6037,provverpres)
(6038,fr->callno)
(6039,iseqno)
(6040,iaxs)
(6041,pingied.pos)
(6042,1)
(6043,"Attempting media bridge of %s and %s\\n")
(6044,0)
(6045,pingtime)
(6046,ies.username)
(6047,f.subclass)
(6048,vh->ts)
(6049,&pref)
(6050,res)
(6051,afdatalen)
(6052,varlist)
(6053,iaxs[fr->callno])
(6054,fr->callno)
(6055,ast_channel_caller(iaxs[fr->callno]->owner)
(6056,iaxs[fr->callno])
(6057,fr->callno)
(6058,peercapability)
(6059,fr)
(6060,iaxs[fr->callno])
(6061,owner)
(6062,iaxsl[fr->callno])
(6063,fr->callno)
(6064,iax2_getformatname(format)
(6065,break;)
(6066,oseqno)
(6067,fr->callno)
(6068,iaxs[fr->callno])
(6069,iaxs[fr->callno]->chosenformat = format)
(6070,iaxs[fr->callno])
(6071,iaxs)
(6072,fr->callno)
(6073,f.subclass)
(6074,fr)
(6075,)
(6076,ast_format_from_old_bitfield(&f.subclass.format, (uncompress_subclass(fh->csub & ~0x40)
(6077,variablestore->inheritance = DATASTORE_INHERIT_FOREVER)
(6078,iaxs)
(6079,subclass)
(6080,fr->callno)
(6081,&tmpfmt)
(6082,format)
(6083,f)
(6084,fr->ts = (iaxs[fr->callno]->last & 0xFFFF0000L)
(6085,frametype)
(6086,frametype)
(6087,ast_codec_pref_string(&iaxs[fr->callno]->prefs, host_pref_buf, sizeof(host_pref_buf)
(6088,fr->callno)
(6089,callno)
(6090,*vh)
(6091,fr->callno)
(6092,)
(6093,iaxs)
(6094,sizeof(tmp3)
(6095,peerformat)
(6096,)
(6097,f.frametype)
(6098,sin.sin_addr.s_addr)
(6099,if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(6100,iaxs)
(6101,peer->lastms < 0)
(6102,f.offset = 0)
(6103,fr->callno)
(6104,fr->callno)
(6105,)
(6106,ies)
(6107,vars)
(6108,callno)
(6109,iaxs[fr->callno])
(6110,oseqno)
(6111,fr->callno)
(6112,IAX_CODEC_NOPREFS)
(6113,tmpfmt)
(6114,sin.sin_addr)
(6115,caller_pref_buf)
(6116,callno)
(6117,native)
(6118,subclass)
(6119,context)
(6120,callno)
(6121,f.subclass.integer)
(6122,IAX_STATE_TBD)
(6123,newvar)
(6124,iaxs)
(6125,fr->callno)
(6126,IAX_COMMAND_TXACC)
(6127,"Memory allocation error while processing IAX2 variables\\n")
(6128,fr)
(6129,callno)
(6130,buf)
(6131,if (\n\\n\\t\\t\\t ((f.subclass.integer != IAX_COMMAND_ACK)
(6132,authenticate_verify(iaxs[fr->callno], &ies)
(6133,fr)
(6134,callno)
(6135,iax2_destroy(fr->callno)
(6136,meta)
(6137,send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
(6138,last)
(6139,f)
(6140,ast_log(LOG_WARNING, "Registration failure\\n")
(6141,peer->name)
(6142,iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)
(6143,callno)
(6144,fr)
(6145,buf)
(6146,iax_outputframe(NULL, fh, 1, &sin, res - sizeof(*fh)
(6147,integer)
(6148,ast_channel_name(iaxs[fr->callno]->owner)
(6149,&iaxs[fr->callno]->state)
(6150,ies.vars = NULL)
(6151,iaxs[fr->callno]->exten)
(6152,name)
(6153,callno)
(6154,connected.id.number.presentation = iaxs[fr->callno]->calling_pres)
(6155,iaxs[fr->callno]->transferring == TRANSFER_MREADY)
(6156,iaxs[fr->callno])
(6157,-1)
(6158,fr->callno)
(6159,fr->ts)
(6160,3)
(6161,IAX_STATE_STARTED)
(6162,immediatedial:)
(6163,ptr)
(6164,vars)
(6165,IAX_COMMAND_VNAK)
(6166,sin)
(6167,iaxs[fr->callno]->bridgecallno)
(6168,AST_FRAME_IAX)
(6169,if (!format)
(6170,fr)
(6171,iaxs)
(6172,"reqonly")
(6173,iaxs[fr->callno])
(6174,new_callno = make_trunk(fr->callno, 1)
(6175,1)
(6176,ast_log(LOG_NOTICE, "Packet Decrypt Failed!\\n")
(6177,&sin)
(6178,if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)
(6179,f.frametype == AST_FRAME_VOICE)
(6180,dpcache)
(6181,ast_debug(1, "Parking call \'%s\'\\n", ast_channel_name(bridged_chan)
(6182,iaxs[fr->callno])
(6183,bridgecallno)
(6184,peercallno)
(6185,updatehistory)
(6186,callno)
(6187,ast_inet_ntoa(sin.sin_addr)
(6188,iaxs[fr->callno]->frames_received++)
(6189,iaxs[fr->callno]->owner)
(6190,fr->callno)
(6191,callno)
(6192,"mine")
(6193,fr)
(6194,(unsigned short)
(6195,fr)
(6196,ies.vars)
(6197,iaxs)
(6198,fr->callno)
(6199,ied0.buf)
(6200,fr->callno > 0)
(6201,ts = calc_timestamp(iaxs[fr->callno], 0, &fr->af)
(6202,iaxs[fr->callno])
(6203,number)
(6204,callno)
(6205,minivid)
(6206,"Unable to negotiate codec")
(6207,fr)
(6208,c = ast_iax2_new(fr->callno, AST_STATE_RING, format, NULL)
(6209,peer->lastms)
(6210,if (!ast_test_flag64(&globalflags, IAX_ALLOWFWDOWNLOAD)
(6211,"Immediately destroying %d, having received INVAL\\n")
(6212,if (iaxs[fr->callno]->reg)
(6213,"Ooh, voice format changed to \'%s\'\\n")
(6214,ast_log(LOG_WARNING, "Failed to park call \'%s\'\\n",\n\\n\\t\\t\\t\\t\\t\\t\\t\\tast_channel_name(bridged_chan)
(6215,fr->callno)
(6216,-1)
(6217,next)
(6218,fr)
(6219,caller_pref_buf)
(6220,fr->callno)
(6221,iaxs)
(6222,case IAX_COMMAND_NEW:)
(6223,fr->callno)
(6224,buf)
(6225,f)
(6226,iax2_dprequest(dp, fr->callno)
(6227,iaxs[fr->callno])
(6228,subclass)
(6229,iaxs)
(6230,ast_strdupa(iaxs[fr->callno]->context)
(6231,f)
(6232,callno)
(6233,callno)
(6234,fr->callno)
(6235,if (format)
(6236,fr->callno)
(6237,iaxs[fr->callno]->iaxvars = ies.vars)
(6238,if (iaxs[fr->callno]->owner)
(6239,unsigned char)
(6240,integer)
(6241,peer->historicms > peer->maxms)
(6242,pingtime)
(6243,1)
(6244,unsigned short)
(6245,integer)
(6246,fr->callno)
(6247,fr)
(6248,fr)
(6249,tmp)
(6250,if ( (ntohs(fh->dcallno)
(6251,last)
(6252,meta->metacmd)
(6253,0)
(6254,fr->callno)
(6255,ast_mutex_lock(&iaxsl[fr->callno])
(6256,callno)
(6257,ied1)
(6258,ast_inet_ntoa(sin.sin_addr)
(6259,iaxs[fr->callno])
(6260,if (!AST_SCHED_DEL(sched, peer->pokeexpire)
(6261,bridged_chan)
(6262,iaxs)
(6263,fr)
(6264,)
(6265,iaxs[fr->callno])
(6266,ptr)
(6267,iaxs[fr->callno]->owner)
(6268,if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(6269,)
(6270,AST_FRAME_IAX)
(6271,iaxs)
(6272,&frame_queue[fr->callno])
(6273,&connected)
(6274,sin_port)
(6275,ies.causecode)
(6276,)
(6277,1)
(6278,iax_ie_append_versioned_uint64(&ied1, IAX_IE_FORMAT2, 0, format)
(6279,iaxs[iaxs[fr->callno]->bridgecallno]->owner ? ast_channel_name(iaxs[iaxs[fr->callno]->bridgecallno]->owner)
(6280,authdebug)
(6281,using_prefs)
(6282,vars)
(6283,NULL)
(6284,return 1;)
(6285,!iaxs[fr->callno])
(6286,ies.causecode)
(6287,case IAX_COMMAND_LAGRQ:)
(6288,fr->callno)
(6289,iaxs[fr->callno])
(6290,pref)
(6291,fr)
(6292,var = var->next)
(6293,construct_rr(iaxs[fr->callno], &pingied)
(6294,iaxs)
(6295,IAX_IE_FORMAT)
(6296,iaxs)
(6297,1)
(6298,ies.called_number)
(6299,thread->buf)
(6300,vars)
(6301,iaxs)
(6302,iseqno)
(6303,callno)
(6304,subclass)
(6305,fr)
(6306,variablestore)
(6307,AST_FRAME_IAX)
(6308,f.data)
(6309,iaxs)
(6310,iaxs[fr->callno])
(6311,TRANSFER_MEDIA)
(6312,0)
(6313,subclass)
(6314,!iaxs[fr->callno])
(6315,"Receiving")
(6316,fr)
(6317,fr->callno)
(6318,fr->callno)
(6319,break;)
(6320,sizeof(ies)
(6321,ies.provver)
(6322,ies)
(6323,break;)
(6324,fh)
(6325,fr->callno)
(6326,f)
(6327,iaxs)
(6328,fr)
(6329,cause_code)
(6330,callno)
(6331,0)
(6332,callno)
(6333,iax2_queue_control_data(fr->callno, AST_CONTROL_UNHOLD, NULL, 0)
(6334,AST_FRAME_IAX)
(6335,)
(6336,iax2_getformatname_multiple(tmp2, sizeof(tmp2)
(6337,f.subclass.format.id)
(6338,data_size)
(6339,IAX_IE_CAUSE)
(6340,owner)
(6341,fr->callno)
(6342,LOG_WARNING)
(6343,oseqno)
(6344,if (ntohs(mh->callno)
(6345,ies)
(6346,iaxs[fr->callno])
(6347,)
(6348,ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability \'%s\'/\'%s\' incompatible with our capability \'%s\'.\\n",\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tast_inet_ntoa(sin.sin_addr)
(6349,&iaxsl[fr->callno])
(6350,if (iaxdebug)
(6351,pref = iaxs[fr->callno]->rprefs)
(6352,sizeof(*fh)
(6353,connected)
(6354,iaxs[fr->callno]->pingtime)
(6355,f.subclass == IAX_COMMAND_REJECT)
(6356,f.data.ptr)
(6357,fr->callno)
(6358,)
(6359,ast_mutex_unlock(&iaxsl[fr->callno])
(6360,fr->ts)
(6361,callno)
(6362,iaxs)
(6363,if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)
(6364,iaxs[fr->callno]->peerformat)
(6365,peer)
(6366,iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL)
(6367,ast_test_flag64(iaxs[fr->callno], IAX_QUELCH)
(6368,fr)
(6369,iaxs[fr->callno])
(6370,sched)
(6371,0)
(6372,fr)
(6373,callno)
(6374,return 1;)
(6375,tmp2)
(6376,f.subclass)
(6377,iaxs)
(6378,fr->callno)
(6379,fr)
(6380,buf)
(6381,ied0)
(6382,fwdesc)
(6383,format)
(6384,iaxs[fr->callno]->state)
(6385,ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)
(6386,iaxs[iaxs[fr->callno]->bridgecallno]->peercallno)
(6387,IAX_COMMAND_ACK)
(6388,ies.vars)
(6389,maxms)
(6390,ied0)
(6391,owner)
(6392,fr)
(6393,AST_CONTROL_HOLD)
(6394,iaxs[iaxs[fr->callno]->bridgecallno])
(6395,connected)
(6396,iaxsl)
(6397,fr->callno)
(6398,iaxs)
(6399,fr)
(6400,peer->lastms > -1)
(6401,IAX_STATE_STARTED)
(6402,)
(6403,fr)
(6404,buf)
(6405,meta->zeros)
(6406,if (registry_rerequest(&ies, fr->callno, &sin)
(6407,iaxs[fr->callno]->capability)
(6408,iaxs)
(6409,callno)
(6410,owner)
(6411,f)
(6412,f.frametype)
(6413,"Unable to negotiate codec")
(6414,iaxs[fr->callno]->owner)
(6415,sin_addr)
(6416,fr)
(6417,ast_strlen_zero(iaxs[fr->callno]->secret)
(6418,if (((f.subclass.integer != IAX_COMMAND_INVAL)
(6419,return 1;)
(6420,iaxs)
(6421,128)
(6422,ies)
(6423,&iaxs[fr->callno]->state)
(6424,iaxs[fr->callno])
(6425,manager_event(EVENT_FLAG_SYSTEM, "Registry", "ChannelType: IAX2\\r\\nUsername: %s\\r\\nStatus: Rejected\\r\\nCause: %s\\r\\n", iaxs[fr->callno]->reg->username, ies.cause ? ies.cause : "<unknown>")
(6426,iaxs[fr->callno])
(6427,callno)
(6428,iaxs[fr->callno]->state)
(6429,fr->callno)
(6430,fr->callno)
(6431,f.frametype)
(6432,subclass)
(6433,iaxs[fr->callno])
(6434,&iaxs[fr->callno]->state)
(6435,fr->ts)
(6436,fr)
(6437,callno)
(6438,sin.sin_addr)
(6439,ies)
(6440,ast_clear_flag64(iaxs[fr->callno], IAX_QUELCH)
(6441,if (ast_strlen_zero(iaxs[fr->callno]->secret)
(6442,iaxs[fr->callno]->owner)
(6443,)
(6444,)
(6445,exists = 0)
(6446,iaxs[fr->callno]->last & 0xFFFF0000L)
(6447,if (iaxs[fr->callno] && iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno)
(6448,0)
(6449,fr->callno)
(6450,ied0)
(6451,fr->callno)
(6452,(f.frametype == AST_FRAME_IAX)
(6453,IAX_CODEC_USER_FIRST)
(6454,fr->iseqno)
(6455,duped_fr)
(6456,0)
(6457,ies.vars)
(6458,iaxs[fr->callno]->peerformat)
(6459,iaxs)
(6460,if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->peerformat, NULL)
(6461,LOG_NOTICE)
(6462,peer->lastms)
(6463,callno)
(6464,iaxs[fr->callno])
(6465,callno)
(6466,str)
(6467,ast_format_set_video_mark(&f.subclass.format)
(6468,iaxs[fr->callno]->error = EPERM)
(6469,ied1.buf)
(6470,break;)
(6471,ast_channel_caller(iaxs[fr->callno]->owner)
(6472,c)
(6473,sin)
(6474,f.frametype)
(6475,-1)
(6476,)
(6477,iaxs)
(6478,iaxs[fr->callno]->reg->regstate)
(6479,!IAX_CALLENCRYPTED(iaxs[fr->callno])
(6480,iseqno)
(6481,f)
(6482,ies)
(6483,iaxs[iaxs[fr->callno]->bridgecallno]->owner)
(6484,callno)
(6485,fh->csub)
(6486,callno)
(6487,fr)
(6488,&ied0)
(6489,prev)
(6490,iaxsl)
(6491,fr)
(6492,ies)
(6493,context)
(6494,iaxs[fr->callno])
(6495,iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)
(6496,ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr)
(6497,owner)
(6498,fr)
(6499,videoformat)
(6500,iaxs[fr->callno])
(6501,6)
(6502,RET)
(6503,iaxs[fr->callno]->error = ENOTCONN)
(6504,iaxsl[fr->callno])
(6505,ast_party_id_presentation(&connected.id)
(6506,data)
(6507,callno)
(6508,f.subclass == IAX_COMMAND_AUTHREQ ||\n\\n\\t\\t\\t\\t\\t\\t\\t\\t f.subclass == IAX_COMMAND_ACCEPT ||\n\\n\\t\\t\\t\\t\\t\\t\\t\\t f.subclass == IAX_COMMAND_REJECT)
(6509,iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)
(6510,f.subclass.format.id)
(6511,IAX_ALREADYGONE)
(6512,ies)
(6513,fr->callno)
(6514,peer)
(6515,fr)
(6516,f)
(6517,-1)
(6518,)
(6519,if (res < sizeof(*mh)
(6520,var->next)
(6521,iaxs[fr->callno])
(6522,fr->callno)
(6523,fr->callno)
(6524,&f.subclass.format)
(6525,iaxs[fr->callno]->cid_num)
(6526,callno)
(6527,&sin)
(6528,iaxs[fr->callno])
(6529,iaxs[fr->callno])
(6530,f.subclass.integer != IAX_COMMAND_VNAK)
(6531,IAX_IE_CALLNO)
(6532,owner)
(6533,ast_channel_name(iaxs[fr->callno]->owner)
(6534,iax_frame_subclass2str(fh->csub, subclass, sizeof(subclass)
(6535,iaxs[fr->callno])
(6536,send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno)
(6537,iaxs[fr->callno])
(6538,iaxs[fr->callno]->capability)
(6539,fr->callno)
(6540,"mine")
(6541,iaxs[fr->callno]->aseqno)
(6542,callno)
(6543,&sin)
(6544,iaxs[fr->callno])
(6545,send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1)
(6546,callno)
(6547,transferring)
(6548,!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(6549,fr)
(6550,1)
(6551,fr)
(6552,fh)
(6553,callno)
(6554,iaxs[fr->callno]->voiceformat)
(6555,fr->callno)
(6556,fr->callno)
(6557,ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
(6558,1)
(6559,peer->pokeexpire)
(6560,fh->dcallno)
(6561,sizeof(ied0)
(6562,iaxs)
(6563,iaxs[fr->callno]->iaxvars)
(6564,iaxs)
(6565,iaxs[fr->callno])
(6566,-1)
(6567,if (ies.codec_prefs)
(6568,connected)
(6569,iaxs)
(6570,sizeof(*cause_code)
(6571,iaxs[fr->callno]->lag)
(6572,mh)
(6573,"Memory allocation error while processing IAX2 variables\\n")
(6574,capability)
(6575,format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0)
(6576,fr->callno)
(6577,res = thread->buf_len)
(6578,)
(6579,callno)
(6580,f.subclass.integer != IAX_COMMAND_INVAL)
(6581,callno)
(6582,(f.frametype != AST_FRAME_IAX)
(6583,iaxdebug)
(6584,fr)
(6585,callno)
(6586,if (iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)
(6587,subclass)
(6588,ied0)
(6589,fr)
(6590,id)
(6591,if (iaxs[fr->callno] && iaxs[fr->callno]->owner)
(6592,f.frametype)
(6593,pokeexpire)
(6594,fr->callno)
(6595,f)
(6596,iaxs[fr->callno])
(6597,iaxs[fr->callno])
(6598,iaxs[fr->callno])
(6599,fr)
(6600,fh->csub)
(6601,f)
(6602,iax_frame_wrap(fr, &f)
(6603,fr->callno)
(6604,fr)
(6605,IAX_COMMAND_PONG)
(6606,fr)
(6607,if ((dcallno != 1)
(6608,fr->callno)
(6609,fr->callno)
(6610,if (f.frametype == AST_FRAME_IAX)
(6611,fr->callno)
(6612,callno)
(6613,iaxcompat)
(6614,fr->oseqno = fh->oseqno)
(6615,break;)
(6616,stop_stuff(fr->callno)
(6617,iaxs)
(6618,0)
(6619,callno)
(6620,fr->callno)
(6621,fr)
(6622,unsigned char *)
(6623,sin.sin_addr)
(6624,calling_pres)
(6625,iaxs[fr->callno])
(6626,capability)
(6627,fr->callno)
(6628,callno)
(6629,f.subclass.format)
(6630,iaxs[fr->callno]->transferring)
(6631,fr)
(6632,fr->callno)
(6633,varlist)
(6634,variablestore->data = varlist)
(6635,callno)
(6636,ntohs(vh->ts)
(6637,fr)
(6638,f)
(6639,host_pref_buf)
(6640,)
(6641,iaxs)
(6642,if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD | IAX_STATE_AUTHENTICATED)
(6643,sin_addr)
(6644,context)
(6645,buf)
(6646,f.subclass)
(6647,&ied0)
(6648,ast_debug(1, "Neat, somebody took away the channel at a magical time but i found it!\\n")
(6649,fr->afdatalen)
(6650,maxms)
(6651,lastms)
(6652,ast_channel_nativeformats(iaxs[fr->callno]->owner)
(6653,iaxs)
(6654,callno)
(6655,ast_channel_unlock(owner)
(6656,fr->callno)
(6657,peer->maxms)
(6658,fr)
(6659,f.subclass.integer != IAX_COMMAND_ACK)
(6660,iaxs[iaxs[fr->callno]->bridgecallno])
(6661,ied1)
(6662,iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)
(6663,fr->callno)
(6664,peer->lastms)
(6665,iaxs[fr->callno])
(6666,fr->callno)
(6667,fr)
(6668,callno)
(6669,1)
(6670,ies)
(6671,)
(6672,ts)
(6673,iaxs)
(6674,host_pref_buf)
(6675,peercapability)
(6676,callno)
(6677,(iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_READY)
(6678,fr->callno)
(6679,callno)
(6680,owner)
(6681,iaxs[fr->callno])
(6682,callno)
(6683,csub)
(6684,callno)
(6685,owner)
(6686,fr->callno)
(6687,ies.serviceident)
(6688,ast_channel_name(bridged_chan)
(6689,strlen(moh_suggest)
(6690,peer)
(6691,"Async goto of \'%s\' to \'%s@%s\' failed\\n")
(6692,iaxs[fr->callno])
(6693,owner)
(6694,iaxs[fr->callno])
(6695,&ied0)
(6696,callno)
(6697,pingied)
(6698,IAX_IE_CALLNO)
(6699,iaxs[fr->callno])
(6700,fr->callno)
(6701,fr)
(6702,if (ies.provverpres && ies.serviceident && sin.sin_addr.s_addr)
(6703,fr->callno)
(6704,ies)
(6705,fr)
(6706,if (bridged_chan && ies.called_number)
(6707,)
(6708,f.offset)
(6709,iaxs)
(6710,variablestore->inheritance)
(6711,*meta = (struct ast_iax2_meta_hdr *)
(6712,"Accepting UNAUTHENTICATED call from %s:\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t"%srequested format = %s,\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t"%srequested prefs = %s,\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t"%sactual format = %s,\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t"%shost prefs = %s,\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t"%spriority = %s\\n")
(6713,fr->callno)
(6714,var)
(6715,fr->callno)
(6716,iax2_lock_owner(fr->callno)
(6717,ied0.buf)
(6718,prefs)
(6719,ies.vars = NULL)
(6720,)
(6721,callno)
(6722,iaxs[fr->callno])
(6723,fr->callno)
(6724,iaxs[fr->callno]->last = fr->ts)
(6725,owner)
(6726,f.subclass.integer)
(6727,fr)
(6728,break;)
(6729,frametype)
(6730,cur->final)
(6731,connected.id)
(6732,-1)
(6733,"Peer \'%s\' is now REACHABLE! Time: %d\\n")
(6734,fr->callno)
(6735,iaxs)
(6736,iax2_getformatname_multiple(tmp3, sizeof(tmp3)
(6737,iaxs[fr->callno])
(6738,owner)
(6739,iaxs)
(6740,subclass)
(6741,f.frametype)
(6742,ntohl(fh->ts)
(6743,case IAX_COMMAND_REGAUTH:)
(6744,iaxs[fr->callno]->owner)
(6745,iaxs)
(6746,iaxs[fr->callno])
(6747,iaxsl)
(6748,&fr->af)
(6749,tmp2)
(6750,fr->callno)
(6751,ntohs(fh->scallno)
(6752,context)
(6753,iaxs[fr->callno])
(6754,if (prev)
(6755,iaxs)
(6756,iaxs)
(6757,using_prefs)
(6758,iaxs[fr->callno])
(6759,iseqno)
(6760,ntohs(mh->callno)
(6761,break;)
(6762,f.subclass.integer)
(6763,"disabled")
(6764,break;)
(6765,callno)
(6766,fr)
(6767,fr)
(6768,callno)
(6769,connected)
(6770,callno)
(6771,fr->callno)
(6772,iaxs[iaxs[fr->callno]->bridgecallno])
(6773,ies)
(6774,callno)
(6775,sizeof(ied0)
(6776,iaxs[fr->callno])
(6777,integer)
(6778,&iaxs[fr->callno]->rprefs)
(6779,iaxs)
(6780,peer)
(6781,iaxs)
(6782,ast_inet_ntoa(sin.sin_addr)
(6783,iaxs[fr->callno])
(6784,f.subclass.integer != IAX_COMMAND_UNQUELCH)
(6785,buf)
(6786,fr)
(6787,if (prev)
(6788,0)
(6789,f)
(6790,callno)
(6791,f.subclass.integer == AST_CONTROL_BUSY)
(6792,callno)
(6793,ies.vars)
(6794,vh)
(6795,fr->callno)
(6796,IAX_COMMAND_ACCEPT)
(6797,iaxs[fr->callno])
(6798,"Rejected connect attempt from %s, requested/capability \'%s\'/\'%s\' incompatible with our capability \'%s\'.\\n")
(6799,)
(6800,f)
(6801,data_size)
(6802,iaxs)
(6803,ast_channel_caller(iaxs[fr->callno]->owner)
(6804,!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)
(6805,f.subclass)
(6806,ied0)
(6807,iaxs[fr->callno]->peerformat)
(6808,send_apathetic_reply(1, ntohs(fh->scallno)
(6809,callno)
(6810,buf)
(6811,peer)
(6812,state)
(6813,callno)
(6814,fr)
(6815,ast_test_flag64(iaxs[fr->callno], IAX_ENCRYPTED)
(6816,peer->maxms)
(6817,format)
(6818,ies)
(6819,0)
(6820,(ntohs(vh->ts)
(6821,fr->iseqno >= iaxs[fr->callno]->rseqno && fr->iseqno < iaxs[fr->callno]->oseqno)
(6822,0)
(6823,ied0)
(6824,ntohs(vh->callno)
(6825,)
(6826,f.subclass == IAX_COMMAND_NEW)
(6827,fr->callno)
(6828,callno)
(6829,f.subclass)
(6830,sizeof(*vh)
(6831,fr)
(6832,offset)
(6833,owner)
(6834,f.subclass)
(6835,fr)
(6836,ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr)
(6837,ies)
(6838,calc_timestamp(iaxs[fr->callno], 0, &fr->af)
(6839,)
(6840,fr)
(6841,moh_suggest)
(6842,iaxs[fr->callno]->capability)
(6843,"Status: On\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t"Channel: %s\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t"Uniqueid: %s\\r\\n")
(6844,send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_UNSUPPORT, 0, NULL, 0, -1)
(6845,callno)
(6846,vh->ts)
(6847,ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested/capability \'%s\'/\'%s\' incompatible with our capability \'%s\'.\\n",\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tast_inet_ntoa(sin.sin_addr)
(6848,1)
(6849,&ied0)
(6850,IAX_STATE_STARTED)
(6851,ies.vars)
(6852,callno)
(6853,if (!iaxs[fr->callno])
(6854,iaxs[fr->callno]->state)
(6855,ast_debug(1, "Received packet %d, (%d, %u)
(6856,if (ies.vars)
(6857,data)
(6858,f.datalen < 0)
(6859,3)
(6860,ts)
(6861,"Parking call \'%s\'\\n")
(6862,fr)
(6863,x)
(6864,ies)
(6865,fr->callno)
(6866,iaxs[fr->callno]->reg->username)
(6867,format)
(6868,(struct ast_iax2_full_hdr *)
(6869,format)
(6870,ies)
(6871,*varlist)
(6872,iaxs)
(6873,id)
(6874,5)
(6875,fr->callno)
(6876,break;)
(6877,varlist)
(6878,transferring)
(6879,callno)
(6880,var->next)
(6881,f.subclass.integer)
(6882,IAX_DELAYPBXSTART)
(6883,tmp3)
(6884,fr->callno)
(6885,subclass)
(6886,ast_debug(1, "Destroying call %d\\n", fr->callno)
(6887,LOG_NOTICE)
(6888,fr->callno)
(6889,fr->callno)
(6890,iaxs)
(6891,&iaxsl[fr->callno])
(6892,f)
(6893,reg)
(6894,fr)
(6895,f)
(6896,iaxs[fr->callno]->owner)
(6897,ied0.pos)
(6898,ts)
(6899,var && var->next)
(6900,iaxs[iaxs[fr->callno]->bridgecallno])
(6901,TRANSFER_READY)
(6902,f)
(6903,"Received iseqno %d not within window %d->%d\\n")
(6904,ast_channel_readformat(iaxs[fr->callno]->owner)
(6905,EVENT_FLAG_CALL)
(6906,callno)
(6907,peer->lastms < 0)
(6908,f.frametype)
(6909,iaxs)
(6910,send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1)
(6911,prev)
(6912,iaxs[fr->callno])
(6913,peercapability)
(6914,capability)
(6915,number)
(6916,iaxs[fr->callno]->owner)
(6917,)
(6918,last)
(6919,iaxs[fr->callno]->peercallno = new_peercallno)
(6920,variablestore)
(6921,var->next)
(6922,iaxs[fr->callno]->capability)
(6923,called_number)
(6924,if ((f.frametype == AST_FRAME_IAX)
(6925,if (test_resync)
(6926,fr->callno)
(6927,callno)
(6928,fr->callno)
(6929,sin)
(6930,exten)
(6931,fr)
(6932,fr->callno)
(6933,ts)
(6934,)
(6935,fr->callno)
(6936,f)
(6937,ts)
(6938,callno)
(6939,sizeof(tmp1)
(6940,c)
(6941,if (ast_bridged_channel(iaxs[fr->callno]->owner)
(6942,caller_pref_buf)
(6943,callno)
(6944,name)
(6945,iaxs)
(6946,0)
(6947,"Call accepted by %s (format %s)
(6948,f)
(6949,ast_strlen_zero(moh_suggest)
(6950,iaxs[fr->callno])
(6951,pos)
(6952,iaxs[fr->callno]->transferring)
(6953,fr)
(6954,var)
(6955,integer)
(6956,iaxs[fr->callno]->context)
(6957,&iaxs[fr->callno]->addr)
(6958,fr)
(6959,rprefs)
(6960,authenticate_request(fr->callno)
(6961,IAX_CODEC_NOCAP)
(6962,break;)
(6963,iaxs)
(6964,&f.subclass.format)
(6965,rprefs)
(6966,if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(6967,ast_channel_writeformat(iaxs[fr->callno]->owner)
(6968,thread->buf[res - 1])
(6969,iaxs)
(6970,ies)
(6971,f.datalen && (f.frametype == AST_FRAME_VOICE)
(6972,f.subclass.integer)
(6973,fr->callno)
(6974,IAX_STATE_STARTED)
(6975,iaxs[fr->callno]->rprefs)
(6976,fr)
(6977,f.mallocd = 0)
(6978,owner)
(6979,f.subclass)
(6980,"Acking anyway\\n")
(6981,iaxs[fr->callno]->transferring)
(6982,connected)
(6983,callno)
(6984,buf_size)
(6985,iaxs[fr->callno]->transferring == TRANSFER_MBEGIN)
(6986,iaxs[fr->callno])
(6987,buf)
(6988,f)
(6989,data)
(6990,mount_callid)
(6991,if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)
(6992,ast_variables_destroy(ies.vars)
(6993,ast_iax2_new(fr->callno, AST_STATE_RING, format, NULL)
(6994,pref)
(6995,owner = iaxs[fr->callno]->owner)
(6996,)
(6997,callno)
(6998,iaxs[fr->callno])
(6999,mount_callid)
(7000,&iaxs[fr->callno]->state)
(7001,iaxs[fr->callno] && ast_test_flag64(iaxs[fr->callno], IAX_ENCRYPTED)
(7002,"No such context/extension")
(7003,send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1)
(7004,ied1.pos)
(7005,fr->callno)
(7006,iaxs)
(7007,ast_mutex_unlock(&iaxsl[fr->callno])
(7008,fr)
(7009,iaxs)
(7010,if (ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)
(7011,f)
(7012,tmpfmt)
(7013,ntohs(vh->callno)
(7014,iaxsl[fr->callno])
(7015,transferring)
(7016,)
(7017,iaxs)
(7018,iaxs)
(7019,ast_inet_ntoa(sin.sin_addr)
(7020,AST_FRAME_IAX)
(7021,iaxs)
(7022,0)
(7023,sin)
(7024,struct ast_iax2_full_hdr)
(7025,iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_NO_ROUTE_DESTINATION)
(7026,iaxs[fr->callno])
(7027,if (x == cur->oseqno)
(7028,fr)
(7029,iaxs[fr->callno])
(7030,iaxs[fr->callno])
(7031,fr->callno)
(7032,)
(7033,ast_inet_ntoa(sin.sin_addr)
(7034,iaxs[fr->callno])
(7035,ast_format_cap_set(native, &f.subclass.format)
(7036,iaxs[fr->callno]->calling_pres = ast_party_id_presentation(&connected.id)
(7037,samples)
(7038,fr->callno)
(7039,f.frametype)
(7040,iaxs[fr->callno])
(7041,f.subclass.integer != IAX_COMMAND_TXACC)
(7042,connected.id.name.str)
(7043,LOG_NOTICE)
(7044,f)
(7045,f.offset)
(7046,)
(7047,callno)
(7048,iaxs)
(7049,peer)
(7050,resend_with_token(fr->callno, cur, (char *)
(7051,callno)
(7052,data)
(7053,0)
(7054,iaxs[fr->callno]->capability)
(7055,iaxs[fr->callno]->voiceformat)
(7056,fr->callno)
(7057,fr->callno)
(7058,ast_inet_ntoa(sin.sin_addr)
(7059,sin.sin_addr)
(7060,iaxs[fr->callno])
(7061,if (prev)
(7062,callno)
(7063,fr->callno)
(7064,&ied0)
(7065,iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No authority found")
(7066,x != fr->iseqno)
(7067,fr->callno)
(7068,sin)
(7069,owner)
(7070,if (f.frametype == AST_FRAME_VIDEO)
(7071,subclass)
(7072,str)
(7073,iaxs)
(7074,0)
(7075,fr->callno)
(7076,fr)
(7077,iaxs[fr->callno])
(7078,ied0)
(7079,format = iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1)
(7080,ast_log(LOG_NOTICE, "Rejected connect attempt from %s, requested \'%s\' incompatible with our capability \'%s\'.\\n", ast_inet_ntoa(sin.sin_addr)
(7081,IAX_IMMEDIATE)
(7082,if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD)
(7083,iaxs[fr->callno])
(7084,AST_FRAME_IAX)
(7085,fr->callno)
(7086,fr)
(7087,bridgecallno)
(7088,iaxs[fr->callno])
(7089,iaxs[fr->callno])
(7090,ast_channel_datastore_add(c, variablestore)
(7091,dcallno)
(7092,iseqno)
(7093,0)
(7094,f.mallocd)
(7095,last)
(7096,exten)
(7097,iax_ie_append_int(&ied1, IAX_IE_FORMAT, format)
(7098,~IAX_FLAG_RETRANS)
(7099,csub)
(7100,AST_SCHED_DEL(sched, peer->pokeexpire)
(7101,iaxs)
(7102,AST_LIST_LAST(&frame_queue[fr->callno])
(7103,inaddrcmp(&sin, &iaxs[fr->callno]->addr)
(7104,iaxs[fr->callno]->last)
(7105,iaxs[fr->callno])
(7106,ied0)
(7107,fr->af)
(7108,fr->callno)
(7109,1)
(7110,ast_debug(1, "I can haz IAX vars? w00t\\n")
(7111,format)
(7112,1)
(7113,fr->af)
(7114,iaxs[iaxs[fr->callno]->bridgecallno]->transferring)
(7115,ts)
(7116,)
(7117,owner)
(7118,fr)
(7119,f.frametype == AST_FRAME_IAX)
(7120,fr->callno)
(7121,f)
(7122,IAX_COMMAND_TXCNT)
(7123,vars)
(7124,lag)
(7125,break;)
(7126,frametype)
(7127,iaxs[fr->callno])
(7128,break;)
(7129,ies.called_number)
(7130,break;)
(7131,callno)
(7132,AST_FRAME_IAX)
(7133,peer_unref(peer)
(7134,"disabled")
(7135,f.subclass)
(7136,iaxs[fr->callno])
(7137,callno)
(7138,iaxs[fr->callno]->owner)
(7139,iax2_getformatname_multiple(tmp2, sizeof(tmp2)
(7140,f.data.ptr)
(7141,f)
(7142,fr)
(7143,!iaxs[fr->callno])
(7144,if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)
(7145,iaxsl[fr->callno])
(7146,iaxs[fr->callno]->exten)
(7147,maxms)
(7148,fr)
(7149,&sin)
(7150,(f.subclass.integer != IAX_COMMAND_ACK)
(7151,1)
(7152,fh->type)
(7153,iaxsl)
(7154,fr)
(7155,iaxdebug)
(7156,sizeof(struct ast_iax2_full_hdr)
(7157,callno)
(7158,)
(7159,fr->ts)
(7160,iaxs[fr->callno])
(7161,ast_debug(1, "Received mini frame before first full voice frame\\n")
(7162,cause_code)
(7163,(iaxs[fr->callno]->last & 0xFFFF8000L)
(7164,callno)
(7165,callno)
(7166,)
(7167,f.subclass)
(7168,sizeof(caller_pref_buf)
(7169,fr)
(7170,capability)
(7171,integer)
(7172,sin_addr)
(7173,iaxs)
(7174,datalen)
(7175,0)
(7176,iax_frame_wrap(fr, &f)
(7177,fd)
(7178,"we\'ve been told to rotate our encryption key, "\n\\n\\t\\t\\t\\t\\t\\t"but this isn\'t an encrypted call. bad things will happen.\\n")
(7179,serviceident)
(7180,peer->lastms < 0)
(7181,ts)
(7182,fr->callno)
(7183,thread)
(7184,ied0)
(7185,pos)
(7186,fh->csub == IAX_COMMAND_HANGUP)
(7187,iaxs[iaxs[fr->callno]->bridgecallno]->peercallno)
(7188,if ((vh->zeros == 0)
(7189,if (!format)
(7190,iaxsl)
(7191,fr->callno)
(7192,callno)
(7193,native)
(7194,subclass)
(7195,f)
(7196,fr->ts)
(7197,fr->callno)
(7198,fr->callno)
(7199,)
(7200,!iaxs[fr->callno])
(7201,decrypted = 1)
(7202,iseqno)
(7203,iaxs[fr->callno])
(7204,callno)
(7205,ntohs(mh->callno)
(7206,IAX_COMMAND_TXACC)
(7207,variablestore->data = varlist)
(7208,owner)
(7209,fh)
(7210,*mh = (struct ast_iax2_mini_hdr *)
(7211,!minivid &&\n\\n\\t\\tf.subclass.integer != IAX_COMMAND_TXCNT &&\\t\\t/* for attended transfer */\n\\n\\t\\tf.subclass.integer != IAX_COMMAND_TXACC)
(7212,ast_channel_caller(iaxs[fr->callno]->owner)
(7213,ast_log(LOG_NOTICE, "Packet Decrypt Failed!\\n")
(7214,fr)
(7215,LOG_ERROR)
(7216,f.subclass)
(7217,fr)
(7218,iaxs[fr->callno]->frames_received)
(7219,f.subclass.integer != IAX_COMMAND_LAGRP)
(7220,tmp3)
(7221,subclass)
(7222,fr->callno)
(7223,iaxs[fr->callno])
(7224,fr->callno)
(7225,callno)
(7226,(ntohs(mh->callno)
(7227,if (iaxs[fr->callno]->owner)
(7228,caller_pref_buf)
(7229,)
(7230,var->value)
(7231,maxms)
(7232,subclass)
(7233,(f.subclass.integer != IAX_COMMAND_INVAL)
(7234,data)
(7235,if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(7236,fr)
(7237,next)
(7238,decrypted = 0)
(7239,iaxs[fr->callno])
(7240,subclass)
(7241,fr)
(7242,iaxs[fr->callno]->last)
(7243,transferring)
(7244,ies)
(7245,fr)
(7246,IAX_COMMAND_CALLTOKEN)
(7247,fr)
(7248,&f.subclass.format)
(7249,fr)
(7250,f.subclass)
(7251,fr->callno)
(7252,integer)
(7253,iaxs[fr->callno]->capability)
(7254,ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_CONGESTION)
(7255,callno)
(7256,f)
(7257,iaxs[fr->callno]->transferring)
(7258,f.subclass.integer != IAX_COMMAND_ACK)
(7259,break;)
(7260,)
(7261,iseqno)
(7262,!ast_test_flag64(&globalflags, IAX_ALLOWFWDOWNLOAD)
(7263,sin.sin_addr)
(7264,fr->iseqno)
(7265,subclass)
(7266,"Host %s failed to authenticate as %s\\n")
(7267,case IAX_COMMAND_TXCNT:)
(7268,)
(7269,decrypted)
(7270,tmp1)
(7271,f.frametype == AST_FRAME_VIDEO)
(7272,)
(7273,tmp2)
(7274,fr)
(7275,varlist)
(7276,frametype)
(7277,callno)
(7278,AST_FRAME_VIDEO)
(7279,LOG_NOTICE)
(7280,iaxs[fr->callno]->rseqno)
(7281,subclass)
(7282,prefs)
(7283,fr->callno)
(7284,frametype)
(7285,iaxs)
(7286,)
(7287,fr->callno)
(7288,callno)
(7289,callno)
(7290,"Channel \'%s\' ready to transfer\\n")
(7291,sizeof(ied0)
(7292,remove_by_peercallno(iaxs[fr->callno])
(7293,res = iax_firmware_append(&ied0, (unsigned char *)
(7294,inaddrcmp(&sin, &iaxs[fr->callno]->addr)
(7295,fr)
(7296,iax2_getformatname_multiple(tmp, sizeof(tmp)
(7297,ptr)
(7298,AST_FRAME_VOICE)
(7299,ntohs(fh->dcallno)
(7300,csub)
(7301,tmpfmt)
(7302,owner)
(7303,iaxs)
(7304,NEW_PREVENT)
(7305,globalflags)
(7306,fr->callno)
(7307,ts)
(7308,call_to_destroy)
(7309,last)
(7310,ied0)
(7311,iseqno)
(7312,oseqno)
(7313,fr)
(7314,calltoken)
(7315,IAX_CODEC_NOPREFS)
(7316,var = ies.vars)
(7317,fr)
(7318,iaxs[fr->callno])
(7319,if (ast_bridged_channel(iaxs[fr->callno]->owner)
(7320,ast_free(varlist)
(7321,peerformat)
(7322,callno)
(7323,iaxs)
(7324,fr)
(7325,1)
(7326,ts)
(7327,"mine")
(7328,ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->peerformat, NULL)
(7329,new_peercallno)
(7330,iaxs)
(7331,IAX_COMMAND_LAGRP)
(7332,owner)
(7333,capability)
(7334,rprefs)
(7335,callno)
(7336,callno)
(7337,iaxs[fr->callno])
(7338,res)
(7339,iaxsl[fr->callno])
(7340,iaxsl[fr->callno])
(7341,)
(7342,1)
(7343,iaxsl)
(7344,"For call=%d, set last=%d\\n")
(7345,callno)
(7346,iaxs[fr->callno])
(7347,ast_clear_flag(&iaxs[fr->callno]->state, IAX_STATE_TBD)
(7348,IAX_COMMAND_REJECT)
(7349,fr->callno)
(7350,ast_mutex_unlock(&iaxsl[fr->callno])
(7351,iaxs)
(7352,iaxs[fr->callno])
(7353,!fr->callno)
(7354,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(7355,fr)
(7356,&f)
(7357,fr->callno)
(7358,iaxs[fr->callno])
(7359,iaxs)
(7360,pos)
(7361,fr)
(7362,prefs)
(7363,send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREJ, 0, NULL, 0, -1)
(7364,AST_FRAME_IAX)
(7365,iaxs[fr->callno])
(7366,fr->callno)
(7367,fr->callno)
(7368,EVENT_FLAG_SYSTEM)
(7369,ast_variables_destroy(ies.vars)
(7370,fr)
(7371,IAX_IE_CALLNO)
(7372,host_pref_buf)
(7373,fr->callno)
(7374,fr->callno)
(7375,f.subclass.integer != IAX_COMMAND_TXCNT &&\\t\\t/* for attended transfer */\n\\n\\t\\tf.subclass.integer != IAX_COMMAND_TXACC)
(7376,dcallno)
(7377,fr)
(7378,fr)
(7379,connected)
(7380,iaxs[fr->callno]->calling_pres)
(7381,id)
(7382,AST_STATE_RING)
(7383,connected.id)
(7384,peer->historicms)
(7385,1)
(7386,iaxs)
(7387,iaxs[fr->callno]->first_iax_message = f.subclass.integer)
(7388,callno)
(7389,iaxs[fr->callno])
(7390,iaxs)
(7391,buf)
(7392,iaxs[fr->callno])
(7393,(iaxs[fr->callno]->last & 0xFFFF8000L)
(7394,callno)
(7395,if (register_verify(fr->callno, &sin, &ies)
(7396,ies.cause ? ies.cause : "<unknown>")
(7397,type)
(7398,fr->callno)
(7399,iaxs)
(7400,c = ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->peerformat, NULL)
(7401,iaxs)
(7402,subclass)
(7403,f)
(7404,iaxs[iaxs[fr->callno]->bridgecallno]->transferring)
(7405,ast_codec_pref_index(&iaxs[fr->callno]->rprefs, 0, &tmpfmt)
(7406,f)
(7407,c)
(7408,fr->ts)
(7409,var->next)
(7410,&iaxs[fr->callno]->addr)
(7411,fr->callno)
(7412,integer)
(7413,iaxs[fr->callno])
(7414,case IAX_COMMAND_REGREQ:)
(7415,ied0.buf)
(7416,fr->cacheable = ((f.frametype == AST_FRAME_VOICE)
(7417,peer)
(7418,iaxs[iaxs[fr->callno]->bridgecallno]->transferring)
(7419,iaxs)
(7420,AST_FRAME_IAX)
(7421,f)
(7422,-1)
(7423,fr)
(7424,AST_CAUSE_BEARERCAPABILITY_NOTAVAIL)
(7425,if (ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)
(7426,ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
(7427,id)
(7428,authmethods)
(7429,owner)
(7430,AST_FRAME_NULL)
(7431,iax2_sched_add(sched, peer->pokefreqok, iax2_poke_peer_s, peer_ref(peer)
(7432,fr->callno)
(7433,iaxs[fr->callno])
(7434,iaxs)
(7435,oseqno)
(7436,fr)
(7437,data_size)
(7438,if (res < sizeof(*vh)
(7439,)
(7440,&iaxs[fr->callno]->state)
(7441,peer)
(7442,callno)
(7443,iaxs)
(7444,f.subclass.integer)
(7445,IAX_COMMAND_REJECT)
(7446,f)
(7447,"Status: Off\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t"Channel: %s\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t"Uniqueid: %s\\r\\n")
(7448,if (!format)
(7449,ast_log(LOG_ERROR, "No best format in %s???\\n",\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tiax2_getformatname_multiple(tmp1, sizeof(tmp1)
(7450,callno)
(7451,ies.vars)
(7452,&pref)
(7453,f.subclass.integer != IAX_COMMAND_ACK)
(7454,fh)
(7455,callno)
(7456,AST_FRAME_IAX)
(7457,callno)
(7458,iaxs[fr->callno]->prefs)
(7459,vars)
(7460,NULL)
(7461,iaxs[fr->callno])
(7462,fr->callno)
(7463,ntohs(fh->scallno)
(7464,"Memory allocation error while processing IAX2 variables\\n")
(7465,exten)
(7466,fr)
(7467,f)
(7468,&ies)
(7469,fr)
(7470,iaxs[fr->callno])
(7471,prev)
(7472,callno)
(7473,&sin)
(7474,0)
(7475,sizeof(tmp)
(7476,"No such context/extension")
(7477,fr)
(7478,name)
(7479,"<Unknown>")
(7480,ntohl(fh->ts)
(7481,fr)
(7482,callno)
(7483,called_number)
(7484,owner)
(7485,iaxs[fr->callno])
(7486,iaxs[fr->callno])
(7487,iaxs)
(7488,*cause_code)
(7489,iaxs[fr->callno]->peercapability)
(7490,)
(7491,iaxsl[call_to_destroy])
(7492,callno)
(7493,f.datalen)
(7494,fh)
(7495,)
(7496,f)
(7497,iaxs[fr->callno])
(7498,fr->callno)
(7499,fr->callno)
(7500,-1)
(7501,ntohs(sin.sin_port)
(7502,IAX_IE_CAUSE)
(7503,owner)
(7504,iaxs)
(7505,if ((c = iaxs[fr->callno]->owner)
(7506,fr)
(7507,break;)
(7508,fr)
(7509,bridged_chan)
(7510,fr->callno)
(7511,sizeof(tmp1)
(7512,state)
(7513,IAX_IE_CALLNO)
(7514,!ast_test_flag64(iaxs[fr->callno], IAX_RECVCONNECTEDLINE)
(7515,ies.called_number)
(7516,fr->callno)
(7517,sin)
(7518,tmp3)
(7519,iaxs[fr->callno])
(7520,break;)
(7521,if (!iaxs[fr->callno])
(7522,LOG_ERROR)
(7523,inheritance)
(7524,peer->pokeexpire)
(7525,fr->callno)
(7526,fr)
(7527,iaxs[fr->callno]->pingtime)
(7528,iaxs)
(7529,break;)
(7530,1)
(7531,memset(&ied1, 0, sizeof(ied1)
(7532,fr->ts)
(7533,1)
(7534,iseqno)
(7535,iaxs[fr->callno])
(7536,fr->callno)
(7537,vh)
(7538,fr)
(7539,"TBD")
(7540,newvar)
(7541,pref = iaxs[fr->callno]->prefs)
(7542,integer)
(7543,1)
(7544,sin.sin_family)
(7545,iax_pvt_callid_get(fr->callno)
(7546,f.subclass)
(7547,callno)
(7548,iaxs[fr->callno])
(7549,connected.id)
(7550,)
(7551,sizeof(tmp2)
(7552,ies.provverpres)
(7553,iaxs[fr->callno])
(7554,callno)
(7555,connected.id.number)
(7556,peercapability)
(7557,if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(7558,fr)
(7559,1)
(7560,)
(7561,fr->callno)
(7562,callno)
(7563,integer)
(7564,subclass)
(7565,if (!iaxs[fr->callno]->first_iax_message)
(7566,fr->callno)
(7567,moh_suggest)
(7568,ast_variables_destroy(ies.vars)
(7569,iaxs[fr->callno]->pingtime <= peer->maxms)
(7570,!iaxs[fr->callno])
(7571,fr->callno)
(7572,(f.frametype != AST_FRAME_VOICE)
(7573,IAX_COMMAND_ACK)
(7574,frametype)
(7575,ast_channel_nativeformats(iaxs[fr->callno]->owner)
(7576,varlist)
(7577,format = iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
(7578,fr->callno)
(7579,iaxs[fr->callno]->pingtime)
(7580,iaxs)
(7581,ts)
(7582,ied1)
(7583,fr)
(7584,break;)
(7585,fr)
(7586,ies.provver)
(7587,ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)
(7588,)
(7589,varlist)
(7590,iaxs[fr->callno]->authmethods & IAX_AUTH_MD5)
(7591,ies.vars = NULL)
(7592,tmp)
(7593,fr)
(7594,subclass)
(7595,fr->callno)
(7596,iaxs)
(7597,&iaxsl[fr->callno])
(7598,&iaxsl[fr->callno])
(7599,TRANSFER_RELEASED)
(7600,f)
(7601,break;)
(7602,&ied0)
(7603,fr)
(7604,f.subclass.format)
(7605,fr)
(7606,IAX_STATE_STARTED)
(7607,"mine")
(7608,iaxs[fr->callno]->owner)
(7609,fr)
(7610,if (!iaxs[fr->callno])
(7611,data_size += 5)
(7612,break;)
(7613,sin)
(7614,authdebug)
(7615,if (iaxs[fr->callno]->transferring == TRANSFER_MREADY)
(7616,retries)
(7617,fr)
(7618,callno)
(7619,fr)
(7620,IAX_IE_CAUSE)
(7621,peercallno)
(7622,iaxs[fr->callno])
(7623,"Async goto of \'%s\' to \'%s@%s\' started\\n")
(7624,f)
(7625,f.datalen)
(7626,return 1;)
(7627,ied0)
(7628,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)
(7629,call_to_destroy)
(7630,iaxs[fr->callno])
(7631,integer)
(7632,fr->callno)
(7633,NULL)
(7634,iaxs[fr->callno]->peercallno)
(7635,owner)
(7636,frametype)
(7637,IAX_COMMAND_TXREL)
(7638,iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec")
(7639,x)
(7640,iaxsl)
(7641,iaxs)
(7642,variablestore)
(7643,ast_codec_pref_convert(&iaxs[fr->callno]->rprefs, ies.codec_prefs, 32, 0)
(7644,iaxs)
(7645,owner)
(7646,fr->callno)
(7647,iaxs[fr->callno]->peerformat)
(7648,iaxs)
(7649,varlist)
(7650,iaxs[fr->callno]->dcx)
(7651,ied0)
(7652,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(7653,fr->callno)
(7654,pos)
(7655,iaxs)
(7656,fr->ts)
(7657,f.frametype == AST_FRAME_TEXT && thread->buf[res - 1] != \'\\0\')
(7658,mallocd)
(7659,)
(7660,fr->callno)
(7661,historicms)
(7662,IAX_IE_CAUSECODE)
(7663,iaxs)
(7664,f.subclass.integer)
(7665,duped_fr)
(7666,EVENT_FLAG_CALL)
(7667,iaxs[fr->callno])
(7668,peerformat)
(7669,1)
(7670,fr->callno)
(7671,iaxs[fr->callno]->context)
(7672,ast_iax2_new(fr->callno, AST_STATE_RING, iaxs[fr->callno]->chosenformat, NULL)
(7673,capability)
(7674,IAX_STATE_TBD)
(7675,)
(7676,owner)
(7677,rseqno)
(7678,capability)
(7679,f.subclass.integer != IAX_COMMAND_PONG &&\n\\n                            f.subclass.integer != IAX_COMMAND_LAGRP)
(7680,)
(7681,ied0)
(7682,callno)
(7683,connected.id)
(7684,dpcache)
(7685,buf)
(7686,f)
(7687,capability)
(7688,0)
(7689,IAX_COMMAND_REGREL)
(7690,sin_addr)
(7691,ies.calltokendata)
(7692,ast_log(LOG_WARNING, \n\\n\\t\\t\\t\\t\\t\\t"we\'ve been told to rotate our encryption key, "\n\\n\\t\\t\\t\\t\\t\\t"but this isn\'t an encrypted call. bad things will happen.\\n"\n\\n\\t\\t\\t\\t\\t)
(7693,sizeof(tmp2)
(7694,fr)
(7695,iaxs)
(7696,tmp)
(7697,break;)
(7698,ies.serviceident)
(7699,ts)
(7700,res)
(7701,tmp2)
(7702,callno)
(7703,sizeof(pref)
(7704,ied0)
(7705,using_prefs)
(7706,owner)
(7707,)
(7708,callno)
(7709,fr)
(7710,fr->callno)
(7711,fr->iseqno = fh->iseqno)
(7712,AST_FRAME_IAX)
(7713,fr)
(7714,iaxs[fr->callno])
(7715,f)
(7716,fr->callno)
(7717,fr)
(7718,ies.causecode)
(7719,datalen)
(7720,peercapability)
(7721,format)
(7722,thread->buf_size)
(7723,callno)
(7724,ies.provverpres)
(7725,1)
(7726,caller_pref_buf)
(7727,1)
(7728,ies)
(7729,iaxs)
(7730,!(ntohs(meta->metacmd)
(7731,TRANSFER_BEGIN)
(7732,vars)
(7733,iaxs)
(7734,ied0)
(7735,f.subclass.integer)
(7736,iaxs)
(7737,"I have IAX variables, but they were not processed\\n")
(7738,iaxs)
(7739,iaxs)
(7740,pos)
(7741,)
(7742,historicms)
(7743,f.frametype)
(7744,iaxs)
(7745,fr)
(7746,&ied1)
(7747,if (f.frametype == AST_FRAME_IAX)
(7748,callno)
(7749,variablestore)
(7750,ies)
(7751,iaxs)
(7752,LOG_WARNING)
(7753,cause_code)
(7754,ntohs(mh->callno)
(7755,AST_FRAME_IAX)
(7756,0)
(7757,iaxs[fr->callno]->last)
(7758,vh)
(7759,fr->ts)
(7760,f.frametype == AST_FRAME_IAX)
(7761,1)
(7762,peer->smoothing && (peer->lastms > -1)
(7763,ast_variables_destroy(ies.vars)
(7764,fr->callno)
(7765,(iaxs[fr->callno]->transferring == TRANSFER_BEGIN)
(7766,mh)
(7767,IAX_COMMAND_ACK)
(7768,peercapability)
(7769,iaxs)
(7770,tmp)
(7771,(f.subclass.integer != IAX_COMMAND_TXREL)
(7772,fr)
(7773,iaxs)
(7774,x)
(7775,fr->callno)
(7776,if (!ast_connected_line_parse_data(f.data.ptr, f.datalen, &connected)
(7777,iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_peer_s, peer_ref(peer)
(7778,owner)
(7779,&ied1)
(7780,&iaxsl[fr->callno])
(7781,ies.called_number)
(7782,peer)
(7783,AST_CAUSE_FACILITY_NOT_SUBSCRIBED)
(7784,iaxs)
(7785,iaxs[fr->callno])
(7786,0)
(7787,AST_FRAME_IAX)
(7788,if (ast_channel_readformat(iaxs[fr->callno]->owner)
(7789,)
(7790,iaxs[fr->callno]->rprefs)
(7791,f.subclass.format)
(7792,iaxs[fr->callno])
(7793,(f.subclass.integer != IAX_COMMAND_TXCNT)
(7794,if (peer->pokeexpire > -1)
(7795,iaxs)
(7796,strcmp(iaxs[fr->callno]->exten, "TBD")
(7797,iaxs[fr->callno]->last < fr->ts)
(7798,f.subclass.integer)
(7799,peer->historicms)
(7800,state)
(7801,IAX_COMMAND_ACK)
(7802,-1)
(7803,break;)
(7804,fr)
(7805,host_pref_buf)
(7806,res)
(7807,f.subclass)
(7808,iaxs)
(7809,fr)
(7810,fr->callno)
(7811,varlist)
(7812,fr->ts)
(7813,1)
(7814,32)
(7815,IAX_ENCRYPTED)
(7816,iaxs[fr->callno])
(7817,res)
(7818,fr)
(7819,sizeof(*fr)
(7820,fr->callno)
(7821,iaxs[fr->callno] && iaxs[fr->callno]->last < fr->ts)
(7822,fr)
(7823,case IAX_COMMAND_RTKEY:)
(7824,IAX_COMMAND_ACK)
(7825,if ((fh->csub >> 6)
(7826,ied0)
(7827,ast_inet_ntoa(sin.sin_addr)
(7828,(ast_strlen_zero(iaxs[fr->callno]->secret)
(7829,&f.subclass.format)
(7830,iaxs[fr->callno])
(7831,fr)
(7832,iax2_getformatname_multiple(tmp1, sizeof(tmp1)
(7833,f.frametype)
(7834,sizeof(tmp2)
(7835,f.subclass)
(7836,ied0)
(7837,callno)
(7838,integer)
(7839,0)
(7840,iaxsl[fr->callno])
(7841,iaxs[fr->callno]->transferring == TRANSFER_BEGIN)
(7842,callno)
(7843,iaxs)
(7844,&f.subclass.format)
(7845,0)
(7846,iaxs)
(7847,fr->callno)
(7848,datalen)
(7849,iaxs[fr->callno])
(7850,oseqno)
(7851,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(7852,iaxs[fr->callno]->reg)
(7853,callno)
(7854,pref)
(7855,callno)
(7856,iaxs[fr->callno]->capability)
(7857,fh->iseqno + 1)
(7858,iaxs[fr->callno])
(7859,f.subclass)
(7860,IAX_CODEC_NOCAP)
(7861,data_size)
(7862,sizeof(ied0)
(7863,fr->callno)
(7864,&ied0)
(7865,owner)
(7866,ast_debug(1, "Received iseqno %d not within window %d->%d\\n", fr->iseqno, iaxs[fr->callno]->rseqno, iaxs[fr->callno]->oseqno)
(7867,callno)
(7868,!ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)
(7869,ast_inet_ntoa(sin.sin_addr)
(7870,(f.frametype != AST_FRAME_IAX)
(7871,fr->iseqno)
(7872,subclass)
(7873,0)
(7874,iaxs[fr->callno])
(7875,subclass)
(7876,iaxs)
(7877,1)
(7878,break;)
(7879,callno)
(7880,fr->callno)
(7881,return socket_process_meta(res, meta, &sin, fd, fr)
(7882,check_dcallno)
(7883,fr->callno)
(7884,callno)
(7885,iaxs)
(7886,call_to_destroy)
(7887,fr)
(7888,format = iax2_codec_choose(&pref, iaxs[fr->callno]->capability & iaxs[fr->callno]->peercapability, 0)
(7889,iaxs[fr->callno])
(7890,f.subclass.integer)
(7891,iaxs[fr->callno])
(7892,iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner)
(7893,&ied0)
(7894,iaxs)
(7895,fr)
(7896,LOG_WARNING)
(7897,f.subclass)
(7898,ies)
(7899,1)
(7900,ts)
(7901,f)
(7902,fr)
(7903,)
(7904,iaxs)
(7905,callno)
(7906,ies)
(7907,iaxs)
(7908,bridged_chan)
(7909,c = iaxs[fr->callno]->owner)
(7910,fr->callno)
(7911,callno)
(7912,f.frametype)
(7913,fr)
(7914,IAX_COMMAND_ACK)
(7915,callno)
(7916,IAX_COMMAND_TXCNT)
(7917,f.frametype == AST_FRAME_VIDEO)
(7918,)
(7919,ies)
(7920,ies)
(7921,iaxs[fr->callno])
(7922,lastms)
(7923,fr->callno)
(7924,iaxs[fr->callno])
(7925,iax_ie_append_str(&ied0, IAX_IE_CAUSE, "No such context/extension")
(7926,historicms)
(7927,&ies)
(7928,struct ast_iax2_full_hdr *)
(7929,fr->callno)
(7930,iaxs[fr->callno]->addr.sin_addr)
(7931,f)
(7932,iseqno)
(7933,fr)
(7934,if (decrypt_frame(fr->callno, fh, &f, &res)
(7935,iaxs)
(7936,callno)
(7937,)
(7938,iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner)
(7939,ies.cause)
(7940,strcmp(iaxs[fr->callno]->exten, "TBD")
(7941,callno)
(7942,newvar)
(7943,fr)
(7944,f.samples = 0)
(7945,&f.subclass.format)
(7946,f)
(7947,&iaxsl[fr->callno])
(7948,if (!fr->callno || !iaxs[fr->callno])
(7949,ied0)
(7950,iaxs[fr->callno]->error)
(7951,iaxs[fr->callno]->peercapability)
(7952,var)
(7953,iaxs[fr->callno]->addr)
(7954,capability)
(7955,IAX_COMMAND_ACK)
(7956,iaxs)
(7957,ast_mutex_unlock(&iaxsl[fr->callno])
(7958,TRANSFER_MREADY)
(7959,fr->callno)
(7960,if (iaxs[fr->callno]->owner && fh->type == AST_FRAME_IAX &&\n\\n\\t\\t\\t(fh->csub == IAX_COMMAND_HANGUP\n\\n\\t\\t\\t|| fh->csub == IAX_COMMAND_REJECT\n\\n\\t\\t\\t|| fh->csub == IAX_COMMAND_REGREJ\n\\n\\t\\t\\t|| fh->csub == IAX_COMMAND_TXREJ)
(7961,iaxsl)
(7962,f.frametype)
(7963,f.subclass.integer == IAX_COMMAND_ACK)
(7964,)
(7965,ast_verb(3, "Accepted unauthenticated TBD call from %s\\n", ast_inet_ntoa(sin.sin_addr)
(7966,return 1;)
(7967,if (!iaxs[fr->callno])
(7968,f.samples = ast_codec_get_samples(&f)
(7969,fr->callno)
(7970,f.subclass)
(7971,break;)
(7972,f.subclass)
(7973,f.frametype != AST_FRAME_IAX)
(7974,peer->name)
(7975,iax2_codec_choose(&pref, iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability, 1)
(7976,fr)
(7977,ast_test_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART)
(7978,fr)
(7979,)
(7980,fr->ts)
(7981,callno)
(7982,fr->callno)
(7983,ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
(7984,fr->callno)
(7985,username)
(7986,if (duped_fr)
(7987,ies)
(7988,fr->callno)
(7989,fr->callno)
(7990,format)
(7991,ast_free(prev)
(7992,fr)
(7993,newvar)
(7994,callno)
(7995,iaxs[fr->callno])
(7996,f.frametype == AST_FRAME_IAX &&\n\\n\\t\\t\\t\\t\\t\\t\\t\\t(f.subclass == IAX_COMMAND_NEW ||\n\\n\\t\\t\\t\\t\\t\\t\\t\\t f.subclass == IAX_COMMAND_AUTHREQ ||\n\\n\\t\\t\\t\\t\\t\\t\\t\\t f.subclass == IAX_COMMAND_ACCEPT ||\n\\n\\t\\t\\t\\t\\t\\t\\t\\t f.subclass == IAX_COMMAND_REJECT)
(7997,res)
(7998,tmp2)
(7999,!iaxs[fr->callno])
(8000,)
(8001,data)
(8002,format)
(8003,iaxs)
(8004,if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED | IAX_STATE_TBD)
(8005,IAX_COMMAND_ACCEPT)
(8006,bridgecallno)
(8007,NULL)
(8008,fr->callno)
(8009,fr->callno)
(8010,)
(8011,callno)
(8012,ies)
(8013,moh_suggest)
(8014,peer_ref(peer)
(8015,callno)
(8016,callno)
(8017,&sin)
(8018,(struct ast_iax2_mini_hdr *)
(8019,cause)
(8020,iaxs[fr->callno])
(8021,fr->oseqno)
(8022,iaxs)
(8023,using_prefs)
(8024,iaxs[fr->callno])
(8025,IAX_COMMAND_REJECT)
(8026,f.subclass)
(8027,ast_format_to_old_bitfield(&f.subclass.format)
(8028,transferring)
(8029,var->name)
(8030,peer_ref(peer)
(8031,fr->callno)
(8032,f)
(8033,VERBOSE_PREFIX_4)
(8034,f.subclass.integer)
(8035,f.subclass.integer)
(8036,iaxs)
(8037,iaxs)
(8038,return 1;)
(8039,bridged_chan)
(8040,fh)
(8041,strcpy(host_pref_buf, "disabled")
(8042,ast_channel_ref(bridged_chan)
(8043,iax2_send(iaxs[fr->callno], &fr->af, fr->ts, -1, 0, 0, 0)
(8044,owner)
(8045,variablestore)
(8046,callno)
(8047,send_apathetic_reply(1, ntohs(fh->scallno)
(8048,iax2_getformatname_multiple(tmp1, sizeof(tmp1)
(8049,LOG_ERROR)
(8050,iaxs[iaxs[fr->callno]->bridgecallno])
(8051,ies)
(8052,if (variablestore)
(8053,f)
(8054,*varlist)
(8055,fr->callno)
(8056,iseqno)
(8057,fr->callno)
(8058,f)
(8059,ast_mutex_lock(&iaxsl[fr->callno])
(8060,"Registration of \'%s\' rejected: \'%s\' from: \'%s\'\\n")
(8061,ast_connected_line_parse_data(f.data.ptr, f.datalen, &connected)
(8062,callno)
(8063,iaxs[fr->callno]->rprefs)
(8064,0)
(8065,authdebug)
(8066,cur)
(8067,call_to_destroy)
(8068,f.subclass)
(8069,AST_LIST_HEAD_INIT(varlist)
(8070,*fh)
(8071,frametype)
(8072,f)
(8073,fr)
(8074,f.frametype = AST_FRAME_VOICE)
(8075,fr)
(8076,vh)
(8077,callno)
(8078,auth_fail(fr->callno, IAX_COMMAND_REJECT)
(8079,fr)
(8080,cur)
(8081,IAX_COMMAND_ACK)
(8082,iaxs)
(8083,ast_callid_threadassoc_add(mount_callid)
(8084,AST_CONTROL_BUSY)
(8085,iaxs[fr->callno]->owner)
(8086,fr)
(8087,ies)
(8088,fr->callno)
(8089,1)
(8090,AST_CONTROL_UNHOLD)
(8091,ast_set_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
(8092,callno)
(8093,lastms)
(8094,fr)
(8095,fr)
(8096,f)
(8097,strcpy(host_pref_buf,"disabled")
(8098,iaxs[fr->callno]->transferring = TRANSFER_READY)
(8099,iaxs[fr->callno]->pingtime)
(8100,id)
(8101,EVENT_FLAG_SYSTEM)
(8102,sizeof(pref)
(8103,iaxs[fr->callno]->prefs)
(8104,iaxsl)
(8105,fr->callno)
(8106,peer)
(8107,test_resync)
(8108,f.frametype != AST_FRAME_IAX)
(8109,thread->buf)
(8110,f.frametype)
(8111,f.datalen)
(8112,cause_code)
(8113,iaxs[fr->callno])
(8114,subclass)
(8115,callno)
(8116,sin_addr)
(8117,peer->historicms)
(8118,0)
(8119,iaxs)
(8120,callno)
(8121,iaxs[fr->callno]->videoformat = ast_format_to_old_bitfield(&f.subclass.format)
(8122,fr)
(8123,&iaxsl[fr->callno])
(8124,1)
(8125,fr)
(8126,(f.subclass.integer != IAX_COMMAND_TXREADY)
(8127,videoformat)
(8128,ntohs(sin.sin_port)
(8129,decrypted)
(8130,iaxs[fr->callno]->peercapability & iaxs[fr->callno]->capability)
(8131,f.subclass.integer != IAX_COMMAND_TXACC)
(8132,IAX_COMMAND_ACK)
(8133,peercapability)
(8134,iaxs[fr->callno]->iseqno)
(8135,cacheable)
(8136,fr->callno)
(8137,fr)
(8138,ast_string_field_set(iaxs[fr->callno], cid_name, connected.id.name.str)
(8139,fr->callno)
(8140,callno)
(8141,TRANSFER_MBEGIN)
(8142,iax_ie_append_int(&ied1, IAX_IE_FORMAT, format)
(8143,&tmpfmt)
(8144,&iaxs[fr->callno]->state)
(8145,if (iaxs[fr->callno]->owner)
(8146,subclass)
(8147,iaxs[fr->callno])
(8148,fr->callno)
(8149,iaxs[fr->callno])
(8150,)
(8151,fr)
(8152,callno)
(8153,break;)
(8154,peercallno)
(8155,f.subclass.integer)
(8156,ied0.buf)
(8157,bridged_chan)
(8158,iaxs[fr->callno])
(8159,fr)
(8160,iaxs[fr->callno]->peerformat)
(8161,fr)
(8162,connected.id.number)
(8163,callno)
(8164,)
(8165,ntohs(vh->ts)
(8166,fr)
(8167,iaxs[fr->callno])
(8168,)
(8169,iaxs)
(8170,fh)
(8171,sin_addr)
(8172,callno)
(8173,ntohs(fh->dcallno)
(8174,ied0)
(8175,f.data)
(8176,prev = var)
(8177,callno)
(8178,auth_fail(fr->callno, IAX_COMMAND_REJECT)
(8179,callno)
(8180,ied0)
(8181,cause)
(8182,iaxs[fr->callno])
(8183,callno)
(8184,&iaxs[fr->callno]->rprefs)
(8185,IAX_IE_FORMAT2)
(8186,ast_debug(1, "Immediately destroying %d, having received INVAL\\n", fr->callno)
(8187,cur->transfer)
(8188,frametype)
(8189,var->next)
(8190,iaxs[fr->callno])
(8191,ies)
(8192,IAX_COMMAND_ACK)
(8193,&iaxsl[fr->callno])
(8194,iaxs[fr->callno]->iseqno)
(8195,)
(8196,fr)
(8197,)
(8198,ast_log(LOG_NOTICE, "Peer \'%s\' is now TOO LAGGED (%d ms)
(8199,ast_format_cap_to_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner)
(8200,fr->callno)
(8201,ast_debug(1, "I can haz IAX vars, but they is no good :-(\\n")
(8202,iaxs)
(8203,format)
(8204,S_COR(connected.id.name.valid, connected.id.name.str, "")
(8205,iaxs[fr->callno])
(8206,iaxsl[fr->callno])
(8207,callno)
(8208,iaxs[fr->callno]->encmethods = 0)
(8209,f.subclass.integer)
(8210,"Rejected dial attempt from %s, request \'%s@%s\' does not exist\\n")
(8211,iaxs[fr->callno])
(8212,break;)
(8213,sizeof(tmp3)
(8214,fr)
(8215,format)
(8216,callno)
(8217,*varlist)
(8218,pref)
(8219,&ied0)
(8220,case IAX_COMMAND_TXREL:)
(8221,iseqno)
(8222,ied0.buf)
(8223,if (ast_async_goto(bridged_chan, context, ies.called_number, 1)
(8224,subclass)
(8225,iax_ie_append_short(&ied0, IAX_IE_CALLNO, iaxs[iaxs[fr->callno]->bridgecallno]->peercallno)
(8226,iaxsl[fr->callno])
(8227,iaxs)
(8228,fr)
(8229,cid_num)
(8230,IAX_PROVISION)
(8231,sin)
(8232,owner)
(8233,f.frametype == AST_FRAME_CONTROL)
(8234,mh)
(8235,new_peercallno)
(8236,sin_addr)
(8237,fr->callno)
(8238,peer->lastms)
(8239,context)
(8240,fr)
(8241,peer->historicms > 0)
(8242,fr->callno)
(8243,)
(8244,iaxs[fr->callno]->last & 0xFFFF8000L)
(8245,f.frametype == AST_FRAME_VOICE)
(8246,f.subclass == IAX_COMMAND_NEW ||\n\\n\\t\\t\\t\\t\\t\\t\\t\\t f.subclass == IAX_COMMAND_AUTHREQ ||\n\\n\\t\\t\\t\\t\\t\\t\\t\\t f.subclass == IAX_COMMAND_ACCEPT ||\n\\n\\t\\t\\t\\t\\t\\t\\t\\t f.subclass == IAX_COMMAND_REJECT)
(8247,ast_exists_extension(NULL, iaxs[fr->callno]->context, iaxs[fr->callno]->exten, 1, iaxs[fr->callno]->cid_num)
(8248,ast_queue_control_data(iaxs[fr->callno]->owner, AST_CONTROL_PVT_CAUSE_CODE, cause_code, data_size)
(8249,fr->iseqno)
(8250,fr)
(8251,iaxs[fr->callno])
(8252,!iaxs[fr->callno])
(8253,fr)
(8254,f.subclass.integer != IAX_COMMAND_TXREADY)
(8255,"For call=%d, set last=%d\\n")
(8256,)
(8257,ies.vars)
(8258,)
(8259,fr->callno)
(8260,authdebug)
(8261,value)
(8262,f)
(8263,f)
(8264,fr)
(8265,owner)
(8266,if (!inaddrcmp(&sin, &iaxs[fr->callno]->addr)
(8267,frametype)
(8268,callno)
(8269,prev)
(8270,"Rejected connect attempt from %s, who was trying to reach \'%s@%s\'\\n")
(8271,ied0)
(8272,callno)
(8273,iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner)
(8274,iaxs[fr->callno]->calling_pres)
(8275,callno)
(8276,iaxs[fr->callno]->state)
(8277,sin.sin_port)
(8278,iaxs)
(8279,fr->callno)
(8280,iaxs)
(8281,!iaxs[fr->callno])
(8282,iaxs[fr->callno]->owner)
(8283,ied0)
(8284,fr)
(8285,updatehistory=1)
(8286,-1)
(8287,)
(8288,iaxs[fr->callno]->rseqno)
(8289,peer->smoothing)
(8290,sin)
(8291,fr->af.subclass.integer = IAX_COMMAND_LAGRP)
(8292,AST_FRAME_IAX)
(8293,memset(&ied0, 0, sizeof(ied0)
(8294,1)
(8295,fr->callno)
(8296,fr->ts)
(8297,iaxs[fr->callno])
(8298,iax2_lock_owner(fr->callno)
(8299,state)
(8300,IAX_STATE_TBD)
(8301,callno)
(8302,f.subclass)
(8303,iax2_getformatname(iaxs[fr->callno]->peerformat)
(8304,iaxs)
(8305,format)
(8306,1)
(8307,iaxs[fr->callno]->peerformat)
(8308,"disabled")
(8309,fr)
(8310,case IAX_COMMAND_TXREQ:)
(8311,fr->callno)
(8312,IAX_COMMAND_TXREJ)
(8313,fr->callno)
(8314,1)
(8315,ts)
(8316,iaxs)
(8317,f)
(8318,!exists)
(8319,ast_test_flag64(iaxs[fr->callno], IAX_PROVISION)
(8320,ast_mutex_unlock(&iaxsl[fr->callno])
(8321,sizeof(struct ast_iax2_mini_hdr)
(8322,ntohl(fh->ts)
(8323,iax_ie_append_byte(&ied0, IAX_IE_CAUSECODE, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL)
(8324,fr)
(8325,iaxs)
(8326,iaxs)
(8327,sin_addr)
(8328,fr->callno)
(8329,oseqno)
(8330,iaxs)
(8331,0)
(8332,retries)
(8333,fr)
(8334,1)
(8335,ast_exists_extension(NULL, context, exten, 1, cid_num)
(8336,rseqno)
(8337,callno)
(8338,memcpy(&sin, &thread->iosin, sizeof(sin)
(8339,sizeof(tmp1)
(8340,fr->callno)
(8341,f.frametype)
(8342,callno)
(8343,IAX_COMMAND_TXACC)
(8344,if (!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)
(8345,callno)
(8346,AST_FRAME_IAX)
(8347,subclass)
(8348,fr->callno)
(8349,"<unknown>")
(8350,0)
(8351,iaxs)
(8352,iaxs[fr->callno])
(8353,host_pref_buf)
(8354,ast_debug(1, "Async goto of \'%s\' to \'%s@%s\' started\\n",\n\\n\\t\\t\\t\\t\\t\\t\\t\\tast_channel_name(bridged_chan)
(8355,iaxs[fr->callno]->peercapability)
(8356,f)
(8357,)
(8358,iaxs[fr->callno])
(8359,fr->callno)
(8360,ies.fwdesc)
(8361,ast_aes_set_decrypt_key((unsigned char *)
(8362,iax_firmware_append(&ied0, (unsigned char *)
(8363,name)
(8364,rprefs)
(8365,ast_codec_pref_string(&iaxs[fr->callno]->rprefs, caller_pref_buf, sizeof(caller_pref_buf)
(8366,fr->callno)
(8367,secret)
(8368,iaxs)
(8369,&sin)
(8370,IAX_STATE_STARTED)
(8371,iaxs)
(8372,stop_stuff(fr->callno)
(8373,ntohs(fh->scallno)
(8374,res)
(8375,)
(8376,callno)
(8377,iaxsl[fr->callno])
(8378,iaxs[fr->callno]->context)
(8379,f.subclass.integer)
(8380,"Undecodable frame received from \'%s\'\\n")
(8381,)
(8382,ies)
(8383,callno)
(8384,peerformat)
(8385,sin)
(8386,iaxs[fr->callno]->state)
(8387,updatehistory)
(8388,ast_verb(3, "Releasing %s and %s\\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner)
(8389,fr)
(8390,AST_CONTROL_CONGESTION)
(8391,fr = ast_alloca(sizeof(*fr)
(8392,iaxs)
(8393,ast_copy_string(cause_code->chan_name, ast_channel_name(iaxs[fr->callno]->owner)
(8394,using_prefs)
(8395,subclass)
(8396,owner)
(8397,f)
(8398,fh->csub & ~0x40)
(8399,transferring)
(8400,f.subclass)
(8401,buf)
(8402,sin)
(8403,iaxs[fr->callno])
(8404,iaxs)
(8405,iax2_ack_registry(&ies, &sin, fr->callno)
(8406,0)
(8407,peer)
(8408,provver)
(8409,callno)
(8410,fr)
(8411,if (ast_test_flag64(iaxs[fr->callno], IAX_DELAYPBXSTART)
(8412,IAX_STATE_STARTED)
(8413,reg)
(8414,iax2_vnak(fr->callno)
(8415,iaxs[fr->callno])
(8416,fr)
(8417,iaxs)
(8418,ast_string_field_set(iaxs[fr->callno], cid_num, connected.id.number.str)
(8419,fr->callno)
(8420,buf)
(8421,fr->callno)
(8422,callno)
(8423,)
(8424,iaxs)
(8425,iaxs)
(8426,ast_log(LOG_WARNING, "Call rejected by %s: %s\\n",\n\\n\\t\\t\\t\\t\\t\\t\\tast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr)
(8427,iaxs[fr->callno])
(8428,vars)
(8429,ast_channel_caller(iaxs[fr->callno]->owner)
(8430,iaxs[fr->callno]->owner)
(8431,!ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOCAP)
(8432,decrypt_frame(fr->callno, fh, &f, &res)
(8433,iaxs[fr->callno])
(8434,fr)
(8435,peer_unref(peer)
(8436,mh)
(8437,IAX_STATE_STARTED)
(8438,)
(8439,iaxs[fr->callno]->context)
(8440,callno)
(8441,variablestore->data)
(8442,iaxsl)
(8443,"I can haz IAX vars?\\n")
(8444,memset(fr, 0, sizeof(*fr)
(8445,(f.subclass.integer != IAX_COMMAND_UNQUELCH )
(8446,connected.id)
(8447,AST_LIST_LOCK(&dpcache)
(8448,iseqno)
(8449,peercapability)
(8450,iaxs[fr->callno])
(8451,peer->pokeexpire)
(8452,peer->pokefreqnotok)
(8453,ast_variables_destroy(ies.vars)
(8454,iaxs[fr->callno])
(8455,f.subclass)
(8456,iaxs)
(8457,iaxs[fr->callno])
(8458,f.data.ptr)
(8459,fr)
(8460,subclass)
(8461,peer->name)
(8462,iaxs)
(8463,0)
(8464,challenge)
(8465,iaxs)
(8466,0)
(8467,if (!(c = ast_iax2_new(fr->callno, AST_STATE_RING, format, NULL)
(8468,owner)
(8469,if (!iaxs[fr->callno])
(8470,fr->callno)
(8471,iaxs[fr->callno]->peercallno)
(8472,case IAX_COMMAND_FWDOWNL:)
(8473,ied1)
(8474,dp)
(8475,sizeof(ied0)
(8476,IAX_COMMAND_TXCNT)
(8477,)
(8478,memset(&ied0, 0, sizeof(ied0)
(8479,f.subclass.integer == IAX_COMMAND_REGREL)
(8480,callno)
(8481,(meta->zeros == 0)
(8482,fr)
(8483,)
(8484,iaxs[fr->callno])
(8485,ast_format_set_video_mark(&f.subclass.format)
(8486,callno)
(8487,ast_format_cap_dup(ast_channel_nativeformats(iaxs[fr->callno]->owner)
(8488,iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno)
(8489,subclass)
(8490,callno)
(8491,if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)
(8492,format)
(8493,!iaxs[fr->callno])
(8494,pingtime)
(8495,ies.vars)
(8496,fr->callno)
(8497,fr->callno)
(8498,fr)
(8499,iaxs[fr->callno])
(8500,fr->callno)
(8501,fr->callno)
(8502,fr)
(8503,)
(8504,0)
(8505,iax2_allow_new(f.frametype, f.subclass.integer, 1)
(8506,callno)
(8507,sizeof(pref)
(8508,fr)
(8509,)
(8510,f.subclass.integer)
(8511,integer)
(8512,fr)
(8513,fr)
(8514,fr)
(8515,)
(8516,)
(8517,iaxs[fr->callno]->callno)
(8518,fr)
(8519,varlist)
(8520,ied1)
(8521,ies.called_number)
(8522,)
(8523,iaxs[fr->callno]->owner && ast_test_flag64(iaxs[fr->callno], IAX_QUELCH)
(8524,AST_CONTROL_PVT_CAUSE_CODE)
(8525,caller_pref_buf)
(8526,callno)
(8527,iaxs[fr->callno])
(8528,iaxs[fr->callno]->capability)
(8529,f.subclass)
(8530,transferring)
(8531,fr->callno)
(8532,iaxs[fr->callno])
(8533,peercapability)
(8534,sin)
(8535,ied1.pos)
(8536,fr)
(8537,sin)
(8538,!iaxs[fr->callno] || !iaxs[fr->callno]->owner)
(8539,callno)
(8540,sin.sin_addr)
(8541,complete_transfer(fr->callno, &ies)
(8542,NULL)
(8543,ast_codec_get_samples(&f)
(8544,-1)
(8545,if (f.datalen && (f.frametype == AST_FRAME_VOICE)
(8546,ast_inet_ntoa(sin.sin_addr)
(8547,if (orignative)
(8548,strcpy(caller_pref_buf, "disabled")
(8549,ast_var_assign(var->name, var->value)
(8550,fr->callno)
(8551,if (!IAX_CALLENCRYPTED(iaxs[fr->callno])
(8552,check_provisioning(&sin, fd, ies.serviceident, ies.provver)
(8553,)
(8554,peercapability)
(8555,tmp)
(8556,iaxs)
(8557,callno)
(8558,(f.subclass.integer != IAX_COMMAND_TXCNT)
(8559,iaxsl[fr->callno])
(8560,iaxs[fr->callno])
(8561,fr->callno)
(8562,native)
(8563,fr)
(8564,"Simulating frame ts resync, was %u now %u\\n")
(8565,sin)
(8566,0)
(8567,f.subclass.integer == IAX_COMMAND_REGREQ || f.subclass.integer == IAX_COMMAND_REGREL)
(8568,ast_set_flag64(iaxs[fr->callno], IAX_QUELCH)
(8569,if (!authenticate_request(fr->callno)
(8570,send_command_transfer(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_TXACC, 0, NULL, 0)
(8571,iaxs[fr->callno])
(8572,iaxs[fr->callno]->bridgecallno)
(8573,ast_format_cap_destroy(orignative)
(8574,NULL)
(8575,LOG_WARNING)
(8576,iaxs)
(8577,iaxs[fr->callno]->secret)
(8578,f.subclass.integer)
(8579,ast_channel_unlock(owner)
(8580,ntohs(mh->callno)
(8581,iaxs[fr->callno]->peercapability)
(8582,fr->callno)
(8583,if (decrypt_frame(fr->callno, fh, &f, &res)
(8584,callno)
(8585,)
(8586,tmpfmt)
(8587,iaxs[fr->callno])
(8588,ies.codec_prefs)
(8589,fr)
(8590,callno)
(8591,sin)
(8592,fr->callno)
(8593,ntohs(vh->ts)
(8594,peer->historicms)
(8595,fr->outoforder)
(8596,ts)
(8597,callno)
(8598,iaxs[fr->callno])
(8599,ied0)
(8600,connected.id)
(8601,iaxs[fr->callno])
(8602,callno)
(8603,if(!(iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)
(8604,NEW_ALLOW)
(8605,if (authdebug)
(8606,NULL)
(8607,iaxs)
(8608,exten)
(8609,)
(8610,fr->callno)
(8611,if (iaxdebug)
(8612,&iaxs[fr->callno]->rprefs)
(8613,)
(8614,return 1;)
(8615,f)
(8616,fr->callno)
(8617,f)
(8618,fr->callno)
(8619,callno)
(8620,transfer)
(8621,IAX_QUELCH)
(8622,callno)
(8623,iaxs[fr->callno])
(8624,sizeof(*mh)
(8625,fr)
(8626,iaxs[fr->callno])
(8627,buf)
(8628,iaxs[fr->callno]->peerformat = ast_format_cap_to_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner)
(8629,iaxs)
(8630,IAX_COMMAND_REJECT)
(8631,\'\\0\')
(8632,variablestore)
(8633,var->next)
(8634,fr)
(8635,presentation)
(8636,calling_pres)
(8637,iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec")
(8638,fr)
(8639,vh)
(8640,0)
(8641,iaxs[fr->callno]->addr)
(8642,iaxs)
(8643,bridged_chan)
(8644,callno)
(8645,buf)
(8646,iaxs[fr->callno])
(8647,capability)
(8648,fr->callno)
(8649,ast_mutex_unlock(&iaxsl[fr->callno])
(8650,1)
(8651,test_resync)
(8652,if (iaxdebug)
(8653,dcallno)
(8654,raw_hangup(&sin, ntohs(fh->dcallno)
(8655,thread->buf[res - 1])
(8656,&pref)
(8657,"<unknown>")
(8658,iaxs[fr->callno]->iseqno)
(8659,iaxs[fr->callno])
(8660,&ied0)
(8661,if (iaxs[fr->callno]->authmethods & IAX_AUTH_MD5)
(8662,iaxs)
(8663,IAX_COMMAND_HANGUP)
(8664,fr->callno)
(8665,fr)
(8666,fr->callno)
(8667,ied0.pos)
(8668,iaxs)
(8669,0)
(8670,iaxs[fr->callno]->owner)
(8671,fr)
(8672,)
(8673,iaxs[fr->callno])
(8674,ies.vars)
(8675,cur)
(8676,if (!iaxs[fr->callno])
(8677,fd = thread->iofd)
(8678,fh)
(8679,callno)
(8680,iaxs[fr->callno])
(8681,!newvar)
(8682,if (delayreject)
(8683,)
(8684,"<Unknown>")
(8685,AST_FRAME_VOICE)
(8686,transferring)
(8687,ast_mutex_unlock(&iaxsl[fr->callno])
(8688,callno)
(8689,iaxs)
(8690,peerformat)
(8691,*newvar = ast_var_assign(var->name, var->value)
(8692,1)
(8693,owner)
(8694,ies.called_number ? ies.called_number : "s")
(8695,*vh = (struct ast_iax2_video_hdr *)
(8696,lastms)
(8697,f.subclass.integer)
(8698,iaxs[fr->callno])
(8699,connected.id.number)
(8700,callno)
(8701,case IAX_COMMAND_QUELCH:)
(8702,f.subclass.integer)
(8703,callno)
(8704,0)
(8705,iaxs)
(8706,buf)
(8707,exists)
(8708,sin_addr)
(8709,fr->callno)
(8710,iaxsl[fr->callno])
(8711,IAX_COMMAND_TXACC)
(8712,f.frametype == AST_FRAME_CONTROL)
(8713,fr->callno)
(8714,1)
(8715,fh->csub)
(8716,ies)
(8717,IAX_COMMAND_FWDATA)
(8718,fr)
(8719,fr->callno)
(8720,capability)
(8721,0)
(8722,iaxs[fr->callno])
(8723,fr->callno)
(8724,if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
(8725,)
(8726,iax_ie_append_str(&ied0, IAX_IE_CAUSE, "Unable to negotiate codec")
(8727,cur->retries)
(8728,res < sizeof(*fh)
(8729,LOG_NOTICE)
(8730,cause_code->ast_cause = ies.causecode)
(8731,integer)
(8732,*fr)
(8733,1)
(8734,1)
(8735,fr)
(8736,iaxs[fr->callno])
(8737,if (f.subclass.format.id == AST_FORMAT_SLINEAR)
(8738,)
(8739,f)
(8740,ies.vars = NULL)
(8741,ast_strdupa(iaxs[fr->callno]->context)
(8742,fr->callno)
(8743,auth_fail(fr->callno, IAX_COMMAND_REJECT)
(8744,AST_SCHED_DEL(sched, iaxs[fr->callno]->initid)
(8745,pref)
(8746,res < sizeof(*mh)
(8747,res)
(8748,callno)
(8749,(new_callno = make_trunk(fr->callno, 1)
(8750,callno)
(8751,iaxs[fr->callno]->pingtime > peer->maxms)
(8752,fr)
(8753,vh)
(8754,sin)
(8755,"No channel, so populating IAXVARs to the pvt, as an intermediate step.\\n")
(8756,f.subclass.integer)
(8757,ies.cause ? ies.cause : "<unknown>")
(8758,ies)
(8759,encmethods)
(8760,fr)
(8761,integer)
(8762,datalen)
(8763,sin.sin_addr)
(8764,memset(&ied0, 0, sizeof(ied0)
(8765,fr)
(8766,sizeof(caller_pref_buf)
(8767,bridgecallno)
(8768,connected.id.number.valid)
(8769,fr)
(8770,ied0)
(8771,iaxs)
(8772,callno)
(8773,owner)
(8774,iaxs[fr->callno]->owner)
(8775,iaxs[fr->callno])
(8776,fr->callno)
(8777,f.subclass.integer != IAX_COMMAND_TXREL)
(8778,f.subclass.integer != IAX_COMMAND_TXACC)
(8779,transfer)
(8780,subclass)
(8781,iaxs[fr->callno])
(8782,"Rejected connect attempt from %s, requested \'%s\' incompatible with our capability \'%s\'.\\n")
(8783,iaxs[fr->callno]->state)
(8784,ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\\n")
(8785,frametype)
(8786,ied0.buf)
(8787,"Peer \'%s\' is now TOO LAGGED (%d ms)
(8788,ts)
(8789,f.subclass.format)
(8790,fr->callno)
(8791,varlist)
(8792,iaxs)
(8793,f.frametype == AST_FRAME_IAX)
(8794,(vh->zeros == 0)
(8795,csub)
(8796,pingtime)
(8797,ast_log(LOG_WARNING, "Call on %s is already up, can\'t start on it\\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner)
(8798,sin_addr)
(8799,variablestore->data)
(8800,iaxs)
(8801,)
(8802,fr->callno)
(8803,causecode)
(8804,fr)
(8805,IAX_DELAYPBXSTART)
(8806,fr->callno)
(8807,iaxs[fr->callno]->transferring = TRANSFER_READY)
(8808,fr)
(8809,break;)
(8810,fr)
(8811,fr->callno)
(8812,iaxs[fr->callno])
(8813,pref)
(8814,0)
(8815,fr->iseqno >= iaxs[fr->callno]->rseqno)
(8816,ies)
(8817,iaxs[fr->callno])
(8818,*using_prefs = "mine")
(8819,iaxs[fr->callno]->capability)
(8820,fr->callno)
(8821,serviceident)
(8822,ies.challenge)
(8823,callno)
(8824,iaxs[fr->callno])
(8825,iaxs[fr->callno]->bridgecallno)
(8826,1)
(8827,peer->name)
(8828,vars)
(8829,1)
(8830,fr->callno)
(8831,callno)
(8832,inaddrcmp(&sin, &iaxs[fr->callno]->addr)
(8833,iaxs[fr->callno])
(8834,ast_mutex_unlock(&iaxsl[fr->callno])
(8835,aseqno)
(8836,iaxs[fr->callno])
(8837,fr->callno)
(8838,fr->callno)
(8839,capability)
(8840,&f)
(8841,AST_FRAME_IAX)
(8842,if (f.frametype == AST_FRAME_IAX)
(8843,&sin)
(8844,ast_log(LOG_WARNING,\n\\n\\t\\t\\t\\t\\t\\t\\t\\t"Async goto of \'%s\' to \'%s@%s\' failed\\n",\n\\n\\t\\t\\t\\t\\t\\t\\t\\tast_channel_name(bridged_chan)
(8845,f.subclass.integer != IAX_COMMAND_TXCNT)
(8846,iaxs[fr->callno]->capability)
(8847,ts)
(8848,if (variablestore && varlist)
(8849,fr->callno)
(8850,1)
(8851,iaxsl[fr->callno])
(8852,ies.refresh)
(8853,iaxs)
(8854,iaxs[fr->callno])
(8855,fr)
(8856,(fh->csub >> 6)
(8857,prev = var)
(8858,id)
(8859,musiconhold)
(8860,rprefs)
(8861,using_prefs)
(8862,iax2_getformatname_multiple(tmp, sizeof(tmp)
(8863,iaxs[fr->callno]->peerformat & iaxs[fr->callno]->capability)
(8864,using_prefs = "disabled")
(8865,cur->retries = -1)
(8866,f.subclass)
(8867,tmp1)
(8868,if (!iaxs[fr->callno])
(8869,callno)
(8870,&iaxs[fr->callno]->state)
(8871,subclass)
(8872,0)
(8873,&iaxs[fr->callno]->state)
(8874,)
(8875,fr)
(8876,iax2_destroy(fr->callno)
(8877,iaxs[fr->callno]->capability)
(8878,IAX_COMMAND_TXREADY)
(8879,iaxs[fr->callno])
(8880,tmp1)
(8881,peer)
(8882,callno)
(8883,iaxs[fr->callno]->capability)
(8884,fr->callno)
(8885,cid_num)
(8886,integer)
(8887,ied0)
(8888,"Peer did not understand our iax command \'%d\'\\n")
(8889,(dcallno != 1)
(8890,AST_FRAME_IAX)
(8891,f.frametype)
(8892,varlist)
(8893,"Rejected connect attempt from %s, requested/capability \'%s\'/\'%s\' incompatible with our capability \'%s\'.\\n")
(8894,&ies)
(8895,valid)
(8896,callno)
(8897,ied0)
(8898,callno)
(8899,)
(8900,number)
(8901,iaxs[fr->callno])
(8902,iaxs[fr->callno])
(8903,buf)
(8904,callno)
(8905,0)
(8906,if(ast_test_flag64(iaxs[fr->callno], IAX_CODEC_NOPREFS)
(8907,prefs)
(8908,iaxs[fr->callno])
(8909,fr->callno)
(8910,&ied0)
(8911,ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\\n")
(8912,fr)
(8913,fr->callno)
(8914,fr)
(8915,)
(8916,fr)
(8917,peerformat)
(8918,integer)
(8919,tmp2)
(8920,*vh)
(8921,IAX_COMMAND_REGREJ)
(8922,callno)
(8923,res < 0)
(8924,)
(8925,ast_strdupa(iaxs[fr->callno]->cid_num)
(8926,peercallno)
(8927,ast_free(prev)
(8928,f.subclass.integer != IAX_COMMAND_UNQUELCH)
(8929,integer)
(8930,res)
(8931,LOG_WARNING)
(8932,addr)
(8933,ast_format_cap_from_old_bitfield(ast_channel_nativeformats(iaxs[fr->callno]->owner)
(8934,iaxs)
(8935,ast_verb(3, "Accepting DIAL from %s, formats = %s\\n",\n\\n\\t\\t\\t\\t\\t\\t\\tast_inet_ntoa(sin.sin_addr)
(8936,&tmpfmt)
(8937,callno)
(8938,peer)
(8939,format)
(8940,iaxs[fr->callno])
(8941,sizeof(caller_pref_buf)
(8942,if (iaxs[fr->callno])
(8943,iaxs)
(8944,IAX_STATE_STARTED)
(8945,AST_FRAME_IAX)
(8946,ast_mutex_unlock(&iaxsl[fr->callno])
(8947,ast_inet_ntoa(sin.sin_addr)
(8948,)
(8949,LOG_NOTICE)
(8950,callno)
(8951,integer)
(8952,iaxs[fr->callno])
(8953,fh)
(8954,fr)
(8955,ies.vars)
(8956,IAX_COMMAND_ACK)
(8957,iaxs[fr->callno]->owner)
(8958,historicms)
(8959,iaxs[fr->callno])
(8960,-1)
(8961,iaxs)
(8962,)
(8963,if (ast_test_flag64(iaxs[fr->callno], IAX_TRUNK)
(8964,ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr)
(8965,fr)
(8966,fr->callno)
(8967,ast_set_flag64(iaxs[iaxs[fr->callno]->bridgecallno], IAX_ALREADYGONE)
(8968,break;)
(8969,iaxs[fr->callno]->addr.sin_addr)
(8970,ied0)
(8971,fr)
(8972,"Peer %s: got pong, lastms %d, historicms %d, maxms %d\\n")
(8973,callno)
(8974,ts)
(8975,ntohs(mh->callno)
(8976,iaxs[fr->callno]->transferring = TRANSFER_MEDIAPASS)
(8977,&iaxs[fr->callno]->rprefs)
(8978,&ies)
(8979,iaxs)
(8980,ast_channel_name(bridged_chan)
(8981,vars)
(8982,1)
(8983,iaxs)
(8984,fr)
(8985,iax2_getformatname_multiple(tmp1, sizeof(tmp1)
(8986,pingied.buf)
(8987,f)
(8988,TRANSFER_READY)
(8989,call_to_destroy = fr->callno)
(8990,state)
(8991,case IAX_COMMAND_REGREL:)
(8992,iaxs)
(8993,sin)
(8994,iaxs[fr->callno])
(8995,using_prefs = "caller")
(8996,iaxs[fr->callno])
(8997,1)
(8998,VERBOSE_PREFIX_4)
(8999,case IAX_COMMAND_ACCEPT:)
(9000,unsigned char *)
(9001,(f.subclass.integer != IAX_COMMAND_ACK)
(9002,tmp1)
(9003,iaxsl[fr->callno])
(9004,fr->callno)
(9005,ast_channel_unlock(iaxs[fr->callno]->owner)
(9006,sin_addr)
(9007,mh->callno)
(9008,memset(&ied0, 0, sizeof(ied0)
(9009,"TBD")
(9010,fr->callno)
(9011,fr)
(9012,f.frametype != AST_FRAME_IAX)
(9013,memset(&ied0, 0, sizeof(ied0)
(9014,callno)
(9015,iaxs[fr->callno])
(9016,fr)
(9017,f.data.ptr = NULL)
(9018,callno)
(9019,fr->callno)
(9020,var)
(9021,iaxs[fr->callno])
(9022,1)
(9023,)
(9024,subclass)
(9025,frametype)
(9026,fr->callno)
(9027,iaxsl)
(9028,iaxs[fr->callno])
(9029,fr->callno)
(9030,f)
(9031,IAX_STATE_STARTED)
(9032,fr)
(9033,owner)
(9034,iax2_getformatname_multiple(tmp1, sizeof(tmp1)
(9035,iaxs[fr->callno]->last)
(9036,mh->ts)
(9037,IAX_COMMAND_UNSUPPORT)
(9038,fr->callno)
(9039,f.subclass)
(9040,pos)
(9041,iaxs)
(9042,bridgecallno)
(9043,send_command_final(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_REJECT, 0, ied0.buf, ied0.pos, -1)
(9044,ast_free(prev)
(9045,ies)
(9046,iaxs)
(9047,fr->callno)
(9048,connected.id)
(9049,fr->callno)
(9050,iaxs[fr->callno]->inkeys)
(9051,fr)
(9052,LOG_ERROR)
(9053,if (iaxs[fr->callno]->videoformat > 0)
(9054,fr)
(9055,fr)
(9056,callno)
(9057,iaxs)
(9058,"Rejected connect attempt from %s, requested/capability \'%s\'/\'%s\' incompatible with our capability \'%s\'.\\n")
(9059,fr->ts = (iaxs[fr->callno]->last & 0xFFFF0000L)
(9060,iaxs)
(9061,)
(9062,IAX_COMMAND_TXREL)
(9063,fh->csub)
(9064,&ied0)
(9065,break;)
(9066,iaxs[fr->callno])
(9067,fr->callno)
(9068,peer->historicms)
(9069,fr->ts)
(9070,IAX_COMMAND_VNAK)
(9071,"<Unknown>")
(9072,subclass)
(9073,fr->callno)
(9074,f)
(9075,callno)
(9076,iaxs[fr->callno])
(9077,ast_log(LOG_NOTICE, "Peer \'%s\' is now REACHABLE! Time: %d\\n", peer->name, iaxs[fr->callno]->pingtime)
(9078,tmp1)
(9079,dcallno)
(9080,f)
(9081,callno)
(9082,bridged_chan)
(9083,ies.vars)
(9084,callno)
(9085,connected)
(9086,iaxs[fr->callno])
(9087,fh->csub)
(9088,fr->iseqno)
(9089,dp)
(9090,fr->callno)
(9091,smoothing)
(9092,"<Unknown>")
(9093,sin)
(9094,vars)
(9095,fr)
(9096,ast_test_flag64(iaxs[fr->callno], IAX_CODEC_USER_FIRST)
(9097,callno)
(9098,ast_callid_unref(mount_callid)
(9099,iseqno)
(9100,fr)
(9101,datalen)
(9102,variablestore)
(9103,iaxs[fr->callno])
(9104,frametype)
(9105,AST_FRAME_IAX)
(9106,fr->callno)
(9107,0)
(9108,vars)
(9109,host_pref_buf)
(9110,iaxs[fr->callno]->peercapability)
(9111,ptr)
(9112,!exists)
(9113,f)
(9114,&ied0)
(9115,NULL)
(9116,if (!ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)
(9117,fr->callno)
(9118,callno)
(9119,fr->callno)
(9120,callno)
(9121,vars)
(9122,fr)
(9123,callno)
(9124,fr->iseqno)
(9125,iaxs[fr->callno]->peerformat = ies.format)
(9126,"IAX2")
(9127,iaxs[fr->callno])
(9128,!dcallno)
(9129,AST_FRAME_VOICE)
(9130,f.datalen)
(9131,)
(9132,f)
(9133,ast_inet_ntoa(iaxs[fr->callno]->addr.sin_addr)
(9134,buf)
(9135,iaxs)
(9136,callno)
(9137,tmp1)
(9138,f.frametype)
(9139,ied1)
(9140,var)
(9141,ast_verb(3, "Channel \'%s\' unable to transfer\\n", iaxs[fr->callno]->owner ? ast_channel_name(iaxs[fr->callno]->owner)
(9142,f)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^