-----label-----
1
-----code-----
void
limProcessAuthFrame(tpAniSirGlobal pMac, tANI_U8 *pRxPacketInfo, tpPESession psessionEntry)
{
    tANI_U8                 *pBody, keyId, cfgPrivacyOptImp,
                            defaultKey[SIR_MAC_KEY_LENGTH],
                            encrAuthFrame[LIM_ENCR_AUTH_BODY_LEN],
                            plainBody[256];
    tANI_U16                frameLen;
    tANI_U32                maxNumPreAuth, val;
    tSirMacAuthFrameBody    *pRxAuthFrameBody, rxAuthFrame, authFrame;
    tpSirMacMgmtHdr         pHdr;
    tCfgWepKeyEntry         *pKeyMapEntry = NULL;
    struct tLimPreAuthNode  *pAuthNode;
    tLimMlmAuthInd          mlmAuthInd;
    tANI_U8                 decryptResult;
    tANI_U8                 *pChallenge;
    tANI_U32                key_length=8;
    tANI_U8                 challengeTextArray[SIR_MAC_AUTH_CHALLENGE_LENGTH];
    tpDphHashNode           pStaDs = NULL;
    tANI_U16                assocId = 0;
    tANI_U16                currSeqNum = 0;

    // Get pointer to Authentication frame header and body
    pHdr = WDA_GET_RX_MAC_HEADER(pRxPacketInfo);
    frameLen = WDA_GET_RX_PAYLOAD_LEN(pRxPacketInfo);


    if (!frameLen)
    {
        // Log error
        limLog(pMac, LOGE,
               FL("received Authentication frame with no body from "));
        limPrintMacAddr(pMac, pHdr->sa, LOGE);

        return;
    }

    if (limIsGroupAddr(pHdr->sa))
    {
        // Received Auth frame from a BC/MC address
        // Log error and ignore it
        PELOGE(limLog(pMac, LOGE,
               FL("received Auth frame from a BC/MC address - "));)
        PELOGE( limPrintMacAddr(pMac, pHdr->sa, LOGE);)

        return;
    }
    currSeqNum = (pHdr->seqControl.seqNumHi << 4) |
                    (pHdr->seqControl.seqNumLo);
    limLog(pMac, LOG1,
               FL("Sessionid: %d System role : %d limMlmState: %d :Auth "
               "Frame Received: BSSID: "MAC_ADDRESS_STR " (RSSI %d)"),
               psessionEntry->peSessionId, GET_LIM_SYSTEM_ROLE(psessionEntry),
               psessionEntry->limMlmState, MAC_ADDR_ARRAY(pHdr->bssId),
              (uint)abs((tANI_S8)WDA_GET_RX_RSSI_NORMALIZED(pRxPacketInfo)));

    pBody = WDA_GET_RX_MPDU_DATA(pRxPacketInfo);

    //Restore default failure timeout
    if (VOS_P2P_CLIENT_MODE == psessionEntry->pePersona && psessionEntry->defaultAuthFailureTimeout)
    {
        limLog(pMac, LOG1, FL("Restore default failure timeout"));
        ccmCfgSetInt(pMac,WNI_CFG_AUTHENTICATE_FAILURE_TIMEOUT ,
                          psessionEntry->defaultAuthFailureTimeout, NULL, eANI_BOOLEAN_FALSE);
    }

    /// Determine if WEP bit is set in the FC or received MAC header
    if (pHdr->fc.wep)
    {
        /**
         * WEP bit is set in FC of MAC header.
         */

        // If TKIP counter measures enabled issue Deauth frame to station
        if ((psessionEntry->bTkipCntrMeasActive) &&
             LIM_IS_AP_ROLE(psessionEntry)) {
            PELOGE( limLog(pMac, LOGE,
               FL("Tkip counter measures Enabled, sending Deauth frame to")); )
            limPrintMacAddr(pMac, pHdr->sa, LOGE);

            limSendDeauthMgmtFrame( pMac, eSIR_MAC_MIC_FAILURE_REASON,
                                    pHdr->sa, psessionEntry, FALSE );
            return;
        }

        // Extract key ID from IV (most 2 bits of 4th byte of IV)

        keyId = (*(pBody + 3)) >> 6;

        /**
         * On STA in infrastructure BSS, Authentication frames received
         * with WEP bit set in the FC must be rejected with challenge
         * failure status code (wierd thing in the spec - this should have
         * been rejected with unspecified failure or unexpected assertion
         * of wep bit (this status code does not exist though) or
         * Out-of-sequence-Authentication-Frame status code.
         */

        if (LIM_IS_STA_ROLE(psessionEntry) ||
            LIM_IS_BT_AMP_STA_ROLE(psessionEntry)) {
            authFrame.authAlgoNumber = eSIR_SHARED_KEY;
            authFrame.authTransactionSeqNumber = SIR_MAC_AUTH_FRAME_4;
            authFrame.authStatusCode = eSIR_MAC_CHALLENGE_FAILURE_STATUS;
            // Log error
            PELOGE(limLog(pMac, LOGE,
                   FL("received Authentication frame with wep bit set on role=%d"
                   MAC_ADDRESS_STR), GET_LIM_SYSTEM_ROLE(psessionEntry),
                   MAC_ADDR_ARRAY(pHdr->sa));)

            limSendAuthMgmtFrame(pMac, &authFrame,
                                 pHdr->sa,
                                 LIM_NO_WEP_IN_FC,psessionEntry);
            return;
        }

        if (frameLen < LIM_ENCR_AUTH_BODY_LEN)
        {
            // Log error
            limLog(pMac, LOGE,
                   FL("Not enough size [%d] to decrypt received Auth frame"),
                   frameLen);
            limPrintMacAddr(pMac, pHdr->sa, LOGE);

            return;
        }
        if (LIM_IS_AP_ROLE(psessionEntry)) {
            val = psessionEntry->privacy;
        }
        else
        // Accept Authentication frame only if Privacy is implemented
        if (wlan_cfgGetInt(pMac, WNI_CFG_PRIVACY_ENABLED,
                      &val) != eSIR_SUCCESS)
        {
            /**
             * Could not get Privacy option
             * from CFG. Log error.
             */
            limLog(pMac, LOGP, FL("could not retrieve Privacy option"));
        }

        cfgPrivacyOptImp = (tANI_U8)val;
        if (cfgPrivacyOptImp)
        {
            /**
             * Privacy option is implemented.
             * Check if the received frame is Authentication
             * frame3 and there is a context for requesting STA.
             * If not, reject with unspecified failure status code
             */
            pAuthNode = limSearchPreAuthList(pMac, pHdr->sa);

            if (pAuthNode == NULL)
            {
                // Log error
                PELOGE(limLog(pMac, LOGE,
                       FL("received Authentication frame from peer that has no preauth context with WEP bit set "
                           MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)

                /**
                 * No 'pre-auth' context exists for this STA that sent
                 * an Authentication frame with FC bit set.
                 * Send Auth frame4 with 'out of sequence' status code.
                 */
                authFrame.authAlgoNumber = eSIR_SHARED_KEY;
                authFrame.authTransactionSeqNumber =
                SIR_MAC_AUTH_FRAME_4;
                authFrame.authStatusCode =
                eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;

                limSendAuthMgmtFrame(pMac, &authFrame,
                                     pHdr->sa,
                                     LIM_NO_WEP_IN_FC,psessionEntry);
                return;
            }
            else
            {
                /// Change the auth-response timeout
                limDeactivateAndChangePerStaIdTimer(pMac,
                                                    eLIM_AUTH_RSP_TIMER,
                                                    pAuthNode->authNodeIdx);

                /// 'Pre-auth' status exists for STA
                if ((pAuthNode->mlmState !=
                     eLIM_MLM_WT_AUTH_FRAME3_STATE) &&
                    (pAuthNode->mlmState !=
                     eLIM_MLM_AUTH_RSP_TIMEOUT_STATE))
                {
                   // Log error
                   PELOGE(limLog(pMac, LOGE,
                          FL("received Authentication frame from peer that is in state %d "
                          MAC_ADDRESS_STR),
                          pAuthNode->mlmState, MAC_ADDR_ARRAY(pHdr->sa));)
                    /**
                     * Should not have received Authentication frame
                     * with WEP bit set in FC in other states.
                     * Reject by sending Authenticaton frame with
                     * out of sequence Auth frame status code.
                     */

                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;
                    authFrame.authTransactionSeqNumber =
                    SIR_MAC_AUTH_FRAME_4;
                    authFrame.authStatusCode =
                    eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;

                    limSendAuthMgmtFrame(pMac, &authFrame,
                                         pHdr->sa,
                                         LIM_NO_WEP_IN_FC,psessionEntry);
                    return;
                }
            }

            /**
             * Check if there exists a key mappping key
             * for the STA that sent Authentication frame
             */
            pKeyMapEntry = limLookUpKeyMappings(pHdr->sa);

            if (pKeyMapEntry)
            {
                if (!pKeyMapEntry->wepOn)
                {
                   // Log error
                   PELOGE(limLog(pMac, LOGE,
                          FL("received Auth frame3 from peer that has NULL key map entry "
                          MAC_ADDRESS_STR),MAC_ADDR_ARRAY(pHdr->sa));)
                    /**
                     * Key Mapping entry has null key.
                     * Send Authentication frame
                     * with challenge failure status code
                     */
                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;
                    authFrame.authTransactionSeqNumber =
                    SIR_MAC_AUTH_FRAME_4;
                    authFrame.authStatusCode =
                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;

                    limSendAuthMgmtFrame(pMac, &authFrame,
                                         pHdr->sa,
                                         LIM_NO_WEP_IN_FC,psessionEntry);
                    return;
                } // if (!pKeyMapEntry->wepOn)
                else
                {
                    decryptResult = limDecryptAuthFrame(pMac, pKeyMapEntry->key,
                                                        pBody,
                                                        plainBody,
                                                        key_length,
                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH));
                    if (decryptResult == LIM_DECRYPT_ICV_FAIL)
                    {
                        // Log error
                        PELOGE(limLog(pMac, LOGE,
                               FL("received Authentication frame from peer that failed decryption, Addr "
                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)

                        limDeletePreAuthNode(pMac,
                                             pHdr->sa);
                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;
                        authFrame.authTransactionSeqNumber =
                        SIR_MAC_AUTH_FRAME_4;
                        authFrame.authStatusCode =
                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;

                        limSendAuthMgmtFrame(
                                            pMac, &authFrame,
                                            pHdr->sa,
                                            LIM_NO_WEP_IN_FC,psessionEntry);


                        return;
                    }

                    if ((sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,
                         &rxAuthFrame)!=eSIR_SUCCESS ) ||
                        ( !isAuthValid(pMac, &rxAuthFrame,psessionEntry)))
                    {
                        PELOGE(limLog(pMac, LOGE, FL(
                               "failed to convert Auth Frame to structure or Auth is not valid "));)
                        return;
                    }
                } // end if (pKeyMapEntry->key == NULL)
            } // if keyMappings has entry
            else
            {

                val = SIR_MAC_KEY_LENGTH;

                if (LIM_IS_AP_ROLE(psessionEntry)) {
                    tpSirKeys pKey;
                    pKey =  &psessionEntry->WEPKeyMaterial[keyId].key[0];
                    vos_mem_copy(defaultKey, pKey->key, pKey->keyLength);
                    val = pKey->keyLength;
                } else if (wlan_cfgGetStr(pMac,
                             (tANI_U16) (WNI_CFG_WEP_DEFAULT_KEY_1 + keyId),
                              defaultKey, &val) != eSIR_SUCCESS) {
                    /// Could not get Default key from CFG.
                    //Log error.
                    limLog(pMac, LOGP,
                           FL("could not retrieve Default key"));

                    /**
                     * Send Authentication frame
                     * with challenge failure status code
                     */

                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;
                    authFrame.authTransactionSeqNumber =
                    SIR_MAC_AUTH_FRAME_4;
                    authFrame.authStatusCode =
                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;

                    limSendAuthMgmtFrame(pMac, &authFrame,
                                         pHdr->sa,
                                         LIM_NO_WEP_IN_FC,psessionEntry);

                    return;
                }

                    key_length=val;

                    decryptResult = limDecryptAuthFrame(pMac, defaultKey,
                                                        pBody,
                                                        plainBody,
                                                        key_length,
                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH));
                    if (decryptResult == LIM_DECRYPT_ICV_FAIL)
                    {
                         // Log error
                        PELOGE(limLog(pMac, LOGE,
                               FL("received Authentication frame from peer that failed decryption: "
                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)
                       /// ICV failure
                        limDeletePreAuthNode(pMac,
                                             pHdr->sa);
                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;
                        authFrame.authTransactionSeqNumber =
                        SIR_MAC_AUTH_FRAME_4;
                        authFrame.authStatusCode =
                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;

                        limSendAuthMgmtFrame(
                                            pMac, &authFrame,
                                            pHdr->sa,
                                            LIM_NO_WEP_IN_FC,psessionEntry);
                        return;
                    }
                    if ( ( sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,
                          &rxAuthFrame)!=eSIR_SUCCESS ) ||
                        ( !isAuthValid(pMac, &rxAuthFrame, psessionEntry) ) )
                    {
                        limLog(pMac, LOGE,
                               FL("failed to convert Auth Frame to structure or Auth is not valid "));
                        return;
                    }
            } // End of check for Key Mapping/Default key presence
        }
        else
        {
            // Log error
            PELOGE(limLog(pMac, LOGE,
                   FL("received Authentication frame3 from peer that while privacy option is turned OFF "
                   MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)
            /**
             * Privacy option is not implemented.
             * So reject Authentication frame received with
             * WEP bit set by sending Authentication frame
             * with 'challenge failure' status code. This is
             * another strange thing in the spec. Status code
             * should have been 'unsupported algorithm' status code.
             */

            authFrame.authAlgoNumber = eSIR_SHARED_KEY;
            authFrame.authTransactionSeqNumber =
            SIR_MAC_AUTH_FRAME_4;
            authFrame.authStatusCode =
            eSIR_MAC_CHALLENGE_FAILURE_STATUS;

            limSendAuthMgmtFrame(pMac, &authFrame,
                                 pHdr->sa,
                                 LIM_NO_WEP_IN_FC,psessionEntry);
            return;
        } // else if (wlan_cfgGetInt(CFG_PRIVACY_OPTION_IMPLEMENTED))
    } // if (fc.wep)
    else
    {
        if ( ( sirConvertAuthFrame2Struct(pMac, pBody,
            frameLen, &rxAuthFrame)!=eSIR_SUCCESS ) ||
            ( !isAuthValid(pMac, &rxAuthFrame,psessionEntry) ) )
        {
            PELOGE(limLog(pMac, LOGE,
                   FL("failed to convert Auth Frame to structure or Auth is not valid "));)
            return;
        }
    }


    pRxAuthFrameBody = &rxAuthFrame;

   PELOGW(limLog(pMac, LOGW,
           FL("Received Auth frame with type=%d seqnum=%d, status=%d (%d)"),
           (tANI_U32) pRxAuthFrameBody->authAlgoNumber,
           (tANI_U32) pRxAuthFrameBody->authTransactionSeqNumber,
           (tANI_U32) pRxAuthFrameBody->authStatusCode,(tANI_U32)pMac->lim.gLimNumPreAuthContexts);)

    switch (pRxAuthFrameBody->authTransactionSeqNumber)
    {
        case SIR_MAC_AUTH_FRAME_1:
            // AuthFrame 1

            pStaDs = dphLookupHashEntry(pMac, pHdr->sa,
                    &assocId, &psessionEntry->dph.dphHashTable);
            if (pStaDs)
            {
                tLimMlmDisassocReq      *pMlmDisassocReq = NULL;
                tLimMlmDeauthReq        *pMlmDeauthReq = NULL;
                tAniBool                 isConnected = eSIR_TRUE;

                pMlmDisassocReq = pMac->lim.limDisassocDeauthCnfReq.pMlmDisassocReq;
                if (pMlmDisassocReq &&
                        (vos_mem_compare((tANI_U8 *) pHdr->sa,
                                         (tANI_U8 *) &pMlmDisassocReq->peerMacAddr,
                                          sizeof(tSirMacAddr))))
                {
                    PELOGE(limLog(pMac, LOGE, FL("TODO:Ack for disassoc "
                                "frame is pending Issue delsta for "
                                MAC_ADDRESS_STR),
                                MAC_ADDR_ARRAY(pMlmDisassocReq->peerMacAddr));)
                    limProcessDisassocAckTimeout(pMac);
                    isConnected = eSIR_FALSE;
                }
                pMlmDeauthReq = pMac->lim.limDisassocDeauthCnfReq.pMlmDeauthReq;
                if (pMlmDeauthReq &&
                        (vos_mem_compare((tANI_U8 *) pHdr->sa,
                                         (tANI_U8 *) &pMlmDeauthReq->peerMacAddr,
                                         sizeof(tSirMacAddr))))
                {
                    PELOGE(limLog(pMac, LOGE, FL("TODO:Ack for deauth frame "
                                "is pending Issue delsta for "
                                MAC_ADDRESS_STR),
                                MAC_ADDR_ARRAY(pMlmDeauthReq->peerMacAddr));)
                    limProcessDeauthAckTimeout(pMac);
                    isConnected = eSIR_FALSE;
                }

                /* pStaDS != NULL and isConnected = 1 means the STA is already
                 * connected, But SAP received the Auth from that station.
                 * For non PMF connection send Deauth frame as STA will retry
                 * to connect back.
                 *
                 * For PMF connection the AP should not tear down or otherwise
                 * modify the state of the existing association until the
                 * SA-Query procedure determines that the original SA is
                 * invalid.
                 */
                if (isConnected
#ifdef WLAN_FEATURE_11W
                    && !pStaDs->rmfEnabled
#endif
                                          )
                {
                    limLog(pMac, LOGE,
                            FL("STA is already connected but received auth frame"
                                "Send the Deauth and lim Delete Station Context"
                                "(staId: %d, assocId: %d) "),
                            pStaDs->staIndex, assocId);
                    limSendDeauthMgmtFrame(pMac, eSIR_MAC_UNSPEC_FAILURE_REASON,
                            (tANI_U8 *) pHdr->sa, psessionEntry, FALSE);
                    limTriggerSTAdeletion(pMac, pStaDs, psessionEntry);
                    return;
                }
            }

            /// Check if there exists pre-auth context for this STA
            pAuthNode = limSearchPreAuthList(pMac, pHdr->sa);
            if (pAuthNode)
            {
                /// Pre-auth context exists for the STA
                if (pHdr->fc.retry == 0 || pAuthNode->seqNum != currSeqNum)
                {
                    /**
                     * STA is initiating brand-new Authentication
                     * sequence after local Auth Response timeout.
                     * Or STA retrying to transmit First Auth frame due to packet drop OTA
                     * Delete Pre-auth node and fall through.
                     */
                    if(pAuthNode->fTimerStarted)
                    {
                        limDeactivateAndChangePerStaIdTimer(pMac,
                                                    eLIM_AUTH_RSP_TIMER,
                                                    pAuthNode->authNodeIdx);
                    }
                    PELOGE(limLog(pMac, LOGE, FL("STA is initiating brand-new Authentication ..."));)
                    limDeletePreAuthNode(pMac,
                                         pHdr->sa);
                    /**
                     *  SAP Mode:Disassociate the station and
                     *  delete its entry if we have its entry
                     *  already and received "auth" from the
                     *  same station.
                     */

                    for (assocId = 0; assocId < psessionEntry->dph.dphHashTable.size; assocId++)// Softap dphHashTable.size = 8
                    {
                        pStaDs = dphGetHashEntry(pMac, assocId, &psessionEntry->dph.dphHashTable);

                        if (NULL == pStaDs)
                             continue;

                        if (pStaDs->valid)
                        {
                             if (vos_mem_compare((tANI_U8 *) &pStaDs->staAddr,
                                      (tANI_U8 *) &(pHdr->sa), (tANI_U8) (sizeof(tSirMacAddr))) )
                                  break;
                        }

                        pStaDs = NULL;
                    }

                    if (NULL != pStaDs
#ifdef WLAN_FEATURE_11W
                        && !pStaDs->rmfEnabled
#endif
                       )
                    {
                        PELOGE(limLog(pMac, LOGE,
                               FL("lim Delete Station Context (staId: %d, assocId: %d) "),
                               pStaDs->staIndex, assocId);)
                        limSendDeauthMgmtFrame(pMac,
                               eSIR_MAC_UNSPEC_FAILURE_REASON, (tANI_U8 *) pAuthNode->peerMacAddr, psessionEntry, FALSE);
                        limTriggerSTAdeletion(pMac, pStaDs, psessionEntry);
                        return;
                    }
                }
                else
                {
                    /*
                     * This can happen when first authentication frame is received
                     * but ACK lost at STA side, in this case 2nd auth frame is already
                     * in transmission queue
                     * */
                    PELOGE(limLog(pMac, LOGE, FL("STA is initiating Authentication after ACK lost..."));)
                    return;
                }
            }
            if (wlan_cfgGetInt(pMac, WNI_CFG_MAX_NUM_PRE_AUTH,
                          (tANI_U32 *) &maxNumPreAuth) != eSIR_SUCCESS)
            {
                /**
                 * Could not get MaxNumPreAuth
                 * from CFG. Log error.
                 */
                limLog(pMac, LOGP,
                       FL("could not retrieve MaxNumPreAuth"));
            }
            if (pMac->lim.gLimNumPreAuthContexts == maxNumPreAuth)
            {
                PELOGE(limLog(pMac, LOGE, FL("Max number of preauth context reached"));)
                /**
                 * Maximum number of pre-auth contexts
                 * reached. Send Authentication frame
                 * with unspecified failure
                 */
                authFrame.authAlgoNumber =
                pRxAuthFrameBody->authAlgoNumber;
                authFrame.authTransactionSeqNumber =
                pRxAuthFrameBody->authTransactionSeqNumber + 1;
                authFrame.authStatusCode =
                eSIR_MAC_UNSPEC_FAILURE_STATUS;

                limSendAuthMgmtFrame(pMac, &authFrame,
                                     pHdr->sa,
                                     LIM_NO_WEP_IN_FC,psessionEntry);

                return;
            }
            /// No Pre-auth context exists for the STA.
            if (limIsAuthAlgoSupported(
                                      pMac,
                                      (tAniAuthType)
                                      pRxAuthFrameBody->authAlgoNumber, psessionEntry))
            {
                switch (pRxAuthFrameBody->authAlgoNumber)
                {
                    case eSIR_OPEN_SYSTEM:
                        PELOGW(limLog(pMac, LOGW, FL("=======> eSIR_OPEN_SYSTEM  ..."));)
                        /// Create entry for this STA in pre-auth list
                        pAuthNode = limAcquireFreePreAuthNode(pMac, &pMac->lim.gLimPreAuthTimerTable);
                        if (pAuthNode == NULL)
                        {
                            // Log error
                            limLog(pMac, LOGW,
                                   FL("Max pre-auth nodes reached "));
                            limPrintMacAddr(pMac, pHdr->sa, LOGW);

                            return;
                        }

                        PELOG1(limLog(pMac, LOG1, FL("Alloc new data: %x peer "), pAuthNode);
                        limPrintMacAddr(pMac, pHdr->sa, LOG1);)

                        vos_mem_copy((tANI_U8 *) pAuthNode->peerMacAddr,
                                      pHdr->sa,
                                      sizeof(tSirMacAddr));

                        pAuthNode->mlmState =
                        eLIM_MLM_AUTHENTICATED_STATE;
                        pAuthNode->authType = (tAniAuthType)
                                              pRxAuthFrameBody->authAlgoNumber;
                        pAuthNode->fSeen = 0;
                        pAuthNode->fTimerStarted = 0;
                        pAuthNode->seqNum = ((pHdr->seqControl.seqNumHi << 4) |
                                                (pHdr->seqControl.seqNumLo));
                        limAddPreAuthNode(pMac, pAuthNode);

                        /**
                         * Send Authenticaton frame with Success
                         * status code.
                         */

                        authFrame.authAlgoNumber =
                        pRxAuthFrameBody->authAlgoNumber;
                        authFrame.authTransactionSeqNumber =
                        pRxAuthFrameBody->authTransactionSeqNumber + 1;
                        authFrame.authStatusCode = eSIR_MAC_SUCCESS_STATUS;
                        limSendAuthMgmtFrame(
                                            pMac, &authFrame,
                                            pHdr->sa,
                                            LIM_NO_WEP_IN_FC,psessionEntry);

                        /// Send Auth indication to SME

                        vos_mem_copy((tANI_U8 *) mlmAuthInd.peerMacAddr,
                                     (tANI_U8 *) pHdr->sa,
                                     sizeof(tSirMacAddr));
                        mlmAuthInd.authType = (tAniAuthType)
                                              pRxAuthFrameBody->authAlgoNumber;
                        mlmAuthInd.sessionId = psessionEntry->smeSessionId;

                        limPostSmeMessage(pMac,
                                          LIM_MLM_AUTH_IND,
                                          (tANI_U32 *) &mlmAuthInd);
                        break;

                    case eSIR_SHARED_KEY:
                        PELOGW(limLog(pMac, LOGW, FL("=======> eSIR_SHARED_KEY  ..."));)
                        if (LIM_IS_AP_ROLE(psessionEntry)) {
                            val = psessionEntry->privacy;
                        } else if (wlan_cfgGetInt(pMac, WNI_CFG_PRIVACY_ENABLED,
                                      &val) != eSIR_SUCCESS) {
                            /**
                             * Could not get Privacy option
                             * from CFG. Log error.
                             */
                            limLog(pMac, LOGP,
                                   FL("could not retrieve Privacy option"));
                        }
                        cfgPrivacyOptImp = (tANI_U8)val;
                        if (!cfgPrivacyOptImp)
                        {
                            // Log error
                            PELOGE(limLog(pMac, LOGE,
                                   FL("received Auth frame for unsupported auth algorithm %d "
                                   MAC_ADDRESS_STR), pRxAuthFrameBody->authAlgoNumber,
                                   MAC_ADDR_ARRAY(pHdr->sa));)

                            /**
                             * Authenticator does not have WEP
                             * implemented.
                             * Reject by sending Authentication frame
                             * with Auth algorithm not supported status
                             * code.
                             */

                            authFrame.authAlgoNumber =
                            pRxAuthFrameBody->authAlgoNumber;
                            authFrame.authTransactionSeqNumber =
                            pRxAuthFrameBody->authTransactionSeqNumber + 1;
                            authFrame.authStatusCode =
                            eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS;

                            limSendAuthMgmtFrame(
                                                pMac, &authFrame,
                                                pHdr->sa,
                                                LIM_NO_WEP_IN_FC,psessionEntry);
                            return;
                        }
                        else
                        {
                            // Create entry for this STA
                            //in pre-auth list
                            pAuthNode = limAcquireFreePreAuthNode(pMac, &pMac->lim.gLimPreAuthTimerTable);
                            if (pAuthNode == NULL)
                            {
                                // Log error
                                limLog(pMac, LOGW,
                                       FL("Max pre-auth nodes reached "));
                                limPrintMacAddr(pMac, pHdr->sa, LOGW);

                                return;
                            }

                            vos_mem_copy((tANI_U8 *) pAuthNode->peerMacAddr,
                                          pHdr->sa,
                                          sizeof(tSirMacAddr));

                            pAuthNode->mlmState =
                            eLIM_MLM_WT_AUTH_FRAME3_STATE;
                            pAuthNode->authType =
                            (tAniAuthType)
                            pRxAuthFrameBody->authAlgoNumber;
                            pAuthNode->fSeen = 0;
                            pAuthNode->fTimerStarted = 0;
                            pAuthNode->seqNum =
                                    ((pHdr->seqControl.seqNumHi << 4) |
                                     (pHdr->seqControl.seqNumLo));
                            limAddPreAuthNode(pMac, pAuthNode);

                            PELOG1(limLog(pMac, LOG1, FL("Alloc new data: %x id %d peer "),
                                          pAuthNode, pAuthNode->authNodeIdx);)
                            PELOG1(limPrintMacAddr(pMac, pHdr->sa, LOG1);)

                            /// Create and activate Auth Response timer
                            if (tx_timer_change_context(&pAuthNode->timer, pAuthNode->authNodeIdx) != TX_SUCCESS)
                            {
                                /// Could not start Auth response timer.
                                // Log error
                                limLog(pMac, LOGP,
                                   FL("Unable to chg context auth response timer for peer "));
                                limPrintMacAddr(pMac, pHdr->sa, LOGP);

                                /**
                                 * Send Authenticaton frame with
                                 * unspecified failure status code.
                                 */

                                authFrame.authAlgoNumber =
                                        pRxAuthFrameBody->authAlgoNumber;
                                authFrame.authTransactionSeqNumber =
                                        pRxAuthFrameBody->authTransactionSeqNumber + 1;
                                authFrame.authStatusCode =
                                        eSIR_MAC_UNSPEC_FAILURE_STATUS;

                                limSendAuthMgmtFrame(pMac, &authFrame,
                                                     pHdr->sa,
                                                     LIM_NO_WEP_IN_FC,psessionEntry);

                                limDeletePreAuthNode(pMac, pHdr->sa);
                                return;
                            }

                            limActivateAuthRspTimer(pMac, pAuthNode);

                            pAuthNode->fTimerStarted = 1;

                            // get random bytes and use as
                            // challenge text. If it fails we already have random stack bytes.
                            if( !VOS_IS_STATUS_SUCCESS( vos_rand_get_bytes( 0, (tANI_U8 *)challengeTextArray, SIR_MAC_AUTH_CHALLENGE_LENGTH ) ) )
                            {
                               limLog(pMac, LOGE,FL("Challenge text preparation failed in limProcessAuthFrame"));
                            }

                            pChallenge = pAuthNode->challengeText;

                            vos_mem_copy(pChallenge,
                                        (tANI_U8 *) challengeTextArray,
                                         sizeof(challengeTextArray));

                            /**
                             * Sending Authenticaton frame with challenge.
                             */

                            authFrame.authAlgoNumber =
                            pRxAuthFrameBody->authAlgoNumber;
                            authFrame.authTransactionSeqNumber =
                            pRxAuthFrameBody->authTransactionSeqNumber + 1;
                            authFrame.authStatusCode =
                            eSIR_MAC_SUCCESS_STATUS;
                            authFrame.type   = SIR_MAC_CHALLENGE_TEXT_EID;
                            authFrame.length = SIR_MAC_AUTH_CHALLENGE_LENGTH;
                            vos_mem_copy(authFrame.challengeText,
                                         pAuthNode->challengeText,
                                         SIR_MAC_AUTH_CHALLENGE_LENGTH);

                            limSendAuthMgmtFrame(
                                                pMac, &authFrame,
                                                pHdr->sa,
                                                LIM_NO_WEP_IN_FC,psessionEntry);
                        } // if (wlan_cfgGetInt(CFG_PRIVACY_OPTION_IMPLEMENTED))

                        break;

                    default:
                        // Log error
                       PELOGE( limLog(pMac, LOGE,
                               FL("received Auth frame for unsupported auth algorithm %d "
                               MAC_ADDRESS_STR), pRxAuthFrameBody->authAlgoNumber,
                               MAC_ADDR_ARRAY(pHdr->sa));)

                        /**
                         * Responding party does not support the
                         * authentication algorithm requested by
                         * sending party.
                         * Reject by sending Authentication frame
                         * with auth algorithm not supported status code
                         */

                        authFrame.authAlgoNumber =
                        pRxAuthFrameBody->authAlgoNumber;
                        authFrame.authTransactionSeqNumber =
                        pRxAuthFrameBody->authTransactionSeqNumber + 1;
                        authFrame.authStatusCode =
                        eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS;

                        limSendAuthMgmtFrame(
                                            pMac, &authFrame,
                                            pHdr->sa,
                                            LIM_NO_WEP_IN_FC,psessionEntry);
                        return;
                } // end switch(pRxAuthFrameBody->authAlgoNumber)
            } // if (limIsAuthAlgoSupported(pRxAuthFrameBody->authAlgoNumber))
            else
            {
                // Log error
                PELOGE(limLog(pMac, LOGE,
                       FL("received Authentication frame for unsupported auth algorithm %d "
                       MAC_ADDRESS_STR), pRxAuthFrameBody->authAlgoNumber,
                       MAC_ADDR_ARRAY(pHdr->sa));)

                /**
                 * Responding party does not support the
                 * authentication algorithm requested by sending party.
                 * Reject Authentication with StatusCode=13.
                 */
                authFrame.authAlgoNumber =
                pRxAuthFrameBody->authAlgoNumber;
                authFrame.authTransactionSeqNumber =
                pRxAuthFrameBody->authTransactionSeqNumber + 1;
                authFrame.authStatusCode =
                eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS;

                limSendAuthMgmtFrame(pMac, &authFrame,
                                     pHdr->sa,
                                     LIM_NO_WEP_IN_FC,psessionEntry);
                return;
            } //end if (limIsAuthAlgoSupported(pRxAuthFrameBody->authAlgoNumber))
            break;

        case SIR_MAC_AUTH_FRAME_2:
            // AuthFrame 2

            if (psessionEntry->limMlmState != eLIM_MLM_WT_AUTH_FRAME2_STATE)
            {
#ifdef WLAN_FEATURE_VOWIFI_11R
                /**
                 * Check if a Reassociation is in progress and this is a
                 * Pre-Auth frame
                 */
                if ((LIM_IS_STA_ROLE(psessionEntry) ||
                     LIM_IS_BT_AMP_STA_ROLE(psessionEntry)) &&
                    (psessionEntry->limSmeState == eLIM_SME_WT_REASSOC_STATE) &&
                    (pRxAuthFrameBody->authStatusCode == eSIR_MAC_SUCCESS_STATUS) &&
                    (psessionEntry->ftPEContext.pFTPreAuthReq != NULL) &&
                    (vos_mem_compare(
                        psessionEntry->ftPEContext.pFTPreAuthReq->preAuthbssId,
                        pHdr->sa, sizeof(tSirMacAddr))))
                {
                    // Update the FTIEs in the saved auth response
                    PELOGW(limLog(pMac, LOGW, FL("received another PreAuth frame2"
                           " from peer " MAC_ADDRESS_STR" in Smestate %d"),
                           MAC_ADDR_ARRAY(pHdr->sa), psessionEntry->limSmeState);)

                    psessionEntry->ftPEContext.saved_auth_rsp_length = 0;
                    if ((pBody != NULL) && (frameLen < MAX_FTIE_SIZE))
                    {
                        vos_mem_copy(psessionEntry->ftPEContext.saved_auth_rsp,
                                     pBody, frameLen);
                        psessionEntry->ftPEContext.saved_auth_rsp_length = frameLen;
                    }
                }
                else
#endif
                {
                    /**
                     * Received Authentication frame2 in an unexpected state.
                     * Log error and ignore the frame.
                     */

                    // Log error
                    PELOG1(limLog(pMac, LOG1,
                           FL("received Auth frame2 from peer in state %d, addr "),
                           psessionEntry->limMlmState);)
                    PELOG1(limPrintMacAddr(pMac, pHdr->sa, LOG1);)
                }

                return;

            }

            if ( !vos_mem_compare((tANI_U8 *) pHdr->sa,
                                  (tANI_U8 *) &pMac->lim.gpLimMlmAuthReq->peerMacAddr,
                                  sizeof(tSirMacAddr)) )
            {
                /**
                 * Received Authentication frame from an entity
                 * other than one request was initiated.
                 * Wait until Authentication Failure Timeout.
                 */

                // Log error
                PELOGW(limLog(pMac, LOGW,
                       FL("received Auth frame2 from unexpected peer "
                       MAC_ADDRESS_STR),
                       MAC_ADDR_ARRAY(pHdr->sa));)

                break;
            }

            if (pRxAuthFrameBody->authStatusCode ==
                eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS)
            {
                /**
                 * Interoperability workaround: Linksys WAP4400N is returning
                 * wrong authType in OpenAuth response in case of
                 * SharedKey AP configuration. Pretend we don't see that,
                 * so upper layer can fallback to SharedKey authType,
                 * and successfully connect to the AP.
                 */
                if (pRxAuthFrameBody->authAlgoNumber !=
                    pMac->lim.gpLimMlmAuthReq->authType)
                {
                    pRxAuthFrameBody->authAlgoNumber =
                    pMac->lim.gpLimMlmAuthReq->authType;
                }
            }

            if (pRxAuthFrameBody->authAlgoNumber !=
                pMac->lim.gpLimMlmAuthReq->authType)
            {
                /**
                 * Received Authentication frame with an auth
                 * algorithm other than one requested.
                 * Wait until Authentication Failure Timeout.
                 */

                // Log error
                PELOGW(limLog(pMac, LOGW,
                       FL("received Auth frame2 for unexpected auth algo number %d "
                       MAC_ADDRESS_STR), pRxAuthFrameBody->authAlgoNumber,
                       MAC_ADDR_ARRAY(pHdr->sa));)

                break;
            }

            if (pRxAuthFrameBody->authStatusCode ==
                eSIR_MAC_SUCCESS_STATUS)
            {
                if (pRxAuthFrameBody->authAlgoNumber ==
                    eSIR_OPEN_SYSTEM)
                {
                    psessionEntry->limCurrentAuthType = eSIR_OPEN_SYSTEM;

                    pAuthNode = limAcquireFreePreAuthNode(pMac, &pMac->lim.gLimPreAuthTimerTable);

                    if (pAuthNode == NULL)
                    {
                        // Log error
                        limLog(pMac, LOGW,
                               FL("Max pre-auth nodes reached "));
                        limPrintMacAddr(pMac, pHdr->sa, LOGW);

                        return;
                    }

                    PELOG1(limLog(pMac, LOG1, FL("Alloc new data: %x peer "), pAuthNode);)
                    PELOG1(limPrintMacAddr(pMac, pHdr->sa, LOG1);)

                    vos_mem_copy((tANI_U8 *) pAuthNode->peerMacAddr,
                                 pMac->lim.gpLimMlmAuthReq->peerMacAddr,
                                 sizeof(tSirMacAddr));
                    pAuthNode->fTimerStarted = 0;
                    pAuthNode->seqNum = ((pHdr->seqControl.seqNumHi << 4) |
                                    (pHdr->seqControl.seqNumLo));
                    pAuthNode->authType = pMac->lim.gpLimMlmAuthReq->authType;
                    limAddPreAuthNode(pMac, pAuthNode);

                    limRestoreFromAuthState(pMac, eSIR_SME_SUCCESS,
                                            pRxAuthFrameBody->authStatusCode,psessionEntry);
                } // if (pRxAuthFrameBody->authAlgoNumber == eSIR_OPEN_SYSTEM)
                else
                {
                    // Shared key authentication

                    if (LIM_IS_AP_ROLE(psessionEntry)) {
                        val = psessionEntry->privacy;
                    } else if (wlan_cfgGetInt(pMac, WNI_CFG_PRIVACY_ENABLED,
                                  &val) != eSIR_SUCCESS) {
                        /**
                         * Could not get Privacy option
                         * from CFG. Log error.
                         */
                        limLog(pMac, LOGP,
                               FL("could not retrieve Privacy option"));
                    }
                    cfgPrivacyOptImp = (tANI_U8)val;
                    if (!cfgPrivacyOptImp)
                    {
                        /**
                         * Requesting STA does not have WEP implemented.
                         * Reject with unsupported authentication algorithm
                         * Status code and wait until auth failure timeout
                         */

                        // Log error
                       PELOGE( limLog(pMac, LOGE,
                               FL("received Auth frame from peer for unsupported auth algo %d "
                               MAC_ADDRESS_STR), pRxAuthFrameBody->authAlgoNumber,
                               MAC_ADDR_ARRAY(pHdr->sa));)

                        authFrame.authAlgoNumber =
                        pRxAuthFrameBody->authAlgoNumber;
                        authFrame.authTransactionSeqNumber =
                        pRxAuthFrameBody->authTransactionSeqNumber + 1;
                        authFrame.authStatusCode =
                        eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS;

                        limSendAuthMgmtFrame(pMac, &authFrame,
                                            pHdr->sa,
                                            LIM_NO_WEP_IN_FC,psessionEntry);
                        return;
                    }
                    else
                    {

                        if (pRxAuthFrameBody->type !=
                            SIR_MAC_CHALLENGE_TEXT_EID)
                        {
                            // Log error
                            PELOGE(limLog(pMac, LOGE,
                                   FL("received Auth frame with invalid challenge text IE"));)

                            return;
                        }

                        /**
                         * Check if there exists a key mappping key
                         * for the STA that sent Authentication frame
                         */
                        pKeyMapEntry = limLookUpKeyMappings(
                                                           pHdr->sa);

                        if (pKeyMapEntry)
                        {
                            if (pKeyMapEntry->key == NULL)
                            {
                                // Log error
                                PELOGE(limLog(pMac, LOGE,
                                       FL("received Auth frame from peer when key mapping key is NULL"
                                       MAC_ADDRESS_STR),MAC_ADDR_ARRAY(pHdr->sa));)

                                /**
                                 * Key Mapping entry has null key.
                                 * Send Auth frame with
                                 * challenge failure status code
                                 */
                                authFrame.authAlgoNumber =
                                pRxAuthFrameBody->authAlgoNumber;
                                authFrame.authTransactionSeqNumber =
                                pRxAuthFrameBody->authTransactionSeqNumber + 1;
                                authFrame.authStatusCode =
                                eSIR_MAC_CHALLENGE_FAILURE_STATUS;

                                limSendAuthMgmtFrame(pMac, &authFrame,
                                                     pHdr->sa,
                                                     LIM_NO_WEP_IN_FC,psessionEntry);

                                limRestoreFromAuthState(pMac, eSIR_SME_NO_KEY_MAPPING_KEY_FOR_PEER,
                                                              eSIR_MAC_UNSPEC_FAILURE_REASON,psessionEntry);

                                return;
                            } // if (pKeyMapEntry->key == NULL)
                            else
                            {
                                ((tpSirMacAuthFrameBody) plainBody)->authAlgoNumber =
                                sirSwapU16ifNeeded(pRxAuthFrameBody->authAlgoNumber);
                                ((tpSirMacAuthFrameBody) plainBody)->authTransactionSeqNumber =
                                sirSwapU16ifNeeded((tANI_U16) (pRxAuthFrameBody->authTransactionSeqNumber + 1));
                                ((tpSirMacAuthFrameBody) plainBody)->authStatusCode = eSIR_MAC_SUCCESS_STATUS;
                                ((tpSirMacAuthFrameBody) plainBody)->type   = SIR_MAC_CHALLENGE_TEXT_EID;
                                ((tpSirMacAuthFrameBody) plainBody)->length = SIR_MAC_AUTH_CHALLENGE_LENGTH;
                                vos_mem_copy((tANI_U8 *) ((tpSirMacAuthFrameBody) plainBody)->challengeText,
                                              pRxAuthFrameBody->challengeText,
                                              SIR_MAC_AUTH_CHALLENGE_LENGTH);

                                limEncryptAuthFrame(pMac, 0,
                                                    pKeyMapEntry->key,
                                                    plainBody,
                                                    encrAuthFrame,key_length);

                                psessionEntry->limMlmState = eLIM_MLM_WT_AUTH_FRAME4_STATE;
                                MTRACE(macTrace(pMac, TRACE_CODE_MLM_STATE, psessionEntry->peSessionId, psessionEntry->limMlmState));

                                limSendAuthMgmtFrame(pMac,
                                                     (tpSirMacAuthFrameBody) encrAuthFrame,
                                                     pHdr->sa,
                                                     LIM_WEP_IN_FC,psessionEntry);

                                break;
                            } // end if (pKeyMapEntry->key == NULL)
                        } // if (pKeyMapEntry)
                        else
                        {
                            if (wlan_cfgGetInt(pMac, WNI_CFG_WEP_DEFAULT_KEYID,
                                          &val) != eSIR_SUCCESS)
                            {
                                /**
                                 * Could not get Default keyId
                                 * from CFG. Log error.
                                 */
                                limLog(pMac, LOGP,
                                       FL("could not retrieve Default keyId"));
                            }
                            keyId = (tANI_U8)val;

                            val = SIR_MAC_KEY_LENGTH;

                            if (LIM_IS_AP_ROLE(psessionEntry)) {
                                tpSirKeys pKey;
                                pKey =  &psessionEntry->WEPKeyMaterial[keyId].key[0];
                                vos_mem_copy(defaultKey, pKey->key, pKey->keyLength);
                            } else if (wlan_cfgGetStr(pMac,
                                      (tANI_U16) (WNI_CFG_WEP_DEFAULT_KEY_1 + keyId),
                                       defaultKey, &val) != eSIR_SUCCESS) {
                                /// Could not get Default key from CFG.
                                //Log error.
                                limLog(pMac, LOGP,
                                       FL("could not retrieve Default key"));

                                authFrame.authAlgoNumber =
                                pRxAuthFrameBody->authAlgoNumber;
                                authFrame.authTransactionSeqNumber =
                                pRxAuthFrameBody->authTransactionSeqNumber + 1;
                                authFrame.authStatusCode =
                                eSIR_MAC_CHALLENGE_FAILURE_STATUS;

                                limSendAuthMgmtFrame(
                                                    pMac, &authFrame,
                                                    pHdr->sa,
                                                    LIM_NO_WEP_IN_FC,psessionEntry);

                                limRestoreFromAuthState(pMac, eSIR_SME_INVALID_WEP_DEFAULT_KEY,
                                                              eSIR_MAC_UNSPEC_FAILURE_REASON,psessionEntry);

                                break;
                            }
                                key_length=val;
                                ((tpSirMacAuthFrameBody) plainBody)->authAlgoNumber =
                                sirSwapU16ifNeeded(pRxAuthFrameBody->authAlgoNumber);
                                ((tpSirMacAuthFrameBody) plainBody)->authTransactionSeqNumber =
                                sirSwapU16ifNeeded((tANI_U16) (pRxAuthFrameBody->authTransactionSeqNumber + 1));
                                ((tpSirMacAuthFrameBody) plainBody)->authStatusCode = eSIR_MAC_SUCCESS_STATUS;
                                ((tpSirMacAuthFrameBody) plainBody)->type   = SIR_MAC_CHALLENGE_TEXT_EID;
                                ((tpSirMacAuthFrameBody) plainBody)->length = SIR_MAC_AUTH_CHALLENGE_LENGTH;
                                vos_mem_copy((tANI_U8 *) ((tpSirMacAuthFrameBody) plainBody)->challengeText,
                                              pRxAuthFrameBody->challengeText,
                                              SIR_MAC_AUTH_CHALLENGE_LENGTH);

                                limEncryptAuthFrame(pMac, keyId,
                                                    defaultKey,
                                                    plainBody,
                                                    encrAuthFrame,key_length);

                                psessionEntry->limMlmState =
                                eLIM_MLM_WT_AUTH_FRAME4_STATE;
                                MTRACE(macTrace(pMac, TRACE_CODE_MLM_STATE, psessionEntry->peSessionId, psessionEntry->limMlmState));

                                limSendAuthMgmtFrame(pMac,
                                                     (tpSirMacAuthFrameBody) encrAuthFrame,
                                                     pHdr->sa,
                                                     LIM_WEP_IN_FC,psessionEntry);

                                break;
                        } // end if (pKeyMapEntry)
                    } // end if (!wlan_cfgGetInt(CFG_PRIVACY_OPTION_IMPLEMENTED))
                } // end if (pRxAuthFrameBody->authAlgoNumber == eSIR_OPEN_SYSTEM)
            } // if (pRxAuthFrameBody->authStatusCode == eSIR_MAC_SUCCESS_STATUS)
            else
            {
                /**
                 * Authentication failure.
                 * Return Auth confirm with received failure code to SME
                 */

                // Log error
                PELOGE(limLog(pMac, LOGE,
                       FL("received Auth frame from peer with failure code %d "
                       MAC_ADDRESS_STR), pRxAuthFrameBody->authStatusCode,
                       MAC_ADDR_ARRAY(pHdr->sa));)

                limRestoreFromAuthState(pMac, eSIR_SME_AUTH_REFUSED,
                                              pRxAuthFrameBody->authStatusCode,psessionEntry);
            } // end if (pRxAuthFrameBody->authStatusCode == eSIR_MAC_SUCCESS_STATUS)

            break;

        case SIR_MAC_AUTH_FRAME_3:
            // AuthFrame 3

            if (pRxAuthFrameBody->authAlgoNumber != eSIR_SHARED_KEY)
            {
                // Log error
                PELOGE(limLog(pMac, LOGE,
                       FL("received Auth frame3 from peer with auth algo number %d "
                       MAC_ADDRESS_STR), pRxAuthFrameBody->authAlgoNumber,
                       MAC_ADDR_ARRAY(pHdr->sa));)

                /**
                 * Received Authentication frame3 with algorithm other than
                 * Shared Key authentication type. Reject with Auth frame4
                 * with 'out of sequence' status code.
                 */
                authFrame.authAlgoNumber = eSIR_SHARED_KEY;
                authFrame.authTransactionSeqNumber =
                SIR_MAC_AUTH_FRAME_4;
                authFrame.authStatusCode =
                eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;

                limSendAuthMgmtFrame(pMac, &authFrame,
                                     pHdr->sa,
                                     LIM_NO_WEP_IN_FC,psessionEntry);
                return;
            }

            if (LIM_IS_AP_ROLE(psessionEntry) ||
                LIM_IS_BT_AMP_AP_ROLE(psessionEntry) ||
                LIM_IS_IBSS_ROLE(psessionEntry)) {
                /**
                 * Check if wep bit was set in FC. If not set,
                 * reject with Authentication frame4 with
                 * 'challenge failure' status code.
                 */
                if (!pHdr->fc.wep)
                {
                    // Log error
                    PELOGE(limLog(pMac, LOGE,
                           FL("received Auth frame3 from peer with no WEP bit set "MAC_ADDRESS_STR),
                           MAC_ADDR_ARRAY(pHdr->sa));)

                    /// WEP bit is not set in FC of Auth Frame3
                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;
                    authFrame.authTransactionSeqNumber =
                    SIR_MAC_AUTH_FRAME_4;
                    authFrame.authStatusCode =
                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;

                    limSendAuthMgmtFrame(pMac, &authFrame,
                                         pHdr->sa,
                                         LIM_NO_WEP_IN_FC,psessionEntry);
                    return;
                }

                pAuthNode = limSearchPreAuthList(pMac,
                                                pHdr->sa);
                if (pAuthNode == NULL)
                {
                    // Log error
                    PELOGE(limLog(pMac, LOGW,
                           FL("received AuthFrame3 from peer that has no preauth context "
                           MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)
                   /**
                     * No 'pre-auth' context exists for
                     * this STA that sent an Authentication
                     * frame3.
                     * Send Auth frame4 with 'out of sequence'
                     * status code.
                     */
                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;
                    authFrame.authTransactionSeqNumber =
                    SIR_MAC_AUTH_FRAME_4;
                    authFrame.authStatusCode =
                    eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;

                    limSendAuthMgmtFrame(pMac, &authFrame,
                                         pHdr->sa,
                                         LIM_NO_WEP_IN_FC,psessionEntry);
                    return;
                }

                if (pAuthNode->mlmState == eLIM_MLM_AUTH_RSP_TIMEOUT_STATE)
                {
                    // Log error
                    limLog(pMac, LOGW,
                           FL("auth response timer timedout for peer "
                           MAC_ADDRESS_STR),MAC_ADDR_ARRAY(pHdr->sa));

                    /**
                     * Received Auth Frame3 after Auth Response timeout.
                     * Reject by sending Auth Frame4 with
                     * Auth respone timeout Status Code.
                     */
                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;
                    authFrame.authTransactionSeqNumber =
                    SIR_MAC_AUTH_FRAME_4;
                    authFrame.authStatusCode =
                    eSIR_MAC_AUTH_RSP_TIMEOUT_STATUS;

                    limSendAuthMgmtFrame(
                                        pMac, &authFrame,
                                        pHdr->sa,
                                        LIM_NO_WEP_IN_FC,psessionEntry);

                    /// Delete pre-auth context of STA
                    limDeletePreAuthNode(pMac,
                                         pHdr->sa);

                    return;
                } // end switch (pAuthNode->mlmState)

                if (pRxAuthFrameBody->authStatusCode != eSIR_MAC_SUCCESS_STATUS)
                {
                    /**
                     * Received Authenetication Frame 3 with status code
                     * other than success. Wait until Auth response timeout
                     * to delete STA context.
                     */

                    // Log error
                    PELOGE(limLog(pMac, LOGE,
                           FL("received Auth frame3 from peer with status code %d "
                           MAC_ADDRESS_STR), pRxAuthFrameBody->authStatusCode,
                           MAC_ADDR_ARRAY(pHdr->sa));)

                    return;
                }

                /**
                 * Check if received challenge text is same as one sent in
                 * Authentication frame3
                 */

                if (vos_mem_compare(pRxAuthFrameBody->challengeText,
                                    pAuthNode->challengeText,
                                    SIR_MAC_AUTH_CHALLENGE_LENGTH))
                {
                    /// Challenge match. STA is autheticated !

                    /// Delete Authentication response timer if running
                    limDeactivateAndChangePerStaIdTimer(pMac,
                                                        eLIM_AUTH_RSP_TIMER,
                                                        pAuthNode->authNodeIdx);

                    pAuthNode->fTimerStarted = 0;
                    pAuthNode->mlmState = eLIM_MLM_AUTHENTICATED_STATE;

                    /**
                     * Send Authentication Frame4 with 'success' Status Code.
                     */
                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;
                    authFrame.authTransactionSeqNumber =
                        SIR_MAC_AUTH_FRAME_4;
                    authFrame.authStatusCode = eSIR_MAC_SUCCESS_STATUS;

                    limSendAuthMgmtFrame(pMac, &authFrame,
                                         pHdr->sa,
                                         LIM_NO_WEP_IN_FC,psessionEntry);

                    /// Send Auth indication to SME
                    vos_mem_copy((tANI_U8 *) mlmAuthInd.peerMacAddr,
                                 (tANI_U8 *) pHdr->sa,
                                  sizeof(tSirMacAddr));
                    mlmAuthInd.authType = (tAniAuthType)
                                          pRxAuthFrameBody->authAlgoNumber;
                    mlmAuthInd.sessionId = psessionEntry->smeSessionId;

                    limPostSmeMessage(pMac,
                                      LIM_MLM_AUTH_IND,
                                      (tANI_U32 *) &mlmAuthInd);

                    break;
                }
                else
                {
                     // Log error
                    PELOGE( limLog(pMac, LOGW,
                                   FL("Challenge failure for peer "MAC_ADDRESS_STR),
                                   MAC_ADDR_ARRAY(pHdr->sa));)
                   /**
                     * Challenge Failure.
                     * Send Authentication frame4 with 'challenge failure'
                     * status code and wait until Auth response timeout to
                     * delete STA context.
                     */

                    authFrame.authAlgoNumber =
                        pRxAuthFrameBody->authAlgoNumber;
                    authFrame.authTransactionSeqNumber =
                        SIR_MAC_AUTH_FRAME_4;
                    authFrame.authStatusCode =
                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;

                    limSendAuthMgmtFrame(pMac, &authFrame,
                                         pHdr->sa,
                                         LIM_NO_WEP_IN_FC,psessionEntry);
                    return;
                }
            } // if (pMac->lim.gLimSystemRole == eLIM_AP_ROLE || ...

            break;

        case SIR_MAC_AUTH_FRAME_4:
            // AuthFrame 4
            if (psessionEntry->limMlmState != eLIM_MLM_WT_AUTH_FRAME4_STATE)
            {
                /**
                 * Received Authentication frame4 in an unexpected state.
                 * Log error and ignore the frame.
                 */

                // Log error
                PELOG1(limLog(pMac, LOG1,
                       FL("received unexpected Auth frame4 from peer in state %d, addr "
                       MAC_ADDRESS_STR), psessionEntry->limMlmState,
                       MAC_ADDR_ARRAY(pHdr->sa));)

                return;
            }

            if (pRxAuthFrameBody->authAlgoNumber != eSIR_SHARED_KEY)
            {
                /**
                 * Received Authentication frame4 with algorithm other than
                 * Shared Key authentication type.
                 * Wait until Auth failure timeout to report authentication
                 * failure to SME.
                 */

                // Log error
                PELOGE(limLog(pMac, LOGE,
                       FL("received Auth frame4 from peer with invalid auth algo %d "
                           MAC_ADDRESS_STR), pRxAuthFrameBody->authAlgoNumber,
                       MAC_ADDR_ARRAY(pHdr->sa));)

                return;
            }

            if ( !vos_mem_compare((tANI_U8 *) pHdr->sa,
                                  (tANI_U8 *) &pMac->lim.gpLimMlmAuthReq->peerMacAddr,
                                  sizeof(tSirMacAddr)) )
            {
                /**
                 * Received Authentication frame from an entity
                 * other than one to which request was initiated.
                 * Wait until Authentication Failure Timeout.
                 */

                // Log error
                PELOGE(limLog(pMac, LOGW,
                       FL("received Auth frame4 from unexpected peer "
                       MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)

                break;
            }

            if (pRxAuthFrameBody->authAlgoNumber !=
                pMac->lim.gpLimMlmAuthReq->authType)
            {
                /**
                 * Received Authentication frame with an auth algorithm
                 * other than one requested.
                 * Wait until Authentication Failure Timeout.
                 */

                PELOGE(limLog(pMac, LOGE,
                       FL("received Authentication frame from peer with invalid auth seq number %d "
                       MAC_ADDRESS_STR), pRxAuthFrameBody->authTransactionSeqNumber,
                       MAC_ADDR_ARRAY(pHdr->sa));)

                break;
            }

            if (pRxAuthFrameBody->authStatusCode ==
                eSIR_MAC_SUCCESS_STATUS)
            {
                /**
                 * Authentication Success !
                 * Inform SME of same.
                 */
                psessionEntry->limCurrentAuthType = eSIR_SHARED_KEY;

                pAuthNode = limAcquireFreePreAuthNode(pMac, &pMac->lim.gLimPreAuthTimerTable);
                if (pAuthNode == NULL)
                {
                    // Log error
                    limLog(pMac, LOGW,
                           FL("Max pre-auth nodes reached "));
                    limPrintMacAddr(pMac, pHdr->sa, LOGW);

                    return;
                }
                PELOG1(limLog(pMac, LOG1, FL("Alloc new data: %x peer "), pAuthNode);
                limPrintMacAddr(pMac, pHdr->sa, LOG1);)

                vos_mem_copy((tANI_U8 *) pAuthNode->peerMacAddr,
                             pMac->lim.gpLimMlmAuthReq->peerMacAddr,
                             sizeof(tSirMacAddr));
                pAuthNode->fTimerStarted = 0;
                pAuthNode->authType = pMac->lim.gpLimMlmAuthReq->authType;
                pAuthNode->seqNum = ((pHdr->seqControl.seqNumHi << 4) |
                                (pHdr->seqControl.seqNumLo));
                limAddPreAuthNode(pMac, pAuthNode);

                limRestoreFromAuthState(pMac, eSIR_SME_SUCCESS,
                                              pRxAuthFrameBody->authStatusCode,psessionEntry);

            } // if (pRxAuthFrameBody->authStatusCode == eSIR_MAC_SUCCESS_STATUS)
            else
            {
                /**
                 * Authentication failure.
                 * Return Auth confirm with received failure code to SME
                 */

                // Log error
                PELOGE(limLog(pMac, LOGE, FL("Authentication failure from peer "
                       MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)

                limRestoreFromAuthState(pMac, eSIR_SME_AUTH_REFUSED,
                                              pRxAuthFrameBody->authStatusCode,psessionEntry);
            } // end if (pRxAuthFrameBody->Status == 0)

            break;

        default:
            /// Invalid Authentication Frame received. Ignore it.

            // Log error
            PELOGE(limLog(pMac, LOGE,
                   FL("received Auth frame from peer with invalid auth seq "
                   "number %d " MAC_ADDRESS_STR),
                   pRxAuthFrameBody->authTransactionSeqNumber,
                   MAC_ADDR_ARRAY(pHdr->sa));)

            break;
    } // end switch (pRxAuthFrameBody->authTransactionSeqNumber)
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
3,7
5,6
5,7
6,7
8,9
10,11
10,12
11,12
13,14
13,15
16,17
16,18
17,18
19,20
21,22
21,23
21,24
21,25
21,26
21,27
21,28
21,29
21,30
21,31
21,32
21,33
21,34
21,35
21,36
21,37
21,38
21,39
21,40
21,41
21,42
21,43
21,44
21,45
21,46
21,47
21,48
22,23
23,24
23,25
23,26
23,27
23,28
23,29
23,30
24,25
26,27
26,28
29,30
31,32
33,34
33,35
35,36
36,37
38,39
38,40
40,41
41,42
43,44
43,45
45,46
47,48
48,49
48,50
49,50
51,52
53,54
54,55
54,56
54,57
55,56
57,58
59,60
61,62
62,63
62,64
62,65
62,66
63,64
65,66
65,67
68,69
70,71
72,73
73,74
73,75
74,75
76,77
78,79
79,80
79,81
80,81
82,83
82,84
82,85
85,86
86,87
88,89
89,90
89,91
90,91
92,93
92,94
95,96
96,97
96,98
97,98
99,100
101,102
102,103
102,104
103,104
105,106
107,108
108,109
108,110
109,110
111,112
111,113
114,115
115,116
115,117
116,117
118,119
118,120
120,121
122,123
123,124
123,125
124,125
126,127
126,128
128,129
129,130
131,132
132,133
132,134
133,134
135,136
135,137
137,138
138,139
140,141
141,142
141,143
142,143
144,145
144,146
146,147
148,149
149,150
149,151
150,151
152,153
152,154
154,155
156,157
157,158
157,159
158,159
160,161
160,162
161,162
163,164
165,166
166,167
166,168
167,168
169,170
169,171
170,171
172,173
174,175
174,176
175,176
176,177
178,179
178,180
178,181
179,180
180,181
180,182
180,183
180,184
181,182
183,184
185,186
187,188
187,189
188,189
191,192
192,193
192,194
192,195
192,196
193,194
195,196
197,198
197,199
198,199
201,202
204,205
204,206
205,206
205,207
206,207
208,209
208,210
209,210
212,213
212,214
212,215
213,214
214,215
215,216
216,217
217,218
217,219
218,219
220,221
220,222
221,222
222,223
222,224
223,224
223,225
224,225
224,226
225,226
230,231
231,232
231,233
232,233
232,234
233,234
237,238
238,239
239,240
239,241
240,241
242,243
242,244
243,244
245,246
247,248
247,249
248,249
248,250
249,250
249,251
250,251
252,253
252,254
253,254
256,257
256,258
257,258
260,261
260,262
261,262
262,263
262,264
262,265
262,266
263,264
265,266
267,268
269,270
269,271
270,271
273,274
274,275
274,276
274,277
274,278
274,279
274,280
275,276
277,278
279,280
281,282
281,283
282,283
285,286
287,288
289,290
289,291
289,292
290,291
290,292
291,292
291,293
292,293
296,297
296,298
296,299
296,300
296,301
296,302
296,303
297,298
297,299
298,299
298,300
299,300
300,301
300,302
301,302
304,305
304,306
305,306
307,308
309,310
309,311
309,312
309,313
310,311
311,312
312,313
313,314
313,315
313,316
313,317
313,318
313,319
314,315
316,317
318,319
320,321
320,322
321,322
324,325
326,327
329,330
330,331
330,332
331,332
333,334
333,335
334,335
335,336
336,337
337,338
337,339
338,339
342,343
342,344
343,344
343,345
344,345
344,346
345,346
347,348
349,350
349,351
350,351
352,353
354,355
354,356
354,357
354,358
354,359
354,360
355,356
356,357
356,358
357,358
357,359
358,359
361,362
363,364
364,365
364,366
365,366
365,367
366,367
369,370
371,372
372,373
372,374
373,374
373,375
374,375
377,378
379,380
380,381
382,383
382,384
383,384
383,385
384,385
386,387
388,389
388,390
388,391
389,390
390,391
390,392
390,393
390,394
390,395
391,392
393,394
395,396
397,398
397,399
398,399
401,402
403,404
404,405
404,406
404,407
404,408
405,406
407,408
409,410
409,411
410,411
413,414
416,417
416,418
416,419
417,418
417,419
418,419
420,421
422,423
423,424
424,425
424,426
425,426
427,428
427,429
428,429
431,432
431,433
432,433
432,434
433,434
433,435
433,436
433,437
434,435
436,437
438,439
440,441
441,442
443,444
445,446
446,447
447,448
447,449
447,450
447,451
448,449
450,451
452,453
454,455
454,456
455,456
458,459
459,460
459,461
460,461
462,463
462,464
463,464
463,465
464,465
467,468
469,470
469,471
469,472
470,471
472,473
472,474
472,475
472,476
473,474
474,475
474,476
475,476
477,478
477,479
477,480
478,479
480,481
482,483
482,484
483,484
486,487
486,488
486,489
487,488
487,489
488,489
490,491
492,493
492,494
492,495
492,496
492,497
492,498
493,494
494,495
495,496
496,497
496,498
497,498
497,499
498,499
501,502
503,504
504,505
504,506
505,506
505,507
506,507
509,510
511,512
512,513
512,514
512,515
512,516
512,517
512,518
513,514
515,516
517,518
518,519
520,521
520,522
521,522
524,525
526,527
529,530
529,531
530,531
531,532
531,533
531,534
531,535
532,533
534,535
536,537
538,539
538,540
539,540
542,543
542,544
543,544
543,545
544,545
545,546
545,547
546,547
546,548
547,548
550,551
552,553
553,554
553,555
554,555
554,556
555,556
558,559
560,561
560,562
560,563
560,564
560,565
560,566
561,562
562,563
563,564
564,565
564,566
565,566
565,567
566,567
569,570
571,572
572,573
572,574
573,574
573,575
574,575
577,578
579,580
580,581
580,582
580,583
580,584
580,585
580,586
581,582
583,584
585,586
586,587
588,589
588,590
589,590
592,593
594,595
597,598
598,599
598,600
599,600
601,602
601,603
602,603
604,605
604,606
605,606
608,609
608,610
608,611
609,610
611,612
612,613
612,614
612,615
613,614
614,615
614,616
615,616
618,619
618,620
618,621
618,622
618,623
618,624
619,620
620,621
621,622
622,623
622,624
623,624
623,625
624,625
627,628
629,630
630,631
630,632
631,632
631,633
632,633
635,636
637,638
638,639
638,640
638,641
638,642
638,643
638,644
639,640
641,642
643,644
644,645
646,647
646,648
647,648
650,651
652,653
655,656
655,657
655,658
656,657
657,658
657,659
658,659
660,661
660,662
660,663
660,664
660,665
660,666
660,667
661,662
663,664
665,666
665,667
666,667
669,670
671,672
673,674
675,676
675,677
676,677
677,678
679,680
679,681
680,681
682,683
684,685
684,686
685,686
685,687
686,687
688,689
690,691
690,692
690,693
690,694
690,695
690,696
690,697
691,692
692,693
693,694
694,695
694,696
695,696
695,697
696,697
699,700
701,702
702,703
702,704
703,704
703,705
704,705
707,708
709,710
710,711
710,712
711,712
711,713
712,713
715,716
717,718
718,719
718,720
718,721
718,722
718,723
718,724
719,720
721,722
723,724
724,725
726,727
726,728
727,728
730,731
732,733
735,736
735,737
736,737
736,738
737,738
738,739
738,740
739,740
739,741
739,742
739,743
739,744
740,741
742,743
744,745
746,747
746,748
747,748
750,751
751,752
753,754
755,756
756,757
757,758
757,759
757,760
757,761
758,759
760,761
762,763
763,764
765,766
767,768
767,769
768,769
769,770
770,771
770,772
770,773
770,774
770,775
770,776
771,772
772,773
772,774
773,774
775,776
777,778
777,779
777,780
778,779
778,780
779,780
781,782
783,784
783,785
783,786
783,787
784,785
785,786
785,787
786,787
788,789
790,791
791,792
791,793
792,793
794,795
795,796
795,797
796,797
796,798
797,798
797,799
798,799
798,800
799,800
802,803
806,807
807,808
807,809
807,810
807,811
808,809
810,811
812,813
812,814
813,814
816,817
816,818
817,818
820,821
821,822
821,823
822,823
824,825
824,826
825,826
828,829
828,830
829,830
829,831
830,831
830,832
830,833
830,834
830,835
831,832
833,834
835,836
835,837
836,837
837,838
839,840
839,841
840,841
842,843
844,845
846,847
847,848
849,850
851,852
851,853
851,854
851,855
851,856
851,857
852,853
853,854
853,855
853,856
853,857
854,855
856,857
858,859
860,861
860,862
861,862
864,865
865,866
865,867
866,867
866,868
867,868
870,871
872,873
873,874
873,875
874,875
874,876
875,876
878,879
880,881
881,882
881,883
882,883
882,884
883,884
886,887
888,889
889,890
889,891
889,892
889,893
889,894
889,895
890,891
892,893
894,895
895,896
897,898
897,899
898,899
901,902
903,904
906,907
907,908
907,909
908,909
910,911
912,913
913,914
913,915
914,915
916,917
916,918
916,919
916,920
916,921
916,922
916,923
917,918
919,920
921,922
923,924
925,926
927,928
929,930
929,931
930,931
931,932
933,934
933,935
934,935
936,937
938,939
938,940
939,940
939,941
940,941
942,943
944,945
944,946
944,947
944,948
944,949
944,950
944,951
945,946
946,947
947,948
948,949
948,950
949,950
949,951
950,951
953,954
955,956
956,957
956,958
957,958
957,959
958,959
961,962
963,964
964,965
964,966
965,966
965,967
966,967
969,970
971,972
972,973
972,974
972,975
972,976
972,977
972,978
973,974
975,976
977,978
978,979
980,981
980,982
981,982
984,985
986,987
989,990
989,991
990,991
990,992
991,992
992,993
992,994
993,994
993,995
993,996
993,997
993,998
994,995
996,997
998,999
1000,1001
1000,1002
1001,1002
1004,1005
1005,1006
1007,1008
1009,1010
1010,1011
1011,1012
1011,1013
1011,1014
1011,1015
1012,1013
1014,1015
1016,1017
1017,1018
1019,1020
1021,1022
1021,1023
1022,1023
1023,1024
1023,1025
1023,1026
1023,1027
1024,1025
1026,1027
1028,1029
1030,1031
1030,1032
1031,1032
1035,1036
1035,1037
1035,1038
1035,1039
1035,1040
1035,1041
1036,1037
1037,1038
1038,1039
1039,1040
1039,1041
1040,1041
1040,1042
1041,1042
1044,1045
1046,1047
1047,1048
1047,1049
1048,1049
1048,1050
1049,1050
1052,1053
1054,1055
1055,1056
1055,1057
1055,1058
1055,1059
1055,1060
1055,1061
1056,1057
1058,1059
1060,1061
1061,1062
1063,1064
1063,1065
1064,1065
1067,1068
1069,1070
1072,1073
1073,1074
1073,1075
1074,1075
1074,1076
1075,1076
1076,1077
1076,1078
1077,1078
1077,1079
1077,1080
1077,1081
1077,1082
1078,1079
1080,1081
1082,1083
1084,1085
1086,1087
1087,1088
1089,1090
1091,1092
1092,1093
1093,1094
1093,1095
1093,1096
1093,1097
1094,1095
1096,1097
1098,1099
1099,1100
1101,1102
1103,1104
1103,1105
1104,1105
1105,1106
1106,1107
1107,1108
1107,1109
1108,1109
1110,1111
1111,1112
1113,1114
-----nextToken-----
2,4,7,9,12,14,15,18,20,25,27,28,30,32,34,37,39,42,44,46,50,52,56,58,60,64,66,67,69,71,75,77,81,83,84,87,91,93,94,98,100,104,106,110,112,113,117,119,121,125,127,130,134,136,139,143,145,147,151,153,155,159,162,164,168,171,173,177,182,184,186,189,190,194,196,199,200,202,203,207,210,211,219,226,227,228,229,234,235,236,241,244,246,251,254,255,258,259,264,266,268,271,272,276,278,280,283,284,286,288,293,294,295,302,303,306,308,315,317,319,322,323,325,327,328,332,339,340,341,346,348,351,353,359,360,362,367,368,370,375,376,378,381,385,387,392,394,396,399,400,402,406,408,411,412,414,415,419,421,426,429,430,435,437,439,442,444,449,451,453,456,457,461,465,466,468,471,476,479,481,484,485,489,491,499,500,502,507,508,510,514,516,519,522,523,525,527,528,533,535,537,540,541,548,549,551,556,557,559,567,568,570,575,576,578,582,584,587,590,591,593,595,596,600,603,606,607,610,616,617,625,626,628,633,634,636,640,642,645,648,649,651,653,654,659,662,664,667,668,670,672,674,678,681,683,687,689,697,698,700,705,706,708,713,714,716,720,722,725,728,729,731,733,734,741,743,745,748,749,752,754,759,761,764,766,774,776,780,782,787,789,793,800,801,803,804,805,809,811,814,815,818,819,823,826,827,832,834,838,841,843,845,848,850,855,857,859,862,863,868,869,871,876,877,879,884,885,887,891,893,896,899,900,902,904,905,909,911,915,918,920,922,924,926,928,932,935,937,941,943,951,952,954,959,960,962,967,968,970,974,976,979,982,983,985,987,988,995,997,999,1002,1003,1006,1008,1013,1015,1018,1020,1025,1027,1029,1032,1033,1034,1042,1043,1045,1050,1051,1053,1057,1059,1062,1065,1066,1068,1070,1071,1079,1081,1083,1085,1088,1090,1095,1097,1100,1102,1109,1112
-----computeFrom-----
157,158
157,159
166,167
166,168
217,218
217,219
220,221
220,222
222,223
222,224
239,240
239,241
248,249
248,250
249,250
249,251
298,299
298,300
330,331
330,332
333,334
333,335
337,338
337,339
343,344
343,345
356,357
356,358
364,365
364,366
372,373
372,374
383,384
383,385
424,425
424,426
432,433
432,434
459,460
459,461
474,475
474,476
487,488
487,489
496,497
496,498
504,505
504,506
543,544
543,545
545,546
545,547
553,554
553,555
564,565
564,566
572,573
572,574
598,599
598,600
622,623
622,624
630,631
630,632
657,658
657,659
679,680
679,681
685,686
685,687
694,695
694,696
702,703
702,704
710,711
710,712
736,737
736,738
738,739
738,740
746,747
746,748
772,773
772,774
791,792
791,793
821,822
821,823
829,830
829,831
839,840
839,841
865,866
865,867
873,874
873,875
881,882
881,883
907,908
907,909
913,914
913,915
933,934
933,935
939,940
939,941
948,949
948,950
956,957
956,958
964,965
964,966
990,991
990,992
992,993
992,994
1000,1001
1000,1002
1039,1040
1039,1041
1047,1048
1047,1049
1074,1075
1074,1076
1076,1077
1076,1078
1107,1108
1107,1109
-----guardedBy-----
259,284
258,283
308,325
385,402
437,451
834,893
1015,1027
-----guardedByNegation-----
489,556
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;Declarator;Name;Declarator;Name;ArrayDeclarator;Name;ArrayModifier;IdExpression;Name;ArrayDeclarator;Name;ArrayModifier;IdExpression;Name;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;Declarator;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;ArrayDeclarator;Name;ArrayModifier;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;ReturnStatement;IfStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ProblemStatement;ProblemStatement;ProblemStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;ProblemStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;IfStatement;FieldReference;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;IfStatement;BinaryExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ProblemStatement;ProblemStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;ReturnStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;UnaryExpression;UnaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ProblemStatement;ProblemStatement;ReturnStatement;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;ReturnStatement;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ProblemStatement;ProblemStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;ReturnStatement;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ProblemStatement;ProblemStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;ReturnStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;IdExpression;Name;CompoundStatement;IfStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ProblemStatement;ProblemStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;ReturnStatement;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;FunctionCallExpression;UnaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ProblemStatement;ProblemStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;ReturnStatement;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ProblemStatement;ProblemStatement;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;FieldReference;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;UnaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;ReturnStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;FunctionCallExpression;UnaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ProblemStatement;ProblemStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;ReturnStatement;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;ReturnStatement;CompoundStatement;ProblemStatement;ProblemStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;ReturnStatement;CompoundStatement;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ProblemStatement;ProblemStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ProblemStatement;ProblemStatement;
-----ast_node-----
voidlimProcessAuthFrame(tpAniSirGlobal pMac, tANI_U8 *pRxPacketInfo, tpPESession psessionEntry){    tANI_U8                 *pBody, keyId, cfgPrivacyOptImp,                            defaultKey[SIR_MAC_KEY_LENGTH],                            encrAuthFrame[LIM_ENCR_AUTH_BODY_LEN],                            plainBody[256];    tANI_U16                frameLen;    tANI_U32                maxNumPreAuth, val;    tSirMacAuthFrameBody    *pRxAuthFrameBody, rxAuthFrame, authFrame;    tpSirMacMgmtHdr         pHdr;    tCfgWepKeyEntry         *pKeyMapEntry = NULL;    struct tLimPreAuthNode  *pAuthNode;    tLimMlmAuthInd          mlmAuthInd;    tANI_U8                 decryptResult;    tANI_U8                 *pChallenge;    tANI_U32                key_length=8;    tANI_U8                 challengeTextArray[SIR_MAC_AUTH_CHALLENGE_LENGTH];    tpDphHashNode           pStaDs = NULL;    tANI_U16                assocId = 0;    tANI_U16                currSeqNum = 0;    // Get pointer to Authentication frame header and body    pHdr = WDA_GET_RX_MAC_HEADER(pRxPacketInfo);    frameLen = WDA_GET_RX_PAYLOAD_LEN(pRxPacketInfo);    if (!frameLen)    {        // Log error        limLog(pMac, LOGE,               FL("received Authentication frame with no body from "));        limPrintMacAddr(pMac, pHdr->sa, LOGE);        return;    }    if (limIsGroupAddr(pHdr->sa))    {        // Received Auth frame from a BC/MC address        // Log error and ignore it        PELOGE(limLog(pMac, LOGE,               FL("received Auth frame from a BC/MC address - "));)        PELOGE( limPrintMacAddr(pMac, pHdr->sa, LOGE);)        return;    }    currSeqNum = (pHdr->seqControl.seqNumHi << 4) |                    (pHdr->seqControl.seqNumLo);    limLog(pMac, LOG1,               FL("Sessionid: %d System role : %d limMlmState: %d :Auth "               "Frame Received: BSSID: "MAC_ADDRESS_STR " (RSSI %d)"),               psessionEntry->peSessionId, GET_LIM_SYSTEM_ROLE(psessionEntry),               psessionEntry->limMlmState, MAC_ADDR_ARRAY(pHdr->bssId),              (uint)abs((tANI_S8)WDA_GET_RX_RSSI_NORMALIZED(pRxPacketInfo)));    pBody = WDA_GET_RX_MPDU_DATA(pRxPacketInfo);    //Restore default failure timeout    if (VOS_P2P_CLIENT_MODE == psessionEntry->pePersona && psessionEntry->defaultAuthFailureTimeout)    {        limLog(pMac, LOG1, FL("Restore default failure timeout"));        ccmCfgSetInt(pMac,WNI_CFG_AUTHENTICATE_FAILURE_TIMEOUT ,                          psessionEntry->defaultAuthFailureTimeout, NULL, eANI_BOOLEAN_FALSE);    }    /// Determine if WEP bit is set in the FC or received MAC header    if (pHdr->fc.wep)    {        /**         * WEP bit is set in FC of MAC header.         */        // If TKIP counter measures enabled issue Deauth frame to station        if ((psessionEntry->bTkipCntrMeasActive) &&             LIM_IS_AP_ROLE(psessionEntry)) {            PELOGE( limLog(pMac, LOGE,               FL("Tkip counter measures Enabled, sending Deauth frame to")); )            limPrintMacAddr(pMac, pHdr->sa, LOGE);            limSendDeauthMgmtFrame( pMac, eSIR_MAC_MIC_FAILURE_REASON,                                    pHdr->sa, psessionEntry, FALSE );            return;        }        // Extract key ID from IV (most 2 bits of 4th byte of IV)        keyId = (*(pBody + 3)) >> 6;        /**         * On STA in infrastructure BSS, Authentication frames received         * with WEP bit set in the FC must be rejected with challenge         * failure status code (wierd thing in the spec - this should have         * been rejected with unspecified failure or unexpected assertion         * of wep bit (this status code does not exist though) or         * Out-of-sequence-Authentication-Frame status code.         */        if (LIM_IS_STA_ROLE(psessionEntry) ||            LIM_IS_BT_AMP_STA_ROLE(psessionEntry)) {            authFrame.authAlgoNumber = eSIR_SHARED_KEY;            authFrame.authTransactionSeqNumber = SIR_MAC_AUTH_FRAME_4;            authFrame.authStatusCode = eSIR_MAC_CHALLENGE_FAILURE_STATUS;            // Log error            PELOGE(limLog(pMac, LOGE,                   FL("received Authentication frame with wep bit set on role=%d"                   MAC_ADDRESS_STR), GET_LIM_SYSTEM_ROLE(psessionEntry),                   MAC_ADDR_ARRAY(pHdr->sa));)            limSendAuthMgmtFrame(pMac, &authFrame,                                 pHdr->sa,                                 LIM_NO_WEP_IN_FC,psessionEntry);            return;        }        if (frameLen < LIM_ENCR_AUTH_BODY_LEN)        {            // Log error            limLog(pMac, LOGE,                   FL("Not enough size [%d] to decrypt received Auth frame"),                   frameLen);            limPrintMacAddr(pMac, pHdr->sa, LOGE);            return;        }        if (LIM_IS_AP_ROLE(psessionEntry)) {            val = psessionEntry->privacy;        }        else        // Accept Authentication frame only if Privacy is implemented        if (wlan_cfgGetInt(pMac, WNI_CFG_PRIVACY_ENABLED,                      &val) != eSIR_SUCCESS)        {            /**             * Could not get Privacy option             * from CFG. Log error.             */            limLog(pMac, LOGP, FL("could not retrieve Privacy option"));        }        cfgPrivacyOptImp = (tANI_U8)val;        if (cfgPrivacyOptImp)        {            /**             * Privacy option is implemented.             * Check if the received frame is Authentication             * frame3 and there is a context for requesting STA.             * If not, reject with unspecified failure status code             */            pAuthNode = limSearchPreAuthList(pMac, pHdr->sa);            if (pAuthNode == NULL)            {                // Log error                PELOGE(limLog(pMac, LOGE,                       FL("received Authentication frame from peer that has no preauth context with WEP bit set "                           MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                /**                 * No 'pre-auth' context exists for this STA that sent                 * an Authentication frame with FC bit set.                 * Send Auth frame4 with 'out of sequence' status code.                 */                authFrame.authAlgoNumber = eSIR_SHARED_KEY;                authFrame.authTransactionSeqNumber =                SIR_MAC_AUTH_FRAME_4;                authFrame.authStatusCode =                eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                limSendAuthMgmtFrame(pMac, &authFrame,                                     pHdr->sa,                                     LIM_NO_WEP_IN_FC,psessionEntry);                return;            }            else            {                /// Change the auth-response timeout                limDeactivateAndChangePerStaIdTimer(pMac,                                                    eLIM_AUTH_RSP_TIMER,                                                    pAuthNode->authNodeIdx);                /// 'Pre-auth' status exists for STA                if ((pAuthNode->mlmState !=                     eLIM_MLM_WT_AUTH_FRAME3_STATE) &&                    (pAuthNode->mlmState !=                     eLIM_MLM_AUTH_RSP_TIMEOUT_STATE))                {                   // Log error                   PELOGE(limLog(pMac, LOGE,                          FL("received Authentication frame from peer that is in state %d "                          MAC_ADDRESS_STR),                          pAuthNode->mlmState, MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * Should not have received Authentication frame                     * with WEP bit set in FC in other states.                     * Reject by sending Authenticaton frame with                     * out of sequence Auth frame status code.                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }            }            /**             * Check if there exists a key mappping key             * for the STA that sent Authentication frame             */            pKeyMapEntry = limLookUpKeyMappings(pHdr->sa);            if (pKeyMapEntry)            {                if (!pKeyMapEntry->wepOn)                {                   // Log error                   PELOGE(limLog(pMac, LOGE,                          FL("received Auth frame3 from peer that has NULL key map entry "                          MAC_ADDRESS_STR),MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * Key Mapping entry has null key.                     * Send Authentication frame                     * with challenge failure status code                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                } // if (!pKeyMapEntry->wepOn)                else                {                    decryptResult = limDecryptAuthFrame(pMac, pKeyMapEntry->key,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH));                    if (decryptResult == LIM_DECRYPT_ICV_FAIL)                    {                        // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer that failed decryption, Addr "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                        limDeletePreAuthNode(pMac,                                             pHdr->sa);                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;                        authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                        authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }                    if ((sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                         &rxAuthFrame)!=eSIR_SUCCESS ) ||                        ( !isAuthValid(pMac, &rxAuthFrame,psessionEntry)))                    {                        PELOGE(limLog(pMac, LOGE, FL(                               "failed to convert Auth Frame to structure or Auth is not valid "));)                        return;                    }                } // end if (pKeyMapEntry->key == NULL)            } // if keyMappings has entry            else            {                val = SIR_MAC_KEY_LENGTH;                if (LIM_IS_AP_ROLE(psessionEntry)) {                    tpSirKeys pKey;                    pKey =  &psessionEntry->WEPKeyMaterial[keyId].key[0];                    vos_mem_copy(defaultKey, pKey->key, pKey->keyLength);                    val = pKey->keyLength;                } else if (wlan_cfgGetStr(pMac,                             (tANI_U16) (WNI_CFG_WEP_DEFAULT_KEY_1 + keyId),                              defaultKey, &val) != eSIR_SUCCESS) {                    /// Could not get Default key from CFG.                    //Log error.                    limLog(pMac, LOGP,                           FL("could not retrieve Default key"));                    /**                     * Send Authentication frame                     * with challenge failure status code                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }                    key_length=val;                    decryptResult = limDecryptAuthFrame(pMac, defaultKey,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH));                    if (decryptResult == LIM_DECRYPT_ICV_FAIL)                    {                         // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer that failed decryption: "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                       /// ICV failure                        limDeletePreAuthNode(pMac,                                             pHdr->sa);                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;                        authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                        authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }                    if ( ( sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                          &rxAuthFrame)!=eSIR_SUCCESS ) ||                        ( !isAuthValid(pMac, &rxAuthFrame, psessionEntry) ) )                    {                        limLog(pMac, LOGE,                               FL("failed to convert Auth Frame to structure or Auth is not valid "));                        return;                    }            } // End of check for Key Mapping/Default key presence        }        else        {            // Log error            PELOGE(limLog(pMac, LOGE,                   FL("received Authentication frame3 from peer that while privacy option is turned OFF "                   MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)            /**             * Privacy option is not implemented.             * So reject Authentication frame received with             * WEP bit set by sending Authentication frame             * with 'challenge failure' status code. This is             * another strange thing in the spec. Status code             * should have been 'unsupported algorithm' status code.             */            authFrame.authAlgoNumber = eSIR_SHARED_KEY;            authFrame.authTransactionSeqNumber =            SIR_MAC_AUTH_FRAME_4;            authFrame.authStatusCode =            eSIR_MAC_CHALLENGE_FAILURE_STATUS;            limSendAuthMgmtFrame(pMac, &authFrame,                                 pHdr->sa,                                 LIM_NO_WEP_IN_FC,psessionEntry);            return;        } // else if (wlan_cfgGetInt(CFG_PRIVACY_OPTION_IMPLEMENTED))    } // if (fc.wep)    else    {        if ( ( sirConvertAuthFrame2Struct(pMac, pBody,            frameLen, &rxAuthFrame)!=eSIR_SUCCESS ) ||            ( !isAuthValid(pMac, &rxAuthFrame,psessionEntry) ) )        {            PELOGE(limLog(pMac, LOGE,                   FL("failed to convert Auth Frame to structure or Auth is not valid "));)            return;        }    }    pRxAuthFrameBody = &rxAuthFrame;   PELOGW(limLog(pMac, LOGW,           FL("Received Auth frame with type=%d seqnum=%d, status=%d (%d)"),           (tANI_U32) pRxAuthFrameBody->authAlgoNumber,           (tANI_U32) pRxAuthFrameBody->authTransactionSeqNumber,           (tANI_U32) pRxAuthFrameBody->authStatusCode,(tANI_U32)pMac->lim.gLimNumPreAuthContexts);)    switch (pRxAuthFrameBody->authTransactionSeqNumber)    {        case SIR_MAC_AUTH_FRAME_1:            // AuthFrame 1            pStaDs = dphLookupHashEntry(pMac, pHdr->sa,                    &assocId, &psessionEntry->dph.dphHashTable);            if (pStaDs)            {                tLimMlmDisassocReq      *pMlmDisassocReq = NULL;                tLimMlmDeauthReq        *pMlmDeauthReq = NULL;                tAniBool                 isConnected = eSIR_TRUE;                pMlmDisassocReq = pMac->lim.limDisassocDeauthCnfReq.pMlmDisassocReq;                if (pMlmDisassocReq &&                        (vos_mem_compare((tANI_U8 *) pHdr->sa,                                         (tANI_U8 *) &pMlmDisassocReq->peerMacAddr,                                          sizeof(tSirMacAddr))))                {                    PELOGE(limLog(pMac, LOGE, FL("TODO:Ack for disassoc "                                "frame is pending Issue delsta for "                                MAC_ADDRESS_STR),                                MAC_ADDR_ARRAY(pMlmDisassocReq->peerMacAddr));)                    limProcessDisassocAckTimeout(pMac);                    isConnected = eSIR_FALSE;                }                pMlmDeauthReq = pMac->lim.limDisassocDeauthCnfReq.pMlmDeauthReq;                if (pMlmDeauthReq &&                        (vos_mem_compare((tANI_U8 *) pHdr->sa,                                         (tANI_U8 *) &pMlmDeauthReq->peerMacAddr,                                         sizeof(tSirMacAddr))))                {                    PELOGE(limLog(pMac, LOGE, FL("TODO:Ack for deauth frame "                                "is pending Issue delsta for "                                MAC_ADDRESS_STR),                                MAC_ADDR_ARRAY(pMlmDeauthReq->peerMacAddr));)                    limProcessDeauthAckTimeout(pMac);                    isConnected = eSIR_FALSE;                }                /* pStaDS != NULL and isConnected = 1 means the STA is already                 * connected, But SAP received the Auth from that station.                 * For non PMF connection send Deauth frame as STA will retry                 * to connect back.                 *                 * For PMF connection the AP should not tear down or otherwise                 * modify the state of the existing association until the                 * SA-Query procedure determines that the original SA is                 * invalid.                 */                if (isConnected#ifdef WLAN_FEATURE_11W                    && !pStaDs->rmfEnabled#endif                                          )                {                    limLog(pMac, LOGE,                            FL("STA is already connected but received auth frame"                                "Send the Deauth and lim Delete Station Context"                                "(staId: %d, assocId: %d) "),                            pStaDs->staIndex, assocId);                    limSendDeauthMgmtFrame(pMac, eSIR_MAC_UNSPEC_FAILURE_REASON,                            (tANI_U8 *) pHdr->sa, psessionEntry, FALSE);                    limTriggerSTAdeletion(pMac, pStaDs, psessionEntry);                    return;                }            }            /// Check if there exists pre-auth context for this STA            pAuthNode = limSearchPreAuthList(pMac, pHdr->sa);            if (pAuthNode)            {                /// Pre-auth context exists for the STA                if (pHdr->fc.retry == 0 || pAuthNode->seqNum != currSeqNum)                {                    /**                     * STA is initiating brand-new Authentication                     * sequence after local Auth Response timeout.                     * Or STA retrying to transmit First Auth frame due to packet drop OTA                     * Delete Pre-auth node and fall through.                     */                    if(pAuthNode->fTimerStarted)                    {                        limDeactivateAndChangePerStaIdTimer(pMac,                                                    eLIM_AUTH_RSP_TIMER,                                                    pAuthNode->authNodeIdx);                    }                    PELOGE(limLog(pMac, LOGE, FL("STA is initiating brand-new Authentication ..."));)                    limDeletePreAuthNode(pMac,                                         pHdr->sa);                    /**                     *  SAP Mode:Disassociate the station and                     *  delete its entry if we have its entry                     *  already and received "auth" from the                     *  same station.                     */                    for (assocId = 0; assocId < psessionEntry->dph.dphHashTable.size; assocId++)// Softap dphHashTable.size = 8                    {                        pStaDs = dphGetHashEntry(pMac, assocId, &psessionEntry->dph.dphHashTable);                        if (NULL == pStaDs)                             continue;                        if (pStaDs->valid)                        {                             if (vos_mem_compare((tANI_U8 *) &pStaDs->staAddr,                                      (tANI_U8 *) &(pHdr->sa), (tANI_U8) (sizeof(tSirMacAddr))) )                                  break;                        }                        pStaDs = NULL;                    }                    if (NULL != pStaDs#ifdef WLAN_FEATURE_11W                        && !pStaDs->rmfEnabled#endif                       )                    {                        PELOGE(limLog(pMac, LOGE,                               FL("lim Delete Station Context (staId: %d, assocId: %d) "),                               pStaDs->staIndex, assocId);)                        limSendDeauthMgmtFrame(pMac,                               eSIR_MAC_UNSPEC_FAILURE_REASON, (tANI_U8 *) pAuthNode->peerMacAddr, psessionEntry, FALSE);                        limTriggerSTAdeletion(pMac, pStaDs, psessionEntry);                        return;                    }                }                else                {                    /*                     * This can happen when first authentication frame is received                     * but ACK lost at STA side, in this case 2nd auth frame is already                     * in transmission queue                     * */                    PELOGE(limLog(pMac, LOGE, FL("STA is initiating Authentication after ACK lost..."));)                    return;                }            }            if (wlan_cfgGetInt(pMac, WNI_CFG_MAX_NUM_PRE_AUTH,                          (tANI_U32 *) &maxNumPreAuth) != eSIR_SUCCESS)            {                /**                 * Could not get MaxNumPreAuth                 * from CFG. Log error.                 */                limLog(pMac, LOGP,                       FL("could not retrieve MaxNumPreAuth"));            }            if (pMac->lim.gLimNumPreAuthContexts == maxNumPreAuth)            {                PELOGE(limLog(pMac, LOGE, FL("Max number of preauth context reached"));)                /**                 * Maximum number of pre-auth contexts                 * reached. Send Authentication frame                 * with unspecified failure                 */                authFrame.authAlgoNumber =                pRxAuthFrameBody->authAlgoNumber;                authFrame.authTransactionSeqNumber =                pRxAuthFrameBody->authTransactionSeqNumber + 1;                authFrame.authStatusCode =                eSIR_MAC_UNSPEC_FAILURE_STATUS;                limSendAuthMgmtFrame(pMac, &authFrame,                                     pHdr->sa,                                     LIM_NO_WEP_IN_FC,psessionEntry);                return;            }            /// No Pre-auth context exists for the STA.            if (limIsAuthAlgoSupported(                                      pMac,                                      (tAniAuthType)                                      pRxAuthFrameBody->authAlgoNumber, psessionEntry))            {                switch (pRxAuthFrameBody->authAlgoNumber)                {                    case eSIR_OPEN_SYSTEM:                        PELOGW(limLog(pMac, LOGW, FL("=======> eSIR_OPEN_SYSTEM  ..."));)                        /// Create entry for this STA in pre-auth list                        pAuthNode = limAcquireFreePreAuthNode(pMac, &pMac->lim.gLimPreAuthTimerTable);                        if (pAuthNode == NULL)                        {                            // Log error                            limLog(pMac, LOGW,                                   FL("Max pre-auth nodes reached "));                            limPrintMacAddr(pMac, pHdr->sa, LOGW);                            return;                        }                        PELOG1(limLog(pMac, LOG1, FL("Alloc new data: %x peer "), pAuthNode);                        limPrintMacAddr(pMac, pHdr->sa, LOG1);)                        vos_mem_copy((tANI_U8 *) pAuthNode->peerMacAddr,                                      pHdr->sa,                                      sizeof(tSirMacAddr));                        pAuthNode->mlmState =                        eLIM_MLM_AUTHENTICATED_STATE;                        pAuthNode->authType = (tAniAuthType)                                              pRxAuthFrameBody->authAlgoNumber;                        pAuthNode->fSeen = 0;                        pAuthNode->fTimerStarted = 0;                        pAuthNode->seqNum = ((pHdr->seqControl.seqNumHi << 4) |                                                (pHdr->seqControl.seqNumLo));                        limAddPreAuthNode(pMac, pAuthNode);                        /**                         * Send Authenticaton frame with Success                         * status code.                         */                        authFrame.authAlgoNumber =                        pRxAuthFrameBody->authAlgoNumber;                        authFrame.authTransactionSeqNumber =                        pRxAuthFrameBody->authTransactionSeqNumber + 1;                        authFrame.authStatusCode = eSIR_MAC_SUCCESS_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        /// Send Auth indication to SME                        vos_mem_copy((tANI_U8 *) mlmAuthInd.peerMacAddr,                                     (tANI_U8 *) pHdr->sa,                                     sizeof(tSirMacAddr));                        mlmAuthInd.authType = (tAniAuthType)                                              pRxAuthFrameBody->authAlgoNumber;                        mlmAuthInd.sessionId = psessionEntry->smeSessionId;                        limPostSmeMessage(pMac,                                          LIM_MLM_AUTH_IND,                                          (tANI_U32 *) &mlmAuthInd);                        break;                    case eSIR_SHARED_KEY:                        PELOGW(limLog(pMac, LOGW, FL("=======> eSIR_SHARED_KEY  ..."));)                        if (LIM_IS_AP_ROLE(psessionEntry)) {                            val = psessionEntry->privacy;                        } else if (wlan_cfgGetInt(pMac, WNI_CFG_PRIVACY_ENABLED,                                      &val) != eSIR_SUCCESS) {                            /**                             * Could not get Privacy option                             * from CFG. Log error.                             */                            limLog(pMac, LOGP,                                   FL("could not retrieve Privacy option"));                        }                        cfgPrivacyOptImp = (tANI_U8)val;                        if (!cfgPrivacyOptImp)                        {                            // Log error                            PELOGE(limLog(pMac, LOGE,                                   FL("received Auth frame for unsupported auth algorithm %d "                                   MAC_ADDRESS_STR), pRxAuthFrameBody->authAlgoNumber,                                   MAC_ADDR_ARRAY(pHdr->sa));)                            /**                             * Authenticator does not have WEP                             * implemented.                             * Reject by sending Authentication frame                             * with Auth algorithm not supported status                             * code.                             */                            authFrame.authAlgoNumber =                            pRxAuthFrameBody->authAlgoNumber;                            authFrame.authTransactionSeqNumber =                            pRxAuthFrameBody->authTransactionSeqNumber + 1;                            authFrame.authStatusCode =                            eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS;                            limSendAuthMgmtFrame(                                                pMac, &authFrame,                                                pHdr->sa,                                                LIM_NO_WEP_IN_FC,psessionEntry);                            return;                        }                        else                        {                            // Create entry for this STA                            //in pre-auth list                            pAuthNode = limAcquireFreePreAuthNode(pMac, &pMac->lim.gLimPreAuthTimerTable);                            if (pAuthNode == NULL)                            {                                // Log error                                limLog(pMac, LOGW,                                       FL("Max pre-auth nodes reached "));                                limPrintMacAddr(pMac, pHdr->sa, LOGW);                                return;                            }                            vos_mem_copy((tANI_U8 *) pAuthNode->peerMacAddr,                                          pHdr->sa,                                          sizeof(tSirMacAddr));                            pAuthNode->mlmState =                            eLIM_MLM_WT_AUTH_FRAME3_STATE;                            pAuthNode->authType =                            (tAniAuthType)                            pRxAuthFrameBody->authAlgoNumber;                            pAuthNode->fSeen = 0;                            pAuthNode->fTimerStarted = 0;                            pAuthNode->seqNum =                                    ((pHdr->seqControl.seqNumHi << 4) |                                     (pHdr->seqControl.seqNumLo));                            limAddPreAuthNode(pMac, pAuthNode);                            PELOG1(limLog(pMac, LOG1, FL("Alloc new data: %x id %d peer "),                                          pAuthNode, pAuthNode->authNodeIdx);)                            PELOG1(limPrintMacAddr(pMac, pHdr->sa, LOG1);)                            /// Create and activate Auth Response timer                            if (tx_timer_change_context(&pAuthNode->timer, pAuthNode->authNodeIdx) != TX_SUCCESS)                            {                                /// Could not start Auth response timer.                                // Log error                                limLog(pMac, LOGP,                                   FL("Unable to chg context auth response timer for peer "));                                limPrintMacAddr(pMac, pHdr->sa, LOGP);                                /**                                 * Send Authenticaton frame with                                 * unspecified failure status code.                                 */                                authFrame.authAlgoNumber =                                        pRxAuthFrameBody->authAlgoNumber;                                authFrame.authTransactionSeqNumber =                                        pRxAuthFrameBody->authTransactionSeqNumber + 1;                                authFrame.authStatusCode =                                        eSIR_MAC_UNSPEC_FAILURE_STATUS;                                limSendAuthMgmtFrame(pMac, &authFrame,                                                     pHdr->sa,                                                     LIM_NO_WEP_IN_FC,psessionEntry);                                limDeletePreAuthNode(pMac, pHdr->sa);                                return;                            }                            limActivateAuthRspTimer(pMac, pAuthNode);                            pAuthNode->fTimerStarted = 1;                            // get random bytes and use as                            // challenge text. If it fails we already have random stack bytes.                            if( !VOS_IS_STATUS_SUCCESS( vos_rand_get_bytes( 0, (tANI_U8 *)challengeTextArray, SIR_MAC_AUTH_CHALLENGE_LENGTH ) ) )                            {                               limLog(pMac, LOGE,FL("Challenge text preparation failed in limProcessAuthFrame"));                            }                            pChallenge = pAuthNode->challengeText;                            vos_mem_copy(pChallenge,                                        (tANI_U8 *) challengeTextArray,                                         sizeof(challengeTextArray));                            /**                             * Sending Authenticaton frame with challenge.                             */                            authFrame.authAlgoNumber =                            pRxAuthFrameBody->authAlgoNumber;                            authFrame.authTransactionSeqNumber =                            pRxAuthFrameBody->authTransactionSeqNumber + 1;                            authFrame.authStatusCode =                            eSIR_MAC_SUCCESS_STATUS;                            authFrame.type   = SIR_MAC_CHALLENGE_TEXT_EID;                            authFrame.length = SIR_MAC_AUTH_CHALLENGE_LENGTH;                            vos_mem_copy(authFrame.challengeText,                                         pAuthNode->challengeText,                                         SIR_MAC_AUTH_CHALLENGE_LENGTH);                            limSendAuthMgmtFrame(                                                pMac, &authFrame,                                                pHdr->sa,                                                LIM_NO_WEP_IN_FC,psessionEntry);                        } // if (wlan_cfgGetInt(CFG_PRIVACY_OPTION_IMPLEMENTED))                        break;                    default:                        // Log error                       PELOGE( limLog(pMac, LOGE,                               FL("received Auth frame for unsupported auth algorithm %d "                               MAC_ADDRESS_STR), pRxAuthFrameBody->authAlgoNumber,                               MAC_ADDR_ARRAY(pHdr->sa));)                        /**                         * Responding party does not support the                         * authentication algorithm requested by                         * sending party.                         * Reject by sending Authentication frame                         * with auth algorithm not supported status code                         */                        authFrame.authAlgoNumber =                        pRxAuthFrameBody->authAlgoNumber;                        authFrame.authTransactionSeqNumber =                        pRxAuthFrameBody->authTransactionSeqNumber + 1;                        authFrame.authStatusCode =                        eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                } // end switch(pRxAuthFrameBody->authAlgoNumber)            } // if (limIsAuthAlgoSupported(pRxAuthFrameBody->authAlgoNumber))            else            {                // Log error                PELOGE(limLog(pMac, LOGE,                       FL("received Authentication frame for unsupported auth algorithm %d "                       MAC_ADDRESS_STR), pRxAuthFrameBody->authAlgoNumber,                       MAC_ADDR_ARRAY(pHdr->sa));)                /**                 * Responding party does not support the                 * authentication algorithm requested by sending party.                 * Reject Authentication with StatusCode=13.                 */                authFrame.authAlgoNumber =                pRxAuthFrameBody->authAlgoNumber;                authFrame.authTransactionSeqNumber =                pRxAuthFrameBody->authTransactionSeqNumber + 1;                authFrame.authStatusCode =                eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS;                limSendAuthMgmtFrame(pMac, &authFrame,                                     pHdr->sa,                                     LIM_NO_WEP_IN_FC,psessionEntry);                return;            } //end if (limIsAuthAlgoSupported(pRxAuthFrameBody->authAlgoNumber))            break;        case SIR_MAC_AUTH_FRAME_2:            // AuthFrame 2            if (psessionEntry->limMlmState != eLIM_MLM_WT_AUTH_FRAME2_STATE)            {#ifdef WLAN_FEATURE_VOWIFI_11R                /**                 * Check if a Reassociation is in progress and this is a                 * Pre-Auth frame                 */                if ((LIM_IS_STA_ROLE(psessionEntry) ||                     LIM_IS_BT_AMP_STA_ROLE(psessionEntry)) &&                    (psessionEntry->limSmeState == eLIM_SME_WT_REASSOC_STATE) &&                    (pRxAuthFrameBody->authStatusCode == eSIR_MAC_SUCCESS_STATUS) &&                    (psessionEntry->ftPEContext.pFTPreAuthReq != NULL) &&                    (vos_mem_compare(                        psessionEntry->ftPEContext.pFTPreAuthReq->preAuthbssId,                        pHdr->sa, sizeof(tSirMacAddr))))                {                    // Update the FTIEs in the saved auth response                    PELOGW(limLog(pMac, LOGW, FL("received another PreAuth frame2"                           " from peer " MAC_ADDRESS_STR" in Smestate %d"),                           MAC_ADDR_ARRAY(pHdr->sa), psessionEntry->limSmeState);)                    psessionEntry->ftPEContext.saved_auth_rsp_length = 0;                    if ((pBody != NULL) && (frameLen < MAX_FTIE_SIZE))                    {                        vos_mem_copy(psessionEntry->ftPEContext.saved_auth_rsp,                                     pBody, frameLen);                        psessionEntry->ftPEContext.saved_auth_rsp_length = frameLen;                    }                }                else#endif                {                    /**                     * Received Authentication frame2 in an unexpected state.                     * Log error and ignore the frame.                     */                    // Log error                    PELOG1(limLog(pMac, LOG1,                           FL("received Auth frame2 from peer in state %d, addr "),                           psessionEntry->limMlmState);)                    PELOG1(limPrintMacAddr(pMac, pHdr->sa, LOG1);)                }                return;            }            if ( !vos_mem_compare((tANI_U8 *) pHdr->sa,                                  (tANI_U8 *) &pMac->lim.gpLimMlmAuthReq->peerMacAddr,                                  sizeof(tSirMacAddr)) )            {                /**                 * Received Authentication frame from an entity                 * other than one request was initiated.                 * Wait until Authentication Failure Timeout.                 */                // Log error                PELOGW(limLog(pMac, LOGW,                       FL("received Auth frame2 from unexpected peer "                       MAC_ADDRESS_STR),                       MAC_ADDR_ARRAY(pHdr->sa));)                break;            }            if (pRxAuthFrameBody->authStatusCode ==                eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS)            {                /**                 * Interoperability workaround: Linksys WAP4400N is returning                 * wrong authType in OpenAuth response in case of                 * SharedKey AP configuration. Pretend we don't see that,                 * so upper layer can fallback to SharedKey authType,                 * and successfully connect to the AP.                 */                if (pRxAuthFrameBody->authAlgoNumber !=                    pMac->lim.gpLimMlmAuthReq->authType)                {                    pRxAuthFrameBody->authAlgoNumber =                    pMac->lim.gpLimMlmAuthReq->authType;                }            }            if (pRxAuthFrameBody->authAlgoNumber !=                pMac->lim.gpLimMlmAuthReq->authType)            {                /**                 * Received Authentication frame with an auth                 * algorithm other than one requested.                 * Wait until Authentication Failure Timeout.                 */                // Log error                PELOGW(limLog(pMac, LOGW,                       FL("received Auth frame2 for unexpected auth algo number %d "                       MAC_ADDRESS_STR), pRxAuthFrameBody->authAlgoNumber,                       MAC_ADDR_ARRAY(pHdr->sa));)                break;            }            if (pRxAuthFrameBody->authStatusCode ==                eSIR_MAC_SUCCESS_STATUS)            {                if (pRxAuthFrameBody->authAlgoNumber ==                    eSIR_OPEN_SYSTEM)                {                    psessionEntry->limCurrentAuthType = eSIR_OPEN_SYSTEM;                    pAuthNode = limAcquireFreePreAuthNode(pMac, &pMac->lim.gLimPreAuthTimerTable);                    if (pAuthNode == NULL)                    {                        // Log error                        limLog(pMac, LOGW,                               FL("Max pre-auth nodes reached "));                        limPrintMacAddr(pMac, pHdr->sa, LOGW);                        return;                    }                    PELOG1(limLog(pMac, LOG1, FL("Alloc new data: %x peer "), pAuthNode);)                    PELOG1(limPrintMacAddr(pMac, pHdr->sa, LOG1);)                    vos_mem_copy((tANI_U8 *) pAuthNode->peerMacAddr,                                 pMac->lim.gpLimMlmAuthReq->peerMacAddr,                                 sizeof(tSirMacAddr));                    pAuthNode->fTimerStarted = 0;                    pAuthNode->seqNum = ((pHdr->seqControl.seqNumHi << 4) |                                    (pHdr->seqControl.seqNumLo));                    pAuthNode->authType = pMac->lim.gpLimMlmAuthReq->authType;                    limAddPreAuthNode(pMac, pAuthNode);                    limRestoreFromAuthState(pMac, eSIR_SME_SUCCESS,                                            pRxAuthFrameBody->authStatusCode,psessionEntry);                } // if (pRxAuthFrameBody->authAlgoNumber == eSIR_OPEN_SYSTEM)                else                {                    // Shared key authentication                    if (LIM_IS_AP_ROLE(psessionEntry)) {                        val = psessionEntry->privacy;                    } else if (wlan_cfgGetInt(pMac, WNI_CFG_PRIVACY_ENABLED,                                  &val) != eSIR_SUCCESS) {                        /**                         * Could not get Privacy option                         * from CFG. Log error.                         */                        limLog(pMac, LOGP,                               FL("could not retrieve Privacy option"));                    }                    cfgPrivacyOptImp = (tANI_U8)val;                    if (!cfgPrivacyOptImp)                    {                        /**                         * Requesting STA does not have WEP implemented.                         * Reject with unsupported authentication algorithm                         * Status code and wait until auth failure timeout                         */                        // Log error                       PELOGE( limLog(pMac, LOGE,                               FL("received Auth frame from peer for unsupported auth algo %d "                               MAC_ADDRESS_STR), pRxAuthFrameBody->authAlgoNumber,                               MAC_ADDR_ARRAY(pHdr->sa));)                        authFrame.authAlgoNumber =                        pRxAuthFrameBody->authAlgoNumber;                        authFrame.authTransactionSeqNumber =                        pRxAuthFrameBody->authTransactionSeqNumber + 1;                        authFrame.authStatusCode =                        eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS;                        limSendAuthMgmtFrame(pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }                    else                    {                        if (pRxAuthFrameBody->type !=                            SIR_MAC_CHALLENGE_TEXT_EID)                        {                            // Log error                            PELOGE(limLog(pMac, LOGE,                                   FL("received Auth frame with invalid challenge text IE"));)                            return;                        }                        /**                         * Check if there exists a key mappping key                         * for the STA that sent Authentication frame                         */                        pKeyMapEntry = limLookUpKeyMappings(                                                           pHdr->sa);                        if (pKeyMapEntry)                        {                            if (pKeyMapEntry->key == NULL)                            {                                // Log error                                PELOGE(limLog(pMac, LOGE,                                       FL("received Auth frame from peer when key mapping key is NULL"                                       MAC_ADDRESS_STR),MAC_ADDR_ARRAY(pHdr->sa));)                                /**                                 * Key Mapping entry has null key.                                 * Send Auth frame with                                 * challenge failure status code                                 */                                authFrame.authAlgoNumber =                                pRxAuthFrameBody->authAlgoNumber;                                authFrame.authTransactionSeqNumber =                                pRxAuthFrameBody->authTransactionSeqNumber + 1;                                authFrame.authStatusCode =                                eSIR_MAC_CHALLENGE_FAILURE_STATUS;                                limSendAuthMgmtFrame(pMac, &authFrame,                                                     pHdr->sa,                                                     LIM_NO_WEP_IN_FC,psessionEntry);                                limRestoreFromAuthState(pMac, eSIR_SME_NO_KEY_MAPPING_KEY_FOR_PEER,                                                              eSIR_MAC_UNSPEC_FAILURE_REASON,psessionEntry);                                return;                            } // if (pKeyMapEntry->key == NULL)                            else                            {                                ((tpSirMacAuthFrameBody) plainBody)->authAlgoNumber =                                sirSwapU16ifNeeded(pRxAuthFrameBody->authAlgoNumber);                                ((tpSirMacAuthFrameBody) plainBody)->authTransactionSeqNumber =                                sirSwapU16ifNeeded((tANI_U16) (pRxAuthFrameBody->authTransactionSeqNumber + 1));                                ((tpSirMacAuthFrameBody) plainBody)->authStatusCode = eSIR_MAC_SUCCESS_STATUS;                                ((tpSirMacAuthFrameBody) plainBody)->type   = SIR_MAC_CHALLENGE_TEXT_EID;                                ((tpSirMacAuthFrameBody) plainBody)->length = SIR_MAC_AUTH_CHALLENGE_LENGTH;                                vos_mem_copy((tANI_U8 *) ((tpSirMacAuthFrameBody) plainBody)->challengeText,                                              pRxAuthFrameBody->challengeText,                                              SIR_MAC_AUTH_CHALLENGE_LENGTH);                                limEncryptAuthFrame(pMac, 0,                                                    pKeyMapEntry->key,                                                    plainBody,                                                    encrAuthFrame,key_length);                                psessionEntry->limMlmState = eLIM_MLM_WT_AUTH_FRAME4_STATE;                                MTRACE(macTrace(pMac, TRACE_CODE_MLM_STATE, psessionEntry->peSessionId, psessionEntry->limMlmState));                                limSendAuthMgmtFrame(pMac,                                                     (tpSirMacAuthFrameBody) encrAuthFrame,                                                     pHdr->sa,                                                     LIM_WEP_IN_FC,psessionEntry);                                break;                            } // end if (pKeyMapEntry->key == NULL)                        } // if (pKeyMapEntry)                        else                        {                            if (wlan_cfgGetInt(pMac, WNI_CFG_WEP_DEFAULT_KEYID,                                          &val) != eSIR_SUCCESS)                            {                                /**                                 * Could not get Default keyId                                 * from CFG. Log error.                                 */                                limLog(pMac, LOGP,                                       FL("could not retrieve Default keyId"));                            }                            keyId = (tANI_U8)val;                            val = SIR_MAC_KEY_LENGTH;                            if (LIM_IS_AP_ROLE(psessionEntry)) {                                tpSirKeys pKey;                                pKey =  &psessionEntry->WEPKeyMaterial[keyId].key[0];                                vos_mem_copy(defaultKey, pKey->key, pKey->keyLength);                            } else if (wlan_cfgGetStr(pMac,                                      (tANI_U16) (WNI_CFG_WEP_DEFAULT_KEY_1 + keyId),                                       defaultKey, &val) != eSIR_SUCCESS) {                                /// Could not get Default key from CFG.                                //Log error.                                limLog(pMac, LOGP,                                       FL("could not retrieve Default key"));                                authFrame.authAlgoNumber =                                pRxAuthFrameBody->authAlgoNumber;                                authFrame.authTransactionSeqNumber =                                pRxAuthFrameBody->authTransactionSeqNumber + 1;                                authFrame.authStatusCode =                                eSIR_MAC_CHALLENGE_FAILURE_STATUS;                                limSendAuthMgmtFrame(                                                    pMac, &authFrame,                                                    pHdr->sa,                                                    LIM_NO_WEP_IN_FC,psessionEntry);                                limRestoreFromAuthState(pMac, eSIR_SME_INVALID_WEP_DEFAULT_KEY,                                                              eSIR_MAC_UNSPEC_FAILURE_REASON,psessionEntry);                                break;                            }                                key_length=val;                                ((tpSirMacAuthFrameBody) plainBody)->authAlgoNumber =                                sirSwapU16ifNeeded(pRxAuthFrameBody->authAlgoNumber);                                ((tpSirMacAuthFrameBody) plainBody)->authTransactionSeqNumber =                                sirSwapU16ifNeeded((tANI_U16) (pRxAuthFrameBody->authTransactionSeqNumber + 1));                                ((tpSirMacAuthFrameBody) plainBody)->authStatusCode = eSIR_MAC_SUCCESS_STATUS;                                ((tpSirMacAuthFrameBody) plainBody)->type   = SIR_MAC_CHALLENGE_TEXT_EID;                                ((tpSirMacAuthFrameBody) plainBody)->length = SIR_MAC_AUTH_CHALLENGE_LENGTH;                                vos_mem_copy((tANI_U8 *) ((tpSirMacAuthFrameBody) plainBody)->challengeText,                                              pRxAuthFrameBody->challengeText,                                              SIR_MAC_AUTH_CHALLENGE_LENGTH);                                limEncryptAuthFrame(pMac, keyId,                                                    defaultKey,                                                    plainBody,                                                    encrAuthFrame,key_length);                                psessionEntry->limMlmState =                                eLIM_MLM_WT_AUTH_FRAME4_STATE;                                MTRACE(macTrace(pMac, TRACE_CODE_MLM_STATE, psessionEntry->peSessionId, psessionEntry->limMlmState));                                limSendAuthMgmtFrame(pMac,                                                     (tpSirMacAuthFrameBody) encrAuthFrame,                                                     pHdr->sa,                                                     LIM_WEP_IN_FC,psessionEntry);                                break;                        } // end if (pKeyMapEntry)                    } // end if (!wlan_cfgGetInt(CFG_PRIVACY_OPTION_IMPLEMENTED))                } // end if (pRxAuthFrameBody->authAlgoNumber == eSIR_OPEN_SYSTEM)            } // if (pRxAuthFrameBody->authStatusCode == eSIR_MAC_SUCCESS_STATUS)            else            {                /**                 * Authentication failure.                 * Return Auth confirm with received failure code to SME                 */                // Log error                PELOGE(limLog(pMac, LOGE,                       FL("received Auth frame from peer with failure code %d "                       MAC_ADDRESS_STR), pRxAuthFrameBody->authStatusCode,                       MAC_ADDR_ARRAY(pHdr->sa));)                limRestoreFromAuthState(pMac, eSIR_SME_AUTH_REFUSED,                                              pRxAuthFrameBody->authStatusCode,psessionEntry);            } // end if (pRxAuthFrameBody->authStatusCode == eSIR_MAC_SUCCESS_STATUS)            break;        case SIR_MAC_AUTH_FRAME_3:            // AuthFrame 3            if (pRxAuthFrameBody->authAlgoNumber != eSIR_SHARED_KEY)            {                // Log error                PELOGE(limLog(pMac, LOGE,                       FL("received Auth frame3 from peer with auth algo number %d "                       MAC_ADDRESS_STR), pRxAuthFrameBody->authAlgoNumber,                       MAC_ADDR_ARRAY(pHdr->sa));)                /**                 * Received Authentication frame3 with algorithm other than                 * Shared Key authentication type. Reject with Auth frame4                 * with 'out of sequence' status code.                 */                authFrame.authAlgoNumber = eSIR_SHARED_KEY;                authFrame.authTransactionSeqNumber =                SIR_MAC_AUTH_FRAME_4;                authFrame.authStatusCode =                eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                limSendAuthMgmtFrame(pMac, &authFrame,                                     pHdr->sa,                                     LIM_NO_WEP_IN_FC,psessionEntry);                return;            }            if (LIM_IS_AP_ROLE(psessionEntry) ||                LIM_IS_BT_AMP_AP_ROLE(psessionEntry) ||                LIM_IS_IBSS_ROLE(psessionEntry)) {                /**                 * Check if wep bit was set in FC. If not set,                 * reject with Authentication frame4 with                 * 'challenge failure' status code.                 */                if (!pHdr->fc.wep)                {                    // Log error                    PELOGE(limLog(pMac, LOGE,                           FL("received Auth frame3 from peer with no WEP bit set "MAC_ADDRESS_STR),                           MAC_ADDR_ARRAY(pHdr->sa));)                    /// WEP bit is not set in FC of Auth Frame3                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }                pAuthNode = limSearchPreAuthList(pMac,                                                pHdr->sa);                if (pAuthNode == NULL)                {                    // Log error                    PELOGE(limLog(pMac, LOGW,                           FL("received AuthFrame3 from peer that has no preauth context "                           MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                   /**                     * No 'pre-auth' context exists for                     * this STA that sent an Authentication                     * frame3.                     * Send Auth frame4 with 'out of sequence'                     * status code.                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }                if (pAuthNode->mlmState == eLIM_MLM_AUTH_RSP_TIMEOUT_STATE)                {                    // Log error                    limLog(pMac, LOGW,                           FL("auth response timer timedout for peer "                           MAC_ADDRESS_STR),MAC_ADDR_ARRAY(pHdr->sa));                    /**                     * Received Auth Frame3 after Auth Response timeout.                     * Reject by sending Auth Frame4 with                     * Auth respone timeout Status Code.                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_AUTH_RSP_TIMEOUT_STATUS;                    limSendAuthMgmtFrame(                                        pMac, &authFrame,                                        pHdr->sa,                                        LIM_NO_WEP_IN_FC,psessionEntry);                    /// Delete pre-auth context of STA                    limDeletePreAuthNode(pMac,                                         pHdr->sa);                    return;                } // end switch (pAuthNode->mlmState)                if (pRxAuthFrameBody->authStatusCode != eSIR_MAC_SUCCESS_STATUS)                {                    /**                     * Received Authenetication Frame 3 with status code                     * other than success. Wait until Auth response timeout                     * to delete STA context.                     */                    // Log error                    PELOGE(limLog(pMac, LOGE,                           FL("received Auth frame3 from peer with status code %d "                           MAC_ADDRESS_STR), pRxAuthFrameBody->authStatusCode,                           MAC_ADDR_ARRAY(pHdr->sa));)                    return;                }                /**                 * Check if received challenge text is same as one sent in                 * Authentication frame3                 */                if (vos_mem_compare(pRxAuthFrameBody->challengeText,                                    pAuthNode->challengeText,                                    SIR_MAC_AUTH_CHALLENGE_LENGTH))                {                    /// Challenge match. STA is autheticated !                    /// Delete Authentication response timer if running                    limDeactivateAndChangePerStaIdTimer(pMac,                                                        eLIM_AUTH_RSP_TIMER,                                                        pAuthNode->authNodeIdx);                    pAuthNode->fTimerStarted = 0;                    pAuthNode->mlmState = eLIM_MLM_AUTHENTICATED_STATE;                    /**                     * Send Authentication Frame4 with 'success' Status Code.                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode = eSIR_MAC_SUCCESS_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    /// Send Auth indication to SME                    vos_mem_copy((tANI_U8 *) mlmAuthInd.peerMacAddr,                                 (tANI_U8 *) pHdr->sa,                                  sizeof(tSirMacAddr));                    mlmAuthInd.authType = (tAniAuthType)                                          pRxAuthFrameBody->authAlgoNumber;                    mlmAuthInd.sessionId = psessionEntry->smeSessionId;                    limPostSmeMessage(pMac,                                      LIM_MLM_AUTH_IND,                                      (tANI_U32 *) &mlmAuthInd);                    break;                }                else                {                     // Log error                    PELOGE( limLog(pMac, LOGW,                                   FL("Challenge failure for peer "MAC_ADDRESS_STR),                                   MAC_ADDR_ARRAY(pHdr->sa));)                   /**                     * Challenge Failure.                     * Send Authentication frame4 with 'challenge failure'                     * status code and wait until Auth response timeout to                     * delete STA context.                     */                    authFrame.authAlgoNumber =                        pRxAuthFrameBody->authAlgoNumber;                    authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }            } // if (pMac->lim.gLimSystemRole == eLIM_AP_ROLE || ...            break;        case SIR_MAC_AUTH_FRAME_4:            // AuthFrame 4            if (psessionEntry->limMlmState != eLIM_MLM_WT_AUTH_FRAME4_STATE)            {                /**                 * Received Authentication frame4 in an unexpected state.                 * Log error and ignore the frame.                 */                // Log error                PELOG1(limLog(pMac, LOG1,                       FL("received unexpected Auth frame4 from peer in state %d, addr "                       MAC_ADDRESS_STR), psessionEntry->limMlmState,                       MAC_ADDR_ARRAY(pHdr->sa));)                return;            }            if (pRxAuthFrameBody->authAlgoNumber != eSIR_SHARED_KEY)            {                /**                 * Received Authentication frame4 with algorithm other than                 * Shared Key authentication type.                 * Wait until Auth failure timeout to report authentication                 * failure to SME.                 */                // Log error                PELOGE(limLog(pMac, LOGE,                       FL("received Auth frame4 from peer with invalid auth algo %d "                           MAC_ADDRESS_STR), pRxAuthFrameBody->authAlgoNumber,                       MAC_ADDR_ARRAY(pHdr->sa));)                return;            }            if ( !vos_mem_compare((tANI_U8 *) pHdr->sa,                                  (tANI_U8 *) &pMac->lim.gpLimMlmAuthReq->peerMacAddr,                                  sizeof(tSirMacAddr)) )            {                /**                 * Received Authentication frame from an entity                 * other than one to which request was initiated.                 * Wait until Authentication Failure Timeout.                 */                // Log error                PELOGE(limLog(pMac, LOGW,                       FL("received Auth frame4 from unexpected peer "                       MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                break;            }            if (pRxAuthFrameBody->authAlgoNumber !=                pMac->lim.gpLimMlmAuthReq->authType)            {                /**                 * Received Authentication frame with an auth algorithm                 * other than one requested.                 * Wait until Authentication Failure Timeout.                 */                PELOGE(limLog(pMac, LOGE,                       FL("received Authentication frame from peer with invalid auth seq number %d "                       MAC_ADDRESS_STR), pRxAuthFrameBody->authTransactionSeqNumber,                       MAC_ADDR_ARRAY(pHdr->sa));)                break;            }            if (pRxAuthFrameBody->authStatusCode ==                eSIR_MAC_SUCCESS_STATUS)            {                /**                 * Authentication Success !                 * Inform SME of same.                 */                psessionEntry->limCurrentAuthType = eSIR_SHARED_KEY;                pAuthNode = limAcquireFreePreAuthNode(pMac, &pMac->lim.gLimPreAuthTimerTable);                if (pAuthNode == NULL)                {                    // Log error                    limLog(pMac, LOGW,                           FL("Max pre-auth nodes reached "));                    limPrintMacAddr(pMac, pHdr->sa, LOGW);                    return;                }                PELOG1(limLog(pMac, LOG1, FL("Alloc new data: %x peer "), pAuthNode);                limPrintMacAddr(pMac, pHdr->sa, LOG1);)                vos_mem_copy((tANI_U8 *) pAuthNode->peerMacAddr,                             pMac->lim.gpLimMlmAuthReq->peerMacAddr,                             sizeof(tSirMacAddr));                pAuthNode->fTimerStarted = 0;                pAuthNode->authType = pMac->lim.gpLimMlmAuthReq->authType;                pAuthNode->seqNum = ((pHdr->seqControl.seqNumHi << 4) |                                (pHdr->seqControl.seqNumLo));                limAddPreAuthNode(pMac, pAuthNode);                limRestoreFromAuthState(pMac, eSIR_SME_SUCCESS,                                              pRxAuthFrameBody->authStatusCode,psessionEntry);            } // if (pRxAuthFrameBody->authStatusCode == eSIR_MAC_SUCCESS_STATUS)            else            {                /**                 * Authentication failure.                 * Return Auth confirm with received failure code to SME                 */                // Log error                PELOGE(limLog(pMac, LOGE, FL("Authentication failure from peer "                       MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                limRestoreFromAuthState(pMac, eSIR_SME_AUTH_REFUSED,                                              pRxAuthFrameBody->authStatusCode,psessionEntry);            } // end if (pRxAuthFrameBody->Status == 0)            break;        default:            /// Invalid Authentication Frame received. Ignore it.            // Log error            PELOGE(limLog(pMac, LOGE,                   FL("received Auth frame from peer with invalid auth seq "                   "number %d " MAC_ADDRESS_STR),                   pRxAuthFrameBody->authTransactionSeqNumber,                   MAC_ADDR_ARRAY(pHdr->sa));)            break;    } // end switch (pRxAuthFrameBody->authTransactionSeqNumber)}
void
limProcessAuthFrame(tpAniSirGlobal pMac, tANI_U8 *pRxPacketInfo, tpPESession psessionEntry)
limProcessAuthFrame
tpAniSirGlobal pMac
tpAniSirGlobal
tpAniSirGlobal
pMac
pMac
tANI_U8 *pRxPacketInfo
tANI_U8
tANI_U8
*pRxPacketInfo
*
pRxPacketInfo
tpPESession psessionEntry
tpPESession
tpPESession
psessionEntry
psessionEntry
{    tANI_U8                 *pBody, keyId, cfgPrivacyOptImp,                            defaultKey[SIR_MAC_KEY_LENGTH],                            encrAuthFrame[LIM_ENCR_AUTH_BODY_LEN],                            plainBody[256];    tANI_U16                frameLen;    tANI_U32                maxNumPreAuth, val;    tSirMacAuthFrameBody    *pRxAuthFrameBody, rxAuthFrame, authFrame;    tpSirMacMgmtHdr         pHdr;    tCfgWepKeyEntry         *pKeyMapEntry = NULL;    struct tLimPreAuthNode  *pAuthNode;    tLimMlmAuthInd          mlmAuthInd;    tANI_U8                 decryptResult;    tANI_U8                 *pChallenge;    tANI_U32                key_length=8;    tANI_U8                 challengeTextArray[SIR_MAC_AUTH_CHALLENGE_LENGTH];    tpDphHashNode           pStaDs = NULL;    tANI_U16                assocId = 0;    tANI_U16                currSeqNum = 0;    // Get pointer to Authentication frame header and body    pHdr = WDA_GET_RX_MAC_HEADER(pRxPacketInfo);    frameLen = WDA_GET_RX_PAYLOAD_LEN(pRxPacketInfo);    if (!frameLen)    {        // Log error        limLog(pMac, LOGE,               FL("received Authentication frame with no body from "));        limPrintMacAddr(pMac, pHdr->sa, LOGE);        return;    }    if (limIsGroupAddr(pHdr->sa))    {        // Received Auth frame from a BC/MC address        // Log error and ignore it        PELOGE(limLog(pMac, LOGE,               FL("received Auth frame from a BC/MC address - "));)        PELOGE( limPrintMacAddr(pMac, pHdr->sa, LOGE);)        return;    }    currSeqNum = (pHdr->seqControl.seqNumHi << 4) |                    (pHdr->seqControl.seqNumLo);    limLog(pMac, LOG1,               FL("Sessionid: %d System role : %d limMlmState: %d :Auth "               "Frame Received: BSSID: "MAC_ADDRESS_STR " (RSSI %d)"),               psessionEntry->peSessionId, GET_LIM_SYSTEM_ROLE(psessionEntry),               psessionEntry->limMlmState, MAC_ADDR_ARRAY(pHdr->bssId),              (uint)abs((tANI_S8)WDA_GET_RX_RSSI_NORMALIZED(pRxPacketInfo)));    pBody = WDA_GET_RX_MPDU_DATA(pRxPacketInfo);    //Restore default failure timeout    if (VOS_P2P_CLIENT_MODE == psessionEntry->pePersona && psessionEntry->defaultAuthFailureTimeout)    {        limLog(pMac, LOG1, FL("Restore default failure timeout"));        ccmCfgSetInt(pMac,WNI_CFG_AUTHENTICATE_FAILURE_TIMEOUT ,                          psessionEntry->defaultAuthFailureTimeout, NULL, eANI_BOOLEAN_FALSE);    }    /// Determine if WEP bit is set in the FC or received MAC header    if (pHdr->fc.wep)    {        /**         * WEP bit is set in FC of MAC header.         */        // If TKIP counter measures enabled issue Deauth frame to station        if ((psessionEntry->bTkipCntrMeasActive) &&             LIM_IS_AP_ROLE(psessionEntry)) {            PELOGE( limLog(pMac, LOGE,               FL("Tkip counter measures Enabled, sending Deauth frame to")); )            limPrintMacAddr(pMac, pHdr->sa, LOGE);            limSendDeauthMgmtFrame( pMac, eSIR_MAC_MIC_FAILURE_REASON,                                    pHdr->sa, psessionEntry, FALSE );            return;        }        // Extract key ID from IV (most 2 bits of 4th byte of IV)        keyId = (*(pBody + 3)) >> 6;        /**         * On STA in infrastructure BSS, Authentication frames received         * with WEP bit set in the FC must be rejected with challenge         * failure status code (wierd thing in the spec - this should have         * been rejected with unspecified failure or unexpected assertion         * of wep bit (this status code does not exist though) or         * Out-of-sequence-Authentication-Frame status code.         */        if (LIM_IS_STA_ROLE(psessionEntry) ||            LIM_IS_BT_AMP_STA_ROLE(psessionEntry)) {            authFrame.authAlgoNumber = eSIR_SHARED_KEY;            authFrame.authTransactionSeqNumber = SIR_MAC_AUTH_FRAME_4;            authFrame.authStatusCode = eSIR_MAC_CHALLENGE_FAILURE_STATUS;            // Log error            PELOGE(limLog(pMac, LOGE,                   FL("received Authentication frame with wep bit set on role=%d"                   MAC_ADDRESS_STR), GET_LIM_SYSTEM_ROLE(psessionEntry),                   MAC_ADDR_ARRAY(pHdr->sa));)            limSendAuthMgmtFrame(pMac, &authFrame,                                 pHdr->sa,                                 LIM_NO_WEP_IN_FC,psessionEntry);            return;        }        if (frameLen < LIM_ENCR_AUTH_BODY_LEN)        {            // Log error            limLog(pMac, LOGE,                   FL("Not enough size [%d] to decrypt received Auth frame"),                   frameLen);            limPrintMacAddr(pMac, pHdr->sa, LOGE);            return;        }        if (LIM_IS_AP_ROLE(psessionEntry)) {            val = psessionEntry->privacy;        }        else        // Accept Authentication frame only if Privacy is implemented        if (wlan_cfgGetInt(pMac, WNI_CFG_PRIVACY_ENABLED,                      &val) != eSIR_SUCCESS)        {            /**             * Could not get Privacy option             * from CFG. Log error.             */            limLog(pMac, LOGP, FL("could not retrieve Privacy option"));        }        cfgPrivacyOptImp = (tANI_U8)val;        if (cfgPrivacyOptImp)        {            /**             * Privacy option is implemented.             * Check if the received frame is Authentication             * frame3 and there is a context for requesting STA.             * If not, reject with unspecified failure status code             */            pAuthNode = limSearchPreAuthList(pMac, pHdr->sa);            if (pAuthNode == NULL)            {                // Log error                PELOGE(limLog(pMac, LOGE,                       FL("received Authentication frame from peer that has no preauth context with WEP bit set "                           MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                /**                 * No 'pre-auth' context exists for this STA that sent                 * an Authentication frame with FC bit set.                 * Send Auth frame4 with 'out of sequence' status code.                 */                authFrame.authAlgoNumber = eSIR_SHARED_KEY;                authFrame.authTransactionSeqNumber =                SIR_MAC_AUTH_FRAME_4;                authFrame.authStatusCode =                eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                limSendAuthMgmtFrame(pMac, &authFrame,                                     pHdr->sa,                                     LIM_NO_WEP_IN_FC,psessionEntry);                return;            }            else            {                /// Change the auth-response timeout                limDeactivateAndChangePerStaIdTimer(pMac,                                                    eLIM_AUTH_RSP_TIMER,                                                    pAuthNode->authNodeIdx);                /// 'Pre-auth' status exists for STA                if ((pAuthNode->mlmState !=                     eLIM_MLM_WT_AUTH_FRAME3_STATE) &&                    (pAuthNode->mlmState !=                     eLIM_MLM_AUTH_RSP_TIMEOUT_STATE))                {                   // Log error                   PELOGE(limLog(pMac, LOGE,                          FL("received Authentication frame from peer that is in state %d "                          MAC_ADDRESS_STR),                          pAuthNode->mlmState, MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * Should not have received Authentication frame                     * with WEP bit set in FC in other states.                     * Reject by sending Authenticaton frame with                     * out of sequence Auth frame status code.                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }            }            /**             * Check if there exists a key mappping key             * for the STA that sent Authentication frame             */            pKeyMapEntry = limLookUpKeyMappings(pHdr->sa);            if (pKeyMapEntry)            {                if (!pKeyMapEntry->wepOn)                {                   // Log error                   PELOGE(limLog(pMac, LOGE,                          FL("received Auth frame3 from peer that has NULL key map entry "                          MAC_ADDRESS_STR),MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * Key Mapping entry has null key.                     * Send Authentication frame                     * with challenge failure status code                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                } // if (!pKeyMapEntry->wepOn)                else                {                    decryptResult = limDecryptAuthFrame(pMac, pKeyMapEntry->key,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH));                    if (decryptResult == LIM_DECRYPT_ICV_FAIL)                    {                        // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer that failed decryption, Addr "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                        limDeletePreAuthNode(pMac,                                             pHdr->sa);                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;                        authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                        authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }                    if ((sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                         &rxAuthFrame)!=eSIR_SUCCESS ) ||                        ( !isAuthValid(pMac, &rxAuthFrame,psessionEntry)))                    {                        PELOGE(limLog(pMac, LOGE, FL(                               "failed to convert Auth Frame to structure or Auth is not valid "));)                        return;                    }                } // end if (pKeyMapEntry->key == NULL)            } // if keyMappings has entry            else            {                val = SIR_MAC_KEY_LENGTH;                if (LIM_IS_AP_ROLE(psessionEntry)) {                    tpSirKeys pKey;                    pKey =  &psessionEntry->WEPKeyMaterial[keyId].key[0];                    vos_mem_copy(defaultKey, pKey->key, pKey->keyLength);                    val = pKey->keyLength;                } else if (wlan_cfgGetStr(pMac,                             (tANI_U16) (WNI_CFG_WEP_DEFAULT_KEY_1 + keyId),                              defaultKey, &val) != eSIR_SUCCESS) {                    /// Could not get Default key from CFG.                    //Log error.                    limLog(pMac, LOGP,                           FL("could not retrieve Default key"));                    /**                     * Send Authentication frame                     * with challenge failure status code                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }                    key_length=val;                    decryptResult = limDecryptAuthFrame(pMac, defaultKey,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH));                    if (decryptResult == LIM_DECRYPT_ICV_FAIL)                    {                         // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer that failed decryption: "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                       /// ICV failure                        limDeletePreAuthNode(pMac,                                             pHdr->sa);                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;                        authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                        authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }                    if ( ( sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                          &rxAuthFrame)!=eSIR_SUCCESS ) ||                        ( !isAuthValid(pMac, &rxAuthFrame, psessionEntry) ) )                    {                        limLog(pMac, LOGE,                               FL("failed to convert Auth Frame to structure or Auth is not valid "));                        return;                    }            } // End of check for Key Mapping/Default key presence        }        else        {            // Log error            PELOGE(limLog(pMac, LOGE,                   FL("received Authentication frame3 from peer that while privacy option is turned OFF "                   MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)            /**             * Privacy option is not implemented.             * So reject Authentication frame received with             * WEP bit set by sending Authentication frame             * with 'challenge failure' status code. This is             * another strange thing in the spec. Status code             * should have been 'unsupported algorithm' status code.             */            authFrame.authAlgoNumber = eSIR_SHARED_KEY;            authFrame.authTransactionSeqNumber =            SIR_MAC_AUTH_FRAME_4;            authFrame.authStatusCode =            eSIR_MAC_CHALLENGE_FAILURE_STATUS;            limSendAuthMgmtFrame(pMac, &authFrame,                                 pHdr->sa,                                 LIM_NO_WEP_IN_FC,psessionEntry);            return;        } // else if (wlan_cfgGetInt(CFG_PRIVACY_OPTION_IMPLEMENTED))    } // if (fc.wep)    else    {        if ( ( sirConvertAuthFrame2Struct(pMac, pBody,            frameLen, &rxAuthFrame)!=eSIR_SUCCESS ) ||            ( !isAuthValid(pMac, &rxAuthFrame,psessionEntry) ) )        {            PELOGE(limLog(pMac, LOGE,                   FL("failed to convert Auth Frame to structure or Auth is not valid "));)            return;        }    }    pRxAuthFrameBody = &rxAuthFrame;   PELOGW(limLog(pMac, LOGW,           FL("Received Auth frame with type=%d seqnum=%d, status=%d (%d)"),           (tANI_U32) pRxAuthFrameBody->authAlgoNumber,           (tANI_U32) pRxAuthFrameBody->authTransactionSeqNumber,           (tANI_U32) pRxAuthFrameBody->authStatusCode,(tANI_U32)pMac->lim.gLimNumPreAuthContexts);)    switch (pRxAuthFrameBody->authTransactionSeqNumber)    {        case SIR_MAC_AUTH_FRAME_1:            // AuthFrame 1            pStaDs = dphLookupHashEntry(pMac, pHdr->sa,                    &assocId, &psessionEntry->dph.dphHashTable);            if (pStaDs)            {                tLimMlmDisassocReq      *pMlmDisassocReq = NULL;                tLimMlmDeauthReq        *pMlmDeauthReq = NULL;                tAniBool                 isConnected = eSIR_TRUE;                pMlmDisassocReq = pMac->lim.limDisassocDeauthCnfReq.pMlmDisassocReq;                if (pMlmDisassocReq &&                        (vos_mem_compare((tANI_U8 *) pHdr->sa,                                         (tANI_U8 *) &pMlmDisassocReq->peerMacAddr,                                          sizeof(tSirMacAddr))))                {                    PELOGE(limLog(pMac, LOGE, FL("TODO:Ack for disassoc "                                "frame is pending Issue delsta for "                                MAC_ADDRESS_STR),                                MAC_ADDR_ARRAY(pMlmDisassocReq->peerMacAddr));)                    limProcessDisassocAckTimeout(pMac);                    isConnected = eSIR_FALSE;                }                pMlmDeauthReq = pMac->lim.limDisassocDeauthCnfReq.pMlmDeauthReq;                if (pMlmDeauthReq &&                        (vos_mem_compare((tANI_U8 *) pHdr->sa,                                         (tANI_U8 *) &pMlmDeauthReq->peerMacAddr,                                         sizeof(tSirMacAddr))))                {                    PELOGE(limLog(pMac, LOGE, FL("TODO:Ack for deauth frame "                                "is pending Issue delsta for "                                MAC_ADDRESS_STR),                                MAC_ADDR_ARRAY(pMlmDeauthReq->peerMacAddr));)                    limProcessDeauthAckTimeout(pMac);                    isConnected = eSIR_FALSE;                }                /* pStaDS != NULL and isConnected = 1 means the STA is already                 * connected, But SAP received the Auth from that station.                 * For non PMF connection send Deauth frame as STA will retry                 * to connect back.                 *                 * For PMF connection the AP should not tear down or otherwise                 * modify the state of the existing association until the                 * SA-Query procedure determines that the original SA is                 * invalid.                 */                if (isConnected#ifdef WLAN_FEATURE_11W                    && !pStaDs->rmfEnabled#endif                                          )                {                    limLog(pMac, LOGE,                            FL("STA is already connected but received auth frame"                                "Send the Deauth and lim Delete Station Context"                                "(staId: %d, assocId: %d) "),                            pStaDs->staIndex, assocId);                    limSendDeauthMgmtFrame(pMac, eSIR_MAC_UNSPEC_FAILURE_REASON,                            (tANI_U8 *) pHdr->sa, psessionEntry, FALSE);                    limTriggerSTAdeletion(pMac, pStaDs, psessionEntry);                    return;                }            }            /// Check if there exists pre-auth context for this STA            pAuthNode = limSearchPreAuthList(pMac, pHdr->sa);            if (pAuthNode)            {                /// Pre-auth context exists for the STA                if (pHdr->fc.retry == 0 || pAuthNode->seqNum != currSeqNum)                {                    /**                     * STA is initiating brand-new Authentication                     * sequence after local Auth Response timeout.                     * Or STA retrying to transmit First Auth frame due to packet drop OTA                     * Delete Pre-auth node and fall through.                     */                    if(pAuthNode->fTimerStarted)                    {                        limDeactivateAndChangePerStaIdTimer(pMac,                                                    eLIM_AUTH_RSP_TIMER,                                                    pAuthNode->authNodeIdx);                    }                    PELOGE(limLog(pMac, LOGE, FL("STA is initiating brand-new Authentication ..."));)                    limDeletePreAuthNode(pMac,                                         pHdr->sa);                    /**                     *  SAP Mode:Disassociate the station and                     *  delete its entry if we have its entry                     *  already and received "auth" from the                     *  same station.                     */                    for (assocId = 0; assocId < psessionEntry->dph.dphHashTable.size; assocId++)// Softap dphHashTable.size = 8                    {                        pStaDs = dphGetHashEntry(pMac, assocId, &psessionEntry->dph.dphHashTable);                        if (NULL == pStaDs)                             continue;                        if (pStaDs->valid)                        {                             if (vos_mem_compare((tANI_U8 *) &pStaDs->staAddr,                                      (tANI_U8 *) &(pHdr->sa), (tANI_U8) (sizeof(tSirMacAddr))) )                                  break;                        }                        pStaDs = NULL;                    }                    if (NULL != pStaDs#ifdef WLAN_FEATURE_11W                        && !pStaDs->rmfEnabled#endif                       )                    {                        PELOGE(limLog(pMac, LOGE,                               FL("lim Delete Station Context (staId: %d, assocId: %d) "),                               pStaDs->staIndex, assocId);)                        limSendDeauthMgmtFrame(pMac,                               eSIR_MAC_UNSPEC_FAILURE_REASON, (tANI_U8 *) pAuthNode->peerMacAddr, psessionEntry, FALSE);                        limTriggerSTAdeletion(pMac, pStaDs, psessionEntry);                        return;                    }                }                else                {                    /*                     * This can happen when first authentication frame is received                     * but ACK lost at STA side, in this case 2nd auth frame is already                     * in transmission queue                     * */                    PELOGE(limLog(pMac, LOGE, FL("STA is initiating Authentication after ACK lost..."));)                    return;                }            }            if (wlan_cfgGetInt(pMac, WNI_CFG_MAX_NUM_PRE_AUTH,                          (tANI_U32 *) &maxNumPreAuth) != eSIR_SUCCESS)            {                /**                 * Could not get MaxNumPreAuth                 * from CFG. Log error.                 */                limLog(pMac, LOGP,                       FL("could not retrieve MaxNumPreAuth"));            }            if (pMac->lim.gLimNumPreAuthContexts == maxNumPreAuth)            {                PELOGE(limLog(pMac, LOGE, FL("Max number of preauth context reached"));)                /**                 * Maximum number of pre-auth contexts                 * reached. Send Authentication frame                 * with unspecified failure                 */                authFrame.authAlgoNumber =                pRxAuthFrameBody->authAlgoNumber;                authFrame.authTransactionSeqNumber =                pRxAuthFrameBody->authTransactionSeqNumber + 1;                authFrame.authStatusCode =                eSIR_MAC_UNSPEC_FAILURE_STATUS;                limSendAuthMgmtFrame(pMac, &authFrame,                                     pHdr->sa,                                     LIM_NO_WEP_IN_FC,psessionEntry);                return;            }            /// No Pre-auth context exists for the STA.            if (limIsAuthAlgoSupported(                                      pMac,                                      (tAniAuthType)                                      pRxAuthFrameBody->authAlgoNumber, psessionEntry))            {                switch (pRxAuthFrameBody->authAlgoNumber)                {                    case eSIR_OPEN_SYSTEM:                        PELOGW(limLog(pMac, LOGW, FL("=======> eSIR_OPEN_SYSTEM  ..."));)                        /// Create entry for this STA in pre-auth list                        pAuthNode = limAcquireFreePreAuthNode(pMac, &pMac->lim.gLimPreAuthTimerTable);                        if (pAuthNode == NULL)                        {                            // Log error                            limLog(pMac, LOGW,                                   FL("Max pre-auth nodes reached "));                            limPrintMacAddr(pMac, pHdr->sa, LOGW);                            return;                        }                        PELOG1(limLog(pMac, LOG1, FL("Alloc new data: %x peer "), pAuthNode);                        limPrintMacAddr(pMac, pHdr->sa, LOG1);)                        vos_mem_copy((tANI_U8 *) pAuthNode->peerMacAddr,                                      pHdr->sa,                                      sizeof(tSirMacAddr));                        pAuthNode->mlmState =                        eLIM_MLM_AUTHENTICATED_STATE;                        pAuthNode->authType = (tAniAuthType)                                              pRxAuthFrameBody->authAlgoNumber;                        pAuthNode->fSeen = 0;                        pAuthNode->fTimerStarted = 0;                        pAuthNode->seqNum = ((pHdr->seqControl.seqNumHi << 4) |                                                (pHdr->seqControl.seqNumLo));                        limAddPreAuthNode(pMac, pAuthNode);                        /**                         * Send Authenticaton frame with Success                         * status code.                         */                        authFrame.authAlgoNumber =                        pRxAuthFrameBody->authAlgoNumber;                        authFrame.authTransactionSeqNumber =                        pRxAuthFrameBody->authTransactionSeqNumber + 1;                        authFrame.authStatusCode = eSIR_MAC_SUCCESS_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        /// Send Auth indication to SME                        vos_mem_copy((tANI_U8 *) mlmAuthInd.peerMacAddr,                                     (tANI_U8 *) pHdr->sa,                                     sizeof(tSirMacAddr));                        mlmAuthInd.authType = (tAniAuthType)                                              pRxAuthFrameBody->authAlgoNumber;                        mlmAuthInd.sessionId = psessionEntry->smeSessionId;                        limPostSmeMessage(pMac,                                          LIM_MLM_AUTH_IND,                                          (tANI_U32 *) &mlmAuthInd);                        break;                    case eSIR_SHARED_KEY:                        PELOGW(limLog(pMac, LOGW, FL("=======> eSIR_SHARED_KEY  ..."));)                        if (LIM_IS_AP_ROLE(psessionEntry)) {                            val = psessionEntry->privacy;                        } else if (wlan_cfgGetInt(pMac, WNI_CFG_PRIVACY_ENABLED,                                      &val) != eSIR_SUCCESS) {                            /**                             * Could not get Privacy option                             * from CFG. Log error.                             */                            limLog(pMac, LOGP,                                   FL("could not retrieve Privacy option"));                        }                        cfgPrivacyOptImp = (tANI_U8)val;                        if (!cfgPrivacyOptImp)                        {                            // Log error                            PELOGE(limLog(pMac, LOGE,                                   FL("received Auth frame for unsupported auth algorithm %d "                                   MAC_ADDRESS_STR), pRxAuthFrameBody->authAlgoNumber,                                   MAC_ADDR_ARRAY(pHdr->sa));)                            /**                             * Authenticator does not have WEP                             * implemented.                             * Reject by sending Authentication frame                             * with Auth algorithm not supported status                             * code.                             */                            authFrame.authAlgoNumber =                            pRxAuthFrameBody->authAlgoNumber;                            authFrame.authTransactionSeqNumber =                            pRxAuthFrameBody->authTransactionSeqNumber + 1;                            authFrame.authStatusCode =                            eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS;                            limSendAuthMgmtFrame(                                                pMac, &authFrame,                                                pHdr->sa,                                                LIM_NO_WEP_IN_FC,psessionEntry);                            return;                        }                        else                        {                            // Create entry for this STA                            //in pre-auth list                            pAuthNode = limAcquireFreePreAuthNode(pMac, &pMac->lim.gLimPreAuthTimerTable);                            if (pAuthNode == NULL)                            {                                // Log error                                limLog(pMac, LOGW,                                       FL("Max pre-auth nodes reached "));                                limPrintMacAddr(pMac, pHdr->sa, LOGW);                                return;                            }                            vos_mem_copy((tANI_U8 *) pAuthNode->peerMacAddr,                                          pHdr->sa,                                          sizeof(tSirMacAddr));                            pAuthNode->mlmState =                            eLIM_MLM_WT_AUTH_FRAME3_STATE;                            pAuthNode->authType =                            (tAniAuthType)                            pRxAuthFrameBody->authAlgoNumber;                            pAuthNode->fSeen = 0;                            pAuthNode->fTimerStarted = 0;                            pAuthNode->seqNum =                                    ((pHdr->seqControl.seqNumHi << 4) |                                     (pHdr->seqControl.seqNumLo));                            limAddPreAuthNode(pMac, pAuthNode);                            PELOG1(limLog(pMac, LOG1, FL("Alloc new data: %x id %d peer "),                                          pAuthNode, pAuthNode->authNodeIdx);)                            PELOG1(limPrintMacAddr(pMac, pHdr->sa, LOG1);)                            /// Create and activate Auth Response timer                            if (tx_timer_change_context(&pAuthNode->timer, pAuthNode->authNodeIdx) != TX_SUCCESS)                            {                                /// Could not start Auth response timer.                                // Log error                                limLog(pMac, LOGP,                                   FL("Unable to chg context auth response timer for peer "));                                limPrintMacAddr(pMac, pHdr->sa, LOGP);                                /**                                 * Send Authenticaton frame with                                 * unspecified failure status code.                                 */                                authFrame.authAlgoNumber =                                        pRxAuthFrameBody->authAlgoNumber;                                authFrame.authTransactionSeqNumber =                                        pRxAuthFrameBody->authTransactionSeqNumber + 1;                                authFrame.authStatusCode =                                        eSIR_MAC_UNSPEC_FAILURE_STATUS;                                limSendAuthMgmtFrame(pMac, &authFrame,                                                     pHdr->sa,                                                     LIM_NO_WEP_IN_FC,psessionEntry);                                limDeletePreAuthNode(pMac, pHdr->sa);                                return;                            }                            limActivateAuthRspTimer(pMac, pAuthNode);                            pAuthNode->fTimerStarted = 1;                            // get random bytes and use as                            // challenge text. If it fails we already have random stack bytes.                            if( !VOS_IS_STATUS_SUCCESS( vos_rand_get_bytes( 0, (tANI_U8 *)challengeTextArray, SIR_MAC_AUTH_CHALLENGE_LENGTH ) ) )                            {                               limLog(pMac, LOGE,FL("Challenge text preparation failed in limProcessAuthFrame"));                            }                            pChallenge = pAuthNode->challengeText;                            vos_mem_copy(pChallenge,                                        (tANI_U8 *) challengeTextArray,                                         sizeof(challengeTextArray));                            /**                             * Sending Authenticaton frame with challenge.                             */                            authFrame.authAlgoNumber =                            pRxAuthFrameBody->authAlgoNumber;                            authFrame.authTransactionSeqNumber =                            pRxAuthFrameBody->authTransactionSeqNumber + 1;                            authFrame.authStatusCode =                            eSIR_MAC_SUCCESS_STATUS;                            authFrame.type   = SIR_MAC_CHALLENGE_TEXT_EID;                            authFrame.length = SIR_MAC_AUTH_CHALLENGE_LENGTH;                            vos_mem_copy(authFrame.challengeText,                                         pAuthNode->challengeText,                                         SIR_MAC_AUTH_CHALLENGE_LENGTH);                            limSendAuthMgmtFrame(                                                pMac, &authFrame,                                                pHdr->sa,                                                LIM_NO_WEP_IN_FC,psessionEntry);                        } // if (wlan_cfgGetInt(CFG_PRIVACY_OPTION_IMPLEMENTED))                        break;                    default:                        // Log error                       PELOGE( limLog(pMac, LOGE,                               FL("received Auth frame for unsupported auth algorithm %d "                               MAC_ADDRESS_STR), pRxAuthFrameBody->authAlgoNumber,                               MAC_ADDR_ARRAY(pHdr->sa));)                        /**                         * Responding party does not support the                         * authentication algorithm requested by                         * sending party.                         * Reject by sending Authentication frame                         * with auth algorithm not supported status code                         */                        authFrame.authAlgoNumber =                        pRxAuthFrameBody->authAlgoNumber;                        authFrame.authTransactionSeqNumber =                        pRxAuthFrameBody->authTransactionSeqNumber + 1;                        authFrame.authStatusCode =                        eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                } // end switch(pRxAuthFrameBody->authAlgoNumber)            } // if (limIsAuthAlgoSupported(pRxAuthFrameBody->authAlgoNumber))            else            {                // Log error                PELOGE(limLog(pMac, LOGE,                       FL("received Authentication frame for unsupported auth algorithm %d "                       MAC_ADDRESS_STR), pRxAuthFrameBody->authAlgoNumber,                       MAC_ADDR_ARRAY(pHdr->sa));)                /**                 * Responding party does not support the                 * authentication algorithm requested by sending party.                 * Reject Authentication with StatusCode=13.                 */                authFrame.authAlgoNumber =                pRxAuthFrameBody->authAlgoNumber;                authFrame.authTransactionSeqNumber =                pRxAuthFrameBody->authTransactionSeqNumber + 1;                authFrame.authStatusCode =                eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS;                limSendAuthMgmtFrame(pMac, &authFrame,                                     pHdr->sa,                                     LIM_NO_WEP_IN_FC,psessionEntry);                return;            } //end if (limIsAuthAlgoSupported(pRxAuthFrameBody->authAlgoNumber))            break;        case SIR_MAC_AUTH_FRAME_2:            // AuthFrame 2            if (psessionEntry->limMlmState != eLIM_MLM_WT_AUTH_FRAME2_STATE)            {#ifdef WLAN_FEATURE_VOWIFI_11R                /**                 * Check if a Reassociation is in progress and this is a                 * Pre-Auth frame                 */                if ((LIM_IS_STA_ROLE(psessionEntry) ||                     LIM_IS_BT_AMP_STA_ROLE(psessionEntry)) &&                    (psessionEntry->limSmeState == eLIM_SME_WT_REASSOC_STATE) &&                    (pRxAuthFrameBody->authStatusCode == eSIR_MAC_SUCCESS_STATUS) &&                    (psessionEntry->ftPEContext.pFTPreAuthReq != NULL) &&                    (vos_mem_compare(                        psessionEntry->ftPEContext.pFTPreAuthReq->preAuthbssId,                        pHdr->sa, sizeof(tSirMacAddr))))                {                    // Update the FTIEs in the saved auth response                    PELOGW(limLog(pMac, LOGW, FL("received another PreAuth frame2"                           " from peer " MAC_ADDRESS_STR" in Smestate %d"),                           MAC_ADDR_ARRAY(pHdr->sa), psessionEntry->limSmeState);)                    psessionEntry->ftPEContext.saved_auth_rsp_length = 0;                    if ((pBody != NULL) && (frameLen < MAX_FTIE_SIZE))                    {                        vos_mem_copy(psessionEntry->ftPEContext.saved_auth_rsp,                                     pBody, frameLen);                        psessionEntry->ftPEContext.saved_auth_rsp_length = frameLen;                    }                }                else#endif                {                    /**                     * Received Authentication frame2 in an unexpected state.                     * Log error and ignore the frame.                     */                    // Log error                    PELOG1(limLog(pMac, LOG1,                           FL("received Auth frame2 from peer in state %d, addr "),                           psessionEntry->limMlmState);)                    PELOG1(limPrintMacAddr(pMac, pHdr->sa, LOG1);)                }                return;            }            if ( !vos_mem_compare((tANI_U8 *) pHdr->sa,                                  (tANI_U8 *) &pMac->lim.gpLimMlmAuthReq->peerMacAddr,                                  sizeof(tSirMacAddr)) )            {                /**                 * Received Authentication frame from an entity                 * other than one request was initiated.                 * Wait until Authentication Failure Timeout.                 */                // Log error                PELOGW(limLog(pMac, LOGW,                       FL("received Auth frame2 from unexpected peer "                       MAC_ADDRESS_STR),                       MAC_ADDR_ARRAY(pHdr->sa));)                break;            }            if (pRxAuthFrameBody->authStatusCode ==                eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS)            {                /**                 * Interoperability workaround: Linksys WAP4400N is returning                 * wrong authType in OpenAuth response in case of                 * SharedKey AP configuration. Pretend we don't see that,                 * so upper layer can fallback to SharedKey authType,                 * and successfully connect to the AP.                 */                if (pRxAuthFrameBody->authAlgoNumber !=                    pMac->lim.gpLimMlmAuthReq->authType)                {                    pRxAuthFrameBody->authAlgoNumber =                    pMac->lim.gpLimMlmAuthReq->authType;                }            }            if (pRxAuthFrameBody->authAlgoNumber !=                pMac->lim.gpLimMlmAuthReq->authType)            {                /**                 * Received Authentication frame with an auth                 * algorithm other than one requested.                 * Wait until Authentication Failure Timeout.                 */                // Log error                PELOGW(limLog(pMac, LOGW,                       FL("received Auth frame2 for unexpected auth algo number %d "                       MAC_ADDRESS_STR), pRxAuthFrameBody->authAlgoNumber,                       MAC_ADDR_ARRAY(pHdr->sa));)                break;            }            if (pRxAuthFrameBody->authStatusCode ==                eSIR_MAC_SUCCESS_STATUS)            {                if (pRxAuthFrameBody->authAlgoNumber ==                    eSIR_OPEN_SYSTEM)                {                    psessionEntry->limCurrentAuthType = eSIR_OPEN_SYSTEM;                    pAuthNode = limAcquireFreePreAuthNode(pMac, &pMac->lim.gLimPreAuthTimerTable);                    if (pAuthNode == NULL)                    {                        // Log error                        limLog(pMac, LOGW,                               FL("Max pre-auth nodes reached "));                        limPrintMacAddr(pMac, pHdr->sa, LOGW);                        return;                    }                    PELOG1(limLog(pMac, LOG1, FL("Alloc new data: %x peer "), pAuthNode);)                    PELOG1(limPrintMacAddr(pMac, pHdr->sa, LOG1);)                    vos_mem_copy((tANI_U8 *) pAuthNode->peerMacAddr,                                 pMac->lim.gpLimMlmAuthReq->peerMacAddr,                                 sizeof(tSirMacAddr));                    pAuthNode->fTimerStarted = 0;                    pAuthNode->seqNum = ((pHdr->seqControl.seqNumHi << 4) |                                    (pHdr->seqControl.seqNumLo));                    pAuthNode->authType = pMac->lim.gpLimMlmAuthReq->authType;                    limAddPreAuthNode(pMac, pAuthNode);                    limRestoreFromAuthState(pMac, eSIR_SME_SUCCESS,                                            pRxAuthFrameBody->authStatusCode,psessionEntry);                } // if (pRxAuthFrameBody->authAlgoNumber == eSIR_OPEN_SYSTEM)                else                {                    // Shared key authentication                    if (LIM_IS_AP_ROLE(psessionEntry)) {                        val = psessionEntry->privacy;                    } else if (wlan_cfgGetInt(pMac, WNI_CFG_PRIVACY_ENABLED,                                  &val) != eSIR_SUCCESS) {                        /**                         * Could not get Privacy option                         * from CFG. Log error.                         */                        limLog(pMac, LOGP,                               FL("could not retrieve Privacy option"));                    }                    cfgPrivacyOptImp = (tANI_U8)val;                    if (!cfgPrivacyOptImp)                    {                        /**                         * Requesting STA does not have WEP implemented.                         * Reject with unsupported authentication algorithm                         * Status code and wait until auth failure timeout                         */                        // Log error                       PELOGE( limLog(pMac, LOGE,                               FL("received Auth frame from peer for unsupported auth algo %d "                               MAC_ADDRESS_STR), pRxAuthFrameBody->authAlgoNumber,                               MAC_ADDR_ARRAY(pHdr->sa));)                        authFrame.authAlgoNumber =                        pRxAuthFrameBody->authAlgoNumber;                        authFrame.authTransactionSeqNumber =                        pRxAuthFrameBody->authTransactionSeqNumber + 1;                        authFrame.authStatusCode =                        eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS;                        limSendAuthMgmtFrame(pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }                    else                    {                        if (pRxAuthFrameBody->type !=                            SIR_MAC_CHALLENGE_TEXT_EID)                        {                            // Log error                            PELOGE(limLog(pMac, LOGE,                                   FL("received Auth frame with invalid challenge text IE"));)                            return;                        }                        /**                         * Check if there exists a key mappping key                         * for the STA that sent Authentication frame                         */                        pKeyMapEntry = limLookUpKeyMappings(                                                           pHdr->sa);                        if (pKeyMapEntry)                        {                            if (pKeyMapEntry->key == NULL)                            {                                // Log error                                PELOGE(limLog(pMac, LOGE,                                       FL("received Auth frame from peer when key mapping key is NULL"                                       MAC_ADDRESS_STR),MAC_ADDR_ARRAY(pHdr->sa));)                                /**                                 * Key Mapping entry has null key.                                 * Send Auth frame with                                 * challenge failure status code                                 */                                authFrame.authAlgoNumber =                                pRxAuthFrameBody->authAlgoNumber;                                authFrame.authTransactionSeqNumber =                                pRxAuthFrameBody->authTransactionSeqNumber + 1;                                authFrame.authStatusCode =                                eSIR_MAC_CHALLENGE_FAILURE_STATUS;                                limSendAuthMgmtFrame(pMac, &authFrame,                                                     pHdr->sa,                                                     LIM_NO_WEP_IN_FC,psessionEntry);                                limRestoreFromAuthState(pMac, eSIR_SME_NO_KEY_MAPPING_KEY_FOR_PEER,                                                              eSIR_MAC_UNSPEC_FAILURE_REASON,psessionEntry);                                return;                            } // if (pKeyMapEntry->key == NULL)                            else                            {                                ((tpSirMacAuthFrameBody) plainBody)->authAlgoNumber =                                sirSwapU16ifNeeded(pRxAuthFrameBody->authAlgoNumber);                                ((tpSirMacAuthFrameBody) plainBody)->authTransactionSeqNumber =                                sirSwapU16ifNeeded((tANI_U16) (pRxAuthFrameBody->authTransactionSeqNumber + 1));                                ((tpSirMacAuthFrameBody) plainBody)->authStatusCode = eSIR_MAC_SUCCESS_STATUS;                                ((tpSirMacAuthFrameBody) plainBody)->type   = SIR_MAC_CHALLENGE_TEXT_EID;                                ((tpSirMacAuthFrameBody) plainBody)->length = SIR_MAC_AUTH_CHALLENGE_LENGTH;                                vos_mem_copy((tANI_U8 *) ((tpSirMacAuthFrameBody) plainBody)->challengeText,                                              pRxAuthFrameBody->challengeText,                                              SIR_MAC_AUTH_CHALLENGE_LENGTH);                                limEncryptAuthFrame(pMac, 0,                                                    pKeyMapEntry->key,                                                    plainBody,                                                    encrAuthFrame,key_length);                                psessionEntry->limMlmState = eLIM_MLM_WT_AUTH_FRAME4_STATE;                                MTRACE(macTrace(pMac, TRACE_CODE_MLM_STATE, psessionEntry->peSessionId, psessionEntry->limMlmState));                                limSendAuthMgmtFrame(pMac,                                                     (tpSirMacAuthFrameBody) encrAuthFrame,                                                     pHdr->sa,                                                     LIM_WEP_IN_FC,psessionEntry);                                break;                            } // end if (pKeyMapEntry->key == NULL)                        } // if (pKeyMapEntry)                        else                        {                            if (wlan_cfgGetInt(pMac, WNI_CFG_WEP_DEFAULT_KEYID,                                          &val) != eSIR_SUCCESS)                            {                                /**                                 * Could not get Default keyId                                 * from CFG. Log error.                                 */                                limLog(pMac, LOGP,                                       FL("could not retrieve Default keyId"));                            }                            keyId = (tANI_U8)val;                            val = SIR_MAC_KEY_LENGTH;                            if (LIM_IS_AP_ROLE(psessionEntry)) {                                tpSirKeys pKey;                                pKey =  &psessionEntry->WEPKeyMaterial[keyId].key[0];                                vos_mem_copy(defaultKey, pKey->key, pKey->keyLength);                            } else if (wlan_cfgGetStr(pMac,                                      (tANI_U16) (WNI_CFG_WEP_DEFAULT_KEY_1 + keyId),                                       defaultKey, &val) != eSIR_SUCCESS) {                                /// Could not get Default key from CFG.                                //Log error.                                limLog(pMac, LOGP,                                       FL("could not retrieve Default key"));                                authFrame.authAlgoNumber =                                pRxAuthFrameBody->authAlgoNumber;                                authFrame.authTransactionSeqNumber =                                pRxAuthFrameBody->authTransactionSeqNumber + 1;                                authFrame.authStatusCode =                                eSIR_MAC_CHALLENGE_FAILURE_STATUS;                                limSendAuthMgmtFrame(                                                    pMac, &authFrame,                                                    pHdr->sa,                                                    LIM_NO_WEP_IN_FC,psessionEntry);                                limRestoreFromAuthState(pMac, eSIR_SME_INVALID_WEP_DEFAULT_KEY,                                                              eSIR_MAC_UNSPEC_FAILURE_REASON,psessionEntry);                                break;                            }                                key_length=val;                                ((tpSirMacAuthFrameBody) plainBody)->authAlgoNumber =                                sirSwapU16ifNeeded(pRxAuthFrameBody->authAlgoNumber);                                ((tpSirMacAuthFrameBody) plainBody)->authTransactionSeqNumber =                                sirSwapU16ifNeeded((tANI_U16) (pRxAuthFrameBody->authTransactionSeqNumber + 1));                                ((tpSirMacAuthFrameBody) plainBody)->authStatusCode = eSIR_MAC_SUCCESS_STATUS;                                ((tpSirMacAuthFrameBody) plainBody)->type   = SIR_MAC_CHALLENGE_TEXT_EID;                                ((tpSirMacAuthFrameBody) plainBody)->length = SIR_MAC_AUTH_CHALLENGE_LENGTH;                                vos_mem_copy((tANI_U8 *) ((tpSirMacAuthFrameBody) plainBody)->challengeText,                                              pRxAuthFrameBody->challengeText,                                              SIR_MAC_AUTH_CHALLENGE_LENGTH);                                limEncryptAuthFrame(pMac, keyId,                                                    defaultKey,                                                    plainBody,                                                    encrAuthFrame,key_length);                                psessionEntry->limMlmState =                                eLIM_MLM_WT_AUTH_FRAME4_STATE;                                MTRACE(macTrace(pMac, TRACE_CODE_MLM_STATE, psessionEntry->peSessionId, psessionEntry->limMlmState));                                limSendAuthMgmtFrame(pMac,                                                     (tpSirMacAuthFrameBody) encrAuthFrame,                                                     pHdr->sa,                                                     LIM_WEP_IN_FC,psessionEntry);                                break;                        } // end if (pKeyMapEntry)                    } // end if (!wlan_cfgGetInt(CFG_PRIVACY_OPTION_IMPLEMENTED))                } // end if (pRxAuthFrameBody->authAlgoNumber == eSIR_OPEN_SYSTEM)            } // if (pRxAuthFrameBody->authStatusCode == eSIR_MAC_SUCCESS_STATUS)            else            {                /**                 * Authentication failure.                 * Return Auth confirm with received failure code to SME                 */                // Log error                PELOGE(limLog(pMac, LOGE,                       FL("received Auth frame from peer with failure code %d "                       MAC_ADDRESS_STR), pRxAuthFrameBody->authStatusCode,                       MAC_ADDR_ARRAY(pHdr->sa));)                limRestoreFromAuthState(pMac, eSIR_SME_AUTH_REFUSED,                                              pRxAuthFrameBody->authStatusCode,psessionEntry);            } // end if (pRxAuthFrameBody->authStatusCode == eSIR_MAC_SUCCESS_STATUS)            break;        case SIR_MAC_AUTH_FRAME_3:            // AuthFrame 3            if (pRxAuthFrameBody->authAlgoNumber != eSIR_SHARED_KEY)            {                // Log error                PELOGE(limLog(pMac, LOGE,                       FL("received Auth frame3 from peer with auth algo number %d "                       MAC_ADDRESS_STR), pRxAuthFrameBody->authAlgoNumber,                       MAC_ADDR_ARRAY(pHdr->sa));)                /**                 * Received Authentication frame3 with algorithm other than                 * Shared Key authentication type. Reject with Auth frame4                 * with 'out of sequence' status code.                 */                authFrame.authAlgoNumber = eSIR_SHARED_KEY;                authFrame.authTransactionSeqNumber =                SIR_MAC_AUTH_FRAME_4;                authFrame.authStatusCode =                eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                limSendAuthMgmtFrame(pMac, &authFrame,                                     pHdr->sa,                                     LIM_NO_WEP_IN_FC,psessionEntry);                return;            }            if (LIM_IS_AP_ROLE(psessionEntry) ||                LIM_IS_BT_AMP_AP_ROLE(psessionEntry) ||                LIM_IS_IBSS_ROLE(psessionEntry)) {                /**                 * Check if wep bit was set in FC. If not set,                 * reject with Authentication frame4 with                 * 'challenge failure' status code.                 */                if (!pHdr->fc.wep)                {                    // Log error                    PELOGE(limLog(pMac, LOGE,                           FL("received Auth frame3 from peer with no WEP bit set "MAC_ADDRESS_STR),                           MAC_ADDR_ARRAY(pHdr->sa));)                    /// WEP bit is not set in FC of Auth Frame3                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }                pAuthNode = limSearchPreAuthList(pMac,                                                pHdr->sa);                if (pAuthNode == NULL)                {                    // Log error                    PELOGE(limLog(pMac, LOGW,                           FL("received AuthFrame3 from peer that has no preauth context "                           MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                   /**                     * No 'pre-auth' context exists for                     * this STA that sent an Authentication                     * frame3.                     * Send Auth frame4 with 'out of sequence'                     * status code.                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }                if (pAuthNode->mlmState == eLIM_MLM_AUTH_RSP_TIMEOUT_STATE)                {                    // Log error                    limLog(pMac, LOGW,                           FL("auth response timer timedout for peer "                           MAC_ADDRESS_STR),MAC_ADDR_ARRAY(pHdr->sa));                    /**                     * Received Auth Frame3 after Auth Response timeout.                     * Reject by sending Auth Frame4 with                     * Auth respone timeout Status Code.                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_AUTH_RSP_TIMEOUT_STATUS;                    limSendAuthMgmtFrame(                                        pMac, &authFrame,                                        pHdr->sa,                                        LIM_NO_WEP_IN_FC,psessionEntry);                    /// Delete pre-auth context of STA                    limDeletePreAuthNode(pMac,                                         pHdr->sa);                    return;                } // end switch (pAuthNode->mlmState)                if (pRxAuthFrameBody->authStatusCode != eSIR_MAC_SUCCESS_STATUS)                {                    /**                     * Received Authenetication Frame 3 with status code                     * other than success. Wait until Auth response timeout                     * to delete STA context.                     */                    // Log error                    PELOGE(limLog(pMac, LOGE,                           FL("received Auth frame3 from peer with status code %d "                           MAC_ADDRESS_STR), pRxAuthFrameBody->authStatusCode,                           MAC_ADDR_ARRAY(pHdr->sa));)                    return;                }                /**                 * Check if received challenge text is same as one sent in                 * Authentication frame3                 */                if (vos_mem_compare(pRxAuthFrameBody->challengeText,                                    pAuthNode->challengeText,                                    SIR_MAC_AUTH_CHALLENGE_LENGTH))                {                    /// Challenge match. STA is autheticated !                    /// Delete Authentication response timer if running                    limDeactivateAndChangePerStaIdTimer(pMac,                                                        eLIM_AUTH_RSP_TIMER,                                                        pAuthNode->authNodeIdx);                    pAuthNode->fTimerStarted = 0;                    pAuthNode->mlmState = eLIM_MLM_AUTHENTICATED_STATE;                    /**                     * Send Authentication Frame4 with 'success' Status Code.                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode = eSIR_MAC_SUCCESS_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    /// Send Auth indication to SME                    vos_mem_copy((tANI_U8 *) mlmAuthInd.peerMacAddr,                                 (tANI_U8 *) pHdr->sa,                                  sizeof(tSirMacAddr));                    mlmAuthInd.authType = (tAniAuthType)                                          pRxAuthFrameBody->authAlgoNumber;                    mlmAuthInd.sessionId = psessionEntry->smeSessionId;                    limPostSmeMessage(pMac,                                      LIM_MLM_AUTH_IND,                                      (tANI_U32 *) &mlmAuthInd);                    break;                }                else                {                     // Log error                    PELOGE( limLog(pMac, LOGW,                                   FL("Challenge failure for peer "MAC_ADDRESS_STR),                                   MAC_ADDR_ARRAY(pHdr->sa));)                   /**                     * Challenge Failure.                     * Send Authentication frame4 with 'challenge failure'                     * status code and wait until Auth response timeout to                     * delete STA context.                     */                    authFrame.authAlgoNumber =                        pRxAuthFrameBody->authAlgoNumber;                    authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }            } // if (pMac->lim.gLimSystemRole == eLIM_AP_ROLE || ...            break;        case SIR_MAC_AUTH_FRAME_4:            // AuthFrame 4            if (psessionEntry->limMlmState != eLIM_MLM_WT_AUTH_FRAME4_STATE)            {                /**                 * Received Authentication frame4 in an unexpected state.                 * Log error and ignore the frame.                 */                // Log error                PELOG1(limLog(pMac, LOG1,                       FL("received unexpected Auth frame4 from peer in state %d, addr "                       MAC_ADDRESS_STR), psessionEntry->limMlmState,                       MAC_ADDR_ARRAY(pHdr->sa));)                return;            }            if (pRxAuthFrameBody->authAlgoNumber != eSIR_SHARED_KEY)            {                /**                 * Received Authentication frame4 with algorithm other than                 * Shared Key authentication type.                 * Wait until Auth failure timeout to report authentication                 * failure to SME.                 */                // Log error                PELOGE(limLog(pMac, LOGE,                       FL("received Auth frame4 from peer with invalid auth algo %d "                           MAC_ADDRESS_STR), pRxAuthFrameBody->authAlgoNumber,                       MAC_ADDR_ARRAY(pHdr->sa));)                return;            }            if ( !vos_mem_compare((tANI_U8 *) pHdr->sa,                                  (tANI_U8 *) &pMac->lim.gpLimMlmAuthReq->peerMacAddr,                                  sizeof(tSirMacAddr)) )            {                /**                 * Received Authentication frame from an entity                 * other than one to which request was initiated.                 * Wait until Authentication Failure Timeout.                 */                // Log error                PELOGE(limLog(pMac, LOGW,                       FL("received Auth frame4 from unexpected peer "                       MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                break;            }            if (pRxAuthFrameBody->authAlgoNumber !=                pMac->lim.gpLimMlmAuthReq->authType)            {                /**                 * Received Authentication frame with an auth algorithm                 * other than one requested.                 * Wait until Authentication Failure Timeout.                 */                PELOGE(limLog(pMac, LOGE,                       FL("received Authentication frame from peer with invalid auth seq number %d "                       MAC_ADDRESS_STR), pRxAuthFrameBody->authTransactionSeqNumber,                       MAC_ADDR_ARRAY(pHdr->sa));)                break;            }            if (pRxAuthFrameBody->authStatusCode ==                eSIR_MAC_SUCCESS_STATUS)            {                /**                 * Authentication Success !                 * Inform SME of same.                 */                psessionEntry->limCurrentAuthType = eSIR_SHARED_KEY;                pAuthNode = limAcquireFreePreAuthNode(pMac, &pMac->lim.gLimPreAuthTimerTable);                if (pAuthNode == NULL)                {                    // Log error                    limLog(pMac, LOGW,                           FL("Max pre-auth nodes reached "));                    limPrintMacAddr(pMac, pHdr->sa, LOGW);                    return;                }                PELOG1(limLog(pMac, LOG1, FL("Alloc new data: %x peer "), pAuthNode);                limPrintMacAddr(pMac, pHdr->sa, LOG1);)                vos_mem_copy((tANI_U8 *) pAuthNode->peerMacAddr,                             pMac->lim.gpLimMlmAuthReq->peerMacAddr,                             sizeof(tSirMacAddr));                pAuthNode->fTimerStarted = 0;                pAuthNode->authType = pMac->lim.gpLimMlmAuthReq->authType;                pAuthNode->seqNum = ((pHdr->seqControl.seqNumHi << 4) |                                (pHdr->seqControl.seqNumLo));                limAddPreAuthNode(pMac, pAuthNode);                limRestoreFromAuthState(pMac, eSIR_SME_SUCCESS,                                              pRxAuthFrameBody->authStatusCode,psessionEntry);            } // if (pRxAuthFrameBody->authStatusCode == eSIR_MAC_SUCCESS_STATUS)            else            {                /**                 * Authentication failure.                 * Return Auth confirm with received failure code to SME                 */                // Log error                PELOGE(limLog(pMac, LOGE, FL("Authentication failure from peer "                       MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                limRestoreFromAuthState(pMac, eSIR_SME_AUTH_REFUSED,                                              pRxAuthFrameBody->authStatusCode,psessionEntry);            } // end if (pRxAuthFrameBody->Status == 0)            break;        default:            /// Invalid Authentication Frame received. Ignore it.            // Log error            PELOGE(limLog(pMac, LOGE,                   FL("received Auth frame from peer with invalid auth seq "                   "number %d " MAC_ADDRESS_STR),                   pRxAuthFrameBody->authTransactionSeqNumber,                   MAC_ADDR_ARRAY(pHdr->sa));)            break;    } // end switch (pRxAuthFrameBody->authTransactionSeqNumber)}
tANI_U8                 *pBody, keyId, cfgPrivacyOptImp,                            defaultKey[SIR_MAC_KEY_LENGTH],                            encrAuthFrame[LIM_ENCR_AUTH_BODY_LEN],                            plainBody[256];
tANI_U8                 *pBody, keyId, cfgPrivacyOptImp,                            defaultKey[SIR_MAC_KEY_LENGTH],                            encrAuthFrame[LIM_ENCR_AUTH_BODY_LEN],                            plainBody[256];
tANI_U8
tANI_U8
*pBody
*
pBody
keyId
keyId
cfgPrivacyOptImp
cfgPrivacyOptImp
defaultKey[SIR_MAC_KEY_LENGTH]
defaultKey
[SIR_MAC_KEY_LENGTH]
SIR_MAC_KEY_LENGTH
SIR_MAC_KEY_LENGTH
encrAuthFrame[LIM_ENCR_AUTH_BODY_LEN]
encrAuthFrame
[LIM_ENCR_AUTH_BODY_LEN]
LIM_ENCR_AUTH_BODY_LEN
LIM_ENCR_AUTH_BODY_LEN
plainBody[256]
plainBody
[256]
256
tANI_U16                frameLen;
tANI_U16                frameLen;
tANI_U16
tANI_U16
frameLen
frameLen
tANI_U32                maxNumPreAuth, val;
tANI_U32                maxNumPreAuth, val;
tANI_U32
tANI_U32
maxNumPreAuth
maxNumPreAuth
val
val
tSirMacAuthFrameBody    *pRxAuthFrameBody, rxAuthFrame, authFrame;
tSirMacAuthFrameBody    *pRxAuthFrameBody, rxAuthFrame, authFrame;
tSirMacAuthFrameBody
tSirMacAuthFrameBody
*pRxAuthFrameBody
*
pRxAuthFrameBody
rxAuthFrame
rxAuthFrame
authFrame
authFrame
tpSirMacMgmtHdr         pHdr;
tpSirMacMgmtHdr         pHdr;
tpSirMacMgmtHdr
tpSirMacMgmtHdr
pHdr
pHdr
tCfgWepKeyEntry         *pKeyMapEntry = NULL;
tCfgWepKeyEntry         *pKeyMapEntry = NULL;
tCfgWepKeyEntry
tCfgWepKeyEntry
*pKeyMapEntry = NULL
*
pKeyMapEntry
= NULL
NULL
NULL
struct tLimPreAuthNode  *pAuthNode;
struct tLimPreAuthNode  *pAuthNode;
struct tLimPreAuthNode
tLimPreAuthNode
*pAuthNode
*
pAuthNode
tLimMlmAuthInd          mlmAuthInd;
tLimMlmAuthInd          mlmAuthInd;
tLimMlmAuthInd
tLimMlmAuthInd
mlmAuthInd
mlmAuthInd
tANI_U8                 decryptResult;
tANI_U8                 decryptResult;
tANI_U8
tANI_U8
decryptResult
decryptResult
tANI_U8                 *pChallenge;
tANI_U8                 *pChallenge;
tANI_U8
tANI_U8
*pChallenge
*
pChallenge
tANI_U32                key_length=8;
tANI_U32                key_length=8;
tANI_U32
tANI_U32
key_length=8
key_length
=8
8
tANI_U8                 challengeTextArray[SIR_MAC_AUTH_CHALLENGE_LENGTH];
tANI_U8                 challengeTextArray[SIR_MAC_AUTH_CHALLENGE_LENGTH];
tANI_U8
tANI_U8
challengeTextArray[SIR_MAC_AUTH_CHALLENGE_LENGTH]
challengeTextArray
[SIR_MAC_AUTH_CHALLENGE_LENGTH]
SIR_MAC_AUTH_CHALLENGE_LENGTH
SIR_MAC_AUTH_CHALLENGE_LENGTH
tpDphHashNode           pStaDs = NULL;
tpDphHashNode           pStaDs = NULL;
tpDphHashNode
tpDphHashNode
pStaDs = NULL
pStaDs
= NULL
NULL
NULL
tANI_U16                assocId = 0;
tANI_U16                assocId = 0;
tANI_U16
tANI_U16
assocId = 0
assocId
= 0
0
tANI_U16                currSeqNum = 0;
tANI_U16                currSeqNum = 0;
tANI_U16
tANI_U16
currSeqNum = 0
currSeqNum
= 0
0
pHdr = WDA_GET_RX_MAC_HEADER(pRxPacketInfo);
pHdr = WDA_GET_RX_MAC_HEADER(pRxPacketInfo)
pHdr
pHdr
WDA_GET_RX_MAC_HEADER(pRxPacketInfo)
WDA_GET_RX_MAC_HEADER
WDA_GET_RX_MAC_HEADER
pRxPacketInfo
pRxPacketInfo
frameLen = WDA_GET_RX_PAYLOAD_LEN(pRxPacketInfo);
frameLen = WDA_GET_RX_PAYLOAD_LEN(pRxPacketInfo)
frameLen
frameLen
WDA_GET_RX_PAYLOAD_LEN(pRxPacketInfo)
WDA_GET_RX_PAYLOAD_LEN
WDA_GET_RX_PAYLOAD_LEN
pRxPacketInfo
pRxPacketInfo
if (!frameLen)    {        // Log error        limLog(pMac, LOGE,               FL("received Authentication frame with no body from "));        limPrintMacAddr(pMac, pHdr->sa, LOGE);        return;    }
!frameLen
frameLen
frameLen
{        // Log error        limLog(pMac, LOGE,               FL("received Authentication frame with no body from "));        limPrintMacAddr(pMac, pHdr->sa, LOGE);        return;    }
limLog(pMac, LOGE,               FL("received Authentication frame with no body from "));
limLog(pMac, LOGE,               FL("received Authentication frame with no body from "))
limLog
limLog
pMac
pMac
LOGE
LOGE
FL("received Authentication frame with no body from ")
FL
FL
"received Authentication frame with no body from "
limPrintMacAddr(pMac, pHdr->sa, LOGE);
limPrintMacAddr(pMac, pHdr->sa, LOGE)
limPrintMacAddr
limPrintMacAddr
pMac
pMac
pHdr->sa
pHdr
pHdr
sa
LOGE
LOGE
return;
if (limIsGroupAddr(pHdr->sa))    {        // Received Auth frame from a BC/MC address        // Log error and ignore it        PELOGE(limLog(pMac, LOGE,               FL("received Auth frame from a BC/MC address - "));)        PELOGE( limPrintMacAddr(pMac, pHdr->sa, LOGE);)        return;    }
limIsGroupAddr(pHdr->sa)
limIsGroupAddr
limIsGroupAddr
pHdr->sa
pHdr
pHdr
sa
{        // Received Auth frame from a BC/MC address        // Log error and ignore it        PELOGE(limLog(pMac, LOGE,               FL("received Auth frame from a BC/MC address - "));)        PELOGE( limPrintMacAddr(pMac, pHdr->sa, LOGE);)        return;    }
PELOGE(limLog(pMac, LOGE,               FL("received Auth frame from a BC/MC address - "));
)        PELOGE( limPrintMacAddr(pMac, pHdr->sa, LOGE);
)        return;
currSeqNum = (pHdr->seqControl.seqNumHi << 4) |                    (pHdr->seqControl.seqNumLo);
currSeqNum = (pHdr->seqControl.seqNumHi << 4) |                    (pHdr->seqControl.seqNumLo)
currSeqNum
currSeqNum
(pHdr->seqControl.seqNumHi << 4) |                    (pHdr->seqControl.seqNumLo)
(pHdr->seqControl.seqNumHi << 4)
pHdr->seqControl.seqNumHi << 4
pHdr->seqControl.seqNumHi
pHdr->seqControl
pHdr
pHdr
seqControl
seqNumHi
4
(pHdr->seqControl.seqNumLo)
pHdr->seqControl.seqNumLo
pHdr->seqControl
pHdr
pHdr
seqControl
seqNumLo
limLog(pMac, LOG1,               FL("Sessionid: %d System role : %d limMlmState: %d :Auth "               "Frame Received: BSSID: "MAC_ADDRESS_STR " (RSSI %d)"),               psessionEntry->peSessionId, GET_LIM_SYSTEM_ROLE(psessionEntry),               psessionEntry->limMlmState, MAC_ADDR_ARRAY(pHdr->bssId),              (uint)abs((tANI_S8)WDA_GET_RX_RSSI_NORMALIZED(pRxPacketInfo)));
pBody = WDA_GET_RX_MPDU_DATA(pRxPacketInfo);
pBody = WDA_GET_RX_MPDU_DATA(pRxPacketInfo)
pBody
pBody
WDA_GET_RX_MPDU_DATA(pRxPacketInfo)
WDA_GET_RX_MPDU_DATA
WDA_GET_RX_MPDU_DATA
pRxPacketInfo
pRxPacketInfo
if (VOS_P2P_CLIENT_MODE == psessionEntry->pePersona && psessionEntry->defaultAuthFailureTimeout)    {        limLog(pMac, LOG1, FL("Restore default failure timeout"));        ccmCfgSetInt(pMac,WNI_CFG_AUTHENTICATE_FAILURE_TIMEOUT ,                          psessionEntry->defaultAuthFailureTimeout, NULL, eANI_BOOLEAN_FALSE);    }
VOS_P2P_CLIENT_MODE == psessionEntry->pePersona && psessionEntry->defaultAuthFailureTimeout
VOS_P2P_CLIENT_MODE == psessionEntry->pePersona
VOS_P2P_CLIENT_MODE
VOS_P2P_CLIENT_MODE
psessionEntry->pePersona
psessionEntry
psessionEntry
pePersona
psessionEntry->defaultAuthFailureTimeout
psessionEntry
psessionEntry
defaultAuthFailureTimeout
{        limLog(pMac, LOG1, FL("Restore default failure timeout"));        ccmCfgSetInt(pMac,WNI_CFG_AUTHENTICATE_FAILURE_TIMEOUT ,                          psessionEntry->defaultAuthFailureTimeout, NULL, eANI_BOOLEAN_FALSE);    }
limLog(pMac, LOG1, FL("Restore default failure timeout"));
limLog(pMac, LOG1, FL("Restore default failure timeout"))
limLog
limLog
pMac
pMac
LOG1
LOG1
FL("Restore default failure timeout")
FL
FL
"Restore default failure timeout"
ccmCfgSetInt(pMac,WNI_CFG_AUTHENTICATE_FAILURE_TIMEOUT ,                          psessionEntry->defaultAuthFailureTimeout, NULL, eANI_BOOLEAN_FALSE);
ccmCfgSetInt(pMac,WNI_CFG_AUTHENTICATE_FAILURE_TIMEOUT ,                          psessionEntry->defaultAuthFailureTimeout, NULL, eANI_BOOLEAN_FALSE)
ccmCfgSetInt
ccmCfgSetInt
pMac
pMac
WNI_CFG_AUTHENTICATE_FAILURE_TIMEOUT
WNI_CFG_AUTHENTICATE_FAILURE_TIMEOUT
psessionEntry->defaultAuthFailureTimeout
psessionEntry
psessionEntry
defaultAuthFailureTimeout
NULL
NULL
eANI_BOOLEAN_FALSE
eANI_BOOLEAN_FALSE
if (pHdr->fc.wep)    {        /**         * WEP bit is set in FC of MAC header.         */        // If TKIP counter measures enabled issue Deauth frame to station        if ((psessionEntry->bTkipCntrMeasActive) &&             LIM_IS_AP_ROLE(psessionEntry)) {            PELOGE( limLog(pMac, LOGE,               FL("Tkip counter measures Enabled, sending Deauth frame to")); )            limPrintMacAddr(pMac, pHdr->sa, LOGE);            limSendDeauthMgmtFrame( pMac, eSIR_MAC_MIC_FAILURE_REASON,                                    pHdr->sa, psessionEntry, FALSE );            return;        }        // Extract key ID from IV (most 2 bits of 4th byte of IV)        keyId = (*(pBody + 3)) >> 6;        /**         * On STA in infrastructure BSS, Authentication frames received         * with WEP bit set in the FC must be rejected with challenge         * failure status code (wierd thing in the spec - this should have         * been rejected with unspecified failure or unexpected assertion         * of wep bit (this status code does not exist though) or         * Out-of-sequence-Authentication-Frame status code.         */        if (LIM_IS_STA_ROLE(psessionEntry) ||            LIM_IS_BT_AMP_STA_ROLE(psessionEntry)) {            authFrame.authAlgoNumber = eSIR_SHARED_KEY;            authFrame.authTransactionSeqNumber = SIR_MAC_AUTH_FRAME_4;            authFrame.authStatusCode = eSIR_MAC_CHALLENGE_FAILURE_STATUS;            // Log error            PELOGE(limLog(pMac, LOGE,                   FL("received Authentication frame with wep bit set on role=%d"                   MAC_ADDRESS_STR), GET_LIM_SYSTEM_ROLE(psessionEntry),                   MAC_ADDR_ARRAY(pHdr->sa));)            limSendAuthMgmtFrame(pMac, &authFrame,                                 pHdr->sa,                                 LIM_NO_WEP_IN_FC,psessionEntry);            return;        }        if (frameLen < LIM_ENCR_AUTH_BODY_LEN)        {            // Log error            limLog(pMac, LOGE,                   FL("Not enough size [%d] to decrypt received Auth frame"),                   frameLen);            limPrintMacAddr(pMac, pHdr->sa, LOGE);            return;        }        if (LIM_IS_AP_ROLE(psessionEntry)) {            val = psessionEntry->privacy;        }        else        // Accept Authentication frame only if Privacy is implemented        if (wlan_cfgGetInt(pMac, WNI_CFG_PRIVACY_ENABLED,                      &val) != eSIR_SUCCESS)        {            /**             * Could not get Privacy option             * from CFG. Log error.             */            limLog(pMac, LOGP, FL("could not retrieve Privacy option"));        }        cfgPrivacyOptImp = (tANI_U8)val;        if (cfgPrivacyOptImp)        {            /**             * Privacy option is implemented.             * Check if the received frame is Authentication             * frame3 and there is a context for requesting STA.             * If not, reject with unspecified failure status code             */            pAuthNode = limSearchPreAuthList(pMac, pHdr->sa);            if (pAuthNode == NULL)            {                // Log error                PELOGE(limLog(pMac, LOGE,                       FL("received Authentication frame from peer that has no preauth context with WEP bit set "                           MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                /**                 * No 'pre-auth' context exists for this STA that sent                 * an Authentication frame with FC bit set.                 * Send Auth frame4 with 'out of sequence' status code.                 */                authFrame.authAlgoNumber = eSIR_SHARED_KEY;                authFrame.authTransactionSeqNumber =                SIR_MAC_AUTH_FRAME_4;                authFrame.authStatusCode =                eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                limSendAuthMgmtFrame(pMac, &authFrame,                                     pHdr->sa,                                     LIM_NO_WEP_IN_FC,psessionEntry);                return;            }            else            {                /// Change the auth-response timeout                limDeactivateAndChangePerStaIdTimer(pMac,                                                    eLIM_AUTH_RSP_TIMER,                                                    pAuthNode->authNodeIdx);                /// 'Pre-auth' status exists for STA                if ((pAuthNode->mlmState !=                     eLIM_MLM_WT_AUTH_FRAME3_STATE) &&                    (pAuthNode->mlmState !=                     eLIM_MLM_AUTH_RSP_TIMEOUT_STATE))                {                   // Log error                   PELOGE(limLog(pMac, LOGE,                          FL("received Authentication frame from peer that is in state %d "                          MAC_ADDRESS_STR),                          pAuthNode->mlmState, MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * Should not have received Authentication frame                     * with WEP bit set in FC in other states.                     * Reject by sending Authenticaton frame with                     * out of sequence Auth frame status code.                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }            }            /**             * Check if there exists a key mappping key             * for the STA that sent Authentication frame             */            pKeyMapEntry = limLookUpKeyMappings(pHdr->sa);            if (pKeyMapEntry)            {                if (!pKeyMapEntry->wepOn)                {                   // Log error                   PELOGE(limLog(pMac, LOGE,                          FL("received Auth frame3 from peer that has NULL key map entry "                          MAC_ADDRESS_STR),MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * Key Mapping entry has null key.                     * Send Authentication frame                     * with challenge failure status code                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                } // if (!pKeyMapEntry->wepOn)                else                {                    decryptResult = limDecryptAuthFrame(pMac, pKeyMapEntry->key,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH));                    if (decryptResult == LIM_DECRYPT_ICV_FAIL)                    {                        // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer that failed decryption, Addr "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                        limDeletePreAuthNode(pMac,                                             pHdr->sa);                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;                        authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                        authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }                    if ((sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                         &rxAuthFrame)!=eSIR_SUCCESS ) ||                        ( !isAuthValid(pMac, &rxAuthFrame,psessionEntry)))                    {                        PELOGE(limLog(pMac, LOGE, FL(                               "failed to convert Auth Frame to structure or Auth is not valid "));)                        return;                    }                } // end if (pKeyMapEntry->key == NULL)            } // if keyMappings has entry            else            {                val = SIR_MAC_KEY_LENGTH;                if (LIM_IS_AP_ROLE(psessionEntry)) {                    tpSirKeys pKey;                    pKey =  &psessionEntry->WEPKeyMaterial[keyId].key[0];                    vos_mem_copy(defaultKey, pKey->key, pKey->keyLength);                    val = pKey->keyLength;                } else if (wlan_cfgGetStr(pMac,                             (tANI_U16) (WNI_CFG_WEP_DEFAULT_KEY_1 + keyId),                              defaultKey, &val) != eSIR_SUCCESS) {                    /// Could not get Default key from CFG.                    //Log error.                    limLog(pMac, LOGP,                           FL("could not retrieve Default key"));                    /**                     * Send Authentication frame                     * with challenge failure status code                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }                    key_length=val;                    decryptResult = limDecryptAuthFrame(pMac, defaultKey,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH));                    if (decryptResult == LIM_DECRYPT_ICV_FAIL)                    {                         // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer that failed decryption: "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                       /// ICV failure                        limDeletePreAuthNode(pMac,                                             pHdr->sa);                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;                        authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                        authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }                    if ( ( sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                          &rxAuthFrame)!=eSIR_SUCCESS ) ||                        ( !isAuthValid(pMac, &rxAuthFrame, psessionEntry) ) )                    {                        limLog(pMac, LOGE,                               FL("failed to convert Auth Frame to structure or Auth is not valid "));                        return;                    }            } // End of check for Key Mapping/Default key presence        }        else        {            // Log error            PELOGE(limLog(pMac, LOGE,                   FL("received Authentication frame3 from peer that while privacy option is turned OFF "                   MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)            /**             * Privacy option is not implemented.             * So reject Authentication frame received with             * WEP bit set by sending Authentication frame             * with 'challenge failure' status code. This is             * another strange thing in the spec. Status code             * should have been 'unsupported algorithm' status code.             */            authFrame.authAlgoNumber = eSIR_SHARED_KEY;            authFrame.authTransactionSeqNumber =            SIR_MAC_AUTH_FRAME_4;            authFrame.authStatusCode =            eSIR_MAC_CHALLENGE_FAILURE_STATUS;            limSendAuthMgmtFrame(pMac, &authFrame,                                 pHdr->sa,                                 LIM_NO_WEP_IN_FC,psessionEntry);            return;        } // else if (wlan_cfgGetInt(CFG_PRIVACY_OPTION_IMPLEMENTED))    } // if (fc.wep)    else    {        if ( ( sirConvertAuthFrame2Struct(pMac, pBody,            frameLen, &rxAuthFrame)!=eSIR_SUCCESS ) ||            ( !isAuthValid(pMac, &rxAuthFrame,psessionEntry) ) )        {            PELOGE(limLog(pMac, LOGE,                   FL("failed to convert Auth Frame to structure or Auth is not valid "));)            return;        }    }
pHdr->fc.wep
pHdr->fc
pHdr
pHdr
fc
wep
{        /**         * WEP bit is set in FC of MAC header.         */        // If TKIP counter measures enabled issue Deauth frame to station        if ((psessionEntry->bTkipCntrMeasActive) &&             LIM_IS_AP_ROLE(psessionEntry)) {            PELOGE( limLog(pMac, LOGE,               FL("Tkip counter measures Enabled, sending Deauth frame to")); )            limPrintMacAddr(pMac, pHdr->sa, LOGE);            limSendDeauthMgmtFrame( pMac, eSIR_MAC_MIC_FAILURE_REASON,                                    pHdr->sa, psessionEntry, FALSE );            return;        }        // Extract key ID from IV (most 2 bits of 4th byte of IV)        keyId = (*(pBody + 3)) >> 6;        /**         * On STA in infrastructure BSS, Authentication frames received         * with WEP bit set in the FC must be rejected with challenge         * failure status code (wierd thing in the spec - this should have         * been rejected with unspecified failure or unexpected assertion         * of wep bit (this status code does not exist though) or         * Out-of-sequence-Authentication-Frame status code.         */        if (LIM_IS_STA_ROLE(psessionEntry) ||            LIM_IS_BT_AMP_STA_ROLE(psessionEntry)) {            authFrame.authAlgoNumber = eSIR_SHARED_KEY;            authFrame.authTransactionSeqNumber = SIR_MAC_AUTH_FRAME_4;            authFrame.authStatusCode = eSIR_MAC_CHALLENGE_FAILURE_STATUS;            // Log error            PELOGE(limLog(pMac, LOGE,                   FL("received Authentication frame with wep bit set on role=%d"                   MAC_ADDRESS_STR), GET_LIM_SYSTEM_ROLE(psessionEntry),                   MAC_ADDR_ARRAY(pHdr->sa));)            limSendAuthMgmtFrame(pMac, &authFrame,                                 pHdr->sa,                                 LIM_NO_WEP_IN_FC,psessionEntry);            return;        }        if (frameLen < LIM_ENCR_AUTH_BODY_LEN)        {            // Log error            limLog(pMac, LOGE,                   FL("Not enough size [%d] to decrypt received Auth frame"),                   frameLen);            limPrintMacAddr(pMac, pHdr->sa, LOGE);            return;        }        if (LIM_IS_AP_ROLE(psessionEntry)) {            val = psessionEntry->privacy;        }        else        // Accept Authentication frame only if Privacy is implemented        if (wlan_cfgGetInt(pMac, WNI_CFG_PRIVACY_ENABLED,                      &val) != eSIR_SUCCESS)        {            /**             * Could not get Privacy option             * from CFG. Log error.             */            limLog(pMac, LOGP, FL("could not retrieve Privacy option"));        }        cfgPrivacyOptImp = (tANI_U8)val;        if (cfgPrivacyOptImp)        {            /**             * Privacy option is implemented.             * Check if the received frame is Authentication             * frame3 and there is a context for requesting STA.             * If not, reject with unspecified failure status code             */            pAuthNode = limSearchPreAuthList(pMac, pHdr->sa);            if (pAuthNode == NULL)            {                // Log error                PELOGE(limLog(pMac, LOGE,                       FL("received Authentication frame from peer that has no preauth context with WEP bit set "                           MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                /**                 * No 'pre-auth' context exists for this STA that sent                 * an Authentication frame with FC bit set.                 * Send Auth frame4 with 'out of sequence' status code.                 */                authFrame.authAlgoNumber = eSIR_SHARED_KEY;                authFrame.authTransactionSeqNumber =                SIR_MAC_AUTH_FRAME_4;                authFrame.authStatusCode =                eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                limSendAuthMgmtFrame(pMac, &authFrame,                                     pHdr->sa,                                     LIM_NO_WEP_IN_FC,psessionEntry);                return;            }            else            {                /// Change the auth-response timeout                limDeactivateAndChangePerStaIdTimer(pMac,                                                    eLIM_AUTH_RSP_TIMER,                                                    pAuthNode->authNodeIdx);                /// 'Pre-auth' status exists for STA                if ((pAuthNode->mlmState !=                     eLIM_MLM_WT_AUTH_FRAME3_STATE) &&                    (pAuthNode->mlmState !=                     eLIM_MLM_AUTH_RSP_TIMEOUT_STATE))                {                   // Log error                   PELOGE(limLog(pMac, LOGE,                          FL("received Authentication frame from peer that is in state %d "                          MAC_ADDRESS_STR),                          pAuthNode->mlmState, MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * Should not have received Authentication frame                     * with WEP bit set in FC in other states.                     * Reject by sending Authenticaton frame with                     * out of sequence Auth frame status code.                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }            }            /**             * Check if there exists a key mappping key             * for the STA that sent Authentication frame             */            pKeyMapEntry = limLookUpKeyMappings(pHdr->sa);            if (pKeyMapEntry)            {                if (!pKeyMapEntry->wepOn)                {                   // Log error                   PELOGE(limLog(pMac, LOGE,                          FL("received Auth frame3 from peer that has NULL key map entry "                          MAC_ADDRESS_STR),MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * Key Mapping entry has null key.                     * Send Authentication frame                     * with challenge failure status code                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                } // if (!pKeyMapEntry->wepOn)                else                {                    decryptResult = limDecryptAuthFrame(pMac, pKeyMapEntry->key,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH));                    if (decryptResult == LIM_DECRYPT_ICV_FAIL)                    {                        // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer that failed decryption, Addr "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                        limDeletePreAuthNode(pMac,                                             pHdr->sa);                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;                        authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                        authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }                    if ((sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                         &rxAuthFrame)!=eSIR_SUCCESS ) ||                        ( !isAuthValid(pMac, &rxAuthFrame,psessionEntry)))                    {                        PELOGE(limLog(pMac, LOGE, FL(                               "failed to convert Auth Frame to structure or Auth is not valid "));)                        return;                    }                } // end if (pKeyMapEntry->key == NULL)            } // if keyMappings has entry            else            {                val = SIR_MAC_KEY_LENGTH;                if (LIM_IS_AP_ROLE(psessionEntry)) {                    tpSirKeys pKey;                    pKey =  &psessionEntry->WEPKeyMaterial[keyId].key[0];                    vos_mem_copy(defaultKey, pKey->key, pKey->keyLength);                    val = pKey->keyLength;                } else if (wlan_cfgGetStr(pMac,                             (tANI_U16) (WNI_CFG_WEP_DEFAULT_KEY_1 + keyId),                              defaultKey, &val) != eSIR_SUCCESS) {                    /// Could not get Default key from CFG.                    //Log error.                    limLog(pMac, LOGP,                           FL("could not retrieve Default key"));                    /**                     * Send Authentication frame                     * with challenge failure status code                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }                    key_length=val;                    decryptResult = limDecryptAuthFrame(pMac, defaultKey,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH));                    if (decryptResult == LIM_DECRYPT_ICV_FAIL)                    {                         // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer that failed decryption: "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                       /// ICV failure                        limDeletePreAuthNode(pMac,                                             pHdr->sa);                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;                        authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                        authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }                    if ( ( sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                          &rxAuthFrame)!=eSIR_SUCCESS ) ||                        ( !isAuthValid(pMac, &rxAuthFrame, psessionEntry) ) )                    {                        limLog(pMac, LOGE,                               FL("failed to convert Auth Frame to structure or Auth is not valid "));                        return;                    }            } // End of check for Key Mapping/Default key presence        }        else        {            // Log error            PELOGE(limLog(pMac, LOGE,                   FL("received Authentication frame3 from peer that while privacy option is turned OFF "                   MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)            /**             * Privacy option is not implemented.             * So reject Authentication frame received with             * WEP bit set by sending Authentication frame             * with 'challenge failure' status code. This is             * another strange thing in the spec. Status code             * should have been 'unsupported algorithm' status code.             */            authFrame.authAlgoNumber = eSIR_SHARED_KEY;            authFrame.authTransactionSeqNumber =            SIR_MAC_AUTH_FRAME_4;            authFrame.authStatusCode =            eSIR_MAC_CHALLENGE_FAILURE_STATUS;            limSendAuthMgmtFrame(pMac, &authFrame,                                 pHdr->sa,                                 LIM_NO_WEP_IN_FC,psessionEntry);            return;        } // else if (wlan_cfgGetInt(CFG_PRIVACY_OPTION_IMPLEMENTED))    }
if ((psessionEntry->bTkipCntrMeasActive) &&             LIM_IS_AP_ROLE(psessionEntry)) {            PELOGE( limLog(pMac, LOGE,               FL("Tkip counter measures Enabled, sending Deauth frame to")); )            limPrintMacAddr(pMac, pHdr->sa, LOGE);            limSendDeauthMgmtFrame( pMac, eSIR_MAC_MIC_FAILURE_REASON,                                    pHdr->sa, psessionEntry, FALSE );            return;        }
(psessionEntry->bTkipCntrMeasActive) &&             LIM_IS_AP_ROLE(psessionEntry)
(psessionEntry->bTkipCntrMeasActive)
psessionEntry->bTkipCntrMeasActive
psessionEntry
psessionEntry
bTkipCntrMeasActive
LIM_IS_AP_ROLE(psessionEntry)
LIM_IS_AP_ROLE
LIM_IS_AP_ROLE
psessionEntry
psessionEntry
{            PELOGE( limLog(pMac, LOGE,               FL("Tkip counter measures Enabled, sending Deauth frame to")); )            limPrintMacAddr(pMac, pHdr->sa, LOGE);            limSendDeauthMgmtFrame( pMac, eSIR_MAC_MIC_FAILURE_REASON,                                    pHdr->sa, psessionEntry, FALSE );            return;        }
PELOGE( limLog(pMac, LOGE,               FL("Tkip counter measures Enabled, sending Deauth frame to"));
)            limPrintMacAddr(pMac, pHdr->sa, LOGE);
limSendDeauthMgmtFrame( pMac, eSIR_MAC_MIC_FAILURE_REASON,                                    pHdr->sa, psessionEntry, FALSE );
limSendDeauthMgmtFrame( pMac, eSIR_MAC_MIC_FAILURE_REASON,                                    pHdr->sa, psessionEntry, FALSE )
limSendDeauthMgmtFrame
limSendDeauthMgmtFrame
pMac
pMac
eSIR_MAC_MIC_FAILURE_REASON
eSIR_MAC_MIC_FAILURE_REASON
pHdr->sa
pHdr
pHdr
sa
psessionEntry
psessionEntry
FALSE
FALSE
return;
keyId = (*(pBody + 3)) >> 6;
keyId = (*(pBody + 3)) >> 6
keyId
keyId
(*(pBody + 3)) >> 6
(*(pBody + 3))
*(pBody + 3)
(pBody + 3)
pBody + 3
pBody
pBody
3
6
if (LIM_IS_STA_ROLE(psessionEntry) ||            LIM_IS_BT_AMP_STA_ROLE(psessionEntry)) {            authFrame.authAlgoNumber = eSIR_SHARED_KEY;            authFrame.authTransactionSeqNumber = SIR_MAC_AUTH_FRAME_4;            authFrame.authStatusCode = eSIR_MAC_CHALLENGE_FAILURE_STATUS;            // Log error            PELOGE(limLog(pMac, LOGE,                   FL("received Authentication frame with wep bit set on role=%d"                   MAC_ADDRESS_STR), GET_LIM_SYSTEM_ROLE(psessionEntry),                   MAC_ADDR_ARRAY(pHdr->sa));)            limSendAuthMgmtFrame(pMac, &authFrame,                                 pHdr->sa,                                 LIM_NO_WEP_IN_FC,psessionEntry);            return;        }
LIM_IS_STA_ROLE(psessionEntry) ||            LIM_IS_BT_AMP_STA_ROLE(psessionEntry)
LIM_IS_STA_ROLE(psessionEntry)
LIM_IS_STA_ROLE
LIM_IS_STA_ROLE
psessionEntry
psessionEntry
LIM_IS_BT_AMP_STA_ROLE(psessionEntry)
LIM_IS_BT_AMP_STA_ROLE
LIM_IS_BT_AMP_STA_ROLE
psessionEntry
psessionEntry
{            authFrame.authAlgoNumber = eSIR_SHARED_KEY;            authFrame.authTransactionSeqNumber = SIR_MAC_AUTH_FRAME_4;            authFrame.authStatusCode = eSIR_MAC_CHALLENGE_FAILURE_STATUS;            // Log error            PELOGE(limLog(pMac, LOGE,                   FL("received Authentication frame with wep bit set on role=%d"                   MAC_ADDRESS_STR), GET_LIM_SYSTEM_ROLE(psessionEntry),                   MAC_ADDR_ARRAY(pHdr->sa));)            limSendAuthMgmtFrame(pMac, &authFrame,                                 pHdr->sa,                                 LIM_NO_WEP_IN_FC,psessionEntry);            return;        }
authFrame.authAlgoNumber = eSIR_SHARED_KEY;
authFrame.authAlgoNumber = eSIR_SHARED_KEY
authFrame.authAlgoNumber
authFrame
authFrame
authAlgoNumber
eSIR_SHARED_KEY
eSIR_SHARED_KEY
authFrame.authTransactionSeqNumber = SIR_MAC_AUTH_FRAME_4;
authFrame.authTransactionSeqNumber = SIR_MAC_AUTH_FRAME_4
authFrame.authTransactionSeqNumber
authFrame
authFrame
authTransactionSeqNumber
SIR_MAC_AUTH_FRAME_4
SIR_MAC_AUTH_FRAME_4
authFrame.authStatusCode = eSIR_MAC_CHALLENGE_FAILURE_STATUS;
authFrame.authStatusCode = eSIR_MAC_CHALLENGE_FAILURE_STATUS
authFrame.authStatusCode
authFrame
authFrame
authStatusCode
eSIR_MAC_CHALLENGE_FAILURE_STATUS
eSIR_MAC_CHALLENGE_FAILURE_STATUS
PELOGE(limLog(pMac, LOGE,                   FL("received Authentication frame with wep bit set on role=%d"                   MAC_ADDRESS_STR), GET_LIM_SYSTEM_ROLE(psessionEntry),                   MAC_ADDR_ARRAY(pHdr->sa));
)            limSendAuthMgmtFrame(pMac, &authFrame,                                 pHdr->sa,                                 LIM_NO_WEP_IN_FC,psessionEntry);
return;
if (frameLen < LIM_ENCR_AUTH_BODY_LEN)        {            // Log error            limLog(pMac, LOGE,                   FL("Not enough size [%d] to decrypt received Auth frame"),                   frameLen);            limPrintMacAddr(pMac, pHdr->sa, LOGE);            return;        }
frameLen < LIM_ENCR_AUTH_BODY_LEN
frameLen
frameLen
LIM_ENCR_AUTH_BODY_LEN
LIM_ENCR_AUTH_BODY_LEN
{            // Log error            limLog(pMac, LOGE,                   FL("Not enough size [%d] to decrypt received Auth frame"),                   frameLen);            limPrintMacAddr(pMac, pHdr->sa, LOGE);            return;        }
limLog(pMac, LOGE,                   FL("Not enough size [%d] to decrypt received Auth frame"),                   frameLen);
limLog(pMac, LOGE,                   FL("Not enough size [%d] to decrypt received Auth frame"),                   frameLen)
limLog
limLog
pMac
pMac
LOGE
LOGE
FL("Not enough size [%d] to decrypt received Auth frame")
FL
FL
"Not enough size [%d] to decrypt received Auth frame"
frameLen
frameLen
limPrintMacAddr(pMac, pHdr->sa, LOGE);
limPrintMacAddr(pMac, pHdr->sa, LOGE)
limPrintMacAddr
limPrintMacAddr
pMac
pMac
pHdr->sa
pHdr
pHdr
sa
LOGE
LOGE
return;
if (LIM_IS_AP_ROLE(psessionEntry)) {            val = psessionEntry->privacy;        }        else        // Accept Authentication frame only if Privacy is implemented        if (wlan_cfgGetInt(pMac, WNI_CFG_PRIVACY_ENABLED,                      &val) != eSIR_SUCCESS)        {            /**             * Could not get Privacy option             * from CFG. Log error.             */            limLog(pMac, LOGP, FL("could not retrieve Privacy option"));        }
LIM_IS_AP_ROLE(psessionEntry)
LIM_IS_AP_ROLE
LIM_IS_AP_ROLE
psessionEntry
psessionEntry
{            val = psessionEntry->privacy;        }
val = psessionEntry->privacy;
val = psessionEntry->privacy
val
val
psessionEntry->privacy
psessionEntry
psessionEntry
privacy
if (wlan_cfgGetInt(pMac, WNI_CFG_PRIVACY_ENABLED,                      &val) != eSIR_SUCCESS)        {            /**             * Could not get Privacy option             * from CFG. Log error.             */            limLog(pMac, LOGP, FL("could not retrieve Privacy option"));        }
wlan_cfgGetInt(pMac, WNI_CFG_PRIVACY_ENABLED,                      &val) != eSIR_SUCCESS
wlan_cfgGetInt(pMac, WNI_CFG_PRIVACY_ENABLED,                      &val)
wlan_cfgGetInt
wlan_cfgGetInt
pMac
pMac
WNI_CFG_PRIVACY_ENABLED
WNI_CFG_PRIVACY_ENABLED
&val
val
val
eSIR_SUCCESS
eSIR_SUCCESS
{            /**             * Could not get Privacy option             * from CFG. Log error.             */            limLog(pMac, LOGP, FL("could not retrieve Privacy option"));        }
limLog(pMac, LOGP, FL("could not retrieve Privacy option"));
limLog(pMac, LOGP, FL("could not retrieve Privacy option"))
limLog
limLog
pMac
pMac
LOGP
LOGP
FL("could not retrieve Privacy option")
FL
FL
"could not retrieve Privacy option"
cfgPrivacyOptImp = (tANI_U8)val;
cfgPrivacyOptImp = (tANI_U8)val
cfgPrivacyOptImp
cfgPrivacyOptImp
(tANI_U8)val
tANI_U8
tANI_U8
tANI_U8

val
val
if (cfgPrivacyOptImp)        {            /**             * Privacy option is implemented.             * Check if the received frame is Authentication             * frame3 and there is a context for requesting STA.             * If not, reject with unspecified failure status code             */            pAuthNode = limSearchPreAuthList(pMac, pHdr->sa);            if (pAuthNode == NULL)            {                // Log error                PELOGE(limLog(pMac, LOGE,                       FL("received Authentication frame from peer that has no preauth context with WEP bit set "                           MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                /**                 * No 'pre-auth' context exists for this STA that sent                 * an Authentication frame with FC bit set.                 * Send Auth frame4 with 'out of sequence' status code.                 */                authFrame.authAlgoNumber = eSIR_SHARED_KEY;                authFrame.authTransactionSeqNumber =                SIR_MAC_AUTH_FRAME_4;                authFrame.authStatusCode =                eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                limSendAuthMgmtFrame(pMac, &authFrame,                                     pHdr->sa,                                     LIM_NO_WEP_IN_FC,psessionEntry);                return;            }            else            {                /// Change the auth-response timeout                limDeactivateAndChangePerStaIdTimer(pMac,                                                    eLIM_AUTH_RSP_TIMER,                                                    pAuthNode->authNodeIdx);                /// 'Pre-auth' status exists for STA                if ((pAuthNode->mlmState !=                     eLIM_MLM_WT_AUTH_FRAME3_STATE) &&                    (pAuthNode->mlmState !=                     eLIM_MLM_AUTH_RSP_TIMEOUT_STATE))                {                   // Log error                   PELOGE(limLog(pMac, LOGE,                          FL("received Authentication frame from peer that is in state %d "                          MAC_ADDRESS_STR),                          pAuthNode->mlmState, MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * Should not have received Authentication frame                     * with WEP bit set in FC in other states.                     * Reject by sending Authenticaton frame with                     * out of sequence Auth frame status code.                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }            }            /**             * Check if there exists a key mappping key             * for the STA that sent Authentication frame             */            pKeyMapEntry = limLookUpKeyMappings(pHdr->sa);            if (pKeyMapEntry)            {                if (!pKeyMapEntry->wepOn)                {                   // Log error                   PELOGE(limLog(pMac, LOGE,                          FL("received Auth frame3 from peer that has NULL key map entry "                          MAC_ADDRESS_STR),MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * Key Mapping entry has null key.                     * Send Authentication frame                     * with challenge failure status code                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                } // if (!pKeyMapEntry->wepOn)                else                {                    decryptResult = limDecryptAuthFrame(pMac, pKeyMapEntry->key,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH));                    if (decryptResult == LIM_DECRYPT_ICV_FAIL)                    {                        // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer that failed decryption, Addr "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                        limDeletePreAuthNode(pMac,                                             pHdr->sa);                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;                        authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                        authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }                    if ((sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                         &rxAuthFrame)!=eSIR_SUCCESS ) ||                        ( !isAuthValid(pMac, &rxAuthFrame,psessionEntry)))                    {                        PELOGE(limLog(pMac, LOGE, FL(                               "failed to convert Auth Frame to structure or Auth is not valid "));)                        return;                    }                } // end if (pKeyMapEntry->key == NULL)            } // if keyMappings has entry            else            {                val = SIR_MAC_KEY_LENGTH;                if (LIM_IS_AP_ROLE(psessionEntry)) {                    tpSirKeys pKey;                    pKey =  &psessionEntry->WEPKeyMaterial[keyId].key[0];                    vos_mem_copy(defaultKey, pKey->key, pKey->keyLength);                    val = pKey->keyLength;                } else if (wlan_cfgGetStr(pMac,                             (tANI_U16) (WNI_CFG_WEP_DEFAULT_KEY_1 + keyId),                              defaultKey, &val) != eSIR_SUCCESS) {                    /// Could not get Default key from CFG.                    //Log error.                    limLog(pMac, LOGP,                           FL("could not retrieve Default key"));                    /**                     * Send Authentication frame                     * with challenge failure status code                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }                    key_length=val;                    decryptResult = limDecryptAuthFrame(pMac, defaultKey,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH));                    if (decryptResult == LIM_DECRYPT_ICV_FAIL)                    {                         // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer that failed decryption: "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                       /// ICV failure                        limDeletePreAuthNode(pMac,                                             pHdr->sa);                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;                        authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                        authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }                    if ( ( sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                          &rxAuthFrame)!=eSIR_SUCCESS ) ||                        ( !isAuthValid(pMac, &rxAuthFrame, psessionEntry) ) )                    {                        limLog(pMac, LOGE,                               FL("failed to convert Auth Frame to structure or Auth is not valid "));                        return;                    }            } // End of check for Key Mapping/Default key presence        }        else        {            // Log error            PELOGE(limLog(pMac, LOGE,                   FL("received Authentication frame3 from peer that while privacy option is turned OFF "                   MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)            /**             * Privacy option is not implemented.             * So reject Authentication frame received with             * WEP bit set by sending Authentication frame             * with 'challenge failure' status code. This is             * another strange thing in the spec. Status code             * should have been 'unsupported algorithm' status code.             */            authFrame.authAlgoNumber = eSIR_SHARED_KEY;            authFrame.authTransactionSeqNumber =            SIR_MAC_AUTH_FRAME_4;            authFrame.authStatusCode =            eSIR_MAC_CHALLENGE_FAILURE_STATUS;            limSendAuthMgmtFrame(pMac, &authFrame,                                 pHdr->sa,                                 LIM_NO_WEP_IN_FC,psessionEntry);            return;        }
cfgPrivacyOptImp
cfgPrivacyOptImp
{            /**             * Privacy option is implemented.             * Check if the received frame is Authentication             * frame3 and there is a context for requesting STA.             * If not, reject with unspecified failure status code             */            pAuthNode = limSearchPreAuthList(pMac, pHdr->sa);            if (pAuthNode == NULL)            {                // Log error                PELOGE(limLog(pMac, LOGE,                       FL("received Authentication frame from peer that has no preauth context with WEP bit set "                           MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                /**                 * No 'pre-auth' context exists for this STA that sent                 * an Authentication frame with FC bit set.                 * Send Auth frame4 with 'out of sequence' status code.                 */                authFrame.authAlgoNumber = eSIR_SHARED_KEY;                authFrame.authTransactionSeqNumber =                SIR_MAC_AUTH_FRAME_4;                authFrame.authStatusCode =                eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                limSendAuthMgmtFrame(pMac, &authFrame,                                     pHdr->sa,                                     LIM_NO_WEP_IN_FC,psessionEntry);                return;            }            else            {                /// Change the auth-response timeout                limDeactivateAndChangePerStaIdTimer(pMac,                                                    eLIM_AUTH_RSP_TIMER,                                                    pAuthNode->authNodeIdx);                /// 'Pre-auth' status exists for STA                if ((pAuthNode->mlmState !=                     eLIM_MLM_WT_AUTH_FRAME3_STATE) &&                    (pAuthNode->mlmState !=                     eLIM_MLM_AUTH_RSP_TIMEOUT_STATE))                {                   // Log error                   PELOGE(limLog(pMac, LOGE,                          FL("received Authentication frame from peer that is in state %d "                          MAC_ADDRESS_STR),                          pAuthNode->mlmState, MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * Should not have received Authentication frame                     * with WEP bit set in FC in other states.                     * Reject by sending Authenticaton frame with                     * out of sequence Auth frame status code.                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }            }            /**             * Check if there exists a key mappping key             * for the STA that sent Authentication frame             */            pKeyMapEntry = limLookUpKeyMappings(pHdr->sa);            if (pKeyMapEntry)            {                if (!pKeyMapEntry->wepOn)                {                   // Log error                   PELOGE(limLog(pMac, LOGE,                          FL("received Auth frame3 from peer that has NULL key map entry "                          MAC_ADDRESS_STR),MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * Key Mapping entry has null key.                     * Send Authentication frame                     * with challenge failure status code                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                } // if (!pKeyMapEntry->wepOn)                else                {                    decryptResult = limDecryptAuthFrame(pMac, pKeyMapEntry->key,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH));                    if (decryptResult == LIM_DECRYPT_ICV_FAIL)                    {                        // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer that failed decryption, Addr "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                        limDeletePreAuthNode(pMac,                                             pHdr->sa);                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;                        authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                        authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }                    if ((sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                         &rxAuthFrame)!=eSIR_SUCCESS ) ||                        ( !isAuthValid(pMac, &rxAuthFrame,psessionEntry)))                    {                        PELOGE(limLog(pMac, LOGE, FL(                               "failed to convert Auth Frame to structure or Auth is not valid "));)                        return;                    }                } // end if (pKeyMapEntry->key == NULL)            } // if keyMappings has entry            else            {                val = SIR_MAC_KEY_LENGTH;                if (LIM_IS_AP_ROLE(psessionEntry)) {                    tpSirKeys pKey;                    pKey =  &psessionEntry->WEPKeyMaterial[keyId].key[0];                    vos_mem_copy(defaultKey, pKey->key, pKey->keyLength);                    val = pKey->keyLength;                } else if (wlan_cfgGetStr(pMac,                             (tANI_U16) (WNI_CFG_WEP_DEFAULT_KEY_1 + keyId),                              defaultKey, &val) != eSIR_SUCCESS) {                    /// Could not get Default key from CFG.                    //Log error.                    limLog(pMac, LOGP,                           FL("could not retrieve Default key"));                    /**                     * Send Authentication frame                     * with challenge failure status code                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }                    key_length=val;                    decryptResult = limDecryptAuthFrame(pMac, defaultKey,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH));                    if (decryptResult == LIM_DECRYPT_ICV_FAIL)                    {                         // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer that failed decryption: "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                       /// ICV failure                        limDeletePreAuthNode(pMac,                                             pHdr->sa);                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;                        authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                        authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }                    if ( ( sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                          &rxAuthFrame)!=eSIR_SUCCESS ) ||                        ( !isAuthValid(pMac, &rxAuthFrame, psessionEntry) ) )                    {                        limLog(pMac, LOGE,                               FL("failed to convert Auth Frame to structure or Auth is not valid "));                        return;                    }            } // End of check for Key Mapping/Default key presence        }
pAuthNode = limSearchPreAuthList(pMac, pHdr->sa);
pAuthNode = limSearchPreAuthList(pMac, pHdr->sa)
pAuthNode
pAuthNode
limSearchPreAuthList(pMac, pHdr->sa)
limSearchPreAuthList
limSearchPreAuthList
pMac
pMac
pHdr->sa
pHdr
pHdr
sa
if (pAuthNode == NULL)            {                // Log error                PELOGE(limLog(pMac, LOGE,                       FL("received Authentication frame from peer that has no preauth context with WEP bit set "                           MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                /**                 * No 'pre-auth' context exists for this STA that sent                 * an Authentication frame with FC bit set.                 * Send Auth frame4 with 'out of sequence' status code.                 */                authFrame.authAlgoNumber = eSIR_SHARED_KEY;                authFrame.authTransactionSeqNumber =                SIR_MAC_AUTH_FRAME_4;                authFrame.authStatusCode =                eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                limSendAuthMgmtFrame(pMac, &authFrame,                                     pHdr->sa,                                     LIM_NO_WEP_IN_FC,psessionEntry);                return;            }            else            {                /// Change the auth-response timeout                limDeactivateAndChangePerStaIdTimer(pMac,                                                    eLIM_AUTH_RSP_TIMER,                                                    pAuthNode->authNodeIdx);                /// 'Pre-auth' status exists for STA                if ((pAuthNode->mlmState !=                     eLIM_MLM_WT_AUTH_FRAME3_STATE) &&                    (pAuthNode->mlmState !=                     eLIM_MLM_AUTH_RSP_TIMEOUT_STATE))                {                   // Log error                   PELOGE(limLog(pMac, LOGE,                          FL("received Authentication frame from peer that is in state %d "                          MAC_ADDRESS_STR),                          pAuthNode->mlmState, MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * Should not have received Authentication frame                     * with WEP bit set in FC in other states.                     * Reject by sending Authenticaton frame with                     * out of sequence Auth frame status code.                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }            }
pAuthNode == NULL
pAuthNode
pAuthNode
NULL
NULL
{                // Log error                PELOGE(limLog(pMac, LOGE,                       FL("received Authentication frame from peer that has no preauth context with WEP bit set "                           MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                /**                 * No 'pre-auth' context exists for this STA that sent                 * an Authentication frame with FC bit set.                 * Send Auth frame4 with 'out of sequence' status code.                 */                authFrame.authAlgoNumber = eSIR_SHARED_KEY;                authFrame.authTransactionSeqNumber =                SIR_MAC_AUTH_FRAME_4;                authFrame.authStatusCode =                eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                limSendAuthMgmtFrame(pMac, &authFrame,                                     pHdr->sa,                                     LIM_NO_WEP_IN_FC,psessionEntry);                return;            }
PELOGE(limLog(pMac, LOGE,                       FL("received Authentication frame from peer that has no preauth context with WEP bit set "                           MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));
)                /**                 * No 'pre-auth' context exists for this STA that sent                 * an Authentication frame with FC bit set.                 * Send Auth frame4 with 'out of sequence' status code.                 */                authFrame.authAlgoNumber = eSIR_SHARED_KEY;
authFrame.authTransactionSeqNumber =                SIR_MAC_AUTH_FRAME_4;
authFrame.authTransactionSeqNumber =                SIR_MAC_AUTH_FRAME_4
authFrame.authTransactionSeqNumber
authFrame
authFrame
authTransactionSeqNumber
SIR_MAC_AUTH_FRAME_4
SIR_MAC_AUTH_FRAME_4
authFrame.authStatusCode =                eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;
authFrame.authStatusCode =                eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS
authFrame.authStatusCode
authFrame
authFrame
authStatusCode
eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS
eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS
limSendAuthMgmtFrame(pMac, &authFrame,                                     pHdr->sa,                                     LIM_NO_WEP_IN_FC,psessionEntry);
limSendAuthMgmtFrame(pMac, &authFrame,                                     pHdr->sa,                                     LIM_NO_WEP_IN_FC,psessionEntry)
limSendAuthMgmtFrame
limSendAuthMgmtFrame
pMac
pMac
&authFrame
authFrame
authFrame
pHdr->sa
pHdr
pHdr
sa
LIM_NO_WEP_IN_FC
LIM_NO_WEP_IN_FC
psessionEntry
psessionEntry
return;
{                /// Change the auth-response timeout                limDeactivateAndChangePerStaIdTimer(pMac,                                                    eLIM_AUTH_RSP_TIMER,                                                    pAuthNode->authNodeIdx);                /// 'Pre-auth' status exists for STA                if ((pAuthNode->mlmState !=                     eLIM_MLM_WT_AUTH_FRAME3_STATE) &&                    (pAuthNode->mlmState !=                     eLIM_MLM_AUTH_RSP_TIMEOUT_STATE))                {                   // Log error                   PELOGE(limLog(pMac, LOGE,                          FL("received Authentication frame from peer that is in state %d "                          MAC_ADDRESS_STR),                          pAuthNode->mlmState, MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * Should not have received Authentication frame                     * with WEP bit set in FC in other states.                     * Reject by sending Authenticaton frame with                     * out of sequence Auth frame status code.                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }            }
limDeactivateAndChangePerStaIdTimer(pMac,                                                    eLIM_AUTH_RSP_TIMER,                                                    pAuthNode->authNodeIdx);
limDeactivateAndChangePerStaIdTimer(pMac,                                                    eLIM_AUTH_RSP_TIMER,                                                    pAuthNode->authNodeIdx)
limDeactivateAndChangePerStaIdTimer
limDeactivateAndChangePerStaIdTimer
pMac
pMac
eLIM_AUTH_RSP_TIMER
eLIM_AUTH_RSP_TIMER
pAuthNode->authNodeIdx
pAuthNode
pAuthNode
authNodeIdx
if ((pAuthNode->mlmState !=                     eLIM_MLM_WT_AUTH_FRAME3_STATE) &&                    (pAuthNode->mlmState !=                     eLIM_MLM_AUTH_RSP_TIMEOUT_STATE))                {                   // Log error                   PELOGE(limLog(pMac, LOGE,                          FL("received Authentication frame from peer that is in state %d "                          MAC_ADDRESS_STR),                          pAuthNode->mlmState, MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * Should not have received Authentication frame                     * with WEP bit set in FC in other states.                     * Reject by sending Authenticaton frame with                     * out of sequence Auth frame status code.                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }
(pAuthNode->mlmState !=                     eLIM_MLM_WT_AUTH_FRAME3_STATE) &&                    (pAuthNode->mlmState !=                     eLIM_MLM_AUTH_RSP_TIMEOUT_STATE)
(pAuthNode->mlmState !=                     eLIM_MLM_WT_AUTH_FRAME3_STATE)
pAuthNode->mlmState !=                     eLIM_MLM_WT_AUTH_FRAME3_STATE
pAuthNode->mlmState
pAuthNode
pAuthNode
mlmState
eLIM_MLM_WT_AUTH_FRAME3_STATE
eLIM_MLM_WT_AUTH_FRAME3_STATE
(pAuthNode->mlmState !=                     eLIM_MLM_AUTH_RSP_TIMEOUT_STATE)
pAuthNode->mlmState !=                     eLIM_MLM_AUTH_RSP_TIMEOUT_STATE
pAuthNode->mlmState
pAuthNode
pAuthNode
mlmState
eLIM_MLM_AUTH_RSP_TIMEOUT_STATE
eLIM_MLM_AUTH_RSP_TIMEOUT_STATE
{                   // Log error                   PELOGE(limLog(pMac, LOGE,                          FL("received Authentication frame from peer that is in state %d "                          MAC_ADDRESS_STR),                          pAuthNode->mlmState, MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * Should not have received Authentication frame                     * with WEP bit set in FC in other states.                     * Reject by sending Authenticaton frame with                     * out of sequence Auth frame status code.                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }
PELOGE(limLog(pMac, LOGE,                          FL("received Authentication frame from peer that is in state %d "                          MAC_ADDRESS_STR),                          pAuthNode->mlmState, MAC_ADDR_ARRAY(pHdr->sa));
)                    /**                     * Should not have received Authentication frame                     * with WEP bit set in FC in other states.                     * Reject by sending Authenticaton frame with                     * out of sequence Auth frame status code.                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;
authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;
authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4
authFrame.authTransactionSeqNumber
authFrame
authFrame
authTransactionSeqNumber
SIR_MAC_AUTH_FRAME_4
SIR_MAC_AUTH_FRAME_4
authFrame.authStatusCode =                    eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;
authFrame.authStatusCode =                    eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS
authFrame.authStatusCode
authFrame
authFrame
authStatusCode
eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS
eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS
limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);
limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry)
limSendAuthMgmtFrame
limSendAuthMgmtFrame
pMac
pMac
&authFrame
authFrame
authFrame
pHdr->sa
pHdr
pHdr
sa
LIM_NO_WEP_IN_FC
LIM_NO_WEP_IN_FC
psessionEntry
psessionEntry
return;
pKeyMapEntry = limLookUpKeyMappings(pHdr->sa);
pKeyMapEntry = limLookUpKeyMappings(pHdr->sa)
pKeyMapEntry
pKeyMapEntry
limLookUpKeyMappings(pHdr->sa)
limLookUpKeyMappings
limLookUpKeyMappings
pHdr->sa
pHdr
pHdr
sa
if (pKeyMapEntry)            {                if (!pKeyMapEntry->wepOn)                {                   // Log error                   PELOGE(limLog(pMac, LOGE,                          FL("received Auth frame3 from peer that has NULL key map entry "                          MAC_ADDRESS_STR),MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * Key Mapping entry has null key.                     * Send Authentication frame                     * with challenge failure status code                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                } // if (!pKeyMapEntry->wepOn)                else                {                    decryptResult = limDecryptAuthFrame(pMac, pKeyMapEntry->key,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH));                    if (decryptResult == LIM_DECRYPT_ICV_FAIL)                    {                        // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer that failed decryption, Addr "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                        limDeletePreAuthNode(pMac,                                             pHdr->sa);                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;                        authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                        authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }                    if ((sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                         &rxAuthFrame)!=eSIR_SUCCESS ) ||                        ( !isAuthValid(pMac, &rxAuthFrame,psessionEntry)))                    {                        PELOGE(limLog(pMac, LOGE, FL(                               "failed to convert Auth Frame to structure or Auth is not valid "));)                        return;                    }                } // end if (pKeyMapEntry->key == NULL)            } // if keyMappings has entry            else            {                val = SIR_MAC_KEY_LENGTH;                if (LIM_IS_AP_ROLE(psessionEntry)) {                    tpSirKeys pKey;                    pKey =  &psessionEntry->WEPKeyMaterial[keyId].key[0];                    vos_mem_copy(defaultKey, pKey->key, pKey->keyLength);                    val = pKey->keyLength;                } else if (wlan_cfgGetStr(pMac,                             (tANI_U16) (WNI_CFG_WEP_DEFAULT_KEY_1 + keyId),                              defaultKey, &val) != eSIR_SUCCESS) {                    /// Could not get Default key from CFG.                    //Log error.                    limLog(pMac, LOGP,                           FL("could not retrieve Default key"));                    /**                     * Send Authentication frame                     * with challenge failure status code                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }                    key_length=val;                    decryptResult = limDecryptAuthFrame(pMac, defaultKey,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH));                    if (decryptResult == LIM_DECRYPT_ICV_FAIL)                    {                         // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer that failed decryption: "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                       /// ICV failure                        limDeletePreAuthNode(pMac,                                             pHdr->sa);                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;                        authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                        authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }                    if ( ( sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                          &rxAuthFrame)!=eSIR_SUCCESS ) ||                        ( !isAuthValid(pMac, &rxAuthFrame, psessionEntry) ) )                    {                        limLog(pMac, LOGE,                               FL("failed to convert Auth Frame to structure or Auth is not valid "));                        return;                    }            }
pKeyMapEntry
pKeyMapEntry
{                if (!pKeyMapEntry->wepOn)                {                   // Log error                   PELOGE(limLog(pMac, LOGE,                          FL("received Auth frame3 from peer that has NULL key map entry "                          MAC_ADDRESS_STR),MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * Key Mapping entry has null key.                     * Send Authentication frame                     * with challenge failure status code                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                } // if (!pKeyMapEntry->wepOn)                else                {                    decryptResult = limDecryptAuthFrame(pMac, pKeyMapEntry->key,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH));                    if (decryptResult == LIM_DECRYPT_ICV_FAIL)                    {                        // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer that failed decryption, Addr "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                        limDeletePreAuthNode(pMac,                                             pHdr->sa);                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;                        authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                        authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }                    if ((sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                         &rxAuthFrame)!=eSIR_SUCCESS ) ||                        ( !isAuthValid(pMac, &rxAuthFrame,psessionEntry)))                    {                        PELOGE(limLog(pMac, LOGE, FL(                               "failed to convert Auth Frame to structure or Auth is not valid "));)                        return;                    }                } // end if (pKeyMapEntry->key == NULL)            }
if (!pKeyMapEntry->wepOn)                {                   // Log error                   PELOGE(limLog(pMac, LOGE,                          FL("received Auth frame3 from peer that has NULL key map entry "                          MAC_ADDRESS_STR),MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * Key Mapping entry has null key.                     * Send Authentication frame                     * with challenge failure status code                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                } // if (!pKeyMapEntry->wepOn)                else                {                    decryptResult = limDecryptAuthFrame(pMac, pKeyMapEntry->key,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH));                    if (decryptResult == LIM_DECRYPT_ICV_FAIL)                    {                        // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer that failed decryption, Addr "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                        limDeletePreAuthNode(pMac,                                             pHdr->sa);                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;                        authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                        authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }                    if ((sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                         &rxAuthFrame)!=eSIR_SUCCESS ) ||                        ( !isAuthValid(pMac, &rxAuthFrame,psessionEntry)))                    {                        PELOGE(limLog(pMac, LOGE, FL(                               "failed to convert Auth Frame to structure or Auth is not valid "));)                        return;                    }                }
!pKeyMapEntry->wepOn
pKeyMapEntry->wepOn
pKeyMapEntry
pKeyMapEntry
wepOn
{                   // Log error                   PELOGE(limLog(pMac, LOGE,                          FL("received Auth frame3 from peer that has NULL key map entry "                          MAC_ADDRESS_STR),MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * Key Mapping entry has null key.                     * Send Authentication frame                     * with challenge failure status code                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }
PELOGE(limLog(pMac, LOGE,                          FL("received Auth frame3 from peer that has NULL key map entry "                          MAC_ADDRESS_STR),MAC_ADDR_ARRAY(pHdr->sa));
)                    /**                     * Key Mapping entry has null key.                     * Send Authentication frame                     * with challenge failure status code                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;
authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;
authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4
authFrame.authTransactionSeqNumber
authFrame
authFrame
authTransactionSeqNumber
SIR_MAC_AUTH_FRAME_4
SIR_MAC_AUTH_FRAME_4
authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;
authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS
authFrame.authStatusCode
authFrame
authFrame
authStatusCode
eSIR_MAC_CHALLENGE_FAILURE_STATUS
eSIR_MAC_CHALLENGE_FAILURE_STATUS
limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);
limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry)
limSendAuthMgmtFrame
limSendAuthMgmtFrame
pMac
pMac
&authFrame
authFrame
authFrame
pHdr->sa
pHdr
pHdr
sa
LIM_NO_WEP_IN_FC
LIM_NO_WEP_IN_FC
psessionEntry
psessionEntry
return;
{                    decryptResult = limDecryptAuthFrame(pMac, pKeyMapEntry->key,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH));                    if (decryptResult == LIM_DECRYPT_ICV_FAIL)                    {                        // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer that failed decryption, Addr "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                        limDeletePreAuthNode(pMac,                                             pHdr->sa);                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;                        authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                        authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }                    if ((sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                         &rxAuthFrame)!=eSIR_SUCCESS ) ||                        ( !isAuthValid(pMac, &rxAuthFrame,psessionEntry)))                    {                        PELOGE(limLog(pMac, LOGE, FL(                               "failed to convert Auth Frame to structure or Auth is not valid "));)                        return;                    }                }
decryptResult = limDecryptAuthFrame(pMac, pKeyMapEntry->key,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH));
decryptResult = limDecryptAuthFrame(pMac, pKeyMapEntry->key,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH))
decryptResult
decryptResult
limDecryptAuthFrame(pMac, pKeyMapEntry->key,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH))
limDecryptAuthFrame
limDecryptAuthFrame
pMac
pMac
pKeyMapEntry->key
pKeyMapEntry
pKeyMapEntry
key
pBody
pBody
plainBody
plainBody
key_length
key_length
(tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH)
(tANI_U16)
tANI_U16
tANI_U16
frameLen-SIR_MAC_WEP_IV_LENGTH
frameLen
frameLen
SIR_MAC_WEP_IV_LENGTH
SIR_MAC_WEP_IV_LENGTH
if (decryptResult == LIM_DECRYPT_ICV_FAIL)                    {                        // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer that failed decryption, Addr "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                        limDeletePreAuthNode(pMac,                                             pHdr->sa);                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;                        authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                        authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }
decryptResult == LIM_DECRYPT_ICV_FAIL
decryptResult
decryptResult
LIM_DECRYPT_ICV_FAIL
LIM_DECRYPT_ICV_FAIL
{                        // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer that failed decryption, Addr "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                        limDeletePreAuthNode(pMac,                                             pHdr->sa);                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;                        authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                        authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }
PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer that failed decryption, Addr "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));
)                        limDeletePreAuthNode(pMac,                                             pHdr->sa);
authFrame.authAlgoNumber = eSIR_SHARED_KEY;
authFrame.authAlgoNumber = eSIR_SHARED_KEY
authFrame.authAlgoNumber
authFrame
authFrame
authAlgoNumber
eSIR_SHARED_KEY
eSIR_SHARED_KEY
authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;
authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4
authFrame.authTransactionSeqNumber
authFrame
authFrame
authTransactionSeqNumber
SIR_MAC_AUTH_FRAME_4
SIR_MAC_AUTH_FRAME_4
authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;
authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS
authFrame.authStatusCode
authFrame
authFrame
authStatusCode
eSIR_MAC_CHALLENGE_FAILURE_STATUS
eSIR_MAC_CHALLENGE_FAILURE_STATUS
limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);
limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry)
limSendAuthMgmtFrame
limSendAuthMgmtFrame
pMac
pMac
&authFrame
authFrame
authFrame
pHdr->sa
pHdr
pHdr
sa
LIM_NO_WEP_IN_FC
LIM_NO_WEP_IN_FC
psessionEntry
psessionEntry
return;
if ((sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                         &rxAuthFrame)!=eSIR_SUCCESS ) ||                        ( !isAuthValid(pMac, &rxAuthFrame,psessionEntry)))                    {                        PELOGE(limLog(pMac, LOGE, FL(                               "failed to convert Auth Frame to structure or Auth is not valid "));)                        return;                    }
(sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                         &rxAuthFrame)!=eSIR_SUCCESS ) ||                        ( !isAuthValid(pMac, &rxAuthFrame,psessionEntry))
(sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                         &rxAuthFrame)!=eSIR_SUCCESS )
sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                         &rxAuthFrame)!=eSIR_SUCCESS
sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                         &rxAuthFrame)
sirConvertAuthFrame2Struct
sirConvertAuthFrame2Struct
pMac
pMac
plainBody
plainBody
frameLen-8
frameLen
frameLen
8
&rxAuthFrame
rxAuthFrame
rxAuthFrame
eSIR_SUCCESS
eSIR_SUCCESS
( !isAuthValid(pMac, &rxAuthFrame,psessionEntry))
!isAuthValid(pMac, &rxAuthFrame,psessionEntry)
isAuthValid(pMac, &rxAuthFrame,psessionEntry)
isAuthValid
isAuthValid
pMac
pMac
&rxAuthFrame
rxAuthFrame
rxAuthFrame
psessionEntry
psessionEntry
{                        PELOGE(limLog(pMac, LOGE, FL(                               "failed to convert Auth Frame to structure or Auth is not valid "));)                        return;                    }
PELOGE(limLog(pMac, LOGE, FL(                               "failed to convert Auth Frame to structure or Auth is not valid "));
)                        return;
{                val = SIR_MAC_KEY_LENGTH;                if (LIM_IS_AP_ROLE(psessionEntry)) {                    tpSirKeys pKey;                    pKey =  &psessionEntry->WEPKeyMaterial[keyId].key[0];                    vos_mem_copy(defaultKey, pKey->key, pKey->keyLength);                    val = pKey->keyLength;                } else if (wlan_cfgGetStr(pMac,                             (tANI_U16) (WNI_CFG_WEP_DEFAULT_KEY_1 + keyId),                              defaultKey, &val) != eSIR_SUCCESS) {                    /// Could not get Default key from CFG.                    //Log error.                    limLog(pMac, LOGP,                           FL("could not retrieve Default key"));                    /**                     * Send Authentication frame                     * with challenge failure status code                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }                    key_length=val;                    decryptResult = limDecryptAuthFrame(pMac, defaultKey,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH));                    if (decryptResult == LIM_DECRYPT_ICV_FAIL)                    {                         // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer that failed decryption: "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                       /// ICV failure                        limDeletePreAuthNode(pMac,                                             pHdr->sa);                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;                        authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                        authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }                    if ( ( sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                          &rxAuthFrame)!=eSIR_SUCCESS ) ||                        ( !isAuthValid(pMac, &rxAuthFrame, psessionEntry) ) )                    {                        limLog(pMac, LOGE,                               FL("failed to convert Auth Frame to structure or Auth is not valid "));                        return;                    }            }
val = SIR_MAC_KEY_LENGTH;
val = SIR_MAC_KEY_LENGTH
val
val
SIR_MAC_KEY_LENGTH
SIR_MAC_KEY_LENGTH
if (LIM_IS_AP_ROLE(psessionEntry)) {                    tpSirKeys pKey;                    pKey =  &psessionEntry->WEPKeyMaterial[keyId].key[0];                    vos_mem_copy(defaultKey, pKey->key, pKey->keyLength);                    val = pKey->keyLength;                } else if (wlan_cfgGetStr(pMac,                             (tANI_U16) (WNI_CFG_WEP_DEFAULT_KEY_1 + keyId),                              defaultKey, &val) != eSIR_SUCCESS) {                    /// Could not get Default key from CFG.                    //Log error.                    limLog(pMac, LOGP,                           FL("could not retrieve Default key"));                    /**                     * Send Authentication frame                     * with challenge failure status code                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }
LIM_IS_AP_ROLE(psessionEntry)
LIM_IS_AP_ROLE
LIM_IS_AP_ROLE
psessionEntry
psessionEntry
{                    tpSirKeys pKey;                    pKey =  &psessionEntry->WEPKeyMaterial[keyId].key[0];                    vos_mem_copy(defaultKey, pKey->key, pKey->keyLength);                    val = pKey->keyLength;                }
tpSirKeys pKey;
tpSirKeys pKey;
tpSirKeys
tpSirKeys
pKey
pKey
pKey =  &psessionEntry->WEPKeyMaterial[keyId].key[0];
pKey =  &psessionEntry->WEPKeyMaterial[keyId].key[0]
pKey
pKey
&psessionEntry->WEPKeyMaterial[keyId].key[0]
psessionEntry->WEPKeyMaterial[keyId].key[0]
psessionEntry->WEPKeyMaterial[keyId].key
psessionEntry->WEPKeyMaterial[keyId]
psessionEntry->WEPKeyMaterial
psessionEntry
psessionEntry
WEPKeyMaterial
keyId
keyId
key
0
vos_mem_copy(defaultKey, pKey->key, pKey->keyLength);
vos_mem_copy(defaultKey, pKey->key, pKey->keyLength)
vos_mem_copy
vos_mem_copy
defaultKey
defaultKey
pKey->key
pKey
pKey
key
pKey->keyLength
pKey
pKey
keyLength
val = pKey->keyLength;
val = pKey->keyLength
val
val
pKey->keyLength
pKey
pKey
keyLength
if (wlan_cfgGetStr(pMac,                             (tANI_U16) (WNI_CFG_WEP_DEFAULT_KEY_1 + keyId),                              defaultKey, &val) != eSIR_SUCCESS) {                    /// Could not get Default key from CFG.                    //Log error.                    limLog(pMac, LOGP,                           FL("could not retrieve Default key"));                    /**                     * Send Authentication frame                     * with challenge failure status code                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }
wlan_cfgGetStr(pMac,                             (tANI_U16) (WNI_CFG_WEP_DEFAULT_KEY_1 + keyId),                              defaultKey, &val) != eSIR_SUCCESS
wlan_cfgGetStr(pMac,                             (tANI_U16) (WNI_CFG_WEP_DEFAULT_KEY_1 + keyId),                              defaultKey, &val)
wlan_cfgGetStr
wlan_cfgGetStr
pMac
pMac
(tANI_U16) (WNI_CFG_WEP_DEFAULT_KEY_1 + keyId)
(tANI_U16)
tANI_U16
tANI_U16
WNI_CFG_WEP_DEFAULT_KEY_1 + keyId
WNI_CFG_WEP_DEFAULT_KEY_1
WNI_CFG_WEP_DEFAULT_KEY_1
keyId
keyId
defaultKey
defaultKey
&val
val
val
eSIR_SUCCESS
eSIR_SUCCESS
{                    /// Could not get Default key from CFG.                    //Log error.                    limLog(pMac, LOGP,                           FL("could not retrieve Default key"));                    /**                     * Send Authentication frame                     * with challenge failure status code                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }
limLog(pMac, LOGP,                           FL("could not retrieve Default key"));
limLog(pMac, LOGP,                           FL("could not retrieve Default key"))
limLog
limLog
pMac
pMac
LOGP
LOGP
FL("could not retrieve Default key")
FL
FL
"could not retrieve Default key"
authFrame.authAlgoNumber = eSIR_SHARED_KEY;
authFrame.authAlgoNumber = eSIR_SHARED_KEY
authFrame.authAlgoNumber
authFrame
authFrame
authAlgoNumber
eSIR_SHARED_KEY
eSIR_SHARED_KEY
authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;
authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4
authFrame.authTransactionSeqNumber
authFrame
authFrame
authTransactionSeqNumber
SIR_MAC_AUTH_FRAME_4
SIR_MAC_AUTH_FRAME_4
authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;
authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS
authFrame.authStatusCode
authFrame
authFrame
authStatusCode
eSIR_MAC_CHALLENGE_FAILURE_STATUS
eSIR_MAC_CHALLENGE_FAILURE_STATUS
limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);
limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry)
limSendAuthMgmtFrame
limSendAuthMgmtFrame
pMac
pMac
&authFrame
authFrame
authFrame
pHdr->sa
pHdr
pHdr
sa
LIM_NO_WEP_IN_FC
LIM_NO_WEP_IN_FC
psessionEntry
psessionEntry
return;
key_length=val;
key_length=val
key_length
key_length
val
val
decryptResult = limDecryptAuthFrame(pMac, defaultKey,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH));
decryptResult = limDecryptAuthFrame(pMac, defaultKey,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH))
decryptResult
decryptResult
limDecryptAuthFrame(pMac, defaultKey,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH))
limDecryptAuthFrame
limDecryptAuthFrame
pMac
pMac
defaultKey
defaultKey
pBody
pBody
plainBody
plainBody
key_length
key_length
(tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH)
(tANI_U16)
tANI_U16
tANI_U16
frameLen-SIR_MAC_WEP_IV_LENGTH
frameLen
frameLen
SIR_MAC_WEP_IV_LENGTH
SIR_MAC_WEP_IV_LENGTH
if (decryptResult == LIM_DECRYPT_ICV_FAIL)                    {                         // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer that failed decryption: "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                       /// ICV failure                        limDeletePreAuthNode(pMac,                                             pHdr->sa);                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;                        authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                        authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }
decryptResult == LIM_DECRYPT_ICV_FAIL
decryptResult
decryptResult
LIM_DECRYPT_ICV_FAIL
LIM_DECRYPT_ICV_FAIL
{                         // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer that failed decryption: "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                       /// ICV failure                        limDeletePreAuthNode(pMac,                                             pHdr->sa);                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;                        authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                        authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }
PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer that failed decryption: "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));
)                       /// ICV failure                        limDeletePreAuthNode(pMac,                                             pHdr->sa);
authFrame.authAlgoNumber = eSIR_SHARED_KEY;
authFrame.authAlgoNumber = eSIR_SHARED_KEY
authFrame.authAlgoNumber
authFrame
authFrame
authAlgoNumber
eSIR_SHARED_KEY
eSIR_SHARED_KEY
authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;
authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4
authFrame.authTransactionSeqNumber
authFrame
authFrame
authTransactionSeqNumber
SIR_MAC_AUTH_FRAME_4
SIR_MAC_AUTH_FRAME_4
authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;
authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS
authFrame.authStatusCode
authFrame
authFrame
authStatusCode
eSIR_MAC_CHALLENGE_FAILURE_STATUS
eSIR_MAC_CHALLENGE_FAILURE_STATUS
limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);
limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry)
limSendAuthMgmtFrame
limSendAuthMgmtFrame
pMac
pMac
&authFrame
authFrame
authFrame
pHdr->sa
pHdr
pHdr
sa
LIM_NO_WEP_IN_FC
LIM_NO_WEP_IN_FC
psessionEntry
psessionEntry
return;
if ( ( sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                          &rxAuthFrame)!=eSIR_SUCCESS ) ||                        ( !isAuthValid(pMac, &rxAuthFrame, psessionEntry) ) )                    {                        limLog(pMac, LOGE,                               FL("failed to convert Auth Frame to structure or Auth is not valid "));                        return;                    }
( sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                          &rxAuthFrame)!=eSIR_SUCCESS ) ||                        ( !isAuthValid(pMac, &rxAuthFrame, psessionEntry) )
( sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                          &rxAuthFrame)!=eSIR_SUCCESS )
sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                          &rxAuthFrame)!=eSIR_SUCCESS
sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                          &rxAuthFrame)
sirConvertAuthFrame2Struct
sirConvertAuthFrame2Struct
pMac
pMac
plainBody
plainBody
frameLen-8
frameLen
frameLen
8
&rxAuthFrame
rxAuthFrame
rxAuthFrame
eSIR_SUCCESS
eSIR_SUCCESS
( !isAuthValid(pMac, &rxAuthFrame, psessionEntry) )
!isAuthValid(pMac, &rxAuthFrame, psessionEntry)
isAuthValid(pMac, &rxAuthFrame, psessionEntry)
isAuthValid
isAuthValid
pMac
pMac
&rxAuthFrame
rxAuthFrame
rxAuthFrame
psessionEntry
psessionEntry
{                        limLog(pMac, LOGE,                               FL("failed to convert Auth Frame to structure or Auth is not valid "));                        return;                    }
limLog(pMac, LOGE,                               FL("failed to convert Auth Frame to structure or Auth is not valid "));
limLog(pMac, LOGE,                               FL("failed to convert Auth Frame to structure or Auth is not valid "))
limLog
limLog
pMac
pMac
LOGE
LOGE
FL("failed to convert Auth Frame to structure or Auth is not valid ")
FL
FL
"failed to convert Auth Frame to structure or Auth is not valid "
return;
{            // Log error            PELOGE(limLog(pMac, LOGE,                   FL("received Authentication frame3 from peer that while privacy option is turned OFF "                   MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)            /**             * Privacy option is not implemented.             * So reject Authentication frame received with             * WEP bit set by sending Authentication frame             * with 'challenge failure' status code. This is             * another strange thing in the spec. Status code             * should have been 'unsupported algorithm' status code.             */            authFrame.authAlgoNumber = eSIR_SHARED_KEY;            authFrame.authTransactionSeqNumber =            SIR_MAC_AUTH_FRAME_4;            authFrame.authStatusCode =            eSIR_MAC_CHALLENGE_FAILURE_STATUS;            limSendAuthMgmtFrame(pMac, &authFrame,                                 pHdr->sa,                                 LIM_NO_WEP_IN_FC,psessionEntry);            return;        }
PELOGE(limLog(pMac, LOGE,                   FL("received Authentication frame3 from peer that while privacy option is turned OFF "                   MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));
)            /**             * Privacy option is not implemented.             * So reject Authentication frame received with             * WEP bit set by sending Authentication frame             * with 'challenge failure' status code. This is             * another strange thing in the spec. Status code             * should have been 'unsupported algorithm' status code.             */            authFrame.authAlgoNumber = eSIR_SHARED_KEY;
authFrame.authTransactionSeqNumber =            SIR_MAC_AUTH_FRAME_4;
authFrame.authTransactionSeqNumber =            SIR_MAC_AUTH_FRAME_4
authFrame.authTransactionSeqNumber
authFrame
authFrame
authTransactionSeqNumber
SIR_MAC_AUTH_FRAME_4
SIR_MAC_AUTH_FRAME_4
authFrame.authStatusCode =            eSIR_MAC_CHALLENGE_FAILURE_STATUS;
authFrame.authStatusCode =            eSIR_MAC_CHALLENGE_FAILURE_STATUS
authFrame.authStatusCode
authFrame
authFrame
authStatusCode
eSIR_MAC_CHALLENGE_FAILURE_STATUS
eSIR_MAC_CHALLENGE_FAILURE_STATUS
limSendAuthMgmtFrame(pMac, &authFrame,                                 pHdr->sa,                                 LIM_NO_WEP_IN_FC,psessionEntry);
limSendAuthMgmtFrame(pMac, &authFrame,                                 pHdr->sa,                                 LIM_NO_WEP_IN_FC,psessionEntry)
limSendAuthMgmtFrame
limSendAuthMgmtFrame
pMac
pMac
&authFrame
authFrame
authFrame
pHdr->sa
pHdr
pHdr
sa
LIM_NO_WEP_IN_FC
LIM_NO_WEP_IN_FC
psessionEntry
psessionEntry
return;
{        if ( ( sirConvertAuthFrame2Struct(pMac, pBody,            frameLen, &rxAuthFrame)!=eSIR_SUCCESS ) ||            ( !isAuthValid(pMac, &rxAuthFrame,psessionEntry) ) )        {            PELOGE(limLog(pMac, LOGE,                   FL("failed to convert Auth Frame to structure or Auth is not valid "));)            return;        }    }
if ( ( sirConvertAuthFrame2Struct(pMac, pBody,            frameLen, &rxAuthFrame)!=eSIR_SUCCESS ) ||            ( !isAuthValid(pMac, &rxAuthFrame,psessionEntry) ) )        {            PELOGE(limLog(pMac, LOGE,                   FL("failed to convert Auth Frame to structure or Auth is not valid "));)            return;        }
( sirConvertAuthFrame2Struct(pMac, pBody,            frameLen, &rxAuthFrame)!=eSIR_SUCCESS ) ||            ( !isAuthValid(pMac, &rxAuthFrame,psessionEntry) )
( sirConvertAuthFrame2Struct(pMac, pBody,            frameLen, &rxAuthFrame)!=eSIR_SUCCESS )
sirConvertAuthFrame2Struct(pMac, pBody,            frameLen, &rxAuthFrame)!=eSIR_SUCCESS
sirConvertAuthFrame2Struct(pMac, pBody,            frameLen, &rxAuthFrame)
sirConvertAuthFrame2Struct
sirConvertAuthFrame2Struct
pMac
pMac
pBody
pBody
frameLen
frameLen
&rxAuthFrame
rxAuthFrame
rxAuthFrame
eSIR_SUCCESS
eSIR_SUCCESS
( !isAuthValid(pMac, &rxAuthFrame,psessionEntry) )
!isAuthValid(pMac, &rxAuthFrame,psessionEntry)
isAuthValid(pMac, &rxAuthFrame,psessionEntry)
isAuthValid
isAuthValid
pMac
pMac
&rxAuthFrame
rxAuthFrame
rxAuthFrame
psessionEntry
psessionEntry
{            PELOGE(limLog(pMac, LOGE,                   FL("failed to convert Auth Frame to structure or Auth is not valid "));)            return;        }
PELOGE(limLog(pMac, LOGE,                   FL("failed to convert Auth Frame to structure or Auth is not valid "));
)            return;
pRxAuthFrameBody = &rxAuthFrame;
pRxAuthFrameBody = &rxAuthFrame
pRxAuthFrameBody
pRxAuthFrameBody
&rxAuthFrame
rxAuthFrame
rxAuthFrame
PELOGW(limLog(pMac, LOGW,           FL("Received Auth frame with type=%d seqnum=%d, status=%d (%d)"),           (tANI_U32) pRxAuthFrameBody->authAlgoNumber,           (tANI_U32) pRxAuthFrameBody->authTransactionSeqNumber,           (tANI_U32) pRxAuthFrameBody->authStatusCode,(tANI_U32)pMac->lim.gLimNumPreAuthContexts);
)    switch (pRxAuthFrameBody->authTransactionSeqNumber)    {        case SIR_MAC_AUTH_FRAME_1:            // AuthFrame 1            pStaDs = dphLookupHashEntry(pMac, pHdr->sa,                    &assocId, &psessionEntry->dph.dphHashTable);            if (pStaDs)            {                tLimMlmDisassocReq      *pMlmDisassocReq = NULL;                tLimMlmDeauthReq        *pMlmDeauthReq = NULL;                tAniBool                 isConnected = eSIR_TRUE;                pMlmDisassocReq = pMac->lim.limDisassocDeauthCnfReq.pMlmDisassocReq;                if (pMlmDisassocReq &&                        (vos_mem_compare((tANI_U8 *) pHdr->sa,                                         (tANI_U8 *) &pMlmDisassocReq->peerMacAddr,                                          sizeof(tSirMacAddr))))                {                    PELOGE(limLog(pMac, LOGE, FL("TODO:Ack for disassoc "                                "frame is pending Issue delsta for "                                MAC_ADDRESS_STR),                                MAC_ADDR_ARRAY(pMlmDisassocReq->peerMacAddr));)                    limProcessDisassocAckTimeout(pMac);                    isConnected = eSIR_FALSE;                }                pMlmDeauthReq = pMac->lim.limDisassocDeauthCnfReq.pMlmDeauthReq;                if (pMlmDeauthReq &&                        (vos_mem_compare((tANI_U8 *) pHdr->sa,                                         (tANI_U8 *) &pMlmDeauthReq->peerMacAddr,                                         sizeof(tSirMacAddr))))                {                    PELOGE(limLog(pMac, LOGE, FL("TODO:Ack for deauth frame "                                "is pending Issue delsta for "                                MAC_ADDRESS_STR),                                MAC_ADDR_ARRAY(pMlmDeauthReq->peerMacAddr));)                    limProcessDeauthAckTimeout(pMac);                    isConnected = eSIR_FALSE;                }                /* pStaDS != NULL and isConnected = 1 means the STA is already                 * connected, But SAP received the Auth from that station.                 * For non PMF connection send Deauth frame as STA will retry                 * to connect back.                 *                 * For PMF connection the AP should not tear down or otherwise                 * modify the state of the existing association until the                 * SA-Query procedure determines that the original SA is                 * invalid.                 */                if (isConnected#ifdef WLAN_FEATURE_11W                    && !pStaDs->rmfEnabled#endif                                          )                {                    limLog(pMac, LOGE,                            FL("STA is already connected but received auth frame"                                "Send the Deauth and lim Delete Station Context"                                "(staId: %d, assocId: %d) "),                            pStaDs->staIndex, assocId);                    limSendDeauthMgmtFrame(pMac, eSIR_MAC_UNSPEC_FAILURE_REASON,                            (tANI_U8 *) pHdr->sa, psessionEntry, FALSE);                    limTriggerSTAdeletion(pMac, pStaDs, psessionEntry);                    return;                }            }            /// Check if there exists pre-auth context for this STA            pAuthNode = limSearchPreAuthList(pMac, pHdr->sa);            if (pAuthNode)            {                /// Pre-auth context exists for the STA                if (pHdr->fc.retry == 0 || pAuthNode->seqNum != currSeqNum)                {                    /**                     * STA is initiating brand-new Authentication                     * sequence after local Auth Response timeout.                     * Or STA retrying to transmit First Auth frame due to packet drop OTA                     * Delete Pre-auth node and fall through.                     */                    if(pAuthNode->fTimerStarted)                    {                        limDeactivateAndChangePerStaIdTimer(pMac,                                                    eLIM_AUTH_RSP_TIMER,                                                    pAuthNode->authNodeIdx);                    }                    PELOGE(limLog(pMac, LOGE, FL("STA is initiating brand-new Authentication ..."));)                    limDeletePreAuthNode(pMac,                                         pHdr->sa);                    /**                     *  SAP Mode:Disassociate the station and                     *  delete its entry if we have its entry                     *  already and received "auth" from the                     *  same station.                     */                    for (assocId = 0; assocId < psessionEntry->dph.dphHashTable.size; assocId++)// Softap dphHashTable.size = 8                    {                        pStaDs = dphGetHashEntry(pMac, assocId, &psessionEntry->dph.dphHashTable);                        if (NULL == pStaDs)                             continue;                        if (pStaDs->valid)                        {                             if (vos_mem_compare((tANI_U8 *) &pStaDs->staAddr,                                      (tANI_U8 *) &(pHdr->sa), (tANI_U8) (sizeof(tSirMacAddr))) )                                  break;                        }                        pStaDs = NULL;                    }                    if (NULL != pStaDs#ifdef WLAN_FEATURE_11W                        && !pStaDs->rmfEnabled#endif                       )                    {                        PELOGE(limLog(pMac, LOGE,                               FL("lim Delete Station Context (staId: %d, assocId: %d) "),                               pStaDs->staIndex, assocId);)                        limSendDeauthMgmtFrame(pMac,                               eSIR_MAC_UNSPEC_FAILURE_REASON, (tANI_U8 *) pAuthNode->peerMacAddr, psessionEntry, FALSE);                        limTriggerSTAdeletion(pMac, pStaDs, psessionEntry);                        return;                    }                }                else                {                    /*                     * This can happen when first authentication frame is received                     * but ACK lost at STA side, in this case 2nd auth frame is already                     * in transmission queue                     * */                    PELOGE(limLog(pMac, LOGE, FL("STA is initiating Authentication after ACK lost..."));)                    return;                }            }            if (wlan_cfgGetInt(pMac, WNI_CFG_MAX_NUM_PRE_AUTH,                          (tANI_U32 *) &maxNumPreAuth) != eSIR_SUCCESS)            {                /**                 * Could not get MaxNumPreAuth                 * from CFG. Log error.                 */                limLog(pMac, LOGP,                       FL("could not retrieve MaxNumPreAuth"));            }            if (pMac->lim.gLimNumPreAuthContexts == maxNumPreAuth)            {                PELOGE(limLog(pMac, LOGE, FL("Max number of preauth context reached"));)                /**                 * Maximum number of pre-auth contexts                 * reached. Send Authentication frame                 * with unspecified failure                 */                authFrame.authAlgoNumber =                pRxAuthFrameBody->authAlgoNumber;                authFrame.authTransactionSeqNumber =                pRxAuthFrameBody->authTransactionSeqNumber + 1;                authFrame.authStatusCode =                eSIR_MAC_UNSPEC_FAILURE_STATUS;                limSendAuthMgmtFrame(pMac, &authFrame,                                     pHdr->sa,                                     LIM_NO_WEP_IN_FC,psessionEntry);                return;            }            /// No Pre-auth context exists for the STA.            if (limIsAuthAlgoSupported(                                      pMac,                                      (tAniAuthType)                                      pRxAuthFrameBody->authAlgoNumber, psessionEntry))            {                switch (pRxAuthFrameBody->authAlgoNumber)                {                    case eSIR_OPEN_SYSTEM:                        PELOGW(limLog(pMac, LOGW, FL("=======> eSIR_OPEN_SYSTEM  ..."));)                        /// Create entry for this STA in pre-auth list                        pAuthNode = limAcquireFreePreAuthNode(pMac, &pMac->lim.gLimPreAuthTimerTable);                        if (pAuthNode == NULL)                        {                            // Log error                            limLog(pMac, LOGW,                                   FL("Max pre-auth nodes reached "));                            limPrintMacAddr(pMac, pHdr->sa, LOGW);                            return;                        }                        PELOG1(limLog(pMac, LOG1, FL("Alloc new data: %x peer "), pAuthNode);                        limPrintMacAddr(pMac, pHdr->sa, LOG1);)                        vos_mem_copy((tANI_U8 *) pAuthNode->peerMacAddr,                                      pHdr->sa,                                      sizeof(tSirMacAddr));                        pAuthNode->mlmState =                        eLIM_MLM_AUTHENTICATED_STATE;                        pAuthNode->authType = (tAniAuthType)                                              pRxAuthFrameBody->authAlgoNumber;                        pAuthNode->fSeen = 0;                        pAuthNode->fTimerStarted = 0;                        pAuthNode->seqNum = ((pHdr->seqControl.seqNumHi << 4) |                                                (pHdr->seqControl.seqNumLo));                        limAddPreAuthNode(pMac, pAuthNode);                        /**                         * Send Authenticaton frame with Success                         * status code.                         */                        authFrame.authAlgoNumber =                        pRxAuthFrameBody->authAlgoNumber;                        authFrame.authTransactionSeqNumber =                        pRxAuthFrameBody->authTransactionSeqNumber + 1;                        authFrame.authStatusCode = eSIR_MAC_SUCCESS_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        /// Send Auth indication to SME                        vos_mem_copy((tANI_U8 *) mlmAuthInd.peerMacAddr,                                     (tANI_U8 *) pHdr->sa,                                     sizeof(tSirMacAddr));                        mlmAuthInd.authType = (tAniAuthType)                                              pRxAuthFrameBody->authAlgoNumber;                        mlmAuthInd.sessionId = psessionEntry->smeSessionId;                        limPostSmeMessage(pMac,                                          LIM_MLM_AUTH_IND,                                          (tANI_U32 *) &mlmAuthInd);                        break;                    case eSIR_SHARED_KEY:                        PELOGW(limLog(pMac, LOGW, FL("=======> eSIR_SHARED_KEY  ..."));)                        if (LIM_IS_AP_ROLE(psessionEntry)) {                            val = psessionEntry->privacy;                        } else if (wlan_cfgGetInt(pMac, WNI_CFG_PRIVACY_ENABLED,                                      &val) != eSIR_SUCCESS) {                            /**                             * Could not get Privacy option                             * from CFG. Log error.                             */                            limLog(pMac, LOGP,                                   FL("could not retrieve Privacy option"));                        }                        cfgPrivacyOptImp = (tANI_U8)val;                        if (!cfgPrivacyOptImp)                        {                            // Log error                            PELOGE(limLog(pMac, LOGE,                                   FL("received Auth frame for unsupported auth algorithm %d "                                   MAC_ADDRESS_STR), pRxAuthFrameBody->authAlgoNumber,                                   MAC_ADDR_ARRAY(pHdr->sa));)                            /**                             * Authenticator does not have WEP                             * implemented.                             * Reject by sending Authentication frame                             * with Auth algorithm not supported status                             * code.                             */                            authFrame.authAlgoNumber =                            pRxAuthFrameBody->authAlgoNumber;                            authFrame.authTransactionSeqNumber =                            pRxAuthFrameBody->authTransactionSeqNumber + 1;                            authFrame.authStatusCode =                            eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS;                            limSendAuthMgmtFrame(                                                pMac, &authFrame,                                                pHdr->sa,                                                LIM_NO_WEP_IN_FC,psessionEntry);                            return;                        }                        else                        {                            // Create entry for this STA                            //in pre-auth list                            pAuthNode = limAcquireFreePreAuthNode(pMac, &pMac->lim.gLimPreAuthTimerTable);                            if (pAuthNode == NULL)                            {                                // Log error                                limLog(pMac, LOGW,                                       FL("Max pre-auth nodes reached "));                                limPrintMacAddr(pMac, pHdr->sa, LOGW);                                return;                            }                            vos_mem_copy((tANI_U8 *) pAuthNode->peerMacAddr,                                          pHdr->sa,                                          sizeof(tSirMacAddr));                            pAuthNode->mlmState =                            eLIM_MLM_WT_AUTH_FRAME3_STATE;                            pAuthNode->authType =                            (tAniAuthType)                            pRxAuthFrameBody->authAlgoNumber;                            pAuthNode->fSeen = 0;                            pAuthNode->fTimerStarted = 0;                            pAuthNode->seqNum =                                    ((pHdr->seqControl.seqNumHi << 4) |                                     (pHdr->seqControl.seqNumLo));                            limAddPreAuthNode(pMac, pAuthNode);                            PELOG1(limLog(pMac, LOG1, FL("Alloc new data: %x id %d peer "),                                          pAuthNode, pAuthNode->authNodeIdx);)                            PELOG1(limPrintMacAddr(pMac, pHdr->sa, LOG1);)                            /// Create and activate Auth Response timer                            if (tx_timer_change_context(&pAuthNode->timer, pAuthNode->authNodeIdx) != TX_SUCCESS)                            {                                /// Could not start Auth response timer.                                // Log error                                limLog(pMac, LOGP,                                   FL("Unable to chg context auth response timer for peer "));                                limPrintMacAddr(pMac, pHdr->sa, LOGP);                                /**                                 * Send Authenticaton frame with                                 * unspecified failure status code.                                 */                                authFrame.authAlgoNumber =                                        pRxAuthFrameBody->authAlgoNumber;                                authFrame.authTransactionSeqNumber =                                        pRxAuthFrameBody->authTransactionSeqNumber + 1;                                authFrame.authStatusCode =                                        eSIR_MAC_UNSPEC_FAILURE_STATUS;                                limSendAuthMgmtFrame(pMac, &authFrame,                                                     pHdr->sa,                                                     LIM_NO_WEP_IN_FC,psessionEntry);                                limDeletePreAuthNode(pMac, pHdr->sa);                                return;                            }                            limActivateAuthRspTimer(pMac, pAuthNode);                            pAuthNode->fTimerStarted = 1;                            // get random bytes and use as                            // challenge text. If it fails we already have random stack bytes.                            if( !VOS_IS_STATUS_SUCCESS( vos_rand_get_bytes( 0, (tANI_U8 *)challengeTextArray, SIR_MAC_AUTH_CHALLENGE_LENGTH ) ) )                            {                               limLog(pMac, LOGE,FL("Challenge text preparation failed in limProcessAuthFrame"));                            }                            pChallenge = pAuthNode->challengeText;                            vos_mem_copy(pChallenge,                                        (tANI_U8 *) challengeTextArray,                                         sizeof(challengeTextArray));                            /**                             * Sending Authenticaton frame with challenge.                             */                            authFrame.authAlgoNumber =                            pRxAuthFrameBody->authAlgoNumber;                            authFrame.authTransactionSeqNumber =                            pRxAuthFrameBody->authTransactionSeqNumber + 1;                            authFrame.authStatusCode =                            eSIR_MAC_SUCCESS_STATUS;                            authFrame.type   = SIR_MAC_CHALLENGE_TEXT_EID;                            authFrame.length = SIR_MAC_AUTH_CHALLENGE_LENGTH;                            vos_mem_copy(authFrame.challengeText,                                         pAuthNode->challengeText,                                         SIR_MAC_AUTH_CHALLENGE_LENGTH);                            limSendAuthMgmtFrame(                                                pMac, &authFrame,                                                pHdr->sa,                                                LIM_NO_WEP_IN_FC,psessionEntry);                        } // if (wlan_cfgGetInt(CFG_PRIVACY_OPTION_IMPLEMENTED))                        break;                    default:                        // Log error                       PELOGE( limLog(pMac, LOGE,                               FL("received Auth frame for unsupported auth algorithm %d "                               MAC_ADDRESS_STR), pRxAuthFrameBody->authAlgoNumber,                               MAC_ADDR_ARRAY(pHdr->sa));)                        /**                         * Responding party does not support the                         * authentication algorithm requested by                         * sending party.                         * Reject by sending Authentication frame                         * with auth algorithm not supported status code                         */                        authFrame.authAlgoNumber =                        pRxAuthFrameBody->authAlgoNumber;                        authFrame.authTransactionSeqNumber =                        pRxAuthFrameBody->authTransactionSeqNumber + 1;                        authFrame.authStatusCode =                        eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                } // end switch(pRxAuthFrameBody->authAlgoNumber)            } // if (limIsAuthAlgoSupported(pRxAuthFrameBody->authAlgoNumber))            else            {                // Log error                PELOGE(limLog(pMac, LOGE,                       FL("received Authentication frame for unsupported auth algorithm %d "                       MAC_ADDRESS_STR), pRxAuthFrameBody->authAlgoNumber,                       MAC_ADDR_ARRAY(pHdr->sa));)                /**                 * Responding party does not support the                 * authentication algorithm requested by sending party.                 * Reject Authentication with StatusCode=13.                 */                authFrame.authAlgoNumber =                pRxAuthFrameBody->authAlgoNumber;                authFrame.authTransactionSeqNumber =                pRxAuthFrameBody->authTransactionSeqNumber + 1;                authFrame.authStatusCode =                eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS;                limSendAuthMgmtFrame(pMac, &authFrame,                                     pHdr->sa,                                     LIM_NO_WEP_IN_FC,psessionEntry);                return;            } //end if (limIsAuthAlgoSupported(pRxAuthFrameBody->authAlgoNumber))            break;        case SIR_MAC_AUTH_FRAME_2:            // AuthFrame 2            if (psessionEntry->limMlmState != eLIM_MLM_WT_AUTH_FRAME2_STATE)            {#ifdef WLAN_FEATURE_VOWIFI_11R                /**                 * Check if a Reassociation is in progress and this is a                 * Pre-Auth frame                 */                if ((LIM_IS_STA_ROLE(psessionEntry) ||                     LIM_IS_BT_AMP_STA_ROLE(psessionEntry)) &&                    (psessionEntry->limSmeState == eLIM_SME_WT_REASSOC_STATE) &&                    (pRxAuthFrameBody->authStatusCode == eSIR_MAC_SUCCESS_STATUS) &&                    (psessionEntry->ftPEContext.pFTPreAuthReq != NULL) &&                    (vos_mem_compare(                        psessionEntry->ftPEContext.pFTPreAuthReq->preAuthbssId,                        pHdr->sa, sizeof(tSirMacAddr))))                {                    // Update the FTIEs in the saved auth response                    PELOGW(limLog(pMac, LOGW, FL("received another PreAuth frame2"                           " from peer " MAC_ADDRESS_STR" in Smestate %d"),                           MAC_ADDR_ARRAY(pHdr->sa), psessionEntry->limSmeState);)                    psessionEntry->ftPEContext.saved_auth_rsp_length = 0;                    if ((pBody != NULL) && (frameLen < MAX_FTIE_SIZE))                    {                        vos_mem_copy(psessionEntry->ftPEContext.saved_auth_rsp,                                     pBody, frameLen);                        psessionEntry->ftPEContext.saved_auth_rsp_length = frameLen;                    }                }                else#endif                {                    /**                     * Received Authentication frame2 in an unexpected state.                     * Log error and ignore the frame.                     */                    // Log error                    PELOG1(limLog(pMac, LOG1,                           FL("received Auth frame2 from peer in state %d, addr "),                           psessionEntry->limMlmState);)                    PELOG1(limPrintMacAddr(pMac, pHdr->sa, LOG1);)                }                return;            }            if ( !vos_mem_compare((tANI_U8 *) pHdr->sa,                                  (tANI_U8 *) &pMac->lim.gpLimMlmAuthReq->peerMacAddr,                                  sizeof(tSirMacAddr)) )            {                /**                 * Received Authentication frame from an entity                 * other than one request was initiated.                 * Wait until Authentication Failure Timeout.                 */                // Log error                PELOGW(limLog(pMac, LOGW,                       FL("received Auth frame2 from unexpected peer "                       MAC_ADDRESS_STR),                       MAC_ADDR_ARRAY(pHdr->sa));)                break;            }            if (pRxAuthFrameBody->authStatusCode ==                eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS)            {                /**                 * Interoperability workaround: Linksys WAP4400N is returning                 * wrong authType in OpenAuth response in case of                 * SharedKey AP configuration. Pretend we don't see that,                 * so upper layer can fallback to SharedKey authType,                 * and successfully connect to the AP.                 */                if (pRxAuthFrameBody->authAlgoNumber !=                    pMac->lim.gpLimMlmAuthReq->authType)                {                    pRxAuthFrameBody->authAlgoNumber =                    pMac->lim.gpLimMlmAuthReq->authType;                }            }            if (pRxAuthFrameBody->authAlgoNumber !=                pMac->lim.gpLimMlmAuthReq->authType)            {                /**                 * Received Authentication frame with an auth                 * algorithm other than one requested.                 * Wait until Authentication Failure Timeout.                 */                // Log error                PELOGW(limLog(pMac, LOGW,                       FL("received Auth frame2 for unexpected auth algo number %d "                       MAC_ADDRESS_STR), pRxAuthFrameBody->authAlgoNumber,                       MAC_ADDR_ARRAY(pHdr->sa));)                break;            }            if (pRxAuthFrameBody->authStatusCode ==                eSIR_MAC_SUCCESS_STATUS)            {                if (pRxAuthFrameBody->authAlgoNumber ==                    eSIR_OPEN_SYSTEM)                {                    psessionEntry->limCurrentAuthType = eSIR_OPEN_SYSTEM;                    pAuthNode = limAcquireFreePreAuthNode(pMac, &pMac->lim.gLimPreAuthTimerTable);                    if (pAuthNode == NULL)                    {                        // Log error                        limLog(pMac, LOGW,                               FL("Max pre-auth nodes reached "));                        limPrintMacAddr(pMac, pHdr->sa, LOGW);                        return;                    }                    PELOG1(limLog(pMac, LOG1, FL("Alloc new data: %x peer "), pAuthNode);)                    PELOG1(limPrintMacAddr(pMac, pHdr->sa, LOG1);)                    vos_mem_copy((tANI_U8 *) pAuthNode->peerMacAddr,                                 pMac->lim.gpLimMlmAuthReq->peerMacAddr,                                 sizeof(tSirMacAddr));                    pAuthNode->fTimerStarted = 0;                    pAuthNode->seqNum = ((pHdr->seqControl.seqNumHi << 4) |                                    (pHdr->seqControl.seqNumLo));                    pAuthNode->authType = pMac->lim.gpLimMlmAuthReq->authType;                    limAddPreAuthNode(pMac, pAuthNode);                    limRestoreFromAuthState(pMac, eSIR_SME_SUCCESS,                                            pRxAuthFrameBody->authStatusCode,psessionEntry);                } // if (pRxAuthFrameBody->authAlgoNumber == eSIR_OPEN_SYSTEM)                else                {                    // Shared key authentication                    if (LIM_IS_AP_ROLE(psessionEntry)) {                        val = psessionEntry->privacy;                    } else if (wlan_cfgGetInt(pMac, WNI_CFG_PRIVACY_ENABLED,                                  &val) != eSIR_SUCCESS) {                        /**                         * Could not get Privacy option                         * from CFG. Log error.                         */                        limLog(pMac, LOGP,                               FL("could not retrieve Privacy option"));                    }                    cfgPrivacyOptImp = (tANI_U8)val;                    if (!cfgPrivacyOptImp)                    {                        /**                         * Requesting STA does not have WEP implemented.                         * Reject with unsupported authentication algorithm                         * Status code and wait until auth failure timeout                         */                        // Log error                       PELOGE( limLog(pMac, LOGE,                               FL("received Auth frame from peer for unsupported auth algo %d "                               MAC_ADDRESS_STR), pRxAuthFrameBody->authAlgoNumber,                               MAC_ADDR_ARRAY(pHdr->sa));)                        authFrame.authAlgoNumber =                        pRxAuthFrameBody->authAlgoNumber;                        authFrame.authTransactionSeqNumber =                        pRxAuthFrameBody->authTransactionSeqNumber + 1;                        authFrame.authStatusCode =                        eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS;                        limSendAuthMgmtFrame(pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }                    else                    {                        if (pRxAuthFrameBody->type !=                            SIR_MAC_CHALLENGE_TEXT_EID)                        {                            // Log error                            PELOGE(limLog(pMac, LOGE,                                   FL("received Auth frame with invalid challenge text IE"));)                            return;                        }                        /**                         * Check if there exists a key mappping key                         * for the STA that sent Authentication frame                         */                        pKeyMapEntry = limLookUpKeyMappings(                                                           pHdr->sa);                        if (pKeyMapEntry)                        {                            if (pKeyMapEntry->key == NULL)                            {                                // Log error                                PELOGE(limLog(pMac, LOGE,                                       FL("received Auth frame from peer when key mapping key is NULL"                                       MAC_ADDRESS_STR),MAC_ADDR_ARRAY(pHdr->sa));)                                /**                                 * Key Mapping entry has null key.                                 * Send Auth frame with                                 * challenge failure status code                                 */                                authFrame.authAlgoNumber =                                pRxAuthFrameBody->authAlgoNumber;                                authFrame.authTransactionSeqNumber =                                pRxAuthFrameBody->authTransactionSeqNumber + 1;                                authFrame.authStatusCode =                                eSIR_MAC_CHALLENGE_FAILURE_STATUS;                                limSendAuthMgmtFrame(pMac, &authFrame,                                                     pHdr->sa,                                                     LIM_NO_WEP_IN_FC,psessionEntry);                                limRestoreFromAuthState(pMac, eSIR_SME_NO_KEY_MAPPING_KEY_FOR_PEER,                                                              eSIR_MAC_UNSPEC_FAILURE_REASON,psessionEntry);                                return;                            } // if (pKeyMapEntry->key == NULL)                            else                            {                                ((tpSirMacAuthFrameBody) plainBody)->authAlgoNumber =                                sirSwapU16ifNeeded(pRxAuthFrameBody->authAlgoNumber);                                ((tpSirMacAuthFrameBody) plainBody)->authTransactionSeqNumber =                                sirSwapU16ifNeeded((tANI_U16) (pRxAuthFrameBody->authTransactionSeqNumber + 1));                                ((tpSirMacAuthFrameBody) plainBody)->authStatusCode = eSIR_MAC_SUCCESS_STATUS;                                ((tpSirMacAuthFrameBody) plainBody)->type   = SIR_MAC_CHALLENGE_TEXT_EID;                                ((tpSirMacAuthFrameBody) plainBody)->length = SIR_MAC_AUTH_CHALLENGE_LENGTH;                                vos_mem_copy((tANI_U8 *) ((tpSirMacAuthFrameBody) plainBody)->challengeText,                                              pRxAuthFrameBody->challengeText,                                              SIR_MAC_AUTH_CHALLENGE_LENGTH);                                limEncryptAuthFrame(pMac, 0,                                                    pKeyMapEntry->key,                                                    plainBody,                                                    encrAuthFrame,key_length);                                psessionEntry->limMlmState = eLIM_MLM_WT_AUTH_FRAME4_STATE;                                MTRACE(macTrace(pMac, TRACE_CODE_MLM_STATE, psessionEntry->peSessionId, psessionEntry->limMlmState));                                limSendAuthMgmtFrame(pMac,                                                     (tpSirMacAuthFrameBody) encrAuthFrame,                                                     pHdr->sa,                                                     LIM_WEP_IN_FC,psessionEntry);                                break;                            } // end if (pKeyMapEntry->key == NULL)                        } // if (pKeyMapEntry)                        else                        {                            if (wlan_cfgGetInt(pMac, WNI_CFG_WEP_DEFAULT_KEYID,                                          &val) != eSIR_SUCCESS)                            {                                /**                                 * Could not get Default keyId                                 * from CFG. Log error.                                 */                                limLog(pMac, LOGP,                                       FL("could not retrieve Default keyId"));                            }                            keyId = (tANI_U8)val;                            val = SIR_MAC_KEY_LENGTH;                            if (LIM_IS_AP_ROLE(psessionEntry)) {                                tpSirKeys pKey;                                pKey =  &psessionEntry->WEPKeyMaterial[keyId].key[0];                                vos_mem_copy(defaultKey, pKey->key, pKey->keyLength);                            } else if (wlan_cfgGetStr(pMac,                                      (tANI_U16) (WNI_CFG_WEP_DEFAULT_KEY_1 + keyId),                                       defaultKey, &val) != eSIR_SUCCESS) {                                /// Could not get Default key from CFG.                                //Log error.                                limLog(pMac, LOGP,                                       FL("could not retrieve Default key"));                                authFrame.authAlgoNumber =                                pRxAuthFrameBody->authAlgoNumber;                                authFrame.authTransactionSeqNumber =                                pRxAuthFrameBody->authTransactionSeqNumber + 1;                                authFrame.authStatusCode =                                eSIR_MAC_CHALLENGE_FAILURE_STATUS;                                limSendAuthMgmtFrame(                                                    pMac, &authFrame,                                                    pHdr->sa,                                                    LIM_NO_WEP_IN_FC,psessionEntry);                                limRestoreFromAuthState(pMac, eSIR_SME_INVALID_WEP_DEFAULT_KEY,                                                              eSIR_MAC_UNSPEC_FAILURE_REASON,psessionEntry);                                break;                            }                                key_length=val;                                ((tpSirMacAuthFrameBody) plainBody)->authAlgoNumber =                                sirSwapU16ifNeeded(pRxAuthFrameBody->authAlgoNumber);                                ((tpSirMacAuthFrameBody) plainBody)->authTransactionSeqNumber =                                sirSwapU16ifNeeded((tANI_U16) (pRxAuthFrameBody->authTransactionSeqNumber + 1));                                ((tpSirMacAuthFrameBody) plainBody)->authStatusCode = eSIR_MAC_SUCCESS_STATUS;                                ((tpSirMacAuthFrameBody) plainBody)->type   = SIR_MAC_CHALLENGE_TEXT_EID;                                ((tpSirMacAuthFrameBody) plainBody)->length = SIR_MAC_AUTH_CHALLENGE_LENGTH;                                vos_mem_copy((tANI_U8 *) ((tpSirMacAuthFrameBody) plainBody)->challengeText,                                              pRxAuthFrameBody->challengeText,                                              SIR_MAC_AUTH_CHALLENGE_LENGTH);                                limEncryptAuthFrame(pMac, keyId,                                                    defaultKey,                                                    plainBody,                                                    encrAuthFrame,key_length);                                psessionEntry->limMlmState =                                eLIM_MLM_WT_AUTH_FRAME4_STATE;                                MTRACE(macTrace(pMac, TRACE_CODE_MLM_STATE, psessionEntry->peSessionId, psessionEntry->limMlmState));                                limSendAuthMgmtFrame(pMac,                                                     (tpSirMacAuthFrameBody) encrAuthFrame,                                                     pHdr->sa,                                                     LIM_WEP_IN_FC,psessionEntry);                                break;                        } // end if (pKeyMapEntry)                    } // end if (!wlan_cfgGetInt(CFG_PRIVACY_OPTION_IMPLEMENTED))                } // end if (pRxAuthFrameBody->authAlgoNumber == eSIR_OPEN_SYSTEM)            } // if (pRxAuthFrameBody->authStatusCode == eSIR_MAC_SUCCESS_STATUS)            else            {                /**                 * Authentication failure.                 * Return Auth confirm with received failure code to SME                 */                // Log error                PELOGE(limLog(pMac, LOGE,                       FL("received Auth frame from peer with failure code %d "                       MAC_ADDRESS_STR), pRxAuthFrameBody->authStatusCode,                       MAC_ADDR_ARRAY(pHdr->sa));)                limRestoreFromAuthState(pMac, eSIR_SME_AUTH_REFUSED,                                              pRxAuthFrameBody->authStatusCode,psessionEntry);            } // end if (pRxAuthFrameBody->authStatusCode == eSIR_MAC_SUCCESS_STATUS)            break;        case SIR_MAC_AUTH_FRAME_3:            // AuthFrame 3            if (pRxAuthFrameBody->authAlgoNumber != eSIR_SHARED_KEY)            {                // Log error                PELOGE(limLog(pMac, LOGE,                       FL("received Auth frame3 from peer with auth algo number %d "                       MAC_ADDRESS_STR), pRxAuthFrameBody->authAlgoNumber,                       MAC_ADDR_ARRAY(pHdr->sa));)                /**                 * Received Authentication frame3 with algorithm other than                 * Shared Key authentication type. Reject with Auth frame4                 * with 'out of sequence' status code.                 */                authFrame.authAlgoNumber = eSIR_SHARED_KEY;                authFrame.authTransactionSeqNumber =                SIR_MAC_AUTH_FRAME_4;                authFrame.authStatusCode =                eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                limSendAuthMgmtFrame(pMac, &authFrame,                                     pHdr->sa,                                     LIM_NO_WEP_IN_FC,psessionEntry);                return;            }            if (LIM_IS_AP_ROLE(psessionEntry) ||                LIM_IS_BT_AMP_AP_ROLE(psessionEntry) ||                LIM_IS_IBSS_ROLE(psessionEntry)) {                /**                 * Check if wep bit was set in FC. If not set,                 * reject with Authentication frame4 with                 * 'challenge failure' status code.                 */                if (!pHdr->fc.wep)                {                    // Log error                    PELOGE(limLog(pMac, LOGE,                           FL("received Auth frame3 from peer with no WEP bit set "MAC_ADDRESS_STR),                           MAC_ADDR_ARRAY(pHdr->sa));)                    /// WEP bit is not set in FC of Auth Frame3                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }                pAuthNode = limSearchPreAuthList(pMac,                                                pHdr->sa);                if (pAuthNode == NULL)                {                    // Log error                    PELOGE(limLog(pMac, LOGW,                           FL("received AuthFrame3 from peer that has no preauth context "                           MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                   /**                     * No 'pre-auth' context exists for                     * this STA that sent an Authentication                     * frame3.                     * Send Auth frame4 with 'out of sequence'                     * status code.                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }                if (pAuthNode->mlmState == eLIM_MLM_AUTH_RSP_TIMEOUT_STATE)                {                    // Log error                    limLog(pMac, LOGW,                           FL("auth response timer timedout for peer "                           MAC_ADDRESS_STR),MAC_ADDR_ARRAY(pHdr->sa));                    /**                     * Received Auth Frame3 after Auth Response timeout.                     * Reject by sending Auth Frame4 with                     * Auth respone timeout Status Code.                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_AUTH_RSP_TIMEOUT_STATUS;                    limSendAuthMgmtFrame(                                        pMac, &authFrame,                                        pHdr->sa,                                        LIM_NO_WEP_IN_FC,psessionEntry);                    /// Delete pre-auth context of STA                    limDeletePreAuthNode(pMac,                                         pHdr->sa);                    return;                } // end switch (pAuthNode->mlmState)                if (pRxAuthFrameBody->authStatusCode != eSIR_MAC_SUCCESS_STATUS)                {                    /**                     * Received Authenetication Frame 3 with status code                     * other than success. Wait until Auth response timeout                     * to delete STA context.                     */                    // Log error                    PELOGE(limLog(pMac, LOGE,                           FL("received Auth frame3 from peer with status code %d "                           MAC_ADDRESS_STR), pRxAuthFrameBody->authStatusCode,                           MAC_ADDR_ARRAY(pHdr->sa));)                    return;                }                /**                 * Check if received challenge text is same as one sent in                 * Authentication frame3                 */                if (vos_mem_compare(pRxAuthFrameBody->challengeText,                                    pAuthNode->challengeText,                                    SIR_MAC_AUTH_CHALLENGE_LENGTH))                {                    /// Challenge match. STA is autheticated !                    /// Delete Authentication response timer if running                    limDeactivateAndChangePerStaIdTimer(pMac,                                                        eLIM_AUTH_RSP_TIMER,                                                        pAuthNode->authNodeIdx);                    pAuthNode->fTimerStarted = 0;                    pAuthNode->mlmState = eLIM_MLM_AUTHENTICATED_STATE;                    /**                     * Send Authentication Frame4 with 'success' Status Code.                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode = eSIR_MAC_SUCCESS_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    /// Send Auth indication to SME                    vos_mem_copy((tANI_U8 *) mlmAuthInd.peerMacAddr,                                 (tANI_U8 *) pHdr->sa,                                  sizeof(tSirMacAddr));                    mlmAuthInd.authType = (tAniAuthType)                                          pRxAuthFrameBody->authAlgoNumber;                    mlmAuthInd.sessionId = psessionEntry->smeSessionId;                    limPostSmeMessage(pMac,                                      LIM_MLM_AUTH_IND,                                      (tANI_U32 *) &mlmAuthInd);                    break;                }                else                {                     // Log error                    PELOGE( limLog(pMac, LOGW,                                   FL("Challenge failure for peer "MAC_ADDRESS_STR),                                   MAC_ADDR_ARRAY(pHdr->sa));)                   /**                     * Challenge Failure.                     * Send Authentication frame4 with 'challenge failure'                     * status code and wait until Auth response timeout to                     * delete STA context.                     */                    authFrame.authAlgoNumber =                        pRxAuthFrameBody->authAlgoNumber;                    authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }            } // if (pMac->lim.gLimSystemRole == eLIM_AP_ROLE || ...            break;        case SIR_MAC_AUTH_FRAME_4:            // AuthFrame 4            if (psessionEntry->limMlmState != eLIM_MLM_WT_AUTH_FRAME4_STATE)            {                /**                 * Received Authentication frame4 in an unexpected state.                 * Log error and ignore the frame.                 */                // Log error                PELOG1(limLog(pMac, LOG1,                       FL("received unexpected Auth frame4 from peer in state %d, addr "                       MAC_ADDRESS_STR), psessionEntry->limMlmState,                       MAC_ADDR_ARRAY(pHdr->sa));)                return;            }            if (pRxAuthFrameBody->authAlgoNumber != eSIR_SHARED_KEY)            {                /**                 * Received Authentication frame4 with algorithm other than                 * Shared Key authentication type.                 * Wait until Auth failure timeout to report authentication                 * failure to SME.                 */                // Log error                PELOGE(limLog(pMac, LOGE,                       FL("received Auth frame4 from peer with invalid auth algo %d "                           MAC_ADDRESS_STR), pRxAuthFrameBody->authAlgoNumber,                       MAC_ADDR_ARRAY(pHdr->sa));)                return;            }            if ( !vos_mem_compare((tANI_U8 *) pHdr->sa,                                  (tANI_U8 *) &pMac->lim.gpLimMlmAuthReq->peerMacAddr,                                  sizeof(tSirMacAddr)) )            {                /**                 * Received Authentication frame from an entity                 * other than one to which request was initiated.                 * Wait until Authentication Failure Timeout.                 */                // Log error                PELOGE(limLog(pMac, LOGW,                       FL("received Auth frame4 from unexpected peer "                       MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                break;            }            if (pRxAuthFrameBody->authAlgoNumber !=                pMac->lim.gpLimMlmAuthReq->authType)            {                /**                 * Received Authentication frame with an auth algorithm                 * other than one requested.                 * Wait until Authentication Failure Timeout.                 */                PELOGE(limLog(pMac, LOGE,                       FL("received Authentication frame from peer with invalid auth seq number %d "                       MAC_ADDRESS_STR), pRxAuthFrameBody->authTransactionSeqNumber,                       MAC_ADDR_ARRAY(pHdr->sa));)                break;            }            if (pRxAuthFrameBody->authStatusCode ==                eSIR_MAC_SUCCESS_STATUS)            {                /**                 * Authentication Success !                 * Inform SME of same.                 */                psessionEntry->limCurrentAuthType = eSIR_SHARED_KEY;                pAuthNode = limAcquireFreePreAuthNode(pMac, &pMac->lim.gLimPreAuthTimerTable);                if (pAuthNode == NULL)                {                    // Log error                    limLog(pMac, LOGW,                           FL("Max pre-auth nodes reached "));                    limPrintMacAddr(pMac, pHdr->sa, LOGW);                    return;                }                PELOG1(limLog(pMac, LOG1, FL("Alloc new data: %x peer "), pAuthNode);                limPrintMacAddr(pMac, pHdr->sa, LOG1);)                vos_mem_copy((tANI_U8 *) pAuthNode->peerMacAddr,                             pMac->lim.gpLimMlmAuthReq->peerMacAddr,                             sizeof(tSirMacAddr));                pAuthNode->fTimerStarted = 0;                pAuthNode->authType = pMac->lim.gpLimMlmAuthReq->authType;                pAuthNode->seqNum = ((pHdr->seqControl.seqNumHi << 4) |                                (pHdr->seqControl.seqNumLo));                limAddPreAuthNode(pMac, pAuthNode);                limRestoreFromAuthState(pMac, eSIR_SME_SUCCESS,                                              pRxAuthFrameBody->authStatusCode,psessionEntry);            } // if (pRxAuthFrameBody->authStatusCode == eSIR_MAC_SUCCESS_STATUS)            else            {                /**                 * Authentication failure.                 * Return Auth confirm with received failure code to SME                 */                // Log error                PELOGE(limLog(pMac, LOGE, FL("Authentication failure from peer "                       MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                limRestoreFromAuthState(pMac, eSIR_SME_AUTH_REFUSED,                                              pRxAuthFrameBody->authStatusCode,psessionEntry);            } // end if (pRxAuthFrameBody->Status == 0)            break;        default:            /// Invalid Authentication Frame received. Ignore it.            // Log error            PELOGE(limLog(pMac, LOGE,                   FL("received Auth frame from peer with invalid auth seq "                   "number %d " MAC_ADDRESS_STR),                   pRxAuthFrameBody->authTransactionSeqNumber,                   MAC_ADDR_ARRAY(pHdr->sa));)            break;    }
-----joern-----
(540,1065,0)
(201,680,0)
(189,893,0)
(927,538,0)
(845,875,0)
(561,670,0)
(463,1102,0)
(116,123,0)
(46,532,0)
(4,268,0)
(73,1007,0)
(930,790,0)
(689,943,0)
(945,589,0)
(38,1025,0)
(438,878,0)
(755,12,0)
(960,1103,0)
(135,359,0)
(941,794,0)
(131,729,0)
(173,1111,0)
(868,736,0)
(66,550,0)
(1112,779,0)
(630,191,0)
(664,961,0)
(943,689,0)
(846,538,0)
(715,834,0)
(1097,528,0)
(127,224,0)
(113,5,0)
(1018,316,0)
(298,852,0)
(864,739,0)
(626,880,0)
(919,220,0)
(887,359,0)
(767,192,0)
(208,1060,0)
(846,304,0)
(773,915,0)
(197,665,0)
(475,827,0)
(1010,677,0)
(471,93,0)
(105,311,0)
(842,742,0)
(749,595,0)
(920,564,0)
(158,754,0)
(631,191,0)
(319,706,0)
(568,538,0)
(673,418,0)
(455,378,0)
(692,64,0)
(1093,1063,0)
(1021,1014,0)
(45,400,0)
(694,1109,0)
(832,321,0)
(482,125,0)
(447,400,0)
(232,138,0)
(69,538,0)
(136,739,0)
(705,28,0)
(618,1096,0)
(950,739,0)
(75,255,0)
(69,818,0)
(542,277,0)
(433,111,0)
(763,729,0)
(484,532,0)
(134,538,0)
(797,759,0)
(866,323,0)
(894,191,0)
(737,843,0)
(1022,532,0)
(877,399,0)
(1024,429,0)
(123,116,0)
(473,1024,0)
(859,952,0)
(499,577,0)
(123,910,0)
(544,395,0)
(463,1060,0)
(637,666,0)
(1012,349,0)
(117,397,0)
(360,976,0)
(852,654,0)
(1098,510,0)
(528,538,0)
(817,1025,0)
(639,421,0)
(34,1013,0)
(612,773,0)
(542,154,0)
(685,875,0)
(736,538,0)
(365,914,0)
(386,349,0)
(730,823,0)
(266,773,0)
(658,936,0)
(154,911,0)
(802,151,0)
(486,899,0)
(1019,151,0)
(290,480,0)
(622,463,0)
(6,704,0)
(661,538,0)
(970,614,0)
(302,538,0)
(311,1005,0)
(958,182,0)
(158,233,0)
(979,1029,0)
(536,116,0)
(96,204,0)
(158,475,0)
(1059,909,0)
(155,632,0)
(548,140,0)
(1090,154,0)
(860,1074,0)
(168,921,0)
(170,729,0)
(15,795,0)
(399,877,0)
(645,928,0)
(1106,391,0)
(527,571,0)
(353,202,0)
(796,563,0)
(522,871,0)
(350,809,0)
(125,482,0)
(410,830,0)
(909,1059,0)
(951,151,0)
(1083,790,0)
(638,702,0)
(18,138,0)
(158,694,0)
(589,1092,0)
(277,542,0)
(547,904,0)
(698,90,0)
(494,978,0)
(875,845,0)
(1067,994,0)
(579,681,0)
(683,753,0)
(633,667,0)
(1013,34,0)
(203,678,0)
(757,826,0)
(281,235,0)
(788,416,0)
(1096,1090,0)
(804,599,0)
(403,887,0)
(904,1003,0)
(175,268,0)
(1007,73,0)
(149,657,0)
(1090,560,0)
(414,323,0)
(114,100,0)
(449,723,0)
(961,787,0)
(552,863,0)
(511,994,0)
(753,683,0)
(648,15,0)
(238,555,0)
(874,1092,0)
(444,840,0)
(100,114,0)
(584,698,0)
(781,772,0)
(158,469,0)
(604,844,0)
(253,844,0)
(94,360,0)
(1035,442,0)
(1106,844,0)
(470,400,0)
(221,779,0)
(912,1040,0)
(178,530,0)
(794,745,0)
(269,265,0)
(316,538,0)
(800,898,0)
(270,449,0)
(1062,1089,0)
(942,987,0)
(1089,268,0)
(818,840,0)
(1114,646,0)
(385,538,0)
(192,434,0)
(790,930,0)
(837,42,0)
(249,193,0)
(194,895,0)
(283,702,0)
(571,527,0)
(288,1029,0)
(593,489,0)
(1009,193,0)
(609,1065,0)
(954,637,0)
(1054,503,0)
(555,319,0)
(1029,440,0)
(495,1096,0)
(494,702,0)
(462,324,0)
(632,155,0)
(191,60,0)
(293,31,0)
(794,684,0)
(289,832,0)
(1052,729,0)
(815,999,0)
(385,204,0)
(267,755,0)
(808,336,0)
(386,15,0)
(643,844,0)
(662,771,0)
(925,171,0)
(1033,428,0)
(895,316,0)
(813,543,0)
(783,833,0)
(479,547,0)
(30,713,0)
(268,175,0)
(552,861,0)
(607,188,0)
(419,538,0)
(418,673,0)
(773,266,0)
(263,1040,0)
(23,623,0)
(731,880,0)
(898,260,0)
(200,1036,0)
(441,140,0)
(4,673,0)
(319,555,0)
(569,634,0)
(1073,704,0)
(904,547,0)
(951,71,0)
(57,0,0)
(459,11,0)
(268,4,0)
(929,729,0)
(204,385,0)
(40,951,0)
(1078,439,0)
(638,904,0)
(397,117,0)
(843,642,0)
(1005,779,0)
(322,521,0)
(324,538,0)
(508,729,0)
(666,637,0)
(1074,312,0)
(695,1044,0)
(416,538,0)
(517,391,0)
(158,1067,0)
(239,77,0)
(1025,38,0)
(142,278,0)
(550,646,0)
(39,809,0)
(742,952,0)
(321,832,0)
(67,951,0)
(936,538,0)
(703,511,0)
(91,896,0)
(705,224,0)
(791,45,0)
(915,454,0)
(52,487,0)
(404,749,0)
(260,898,0)
(833,665,0)
(211,88,0)
(902,846,0)
(400,45,0)
(429,1024,0)
(164,377,0)
(360,94,0)
(655,729,0)
(376,276,0)
(489,115,0)
(22,836,0)
(997,729,0)
(279,690,0)
(359,1111,0)
(967,73,0)
(481,975,0)
(541,905,0)
(154,542,0)
(328,337,0)
(422,221,0)
(931,729,0)
(978,494,0)
(46,134,0)
(14,1024,0)
(1077,504,0)
(372,538,0)
(54,385,0)
(1085,150,0)
(684,302,0)
(302,684,0)
(453,370,0)
(450,202,0)
(749,634,0)
(11,459,0)
(301,424,0)
(551,971,0)
(13,154,0)
(63,755,0)
(953,212,0)
(7,721,0)
(193,64,0)
(367,5,0)
(436,276,0)
(48,1087,0)
(68,188,0)
(15,386,0)
(460,356,0)
(803,251,0)
(851,656,0)
(1096,618,0)
(784,845,0)
(646,550,0)
(45,538,0)
(329,1074,0)
(144,767,0)
(212,634,0)
(853,1014,0)
(798,861,0)
(855,1072,0)
(1008,311,0)
(448,538,0)
(71,951,0)
(849,538,0)
(590,756,0)
(497,696,0)
(554,498,0)
(732,779,0)
(311,1008,0)
(323,139,0)
(424,453,0)
(225,723,0)
(709,1102,0)
(679,840,0)
(291,935,0)
(1008,121,0)
(605,432,0)
(330,563,0)
(734,776,0)
(316,895,0)
(674,826,0)
(1015,1098,0)
(60,191,0)
(445,92,0)
(454,915,0)
(663,1070,0)
(601,1103,0)
(1016,750,0)
(861,552,0)
(863,552,0)
(668,927,0)
(821,991,0)
(287,994,0)
(976,360,0)
(59,532,0)
(625,234,0)
(412,778,0)
(547,479,0)
(550,538,0)
(1090,1096,0)
(480,290,0)
(659,712,0)
(899,532,0)
(93,532,0)
(216,398,0)
(1102,463,0)
(265,971,0)
(684,794,0)
(209,538,0)
(1042,665,0)
(971,265,0)
(948,431,0)
(24,425,0)
(610,208,0)
(567,502,0)
(858,967,0)
(158,61,0)
(723,225,0)
(158,918,0)
(939,0,0)
(315,618,0)
(64,692,0)
(673,4,0)
(790,915,0)
(904,638,0)
(193,249,0)
(456,732,0)
(452,705,0)
(754,559,0)
(665,538,0)
(388,278,0)
(614,252,0)
(62,767,0)
(983,73,0)
(345,354,0)
(395,569,0)
(73,967,0)
(845,838,0)
(586,370,0)
(158,126,0)
(698,538,0)
(844,604,0)
(188,476,0)
(724,100,0)
(139,425,0)
(401,846,0)
(251,776,0)
(28,705,0)
(312,1074,0)
(260,425,0)
(43,818,0)
(1003,904,0)
(543,813,0)
(792,480,0)
(413,9,0)
(642,9,0)
(836,538,0)
(245,543,0)
(242,411,0)
(158,461,0)
(745,794,0)
(89,713,0)
(346,287,0)
(90,698,0)
(100,724,0)
(134,46,0)
(217,221,0)
(359,887,0)
(368,1031,0)
(606,614,0)
(74,150,0)
(654,852,0)
(472,504,0)
(126,318,0)
(488,294,0)
(297,249,0)
(326,895,0)
(377,164,0)
(896,91,0)
(888,799,0)
(587,933,0)
(787,961,0)
(237,487,0)
(158,173,0)
(121,1008,0)
(718,729,0)
(16,160,0)
(665,833,0)
(724,921,0)
(706,319,0)
(1048,752,0)
(1092,589,0)
(696,969,0)
(895,326,0)
(320,81,0)
(507,400,0)
(878,438,0)
(818,69,0)
(521,1044,0)
(64,193,0)
(510,1098,0)
(844,1106,0)
(680,201,0)
(304,846,0)
(294,488,0)
(1072,235,0)
(268,1089,0)
(518,124,0)
(103,104,0)
(969,696,0)
(358,209,0)
(93,471,0)
(146,871,0)
(1058,553,0)
(224,705,0)
(807,255,0)
(795,15,0)
(713,30,0)
(158,16,0)
(805,854,0)
(390,247,0)
(505,1010,0)
(487,151,0)
(87,290,0)
(940,978,0)
(891,323,0)
(840,444,0)
(196,391,0)
(647,977,0)
(214,862,0)
(2,386,0)
(726,661,0)
(304,543,0)
(426,1107,0)
(1020,802,0)
(595,749,0)
(1102,538,0)
(820,787,0)
(42,837,0)
(769,905,0)
(437,933,0)
(723,449,0)
(751,597,0)
(543,304,0)
(990,677,0)
(391,1106,0)
(1004,123,0)
(840,818,0)
(560,729,0)
(996,312,0)
(702,494,0)
(1037,130,0)
(587,437,1)
(269,971,1)
(752,1048,1)
(654,852,1)
(787,820,1)
(47,480,1)
(1090,154,1)
(195,314,1)
(64,692,1)
(589,1092,1)
(698,538,1)
(193,249,1)
(582,504,1)
(790,915,1)
(886,1063,1)
(716,872,1)
(917,156,1)
(773,915,1)
(847,284,1)
(158,655,1)
(563,796,1)
(391,517,1)
(961,787,1)
(1040,263,1)
(749,595,1)
(751,32,1)
(864,136,1)
(158,475,1)
(224,127,1)
(255,75,1)
(951,151,1)
(1035,21,1)
(1070,663,1)
(150,74,1)
(409,1051,1)
(900,92,1)
(568,538,1)
(312,1074,1)
(158,763,1)
(218,466,1)
(220,919,1)
(1057,724,1)
(757,608,1)
(278,388,1)
(631,630,1)
(869,687,1)
(118,258,1)
(132,956,1)
(555,319,1)
(117,397,1)
(1099,987,1)
(158,173,1)
(304,846,1)
(235,281,1)
(323,139,1)
(353,450,1)
(793,995,1)
(558,650,1)
(210,59,1)
(221,217,1)
(185,346,1)
(1025,817,1)
(802,151,1)
(385,538,1)
(399,877,1)
(411,242,1)
(93,471,1)
(770,946,1)
(73,983,1)
(562,539,1)
(543,245,1)
(915,454,1)
(603,585,1)
(487,237,1)
(303,549,1)
(638,904,1)
(843,737,1)
(724,100,1)
(265,269,1)
(77,239,1)
(1049,30,1)
(622,1102,1)
(960,601,1)
(393,703,1)
(323,891,1)
(11,459,1)
(368,734,1)
(1096,618,1)
(105,1008,1)
(510,1098,1)
(142,443,1)
(514,79,1)
(855,839,1)
(928,645,1)
(15,648,1)
(234,625,1)
(293,529,1)
(147,27,1)
(713,89,1)
(228,556,1)
(427,678,1)
(158,461,1)
(158,61,1)
(914,365,1)
(398,216,1)
(309,336,1)
(4,268,1)
(372,538,1)
(663,735,1)
(1103,960,1)
(581,806,1)
(152,577,1)
(661,538,1)
(75,807,1)
(1044,695,1)
(795,15,1)
(904,547,1)
(281,1072,1)
(862,214,1)
(217,422,1)
(392,656,1)
(1092,874,1)
(927,538,1)
(1042,197,1)
(1020,64,1)
(983,967,1)
(996,1074,1)
(541,321,1)
(336,808,1)
(815,230,1)
(699,568,1)
(826,674,1)
(306,49,1)
(260,425,1)
(844,1106,1)
(1074,860,1)
(746,928,1)
(679,818,1)
(771,662,1)
(696,497,1)
(806,1066,1)
(30,713,1)
(942,93,1)
(905,769,1)
(599,804,1)
(227,980,1)
(431,948,1)
(512,1043,1)
(394,372,1)
(949,235,1)
(871,522,1)
(64,193,1)
(405,989,1)
(5,367,1)
(249,297,1)
(1067,511,1)
(360,94,1)
(204,96,1)
(550,538,1)
(40,71,1)
(202,353,1)
(741,498,1)
(885,34,1)
(745,794,1)
(312,996,1)
(441,548,1)
(62,144,1)
(665,1042,1)
(355,739,1)
(448,81,1)
(329,276,1)
(263,912,1)
(1058,638,1)
(515,299,1)
(280,361,1)
(920,845,1)
(243,823,1)
(552,863,1)
(1098,1015,1)
(646,1114,1)
(104,103,1)
(462,229,1)
(347,611,1)
(571,527,1)
(988,453,1)
(504,472,1)
(767,62,1)
(721,7,1)
(232,1014,1)
(890,41,1)
(753,683,1)
(573,519,1)
(884,886,1)
(282,357,1)
(956,925,1)
(183,657,1)
(708,800,1)
(705,452,1)
(498,554,1)
(154,542,1)
(543,304,1)
(575,377,1)
(1097,673,1)
(941,684,1)
(22,201,1)
(542,277,1)
(1021,853,1)
(794,941,1)
(1002,357,1)
(536,1004,1)
(378,455,1)
(316,538,1)
(470,378,1)
(848,202,1)
(376,436,1)
(650,809,1)
(385,54,1)
(938,913,1)
(785,826,1)
(4,673,1)
(69,538,1)
(191,631,1)
(279,830,1)
(632,155,1)
(814,42,1)
(311,105,1)
(419,538,1)
(594,1103,1)
(882,382,1)
(965,458,1)
(447,507,1)
(29,264,1)
(840,679,1)
(625,33,1)
(88,211,1)
(256,538,1)
(158,233,1)
(730,1056,1)
(666,637,1)
(1008,121,1)
(204,385,1)
(1064,1025,1)
(245,304,1)
(468,393,1)
(824,255,1)
(295,608,1)
(836,538,1)
(1061,653,1)
(846,538,1)
(703,287,1)
(661,726,1)
(985,442,1)
(809,39,1)
(1009,249,1)
(1091,664,1)
(607,68,1)
(618,315,1)
(720,1032,1)
(600,916,1)
(400,447,1)
(506,47,1)
(63,267,1)
(268,1089,1)
(844,604,1)
(224,705,1)
(535,571,1)
(45,538,1)
(354,345,1)
(158,764,1)
(714,231,1)
(951,40,1)
(895,326,1)
(158,918,1)
(964,871,1)
(998,325,1)
(159,962,1)
(268,175,1)
(889,790,1)
(896,91,1)
(1014,1021,1)
(18,232,1)
(1096,1090,1)
(1102,538,1)
(438,878,1)
(895,316,1)
(825,257,1)
(933,587,1)
(384,775,1)
(13,154,1)
(134,538,1)
(667,633,1)
(1086,354,1)
(818,69,1)
(36,690,1)
(1106,391,1)
(209,538,1)
(592,789,1)
(979,288,1)
(859,742,1)
(193,1009,1)
(176,947,1)
(951,71,1)
(265,971,1)
(934,1031,1)
(451,427,1)
(233,400,1)
(763,837,1)
(1048,621,1)
(407,756,1)
(1076,111,1)
(463,1102,1)
(267,712,1)
(43,69,1)
(266,773,1)
(49,115,1)
(530,178,1)
(288,11,1)
(41,208,1)
(158,126,1)
(936,538,1)
(835,366,1)
(1107,426,1)
(236,1082,1)
(909,1059,1)
(813,543,1)
(158,694,1)
(125,482,1)
(386,2,1)
(127,705,1)
(140,441,1)
(123,116,1)
(138,18,1)
(388,142,1)
(904,1003,1)
(555,238,1)
(901,646,1)
(15,386,1)
(139,425,1)
(880,626,1)
(480,290,1)
(990,1010,1)
(1114,550,1)
(696,969,1)
(225,723,1)
(677,990,1)
(386,349,1)
(310,416,1)
(316,1018,1)
(437,580,1)
(1075,553,1)
(971,551,1)
(294,488,1)
(302,538,1)
(162,259,1)
(153,209,1)
(460,501,1)
(46,134,1)
(723,449,1)
(927,668,1)
(860,329,1)
(630,60,1)
(158,754,1)
(589,945,1)
(887,403,1)
(238,319,1)
(146,632,1)
(846,902,1)
(845,875,1)
(298,374,1)
(20,467,1)
(1093,1023,1)
(1025,38,1)
(773,612,1)
(342,952,1)
(765,620,1)
(116,536,1)
(74,1085,1)
(367,113,1)
(464,177,1)
(201,680,1)
(976,360,1)
(507,45,1)
(200,872,1)
(796,330,1)
(34,1013,1)
(695,521,1)
(276,376,1)
(834,715,1)
(100,114,1)
(356,460,1)
(173,359,1)
(61,833,1)
(319,706,1)
(772,781,1)
(102,903,1)
(426,638,1)
(499,1007,1)
(727,547,1)
(705,28,1)
(783,665,1)
(656,851,1)
(861,552,1)
(96,385,1)
(977,647,1)
(626,731,1)
(843,642,1)
(678,203,1)
(840,818,1)
(930,790,1)
(648,386,1)
(576,951,1)
(849,538,1)
(212,953,1)
(681,579,1)
(1010,505,1)
(1007,73,1)
(755,63,1)
(352,119,1)
(670,561,1)
(853,502,1)
(684,302,1)
(509,602,1)
(0,939,1)
(893,189,1)
(685,784,1)
(975,481,1)
(517,196,1)
(769,541,1)
(389,256,1)
(473,14,1)
(315,495,1)
(158,469,1)
(528,538,1)
(1024,473,1)
(158,16,1)
(187,927,1)
(1,411,1)
(790,1083,1)
(768,988,1)
(945,1092,1)
(759,797,1)
(841,1087,1)
(1080,180,1)
(854,805,1)
(1036,200,1)
(70,327,1)
(90,698,1)
(130,1037,1)
(719,887,1)
(898,260,1)
(837,42,1)
(831,811,1)
(749,404,1)
(522,146,1)
(936,658,1)
(673,418,1)
(617,615,1)
(638,702,1)
(158,1067,1)
(643,253,1)
(702,494,1)
(400,45,1)
(590,429,1)
(148,143,1)
(1054,915,1)
(782,26,1)
(1089,1062,1)
(487,151,1)
(736,538,1)
(952,859,1)
(697,11,1)
(991,821,1)
(377,164,1)
(833,665,1)
(87,792,1)
(311,1008,1)
(292,181,1)
(980,191,1)
(359,887,1)
(416,538,1)
(334,321,1)
(973,714,1)
(675,195,1)
(978,940,1)
(73,967,1)
(646,550,1)
(665,538,1)
(792,430,1)
(1090,560,1)
(689,943,1)
(817,38,1)
(494,978,1)
(1000,153,1)
(237,52,1)
(868,864,1)
(324,538,1)
(870,922,1)
(321,832,1)
(433,349,1)
(637,954,1)
(341,324,1)
(72,986,1)
(935,291,1)
(429,1024,1)
(39,350,1)
(472,1077,1)
(728,1047,1)
(537,13,1)
(444,840,1)
(439,1078,1)
(664,787,1)
(794,684,1)
(644,369,1)
(111,433,1)
(264,837,1)
(547,479,1)
(1063,1093,1)
(191,60,1)
(161,448,1)
(920,546,1)
(818,43,1)
(832,289,1)
(283,702,1)
(7,765,1)
(401,670,1)
(902,401,1)
(674,757,1)
(748,856,2)
(665,538,2)
(493,725,2)
(724,100,2)
(933,150,2)
(1066,678,2)
(359,887,2)
(980,90,2)
(936,538,2)
(543,258,2)
(573,789,2)
(158,126,2)
(11,150,2)
(671,258,2)
(38,935,2)
(4,268,2)
(605,321,2)
(552,863,2)
(59,789,2)
(719,321,2)
(399,90,2)
(836,538,2)
(952,678,2)
(649,789,2)
(745,794,2)
(543,304,2)
(895,326,2)
(949,678,2)
(218,321,2)
(330,258,2)
(696,969,2)
(158,469,2)
(1106,391,2)
(158,694,2)
(397,150,2)
(99,258,2)
(796,258,2)
(987,789,2)
(176,1036,2)
(1045,321,2)
(154,542,2)
(15,386,2)
(560,443,2)
(909,1059,2)
(178,258,2)
(1084,725,2)
(264,837,2)
(791,292,2)
(507,292,2)
(343,90,2)
(123,116,2)
(4,673,2)
(915,454,2)
(750,321,2)
(30,713,2)
(818,69,2)
(658,258,2)
(288,11,2)
(684,302,2)
(542,277,2)
(390,725,2)
(287,725,2)
(581,678,2)
(146,632,2)
(749,595,2)
(859,678,2)
(870,258,2)
(363,27,2)
(852,34,2)
(982,150,2)
(1107,638,2)
(798,578,2)
(571,527,2)
(666,637,2)
(654,34,2)
(336,930,2)
(714,231,2)
(947,1036,2)
(843,642,2)
(356,90,2)
(503,90,2)
(898,260,2)
(1029,11,2)
(806,678,2)
(1086,321,2)
(312,1074,2)
(245,258,2)
(942,789,2)
(1002,357,2)
(210,789,2)
(547,479,2)
(372,789,2)
(387,837,2)
(201,680,2)
(885,34,2)
(454,90,2)
(471,789,2)
(324,538,2)
(185,725,2)
(794,684,2)
(602,258,2)
(572,725,2)
(1007,73,2)
(927,538,2)
(118,258,2)
(316,77,2)
(384,775,2)
(180,90,2)
(388,443,2)
(869,678,2)
(332,77,2)
(795,15,2)
(657,321,2)
(743,578,2)
(552,578,2)
(1114,725,2)
(571,725,2)
(359,321,2)
(895,316,2)
(836,321,2)
(555,319,2)
(1047,789,2)
(961,258,2)
(813,258,2)
(412,292,2)
(1106,11,2)
(844,11,2)
(638,904,2)
(715,872,2)
(48,77,2)
(763,837,2)
(69,90,2)
(145,678,2)
(13,154,2)
(944,856,2)
(1041,321,2)
(43,90,2)
(66,725,2)
(498,321,2)
(563,258,2)
(1054,90,2)
(787,258,2)
(172,90,2)
(383,975,2)
(633,11,2)
(1019,357,2)
(191,60,2)
(486,789,2)
(227,90,2)
(391,11,2)
(829,150,2)
(1077,77,2)
(83,856,2)
(156,725,2)
(766,725,2)
(741,321,2)
(828,725,2)
(1080,90,2)
(833,665,2)
(1018,77,2)
(149,321,2)
(468,725,2)
(326,77,2)
(839,678,2)
(773,915,2)
(394,789,2)
(964,632,2)
(826,608,2)
(204,385,2)
(807,258,2)
(494,978,2)
(772,608,2)
(1096,618,2)
(951,151,2)
(323,139,2)
(317,258,2)
(1055,789,2)
(100,114,2)
(762,321,2)
(158,461,2)
(564,578,2)
(271,725,2)
(951,71,2)
(292,872,2)
(193,249,2)
(930,790,2)
(302,538,2)
(228,258,2)
(265,971,2)
(268,175,2)
(693,321,2)
(755,578,2)
(64,692,2)
(589,1092,2)
(158,754,2)
(122,357,2)
(769,321,2)
(63,578,2)
(374,34,2)
(1091,258,2)
(579,909,2)
(723,449,2)
(699,725,2)
(668,789,2)
(682,725,2)
(849,443,2)
(694,90,2)
(34,443,2)
(480,290,2)
(27,292,2)
(147,27,2)
(629,578,2)
(158,475,2)
(209,538,2)
(777,725,2)
(22,321,2)
(846,538,2)
(863,578,2)
(117,150,2)
(103,27,2)
(158,173,2)
(139,425,2)
(174,150,2)
(850,1075,2)
(785,826,2)
(992,258,2)
(556,258,2)
(446,150,2)
(835,725,2)
(522,632,2)
(561,258,2)
(1025,935,2)
(818,90,2)
(920,578,2)
(702,494,2)
(861,552,2)
(260,425,2)
(1064,935,2)
(946,725,2)
(844,604,2)
(617,90,2)
(670,258,2)
(841,77,2)
(991,789,2)
(574,357,2)
(416,538,2)
(255,258,2)
(681,909,2)
(259,725,2)
(535,725,2)
(801,725,2)
(877,90,2)
(821,789,2)
(814,42,2)
(187,789,2)
(151,357,2)
(659,578,2)
(674,608,2)
(224,705,2)
(93,471,2)
(1028,578,2)
(924,258,2)
(1110,77,2)
(392,725,2)
(816,443,2)
(45,538,2)
(615,90,2)
(998,443,2)
(158,233,2)
(225,723,2)
(488,725,2)
(82,935,2)
(411,526,2)
(587,150,2)
(770,725,2)
(846,258,2)
(855,678,2)
(753,683,2)
(104,27,2)
(808,930,2)
(396,258,2)
(742,678,2)
(157,578,2)
(728,789,2)
(817,935,2)
(142,443,2)
(165,13,2)
(470,292,2)
(861,578,2)
(385,789,2)
(134,538,2)
(204,789,2)
(54,789,2)
(447,292,2)
(824,258,2)
(580,150,2)
(316,538,2)
(712,578,2)
(460,90,2)
(813,543,2)
(95,11,2)
(34,1013,2)
(158,918,2)
(196,11,2)
(966,725,2)
(377,164,2)
(705,28,2)
(837,42,2)
(1090,560,2)
(936,258,2)
(372,538,2)
(11,459,2)
(419,538,2)
(915,90,2)
(189,90,2)
(294,725,2)
(233,292,2)
(646,550,2)
(688,789,2)
(291,632,2)
(399,877,2)
(169,578,2)
(775,34,2)
(158,61,2)
(45,292,2)
(810,789,2)
(1068,292,2)
(325,443,2)
(1026,789,2)
(102,1075,2)
(484,789,2)
(842,678,2)
(200,872,2)
(247,725,2)
(896,91,2)
(889,790,2)
(266,773,2)
(661,538,2)
(466,321,2)
(126,872,2)
(219,258,2)
(17,1075,2)
(235,678,2)
(716,872,2)
(409,725,2)
(598,638,2)
(917,725,2)
(851,725,2)
(360,94,2)
(656,725,2)
(1049,30,2)
(487,151,2)
(429,1024,2)
(554,321,2)
(400,292,2)
(687,678,2)
(519,789,2)
(650,292,2)
(183,321,2)
(281,678,2)
(781,608,2)
(222,443,2)
(346,725,2)
(509,258,2)
(959,443,2)
(298,34,2)
(638,702,2)
(125,482,2)
(935,632,2)
(664,258,2)
(1016,321,2)
(73,967,2)
(689,725,2)
(432,321,2)
(240,678,2)
(550,538,2)
(646,725,2)
(423,725,2)
(1087,77,2)
(537,13,2)
(582,77,2)
(304,258,2)
(403,321,2)
(1008,121,2)
(75,258,2)
(526,443,2)
(905,321,2)
(253,11,2)
(304,846,2)
(300,1032,2)
(393,725,2)
(158,16,2)
(703,725,2)
(223,443,2)
(643,11,2)
(1069,678,2)
(283,702,2)
(455,292,2)
(604,11,2)
(904,1003,2)
(427,678,2)
(845,875,2)
(378,292,2)
(512,872,2)
(444,90,2)
(802,151,2)
(510,1098,2)
(90,698,2)
(135,321,2)
(501,90,2)
(973,231,2)
(267,578,2)
(758,321,2)
(908,578,2)
(541,321,2)
(451,678,2)
(568,538,2)
(242,526,2)
(437,150,2)
(1101,231,2)
(345,321,2)
(840,90,2)
(558,292,2)
(871,632,2)
(401,258,2)
(1090,154,2)
(1099,789,2)
(632,155,2)
(724,357,2)
(697,11,2)
(56,725,2)
(295,608,2)
(903,1075,2)
(46,134,2)
(849,538,2)
(337,578,2)
(385,538,2)
(907,909,2)
(482,27,2)
(1043,872,2)
(757,608,2)
(667,11,2)
(39,292,2)
(201,321,2)
(80,150,2)
(895,77,2)
(278,443,2)
(93,789,2)
(307,930,2)
(957,725,2)
(84,578,2)
(381,231,2)
(443,11,2)
(12,578,2)
(406,258,2)
(673,418,2)
(592,789,2)
(927,789,2)
(340,909,2)
(904,547,2)
(162,725,2)
(366,725,2)
(1105,34,2)
(919,935,2)
(100,357,2)
(778,292,2)
(334,321,2)
(400,45,2)
(321,832,2)
(96,789,2)
(117,397,2)
(328,578,2)
(46,789,2)
(628,321,2)
(511,725,2)
(167,258,2)
(173,321,2)
(354,321,2)
(386,349,2)
(16,258,2)
(790,915,2)
(282,357,2)
(981,725,2)
(220,935,2)
(1072,678,2)
(679,90,2)
(504,77,2)
(319,706,2)
(887,321,2)
(1013,443,2)
(528,538,2)
(809,292,2)
(125,27,2)
(339,725,2)
(961,787,2)
(199,789,2)
(213,321,2)
(64,193,2)
(463,1102,2)
(177,27,2)
(190,11,2)
(181,872,2)
(465,321,2)
(897,1036,2)
(1057,357,2)
(472,77,2)
(844,1106,2)
(698,538,2)
(550,725,2)
(1036,872,2)
(1096,1090,2)
(820,258,2)
(1067,725,2)
(1102,538,2)
(350,292,2)
(901,725,2)
(725,578,2)
(760,27,2)
(438,878,2)
(530,258,2)
(309,930,2)
(268,1089,2)
(457,975,2)
(1108,321,2)
(311,1008,2)
(636,678,2)
(568,725,2)
(464,27,2)
(1051,725,2)
(608,90,2)
(250,258,2)
(158,1067,2)
(380,13,2)
(165,4,2)
(417,578,2)
(69,538,2)
(899,789,2)
(1025,38,2)
(426,638,2)
(893,90,2)
(120,258,2)
(533,30,2)
(444,840,2)
(525,321,2)
(517,11,2)
(707,909,2)
(654,852,2)
(834,872,2)
(979,11,2)
(736,538,2)
(976,360,2)
(1,526,2)
(689,943,2)
(840,818,2)
(134,789,2)
(527,725,2)
(342,678,2)
(1076,111,2)
(972,725,2)
(194,77,2)
(29,837,2)
(686,725,2)
(380,4,2)
(294,488,2)
(902,258,2)
(922,258,2)
(1027,789,2)
-----------------------------------
(0,limPrintMacAddr(pMac, pHdr->sa, LOGP)
(1,eSIR_SHARED_KEY)
(2,keyId)
(3,authFrame)
(4,vos_mem_compare((tANI_U8 *)
(5,authFrame.authAlgoNumber)
(6,if (decryptResult == LIM_DECRYPT_ICV_FAIL)
(7,"Restore default failure timeout")
(8,pStaDs)
(9,)
(10,authTransactionSeqNumber)
(11,(sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,\n\\n                         &rxAuthFrame)
(12,authFrame.authStatusCode =\n\\n                        eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS)
(13,NULL == pStaDs)
(14,pRxAuthFrameBody)
(15,psessionEntry->WEPKeyMaterial[keyId].key)
(16,return;)
(17,sa)
(18,authAlgoNumber)
(19,authFrame)
(20,sa)
(21,authFrame.authTransactionSeqNumber =\n\\n                    SIR_MAC_AUTH_FRAME_4)
(22,pHdr)
(23,pRxAuthFrameBody)
(24,val)
(25,)
(26,(tpSirMacAuthFrameBody)
(27,pAuthNode == NULL)
(28,tpSirMacAuthFrameBody)
(29,fc)
(30,pRxAuthFrameBody->type !=\n\\n                            SIR_MAC_CHALLENGE_TEXT_EID)
(31,limSendDeauthMgmtFrame( pMac, eSIR_MAC_MIC_FAILURE_REASON,\n\\n                                    pHdr->sa, psessionEntry, FALSE )
(32,pAuthNode)
(33,LOGE)
(34,psessionEntry->limMlmState != eLIM_MLM_WT_AUTH_FRAME2_STATE)
(35,tANI_U32)
(36,eSIR_MAC_SUCCESS_STATUS)
(37,if (LIM_IS_AP_ROLE(psessionEntry)
(38,psessionEntry->ftPEContext)
(39,SIR_MAC_AUTH_FRAME_4)
(40,pAuthNode)
(41,authFrame)
(42,LIM_IS_AP_ROLE(psessionEntry)
(43,seqNumHi)
(44,pMlmDeauthReq)
(45,pHdr->sa)
(46,limPrintMacAddr(pMac, pHdr->sa, LOG1)
(47,pChallenge)
(48,authFrame)
(49,authFrame)
(50,"Unable to chg context auth response timer for peer ")
(51,eSIR_MAC_UNSPEC_FAILURE_REASON)
(52,pAuthNode)
(53,tANI_U8 *)
(54,seqControl)
(55,pRxAuthFrameBody)
(56,pHdr)
(57,pMac)
(58,frameLen-8)
(59,pAuthNode->authType = pMac->lim.gpLimMlmAuthReq->authType)
(60,psessionEntry->defaultAuthFailureTimeout)
(61,return;)
(62,authTransactionSeqNumber)
(63,authStatusCode)
(64,vos_mem_copy((tANI_U8 *)
(65,pRxAuthFrameBody)
(66,pHdr)
(67,LOG1)
(68,pMac)
(69,pHdr->seqControl)
(70,pHdr)
(71,FL("Alloc new data: %x peer ")
(72,sa)
(73,pRxAuthFrameBody->authTransactionSeqNumber + 1)
(74,LIM_DECRYPT_ICV_FAIL)
(75,fSeen)
(76,authTransactionSeqNumber)
(77,pAuthNode == NULL)
(78,(tANI_U8 *)
(79,authFrame)
(80,authFrame)
(81,currSeqNum = 0)
(82,pHdr)
(83,gpLimMlmAuthReq)
(84,authFrame.authAlgoNumber =\n\\n                        pRxAuthFrameBody->authAlgoNumber)
(85,pKey)
(86,)
(87,pAuthNode)
(88,isAuthValid(pMac, &rxAuthFrame,psessionEntry)
(89,type)
(90,limIsGroupAddr(pHdr->sa)
(91,psessionEntry->WEPKeyMaterial[keyId].key[0])
(92,authFrame.authStatusCode)
(93,vos_mem_copy((tANI_U8 *)
(94,pMac->lim)
(95,authAlgoNumber)
(96,seqNumHi)
(97,tANI_U8 *)
(98,LIM_NO_WEP_IN_FC)
(99,pMac)
(100,(tANI_U8)
(101,if (pAuthNode == NULL)
(102,pMlmDeauthReq)
(103,mlmState)
(104,pAuthNode->mlmState)
(105,length)
(106,authAlgoNumber)
(107,sa)
(108,authAlgoNumber)
(109,pMac)
(110,authFrame.authStatusCode)
(111,LIM_IS_STA_ROLE(psessionEntry)
(112,pAuthNode)
(113,authFrame)
(114,tANI_U8)
(115,authFrame.authAlgoNumber = eSIR_SHARED_KEY)
(116,FL("received Authentication frame with no body from ")
(117,sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,\n\\n                         &rxAuthFrame)
(118,pMac)
(119,LIM_NO_WEP_IN_FC)
(120,fTimerStarted)
(121,tpSirMacAuthFrameBody)
(122,eSIR_OPEN_SYSTEM)
(123,limLog(pMac, LOGE,\n\\n               FL("received Authentication frame with no body from ")
(124,psessionEntry->WEPKeyMaterial)
(125,limDeactivateAndChangePerStaIdTimer(pMac,\n\\n                                                    eLIM_AUTH_RSP_TIMER,\n\\n                                                    pAuthNode->authNodeIdx)
(126,return;)
(127,authTransactionSeqNumber)
(128,FL("failed to convert Auth Frame to structure or Auth is not valid ")
(129,encrAuthFrame)
(130,pMac->lim.gpLimMlmAuthReq)
(131,if (pMac->lim.gLimNumPreAuthContexts == maxNumPreAuth)
(132,peSessionId)
(133,tANI_U8 *)
(134,pHdr->sa)
(135,LIM_NO_WEP_IN_FC)
(136,pMac)
(137,TRACE_CODE_MLM_STATE)
(138,pRxAuthFrameBody->authAlgoNumber)
(139,key_length=val)
(140,pRxAuthFrameBody->challengeText)
(141,isConnected = eSIR_TRUE)
(142,pRxAuthFrameBody)
(143,pMac)
(144,authFrame)
(145,LOGP)
(146,psessionEntry)
(147,authFrame)
(148,LOG1)
(149,pAuthNode)
(150,decryptResult == LIM_DECRYPT_ICV_FAIL)
(151,pAuthNode = limAcquireFreePreAuthNode(pMac, &pMac->lim.gLimPreAuthTimerTable)
(152,eSIR_MAC_UNSPEC_FAILURE_STATUS)
(153,LIM_NO_WEP_IN_FC)
(154,pStaDs = dphGetHashEntry(pMac, assocId, &psessionEntry->dph.dphHashTable)
(155,pRxAuthFrameBody->authStatusCode)
(156,pRxAuthFrameBody)
(157,limLog(pMac, LOGW, FL("=======> eSIR_OPEN_SYSTEM  ...")
(158,RET)
(159,sa)
(160,)
(161,pRxPacketInfo)
(162,authAlgoNumber)
(163,if (cfgPrivacyOptImp)
(164,tpSirMacAuthFrameBody)
(165,psessionEntry->dph.dphHashTable.size)
(166,seqControl)
(167,0)
(168,if (LIM_IS_AP_ROLE(psessionEntry)
(169,authFrame)
(170,if ( !vos_mem_compare((tANI_U8 *)
(171,macTrace(pMac, TRACE_CODE_MLM_STATE, psessionEntry->peSessionId, psessionEntry->limMlmState)
(172,bssId)
(173,return;)
(174,frameLen)
(175,tANI_U8)
(176,eSIR_SUCCESS)
(177,authFrame.authAlgoNumber = eSIR_SHARED_KEY)
(178,"Max pre-auth nodes reached ")
(179,tANI_U8 *)
(180,pMac)
(181,cfgPrivacyOptImp = (tANI_U8)
(182,)
(183,0)
(184,if (pRxAuthFrameBody->type !=\n\\n                            SIR_MAC_CHALLENGE_TEXT_EID)
(185,"Max pre-auth nodes reached ")
(186,plainBody)
(187,LOGW)
(188,limLog(pMac, LOGP, FL("could not retrieve Privacy option")
(189,limMlmState)
(190,lim)
(191,ccmCfgSetInt(pMac,WNI_CFG_AUTHENTICATE_FAILURE_TIMEOUT ,\n\\n                          psessionEntry->defaultAuthFailureTimeout, NULL, eANI_BOOLEAN_FALSE)
(192,authFrame.authTransactionSeqNumber =\n\\n                pRxAuthFrameBody->authTransactionSeqNumber + 1)
(193,pMac->lim.gpLimMlmAuthReq->peerMacAddr)
(194,pMac)
(195,plainBody)
(196,pRxAuthFrameBody)
(197,pHdr)
(198,tpSirMacAuthFrameBody)
(199,lim)
(200,psessionEntry)
(201,(tANI_U8 *)
(202,psessionEntry->ftPEContext)
(203,eSIR_SUCCESS)
(204,pHdr->seqControl.seqNumHi)
(205,plainBody)
(206,)
(207,encrAuthFrame)
(208,authFrame.authAlgoNumber = eSIR_SHARED_KEY)
(209,pHdr->sa)
(210,pAuthNode)
(211,psessionEntry)
(212,authFrame.authStatusCode =\n\\n                        eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS)
(213,pHdr)
(214,keyLength)
(215,)
(216,8)
(217,psessionEntry)
(218,authType)
(219,seqControl)
(220,sizeof(tSirMacAddr)
(221,limSendAuthMgmtFrame(pMac,\n\\n                                                     (tpSirMacAuthFrameBody)
(222,limMlmState)
(223,pMac)
(224,((tpSirMacAuthFrameBody)
(225,((tpSirMacAuthFrameBody)
(226,pRxAuthFrameBody->authTransactionSeqNumber)
(227,fc)
(228,mlmState)
(229,&authFrame)
(230,authFrame.authAlgoNumber)
(231,pAuthNode)
(232,pRxAuthFrameBody)
(233,return;)
(234,FL("Tkip counter measures Enabled, sending Deauth frame to")
(235,authFrame.authStatusCode =\n\\n                    eSIR_MAC_CHALLENGE_FAILURE_STATUS)
(236,authAlgoNumber)
(237,seqNum)
(238,authType)
(239,NULL)
(240,&authFrame)
(241,sa)
(242,authAlgoNumber)
(243,psessionEntry)
(244,tANI_U32 *)
(245,4)
(246,eSIR_MAC_UNSPEC_FAILURE_REASON)
(247,pRxAuthFrameBody->authAlgoNumber)
(248,psessionEntry)
(249,pMac->lim.gpLimMlmAuthReq)
(250,authNodeIdx)
(251,limSendAuthMgmtFrame(\n\\n                                            pMac, &authFrame,\n\\n                                            pHdr->sa,\n\\n                                            LIM_NO_WEP_IN_FC,psessionEntry)
(252,)
(253,pMac)
(254,sizeof(challengeTextArray)
(255,pAuthNode->fSeen)
(256,frameLen)
(257,pRxAuthFrameBody)
(258,pAuthNode == NULL)
(259,pRxAuthFrameBody)
(260,&val)
(261,vos_mem_copy(defaultKey, pKey->key, pKey->keyLength)
(262,cfgPrivacyOptImp)
(263,authStatusCode)
(264,pHdr)
(265,pMac->lim.gpLimMlmAuthReq->authType)
(266,*(pBody + 3)
(267,authFrame)
(268,(tANI_U8)
(269,authType)
(270,pRxAuthFrameBody)
(271,4)
(272,pHdr)
(273,psessionEntry)
(274,pKeyMapEntry->key)
(275,pKeyMapEntry)
(276,authFrame.authTransactionSeqNumber)
(277,&psessionEntry->dph.dphHashTable)
(278,pRxAuthFrameBody->authAlgoNumber)
(279,authFrame)
(280,eSIR_MAC_CHALLENGE_FAILURE_STATUS)
(281,eSIR_MAC_CHALLENGE_FAILURE_STATUS)
(282,psessionEntry)
(283,pMlmDisassocReq->peerMacAddr)
(284,authFrame)
(285,authFrame)
(286,eSIR_SUCCESS)
(287,limLog(pMac, LOGW,\n\\n                                   FL("Max pre-auth nodes reached ")
(288,pMac)
(289,challengeText)
(290,pAuthNode->challengeText)
(291,NULL)
(292,cfgPrivacyOptImp)
(293,pMac)
(294,(tANI_U32 *)
(295,pMac)
(296,sirSwapU16ifNeeded(pRxAuthFrameBody->authAlgoNumber)
(297,gpLimMlmAuthReq)
(298,pMac)
(299,pMac)
(300,eLIM_AUTH_RSP_TIMER)
(301,authFrame)
(302,pHdr->seqControl)
(303,SIR_MAC_CHALLENGE_TEXT_EID)
(304,pHdr->seqControl.seqNumHi)
(305,lim)
(306,authTransactionSeqNumber)
(307,ftPEContext)
(308,pMac)
(309,pBody)
(310,LOGE)
(311,((tpSirMacAuthFrameBody)
(312,pRxAuthFrameBody->authTransactionSeqNumber + 1)
(313,limLog(pMac, LOGP,\n\\n                                       FL("could not retrieve Default keyId")
(314,pBody)
(315,"lim Delete Station Context (staId: %d, assocId: %d)
(316,pHdr->sa)
(317,pHdr)
(318,)
(319,pMac->lim.gpLimMlmAuthReq)
(320,currSeqNum)
(321,vos_mem_compare(pRxAuthFrameBody->challengeText,\n\\n                                    pAuthNode->challengeText,\n\\n                                    SIR_MAC_AUTH_CHALLENGE_LENGTH)
(322,authFrame)
(323,limEncryptAuthFrame(pMac, keyId,\n\\n                                                    defaultKey,\n\\n                                                    plainBody,\n\\n                                                    encrAuthFrame,key_length)
(324,pHdr->sa)
(325,&assocId)
(326,&authFrame)
(327,&authFrame)
(328,LOGW)
(329,pRxAuthFrameBody)
(330,pRxAuthFrameBody)
(331,if (limIsGroupAddr(pHdr->sa)
(332,authAlgoNumber)
(333,uint)
(334,pMac)
(335,plainBody)
(336,psessionEntry->ftPEContext.saved_auth_rsp)
(337,limLog(pMac, LOGW, FL("=======> eSIR_SHARED_KEY  ...")
(338,pAuthNode)
(339,sa)
(340,lim)
(341,LIM_NO_WEP_IN_FC)
(342,authFrame)
(343,psessionEntry)
(344,)
(345,authStatusCode)
(346,LOGW)
(347,eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS)
(348,)
(349,keyId = (*(pBody + 3)
(350,authFrame.authTransactionSeqNumber)
(351,pAuthNode->peerMacAddr)
(352,psessionEntry)
(353,ftPEContext)
(354,authFrame.authStatusCode)
(355,pMac)
(356,FL("received Auth frame from a BC/MC address - ")
(357,pRxAuthFrameBody->authAlgoNumber ==\n\\n                    eSIR_OPEN_SYSTEM)
(358,pHdr)
(359,limSendAuthMgmtFrame(pMac, &authFrame,\n\\n                                         pHdr->sa,\n\\n                                         LIM_NO_WEP_IN_FC,psessionEntry)
(360,pMac->lim.gLimPreAuthTimerTable)
(361,authFrame.authStatusCode)
(362,pKey)
(363,SIR_MAC_AUTH_FRAME_4)
(364,if (VOS_P2P_CLIENT_MODE == psessionEntry->pePersona && psessionEntry->defaultAuthFailureTimeout)
(365,length)
(366,pAuthNode)
(367,authAlgoNumber)
(368,authFrame)
(369,pMac)
(370,)
(371,pMac)
(372,pHdr->seqControl)
(373,challengeText)
(374,(tANI_U8 *)
(375,SIR_MAC_AUTH_FRAME_4)
(376,authTransactionSeqNumber)
(377,(tpSirMacAuthFrameBody)
(378,authFrame.authStatusCode =\n\\n            eSIR_MAC_CHALLENGE_FAILURE_STATUS)
(379,psessionEntry)
(380,psessionEntry)
(381,eSIR_SUCCESS)
(382,val)
(383,isAuthValid(pMac, &rxAuthFrame, psessionEntry)
(384,psessionEntry)
(385,pHdr->seqControl)
(386,psessionEntry->WEPKeyMaterial[keyId])
(387,pHdr->fc.wep)
(388,authAlgoNumber)
(389,pRxPacketInfo)
(390,pRxAuthFrameBody)
(391,pRxAuthFrameBody->authStatusCode)
(392,0)
(393,pHdr)
(394,seqNumLo)
(395,authFrame.authAlgoNumber)
(396,pAuthNode)
(397,&rxAuthFrame)
(398,key_length=8)
(399,(tANI_S8)
(400,limSendAuthMgmtFrame(pMac, &authFrame,\n\\n                                 pHdr->sa,\n\\n                                 LIM_NO_WEP_IN_FC,psessionEntry)
(401,pHdr)
(402,assocId)
(403,authFrame)
(404,psessionEntry)
(405,plainBody)
(406,sa)
(407,pRxAuthFrameBody)
(408,psessionEntry)
(409,sa)
(410,authFrame.authTransactionSeqNumber)
(411,pRxAuthFrameBody->authAlgoNumber)
(412,pMac)
(413,if (pKeyMapEntry)
(414,keyId)
(415,staAddr)
(416,pHdr->sa)
(417,lim)
(418,tANI_U8 *)
(419,pHdr->sa)
(420,pMac)
(421,limSendAuthMgmtFrame(pMac, &authFrame,\n\\n                                                     pHdr->sa,\n\\n                                                     LIM_NO_WEP_IN_FC,psessionEntry)
(422,LIM_WEP_IN_FC)
(423,eSIR_MAC_SUCCESS_STATUS)
(424,authFrame.authAlgoNumber)
(425,val = SIR_MAC_KEY_LENGTH)
(426,pMac)
(427,key_length)
(428,)
(429,authFrame.authAlgoNumber =\n\\n                            pRxAuthFrameBody->authAlgoNumber)
(430,limLog(pMac, LOGE,FL("Challenge text preparation failed in limProcessAuthFrame")
(431,authFrame.authStatusCode =\n\\n                            eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS)
(432,pAuthNode->authNodeIdx)
(433,psessionEntry)
(434,)
(435,tpSirMacAuthFrameBody)
(436,authFrame)
(437,authFrame)
(438,authFrame.authTransactionSeqNumber =\n\\n                                        pRxAuthFrameBody->authTransactionSeqNumber + 1)
(439,FL("could not retrieve MaxNumPreAuth")
(440,)
(441,challengeText)
(442,authFrame.authStatusCode)
(443,pRxAuthFrameBody->authTransactionSeqNumber)
(444,(pHdr->seqControl.seqNumHi << 4)
(445,authFrame)
(446,authFrame)
(447,psessionEntry)
(448,pHdr)
(449,pRxAuthFrameBody->authAlgoNumber)
(450,psessionEntry)
(451,val)
(452,plainBody)
(453,authFrame.authAlgoNumber = eSIR_SHARED_KEY)
(454,WDA_GET_RX_MPDU_DATA(pRxPacketInfo)
(455,eSIR_MAC_CHALLENGE_FAILURE_STATUS)
(456,((tpSirMacAuthFrameBody)
(457,rxAuthFrame)
(458,pRxAuthFrameBody)
(459,!isAuthValid(pMac, &rxAuthFrame,psessionEntry)
(460,"received Auth frame from a BC/MC address - ")
(461,return;)
(462,pHdr)
(463,limSendAuthMgmtFrame(pMac, &authFrame,\n\\n                                 pHdr->sa,\n\\n                                 LIM_NO_WEP_IN_FC,psessionEntry)
(464,authFrame)
(465,mlmAuthInd.sessionId)
(466,mlmAuthInd)
(467,pHdr)
(468,sa)
(469,return;)
(470,pMac)
(471,pMac->lim.gpLimMlmAuthReq->peerMacAddr)
(472,authStatusCode)
(473,authAlgoNumber)
(474,case eSIR_SHARED_KEY:)
(475,return;)
(476,)
(477,authFrame)
(478,"received another PreAuth frame2"\n\\n                           " from peer " MAC_ADDRESS_STR" in Smestate %d")
(479,tANI_U8 *)
(480,pChallenge = pAuthNode->challengeText)
(481,eSIR_SUCCESS)
(482,pAuthNode->authNodeIdx)
(483,defaultKey)
(484,pAuthNode->seqNum = ((pHdr->seqControl.seqNumHi << 4)
(485,maxNumPreAuth)
(486,pMac)
(487,pAuthNode->seqNum)
(488,&mlmAuthInd)
(489,authFrame.authAlgoNumber)
(490,tpSirMacAuthFrameBody)
(491,if ((sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,\n\\n                         &rxAuthFrame)
(492,)
(493,pAuthNode->fSeen = 0)
(494,pMac->lim.limDisassocDeauthCnfReq.pMlmDisassocReq)
(495,LOGE)
(496,"could not retrieve Privacy option")
(497,encrAuthFrame)
(498,authFrame.authStatusCode)
(499,authFrame)
(500,peSessionId)
(501,LOGE)
(502,limLog(pMac, LOGE, FL("Max number of preauth context reached")
(503,VOS_P2P_CLIENT_MODE == psessionEntry->pePersona)
(504,authFrame.authStatusCode)
(505,authTransactionSeqNumber)
(506,challengeTextArray)
(507,LIM_NO_WEP_IN_FC)
(508,if (pRxAuthFrameBody->authAlgoNumber !=\n\\n                pMac->lim.gpLimMlmAuthReq->authType)
(509,pAuthNode)
(510,(tANI_U16)
(511,limPrintMacAddr(pMac, pHdr->sa, LOGW)
(512,pHdr)
(513,pMac)
(514,authAlgoNumber)
(515,lim)
(516,NULL)
(517,authStatusCode)
(518,psessionEntry)
(519,pMac->lim.gpLimMlmAuthReq)
(520,if (wlan_cfgGetInt(pMac, WNI_CFG_WEP_DEFAULT_KEYID,\n\\n                                          &val)
(521,authFrame.length)
(522,ftPEContext)
(523,type)
(524,tANI_U8 *)
(525,eLIM_MLM_AUTHENTICATED_STATE)
(526,psessionEntry->limMlmState != eLIM_MLM_WT_AUTH_FRAME4_STATE)
(527,mlmAuthInd.peerMacAddr)
(528,pHdr->sa)
(529,limPrintMacAddr(pMac, pHdr->sa, LOGE)
(530,FL("Max pre-auth nodes reached ")
(531,authTransactionSeqNumber)
(532,)
(533,LOGE)
(534,dphHashTable)
(535,pHdr)
(536,"received Authentication frame with no body from ")
(537,continue;)
(538,pHdr = WDA_GET_RX_MAC_HEADER(pRxPacketInfo)
(539,WNI_CFG_WEP_DEFAULT_KEY_1)
(540,eSIR_MAC_UNSPEC_FAILURE_REASON)
(541,authFrame)
(542,dphGetHashEntry(pMac, assocId, &psessionEntry->dph.dphHashTable)
(543,pHdr->seqControl.seqNumHi << 4)
(544,authFrame)
(545,limMlmState)
(546,limLog(pMac, LOGP,\n\\n                                   FL("could not retrieve Privacy option")
(547,(tANI_U8 *)
(548,pRxAuthFrameBody)
(549,authFrame.type)
(550,pHdr->sa)
(551,gpLimMlmAuthReq)
(552,&pMac->lim.gLimPreAuthTimerTable)
(553,pMlmDeauthReq = pMac->lim.limDisassocDeauthCnfReq.pMlmDeauthReq)
(554,authStatusCode)
(555,pMac->lim.gpLimMlmAuthReq->authType)
(556,pAuthNode)
(557,eSIR_SHARED_KEY)
(558,authStatusCode)
(559,)
(560,pStaDs = dphLookupHashEntry(pMac, pHdr->sa,\n\\n                    &assocId, &psessionEntry->dph.dphHashTable)
(561,seqNum)
(562,keyId)
(563,pRxAuthFrameBody->authAlgoNumber)
(564,cfgPrivacyOptImp = (tANI_U8)
(565,pAuthNode->mlmState)
(566,LIM_NO_WEP_IN_FC)
(567,pMac)
(568,pHdr->seqControl)
(569,authFrame.authAlgoNumber =\n\\n                        pRxAuthFrameBody->authAlgoNumber)
(570,pMac)
(571,(tANI_U8 *)
(572,pAuthNode)
(573,authType)
(574,NULL)
(575,authStatusCode)
(576,pMac)
(577,authFrame.authStatusCode)
(578,pRxAuthFrameBody->authAlgoNumber)
(579,authType)
(580,authFrame.authAlgoNumber = eSIR_SHARED_KEY)
(581,defaultKey)
(582,eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS)
(583,assocId)
(584,pHdr)
(585,psessionEntry)
(586,authFrame.authStatusCode =\n\\n                    eSIR_MAC_CHALLENGE_FAILURE_STATUS)
(587,authTransactionSeqNumber)
(588,authFrame.authAlgoNumber =\n\\n                            pRxAuthFrameBody->authAlgoNumber)
(589,pMac->lim.gpLimMlmAuthReq->peerMacAddr)
(590,authFrame)
(591,switch (pRxAuthFrameBody->authTransactionSeqNumber)
(592,pMac)
(593,authFrame)
(594,pRxAuthFrameBody)
(595,&authFrame)
(596,if ( ( sirConvertAuthFrame2Struct(pMac, pBody,\n\\n            frameLen, &rxAuthFrame)
(597,limSearchPreAuthList(pMac,\n\\n                                                pHdr->sa)
(598,eSIR_FALSE)
(599,pRxAuthFrameBody->authTransactionSeqNumber)
(600,SIR_MAC_AUTH_CHALLENGE_LENGTH)
(601,authFrame)
(602,pAuthNode->mlmState =\n\\n                            eLIM_MLM_WT_AUTH_FRAME3_STATE)
(603,limMlmState)
(604,FL("Received Auth frame with type=%d seqnum=%d, status=%d (%d)
(605,pAuthNode)
(606,pMac)
(607,LOGP)
(608,pHdr->fc.wep)
(609,psessionEntry)
(610,authFrame.authAlgoNumber)
(611,authFrame.authStatusCode)
(612,3)
(613,if (LIM_IS_AP_ROLE(psessionEntry)
(614,limSendAuthMgmtFrame(\n\\n                                        pMac, &authFrame,\n\\n                                        pHdr->sa,\n\\n                                        LIM_NO_WEP_IN_FC,psessionEntry)
(615,LOG1)
(616,LOGE)
(617,"Sessionid: %d System role : %d limMlmState: %d :Auth "\n\\n               "Frame Received: BSSID: "MAC_ADDRESS_STR " (RSSI %d)
(618,FL("lim Delete Station Context (staId: %d, assocId: %d)
(619,pHdr)
(620,pMac)
(621,LOGW)
(622,LIM_NO_WEP_IN_FC)
(623,pRxAuthFrameBody->authStatusCode)
(624,keyId)
(625,"Tkip counter measures Enabled, sending Deauth frame to")
(626,limMlmState)
(627,psessionEntry)
(628,authFrame)
(629,authTransactionSeqNumber)
(630,NULL)
(631,eANI_BOOLEAN_FALSE)
(632,pRxAuthFrameBody->authStatusCode == eSIR_MAC_SUCCESS_STATUS)
(633,gLimNumPreAuthContexts)
(634,)
(635,currSeqNum)
(636,LIM_DECRYPT_ICV_FAIL)
(637,pMac->lim.gLimPreAuthTimerTable)
(638,pMlmDisassocReq &&\n\\n                        (vos_mem_compare((tANI_U8 *)
(639,pMac)
(640,challengeText)
(641,key_length)
(642,pKeyMapEntry = limLookUpKeyMappings(pHdr->sa)
(643,LOGW)
(644,pHdr)
(645,1)
(646,limPrintMacAddr(pMac, pHdr->sa, LOG1)
(647,keyLength)
(648,key)
(649,"Max pre-auth nodes reached ")
(650,authFrame)
(651,if (LIM_IS_AP_ROLE(psessionEntry)
(652,authFrame)
(653,psessionEntry)
(654,pMac->lim.gpLimMlmAuthReq)
(655,break;)
(656,pAuthNode->fTimerStarted)
(657,pAuthNode->fTimerStarted)
(658,sa)
(659,authFrame.authTransactionSeqNumber)
(660,pRxAuthFrameBody)
(661,pHdr->sa)
(662,1)
(663,"failed to convert Auth Frame to structure or Auth is not valid ")
(664,pAuthNode)
(665,pHdr->sa)
(666,&pMac->lim.gLimPreAuthTimerTable)
(667,pMac->lim.gLimNumPreAuthContexts)
(668,sa)
(669,pMac)
(670,pAuthNode->seqNum)
(671,LOGW)
(672,authAlgoNumber)
(673,(tANI_U8 *)
(674,bTkipCntrMeasActive)
(675,key_length)
(676,authFrame)
(677,authFrame.authTransactionSeqNumber =\n\\n                    SIR_MAC_AUTH_FRAME_4)
(678,wlan_cfgGetStr(pMac,\n\\n                             (tANI_U16)
(679,4)
(680,tANI_U8 *)
(681,pMac->lim.gpLimMlmAuthReq->authType)
(682,authAlgoNumber)
(683,tANI_U8)
(684,pHdr->seqControl.seqNumHi)
(685,psessionEntry)
(686,authType)
(687,frameLen)
(688,pRxAuthFrameBody)
(689,(tANI_U8 *)
(690,authFrame.authStatusCode)
(691,tANI_U8 *)
(692,sizeof(tSirMacAddr)
(693,peerMacAddr)
(694,return;)
(695,SIR_MAC_AUTH_CHALLENGE_LENGTH)
(696,(tpSirMacAuthFrameBody)
(697,pRxAuthFrameBody)
(698,pHdr->sa)
(699,seqNumHi)
(700,pRxAuthFrameBody)
(701,LIM_NO_WEP_IN_FC)
(702,pMlmDisassocReq = pMac->lim.limDisassocDeauthCnfReq.pMlmDisassocReq)
(703,pMac)
(704,)
(705,(tpSirMacAuthFrameBody)
(706,pMac->lim)
(707,pRxAuthFrameBody->authAlgoNumber)
(708,WNI_CFG_WEP_DEFAULT_KEY_1)
(709,pHdr)
(710,authFrame)
(711,pMlmDisassocReq)
(712,authFrame.authTransactionSeqNumber =\n\\n                        pRxAuthFrameBody->authTransactionSeqNumber + 1)
(713,pRxAuthFrameBody->type)
(714,pMac)
(715,"Not enough size [%d] to decrypt received Auth frame")
(716,pMac)
(717,sa)
(718,if (limIsAuthAlgoSupported(\n\\n                                      pMac,\n\\n                                      (tAniAuthType)
(719,pHdr)
(720,pMac)
(721,FL("Restore default failure timeout")
(722,pStaDs)
(723,sirSwapU16ifNeeded(pRxAuthFrameBody->authAlgoNumber)
(724,cfgPrivacyOptImp = (tANI_U8)
(725,pAuthNode == NULL)
(726,sa)
(727,tSirMacAddr)
(728,lim)
(729,)
(730,pRxAuthFrameBody)
(731,psessionEntry)
(732,((tpSirMacAuthFrameBody)
(733,limDeletePreAuthNode(pMac, pHdr->sa)
(734,limDeletePreAuthNode(pMac,\n\\n                                             pHdr->sa)
(735,LOGE)
(736,pHdr->sa)
(737,wepOn)
(738,if (decryptResult == LIM_DECRYPT_ICV_FAIL)
(739,limSendDeauthMgmtFrame(pMac, eSIR_MAC_UNSPEC_FAILURE_REASON,\n\\n                            (tANI_U8 *)
(740,break;)
(741,eSIR_MAC_CHALLENGE_FAILURE_STATUS)
(742,authFrame.authAlgoNumber)
(743,1)
(744,switch (pRxAuthFrameBody->authAlgoNumber)
(745,(pHdr->seqControl.seqNumHi << 4)
(746,0)
(747,LOGW)
(748,pMac)
(749,limSendAuthMgmtFrame(pMac, &authFrame,\n\\n                                            pHdr->sa,\n\\n                                            LIM_NO_WEP_IN_FC,psessionEntry)
(750,pRxAuthFrameBody->authAlgoNumber)
(751,pMac)
(752,FL("Max pre-auth nodes reached ")
(753,(tANI_U8)
(754,return;)
(755,authFrame.authStatusCode)
(756,authFrame.authTransactionSeqNumber)
(757,psessionEntry)
(758,psessionEntry)
(759,((tpSirMacAuthFrameBody)
(760,pMac)
(761,tANI_U32)
(762,pMac)
(763,break;)
(764,break;)
(765,LOG1)
(766,LIM_MLM_AUTH_IND)
(767,authFrame.authTransactionSeqNumber)
(768,authTransactionSeqNumber)
(769,authAlgoNumber)
(770,mlmState)
(771,pRxAuthFrameBody->authTransactionSeqNumber + 1)
(772,&rxAuthFrame)
(773,pBody + 3)
(774,seqNumLo)
(775,LIM_IS_STA_ROLE(psessionEntry)
(776,)
(777,psessionEntry)
(778,limSearchPreAuthList(pMac, pHdr->sa)
(779,)
(780,authFrame)
(781,rxAuthFrame)
(782,authStatusCode)
(783,LIM_NO_WEP_IN_FC)
(784,val)
(785,psessionEntry)
(786,sa)
(787,FL("Alloc new data: %x id %d peer ")
(788,pHdr)
(789,pAuthNode == NULL)
(790,pBody != NULL)
(791,pHdr)
(792,pChallenge)
(793,pAuthNode)
(794,pHdr->seqControl.seqNumHi << 4)
(795,psessionEntry->WEPKeyMaterial[keyId].key[0])
(796,authAlgoNumber)
(797,challengeText)
(798,pMac)
(799,wlan_cfgGetInt(pMac, WNI_CFG_PRIVACY_ENABLED,\n\\n                                  &val)
(800,pMac)
(801,sizeof(tSirMacAddr)
(802,pAuthNode->fTimerStarted)
(803,pMac)
(804,authTransactionSeqNumber)
(805,authFrame)
(806,pMac)
(807,pAuthNode)
(808,saved_auth_rsp)
(809,authFrame.authTransactionSeqNumber =\n\\n            SIR_MAC_AUTH_FRAME_4)
(810,gpLimMlmAuthReq)
(811,pRxAuthFrameBody)
(812,pAuthNode->seqNum)
(813,(pHdr->seqControl.seqNumHi << 4)
(814,psessionEntry)
(815,pRxAuthFrameBody)
(816,dphHashTable)
(817,pFTPreAuthReq)
(818,pHdr->seqControl.seqNumHi)
(819,pRxAuthFrameBody)
(820,"Alloc new data: %x id %d peer ")
(821,peerMacAddr)
(822,authFrame.authTransactionSeqNumber)
(823,pRxAuthFrameBody->authStatusCode)
(824,0)
(825,authAlgoNumber)
(826,psessionEntry->bTkipCntrMeasActive)
(827,)
(828,mlmAuthInd.sessionId = psessionEntry->smeSessionId)
(829,pHdr)
(830,authFrame.authTransactionSeqNumber =\n\\n                            pRxAuthFrameBody->authTransactionSeqNumber + 1)
(831,authStatusCode)
(832,pRxAuthFrameBody->challengeText)
(833,limSendAuthMgmtFrame(pMac, &authFrame,\n\\n                                         pHdr->sa,\n\\n                                         LIM_NO_WEP_IN_FC,psessionEntry)
(834,FL("Not enough size [%d] to decrypt received Auth frame")
(835,seqNum)
(836,pHdr->sa)
(837,LIM_IS_AP_ROLE(psessionEntry)
(838,)
(839,authFrame.authTransactionSeqNumber =\n\\n                    SIR_MAC_AUTH_FRAME_4)
(840,pHdr->seqControl.seqNumHi << 4)
(841,SIR_MAC_AUTH_FRAME_4)
(842,authFrame)
(843,pKeyMapEntry->wepOn)
(844,limLog(pMac, LOGW,\n\\n           FL("Received Auth frame with type=%d seqnum=%d, status=%d (%d)
(845,val = psessionEntry->privacy)
(846,pHdr->seqControl)
(847,authStatusCode)
(848,saved_auth_rsp_length)
(849,pHdr->sa)
(850,&pMlmDeauthReq->peerMacAddr)
(851,fTimerStarted)
(852,pMac->lim)
(853,authFrame)
(854,&authFrame)
(855,authFrame)
(856,!vos_mem_compare((tANI_U8 *)
(857,val)
(858,pRxAuthFrameBody)
(859,eSIR_SHARED_KEY)
(860,authTransactionSeqNumber)
(861,limAcquireFreePreAuthNode(pMac, &pMac->lim.gLimPreAuthTimerTable)
(862,pKey->keyLength)
(863,pMac->lim.gLimPreAuthTimerTable)
(864,eSIR_MAC_UNSPEC_FAILURE_REASON)
(865,authAlgoNumber)
(866,plainBody)
(867,FL("STA is initiating brand-new Authentication ...")
(868,pHdr)
(869,SIR_MAC_WEP_IV_LENGTH)
(870,TX_SUCCESS)
(871,psessionEntry->ftPEContext)
(872,frameLen < LIM_ENCR_AUTH_BODY_LEN)
(873,MAC_ADDR_ARRAY(pHdr->sa)
(874,gpLimMlmAuthReq)
(875,psessionEntry->privacy)
(876,assocId)
(877,WDA_GET_RX_RSSI_NORMALIZED(pRxPacketInfo)
(878,pRxAuthFrameBody->authTransactionSeqNumber + 1)
(879,authStatusCode)
(880,psessionEntry->limMlmState)
(881,eSIR_MAC_CHALLENGE_FAILURE_STATUS)
(882,SIR_MAC_KEY_LENGTH)
(883,)
(884,sa)
(885,psessionEntry)
(886,pHdr)
(887,&authFrame)
(888,pMac)
(889,frameLen)
(890,authTransactionSeqNumber)
(891,key_length)
(892,authFrame)
(893,psessionEntry->limMlmState)
(894,WNI_CFG_AUTHENTICATE_FAILURE_TIMEOUT)
(895,limSendAuthMgmtFrame(pMac, &authFrame,\n\\n                                         pHdr->sa,\n\\n                                         LIM_NO_WEP_IN_FC,psessionEntry)
(896,&psessionEntry->WEPKeyMaterial[keyId].key[0])
(897,privacy)
(898,wlan_cfgGetStr(pMac,\n\\n                                      (tANI_U16)
(899,limRestoreFromAuthState(pMac, eSIR_SME_SUCCESS,\n\\n                                              pRxAuthFrameBody->authStatusCode,psessionEntry)
(900,eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS)
(901,pAuthNode)
(902,seqControl)
(903,(tANI_U8 *)
(904,vos_mem_compare((tANI_U8 *)
(905,authFrame.authAlgoNumber)
(906,if (pKeyMapEntry)
(907,gpLimMlmAuthReq)
(908,limSendAuthMgmtFrame(\n\\n                                            pMac, &authFrame,\n\\n                                            pHdr->sa,\n\\n                                            LIM_NO_WEP_IN_FC,psessionEntry)
(909,pRxAuthFrameBody->authStatusCode ==\n\\n                eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS)
(910,)
(911,)
(912,pRxAuthFrameBody)
(913,pRxAuthFrameBody->authTransactionSeqNumber)
(914,((tpSirMacAuthFrameBody)
(915,pBody = WDA_GET_RX_MPDU_DATA(pRxPacketInfo)
(916,(tANI_U8 *)
(917,authTransactionSeqNumber)
(918,return;)
(919,tSirMacAddr)
(920,cfgPrivacyOptImp)
(921,)
(922,tx_timer_change_context(&pAuthNode->timer, pAuthNode->authNodeIdx)
(923,authTransactionSeqNumber)
(924,timer)
(925,TRACE_CODE_MLM_STATE)
(926,tpSirMacAuthFrameBody)
(927,pHdr->sa)
(928,pAuthNode->fTimerStarted = 1)
(929,if (pRxAuthFrameBody->authAlgoNumber != eSIR_SHARED_KEY)
(930,(pBody != NULL)
(931,case SIR_MAC_AUTH_FRAME_4:)
(932,pAuthNode)
(933,authFrame.authTransactionSeqNumber)
(934,eSIR_SHARED_KEY)
(935,psessionEntry->ftPEContext.pFTPreAuthReq != NULL)
(936,pHdr->sa)
(937,if(pAuthNode->fTimerStarted)
(938,1)
(939,LOGP)
(940,limDisassocDeauthCnfReq)
(941,4)
(942,pAuthNode)
(943,tANI_U8 *)
(944,authType)
(945,peerMacAddr)
(946,pAuthNode)
(947,wlan_cfgGetInt(pMac, WNI_CFG_PRIVACY_ENABLED,\n\\n                      &val)
(948,eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS)
(949,pMac)
(950,psessionEntry)
(951,limLog(pMac, LOG1, FL("Alloc new data: %x peer ")
(952,authFrame.authAlgoNumber = eSIR_SHARED_KEY)
(953,eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS)
(954,gLimPreAuthTimerTable)
(955,pMac)
(956,psessionEntry)
(957,tSirMacAddr)
(958,if (pHdr->fc.retry == 0 || pAuthNode->seqNum != currSeqNum)
(959,&psessionEntry->dph.dphHashTable)
(960,authAlgoNumber)
(961,limLog(pMac, LOG1, FL("Alloc new data: %x id %d peer ")
(962,pHdr)
(963,SIR_MAC_CHALLENGE_TEXT_EID)
(964,pFTPreAuthReq)
(965,authAlgoNumber)
(966,authFrame.authAlgoNumber =\n\\n                        pRxAuthFrameBody->authAlgoNumber)
(967,pRxAuthFrameBody->authTransactionSeqNumber)
(968,psessionEntry->limSmeState)
(969,tpSirMacAuthFrameBody)
(970,LIM_NO_WEP_IN_FC)
(971,pMac->lim.gpLimMlmAuthReq)
(972,(tAniAuthType)
(973,WNI_CFG_MAX_NUM_PRE_AUTH)
(974,pRxAuthFrameBody->authStatusCode)
(975,sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,\n\\n                          &rxAuthFrame)
(976,&pMac->lim.gLimPreAuthTimerTable)
(977,pKey->keyLength)
(978,pMac->lim.limDisassocDeauthCnfReq)
(979,LOGE)
(980,pHdr)
(981,authFrame)
(982,psessionEntry)
(983,1)
(984,psessionEntry)
(985,eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS)
(986,pHdr)
(987,pAuthNode->fTimerStarted)
(988,authFrame)
(989,pMac)
(990,SIR_MAC_AUTH_FRAME_4)
(991,pAuthNode->peerMacAddr)
(992,limPrintMacAddr(pMac, pHdr->sa, LOG1)
(993,tANI_U32)
(994,)
(995,pMac)
(996,1)
(997,if (pRxAuthFrameBody->authStatusCode ==\n\\n                eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS)
(998,psessionEntry)
(999,pRxAuthFrameBody->authAlgoNumber)
(1000,psessionEntry)
(1001,sirSwapU16ifNeeded((tANI_U16)
(1002,psessionEntry)
(1003,(tANI_U8 *)
(1004,LOGE)
(1005,((tpSirMacAuthFrameBody)
(1006,authAlgoNumber)
(1007,authFrame.authTransactionSeqNumber =\n\\n                pRxAuthFrameBody->authTransactionSeqNumber + 1)
(1008,(tpSirMacAuthFrameBody)
(1009,peerMacAddr)
(1010,authFrame.authTransactionSeqNumber)
(1011,sa)
(1012,keyId)
(1013,psessionEntry->limMlmState)
(1014,authFrame.authAlgoNumber)
(1015,SIR_MAC_WEP_IV_LENGTH)
(1016,pRxAuthFrameBody)
(1017,frameLen)
(1018,sa)
(1019,pAuthNode)
(1020,pAuthNode)
(1021,authAlgoNumber)
(1022,if (pAuthNode == NULL)
(1023,pMac)
(1024,pRxAuthFrameBody->authAlgoNumber)
(1025,psessionEntry->ftPEContext.pFTPreAuthReq)
(1026,pMac)
(1027,FL("Alloc new data: %x peer ")
(1028,pRxAuthFrameBody)
(1029,limLog(pMac, LOGE, FL(\n\\n                               "failed to convert Auth Frame to structure or Auth is not valid ")
(1030,sa)
(1031,authFrame.authAlgoNumber)
(1032,pAuthNode->fTimerStarted)
(1033,if (pKeyMapEntry->key == NULL)
(1034,lim)
(1035,authFrame)
(1036,LIM_IS_AP_ROLE(psessionEntry)
(1037,gpLimMlmAuthReq)
(1038,challengeText)
(1039,FL("could not retrieve Privacy option")
(1040,pRxAuthFrameBody->authStatusCode)
(1041,pAuthNode)
(1042,sa)
(1043,pMac)
(1044,authFrame.length = SIR_MAC_AUTH_CHALLENGE_LENGTH)
(1045,authFrame)
(1046,sa)
(1047,pMac)
(1048,"Max pre-auth nodes reached ")
(1049,pKeyMapEntry)
(1050,eLIM_MLM_WT_AUTH_FRAME4_STATE)
(1051,pHdr)
(1052,default:)
(1053,key)
(1054,VOS_P2P_CLIENT_MODE)
(1055,pAuthNode)
(1056,eSIR_SME_AUTH_REFUSED)
(1057,cfgPrivacyOptImp)
(1058,pMlmDeauthReq)
(1059,pRxAuthFrameBody->authStatusCode)
(1060,)
(1061,limMlmState)
(1062,tSirMacAddr)
(1063,&authFrame)
(1064,preAuthbssId)
(1065,limSendDeauthMgmtFrame(pMac,\n\\n                               eSIR_MAC_UNSPEC_FAILURE_REASON, (tANI_U8 *)
(1066,decryptResult)
(1067,return;)
(1068,authAlgoNumber)
(1069,plainBody)
(1070,FL("failed to convert Auth Frame to structure or Auth is not valid ")
(1071,authAlgoNumber)
(1072,authFrame.authStatusCode)
(1073,if (LIM_IS_AP_ROLE(psessionEntry)
(1074,pRxAuthFrameBody->authTransactionSeqNumber)
(1075,pMlmDeauthReq)
(1076,psessionEntry)
(1077,authFrame)
(1078,"could not retrieve MaxNumPreAuth")
(1079,sirSwapU16ifNeeded((tANI_U16)
(1080,pHdr)
(1081,pKey)
(1082,(tpSirMacAuthFrameBody)
(1083,NULL)
(1084,eLIM_MLM_AUTHENTICATED_STATE)
(1085,decryptResult)
(1086,eSIR_MAC_SUCCESS_STATUS)
(1087,authFrame.authTransactionSeqNumber)
(1088,authStatusCode)
(1089,sizeof(tSirMacAddr)
(1090,pStaDs->staIndex)
(1091,pAuthNode)
(1092,pMac->lim.gpLimMlmAuthReq)
(1093,authFrame)
(1094,peerMacAddr)
(1095,)
(1096,limLog(pMac, LOGE,\n\\n                               FL("lim Delete Station Context (staId: %d, assocId: %d)
(1097,pHdr)
(1098,frameLen-SIR_MAC_WEP_IV_LENGTH)
(1099,0)
(1100,LOGP)
(1101,0)
(1102,pHdr->sa)
(1103,authFrame.authAlgoNumber)
(1104,pHdr)
(1105,sa)
(1106,(tANI_U32)
(1107,limProcessDisassocAckTimeout(pMac)
(1108,(tANI_U32 *)
(1109,)
(1110,eSIR_SHARED_KEY)
(1111,)
(1112,MTRACE(macTrace(pMac, TRACE_CODE_MLM_STATE, psessionEntry->peSessionId, psessionEntry->limMlmState)
(1113,pMac)
(1114,LOG1)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^