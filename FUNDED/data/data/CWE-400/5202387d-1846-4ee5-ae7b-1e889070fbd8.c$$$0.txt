-----label-----
1
-----code-----
static __inline vsize_t
sokvareserve(struct socket *so, vsize_t len)
{
	int s;
	int error;

	s = splvm();
	simple_lock(&so_pendfree_slock);
	while (socurkva + len > somaxkva) {
		size_t freed;

		/*
		 * try to do pendfree.
		 */

		freed = sodopendfreel(so);

		/*
		 * if some kva was freed, try again.
		 */

		if (freed)
			continue;

		SOSEND_COUNTER_INCR(&sosend_kvalimit);
		sokvawaiters++;
		error = ltsleep(&socurkva, PVM | PCATCH, "sokva", 0,
		    &so_pendfree_slock);
		sokvawaiters--;
		if (error) {
			len = 0;
			break;
		}
	}
	socurkva += len;
	simple_unlock(&so_pendfree_slock);
	splx(s);
	return len;
}
-----children-----
1,2
1,3
1,4
2,3
4,5
4,6
4,7
6,7
6,8
7,8
9,10
9,11
12,13
12,14
13,14
15,16
17,18
17,19
17,20
17,21
17,22
17,23
17,24
17,25
17,26
18,19
19,20
19,21
21,22
23,24
24,25
24,26
26,27
28,29
29,30
29,31
30,31
32,33
33,34
35,36
36,37
36,38
37,38
39,40
40,41
40,42
43,44
43,45
44,45
44,46
45,46
45,47
46,47
48,49
50,51
52,53
52,54
52,55
52,56
52,57
52,58
52,59
52,60
53,54
54,55
54,56
55,56
57,58
59,60
60,61
60,62
61,62
63,64
63,65
64,65
66,67
68,69
68,70
69,70
72,73
73,74
73,75
74,75
76,77
77,78
77,79
80,81
81,82
82,83
84,85
85,86
85,87
86,87
88,89
88,90
88,91
88,92
88,93
88,94
89,90
91,92
92,93
94,95
94,96
95,96
97,98
101,102
102,103
104,105
105,106
106,107
108,109
108,110
109,110
111,112
111,113
112,113
113,114
113,115
114,115
118,119
119,120
119,121
120,121
122,123
124,125
125,126
125,127
126,127
128,129
129,130
131,132
132,133
132,134
133,134
135,136
137,138
138,139
-----nextToken-----
3,5,8,10,11,14,16,20,22,25,27,31,34,38,41,42,47,49,51,56,58,62,65,67,70,71,75,78,79,83,87,90,93,96,98,99,100,103,107,110,115,116,117,121,123,127,130,134,136,139
-----computeFrom-----
29,30
29,31
44,45
44,46
45,46
45,47
60,61
60,62
85,86
85,87
94,95
94,96
113,114
113,115
119,120
119,121
-----guardedBy-----
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;NamedTypeSpecifier;Name;FunctionDeclarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;ReferenceOperator;Name;WhileStatement;BinaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;ContinueStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;ReferenceOperator;Name;ExpressionStatement;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;UnaryExpression;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BreakStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;IdExpression;Name;
-----ast_node-----
static __inline vsize_tsokvareserve(struct socket *so, vsize_t len){	int s;	int error;	s = splvm();	simple_lock(&so_pendfree_slock);	while (socurkva + len > somaxkva) {		size_t freed;		/*		 * try to do pendfree.		 */		freed = sodopendfreel(so);		/*		 * if some kva was freed, try again.		 */		if (freed)			continue;		SOSEND_COUNTER_INCR(&sosend_kvalimit);		sokvawaiters++;		error = ltsleep(&socurkva, PVM | PCATCH, "sokva", 0,		    &so_pendfree_slock);		sokvawaiters--;		if (error) {			len = 0;			break;		}	}	socurkva += len;	simple_unlock(&so_pendfree_slock);	splx(s);	return len;}
static __inline vsize_t
vsize_t
sokvareserve(struct socket *so, vsize_t len)
sokvareserve
struct socket *so
struct socket
socket
*so
*
so
vsize_t len
vsize_t
vsize_t
len
len
{	int s;	int error;	s = splvm();	simple_lock(&so_pendfree_slock);	while (socurkva + len > somaxkva) {		size_t freed;		/*		 * try to do pendfree.		 */		freed = sodopendfreel(so);		/*		 * if some kva was freed, try again.		 */		if (freed)			continue;		SOSEND_COUNTER_INCR(&sosend_kvalimit);		sokvawaiters++;		error = ltsleep(&socurkva, PVM | PCATCH, "sokva", 0,		    &so_pendfree_slock);		sokvawaiters--;		if (error) {			len = 0;			break;		}	}	socurkva += len;	simple_unlock(&so_pendfree_slock);	splx(s);	return len;}
int s;
int s;
int
s
s
int error;
int error;
int
error
error
s = splvm();
s = splvm()
s
s
splvm()
splvm
splvm
simple_lock(&so_pendfree_slock);
simple_lock(&so_pendfree_slock);
simple_lock
simple_lock
(&so_pendfree_slock)
&so_pendfree_slock
&
so_pendfree_slock
while (socurkva + len > somaxkva) {		size_t freed;		/*		 * try to do pendfree.		 */		freed = sodopendfreel(so);		/*		 * if some kva was freed, try again.		 */		if (freed)			continue;		SOSEND_COUNTER_INCR(&sosend_kvalimit);		sokvawaiters++;		error = ltsleep(&socurkva, PVM | PCATCH, "sokva", 0,		    &so_pendfree_slock);		sokvawaiters--;		if (error) {			len = 0;			break;		}	}
socurkva + len > somaxkva
socurkva + len
socurkva
socurkva
len
len
somaxkva
somaxkva
{		size_t freed;		/*		 * try to do pendfree.		 */		freed = sodopendfreel(so);		/*		 * if some kva was freed, try again.		 */		if (freed)			continue;		SOSEND_COUNTER_INCR(&sosend_kvalimit);		sokvawaiters++;		error = ltsleep(&socurkva, PVM | PCATCH, "sokva", 0,		    &so_pendfree_slock);		sokvawaiters--;		if (error) {			len = 0;			break;		}	}
size_t freed;
size_t freed;
size_t
size_t
freed
freed
freed = sodopendfreel(so);
freed = sodopendfreel(so)
freed
freed
sodopendfreel(so)
sodopendfreel
sodopendfreel
so
so
if (freed)			continue;
freed
freed
continue;
SOSEND_COUNTER_INCR(&sosend_kvalimit);
SOSEND_COUNTER_INCR(&sosend_kvalimit);
SOSEND_COUNTER_INCR
SOSEND_COUNTER_INCR
(&sosend_kvalimit)
&sosend_kvalimit
&
sosend_kvalimit
sokvawaiters++;
sokvawaiters++
sokvawaiters
sokvawaiters
error = ltsleep(&socurkva, PVM | PCATCH, "sokva", 0,		    &so_pendfree_slock);
error = ltsleep(&socurkva, PVM | PCATCH, "sokva", 0,		    &so_pendfree_slock)
error
error
ltsleep(&socurkva, PVM | PCATCH, "sokva", 0,		    &so_pendfree_slock)
ltsleep
ltsleep
&socurkva
socurkva
socurkva
PVM | PCATCH
PVM
PVM
PCATCH
PCATCH
"sokva"
0
&so_pendfree_slock
so_pendfree_slock
so_pendfree_slock
sokvawaiters--;
sokvawaiters--
sokvawaiters
sokvawaiters
if (error) {			len = 0;			break;		}
error
error
{			len = 0;			break;		}
len = 0;
len = 0
len
len
0
break;
socurkva += len;
socurkva += len
socurkva
socurkva
len
len
simple_unlock(&so_pendfree_slock);
simple_unlock(&so_pendfree_slock)
simple_unlock
simple_unlock
&so_pendfree_slock
so_pendfree_slock
so_pendfree_slock
splx(s);
splx(s)
splx
splx
s
s
return len;
len
len
-----joern-----
(18,30,0)
(6,62,0)
(5,1,0)
(13,7,0)
(24,62,0)
(61,4,0)
(62,58,0)
(32,9,0)
(7,4,0)
(51,32,0)
(49,13,0)
(20,4,0)
(2,45,0)
(58,62,0)
(37,9,0)
(1,42,0)
(41,61,0)
(19,9,0)
(27,4,0)
(7,13,0)
(25,4,0)
(39,50,0)
(38,34,0)
(31,45,0)
(47,42,0)
(52,20,0)
(20,36,0)
(47,43,0)
(33,58,0)
(1,45,0)
(46,23,0)
(40,9,0)
(62,55,0)
(57,55,0)
(23,9,0)
(48,19,0)
(54,9,0)
(28,55,0)
(30,44,0)
(23,46,0)
(15,47,0)
(36,20,0)
(22,47,0)
(44,30,0)
(54,26,0)
(59,4,0)
(10,1,0)
(26,54,0)
(45,42,0)
(0,9,0)
(21,27,0)
(14,36,0)
(1,9,0)
(16,23,0)
(36,35,0)
(32,45,0)
(27,62,0)
(44,9,0)
(60,8,0)
(62,50,0)
(11,43,0)
(19,23,0)
(43,47,0)
(32,42,0)
(50,62,0)
(53,4,0)
(55,62,0)
(29,32,0)
(8,4,0)
(45,34,0)
(56,26,0)
(62,27,0)
(31,2,1)
(11,47,1)
(12,20,1)
(5,43,1)
(17,12,1)
(6,55,1)
(1,45,1)
(47,22,1)
(18,1,1)
(52,43,1)
(47,42,1)
(19,48,1)
(3,61,1)
(22,15,1)
(2,3,1)
(55,57,1)
(62,50,1)
(51,32,1)
(33,24,1)
(32,45,1)
(19,23,1)
(30,18,1)
(1,10,1)
(29,19,1)
(54,26,1)
(58,33,1)
(13,49,1)
(14,52,1)
(24,6,1)
(61,41,1)
(27,62,1)
(15,17,1)
(26,56,1)
(57,28,1)
(48,44,1)
(56,23,1)
(8,60,1)
(44,30,1)
(43,11,1)
(36,35,1)
(49,12,1)
(21,8,1)
(41,27,1)
(46,16,1)
(15,3,1)
(50,39,1)
(60,7,1)
(10,5,1)
(36,14,1)
(32,29,1)
(1,42,1)
(28,50,1)
(15,54,1)
(7,13,1)
(38,45,1)
(5,38,1)
(32,42,1)
(23,46,1)
(45,31,1)
(39,21,1)
(20,36,1)
(62,55,1)
(62,58,1)
(43,47,1)
(45,42,1)
(41,12,2)
(13,12,2)
(27,12,2)
(15,12,2)
(24,12,2)
(45,42,2)
(17,12,2)
(7,13,2)
(8,12,2)
(22,3,2)
(45,3,2)
(47,3,2)
(49,12,2)
(62,58,2)
(32,45,2)
(27,62,2)
(54,26,2)
(61,12,2)
(43,12,2)
(1,42,2)
(11,12,2)
(62,50,2)
(1,45,2)
(50,12,2)
(12,43,2)
(15,3,2)
(7,12,2)
(38,3,2)
(3,12,2)
(20,36,2)
(44,30,2)
(43,47,2)
(20,43,2)
(14,43,2)
(33,12,2)
(32,42,2)
(11,3,2)
(28,12,2)
(62,12,2)
(47,42,2)
(6,12,2)
(39,12,2)
(60,12,2)
(47,12,2)
(21,12,2)
(55,12,2)
(22,12,2)
(23,46,2)
(57,12,2)
(19,23,2)
(36,43,2)
(52,43,2)
(51,32,2)
(36,35,2)
(2,3,2)
(31,3,2)
(58,12,2)
(62,55,2)
(43,3,2)
-----------------------------------
(0,s)
(1,socurkva += len)
(2,len)
(3,error)
(4,)
(5,socurkva)
(6,"sokva")
(7,SOSEND_COUNTER_INCR(&sosend_kvalimit)
(8,sokvawaiters++)
(9,)
(10,len)
(11,somaxkva)
(12,freed)
(13,&sosend_kvalimit)
(14,so)
(15,socurkva)
(16,s)
(17,continue;)
(18,so_pendfree_slock)
(19,splx(s)
(20,freed = sodopendfreel(so)
(21,error)
(22,len)
(23,s = splvm()
(24,0)
(25,if (freed)
(26,&so_pendfree_slock)
(27,error = ltsleep(&socurkva, PVM | PCATCH, "sokva", 0,\n\\n\\t\\t    &so_pendfree_slock)
(28,PVM)
(29,len)
(30,&so_pendfree_slock)
(31,0)
(32,return len;)
(33,so_pendfree_slock)
(34,)
(35,struct socket *so)
(36,sodopendfreel(so)
(37,error)
(38,break;)
(39,socurkva)
(40,while (socurkva + len > somaxkva)
(41,sokvawaiters)
(42,vsize_t len)
(43,socurkva + len > somaxkva)
(44,simple_unlock(&so_pendfree_slock)
(45,len = 0)
(46,splvm()
(47,socurkva + len)
(48,s)
(49,sosend_kvalimit)
(50,&socurkva)
(51,RET)
(52,freed)
(53,if (error)
(54,simple_lock(&so_pendfree_slock)
(55,PVM | PCATCH)
(56,so_pendfree_slock)
(57,PCATCH)
(58,&so_pendfree_slock)
(59,freed)
(60,sokvawaiters)
(61,sokvawaiters--)
(62,ltsleep(&socurkva, PVM | PCATCH, "sokva", 0,\n\\n\\t\\t    &so_pendfree_slock)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^