-----label-----
1
-----code-----
static void
ImgPhotoInstanceSetSize(
    PhotoInstance *instancePtr)	/* Instance whose size is to be changed. */
{
    PhotoMaster *masterPtr;
    schar *newError, *errSrcPtr, *errDestPtr;
    int h, offset;
    XRectangle validBox;
    Pixmap newPixmap;

    masterPtr = instancePtr->masterPtr;
    TkClipBox(masterPtr->validRegion, &validBox);

    if ((instancePtr->width != masterPtr->width)
	    || (instancePtr->height != masterPtr->height)
	    || (instancePtr->pixels == None)) {
	newPixmap = Tk_GetPixmap(instancePtr->display,
		RootWindow(instancePtr->display,
			instancePtr->visualInfo.screen),
		(masterPtr->width > 0) ? masterPtr->width: 1,
		(masterPtr->height > 0) ? masterPtr->height: 1,
		instancePtr->visualInfo.depth);
	if (!newPixmap) {
	    Tcl_Panic("Fail to create pixmap with Tk_GetPixmap in ImgPhotoInstanceSetSize.\n");
	}

	/*
	 * The following is a gross hack needed to properly support colormaps
	 * under Windows. Before the pixels can be copied to the pixmap, the
	 * relevent colormap must be associated with the drawable. Normally we
	 * can infer this association from the window that was used to create
	 * the pixmap. However, in this case we're using the root window, so
	 * we have to be more explicit.
	 */

	TkSetPixmapColormap(newPixmap, instancePtr->colormap);

	if (instancePtr->pixels != None) {
	    /*
	     * Copy any common pixels from the old pixmap and free it.
	     */

	    XCopyArea(instancePtr->display, instancePtr->pixels, newPixmap,
		    instancePtr->gc, validBox.x, validBox.y,
		    validBox.width, validBox.height, validBox.x, validBox.y);
	    Tk_FreePixmap(instancePtr->display, instancePtr->pixels);
	}
	instancePtr->pixels = newPixmap;
    }

    if ((instancePtr->width != masterPtr->width)
	    || (instancePtr->height != masterPtr->height)
	    || (instancePtr->error == NULL)) {

	if (masterPtr->height > 0 && masterPtr->width > 0) {
	    newError = (schar *) ckalloc((unsigned)
		    masterPtr->height * masterPtr->width * 3 * sizeof(schar));

	    /*
	     * Zero the new array so that we don't get bogus error values
	     * propagating into areas we dither later.
	     */

	    if ((instancePtr->error != NULL)
		    && ((instancePtr->width == masterPtr->width)
		    || (validBox.width == masterPtr->width))) {
		if (validBox.y > 0) {
		    memset(newError, 0, (size_t)
			    validBox.y * masterPtr->width * 3 * sizeof(schar));
		}
		h = validBox.y + validBox.height;
		if (h < masterPtr->height) {
		    memset(newError + h*masterPtr->width*3, 0,
			    (size_t) (masterPtr->height - h)
			    * masterPtr->width * 3 * sizeof(schar));
		}
	    } else {
		memset(newError, 0, (size_t)
			masterPtr->height * masterPtr->width *3*sizeof(schar));
	    }
	} else {
	    newError = NULL;
	}

	if (instancePtr->error != NULL) {
	    /*
	     * Copy the common area over to the new array and free the old
	     * array.
	     */

	    if (masterPtr->width == instancePtr->width) {
		offset = validBox.y * masterPtr->width * 3;
		memcpy(newError + offset, instancePtr->error + offset,
			((size_t) validBox.height
			* masterPtr->width * 3 * sizeof(schar)));

	    } else if (validBox.width > 0 && validBox.height > 0) {
		errDestPtr = newError +
			(validBox.y * masterPtr->width + validBox.x) * 3;
		errSrcPtr = instancePtr->error +
			(validBox.y * instancePtr->width + validBox.x) * 3;

		for (h = validBox.height; h > 0; --h) {
		    memcpy(errDestPtr, errSrcPtr,
			    validBox.width * 3 * sizeof(schar));
		    errDestPtr += masterPtr->width * 3;
		    errSrcPtr += instancePtr->width * 3;
		}
	    }
	    ckfree((char *) instancePtr->error);
	}

	instancePtr->error = newError;
    }

    instancePtr->width = masterPtr->width;
    instancePtr->height = masterPtr->height;
}
-----children-----
1,2
1,3
1,4
3,4
3,5
5,6
5,7
6,7
8,9
8,10
11,12
11,13
11,14
11,15
11,16
11,17
11,18
11,19
11,20
11,21
11,22
12,13
13,14
13,15
14,15
16,17
16,18
19,20
20,21
20,22
20,23
20,24
21,22
23,24
23,25
26,27
26,28
29,30
29,31
32,33
33,34
33,35
33,36
35,36
37,38
39,40
40,41
40,42
41,42
43,44
45,46
46,47
46,48
47,48
49,50
51,52
52,53
52,54
53,54
55,56
55,57
56,57
59,60
60,61
60,62
60,63
61,62
63,64
63,65
64,65
67,68
68,69
70,71
70,72
71,72
71,73
72,73
72,74
73,74
74,75
74,76
75,76
75,77
76,77
79,80
79,81
80,81
83,84
84,85
84,86
85,86
85,87
86,87
89,90
89,91
90,91
93,94
94,95
94,96
95,96
95,97
96,97
99,100
101,102
101,103
101,104
101,105
101,106
102,103
103,104
103,105
104,105
106,107
106,108
106,109
106,110
106,111
106,112
107,108
109,110
109,111
110,111
113,114
113,115
113,116
114,115
116,117
116,118
117,118
120,121
120,122
121,122
121,123
122,123
126,127
126,128
126,129
127,128
128,129
128,130
129,130
129,131
130,131
134,135
134,136
135,136
139,140
139,141
139,142
140,141
141,142
141,143
142,143
142,144
143,144
147,148
147,149
148,149
152,153
152,154
153,154
153,155
154,155
158,159
158,160
159,160
160,161
162,163
163,164
164,165
164,166
165,166
168,169
169,170
169,171
169,172
170,171
172,173
174,175
174,176
175,176
178,179
178,180
179,180
179,181
180,181
180,182
181,182
184,185
186,187
186,188
187,188
188,189
188,190
188,191
188,192
188,193
188,194
188,195
188,196
188,197
188,198
188,199
189,190
191,192
191,193
192,193
195,196
195,197
196,197
199,200
201,202
201,203
202,203
205,206
205,207
206,207
209,210
209,211
210,211
213,214
213,215
214,215
217,218
217,219
218,219
221,222
221,223
222,223
225,226
225,227
226,227
229,230
230,231
230,232
230,233
231,232
233,234
233,235
234,235
237,238
237,239
238,239
241,242
242,243
242,244
243,244
243,245
244,245
247,248
249,250
249,251
250,251
250,252
251,252
251,253
252,253
253,254
253,255
254,255
254,256
255,256
258,259
258,260
259,260
262,263
263,264
263,265
264,265
264,266
265,266
268,269
268,270
269,270
272,273
273,274
273,275
274,275
274,276
275,276
278,279
280,281
280,282
280,283
281,282
281,283
281,284
282,283
282,284
283,284
283,285
284,285
284,286
285,286
289,290
289,291
290,291
290,292
291,292
295,296
295,297
296,297
297,298
297,299
298,299
300,301
300,302
301,302
301,303
302,303
304,305
306,307
306,308
307,308
309,310
309,311
310,311
310,312
311,312
311,313
312,313
312,314
313,314
313,315
316,317
316,318
317,318
320,321
320,322
321,322
325,326
326,327
326,328
327,328
330,331
330,332
330,333
331,332
331,333
332,333
333,334
333,335
334,335
334,336
335,336
338,339
340,341
341,342
341,343
342,343
343,344
343,345
344,345
344,346
345,346
348,349
348,350
349,350
352,353
353,354
353,355
354,355
354,356
355,356
358,359
358,360
359,360
362,363
362,364
362,365
363,364
363,365
364,365
364,366
365,366
365,367
366,367
370,371
371,372
372,373
372,374
372,375
372,376
373,374
375,376
378,379
378,380
379,380
379,381
380,381
380,382
381,382
381,383
382,383
382,384
383,384
386,387
386,388
387,388
390,391
390,392
391,392
395,396
396,397
396,398
397,398
400,401
401,402
401,403
402,403
404,405
404,406
405,406
405,407
406,407
409,410
409,411
410,411
413,414
413,415
414,415
414,416
415,416
417,418
417,419
418,419
421,422
422,423
423,424
423,425
423,426
423,427
424,425
426,427
426,428
427,428
429,430
429,431
430,431
430,432
431,432
433,434
433,435
434,435
439,440
439,441
440,441
440,442
441,442
441,443
442,443
442,444
443,444
444,445
446,447
446,448
447,448
447,449
448,449
451,452
453,454
453,455
454,455
458,459
459,460
459,461
460,461
463,464
464,465
465,466
465,467
465,468
465,469
466,467
468,469
471,472
471,473
472,473
472,474
473,474
473,475
474,475
474,476
475,476
475,477
476,477
479,480
479,481
480,481
483,484
483,485
484,485
488,489
489,490
489,491
490,491
493,494
494,495
495,496
495,497
496,497
498,499
500,501
500,502
501,502
501,503
502,503
502,504
503,504
506,507
508,509
508,510
509,510
509,511
509,512
510,511
510,512
511,512
511,513
512,513
515,516
515,517
516,517
519,520
519,521
520,521
521,522
521,523
522,523
524,525
524,526
525,526
525,527
526,527
526,528
527,528
530,531
530,532
531,532
535,536
536,537
536,538
536,539
536,540
537,538
539,540
539,541
540,541
542,543
544,545
544,546
545,546
545,547
546,547
549,550
551,552
552,553
552,554
553,554
553,555
554,555
554,556
555,556
555,557
556,557
556,558
557,558
560,561
560,562
561,562
564,565
564,566
565,566
569,570
570,571
570,572
571,572
574,575
574,576
575,576
575,577
576,577
576,578
577,578
577,579
578,579
582,583
582,584
583,584
583,585
584,585
588,589
588,590
588,591
589,590
590,591
590,592
591,592
593,594
593,595
594,595
596,597
596,598
597,598
598,599
598,600
599,600
599,601
600,601
600,602
601,602
604,605
604,606
605,606
608,609
608,610
609,610
613,614
614,615
614,616
615,616
617,618
617,619
618,619
618,620
619,620
622,623
622,624
623,624
624,625
624,626
625,626
625,627
626,627
626,628
627,628
630,631
630,632
631,632
634,635
634,636
635,636
639,640
639,641
639,642
639,643
640,641
641,642
641,643
642,643
644,645
644,646
645,646
648,649
648,650
649,650
652,653
653,654
655,656
655,657
655,658
656,657
657,658
657,659
657,660
657,661
658,659
660,661
662,663
664,665
664,666
665,666
665,667
666,667
666,668
667,668
671,672
672,673
672,674
673,674
676,677
677,678
677,679
678,679
680,681
680,682
681,682
681,683
682,683
686,687
687,688
687,689
688,689
690,691
690,692
691,692
691,693
692,693
696,697
697,698
697,699
698,699
700,701
700,702
701,702
701,703
703,704
705,706
705,707
706,707
709,710
710,711
710,712
711,712
711,713
712,713
715,716
717,718
718,719
718,720
719,720
719,721
720,721
723,724
723,725
724,725
727,728
728,729
728,730
729,730
729,731
730,731
733,734
733,735
734,735
-----nextToken-----
2,4,7,9,10,15,17,18,22,24,25,27,28,30,31,34,36,38,42,44,48,50,54,57,58,62,65,66,69,77,78,81,82,87,88,91,92,97,98,100,105,108,111,112,115,118,119,123,124,125,131,132,133,136,137,138,144,145,146,149,150,151,155,156,157,161,166,167,171,173,176,177,182,183,185,190,193,194,197,198,200,203,204,207,208,211,212,215,216,219,220,223,224,227,228,232,235,236,239,240,245,246,248,256,257,260,261,266,267,270,271,276,277,279,286,287,288,292,293,294,299,303,305,308,314,315,318,319,322,323,324,328,329,336,337,339,346,347,350,351,356,357,360,361,367,368,369,374,376,377,384,385,388,389,392,393,394,398,399,403,407,408,411,412,416,419,420,425,428,432,435,436,437,438,445,449,450,452,455,456,457,461,462,467,469,470,477,478,481,482,485,486,487,491,492,497,499,504,505,507,513,514,517,518,523,528,529,532,533,534,538,541,543,547,548,550,558,559,562,563,566,567,568,572,573,579,580,581,585,586,587,592,595,602,603,606,607,610,611,612,616,620,621,628,629,632,633,636,637,638,643,646,647,650,651,654,659,661,663,668,669,670,674,675,679,683,684,685,689,693,694,695,699,702,704,707,708,713,714,716,721,722,725,726,731,732,735,736
-----computeFrom-----
52,53
52,54
71,72
71,73
72,73
72,74
74,75
74,76
84,85
84,86
94,95
94,96
103,104
103,105
128,129
128,130
141,142
141,143
179,180
179,181
242,243
242,244
250,251
250,252
251,252
251,253
253,254
253,255
263,264
263,265
273,274
273,275
282,283
282,284
283,284
283,285
289,290
289,291
297,298
297,299
309,310
309,311
310,311
310,312
311,312
311,313
331,332
331,333
333,334
333,335
341,342
341,343
343,344
343,345
353,354
353,355
364,365
364,366
378,379
378,380
379,380
379,381
380,381
380,382
401,402
401,403
404,405
404,406
414,415
414,416
426,427
426,428
429,430
429,431
430,431
430,432
439,440
439,441
440,441
440,442
441,442
441,443
446,447
446,448
471,472
471,473
472,473
472,474
473,474
473,475
495,496
495,497
501,502
501,503
510,511
510,512
521,522
521,523
524,525
524,526
525,526
525,527
539,540
539,541
544,545
544,546
552,553
552,554
553,554
553,555
554,555
554,556
575,576
575,577
576,577
576,578
582,583
582,584
590,591
590,592
593,594
593,595
596,597
596,598
598,599
598,600
599,600
599,601
614,615
614,616
617,618
617,619
622,623
622,624
624,625
624,626
625,626
625,627
641,642
641,643
648,649
648,650
664,665
664,666
665,666
665,667
677,678
677,679
680,681
680,682
687,688
687,689
690,691
690,692
710,711
710,712
718,719
718,720
728,729
728,730
-----guardedBy-----
98,246
91,149
82,216
97,245
100,185
92,220
183,240
182,239
279,507
270,683
261,694
276,713
277,714
271,647
292,485
293,486
287,482
360,455
356,411
361,456
367,388
368,389
419,455
416,452
420,450
504,707
505,708
513,566
518,567
517,547
585,668
580,694
586,647
-----guardedByNegation-----
360,485
361,486
513,683
518,694
517,693
-----lastLexicalUse-----
360,485
361,486
513,683
518,694
517,693
-----jump-----
360,485
361,486
513,683
518,694
517,693
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;Declarator;Pointer;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;ConditionalExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ConditionalExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;Pointer;FunctionCallExpression;IdExpression;Name;BinaryExpression;BinaryExpression;BinaryExpression;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;BinaryExpression;BinaryExpression;BinaryExpression;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;BinaryExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;BinaryExpression;BinaryExpression;BinaryExpression;FunctionCallExpression;UnaryExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;BinaryExpression;BinaryExpression;BinaryExpression;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;IfStatement;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;BinaryExpression;UnaryExpression;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;UnaryExpression;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;
-----ast_node-----
static voidImgPhotoInstanceSetSize(    PhotoInstance *instancePtr)	/* Instance whose size is to be changed. */{    PhotoMaster *masterPtr;    schar *newError, *errSrcPtr, *errDestPtr;    int h, offset;    XRectangle validBox;    Pixmap newPixmap;    masterPtr = instancePtr->masterPtr;    TkClipBox(masterPtr->validRegion, &validBox);    if ((instancePtr->width != masterPtr->width)	    || (instancePtr->height != masterPtr->height)	    || (instancePtr->pixels == None)) {	newPixmap = Tk_GetPixmap(instancePtr->display,		RootWindow(instancePtr->display,			instancePtr->visualInfo.screen),		(masterPtr->width > 0) ? masterPtr->width: 1,		(masterPtr->height > 0) ? masterPtr->height: 1,		instancePtr->visualInfo.depth);	if (!newPixmap) {	    Tcl_Panic("Fail to create pixmap with Tk_GetPixmap in ImgPhotoInstanceSetSize.\n");	}	/*	 * The following is a gross hack needed to properly support colormaps	 * under Windows. Before the pixels can be copied to the pixmap, the	 * relevent colormap must be associated with the drawable. Normally we	 * can infer this association from the window that was used to create	 * the pixmap. However, in this case we're using the root window, so	 * we have to be more explicit.	 */	TkSetPixmapColormap(newPixmap, instancePtr->colormap);	if (instancePtr->pixels != None) {	    /*	     * Copy any common pixels from the old pixmap and free it.	     */	    XCopyArea(instancePtr->display, instancePtr->pixels, newPixmap,		    instancePtr->gc, validBox.x, validBox.y,		    validBox.width, validBox.height, validBox.x, validBox.y);	    Tk_FreePixmap(instancePtr->display, instancePtr->pixels);	}	instancePtr->pixels = newPixmap;    }    if ((instancePtr->width != masterPtr->width)	    || (instancePtr->height != masterPtr->height)	    || (instancePtr->error == NULL)) {	if (masterPtr->height > 0 && masterPtr->width > 0) {	    newError = (schar *) ckalloc((unsigned)		    masterPtr->height * masterPtr->width * 3 * sizeof(schar));	    /*	     * Zero the new array so that we don't get bogus error values	     * propagating into areas we dither later.	     */	    if ((instancePtr->error != NULL)		    && ((instancePtr->width == masterPtr->width)		    || (validBox.width == masterPtr->width))) {		if (validBox.y > 0) {		    memset(newError, 0, (size_t)			    validBox.y * masterPtr->width * 3 * sizeof(schar));		}		h = validBox.y + validBox.height;		if (h < masterPtr->height) {		    memset(newError + h*masterPtr->width*3, 0,			    (size_t) (masterPtr->height - h)			    * masterPtr->width * 3 * sizeof(schar));		}	    } else {		memset(newError, 0, (size_t)			masterPtr->height * masterPtr->width *3*sizeof(schar));	    }	} else {	    newError = NULL;	}	if (instancePtr->error != NULL) {	    /*	     * Copy the common area over to the new array and free the old	     * array.	     */	    if (masterPtr->width == instancePtr->width) {		offset = validBox.y * masterPtr->width * 3;		memcpy(newError + offset, instancePtr->error + offset,			((size_t) validBox.height			* masterPtr->width * 3 * sizeof(schar)));	    } else if (validBox.width > 0 && validBox.height > 0) {		errDestPtr = newError +			(validBox.y * masterPtr->width + validBox.x) * 3;		errSrcPtr = instancePtr->error +			(validBox.y * instancePtr->width + validBox.x) * 3;		for (h = validBox.height; h > 0; --h) {		    memcpy(errDestPtr, errSrcPtr,			    validBox.width * 3 * sizeof(schar));		    errDestPtr += masterPtr->width * 3;		    errSrcPtr += instancePtr->width * 3;		}	    }	    ckfree((char *) instancePtr->error);	}	instancePtr->error = newError;    }    instancePtr->width = masterPtr->width;    instancePtr->height = masterPtr->height;}
static void
ImgPhotoInstanceSetSize(    PhotoInstance *instancePtr)
ImgPhotoInstanceSetSize
PhotoInstance *instancePtr
PhotoInstance
PhotoInstance
*instancePtr
*
instancePtr
{    PhotoMaster *masterPtr;    schar *newError, *errSrcPtr, *errDestPtr;    int h, offset;    XRectangle validBox;    Pixmap newPixmap;    masterPtr = instancePtr->masterPtr;    TkClipBox(masterPtr->validRegion, &validBox);    if ((instancePtr->width != masterPtr->width)	    || (instancePtr->height != masterPtr->height)	    || (instancePtr->pixels == None)) {	newPixmap = Tk_GetPixmap(instancePtr->display,		RootWindow(instancePtr->display,			instancePtr->visualInfo.screen),		(masterPtr->width > 0) ? masterPtr->width: 1,		(masterPtr->height > 0) ? masterPtr->height: 1,		instancePtr->visualInfo.depth);	if (!newPixmap) {	    Tcl_Panic("Fail to create pixmap with Tk_GetPixmap in ImgPhotoInstanceSetSize.\n");	}	/*	 * The following is a gross hack needed to properly support colormaps	 * under Windows. Before the pixels can be copied to the pixmap, the	 * relevent colormap must be associated with the drawable. Normally we	 * can infer this association from the window that was used to create	 * the pixmap. However, in this case we're using the root window, so	 * we have to be more explicit.	 */	TkSetPixmapColormap(newPixmap, instancePtr->colormap);	if (instancePtr->pixels != None) {	    /*	     * Copy any common pixels from the old pixmap and free it.	     */	    XCopyArea(instancePtr->display, instancePtr->pixels, newPixmap,		    instancePtr->gc, validBox.x, validBox.y,		    validBox.width, validBox.height, validBox.x, validBox.y);	    Tk_FreePixmap(instancePtr->display, instancePtr->pixels);	}	instancePtr->pixels = newPixmap;    }    if ((instancePtr->width != masterPtr->width)	    || (instancePtr->height != masterPtr->height)	    || (instancePtr->error == NULL)) {	if (masterPtr->height > 0 && masterPtr->width > 0) {	    newError = (schar *) ckalloc((unsigned)		    masterPtr->height * masterPtr->width * 3 * sizeof(schar));	    /*	     * Zero the new array so that we don't get bogus error values	     * propagating into areas we dither later.	     */	    if ((instancePtr->error != NULL)		    && ((instancePtr->width == masterPtr->width)		    || (validBox.width == masterPtr->width))) {		if (validBox.y > 0) {		    memset(newError, 0, (size_t)			    validBox.y * masterPtr->width * 3 * sizeof(schar));		}		h = validBox.y + validBox.height;		if (h < masterPtr->height) {		    memset(newError + h*masterPtr->width*3, 0,			    (size_t) (masterPtr->height - h)			    * masterPtr->width * 3 * sizeof(schar));		}	    } else {		memset(newError, 0, (size_t)			masterPtr->height * masterPtr->width *3*sizeof(schar));	    }	} else {	    newError = NULL;	}	if (instancePtr->error != NULL) {	    /*	     * Copy the common area over to the new array and free the old	     * array.	     */	    if (masterPtr->width == instancePtr->width) {		offset = validBox.y * masterPtr->width * 3;		memcpy(newError + offset, instancePtr->error + offset,			((size_t) validBox.height			* masterPtr->width * 3 * sizeof(schar)));	    } else if (validBox.width > 0 && validBox.height > 0) {		errDestPtr = newError +			(validBox.y * masterPtr->width + validBox.x) * 3;		errSrcPtr = instancePtr->error +			(validBox.y * instancePtr->width + validBox.x) * 3;		for (h = validBox.height; h > 0; --h) {		    memcpy(errDestPtr, errSrcPtr,			    validBox.width * 3 * sizeof(schar));		    errDestPtr += masterPtr->width * 3;		    errSrcPtr += instancePtr->width * 3;		}	    }	    ckfree((char *) instancePtr->error);	}	instancePtr->error = newError;    }    instancePtr->width = masterPtr->width;    instancePtr->height = masterPtr->height;}
PhotoMaster *masterPtr;
PhotoMaster *masterPtr;
PhotoMaster
PhotoMaster
*masterPtr
*
masterPtr
schar *newError, *errSrcPtr, *errDestPtr;
schar *newError, *errSrcPtr, *errDestPtr;
schar
schar
*newError
*
newError
*errSrcPtr
*
errSrcPtr
*errDestPtr
*
errDestPtr
int h, offset;
int h, offset;
int
h
h
offset
offset
XRectangle validBox;
XRectangle validBox;
XRectangle
XRectangle
validBox
validBox
Pixmap newPixmap;
Pixmap newPixmap;
Pixmap
Pixmap
newPixmap
newPixmap
masterPtr = instancePtr->masterPtr;
masterPtr = instancePtr->masterPtr
masterPtr
masterPtr
instancePtr->masterPtr
instancePtr
instancePtr
masterPtr
TkClipBox(masterPtr->validRegion, &validBox);
TkClipBox(masterPtr->validRegion, &validBox)
TkClipBox
TkClipBox
masterPtr->validRegion
masterPtr
masterPtr
validRegion
&validBox
validBox
validBox
if ((instancePtr->width != masterPtr->width)	    || (instancePtr->height != masterPtr->height)	    || (instancePtr->pixels == None)) {	newPixmap = Tk_GetPixmap(instancePtr->display,		RootWindow(instancePtr->display,			instancePtr->visualInfo.screen),		(masterPtr->width > 0) ? masterPtr->width: 1,		(masterPtr->height > 0) ? masterPtr->height: 1,		instancePtr->visualInfo.depth);	if (!newPixmap) {	    Tcl_Panic("Fail to create pixmap with Tk_GetPixmap in ImgPhotoInstanceSetSize.\n");	}	/*	 * The following is a gross hack needed to properly support colormaps	 * under Windows. Before the pixels can be copied to the pixmap, the	 * relevent colormap must be associated with the drawable. Normally we	 * can infer this association from the window that was used to create	 * the pixmap. However, in this case we're using the root window, so	 * we have to be more explicit.	 */	TkSetPixmapColormap(newPixmap, instancePtr->colormap);	if (instancePtr->pixels != None) {	    /*	     * Copy any common pixels from the old pixmap and free it.	     */	    XCopyArea(instancePtr->display, instancePtr->pixels, newPixmap,		    instancePtr->gc, validBox.x, validBox.y,		    validBox.width, validBox.height, validBox.x, validBox.y);	    Tk_FreePixmap(instancePtr->display, instancePtr->pixels);	}	instancePtr->pixels = newPixmap;    }
(instancePtr->width != masterPtr->width)	    || (instancePtr->height != masterPtr->height)	    || (instancePtr->pixels == None)
(instancePtr->width != masterPtr->width)	    || (instancePtr->height != masterPtr->height)
(instancePtr->width != masterPtr->width)
instancePtr->width != masterPtr->width
instancePtr->width
instancePtr
instancePtr
width
masterPtr->width
masterPtr
masterPtr
width
(instancePtr->height != masterPtr->height)
instancePtr->height != masterPtr->height
instancePtr->height
instancePtr
instancePtr
height
masterPtr->height
masterPtr
masterPtr
height
(instancePtr->pixels == None)
instancePtr->pixels == None
instancePtr->pixels
instancePtr
instancePtr
pixels
None
None
{	newPixmap = Tk_GetPixmap(instancePtr->display,		RootWindow(instancePtr->display,			instancePtr->visualInfo.screen),		(masterPtr->width > 0) ? masterPtr->width: 1,		(masterPtr->height > 0) ? masterPtr->height: 1,		instancePtr->visualInfo.depth);	if (!newPixmap) {	    Tcl_Panic("Fail to create pixmap with Tk_GetPixmap in ImgPhotoInstanceSetSize.\n");	}	/*	 * The following is a gross hack needed to properly support colormaps	 * under Windows. Before the pixels can be copied to the pixmap, the	 * relevent colormap must be associated with the drawable. Normally we	 * can infer this association from the window that was used to create	 * the pixmap. However, in this case we're using the root window, so	 * we have to be more explicit.	 */	TkSetPixmapColormap(newPixmap, instancePtr->colormap);	if (instancePtr->pixels != None) {	    /*	     * Copy any common pixels from the old pixmap and free it.	     */	    XCopyArea(instancePtr->display, instancePtr->pixels, newPixmap,		    instancePtr->gc, validBox.x, validBox.y,		    validBox.width, validBox.height, validBox.x, validBox.y);	    Tk_FreePixmap(instancePtr->display, instancePtr->pixels);	}	instancePtr->pixels = newPixmap;    }
newPixmap = Tk_GetPixmap(instancePtr->display,		RootWindow(instancePtr->display,			instancePtr->visualInfo.screen),		(masterPtr->width > 0) ? masterPtr->width: 1,		(masterPtr->height > 0) ? masterPtr->height: 1,		instancePtr->visualInfo.depth);
newPixmap = Tk_GetPixmap(instancePtr->display,		RootWindow(instancePtr->display,			instancePtr->visualInfo.screen),		(masterPtr->width > 0) ? masterPtr->width: 1,		(masterPtr->height > 0) ? masterPtr->height: 1,		instancePtr->visualInfo.depth)
newPixmap
newPixmap
Tk_GetPixmap(instancePtr->display,		RootWindow(instancePtr->display,			instancePtr->visualInfo.screen),		(masterPtr->width > 0) ? masterPtr->width: 1,		(masterPtr->height > 0) ? masterPtr->height: 1,		instancePtr->visualInfo.depth)
Tk_GetPixmap
Tk_GetPixmap
instancePtr->display
instancePtr
instancePtr
display
RootWindow(instancePtr->display,			instancePtr->visualInfo.screen)
RootWindow
RootWindow
instancePtr->display
instancePtr
instancePtr
display
instancePtr->visualInfo.screen
instancePtr->visualInfo
instancePtr
instancePtr
visualInfo
screen
(masterPtr->width > 0) ? masterPtr->width: 1
(masterPtr->width > 0)
masterPtr->width > 0
masterPtr->width
masterPtr
masterPtr
width
0
masterPtr->width
masterPtr
masterPtr
width
1
(masterPtr->height > 0) ? masterPtr->height: 1
(masterPtr->height > 0)
masterPtr->height > 0
masterPtr->height
masterPtr
masterPtr
height
0
masterPtr->height
masterPtr
masterPtr
height
1
instancePtr->visualInfo.depth
instancePtr->visualInfo
instancePtr
instancePtr
visualInfo
depth
if (!newPixmap) {	    Tcl_Panic("Fail to create pixmap with Tk_GetPixmap in ImgPhotoInstanceSetSize.\n");	}
!newPixmap
newPixmap
newPixmap
{	    Tcl_Panic("Fail to create pixmap with Tk_GetPixmap in ImgPhotoInstanceSetSize.\n");	}
Tcl_Panic("Fail to create pixmap with Tk_GetPixmap in ImgPhotoInstanceSetSize.\n");
Tcl_Panic("Fail to create pixmap with Tk_GetPixmap in ImgPhotoInstanceSetSize.\n")
Tcl_Panic
Tcl_Panic
"Fail to create pixmap with Tk_GetPixmap in ImgPhotoInstanceSetSize.\n"
TkSetPixmapColormap(newPixmap, instancePtr->colormap);
TkSetPixmapColormap(newPixmap, instancePtr->colormap)
TkSetPixmapColormap
TkSetPixmapColormap
newPixmap
newPixmap
instancePtr->colormap
instancePtr
instancePtr
colormap
if (instancePtr->pixels != None) {	    /*	     * Copy any common pixels from the old pixmap and free it.	     */	    XCopyArea(instancePtr->display, instancePtr->pixels, newPixmap,		    instancePtr->gc, validBox.x, validBox.y,		    validBox.width, validBox.height, validBox.x, validBox.y);	    Tk_FreePixmap(instancePtr->display, instancePtr->pixels);	}
instancePtr->pixels != None
instancePtr->pixels
instancePtr
instancePtr
pixels
None
None
{	    /*	     * Copy any common pixels from the old pixmap and free it.	     */	    XCopyArea(instancePtr->display, instancePtr->pixels, newPixmap,		    instancePtr->gc, validBox.x, validBox.y,		    validBox.width, validBox.height, validBox.x, validBox.y);	    Tk_FreePixmap(instancePtr->display, instancePtr->pixels);	}
XCopyArea(instancePtr->display, instancePtr->pixels, newPixmap,		    instancePtr->gc, validBox.x, validBox.y,		    validBox.width, validBox.height, validBox.x, validBox.y);
XCopyArea(instancePtr->display, instancePtr->pixels, newPixmap,		    instancePtr->gc, validBox.x, validBox.y,		    validBox.width, validBox.height, validBox.x, validBox.y)
XCopyArea
XCopyArea
instancePtr->display
instancePtr
instancePtr
display
instancePtr->pixels
instancePtr
instancePtr
pixels
newPixmap
newPixmap
instancePtr->gc
instancePtr
instancePtr
gc
validBox.x
validBox
validBox
x
validBox.y
validBox
validBox
y
validBox.width
validBox
validBox
width
validBox.height
validBox
validBox
height
validBox.x
validBox
validBox
x
validBox.y
validBox
validBox
y
Tk_FreePixmap(instancePtr->display, instancePtr->pixels);
Tk_FreePixmap(instancePtr->display, instancePtr->pixels)
Tk_FreePixmap
Tk_FreePixmap
instancePtr->display
instancePtr
instancePtr
display
instancePtr->pixels
instancePtr
instancePtr
pixels
instancePtr->pixels = newPixmap;
instancePtr->pixels = newPixmap
instancePtr->pixels
instancePtr
instancePtr
pixels
newPixmap
newPixmap
if ((instancePtr->width != masterPtr->width)	    || (instancePtr->height != masterPtr->height)	    || (instancePtr->error == NULL)) {	if (masterPtr->height > 0 && masterPtr->width > 0) {	    newError = (schar *) ckalloc((unsigned)		    masterPtr->height * masterPtr->width * 3 * sizeof(schar));	    /*	     * Zero the new array so that we don't get bogus error values	     * propagating into areas we dither later.	     */	    if ((instancePtr->error != NULL)		    && ((instancePtr->width == masterPtr->width)		    || (validBox.width == masterPtr->width))) {		if (validBox.y > 0) {		    memset(newError, 0, (size_t)			    validBox.y * masterPtr->width * 3 * sizeof(schar));		}		h = validBox.y + validBox.height;		if (h < masterPtr->height) {		    memset(newError + h*masterPtr->width*3, 0,			    (size_t) (masterPtr->height - h)			    * masterPtr->width * 3 * sizeof(schar));		}	    } else {		memset(newError, 0, (size_t)			masterPtr->height * masterPtr->width *3*sizeof(schar));	    }	} else {	    newError = NULL;	}	if (instancePtr->error != NULL) {	    /*	     * Copy the common area over to the new array and free the old	     * array.	     */	    if (masterPtr->width == instancePtr->width) {		offset = validBox.y * masterPtr->width * 3;		memcpy(newError + offset, instancePtr->error + offset,			((size_t) validBox.height			* masterPtr->width * 3 * sizeof(schar)));	    } else if (validBox.width > 0 && validBox.height > 0) {		errDestPtr = newError +			(validBox.y * masterPtr->width + validBox.x) * 3;		errSrcPtr = instancePtr->error +			(validBox.y * instancePtr->width + validBox.x) * 3;		for (h = validBox.height; h > 0; --h) {		    memcpy(errDestPtr, errSrcPtr,			    validBox.width * 3 * sizeof(schar));		    errDestPtr += masterPtr->width * 3;		    errSrcPtr += instancePtr->width * 3;		}	    }	    ckfree((char *) instancePtr->error);	}	instancePtr->error = newError;    }
(instancePtr->width != masterPtr->width)	    || (instancePtr->height != masterPtr->height)	    || (instancePtr->error == NULL)
(instancePtr->width != masterPtr->width)	    || (instancePtr->height != masterPtr->height)
(instancePtr->width != masterPtr->width)
instancePtr->width != masterPtr->width
instancePtr->width
instancePtr
instancePtr
width
masterPtr->width
masterPtr
masterPtr
width
(instancePtr->height != masterPtr->height)
instancePtr->height != masterPtr->height
instancePtr->height
instancePtr
instancePtr
height
masterPtr->height
masterPtr
masterPtr
height
(instancePtr->error == NULL)
instancePtr->error == NULL
instancePtr->error
instancePtr
instancePtr
error
NULL
NULL
{	if (masterPtr->height > 0 && masterPtr->width > 0) {	    newError = (schar *) ckalloc((unsigned)		    masterPtr->height * masterPtr->width * 3 * sizeof(schar));	    /*	     * Zero the new array so that we don't get bogus error values	     * propagating into areas we dither later.	     */	    if ((instancePtr->error != NULL)		    && ((instancePtr->width == masterPtr->width)		    || (validBox.width == masterPtr->width))) {		if (validBox.y > 0) {		    memset(newError, 0, (size_t)			    validBox.y * masterPtr->width * 3 * sizeof(schar));		}		h = validBox.y + validBox.height;		if (h < masterPtr->height) {		    memset(newError + h*masterPtr->width*3, 0,			    (size_t) (masterPtr->height - h)			    * masterPtr->width * 3 * sizeof(schar));		}	    } else {		memset(newError, 0, (size_t)			masterPtr->height * masterPtr->width *3*sizeof(schar));	    }	} else {	    newError = NULL;	}	if (instancePtr->error != NULL) {	    /*	     * Copy the common area over to the new array and free the old	     * array.	     */	    if (masterPtr->width == instancePtr->width) {		offset = validBox.y * masterPtr->width * 3;		memcpy(newError + offset, instancePtr->error + offset,			((size_t) validBox.height			* masterPtr->width * 3 * sizeof(schar)));	    } else if (validBox.width > 0 && validBox.height > 0) {		errDestPtr = newError +			(validBox.y * masterPtr->width + validBox.x) * 3;		errSrcPtr = instancePtr->error +			(validBox.y * instancePtr->width + validBox.x) * 3;		for (h = validBox.height; h > 0; --h) {		    memcpy(errDestPtr, errSrcPtr,			    validBox.width * 3 * sizeof(schar));		    errDestPtr += masterPtr->width * 3;		    errSrcPtr += instancePtr->width * 3;		}	    }	    ckfree((char *) instancePtr->error);	}	instancePtr->error = newError;    }
if (masterPtr->height > 0 && masterPtr->width > 0) {	    newError = (schar *) ckalloc((unsigned)		    masterPtr->height * masterPtr->width * 3 * sizeof(schar));	    /*	     * Zero the new array so that we don't get bogus error values	     * propagating into areas we dither later.	     */	    if ((instancePtr->error != NULL)		    && ((instancePtr->width == masterPtr->width)		    || (validBox.width == masterPtr->width))) {		if (validBox.y > 0) {		    memset(newError, 0, (size_t)			    validBox.y * masterPtr->width * 3 * sizeof(schar));		}		h = validBox.y + validBox.height;		if (h < masterPtr->height) {		    memset(newError + h*masterPtr->width*3, 0,			    (size_t) (masterPtr->height - h)			    * masterPtr->width * 3 * sizeof(schar));		}	    } else {		memset(newError, 0, (size_t)			masterPtr->height * masterPtr->width *3*sizeof(schar));	    }	} else {	    newError = NULL;	}
masterPtr->height > 0 && masterPtr->width > 0
masterPtr->height > 0
masterPtr->height
masterPtr
masterPtr
height
0
masterPtr->width > 0
masterPtr->width
masterPtr
masterPtr
width
0
{	    newError = (schar *) ckalloc((unsigned)		    masterPtr->height * masterPtr->width * 3 * sizeof(schar));	    /*	     * Zero the new array so that we don't get bogus error values	     * propagating into areas we dither later.	     */	    if ((instancePtr->error != NULL)		    && ((instancePtr->width == masterPtr->width)		    || (validBox.width == masterPtr->width))) {		if (validBox.y > 0) {		    memset(newError, 0, (size_t)			    validBox.y * masterPtr->width * 3 * sizeof(schar));		}		h = validBox.y + validBox.height;		if (h < masterPtr->height) {		    memset(newError + h*masterPtr->width*3, 0,			    (size_t) (masterPtr->height - h)			    * masterPtr->width * 3 * sizeof(schar));		}	    } else {		memset(newError, 0, (size_t)			masterPtr->height * masterPtr->width *3*sizeof(schar));	    }	}
newError = (schar *) ckalloc((unsigned)		    masterPtr->height * masterPtr->width * 3 * sizeof(schar));
newError = (schar *) ckalloc((unsigned)		    masterPtr->height * masterPtr->width * 3 * sizeof(schar))
newError
newError
(schar *) ckalloc((unsigned)		    masterPtr->height * masterPtr->width * 3 * sizeof(schar))
schar *
schar
schar
*
*
ckalloc((unsigned)		    masterPtr->height * masterPtr->width * 3 * sizeof(schar))
ckalloc
ckalloc
(unsigned)		    masterPtr->height * masterPtr->width * 3 * sizeof(schar)
(unsigned)		    masterPtr->height * masterPtr->width * 3
(unsigned)		    masterPtr->height * masterPtr->width
(unsigned)		    masterPtr->height
unsigned
unsigned

masterPtr->height
masterPtr
masterPtr
height
masterPtr->width
masterPtr
masterPtr
width
3
sizeof(schar)
schar
schar
schar

if ((instancePtr->error != NULL)		    && ((instancePtr->width == masterPtr->width)		    || (validBox.width == masterPtr->width))) {		if (validBox.y > 0) {		    memset(newError, 0, (size_t)			    validBox.y * masterPtr->width * 3 * sizeof(schar));		}		h = validBox.y + validBox.height;		if (h < masterPtr->height) {		    memset(newError + h*masterPtr->width*3, 0,			    (size_t) (masterPtr->height - h)			    * masterPtr->width * 3 * sizeof(schar));		}	    } else {		memset(newError, 0, (size_t)			masterPtr->height * masterPtr->width *3*sizeof(schar));	    }
(instancePtr->error != NULL)		    && ((instancePtr->width == masterPtr->width)		    || (validBox.width == masterPtr->width))
(instancePtr->error != NULL)
instancePtr->error != NULL
instancePtr->error
instancePtr
instancePtr
error
NULL
NULL
((instancePtr->width == masterPtr->width)		    || (validBox.width == masterPtr->width))
(instancePtr->width == masterPtr->width)		    || (validBox.width == masterPtr->width)
(instancePtr->width == masterPtr->width)
instancePtr->width == masterPtr->width
instancePtr->width
instancePtr
instancePtr
width
masterPtr->width
masterPtr
masterPtr
width
(validBox.width == masterPtr->width)
validBox.width == masterPtr->width
validBox.width
validBox
validBox
width
masterPtr->width
masterPtr
masterPtr
width
{		if (validBox.y > 0) {		    memset(newError, 0, (size_t)			    validBox.y * masterPtr->width * 3 * sizeof(schar));		}		h = validBox.y + validBox.height;		if (h < masterPtr->height) {		    memset(newError + h*masterPtr->width*3, 0,			    (size_t) (masterPtr->height - h)			    * masterPtr->width * 3 * sizeof(schar));		}	    }
if (validBox.y > 0) {		    memset(newError, 0, (size_t)			    validBox.y * masterPtr->width * 3 * sizeof(schar));		}
validBox.y > 0
validBox.y
validBox
validBox
y
0
{		    memset(newError, 0, (size_t)			    validBox.y * masterPtr->width * 3 * sizeof(schar));		}
memset(newError, 0, (size_t)			    validBox.y * masterPtr->width * 3 * sizeof(schar));
memset(newError, 0, (size_t)			    validBox.y * masterPtr->width * 3 * sizeof(schar))
memset
memset
newError
newError
0
(size_t)			    validBox.y * masterPtr->width * 3 * sizeof(schar)
(size_t)			    validBox.y * masterPtr->width * 3
(size_t)			    validBox.y * masterPtr->width
(size_t)			    validBox.y
size_t
size_t
size_t

validBox.y
validBox
validBox
y
masterPtr->width
masterPtr
masterPtr
width
3
sizeof(schar)
schar
schar
schar

h = validBox.y + validBox.height;
h = validBox.y + validBox.height
h
h
validBox.y + validBox.height
validBox.y
validBox
validBox
y
validBox.height
validBox
validBox
height
if (h < masterPtr->height) {		    memset(newError + h*masterPtr->width*3, 0,			    (size_t) (masterPtr->height - h)			    * masterPtr->width * 3 * sizeof(schar));		}
h < masterPtr->height
h
h
masterPtr->height
masterPtr
masterPtr
height
{		    memset(newError + h*masterPtr->width*3, 0,			    (size_t) (masterPtr->height - h)			    * masterPtr->width * 3 * sizeof(schar));		}
memset(newError + h*masterPtr->width*3, 0,			    (size_t) (masterPtr->height - h)			    * masterPtr->width * 3 * sizeof(schar));
memset(newError + h*masterPtr->width*3, 0,			    (size_t) (masterPtr->height - h)			    * masterPtr->width * 3 * sizeof(schar))
memset
memset
newError + h*masterPtr->width*3
newError
newError
h*masterPtr->width*3
h*masterPtr->width
h
h
masterPtr->width
masterPtr
masterPtr
width
3
0
(size_t) (masterPtr->height - h)			    * masterPtr->width * 3 * sizeof(schar)
(size_t) (masterPtr->height - h)			    * masterPtr->width * 3
(size_t) (masterPtr->height - h)			    * masterPtr->width
(size_t) (masterPtr->height - h)
(size_t)
size_t
size_t
masterPtr->height - h
masterPtr->height
masterPtr
masterPtr
height
h
h
masterPtr->width
masterPtr
masterPtr
width
3
sizeof(schar)
schar
schar
schar

{		memset(newError, 0, (size_t)			masterPtr->height * masterPtr->width *3*sizeof(schar));	    }
memset(newError, 0, (size_t)			masterPtr->height * masterPtr->width *3*sizeof(schar));
memset(newError, 0, (size_t)			masterPtr->height * masterPtr->width *3*sizeof(schar))
memset
memset
newError
newError
0
(size_t)			masterPtr->height * masterPtr->width *3*sizeof(schar)
(size_t)			masterPtr->height * masterPtr->width *3
(size_t)			masterPtr->height * masterPtr->width
(size_t)			masterPtr->height
size_t
size_t
size_t

masterPtr->height
masterPtr
masterPtr
height
masterPtr->width
masterPtr
masterPtr
width
3
sizeof(schar)
schar
schar
schar

{	    newError = NULL;	}
newError = NULL;
newError = NULL
newError
newError
NULL
NULL
if (instancePtr->error != NULL) {	    /*	     * Copy the common area over to the new array and free the old	     * array.	     */	    if (masterPtr->width == instancePtr->width) {		offset = validBox.y * masterPtr->width * 3;		memcpy(newError + offset, instancePtr->error + offset,			((size_t) validBox.height			* masterPtr->width * 3 * sizeof(schar)));	    } else if (validBox.width > 0 && validBox.height > 0) {		errDestPtr = newError +			(validBox.y * masterPtr->width + validBox.x) * 3;		errSrcPtr = instancePtr->error +			(validBox.y * instancePtr->width + validBox.x) * 3;		for (h = validBox.height; h > 0; --h) {		    memcpy(errDestPtr, errSrcPtr,			    validBox.width * 3 * sizeof(schar));		    errDestPtr += masterPtr->width * 3;		    errSrcPtr += instancePtr->width * 3;		}	    }	    ckfree((char *) instancePtr->error);	}
instancePtr->error != NULL
instancePtr->error
instancePtr
instancePtr
error
NULL
NULL
{	    /*	     * Copy the common area over to the new array and free the old	     * array.	     */	    if (masterPtr->width == instancePtr->width) {		offset = validBox.y * masterPtr->width * 3;		memcpy(newError + offset, instancePtr->error + offset,			((size_t) validBox.height			* masterPtr->width * 3 * sizeof(schar)));	    } else if (validBox.width > 0 && validBox.height > 0) {		errDestPtr = newError +			(validBox.y * masterPtr->width + validBox.x) * 3;		errSrcPtr = instancePtr->error +			(validBox.y * instancePtr->width + validBox.x) * 3;		for (h = validBox.height; h > 0; --h) {		    memcpy(errDestPtr, errSrcPtr,			    validBox.width * 3 * sizeof(schar));		    errDestPtr += masterPtr->width * 3;		    errSrcPtr += instancePtr->width * 3;		}	    }	    ckfree((char *) instancePtr->error);	}
if (masterPtr->width == instancePtr->width) {		offset = validBox.y * masterPtr->width * 3;		memcpy(newError + offset, instancePtr->error + offset,			((size_t) validBox.height			* masterPtr->width * 3 * sizeof(schar)));	    } else if (validBox.width > 0 && validBox.height > 0) {		errDestPtr = newError +			(validBox.y * masterPtr->width + validBox.x) * 3;		errSrcPtr = instancePtr->error +			(validBox.y * instancePtr->width + validBox.x) * 3;		for (h = validBox.height; h > 0; --h) {		    memcpy(errDestPtr, errSrcPtr,			    validBox.width * 3 * sizeof(schar));		    errDestPtr += masterPtr->width * 3;		    errSrcPtr += instancePtr->width * 3;		}	    }
masterPtr->width == instancePtr->width
masterPtr->width
masterPtr
masterPtr
width
instancePtr->width
instancePtr
instancePtr
width
{		offset = validBox.y * masterPtr->width * 3;		memcpy(newError + offset, instancePtr->error + offset,			((size_t) validBox.height			* masterPtr->width * 3 * sizeof(schar)));	    }
offset = validBox.y * masterPtr->width * 3;
offset = validBox.y * masterPtr->width * 3
offset
offset
validBox.y * masterPtr->width * 3
validBox.y * masterPtr->width
validBox.y
validBox
validBox
y
masterPtr->width
masterPtr
masterPtr
width
3
memcpy(newError + offset, instancePtr->error + offset,			((size_t) validBox.height			* masterPtr->width * 3 * sizeof(schar)));
memcpy(newError + offset, instancePtr->error + offset,			((size_t) validBox.height			* masterPtr->width * 3 * sizeof(schar)))
memcpy
memcpy
newError + offset
newError
newError
offset
offset
instancePtr->error + offset
instancePtr->error
instancePtr
instancePtr
error
offset
offset
((size_t) validBox.height			* masterPtr->width * 3 * sizeof(schar))
(size_t) validBox.height			* masterPtr->width * 3 * sizeof(schar)
(size_t) validBox.height			* masterPtr->width * 3
(size_t) validBox.height			* masterPtr->width
(size_t) validBox.height
size_t
size_t
size_t

validBox.height
validBox
validBox
height
masterPtr->width
masterPtr
masterPtr
width
3
sizeof(schar)
schar
schar
schar

if (validBox.width > 0 && validBox.height > 0) {		errDestPtr = newError +			(validBox.y * masterPtr->width + validBox.x) * 3;		errSrcPtr = instancePtr->error +			(validBox.y * instancePtr->width + validBox.x) * 3;		for (h = validBox.height; h > 0; --h) {		    memcpy(errDestPtr, errSrcPtr,			    validBox.width * 3 * sizeof(schar));		    errDestPtr += masterPtr->width * 3;		    errSrcPtr += instancePtr->width * 3;		}	    }
validBox.width > 0 && validBox.height > 0
validBox.width > 0
validBox.width
validBox
validBox
width
0
validBox.height > 0
validBox.height
validBox
validBox
height
0
{		errDestPtr = newError +			(validBox.y * masterPtr->width + validBox.x) * 3;		errSrcPtr = instancePtr->error +			(validBox.y * instancePtr->width + validBox.x) * 3;		for (h = validBox.height; h > 0; --h) {		    memcpy(errDestPtr, errSrcPtr,			    validBox.width * 3 * sizeof(schar));		    errDestPtr += masterPtr->width * 3;		    errSrcPtr += instancePtr->width * 3;		}	    }
errDestPtr = newError +			(validBox.y * masterPtr->width + validBox.x) * 3;
errDestPtr = newError +			(validBox.y * masterPtr->width + validBox.x) * 3
errDestPtr
errDestPtr
newError +			(validBox.y * masterPtr->width + validBox.x) * 3
newError
newError
(validBox.y * masterPtr->width + validBox.x) * 3
(validBox.y * masterPtr->width + validBox.x)
validBox.y * masterPtr->width + validBox.x
validBox.y * masterPtr->width
validBox.y
validBox
validBox
y
masterPtr->width
masterPtr
masterPtr
width
validBox.x
validBox
validBox
x
3
errSrcPtr = instancePtr->error +			(validBox.y * instancePtr->width + validBox.x) * 3;
errSrcPtr = instancePtr->error +			(validBox.y * instancePtr->width + validBox.x) * 3
errSrcPtr
errSrcPtr
instancePtr->error +			(validBox.y * instancePtr->width + validBox.x) * 3
instancePtr->error
instancePtr
instancePtr
error
(validBox.y * instancePtr->width + validBox.x) * 3
(validBox.y * instancePtr->width + validBox.x)
validBox.y * instancePtr->width + validBox.x
validBox.y * instancePtr->width
validBox.y
validBox
validBox
y
instancePtr->width
instancePtr
instancePtr
width
validBox.x
validBox
validBox
x
3
for (h = validBox.height; h > 0; --h) {		    memcpy(errDestPtr, errSrcPtr,			    validBox.width * 3 * sizeof(schar));		    errDestPtr += masterPtr->width * 3;		    errSrcPtr += instancePtr->width * 3;		}
h = validBox.height;
h = validBox.height
h
h
validBox.height
validBox
validBox
height
h > 0
h
h
0
--h
h
h
{		    memcpy(errDestPtr, errSrcPtr,			    validBox.width * 3 * sizeof(schar));		    errDestPtr += masterPtr->width * 3;		    errSrcPtr += instancePtr->width * 3;		}
memcpy(errDestPtr, errSrcPtr,			    validBox.width * 3 * sizeof(schar));
memcpy(errDestPtr, errSrcPtr,			    validBox.width * 3 * sizeof(schar))
memcpy
memcpy
errDestPtr
errDestPtr
errSrcPtr
errSrcPtr
validBox.width * 3 * sizeof(schar)
validBox.width * 3
validBox.width
validBox
validBox
width
3
sizeof(schar)
schar
schar
schar

errDestPtr += masterPtr->width * 3;
errDestPtr += masterPtr->width * 3
errDestPtr
errDestPtr
masterPtr->width * 3
masterPtr->width
masterPtr
masterPtr
width
3
errSrcPtr += instancePtr->width * 3;
errSrcPtr += instancePtr->width * 3
errSrcPtr
errSrcPtr
instancePtr->width * 3
instancePtr->width
instancePtr
instancePtr
width
3
ckfree((char *) instancePtr->error);
ckfree((char *) instancePtr->error)
ckfree
ckfree
(char *) instancePtr->error
char *
char
*
*
instancePtr->error
instancePtr
instancePtr
error
instancePtr->error = newError;
instancePtr->error = newError
instancePtr->error
instancePtr
instancePtr
error
newError
newError
instancePtr->width = masterPtr->width;
instancePtr->width = masterPtr->width
instancePtr->width
instancePtr
instancePtr
width
masterPtr->width
masterPtr
masterPtr
width
instancePtr->height = masterPtr->height;
instancePtr->height = masterPtr->height
instancePtr->height
instancePtr
instancePtr
height
masterPtr->height
masterPtr
masterPtr
height
-----joern-----
(320,310,0)
(5,12,0)
(460,366,0)
(88,416,0)
(292,252,0)
(345,268,0)
(184,377,0)
(186,288,0)
(414,315,0)
(459,250,0)
(40,235,0)
(17,333,0)
(445,157,0)
(161,357,0)
(219,9,0)
(266,375,0)
(209,372,0)
(223,157,0)
(242,350,0)
(156,460,0)
(184,51,0)
(221,314,0)
(354,277,0)
(359,314,0)
(168,452,0)
(31,237,0)
(159,55,0)
(378,367,0)
(70,92,0)
(178,324,0)
(179,458,0)
(434,459,0)
(251,342,0)
(453,252,0)
(168,98,0)
(63,95,0)
(298,140,0)
(7,89,0)
(224,197,0)
(464,127,0)
(307,431,0)
(111,262,0)
(109,157,0)
(150,350,0)
(134,123,0)
(276,370,0)
(65,230,0)
(34,440,0)
(190,159,0)
(227,20,0)
(405,333,0)
(237,460,0)
(285,414,0)
(338,115,0)
(163,116,0)
(278,197,0)
(204,317,0)
(226,160,0)
(353,454,0)
(60,437,0)
(355,378,0)
(312,22,0)
(290,207,0)
(456,279,0)
(140,319,0)
(286,102,0)
(137,181,0)
(332,26,0)
(320,308,0)
(275,422,0)
(22,312,0)
(174,399,0)
(145,178,0)
(252,342,0)
(176,246,0)
(182,418,0)
(324,363,0)
(38,65,0)
(297,380,0)
(431,197,0)
(21,14,0)
(298,42,0)
(207,342,0)
(375,194,0)
(45,87,0)
(151,165,0)
(385,183,0)
(17,314,0)
(235,288,0)
(16,157,0)
(315,85,0)
(406,439,0)
(435,145,0)
(226,331,0)
(366,342,0)
(106,165,0)
(145,287,0)
(460,27,0)
(283,241,0)
(460,467,0)
(441,192,0)
(159,342,0)
(199,395,0)
(429,304,0)
(114,43,0)
(216,22,0)
(460,393,0)
(431,326,0)
(265,17,0)
(192,172,0)
(422,275,0)
(398,316,0)
(80,192,0)
(250,459,0)
(382,429,0)
(339,374,0)
(421,157,0)
(286,347,0)
(139,179,0)
(237,342,0)
(36,165,0)
(436,455,0)
(61,331,0)
(104,213,0)
(13,317,0)
(203,358,0)
(161,417,0)
(411,269,0)
(441,314,0)
(294,382,0)
(218,312,0)
(28,367,0)
(446,3,0)
(26,20,0)
(444,262,0)
(166,251,0)
(405,112,0)
(416,12,0)
(445,239,0)
(118,157,0)
(48,338,0)
(98,168,0)
(468,121,0)
(343,444,0)
(58,422,0)
(302,90,0)
(227,123,0)
(188,169,0)
(298,440,0)
(441,247,0)
(62,118,0)
(244,12,0)
(20,95,0)
(120,312,0)
(336,27,0)
(412,143,0)
(328,146,0)
(390,326,0)
(281,380,0)
(462,351,0)
(422,140,0)
(313,332,0)
(133,175,0)
(152,159,0)
(205,460,0)
(437,113,0)
(419,302,0)
(447,41,0)
(460,12,0)
(296,320,0)
(193,268,0)
(448,287,0)
(275,225,0)
(258,53,0)
(22,342,0)
(417,161,0)
(191,123,0)
(418,182,0)
(110,317,0)
(277,189,0)
(51,184,0)
(292,454,0)
(121,157,0)
(389,7,0)
(441,324,0)
(254,127,0)
(184,6,0)
(215,88,0)
(144,314,0)
(120,309,0)
(157,165,0)
(178,145,0)
(220,102,0)
(429,41,0)
(122,93,0)
(164,319,0)
(50,23,0)
(125,421,0)
(383,254,0)
(180,157,0)
(138,280,0)
(443,157,0)
(141,241,0)
(43,342,0)
(246,146,0)
(403,51,0)
(302,419,0)
(345,165,0)
(378,355,0)
(309,120,0)
(182,12,0)
(212,218,0)
(221,192,0)
(30,375,0)
(429,382,0)
(386,156,0)
(375,266,0)
(39,177,0)
(72,116,0)
(178,87,0)
(406,442,0)
(456,369,0)
(454,292,0)
(137,292,0)
(303,8,0)
(341,217,0)
(55,159,0)
(240,232,0)
(115,338,0)
(75,398,0)
(113,437,0)
(218,157,0)
(57,60,0)
(250,57,0)
(304,213,0)
(407,156,0)
(121,367,0)
(302,6,0)
(451,165,0)
(204,286,0)
(213,147,0)
(333,17,0)
(348,366,0)
(325,165,0)
(47,418,0)
(247,363,0)
(98,342,0)
(217,365,0)
(366,460,0)
(101,365,0)
(87,45,0)
(427,418,0)
(277,192,0)
(77,161,0)
(298,310,0)
(241,157,0)
(358,95,0)
(54,460,0)
(261,298,0)
(284,12,0)
(269,342,0)
(379,368,0)
(384,165,0)
(153,52,0)
(292,137,0)
(175,43,0)
(77,157,0)
(413,77,0)
(128,254,0)
(461,1,0)
(232,244,0)
(330,238,0)
(158,205,0)
(85,136,0)
(14,168,0)
(392,308,0)
(84,282,0)
(146,157,0)
(347,286,0)
(428,235,0)
(269,344,0)
(466,5,0)
(341,370,0)
(150,181,0)
(423,358,0)
(436,157,0)
(367,378,0)
(323,277,0)
(246,262,0)
(217,341,0)
(235,342,0)
(12,183,0)
(41,192,0)
(256,302,0)
(404,369,0)
(68,395,0)
(38,342,0)
(264,456,0)
(310,320,0)
(197,431,0)
(262,182,0)
(309,180,0)
(76,436,0)
(131,41,0)
(382,294,0)
(74,334,0)
(316,214,0)
(230,65,0)
(268,345,0)
(147,213,0)
(454,157,0)
(6,302,0)
(228,63,0)
(169,342,0)
(410,251,0)
(239,445,0)
(352,227,0)
(408,202,0)
(262,246,0)
(418,342,0)
(192,340,0)
(371,321,0)
(324,441,0)
(43,175,0)
(416,183,0)
(243,372,0)
(260,165,0)
(271,172,0)
(60,57,0)
(18,38,0)
(310,310,0)
(388,347,0)
(430,437,0)
(344,452,0)
(194,375,0)
(93,177,0)
(82,199,0)
(398,157,0)
(321,50,0)
(208,445,0)
(291,421,0)
(327,115,0)
(214,239,0)
(196,98,0)
(421,458,0)
(120,230,0)
(116,266,0)
(460,92,0)
(439,342,0)
(179,342,0)
(181,137,0)
(372,460,0)
(395,68,0)
(171,298,0)
(391,439,0)
(78,395,0)
(67,3,0)
(26,419,0)
(333,405,0)
(382,241,0)
(310,440,0)
(14,157,0)
(395,199,0)
(52,345,0)
(329,55,0)
(444,157,0)
(331,266,0)
(24,16,0)
(68,298,0)
(324,338,0)
(295,377,0)
(116,157,0)
(45,198,0)
(160,226,0)
(32,113,0)
(148,165,0)
(312,218,0)
(142,98,0)
(100,121,0)
(23,50,0)
(222,269,0)
(419,192,0)
(27,460,0)
(68,1,0)
(202,157,0)
(86,198,0)
(182,326,0)
(356,370,0)
(187,26,0)
(452,168,0)
(213,304,0)
(232,342,0)
(169,188,0)
(438,183,0)
(92,460,0)
(455,436,0)
(143,377,0)
(41,362,0)
(457,165,0)
(161,77,0)
(127,254,0)
(135,350,0)
(345,52,0)
(440,319,0)
(460,205,0)
(322,247,0)
(6,378,0)
(409,92,0)
(469,393,0)
(0,88,0)
(304,238,0)
(367,20,0)
(424,136,0)
(181,288,0)
(308,320,0)
(442,406,0)
(64,464,0)
(309,91,0)
(449,374,0)
(92,342,0)
(1,68,0)
(61,340,0)
(59,280,0)
(162,334,0)
(17,140,0)
(167,340,0)
(357,161,0)
(273,310,0)
(306,112,0)
(279,456,0)
(117,63,0)
(25,417,0)
(263,29,0)
(69,316,0)
(10,177,0)
(326,182,0)
(257,275,0)
(79,416,0)
(15,53,0)
(399,87,0)
(463,393,0)
(182,279,0)
(380,282,0)
(365,217,0)
(393,460,0)
(326,431,0)
(83,287,0)
(57,250,0)
(334,221,0)
(124,232,0)
(373,51,0)
(20,53,0)
(452,357,0)
(394,207,0)
(274,180,0)
(177,93,0)
(33,415,0)
(85,315,0)
(102,286,0)
(234,368,0)
(175,182,0)
(432,444,0)
(370,341,0)
(44,179,0)
(73,45,0)
(81,237,0)
(460,237,0)
(377,143,0)
(347,342,0)
(305,38,0)
(99,165,0)
(458,421,0)
(238,157,0)
(188,339,0)
(415,282,0)
(12,182,0)
(91,309,0)
(339,188,0)
(37,239,0)
(146,246,0)
(168,14,0)
(255,66,0)
(351,365,0)
(378,6,0)
(50,321,0)
(181,150,0)
(304,429,0)
(16,342,0)
(350,150,0)
(60,368,0)
(335,443,0)
(316,398,0)
(266,331,0)
(332,202,0)
(95,63,0)
(414,157,0)
(94,347,0)
(334,342,0)
(452,344,0)
(88,342,0)
(97,366,0)
(310,42,0)
(19,442,0)
(289,169,0)
(202,332,0)
(229,22,0)
(439,406,0)
(182,262,0)
(425,344,0)
(126,419,0)
(340,61,0)
(450,441,0)
(123,227,0)
(287,145,0)
(51,157,0)
(157,16,0)
(201,23,0)
(248,308,0)
(140,17,0)
(417,342,0)
(226,443,0)
(211,223,0)
(422,42,0)
(406,440,0)
(401,321,0)
(400,221,0)
(308,342,0)
(225,157,0)
(368,60,0)
(367,121,0)
(364,91,0)
(241,382,0)
(132,351,0)
(338,324,0)
(315,414,0)
(460,372,0)
(50,405,0)
(150,280,0)
(239,214,0)
(311,436,0)
(266,116,0)
(340,167,0)
(17,192,0)
(399,157,0)
(377,184,0)
(195,165,0)
(247,85,0)
(173,27,0)
(56,1,0)
(357,452,0)
(381,464,0)
(129,445,0)
(344,269,0)
(26,332,0)
(85,247,0)
(251,455,0)
(279,207,0)
(136,85,0)
(360,202,0)
(221,8,0)
(396,459,0)
(419,26,0)
(87,178,0)
(455,251,0)
(458,165,0)
(214,316,0)
(337,91,0)
(365,351,0)
(252,292,0)
(280,150,0)
(236,414,0)
(155,130,0)
(105,252,0)
(245,454,0)
(180,309,0)
(65,38,0)
(301,169,0)
(231,112,0)
(259,399,0)
(433,8,0)
(112,405,0)
(376,16,0)
(460,156,0)
(2,268,0)
(369,342,0)
(11,14,0)
(282,415,0)
(107,441,0)
(312,120,0)
(440,406,0)
(6,184,0)
(4,244,0)
(87,399,0)
(95,20,0)
(206,188,0)
(267,341,0)
(49,225,0)
(106,223,0)
(279,182,0)
(340,192,0)
(149,439,0)
(238,304,0)
(188,206,0)
(225,275,0)
(460,9,0)
(442,204,0)
(293,9,0)
(300,20,0)
(470,140,0)
(46,218,0)
(118,326,0)
(96,65,0)
(210,102,0)
(177,342,0)
(130,3,0)
(185,43,0)
(331,226,0)
(223,106,0)
(71,23,0)
(103,398,0)
(170,194,0)
(368,157,0)
(397,29,0)
(405,50,0)
(338,247,0)
(286,204,0)
(318,250,0)
(426,147,0)
(249,369,0)
(331,61,0)
(204,442,0)
(402,77,0)
(66,282,0)
(288,235,0)
(387,180,0)
(29,106,0)
(298,68,0)
(198,45,0)
(465,136,0)
(127,464,0)
(95,358,0)
(443,226,0)
(361,417,0)
(299,205,0)
(230,120,0)
(200,225,0)
(9,460,0)
(437,60,0)
(41,429,0)
(253,333,0)
(420,238,0)
(127,467,0)
(108,115,0)
(350,157,0)
(197,157,0)
(317,204,0)
(270,443,0)
(268,157,0)
(464,342,0)
(207,279,0)
(154,415,0)
(57,277,0)
(288,181,0)
(262,444,0)
(145,435,0)
(123,157,0)
(115,342,0)
(250,318,0)
(324,178,0)
(369,456,0)
(346,223,0)
(272,146,0)
(326,118,0)
(280,342,0)
(314,349,0)
(244,232,0)
(254,342,0)
(422,422,0)
(119,315,0)
(244,183,0)
(35,118,0)
(3,130,0)
(321,157,0)
(277,57,0)
(29,342,0)
(182,175,0)
(298,422,0)
(39,227,1)
(334,74,1)
(250,318,1)
(191,352,1)
(427,47,1)
(202,408,1)
(69,398,1)
(256,419,1)
(3,446,1)
(428,40,1)
(320,296,1)
(456,264,1)
(217,365,1)
(444,432,1)
(188,206,1)
(106,223,1)
(87,45,1)
(101,351,1)
(132,341,1)
(406,442,1)
(107,450,1)
(218,46,1)
(404,249,1)
(359,214,1)
(298,422,1)
(470,217,1)
(379,250,1)
(49,200,1)
(6,184,1)
(50,321,1)
(460,393,1)
(227,20,1)
(242,135,1)
(401,371,1)
(373,378,1)
(442,204,1)
(304,213,1)
(5,12,1)
(223,157,1)
(163,72,1)
(357,161,1)
(378,355,1)
(237,81,1)
(343,246,1)
(180,274,1)
(380,282,1)
(66,255,1)
(150,280,1)
(326,390,1)
(441,247,1)
(235,428,1)
(367,20,1)
(117,228,1)
(116,157,1)
(196,161,1)
(145,435,1)
(312,22,1)
(17,314,1)
(220,210,1)
(0,55,1)
(55,159,1)
(285,236,1)
(265,470,1)
(130,3,1)
(5,466,1)
(280,342,1)
(230,120,1)
(454,157,1)
(125,291,1)
(184,51,1)
(269,411,1)
(257,225,1)
(72,226,1)
(39,41,1)
(417,342,1)
(375,194,1)
(2,157,1)
(454,245,1)
(406,439,1)
(180,157,1)
(218,157,1)
(279,207,1)
(192,340,1)
(93,177,1)
(162,93,1)
(450,247,1)
(391,34,1)
(333,405,1)
(182,262,1)
(181,150,1)
(239,445,1)
(464,64,1)
(254,383,1)
(249,207,1)
(83,338,1)
(55,329,1)
(56,461,1)
(397,263,1)
(179,342,1)
(162,339,1)
(460,366,1)
(443,270,1)
(212,22,1)
(280,138,1)
(321,401,1)
(448,83,1)
(158,156,1)
(301,324,1)
(35,62,1)
(313,202,1)
(178,87,1)
(332,202,1)
(65,38,1)
(134,191,1)
(201,265,1)
(367,28,1)
(414,157,1)
(335,80,1)
(205,299,1)
(14,11,1)
(11,21,1)
(367,121,1)
(339,188,1)
(78,1,1)
(75,137,1)
(119,414,1)
(41,192,1)
(439,149,1)
(120,309,1)
(317,110,1)
(22,342,1)
(386,27,1)
(445,157,1)
(247,85,1)
(326,431,1)
(455,251,1)
(115,327,1)
(12,182,1)
(419,192,1)
(34,140,1)
(423,203,1)
(39,302,1)
(169,289,1)
(1,56,1)
(177,10,1)
(441,314,1)
(179,44,1)
(441,192,1)
(338,115,1)
(129,316,1)
(177,342,1)
(284,357,1)
(336,372,1)
(4,5,1)
(345,52,1)
(310,310,1)
(395,199,1)
(54,92,1)
(80,214,1)
(234,379,1)
(98,342,1)
(310,320,1)
(443,157,1)
(292,252,1)
(248,273,1)
(16,376,1)
(38,305,1)
(452,344,1)
(240,4,1)
(323,130,1)
(141,283,1)
(273,422,1)
(238,420,1)
(345,268,1)
(127,464,1)
(466,12,1)
(418,427,1)
(283,131,1)
(462,132,1)
(409,366,1)
(126,227,1)
(214,239,1)
(300,277,1)
(20,95,1)
(421,125,1)
(29,397,1)
(347,94,1)
(341,370,1)
(354,323,1)
(97,55,1)
(298,310,1)
(76,311,1)
(121,100,1)
(241,141,1)
(186,235,1)
(50,23,1)
(324,178,1)
(314,144,1)
(9,219,1)
(382,294,1)
(229,216,1)
(142,196,1)
(70,409,1)
(159,190,1)
(298,140,1)
(204,286,1)
(412,295,1)
(309,180,1)
(17,192,1)
(182,175,1)
(324,338,1)
(302,6,1)
(281,66,1)
(279,456,1)
(263,221,1)
(114,185,1)
(116,163,1)
(91,364,1)
(340,167,1)
(277,57,1)
(57,250,1)
(217,341,1)
(28,121,1)
(238,157,1)
(66,282,1)
(298,68,1)
(306,231,1)
(255,310,1)
(440,406,1)
(293,393,1)
(216,65,1)
(281,282,1)
(155,3,1)
(22,229,1)
(305,18,1)
(320,308,1)
(128,460,1)
(47,284,1)
(316,69,1)
(301,380,1)
(416,12,1)
(278,262,1)
(275,257,1)
(63,117,1)
(140,17,1)
(82,78,1)
(328,279,1)
(19,204,1)
(112,306,1)
(118,157,1)
(252,105,1)
(88,215,1)
(286,347,1)
(376,24,1)
(383,128,1)
(246,176,1)
(105,453,1)
(322,455,1)
(194,170,1)
(243,9,1)
(153,268,1)
(175,133,1)
(333,253,1)
(262,111,1)
(398,157,1)
(252,342,1)
(311,93,1)
(136,465,1)
(371,23,1)
(219,293,1)
(460,92,1)
(30,116,1)
(149,391,1)
(62,431,1)
(393,469,1)
(168,14,1)
(447,230,1)
(350,242,1)
(204,317,1)
(161,417,1)
(334,342,1)
(407,386,1)
(171,380,1)
(344,269,1)
(60,437,1)
(6,378,1)
(168,98,1)
(368,234,1)
(68,1,1)
(277,192,1)
(337,312,1)
(59,292,1)
(453,357,1)
(181,288,1)
(213,147,1)
(52,153,1)
(299,158,1)
(121,157,1)
(154,33,1)
(27,173,1)
(338,247,1)
(263,137,1)
(185,326,1)
(74,162,1)
(143,412,1)
(296,308,1)
(207,342,1)
(326,118,1)
(157,16,1)
(464,342,1)
(226,443,1)
(221,400,1)
(187,126,1)
(418,342,1)
(95,63,1)
(29,342,1)
(288,186,1)
(184,377,1)
(156,407,1)
(170,30,1)
(92,70,1)
(261,171,1)
(429,304,1)
(459,434,1)
(417,361,1)
(225,157,1)
(413,417,1)
(348,97,1)
(315,414,1)
(226,160,1)
(26,20,1)
(366,348,1)
(4,7,1)
(104,238,1)
(361,25,1)
(92,342,1)
(138,59,1)
(246,146,1)
(378,367,1)
(308,342,1)
(64,381,1)
(77,402,1)
(394,418,1)
(93,122,1)
(312,218,1)
(262,444,1)
(169,342,1)
(380,297,1)
(120,312,1)
(139,106,1)
(61,331,1)
(32,430,1)
(315,119,1)
(118,35,1)
(276,356,1)
(377,143,1)
(392,248,1)
(31,54,1)
(244,232,1)
(287,448,1)
(390,431,1)
(188,169,1)
(389,5,1)
(366,342,1)
(137,181,1)
(431,307,1)
(270,335,1)
(295,51,1)
(292,454,1)
(436,76,1)
(268,193,1)
(25,345,1)
(434,396,1)
(16,342,1)
(110,13,1)
(364,337,1)
(268,157,1)
(368,157,1)
(431,197,1)
(113,32,1)
(372,209,1)
(452,168,1)
(198,86,1)
(405,112,1)
(81,31,1)
(84,440,1)
(221,314,1)
(178,145,1)
(267,370,1)
(225,49,1)
(460,9,1)
(7,389,1)
(122,177,1)
(416,79,1)
(253,405,1)
(173,336,1)
(48,115,1)
(370,276,1)
(330,382,1)
(272,328,1)
(405,50,1)
(51,403,1)
(410,436,1)
(403,373,1)
(245,353,1)
(46,212,1)
(209,243,1)
(329,159,1)
(131,447,1)
(347,342,1)
(453,416,1)
(159,342,1)
(259,174,1)
(250,459,1)
(77,157,1)
(111,246,1)
(102,220,1)
(23,71,1)
(10,39,1)
(266,116,1)
(455,436,1)
(408,360,1)
(251,166,1)
(199,82,1)
(469,463,1)
(214,316,1)
(419,26,1)
(264,369,1)
(210,439,1)
(224,278,1)
(137,292,1)
(321,157,1)
(275,225,1)
(387,91,1)
(458,421,1)
(308,392,1)
(396,354,1)
(223,346,1)
(123,134,1)
(96,38,1)
(327,108,1)
(60,368,1)
(460,372,1)
(135,280,1)
(445,208,1)
(174,145,1)
(24,109,1)
(422,422,1)
(100,468,1)
(269,342,1)
(304,238,1)
(424,322,1)
(232,342,1)
(365,101,1)
(338,48,1)
(266,375,1)
(71,201,1)
(307,197,1)
(420,330,1)
(182,418,1)
(340,61,1)
(14,157,1)
(444,157,1)
(309,91,1)
(310,440,1)
(202,157,1)
(324,441,1)
(369,404,1)
(227,123,1)
(182,326,1)
(88,342,1)
(398,103,1)
(152,244,1)
(414,285,1)
(197,224,1)
(43,342,1)
(289,301,1)
(237,342,1)
(182,279,1)
(38,342,1)
(146,272,1)
(360,187,1)
(13,286,1)
(300,130,1)
(422,275,1)
(353,252,1)
(144,359,1)
(222,168,1)
(399,259,1)
(190,152,1)
(85,136,1)
(282,415,1)
(288,235,1)
(274,387,1)
(235,342,1)
(415,154,1)
(115,342,1)
(341,267,1)
(421,157,1)
(301,217,1)
(297,281,1)
(146,157,1)
(241,157,1)
(57,60,1)
(43,114,1)
(200,58,1)
(236,136,1)
(98,142,1)
(460,156,1)
(262,246,1)
(133,43,1)
(86,73,1)
(130,155,1)
(203,63,1)
(350,157,1)
(166,410,1)
(68,395,1)
(17,333,1)
(442,19,1)
(41,429,1)
(446,67,1)
(411,222,1)
(402,413,1)
(344,425,1)
(251,342,1)
(215,0,1)
(87,399,1)
(332,313,1)
(221,192,1)
(352,20,1)
(85,315,1)
(147,426,1)
(382,241,1)
(232,124,1)
(456,369,1)
(365,351,1)
(193,2,1)
(290,394,1)
(430,368,1)
(436,157,1)
(33,84,1)
(346,211,1)
(422,140,1)
(460,205,1)
(463,237,1)
(51,157,1)
(73,399,1)
(233,458,1)
(356,455,1)
(432,343,1)
(67,230,1)
(331,266,1)
(228,300,1)
(79,88,1)
(460,27,1)
(369,342,1)
(37,445,1)
(331,226,1)
(388,102,1)
(439,342,1)
(175,43,1)
(465,424,1)
(460,237,1)
(298,440,1)
(197,157,1)
(461,261,1)
(441,107,1)
(381,254,1)
(211,29,1)
(230,65,1)
(40,150,1)
(0,127,1)
(358,423,1)
(399,157,1)
(357,452,1)
(286,102,1)
(425,269,1)
(426,104,1)
(351,462,1)
(21,98,1)
(231,50,1)
(207,290,1)
(18,192,1)
(291,179,1)
(161,77,1)
(316,398,1)
(45,198,1)
(26,332,1)
(400,334,1)
(302,419,1)
(95,358,1)
(176,146,1)
(150,350,1)
(44,139,1)
(94,388,1)
(429,382,1)
(254,342,1)
(244,12,1)
(65,96,1)
(468,256,1)
(239,37,1)
(58,298,1)
(123,157,1)
(127,254,1)
(108,441,1)
(460,12,1)
(124,240,1)
(103,75,1)
(145,287,1)
(437,113,1)
(208,129,1)
(39,314,1)
(140,217,2)
(322,455,2)
(91,312,2)
(286,347,2)
(98,342,2)
(427,357,2)
(404,357,2)
(382,294,2)
(468,227,2)
(192,214,2)
(214,137,2)
(437,113,2)
(138,292,2)
(372,55,2)
(324,338,2)
(255,380,2)
(117,230,2)
(126,227,2)
(140,17,2)
(118,431,2)
(382,241,2)
(13,217,2)
(215,357,2)
(405,217,2)
(190,357,2)
(226,160,2)
(465,455,2)
(289,93,2)
(412,227,2)
(180,157,2)
(73,455,2)
(308,342,2)
(428,150,2)
(213,230,2)
(399,455,2)
(98,161,2)
(299,55,2)
(60,437,2)
(38,214,2)
(414,455,2)
(316,398,2)
(57,130,2)
(276,455,2)
(317,217,2)
(181,150,2)
(419,192,2)
(284,357,2)
(146,357,2)
(436,157,2)
(147,230,2)
(12,182,2)
(72,214,2)
(310,440,2)
(136,455,2)
(178,145,2)
(431,357,2)
(54,55,2)
(326,431,2)
(66,380,2)
(262,357,2)
(248,380,2)
(408,227,2)
(334,137,2)
(228,230,2)
(108,455,2)
(85,315,2)
(96,214,2)
(321,217,2)
(405,112,2)
(341,370,2)
(460,366,2)
(460,12,2)
(232,342,2)
(261,380,2)
(224,357,2)
(388,217,2)
(304,213,2)
(1,380,2)
(5,12,2)
(51,227,2)
(6,184,2)
(128,55,2)
(282,415,2)
(309,312,2)
(230,214,2)
(391,217,2)
(47,357,2)
(305,214,2)
(178,87,2)
(188,169,2)
(107,455,2)
(51,157,2)
(196,161,2)
(216,65,2)
(252,342,2)
(122,137,2)
(396,130,2)
(40,150,2)
(46,65,2)
(182,418,2)
(230,65,2)
(56,380,2)
(339,93,2)
(95,63,2)
(17,333,2)
(394,357,2)
(205,55,2)
(344,168,2)
(227,20,2)
(145,455,2)
(97,55,2)
(316,137,2)
(300,230,2)
(176,357,2)
(220,217,2)
(64,55,2)
(203,230,2)
(16,342,2)
(123,157,2)
(264,357,2)
(168,161,2)
(309,180,2)
(395,380,2)
(378,355,2)
(366,342,2)
(350,157,2)
(93,177,2)
(440,406,2)
(406,217,2)
(469,55,2)
(23,217,2)
(161,77,2)
(251,93,2)
(390,431,2)
(141,230,2)
(22,342,2)
(221,137,2)
(133,357,2)
(423,230,2)
(86,455,2)
(442,204,2)
(57,250,2)
(366,55,2)
(169,93,2)
(288,235,2)
(106,223,2)
(182,279,2)
(357,452,2)
(338,247,2)
(268,157,2)
(191,230,2)
(150,280,2)
(270,214,2)
(145,287,2)
(201,217,2)
(17,192,2)
(455,436,2)
(410,93,2)
(340,61,2)
(440,217,2)
(63,230,2)
(22,65,2)
(6,378,2)
(458,421,2)
(157,16,2)
(14,161,2)
(431,197,2)
(277,192,2)
(137,181,2)
(419,227,2)
(221,314,2)
(283,230,2)
(332,227,2)
(87,455,2)
(150,350,2)
(295,227,2)
(236,455,2)
(378,367,2)
(163,214,2)
(380,380,2)
(302,6,2)
(367,121,2)
(229,65,2)
(0,357,2)
(159,357,2)
(45,455,2)
(392,380,2)
(460,237,2)
(14,157,2)
(454,157,2)
(5,357,2)
(275,380,2)
(76,93,2)
(48,455,2)
(68,1,2)
(375,214,2)
(364,312,2)
(254,342,2)
(320,308,2)
(170,214,2)
(34,217,2)
(302,227,2)
(418,357,2)
(411,168,2)
(227,230,2)
(298,380,2)
(65,214,2)
(272,357,2)
(334,342,2)
(230,120,2)
(441,247,2)
(358,230,2)
(429,304,2)
(460,9,2)
(184,51,2)
(219,55,2)
(470,217,2)
(145,435,2)
(460,27,2)
(347,217,2)
(313,227,2)
(85,455,2)
(441,314,2)
(327,455,2)
(146,157,2)
(403,227,2)
(159,342,2)
(341,455,2)
(275,225,2)
(377,227,2)
(71,217,2)
(197,157,2)
(115,342,2)
(226,443,2)
(192,340,2)
(373,227,2)
(81,55,2)
(177,342,2)
(269,168,2)
(460,55,2)
(429,382,2)
(370,455,2)
(175,357,2)
(306,217,2)
(62,431,2)
(155,230,2)
(132,341,2)
(94,217,2)
(452,344,2)
(426,230,2)
(460,372,2)
(242,292,2)
(310,320,2)
(282,217,2)
(326,357,2)
(123,230,2)
(357,161,2)
(225,380,2)
(286,217,2)
(243,55,2)
(314,214,2)
(279,207,2)
(194,214,2)
(265,217,2)
(223,157,2)
(110,217,2)
(430,130,2)
(182,326,2)
(118,157,2)
(287,455,2)
(28,227,2)
(267,455,2)
(218,157,2)
(324,178,2)
(237,342,2)
(69,137,2)
(111,246,2)
(302,419,2)
(419,26,2)
(461,380,2)
(425,168,2)
(241,157,2)
(309,91,2)
(352,230,2)
(92,342,2)
(277,130,2)
(21,161,2)
(20,230,2)
(130,230,2)
(100,227,2)
(250,318,2)
(17,314,2)
(7,5,2)
(307,357,2)
(130,3,2)
(279,357,2)
(315,414,2)
(87,45,2)
(326,118,2)
(49,380,2)
(298,140,2)
(103,137,2)
(250,459,2)
(324,441,2)
(101,341,2)
(12,357,2)
(304,230,2)
(464,342,2)
(308,380,2)
(266,116,2)
(278,357,2)
(450,455,2)
(274,312,2)
(422,140,2)
(292,252,2)
(213,147,2)
(285,455,2)
(448,455,2)
(50,321,2)
(406,439,2)
(55,159,2)
(340,214,2)
(360,227,2)
(179,342,2)
(244,12,2)
(354,130,2)
(182,262,2)
(218,65,2)
(356,455,2)
(60,130,2)
(119,455,2)
(455,251,2)
(279,456,2)
(290,357,2)
(88,357,2)
(11,161,2)
(452,168,2)
(297,380,2)
(221,192,2)
(452,161,2)
(58,380,2)
(184,227,2)
(312,65,2)
(277,57,2)
(204,217,2)
(38,342,2)
(389,5,2)
(321,157,2)
(415,217,2)
(120,309,2)
(281,380,2)
(83,455,2)
(256,227,2)
(395,199,2)
(333,405,2)
(204,286,2)
(422,422,2)
(142,161,2)
(225,157,2)
(154,217,2)
(152,357,2)
(207,357,2)
(31,55,2)
(137,292,2)
(442,217,2)
(320,380,2)
(43,357,2)
(214,239,2)
(368,130,2)
(85,136,2)
(127,55,2)
(240,357,2)
(336,55,2)
(104,230,2)
(293,55,2)
(3,230,2)
(298,440,2)
(158,55,2)
(244,232,2)
(95,358,2)
(57,60,2)
(253,217,2)
(41,429,2)
(286,102,2)
(156,55,2)
(259,455,2)
(182,175,2)
(50,23,2)
(375,194,2)
(209,55,2)
(418,342,2)
(380,217,2)
(238,157,2)
(199,380,2)
(377,143,2)
(401,217,2)
(6,227,2)
(9,55,2)
(204,317,2)
(174,455,2)
(18,214,2)
(80,214,2)
(333,217,2)
(398,157,2)
(175,43,2)
(441,455,2)
(407,55,2)
(60,368,2)
(127,254,2)
(134,230,2)
(29,342,2)
(135,292,2)
(127,464,2)
(393,55,2)
(35,431,2)
(217,455,2)
(68,380,2)
(45,198,2)
(41,230,2)
(185,357,2)
(339,188,2)
(340,167,2)
(387,312,2)
(75,137,2)
(262,444,2)
(312,22,2)
(432,246,2)
(398,137,2)
(115,455,2)
(27,55,2)
(456,369,2)
(92,55,2)
(247,85,2)
(417,342,2)
(166,93,2)
(33,217,2)
(365,351,2)
(380,282,2)
(207,342,2)
(446,230,2)
(344,269,2)
(348,55,2)
(210,217,2)
(181,288,2)
(171,380,2)
(121,157,2)
(168,14,2)
(200,380,2)
(280,342,2)
(332,202,2)
(95,230,2)
(331,214,2)
(251,342,2)
(184,377,2)
(10,137,2)
(78,380,2)
(345,268,2)
(231,217,2)
(249,357,2)
(460,92,2)
(187,227,2)
(222,168,2)
(434,130,2)
(239,316,2)
(79,357,2)
(328,357,2)
(463,55,2)
(66,282,2)
(93,137,2)
(180,312,2)
(188,93,2)
(298,68,2)
(405,50,2)
(74,137,2)
(288,150,2)
(124,357,2)
(311,93,2)
(61,214,2)
(266,214,2)
(335,214,2)
(26,20,2)
(150,292,2)
(369,357,2)
(20,95,2)
(161,417,2)
(168,98,2)
(102,217,2)
(359,214,2)
(269,342,2)
(444,157,2)
(37,316,2)
(217,365,2)
(257,380,2)
(120,312,2)
(350,292,2)
(383,55,2)
(443,214,2)
(241,230,2)
(421,157,2)
(239,445,2)
(406,442,2)
(144,214,2)
(121,227,2)
(381,55,2)
(214,316,2)
(55,357,2)
(447,230,2)
(459,130,2)
(169,342,2)
(280,292,2)
(202,227,2)
(338,115,2)
(234,130,2)
(149,217,2)
(188,206,2)
(235,150,2)
(298,422,2)
(68,395,2)
(296,380,2)
(235,342,2)
(65,38,2)
(77,157,2)
(386,55,2)
(198,455,2)
(246,146,2)
(113,130,2)
(310,310,2)
(304,238,2)
(82,380,2)
(43,342,2)
(26,227,2)
(32,130,2)
(232,357,2)
(70,55,2)
(416,12,2)
(315,455,2)
(444,246,2)
(345,52,2)
(416,357,2)
(143,227,2)
(329,357,2)
(26,332,2)
(367,20,2)
(429,230,2)
(436,93,2)
(462,341,2)
(30,214,2)
(422,380,2)
(371,217,2)
(347,342,2)
(114,357,2)
(351,341,2)
(400,137,2)
(379,130,2)
(17,217,2)
(312,218,2)
(177,137,2)
(131,230,2)
(331,226,2)
(466,357,2)
(298,310,2)
(301,93,2)
(41,192,2)
(19,217,2)
(182,357,2)
(331,266,2)
(244,357,2)
(414,157,2)
(281,217,2)
(420,230,2)
(460,156,2)
(368,157,2)
(238,230,2)
(378,227,2)
(186,150,2)
(250,130,2)
(181,292,2)
(87,399,2)
(399,157,2)
(323,130,2)
(464,55,2)
(254,55,2)
(365,341,2)
(226,214,2)
(61,331,2)
(367,227,2)
(441,192,2)
(39,137,2)
(445,316,2)
(273,380,2)
(208,316,2)
(343,246,2)
(437,130,2)
(112,217,2)
(212,65,2)
(424,455,2)
(178,455,2)
(59,292,2)
(460,205,2)
(292,454,2)
(84,217,2)
(338,455,2)
(337,312,2)
(439,342,2)
(120,65,2)
(262,246,2)
(129,316,2)
(4,357,2)
(217,341,2)
(88,342,2)
(116,214,2)
(246,357,2)
(382,230,2)
(67,230,2)
(247,455,2)
(439,217,2)
(455,93,2)
(50,217,2)
(330,230,2)
(460,393,2)
(324,455,2)
(310,380,2)
(237,55,2)
(197,357,2)
(297,217,2)
(456,357,2)
(445,157,2)
(422,275,2)
(202,157,2)
(443,157,2)
(173,55,2)
(227,123,2)
(409,55,2)
(266,375,2)
(116,157,2)
(369,342,2)
(162,137,2)
-----------------------------------
(0,instancePtr)
(1,validBox.width)
(2,masterPtr)
(3,validBox.y)
(4,newPixmap)
(5,!newPixmap)
(6,(size_t)
(7,Tcl_Panic("Fail to create pixmap with Tk_GetPixmap in ImgPhotoInstanceSetSize.\\n")
(8,)
(9,validBox.y)
(10,error)
(11,height)
(12,newPixmap = Tk_GetPixmap(instancePtr->display,\n\\n\\t\\tRootWindow(instancePtr->display,\n\\n\\t\\t\\tinstancePtr->visualInfo.screen)
(13,validBox)
(14,masterPtr->height)
(15,if (h < masterPtr->height)
(16,instancePtr->masterPtr)
(17,newError +\n\\n\\t\\t\\t(validBox.y * masterPtr->width + validBox.x)
(18,instancePtr)
(19,3)
(20,h = validBox.y + validBox.height)
(21,masterPtr)
(22,instancePtr->width)
(23,validBox.y)
(24,instancePtr)
(25,instancePtr)
(26,h*masterPtr->width*3)
(27,validBox.height)
(28,h)
(29,instancePtr->width)
(30,3)
(31,instancePtr)
(32,schar)
(33,validBox)
(34,errSrcPtr)
(35,height)
(36,offset)
(37,0)
(38,instancePtr->error)
(39,instancePtr)
(40,instancePtr)
(41,memset(newError, 0, (size_t)
(42,)
(43,instancePtr->visualInfo)
(44,height)
(45,3 * sizeof(schar)
(46,width)
(47,instancePtr)
(48,offset)
(49,width)
(50,validBox.y * masterPtr->width)
(51,masterPtr->width)
(52,&validBox)
(53,)
(54,newPixmap)
(55,instancePtr->pixels != None)
(56,width)
(57,(size_t)
(58,errDestPtr)
(59,instancePtr)
(60,masterPtr->width * 3 * sizeof(schar)
(61,ckalloc((unsigned)
(62,masterPtr)
(63,validBox.y)
(64,pixels)
(65,instancePtr->error != NULL)
(66,--h)
(67,validBox)
(68,validBox.width * 3 * sizeof(schar)
(69,0)
(70,pixels)
(71,y)
(72,masterPtr)
(73,3)
(74,error)
(75,masterPtr)
(76,width)
(77,masterPtr->width)
(78,3)
(79,newPixmap)
(80,newError)
(81,gc)
(82,schar)
(83,validBox)
(84,h)
(85,validBox.y * masterPtr->width * 3)
(86,schar)
(87,masterPtr->width * 3 * sizeof(schar)
(88,instancePtr->pixels)
(89,)
(90,)
(91,validBox.width)
(92,instancePtr->pixels)
(93,instancePtr->error != NULL)
(94,width)
(95,validBox.y + validBox.height)
(96,NULL)
(97,instancePtr)
(98,instancePtr->height)
(99,if ((instancePtr->width != masterPtr->width)
(100,height)
(101,0)
(102,validBox.y)
(103,height)
(104,3)
(105,width)
(106,instancePtr->width = masterPtr->width)
(107,offset)
(108,instancePtr)
(109,masterPtr)
(110,x)
(111,1)
(112,validBox.x)
(113,sizeof(schar)
(114,visualInfo)
(115,instancePtr->error)
(116,masterPtr->width)
(117,y)
(118,masterPtr->height)
(119,3)
(120,(instancePtr->width == masterPtr->width)
(121,masterPtr->height)
(122,NULL)
(123,masterPtr->height)
(124,colormap)
(125,height)
(126,newError)
(127,Tk_FreePixmap(instancePtr->display, instancePtr->pixels)
(128,instancePtr)
(129,masterPtr)
(130,validBox.y > 0)
(131,0)
(132,validBox)
(133,depth)
(134,height)
(135,masterPtr)
(136,validBox.y)
(137,(instancePtr->width != masterPtr->width)
(138,height)
(139,instancePtr)
(140,errDestPtr = newError +\n\\n\\t\\t\\t(validBox.y * masterPtr->width + validBox.x)
(141,height)
(142,height)
(143,sizeof(schar)
(144,NULL)
(145,(size_t)
(146,masterPtr->width)
(147,sizeof(schar)
(148,errSrcPtr)
(149,error)
(150,instancePtr->height != masterPtr->height)
(151,newPixmap)
(152,instancePtr)
(153,validBox)
(154,height)
(155,0)
(156,validBox.x)
(157,masterPtr = instancePtr->masterPtr)
(158,validBox)
(159,instancePtr->pixels)
(160,unsigned)
(161,instancePtr->width != masterPtr->width)
(162,instancePtr)
(163,width)
(164,for (h = validBox.height; h > 0; --h)
(165,)
(166,width)
(167,schar *)
(168,instancePtr->height != masterPtr->height)
(169,instancePtr->error)
(170,schar)
(171,errDestPtr)
(172,)
(173,height)
(174,masterPtr)
(175,instancePtr->visualInfo.depth)
(176,0)
(177,instancePtr->error)
(178,(size_t)
(179,instancePtr->height)
(180,masterPtr->width)
(181,(instancePtr->height != masterPtr->height)
(182,Tk_GetPixmap(instancePtr->display,\n\\n\\t\\tRootWindow(instancePtr->display,\n\\n\\t\\t\\tinstancePtr->visualInfo.screen)
(183,)
(184,masterPtr->width * 3 * sizeof(schar)
(185,instancePtr)
(186,NULL)
(187,h)
(188,(char *)
(189,)
(190,pixels)
(191,masterPtr)
(192,newError = (schar *)
(193,validRegion)
(194,sizeof(schar)
(195,if ((instancePtr->width != masterPtr->width)
(196,instancePtr)
(197,masterPtr->height)
(198,sizeof(schar)
(199,sizeof(schar)
(200,masterPtr)
(201,validBox)
(202,masterPtr->width)
(203,validBox)
(204,validBox.y * instancePtr->width + validBox.x)
(205,validBox.y)
(206,char *)
(207,instancePtr->display)
(208,width)
(209,width)
(210,validBox)
(211,masterPtr)
(212,masterPtr)
(213,3*sizeof(schar)
(214,masterPtr->height > 0 && masterPtr->width > 0)
(215,pixels)
(216,instancePtr)
(217,validBox.width > 0 && validBox.height > 0)
(218,masterPtr->width)
(219,y)
(220,y)
(221,instancePtr->error = newError)
(222,instancePtr)
(223,masterPtr->width)
(224,height)
(225,masterPtr->width)
(226,(unsigned)
(227,h < masterPtr->height)
(228,validBox)
(229,width)
(230,(instancePtr->error != NULL)
(231,validBox)
(232,instancePtr->colormap)
(233,RET)
(234,width)
(235,instancePtr->error)
(236,masterPtr)
(237,instancePtr->gc)
(238,masterPtr->width)
(239,masterPtr->width > 0)
(240,instancePtr)
(241,masterPtr->height)
(242,height)
(243,validBox)
(244,TkSetPixmapColormap(newPixmap, instancePtr->colormap)
(245,width)
(246,masterPtr->width > 0)
(247,offset = validBox.y * masterPtr->width * 3)
(248,instancePtr)
(249,instancePtr)
(250,(size_t)
(251,instancePtr->width)
(252,instancePtr->width)
(253,3)
(254,instancePtr->display)
(255,h)
(256,0)
(257,3)
(258,if (validBox.y > 0)
(259,width)
(260,errDestPtr)
(261,errSrcPtr)
(262,(masterPtr->width > 0)
(263,instancePtr)
(264,screen)
(265,newError)
(266,masterPtr->width * 3 * sizeof(schar)
(267,0)
(268,masterPtr->validRegion)
(269,instancePtr->pixels)
(270,height)
(271,if ((instancePtr->error != NULL)
(272,width)
(273,errSrcPtr)
(274,width)
(275,masterPtr->width * 3)
(276,width)
(277,memset(newError, 0, (size_t)
(278,masterPtr)
(279,RootWindow(instancePtr->display,\n\\n\\t\\t\\tinstancePtr->visualInfo.screen)
(280,instancePtr->height)
(281,h)
(282,h = validBox.height)
(283,masterPtr)
(284,newPixmap)
(285,width)
(286,validBox.y * instancePtr->width)
(287,validBox.height)
(288,instancePtr->error == NULL)
(289,error)
(290,display)
(291,masterPtr)
(292,instancePtr->width != masterPtr->width)
(293,validBox)
(294,size_t)
(295,3)
(296,3)
(297,0)
(298,memcpy(errDestPtr, errSrcPtr,\n\\n\\t\\t\\t    validBox.width * 3 * sizeof(schar)
(299,y)
(300,h)
(301,instancePtr)
(302,memset(newError + h*masterPtr->width*3, 0,\n\\n\\t\\t\\t    (size_t)
(303,if (masterPtr->height > 0 && masterPtr->width > 0)
(304,masterPtr->width *3*sizeof(schar)
(305,error)
(306,x)
(307,0)
(308,instancePtr->width)
(309,validBox.width == masterPtr->width)
(310,errSrcPtr += instancePtr->width * 3)
(311,masterPtr)
(312,instancePtr->width == masterPtr->width)
(313,3)
(314,newError = NULL)
(315,masterPtr->width * 3)
(316,masterPtr->height > 0)
(317,validBox.x)
(318,size_t)
(319,)
(320,instancePtr->width * 3)
(321,masterPtr->width)
(322,offset)
(323,newError)
(324,memcpy(newError + offset, instancePtr->error + offset,\n\\n\\t\\t\\t((size_t)
(325,h)
(326,(masterPtr->height > 0)
(327,error)
(328,masterPtr)
(329,None)
(330,masterPtr)
(331,(unsigned)
(332,masterPtr->width*3)
(333,(validBox.y * masterPtr->width + validBox.x)
(334,instancePtr->error)
(335,masterPtr)
(336,validBox)
(337,validBox)
(338,instancePtr->error + offset)
(339,ckfree((char *)
(340,(schar *)
(341,validBox.width > 0)
(342,PhotoInstance *instancePtr)
(343,masterPtr)
(344,instancePtr->pixels == None)
(345,TkClipBox(masterPtr->validRegion, &validBox)
(346,width)
(347,instancePtr->width)
(348,display)
(349,)
(350,masterPtr->height)
(351,validBox.height)
(352,h)
(353,masterPtr)
(354,0)
(355,size_t)
(356,validBox)
(357,(instancePtr->width != masterPtr->width)
(358,validBox.height)
(359,newError)
(360,masterPtr)
(361,width)
(362,)
(363,)
(364,width)
(365,validBox.height > 0)
(366,instancePtr->display)
(367,masterPtr->height - h)
(368,masterPtr->width)
(369,instancePtr->visualInfo)
(370,validBox.width)
(371,masterPtr)
(372,validBox.width)
(373,masterPtr)
(374,)
(375,3 * sizeof(schar)
(376,masterPtr)
(377,3 * sizeof(schar)
(378,(size_t)
(379,masterPtr)
(380,h > 0)
(381,instancePtr)
(382,(size_t)
(383,display)
(384,newError)
(385,if (!newPixmap)
(386,validBox)
(387,masterPtr)
(388,instancePtr)
(389,"Fail to create pixmap with Tk_GetPixmap in ImgPhotoInstanceSetSize.\\n")
(390,1)
(391,instancePtr)
(392,width)
(393,validBox.x)
(394,instancePtr)
(395,3 * sizeof(schar)
(396,validBox)
(397,width)
(398,masterPtr->height)
(399,masterPtr->width)
(400,newError)
(401,width)
(402,width)
(403,width)
(404,visualInfo)
(405,validBox.y * masterPtr->width + validBox.x)
(406,instancePtr->error +\n\\n\\t\\t\\t(validBox.y * instancePtr->width + validBox.x)
(407,x)
(408,width)
(409,instancePtr)
(410,instancePtr)
(411,pixels)
(412,schar)
(413,masterPtr)
(414,masterPtr->width)
(415,validBox.height)
(416,instancePtr->pixels = newPixmap)
(417,instancePtr->width)
(418,instancePtr->display)
(419,newError + h*masterPtr->width*3)
(420,width)
(421,masterPtr->height)
(422,errDestPtr += masterPtr->width * 3)
(423,height)
(424,validBox)
(425,None)
(426,schar)
(427,display)
(428,error)
(429,(size_t)
(430,3)
(431,masterPtr->height > 0)
(432,width)
(433,if (instancePtr->error != NULL)
(434,y)
(435,size_t)
(436,masterPtr->width)
(437,3 * sizeof(schar)
(438,if (instancePtr->pixels != None)
(439,instancePtr->error)
(440,errSrcPtr = instancePtr->error +\n\\n\\t\\t\\t(validBox.y * instancePtr->width + validBox.x)
(441,newError + offset)
(442,(validBox.y * instancePtr->width + validBox.x)
(443,masterPtr->height)
(444,masterPtr->width)
(445,masterPtr->width)
(446,y)
(447,newError)
(448,height)
(449,if (masterPtr->width == instancePtr->width)
(450,newError)
(451,masterPtr)
(452,(instancePtr->height != masterPtr->height)
(453,instancePtr)
(454,masterPtr->width)
(455,masterPtr->width == instancePtr->width)
(456,instancePtr->visualInfo.screen)
(457,validBox)
(458,instancePtr->height = masterPtr->height)
(459,validBox.y)
(460,XCopyArea(instancePtr->display, instancePtr->pixels, newPixmap,\n\\n\\t\\t    instancePtr->gc, validBox.x, validBox.y,\n\\n\\t\\t    validBox.width, validBox.height, validBox.x, validBox.y)
(461,validBox)
(462,height)
(463,validBox)
(464,instancePtr->pixels)
(465,y)
(466,newPixmap)
(467,)
(468,masterPtr)
(469,x)
(470,errDestPtr)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^