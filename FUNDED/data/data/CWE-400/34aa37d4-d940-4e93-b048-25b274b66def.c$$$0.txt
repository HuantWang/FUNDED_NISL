-----label-----
0
-----code-----
static void sla_handle_hold_event(struct sla_event *event)
{
	ast_atomic_fetchadd_int((int *) &event->trunk_ref->trunk->hold_stations, 1);
	event->trunk_ref->state = SLA_TRUNK_STATE_ONHOLD_BYME;
	ast_devstate_changed(AST_DEVICE_ONHOLD, AST_DEVSTATE_CACHABLE, "SLA:%s_%s",
			     event->station->name, event->trunk_ref->trunk->name);
	sla_change_trunk_state(event->trunk_ref->trunk, SLA_TRUNK_STATE_ONHOLD, 
		INACTIVE_TRUNK_REFS, event->trunk_ref);

	if (event->trunk_ref->trunk->active_stations == 1) {
		/* The station putting it on hold is the only one on the call, so start
		 * Music on hold to the trunk. */
		event->trunk_ref->trunk->on_hold = 1;
		ast_indicate(event->trunk_ref->trunk->chan, AST_CONTROL_HOLD);
	}

	ast_softhangup(event->trunk_ref->chan, AST_SOFTHANGUP_DEV);
	event->trunk_ref->chan = NULL;
}
-----children-----
1,2
1,3
1,4
3,4
3,5
5,6
5,7
6,7
8,9
8,10
11,12
11,13
11,14
11,15
11,16
11,17
11,18
12,13
13,14
13,15
13,16
14,15
16,17
16,18
17,18
17,19
19,20
21,22
22,23
22,24
23,24
23,25
24,25
24,26
25,26
31,32
32,33
32,34
33,34
33,35
34,35
34,36
35,36
39,40
41,42
42,43
42,44
42,45
42,46
42,47
42,48
43,44
45,46
47,48
50,51
50,52
51,52
51,53
52,53
56,57
56,58
57,58
57,59
58,59
58,60
59,60
64,65
65,66
65,67
65,68
65,69
65,70
66,67
68,69
68,70
69,70
69,71
70,71
74,75
76,77
78,79
78,80
79,80
82,83
82,84
83,84
83,85
84,85
84,86
85,86
85,87
86,87
86,88
87,88
93,94
93,95
94,95
95,96
95,97
96,97
96,98
97,98
97,99
98,99
98,100
99,100
105,106
106,107
106,108
106,109
107,108
109,110
109,111
110,111
110,112
111,112
111,113
112,113
117,118
119,120
120,121
120,122
120,123
121,122
123,124
123,125
124,125
124,126
125,126
129,130
131,132
132,133
132,134
133,134
133,135
134,135
134,136
135,136
139,140
-----nextToken-----
2,4,7,9,10,15,18,20,26,27,28,29,30,36,37,38,40,44,46,48,49,53,54,55,60,61,62,63,67,71,72,73,75,77,80,81,88,89,90,91,92,100,101,102,103,104,108,113,114,115,116,118,122,126,127,128,130,136,137,138,140
-----computeFrom-----
32,33
32,34
83,84
83,85
95,96
95,97
132,133
132,134
-----guardedBy-----
88,113
90,115
89,114
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;UnaryExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;
-----ast_node-----
static void sla_handle_hold_event(struct sla_event *event){	ast_atomic_fetchadd_int((int *) &event->trunk_ref->trunk->hold_stations, 1);	event->trunk_ref->state = SLA_TRUNK_STATE_ONHOLD_BYME;	ast_devstate_changed(AST_DEVICE_ONHOLD, AST_DEVSTATE_CACHABLE, "SLA:%s_%s",			     event->station->name, event->trunk_ref->trunk->name);	sla_change_trunk_state(event->trunk_ref->trunk, SLA_TRUNK_STATE_ONHOLD, 		INACTIVE_TRUNK_REFS, event->trunk_ref);	if (event->trunk_ref->trunk->active_stations == 1) {		/* The station putting it on hold is the only one on the call, so start		 * Music on hold to the trunk. */		event->trunk_ref->trunk->on_hold = 1;		ast_indicate(event->trunk_ref->trunk->chan, AST_CONTROL_HOLD);	}	ast_softhangup(event->trunk_ref->chan, AST_SOFTHANGUP_DEV);	event->trunk_ref->chan = NULL;}
static void
sla_handle_hold_event(struct sla_event *event)
sla_handle_hold_event
struct sla_event *event
struct sla_event
sla_event
*event
*
event
{	ast_atomic_fetchadd_int((int *) &event->trunk_ref->trunk->hold_stations, 1);	event->trunk_ref->state = SLA_TRUNK_STATE_ONHOLD_BYME;	ast_devstate_changed(AST_DEVICE_ONHOLD, AST_DEVSTATE_CACHABLE, "SLA:%s_%s",			     event->station->name, event->trunk_ref->trunk->name);	sla_change_trunk_state(event->trunk_ref->trunk, SLA_TRUNK_STATE_ONHOLD, 		INACTIVE_TRUNK_REFS, event->trunk_ref);	if (event->trunk_ref->trunk->active_stations == 1) {		/* The station putting it on hold is the only one on the call, so start		 * Music on hold to the trunk. */		event->trunk_ref->trunk->on_hold = 1;		ast_indicate(event->trunk_ref->trunk->chan, AST_CONTROL_HOLD);	}	ast_softhangup(event->trunk_ref->chan, AST_SOFTHANGUP_DEV);	event->trunk_ref->chan = NULL;}
ast_atomic_fetchadd_int((int *) &event->trunk_ref->trunk->hold_stations, 1);
ast_atomic_fetchadd_int((int *) &event->trunk_ref->trunk->hold_stations, 1)
ast_atomic_fetchadd_int
ast_atomic_fetchadd_int
(int *) &event->trunk_ref->trunk->hold_stations
int *
int
*
*
&event->trunk_ref->trunk->hold_stations
event->trunk_ref->trunk->hold_stations
event->trunk_ref->trunk
event->trunk_ref
event
event
trunk_ref
trunk
hold_stations
1
event->trunk_ref->state = SLA_TRUNK_STATE_ONHOLD_BYME;
event->trunk_ref->state = SLA_TRUNK_STATE_ONHOLD_BYME
event->trunk_ref->state
event->trunk_ref
event
event
trunk_ref
state
SLA_TRUNK_STATE_ONHOLD_BYME
SLA_TRUNK_STATE_ONHOLD_BYME
ast_devstate_changed(AST_DEVICE_ONHOLD, AST_DEVSTATE_CACHABLE, "SLA:%s_%s",			     event->station->name, event->trunk_ref->trunk->name);
ast_devstate_changed(AST_DEVICE_ONHOLD, AST_DEVSTATE_CACHABLE, "SLA:%s_%s",			     event->station->name, event->trunk_ref->trunk->name)
ast_devstate_changed
ast_devstate_changed
AST_DEVICE_ONHOLD
AST_DEVICE_ONHOLD
AST_DEVSTATE_CACHABLE
AST_DEVSTATE_CACHABLE
"SLA:%s_%s"
event->station->name
event->station
event
event
station
name
event->trunk_ref->trunk->name
event->trunk_ref->trunk
event->trunk_ref
event
event
trunk_ref
trunk
name
sla_change_trunk_state(event->trunk_ref->trunk, SLA_TRUNK_STATE_ONHOLD, 		INACTIVE_TRUNK_REFS, event->trunk_ref);
sla_change_trunk_state(event->trunk_ref->trunk, SLA_TRUNK_STATE_ONHOLD, 		INACTIVE_TRUNK_REFS, event->trunk_ref)
sla_change_trunk_state
sla_change_trunk_state
event->trunk_ref->trunk
event->trunk_ref
event
event
trunk_ref
trunk
SLA_TRUNK_STATE_ONHOLD
SLA_TRUNK_STATE_ONHOLD
INACTIVE_TRUNK_REFS
INACTIVE_TRUNK_REFS
event->trunk_ref
event
event
trunk_ref
if (event->trunk_ref->trunk->active_stations == 1) {		/* The station putting it on hold is the only one on the call, so start		 * Music on hold to the trunk. */		event->trunk_ref->trunk->on_hold = 1;		ast_indicate(event->trunk_ref->trunk->chan, AST_CONTROL_HOLD);	}
event->trunk_ref->trunk->active_stations == 1
event->trunk_ref->trunk->active_stations
event->trunk_ref->trunk
event->trunk_ref
event
event
trunk_ref
trunk
active_stations
1
{		/* The station putting it on hold is the only one on the call, so start		 * Music on hold to the trunk. */		event->trunk_ref->trunk->on_hold = 1;		ast_indicate(event->trunk_ref->trunk->chan, AST_CONTROL_HOLD);	}
event->trunk_ref->trunk->on_hold = 1;
event->trunk_ref->trunk->on_hold = 1
event->trunk_ref->trunk->on_hold
event->trunk_ref->trunk
event->trunk_ref
event
event
trunk_ref
trunk
on_hold
1
ast_indicate(event->trunk_ref->trunk->chan, AST_CONTROL_HOLD);
ast_indicate(event->trunk_ref->trunk->chan, AST_CONTROL_HOLD)
ast_indicate
ast_indicate
event->trunk_ref->trunk->chan
event->trunk_ref->trunk
event->trunk_ref
event
event
trunk_ref
trunk
chan
AST_CONTROL_HOLD
AST_CONTROL_HOLD
ast_softhangup(event->trunk_ref->chan, AST_SOFTHANGUP_DEV);
ast_softhangup(event->trunk_ref->chan, AST_SOFTHANGUP_DEV)
ast_softhangup
ast_softhangup
event->trunk_ref->chan
event->trunk_ref
event
event
trunk_ref
chan
AST_SOFTHANGUP_DEV
AST_SOFTHANGUP_DEV
event->trunk_ref->chan = NULL;
event->trunk_ref->chan = NULL
event->trunk_ref->chan
event->trunk_ref
event
event
trunk_ref
chan
NULL
NULL
-----joern-----
(26,45,0)
(12,46,0)
(54,57,0)
(60,5,0)
(9,1,0)
(70,49,0)
(31,45,0)
(90,22,0)
(20,10,0)
(37,1,0)
(70,62,0)
(32,24,0)
(83,79,0)
(78,43,0)
(28,88,0)
(29,47,0)
(46,24,0)
(57,7,0)
(58,38,0)
(37,13,0)
(56,15,0)
(44,27,0)
(44,22,0)
(72,6,0)
(84,50,0)
(79,47,0)
(49,89,0)
(16,17,0)
(30,65,0)
(33,13,0)
(76,42,0)
(3,43,0)
(86,12,0)
(75,53,0)
(73,22,0)
(52,49,0)
(6,39,0)
(47,53,0)
(13,75,0)
(43,53,0)
(0,15,0)
(15,1,0)
(19,47,0)
(39,6,0)
(11,39,0)
(88,1,0)
(43,3,0)
(21,3,0)
(67,88,0)
(47,64,0)
(39,1,0)
(3,15,0)
(81,60,0)
(61,53,0)
(57,1,0)
(80,5,0)
(74,50,0)
(65,59,0)
(85,39,0)
(88,64,0)
(42,62,0)
(4,89,0)
(69,70,0)
(82,37,0)
(62,70,0)
(17,42,0)
(42,76,0)
(46,12,0)
(7,79,0)
(9,38,0)
(15,3,0)
(42,17,0)
(34,44,0)
(68,64,0)
(36,7,0)
(12,1,0)
(62,42,0)
(6,38,0)
(45,84,0)
(79,7,0)
(22,1,0)
(77,37,0)
(55,12,0)
(25,27,0)
(51,9,0)
(22,44,0)
(45,1,0)
(7,57,0)
(8,9,0)
(38,9,0)
(18,38,0)
(65,27,0)
(40,47,0)
(10,87,0)
(50,84,0)
(60,1,0)
(14,87,0)
(2,60,0)
(5,60,0)
(64,88,0)
(89,1,0)
(66,46,0)
(91,84,0)
(27,65,0)
(50,71,0)
(10,5,0)
(24,53,0)
(17,53,0)
(47,79,0)
(63,89,0)
(71,50,0)
(89,49,0)
(38,53,0)
(49,70,0)
(38,6,0)
(87,59,0)
(35,57,0)
(41,71,0)
(84,45,0)
(5,10,0)
(27,44,0)
(64,47,0)
(23,75,0)
(13,37,0)
(67,28,1)
(71,50,1)
(3,15,1)
(91,45,1)
(22,73,1)
(24,32,1)
(2,81,1)
(54,64,1)
(52,89,1)
(77,82,1)
(0,65,1)
(7,36,1)
(32,46,1)
(66,12,1)
(60,1,1)
(60,2,1)
(11,85,1)
(7,57,1)
(16,42,1)
(10,5,1)
(27,25,1)
(19,29,1)
(29,40,1)
(5,80,1)
(70,49,1)
(34,22,1)
(28,19,1)
(85,47,1)
(27,44,1)
(42,62,1)
(57,35,1)
(73,90,1)
(0,71,1)
(43,3,1)
(8,51,1)
(20,5,1)
(50,84,1)
(51,58,1)
(46,66,1)
(13,37,1)
(10,20,1)
(45,1,1)
(13,33,1)
(17,42,1)
(36,57,1)
(38,9,1)
(64,68,1)
(86,17,1)
(45,31,1)
(88,67,1)
(84,45,1)
(68,88,1)
(46,12,1)
(87,14,1)
(90,87,1)
(65,30,1)
(81,71,1)
(15,56,1)
(44,34,1)
(64,88,1)
(41,50,1)
(23,13,1)
(43,78,1)
(18,6,1)
(12,55,1)
(26,38,1)
(58,18,1)
(6,39,1)
(48,75,1)
(38,6,1)
(70,69,1)
(9,1,1)
(72,39,1)
(63,4,1)
(50,74,1)
(71,41,1)
(30,27,1)
(12,1,1)
(88,1,1)
(84,91,1)
(33,37,1)
(21,15,1)
(17,16,1)
(79,83,1)
(49,52,1)
(62,70,1)
(39,1,1)
(37,77,1)
(40,24,1)
(89,1,1)
(9,8,1)
(89,63,1)
(44,22,1)
(74,84,1)
(56,0,1)
(15,1,1)
(42,76,1)
(78,3,1)
(79,7,1)
(82,43,1)
(80,60,1)
(65,27,1)
(47,79,1)
(25,44,1)
(49,89,1)
(14,10,1)
(31,26,1)
(39,11,1)
(75,23,1)
(22,1,1)
(35,54,1)
(37,1,1)
(57,1,1)
(6,72,1)
(55,86,1)
(83,7,1)
(69,49,1)
(47,64,1)
(5,60,1)
(3,21,1)
(10,5,2)
(22,1,2)
(89,1,2)
(27,71,2)
(38,9,2)
(22,71,2)
(2,71,2)
(65,27,2)
(64,88,2)
(10,71,2)
(47,64,2)
(39,1,2)
(3,15,2)
(15,1,2)
(50,84,2)
(20,71,2)
(47,79,2)
(7,57,2)
(17,42,2)
(5,71,2)
(25,71,2)
(81,71,2)
(60,71,2)
(27,44,2)
(65,71,2)
(45,1,2)
(71,50,2)
(12,1,2)
(49,89,2)
(90,71,2)
(80,71,2)
(60,1,2)
(42,62,2)
(5,60,2)
(43,3,2)
(34,71,2)
(38,6,2)
(42,76,2)
(14,71,2)
(13,37,2)
(70,49,2)
(9,1,2)
(44,71,2)
(62,70,2)
(88,1,2)
(30,71,2)
(87,71,2)
(6,39,2)
(37,1,2)
(84,45,2)
(46,12,2)
(44,22,2)
(73,71,2)
(57,1,2)
(79,7,2)
-----------------------------------
(0,event)
(1,struct sla_event *event)
(2,trunk_ref)
(3,event->trunk_ref->chan)
(4,event)
(5,event->trunk_ref->trunk)
(6,event->trunk_ref->trunk)
(7,event->trunk_ref->trunk)
(8,trunk_ref)
(9,event->trunk_ref)
(10,event->trunk_ref->trunk->on_hold)
(11,trunk_ref)
(12,event->trunk_ref)
(13,event->trunk_ref->chan)
(14,1)
(15,event->trunk_ref)
(16,1)
(17,ast_atomic_fetchadd_int((int *)
(18,SLA_TRUNK_STATE_ONHOLD)
(19,"SLA:%s_%s")
(20,on_hold)
(21,chan)
(22,event->trunk_ref)
(23,NULL)
(24,event->trunk_ref->state = SLA_TRUNK_STATE_ONHOLD_BYME)
(25,chan)
(26,event)
(27,event->trunk_ref->trunk->chan)
(28,event)
(29,AST_DEVSTATE_CACHABLE)
(30,AST_CONTROL_HOLD)
(31,trunk_ref)
(32,SLA_TRUNK_STATE_ONHOLD_BYME)
(33,chan)
(34,trunk)
(35,trunk_ref)
(36,trunk)
(37,event->trunk_ref)
(38,sla_change_trunk_state(event->trunk_ref->trunk, SLA_TRUNK_STATE_ONHOLD, \n\\n\\t\\tINACTIVE_TRUNK_REFS, event->trunk_ref)
(39,event->trunk_ref)
(40,AST_DEVICE_ONHOLD)
(41,1)
(42,(int *)
(43,ast_softhangup(event->trunk_ref->chan, AST_SOFTHANGUP_DEV)
(44,event->trunk_ref->trunk)
(45,event->trunk_ref)
(46,event->trunk_ref->state)
(47,ast_devstate_changed(AST_DEVICE_ONHOLD, AST_DEVSTATE_CACHABLE, "SLA:%s_%s",\n\\n\\t\\t\\t     event->station->name, event->trunk_ref->trunk->name)
(48,RET)
(49,event->trunk_ref->trunk)
(50,event->trunk_ref->trunk->active_stations)
(51,event)
(52,trunk)
(53,)
(54,event)
(55,trunk_ref)
(56,trunk_ref)
(57,event->trunk_ref)
(58,INACTIVE_TRUNK_REFS)
(59,)
(60,event->trunk_ref)
(61,if (event->trunk_ref->trunk->active_stations == 1)
(62,&event->trunk_ref->trunk->hold_stations)
(63,trunk_ref)
(64,event->station->name)
(65,ast_indicate(event->trunk_ref->trunk->chan, AST_CONTROL_HOLD)
(66,state)
(67,station)
(68,name)
(69,hold_stations)
(70,event->trunk_ref->trunk->hold_stations)
(71,event->trunk_ref->trunk->active_stations == 1)
(72,trunk)
(73,trunk_ref)
(74,active_stations)
(75,event->trunk_ref->chan = NULL)
(76,int *)
(77,trunk_ref)
(78,AST_SOFTHANGUP_DEV)
(79,event->trunk_ref->trunk->name)
(80,trunk)
(81,event)
(82,event)
(83,name)
(84,event->trunk_ref->trunk)
(85,event)
(86,event)
(87,event->trunk_ref->trunk->on_hold = 1)
(88,event->station)
(89,event->trunk_ref)
(90,event)
(91,trunk)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^