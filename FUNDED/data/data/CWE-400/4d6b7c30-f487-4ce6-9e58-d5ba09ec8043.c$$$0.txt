-----label-----
0
-----code-----
static void goodB2G2()
{
    size_t data;
    /* Initialize data */
    data = 0;
    switch(6)
    {
    case 6:
        /* POTENTIAL FLAW: Set data to a random value */
        data = rand();
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine("Benign, fixed string");
        break;
    }
    switch(7)
    {
    case 7:
    {
        wchar_t * myString;
        /* FIX: Include a MAXIMUM limitation for memory allocation and a check to ensure data is large enough
         * for the wcscpy() function to not cause a buffer overflow */
        /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */
        if (data > wcslen(HELLO_STRING) && data < 100)
        {
            myString = (wchar_t *)malloc(data*sizeof(wchar_t));
            if (myString == NULL) {exit(-1);}
            /* Copy a small string into myString */
            wcscpy(myString, HELLO_STRING);
            printWLine(myString);
            free(myString);
        }
        else
        {
            printLine("Input is less than the length of the source string or too large");
        }
    }
    break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine("Benign, fixed string");
        break;
    }
}
-----children-----
1,2
1,3
1,4
3,4
5,6
5,7
5,8
5,9
6,7
7,8
7,9
8,9
10,11
12,13
13,14
13,15
14,15
17,18
17,19
19,20
19,21
19,22
19,23
19,24
19,25
20,21
22,23
23,24
23,25
24,25
26,27
27,28
31,32
32,33
32,34
33,34
37,38
37,39
39,40
39,41
39,42
39,43
39,44
39,45
40,41
42,43
42,44
43,44
44,45
44,46
46,47
46,48
49,50
49,51
49,52
50,51
50,52
51,52
51,53
52,53
54,55
54,56
55,56
57,58
59,60
59,61
60,61
63,64
63,65
63,66
63,67
63,68
64,65
65,66
65,67
66,67
68,69
68,70
69,70
69,71
71,72
73,74
73,75
74,75
76,77
76,78
77,78
79,80
80,81
80,82
83,84
83,85
84,85
84,86
85,86
87,88
89,90
90,91
91,92
91,93
92,93
94,95
96,97
97,98
97,99
97,100
98,99
100,101
102,103
104,105
105,106
105,107
106,107
108,109
110,111
111,112
111,113
112,113
114,115
116,117
117,118
118,119
118,120
119,120
124,125
125,126
125,127
126,127
-----nextToken-----
2,4,9,11,15,16,18,21,25,28,29,30,34,35,36,38,41,45,47,48,53,56,58,61,62,67,70,72,75,78,81,82,86,88,93,95,99,101,103,107,109,113,115,120,121,122,123,127,128,129
-----computeFrom-----
13,14
13,15
23,24
23,25
50,51
50,52
51,52
51,53
59,60
59,61
65,66
65,67
76,77
76,78
84,85
84,86
-----guardedBy-----
58,103
61,78
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;SwitchStatement;LiteralExpression;CompoundStatement;CaseStatement;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;BreakStatement;DefaultStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;BreakStatement;SwitchStatement;LiteralExpression;CompoundStatement;CaseStatement;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FunctionCallExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;TypeIdExpression;TypeId;SimpleDeclSpecifier;Declarator;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;BreakStatement;DefaultStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;BreakStatement;
-----ast_node-----
static void goodB2G2(){    size_t data;    /* Initialize data */    data = 0;    switch(6)    {    case 6:        /* POTENTIAL FLAW: Set data to a random value */        data = rand();        break;    default:        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */        printLine("Benign, fixed string");        break;    }    switch(7)    {    case 7:    {        wchar_t * myString;        /* FIX: Include a MAXIMUM limitation for memory allocation and a check to ensure data is large enough         * for the wcscpy() function to not cause a buffer overflow */        /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */        if (data > wcslen(HELLO_STRING) && data < 100)        {            myString = (wchar_t *)malloc(data*sizeof(wchar_t));            if (myString == NULL) {exit(-1);}            /* Copy a small string into myString */            wcscpy(myString, HELLO_STRING);            printWLine(myString);            free(myString);        }        else        {            printLine("Input is less than the length of the source string or too large");        }    }    break;    default:        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */        printLine("Benign, fixed string");        break;    }}
static void
goodB2G2()
goodB2G2
{    size_t data;    /* Initialize data */    data = 0;    switch(6)    {    case 6:        /* POTENTIAL FLAW: Set data to a random value */        data = rand();        break;    default:        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */        printLine("Benign, fixed string");        break;    }    switch(7)    {    case 7:    {        wchar_t * myString;        /* FIX: Include a MAXIMUM limitation for memory allocation and a check to ensure data is large enough         * for the wcscpy() function to not cause a buffer overflow */        /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */        if (data > wcslen(HELLO_STRING) && data < 100)        {            myString = (wchar_t *)malloc(data*sizeof(wchar_t));            if (myString == NULL) {exit(-1);}            /* Copy a small string into myString */            wcscpy(myString, HELLO_STRING);            printWLine(myString);            free(myString);        }        else        {            printLine("Input is less than the length of the source string or too large");        }    }    break;    default:        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */        printLine("Benign, fixed string");        break;    }}
size_t data;
size_t data;
size_t
size_t
data
data
data = 0;
data = 0
data
data
0
switch(6)    {    case 6:        /* POTENTIAL FLAW: Set data to a random value */        data = rand();        break;    default:        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */        printLine("Benign, fixed string");        break;    }
6
{    case 6:        /* POTENTIAL FLAW: Set data to a random value */        data = rand();        break;    default:        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */        printLine("Benign, fixed string");        break;    }
case 6:
6
data = rand();
data = rand()
data
data
rand()
rand
rand
break;
default:
printLine("Benign, fixed string");
printLine("Benign, fixed string")
printLine
printLine
"Benign, fixed string"
break;
switch(7)    {    case 7:    {        wchar_t * myString;        /* FIX: Include a MAXIMUM limitation for memory allocation and a check to ensure data is large enough         * for the wcscpy() function to not cause a buffer overflow */        /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */        if (data > wcslen(HELLO_STRING) && data < 100)        {            myString = (wchar_t *)malloc(data*sizeof(wchar_t));            if (myString == NULL) {exit(-1);}            /* Copy a small string into myString */            wcscpy(myString, HELLO_STRING);            printWLine(myString);            free(myString);        }        else        {            printLine("Input is less than the length of the source string or too large");        }    }    break;    default:        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */        printLine("Benign, fixed string");        break;    }
7
{    case 7:    {        wchar_t * myString;        /* FIX: Include a MAXIMUM limitation for memory allocation and a check to ensure data is large enough         * for the wcscpy() function to not cause a buffer overflow */        /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */        if (data > wcslen(HELLO_STRING) && data < 100)        {            myString = (wchar_t *)malloc(data*sizeof(wchar_t));            if (myString == NULL) {exit(-1);}            /* Copy a small string into myString */            wcscpy(myString, HELLO_STRING);            printWLine(myString);            free(myString);        }        else        {            printLine("Input is less than the length of the source string or too large");        }    }    break;    default:        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */        printLine("Benign, fixed string");        break;    }
case 7:
7
{        wchar_t * myString;        /* FIX: Include a MAXIMUM limitation for memory allocation and a check to ensure data is large enough         * for the wcscpy() function to not cause a buffer overflow */        /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */        if (data > wcslen(HELLO_STRING) && data < 100)        {            myString = (wchar_t *)malloc(data*sizeof(wchar_t));            if (myString == NULL) {exit(-1);}            /* Copy a small string into myString */            wcscpy(myString, HELLO_STRING);            printWLine(myString);            free(myString);        }        else        {            printLine("Input is less than the length of the source string or too large");        }    }
wchar_t * myString;
wchar_t * myString;
wchar_t
* myString
*
myString
if (data > wcslen(HELLO_STRING) && data < 100)        {            myString = (wchar_t *)malloc(data*sizeof(wchar_t));            if (myString == NULL) {exit(-1);}            /* Copy a small string into myString */            wcscpy(myString, HELLO_STRING);            printWLine(myString);            free(myString);        }        else        {            printLine("Input is less than the length of the source string or too large");        }
data > wcslen(HELLO_STRING) && data < 100
data > wcslen(HELLO_STRING)
data
data
wcslen(HELLO_STRING)
wcslen
wcslen
HELLO_STRING
HELLO_STRING
data < 100
data
data
100
{            myString = (wchar_t *)malloc(data*sizeof(wchar_t));            if (myString == NULL) {exit(-1);}            /* Copy a small string into myString */            wcscpy(myString, HELLO_STRING);            printWLine(myString);            free(myString);        }
myString = (wchar_t *)malloc(data*sizeof(wchar_t));
myString = (wchar_t *)malloc(data*sizeof(wchar_t))
myString
myString
(wchar_t *)malloc(data*sizeof(wchar_t))
wchar_t *
wchar_t
*
*
malloc(data*sizeof(wchar_t))
malloc
malloc
data*sizeof(wchar_t)
data
data
sizeof(wchar_t)
wchar_t
wchar_t

if (myString == NULL) {exit(-1);}
myString == NULL
myString
myString
NULL
NULL
{exit(-1);}
exit(-1);
exit(-1)
exit
exit
-1
1
wcscpy(myString, HELLO_STRING);
wcscpy(myString, HELLO_STRING)
wcscpy
wcscpy
myString
myString
HELLO_STRING
HELLO_STRING
printWLine(myString);
printWLine(myString)
printWLine
printWLine
myString
myString
free(myString);
free(myString)
free
free
myString
myString
{            printLine("Input is less than the length of the source string or too large");        }
printLine("Input is less than the length of the source string or too large");
printLine("Input is less than the length of the source string or too large")
printLine
printLine
"Input is less than the length of the source string or too large"
break;
default:
printLine("Benign, fixed string");
printLine("Benign, fixed string")
printLine
printLine
"Benign, fixed string"
break;
-----joern-----
(56,36,0)
(63,54,0)
(61,20,0)
(12,63,0)
(34,59,0)
(3,2,0)
(60,36,0)
(35,7,0)
(65,63,0)
(51,10,0)
(11,44,0)
(33,2,0)
(23,45,0)
(55,13,0)
(48,46,0)
(61,41,0)
(37,54,0)
(22,20,0)
(59,34,0)
(21,43,0)
(13,24,0)
(13,7,0)
(40,43,0)
(46,43,0)
(29,45,0)
(30,13,0)
(10,45,0)
(41,19,0)
(7,35,0)
(24,34,0)
(13,63,0)
(34,63,0)
(62,60,0)
(9,45,0)
(7,45,0)
(41,61,0)
(42,59,0)
(58,18,0)
(1,21,0)
(64,43,0)
(36,43,0)
(61,7,0)
(4,18,0)
(57,61,0)
(24,13,0)
(16,54,0)
(14,58,0)
(34,7,0)
(25,18,0)
(32,5,0)
(20,61,0)
(5,32,0)
(40,36,0)
(36,19,0)
(26,60,0)
(19,41,0)
(21,36,0)
(46,36,0)
(28,18,0)
(19,0,0)
(49,18,0)
(17,34,0)
(44,8,0)
(27,40,0)
(0,19,0)
(39,32,0)
(19,36,0)
(31,7,0)
(34,24,0)
(15,45,0)
(47,40,0)
(61,63,0)
(2,18,0)
(5,6,0)
(53,54,0)
(40,36,1)
(46,36,1)
(52,9,1)
(60,26,1)
(14,52,1)
(21,36,1)
(17,52,1)
(38,49,1)
(13,55,1)
(25,44,1)
(61,7,1)
(22,57,1)
(5,32,1)
(20,22,1)
(21,1,1)
(39,60,1)
(25,21,1)
(24,13,1)
(9,10,1)
(56,24,1)
(36,19,1)
(44,11,1)
(47,27,1)
(46,48,1)
(63,12,1)
(41,61,1)
(12,65,1)
(51,50,1)
(61,63,1)
(19,41,1)
(34,7,1)
(34,63,1)
(50,63,1)
(62,36,1)
(40,47,1)
(11,24,1)
(49,58,1)
(61,20,1)
(13,7,1)
(32,39,1)
(52,29,1)
(27,60,1)
(24,34,1)
(57,56,1)
(48,40,1)
(59,42,1)
(34,59,1)
(26,62,1)
(35,31,1)
(30,34,1)
(13,63,1)
(10,51,1)
(27,5,1)
(1,46,1)
(55,30,1)
(19,0,1)
(58,14,1)
(38,25,1)
(60,36,1)
(31,50,1)
(29,7,1)
(7,35,1)
(42,17,1)
(7,35,2)
(26,24,2)
(61,7,2)
(34,63,2)
(22,24,2)
(57,24,2)
(39,60,2)
(41,61,2)
(46,24,2)
(42,52,2)
(34,7,2)
(46,36,2)
(48,24,2)
(13,63,2)
(29,50,2)
(40,36,2)
(41,24,2)
(14,52,2)
(47,24,2)
(32,60,2)
(35,50,2)
(19,24,2)
(58,52,2)
(30,34,2)
(21,24,2)
(61,24,2)
(21,36,2)
(34,52,2)
(25,52,2)
(13,7,2)
(60,36,2)
(51,50,2)
(61,63,2)
(27,24,2)
(24,52,2)
(20,24,2)
(49,52,2)
(24,13,2)
(55,34,2)
(24,34,2)
(9,50,2)
(31,50,2)
(34,59,2)
(7,50,2)
(40,24,2)
(1,24,2)
(10,50,2)
(61,20,2)
(59,52,2)
(44,24,2)
(11,24,2)
(62,24,2)
(56,24,2)
(5,60,2)
(13,34,2)
(17,52,2)
(5,32,2)
(19,0,2)
(36,19,2)
(36,24,2)
(60,24,2)
(19,41,2)
-----------------------------------
(0,wchar_t *)
(1,myString)
(2,)
(3,if (data > wcslen(HELLO_STRING)
(4,default:)
(5,exit(-1)
(6,)
(7,data = rand()
(8,)
(9,break;)
(10,printLine("Benign, fixed string")
(11,"Input is less than the length of the source string or too large")
(12,0)
(13,data < 100)
(14,"Benign, fixed string")
(15,default:)
(16,switch(7)
(17,data)
(18,)
(19,(wchar_t *)
(20,sizeof(wchar_t)
(21,free(myString)
(22,wchar_t)
(23,case 6:)
(24,data > wcslen(HELLO_STRING)
(25,break;)
(26,NULL)
(27,myString)
(28,case 7:)
(29,break;)
(30,data)
(31,data)
(32,-1)
(33,myString)
(34,data > wcslen(HELLO_STRING)
(35,rand()
(36,myString = (wchar_t *)
(37,switch(6)
(38,RET)
(39,1)
(40,wcscpy(myString, HELLO_STRING)
(41,malloc(data*sizeof(wchar_t)
(42,HELLO_STRING)
(43,)
(44,printLine("Input is less than the length of the source string or too large")
(45,)
(46,printWLine(myString)
(47,HELLO_STRING)
(48,myString)
(49,break;)
(50,6)
(51,"Benign, fixed string")
(52,7)
(53,data)
(54,)
(55,100)
(56,myString)
(57,data)
(58,printLine("Benign, fixed string")
(59,wcslen(HELLO_STRING)
(60,myString == NULL)
(61,data*sizeof(wchar_t)
(62,myString)
(63,data = 0)
(64,if (myString == NULL)
(65,data)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^