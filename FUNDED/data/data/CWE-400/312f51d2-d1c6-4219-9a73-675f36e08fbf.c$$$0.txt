-----label-----
0
-----code-----
static struct ast_channel *ast_iax2_new(int callno, int state, iax2_format capability, const char *linkedid)
{
	struct ast_channel *tmp;
	struct chan_iax2_pvt *i;
	struct ast_variable *v = NULL;
	struct ast_format tmpfmt;
	struct ast_callid *callid;

	if (!(i = iaxs[callno])) {
		ast_log(LOG_WARNING, "No IAX2 pvt found for callno '%d' !\n", callno);
		return NULL;
	}

	/* Don't hold call lock */
	ast_mutex_unlock(&iaxsl[callno]);
	tmp = ast_channel_alloc(1, state, i->cid_num, i->cid_name, i->accountcode, i->exten, i->context, linkedid, i->amaflags, "IAX2/%s-%d", i->host, i->callno);
	ast_mutex_lock(&iaxsl[callno]);
	if (i != iaxs[callno]) {
		if (tmp) {
			/* unlock and relock iaxsl[callno] to preserve locking order */
			ast_mutex_unlock(&iaxsl[callno]);
			tmp = ast_channel_release(tmp);
			ast_mutex_lock(&iaxsl[callno]);
		}
		return NULL;
	}
	iax2_ami_channelupdate(i);
	if (!tmp) {
		return NULL;
	}

	if ((callid = iaxs[callno]->callid)) {
		ast_channel_callid_set(tmp, callid);
	}

	ast_channel_tech_set(tmp, &iax2_tech);
	/* We can support any format by default, until we get restricted */
	ast_format_cap_from_old_bitfield(ast_channel_nativeformats(tmp), capability);
	ast_best_codec(ast_channel_nativeformats(tmp), &tmpfmt);

	ast_format_copy(ast_channel_readformat(tmp), &tmpfmt);
	ast_format_copy(ast_channel_rawreadformat(tmp), &tmpfmt);
	ast_format_copy(ast_channel_writeformat(tmp), &tmpfmt);
	ast_format_copy(ast_channel_rawwriteformat(tmp), &tmpfmt);

	ast_channel_tech_pvt_set(tmp, CALLNO_TO_PTR(i->callno));

	if (!ast_strlen_zero(i->parkinglot))
		ast_channel_parkinglot_set(tmp, i->parkinglot);
	/* Don't use ast_set_callerid() here because it will
	 * generate a NewCallerID event before the NewChannel event */
	if (!ast_strlen_zero(i->ani)) {
		ast_channel_caller(tmp)->ani.number.valid = 1;
		ast_channel_caller(tmp)->ani.number.str = ast_strdup(i->ani);
	} else if (!ast_strlen_zero(i->cid_num)) {
		ast_channel_caller(tmp)->ani.number.valid = 1;
		ast_channel_caller(tmp)->ani.number.str = ast_strdup(i->cid_num);
	}
	ast_channel_dialed(tmp)->number.str = ast_strdup(i->dnid);
	if (!ast_strlen_zero(i->rdnis)) {
		ast_channel_redirecting(tmp)->from.number.valid = 1;
		ast_channel_redirecting(tmp)->from.number.str = ast_strdup(i->rdnis);
	}
	ast_channel_caller(tmp)->id.name.presentation = i->calling_pres;
	ast_channel_caller(tmp)->id.number.presentation = i->calling_pres;
	ast_channel_caller(tmp)->id.number.plan = i->calling_ton;
	ast_channel_dialed(tmp)->transit_network_select = i->calling_tns;
	if (!ast_strlen_zero(i->language))
		ast_channel_language_set(tmp, i->language);
	if (!ast_strlen_zero(i->accountcode))
		ast_channel_accountcode_set(tmp, i->accountcode);
	if (i->amaflags)
		ast_channel_amaflags_set(tmp, i->amaflags);
	ast_channel_context_set(tmp, i->context);
	ast_channel_exten_set(tmp, i->exten);
	if (i->adsi)
		ast_channel_adsicpe_set(tmp, i->peeradsicpe);
	else
		ast_channel_adsicpe_set(tmp, AST_ADSI_UNAVAILABLE);
	i->owner = tmp;
	i->capability = capability;

	/* Set inherited variables */
	if (i->vars) {
		for (v = i->vars ; v ; v = v->next)
			pbx_builtin_setvar_helper(tmp, v->name, v->value);
	}
	if (i->iaxvars) {
		struct ast_datastore *variablestore;
		struct ast_variable *var, *prev = NULL;
		AST_LIST_HEAD(, ast_var_t) *varlist;
		ast_debug(1, "Loading up the channel with IAXVARs\n");
		varlist = ast_calloc(1, sizeof(*varlist));
		variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);
		if (variablestore && varlist) {
			variablestore->data = varlist;
			variablestore->inheritance = DATASTORE_INHERIT_FOREVER;
			AST_LIST_HEAD_INIT(varlist);
			for (var = i->iaxvars; var; var = var->next) {
				struct ast_var_t *newvar = ast_var_assign(var->name, var->value);
				if (prev)
					ast_free(prev);
				prev = var;
				if (!newvar) {
					/* Don't abort list traversal, as this would leave i->iaxvars in an inconsistent state. */
					ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");
				} else {
					AST_LIST_INSERT_TAIL(varlist, newvar, entries);
				}
			}
			if (prev)
				ast_free(prev);
			i->iaxvars = NULL;
			ast_channel_datastore_add(i->owner, variablestore);
		} else {
			if (variablestore) {
				ast_datastore_free(variablestore);
			}
			if (varlist) {
				ast_free(varlist);
			}
		}
	}

	if (state != AST_STATE_DOWN) {
		if (ast_pbx_start(tmp)) {
			ast_log(LOG_WARNING, "Unable to start PBX on %s\n", ast_channel_name(tmp));
			ast_hangup(tmp);
			i->owner = NULL;
			return NULL;
		}
	}

	ast_module_ref(ast_module_info->self);
	return tmp;
}
-----children-----
1,2
1,3
1,4
2,3
4,5
4,6
4,7
4,8
4,9
4,10
7,8
7,9
9,10
11,12
11,13
13,14
15,16
15,17
16,17
18,19
20,21
20,22
22,23
22,24
25,26
25,27
25,28
25,29
25,30
25,31
25,32
25,33
25,34
25,35
25,36
25,37
25,38
25,39
25,40
25,41
25,42
25,43
25,44
25,45
25,46
25,47
25,48
25,49
25,50
25,51
25,52
25,53
25,54
25,55
25,56
25,57
25,58
25,59
25,60
25,61
25,62
25,63
25,64
25,65
25,66
25,67
26,27
27,28
27,29
28,29
30,31
30,32
33,34
34,35
34,36
35,36
37,38
37,39
40,41
41,42
41,43
42,43
44,45
44,46
44,47
47,48
48,49
50,51
51,52
51,53
52,53
54,55
56,57
57,58
57,59
58,59
60,61
60,62
63,64
63,65
64,65
65,66
66,67
66,68
67,68
69,70
69,71
70,71
72,73
74,75
74,76
75,76
76,77
76,78
76,79
76,80
77,78
79,80
82,83
84,85
85,86
87,88
88,89
88,90
89,90
91,92
92,93
92,94
92,95
95,96
96,97
98,99
99,100
99,101
100,101
102,103
102,104
102,105
102,106
102,107
102,108
102,109
102,110
102,111
102,112
102,113
102,114
102,115
103,104
106,107
108,109
108,110
109,110
112,113
112,114
113,114
116,117
116,118
117,118
120,121
120,122
121,122
124,125
124,126
125,126
128,129
130,131
130,132
131,132
135,136
135,137
136,137
139,140
139,141
140,141
143,144
144,145
144,146
145,146
147,148
148,149
148,150
149,150
151,152
153,154
153,155
154,155
154,156
155,156
157,158
157,159
158,159
160,161
162,163
162,164
163,164
163,165
164,165
166,167
166,168
166,169
167,168
168,169
168,170
169,170
171,172
172,173
172,174
173,174
175,176
177,178
178,179
178,180
179,180
181,182
181,183
182,183
184,185
186,187
187,188
187,189
188,189
190,191
191,192
191,193
192,193
194,195
196,197
197,198
199,200
200,201
200,202
201,202
203,204
205,206
205,207
206,207
207,208
209,210
210,211
211,212
213,214
213,215
214,215
215,216
215,217
216,217
218,219
218,220
219,220
219,221
220,221
222,223
225,226
226,227
227,228
227,229
227,230
228,229
230,231
232,233
234,235
235,236
235,237
235,238
236,237
238,239
240,241
241,242
243,244
244,245
244,246
244,247
245,246
247,248
247,249
248,249
250,251
252,253
254,255
255,256
255,257
255,258
256,257
258,259
258,260
259,260
261,262
263,264
264,265
266,267
267,268
267,269
267,270
268,269
270,271
270,272
271,272
273,274
275,276
276,277
278,279
279,280
279,281
279,282
280,281
282,283
282,284
283,284
285,286
287,288
288,289
290,291
291,292
291,293
291,294
292,293
294,295
294,296
295,296
297,298
299,300
300,301
302,303
303,304
303,305
303,306
304,305
306,307
306,308
307,308
309,310
311,312
312,313
314,315
315,316
315,317
315,318
316,317
318,319
320,321
320,322
321,322
323,324
323,325
324,325
327,328
327,329
328,329
329,330
329,331
330,331
332,333
332,334
333,334
336,337
337,338
337,339
337,340
338,339
340,341
342,343
342,344
343,344
346,347
346,348
346,349
347,348
348,349
348,350
349,350
351,352
351,353
352,353
355,356
355,357
356,357
357,358
357,359
358,359
358,360
359,360
359,361
360,361
360,362
361,362
361,363
362,363
364,365
370,371
371,372
371,373
372,373
372,374
373,374
373,375
374,375
374,376
375,376
375,377
376,377
378,379
383,384
383,385
384,385
386,387
386,388
387,388
390,391
390,392
391,392
392,393
392,394
393,394
395,396
395,397
396,397
399,400
399,401
400,401
401,402
401,403
402,403
402,404
403,404
403,405
404,405
404,406
405,406
405,407
406,407
408,409
414,415
415,416
415,417
416,417
416,418
417,418
417,419
418,419
418,420
419,420
419,421
420,421
422,423
427,428
427,429
428,429
430,431
430,432
431,432
434,435
435,436
435,437
436,437
436,438
437,438
437,439
438,439
438,440
439,440
441,442
445,446
445,447
446,447
448,449
448,450
449,450
452,453
452,454
453,454
454,455
454,456
455,456
457,458
457,459
458,459
461,462
461,463
462,463
463,464
463,465
464,465
464,466
465,466
465,467
466,467
466,468
467,468
467,469
468,469
470,471
476,477
477,478
477,479
478,479
478,480
479,480
479,481
480,481
480,482
481,482
481,483
482,483
484,485
489,490
489,491
490,491
492,493
492,494
493,494
496,497
497,498
497,499
498,499
498,500
499,500
499,501
500,501
500,502
501,502
501,503
502,503
504,505
509,510
509,511
510,511
513,514
514,515
514,516
515,516
515,517
516,517
516,518
517,518
517,519
518,519
518,520
519,520
521,522
526,527
526,528
527,528
530,531
531,532
531,533
532,533
532,534
533,534
533,535
534,535
534,536
535,536
535,537
536,537
538,539
543,544
543,545
544,545
547,548
548,549
548,550
549,550
549,551
550,551
550,552
551,552
553,554
556,557
556,558
557,558
560,561
560,562
561,562
562,563
562,564
563,564
565,566
565,567
566,567
569,570
570,571
570,572
570,573
571,572
573,574
575,576
575,577
576,577
579,580
579,581
580,581
581,582
581,583
582,583
584,585
584,586
585,586
588,589
589,590
589,591
589,592
590,591
592,593
594,595
594,596
595,596
598,599
598,600
599,600
599,601
600,601
603,604
604,605
604,606
604,607
605,606
607,608
609,610
609,611
610,611
613,614
614,615
614,616
614,617
615,616
617,618
619,620
619,621
620,621
623,624
624,625
624,626
624,627
625,626
627,628
629,630
629,631
630,631
633,634
633,635
633,636
634,635
634,636
635,636
638,639
639,640
639,641
639,642
640,641
642,643
644,645
644,646
645,646
648,649
649,650
649,651
649,652
650,651
652,653
654,655
656,657
657,658
657,659
658,659
658,660
659,660
662,663
664,665
665,666
665,667
666,667
666,668
667,668
670,671
672,673
672,674
673,674
673,675
674,675
677,678
678,679
678,680
678,681
678,682
679,680
680,681
680,682
681,682
683,684
683,685
684,685
687,688
689,690
689,691
690,691
692,693
692,694
693,694
696,697
697,698
697,699
697,700
697,701
698,699
700,701
702,703
702,704
703,704
706,707
706,708
707,708
710,711
710,712
711,712
711,713
712,713
715,716
715,717
715,718
715,719
715,720
715,721
715,722
716,717
717,718
717,719
718,719
720,721
720,722
723,724
724,725
724,726
724,727
725,726
727,728
727,729
730,731
730,732
730,733
733,734
734,735
736,737
737,738
738,739
738,740
738,741
739,740
743,744
744,745
744,746
745,746
747,748
747,749
747,750
748,749
751,752
752,753
753,754
754,755
756,757
757,758
757,759
758,759
760,761
760,762
760,763
761,762
763,764
764,765
766,767
768,769
768,770
768,771
769,770
769,771
770,771
772,773
774,775
774,776
774,777
774,778
774,779
774,780
774,781
775,776
776,777
776,778
777,778
777,779
778,779
781,782
783,784
784,785
784,786
785,786
785,787
786,787
789,790
791,792
792,793
792,794
793,794
795,796
796,797
798,799
798,800
798,801
798,802
799,800
800,801
800,802
801,802
803,804
803,805
804,805
807,808
809,810
809,811
810,811
812,813
812,814
813,814
816,817
816,818
816,819
816,820
817,818
818,819
818,820
819,820
821,822
821,823
821,824
824,825
825,826
825,827
825,828
826,827
828,829
828,830
829,830
832,833
832,834
833,834
836,837
836,838
837,838
839,840
840,841
840,842
841,842
843,844
845,846
846,847
846,848
847,848
849,850
851,852
851,853
851,854
852,853
853,854
855,856
856,857
857,858
857,859
857,860
858,859
860,861
863,864
864,865
865,866
865,867
865,868
865,869
866,867
868,869
870,871
872,873
874,875
874,876
875,876
877,878
878,879
878,880
879,880
881,882
883,884
884,885
884,886
885,886
885,887
886,887
889,890
891,892
892,893
892,894
892,895
893,894
895,896
895,897
896,897
899,900
901,902
901,903
902,903
902,904
903,904
905,906
906,907
907,908
907,909
908,909
910,911
912,913
912,914
913,914
915,916
916,917
917,918
917,919
918,919
920,921
921,922
923,924
923,925
924,925
924,926
925,926
927,928
929,930
930,931
930,932
931,932
931,933
932,933
934,935
936,937
936,938
936,939
936,940
937,938
938,939
938,940
938,941
938,942
939,940
941,942
944,945
944,946
945,946
947,948
949,950
950,951
950,952
951,952
953,954
955,956
956,957
956,958
957,958
957,959
958,959
961,962
963,964
964,965
966,967
967,968
967,969
968,969
970,971
970,972
971,972
974,975
975,976
-----nextToken-----
3,5,6,8,10,12,14,17,19,21,23,24,29,31,32,36,38,39,43,45,46,49,53,55,59,61,62,68,71,73,78,80,81,83,86,90,93,94,97,101,104,105,107,110,111,114,115,118,119,122,123,126,127,129,132,133,134,137,138,141,142,146,150,152,156,159,161,165,170,174,176,180,183,185,189,193,195,198,202,204,208,212,217,221,223,224,229,231,233,237,239,242,246,249,251,253,257,260,262,265,269,272,274,277,281,284,286,289,293,296,298,301,305,308,310,313,317,319,322,325,326,331,334,335,339,341,344,345,350,353,354,363,365,366,367,368,369,377,379,380,381,382,385,388,389,394,397,398,407,409,410,411,412,413,421,423,424,425,426,429,432,433,440,442,443,444,447,450,451,456,459,460,469,471,472,473,474,475,483,485,486,487,488,491,494,495,503,505,506,507,508,511,512,520,522,523,524,525,528,529,537,539,540,541,542,545,546,552,554,555,558,559,564,567,568,572,574,577,578,583,586,587,591,593,596,597,601,602,606,608,611,612,616,618,621,622,626,628,631,632,636,637,641,643,646,647,651,653,655,660,661,663,668,669,671,675,676,682,685,686,688,691,694,695,699,701,704,705,708,709,713,714,719,721,722,726,728,729,731,732,735,740,741,742,746,749,750,755,759,762,765,767,771,773,779,780,782,787,788,790,794,797,802,805,806,808,811,814,815,820,822,823,827,830,831,834,835,838,842,844,848,850,854,859,861,862,867,869,871,873,876,880,882,887,888,890,894,897,898,900,904,909,911,914,919,922,926,928,933,935,940,942,943,946,948,952,954,959,960,962,965,969,972,973,976
-----computeFrom-----
66,67
66,68
99,100
99,101
154,155
154,156
178,179
178,180
215,216
215,217
357,358
357,359
371,372
371,373
401,402
401,403
415,416
415,417
435,436
435,437
463,464
463,465
477,478
477,479
497,498
497,499
514,515
514,516
531,532
531,533
548,549
548,550
657,658
657,659
665,666
665,667
680,681
680,682
689,690
689,691
744,745
744,746
757,758
757,759
769,770
769,771
776,777
776,778
784,785
784,786
800,801
800,802
809,810
809,811
846,847
846,848
884,885
884,886
924,925
924,926
956,957
956,958
-----guardedBy-----
161,195
771,900
773,869
-----guardedByNegation-----
771,911
773,922
-----lastLexicalUse-----
771,911
773,922
-----jump-----
771,911
773,922
-----attribute-----
FunctionDefinition;ElaboratedTypeSpecifier;Name;FunctionDeclarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;IfStatement;UnaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;ReturnStatement;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ArrayDeclarator;ReferenceOperator;Name;ArrayModifier;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;ReturnStatement;IdExpression;Name;IfStatement;UnaryExpression;BinaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;FieldReference;FunctionCallExpression;IdExpression;Name;IdExpression;Name;Name;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;FieldReference;FunctionCallExpression;IdExpression;Name;IdExpression;Name;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;FieldReference;FunctionCallExpression;IdExpression;Name;IdExpression;Name;Name;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;FieldReference;FunctionCallExpression;IdExpression;Name;IdExpression;Name;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;FunctionCallExpression;IdExpression;Name;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;FieldReference;FunctionCallExpression;IdExpression;Name;IdExpression;Name;Name;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;FieldReference;FunctionCallExpression;IdExpression;Name;IdExpression;Name;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;FieldReference;FunctionCallExpression;IdExpression;Name;IdExpression;Name;Name;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;FieldReference;FunctionCallExpression;IdExpression;Name;IdExpression;Name;Name;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;FieldReference;FunctionCallExpression;IdExpression;Name;IdExpression;Name;Name;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;FunctionCallExpression;IdExpression;Name;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;ProblemStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ReturnStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ReturnStatement;IdExpression;Name;
-----ast_node-----
static struct ast_channel *ast_iax2_new(int callno, int state, iax2_format capability, const char *linkedid){	struct ast_channel *tmp;	struct chan_iax2_pvt *i;	struct ast_variable *v = NULL;	struct ast_format tmpfmt;	struct ast_callid *callid;	if (!(i = iaxs[callno])) {		ast_log(LOG_WARNING, "No IAX2 pvt found for callno '%d' !\n", callno);		return NULL;	}	/* Don't hold call lock */	ast_mutex_unlock(&iaxsl[callno]);	tmp = ast_channel_alloc(1, state, i->cid_num, i->cid_name, i->accountcode, i->exten, i->context, linkedid, i->amaflags, "IAX2/%s-%d", i->host, i->callno);	ast_mutex_lock(&iaxsl[callno]);	if (i != iaxs[callno]) {		if (tmp) {			/* unlock and relock iaxsl[callno] to preserve locking order */			ast_mutex_unlock(&iaxsl[callno]);			tmp = ast_channel_release(tmp);			ast_mutex_lock(&iaxsl[callno]);		}		return NULL;	}	iax2_ami_channelupdate(i);	if (!tmp) {		return NULL;	}	if ((callid = iaxs[callno]->callid)) {		ast_channel_callid_set(tmp, callid);	}	ast_channel_tech_set(tmp, &iax2_tech);	/* We can support any format by default, until we get restricted */	ast_format_cap_from_old_bitfield(ast_channel_nativeformats(tmp), capability);	ast_best_codec(ast_channel_nativeformats(tmp), &tmpfmt);	ast_format_copy(ast_channel_readformat(tmp), &tmpfmt);	ast_format_copy(ast_channel_rawreadformat(tmp), &tmpfmt);	ast_format_copy(ast_channel_writeformat(tmp), &tmpfmt);	ast_format_copy(ast_channel_rawwriteformat(tmp), &tmpfmt);	ast_channel_tech_pvt_set(tmp, CALLNO_TO_PTR(i->callno));	if (!ast_strlen_zero(i->parkinglot))		ast_channel_parkinglot_set(tmp, i->parkinglot);	/* Don't use ast_set_callerid() here because it will	 * generate a NewCallerID event before the NewChannel event */	if (!ast_strlen_zero(i->ani)) {		ast_channel_caller(tmp)->ani.number.valid = 1;		ast_channel_caller(tmp)->ani.number.str = ast_strdup(i->ani);	} else if (!ast_strlen_zero(i->cid_num)) {		ast_channel_caller(tmp)->ani.number.valid = 1;		ast_channel_caller(tmp)->ani.number.str = ast_strdup(i->cid_num);	}	ast_channel_dialed(tmp)->number.str = ast_strdup(i->dnid);	if (!ast_strlen_zero(i->rdnis)) {		ast_channel_redirecting(tmp)->from.number.valid = 1;		ast_channel_redirecting(tmp)->from.number.str = ast_strdup(i->rdnis);	}	ast_channel_caller(tmp)->id.name.presentation = i->calling_pres;	ast_channel_caller(tmp)->id.number.presentation = i->calling_pres;	ast_channel_caller(tmp)->id.number.plan = i->calling_ton;	ast_channel_dialed(tmp)->transit_network_select = i->calling_tns;	if (!ast_strlen_zero(i->language))		ast_channel_language_set(tmp, i->language);	if (!ast_strlen_zero(i->accountcode))		ast_channel_accountcode_set(tmp, i->accountcode);	if (i->amaflags)		ast_channel_amaflags_set(tmp, i->amaflags);	ast_channel_context_set(tmp, i->context);	ast_channel_exten_set(tmp, i->exten);	if (i->adsi)		ast_channel_adsicpe_set(tmp, i->peeradsicpe);	else		ast_channel_adsicpe_set(tmp, AST_ADSI_UNAVAILABLE);	i->owner = tmp;	i->capability = capability;	/* Set inherited variables */	if (i->vars) {		for (v = i->vars ; v ; v = v->next)			pbx_builtin_setvar_helper(tmp, v->name, v->value);	}	if (i->iaxvars) {		struct ast_datastore *variablestore;		struct ast_variable *var, *prev = NULL;		AST_LIST_HEAD(, ast_var_t) *varlist;		ast_debug(1, "Loading up the channel with IAXVARs\n");		varlist = ast_calloc(1, sizeof(*varlist));		variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);		if (variablestore && varlist) {			variablestore->data = varlist;			variablestore->inheritance = DATASTORE_INHERIT_FOREVER;			AST_LIST_HEAD_INIT(varlist);			for (var = i->iaxvars; var; var = var->next) {				struct ast_var_t *newvar = ast_var_assign(var->name, var->value);				if (prev)					ast_free(prev);				prev = var;				if (!newvar) {					/* Don't abort list traversal, as this would leave i->iaxvars in an inconsistent state. */					ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");				} else {					AST_LIST_INSERT_TAIL(varlist, newvar, entries);				}			}			if (prev)				ast_free(prev);			i->iaxvars = NULL;			ast_channel_datastore_add(i->owner, variablestore);		} else {			if (variablestore) {				ast_datastore_free(variablestore);			}			if (varlist) {				ast_free(varlist);			}		}	}	if (state != AST_STATE_DOWN) {		if (ast_pbx_start(tmp)) {			ast_log(LOG_WARNING, "Unable to start PBX on %s\n", ast_channel_name(tmp));			ast_hangup(tmp);			i->owner = NULL;			return NULL;		}	}	ast_module_ref(ast_module_info->self);	return tmp;}
static struct ast_channel
ast_channel
*ast_iax2_new(int callno, int state, iax2_format capability, const char *linkedid)
*
ast_iax2_new
int callno
int
callno
callno
int state
int
state
state
iax2_format capability
iax2_format
iax2_format
capability
capability
const char *linkedid
const char
*linkedid
*
linkedid
{	struct ast_channel *tmp;	struct chan_iax2_pvt *i;	struct ast_variable *v = NULL;	struct ast_format tmpfmt;	struct ast_callid *callid;	if (!(i = iaxs[callno])) {		ast_log(LOG_WARNING, "No IAX2 pvt found for callno '%d' !\n", callno);		return NULL;	}	/* Don't hold call lock */	ast_mutex_unlock(&iaxsl[callno]);	tmp = ast_channel_alloc(1, state, i->cid_num, i->cid_name, i->accountcode, i->exten, i->context, linkedid, i->amaflags, "IAX2/%s-%d", i->host, i->callno);	ast_mutex_lock(&iaxsl[callno]);	if (i != iaxs[callno]) {		if (tmp) {			/* unlock and relock iaxsl[callno] to preserve locking order */			ast_mutex_unlock(&iaxsl[callno]);			tmp = ast_channel_release(tmp);			ast_mutex_lock(&iaxsl[callno]);		}		return NULL;	}	iax2_ami_channelupdate(i);	if (!tmp) {		return NULL;	}	if ((callid = iaxs[callno]->callid)) {		ast_channel_callid_set(tmp, callid);	}	ast_channel_tech_set(tmp, &iax2_tech);	/* We can support any format by default, until we get restricted */	ast_format_cap_from_old_bitfield(ast_channel_nativeformats(tmp), capability);	ast_best_codec(ast_channel_nativeformats(tmp), &tmpfmt);	ast_format_copy(ast_channel_readformat(tmp), &tmpfmt);	ast_format_copy(ast_channel_rawreadformat(tmp), &tmpfmt);	ast_format_copy(ast_channel_writeformat(tmp), &tmpfmt);	ast_format_copy(ast_channel_rawwriteformat(tmp), &tmpfmt);	ast_channel_tech_pvt_set(tmp, CALLNO_TO_PTR(i->callno));	if (!ast_strlen_zero(i->parkinglot))		ast_channel_parkinglot_set(tmp, i->parkinglot);	/* Don't use ast_set_callerid() here because it will	 * generate a NewCallerID event before the NewChannel event */	if (!ast_strlen_zero(i->ani)) {		ast_channel_caller(tmp)->ani.number.valid = 1;		ast_channel_caller(tmp)->ani.number.str = ast_strdup(i->ani);	} else if (!ast_strlen_zero(i->cid_num)) {		ast_channel_caller(tmp)->ani.number.valid = 1;		ast_channel_caller(tmp)->ani.number.str = ast_strdup(i->cid_num);	}	ast_channel_dialed(tmp)->number.str = ast_strdup(i->dnid);	if (!ast_strlen_zero(i->rdnis)) {		ast_channel_redirecting(tmp)->from.number.valid = 1;		ast_channel_redirecting(tmp)->from.number.str = ast_strdup(i->rdnis);	}	ast_channel_caller(tmp)->id.name.presentation = i->calling_pres;	ast_channel_caller(tmp)->id.number.presentation = i->calling_pres;	ast_channel_caller(tmp)->id.number.plan = i->calling_ton;	ast_channel_dialed(tmp)->transit_network_select = i->calling_tns;	if (!ast_strlen_zero(i->language))		ast_channel_language_set(tmp, i->language);	if (!ast_strlen_zero(i->accountcode))		ast_channel_accountcode_set(tmp, i->accountcode);	if (i->amaflags)		ast_channel_amaflags_set(tmp, i->amaflags);	ast_channel_context_set(tmp, i->context);	ast_channel_exten_set(tmp, i->exten);	if (i->adsi)		ast_channel_adsicpe_set(tmp, i->peeradsicpe);	else		ast_channel_adsicpe_set(tmp, AST_ADSI_UNAVAILABLE);	i->owner = tmp;	i->capability = capability;	/* Set inherited variables */	if (i->vars) {		for (v = i->vars ; v ; v = v->next)			pbx_builtin_setvar_helper(tmp, v->name, v->value);	}	if (i->iaxvars) {		struct ast_datastore *variablestore;		struct ast_variable *var, *prev = NULL;		AST_LIST_HEAD(, ast_var_t) *varlist;		ast_debug(1, "Loading up the channel with IAXVARs\n");		varlist = ast_calloc(1, sizeof(*varlist));		variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);		if (variablestore && varlist) {			variablestore->data = varlist;			variablestore->inheritance = DATASTORE_INHERIT_FOREVER;			AST_LIST_HEAD_INIT(varlist);			for (var = i->iaxvars; var; var = var->next) {				struct ast_var_t *newvar = ast_var_assign(var->name, var->value);				if (prev)					ast_free(prev);				prev = var;				if (!newvar) {					/* Don't abort list traversal, as this would leave i->iaxvars in an inconsistent state. */					ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");				} else {					AST_LIST_INSERT_TAIL(varlist, newvar, entries);				}			}			if (prev)				ast_free(prev);			i->iaxvars = NULL;			ast_channel_datastore_add(i->owner, variablestore);		} else {			if (variablestore) {				ast_datastore_free(variablestore);			}			if (varlist) {				ast_free(varlist);			}		}	}	if (state != AST_STATE_DOWN) {		if (ast_pbx_start(tmp)) {			ast_log(LOG_WARNING, "Unable to start PBX on %s\n", ast_channel_name(tmp));			ast_hangup(tmp);			i->owner = NULL;			return NULL;		}	}	ast_module_ref(ast_module_info->self);	return tmp;}
struct ast_channel *tmp;
struct ast_channel *tmp;
struct ast_channel
ast_channel
*tmp
*
tmp
struct chan_iax2_pvt *i;
struct chan_iax2_pvt *i;
struct chan_iax2_pvt
chan_iax2_pvt
*i
*
i
struct ast_variable *v = NULL;
struct ast_variable *v = NULL;
struct ast_variable
ast_variable
*v = NULL
*
v
= NULL
NULL
NULL
struct ast_format tmpfmt;
struct ast_format tmpfmt;
struct ast_format
ast_format
tmpfmt
tmpfmt
struct ast_callid *callid;
struct ast_callid *callid;
struct ast_callid
ast_callid
*callid
*
callid
if (!(i = iaxs[callno])) {		ast_log(LOG_WARNING, "No IAX2 pvt found for callno '%d' !\n", callno);		return NULL;	}
!(i = iaxs[callno])
(i = iaxs[callno])
i = iaxs[callno]
i
i
iaxs[callno]
iaxs
iaxs
callno
callno
{		ast_log(LOG_WARNING, "No IAX2 pvt found for callno '%d' !\n", callno);		return NULL;	}
ast_log(LOG_WARNING, "No IAX2 pvt found for callno '%d' !\n", callno);
ast_log(LOG_WARNING, "No IAX2 pvt found for callno '%d' !\n", callno)
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"No IAX2 pvt found for callno '%d' !\n"
callno
callno
return NULL;
NULL
NULL
ast_mutex_unlock(&iaxsl[callno]);
ast_mutex_unlock(&iaxsl[callno]);
ast_mutex_unlock
ast_mutex_unlock
(&iaxsl[callno])
&iaxsl[callno]
&
iaxsl
[callno]
callno
callno
tmp = ast_channel_alloc(1, state, i->cid_num, i->cid_name, i->accountcode, i->exten, i->context, linkedid, i->amaflags, "IAX2/%s-%d", i->host, i->callno);
tmp = ast_channel_alloc(1, state, i->cid_num, i->cid_name, i->accountcode, i->exten, i->context, linkedid, i->amaflags, "IAX2/%s-%d", i->host, i->callno)
tmp
tmp
ast_channel_alloc(1, state, i->cid_num, i->cid_name, i->accountcode, i->exten, i->context, linkedid, i->amaflags, "IAX2/%s-%d", i->host, i->callno)
ast_channel_alloc
ast_channel_alloc
1
state
state
i->cid_num
i
i
cid_num
i->cid_name
i
i
cid_name
i->accountcode
i
i
accountcode
i->exten
i
i
exten
i->context
i
i
context
linkedid
linkedid
i->amaflags
i
i
amaflags
"IAX2/%s-%d"
i->host
i
i
host
i->callno
i
i
callno
ast_mutex_lock(&iaxsl[callno]);
ast_mutex_lock(&iaxsl[callno])
ast_mutex_lock
ast_mutex_lock
&iaxsl[callno]
iaxsl[callno]
iaxsl
iaxsl
callno
callno
if (i != iaxs[callno]) {		if (tmp) {			/* unlock and relock iaxsl[callno] to preserve locking order */			ast_mutex_unlock(&iaxsl[callno]);			tmp = ast_channel_release(tmp);			ast_mutex_lock(&iaxsl[callno]);		}		return NULL;	}
i != iaxs[callno]
i
i
iaxs[callno]
iaxs
iaxs
callno
callno
{		if (tmp) {			/* unlock and relock iaxsl[callno] to preserve locking order */			ast_mutex_unlock(&iaxsl[callno]);			tmp = ast_channel_release(tmp);			ast_mutex_lock(&iaxsl[callno]);		}		return NULL;	}
if (tmp) {			/* unlock and relock iaxsl[callno] to preserve locking order */			ast_mutex_unlock(&iaxsl[callno]);			tmp = ast_channel_release(tmp);			ast_mutex_lock(&iaxsl[callno]);		}
tmp
tmp
{			/* unlock and relock iaxsl[callno] to preserve locking order */			ast_mutex_unlock(&iaxsl[callno]);			tmp = ast_channel_release(tmp);			ast_mutex_lock(&iaxsl[callno]);		}
ast_mutex_unlock(&iaxsl[callno]);
ast_mutex_unlock(&iaxsl[callno])
ast_mutex_unlock
ast_mutex_unlock
&iaxsl[callno]
iaxsl[callno]
iaxsl
iaxsl
callno
callno
tmp = ast_channel_release(tmp);
tmp = ast_channel_release(tmp)
tmp
tmp
ast_channel_release(tmp)
ast_channel_release
ast_channel_release
tmp
tmp
ast_mutex_lock(&iaxsl[callno]);
ast_mutex_lock(&iaxsl[callno])
ast_mutex_lock
ast_mutex_lock
&iaxsl[callno]
iaxsl[callno]
iaxsl
iaxsl
callno
callno
return NULL;
NULL
NULL
iax2_ami_channelupdate(i);
iax2_ami_channelupdate(i)
iax2_ami_channelupdate
iax2_ami_channelupdate
i
i
if (!tmp) {		return NULL;	}
!tmp
tmp
tmp
{		return NULL;	}
return NULL;
NULL
NULL
if ((callid = iaxs[callno]->callid)) {		ast_channel_callid_set(tmp, callid);	}
(callid = iaxs[callno]->callid)
callid = iaxs[callno]->callid
callid
callid
iaxs[callno]->callid
iaxs[callno]
iaxs
iaxs
callno
callno
callid
{		ast_channel_callid_set(tmp, callid);	}
ast_channel_callid_set(tmp, callid);
ast_channel_callid_set(tmp, callid)
ast_channel_callid_set
ast_channel_callid_set
tmp
tmp
callid
callid
ast_channel_tech_set(tmp, &iax2_tech);
ast_channel_tech_set(tmp, &iax2_tech)
ast_channel_tech_set
ast_channel_tech_set
tmp
tmp
&iax2_tech
iax2_tech
iax2_tech
ast_format_cap_from_old_bitfield(ast_channel_nativeformats(tmp), capability);
ast_format_cap_from_old_bitfield(ast_channel_nativeformats(tmp), capability)
ast_format_cap_from_old_bitfield
ast_format_cap_from_old_bitfield
ast_channel_nativeformats(tmp)
ast_channel_nativeformats
ast_channel_nativeformats
tmp
tmp
capability
capability
ast_best_codec(ast_channel_nativeformats(tmp), &tmpfmt);
ast_best_codec(ast_channel_nativeformats(tmp), &tmpfmt)
ast_best_codec
ast_best_codec
ast_channel_nativeformats(tmp)
ast_channel_nativeformats
ast_channel_nativeformats
tmp
tmp
&tmpfmt
tmpfmt
tmpfmt
ast_format_copy(ast_channel_readformat(tmp), &tmpfmt);
ast_format_copy(ast_channel_readformat(tmp), &tmpfmt)
ast_format_copy
ast_format_copy
ast_channel_readformat(tmp)
ast_channel_readformat
ast_channel_readformat
tmp
tmp
&tmpfmt
tmpfmt
tmpfmt
ast_format_copy(ast_channel_rawreadformat(tmp), &tmpfmt);
ast_format_copy(ast_channel_rawreadformat(tmp), &tmpfmt)
ast_format_copy
ast_format_copy
ast_channel_rawreadformat(tmp)
ast_channel_rawreadformat
ast_channel_rawreadformat
tmp
tmp
&tmpfmt
tmpfmt
tmpfmt
ast_format_copy(ast_channel_writeformat(tmp), &tmpfmt);
ast_format_copy(ast_channel_writeformat(tmp), &tmpfmt)
ast_format_copy
ast_format_copy
ast_channel_writeformat(tmp)
ast_channel_writeformat
ast_channel_writeformat
tmp
tmp
&tmpfmt
tmpfmt
tmpfmt
ast_format_copy(ast_channel_rawwriteformat(tmp), &tmpfmt);
ast_format_copy(ast_channel_rawwriteformat(tmp), &tmpfmt)
ast_format_copy
ast_format_copy
ast_channel_rawwriteformat(tmp)
ast_channel_rawwriteformat
ast_channel_rawwriteformat
tmp
tmp
&tmpfmt
tmpfmt
tmpfmt
ast_channel_tech_pvt_set(tmp, CALLNO_TO_PTR(i->callno));
ast_channel_tech_pvt_set(tmp, CALLNO_TO_PTR(i->callno))
ast_channel_tech_pvt_set
ast_channel_tech_pvt_set
tmp
tmp
CALLNO_TO_PTR(i->callno)
CALLNO_TO_PTR
CALLNO_TO_PTR
i->callno
i
i
callno
if (!ast_strlen_zero(i->parkinglot))		ast_channel_parkinglot_set(tmp, i->parkinglot);
!ast_strlen_zero(i->parkinglot)
ast_strlen_zero(i->parkinglot)
ast_strlen_zero
ast_strlen_zero
i->parkinglot
i
i
parkinglot
ast_channel_parkinglot_set(tmp, i->parkinglot);
ast_channel_parkinglot_set(tmp, i->parkinglot)
ast_channel_parkinglot_set
ast_channel_parkinglot_set
tmp
tmp
i->parkinglot
i
i
parkinglot
if (!ast_strlen_zero(i->ani)) {		ast_channel_caller(tmp)->ani.number.valid = 1;		ast_channel_caller(tmp)->ani.number.str = ast_strdup(i->ani);	} else if (!ast_strlen_zero(i->cid_num)) {		ast_channel_caller(tmp)->ani.number.valid = 1;		ast_channel_caller(tmp)->ani.number.str = ast_strdup(i->cid_num);	}
!ast_strlen_zero(i->ani)
ast_strlen_zero(i->ani)
ast_strlen_zero
ast_strlen_zero
i->ani
i
i
ani
{		ast_channel_caller(tmp)->ani.number.valid = 1;		ast_channel_caller(tmp)->ani.number.str = ast_strdup(i->ani);	}
ast_channel_caller(tmp)->ani.number.valid = 1;
ast_channel_caller(tmp)->ani.number.valid = 1
ast_channel_caller(tmp)->ani.number.valid
ast_channel_caller(tmp)->ani.number
ast_channel_caller(tmp)->ani
ast_channel_caller(tmp)
ast_channel_caller
ast_channel_caller
tmp
tmp
ani
number
valid
1
ast_channel_caller(tmp)->ani.number.str = ast_strdup(i->ani);
ast_channel_caller(tmp)->ani.number.str = ast_strdup(i->ani)
ast_channel_caller(tmp)->ani.number.str
ast_channel_caller(tmp)->ani.number
ast_channel_caller(tmp)->ani
ast_channel_caller(tmp)
ast_channel_caller
ast_channel_caller
tmp
tmp
ani
number
str
ast_strdup(i->ani)
ast_strdup
ast_strdup
i->ani
i
i
ani
if (!ast_strlen_zero(i->cid_num)) {		ast_channel_caller(tmp)->ani.number.valid = 1;		ast_channel_caller(tmp)->ani.number.str = ast_strdup(i->cid_num);	}
!ast_strlen_zero(i->cid_num)
ast_strlen_zero(i->cid_num)
ast_strlen_zero
ast_strlen_zero
i->cid_num
i
i
cid_num
{		ast_channel_caller(tmp)->ani.number.valid = 1;		ast_channel_caller(tmp)->ani.number.str = ast_strdup(i->cid_num);	}
ast_channel_caller(tmp)->ani.number.valid = 1;
ast_channel_caller(tmp)->ani.number.valid = 1
ast_channel_caller(tmp)->ani.number.valid
ast_channel_caller(tmp)->ani.number
ast_channel_caller(tmp)->ani
ast_channel_caller(tmp)
ast_channel_caller
ast_channel_caller
tmp
tmp
ani
number
valid
1
ast_channel_caller(tmp)->ani.number.str = ast_strdup(i->cid_num);
ast_channel_caller(tmp)->ani.number.str = ast_strdup(i->cid_num)
ast_channel_caller(tmp)->ani.number.str
ast_channel_caller(tmp)->ani.number
ast_channel_caller(tmp)->ani
ast_channel_caller(tmp)
ast_channel_caller
ast_channel_caller
tmp
tmp
ani
number
str
ast_strdup(i->cid_num)
ast_strdup
ast_strdup
i->cid_num
i
i
cid_num
ast_channel_dialed(tmp)->number.str = ast_strdup(i->dnid);
ast_channel_dialed(tmp)->number.str = ast_strdup(i->dnid)
ast_channel_dialed(tmp)->number.str
ast_channel_dialed(tmp)->number
ast_channel_dialed(tmp)
ast_channel_dialed
ast_channel_dialed
tmp
tmp
number
str
ast_strdup(i->dnid)
ast_strdup
ast_strdup
i->dnid
i
i
dnid
if (!ast_strlen_zero(i->rdnis)) {		ast_channel_redirecting(tmp)->from.number.valid = 1;		ast_channel_redirecting(tmp)->from.number.str = ast_strdup(i->rdnis);	}
!ast_strlen_zero(i->rdnis)
ast_strlen_zero(i->rdnis)
ast_strlen_zero
ast_strlen_zero
i->rdnis
i
i
rdnis
{		ast_channel_redirecting(tmp)->from.number.valid = 1;		ast_channel_redirecting(tmp)->from.number.str = ast_strdup(i->rdnis);	}
ast_channel_redirecting(tmp)->from.number.valid = 1;
ast_channel_redirecting(tmp)->from.number.valid = 1
ast_channel_redirecting(tmp)->from.number.valid
ast_channel_redirecting(tmp)->from.number
ast_channel_redirecting(tmp)->from
ast_channel_redirecting(tmp)
ast_channel_redirecting
ast_channel_redirecting
tmp
tmp
from
number
valid
1
ast_channel_redirecting(tmp)->from.number.str = ast_strdup(i->rdnis);
ast_channel_redirecting(tmp)->from.number.str = ast_strdup(i->rdnis)
ast_channel_redirecting(tmp)->from.number.str
ast_channel_redirecting(tmp)->from.number
ast_channel_redirecting(tmp)->from
ast_channel_redirecting(tmp)
ast_channel_redirecting
ast_channel_redirecting
tmp
tmp
from
number
str
ast_strdup(i->rdnis)
ast_strdup
ast_strdup
i->rdnis
i
i
rdnis
ast_channel_caller(tmp)->id.name.presentation = i->calling_pres;
ast_channel_caller(tmp)->id.name.presentation = i->calling_pres
ast_channel_caller(tmp)->id.name.presentation
ast_channel_caller(tmp)->id.name
ast_channel_caller(tmp)->id
ast_channel_caller(tmp)
ast_channel_caller
ast_channel_caller
tmp
tmp
id
name
presentation
i->calling_pres
i
i
calling_pres
ast_channel_caller(tmp)->id.number.presentation = i->calling_pres;
ast_channel_caller(tmp)->id.number.presentation = i->calling_pres
ast_channel_caller(tmp)->id.number.presentation
ast_channel_caller(tmp)->id.number
ast_channel_caller(tmp)->id
ast_channel_caller(tmp)
ast_channel_caller
ast_channel_caller
tmp
tmp
id
number
presentation
i->calling_pres
i
i
calling_pres
ast_channel_caller(tmp)->id.number.plan = i->calling_ton;
ast_channel_caller(tmp)->id.number.plan = i->calling_ton
ast_channel_caller(tmp)->id.number.plan
ast_channel_caller(tmp)->id.number
ast_channel_caller(tmp)->id
ast_channel_caller(tmp)
ast_channel_caller
ast_channel_caller
tmp
tmp
id
number
plan
i->calling_ton
i
i
calling_ton
ast_channel_dialed(tmp)->transit_network_select = i->calling_tns;
ast_channel_dialed(tmp)->transit_network_select = i->calling_tns
ast_channel_dialed(tmp)->transit_network_select
ast_channel_dialed(tmp)
ast_channel_dialed
ast_channel_dialed
tmp
tmp
transit_network_select
i->calling_tns
i
i
calling_tns
if (!ast_strlen_zero(i->language))		ast_channel_language_set(tmp, i->language);
!ast_strlen_zero(i->language)
ast_strlen_zero(i->language)
ast_strlen_zero
ast_strlen_zero
i->language
i
i
language
ast_channel_language_set(tmp, i->language);
ast_channel_language_set(tmp, i->language)
ast_channel_language_set
ast_channel_language_set
tmp
tmp
i->language
i
i
language
if (!ast_strlen_zero(i->accountcode))		ast_channel_accountcode_set(tmp, i->accountcode);
!ast_strlen_zero(i->accountcode)
ast_strlen_zero(i->accountcode)
ast_strlen_zero
ast_strlen_zero
i->accountcode
i
i
accountcode
ast_channel_accountcode_set(tmp, i->accountcode);
ast_channel_accountcode_set(tmp, i->accountcode)
ast_channel_accountcode_set
ast_channel_accountcode_set
tmp
tmp
i->accountcode
i
i
accountcode
if (i->amaflags)		ast_channel_amaflags_set(tmp, i->amaflags);
i->amaflags
i
i
amaflags
ast_channel_amaflags_set(tmp, i->amaflags);
ast_channel_amaflags_set(tmp, i->amaflags)
ast_channel_amaflags_set
ast_channel_amaflags_set
tmp
tmp
i->amaflags
i
i
amaflags
ast_channel_context_set(tmp, i->context);
ast_channel_context_set(tmp, i->context)
ast_channel_context_set
ast_channel_context_set
tmp
tmp
i->context
i
i
context
ast_channel_exten_set(tmp, i->exten);
ast_channel_exten_set(tmp, i->exten)
ast_channel_exten_set
ast_channel_exten_set
tmp
tmp
i->exten
i
i
exten
if (i->adsi)		ast_channel_adsicpe_set(tmp, i->peeradsicpe);	else		ast_channel_adsicpe_set(tmp, AST_ADSI_UNAVAILABLE);
i->adsi
i
i
adsi
ast_channel_adsicpe_set(tmp, i->peeradsicpe);
ast_channel_adsicpe_set(tmp, i->peeradsicpe)
ast_channel_adsicpe_set
ast_channel_adsicpe_set
tmp
tmp
i->peeradsicpe
i
i
peeradsicpe
ast_channel_adsicpe_set(tmp, AST_ADSI_UNAVAILABLE);
ast_channel_adsicpe_set(tmp, AST_ADSI_UNAVAILABLE)
ast_channel_adsicpe_set
ast_channel_adsicpe_set
tmp
tmp
AST_ADSI_UNAVAILABLE
AST_ADSI_UNAVAILABLE
i->owner = tmp;
i->owner = tmp
i->owner
i
i
owner
tmp
tmp
i->capability = capability;
i->capability = capability
i->capability
i
i
capability
capability
capability
if (i->vars) {		for (v = i->vars ; v ; v = v->next)			pbx_builtin_setvar_helper(tmp, v->name, v->value);	}
i->vars
i
i
vars
{		for (v = i->vars ; v ; v = v->next)			pbx_builtin_setvar_helper(tmp, v->name, v->value);	}
for (v = i->vars ; v ; v = v->next)			pbx_builtin_setvar_helper(tmp, v->name, v->value);
v = i->vars ;
v = i->vars
v
v
i->vars
i
i
vars
v
v
v = v->next
v
v
v->next
v
v
next
pbx_builtin_setvar_helper(tmp, v->name, v->value);
pbx_builtin_setvar_helper(tmp, v->name, v->value)
pbx_builtin_setvar_helper
pbx_builtin_setvar_helper
tmp
tmp
v->name
v
v
name
v->value
v
v
value
if (i->iaxvars) {		struct ast_datastore *variablestore;		struct ast_variable *var, *prev = NULL;		AST_LIST_HEAD(, ast_var_t) *varlist;		ast_debug(1, "Loading up the channel with IAXVARs\n");		varlist = ast_calloc(1, sizeof(*varlist));		variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);		if (variablestore && varlist) {			variablestore->data = varlist;			variablestore->inheritance = DATASTORE_INHERIT_FOREVER;			AST_LIST_HEAD_INIT(varlist);			for (var = i->iaxvars; var; var = var->next) {				struct ast_var_t *newvar = ast_var_assign(var->name, var->value);				if (prev)					ast_free(prev);				prev = var;				if (!newvar) {					/* Don't abort list traversal, as this would leave i->iaxvars in an inconsistent state. */					ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");				} else {					AST_LIST_INSERT_TAIL(varlist, newvar, entries);				}			}			if (prev)				ast_free(prev);			i->iaxvars = NULL;			ast_channel_datastore_add(i->owner, variablestore);		} else {			if (variablestore) {				ast_datastore_free(variablestore);			}			if (varlist) {				ast_free(varlist);			}		}	}
i->iaxvars
i
i
iaxvars
{		struct ast_datastore *variablestore;		struct ast_variable *var, *prev = NULL;		AST_LIST_HEAD(, ast_var_t) *varlist;		ast_debug(1, "Loading up the channel with IAXVARs\n");		varlist = ast_calloc(1, sizeof(*varlist));		variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);		if (variablestore && varlist) {			variablestore->data = varlist;			variablestore->inheritance = DATASTORE_INHERIT_FOREVER;			AST_LIST_HEAD_INIT(varlist);			for (var = i->iaxvars; var; var = var->next) {				struct ast_var_t *newvar = ast_var_assign(var->name, var->value);				if (prev)					ast_free(prev);				prev = var;				if (!newvar) {					/* Don't abort list traversal, as this would leave i->iaxvars in an inconsistent state. */					ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");				} else {					AST_LIST_INSERT_TAIL(varlist, newvar, entries);				}			}			if (prev)				ast_free(prev);			i->iaxvars = NULL;			ast_channel_datastore_add(i->owner, variablestore);		} else {			if (variablestore) {				ast_datastore_free(variablestore);			}			if (varlist) {				ast_free(varlist);			}		}	}
struct ast_datastore *variablestore;
struct ast_datastore *variablestore;
struct ast_datastore
ast_datastore
*variablestore
*
variablestore
struct ast_variable *var, *prev = NULL;
struct ast_variable *var, *prev = NULL;
struct ast_variable
ast_variable
*var
*
var
*prev = NULL
*
prev
= NULL
NULL
NULL
AST_LIST_HEAD(, ast_var_t) *varlist;
ast_debug(1, "Loading up the channel with IAXVARs\n");
ast_debug(1, "Loading up the channel with IAXVARs\n")
ast_debug
ast_debug
1
"Loading up the channel with IAXVARs\n"
varlist = ast_calloc(1, sizeof(*varlist));
varlist = ast_calloc(1, sizeof(*varlist))
varlist
varlist
ast_calloc(1, sizeof(*varlist))
ast_calloc
ast_calloc
1
sizeof(*varlist)
(*varlist)
*varlist
varlist
varlist
variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL);
variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL)
variablestore
variablestore
ast_datastore_alloc(&iax2_variable_datastore_info, NULL)
ast_datastore_alloc
ast_datastore_alloc
&iax2_variable_datastore_info
iax2_variable_datastore_info
iax2_variable_datastore_info
NULL
NULL
if (variablestore && varlist) {			variablestore->data = varlist;			variablestore->inheritance = DATASTORE_INHERIT_FOREVER;			AST_LIST_HEAD_INIT(varlist);			for (var = i->iaxvars; var; var = var->next) {				struct ast_var_t *newvar = ast_var_assign(var->name, var->value);				if (prev)					ast_free(prev);				prev = var;				if (!newvar) {					/* Don't abort list traversal, as this would leave i->iaxvars in an inconsistent state. */					ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");				} else {					AST_LIST_INSERT_TAIL(varlist, newvar, entries);				}			}			if (prev)				ast_free(prev);			i->iaxvars = NULL;			ast_channel_datastore_add(i->owner, variablestore);		} else {			if (variablestore) {				ast_datastore_free(variablestore);			}			if (varlist) {				ast_free(varlist);			}		}
variablestore && varlist
variablestore
variablestore
varlist
varlist
{			variablestore->data = varlist;			variablestore->inheritance = DATASTORE_INHERIT_FOREVER;			AST_LIST_HEAD_INIT(varlist);			for (var = i->iaxvars; var; var = var->next) {				struct ast_var_t *newvar = ast_var_assign(var->name, var->value);				if (prev)					ast_free(prev);				prev = var;				if (!newvar) {					/* Don't abort list traversal, as this would leave i->iaxvars in an inconsistent state. */					ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");				} else {					AST_LIST_INSERT_TAIL(varlist, newvar, entries);				}			}			if (prev)				ast_free(prev);			i->iaxvars = NULL;			ast_channel_datastore_add(i->owner, variablestore);		}
variablestore->data = varlist;
variablestore->data = varlist
variablestore->data
variablestore
variablestore
data
varlist
varlist
variablestore->inheritance = DATASTORE_INHERIT_FOREVER;
variablestore->inheritance = DATASTORE_INHERIT_FOREVER
variablestore->inheritance
variablestore
variablestore
inheritance
DATASTORE_INHERIT_FOREVER
DATASTORE_INHERIT_FOREVER
AST_LIST_HEAD_INIT(varlist);
AST_LIST_HEAD_INIT(varlist);
AST_LIST_HEAD_INIT
AST_LIST_HEAD_INIT
(varlist)
varlist
varlist
for (var = i->iaxvars; var; var = var->next) {				struct ast_var_t *newvar = ast_var_assign(var->name, var->value);				if (prev)					ast_free(prev);				prev = var;				if (!newvar) {					/* Don't abort list traversal, as this would leave i->iaxvars in an inconsistent state. */					ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");				} else {					AST_LIST_INSERT_TAIL(varlist, newvar, entries);				}			}
var = i->iaxvars;
var = i->iaxvars
var
var
i->iaxvars
i
i
iaxvars
var
var
var = var->next
var
var
var->next
var
var
next
{				struct ast_var_t *newvar = ast_var_assign(var->name, var->value);				if (prev)					ast_free(prev);				prev = var;				if (!newvar) {					/* Don't abort list traversal, as this would leave i->iaxvars in an inconsistent state. */					ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");				} else {					AST_LIST_INSERT_TAIL(varlist, newvar, entries);				}			}
struct ast_var_t *newvar = ast_var_assign(var->name, var->value);
struct ast_var_t *newvar = ast_var_assign(var->name, var->value);
struct ast_var_t
ast_var_t
*newvar = ast_var_assign(var->name, var->value)
*
newvar
= ast_var_assign(var->name, var->value)
ast_var_assign(var->name, var->value)
ast_var_assign
ast_var_assign
var->name
var
var
name
var->value
var
var
value
if (prev)					ast_free(prev);
prev
prev
ast_free(prev);
ast_free(prev)
ast_free
ast_free
prev
prev
prev = var;
prev = var
prev
prev
var
var
if (!newvar) {					/* Don't abort list traversal, as this would leave i->iaxvars in an inconsistent state. */					ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");				} else {					AST_LIST_INSERT_TAIL(varlist, newvar, entries);				}
!newvar
newvar
newvar
{					/* Don't abort list traversal, as this would leave i->iaxvars in an inconsistent state. */					ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");				}
ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");
ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n")
ast_log
ast_log
LOG_ERROR
LOG_ERROR
"Memory allocation error while processing IAX2 variables\n"
{					AST_LIST_INSERT_TAIL(varlist, newvar, entries);				}
AST_LIST_INSERT_TAIL(varlist, newvar, entries);
AST_LIST_INSERT_TAIL(varlist, newvar, entries)
AST_LIST_INSERT_TAIL
AST_LIST_INSERT_TAIL
varlist
varlist
newvar
newvar
entries
entries
if (prev)				ast_free(prev);
prev
prev
ast_free(prev);
ast_free(prev)
ast_free
ast_free
prev
prev
i->iaxvars = NULL;
i->iaxvars = NULL
i->iaxvars
i
i
iaxvars
NULL
NULL
ast_channel_datastore_add(i->owner, variablestore);
ast_channel_datastore_add(i->owner, variablestore)
ast_channel_datastore_add
ast_channel_datastore_add
i->owner
i
i
owner
variablestore
variablestore
{			if (variablestore) {				ast_datastore_free(variablestore);			}			if (varlist) {				ast_free(varlist);			}		}
if (variablestore) {				ast_datastore_free(variablestore);			}
variablestore
variablestore
{				ast_datastore_free(variablestore);			}
ast_datastore_free(variablestore);
ast_datastore_free(variablestore)
ast_datastore_free
ast_datastore_free
variablestore
variablestore
if (varlist) {				ast_free(varlist);			}
varlist
varlist
{				ast_free(varlist);			}
ast_free(varlist);
ast_free(varlist);
ast_free
ast_free
(varlist)
varlist
varlist
if (state != AST_STATE_DOWN) {		if (ast_pbx_start(tmp)) {			ast_log(LOG_WARNING, "Unable to start PBX on %s\n", ast_channel_name(tmp));			ast_hangup(tmp);			i->owner = NULL;			return NULL;		}	}
state != AST_STATE_DOWN
state
state
AST_STATE_DOWN
AST_STATE_DOWN
{		if (ast_pbx_start(tmp)) {			ast_log(LOG_WARNING, "Unable to start PBX on %s\n", ast_channel_name(tmp));			ast_hangup(tmp);			i->owner = NULL;			return NULL;		}	}
if (ast_pbx_start(tmp)) {			ast_log(LOG_WARNING, "Unable to start PBX on %s\n", ast_channel_name(tmp));			ast_hangup(tmp);			i->owner = NULL;			return NULL;		}
ast_pbx_start(tmp)
ast_pbx_start
ast_pbx_start
tmp
tmp
{			ast_log(LOG_WARNING, "Unable to start PBX on %s\n", ast_channel_name(tmp));			ast_hangup(tmp);			i->owner = NULL;			return NULL;		}
ast_log(LOG_WARNING, "Unable to start PBX on %s\n", ast_channel_name(tmp));
ast_log(LOG_WARNING, "Unable to start PBX on %s\n", ast_channel_name(tmp))
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"Unable to start PBX on %s\n"
ast_channel_name(tmp)
ast_channel_name
ast_channel_name
tmp
tmp
ast_hangup(tmp);
ast_hangup(tmp)
ast_hangup
ast_hangup
tmp
tmp
i->owner = NULL;
i->owner = NULL
i->owner
i
i
owner
NULL
NULL
return NULL;
NULL
NULL
ast_module_ref(ast_module_info->self);
ast_module_ref(ast_module_info->self)
ast_module_ref
ast_module_ref
ast_module_info->self
ast_module_info
ast_module_info
self
return tmp;
tmp
tmp
-----joern-----
(504,318,0)
(399,31,0)
(487,238,0)
(412,514,0)
(510,177,0)
(282,466,0)
(153,301,0)
(384,362,0)
(350,278,0)
(302,499,0)
(3,205,0)
(196,246,0)
(499,31,0)
(109,295,0)
(433,502,0)
(49,36,0)
(244,460,0)
(112,116,0)
(440,430,0)
(170,428,0)
(275,350,0)
(458,194,0)
(41,46,0)
(119,321,0)
(469,440,0)
(538,211,0)
(416,524,0)
(487,461,0)
(17,87,0)
(66,114,0)
(8,423,0)
(395,437,0)
(149,164,0)
(455,410,0)
(487,36,0)
(496,437,0)
(405,173,0)
(55,220,0)
(481,313,0)
(123,254,0)
(189,271,0)
(144,207,0)
(378,189,0)
(385,136,0)
(145,227,0)
(468,534,0)
(387,188,0)
(381,158,0)
(156,423,0)
(194,184,0)
(421,152,0)
(35,86,0)
(119,278,0)
(514,423,0)
(334,295,0)
(106,127,0)
(520,526,0)
(2,437,0)
(364,141,0)
(484,158,0)
(414,164,0)
(322,344,0)
(108,349,0)
(439,33,0)
(536,437,0)
(163,275,0)
(245,420,0)
(266,12,0)
(422,464,0)
(473,205,0)
(406,32,0)
(226,487,0)
(122,488,0)
(500,487,0)
(109,232,0)
(159,31,0)
(258,358,0)
(407,8,0)
(312,415,0)
(300,464,0)
(193,381,0)
(391,134,0)
(314,399,0)
(135,295,0)
(207,364,0)
(102,149,0)
(19,464,0)
(259,14,0)
(242,437,0)
(326,505,0)
(210,279,0)
(401,295,0)
(198,464,0)
(132,175,0)
(88,510,0)
(338,466,0)
(59,417,0)
(351,533,0)
(487,501,0)
(201,527,0)
(231,493,0)
(129,370,0)
(486,42,0)
(301,437,0)
(291,173,0)
(318,31,0)
(502,439,0)
(354,483,0)
(519,109,0)
(23,370,0)
(93,487,0)
(520,134,0)
(187,224,0)
(381,134,0)
(255,24,0)
(75,400,0)
(487,93,0)
(107,247,0)
(0,72,0)
(95,363,0)
(380,175,0)
(335,1,0)
(127,292,0)
(390,535,0)
(1,335,0)
(37,476,0)
(441,159,0)
(527,31,0)
(198,437,0)
(316,387,0)
(487,437,0)
(272,309,0)
(363,395,0)
(459,109,0)
(342,20,0)
(164,149,0)
(31,156,0)
(222,437,0)
(381,191,0)
(306,132,0)
(152,209,0)
(246,26,0)
(402,31,0)
(162,294,0)
(288,377,0)
(330,537,0)
(157,437,0)
(290,315,0)
(252,464,0)
(487,499,0)
(120,322,0)
(474,295,0)
(146,437,0)
(164,31,0)
(478,152,0)
(232,68,0)
(264,112,0)
(521,156,0)
(26,246,0)
(203,301,0)
(138,196,0)
(63,183,0)
(341,159,0)
(53,481,0)
(25,98,0)
(122,464,0)
(32,133,0)
(173,464,0)
(246,196,0)
(503,86,0)
(396,222,0)
(313,46,0)
(508,507,0)
(438,100,0)
(331,319,0)
(494,128,0)
(488,122,0)
(381,475,0)
(132,102,0)
(468,130,0)
(261,313,0)
(381,58,0)
(317,31,0)
(321,15,0)
(62,58,0)
(113,461,0)
(172,535,0)
(465,446,0)
(236,325,0)
(185,381,0)
(279,31,0)
(137,239,0)
(234,191,0)
(319,177,0)
(200,317,0)
(381,322,0)
(340,534,0)
(70,518,0)
(40,420,0)
(381,183,0)
(533,98,0)
(487,296,0)
(483,437,0)
(338,437,0)
(56,176,0)
(454,282,0)
(12,437,0)
(87,31,0)
(183,109,0)
(68,232,0)
(247,31,0)
(402,443,0)
(350,275,0)
(269,86,0)
(126,198,0)
(490,408,0)
(410,437,0)
(291,98,0)
(293,498,0)
(528,423,0)
(381,294,0)
(363,31,0)
(456,257,0)
(457,205,0)
(381,434,0)
(398,275,0)
(523,464,0)
(2,202,0)
(339,487,0)
(134,295,0)
(450,295,0)
(253,189,0)
(277,203,0)
(537,31,0)
(214,464,0)
(211,448,0)
(499,487,0)
(430,464,0)
(194,437,0)
(305,166,0)
(395,363,0)
(336,206,0)
(312,464,0)
(142,11,0)
(424,399,0)
(370,374,0)
(463,492,0)
(503,31,0)
(92,255,0)
(516,18,0)
(434,101,0)
(130,468,0)
(392,181,0)
(121,157,0)
(451,447,0)
(31,369,0)
(155,112,0)
(152,31,0)
(427,176,0)
(112,468,0)
(460,279,0)
(206,507,0)
(372,133,0)
(233,127,0)
(498,375,0)
(434,518,0)
(262,203,0)
(18,312,0)
(492,219,0)
(52,465,0)
(505,347,0)
(33,511,0)
(285,271,0)
(251,530,0)
(475,496,0)
(369,31,0)
(289,184,0)
(368,437,0)
(353,271,0)
(227,437,0)
(333,538,0)
(114,100,0)
(298,363,0)
(71,437,0)
(382,318,0)
(60,164,0)
(299,518,0)
(128,31,0)
(166,322,0)
(20,319,0)
(215,93,0)
(518,434,0)
(446,465,0)
(287,511,0)
(267,448,0)
(92,492,0)
(205,423,0)
(191,422,0)
(197,407,0)
(67,487,0)
(230,183,0)
(175,380,0)
(453,92,0)
(140,315,0)
(321,119,0)
(358,141,0)
(184,31,0)
(389,238,0)
(94,464,0)
(366,493,0)
(197,464,0)
(4,21,0)
(437,487,0)
(395,464,0)
(524,31,0)
(324,0,0)
(327,31,0)
(70,146,0)
(176,335,0)
(184,194,0)
(403,362,0)
(14,136,0)
(532,366,0)
(323,198,0)
(377,437,0)
(381,18,0)
(128,487,0)
(89,304,0)
(466,464,0)
(524,446,0)
(101,150,0)
(359,291,0)
(66,437,0)
(58,131,0)
(410,380,0)
(493,295,0)
(221,295,0)
(98,533,0)
(265,227,0)
(498,31,0)
(470,447,0)
(517,392,0)
(512,437,0)
(352,87,0)
(303,296,0)
(11,263,0)
(311,464,0)
(22,524,0)
(392,464,0)
(419,145,0)
(370,31,0)
(36,31,0)
(274,441,0)
(381,20,0)
(73,15,0)
(418,70,0)
(502,437,0)
(381,378,0)
(411,510,0)
(178,509,0)
(211,464,0)
(255,374,0)
(381,119,0)
(199,214,0)
(276,279,0)
(82,520,0)
(136,437,0)
(133,222,0)
(444,439,0)
(260,214,0)
(381,511,0)
(461,487,0)
(278,350,0)
(114,66,0)
(538,437,0)
(192,435,0)
(447,470,0)
(515,93,0)
(61,162,0)
(257,413,0)
(335,176,0)
(157,148,0)
(420,31,0)
(8,407,0)
(71,464,0)
(111,33,0)
(386,321,0)
(420,488,0)
(219,309,0)
(225,526,0)
(34,464,0)
(347,31,0)
(169,402,0)
(130,127,0)
(90,400,0)
(48,353,0)
(166,145,0)
(186,380,0)
(247,344,0)
(475,430,0)
(529,179,0)
(461,31,0)
(528,426,0)
(218,395,0)
(127,313,0)
(81,36,0)
(481,534,0)
(209,343,0)
(358,207,0)
(431,496,0)
(21,482,0)
(47,46,0)
(487,128,0)
(301,203,0)
(124,476,0)
(344,247,0)
(103,426,0)
(54,318,0)
(356,61,0)
(98,291,0)
(219,492,0)
(217,271,0)
(104,464,0)
(232,109,0)
(158,137,0)
(202,464,0)
(440,31,0)
(208,137,0)
(537,42,0)
(404,443,0)
(159,441,0)
(241,101,0)
(231,481,0)
(105,362,0)
(44,358,0)
(29,3,0)
(349,3,0)
(15,530,0)
(428,24,0)
(446,524,0)
(506,475,0)
(167,464,0)
(425,464,0)
(346,528,0)
(467,437,0)
(441,437,0)
(133,32,0)
(86,503,0)
(533,536,0)
(508,482,0)
(381,132,0)
(487,315,0)
(517,437,0)
(193,257,0)
(254,271,0)
(280,242,0)
(400,422,0)
(64,464,0)
(491,400,0)
(242,61,0)
(46,313,0)
(248,402,0)
(131,467,0)
(317,487,0)
(448,211,0)
(30,184,0)
(45,191,0)
(178,358,0)
(174,68,0)
(409,499,0)
(381,92,0)
(531,512,0)
(168,464,0)
(394,517,0)
(193,103,0)
(18,31,0)
(496,475,0)
(21,423,0)
(286,519,0)
(181,392,0)
(238,487,0)
(178,437,0)
(482,21,0)
(375,74,0)
(381,177,0)
(220,130,0)
(336,224,0)
(315,31,0)
(522,514,0)
(525,534,0)
(72,0,0)
(320,31,0)
(275,31,0)
(536,533,0)
(284,382,0)
(318,382,0)
(220,313,0)
(465,437,0)
(344,464,0)
(466,338,0)
(467,131,0)
(15,321,0)
(161,338,0)
(33,439,0)
(100,114,0)
(343,209,0)
(102,239,0)
(497,126,0)
(240,440,0)
(417,202,0)
(222,133,0)
(460,244,0)
(366,481,0)
(20,31,0)
(69,347,0)
(495,294,0)
(315,487,0)
(14,507,0)
(307,422,0)
(209,152,0)
(162,61,0)
(510,368,0)
(173,405,0)
(273,8,0)
(147,470,0)
(328,156,0)
(149,102,0)
(252,377,0)
(368,510,0)
(357,141,0)
(13,450,0)
(483,177,0)
(236,109,0)
(374,255,0)
(134,520,0)
(211,538,0)
(309,437,0)
(171,468,0)
(481,292,0)
(196,31,0)
(51,452,0)
(93,31,0)
(279,460,0)
(256,157,0)
(530,15,0)
(309,219,0)
(216,368,0)
(84,378,0)
(511,428,0)
(405,31,0)
(482,508,0)
(509,207,0)
(191,31,0)
(143,464,0)
(348,435,0)
(412,143,0)
(487,317,0)
(78,224,0)
(488,420,0)
(154,514,0)
(435,437,0)
(477,181,0)
(268,220,0)
(526,520,0)
(243,534,0)
(442,252,0)
(156,31,0)
(472,0,0)
(118,509,0)
(362,403,0)
(193,71,0)
(130,220,0)
(220,292,0)
(292,452,0)
(146,70,0)
(476,31,0)
(227,145,0)
(36,487,0)
(79,537,0)
(270,103,0)
(16,219,0)
(304,91,0)
(439,502,0)
(160,8,0)
(381,291,0)
(376,509,0)
(193,387,0)
(505,464,0)
(443,402,0)
(360,66,0)
(452,31,0)
(367,2,0)
(43,247,0)
(514,412,0)
(97,493,0)
(310,236,0)
(365,450,0)
(9,196,0)
(397,71,0)
(530,437,0)
(355,364,0)
(127,130,0)
(527,464,0)
(518,70,0)
(252,415,0)
(75,109,0)
(447,31,0)
(358,178,0)
(430,440,0)
(136,14,0)
(3,349,0)
(511,33,0)
(39,225,0)
(176,31,0)
(337,464,0)
(281,18,0)
(345,85,0)
(235,303,0)
(380,410,0)
(422,437,0)
(379,493,0)
(165,238,0)
(27,437,0)
(223,528,0)
(7,464,0)
(400,75,0)
(485,232,0)
(224,336,0)
(479,464,0)
(278,150,0)
(175,132,0)
(151,303,0)
(383,292,0)
(115,464,0)
(58,122,0)
(42,271,0)
(400,31,0)
(131,58,0)
(72,464,0)
(10,128,0)
(28,378,0)
(465,464,0)
(57,347,0)
(283,179,0)
(212,464,0)
(5,481,0)
(249,312,0)
(145,166,0)
(371,178,0)
(32,158,0)
(364,207,0)
(449,20,0)
(202,417,0)
(509,178,0)
(202,2,0)
(179,31,0)
(229,364,0)
(110,188,0)
(361,461,0)
(195,462,0)
(38,159,0)
(407,197,0)
(86,423,0)
(470,147,0)
(320,141,0)
(213,498,0)
(183,353,0)
(65,434,0)
(429,162,0)
(436,175,0)
(322,166,0)
(224,423,0)
(157,349,0)
(141,320,0)
(509,141,0)
(76,464,0)
(125,447,0)
(61,242,0)
(432,21,0)
(0,31,0)
(206,336,0)
(492,92,0)
(143,412,0)
(182,464,0)
(96,405,0)
(471,528,0)
(46,292,0)
(297,503,0)
(378,109,0)
(237,334,0)
(452,292,0)
(74,375,0)
(238,31,0)
(294,72,0)
(6,405,0)
(393,536,0)
(526,225,0)
(204,519,0)
(50,317,0)
(294,162,0)
(77,231,0)
(85,468,0)
(480,464,0)
(513,320,0)
(466,282,0)
(403,464,0)
(374,370,0)
(114,464,0)
(489,467,0)
(388,11,0)
(205,3,0)
(381,537,0)
(443,437,0)
(445,112,0)
(117,131,0)
(375,498,0)
(83,320,0)
(332,146,0)
(347,505,0)
(505,437,0)
(392,517,0)
(250,75,0)
(203,31,0)
(198,126,0)
(158,32,0)
(373,119,0)
(437,464,0)
(382,437,0)
(75,271,0)
(377,252,0)
(180,452,0)
(232,68,1)
(344,247,1)
(378,28,1)
(469,240,1)
(5,366,1)
(381,158,1)
(0,472,1)
(81,49,1)
(489,147,1)
(207,364,1)
(107,43,1)
(400,31,1)
(536,437,1)
(422,307,1)
(54,504,1)
(160,273,1)
(302,409,1)
(398,119,1)
(280,344,1)
(502,433,1)
(166,305,1)
(2,437,1)
(447,451,1)
(99,519,1)
(47,41,1)
(158,484,1)
(381,134,1)
(366,493,1)
(119,321,1)
(105,303,1)
(499,302,1)
(417,59,1)
(367,252,1)
(443,402,1)
(45,382,1)
(508,482,1)
(180,51,1)
(89,308,1)
(171,190,1)
(55,127,1)
(161,202,1)
(386,15,1)
(420,31,1)
(312,415,1)
(39,82,1)
(3,29,1)
(215,238,1)
(227,437,1)
(141,320,1)
(509,118,1)
(312,249,1)
(118,376,1)
(335,176,1)
(435,348,1)
(100,438,1)
(522,437,1)
(393,343,1)
(487,461,1)
(526,225,1)
(531,303,1)
(381,191,1)
(434,65,1)
(41,261,1)
(191,234,1)
(132,306,1)
(520,526,1)
(359,98,1)
(478,421,1)
(121,256,1)
(440,31,1)
(409,461,1)
(447,31,1)
(128,10,1)
(44,371,1)
(433,244,1)
(176,31,1)
(403,362,1)
(254,123,1)
(487,36,1)
(61,242,1)
(445,85,1)
(381,132,1)
(451,125,1)
(181,477,1)
(303,151,1)
(389,67,1)
(362,384,1)
(202,2,1)
(475,496,1)
(228,141,1)
(247,107,1)
(487,128,1)
(38,274,1)
(353,48,1)
(203,31,1)
(93,515,1)
(247,31,1)
(193,381,1)
(294,495,1)
(130,127,1)
(87,352,1)
(137,208,1)
(146,332,1)
(505,347,1)
(400,422,1)
(452,180,1)
(66,437,1)
(20,31,1)
(29,205,1)
(288,198,1)
(8,423,1)
(369,31,1)
(37,505,1)
(220,268,1)
(252,442,1)
(316,80,1)
(219,16,1)
(240,475,1)
(303,296,1)
(320,513,1)
(117,467,1)
(289,30,1)
(381,92,1)
(178,509,1)
(381,322,1)
(461,361,1)
(334,237,1)
(301,203,1)
(439,444,1)
(492,463,1)
(32,133,1)
(381,185,1)
(459,134,1)
(77,329,1)
(533,536,1)
(377,288,1)
(169,248,1)
(381,475,1)
(352,17,1)
(14,136,1)
(170,511,1)
(211,538,1)
(111,439,1)
(519,109,1)
(154,522,1)
(347,31,1)
(411,512,1)
(513,83,1)
(53,5,1)
(69,326,1)
(489,102,1)
(537,31,1)
(267,538,1)
(435,437,1)
(283,529,1)
(427,56,1)
(33,439,1)
(339,128,1)
(231,493,1)
(374,370,1)
(452,31,1)
(453,492,1)
(487,238,1)
(62,131,1)
(466,282,1)
(358,258,1)
(381,119,1)
(308,236,1)
(128,31,1)
(284,476,1)
(493,379,1)
(122,488,1)
(275,163,1)
(336,224,1)
(489,255,1)
(210,276,1)
(201,503,1)
(272,428,1)
(372,222,1)
(477,517,1)
(194,437,1)
(245,40,1)
(294,162,1)
(432,14,1)
(82,391,1)
(9,138,1)
(46,313,1)
(218,443,1)
(527,201,1)
(97,179,1)
(190,292,1)
(127,233,1)
(276,1,1)
(35,297,1)
(512,437,1)
(442,377,1)
(193,387,1)
(382,437,1)
(66,360,1)
(15,73,1)
(449,483,1)
(157,349,1)
(114,100,1)
(524,416,1)
(517,437,1)
(509,207,1)
(216,88,1)
(85,345,1)
(282,454,1)
(187,80,1)
(93,31,1)
(136,437,1)
(315,140,1)
(293,213,1)
(394,114,1)
(226,500,1)
(222,396,1)
(297,143,1)
(143,412,1)
(12,437,1)
(533,351,1)
(524,31,1)
(46,47,1)
(486,537,1)
(70,418,1)
(421,122,1)
(365,334,1)
(358,141,1)
(465,446,1)
(437,487,1)
(95,218,1)
(355,144,1)
(514,154,1)
(236,109,1)
(200,226,1)
(473,108,1)
(67,36,1)
(238,165,1)
(332,343,1)
(185,319,1)
(11,388,1)
(443,437,1)
(481,313,1)
(241,434,1)
(120,166,1)
(416,22,1)
(328,327,1)
(514,423,1)
(347,57,1)
(220,292,1)
(528,471,1)
(175,436,1)
(191,31,1)
(349,3,1)
(373,321,1)
(371,228,1)
(86,269,1)
(414,132,1)
(496,437,1)
(494,499,1)
(4,432,1)
(229,355,1)
(190,313,1)
(420,245,1)
(75,109,1)
(450,13,1)
(31,156,1)
(51,383,1)
(133,222,1)
(214,199,1)
(105,512,1)
(112,155,1)
(316,508,1)
(193,71,1)
(281,516,1)
(109,232,1)
(391,450,1)
(70,146,1)
(42,486,1)
(270,528,1)
(381,511,1)
(364,207,1)
(321,386,1)
(152,478,1)
(481,53,1)
(511,287,1)
(487,317,1)
(438,66,1)
(196,9,1)
(399,31,1)
(176,427,1)
(101,241,1)
(274,74,1)
(492,219,1)
(253,378,1)
(363,31,1)
(440,469,1)
(381,183,1)
(227,265,1)
(158,32,1)
(381,378,1)
(133,372,1)
(487,93,1)
(393,278,1)
(21,423,1)
(159,31,1)
(388,142,1)
(308,99,1)
(151,235,1)
(318,31,1)
(381,58,1)
(324,294,1)
(140,290,1)
(197,407,1)
(385,259,1)
(192,476,1)
(536,393,1)
(268,55,1)
(279,210,1)
(18,31,1)
(497,323,1)
(397,403,1)
(381,537,1)
(5,139,1)
(178,358,1)
(16,309,1)
(292,452,1)
(244,460,1)
(317,31,1)
(392,517,1)
(291,359,1)
(189,253,1)
(412,514,1)
(83,357,1)
(127,292,1)
(211,448,1)
(79,329,1)
(330,79,1)
(318,54,1)
(8,160,1)
(331,20,1)
(439,502,1)
(446,524,1)
(422,437,1)
(491,42,1)
(380,410,1)
(379,97,1)
(50,200,1)
(538,437,1)
(392,181,1)
(155,264,1)
(184,31,1)
(72,0,1)
(399,314,1)
(73,530,1)
(33,111,1)
(98,533,1)
(246,196,1)
(444,502,1)
(429,61,1)
(22,52,1)
(258,44,1)
(75,250,1)
(58,62,1)
(275,31,1)
(269,35,1)
(52,211,1)
(199,260,1)
(309,437,1)
(455,137,1)
(259,206,1)
(179,283,1)
(235,179,1)
(329,190,1)
(424,26,1)
(68,174,1)
(382,318,1)
(131,117,1)
(146,437,1)
(36,81,1)
(6,291,1)
(516,422,1)
(342,449,1)
(138,74,1)
(173,405,1)
(528,423,1)
(419,227,1)
(368,437,1)
(15,530,1)
(472,324,1)
(475,506,1)
(252,415,1)
(18,281,1)
(262,153,1)
(235,308,1)
(299,70,1)
(504,284,1)
(320,31,1)
(319,331,1)
(165,389,1)
(92,492,1)
(71,437,1)
(88,411,1)
(485,68,1)
(487,315,1)
(467,437,1)
(208,158,1)
(86,423,1)
(203,277,1)
(381,294,1)
(248,404,1)
(266,527,1)
(304,89,1)
(381,18,1)
(205,457,1)
(350,275,1)
(345,481,1)
(309,272,1)
(317,50,1)
(112,468,1)
(465,437,1)
(183,109,1)
(218,399,1)
(238,31,1)
(21,4,1)
(256,349,1)
(0,31,1)
(85,468,1)
(233,106,1)
(482,21,1)
(204,286,1)
(32,406,1)
(250,400,1)
(387,316,1)
(512,531,1)
(383,254,1)
(315,31,1)
(341,38,1)
(463,219,1)
(529,228,1)
(74,375,1)
(71,397,1)
(498,31,1)
(467,489,1)
(376,358,1)
(193,257,1)
(313,46,1)
(277,262,1)
(410,437,1)
(153,1,1)
(378,109,1)
(106,171,1)
(136,385,1)
(500,27,1)
(178,437,1)
(237,493,1)
(338,437,1)
(219,309,1)
(84,353,1)
(503,31,1)
(360,466,1)
(232,485,1)
(235,75,1)
(231,481,1)
(483,354,1)
(396,147,1)
(366,481,1)
(123,189,1)
(59,2,1)
(196,31,1)
(43,322,1)
(61,356,1)
(119,373,1)
(261,11,1)
(461,31,1)
(49,339,1)
(80,503,1)
(13,365,1)
(503,86,1)
(368,216,1)
(231,77,1)
(441,159,1)
(381,20,1)
(460,279,1)
(205,423,1)
(346,369,1)
(149,164,1)
(488,420,1)
(322,166,1)
(257,456,1)
(12,266,1)
(384,105,1)
(58,131,1)
(220,313,1)
(326,395,1)
(162,61,1)
(400,90,1)
(502,437,1)
(251,101,1)
(157,437,1)
(96,6,1)
(23,92,1)
(487,501,1)
(484,32,1)
(518,70,1)
(186,410,1)
(448,267,1)
(290,317,1)
(194,184,1)
(249,18,1)
(466,338,1)
(98,25,1)
(103,270,1)
(430,440,1)
(157,121,1)
(377,437,1)
(20,342,1)
(468,130,1)
(287,33,1)
(57,69,1)
(361,113,1)
(132,175,1)
(483,437,1)
(278,350,1)
(87,31,1)
(380,186,1)
(405,96,1)
(255,374,1)
(242,280,1)
(134,520,1)
(314,424,1)
(538,333,1)
(90,491,1)
(527,31,1)
(108,12,1)
(298,95,1)
(79,231,1)
(56,465,1)
(60,414,1)
(130,220,1)
(264,445,1)
(102,149,1)
(279,31,1)
(338,161,1)
(261,112,1)
(179,31,1)
(183,230,1)
(357,87,1)
(45,435,1)
(78,187,1)
(164,60,1)
(323,157,1)
(406,133,1)
(156,521,1)
(510,368,1)
(48,183,1)
(198,437,1)
(193,103,1)
(209,152,1)
(124,37,1)
(206,336,1)
(456,12,1)
(431,72,1)
(113,315,1)
(410,455,1)
(46,292,1)
(471,223,1)
(142,85,1)
(162,429,1)
(515,215,1)
(370,31,1)
(242,437,1)
(166,145,1)
(152,31,1)
(286,109,1)
(63,519,1)
(358,207,1)
(498,293,1)
(224,423,1)
(529,87,1)
(366,532,1)
(363,298,1)
(175,380,1)
(532,139,1)
(236,310,1)
(364,141,1)
(291,98,1)
(428,170,1)
(223,346,1)
(481,292,1)
(476,124,1)
(25,533,1)
(370,129,1)
(418,146,1)
(343,209,1)
(144,178,1)
(407,8,1)
(356,242,1)
(333,392,1)
(30,458,1)
(301,437,1)
(495,162,1)
(306,175,1)
(265,173,1)
(499,31,1)
(424,194,1)
(436,380,1)
(2,367,1)
(145,227,1)
(17,312,1)
(487,499,1)
(230,63,1)
(202,417,1)
(234,45,1)
(381,291,1)
(496,431,1)
(114,66,1)
(348,192,1)
(487,296,1)
(10,494,1)
(364,229,1)
(27,197,1)
(198,126,1)
(235,304,1)
(476,31,1)
(92,453,1)
(75,400,1)
(156,423,1)
(222,437,1)
(327,214,1)
(537,330,1)
(457,473,1)
(273,369,1)
(307,191,1)
(395,363,1)
(252,377,1)
(402,31,1)
(213,430,1)
(351,536,1)
(129,23,1)
(36,31,1)
(305,145,1)
(511,33,1)
(3,205,1)
(404,399,1)
(131,467,1)
(434,518,1)
(159,341,1)
(126,497,1)
(519,204,1)
(147,470,1)
(174,459,1)
(321,15,1)
(224,78,1)
(454,338,1)
(441,437,1)
(375,498,1)
(354,510,1)
(506,496,1)
(322,120,1)
(28,84,1)
(505,437,1)
(405,31,1)
(65,518,1)
(402,169,1)
(509,141,1)
(519,286,1)
(184,289,1)
(164,31,1)
(138,441,1)
(530,251,1)
(517,394,1)
(521,328,1)
(125,244,1)
(381,434,1)
(458,26,1)
(518,299,1)
(40,58,1)
(323,349,1)
(139,468,1)
(163,398,1)
(395,437,1)
(530,437,1)
(276,301,1)
(225,39,1)
(228,207,1)
(310,99,1)
(1,335,1)
(127,313,1)
(26,246,1)
(145,419,1)
(470,447,1)
(381,537,2)
(291,98,2)
(455,147,2)
(287,244,2)
(329,519,2)
(482,21,2)
(381,92,2)
(346,369,2)
(89,308,2)
(50,369,2)
(244,460,2)
(255,374,2)
(286,179,2)
(491,519,2)
(85,468,2)
(57,12,2)
(536,12,2)
(233,190,2)
(377,12,2)
(461,369,2)
(130,190,2)
(443,402,2)
(246,196,2)
(502,244,2)
(42,519,2)
(306,147,2)
(119,321,2)
(178,437,2)
(465,437,2)
(476,31,2)
(393,12,2)
(149,164,2)
(368,512,2)
(344,247,2)
(147,244,2)
(281,12,2)
(386,343,2)
(519,109,2)
(176,31,2)
(447,244,2)
(298,12,2)
(538,12,2)
(75,400,2)
(358,141,2)
(488,420,2)
(146,343,2)
(251,343,2)
(527,503,2)
(467,437,2)
(198,437,2)
(268,190,2)
(517,437,2)
(226,369,2)
(430,440,2)
(517,12,2)
(368,437,2)
(173,12,2)
(518,70,2)
(209,12,2)
(54,476,2)
(11,85,2)
(515,369,2)
(384,512,2)
(443,399,2)
(323,12,2)
(197,369,2)
(452,519,2)
(127,313,2)
(26,246,2)
(499,31,2)
(68,179,2)
(456,12,2)
(98,12,2)
(112,85,2)
(363,31,2)
(207,364,2)
(417,12,2)
(38,74,2)
(136,80,2)
(439,244,2)
(230,519,2)
(381,291,2)
(107,12,2)
(74,375,2)
(400,422,2)
(316,503,2)
(358,228,2)
(449,512,2)
(503,31,2)
(466,12,2)
(495,12,2)
(440,12,2)
(424,12,2)
(231,481,2)
(143,369,2)
(213,12,2)
(32,147,2)
(238,369,2)
(537,519,2)
(17,12,2)
(264,85,2)
(419,12,2)
(371,228,2)
(487,296,2)
(496,437,2)
(319,512,2)
(102,149,2)
(93,369,2)
(160,369,2)
(151,12,2)
(192,476,2)
(159,74,2)
(265,12,2)
(128,369,2)
(341,74,2)
(125,244,2)
(86,423,2)
(6,12,2)
(170,244,2)
(87,31,2)
(75,109,2)
(3,205,2)
(396,147,2)
(324,12,2)
(197,407,2)
(366,493,2)
(5,190,2)
(430,12,2)
(71,303,2)
(20,31,2)
(183,519,2)
(383,519,2)
(322,166,2)
(67,369,2)
(193,257,2)
(392,12,2)
(399,12,2)
(374,244,2)
(100,12,2)
(201,503,2)
(55,190,2)
(204,286,2)
(410,437,2)
(475,496,2)
(381,434,2)
(444,244,2)
(369,31,2)
(194,437,2)
(274,74,2)
(492,244,2)
(227,437,2)
(514,369,2)
(252,377,2)
(416,12,2)
(359,12,2)
(270,369,2)
(470,244,2)
(28,519,2)
(338,437,2)
(370,31,2)
(373,343,2)
(332,343,2)
(51,519,2)
(73,343,2)
(536,437,2)
(503,86,2)
(223,369,2)
(367,12,2)
(106,190,2)
(283,12,2)
(256,349,2)
(374,370,2)
(257,12,2)
(85,190,2)
(169,399,2)
(114,12,2)
(90,519,2)
(510,512,2)
(152,31,2)
(468,190,2)
(79,519,2)
(370,244,2)
(463,244,2)
(434,343,2)
(381,58,2)
(191,12,2)
(211,448,2)
(364,141,2)
(382,318,2)
(315,31,2)
(312,12,2)
(1,335,2)
(138,12,2)
(87,12,2)
(312,415,2)
(122,488,2)
(342,512,2)
(476,12,2)
(436,147,2)
(509,228,2)
(242,437,2)
(422,12,2)
(155,85,2)
(461,31,2)
(77,329,2)
(493,179,2)
(457,12,2)
(519,179,2)
(381,191,2)
(303,296,2)
(141,87,2)
(266,503,2)
(194,184,2)
(453,244,2)
(384,303,2)
(437,369,2)
(103,369,2)
(294,162,2)
(528,369,2)
(279,31,2)
(33,244,2)
(242,12,2)
(20,512,2)
(468,130,2)
(446,12,2)
(132,147,2)
(97,179,2)
(353,519,2)
(181,12,2)
(381,119,2)
(235,12,2)
(46,313,2)
(448,12,2)
(146,437,2)
(37,12,2)
(382,476,2)
(497,12,2)
(175,147,2)
(13,179,2)
(406,147,2)
(400,31,2)
(412,514,2)
(40,12,2)
(484,147,2)
(99,519,2)
(397,303,2)
(121,349,2)
(315,369,2)
(184,31,2)
(301,203,2)
(118,228,2)
(152,12,2)
(318,31,2)
(220,313,2)
(472,12,2)
(272,244,2)
(62,12,2)
(122,12,2)
(15,530,2)
(113,369,2)
(162,61,2)
(246,12,2)
(236,99,2)
(350,343,2)
(1,12,2)
(432,80,2)
(420,12,2)
(381,322,2)
(133,147,2)
(481,292,2)
(14,80,2)
(520,179,2)
(84,519,2)
(506,12,2)
(532,139,2)
(191,31,2)
(8,369,2)
(400,519,2)
(326,12,2)
(127,190,2)
(357,87,2)
(158,32,2)
(508,482,2)
(52,12,2)
(381,378,2)
(244,12,2)
(26,12,2)
(102,147,2)
(317,31,2)
(528,423,2)
(41,190,2)
(180,519,2)
(289,26,2)
(302,369,2)
(466,338,2)
(145,227,2)
(520,526,2)
(486,519,2)
(92,244,2)
(75,519,2)
(530,437,2)
(194,26,2)
(137,147,2)
(452,31,2)
(149,147,2)
(349,3,2)
(355,228,2)
(330,519,2)
(112,468,2)
(78,80,2)
(161,12,2)
(252,12,2)
(378,519,2)
(15,343,2)
(232,68,2)
(459,179,2)
(487,499,2)
(318,476,2)
(231,493,2)
(301,437,2)
(487,461,2)
(71,437,2)
(143,412,2)
(228,228,2)
(193,103,2)
(511,33,2)
(117,12,2)
(224,423,2)
(70,146,2)
(403,362,2)
(156,423,2)
(185,512,2)
(59,12,2)
(487,128,2)
(237,179,2)
(381,20,2)
(385,80,2)
(279,12,2)
(399,31,2)
(527,31,2)
(434,518,2)
(405,12,2)
(219,244,2)
(409,369,2)
(362,512,2)
(164,147,2)
(291,12,2)
(245,12,2)
(354,512,2)
(313,46,2)
(109,232,2)
(362,303,2)
(124,12,2)
(377,437,2)
(402,31,2)
(66,12,2)
(375,12,2)
(297,369,2)
(36,369,2)
(398,343,2)
(498,31,2)
(29,12,2)
(310,99,2)
(193,387,2)
(508,80,2)
(381,511,2)
(60,147,2)
(211,538,2)
(358,207,2)
(35,369,2)
(98,533,2)
(487,315,2)
(475,12,2)
(505,12,2)
(175,380,2)
(375,498,2)
(166,145,2)
(275,343,2)
(489,12,2)
(120,12,2)
(190,190,2)
(322,12,2)
(129,244,2)
(351,12,2)
(184,26,2)
(207,228,2)
(196,12,2)
(529,12,2)
(198,126,2)
(402,399,2)
(483,512,2)
(460,279,2)
(88,512,2)
(471,369,2)
(56,12,2)
(481,313,2)
(46,292,2)
(467,12,2)
(428,244,2)
(388,85,2)
(162,12,2)
(14,136,2)
(483,437,2)
(33,439,2)
(154,369,2)
(365,179,2)
(165,369,2)
(228,87,2)
(294,12,2)
(275,31,2)
(381,475,2)
(533,536,2)
(276,12,2)
(477,12,2)
(378,109,2)
(222,437,2)
(142,85,2)
(314,12,2)
(524,31,2)
(86,369,2)
(531,303,2)
(147,470,2)
(238,31,2)
(211,12,2)
(9,12,2)
(439,502,2)
(505,437,2)
(280,12,2)
(465,446,2)
(206,80,2)
(331,512,2)
(58,131,2)
(205,12,2)
(44,228,2)
(159,31,2)
(262,1,2)
(21,80,2)
(128,31,2)
(65,343,2)
(206,336,2)
(487,501,2)
(478,12,2)
(336,80,2)
(231,329,2)
(301,1,2)
(157,437,2)
(225,179,2)
(18,12,2)
(395,437,2)
(193,381,2)
(465,12,2)
(442,12,2)
(345,190,2)
(10,369,2)
(382,437,2)
(343,12,2)
(134,520,2)
(420,31,2)
(435,476,2)
(119,343,2)
(511,244,2)
(336,224,2)
(335,12,2)
(433,244,2)
(441,159,2)
(208,147,2)
(66,437,2)
(421,12,2)
(105,512,2)
(304,308,2)
(496,12,2)
(509,141,2)
(381,158,2)
(187,80,2)
(178,509,2)
(145,12,2)
(487,369,2)
(39,179,2)
(247,31,2)
(157,349,2)
(2,437,2)
(347,12,2)
(249,12,2)
(179,31,2)
(492,219,2)
(220,190,2)
(196,31,2)
(108,12,2)
(349,12,2)
(441,437,2)
(139,190,2)
(130,127,2)
(200,369,2)
(487,36,2)
(321,343,2)
(83,87,2)
(526,179,2)
(109,179,2)
(132,175,2)
(61,12,2)
(364,228,2)
(80,503,2)
(364,207,2)
(356,12,2)
(198,12,2)
(441,74,2)
(431,12,2)
(469,12,2)
(405,31,2)
(25,12,2)
(284,476,2)
(512,437,2)
(105,303,2)
(144,228,2)
(418,343,2)
(123,519,2)
(530,343,2)
(487,317,2)
(27,369,2)
(222,147,2)
(258,228,2)
(533,12,2)
(236,109,2)
(395,12,2)
(387,503,2)
(290,369,2)
(352,12,2)
(58,12,2)
(473,12,2)
(250,519,2)
(101,343,2)
(487,238,2)
(512,303,2)
(49,369,2)
(363,12,2)
(516,12,2)
(381,18,2)
(21,423,2)
(482,80,2)
(247,12,2)
(343,209,2)
(70,343,2)
(202,12,2)
(219,309,2)
(278,343,2)
(45,12,2)
(460,12,2)
(412,369,2)
(0,12,2)
(202,2,2)
(209,152,2)
(203,1,2)
(2,12,2)
(12,437,2)
(23,244,2)
(435,437,2)
(348,476,2)
(241,343,2)
(8,423,2)
(397,512,2)
(339,369,2)
(267,12,2)
(307,12,2)
(224,80,2)
(72,12,2)
(350,275,2)
(255,244,2)
(366,481,2)
(538,437,2)
(74,12,2)
(437,487,2)
(404,399,2)
(440,31,2)
(71,512,2)
(12,503,2)
(158,147,2)
(278,350,2)
(227,12,2)
(522,369,2)
(16,244,2)
(133,222,2)
(36,31,2)
(193,71,2)
(205,423,2)
(505,347,2)
(499,369,2)
(3,12,2)
(391,179,2)
(48,519,2)
(320,31,2)
(381,132,2)
(360,12,2)
(487,93,2)
(203,31,2)
(392,517,2)
(380,410,2)
(111,244,2)
(163,343,2)
(173,405,2)
(252,415,2)
(445,85,2)
(347,31,2)
(500,369,2)
(215,369,2)
(269,369,2)
(379,179,2)
(389,369,2)
(494,369,2)
(202,417,2)
(220,292,2)
(313,190,2)
(232,179,2)
(164,31,2)
(470,447,2)
(153,1,2)
(4,80,2)
(372,147,2)
(261,190,2)
(526,225,2)
(96,12,2)
(454,12,2)
(114,66,2)
(395,363,2)
(130,220,2)
(381,134,2)
(422,437,2)
(403,303,2)
(485,179,2)
(273,369,2)
(0,31,2)
(61,242,2)
(292,452,2)
(183,109,2)
(380,147,2)
(95,12,2)
(503,369,2)
(447,31,2)
(277,1,2)
(411,512,2)
(537,31,2)
(32,133,2)
(407,8,2)
(394,12,2)
(376,228,2)
(134,179,2)
(82,179,2)
(234,12,2)
(451,244,2)
(18,31,2)
(458,26,2)
(218,12,2)
(488,12,2)
(427,12,2)
(174,179,2)
(509,207,2)
(381,512,2)
(186,147,2)
(46,190,2)
(305,12,2)
(293,12,2)
(229,228,2)
(504,476,2)
(43,12,2)
(309,437,2)
(190,519,2)
(53,190,2)
(338,12,2)
(178,228,2)
(524,12,2)
(498,12,2)
(288,12,2)
(299,343,2)
(178,358,2)
(240,12,2)
(126,12,2)
(446,524,2)
(333,12,2)
(179,12,2)
(514,423,2)
(450,179,2)
(317,369,2)
(303,12,2)
(410,147,2)
(72,0,2)
(335,176,2)
(392,181,2)
(309,244,2)
(320,87,2)
(166,12,2)
(381,183,2)
(502,437,2)
(438,12,2)
(69,12,2)
(131,467,2)
(466,282,2)
(114,100,2)
(344,12,2)
(481,190,2)
(308,519,2)
(443,437,2)
(407,369,2)
(510,368,2)
(92,492,2)
(321,15,2)
(259,80,2)
(414,147,2)
(216,512,2)
(63,519,2)
(254,519,2)
(176,12,2)
(22,12,2)
(171,190,2)
(282,12,2)
(248,399,2)
(403,512,2)
(31,156,2)
(30,26,2)
(131,12,2)
(334,179,2)
(140,369,2)
(47,190,2)
(81,369,2)
(513,87,2)
(93,31,2)
(361,369,2)
(210,12,2)
(381,294,2)
(127,292,2)
(366,139,2)
(292,519,2)
(189,519,2)
(136,437,2)
(253,519,2)
(141,320,2)
(429,12,2)
(518,343,2)
-----------------------------------
(0,i->calling_ton)
(1,!ast_strlen_zero(i->parkinglot)
(2,ast_channel_nativeformats(tmp)
(3,iaxs[callno]->callid)
(4,callno)
(5,prev)
(6,i)
(7,if (!ast_strlen_zero(i->accountcode)
(8,iaxsl[callno])
(9,accountcode)
(10,context)
(11,ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\\n")
(12,!tmp)
(13,"Loading up the channel with IAXVARs\\n")
(14,tmp = ast_channel_release(tmp)
(15,ast_channel_redirecting(tmp)
(16,ani)
(17,i)
(18,i->capability)
(19,if (i->iaxvars)
(20,i->owner)
(21,iaxsl[callno])
(22,i)
(23,i)
(24,)
(25,name)
(26,!ast_strlen_zero(i->accountcode)
(27,tmp)
(28,inheritance)
(29,callid)
(30,i)
(31,i = iaxs[callno])
(32,ast_channel_caller(tmp)
(33,ast_channel_caller(tmp)
(34,if (i->amaflags)
(35,iaxs)
(36,i->amaflags)
(37,i)
(38,i)
(39,varlist)
(40,i)
(41,var)
(42,i->iaxvars = NULL)
(43,i)
(44,v)
(45,i)
(46,var->next)
(47,next)
(48,varlist)
(49,i)
(50,cid_num)
(51,i)
(52,tmp)
(53,var)
(54,peeradsicpe)
(55,var)
(56,i)
(57,exten)
(58,ast_channel_dialed(tmp)
(59,tmpfmt)
(60,cid_num)
(61,ast_channel_caller(tmp)
(62,str)
(63,variablestore)
(64,if (!tmp)
(65,valid)
(66,ast_channel_rawreadformat(tmp)
(67,"IAX2/%s-%d")
(68,&iax2_variable_datastore_info)
(69,i)
(70,ast_channel_redirecting(tmp)
(71,return tmp;)
(72,ast_channel_caller(tmp)
(73,from)
(74,!ast_strlen_zero(i->language)
(75,ast_channel_datastore_add(i->owner, variablestore)
(76,if (!ast_strlen_zero(i->rdnis)
(77,prev)
(78,callno)
(79,i)
(80,tmp)
(81,amaflags)
(82,1)
(83,i)
(84,variablestore)
(85,!newvar)
(86,iaxs[callno])
(87,i->vars)
(88,"Unable to start PBX on %s\\n")
(89,varlist)
(90,owner)
(91,)
(92,ast_channel_caller(tmp)
(93,i->callno)
(94,if (!ast_strlen_zero(i->parkinglot)
(95,i)
(96,calling_pres)
(97,prev)
(98,ast_channel_caller(tmp)
(99,variablestore)
(100,&tmpfmt)
(101,ast_channel_redirecting(tmp)
(102,ast_channel_caller(tmp)
(103,return NULL;)
(104,if ((callid = iaxs[callno]->callid)
(105,ast_module_info)
(106,var)
(107,calling_pres)
(108,callid)
(109,variablestore = ast_datastore_alloc(&iax2_variable_datastore_info, NULL)
(110,if (tmp)
(111,number)
(112,AST_LIST_INSERT_TAIL(varlist, newvar, entries)
(113,i)
(114,ast_format_copy(ast_channel_rawreadformat(tmp)
(115,callid)
(116,)
(117,number)
(118,value)
(119,ast_channel_redirecting(tmp)
(120,presentation)
(121,callid)
(122,ast_channel_dialed(tmp)
(123,varlist)
(124,adsi)
(125,i)
(126,&iax2_tech)
(127,var->name)
(128,i->context)
(129,ani)
(130,ast_var_assign(var->name, var->value)
(131,ast_channel_dialed(tmp)
(132,ast_channel_caller(tmp)
(133,ast_channel_caller(tmp)
(134,varlist = ast_calloc(1, sizeof(*varlist)
(135,variablestore)
(136,ast_channel_release(tmp)
(137,ast_channel_caller(tmp)
(138,i)
(139,prev)
(140,cid_name)
(141,v = i->vars)
(142,LOG_ERROR)
(143,ast_mutex_lock(&iaxsl[callno])
(144,v)
(145,ast_channel_caller(tmp)
(146,ast_channel_redirecting(tmp)
(147,!ast_strlen_zero(i->cid_num)
(148,)
(149,ast_strdup(i->cid_num)
(150,)
(151,AST_STATE_DOWN)
(152,i->rdnis)
(153,tmp)
(154,callno)
(155,entries)
(156,iaxs[callno])
(157,ast_channel_callid_set(tmp, callid)
(158,ast_channel_caller(tmp)
(159,i->language)
(160,callno)
(161,tmp)
(162,ast_channel_caller(tmp)
(163,rdnis)
(164,i->cid_num)
(165,host)
(166,ast_channel_caller(tmp)
(167,if (state != AST_STATE_DOWN)
(168,if (!ast_strlen_zero(i->language)
(169,amaflags)
(170,1)
(171,newvar)
(172,if (varlist)
(173,ast_channel_caller(tmp)
(174,iax2_variable_datastore_info)
(175,ast_channel_caller(tmp)
(176,i->parkinglot)
(177,)
(178,pbx_builtin_setvar_helper(tmp, v->name, v->value)
(179,i->iaxvars)
(180,iaxvars)
(181,&tmpfmt)
(182,if (!(i = iaxs[callno])
(183,variablestore->data)
(184,i->accountcode)
(185,NULL)
(186,ani)
(187,iaxsl)
(188,)
(189,variablestore->inheritance = DATASTORE_INHERIT_FOREVER)
(190,var)
(191,i->owner)
(192,tmp)
(193,RET)
(194,ast_channel_accountcode_set(tmp, i->accountcode)
(195,for (v = i->vars ; v ; v = v->next)
(196,i->accountcode)
(197,ast_mutex_unlock(&iaxsl[callno])
(198,ast_channel_tech_set(tmp, &iax2_tech)
(199,NULL)
(200,i)
(201,i)
(202,ast_best_codec(ast_channel_nativeformats(tmp)
(203,i->parkinglot)
(204,varlist)
(205,iaxs[callno])
(206,ast_mutex_unlock(&iaxsl[callno])
(207,v = v->next)
(208,1)
(209,ast_strlen_zero(i->rdnis)
(210,ani)
(211,ast_format_copy(ast_channel_rawwriteformat(tmp)
(212,tmpfmt)
(213,i)
(214,*v = NULL)
(215,i)
(216,tmp)
(217,for (var = i->iaxvars; var; var = var->next)
(218,tmp)
(219,ast_channel_caller(tmp)
(220,var->value)
(221,prev)
(222,ast_channel_caller(tmp)
(223,"No IAX2 pvt found for callno \'%d\' !\\n")
(224,iaxsl[callno])
(225,*varlist)
(226,state)
(227,ast_channel_caller(tmp)
(228,v)
(229,next)
(230,data)
(231,ast_free(prev)
(232,ast_datastore_alloc(&iax2_variable_datastore_info, NULL)
(233,name)
(234,owner)
(235,state)
(236,ast_datastore_free(variablestore)
(237,varlist)
(238,i->host)
(239,)
(240,i)
(241,1)
(242,ast_channel_caller(tmp)
(243,newvar)
(244,!ast_strlen_zero(i->ani)
(245,dnid)
(246,ast_strlen_zero(i->accountcode)
(247,i->calling_pres)
(248,i)
(249,capability)
(250,variablestore)
(251,tmp)
(252,ast_format_cap_from_old_bitfield(ast_channel_nativeformats(tmp)
(253,DATASTORE_INHERIT_FOREVER)
(254,AST_LIST_HEAD_INIT(varlist)
(255,ast_channel_caller(tmp)
(256,tmp)
(257,return NULL;)
(258,name)
(259,tmp)
(260,v)
(261,var)
(262,i)
(263,)
(264,newvar)
(265,tmp)
(266,tmp)
(267,tmpfmt)
(268,value)
(269,callno)
(270,NULL)
(271,)
(272,tmp)
(273,iaxsl)
(274,tmp)
(275,i->rdnis)
(276,i)
(277,parkinglot)
(278,ast_channel_redirecting(tmp)
(279,i->ani)
(280,tmp)
(281,capability)
(282,&tmpfmt)
(283,iaxvars)
(284,tmp)
(285,if (prev)
(286,variablestore)
(287,valid)
(288,tmp)
(289,accountcode)
(290,i)
(291,ast_channel_caller(tmp)
(292,var = i->iaxvars)
(293,language)
(294,ast_channel_caller(tmp)
(295,)
(296,int state)
(297,i)
(298,context)
(299,number)
(300,if (!ast_strlen_zero(i->ani)
(301,ast_channel_parkinglot_set(tmp, i->parkinglot)
(302,exten)
(303,state != AST_STATE_DOWN)
(304,ast_free(varlist)
(305,number)
(306,str)
(307,tmp)
(308,varlist)
(309,ast_channel_caller(tmp)
(310,variablestore)
(311,if (i->vars)
(312,i->capability = capability)
(313,var = var->next)
(314,amaflags)
(315,i->cid_name)
(316,NULL)
(317,i->cid_num)
(318,i->peeradsicpe)
(319,i->owner = NULL)
(320,i->vars)
(321,ast_channel_redirecting(tmp)
(322,ast_channel_caller(tmp)
(323,tmp)
(324,i)
(325,)
(326,tmp)
(327,i)
(328,iaxs)
(329,prev)
(330,iaxvars)
(331,NULL)
(332,tmp)
(333,tmp)
(334,*varlist)
(335,ast_strlen_zero(i->parkinglot)
(336,&iaxsl[callno])
(337,i)
(338,ast_channel_readformat(tmp)
(339,linkedid)
(340,if (!newvar)
(341,language)
(342,owner)
(343,!ast_strlen_zero(i->rdnis)
(344,ast_channel_caller(tmp)
(345,newvar)
(346,LOG_WARNING)
(347,i->exten)
(348,AST_ADSI_UNAVAILABLE)
(349,callid = iaxs[callno]->callid)
(350,ast_strdup(i->rdnis)
(351,id)
(352,vars)
(353,variablestore->data = varlist)
(354,tmp)
(355,v)
(356,id)
(357,v)
(358,v->name)
(359,presentation)
(360,tmp)
(361,accountcode)
(362,ast_module_info->self)
(363,i->context)
(364,v->next)
(365,1)
(366,ast_free(prev)
(367,tmp)
(368,ast_channel_name(tmp)
(369,!(i = iaxs[callno])
(370,i->ani)
(371,tmp)
(372,ani)
(373,str)
(374,ast_strdup(i->ani)
(375,ast_strlen_zero(i->language)
(376,v)
(377,ast_channel_nativeformats(tmp)
(378,variablestore->inheritance)
(379,NULL)
(380,ast_channel_caller(tmp)
(381,return NULL;)
(382,ast_channel_adsicpe_set(tmp, i->peeradsicpe)
(383,var)
(384,self)
(385,tmp)
(386,number)
(387,return NULL;)
(388,"Memory allocation error while processing IAX2 variables\\n")
(389,i)
(390,if (variablestore)
(391,varlist)
(392,ast_format_copy(ast_channel_writeformat(tmp)
(393,tmp)
(394,tmp)
(395,ast_channel_context_set(tmp, i->context)
(396,tmp)
(397,tmp)
(398,i)
(399,i->amaflags)
(400,i->owner)
(401,var)
(402,i->amaflags)
(403,ast_module_ref(ast_module_info->self)
(404,tmp)
(405,i->calling_pres)
(406,number)
(407,&iaxsl[callno])
(408,)
(409,i)
(410,ast_channel_caller(tmp)
(411,LOG_WARNING)
(412,&iaxsl[callno])
(413,)
(414,i)
(415,iax2_format capability)
(416,callno)
(417,&tmpfmt)
(418,from)
(419,id)
(420,i->dnid)
(421,i)
(422,i->owner = tmp)
(423,int callno)
(424,i)
(425,if (i != iaxs[callno])
(426,)
(427,parkinglot)
(428,ast_channel_caller(tmp)
(429,number)
(430,ast_channel_dialed(tmp)
(431,tmp)
(432,iaxsl)
(433,tmp)
(434,ast_channel_redirecting(tmp)
(435,ast_channel_adsicpe_set(tmp, AST_ADSI_UNAVAILABLE)
(436,number)
(437,tmp = ast_channel_alloc(1, state, i->cid_num, i->cid_name, i->accountcode, i->exten, i->context, linkedid, i->amaflags, "IAX2/%s-%d", i->host, i->callno)
(438,tmpfmt)
(439,ast_channel_caller(tmp)
(440,i->calling_tns)
(441,ast_channel_language_set(tmp, i->language)
(442,capability)
(443,ast_channel_amaflags_set(tmp, i->amaflags)
(444,ani)
(445,varlist)
(446,CALLNO_TO_PTR(i->callno)
(447,i->cid_num)
(448,&tmpfmt)
(449,i)
(450,ast_debug(1, "Loading up the channel with IAXVARs\\n")
(451,cid_num)
(452,i->iaxvars)
(453,str)
(454,tmpfmt)
(455,tmp)
(456,NULL)
(457,callno)
(458,tmp)
(459,variablestore)
(460,ast_strlen_zero(i->ani)
(461,i->accountcode)
(462,)
(463,number)
(464,)
(465,ast_channel_tech_pvt_set(tmp, CALLNO_TO_PTR(i->callno)
(466,ast_format_copy(ast_channel_readformat(tmp)
(467,ast_channel_dialed(tmp)
(468,*newvar = ast_var_assign(var->name, var->value)
(469,calling_tns)
(470,ast_strlen_zero(i->cid_num)
(471,callno)
(472,calling_ton)
(473,iaxs)
(474,if (variablestore && varlist)
(475,ast_channel_dialed(tmp)
(476,i->adsi)
(477,tmpfmt)
(478,rdnis)
(479,if (i->adsi)
(480,v)
(481,prev = var)
(482,&iaxsl[callno])
(483,ast_hangup(tmp)
(484,valid)
(485,NULL)
(486,NULL)
(487,ast_channel_alloc(1, state, i->cid_num, i->cid_name, i->accountcode, i->exten, i->context, linkedid, i->amaflags, "IAX2/%s-%d", i->host, i->callno)
(488,ast_strdup(i->dnid)
(489,tmp)
(490,if (ast_pbx_start(tmp)
(491,i)
(492,ast_channel_caller(tmp)
(493,*prev = NULL)
(494,i)
(495,plan)
(496,ast_channel_dialed(tmp)
(497,iax2_tech)
(498,i->language)
(499,i->exten)
(500,1)
(501,const char *linkedid)
(502,ast_channel_caller(tmp)
(503,i != iaxs[callno])
(504,i)
(505,ast_channel_exten_set(tmp, i->exten)
(506,transit_network_select)
(507,)
(508,ast_mutex_lock(&iaxsl[callno])
(509,v->value)
(510,ast_log(LOG_WARNING, "Unable to start PBX on %s\\n", ast_channel_name(tmp)
(511,ast_channel_caller(tmp)
(512,ast_pbx_start(tmp)
(513,vars)
(514,iaxsl[callno])
(515,callno)
(516,i)
(517,ast_channel_writeformat(tmp)
(518,ast_channel_redirecting(tmp)
(519,variablestore && varlist)
(520,ast_calloc(1, sizeof(*varlist)
(521,callno)
(522,iaxsl)
(523,tmp)
(524,i->callno)
(525,if (prev)
(526,sizeof(*varlist)
(527,iax2_ami_channelupdate(i)
(528,ast_log(LOG_WARNING, "No IAX2 pvt found for callno \'%d\' !\\n", callno)
(529,i)
(530,ast_channel_redirecting(tmp)
(531,tmp)
(532,prev)
(533,ast_channel_caller(tmp)
(534,)
(535,)
(536,ast_channel_caller(tmp)
(537,i->iaxvars)
(538,ast_channel_rawwriteformat(tmp)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^