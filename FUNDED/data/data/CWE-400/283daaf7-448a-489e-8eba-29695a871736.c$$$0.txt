-----label-----
1
-----code-----
static unsigned int xfrm_ascii_write(char **buf, unsigned int *buflen,
    unsigned int bufsize) {
  char *tmpbuf = *buf;
  unsigned int tmplen = *buflen;
  unsigned int lfcount = 0;
  unsigned int added = 0;

  int res = 0;
  register unsigned int i = 0;

  /* First, determine how many bare LFs are present. */
  if (!have_dangling_cr && tmpbuf[0] == '\n')
    lfcount++;

  for (i = 1; i < tmplen; i++)
    if (tmpbuf[i] == '\n' && tmpbuf[i-1] != '\r')
      lfcount++;

  /* If the last character in the buffer is CR, then we have a dangling CR.
   * The first character in the next buffer could be an LF, and without
   * this flag, that LF would be treated as a bare LF, thus resulting in
   * an added extraneous CR in the stream.
   */
  have_dangling_cr = (tmpbuf[tmplen-1] == '\r') ? TRUE : FALSE;

  if (lfcount == 0)
    /* No translation needed. */
    return 0;

  /* Assume that for each LF (including a leading LF), space for another
   * char (a '\r') is needed.  Determine whether there is enough space in
   * the buffer for the adjusted data.  If not, allocate a new buffer that is
   * large enough.  The new buffer is allocated from session.xfer.p, which is
   * fine; this pool has a lifetime only for this current data transfer, and
   * will be cleared after the transfer is done, either having succeeded or
   * failed.
   *
   * Note: the res variable is needed in order to force signedness of the
   * resulting difference.  Without it, this condition would never evaluate
   * to true, as C's promotion rules would ensure that the resulting value
   * would be of the same type as the operands: an unsigned int (which will
   * never be less than zero).
   */
  if ((res = (bufsize - tmplen - lfcount)) <= 0) {
    char *copybuf = malloc(tmplen);
    if (copybuf == NULL) {
      pr_log_pri(pr_log_level_exhausted_rsrc(PR_LOG_RSRC_MEM, 0),
        "Out of memory!");
      exit(1);
    }

    memcpy(copybuf, tmpbuf, tmplen);

    /* Allocate a new session.xfer.buf of the needed size. */
    session.xfer.bufsize = tmplen + lfcount + 1;
    session.xfer.buf = pcalloc(session.xfer.p, session.xfer.bufsize);

    memcpy(session.xfer.buf, copybuf, tmplen);

    free(copybuf);
    copybuf = NULL;

    tmpbuf = session.xfer.buf;
    bufsize = session.xfer.bufsize;
  }

  if (tmpbuf[0] == '\n') {

    /* Shift everything in the buffer to the right one character, making
     * space for a '\r'
     */
    memmove(&(tmpbuf[1]), &(tmpbuf[0]), tmplen);
    tmpbuf[0] = '\r';

    /* Increment the number of added characters, and decrement the number
     * of bare LFs.
     */
    added++;
    lfcount--;
  }

  for (i = 1; i < bufsize && (lfcount > 0); i++) {
    if (tmpbuf[i] == '\n' && tmpbuf[i-1] != '\r') {
      memmove(&(tmpbuf[i+1]), &(tmpbuf[i]), bufsize - i - 1);
      tmpbuf[i] = '\r';
      added++;
      lfcount--;
    }
  }

  *buf = tmpbuf;
  *buflen = tmplen + added;

  return added;
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
3,7
5,6
5,7
7,8
7,9
7,10
11,12
11,13
13,14
13,15
16,17
16,18
18,19
20,21
20,22
20,23
20,24
20,25
20,26
20,27
20,28
20,29
20,30
20,31
20,32
20,33
20,34
20,35
20,36
21,22
22,23
22,24
24,25
24,26
24,27
27,28
28,29
29,30
31,32
32,33
32,34
34,35
34,36
36,37
37,38
38,39
40,41
41,42
41,43
43,44
43,45
45,46
47,48
48,49
48,50
50,51
50,52
52,53
54,55
55,56
55,57
57,58
57,59
59,60
61,62
62,63
62,64
64,65
64,66
66,67
68,69
68,70
69,70
69,71
70,71
71,72
73,74
73,75
74,75
74,76
75,76
79,80
80,81
81,82
83,84
83,85
83,86
83,87
84,85
85,86
85,87
86,87
89,90
89,91
90,91
92,93
94,95
95,96
97,98
97,99
98,99
98,100
99,100
99,101
100,101
100,102
101,102
103,104
106,107
106,108
107,108
107,109
108,109
110,111
110,112
111,112
115,116
116,117
117,118
119,120
120,121
120,122
121,122
123,124
123,125
123,126
124,125
125,126
125,127
126,127
126,128
127,128
129,130
129,131
130,131
134,135
136,137
138,139
138,140
139,140
139,141
140,141
143,144
145,146
145,147
146,147
146,148
147,148
148,149
148,150
149,150
151,152
152,153
152,154
153,154
153,155
154,155
156,157
158,159
161,162
161,163
161,164
161,165
161,166
161,167
161,168
161,169
161,170
161,171
162,163
163,164
163,165
165,166
165,167
165,168
168,169
169,170
169,171
170,171
172,173
174,175
174,176
175,176
175,177
176,177
178,179
180,181
180,182
181,182
182,183
182,184
182,185
183,184
185,186
185,187
185,188
186,187
188,189
192,193
193,194
193,195
194,195
197,198
198,199
198,200
198,201
198,202
199,200
201,202
203,204
205,206
207,208
208,209
208,210
209,210
209,211
210,211
210,212
211,212
215,216
215,217
216,217
216,218
217,218
219,220
222,223
223,224
223,225
224,225
224,226
225,226
225,227
226,227
230,231
230,232
230,233
231,232
233,234
233,235
234,235
234,236
235,236
239,240
239,241
240,241
240,242
241,242
245,246
246,247
246,248
246,249
246,250
247,248
249,250
249,251
250,251
250,252
251,252
255,256
257,258
259,260
260,261
260,262
261,262
263,264
265,266
266,267
266,268
267,268
269,270
271,272
272,273
272,274
273,274
275,276
275,277
276,277
276,278
277,278
281,282
282,283
282,284
283,284
285,286
285,287
286,287
286,288
287,288
291,292
291,293
292,293
292,294
293,294
293,295
294,295
298,299
298,300
298,301
298,302
299,300
300,301
300,302
300,303
300,304
301,302
303,304
304,305
305,306
305,307
306,307
309,310
310,311
311,312
311,313
312,313
315,316
317,318
318,319
318,320
319,320
319,321
320,321
324,325
325,326
326,327
328,329
329,330
330,331
332,333
332,334
332,335
332,336
333,334
334,335
334,336
335,336
338,339
338,340
339,340
339,341
340,341
342,343
344,345
345,346
345,347
346,347
349,350
350,351
352,353
353,354
353,355
354,355
354,356
355,356
355,357
356,357
356,358
357,358
359,360
362,363
362,364
363,364
363,365
364,365
366,367
366,368
367,368
371,372
371,373
371,374
371,375
372,373
373,374
373,375
373,376
373,377
374,375
376,377
377,378
378,379
378,380
379,380
381,382
381,383
382,383
385,386
386,387
387,388
387,389
388,389
390,391
392,393
392,394
393,394
393,395
394,395
396,397
399,400
400,401
400,402
401,402
401,403
402,403
404,405
407,408
408,409
409,410
411,412
412,413
413,414
415,416
416,417
416,418
417,418
418,419
420,421
422,423
423,424
423,425
424,425
425,426
427,428
427,429
428,429
430,431
432,433
433,434
-----nextToken-----
2,4,6,8,9,10,12,14,15,17,19,23,25,26,30,33,35,39,42,44,46,49,51,53,56,58,60,63,65,67,72,76,77,78,82,87,88,91,93,96,102,104,105,109,112,113,114,118,122,128,131,132,133,135,137,141,142,144,150,155,157,159,160,164,166,167,171,173,177,179,184,187,189,190,191,195,196,200,202,204,206,212,213,214,218,220,221,227,228,229,232,236,237,238,242,243,244,248,252,253,254,256,258,262,264,268,270,274,278,279,280,284,288,289,290,295,296,297,302,307,308,313,314,316,321,322,323,327,331,336,337,341,343,347,348,351,358,360,361,365,368,369,370,375,380,383,384,389,391,395,397,398,403,405,406,410,414,419,421,426,429,431,434
-----computeFrom-----
69,70
69,71
73,74
73,75
85,86
85,87
89,90
89,91
98,99
98,100
99,100
99,101
106,107
106,108
110,111
110,112
120,121
120,122
125,126
125,127
129,130
129,131
139,140
139,141
146,147
146,148
148,149
148,150
152,153
152,154
153,154
153,155
175,176
175,177
208,209
208,210
215,216
215,217
216,217
216,218
223,224
223,225
266,267
266,268
272,273
272,274
282,283
282,284
292,293
292,294
318,319
318,320
334,335
334,336
338,339
338,340
339,340
339,341
345,346
345,347
354,355
354,356
355,356
355,357
362,363
362,364
366,367
366,368
381,382
381,383
392,393
392,394
393,394
393,395
400,401
400,402
416,417
416,418
423,424
423,425
427,428
427,429
-----guardedBy-----
159,220
155,290
157,258
295,321
368,405
365,403
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;UnaryExpression;IdExpression;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;UnaryExpression;IdExpression;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;IfStatement;BinaryExpression;UnaryExpression;IdExpression;Name;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;UnaryExpression;IdExpression;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;ConditionalExpression;UnaryExpression;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ReturnStatement;LiteralExpression;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;UnaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;BinaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;IfStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;UnaryExpression;IdExpression;Name;ExpressionStatement;UnaryExpression;IdExpression;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;UnaryExpression;IdExpression;Name;ExpressionStatement;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;UnaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;UnaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;IdExpression;Name;
-----ast_node-----
static unsigned int xfrm_ascii_write(char **buf, unsigned int *buflen,    unsigned int bufsize) {  char *tmpbuf = *buf;  unsigned int tmplen = *buflen;  unsigned int lfcount = 0;  unsigned int added = 0;  int res = 0;  register unsigned int i = 0;  /* First, determine how many bare LFs are present. */  if (!have_dangling_cr && tmpbuf[0] == '\n')    lfcount++;  for (i = 1; i < tmplen; i++)    if (tmpbuf[i] == '\n' && tmpbuf[i-1] != '\r')      lfcount++;  /* If the last character in the buffer is CR, then we have a dangling CR.   * The first character in the next buffer could be an LF, and without   * this flag, that LF would be treated as a bare LF, thus resulting in   * an added extraneous CR in the stream.   */  have_dangling_cr = (tmpbuf[tmplen-1] == '\r') ? TRUE : FALSE;  if (lfcount == 0)    /* No translation needed. */    return 0;  /* Assume that for each LF (including a leading LF), space for another   * char (a '\r') is needed.  Determine whether there is enough space in   * the buffer for the adjusted data.  If not, allocate a new buffer that is   * large enough.  The new buffer is allocated from session.xfer.p, which is   * fine; this pool has a lifetime only for this current data transfer, and   * will be cleared after the transfer is done, either having succeeded or   * failed.   *   * Note: the res variable is needed in order to force signedness of the   * resulting difference.  Without it, this condition would never evaluate   * to true, as C's promotion rules would ensure that the resulting value   * would be of the same type as the operands: an unsigned int (which will   * never be less than zero).   */  if ((res = (bufsize - tmplen - lfcount)) <= 0) {    char *copybuf = malloc(tmplen);    if (copybuf == NULL) {      pr_log_pri(pr_log_level_exhausted_rsrc(PR_LOG_RSRC_MEM, 0),        "Out of memory!");      exit(1);    }    memcpy(copybuf, tmpbuf, tmplen);    /* Allocate a new session.xfer.buf of the needed size. */    session.xfer.bufsize = tmplen + lfcount + 1;    session.xfer.buf = pcalloc(session.xfer.p, session.xfer.bufsize);    memcpy(session.xfer.buf, copybuf, tmplen);    free(copybuf);    copybuf = NULL;    tmpbuf = session.xfer.buf;    bufsize = session.xfer.bufsize;  }  if (tmpbuf[0] == '\n') {    /* Shift everything in the buffer to the right one character, making     * space for a '\r'     */    memmove(&(tmpbuf[1]), &(tmpbuf[0]), tmplen);    tmpbuf[0] = '\r';    /* Increment the number of added characters, and decrement the number     * of bare LFs.     */    added++;    lfcount--;  }  for (i = 1; i < bufsize && (lfcount > 0); i++) {    if (tmpbuf[i] == '\n' && tmpbuf[i-1] != '\r') {      memmove(&(tmpbuf[i+1]), &(tmpbuf[i]), bufsize - i - 1);      tmpbuf[i] = '\r';      added++;      lfcount--;    }  }  *buf = tmpbuf;  *buflen = tmplen + added;  return added;}
static unsigned int
xfrm_ascii_write(char **buf, unsigned int *buflen,    unsigned int bufsize)
xfrm_ascii_write
char **buf
char
**buf
*
*
buf
unsigned int *buflen
unsigned int
*buflen
*
buflen
unsigned int bufsize
unsigned int
bufsize
bufsize
{  char *tmpbuf = *buf;  unsigned int tmplen = *buflen;  unsigned int lfcount = 0;  unsigned int added = 0;  int res = 0;  register unsigned int i = 0;  /* First, determine how many bare LFs are present. */  if (!have_dangling_cr && tmpbuf[0] == '\n')    lfcount++;  for (i = 1; i < tmplen; i++)    if (tmpbuf[i] == '\n' && tmpbuf[i-1] != '\r')      lfcount++;  /* If the last character in the buffer is CR, then we have a dangling CR.   * The first character in the next buffer could be an LF, and without   * this flag, that LF would be treated as a bare LF, thus resulting in   * an added extraneous CR in the stream.   */  have_dangling_cr = (tmpbuf[tmplen-1] == '\r') ? TRUE : FALSE;  if (lfcount == 0)    /* No translation needed. */    return 0;  /* Assume that for each LF (including a leading LF), space for another   * char (a '\r') is needed.  Determine whether there is enough space in   * the buffer for the adjusted data.  If not, allocate a new buffer that is   * large enough.  The new buffer is allocated from session.xfer.p, which is   * fine; this pool has a lifetime only for this current data transfer, and   * will be cleared after the transfer is done, either having succeeded or   * failed.   *   * Note: the res variable is needed in order to force signedness of the   * resulting difference.  Without it, this condition would never evaluate   * to true, as C's promotion rules would ensure that the resulting value   * would be of the same type as the operands: an unsigned int (which will   * never be less than zero).   */  if ((res = (bufsize - tmplen - lfcount)) <= 0) {    char *copybuf = malloc(tmplen);    if (copybuf == NULL) {      pr_log_pri(pr_log_level_exhausted_rsrc(PR_LOG_RSRC_MEM, 0),        "Out of memory!");      exit(1);    }    memcpy(copybuf, tmpbuf, tmplen);    /* Allocate a new session.xfer.buf of the needed size. */    session.xfer.bufsize = tmplen + lfcount + 1;    session.xfer.buf = pcalloc(session.xfer.p, session.xfer.bufsize);    memcpy(session.xfer.buf, copybuf, tmplen);    free(copybuf);    copybuf = NULL;    tmpbuf = session.xfer.buf;    bufsize = session.xfer.bufsize;  }  if (tmpbuf[0] == '\n') {    /* Shift everything in the buffer to the right one character, making     * space for a '\r'     */    memmove(&(tmpbuf[1]), &(tmpbuf[0]), tmplen);    tmpbuf[0] = '\r';    /* Increment the number of added characters, and decrement the number     * of bare LFs.     */    added++;    lfcount--;  }  for (i = 1; i < bufsize && (lfcount > 0); i++) {    if (tmpbuf[i] == '\n' && tmpbuf[i-1] != '\r') {      memmove(&(tmpbuf[i+1]), &(tmpbuf[i]), bufsize - i - 1);      tmpbuf[i] = '\r';      added++;      lfcount--;    }  }  *buf = tmpbuf;  *buflen = tmplen + added;  return added;}
char *tmpbuf = *buf;
char *tmpbuf = *buf;
char
*tmpbuf = *buf
*
tmpbuf
= *buf
*buf
buf
buf
unsigned int tmplen = *buflen;
unsigned int tmplen = *buflen;
unsigned int
tmplen = *buflen
tmplen
= *buflen
*buflen
buflen
buflen
unsigned int lfcount = 0;
unsigned int lfcount = 0;
unsigned int
lfcount = 0
lfcount
= 0
0
unsigned int added = 0;
unsigned int added = 0;
unsigned int
added = 0
added
= 0
0
int res = 0;
int res = 0;
int
res = 0
res
= 0
0
register unsigned int i = 0;
register unsigned int i = 0;
register unsigned int
i = 0
i
= 0
0
if (!have_dangling_cr && tmpbuf[0] == '\n')    lfcount++;
!have_dangling_cr && tmpbuf[0] == '\n'
!have_dangling_cr
have_dangling_cr
have_dangling_cr
tmpbuf[0] == '\n'
tmpbuf[0]
tmpbuf
tmpbuf
0
'\n'
lfcount++;
lfcount++
lfcount
lfcount
for (i = 1; i < tmplen; i++)    if (tmpbuf[i] == '\n' && tmpbuf[i-1] != '\r')      lfcount++;
i = 1;
i = 1
i
i
1
i < tmplen
i
i
tmplen
tmplen
i++
i
i
if (tmpbuf[i] == '\n' && tmpbuf[i-1] != '\r')      lfcount++;
tmpbuf[i] == '\n' && tmpbuf[i-1] != '\r'
tmpbuf[i] == '\n'
tmpbuf[i]
tmpbuf
tmpbuf
i
i
'\n'
tmpbuf[i-1] != '\r'
tmpbuf[i-1]
tmpbuf
tmpbuf
i-1
i
i
1
'\r'
lfcount++;
lfcount++
lfcount
lfcount
have_dangling_cr = (tmpbuf[tmplen-1] == '\r') ? TRUE : FALSE;
have_dangling_cr = (tmpbuf[tmplen-1] == '\r') ? TRUE : FALSE
have_dangling_cr
have_dangling_cr
(tmpbuf[tmplen-1] == '\r') ? TRUE : FALSE
(tmpbuf[tmplen-1] == '\r')
tmpbuf[tmplen-1] == '\r'
tmpbuf[tmplen-1]
tmpbuf
tmpbuf
tmplen-1
tmplen
tmplen
1
'\r'
TRUE
TRUE
FALSE
FALSE
if (lfcount == 0)    /* No translation needed. */    return 0;
lfcount == 0
lfcount
lfcount
0
return 0;
0
if ((res = (bufsize - tmplen - lfcount)) <= 0) {    char *copybuf = malloc(tmplen);    if (copybuf == NULL) {      pr_log_pri(pr_log_level_exhausted_rsrc(PR_LOG_RSRC_MEM, 0),        "Out of memory!");      exit(1);    }    memcpy(copybuf, tmpbuf, tmplen);    /* Allocate a new session.xfer.buf of the needed size. */    session.xfer.bufsize = tmplen + lfcount + 1;    session.xfer.buf = pcalloc(session.xfer.p, session.xfer.bufsize);    memcpy(session.xfer.buf, copybuf, tmplen);    free(copybuf);    copybuf = NULL;    tmpbuf = session.xfer.buf;    bufsize = session.xfer.bufsize;  }
(res = (bufsize - tmplen - lfcount)) <= 0
(res = (bufsize - tmplen - lfcount))
res = (bufsize - tmplen - lfcount)
res
res
(bufsize - tmplen - lfcount)
bufsize - tmplen - lfcount
bufsize - tmplen
bufsize
bufsize
tmplen
tmplen
lfcount
lfcount
0
{    char *copybuf = malloc(tmplen);    if (copybuf == NULL) {      pr_log_pri(pr_log_level_exhausted_rsrc(PR_LOG_RSRC_MEM, 0),        "Out of memory!");      exit(1);    }    memcpy(copybuf, tmpbuf, tmplen);    /* Allocate a new session.xfer.buf of the needed size. */    session.xfer.bufsize = tmplen + lfcount + 1;    session.xfer.buf = pcalloc(session.xfer.p, session.xfer.bufsize);    memcpy(session.xfer.buf, copybuf, tmplen);    free(copybuf);    copybuf = NULL;    tmpbuf = session.xfer.buf;    bufsize = session.xfer.bufsize;  }
char *copybuf = malloc(tmplen);
char *copybuf = malloc(tmplen);
char
*copybuf = malloc(tmplen)
*
copybuf
= malloc(tmplen)
malloc(tmplen)
malloc
malloc
tmplen
tmplen
if (copybuf == NULL) {      pr_log_pri(pr_log_level_exhausted_rsrc(PR_LOG_RSRC_MEM, 0),        "Out of memory!");      exit(1);    }
copybuf == NULL
copybuf
copybuf
NULL
NULL
{      pr_log_pri(pr_log_level_exhausted_rsrc(PR_LOG_RSRC_MEM, 0),        "Out of memory!");      exit(1);    }
pr_log_pri(pr_log_level_exhausted_rsrc(PR_LOG_RSRC_MEM, 0),        "Out of memory!");
pr_log_pri(pr_log_level_exhausted_rsrc(PR_LOG_RSRC_MEM, 0),        "Out of memory!")
pr_log_pri
pr_log_pri
pr_log_level_exhausted_rsrc(PR_LOG_RSRC_MEM, 0)
pr_log_level_exhausted_rsrc
pr_log_level_exhausted_rsrc
PR_LOG_RSRC_MEM
PR_LOG_RSRC_MEM
0
"Out of memory!"
exit(1);
exit(1)
exit
exit
1
memcpy(copybuf, tmpbuf, tmplen);
memcpy(copybuf, tmpbuf, tmplen)
memcpy
memcpy
copybuf
copybuf
tmpbuf
tmpbuf
tmplen
tmplen
session.xfer.bufsize = tmplen + lfcount + 1;
session.xfer.bufsize = tmplen + lfcount + 1
session.xfer.bufsize
session.xfer
session
session
xfer
bufsize
tmplen + lfcount + 1
tmplen + lfcount
tmplen
tmplen
lfcount
lfcount
1
session.xfer.buf = pcalloc(session.xfer.p, session.xfer.bufsize);
session.xfer.buf = pcalloc(session.xfer.p, session.xfer.bufsize)
session.xfer.buf
session.xfer
session
session
xfer
buf
pcalloc(session.xfer.p, session.xfer.bufsize)
pcalloc
pcalloc
session.xfer.p
session.xfer
session
session
xfer
p
session.xfer.bufsize
session.xfer
session
session
xfer
bufsize
memcpy(session.xfer.buf, copybuf, tmplen);
memcpy(session.xfer.buf, copybuf, tmplen)
memcpy
memcpy
session.xfer.buf
session.xfer
session
session
xfer
buf
copybuf
copybuf
tmplen
tmplen
free(copybuf);
free(copybuf)
free
free
copybuf
copybuf
copybuf = NULL;
copybuf = NULL
copybuf
copybuf
NULL
NULL
tmpbuf = session.xfer.buf;
tmpbuf = session.xfer.buf
tmpbuf
tmpbuf
session.xfer.buf
session.xfer
session
session
xfer
buf
bufsize = session.xfer.bufsize;
bufsize = session.xfer.bufsize
bufsize
bufsize
session.xfer.bufsize
session.xfer
session
session
xfer
bufsize
if (tmpbuf[0] == '\n') {    /* Shift everything in the buffer to the right one character, making     * space for a '\r'     */    memmove(&(tmpbuf[1]), &(tmpbuf[0]), tmplen);    tmpbuf[0] = '\r';    /* Increment the number of added characters, and decrement the number     * of bare LFs.     */    added++;    lfcount--;  }
tmpbuf[0] == '\n'
tmpbuf[0]
tmpbuf
tmpbuf
0
'\n'
{    /* Shift everything in the buffer to the right one character, making     * space for a '\r'     */    memmove(&(tmpbuf[1]), &(tmpbuf[0]), tmplen);    tmpbuf[0] = '\r';    /* Increment the number of added characters, and decrement the number     * of bare LFs.     */    added++;    lfcount--;  }
memmove(&(tmpbuf[1]), &(tmpbuf[0]), tmplen);
memmove(&(tmpbuf[1]), &(tmpbuf[0]), tmplen)
memmove
memmove
&(tmpbuf[1])
(tmpbuf[1])
tmpbuf[1]
tmpbuf
tmpbuf
1
&(tmpbuf[0])
(tmpbuf[0])
tmpbuf[0]
tmpbuf
tmpbuf
0
tmplen
tmplen
tmpbuf[0] = '\r';
tmpbuf[0] = '\r'
tmpbuf[0]
tmpbuf
tmpbuf
0
'\r'
added++;
added++
added
added
lfcount--;
lfcount--
lfcount
lfcount
for (i = 1; i < bufsize && (lfcount > 0); i++) {    if (tmpbuf[i] == '\n' && tmpbuf[i-1] != '\r') {      memmove(&(tmpbuf[i+1]), &(tmpbuf[i]), bufsize - i - 1);      tmpbuf[i] = '\r';      added++;      lfcount--;    }  }
i = 1;
i = 1
i
i
1
i < bufsize && (lfcount > 0)
i < bufsize
i
i
bufsize
bufsize
(lfcount > 0)
lfcount > 0
lfcount
lfcount
0
i++
i
i
{    if (tmpbuf[i] == '\n' && tmpbuf[i-1] != '\r') {      memmove(&(tmpbuf[i+1]), &(tmpbuf[i]), bufsize - i - 1);      tmpbuf[i] = '\r';      added++;      lfcount--;    }  }
if (tmpbuf[i] == '\n' && tmpbuf[i-1] != '\r') {      memmove(&(tmpbuf[i+1]), &(tmpbuf[i]), bufsize - i - 1);      tmpbuf[i] = '\r';      added++;      lfcount--;    }
tmpbuf[i] == '\n' && tmpbuf[i-1] != '\r'
tmpbuf[i] == '\n'
tmpbuf[i]
tmpbuf
tmpbuf
i
i
'\n'
tmpbuf[i-1] != '\r'
tmpbuf[i-1]
tmpbuf
tmpbuf
i-1
i
i
1
'\r'
{      memmove(&(tmpbuf[i+1]), &(tmpbuf[i]), bufsize - i - 1);      tmpbuf[i] = '\r';      added++;      lfcount--;    }
memmove(&(tmpbuf[i+1]), &(tmpbuf[i]), bufsize - i - 1);
memmove(&(tmpbuf[i+1]), &(tmpbuf[i]), bufsize - i - 1)
memmove
memmove
&(tmpbuf[i+1])
(tmpbuf[i+1])
tmpbuf[i+1]
tmpbuf
tmpbuf
i+1
i
i
1
&(tmpbuf[i])
(tmpbuf[i])
tmpbuf[i]
tmpbuf
tmpbuf
i
i
bufsize - i - 1
bufsize - i
bufsize
bufsize
i
i
1
tmpbuf[i] = '\r';
tmpbuf[i] = '\r'
tmpbuf[i]
tmpbuf
tmpbuf
i
i
'\r'
added++;
added++
added
added
lfcount--;
lfcount--
lfcount
lfcount
*buf = tmpbuf;
*buf = tmpbuf
*buf
buf
buf
tmpbuf
tmpbuf
*buflen = tmplen + added;
*buflen = tmplen + added
*buflen
buflen
buflen
tmplen + added
tmplen
tmplen
added
added
return added;
added
added
-----joern-----
(29,47,0)
(250,256,0)
(23,171,0)
(148,199,0)
(185,171,0)
(168,23,0)
(192,120,0)
(93,146,0)
(53,82,0)
(52,204,0)
(91,237,0)
(239,237,0)
(145,114,0)
(147,195,0)
(194,186,0)
(176,3,0)
(67,53,0)
(178,229,0)
(221,234,0)
(258,148,0)
(164,34,0)
(132,154,0)
(145,85,0)
(47,234,0)
(141,1,0)
(137,123,0)
(197,192,0)
(84,93,0)
(239,242,0)
(102,233,0)
(106,237,0)
(100,59,0)
(13,153,0)
(173,131,0)
(234,221,0)
(119,146,0)
(163,189,0)
(154,59,0)
(231,132,0)
(144,205,0)
(12,239,0)
(232,133,0)
(120,101,0)
(113,244,0)
(82,18,0)
(155,55,0)
(14,55,0)
(248,73,0)
(58,237,0)
(156,131,0)
(207,74,0)
(149,227,0)
(2,13,0)
(169,85,0)
(262,167,0)
(182,259,0)
(133,195,0)
(185,37,0)
(20,58,0)
(124,115,0)
(153,189,0)
(245,8,0)
(125,58,0)
(6,40,0)
(111,36,0)
(201,224,0)
(14,131,0)
(101,120,0)
(99,18,0)
(138,157,0)
(221,155,0)
(28,189,0)
(111,237,0)
(243,104,0)
(179,256,0)
(121,177,0)
(112,55,0)
(43,153,0)
(75,189,0)
(34,85,0)
(72,256,0)
(105,29,0)
(82,211,0)
(36,131,0)
(125,171,0)
(242,146,0)
(119,1,0)
(221,153,0)
(116,33,0)
(123,137,0)
(196,199,0)
(31,176,0)
(146,189,0)
(78,14,0)
(58,125,0)
(128,33,0)
(19,86,0)
(95,40,0)
(143,40,0)
(150,27,0)
(46,24,0)
(140,196,0)
(71,55,0)
(87,128,0)
(34,25,0)
(110,249,0)
(79,167,0)
(63,152,0)
(157,153,0)
(126,261,0)
(188,259,0)
(80,18,0)
(170,8,0)
(21,207,0)
(56,112,0)
(73,229,0)
(222,36,0)
(24,146,0)
(23,137,0)
(80,177,0)
(109,222,0)
(262,86,0)
(92,157,0)
(92,189,0)
(162,136,0)
(25,34,0)
(220,55,0)
(61,214,0)
(234,18,0)
(249,227,0)
(246,222,0)
(212,103,0)
(6,211,0)
(208,155,0)
(228,141,0)
(125,187,0)
(199,82,0)
(137,23,0)
(53,83,0)
(215,227,0)
(167,84,0)
(165,191,0)
(218,59,0)
(227,249,0)
(251,83,0)
(258,233,0)
(30,18,0)
(244,146,0)
(49,148,0)
(114,244,0)
(260,258,0)
(42,153,0)
(198,93,0)
(244,36,0)
(155,221,0)
(66,245,0)
(183,80,0)
(15,54,0)
(166,217,0)
(254,86,0)
(191,153,0)
(256,72,0)
(40,6,0)
(5,42,0)
(156,125,0)
(39,187,0)
(135,6,0)
(111,146,0)
(261,55,0)
(235,99,0)
(187,18,0)
(192,24,0)
(253,54,0)
(167,262,0)
(211,47,0)
(167,153,0)
(59,104,0)
(72,82,0)
(248,224,0)
(83,53,0)
(37,185,0)
(103,189,0)
(219,71,0)
(141,49,0)
(222,142,0)
(64,199,0)
(125,156,0)
(227,153,0)
(160,189,0)
(81,123,0)
(41,229,0)
(48,186,0)
(216,252,0)
(255,55,0)
(136,54,0)
(226,189,0)
(26,57,0)
(224,248,0)
(88,155,0)
(0,74,0)
(71,115,0)
(133,234,0)
(154,189,0)
(174,99,0)
(84,167,0)
(139,29,0)
(27,189,0)
(245,223,0)
(173,57,0)
(195,133,0)
(214,189,0)
(222,148,0)
(185,187,0)
(172,114,0)
(134,74,0)
(93,148,0)
(256,18,0)
(244,114,0)
(76,18,0)
(213,112,0)
(211,82,0)
(233,258,0)
(225,83,0)
(152,259,0)
(200,73,0)
(244,237,0)
(70,36,0)
(68,237,0)
(99,177,0)
(74,259,0)
(49,189,0)
(47,211,0)
(27,57,0)
(230,106,0)
(153,42,0)
(77,99,0)
(69,137,0)
(86,262,0)
(98,214,0)
(156,142,0)
(54,136,0)
(34,148,0)
(222,237,0)
(121,153,0)
(136,234,0)
(167,115,0)
(60,101,0)
(13,259,0)
(24,192,0)
(257,239,0)
(24,259,0)
(118,242,0)
(159,189,0)
(85,34,0)
(85,145,0)
(128,146,0)
(11,196,0)
(157,92,0)
(204,18,0)
(111,148,0)
(118,156,0)
(128,148,0)
(210,121,0)
(7,189,0)
(59,154,0)
(50,111,0)
(249,104,0)
(256,153,0)
(124,57,0)
(104,59,0)
(49,146,0)
(16,180,0)
(207,146,0)
(209,25,0)
(190,189,0)
(242,239,0)
(112,37,0)
(127,111,0)
(65,204,0)
(238,191,0)
(185,237,0)
(86,148,0)
(161,244,0)
(211,6,0)
(57,189,0)
(101,207,0)
(202,173,0)
(33,115,0)
(117,128,0)
(191,55,0)
(55,189,0)
(107,177,0)
(206,242,0)
(157,57,0)
(184,189,0)
(32,220,0)
(17,157,0)
(229,73,0)
(242,118,0)
(42,3,0)
(23,191,0)
(175,180,0)
(8,245,0)
(249,146,0)
(193,125,0)
(258,146,0)
(142,222,0)
(96,124,0)
(181,47,0)
(114,145,0)
(203,217,0)
(10,258,0)
(9,13,0)
(256,177,0)
(156,118,0)
(217,72,0)
(180,177,0)
(35,185,0)
(62,55,0)
(93,84,0)
(51,49,0)
(45,72,0)
(104,249,0)
(74,207,0)
(120,192,0)
(129,148,0)
(146,119,0)
(241,24,0)
(199,148,0)
(177,18,0)
(229,146,0)
(222,146,0)
(34,146,0)
(148,18,0)
(122,58,0)
(186,55,0)
(151,195,0)
(99,153,0)
(37,112,0)
(97,146,0)
(240,189,0)
(247,57,0)
(133,187,0)
(108,8,0)
(187,133,0)
(86,146,0)
(25,237,0)
(191,23,0)
(90,93,0)
(187,171,0)
(94,221,0)
(142,156,0)
(199,196,0)
(242,148,0)
(38,103,0)
(47,29,0)
(205,223,0)
(99,146,0)
(73,248,0)
(231,27,0)
(89,132,0)
(176,92,0)
(4,25,0)
(236,154,0)
(158,189,0)
(72,217,0)
(44,185,0)
(244,148,0)
(207,101,0)
(177,121,0)
(130,119,0)
(22,189,0)
(47,29,1)
(206,145,1)
(199,196,1)
(34,148,1)
(19,254,1)
(213,56,1)
(182,220,1)
(33,116,1)
(145,85,1)
(132,89,1)
(196,11,1)
(180,175,1)
(74,259,1)
(71,55,1)
(124,57,1)
(36,70,1)
(205,144,1)
(211,47,1)
(108,170,1)
(106,230,1)
(156,125,1)
(15,253,1)
(86,148,1)
(64,196,1)
(125,58,1)
(233,258,1)
(162,54,1)
(236,13,1)
(52,65,1)
(69,186,1)
(58,122,1)
(38,212,1)
(35,106,1)
(169,34,1)
(125,171,1)
(45,217,1)
(176,31,1)
(185,44,1)
(219,124,1)
(155,55,1)
(109,246,1)
(136,54,1)
(182,248,1)
(89,186,1)
(136,162,1)
(227,149,1)
(49,148,1)
(258,148,1)
(81,137,1)
(34,25,1)
(112,213,1)
(224,201,1)
(192,24,1)
(243,249,1)
(128,117,1)
(191,153,1)
(229,178,1)
(260,123,1)
(127,50,1)
(228,37,1)
(73,229,1)
(255,62,1)
(93,146,1)
(144,245,1)
(152,259,1)
(187,171,1)
(172,244,1)
(56,185,1)
(183,256,1)
(138,176,1)
(119,130,1)
(175,16,1)
(53,67,1)
(249,227,1)
(23,171,1)
(101,207,1)
(186,55,1)
(235,205,1)
(4,164,1)
(91,71,1)
(195,151,1)
(35,237,1)
(173,202,1)
(116,128,1)
(180,177,1)
(259,188,1)
(215,110,1)
(157,153,1)
(256,177,1)
(111,237,1)
(244,146,1)
(10,260,1)
(105,139,1)
(111,127,1)
(79,84,1)
(231,132,1)
(100,104,1)
(25,209,1)
(156,118,1)
(222,109,1)
(43,146,1)
(157,57,1)
(8,108,1)
(93,198,1)
(258,10,1)
(261,126,1)
(27,150,1)
(49,51,1)
(155,208,1)
(102,258,1)
(167,262,1)
(202,36,1)
(222,36,1)
(176,3,1)
(66,8,1)
(253,99,1)
(106,237,1)
(13,153,1)
(114,172,1)
(99,177,1)
(220,32,1)
(156,142,1)
(117,87,1)
(71,219,1)
(242,239,1)
(222,146,1)
(239,257,1)
(72,45,1)
(5,43,1)
(92,157,1)
(256,153,1)
(104,249,1)
(9,152,1)
(112,55,1)
(188,182,1)
(238,168,1)
(83,251,1)
(47,181,1)
(88,94,1)
(122,20,1)
(168,69,1)
(167,79,1)
(220,55,1)
(178,41,1)
(199,82,1)
(194,48,1)
(130,97,1)
(80,177,1)
(167,153,1)
(128,146,1)
(237,68,1)
(249,146,1)
(181,29,1)
(222,237,1)
(63,261,1)
(254,233,1)
(134,0,1)
(118,242,1)
(151,147,1)
(60,207,1)
(244,148,1)
(9,259,1)
(65,80,1)
(126,120,1)
(234,221,1)
(193,142,1)
(239,237,1)
(39,148,1)
(191,165,1)
(124,96,1)
(185,237,1)
(247,26,1)
(153,42,1)
(12,206,1)
(99,146,1)
(212,214,1)
(142,222,1)
(84,93,1)
(111,148,1)
(244,237,1)
(41,224,1)
(107,123,1)
(90,262,1)
(177,121,1)
(218,104,1)
(258,146,1)
(24,146,1)
(248,224,1)
(44,35,1)
(99,153,1)
(26,55,1)
(222,148,1)
(187,133,1)
(227,153,1)
(170,180,1)
(37,185,1)
(82,211,1)
(94,136,1)
(6,135,1)
(230,14,1)
(262,86,1)
(78,173,1)
(135,40,1)
(67,83,1)
(200,229,1)
(40,95,1)
(260,187,1)
(148,199,1)
(54,15,1)
(165,238,1)
(32,248,1)
(14,78,1)
(251,225,1)
(133,232,1)
(120,192,1)
(210,107,1)
(157,17,1)
(11,140,1)
(101,60,1)
(146,119,1)
(70,111,1)
(87,167,1)
(68,91,1)
(123,137,1)
(147,39,1)
(72,217,1)
(203,82,1)
(141,1,1)
(111,146,1)
(245,66,1)
(164,114,1)
(2,9,1)
(73,200,1)
(121,153,1)
(103,38,1)
(86,146,1)
(199,64,1)
(137,23,1)
(235,180,1)
(149,215,1)
(185,187,1)
(245,8,1)
(59,100,1)
(114,244,1)
(214,98,1)
(21,192,1)
(231,27,1)
(85,169,1)
(230,145,1)
(49,146,1)
(121,210,1)
(133,195,1)
(86,19,1)
(59,218,1)
(229,146,1)
(241,46,1)
(225,234,1)
(197,24,1)
(244,161,1)
(261,55,1)
(123,81,1)
(27,57,1)
(166,203,1)
(221,155,1)
(119,1,1)
(50,156,1)
(204,52,1)
(256,72,1)
(14,55,1)
(207,146,1)
(98,61,1)
(244,36,1)
(113,37,1)
(47,234,1)
(198,90,1)
(110,236,1)
(51,141,1)
(62,153,1)
(42,5,1)
(145,114,1)
(233,102,1)
(248,73,1)
(167,84,1)
(140,129,1)
(93,148,1)
(120,101,1)
(42,3,1)
(74,134,1)
(17,138,1)
(72,82,1)
(77,235,1)
(221,153,1)
(209,4,1)
(208,88,1)
(132,154,1)
(31,49,1)
(24,259,1)
(207,74,1)
(257,12,1)
(192,197,1)
(13,2,1)
(48,154,1)
(25,237,1)
(129,204,1)
(13,259,1)
(179,250,1)
(128,148,1)
(141,228,1)
(85,34,1)
(250,72,1)
(24,241,1)
(125,187,1)
(242,148,1)
(58,237,1)
(174,77,1)
(173,57,1)
(91,233,1)
(242,146,1)
(217,166,1)
(63,120,1)
(201,103,1)
(61,57,1)
(191,55,1)
(34,146,1)
(0,21,1)
(211,6,1)
(154,59,1)
(186,194,1)
(152,63,1)
(16,177,1)
(53,83,1)
(246,118,1)
(37,112,1)
(29,105,1)
(6,40,1)
(143,53,1)
(133,234,1)
(161,113,1)
(96,33,1)
(232,195,1)
(150,92,1)
(185,171,1)
(20,193,1)
(46,13,1)
(95,143,1)
(80,183,1)
(57,247,1)
(99,174,1)
(23,191,1)
(256,179,1)
(55,255,1)
(59,104,1)
(139,6,1)
(104,243,1)
(177,121,2)
(249,146,2)
(157,153,2)
(137,23,2)
(37,186,2)
(84,93,2)
(100,104,2)
(250,123,2)
(77,123,2)
(175,123,2)
(176,3,2)
(211,47,2)
(234,221,2)
(231,27,2)
(59,104,2)
(90,233,2)
(133,234,2)
(155,55,2)
(121,153,2)
(186,55,2)
(199,196,2)
(80,177,2)
(262,233,2)
(125,145,2)
(50,145,2)
(24,13,2)
(99,146,2)
(229,224,2)
(20,145,2)
(112,55,2)
(141,186,2)
(47,234,2)
(203,123,2)
(154,59,2)
(52,123,2)
(221,123,2)
(13,13,2)
(93,146,2)
(72,217,2)
(192,24,2)
(239,145,2)
(222,148,2)
(114,37,2)
(83,123,2)
(68,186,2)
(40,123,2)
(260,186,2)
(167,262,2)
(231,132,2)
(242,239,2)
(13,259,2)
(244,36,2)
(232,123,2)
(258,148,2)
(36,145,2)
(207,74,2)
(162,123,2)
(234,123,2)
(195,123,2)
(23,186,2)
(122,145,2)
(139,123,2)
(71,233,2)
(164,114,2)
(245,180,2)
(102,186,2)
(136,54,2)
(256,177,2)
(213,185,2)
(132,154,2)
(86,233,2)
(199,123,2)
(14,55,2)
(132,186,2)
(46,13,2)
(93,233,2)
(72,82,2)
(109,145,2)
(34,114,2)
(185,237,2)
(60,192,2)
(210,123,2)
(47,123,2)
(67,123,2)
(12,145,2)
(202,145,2)
(208,123,2)
(86,148,2)
(133,123,2)
(17,186,2)
(167,153,2)
(120,192,2)
(123,137,2)
(74,192,2)
(254,233,2)
(92,186,2)
(167,84,2)
(151,123,2)
(27,186,2)
(25,114,2)
(206,145,2)
(178,224,2)
(87,233,2)
(94,123,2)
(248,73,2)
(9,13,2)
(11,123,2)
(187,133,2)
(146,119,2)
(219,233,2)
(120,13,2)
(233,186,2)
(92,157,2)
(54,123,2)
(205,180,2)
(53,123,2)
(174,123,2)
(257,145,2)
(101,192,2)
(8,180,2)
(168,186,2)
(222,146,2)
(148,123,2)
(237,186,2)
(49,146,2)
(145,114,2)
(204,123,2)
(33,233,2)
(58,145,2)
(218,104,2)
(65,123,2)
(71,55,2)
(69,186,2)
(256,153,2)
(179,123,2)
(187,171,2)
(89,186,2)
(180,123,2)
(128,148,2)
(258,146,2)
(191,55,2)
(244,148,2)
(140,123,2)
(165,186,2)
(56,185,2)
(157,186,2)
(95,123,2)
(211,6,2)
(107,123,2)
(99,153,2)
(191,186,2)
(106,37,2)
(85,114,2)
(262,86,2)
(96,233,2)
(207,192,2)
(121,123,2)
(197,13,2)
(144,180,2)
(228,186,2)
(82,211,2)
(88,123,2)
(142,222,2)
(104,249,2)
(32,248,2)
(225,123,2)
(181,123,2)
(4,114,2)
(242,148,2)
(34,25,2)
(14,145,2)
(118,242,2)
(244,237,2)
(106,237,2)
(72,123,2)
(2,13,2)
(35,186,2)
(125,171,2)
(113,37,2)
(249,227,2)
(58,237,2)
(64,123,2)
(117,233,2)
(211,123,2)
(111,146,2)
(258,186,2)
(128,233,2)
(185,186,2)
(111,148,2)
(134,192,2)
(169,114,2)
(239,237,2)
(116,233,2)
(222,36,2)
(37,37,2)
(125,58,2)
(185,171,2)
(49,186,2)
(156,118,2)
(82,123,2)
(123,186,2)
(251,123,2)
(23,171,2)
(244,146,2)
(138,186,2)
(126,120,2)
(70,145,2)
(112,185,2)
(192,13,2)
(241,13,2)
(253,123,2)
(81,186,2)
(124,233,2)
(10,186,2)
(147,123,2)
(256,72,2)
(229,146,2)
(42,3,2)
(47,29,2)
(150,186,2)
(233,258,2)
(24,259,2)
(199,82,2)
(198,233,2)
(193,145,2)
(125,187,2)
(39,123,2)
(172,37,2)
(137,186,2)
(166,123,2)
(118,145,2)
(25,237,2)
(177,123,2)
(44,186,2)
(221,155,2)
(207,146,2)
(156,145,2)
(6,40,2)
(101,207,2)
(129,123,2)
(261,55,2)
(35,37,2)
(157,57,2)
(114,244,2)
(221,153,2)
(145,85,2)
(99,123,2)
(45,123,2)
(111,237,2)
(242,146,2)
(136,123,2)
(145,37,2)
(155,123,2)
(44,37,2)
(63,13,2)
(238,186,2)
(183,123,2)
(222,237,2)
(167,233,2)
(13,153,2)
(242,145,2)
(21,192,2)
(127,145,2)
(120,101,2)
(244,37,2)
(53,83,2)
(73,229,2)
(227,153,2)
(143,123,2)
(156,125,2)
(105,123,2)
(74,259,2)
(73,224,2)
(153,42,2)
(152,13,2)
(209,114,2)
(245,8,2)
(185,187,2)
(6,123,2)
(156,142,2)
(78,145,2)
(91,186,2)
(173,145,2)
(176,186,2)
(235,123,2)
(222,145,2)
(187,123,2)
(37,112,2)
(173,57,2)
(185,37,2)
(86,146,2)
(180,177,2)
(256,123,2)
(31,186,2)
(0,192,2)
(29,123,2)
(128,146,2)
(19,233,2)
(79,233,2)
(246,145,2)
(148,199,2)
(111,145,2)
(85,34,2)
(119,1,2)
(248,224,2)
(93,148,2)
(108,180,2)
(34,146,2)
(161,37,2)
(49,148,2)
(141,1,2)
(16,123,2)
(80,123,2)
(261,120,2)
(152,259,2)
(200,224,2)
(15,123,2)
(170,180,2)
(34,148,2)
(37,185,2)
(84,233,2)
(27,57,2)
(191,153,2)
(220,248,2)
(220,55,2)
(41,224,2)
(51,186,2)
(217,123,2)
(124,57,2)
(23,191,2)
(133,195,2)
(24,146,2)
(66,180,2)
(135,123,2)
(196,123,2)
(142,145,2)
(99,177,2)
(230,37,2)
-----------------------------------
(0,i)
(1,char **buf)
(2,tmplen)
(3,unsigned int *buflen)
(4,i)
(5,buflen)
(6,session.xfer.p)
(7,tmpbuf)
(8,pr_log_level_exhausted_rsrc(PR_LOG_RSRC_MEM, 0)
(9,i)
(10,0)
(11,xfer)
(12,i)
(13,i < tmplen)
(14,lfcount--)
(15,xfer)
(16,copybuf)
(17,added)
(18,)
(19,1)
(20,i)
(21,tmpbuf)
(22,added)
(23,bufsize - tmplen - lfcount)
(24,tmpbuf[i])
(25,i-1)
(26,added)
(27,return added;)
(28,res)
(29,session.xfer)
(30,if (copybuf == NULL)
(31,buflen)
(32,lfcount)
(33,tmpbuf[0] = \'\\r\')
(34,tmpbuf[i-1])
(35,i)
(36,tmpbuf[i] = \'\\r\')
(37,i < bufsize && (lfcount > 0)
(38,0)
(39,bufsize)
(40,session.xfer)
(41,tmpbuf)
(42,*buflen)
(43,tmplen)
(44,bufsize)
(45,buf)
(46,tmpbuf)
(47,session.xfer.bufsize)
(48,lfcount)
(49,*buf = tmpbuf)
(50,tmpbuf)
(51,tmpbuf)
(52,NULL)
(53,session.xfer.buf)
(54,session.xfer)
(55,lfcount = 0)
(56,lfcount)
(57,added = 0)
(58,i - 1)
(59,(tmpbuf[tmplen-1] == \'\\r\')
(60,\'\\r\')
(61,res)
(62,lfcount)
(63,i)
(64,buf)
(65,copybuf)
(66,"Out of memory!")
(67,buf)
(68,1)
(69,res)
(70,\'\\r\')
(71,lfcount--)
(72,session.xfer.buf)
(73,tmpbuf[0] == \'\\n\')
(74,i-1)
(75,tmplen)
(76,copybuf)
(77,tmpbuf)
(78,lfcount)
(79,tmplen)
(80,free(copybuf)
(81,0)
(82,session.xfer.buf = pcalloc(session.xfer.p, session.xfer.bufsize)
(83,session.xfer)
(84,&(tmpbuf[0])
(85,tmpbuf[i-1] != \'\\r\')
(86,tmpbuf[1])
(87,tmpbuf)
(88,lfcount)
(89,0)
(90,tmpbuf)
(91,i)
(92,*buflen = tmplen + added)
(93,tmpbuf[0])
(94,tmplen)
(95,xfer)
(96,added)
(97,tmpbuf)
(98,0)
(99,memcpy(copybuf, tmpbuf, tmplen)
(100,FALSE)
(101,tmpbuf[i-1] != \'\\r\')
(102,\'\\n\')
(103,i = 0)
(104,tmpbuf[tmplen-1] == \'\\r\')
(105,xfer)
(106,i++)
(107,copybuf)
(108,0)
(109,i)
(110,tmpbuf)
(111,tmpbuf[i])
(112,lfcount > 0)
(113,tmpbuf)
(114,tmpbuf[i] == \'\\n\')
(115,)
(116,\'\\r\')
(117,0)
(118,&(tmpbuf[i+1])
(119,*buf)
(120,tmpbuf[i] == \'\\n\' && tmpbuf[i-1] != \'\\r\')
(121,malloc(tmplen)
(122,1)
(123,(res = (bufsize - tmplen - lfcount)
(124,added++)
(125,bufsize - i - 1)
(126,lfcount)
(127,i)
(128,tmpbuf[0])
(129,tmpbuf)
(130,buf)
(131,)
(132,return 0;)
(133,session.xfer.bufsize)
(134,1)
(135,p)
(136,session.xfer.bufsize)
(137,res = (bufsize - tmplen - lfcount)
(138,tmplen)
(139,session)
(140,session)
(141,*buf)
(142,&(tmpbuf[i])
(143,session)
(144,1)
(145,tmpbuf[i] == \'\\n\' && tmpbuf[i-1] != \'\\r\')
(146,*tmpbuf = *buf)
(147,session)
(148,tmpbuf = session.xfer.buf)
(149,1)
(150,added)
(151,xfer)
(152,i++)
(153,tmplen = *buflen)
(154,have_dangling_cr = (tmpbuf[tmplen-1] == \'\\r\')
(155,lfcount + 1)
(156,memmove(&(tmpbuf[i+1])
(157,tmplen + added)
(158,for (i = 1; i < tmplen; i++)
(159,if (!have_dangling_cr && tmpbuf[0] == \'\\n\')
(160,for (i = 1; i < bufsize && (lfcount > 0)
(161,i)
(162,bufsize)
(163,if ((res = (bufsize - tmplen - lfcount)
(164,tmpbuf)
(165,lfcount)
(166,xfer)
(167,memmove(&(tmpbuf[1])
(168,bufsize)
(169,\'\\r\')
(170,PR_LOG_RSRC_MEM)
(171,unsigned int bufsize)
(172,\'\\n\')
(173,added++)
(174,tmplen)
(175,NULL)
(176,*buflen)
(177,*copybuf = malloc(tmplen)
(178,0)
(179,tmplen)
(180,copybuf == NULL)
(181,bufsize)
(182,i)
(183,copybuf)
(184,lfcount)
(185,i < bufsize)
(186,lfcount == 0)
(187,bufsize = session.xfer.bufsize)
(188,1)
(189,)
(190,if (tmpbuf[0] == \'\\n\')
(191,tmplen - lfcount)
(192,tmpbuf[i] == \'\\n\')
(193,bufsize)
(194,0)
(195,session.xfer)
(196,session.xfer)
(197,\'\\n\')
(198,0)
(199,session.xfer.buf)
(200,\'\\n\')
(201,have_dangling_cr)
(202,added)
(203,session)
(204,copybuf = NULL)
(205,exit(1)
(206,tmpbuf)
(207,tmpbuf[i-1])
(208,1)
(209,1)
(210,tmplen)
(211,pcalloc(session.xfer.p, session.xfer.bufsize)
(212,i)
(213,0)
(214,res = 0)
(215,tmplen)
(216,if (tmpbuf[i] == \'\\n\' && tmpbuf[i-1] != \'\\r\')
(217,session.xfer)
(218,TRUE)
(219,lfcount)
(220,lfcount++)
(221,tmplen + lfcount + 1)
(222,tmpbuf[i])
(223,)
(224,!have_dangling_cr)
(225,session)
(226,if (lfcount == 0)
(227,tmplen-1)
(228,buf)
(229,tmpbuf[0])
(230,i)
(231,RET)
(232,bufsize)
(233,tmpbuf[0] == \'\\n\')
(234,session.xfer.bufsize = tmplen + lfcount + 1)
(235,copybuf)
(236,have_dangling_cr)
(237,i = 1)
(238,tmplen)
(239,i+1)
(240,i)
(241,i)
(242,tmpbuf[i+1])
(243,\'\\r\')
(244,tmpbuf[i])
(245,pr_log_pri(pr_log_level_exhausted_rsrc(PR_LOG_RSRC_MEM, 0)
(246,tmpbuf)
(247,0)
(248,!have_dangling_cr && tmpbuf[0] == \'\\n\')
(249,tmpbuf[tmplen-1])
(250,copybuf)
(251,xfer)
(252,)
(253,session)
(254,tmpbuf)
(255,0)
(256,memcpy(session.xfer.buf, copybuf, tmplen)
(257,1)
(258,tmpbuf[0])
(259,i = 1)
(260,tmpbuf)
(261,lfcount++)
(262,&(tmpbuf[1])
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^