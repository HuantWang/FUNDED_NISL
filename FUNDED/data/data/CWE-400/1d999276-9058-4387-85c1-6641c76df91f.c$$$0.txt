-----label-----
1
-----code-----
int peer_dispatch(DispatchFile *file) {
        Peer *peer = c_container_of(file, Peer, connection.socket_file);
        static const uint32_t interest[] = { EPOLLIN | EPOLLHUP, EPOLLOUT };
        size_t i;
        int r;

        /*
         * Usually, we would just call
         * peer_dispatch_connection(peer, dispatch_file_events(file)) here.
         * However, a very common scenario is to dispatch D-Bus driver calls.
         * Those calls fetch an incoming message from a peer, handle it and
         * then immediately queue a reply. In those cases we want EPOLLOUT
         * to be handled late. Hence, rather than dispatching the connection
         * in one go, we rather split it into two:
         *
         *     peer_dispatch_connection(peer, EPOLLIN | EPOLLHUP);
         *     peer_dispatch_connection(peer, EPOLLOUT);
         *
         * This makes sure to first handle all the incoming messages, then the
         * outgointg messages.
         *
         * Note that it is not enough to simply delay the call to
         * connection_dispatch(EPOLLOUT). The socket API requires you to loop
         * over connection_dequeue() after *ANY* call to the dispatcher. This
         * is, because the dequeue function is considered to be the event
         * handler, and as such the only function that performs forward
         * progress on the socket.
         *
         * Furthermore, note that we must not cache the events but rather query
         * dispatch_file_events(), since the connection handler might select or
         * deselect events we want to handle.
         *
         * Lastly, the connection API explicitly allows splitting the events.
         * There is no requirement to provide them in-order.
         */
        for (i = 0; i < C_ARRAY_SIZE(interest); ++i) {
                r = peer_dispatch_connection(peer, dispatch_file_events(file) & interest[i]);
                if (r)
                        break;
        }

        if (r) {
                if (r == PEER_E_EOF) {
                        metrics_sample_start(&peer->bus->metrics);
                        r = driver_goodbye(peer, false);
                        metrics_sample_end(&peer->bus->metrics);
                        if (r)
                                return error_fold(r);

                        connection_shutdown(&peer->connection);
                } else if (r == PEER_E_QUOTA ||
                           r == PEER_E_PROTOCOL_VIOLATION) {
                        NameSet peer_names = NAME_SET_INIT_FROM_OWNER(&peer->owned_names);

                        connection_close(&peer->connection);

                        log_append_here(peer->bus->log, LOG_WARNING, 0);
                        bus_log_append_sender(peer->bus, peer->id, &peer_names, peer->policy->seclabel);

                        switch (r) {
                        case PEER_E_QUOTA:
                                r = log_commitf(peer->bus->log, "Peer :1.%llu is being disconnected as it does not have the resources to perform an operation.",
                                                peer->id);
                                if (r)
                                        return error_fold(r);

                                break;
                        case PEER_E_PROTOCOL_VIOLATION:
                                r = log_commitf(peer->bus->log, "Peer :1.%llu is being disconnected as it violated the protocol.",
                                                peer->id);
                                if (r)
                                        return error_fold(r);

                                break;
                        default:
                                assert(0);
                        }

                        metrics_sample_start(&peer->bus->metrics);
                        r = driver_goodbye(peer, false);
                        metrics_sample_end(&peer->bus->metrics);
                        if (r)
                                return error_fold(r);
                } else {
                        return error_fold(r);
                }

                if (!connection_is_running(&peer->connection))
                        peer_free(peer);
        }

        /* Careful: @peer might be deallocated here */

        return 0;
}
-----children-----
1,2
1,3
1,4
3,4
3,5
5,6
5,7
6,7
8,9
8,10
11,12
11,13
11,14
11,15
11,16
11,17
11,18
12,13
13,14
13,15
14,15
16,17
16,18
16,19
19,20
20,21
20,22
20,23
20,24
21,22
23,24
25,26
27,28
27,29
28,29
31,32
32,33
32,34
33,34
35,36
35,37
35,38
38,39
39,40
39,41
40,41
40,42
41,42
43,44
45,46
47,48
48,49
48,50
49,50
51,52
53,54
54,55
54,56
56,57
58,59
58,60
58,61
58,62
59,60
60,61
60,62
61,62
64,65
64,66
65,66
67,68
67,69
68,69
70,71
72,73
73,74
75,76
75,77
76,77
77,78
77,79
78,79
80,81
80,82
80,83
81,82
83,84
85,86
85,87
86,87
86,88
87,88
89,90
91,92
91,93
92,93
94,95
96,97
96,98
97,98
100,101
100,102
101,102
103,104
103,105
104,105
104,106
104,107
105,106
105,107
106,107
108,109
110,111
110,112
110,113
110,114
110,115
111,112
112,113
112,114
113,114
115,116
116,117
116,118
117,118
117,119
118,119
122,123
123,124
123,125
124,125
126,127
126,128
126,129
127,128
129,130
132,133
133,134
133,135
134,135
136,137
137,138
137,139
138,139
138,140
139,140
143,144
143,145
144,145
146,147
147,148
147,149
148,149
150,151
152,153
153,154
153,155
154,155
156,157
157,158
157,159
158,159
161,162
161,163
161,164
162,163
162,164
163,164
163,165
164,165
166,167
168,169
168,170
169,170
171,172
173,174
173,175
173,176
173,177
173,178
173,179
173,180
173,181
173,182
174,175
175,176
175,177
176,177
178,179
178,180
180,181
181,182
181,183
182,183
184,185
185,186
185,187
186,187
189,190
190,191
190,192
191,192
193,194
194,195
194,196
195,196
198,199
199,200
199,201
199,202
199,203
200,201
202,203
202,204
203,204
203,205
204,205
208,209
211,212
212,213
212,214
212,215
212,216
212,217
213,214
215,216
215,217
216,217
219,220
219,221
220,221
223,224
224,225
226,227
226,228
227,228
227,229
228,229
232,233
232,234
233,234
235,236
235,237
235,238
235,239
235,240
235,241
235,242
235,243
235,244
235,245
236,237
237,238
239,240
240,241
240,242
241,242
243,244
243,245
243,246
243,247
244,245
246,247
246,248
247,248
247,249
248,249
253,254
253,255
254,255
257,258
257,259
258,259
260,261
261,262
261,263
262,263
264,265
267,268
268,269
270,271
271,272
271,273
272,273
274,275
274,276
274,277
274,278
275,276
277,278
277,279
278,279
278,280
279,280
284,285
284,286
285,286
288,289
288,290
289,290
291,292
292,293
292,294
293,294
295,296
299,300
300,301
300,302
301,302
304,305
305,306
305,307
306,307
308,309
309,310
309,311
310,311
310,312
311,312
315,316
316,317
316,318
317,318
319,320
319,321
319,322
320,321
322,323
325,326
326,327
326,328
327,328
329,330
330,331
330,332
331,332
331,333
332,333
336,337
336,338
337,338
339,340
340,341
340,342
341,342
343,344
345,346
346,347
347,348
347,349
348,349
350,351
352,353
352,354
353,354
354,355
354,356
355,356
357,358
358,359
358,360
359,360
362,363
363,364
363,365
364,365
366,367
368,369
-----nextToken-----
2,4,7,9,10,15,17,18,22,24,26,29,30,34,36,37,42,44,46,50,52,55,57,62,63,66,69,71,74,79,82,84,88,90,93,95,98,99,102,107,109,114,119,120,121,125,128,130,131,135,140,141,142,145,149,151,155,159,160,165,167,170,172,177,179,183,187,188,192,196,197,201,205,206,207,209,210,214,217,218,221,222,225,229,230,231,234,238,242,245,249,250,251,252,255,256,259,263,265,266,269,273,276,280,281,282,283,286,287,290,294,296,297,298,302,303,307,312,313,314,318,321,323,324,328,333,334,335,338,342,344,349,351,356,360,361,365,367,369
-----computeFrom-----
40,41
40,42
60,61
60,62
64,65
64,66
77,78
77,79
85,86
85,87
105,106
105,107
123,124
123,125
162,163
162,164
163,164
163,165
168,169
168,170
240,241
240,242
271,272
271,273
316,317
316,318
-----guardedBy-----
107,151
172,269
170,344
167,238
-----guardedByNegation-----
107,351
170,351
-----lastLexicalUse-----
107,351
170,351
-----jump-----
107,351
170,351
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;ArrayDeclarator;Name;ArrayModifier;EqualsInitializer;InitializerList;BinaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;BreakStatement;IfStatement;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IfStatement;IdExpression;Name;ReturnStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;SwitchStatement;IdExpression;Name;CompoundStatement;CaseStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;IfStatement;IdExpression;Name;ReturnStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;IfStatement;IdExpression;Name;ReturnStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BreakStatement;DefaultStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IfStatement;IdExpression;Name;ReturnStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ReturnStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;LiteralExpression;
-----ast_node-----
int peer_dispatch(DispatchFile *file) {        Peer *peer = c_container_of(file, Peer, connection.socket_file);        static const uint32_t interest[] = { EPOLLIN | EPOLLHUP, EPOLLOUT };        size_t i;        int r;        /*         * Usually, we would just call         * peer_dispatch_connection(peer, dispatch_file_events(file)) here.         * However, a very common scenario is to dispatch D-Bus driver calls.         * Those calls fetch an incoming message from a peer, handle it and         * then immediately queue a reply. In those cases we want EPOLLOUT         * to be handled late. Hence, rather than dispatching the connection         * in one go, we rather split it into two:         *         *     peer_dispatch_connection(peer, EPOLLIN | EPOLLHUP);         *     peer_dispatch_connection(peer, EPOLLOUT);         *         * This makes sure to first handle all the incoming messages, then the         * outgointg messages.         *         * Note that it is not enough to simply delay the call to         * connection_dispatch(EPOLLOUT). The socket API requires you to loop         * over connection_dequeue() after *ANY* call to the dispatcher. This         * is, because the dequeue function is considered to be the event         * handler, and as such the only function that performs forward         * progress on the socket.         *         * Furthermore, note that we must not cache the events but rather query         * dispatch_file_events(), since the connection handler might select or         * deselect events we want to handle.         *         * Lastly, the connection API explicitly allows splitting the events.         * There is no requirement to provide them in-order.         */        for (i = 0; i < C_ARRAY_SIZE(interest); ++i) {                r = peer_dispatch_connection(peer, dispatch_file_events(file) & interest[i]);                if (r)                        break;        }        if (r) {                if (r == PEER_E_EOF) {                        metrics_sample_start(&peer->bus->metrics);                        r = driver_goodbye(peer, false);                        metrics_sample_end(&peer->bus->metrics);                        if (r)                                return error_fold(r);                        connection_shutdown(&peer->connection);                } else if (r == PEER_E_QUOTA ||                           r == PEER_E_PROTOCOL_VIOLATION) {                        NameSet peer_names = NAME_SET_INIT_FROM_OWNER(&peer->owned_names);                        connection_close(&peer->connection);                        log_append_here(peer->bus->log, LOG_WARNING, 0);                        bus_log_append_sender(peer->bus, peer->id, &peer_names, peer->policy->seclabel);                        switch (r) {                        case PEER_E_QUOTA:                                r = log_commitf(peer->bus->log, "Peer :1.%llu is being disconnected as it does not have the resources to perform an operation.",                                                peer->id);                                if (r)                                        return error_fold(r);                                break;                        case PEER_E_PROTOCOL_VIOLATION:                                r = log_commitf(peer->bus->log, "Peer :1.%llu is being disconnected as it violated the protocol.",                                                peer->id);                                if (r)                                        return error_fold(r);                                break;                        default:                                assert(0);                        }                        metrics_sample_start(&peer->bus->metrics);                        r = driver_goodbye(peer, false);                        metrics_sample_end(&peer->bus->metrics);                        if (r)                                return error_fold(r);                } else {                        return error_fold(r);                }                if (!connection_is_running(&peer->connection))                        peer_free(peer);        }        /* Careful: @peer might be deallocated here */        return 0;}
int
peer_dispatch(DispatchFile *file)
peer_dispatch
DispatchFile *file
DispatchFile
DispatchFile
*file
*
file
{        Peer *peer = c_container_of(file, Peer, connection.socket_file);        static const uint32_t interest[] = { EPOLLIN | EPOLLHUP, EPOLLOUT };        size_t i;        int r;        /*         * Usually, we would just call         * peer_dispatch_connection(peer, dispatch_file_events(file)) here.         * However, a very common scenario is to dispatch D-Bus driver calls.         * Those calls fetch an incoming message from a peer, handle it and         * then immediately queue a reply. In those cases we want EPOLLOUT         * to be handled late. Hence, rather than dispatching the connection         * in one go, we rather split it into two:         *         *     peer_dispatch_connection(peer, EPOLLIN | EPOLLHUP);         *     peer_dispatch_connection(peer, EPOLLOUT);         *         * This makes sure to first handle all the incoming messages, then the         * outgointg messages.         *         * Note that it is not enough to simply delay the call to         * connection_dispatch(EPOLLOUT). The socket API requires you to loop         * over connection_dequeue() after *ANY* call to the dispatcher. This         * is, because the dequeue function is considered to be the event         * handler, and as such the only function that performs forward         * progress on the socket.         *         * Furthermore, note that we must not cache the events but rather query         * dispatch_file_events(), since the connection handler might select or         * deselect events we want to handle.         *         * Lastly, the connection API explicitly allows splitting the events.         * There is no requirement to provide them in-order.         */        for (i = 0; i < C_ARRAY_SIZE(interest); ++i) {                r = peer_dispatch_connection(peer, dispatch_file_events(file) & interest[i]);                if (r)                        break;        }        if (r) {                if (r == PEER_E_EOF) {                        metrics_sample_start(&peer->bus->metrics);                        r = driver_goodbye(peer, false);                        metrics_sample_end(&peer->bus->metrics);                        if (r)                                return error_fold(r);                        connection_shutdown(&peer->connection);                } else if (r == PEER_E_QUOTA ||                           r == PEER_E_PROTOCOL_VIOLATION) {                        NameSet peer_names = NAME_SET_INIT_FROM_OWNER(&peer->owned_names);                        connection_close(&peer->connection);                        log_append_here(peer->bus->log, LOG_WARNING, 0);                        bus_log_append_sender(peer->bus, peer->id, &peer_names, peer->policy->seclabel);                        switch (r) {                        case PEER_E_QUOTA:                                r = log_commitf(peer->bus->log, "Peer :1.%llu is being disconnected as it does not have the resources to perform an operation.",                                                peer->id);                                if (r)                                        return error_fold(r);                                break;                        case PEER_E_PROTOCOL_VIOLATION:                                r = log_commitf(peer->bus->log, "Peer :1.%llu is being disconnected as it violated the protocol.",                                                peer->id);                                if (r)                                        return error_fold(r);                                break;                        default:                                assert(0);                        }                        metrics_sample_start(&peer->bus->metrics);                        r = driver_goodbye(peer, false);                        metrics_sample_end(&peer->bus->metrics);                        if (r)                                return error_fold(r);                } else {                        return error_fold(r);                }                if (!connection_is_running(&peer->connection))                        peer_free(peer);        }        /* Careful: @peer might be deallocated here */        return 0;}
Peer *peer = c_container_of(file, Peer, connection.socket_file);
Peer *peer = c_container_of(file, Peer, connection.socket_file);
Peer
Peer
*peer = c_container_of(file, Peer, connection.socket_file)
*
peer
= c_container_of(file, Peer, connection.socket_file)
c_container_of(file, Peer, connection.socket_file)
c_container_of
c_container_of
file
file
Peer
Peer
connection.socket_file
connection
connection
socket_file
static const uint32_t interest[] = { EPOLLIN | EPOLLHUP, EPOLLOUT };
static const uint32_t interest[] = { EPOLLIN | EPOLLHUP, EPOLLOUT };
static const uint32_t
uint32_t
interest[] = { EPOLLIN | EPOLLHUP, EPOLLOUT }
interest
[]
= { EPOLLIN | EPOLLHUP, EPOLLOUT }
{ EPOLLIN | EPOLLHUP, EPOLLOUT }
EPOLLIN | EPOLLHUP
EPOLLIN
EPOLLIN
EPOLLHUP
EPOLLHUP
EPOLLOUT
EPOLLOUT
size_t i;
size_t i;
size_t
size_t
i
i
int r;
int r;
int
r
r
for (i = 0; i < C_ARRAY_SIZE(interest); ++i) {                r = peer_dispatch_connection(peer, dispatch_file_events(file) & interest[i]);                if (r)                        break;        }
i = 0;
i = 0
i
i
0
i < C_ARRAY_SIZE(interest)
i
i
C_ARRAY_SIZE(interest)
C_ARRAY_SIZE
C_ARRAY_SIZE
interest
interest
++i
i
i
{                r = peer_dispatch_connection(peer, dispatch_file_events(file) & interest[i]);                if (r)                        break;        }
r = peer_dispatch_connection(peer, dispatch_file_events(file) & interest[i]);
r = peer_dispatch_connection(peer, dispatch_file_events(file) & interest[i])
r
r
peer_dispatch_connection(peer, dispatch_file_events(file) & interest[i])
peer_dispatch_connection
peer_dispatch_connection
peer
peer
dispatch_file_events(file) & interest[i]
dispatch_file_events(file)
dispatch_file_events
dispatch_file_events
file
file
interest[i]
interest
interest
i
i
if (r)                        break;
r
r
break;
if (r) {                if (r == PEER_E_EOF) {                        metrics_sample_start(&peer->bus->metrics);                        r = driver_goodbye(peer, false);                        metrics_sample_end(&peer->bus->metrics);                        if (r)                                return error_fold(r);                        connection_shutdown(&peer->connection);                } else if (r == PEER_E_QUOTA ||                           r == PEER_E_PROTOCOL_VIOLATION) {                        NameSet peer_names = NAME_SET_INIT_FROM_OWNER(&peer->owned_names);                        connection_close(&peer->connection);                        log_append_here(peer->bus->log, LOG_WARNING, 0);                        bus_log_append_sender(peer->bus, peer->id, &peer_names, peer->policy->seclabel);                        switch (r) {                        case PEER_E_QUOTA:                                r = log_commitf(peer->bus->log, "Peer :1.%llu is being disconnected as it does not have the resources to perform an operation.",                                                peer->id);                                if (r)                                        return error_fold(r);                                break;                        case PEER_E_PROTOCOL_VIOLATION:                                r = log_commitf(peer->bus->log, "Peer :1.%llu is being disconnected as it violated the protocol.",                                                peer->id);                                if (r)                                        return error_fold(r);                                break;                        default:                                assert(0);                        }                        metrics_sample_start(&peer->bus->metrics);                        r = driver_goodbye(peer, false);                        metrics_sample_end(&peer->bus->metrics);                        if (r)                                return error_fold(r);                } else {                        return error_fold(r);                }                if (!connection_is_running(&peer->connection))                        peer_free(peer);        }
r
r
{                if (r == PEER_E_EOF) {                        metrics_sample_start(&peer->bus->metrics);                        r = driver_goodbye(peer, false);                        metrics_sample_end(&peer->bus->metrics);                        if (r)                                return error_fold(r);                        connection_shutdown(&peer->connection);                } else if (r == PEER_E_QUOTA ||                           r == PEER_E_PROTOCOL_VIOLATION) {                        NameSet peer_names = NAME_SET_INIT_FROM_OWNER(&peer->owned_names);                        connection_close(&peer->connection);                        log_append_here(peer->bus->log, LOG_WARNING, 0);                        bus_log_append_sender(peer->bus, peer->id, &peer_names, peer->policy->seclabel);                        switch (r) {                        case PEER_E_QUOTA:                                r = log_commitf(peer->bus->log, "Peer :1.%llu is being disconnected as it does not have the resources to perform an operation.",                                                peer->id);                                if (r)                                        return error_fold(r);                                break;                        case PEER_E_PROTOCOL_VIOLATION:                                r = log_commitf(peer->bus->log, "Peer :1.%llu is being disconnected as it violated the protocol.",                                                peer->id);                                if (r)                                        return error_fold(r);                                break;                        default:                                assert(0);                        }                        metrics_sample_start(&peer->bus->metrics);                        r = driver_goodbye(peer, false);                        metrics_sample_end(&peer->bus->metrics);                        if (r)                                return error_fold(r);                } else {                        return error_fold(r);                }                if (!connection_is_running(&peer->connection))                        peer_free(peer);        }
if (r == PEER_E_EOF) {                        metrics_sample_start(&peer->bus->metrics);                        r = driver_goodbye(peer, false);                        metrics_sample_end(&peer->bus->metrics);                        if (r)                                return error_fold(r);                        connection_shutdown(&peer->connection);                } else if (r == PEER_E_QUOTA ||                           r == PEER_E_PROTOCOL_VIOLATION) {                        NameSet peer_names = NAME_SET_INIT_FROM_OWNER(&peer->owned_names);                        connection_close(&peer->connection);                        log_append_here(peer->bus->log, LOG_WARNING, 0);                        bus_log_append_sender(peer->bus, peer->id, &peer_names, peer->policy->seclabel);                        switch (r) {                        case PEER_E_QUOTA:                                r = log_commitf(peer->bus->log, "Peer :1.%llu is being disconnected as it does not have the resources to perform an operation.",                                                peer->id);                                if (r)                                        return error_fold(r);                                break;                        case PEER_E_PROTOCOL_VIOLATION:                                r = log_commitf(peer->bus->log, "Peer :1.%llu is being disconnected as it violated the protocol.",                                                peer->id);                                if (r)                                        return error_fold(r);                                break;                        default:                                assert(0);                        }                        metrics_sample_start(&peer->bus->metrics);                        r = driver_goodbye(peer, false);                        metrics_sample_end(&peer->bus->metrics);                        if (r)                                return error_fold(r);                } else {                        return error_fold(r);                }
r == PEER_E_EOF
r
r
PEER_E_EOF
PEER_E_EOF
{                        metrics_sample_start(&peer->bus->metrics);                        r = driver_goodbye(peer, false);                        metrics_sample_end(&peer->bus->metrics);                        if (r)                                return error_fold(r);                        connection_shutdown(&peer->connection);                }
metrics_sample_start(&peer->bus->metrics);
metrics_sample_start(&peer->bus->metrics)
metrics_sample_start
metrics_sample_start
&peer->bus->metrics
peer->bus->metrics
peer->bus
peer
peer
bus
metrics
r = driver_goodbye(peer, false);
r = driver_goodbye(peer, false)
r
r
driver_goodbye(peer, false)
driver_goodbye
driver_goodbye
peer
peer
false
metrics_sample_end(&peer->bus->metrics);
metrics_sample_end(&peer->bus->metrics)
metrics_sample_end
metrics_sample_end
&peer->bus->metrics
peer->bus->metrics
peer->bus
peer
peer
bus
metrics
if (r)                                return error_fold(r);
r
r
return error_fold(r);
error_fold(r)
error_fold
error_fold
r
r
connection_shutdown(&peer->connection);
connection_shutdown(&peer->connection)
connection_shutdown
connection_shutdown
&peer->connection
peer->connection
peer
peer
connection
if (r == PEER_E_QUOTA ||                           r == PEER_E_PROTOCOL_VIOLATION) {                        NameSet peer_names = NAME_SET_INIT_FROM_OWNER(&peer->owned_names);                        connection_close(&peer->connection);                        log_append_here(peer->bus->log, LOG_WARNING, 0);                        bus_log_append_sender(peer->bus, peer->id, &peer_names, peer->policy->seclabel);                        switch (r) {                        case PEER_E_QUOTA:                                r = log_commitf(peer->bus->log, "Peer :1.%llu is being disconnected as it does not have the resources to perform an operation.",                                                peer->id);                                if (r)                                        return error_fold(r);                                break;                        case PEER_E_PROTOCOL_VIOLATION:                                r = log_commitf(peer->bus->log, "Peer :1.%llu is being disconnected as it violated the protocol.",                                                peer->id);                                if (r)                                        return error_fold(r);                                break;                        default:                                assert(0);                        }                        metrics_sample_start(&peer->bus->metrics);                        r = driver_goodbye(peer, false);                        metrics_sample_end(&peer->bus->metrics);                        if (r)                                return error_fold(r);                } else {                        return error_fold(r);                }
r == PEER_E_QUOTA ||                           r == PEER_E_PROTOCOL_VIOLATION
r == PEER_E_QUOTA
r
r
PEER_E_QUOTA
PEER_E_QUOTA
r == PEER_E_PROTOCOL_VIOLATION
r
r
PEER_E_PROTOCOL_VIOLATION
PEER_E_PROTOCOL_VIOLATION
{                        NameSet peer_names = NAME_SET_INIT_FROM_OWNER(&peer->owned_names);                        connection_close(&peer->connection);                        log_append_here(peer->bus->log, LOG_WARNING, 0);                        bus_log_append_sender(peer->bus, peer->id, &peer_names, peer->policy->seclabel);                        switch (r) {                        case PEER_E_QUOTA:                                r = log_commitf(peer->bus->log, "Peer :1.%llu is being disconnected as it does not have the resources to perform an operation.",                                                peer->id);                                if (r)                                        return error_fold(r);                                break;                        case PEER_E_PROTOCOL_VIOLATION:                                r = log_commitf(peer->bus->log, "Peer :1.%llu is being disconnected as it violated the protocol.",                                                peer->id);                                if (r)                                        return error_fold(r);                                break;                        default:                                assert(0);                        }                        metrics_sample_start(&peer->bus->metrics);                        r = driver_goodbye(peer, false);                        metrics_sample_end(&peer->bus->metrics);                        if (r)                                return error_fold(r);                }
NameSet peer_names = NAME_SET_INIT_FROM_OWNER(&peer->owned_names);
NameSet peer_names = NAME_SET_INIT_FROM_OWNER(&peer->owned_names);
NameSet
NameSet
peer_names = NAME_SET_INIT_FROM_OWNER(&peer->owned_names)
peer_names
= NAME_SET_INIT_FROM_OWNER(&peer->owned_names)
NAME_SET_INIT_FROM_OWNER(&peer->owned_names)
NAME_SET_INIT_FROM_OWNER
NAME_SET_INIT_FROM_OWNER
&peer->owned_names
peer->owned_names
peer
peer
owned_names
connection_close(&peer->connection);
connection_close(&peer->connection)
connection_close
connection_close
&peer->connection
peer->connection
peer
peer
connection
log_append_here(peer->bus->log, LOG_WARNING, 0);
log_append_here(peer->bus->log, LOG_WARNING, 0)
log_append_here
log_append_here
peer->bus->log
peer->bus
peer
peer
bus
log
LOG_WARNING
LOG_WARNING
0
bus_log_append_sender(peer->bus, peer->id, &peer_names, peer->policy->seclabel);
bus_log_append_sender(peer->bus, peer->id, &peer_names, peer->policy->seclabel)
bus_log_append_sender
bus_log_append_sender
peer->bus
peer
peer
bus
peer->id
peer
peer
id
&peer_names
peer_names
peer_names
peer->policy->seclabel
peer->policy
peer
peer
policy
seclabel
switch (r) {                        case PEER_E_QUOTA:                                r = log_commitf(peer->bus->log, "Peer :1.%llu is being disconnected as it does not have the resources to perform an operation.",                                                peer->id);                                if (r)                                        return error_fold(r);                                break;                        case PEER_E_PROTOCOL_VIOLATION:                                r = log_commitf(peer->bus->log, "Peer :1.%llu is being disconnected as it violated the protocol.",                                                peer->id);                                if (r)                                        return error_fold(r);                                break;                        default:                                assert(0);                        }
r
r
{                        case PEER_E_QUOTA:                                r = log_commitf(peer->bus->log, "Peer :1.%llu is being disconnected as it does not have the resources to perform an operation.",                                                peer->id);                                if (r)                                        return error_fold(r);                                break;                        case PEER_E_PROTOCOL_VIOLATION:                                r = log_commitf(peer->bus->log, "Peer :1.%llu is being disconnected as it violated the protocol.",                                                peer->id);                                if (r)                                        return error_fold(r);                                break;                        default:                                assert(0);                        }
case PEER_E_QUOTA:
PEER_E_QUOTA
PEER_E_QUOTA
r = log_commitf(peer->bus->log, "Peer :1.%llu is being disconnected as it does not have the resources to perform an operation.",                                                peer->id);
r = log_commitf(peer->bus->log, "Peer :1.%llu is being disconnected as it does not have the resources to perform an operation.",                                                peer->id)
r
r
log_commitf(peer->bus->log, "Peer :1.%llu is being disconnected as it does not have the resources to perform an operation.",                                                peer->id)
log_commitf
log_commitf
peer->bus->log
peer->bus
peer
peer
bus
log
"Peer :1.%llu is being disconnected as it does not have the resources to perform an operation."
peer->id
peer
peer
id
if (r)                                        return error_fold(r);
r
r
return error_fold(r);
error_fold(r)
error_fold
error_fold
r
r
break;
case PEER_E_PROTOCOL_VIOLATION:
PEER_E_PROTOCOL_VIOLATION
PEER_E_PROTOCOL_VIOLATION
r = log_commitf(peer->bus->log, "Peer :1.%llu is being disconnected as it violated the protocol.",                                                peer->id);
r = log_commitf(peer->bus->log, "Peer :1.%llu is being disconnected as it violated the protocol.",                                                peer->id)
r
r
log_commitf(peer->bus->log, "Peer :1.%llu is being disconnected as it violated the protocol.",                                                peer->id)
log_commitf
log_commitf
peer->bus->log
peer->bus
peer
peer
bus
log
"Peer :1.%llu is being disconnected as it violated the protocol."
peer->id
peer
peer
id
if (r)                                        return error_fold(r);
r
r
return error_fold(r);
error_fold(r)
error_fold
error_fold
r
r
break;
default:
assert(0);
assert(0)
assert
assert
0
metrics_sample_start(&peer->bus->metrics);
metrics_sample_start(&peer->bus->metrics)
metrics_sample_start
metrics_sample_start
&peer->bus->metrics
peer->bus->metrics
peer->bus
peer
peer
bus
metrics
r = driver_goodbye(peer, false);
r = driver_goodbye(peer, false)
r
r
driver_goodbye(peer, false)
driver_goodbye
driver_goodbye
peer
peer
false
metrics_sample_end(&peer->bus->metrics);
metrics_sample_end(&peer->bus->metrics)
metrics_sample_end
metrics_sample_end
&peer->bus->metrics
peer->bus->metrics
peer->bus
peer
peer
bus
metrics
if (r)                                return error_fold(r);
r
r
return error_fold(r);
error_fold(r)
error_fold
error_fold
r
r
{                        return error_fold(r);                }
return error_fold(r);
error_fold(r)
error_fold
error_fold
r
r
if (!connection_is_running(&peer->connection))                        peer_free(peer);
!connection_is_running(&peer->connection)
connection_is_running(&peer->connection)
connection_is_running
connection_is_running
&peer->connection
peer->connection
peer
peer
connection
peer_free(peer);
peer_free(peer)
peer_free
peer_free
peer
peer
return 0;
0
-----joern-----
(135,55,0)
(108,47,0)
(70,124,0)
(16,198,0)
(95,122,0)
(62,101,0)
(32,160,0)
(12,137,0)
(125,75,0)
(161,50,0)
(148,179,0)
(89,62,0)
(7,44,0)
(56,119,0)
(109,141,0)
(202,83,0)
(2,26,0)
(58,44,0)
(8,109,0)
(150,87,0)
(68,100,0)
(87,149,0)
(75,169,0)
(189,101,0)
(60,174,0)
(110,44,0)
(48,31,0)
(67,13,0)
(34,151,0)
(200,101,0)
(141,109,0)
(6,75,0)
(22,89,0)
(159,50,0)
(166,101,0)
(118,109,0)
(194,179,0)
(56,170,0)
(40,160,0)
(38,85,0)
(195,47,0)
(93,52,0)
(70,101,0)
(155,26,0)
(124,42,0)
(128,149,0)
(101,81,0)
(31,124,0)
(98,101,0)
(26,159,0)
(124,70,0)
(43,85,0)
(9,44,0)
(145,124,0)
(32,101,0)
(80,31,0)
(138,23,0)
(120,143,0)
(162,143,0)
(129,89,0)
(97,62,0)
(100,58,0)
(129,50,0)
(39,166,0)
(41,50,0)
(29,182,0)
(173,70,0)
(35,46,0)
(154,75,0)
(100,3,0)
(2,101,0)
(72,107,0)
(173,128,0)
(104,201,0)
(15,55,0)
(135,169,0)
(134,101,0)
(183,53,0)
(182,165,0)
(47,124,0)
(76,6,0)
(37,171,0)
(30,129,0)
(121,101,0)
(25,44,0)
(71,3,0)
(193,125,0)
(102,131,0)
(127,190,0)
(98,165,0)
(79,16,0)
(151,103,0)
(35,159,0)
(111,126,0)
(52,93,0)
(23,138,0)
(55,15,0)
(134,75,0)
(105,200,0)
(190,116,0)
(75,134,0)
(140,128,0)
(52,180,0)
(89,129,0)
(54,58,0)
(3,149,0)
(81,24,0)
(164,47,0)
(56,198,0)
(20,158,0)
(10,81,0)
(180,189,0)
(0,50,0)
(160,40,0)
(83,202,0)
(196,50,0)
(148,202,0)
(107,103,0)
(186,74,0)
(193,101,0)
(153,169,0)
(172,39,0)
(47,195,0)
(201,124,0)
(189,180,0)
(84,144,0)
(174,101,0)
(125,193,0)
(1,98,0)
(133,13,0)
(65,63,0)
(56,73,0)
(101,44,0)
(122,195,0)
(81,13,0)
(28,116,0)
(188,38,0)
(203,28,0)
(75,125,0)
(85,101,0)
(74,170,0)
(138,63,0)
(174,137,0)
(56,131,0)
(33,50,0)
(22,171,0)
(103,151,0)
(11,28,0)
(14,128,0)
(91,169,0)
(26,2,0)
(187,165,0)
(123,91,0)
(28,101,0)
(147,70,0)
(195,122,0)
(56,46,0)
(94,103,0)
(137,174,0)
(55,135,0)
(151,101,0)
(175,151,0)
(83,63,0)
(171,22,0)
(49,169,0)
(115,89,0)
(141,91,0)
(5,127,0)
(112,50,0)
(128,58,0)
(171,101,0)
(88,169,0)
(91,141,0)
(4,134,0)
(142,189,0)
(64,193,0)
(146,154,0)
(103,169,0)
(27,149,0)
(15,143,0)
(178,141,0)
(78,159,0)
(85,38,0)
(113,158,0)
(157,50,0)
(126,111,0)
(77,2,0)
(122,124,0)
(19,22,0)
(3,100,0)
(23,111,0)
(66,193,0)
(130,35,0)
(116,28,0)
(165,182,0)
(81,101,0)
(89,22,0)
(18,111,0)
(165,98,0)
(173,144,0)
(154,127,0)
(144,173,0)
(139,166,0)
(53,50,0)
(197,81,0)
(163,32,0)
(26,38,0)
(107,119,0)
(166,39,0)
(179,101,0)
(86,44,0)
(90,2,0)
(12,63,0)
(202,148,0)
(143,15,0)
(126,101,0)
(176,126,0)
(109,101,0)
(182,29,0)
(39,63,0)
(185,126,0)
(69,174,0)
(144,24,0)
(143,101,0)
(40,169,0)
(59,189,0)
(13,81,0)
(96,166,0)
(45,171,0)
(75,6,0)
(29,169,0)
(156,122,0)
(190,127,0)
(131,44,0)
(62,89,0)
(201,73,0)
(127,169,0)
(114,85,0)
(106,98,0)
(6,101,0)
(177,42,0)
(74,129,0)
(111,23,0)
(191,148,0)
(82,62,0)
(116,190,0)
(184,32,0)
(128,173,0)
(137,12,0)
(152,15,0)
(38,26,0)
(36,179,0)
(180,52,0)
(16,39,0)
(199,44,0)
(75,154,0)
(73,132,0)
(159,26,0)
(179,148,0)
(160,32,0)
(70,173,0)
(57,149,0)
(136,91,0)
(117,125,0)
(21,134,0)
(61,6,0)
(31,124,1)
(191,179,1)
(115,22,1)
(193,101,1)
(1,33,1)
(131,102,1)
(155,38,1)
(2,77,1)
(28,101,1)
(3,100,1)
(134,21,1)
(52,180,1)
(165,187,1)
(179,101,1)
(182,165,1)
(160,32,1)
(128,58,1)
(122,124,1)
(156,95,1)
(40,160,1)
(46,35,1)
(16,39,1)
(61,76,1)
(144,24,1)
(38,85,1)
(203,5,1)
(6,101,1)
(102,200,1)
(126,101,1)
(82,115,1)
(4,6,1)
(107,72,1)
(75,125,1)
(111,126,1)
(92,99,1)
(152,143,1)
(149,27,1)
(79,181,1)
(47,108,1)
(67,133,1)
(33,168,1)
(107,103,1)
(120,103,1)
(166,101,1)
(27,57,1)
(72,17,1)
(13,67,1)
(10,121,1)
(168,159,1)
(176,185,1)
(38,188,1)
(148,191,1)
(200,105,1)
(1,53,1)
(48,92,1)
(31,80,1)
(62,101,1)
(166,139,1)
(15,143,1)
(124,70,1)
(16,79,1)
(69,181,1)
(165,98,1)
(195,47,1)
(125,193,1)
(83,202,1)
(146,134,1)
(183,51,1)
(22,19,1)
(56,198,1)
(64,154,1)
(99,167,1)
(133,197,1)
(58,54,1)
(135,55,1)
(59,17,1)
(159,26,1)
(102,92,1)
(23,111,1)
(193,66,1)
(5,195,1)
(108,164,1)
(51,75,1)
(18,126,1)
(174,101,1)
(148,179,1)
(57,58,1)
(45,37,1)
(14,140,1)
(71,87,1)
(6,61,1)
(106,1,1)
(171,45,1)
(200,101,1)
(122,156,1)
(56,119,1)
(54,101,1)
(127,190,1)
(188,85,1)
(91,141,1)
(198,16,1)
(162,120,1)
(189,142,1)
(26,38,1)
(97,82,1)
(170,74,1)
(100,68,1)
(68,71,1)
(100,58,1)
(32,184,1)
(84,147,1)
(175,34,1)
(2,101,1)
(187,98,1)
(11,203,1)
(103,151,1)
(70,101,1)
(180,189,1)
(178,109,1)
(102,93,1)
(85,114,1)
(39,166,1)
(104,195,1)
(173,128,1)
(116,28,1)
(184,163,1)
(47,124,1)
(60,69,1)
(151,175,1)
(201,124,1)
(167,124,1)
(189,101,1)
(75,154,1)
(181,83,1)
(75,6,1)
(32,101,1)
(56,73,1)
(89,62,1)
(123,136,1)
(202,148,1)
(142,59,1)
(90,155,1)
(37,30,1)
(130,168,1)
(173,144,1)
(144,84,1)
(98,101,1)
(125,117,1)
(154,127,1)
(119,107,1)
(17,135,1)
(140,144,1)
(134,101,1)
(129,89,1)
(136,141,1)
(141,109,1)
(151,101,1)
(80,48,1)
(56,170,1)
(87,150,1)
(143,162,1)
(78,51,1)
(105,93,1)
(114,43,1)
(93,52,1)
(89,22,1)
(74,186,1)
(81,24,1)
(85,101,1)
(186,192,1)
(128,149,1)
(35,159,1)
(138,23,1)
(174,60,1)
(101,81,1)
(154,146,1)
(66,64,1)
(171,101,1)
(53,183,1)
(137,174,1)
(56,46,1)
(8,118,1)
(98,106,1)
(96,172,1)
(43,78,1)
(143,101,1)
(81,13,1)
(91,123,1)
(111,18,1)
(139,96,1)
(147,145,1)
(94,29,1)
(195,122,1)
(87,149,1)
(70,173,1)
(12,137,1)
(145,3,1)
(197,10,1)
(56,131,1)
(34,94,1)
(1,41,1)
(163,127,1)
(164,31,1)
(19,171,1)
(117,193,1)
(71,149,1)
(109,101,1)
(128,14,1)
(192,129,1)
(22,171,1)
(76,91,1)
(35,130,1)
(36,39,1)
(26,2,1)
(92,3,1)
(75,134,1)
(62,97,1)
(194,36,1)
(109,8,1)
(55,15,1)
(172,138,1)
(179,194,1)
(95,47,1)
(29,182,1)
(190,116,1)
(59,12,1)
(118,40,1)
(141,178,1)
(73,201,1)
(28,11,1)
(3,149,1)
(126,176,1)
(15,152,1)
(201,104,1)
(30,51,1)
(41,192,1)
(74,129,1)
(21,4,1)
(150,167,1)
(185,31,1)
(77,90,1)
(64,195,2)
(114,51,2)
(111,126,2)
(83,31,2)
(38,51,2)
(108,31,2)
(26,51,2)
(34,192,2)
(173,128,2)
(183,51,2)
(138,31,2)
(120,168,2)
(16,181,2)
(193,101,2)
(102,181,2)
(28,195,2)
(173,3,2)
(128,3,2)
(163,195,2)
(120,192,2)
(187,168,2)
(103,151,2)
(202,31,2)
(122,47,2)
(200,93,2)
(90,51,2)
(125,195,2)
(75,125,2)
(180,17,2)
(35,159,2)
(70,101,2)
(115,51,2)
(74,192,2)
(56,119,2)
(62,101,2)
(129,51,2)
(101,81,2)
(47,31,2)
(39,166,2)
(6,195,2)
(192,51,2)
(1,51,2)
(134,101,2)
(143,101,2)
(135,51,2)
(142,17,2)
(160,32,2)
(93,181,2)
(165,192,2)
(14,3,2)
(31,124,2)
(152,51,2)
(74,129,2)
(116,28,2)
(148,31,2)
(40,195,2)
(162,168,2)
(102,17,2)
(53,51,2)
(81,24,2)
(135,168,2)
(128,58,2)
(70,3,2)
(56,170,2)
(182,51,2)
(3,100,2)
(56,73,2)
(190,116,2)
(21,195,2)
(182,192,2)
(48,92,2)
(170,192,2)
(105,93,2)
(91,195,2)
(34,168,2)
(162,51,2)
(200,101,2)
(179,31,2)
(107,103,2)
(156,47,2)
(87,167,2)
(125,193,2)
(184,195,2)
(144,24,2)
(194,31,2)
(81,13,2)
(174,181,2)
(23,111,2)
(151,51,2)
(89,62,2)
(103,192,2)
(195,122,2)
(43,51,2)
(17,51,2)
(175,168,2)
(96,31,2)
(186,192,2)
(124,70,2)
(38,85,2)
(159,51,2)
(117,195,2)
(29,51,2)
(167,3,2)
(46,168,2)
(201,124,2)
(4,195,2)
(128,149,2)
(52,17,2)
(15,168,2)
(109,195,2)
(22,51,2)
(165,98,2)
(165,51,2)
(162,192,2)
(98,168,2)
(106,51,2)
(75,195,2)
(94,168,2)
(127,190,2)
(51,195,2)
(151,192,2)
(198,181,2)
(103,51,2)
(165,168,2)
(26,38,2)
(55,192,2)
(131,181,2)
(29,168,2)
(142,181,2)
(22,171,2)
(80,92,2)
(137,181,2)
(37,51,2)
(75,154,2)
(26,2,2)
(137,174,2)
(11,195,2)
(118,195,2)
(55,15,2)
(3,167,2)
(143,51,2)
(15,192,2)
(154,127,2)
(99,167,2)
(59,17,2)
(123,195,2)
(55,51,2)
(171,101,2)
(175,51,2)
(85,51,2)
(182,168,2)
(134,195,2)
(131,17,2)
(19,51,2)
(98,192,2)
(41,192,2)
(2,51,2)
(191,31,2)
(203,195,2)
(160,195,2)
(195,47,2)
(148,179,2)
(12,181,2)
(171,51,2)
(174,101,2)
(39,31,2)
(30,51,2)
(195,31,2)
(15,51,2)
(84,3,2)
(120,51,2)
(193,195,2)
(166,101,2)
(168,51,2)
(77,51,2)
(78,51,2)
(79,181,2)
(45,51,2)
(69,181,2)
(201,195,2)
(143,168,2)
(83,202,2)
(140,3,2)
(56,198,2)
(103,168,2)
(146,195,2)
(187,51,2)
(155,51,2)
(152,192,2)
(75,6,2)
(56,46,2)
(145,3,2)
(181,31,2)
(189,101,2)
(66,195,2)
(28,101,2)
(129,89,2)
(106,168,2)
(75,134,2)
(185,31,2)
(93,17,2)
(61,195,2)
(32,101,2)
(29,192,2)
(36,31,2)
(2,101,2)
(180,189,2)
(16,39,2)
(100,58,2)
(131,92,2)
(135,55,2)
(32,195,2)
(82,51,2)
(189,181,2)
(97,51,2)
(1,192,2)
(176,31,2)
(182,165,2)
(189,17,2)
(188,51,2)
(55,168,2)
(62,51,2)
(94,51,2)
(98,51,2)
(70,173,2)
(35,168,2)
(87,149,2)
(138,23,2)
(1,168,2)
(104,195,2)
(127,195,2)
(178,195,2)
(172,31,2)
(56,131,2)
(126,31,2)
(15,143,2)
(159,26,2)
(143,192,2)
(68,167,2)
(135,192,2)
(72,17,2)
(144,3,2)
(60,181,2)
(116,195,2)
(12,137,2)
(106,192,2)
(102,92,2)
(173,144,2)
(164,31,2)
(119,17,2)
(100,167,2)
(202,148,2)
(17,168,2)
(94,192,2)
(126,101,2)
(17,192,2)
(130,168,2)
(179,101,2)
(154,195,2)
(59,181,2)
(34,51,2)
(152,168,2)
(76,195,2)
(139,31,2)
(109,101,2)
(141,195,2)
(73,195,2)
(89,22,2)
(95,47,2)
(190,195,2)
(147,3,2)
(98,101,2)
(52,180,2)
(91,141,2)
(47,124,2)
(8,195,2)
(18,31,2)
(5,195,2)
(23,31,2)
(93,52,2)
(52,181,2)
(166,31,2)
(107,17,2)
(150,167,2)
(6,101,2)
(141,109,2)
(33,168,2)
(29,182,2)
(31,92,2)
(85,101,2)
(3,149,2)
(89,51,2)
(187,192,2)
(151,101,2)
(71,167,2)
(40,160,2)
(136,195,2)
(180,181,2)
(122,124,2)
(111,31,2)
(124,3,2)
(151,168,2)
(175,192,2)
-----------------------------------
(0,case PEER_E_QUOTA:)
(1,peer)
(2,peer->id)
(3,i < C_ARRAY_SIZE(interest)
(4,peer)
(5,peer_names)
(6,peer->bus)
(7,interest)
(8,bus)
(9,r)
(10,file)
(11,owned_names)
(12,connection_shutdown(&peer->connection)
(13,connection.socket_file)
(14,i)
(15,peer->bus->metrics)
(16,error_fold(r)
(17,r)
(18,metrics)
(19,log)
(20,if (r == PEER_E_EOF)
(21,id)
(22,peer->bus->log)
(23,&peer->bus->metrics)
(24,DispatchFile *file)
(25,peer)
(26,log_commitf(peer->bus->log, "Peer :1.%llu is being disconnected as it does not have the resources to perform an operation.",\n\\n                                                peer->id)
(27,0)
(28,peer->owned_names)
(29,metrics_sample_start(&peer->bus->metrics)
(30,r)
(31,r == PEER_E_EOF)
(32,peer->connection)
(33,break;)
(34,peer)
(35,error_fold(r)
(36,peer)
(37,peer)
(38,peer->bus->log)
(39,r = driver_goodbye(peer, false)
(40,connection_close(&peer->connection)
(41,break;)
(42,)
(43,peer)
(44,)
(45,bus)
(46,return error_fold(r)
(47,r == PEER_E_QUOTA)
(48,r)
(49,peer_names)
(50,)
(51,r)
(52,connection_is_running(&peer->connection)
(53,assert(0)
(54,interest)
(55,&peer->bus->metrics)
(56,RET)
(57,i)
(58,interest[] = { EPOLLIN | EPOLLHUP, EPOLLOUT })
(59,peer)
(60,connection)
(61,bus)
(62,peer->id)
(63,)
(64,peer)
(65,if (r)
(66,policy)
(67,socket_file)
(68,interest)
(69,peer)
(70,peer_dispatch_connection(peer, dispatch_file_events(file)
(71,i)
(72,r)
(73,return error_fold(r)
(74,error_fold(r)
(75,bus_log_append_sender(peer->bus, peer->id, &peer_names, peer->policy->seclabel)
(76,peer)
(77,id)
(78,r)
(79,r)
(80,PEER_E_EOF)
(81,c_container_of(file, Peer, connection.socket_file)
(82,peer)
(83,metrics_sample_end(&peer->bus->metrics)
(84,file)
(85,peer->bus)
(86,i)
(87,++i)
(88,if (r)
(89,log_commitf(peer->bus->log, "Peer :1.%llu is being disconnected as it violated the protocol.",\n\\n                                                peer->id)
(90,peer)
(91,log_append_here(peer->bus->log, LOG_WARNING, 0)
(92,r)
(93,!connection_is_running(&peer->connection)
(94,r)
(95,r)
(96,peer)
(97,id)
(98,peer->bus)
(99,break;)
(100,C_ARRAY_SIZE(interest)
(101,*peer = c_container_of(file, Peer, connection.socket_file)
(102,0)
(103,r = driver_goodbye(peer, false)
(104,r)
(105,peer)
(106,bus)
(107,error_fold(r)
(108,PEER_E_QUOTA)
(109,peer->bus)
(110,for (i = 0; i < C_ARRAY_SIZE(interest)
(111,peer->bus->metrics)
(112,if (r)
(113,if (!connection_is_running(&peer->connection)
(114,bus)
(115,"Peer :1.%llu is being disconnected as it violated the protocol.")
(116,&peer->owned_names)
(117,seclabel)
(118,peer)
(119,return error_fold(r)
(120,peer)
(121,peer)
(122,r == PEER_E_PROTOCOL_VIOLATION)
(123,0)
(124,r = peer_dispatch_connection(peer, dispatch_file_events(file)
(125,peer->policy->seclabel)
(126,peer->bus)
(127,peer_names = NAME_SET_INIT_FROM_OWNER(&peer->owned_names)
(128,interest[i])
(129,r = log_commitf(peer->bus->log, "Peer :1.%llu is being disconnected as it violated the protocol.",\n\\n                                                peer->id)
(130,r)
(131,return 0;)
(132,)
(133,connection)
(134,peer->id)
(135,metrics_sample_end(&peer->bus->metrics)
(136,LOG_WARNING)
(137,&peer->connection)
(138,metrics_sample_start(&peer->bus->metrics)
(139,false)
(140,interest)
(141,peer->bus->log)
(142,connection)
(143,peer->bus)
(144,dispatch_file_events(file)
(145,r)
(146,peer_names)
(147,peer)
(148,peer->bus->metrics)
(149,i = 0)
(150,i)
(151,driver_goodbye(peer, false)
(152,metrics)
(153,switch (r)
(154,&peer_names)
(155,"Peer :1.%llu is being disconnected as it does not have the resources to perform an operation.")
(156,PEER_E_PROTOCOL_VIOLATION)
(157,case PEER_E_PROTOCOL_VIOLATION:)
(158,)
(159,r = log_commitf(peer->bus->log, "Peer :1.%llu is being disconnected as it does not have the resources to perform an operation.",\n\\n                                                peer->id)
(160,&peer->connection)
(161,default:)
(162,bus)
(163,peer)
(164,r)
(165,peer->bus->metrics)
(166,driver_goodbye(peer, false)
(167,r)
(168,r)
(169,)
(170,return error_fold(r)
(171,peer->bus)
(172,r)
(173,dispatch_file_events(file)
(174,peer->connection)
(175,false)
(176,bus)
(177,if (r)
(178,log)
(179,peer->bus)
(180,&peer->connection)
(181,r)
(182,&peer->bus->metrics)
(183,0)
(184,connection)
(185,peer)
(186,r)
(187,metrics)
(188,log)
(189,peer->connection)
(190,NAME_SET_INIT_FROM_OWNER(&peer->owned_names)
(191,metrics)
(192,r)
(193,peer->policy)
(194,bus)
(195,r == PEER_E_QUOTA ||\n\\n                           r == PEER_E_PROTOCOL_VIOLATION)
(196,if (r)
(197,Peer)
(198,return error_fold(r)
(199,if (r)
(200,peer_free(peer)
(201,error_fold(r)
(202,&peer->bus->metrics)
(203,peer)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^