-----label-----
1
-----code-----
static int agent_hangup(struct ast_channel *ast)
{
	struct agent_pvt *p = ast_channel_tech_pvt(ast);
	struct ast_channel *indicate_chan = NULL;
	char *tmp_moh; /* moh buffer for indicating after unlocking p */

	if (p->pending) {
		AST_LIST_LOCK(&agents);
		AST_LIST_REMOVE(&agents, p, list);
		AST_LIST_UNLOCK(&agents);
	}

	ast_mutex_lock(&p->lock);
	p->owner = NULL;
	ast_channel_tech_pvt_set(ast, NULL);
	p->app_sleep_cond = 1;
	p->acknowledged = 0;

	/* Release ownership of the agent to other threads (presumably running the login app). */
	p->app_lock_flag = 0;
	ast_cond_signal(&p->app_complete_cond);

	/* if they really are hung up then set start to 0 so the test
	 * later if we're called on an already downed channel
	 * doesn't cause an agent to be logged out like when
	 * agent_request() is followed immediately by agent_hangup()
	 * as in apps/app_chanisavail.c:chanavail_exec()
	 */

	ast_debug(1, "Hangup called for state %s\n", ast_state2str(ast_channel_state(ast)));
	if (p->start && (ast_channel_state(ast) != AST_STATE_UP)) {
		p->start = 0;
	} else
		p->start = 0;
	if (p->chan) {
		ast_channel_internal_bridged_channel_set(p->chan, NULL);
		/* If they're dead, go ahead and hang up on the agent now */
		if (p->dead) {
			ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);
		} else if (p->loginstart) {
			indicate_chan = ast_channel_ref(p->chan);
			tmp_moh = ast_strdupa(p->moh);
		}
	}
	ast_mutex_unlock(&p->lock);

	if (indicate_chan) {
		ast_indicate_data(indicate_chan, AST_CONTROL_HOLD,
			S_OR(tmp_moh, NULL),
			!ast_strlen_zero(tmp_moh) ? strlen(tmp_moh) + 1 : 0);
		indicate_chan = ast_channel_unref(indicate_chan);
	}

	/* Only register a device state change if the agent is still logged in */
	if (!p->loginstart) {
		p->logincallerid[0] = '\0';
	} else {
		ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Agent/%s", p->agent);
	}

	if (p->abouttograb) {
		/* Let the "about to grab" thread know this isn't valid anymore, and let it
		   kill it later */
		p->abouttograb = 0;
	} else if (p->dead) {
		ast_mutex_destroy(&p->lock);
		ast_cond_destroy(&p->app_complete_cond);
		ast_cond_destroy(&p->login_wait_cond);
		ast_free(p);
	} else {
		if (p->chan) {
			/* Not dead -- check availability now */
			ast_mutex_lock(&p->lock);
			/* Store last disconnect time */
			p->lastdisc = ast_tvadd(ast_tvnow(), ast_samp2tv(p->wrapuptime, 1000));
			ast_mutex_unlock(&p->lock);
		}
	}
	return 0;
}
-----children-----
1,2
1,3
1,4
3,4
3,5
5,6
5,7
6,7
8,9
8,10
11,12
11,13
11,14
11,15
11,16
11,17
11,18
11,19
11,20
11,21
11,22
11,23
11,24
11,25
11,26
11,27
11,28
11,29
11,30
12,13
13,14
13,15
14,15
16,17
16,18
16,19
19,20
20,21
20,22
21,22
23,24
25,26
26,27
26,28
27,28
29,30
29,31
29,32
32,33
33,34
35,36
36,37
36,38
38,39
38,40
41,42
41,43
42,43
42,44
43,44
46,47
46,48
46,49
47,48
48,49
48,50
49,50
51,52
52,53
52,54
55,56
56,57
56,58
56,59
56,60
57,58
59,60
60,61
62,63
64,65
66,67
67,68
67,69
68,69
70,71
71,72
73,74
74,75
74,76
75,76
77,78
78,79
78,80
79,80
82,83
83,84
83,85
84,85
84,86
85,86
88,89
90,91
91,92
91,93
91,94
92,93
94,95
96,97
98,99
99,100
99,101
100,101
100,102
101,102
105,106
106,107
106,108
107,108
107,109
108,109
112,113
113,114
113,115
114,115
114,116
115,116
119,120
120,121
120,122
121,122
123,124
124,125
124,126
125,126
128,129
129,130
129,131
129,132
129,133
130,131
134,135
134,136
135,136
137,138
137,139
138,139
140,141
142,143
142,144
142,145
143,144
143,145
144,145
144,146
145,146
148,149
149,150
149,151
150,151
150,152
151,152
153,154
155,156
157,158
158,159
159,160
159,161
160,161
160,162
161,162
165,166
166,167
166,168
167,168
167,169
168,169
172,173
172,174
173,174
173,175
174,175
177,178
177,179
178,179
179,180
179,181
179,182
180,181
182,183
182,184
183,184
186,187
188,189
188,190
188,191
189,190
189,191
190,191
193,194
194,195
195,196
195,197
195,198
196,197
198,199
198,200
199,200
202,203
204,205
204,206
205,206
205,207
206,207
209,210
209,211
210,211
211,212
211,213
212,213
214,215
214,216
215,216
217,218
217,219
218,219
221,222
222,223
222,224
223,224
225,226
225,227
226,227
228,229
228,230
229,230
232,233
233,234
233,235
234,235
236,237
237,238
237,239
238,239
241,242
241,243
242,243
244,245
244,246
245,246
246,247
246,248
246,249
246,250
246,251
247,248
249,250
251,252
253,254
253,255
253,256
254,255
256,257
258,259
260,261
260,262
260,263
261,262
262,263
262,264
263,264
265,266
267,268
267,269
268,269
268,270
269,270
271,272
275,276
276,277
276,278
277,278
279,280
279,281
280,281
282,283
284,285
284,286
284,287
285,286
286,287
286,288
287,288
290,291
291,292
292,293
292,294
293,294
293,295
294,295
294,296
295,296
300,301
301,302
302,303
302,304
302,305
302,306
303,304
305,306
308,309
308,310
309,310
312,313
312,314
312,315
313,314
313,315
314,315
317,318
318,319
319,320
319,321
320,321
320,322
321,322
325,326
325,327
325,328
326,327
326,328
327,328
330,331
330,332
330,333
330,334
331,332
332,333
332,334
333,334
335,336
336,337
336,338
337,338
340,341
341,342
341,343
342,343
344,345
345,346
345,347
346,347
349,350
350,351
350,352
351,352
353,354
354,355
354,356
355,356
358,359
359,360
359,361
360,361
362,363
364,365
365,366
365,367
366,367
366,368
367,368
370,371
370,372
370,373
371,372
372,373
372,374
373,374
375,376
376,377
376,378
377,378
380,381
381,382
381,383
382,383
382,384
383,384
386,387
386,388
386,389
387,388
389,390
390,391
392,393
392,394
392,395
393,394
395,396
395,397
396,397
400,401
401,402
401,403
402,403
404,405
405,406
405,407
406,407
409,410
-----nextToken-----
2,4,7,9,10,15,17,18,22,24,28,30,31,34,37,39,40,44,45,50,53,54,58,61,63,65,69,72,76,80,81,86,87,89,93,95,97,102,103,104,109,110,111,116,117,118,122,126,127,131,132,133,136,139,141,146,147,152,154,156,162,163,164,169,170,171,175,176,181,184,185,187,191,192,197,200,201,203,207,208,213,216,219,220,224,227,230,231,235,239,240,243,248,250,252,255,257,259,264,266,270,272,273,274,278,281,283,288,289,296,297,298,299,304,306,307,310,311,315,316,322,323,324,328,329,334,338,339,343,347,348,352,356,357,361,363,368,369,374,378,379,384,385,388,391,394,397,398,399,403,407,408,410
-----computeFrom-----
83,84
83,85
99,100
99,101
106,107
106,108
113,114
113,115
143,144
143,145
149,150
149,151
159,160
159,161
166,167
166,168
211,212
211,213
222,223
222,224
267,268
267,269
276,277
276,278
292,293
292,294
319,320
319,321
381,382
381,383
-----guardedBy-----
146,162
147,163
-----guardedByNegation-----
146,169
147,170
-----lastLexicalUse-----
146,169
147,170
-----jump-----
146,169
147,170
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;ReferenceOperator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ConditionalExpression;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ReturnStatement;LiteralExpression;
-----ast_node-----
static int agent_hangup(struct ast_channel *ast){	struct agent_pvt *p = ast_channel_tech_pvt(ast);	struct ast_channel *indicate_chan = NULL;	char *tmp_moh; /* moh buffer for indicating after unlocking p */	if (p->pending) {		AST_LIST_LOCK(&agents);		AST_LIST_REMOVE(&agents, p, list);		AST_LIST_UNLOCK(&agents);	}	ast_mutex_lock(&p->lock);	p->owner = NULL;	ast_channel_tech_pvt_set(ast, NULL);	p->app_sleep_cond = 1;	p->acknowledged = 0;	/* Release ownership of the agent to other threads (presumably running the login app). */	p->app_lock_flag = 0;	ast_cond_signal(&p->app_complete_cond);	/* if they really are hung up then set start to 0 so the test	 * later if we're called on an already downed channel	 * doesn't cause an agent to be logged out like when	 * agent_request() is followed immediately by agent_hangup()	 * as in apps/app_chanisavail.c:chanavail_exec()	 */	ast_debug(1, "Hangup called for state %s\n", ast_state2str(ast_channel_state(ast)));	if (p->start && (ast_channel_state(ast) != AST_STATE_UP)) {		p->start = 0;	} else		p->start = 0;	if (p->chan) {		ast_channel_internal_bridged_channel_set(p->chan, NULL);		/* If they're dead, go ahead and hang up on the agent now */		if (p->dead) {			ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);		} else if (p->loginstart) {			indicate_chan = ast_channel_ref(p->chan);			tmp_moh = ast_strdupa(p->moh);		}	}	ast_mutex_unlock(&p->lock);	if (indicate_chan) {		ast_indicate_data(indicate_chan, AST_CONTROL_HOLD,			S_OR(tmp_moh, NULL),			!ast_strlen_zero(tmp_moh) ? strlen(tmp_moh) + 1 : 0);		indicate_chan = ast_channel_unref(indicate_chan);	}	/* Only register a device state change if the agent is still logged in */	if (!p->loginstart) {		p->logincallerid[0] = '\0';	} else {		ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Agent/%s", p->agent);	}	if (p->abouttograb) {		/* Let the "about to grab" thread know this isn't valid anymore, and let it		   kill it later */		p->abouttograb = 0;	} else if (p->dead) {		ast_mutex_destroy(&p->lock);		ast_cond_destroy(&p->app_complete_cond);		ast_cond_destroy(&p->login_wait_cond);		ast_free(p);	} else {		if (p->chan) {			/* Not dead -- check availability now */			ast_mutex_lock(&p->lock);			/* Store last disconnect time */			p->lastdisc = ast_tvadd(ast_tvnow(), ast_samp2tv(p->wrapuptime, 1000));			ast_mutex_unlock(&p->lock);		}	}	return 0;}
static int
agent_hangup(struct ast_channel *ast)
agent_hangup
struct ast_channel *ast
struct ast_channel
ast_channel
*ast
*
ast
{	struct agent_pvt *p = ast_channel_tech_pvt(ast);	struct ast_channel *indicate_chan = NULL;	char *tmp_moh; /* moh buffer for indicating after unlocking p */	if (p->pending) {		AST_LIST_LOCK(&agents);		AST_LIST_REMOVE(&agents, p, list);		AST_LIST_UNLOCK(&agents);	}	ast_mutex_lock(&p->lock);	p->owner = NULL;	ast_channel_tech_pvt_set(ast, NULL);	p->app_sleep_cond = 1;	p->acknowledged = 0;	/* Release ownership of the agent to other threads (presumably running the login app). */	p->app_lock_flag = 0;	ast_cond_signal(&p->app_complete_cond);	/* if they really are hung up then set start to 0 so the test	 * later if we're called on an already downed channel	 * doesn't cause an agent to be logged out like when	 * agent_request() is followed immediately by agent_hangup()	 * as in apps/app_chanisavail.c:chanavail_exec()	 */	ast_debug(1, "Hangup called for state %s\n", ast_state2str(ast_channel_state(ast)));	if (p->start && (ast_channel_state(ast) != AST_STATE_UP)) {		p->start = 0;	} else		p->start = 0;	if (p->chan) {		ast_channel_internal_bridged_channel_set(p->chan, NULL);		/* If they're dead, go ahead and hang up on the agent now */		if (p->dead) {			ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);		} else if (p->loginstart) {			indicate_chan = ast_channel_ref(p->chan);			tmp_moh = ast_strdupa(p->moh);		}	}	ast_mutex_unlock(&p->lock);	if (indicate_chan) {		ast_indicate_data(indicate_chan, AST_CONTROL_HOLD,			S_OR(tmp_moh, NULL),			!ast_strlen_zero(tmp_moh) ? strlen(tmp_moh) + 1 : 0);		indicate_chan = ast_channel_unref(indicate_chan);	}	/* Only register a device state change if the agent is still logged in */	if (!p->loginstart) {		p->logincallerid[0] = '\0';	} else {		ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Agent/%s", p->agent);	}	if (p->abouttograb) {		/* Let the "about to grab" thread know this isn't valid anymore, and let it		   kill it later */		p->abouttograb = 0;	} else if (p->dead) {		ast_mutex_destroy(&p->lock);		ast_cond_destroy(&p->app_complete_cond);		ast_cond_destroy(&p->login_wait_cond);		ast_free(p);	} else {		if (p->chan) {			/* Not dead -- check availability now */			ast_mutex_lock(&p->lock);			/* Store last disconnect time */			p->lastdisc = ast_tvadd(ast_tvnow(), ast_samp2tv(p->wrapuptime, 1000));			ast_mutex_unlock(&p->lock);		}	}	return 0;}
struct agent_pvt *p = ast_channel_tech_pvt(ast);
struct agent_pvt *p = ast_channel_tech_pvt(ast);
struct agent_pvt
agent_pvt
*p = ast_channel_tech_pvt(ast)
*
p
= ast_channel_tech_pvt(ast)
ast_channel_tech_pvt(ast)
ast_channel_tech_pvt
ast_channel_tech_pvt
ast
ast
struct ast_channel *indicate_chan = NULL;
struct ast_channel *indicate_chan = NULL;
struct ast_channel
ast_channel
*indicate_chan = NULL
*
indicate_chan
= NULL
NULL
NULL
char *tmp_moh;
char *tmp_moh;
char
*tmp_moh
*
tmp_moh
if (p->pending) {		AST_LIST_LOCK(&agents);		AST_LIST_REMOVE(&agents, p, list);		AST_LIST_UNLOCK(&agents);	}
p->pending
p
p
pending
{		AST_LIST_LOCK(&agents);		AST_LIST_REMOVE(&agents, p, list);		AST_LIST_UNLOCK(&agents);	}
AST_LIST_LOCK(&agents);
AST_LIST_LOCK(&agents);
AST_LIST_LOCK
AST_LIST_LOCK
(&agents)
&agents
&
agents
AST_LIST_REMOVE(&agents, p, list);
AST_LIST_REMOVE(&agents, p, list)
AST_LIST_REMOVE
AST_LIST_REMOVE
&agents
agents
agents
p
p
list
list
AST_LIST_UNLOCK(&agents);
AST_LIST_UNLOCK(&agents)
AST_LIST_UNLOCK
AST_LIST_UNLOCK
&agents
agents
agents
ast_mutex_lock(&p->lock);
ast_mutex_lock(&p->lock)
ast_mutex_lock
ast_mutex_lock
&p->lock
p->lock
p
p
lock
p->owner = NULL;
p->owner = NULL
p->owner
p
p
owner
NULL
NULL
ast_channel_tech_pvt_set(ast, NULL);
ast_channel_tech_pvt_set(ast, NULL)
ast_channel_tech_pvt_set
ast_channel_tech_pvt_set
ast
ast
NULL
NULL
p->app_sleep_cond = 1;
p->app_sleep_cond = 1
p->app_sleep_cond
p
p
app_sleep_cond
1
p->acknowledged = 0;
p->acknowledged = 0
p->acknowledged
p
p
acknowledged
0
p->app_lock_flag = 0;
p->app_lock_flag = 0
p->app_lock_flag
p
p
app_lock_flag
0
ast_cond_signal(&p->app_complete_cond);
ast_cond_signal(&p->app_complete_cond)
ast_cond_signal
ast_cond_signal
&p->app_complete_cond
p->app_complete_cond
p
p
app_complete_cond
ast_debug(1, "Hangup called for state %s\n", ast_state2str(ast_channel_state(ast)));
ast_debug(1, "Hangup called for state %s\n", ast_state2str(ast_channel_state(ast)))
ast_debug
ast_debug
1
"Hangup called for state %s\n"
ast_state2str(ast_channel_state(ast))
ast_state2str
ast_state2str
ast_channel_state(ast)
ast_channel_state
ast_channel_state
ast
ast
if (p->start && (ast_channel_state(ast) != AST_STATE_UP)) {		p->start = 0;	} else		p->start = 0;
p->start && (ast_channel_state(ast) != AST_STATE_UP)
p->start
p
p
start
(ast_channel_state(ast) != AST_STATE_UP)
ast_channel_state(ast) != AST_STATE_UP
ast_channel_state(ast)
ast_channel_state
ast_channel_state
ast
ast
AST_STATE_UP
AST_STATE_UP
{		p->start = 0;	}
p->start = 0;
p->start = 0
p->start
p
p
start
0
p->start = 0;
p->start = 0
p->start
p
p
start
0
if (p->chan) {		ast_channel_internal_bridged_channel_set(p->chan, NULL);		/* If they're dead, go ahead and hang up on the agent now */		if (p->dead) {			ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);		} else if (p->loginstart) {			indicate_chan = ast_channel_ref(p->chan);			tmp_moh = ast_strdupa(p->moh);		}	}
p->chan
p
p
chan
{		ast_channel_internal_bridged_channel_set(p->chan, NULL);		/* If they're dead, go ahead and hang up on the agent now */		if (p->dead) {			ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);		} else if (p->loginstart) {			indicate_chan = ast_channel_ref(p->chan);			tmp_moh = ast_strdupa(p->moh);		}	}
ast_channel_internal_bridged_channel_set(p->chan, NULL);
ast_channel_internal_bridged_channel_set(p->chan, NULL)
ast_channel_internal_bridged_channel_set
ast_channel_internal_bridged_channel_set
p->chan
p
p
chan
NULL
NULL
if (p->dead) {			ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);		} else if (p->loginstart) {			indicate_chan = ast_channel_ref(p->chan);			tmp_moh = ast_strdupa(p->moh);		}
p->dead
p
p
dead
{			ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);		}
ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);
ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT)
ast_softhangup
ast_softhangup
p->chan
p
p
chan
AST_SOFTHANGUP_EXPLICIT
AST_SOFTHANGUP_EXPLICIT
if (p->loginstart) {			indicate_chan = ast_channel_ref(p->chan);			tmp_moh = ast_strdupa(p->moh);		}
p->loginstart
p
p
loginstart
{			indicate_chan = ast_channel_ref(p->chan);			tmp_moh = ast_strdupa(p->moh);		}
indicate_chan = ast_channel_ref(p->chan);
indicate_chan = ast_channel_ref(p->chan)
indicate_chan
indicate_chan
ast_channel_ref(p->chan)
ast_channel_ref
ast_channel_ref
p->chan
p
p
chan
tmp_moh = ast_strdupa(p->moh);
tmp_moh = ast_strdupa(p->moh)
tmp_moh
tmp_moh
ast_strdupa(p->moh)
ast_strdupa
ast_strdupa
p->moh
p
p
moh
ast_mutex_unlock(&p->lock);
ast_mutex_unlock(&p->lock)
ast_mutex_unlock
ast_mutex_unlock
&p->lock
p->lock
p
p
lock
if (indicate_chan) {		ast_indicate_data(indicate_chan, AST_CONTROL_HOLD,			S_OR(tmp_moh, NULL),			!ast_strlen_zero(tmp_moh) ? strlen(tmp_moh) + 1 : 0);		indicate_chan = ast_channel_unref(indicate_chan);	}
indicate_chan
indicate_chan
{		ast_indicate_data(indicate_chan, AST_CONTROL_HOLD,			S_OR(tmp_moh, NULL),			!ast_strlen_zero(tmp_moh) ? strlen(tmp_moh) + 1 : 0);		indicate_chan = ast_channel_unref(indicate_chan);	}
ast_indicate_data(indicate_chan, AST_CONTROL_HOLD,			S_OR(tmp_moh, NULL),			!ast_strlen_zero(tmp_moh) ? strlen(tmp_moh) + 1 : 0);
ast_indicate_data(indicate_chan, AST_CONTROL_HOLD,			S_OR(tmp_moh, NULL),			!ast_strlen_zero(tmp_moh) ? strlen(tmp_moh) + 1 : 0)
ast_indicate_data
ast_indicate_data
indicate_chan
indicate_chan
AST_CONTROL_HOLD
AST_CONTROL_HOLD
S_OR(tmp_moh, NULL)
S_OR
S_OR
tmp_moh
tmp_moh
NULL
NULL
!ast_strlen_zero(tmp_moh) ? strlen(tmp_moh) + 1 : 0
!ast_strlen_zero(tmp_moh)
ast_strlen_zero(tmp_moh)
ast_strlen_zero
ast_strlen_zero
tmp_moh
tmp_moh
strlen(tmp_moh) + 1
strlen(tmp_moh)
strlen
strlen
tmp_moh
tmp_moh
1
0
indicate_chan = ast_channel_unref(indicate_chan);
indicate_chan = ast_channel_unref(indicate_chan)
indicate_chan
indicate_chan
ast_channel_unref(indicate_chan)
ast_channel_unref
ast_channel_unref
indicate_chan
indicate_chan
if (!p->loginstart) {		p->logincallerid[0] = '\0';	} else {		ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Agent/%s", p->agent);	}
!p->loginstart
p->loginstart
p
p
loginstart
{		p->logincallerid[0] = '\0';	}
p->logincallerid[0] = '\0';
p->logincallerid[0] = '\0'
p->logincallerid[0]
p->logincallerid
p
p
logincallerid
0
'\0'
{		ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Agent/%s", p->agent);	}
ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Agent/%s", p->agent);
ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Agent/%s", p->agent)
ast_devstate_changed
ast_devstate_changed
AST_DEVICE_NOT_INUSE
AST_DEVICE_NOT_INUSE
"Agent/%s"
p->agent
p
p
agent
if (p->abouttograb) {		/* Let the "about to grab" thread know this isn't valid anymore, and let it		   kill it later */		p->abouttograb = 0;	} else if (p->dead) {		ast_mutex_destroy(&p->lock);		ast_cond_destroy(&p->app_complete_cond);		ast_cond_destroy(&p->login_wait_cond);		ast_free(p);	} else {		if (p->chan) {			/* Not dead -- check availability now */			ast_mutex_lock(&p->lock);			/* Store last disconnect time */			p->lastdisc = ast_tvadd(ast_tvnow(), ast_samp2tv(p->wrapuptime, 1000));			ast_mutex_unlock(&p->lock);		}	}
p->abouttograb
p
p
abouttograb
{		/* Let the "about to grab" thread know this isn't valid anymore, and let it		   kill it later */		p->abouttograb = 0;	}
p->abouttograb = 0;
p->abouttograb = 0
p->abouttograb
p
p
abouttograb
0
if (p->dead) {		ast_mutex_destroy(&p->lock);		ast_cond_destroy(&p->app_complete_cond);		ast_cond_destroy(&p->login_wait_cond);		ast_free(p);	} else {		if (p->chan) {			/* Not dead -- check availability now */			ast_mutex_lock(&p->lock);			/* Store last disconnect time */			p->lastdisc = ast_tvadd(ast_tvnow(), ast_samp2tv(p->wrapuptime, 1000));			ast_mutex_unlock(&p->lock);		}	}
p->dead
p
p
dead
{		ast_mutex_destroy(&p->lock);		ast_cond_destroy(&p->app_complete_cond);		ast_cond_destroy(&p->login_wait_cond);		ast_free(p);	}
ast_mutex_destroy(&p->lock);
ast_mutex_destroy(&p->lock)
ast_mutex_destroy
ast_mutex_destroy
&p->lock
p->lock
p
p
lock
ast_cond_destroy(&p->app_complete_cond);
ast_cond_destroy(&p->app_complete_cond)
ast_cond_destroy
ast_cond_destroy
&p->app_complete_cond
p->app_complete_cond
p
p
app_complete_cond
ast_cond_destroy(&p->login_wait_cond);
ast_cond_destroy(&p->login_wait_cond)
ast_cond_destroy
ast_cond_destroy
&p->login_wait_cond
p->login_wait_cond
p
p
login_wait_cond
ast_free(p);
ast_free(p)
ast_free
ast_free
p
p
{		if (p->chan) {			/* Not dead -- check availability now */			ast_mutex_lock(&p->lock);			/* Store last disconnect time */			p->lastdisc = ast_tvadd(ast_tvnow(), ast_samp2tv(p->wrapuptime, 1000));			ast_mutex_unlock(&p->lock);		}	}
if (p->chan) {			/* Not dead -- check availability now */			ast_mutex_lock(&p->lock);			/* Store last disconnect time */			p->lastdisc = ast_tvadd(ast_tvnow(), ast_samp2tv(p->wrapuptime, 1000));			ast_mutex_unlock(&p->lock);		}
p->chan
p
p
chan
{			/* Not dead -- check availability now */			ast_mutex_lock(&p->lock);			/* Store last disconnect time */			p->lastdisc = ast_tvadd(ast_tvnow(), ast_samp2tv(p->wrapuptime, 1000));			ast_mutex_unlock(&p->lock);		}
ast_mutex_lock(&p->lock);
ast_mutex_lock(&p->lock)
ast_mutex_lock
ast_mutex_lock
&p->lock
p->lock
p
p
lock
p->lastdisc = ast_tvadd(ast_tvnow(), ast_samp2tv(p->wrapuptime, 1000));
p->lastdisc = ast_tvadd(ast_tvnow(), ast_samp2tv(p->wrapuptime, 1000))
p->lastdisc
p
p
lastdisc
ast_tvadd(ast_tvnow(), ast_samp2tv(p->wrapuptime, 1000))
ast_tvadd
ast_tvadd
ast_tvnow()
ast_tvnow
ast_tvnow
ast_samp2tv(p->wrapuptime, 1000)
ast_samp2tv
ast_samp2tv
p->wrapuptime
p
p
wrapuptime
1000
ast_mutex_unlock(&p->lock);
ast_mutex_unlock(&p->lock)
ast_mutex_unlock
ast_mutex_unlock
&p->lock
p->lock
p
p
lock
return 0;
0
-----joern-----
(146,114,0)
(29,199,0)
(211,128,0)
(17,12,0)
(225,188,0)
(195,116,0)
(58,128,0)
(99,169,0)
(98,129,0)
(226,12,0)
(1,69,0)
(200,114,0)
(54,187,0)
(129,134,0)
(121,72,0)
(158,89,0)
(18,8,0)
(86,137,0)
(13,75,0)
(38,103,0)
(2,224,0)
(137,56,0)
(74,55,0)
(114,223,0)
(63,40,0)
(75,13,0)
(107,228,0)
(176,128,0)
(71,114,0)
(198,162,0)
(147,89,0)
(27,103,0)
(157,146,0)
(87,16,0)
(123,128,0)
(161,128,0)
(214,67,0)
(24,37,0)
(212,176,0)
(44,211,0)
(205,68,0)
(31,69,0)
(203,13,0)
(89,147,0)
(173,2,0)
(130,114,0)
(221,213,0)
(164,51,0)
(139,200,0)
(6,114,0)
(169,0,0)
(167,128,0)
(6,135,0)
(150,114,0)
(229,76,0)
(65,128,0)
(100,114,0)
(90,80,0)
(48,98,0)
(174,118,0)
(78,18,0)
(72,121,0)
(45,22,0)
(137,60,0)
(74,18,0)
(102,114,0)
(66,50,0)
(31,18,0)
(117,200,0)
(59,214,0)
(40,63,0)
(226,114,0)
(132,34,0)
(149,135,0)
(107,105,0)
(81,0,0)
(160,57,0)
(46,83,0)
(69,31,0)
(68,228,0)
(142,75,0)
(46,53,0)
(111,3,0)
(211,186,0)
(85,229,0)
(26,21,0)
(131,15,0)
(92,230,0)
(30,8,0)
(30,158,0)
(96,137,0)
(154,186,0)
(223,114,0)
(11,125,0)
(228,107,0)
(227,199,0)
(122,114,0)
(93,175,0)
(225,52,0)
(177,226,0)
(207,172,0)
(118,19,0)
(170,100,0)
(2,173,0)
(100,162,0)
(186,77,0)
(39,122,0)
(10,125,0)
(202,80,0)
(15,131,0)
(172,53,0)
(191,38,0)
(103,27,0)
(171,223,0)
(79,10,0)
(163,37,0)
(73,5,0)
(144,55,0)
(84,173,0)
(178,214,0)
(31,229,0)
(113,186,0)
(137,114,0)
(98,114,0)
(214,178,0)
(201,182,0)
(10,176,0)
(166,102,0)
(109,40,0)
(5,114,0)
(69,158,0)
(197,160,0)
(211,116,0)
(211,174,0)
(173,114,0)
(136,56,0)
(148,30,0)
(89,158,0)
(210,226,0)
(153,147,0)
(129,98,0)
(229,163,0)
(114,128,0)
(192,31,0)
(182,114,0)
(47,122,0)
(22,34,0)
(103,38,0)
(190,82,0)
(31,176,0)
(204,182,0)
(32,54,0)
(116,16,0)
(55,158,0)
(124,69,0)
(224,128,0)
(218,142,0)
(41,67,0)
(216,6,0)
(50,0,0)
(194,172,0)
(83,46,0)
(14,230,0)
(181,13,0)
(16,119,0)
(52,114,0)
(46,118,0)
(186,114,0)
(104,22,0)
(196,72,0)
(33,100,0)
(224,2,0)
(80,160,0)
(9,19,0)
(185,21,0)
(9,145,0)
(222,150,0)
(134,105,0)
(56,137,0)
(169,187,0)
(108,128,0)
(156,130,0)
(118,46,0)
(68,114,0)
(94,38,0)
(34,22,0)
(174,114,0)
(133,51,0)
(23,66,0)
(63,115,0)
(35,147,0)
(61,34,0)
(18,74,0)
(217,158,0)
(22,215,0)
(125,120,0)
(168,53,0)
(138,128,0)
(106,37,0)
(97,146,0)
(95,184,0)
(75,142,0)
(211,100,0)
(178,114,0)
(188,19,0)
(70,173,0)
(141,52,0)
(82,49,0)
(220,150,0)
(155,178,0)
(27,128,0)
(20,71,0)
(150,184,0)
(180,52,0)
(145,9,0)
(25,82,0)
(31,120,0)
(143,66,0)
(55,74,0)
(163,229,0)
(36,49,0)
(77,128,0)
(211,82,0)
(130,145,0)
(66,114,0)
(189,31,0)
(112,174,0)
(62,74,0)
(52,225,0)
(172,114,0)
(8,30,0)
(8,18,0)
(110,77,0)
(223,187,0)
(211,150,0)
(50,66,0)
(145,130,0)
(126,130,0)
(162,151,0)
(82,114,0)
(64,114,0)
(179,178,0)
(200,116,0)
(199,114,0)
(7,5,0)
(211,6,0)
(80,114,0)
(14,60,0)
(53,172,0)
(51,114,0)
(131,128,0)
(37,114,0)
(72,114,0)
(134,129,0)
(185,60,0)
(53,46,0)
(12,128,0)
(15,183,0)
(0,50,0)
(0,169,0)
(43,128,0)
(28,6,0)
(158,76,0)
(213,105,0)
(209,68,0)
(221,122,0)
(4,98,0)
(211,226,0)
(3,105,0)
(206,174,0)
(34,114,0)
(127,211,0)
(142,187,0)
(211,80,0)
(21,185,0)
(208,128,0)
(122,221,0)
(125,10,0)
(10,229,0)
(38,114,0)
(54,128,0)
(219,54,0)
(159,63,0)
(37,163,0)
(116,200,0)
(13,128,0)
(91,183,0)
(101,71,0)
(183,114,0)
(228,68,0)
(230,14,0)
(3,114,0)
(193,183,0)
(183,15,0)
(42,176,0)
(18,31,0)
(49,128,0)
(188,225,0)
(88,72,0)
(184,128,0)
(40,114,0)
(165,40,0)
(147,114,0)
(152,102,0)
(213,221,0)
(35,153,1)
(134,129,1)
(163,37,1)
(178,155,1)
(193,91,1)
(200,114,1)
(20,101,1)
(73,160,1)
(211,82,1)
(31,18,1)
(118,46,1)
(70,84,1)
(89,147,1)
(182,201,1)
(30,148,1)
(97,71,1)
(147,35,1)
(136,14,1)
(53,172,1)
(229,163,1)
(80,202,1)
(74,55,1)
(148,69,1)
(223,171,1)
(133,16,1)
(100,114,1)
(145,130,1)
(210,224,1)
(204,176,1)
(51,114,1)
(55,158,1)
(104,121,1)
(190,54,1)
(225,52,1)
(42,114,1)
(31,176,1)
(174,112,1)
(194,207,1)
(2,173,1)
(31,69,1)
(99,66,1)
(47,134,1)
(206,9,1)
(45,104,1)
(209,205,1)
(29,227,1)
(199,29,1)
(66,143,1)
(56,136,1)
(142,187,1)
(178,114,1)
(129,98,1)
(122,39,1)
(153,217,1)
(25,190,1)
(80,114,1)
(154,184,1)
(189,192,1)
(158,89,1)
(38,114,1)
(46,53,1)
(49,36,1)
(127,102,1)
(5,114,1)
(183,114,1)
(1,124,1)
(5,7,1)
(141,118,1)
(34,61,1)
(191,5,1)
(15,183,1)
(10,229,1)
(9,145,1)
(94,191,1)
(3,111,1)
(211,186,1)
(160,197,1)
(207,83,1)
(150,220,1)
(200,117,1)
(168,172,1)
(33,51,1)
(44,211,1)
(224,2,1)
(211,174,1)
(12,17,1)
(221,122,1)
(227,51,1)
(22,34,1)
(88,140,1)
(223,187,1)
(7,73,1)
(82,114,1)
(159,40,1)
(46,83,1)
(197,80,1)
(174,114,1)
(71,20,1)
(211,226,1)
(75,142,1)
(183,193,1)
(112,206,1)
(27,103,1)
(24,106,1)
(172,194,1)
(165,71,1)
(211,116,1)
(222,49,1)
(196,88,1)
(135,149,1)
(211,6,1)
(127,162,1)
(150,114,1)
(40,114,1)
(228,68,1)
(126,102,1)
(82,25,1)
(68,114,1)
(54,187,1)
(51,164,1)
(10,176,1)
(113,154,1)
(71,114,1)
(17,226,1)
(114,223,1)
(169,99,1)
(14,230,1)
(34,114,1)
(107,228,1)
(147,114,1)
(77,110,1)
(140,27,1)
(39,47,1)
(72,114,1)
(50,0,1)
(176,212,1)
(211,80,1)
(6,216,1)
(122,114,1)
(3,114,1)
(61,132,1)
(18,8,1)
(90,50,1)
(18,74,1)
(0,81,1)
(214,178,1)
(144,8,1)
(13,75,1)
(30,158,1)
(59,178,1)
(21,26,1)
(84,185,1)
(109,165,1)
(37,24,1)
(127,188,1)
(186,113,1)
(230,92,1)
(152,199,1)
(186,114,1)
(81,169,1)
(142,218,1)
(96,56,1)
(219,12,1)
(172,114,1)
(173,70,1)
(171,64,1)
(79,11,1)
(188,225,1)
(226,177,1)
(88,125,1)
(214,59,1)
(40,109,1)
(72,196,1)
(181,203,1)
(50,66,1)
(68,209,1)
(127,3,1)
(191,146,1)
(139,121,1)
(83,174,1)
(146,157,1)
(184,95,1)
(52,114,1)
(162,198,1)
(63,159,1)
(226,114,1)
(74,62,1)
(86,96,1)
(55,144,1)
(125,10,1)
(218,181,1)
(66,114,1)
(132,45,1)
(173,114,1)
(177,210,1)
(69,1,1)
(102,166,1)
(137,114,1)
(203,131,1)
(166,152,1)
(199,114,1)
(23,13,1)
(137,86,1)
(131,15,1)
(37,114,1)
(164,133,1)
(211,100,1)
(69,158,1)
(205,199,1)
(87,116,1)
(53,168,1)
(101,214,1)
(156,126,1)
(213,221,1)
(63,40,1)
(98,4,1)
(124,189,1)
(146,114,1)
(6,114,1)
(98,114,1)
(31,229,1)
(211,127,1)
(102,114,1)
(191,158,1)
(103,38,1)
(73,135,1)
(62,55,1)
(137,56,1)
(157,97,1)
(54,32,1)
(16,87,1)
(92,182,1)
(95,150,1)
(4,48,1)
(8,30,1)
(179,5,1)
(192,140,1)
(10,79,1)
(116,200,1)
(106,85,1)
(133,22,1)
(202,90,1)
(169,187,1)
(195,200,1)
(121,72,1)
(201,204,1)
(32,219,1)
(185,21,1)
(11,31,1)
(191,63,1)
(130,156,1)
(38,94,1)
(91,77,1)
(211,150,1)
(28,50,1)
(116,195,1)
(85,146,1)
(130,114,1)
(216,28,1)
(170,33,1)
(78,8,1)
(84,182,1)
(48,107,1)
(198,100,1)
(143,23,1)
(0,169,1)
(155,179,1)
(52,180,1)
(220,222,1)
(26,137,1)
(217,229,1)
(182,114,1)
(36,82,1)
(100,170,1)
(180,141,1)
(111,213,1)
(110,186,1)
(149,6,1)
(117,139,1)
(212,42,1)
(18,78,1)
(20,5,2)
(169,66,2)
(211,116,2)
(199,51,2)
(81,66,2)
(35,146,2)
(18,74,2)
(8,140,2)
(114,223,2)
(213,199,2)
(202,50,2)
(63,71,2)
(29,51,2)
(118,46,2)
(53,172,2)
(211,100,2)
(82,114,2)
(197,50,2)
(3,114,2)
(227,51,2)
(172,114,2)
(34,114,2)
(78,8,2)
(46,102,2)
(99,66,2)
(146,71,2)
(132,121,2)
(180,102,2)
(194,102,2)
(89,146,2)
(172,102,2)
(96,182,2)
(141,102,2)
(53,102,2)
(163,146,2)
(106,146,2)
(37,114,2)
(137,182,2)
(221,199,2)
(102,199,2)
(9,145,2)
(37,146,2)
(209,199,2)
(47,199,2)
(183,114,2)
(126,102,2)
(69,158,2)
(1,140,2)
(117,121,2)
(61,121,2)
(51,114,2)
(87,121,2)
(86,182,2)
(160,50,2)
(59,5,2)
(71,5,2)
(145,130,2)
(125,10,2)
(122,114,2)
(229,163,2)
(214,5,2)
(174,114,2)
(211,186,2)
(129,98,2)
(124,140,2)
(50,0,2)
(0,169,2)
(30,140,2)
(4,199,2)
(83,102,2)
(169,187,2)
(131,15,2)
(221,122,2)
(192,140,2)
(102,114,2)
(72,114,2)
(146,114,2)
(178,5,2)
(179,5,2)
(195,121,2)
(130,114,2)
(92,182,2)
(44,211,2)
(21,182,2)
(198,51,2)
(213,221,2)
(79,140,2)
(216,50,2)
(152,199,2)
(225,102,2)
(186,114,2)
(228,199,2)
(71,114,2)
(16,121,2)
(97,71,2)
(90,50,2)
(207,102,2)
(142,187,2)
(31,69,2)
(174,102,2)
(22,121,2)
(18,140,2)
(159,71,2)
(153,146,2)
(147,114,2)
(27,103,2)
(158,89,2)
(68,199,2)
(200,121,2)
(52,102,2)
(224,2,2)
(74,8,2)
(68,114,2)
(211,80,2)
(156,102,2)
(178,114,2)
(52,114,2)
(54,187,2)
(6,114,2)
(134,199,2)
(211,6,2)
(34,121,2)
(185,182,2)
(163,37,2)
(125,140,2)
(162,51,2)
(98,114,2)
(2,173,2)
(189,140,2)
(100,51,2)
(211,226,2)
(130,102,2)
(80,114,2)
(137,114,2)
(107,199,2)
(69,140,2)
(55,158,2)
(139,121,2)
(40,114,2)
(211,150,2)
(185,21,2)
(111,199,2)
(104,121,2)
(137,56,2)
(134,129,2)
(230,182,2)
(103,38,2)
(15,183,2)
(122,199,2)
(118,102,2)
(50,66,2)
(211,82,2)
(55,8,2)
(10,229,2)
(107,228,2)
(98,199,2)
(170,51,2)
(188,225,2)
(200,114,2)
(80,50,2)
(226,114,2)
(155,5,2)
(46,53,2)
(214,178,2)
(158,146,2)
(89,147,2)
(148,140,2)
(6,50,2)
(228,68,2)
(39,199,2)
(157,71,2)
(85,146,2)
(112,102,2)
(144,8,2)
(188,102,2)
(150,114,2)
(31,140,2)
(116,200,2)
(66,114,2)
(31,18,2)
(56,182,2)
(166,199,2)
(101,5,2)
(225,52,2)
(62,8,2)
(206,102,2)
(182,114,2)
(26,182,2)
(22,34,2)
(33,51,2)
(13,75,2)
(165,71,2)
(149,50,2)
(48,199,2)
(217,146,2)
(38,114,2)
(100,114,2)
(30,158,2)
(121,72,2)
(229,146,2)
(136,182,2)
(18,8,2)
(31,229,2)
(145,102,2)
(10,140,2)
(5,114,2)
(168,102,2)
(109,71,2)
(28,50,2)
(223,187,2)
(45,121,2)
(199,114,2)
(135,50,2)
(129,199,2)
(40,71,2)
(31,176,2)
(11,140,2)
(205,199,2)
(10,176,2)
(63,40,2)
(116,121,2)
(211,174,2)
(46,83,2)
(24,146,2)
(0,66,2)
(75,142,2)
(173,114,2)
(74,55,2)
(9,102,2)
(3,199,2)
(14,182,2)
(147,146,2)
(8,30,2)
(14,230,2)
-----------------------------------
(0,ast_channel_state(ast)
(1,NULL)
(2,&p->lock)
(3,ast_free(p)
(4,app_complete_cond)
(5,p->chan)
(6,p->start)
(7,chan)
(8,!ast_strlen_zero(tmp_moh)
(9,ast_mutex_lock(&p->lock)
(10,ast_channel_unref(indicate_chan)
(11,indicate_chan)
(12,p->owner = NULL)
(13,ast_debug(1, "Hangup called for state %s\\n", ast_state2str(ast_channel_state(ast)
(14,AST_LIST_LOCK(&agents)
(15,&p->app_complete_cond)
(16,p->logincallerid[0] = \'\\0\')
(17,NULL)
(18,!ast_strlen_zero(tmp_moh)
(19,)
(20,dead)
(21,&agents)
(22,ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Agent/%s", p->agent)
(23,p)
(24,chan)
(25,app_sleep_cond)
(26,agents)
(27,ast_mutex_unlock(&p->lock)
(28,p)
(29,dead)
(30,ast_strlen_zero(tmp_moh)
(31,ast_indicate_data(indicate_chan, AST_CONTROL_HOLD,\n\\n\\t\\t\\tS_OR(tmp_moh, NULL)
(32,NULL)
(33,p)
(34,p->agent)
(35,moh)
(36,1)
(37,p->chan)
(38,p->lock)
(39,login_wait_cond)
(40,p->chan)
(41,if (p->dead)
(42,indicate_chan)
(43,if (p->start && (ast_channel_state(ast)
(44,RET)
(45,"Agent/%s")
(46,ast_tvadd(ast_tvnow()
(47,p)
(48,p)
(49,p->app_sleep_cond = 1)
(50,p->start && (ast_channel_state(ast)
(51,p->abouttograb)
(52,p->lock)
(53,ast_samp2tv(p->wrapuptime, 1000)
(54,ast_channel_tech_pvt_set(ast, NULL)
(55,strlen(tmp_moh)
(56,&agents)
(57,)
(58,if (indicate_chan)
(59,NULL)
(60,)
(61,agent)
(62,1)
(63,ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT)
(64,p)
(65,if (p->chan)
(66,p->start)
(67,)
(68,p->lock)
(69,S_OR(tmp_moh, NULL)
(70,lock)
(71,p->dead)
(72,p->loginstart)
(73,p)
(74,strlen(tmp_moh)
(75,ast_state2str(ast_channel_state(ast)
(76,)
(77,p->app_lock_flag = 0)
(78,0)
(79,indicate_chan)
(80,p->start)
(81,AST_STATE_UP)
(82,p->app_sleep_cond)
(83,ast_tvnow()
(84,p)
(85,indicate_chan)
(86,list)
(87,\'\\0\')
(88,p)
(89,ast_strdupa(p->moh)
(90,p)
(91,p)
(92,agents)
(93,if (p->chan)
(94,lock)
(95,0)
(96,p)
(97,p)
(98,p->app_complete_cond)
(99,ast)
(100,p->abouttograb)
(101,p)
(102,p->chan)
(103,&p->lock)
(104,AST_DEVICE_NOT_INUSE)
(105,)
(106,p)
(107,ast_mutex_destroy(&p->lock)
(108,if (p->abouttograb)
(109,chan)
(110,0)
(111,p)
(112,lastdisc)
(113,app_lock_flag)
(114,*p = ast_channel_tech_pvt(ast)
(115,)
(116,p->logincallerid[0])
(117,logincallerid)
(118,p->lastdisc = ast_tvadd(ast_tvnow()
(119,)
(120,)
(121,!p->loginstart)
(122,p->login_wait_cond)
(123,if (!p->loginstart)
(124,tmp_moh)
(125,indicate_chan = ast_channel_unref(indicate_chan)
(126,p)
(127,0)
(128,)
(129,&p->app_complete_cond)
(130,p->lock)
(131,ast_cond_signal(&p->app_complete_cond)
(132,p)
(133,p)
(134,ast_cond_destroy(&p->app_complete_cond)
(135,p->start = 0)
(136,agents)
(137,AST_LIST_REMOVE(&agents, p, list)
(138,if (p->pending)
(139,p)
(140,indicate_chan)
(141,p)
(142,ast_channel_state(ast)
(143,start)
(144,tmp_moh)
(145,&p->lock)
(146,p->loginstart)
(147,p->moh)
(148,tmp_moh)
(149,0)
(150,p->acknowledged)
(151,)
(152,p)
(153,p)
(154,p)
(155,chan)
(156,lock)
(157,loginstart)
(158,tmp_moh = ast_strdupa(p->moh)
(159,AST_SOFTHANGUP_EXPLICIT)
(160,p->start = 0)
(161,p)
(162,p->abouttograb = 0)
(163,ast_channel_ref(p->chan)
(164,abouttograb)
(165,p)
(166,chan)
(167,tmp_moh)
(168,1000)
(169,ast_channel_state(ast)
(170,abouttograb)
(171,ast)
(172,p->wrapuptime)
(173,p->lock)
(174,p->lastdisc)
(175,)
(176,*indicate_chan = NULL)
(177,owner)
(178,p->chan)
(179,p)
(180,lock)
(181,"Hangup called for state %s\\n")
(182,p->pending)
(183,p->app_complete_cond)
(184,p->acknowledged = 0)
(185,AST_LIST_UNLOCK(&agents)
(186,p->app_lock_flag)
(187,struct ast_channel *ast)
(188,ast_mutex_unlock(&p->lock)
(189,AST_CONTROL_HOLD)
(190,p)
(191,p)
(192,indicate_chan)
(193,app_complete_cond)
(194,wrapuptime)
(195,0)
(196,loginstart)
(197,0)
(198,0)
(199,p->dead)
(200,p->logincallerid)
(201,pending)
(202,start)
(203,1)
(204,p)
(205,p)
(206,p)
(207,p)
(208,indicate_chan)
(209,lock)
(210,p)
(211,return 0;)
(212,NULL)
(213,ast_cond_destroy(&p->login_wait_cond)
(214,ast_channel_internal_bridged_channel_set(p->chan, NULL)
(215,)
(216,start)
(217,tmp_moh)
(218,ast)
(219,ast)
(220,acknowledged)
(221,&p->login_wait_cond)
(222,p)
(223,ast_channel_tech_pvt(ast)
(224,ast_mutex_lock(&p->lock)
(225,&p->lock)
(226,p->owner)
(227,p)
(228,&p->lock)
(229,indicate_chan = ast_channel_ref(p->chan)
(230,&agents)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^