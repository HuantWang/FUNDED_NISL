-----label-----
1
-----code-----
static proto_entry_t *
parse_single_entry(const char *s, const char *end_of_entry)
{
  proto_entry_t *out = tor_malloc_zero(sizeof(proto_entry_t));
  const char *equals;

  out->ranges = smartlist_new();

  if (BUG (!end_of_entry))
    end_of_entry = s + strlen(s); // LCOV_EXCL_LINE

  /* There must be an =. */
  equals = memchr(s, '=', end_of_entry - s);
  if (!equals)
    goto error;

  /* The name must be nonempty */
  if (equals == s)
    goto error;

  /* The name must not be longer than MAX_PROTOCOL_NAME_LENGTH. */
  if (equals - s > MAX_PROTOCOL_NAME_LENGTH) {
    log_warn(LD_NET, "When parsing a protocol entry, I got a very large "
             "protocol name. This is possibly an attack or a bug, unless "
             "the Tor network truly supports protocol names larger than "
             "%ud characters. The offending string was: %s",
             MAX_PROTOCOL_NAME_LENGTH, escaped(out->name));
    goto error;
  }
  out->name = tor_strndup(s, equals-s);

  tor_assert(equals < end_of_entry);

  s = equals + 1;
  while (s < end_of_entry) {
    const char *comma = memchr(s, ',', end_of_entry-s);
    proto_range_t *range = tor_malloc_zero(sizeof(proto_range_t));
    if (! comma)
      comma = end_of_entry;

    smartlist_add(out->ranges, range);
    if (parse_version_range(s, comma, &range->low, &range->high) < 0) {
      goto error;
    }

    s = comma;
    while (*s == ',' && s < end_of_entry)
      ++s;
  }

  return out;

 error:
  proto_entry_free(out);
  return NULL;
}
-----children-----
1,2
1,3
1,4
2,3
4,5
4,6
4,7
4,8
7,8
7,9
9,10
9,11
12,13
12,14
14,15
14,16
17,18
17,19
17,20
17,21
17,22
17,23
17,24
17,25
17,26
17,27
17,28
17,29
17,30
17,31
17,32
18,19
19,20
19,21
20,21
22,23
22,24
22,25
25,26
26,27
26,28
27,28
29,30
30,31
30,32
31,32
34,35
35,36
35,37
37,38
37,39
40,41
41,42
41,43
42,43
42,44
43,44
46,47
47,48
49,50
49,51
50,51
50,52
51,52
53,54
54,55
56,57
57,58
57,59
58,59
60,61
60,62
61,62
63,64
63,65
64,65
66,67
68,69
69,70
69,71
70,71
72,73
72,74
72,75
72,76
73,74
75,76
78,79
78,80
79,80
81,82
83,84
83,85
84,85
85,86
87,88
89,90
89,91
90,91
90,92
91,92
93,94
95,96
97,98
97,99
98,99
98,100
99,100
99,101
100,101
102,103
104,105
106,107
106,108
107,108
108,109
108,110
108,111
108,112
108,113
109,110
111,112
114,115
116,117
116,118
117,118
119,120
119,121
120,121
123,124
125,126
126,127
126,128
127,128
127,129
128,129
131,132
131,133
131,134
132,133
134,135
136,137
136,138
137,138
139,140
141,142
142,143
142,144
143,144
145,146
145,147
146,147
148,149
150,151
151,152
151,153
152,153
154,155
154,156
155,156
158,159
158,160
159,160
159,161
160,161
162,163
164,165
164,166
164,167
164,168
164,169
164,170
164,171
165,166
166,167
166,168
168,169
168,170
168,171
171,172
172,173
172,174
172,175
172,176
173,174
175,176
178,179
178,180
179,180
181,182
183,184
184,185
184,186
185,186
187,188
187,189
187,190
190,191
191,192
191,193
192,193
194,195
195,196
195,197
196,197
199,200
199,201
200,201
201,202
203,204
204,205
204,206
205,206
207,208
209,210
210,211
210,212
210,213
211,212
213,214
213,215
214,215
217,218
219,220
219,221
220,221
220,222
221,222
221,223
221,224
221,225
221,226
222,223
224,225
226,227
228,229
229,230
229,231
230,231
233,234
234,235
234,236
235,236
239,240
240,241
242,243
243,244
243,245
244,245
246,247
248,249
248,250
249,250
249,251
250,251
250,252
251,252
252,253
255,256
255,257
256,257
258,259
260,261
261,262
262,263
264,265
265,266
267,268
267,269
269,270
270,271
270,272
271,272
273,274
275,276
276,277
-----nextToken-----
3,5,6,8,10,11,13,15,16,21,23,24,28,32,33,36,38,39,44,45,48,52,55,59,62,65,67,71,74,76,77,80,82,86,88,92,94,96,101,103,105,110,112,113,115,118,121,122,124,129,130,133,135,138,140,144,147,149,153,156,157,161,163,167,169,170,174,176,177,180,182,186,188,189,193,197,198,202,206,208,212,215,216,218,223,225,227,231,232,236,237,238,241,245,247,253,254,257,259,263,266,268,272,274,277
-----computeFrom-----
41,42
41,43
57,58
57,59
60,61
60,62
69,70
69,71
78,79
78,80
90,91
90,92
98,99
98,100
99,100
99,101
126,127
126,128
136,137
136,138
145,146
145,147
151,152
151,153
154,155
154,156
159,160
159,161
178,179
178,180
204,205
204,206
220,221
220,222
243,244
243,245
249,250
249,251
250,251
250,252
255,256
255,257
-----guardedBy-----
105,115
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;NamedTypeSpecifier;Name;FunctionDeclarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;GotoStatement;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;GotoStatement;Name;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;GotoStatement;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;WhileStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;IfStatement;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;GotoStatement;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;WhileStatement;BinaryExpression;BinaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;UnaryExpression;IdExpression;Name;ReturnStatement;IdExpression;Name;LabelStatement;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;IdExpression;Name;
-----ast_node-----
static proto_entry_t *parse_single_entry(const char *s, const char *end_of_entry){  proto_entry_t *out = tor_malloc_zero(sizeof(proto_entry_t));  const char *equals;  out->ranges = smartlist_new();  if (BUG (!end_of_entry))    end_of_entry = s + strlen(s); // LCOV_EXCL_LINE  /* There must be an =. */  equals = memchr(s, '=', end_of_entry - s);  if (!equals)    goto error;  /* The name must be nonempty */  if (equals == s)    goto error;  /* The name must not be longer than MAX_PROTOCOL_NAME_LENGTH. */  if (equals - s > MAX_PROTOCOL_NAME_LENGTH) {    log_warn(LD_NET, "When parsing a protocol entry, I got a very large "             "protocol name. This is possibly an attack or a bug, unless "             "the Tor network truly supports protocol names larger than "             "%ud characters. The offending string was: %s",             MAX_PROTOCOL_NAME_LENGTH, escaped(out->name));    goto error;  }  out->name = tor_strndup(s, equals-s);  tor_assert(equals < end_of_entry);  s = equals + 1;  while (s < end_of_entry) {    const char *comma = memchr(s, ',', end_of_entry-s);    proto_range_t *range = tor_malloc_zero(sizeof(proto_range_t));    if (! comma)      comma = end_of_entry;    smartlist_add(out->ranges, range);    if (parse_version_range(s, comma, &range->low, &range->high) < 0) {      goto error;    }    s = comma;    while (*s == ',' && s < end_of_entry)      ++s;  }  return out; error:  proto_entry_free(out);  return NULL;}
static proto_entry_t
proto_entry_t
*parse_single_entry(const char *s, const char *end_of_entry)
*
parse_single_entry
const char *s
const char
*s
*
s
const char *end_of_entry
const char
*end_of_entry
*
end_of_entry
{  proto_entry_t *out = tor_malloc_zero(sizeof(proto_entry_t));  const char *equals;  out->ranges = smartlist_new();  if (BUG (!end_of_entry))    end_of_entry = s + strlen(s); // LCOV_EXCL_LINE  /* There must be an =. */  equals = memchr(s, '=', end_of_entry - s);  if (!equals)    goto error;  /* The name must be nonempty */  if (equals == s)    goto error;  /* The name must not be longer than MAX_PROTOCOL_NAME_LENGTH. */  if (equals - s > MAX_PROTOCOL_NAME_LENGTH) {    log_warn(LD_NET, "When parsing a protocol entry, I got a very large "             "protocol name. This is possibly an attack or a bug, unless "             "the Tor network truly supports protocol names larger than "             "%ud characters. The offending string was: %s",             MAX_PROTOCOL_NAME_LENGTH, escaped(out->name));    goto error;  }  out->name = tor_strndup(s, equals-s);  tor_assert(equals < end_of_entry);  s = equals + 1;  while (s < end_of_entry) {    const char *comma = memchr(s, ',', end_of_entry-s);    proto_range_t *range = tor_malloc_zero(sizeof(proto_range_t));    if (! comma)      comma = end_of_entry;    smartlist_add(out->ranges, range);    if (parse_version_range(s, comma, &range->low, &range->high) < 0) {      goto error;    }    s = comma;    while (*s == ',' && s < end_of_entry)      ++s;  }  return out; error:  proto_entry_free(out);  return NULL;}
proto_entry_t *out = tor_malloc_zero(sizeof(proto_entry_t));
proto_entry_t *out = tor_malloc_zero(sizeof(proto_entry_t));
proto_entry_t
proto_entry_t
*out = tor_malloc_zero(sizeof(proto_entry_t))
*
out
= tor_malloc_zero(sizeof(proto_entry_t))
tor_malloc_zero(sizeof(proto_entry_t))
tor_malloc_zero
tor_malloc_zero
sizeof(proto_entry_t)
proto_entry_t
proto_entry_t
proto_entry_t

const char *equals;
const char *equals;
const char
*equals
*
equals
out->ranges = smartlist_new();
out->ranges = smartlist_new()
out->ranges
out
out
ranges
smartlist_new()
smartlist_new
smartlist_new
if (BUG (!end_of_entry))    end_of_entry = s + strlen(s);
BUG (!end_of_entry)
BUG
BUG
!end_of_entry
end_of_entry
end_of_entry
end_of_entry = s + strlen(s);
end_of_entry = s + strlen(s)
end_of_entry
end_of_entry
s + strlen(s)
s
s
strlen(s)
strlen
strlen
s
s
equals = memchr(s, '=', end_of_entry - s);
equals = memchr(s, '=', end_of_entry - s)
equals
equals
memchr(s, '=', end_of_entry - s)
memchr
memchr
s
s
'='
end_of_entry - s
end_of_entry
end_of_entry
s
s
if (!equals)    goto error;
!equals
equals
equals
goto error;
error
if (equals == s)    goto error;
equals == s
equals
equals
s
s
goto error;
error
if (equals - s > MAX_PROTOCOL_NAME_LENGTH) {    log_warn(LD_NET, "When parsing a protocol entry, I got a very large "             "protocol name. This is possibly an attack or a bug, unless "             "the Tor network truly supports protocol names larger than "             "%ud characters. The offending string was: %s",             MAX_PROTOCOL_NAME_LENGTH, escaped(out->name));    goto error;  }
equals - s > MAX_PROTOCOL_NAME_LENGTH
equals - s
equals
equals
s
s
MAX_PROTOCOL_NAME_LENGTH
MAX_PROTOCOL_NAME_LENGTH
{    log_warn(LD_NET, "When parsing a protocol entry, I got a very large "             "protocol name. This is possibly an attack or a bug, unless "             "the Tor network truly supports protocol names larger than "             "%ud characters. The offending string was: %s",             MAX_PROTOCOL_NAME_LENGTH, escaped(out->name));    goto error;  }
log_warn(LD_NET, "When parsing a protocol entry, I got a very large "             "protocol name. This is possibly an attack or a bug, unless "             "the Tor network truly supports protocol names larger than "             "%ud characters. The offending string was: %s",             MAX_PROTOCOL_NAME_LENGTH, escaped(out->name));
log_warn(LD_NET, "When parsing a protocol entry, I got a very large "             "protocol name. This is possibly an attack or a bug, unless "             "the Tor network truly supports protocol names larger than "             "%ud characters. The offending string was: %s",             MAX_PROTOCOL_NAME_LENGTH, escaped(out->name))
log_warn
log_warn
LD_NET
LD_NET
"When parsing a protocol entry, I got a very large "             "protocol name. This is possibly an attack or a bug, unless "             "the Tor network truly supports protocol names larger than "             "%ud characters. The offending string was: %s"
MAX_PROTOCOL_NAME_LENGTH
MAX_PROTOCOL_NAME_LENGTH
escaped(out->name)
escaped
escaped
out->name
out
out
name
goto error;
error
out->name = tor_strndup(s, equals-s);
out->name = tor_strndup(s, equals-s)
out->name
out
out
name
tor_strndup(s, equals-s)
tor_strndup
tor_strndup
s
s
equals-s
equals
equals
s
s
tor_assert(equals < end_of_entry);
tor_assert(equals < end_of_entry)
tor_assert
tor_assert
equals < end_of_entry
equals
equals
end_of_entry
end_of_entry
s = equals + 1;
s = equals + 1
s
s
equals + 1
equals
equals
1
while (s < end_of_entry) {    const char *comma = memchr(s, ',', end_of_entry-s);    proto_range_t *range = tor_malloc_zero(sizeof(proto_range_t));    if (! comma)      comma = end_of_entry;    smartlist_add(out->ranges, range);    if (parse_version_range(s, comma, &range->low, &range->high) < 0) {      goto error;    }    s = comma;    while (*s == ',' && s < end_of_entry)      ++s;  }
s < end_of_entry
s
s
end_of_entry
end_of_entry
{    const char *comma = memchr(s, ',', end_of_entry-s);    proto_range_t *range = tor_malloc_zero(sizeof(proto_range_t));    if (! comma)      comma = end_of_entry;    smartlist_add(out->ranges, range);    if (parse_version_range(s, comma, &range->low, &range->high) < 0) {      goto error;    }    s = comma;    while (*s == ',' && s < end_of_entry)      ++s;  }
const char *comma = memchr(s, ',', end_of_entry-s);
const char *comma = memchr(s, ',', end_of_entry-s);
const char
*comma = memchr(s, ',', end_of_entry-s)
*
comma
= memchr(s, ',', end_of_entry-s)
memchr(s, ',', end_of_entry-s)
memchr
memchr
s
s
','
end_of_entry-s
end_of_entry
end_of_entry
s
s
proto_range_t *range = tor_malloc_zero(sizeof(proto_range_t));
proto_range_t *range = tor_malloc_zero(sizeof(proto_range_t));
proto_range_t
proto_range_t
*range = tor_malloc_zero(sizeof(proto_range_t))
*
range
= tor_malloc_zero(sizeof(proto_range_t))
tor_malloc_zero(sizeof(proto_range_t))
tor_malloc_zero
tor_malloc_zero
sizeof(proto_range_t)
proto_range_t
proto_range_t
proto_range_t

if (! comma)      comma = end_of_entry;
! comma
comma
comma
comma = end_of_entry;
comma = end_of_entry
comma
comma
end_of_entry
end_of_entry
smartlist_add(out->ranges, range);
smartlist_add(out->ranges, range)
smartlist_add
smartlist_add
out->ranges
out
out
ranges
range
range
if (parse_version_range(s, comma, &range->low, &range->high) < 0) {      goto error;    }
parse_version_range(s, comma, &range->low, &range->high) < 0
parse_version_range(s, comma, &range->low, &range->high)
parse_version_range
parse_version_range
s
s
comma
comma
&range->low
range->low
range
range
low
&range->high
range->high
range
range
high
0
{      goto error;    }
goto error;
error
s = comma;
s = comma
s
s
comma
comma
while (*s == ',' && s < end_of_entry)      ++s;
*s == ',' && s < end_of_entry
*s == ','
*s
s
s
','
s < end_of_entry
s
s
end_of_entry
end_of_entry
++s;
++s
s
s
return out;
out
out
error:  proto_entry_free(out);
error
proto_entry_free(out);
proto_entry_free(out)
proto_entry_free
proto_entry_free
out
out
return NULL;
NULL
NULL
-----joern-----
(83,81,0)
(118,67,0)
(143,120,0)
(71,80,0)
(58,130,0)
(68,84,0)
(84,59,0)
(111,67,0)
(135,56,0)
(126,137,0)
(22,90,0)
(96,138,0)
(102,97,0)
(114,81,0)
(61,109,0)
(93,10,0)
(119,61,0)
(72,111,0)
(115,109,0)
(138,109,0)
(140,17,0)
(40,10,0)
(120,123,0)
(7,61,0)
(86,41,0)
(34,15,0)
(68,107,0)
(6,109,0)
(94,109,0)
(84,141,0)
(70,141,0)
(90,61,0)
(94,10,0)
(100,70,0)
(85,68,0)
(18,10,0)
(92,6,0)
(117,137,0)
(136,17,0)
(64,62,0)
(143,109,0)
(35,126,0)
(132,68,0)
(129,122,0)
(142,115,0)
(41,13,0)
(30,41,0)
(51,138,0)
(54,139,0)
(89,10,0)
(75,81,0)
(32,89,0)
(79,95,0)
(22,17,0)
(144,73,0)
(38,72,0)
(73,94,0)
(89,32,0)
(49,114,0)
(134,72,0)
(107,68,0)
(81,109,0)
(47,64,0)
(68,67,0)
(59,109,0)
(37,94,0)
(56,135,0)
(25,15,0)
(1,64,0)
(40,126,0)
(40,41,0)
(101,73,0)
(46,129,0)
(61,22,0)
(106,112,0)
(12,104,0)
(33,109,0)
(113,126,0)
(124,17,0)
(91,10,0)
(122,129,0)
(138,33,0)
(125,49,0)
(81,95,0)
(63,22,0)
(112,67,0)
(44,62,0)
(139,17,0)
(26,117,0)
(143,61,0)
(59,6,0)
(50,67,0)
(13,10,0)
(80,67,0)
(112,109,0)
(45,10,0)
(5,21,0)
(61,95,0)
(122,64,0)
(49,140,0)
(77,130,0)
(139,140,0)
(97,102,0)
(72,141,0)
(121,10,0)
(115,141,0)
(12,140,0)
(29,19,0)
(25,137,0)
(15,25,0)
(90,109,0)
(14,84,0)
(111,72,0)
(50,94,0)
(16,90,0)
(90,22,0)
(33,13,0)
(114,49,0)
(131,49,0)
(19,22,0)
(61,17,0)
(42,70,0)
(53,61,0)
(137,25,0)
(68,141,0)
(81,104,0)
(70,90,0)
(31,12,0)
(95,141,0)
(130,139,0)
(99,80,0)
(72,84,0)
(41,137,0)
(9,112,0)
(13,33,0)
(73,84,0)
(59,84,0)
(130,137,0)
(102,140,0)
(81,83,0)
(127,7,0)
(57,80,0)
(3,67,0)
(21,137,0)
(94,50,0)
(95,84,0)
(70,61,0)
(28,40,0)
(120,143,0)
(80,109,0)
(111,109,0)
(104,81,0)
(133,111,0)
(116,3,0)
(76,12,0)
(129,137,0)
(108,111,0)
(2,10,0)
(11,10,0)
(60,17,0)
(72,109,0)
(81,22,0)
(105,64,0)
(70,109,0)
(115,123,0)
(123,115,0)
(8,20,0)
(87,143,0)
(107,10,0)
(130,89,0)
(90,94,0)
(33,138,0)
(80,99,0)
(103,95,0)
(52,137,0)
(66,115,0)
(21,10,0)
(104,12,0)
(65,83,0)
(88,33,0)
(115,84,0)
(48,59,0)
(70,84,0)
(67,10,0)
(98,129,0)
(138,67,0)
(74,56,0)
(126,89,0)
(27,81,0)
(24,50,0)
(4,50,0)
(128,120,0)
(139,130,0)
(6,59,0)
(70,94,0)
(140,102,0)
(56,141,0)
(137,10,0)
(26,40,0)
(7,109,0)
(81,61,0)
(73,109,0)
(64,122,0)
(55,140,0)
(67,111,0)
(81,94,0)
(73,141,0)
(43,90,0)
(90,70,0)
(123,120,0)
(39,17,0)
(110,97,0)
(117,10,0)
(23,17,0)
(73,61,0)
(82,117,0)
(78,10,0)
(81,114,0)
(69,99,0)
(115,61,0)
(99,69,1)
(129,137,1)
(31,114,1)
(111,72,1)
(114,49,1)
(144,123,1)
(28,21,1)
(143,109,1)
(107,68,1)
(68,85,1)
(0,3,1)
(6,92,1)
(108,118,1)
(73,101,1)
(68,141,1)
(100,43,1)
(40,28,1)
(139,130,1)
(9,3,1)
(7,109,1)
(58,95,1)
(130,77,1)
(6,109,1)
(68,84,1)
(95,84,1)
(88,41,1)
(15,34,1)
(80,67,1)
(27,139,1)
(76,31,1)
(68,67,1)
(142,120,1)
(41,137,1)
(81,94,1)
(70,61,1)
(67,111,1)
(59,6,1)
(113,35,1)
(119,53,1)
(64,122,1)
(37,107,1)
(89,32,1)
(43,16,1)
(138,67,1)
(69,80,1)
(85,132,1)
(70,94,1)
(126,137,1)
(44,64,1)
(102,97,1)
(117,137,1)
(123,120,1)
(73,94,1)
(50,24,1)
(72,134,1)
(61,95,1)
(22,90,1)
(70,42,1)
(138,109,1)
(70,84,1)
(103,19,1)
(115,141,1)
(105,47,1)
(72,141,1)
(133,108,1)
(8,83,1)
(26,40,1)
(66,142,1)
(83,65,1)
(81,22,1)
(96,51,1)
(32,126,1)
(132,13,1)
(51,88,1)
(84,141,1)
(72,84,1)
(95,141,1)
(29,140,1)
(83,81,1)
(90,94,1)
(75,27,1)
(139,54,1)
(36,112,1)
(123,115,1)
(112,109,1)
(57,112,1)
(35,137,1)
(56,141,1)
(30,86,1)
(130,89,1)
(33,109,1)
(115,109,1)
(55,22,1)
(5,0,1)
(115,66,1)
(54,130,1)
(81,114,1)
(24,4,1)
(104,12,1)
(3,116,1)
(125,131,1)
(73,109,1)
(110,55,1)
(71,57,1)
(130,137,1)
(116,67,1)
(19,29,1)
(98,105,1)
(21,5,1)
(1,99,1)
(73,61,1)
(94,50,1)
(139,140,1)
(25,15,1)
(135,56,1)
(61,109,1)
(53,83,1)
(128,143,1)
(46,98,1)
(81,109,1)
(73,141,1)
(12,76,1)
(92,48,1)
(41,30,1)
(40,41,1)
(59,109,1)
(134,38,1)
(34,52,1)
(90,109,1)
(120,143,1)
(4,37,1)
(61,22,1)
(70,141,1)
(115,61,1)
(94,109,1)
(137,25,1)
(84,59,1)
(38,133,1)
(80,109,1)
(16,63,1)
(58,19,1)
(87,7,1)
(19,22,1)
(21,137,1)
(79,103,1)
(117,82,1)
(14,135,1)
(129,46,1)
(112,67,1)
(33,138,1)
(77,58,1)
(118,135,1)
(50,67,1)
(97,110,1)
(74,89,1)
(40,126,1)
(87,61,1)
(127,123,1)
(131,75,1)
(101,144,1)
(49,125,1)
(5,36,1)
(143,87,1)
(140,102,1)
(3,67,1)
(72,109,1)
(99,80,1)
(106,9,1)
(86,99,1)
(7,127,1)
(112,106,1)
(122,129,1)
(90,70,1)
(138,96,1)
(73,84,1)
(56,74,1)
(7,61,1)
(61,119,1)
(82,73,1)
(115,84,1)
(12,140,1)
(90,61,1)
(5,44,1)
(80,71,1)
(26,117,1)
(63,73,1)
(47,1,1)
(70,109,1)
(42,100,1)
(111,109,1)
(81,104,1)
(118,84,1)
(81,61,1)
(144,94,1)
(65,81,1)
(5,8,1)
(143,61,1)
(81,95,1)
(13,33,1)
(120,128,1)
(49,140,1)
(48,14,1)
(126,113,1)
(95,79,1)
(120,143,2)
(29,73,2)
(61,95,2)
(7,61,2)
(135,56,2)
(19,22,2)
(81,61,2)
(89,32,2)
(40,3,2)
(130,137,2)
(144,83,2)
(90,109,2)
(61,22,2)
(87,123,2)
(143,61,2)
(9,3,2)
(129,137,2)
(94,99,2)
(12,73,2)
(16,73,2)
(66,120,2)
(132,99,2)
(77,73,2)
(57,112,2)
(21,137,2)
(40,112,2)
(111,109,2)
(59,135,2)
(67,111,2)
(95,84,2)
(58,73,2)
(140,102,2)
(70,109,2)
(59,109,2)
(50,67,2)
(22,90,2)
(90,70,2)
(138,67,2)
(7,109,2)
(94,50,2)
(139,140,2)
(84,141,2)
(0,3,2)
(139,130,2)
(122,99,2)
(104,12,2)
(100,73,2)
(143,83,2)
(68,84,2)
(115,141,2)
(102,73,2)
(44,99,2)
(81,95,2)
(73,99,2)
(61,109,2)
(88,99,2)
(43,73,2)
(79,19,2)
(63,73,2)
(7,123,2)
(115,109,2)
(59,6,2)
(87,83,2)
(73,83,2)
(106,3,2)
(123,115,2)
(112,67,2)
(76,73,2)
(5,112,2)
(143,123,2)
(107,68,2)
(92,135,2)
(95,141,2)
(81,22,2)
(21,83,2)
(36,112,2)
(28,3,2)
(70,84,2)
(81,94,2)
(68,141,2)
(72,109,2)
(4,99,2)
(14,135,2)
(54,73,2)
(3,67,2)
(1,99,2)
(99,80,2)
(73,109,2)
(114,73,2)
(73,84,2)
(130,73,2)
(142,120,2)
(51,99,2)
(90,73,2)
(46,99,2)
(104,73,2)
(128,83,2)
(97,73,2)
(28,83,2)
(5,83,2)
(138,99,2)
(21,99,2)
(117,137,2)
(119,83,2)
(41,99,2)
(53,83,2)
(64,122,2)
(125,73,2)
(96,99,2)
(41,137,2)
(37,99,2)
(25,15,2)
(144,99,2)
(112,109,2)
(70,94,2)
(6,135,2)
(27,73,2)
(94,109,2)
(114,49,2)
(64,99,2)
(115,61,2)
(8,83,2)
(81,109,2)
(28,99,2)
(73,141,2)
(47,99,2)
(72,141,2)
(49,73,2)
(84,59,2)
(143,109,2)
(13,99,2)
(126,137,2)
(131,73,2)
(30,99,2)
(21,112,2)
(115,84,2)
(56,141,2)
(117,73,2)
(40,83,2)
(42,73,2)
(123,83,2)
(128,123,2)
(73,61,2)
(84,135,2)
(127,123,2)
(21,3,2)
(130,89,2)
(98,99,2)
(19,73,2)
(5,3,2)
(72,84,2)
(13,33,2)
(83,73,2)
(82,73,2)
(48,135,2)
(112,3,2)
(26,40,2)
(40,41,2)
(120,123,2)
(33,109,2)
(139,73,2)
(40,99,2)
(61,83,2)
(111,72,2)
(137,25,2)
(22,73,2)
(26,117,2)
(120,83,2)
(80,109,2)
(55,73,2)
(123,123,2)
(86,99,2)
(138,109,2)
(122,129,2)
(103,19,2)
(81,114,2)
(69,112,2)
(33,138,2)
(80,67,2)
(40,126,2)
(75,73,2)
(81,73,2)
(83,81,2)
(105,99,2)
(123,120,2)
(50,99,2)
(95,19,2)
(90,94,2)
(80,112,2)
(102,97,2)
(101,99,2)
(140,73,2)
(70,61,2)
(70,73,2)
(70,141,2)
(5,99,2)
(65,73,2)
(107,99,2)
(68,67,2)
(28,112,2)
(24,99,2)
(115,120,2)
(33,99,2)
(90,61,2)
(71,112,2)
(12,140,2)
(101,83,2)
(110,73,2)
(99,112,2)
(31,73,2)
(85,99,2)
(49,140,2)
(68,99,2)
(6,109,2)
(129,99,2)
(81,104,2)
(73,94,2)
-----------------------------------
(0,goto error;)
(1,LD_NET)
(2,if (BUG (!end_of_entry)
(3,!equals)
(4,equals)
(5,out)
(6,strlen(s)
(7,++s)
(8,goto error;)
(9,equals)
(10,)
(11,while (s < end_of_entry)
(12,range->high)
(13,out->name = tor_strndup(s, equals-s)
(14,end_of_entry)
(15,sizeof(proto_entry_t)
(16,s)
(17,)
(18,out)
(19,! comma)
(20,)
(21,proto_entry_free(out)
(22,*comma = memchr(s, \',\', end_of_entry-s)
(23,comma)
(24,1)
(25,tor_malloc_zero(sizeof(proto_entry_t)
(26,RET)
(27,s)
(28,NULL)
(29,comma)
(30,name)
(31,range)
(32,smartlist_new()
(33,tor_strndup(s, equals-s)
(34,proto_entry_t)
(35,out)
(36,goto error;)
(37,s)
(38,end_of_entry)
(39,if (parse_version_range(s, comma, &range->low, &range->high)
(40,return NULL;)
(41,out->name)
(42,s)
(43,\',\')
(44,goto error;)
(45,if (equals - s > MAX_PROTOCOL_NAME_LENGTH)
(46,name)
(47,"When parsing a protocol entry, I got a very large "\n\\n             "protocol name. This is possibly an attack or a bug, unless "\n\\n             "the Tor network truly supports protocol names larger than "\n\\n             "%ud characters. The offending string was: %s")
(48,s)
(49,range->low)
(50,equals + 1)
(51,equals)
(52,out)
(53,s)
(54,range)
(55,range)
(56,!end_of_entry)
(57,equals)
(58,out)
(59,s + strlen(s)
(60,if (! comma)
(61,s = comma)
(62,)
(63,comma)
(64,log_warn(LD_NET, "When parsing a protocol entry, I got a very large "\n\\n             "protocol name. This is possibly an attack or a bug, unless "\n\\n             "the Tor network truly supports protocol names larger than "\n\\n             "%ud characters. The offending string was: %s",\n\\n             MAX_PROTOCOL_NAME_LENGTH, escaped(out->name)
(65,0)
(66,end_of_entry)
(67,equals = memchr(s, \'=\', end_of_entry - s)
(68,equals < end_of_entry)
(69,MAX_PROTOCOL_NAME_LENGTH)
(70,end_of_entry-s)
(71,s)
(72,end_of_entry - s)
(73,s < end_of_entry)
(74,end_of_entry)
(75,comma)
(76,high)
(77,ranges)
(78,equals)
(79,end_of_entry)
(80,equals - s)
(81,parse_version_range(s, comma, &range->low, &range->high)
(82,out)
(83,parse_version_range(s, comma, &range->low, &range->high)
(84,end_of_entry = s + strlen(s)
(85,end_of_entry)
(86,out)
(87,s)
(88,s)
(89,out->ranges = smartlist_new()
(90,memchr(s, \',\', end_of_entry-s)
(91,if (!equals)
(92,s)
(93,if (equals == s)
(94,s = equals + 1)
(95,comma = end_of_entry)
(96,s)
(97,sizeof(proto_range_t)
(98,out)
(99,equals - s > MAX_PROTOCOL_NAME_LENGTH)
(100,end_of_entry)
(101,end_of_entry)
(102,tor_malloc_zero(sizeof(proto_range_t)
(103,comma)
(104,&range->high)
(105,MAX_PROTOCOL_NAME_LENGTH)
(106,s)
(107,tor_assert(equals < end_of_entry)
(108,s)
(109,const char *s)
(110,proto_range_t)
(111,memchr(s, \'=\', end_of_entry - s)
(112,equals == s)
(113,ranges)
(114,&range->low)
(115,s < end_of_entry)
(116,equals)
(117,return out;)
(118,equals)
(119,comma)
(120,*s == \',\')
(121,error:)
(122,escaped(out->name)
(123,*s == \',\' && s < end_of_entry)
(124,range)
(125,low)
(126,out->ranges)
(127,s)
(128,\',\')
(129,out->name)
(130,out->ranges)
(131,range)
(132,equals)
(133,\'=\')
(134,s)
(135,BUG (!end_of_entry)
(136,while (*s == \',\' && s < end_of_entry)
(137,*out = tor_malloc_zero(sizeof(proto_entry_t)
(138,equals-s)
(139,smartlist_add(out->ranges, range)
(140,*range = tor_malloc_zero(sizeof(proto_range_t)
(141,const char *end_of_entry)
(142,s)
(143,*s)
(144,s)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^