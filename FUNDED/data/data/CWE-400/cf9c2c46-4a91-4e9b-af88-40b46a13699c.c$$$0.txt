-----label-----
0
-----code-----
static struct ast_frame *agent_read(struct ast_channel *ast)
{
	struct agent_pvt *p = ast_channel_tech_pvt(ast);
	struct ast_frame *f = NULL;
	static struct ast_frame answer_frame = { AST_FRAME_CONTROL, { AST_CONTROL_ANSWER } };
	int cur_time = time(NULL);
	struct ast_channel *owner;

	ast_mutex_lock(&p->lock);
	owner = agent_lock_owner(p);

	CHECK_FORMATS(ast, p);
	if (!p->start) {
		p->start = cur_time;
	}
	if (p->chan) {
		ast_copy_flags(ast_channel_flags(p->chan), ast_channel_flags(ast), AST_FLAG_EXCEPTION);
		ast_channel_fdno_set(p->chan, (ast_channel_fdno(ast) == AST_AGENT_FD) ? AST_TIMING_FD : ast_channel_fdno(ast));
		f = ast_read(p->chan);
	} else
		f = &ast_null_frame;
	if (!f) {
		/* If there's a channel, make it NULL */
		if (p->chan) {
			ast_channel_internal_bridged_channel_set(p->chan, NULL);
			p->chan = NULL;
			ast_devstate_changed(AST_DEVICE_UNAVAILABLE, "Agent/%s", p->agent);
			p->acknowledged = 0;
		}
	} else {
		/* if acknowledgement is not required, and the channel is up, we may have missed
			an AST_CONTROL_ANSWER (if there was one), so mark the call acknowledged anyway */
		if (!p->ackcall && !p->acknowledged && p->chan && (ast_channel_state(p->chan) == AST_STATE_UP)) {
			p->acknowledged = 1;
		}

		if (!p->acknowledged) {
			int howlong = cur_time - p->start;
			if (p->autologoff && (howlong >= p->autologoff)) {
				ast_log(LOG_NOTICE, "Agent '%s' didn't answer/confirm within %d seconds (waited %d)\n", p->name, p->autologoff, howlong);
				if (owner || p->chan) {
					if (owner) {
						ast_softhangup(owner, AST_SOFTHANGUP_EXPLICIT);
						ast_channel_unlock(owner);
						owner = ast_channel_unref(owner);
					}

					while (p->chan && ast_channel_trylock(p->chan)) {
						DEADLOCK_AVOIDANCE(&p->lock);
					}
					if (p->chan) {
						ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);
						ast_channel_unlock(p->chan);
					}
				}
			}
		}
		switch (f->frametype) {
		case AST_FRAME_CONTROL:
			if (f->subclass.integer == AST_CONTROL_ANSWER) {
				if (p->ackcall) {
					ast_verb(3, "%s answered, waiting for '%c' to acknowledge\n", ast_channel_name(p->chan), p->acceptdtmf);
					/* Don't pass answer along */
					ast_frfree(f);
					f = &ast_null_frame;
				} else {
					p->acknowledged = 1;
					/* Use the builtin answer frame for the 
					   recording start check below. */
					ast_frfree(f);
					f = &answer_frame;
				}
			}
			break;
		case AST_FRAME_DTMF_BEGIN:
			/*ignore DTMF begin's as it can cause issues with queue announce files*/
			if((!p->acknowledged && f->subclass.integer == p->acceptdtmf) || (f->subclass.integer == p->enddtmf && endcall)){
				ast_frfree(f);
				f = &ast_null_frame;
			}
			break;
		case AST_FRAME_DTMF_END:
			if (!p->acknowledged && (f->subclass.integer == p->acceptdtmf)) {
				if (p->chan) {
					ast_verb(3, "%s acknowledged\n", ast_channel_name(p->chan));
				}
				p->acknowledged = 1;
				ast_frfree(f);
				f = &answer_frame;
			} else if (f->subclass.integer == p->enddtmf && endcall) {
				/* terminates call */
				ast_frfree(f);
				f = NULL;
			}
			break;
		case AST_FRAME_VOICE:
		case AST_FRAME_VIDEO:
			/* don't pass voice or video until the call is acknowledged */
			if (!p->acknowledged) {
				ast_frfree(f);
				f = &ast_null_frame;
			}
		default:
			/* pass everything else on through */
			break;
		}
	}

	if (owner) {
		ast_channel_unlock(owner);
		owner = ast_channel_unref(owner);
	}

	CLEANUP(ast,p);
	if (p->chan && !ast_channel_internal_bridged_channel(p->chan)) {
		if (strcasecmp(ast_channel_tech(p->chan)->type, "Local")) {
			ast_channel_internal_bridged_channel_set(p->chan, ast);
			if (p->chan)
				ast_debug(1, "Bridge on '%s' being set to '%s' (3)\n", ast_channel_name(p->chan), ast_channel_name(ast_channel_internal_bridged_channel(p->chan)));
		}
	}
	ast_mutex_unlock(&p->lock);
	if (recordagentcalls && f == &answer_frame)
		agent_start_monitoring(ast,0);
	return f;
}
-----children-----
1,2
1,3
1,4
2,3
4,5
4,6
4,7
7,8
7,9
8,9
10,11
10,12
13,14
13,15
13,16
13,17
13,18
13,19
13,20
13,21
13,22
13,23
13,24
13,25
13,26
13,27
13,28
13,29
13,30
14,15
15,16
15,17
16,17
18,19
18,20
18,21
21,22
22,23
22,24
23,24
25,26
27,28
28,29
28,30
29,30
31,32
31,33
31,34
34,35
35,36
37,38
38,39
38,40
39,40
41,42
41,43
43,44
44,45
44,46
45,46
47,48
48,49
50,51
51,52
51,53
53,54
53,55
55,56
56,57
56,58
57,58
59,60
61,62
62,63
62,64
63,64
65,66
65,67
68,69
69,70
69,71
70,71
72,73
73,74
73,75
74,75
77,78
78,79
78,80
79,80
81,82
81,83
82,83
84,85
86,87
87,88
87,89
87,90
88,89
90,91
92,93
94,95
94,96
95,96
96,97
96,98
97,98
100,101
101,102
102,103
102,104
103,104
103,105
104,105
107,108
109,110
109,111
109,112
110,111
110,112
111,112
114,115
114,116
114,117
115,116
116,117
116,118
116,119
116,120
117,118
119,120
119,121
120,121
122,123
122,124
123,124
126,127
126,128
127,128
129,130
131,132
133,134
134,135
134,136
134,137
135,136
137,138
137,139
138,139
141,142
141,143
141,144
142,143
143,144
143,145
144,145
144,146
145,146
147,148
149,150
151,152
153,154
153,155
154,155
156,157
158,159
159,160
159,161
160,161
162,163
162,164
163,164
165,166
165,167
166,167
169,170
170,171
170,172
171,172
173,174
174,175
176,177
176,178
176,179
177,178
178,179
180,181
181,182
181,183
182,183
182,184
183,184
186,187
186,188
186,189
186,190
187,188
188,189
188,190
188,191
189,190
191,192
191,193
192,193
195,196
197,198
198,199
198,200
199,200
199,201
200,201
203,204
205,206
206,207
206,208
206,209
206,210
207,208
209,210
212,213
212,214
213,214
216,217
217,218
217,219
218,219
218,220
219,220
223,224
223,225
223,226
224,225
224,226
225,226
225,227
226,227
226,228
227,228
227,229
228,229
229,230
229,231
230,231
233,234
234,235
234,236
235,236
238,239
238,240
239,240
242,243
243,244
243,245
244,245
244,246
245,246
247,248
247,249
248,249
251,252
253,254
254,255
255,256
255,257
256,257
256,258
257,258
261,262
261,263
262,263
263,264
263,265
264,265
267,268
267,269
268,269
269,270
269,271
271,272
271,273
273,274
274,275
274,276
275,276
277,278
277,279
278,279
281,282
281,283
282,283
282,284
283,284
283,285
284,285
287,288
288,289
288,290
289,290
291,292
291,293
292,293
295,296
295,297
296,297
297,298
297,299
297,300
297,301
297,302
297,303
298,299
300,301
303,304
303,305
304,305
307,308
307,309
308,309
311,312
313,314
313,315
314,315
314,316
315,316
317,318
317,319
318,319
321,322
321,323
321,324
322,323
322,324
323,324
325,326
325,327
325,328
326,327
327,328
327,329
327,330
328,329
330,331
332,333
334,335
335,336
335,337
336,337
338,339
340,341
341,342
341,343
342,343
344,345
344,346
345,346
347,348
349,350
349,351
350,351
350,352
351,352
351,353
352,353
355,356
355,357
356,357
358,359
358,360
359,360
362,363
363,364
364,365
364,366
365,366
367,368
368,369
368,370
369,370
372,373
372,374
373,374
373,375
374,375
377,378
377,379
378,379
379,380
379,381
379,382
380,381
382,383
382,384
383,384
386,387
388,389
389,390
389,391
390,391
392,393
392,394
393,394
396,397
396,398
397,398
397,399
398,399
401,402
401,403
401,404
401,405
401,406
401,407
401,408
401,409
401,410
401,411
401,412
401,413
401,414
401,415
402,403
403,404
405,406
405,407
406,407
406,408
407,408
407,409
408,409
408,410
409,410
413,414
415,416
416,417
416,418
416,419
417,418
417,419
418,419
421,422
421,423
421,424
422,423
423,424
423,425
423,426
423,427
423,428
424,425
428,429
428,430
429,430
431,432
431,433
432,433
435,436
435,437
436,437
439,440
440,441
440,442
441,442
443,444
445,446
446,447
446,448
447,448
449,450
450,451
452,453
452,454
452,455
453,454
454,455
454,456
455,456
455,457
456,457
460,461
461,462
461,463
462,463
464,465
466,467
467,468
467,469
468,469
470,471
471,472
474,475
475,476
477,478
477,479
478,479
478,480
479,480
480,481
480,482
481,482
482,483
482,484
483,484
486,487
486,488
487,488
487,489
488,489
488,490
489,490
493,494
493,495
494,495
497,498
498,499
498,500
499,500
499,501
500,501
500,502
501,502
501,503
502,503
506,507
506,508
507,508
510,511
512,513
512,514
513,514
514,515
514,516
515,516
517,518
519,520
520,521
520,522
521,522
523,524
524,525
527,528
528,529
530,531
530,532
530,533
531,532
531,533
532,533
533,534
533,535
534,535
537,538
538,539
538,540
539,540
539,541
540,541
540,542
541,542
545,546
545,547
546,547
549,550
549,551
549,552
549,553
550,551
550,552
551,552
551,553
552,553
555,556
556,557
557,558
557,559
557,560
557,561
558,559
562,563
562,564
563,564
565,566
565,567
566,567
569,570
570,571
570,572
571,572
571,573
572,573
576,577
577,578
577,579
578,579
580,581
582,583
583,584
583,585
584,585
586,587
587,588
589,590
589,591
590,591
590,592
591,592
591,593
592,593
592,594
593,594
593,595
594,595
598,599
598,600
599,600
602,603
604,605
604,606
605,606
606,607
606,608
607,608
609,610
611,612
612,613
612,614
613,614
615,616
618,619
619,620
621,622
622,623
624,625
624,626
625,626
626,627
626,628
627,628
630,631
630,632
631,632
632,633
632,634
633,634
635,636
637,638
638,639
638,640
639,640
641,642
642,643
646,647
646,648
647,648
649,650
649,651
650,651
651,652
651,653
652,653
654,655
656,657
657,658
657,659
658,659
660,661
660,662
661,662
663,664
665,666
666,667
666,668
666,669
667,668
669,670
671,672
673,674
673,675
674,675
674,676
675,676
675,677
676,677
679,680
680,681
680,682
681,682
683,684
683,685
684,685
687,688
688,689
688,690
689,690
689,691
689,692
690,691
692,693
692,694
693,694
693,695
694,695
696,697
696,698
697,698
702,703
702,704
703,704
704,705
704,706
704,707
705,706
707,708
707,709
708,709
711,712
713,714
713,715
714,715
714,716
715,716
718,719
719,720
719,721
719,722
719,723
719,724
720,721
724,725
724,726
725,726
727,728
727,729
728,729
731,732
731,733
732,733
734,735
734,736
735,736
737,738
737,739
738,739
741,742
742,743
742,744
743,744
745,746
746,747
746,748
747,748
750,751
750,752
751,752
751,753
752,753
754,755
754,756
755,756
757,758
758,759
760,761
761,762
761,763
761,764
762,763
764,765
767,768
768,769
-----nextToken-----
3,5,6,9,11,12,17,19,20,24,26,30,32,33,36,40,42,46,49,52,54,58,60,64,66,67,71,75,76,80,83,85,89,91,93,98,99,105,106,108,112,113,118,121,124,125,128,130,132,136,139,140,146,148,150,152,155,157,161,164,167,168,172,175,179,184,185,190,193,194,196,201,202,204,208,210,211,214,215,220,221,222,231,232,236,237,240,241,246,249,250,252,258,259,260,265,266,270,272,276,279,280,285,286,290,293,294,299,301,302,305,306,309,310,312,316,319,320,324,329,331,333,337,339,343,346,348,353,354,357,360,361,366,370,371,375,376,381,384,385,387,391,394,395,399,400,404,410,411,412,414,419,420,425,426,427,430,433,434,437,438,442,444,448,451,457,458,459,463,465,469,472,473,476,484,485,490,491,492,495,496,503,504,505,508,509,511,516,518,522,525,526,529,535,536,542,543,544,547,548,553,554,559,560,561,564,567,568,573,574,575,579,581,585,588,595,596,597,600,601,603,608,610,614,616,617,620,623,628,629,634,636,640,643,644,645,648,653,655,659,662,664,668,670,672,677,678,682,685,686,691,695,698,699,700,701,706,709,710,712,716,717,721,722,723,726,729,730,733,736,739,740,744,748,749,753,756,759,763,765,766,769
-----computeFrom-----
78,79
78,80
102,103
102,104
143,144
143,145
159,160
159,161
170,171
170,172
198,199
198,200
217,218
217,219
225,226
225,227
226,227
226,228
227,228
227,229
243,244
243,245
255,256
255,257
274,275
274,276
282,283
282,284
288,289
288,290
314,315
314,316
341,342
341,343
350,351
350,352
406,407
406,408
446,447
446,448
454,455
454,456
467,468
467,469
478,479
478,480
480,481
480,482
486,487
486,488
498,499
498,500
499,500
499,501
520,521
520,522
531,532
531,533
538,539
538,540
570,571
570,572
583,584
583,585
590,591
590,592
591,592
591,593
612,613
612,614
638,639
638,640
657,658
657,659
674,675
674,676
751,752
751,753
754,755
754,756
-----guardedBy-----
249,258
237,259
293,394
294,310
290,312
316,348
319,394
320,395
410,469
503,522
547,573
536,574
542,585
595,614
685,739
682,736
686,740
-----guardedByNegation-----
547,600
542,614
543,596
544,597
-----lastLexicalUse-----
547,600
542,614
-----jump-----
547,600
542,614
-----attribute-----
FunctionDefinition;ElaboratedTypeSpecifier;Name;FunctionDeclarator;Pointer;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;InitializerList;IdExpression;Name;InitializerList;IdExpression;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ConditionalExpression;UnaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IfStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;WhileStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;SwitchStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;CaseStatement;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;IfStatement;BinaryExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;IfStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;DefaultStatement;BreakStatement;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;FieldReference;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ReturnStatement;IdExpression;Name;
-----ast_node-----
static struct ast_frame *agent_read(struct ast_channel *ast){	struct agent_pvt *p = ast_channel_tech_pvt(ast);	struct ast_frame *f = NULL;	static struct ast_frame answer_frame = { AST_FRAME_CONTROL, { AST_CONTROL_ANSWER } };	int cur_time = time(NULL);	struct ast_channel *owner;	ast_mutex_lock(&p->lock);	owner = agent_lock_owner(p);	CHECK_FORMATS(ast, p);	if (!p->start) {		p->start = cur_time;	}	if (p->chan) {		ast_copy_flags(ast_channel_flags(p->chan), ast_channel_flags(ast), AST_FLAG_EXCEPTION);		ast_channel_fdno_set(p->chan, (ast_channel_fdno(ast) == AST_AGENT_FD) ? AST_TIMING_FD : ast_channel_fdno(ast));		f = ast_read(p->chan);	} else		f = &ast_null_frame;	if (!f) {		/* If there's a channel, make it NULL */		if (p->chan) {			ast_channel_internal_bridged_channel_set(p->chan, NULL);			p->chan = NULL;			ast_devstate_changed(AST_DEVICE_UNAVAILABLE, "Agent/%s", p->agent);			p->acknowledged = 0;		}	} else {		/* if acknowledgement is not required, and the channel is up, we may have missed			an AST_CONTROL_ANSWER (if there was one), so mark the call acknowledged anyway */		if (!p->ackcall && !p->acknowledged && p->chan && (ast_channel_state(p->chan) == AST_STATE_UP)) {			p->acknowledged = 1;		}		if (!p->acknowledged) {			int howlong = cur_time - p->start;			if (p->autologoff && (howlong >= p->autologoff)) {				ast_log(LOG_NOTICE, "Agent '%s' didn't answer/confirm within %d seconds (waited %d)\n", p->name, p->autologoff, howlong);				if (owner || p->chan) {					if (owner) {						ast_softhangup(owner, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(owner);						owner = ast_channel_unref(owner);					}					while (p->chan && ast_channel_trylock(p->chan)) {						DEADLOCK_AVOIDANCE(&p->lock);					}					if (p->chan) {						ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(p->chan);					}				}			}		}		switch (f->frametype) {		case AST_FRAME_CONTROL:			if (f->subclass.integer == AST_CONTROL_ANSWER) {				if (p->ackcall) {					ast_verb(3, "%s answered, waiting for '%c' to acknowledge\n", ast_channel_name(p->chan), p->acceptdtmf);					/* Don't pass answer along */					ast_frfree(f);					f = &ast_null_frame;				} else {					p->acknowledged = 1;					/* Use the builtin answer frame for the 					   recording start check below. */					ast_frfree(f);					f = &answer_frame;				}			}			break;		case AST_FRAME_DTMF_BEGIN:			/*ignore DTMF begin's as it can cause issues with queue announce files*/			if((!p->acknowledged && f->subclass.integer == p->acceptdtmf) || (f->subclass.integer == p->enddtmf && endcall)){				ast_frfree(f);				f = &ast_null_frame;			}			break;		case AST_FRAME_DTMF_END:			if (!p->acknowledged && (f->subclass.integer == p->acceptdtmf)) {				if (p->chan) {					ast_verb(3, "%s acknowledged\n", ast_channel_name(p->chan));				}				p->acknowledged = 1;				ast_frfree(f);				f = &answer_frame;			} else if (f->subclass.integer == p->enddtmf && endcall) {				/* terminates call */				ast_frfree(f);				f = NULL;			}			break;		case AST_FRAME_VOICE:		case AST_FRAME_VIDEO:			/* don't pass voice or video until the call is acknowledged */			if (!p->acknowledged) {				ast_frfree(f);				f = &ast_null_frame;			}		default:			/* pass everything else on through */			break;		}	}	if (owner) {		ast_channel_unlock(owner);		owner = ast_channel_unref(owner);	}	CLEANUP(ast,p);	if (p->chan && !ast_channel_internal_bridged_channel(p->chan)) {		if (strcasecmp(ast_channel_tech(p->chan)->type, "Local")) {			ast_channel_internal_bridged_channel_set(p->chan, ast);			if (p->chan)				ast_debug(1, "Bridge on '%s' being set to '%s' (3)\n", ast_channel_name(p->chan), ast_channel_name(ast_channel_internal_bridged_channel(p->chan)));		}	}	ast_mutex_unlock(&p->lock);	if (recordagentcalls && f == &answer_frame)		agent_start_monitoring(ast,0);	return f;}
static struct ast_frame
ast_frame
*agent_read(struct ast_channel *ast)
*
agent_read
struct ast_channel *ast
struct ast_channel
ast_channel
*ast
*
ast
{	struct agent_pvt *p = ast_channel_tech_pvt(ast);	struct ast_frame *f = NULL;	static struct ast_frame answer_frame = { AST_FRAME_CONTROL, { AST_CONTROL_ANSWER } };	int cur_time = time(NULL);	struct ast_channel *owner;	ast_mutex_lock(&p->lock);	owner = agent_lock_owner(p);	CHECK_FORMATS(ast, p);	if (!p->start) {		p->start = cur_time;	}	if (p->chan) {		ast_copy_flags(ast_channel_flags(p->chan), ast_channel_flags(ast), AST_FLAG_EXCEPTION);		ast_channel_fdno_set(p->chan, (ast_channel_fdno(ast) == AST_AGENT_FD) ? AST_TIMING_FD : ast_channel_fdno(ast));		f = ast_read(p->chan);	} else		f = &ast_null_frame;	if (!f) {		/* If there's a channel, make it NULL */		if (p->chan) {			ast_channel_internal_bridged_channel_set(p->chan, NULL);			p->chan = NULL;			ast_devstate_changed(AST_DEVICE_UNAVAILABLE, "Agent/%s", p->agent);			p->acknowledged = 0;		}	} else {		/* if acknowledgement is not required, and the channel is up, we may have missed			an AST_CONTROL_ANSWER (if there was one), so mark the call acknowledged anyway */		if (!p->ackcall && !p->acknowledged && p->chan && (ast_channel_state(p->chan) == AST_STATE_UP)) {			p->acknowledged = 1;		}		if (!p->acknowledged) {			int howlong = cur_time - p->start;			if (p->autologoff && (howlong >= p->autologoff)) {				ast_log(LOG_NOTICE, "Agent '%s' didn't answer/confirm within %d seconds (waited %d)\n", p->name, p->autologoff, howlong);				if (owner || p->chan) {					if (owner) {						ast_softhangup(owner, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(owner);						owner = ast_channel_unref(owner);					}					while (p->chan && ast_channel_trylock(p->chan)) {						DEADLOCK_AVOIDANCE(&p->lock);					}					if (p->chan) {						ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(p->chan);					}				}			}		}		switch (f->frametype) {		case AST_FRAME_CONTROL:			if (f->subclass.integer == AST_CONTROL_ANSWER) {				if (p->ackcall) {					ast_verb(3, "%s answered, waiting for '%c' to acknowledge\n", ast_channel_name(p->chan), p->acceptdtmf);					/* Don't pass answer along */					ast_frfree(f);					f = &ast_null_frame;				} else {					p->acknowledged = 1;					/* Use the builtin answer frame for the 					   recording start check below. */					ast_frfree(f);					f = &answer_frame;				}			}			break;		case AST_FRAME_DTMF_BEGIN:			/*ignore DTMF begin's as it can cause issues with queue announce files*/			if((!p->acknowledged && f->subclass.integer == p->acceptdtmf) || (f->subclass.integer == p->enddtmf && endcall)){				ast_frfree(f);				f = &ast_null_frame;			}			break;		case AST_FRAME_DTMF_END:			if (!p->acknowledged && (f->subclass.integer == p->acceptdtmf)) {				if (p->chan) {					ast_verb(3, "%s acknowledged\n", ast_channel_name(p->chan));				}				p->acknowledged = 1;				ast_frfree(f);				f = &answer_frame;			} else if (f->subclass.integer == p->enddtmf && endcall) {				/* terminates call */				ast_frfree(f);				f = NULL;			}			break;		case AST_FRAME_VOICE:		case AST_FRAME_VIDEO:			/* don't pass voice or video until the call is acknowledged */			if (!p->acknowledged) {				ast_frfree(f);				f = &ast_null_frame;			}		default:			/* pass everything else on through */			break;		}	}	if (owner) {		ast_channel_unlock(owner);		owner = ast_channel_unref(owner);	}	CLEANUP(ast,p);	if (p->chan && !ast_channel_internal_bridged_channel(p->chan)) {		if (strcasecmp(ast_channel_tech(p->chan)->type, "Local")) {			ast_channel_internal_bridged_channel_set(p->chan, ast);			if (p->chan)				ast_debug(1, "Bridge on '%s' being set to '%s' (3)\n", ast_channel_name(p->chan), ast_channel_name(ast_channel_internal_bridged_channel(p->chan)));		}	}	ast_mutex_unlock(&p->lock);	if (recordagentcalls && f == &answer_frame)		agent_start_monitoring(ast,0);	return f;}
struct agent_pvt *p = ast_channel_tech_pvt(ast);
struct agent_pvt *p = ast_channel_tech_pvt(ast);
struct agent_pvt
agent_pvt
*p = ast_channel_tech_pvt(ast)
*
p
= ast_channel_tech_pvt(ast)
ast_channel_tech_pvt(ast)
ast_channel_tech_pvt
ast_channel_tech_pvt
ast
ast
struct ast_frame *f = NULL;
struct ast_frame *f = NULL;
struct ast_frame
ast_frame
*f = NULL
*
f
= NULL
NULL
NULL
static struct ast_frame answer_frame = { AST_FRAME_CONTROL, { AST_CONTROL_ANSWER } };
static struct ast_frame answer_frame = { AST_FRAME_CONTROL, { AST_CONTROL_ANSWER } };
static struct ast_frame
ast_frame
answer_frame = { AST_FRAME_CONTROL, { AST_CONTROL_ANSWER } }
answer_frame
= { AST_FRAME_CONTROL, { AST_CONTROL_ANSWER } }
{ AST_FRAME_CONTROL, { AST_CONTROL_ANSWER } }
AST_FRAME_CONTROL
AST_FRAME_CONTROL
{ AST_CONTROL_ANSWER }
AST_CONTROL_ANSWER
AST_CONTROL_ANSWER
int cur_time = time(NULL);
int cur_time = time(NULL);
int
cur_time = time(NULL)
cur_time
= time(NULL)
time(NULL)
time
time
NULL
NULL
struct ast_channel *owner;
struct ast_channel *owner;
struct ast_channel
ast_channel
*owner
*
owner
ast_mutex_lock(&p->lock);
ast_mutex_lock(&p->lock)
ast_mutex_lock
ast_mutex_lock
&p->lock
p->lock
p
p
lock
owner = agent_lock_owner(p);
owner = agent_lock_owner(p)
owner
owner
agent_lock_owner(p)
agent_lock_owner
agent_lock_owner
p
p
CHECK_FORMATS(ast, p);
CHECK_FORMATS(ast, p)
CHECK_FORMATS
CHECK_FORMATS
ast
ast
p
p
if (!p->start) {		p->start = cur_time;	}
!p->start
p->start
p
p
start
{		p->start = cur_time;	}
p->start = cur_time;
p->start = cur_time
p->start
p
p
start
cur_time
cur_time
if (p->chan) {		ast_copy_flags(ast_channel_flags(p->chan), ast_channel_flags(ast), AST_FLAG_EXCEPTION);		ast_channel_fdno_set(p->chan, (ast_channel_fdno(ast) == AST_AGENT_FD) ? AST_TIMING_FD : ast_channel_fdno(ast));		f = ast_read(p->chan);	} else		f = &ast_null_frame;
p->chan
p
p
chan
{		ast_copy_flags(ast_channel_flags(p->chan), ast_channel_flags(ast), AST_FLAG_EXCEPTION);		ast_channel_fdno_set(p->chan, (ast_channel_fdno(ast) == AST_AGENT_FD) ? AST_TIMING_FD : ast_channel_fdno(ast));		f = ast_read(p->chan);	}
ast_copy_flags(ast_channel_flags(p->chan), ast_channel_flags(ast), AST_FLAG_EXCEPTION);
ast_copy_flags(ast_channel_flags(p->chan), ast_channel_flags(ast), AST_FLAG_EXCEPTION)
ast_copy_flags
ast_copy_flags
ast_channel_flags(p->chan)
ast_channel_flags
ast_channel_flags
p->chan
p
p
chan
ast_channel_flags(ast)
ast_channel_flags
ast_channel_flags
ast
ast
AST_FLAG_EXCEPTION
AST_FLAG_EXCEPTION
ast_channel_fdno_set(p->chan, (ast_channel_fdno(ast) == AST_AGENT_FD) ? AST_TIMING_FD : ast_channel_fdno(ast));
ast_channel_fdno_set(p->chan, (ast_channel_fdno(ast) == AST_AGENT_FD) ? AST_TIMING_FD : ast_channel_fdno(ast))
ast_channel_fdno_set
ast_channel_fdno_set
p->chan
p
p
chan
(ast_channel_fdno(ast) == AST_AGENT_FD) ? AST_TIMING_FD : ast_channel_fdno(ast)
(ast_channel_fdno(ast) == AST_AGENT_FD)
ast_channel_fdno(ast) == AST_AGENT_FD
ast_channel_fdno(ast)
ast_channel_fdno
ast_channel_fdno
ast
ast
AST_AGENT_FD
AST_AGENT_FD
AST_TIMING_FD
AST_TIMING_FD
ast_channel_fdno(ast)
ast_channel_fdno
ast_channel_fdno
ast
ast
f = ast_read(p->chan);
f = ast_read(p->chan)
f
f
ast_read(p->chan)
ast_read
ast_read
p->chan
p
p
chan
f = &ast_null_frame;
f = &ast_null_frame
f
f
&ast_null_frame
ast_null_frame
ast_null_frame
if (!f) {		/* If there's a channel, make it NULL */		if (p->chan) {			ast_channel_internal_bridged_channel_set(p->chan, NULL);			p->chan = NULL;			ast_devstate_changed(AST_DEVICE_UNAVAILABLE, "Agent/%s", p->agent);			p->acknowledged = 0;		}	} else {		/* if acknowledgement is not required, and the channel is up, we may have missed			an AST_CONTROL_ANSWER (if there was one), so mark the call acknowledged anyway */		if (!p->ackcall && !p->acknowledged && p->chan && (ast_channel_state(p->chan) == AST_STATE_UP)) {			p->acknowledged = 1;		}		if (!p->acknowledged) {			int howlong = cur_time - p->start;			if (p->autologoff && (howlong >= p->autologoff)) {				ast_log(LOG_NOTICE, "Agent '%s' didn't answer/confirm within %d seconds (waited %d)\n", p->name, p->autologoff, howlong);				if (owner || p->chan) {					if (owner) {						ast_softhangup(owner, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(owner);						owner = ast_channel_unref(owner);					}					while (p->chan && ast_channel_trylock(p->chan)) {						DEADLOCK_AVOIDANCE(&p->lock);					}					if (p->chan) {						ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(p->chan);					}				}			}		}		switch (f->frametype) {		case AST_FRAME_CONTROL:			if (f->subclass.integer == AST_CONTROL_ANSWER) {				if (p->ackcall) {					ast_verb(3, "%s answered, waiting for '%c' to acknowledge\n", ast_channel_name(p->chan), p->acceptdtmf);					/* Don't pass answer along */					ast_frfree(f);					f = &ast_null_frame;				} else {					p->acknowledged = 1;					/* Use the builtin answer frame for the 					   recording start check below. */					ast_frfree(f);					f = &answer_frame;				}			}			break;		case AST_FRAME_DTMF_BEGIN:			/*ignore DTMF begin's as it can cause issues with queue announce files*/			if((!p->acknowledged && f->subclass.integer == p->acceptdtmf) || (f->subclass.integer == p->enddtmf && endcall)){				ast_frfree(f);				f = &ast_null_frame;			}			break;		case AST_FRAME_DTMF_END:			if (!p->acknowledged && (f->subclass.integer == p->acceptdtmf)) {				if (p->chan) {					ast_verb(3, "%s acknowledged\n", ast_channel_name(p->chan));				}				p->acknowledged = 1;				ast_frfree(f);				f = &answer_frame;			} else if (f->subclass.integer == p->enddtmf && endcall) {				/* terminates call */				ast_frfree(f);				f = NULL;			}			break;		case AST_FRAME_VOICE:		case AST_FRAME_VIDEO:			/* don't pass voice or video until the call is acknowledged */			if (!p->acknowledged) {				ast_frfree(f);				f = &ast_null_frame;			}		default:			/* pass everything else on through */			break;		}	}
!f
f
f
{		/* If there's a channel, make it NULL */		if (p->chan) {			ast_channel_internal_bridged_channel_set(p->chan, NULL);			p->chan = NULL;			ast_devstate_changed(AST_DEVICE_UNAVAILABLE, "Agent/%s", p->agent);			p->acknowledged = 0;		}	}
if (p->chan) {			ast_channel_internal_bridged_channel_set(p->chan, NULL);			p->chan = NULL;			ast_devstate_changed(AST_DEVICE_UNAVAILABLE, "Agent/%s", p->agent);			p->acknowledged = 0;		}
p->chan
p
p
chan
{			ast_channel_internal_bridged_channel_set(p->chan, NULL);			p->chan = NULL;			ast_devstate_changed(AST_DEVICE_UNAVAILABLE, "Agent/%s", p->agent);			p->acknowledged = 0;		}
ast_channel_internal_bridged_channel_set(p->chan, NULL);
ast_channel_internal_bridged_channel_set(p->chan, NULL)
ast_channel_internal_bridged_channel_set
ast_channel_internal_bridged_channel_set
p->chan
p
p
chan
NULL
NULL
p->chan = NULL;
p->chan = NULL
p->chan
p
p
chan
NULL
NULL
ast_devstate_changed(AST_DEVICE_UNAVAILABLE, "Agent/%s", p->agent);
ast_devstate_changed(AST_DEVICE_UNAVAILABLE, "Agent/%s", p->agent)
ast_devstate_changed
ast_devstate_changed
AST_DEVICE_UNAVAILABLE
AST_DEVICE_UNAVAILABLE
"Agent/%s"
p->agent
p
p
agent
p->acknowledged = 0;
p->acknowledged = 0
p->acknowledged
p
p
acknowledged
0
{		/* if acknowledgement is not required, and the channel is up, we may have missed			an AST_CONTROL_ANSWER (if there was one), so mark the call acknowledged anyway */		if (!p->ackcall && !p->acknowledged && p->chan && (ast_channel_state(p->chan) == AST_STATE_UP)) {			p->acknowledged = 1;		}		if (!p->acknowledged) {			int howlong = cur_time - p->start;			if (p->autologoff && (howlong >= p->autologoff)) {				ast_log(LOG_NOTICE, "Agent '%s' didn't answer/confirm within %d seconds (waited %d)\n", p->name, p->autologoff, howlong);				if (owner || p->chan) {					if (owner) {						ast_softhangup(owner, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(owner);						owner = ast_channel_unref(owner);					}					while (p->chan && ast_channel_trylock(p->chan)) {						DEADLOCK_AVOIDANCE(&p->lock);					}					if (p->chan) {						ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(p->chan);					}				}			}		}		switch (f->frametype) {		case AST_FRAME_CONTROL:			if (f->subclass.integer == AST_CONTROL_ANSWER) {				if (p->ackcall) {					ast_verb(3, "%s answered, waiting for '%c' to acknowledge\n", ast_channel_name(p->chan), p->acceptdtmf);					/* Don't pass answer along */					ast_frfree(f);					f = &ast_null_frame;				} else {					p->acknowledged = 1;					/* Use the builtin answer frame for the 					   recording start check below. */					ast_frfree(f);					f = &answer_frame;				}			}			break;		case AST_FRAME_DTMF_BEGIN:			/*ignore DTMF begin's as it can cause issues with queue announce files*/			if((!p->acknowledged && f->subclass.integer == p->acceptdtmf) || (f->subclass.integer == p->enddtmf && endcall)){				ast_frfree(f);				f = &ast_null_frame;			}			break;		case AST_FRAME_DTMF_END:			if (!p->acknowledged && (f->subclass.integer == p->acceptdtmf)) {				if (p->chan) {					ast_verb(3, "%s acknowledged\n", ast_channel_name(p->chan));				}				p->acknowledged = 1;				ast_frfree(f);				f = &answer_frame;			} else if (f->subclass.integer == p->enddtmf && endcall) {				/* terminates call */				ast_frfree(f);				f = NULL;			}			break;		case AST_FRAME_VOICE:		case AST_FRAME_VIDEO:			/* don't pass voice or video until the call is acknowledged */			if (!p->acknowledged) {				ast_frfree(f);				f = &ast_null_frame;			}		default:			/* pass everything else on through */			break;		}	}
if (!p->ackcall && !p->acknowledged && p->chan && (ast_channel_state(p->chan) == AST_STATE_UP)) {			p->acknowledged = 1;		}
!p->ackcall && !p->acknowledged && p->chan && (ast_channel_state(p->chan) == AST_STATE_UP)
!p->ackcall && !p->acknowledged && p->chan
!p->ackcall && !p->acknowledged
!p->ackcall
p->ackcall
p
p
ackcall
!p->acknowledged
p->acknowledged
p
p
acknowledged
p->chan
p
p
chan
(ast_channel_state(p->chan) == AST_STATE_UP)
ast_channel_state(p->chan) == AST_STATE_UP
ast_channel_state(p->chan)
ast_channel_state
ast_channel_state
p->chan
p
p
chan
AST_STATE_UP
AST_STATE_UP
{			p->acknowledged = 1;		}
p->acknowledged = 1;
p->acknowledged = 1
p->acknowledged
p
p
acknowledged
1
if (!p->acknowledged) {			int howlong = cur_time - p->start;			if (p->autologoff && (howlong >= p->autologoff)) {				ast_log(LOG_NOTICE, "Agent '%s' didn't answer/confirm within %d seconds (waited %d)\n", p->name, p->autologoff, howlong);				if (owner || p->chan) {					if (owner) {						ast_softhangup(owner, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(owner);						owner = ast_channel_unref(owner);					}					while (p->chan && ast_channel_trylock(p->chan)) {						DEADLOCK_AVOIDANCE(&p->lock);					}					if (p->chan) {						ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(p->chan);					}				}			}		}
!p->acknowledged
p->acknowledged
p
p
acknowledged
{			int howlong = cur_time - p->start;			if (p->autologoff && (howlong >= p->autologoff)) {				ast_log(LOG_NOTICE, "Agent '%s' didn't answer/confirm within %d seconds (waited %d)\n", p->name, p->autologoff, howlong);				if (owner || p->chan) {					if (owner) {						ast_softhangup(owner, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(owner);						owner = ast_channel_unref(owner);					}					while (p->chan && ast_channel_trylock(p->chan)) {						DEADLOCK_AVOIDANCE(&p->lock);					}					if (p->chan) {						ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(p->chan);					}				}			}		}
int howlong = cur_time - p->start;
int howlong = cur_time - p->start;
int
howlong = cur_time - p->start
howlong
= cur_time - p->start
cur_time - p->start
cur_time
cur_time
p->start
p
p
start
if (p->autologoff && (howlong >= p->autologoff)) {				ast_log(LOG_NOTICE, "Agent '%s' didn't answer/confirm within %d seconds (waited %d)\n", p->name, p->autologoff, howlong);				if (owner || p->chan) {					if (owner) {						ast_softhangup(owner, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(owner);						owner = ast_channel_unref(owner);					}					while (p->chan && ast_channel_trylock(p->chan)) {						DEADLOCK_AVOIDANCE(&p->lock);					}					if (p->chan) {						ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(p->chan);					}				}			}
p->autologoff && (howlong >= p->autologoff)
p->autologoff
p
p
autologoff
(howlong >= p->autologoff)
howlong >= p->autologoff
howlong
howlong
p->autologoff
p
p
autologoff
{				ast_log(LOG_NOTICE, "Agent '%s' didn't answer/confirm within %d seconds (waited %d)\n", p->name, p->autologoff, howlong);				if (owner || p->chan) {					if (owner) {						ast_softhangup(owner, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(owner);						owner = ast_channel_unref(owner);					}					while (p->chan && ast_channel_trylock(p->chan)) {						DEADLOCK_AVOIDANCE(&p->lock);					}					if (p->chan) {						ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(p->chan);					}				}			}
ast_log(LOG_NOTICE, "Agent '%s' didn't answer/confirm within %d seconds (waited %d)\n", p->name, p->autologoff, howlong);
ast_log(LOG_NOTICE, "Agent '%s' didn't answer/confirm within %d seconds (waited %d)\n", p->name, p->autologoff, howlong)
ast_log
ast_log
LOG_NOTICE
LOG_NOTICE
"Agent '%s' didn't answer/confirm within %d seconds (waited %d)\n"
p->name
p
p
name
p->autologoff
p
p
autologoff
howlong
howlong
if (owner || p->chan) {					if (owner) {						ast_softhangup(owner, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(owner);						owner = ast_channel_unref(owner);					}					while (p->chan && ast_channel_trylock(p->chan)) {						DEADLOCK_AVOIDANCE(&p->lock);					}					if (p->chan) {						ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(p->chan);					}				}
owner || p->chan
owner
owner
p->chan
p
p
chan
{					if (owner) {						ast_softhangup(owner, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(owner);						owner = ast_channel_unref(owner);					}					while (p->chan && ast_channel_trylock(p->chan)) {						DEADLOCK_AVOIDANCE(&p->lock);					}					if (p->chan) {						ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(p->chan);					}				}
if (owner) {						ast_softhangup(owner, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(owner);						owner = ast_channel_unref(owner);					}
owner
owner
{						ast_softhangup(owner, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(owner);						owner = ast_channel_unref(owner);					}
ast_softhangup(owner, AST_SOFTHANGUP_EXPLICIT);
ast_softhangup(owner, AST_SOFTHANGUP_EXPLICIT)
ast_softhangup
ast_softhangup
owner
owner
AST_SOFTHANGUP_EXPLICIT
AST_SOFTHANGUP_EXPLICIT
ast_channel_unlock(owner);
ast_channel_unlock(owner)
ast_channel_unlock
ast_channel_unlock
owner
owner
owner = ast_channel_unref(owner);
owner = ast_channel_unref(owner)
owner
owner
ast_channel_unref(owner)
ast_channel_unref
ast_channel_unref
owner
owner
while (p->chan && ast_channel_trylock(p->chan)) {						DEADLOCK_AVOIDANCE(&p->lock);					}
p->chan && ast_channel_trylock(p->chan)
p->chan
p
p
chan
ast_channel_trylock(p->chan)
ast_channel_trylock
ast_channel_trylock
p->chan
p
p
chan
{						DEADLOCK_AVOIDANCE(&p->lock);					}
DEADLOCK_AVOIDANCE(&p->lock);
DEADLOCK_AVOIDANCE(&p->lock)
DEADLOCK_AVOIDANCE
DEADLOCK_AVOIDANCE
&p->lock
p->lock
p
p
lock
if (p->chan) {						ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(p->chan);					}
p->chan
p
p
chan
{						ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(p->chan);					}
ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);
ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT)
ast_softhangup
ast_softhangup
p->chan
p
p
chan
AST_SOFTHANGUP_EXPLICIT
AST_SOFTHANGUP_EXPLICIT
ast_channel_unlock(p->chan);
ast_channel_unlock(p->chan)
ast_channel_unlock
ast_channel_unlock
p->chan
p
p
chan
switch (f->frametype) {		case AST_FRAME_CONTROL:			if (f->subclass.integer == AST_CONTROL_ANSWER) {				if (p->ackcall) {					ast_verb(3, "%s answered, waiting for '%c' to acknowledge\n", ast_channel_name(p->chan), p->acceptdtmf);					/* Don't pass answer along */					ast_frfree(f);					f = &ast_null_frame;				} else {					p->acknowledged = 1;					/* Use the builtin answer frame for the 					   recording start check below. */					ast_frfree(f);					f = &answer_frame;				}			}			break;		case AST_FRAME_DTMF_BEGIN:			/*ignore DTMF begin's as it can cause issues with queue announce files*/			if((!p->acknowledged && f->subclass.integer == p->acceptdtmf) || (f->subclass.integer == p->enddtmf && endcall)){				ast_frfree(f);				f = &ast_null_frame;			}			break;		case AST_FRAME_DTMF_END:			if (!p->acknowledged && (f->subclass.integer == p->acceptdtmf)) {				if (p->chan) {					ast_verb(3, "%s acknowledged\n", ast_channel_name(p->chan));				}				p->acknowledged = 1;				ast_frfree(f);				f = &answer_frame;			} else if (f->subclass.integer == p->enddtmf && endcall) {				/* terminates call */				ast_frfree(f);				f = NULL;			}			break;		case AST_FRAME_VOICE:		case AST_FRAME_VIDEO:			/* don't pass voice or video until the call is acknowledged */			if (!p->acknowledged) {				ast_frfree(f);				f = &ast_null_frame;			}		default:			/* pass everything else on through */			break;		}
f->frametype
f
f
frametype
{		case AST_FRAME_CONTROL:			if (f->subclass.integer == AST_CONTROL_ANSWER) {				if (p->ackcall) {					ast_verb(3, "%s answered, waiting for '%c' to acknowledge\n", ast_channel_name(p->chan), p->acceptdtmf);					/* Don't pass answer along */					ast_frfree(f);					f = &ast_null_frame;				} else {					p->acknowledged = 1;					/* Use the builtin answer frame for the 					   recording start check below. */					ast_frfree(f);					f = &answer_frame;				}			}			break;		case AST_FRAME_DTMF_BEGIN:			/*ignore DTMF begin's as it can cause issues with queue announce files*/			if((!p->acknowledged && f->subclass.integer == p->acceptdtmf) || (f->subclass.integer == p->enddtmf && endcall)){				ast_frfree(f);				f = &ast_null_frame;			}			break;		case AST_FRAME_DTMF_END:			if (!p->acknowledged && (f->subclass.integer == p->acceptdtmf)) {				if (p->chan) {					ast_verb(3, "%s acknowledged\n", ast_channel_name(p->chan));				}				p->acknowledged = 1;				ast_frfree(f);				f = &answer_frame;			} else if (f->subclass.integer == p->enddtmf && endcall) {				/* terminates call */				ast_frfree(f);				f = NULL;			}			break;		case AST_FRAME_VOICE:		case AST_FRAME_VIDEO:			/* don't pass voice or video until the call is acknowledged */			if (!p->acknowledged) {				ast_frfree(f);				f = &ast_null_frame;			}		default:			/* pass everything else on through */			break;		}
case AST_FRAME_CONTROL:
AST_FRAME_CONTROL
AST_FRAME_CONTROL
if (f->subclass.integer == AST_CONTROL_ANSWER) {				if (p->ackcall) {					ast_verb(3, "%s answered, waiting for '%c' to acknowledge\n", ast_channel_name(p->chan), p->acceptdtmf);					/* Don't pass answer along */					ast_frfree(f);					f = &ast_null_frame;				} else {					p->acknowledged = 1;					/* Use the builtin answer frame for the 					   recording start check below. */					ast_frfree(f);					f = &answer_frame;				}			}
f->subclass.integer == AST_CONTROL_ANSWER
f->subclass.integer
f->subclass
f
f
subclass
integer
AST_CONTROL_ANSWER
AST_CONTROL_ANSWER
{				if (p->ackcall) {					ast_verb(3, "%s answered, waiting for '%c' to acknowledge\n", ast_channel_name(p->chan), p->acceptdtmf);					/* Don't pass answer along */					ast_frfree(f);					f = &ast_null_frame;				} else {					p->acknowledged = 1;					/* Use the builtin answer frame for the 					   recording start check below. */					ast_frfree(f);					f = &answer_frame;				}			}
if (p->ackcall) {					ast_verb(3, "%s answered, waiting for '%c' to acknowledge\n", ast_channel_name(p->chan), p->acceptdtmf);					/* Don't pass answer along */					ast_frfree(f);					f = &ast_null_frame;				} else {					p->acknowledged = 1;					/* Use the builtin answer frame for the 					   recording start check below. */					ast_frfree(f);					f = &answer_frame;				}
p->ackcall
p
p
ackcall
{					ast_verb(3, "%s answered, waiting for '%c' to acknowledge\n", ast_channel_name(p->chan), p->acceptdtmf);					/* Don't pass answer along */					ast_frfree(f);					f = &ast_null_frame;				}
ast_verb(3, "%s answered, waiting for '%c' to acknowledge\n", ast_channel_name(p->chan), p->acceptdtmf);
ast_verb(3, "%s answered, waiting for '%c' to acknowledge\n", ast_channel_name(p->chan), p->acceptdtmf)
ast_verb
ast_verb
3
"%s answered, waiting for '%c' to acknowledge\n"
ast_channel_name(p->chan)
ast_channel_name
ast_channel_name
p->chan
p
p
chan
p->acceptdtmf
p
p
acceptdtmf
ast_frfree(f);
ast_frfree(f)
ast_frfree
ast_frfree
f
f
f = &ast_null_frame;
f = &ast_null_frame
f
f
&ast_null_frame
ast_null_frame
ast_null_frame
{					p->acknowledged = 1;					/* Use the builtin answer frame for the 					   recording start check below. */					ast_frfree(f);					f = &answer_frame;				}
p->acknowledged = 1;
p->acknowledged = 1
p->acknowledged
p
p
acknowledged
1
ast_frfree(f);
ast_frfree(f)
ast_frfree
ast_frfree
f
f
f = &answer_frame;
f = &answer_frame
f
f
&answer_frame
answer_frame
answer_frame
break;
case AST_FRAME_DTMF_BEGIN:
AST_FRAME_DTMF_BEGIN
AST_FRAME_DTMF_BEGIN
if((!p->acknowledged && f->subclass.integer == p->acceptdtmf) || (f->subclass.integer == p->enddtmf && endcall)){				ast_frfree(f);				f = &ast_null_frame;			}
(!p->acknowledged && f->subclass.integer == p->acceptdtmf) || (f->subclass.integer == p->enddtmf && endcall)
(!p->acknowledged && f->subclass.integer == p->acceptdtmf)
!p->acknowledged && f->subclass.integer == p->acceptdtmf
!p->acknowledged
p->acknowledged
p
p
acknowledged
f->subclass.integer == p->acceptdtmf
f->subclass.integer
f->subclass
f
f
subclass
integer
p->acceptdtmf
p
p
acceptdtmf
(f->subclass.integer == p->enddtmf && endcall)
f->subclass.integer == p->enddtmf && endcall
f->subclass.integer == p->enddtmf
f->subclass.integer
f->subclass
f
f
subclass
integer
p->enddtmf
p
p
enddtmf
endcall
endcall
{				ast_frfree(f);				f = &ast_null_frame;			}
ast_frfree(f);
ast_frfree(f)
ast_frfree
ast_frfree
f
f
f = &ast_null_frame;
f = &ast_null_frame
f
f
&ast_null_frame
ast_null_frame
ast_null_frame
break;
case AST_FRAME_DTMF_END:
AST_FRAME_DTMF_END
AST_FRAME_DTMF_END
if (!p->acknowledged && (f->subclass.integer == p->acceptdtmf)) {				if (p->chan) {					ast_verb(3, "%s acknowledged\n", ast_channel_name(p->chan));				}				p->acknowledged = 1;				ast_frfree(f);				f = &answer_frame;			} else if (f->subclass.integer == p->enddtmf && endcall) {				/* terminates call */				ast_frfree(f);				f = NULL;			}
!p->acknowledged && (f->subclass.integer == p->acceptdtmf)
!p->acknowledged
p->acknowledged
p
p
acknowledged
(f->subclass.integer == p->acceptdtmf)
f->subclass.integer == p->acceptdtmf
f->subclass.integer
f->subclass
f
f
subclass
integer
p->acceptdtmf
p
p
acceptdtmf
{				if (p->chan) {					ast_verb(3, "%s acknowledged\n", ast_channel_name(p->chan));				}				p->acknowledged = 1;				ast_frfree(f);				f = &answer_frame;			}
if (p->chan) {					ast_verb(3, "%s acknowledged\n", ast_channel_name(p->chan));				}
p->chan
p
p
chan
{					ast_verb(3, "%s acknowledged\n", ast_channel_name(p->chan));				}
ast_verb(3, "%s acknowledged\n", ast_channel_name(p->chan));
ast_verb(3, "%s acknowledged\n", ast_channel_name(p->chan))
ast_verb
ast_verb
3
"%s acknowledged\n"
ast_channel_name(p->chan)
ast_channel_name
ast_channel_name
p->chan
p
p
chan
p->acknowledged = 1;
p->acknowledged = 1
p->acknowledged
p
p
acknowledged
1
ast_frfree(f);
ast_frfree(f)
ast_frfree
ast_frfree
f
f
f = &answer_frame;
f = &answer_frame
f
f
&answer_frame
answer_frame
answer_frame
if (f->subclass.integer == p->enddtmf && endcall) {				/* terminates call */				ast_frfree(f);				f = NULL;			}
f->subclass.integer == p->enddtmf && endcall
f->subclass.integer == p->enddtmf
f->subclass.integer
f->subclass
f
f
subclass
integer
p->enddtmf
p
p
enddtmf
endcall
endcall
{				/* terminates call */				ast_frfree(f);				f = NULL;			}
ast_frfree(f);
ast_frfree(f)
ast_frfree
ast_frfree
f
f
f = NULL;
f = NULL
f
f
NULL
NULL
break;
case AST_FRAME_VOICE:
AST_FRAME_VOICE
AST_FRAME_VOICE
case AST_FRAME_VIDEO:
AST_FRAME_VIDEO
AST_FRAME_VIDEO
if (!p->acknowledged) {				ast_frfree(f);				f = &ast_null_frame;			}
!p->acknowledged
p->acknowledged
p
p
acknowledged
{				ast_frfree(f);				f = &ast_null_frame;			}
ast_frfree(f);
ast_frfree(f)
ast_frfree
ast_frfree
f
f
f = &ast_null_frame;
f = &ast_null_frame
f
f
&ast_null_frame
ast_null_frame
ast_null_frame
default:
break;
if (owner) {		ast_channel_unlock(owner);		owner = ast_channel_unref(owner);	}
owner
owner
{		ast_channel_unlock(owner);		owner = ast_channel_unref(owner);	}
ast_channel_unlock(owner);
ast_channel_unlock(owner)
ast_channel_unlock
ast_channel_unlock
owner
owner
owner = ast_channel_unref(owner);
owner = ast_channel_unref(owner)
owner
owner
ast_channel_unref(owner)
ast_channel_unref
ast_channel_unref
owner
owner
CLEANUP(ast,p);
CLEANUP(ast,p)
CLEANUP
CLEANUP
ast
ast
p
p
if (p->chan && !ast_channel_internal_bridged_channel(p->chan)) {		if (strcasecmp(ast_channel_tech(p->chan)->type, "Local")) {			ast_channel_internal_bridged_channel_set(p->chan, ast);			if (p->chan)				ast_debug(1, "Bridge on '%s' being set to '%s' (3)\n", ast_channel_name(p->chan), ast_channel_name(ast_channel_internal_bridged_channel(p->chan)));		}	}
p->chan && !ast_channel_internal_bridged_channel(p->chan)
p->chan
p
p
chan
!ast_channel_internal_bridged_channel(p->chan)
ast_channel_internal_bridged_channel(p->chan)
ast_channel_internal_bridged_channel
ast_channel_internal_bridged_channel
p->chan
p
p
chan
{		if (strcasecmp(ast_channel_tech(p->chan)->type, "Local")) {			ast_channel_internal_bridged_channel_set(p->chan, ast);			if (p->chan)				ast_debug(1, "Bridge on '%s' being set to '%s' (3)\n", ast_channel_name(p->chan), ast_channel_name(ast_channel_internal_bridged_channel(p->chan)));		}	}
if (strcasecmp(ast_channel_tech(p->chan)->type, "Local")) {			ast_channel_internal_bridged_channel_set(p->chan, ast);			if (p->chan)				ast_debug(1, "Bridge on '%s' being set to '%s' (3)\n", ast_channel_name(p->chan), ast_channel_name(ast_channel_internal_bridged_channel(p->chan)));		}
strcasecmp(ast_channel_tech(p->chan)->type, "Local")
strcasecmp
strcasecmp
ast_channel_tech(p->chan)->type
ast_channel_tech(p->chan)
ast_channel_tech
ast_channel_tech
p->chan
p
p
chan
type
"Local"
{			ast_channel_internal_bridged_channel_set(p->chan, ast);			if (p->chan)				ast_debug(1, "Bridge on '%s' being set to '%s' (3)\n", ast_channel_name(p->chan), ast_channel_name(ast_channel_internal_bridged_channel(p->chan)));		}
ast_channel_internal_bridged_channel_set(p->chan, ast);
ast_channel_internal_bridged_channel_set(p->chan, ast)
ast_channel_internal_bridged_channel_set
ast_channel_internal_bridged_channel_set
p->chan
p
p
chan
ast
ast
if (p->chan)				ast_debug(1, "Bridge on '%s' being set to '%s' (3)\n", ast_channel_name(p->chan), ast_channel_name(ast_channel_internal_bridged_channel(p->chan)));
p->chan
p
p
chan
ast_debug(1, "Bridge on '%s' being set to '%s' (3)\n", ast_channel_name(p->chan), ast_channel_name(ast_channel_internal_bridged_channel(p->chan)));
ast_debug(1, "Bridge on '%s' being set to '%s' (3)\n", ast_channel_name(p->chan), ast_channel_name(ast_channel_internal_bridged_channel(p->chan)))
ast_debug
ast_debug
1
"Bridge on '%s' being set to '%s' (3)\n"
ast_channel_name(p->chan)
ast_channel_name
ast_channel_name
p->chan
p
p
chan
ast_channel_name(ast_channel_internal_bridged_channel(p->chan))
ast_channel_name
ast_channel_name
ast_channel_internal_bridged_channel(p->chan)
ast_channel_internal_bridged_channel
ast_channel_internal_bridged_channel
p->chan
p
p
chan
ast_mutex_unlock(&p->lock);
ast_mutex_unlock(&p->lock)
ast_mutex_unlock
ast_mutex_unlock
&p->lock
p->lock
p
p
lock
if (recordagentcalls && f == &answer_frame)		agent_start_monitoring(ast,0);
recordagentcalls && f == &answer_frame
recordagentcalls
recordagentcalls
f == &answer_frame
f
f
&answer_frame
answer_frame
answer_frame
agent_start_monitoring(ast,0);
agent_start_monitoring(ast,0)
agent_start_monitoring
agent_start_monitoring
ast
ast
0
return f;
f
f
-----joern-----
(338,407,0)
(364,145,0)
(117,350,0)
(76,349,0)
(77,185,0)
(277,107,0)
(232,226,0)
(110,207,0)
(128,55,0)
(383,145,0)
(130,256,0)
(13,216,0)
(101,314,0)
(223,88,0)
(153,177,0)
(432,325,0)
(326,185,0)
(425,310,0)
(32,207,0)
(378,100,0)
(256,359,0)
(32,24,0)
(424,321,0)
(104,95,0)
(397,146,0)
(196,63,0)
(36,446,0)
(354,366,0)
(176,218,0)
(134,162,0)
(8,424,0)
(150,199,0)
(229,227,0)
(301,72,0)
(183,367,0)
(66,291,0)
(432,199,0)
(419,286,0)
(305,165,0)
(97,104,0)
(356,393,0)
(292,138,0)
(178,367,0)
(69,23,0)
(23,407,0)
(411,221,0)
(254,443,0)
(192,420,0)
(206,353,0)
(185,367,0)
(432,256,0)
(149,401,0)
(362,431,0)
(366,280,0)
(152,353,0)
(320,21,0)
(330,216,0)
(439,422,0)
(166,2,0)
(447,95,0)
(335,319,0)
(314,101,0)
(350,117,0)
(34,166,0)
(339,391,0)
(324,55,0)
(36,367,0)
(353,78,0)
(302,423,0)
(308,442,0)
(432,207,0)
(311,367,0)
(103,117,0)
(72,2,0)
(72,301,0)
(120,443,0)
(251,426,0)
(366,442,0)
(297,183,0)
(416,418,0)
(393,436,0)
(63,317,0)
(146,397,0)
(303,272,0)
(264,417,0)
(365,283,0)
(211,197,0)
(266,226,0)
(230,7,0)
(96,423,0)
(207,126,0)
(6,394,0)
(80,340,0)
(382,216,0)
(110,359,0)
(441,138,0)
(176,350,0)
(366,2,0)
(385,410,0)
(14,90,0)
(50,11,0)
(24,32,0)
(204,264,0)
(432,367,0)
(108,194,0)
(261,306,0)
(88,393,0)
(287,394,0)
(318,207,0)
(168,112,0)
(84,367,0)
(392,449,0)
(123,261,0)
(245,348,0)
(90,86,0)
(197,207,0)
(1,185,0)
(342,151,0)
(399,4,0)
(357,213,0)
(107,277,0)
(91,36,0)
(442,295,0)
(375,221,0)
(421,303,0)
(398,216,0)
(3,191,0)
(104,194,0)
(58,423,0)
(100,299,0)
(53,436,0)
(96,36,0)
(413,214,0)
(285,211,0)
(113,154,0)
(220,0,0)
(111,205,0)
(82,319,0)
(225,401,0)
(242,256,0)
(116,158,0)
(234,436,0)
(430,195,0)
(133,375,0)
(349,266,0)
(12,406,0)
(74,291,0)
(20,43,0)
(139,174,0)
(5,358,0)
(144,331,0)
(118,189,0)
(395,417,0)
(79,199,0)
(147,328,0)
(411,157,0)
(213,2,0)
(115,40,0)
(241,78,0)
(362,315,0)
(183,2,0)
(226,232,0)
(432,317,0)
(42,216,0)
(416,2,0)
(48,58,0)
(198,321,0)
(129,64,0)
(360,326,0)
(272,303,0)
(381,343,0)
(157,411,0)
(181,197,0)
(393,271,0)
(182,174,0)
(9,327,0)
(257,302,0)
(344,90,0)
(383,407,0)
(422,100,0)
(171,157,0)
(219,2,0)
(185,7,0)
(18,403,0)
(70,94,0)
(127,47,0)
(61,392,0)
(33,407,0)
(239,338,0)
(267,216,0)
(227,2,0)
(125,418,0)
(289,91,0)
(78,241,0)
(78,353,0)
(291,346,0)
(280,101,0)
(410,248,0)
(363,139,0)
(401,2,0)
(22,417,0)
(195,430,0)
(409,117,0)
(255,265,0)
(148,135,0)
(262,278,0)
(322,395,0)
(199,449,0)
(112,265,0)
(194,2,0)
(84,143,0)
(190,93,0)
(325,396,0)
(418,417,0)
(79,325,0)
(86,90,0)
(333,383,0)
(135,207,0)
(104,248,0)
(169,264,0)
(369,176,0)
(7,185,0)
(420,152,0)
(57,286,0)
(387,310,0)
(360,1,0)
(233,252,0)
(443,358,0)
(237,321,0)
(33,396,0)
(93,190,0)
(393,88,0)
(427,360,0)
(191,421,0)
(177,2,0)
(59,216,0)
(151,2,0)
(426,2,0)
(200,189,0)
(202,32,0)
(265,71,0)
(269,146,0)
(315,362,0)
(310,0,0)
(186,191,0)
(400,204,0)
(286,265,0)
(208,401,0)
(414,279,0)
(373,207,0)
(261,2,0)
(219,9,0)
(430,2,0)
(328,407,0)
(120,381,0)
(164,397,0)
(357,314,0)
(191,2,0)
(145,195,0)
(86,211,0)
(213,357,0)
(277,36,0)
(32,407,0)
(187,271,0)
(351,325,0)
(319,2,0)
(389,424,0)
(15,207,0)
(54,36,0)
(407,338,0)
(426,251,0)
(380,205,0)
(1,443,0)
(410,407,0)
(408,332,0)
(331,2,0)
(247,107,0)
(112,56,0)
(100,422,0)
(306,348,0)
(405,332,0)
(19,166,0)
(323,367,0)
(159,393,0)
(162,2,0)
(207,301,0)
(180,440,0)
(38,367,0)
(431,195,0)
(445,152,0)
(250,201,0)
(253,343,0)
(166,272,0)
(154,2,0)
(128,337,0)
(55,367,0)
(345,197,0)
(226,266,0)
(429,162,0)
(281,24,0)
(375,2,0)
(138,2,0)
(26,416,0)
(296,43,0)
(286,2,0)
(28,251,0)
(214,2,0)
(139,2,0)
(337,128,0)
(298,110,0)
(22,367,0)
(231,447,0)
(243,47,0)
(142,194,0)
(210,216,0)
(30,58,0)
(218,177,0)
(101,280,0)
(141,227,0)
(222,112,0)
(312,32,0)
(436,2,0)
(62,375,0)
(353,391,0)
(317,293,0)
(23,207,0)
(391,417,0)
(303,421,0)
(119,277,0)
(209,1,0)
(95,104,0)
(170,411,0)
(11,248,0)
(195,145,0)
(191,265,0)
(424,2,0)
(52,232,0)
(162,275,0)
(79,407,0)
(212,240,0)
(361,367,0)
(218,93,0)
(174,24,0)
(177,218,0)
(205,2,0)
(246,416,0)
(258,154,0)
(140,367,0)
(40,265,0)
(370,403,0)
(218,176,0)
(251,28,0)
(217,372,0)
(37,283,0)
(155,332,0)
(349,76,0)
(224,172,0)
(313,432,0)
(215,351,0)
(109,315,0)
(107,2,0)
(326,132,0)
(120,151,0)
(121,216,0)
(321,295,0)
(88,2,0)
(260,43,0)
(93,218,0)
(328,207,0)
(189,326,0)
(35,325,0)
(213,442,0)
(283,2,0)
(360,2,0)
(249,272,0)
(446,36,0)
(79,428,0)
(402,88,0)
(276,432,0)
(160,107,0)
(4,240,0)
(294,216,0)
(337,348,0)
(416,442,0)
(390,128,0)
(368,120,0)
(432,11,0)
(204,126,0)
(372,214,0)
(193,430,0)
(57,431,0)
(315,86,0)
(0,310,0)
(44,72,0)
(314,357,0)
(394,388,0)
(105,201,0)
(440,2,0)
(138,296,0)
(124,406,0)
(244,214,0)
(374,183,0)
(268,426,0)
(117,2,0)
(146,2,0)
(446,2,0)
(406,2,0)
(352,216,0)
(428,79,0)
(158,116,0)
(39,367,0)
(392,407,0)
(190,346,0)
(301,207,0)
(183,417,0)
(373,293,0)
(353,152,0)
(45,241,0)
(388,295,0)
(137,388,0)
(85,21,0)
(184,79,0)
(106,261,0)
(245,407,0)
(54,302,0)
(377,23,0)
(288,2,0)
(321,424,0)
(110,407,0)
(179,101,0)
(372,295,0)
(274,146,0)
(21,417,0)
(432,337,0)
(197,407,0)
(22,2,0)
(436,393,0)
(284,286,0)
(167,216,0)
(33,207,0)
(355,213,0)
(99,318,0)
(76,442,0)
(27,94,0)
(351,55,0)
(135,407,0)
(343,2,0)
(136,393,0)
(1,360,0)
(28,73,0)
(98,101,0)
(49,182,0)
(173,367,0)
(440,327,0)
(264,204,0)
(241,2,0)
(79,317,0)
(154,258,0)
(373,407,0)
(448,22,0)
(272,166,0)
(431,57,0)
(280,366,0)
(47,2,0)
(135,240,0)
(11,340,0)
(92,67,0)
(199,64,0)
(236,72,0)
(279,442,0)
(327,9,0)
(143,84,0)
(347,426,0)
(290,279,0)
(0,67,0)
(189,2,0)
(75,241,0)
(56,112,0)
(152,420,0)
(232,2,0)
(175,373,0)
(91,302,0)
(161,154,0)
(410,207,0)
(332,2,0)
(391,353,0)
(31,55,0)
(86,315,0)
(95,447,0)
(89,104,0)
(68,33,0)
(434,219,0)
(328,249,0)
(422,302,0)
(90,2,0)
(422,36,0)
(386,430,0)
(163,219,0)
(9,219,0)
(433,96,0)
(346,291,0)
(24,174,0)
(316,76,0)
(131,326,0)
(87,306,0)
(174,182,0)
(309,367,0)
(2,367,0)
(40,2,0)
(435,31,0)
(79,337,0)
(403,367,0)
(238,36,0)
(432,407,0)
(350,176,0)
(232,442,0)
(81,331,0)
(79,31,0)
(394,2,0)
(78,126,0)
(258,204,0)
(143,283,0)
(437,151,0)
(272,249,0)
(64,199,0)
(283,143,0)
(16,139,0)
(116,2,0)
(151,120,0)
(379,116,0)
(17,407,0)
(145,383,0)
(249,328,0)
(415,216,0)
(91,299,0)
(214,372,0)
(259,216,0)
(371,135,0)
(395,2,0)
(376,328,0)
(282,76,0)
(197,211,0)
(412,54,0)
(46,446,0)
(447,2,0)
(122,252,0)
(41,447,0)
(341,348,0)
(266,349,0)
(60,343,0)
(235,440,0)
(240,135,0)
(438,367,0)
(334,51,0)
(76,2,0)
(245,207,0)
(286,57,0)
(300,337,0)
(195,431,0)
(329,177,0)
(375,442,0)
(270,383,0)
(310,2,0)
(174,139,0)
(114,428,0)
(275,396,0)
(79,256,0)
(228,116,0)
(94,2,0)
(444,213,0)
(406,92,0)
(203,245,0)
(156,358,0)
(29,275,0)
(263,201,0)
(31,79,0)
(279,2,0)
(443,1,0)
(325,351,0)
(58,36,0)
(392,207,0)
(83,360,0)
(2,395,0)
(384,40,0)
(211,86,0)
(346,190,0)
(418,278,0)
(43,296,0)
(204,258,0)
(291,2,0)
(404,249,0)
(421,191,0)
(307,366,0)
(393,443,0)
(343,381,0)
(401,208,0)
(340,11,0)
(332,265,0)
(10,367,0)
(240,4,0)
(431,362,0)
(221,375,0)
(43,188,0)
(93,208,0)
(65,232,0)
(332,405,0)
(318,407,0)
(221,411,0)
(420,417,0)
(302,54,0)
(327,440,0)
(381,120,0)
(92,406,0)
(296,138,0)
(25,252,0)
(336,22,0)
(194,104,0)
(79,11,0)
(317,63,0)
(208,93,0)
(418,416,0)
(112,2,0)
(164,367,0)
(273,317,0)
(397,164,0)
(383,207,0)
(79,207,0)
(159,136,1)
(291,2,1)
(79,199,1)
(264,417,1)
(317,63,1)
(191,2,1)
(60,253,1)
(291,66,1)
(434,163,1)
(146,274,1)
(155,408,1)
(145,364,1)
(35,33,1)
(443,1,1)
(360,83,1)
(424,389,1)
(230,77,1)
(424,2,1)
(211,197,1)
(411,170,1)
(8,237,1)
(128,390,1)
(96,433,1)
(78,241,1)
(440,2,1)
(204,258,1)
(185,7,1)
(79,407,1)
(30,102,1)
(79,256,1)
(432,337,1)
(162,134,1)
(268,9,1)
(76,2,1)
(87,261,1)
(432,11,1)
(428,114,1)
(336,36,1)
(393,88,1)
(312,202,1)
(353,391,1)
(77,55,1)
(297,374,1)
(365,101,1)
(318,99,1)
(256,242,1)
(22,2,1)
(408,190,1)
(57,286,1)
(116,2,1)
(313,21,1)
(68,275,1)
(283,37,1)
(356,88,1)
(342,437,1)
(150,392,1)
(206,152,1)
(416,2,1)
(28,251,1)
(422,439,1)
(213,442,1)
(79,207,1)
(232,2,1)
(446,46,1)
(394,287,1)
(21,320,1)
(49,174,1)
(375,2,1)
(113,331,1)
(138,292,1)
(410,407,1)
(54,36,1)
(153,329,1)
(163,302,1)
(151,342,1)
(242,130,1)
(138,2,1)
(48,30,1)
(408,265,1)
(163,28,1)
(303,272,1)
(435,184,1)
(349,266,1)
(241,45,1)
(171,411,1)
(393,443,1)
(7,230,1)
(298,182,1)
(331,144,1)
(190,93,1)
(81,158,1)
(145,383,1)
(418,417,1)
(372,217,1)
(181,345,1)
(135,371,1)
(363,24,1)
(440,235,1)
(419,284,1)
(379,22,1)
(238,164,1)
(446,2,1)
(84,143,1)
(72,2,1)
(16,363,1)
(168,222,1)
(349,76,1)
(240,212,1)
(160,119,1)
(375,133,1)
(79,317,1)
(283,2,1)
(345,431,1)
(310,387,1)
(389,8,1)
(74,318,1)
(245,207,1)
(191,265,1)
(391,339,1)
(234,53,1)
(116,228,1)
(372,214,1)
(194,2,1)
(373,175,1)
(120,443,1)
(437,368,1)
(14,211,1)
(154,2,1)
(4,399,1)
(154,161,1)
(376,421,1)
(360,326,1)
(176,350,1)
(392,407,1)
(380,111,1)
(86,211,1)
(338,239,1)
(221,375,1)
(117,409,1)
(166,2,1)
(364,383,1)
(331,2,1)
(196,273,1)
(72,236,1)
(430,386,1)
(205,380,1)
(403,18,1)
(272,166,1)
(169,258,1)
(170,221,1)
(432,407,1)
(332,155,1)
(277,119,1)
(269,185,1)
(61,56,1)
(304,94,1)
(139,16,1)
(217,214,1)
(431,195,1)
(344,14,1)
(33,207,1)
(58,36,1)
(92,406,1)
(401,2,1)
(436,234,1)
(315,109,1)
(70,27,1)
(194,108,1)
(343,2,1)
(432,325,1)
(189,2,1)
(146,2,1)
(152,420,1)
(382,256,1)
(418,125,1)
(123,106,1)
(307,354,1)
(339,152,1)
(277,107,1)
(306,87,1)
(11,340,1)
(277,36,1)
(428,79,1)
(347,268,1)
(125,416,1)
(110,298,1)
(180,219,1)
(91,289,1)
(249,328,1)
(53,159,1)
(232,442,1)
(246,26,1)
(186,23,1)
(183,297,1)
(175,362,1)
(303,421,1)
(325,351,1)
(90,344,1)
(23,377,1)
(366,442,1)
(143,283,1)
(97,47,1)
(365,157,1)
(62,349,1)
(164,397,1)
(385,104,1)
(40,2,1)
(410,207,1)
(228,379,1)
(426,347,1)
(131,189,1)
(147,376,1)
(433,58,1)
(218,176,1)
(279,2,1)
(373,407,1)
(219,434,1)
(124,0,1)
(197,407,1)
(104,194,1)
(94,2,1)
(370,2,1)
(135,407,1)
(106,43,1)
(64,129,1)
(316,282,1)
(245,203,1)
(101,314,1)
(365,227,1)
(327,440,1)
(211,285,1)
(226,232,1)
(322,288,1)
(239,17,1)
(240,135,1)
(294,23,1)
(409,103,1)
(442,308,1)
(400,264,1)
(255,40,1)
(318,407,1)
(151,2,1)
(247,160,1)
(425,319,1)
(32,207,1)
(292,441,1)
(177,2,1)
(24,32,1)
(261,123,1)
(89,97,1)
(158,116,1)
(55,324,1)
(426,2,1)
(112,2,1)
(220,310,1)
(374,304,1)
(328,147,1)
(50,410,1)
(121,362,1)
(404,328,1)
(32,407,1)
(36,446,1)
(371,148,1)
(420,192,1)
(207,301,1)
(109,86,1)
(326,131,1)
(373,207,1)
(407,338,1)
(397,146,1)
(182,49,1)
(294,199,1)
(112,168,1)
(243,4,1)
(203,306,1)
(90,2,1)
(332,265,1)
(182,174,1)
(244,413,1)
(332,2,1)
(392,61,1)
(199,64,1)
(1,360,1)
(86,90,1)
(381,120,1)
(148,23,1)
(135,207,1)
(406,2,1)
(413,94,1)
(430,2,1)
(241,2,1)
(290,414,1)
(183,2,1)
(52,76,1)
(174,139,1)
(102,277,1)
(65,52,1)
(88,223,1)
(29,162,1)
(6,321,1)
(82,9,1)
(137,394,1)
(75,204,1)
(333,270,1)
(117,2,1)
(235,180,1)
(110,207,1)
(47,2,1)
(1,185,1)
(93,218,1)
(421,191,1)
(108,142,1)
(390,300,1)
(69,277,1)
(69,92,1)
(276,432,1)
(286,265,1)
(127,243,1)
(152,445,1)
(279,290,1)
(410,385,1)
(416,442,1)
(79,31,1)
(141,229,1)
(254,405,1)
(58,48,1)
(189,118,1)
(301,72,1)
(351,215,1)
(212,135,1)
(227,141,1)
(40,115,1)
(286,2,1)
(249,404,1)
(80,50,1)
(69,381,1)
(190,346,1)
(392,207,1)
(85,428,1)
(100,422,1)
(391,417,1)
(15,78,1)
(429,47,1)
(420,417,1)
(91,36,1)
(287,6,1)
(157,411,1)
(237,198,1)
(22,417,1)
(302,54,1)
(215,35,1)
(369,350,1)
(374,100,1)
(26,157,1)
(223,402,1)
(275,29,1)
(284,23,1)
(386,193,1)
(144,81,1)
(381,343,1)
(2,395,1)
(294,56,1)
(79,11,1)
(47,127,1)
(432,256,1)
(411,221,1)
(33,68,1)
(214,2,1)
(213,2,1)
(329,208,1)
(208,401,1)
(59,325,1)
(162,2,1)
(346,291,1)
(4,240,1)
(236,44,1)
(337,128,1)
(422,36,1)
(362,431,1)
(0,310,1)
(432,313,1)
(174,24,1)
(382,182,1)
(195,145,1)
(418,416,1)
(270,57,1)
(99,207,1)
(383,407,1)
(54,412,1)
(414,372,1)
(120,151,1)
(76,316,1)
(157,171,1)
(176,369,1)
(24,281,1)
(56,112,1)
(94,70,1)
(76,442,1)
(328,407,1)
(395,417,1)
(229,418,1)
(166,19,1)
(130,110,1)
(444,355,1)
(179,98,1)
(197,207,1)
(136,381,1)
(324,403,1)
(439,378,1)
(378,91,1)
(282,183,1)
(436,2,1)
(79,325,1)
(353,152,1)
(274,269,1)
(231,41,1)
(227,2,1)
(96,36,1)
(335,82,1)
(350,117,1)
(32,312,1)
(285,197,1)
(360,2,1)
(273,373,1)
(261,2,1)
(110,407,1)
(200,158,1)
(202,303,1)
(99,407,1)
(34,249,1)
(304,382,1)
(37,365,1)
(412,257,1)
(366,2,1)
(387,425,1)
(401,149,1)
(357,213,1)
(314,357,1)
(431,57,1)
(264,169,1)
(121,317,1)
(88,2,1)
(23,407,1)
(128,55,1)
(289,304,1)
(319,2,1)
(23,207,1)
(177,153,1)
(139,2,1)
(310,2,1)
(320,85,1)
(195,430,1)
(343,60,1)
(355,280,1)
(21,417,1)
(107,247,1)
(193,145,1)
(163,102,1)
(304,59,1)
(441,20,1)
(445,420,1)
(365,349,1)
(296,138,1)
(31,55,1)
(133,62,1)
(106,205,1)
(354,179,1)
(59,4,1)
(43,296,1)
(18,370,1)
(209,254,1)
(81,326,1)
(399,240,1)
(308,279,1)
(353,206,1)
(31,435,1)
(191,3,1)
(432,207,1)
(222,23,1)
(149,225,1)
(95,447,1)
(375,442,1)
(107,2,1)
(432,199,1)
(393,356,1)
(103,177,1)
(114,84,1)
(368,343,1)
(265,255,1)
(326,185,1)
(59,11,1)
(104,95,1)
(260,205,1)
(219,2,1)
(46,238,1)
(112,265,1)
(115,384,1)
(258,154,1)
(0,220,1)
(351,55,1)
(27,318,1)
(447,231,1)
(192,241,1)
(111,303,1)
(362,315,1)
(304,294,1)
(183,417,1)
(402,436,1)
(313,428,1)
(20,260,1)
(319,335,1)
(213,444,1)
(266,226,1)
(406,12,1)
(427,209,1)
(9,219,1)
(33,407,1)
(416,246,1)
(79,337,1)
(66,74,1)
(198,442,1)
(383,207,1)
(129,150,1)
(44,15,1)
(281,32,1)
(41,89,1)
(304,121,1)
(377,69,1)
(232,65,1)
(253,443,1)
(394,2,1)
(395,322,1)
(204,264,1)
(119,393,1)
(432,317,1)
(98,227,1)
(328,207,1)
(422,302,1)
(101,280,1)
(22,448,1)
(9,327,1)
(63,196,1)
(448,336,1)
(205,2,1)
(17,331,1)
(161,113,1)
(45,75,1)
(134,429,1)
(204,400,1)
(366,307,1)
(280,366,1)
(300,245,1)
(382,337,1)
(69,405,1)
(447,2,1)
(286,419,1)
(388,137,1)
(3,186,1)
(197,181,1)
(78,353,1)
(245,407,1)
(393,436,1)
(69,319,1)
(93,208,1)
(272,249,1)
(118,200,1)
(315,86,1)
(142,95,1)
(321,424,1)
(12,124,1)
(383,333,1)
(91,302,1)
(251,426,1)
(405,332,1)
(214,244,1)
(318,207,1)
(225,346,1)
(218,177,1)
(83,427,1)
(184,114,1)
(19,34,1)
(304,388,1)
(340,80,1)
(257,96,1)
(384,190,1)
(223,381,2)
(399,23,2)
(368,343,2)
(163,9,2)
(296,138,2)
(79,114,2)
(204,258,2)
(342,343,2)
(337,128,2)
(346,291,2)
(11,340,2)
(82,277,2)
(432,11,2)
(362,23,2)
(168,23,2)
(226,232,2)
(30,102,2)
(213,227,2)
(91,36,2)
(245,207,2)
(110,407,2)
(277,381,2)
(174,139,2)
(57,23,2)
(418,416,2)
(383,57,2)
(106,303,2)
(273,362,2)
(383,407,2)
(104,47,2)
(340,47,2)
(179,227,2)
(327,440,2)
(45,331,2)
(33,207,2)
(236,331,2)
(29,47,2)
(95,447,2)
(362,315,2)
(393,381,2)
(243,4,2)
(253,405,2)
(315,86,2)
(182,174,2)
(239,331,2)
(163,277,2)
(328,407,2)
(94,318,2)
(314,357,2)
(211,431,2)
(279,94,2)
(268,9,2)
(382,23,2)
(391,152,2)
(225,346,2)
(301,72,2)
(134,47,2)
(249,328,2)
(159,381,2)
(78,331,2)
(266,76,2)
(356,381,2)
(3,23,2)
(135,207,2)
(182,303,2)
(208,346,2)
(245,303,2)
(283,2,2)
(350,117,2)
(372,214,2)
(277,107,2)
(177,208,2)
(439,304,2)
(129,56,2)
(50,47,2)
(240,23,2)
(185,7,2)
(104,95,2)
(138,205,2)
(44,331,2)
(397,146,2)
(85,428,2)
(427,405,2)
(380,303,2)
(204,264,2)
(79,199,2)
(86,211,2)
(127,4,2)
(36,446,2)
(261,303,2)
(424,2,2)
(303,272,2)
(300,303,2)
(444,227,2)
(298,182,2)
(232,442,2)
(407,338,2)
(93,218,2)
(331,2,2)
(234,381,2)
(281,303,2)
(366,2,2)
(432,199,2)
(169,331,2)
(437,343,2)
(198,94,2)
(32,303,2)
(84,143,2)
(23,207,2)
(408,318,2)
(205,303,2)
(377,318,2)
(328,421,2)
(174,303,2)
(219,277,2)
(76,2,2)
(192,331,2)
(95,47,2)
(257,102,2)
(90,431,2)
(381,405,2)
(292,205,2)
(175,362,2)
(52,76,2)
(47,4,2)
(53,381,2)
(142,47,2)
(420,331,2)
(199,56,2)
(209,405,2)
(301,331,2)
(21,428,2)
(325,47,2)
(31,114,2)
(96,36,2)
(119,381,2)
(151,343,2)
(135,23,2)
(241,331,2)
(401,346,2)
(440,2,2)
(16,303,2)
(376,421,2)
(70,318,2)
(302,102,2)
(275,47,2)
(421,191,2)
(443,405,2)
(9,277,2)
(426,9,2)
(349,76,2)
(389,94,2)
(195,57,2)
(432,337,2)
(2,395,2)
(112,23,2)
(191,265,2)
(393,88,2)
(241,2,2)
(191,2,2)
(360,326,2)
(26,157,2)
(22,417,2)
(0,310,2)
(240,135,2)
(434,277,2)
(90,2,2)
(176,350,2)
(433,102,2)
(89,47,2)
(303,23,2)
(147,421,2)
(102,277,2)
(221,375,2)
(49,174,2)
(400,331,2)
(394,2,2)
(393,443,2)
(148,23,2)
(391,417,2)
(443,1,2)
(63,362,2)
(337,303,2)
(66,318,2)
(335,277,2)
(100,304,2)
(353,391,2)
(57,286,2)
(194,2,2)
(414,94,2)
(432,317,2)
(385,47,2)
(315,431,2)
(211,197,2)
(124,319,2)
(189,158,2)
(214,2,2)
(264,417,2)
(78,241,2)
(1,360,2)
(272,166,2)
(411,349,2)
(431,23,2)
(9,9,2)
(24,303,2)
(416,157,2)
(229,157,2)
(62,349,2)
(272,249,2)
(432,325,2)
(24,32,2)
(166,2,2)
(303,421,2)
(285,431,2)
(43,296,2)
(284,23,2)
(6,94,2)
(219,2,2)
(310,319,2)
(327,219,2)
(364,57,2)
(96,102,2)
(79,207,2)
(86,431,2)
(332,265,2)
(131,158,2)
(402,381,2)
(328,207,2)
(109,86,2)
(373,207,2)
(75,331,2)
(79,407,2)
(14,431,2)
(152,420,2)
(27,318,2)
(218,176,2)
(32,407,2)
(360,405,2)
(203,303,2)
(145,57,2)
(318,407,2)
(256,182,2)
(110,182,2)
(152,331,2)
(258,331,2)
(286,2,2)
(194,47,2)
(204,331,2)
(406,2,2)
(139,2,2)
(150,56,2)
(401,2,2)
(353,331,2)
(255,190,2)
(351,55,2)
(121,23,2)
(128,55,2)
(125,157,2)
(112,2,2)
(206,152,2)
(244,94,2)
(286,23,2)
(197,407,2)
(138,2,2)
(302,54,2)
(93,346,2)
(86,90,2)
(213,2,2)
(15,331,2)
(412,102,2)
(47,2,2)
(310,2,2)
(136,381,2)
(88,2,2)
(20,205,2)
(208,401,2)
(151,2,2)
(251,9,2)
(429,47,2)
(205,2,2)
(83,405,2)
(319,277,2)
(249,421,2)
(422,304,2)
(56,23,2)
(177,2,2)
(184,114,2)
(291,318,2)
(407,331,2)
(390,303,2)
(72,331,2)
(294,23,2)
(193,57,2)
(343,2,2)
(410,47,2)
(447,47,2)
(436,381,2)
(245,407,2)
(405,332,2)
(196,362,2)
(88,381,2)
(218,177,2)
(373,362,2)
(425,319,2)
(242,182,2)
(383,207,2)
(357,227,2)
(289,304,2)
(431,57,2)
(100,422,2)
(326,158,2)
(157,411,2)
(419,23,2)
(61,56,2)
(174,24,2)
(33,407,2)
(394,94,2)
(421,23,2)
(162,2,2)
(354,227,2)
(4,23,2)
(339,152,2)
(11,47,2)
(410,407,2)
(58,36,2)
(149,346,2)
(189,2,2)
(41,47,2)
(31,55,2)
(411,221,2)
(434,9,2)
(123,303,2)
(409,177,2)
(1,185,2)
(72,2,2)
(222,23,2)
(381,120,2)
(43,205,2)
(246,157,2)
(318,207,2)
(157,349,2)
(111,303,2)
(392,56,2)
(200,158,2)
(78,353,2)
(92,406,2)
(35,47,2)
(176,177,2)
(261,2,2)
(392,207,2)
(215,47,2)
(190,93,2)
(386,57,2)
(133,349,2)
(120,151,2)
(9,327,2)
(120,343,2)
(91,302,2)
(277,36,2)
(76,442,2)
(87,303,2)
(48,102,2)
(344,431,2)
(195,430,2)
(424,94,2)
(319,2,2)
(32,207,2)
(270,57,2)
(97,47,2)
(195,145,2)
(115,190,2)
(202,303,2)
(296,205,2)
(227,2,2)
(183,417,2)
(347,9,2)
(247,119,2)
(23,318,2)
(112,265,2)
(146,2,2)
(164,397,2)
(237,94,2)
(183,2,2)
(362,431,2)
(79,256,2)
(197,431,2)
(430,2,2)
(373,407,2)
(0,319,2)
(137,94,2)
(118,158,2)
(160,119,2)
(395,417,2)
(4,240,2)
(68,47,2)
(220,319,2)
(154,2,2)
(213,442,2)
(65,76,2)
(314,227,2)
(388,94,2)
(381,343,2)
(446,2,2)
(375,2,2)
(34,421,2)
(422,302,2)
(321,94,2)
(28,9,2)
(139,303,2)
(217,94,2)
(321,424,2)
(317,63,2)
(162,47,2)
(153,208,2)
(154,331,2)
(404,421,2)
(227,157,2)
(60,405,2)
(306,303,2)
(291,2,2)
(346,318,2)
(171,349,2)
(226,76,2)
(219,9,2)
(286,265,2)
(264,331,2)
(338,331,2)
(432,256,2)
(9,219,2)
(130,182,2)
(372,94,2)
(265,190,2)
(93,208,2)
(199,64,2)
(254,405,2)
(107,2,2)
(406,319,2)
(231,47,2)
(442,94,2)
(56,112,2)
(91,304,2)
(79,31,2)
(353,152,2)
(69,318,2)
(120,443,2)
(190,346,2)
(161,331,2)
(180,219,2)
(40,2,2)
(410,207,2)
(416,2,2)
(441,205,2)
(392,407,2)
(197,207,2)
(369,177,2)
(135,407,2)
(190,318,2)
(79,11,2)
(207,301,2)
(54,102,2)
(325,351,2)
(235,219,2)
(80,47,2)
(317,362,2)
(232,2,2)
(40,190,2)
(308,94,2)
(155,318,2)
(416,442,2)
(387,319,2)
(59,23,2)
(375,442,2)
(287,94,2)
(116,2,2)
(418,157,2)
(191,23,2)
(447,2,2)
(19,421,2)
(436,2,2)
(101,280,2)
(166,421,2)
(422,36,2)
(349,266,2)
(280,227,2)
(375,349,2)
(418,417,2)
(207,331,2)
(272,421,2)
(218,208,2)
(22,2,2)
(79,325,2)
(290,94,2)
(430,57,2)
(251,426,2)
(307,227,2)
(426,2,2)
(363,303,2)
(98,227,2)
(431,195,2)
(360,2,2)
(384,190,2)
(58,102,2)
(221,349,2)
(357,213,2)
(366,442,2)
(405,318,2)
(104,194,2)
(64,56,2)
(280,366,2)
(79,317,2)
(393,436,2)
(117,2,2)
(378,304,2)
(333,57,2)
(435,114,2)
(17,331,2)
(345,431,2)
(413,94,2)
(181,431,2)
(428,79,2)
(276,432,2)
(145,383,2)
(113,331,2)
(440,219,2)
(258,154,2)
(117,177,2)
(12,319,2)
(343,405,2)
(266,226,2)
(101,314,2)
(94,2,2)
(214,94,2)
(143,283,2)
(350,177,2)
(103,177,2)
(232,76,2)
(54,36,2)
(8,94,2)
(326,185,2)
(212,23,2)
(23,407,2)
(170,349,2)
(110,207,2)
(355,227,2)
(445,331,2)
(260,205,2)
(79,337,2)
(141,157,2)
(1,405,2)
(312,303,2)
(332,2,2)
(186,23,2)
(432,207,2)
(21,417,2)
(320,428,2)
(107,119,2)
(351,47,2)
(33,47,2)
(101,227,2)
(279,2,2)
(420,417,2)
(366,227,2)
(28,251,2)
(329,208,2)
(74,318,2)
(371,23,2)
(432,407,2)
(332,318,2)
(92,319,2)
(128,303,2)
(158,116,2)
(108,47,2)
-----------------------------------
(0,ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT)
(1,cur_time - p->start)
(2,*p = ast_channel_tech_pvt(ast)
(3,acknowledged)
(4,f->subclass.integer == AST_CONTROL_ANSWER)
(5,if (p->autologoff && (howlong >= p->autologoff)
(6,p)
(7,time(NULL)
(8,p)
(9,p->chan && ast_channel_trylock(p->chan)
(10,if (p->chan)
(11,f = &ast_null_frame)
(12,chan)
(13,if (f->subclass.integer == AST_CONTROL_ANSWER)
(14,p)
(15,f)
(16,enddtmf)
(17,f)
(18,NULL)
(19,acceptdtmf)
(20,"%s acknowledged\\n")
(21,agent_start_monitoring(ast,0)
(22,CHECK_FORMATS(ast, p)
(23,f->frametype)
(24,f->subclass.integer)
(25,while (p->chan && ast_channel_trylock(p->chan)
(26,p)
(27,p)
(28,DEADLOCK_AVOIDANCE(&p->lock)
(29,1)
(30,owner)
(31,&answer_frame)
(32,f->subclass)
(33,ast_frfree(f)
(34,p)
(35,f)
(36,owner = agent_lock_owner(p)
(37,lock)
(38,p)
(39,if (!f)
(40,p->acknowledged)
(41,p)
(42,case AST_FRAME_VIDEO:)
(43,ast_verb(3, "%s acknowledged\\n", ast_channel_name(p->chan)
(44,p)
(45,chan)
(46,p)
(47,p->ackcall)
(48,AST_SOFTHANGUP_EXPLICIT)
(49,endcall)
(50,f)
(51,)
(52,p)
(53,p)
(54,ast_channel_unref(owner)
(55,answer_frame = { AST_FRAME_CONTROL, { AST_CONTROL_ANSWER } })
(56,!p->acknowledged)
(57,!p->acknowledged)
(58,ast_softhangup(owner, AST_SOFTHANGUP_EXPLICIT)
(59,break;)
(60,autologoff)
(61,f)
(62,p)
(63,&ast_null_frame)
(64,&ast_null_frame)
(65,chan)
(66,ackcall)
(67,)
(68,f)
(69,f)
(70,chan)
(71,)
(72,p->chan)
(73,)
(74,p)
(75,p)
(76,p->chan)
(77,cur_time)
(78,ast_channel_fdno_set(p->chan, (ast_channel_fdno(ast)
(79,f == &answer_frame)
(80,ast_null_frame)
(81,p)
(82,p)
(83,start)
(84,ast_mutex_unlock(&p->lock)
(85,ast)
(86,f->subclass.integer == p->enddtmf)
(87,1)
(88,p->autologoff)
(89,"%s answered, waiting for \'%c\' to acknowledge\\n")
(90,p->enddtmf)
(91,ast_channel_unlock(owner)
(92,ast_channel_unlock(p->chan)
(93,!p->acknowledged && p->chan && (ast_channel_state(p->chan)
(94,p->chan)
(95,ast_channel_name(p->chan)
(96,ast_channel_unlock(owner)
(97,3)
(98,1)
(99,f)
(100,owner = ast_channel_unref(owner)
(101,ast_debug(1, "Bridge on \'%s\' being set to \'%s\' (3)
(102,owner)
(103,p)
(104,ast_verb(3, "%s answered, waiting for \'%c\' to acknowledge\\n", ast_channel_name(p->chan)
(105,switch (f->frametype)
(106,p)
(107,p->chan)
(108,acceptdtmf)
(109,endcall)
(110,ast_frfree(f)
(111,p)
(112,p->acknowledged)
(113,p)
(114,recordagentcalls)
(115,acknowledged)
(116,p->start)
(117,p->chan)
(118,start)
(119,owner)
(120,howlong >= p->autologoff)
(121,break;)
(122,if (owner)
(123,acknowledged)
(124,p)
(125,ast)
(126,)
(127,ackcall)
(128,&answer_frame)
(129,ast_null_frame)
(130,f)
(131,cur_time)
(132,)
(133,chan)
(134,acknowledged)
(135,f->subclass)
(136,LOG_NOTICE)
(137,0)
(138,p->chan)
(139,p->enddtmf)
(140,f)
(141,chan)
(142,p)
(143,&p->lock)
(144,chan)
(145,f->subclass.integer)
(146,p->lock)
(147,subclass)
(148,f)
(149,acknowledged)
(150,f)
(151,p->autologoff)
(152,ast_channel_fdno(ast)
(153,chan)
(154,p->chan)
(155,acknowledged)
(156,howlong)
(157,strcasecmp(ast_channel_tech(p->chan)
(158,!p->start)
(159,"Agent \'%s\' didn\'t answer/confirm within %d seconds (waited %d)
(160,p)
(161,chan)
(162,p->acknowledged)
(163,p)
(164,ast_mutex_lock(&p->lock)
(165,)
(166,p->acceptdtmf)
(167,case AST_FRAME_DTMF_END:)
(168,acknowledged)
(169,ast)
(170,type)
(171,"Local")
(172,)
(173,if (owner)
(174,f->subclass.integer == p->enddtmf)
(175,f)
(176,ast_channel_state(p->chan)
(177,p->chan)
(178,cur_time)
(179,"Bridge on \'%s\' being set to \'%s\' (3)
(180,p)
(181,subclass)
(182,f->subclass.integer == p->enddtmf && endcall)
(183,CLEANUP(ast,p)
(184,f)
(185,cur_time = time(NULL)
(186,p)
(187,if (owner || p->chan)
(188,)
(189,p->start)
(190,!p->ackcall && !p->acknowledged && p->chan && (ast_channel_state(p->chan)
(191,p->acknowledged)
(192,ast)
(193,p)
(194,p->acceptdtmf)
(195,f->subclass.integer == p->acceptdtmf)
(196,ast_null_frame)
(197,f->subclass)
(198,AST_DEVICE_UNAVAILABLE)
(199,f = &ast_null_frame)
(200,p)
(201,)
(202,f)
(203,f)
(204,ast_copy_flags(ast_channel_flags(p->chan)
(205,p->chan)
(206,AST_TIMING_FD)
(207,f = ast_read(p->chan)
(208,!p->acknowledged)
(209,cur_time)
(210,if((!p->acknowledged && f->subclass.integer == p->acceptdtmf)
(211,f->subclass.integer)
(212,integer)
(213,p->chan)
(214,p->chan)
(215,answer_frame)
(216,)
(217,NULL)
(218,p->chan && (ast_channel_state(p->chan)
(219,p->chan)
(220,AST_SOFTHANGUP_EXPLICIT)
(221,ast_channel_tech(p->chan)
(222,p)
(223,autologoff)
(224,if (p->ackcall)
(225,p)
(226,ast_channel_internal_bridged_channel(p->chan)
(227,p->chan)
(228,start)
(229,p)
(230,NULL)
(231,chan)
(232,p->chan)
(233,if (p->chan)
(234,name)
(235,chan)
(236,chan)
(237,"Agent/%s")
(238,owner)
(239,ast_null_frame)
(240,f->subclass.integer)
(241,p->chan)
(242,NULL)
(243,p)
(244,chan)
(245,ast_frfree(f)
(246,chan)
(247,chan)
(248,)
(249,f->subclass.integer)
(250,if (!p->ackcall && !p->acknowledged && p->chan && (ast_channel_state(p->chan)
(251,&p->lock)
(252,)
(253,p)
(254,howlong)
(255,1)
(256,f = NULL)
(257,owner)
(258,ast_channel_flags(p->chan)
(259,if (!p->acknowledged && (f->subclass.integer == p->acceptdtmf)
(260,3)
(261,p->acknowledged)
(262,if (p->chan)
(263,if (!p->acknowledged)
(264,ast_channel_flags(ast)
(265,p->acknowledged = 1)
(266,!ast_channel_internal_bridged_channel(p->chan)
(267,if (!p->acknowledged)
(268,p)
(269,p)
(270,f)
(271,)
(272,f->subclass.integer == p->acceptdtmf)
(273,f)
(274,lock)
(275,p->acknowledged = 1)
(276,RET)
(277,owner || p->chan)
(278,)
(279,p->chan)
(280,ast_channel_name(p->chan)
(281,integer)
(282,p)
(283,p->lock)
(284,p)
(285,integer)
(286,p->acknowledged)
(287,acknowledged)
(288,p)
(289,owner)
(290,chan)
(291,p->ackcall)
(292,chan)
(293,)
(294,break;)
(295,)
(296,ast_channel_name(p->chan)
(297,p)
(298,f)
(299,)
(300,f)
(301,ast_read(p->chan)
(302,owner = ast_channel_unref(owner)
(303,!p->acknowledged && (f->subclass.integer == p->acceptdtmf)
(304,owner)
(305,if (p->chan)
(306,p->acknowledged = 1)
(307,chan)
(308,NULL)
(309,if (p->chan && !ast_channel_internal_bridged_channel(p->chan)
(310,p->chan)
(311,answer_frame)
(312,subclass)
(313,f)
(314,ast_channel_name(ast_channel_internal_bridged_channel(p->chan)
(315,f->subclass.integer == p->enddtmf && endcall)
(316,chan)
(317,f = &ast_null_frame)
(318,!f)
(319,p->chan)
(320,0)
(321,ast_devstate_changed(AST_DEVICE_UNAVAILABLE, "Agent/%s", p->agent)
(322,ast)
(323,owner)
(324,answer_frame)
(325,f = &answer_frame)
(326,p->start = cur_time)
(327,ast_channel_trylock(p->chan)
(328,f->subclass)
(329,p)
(330,case AST_FRAME_CONTROL:)
(331,p->chan)
(332,p->acknowledged)
(333,subclass)
(334,if (strcasecmp(ast_channel_tech(p->chan)
(335,chan)
(336,ast)
(337,f = &answer_frame)
(338,&ast_null_frame)
(339,ast)
(340,&ast_null_frame)
(341,if (p->chan)
(342,autologoff)
(343,p->autologoff)
(344,enddtmf)
(345,f)
(346,!p->ackcall)
(347,lock)
(348,)
(349,p->chan && !ast_channel_internal_bridged_channel(p->chan)
(350,ast_channel_state(p->chan)
(351,&answer_frame)
(352,case AST_FRAME_VOICE:)
(353,(ast_channel_fdno(ast)
(354,p)
(355,p)
(356,howlong)
(357,ast_channel_internal_bridged_channel(p->chan)
(358,)
(359,)
(360,p->start)
(361,if (recordagentcalls && f == &answer_frame)
(362,(!p->acknowledged && f->subclass.integer == p->acceptdtmf)
(363,p)
(364,integer)
(365,p)
(366,p->chan)
(367,)
(368,howlong)
(369,AST_STATE_UP)
(370,f)
(371,subclass)
(372,ast_channel_internal_bridged_channel_set(p->chan, NULL)
(373,ast_frfree(f)
(374,ast)
(375,p->chan)
(376,f)
(377,frametype)
(378,owner)
(379,p)
(380,chan)
(381,p->autologoff && (howlong >= p->autologoff)
(382,break;)
(383,f->subclass)
(384,p)
(385,f)
(386,acceptdtmf)
(387,chan)
(388,p->acknowledged = 0)
(389,agent)
(390,answer_frame)
(391,ast_channel_fdno(ast)
(392,ast_frfree(f)
(393,ast_log(LOG_NOTICE, "Agent \'%s\' didn\'t answer/confirm within %d seconds (waited %d)
(394,p->acknowledged)
(395,ast_channel_tech_pvt(ast)
(396,)
(397,&p->lock)
(398,default:)
(399,AST_CONTROL_ANSWER)
(400,AST_FLAG_EXCEPTION)
(401,p->acknowledged)
(402,p)
(403,*f = NULL)
(404,integer)
(405,!p->acknowledged)
(406,p->chan)
(407,f = &ast_null_frame)
(408,p)
(409,chan)
(410,ast_frfree(f)
(411,ast_channel_tech(p->chan)
(412,owner)
(413,p)
(414,p)
(415,case AST_FRAME_DTMF_BEGIN:)
(416,p->chan)
(417,struct ast_channel *ast)
(418,ast_channel_internal_bridged_channel_set(p->chan, ast)
(419,acknowledged)
(420,ast_channel_fdno(ast)
(421,!p->acknowledged)
(422,ast_channel_unref(owner)
(423,)
(424,p->agent)
(425,p)
(426,p->lock)
(427,p)
(428,recordagentcalls && f == &answer_frame)
(429,p)
(430,p->acceptdtmf)
(431,!p->acknowledged && f->subclass.integer == p->acceptdtmf)
(432,return f;)
(433,owner)
(434,chan)
(435,answer_frame)
(436,p->name)
(437,p)
(438,if (!p->start)
(439,owner)
(440,p->chan)
(441,p)
(442,p->chan = NULL)
(443,howlong = cur_time - p->start)
(444,chan)
(445,AST_AGENT_FD)
(446,agent_lock_owner(p)
(447,p->chan)
(448,p)
(449,)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^