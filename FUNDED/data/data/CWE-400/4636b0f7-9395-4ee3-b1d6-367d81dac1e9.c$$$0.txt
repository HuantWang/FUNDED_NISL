-----label-----
0
-----code-----
static void
_socket_open(SOCKET *sockp, CCS call)
{
    struct sockaddr_in dest_addr;
    int tries;

    if (*sockp != INVALID_SOCKET) {
	return;
    }

    util_socket_lib_init();

    memset(&dest_addr, 0, sizeof(dest_addr));
    dest_addr.sin_family = PF_INET;
    dest_addr.sin_addr.s_addr = inet_addr(prop_get_str(P_CLIENT_HOST));
    dest_addr.sin_port = htons((u_short)prop_get_ulong(P_CLIENT_PORT));

    if (((*sockp = socket(PF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)) {
	char host_port[256];

	snprintf(host_port, charlen(host_port), "socket(%s:%lu) [%s]",
		   prop_get_str(P_CLIENT_HOST), prop_get_ulong(P_CLIENT_PORT),
		   call);
	putil_syserr(2, host_port);
    }

    for (tries = 0;
	    connect(*sockp, (struct sockaddr *)&dest_addr, sizeof(struct sockaddr)) == -1;
	    tries++) {
	char host_port[256];

#if defined(_WIN32)
	if (WSAGetLastError() == WSAETIMEDOUT) {
	    continue;
	}
#else				/*!_WIN32 */
	if (errno == ETIMEDOUT || errno == EINTR) {
	    vb_printf(VB_STD, "RETRY CONNECT");
	    continue;
	} else if (errno == EISCONN) {
	    break;
	}
#endif	/*_WIN32*/

	snprintf(host_port, charlen(host_port), "connect(%s:%lu)",
		   prop_get_str(P_CLIENT_HOST), prop_get_ulong(P_CLIENT_PORT));

	// TODO - this retry business is needed only until the TIME_WAIT
	// flood problem in parallel builds is solved.
	if (tries > 30) {
	    putil_syserr(2, host_port);
	} else {
	    vb_printf(VB_TMP, "RETRY %s in %lu [%dms]",
		host_port, (unsigned long)getpid(), tries * 100);
	    moment_millisleep(tries * 100);
	}
    }
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
5,6
5,7
6,7
8,9
8,10
11,12
11,13
12,13
14,15
16,17
16,18
16,19
16,20
16,21
16,22
16,23
16,24
16,25
16,26
17,18
18,19
18,20
19,20
21,22
23,24
24,25
24,26
26,27
28,29
28,30
29,30
29,31
30,31
31,32
33,34
35,36
37,38
38,39
39,40
41,42
42,43
42,44
42,45
42,46
43,44
45,46
46,47
49,50
50,51
51,52
53,54
54,55
54,56
55,56
55,57
56,57
59,60
61,62
62,63
62,64
63,64
63,65
64,65
64,66
65,66
69,70
69,71
70,71
72,73
72,74
73,74
75,76
77,78
78,79
78,80
79,80
79,81
80,81
83,84
83,85
84,85
86,87
86,88
87,88
87,89
88,89
91,92
91,93
92,93
94,95
96,97
96,98
97,98
98,99
98,100
99,100
100,101
100,102
101,102
102,103
104,105
104,106
104,107
104,108
105,106
107,108
109,110
112,113
114,115
114,116
114,117
115,116
116,117
116,118
118,119
118,120
120,121
122,123
123,124
123,125
123,126
123,127
123,128
123,129
123,130
124,125
126,127
128,129
128,130
129,130
131,132
134,135
134,136
135,136
137,138
139,140
139,141
140,141
142,143
144,145
146,147
147,148
147,149
147,150
148,149
151,152
153,154
153,155
153,156
153,157
154,155
155,156
155,157
156,157
159,160
159,161
160,161
160,162
160,163
160,164
161,162
163,164
164,165
166,167
166,168
167,168
167,169
168,169
170,171
172,173
173,174
175,176
176,177
176,178
177,178
180,181
182,183
183,184
185,186
185,187
185,188
185,189
186,187
187,188
187,189
189,190
189,191
191,192
193,194
193,195
193,196
194,195
194,196
195,196
195,197
196,197
198,199
200,201
200,202
201,202
203,204
205,206
205,207
206,207
207,208
207,209
207,210
208,209
210,211
214,215
214,216
215,216
215,217
216,217
218,219
220,221
222,223
223,224
223,225
223,226
223,227
223,228
223,229
224,225
226,227
228,229
228,230
229,230
231,232
234,235
234,236
235,236
237,238
239,240
239,241
240,241
242,243
244,245
244,246
244,247
245,246
245,247
246,247
249,250
250,251
251,252
251,253
251,254
252,253
255,256
257,258
257,259
258,259
259,260
259,261
259,262
259,263
259,264
259,265
260,261
262,263
265,266
267,268
267,269
268,269
268,270
271,272
272,273
274,275
274,276
275,276
278,279
279,280
279,281
280,281
282,283
282,284
283,284
-----nextToken-----
2,4,7,9,10,13,15,20,22,25,27,32,34,36,40,44,47,48,52,57,58,60,66,67,68,71,74,76,81,82,85,89,90,93,95,103,106,108,110,111,113,117,119,121,125,127,130,132,133,136,138,141,143,145,149,150,152,157,158,162,165,169,171,174,178,179,181,184,188,190,192,197,199,202,204,209,211,212,213,217,219,221,225,227,230,232,233,236,238,241,243,247,248,253,254,256,261,263,264,266,269,270,273,276,277,281,284,285
-----computeFrom-----
29,30
29,31
54,55
54,56
62,63
62,64
78,79
78,80
98,99
98,100
100,101
100,102
155,156
155,157
159,160
159,161
194,195
194,196
195,196
195,197
200,201
200,202
215,216
215,217
245,246
245,247
274,275
274,276
282,283
282,284
-----guardedBy-----
-----guardedByNegation-----
202,217
247,284
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;IfStatement;BinaryExpression;UnaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ReturnStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;UnaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;CastExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;Pointer;UnaryExpression;IdExpression;Name;TypeIdExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;UnaryExpression;LiteralExpression;UnaryExpression;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ContinueStatement;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;BreakStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;FunctionCallExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;
-----ast_node-----
static void_socket_open(SOCKET *sockp, CCS call){    struct sockaddr_in dest_addr;    int tries;    if (*sockp != INVALID_SOCKET) {	return;    }    util_socket_lib_init();    memset(&dest_addr, 0, sizeof(dest_addr));    dest_addr.sin_family = PF_INET;    dest_addr.sin_addr.s_addr = inet_addr(prop_get_str(P_CLIENT_HOST));    dest_addr.sin_port = htons((u_short)prop_get_ulong(P_CLIENT_PORT));    if (((*sockp = socket(PF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)) {	char host_port[256];	snprintf(host_port, charlen(host_port), "socket(%s:%lu) [%s]",		   prop_get_str(P_CLIENT_HOST), prop_get_ulong(P_CLIENT_PORT),		   call);	putil_syserr(2, host_port);    }    for (tries = 0;	    connect(*sockp, (struct sockaddr *)&dest_addr, sizeof(struct sockaddr)) == -1;	    tries++) {	char host_port[256];#if defined(_WIN32)	if (WSAGetLastError() == WSAETIMEDOUT) {	    continue;	}#else				/*!_WIN32 */	if (errno == ETIMEDOUT || errno == EINTR) {	    vb_printf(VB_STD, "RETRY CONNECT");	    continue;	} else if (errno == EISCONN) {	    break;	}#endif	/*_WIN32*/	snprintf(host_port, charlen(host_port), "connect(%s:%lu)",		   prop_get_str(P_CLIENT_HOST), prop_get_ulong(P_CLIENT_PORT));	// TODO - this retry business is needed only until the TIME_WAIT	// flood problem in parallel builds is solved.	if (tries > 30) {	    putil_syserr(2, host_port);	} else {	    vb_printf(VB_TMP, "RETRY %s in %lu [%dms]",		host_port, (unsigned long)getpid(), tries * 100);	    moment_millisleep(tries * 100);	}    }}
static void
_socket_open(SOCKET *sockp, CCS call)
_socket_open
SOCKET *sockp
SOCKET
SOCKET
*sockp
*
sockp
CCS call
CCS
CCS
call
call
{    struct sockaddr_in dest_addr;    int tries;    if (*sockp != INVALID_SOCKET) {	return;    }    util_socket_lib_init();    memset(&dest_addr, 0, sizeof(dest_addr));    dest_addr.sin_family = PF_INET;    dest_addr.sin_addr.s_addr = inet_addr(prop_get_str(P_CLIENT_HOST));    dest_addr.sin_port = htons((u_short)prop_get_ulong(P_CLIENT_PORT));    if (((*sockp = socket(PF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)) {	char host_port[256];	snprintf(host_port, charlen(host_port), "socket(%s:%lu) [%s]",		   prop_get_str(P_CLIENT_HOST), prop_get_ulong(P_CLIENT_PORT),		   call);	putil_syserr(2, host_port);    }    for (tries = 0;	    connect(*sockp, (struct sockaddr *)&dest_addr, sizeof(struct sockaddr)) == -1;	    tries++) {	char host_port[256];#if defined(_WIN32)	if (WSAGetLastError() == WSAETIMEDOUT) {	    continue;	}#else				/*!_WIN32 */	if (errno == ETIMEDOUT || errno == EINTR) {	    vb_printf(VB_STD, "RETRY CONNECT");	    continue;	} else if (errno == EISCONN) {	    break;	}#endif	/*_WIN32*/	snprintf(host_port, charlen(host_port), "connect(%s:%lu)",		   prop_get_str(P_CLIENT_HOST), prop_get_ulong(P_CLIENT_PORT));	// TODO - this retry business is needed only until the TIME_WAIT	// flood problem in parallel builds is solved.	if (tries > 30) {	    putil_syserr(2, host_port);	} else {	    vb_printf(VB_TMP, "RETRY %s in %lu [%dms]",		host_port, (unsigned long)getpid(), tries * 100);	    moment_millisleep(tries * 100);	}    }}
struct sockaddr_in dest_addr;
struct sockaddr_in dest_addr;
struct sockaddr_in
sockaddr_in
dest_addr
dest_addr
int tries;
int tries;
int
tries
tries
if (*sockp != INVALID_SOCKET) {	return;    }
*sockp != INVALID_SOCKET
*sockp
sockp
sockp
INVALID_SOCKET
INVALID_SOCKET
{	return;    }
return;
util_socket_lib_init();
util_socket_lib_init()
util_socket_lib_init
util_socket_lib_init
memset(&dest_addr, 0, sizeof(dest_addr));
memset(&dest_addr, 0, sizeof(dest_addr))
memset
memset
&dest_addr
dest_addr
dest_addr
0
sizeof(dest_addr)
(dest_addr)
dest_addr
dest_addr
dest_addr.sin_family = PF_INET;
dest_addr.sin_family = PF_INET
dest_addr.sin_family
dest_addr
dest_addr
sin_family
PF_INET
PF_INET
dest_addr.sin_addr.s_addr = inet_addr(prop_get_str(P_CLIENT_HOST));
dest_addr.sin_addr.s_addr = inet_addr(prop_get_str(P_CLIENT_HOST))
dest_addr.sin_addr.s_addr
dest_addr.sin_addr
dest_addr
dest_addr
sin_addr
s_addr
inet_addr(prop_get_str(P_CLIENT_HOST))
inet_addr
inet_addr
prop_get_str(P_CLIENT_HOST)
prop_get_str
prop_get_str
P_CLIENT_HOST
P_CLIENT_HOST
dest_addr.sin_port = htons((u_short)prop_get_ulong(P_CLIENT_PORT));
dest_addr.sin_port = htons((u_short)prop_get_ulong(P_CLIENT_PORT))
dest_addr.sin_port
dest_addr
dest_addr
sin_port
htons((u_short)prop_get_ulong(P_CLIENT_PORT))
htons
htons
(u_short)prop_get_ulong(P_CLIENT_PORT)
u_short
u_short
u_short

prop_get_ulong(P_CLIENT_PORT)
prop_get_ulong
prop_get_ulong
P_CLIENT_PORT
P_CLIENT_PORT
if (((*sockp = socket(PF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)) {	char host_port[256];	snprintf(host_port, charlen(host_port), "socket(%s:%lu) [%s]",		   prop_get_str(P_CLIENT_HOST), prop_get_ulong(P_CLIENT_PORT),		   call);	putil_syserr(2, host_port);    }
((*sockp = socket(PF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)
(*sockp = socket(PF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET
(*sockp = socket(PF_INET, SOCK_STREAM, 0))
*sockp = socket(PF_INET, SOCK_STREAM, 0)
*sockp
sockp
sockp
socket(PF_INET, SOCK_STREAM, 0)
socket
socket
PF_INET
PF_INET
SOCK_STREAM
SOCK_STREAM
0
INVALID_SOCKET
INVALID_SOCKET
{	char host_port[256];	snprintf(host_port, charlen(host_port), "socket(%s:%lu) [%s]",		   prop_get_str(P_CLIENT_HOST), prop_get_ulong(P_CLIENT_PORT),		   call);	putil_syserr(2, host_port);    }
char host_port[256];
char host_port[256];
char
host_port[256]
host_port
[256]
256
snprintf(host_port, charlen(host_port), "socket(%s:%lu) [%s]",		   prop_get_str(P_CLIENT_HOST), prop_get_ulong(P_CLIENT_PORT),		   call);
snprintf(host_port, charlen(host_port), "socket(%s:%lu) [%s]",		   prop_get_str(P_CLIENT_HOST), prop_get_ulong(P_CLIENT_PORT),		   call)
snprintf
snprintf
host_port
host_port
charlen(host_port)
charlen
charlen
host_port
host_port
"socket(%s:%lu) [%s]"
prop_get_str(P_CLIENT_HOST)
prop_get_str
prop_get_str
P_CLIENT_HOST
P_CLIENT_HOST
prop_get_ulong(P_CLIENT_PORT)
prop_get_ulong
prop_get_ulong
P_CLIENT_PORT
P_CLIENT_PORT
call
call
putil_syserr(2, host_port);
putil_syserr(2, host_port)
putil_syserr
putil_syserr
2
host_port
host_port
for (tries = 0;	    connect(*sockp, (struct sockaddr *)&dest_addr, sizeof(struct sockaddr)) == -1;	    tries++) {	char host_port[256];#if defined(_WIN32)	if (WSAGetLastError() == WSAETIMEDOUT) {	    continue;	}#else				/*!_WIN32 */	if (errno == ETIMEDOUT || errno == EINTR) {	    vb_printf(VB_STD, "RETRY CONNECT");	    continue;	} else if (errno == EISCONN) {	    break;	}#endif	/*_WIN32*/	snprintf(host_port, charlen(host_port), "connect(%s:%lu)",		   prop_get_str(P_CLIENT_HOST), prop_get_ulong(P_CLIENT_PORT));	// TODO - this retry business is needed only until the TIME_WAIT	// flood problem in parallel builds is solved.	if (tries > 30) {	    putil_syserr(2, host_port);	} else {	    vb_printf(VB_TMP, "RETRY %s in %lu [%dms]",		host_port, (unsigned long)getpid(), tries * 100);	    moment_millisleep(tries * 100);	}    }
tries = 0;
tries = 0
tries
tries
0
connect(*sockp, (struct sockaddr *)&dest_addr, sizeof(struct sockaddr)) == -1
connect(*sockp, (struct sockaddr *)&dest_addr, sizeof(struct sockaddr))
connect
connect
*sockp
sockp
sockp
(struct sockaddr *)&dest_addr
struct sockaddr *
struct sockaddr
sockaddr
*
*
&dest_addr
dest_addr
dest_addr
sizeof(struct sockaddr)
struct sockaddr
struct sockaddr
sockaddr

-1
1
tries++
tries
tries
{	char host_port[256];#if defined(_WIN32)	if (WSAGetLastError() == WSAETIMEDOUT) {	    continue;	}#else				/*!_WIN32 */	if (errno == ETIMEDOUT || errno == EINTR) {	    vb_printf(VB_STD, "RETRY CONNECT");	    continue;	} else if (errno == EISCONN) {	    break;	}#endif	/*_WIN32*/	snprintf(host_port, charlen(host_port), "connect(%s:%lu)",		   prop_get_str(P_CLIENT_HOST), prop_get_ulong(P_CLIENT_PORT));	// TODO - this retry business is needed only until the TIME_WAIT	// flood problem in parallel builds is solved.	if (tries > 30) {	    putil_syserr(2, host_port);	} else {	    vb_printf(VB_TMP, "RETRY %s in %lu [%dms]",		host_port, (unsigned long)getpid(), tries * 100);	    moment_millisleep(tries * 100);	}    }
char host_port[256];
char host_port[256];
char
host_port[256]
host_port
[256]
256
if (errno == ETIMEDOUT || errno == EINTR) {	    vb_printf(VB_STD, "RETRY CONNECT");	    continue;	} else if (errno == EISCONN) {	    break;	}
errno == ETIMEDOUT || errno == EINTR
errno == ETIMEDOUT
errno
errno
ETIMEDOUT
ETIMEDOUT
errno == EINTR
errno
errno
EINTR
EINTR
{	    vb_printf(VB_STD, "RETRY CONNECT");	    continue;	}
vb_printf(VB_STD, "RETRY CONNECT");
vb_printf(VB_STD, "RETRY CONNECT")
vb_printf
vb_printf
VB_STD
VB_STD
"RETRY CONNECT"
continue;
if (errno == EISCONN) {	    break;	}
errno == EISCONN
errno
errno
EISCONN
EISCONN
{	    break;	}
break;
snprintf(host_port, charlen(host_port), "connect(%s:%lu)",		   prop_get_str(P_CLIENT_HOST), prop_get_ulong(P_CLIENT_PORT));
snprintf(host_port, charlen(host_port), "connect(%s:%lu)",		   prop_get_str(P_CLIENT_HOST), prop_get_ulong(P_CLIENT_PORT))
snprintf
snprintf
host_port
host_port
charlen(host_port)
charlen
charlen
host_port
host_port
"connect(%s:%lu)"
prop_get_str(P_CLIENT_HOST)
prop_get_str
prop_get_str
P_CLIENT_HOST
P_CLIENT_HOST
prop_get_ulong(P_CLIENT_PORT)
prop_get_ulong
prop_get_ulong
P_CLIENT_PORT
P_CLIENT_PORT
if (tries > 30) {	    putil_syserr(2, host_port);	} else {	    vb_printf(VB_TMP, "RETRY %s in %lu [%dms]",		host_port, (unsigned long)getpid(), tries * 100);	    moment_millisleep(tries * 100);	}
tries > 30
tries
tries
30
{	    putil_syserr(2, host_port);	}
putil_syserr(2, host_port);
putil_syserr(2, host_port)
putil_syserr
putil_syserr
2
host_port
host_port
{	    vb_printf(VB_TMP, "RETRY %s in %lu [%dms]",		host_port, (unsigned long)getpid(), tries * 100);	    moment_millisleep(tries * 100);	}
vb_printf(VB_TMP, "RETRY %s in %lu [%dms]",		host_port, (unsigned long)getpid(), tries * 100);
vb_printf(VB_TMP, "RETRY %s in %lu [%dms]",		host_port, (unsigned long)getpid(), tries * 100)
vb_printf
vb_printf
VB_TMP
VB_TMP
"RETRY %s in %lu [%dms]"
host_port
host_port
(unsigned long)getpid()
unsigned long
unsigned long

getpid()
getpid
getpid
tries * 100
tries
tries
100
moment_millisleep(tries * 100);
moment_millisleep(tries * 100)
moment_millisleep
moment_millisleep
tries * 100
tries
tries
100
-----joern-----
(74,1,0)
(17,3,0)
(91,81,0)
(123,120,0)
(34,122,0)
(97,72,0)
(113,59,0)
(57,125,0)
(19,59,0)
(56,21,0)
(121,0,0)
(68,120,0)
(80,36,0)
(67,4,0)
(11,90,0)
(116,14,0)
(4,95,0)
(10,30,0)
(14,116,0)
(98,37,0)
(60,120,0)
(18,46,0)
(117,94,0)
(9,46,0)
(26,123,0)
(15,28,0)
(30,125,0)
(88,16,0)
(69,59,0)
(100,58,0)
(24,37,0)
(66,31,0)
(84,77,0)
(42,109,0)
(109,110,0)
(53,123,0)
(29,107,0)
(43,115,0)
(124,76,0)
(94,117,0)
(82,37,0)
(59,81,0)
(105,35,0)
(77,18,0)
(76,31,0)
(64,11,0)
(97,102,0)
(123,37,0)
(63,17,0)
(125,57,0)
(28,120,0)
(23,90,0)
(41,16,0)
(56,35,0)
(109,58,0)
(30,97,0)
(115,43,0)
(22,49,0)
(20,14,0)
(101,57,0)
(6,82,0)
(0,36,0)
(49,22,0)
(35,120,0)
(86,31,0)
(46,18,0)
(59,69,0)
(12,72,0)
(38,110,0)
(25,8,0)
(104,93,0)
(71,109,0)
(49,125,0)
(7,71,0)
(70,109,0)
(78,11,0)
(116,55,0)
(85,16,0)
(14,20,0)
(1,110,0)
(82,6,0)
(52,59,0)
(18,31,0)
(76,124,0)
(62,37,0)
(44,102,0)
(109,119,0)
(72,97,0)
(109,71,0)
(51,120,0)
(50,118,0)
(107,55,0)
(124,122,0)
(48,14,0)
(55,31,0)
(45,31,0)
(59,19,0)
(2,25,0)
(13,109,0)
(59,16,0)
(81,59,0)
(125,94,0)
(5,4,0)
(65,94,0)
(111,31,0)
(37,82,0)
(96,65,0)
(93,3,0)
(30,3,0)
(75,31,0)
(89,82,0)
(39,102,0)
(33,31,0)
(103,22,0)
(109,42,0)
(94,125,0)
(93,104,0)
(125,30,0)
(18,77,0)
(94,65,0)
(61,102,0)
(79,109,0)
(83,115,0)
(37,21,0)
(55,116,0)
(58,109,0)
(112,18,0)
(54,0,0)
(47,42,0)
(82,89,0)
(40,35,0)
(14,48,0)
(35,56,0)
(32,19,0)
(125,49,0)
(90,31,0)
(122,124,0)
(87,104,0)
(108,107,0)
(36,0,0)
(27,1,0)
(102,97,0)
(17,97,0)
(99,20,0)
(106,51,0)
(36,76,0)
(92,93,0)
(57,101,0)
(114,51,0)
(37,123,0)
(73,69,0)
(11,64,1)
(35,105,1)
(106,59,1)
(59,69,1)
(72,12,1)
(26,82,1)
(125,94,1)
(97,102,1)
(124,122,1)
(25,104,1)
(108,76,1)
(50,115,1)
(4,67,1)
(63,55,1)
(29,108,1)
(71,7,1)
(15,50,1)
(30,10,1)
(76,124,1)
(65,96,1)
(60,68,1)
(109,58,1)
(62,51,1)
(109,79,1)
(47,71,1)
(13,72,1)
(102,44,1)
(91,113,1)
(114,106,1)
(74,27,1)
(59,19,1)
(10,28,1)
(96,30,1)
(121,54,1)
(105,40,1)
(123,53,1)
(113,69,1)
(12,97,1)
(120,60,1)
(52,115,1)
(109,42,1)
(78,18,1)
(42,47,1)
(2,25,1)
(15,56,1)
(27,109,1)
(37,82,1)
(17,3,1)
(77,84,1)
(64,78,1)
(18,77,1)
(100,13,1)
(80,0,1)
(58,100,1)
(6,24,1)
(57,101,1)
(30,97,1)
(35,120,1)
(53,26,1)
(122,34,1)
(116,14,1)
(55,116,1)
(84,45,1)
(2,49,1)
(14,48,1)
(51,120,1)
(39,61,1)
(19,32,1)
(22,103,1)
(94,65,1)
(54,90,1)
(34,36,1)
(32,81,1)
(15,4,1)
(28,120,1)
(104,93,1)
(82,6,1)
(99,107,1)
(83,43,1)
(56,35,1)
(94,117,1)
(9,112,1)
(46,9,1)
(44,39,1)
(104,87,1)
(24,98,1)
(68,1,1)
(5,51,1)
(28,15,1)
(109,119,1)
(23,11,1)
(61,17,1)
(112,77,1)
(10,120,1)
(17,63,1)
(93,92,1)
(45,104,1)
(81,91,1)
(115,83,1)
(87,93,1)
(125,30,1)
(20,99,1)
(73,52,1)
(67,5,1)
(36,0,1)
(49,125,1)
(90,23,1)
(82,89,1)
(115,43,1)
(123,120,1)
(59,81,1)
(40,37,1)
(109,71,1)
(107,29,1)
(103,125,1)
(57,94,1)
(43,49,1)
(79,42,1)
(51,114,1)
(18,46,1)
(30,3,1)
(14,20,1)
(0,121,1)
(68,72,1)
(70,58,1)
(98,62,1)
(125,57,1)
(69,73,1)
(72,97,1)
(36,80,1)
(37,123,1)
(49,22,1)
(1,74,1)
(7,70,1)
(93,3,1)
(104,93,2)
(9,104,2)
(49,49,2)
(61,104,2)
(125,57,2)
(44,104,2)
(32,115,2)
(35,120,2)
(123,120,2)
(125,30,2)
(122,104,2)
(68,104,2)
(72,104,2)
(71,72,2)
(96,49,2)
(115,43,2)
(124,104,2)
(93,3,2)
(7,72,2)
(40,51,2)
(125,104,2)
(113,115,2)
(76,124,2)
(65,104,2)
(43,49,2)
(13,72,2)
(62,51,2)
(4,51,2)
(94,49,2)
(30,49,2)
(36,104,2)
(57,101,2)
(37,82,2)
(18,46,2)
(97,104,2)
(49,22,2)
(96,104,2)
(100,72,2)
(39,104,2)
(58,72,2)
(106,115,2)
(103,49,2)
(109,72,2)
(94,65,2)
(60,104,2)
(49,125,2)
(55,104,2)
(82,6,2)
(90,104,2)
(5,51,2)
(30,3,2)
(59,69,2)
(25,104,2)
(124,122,2)
(77,104,2)
(57,104,2)
(115,49,2)
(59,115,2)
(65,49,2)
(46,104,2)
(107,104,2)
(14,48,2)
(102,104,2)
(59,19,2)
(70,72,2)
(24,51,2)
(2,25,2)
(94,117,2)
(1,72,2)
(10,104,2)
(26,51,2)
(19,115,2)
(45,104,2)
(30,97,2)
(64,104,2)
(103,104,2)
(80,104,2)
(125,49,2)
(14,20,2)
(50,115,2)
(34,104,2)
(97,102,2)
(78,104,2)
(112,104,2)
(123,51,2)
(121,104,2)
(22,49,2)
(14,104,2)
(12,104,2)
(23,104,2)
(114,115,2)
(73,115,2)
(99,104,2)
(54,104,2)
(17,3,2)
(94,104,2)
(91,115,2)
(51,115,2)
(84,104,2)
(28,120,2)
(57,49,2)
(116,104,2)
(18,104,2)
(37,51,2)
(56,35,2)
(22,104,2)
(18,77,2)
(105,51,2)
(0,104,2)
(11,104,2)
(82,89,2)
(47,72,2)
(108,104,2)
(74,72,2)
(69,115,2)
(125,94,2)
(36,0,2)
(67,51,2)
(109,58,2)
(76,104,2)
(116,14,2)
(98,51,2)
(10,49,2)
(109,71,2)
(55,116,2)
(51,120,2)
(37,123,2)
(56,51,2)
(52,115,2)
(30,104,2)
(17,104,2)
(6,51,2)
(59,81,2)
(63,104,2)
(28,49,2)
(83,49,2)
(35,51,2)
(15,49,2)
(27,72,2)
(120,104,2)
(42,72,2)
(72,97,2)
(109,42,2)
(20,104,2)
(29,104,2)
(79,72,2)
(49,104,2)
(81,115,2)
(109,119,2)
(53,51,2)
(82,51,2)
-----------------------------------
(0,dest_addr.sin_addr)
(1,putil_syserr(2, host_port)
(2,RET)
(3,SOCKET *sockp)
(4,putil_syserr(2, host_port)
(5,2)
(6,getpid()
(7,P_CLIENT_HOST)
(8,)
(9,dest_addr)
(10,sockp)
(11,dest_addr.sin_family)
(12,INVALID_SOCKET)
(13,host_port)
(14,(u_short)
(15,tries)
(16,)
(17,*sockp)
(18,memset(&dest_addr, 0, sizeof(dest_addr)
(19,prop_get_ulong(P_CLIENT_PORT)
(20,prop_get_ulong(P_CLIENT_PORT)
(21,)
(22,-1)
(23,PF_INET)
(24,host_port)
(25,return;)
(26,tries)
(27,2)
(28,tries++)
(29,sin_port)
(30,*sockp)
(31,)
(32,P_CLIENT_PORT)
(33,if (*sockp != INVALID_SOCKET)
(34,P_CLIENT_HOST)
(35,tries * 100)
(36,dest_addr.sin_addr.s_addr)
(37,vb_printf(VB_TMP, "RETRY %s in %lu [%dms]",\n\\n\\t\\thost_port, (unsigned long)
(38,host_port)
(39,SOCK_STREAM)
(40,tries)
(41,if (WSAGetLastError()
(42,prop_get_ulong(P_CLIENT_PORT)
(43,WSAGetLastError()
(44,0)
(45,util_socket_lib_init()
(46,sizeof(dest_addr)
(47,P_CLIENT_PORT)
(48,u_short)
(49,connect(*sockp, (struct sockaddr *)
(50,continue;)
(51,tries > 30)
(52,host_port)
(53,100)
(54,dest_addr)
(55,dest_addr.sin_port = htons((u_short)
(56,moment_millisleep(tries * 100)
(57,sizeof(struct sockaddr)
(58,charlen(host_port)
(59,snprintf(host_port, charlen(host_port)
(60,0)
(61,PF_INET)
(62,VB_TMP)
(63,sockp)
(64,sin_family)
(65,&dest_addr)
(66,dest_addr)
(67,host_port)
(68,tries)
(69,charlen(host_port)
(70,"socket(%s:%lu)
(71,prop_get_str(P_CLIENT_HOST)
(72,(*sockp = socket(PF_INET, SOCK_STREAM, 0)
(73,host_port)
(74,host_port)
(75,if (((*sockp = socket(PF_INET, SOCK_STREAM, 0)
(76,dest_addr.sin_addr.s_addr = inet_addr(prop_get_str(P_CLIENT_HOST)
(77,&dest_addr)
(78,dest_addr)
(79,call)
(80,s_addr)
(81,prop_get_str(P_CLIENT_HOST)
(82,(unsigned long)
(83,WSAETIMEDOUT)
(84,dest_addr)
(85,if (tries > 30)
(86,for (tries = 0;\n\\n\\t    connect(*sockp, (struct sockaddr *)
(87,INVALID_SOCKET)
(88,host_port)
(89,unsigned long)
(90,dest_addr.sin_family = PF_INET)
(91,P_CLIENT_HOST)
(92,sockp)
(93,*sockp)
(94,(struct sockaddr *)
(95,)
(96,dest_addr)
(97,*sockp = socket(PF_INET, SOCK_STREAM, 0)
(98,"RETRY %s in %lu [%dms]")
(99,P_CLIENT_PORT)
(100,host_port)
(101,struct sockaddr)
(102,socket(PF_INET, SOCK_STREAM, 0)
(103,1)
(104,*sockp != INVALID_SOCKET)
(105,100)
(106,tries)
(107,dest_addr.sin_port)
(108,dest_addr)
(109,snprintf(host_port, charlen(host_port)
(110,)
(111,tries)
(112,0)
(113,"connect(%s:%lu)
(114,30)
(115,WSAGetLastError()
(116,htons((u_short)
(117,struct sockaddr *)
(118,)
(119,CCS call)
(120,tries = 0)
(121,sin_addr)
(122,prop_get_str(P_CLIENT_HOST)
(123,tries * 100)
(124,inet_addr(prop_get_str(P_CLIENT_HOST)
(125,connect(*sockp, (struct sockaddr *)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^