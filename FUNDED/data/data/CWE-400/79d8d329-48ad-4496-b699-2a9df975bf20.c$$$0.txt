-----label-----
1
-----code-----
const char* process_line(struct client_data* cli_data, char* line, int line_len) {
	if (line_len > 0 && line[line_len-1] == '\r') {
		line_len--;
		line[line_len] = '\0';
	}

	if ( !strncmp( line, "ACQ4ME ", 7 ) || !strncmp( line, "ACQ4ANY ", 8 ) ) {
		if ( cli_data->next_lock >= MAX_LOCKS_PER_CLIENT ) {
			incr_stats( lock_mismatch );
			return "LOCK_HELD\n";
		}
		if ( cli_data->next_lock > 0 ) {
			struct locks* last_lock = cli_data->client_locks + cli_data->next_lock - 1;
			if ( last_lock->state != PROCESSING ) {
				/*
				 * Handling multiple timeouts would require some extensive
				 * rejiggering and we don't expect users to try anyway.  So we
				 * don't let them.  Also, it'd be a bit crazy to actually get
				 * a lock while waiting on another - it'd lead to unpredictable
				 * locking order which is the first step in deadlocking.
				 */
				incr_stats( lock_while_waiting );
				return "ERROR WAIT_FOR_RESPONSE\n";
			}
		}

		int for_anyone = line[6] != ' ';

		char* key = strtok( line + 7 + for_anyone, " " );
		unsigned workers = atou( strtok(NULL, " ") );
		unsigned maxqueue = atou( strtok(NULL, " ") );
		unsigned timeout = atou( strtok(NULL, " ") );

		if ( !key || !workers || !maxqueue ) {
			return "ERROR BAD_SYNTAX\n";
		}

		uint32_t hash_value = hash( key, strlen( key ), 0 );
		struct PoolCounter* pCounter;
		pCounter = hashtable_find( primary_hashtable, hash_value, key );
		if ( !pCounter ) {
			pCounter = malloc( sizeof( *pCounter ) );
			if ( !pCounter ) {
				fprintf( stderr, "Out of memory\n" );
				return "ERROR OUT_OF_MEMORY\n";
			}
			pCounter->htentry.key = strdup( key );
			pCounter->htentry.key_hash = hash_value;
			pCounter->count = 0;
			pCounter->processing = 0;

			DOUBLE_LLIST_INIT( pCounter->working );
			DOUBLE_LLIST_INIT( pCounter->for_them );
			DOUBLE_LLIST_INIT( pCounter->for_anyone );

			hashtable_insert( primary_hashtable, (struct hashtable_entry *) pCounter );
			incr_stats( hashtable_entries );
		}

		if ( pCounter->count >= maxqueue ) {
			incr_stats( full_queues );
			return "QUEUE_FULL\n";
		}

		if ( pCounter->processing < workers ) {
			struct locks* l = init_next_lock( cli_data, pCounter, PROCESSING );
			if ( !l ) {
				/*
				 * We check for this condition way way up above so we should
				 * never see this.
				 */
				fprintf( stderr, "Out of locks\n" );
				exit( EXIT_FAILURE );
			}
			gettimeofday( &l->timeval, NULL );
			pCounter->count++;
			pCounter->processing++;
			incr_stats( processing_workers );
			DOUBLE_LLIST_ADD( &pCounter->working, &l->siblings );
			incr_stats( total_acquired );
			return "LOCKED\n";
		}
		if ( !timeout ) {
			return "TIMEOUT\n";
		}
		struct locks* l = init_next_lock( cli_data, pCounter, for_anyone ? WAIT_ANY : WAITING );
		pCounter->count++;
		struct timeval wait_time;
		if ( for_anyone ) {
			DOUBLE_LLIST_ADD( &pCounter->for_anyone, &l->siblings );
		} else {
			DOUBLE_LLIST_ADD( &pCounter->for_them, &l->siblings );
		}
		incr_stats( waiting_workers );
		gettimeofday( &l->timeval, NULL );

		wait_time.tv_sec = timeout;
		wait_time.tv_usec = 0;

		/*
		 * Note that this timeout will override any previously set timeouts.
		 * You _can't_ clear the a timeout so we have to handle that too but
		 * at least we don't have to handle timeouts too early.
		 */
		event_add( &cli_data->ev, &wait_time );
		return NULL;
	} else if ( !strncmp(line, "RELEASE", 7) ) {
		if ( cli_data->next_lock <= 0 ) {
			incr_stats( release_mismatch );
			return "NOT_LOCKED\n";
		}
		cli_data->next_lock--;
		struct locks* l = cli_data->client_locks + cli_data->next_lock;
		if ( l->state == UNLOCKED ) {
			incr_stats( release_mismatch );
			return "NOT_LOCKED\n";
		}
		remove_client_lock( l, 1 );
		incr_stats( total_releases );
		return "RELEASED\n";
	} else if ( !strncmp( line, "STATS ", 6 ) ) {
		return provide_stats( line + 6 );
	} else {
		return "ERROR BAD_COMMAND\n";
	}
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
3,7
3,8
6,7
6,8
7,8
9,10
9,11
12,13
12,14
14,15
14,16
17,18
17,19
19,20
21,22
21,23
22,23
22,24
23,24
23,25
24,25
24,26
25,26
28,29
28,30
29,30
29,31
30,31
32,33
32,34
33,34
37,38
37,39
38,39
39,40
40,41
42,43
43,44
43,45
44,45
44,46
45,46
47,48
50,51
50,52
50,53
51,52
51,53
52,53
53,54
53,55
53,56
53,57
54,55
56,57
60,61
61,62
61,63
61,64
61,65
62,63
64,65
68,69
68,70
68,71
68,72
68,73
68,74
68,75
68,76
68,77
68,78
68,79
68,80
68,81
68,82
68,83
68,84
68,85
68,86
68,87
68,88
68,89
68,90
68,91
68,92
68,93
69,70
69,71
70,71
70,72
71,72
71,73
72,73
75,76
77,78
77,79
78,79
79,80
79,81
80,81
82,83
83,84
85,86
87,88
87,89
88,89
88,90
89,90
89,91
90,91
94,95
94,96
95,96
96,97
96,98
97,98
99,100
99,101
99,102
102,103
103,104
103,105
104,105
104,106
105,106
105,107
106,107
109,110
109,111
110,111
114,115
114,116
115,116
115,117
116,117
116,118
117,118
120,121
122,123
122,124
123,124
124,125
124,126
125,126
127,128
128,129
130,131
132,133
133,134
133,135
135,136
135,137
137,138
138,139
138,140
139,140
139,141
140,141
144,145
145,146
145,147
147,148
147,149
147,150
150,151
151,152
151,153
151,154
152,153
154,155
154,156
155,156
155,157
156,157
159,160
162,163
163,164
163,165
165,166
165,167
167,168
168,169
168,170
169,170
171,172
171,173
171,174
172,173
174,175
177,178
178,179
178,180
180,181
180,182
182,183
183,184
183,185
184,185
186,187
186,188
186,189
187,188
189,190
192,193
193,194
193,195
195,196
195,197
197,198
198,199
198,200
199,200
201,202
201,203
201,204
202,203
204,205
207,208
207,209
208,209
208,210
209,210
209,211
210,211
211,212
213,214
214,215
216,217
217,218
219,220
220,221
222,223
223,224
223,225
224,225
226,227
226,228
228,229
229,230
229,231
229,232
229,233
230,231
232,233
234,235
234,236
235,236
237,238
240,241
241,242
241,243
242,243
244,245
244,246
247,248
248,249
248,250
249,250
251,252
251,253
251,254
251,255
252,253
254,255
256,257
258,259
260,261
260,262
261,262
262,263
264,265
264,266
264,267
264,268
264,269
264,270
264,271
264,272
264,273
264,274
264,275
265,266
266,267
266,268
267,268
269,270
269,271
270,271
272,273
273,274
274,275
275,276
277,278
277,279
278,279
279,280
281,282
281,283
282,283
283,284
283,285
283,286
284,285
286,287
289,290
291,292
292,293
292,294
293,294
293,295
294,295
294,296
295,296
299,300
299,301
300,301
302,303
304,305
305,306
305,307
306,307
306,308
307,308
307,309
308,309
312,313
314,315
315,316
315,317
316,317
316,318
317,318
321,322
322,323
322,324
323,324
323,325
324,325
328,329
329,330
329,331
330,331
332,333
332,334
333,334
336,337
337,338
337,339
338,339
340,341
340,342
341,342
344,345
345,346
345,347
346,347
348,349
348,350
349,350
352,353
353,354
353,355
353,356
354,355
356,357
358,359
358,360
359,360
359,361
360,361
362,363
364,365
366,367
367,368
367,369
368,369
370,371
371,372
373,374
373,375
374,375
374,376
375,376
375,377
376,377
379,380
381,382
381,383
382,383
383,384
383,385
384,385
386,387
387,388
389,390
391,392
391,393
392,393
392,394
393,394
393,395
394,395
397,398
399,400
399,401
399,402
399,403
399,404
399,405
399,406
399,407
399,408
400,401
401,402
401,403
402,403
404,405
404,406
404,407
407,408
408,409
408,410
408,411
408,412
409,410
411,412
413,414
415,416
417,418
417,419
418,419
419,420
421,422
421,423
422,423
423,424
423,425
423,426
424,425
426,427
429,430
430,431
430,432
431,432
433,434
434,435
436,437
437,438
437,439
437,440
438,439
440,441
441,442
441,443
442,443
445,446
447,448
448,449
449,450
449,451
450,451
453,454
454,455
455,456
455,457
456,457
459,460
460,461
460,462
461,462
463,464
464,465
466,467
467,468
467,469
467,470
468,469
470,471
471,472
471,473
472,473
475,476
476,477
476,478
477,478
480,481
481,482
481,483
482,483
484,485
485,486
487,488
489,490
489,491
490,491
491,492
493,494
494,495
496,497
497,498
497,499
498,499
500,501
500,502
500,503
503,504
504,505
504,506
504,507
504,508
505,506
507,508
509,510
511,512
511,513
511,514
512,513
514,515
516,517
518,519
519,520
520,521
520,522
521,522
524,525
525,526
525,527
526,527
528,529
530,531
530,532
530,533
531,532
533,534
534,535
535,536
535,537
535,538
536,537
538,539
539,540
539,541
540,541
543,544
544,545
544,546
545,546
548,549
549,550
550,551
550,552
550,553
551,552
553,554
554,555
554,556
555,556
558,559
559,560
559,561
560,561
563,564
564,565
564,566
565,566
567,568
568,569
570,571
571,572
571,573
571,574
572,573
574,575
575,576
575,577
576,577
579,580
581,582
582,583
582,584
583,584
583,585
584,585
587,588
589,590
590,591
590,592
591,592
591,593
592,593
596,597
597,598
597,599
597,600
598,599
600,601
601,602
601,603
602,603
605,606
606,607
608,609
609,610
611,612
611,613
611,614
612,613
613,614
613,615
613,616
613,617
614,615
616,617
620,621
620,622
620,623
620,624
620,625
620,626
620,627
621,622
621,623
622,623
622,624
623,624
623,625
624,625
628,629
628,630
629,630
630,631
630,632
631,632
633,634
634,635
636,637
638,639
639,640
640,641
640,642
641,642
644,645
645,646
645,647
646,647
648,649
648,650
648,651
651,652
652,653
652,654
653,654
653,655
654,655
657,658
657,659
658,659
661,662
661,663
662,663
662,664
663,664
663,665
664,665
667,668
669,670
669,671
670,671
671,672
671,673
672,673
674,675
675,676
677,678
679,680
680,681
680,682
680,683
681,682
683,684
686,687
687,688
687,689
688,689
690,691
691,692
693,694
695,696
695,697
695,698
696,697
697,698
697,699
697,700
697,701
698,699
700,701
704,705
705,706
706,707
706,708
707,708
709,710
709,711
710,711
713,714
714,715
-----nextToken-----
2,4,5,8,10,11,13,15,16,18,20,26,27,31,34,35,36,41,46,48,49,55,57,58,59,63,65,66,67,73,74,76,81,84,86,91,92,93,98,100,101,107,108,111,112,113,118,119,121,126,129,131,134,136,141,142,143,146,148,149,153,157,158,160,161,164,166,170,173,175,176,179,181,185,188,190,191,194,196,200,203,205,206,212,215,218,221,225,227,231,233,236,238,239,243,245,246,250,253,255,257,259,263,268,271,276,280,285,287,288,290,296,297,298,301,303,309,310,311,313,318,319,320,325,326,327,331,334,335,339,342,343,347,350,351,355,357,361,363,365,369,372,377,378,380,385,388,390,395,396,398,403,405,406,410,412,414,416,420,425,427,428,432,435,439,443,444,446,451,452,457,458,462,465,469,473,474,478,479,483,486,488,492,495,499,501,502,506,508,510,513,515,517,522,523,527,529,532,537,541,542,546,547,552,556,557,561,562,566,569,573,577,578,580,585,586,588,593,594,595,599,603,604,607,610,615,617,618,619,625,626,627,632,635,637,642,643,647,649,650,655,656,659,660,665,666,668,673,676,678,682,684,685,689,692,694,699,701,702,703,708,711,712,715
-----computeFrom-----
23,24
23,25
24,25
24,26
28,29
28,30
32,33
32,34
43,44
43,45
51,52
51,53
70,71
70,72
88,89
88,90
103,104
103,105
104,105
104,106
115,116
115,117
138,139
138,140
154,155
154,156
155,156
155,157
208,209
208,210
209,210
209,211
248,249
248,250
266,267
266,268
292,293
292,294
305,306
305,307
315,316
315,317
322,323
322,324
374,375
374,376
392,393
392,394
582,583
582,584
590,591
590,592
622,623
622,624
652,653
652,654
662,663
662,664
709,710
709,711
-----guardedBy-----
34,48
31,46
65,157
91,111
92,112
396,458
395,473
-----guardedByNegation-----
63,699
65,711
-----lastLexicalUse-----
65,711
-----jump-----
65,711
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Pointer;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;CompoundStatement;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;CompoundStatement;ExpressionStatement;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;CompoundStatement;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ReturnStatement;LiteralExpression;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ReturnStatement;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ReturnStatement;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ReturnStatement;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CastExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;Pointer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ReturnStatement;LiteralExpression;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ReturnStatement;LiteralExpression;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;ReturnStatement;LiteralExpression;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ConditionalExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;ReturnStatement;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;CompoundStatement;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ReturnStatement;LiteralExpression;ExpressionStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ReturnStatement;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ReturnStatement;LiteralExpression;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;CompoundStatement;ReturnStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ReturnStatement;LiteralExpression;
-----ast_node-----
const char* process_line(struct client_data* cli_data, char* line, int line_len) {	if (line_len > 0 && line[line_len-1] == '\r') {		line_len--;		line[line_len] = '\0';	}	if ( !strncmp( line, "ACQ4ME ", 7 ) || !strncmp( line, "ACQ4ANY ", 8 ) ) {		if ( cli_data->next_lock >= MAX_LOCKS_PER_CLIENT ) {			incr_stats( lock_mismatch );			return "LOCK_HELD\n";		}		if ( cli_data->next_lock > 0 ) {			struct locks* last_lock = cli_data->client_locks + cli_data->next_lock - 1;			if ( last_lock->state != PROCESSING ) {				/*				 * Handling multiple timeouts would require some extensive				 * rejiggering and we don't expect users to try anyway.  So we				 * don't let them.  Also, it'd be a bit crazy to actually get				 * a lock while waiting on another - it'd lead to unpredictable				 * locking order which is the first step in deadlocking.				 */				incr_stats( lock_while_waiting );				return "ERROR WAIT_FOR_RESPONSE\n";			}		}		int for_anyone = line[6] != ' ';		char* key = strtok( line + 7 + for_anyone, " " );		unsigned workers = atou( strtok(NULL, " ") );		unsigned maxqueue = atou( strtok(NULL, " ") );		unsigned timeout = atou( strtok(NULL, " ") );		if ( !key || !workers || !maxqueue ) {			return "ERROR BAD_SYNTAX\n";		}		uint32_t hash_value = hash( key, strlen( key ), 0 );		struct PoolCounter* pCounter;		pCounter = hashtable_find( primary_hashtable, hash_value, key );		if ( !pCounter ) {			pCounter = malloc( sizeof( *pCounter ) );			if ( !pCounter ) {				fprintf( stderr, "Out of memory\n" );				return "ERROR OUT_OF_MEMORY\n";			}			pCounter->htentry.key = strdup( key );			pCounter->htentry.key_hash = hash_value;			pCounter->count = 0;			pCounter->processing = 0;			DOUBLE_LLIST_INIT( pCounter->working );			DOUBLE_LLIST_INIT( pCounter->for_them );			DOUBLE_LLIST_INIT( pCounter->for_anyone );			hashtable_insert( primary_hashtable, (struct hashtable_entry *) pCounter );			incr_stats( hashtable_entries );		}		if ( pCounter->count >= maxqueue ) {			incr_stats( full_queues );			return "QUEUE_FULL\n";		}		if ( pCounter->processing < workers ) {			struct locks* l = init_next_lock( cli_data, pCounter, PROCESSING );			if ( !l ) {				/*				 * We check for this condition way way up above so we should				 * never see this.				 */				fprintf( stderr, "Out of locks\n" );				exit( EXIT_FAILURE );			}			gettimeofday( &l->timeval, NULL );			pCounter->count++;			pCounter->processing++;			incr_stats( processing_workers );			DOUBLE_LLIST_ADD( &pCounter->working, &l->siblings );			incr_stats( total_acquired );			return "LOCKED\n";		}		if ( !timeout ) {			return "TIMEOUT\n";		}		struct locks* l = init_next_lock( cli_data, pCounter, for_anyone ? WAIT_ANY : WAITING );		pCounter->count++;		struct timeval wait_time;		if ( for_anyone ) {			DOUBLE_LLIST_ADD( &pCounter->for_anyone, &l->siblings );		} else {			DOUBLE_LLIST_ADD( &pCounter->for_them, &l->siblings );		}		incr_stats( waiting_workers );		gettimeofday( &l->timeval, NULL );		wait_time.tv_sec = timeout;		wait_time.tv_usec = 0;		/*		 * Note that this timeout will override any previously set timeouts.		 * You _can't_ clear the a timeout so we have to handle that too but		 * at least we don't have to handle timeouts too early.		 */		event_add( &cli_data->ev, &wait_time );		return NULL;	} else if ( !strncmp(line, "RELEASE", 7) ) {		if ( cli_data->next_lock <= 0 ) {			incr_stats( release_mismatch );			return "NOT_LOCKED\n";		}		cli_data->next_lock--;		struct locks* l = cli_data->client_locks + cli_data->next_lock;		if ( l->state == UNLOCKED ) {			incr_stats( release_mismatch );			return "NOT_LOCKED\n";		}		remove_client_lock( l, 1 );		incr_stats( total_releases );		return "RELEASED\n";	} else if ( !strncmp( line, "STATS ", 6 ) ) {		return provide_stats( line + 6 );	} else {		return "ERROR BAD_COMMAND\n";	}}
const char
* process_line(struct client_data* cli_data, char* line, int line_len)
*
process_line
struct client_data* cli_data
struct client_data
client_data
* cli_data
*
cli_data
char* line
char
* line
*
line
int line_len
int
line_len
line_len
{	if (line_len > 0 && line[line_len-1] == '\r') {		line_len--;		line[line_len] = '\0';	}	if ( !strncmp( line, "ACQ4ME ", 7 ) || !strncmp( line, "ACQ4ANY ", 8 ) ) {		if ( cli_data->next_lock >= MAX_LOCKS_PER_CLIENT ) {			incr_stats( lock_mismatch );			return "LOCK_HELD\n";		}		if ( cli_data->next_lock > 0 ) {			struct locks* last_lock = cli_data->client_locks + cli_data->next_lock - 1;			if ( last_lock->state != PROCESSING ) {				/*				 * Handling multiple timeouts would require some extensive				 * rejiggering and we don't expect users to try anyway.  So we				 * don't let them.  Also, it'd be a bit crazy to actually get				 * a lock while waiting on another - it'd lead to unpredictable				 * locking order which is the first step in deadlocking.				 */				incr_stats( lock_while_waiting );				return "ERROR WAIT_FOR_RESPONSE\n";			}		}		int for_anyone = line[6] != ' ';		char* key = strtok( line + 7 + for_anyone, " " );		unsigned workers = atou( strtok(NULL, " ") );		unsigned maxqueue = atou( strtok(NULL, " ") );		unsigned timeout = atou( strtok(NULL, " ") );		if ( !key || !workers || !maxqueue ) {			return "ERROR BAD_SYNTAX\n";		}		uint32_t hash_value = hash( key, strlen( key ), 0 );		struct PoolCounter* pCounter;		pCounter = hashtable_find( primary_hashtable, hash_value, key );		if ( !pCounter ) {			pCounter = malloc( sizeof( *pCounter ) );			if ( !pCounter ) {				fprintf( stderr, "Out of memory\n" );				return "ERROR OUT_OF_MEMORY\n";			}			pCounter->htentry.key = strdup( key );			pCounter->htentry.key_hash = hash_value;			pCounter->count = 0;			pCounter->processing = 0;			DOUBLE_LLIST_INIT( pCounter->working );			DOUBLE_LLIST_INIT( pCounter->for_them );			DOUBLE_LLIST_INIT( pCounter->for_anyone );			hashtable_insert( primary_hashtable, (struct hashtable_entry *) pCounter );			incr_stats( hashtable_entries );		}		if ( pCounter->count >= maxqueue ) {			incr_stats( full_queues );			return "QUEUE_FULL\n";		}		if ( pCounter->processing < workers ) {			struct locks* l = init_next_lock( cli_data, pCounter, PROCESSING );			if ( !l ) {				/*				 * We check for this condition way way up above so we should				 * never see this.				 */				fprintf( stderr, "Out of locks\n" );				exit( EXIT_FAILURE );			}			gettimeofday( &l->timeval, NULL );			pCounter->count++;			pCounter->processing++;			incr_stats( processing_workers );			DOUBLE_LLIST_ADD( &pCounter->working, &l->siblings );			incr_stats( total_acquired );			return "LOCKED\n";		}		if ( !timeout ) {			return "TIMEOUT\n";		}		struct locks* l = init_next_lock( cli_data, pCounter, for_anyone ? WAIT_ANY : WAITING );		pCounter->count++;		struct timeval wait_time;		if ( for_anyone ) {			DOUBLE_LLIST_ADD( &pCounter->for_anyone, &l->siblings );		} else {			DOUBLE_LLIST_ADD( &pCounter->for_them, &l->siblings );		}		incr_stats( waiting_workers );		gettimeofday( &l->timeval, NULL );		wait_time.tv_sec = timeout;		wait_time.tv_usec = 0;		/*		 * Note that this timeout will override any previously set timeouts.		 * You _can't_ clear the a timeout so we have to handle that too but		 * at least we don't have to handle timeouts too early.		 */		event_add( &cli_data->ev, &wait_time );		return NULL;	} else if ( !strncmp(line, "RELEASE", 7) ) {		if ( cli_data->next_lock <= 0 ) {			incr_stats( release_mismatch );			return "NOT_LOCKED\n";		}		cli_data->next_lock--;		struct locks* l = cli_data->client_locks + cli_data->next_lock;		if ( l->state == UNLOCKED ) {			incr_stats( release_mismatch );			return "NOT_LOCKED\n";		}		remove_client_lock( l, 1 );		incr_stats( total_releases );		return "RELEASED\n";	} else if ( !strncmp( line, "STATS ", 6 ) ) {		return provide_stats( line + 6 );	} else {		return "ERROR BAD_COMMAND\n";	}}
if (line_len > 0 && line[line_len-1] == '\r') {		line_len--;		line[line_len] = '\0';	}
line_len > 0 && line[line_len-1] == '\r'
line_len > 0
line_len
line_len
0
line[line_len-1] == '\r'
line[line_len-1]
line
line
line_len-1
line_len
line_len
1
'\r'
{		line_len--;		line[line_len] = '\0';	}
line_len--;
line_len--
line_len
line_len
line[line_len] = '\0';
line[line_len] = '\0'
line[line_len]
line
line
line_len
line_len
'\0'
if ( !strncmp( line, "ACQ4ME ", 7 ) || !strncmp( line, "ACQ4ANY ", 8 ) ) {		if ( cli_data->next_lock >= MAX_LOCKS_PER_CLIENT ) {			incr_stats( lock_mismatch );			return "LOCK_HELD\n";		}		if ( cli_data->next_lock > 0 ) {			struct locks* last_lock = cli_data->client_locks + cli_data->next_lock - 1;			if ( last_lock->state != PROCESSING ) {				/*				 * Handling multiple timeouts would require some extensive				 * rejiggering and we don't expect users to try anyway.  So we				 * don't let them.  Also, it'd be a bit crazy to actually get				 * a lock while waiting on another - it'd lead to unpredictable				 * locking order which is the first step in deadlocking.				 */				incr_stats( lock_while_waiting );				return "ERROR WAIT_FOR_RESPONSE\n";			}		}		int for_anyone = line[6] != ' ';		char* key = strtok( line + 7 + for_anyone, " " );		unsigned workers = atou( strtok(NULL, " ") );		unsigned maxqueue = atou( strtok(NULL, " ") );		unsigned timeout = atou( strtok(NULL, " ") );		if ( !key || !workers || !maxqueue ) {			return "ERROR BAD_SYNTAX\n";		}		uint32_t hash_value = hash( key, strlen( key ), 0 );		struct PoolCounter* pCounter;		pCounter = hashtable_find( primary_hashtable, hash_value, key );		if ( !pCounter ) {			pCounter = malloc( sizeof( *pCounter ) );			if ( !pCounter ) {				fprintf( stderr, "Out of memory\n" );				return "ERROR OUT_OF_MEMORY\n";			}			pCounter->htentry.key = strdup( key );			pCounter->htentry.key_hash = hash_value;			pCounter->count = 0;			pCounter->processing = 0;			DOUBLE_LLIST_INIT( pCounter->working );			DOUBLE_LLIST_INIT( pCounter->for_them );			DOUBLE_LLIST_INIT( pCounter->for_anyone );			hashtable_insert( primary_hashtable, (struct hashtable_entry *) pCounter );			incr_stats( hashtable_entries );		}		if ( pCounter->count >= maxqueue ) {			incr_stats( full_queues );			return "QUEUE_FULL\n";		}		if ( pCounter->processing < workers ) {			struct locks* l = init_next_lock( cli_data, pCounter, PROCESSING );			if ( !l ) {				/*				 * We check for this condition way way up above so we should				 * never see this.				 */				fprintf( stderr, "Out of locks\n" );				exit( EXIT_FAILURE );			}			gettimeofday( &l->timeval, NULL );			pCounter->count++;			pCounter->processing++;			incr_stats( processing_workers );			DOUBLE_LLIST_ADD( &pCounter->working, &l->siblings );			incr_stats( total_acquired );			return "LOCKED\n";		}		if ( !timeout ) {			return "TIMEOUT\n";		}		struct locks* l = init_next_lock( cli_data, pCounter, for_anyone ? WAIT_ANY : WAITING );		pCounter->count++;		struct timeval wait_time;		if ( for_anyone ) {			DOUBLE_LLIST_ADD( &pCounter->for_anyone, &l->siblings );		} else {			DOUBLE_LLIST_ADD( &pCounter->for_them, &l->siblings );		}		incr_stats( waiting_workers );		gettimeofday( &l->timeval, NULL );		wait_time.tv_sec = timeout;		wait_time.tv_usec = 0;		/*		 * Note that this timeout will override any previously set timeouts.		 * You _can't_ clear the a timeout so we have to handle that too but		 * at least we don't have to handle timeouts too early.		 */		event_add( &cli_data->ev, &wait_time );		return NULL;	} else if ( !strncmp(line, "RELEASE", 7) ) {		if ( cli_data->next_lock <= 0 ) {			incr_stats( release_mismatch );			return "NOT_LOCKED\n";		}		cli_data->next_lock--;		struct locks* l = cli_data->client_locks + cli_data->next_lock;		if ( l->state == UNLOCKED ) {			incr_stats( release_mismatch );			return "NOT_LOCKED\n";		}		remove_client_lock( l, 1 );		incr_stats( total_releases );		return "RELEASED\n";	} else if ( !strncmp( line, "STATS ", 6 ) ) {		return provide_stats( line + 6 );	} else {		return "ERROR BAD_COMMAND\n";	}
!strncmp( line, "ACQ4ME ", 7 ) || !strncmp( line, "ACQ4ANY ", 8 )
!strncmp( line, "ACQ4ME ", 7 )
strncmp( line, "ACQ4ME ", 7 )
strncmp
strncmp
line
line
"ACQ4ME "
7
!strncmp( line, "ACQ4ANY ", 8 )
strncmp( line, "ACQ4ANY ", 8 )
strncmp
strncmp
line
line
"ACQ4ANY "
8
{		if ( cli_data->next_lock >= MAX_LOCKS_PER_CLIENT ) {			incr_stats( lock_mismatch );			return "LOCK_HELD\n";		}		if ( cli_data->next_lock > 0 ) {			struct locks* last_lock = cli_data->client_locks + cli_data->next_lock - 1;			if ( last_lock->state != PROCESSING ) {				/*				 * Handling multiple timeouts would require some extensive				 * rejiggering and we don't expect users to try anyway.  So we				 * don't let them.  Also, it'd be a bit crazy to actually get				 * a lock while waiting on another - it'd lead to unpredictable				 * locking order which is the first step in deadlocking.				 */				incr_stats( lock_while_waiting );				return "ERROR WAIT_FOR_RESPONSE\n";			}		}		int for_anyone = line[6] != ' ';		char* key = strtok( line + 7 + for_anyone, " " );		unsigned workers = atou( strtok(NULL, " ") );		unsigned maxqueue = atou( strtok(NULL, " ") );		unsigned timeout = atou( strtok(NULL, " ") );		if ( !key || !workers || !maxqueue ) {			return "ERROR BAD_SYNTAX\n";		}		uint32_t hash_value = hash( key, strlen( key ), 0 );		struct PoolCounter* pCounter;		pCounter = hashtable_find( primary_hashtable, hash_value, key );		if ( !pCounter ) {			pCounter = malloc( sizeof( *pCounter ) );			if ( !pCounter ) {				fprintf( stderr, "Out of memory\n" );				return "ERROR OUT_OF_MEMORY\n";			}			pCounter->htentry.key = strdup( key );			pCounter->htentry.key_hash = hash_value;			pCounter->count = 0;			pCounter->processing = 0;			DOUBLE_LLIST_INIT( pCounter->working );			DOUBLE_LLIST_INIT( pCounter->for_them );			DOUBLE_LLIST_INIT( pCounter->for_anyone );			hashtable_insert( primary_hashtable, (struct hashtable_entry *) pCounter );			incr_stats( hashtable_entries );		}		if ( pCounter->count >= maxqueue ) {			incr_stats( full_queues );			return "QUEUE_FULL\n";		}		if ( pCounter->processing < workers ) {			struct locks* l = init_next_lock( cli_data, pCounter, PROCESSING );			if ( !l ) {				/*				 * We check for this condition way way up above so we should				 * never see this.				 */				fprintf( stderr, "Out of locks\n" );				exit( EXIT_FAILURE );			}			gettimeofday( &l->timeval, NULL );			pCounter->count++;			pCounter->processing++;			incr_stats( processing_workers );			DOUBLE_LLIST_ADD( &pCounter->working, &l->siblings );			incr_stats( total_acquired );			return "LOCKED\n";		}		if ( !timeout ) {			return "TIMEOUT\n";		}		struct locks* l = init_next_lock( cli_data, pCounter, for_anyone ? WAIT_ANY : WAITING );		pCounter->count++;		struct timeval wait_time;		if ( for_anyone ) {			DOUBLE_LLIST_ADD( &pCounter->for_anyone, &l->siblings );		} else {			DOUBLE_LLIST_ADD( &pCounter->for_them, &l->siblings );		}		incr_stats( waiting_workers );		gettimeofday( &l->timeval, NULL );		wait_time.tv_sec = timeout;		wait_time.tv_usec = 0;		/*		 * Note that this timeout will override any previously set timeouts.		 * You _can't_ clear the a timeout so we have to handle that too but		 * at least we don't have to handle timeouts too early.		 */		event_add( &cli_data->ev, &wait_time );		return NULL;	}
if ( cli_data->next_lock >= MAX_LOCKS_PER_CLIENT ) {			incr_stats( lock_mismatch );			return "LOCK_HELD\n";		}
cli_data->next_lock >= MAX_LOCKS_PER_CLIENT
cli_data->next_lock
cli_data
cli_data
next_lock
MAX_LOCKS_PER_CLIENT
MAX_LOCKS_PER_CLIENT
{			incr_stats( lock_mismatch );			return "LOCK_HELD\n";		}
incr_stats( lock_mismatch );
incr_stats( lock_mismatch );
incr_stats
incr_stats
( lock_mismatch )
lock_mismatch
lock_mismatch
return "LOCK_HELD\n";
"LOCK_HELD\n"
if ( cli_data->next_lock > 0 ) {			struct locks* last_lock = cli_data->client_locks + cli_data->next_lock - 1;			if ( last_lock->state != PROCESSING ) {				/*				 * Handling multiple timeouts would require some extensive				 * rejiggering and we don't expect users to try anyway.  So we				 * don't let them.  Also, it'd be a bit crazy to actually get				 * a lock while waiting on another - it'd lead to unpredictable				 * locking order which is the first step in deadlocking.				 */				incr_stats( lock_while_waiting );				return "ERROR WAIT_FOR_RESPONSE\n";			}		}
cli_data->next_lock > 0
cli_data->next_lock
cli_data
cli_data
next_lock
0
{			struct locks* last_lock = cli_data->client_locks + cli_data->next_lock - 1;			if ( last_lock->state != PROCESSING ) {				/*				 * Handling multiple timeouts would require some extensive				 * rejiggering and we don't expect users to try anyway.  So we				 * don't let them.  Also, it'd be a bit crazy to actually get				 * a lock while waiting on another - it'd lead to unpredictable				 * locking order which is the first step in deadlocking.				 */				incr_stats( lock_while_waiting );				return "ERROR WAIT_FOR_RESPONSE\n";			}		}
struct locks* last_lock = cli_data->client_locks + cli_data->next_lock - 1;
struct locks* last_lock = cli_data->client_locks + cli_data->next_lock - 1;
struct locks
locks
* last_lock = cli_data->client_locks + cli_data->next_lock - 1
*
last_lock
= cli_data->client_locks + cli_data->next_lock - 1
cli_data->client_locks + cli_data->next_lock - 1
cli_data->client_locks + cli_data->next_lock
cli_data->client_locks
cli_data
cli_data
client_locks
cli_data->next_lock
cli_data
cli_data
next_lock
1
if ( last_lock->state != PROCESSING ) {				/*				 * Handling multiple timeouts would require some extensive				 * rejiggering and we don't expect users to try anyway.  So we				 * don't let them.  Also, it'd be a bit crazy to actually get				 * a lock while waiting on another - it'd lead to unpredictable				 * locking order which is the first step in deadlocking.				 */				incr_stats( lock_while_waiting );				return "ERROR WAIT_FOR_RESPONSE\n";			}
last_lock->state != PROCESSING
last_lock->state
last_lock
last_lock
state
PROCESSING
PROCESSING
{				/*				 * Handling multiple timeouts would require some extensive				 * rejiggering and we don't expect users to try anyway.  So we				 * don't let them.  Also, it'd be a bit crazy to actually get				 * a lock while waiting on another - it'd lead to unpredictable				 * locking order which is the first step in deadlocking.				 */				incr_stats( lock_while_waiting );				return "ERROR WAIT_FOR_RESPONSE\n";			}
incr_stats( lock_while_waiting );
incr_stats( lock_while_waiting );
incr_stats
incr_stats
( lock_while_waiting )
lock_while_waiting
lock_while_waiting
return "ERROR WAIT_FOR_RESPONSE\n";
"ERROR WAIT_FOR_RESPONSE\n"
int for_anyone = line[6] != ' ';
int for_anyone = line[6] != ' ';
int
for_anyone = line[6] != ' '
for_anyone
= line[6] != ' '
line[6] != ' '
line[6]
line
line
6
' '
char* key = strtok( line + 7 + for_anyone, " " );
char* key = strtok( line + 7 + for_anyone, " " );
char
* key = strtok( line + 7 + for_anyone, " " )
*
key
= strtok( line + 7 + for_anyone, " " )
strtok( line + 7 + for_anyone, " " )
strtok
strtok
line + 7 + for_anyone
line + 7
line
line
7
for_anyone
for_anyone
" "
unsigned workers = atou( strtok(NULL, " ") );
unsigned workers = atou( strtok(NULL, " ") );
unsigned
workers = atou( strtok(NULL, " ") )
workers
= atou( strtok(NULL, " ") )
atou( strtok(NULL, " ") )
atou
atou
strtok(NULL, " ")
strtok
strtok
NULL
NULL
" "
unsigned maxqueue = atou( strtok(NULL, " ") );
unsigned maxqueue = atou( strtok(NULL, " ") );
unsigned
maxqueue = atou( strtok(NULL, " ") )
maxqueue
= atou( strtok(NULL, " ") )
atou( strtok(NULL, " ") )
atou
atou
strtok(NULL, " ")
strtok
strtok
NULL
NULL
" "
unsigned timeout = atou( strtok(NULL, " ") );
unsigned timeout = atou( strtok(NULL, " ") );
unsigned
timeout = atou( strtok(NULL, " ") )
timeout
= atou( strtok(NULL, " ") )
atou( strtok(NULL, " ") )
atou
atou
strtok(NULL, " ")
strtok
strtok
NULL
NULL
" "
if ( !key || !workers || !maxqueue ) {			return "ERROR BAD_SYNTAX\n";		}
!key || !workers || !maxqueue
!key || !workers
!key
key
key
!workers
workers
workers
!maxqueue
maxqueue
maxqueue
{			return "ERROR BAD_SYNTAX\n";		}
return "ERROR BAD_SYNTAX\n";
"ERROR BAD_SYNTAX\n"
uint32_t hash_value = hash( key, strlen( key ), 0 );
uint32_t hash_value = hash( key, strlen( key ), 0 );
uint32_t
uint32_t
hash_value = hash( key, strlen( key ), 0 )
hash_value
= hash( key, strlen( key ), 0 )
hash( key, strlen( key ), 0 )
hash
hash
key
key
strlen( key )
strlen
strlen
key
key
0
struct PoolCounter* pCounter;
struct PoolCounter* pCounter;
struct PoolCounter
PoolCounter
* pCounter
*
pCounter
pCounter = hashtable_find( primary_hashtable, hash_value, key );
pCounter = hashtable_find( primary_hashtable, hash_value, key )
pCounter
pCounter
hashtable_find( primary_hashtable, hash_value, key )
hashtable_find
hashtable_find
primary_hashtable
primary_hashtable
hash_value
hash_value
key
key
if ( !pCounter ) {			pCounter = malloc( sizeof( *pCounter ) );			if ( !pCounter ) {				fprintf( stderr, "Out of memory\n" );				return "ERROR OUT_OF_MEMORY\n";			}			pCounter->htentry.key = strdup( key );			pCounter->htentry.key_hash = hash_value;			pCounter->count = 0;			pCounter->processing = 0;			DOUBLE_LLIST_INIT( pCounter->working );			DOUBLE_LLIST_INIT( pCounter->for_them );			DOUBLE_LLIST_INIT( pCounter->for_anyone );			hashtable_insert( primary_hashtable, (struct hashtable_entry *) pCounter );			incr_stats( hashtable_entries );		}
!pCounter
pCounter
pCounter
{			pCounter = malloc( sizeof( *pCounter ) );			if ( !pCounter ) {				fprintf( stderr, "Out of memory\n" );				return "ERROR OUT_OF_MEMORY\n";			}			pCounter->htentry.key = strdup( key );			pCounter->htentry.key_hash = hash_value;			pCounter->count = 0;			pCounter->processing = 0;			DOUBLE_LLIST_INIT( pCounter->working );			DOUBLE_LLIST_INIT( pCounter->for_them );			DOUBLE_LLIST_INIT( pCounter->for_anyone );			hashtable_insert( primary_hashtable, (struct hashtable_entry *) pCounter );			incr_stats( hashtable_entries );		}
pCounter = malloc( sizeof( *pCounter ) );
pCounter = malloc( sizeof( *pCounter ) )
pCounter
pCounter
malloc( sizeof( *pCounter ) )
malloc
malloc
sizeof( *pCounter )
( *pCounter )
*pCounter
pCounter
pCounter
if ( !pCounter ) {				fprintf( stderr, "Out of memory\n" );				return "ERROR OUT_OF_MEMORY\n";			}
!pCounter
pCounter
pCounter
{				fprintf( stderr, "Out of memory\n" );				return "ERROR OUT_OF_MEMORY\n";			}
fprintf( stderr, "Out of memory\n" );
fprintf( stderr, "Out of memory\n" )
fprintf
fprintf
stderr
stderr
"Out of memory\n"
return "ERROR OUT_OF_MEMORY\n";
"ERROR OUT_OF_MEMORY\n"
pCounter->htentry.key = strdup( key );
pCounter->htentry.key = strdup( key )
pCounter->htentry.key
pCounter->htentry
pCounter
pCounter
htentry
key
strdup( key )
strdup
strdup
key
key
pCounter->htentry.key_hash = hash_value;
pCounter->htentry.key_hash = hash_value
pCounter->htentry.key_hash
pCounter->htentry
pCounter
pCounter
htentry
key_hash
hash_value
hash_value
pCounter->count = 0;
pCounter->count = 0
pCounter->count
pCounter
pCounter
count
0
pCounter->processing = 0;
pCounter->processing = 0
pCounter->processing
pCounter
pCounter
processing
0
DOUBLE_LLIST_INIT( pCounter->working );
DOUBLE_LLIST_INIT( pCounter->working )
DOUBLE_LLIST_INIT
DOUBLE_LLIST_INIT
pCounter->working
pCounter
pCounter
working
DOUBLE_LLIST_INIT( pCounter->for_them );
DOUBLE_LLIST_INIT( pCounter->for_them )
DOUBLE_LLIST_INIT
DOUBLE_LLIST_INIT
pCounter->for_them
pCounter
pCounter
for_them
DOUBLE_LLIST_INIT( pCounter->for_anyone );
DOUBLE_LLIST_INIT( pCounter->for_anyone )
DOUBLE_LLIST_INIT
DOUBLE_LLIST_INIT
pCounter->for_anyone
pCounter
pCounter
for_anyone
hashtable_insert( primary_hashtable, (struct hashtable_entry *) pCounter );
hashtable_insert( primary_hashtable, (struct hashtable_entry *) pCounter )
hashtable_insert
hashtable_insert
primary_hashtable
primary_hashtable
(struct hashtable_entry *) pCounter
struct hashtable_entry *
struct hashtable_entry
hashtable_entry
*
*
pCounter
pCounter
incr_stats( hashtable_entries );
incr_stats( hashtable_entries );
incr_stats
incr_stats
( hashtable_entries )
hashtable_entries
hashtable_entries
if ( pCounter->count >= maxqueue ) {			incr_stats( full_queues );			return "QUEUE_FULL\n";		}
pCounter->count >= maxqueue
pCounter->count
pCounter
pCounter
count
maxqueue
maxqueue
{			incr_stats( full_queues );			return "QUEUE_FULL\n";		}
incr_stats( full_queues );
incr_stats( full_queues );
incr_stats
incr_stats
( full_queues )
full_queues
full_queues
return "QUEUE_FULL\n";
"QUEUE_FULL\n"
if ( pCounter->processing < workers ) {			struct locks* l = init_next_lock( cli_data, pCounter, PROCESSING );			if ( !l ) {				/*				 * We check for this condition way way up above so we should				 * never see this.				 */				fprintf( stderr, "Out of locks\n" );				exit( EXIT_FAILURE );			}			gettimeofday( &l->timeval, NULL );			pCounter->count++;			pCounter->processing++;			incr_stats( processing_workers );			DOUBLE_LLIST_ADD( &pCounter->working, &l->siblings );			incr_stats( total_acquired );			return "LOCKED\n";		}
pCounter->processing < workers
pCounter->processing
pCounter
pCounter
processing
workers
workers
{			struct locks* l = init_next_lock( cli_data, pCounter, PROCESSING );			if ( !l ) {				/*				 * We check for this condition way way up above so we should				 * never see this.				 */				fprintf( stderr, "Out of locks\n" );				exit( EXIT_FAILURE );			}			gettimeofday( &l->timeval, NULL );			pCounter->count++;			pCounter->processing++;			incr_stats( processing_workers );			DOUBLE_LLIST_ADD( &pCounter->working, &l->siblings );			incr_stats( total_acquired );			return "LOCKED\n";		}
struct locks* l = init_next_lock( cli_data, pCounter, PROCESSING );
struct locks* l = init_next_lock( cli_data, pCounter, PROCESSING );
struct locks
locks
* l = init_next_lock( cli_data, pCounter, PROCESSING )
*
l
= init_next_lock( cli_data, pCounter, PROCESSING )
init_next_lock( cli_data, pCounter, PROCESSING )
init_next_lock
init_next_lock
cli_data
cli_data
pCounter
pCounter
PROCESSING
PROCESSING
if ( !l ) {				/*				 * We check for this condition way way up above so we should				 * never see this.				 */				fprintf( stderr, "Out of locks\n" );				exit( EXIT_FAILURE );			}
!l
l
l
{				/*				 * We check for this condition way way up above so we should				 * never see this.				 */				fprintf( stderr, "Out of locks\n" );				exit( EXIT_FAILURE );			}
fprintf( stderr, "Out of locks\n" );
fprintf( stderr, "Out of locks\n" )
fprintf
fprintf
stderr
stderr
"Out of locks\n"
exit( EXIT_FAILURE );
exit( EXIT_FAILURE );
exit
exit
( EXIT_FAILURE )
EXIT_FAILURE
EXIT_FAILURE
gettimeofday( &l->timeval, NULL );
gettimeofday( &l->timeval, NULL )
gettimeofday
gettimeofday
&l->timeval
l->timeval
l
l
timeval
NULL
NULL
pCounter->count++;
pCounter->count++
pCounter->count
pCounter
pCounter
count
pCounter->processing++;
pCounter->processing++
pCounter->processing
pCounter
pCounter
processing
incr_stats( processing_workers );
incr_stats( processing_workers );
incr_stats
incr_stats
( processing_workers )
processing_workers
processing_workers
DOUBLE_LLIST_ADD( &pCounter->working, &l->siblings );
DOUBLE_LLIST_ADD( &pCounter->working, &l->siblings )
DOUBLE_LLIST_ADD
DOUBLE_LLIST_ADD
&pCounter->working
pCounter->working
pCounter
pCounter
working
&l->siblings
l->siblings
l
l
siblings
incr_stats( total_acquired );
incr_stats( total_acquired );
incr_stats
incr_stats
( total_acquired )
total_acquired
total_acquired
return "LOCKED\n";
"LOCKED\n"
if ( !timeout ) {			return "TIMEOUT\n";		}
!timeout
timeout
timeout
{			return "TIMEOUT\n";		}
return "TIMEOUT\n";
"TIMEOUT\n"
struct locks* l = init_next_lock( cli_data, pCounter, for_anyone ? WAIT_ANY : WAITING );
struct locks* l = init_next_lock( cli_data, pCounter, for_anyone ? WAIT_ANY : WAITING );
struct locks
locks
* l = init_next_lock( cli_data, pCounter, for_anyone ? WAIT_ANY : WAITING )
*
l
= init_next_lock( cli_data, pCounter, for_anyone ? WAIT_ANY : WAITING )
init_next_lock( cli_data, pCounter, for_anyone ? WAIT_ANY : WAITING )
init_next_lock
init_next_lock
cli_data
cli_data
pCounter
pCounter
for_anyone ? WAIT_ANY : WAITING
for_anyone
for_anyone
WAIT_ANY
WAIT_ANY
WAITING
WAITING
pCounter->count++;
pCounter->count++
pCounter->count
pCounter
pCounter
count
struct timeval wait_time;
struct timeval wait_time;
struct timeval
timeval
wait_time
wait_time
if ( for_anyone ) {			DOUBLE_LLIST_ADD( &pCounter->for_anyone, &l->siblings );		} else {			DOUBLE_LLIST_ADD( &pCounter->for_them, &l->siblings );		}
for_anyone
for_anyone
{			DOUBLE_LLIST_ADD( &pCounter->for_anyone, &l->siblings );		}
DOUBLE_LLIST_ADD( &pCounter->for_anyone, &l->siblings );
DOUBLE_LLIST_ADD( &pCounter->for_anyone, &l->siblings )
DOUBLE_LLIST_ADD
DOUBLE_LLIST_ADD
&pCounter->for_anyone
pCounter->for_anyone
pCounter
pCounter
for_anyone
&l->siblings
l->siblings
l
l
siblings
{			DOUBLE_LLIST_ADD( &pCounter->for_them, &l->siblings );		}
DOUBLE_LLIST_ADD( &pCounter->for_them, &l->siblings );
DOUBLE_LLIST_ADD( &pCounter->for_them, &l->siblings )
DOUBLE_LLIST_ADD
DOUBLE_LLIST_ADD
&pCounter->for_them
pCounter->for_them
pCounter
pCounter
for_them
&l->siblings
l->siblings
l
l
siblings
incr_stats( waiting_workers );
incr_stats( waiting_workers );
incr_stats
incr_stats
( waiting_workers )
waiting_workers
waiting_workers
gettimeofday( &l->timeval, NULL );
gettimeofday( &l->timeval, NULL )
gettimeofday
gettimeofday
&l->timeval
l->timeval
l
l
timeval
NULL
NULL
wait_time.tv_sec = timeout;
wait_time.tv_sec = timeout
wait_time.tv_sec
wait_time
wait_time
tv_sec
timeout
timeout
wait_time.tv_usec = 0;
wait_time.tv_usec = 0
wait_time.tv_usec
wait_time
wait_time
tv_usec
0
event_add( &cli_data->ev, &wait_time );
event_add( &cli_data->ev, &wait_time )
event_add
event_add
&cli_data->ev
cli_data->ev
cli_data
cli_data
ev
&wait_time
wait_time
wait_time
return NULL;
NULL
NULL
if ( !strncmp(line, "RELEASE", 7) ) {		if ( cli_data->next_lock <= 0 ) {			incr_stats( release_mismatch );			return "NOT_LOCKED\n";		}		cli_data->next_lock--;		struct locks* l = cli_data->client_locks + cli_data->next_lock;		if ( l->state == UNLOCKED ) {			incr_stats( release_mismatch );			return "NOT_LOCKED\n";		}		remove_client_lock( l, 1 );		incr_stats( total_releases );		return "RELEASED\n";	} else if ( !strncmp( line, "STATS ", 6 ) ) {		return provide_stats( line + 6 );	} else {		return "ERROR BAD_COMMAND\n";	}
!strncmp(line, "RELEASE", 7)
strncmp(line, "RELEASE", 7)
strncmp
strncmp
line
line
"RELEASE"
7
{		if ( cli_data->next_lock <= 0 ) {			incr_stats( release_mismatch );			return "NOT_LOCKED\n";		}		cli_data->next_lock--;		struct locks* l = cli_data->client_locks + cli_data->next_lock;		if ( l->state == UNLOCKED ) {			incr_stats( release_mismatch );			return "NOT_LOCKED\n";		}		remove_client_lock( l, 1 );		incr_stats( total_releases );		return "RELEASED\n";	}
if ( cli_data->next_lock <= 0 ) {			incr_stats( release_mismatch );			return "NOT_LOCKED\n";		}
cli_data->next_lock <= 0
cli_data->next_lock
cli_data
cli_data
next_lock
0
{			incr_stats( release_mismatch );			return "NOT_LOCKED\n";		}
incr_stats( release_mismatch );
incr_stats( release_mismatch );
incr_stats
incr_stats
( release_mismatch )
release_mismatch
release_mismatch
return "NOT_LOCKED\n";
"NOT_LOCKED\n"
cli_data->next_lock--;
cli_data->next_lock--
cli_data->next_lock
cli_data
cli_data
next_lock
struct locks* l = cli_data->client_locks + cli_data->next_lock;
struct locks* l = cli_data->client_locks + cli_data->next_lock;
struct locks
locks
* l = cli_data->client_locks + cli_data->next_lock
*
l
= cli_data->client_locks + cli_data->next_lock
cli_data->client_locks + cli_data->next_lock
cli_data->client_locks
cli_data
cli_data
client_locks
cli_data->next_lock
cli_data
cli_data
next_lock
if ( l->state == UNLOCKED ) {			incr_stats( release_mismatch );			return "NOT_LOCKED\n";		}
l->state == UNLOCKED
l->state
l
l
state
UNLOCKED
UNLOCKED
{			incr_stats( release_mismatch );			return "NOT_LOCKED\n";		}
incr_stats( release_mismatch );
incr_stats( release_mismatch );
incr_stats
incr_stats
( release_mismatch )
release_mismatch
release_mismatch
return "NOT_LOCKED\n";
"NOT_LOCKED\n"
remove_client_lock( l, 1 );
remove_client_lock( l, 1 )
remove_client_lock
remove_client_lock
l
l
1
incr_stats( total_releases );
incr_stats( total_releases );
incr_stats
incr_stats
( total_releases )
total_releases
total_releases
return "RELEASED\n";
"RELEASED\n"
if ( !strncmp( line, "STATS ", 6 ) ) {		return provide_stats( line + 6 );	} else {		return "ERROR BAD_COMMAND\n";	}
!strncmp( line, "STATS ", 6 )
strncmp( line, "STATS ", 6 )
strncmp
strncmp
line
line
"STATS "
6
{		return provide_stats( line + 6 );	}
return provide_stats( line + 6 );
provide_stats( line + 6 )
provide_stats
provide_stats
line + 6
line
line
6
{		return "ERROR BAD_COMMAND\n";	}
return "ERROR BAD_COMMAND\n";
"ERROR BAD_COMMAND\n"
-----joern-----
(295,221,0)
(368,403,0)
(63,124,0)
(386,101,0)
(42,142,0)
(258,64,0)
(76,10,0)
(282,116,0)
(366,235,0)
(52,64,0)
(377,116,0)
(78,146,0)
(156,305,0)
(329,368,0)
(328,179,0)
(90,230,0)
(16,247,0)
(37,196,0)
(312,72,0)
(300,63,0)
(143,287,0)
(180,179,0)
(239,310,0)
(397,12,0)
(233,137,0)
(298,64,0)
(290,146,0)
(67,372,0)
(307,165,0)
(29,212,0)
(363,172,0)
(359,385,0)
(293,358,0)
(64,335,0)
(173,333,0)
(272,146,0)
(292,77,0)
(203,145,0)
(198,403,0)
(172,235,0)
(165,169,0)
(287,67,0)
(228,195,0)
(36,191,0)
(245,258,0)
(46,27,0)
(7,314,0)
(149,57,0)
(158,86,0)
(220,325,0)
(8,146,0)
(306,298,0)
(304,228,0)
(96,257,0)
(229,64,0)
(263,403,0)
(131,179,0)
(43,174,0)
(256,17,0)
(161,130,0)
(87,47,0)
(103,24,0)
(214,146,0)
(8,59,0)
(310,139,0)
(182,45,0)
(228,146,0)
(397,53,0)
(288,294,0)
(19,152,0)
(168,180,0)
(253,397,0)
(149,179,0)
(72,365,0)
(131,154,0)
(389,260,0)
(181,284,0)
(288,393,0)
(179,350,0)
(130,161,0)
(287,64,0)
(309,191,0)
(339,395,0)
(306,41,0)
(112,276,0)
(186,118,0)
(59,192,0)
(153,216,0)
(25,45,0)
(327,284,0)
(43,179,0)
(230,35,0)
(402,397,0)
(350,179,0)
(268,188,0)
(354,141,0)
(259,385,0)
(378,194,0)
(164,36,0)
(262,53,0)
(216,12,0)
(28,10,0)
(6,328,0)
(98,34,0)
(101,386,0)
(162,194,0)
(227,380,0)
(340,39,0)
(0,132,0)
(183,156,0)
(101,191,0)
(144,31,0)
(212,29,0)
(161,11,0)
(24,45,0)
(153,374,0)
(360,368,0)
(23,283,0)
(344,368,0)
(194,378,0)
(313,191,0)
(193,179,0)
(313,210,0)
(309,17,0)
(37,146,0)
(380,125,0)
(197,176,0)
(160,378,0)
(283,400,0)
(40,45,0)
(369,11,0)
(169,165,0)
(44,64,0)
(375,84,0)
(182,105,0)
(357,36,0)
(4,67,0)
(237,146,0)
(286,146,0)
(20,193,0)
(104,35,0)
(135,210,0)
(135,276,0)
(53,374,0)
(196,37,0)
(134,45,0)
(86,12,0)
(298,276,0)
(400,283,0)
(380,18,0)
(110,385,0)
(393,77,0)
(237,149,0)
(300,179,0)
(219,276,0)
(193,372,0)
(36,403,0)
(92,79,0)
(45,146,0)
(331,327,0)
(370,81,0)
(403,314,0)
(212,350,0)
(234,63,0)
(85,25,0)
(79,191,0)
(142,356,0)
(63,300,0)
(11,161,0)
(336,26,0)
(340,276,0)
(231,146,0)
(54,276,0)
(237,94,0)
(332,113,0)
(77,179,0)
(394,182,0)
(134,227,0)
(121,193,0)
(280,63,0)
(319,162,0)
(50,146,0)
(64,197,0)
(306,229,0)
(315,270,0)
(370,87,0)
(18,380,0)
(124,356,0)
(361,153,0)
(2,180,0)
(306,44,0)
(177,146,0)
(284,146,0)
(383,94,0)
(136,322,0)
(299,295,0)
(317,176,0)
(141,354,0)
(59,8,0)
(190,303,0)
(15,84,0)
(281,146,0)
(310,239,0)
(57,356,0)
(14,363,0)
(81,370,0)
(261,257,0)
(396,7,0)
(94,247,0)
(266,354,0)
(32,237,0)
(109,209,0)
(105,182,0)
(7,396,0)
(45,327,0)
(306,287,0)
(105,8,0)
(23,356,0)
(114,34,0)
(206,336,0)
(204,272,0)
(301,29,0)
(0,270,0)
(336,179,0)
(285,244,0)
(288,63,0)
(270,335,0)
(279,399,0)
(99,400,0)
(148,24,0)
(317,335,0)
(11,369,0)
(7,360,0)
(211,151,0)
(234,64,0)
(355,69,0)
(39,191,0)
(87,370,0)
(208,94,0)
(33,31,0)
(40,179,0)
(246,134,0)
(167,363,0)
(283,146,0)
(55,387,0)
(89,192,0)
(342,146,0)
(353,378,0)
(226,324,0)
(393,23,0)
(128,67,0)
(240,267,0)
(380,227,0)
(101,27,0)
(180,57,0)
(24,179,0)
(207,131,0)
(179,356,0)
(337,146,0)
(126,74,0)
(367,64,0)
(108,324,0)
(185,149,0)
(79,365,0)
(106,165,0)
(132,0,0)
(234,67,0)
(201,130,0)
(248,86,0)
(272,204,0)
(303,190,0)
(242,169,0)
(150,43,0)
(392,179,0)
(269,105,0)
(386,374,0)
(1,392,0)
(137,356,0)
(108,272,0)
(39,340,0)
(287,393,0)
(131,45,0)
(392,57,0)
(210,313,0)
(336,142,0)
(36,179,0)
(130,37,0)
(18,244,0)
(224,146,0)
(97,314,0)
(346,113,0)
(151,314,0)
(157,298,0)
(61,261,0)
(193,45,0)
(2,314,0)
(210,31,0)
(288,67,0)
(161,188,0)
(392,45,0)
(72,74,0)
(391,131,0)
(188,161,0)
(169,12,0)
(184,146,0)
(257,261,0)
(200,328,0)
(190,195,0)
(363,403,0)
(234,314,0)
(174,43,0)
(26,336,0)
(69,400,0)
(116,70,0)
(237,387,0)
(142,336,0)
(205,221,0)
(101,179,0)
(387,228,0)
(373,244,0)
(238,369,0)
(84,395,0)
(49,386,0)
(65,317,0)
(291,195,0)
(390,135,0)
(368,360,0)
(127,295,0)
(113,135,0)
(111,230,0)
(237,393,0)
(107,300,0)
(86,139,0)
(195,146,0)
(247,146,0)
(287,63,0)
(281,392,0)
(306,258,0)
(83,95,0)
(257,191,0)
(234,149,0)
(71,57,0)
(82,203,0)
(154,314,0)
(17,309,0)
(93,153,0)
(129,203,0)
(215,119,0)
(66,400,0)
(41,223,0)
(250,300,0)
(235,172,0)
(182,179,0)
(374,53,0)
(306,133,0)
(306,234,0)
(64,12,0)
(145,203,0)
(296,86,0)
(136,64,0)
(251,313,0)
(139,86,0)
(371,36,0)
(199,195,0)
(5,124,0)
(102,39,0)
(321,10,0)
(62,386,0)
(84,72,0)
(75,109,0)
(175,133,0)
(95,216,0)
(225,327,0)
(374,146,0)
(288,149,0)
(297,123,0)
(154,131,0)
(210,135,0)
(258,209,0)
(170,354,0)
(163,146,0)
(235,314,0)
(328,6,0)
(343,324,0)
(327,45,0)
(318,215,0)
(306,136,0)
(180,2,0)
(10,12,0)
(379,311,0)
(47,87,0)
(44,305,0)
(31,191,0)
(91,40,0)
(133,64,0)
(28,52,0)
(287,289,0)
(77,393,0)
(333,196,0)
(147,257,0)
(376,291,0)
(287,149,0)
(13,229,0)
(270,0,0)
(31,210,0)
(52,275,0)
(400,69,0)
(101,45,0)
(3,123,0)
(255,81,0)
(140,39,0)
(116,179,0)
(70,116,0)
(284,95,0)
(237,63,0)
(384,118,0)
(131,372,0)
(274,216,0)
(60,392,0)
(306,288,0)
(194,162,0)
(87,388,0)
(166,81,0)
(139,310,0)
(88,393,0)
(358,119,0)
(81,27,0)
(254,149,0)
(203,12,0)
(252,136,0)
(327,283,0)
(385,259,0)
(120,309,0)
(400,284,0)
(398,276,0)
(382,146,0)
(5,284,0)
(399,193,0)
(347,205,0)
(403,36,0)
(205,64,0)
(261,365,0)
(324,191,0)
(22,387,0)
(216,95,0)
(241,354,0)
(341,3,0)
(10,28,0)
(325,294,0)
(134,179,0)
(348,77,0)
(196,333,0)
(193,399,0)
(232,309,0)
(265,356,0)
(195,190,0)
(308,313,0)
(138,203,0)
(34,12,0)
(237,67,0)
(350,212,0)
(392,281,0)
(360,7,0)
(124,5,0)
(3,191,0)
(395,84,0)
(352,146,0)
(272,108,0)
(267,213,0)
(9,179,0)
(385,191,0)
(68,192,0)
(271,234,0)
(187,101,0)
(48,327,0)
(302,132,0)
(401,263,0)
(381,101,0)
(239,34,0)
(330,41,0)
(365,261,0)
(182,57,0)
(56,146,0)
(378,27,0)
(218,283,0)
(171,314,0)
(351,204,0)
(178,34,0)
(36,45,0)
(95,284,0)
(30,44,0)
(67,179,0)
(41,64,0)
(169,132,0)
(311,322,0)
(162,146,0)
(123,3,0)
(243,64,0)
(277,5,0)
(24,396,0)
(316,74,0)
(237,64,0)
(320,146,0)
(58,45,0)
(122,146,0)
(273,372,0)
(306,52,0)
(216,153,0)
(100,37,0)
(117,180,0)
(69,284,0)
(115,303,0)
(364,23,0)
(132,169,0)
(334,398,0)
(227,134,0)
(229,278,0)
(40,47,0)
(73,386,0)
(264,328,0)
(53,397,0)
(372,356,0)
(29,45,0)
(38,197,0)
(34,239,0)
(244,18,0)
(155,146,0)
(362,8,0)
(152,179,0)
(47,40,0)
(27,146,0)
(222,43,0)
(159,3,0)
(189,374,0)
(324,108,0)
(306,237,0)
(260,314,0)
(234,393,0)
(21,79,0)
(180,45,0)
(202,134,0)
(133,213,0)
(165,335,0)
(174,356,0)
(35,230,0)
(113,276,0)
(338,303,0)
(80,270,0)
(172,363,0)
(345,215,0)
(396,24,0)
(365,72,0)
(354,12,0)
(230,135,0)
(249,259,0)
(399,37,0)
(6,356,0)
(244,27,0)
(236,286,0)
(288,64,0)
(217,182,0)
(27,101,0)
(188,8,0)
(369,284,0)
(51,40,0)
(70,356,0)
(192,59,0)
(326,333,0)
(365,79,0)
(306,205,0)
(323,288,0)
(324,343,1)
(131,372,1)
(131,179,1)
(329,396,1)
(394,25,1)
(210,31,1)
(3,191,1)
(203,12,1)
(242,270,1)
(354,170,1)
(237,149,1)
(306,205,1)
(237,67,1)
(133,64,1)
(18,244,1)
(201,369,1)
(154,131,1)
(330,11,1)
(182,217,1)
(385,110,1)
(258,64,1)
(132,302,1)
(21,312,1)
(58,283,1)
(403,36,1)
(255,166,1)
(194,378,1)
(145,203,1)
(392,1,1)
(387,22,1)
(306,237,1)
(183,17,1)
(2,180,1)
(152,19,1)
(151,211,1)
(123,297,1)
(69,355,1)
(34,178,1)
(131,391,1)
(29,45,1)
(357,164,1)
(35,230,1)
(158,296,1)
(180,57,1)
(306,234,1)
(144,390,1)
(49,73,1)
(64,367,1)
(220,105,1)
(338,199,1)
(37,196,1)
(317,65,1)
(38,64,1)
(368,403,1)
(216,12,1)
(81,27,1)
(157,398,1)
(20,121,1)
(23,283,1)
(36,45,1)
(136,64,1)
(43,150,1)
(306,44,1)
(187,46,1)
(0,270,1)
(120,310,1)
(287,149,1)
(138,129,1)
(254,185,1)
(193,45,1)
(257,147,1)
(99,69,1)
(262,397,1)
(129,82,1)
(9,25,1)
(212,29,1)
(234,149,1)
(386,374,1)
(19,179,1)
(311,379,1)
(372,273,1)
(348,292,1)
(47,40,1)
(64,335,1)
(257,191,1)
(106,242,1)
(287,67,1)
(128,57,1)
(234,393,1)
(180,168,1)
(272,204,1)
(178,114,1)
(247,16,1)
(261,257,1)
(130,37,1)
(82,141,1)
(373,285,1)
(369,238,1)
(241,266,1)
(243,317,1)
(0,132,1)
(121,105,1)
(259,385,1)
(343,226,1)
(182,45,1)
(302,169,1)
(333,173,1)
(300,107,1)
(114,98,1)
(107,250,1)
(226,247,1)
(24,179,1)
(392,45,1)
(7,396,1)
(234,63,1)
(33,144,1)
(399,193,1)
(62,73,1)
(273,67,1)
(217,394,1)
(283,400,1)
(207,2,1)
(204,351,1)
(270,335,1)
(286,236,1)
(260,389,1)
(200,264,1)
(80,315,1)
(160,353,1)
(93,274,1)
(250,152,1)
(306,133,1)
(350,212,1)
(5,277,1)
(230,135,1)
(27,101,1)
(29,301,1)
(393,88,1)
(271,151,1)
(102,259,1)
(228,195,1)
(90,135,1)
(73,381,1)
(272,108,1)
(14,358,1)
(347,295,1)
(42,70,1)
(127,152,1)
(88,77,1)
(399,37,1)
(75,259,1)
(261,61,1)
(288,149,1)
(70,116,1)
(363,403,1)
(153,374,1)
(195,190,1)
(24,103,1)
(96,79,1)
(180,179,1)
(53,262,1)
(313,308,1)
(232,120,1)
(193,372,1)
(25,85,1)
(236,87,1)
(36,357,1)
(174,43,1)
(227,134,1)
(282,377,1)
(15,72,1)
(304,387,1)
(380,227,1)
(185,23,1)
(192,89,1)
(101,191,1)
(397,12,1)
(288,323,1)
(105,269,1)
(251,31,1)
(105,8,1)
(87,370,1)
(377,174,1)
(229,64,1)
(383,208,1)
(395,84,1)
(40,179,1)
(259,249,1)
(237,32,1)
(288,63,1)
(389,154,1)
(296,239,1)
(7,360,1)
(359,141,1)
(318,345,1)
(108,324,1)
(386,49,1)
(44,30,1)
(168,117,1)
(167,14,1)
(246,349,1)
(55,162,1)
(63,280,1)
(52,28,1)
(131,45,1)
(210,313,1)
(98,0,1)
(46,291,1)
(269,182,1)
(287,143,1)
(91,51,1)
(117,235,1)
(130,201,1)
(277,63,1)
(285,227,1)
(165,307,1)
(230,111,1)
(13,145,1)
(162,194,1)
(109,75,1)
(35,104,1)
(85,45,1)
(16,94,1)
(393,77,1)
(10,12,1)
(270,80,1)
(334,113,1)
(364,393,1)
(375,15,1)
(40,45,1)
(366,172,1)
(371,198,1)
(266,310,1)
(303,115,1)
(149,179,1)
(100,284,1)
(188,268,1)
(113,332,1)
(173,326,1)
(291,195,1)
(39,140,1)
(180,45,1)
(175,267,1)
(36,179,1)
(313,191,1)
(341,17,1)
(5,284,1)
(279,193,1)
(392,57,1)
(336,206,1)
(10,321,1)
(258,245,1)
(365,79,1)
(137,233,1)
(297,3,1)
(401,403,1)
(328,200,1)
(161,188,1)
(111,90,1)
(101,179,1)
(386,62,1)
(41,64,1)
(360,368,1)
(40,91,1)
(340,39,1)
(288,64,1)
(402,253,1)
(306,288,1)
(86,12,1)
(280,300,1)
(234,271,1)
(328,179,1)
(101,45,1)
(89,68,1)
(84,375,1)
(95,83,1)
(161,130,1)
(11,161,1)
(17,256,1)
(28,10,1)
(400,284,1)
(287,393,1)
(23,364,1)
(308,251,1)
(244,373,1)
(310,139,1)
(104,230,1)
(309,191,1)
(31,191,1)
(63,300,1)
(370,81,1)
(76,145,1)
(135,210,1)
(244,27,1)
(392,179,1)
(349,281,1)
(336,26,1)
(79,92,1)
(116,282,1)
(306,258,1)
(301,9,1)
(152,179,1)
(263,401,1)
(222,6,1)
(237,94,1)
(346,35,1)
(189,123,1)
(306,136,1)
(134,45,1)
(14,263,1)
(36,191,1)
(166,47,1)
(306,41,1)
(306,229,1)
(287,64,1)
(150,222,1)
(45,327,1)
(92,21,1)
(239,34,1)
(1,60,1)
(253,189,1)
(165,335,1)
(182,57,1)
(51,349,1)
(142,336,1)
(379,395,1)
(110,359,1)
(234,64,1)
(306,287,1)
(193,20,1)
(65,0,1)
(291,376,1)
(252,311,1)
(133,175,1)
(339,84,1)
(141,354,1)
(235,172,1)
(136,252,1)
(390,340,1)
(169,12,1)
(397,402,1)
(197,38,1)
(319,194,1)
(263,403,1)
(53,397,1)
(41,330,1)
(87,47,1)
(264,372,1)
(43,179,1)
(113,135,1)
(378,160,1)
(292,124,1)
(188,8,1)
(156,183,1)
(293,215,1)
(196,333,1)
(3,159,1)
(234,67,1)
(344,329,1)
(8,59,1)
(385,191,1)
(312,123,1)
(396,24,1)
(218,11,1)
(321,76,1)
(84,72,1)
(95,216,1)
(381,187,1)
(295,299,1)
(317,335,1)
(169,165,1)
(198,399,1)
(164,371,1)
(193,179,1)
(61,257,1)
(32,272,1)
(267,240,1)
(94,383,1)
(327,283,1)
(202,246,1)
(44,64,1)
(124,5,1)
(237,393,1)
(225,48,1)
(68,362,1)
(249,385,1)
(153,361,1)
(391,207,1)
(368,344,1)
(172,363,1)
(189,395,1)
(358,293,1)
(39,191,1)
(298,64,1)
(79,191,1)
(233,142,1)
(205,347,1)
(236,380,1)
(362,37,1)
(116,179,1)
(400,99,1)
(86,248,1)
(309,232,1)
(235,366,1)
(378,27,1)
(361,93,1)
(205,64,1)
(323,325,1)
(101,386,1)
(4,128,1)
(30,156,1)
(69,284,1)
(353,286,1)
(34,12,1)
(363,167,1)
(60,27,1)
(394,137,1)
(306,52,1)
(351,108,1)
(170,241,1)
(298,157,1)
(374,53,1)
(336,179,1)
(77,348,1)
(67,4,1)
(288,393,1)
(245,109,1)
(229,13,1)
(216,153,1)
(132,169,1)
(6,328,1)
(77,179,1)
(355,66,1)
(52,64,1)
(327,284,1)
(208,228,1)
(149,254,1)
(287,63,1)
(179,350,1)
(324,191,1)
(240,35,1)
(306,298,1)
(48,331,1)
(134,179,1)
(22,55,1)
(354,12,1)
(300,179,1)
(72,365,1)
(115,338,1)
(103,148,1)
(332,346,1)
(98,197,1)
(105,182,1)
(162,319,1)
(237,64,1)
(367,243,1)
(123,3,1)
(199,8,1)
(190,303,1)
(248,158,1)
(365,261,1)
(331,58,1)
(57,71,1)
(147,96,1)
(307,106,1)
(228,304,1)
(238,195,1)
(268,130,1)
(203,138,1)
(326,100,1)
(71,149,1)
(376,399,1)
(380,18,1)
(139,86,1)
(81,255,1)
(398,334,1)
(148,260,1)
(215,318,1)
(284,95,1)
(25,45,1)
(237,387,1)
(143,291,1)
(256,309,1)
(237,63,1)
(369,284,1)
(11,369,1)
(399,279,1)
(345,263,1)
(181,374,1)
(327,225,1)
(274,181,1)
(325,220,1)
(24,45,1)
(310,239,1)
(395,339,1)
(83,216,1)
(159,341,1)
(281,392,1)
(31,33,1)
(288,67,1)
(17,309,1)
(67,179,1)
(400,69,1)
(182,179,1)
(299,127,1)
(134,202,1)
(59,192,1)
(140,102,1)
(64,12,1)
(211,7,1)
(206,42,1)
(66,218,1)
(288,393,2)
(333,123,2)
(110,141,2)
(237,291,2)
(145,203,2)
(210,313,2)
(71,152,2)
(220,105,2)
(92,123,2)
(68,395,2)
(392,45,2)
(2,399,2)
(134,179,2)
(188,130,2)
(72,123,2)
(91,349,2)
(312,123,2)
(143,291,2)
(323,105,2)
(383,291,2)
(202,349,2)
(345,263,2)
(259,385,2)
(308,259,2)
(243,0,2)
(40,45,2)
(396,24,2)
(306,234,2)
(237,149,2)
(347,152,2)
(99,11,2)
(234,63,2)
(203,12,2)
(299,152,2)
(111,259,2)
(217,152,2)
(283,400,2)
(36,399,2)
(198,399,2)
(101,386,2)
(28,145,2)
(303,123,2)
(70,116,2)
(261,257,2)
(306,298,2)
(338,395,2)
(263,403,2)
(123,17,2)
(47,349,2)
(245,259,2)
(306,41,2)
(325,105,2)
(182,25,2)
(30,17,2)
(162,194,2)
(52,64,2)
(349,291,2)
(13,145,2)
(1,291,2)
(189,123,2)
(340,259,2)
(145,141,2)
(287,149,2)
(287,63,2)
(377,152,2)
(238,395,2)
(135,210,2)
(49,73,2)
(82,141,2)
(272,291,2)
(47,40,2)
(32,291,2)
(51,349,2)
(339,123,2)
(5,284,2)
(57,152,2)
(205,152,2)
(262,395,2)
(253,123,2)
(277,152,2)
(391,399,2)
(351,291,2)
(11,161,2)
(96,123,2)
(93,123,2)
(29,45,2)
(58,11,2)
(105,182,2)
(15,123,2)
(296,239,2)
(311,395,2)
(182,57,2)
(244,349,2)
(266,310,2)
(113,135,2)
(36,45,2)
(86,239,2)
(141,354,2)
(150,152,2)
(28,10,2)
(230,259,2)
(40,349,2)
(369,123,2)
(328,152,2)
(399,193,2)
(193,372,2)
(87,370,2)
(393,77,2)
(63,300,2)
(79,191,2)
(215,263,2)
(181,395,2)
(180,399,2)
(81,349,2)
(76,145,2)
(25,11,2)
(380,349,2)
(105,152,2)
(327,284,2)
(361,395,2)
(194,291,2)
(402,395,2)
(310,239,2)
(248,239,2)
(306,237,2)
(19,25,2)
(306,258,2)
(365,123,2)
(225,11,2)
(108,324,2)
(77,152,2)
(386,374,2)
(212,25,2)
(313,259,2)
(279,105,2)
(286,291,2)
(73,291,2)
(93,395,2)
(306,288,2)
(182,45,2)
(309,191,2)
(326,395,2)
(45,327,2)
(369,395,2)
(237,393,2)
(107,152,2)
(287,67,2)
(230,135,2)
(196,333,2)
(400,284,2)
(134,349,2)
(291,399,2)
(116,152,2)
(38,0,2)
(331,11,2)
(257,123,2)
(85,11,2)
(22,291,2)
(131,45,2)
(251,259,2)
(0,132,2)
(132,169,2)
(303,395,2)
(23,152,2)
(281,291,2)
(237,387,2)
(287,291,2)
(306,205,2)
(288,67,2)
(353,291,2)
(95,123,2)
(355,11,2)
(392,57,2)
(237,94,2)
(271,399,2)
(369,284,2)
(386,291,2)
(40,179,2)
(329,399,2)
(310,139,2)
(17,309,2)
(397,395,2)
(206,152,2)
(247,291,2)
(235,172,2)
(29,25,2)
(37,123,2)
(272,108,2)
(258,259,2)
(151,399,2)
(362,123,2)
(400,11,2)
(306,229,2)
(210,31,2)
(180,179,2)
(368,399,2)
(338,123,2)
(360,399,2)
(395,84,2)
(254,152,2)
(7,396,2)
(375,123,2)
(67,152,2)
(7,360,2)
(262,123,2)
(131,399,2)
(180,45,2)
(31,191,2)
(287,393,2)
(374,123,2)
(9,25,2)
(31,259,2)
(44,17,2)
(11,123,2)
(341,17,2)
(105,8,2)
(14,399,2)
(207,399,2)
(284,123,2)
(400,69,2)
(321,145,2)
(159,17,2)
(313,191,2)
(128,152,2)
(274,395,2)
(84,72,2)
(210,259,2)
(385,141,2)
(141,310,2)
(153,123,2)
(149,179,2)
(39,259,2)
(260,399,2)
(240,35,2)
(336,179,2)
(197,0,2)
(363,399,2)
(370,81,2)
(152,25,2)
(192,123,2)
(204,291,2)
(18,244,2)
(401,399,2)
(284,395,2)
(190,395,2)
(326,123,2)
(167,399,2)
(25,45,2)
(381,291,2)
(274,123,2)
(287,64,2)
(358,263,2)
(392,291,2)
(160,291,2)
(66,11,2)
(232,310,2)
(399,37,2)
(217,25,2)
(226,291,2)
(228,291,2)
(200,152,2)
(268,130,2)
(257,191,2)
(330,11,2)
(397,123,2)
(354,12,2)
(95,216,2)
(365,261,2)
(27,101,2)
(105,25,2)
(131,372,2)
(233,152,2)
(116,179,2)
(227,134,2)
(37,196,2)
(5,152,2)
(402,123,2)
(235,399,2)
(300,179,2)
(63,152,2)
(371,399,2)
(81,27,2)
(59,123,2)
(64,12,2)
(397,12,2)
(39,191,2)
(216,12,2)
(328,179,2)
(298,35,2)
(236,291,2)
(193,179,2)
(205,64,2)
(161,188,2)
(180,57,2)
(68,123,2)
(344,399,2)
(174,43,2)
(360,368,2)
(113,35,2)
(307,270,2)
(227,349,2)
(165,335,2)
(378,27,2)
(6,328,2)
(324,291,2)
(90,259,2)
(3,17,2)
(203,141,2)
(237,63,2)
(222,152,2)
(45,11,2)
(395,123,2)
(6,152,2)
(291,195,2)
(89,395,2)
(182,152,2)
(195,395,2)
(332,35,2)
(306,287,2)
(24,45,2)
(234,67,2)
(21,123,2)
(212,29,2)
(288,63,2)
(101,179,2)
(282,152,2)
(348,152,2)
(59,395,2)
(359,141,2)
(53,123,2)
(7,399,2)
(131,179,2)
(374,53,2)
(129,141,2)
(196,123,2)
(376,399,2)
(246,349,2)
(154,131,2)
(134,45,2)
(295,152,2)
(252,395,2)
(43,179,2)
(179,350,2)
(194,378,2)
(36,179,2)
(297,17,2)
(100,123,2)
(306,133,2)
(124,152,2)
(139,239,2)
(334,35,2)
(258,64,2)
(374,395,2)
(88,152,2)
(172,399,2)
(41,64,2)
(35,230,2)
(327,11,2)
(154,399,2)
(239,34,2)
(380,18,2)
(269,152,2)
(53,397,2)
(174,152,2)
(365,79,2)
(298,64,2)
(387,291,2)
(140,259,2)
(350,25,2)
(60,291,2)
(127,152,2)
(379,395,2)
(136,64,2)
(192,395,2)
(156,17,2)
(285,349,2)
(234,399,2)
(302,270,2)
(181,123,2)
(385,191,2)
(44,64,2)
(319,291,2)
(208,291,2)
(190,303,2)
(153,374,2)
(169,12,2)
(101,45,2)
(117,399,2)
(133,35,2)
(170,310,2)
(367,0,2)
(83,395,2)
(238,123,2)
(137,152,2)
(363,403,2)
(394,152,2)
(153,395,2)
(79,123,2)
(108,291,2)
(132,270,2)
(27,291,2)
(211,399,2)
(69,284,2)
(121,105,2)
(364,152,2)
(169,270,2)
(139,86,2)
(264,152,2)
(336,26,2)
(403,36,2)
(166,349,2)
(300,152,2)
(318,263,2)
(41,11,2)
(157,35,2)
(123,3,2)
(70,152,2)
(403,399,2)
(61,123,2)
(237,67,2)
(8,395,2)
(216,123,2)
(189,395,2)
(148,399,2)
(272,204,2)
(389,399,2)
(340,39,2)
(195,190,2)
(288,105,2)
(142,152,2)
(288,64,2)
(288,149,2)
(101,191,2)
(393,152,2)
(173,123,2)
(306,44,2)
(241,310,2)
(193,45,2)
(259,141,2)
(158,239,2)
(372,152,2)
(24,179,2)
(135,259,2)
(280,152,2)
(234,64,2)
(270,335,2)
(48,11,2)
(343,291,2)
(368,403,2)
(162,291,2)
(144,259,2)
(267,35,2)
(84,123,2)
(242,270,2)
(100,395,2)
(182,179,2)
(42,152,2)
(102,259,2)
(229,64,2)
(350,212,2)
(133,64,2)
(336,152,2)
(179,25,2)
(256,310,2)
(106,270,2)
(301,25,2)
(263,399,2)
(149,152,2)
(36,191,2)
(196,395,2)
(59,192,2)
(124,5,2)
(53,395,2)
(304,291,2)
(269,25,2)
(10,145,2)
(33,259,2)
(380,227,2)
(161,130,2)
(193,105,2)
(4,152,2)
(161,369,2)
(136,395,2)
(261,123,2)
(46,291,2)
(175,35,2)
(0,270,2)
(64,335,2)
(228,195,2)
(346,35,2)
(237,64,2)
(378,291,2)
(152,179,2)
(317,0,2)
(138,141,2)
(396,399,2)
(34,12,2)
(253,395,2)
(188,8,2)
(77,179,2)
(67,179,2)
(199,123,2)
(273,152,2)
(234,393,2)
(23,283,2)
(168,399,2)
(35,259,2)
(284,95,2)
(109,259,2)
(317,335,2)
(8,59,2)
(362,395,2)
(115,395,2)
(244,27,2)
(327,283,2)
(147,123,2)
(250,152,2)
(55,291,2)
(87,349,2)
(398,35,2)
(234,149,2)
(86,12,2)
(10,12,2)
(187,291,2)
(172,363,2)
(216,395,2)
(87,47,2)
(255,349,2)
(130,369,2)
(62,73,2)
(18,349,2)
(199,395,2)
(130,37,2)
(283,11,2)
(11,395,2)
(20,105,2)
(370,349,2)
(165,270,2)
(75,259,2)
(357,399,2)
(218,11,2)
(69,11,2)
(83,123,2)
(2,180,2)
(190,123,2)
(11,369,2)
(392,179,2)
(95,395,2)
(309,310,2)
(17,310,2)
(394,25,2)
(292,152,2)
(249,141,2)
(366,399,2)
(94,291,2)
(390,259,2)
(65,0,2)
(185,152,2)
(89,123,2)
(24,399,2)
(195,123,2)
(306,136,2)
(43,152,2)
(333,395,2)
(72,365,2)
(399,105,2)
(104,259,2)
(281,392,2)
(142,336,2)
(52,145,2)
(183,17,2)
(293,263,2)
(201,369,2)
(120,310,2)
(306,52,2)
(103,399,2)
(173,395,2)
(373,349,2)
(37,395,2)
(169,165,2)
(354,310,2)
(101,291,2)
(361,123,2)
(164,399,2)
(216,153,2)
(8,123,2)
(229,145,2)
(3,191,2)
(16,291,2)
(115,123,2)
(64,0,2)
(324,191,2)
-----------------------------------
(0,line_len > 0 && line[line_len-1] == \'\\r\')
(1,count)
(2,pCounter->count++)
(3,cli_data->next_lock)
(4,processing)
(5,strdup( key )
(6,DOUBLE_LLIST_INIT( pCounter->working )
(7,DOUBLE_LLIST_ADD( &pCounter->working, &l->siblings )
(8,maxqueue = atou( strtok(NULL, " ")
(9,pCounter)
(10,line + 6)
(11,!key || !workers || !maxqueue)
(12,char* line)
(13,"ERROR BAD_COMMAND\\n")
(14,l)
(15,last_lock)
(16,0)
(17,cli_data->next_lock >= MAX_LOCKS_PER_CLIENT)
(18,&l->siblings)
(19,pCounter)
(20,processing)
(21,cli_data)
(22,tv_sec)
(23,pCounter->htentry.key_hash = hash_value)
(24,pCounter->working)
(25,!pCounter)
(26,struct hashtable_entry *)
(27,* l = init_next_lock( cli_data, pCounter, for_anyone ? WAIT_ANY : WAITING )
(28,provide_stats( line + 6 )
(29,*pCounter)
(30,"LOCK_HELD\\n")
(31,cli_data->client_locks)
(32,NULL)
(33,client_locks)
(34,strncmp( line, "ACQ4ME ", 7 )
(35,l->state == UNLOCKED)
(36,init_next_lock( cli_data, pCounter, PROCESSING )
(37,workers = atou( strtok(NULL, " ")
(38,\'\\0\')
(39,cli_data->next_lock)
(40,pCounter->for_anyone)
(41,return "ERROR BAD_SYNTAX\\n";)
(42,primary_hashtable)
(43,pCounter->for_them)
(44,return "LOCK_HELD\\n";)
(45,pCounter = hashtable_find( primary_hashtable, hash_value, key )
(46,l)
(47,&pCounter->for_anyone)
(48,hash_value)
(49,WAIT_ANY)
(50,timeout)
(51,pCounter)
(52,return provide_stats( line + 6 )
(53,line[6] != \' \')
(54,if ( cli_data->next_lock <= 0 )
(55,wait_time)
(56,wait_time)
(57,pCounter->count = 0)
(58,pCounter)
(59,atou( strtok(NULL, " ")
(60,pCounter)
(61,1)
(62,WAITING)
(63,pCounter->htentry.key)
(64,line[line_len])
(65,line_len)
(66,key)
(67,pCounter->processing)
(68,NULL)
(69,strlen( key )
(70,DOUBLE_LLIST_INIT( pCounter->for_anyone )
(71,0)
(72,* last_lock = cli_data->client_locks + cli_data->next_lock - 1)
(73,for_anyone)
(74,)
(75,release_mismatch)
(76,line)
(77,pCounter->htentry)
(78,if ( !timeout )
(79,cli_data->client_locks)
(80,0)
(81,l->siblings)
(82,line)
(83," ")
(84,last_lock->state)
(85,pCounter)
(86,strncmp( line, "ACQ4ANY ", 8 )
(87,DOUBLE_LLIST_ADD( &pCounter->for_anyone, &l->siblings )
(88,key_hash)
(89," ")
(90,l)
(91,for_anyone)
(92,client_locks)
(93,7)
(94,wait_time.tv_usec)
(95,strtok( line + 7 + for_anyone, " " )
(96,cli_data)
(97,if ( !l )
(98,line)
(99,0)
(100,workers)
(101,init_next_lock( cli_data, pCounter, for_anyone ? WAIT_ANY : WAITING )
(102,cli_data)
(103,working)
(104,UNLOCKED)
(105,pCounter->count >= maxqueue)
(106,line_len)
(107,htentry)
(108,&cli_data->ev)
(109,incr_stats( release_mismatch )
(110,next_lock)
(111,state)
(112,l)
(113,remove_client_lock( l, 1 )
(114,"ACQ4ME ")
(115," ")
(116,pCounter->for_anyone)
(117,pCounter)
(118,)
(119,)
(120,cli_data)
(121,pCounter)
(122,if ( !key || !workers || !maxqueue )
(123,cli_data->next_lock > 0)
(124,pCounter->htentry.key = strdup( key )
(125,)
(126,last_lock)
(127,stderr)
(128,pCounter)
(129,"STATS ")
(130,!workers)
(131,pCounter->processing)
(132,line[line_len-1] == \'\\r\')
(133,return "NOT_LOCKED\\n";)
(134,pCounter->for_them)
(135,* l = cli_data->client_locks + cli_data->next_lock)
(136,return "ERROR WAIT_FOR_RESPONSE\\n";)
(137,incr_stats( hashtable_entries )
(138,6)
(139,!strncmp( line, "ACQ4ANY ", 8 )
(140,next_lock)
(141,!strncmp(line, "RELEASE", 7)
(142,hashtable_insert( primary_hashtable, (struct hashtable_entry *)
(143,"TIMEOUT\\n")
(144,cli_data)
(145,!strncmp( line, "STATS ", 6 )
(146,)
(147,next_lock)
(148,pCounter)
(149,pCounter->count)
(150,for_them)
(151,incr_stats( total_acquired )
(152,!pCounter)
(153,7 + for_anyone)
(154,pCounter->processing++)
(155,hash_value)
(156,incr_stats( lock_mismatch )
(157,"RELEASED\\n")
(158,"ACQ4ANY ")
(159,next_lock)
(160,timeval)
(161,!workers || !maxqueue)
(162,gettimeofday( &l->timeval, NULL )
(163,if ( cli_data->next_lock > 0 )
(164,pCounter)
(165,line_len-1)
(166,l)
(167,timeval)
(168,count)
(169,line[line_len-1])
(170,7)
(171,l)
(172,&l->timeval)
(173," ")
(174,DOUBLE_LLIST_INIT( pCounter->for_them )
(175,"NOT_LOCKED\\n")
(176,)
(177,if ( cli_data->next_lock >= MAX_LOCKS_PER_CLIENT )
(178,7)
(179,pCounter = malloc( sizeof( *pCounter )
(180,pCounter->count)
(181,key)
(182,pCounter->count)
(183,lock_mismatch)
(184,for_anyone)
(185,pCounter)
(186,if (line_len > 0 && line[line_len-1] == \'\\r\')
(187,cli_data)
(188,!maxqueue)
(189,for_anyone)
(190,atou( strtok(NULL, " ")
(191,struct client_data* cli_data)
(192,strtok(NULL, " ")
(193,pCounter->processing)
(194,&l->timeval)
(195,timeout = atou( strtok(NULL, " ")
(196,atou( strtok(NULL, " ")
(197,line[line_len] = \'\\0\')
(198,l)
(199,timeout)
(200,working)
(201,workers)
(202,for_them)
(203,strncmp( line, "STATS ", 6 )
(204,&wait_time)
(205,return "ERROR OUT_OF_MEMORY\\n";)
(206,pCounter)
(207,pCounter)
(208,wait_time)
(209,)
(210,cli_data->client_locks + cli_data->next_lock)
(211,total_acquired)
(212,sizeof( *pCounter )
(213,)
(214,l)
(215,fprintf( stderr, "Out of locks\\n" )
(216,line + 7 + for_anyone)
(217,count)
(218,hash_value)
(219,if ( l->state == UNLOCKED )
(220,full_queues)
(221,)
(222,pCounter)
(223,)
(224,pCounter)
(225,key)
(226,cli_data)
(227,&pCounter->for_them)
(228,wait_time.tv_sec = timeout)
(229,return "ERROR BAD_COMMAND\\n";)
(230,l->state)
(231,if ( pCounter->count >= maxqueue )
(232,next_lock)
(233,hashtable_entries)
(234,return "LOCKED\\n";)
(235,gettimeofday( &l->timeval, NULL )
(236,waiting_workers)
(237,return NULL;)
(238,key)
(239,!strncmp( line, "ACQ4ME ", 7 )
(240,release_mismatch)
(241,"RELEASE")
(242,line)
(243,line)
(244,l->siblings)
(245,"NOT_LOCKED\\n")
(246,pCounter)
(247,wait_time.tv_usec = 0)
(248,8)
(249,0)
(250,pCounter)
(251,cli_data)
(252,"ERROR WAIT_FOR_RESPONSE\\n")
(253,line)
(254,count)
(255,siblings)
(256,MAX_LOCKS_PER_CLIENT)
(257,cli_data->next_lock)
(258,return "NOT_LOCKED\\n";)
(259,cli_data->next_lock <= 0)
(260,incr_stats( processing_workers )
(261,cli_data->next_lock - 1)
(262,\' \')
(263,!l)
(264,pCounter)
(265,if ( !pCounter )
(266,line)
(267,incr_stats( release_mismatch )
(268,maxqueue)
(269,maxqueue)
(270,line_len > 0)
(271,"LOCKED\\n")
(272,event_add( &cli_data->ev, &wait_time )
(273,0)
(274,line)
(275,)
(276,)
(277,key)
(278,)
(279,workers)
(280,key)
(281,pCounter->count++)
(282,for_anyone)
(283,hash_value = hash( key, strlen( key )
(284,* key = strtok( line + 7 + for_anyone, " " )
(285,l)
(286,incr_stats( waiting_workers )
(287,return "TIMEOUT\\n";)
(288,return "QUEUE_FULL\\n";)
(289,)
(290,if ( !pCounter )
(291,!timeout)
(292,pCounter)
(293,EXIT_FAILURE)
(294,)
(295,fprintf( stderr, "Out of memory\\n" )
(296,line)
(297,0)
(298,return "RELEASED\\n";)
(299,"Out of memory\\n")
(300,pCounter->htentry)
(301,pCounter)
(302,\'\\r\')
(303,strtok(NULL, " ")
(304,timeout)
(305,)
(306,RET)
(307,1)
(308,next_lock)
(309,cli_data->next_lock)
(310,!strncmp( line, "ACQ4ME ", 7 )
(311,incr_stats( lock_while_waiting )
(312,last_lock)
(313,cli_data->next_lock)
(314,)
(315,line_len)
(316,if ( last_lock->state != PROCESSING )
(317,line_len--)
(318,"Out of locks\\n")
(319,NULL)
(320,key)
(321,6)
(322,)
(323,"QUEUE_FULL\\n")
(324,cli_data->ev)
(325,incr_stats( full_queues )
(326,NULL)
(327,hashtable_find( primary_hashtable, hash_value, key )
(328,pCounter->working)
(329,l)
(330,"ERROR BAD_SYNTAX\\n")
(331,primary_hashtable)
(332,1)
(333,strtok(NULL, " ")
(334,total_releases)
(335,int line_len)
(336,(struct hashtable_entry *)
(337,if ( for_anyone )
(338,NULL)
(339,PROCESSING)
(340,cli_data->next_lock--)
(341,cli_data)
(342,maxqueue)
(343,ev)
(344,siblings)
(345,stderr)
(346,l)
(347,"ERROR OUT_OF_MEMORY\\n")
(348,htentry)
(349,for_anyone)
(350,malloc( sizeof( *pCounter )
(351,wait_time)
(352,workers)
(353,l)
(354,strncmp(line, "RELEASE", 7)
(355,key)
(356,)
(357,PROCESSING)
(358,exit( EXIT_FAILURE )
(359,cli_data)
(360,&l->siblings)
(361,for_anyone)
(362,maxqueue)
(363,l->timeval)
(364,hash_value)
(365,cli_data->client_locks + cli_data->next_lock - 1)
(366,NULL)
(367,line_len)
(368,l->siblings)
(369,!key)
(370,&l->siblings)
(371,cli_data)
(372,pCounter->processing = 0)
(373,siblings)
(374,for_anyone = line[6] != \' \')
(375,state)
(376,timeout)
(377,pCounter)
(378,l->timeval)
(379,lock_while_waiting)
(380,DOUBLE_LLIST_ADD( &pCounter->for_them, &l->siblings )
(381,pCounter)
(382,if ( pCounter->processing < workers )
(383,tv_usec)
(384,if ( !strncmp( line, "ACQ4ME ", 7 )
(385,cli_data->next_lock)
(386,for_anyone ? WAIT_ANY : WAITING)
(387,wait_time.tv_sec)
(388,)
(389,processing_workers)
(390,l)
(391,processing)
(392,pCounter->count)
(393,pCounter->htentry.key_hash)
(394,pCounter)
(395,last_lock->state != PROCESSING)
(396,&pCounter->working)
(397,line[6])
(398,incr_stats( total_releases )
(399,pCounter->processing < workers)
(400,hash( key, strlen( key )
(401,l)
(402,6)
(403,* l = init_next_lock( cli_data, pCounter, PROCESSING )
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^