-----label-----
1
-----code-----
void process_timeout(struct client_data* cli_data) {
	/*
	 * Note that you can't cancel a timeout so we just have to be careful and
	 * only do timeout things when the lock looks like its timed out.
	 */
	if ( cli_data->next_lock <= 0 ) {
		return;
	}
	struct locks* l = cli_data->client_locks + cli_data->next_lock - 1;
	if ( ( l->state == WAIT_ANY ) || ( l->state == WAITING ) ) {
		// Ignore any timeouts for locks not waiting - those are just left over
		// because its expensive to cancel them.
		cli_data->next_lock--;
		struct timeval now = { 0 };
		time_stats( l, wasted_timeout_time );
		send_client( cli_data, "TIMEOUT\n" );
		decr_stats( waiting_workers );
		remove_client_lock( l, 0 );
	}
}
-----children-----
1,2
1,3
1,4
3,4
3,5
5,6
5,7
6,7
8,9
8,10
11,12
11,13
11,14
12,13
12,14
13,14
13,15
14,15
14,16
15,16
19,20
21,22
22,23
22,24
23,24
25,26
25,27
25,28
28,29
29,30
29,31
30,31
30,32
31,32
31,33
32,33
35,36
35,37
36,37
40,41
40,42
41,42
41,43
42,43
43,44
43,45
44,45
44,46
45,46
48,49
50,51
51,52
51,53
52,53
52,54
53,54
56,57
58,59
58,60
58,61
58,62
58,63
58,64
59,60
60,61
61,62
61,63
62,63
65,66
66,67
66,68
67,68
69,70
69,71
71,72
72,73
74,75
75,76
75,77
75,78
76,77
78,79
80,81
82,83
83,84
83,85
83,86
84,85
86,87
89,90
90,91
90,92
91,92
93,94
94,95
96,97
97,98
97,99
97,100
98,99
100,101
-----nextToken-----
2,4,7,9,10,16,17,18,20,24,26,27,33,34,37,38,39,46,47,49,54,55,57,63,64,68,70,73,77,79,81,85,87,88,92,95,99,101,102
-----computeFrom-----
13,14
13,15
29,30
29,31
30,31
30,32
41,42
41,43
43,44
43,45
51,52
51,53
-----guardedBy-----
54,101
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ReturnStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;InitializerList;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;
-----ast_node-----
void process_timeout(struct client_data* cli_data) {	/*	 * Note that you can't cancel a timeout so we just have to be careful and	 * only do timeout things when the lock looks like its timed out.	 */	if ( cli_data->next_lock <= 0 ) {		return;	}	struct locks* l = cli_data->client_locks + cli_data->next_lock - 1;	if ( ( l->state == WAIT_ANY ) || ( l->state == WAITING ) ) {		// Ignore any timeouts for locks not waiting - those are just left over		// because its expensive to cancel them.		cli_data->next_lock--;		struct timeval now = { 0 };		time_stats( l, wasted_timeout_time );		send_client( cli_data, "TIMEOUT\n" );		decr_stats( waiting_workers );		remove_client_lock( l, 0 );	}}
void
process_timeout(struct client_data* cli_data)
process_timeout
struct client_data* cli_data
struct client_data
client_data
* cli_data
*
cli_data
{	/*	 * Note that you can't cancel a timeout so we just have to be careful and	 * only do timeout things when the lock looks like its timed out.	 */	if ( cli_data->next_lock <= 0 ) {		return;	}	struct locks* l = cli_data->client_locks + cli_data->next_lock - 1;	if ( ( l->state == WAIT_ANY ) || ( l->state == WAITING ) ) {		// Ignore any timeouts for locks not waiting - those are just left over		// because its expensive to cancel them.		cli_data->next_lock--;		struct timeval now = { 0 };		time_stats( l, wasted_timeout_time );		send_client( cli_data, "TIMEOUT\n" );		decr_stats( waiting_workers );		remove_client_lock( l, 0 );	}}
if ( cli_data->next_lock <= 0 ) {		return;	}
cli_data->next_lock <= 0
cli_data->next_lock
cli_data
cli_data
next_lock
0
{		return;	}
return;
struct locks* l = cli_data->client_locks + cli_data->next_lock - 1;
struct locks* l = cli_data->client_locks + cli_data->next_lock - 1;
struct locks
locks
* l = cli_data->client_locks + cli_data->next_lock - 1
*
l
= cli_data->client_locks + cli_data->next_lock - 1
cli_data->client_locks + cli_data->next_lock - 1
cli_data->client_locks + cli_data->next_lock
cli_data->client_locks
cli_data
cli_data
client_locks
cli_data->next_lock
cli_data
cli_data
next_lock
1
if ( ( l->state == WAIT_ANY ) || ( l->state == WAITING ) ) {		// Ignore any timeouts for locks not waiting - those are just left over		// because its expensive to cancel them.		cli_data->next_lock--;		struct timeval now = { 0 };		time_stats( l, wasted_timeout_time );		send_client( cli_data, "TIMEOUT\n" );		decr_stats( waiting_workers );		remove_client_lock( l, 0 );	}
( l->state == WAIT_ANY ) || ( l->state == WAITING )
( l->state == WAIT_ANY )
l->state == WAIT_ANY
l->state
l
l
state
WAIT_ANY
WAIT_ANY
( l->state == WAITING )
l->state == WAITING
l->state
l
l
state
WAITING
WAITING
{		// Ignore any timeouts for locks not waiting - those are just left over		// because its expensive to cancel them.		cli_data->next_lock--;		struct timeval now = { 0 };		time_stats( l, wasted_timeout_time );		send_client( cli_data, "TIMEOUT\n" );		decr_stats( waiting_workers );		remove_client_lock( l, 0 );	}
cli_data->next_lock--;
cli_data->next_lock--
cli_data->next_lock
cli_data
cli_data
next_lock
struct timeval now = { 0 };
struct timeval now = { 0 };
struct timeval
timeval
now = { 0 }
now
= { 0 }
{ 0 }
0
time_stats( l, wasted_timeout_time );
time_stats( l, wasted_timeout_time )
time_stats
time_stats
l
l
wasted_timeout_time
wasted_timeout_time
send_client( cli_data, "TIMEOUT\n" );
send_client( cli_data, "TIMEOUT\n" )
send_client
send_client
cli_data
cli_data
"TIMEOUT\n"
decr_stats( waiting_workers );
decr_stats( waiting_workers );
decr_stats
decr_stats
( waiting_workers )
waiting_workers
waiting_workers
remove_client_lock( l, 0 );
remove_client_lock( l, 0 )
remove_client_lock
remove_client_lock
l
l
0
-----joern-----
(17,8,0)
(28,18,0)
(26,50,0)
(49,4,0)
(27,7,0)
(44,27,0)
(34,49,0)
(44,11,0)
(28,30,0)
(4,47,0)
(3,10,0)
(20,36,0)
(32,11,0)
(45,47,0)
(4,20,0)
(8,18,0)
(13,10,0)
(51,36,0)
(19,50,0)
(24,7,0)
(50,7,0)
(40,25,0)
(42,11,0)
(6,24,0)
(20,50,0)
(10,37,0)
(48,11,0)
(35,52,0)
(52,11,0)
(30,28,0)
(37,10,0)
(39,49,0)
(30,49,0)
(52,7,0)
(8,4,0)
(48,4,0)
(27,44,0)
(20,4,0)
(29,52,0)
(15,40,0)
(14,11,0)
(2,42,0)
(31,48,0)
(36,20,0)
(41,47,0)
(18,8,0)
(21,47,0)
(23,9,0)
(36,24,0)
(50,20,0)
(53,37,0)
(0,48,0)
(9,11,0)
(16,27,0)
(33,18,0)
(12,9,0)
(5,24,0)
(46,4,0)
(1,8,0)
(9,4,0)
(43,14,0)
(18,28,0)
(10,7,0)
(49,30,0)
(22,30,0)
(24,36,0)
(38,27,0)
(9,4,1)
(22,49,1)
(27,16,1)
(53,10,1)
(9,23,1)
(26,46,1)
(39,34,1)
(50,7,1)
(38,28,1)
(48,0,1)
(36,24,1)
(49,4,1)
(15,9,1)
(12,42,1)
(5,50,1)
(18,33,1)
(15,40,1)
(10,7,1)
(30,49,1)
(44,27,1)
(37,53,1)
(17,4,1)
(27,7,1)
(33,8,1)
(52,7,1)
(15,28,1)
(50,19,1)
(51,24,1)
(14,43,1)
(2,52,1)
(4,20,1)
(43,44,1)
(37,10,1)
(23,12,1)
(10,3,1)
(31,14,1)
(46,37,1)
(3,13,1)
(36,51,1)
(6,5,1)
(28,30,1)
(24,7,1)
(0,31,1)
(35,48,1)
(40,37,1)
(24,6,1)
(29,35,1)
(49,39,1)
(19,26,1)
(30,22,1)
(1,17,1)
(20,36,1)
(8,4,1)
(52,29,1)
(8,1,1)
(34,18,1)
(18,8,1)
(28,18,1)
(16,38,1)
(20,50,1)
(42,2,1)
(48,4,1)
(48,4,2)
(51,37,2)
(4,20,2)
(36,24,2)
(10,7,2)
(39,18,2)
(49,4,2)
(44,27,2)
(31,28,2)
(46,37,2)
(27,28,2)
(9,4,2)
(30,18,2)
(36,37,2)
(44,28,2)
(9,28,2)
(40,37,2)
(0,28,2)
(52,7,2)
(24,37,2)
(1,37,2)
(42,28,2)
(49,18,2)
(20,36,2)
(30,49,2)
(50,7,2)
(26,37,2)
(34,18,2)
(22,18,2)
(2,28,2)
(48,28,2)
(17,37,2)
(16,28,2)
(23,28,2)
(20,37,2)
(6,37,2)
(18,8,2)
(12,28,2)
(52,28,2)
(4,37,2)
(28,37,2)
(37,10,2)
(33,37,2)
(43,28,2)
(19,37,2)
(29,28,2)
(24,7,2)
(5,37,2)
(50,37,2)
(28,18,2)
(28,30,2)
(35,28,2)
(14,28,2)
(15,40,2)
(8,4,2)
(38,28,2)
(18,37,2)
(20,50,2)
(27,7,2)
(8,37,2)
-----------------------------------
(0,wasted_timeout_time)
(1,state)
(2,waiting_workers)
(3,next_lock)
(4,* l = cli_data->client_locks + cli_data->next_lock - 1)
(5,cli_data)
(6,next_lock)
(7,struct client_data* cli_data)
(8,l->state)
(9,remove_client_lock( l, 0 )
(10,cli_data->next_lock)
(11,)
(12,l)
(13,cli_data)
(14,now = { 0 })
(15,RET)
(16,next_lock)
(17,l)
(18,l->state == WAIT_ANY)
(19,client_locks)
(20,cli_data->client_locks + cli_data->next_lock - 1)
(21,if ( ( l->state == WAIT_ANY )
(22,WAITING)
(23,0)
(24,cli_data->next_lock)
(25,)
(26,cli_data)
(27,cli_data->next_lock)
(28,( l->state == WAIT_ANY )
(29,"TIMEOUT\\n")
(30,l->state == WAITING)
(31,l)
(32,now)
(33,WAIT_ANY)
(34,l)
(35,cli_data)
(36,cli_data->next_lock - 1)
(37,cli_data->next_lock <= 0)
(38,cli_data)
(39,state)
(40,return;)
(41,if ( cli_data->next_lock <= 0 )
(42,decr_stats( waiting_workers )
(43,now)
(44,cli_data->next_lock--)
(45,l)
(46,l)
(47,)
(48,time_stats( l, wasted_timeout_time )
(49,l->state)
(50,cli_data->client_locks)
(51,1)
(52,send_client( cli_data, "TIMEOUT\\n" )
(53,0)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^