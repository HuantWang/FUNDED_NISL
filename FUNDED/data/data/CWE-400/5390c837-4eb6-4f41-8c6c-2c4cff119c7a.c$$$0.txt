-----label-----
1
-----code-----
int rename_ref(const char *oldrefname, const char *newrefname, const char *logmsg)
{
	unsigned char sha1[20], orig_sha1[20];
	int flag = 0, logmoved = 0;
	struct ref_lock *lock;
	struct stat loginfo;
	int log = !lstat(git_path("logs/%s", oldrefname), &loginfo);
	const char *symref = NULL;

	if (log && S_ISLNK(loginfo.st_mode))
		return error("reflog for %s is a symlink", oldrefname);

	symref = resolve_ref_unsafe(oldrefname, RESOLVE_REF_READING,
				    orig_sha1, &flag);
	if (flag & REF_ISSYMREF)
		return error("refname %s is a symbolic ref, renaming it is not supported",
			oldrefname);
	if (!symref)
		return error("refname %s not found", oldrefname);

	if (!rename_ref_available(oldrefname, newrefname))
		return 1;

	if (log && rename(git_path("logs/%s", oldrefname), git_path(TMP_RENAMED_LOG)))
		return error("unable to move logfile logs/%s to "TMP_RENAMED_LOG": %s",
			oldrefname, strerror(errno));

	if (delete_ref(oldrefname, orig_sha1, REF_NODEREF)) {
		error("unable to delete old %s", oldrefname);
		goto rollback;
	}

	if (!read_ref_full(newrefname, RESOLVE_REF_READING, sha1, NULL) &&
	    delete_ref(newrefname, sha1, REF_NODEREF)) {
		if (errno==EISDIR) {
			if (remove_empty_directories(git_path("%s", newrefname))) {
				error("Directory not empty: %s", newrefname);
				goto rollback;
			}
		} else {
			error("unable to delete existing %s", newrefname);
			goto rollback;
		}
	}

	if (log && rename_tmp_log(newrefname))
		goto rollback;

	logmoved = log;

	lock = lock_ref_sha1_basic(newrefname, NULL, NULL, 0, NULL);
	if (!lock) {
		error("unable to lock %s for update", newrefname);
		goto rollback;
	}
	hashcpy(lock->old_sha1, orig_sha1);

	if (write_ref_to_lockfile(lock, orig_sha1) ||
	    commit_ref_update(lock, orig_sha1, logmsg)) {
		error("unable to write current sha1 into %s", newrefname);
		goto rollback;
	}

	return 0;

 rollback:
	lock = lock_ref_sha1_basic(oldrefname, NULL, NULL, 0, NULL);
	if (!lock) {
		error("unable to lock %s for rollback", oldrefname);
		goto rollbacklog;
	}

	flag = log_all_ref_updates;
	log_all_ref_updates = 0;
	if (write_ref_to_lockfile(lock, orig_sha1) ||
	    commit_ref_update(lock, orig_sha1, NULL))
		error("unable to write current sha1 into %s", oldrefname);
	log_all_ref_updates = flag;

 rollbacklog:
	if (logmoved && rename(git_path("logs/%s", newrefname), git_path("logs/%s", oldrefname)))
		error("unable to restore logfile %s from %s: %s",
			oldrefname, newrefname, strerror(errno));
	if (!logmoved && log &&
	    rename(git_path(TMP_RENAMED_LOG), git_path("logs/%s", oldrefname)))
		error("unable to restore logfile %s from "TMP_RENAMED_LOG": %s",
			oldrefname, strerror(errno));

	return 1;
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
3,7
5,6
5,7
7,8
7,9
10,11
10,12
12,13
12,14
15,16
15,17
17,18
17,19
20,21
20,22
20,23
20,24
20,25
20,26
20,27
20,28
20,29
20,30
20,31
20,32
20,33
20,34
20,35
20,36
20,37
20,38
20,39
20,40
20,41
20,42
20,43
20,44
20,45
20,46
20,47
20,48
20,49
20,50
21,22
22,23
22,24
22,25
24,25
24,26
26,27
28,29
28,30
30,31
32,33
33,34
33,35
33,36
35,36
35,37
37,38
39,40
39,41
41,42
43,44
44,45
44,46
45,46
47,48
47,49
50,51
51,52
51,53
52,53
54,55
56,57
57,58
57,59
59,60
59,61
61,62
62,63
63,64
63,65
63,66
64,65
66,67
66,68
66,69
67,68
70,71
72,73
73,74
75,76
76,77
76,78
78,79
78,80
78,81
81,82
82,83
84,85
84,86
85,86
85,87
86,87
88,89
88,90
89,90
91,92
91,93
92,93
95,96
96,97
96,98
96,99
97,98
100,101
102,103
103,104
103,105
104,105
106,107
106,108
106,109
106,110
106,111
107,108
109,110
111,112
113,114
115,116
116,117
118,119
118,120
119,120
119,121
120,121
122,123
124,125
125,126
125,127
125,128
126,127
129,130
131,132
131,133
132,133
133,134
135,136
136,137
136,138
136,139
137,138
140,141
142,143
142,144
143,144
144,145
144,146
144,147
145,146
147,148
149,150
151,152
153,154
154,155
154,156
155,156
155,157
155,158
155,159
156,157
158,159
160,161
162,163
164,165
164,166
165,166
166,167
166,168
166,169
167,168
170,171
172,173
174,175
174,176
175,176
175,177
176,177
177,178
177,179
177,180
177,181
177,182
178,179
180,181
182,183
184,185
186,187
188,189
188,190
188,191
188,192
189,190
191,192
193,194
195,196
197,198
198,199
198,200
198,201
199,200
199,201
200,201
202,203
204,205
205,206
205,207
206,207
206,208
207,208
209,210
209,211
209,212
210,211
213,214
215,216
215,217
216,217
217,218
217,219
217,220
218,219
221,222
223,224
225,226
225,227
226,227
227,228
227,229
227,230
228,229
231,232
233,234
235,236
235,237
236,237
236,238
237,238
239,240
239,241
240,241
242,243
244,245
246,247
247,248
247,249
248,249
250,251
252,253
253,254
253,255
254,255
256,257
256,258
256,259
256,260
256,261
256,262
257,258
259,260
261,262
263,264
266,267
268,269
268,270
269,270
270,271
272,273
272,274
273,274
274,275
274,276
274,277
275,276
278,279
280,281
282,283
283,284
283,285
283,286
284,285
286,287
286,288
287,288
290,291
292,293
292,294
293,294
293,295
294,295
294,296
294,297
295,296
297,298
299,300
301,302
301,303
301,304
301,305
302,303
304,305
306,307
308,309
310,311
310,312
311,312
312,313
312,314
312,315
313,314
316,317
318,319
320,321
322,323
322,324
324,325
325,326
325,327
326,327
328,329
328,330
328,331
328,332
328,333
328,334
329,330
331,332
333,334
335,336
338,339
340,341
340,342
341,342
342,343
344,345
344,346
345,346
346,347
346,348
346,349
347,348
350,351
352,353
354,355
355,356
355,357
356,357
358,359
360,361
361,362
361,363
362,363
365,366
365,367
366,367
366,368
367,368
367,369
367,370
368,369
370,371
372,373
374,375
374,376
374,377
374,378
375,376
377,378
379,380
381,382
383,384
384,385
384,386
384,387
385,386
388,389
390,391
391,392
391,393
392,393
394,395
396,397
396,398
398,399
398,400
399,400
399,401
400,401
402,403
402,404
402,405
403,404
405,406
405,407
405,408
406,407
409,410
411,412
411,413
411,414
412,413
415,416
417,418
418,419
418,420
418,421
418,422
418,423
419,420
422,423
424,425
426,427
426,428
427,428
429,430
431,432
432,433
-----nextToken-----
2,4,6,8,9,11,13,14,16,18,19,23,25,27,29,31,34,36,38,40,42,46,48,49,53,55,58,60,65,68,69,71,74,77,79,80,83,87,90,93,94,98,99,101,105,108,110,112,114,117,121,123,127,128,130,134,138,139,141,146,148,150,152,157,159,161,163,168,169,171,173,179,181,183,185,187,190,192,194,196,201,203,208,211,212,214,219,220,222,224,229,230,232,234,238,241,243,245,249,251,255,258,260,262,264,265,267,271,276,277,279,281,285,288,289,291,296,298,300,303,305,307,309,314,315,317,319,321,323,327,330,332,334,336,337,339,343,348,349,351,353,357,359,363,364,369,371,373,376,378,380,382,386,387,389,393,395,397,401,404,407,408,410,413,414,416,420,421,423,425,428,430,433
-----computeFrom-----
85,86
85,87
103,104
103,105
119,120
119,121
175,176
175,177
199,200
199,201
236,237
236,238
247,248
247,249
253,254
253,255
293,294
293,295
325,326
325,327
355,356
355,357
361,362
361,363
366,367
366,368
391,392
391,393
399,400
399,401
-----guardedBy-----
192,232
410,425
416,423
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;Declarator;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;UnaryExpression;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ReturnStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;ReturnStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ReturnStatement;LiteralExpression;ProblemStatement;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;GotoStatement;Name;IfStatement;BinaryExpression;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;GotoStatement;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;GotoStatement;Name;IfStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;GotoStatement;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;GotoStatement;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;GotoStatement;Name;ReturnStatement;LiteralExpression;LabelStatement;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;GotoStatement;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;LabelStatement;Name;IfStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ProblemStatement;ReturnStatement;LiteralExpression;
-----ast_node-----
int rename_ref(const char *oldrefname, const char *newrefname, const char *logmsg){	unsigned char sha1[20], orig_sha1[20];	int flag = 0, logmoved = 0;	struct ref_lock *lock;	struct stat loginfo;	int log = !lstat(git_path("logs/%s", oldrefname), &loginfo);	const char *symref = NULL;	if (log && S_ISLNK(loginfo.st_mode))		return error("reflog for %s is a symlink", oldrefname);	symref = resolve_ref_unsafe(oldrefname, RESOLVE_REF_READING,				    orig_sha1, &flag);	if (flag & REF_ISSYMREF)		return error("refname %s is a symbolic ref, renaming it is not supported",			oldrefname);	if (!symref)		return error("refname %s not found", oldrefname);	if (!rename_ref_available(oldrefname, newrefname))		return 1;	if (log && rename(git_path("logs/%s", oldrefname), git_path(TMP_RENAMED_LOG)))		return error("unable to move logfile logs/%s to "TMP_RENAMED_LOG": %s",			oldrefname, strerror(errno));	if (delete_ref(oldrefname, orig_sha1, REF_NODEREF)) {		error("unable to delete old %s", oldrefname);		goto rollback;	}	if (!read_ref_full(newrefname, RESOLVE_REF_READING, sha1, NULL) &&	    delete_ref(newrefname, sha1, REF_NODEREF)) {		if (errno==EISDIR) {			if (remove_empty_directories(git_path("%s", newrefname))) {				error("Directory not empty: %s", newrefname);				goto rollback;			}		} else {			error("unable to delete existing %s", newrefname);			goto rollback;		}	}	if (log && rename_tmp_log(newrefname))		goto rollback;	logmoved = log;	lock = lock_ref_sha1_basic(newrefname, NULL, NULL, 0, NULL);	if (!lock) {		error("unable to lock %s for update", newrefname);		goto rollback;	}	hashcpy(lock->old_sha1, orig_sha1);	if (write_ref_to_lockfile(lock, orig_sha1) ||	    commit_ref_update(lock, orig_sha1, logmsg)) {		error("unable to write current sha1 into %s", newrefname);		goto rollback;	}	return 0; rollback:	lock = lock_ref_sha1_basic(oldrefname, NULL, NULL, 0, NULL);	if (!lock) {		error("unable to lock %s for rollback", oldrefname);		goto rollbacklog;	}	flag = log_all_ref_updates;	log_all_ref_updates = 0;	if (write_ref_to_lockfile(lock, orig_sha1) ||	    commit_ref_update(lock, orig_sha1, NULL))		error("unable to write current sha1 into %s", oldrefname);	log_all_ref_updates = flag; rollbacklog:	if (logmoved && rename(git_path("logs/%s", newrefname), git_path("logs/%s", oldrefname)))		error("unable to restore logfile %s from %s: %s",			oldrefname, newrefname, strerror(errno));	if (!logmoved && log &&	    rename(git_path(TMP_RENAMED_LOG), git_path("logs/%s", oldrefname)))		error("unable to restore logfile %s from "TMP_RENAMED_LOG": %s",			oldrefname, strerror(errno));	return 1;}
int
rename_ref(const char *oldrefname, const char *newrefname, const char *logmsg)
rename_ref
const char *oldrefname
const char
*oldrefname
*
oldrefname
const char *newrefname
const char
*newrefname
*
newrefname
const char *logmsg
const char
*logmsg
*
logmsg
{	unsigned char sha1[20], orig_sha1[20];	int flag = 0, logmoved = 0;	struct ref_lock *lock;	struct stat loginfo;	int log = !lstat(git_path("logs/%s", oldrefname), &loginfo);	const char *symref = NULL;	if (log && S_ISLNK(loginfo.st_mode))		return error("reflog for %s is a symlink", oldrefname);	symref = resolve_ref_unsafe(oldrefname, RESOLVE_REF_READING,				    orig_sha1, &flag);	if (flag & REF_ISSYMREF)		return error("refname %s is a symbolic ref, renaming it is not supported",			oldrefname);	if (!symref)		return error("refname %s not found", oldrefname);	if (!rename_ref_available(oldrefname, newrefname))		return 1;	if (log && rename(git_path("logs/%s", oldrefname), git_path(TMP_RENAMED_LOG)))		return error("unable to move logfile logs/%s to "TMP_RENAMED_LOG": %s",			oldrefname, strerror(errno));	if (delete_ref(oldrefname, orig_sha1, REF_NODEREF)) {		error("unable to delete old %s", oldrefname);		goto rollback;	}	if (!read_ref_full(newrefname, RESOLVE_REF_READING, sha1, NULL) &&	    delete_ref(newrefname, sha1, REF_NODEREF)) {		if (errno==EISDIR) {			if (remove_empty_directories(git_path("%s", newrefname))) {				error("Directory not empty: %s", newrefname);				goto rollback;			}		} else {			error("unable to delete existing %s", newrefname);			goto rollback;		}	}	if (log && rename_tmp_log(newrefname))		goto rollback;	logmoved = log;	lock = lock_ref_sha1_basic(newrefname, NULL, NULL, 0, NULL);	if (!lock) {		error("unable to lock %s for update", newrefname);		goto rollback;	}	hashcpy(lock->old_sha1, orig_sha1);	if (write_ref_to_lockfile(lock, orig_sha1) ||	    commit_ref_update(lock, orig_sha1, logmsg)) {		error("unable to write current sha1 into %s", newrefname);		goto rollback;	}	return 0; rollback:	lock = lock_ref_sha1_basic(oldrefname, NULL, NULL, 0, NULL);	if (!lock) {		error("unable to lock %s for rollback", oldrefname);		goto rollbacklog;	}	flag = log_all_ref_updates;	log_all_ref_updates = 0;	if (write_ref_to_lockfile(lock, orig_sha1) ||	    commit_ref_update(lock, orig_sha1, NULL))		error("unable to write current sha1 into %s", oldrefname);	log_all_ref_updates = flag; rollbacklog:	if (logmoved && rename(git_path("logs/%s", newrefname), git_path("logs/%s", oldrefname)))		error("unable to restore logfile %s from %s: %s",			oldrefname, newrefname, strerror(errno));	if (!logmoved && log &&	    rename(git_path(TMP_RENAMED_LOG), git_path("logs/%s", oldrefname)))		error("unable to restore logfile %s from "TMP_RENAMED_LOG": %s",			oldrefname, strerror(errno));	return 1;}
unsigned char sha1[20], orig_sha1[20];
unsigned char sha1[20], orig_sha1[20];
unsigned char
sha1[20]
sha1
[20]
20
orig_sha1[20]
orig_sha1
[20]
20
int flag = 0, logmoved = 0;
int flag = 0, logmoved = 0;
int
flag = 0
flag
= 0
0
logmoved = 0
logmoved
= 0
0
struct ref_lock *lock;
struct ref_lock *lock;
struct ref_lock
ref_lock
*lock
*
lock
struct stat loginfo;
struct stat loginfo;
struct stat
stat
loginfo
loginfo
int log = !lstat(git_path("logs/%s", oldrefname), &loginfo);
int log = !lstat(git_path("logs/%s", oldrefname), &loginfo);
int
log = !lstat(git_path("logs/%s", oldrefname), &loginfo)
log
= !lstat(git_path("logs/%s", oldrefname), &loginfo)
!lstat(git_path("logs/%s", oldrefname), &loginfo)
lstat(git_path("logs/%s", oldrefname), &loginfo)
lstat
lstat
git_path("logs/%s", oldrefname)
git_path
git_path
"logs/%s"
oldrefname
oldrefname
&loginfo
loginfo
loginfo
const char *symref = NULL;
const char *symref = NULL;
const char
*symref = NULL
*
symref
= NULL
NULL
NULL
if (log && S_ISLNK(loginfo.st_mode))		return error("reflog for %s is a symlink", oldrefname);
log && S_ISLNK(loginfo.st_mode)
log
log
S_ISLNK(loginfo.st_mode)
S_ISLNK
S_ISLNK
loginfo.st_mode
loginfo
loginfo
st_mode
return error("reflog for %s is a symlink", oldrefname);
error("reflog for %s is a symlink", oldrefname)
error
error
"reflog for %s is a symlink"
oldrefname
oldrefname
symref = resolve_ref_unsafe(oldrefname, RESOLVE_REF_READING,				    orig_sha1, &flag);
symref = resolve_ref_unsafe(oldrefname, RESOLVE_REF_READING,				    orig_sha1, &flag)
symref
symref
resolve_ref_unsafe(oldrefname, RESOLVE_REF_READING,				    orig_sha1, &flag)
resolve_ref_unsafe
resolve_ref_unsafe
oldrefname
oldrefname
RESOLVE_REF_READING
RESOLVE_REF_READING
orig_sha1
orig_sha1
&flag
flag
flag
if (flag & REF_ISSYMREF)		return error("refname %s is a symbolic ref, renaming it is not supported",			oldrefname);
flag & REF_ISSYMREF
flag
flag
REF_ISSYMREF
REF_ISSYMREF
return error("refname %s is a symbolic ref, renaming it is not supported",			oldrefname);
error("refname %s is a symbolic ref, renaming it is not supported",			oldrefname)
error
error
"refname %s is a symbolic ref, renaming it is not supported"
oldrefname
oldrefname
if (!symref)		return error("refname %s not found", oldrefname);
!symref
symref
symref
return error("refname %s not found", oldrefname);
error("refname %s not found", oldrefname)
error
error
"refname %s not found"
oldrefname
oldrefname
if (!rename_ref_available(oldrefname, newrefname))		return 1;
!rename_ref_available(oldrefname, newrefname)
rename_ref_available(oldrefname, newrefname)
rename_ref_available
rename_ref_available
oldrefname
oldrefname
newrefname
newrefname
return 1;
1
if (log && rename(git_path("logs/%s", oldrefname), git_path(TMP_RENAMED_LOG)))		return error("unable to move logfile logs/%s to "TMP_RENAMED_LOG": %s",			oldrefname, strerror(errno));
if (delete_ref(oldrefname, orig_sha1, REF_NODEREF)) {		error("unable to delete old %s", oldrefname);		goto rollback;	}
delete_ref(oldrefname, orig_sha1, REF_NODEREF)
delete_ref
delete_ref
oldrefname
oldrefname
orig_sha1
orig_sha1
REF_NODEREF
REF_NODEREF
{		error("unable to delete old %s", oldrefname);		goto rollback;	}
error("unable to delete old %s", oldrefname);
error("unable to delete old %s", oldrefname)
error
error
"unable to delete old %s"
oldrefname
oldrefname
goto rollback;
rollback
if (!read_ref_full(newrefname, RESOLVE_REF_READING, sha1, NULL) &&	    delete_ref(newrefname, sha1, REF_NODEREF)) {		if (errno==EISDIR) {			if (remove_empty_directories(git_path("%s", newrefname))) {				error("Directory not empty: %s", newrefname);				goto rollback;			}		} else {			error("unable to delete existing %s", newrefname);			goto rollback;		}	}
!read_ref_full(newrefname, RESOLVE_REF_READING, sha1, NULL) &&	    delete_ref(newrefname, sha1, REF_NODEREF)
!read_ref_full(newrefname, RESOLVE_REF_READING, sha1, NULL)
read_ref_full(newrefname, RESOLVE_REF_READING, sha1, NULL)
read_ref_full
read_ref_full
newrefname
newrefname
RESOLVE_REF_READING
RESOLVE_REF_READING
sha1
sha1
NULL
NULL
delete_ref(newrefname, sha1, REF_NODEREF)
delete_ref
delete_ref
newrefname
newrefname
sha1
sha1
REF_NODEREF
REF_NODEREF
{		if (errno==EISDIR) {			if (remove_empty_directories(git_path("%s", newrefname))) {				error("Directory not empty: %s", newrefname);				goto rollback;			}		} else {			error("unable to delete existing %s", newrefname);			goto rollback;		}	}
if (errno==EISDIR) {			if (remove_empty_directories(git_path("%s", newrefname))) {				error("Directory not empty: %s", newrefname);				goto rollback;			}		} else {			error("unable to delete existing %s", newrefname);			goto rollback;		}
errno==EISDIR
errno
errno
EISDIR
EISDIR
{			if (remove_empty_directories(git_path("%s", newrefname))) {				error("Directory not empty: %s", newrefname);				goto rollback;			}		}
if (remove_empty_directories(git_path("%s", newrefname))) {				error("Directory not empty: %s", newrefname);				goto rollback;			}
remove_empty_directories(git_path("%s", newrefname))
remove_empty_directories
remove_empty_directories
git_path("%s", newrefname)
git_path
git_path
"%s"
newrefname
newrefname
{				error("Directory not empty: %s", newrefname);				goto rollback;			}
error("Directory not empty: %s", newrefname);
error("Directory not empty: %s", newrefname)
error
error
"Directory not empty: %s"
newrefname
newrefname
goto rollback;
rollback
{			error("unable to delete existing %s", newrefname);			goto rollback;		}
error("unable to delete existing %s", newrefname);
error("unable to delete existing %s", newrefname)
error
error
"unable to delete existing %s"
newrefname
newrefname
goto rollback;
rollback
if (log && rename_tmp_log(newrefname))		goto rollback;
log && rename_tmp_log(newrefname)
log
log
rename_tmp_log(newrefname)
rename_tmp_log
rename_tmp_log
newrefname
newrefname
goto rollback;
rollback
logmoved = log;
logmoved = log
logmoved
logmoved
log
log
lock = lock_ref_sha1_basic(newrefname, NULL, NULL, 0, NULL);
lock = lock_ref_sha1_basic(newrefname, NULL, NULL, 0, NULL)
lock
lock
lock_ref_sha1_basic(newrefname, NULL, NULL, 0, NULL)
lock_ref_sha1_basic
lock_ref_sha1_basic
newrefname
newrefname
NULL
NULL
NULL
NULL
0
NULL
NULL
if (!lock) {		error("unable to lock %s for update", newrefname);		goto rollback;	}
!lock
lock
lock
{		error("unable to lock %s for update", newrefname);		goto rollback;	}
error("unable to lock %s for update", newrefname);
error("unable to lock %s for update", newrefname)
error
error
"unable to lock %s for update"
newrefname
newrefname
goto rollback;
rollback
hashcpy(lock->old_sha1, orig_sha1);
hashcpy(lock->old_sha1, orig_sha1)
hashcpy
hashcpy
lock->old_sha1
lock
lock
old_sha1
orig_sha1
orig_sha1
if (write_ref_to_lockfile(lock, orig_sha1) ||	    commit_ref_update(lock, orig_sha1, logmsg)) {		error("unable to write current sha1 into %s", newrefname);		goto rollback;	}
write_ref_to_lockfile(lock, orig_sha1) ||	    commit_ref_update(lock, orig_sha1, logmsg)
write_ref_to_lockfile(lock, orig_sha1)
write_ref_to_lockfile
write_ref_to_lockfile
lock
lock
orig_sha1
orig_sha1
commit_ref_update(lock, orig_sha1, logmsg)
commit_ref_update
commit_ref_update
lock
lock
orig_sha1
orig_sha1
logmsg
logmsg
{		error("unable to write current sha1 into %s", newrefname);		goto rollback;	}
error("unable to write current sha1 into %s", newrefname);
error("unable to write current sha1 into %s", newrefname)
error
error
"unable to write current sha1 into %s"
newrefname
newrefname
goto rollback;
rollback
return 0;
0
rollback:	lock = lock_ref_sha1_basic(oldrefname, NULL, NULL, 0, NULL);
rollback
lock = lock_ref_sha1_basic(oldrefname, NULL, NULL, 0, NULL);
lock = lock_ref_sha1_basic(oldrefname, NULL, NULL, 0, NULL)
lock
lock
lock_ref_sha1_basic(oldrefname, NULL, NULL, 0, NULL)
lock_ref_sha1_basic
lock_ref_sha1_basic
oldrefname
oldrefname
NULL
NULL
NULL
NULL
0
NULL
NULL
if (!lock) {		error("unable to lock %s for rollback", oldrefname);		goto rollbacklog;	}
!lock
lock
lock
{		error("unable to lock %s for rollback", oldrefname);		goto rollbacklog;	}
error("unable to lock %s for rollback", oldrefname);
error("unable to lock %s for rollback", oldrefname)
error
error
"unable to lock %s for rollback"
oldrefname
oldrefname
goto rollbacklog;
rollbacklog
flag = log_all_ref_updates;
flag = log_all_ref_updates
flag
flag
log_all_ref_updates
log_all_ref_updates
log_all_ref_updates = 0;
log_all_ref_updates = 0
log_all_ref_updates
log_all_ref_updates
0
if (write_ref_to_lockfile(lock, orig_sha1) ||	    commit_ref_update(lock, orig_sha1, NULL))		error("unable to write current sha1 into %s", oldrefname);
write_ref_to_lockfile(lock, orig_sha1) ||	    commit_ref_update(lock, orig_sha1, NULL)
write_ref_to_lockfile(lock, orig_sha1)
write_ref_to_lockfile
write_ref_to_lockfile
lock
lock
orig_sha1
orig_sha1
commit_ref_update(lock, orig_sha1, NULL)
commit_ref_update
commit_ref_update
lock
lock
orig_sha1
orig_sha1
NULL
NULL
error("unable to write current sha1 into %s", oldrefname);
error("unable to write current sha1 into %s", oldrefname)
error
error
"unable to write current sha1 into %s"
oldrefname
oldrefname
log_all_ref_updates = flag;
log_all_ref_updates = flag
log_all_ref_updates
log_all_ref_updates
flag
flag
rollbacklog:	if (logmoved && rename(git_path("logs/%s", newrefname), git_path("logs/%s", oldrefname)))		error("unable to restore logfile %s from %s: %s",			oldrefname, newrefname, strerror(errno));
rollbacklog
if (logmoved && rename(git_path("logs/%s", newrefname), git_path("logs/%s", oldrefname)))		error("unable to restore logfile %s from %s: %s",			oldrefname, newrefname, strerror(errno));
logmoved && rename(git_path("logs/%s", newrefname), git_path("logs/%s", oldrefname))
logmoved
logmoved
rename(git_path("logs/%s", newrefname), git_path("logs/%s", oldrefname))
rename
rename
git_path("logs/%s", newrefname)
git_path
git_path
"logs/%s"
newrefname
newrefname
git_path("logs/%s", oldrefname)
git_path
git_path
"logs/%s"
oldrefname
oldrefname
error("unable to restore logfile %s from %s: %s",			oldrefname, newrefname, strerror(errno));
error("unable to restore logfile %s from %s: %s",			oldrefname, newrefname, strerror(errno))
error
error
"unable to restore logfile %s from %s: %s"
oldrefname
oldrefname
newrefname
newrefname
strerror(errno)
strerror
strerror
errno
errno
if (!logmoved && log &&	    rename(git_path(TMP_RENAMED_LOG), git_path("logs/%s", oldrefname)))		error("unable to restore logfile %s from "TMP_RENAMED_LOG": %s",			oldrefname, strerror(errno));
return 1;
1
-----joern-----
(237,105,0)
(145,114,0)
(73,107,0)
(168,221,0)
(136,109,0)
(225,132,0)
(29,145,0)
(37,80,0)
(237,194,0)
(31,114,0)
(152,107,0)
(90,193,0)
(160,12,0)
(246,152,0)
(161,222,0)
(170,132,0)
(213,211,0)
(57,132,0)
(199,238,0)
(137,200,0)
(116,121,0)
(69,114,0)
(213,214,0)
(49,114,0)
(243,145,0)
(60,248,0)
(9,56,0)
(131,146,0)
(213,126,0)
(93,114,0)
(240,222,0)
(161,229,0)
(14,182,0)
(6,114,0)
(207,236,0)
(236,105,0)
(169,218,0)
(73,1,0)
(240,219,0)
(239,216,0)
(25,229,0)
(56,105,0)
(166,25,0)
(221,38,0)
(213,54,0)
(13,114,0)
(165,114,0)
(162,107,0)
(92,29,0)
(96,83,0)
(208,222,0)
(93,177,0)
(154,141,0)
(64,114,0)
(223,93,0)
(219,20,0)
(191,34,0)
(94,137,0)
(112,105,0)
(215,114,0)
(63,237,0)
(138,202,0)
(20,145,0)
(26,114,0)
(148,114,0)
(104,231,0)
(245,162,0)
(109,222,0)
(85,179,0)
(194,144,0)
(243,229,0)
(236,40,0)
(134,111,0)
(51,114,0)
(92,194,0)
(136,114,0)
(158,51,0)
(106,22,0)
(196,216,0)
(81,29,0)
(135,152,0)
(88,114,0)
(52,54,0)
(55,101,0)
(231,105,0)
(62,173,0)
(190,102,0)
(233,71,0)
(38,221,0)
(129,240,0)
(137,105,0)
(65,103,0)
(24,29,0)
(234,102,0)
(140,78,0)
(155,177,0)
(194,237,0)
(146,222,0)
(149,192,0)
(212,47,0)
(1,162,0)
(152,83,0)
(249,222,0)
(248,202,0)
(229,243,0)
(164,217,0)
(164,185,0)
(95,218,0)
(61,112,0)
(163,136,0)
(213,247,0)
(71,198,0)
(213,42,0)
(74,112,0)
(120,177,0)
(195,32,0)
(107,114,0)
(56,9,0)
(206,224,0)
(32,109,0)
(30,146,0)
(231,108,0)
(210,114,0)
(17,197,0)
(187,9,0)
(113,107,0)
(32,192,0)
(171,114,0)
(71,105,0)
(139,38,0)
(103,222,0)
(176,240,0)
(78,87,0)
(248,114,0)
(46,179,0)
(127,161,0)
(83,152,0)
(220,162,0)
(85,145,0)
(175,162,0)
(157,20,0)
(100,46,0)
(211,114,0)
(177,93,0)
(180,225,0)
(167,168,0)
(20,219,0)
(180,197,0)
(204,56,0)
(98,103,0)
(184,144,0)
(125,113,0)
(101,222,0)
(186,113,0)
(0,108,0)
(228,71,0)
(44,249,0)
(225,180,0)
(28,168,0)
(15,145,0)
(217,111,0)
(185,80,0)
(177,222,0)
(203,161,0)
(123,208,0)
(109,136,0)
(7,163,0)
(144,222,0)
(48,222,0)
(216,218,0)
(164,145,0)
(10,114,0)
(174,137,0)
(224,247,0)
(213,248,0)
(219,121,0)
(235,136,0)
(242,69,0)
(142,113,0)
(80,51,0)
(83,114,0)
(227,197,0)
(72,107,0)
(59,73,0)
(18,114,0)
(79,177,0)
(41,92,0)
(159,43,0)
(193,222,0)
(249,217,0)
(192,114,0)
(185,164,0)
(35,78,0)
(76,177,0)
(121,219,0)
(205,222,0)
(168,93,0)
(89,205,0)
(21,114,0)
(23,114,0)
(80,29,0)
(112,47,0)
(146,30,0)
(216,114,0)
(128,238,0)
(217,164,0)
(117,114,0)
(218,114,0)
(99,113,0)
(182,193,0)
(91,48,0)
(209,231,0)
(219,240,0)
(101,12,0)
(197,180,0)
(38,93,0)
(80,185,0)
(11,118,0)
(188,237,0)
(66,114,0)
(5,48,0)
(201,72,0)
(145,243,0)
(109,32,0)
(67,103,0)
(27,193,0)
(179,46,0)
(4,73,0)
(78,222,0)
(2,38,0)
(229,161,0)
(115,114,0)
(232,197,0)
(241,168,0)
(193,105,0)
(102,222,0)
(48,126,0)
(244,132,0)
(248,216,0)
(144,194,0)
(97,113,0)
(86,193,0)
(118,214,0)
(16,93,0)
(193,182,0)
(8,16,0)
(146,105,0)
(36,114,0)
(150,211,0)
(110,107,0)
(130,177,0)
(1,73,0)
(181,205,0)
(33,192,0)
(122,109,0)
(217,249,0)
(77,109,0)
(162,1,0)
(40,236,0)
(173,48,0)
(119,202,0)
(197,105,0)
(194,92,0)
(124,69,0)
(205,42,0)
(189,236,0)
(58,144,0)
(133,87,0)
(178,198,0)
(53,118,0)
(221,168,0)
(70,114,0)
(9,145,0)
(156,114,0)
(151,224,0)
(50,249,0)
(84,109,0)
(29,114,0)
(229,25,0)
(132,105,0)
(102,22,0)
(202,114,0)
(147,208,0)
(230,114,0)
(107,113,0)
(226,101,0)
(19,85,0)
(68,51,0)
(143,164,0)
(113,105,0)
(118,222,0)
(12,101,0)
(3,34,0)
(111,217,0)
(82,114,0)
(48,173,0)
(132,225,0)
(75,200,0)
(92,51,0)
(179,85,0)
(153,132,0)
(238,192,0)
(39,46,0)
(172,146,0)
(224,222,0)
(162,45,0)
(2,139,1)
(33,149,1)
(91,5,1)
(69,124,1)
(15,51,1)
(233,34,1)
(211,150,1)
(0,231,1)
(128,136,1)
(218,95,1)
(242,145,1)
(240,222,1)
(5,20,1)
(40,236,1)
(9,145,1)
(35,103,1)
(75,137,1)
(145,243,1)
(206,151,1)
(162,175,1)
(137,105,1)
(190,234,1)
(72,201,1)
(217,111,1)
(9,56,1)
(161,203,1)
(164,143,1)
(59,4,1)
(185,80,1)
(20,145,1)
(168,93,1)
(73,107,1)
(37,92,1)
(191,3,1)
(220,73,1)
(130,155,1)
(188,41,1)
(103,67,1)
(110,29,1)
(214,118,1)
(248,60,1)
(213,126,1)
(205,222,1)
(89,238,1)
(129,176,1)
(223,212,1)
(111,134,1)
(101,12,1)
(135,246,1)
(249,222,1)
(152,107,1)
(85,145,1)
(57,170,1)
(181,89,1)
(205,181,1)
(48,173,1)
(179,46,1)
(122,84,1)
(48,222,1)
(34,191,1)
(138,218,1)
(219,240,1)
(86,27,1)
(229,161,1)
(140,35,1)
(164,217,1)
(232,227,1)
(213,42,1)
(56,105,1)
(58,184,1)
(213,211,1)
(80,51,1)
(94,40,1)
(29,145,1)
(42,205,1)
(161,222,1)
(80,37,1)
(146,131,1)
(30,146,1)
(184,237,1)
(1,73,1)
(28,38,1)
(83,96,1)
(166,161,1)
(118,222,1)
(106,102,1)
(11,85,1)
(248,202,1)
(71,105,1)
(163,7,1)
(134,143,1)
(164,145,1)
(199,128,1)
(104,209,1)
(176,157,1)
(119,138,1)
(194,237,1)
(224,222,1)
(102,222,1)
(50,44,1)
(213,54,1)
(180,225,1)
(236,189,1)
(185,164,1)
(121,116,1)
(144,58,1)
(235,85,1)
(143,80,1)
(113,142,1)
(96,152,1)
(182,14,1)
(20,219,1)
(219,121,1)
(208,222,1)
(32,192,1)
(92,51,1)
(192,33,1)
(85,179,1)
(80,29,1)
(238,199,1)
(208,147,1)
(109,32,1)
(73,59,1)
(177,222,1)
(101,222,1)
(123,221,1)
(155,79,1)
(95,169,1)
(223,0,1)
(225,132,1)
(92,29,1)
(125,110,1)
(158,68,1)
(174,94,1)
(99,186,1)
(12,160,1)
(133,78,1)
(81,9,1)
(170,103,1)
(85,19,1)
(72,107,1)
(202,119,1)
(194,144,1)
(78,140,1)
(203,127,1)
(160,226,1)
(76,130,1)
(52,30,1)
(193,105,1)
(151,163,1)
(46,39,1)
(44,111,1)
(116,240,1)
(74,61,1)
(223,183,1)
(223,75,1)
(137,174,1)
(183,9,1)
(124,242,1)
(24,81,1)
(173,62,1)
(39,100,1)
(20,157,1)
(196,221,1)
(126,48,1)
(9,187,1)
(163,136,1)
(223,133,1)
(189,207,1)
(93,177,1)
(55,185,1)
(247,224,1)
(197,105,1)
(132,105,1)
(41,106,1)
(142,97,1)
(234,16,1)
(238,192,1)
(243,229,1)
(131,172,1)
(177,76,1)
(71,228,1)
(196,208,1)
(248,216,1)
(103,222,1)
(63,188,1)
(223,178,1)
(157,30,1)
(3,180,1)
(7,238,1)
(113,105,1)
(201,107,1)
(172,163,1)
(41,216,1)
(244,153,1)
(146,222,1)
(16,8,1)
(213,214,1)
(84,235,1)
(249,50,1)
(127,15,1)
(162,107,1)
(193,182,1)
(229,25,1)
(186,125,1)
(197,232,1)
(139,202,1)
(53,11,1)
(132,244,1)
(97,99,1)
(241,28,1)
(51,158,1)
(147,123,1)
(38,2,1)
(136,109,1)
(38,93,1)
(144,222,1)
(68,192,1)
(231,105,1)
(240,129,1)
(207,34,1)
(169,16,1)
(37,193,1)
(168,167,1)
(8,93,1)
(226,55,1)
(90,86,1)
(79,120,1)
(175,245,1)
(112,74,1)
(204,187,1)
(212,112,1)
(4,83,1)
(19,69,1)
(1,162,1)
(120,223,1)
(213,247,1)
(150,1,1)
(180,197,1)
(217,249,1)
(100,19,1)
(187,180,1)
(54,52,1)
(32,195,1)
(16,93,1)
(178,71,1)
(60,185,1)
(221,168,1)
(65,98,1)
(83,152,1)
(216,218,1)
(112,105,1)
(27,92,1)
(213,248,1)
(246,72,1)
(78,222,1)
(167,241,1)
(236,105,1)
(245,220,1)
(61,72,1)
(146,105,1)
(237,105,1)
(107,113,1)
(224,206,1)
(109,222,1)
(29,24,1)
(239,196,1)
(118,53,1)
(98,20,1)
(237,63,1)
(67,65,1)
(56,204,1)
(187,40,1)
(228,233,1)
(162,45,1)
(102,190,1)
(92,194,1)
(216,239,1)
(153,57,1)
(17,225,1)
(231,104,1)
(221,38,1)
(209,1,1)
(92,41,1)
(14,90,1)
(227,17,1)
(60,101,1)
(25,166,1)
(62,91,1)
(193,222,1)
(152,135,1)
(77,122,1)
(195,77,1)
(238,192,2)
(93,34,2)
(53,85,2)
(194,144,2)
(239,16,2)
(80,1,2)
(193,222,2)
(241,38,2)
(179,46,2)
(120,72,2)
(225,103,2)
(130,34,2)
(226,185,2)
(248,216,2)
(213,126,2)
(102,222,2)
(185,103,2)
(179,19,2)
(75,40,2)
(79,40,2)
(178,34,2)
(213,248,2)
(174,40,2)
(99,9,2)
(196,16,2)
(170,103,2)
(167,38,2)
(240,222,2)
(146,163,2)
(93,177,2)
(221,16,2)
(109,222,2)
(193,92,2)
(236,34,2)
(199,85,2)
(180,103,2)
(221,168,2)
(176,157,2)
(180,225,2)
(41,34,2)
(83,152,2)
(80,40,2)
(16,72,2)
(214,85,2)
(60,103,2)
(191,180,2)
(175,73,2)
(219,240,2)
(189,34,2)
(249,222,2)
(28,38,2)
(86,92,2)
(80,34,2)
(209,1,2)
(177,222,2)
(8,9,2)
(92,72,2)
(217,111,2)
(223,103,2)
(193,105,2)
(60,9,2)
(32,192,2)
(120,9,2)
(41,40,2)
(111,143,2)
(195,85,2)
(93,9,2)
(169,16,2)
(37,1,2)
(216,218,2)
(40,34,2)
(177,1,2)
(8,72,2)
(140,103,2)
(146,222,2)
(37,9,2)
(41,103,2)
(27,92,2)
(231,1,2)
(223,72,2)
(85,145,2)
(217,143,2)
(48,173,2)
(12,185,2)
(227,225,2)
(112,105,2)
(185,80,2)
(213,211,2)
(247,163,2)
(186,9,2)
(78,222,2)
(219,121,2)
(240,157,2)
(29,145,2)
(216,16,2)
(225,132,2)
(248,40,2)
(145,243,2)
(204,187,2)
(184,41,2)
(37,103,2)
(73,72,2)
(20,145,2)
(248,34,2)
(16,34,2)
(92,103,2)
(95,16,2)
(92,29,2)
(233,34,2)
(112,72,2)
(9,56,2)
(57,103,2)
(38,16,2)
(16,40,2)
(98,20,2)
(50,143,2)
(67,20,2)
(109,32,2)
(35,103,2)
(221,38,2)
(20,219,2)
(231,105,2)
(164,145,2)
(1,72,2)
(182,92,2)
(248,202,2)
(80,29,2)
(208,221,2)
(48,222,2)
(116,157,2)
(137,105,2)
(77,85,2)
(104,1,2)
(151,163,2)
(126,20,2)
(90,92,2)
(80,103,2)
(229,25,2)
(97,9,2)
(220,73,2)
(197,105,2)
(76,9,2)
(177,9,2)
(5,20,2)
(100,19,2)
(146,105,2)
(3,180,2)
(101,12,2)
(78,103,2)
(130,1,2)
(249,143,2)
(14,92,2)
(113,9,2)
(48,20,2)
(205,222,2)
(238,85,2)
(185,34,2)
(107,9,2)
(109,85,2)
(92,51,2)
(173,20,2)
(122,85,2)
(56,105,2)
(161,222,2)
(162,107,2)
(248,1,2)
(60,1,2)
(40,236,2)
(243,229,2)
(202,16,2)
(185,164,2)
(248,103,2)
(76,34,2)
(138,16,2)
(39,19,2)
(208,222,2)
(101,185,2)
(219,157,2)
(160,185,2)
(177,34,2)
(217,249,2)
(42,238,2)
(32,85,2)
(246,72,2)
(144,41,2)
(187,40,2)
(194,41,2)
(248,9,2)
(188,41,2)
(155,9,2)
(92,194,2)
(79,103,2)
(55,185,2)
(56,187,2)
(157,30,2)
(62,20,2)
(136,85,2)
(197,225,2)
(89,238,2)
(118,222,2)
(74,72,2)
(7,238,2)
(213,247,2)
(9,145,2)
(155,72,2)
(120,103,2)
(93,40,2)
(213,42,2)
(58,41,2)
(130,103,2)
(102,16,2)
(172,163,2)
(17,225,2)
(206,163,2)
(177,40,2)
(79,34,2)
(223,40,2)
(60,72,2)
(37,34,2)
(71,105,2)
(177,72,2)
(177,103,2)
(132,105,2)
(211,1,2)
(110,9,2)
(41,9,2)
(9,180,2)
(134,143,2)
(180,197,2)
(131,163,2)
(130,9,2)
(168,93,2)
(113,105,2)
(1,73,2)
(92,1,2)
(20,30,2)
(34,180,2)
(181,238,2)
(128,85,2)
(163,136,2)
(235,85,2)
(183,9,2)
(46,19,2)
(93,1,2)
(152,72,2)
(201,9,2)
(234,16,2)
(85,179,2)
(207,34,2)
(96,72,2)
(155,40,2)
(185,9,2)
(228,34,2)
(8,40,2)
(125,9,2)
(155,103,2)
(79,9,2)
(16,1,2)
(92,40,2)
(237,41,2)
(1,162,2)
(30,163,2)
(213,54,2)
(129,157,2)
(212,72,2)
(91,20,2)
(2,16,2)
(164,80,2)
(155,34,2)
(224,222,2)
(76,103,2)
(155,1,2)
(223,1,2)
(63,41,2)
(60,40,2)
(153,103,2)
(60,34,2)
(84,85,2)
(30,146,2)
(4,72,2)
(72,107,2)
(144,222,2)
(132,103,2)
(119,16,2)
(38,93,2)
(92,34,2)
(81,9,2)
(73,107,2)
(248,72,2)
(92,9,2)
(54,30,2)
(8,103,2)
(190,16,2)
(152,107,2)
(213,214,2)
(236,105,2)
(130,72,2)
(142,9,2)
(120,34,2)
(185,72,2)
(79,72,2)
(106,16,2)
(93,103,2)
(8,34,2)
(187,180,2)
(52,30,2)
(139,16,2)
(16,93,2)
(71,34,2)
(44,143,2)
(223,34,2)
(8,1,2)
(80,72,2)
(29,9,2)
(37,40,2)
(103,222,2)
(137,40,2)
(121,157,2)
(93,72,2)
(244,103,2)
(218,16,2)
(185,1,2)
(143,80,2)
(118,85,2)
(72,9,2)
(130,40,2)
(80,9,2)
(205,238,2)
(162,73,2)
(76,40,2)
(76,72,2)
(194,237,2)
(120,40,2)
(101,222,2)
(80,51,2)
(193,182,2)
(16,103,2)
(229,161,2)
(94,40,2)
(16,9,2)
(185,40,2)
(150,1,2)
(168,38,2)
(135,72,2)
(79,1,2)
(120,1,2)
(223,9,2)
(11,85,2)
(41,1,2)
(123,221,2)
(147,221,2)
(232,225,2)
(245,73,2)
(237,105,2)
(61,72,2)
(133,103,2)
(107,113,2)
(59,72,2)
(24,9,2)
(136,109,2)
(83,72,2)
(41,72,2)
(163,238,2)
(37,72,2)
(103,20,2)
(9,40,2)
(224,163,2)
(0,1,2)
(162,45,2)
(76,1,2)
(65,20,2)
(164,217,2)
-----------------------------------
(0,goto rollback;)
(1,write_ref_to_lockfile(lock, orig_sha1)
(2,orig_sha1)
(3,errno)
(4,lock)
(5,"unable to move logfile logs/%s to "TMP_RENAMED_LOG": %s")
(6,logmoved)
(7,symref)
(8,lock)
(9,log && rename_tmp_log(newrefname)
(10,if (!rename_ref_available(oldrefname, newrefname)
(11,"reflog for %s is a symlink")
(12,strerror(errno)
(13,rollbacklog:)
(14,errno)
(15,log)
(16,!lock)
(17,newrefname)
(18,if (!read_ref_full(newrefname, RESOLVE_REF_READING, sha1, NULL)
(19,log)
(20,log && rename(git_path("logs/%s", oldrefname)
(21,if (!symref)
(22,)
(23,flag)
(24,log)
(25,&loginfo)
(26,loginfo)
(27,"unable to restore logfile %s from %s: %s")
(28,lock)
(29,logmoved = log)
(30,!rename_ref_available(oldrefname, newrefname)
(31,if (delete_ref(oldrefname, orig_sha1, REF_NODEREF)
(32,&flag)
(33,0)
(34,errno==EISDIR)
(35,"unable to delete old %s")
(36,sha1)
(37,logmoved)
(38,write_ref_to_lockfile(lock, orig_sha1)
(39,st_mode)
(40,remove_empty_directories(git_path("%s", newrefname)
(41,logmoved)
(42,return error("refname %s is a symbolic ref, renaming it is not supported",\n\\n\\t\\t\\toldrefname)
(43,)
(44,"logs/%s")
(45,const char *logmsg)
(46,loginfo.st_mode)
(47,)
(48,error("unable to move logfile logs/%s to "TMP_RENAMED_LOG": %s",\n\\n\\t\\t\\toldrefname, strerror(errno)
(49,if (!logmoved && log &&\n\\n\\t    rename(git_path(TMP_RENAMED_LOG)
(50,oldrefname)
(51,logmoved = 0)
(52,1)
(53,oldrefname)
(54,return 1;)
(55,"unable to restore logfile %s from "TMP_RENAMED_LOG": %s")
(56,rename_tmp_log(newrefname)
(57,RESOLVE_REF_READING)
(58,oldrefname)
(59,orig_sha1)
(60,1)
(61,"unable to lock %s for update")
(62,errno)
(63,newrefname)
(64,if (log && rename(git_path("logs/%s", oldrefname)
(65,orig_sha1)
(66,if (flag & REF_ISSYMREF)
(67,REF_NODEREF)
(68,logmoved)
(69,*symref = NULL)
(70,if (write_ref_to_lockfile(lock, orig_sha1)
(71,error("unable to delete existing %s", newrefname)
(72,!lock)
(73,write_ref_to_lockfile(lock, orig_sha1)
(74,newrefname)
(75,goto rollback;)
(76,NULL)
(77,orig_sha1)
(78,error("unable to delete old %s", oldrefname)
(79,NULL)
(80,!logmoved)
(81,logmoved)
(82,if (write_ref_to_lockfile(lock, orig_sha1)
(83,hashcpy(lock->old_sha1, orig_sha1)
(84,oldrefname)
(85,log && S_ISLNK(loginfo.st_mode)
(86,oldrefname)
(87,)
(88,if (logmoved && rename(git_path("logs/%s", newrefname)
(89,"refname %s is a symbolic ref, renaming it is not supported")
(90,newrefname)
(91,oldrefname)
(92,logmoved && rename(git_path("logs/%s", newrefname)
(93,lock = lock_ref_sha1_basic(oldrefname, NULL, NULL, 0, NULL)
(94,"Directory not empty: %s")
(95,log_all_ref_updates)
(96,orig_sha1)
(97,0)
(98,oldrefname)
(99,NULL)
(100,loginfo)
(101,error("unable to restore logfile %s from "TMP_RENAMED_LOG": %s",\n\\n\\t\\t\\toldrefname, strerror(errno)
(102,error("unable to lock %s for rollback", oldrefname)
(103,delete_ref(oldrefname, orig_sha1, REF_NODEREF)
(104,newrefname)
(105,const char *newrefname)
(106,goto rollbacklog;)
(107,lock = lock_ref_sha1_basic(newrefname, NULL, NULL, 0, NULL)
(108,)
(109,resolve_ref_unsafe(oldrefname, RESOLVE_REF_READING,\n\\n\\t\\t\\t\\t    orig_sha1, &flag)
(110,lock)
(111,git_path(TMP_RENAMED_LOG)
(112,error("unable to lock %s for update", newrefname)
(113,lock_ref_sha1_basic(newrefname, NULL, NULL, 0, NULL)
(114,)
(115,lock)
(116,TMP_RENAMED_LOG)
(117,orig_sha1)
(118,error("reflog for %s is a symlink", oldrefname)
(119,0)
(120,oldrefname)
(121,git_path(TMP_RENAMED_LOG)
(122,RESOLVE_REF_READING)
(123,"unable to write current sha1 into %s")
(124,NULL)
(125,newrefname)
(126,return error("unable to move logfile logs/%s to "TMP_RENAMED_LOG": %s",\n\\n\\t\\t\\toldrefname, strerror(errno)
(127,"logs/%s")
(128,flag)
(129,oldrefname)
(130,0)
(131,newrefname)
(132,read_ref_full(newrefname, RESOLVE_REF_READING, sha1, NULL)
(133,goto rollback;)
(134,TMP_RENAMED_LOG)
(135,old_sha1)
(136,symref = resolve_ref_unsafe(oldrefname, RESOLVE_REF_READING,\n\\n\\t\\t\\t\\t    orig_sha1, &flag)
(137,error("Directory not empty: %s", newrefname)
(138,log_all_ref_updates)
(139,lock)
(140,oldrefname)
(141,)
(142,NULL)
(143,log)
(144,git_path("logs/%s", oldrefname)
(145,log = !lstat(git_path("logs/%s", oldrefname)
(146,rename_ref_available(oldrefname, newrefname)
(147,oldrefname)
(148,if (!lock)
(149,flag)
(150,0)
(151,"refname %s not found")
(152,lock->old_sha1)
(153,sha1)
(154,if (remove_empty_directories(git_path("%s", newrefname)
(155,NULL)
(156,symref)
(157,log)
(158,0)
(159,if (errno==EISDIR)
(160,errno)
(161,git_path("logs/%s", oldrefname)
(162,commit_ref_update(lock, orig_sha1, logmsg)
(163,!symref)
(164,log &&\n\\n\\t    rename(git_path(TMP_RENAMED_LOG)
(165,if (log && rename_tmp_log(newrefname)
(166,loginfo)
(167,NULL)
(168,commit_ref_update(lock, orig_sha1, NULL)
(169,flag)
(170,newrefname)
(171,log)
(172,oldrefname)
(173,strerror(errno)
(174,newrefname)
(175,logmsg)
(176,"logs/%s")
(177,lock_ref_sha1_basic(oldrefname, NULL, NULL, 0, NULL)
(178,goto rollback;)
(179,S_ISLNK(loginfo.st_mode)
(180,!read_ref_full(newrefname, RESOLVE_REF_READING, sha1, NULL)
(181,oldrefname)
(182,strerror(errno)
(183,goto rollback;)
(184,"logs/%s")
(185,!logmoved && log &&\n\\n\\t    rename(git_path(TMP_RENAMED_LOG)
(186,NULL)
(187,log)
(188,"logs/%s")
(189,newrefname)
(190,oldrefname)
(191,EISDIR)
(192,flag = 0)
(193,error("unable to restore logfile %s from %s: %s",\n\\n\\t\\t\\toldrefname, newrefname, strerror(errno)
(194,rename(git_path("logs/%s", newrefname)
(195,flag)
(196,log_all_ref_updates)
(197,delete_ref(newrefname, sha1, REF_NODEREF)
(198,)
(199,REF_ISSYMREF)
(200,)
(201,lock)
(202,log_all_ref_updates = 0)
(203,oldrefname)
(204,newrefname)
(205,error("refname %s is a symbolic ref, renaming it is not supported",\n\\n\\t\\t\\toldrefname)
(206,oldrefname)
(207,"%s")
(208,error("unable to write current sha1 into %s", oldrefname)
(209,"unable to write current sha1 into %s")
(210,if (!lock)
(211,return 0;)
(212,goto rollback;)
(213,RET)
(214,return error("reflog for %s is a symlink", oldrefname)
(215,rollback:)
(216,log_all_ref_updates = flag)
(217,rename(git_path(TMP_RENAMED_LOG)
(218,flag = log_all_ref_updates)
(219,rename(git_path("logs/%s", oldrefname)
(220,lock)
(221,write_ref_to_lockfile(lock, orig_sha1)
(222,const char *oldrefname)
(223,lock)
(224,error("refname %s not found", oldrefname)
(225,!read_ref_full(newrefname, RESOLVE_REF_READING, sha1, NULL)
(226,oldrefname)
(227,sha1)
(228,newrefname)
(229,lstat(git_path("logs/%s", oldrefname)
(230,if (log && S_ISLNK(loginfo.st_mode)
(231,error("unable to write current sha1 into %s", newrefname)
(232,REF_NODEREF)
(233,"unable to delete existing %s")
(234,"unable to lock %s for rollback")
(235,symref)
(236,git_path("%s", newrefname)
(237,git_path("logs/%s", newrefname)
(238,flag & REF_ISSYMREF)
(239,flag)
(240,git_path("logs/%s", oldrefname)
(241,orig_sha1)
(242,symref)
(243,!lstat(git_path("logs/%s", oldrefname)
(244,NULL)
(245,orig_sha1)
(246,lock)
(247,return error("refname %s not found", oldrefname)
(248,return 1;)
(249,git_path("logs/%s", oldrefname)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^