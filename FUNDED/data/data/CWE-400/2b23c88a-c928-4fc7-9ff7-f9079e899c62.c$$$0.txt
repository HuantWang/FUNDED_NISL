-----label-----
1
-----code-----
static struct ast_channel *iax2_request(const char *type, struct ast_format_cap *cap, const struct ast_channel *requestor, const char *data, int *cause)
{
	int callno;
	int res;
	struct sockaddr_in sin;
	struct ast_channel *c;
	struct parsed_dial_string pds;
	struct create_addr_info cai;
	char *tmpstr;
	struct ast_callid *callid;

	memset(&pds, 0, sizeof(pds));
	tmpstr = ast_strdupa(data);
	parse_dial_string(tmpstr, &pds);

	callid = ast_read_threadstorage_callid();

	if (ast_strlen_zero(pds.peer)) {
		ast_log(LOG_WARNING, "No peer provided in the IAX2 dial string '%s'\n", data);
		return NULL;
	}
	memset(&cai, 0, sizeof(cai));
	cai.capability = iax2_capability;

	ast_copy_flags64(&cai, &globalflags, IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF | IAX_SENDCONNECTEDLINE | IAX_RECVCONNECTEDLINE);

	/* Populate our address from the given */
	if (create_addr(pds.peer, NULL, &sin, &cai)) {
		*cause = AST_CAUSE_UNREGISTERED;
		return NULL;
	}

	if (pds.port)
		sin.sin_port = htons(atoi(pds.port));

	callno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);
	if (callno < 1) {
		ast_log(LOG_WARNING, "Unable to create call\n");
		*cause = AST_CAUSE_CONGESTION;
		return NULL;
	}

	/* If this is a trunk, update it now */
	ast_copy_flags64(iaxs[callno], &cai, IAX_TRUNK | IAX_SENDANI | IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF | IAX_SENDCONNECTEDLINE | IAX_RECVCONNECTEDLINE);
	if (ast_test_flag64(&cai, IAX_TRUNK)) {
		int new_callno;
		if ((new_callno = make_trunk(callno, 1)) != -1)
			callno = new_callno;
	}
	iaxs[callno]->maxtime = cai.maxtime;
	if (callid) {
		iax_pvt_callid_set(callno, callid);
	}

	if (cai.found) {
		ast_string_field_set(iaxs[callno], host, pds.peer);
	}

	c = ast_iax2_new(callno, AST_STATE_DOWN, cai.capability, requestor ? ast_channel_linkedid(requestor) : NULL);
	ast_mutex_unlock(&iaxsl[callno]);

	if (c) {
		struct ast_format_cap *joint;
		if (callid) {
			ast_channel_callid_set(c, callid);
		}

		/* Choose a format we can live with */
		if ((joint = ast_format_cap_joint(ast_channel_nativeformats(c), cap))) {
			ast_format_cap_copy(ast_channel_nativeformats(c), joint);
			joint = ast_format_cap_destroy(joint);
		} else {
			struct ast_format best_fmt_cap;
			struct ast_format best_fmt_native;
			res = ast_translator_best_choice(cap, ast_channel_nativeformats(c), &best_fmt_cap, &best_fmt_native);
			if (res < 0) {
				char tmp[256];
				char tmp2[256];
				ast_log(LOG_WARNING, "Unable to create translator path for %s to %s on %s\n",
					ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(c)), ast_getformatname_multiple(tmp2, sizeof(tmp2), cap), ast_channel_name(c));
				ast_hangup(c);
				return NULL;
			}
			ast_format_cap_set(ast_channel_nativeformats(c), &best_fmt_native);
		}
		ast_best_codec(ast_channel_nativeformats(c), ast_channel_readformat(c));
		ast_format_copy(ast_channel_writeformat(c), ast_channel_readformat(c));
	}

	if (callid) {
		ast_callid_unref(callid);
	}
	return c;
}
-----children-----
1,2
1,3
1,4
2,3
4,5
4,6
4,7
4,8
4,9
4,10
4,11
7,8
7,9
9,10
9,11
12,13
12,14
13,14
15,16
15,17
18,19
18,20
19,20
21,22
21,23
24,25
24,26
26,27
26,28
29,30
29,31
31,32
31,33
34,35
34,36
34,37
34,38
34,39
34,40
34,41
34,42
34,43
34,44
34,45
34,46
34,47
34,48
34,49
34,50
34,51
34,52
34,53
34,54
34,55
34,56
34,57
34,58
34,59
34,60
34,61
34,62
34,63
34,64
35,36
36,37
36,38
38,39
40,41
41,42
41,43
43,44
45,46
46,47
46,48
47,48
49,50
51,52
52,53
52,54
53,54
55,56
55,57
58,59
59,60
59,61
60,61
62,63
64,65
65,66
65,67
66,67
68,69
70,71
71,72
71,73
73,74
73,75
76,77
77,78
77,79
78,79
80,81
80,82
83,84
84,85
84,86
84,87
84,88
85,86
87,88
88,89
91,92
92,93
93,94
95,96
96,97
96,98
97,98
99,100
99,101
100,101
102,103
104,105
105,106
105,107
105,108
106,107
108,109
110,111
111,112
113,114
114,115
114,116
115,116
117,118
118,119
120,121
120,122
121,122
121,123
122,123
124,125
124,126
125,126
128,129
128,130
129,130
130,131
130,132
130,133
130,134
131,132
133,134
136,137
138,139
139,140
141,142
142,143
142,144
142,145
142,146
143,144
145,146
146,147
149,150
150,151
151,152
153,154
154,155
154,156
155,156
155,157
156,157
159,160
161,162
162,163
162,164
162,165
162,166
163,164
165,166
166,167
168,169
169,170
171,172
171,173
172,173
172,174
173,174
173,175
174,175
174,176
175,176
175,177
176,177
178,179
180,181
182,183
184,185
186,187
188,189
188,190
189,190
189,191
189,192
189,193
189,194
190,191
192,193
192,194
193,194
196,197
198,199
199,200
201,202
202,203
204,205
204,206
205,206
206,207
206,208
207,208
208,209
210,211
212,213
213,214
215,216
215,217
216,217
216,218
217,218
220,221
221,222
221,223
222,223
222,224
223,224
226,227
226,228
227,228
229,230
229,231
230,231
232,233
232,234
233,234
236,237
237,238
237,239
238,239
240,241
240,242
240,243
240,244
240,245
240,246
240,247
241,242
245,246
246,247
248,249
250,251
250,252
251,252
255,256
255,257
256,257
256,258
257,258
260,261
260,262
260,263
261,262
262,263
262,264
262,265
263,264
265,266
268,269
269,270
269,271
270,271
271,272
273,274
275,276
276,277
278,279
279,280
279,281
279,282
279,283
280,281
282,283
282,284
283,284
285,286
287,288
288,289
290,291
290,292
291,292
291,293
292,293
292,294
293,294
293,295
294,295
294,296
295,296
295,297
296,297
296,298
297,298
299,300
301,302
303,304
305,306
307,308
309,310
311,312
313,314
313,315
314,315
314,316
314,317
315,316
317,318
318,319
320,321
322,323
322,324
323,324
324,325
324,326
326,327
328,329
328,330
329,330
329,331
330,331
331,332
331,333
332,333
334,335
334,336
334,337
335,336
337,338
340,341
342,343
343,344
343,345
344,345
346,347
348,349
349,350
349,351
350,351
350,352
351,352
351,353
352,353
354,355
357,358
357,359
358,359
361,362
361,363
362,363
364,365
365,366
366,367
366,368
366,369
367,368
369,370
371,372
373,374
373,375
374,375
374,376
375,376
378,379
379,380
380,381
380,382
380,383
380,384
381,382
383,384
383,385
384,385
386,387
388,389
390,391
390,392
391,392
394,395
395,396
395,397
396,397
398,399
398,400
398,401
398,402
398,403
399,400
401,402
403,404
405,406
405,407
406,407
409,410
409,411
409,412
410,411
412,413
412,414
413,414
415,416
417,418
419,420
420,421
420,422
421,422
423,424
424,425
424,426
424,427
427,428
428,429
430,431
430,432
431,432
433,434
433,435
433,436
433,437
433,438
434,435
435,436
435,437
436,437
438,439
438,440
441,442
441,443
442,443
444,445
445,446
446,447
446,448
446,449
447,448
449,450
451,452
453,454
453,455
453,456
454,455
455,456
455,457
456,457
458,459
458,460
458,461
459,460
461,462
461,463
462,463
464,465
466,467
468,469
468,470
469,470
470,471
470,472
470,473
471,472
473,474
473,475
474,475
476,477
478,479
480,481
481,482
481,483
482,483
484,485
484,486
485,486
487,488
489,490
489,491
489,492
489,493
489,494
490,491
491,492
491,493
492,493
494,495
496,497
497,498
497,499
498,499
500,501
502,503
503,504
503,505
504,505
506,507
506,508
506,509
506,510
506,511
507,508
509,510
511,512
511,513
512,513
514,515
516,517
517,518
519,520
520,521
522,523
522,524
523,524
523,525
524,525
527,528
527,529
527,530
527,531
527,532
528,529
529,530
529,531
531,532
531,533
533,534
535,536
536,537
536,538
538,539
538,540
540,541
542,543
543,544
543,545
543,546
543,547
543,548
543,549
544,545
546,547
549,550
549,551
549,552
549,553
550,551
552,553
554,555
555,556
556,557
558,559
558,560
559,560
561,562
563,564
563,565
563,566
563,567
564,565
566,567
568,569
569,570
570,571
572,573
574,575
574,576
575,576
577,578
579,580
580,581
580,582
581,582
583,584
585,586
586,587
588,589
589,590
589,591
589,592
590,591
592,593
592,594
593,594
595,596
597,598
598,599
600,601
601,602
601,603
601,604
602,603
604,605
604,606
605,606
607,608
609,610
609,611
610,611
612,613
614,615
615,616
615,617
615,618
616,617
618,619
618,620
619,620
621,622
623,624
623,625
624,625
626,627
628,629
628,630
629,630
631,632
632,633
633,634
633,635
634,635
636,637
638,639
639,640
-----nextToken-----
3,5,6,8,10,11,14,16,17,20,22,23,25,27,28,30,32,33,37,39,42,44,48,50,54,56,57,61,63,67,69,72,74,75,79,81,82,86,89,90,94,98,101,103,107,109,112,116,119,123,126,127,132,134,135,137,140,144,147,148,152,157,158,160,164,167,170,177,179,181,183,185,187,191,194,195,197,200,203,209,211,214,218,219,224,225,228,231,234,235,239,242,243,244,247,249,252,253,254,258,259,264,266,267,272,274,277,281,284,286,289,298,300,302,304,306,308,310,312,316,319,321,325,327,333,336,338,339,341,345,347,353,355,356,359,360,363,368,370,372,376,377,382,385,387,389,392,393,397,400,402,404,407,408,411,414,416,418,422,425,426,429,432,437,439,440,443,448,450,452,457,460,463,465,467,472,475,477,479,483,486,488,493,495,499,501,505,508,510,513,515,518,521,525,526,530,532,534,537,539,541,545,547,548,551,553,557,560,562,565,567,571,573,576,578,582,584,587,591,594,596,599,603,606,608,611,613,617,620,622,625,627,630,635,637,640
-----computeFrom-----
96,97
96,98
114,115
114,116
154,155
154,156
171,172
171,173
172,173
172,174
173,174
173,175
174,175
174,176
175,176
175,177
206,207
206,208
221,222
221,223
237,238
237,239
256,257
256,258
269,270
269,271
290,291
290,292
291,292
291,293
292,293
292,294
293,294
293,295
294,295
294,296
295,296
295,297
296,297
296,298
329,330
329,331
331,332
331,333
343,344
343,345
349,350
349,351
395,396
395,397
455,456
455,457
481,482
481,483
503,504
503,505
523,524
523,525
-----guardedBy-----
338,345
333,347
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;ElaboratedTypeSpecifier;Name;FunctionDeclarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;ReturnStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;UnaryExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;IdExpression;Name;IfStatement;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;UnaryExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;UnaryExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;UnaryExpression;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;ConditionalExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ArrayDeclarator;ReferenceOperator;Name;ArrayModifier;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;IdExpression;Name;
-----ast_node-----
static struct ast_channel *iax2_request(const char *type, struct ast_format_cap *cap, const struct ast_channel *requestor, const char *data, int *cause){	int callno;	int res;	struct sockaddr_in sin;	struct ast_channel *c;	struct parsed_dial_string pds;	struct create_addr_info cai;	char *tmpstr;	struct ast_callid *callid;	memset(&pds, 0, sizeof(pds));	tmpstr = ast_strdupa(data);	parse_dial_string(tmpstr, &pds);	callid = ast_read_threadstorage_callid();	if (ast_strlen_zero(pds.peer)) {		ast_log(LOG_WARNING, "No peer provided in the IAX2 dial string '%s'\n", data);		return NULL;	}	memset(&cai, 0, sizeof(cai));	cai.capability = iax2_capability;	ast_copy_flags64(&cai, &globalflags, IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF | IAX_SENDCONNECTEDLINE | IAX_RECVCONNECTEDLINE);	/* Populate our address from the given */	if (create_addr(pds.peer, NULL, &sin, &cai)) {		*cause = AST_CAUSE_UNREGISTERED;		return NULL;	}	if (pds.port)		sin.sin_port = htons(atoi(pds.port));	callno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);	if (callno < 1) {		ast_log(LOG_WARNING, "Unable to create call\n");		*cause = AST_CAUSE_CONGESTION;		return NULL;	}	/* If this is a trunk, update it now */	ast_copy_flags64(iaxs[callno], &cai, IAX_TRUNK | IAX_SENDANI | IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF | IAX_SENDCONNECTEDLINE | IAX_RECVCONNECTEDLINE);	if (ast_test_flag64(&cai, IAX_TRUNK)) {		int new_callno;		if ((new_callno = make_trunk(callno, 1)) != -1)			callno = new_callno;	}	iaxs[callno]->maxtime = cai.maxtime;	if (callid) {		iax_pvt_callid_set(callno, callid);	}	if (cai.found) {		ast_string_field_set(iaxs[callno], host, pds.peer);	}	c = ast_iax2_new(callno, AST_STATE_DOWN, cai.capability, requestor ? ast_channel_linkedid(requestor) : NULL);	ast_mutex_unlock(&iaxsl[callno]);	if (c) {		struct ast_format_cap *joint;		if (callid) {			ast_channel_callid_set(c, callid);		}		/* Choose a format we can live with */		if ((joint = ast_format_cap_joint(ast_channel_nativeformats(c), cap))) {			ast_format_cap_copy(ast_channel_nativeformats(c), joint);			joint = ast_format_cap_destroy(joint);		} else {			struct ast_format best_fmt_cap;			struct ast_format best_fmt_native;			res = ast_translator_best_choice(cap, ast_channel_nativeformats(c), &best_fmt_cap, &best_fmt_native);			if (res < 0) {				char tmp[256];				char tmp2[256];				ast_log(LOG_WARNING, "Unable to create translator path for %s to %s on %s\n",					ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(c)), ast_getformatname_multiple(tmp2, sizeof(tmp2), cap), ast_channel_name(c));				ast_hangup(c);				return NULL;			}			ast_format_cap_set(ast_channel_nativeformats(c), &best_fmt_native);		}		ast_best_codec(ast_channel_nativeformats(c), ast_channel_readformat(c));		ast_format_copy(ast_channel_writeformat(c), ast_channel_readformat(c));	}	if (callid) {		ast_callid_unref(callid);	}	return c;}
static struct ast_channel
ast_channel
*iax2_request(const char *type, struct ast_format_cap *cap, const struct ast_channel *requestor, const char *data, int *cause)
*
iax2_request
const char *type
const char
*type
*
type
struct ast_format_cap *cap
struct ast_format_cap
ast_format_cap
*cap
*
cap
const struct ast_channel *requestor
const struct ast_channel
ast_channel
*requestor
*
requestor
const char *data
const char
*data
*
data
int *cause
int
*cause
*
cause
{	int callno;	int res;	struct sockaddr_in sin;	struct ast_channel *c;	struct parsed_dial_string pds;	struct create_addr_info cai;	char *tmpstr;	struct ast_callid *callid;	memset(&pds, 0, sizeof(pds));	tmpstr = ast_strdupa(data);	parse_dial_string(tmpstr, &pds);	callid = ast_read_threadstorage_callid();	if (ast_strlen_zero(pds.peer)) {		ast_log(LOG_WARNING, "No peer provided in the IAX2 dial string '%s'\n", data);		return NULL;	}	memset(&cai, 0, sizeof(cai));	cai.capability = iax2_capability;	ast_copy_flags64(&cai, &globalflags, IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF | IAX_SENDCONNECTEDLINE | IAX_RECVCONNECTEDLINE);	/* Populate our address from the given */	if (create_addr(pds.peer, NULL, &sin, &cai)) {		*cause = AST_CAUSE_UNREGISTERED;		return NULL;	}	if (pds.port)		sin.sin_port = htons(atoi(pds.port));	callno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);	if (callno < 1) {		ast_log(LOG_WARNING, "Unable to create call\n");		*cause = AST_CAUSE_CONGESTION;		return NULL;	}	/* If this is a trunk, update it now */	ast_copy_flags64(iaxs[callno], &cai, IAX_TRUNK | IAX_SENDANI | IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF | IAX_SENDCONNECTEDLINE | IAX_RECVCONNECTEDLINE);	if (ast_test_flag64(&cai, IAX_TRUNK)) {		int new_callno;		if ((new_callno = make_trunk(callno, 1)) != -1)			callno = new_callno;	}	iaxs[callno]->maxtime = cai.maxtime;	if (callid) {		iax_pvt_callid_set(callno, callid);	}	if (cai.found) {		ast_string_field_set(iaxs[callno], host, pds.peer);	}	c = ast_iax2_new(callno, AST_STATE_DOWN, cai.capability, requestor ? ast_channel_linkedid(requestor) : NULL);	ast_mutex_unlock(&iaxsl[callno]);	if (c) {		struct ast_format_cap *joint;		if (callid) {			ast_channel_callid_set(c, callid);		}		/* Choose a format we can live with */		if ((joint = ast_format_cap_joint(ast_channel_nativeformats(c), cap))) {			ast_format_cap_copy(ast_channel_nativeformats(c), joint);			joint = ast_format_cap_destroy(joint);		} else {			struct ast_format best_fmt_cap;			struct ast_format best_fmt_native;			res = ast_translator_best_choice(cap, ast_channel_nativeformats(c), &best_fmt_cap, &best_fmt_native);			if (res < 0) {				char tmp[256];				char tmp2[256];				ast_log(LOG_WARNING, "Unable to create translator path for %s to %s on %s\n",					ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(c)), ast_getformatname_multiple(tmp2, sizeof(tmp2), cap), ast_channel_name(c));				ast_hangup(c);				return NULL;			}			ast_format_cap_set(ast_channel_nativeformats(c), &best_fmt_native);		}		ast_best_codec(ast_channel_nativeformats(c), ast_channel_readformat(c));		ast_format_copy(ast_channel_writeformat(c), ast_channel_readformat(c));	}	if (callid) {		ast_callid_unref(callid);	}	return c;}
int callno;
int callno;
int
callno
callno
int res;
int res;
int
res
res
struct sockaddr_in sin;
struct sockaddr_in sin;
struct sockaddr_in
sockaddr_in
sin
sin
struct ast_channel *c;
struct ast_channel *c;
struct ast_channel
ast_channel
*c
*
c
struct parsed_dial_string pds;
struct parsed_dial_string pds;
struct parsed_dial_string
parsed_dial_string
pds
pds
struct create_addr_info cai;
struct create_addr_info cai;
struct create_addr_info
create_addr_info
cai
cai
char *tmpstr;
char *tmpstr;
char
*tmpstr
*
tmpstr
struct ast_callid *callid;
struct ast_callid *callid;
struct ast_callid
ast_callid
*callid
*
callid
memset(&pds, 0, sizeof(pds));
memset(&pds, 0, sizeof(pds))
memset
memset
&pds
pds
pds
0
sizeof(pds)
(pds)
pds
pds
tmpstr = ast_strdupa(data);
tmpstr = ast_strdupa(data)
tmpstr
tmpstr
ast_strdupa(data)
ast_strdupa
ast_strdupa
data
data
parse_dial_string(tmpstr, &pds);
parse_dial_string(tmpstr, &pds)
parse_dial_string
parse_dial_string
tmpstr
tmpstr
&pds
pds
pds
callid = ast_read_threadstorage_callid();
callid = ast_read_threadstorage_callid()
callid
callid
ast_read_threadstorage_callid()
ast_read_threadstorage_callid
ast_read_threadstorage_callid
if (ast_strlen_zero(pds.peer)) {		ast_log(LOG_WARNING, "No peer provided in the IAX2 dial string '%s'\n", data);		return NULL;	}
ast_strlen_zero(pds.peer)
ast_strlen_zero
ast_strlen_zero
pds.peer
pds
pds
peer
{		ast_log(LOG_WARNING, "No peer provided in the IAX2 dial string '%s'\n", data);		return NULL;	}
ast_log(LOG_WARNING, "No peer provided in the IAX2 dial string '%s'\n", data);
ast_log(LOG_WARNING, "No peer provided in the IAX2 dial string '%s'\n", data)
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"No peer provided in the IAX2 dial string '%s'\n"
data
data
return NULL;
NULL
NULL
memset(&cai, 0, sizeof(cai));
memset(&cai, 0, sizeof(cai))
memset
memset
&cai
cai
cai
0
sizeof(cai)
(cai)
cai
cai
cai.capability = iax2_capability;
cai.capability = iax2_capability
cai.capability
cai
cai
capability
iax2_capability
iax2_capability
ast_copy_flags64(&cai, &globalflags, IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF | IAX_SENDCONNECTEDLINE | IAX_RECVCONNECTEDLINE);
ast_copy_flags64(&cai, &globalflags, IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF | IAX_SENDCONNECTEDLINE | IAX_RECVCONNECTEDLINE)
ast_copy_flags64
ast_copy_flags64
&cai
cai
cai
&globalflags
globalflags
globalflags
IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF | IAX_SENDCONNECTEDLINE | IAX_RECVCONNECTEDLINE
IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF | IAX_SENDCONNECTEDLINE
IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF
IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF
IAX_NOTRANSFER | IAX_TRANSFERMEDIA
IAX_NOTRANSFER
IAX_NOTRANSFER
IAX_TRANSFERMEDIA
IAX_TRANSFERMEDIA
IAX_USEJITTERBUF
IAX_USEJITTERBUF
IAX_FORCEJITTERBUF
IAX_FORCEJITTERBUF
IAX_SENDCONNECTEDLINE
IAX_SENDCONNECTEDLINE
IAX_RECVCONNECTEDLINE
IAX_RECVCONNECTEDLINE
if (create_addr(pds.peer, NULL, &sin, &cai)) {		*cause = AST_CAUSE_UNREGISTERED;		return NULL;	}
create_addr(pds.peer, NULL, &sin, &cai)
create_addr
create_addr
pds.peer
pds
pds
peer
NULL
NULL
&sin
sin
sin
&cai
cai
cai
{		*cause = AST_CAUSE_UNREGISTERED;		return NULL;	}
*cause = AST_CAUSE_UNREGISTERED;
*cause = AST_CAUSE_UNREGISTERED
*cause
cause
cause
AST_CAUSE_UNREGISTERED
AST_CAUSE_UNREGISTERED
return NULL;
NULL
NULL
if (pds.port)		sin.sin_port = htons(atoi(pds.port));
pds.port
pds
pds
port
sin.sin_port = htons(atoi(pds.port));
sin.sin_port = htons(atoi(pds.port))
sin.sin_port
sin
sin
sin_port
htons(atoi(pds.port))
htons
htons
atoi(pds.port)
atoi
atoi
pds.port
pds
pds
port
callno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);
callno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0)
callno
callno
find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0)
find_callno_locked
find_callno_locked
0
0
&sin
sin
sin
NEW_FORCE
NEW_FORCE
cai.sockfd
cai
cai
sockfd
0
if (callno < 1) {		ast_log(LOG_WARNING, "Unable to create call\n");		*cause = AST_CAUSE_CONGESTION;		return NULL;	}
callno < 1
callno
callno
1
{		ast_log(LOG_WARNING, "Unable to create call\n");		*cause = AST_CAUSE_CONGESTION;		return NULL;	}
ast_log(LOG_WARNING, "Unable to create call\n");
ast_log(LOG_WARNING, "Unable to create call\n")
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"Unable to create call\n"
*cause = AST_CAUSE_CONGESTION;
*cause = AST_CAUSE_CONGESTION
*cause
cause
cause
AST_CAUSE_CONGESTION
AST_CAUSE_CONGESTION
return NULL;
NULL
NULL
ast_copy_flags64(iaxs[callno], &cai, IAX_TRUNK | IAX_SENDANI | IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF | IAX_SENDCONNECTEDLINE | IAX_RECVCONNECTEDLINE);
ast_copy_flags64(iaxs[callno], &cai, IAX_TRUNK | IAX_SENDANI | IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF | IAX_SENDCONNECTEDLINE | IAX_RECVCONNECTEDLINE)
ast_copy_flags64
ast_copy_flags64
iaxs[callno]
iaxs
iaxs
callno
callno
&cai
cai
cai
IAX_TRUNK | IAX_SENDANI | IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF | IAX_SENDCONNECTEDLINE | IAX_RECVCONNECTEDLINE
IAX_TRUNK | IAX_SENDANI | IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF | IAX_SENDCONNECTEDLINE
IAX_TRUNK | IAX_SENDANI | IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF
IAX_TRUNK | IAX_SENDANI | IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF
IAX_TRUNK | IAX_SENDANI | IAX_NOTRANSFER | IAX_TRANSFERMEDIA
IAX_TRUNK | IAX_SENDANI | IAX_NOTRANSFER
IAX_TRUNK | IAX_SENDANI
IAX_TRUNK
IAX_TRUNK
IAX_SENDANI
IAX_SENDANI
IAX_NOTRANSFER
IAX_NOTRANSFER
IAX_TRANSFERMEDIA
IAX_TRANSFERMEDIA
IAX_USEJITTERBUF
IAX_USEJITTERBUF
IAX_FORCEJITTERBUF
IAX_FORCEJITTERBUF
IAX_SENDCONNECTEDLINE
IAX_SENDCONNECTEDLINE
IAX_RECVCONNECTEDLINE
IAX_RECVCONNECTEDLINE
if (ast_test_flag64(&cai, IAX_TRUNK)) {		int new_callno;		if ((new_callno = make_trunk(callno, 1)) != -1)			callno = new_callno;	}
ast_test_flag64(&cai, IAX_TRUNK)
ast_test_flag64
ast_test_flag64
&cai
cai
cai
IAX_TRUNK
IAX_TRUNK
{		int new_callno;		if ((new_callno = make_trunk(callno, 1)) != -1)			callno = new_callno;	}
int new_callno;
int new_callno;
int
new_callno
new_callno
if ((new_callno = make_trunk(callno, 1)) != -1)			callno = new_callno;
(new_callno = make_trunk(callno, 1)) != -1
(new_callno = make_trunk(callno, 1))
new_callno = make_trunk(callno, 1)
new_callno
new_callno
make_trunk(callno, 1)
make_trunk
make_trunk
callno
callno
1
-1
1
callno = new_callno;
callno = new_callno
callno
callno
new_callno
new_callno
iaxs[callno]->maxtime = cai.maxtime;
iaxs[callno]->maxtime = cai.maxtime
iaxs[callno]->maxtime
iaxs[callno]
iaxs
iaxs
callno
callno
maxtime
cai.maxtime
cai
cai
maxtime
if (callid) {		iax_pvt_callid_set(callno, callid);	}
callid
callid
{		iax_pvt_callid_set(callno, callid);	}
iax_pvt_callid_set(callno, callid);
iax_pvt_callid_set(callno, callid)
iax_pvt_callid_set
iax_pvt_callid_set
callno
callno
callid
callid
if (cai.found) {		ast_string_field_set(iaxs[callno], host, pds.peer);	}
cai.found
cai
cai
found
{		ast_string_field_set(iaxs[callno], host, pds.peer);	}
ast_string_field_set(iaxs[callno], host, pds.peer);
ast_string_field_set(iaxs[callno], host, pds.peer)
ast_string_field_set
ast_string_field_set
iaxs[callno]
iaxs
iaxs
callno
callno
host
host
pds.peer
pds
pds
peer
c = ast_iax2_new(callno, AST_STATE_DOWN, cai.capability, requestor ? ast_channel_linkedid(requestor) : NULL);
c = ast_iax2_new(callno, AST_STATE_DOWN, cai.capability, requestor ? ast_channel_linkedid(requestor) : NULL)
c
c
ast_iax2_new(callno, AST_STATE_DOWN, cai.capability, requestor ? ast_channel_linkedid(requestor) : NULL)
ast_iax2_new
ast_iax2_new
callno
callno
AST_STATE_DOWN
AST_STATE_DOWN
cai.capability
cai
cai
capability
requestor ? ast_channel_linkedid(requestor) : NULL
requestor
requestor
ast_channel_linkedid(requestor)
ast_channel_linkedid
ast_channel_linkedid
requestor
requestor
NULL
NULL
ast_mutex_unlock(&iaxsl[callno]);
ast_mutex_unlock(&iaxsl[callno]);
ast_mutex_unlock
ast_mutex_unlock
(&iaxsl[callno])
&iaxsl[callno]
&
iaxsl
[callno]
callno
callno
if (c) {		struct ast_format_cap *joint;		if (callid) {			ast_channel_callid_set(c, callid);		}		/* Choose a format we can live with */		if ((joint = ast_format_cap_joint(ast_channel_nativeformats(c), cap))) {			ast_format_cap_copy(ast_channel_nativeformats(c), joint);			joint = ast_format_cap_destroy(joint);		} else {			struct ast_format best_fmt_cap;			struct ast_format best_fmt_native;			res = ast_translator_best_choice(cap, ast_channel_nativeformats(c), &best_fmt_cap, &best_fmt_native);			if (res < 0) {				char tmp[256];				char tmp2[256];				ast_log(LOG_WARNING, "Unable to create translator path for %s to %s on %s\n",					ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(c)), ast_getformatname_multiple(tmp2, sizeof(tmp2), cap), ast_channel_name(c));				ast_hangup(c);				return NULL;			}			ast_format_cap_set(ast_channel_nativeformats(c), &best_fmt_native);		}		ast_best_codec(ast_channel_nativeformats(c), ast_channel_readformat(c));		ast_format_copy(ast_channel_writeformat(c), ast_channel_readformat(c));	}
c
c
{		struct ast_format_cap *joint;		if (callid) {			ast_channel_callid_set(c, callid);		}		/* Choose a format we can live with */		if ((joint = ast_format_cap_joint(ast_channel_nativeformats(c), cap))) {			ast_format_cap_copy(ast_channel_nativeformats(c), joint);			joint = ast_format_cap_destroy(joint);		} else {			struct ast_format best_fmt_cap;			struct ast_format best_fmt_native;			res = ast_translator_best_choice(cap, ast_channel_nativeformats(c), &best_fmt_cap, &best_fmt_native);			if (res < 0) {				char tmp[256];				char tmp2[256];				ast_log(LOG_WARNING, "Unable to create translator path for %s to %s on %s\n",					ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(c)), ast_getformatname_multiple(tmp2, sizeof(tmp2), cap), ast_channel_name(c));				ast_hangup(c);				return NULL;			}			ast_format_cap_set(ast_channel_nativeformats(c), &best_fmt_native);		}		ast_best_codec(ast_channel_nativeformats(c), ast_channel_readformat(c));		ast_format_copy(ast_channel_writeformat(c), ast_channel_readformat(c));	}
struct ast_format_cap *joint;
struct ast_format_cap *joint;
struct ast_format_cap
ast_format_cap
*joint
*
joint
if (callid) {			ast_channel_callid_set(c, callid);		}
callid
callid
{			ast_channel_callid_set(c, callid);		}
ast_channel_callid_set(c, callid);
ast_channel_callid_set(c, callid)
ast_channel_callid_set
ast_channel_callid_set
c
c
callid
callid
if ((joint = ast_format_cap_joint(ast_channel_nativeformats(c), cap))) {			ast_format_cap_copy(ast_channel_nativeformats(c), joint);			joint = ast_format_cap_destroy(joint);		} else {			struct ast_format best_fmt_cap;			struct ast_format best_fmt_native;			res = ast_translator_best_choice(cap, ast_channel_nativeformats(c), &best_fmt_cap, &best_fmt_native);			if (res < 0) {				char tmp[256];				char tmp2[256];				ast_log(LOG_WARNING, "Unable to create translator path for %s to %s on %s\n",					ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(c)), ast_getformatname_multiple(tmp2, sizeof(tmp2), cap), ast_channel_name(c));				ast_hangup(c);				return NULL;			}			ast_format_cap_set(ast_channel_nativeformats(c), &best_fmt_native);		}
(joint = ast_format_cap_joint(ast_channel_nativeformats(c), cap))
joint = ast_format_cap_joint(ast_channel_nativeformats(c), cap)
joint
joint
ast_format_cap_joint(ast_channel_nativeformats(c), cap)
ast_format_cap_joint
ast_format_cap_joint
ast_channel_nativeformats(c)
ast_channel_nativeformats
ast_channel_nativeformats
c
c
cap
cap
{			ast_format_cap_copy(ast_channel_nativeformats(c), joint);			joint = ast_format_cap_destroy(joint);		}
ast_format_cap_copy(ast_channel_nativeformats(c), joint);
ast_format_cap_copy(ast_channel_nativeformats(c), joint)
ast_format_cap_copy
ast_format_cap_copy
ast_channel_nativeformats(c)
ast_channel_nativeformats
ast_channel_nativeformats
c
c
joint
joint
joint = ast_format_cap_destroy(joint);
joint = ast_format_cap_destroy(joint)
joint
joint
ast_format_cap_destroy(joint)
ast_format_cap_destroy
ast_format_cap_destroy
joint
joint
{			struct ast_format best_fmt_cap;			struct ast_format best_fmt_native;			res = ast_translator_best_choice(cap, ast_channel_nativeformats(c), &best_fmt_cap, &best_fmt_native);			if (res < 0) {				char tmp[256];				char tmp2[256];				ast_log(LOG_WARNING, "Unable to create translator path for %s to %s on %s\n",					ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(c)), ast_getformatname_multiple(tmp2, sizeof(tmp2), cap), ast_channel_name(c));				ast_hangup(c);				return NULL;			}			ast_format_cap_set(ast_channel_nativeformats(c), &best_fmt_native);		}
struct ast_format best_fmt_cap;
struct ast_format best_fmt_cap;
struct ast_format
ast_format
best_fmt_cap
best_fmt_cap
struct ast_format best_fmt_native;
struct ast_format best_fmt_native;
struct ast_format
ast_format
best_fmt_native
best_fmt_native
res = ast_translator_best_choice(cap, ast_channel_nativeformats(c), &best_fmt_cap, &best_fmt_native);
res = ast_translator_best_choice(cap, ast_channel_nativeformats(c), &best_fmt_cap, &best_fmt_native)
res
res
ast_translator_best_choice(cap, ast_channel_nativeformats(c), &best_fmt_cap, &best_fmt_native)
ast_translator_best_choice
ast_translator_best_choice
cap
cap
ast_channel_nativeformats(c)
ast_channel_nativeformats
ast_channel_nativeformats
c
c
&best_fmt_cap
best_fmt_cap
best_fmt_cap
&best_fmt_native
best_fmt_native
best_fmt_native
if (res < 0) {				char tmp[256];				char tmp2[256];				ast_log(LOG_WARNING, "Unable to create translator path for %s to %s on %s\n",					ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(c)), ast_getformatname_multiple(tmp2, sizeof(tmp2), cap), ast_channel_name(c));				ast_hangup(c);				return NULL;			}
res < 0
res
res
0
{				char tmp[256];				char tmp2[256];				ast_log(LOG_WARNING, "Unable to create translator path for %s to %s on %s\n",					ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(c)), ast_getformatname_multiple(tmp2, sizeof(tmp2), cap), ast_channel_name(c));				ast_hangup(c);				return NULL;			}
char tmp[256];
char tmp[256];
char
tmp[256]
tmp
[256]
256
char tmp2[256];
char tmp2[256];
char
tmp2[256]
tmp2
[256]
256
ast_log(LOG_WARNING, "Unable to create translator path for %s to %s on %s\n",					ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(c)), ast_getformatname_multiple(tmp2, sizeof(tmp2), cap), ast_channel_name(c));
ast_log(LOG_WARNING, "Unable to create translator path for %s to %s on %s\n",					ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(c)), ast_getformatname_multiple(tmp2, sizeof(tmp2), cap), ast_channel_name(c))
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"Unable to create translator path for %s to %s on %s\n"
ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(c))
ast_getformatname_multiple
ast_getformatname_multiple
tmp
tmp
sizeof(tmp)
(tmp)
tmp
tmp
ast_channel_nativeformats(c)
ast_channel_nativeformats
ast_channel_nativeformats
c
c
ast_getformatname_multiple(tmp2, sizeof(tmp2), cap)
ast_getformatname_multiple
ast_getformatname_multiple
tmp2
tmp2
sizeof(tmp2)
(tmp2)
tmp2
tmp2
cap
cap
ast_channel_name(c)
ast_channel_name
ast_channel_name
c
c
ast_hangup(c);
ast_hangup(c)
ast_hangup
ast_hangup
c
c
return NULL;
NULL
NULL
ast_format_cap_set(ast_channel_nativeformats(c), &best_fmt_native);
ast_format_cap_set(ast_channel_nativeformats(c), &best_fmt_native)
ast_format_cap_set
ast_format_cap_set
ast_channel_nativeformats(c)
ast_channel_nativeformats
ast_channel_nativeformats
c
c
&best_fmt_native
best_fmt_native
best_fmt_native
ast_best_codec(ast_channel_nativeformats(c), ast_channel_readformat(c));
ast_best_codec(ast_channel_nativeformats(c), ast_channel_readformat(c))
ast_best_codec
ast_best_codec
ast_channel_nativeformats(c)
ast_channel_nativeformats
ast_channel_nativeformats
c
c
ast_channel_readformat(c)
ast_channel_readformat
ast_channel_readformat
c
c
ast_format_copy(ast_channel_writeformat(c), ast_channel_readformat(c));
ast_format_copy(ast_channel_writeformat(c), ast_channel_readformat(c))
ast_format_copy
ast_format_copy
ast_channel_writeformat(c)
ast_channel_writeformat
ast_channel_writeformat
c
c
ast_channel_readformat(c)
ast_channel_readformat
ast_channel_readformat
c
c
if (callid) {		ast_callid_unref(callid);	}
callid
callid
{		ast_callid_unref(callid);	}
ast_callid_unref(callid);
ast_callid_unref(callid)
ast_callid_unref
ast_callid_unref
callid
callid
return c;
c
c
-----joern-----
(21,161,0)
(278,181,0)
(236,88,0)
(187,182,0)
(95,44,0)
(220,289,0)
(33,195,0)
(256,107,0)
(96,257,0)
(243,202,0)
(38,99,0)
(45,192,0)
(172,268,0)
(39,137,0)
(243,33,0)
(17,239,0)
(254,187,0)
(59,195,0)
(3,195,0)
(187,24,0)
(289,1,0)
(206,186,0)
(180,56,0)
(130,239,0)
(44,84,0)
(241,192,0)
(71,106,0)
(8,230,0)
(246,195,0)
(229,117,0)
(53,271,0)
(287,195,0)
(294,140,0)
(95,239,0)
(163,219,0)
(205,161,0)
(231,24,0)
(242,194,0)
(117,195,0)
(24,187,0)
(61,274,0)
(16,290,0)
(262,195,0)
(299,258,0)
(258,259,0)
(21,192,0)
(6,38,0)
(88,113,0)
(236,250,0)
(241,79,0)
(72,58,0)
(288,223,0)
(291,211,0)
(41,195,0)
(200,202,0)
(99,38,0)
(209,230,0)
(169,190,0)
(233,197,0)
(198,221,0)
(53,8,0)
(149,290,0)
(42,268,0)
(29,51,0)
(95,263,0)
(154,53,0)
(202,222,0)
(205,192,0)
(236,95,0)
(104,91,0)
(245,30,0)
(249,192,0)
(197,25,0)
(148,124,0)
(245,164,0)
(79,187,0)
(76,95,0)
(140,294,0)
(58,204,0)
(1,20,0)
(185,140,0)
(224,1,0)
(60,195,0)
(226,168,0)
(3,86,0)
(139,208,0)
(284,192,0)
(74,195,0)
(84,226,0)
(159,155,0)
(223,288,0)
(279,229,0)
(174,297,0)
(66,22,0)
(244,298,0)
(67,91,0)
(222,195,0)
(271,195,0)
(16,121,0)
(38,6,0)
(110,263,0)
(105,162,0)
(10,179,0)
(122,232,0)
(162,54,0)
(142,192,0)
(232,56,0)
(271,175,0)
(204,58,0)
(297,283,0)
(14,51,0)
(215,187,0)
(107,222,0)
(192,195,0)
(179,212,0)
(216,259,0)
(247,192,0)
(2,270,0)
(187,79,0)
(264,118,0)
(36,81,0)
(218,157,0)
(161,13,0)
(1,289,0)
(248,222,0)
(182,187,0)
(91,67,0)
(142,16,0)
(70,120,0)
(232,195,0)
(7,67,0)
(137,18,0)
(294,228,0)
(63,162,0)
(82,71,0)
(187,51,0)
(55,224,0)
(146,27,0)
(232,90,0)
(95,51,0)
(188,128,0)
(37,107,0)
(128,188,0)
(223,121,0)
(161,21,0)
(64,257,0)
(156,242,0)
(261,195,0)
(43,164,0)
(156,194,0)
(48,243,0)
(280,78,0)
(71,271,0)
(143,42,0)
(93,81,0)
(165,227,0)
(270,257,0)
(153,67,0)
(53,68,0)
(202,242,0)
(134,298,0)
(109,20,0)
(136,109,0)
(40,242,0)
(103,44,0)
(234,195,0)
(211,34,0)
(182,192,0)
(107,230,0)
(27,117,0)
(236,120,0)
(14,192,0)
(196,88,0)
(198,262,0)
(242,156,0)
(229,222,0)
(221,198,0)
(128,13,0)
(101,182,0)
(23,22,0)
(202,243,0)
(284,128,0)
(259,223,0)
(109,265,0)
(115,223,0)
(152,20,0)
(270,195,0)
(155,270,0)
(213,143,0)
(145,157,0)
(34,211,0)
(272,10,0)
(240,192,0)
(201,284,0)
(85,243,0)
(265,109,0)
(87,117,0)
(276,126,0)
(221,222,0)
(5,268,0)
(79,274,0)
(36,230,0)
(116,242,0)
(77,8,0)
(86,3,0)
(140,27,0)
(184,181,0)
(135,78,0)
(240,139,0)
(20,1,0)
(131,64,0)
(285,44,0)
(114,118,0)
(181,222,0)
(228,143,0)
(56,232,0)
(203,223,0)
(117,229,0)
(295,204,0)
(270,155,0)
(233,222,0)
(219,67,0)
(290,16,0)
(112,42,0)
(38,227,0)
(89,245,0)
(15,137,0)
(31,205,0)
(257,195,0)
(161,205,0)
(242,202,0)
(203,192,0)
(90,232,0)
(118,8,0)
(274,79,0)
(20,109,0)
(249,149,0)
(202,8,0)
(28,176,0)
(268,42,0)
(52,271,0)
(117,87,0)
(42,143,0)
(238,195,0)
(222,67,0)
(139,186,0)
(138,186,0)
(65,149,0)
(123,16,0)
(255,195,0)
(282,195,0)
(129,188,0)
(162,63,0)
(97,51,0)
(214,294,0)
(16,142,0)
(265,204,0)
(237,186,0)
(173,45,0)
(4,25,0)
(125,290,0)
(188,192,0)
(137,283,0)
(202,192,0)
(35,13,0)
(111,195,0)
(263,3,0)
(298,168,0)
(69,33,0)
(133,8,0)
(75,58,0)
(53,222,0)
(263,118,0)
(118,222,0)
(190,73,0)
(275,211,0)
(26,86,0)
(127,63,0)
(120,195,0)
(226,84,0)
(98,202,0)
(223,126,0)
(230,36,0)
(277,137,0)
(32,14,0)
(45,141,0)
(164,245,0)
(228,294,0)
(113,100,0)
(208,139,0)
(132,179,0)
(260,90,0)
(117,27,0)
(126,223,0)
(63,290,0)
(193,6,0)
(191,86,0)
(204,265,0)
(157,73,0)
(49,221,0)
(149,54,0)
(24,158,0)
(175,271,0)
(236,297,0)
(108,249,0)
(245,195,0)
(192,202,0)
(119,87,0)
(177,30,0)
(128,284,0)
(11,228,0)
(223,203,0)
(80,156,0)
(46,240,0)
(150,79,0)
(262,198,0)
(47,258,0)
(223,259,0)
(143,228,0)
(266,227,0)
(233,8,0)
(178,45,0)
(207,221,0)
(81,36,0)
(30,245,0)
(292,203,0)
(221,8,0)
(1,224,0)
(199,113,0)
(45,271,0)
(139,240,0)
(170,241,0)
(158,24,0)
(253,124,0)
(124,253,0)
(83,13,0)
(19,195,0)
(281,265,0)
(257,64,0)
(250,239,0)
(67,222,0)
(88,239,0)
(189,21,0)
(144,250,0)
(250,10,0)
(166,53,0)
(67,219,0)
(227,38,0)
(102,229,0)
(62,197,0)
(12,288,0)
(250,212,0)
(197,210,0)
(293,142,0)
(151,195,0)
(147,176,0)
(252,253,0)
(64,18,0)
(120,192,0)
(113,190,0)
(225,24,0)
(88,73,0)
(9,38,0)
(118,263,0)
(1,195,0)
(168,226,0)
(217,25,0)
(267,219,0)
(149,249,0)
(273,233,0)
(269,99,0)
(296,67,0)
(235,13,0)
(25,197,0)
(57,208,0)
(24,121,0)
(239,33,0)
(160,233,0)
(197,233,0)
(94,158,0)
(168,298,0)
(167,67,0)
(92,195,0)
(0,195,0)
(50,195,0)
(27,140,0)
(259,186,0)
(88,44,0)
(79,241,0)
(10,100,0)
(230,107,0)
(187,182,1)
(207,192,1)
(8,133,1)
(38,6,1)
(98,200,1)
(284,201,1)
(257,64,1)
(232,56,1)
(77,36,1)
(258,259,1)
(57,240,1)
(286,183,1)
(185,146,1)
(247,197,1)
(201,188,1)
(89,30,1)
(66,251,1)
(203,292,1)
(15,34,1)
(189,205,1)
(164,43,1)
(152,289,1)
(278,222,1)
(99,269,1)
(149,290,1)
(115,216,1)
(259,223,1)
(224,55,1)
(236,250,1)
(161,21,1)
(10,100,1)
(281,136,1)
(53,154,1)
(242,40,1)
(155,159,1)
(117,27,1)
(217,4,1)
(118,264,1)
(72,75,1)
(147,38,1)
(177,34,1)
(34,211,1)
(273,22,1)
(93,230,1)
(125,171,1)
(248,84,1)
(16,123,1)
(221,222,1)
(188,129,1)
(86,26,1)
(239,17,1)
(85,98,1)
(159,2,1)
(157,218,1)
(133,77,1)
(294,228,1)
(244,134,1)
(236,88,1)
(216,290,1)
(286,128,1)
(156,194,1)
(187,24,1)
(271,175,1)
(270,257,1)
(270,155,1)
(250,239,1)
(24,121,1)
(90,260,1)
(28,147,1)
(223,126,1)
(209,124,1)
(81,93,1)
(266,1,1)
(197,233,1)
(249,108,1)
(145,181,1)
(168,298,1)
(95,263,1)
(7,91,1)
(105,149,1)
(165,266,1)
(171,183,1)
(149,249,1)
(176,28,1)
(9,227,1)
(107,37,1)
(3,86,1)
(17,130,1)
(10,272,1)
(64,18,1)
(149,65,1)
(236,95,1)
(223,288,1)
(167,248,1)
(260,122,1)
(53,271,1)
(181,184,1)
(64,131,1)
(119,229,1)
(223,203,1)
(125,45,1)
(71,271,1)
(88,44,1)
(95,44,1)
(139,240,1)
(199,157,1)
(265,204,1)
(132,10,1)
(14,32,1)
(208,57,1)
(254,258,1)
(140,294,1)
(174,137,1)
(42,268,1)
(236,120,1)
(16,121,1)
(110,118,1)
(263,118,1)
(24,231,1)
(279,181,1)
(295,281,1)
(31,162,1)
(154,166,1)
(67,153,1)
(277,15,1)
(204,58,1)
(179,132,1)
(30,177,1)
(211,275,1)
(242,156,1)
(166,251,1)
(262,198,1)
(190,169,1)
(205,31,1)
(127,105,1)
(203,192,1)
(52,270,1)
(196,190,1)
(117,229,1)
(128,188,1)
(274,61,1)
(123,142,1)
(233,160,1)
(5,172,1)
(136,152,1)
(256,209,1)
(243,33,1)
(134,44,1)
(250,10,1)
(53,222,1)
(1,20,1)
(228,143,1)
(76,14,1)
(146,87,1)
(109,265,1)
(233,222,1)
(219,163,1)
(298,244,1)
(21,192,1)
(181,222,1)
(113,199,1)
(112,213,1)
(188,192,1)
(23,66,1)
(44,285,1)
(6,193,1)
(63,127,1)
(182,101,1)
(38,227,1)
(258,47,1)
(55,33,1)
(213,11,1)
(272,38,1)
(71,82,1)
(184,278,1)
(269,6,1)
(143,42,1)
(69,239,1)
(251,3,1)
(240,192,1)
(36,230,1)
(129,161,1)
(130,245,1)
(218,145,1)
(137,39,1)
(32,187,1)
(202,243,1)
(114,36,1)
(248,176,1)
(162,63,1)
(276,203,1)
(49,207,1)
(113,100,1)
(25,217,1)
(291,271,1)
(65,249,1)
(96,232,1)
(95,239,1)
(36,81,1)
(202,222,1)
(67,91,1)
(63,290,1)
(288,12,1)
(58,72,1)
(226,168,1)
(126,276,1)
(116,243,1)
(268,5,1)
(299,259,1)
(131,96,1)
(108,290,1)
(222,67,1)
(40,116,1)
(170,274,1)
(297,174,1)
(39,277,1)
(148,253,1)
(120,192,1)
(275,291,1)
(158,94,1)
(264,114,1)
(214,185,1)
(192,202,1)
(197,25,1)
(289,220,1)
(114,8,1)
(202,8,1)
(120,70,1)
(1,289,1)
(252,117,1)
(230,107,1)
(183,262,1)
(45,192,1)
(91,104,1)
(101,24,1)
(150,215,1)
(296,167,1)
(47,299,1)
(139,208,1)
(215,254,1)
(263,110,1)
(12,126,1)
(241,170,1)
(87,119,1)
(191,263,1)
(48,85,1)
(290,16,1)
(38,99,1)
(173,171,1)
(102,279,1)
(231,158,1)
(124,253,1)
(193,9,1)
(62,233,1)
(142,293,1)
(253,252,1)
(292,115,1)
(45,178,1)
(221,49,1)
(8,230,1)
(163,267,1)
(79,241,1)
(104,296,1)
(247,22,1)
(67,219,1)
(56,180,1)
(236,297,1)
(242,194,1)
(114,124,1)
(79,274,1)
(227,165,1)
(88,239,1)
(16,142,1)
(45,271,1)
(107,222,1)
(66,53,1)
(128,284,1)
(200,247,1)
(144,179,1)
(24,158,1)
(20,109,1)
(2,257,1)
(202,242,1)
(26,191,1)
(84,226,1)
(43,89,1)
(205,192,1)
(118,8,1)
(88,196,1)
(70,286,1)
(33,69,1)
(245,164,1)
(198,221,1)
(229,102,1)
(95,76,1)
(31,139,1)
(187,79,1)
(221,8,1)
(82,286,1)
(153,219,1)
(285,103,1)
(4,62,1)
(172,112,1)
(169,113,1)
(142,192,1)
(11,214,1)
(118,222,1)
(240,46,1)
(161,205,1)
(293,125,1)
(88,113,1)
(178,173,1)
(249,192,1)
(122,56,1)
(124,148,1)
(243,48,1)
(37,256,1)
(229,222,1)
(21,189,1)
(245,30,1)
(1,224,1)
(241,192,1)
(14,192,1)
(94,225,1)
(75,295,1)
(250,144,1)
(53,8,1)
(267,7,1)
(160,273,1)
(182,192,1)
(175,52,1)
(233,8,1)
(46,258,1)
(22,23,1)
(117,87,1)
(225,79,1)
(137,18,1)
(156,80,1)
(103,176,1)
(27,140,1)
(80,116,1)
(61,150,1)
(70,71,1)
(284,192,1)
(220,224,1)
(232,90,1)
(223,121,1)
(120,192,2)
(38,6,2)
(139,258,2)
(47,290,2)
(128,290,2)
(32,258,2)
(284,258,2)
(98,181,2)
(79,258,2)
(239,34,2)
(153,38,2)
(145,181,2)
(108,290,2)
(272,38,2)
(61,258,2)
(294,181,2)
(117,87,2)
(95,44,2)
(197,22,2)
(205,258,2)
(124,253,2)
(117,181,2)
(184,38,2)
(298,176,2)
(187,24,2)
(202,242,2)
(188,192,2)
(25,22,2)
(290,183,2)
(20,34,2)
(67,219,2)
(215,258,2)
(79,241,2)
(245,164,2)
(160,22,2)
(70,258,2)
(24,121,2)
(245,34,2)
(1,224,2)
(120,290,2)
(88,181,2)
(161,21,2)
(104,38,2)
(31,290,2)
(245,30,2)
(290,16,2)
(87,181,2)
(84,226,2)
(31,258,2)
(209,124,2)
(161,258,2)
(117,229,2)
(67,38,2)
(40,116,2)
(16,142,2)
(223,288,2)
(205,192,2)
(84,176,2)
(198,221,2)
(240,258,2)
(5,181,2)
(286,183,2)
(168,298,2)
(23,181,2)
(12,290,2)
(216,290,2)
(229,181,2)
(166,251,2)
(236,297,2)
(91,38,2)
(199,181,2)
(181,38,2)
(171,183,2)
(242,181,2)
(109,34,2)
(262,181,2)
(42,268,2)
(118,222,2)
(251,181,2)
(295,34,2)
(164,34,2)
(113,181,2)
(279,181,2)
(88,239,2)
(115,290,2)
(16,183,2)
(274,258,2)
(81,124,2)
(8,36,2)
(204,34,2)
(232,56,2)
(257,64,2)
(256,124,2)
(95,239,2)
(76,258,2)
(137,34,2)
(259,290,2)
(223,290,2)
(240,192,2)
(89,34,2)
(226,176,2)
(188,258,2)
(213,181,2)
(156,116,2)
(201,290,2)
(288,290,2)
(250,38,2)
(229,222,2)
(203,192,2)
(10,38,2)
(202,8,2)
(231,258,2)
(154,251,2)
(202,222,2)
(42,181,2)
(6,34,2)
(265,204,2)
(228,181,2)
(264,181,2)
(243,33,2)
(140,181,2)
(33,34,2)
(168,176,2)
(172,181,2)
(37,124,2)
(45,271,2)
(43,34,2)
(292,290,2)
(128,188,2)
(225,258,2)
(114,181,2)
(202,243,2)
(132,38,2)
(27,181,2)
(197,233,2)
(163,38,2)
(127,290,2)
(105,290,2)
(46,258,2)
(221,8,2)
(14,192,2)
(177,34,2)
(102,181,2)
(242,156,2)
(58,34,2)
(26,181,2)
(253,181,2)
(169,181,2)
(158,258,2)
(223,203,2)
(242,194,2)
(137,18,2)
(241,258,2)
(21,290,2)
(120,183,2)
(268,181,2)
(157,181,2)
(224,34,2)
(297,34,2)
(220,34,2)
(139,208,2)
(258,290,2)
(182,192,2)
(70,290,2)
(270,155,2)
(49,181,2)
(21,258,2)
(170,258,2)
(7,38,2)
(230,107,2)
(218,181,2)
(86,181,2)
(162,63,2)
(285,176,2)
(249,290,2)
(179,38,2)
(53,271,2)
(189,290,2)
(236,95,2)
(222,38,2)
(217,22,2)
(88,113,2)
(228,143,2)
(254,258,2)
(55,34,2)
(149,290,2)
(198,181,2)
(201,258,2)
(123,183,2)
(191,181,2)
(85,181,2)
(219,38,2)
(48,181,2)
(20,109,2)
(161,290,2)
(286,258,2)
(249,192,2)
(221,181,2)
(270,257,2)
(165,34,2)
(241,192,2)
(278,38,2)
(53,8,2)
(109,265,2)
(230,124,2)
(193,34,2)
(45,192,2)
(107,124,2)
(66,181,2)
(236,120,2)
(80,116,2)
(38,227,2)
(129,290,2)
(24,158,2)
(259,223,2)
(69,34,2)
(276,290,2)
(236,88,2)
(17,34,2)
(57,258,2)
(128,284,2)
(65,290,2)
(62,22,2)
(4,22,2)
(10,100,2)
(15,34,2)
(273,22,2)
(53,251,2)
(11,181,2)
(248,38,2)
(101,258,2)
(103,176,2)
(247,181,2)
(294,228,2)
(107,222,2)
(263,118,2)
(136,34,2)
(167,38,2)
(146,181,2)
(124,181,2)
(187,258,2)
(140,294,2)
(214,181,2)
(36,81,2)
(205,290,2)
(232,90,2)
(269,34,2)
(36,124,2)
(284,192,2)
(233,222,2)
(147,38,2)
(38,34,2)
(200,181,2)
(188,290,2)
(207,181,2)
(150,258,2)
(236,250,2)
(125,183,2)
(196,181,2)
(142,192,2)
(118,8,2)
(222,67,2)
(190,181,2)
(189,258,2)
(243,181,2)
(223,126,2)
(82,286,2)
(178,171,2)
(30,34,2)
(299,290,2)
(8,230,2)
(63,290,2)
(185,181,2)
(16,121,2)
(14,258,2)
(174,34,2)
(130,34,2)
(181,222,2)
(118,181,2)
(204,58,2)
(271,175,2)
(28,38,2)
(1,20,2)
(277,34,2)
(64,18,2)
(265,34,2)
(161,205,2)
(21,192,2)
(192,202,2)
(95,258,2)
(208,258,2)
(117,27,2)
(143,42,2)
(3,86,2)
(38,99,2)
(139,240,2)
(284,290,2)
(173,171,2)
(22,181,2)
(1,289,2)
(148,181,2)
(119,181,2)
(134,176,2)
(162,290,2)
(252,181,2)
(250,239,2)
(233,8,2)
(289,34,2)
(176,38,2)
(45,171,2)
(77,36,2)
(71,286,2)
(250,10,2)
(258,259,2)
(110,181,2)
(79,274,2)
(3,181,2)
(187,182,2)
(93,124,2)
(34,211,2)
(27,140,2)
(129,258,2)
(281,34,2)
(233,22,2)
(1,34,2)
(221,222,2)
(152,34,2)
(142,183,2)
(296,38,2)
(187,79,2)
(144,38,2)
(99,34,2)
(39,34,2)
(293,183,2)
(203,290,2)
(182,258,2)
(44,176,2)
(116,181,2)
(149,249,2)
(36,230,2)
(9,34,2)
(286,290,2)
(72,34,2)
(70,183,2)
(128,258,2)
(126,290,2)
(95,263,2)
(262,198,2)
(156,194,2)
(24,258,2)
(202,181,2)
(197,25,2)
(244,176,2)
(227,34,2)
(267,38,2)
(67,91,2)
(53,222,2)
(88,44,2)
(192,181,2)
(183,181,2)
(266,34,2)
(75,34,2)
(223,121,2)
(263,181,2)
(71,271,2)
(113,100,2)
(143,181,2)
(94,258,2)
(133,36,2)
(226,168,2)
(112,181,2)
(120,258,2)
-----------------------------------
(0,sin)
(1,ast_copy_flags64(&cai, &globalflags, IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF | IAX_SENDCONNECTEDLINE | IAX_RECVCONNECTEDLINE)
(2,tmpstr)
(3,iaxs[callno]->maxtime = cai.maxtime)
(4,pds)
(5,IAX_RECVCONNECTEDLINE)
(6,&sin)
(7,NEW_FORCE)
(8,callno = new_callno)
(9,NULL)
(10,*cause)
(11,IAX_TRANSFERMEDIA)
(12,best_fmt_native)
(13,)
(14,ast_hangup(c)
(15,LOG_WARNING)
(16,ast_format_cap_joint(ast_channel_nativeformats(c)
(17,capability)
(18,const char *data)
(19,if (create_addr(pds.peer, NULL, &sin, &cai)
(20,IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF | IAX_SENDCONNECTEDLINE | IAX_RECVCONNECTEDLINE)
(21,ast_channel_readformat(c)
(22,cai.found)
(23,found)
(24,ast_getformatname_multiple(tmp2, sizeof(tmp2)
(25,pds.peer)
(26,maxtime)
(27,IAX_TRUNK | IAX_SENDANI | IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF | IAX_SENDCONNECTEDLINE | IAX_RECVCONNECTEDLINE)
(28,port)
(29,tmp)
(30,&cai)
(31,c)
(32,c)
(33,cai.capability = iax2_capability)
(34,ast_strlen_zero(pds.peer)
(35,if (callid)
(36,(new_callno = make_trunk(callno, 1)
(37,1)
(38,create_addr(pds.peer, NULL, &sin, &cai)
(39,data)
(40,NULL)
(41,if (ast_test_flag64(&cai, IAX_TRUNK)
(42,IAX_FORCEJITTERBUF | IAX_SENDCONNECTEDLINE | IAX_RECVCONNECTEDLINE)
(43,cai)
(44,sin.sin_port)
(45,ast_channel_callid_set(c, callid)
(46,c)
(47,0)
(48,capability)
(49,callno)
(50,if (callno < 1)
(51,)
(52,callid)
(53,iax_pvt_callid_set(callno, callid)
(54,)
(55,cai)
(56,&pds)
(57,best_fmt_native)
(58,IAX_SENDCONNECTEDLINE | IAX_RECVCONNECTEDLINE)
(59,if (cai.found)
(60,callid)
(61,tmp)
(62,host)
(63,ast_format_cap_destroy(joint)
(64,ast_strdupa(data)
(65,joint)
(66,cai)
(67,find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0)
(68,)
(69,iax2_capability)
(70,c)
(71,ast_callid_unref(callid)
(72,IAX_RECVCONNECTEDLINE)
(73,)
(74,cai)
(75,IAX_SENDCONNECTEDLINE)
(76,NULL)
(77,callno)
(78,)
(79,ast_getformatname_multiple(tmp, sizeof(tmp)
(80,requestor)
(81,-1)
(82,callid)
(83,if ((joint = ast_format_cap_joint(ast_channel_nativeformats(c)
(84,sin.sin_port = htons(atoi(pds.port)
(85,cai)
(86,cai.maxtime)
(87,&cai)
(88,return NULL;)
(89,0)
(90,sizeof(pds)
(91,&sin)
(92,res)
(93,1)
(94,tmp2)
(95,return NULL;)
(96,tmpstr)
(97,tmp2)
(98,AST_STATE_DOWN)
(99,&cai)
(100,int *cause)
(101,c)
(102,callno)
(103,sin)
(104,sin)
(105,joint)
(106,)
(107,make_trunk(callno, 1)
(108,c)
(109,IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF | IAX_SENDCONNECTEDLINE | IAX_RECVCONNECTEDLINE)
(110,maxtime)
(111,if (c)
(112,IAX_FORCEJITTERBUF)
(113,*cause)
(114,iaxs)
(115,cap)
(116,requestor)
(117,ast_copy_flags64(iaxs[callno], &cai, IAX_TRUNK | IAX_SENDANI | IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF | IAX_SENDCONNECTEDLINE | IAX_RECVCONNECTEDLINE)
(118,iaxs[callno])
(119,cai)
(120,return c;)
(121,struct ast_format_cap *cap)
(122,0)
(123,cap)
(124,ast_test_flag64(&cai, IAX_TRUNK)
(125,joint)
(126,&best_fmt_cap)
(127,joint)
(128,ast_format_copy(ast_channel_writeformat(c)
(129,c)
(130,cai)
(131,data)
(132,AST_CAUSE_UNREGISTERED)
(133,new_callno)
(134,pds)
(135,if ((new_callno = make_trunk(callno, 1)
(136,IAX_TRANSFERMEDIA)
(137,ast_log(LOG_WARNING, "No peer provided in the IAX2 dial string \'%s\'\\n", data)
(138,if (res < 0)
(139,ast_format_cap_set(ast_channel_nativeformats(c)
(140,IAX_SENDANI | IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF | IAX_SENDCONNECTEDLINE | IAX_RECVCONNECTEDLINE)
(141,)
(142,ast_channel_nativeformats(c)
(143,IAX_USEJITTERBUF | IAX_FORCEJITTERBUF | IAX_SENDCONNECTEDLINE | IAX_RECVCONNECTEDLINE)
(144,NULL)
(145,LOG_WARNING)
(146,IAX_TRUNK)
(147,pds)
(148,IAX_TRUNK)
(149,ast_format_cap_copy(ast_channel_nativeformats(c)
(150,tmp)
(151,if (ast_strlen_zero(pds.peer)
(152,IAX_NOTRANSFER)
(153,0)
(154,callid)
(155,&pds)
(156,ast_channel_linkedid(requestor)
(157,ast_log(LOG_WARNING, "Unable to create call\\n")
(158,sizeof(tmp2)
(159,pds)
(160,callno)
(161,ast_best_codec(ast_channel_nativeformats(c)
(162,joint = ast_format_cap_destroy(joint)
(163,sockfd)
(164,sizeof(cai)
(165,peer)
(166,callno)
(167,0)
(168,atoi(pds.port)
(169,AST_CAUSE_CONGESTION)
(170,c)
(171,callid)
(172,IAX_SENDCONNECTEDLINE)
(173,c)
(174,NULL)
(175,ast_read_threadstorage_callid()
(176,pds.port)
(177,cai)
(178,callid)
(179,*cause = AST_CAUSE_UNREGISTERED)
(180,pds)
(181,callno < 1)
(182,ast_channel_name(c)
(183,c)
(184,1)
(185,IAX_SENDANI)
(186,)
(187,ast_log(LOG_WARNING, "Unable to create translator path for %s to %s on %s\\n",\n\\n\\t\\t\\t\\t\\tast_getformatname_multiple(tmp, sizeof(tmp)
(188,ast_channel_writeformat(c)
(189,c)
(190,*cause = AST_CAUSE_CONGESTION)
(191,cai)
(192,c = ast_iax2_new(callno, AST_STATE_DOWN, cai.capability, requestor ? ast_channel_linkedid(requestor)
(193,sin)
(194,const struct ast_channel *requestor)
(195,)
(196,NULL)
(197,ast_string_field_set(iaxs[callno], host, pds.peer)
(198,&iaxsl[callno])
(199,cause)
(200,callno)
(201,c)
(202,ast_iax2_new(callno, AST_STATE_DOWN, cai.capability, requestor ? ast_channel_linkedid(requestor)
(203,ast_channel_nativeformats(c)
(204,IAX_FORCEJITTERBUF | IAX_SENDCONNECTEDLINE | IAX_RECVCONNECTEDLINE)
(205,ast_channel_nativeformats(c)
(206,best_fmt_native)
(207,iaxsl)
(208,&best_fmt_native)
(209,new_callno)
(210,)
(211,pds.peer)
(212,)
(213,IAX_USEJITTERBUF)
(214,IAX_NOTRANSFER)
(215,"Unable to create translator path for %s to %s on %s\\n")
(216,res)
(217,peer)
(218,"Unable to create call\\n")
(219,cai.sockfd)
(220,globalflags)
(221,iaxsl[callno])
(222,callno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0)
(223,ast_translator_best_choice(cap, ast_channel_nativeformats(c)
(224,&cai)
(225,tmp2)
(226,htons(atoi(pds.port)
(227,pds.peer)
(228,IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF | IAX_SENDCONNECTEDLINE | IAX_RECVCONNECTEDLINE)
(229,iaxs[callno])
(230,new_callno = make_trunk(callno, 1)
(231,cap)
(232,memset(&pds, 0, sizeof(pds)
(233,iaxs[callno])
(234,c)
(235,joint)
(236,RET)
(237,best_fmt_cap)
(238,callno)
(239,cai.capability)
(240,ast_channel_nativeformats(c)
(241,ast_channel_nativeformats(c)
(242,requestor ? ast_channel_linkedid(requestor)
(243,cai.capability)
(244,port)
(245,memset(&cai, 0, sizeof(cai)
(246,pds)
(247,c)
(248,callno)
(249,ast_channel_nativeformats(c)
(250,return NULL;)
(251,callid)
(252,cai)
(253,&cai)
(254,LOG_WARNING)
(255,if (callid)
(256,callno)
(257,tmpstr = ast_strdupa(data)
(258,res < 0)
(259,res = ast_translator_best_choice(cap, ast_channel_nativeformats(c)
(260,pds)
(261,tmpstr)
(262,ast_mutex_unlock(&iaxsl[callno])
(263,iaxs[callno]->maxtime)
(264,callno)
(265,IAX_USEJITTERBUF | IAX_FORCEJITTERBUF | IAX_SENDCONNECTEDLINE | IAX_RECVCONNECTEDLINE)
(266,pds)
(267,cai)
(268,IAX_SENDCONNECTEDLINE | IAX_RECVCONNECTEDLINE)
(269,cai)
(270,parse_dial_string(tmpstr, &pds)
(271,callid = ast_read_threadstorage_callid()
(272,cause)
(273,iaxs)
(274,sizeof(tmp)
(275,peer)
(276,best_fmt_cap)
(277,"No peer provided in the IAX2 dial string \'%s\'\\n")
(278,callno)
(279,iaxs)
(280,new_callno)
(281,IAX_USEJITTERBUF)
(282,if (callid)
(283,)
(284,ast_channel_readformat(c)
(285,sin_port)
(286,callid)
(287,if (pds.port)
(288,&best_fmt_native)
(289,&globalflags)
(290,joint = ast_format_cap_joint(ast_channel_nativeformats(c)
(291,pds)
(292,c)
(293,c)
(294,IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF | IAX_SENDCONNECTEDLINE | IAX_RECVCONNECTEDLINE)
(295,IAX_FORCEJITTERBUF)
(296,0)
(297,return NULL;)
(298,pds.port)
(299,res)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^