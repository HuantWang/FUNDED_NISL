-----label-----
1
-----code-----
void
limProcessAuthFrame(tpAniSirGlobal pMac, tANI_U8 *pRxPacketInfo, tpPESession psessionEntry)
{
    tANI_U8                 *pBody, keyId, cfgPrivacyOptImp,
                            defaultKey[SIR_MAC_KEY_LENGTH],
                            encrAuthFrame[LIM_ENCR_AUTH_BODY_LEN],
                            plainBody[256];
    tANI_U16                frameLen;
    //tANI_U32                authRspTimeout, maxNumPreAuth, val;
    tANI_U32                maxNumPreAuth, val;
    tSirMacAuthFrameBody    *pRxAuthFrameBody, rxAuthFrame, authFrame;
    tpSirMacMgmtHdr         pHdr;
    tCfgWepKeyEntry         *pKeyMapEntry = NULL;
    struct tLimPreAuthNode  *pAuthNode;
    tLimMlmAuthInd          mlmAuthInd;
    tANI_U8                 decryptResult;
    tANI_U8                 *pChallenge;
    tANI_U32                key_length=8;
    tANI_U8                 challengeTextArray[SIR_MAC_AUTH_CHALLENGE_LENGTH];
    tpDphHashNode           pStaDs = NULL;
    tANI_U16                assocId = 0;
    tANI_U16                currSeqNo = 0;
    /* Added For BT -AMP support */
    // Get pointer to Authentication frame header and body


    pHdr = WDA_GET_RX_MAC_HEADER(pRxPacketInfo);
    frameLen = WDA_GET_RX_PAYLOAD_LEN(pRxPacketInfo);


    if (!frameLen)
    {
        // Log error
        limLog(pMac, LOGE,
               FL("received Authentication frame with no body from "));
        limPrintMacAddr(pMac, pHdr->sa, LOGE);

        return;
    }

    if (limIsGroupAddr(pHdr->sa))
    {
        // Received Auth frame from a BC/MC address
        // Log error and ignore it
       limLog(pMac, LOGE,
               FL("received Auth frame from a BC/MC address - "));
       limPrintMacAddr(pMac, pHdr->sa, LOGE);

        return;
    }
    currSeqNo = (pHdr->seqControl.seqNumHi << 4) | (pHdr->seqControl.seqNumLo);
    limLog(pMac, LOG1,
               FL("Sessionid: %d System role : %d limMlmState: %d :Auth "
               "Frame Received: BSSID: "MAC_ADDRESS_STR " (RSSI %d)"),
               psessionEntry->peSessionId, psessionEntry->limSystemRole,
               psessionEntry->limMlmState, MAC_ADDR_ARRAY(pHdr->bssId),
               (uint)abs((tANI_S8)WDA_GET_RX_RSSI_DB(pRxPacketInfo)));

    pBody = WDA_GET_RX_MPDU_DATA(pRxPacketInfo);

    //PELOG3(sirDumpBuf(pMac, SIR_LIM_MODULE_ID, LOG3, (tANI_U8*)pBd, ((tpHalBufDesc) pBd)->mpduDataOffset + frameLen);)

    //Restore default failure timeout
    if (VOS_P2P_CLIENT_MODE == psessionEntry->pePersona && psessionEntry->defaultAuthFailureTimeout)
    {
        limLog(pMac, LOG1, FL("Restore default failure timeout"));
        ccmCfgSetInt(pMac,WNI_CFG_AUTHENTICATE_FAILURE_TIMEOUT ,
                          psessionEntry->defaultAuthFailureTimeout, NULL, eANI_BOOLEAN_FALSE);
    }

    /// Determine if WEP bit is set in the FC or received MAC header
    if (pHdr->fc.wep)
    {
        /**
         * WEP bit is set in FC of MAC header.
         */

        // If TKIP counter measures enabled issue Deauth frame to station
        if ((psessionEntry->bTkipCntrMeasActive) && (psessionEntry->limSystemRole == eLIM_AP_ROLE))
        {
            PELOGE( limLog(pMac, LOGE,
               FL("Tkip counter measures Enabled, sending Deauth frame to")); )
            limPrintMacAddr(pMac, pHdr->sa, LOGE);

            limSendDeauthMgmtFrame( pMac, eSIR_MAC_MIC_FAILURE_REASON,
                                    pHdr->sa, psessionEntry, FALSE );
            return;
        }

        // Extract key ID from IV (most 2 bits of 4th byte of IV)

        keyId = (*(pBody + 3)) >> 6;

        /**
         * On STA in infrastructure BSS, Authentication frames received
         * with WEP bit set in the FC must be rejected with challenge
         * failure status code (wierd thing in the spec - this should have
         * been rejected with unspecified failure or unexpected assertion
         * of wep bit (this status code does not exist though) or
         * Out-of-sequence-Authentication-Frame status code.
         */

        if (psessionEntry->limSystemRole == eLIM_STA_ROLE || psessionEntry->limSystemRole == eLIM_BT_AMP_STA_ROLE)
        {
            authFrame.authAlgoNumber = eSIR_SHARED_KEY;
            authFrame.authTransactionSeqNumber = SIR_MAC_AUTH_FRAME_4;
            authFrame.authStatusCode = eSIR_MAC_CHALLENGE_FAILURE_STATUS;
            // Log error
            PELOGE(limLog(pMac, LOGE,
                   FL("received Authentication frame with wep bit set on "
                   "role=%d "MAC_ADDRESS_STR),
                   psessionEntry->limSystemRole, MAC_ADDR_ARRAY(pHdr->sa) );)
            limSendAuthMgmtFrame(pMac, &authFrame,
                                 pHdr->sa,
                                 LIM_NO_WEP_IN_FC,psessionEntry);
            return;
        }

        if (frameLen < LIM_ENCR_AUTH_BODY_LEN)
        {
            // Log error
            limLog(pMac, LOGE,
                   FL("Not enough size [%d] to decrypt received Auth frame"),
                   frameLen);
            limPrintMacAddr(pMac, pHdr->sa, LOGE);

            return;
        }
        if(psessionEntry->limSystemRole == eLIM_AP_ROLE)
        {
            val = psessionEntry->privacy;
        }
        else
        // Accept Authentication frame only if Privacy is implemented
        if (wlan_cfgGetInt(pMac, WNI_CFG_PRIVACY_ENABLED,
                      &val) != eSIR_SUCCESS)
        {
            /**
             * Could not get Privacy option
             * from CFG. Log error.
             */
            limLog(pMac, LOGP, FL("could not retrieve Privacy option"));
        }

        cfgPrivacyOptImp = (tANI_U8)val;
        if (cfgPrivacyOptImp)
        {
            /**
             * Privacy option is implemented.
             * Check if the received frame is Authentication
             * frame3 and there is a context for requesting STA.
             * If not, reject with unspecified failure status code
             */
            pAuthNode = limSearchPreAuthList(pMac, pHdr->sa);

            if (pAuthNode == NULL)
            {
                // Log error
                PELOGE(limLog(pMac, LOGE,
                       FL("received Authentication frame from peer that has "
                       "no preauth context with WEP bit set "MAC_ADDRESS_STR),
                       MAC_ADDR_ARRAY(pHdr->sa));)

                /**
                 * No 'pre-auth' context exists for this STA that sent
                 * an Authentication frame with FC bit set.
                 * Send Auth frame4 with 'out of sequence' status code.
                 */
                authFrame.authAlgoNumber = eSIR_SHARED_KEY;
                authFrame.authTransactionSeqNumber =
                SIR_MAC_AUTH_FRAME_4;
                authFrame.authStatusCode =
                eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;

                limSendAuthMgmtFrame(pMac, &authFrame,
                                     pHdr->sa,
                                     LIM_NO_WEP_IN_FC,psessionEntry);

                return;
            }
            else
            {
                /// Change the auth-response timeout
                limDeactivateAndChangePerStaIdTimer(pMac,
                                                    eLIM_AUTH_RSP_TIMER,
                                                    pAuthNode->authNodeIdx);

                /// 'Pre-auth' status exists for STA
                if ((pAuthNode->mlmState !=
                     eLIM_MLM_WT_AUTH_FRAME3_STATE) &&
                    (pAuthNode->mlmState !=
                     eLIM_MLM_AUTH_RSP_TIMEOUT_STATE))
                {
                    // Log error
                    PELOGE(limLog(pMac, LOGE,
                           FL("received Authentication frame from peer that is "
                           "in state %d "MAC_ADDRESS_STR),
                            pAuthNode->mlmState, MAC_ADDR_ARRAY(pHdr->sa));)

                    /**
                     * Should not have received Authentication frame
                     * with WEP bit set in FC in other states.
                     * Reject by sending Authenticaton frame with
                     * out of sequence Auth frame status code.
                     */

                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;
                    authFrame.authTransactionSeqNumber =
                    SIR_MAC_AUTH_FRAME_4;
                    authFrame.authStatusCode =
                    eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;

                    limSendAuthMgmtFrame(pMac, &authFrame,
                                         pHdr->sa,
                                         LIM_NO_WEP_IN_FC,psessionEntry);

                    return;
                }
            }

            /**
             * Check if there exists a key mappping key
             * for the STA that sent Authentication frame
             */
            pKeyMapEntry = limLookUpKeyMappings(pHdr->sa);

            if (pKeyMapEntry)
            {
                if (!pKeyMapEntry->wepOn)
                {
                    // Log error
                    PELOGE(limLog(pMac, LOGE,
                           FL("received Auth frame3 from peer that has NULL "
                           "key map entry "
                           MAC_ADDRESS_STR),MAC_ADDR_ARRAY(pHdr->sa));)

                    /**
                     * Key Mapping entry has null key.
                     * Send Authentication frame
                     * with challenge failure status code
                     */
                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;
                    authFrame.authTransactionSeqNumber =
                    SIR_MAC_AUTH_FRAME_4;
                    authFrame.authStatusCode =
                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;

                    limSendAuthMgmtFrame(pMac, &authFrame,
                                         pHdr->sa,
                                         LIM_NO_WEP_IN_FC,psessionEntry);

                    return;
                } // if (!pKeyMapEntry->wepOn)
                else
                {
                    decryptResult = limDecryptAuthFrame(pMac, pKeyMapEntry->key,
                                                        pBody,
                                                        plainBody,
                                                        key_length,
                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH));
                    if (decryptResult == LIM_DECRYPT_ICV_FAIL)
                    {
                        /// ICV failure
                        PELOGW(limLog(pMac, LOGW, FL("=====> decryptResult == "
                        "LIM_DECRYPT_ICV_FAIL ..."));)
                        // Log error
                        PELOGE(limLog(pMac, LOGE,
                               FL("received Authentication frame from peer "
                               "that failed decryption, Addr "
                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)

                        limDeletePreAuthNode(pMac,
                                             pHdr->sa);
                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;
                        authFrame.authTransactionSeqNumber =
                        SIR_MAC_AUTH_FRAME_4;
                        authFrame.authStatusCode =
                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;

                        limSendAuthMgmtFrame(
                                            pMac, &authFrame,
                                            pHdr->sa,
                                            LIM_NO_WEP_IN_FC,psessionEntry);


                        return;
                    }

                    if ( ( sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,
                         &rxAuthFrame)!=eSIR_SUCCESS ) ||
                         ( !isAuthValid(pMac, &rxAuthFrame,psessionEntry) ) )
                    {
                        PELOGE(limLog(pMac, LOGE,
                               FL("failed to convert Auth Frame to structure "
                               "or Auth is not valid "));)
                        return;
                    }


                } // end if (pKeyMapEntry->key == NULL)
            } // if keyMappings has entry
            else
            {

                val = SIR_MAC_KEY_LENGTH;

                if(psessionEntry->limSystemRole == eLIM_AP_ROLE)
                {
                    tpSirKeys pKey;
                    pKey =  &psessionEntry->WEPKeyMaterial[keyId].key[0];
                    vos_mem_copy(defaultKey, pKey->key, pKey->keyLength);
                    val = pKey->keyLength;
                }
                else
                if (wlan_cfgGetStr(pMac, (tANI_U16) (WNI_CFG_WEP_DEFAULT_KEY_1 + keyId),
                              defaultKey, &val) != eSIR_SUCCESS)
                {
                    /// Could not get Default key from CFG.
                    //Log error.
                    limLog(pMac, LOGP,
                           FL("could not retrieve Default key"));

                    /**
                     * Send Authentication frame
                     * with challenge failure status code
                     */

                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;
                    authFrame.authTransactionSeqNumber =
                    SIR_MAC_AUTH_FRAME_4;
                    authFrame.authStatusCode =
                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;

                    limSendAuthMgmtFrame(pMac, &authFrame,
                                         pHdr->sa,
                                         LIM_NO_WEP_IN_FC,psessionEntry);

                    return;
                }

                    key_length=val;

                    decryptResult = limDecryptAuthFrame(pMac, defaultKey,
                                                        pBody,
                                                        plainBody,
                                                        key_length,
                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH));
                    if (decryptResult == LIM_DECRYPT_ICV_FAIL)
                    {
                        PELOGW(limLog(pMac, LOGW, FL("=====> decryptResult == "
                        "LIM_DECRYPT_ICV_FAIL ..."));)
                        // Log error
                        PELOGE(limLog(pMac, LOGE,
                               FL("received Authentication frame from peer that "
                               "failed decryption: "
                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)
                        /// ICV failure
                        limDeletePreAuthNode(pMac,
                                             pHdr->sa);
                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;
                        authFrame.authTransactionSeqNumber =
                        SIR_MAC_AUTH_FRAME_4;
                        authFrame.authStatusCode =
                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;

                        limSendAuthMgmtFrame(
                                            pMac, &authFrame,
                                            pHdr->sa,
                                            LIM_NO_WEP_IN_FC,psessionEntry);

                        return;
                    }
                    if ( ( sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,
                           &rxAuthFrame)!=eSIR_SUCCESS ) ||
                        ( !isAuthValid(pMac, &rxAuthFrame, psessionEntry) ) )
                    {
                        limLog(pMac, LOGE,
                               FL("failed to convert Auth Frame to structure "
                               "or Auth is not valid "));
                        return;
                    }
            } // End of check for Key Mapping/Default key presence
        }
        else
        {
            // Log error
            PELOGE(limLog(pMac, LOGE,
                   FL("received Authentication frame3 from peer that while "
                   "privacy option is turned OFF "
                   MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)
            /**
             * Privacy option is not implemented.
             * So reject Authentication frame received with
             * WEP bit set by sending Authentication frame
             * with 'challenge failure' status code. This is
             * another strange thing in the spec. Status code
             * should have been 'unsupported algorithm' status code.
             */

            authFrame.authAlgoNumber = eSIR_SHARED_KEY;
            authFrame.authTransactionSeqNumber =
            SIR_MAC_AUTH_FRAME_4;
            authFrame.authStatusCode =
            eSIR_MAC_CHALLENGE_FAILURE_STATUS;

            limSendAuthMgmtFrame(pMac, &authFrame,
                                 pHdr->sa,
                                 LIM_NO_WEP_IN_FC,psessionEntry);

            return;
        } // else if (wlan_cfgGetInt(CFG_PRIVACY_OPTION_IMPLEMENTED))
    } // if (fc.wep)
    else
    {


        if ( ( sirConvertAuthFrame2Struct(pMac, pBody,
            frameLen, &rxAuthFrame)!=eSIR_SUCCESS ) ||
            ( !isAuthValid(pMac, &rxAuthFrame,psessionEntry) ) )
        {
            PELOGE(limLog(pMac, LOGE,
                   FL("failed to convert Auth Frame to structure or Auth is "
                   "not valid "));)
            return;
        }
    }


    pRxAuthFrameBody = &rxAuthFrame;

   PELOGW(limLog(pMac, LOGW,
           FL("Received Auth frame with type=%d seqnum=%d, status=%d (%d)"),
           (tANI_U32) pRxAuthFrameBody->authAlgoNumber,
           (tANI_U32) pRxAuthFrameBody->authTransactionSeqNumber,
           (tANI_U32) pRxAuthFrameBody->authStatusCode,(tANI_U32)pMac->lim.gLimNumPreAuthContexts);)

    switch (pRxAuthFrameBody->authTransactionSeqNumber)
    {
        case SIR_MAC_AUTH_FRAME_1:
            // AuthFrame 1

            pStaDs = dphLookupHashEntry(pMac, pHdr->sa,
                    &assocId, &psessionEntry->dph.dphHashTable);
            if (pStaDs)
            {
                tLimMlmDisassocReq      *pMlmDisassocReq = NULL;
                tLimMlmDeauthReq        *pMlmDeauthReq = NULL;
                tAniBool                 isConnected = eSIR_TRUE;

                pMlmDisassocReq = pMac->lim.limDisassocDeauthCnfReq.pMlmDisassocReq;
                if (pMlmDisassocReq &&
                        (vos_mem_compare((tANI_U8 *) pHdr->sa,
                                         (tANI_U8 *) &pMlmDisassocReq->peerMacAddr,
                                          sizeof(tSirMacAddr))))
                {
                    PELOGE(limLog(pMac, LOGE, FL("TODO:Ack for disassoc "
                                "frame is pending Issue delsta for "
                                MAC_ADDRESS_STR),
                                MAC_ADDR_ARRAY(pMlmDisassocReq->peerMacAddr));)
                    limProcessDisassocAckTimeout(pMac);
                    isConnected = eSIR_FALSE;
                }
                pMlmDeauthReq = pMac->lim.limDisassocDeauthCnfReq.pMlmDeauthReq;
                if (pMlmDeauthReq &&
                        (vos_mem_compare((tANI_U8 *) pHdr->sa,
                                         (tANI_U8 *) &pMlmDeauthReq->peerMacAddr,
                                         sizeof(tSirMacAddr))))
                {
                    PELOGE(limLog(pMac, LOGE, FL("TODO:Ack for deauth frame "
                                "is pending Issue delsta for "
                                MAC_ADDRESS_STR),
                                MAC_ADDR_ARRAY(pMlmDeauthReq->peerMacAddr));)
                    limProcessDeauthAckTimeout(pMac);
                    isConnected = eSIR_FALSE;
                }

                /* pStaDS != NULL and isConnected = 1 means the STA is already
                 * connected, But SAP received the Auth from that station.
                 * For non PMF connection send Deauth frame as STA will retry
                 * to connect back.
                 *
                 * For PMF connection the AP should not tear down or otherwise
                 * modify the state of the existing association until the
                 * SA-Query procedure determines that the original SA is
                 * invalid.
                 */
                if (isConnected
#ifdef WLAN_FEATURE_11W
                    && !pStaDs->rmfEnabled
#endif
                                          )
                {
                    limLog(pMac, LOGE,
                            FL("STA is already connected but received auth frame"
                                "Send the Deauth and lim Delete Station Context"
                                "(staId: %d, assocId: %d) "),
                            pStaDs->staIndex, assocId);
                    limSendDeauthMgmtFrame(pMac, eSIR_MAC_UNSPEC_FAILURE_REASON,
                            (tANI_U8 *) pHdr->sa, psessionEntry, FALSE);
                    limTriggerSTAdeletion(pMac, pStaDs, psessionEntry);
                    return;
                }
            }

            /// Check if there exists pre-auth context for this STA
            pAuthNode = limSearchPreAuthList(pMac, pHdr->sa);
            if (pAuthNode)
            {
                /// Pre-auth context exists for the STA
                if (pHdr->fc.retry == 0 || pAuthNode->seqNo != currSeqNo)
                {
                    /**
                     * STA is initiating brand-new Authentication
                     * sequence after local Auth Response timeout.
                     * Or STA retrying to transmit First Auth frame due to packet drop OTA
                     * Delete Pre-auth node and fall through.
                     */
                    if(pAuthNode->fTimerStarted)
                    {
                        limDeactivateAndChangePerStaIdTimer(pMac,
                                                    eLIM_AUTH_RSP_TIMER,
                                                    pAuthNode->authNodeIdx);
                    }
                    PELOGE(limLog(pMac, LOGE, FL("STA is initiating brand-new "
                    "Authentication ..."));)
                    limDeletePreAuthNode(pMac,
                                         pHdr->sa);
                    /**
                     *  SAP Mode:Disassociate the station and
                     *  delete its entry if we have its entry
                     *  already and received "auth" from the
                     *  same station.
                     */

                    for (assocId = 0; assocId < psessionEntry->dph.dphHashTable.size; assocId++)// Softap dphHashTable.size = 8
                    {
                        pStaDs = dphGetHashEntry(pMac, assocId, &psessionEntry->dph.dphHashTable);

                        if (NULL == pStaDs)
                             continue;

                        if (pStaDs->valid)
                        {
                             if (vos_mem_compare((tANI_U8 *) &pStaDs->staAddr,
                                      (tANI_U8 *) &(pHdr->sa), (tANI_U8) (sizeof(tSirMacAddr))) )
                                  break;
                        }

                        pStaDs = NULL;
                    }

                    if (NULL != pStaDs
#ifdef WLAN_FEATURE_11W
                        && !pStaDs->rmfEnabled
#endif
                       )
                    {
                        PELOGE(limLog(pMac, LOGE, FL("lim Delete Station "
                        "Context (staId: %d, assocId: %d) "),pStaDs->staIndex,
                        assocId);)
                        limSendDeauthMgmtFrame(pMac,
                               eSIR_MAC_UNSPEC_FAILURE_REASON, (tANI_U8 *) pAuthNode->peerMacAddr, psessionEntry, FALSE);
                        limTriggerSTAdeletion(pMac, pStaDs, psessionEntry);
                        return;
                    }
                }
                else
                {
                    /*
                     * This can happen when first authentication frame is received
                     * but ACK lost at STA side, in this case 2nd auth frame is already
                     * in transmission queue
                     * */
                    PELOGE(limLog(pMac, LOGE, FL("STA is initiating "
                    "Authentication after ACK lost..."));)
                    return;
                }
            }
            if (wlan_cfgGetInt(pMac, WNI_CFG_MAX_NUM_PRE_AUTH,
                          (tANI_U32 *) &maxNumPreAuth) != eSIR_SUCCESS)
            {
                /**
                 * Could not get MaxNumPreAuth
                 * from CFG. Log error.
                 */
                limLog(pMac, LOGP,
                       FL("could not retrieve MaxNumPreAuth"));
            }
            if (pMac->lim.gLimNumPreAuthContexts == maxNumPreAuth)
            {
                PELOGE(limLog(pMac, LOGE, FL("Max number of "
                    "preauth context reached"));)
                /**
                 * Maximum number of pre-auth contexts
                 * reached. Send Authentication frame
                 * with unspecified failure
                 */
                authFrame.authAlgoNumber =
                pRxAuthFrameBody->authAlgoNumber;
                authFrame.authTransactionSeqNumber =
                pRxAuthFrameBody->authTransactionSeqNumber + 1;
                authFrame.authStatusCode =
                eSIR_MAC_UNSPEC_FAILURE_STATUS;

                limSendAuthMgmtFrame(pMac, &authFrame,
                                     pHdr->sa,
                                     LIM_NO_WEP_IN_FC,psessionEntry);

                return;
            }
            /// No Pre-auth context exists for the STA.
            if (limIsAuthAlgoSupported(
                                      pMac,
                                      (tAniAuthType)
                                      pRxAuthFrameBody->authAlgoNumber, psessionEntry))
            {
                switch (pRxAuthFrameBody->authAlgoNumber)
                {
                    case eSIR_OPEN_SYSTEM:
                        PELOGW(limLog(pMac, LOGW, FL("=======> eSIR_OPEN_SYSTEM  ..."));)
                        /// Create entry for this STA in pre-auth list
                        pAuthNode = limAcquireFreePreAuthNode(pMac, &pMac->lim.gLimPreAuthTimerTable);
                        if (pAuthNode == NULL)
                        {
                            // Log error
                            limLog(pMac, LOGW,
                                   FL("Max pre-auth nodes reached "));
                            limPrintMacAddr(pMac, pHdr->sa, LOGW);

                            return;
                        }

                        limLog(pMac, LOG1,
                               FL("Alloc new data: peer "MAC_ADDRESS_STR),
                                                 MAC_ADDR_ARRAY(pHdr->sa));

                        vos_mem_copy((tANI_U8 *) pAuthNode->peerMacAddr,
                                      pHdr->sa,
                                      sizeof(tSirMacAddr));

                        pAuthNode->mlmState =
                        eLIM_MLM_AUTHENTICATED_STATE;
                        pAuthNode->authType = (tAniAuthType)
                                              pRxAuthFrameBody->authAlgoNumber;
                        pAuthNode->fSeen = 0;
                        pAuthNode->fTimerStarted = 0;
                        pAuthNode->seqNo = ((pHdr->seqControl.seqNumHi << 4) |
                                            (pHdr->seqControl.seqNumLo));
                        limAddPreAuthNode(pMac, pAuthNode);

                        /**
                         * Send Authenticaton frame with Success
                         * status code.
                         */

                        authFrame.authAlgoNumber =
                        pRxAuthFrameBody->authAlgoNumber;
                        authFrame.authTransactionSeqNumber =
                        pRxAuthFrameBody->authTransactionSeqNumber + 1;
                        authFrame.authStatusCode = eSIR_MAC_SUCCESS_STATUS;
                        limSendAuthMgmtFrame(
                                            pMac, &authFrame,
                                            pHdr->sa,
                                            LIM_NO_WEP_IN_FC,psessionEntry);

                        /// Send Auth indication to SME

                        vos_mem_copy((tANI_U8 *) mlmAuthInd.peerMacAddr,
                                     (tANI_U8 *) pHdr->sa,
                                     sizeof(tSirMacAddr));
                        mlmAuthInd.authType = (tAniAuthType)
                                              pRxAuthFrameBody->authAlgoNumber;
                        mlmAuthInd.sessionId = psessionEntry->smeSessionId;

                        limPostSmeMessage(pMac,
                                          LIM_MLM_AUTH_IND,
                                          (tANI_U32 *) &mlmAuthInd);
                        break;

                    case eSIR_SHARED_KEY:
                        PELOGW(limLog(pMac, LOGW, FL("=======> eSIR_SHARED_KEY  ..."));)
                        if(psessionEntry->limSystemRole == eLIM_AP_ROLE)
                        {
                            val = psessionEntry->privacy;
                        }
                        else
                        if (wlan_cfgGetInt(pMac, WNI_CFG_PRIVACY_ENABLED,
                                      &val) != eSIR_SUCCESS)
                        {
                            /**
                             * Could not get Privacy option
                             * from CFG. Log error.
                             */
                            limLog(pMac, LOGP,
                                   FL("could not retrieve Privacy option"));
                        }
                        cfgPrivacyOptImp = (tANI_U8)val;
                        if (!cfgPrivacyOptImp)
                        {
                            // Log error
                            PELOGE(limLog(pMac, LOGE,
                                   FL("received Auth frame for unsupported auth algorithm %d "
                                   MAC_ADDRESS_STR), pRxAuthFrameBody->authAlgoNumber,
                                   MAC_ADDR_ARRAY(pHdr->sa));)

                            /**
                             * Authenticator does not have WEP
                             * implemented.
                             * Reject by sending Authentication frame
                             * with Auth algorithm not supported status
                             * code.
                             */

                            authFrame.authAlgoNumber =
                            pRxAuthFrameBody->authAlgoNumber;
                            authFrame.authTransactionSeqNumber =
                            pRxAuthFrameBody->authTransactionSeqNumber + 1;
                            authFrame.authStatusCode =
                            eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS;

                            limSendAuthMgmtFrame(
                                                pMac, &authFrame,
                                                pHdr->sa,
                                                LIM_NO_WEP_IN_FC,psessionEntry);

                            return;
                        }
                        else
                        {
                            // Create entry for this STA
                            //in pre-auth list
                            pAuthNode = limAcquireFreePreAuthNode(pMac, &pMac->lim.gLimPreAuthTimerTable);
                            if (pAuthNode == NULL)
                            {
                                // Log error
                                limLog(pMac, LOGW,
                                       FL("Max pre-auth nodes reached "));
                                limPrintMacAddr(pMac, pHdr->sa, LOGW);

                                return;
                            }

                            vos_mem_copy((tANI_U8 *) pAuthNode->peerMacAddr,
                                          pHdr->sa,
                                          sizeof(tSirMacAddr));

                            pAuthNode->mlmState =
                            eLIM_MLM_WT_AUTH_FRAME3_STATE;
                            pAuthNode->authType =
                            (tAniAuthType)
                            pRxAuthFrameBody->authAlgoNumber;
                            pAuthNode->fSeen = 0;
                            pAuthNode->fTimerStarted = 0;
                            pAuthNode->seqNo = ((pHdr->seqControl.seqNumHi << 4) |
                                                (pHdr->seqControl.seqNumLo));
                            limAddPreAuthNode(pMac, pAuthNode);

                            limLog(pMac, LOG1,
                                   FL("Alloc new data: id %d peer "MAC_ADDRESS_STR),
                                    pAuthNode->authNodeIdx, MAC_ADDR_ARRAY(pHdr->sa));

                            /// Create and activate Auth Response timer
                            if (tx_timer_change_context(&pAuthNode->timer, pAuthNode->authNodeIdx) != TX_SUCCESS)
                            {
                                /// Could not start Auth response timer.
                                // Log error
                                limLog(pMac, LOGP,
                                   FL("Unable to chg context auth response timer for peer "));
                                limPrintMacAddr(pMac, pHdr->sa, LOGP);

                                /**
                                 * Send Authenticaton frame with
                                 * unspecified failure status code.
                                 */

                                authFrame.authAlgoNumber =
                                        pRxAuthFrameBody->authAlgoNumber;
                                authFrame.authTransactionSeqNumber =
                                        pRxAuthFrameBody->authTransactionSeqNumber + 1;
                                authFrame.authStatusCode =
                                        eSIR_MAC_UNSPEC_FAILURE_STATUS;

                                limSendAuthMgmtFrame(pMac, &authFrame,
                                                     pHdr->sa,
                                                     LIM_NO_WEP_IN_FC,psessionEntry);

                                limDeletePreAuthNode(pMac, pHdr->sa);
                                return;
                            }

                            limActivateAuthRspTimer(pMac, pAuthNode);

                            pAuthNode->fTimerStarted = 1;

                            // get random bytes and use as
                            // challenge text
                            // TODO
                            //if( !VOS_IS_STATUS_SUCCESS( vos_rand_get_bytes( 0, (tANI_U8 *)challengeTextArray, SIR_MAC_AUTH_CHALLENGE_LENGTH ) ) )
                            {
                               limLog(pMac, LOGE,FL("Challenge text "
                               "preparation failed in limProcessAuthFrame"));
                            }

                            pChallenge = pAuthNode->challengeText;

                            vos_mem_copy(pChallenge,
                                        (tANI_U8 *) challengeTextArray,
                                         sizeof(challengeTextArray));

                            /**
                             * Sending Authenticaton frame with challenge.
                             */

                            authFrame.authAlgoNumber =
                            pRxAuthFrameBody->authAlgoNumber;
                            authFrame.authTransactionSeqNumber =
                            pRxAuthFrameBody->authTransactionSeqNumber + 1;
                            authFrame.authStatusCode =
                            eSIR_MAC_SUCCESS_STATUS;
                            authFrame.type   = SIR_MAC_CHALLENGE_TEXT_EID;
                            authFrame.length = SIR_MAC_AUTH_CHALLENGE_LENGTH;
                            vos_mem_copy(authFrame.challengeText,
                                         pAuthNode->challengeText,
                                         SIR_MAC_AUTH_CHALLENGE_LENGTH);

                            limSendAuthMgmtFrame(
                                                pMac, &authFrame,
                                                pHdr->sa,
                                                LIM_NO_WEP_IN_FC,psessionEntry);
                        } // if (wlan_cfgGetInt(CFG_PRIVACY_OPTION_IMPLEMENTED))

                        break;

                    default:
                         // Log error
                       PELOGE( limLog(pMac, LOGE,
                               FL("received Auth frame for unsupported auth "
                               "algorithm %d "MAC_ADDRESS_STR),
                               pRxAuthFrameBody->authAlgoNumber,
                               MAC_ADDR_ARRAY(pHdr->sa));)

                        /**
                         * Responding party does not support the
                         * authentication algorithm requested by
                         * sending party.
                         * Reject by sending Authentication frame
                         * with auth algorithm not supported status code
                         */

                        authFrame.authAlgoNumber =
                        pRxAuthFrameBody->authAlgoNumber;
                        authFrame.authTransactionSeqNumber =
                        pRxAuthFrameBody->authTransactionSeqNumber + 1;
                        authFrame.authStatusCode =
                        eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS;

                        limSendAuthMgmtFrame(
                                            pMac, &authFrame,
                                            pHdr->sa,
                                            LIM_NO_WEP_IN_FC,psessionEntry);

                        return;
                } // end switch(pRxAuthFrameBody->authAlgoNumber)
            } // if (limIsAuthAlgoSupported(pRxAuthFrameBody->authAlgoNumber))
            else
            {
                // Log error
                PELOGE(limLog(pMac, LOGE,
                       FL("received Authentication frame for unsupported auth "
                       "algorithm %d "MAC_ADDRESS_STR),
                       pRxAuthFrameBody->authAlgoNumber,
                       MAC_ADDR_ARRAY(pHdr->sa));)

                /**
                 * Responding party does not support the
                 * authentication algorithm requested by sending party.
                 * Reject Authentication with StatusCode=13.
                 */
                authFrame.authAlgoNumber =
                pRxAuthFrameBody->authAlgoNumber;
                authFrame.authTransactionSeqNumber =
                pRxAuthFrameBody->authTransactionSeqNumber + 1;
                authFrame.authStatusCode =
                eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS;

                limSendAuthMgmtFrame(pMac, &authFrame,
                                     pHdr->sa,
                                     LIM_NO_WEP_IN_FC,psessionEntry);

                return;
            } //end if (limIsAuthAlgoSupported(pRxAuthFrameBody->authAlgoNumber))
            break;

        case SIR_MAC_AUTH_FRAME_2:
            // AuthFrame 2

            if (psessionEntry->limMlmState != eLIM_MLM_WT_AUTH_FRAME2_STATE)
            {
                /**
                 * Received Authentication frame2 in an unexpected state.
                 * Log error and ignore the frame.
                 */

                // Log error
                limLog(pMac, LOG1,
                       FL("received Auth frame2 from peer in state %d, addr "),
                       psessionEntry->limMlmState);
                limPrintMacAddr(pMac, pHdr->sa, LOG1);

                return;
            }

            if ( !vos_mem_compare((tANI_U8 *) pHdr->sa,
                                  (tANI_U8 *) &pMac->lim.gpLimMlmAuthReq->peerMacAddr,
                                  sizeof(tSirMacAddr)) )
            {
                /**
                 * Received Authentication frame from an entity
                 * other than one request was initiated.
                 * Wait until Authentication Failure Timeout.
                 */

                // Log error
                PELOGW(limLog(pMac, LOGW,
                       FL("received Auth frame2 from unexpected peer "
                       MAC_ADDRESS_STR),
                       MAC_ADDR_ARRAY(pHdr->sa));)

                break;
            }

            if (pRxAuthFrameBody->authStatusCode ==
                eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS)
            {
                /**
                 * Interoperability workaround: Linksys WAP4400N is returning
                 * wrong authType in OpenAuth response in case of
                 * SharedKey AP configuration. Pretend we don't see that,
                 * so upper layer can fallback to SharedKey authType,
                 * and successfully connect to the AP.
                 */
                if (pRxAuthFrameBody->authAlgoNumber !=
                    pMac->lim.gpLimMlmAuthReq->authType)
                {
                    pRxAuthFrameBody->authAlgoNumber =
                    pMac->lim.gpLimMlmAuthReq->authType;
                }
            }

            if (pRxAuthFrameBody->authAlgoNumber !=
                pMac->lim.gpLimMlmAuthReq->authType)
            {
                /**
                 * Received Authentication frame with an auth
                 * algorithm other than one requested.
                 * Wait until Authentication Failure Timeout.
                 */

                // Log error
                PELOGW(limLog(pMac, LOGW,
                       FL("received Auth frame2 for unexpected auth algo number %d "
                       MAC_ADDRESS_STR), pRxAuthFrameBody->authAlgoNumber,
                       MAC_ADDR_ARRAY(pHdr->sa));)

                break;
            }

            if (pRxAuthFrameBody->authStatusCode ==
                eSIR_MAC_SUCCESS_STATUS)
            {
                if (pRxAuthFrameBody->authAlgoNumber ==
                    eSIR_OPEN_SYSTEM)
                {
                    psessionEntry->limCurrentAuthType = eSIR_OPEN_SYSTEM;

                    pAuthNode = limAcquireFreePreAuthNode(pMac, &pMac->lim.gLimPreAuthTimerTable);

                    if (pAuthNode == NULL)
                    {
                        // Log error
                        limLog(pMac, LOGW,
                               FL("Max pre-auth nodes reached "));
                        limPrintMacAddr(pMac, pHdr->sa, LOGW);

                        return;
                    }

                    limLog(pMac, LOG1,
                              FL("Alloc new data: peer "MAC_ADDRESS_STR),
                                                 MAC_ADDR_ARRAY(pHdr->sa));

                    vos_mem_copy((tANI_U8 *) pAuthNode->peerMacAddr,
                                 pMac->lim.gpLimMlmAuthReq->peerMacAddr,
                                 sizeof(tSirMacAddr));
                    pAuthNode->fTimerStarted = 0;
                    pAuthNode->authType = pMac->lim.gpLimMlmAuthReq->authType;
                    pAuthNode->seqNo = ((pHdr->seqControl.seqNumHi << 4) |
                                        (pHdr->seqControl.seqNumLo));
                    limAddPreAuthNode(pMac, pAuthNode);

                    limRestoreFromAuthState(pMac, eSIR_SME_SUCCESS,
                                            pRxAuthFrameBody->authStatusCode,psessionEntry);
                } // if (pRxAuthFrameBody->authAlgoNumber == eSIR_OPEN_SYSTEM)
                else
                {
                    // Shared key authentication

                    if(psessionEntry->limSystemRole == eLIM_AP_ROLE)
                    {
                        val = psessionEntry->privacy;
                    }
                    else
                    if (wlan_cfgGetInt(pMac, WNI_CFG_PRIVACY_ENABLED,
                                  &val) != eSIR_SUCCESS)
                    {
                        /**
                         * Could not get Privacy option
                         * from CFG. Log error.
                         */
                        limLog(pMac, LOGP,
                               FL("could not retrieve Privacy option"));
                    }
                    cfgPrivacyOptImp = (tANI_U8)val;
                    if (!cfgPrivacyOptImp)
                    {
                        /**
                         * Requesting STA does not have WEP implemented.
                         * Reject with unsupported authentication algorithm
                         * Status code and wait until auth failure timeout
                         */

                        // Log error
                       PELOGE( limLog(pMac, LOGE,
                               FL("received Auth frame from peer for "
                               "unsupported auth algo %d "
                               MAC_ADDRESS_STR), pRxAuthFrameBody->authAlgoNumber,
                               MAC_ADDR_ARRAY(pHdr->sa));)

                        authFrame.authAlgoNumber =
                        pRxAuthFrameBody->authAlgoNumber;
                        authFrame.authTransactionSeqNumber =
                        pRxAuthFrameBody->authTransactionSeqNumber + 1;
                        authFrame.authStatusCode =
                        eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS;

                        limSendAuthMgmtFrame(pMac, &authFrame,
                                            pHdr->sa,
                                            LIM_NO_WEP_IN_FC,psessionEntry);
                        return;
                    }
                    else
                    {

                        if (pRxAuthFrameBody->type !=
                            SIR_MAC_CHALLENGE_TEXT_EID)
                        {
                            // Log error
                            PELOGE(limLog(pMac, LOGE,
                                   FL("received Auth frame with invalid "
                                   "challenge text IE"));)

                            return;
                        }

                        /**
                         * Check if there exists a key mappping key
                         * for the STA that sent Authentication frame
                         */
                        pKeyMapEntry = limLookUpKeyMappings(
                                                           pHdr->sa);

                        if (pKeyMapEntry)
                        {
                            if (pKeyMapEntry->key == NULL)
                            {
                                // Log error
                                PELOGE(limLog(pMac, LOGE,
                                       FL("received Auth frame from peer when "
                                       "key mapping key is NULL"MAC_ADDRESS_STR),
                                       MAC_ADDR_ARRAY(pHdr->sa));)

                                /**
                                 * Key Mapping entry has null key.
                                 * Send Auth frame with
                                 * challenge failure status code
                                 */
                                authFrame.authAlgoNumber =
                                pRxAuthFrameBody->authAlgoNumber;
                                authFrame.authTransactionSeqNumber =
                                pRxAuthFrameBody->authTransactionSeqNumber + 1;
                                authFrame.authStatusCode =
                                eSIR_MAC_CHALLENGE_FAILURE_STATUS;

                                limSendAuthMgmtFrame(pMac, &authFrame,
                                                     pHdr->sa,
                                                     LIM_NO_WEP_IN_FC,psessionEntry);

                                limRestoreFromAuthState(pMac, eSIR_SME_NO_KEY_MAPPING_KEY_FOR_PEER,
                                                              eSIR_MAC_UNSPEC_FAILURE_REASON,psessionEntry);

                                return;
                            } // if (pKeyMapEntry->key == NULL)
                            else
                            {
                                ((tpSirMacAuthFrameBody) plainBody)->authAlgoNumber =
                                sirSwapU16ifNeeded(pRxAuthFrameBody->authAlgoNumber);
                                ((tpSirMacAuthFrameBody) plainBody)->authTransactionSeqNumber =
                                sirSwapU16ifNeeded((tANI_U16) (pRxAuthFrameBody->authTransactionSeqNumber + 1));
                                ((tpSirMacAuthFrameBody) plainBody)->authStatusCode = eSIR_MAC_SUCCESS_STATUS;
                                ((tpSirMacAuthFrameBody) plainBody)->type   = SIR_MAC_CHALLENGE_TEXT_EID;
                                ((tpSirMacAuthFrameBody) plainBody)->length = SIR_MAC_AUTH_CHALLENGE_LENGTH;
                                vos_mem_copy((tANI_U8 *) ((tpSirMacAuthFrameBody) plainBody)->challengeText,
                                              pRxAuthFrameBody->challengeText,
                                              SIR_MAC_AUTH_CHALLENGE_LENGTH);

                                limEncryptAuthFrame(pMac, 0,
                                                    pKeyMapEntry->key,
                                                    plainBody,
                                                    encrAuthFrame,key_length);

                                psessionEntry->limMlmState = eLIM_MLM_WT_AUTH_FRAME4_STATE;
                                MTRACE(macTrace(pMac, TRACE_CODE_MLM_STATE, psessionEntry->peSessionId, psessionEntry->limMlmState));

                                limSendAuthMgmtFrame(pMac,
                                                     (tpSirMacAuthFrameBody) encrAuthFrame,
                                                     pHdr->sa,
                                                     LIM_WEP_IN_FC,psessionEntry);

                                break;
                            } // end if (pKeyMapEntry->key == NULL)
                        } // if (pKeyMapEntry)
                        else
                        {
                            if (wlan_cfgGetInt(pMac, WNI_CFG_WEP_DEFAULT_KEYID,
                                          &val) != eSIR_SUCCESS)
                            {
                                /**
                                 * Could not get Default keyId
                                 * from CFG. Log error.
                                 */
                                limLog(pMac, LOGP,
                                       FL("could not retrieve Default keyId"));
                            }
                            keyId = (tANI_U8)val;

                            val = SIR_MAC_KEY_LENGTH;

                            if(psessionEntry->limSystemRole == eLIM_AP_ROLE)
                            {
                                tpSirKeys pKey;
                                pKey =  &psessionEntry->WEPKeyMaterial[keyId].key[0];
                                vos_mem_copy(defaultKey, pKey->key, pKey->keyLength);
                            }
                            else
                            if (wlan_cfgGetStr(pMac, (tANI_U16) (WNI_CFG_WEP_DEFAULT_KEY_1 + keyId),
                                          defaultKey,
                                          &val)
                                != eSIR_SUCCESS)
                            {
                                /// Could not get Default key from CFG.
                                //Log error.
                                limLog(pMac, LOGP,
                                       FL("could not retrieve Default key"));

                                authFrame.authAlgoNumber =
                                pRxAuthFrameBody->authAlgoNumber;
                                authFrame.authTransactionSeqNumber =
                                pRxAuthFrameBody->authTransactionSeqNumber + 1;
                                authFrame.authStatusCode =
                                eSIR_MAC_CHALLENGE_FAILURE_STATUS;

                                limSendAuthMgmtFrame(
                                                    pMac, &authFrame,
                                                    pHdr->sa,
                                                    LIM_NO_WEP_IN_FC,psessionEntry);

                                limRestoreFromAuthState(pMac, eSIR_SME_INVALID_WEP_DEFAULT_KEY,
                                                              eSIR_MAC_UNSPEC_FAILURE_REASON,psessionEntry);

                                break;
                            }
                                key_length=val;
                                ((tpSirMacAuthFrameBody) plainBody)->authAlgoNumber =
                                sirSwapU16ifNeeded(pRxAuthFrameBody->authAlgoNumber);
                                ((tpSirMacAuthFrameBody) plainBody)->authTransactionSeqNumber =
                                sirSwapU16ifNeeded((tANI_U16) (pRxAuthFrameBody->authTransactionSeqNumber + 1));
                                ((tpSirMacAuthFrameBody) plainBody)->authStatusCode = eSIR_MAC_SUCCESS_STATUS;
                                ((tpSirMacAuthFrameBody) plainBody)->type   = SIR_MAC_CHALLENGE_TEXT_EID;
                                ((tpSirMacAuthFrameBody) plainBody)->length = SIR_MAC_AUTH_CHALLENGE_LENGTH;
                                vos_mem_copy((tANI_U8 *) ((tpSirMacAuthFrameBody) plainBody)->challengeText,
                                              pRxAuthFrameBody->challengeText,
                                              SIR_MAC_AUTH_CHALLENGE_LENGTH);

                                limEncryptAuthFrame(pMac, keyId,
                                                    defaultKey,
                                                    plainBody,
                                                    encrAuthFrame,key_length);

                                psessionEntry->limMlmState =
                                eLIM_MLM_WT_AUTH_FRAME4_STATE;
                                MTRACE(macTrace(pMac, TRACE_CODE_MLM_STATE, psessionEntry->peSessionId, psessionEntry->limMlmState));

                                limSendAuthMgmtFrame(pMac,
                                                     (tpSirMacAuthFrameBody) encrAuthFrame,
                                                     pHdr->sa,
                                                     LIM_WEP_IN_FC,psessionEntry);

                                break;
                        } // end if (pKeyMapEntry)
                    } // end if (!wlan_cfgGetInt(CFG_PRIVACY_OPTION_IMPLEMENTED))
                } // end if (pRxAuthFrameBody->authAlgoNumber == eSIR_OPEN_SYSTEM)
            } // if (pRxAuthFrameBody->authStatusCode == eSIR_MAC_SUCCESS_STATUS)
            else
            {
                /**
                 * Authentication failure.
                 * Return Auth confirm with received failure code to SME
                 */

                // Log error
                PELOGE(limLog(pMac, LOGE,
                       FL("received Auth frame from peer with failure code %d "
                       MAC_ADDRESS_STR), pRxAuthFrameBody->authStatusCode,
                       MAC_ADDR_ARRAY(pHdr->sa));)

                limRestoreFromAuthState(pMac, eSIR_SME_AUTH_REFUSED,
                                              pRxAuthFrameBody->authStatusCode,psessionEntry);
            } // end if (pRxAuthFrameBody->authStatusCode == eSIR_MAC_SUCCESS_STATUS)

            break;

        case SIR_MAC_AUTH_FRAME_3:
            // AuthFrame 3

            if (pRxAuthFrameBody->authAlgoNumber != eSIR_SHARED_KEY)
            {
                // Log error
                PELOGE(limLog(pMac, LOGE,
                       FL("received Auth frame3 from peer with auth algo "
                       "number %d "MAC_ADDRESS_STR),
                       pRxAuthFrameBody->authAlgoNumber,
                       MAC_ADDR_ARRAY(pHdr->sa));)

                /**
                 * Received Authentication frame3 with algorithm other than
                 * Shared Key authentication type. Reject with Auth frame4
                 * with 'out of sequence' status code.
                 */
                authFrame.authAlgoNumber = eSIR_SHARED_KEY;
                authFrame.authTransactionSeqNumber =
                SIR_MAC_AUTH_FRAME_4;
                authFrame.authStatusCode =
                eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;

                limSendAuthMgmtFrame(pMac, &authFrame,
                                     pHdr->sa,
                                     LIM_NO_WEP_IN_FC,psessionEntry);

                return;
            }

            if (psessionEntry->limSystemRole == eLIM_AP_ROLE || psessionEntry->limSystemRole == eLIM_BT_AMP_AP_ROLE ||
                psessionEntry->limSystemRole == eLIM_STA_IN_IBSS_ROLE)
            {
                /**
                 * Check if wep bit was set in FC. If not set,
                 * reject with Authentication frame4 with
                 * 'challenge failure' status code.
                 */
                if (!pHdr->fc.wep)
                {
                    // Log error
                    PELOGE(limLog(pMac, LOGE,
                           FL("received Auth frame3 from peer with no WEP bit "
                           "set "MAC_ADDRESS_STR),
                           MAC_ADDR_ARRAY(pHdr->sa));)

                    /// WEP bit is not set in FC of Auth Frame3
                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;
                    authFrame.authTransactionSeqNumber =
                    SIR_MAC_AUTH_FRAME_4;
                    authFrame.authStatusCode =
                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;

                    limSendAuthMgmtFrame(pMac, &authFrame,
                                         pHdr->sa,
                                         LIM_NO_WEP_IN_FC,psessionEntry);

                    return;
                }

                pAuthNode = limSearchPreAuthList(pMac,
                                                pHdr->sa);
                if (pAuthNode == NULL)
                {
                     // Log error
                    PELOGE(limLog(pMac, LOGW,
                           FL("received AuthFrame3 from peer that has no "
                           "preauth context "MAC_ADDRESS_STR),
                            MAC_ADDR_ARRAY(pHdr->sa));)

                    /**
                     * No 'pre-auth' context exists for
                     * this STA that sent an Authentication
                     * frame3.
                     * Send Auth frame4 with 'out of sequence'
                     * status code.
                     */
                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;
                    authFrame.authTransactionSeqNumber =
                    SIR_MAC_AUTH_FRAME_4;
                    authFrame.authStatusCode =
                    eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;

                    limSendAuthMgmtFrame(pMac, &authFrame,
                                         pHdr->sa,
                                         LIM_NO_WEP_IN_FC,psessionEntry);

                    return;
                }

                if (pAuthNode->mlmState == eLIM_MLM_AUTH_RSP_TIMEOUT_STATE)
                {
                    // Log error
                    limLog(pMac, LOGW,
                           FL("auth response timer timedout for peer "
                           MAC_ADDRESS_STR),MAC_ADDR_ARRAY(pHdr->sa));
                    /**
                     * Received Auth Frame3 after Auth Response timeout.
                     * Reject by sending Auth Frame4 with
                     * Auth respone timeout Status Code.
                     */
                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;
                    authFrame.authTransactionSeqNumber =
                    SIR_MAC_AUTH_FRAME_4;
                    authFrame.authStatusCode =
                    eSIR_MAC_AUTH_RSP_TIMEOUT_STATUS;

                    limSendAuthMgmtFrame(
                                        pMac, &authFrame,
                                        pHdr->sa,
                                        LIM_NO_WEP_IN_FC,psessionEntry);

                    /// Delete pre-auth context of STA
                    limDeletePreAuthNode(pMac,
                                         pHdr->sa);

                    return;
                } // end switch (pAuthNode->mlmState)

                if (pRxAuthFrameBody->authStatusCode != eSIR_MAC_SUCCESS_STATUS)
                {
                    /**
                     * Received Authenetication Frame 3 with status code
                     * other than success. Wait until Auth response timeout
                     * to delete STA context.
                     */

                    // Log error
                    PELOGE(limLog(pMac, LOGE,
                           FL("received Auth frame3 from peer with status code %d "
                           MAC_ADDRESS_STR), pRxAuthFrameBody->authStatusCode,
                           MAC_ADDR_ARRAY(pHdr->sa));)

                    return;
                }

                /**
                 * Check if received challenge text is same as one sent in
                 * Authentication frame3
                 */

                if (vos_mem_compare(pRxAuthFrameBody->challengeText,
                                    pAuthNode->challengeText,
                                    SIR_MAC_AUTH_CHALLENGE_LENGTH))
                {
                    /// Challenge match. STA is autheticated !

                    /// Delete Authentication response timer if running
                    limDeactivateAndChangePerStaIdTimer(pMac,
                                                        eLIM_AUTH_RSP_TIMER,
                                                        pAuthNode->authNodeIdx);

                    pAuthNode->fTimerStarted = 0;
                    pAuthNode->mlmState = eLIM_MLM_AUTHENTICATED_STATE;

                    /**
                     * Send Authentication Frame4 with 'success' Status Code.
                     */
                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;
                    authFrame.authTransactionSeqNumber =
                        SIR_MAC_AUTH_FRAME_4;
                    authFrame.authStatusCode = eSIR_MAC_SUCCESS_STATUS;

                    limSendAuthMgmtFrame(pMac, &authFrame,
                                         pHdr->sa,
                                         LIM_NO_WEP_IN_FC,psessionEntry);

                    /// Send Auth indication to SME
                    vos_mem_copy((tANI_U8 *) mlmAuthInd.peerMacAddr,
                                 (tANI_U8 *) pHdr->sa,
                                  sizeof(tSirMacAddr));
                    mlmAuthInd.authType = (tAniAuthType)
                                          pRxAuthFrameBody->authAlgoNumber;
                    mlmAuthInd.sessionId = psessionEntry->smeSessionId;

                    limPostSmeMessage(pMac,
                                      LIM_MLM_AUTH_IND,
                                      (tANI_U32 *) &mlmAuthInd);

                    break;
                }
                else
                {
                     // Log error
                    PELOGE( limLog(pMac, LOGW,
                                   FL("Challenge failure for peer "
                                   MAC_ADDRESS_STR),
                                   MAC_ADDR_ARRAY(pHdr->sa));)
                    /**
                     * Challenge Failure.
                     * Send Authentication frame4 with 'challenge failure'
                     * status code and wait until Auth response timeout to
                     * delete STA context.
                     */

                    authFrame.authAlgoNumber =
                        pRxAuthFrameBody->authAlgoNumber;
                    authFrame.authTransactionSeqNumber =
                        SIR_MAC_AUTH_FRAME_4;
                    authFrame.authStatusCode =
                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;

                    limSendAuthMgmtFrame(pMac, &authFrame,
                                         pHdr->sa,
                                         LIM_NO_WEP_IN_FC,psessionEntry);

                    return;
                }
            } // if (pMac->lim.gLimSystemRole == eLIM_AP_ROLE || ...

            break;

        case SIR_MAC_AUTH_FRAME_4:
            // AuthFrame 4
            if (psessionEntry->limMlmState != eLIM_MLM_WT_AUTH_FRAME4_STATE)
            {
                /**
                 * Received Authentication frame4 in an unexpected state.
                 * Log error and ignore the frame.
                 */

                // Log error
                limLog(pMac, LOG1,
                       FL("received unexpected Auth frame4 from peer in state "
                       "%d, addr "MAC_ADDRESS_STR), psessionEntry->limMlmState,
                       MAC_ADDR_ARRAY(pHdr->sa));

                return;
            }

            if (pRxAuthFrameBody->authAlgoNumber != eSIR_SHARED_KEY)
            {
                /**
                 * Received Authentication frame4 with algorithm other than
                 * Shared Key authentication type.
                 * Wait until Auth failure timeout to report authentication
                 * failure to SME.
                 */

                // Log error
                PELOGE(limLog(pMac, LOGE,
                       FL("received Auth frame4 from peer with invalid auth "
                       "algo %d "MAC_ADDRESS_STR), pRxAuthFrameBody->authAlgoNumber,
                       MAC_ADDR_ARRAY(pHdr->sa));)

                return;
            }

            if ( !vos_mem_compare((tANI_U8 *) pHdr->sa,
                                  (tANI_U8 *) &pMac->lim.gpLimMlmAuthReq->peerMacAddr,
                                  sizeof(tSirMacAddr)) )
            {
                /**
                 * Received Authentication frame from an entity
                 * other than one to which request was initiated.
                 * Wait until Authentication Failure Timeout.
                 */

                // Log error
                PELOGE(limLog(pMac, LOGW,
                       FL("received Auth frame4 from unexpected peer "
                       MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)

                break;
            }

            if (pRxAuthFrameBody->authAlgoNumber !=
                pMac->lim.gpLimMlmAuthReq->authType)
            {
                /**
                 * Received Authentication frame with an auth algorithm
                 * other than one requested.
                 * Wait until Authentication Failure Timeout.
                 */

                PELOGE(limLog(pMac, LOGE,
                       FL("received Authentication frame from peer with "
                       "invalid auth seq number %d "
                       MAC_ADDRESS_STR), pRxAuthFrameBody->authTransactionSeqNumber,
                       MAC_ADDR_ARRAY(pHdr->sa));)

                break;
            }

            if (pRxAuthFrameBody->authStatusCode ==
                eSIR_MAC_SUCCESS_STATUS)
            {
                /**
                 * Authentication Success !
                 * Inform SME of same.
                 */
                psessionEntry->limCurrentAuthType = eSIR_SHARED_KEY;

                pAuthNode = limAcquireFreePreAuthNode(pMac, &pMac->lim.gLimPreAuthTimerTable);
                if (pAuthNode == NULL)
                {
                    // Log error
                    limLog(pMac, LOGW,
                           FL("Max pre-auth nodes reached "));
                    limPrintMacAddr(pMac, pHdr->sa, LOGW);

                    return;
                }
                limLog(pMac, LOG1,
                         FL("Alloc new data: peer " MAC_ADDRESS_STR),
                                              MAC_ADDR_ARRAY(pHdr->sa));

                vos_mem_copy((tANI_U8 *) pAuthNode->peerMacAddr,
                             pMac->lim.gpLimMlmAuthReq->peerMacAddr,
                             sizeof(tSirMacAddr));
                pAuthNode->fTimerStarted = 0;
                pAuthNode->authType = pMac->lim.gpLimMlmAuthReq->authType;
                pAuthNode->seqNo = ((pHdr->seqControl.seqNumHi << 4) |
                                    (pHdr->seqControl.seqNumLo));
                limAddPreAuthNode(pMac, pAuthNode);

                limRestoreFromAuthState(pMac, eSIR_SME_SUCCESS,
                                              pRxAuthFrameBody->authStatusCode,psessionEntry);

            } // if (pRxAuthFrameBody->authStatusCode == eSIR_MAC_SUCCESS_STATUS)
            else
            {
                /**
                 * Authentication failure.
                 * Return Auth confirm with received failure code to SME
                 */

                // Log error
                PELOGE(limLog(pMac, LOGE, FL("Authentication failure from peer "
                       MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)

                limRestoreFromAuthState(pMac, eSIR_SME_AUTH_REFUSED,
                                              pRxAuthFrameBody->authStatusCode,psessionEntry);
            } // end if (pRxAuthFrameBody->Status == 0)

            break;

        default:
            /// Invalid Authentication Frame received. Ignore it.

            // Log error
            PELOGE(limLog(pMac, LOGE,
                   FL("received Auth frame from peer with invalid auth seq "
                   "number %d " MAC_ADDRESS_STR),
                   pRxAuthFrameBody->authTransactionSeqNumber,
                   MAC_ADDR_ARRAY(pHdr->sa));)

            break;
    } // end switch (pRxAuthFrameBody->authTransactionSeqNumber)
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
3,7
5,6
5,7
6,7
8,9
10,11
10,12
11,12
13,14
13,15
16,17
16,18
17,18
19,20
21,22
21,23
21,24
21,25
21,26
21,27
21,28
21,29
21,30
21,31
21,32
21,33
21,34
21,35
21,36
21,37
21,38
21,39
21,40
21,41
21,42
21,43
21,44
21,45
21,46
21,47
21,48
22,23
23,24
23,25
23,26
23,27
23,28
23,29
23,30
24,25
26,27
26,28
29,30
31,32
33,34
33,35
35,36
36,37
38,39
38,40
40,41
41,42
43,44
43,45
45,46
47,48
48,49
48,50
49,50
51,52
53,54
54,55
54,56
54,57
55,56
57,58
59,60
61,62
62,63
62,64
62,65
62,66
63,64
65,66
65,67
68,69
70,71
72,73
73,74
73,75
74,75
76,77
78,79
79,80
79,81
80,81
82,83
82,84
82,85
85,86
86,87
88,89
89,90
89,91
90,91
92,93
92,94
95,96
96,97
96,98
97,98
99,100
101,102
102,103
102,104
103,104
105,106
107,108
108,109
108,110
109,110
111,112
111,113
114,115
115,116
115,117
116,117
118,119
118,120
120,121
122,123
123,124
123,125
124,125
126,127
126,128
128,129
129,130
131,132
132,133
132,134
133,134
135,136
135,137
137,138
138,139
140,141
141,142
141,143
142,143
144,145
144,146
146,147
148,149
149,150
149,151
150,151
152,153
152,154
154,155
156,157
157,158
157,159
158,159
160,161
160,162
161,162
163,164
165,166
166,167
166,168
167,168
169,170
169,171
170,171
172,173
174,175
174,176
175,176
176,177
178,179
178,180
178,181
179,180
180,181
180,182
180,183
180,184
181,182
183,184
185,186
187,188
187,189
188,189
191,192
192,193
192,194
192,195
192,196
193,194
195,196
197,198
197,199
198,199
201,202
204,205
204,206
205,206
205,207
206,207
208,209
208,210
209,210
212,213
212,214
212,215
213,214
214,215
214,216
214,217
214,218
215,216
217,218
219,220
221,222
221,223
222,223
225,226
226,227
226,228
226,229
226,230
227,228
229,230
231,232
231,233
232,233
235,236
238,239
239,240
239,241
240,241
242,243
242,244
243,244
244,245
244,246
245,246
245,247
246,247
246,248
247,248
252,253
253,254
253,255
254,255
254,256
255,256
259,260
260,261
261,262
261,263
262,263
264,265
264,266
265,266
267,268
269,270
269,271
270,271
270,272
271,272
271,273
272,273
274,275
274,276
275,276
278,279
278,280
279,280
282,283
282,284
283,284
284,285
284,286
284,287
284,288
285,286
287,288
289,290
291,292
291,293
292,293
295,296
296,297
296,298
296,299
296,300
296,301
296,302
297,298
299,300
301,302
303,304
303,305
304,305
307,308
309,310
311,312
311,313
311,314
312,313
312,314
313,314
313,315
314,315
318,319
318,320
318,321
318,322
318,323
318,324
318,325
319,320
319,321
320,321
320,322
321,322
322,323
322,324
323,324
326,327
327,328
327,329
328,329
328,330
329,330
332,333
334,335
334,336
334,337
334,338
335,336
336,337
337,338
338,339
338,340
338,341
338,342
338,343
338,344
339,340
341,342
343,344
345,346
345,347
346,347
349,350
351,352
354,355
355,356
355,357
356,357
358,359
358,360
359,360
360,361
361,362
362,363
362,364
363,364
367,368
367,369
368,369
368,370
369,370
369,371
370,371
370,372
371,372
374,375
376,377
376,378
377,378
377,379
378,379
381,382
383,384
383,385
383,386
383,387
383,388
383,389
384,385
385,386
385,387
386,387
386,388
387,388
390,391
392,393
393,394
393,395
394,395
394,396
395,396
398,399
400,401
401,402
401,403
402,403
402,404
403,404
406,407
408,409
409,410
411,412
411,413
412,413
412,414
413,414
415,416
417,418
417,419
417,420
418,419
419,420
419,421
419,422
419,423
419,424
420,421
422,423
424,425
426,427
426,428
427,428
430,431
432,433
433,434
433,435
433,436
433,437
434,435
436,437
438,439
438,440
439,440
442,443
445,446
445,447
445,448
446,447
446,448
447,448
447,449
448,449
451,452
453,454
454,455
455,456
455,457
456,457
458,459
458,460
459,460
462,463
462,464
463,464
463,465
464,465
464,466
464,467
464,468
465,466
467,468
469,470
471,472
472,473
474,475
476,477
477,478
478,479
478,480
478,481
478,482
479,480
481,482
483,484
485,486
485,487
486,487
489,490
490,491
490,492
491,492
493,494
493,495
494,495
494,496
495,496
498,499
500,501
500,502
500,503
501,502
503,504
503,505
503,506
503,507
504,505
505,506
505,507
506,507
508,509
508,510
508,511
509,510
511,512
513,514
513,515
514,515
517,518
517,519
517,520
518,519
518,520
519,520
521,522
523,524
523,525
523,526
523,527
523,528
523,529
524,525
525,526
526,527
527,528
527,529
528,529
528,530
529,530
532,533
534,535
535,536
535,537
536,537
536,538
537,538
540,541
542,543
543,544
543,545
543,546
543,547
543,548
543,549
544,545
546,547
548,549
549,550
551,552
551,553
552,553
555,556
557,558
560,561
560,562
561,562
562,563
562,564
562,565
562,566
563,564
565,566
567,568
569,570
569,571
570,571
573,574
573,575
574,575
574,576
575,576
576,577
576,578
577,578
577,579
578,579
581,582
583,584
584,585
584,586
585,586
585,587
586,587
589,590
591,592
591,593
591,594
591,595
591,596
591,597
592,593
593,594
594,595
595,596
595,597
596,597
596,598
597,598
600,601
602,603
603,604
603,605
604,605
604,606
605,606
608,609
610,611
611,612
611,613
611,614
611,615
611,616
611,617
612,613
614,615
616,617
617,618
619,620
619,621
620,621
623,624
625,626
628,629
629,630
629,631
630,631
632,633
632,634
633,634
635,636
635,637
636,637
639,640
639,641
639,642
640,641
642,643
643,644
643,645
643,646
644,645
645,646
645,647
646,647
649,650
649,651
649,652
649,653
649,654
649,655
650,651
651,652
652,653
653,654
653,655
654,655
654,656
655,656
658,659
660,661
661,662
661,663
662,663
662,664
663,664
666,667
668,669
669,670
669,671
669,672
669,673
669,674
669,675
670,671
672,673
674,675
675,676
677,678
677,679
678,679
681,682
683,684
686,687
686,688
686,689
687,688
688,689
688,690
689,690
691,692
691,693
691,694
691,695
691,696
691,697
691,698
692,693
694,695
696,697
696,698
697,698
700,701
702,703
704,705
706,707
706,708
707,708
708,709
710,711
710,712
711,712
713,714
715,716
715,717
716,717
716,718
717,718
719,720
721,722
721,723
721,724
721,725
721,726
721,727
721,728
721,729
722,723
723,724
724,725
725,726
726,727
726,728
727,728
727,729
728,729
731,732
733,734
734,735
734,736
735,736
735,737
736,737
739,740
741,742
742,743
742,744
743,744
743,745
744,745
747,748
749,750
750,751
750,752
750,753
750,754
750,755
750,756
751,752
753,754
755,756
756,757
758,759
758,760
759,760
762,763
764,765
767,768
767,769
768,769
768,770
769,770
770,771
770,772
771,772
771,773
771,774
771,775
771,776
772,773
774,775
776,777
778,779
778,780
779,780
782,783
783,784
785,786
787,788
788,789
789,790
789,791
789,792
789,793
790,791
792,793
794,795
795,796
797,798
799,800
799,801
800,801
801,802
802,803
802,804
802,805
802,806
802,807
802,808
803,804
804,805
804,806
805,806
807,808
809,810
809,811
809,812
810,811
810,812
811,812
811,813
812,813
815,816
817,818
817,819
817,820
817,821
818,819
819,820
819,821
820,821
822,823
824,825
825,826
825,827
826,827
828,829
829,830
829,831
830,831
830,832
831,832
831,833
832,833
832,834
833,834
836,837
840,841
841,842
841,843
841,844
841,845
842,843
844,845
846,847
846,848
847,848
850,851
850,852
851,852
854,855
855,856
855,857
856,857
858,859
858,860
859,860
862,863
862,864
863,864
863,865
864,865
864,866
864,867
864,868
864,869
865,866
867,868
869,870
869,871
870,871
871,872
873,874
873,875
874,875
876,877
878,879
880,881
881,882
883,884
885,886
885,887
885,888
885,889
885,890
885,891
886,887
887,888
887,889
887,890
887,891
888,889
890,891
892,893
894,895
894,896
895,896
898,899
899,900
899,901
900,901
900,902
901,902
904,905
906,907
907,908
907,909
908,909
908,910
909,910
912,913
914,915
915,916
915,917
916,917
916,918
917,918
920,921
922,923
923,924
923,925
923,926
923,927
923,928
923,929
924,925
926,927
928,929
929,930
931,932
931,933
932,933
935,936
937,938
940,941
941,942
941,943
942,943
944,945
946,947
947,948
947,949
948,949
950,951
950,952
950,953
950,954
950,955
950,956
950,957
951,952
953,954
955,956
957,958
959,960
961,962
963,964
963,965
964,965
965,966
967,968
967,969
968,969
970,971
972,973
972,974
973,974
973,975
974,975
976,977
978,979
978,980
978,981
978,982
978,983
978,984
978,985
978,986
979,980
980,981
981,982
982,983
983,984
983,985
984,985
984,986
985,986
988,989
990,991
991,992
991,993
992,993
992,994
993,994
996,997
998,999
999,1000
999,1001
1000,1001
1000,1002
1001,1002
1004,1005
1006,1007
1007,1008
1007,1009
1007,1010
1007,1011
1007,1012
1007,1013
1008,1009
1010,1011
1012,1013
1013,1014
1015,1016
1015,1017
1016,1017
1019,1020
1021,1022
1024,1025
1024,1026
1025,1026
1025,1027
1026,1027
1027,1028
1027,1029
1028,1029
1028,1030
1028,1031
1028,1032
1028,1033
1029,1030
1031,1032
1033,1034
1035,1036
1035,1037
1036,1037
1039,1040
1040,1041
1042,1043
1044,1045
1045,1046
1046,1047
1046,1048
1046,1049
1046,1050
1047,1048
1049,1050
1051,1052
1052,1053
1054,1055
1056,1057
1056,1058
1057,1058
1058,1059
1058,1060
1058,1061
1058,1062
1059,1060
1061,1062
1063,1064
1065,1066
1065,1067
1066,1067
1070,1071
1070,1072
1070,1073
1070,1074
1070,1075
1070,1076
1071,1072
1072,1073
1073,1074
1074,1075
1074,1076
1075,1076
1075,1077
1076,1077
1079,1080
1081,1082
1082,1083
1082,1084
1083,1084
1083,1085
1084,1085
1087,1088
1089,1090
1090,1091
1090,1092
1090,1093
1090,1094
1090,1095
1090,1096
1091,1092
1093,1094
1095,1096
1096,1097
1098,1099
1098,1100
1099,1100
1102,1103
1104,1105
1107,1108
1108,1109
1108,1110
1109,1110
1109,1111
1110,1111
1111,1112
1111,1113
1112,1113
1112,1114
1112,1115
1112,1116
1112,1117
1113,1114
1115,1116
1117,1118
1119,1120
1121,1122
1122,1123
1124,1125
1126,1127
1127,1128
1128,1129
1128,1130
1128,1131
1128,1132
1129,1130
1131,1132
1133,1134
1134,1135
1136,1137
1138,1139
1138,1140
1139,1140
1140,1141
1141,1142
1142,1143
1142,1144
1143,1144
1145,1146
1146,1147
1148,1149
-----nextToken-----
2,4,7,9,12,14,15,18,20,25,27,28,30,32,34,37,39,42,44,46,50,52,56,58,60,64,66,67,69,71,75,77,81,83,84,87,91,93,94,98,100,104,106,110,112,113,117,119,121,125,127,130,134,136,139,143,145,147,151,153,155,159,162,164,168,171,173,177,182,184,186,189,190,194,196,199,200,202,203,207,210,211,216,218,220,223,224,228,230,233,234,236,237,241,248,249,250,251,256,257,258,263,266,268,273,276,277,280,281,286,288,290,293,294,298,300,302,305,306,308,310,315,316,317,324,325,330,331,333,340,342,344,347,348,350,352,353,357,364,365,366,372,373,375,379,380,382,388,389,391,396,397,399,404,405,407,410,414,416,421,423,425,428,429,431,435,437,440,441,443,444,449,450,452,457,460,461,466,468,470,473,475,480,482,484,487,488,492,496,497,499,502,507,510,512,515,516,520,522,530,531,533,538,539,541,545,547,550,553,554,556,558,559,564,566,568,571,572,579,580,582,587,588,590,598,599,601,606,607,609,613,615,618,621,622,624,626,627,631,634,637,638,641,647,648,656,657,659,664,665,667,671,673,676,679,680,682,684,685,690,693,695,698,699,701,703,705,709,712,714,718,720,729,730,732,737,738,740,745,746,748,752,754,757,760,761,763,765,766,773,775,777,780,781,784,786,791,793,796,798,806,808,813,814,816,821,823,827,834,835,837,838,839,843,845,848,849,852,853,857,860,861,866,868,872,875,877,879,882,884,889,891,893,896,897,902,903,905,910,911,913,918,919,921,925,927,930,933,934,936,938,939,943,945,949,952,954,956,958,960,962,966,969,971,975,977,986,987,989,994,995,997,1002,1003,1005,1009,1011,1014,1017,1018,1020,1022,1023,1030,1032,1034,1037,1038,1041,1043,1048,1050,1053,1055,1060,1062,1064,1067,1068,1069,1077,1078,1080,1085,1086,1088,1092,1094,1097,1100,1101,1103,1105,1106,1114,1116,1118,1120,1123,1125,1130,1132,1135,1137,1144,1147
-----computeFrom-----
157,158
157,159
166,167
166,168
239,240
239,241
242,243
242,244
244,245
244,246
261,262
261,263
270,271
270,272
271,272
271,273
320,321
320,322
327,328
327,329
355,356
355,357
358,359
358,360
362,363
362,364
368,369
368,370
369,370
369,371
376,377
376,378
385,386
385,387
393,394
393,395
401,402
401,403
412,413
412,414
446,447
446,448
455,456
455,457
463,464
463,465
490,491
490,492
505,506
505,507
518,519
518,520
527,528
527,529
535,536
535,537
574,575
574,576
576,577
576,578
584,585
584,586
595,596
595,597
603,604
603,605
629,630
629,631
653,654
653,655
661,662
661,663
688,689
688,690
710,711
710,712
716,717
716,718
726,727
726,728
734,735
734,736
742,743
742,744
768,769
768,770
770,771
770,772
778,779
778,780
804,805
804,806
810,811
810,812
825,826
825,827
855,856
855,857
863,864
863,865
873,874
873,875
899,900
899,901
907,908
907,909
915,916
915,917
941,942
941,943
947,948
947,949
967,968
967,969
973,974
973,975
983,984
983,985
991,992
991,993
999,1000
999,1001
1025,1026
1025,1027
1027,1028
1027,1029
1035,1036
1035,1037
1074,1075
1074,1076
1082,1083
1082,1084
1109,1110
1109,1111
1111,1112
1111,1113
1142,1143
1142,1144
-----guardedBy-----
281,306
280,305
330,350
414,431
449,460
468,482
813,834
868,927
1050,1062
-----guardedByNegation-----
520,587
813,938
-----lastLexicalUse-----
813,938
-----jump-----
813,938
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;Declarator;Name;Declarator;Name;ArrayDeclarator;Name;ArrayModifier;IdExpression;Name;ArrayDeclarator;Name;ArrayModifier;IdExpression;Name;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;Declarator;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;ArrayDeclarator;Name;ArrayModifier;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;ReturnStatement;IfStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;ReturnStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;ProblemStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;IfStatement;FieldReference;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;IfStatement;BinaryExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ProblemStatement;ProblemStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;ReturnStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;UnaryExpression;UnaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ProblemStatement;ProblemStatement;ReturnStatement;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;ReturnStatement;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ProblemStatement;ProblemStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;ReturnStatement;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ProblemStatement;ProblemStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;ReturnStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;IdExpression;Name;CompoundStatement;IfStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ProblemStatement;ProblemStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;ReturnStatement;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;FunctionCallExpression;UnaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ProblemStatement;ProblemStatement;ProblemStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;ReturnStatement;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ProblemStatement;ProblemStatement;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;FieldReference;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;UnaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;ReturnStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;FunctionCallExpression;UnaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ProblemStatement;ProblemStatement;ProblemStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;ReturnStatement;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;ReturnStatement;CompoundStatement;ProblemStatement;ProblemStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;ReturnStatement;CompoundStatement;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ProblemStatement;ProblemStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ProblemStatement;ProblemStatement;
-----ast_node-----
voidlimProcessAuthFrame(tpAniSirGlobal pMac, tANI_U8 *pRxPacketInfo, tpPESession psessionEntry){    tANI_U8                 *pBody, keyId, cfgPrivacyOptImp,                            defaultKey[SIR_MAC_KEY_LENGTH],                            encrAuthFrame[LIM_ENCR_AUTH_BODY_LEN],                            plainBody[256];    tANI_U16                frameLen;    //tANI_U32                authRspTimeout, maxNumPreAuth, val;    tANI_U32                maxNumPreAuth, val;    tSirMacAuthFrameBody    *pRxAuthFrameBody, rxAuthFrame, authFrame;    tpSirMacMgmtHdr         pHdr;    tCfgWepKeyEntry         *pKeyMapEntry = NULL;    struct tLimPreAuthNode  *pAuthNode;    tLimMlmAuthInd          mlmAuthInd;    tANI_U8                 decryptResult;    tANI_U8                 *pChallenge;    tANI_U32                key_length=8;    tANI_U8                 challengeTextArray[SIR_MAC_AUTH_CHALLENGE_LENGTH];    tpDphHashNode           pStaDs = NULL;    tANI_U16                assocId = 0;    tANI_U16                currSeqNo = 0;    /* Added For BT -AMP support */    // Get pointer to Authentication frame header and body    pHdr = WDA_GET_RX_MAC_HEADER(pRxPacketInfo);    frameLen = WDA_GET_RX_PAYLOAD_LEN(pRxPacketInfo);    if (!frameLen)    {        // Log error        limLog(pMac, LOGE,               FL("received Authentication frame with no body from "));        limPrintMacAddr(pMac, pHdr->sa, LOGE);        return;    }    if (limIsGroupAddr(pHdr->sa))    {        // Received Auth frame from a BC/MC address        // Log error and ignore it       limLog(pMac, LOGE,               FL("received Auth frame from a BC/MC address - "));       limPrintMacAddr(pMac, pHdr->sa, LOGE);        return;    }    currSeqNo = (pHdr->seqControl.seqNumHi << 4) | (pHdr->seqControl.seqNumLo);    limLog(pMac, LOG1,               FL("Sessionid: %d System role : %d limMlmState: %d :Auth "               "Frame Received: BSSID: "MAC_ADDRESS_STR " (RSSI %d)"),               psessionEntry->peSessionId, psessionEntry->limSystemRole,               psessionEntry->limMlmState, MAC_ADDR_ARRAY(pHdr->bssId),               (uint)abs((tANI_S8)WDA_GET_RX_RSSI_DB(pRxPacketInfo)));    pBody = WDA_GET_RX_MPDU_DATA(pRxPacketInfo);    //PELOG3(sirDumpBuf(pMac, SIR_LIM_MODULE_ID, LOG3, (tANI_U8*)pBd, ((tpHalBufDesc) pBd)->mpduDataOffset + frameLen);)    //Restore default failure timeout    if (VOS_P2P_CLIENT_MODE == psessionEntry->pePersona && psessionEntry->defaultAuthFailureTimeout)    {        limLog(pMac, LOG1, FL("Restore default failure timeout"));        ccmCfgSetInt(pMac,WNI_CFG_AUTHENTICATE_FAILURE_TIMEOUT ,                          psessionEntry->defaultAuthFailureTimeout, NULL, eANI_BOOLEAN_FALSE);    }    /// Determine if WEP bit is set in the FC or received MAC header    if (pHdr->fc.wep)    {        /**         * WEP bit is set in FC of MAC header.         */        // If TKIP counter measures enabled issue Deauth frame to station        if ((psessionEntry->bTkipCntrMeasActive) && (psessionEntry->limSystemRole == eLIM_AP_ROLE))        {            PELOGE( limLog(pMac, LOGE,               FL("Tkip counter measures Enabled, sending Deauth frame to")); )            limPrintMacAddr(pMac, pHdr->sa, LOGE);            limSendDeauthMgmtFrame( pMac, eSIR_MAC_MIC_FAILURE_REASON,                                    pHdr->sa, psessionEntry, FALSE );            return;        }        // Extract key ID from IV (most 2 bits of 4th byte of IV)        keyId = (*(pBody + 3)) >> 6;        /**         * On STA in infrastructure BSS, Authentication frames received         * with WEP bit set in the FC must be rejected with challenge         * failure status code (wierd thing in the spec - this should have         * been rejected with unspecified failure or unexpected assertion         * of wep bit (this status code does not exist though) or         * Out-of-sequence-Authentication-Frame status code.         */        if (psessionEntry->limSystemRole == eLIM_STA_ROLE || psessionEntry->limSystemRole == eLIM_BT_AMP_STA_ROLE)        {            authFrame.authAlgoNumber = eSIR_SHARED_KEY;            authFrame.authTransactionSeqNumber = SIR_MAC_AUTH_FRAME_4;            authFrame.authStatusCode = eSIR_MAC_CHALLENGE_FAILURE_STATUS;            // Log error            PELOGE(limLog(pMac, LOGE,                   FL("received Authentication frame with wep bit set on "                   "role=%d "MAC_ADDRESS_STR),                   psessionEntry->limSystemRole, MAC_ADDR_ARRAY(pHdr->sa) );)            limSendAuthMgmtFrame(pMac, &authFrame,                                 pHdr->sa,                                 LIM_NO_WEP_IN_FC,psessionEntry);            return;        }        if (frameLen < LIM_ENCR_AUTH_BODY_LEN)        {            // Log error            limLog(pMac, LOGE,                   FL("Not enough size [%d] to decrypt received Auth frame"),                   frameLen);            limPrintMacAddr(pMac, pHdr->sa, LOGE);            return;        }        if(psessionEntry->limSystemRole == eLIM_AP_ROLE)        {            val = psessionEntry->privacy;        }        else        // Accept Authentication frame only if Privacy is implemented        if (wlan_cfgGetInt(pMac, WNI_CFG_PRIVACY_ENABLED,                      &val) != eSIR_SUCCESS)        {            /**             * Could not get Privacy option             * from CFG. Log error.             */            limLog(pMac, LOGP, FL("could not retrieve Privacy option"));        }        cfgPrivacyOptImp = (tANI_U8)val;        if (cfgPrivacyOptImp)        {            /**             * Privacy option is implemented.             * Check if the received frame is Authentication             * frame3 and there is a context for requesting STA.             * If not, reject with unspecified failure status code             */            pAuthNode = limSearchPreAuthList(pMac, pHdr->sa);            if (pAuthNode == NULL)            {                // Log error                PELOGE(limLog(pMac, LOGE,                       FL("received Authentication frame from peer that has "                       "no preauth context with WEP bit set "MAC_ADDRESS_STR),                       MAC_ADDR_ARRAY(pHdr->sa));)                /**                 * No 'pre-auth' context exists for this STA that sent                 * an Authentication frame with FC bit set.                 * Send Auth frame4 with 'out of sequence' status code.                 */                authFrame.authAlgoNumber = eSIR_SHARED_KEY;                authFrame.authTransactionSeqNumber =                SIR_MAC_AUTH_FRAME_4;                authFrame.authStatusCode =                eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                limSendAuthMgmtFrame(pMac, &authFrame,                                     pHdr->sa,                                     LIM_NO_WEP_IN_FC,psessionEntry);                return;            }            else            {                /// Change the auth-response timeout                limDeactivateAndChangePerStaIdTimer(pMac,                                                    eLIM_AUTH_RSP_TIMER,                                                    pAuthNode->authNodeIdx);                /// 'Pre-auth' status exists for STA                if ((pAuthNode->mlmState !=                     eLIM_MLM_WT_AUTH_FRAME3_STATE) &&                    (pAuthNode->mlmState !=                     eLIM_MLM_AUTH_RSP_TIMEOUT_STATE))                {                    // Log error                    PELOGE(limLog(pMac, LOGE,                           FL("received Authentication frame from peer that is "                           "in state %d "MAC_ADDRESS_STR),                            pAuthNode->mlmState, MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * Should not have received Authentication frame                     * with WEP bit set in FC in other states.                     * Reject by sending Authenticaton frame with                     * out of sequence Auth frame status code.                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }            }            /**             * Check if there exists a key mappping key             * for the STA that sent Authentication frame             */            pKeyMapEntry = limLookUpKeyMappings(pHdr->sa);            if (pKeyMapEntry)            {                if (!pKeyMapEntry->wepOn)                {                    // Log error                    PELOGE(limLog(pMac, LOGE,                           FL("received Auth frame3 from peer that has NULL "                           "key map entry "                           MAC_ADDRESS_STR),MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * Key Mapping entry has null key.                     * Send Authentication frame                     * with challenge failure status code                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                } // if (!pKeyMapEntry->wepOn)                else                {                    decryptResult = limDecryptAuthFrame(pMac, pKeyMapEntry->key,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH));                    if (decryptResult == LIM_DECRYPT_ICV_FAIL)                    {                        /// ICV failure                        PELOGW(limLog(pMac, LOGW, FL("=====> decryptResult == "                        "LIM_DECRYPT_ICV_FAIL ..."));)                        // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer "                               "that failed decryption, Addr "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                        limDeletePreAuthNode(pMac,                                             pHdr->sa);                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;                        authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                        authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }                    if ( ( sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                         &rxAuthFrame)!=eSIR_SUCCESS ) ||                         ( !isAuthValid(pMac, &rxAuthFrame,psessionEntry) ) )                    {                        PELOGE(limLog(pMac, LOGE,                               FL("failed to convert Auth Frame to structure "                               "or Auth is not valid "));)                        return;                    }                } // end if (pKeyMapEntry->key == NULL)            } // if keyMappings has entry            else            {                val = SIR_MAC_KEY_LENGTH;                if(psessionEntry->limSystemRole == eLIM_AP_ROLE)                {                    tpSirKeys pKey;                    pKey =  &psessionEntry->WEPKeyMaterial[keyId].key[0];                    vos_mem_copy(defaultKey, pKey->key, pKey->keyLength);                    val = pKey->keyLength;                }                else                if (wlan_cfgGetStr(pMac, (tANI_U16) (WNI_CFG_WEP_DEFAULT_KEY_1 + keyId),                              defaultKey, &val) != eSIR_SUCCESS)                {                    /// Could not get Default key from CFG.                    //Log error.                    limLog(pMac, LOGP,                           FL("could not retrieve Default key"));                    /**                     * Send Authentication frame                     * with challenge failure status code                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }                    key_length=val;                    decryptResult = limDecryptAuthFrame(pMac, defaultKey,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH));                    if (decryptResult == LIM_DECRYPT_ICV_FAIL)                    {                        PELOGW(limLog(pMac, LOGW, FL("=====> decryptResult == "                        "LIM_DECRYPT_ICV_FAIL ..."));)                        // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer that "                               "failed decryption: "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                        /// ICV failure                        limDeletePreAuthNode(pMac,                                             pHdr->sa);                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;                        authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                        authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }                    if ( ( sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                           &rxAuthFrame)!=eSIR_SUCCESS ) ||                        ( !isAuthValid(pMac, &rxAuthFrame, psessionEntry) ) )                    {                        limLog(pMac, LOGE,                               FL("failed to convert Auth Frame to structure "                               "or Auth is not valid "));                        return;                    }            } // End of check for Key Mapping/Default key presence        }        else        {            // Log error            PELOGE(limLog(pMac, LOGE,                   FL("received Authentication frame3 from peer that while "                   "privacy option is turned OFF "                   MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)            /**             * Privacy option is not implemented.             * So reject Authentication frame received with             * WEP bit set by sending Authentication frame             * with 'challenge failure' status code. This is             * another strange thing in the spec. Status code             * should have been 'unsupported algorithm' status code.             */            authFrame.authAlgoNumber = eSIR_SHARED_KEY;            authFrame.authTransactionSeqNumber =            SIR_MAC_AUTH_FRAME_4;            authFrame.authStatusCode =            eSIR_MAC_CHALLENGE_FAILURE_STATUS;            limSendAuthMgmtFrame(pMac, &authFrame,                                 pHdr->sa,                                 LIM_NO_WEP_IN_FC,psessionEntry);            return;        } // else if (wlan_cfgGetInt(CFG_PRIVACY_OPTION_IMPLEMENTED))    } // if (fc.wep)    else    {        if ( ( sirConvertAuthFrame2Struct(pMac, pBody,            frameLen, &rxAuthFrame)!=eSIR_SUCCESS ) ||            ( !isAuthValid(pMac, &rxAuthFrame,psessionEntry) ) )        {            PELOGE(limLog(pMac, LOGE,                   FL("failed to convert Auth Frame to structure or Auth is "                   "not valid "));)            return;        }    }    pRxAuthFrameBody = &rxAuthFrame;   PELOGW(limLog(pMac, LOGW,           FL("Received Auth frame with type=%d seqnum=%d, status=%d (%d)"),           (tANI_U32) pRxAuthFrameBody->authAlgoNumber,           (tANI_U32) pRxAuthFrameBody->authTransactionSeqNumber,           (tANI_U32) pRxAuthFrameBody->authStatusCode,(tANI_U32)pMac->lim.gLimNumPreAuthContexts);)    switch (pRxAuthFrameBody->authTransactionSeqNumber)    {        case SIR_MAC_AUTH_FRAME_1:            // AuthFrame 1            pStaDs = dphLookupHashEntry(pMac, pHdr->sa,                    &assocId, &psessionEntry->dph.dphHashTable);            if (pStaDs)            {                tLimMlmDisassocReq      *pMlmDisassocReq = NULL;                tLimMlmDeauthReq        *pMlmDeauthReq = NULL;                tAniBool                 isConnected = eSIR_TRUE;                pMlmDisassocReq = pMac->lim.limDisassocDeauthCnfReq.pMlmDisassocReq;                if (pMlmDisassocReq &&                        (vos_mem_compare((tANI_U8 *) pHdr->sa,                                         (tANI_U8 *) &pMlmDisassocReq->peerMacAddr,                                          sizeof(tSirMacAddr))))                {                    PELOGE(limLog(pMac, LOGE, FL("TODO:Ack for disassoc "                                "frame is pending Issue delsta for "                                MAC_ADDRESS_STR),                                MAC_ADDR_ARRAY(pMlmDisassocReq->peerMacAddr));)                    limProcessDisassocAckTimeout(pMac);                    isConnected = eSIR_FALSE;                }                pMlmDeauthReq = pMac->lim.limDisassocDeauthCnfReq.pMlmDeauthReq;                if (pMlmDeauthReq &&                        (vos_mem_compare((tANI_U8 *) pHdr->sa,                                         (tANI_U8 *) &pMlmDeauthReq->peerMacAddr,                                         sizeof(tSirMacAddr))))                {                    PELOGE(limLog(pMac, LOGE, FL("TODO:Ack for deauth frame "                                "is pending Issue delsta for "                                MAC_ADDRESS_STR),                                MAC_ADDR_ARRAY(pMlmDeauthReq->peerMacAddr));)                    limProcessDeauthAckTimeout(pMac);                    isConnected = eSIR_FALSE;                }                /* pStaDS != NULL and isConnected = 1 means the STA is already                 * connected, But SAP received the Auth from that station.                 * For non PMF connection send Deauth frame as STA will retry                 * to connect back.                 *                 * For PMF connection the AP should not tear down or otherwise                 * modify the state of the existing association until the                 * SA-Query procedure determines that the original SA is                 * invalid.                 */                if (isConnected#ifdef WLAN_FEATURE_11W                    && !pStaDs->rmfEnabled#endif                                          )                {                    limLog(pMac, LOGE,                            FL("STA is already connected but received auth frame"                                "Send the Deauth and lim Delete Station Context"                                "(staId: %d, assocId: %d) "),                            pStaDs->staIndex, assocId);                    limSendDeauthMgmtFrame(pMac, eSIR_MAC_UNSPEC_FAILURE_REASON,                            (tANI_U8 *) pHdr->sa, psessionEntry, FALSE);                    limTriggerSTAdeletion(pMac, pStaDs, psessionEntry);                    return;                }            }            /// Check if there exists pre-auth context for this STA            pAuthNode = limSearchPreAuthList(pMac, pHdr->sa);            if (pAuthNode)            {                /// Pre-auth context exists for the STA                if (pHdr->fc.retry == 0 || pAuthNode->seqNo != currSeqNo)                {                    /**                     * STA is initiating brand-new Authentication                     * sequence after local Auth Response timeout.                     * Or STA retrying to transmit First Auth frame due to packet drop OTA                     * Delete Pre-auth node and fall through.                     */                    if(pAuthNode->fTimerStarted)                    {                        limDeactivateAndChangePerStaIdTimer(pMac,                                                    eLIM_AUTH_RSP_TIMER,                                                    pAuthNode->authNodeIdx);                    }                    PELOGE(limLog(pMac, LOGE, FL("STA is initiating brand-new "                    "Authentication ..."));)                    limDeletePreAuthNode(pMac,                                         pHdr->sa);                    /**                     *  SAP Mode:Disassociate the station and                     *  delete its entry if we have its entry                     *  already and received "auth" from the                     *  same station.                     */                    for (assocId = 0; assocId < psessionEntry->dph.dphHashTable.size; assocId++)// Softap dphHashTable.size = 8                    {                        pStaDs = dphGetHashEntry(pMac, assocId, &psessionEntry->dph.dphHashTable);                        if (NULL == pStaDs)                             continue;                        if (pStaDs->valid)                        {                             if (vos_mem_compare((tANI_U8 *) &pStaDs->staAddr,                                      (tANI_U8 *) &(pHdr->sa), (tANI_U8) (sizeof(tSirMacAddr))) )                                  break;                        }                        pStaDs = NULL;                    }                    if (NULL != pStaDs#ifdef WLAN_FEATURE_11W                        && !pStaDs->rmfEnabled#endif                       )                    {                        PELOGE(limLog(pMac, LOGE, FL("lim Delete Station "                        "Context (staId: %d, assocId: %d) "),pStaDs->staIndex,                        assocId);)                        limSendDeauthMgmtFrame(pMac,                               eSIR_MAC_UNSPEC_FAILURE_REASON, (tANI_U8 *) pAuthNode->peerMacAddr, psessionEntry, FALSE);                        limTriggerSTAdeletion(pMac, pStaDs, psessionEntry);                        return;                    }                }                else                {                    /*                     * This can happen when first authentication frame is received                     * but ACK lost at STA side, in this case 2nd auth frame is already                     * in transmission queue                     * */                    PELOGE(limLog(pMac, LOGE, FL("STA is initiating "                    "Authentication after ACK lost..."));)                    return;                }            }            if (wlan_cfgGetInt(pMac, WNI_CFG_MAX_NUM_PRE_AUTH,                          (tANI_U32 *) &maxNumPreAuth) != eSIR_SUCCESS)            {                /**                 * Could not get MaxNumPreAuth                 * from CFG. Log error.                 */                limLog(pMac, LOGP,                       FL("could not retrieve MaxNumPreAuth"));            }            if (pMac->lim.gLimNumPreAuthContexts == maxNumPreAuth)            {                PELOGE(limLog(pMac, LOGE, FL("Max number of "                    "preauth context reached"));)                /**                 * Maximum number of pre-auth contexts                 * reached. Send Authentication frame                 * with unspecified failure                 */                authFrame.authAlgoNumber =                pRxAuthFrameBody->authAlgoNumber;                authFrame.authTransactionSeqNumber =                pRxAuthFrameBody->authTransactionSeqNumber + 1;                authFrame.authStatusCode =                eSIR_MAC_UNSPEC_FAILURE_STATUS;                limSendAuthMgmtFrame(pMac, &authFrame,                                     pHdr->sa,                                     LIM_NO_WEP_IN_FC,psessionEntry);                return;            }            /// No Pre-auth context exists for the STA.            if (limIsAuthAlgoSupported(                                      pMac,                                      (tAniAuthType)                                      pRxAuthFrameBody->authAlgoNumber, psessionEntry))            {                switch (pRxAuthFrameBody->authAlgoNumber)                {                    case eSIR_OPEN_SYSTEM:                        PELOGW(limLog(pMac, LOGW, FL("=======> eSIR_OPEN_SYSTEM  ..."));)                        /// Create entry for this STA in pre-auth list                        pAuthNode = limAcquireFreePreAuthNode(pMac, &pMac->lim.gLimPreAuthTimerTable);                        if (pAuthNode == NULL)                        {                            // Log error                            limLog(pMac, LOGW,                                   FL("Max pre-auth nodes reached "));                            limPrintMacAddr(pMac, pHdr->sa, LOGW);                            return;                        }                        limLog(pMac, LOG1,                               FL("Alloc new data: peer "MAC_ADDRESS_STR),                                                 MAC_ADDR_ARRAY(pHdr->sa));                        vos_mem_copy((tANI_U8 *) pAuthNode->peerMacAddr,                                      pHdr->sa,                                      sizeof(tSirMacAddr));                        pAuthNode->mlmState =                        eLIM_MLM_AUTHENTICATED_STATE;                        pAuthNode->authType = (tAniAuthType)                                              pRxAuthFrameBody->authAlgoNumber;                        pAuthNode->fSeen = 0;                        pAuthNode->fTimerStarted = 0;                        pAuthNode->seqNo = ((pHdr->seqControl.seqNumHi << 4) |                                            (pHdr->seqControl.seqNumLo));                        limAddPreAuthNode(pMac, pAuthNode);                        /**                         * Send Authenticaton frame with Success                         * status code.                         */                        authFrame.authAlgoNumber =                        pRxAuthFrameBody->authAlgoNumber;                        authFrame.authTransactionSeqNumber =                        pRxAuthFrameBody->authTransactionSeqNumber + 1;                        authFrame.authStatusCode = eSIR_MAC_SUCCESS_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        /// Send Auth indication to SME                        vos_mem_copy((tANI_U8 *) mlmAuthInd.peerMacAddr,                                     (tANI_U8 *) pHdr->sa,                                     sizeof(tSirMacAddr));                        mlmAuthInd.authType = (tAniAuthType)                                              pRxAuthFrameBody->authAlgoNumber;                        mlmAuthInd.sessionId = psessionEntry->smeSessionId;                        limPostSmeMessage(pMac,                                          LIM_MLM_AUTH_IND,                                          (tANI_U32 *) &mlmAuthInd);                        break;                    case eSIR_SHARED_KEY:                        PELOGW(limLog(pMac, LOGW, FL("=======> eSIR_SHARED_KEY  ..."));)                        if(psessionEntry->limSystemRole == eLIM_AP_ROLE)                        {                            val = psessionEntry->privacy;                        }                        else                        if (wlan_cfgGetInt(pMac, WNI_CFG_PRIVACY_ENABLED,                                      &val) != eSIR_SUCCESS)                        {                            /**                             * Could not get Privacy option                             * from CFG. Log error.                             */                            limLog(pMac, LOGP,                                   FL("could not retrieve Privacy option"));                        }                        cfgPrivacyOptImp = (tANI_U8)val;                        if (!cfgPrivacyOptImp)                        {                            // Log error                            PELOGE(limLog(pMac, LOGE,                                   FL("received Auth frame for unsupported auth algorithm %d "                                   MAC_ADDRESS_STR), pRxAuthFrameBody->authAlgoNumber,                                   MAC_ADDR_ARRAY(pHdr->sa));)                            /**                             * Authenticator does not have WEP                             * implemented.                             * Reject by sending Authentication frame                             * with Auth algorithm not supported status                             * code.                             */                            authFrame.authAlgoNumber =                            pRxAuthFrameBody->authAlgoNumber;                            authFrame.authTransactionSeqNumber =                            pRxAuthFrameBody->authTransactionSeqNumber + 1;                            authFrame.authStatusCode =                            eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS;                            limSendAuthMgmtFrame(                                                pMac, &authFrame,                                                pHdr->sa,                                                LIM_NO_WEP_IN_FC,psessionEntry);                            return;                        }                        else                        {                            // Create entry for this STA                            //in pre-auth list                            pAuthNode = limAcquireFreePreAuthNode(pMac, &pMac->lim.gLimPreAuthTimerTable);                            if (pAuthNode == NULL)                            {                                // Log error                                limLog(pMac, LOGW,                                       FL("Max pre-auth nodes reached "));                                limPrintMacAddr(pMac, pHdr->sa, LOGW);                                return;                            }                            vos_mem_copy((tANI_U8 *) pAuthNode->peerMacAddr,                                          pHdr->sa,                                          sizeof(tSirMacAddr));                            pAuthNode->mlmState =                            eLIM_MLM_WT_AUTH_FRAME3_STATE;                            pAuthNode->authType =                            (tAniAuthType)                            pRxAuthFrameBody->authAlgoNumber;                            pAuthNode->fSeen = 0;                            pAuthNode->fTimerStarted = 0;                            pAuthNode->seqNo = ((pHdr->seqControl.seqNumHi << 4) |                                                (pHdr->seqControl.seqNumLo));                            limAddPreAuthNode(pMac, pAuthNode);                            limLog(pMac, LOG1,                                   FL("Alloc new data: id %d peer "MAC_ADDRESS_STR),                                    pAuthNode->authNodeIdx, MAC_ADDR_ARRAY(pHdr->sa));                            /// Create and activate Auth Response timer                            if (tx_timer_change_context(&pAuthNode->timer, pAuthNode->authNodeIdx) != TX_SUCCESS)                            {                                /// Could not start Auth response timer.                                // Log error                                limLog(pMac, LOGP,                                   FL("Unable to chg context auth response timer for peer "));                                limPrintMacAddr(pMac, pHdr->sa, LOGP);                                /**                                 * Send Authenticaton frame with                                 * unspecified failure status code.                                 */                                authFrame.authAlgoNumber =                                        pRxAuthFrameBody->authAlgoNumber;                                authFrame.authTransactionSeqNumber =                                        pRxAuthFrameBody->authTransactionSeqNumber + 1;                                authFrame.authStatusCode =                                        eSIR_MAC_UNSPEC_FAILURE_STATUS;                                limSendAuthMgmtFrame(pMac, &authFrame,                                                     pHdr->sa,                                                     LIM_NO_WEP_IN_FC,psessionEntry);                                limDeletePreAuthNode(pMac, pHdr->sa);                                return;                            }                            limActivateAuthRspTimer(pMac, pAuthNode);                            pAuthNode->fTimerStarted = 1;                            // get random bytes and use as                            // challenge text                            // TODO                            //if( !VOS_IS_STATUS_SUCCESS( vos_rand_get_bytes( 0, (tANI_U8 *)challengeTextArray, SIR_MAC_AUTH_CHALLENGE_LENGTH ) ) )                            {                               limLog(pMac, LOGE,FL("Challenge text "                               "preparation failed in limProcessAuthFrame"));                            }                            pChallenge = pAuthNode->challengeText;                            vos_mem_copy(pChallenge,                                        (tANI_U8 *) challengeTextArray,                                         sizeof(challengeTextArray));                            /**                             * Sending Authenticaton frame with challenge.                             */                            authFrame.authAlgoNumber =                            pRxAuthFrameBody->authAlgoNumber;                            authFrame.authTransactionSeqNumber =                            pRxAuthFrameBody->authTransactionSeqNumber + 1;                            authFrame.authStatusCode =                            eSIR_MAC_SUCCESS_STATUS;                            authFrame.type   = SIR_MAC_CHALLENGE_TEXT_EID;                            authFrame.length = SIR_MAC_AUTH_CHALLENGE_LENGTH;                            vos_mem_copy(authFrame.challengeText,                                         pAuthNode->challengeText,                                         SIR_MAC_AUTH_CHALLENGE_LENGTH);                            limSendAuthMgmtFrame(                                                pMac, &authFrame,                                                pHdr->sa,                                                LIM_NO_WEP_IN_FC,psessionEntry);                        } // if (wlan_cfgGetInt(CFG_PRIVACY_OPTION_IMPLEMENTED))                        break;                    default:                         // Log error                       PELOGE( limLog(pMac, LOGE,                               FL("received Auth frame for unsupported auth "                               "algorithm %d "MAC_ADDRESS_STR),                               pRxAuthFrameBody->authAlgoNumber,                               MAC_ADDR_ARRAY(pHdr->sa));)                        /**                         * Responding party does not support the                         * authentication algorithm requested by                         * sending party.                         * Reject by sending Authentication frame                         * with auth algorithm not supported status code                         */                        authFrame.authAlgoNumber =                        pRxAuthFrameBody->authAlgoNumber;                        authFrame.authTransactionSeqNumber =                        pRxAuthFrameBody->authTransactionSeqNumber + 1;                        authFrame.authStatusCode =                        eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                } // end switch(pRxAuthFrameBody->authAlgoNumber)            } // if (limIsAuthAlgoSupported(pRxAuthFrameBody->authAlgoNumber))            else            {                // Log error                PELOGE(limLog(pMac, LOGE,                       FL("received Authentication frame for unsupported auth "                       "algorithm %d "MAC_ADDRESS_STR),                       pRxAuthFrameBody->authAlgoNumber,                       MAC_ADDR_ARRAY(pHdr->sa));)                /**                 * Responding party does not support the                 * authentication algorithm requested by sending party.                 * Reject Authentication with StatusCode=13.                 */                authFrame.authAlgoNumber =                pRxAuthFrameBody->authAlgoNumber;                authFrame.authTransactionSeqNumber =                pRxAuthFrameBody->authTransactionSeqNumber + 1;                authFrame.authStatusCode =                eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS;                limSendAuthMgmtFrame(pMac, &authFrame,                                     pHdr->sa,                                     LIM_NO_WEP_IN_FC,psessionEntry);                return;            } //end if (limIsAuthAlgoSupported(pRxAuthFrameBody->authAlgoNumber))            break;        case SIR_MAC_AUTH_FRAME_2:            // AuthFrame 2            if (psessionEntry->limMlmState != eLIM_MLM_WT_AUTH_FRAME2_STATE)            {                /**                 * Received Authentication frame2 in an unexpected state.                 * Log error and ignore the frame.                 */                // Log error                limLog(pMac, LOG1,                       FL("received Auth frame2 from peer in state %d, addr "),                       psessionEntry->limMlmState);                limPrintMacAddr(pMac, pHdr->sa, LOG1);                return;            }            if ( !vos_mem_compare((tANI_U8 *) pHdr->sa,                                  (tANI_U8 *) &pMac->lim.gpLimMlmAuthReq->peerMacAddr,                                  sizeof(tSirMacAddr)) )            {                /**                 * Received Authentication frame from an entity                 * other than one request was initiated.                 * Wait until Authentication Failure Timeout.                 */                // Log error                PELOGW(limLog(pMac, LOGW,                       FL("received Auth frame2 from unexpected peer "                       MAC_ADDRESS_STR),                       MAC_ADDR_ARRAY(pHdr->sa));)                break;            }            if (pRxAuthFrameBody->authStatusCode ==                eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS)            {                /**                 * Interoperability workaround: Linksys WAP4400N is returning                 * wrong authType in OpenAuth response in case of                 * SharedKey AP configuration. Pretend we don't see that,                 * so upper layer can fallback to SharedKey authType,                 * and successfully connect to the AP.                 */                if (pRxAuthFrameBody->authAlgoNumber !=                    pMac->lim.gpLimMlmAuthReq->authType)                {                    pRxAuthFrameBody->authAlgoNumber =                    pMac->lim.gpLimMlmAuthReq->authType;                }            }            if (pRxAuthFrameBody->authAlgoNumber !=                pMac->lim.gpLimMlmAuthReq->authType)            {                /**                 * Received Authentication frame with an auth                 * algorithm other than one requested.                 * Wait until Authentication Failure Timeout.                 */                // Log error                PELOGW(limLog(pMac, LOGW,                       FL("received Auth frame2 for unexpected auth algo number %d "                       MAC_ADDRESS_STR), pRxAuthFrameBody->authAlgoNumber,                       MAC_ADDR_ARRAY(pHdr->sa));)                break;            }            if (pRxAuthFrameBody->authStatusCode ==                eSIR_MAC_SUCCESS_STATUS)            {                if (pRxAuthFrameBody->authAlgoNumber ==                    eSIR_OPEN_SYSTEM)                {                    psessionEntry->limCurrentAuthType = eSIR_OPEN_SYSTEM;                    pAuthNode = limAcquireFreePreAuthNode(pMac, &pMac->lim.gLimPreAuthTimerTable);                    if (pAuthNode == NULL)                    {                        // Log error                        limLog(pMac, LOGW,                               FL("Max pre-auth nodes reached "));                        limPrintMacAddr(pMac, pHdr->sa, LOGW);                        return;                    }                    limLog(pMac, LOG1,                              FL("Alloc new data: peer "MAC_ADDRESS_STR),                                                 MAC_ADDR_ARRAY(pHdr->sa));                    vos_mem_copy((tANI_U8 *) pAuthNode->peerMacAddr,                                 pMac->lim.gpLimMlmAuthReq->peerMacAddr,                                 sizeof(tSirMacAddr));                    pAuthNode->fTimerStarted = 0;                    pAuthNode->authType = pMac->lim.gpLimMlmAuthReq->authType;                    pAuthNode->seqNo = ((pHdr->seqControl.seqNumHi << 4) |                                        (pHdr->seqControl.seqNumLo));                    limAddPreAuthNode(pMac, pAuthNode);                    limRestoreFromAuthState(pMac, eSIR_SME_SUCCESS,                                            pRxAuthFrameBody->authStatusCode,psessionEntry);                } // if (pRxAuthFrameBody->authAlgoNumber == eSIR_OPEN_SYSTEM)                else                {                    // Shared key authentication                    if(psessionEntry->limSystemRole == eLIM_AP_ROLE)                    {                        val = psessionEntry->privacy;                    }                    else                    if (wlan_cfgGetInt(pMac, WNI_CFG_PRIVACY_ENABLED,                                  &val) != eSIR_SUCCESS)                    {                        /**                         * Could not get Privacy option                         * from CFG. Log error.                         */                        limLog(pMac, LOGP,                               FL("could not retrieve Privacy option"));                    }                    cfgPrivacyOptImp = (tANI_U8)val;                    if (!cfgPrivacyOptImp)                    {                        /**                         * Requesting STA does not have WEP implemented.                         * Reject with unsupported authentication algorithm                         * Status code and wait until auth failure timeout                         */                        // Log error                       PELOGE( limLog(pMac, LOGE,                               FL("received Auth frame from peer for "                               "unsupported auth algo %d "                               MAC_ADDRESS_STR), pRxAuthFrameBody->authAlgoNumber,                               MAC_ADDR_ARRAY(pHdr->sa));)                        authFrame.authAlgoNumber =                        pRxAuthFrameBody->authAlgoNumber;                        authFrame.authTransactionSeqNumber =                        pRxAuthFrameBody->authTransactionSeqNumber + 1;                        authFrame.authStatusCode =                        eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS;                        limSendAuthMgmtFrame(pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }                    else                    {                        if (pRxAuthFrameBody->type !=                            SIR_MAC_CHALLENGE_TEXT_EID)                        {                            // Log error                            PELOGE(limLog(pMac, LOGE,                                   FL("received Auth frame with invalid "                                   "challenge text IE"));)                            return;                        }                        /**                         * Check if there exists a key mappping key                         * for the STA that sent Authentication frame                         */                        pKeyMapEntry = limLookUpKeyMappings(                                                           pHdr->sa);                        if (pKeyMapEntry)                        {                            if (pKeyMapEntry->key == NULL)                            {                                // Log error                                PELOGE(limLog(pMac, LOGE,                                       FL("received Auth frame from peer when "                                       "key mapping key is NULL"MAC_ADDRESS_STR),                                       MAC_ADDR_ARRAY(pHdr->sa));)                                /**                                 * Key Mapping entry has null key.                                 * Send Auth frame with                                 * challenge failure status code                                 */                                authFrame.authAlgoNumber =                                pRxAuthFrameBody->authAlgoNumber;                                authFrame.authTransactionSeqNumber =                                pRxAuthFrameBody->authTransactionSeqNumber + 1;                                authFrame.authStatusCode =                                eSIR_MAC_CHALLENGE_FAILURE_STATUS;                                limSendAuthMgmtFrame(pMac, &authFrame,                                                     pHdr->sa,                                                     LIM_NO_WEP_IN_FC,psessionEntry);                                limRestoreFromAuthState(pMac, eSIR_SME_NO_KEY_MAPPING_KEY_FOR_PEER,                                                              eSIR_MAC_UNSPEC_FAILURE_REASON,psessionEntry);                                return;                            } // if (pKeyMapEntry->key == NULL)                            else                            {                                ((tpSirMacAuthFrameBody) plainBody)->authAlgoNumber =                                sirSwapU16ifNeeded(pRxAuthFrameBody->authAlgoNumber);                                ((tpSirMacAuthFrameBody) plainBody)->authTransactionSeqNumber =                                sirSwapU16ifNeeded((tANI_U16) (pRxAuthFrameBody->authTransactionSeqNumber + 1));                                ((tpSirMacAuthFrameBody) plainBody)->authStatusCode = eSIR_MAC_SUCCESS_STATUS;                                ((tpSirMacAuthFrameBody) plainBody)->type   = SIR_MAC_CHALLENGE_TEXT_EID;                                ((tpSirMacAuthFrameBody) plainBody)->length = SIR_MAC_AUTH_CHALLENGE_LENGTH;                                vos_mem_copy((tANI_U8 *) ((tpSirMacAuthFrameBody) plainBody)->challengeText,                                              pRxAuthFrameBody->challengeText,                                              SIR_MAC_AUTH_CHALLENGE_LENGTH);                                limEncryptAuthFrame(pMac, 0,                                                    pKeyMapEntry->key,                                                    plainBody,                                                    encrAuthFrame,key_length);                                psessionEntry->limMlmState = eLIM_MLM_WT_AUTH_FRAME4_STATE;                                MTRACE(macTrace(pMac, TRACE_CODE_MLM_STATE, psessionEntry->peSessionId, psessionEntry->limMlmState));                                limSendAuthMgmtFrame(pMac,                                                     (tpSirMacAuthFrameBody) encrAuthFrame,                                                     pHdr->sa,                                                     LIM_WEP_IN_FC,psessionEntry);                                break;                            } // end if (pKeyMapEntry->key == NULL)                        } // if (pKeyMapEntry)                        else                        {                            if (wlan_cfgGetInt(pMac, WNI_CFG_WEP_DEFAULT_KEYID,                                          &val) != eSIR_SUCCESS)                            {                                /**                                 * Could not get Default keyId                                 * from CFG. Log error.                                 */                                limLog(pMac, LOGP,                                       FL("could not retrieve Default keyId"));                            }                            keyId = (tANI_U8)val;                            val = SIR_MAC_KEY_LENGTH;                            if(psessionEntry->limSystemRole == eLIM_AP_ROLE)                            {                                tpSirKeys pKey;                                pKey =  &psessionEntry->WEPKeyMaterial[keyId].key[0];                                vos_mem_copy(defaultKey, pKey->key, pKey->keyLength);                            }                            else                            if (wlan_cfgGetStr(pMac, (tANI_U16) (WNI_CFG_WEP_DEFAULT_KEY_1 + keyId),                                          defaultKey,                                          &val)                                != eSIR_SUCCESS)                            {                                /// Could not get Default key from CFG.                                //Log error.                                limLog(pMac, LOGP,                                       FL("could not retrieve Default key"));                                authFrame.authAlgoNumber =                                pRxAuthFrameBody->authAlgoNumber;                                authFrame.authTransactionSeqNumber =                                pRxAuthFrameBody->authTransactionSeqNumber + 1;                                authFrame.authStatusCode =                                eSIR_MAC_CHALLENGE_FAILURE_STATUS;                                limSendAuthMgmtFrame(                                                    pMac, &authFrame,                                                    pHdr->sa,                                                    LIM_NO_WEP_IN_FC,psessionEntry);                                limRestoreFromAuthState(pMac, eSIR_SME_INVALID_WEP_DEFAULT_KEY,                                                              eSIR_MAC_UNSPEC_FAILURE_REASON,psessionEntry);                                break;                            }                                key_length=val;                                ((tpSirMacAuthFrameBody) plainBody)->authAlgoNumber =                                sirSwapU16ifNeeded(pRxAuthFrameBody->authAlgoNumber);                                ((tpSirMacAuthFrameBody) plainBody)->authTransactionSeqNumber =                                sirSwapU16ifNeeded((tANI_U16) (pRxAuthFrameBody->authTransactionSeqNumber + 1));                                ((tpSirMacAuthFrameBody) plainBody)->authStatusCode = eSIR_MAC_SUCCESS_STATUS;                                ((tpSirMacAuthFrameBody) plainBody)->type   = SIR_MAC_CHALLENGE_TEXT_EID;                                ((tpSirMacAuthFrameBody) plainBody)->length = SIR_MAC_AUTH_CHALLENGE_LENGTH;                                vos_mem_copy((tANI_U8 *) ((tpSirMacAuthFrameBody) plainBody)->challengeText,                                              pRxAuthFrameBody->challengeText,                                              SIR_MAC_AUTH_CHALLENGE_LENGTH);                                limEncryptAuthFrame(pMac, keyId,                                                    defaultKey,                                                    plainBody,                                                    encrAuthFrame,key_length);                                psessionEntry->limMlmState =                                eLIM_MLM_WT_AUTH_FRAME4_STATE;                                MTRACE(macTrace(pMac, TRACE_CODE_MLM_STATE, psessionEntry->peSessionId, psessionEntry->limMlmState));                                limSendAuthMgmtFrame(pMac,                                                     (tpSirMacAuthFrameBody) encrAuthFrame,                                                     pHdr->sa,                                                     LIM_WEP_IN_FC,psessionEntry);                                break;                        } // end if (pKeyMapEntry)                    } // end if (!wlan_cfgGetInt(CFG_PRIVACY_OPTION_IMPLEMENTED))                } // end if (pRxAuthFrameBody->authAlgoNumber == eSIR_OPEN_SYSTEM)            } // if (pRxAuthFrameBody->authStatusCode == eSIR_MAC_SUCCESS_STATUS)            else            {                /**                 * Authentication failure.                 * Return Auth confirm with received failure code to SME                 */                // Log error                PELOGE(limLog(pMac, LOGE,                       FL("received Auth frame from peer with failure code %d "                       MAC_ADDRESS_STR), pRxAuthFrameBody->authStatusCode,                       MAC_ADDR_ARRAY(pHdr->sa));)                limRestoreFromAuthState(pMac, eSIR_SME_AUTH_REFUSED,                                              pRxAuthFrameBody->authStatusCode,psessionEntry);            } // end if (pRxAuthFrameBody->authStatusCode == eSIR_MAC_SUCCESS_STATUS)            break;        case SIR_MAC_AUTH_FRAME_3:            // AuthFrame 3            if (pRxAuthFrameBody->authAlgoNumber != eSIR_SHARED_KEY)            {                // Log error                PELOGE(limLog(pMac, LOGE,                       FL("received Auth frame3 from peer with auth algo "                       "number %d "MAC_ADDRESS_STR),                       pRxAuthFrameBody->authAlgoNumber,                       MAC_ADDR_ARRAY(pHdr->sa));)                /**                 * Received Authentication frame3 with algorithm other than                 * Shared Key authentication type. Reject with Auth frame4                 * with 'out of sequence' status code.                 */                authFrame.authAlgoNumber = eSIR_SHARED_KEY;                authFrame.authTransactionSeqNumber =                SIR_MAC_AUTH_FRAME_4;                authFrame.authStatusCode =                eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                limSendAuthMgmtFrame(pMac, &authFrame,                                     pHdr->sa,                                     LIM_NO_WEP_IN_FC,psessionEntry);                return;            }            if (psessionEntry->limSystemRole == eLIM_AP_ROLE || psessionEntry->limSystemRole == eLIM_BT_AMP_AP_ROLE ||                psessionEntry->limSystemRole == eLIM_STA_IN_IBSS_ROLE)            {                /**                 * Check if wep bit was set in FC. If not set,                 * reject with Authentication frame4 with                 * 'challenge failure' status code.                 */                if (!pHdr->fc.wep)                {                    // Log error                    PELOGE(limLog(pMac, LOGE,                           FL("received Auth frame3 from peer with no WEP bit "                           "set "MAC_ADDRESS_STR),                           MAC_ADDR_ARRAY(pHdr->sa));)                    /// WEP bit is not set in FC of Auth Frame3                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }                pAuthNode = limSearchPreAuthList(pMac,                                                pHdr->sa);                if (pAuthNode == NULL)                {                     // Log error                    PELOGE(limLog(pMac, LOGW,                           FL("received AuthFrame3 from peer that has no "                           "preauth context "MAC_ADDRESS_STR),                            MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * No 'pre-auth' context exists for                     * this STA that sent an Authentication                     * frame3.                     * Send Auth frame4 with 'out of sequence'                     * status code.                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }                if (pAuthNode->mlmState == eLIM_MLM_AUTH_RSP_TIMEOUT_STATE)                {                    // Log error                    limLog(pMac, LOGW,                           FL("auth response timer timedout for peer "                           MAC_ADDRESS_STR),MAC_ADDR_ARRAY(pHdr->sa));                    /**                     * Received Auth Frame3 after Auth Response timeout.                     * Reject by sending Auth Frame4 with                     * Auth respone timeout Status Code.                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_AUTH_RSP_TIMEOUT_STATUS;                    limSendAuthMgmtFrame(                                        pMac, &authFrame,                                        pHdr->sa,                                        LIM_NO_WEP_IN_FC,psessionEntry);                    /// Delete pre-auth context of STA                    limDeletePreAuthNode(pMac,                                         pHdr->sa);                    return;                } // end switch (pAuthNode->mlmState)                if (pRxAuthFrameBody->authStatusCode != eSIR_MAC_SUCCESS_STATUS)                {                    /**                     * Received Authenetication Frame 3 with status code                     * other than success. Wait until Auth response timeout                     * to delete STA context.                     */                    // Log error                    PELOGE(limLog(pMac, LOGE,                           FL("received Auth frame3 from peer with status code %d "                           MAC_ADDRESS_STR), pRxAuthFrameBody->authStatusCode,                           MAC_ADDR_ARRAY(pHdr->sa));)                    return;                }                /**                 * Check if received challenge text is same as one sent in                 * Authentication frame3                 */                if (vos_mem_compare(pRxAuthFrameBody->challengeText,                                    pAuthNode->challengeText,                                    SIR_MAC_AUTH_CHALLENGE_LENGTH))                {                    /// Challenge match. STA is autheticated !                    /// Delete Authentication response timer if running                    limDeactivateAndChangePerStaIdTimer(pMac,                                                        eLIM_AUTH_RSP_TIMER,                                                        pAuthNode->authNodeIdx);                    pAuthNode->fTimerStarted = 0;                    pAuthNode->mlmState = eLIM_MLM_AUTHENTICATED_STATE;                    /**                     * Send Authentication Frame4 with 'success' Status Code.                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode = eSIR_MAC_SUCCESS_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    /// Send Auth indication to SME                    vos_mem_copy((tANI_U8 *) mlmAuthInd.peerMacAddr,                                 (tANI_U8 *) pHdr->sa,                                  sizeof(tSirMacAddr));                    mlmAuthInd.authType = (tAniAuthType)                                          pRxAuthFrameBody->authAlgoNumber;                    mlmAuthInd.sessionId = psessionEntry->smeSessionId;                    limPostSmeMessage(pMac,                                      LIM_MLM_AUTH_IND,                                      (tANI_U32 *) &mlmAuthInd);                    break;                }                else                {                     // Log error                    PELOGE( limLog(pMac, LOGW,                                   FL("Challenge failure for peer "                                   MAC_ADDRESS_STR),                                   MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * Challenge Failure.                     * Send Authentication frame4 with 'challenge failure'                     * status code and wait until Auth response timeout to                     * delete STA context.                     */                    authFrame.authAlgoNumber =                        pRxAuthFrameBody->authAlgoNumber;                    authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }            } // if (pMac->lim.gLimSystemRole == eLIM_AP_ROLE || ...            break;        case SIR_MAC_AUTH_FRAME_4:            // AuthFrame 4            if (psessionEntry->limMlmState != eLIM_MLM_WT_AUTH_FRAME4_STATE)            {                /**                 * Received Authentication frame4 in an unexpected state.                 * Log error and ignore the frame.                 */                // Log error                limLog(pMac, LOG1,                       FL("received unexpected Auth frame4 from peer in state "                       "%d, addr "MAC_ADDRESS_STR), psessionEntry->limMlmState,                       MAC_ADDR_ARRAY(pHdr->sa));                return;            }            if (pRxAuthFrameBody->authAlgoNumber != eSIR_SHARED_KEY)            {                /**                 * Received Authentication frame4 with algorithm other than                 * Shared Key authentication type.                 * Wait until Auth failure timeout to report authentication                 * failure to SME.                 */                // Log error                PELOGE(limLog(pMac, LOGE,                       FL("received Auth frame4 from peer with invalid auth "                       "algo %d "MAC_ADDRESS_STR), pRxAuthFrameBody->authAlgoNumber,                       MAC_ADDR_ARRAY(pHdr->sa));)                return;            }            if ( !vos_mem_compare((tANI_U8 *) pHdr->sa,                                  (tANI_U8 *) &pMac->lim.gpLimMlmAuthReq->peerMacAddr,                                  sizeof(tSirMacAddr)) )            {                /**                 * Received Authentication frame from an entity                 * other than one to which request was initiated.                 * Wait until Authentication Failure Timeout.                 */                // Log error                PELOGE(limLog(pMac, LOGW,                       FL("received Auth frame4 from unexpected peer "                       MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                break;            }            if (pRxAuthFrameBody->authAlgoNumber !=                pMac->lim.gpLimMlmAuthReq->authType)            {                /**                 * Received Authentication frame with an auth algorithm                 * other than one requested.                 * Wait until Authentication Failure Timeout.                 */                PELOGE(limLog(pMac, LOGE,                       FL("received Authentication frame from peer with "                       "invalid auth seq number %d "                       MAC_ADDRESS_STR), pRxAuthFrameBody->authTransactionSeqNumber,                       MAC_ADDR_ARRAY(pHdr->sa));)                break;            }            if (pRxAuthFrameBody->authStatusCode ==                eSIR_MAC_SUCCESS_STATUS)            {                /**                 * Authentication Success !                 * Inform SME of same.                 */                psessionEntry->limCurrentAuthType = eSIR_SHARED_KEY;                pAuthNode = limAcquireFreePreAuthNode(pMac, &pMac->lim.gLimPreAuthTimerTable);                if (pAuthNode == NULL)                {                    // Log error                    limLog(pMac, LOGW,                           FL("Max pre-auth nodes reached "));                    limPrintMacAddr(pMac, pHdr->sa, LOGW);                    return;                }                limLog(pMac, LOG1,                         FL("Alloc new data: peer " MAC_ADDRESS_STR),                                              MAC_ADDR_ARRAY(pHdr->sa));                vos_mem_copy((tANI_U8 *) pAuthNode->peerMacAddr,                             pMac->lim.gpLimMlmAuthReq->peerMacAddr,                             sizeof(tSirMacAddr));                pAuthNode->fTimerStarted = 0;                pAuthNode->authType = pMac->lim.gpLimMlmAuthReq->authType;                pAuthNode->seqNo = ((pHdr->seqControl.seqNumHi << 4) |                                    (pHdr->seqControl.seqNumLo));                limAddPreAuthNode(pMac, pAuthNode);                limRestoreFromAuthState(pMac, eSIR_SME_SUCCESS,                                              pRxAuthFrameBody->authStatusCode,psessionEntry);            } // if (pRxAuthFrameBody->authStatusCode == eSIR_MAC_SUCCESS_STATUS)            else            {                /**                 * Authentication failure.                 * Return Auth confirm with received failure code to SME                 */                // Log error                PELOGE(limLog(pMac, LOGE, FL("Authentication failure from peer "                       MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                limRestoreFromAuthState(pMac, eSIR_SME_AUTH_REFUSED,                                              pRxAuthFrameBody->authStatusCode,psessionEntry);            } // end if (pRxAuthFrameBody->Status == 0)            break;        default:            /// Invalid Authentication Frame received. Ignore it.            // Log error            PELOGE(limLog(pMac, LOGE,                   FL("received Auth frame from peer with invalid auth seq "                   "number %d " MAC_ADDRESS_STR),                   pRxAuthFrameBody->authTransactionSeqNumber,                   MAC_ADDR_ARRAY(pHdr->sa));)            break;    } // end switch (pRxAuthFrameBody->authTransactionSeqNumber)}
void
limProcessAuthFrame(tpAniSirGlobal pMac, tANI_U8 *pRxPacketInfo, tpPESession psessionEntry)
limProcessAuthFrame
tpAniSirGlobal pMac
tpAniSirGlobal
tpAniSirGlobal
pMac
pMac
tANI_U8 *pRxPacketInfo
tANI_U8
tANI_U8
*pRxPacketInfo
*
pRxPacketInfo
tpPESession psessionEntry
tpPESession
tpPESession
psessionEntry
psessionEntry
{    tANI_U8                 *pBody, keyId, cfgPrivacyOptImp,                            defaultKey[SIR_MAC_KEY_LENGTH],                            encrAuthFrame[LIM_ENCR_AUTH_BODY_LEN],                            plainBody[256];    tANI_U16                frameLen;    //tANI_U32                authRspTimeout, maxNumPreAuth, val;    tANI_U32                maxNumPreAuth, val;    tSirMacAuthFrameBody    *pRxAuthFrameBody, rxAuthFrame, authFrame;    tpSirMacMgmtHdr         pHdr;    tCfgWepKeyEntry         *pKeyMapEntry = NULL;    struct tLimPreAuthNode  *pAuthNode;    tLimMlmAuthInd          mlmAuthInd;    tANI_U8                 decryptResult;    tANI_U8                 *pChallenge;    tANI_U32                key_length=8;    tANI_U8                 challengeTextArray[SIR_MAC_AUTH_CHALLENGE_LENGTH];    tpDphHashNode           pStaDs = NULL;    tANI_U16                assocId = 0;    tANI_U16                currSeqNo = 0;    /* Added For BT -AMP support */    // Get pointer to Authentication frame header and body    pHdr = WDA_GET_RX_MAC_HEADER(pRxPacketInfo);    frameLen = WDA_GET_RX_PAYLOAD_LEN(pRxPacketInfo);    if (!frameLen)    {        // Log error        limLog(pMac, LOGE,               FL("received Authentication frame with no body from "));        limPrintMacAddr(pMac, pHdr->sa, LOGE);        return;    }    if (limIsGroupAddr(pHdr->sa))    {        // Received Auth frame from a BC/MC address        // Log error and ignore it       limLog(pMac, LOGE,               FL("received Auth frame from a BC/MC address - "));       limPrintMacAddr(pMac, pHdr->sa, LOGE);        return;    }    currSeqNo = (pHdr->seqControl.seqNumHi << 4) | (pHdr->seqControl.seqNumLo);    limLog(pMac, LOG1,               FL("Sessionid: %d System role : %d limMlmState: %d :Auth "               "Frame Received: BSSID: "MAC_ADDRESS_STR " (RSSI %d)"),               psessionEntry->peSessionId, psessionEntry->limSystemRole,               psessionEntry->limMlmState, MAC_ADDR_ARRAY(pHdr->bssId),               (uint)abs((tANI_S8)WDA_GET_RX_RSSI_DB(pRxPacketInfo)));    pBody = WDA_GET_RX_MPDU_DATA(pRxPacketInfo);    //PELOG3(sirDumpBuf(pMac, SIR_LIM_MODULE_ID, LOG3, (tANI_U8*)pBd, ((tpHalBufDesc) pBd)->mpduDataOffset + frameLen);)    //Restore default failure timeout    if (VOS_P2P_CLIENT_MODE == psessionEntry->pePersona && psessionEntry->defaultAuthFailureTimeout)    {        limLog(pMac, LOG1, FL("Restore default failure timeout"));        ccmCfgSetInt(pMac,WNI_CFG_AUTHENTICATE_FAILURE_TIMEOUT ,                          psessionEntry->defaultAuthFailureTimeout, NULL, eANI_BOOLEAN_FALSE);    }    /// Determine if WEP bit is set in the FC or received MAC header    if (pHdr->fc.wep)    {        /**         * WEP bit is set in FC of MAC header.         */        // If TKIP counter measures enabled issue Deauth frame to station        if ((psessionEntry->bTkipCntrMeasActive) && (psessionEntry->limSystemRole == eLIM_AP_ROLE))        {            PELOGE( limLog(pMac, LOGE,               FL("Tkip counter measures Enabled, sending Deauth frame to")); )            limPrintMacAddr(pMac, pHdr->sa, LOGE);            limSendDeauthMgmtFrame( pMac, eSIR_MAC_MIC_FAILURE_REASON,                                    pHdr->sa, psessionEntry, FALSE );            return;        }        // Extract key ID from IV (most 2 bits of 4th byte of IV)        keyId = (*(pBody + 3)) >> 6;        /**         * On STA in infrastructure BSS, Authentication frames received         * with WEP bit set in the FC must be rejected with challenge         * failure status code (wierd thing in the spec - this should have         * been rejected with unspecified failure or unexpected assertion         * of wep bit (this status code does not exist though) or         * Out-of-sequence-Authentication-Frame status code.         */        if (psessionEntry->limSystemRole == eLIM_STA_ROLE || psessionEntry->limSystemRole == eLIM_BT_AMP_STA_ROLE)        {            authFrame.authAlgoNumber = eSIR_SHARED_KEY;            authFrame.authTransactionSeqNumber = SIR_MAC_AUTH_FRAME_4;            authFrame.authStatusCode = eSIR_MAC_CHALLENGE_FAILURE_STATUS;            // Log error            PELOGE(limLog(pMac, LOGE,                   FL("received Authentication frame with wep bit set on "                   "role=%d "MAC_ADDRESS_STR),                   psessionEntry->limSystemRole, MAC_ADDR_ARRAY(pHdr->sa) );)            limSendAuthMgmtFrame(pMac, &authFrame,                                 pHdr->sa,                                 LIM_NO_WEP_IN_FC,psessionEntry);            return;        }        if (frameLen < LIM_ENCR_AUTH_BODY_LEN)        {            // Log error            limLog(pMac, LOGE,                   FL("Not enough size [%d] to decrypt received Auth frame"),                   frameLen);            limPrintMacAddr(pMac, pHdr->sa, LOGE);            return;        }        if(psessionEntry->limSystemRole == eLIM_AP_ROLE)        {            val = psessionEntry->privacy;        }        else        // Accept Authentication frame only if Privacy is implemented        if (wlan_cfgGetInt(pMac, WNI_CFG_PRIVACY_ENABLED,                      &val) != eSIR_SUCCESS)        {            /**             * Could not get Privacy option             * from CFG. Log error.             */            limLog(pMac, LOGP, FL("could not retrieve Privacy option"));        }        cfgPrivacyOptImp = (tANI_U8)val;        if (cfgPrivacyOptImp)        {            /**             * Privacy option is implemented.             * Check if the received frame is Authentication             * frame3 and there is a context for requesting STA.             * If not, reject with unspecified failure status code             */            pAuthNode = limSearchPreAuthList(pMac, pHdr->sa);            if (pAuthNode == NULL)            {                // Log error                PELOGE(limLog(pMac, LOGE,                       FL("received Authentication frame from peer that has "                       "no preauth context with WEP bit set "MAC_ADDRESS_STR),                       MAC_ADDR_ARRAY(pHdr->sa));)                /**                 * No 'pre-auth' context exists for this STA that sent                 * an Authentication frame with FC bit set.                 * Send Auth frame4 with 'out of sequence' status code.                 */                authFrame.authAlgoNumber = eSIR_SHARED_KEY;                authFrame.authTransactionSeqNumber =                SIR_MAC_AUTH_FRAME_4;                authFrame.authStatusCode =                eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                limSendAuthMgmtFrame(pMac, &authFrame,                                     pHdr->sa,                                     LIM_NO_WEP_IN_FC,psessionEntry);                return;            }            else            {                /// Change the auth-response timeout                limDeactivateAndChangePerStaIdTimer(pMac,                                                    eLIM_AUTH_RSP_TIMER,                                                    pAuthNode->authNodeIdx);                /// 'Pre-auth' status exists for STA                if ((pAuthNode->mlmState !=                     eLIM_MLM_WT_AUTH_FRAME3_STATE) &&                    (pAuthNode->mlmState !=                     eLIM_MLM_AUTH_RSP_TIMEOUT_STATE))                {                    // Log error                    PELOGE(limLog(pMac, LOGE,                           FL("received Authentication frame from peer that is "                           "in state %d "MAC_ADDRESS_STR),                            pAuthNode->mlmState, MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * Should not have received Authentication frame                     * with WEP bit set in FC in other states.                     * Reject by sending Authenticaton frame with                     * out of sequence Auth frame status code.                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }            }            /**             * Check if there exists a key mappping key             * for the STA that sent Authentication frame             */            pKeyMapEntry = limLookUpKeyMappings(pHdr->sa);            if (pKeyMapEntry)            {                if (!pKeyMapEntry->wepOn)                {                    // Log error                    PELOGE(limLog(pMac, LOGE,                           FL("received Auth frame3 from peer that has NULL "                           "key map entry "                           MAC_ADDRESS_STR),MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * Key Mapping entry has null key.                     * Send Authentication frame                     * with challenge failure status code                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                } // if (!pKeyMapEntry->wepOn)                else                {                    decryptResult = limDecryptAuthFrame(pMac, pKeyMapEntry->key,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH));                    if (decryptResult == LIM_DECRYPT_ICV_FAIL)                    {                        /// ICV failure                        PELOGW(limLog(pMac, LOGW, FL("=====> decryptResult == "                        "LIM_DECRYPT_ICV_FAIL ..."));)                        // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer "                               "that failed decryption, Addr "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                        limDeletePreAuthNode(pMac,                                             pHdr->sa);                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;                        authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                        authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }                    if ( ( sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                         &rxAuthFrame)!=eSIR_SUCCESS ) ||                         ( !isAuthValid(pMac, &rxAuthFrame,psessionEntry) ) )                    {                        PELOGE(limLog(pMac, LOGE,                               FL("failed to convert Auth Frame to structure "                               "or Auth is not valid "));)                        return;                    }                } // end if (pKeyMapEntry->key == NULL)            } // if keyMappings has entry            else            {                val = SIR_MAC_KEY_LENGTH;                if(psessionEntry->limSystemRole == eLIM_AP_ROLE)                {                    tpSirKeys pKey;                    pKey =  &psessionEntry->WEPKeyMaterial[keyId].key[0];                    vos_mem_copy(defaultKey, pKey->key, pKey->keyLength);                    val = pKey->keyLength;                }                else                if (wlan_cfgGetStr(pMac, (tANI_U16) (WNI_CFG_WEP_DEFAULT_KEY_1 + keyId),                              defaultKey, &val) != eSIR_SUCCESS)                {                    /// Could not get Default key from CFG.                    //Log error.                    limLog(pMac, LOGP,                           FL("could not retrieve Default key"));                    /**                     * Send Authentication frame                     * with challenge failure status code                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }                    key_length=val;                    decryptResult = limDecryptAuthFrame(pMac, defaultKey,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH));                    if (decryptResult == LIM_DECRYPT_ICV_FAIL)                    {                        PELOGW(limLog(pMac, LOGW, FL("=====> decryptResult == "                        "LIM_DECRYPT_ICV_FAIL ..."));)                        // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer that "                               "failed decryption: "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                        /// ICV failure                        limDeletePreAuthNode(pMac,                                             pHdr->sa);                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;                        authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                        authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }                    if ( ( sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                           &rxAuthFrame)!=eSIR_SUCCESS ) ||                        ( !isAuthValid(pMac, &rxAuthFrame, psessionEntry) ) )                    {                        limLog(pMac, LOGE,                               FL("failed to convert Auth Frame to structure "                               "or Auth is not valid "));                        return;                    }            } // End of check for Key Mapping/Default key presence        }        else        {            // Log error            PELOGE(limLog(pMac, LOGE,                   FL("received Authentication frame3 from peer that while "                   "privacy option is turned OFF "                   MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)            /**             * Privacy option is not implemented.             * So reject Authentication frame received with             * WEP bit set by sending Authentication frame             * with 'challenge failure' status code. This is             * another strange thing in the spec. Status code             * should have been 'unsupported algorithm' status code.             */            authFrame.authAlgoNumber = eSIR_SHARED_KEY;            authFrame.authTransactionSeqNumber =            SIR_MAC_AUTH_FRAME_4;            authFrame.authStatusCode =            eSIR_MAC_CHALLENGE_FAILURE_STATUS;            limSendAuthMgmtFrame(pMac, &authFrame,                                 pHdr->sa,                                 LIM_NO_WEP_IN_FC,psessionEntry);            return;        } // else if (wlan_cfgGetInt(CFG_PRIVACY_OPTION_IMPLEMENTED))    } // if (fc.wep)    else    {        if ( ( sirConvertAuthFrame2Struct(pMac, pBody,            frameLen, &rxAuthFrame)!=eSIR_SUCCESS ) ||            ( !isAuthValid(pMac, &rxAuthFrame,psessionEntry) ) )        {            PELOGE(limLog(pMac, LOGE,                   FL("failed to convert Auth Frame to structure or Auth is "                   "not valid "));)            return;        }    }    pRxAuthFrameBody = &rxAuthFrame;   PELOGW(limLog(pMac, LOGW,           FL("Received Auth frame with type=%d seqnum=%d, status=%d (%d)"),           (tANI_U32) pRxAuthFrameBody->authAlgoNumber,           (tANI_U32) pRxAuthFrameBody->authTransactionSeqNumber,           (tANI_U32) pRxAuthFrameBody->authStatusCode,(tANI_U32)pMac->lim.gLimNumPreAuthContexts);)    switch (pRxAuthFrameBody->authTransactionSeqNumber)    {        case SIR_MAC_AUTH_FRAME_1:            // AuthFrame 1            pStaDs = dphLookupHashEntry(pMac, pHdr->sa,                    &assocId, &psessionEntry->dph.dphHashTable);            if (pStaDs)            {                tLimMlmDisassocReq      *pMlmDisassocReq = NULL;                tLimMlmDeauthReq        *pMlmDeauthReq = NULL;                tAniBool                 isConnected = eSIR_TRUE;                pMlmDisassocReq = pMac->lim.limDisassocDeauthCnfReq.pMlmDisassocReq;                if (pMlmDisassocReq &&                        (vos_mem_compare((tANI_U8 *) pHdr->sa,                                         (tANI_U8 *) &pMlmDisassocReq->peerMacAddr,                                          sizeof(tSirMacAddr))))                {                    PELOGE(limLog(pMac, LOGE, FL("TODO:Ack for disassoc "                                "frame is pending Issue delsta for "                                MAC_ADDRESS_STR),                                MAC_ADDR_ARRAY(pMlmDisassocReq->peerMacAddr));)                    limProcessDisassocAckTimeout(pMac);                    isConnected = eSIR_FALSE;                }                pMlmDeauthReq = pMac->lim.limDisassocDeauthCnfReq.pMlmDeauthReq;                if (pMlmDeauthReq &&                        (vos_mem_compare((tANI_U8 *) pHdr->sa,                                         (tANI_U8 *) &pMlmDeauthReq->peerMacAddr,                                         sizeof(tSirMacAddr))))                {                    PELOGE(limLog(pMac, LOGE, FL("TODO:Ack for deauth frame "                                "is pending Issue delsta for "                                MAC_ADDRESS_STR),                                MAC_ADDR_ARRAY(pMlmDeauthReq->peerMacAddr));)                    limProcessDeauthAckTimeout(pMac);                    isConnected = eSIR_FALSE;                }                /* pStaDS != NULL and isConnected = 1 means the STA is already                 * connected, But SAP received the Auth from that station.                 * For non PMF connection send Deauth frame as STA will retry                 * to connect back.                 *                 * For PMF connection the AP should not tear down or otherwise                 * modify the state of the existing association until the                 * SA-Query procedure determines that the original SA is                 * invalid.                 */                if (isConnected#ifdef WLAN_FEATURE_11W                    && !pStaDs->rmfEnabled#endif                                          )                {                    limLog(pMac, LOGE,                            FL("STA is already connected but received auth frame"                                "Send the Deauth and lim Delete Station Context"                                "(staId: %d, assocId: %d) "),                            pStaDs->staIndex, assocId);                    limSendDeauthMgmtFrame(pMac, eSIR_MAC_UNSPEC_FAILURE_REASON,                            (tANI_U8 *) pHdr->sa, psessionEntry, FALSE);                    limTriggerSTAdeletion(pMac, pStaDs, psessionEntry);                    return;                }            }            /// Check if there exists pre-auth context for this STA            pAuthNode = limSearchPreAuthList(pMac, pHdr->sa);            if (pAuthNode)            {                /// Pre-auth context exists for the STA                if (pHdr->fc.retry == 0 || pAuthNode->seqNo != currSeqNo)                {                    /**                     * STA is initiating brand-new Authentication                     * sequence after local Auth Response timeout.                     * Or STA retrying to transmit First Auth frame due to packet drop OTA                     * Delete Pre-auth node and fall through.                     */                    if(pAuthNode->fTimerStarted)                    {                        limDeactivateAndChangePerStaIdTimer(pMac,                                                    eLIM_AUTH_RSP_TIMER,                                                    pAuthNode->authNodeIdx);                    }                    PELOGE(limLog(pMac, LOGE, FL("STA is initiating brand-new "                    "Authentication ..."));)                    limDeletePreAuthNode(pMac,                                         pHdr->sa);                    /**                     *  SAP Mode:Disassociate the station and                     *  delete its entry if we have its entry                     *  already and received "auth" from the                     *  same station.                     */                    for (assocId = 0; assocId < psessionEntry->dph.dphHashTable.size; assocId++)// Softap dphHashTable.size = 8                    {                        pStaDs = dphGetHashEntry(pMac, assocId, &psessionEntry->dph.dphHashTable);                        if (NULL == pStaDs)                             continue;                        if (pStaDs->valid)                        {                             if (vos_mem_compare((tANI_U8 *) &pStaDs->staAddr,                                      (tANI_U8 *) &(pHdr->sa), (tANI_U8) (sizeof(tSirMacAddr))) )                                  break;                        }                        pStaDs = NULL;                    }                    if (NULL != pStaDs#ifdef WLAN_FEATURE_11W                        && !pStaDs->rmfEnabled#endif                       )                    {                        PELOGE(limLog(pMac, LOGE, FL("lim Delete Station "                        "Context (staId: %d, assocId: %d) "),pStaDs->staIndex,                        assocId);)                        limSendDeauthMgmtFrame(pMac,                               eSIR_MAC_UNSPEC_FAILURE_REASON, (tANI_U8 *) pAuthNode->peerMacAddr, psessionEntry, FALSE);                        limTriggerSTAdeletion(pMac, pStaDs, psessionEntry);                        return;                    }                }                else                {                    /*                     * This can happen when first authentication frame is received                     * but ACK lost at STA side, in this case 2nd auth frame is already                     * in transmission queue                     * */                    PELOGE(limLog(pMac, LOGE, FL("STA is initiating "                    "Authentication after ACK lost..."));)                    return;                }            }            if (wlan_cfgGetInt(pMac, WNI_CFG_MAX_NUM_PRE_AUTH,                          (tANI_U32 *) &maxNumPreAuth) != eSIR_SUCCESS)            {                /**                 * Could not get MaxNumPreAuth                 * from CFG. Log error.                 */                limLog(pMac, LOGP,                       FL("could not retrieve MaxNumPreAuth"));            }            if (pMac->lim.gLimNumPreAuthContexts == maxNumPreAuth)            {                PELOGE(limLog(pMac, LOGE, FL("Max number of "                    "preauth context reached"));)                /**                 * Maximum number of pre-auth contexts                 * reached. Send Authentication frame                 * with unspecified failure                 */                authFrame.authAlgoNumber =                pRxAuthFrameBody->authAlgoNumber;                authFrame.authTransactionSeqNumber =                pRxAuthFrameBody->authTransactionSeqNumber + 1;                authFrame.authStatusCode =                eSIR_MAC_UNSPEC_FAILURE_STATUS;                limSendAuthMgmtFrame(pMac, &authFrame,                                     pHdr->sa,                                     LIM_NO_WEP_IN_FC,psessionEntry);                return;            }            /// No Pre-auth context exists for the STA.            if (limIsAuthAlgoSupported(                                      pMac,                                      (tAniAuthType)                                      pRxAuthFrameBody->authAlgoNumber, psessionEntry))            {                switch (pRxAuthFrameBody->authAlgoNumber)                {                    case eSIR_OPEN_SYSTEM:                        PELOGW(limLog(pMac, LOGW, FL("=======> eSIR_OPEN_SYSTEM  ..."));)                        /// Create entry for this STA in pre-auth list                        pAuthNode = limAcquireFreePreAuthNode(pMac, &pMac->lim.gLimPreAuthTimerTable);                        if (pAuthNode == NULL)                        {                            // Log error                            limLog(pMac, LOGW,                                   FL("Max pre-auth nodes reached "));                            limPrintMacAddr(pMac, pHdr->sa, LOGW);                            return;                        }                        limLog(pMac, LOG1,                               FL("Alloc new data: peer "MAC_ADDRESS_STR),                                                 MAC_ADDR_ARRAY(pHdr->sa));                        vos_mem_copy((tANI_U8 *) pAuthNode->peerMacAddr,                                      pHdr->sa,                                      sizeof(tSirMacAddr));                        pAuthNode->mlmState =                        eLIM_MLM_AUTHENTICATED_STATE;                        pAuthNode->authType = (tAniAuthType)                                              pRxAuthFrameBody->authAlgoNumber;                        pAuthNode->fSeen = 0;                        pAuthNode->fTimerStarted = 0;                        pAuthNode->seqNo = ((pHdr->seqControl.seqNumHi << 4) |                                            (pHdr->seqControl.seqNumLo));                        limAddPreAuthNode(pMac, pAuthNode);                        /**                         * Send Authenticaton frame with Success                         * status code.                         */                        authFrame.authAlgoNumber =                        pRxAuthFrameBody->authAlgoNumber;                        authFrame.authTransactionSeqNumber =                        pRxAuthFrameBody->authTransactionSeqNumber + 1;                        authFrame.authStatusCode = eSIR_MAC_SUCCESS_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        /// Send Auth indication to SME                        vos_mem_copy((tANI_U8 *) mlmAuthInd.peerMacAddr,                                     (tANI_U8 *) pHdr->sa,                                     sizeof(tSirMacAddr));                        mlmAuthInd.authType = (tAniAuthType)                                              pRxAuthFrameBody->authAlgoNumber;                        mlmAuthInd.sessionId = psessionEntry->smeSessionId;                        limPostSmeMessage(pMac,                                          LIM_MLM_AUTH_IND,                                          (tANI_U32 *) &mlmAuthInd);                        break;                    case eSIR_SHARED_KEY:                        PELOGW(limLog(pMac, LOGW, FL("=======> eSIR_SHARED_KEY  ..."));)                        if(psessionEntry->limSystemRole == eLIM_AP_ROLE)                        {                            val = psessionEntry->privacy;                        }                        else                        if (wlan_cfgGetInt(pMac, WNI_CFG_PRIVACY_ENABLED,                                      &val) != eSIR_SUCCESS)                        {                            /**                             * Could not get Privacy option                             * from CFG. Log error.                             */                            limLog(pMac, LOGP,                                   FL("could not retrieve Privacy option"));                        }                        cfgPrivacyOptImp = (tANI_U8)val;                        if (!cfgPrivacyOptImp)                        {                            // Log error                            PELOGE(limLog(pMac, LOGE,                                   FL("received Auth frame for unsupported auth algorithm %d "                                   MAC_ADDRESS_STR), pRxAuthFrameBody->authAlgoNumber,                                   MAC_ADDR_ARRAY(pHdr->sa));)                            /**                             * Authenticator does not have WEP                             * implemented.                             * Reject by sending Authentication frame                             * with Auth algorithm not supported status                             * code.                             */                            authFrame.authAlgoNumber =                            pRxAuthFrameBody->authAlgoNumber;                            authFrame.authTransactionSeqNumber =                            pRxAuthFrameBody->authTransactionSeqNumber + 1;                            authFrame.authStatusCode =                            eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS;                            limSendAuthMgmtFrame(                                                pMac, &authFrame,                                                pHdr->sa,                                                LIM_NO_WEP_IN_FC,psessionEntry);                            return;                        }                        else                        {                            // Create entry for this STA                            //in pre-auth list                            pAuthNode = limAcquireFreePreAuthNode(pMac, &pMac->lim.gLimPreAuthTimerTable);                            if (pAuthNode == NULL)                            {                                // Log error                                limLog(pMac, LOGW,                                       FL("Max pre-auth nodes reached "));                                limPrintMacAddr(pMac, pHdr->sa, LOGW);                                return;                            }                            vos_mem_copy((tANI_U8 *) pAuthNode->peerMacAddr,                                          pHdr->sa,                                          sizeof(tSirMacAddr));                            pAuthNode->mlmState =                            eLIM_MLM_WT_AUTH_FRAME3_STATE;                            pAuthNode->authType =                            (tAniAuthType)                            pRxAuthFrameBody->authAlgoNumber;                            pAuthNode->fSeen = 0;                            pAuthNode->fTimerStarted = 0;                            pAuthNode->seqNo = ((pHdr->seqControl.seqNumHi << 4) |                                                (pHdr->seqControl.seqNumLo));                            limAddPreAuthNode(pMac, pAuthNode);                            limLog(pMac, LOG1,                                   FL("Alloc new data: id %d peer "MAC_ADDRESS_STR),                                    pAuthNode->authNodeIdx, MAC_ADDR_ARRAY(pHdr->sa));                            /// Create and activate Auth Response timer                            if (tx_timer_change_context(&pAuthNode->timer, pAuthNode->authNodeIdx) != TX_SUCCESS)                            {                                /// Could not start Auth response timer.                                // Log error                                limLog(pMac, LOGP,                                   FL("Unable to chg context auth response timer for peer "));                                limPrintMacAddr(pMac, pHdr->sa, LOGP);                                /**                                 * Send Authenticaton frame with                                 * unspecified failure status code.                                 */                                authFrame.authAlgoNumber =                                        pRxAuthFrameBody->authAlgoNumber;                                authFrame.authTransactionSeqNumber =                                        pRxAuthFrameBody->authTransactionSeqNumber + 1;                                authFrame.authStatusCode =                                        eSIR_MAC_UNSPEC_FAILURE_STATUS;                                limSendAuthMgmtFrame(pMac, &authFrame,                                                     pHdr->sa,                                                     LIM_NO_WEP_IN_FC,psessionEntry);                                limDeletePreAuthNode(pMac, pHdr->sa);                                return;                            }                            limActivateAuthRspTimer(pMac, pAuthNode);                            pAuthNode->fTimerStarted = 1;                            // get random bytes and use as                            // challenge text                            // TODO                            //if( !VOS_IS_STATUS_SUCCESS( vos_rand_get_bytes( 0, (tANI_U8 *)challengeTextArray, SIR_MAC_AUTH_CHALLENGE_LENGTH ) ) )                            {                               limLog(pMac, LOGE,FL("Challenge text "                               "preparation failed in limProcessAuthFrame"));                            }                            pChallenge = pAuthNode->challengeText;                            vos_mem_copy(pChallenge,                                        (tANI_U8 *) challengeTextArray,                                         sizeof(challengeTextArray));                            /**                             * Sending Authenticaton frame with challenge.                             */                            authFrame.authAlgoNumber =                            pRxAuthFrameBody->authAlgoNumber;                            authFrame.authTransactionSeqNumber =                            pRxAuthFrameBody->authTransactionSeqNumber + 1;                            authFrame.authStatusCode =                            eSIR_MAC_SUCCESS_STATUS;                            authFrame.type   = SIR_MAC_CHALLENGE_TEXT_EID;                            authFrame.length = SIR_MAC_AUTH_CHALLENGE_LENGTH;                            vos_mem_copy(authFrame.challengeText,                                         pAuthNode->challengeText,                                         SIR_MAC_AUTH_CHALLENGE_LENGTH);                            limSendAuthMgmtFrame(                                                pMac, &authFrame,                                                pHdr->sa,                                                LIM_NO_WEP_IN_FC,psessionEntry);                        } // if (wlan_cfgGetInt(CFG_PRIVACY_OPTION_IMPLEMENTED))                        break;                    default:                         // Log error                       PELOGE( limLog(pMac, LOGE,                               FL("received Auth frame for unsupported auth "                               "algorithm %d "MAC_ADDRESS_STR),                               pRxAuthFrameBody->authAlgoNumber,                               MAC_ADDR_ARRAY(pHdr->sa));)                        /**                         * Responding party does not support the                         * authentication algorithm requested by                         * sending party.                         * Reject by sending Authentication frame                         * with auth algorithm not supported status code                         */                        authFrame.authAlgoNumber =                        pRxAuthFrameBody->authAlgoNumber;                        authFrame.authTransactionSeqNumber =                        pRxAuthFrameBody->authTransactionSeqNumber + 1;                        authFrame.authStatusCode =                        eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                } // end switch(pRxAuthFrameBody->authAlgoNumber)            } // if (limIsAuthAlgoSupported(pRxAuthFrameBody->authAlgoNumber))            else            {                // Log error                PELOGE(limLog(pMac, LOGE,                       FL("received Authentication frame for unsupported auth "                       "algorithm %d "MAC_ADDRESS_STR),                       pRxAuthFrameBody->authAlgoNumber,                       MAC_ADDR_ARRAY(pHdr->sa));)                /**                 * Responding party does not support the                 * authentication algorithm requested by sending party.                 * Reject Authentication with StatusCode=13.                 */                authFrame.authAlgoNumber =                pRxAuthFrameBody->authAlgoNumber;                authFrame.authTransactionSeqNumber =                pRxAuthFrameBody->authTransactionSeqNumber + 1;                authFrame.authStatusCode =                eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS;                limSendAuthMgmtFrame(pMac, &authFrame,                                     pHdr->sa,                                     LIM_NO_WEP_IN_FC,psessionEntry);                return;            } //end if (limIsAuthAlgoSupported(pRxAuthFrameBody->authAlgoNumber))            break;        case SIR_MAC_AUTH_FRAME_2:            // AuthFrame 2            if (psessionEntry->limMlmState != eLIM_MLM_WT_AUTH_FRAME2_STATE)            {                /**                 * Received Authentication frame2 in an unexpected state.                 * Log error and ignore the frame.                 */                // Log error                limLog(pMac, LOG1,                       FL("received Auth frame2 from peer in state %d, addr "),                       psessionEntry->limMlmState);                limPrintMacAddr(pMac, pHdr->sa, LOG1);                return;            }            if ( !vos_mem_compare((tANI_U8 *) pHdr->sa,                                  (tANI_U8 *) &pMac->lim.gpLimMlmAuthReq->peerMacAddr,                                  sizeof(tSirMacAddr)) )            {                /**                 * Received Authentication frame from an entity                 * other than one request was initiated.                 * Wait until Authentication Failure Timeout.                 */                // Log error                PELOGW(limLog(pMac, LOGW,                       FL("received Auth frame2 from unexpected peer "                       MAC_ADDRESS_STR),                       MAC_ADDR_ARRAY(pHdr->sa));)                break;            }            if (pRxAuthFrameBody->authStatusCode ==                eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS)            {                /**                 * Interoperability workaround: Linksys WAP4400N is returning                 * wrong authType in OpenAuth response in case of                 * SharedKey AP configuration. Pretend we don't see that,                 * so upper layer can fallback to SharedKey authType,                 * and successfully connect to the AP.                 */                if (pRxAuthFrameBody->authAlgoNumber !=                    pMac->lim.gpLimMlmAuthReq->authType)                {                    pRxAuthFrameBody->authAlgoNumber =                    pMac->lim.gpLimMlmAuthReq->authType;                }            }            if (pRxAuthFrameBody->authAlgoNumber !=                pMac->lim.gpLimMlmAuthReq->authType)            {                /**                 * Received Authentication frame with an auth                 * algorithm other than one requested.                 * Wait until Authentication Failure Timeout.                 */                // Log error                PELOGW(limLog(pMac, LOGW,                       FL("received Auth frame2 for unexpected auth algo number %d "                       MAC_ADDRESS_STR), pRxAuthFrameBody->authAlgoNumber,                       MAC_ADDR_ARRAY(pHdr->sa));)                break;            }            if (pRxAuthFrameBody->authStatusCode ==                eSIR_MAC_SUCCESS_STATUS)            {                if (pRxAuthFrameBody->authAlgoNumber ==                    eSIR_OPEN_SYSTEM)                {                    psessionEntry->limCurrentAuthType = eSIR_OPEN_SYSTEM;                    pAuthNode = limAcquireFreePreAuthNode(pMac, &pMac->lim.gLimPreAuthTimerTable);                    if (pAuthNode == NULL)                    {                        // Log error                        limLog(pMac, LOGW,                               FL("Max pre-auth nodes reached "));                        limPrintMacAddr(pMac, pHdr->sa, LOGW);                        return;                    }                    limLog(pMac, LOG1,                              FL("Alloc new data: peer "MAC_ADDRESS_STR),                                                 MAC_ADDR_ARRAY(pHdr->sa));                    vos_mem_copy((tANI_U8 *) pAuthNode->peerMacAddr,                                 pMac->lim.gpLimMlmAuthReq->peerMacAddr,                                 sizeof(tSirMacAddr));                    pAuthNode->fTimerStarted = 0;                    pAuthNode->authType = pMac->lim.gpLimMlmAuthReq->authType;                    pAuthNode->seqNo = ((pHdr->seqControl.seqNumHi << 4) |                                        (pHdr->seqControl.seqNumLo));                    limAddPreAuthNode(pMac, pAuthNode);                    limRestoreFromAuthState(pMac, eSIR_SME_SUCCESS,                                            pRxAuthFrameBody->authStatusCode,psessionEntry);                } // if (pRxAuthFrameBody->authAlgoNumber == eSIR_OPEN_SYSTEM)                else                {                    // Shared key authentication                    if(psessionEntry->limSystemRole == eLIM_AP_ROLE)                    {                        val = psessionEntry->privacy;                    }                    else                    if (wlan_cfgGetInt(pMac, WNI_CFG_PRIVACY_ENABLED,                                  &val) != eSIR_SUCCESS)                    {                        /**                         * Could not get Privacy option                         * from CFG. Log error.                         */                        limLog(pMac, LOGP,                               FL("could not retrieve Privacy option"));                    }                    cfgPrivacyOptImp = (tANI_U8)val;                    if (!cfgPrivacyOptImp)                    {                        /**                         * Requesting STA does not have WEP implemented.                         * Reject with unsupported authentication algorithm                         * Status code and wait until auth failure timeout                         */                        // Log error                       PELOGE( limLog(pMac, LOGE,                               FL("received Auth frame from peer for "                               "unsupported auth algo %d "                               MAC_ADDRESS_STR), pRxAuthFrameBody->authAlgoNumber,                               MAC_ADDR_ARRAY(pHdr->sa));)                        authFrame.authAlgoNumber =                        pRxAuthFrameBody->authAlgoNumber;                        authFrame.authTransactionSeqNumber =                        pRxAuthFrameBody->authTransactionSeqNumber + 1;                        authFrame.authStatusCode =                        eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS;                        limSendAuthMgmtFrame(pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }                    else                    {                        if (pRxAuthFrameBody->type !=                            SIR_MAC_CHALLENGE_TEXT_EID)                        {                            // Log error                            PELOGE(limLog(pMac, LOGE,                                   FL("received Auth frame with invalid "                                   "challenge text IE"));)                            return;                        }                        /**                         * Check if there exists a key mappping key                         * for the STA that sent Authentication frame                         */                        pKeyMapEntry = limLookUpKeyMappings(                                                           pHdr->sa);                        if (pKeyMapEntry)                        {                            if (pKeyMapEntry->key == NULL)                            {                                // Log error                                PELOGE(limLog(pMac, LOGE,                                       FL("received Auth frame from peer when "                                       "key mapping key is NULL"MAC_ADDRESS_STR),                                       MAC_ADDR_ARRAY(pHdr->sa));)                                /**                                 * Key Mapping entry has null key.                                 * Send Auth frame with                                 * challenge failure status code                                 */                                authFrame.authAlgoNumber =                                pRxAuthFrameBody->authAlgoNumber;                                authFrame.authTransactionSeqNumber =                                pRxAuthFrameBody->authTransactionSeqNumber + 1;                                authFrame.authStatusCode =                                eSIR_MAC_CHALLENGE_FAILURE_STATUS;                                limSendAuthMgmtFrame(pMac, &authFrame,                                                     pHdr->sa,                                                     LIM_NO_WEP_IN_FC,psessionEntry);                                limRestoreFromAuthState(pMac, eSIR_SME_NO_KEY_MAPPING_KEY_FOR_PEER,                                                              eSIR_MAC_UNSPEC_FAILURE_REASON,psessionEntry);                                return;                            } // if (pKeyMapEntry->key == NULL)                            else                            {                                ((tpSirMacAuthFrameBody) plainBody)->authAlgoNumber =                                sirSwapU16ifNeeded(pRxAuthFrameBody->authAlgoNumber);                                ((tpSirMacAuthFrameBody) plainBody)->authTransactionSeqNumber =                                sirSwapU16ifNeeded((tANI_U16) (pRxAuthFrameBody->authTransactionSeqNumber + 1));                                ((tpSirMacAuthFrameBody) plainBody)->authStatusCode = eSIR_MAC_SUCCESS_STATUS;                                ((tpSirMacAuthFrameBody) plainBody)->type   = SIR_MAC_CHALLENGE_TEXT_EID;                                ((tpSirMacAuthFrameBody) plainBody)->length = SIR_MAC_AUTH_CHALLENGE_LENGTH;                                vos_mem_copy((tANI_U8 *) ((tpSirMacAuthFrameBody) plainBody)->challengeText,                                              pRxAuthFrameBody->challengeText,                                              SIR_MAC_AUTH_CHALLENGE_LENGTH);                                limEncryptAuthFrame(pMac, 0,                                                    pKeyMapEntry->key,                                                    plainBody,                                                    encrAuthFrame,key_length);                                psessionEntry->limMlmState = eLIM_MLM_WT_AUTH_FRAME4_STATE;                                MTRACE(macTrace(pMac, TRACE_CODE_MLM_STATE, psessionEntry->peSessionId, psessionEntry->limMlmState));                                limSendAuthMgmtFrame(pMac,                                                     (tpSirMacAuthFrameBody) encrAuthFrame,                                                     pHdr->sa,                                                     LIM_WEP_IN_FC,psessionEntry);                                break;                            } // end if (pKeyMapEntry->key == NULL)                        } // if (pKeyMapEntry)                        else                        {                            if (wlan_cfgGetInt(pMac, WNI_CFG_WEP_DEFAULT_KEYID,                                          &val) != eSIR_SUCCESS)                            {                                /**                                 * Could not get Default keyId                                 * from CFG. Log error.                                 */                                limLog(pMac, LOGP,                                       FL("could not retrieve Default keyId"));                            }                            keyId = (tANI_U8)val;                            val = SIR_MAC_KEY_LENGTH;                            if(psessionEntry->limSystemRole == eLIM_AP_ROLE)                            {                                tpSirKeys pKey;                                pKey =  &psessionEntry->WEPKeyMaterial[keyId].key[0];                                vos_mem_copy(defaultKey, pKey->key, pKey->keyLength);                            }                            else                            if (wlan_cfgGetStr(pMac, (tANI_U16) (WNI_CFG_WEP_DEFAULT_KEY_1 + keyId),                                          defaultKey,                                          &val)                                != eSIR_SUCCESS)                            {                                /// Could not get Default key from CFG.                                //Log error.                                limLog(pMac, LOGP,                                       FL("could not retrieve Default key"));                                authFrame.authAlgoNumber =                                pRxAuthFrameBody->authAlgoNumber;                                authFrame.authTransactionSeqNumber =                                pRxAuthFrameBody->authTransactionSeqNumber + 1;                                authFrame.authStatusCode =                                eSIR_MAC_CHALLENGE_FAILURE_STATUS;                                limSendAuthMgmtFrame(                                                    pMac, &authFrame,                                                    pHdr->sa,                                                    LIM_NO_WEP_IN_FC,psessionEntry);                                limRestoreFromAuthState(pMac, eSIR_SME_INVALID_WEP_DEFAULT_KEY,                                                              eSIR_MAC_UNSPEC_FAILURE_REASON,psessionEntry);                                break;                            }                                key_length=val;                                ((tpSirMacAuthFrameBody) plainBody)->authAlgoNumber =                                sirSwapU16ifNeeded(pRxAuthFrameBody->authAlgoNumber);                                ((tpSirMacAuthFrameBody) plainBody)->authTransactionSeqNumber =                                sirSwapU16ifNeeded((tANI_U16) (pRxAuthFrameBody->authTransactionSeqNumber + 1));                                ((tpSirMacAuthFrameBody) plainBody)->authStatusCode = eSIR_MAC_SUCCESS_STATUS;                                ((tpSirMacAuthFrameBody) plainBody)->type   = SIR_MAC_CHALLENGE_TEXT_EID;                                ((tpSirMacAuthFrameBody) plainBody)->length = SIR_MAC_AUTH_CHALLENGE_LENGTH;                                vos_mem_copy((tANI_U8 *) ((tpSirMacAuthFrameBody) plainBody)->challengeText,                                              pRxAuthFrameBody->challengeText,                                              SIR_MAC_AUTH_CHALLENGE_LENGTH);                                limEncryptAuthFrame(pMac, keyId,                                                    defaultKey,                                                    plainBody,                                                    encrAuthFrame,key_length);                                psessionEntry->limMlmState =                                eLIM_MLM_WT_AUTH_FRAME4_STATE;                                MTRACE(macTrace(pMac, TRACE_CODE_MLM_STATE, psessionEntry->peSessionId, psessionEntry->limMlmState));                                limSendAuthMgmtFrame(pMac,                                                     (tpSirMacAuthFrameBody) encrAuthFrame,                                                     pHdr->sa,                                                     LIM_WEP_IN_FC,psessionEntry);                                break;                        } // end if (pKeyMapEntry)                    } // end if (!wlan_cfgGetInt(CFG_PRIVACY_OPTION_IMPLEMENTED))                } // end if (pRxAuthFrameBody->authAlgoNumber == eSIR_OPEN_SYSTEM)            } // if (pRxAuthFrameBody->authStatusCode == eSIR_MAC_SUCCESS_STATUS)            else            {                /**                 * Authentication failure.                 * Return Auth confirm with received failure code to SME                 */                // Log error                PELOGE(limLog(pMac, LOGE,                       FL("received Auth frame from peer with failure code %d "                       MAC_ADDRESS_STR), pRxAuthFrameBody->authStatusCode,                       MAC_ADDR_ARRAY(pHdr->sa));)                limRestoreFromAuthState(pMac, eSIR_SME_AUTH_REFUSED,                                              pRxAuthFrameBody->authStatusCode,psessionEntry);            } // end if (pRxAuthFrameBody->authStatusCode == eSIR_MAC_SUCCESS_STATUS)            break;        case SIR_MAC_AUTH_FRAME_3:            // AuthFrame 3            if (pRxAuthFrameBody->authAlgoNumber != eSIR_SHARED_KEY)            {                // Log error                PELOGE(limLog(pMac, LOGE,                       FL("received Auth frame3 from peer with auth algo "                       "number %d "MAC_ADDRESS_STR),                       pRxAuthFrameBody->authAlgoNumber,                       MAC_ADDR_ARRAY(pHdr->sa));)                /**                 * Received Authentication frame3 with algorithm other than                 * Shared Key authentication type. Reject with Auth frame4                 * with 'out of sequence' status code.                 */                authFrame.authAlgoNumber = eSIR_SHARED_KEY;                authFrame.authTransactionSeqNumber =                SIR_MAC_AUTH_FRAME_4;                authFrame.authStatusCode =                eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                limSendAuthMgmtFrame(pMac, &authFrame,                                     pHdr->sa,                                     LIM_NO_WEP_IN_FC,psessionEntry);                return;            }            if (psessionEntry->limSystemRole == eLIM_AP_ROLE || psessionEntry->limSystemRole == eLIM_BT_AMP_AP_ROLE ||                psessionEntry->limSystemRole == eLIM_STA_IN_IBSS_ROLE)            {                /**                 * Check if wep bit was set in FC. If not set,                 * reject with Authentication frame4 with                 * 'challenge failure' status code.                 */                if (!pHdr->fc.wep)                {                    // Log error                    PELOGE(limLog(pMac, LOGE,                           FL("received Auth frame3 from peer with no WEP bit "                           "set "MAC_ADDRESS_STR),                           MAC_ADDR_ARRAY(pHdr->sa));)                    /// WEP bit is not set in FC of Auth Frame3                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }                pAuthNode = limSearchPreAuthList(pMac,                                                pHdr->sa);                if (pAuthNode == NULL)                {                     // Log error                    PELOGE(limLog(pMac, LOGW,                           FL("received AuthFrame3 from peer that has no "                           "preauth context "MAC_ADDRESS_STR),                            MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * No 'pre-auth' context exists for                     * this STA that sent an Authentication                     * frame3.                     * Send Auth frame4 with 'out of sequence'                     * status code.                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }                if (pAuthNode->mlmState == eLIM_MLM_AUTH_RSP_TIMEOUT_STATE)                {                    // Log error                    limLog(pMac, LOGW,                           FL("auth response timer timedout for peer "                           MAC_ADDRESS_STR),MAC_ADDR_ARRAY(pHdr->sa));                    /**                     * Received Auth Frame3 after Auth Response timeout.                     * Reject by sending Auth Frame4 with                     * Auth respone timeout Status Code.                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_AUTH_RSP_TIMEOUT_STATUS;                    limSendAuthMgmtFrame(                                        pMac, &authFrame,                                        pHdr->sa,                                        LIM_NO_WEP_IN_FC,psessionEntry);                    /// Delete pre-auth context of STA                    limDeletePreAuthNode(pMac,                                         pHdr->sa);                    return;                } // end switch (pAuthNode->mlmState)                if (pRxAuthFrameBody->authStatusCode != eSIR_MAC_SUCCESS_STATUS)                {                    /**                     * Received Authenetication Frame 3 with status code                     * other than success. Wait until Auth response timeout                     * to delete STA context.                     */                    // Log error                    PELOGE(limLog(pMac, LOGE,                           FL("received Auth frame3 from peer with status code %d "                           MAC_ADDRESS_STR), pRxAuthFrameBody->authStatusCode,                           MAC_ADDR_ARRAY(pHdr->sa));)                    return;                }                /**                 * Check if received challenge text is same as one sent in                 * Authentication frame3                 */                if (vos_mem_compare(pRxAuthFrameBody->challengeText,                                    pAuthNode->challengeText,                                    SIR_MAC_AUTH_CHALLENGE_LENGTH))                {                    /// Challenge match. STA is autheticated !                    /// Delete Authentication response timer if running                    limDeactivateAndChangePerStaIdTimer(pMac,                                                        eLIM_AUTH_RSP_TIMER,                                                        pAuthNode->authNodeIdx);                    pAuthNode->fTimerStarted = 0;                    pAuthNode->mlmState = eLIM_MLM_AUTHENTICATED_STATE;                    /**                     * Send Authentication Frame4 with 'success' Status Code.                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode = eSIR_MAC_SUCCESS_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    /// Send Auth indication to SME                    vos_mem_copy((tANI_U8 *) mlmAuthInd.peerMacAddr,                                 (tANI_U8 *) pHdr->sa,                                  sizeof(tSirMacAddr));                    mlmAuthInd.authType = (tAniAuthType)                                          pRxAuthFrameBody->authAlgoNumber;                    mlmAuthInd.sessionId = psessionEntry->smeSessionId;                    limPostSmeMessage(pMac,                                      LIM_MLM_AUTH_IND,                                      (tANI_U32 *) &mlmAuthInd);                    break;                }                else                {                     // Log error                    PELOGE( limLog(pMac, LOGW,                                   FL("Challenge failure for peer "                                   MAC_ADDRESS_STR),                                   MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * Challenge Failure.                     * Send Authentication frame4 with 'challenge failure'                     * status code and wait until Auth response timeout to                     * delete STA context.                     */                    authFrame.authAlgoNumber =                        pRxAuthFrameBody->authAlgoNumber;                    authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }            } // if (pMac->lim.gLimSystemRole == eLIM_AP_ROLE || ...            break;        case SIR_MAC_AUTH_FRAME_4:            // AuthFrame 4            if (psessionEntry->limMlmState != eLIM_MLM_WT_AUTH_FRAME4_STATE)            {                /**                 * Received Authentication frame4 in an unexpected state.                 * Log error and ignore the frame.                 */                // Log error                limLog(pMac, LOG1,                       FL("received unexpected Auth frame4 from peer in state "                       "%d, addr "MAC_ADDRESS_STR), psessionEntry->limMlmState,                       MAC_ADDR_ARRAY(pHdr->sa));                return;            }            if (pRxAuthFrameBody->authAlgoNumber != eSIR_SHARED_KEY)            {                /**                 * Received Authentication frame4 with algorithm other than                 * Shared Key authentication type.                 * Wait until Auth failure timeout to report authentication                 * failure to SME.                 */                // Log error                PELOGE(limLog(pMac, LOGE,                       FL("received Auth frame4 from peer with invalid auth "                       "algo %d "MAC_ADDRESS_STR), pRxAuthFrameBody->authAlgoNumber,                       MAC_ADDR_ARRAY(pHdr->sa));)                return;            }            if ( !vos_mem_compare((tANI_U8 *) pHdr->sa,                                  (tANI_U8 *) &pMac->lim.gpLimMlmAuthReq->peerMacAddr,                                  sizeof(tSirMacAddr)) )            {                /**                 * Received Authentication frame from an entity                 * other than one to which request was initiated.                 * Wait until Authentication Failure Timeout.                 */                // Log error                PELOGE(limLog(pMac, LOGW,                       FL("received Auth frame4 from unexpected peer "                       MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                break;            }            if (pRxAuthFrameBody->authAlgoNumber !=                pMac->lim.gpLimMlmAuthReq->authType)            {                /**                 * Received Authentication frame with an auth algorithm                 * other than one requested.                 * Wait until Authentication Failure Timeout.                 */                PELOGE(limLog(pMac, LOGE,                       FL("received Authentication frame from peer with "                       "invalid auth seq number %d "                       MAC_ADDRESS_STR), pRxAuthFrameBody->authTransactionSeqNumber,                       MAC_ADDR_ARRAY(pHdr->sa));)                break;            }            if (pRxAuthFrameBody->authStatusCode ==                eSIR_MAC_SUCCESS_STATUS)            {                /**                 * Authentication Success !                 * Inform SME of same.                 */                psessionEntry->limCurrentAuthType = eSIR_SHARED_KEY;                pAuthNode = limAcquireFreePreAuthNode(pMac, &pMac->lim.gLimPreAuthTimerTable);                if (pAuthNode == NULL)                {                    // Log error                    limLog(pMac, LOGW,                           FL("Max pre-auth nodes reached "));                    limPrintMacAddr(pMac, pHdr->sa, LOGW);                    return;                }                limLog(pMac, LOG1,                         FL("Alloc new data: peer " MAC_ADDRESS_STR),                                              MAC_ADDR_ARRAY(pHdr->sa));                vos_mem_copy((tANI_U8 *) pAuthNode->peerMacAddr,                             pMac->lim.gpLimMlmAuthReq->peerMacAddr,                             sizeof(tSirMacAddr));                pAuthNode->fTimerStarted = 0;                pAuthNode->authType = pMac->lim.gpLimMlmAuthReq->authType;                pAuthNode->seqNo = ((pHdr->seqControl.seqNumHi << 4) |                                    (pHdr->seqControl.seqNumLo));                limAddPreAuthNode(pMac, pAuthNode);                limRestoreFromAuthState(pMac, eSIR_SME_SUCCESS,                                              pRxAuthFrameBody->authStatusCode,psessionEntry);            } // if (pRxAuthFrameBody->authStatusCode == eSIR_MAC_SUCCESS_STATUS)            else            {                /**                 * Authentication failure.                 * Return Auth confirm with received failure code to SME                 */                // Log error                PELOGE(limLog(pMac, LOGE, FL("Authentication failure from peer "                       MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                limRestoreFromAuthState(pMac, eSIR_SME_AUTH_REFUSED,                                              pRxAuthFrameBody->authStatusCode,psessionEntry);            } // end if (pRxAuthFrameBody->Status == 0)            break;        default:            /// Invalid Authentication Frame received. Ignore it.            // Log error            PELOGE(limLog(pMac, LOGE,                   FL("received Auth frame from peer with invalid auth seq "                   "number %d " MAC_ADDRESS_STR),                   pRxAuthFrameBody->authTransactionSeqNumber,                   MAC_ADDR_ARRAY(pHdr->sa));)            break;    } // end switch (pRxAuthFrameBody->authTransactionSeqNumber)}
tANI_U8                 *pBody, keyId, cfgPrivacyOptImp,                            defaultKey[SIR_MAC_KEY_LENGTH],                            encrAuthFrame[LIM_ENCR_AUTH_BODY_LEN],                            plainBody[256];
tANI_U8                 *pBody, keyId, cfgPrivacyOptImp,                            defaultKey[SIR_MAC_KEY_LENGTH],                            encrAuthFrame[LIM_ENCR_AUTH_BODY_LEN],                            plainBody[256];
tANI_U8
tANI_U8
*pBody
*
pBody
keyId
keyId
cfgPrivacyOptImp
cfgPrivacyOptImp
defaultKey[SIR_MAC_KEY_LENGTH]
defaultKey
[SIR_MAC_KEY_LENGTH]
SIR_MAC_KEY_LENGTH
SIR_MAC_KEY_LENGTH
encrAuthFrame[LIM_ENCR_AUTH_BODY_LEN]
encrAuthFrame
[LIM_ENCR_AUTH_BODY_LEN]
LIM_ENCR_AUTH_BODY_LEN
LIM_ENCR_AUTH_BODY_LEN
plainBody[256]
plainBody
[256]
256
tANI_U16                frameLen;
tANI_U16                frameLen;
tANI_U16
tANI_U16
frameLen
frameLen
tANI_U32                maxNumPreAuth, val;
tANI_U32                maxNumPreAuth, val;
tANI_U32
tANI_U32
maxNumPreAuth
maxNumPreAuth
val
val
tSirMacAuthFrameBody    *pRxAuthFrameBody, rxAuthFrame, authFrame;
tSirMacAuthFrameBody    *pRxAuthFrameBody, rxAuthFrame, authFrame;
tSirMacAuthFrameBody
tSirMacAuthFrameBody
*pRxAuthFrameBody
*
pRxAuthFrameBody
rxAuthFrame
rxAuthFrame
authFrame
authFrame
tpSirMacMgmtHdr         pHdr;
tpSirMacMgmtHdr         pHdr;
tpSirMacMgmtHdr
tpSirMacMgmtHdr
pHdr
pHdr
tCfgWepKeyEntry         *pKeyMapEntry = NULL;
tCfgWepKeyEntry         *pKeyMapEntry = NULL;
tCfgWepKeyEntry
tCfgWepKeyEntry
*pKeyMapEntry = NULL
*
pKeyMapEntry
= NULL
NULL
NULL
struct tLimPreAuthNode  *pAuthNode;
struct tLimPreAuthNode  *pAuthNode;
struct tLimPreAuthNode
tLimPreAuthNode
*pAuthNode
*
pAuthNode
tLimMlmAuthInd          mlmAuthInd;
tLimMlmAuthInd          mlmAuthInd;
tLimMlmAuthInd
tLimMlmAuthInd
mlmAuthInd
mlmAuthInd
tANI_U8                 decryptResult;
tANI_U8                 decryptResult;
tANI_U8
tANI_U8
decryptResult
decryptResult
tANI_U8                 *pChallenge;
tANI_U8                 *pChallenge;
tANI_U8
tANI_U8
*pChallenge
*
pChallenge
tANI_U32                key_length=8;
tANI_U32                key_length=8;
tANI_U32
tANI_U32
key_length=8
key_length
=8
8
tANI_U8                 challengeTextArray[SIR_MAC_AUTH_CHALLENGE_LENGTH];
tANI_U8                 challengeTextArray[SIR_MAC_AUTH_CHALLENGE_LENGTH];
tANI_U8
tANI_U8
challengeTextArray[SIR_MAC_AUTH_CHALLENGE_LENGTH]
challengeTextArray
[SIR_MAC_AUTH_CHALLENGE_LENGTH]
SIR_MAC_AUTH_CHALLENGE_LENGTH
SIR_MAC_AUTH_CHALLENGE_LENGTH
tpDphHashNode           pStaDs = NULL;
tpDphHashNode           pStaDs = NULL;
tpDphHashNode
tpDphHashNode
pStaDs = NULL
pStaDs
= NULL
NULL
NULL
tANI_U16                assocId = 0;
tANI_U16                assocId = 0;
tANI_U16
tANI_U16
assocId = 0
assocId
= 0
0
tANI_U16                currSeqNo = 0;
tANI_U16                currSeqNo = 0;
tANI_U16
tANI_U16
currSeqNo = 0
currSeqNo
= 0
0
pHdr = WDA_GET_RX_MAC_HEADER(pRxPacketInfo);
pHdr = WDA_GET_RX_MAC_HEADER(pRxPacketInfo)
pHdr
pHdr
WDA_GET_RX_MAC_HEADER(pRxPacketInfo)
WDA_GET_RX_MAC_HEADER
WDA_GET_RX_MAC_HEADER
pRxPacketInfo
pRxPacketInfo
frameLen = WDA_GET_RX_PAYLOAD_LEN(pRxPacketInfo);
frameLen = WDA_GET_RX_PAYLOAD_LEN(pRxPacketInfo)
frameLen
frameLen
WDA_GET_RX_PAYLOAD_LEN(pRxPacketInfo)
WDA_GET_RX_PAYLOAD_LEN
WDA_GET_RX_PAYLOAD_LEN
pRxPacketInfo
pRxPacketInfo
if (!frameLen)    {        // Log error        limLog(pMac, LOGE,               FL("received Authentication frame with no body from "));        limPrintMacAddr(pMac, pHdr->sa, LOGE);        return;    }
!frameLen
frameLen
frameLen
{        // Log error        limLog(pMac, LOGE,               FL("received Authentication frame with no body from "));        limPrintMacAddr(pMac, pHdr->sa, LOGE);        return;    }
limLog(pMac, LOGE,               FL("received Authentication frame with no body from "));
limLog(pMac, LOGE,               FL("received Authentication frame with no body from "))
limLog
limLog
pMac
pMac
LOGE
LOGE
FL("received Authentication frame with no body from ")
FL
FL
"received Authentication frame with no body from "
limPrintMacAddr(pMac, pHdr->sa, LOGE);
limPrintMacAddr(pMac, pHdr->sa, LOGE)
limPrintMacAddr
limPrintMacAddr
pMac
pMac
pHdr->sa
pHdr
pHdr
sa
LOGE
LOGE
return;
if (limIsGroupAddr(pHdr->sa))    {        // Received Auth frame from a BC/MC address        // Log error and ignore it       limLog(pMac, LOGE,               FL("received Auth frame from a BC/MC address - "));       limPrintMacAddr(pMac, pHdr->sa, LOGE);        return;    }
limIsGroupAddr(pHdr->sa)
limIsGroupAddr
limIsGroupAddr
pHdr->sa
pHdr
pHdr
sa
{        // Received Auth frame from a BC/MC address        // Log error and ignore it       limLog(pMac, LOGE,               FL("received Auth frame from a BC/MC address - "));       limPrintMacAddr(pMac, pHdr->sa, LOGE);        return;    }
limLog(pMac, LOGE,               FL("received Auth frame from a BC/MC address - "));
limLog(pMac, LOGE,               FL("received Auth frame from a BC/MC address - "))
limLog
limLog
pMac
pMac
LOGE
LOGE
FL("received Auth frame from a BC/MC address - ")
FL
FL
"received Auth frame from a BC/MC address - "
limPrintMacAddr(pMac, pHdr->sa, LOGE);
limPrintMacAddr(pMac, pHdr->sa, LOGE)
limPrintMacAddr
limPrintMacAddr
pMac
pMac
pHdr->sa
pHdr
pHdr
sa
LOGE
LOGE
return;
currSeqNo = (pHdr->seqControl.seqNumHi << 4) | (pHdr->seqControl.seqNumLo);
currSeqNo = (pHdr->seqControl.seqNumHi << 4) | (pHdr->seqControl.seqNumLo)
currSeqNo
currSeqNo
(pHdr->seqControl.seqNumHi << 4) | (pHdr->seqControl.seqNumLo)
(pHdr->seqControl.seqNumHi << 4)
pHdr->seqControl.seqNumHi << 4
pHdr->seqControl.seqNumHi
pHdr->seqControl
pHdr
pHdr
seqControl
seqNumHi
4
(pHdr->seqControl.seqNumLo)
pHdr->seqControl.seqNumLo
pHdr->seqControl
pHdr
pHdr
seqControl
seqNumLo
limLog(pMac, LOG1,               FL("Sessionid: %d System role : %d limMlmState: %d :Auth "               "Frame Received: BSSID: "MAC_ADDRESS_STR " (RSSI %d)"),               psessionEntry->peSessionId, psessionEntry->limSystemRole,               psessionEntry->limMlmState, MAC_ADDR_ARRAY(pHdr->bssId),               (uint)abs((tANI_S8)WDA_GET_RX_RSSI_DB(pRxPacketInfo)));
pBody = WDA_GET_RX_MPDU_DATA(pRxPacketInfo);
pBody = WDA_GET_RX_MPDU_DATA(pRxPacketInfo)
pBody
pBody
WDA_GET_RX_MPDU_DATA(pRxPacketInfo)
WDA_GET_RX_MPDU_DATA
WDA_GET_RX_MPDU_DATA
pRxPacketInfo
pRxPacketInfo
if (VOS_P2P_CLIENT_MODE == psessionEntry->pePersona && psessionEntry->defaultAuthFailureTimeout)    {        limLog(pMac, LOG1, FL("Restore default failure timeout"));        ccmCfgSetInt(pMac,WNI_CFG_AUTHENTICATE_FAILURE_TIMEOUT ,                          psessionEntry->defaultAuthFailureTimeout, NULL, eANI_BOOLEAN_FALSE);    }
VOS_P2P_CLIENT_MODE == psessionEntry->pePersona && psessionEntry->defaultAuthFailureTimeout
VOS_P2P_CLIENT_MODE == psessionEntry->pePersona
VOS_P2P_CLIENT_MODE
VOS_P2P_CLIENT_MODE
psessionEntry->pePersona
psessionEntry
psessionEntry
pePersona
psessionEntry->defaultAuthFailureTimeout
psessionEntry
psessionEntry
defaultAuthFailureTimeout
{        limLog(pMac, LOG1, FL("Restore default failure timeout"));        ccmCfgSetInt(pMac,WNI_CFG_AUTHENTICATE_FAILURE_TIMEOUT ,                          psessionEntry->defaultAuthFailureTimeout, NULL, eANI_BOOLEAN_FALSE);    }
limLog(pMac, LOG1, FL("Restore default failure timeout"));
limLog(pMac, LOG1, FL("Restore default failure timeout"))
limLog
limLog
pMac
pMac
LOG1
LOG1
FL("Restore default failure timeout")
FL
FL
"Restore default failure timeout"
ccmCfgSetInt(pMac,WNI_CFG_AUTHENTICATE_FAILURE_TIMEOUT ,                          psessionEntry->defaultAuthFailureTimeout, NULL, eANI_BOOLEAN_FALSE);
ccmCfgSetInt(pMac,WNI_CFG_AUTHENTICATE_FAILURE_TIMEOUT ,                          psessionEntry->defaultAuthFailureTimeout, NULL, eANI_BOOLEAN_FALSE)
ccmCfgSetInt
ccmCfgSetInt
pMac
pMac
WNI_CFG_AUTHENTICATE_FAILURE_TIMEOUT
WNI_CFG_AUTHENTICATE_FAILURE_TIMEOUT
psessionEntry->defaultAuthFailureTimeout
psessionEntry
psessionEntry
defaultAuthFailureTimeout
NULL
NULL
eANI_BOOLEAN_FALSE
eANI_BOOLEAN_FALSE
if (pHdr->fc.wep)    {        /**         * WEP bit is set in FC of MAC header.         */        // If TKIP counter measures enabled issue Deauth frame to station        if ((psessionEntry->bTkipCntrMeasActive) && (psessionEntry->limSystemRole == eLIM_AP_ROLE))        {            PELOGE( limLog(pMac, LOGE,               FL("Tkip counter measures Enabled, sending Deauth frame to")); )            limPrintMacAddr(pMac, pHdr->sa, LOGE);            limSendDeauthMgmtFrame( pMac, eSIR_MAC_MIC_FAILURE_REASON,                                    pHdr->sa, psessionEntry, FALSE );            return;        }        // Extract key ID from IV (most 2 bits of 4th byte of IV)        keyId = (*(pBody + 3)) >> 6;        /**         * On STA in infrastructure BSS, Authentication frames received         * with WEP bit set in the FC must be rejected with challenge         * failure status code (wierd thing in the spec - this should have         * been rejected with unspecified failure or unexpected assertion         * of wep bit (this status code does not exist though) or         * Out-of-sequence-Authentication-Frame status code.         */        if (psessionEntry->limSystemRole == eLIM_STA_ROLE || psessionEntry->limSystemRole == eLIM_BT_AMP_STA_ROLE)        {            authFrame.authAlgoNumber = eSIR_SHARED_KEY;            authFrame.authTransactionSeqNumber = SIR_MAC_AUTH_FRAME_4;            authFrame.authStatusCode = eSIR_MAC_CHALLENGE_FAILURE_STATUS;            // Log error            PELOGE(limLog(pMac, LOGE,                   FL("received Authentication frame with wep bit set on "                   "role=%d "MAC_ADDRESS_STR),                   psessionEntry->limSystemRole, MAC_ADDR_ARRAY(pHdr->sa) );)            limSendAuthMgmtFrame(pMac, &authFrame,                                 pHdr->sa,                                 LIM_NO_WEP_IN_FC,psessionEntry);            return;        }        if (frameLen < LIM_ENCR_AUTH_BODY_LEN)        {            // Log error            limLog(pMac, LOGE,                   FL("Not enough size [%d] to decrypt received Auth frame"),                   frameLen);            limPrintMacAddr(pMac, pHdr->sa, LOGE);            return;        }        if(psessionEntry->limSystemRole == eLIM_AP_ROLE)        {            val = psessionEntry->privacy;        }        else        // Accept Authentication frame only if Privacy is implemented        if (wlan_cfgGetInt(pMac, WNI_CFG_PRIVACY_ENABLED,                      &val) != eSIR_SUCCESS)        {            /**             * Could not get Privacy option             * from CFG. Log error.             */            limLog(pMac, LOGP, FL("could not retrieve Privacy option"));        }        cfgPrivacyOptImp = (tANI_U8)val;        if (cfgPrivacyOptImp)        {            /**             * Privacy option is implemented.             * Check if the received frame is Authentication             * frame3 and there is a context for requesting STA.             * If not, reject with unspecified failure status code             */            pAuthNode = limSearchPreAuthList(pMac, pHdr->sa);            if (pAuthNode == NULL)            {                // Log error                PELOGE(limLog(pMac, LOGE,                       FL("received Authentication frame from peer that has "                       "no preauth context with WEP bit set "MAC_ADDRESS_STR),                       MAC_ADDR_ARRAY(pHdr->sa));)                /**                 * No 'pre-auth' context exists for this STA that sent                 * an Authentication frame with FC bit set.                 * Send Auth frame4 with 'out of sequence' status code.                 */                authFrame.authAlgoNumber = eSIR_SHARED_KEY;                authFrame.authTransactionSeqNumber =                SIR_MAC_AUTH_FRAME_4;                authFrame.authStatusCode =                eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                limSendAuthMgmtFrame(pMac, &authFrame,                                     pHdr->sa,                                     LIM_NO_WEP_IN_FC,psessionEntry);                return;            }            else            {                /// Change the auth-response timeout                limDeactivateAndChangePerStaIdTimer(pMac,                                                    eLIM_AUTH_RSP_TIMER,                                                    pAuthNode->authNodeIdx);                /// 'Pre-auth' status exists for STA                if ((pAuthNode->mlmState !=                     eLIM_MLM_WT_AUTH_FRAME3_STATE) &&                    (pAuthNode->mlmState !=                     eLIM_MLM_AUTH_RSP_TIMEOUT_STATE))                {                    // Log error                    PELOGE(limLog(pMac, LOGE,                           FL("received Authentication frame from peer that is "                           "in state %d "MAC_ADDRESS_STR),                            pAuthNode->mlmState, MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * Should not have received Authentication frame                     * with WEP bit set in FC in other states.                     * Reject by sending Authenticaton frame with                     * out of sequence Auth frame status code.                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }            }            /**             * Check if there exists a key mappping key             * for the STA that sent Authentication frame             */            pKeyMapEntry = limLookUpKeyMappings(pHdr->sa);            if (pKeyMapEntry)            {                if (!pKeyMapEntry->wepOn)                {                    // Log error                    PELOGE(limLog(pMac, LOGE,                           FL("received Auth frame3 from peer that has NULL "                           "key map entry "                           MAC_ADDRESS_STR),MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * Key Mapping entry has null key.                     * Send Authentication frame                     * with challenge failure status code                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                } // if (!pKeyMapEntry->wepOn)                else                {                    decryptResult = limDecryptAuthFrame(pMac, pKeyMapEntry->key,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH));                    if (decryptResult == LIM_DECRYPT_ICV_FAIL)                    {                        /// ICV failure                        PELOGW(limLog(pMac, LOGW, FL("=====> decryptResult == "                        "LIM_DECRYPT_ICV_FAIL ..."));)                        // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer "                               "that failed decryption, Addr "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                        limDeletePreAuthNode(pMac,                                             pHdr->sa);                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;                        authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                        authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }                    if ( ( sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                         &rxAuthFrame)!=eSIR_SUCCESS ) ||                         ( !isAuthValid(pMac, &rxAuthFrame,psessionEntry) ) )                    {                        PELOGE(limLog(pMac, LOGE,                               FL("failed to convert Auth Frame to structure "                               "or Auth is not valid "));)                        return;                    }                } // end if (pKeyMapEntry->key == NULL)            } // if keyMappings has entry            else            {                val = SIR_MAC_KEY_LENGTH;                if(psessionEntry->limSystemRole == eLIM_AP_ROLE)                {                    tpSirKeys pKey;                    pKey =  &psessionEntry->WEPKeyMaterial[keyId].key[0];                    vos_mem_copy(defaultKey, pKey->key, pKey->keyLength);                    val = pKey->keyLength;                }                else                if (wlan_cfgGetStr(pMac, (tANI_U16) (WNI_CFG_WEP_DEFAULT_KEY_1 + keyId),                              defaultKey, &val) != eSIR_SUCCESS)                {                    /// Could not get Default key from CFG.                    //Log error.                    limLog(pMac, LOGP,                           FL("could not retrieve Default key"));                    /**                     * Send Authentication frame                     * with challenge failure status code                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }                    key_length=val;                    decryptResult = limDecryptAuthFrame(pMac, defaultKey,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH));                    if (decryptResult == LIM_DECRYPT_ICV_FAIL)                    {                        PELOGW(limLog(pMac, LOGW, FL("=====> decryptResult == "                        "LIM_DECRYPT_ICV_FAIL ..."));)                        // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer that "                               "failed decryption: "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                        /// ICV failure                        limDeletePreAuthNode(pMac,                                             pHdr->sa);                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;                        authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                        authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }                    if ( ( sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                           &rxAuthFrame)!=eSIR_SUCCESS ) ||                        ( !isAuthValid(pMac, &rxAuthFrame, psessionEntry) ) )                    {                        limLog(pMac, LOGE,                               FL("failed to convert Auth Frame to structure "                               "or Auth is not valid "));                        return;                    }            } // End of check for Key Mapping/Default key presence        }        else        {            // Log error            PELOGE(limLog(pMac, LOGE,                   FL("received Authentication frame3 from peer that while "                   "privacy option is turned OFF "                   MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)            /**             * Privacy option is not implemented.             * So reject Authentication frame received with             * WEP bit set by sending Authentication frame             * with 'challenge failure' status code. This is             * another strange thing in the spec. Status code             * should have been 'unsupported algorithm' status code.             */            authFrame.authAlgoNumber = eSIR_SHARED_KEY;            authFrame.authTransactionSeqNumber =            SIR_MAC_AUTH_FRAME_4;            authFrame.authStatusCode =            eSIR_MAC_CHALLENGE_FAILURE_STATUS;            limSendAuthMgmtFrame(pMac, &authFrame,                                 pHdr->sa,                                 LIM_NO_WEP_IN_FC,psessionEntry);            return;        } // else if (wlan_cfgGetInt(CFG_PRIVACY_OPTION_IMPLEMENTED))    } // if (fc.wep)    else    {        if ( ( sirConvertAuthFrame2Struct(pMac, pBody,            frameLen, &rxAuthFrame)!=eSIR_SUCCESS ) ||            ( !isAuthValid(pMac, &rxAuthFrame,psessionEntry) ) )        {            PELOGE(limLog(pMac, LOGE,                   FL("failed to convert Auth Frame to structure or Auth is "                   "not valid "));)            return;        }    }
pHdr->fc.wep
pHdr->fc
pHdr
pHdr
fc
wep
{        /**         * WEP bit is set in FC of MAC header.         */        // If TKIP counter measures enabled issue Deauth frame to station        if ((psessionEntry->bTkipCntrMeasActive) && (psessionEntry->limSystemRole == eLIM_AP_ROLE))        {            PELOGE( limLog(pMac, LOGE,               FL("Tkip counter measures Enabled, sending Deauth frame to")); )            limPrintMacAddr(pMac, pHdr->sa, LOGE);            limSendDeauthMgmtFrame( pMac, eSIR_MAC_MIC_FAILURE_REASON,                                    pHdr->sa, psessionEntry, FALSE );            return;        }        // Extract key ID from IV (most 2 bits of 4th byte of IV)        keyId = (*(pBody + 3)) >> 6;        /**         * On STA in infrastructure BSS, Authentication frames received         * with WEP bit set in the FC must be rejected with challenge         * failure status code (wierd thing in the spec - this should have         * been rejected with unspecified failure or unexpected assertion         * of wep bit (this status code does not exist though) or         * Out-of-sequence-Authentication-Frame status code.         */        if (psessionEntry->limSystemRole == eLIM_STA_ROLE || psessionEntry->limSystemRole == eLIM_BT_AMP_STA_ROLE)        {            authFrame.authAlgoNumber = eSIR_SHARED_KEY;            authFrame.authTransactionSeqNumber = SIR_MAC_AUTH_FRAME_4;            authFrame.authStatusCode = eSIR_MAC_CHALLENGE_FAILURE_STATUS;            // Log error            PELOGE(limLog(pMac, LOGE,                   FL("received Authentication frame with wep bit set on "                   "role=%d "MAC_ADDRESS_STR),                   psessionEntry->limSystemRole, MAC_ADDR_ARRAY(pHdr->sa) );)            limSendAuthMgmtFrame(pMac, &authFrame,                                 pHdr->sa,                                 LIM_NO_WEP_IN_FC,psessionEntry);            return;        }        if (frameLen < LIM_ENCR_AUTH_BODY_LEN)        {            // Log error            limLog(pMac, LOGE,                   FL("Not enough size [%d] to decrypt received Auth frame"),                   frameLen);            limPrintMacAddr(pMac, pHdr->sa, LOGE);            return;        }        if(psessionEntry->limSystemRole == eLIM_AP_ROLE)        {            val = psessionEntry->privacy;        }        else        // Accept Authentication frame only if Privacy is implemented        if (wlan_cfgGetInt(pMac, WNI_CFG_PRIVACY_ENABLED,                      &val) != eSIR_SUCCESS)        {            /**             * Could not get Privacy option             * from CFG. Log error.             */            limLog(pMac, LOGP, FL("could not retrieve Privacy option"));        }        cfgPrivacyOptImp = (tANI_U8)val;        if (cfgPrivacyOptImp)        {            /**             * Privacy option is implemented.             * Check if the received frame is Authentication             * frame3 and there is a context for requesting STA.             * If not, reject with unspecified failure status code             */            pAuthNode = limSearchPreAuthList(pMac, pHdr->sa);            if (pAuthNode == NULL)            {                // Log error                PELOGE(limLog(pMac, LOGE,                       FL("received Authentication frame from peer that has "                       "no preauth context with WEP bit set "MAC_ADDRESS_STR),                       MAC_ADDR_ARRAY(pHdr->sa));)                /**                 * No 'pre-auth' context exists for this STA that sent                 * an Authentication frame with FC bit set.                 * Send Auth frame4 with 'out of sequence' status code.                 */                authFrame.authAlgoNumber = eSIR_SHARED_KEY;                authFrame.authTransactionSeqNumber =                SIR_MAC_AUTH_FRAME_4;                authFrame.authStatusCode =                eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                limSendAuthMgmtFrame(pMac, &authFrame,                                     pHdr->sa,                                     LIM_NO_WEP_IN_FC,psessionEntry);                return;            }            else            {                /// Change the auth-response timeout                limDeactivateAndChangePerStaIdTimer(pMac,                                                    eLIM_AUTH_RSP_TIMER,                                                    pAuthNode->authNodeIdx);                /// 'Pre-auth' status exists for STA                if ((pAuthNode->mlmState !=                     eLIM_MLM_WT_AUTH_FRAME3_STATE) &&                    (pAuthNode->mlmState !=                     eLIM_MLM_AUTH_RSP_TIMEOUT_STATE))                {                    // Log error                    PELOGE(limLog(pMac, LOGE,                           FL("received Authentication frame from peer that is "                           "in state %d "MAC_ADDRESS_STR),                            pAuthNode->mlmState, MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * Should not have received Authentication frame                     * with WEP bit set in FC in other states.                     * Reject by sending Authenticaton frame with                     * out of sequence Auth frame status code.                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }            }            /**             * Check if there exists a key mappping key             * for the STA that sent Authentication frame             */            pKeyMapEntry = limLookUpKeyMappings(pHdr->sa);            if (pKeyMapEntry)            {                if (!pKeyMapEntry->wepOn)                {                    // Log error                    PELOGE(limLog(pMac, LOGE,                           FL("received Auth frame3 from peer that has NULL "                           "key map entry "                           MAC_ADDRESS_STR),MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * Key Mapping entry has null key.                     * Send Authentication frame                     * with challenge failure status code                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                } // if (!pKeyMapEntry->wepOn)                else                {                    decryptResult = limDecryptAuthFrame(pMac, pKeyMapEntry->key,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH));                    if (decryptResult == LIM_DECRYPT_ICV_FAIL)                    {                        /// ICV failure                        PELOGW(limLog(pMac, LOGW, FL("=====> decryptResult == "                        "LIM_DECRYPT_ICV_FAIL ..."));)                        // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer "                               "that failed decryption, Addr "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                        limDeletePreAuthNode(pMac,                                             pHdr->sa);                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;                        authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                        authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }                    if ( ( sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                         &rxAuthFrame)!=eSIR_SUCCESS ) ||                         ( !isAuthValid(pMac, &rxAuthFrame,psessionEntry) ) )                    {                        PELOGE(limLog(pMac, LOGE,                               FL("failed to convert Auth Frame to structure "                               "or Auth is not valid "));)                        return;                    }                } // end if (pKeyMapEntry->key == NULL)            } // if keyMappings has entry            else            {                val = SIR_MAC_KEY_LENGTH;                if(psessionEntry->limSystemRole == eLIM_AP_ROLE)                {                    tpSirKeys pKey;                    pKey =  &psessionEntry->WEPKeyMaterial[keyId].key[0];                    vos_mem_copy(defaultKey, pKey->key, pKey->keyLength);                    val = pKey->keyLength;                }                else                if (wlan_cfgGetStr(pMac, (tANI_U16) (WNI_CFG_WEP_DEFAULT_KEY_1 + keyId),                              defaultKey, &val) != eSIR_SUCCESS)                {                    /// Could not get Default key from CFG.                    //Log error.                    limLog(pMac, LOGP,                           FL("could not retrieve Default key"));                    /**                     * Send Authentication frame                     * with challenge failure status code                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }                    key_length=val;                    decryptResult = limDecryptAuthFrame(pMac, defaultKey,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH));                    if (decryptResult == LIM_DECRYPT_ICV_FAIL)                    {                        PELOGW(limLog(pMac, LOGW, FL("=====> decryptResult == "                        "LIM_DECRYPT_ICV_FAIL ..."));)                        // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer that "                               "failed decryption: "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                        /// ICV failure                        limDeletePreAuthNode(pMac,                                             pHdr->sa);                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;                        authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                        authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }                    if ( ( sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                           &rxAuthFrame)!=eSIR_SUCCESS ) ||                        ( !isAuthValid(pMac, &rxAuthFrame, psessionEntry) ) )                    {                        limLog(pMac, LOGE,                               FL("failed to convert Auth Frame to structure "                               "or Auth is not valid "));                        return;                    }            } // End of check for Key Mapping/Default key presence        }        else        {            // Log error            PELOGE(limLog(pMac, LOGE,                   FL("received Authentication frame3 from peer that while "                   "privacy option is turned OFF "                   MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)            /**             * Privacy option is not implemented.             * So reject Authentication frame received with             * WEP bit set by sending Authentication frame             * with 'challenge failure' status code. This is             * another strange thing in the spec. Status code             * should have been 'unsupported algorithm' status code.             */            authFrame.authAlgoNumber = eSIR_SHARED_KEY;            authFrame.authTransactionSeqNumber =            SIR_MAC_AUTH_FRAME_4;            authFrame.authStatusCode =            eSIR_MAC_CHALLENGE_FAILURE_STATUS;            limSendAuthMgmtFrame(pMac, &authFrame,                                 pHdr->sa,                                 LIM_NO_WEP_IN_FC,psessionEntry);            return;        } // else if (wlan_cfgGetInt(CFG_PRIVACY_OPTION_IMPLEMENTED))    }
if ((psessionEntry->bTkipCntrMeasActive) && (psessionEntry->limSystemRole == eLIM_AP_ROLE))        {            PELOGE( limLog(pMac, LOGE,               FL("Tkip counter measures Enabled, sending Deauth frame to")); )            limPrintMacAddr(pMac, pHdr->sa, LOGE);            limSendDeauthMgmtFrame( pMac, eSIR_MAC_MIC_FAILURE_REASON,                                    pHdr->sa, psessionEntry, FALSE );            return;        }
(psessionEntry->bTkipCntrMeasActive) && (psessionEntry->limSystemRole == eLIM_AP_ROLE)
(psessionEntry->bTkipCntrMeasActive)
psessionEntry->bTkipCntrMeasActive
psessionEntry
psessionEntry
bTkipCntrMeasActive
(psessionEntry->limSystemRole == eLIM_AP_ROLE)
psessionEntry->limSystemRole == eLIM_AP_ROLE
psessionEntry->limSystemRole
psessionEntry
psessionEntry
limSystemRole
eLIM_AP_ROLE
eLIM_AP_ROLE
{            PELOGE( limLog(pMac, LOGE,               FL("Tkip counter measures Enabled, sending Deauth frame to")); )            limPrintMacAddr(pMac, pHdr->sa, LOGE);            limSendDeauthMgmtFrame( pMac, eSIR_MAC_MIC_FAILURE_REASON,                                    pHdr->sa, psessionEntry, FALSE );            return;        }
PELOGE( limLog(pMac, LOGE,               FL("Tkip counter measures Enabled, sending Deauth frame to"));
)            limPrintMacAddr(pMac, pHdr->sa, LOGE);
limSendDeauthMgmtFrame( pMac, eSIR_MAC_MIC_FAILURE_REASON,                                    pHdr->sa, psessionEntry, FALSE );
limSendDeauthMgmtFrame( pMac, eSIR_MAC_MIC_FAILURE_REASON,                                    pHdr->sa, psessionEntry, FALSE )
limSendDeauthMgmtFrame
limSendDeauthMgmtFrame
pMac
pMac
eSIR_MAC_MIC_FAILURE_REASON
eSIR_MAC_MIC_FAILURE_REASON
pHdr->sa
pHdr
pHdr
sa
psessionEntry
psessionEntry
FALSE
FALSE
return;
keyId = (*(pBody + 3)) >> 6;
keyId = (*(pBody + 3)) >> 6
keyId
keyId
(*(pBody + 3)) >> 6
(*(pBody + 3))
*(pBody + 3)
(pBody + 3)
pBody + 3
pBody
pBody
3
6
if (psessionEntry->limSystemRole == eLIM_STA_ROLE || psessionEntry->limSystemRole == eLIM_BT_AMP_STA_ROLE)        {            authFrame.authAlgoNumber = eSIR_SHARED_KEY;            authFrame.authTransactionSeqNumber = SIR_MAC_AUTH_FRAME_4;            authFrame.authStatusCode = eSIR_MAC_CHALLENGE_FAILURE_STATUS;            // Log error            PELOGE(limLog(pMac, LOGE,                   FL("received Authentication frame with wep bit set on "                   "role=%d "MAC_ADDRESS_STR),                   psessionEntry->limSystemRole, MAC_ADDR_ARRAY(pHdr->sa) );)            limSendAuthMgmtFrame(pMac, &authFrame,                                 pHdr->sa,                                 LIM_NO_WEP_IN_FC,psessionEntry);            return;        }
psessionEntry->limSystemRole == eLIM_STA_ROLE || psessionEntry->limSystemRole == eLIM_BT_AMP_STA_ROLE
psessionEntry->limSystemRole == eLIM_STA_ROLE
psessionEntry->limSystemRole
psessionEntry
psessionEntry
limSystemRole
eLIM_STA_ROLE
eLIM_STA_ROLE
psessionEntry->limSystemRole == eLIM_BT_AMP_STA_ROLE
psessionEntry->limSystemRole
psessionEntry
psessionEntry
limSystemRole
eLIM_BT_AMP_STA_ROLE
eLIM_BT_AMP_STA_ROLE
{            authFrame.authAlgoNumber = eSIR_SHARED_KEY;            authFrame.authTransactionSeqNumber = SIR_MAC_AUTH_FRAME_4;            authFrame.authStatusCode = eSIR_MAC_CHALLENGE_FAILURE_STATUS;            // Log error            PELOGE(limLog(pMac, LOGE,                   FL("received Authentication frame with wep bit set on "                   "role=%d "MAC_ADDRESS_STR),                   psessionEntry->limSystemRole, MAC_ADDR_ARRAY(pHdr->sa) );)            limSendAuthMgmtFrame(pMac, &authFrame,                                 pHdr->sa,                                 LIM_NO_WEP_IN_FC,psessionEntry);            return;        }
authFrame.authAlgoNumber = eSIR_SHARED_KEY;
authFrame.authAlgoNumber = eSIR_SHARED_KEY
authFrame.authAlgoNumber
authFrame
authFrame
authAlgoNumber
eSIR_SHARED_KEY
eSIR_SHARED_KEY
authFrame.authTransactionSeqNumber = SIR_MAC_AUTH_FRAME_4;
authFrame.authTransactionSeqNumber = SIR_MAC_AUTH_FRAME_4
authFrame.authTransactionSeqNumber
authFrame
authFrame
authTransactionSeqNumber
SIR_MAC_AUTH_FRAME_4
SIR_MAC_AUTH_FRAME_4
authFrame.authStatusCode = eSIR_MAC_CHALLENGE_FAILURE_STATUS;
authFrame.authStatusCode = eSIR_MAC_CHALLENGE_FAILURE_STATUS
authFrame.authStatusCode
authFrame
authFrame
authStatusCode
eSIR_MAC_CHALLENGE_FAILURE_STATUS
eSIR_MAC_CHALLENGE_FAILURE_STATUS
PELOGE(limLog(pMac, LOGE,                   FL("received Authentication frame with wep bit set on "                   "role=%d "MAC_ADDRESS_STR),                   psessionEntry->limSystemRole, MAC_ADDR_ARRAY(pHdr->sa) );
)            limSendAuthMgmtFrame(pMac, &authFrame,                                 pHdr->sa,                                 LIM_NO_WEP_IN_FC,psessionEntry);
return;
if (frameLen < LIM_ENCR_AUTH_BODY_LEN)        {            // Log error            limLog(pMac, LOGE,                   FL("Not enough size [%d] to decrypt received Auth frame"),                   frameLen);            limPrintMacAddr(pMac, pHdr->sa, LOGE);            return;        }
frameLen < LIM_ENCR_AUTH_BODY_LEN
frameLen
frameLen
LIM_ENCR_AUTH_BODY_LEN
LIM_ENCR_AUTH_BODY_LEN
{            // Log error            limLog(pMac, LOGE,                   FL("Not enough size [%d] to decrypt received Auth frame"),                   frameLen);            limPrintMacAddr(pMac, pHdr->sa, LOGE);            return;        }
limLog(pMac, LOGE,                   FL("Not enough size [%d] to decrypt received Auth frame"),                   frameLen);
limLog(pMac, LOGE,                   FL("Not enough size [%d] to decrypt received Auth frame"),                   frameLen)
limLog
limLog
pMac
pMac
LOGE
LOGE
FL("Not enough size [%d] to decrypt received Auth frame")
FL
FL
"Not enough size [%d] to decrypt received Auth frame"
frameLen
frameLen
limPrintMacAddr(pMac, pHdr->sa, LOGE);
limPrintMacAddr(pMac, pHdr->sa, LOGE)
limPrintMacAddr
limPrintMacAddr
pMac
pMac
pHdr->sa
pHdr
pHdr
sa
LOGE
LOGE
return;
if(psessionEntry->limSystemRole == eLIM_AP_ROLE)        {            val = psessionEntry->privacy;        }        else        // Accept Authentication frame only if Privacy is implemented        if (wlan_cfgGetInt(pMac, WNI_CFG_PRIVACY_ENABLED,                      &val) != eSIR_SUCCESS)        {            /**             * Could not get Privacy option             * from CFG. Log error.             */            limLog(pMac, LOGP, FL("could not retrieve Privacy option"));        }
psessionEntry->limSystemRole == eLIM_AP_ROLE
psessionEntry->limSystemRole
psessionEntry
psessionEntry
limSystemRole
eLIM_AP_ROLE
eLIM_AP_ROLE
{            val = psessionEntry->privacy;        }
val = psessionEntry->privacy;
val = psessionEntry->privacy
val
val
psessionEntry->privacy
psessionEntry
psessionEntry
privacy
if (wlan_cfgGetInt(pMac, WNI_CFG_PRIVACY_ENABLED,                      &val) != eSIR_SUCCESS)        {            /**             * Could not get Privacy option             * from CFG. Log error.             */            limLog(pMac, LOGP, FL("could not retrieve Privacy option"));        }
wlan_cfgGetInt(pMac, WNI_CFG_PRIVACY_ENABLED,                      &val) != eSIR_SUCCESS
wlan_cfgGetInt(pMac, WNI_CFG_PRIVACY_ENABLED,                      &val)
wlan_cfgGetInt
wlan_cfgGetInt
pMac
pMac
WNI_CFG_PRIVACY_ENABLED
WNI_CFG_PRIVACY_ENABLED
&val
val
val
eSIR_SUCCESS
eSIR_SUCCESS
{            /**             * Could not get Privacy option             * from CFG. Log error.             */            limLog(pMac, LOGP, FL("could not retrieve Privacy option"));        }
limLog(pMac, LOGP, FL("could not retrieve Privacy option"));
limLog(pMac, LOGP, FL("could not retrieve Privacy option"))
limLog
limLog
pMac
pMac
LOGP
LOGP
FL("could not retrieve Privacy option")
FL
FL
"could not retrieve Privacy option"
cfgPrivacyOptImp = (tANI_U8)val;
cfgPrivacyOptImp = (tANI_U8)val
cfgPrivacyOptImp
cfgPrivacyOptImp
(tANI_U8)val
tANI_U8
tANI_U8
tANI_U8

val
val
if (cfgPrivacyOptImp)        {            /**             * Privacy option is implemented.             * Check if the received frame is Authentication             * frame3 and there is a context for requesting STA.             * If not, reject with unspecified failure status code             */            pAuthNode = limSearchPreAuthList(pMac, pHdr->sa);            if (pAuthNode == NULL)            {                // Log error                PELOGE(limLog(pMac, LOGE,                       FL("received Authentication frame from peer that has "                       "no preauth context with WEP bit set "MAC_ADDRESS_STR),                       MAC_ADDR_ARRAY(pHdr->sa));)                /**                 * No 'pre-auth' context exists for this STA that sent                 * an Authentication frame with FC bit set.                 * Send Auth frame4 with 'out of sequence' status code.                 */                authFrame.authAlgoNumber = eSIR_SHARED_KEY;                authFrame.authTransactionSeqNumber =                SIR_MAC_AUTH_FRAME_4;                authFrame.authStatusCode =                eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                limSendAuthMgmtFrame(pMac, &authFrame,                                     pHdr->sa,                                     LIM_NO_WEP_IN_FC,psessionEntry);                return;            }            else            {                /// Change the auth-response timeout                limDeactivateAndChangePerStaIdTimer(pMac,                                                    eLIM_AUTH_RSP_TIMER,                                                    pAuthNode->authNodeIdx);                /// 'Pre-auth' status exists for STA                if ((pAuthNode->mlmState !=                     eLIM_MLM_WT_AUTH_FRAME3_STATE) &&                    (pAuthNode->mlmState !=                     eLIM_MLM_AUTH_RSP_TIMEOUT_STATE))                {                    // Log error                    PELOGE(limLog(pMac, LOGE,                           FL("received Authentication frame from peer that is "                           "in state %d "MAC_ADDRESS_STR),                            pAuthNode->mlmState, MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * Should not have received Authentication frame                     * with WEP bit set in FC in other states.                     * Reject by sending Authenticaton frame with                     * out of sequence Auth frame status code.                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }            }            /**             * Check if there exists a key mappping key             * for the STA that sent Authentication frame             */            pKeyMapEntry = limLookUpKeyMappings(pHdr->sa);            if (pKeyMapEntry)            {                if (!pKeyMapEntry->wepOn)                {                    // Log error                    PELOGE(limLog(pMac, LOGE,                           FL("received Auth frame3 from peer that has NULL "                           "key map entry "                           MAC_ADDRESS_STR),MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * Key Mapping entry has null key.                     * Send Authentication frame                     * with challenge failure status code                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                } // if (!pKeyMapEntry->wepOn)                else                {                    decryptResult = limDecryptAuthFrame(pMac, pKeyMapEntry->key,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH));                    if (decryptResult == LIM_DECRYPT_ICV_FAIL)                    {                        /// ICV failure                        PELOGW(limLog(pMac, LOGW, FL("=====> decryptResult == "                        "LIM_DECRYPT_ICV_FAIL ..."));)                        // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer "                               "that failed decryption, Addr "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                        limDeletePreAuthNode(pMac,                                             pHdr->sa);                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;                        authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                        authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }                    if ( ( sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                         &rxAuthFrame)!=eSIR_SUCCESS ) ||                         ( !isAuthValid(pMac, &rxAuthFrame,psessionEntry) ) )                    {                        PELOGE(limLog(pMac, LOGE,                               FL("failed to convert Auth Frame to structure "                               "or Auth is not valid "));)                        return;                    }                } // end if (pKeyMapEntry->key == NULL)            } // if keyMappings has entry            else            {                val = SIR_MAC_KEY_LENGTH;                if(psessionEntry->limSystemRole == eLIM_AP_ROLE)                {                    tpSirKeys pKey;                    pKey =  &psessionEntry->WEPKeyMaterial[keyId].key[0];                    vos_mem_copy(defaultKey, pKey->key, pKey->keyLength);                    val = pKey->keyLength;                }                else                if (wlan_cfgGetStr(pMac, (tANI_U16) (WNI_CFG_WEP_DEFAULT_KEY_1 + keyId),                              defaultKey, &val) != eSIR_SUCCESS)                {                    /// Could not get Default key from CFG.                    //Log error.                    limLog(pMac, LOGP,                           FL("could not retrieve Default key"));                    /**                     * Send Authentication frame                     * with challenge failure status code                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }                    key_length=val;                    decryptResult = limDecryptAuthFrame(pMac, defaultKey,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH));                    if (decryptResult == LIM_DECRYPT_ICV_FAIL)                    {                        PELOGW(limLog(pMac, LOGW, FL("=====> decryptResult == "                        "LIM_DECRYPT_ICV_FAIL ..."));)                        // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer that "                               "failed decryption: "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                        /// ICV failure                        limDeletePreAuthNode(pMac,                                             pHdr->sa);                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;                        authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                        authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }                    if ( ( sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                           &rxAuthFrame)!=eSIR_SUCCESS ) ||                        ( !isAuthValid(pMac, &rxAuthFrame, psessionEntry) ) )                    {                        limLog(pMac, LOGE,                               FL("failed to convert Auth Frame to structure "                               "or Auth is not valid "));                        return;                    }            } // End of check for Key Mapping/Default key presence        }        else        {            // Log error            PELOGE(limLog(pMac, LOGE,                   FL("received Authentication frame3 from peer that while "                   "privacy option is turned OFF "                   MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)            /**             * Privacy option is not implemented.             * So reject Authentication frame received with             * WEP bit set by sending Authentication frame             * with 'challenge failure' status code. This is             * another strange thing in the spec. Status code             * should have been 'unsupported algorithm' status code.             */            authFrame.authAlgoNumber = eSIR_SHARED_KEY;            authFrame.authTransactionSeqNumber =            SIR_MAC_AUTH_FRAME_4;            authFrame.authStatusCode =            eSIR_MAC_CHALLENGE_FAILURE_STATUS;            limSendAuthMgmtFrame(pMac, &authFrame,                                 pHdr->sa,                                 LIM_NO_WEP_IN_FC,psessionEntry);            return;        }
cfgPrivacyOptImp
cfgPrivacyOptImp
{            /**             * Privacy option is implemented.             * Check if the received frame is Authentication             * frame3 and there is a context for requesting STA.             * If not, reject with unspecified failure status code             */            pAuthNode = limSearchPreAuthList(pMac, pHdr->sa);            if (pAuthNode == NULL)            {                // Log error                PELOGE(limLog(pMac, LOGE,                       FL("received Authentication frame from peer that has "                       "no preauth context with WEP bit set "MAC_ADDRESS_STR),                       MAC_ADDR_ARRAY(pHdr->sa));)                /**                 * No 'pre-auth' context exists for this STA that sent                 * an Authentication frame with FC bit set.                 * Send Auth frame4 with 'out of sequence' status code.                 */                authFrame.authAlgoNumber = eSIR_SHARED_KEY;                authFrame.authTransactionSeqNumber =                SIR_MAC_AUTH_FRAME_4;                authFrame.authStatusCode =                eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                limSendAuthMgmtFrame(pMac, &authFrame,                                     pHdr->sa,                                     LIM_NO_WEP_IN_FC,psessionEntry);                return;            }            else            {                /// Change the auth-response timeout                limDeactivateAndChangePerStaIdTimer(pMac,                                                    eLIM_AUTH_RSP_TIMER,                                                    pAuthNode->authNodeIdx);                /// 'Pre-auth' status exists for STA                if ((pAuthNode->mlmState !=                     eLIM_MLM_WT_AUTH_FRAME3_STATE) &&                    (pAuthNode->mlmState !=                     eLIM_MLM_AUTH_RSP_TIMEOUT_STATE))                {                    // Log error                    PELOGE(limLog(pMac, LOGE,                           FL("received Authentication frame from peer that is "                           "in state %d "MAC_ADDRESS_STR),                            pAuthNode->mlmState, MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * Should not have received Authentication frame                     * with WEP bit set in FC in other states.                     * Reject by sending Authenticaton frame with                     * out of sequence Auth frame status code.                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }            }            /**             * Check if there exists a key mappping key             * for the STA that sent Authentication frame             */            pKeyMapEntry = limLookUpKeyMappings(pHdr->sa);            if (pKeyMapEntry)            {                if (!pKeyMapEntry->wepOn)                {                    // Log error                    PELOGE(limLog(pMac, LOGE,                           FL("received Auth frame3 from peer that has NULL "                           "key map entry "                           MAC_ADDRESS_STR),MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * Key Mapping entry has null key.                     * Send Authentication frame                     * with challenge failure status code                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                } // if (!pKeyMapEntry->wepOn)                else                {                    decryptResult = limDecryptAuthFrame(pMac, pKeyMapEntry->key,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH));                    if (decryptResult == LIM_DECRYPT_ICV_FAIL)                    {                        /// ICV failure                        PELOGW(limLog(pMac, LOGW, FL("=====> decryptResult == "                        "LIM_DECRYPT_ICV_FAIL ..."));)                        // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer "                               "that failed decryption, Addr "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                        limDeletePreAuthNode(pMac,                                             pHdr->sa);                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;                        authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                        authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }                    if ( ( sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                         &rxAuthFrame)!=eSIR_SUCCESS ) ||                         ( !isAuthValid(pMac, &rxAuthFrame,psessionEntry) ) )                    {                        PELOGE(limLog(pMac, LOGE,                               FL("failed to convert Auth Frame to structure "                               "or Auth is not valid "));)                        return;                    }                } // end if (pKeyMapEntry->key == NULL)            } // if keyMappings has entry            else            {                val = SIR_MAC_KEY_LENGTH;                if(psessionEntry->limSystemRole == eLIM_AP_ROLE)                {                    tpSirKeys pKey;                    pKey =  &psessionEntry->WEPKeyMaterial[keyId].key[0];                    vos_mem_copy(defaultKey, pKey->key, pKey->keyLength);                    val = pKey->keyLength;                }                else                if (wlan_cfgGetStr(pMac, (tANI_U16) (WNI_CFG_WEP_DEFAULT_KEY_1 + keyId),                              defaultKey, &val) != eSIR_SUCCESS)                {                    /// Could not get Default key from CFG.                    //Log error.                    limLog(pMac, LOGP,                           FL("could not retrieve Default key"));                    /**                     * Send Authentication frame                     * with challenge failure status code                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }                    key_length=val;                    decryptResult = limDecryptAuthFrame(pMac, defaultKey,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH));                    if (decryptResult == LIM_DECRYPT_ICV_FAIL)                    {                        PELOGW(limLog(pMac, LOGW, FL("=====> decryptResult == "                        "LIM_DECRYPT_ICV_FAIL ..."));)                        // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer that "                               "failed decryption: "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                        /// ICV failure                        limDeletePreAuthNode(pMac,                                             pHdr->sa);                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;                        authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                        authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }                    if ( ( sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                           &rxAuthFrame)!=eSIR_SUCCESS ) ||                        ( !isAuthValid(pMac, &rxAuthFrame, psessionEntry) ) )                    {                        limLog(pMac, LOGE,                               FL("failed to convert Auth Frame to structure "                               "or Auth is not valid "));                        return;                    }            } // End of check for Key Mapping/Default key presence        }
pAuthNode = limSearchPreAuthList(pMac, pHdr->sa);
pAuthNode = limSearchPreAuthList(pMac, pHdr->sa)
pAuthNode
pAuthNode
limSearchPreAuthList(pMac, pHdr->sa)
limSearchPreAuthList
limSearchPreAuthList
pMac
pMac
pHdr->sa
pHdr
pHdr
sa
if (pAuthNode == NULL)            {                // Log error                PELOGE(limLog(pMac, LOGE,                       FL("received Authentication frame from peer that has "                       "no preauth context with WEP bit set "MAC_ADDRESS_STR),                       MAC_ADDR_ARRAY(pHdr->sa));)                /**                 * No 'pre-auth' context exists for this STA that sent                 * an Authentication frame with FC bit set.                 * Send Auth frame4 with 'out of sequence' status code.                 */                authFrame.authAlgoNumber = eSIR_SHARED_KEY;                authFrame.authTransactionSeqNumber =                SIR_MAC_AUTH_FRAME_4;                authFrame.authStatusCode =                eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                limSendAuthMgmtFrame(pMac, &authFrame,                                     pHdr->sa,                                     LIM_NO_WEP_IN_FC,psessionEntry);                return;            }            else            {                /// Change the auth-response timeout                limDeactivateAndChangePerStaIdTimer(pMac,                                                    eLIM_AUTH_RSP_TIMER,                                                    pAuthNode->authNodeIdx);                /// 'Pre-auth' status exists for STA                if ((pAuthNode->mlmState !=                     eLIM_MLM_WT_AUTH_FRAME3_STATE) &&                    (pAuthNode->mlmState !=                     eLIM_MLM_AUTH_RSP_TIMEOUT_STATE))                {                    // Log error                    PELOGE(limLog(pMac, LOGE,                           FL("received Authentication frame from peer that is "                           "in state %d "MAC_ADDRESS_STR),                            pAuthNode->mlmState, MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * Should not have received Authentication frame                     * with WEP bit set in FC in other states.                     * Reject by sending Authenticaton frame with                     * out of sequence Auth frame status code.                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }            }
pAuthNode == NULL
pAuthNode
pAuthNode
NULL
NULL
{                // Log error                PELOGE(limLog(pMac, LOGE,                       FL("received Authentication frame from peer that has "                       "no preauth context with WEP bit set "MAC_ADDRESS_STR),                       MAC_ADDR_ARRAY(pHdr->sa));)                /**                 * No 'pre-auth' context exists for this STA that sent                 * an Authentication frame with FC bit set.                 * Send Auth frame4 with 'out of sequence' status code.                 */                authFrame.authAlgoNumber = eSIR_SHARED_KEY;                authFrame.authTransactionSeqNumber =                SIR_MAC_AUTH_FRAME_4;                authFrame.authStatusCode =                eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                limSendAuthMgmtFrame(pMac, &authFrame,                                     pHdr->sa,                                     LIM_NO_WEP_IN_FC,psessionEntry);                return;            }
PELOGE(limLog(pMac, LOGE,                       FL("received Authentication frame from peer that has "                       "no preauth context with WEP bit set "MAC_ADDRESS_STR),                       MAC_ADDR_ARRAY(pHdr->sa));
)                /**                 * No 'pre-auth' context exists for this STA that sent                 * an Authentication frame with FC bit set.                 * Send Auth frame4 with 'out of sequence' status code.                 */                authFrame.authAlgoNumber = eSIR_SHARED_KEY;
authFrame.authTransactionSeqNumber =                SIR_MAC_AUTH_FRAME_4;
authFrame.authTransactionSeqNumber =                SIR_MAC_AUTH_FRAME_4
authFrame.authTransactionSeqNumber
authFrame
authFrame
authTransactionSeqNumber
SIR_MAC_AUTH_FRAME_4
SIR_MAC_AUTH_FRAME_4
authFrame.authStatusCode =                eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;
authFrame.authStatusCode =                eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS
authFrame.authStatusCode
authFrame
authFrame
authStatusCode
eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS
eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS
limSendAuthMgmtFrame(pMac, &authFrame,                                     pHdr->sa,                                     LIM_NO_WEP_IN_FC,psessionEntry);
limSendAuthMgmtFrame(pMac, &authFrame,                                     pHdr->sa,                                     LIM_NO_WEP_IN_FC,psessionEntry)
limSendAuthMgmtFrame
limSendAuthMgmtFrame
pMac
pMac
&authFrame
authFrame
authFrame
pHdr->sa
pHdr
pHdr
sa
LIM_NO_WEP_IN_FC
LIM_NO_WEP_IN_FC
psessionEntry
psessionEntry
return;
{                /// Change the auth-response timeout                limDeactivateAndChangePerStaIdTimer(pMac,                                                    eLIM_AUTH_RSP_TIMER,                                                    pAuthNode->authNodeIdx);                /// 'Pre-auth' status exists for STA                if ((pAuthNode->mlmState !=                     eLIM_MLM_WT_AUTH_FRAME3_STATE) &&                    (pAuthNode->mlmState !=                     eLIM_MLM_AUTH_RSP_TIMEOUT_STATE))                {                    // Log error                    PELOGE(limLog(pMac, LOGE,                           FL("received Authentication frame from peer that is "                           "in state %d "MAC_ADDRESS_STR),                            pAuthNode->mlmState, MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * Should not have received Authentication frame                     * with WEP bit set in FC in other states.                     * Reject by sending Authenticaton frame with                     * out of sequence Auth frame status code.                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }            }
limDeactivateAndChangePerStaIdTimer(pMac,                                                    eLIM_AUTH_RSP_TIMER,                                                    pAuthNode->authNodeIdx);
limDeactivateAndChangePerStaIdTimer(pMac,                                                    eLIM_AUTH_RSP_TIMER,                                                    pAuthNode->authNodeIdx)
limDeactivateAndChangePerStaIdTimer
limDeactivateAndChangePerStaIdTimer
pMac
pMac
eLIM_AUTH_RSP_TIMER
eLIM_AUTH_RSP_TIMER
pAuthNode->authNodeIdx
pAuthNode
pAuthNode
authNodeIdx
if ((pAuthNode->mlmState !=                     eLIM_MLM_WT_AUTH_FRAME3_STATE) &&                    (pAuthNode->mlmState !=                     eLIM_MLM_AUTH_RSP_TIMEOUT_STATE))                {                    // Log error                    PELOGE(limLog(pMac, LOGE,                           FL("received Authentication frame from peer that is "                           "in state %d "MAC_ADDRESS_STR),                            pAuthNode->mlmState, MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * Should not have received Authentication frame                     * with WEP bit set in FC in other states.                     * Reject by sending Authenticaton frame with                     * out of sequence Auth frame status code.                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }
(pAuthNode->mlmState !=                     eLIM_MLM_WT_AUTH_FRAME3_STATE) &&                    (pAuthNode->mlmState !=                     eLIM_MLM_AUTH_RSP_TIMEOUT_STATE)
(pAuthNode->mlmState !=                     eLIM_MLM_WT_AUTH_FRAME3_STATE)
pAuthNode->mlmState !=                     eLIM_MLM_WT_AUTH_FRAME3_STATE
pAuthNode->mlmState
pAuthNode
pAuthNode
mlmState
eLIM_MLM_WT_AUTH_FRAME3_STATE
eLIM_MLM_WT_AUTH_FRAME3_STATE
(pAuthNode->mlmState !=                     eLIM_MLM_AUTH_RSP_TIMEOUT_STATE)
pAuthNode->mlmState !=                     eLIM_MLM_AUTH_RSP_TIMEOUT_STATE
pAuthNode->mlmState
pAuthNode
pAuthNode
mlmState
eLIM_MLM_AUTH_RSP_TIMEOUT_STATE
eLIM_MLM_AUTH_RSP_TIMEOUT_STATE
{                    // Log error                    PELOGE(limLog(pMac, LOGE,                           FL("received Authentication frame from peer that is "                           "in state %d "MAC_ADDRESS_STR),                            pAuthNode->mlmState, MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * Should not have received Authentication frame                     * with WEP bit set in FC in other states.                     * Reject by sending Authenticaton frame with                     * out of sequence Auth frame status code.                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }
PELOGE(limLog(pMac, LOGE,                           FL("received Authentication frame from peer that is "                           "in state %d "MAC_ADDRESS_STR),                            pAuthNode->mlmState, MAC_ADDR_ARRAY(pHdr->sa));
)                    /**                     * Should not have received Authentication frame                     * with WEP bit set in FC in other states.                     * Reject by sending Authenticaton frame with                     * out of sequence Auth frame status code.                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;
authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;
authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4
authFrame.authTransactionSeqNumber
authFrame
authFrame
authTransactionSeqNumber
SIR_MAC_AUTH_FRAME_4
SIR_MAC_AUTH_FRAME_4
authFrame.authStatusCode =                    eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;
authFrame.authStatusCode =                    eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS
authFrame.authStatusCode
authFrame
authFrame
authStatusCode
eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS
eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS
limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);
limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry)
limSendAuthMgmtFrame
limSendAuthMgmtFrame
pMac
pMac
&authFrame
authFrame
authFrame
pHdr->sa
pHdr
pHdr
sa
LIM_NO_WEP_IN_FC
LIM_NO_WEP_IN_FC
psessionEntry
psessionEntry
return;
pKeyMapEntry = limLookUpKeyMappings(pHdr->sa);
pKeyMapEntry = limLookUpKeyMappings(pHdr->sa)
pKeyMapEntry
pKeyMapEntry
limLookUpKeyMappings(pHdr->sa)
limLookUpKeyMappings
limLookUpKeyMappings
pHdr->sa
pHdr
pHdr
sa
if (pKeyMapEntry)            {                if (!pKeyMapEntry->wepOn)                {                    // Log error                    PELOGE(limLog(pMac, LOGE,                           FL("received Auth frame3 from peer that has NULL "                           "key map entry "                           MAC_ADDRESS_STR),MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * Key Mapping entry has null key.                     * Send Authentication frame                     * with challenge failure status code                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                } // if (!pKeyMapEntry->wepOn)                else                {                    decryptResult = limDecryptAuthFrame(pMac, pKeyMapEntry->key,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH));                    if (decryptResult == LIM_DECRYPT_ICV_FAIL)                    {                        /// ICV failure                        PELOGW(limLog(pMac, LOGW, FL("=====> decryptResult == "                        "LIM_DECRYPT_ICV_FAIL ..."));)                        // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer "                               "that failed decryption, Addr "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                        limDeletePreAuthNode(pMac,                                             pHdr->sa);                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;                        authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                        authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }                    if ( ( sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                         &rxAuthFrame)!=eSIR_SUCCESS ) ||                         ( !isAuthValid(pMac, &rxAuthFrame,psessionEntry) ) )                    {                        PELOGE(limLog(pMac, LOGE,                               FL("failed to convert Auth Frame to structure "                               "or Auth is not valid "));)                        return;                    }                } // end if (pKeyMapEntry->key == NULL)            } // if keyMappings has entry            else            {                val = SIR_MAC_KEY_LENGTH;                if(psessionEntry->limSystemRole == eLIM_AP_ROLE)                {                    tpSirKeys pKey;                    pKey =  &psessionEntry->WEPKeyMaterial[keyId].key[0];                    vos_mem_copy(defaultKey, pKey->key, pKey->keyLength);                    val = pKey->keyLength;                }                else                if (wlan_cfgGetStr(pMac, (tANI_U16) (WNI_CFG_WEP_DEFAULT_KEY_1 + keyId),                              defaultKey, &val) != eSIR_SUCCESS)                {                    /// Could not get Default key from CFG.                    //Log error.                    limLog(pMac, LOGP,                           FL("could not retrieve Default key"));                    /**                     * Send Authentication frame                     * with challenge failure status code                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }                    key_length=val;                    decryptResult = limDecryptAuthFrame(pMac, defaultKey,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH));                    if (decryptResult == LIM_DECRYPT_ICV_FAIL)                    {                        PELOGW(limLog(pMac, LOGW, FL("=====> decryptResult == "                        "LIM_DECRYPT_ICV_FAIL ..."));)                        // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer that "                               "failed decryption: "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                        /// ICV failure                        limDeletePreAuthNode(pMac,                                             pHdr->sa);                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;                        authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                        authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }                    if ( ( sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                           &rxAuthFrame)!=eSIR_SUCCESS ) ||                        ( !isAuthValid(pMac, &rxAuthFrame, psessionEntry) ) )                    {                        limLog(pMac, LOGE,                               FL("failed to convert Auth Frame to structure "                               "or Auth is not valid "));                        return;                    }            }
pKeyMapEntry
pKeyMapEntry
{                if (!pKeyMapEntry->wepOn)                {                    // Log error                    PELOGE(limLog(pMac, LOGE,                           FL("received Auth frame3 from peer that has NULL "                           "key map entry "                           MAC_ADDRESS_STR),MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * Key Mapping entry has null key.                     * Send Authentication frame                     * with challenge failure status code                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                } // if (!pKeyMapEntry->wepOn)                else                {                    decryptResult = limDecryptAuthFrame(pMac, pKeyMapEntry->key,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH));                    if (decryptResult == LIM_DECRYPT_ICV_FAIL)                    {                        /// ICV failure                        PELOGW(limLog(pMac, LOGW, FL("=====> decryptResult == "                        "LIM_DECRYPT_ICV_FAIL ..."));)                        // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer "                               "that failed decryption, Addr "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                        limDeletePreAuthNode(pMac,                                             pHdr->sa);                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;                        authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                        authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }                    if ( ( sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                         &rxAuthFrame)!=eSIR_SUCCESS ) ||                         ( !isAuthValid(pMac, &rxAuthFrame,psessionEntry) ) )                    {                        PELOGE(limLog(pMac, LOGE,                               FL("failed to convert Auth Frame to structure "                               "or Auth is not valid "));)                        return;                    }                } // end if (pKeyMapEntry->key == NULL)            }
if (!pKeyMapEntry->wepOn)                {                    // Log error                    PELOGE(limLog(pMac, LOGE,                           FL("received Auth frame3 from peer that has NULL "                           "key map entry "                           MAC_ADDRESS_STR),MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * Key Mapping entry has null key.                     * Send Authentication frame                     * with challenge failure status code                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                } // if (!pKeyMapEntry->wepOn)                else                {                    decryptResult = limDecryptAuthFrame(pMac, pKeyMapEntry->key,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH));                    if (decryptResult == LIM_DECRYPT_ICV_FAIL)                    {                        /// ICV failure                        PELOGW(limLog(pMac, LOGW, FL("=====> decryptResult == "                        "LIM_DECRYPT_ICV_FAIL ..."));)                        // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer "                               "that failed decryption, Addr "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                        limDeletePreAuthNode(pMac,                                             pHdr->sa);                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;                        authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                        authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }                    if ( ( sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                         &rxAuthFrame)!=eSIR_SUCCESS ) ||                         ( !isAuthValid(pMac, &rxAuthFrame,psessionEntry) ) )                    {                        PELOGE(limLog(pMac, LOGE,                               FL("failed to convert Auth Frame to structure "                               "or Auth is not valid "));)                        return;                    }                }
!pKeyMapEntry->wepOn
pKeyMapEntry->wepOn
pKeyMapEntry
pKeyMapEntry
wepOn
{                    // Log error                    PELOGE(limLog(pMac, LOGE,                           FL("received Auth frame3 from peer that has NULL "                           "key map entry "                           MAC_ADDRESS_STR),MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * Key Mapping entry has null key.                     * Send Authentication frame                     * with challenge failure status code                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }
PELOGE(limLog(pMac, LOGE,                           FL("received Auth frame3 from peer that has NULL "                           "key map entry "                           MAC_ADDRESS_STR),MAC_ADDR_ARRAY(pHdr->sa));
)                    /**                     * Key Mapping entry has null key.                     * Send Authentication frame                     * with challenge failure status code                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;
authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;
authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4
authFrame.authTransactionSeqNumber
authFrame
authFrame
authTransactionSeqNumber
SIR_MAC_AUTH_FRAME_4
SIR_MAC_AUTH_FRAME_4
authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;
authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS
authFrame.authStatusCode
authFrame
authFrame
authStatusCode
eSIR_MAC_CHALLENGE_FAILURE_STATUS
eSIR_MAC_CHALLENGE_FAILURE_STATUS
limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);
limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry)
limSendAuthMgmtFrame
limSendAuthMgmtFrame
pMac
pMac
&authFrame
authFrame
authFrame
pHdr->sa
pHdr
pHdr
sa
LIM_NO_WEP_IN_FC
LIM_NO_WEP_IN_FC
psessionEntry
psessionEntry
return;
{                    decryptResult = limDecryptAuthFrame(pMac, pKeyMapEntry->key,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH));                    if (decryptResult == LIM_DECRYPT_ICV_FAIL)                    {                        /// ICV failure                        PELOGW(limLog(pMac, LOGW, FL("=====> decryptResult == "                        "LIM_DECRYPT_ICV_FAIL ..."));)                        // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer "                               "that failed decryption, Addr "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                        limDeletePreAuthNode(pMac,                                             pHdr->sa);                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;                        authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                        authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }                    if ( ( sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                         &rxAuthFrame)!=eSIR_SUCCESS ) ||                         ( !isAuthValid(pMac, &rxAuthFrame,psessionEntry) ) )                    {                        PELOGE(limLog(pMac, LOGE,                               FL("failed to convert Auth Frame to structure "                               "or Auth is not valid "));)                        return;                    }                }
decryptResult = limDecryptAuthFrame(pMac, pKeyMapEntry->key,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH));
decryptResult = limDecryptAuthFrame(pMac, pKeyMapEntry->key,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH))
decryptResult
decryptResult
limDecryptAuthFrame(pMac, pKeyMapEntry->key,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH))
limDecryptAuthFrame
limDecryptAuthFrame
pMac
pMac
pKeyMapEntry->key
pKeyMapEntry
pKeyMapEntry
key
pBody
pBody
plainBody
plainBody
key_length
key_length
(tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH)
(tANI_U16)
tANI_U16
tANI_U16
frameLen-SIR_MAC_WEP_IV_LENGTH
frameLen
frameLen
SIR_MAC_WEP_IV_LENGTH
SIR_MAC_WEP_IV_LENGTH
if (decryptResult == LIM_DECRYPT_ICV_FAIL)                    {                        /// ICV failure                        PELOGW(limLog(pMac, LOGW, FL("=====> decryptResult == "                        "LIM_DECRYPT_ICV_FAIL ..."));)                        // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer "                               "that failed decryption, Addr "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                        limDeletePreAuthNode(pMac,                                             pHdr->sa);                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;                        authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                        authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }
decryptResult == LIM_DECRYPT_ICV_FAIL
decryptResult
decryptResult
LIM_DECRYPT_ICV_FAIL
LIM_DECRYPT_ICV_FAIL
{                        /// ICV failure                        PELOGW(limLog(pMac, LOGW, FL("=====> decryptResult == "                        "LIM_DECRYPT_ICV_FAIL ..."));)                        // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer "                               "that failed decryption, Addr "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                        limDeletePreAuthNode(pMac,                                             pHdr->sa);                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;                        authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                        authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }
PELOGW(limLog(pMac, LOGW, FL("=====> decryptResult == "                        "LIM_DECRYPT_ICV_FAIL ..."));
)                        // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer "                               "that failed decryption, Addr "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));
)                        limDeletePreAuthNode(pMac,                                             pHdr->sa);
authFrame.authAlgoNumber = eSIR_SHARED_KEY;
authFrame.authAlgoNumber = eSIR_SHARED_KEY
authFrame.authAlgoNumber
authFrame
authFrame
authAlgoNumber
eSIR_SHARED_KEY
eSIR_SHARED_KEY
authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;
authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4
authFrame.authTransactionSeqNumber
authFrame
authFrame
authTransactionSeqNumber
SIR_MAC_AUTH_FRAME_4
SIR_MAC_AUTH_FRAME_4
authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;
authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS
authFrame.authStatusCode
authFrame
authFrame
authStatusCode
eSIR_MAC_CHALLENGE_FAILURE_STATUS
eSIR_MAC_CHALLENGE_FAILURE_STATUS
limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);
limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry)
limSendAuthMgmtFrame
limSendAuthMgmtFrame
pMac
pMac
&authFrame
authFrame
authFrame
pHdr->sa
pHdr
pHdr
sa
LIM_NO_WEP_IN_FC
LIM_NO_WEP_IN_FC
psessionEntry
psessionEntry
return;
if ( ( sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                         &rxAuthFrame)!=eSIR_SUCCESS ) ||                         ( !isAuthValid(pMac, &rxAuthFrame,psessionEntry) ) )                    {                        PELOGE(limLog(pMac, LOGE,                               FL("failed to convert Auth Frame to structure "                               "or Auth is not valid "));)                        return;                    }
( sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                         &rxAuthFrame)!=eSIR_SUCCESS ) ||                         ( !isAuthValid(pMac, &rxAuthFrame,psessionEntry) )
( sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                         &rxAuthFrame)!=eSIR_SUCCESS )
sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                         &rxAuthFrame)!=eSIR_SUCCESS
sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                         &rxAuthFrame)
sirConvertAuthFrame2Struct
sirConvertAuthFrame2Struct
pMac
pMac
plainBody
plainBody
frameLen-8
frameLen
frameLen
8
&rxAuthFrame
rxAuthFrame
rxAuthFrame
eSIR_SUCCESS
eSIR_SUCCESS
( !isAuthValid(pMac, &rxAuthFrame,psessionEntry) )
!isAuthValid(pMac, &rxAuthFrame,psessionEntry)
isAuthValid(pMac, &rxAuthFrame,psessionEntry)
isAuthValid
isAuthValid
pMac
pMac
&rxAuthFrame
rxAuthFrame
rxAuthFrame
psessionEntry
psessionEntry
{                        PELOGE(limLog(pMac, LOGE,                               FL("failed to convert Auth Frame to structure "                               "or Auth is not valid "));)                        return;                    }
PELOGE(limLog(pMac, LOGE,                               FL("failed to convert Auth Frame to structure "                               "or Auth is not valid "));
)                        return;
{                val = SIR_MAC_KEY_LENGTH;                if(psessionEntry->limSystemRole == eLIM_AP_ROLE)                {                    tpSirKeys pKey;                    pKey =  &psessionEntry->WEPKeyMaterial[keyId].key[0];                    vos_mem_copy(defaultKey, pKey->key, pKey->keyLength);                    val = pKey->keyLength;                }                else                if (wlan_cfgGetStr(pMac, (tANI_U16) (WNI_CFG_WEP_DEFAULT_KEY_1 + keyId),                              defaultKey, &val) != eSIR_SUCCESS)                {                    /// Could not get Default key from CFG.                    //Log error.                    limLog(pMac, LOGP,                           FL("could not retrieve Default key"));                    /**                     * Send Authentication frame                     * with challenge failure status code                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }                    key_length=val;                    decryptResult = limDecryptAuthFrame(pMac, defaultKey,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH));                    if (decryptResult == LIM_DECRYPT_ICV_FAIL)                    {                        PELOGW(limLog(pMac, LOGW, FL("=====> decryptResult == "                        "LIM_DECRYPT_ICV_FAIL ..."));)                        // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer that "                               "failed decryption: "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                        /// ICV failure                        limDeletePreAuthNode(pMac,                                             pHdr->sa);                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;                        authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                        authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }                    if ( ( sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                           &rxAuthFrame)!=eSIR_SUCCESS ) ||                        ( !isAuthValid(pMac, &rxAuthFrame, psessionEntry) ) )                    {                        limLog(pMac, LOGE,                               FL("failed to convert Auth Frame to structure "                               "or Auth is not valid "));                        return;                    }            }
val = SIR_MAC_KEY_LENGTH;
val = SIR_MAC_KEY_LENGTH
val
val
SIR_MAC_KEY_LENGTH
SIR_MAC_KEY_LENGTH
if(psessionEntry->limSystemRole == eLIM_AP_ROLE)                {                    tpSirKeys pKey;                    pKey =  &psessionEntry->WEPKeyMaterial[keyId].key[0];                    vos_mem_copy(defaultKey, pKey->key, pKey->keyLength);                    val = pKey->keyLength;                }                else                if (wlan_cfgGetStr(pMac, (tANI_U16) (WNI_CFG_WEP_DEFAULT_KEY_1 + keyId),                              defaultKey, &val) != eSIR_SUCCESS)                {                    /// Could not get Default key from CFG.                    //Log error.                    limLog(pMac, LOGP,                           FL("could not retrieve Default key"));                    /**                     * Send Authentication frame                     * with challenge failure status code                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }
psessionEntry->limSystemRole == eLIM_AP_ROLE
psessionEntry->limSystemRole
psessionEntry
psessionEntry
limSystemRole
eLIM_AP_ROLE
eLIM_AP_ROLE
{                    tpSirKeys pKey;                    pKey =  &psessionEntry->WEPKeyMaterial[keyId].key[0];                    vos_mem_copy(defaultKey, pKey->key, pKey->keyLength);                    val = pKey->keyLength;                }
tpSirKeys pKey;
tpSirKeys pKey;
tpSirKeys
tpSirKeys
pKey
pKey
pKey =  &psessionEntry->WEPKeyMaterial[keyId].key[0];
pKey =  &psessionEntry->WEPKeyMaterial[keyId].key[0]
pKey
pKey
&psessionEntry->WEPKeyMaterial[keyId].key[0]
psessionEntry->WEPKeyMaterial[keyId].key[0]
psessionEntry->WEPKeyMaterial[keyId].key
psessionEntry->WEPKeyMaterial[keyId]
psessionEntry->WEPKeyMaterial
psessionEntry
psessionEntry
WEPKeyMaterial
keyId
keyId
key
0
vos_mem_copy(defaultKey, pKey->key, pKey->keyLength);
vos_mem_copy(defaultKey, pKey->key, pKey->keyLength)
vos_mem_copy
vos_mem_copy
defaultKey
defaultKey
pKey->key
pKey
pKey
key
pKey->keyLength
pKey
pKey
keyLength
val = pKey->keyLength;
val = pKey->keyLength
val
val
pKey->keyLength
pKey
pKey
keyLength
if (wlan_cfgGetStr(pMac, (tANI_U16) (WNI_CFG_WEP_DEFAULT_KEY_1 + keyId),                              defaultKey, &val) != eSIR_SUCCESS)                {                    /// Could not get Default key from CFG.                    //Log error.                    limLog(pMac, LOGP,                           FL("could not retrieve Default key"));                    /**                     * Send Authentication frame                     * with challenge failure status code                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }
wlan_cfgGetStr(pMac, (tANI_U16) (WNI_CFG_WEP_DEFAULT_KEY_1 + keyId),                              defaultKey, &val) != eSIR_SUCCESS
wlan_cfgGetStr(pMac, (tANI_U16) (WNI_CFG_WEP_DEFAULT_KEY_1 + keyId),                              defaultKey, &val)
wlan_cfgGetStr
wlan_cfgGetStr
pMac
pMac
(tANI_U16) (WNI_CFG_WEP_DEFAULT_KEY_1 + keyId)
(tANI_U16)
tANI_U16
tANI_U16
WNI_CFG_WEP_DEFAULT_KEY_1 + keyId
WNI_CFG_WEP_DEFAULT_KEY_1
WNI_CFG_WEP_DEFAULT_KEY_1
keyId
keyId
defaultKey
defaultKey
&val
val
val
eSIR_SUCCESS
eSIR_SUCCESS
{                    /// Could not get Default key from CFG.                    //Log error.                    limLog(pMac, LOGP,                           FL("could not retrieve Default key"));                    /**                     * Send Authentication frame                     * with challenge failure status code                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }
limLog(pMac, LOGP,                           FL("could not retrieve Default key"));
limLog(pMac, LOGP,                           FL("could not retrieve Default key"))
limLog
limLog
pMac
pMac
LOGP
LOGP
FL("could not retrieve Default key")
FL
FL
"could not retrieve Default key"
authFrame.authAlgoNumber = eSIR_SHARED_KEY;
authFrame.authAlgoNumber = eSIR_SHARED_KEY
authFrame.authAlgoNumber
authFrame
authFrame
authAlgoNumber
eSIR_SHARED_KEY
eSIR_SHARED_KEY
authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;
authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4
authFrame.authTransactionSeqNumber
authFrame
authFrame
authTransactionSeqNumber
SIR_MAC_AUTH_FRAME_4
SIR_MAC_AUTH_FRAME_4
authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;
authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS
authFrame.authStatusCode
authFrame
authFrame
authStatusCode
eSIR_MAC_CHALLENGE_FAILURE_STATUS
eSIR_MAC_CHALLENGE_FAILURE_STATUS
limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);
limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry)
limSendAuthMgmtFrame
limSendAuthMgmtFrame
pMac
pMac
&authFrame
authFrame
authFrame
pHdr->sa
pHdr
pHdr
sa
LIM_NO_WEP_IN_FC
LIM_NO_WEP_IN_FC
psessionEntry
psessionEntry
return;
key_length=val;
key_length=val
key_length
key_length
val
val
decryptResult = limDecryptAuthFrame(pMac, defaultKey,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH));
decryptResult = limDecryptAuthFrame(pMac, defaultKey,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH))
decryptResult
decryptResult
limDecryptAuthFrame(pMac, defaultKey,                                                        pBody,                                                        plainBody,                                                        key_length,                                                        (tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH))
limDecryptAuthFrame
limDecryptAuthFrame
pMac
pMac
defaultKey
defaultKey
pBody
pBody
plainBody
plainBody
key_length
key_length
(tANI_U16) (frameLen-SIR_MAC_WEP_IV_LENGTH)
(tANI_U16)
tANI_U16
tANI_U16
frameLen-SIR_MAC_WEP_IV_LENGTH
frameLen
frameLen
SIR_MAC_WEP_IV_LENGTH
SIR_MAC_WEP_IV_LENGTH
if (decryptResult == LIM_DECRYPT_ICV_FAIL)                    {                        PELOGW(limLog(pMac, LOGW, FL("=====> decryptResult == "                        "LIM_DECRYPT_ICV_FAIL ..."));)                        // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer that "                               "failed decryption: "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                        /// ICV failure                        limDeletePreAuthNode(pMac,                                             pHdr->sa);                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;                        authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                        authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }
decryptResult == LIM_DECRYPT_ICV_FAIL
decryptResult
decryptResult
LIM_DECRYPT_ICV_FAIL
LIM_DECRYPT_ICV_FAIL
{                        PELOGW(limLog(pMac, LOGW, FL("=====> decryptResult == "                        "LIM_DECRYPT_ICV_FAIL ..."));)                        // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer that "                               "failed decryption: "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                        /// ICV failure                        limDeletePreAuthNode(pMac,                                             pHdr->sa);                        authFrame.authAlgoNumber = eSIR_SHARED_KEY;                        authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                        authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }
PELOGW(limLog(pMac, LOGW, FL("=====> decryptResult == "                        "LIM_DECRYPT_ICV_FAIL ..."));
)                        // Log error                        PELOGE(limLog(pMac, LOGE,                               FL("received Authentication frame from peer that "                               "failed decryption: "                               MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));
)                        /// ICV failure                        limDeletePreAuthNode(pMac,                                             pHdr->sa);
authFrame.authAlgoNumber = eSIR_SHARED_KEY;
authFrame.authAlgoNumber = eSIR_SHARED_KEY
authFrame.authAlgoNumber
authFrame
authFrame
authAlgoNumber
eSIR_SHARED_KEY
eSIR_SHARED_KEY
authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;
authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4
authFrame.authTransactionSeqNumber
authFrame
authFrame
authTransactionSeqNumber
SIR_MAC_AUTH_FRAME_4
SIR_MAC_AUTH_FRAME_4
authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;
authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS
authFrame.authStatusCode
authFrame
authFrame
authStatusCode
eSIR_MAC_CHALLENGE_FAILURE_STATUS
eSIR_MAC_CHALLENGE_FAILURE_STATUS
limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);
limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry)
limSendAuthMgmtFrame
limSendAuthMgmtFrame
pMac
pMac
&authFrame
authFrame
authFrame
pHdr->sa
pHdr
pHdr
sa
LIM_NO_WEP_IN_FC
LIM_NO_WEP_IN_FC
psessionEntry
psessionEntry
return;
if ( ( sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                           &rxAuthFrame)!=eSIR_SUCCESS ) ||                        ( !isAuthValid(pMac, &rxAuthFrame, psessionEntry) ) )                    {                        limLog(pMac, LOGE,                               FL("failed to convert Auth Frame to structure "                               "or Auth is not valid "));                        return;                    }
( sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                           &rxAuthFrame)!=eSIR_SUCCESS ) ||                        ( !isAuthValid(pMac, &rxAuthFrame, psessionEntry) )
( sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                           &rxAuthFrame)!=eSIR_SUCCESS )
sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                           &rxAuthFrame)!=eSIR_SUCCESS
sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,                           &rxAuthFrame)
sirConvertAuthFrame2Struct
sirConvertAuthFrame2Struct
pMac
pMac
plainBody
plainBody
frameLen-8
frameLen
frameLen
8
&rxAuthFrame
rxAuthFrame
rxAuthFrame
eSIR_SUCCESS
eSIR_SUCCESS
( !isAuthValid(pMac, &rxAuthFrame, psessionEntry) )
!isAuthValid(pMac, &rxAuthFrame, psessionEntry)
isAuthValid(pMac, &rxAuthFrame, psessionEntry)
isAuthValid
isAuthValid
pMac
pMac
&rxAuthFrame
rxAuthFrame
rxAuthFrame
psessionEntry
psessionEntry
{                        limLog(pMac, LOGE,                               FL("failed to convert Auth Frame to structure "                               "or Auth is not valid "));                        return;                    }
limLog(pMac, LOGE,                               FL("failed to convert Auth Frame to structure "                               "or Auth is not valid "));
limLog(pMac, LOGE,                               FL("failed to convert Auth Frame to structure "                               "or Auth is not valid "))
limLog
limLog
pMac
pMac
LOGE
LOGE
FL("failed to convert Auth Frame to structure "                               "or Auth is not valid ")
FL
FL
"failed to convert Auth Frame to structure "                               "or Auth is not valid "
return;
{            // Log error            PELOGE(limLog(pMac, LOGE,                   FL("received Authentication frame3 from peer that while "                   "privacy option is turned OFF "                   MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)            /**             * Privacy option is not implemented.             * So reject Authentication frame received with             * WEP bit set by sending Authentication frame             * with 'challenge failure' status code. This is             * another strange thing in the spec. Status code             * should have been 'unsupported algorithm' status code.             */            authFrame.authAlgoNumber = eSIR_SHARED_KEY;            authFrame.authTransactionSeqNumber =            SIR_MAC_AUTH_FRAME_4;            authFrame.authStatusCode =            eSIR_MAC_CHALLENGE_FAILURE_STATUS;            limSendAuthMgmtFrame(pMac, &authFrame,                                 pHdr->sa,                                 LIM_NO_WEP_IN_FC,psessionEntry);            return;        }
PELOGE(limLog(pMac, LOGE,                   FL("received Authentication frame3 from peer that while "                   "privacy option is turned OFF "                   MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));
)            /**             * Privacy option is not implemented.             * So reject Authentication frame received with             * WEP bit set by sending Authentication frame             * with 'challenge failure' status code. This is             * another strange thing in the spec. Status code             * should have been 'unsupported algorithm' status code.             */            authFrame.authAlgoNumber = eSIR_SHARED_KEY;
authFrame.authTransactionSeqNumber =            SIR_MAC_AUTH_FRAME_4;
authFrame.authTransactionSeqNumber =            SIR_MAC_AUTH_FRAME_4
authFrame.authTransactionSeqNumber
authFrame
authFrame
authTransactionSeqNumber
SIR_MAC_AUTH_FRAME_4
SIR_MAC_AUTH_FRAME_4
authFrame.authStatusCode =            eSIR_MAC_CHALLENGE_FAILURE_STATUS;
authFrame.authStatusCode =            eSIR_MAC_CHALLENGE_FAILURE_STATUS
authFrame.authStatusCode
authFrame
authFrame
authStatusCode
eSIR_MAC_CHALLENGE_FAILURE_STATUS
eSIR_MAC_CHALLENGE_FAILURE_STATUS
limSendAuthMgmtFrame(pMac, &authFrame,                                 pHdr->sa,                                 LIM_NO_WEP_IN_FC,psessionEntry);
limSendAuthMgmtFrame(pMac, &authFrame,                                 pHdr->sa,                                 LIM_NO_WEP_IN_FC,psessionEntry)
limSendAuthMgmtFrame
limSendAuthMgmtFrame
pMac
pMac
&authFrame
authFrame
authFrame
pHdr->sa
pHdr
pHdr
sa
LIM_NO_WEP_IN_FC
LIM_NO_WEP_IN_FC
psessionEntry
psessionEntry
return;
{        if ( ( sirConvertAuthFrame2Struct(pMac, pBody,            frameLen, &rxAuthFrame)!=eSIR_SUCCESS ) ||            ( !isAuthValid(pMac, &rxAuthFrame,psessionEntry) ) )        {            PELOGE(limLog(pMac, LOGE,                   FL("failed to convert Auth Frame to structure or Auth is "                   "not valid "));)            return;        }    }
if ( ( sirConvertAuthFrame2Struct(pMac, pBody,            frameLen, &rxAuthFrame)!=eSIR_SUCCESS ) ||            ( !isAuthValid(pMac, &rxAuthFrame,psessionEntry) ) )        {            PELOGE(limLog(pMac, LOGE,                   FL("failed to convert Auth Frame to structure or Auth is "                   "not valid "));)            return;        }
( sirConvertAuthFrame2Struct(pMac, pBody,            frameLen, &rxAuthFrame)!=eSIR_SUCCESS ) ||            ( !isAuthValid(pMac, &rxAuthFrame,psessionEntry) )
( sirConvertAuthFrame2Struct(pMac, pBody,            frameLen, &rxAuthFrame)!=eSIR_SUCCESS )
sirConvertAuthFrame2Struct(pMac, pBody,            frameLen, &rxAuthFrame)!=eSIR_SUCCESS
sirConvertAuthFrame2Struct(pMac, pBody,            frameLen, &rxAuthFrame)
sirConvertAuthFrame2Struct
sirConvertAuthFrame2Struct
pMac
pMac
pBody
pBody
frameLen
frameLen
&rxAuthFrame
rxAuthFrame
rxAuthFrame
eSIR_SUCCESS
eSIR_SUCCESS
( !isAuthValid(pMac, &rxAuthFrame,psessionEntry) )
!isAuthValid(pMac, &rxAuthFrame,psessionEntry)
isAuthValid(pMac, &rxAuthFrame,psessionEntry)
isAuthValid
isAuthValid
pMac
pMac
&rxAuthFrame
rxAuthFrame
rxAuthFrame
psessionEntry
psessionEntry
{            PELOGE(limLog(pMac, LOGE,                   FL("failed to convert Auth Frame to structure or Auth is "                   "not valid "));)            return;        }
PELOGE(limLog(pMac, LOGE,                   FL("failed to convert Auth Frame to structure or Auth is "                   "not valid "));
)            return;
pRxAuthFrameBody = &rxAuthFrame;
pRxAuthFrameBody = &rxAuthFrame
pRxAuthFrameBody
pRxAuthFrameBody
&rxAuthFrame
rxAuthFrame
rxAuthFrame
PELOGW(limLog(pMac, LOGW,           FL("Received Auth frame with type=%d seqnum=%d, status=%d (%d)"),           (tANI_U32) pRxAuthFrameBody->authAlgoNumber,           (tANI_U32) pRxAuthFrameBody->authTransactionSeqNumber,           (tANI_U32) pRxAuthFrameBody->authStatusCode,(tANI_U32)pMac->lim.gLimNumPreAuthContexts);
)    switch (pRxAuthFrameBody->authTransactionSeqNumber)    {        case SIR_MAC_AUTH_FRAME_1:            // AuthFrame 1            pStaDs = dphLookupHashEntry(pMac, pHdr->sa,                    &assocId, &psessionEntry->dph.dphHashTable);            if (pStaDs)            {                tLimMlmDisassocReq      *pMlmDisassocReq = NULL;                tLimMlmDeauthReq        *pMlmDeauthReq = NULL;                tAniBool                 isConnected = eSIR_TRUE;                pMlmDisassocReq = pMac->lim.limDisassocDeauthCnfReq.pMlmDisassocReq;                if (pMlmDisassocReq &&                        (vos_mem_compare((tANI_U8 *) pHdr->sa,                                         (tANI_U8 *) &pMlmDisassocReq->peerMacAddr,                                          sizeof(tSirMacAddr))))                {                    PELOGE(limLog(pMac, LOGE, FL("TODO:Ack for disassoc "                                "frame is pending Issue delsta for "                                MAC_ADDRESS_STR),                                MAC_ADDR_ARRAY(pMlmDisassocReq->peerMacAddr));)                    limProcessDisassocAckTimeout(pMac);                    isConnected = eSIR_FALSE;                }                pMlmDeauthReq = pMac->lim.limDisassocDeauthCnfReq.pMlmDeauthReq;                if (pMlmDeauthReq &&                        (vos_mem_compare((tANI_U8 *) pHdr->sa,                                         (tANI_U8 *) &pMlmDeauthReq->peerMacAddr,                                         sizeof(tSirMacAddr))))                {                    PELOGE(limLog(pMac, LOGE, FL("TODO:Ack for deauth frame "                                "is pending Issue delsta for "                                MAC_ADDRESS_STR),                                MAC_ADDR_ARRAY(pMlmDeauthReq->peerMacAddr));)                    limProcessDeauthAckTimeout(pMac);                    isConnected = eSIR_FALSE;                }                /* pStaDS != NULL and isConnected = 1 means the STA is already                 * connected, But SAP received the Auth from that station.                 * For non PMF connection send Deauth frame as STA will retry                 * to connect back.                 *                 * For PMF connection the AP should not tear down or otherwise                 * modify the state of the existing association until the                 * SA-Query procedure determines that the original SA is                 * invalid.                 */                if (isConnected#ifdef WLAN_FEATURE_11W                    && !pStaDs->rmfEnabled#endif                                          )                {                    limLog(pMac, LOGE,                            FL("STA is already connected but received auth frame"                                "Send the Deauth and lim Delete Station Context"                                "(staId: %d, assocId: %d) "),                            pStaDs->staIndex, assocId);                    limSendDeauthMgmtFrame(pMac, eSIR_MAC_UNSPEC_FAILURE_REASON,                            (tANI_U8 *) pHdr->sa, psessionEntry, FALSE);                    limTriggerSTAdeletion(pMac, pStaDs, psessionEntry);                    return;                }            }            /// Check if there exists pre-auth context for this STA            pAuthNode = limSearchPreAuthList(pMac, pHdr->sa);            if (pAuthNode)            {                /// Pre-auth context exists for the STA                if (pHdr->fc.retry == 0 || pAuthNode->seqNo != currSeqNo)                {                    /**                     * STA is initiating brand-new Authentication                     * sequence after local Auth Response timeout.                     * Or STA retrying to transmit First Auth frame due to packet drop OTA                     * Delete Pre-auth node and fall through.                     */                    if(pAuthNode->fTimerStarted)                    {                        limDeactivateAndChangePerStaIdTimer(pMac,                                                    eLIM_AUTH_RSP_TIMER,                                                    pAuthNode->authNodeIdx);                    }                    PELOGE(limLog(pMac, LOGE, FL("STA is initiating brand-new "                    "Authentication ..."));)                    limDeletePreAuthNode(pMac,                                         pHdr->sa);                    /**                     *  SAP Mode:Disassociate the station and                     *  delete its entry if we have its entry                     *  already and received "auth" from the                     *  same station.                     */                    for (assocId = 0; assocId < psessionEntry->dph.dphHashTable.size; assocId++)// Softap dphHashTable.size = 8                    {                        pStaDs = dphGetHashEntry(pMac, assocId, &psessionEntry->dph.dphHashTable);                        if (NULL == pStaDs)                             continue;                        if (pStaDs->valid)                        {                             if (vos_mem_compare((tANI_U8 *) &pStaDs->staAddr,                                      (tANI_U8 *) &(pHdr->sa), (tANI_U8) (sizeof(tSirMacAddr))) )                                  break;                        }                        pStaDs = NULL;                    }                    if (NULL != pStaDs#ifdef WLAN_FEATURE_11W                        && !pStaDs->rmfEnabled#endif                       )                    {                        PELOGE(limLog(pMac, LOGE, FL("lim Delete Station "                        "Context (staId: %d, assocId: %d) "),pStaDs->staIndex,                        assocId);)                        limSendDeauthMgmtFrame(pMac,                               eSIR_MAC_UNSPEC_FAILURE_REASON, (tANI_U8 *) pAuthNode->peerMacAddr, psessionEntry, FALSE);                        limTriggerSTAdeletion(pMac, pStaDs, psessionEntry);                        return;                    }                }                else                {                    /*                     * This can happen when first authentication frame is received                     * but ACK lost at STA side, in this case 2nd auth frame is already                     * in transmission queue                     * */                    PELOGE(limLog(pMac, LOGE, FL("STA is initiating "                    "Authentication after ACK lost..."));)                    return;                }            }            if (wlan_cfgGetInt(pMac, WNI_CFG_MAX_NUM_PRE_AUTH,                          (tANI_U32 *) &maxNumPreAuth) != eSIR_SUCCESS)            {                /**                 * Could not get MaxNumPreAuth                 * from CFG. Log error.                 */                limLog(pMac, LOGP,                       FL("could not retrieve MaxNumPreAuth"));            }            if (pMac->lim.gLimNumPreAuthContexts == maxNumPreAuth)            {                PELOGE(limLog(pMac, LOGE, FL("Max number of "                    "preauth context reached"));)                /**                 * Maximum number of pre-auth contexts                 * reached. Send Authentication frame                 * with unspecified failure                 */                authFrame.authAlgoNumber =                pRxAuthFrameBody->authAlgoNumber;                authFrame.authTransactionSeqNumber =                pRxAuthFrameBody->authTransactionSeqNumber + 1;                authFrame.authStatusCode =                eSIR_MAC_UNSPEC_FAILURE_STATUS;                limSendAuthMgmtFrame(pMac, &authFrame,                                     pHdr->sa,                                     LIM_NO_WEP_IN_FC,psessionEntry);                return;            }            /// No Pre-auth context exists for the STA.            if (limIsAuthAlgoSupported(                                      pMac,                                      (tAniAuthType)                                      pRxAuthFrameBody->authAlgoNumber, psessionEntry))            {                switch (pRxAuthFrameBody->authAlgoNumber)                {                    case eSIR_OPEN_SYSTEM:                        PELOGW(limLog(pMac, LOGW, FL("=======> eSIR_OPEN_SYSTEM  ..."));)                        /// Create entry for this STA in pre-auth list                        pAuthNode = limAcquireFreePreAuthNode(pMac, &pMac->lim.gLimPreAuthTimerTable);                        if (pAuthNode == NULL)                        {                            // Log error                            limLog(pMac, LOGW,                                   FL("Max pre-auth nodes reached "));                            limPrintMacAddr(pMac, pHdr->sa, LOGW);                            return;                        }                        limLog(pMac, LOG1,                               FL("Alloc new data: peer "MAC_ADDRESS_STR),                                                 MAC_ADDR_ARRAY(pHdr->sa));                        vos_mem_copy((tANI_U8 *) pAuthNode->peerMacAddr,                                      pHdr->sa,                                      sizeof(tSirMacAddr));                        pAuthNode->mlmState =                        eLIM_MLM_AUTHENTICATED_STATE;                        pAuthNode->authType = (tAniAuthType)                                              pRxAuthFrameBody->authAlgoNumber;                        pAuthNode->fSeen = 0;                        pAuthNode->fTimerStarted = 0;                        pAuthNode->seqNo = ((pHdr->seqControl.seqNumHi << 4) |                                            (pHdr->seqControl.seqNumLo));                        limAddPreAuthNode(pMac, pAuthNode);                        /**                         * Send Authenticaton frame with Success                         * status code.                         */                        authFrame.authAlgoNumber =                        pRxAuthFrameBody->authAlgoNumber;                        authFrame.authTransactionSeqNumber =                        pRxAuthFrameBody->authTransactionSeqNumber + 1;                        authFrame.authStatusCode = eSIR_MAC_SUCCESS_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        /// Send Auth indication to SME                        vos_mem_copy((tANI_U8 *) mlmAuthInd.peerMacAddr,                                     (tANI_U8 *) pHdr->sa,                                     sizeof(tSirMacAddr));                        mlmAuthInd.authType = (tAniAuthType)                                              pRxAuthFrameBody->authAlgoNumber;                        mlmAuthInd.sessionId = psessionEntry->smeSessionId;                        limPostSmeMessage(pMac,                                          LIM_MLM_AUTH_IND,                                          (tANI_U32 *) &mlmAuthInd);                        break;                    case eSIR_SHARED_KEY:                        PELOGW(limLog(pMac, LOGW, FL("=======> eSIR_SHARED_KEY  ..."));)                        if(psessionEntry->limSystemRole == eLIM_AP_ROLE)                        {                            val = psessionEntry->privacy;                        }                        else                        if (wlan_cfgGetInt(pMac, WNI_CFG_PRIVACY_ENABLED,                                      &val) != eSIR_SUCCESS)                        {                            /**                             * Could not get Privacy option                             * from CFG. Log error.                             */                            limLog(pMac, LOGP,                                   FL("could not retrieve Privacy option"));                        }                        cfgPrivacyOptImp = (tANI_U8)val;                        if (!cfgPrivacyOptImp)                        {                            // Log error                            PELOGE(limLog(pMac, LOGE,                                   FL("received Auth frame for unsupported auth algorithm %d "                                   MAC_ADDRESS_STR), pRxAuthFrameBody->authAlgoNumber,                                   MAC_ADDR_ARRAY(pHdr->sa));)                            /**                             * Authenticator does not have WEP                             * implemented.                             * Reject by sending Authentication frame                             * with Auth algorithm not supported status                             * code.                             */                            authFrame.authAlgoNumber =                            pRxAuthFrameBody->authAlgoNumber;                            authFrame.authTransactionSeqNumber =                            pRxAuthFrameBody->authTransactionSeqNumber + 1;                            authFrame.authStatusCode =                            eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS;                            limSendAuthMgmtFrame(                                                pMac, &authFrame,                                                pHdr->sa,                                                LIM_NO_WEP_IN_FC,psessionEntry);                            return;                        }                        else                        {                            // Create entry for this STA                            //in pre-auth list                            pAuthNode = limAcquireFreePreAuthNode(pMac, &pMac->lim.gLimPreAuthTimerTable);                            if (pAuthNode == NULL)                            {                                // Log error                                limLog(pMac, LOGW,                                       FL("Max pre-auth nodes reached "));                                limPrintMacAddr(pMac, pHdr->sa, LOGW);                                return;                            }                            vos_mem_copy((tANI_U8 *) pAuthNode->peerMacAddr,                                          pHdr->sa,                                          sizeof(tSirMacAddr));                            pAuthNode->mlmState =                            eLIM_MLM_WT_AUTH_FRAME3_STATE;                            pAuthNode->authType =                            (tAniAuthType)                            pRxAuthFrameBody->authAlgoNumber;                            pAuthNode->fSeen = 0;                            pAuthNode->fTimerStarted = 0;                            pAuthNode->seqNo = ((pHdr->seqControl.seqNumHi << 4) |                                                (pHdr->seqControl.seqNumLo));                            limAddPreAuthNode(pMac, pAuthNode);                            limLog(pMac, LOG1,                                   FL("Alloc new data: id %d peer "MAC_ADDRESS_STR),                                    pAuthNode->authNodeIdx, MAC_ADDR_ARRAY(pHdr->sa));                            /// Create and activate Auth Response timer                            if (tx_timer_change_context(&pAuthNode->timer, pAuthNode->authNodeIdx) != TX_SUCCESS)                            {                                /// Could not start Auth response timer.                                // Log error                                limLog(pMac, LOGP,                                   FL("Unable to chg context auth response timer for peer "));                                limPrintMacAddr(pMac, pHdr->sa, LOGP);                                /**                                 * Send Authenticaton frame with                                 * unspecified failure status code.                                 */                                authFrame.authAlgoNumber =                                        pRxAuthFrameBody->authAlgoNumber;                                authFrame.authTransactionSeqNumber =                                        pRxAuthFrameBody->authTransactionSeqNumber + 1;                                authFrame.authStatusCode =                                        eSIR_MAC_UNSPEC_FAILURE_STATUS;                                limSendAuthMgmtFrame(pMac, &authFrame,                                                     pHdr->sa,                                                     LIM_NO_WEP_IN_FC,psessionEntry);                                limDeletePreAuthNode(pMac, pHdr->sa);                                return;                            }                            limActivateAuthRspTimer(pMac, pAuthNode);                            pAuthNode->fTimerStarted = 1;                            // get random bytes and use as                            // challenge text                            // TODO                            //if( !VOS_IS_STATUS_SUCCESS( vos_rand_get_bytes( 0, (tANI_U8 *)challengeTextArray, SIR_MAC_AUTH_CHALLENGE_LENGTH ) ) )                            {                               limLog(pMac, LOGE,FL("Challenge text "                               "preparation failed in limProcessAuthFrame"));                            }                            pChallenge = pAuthNode->challengeText;                            vos_mem_copy(pChallenge,                                        (tANI_U8 *) challengeTextArray,                                         sizeof(challengeTextArray));                            /**                             * Sending Authenticaton frame with challenge.                             */                            authFrame.authAlgoNumber =                            pRxAuthFrameBody->authAlgoNumber;                            authFrame.authTransactionSeqNumber =                            pRxAuthFrameBody->authTransactionSeqNumber + 1;                            authFrame.authStatusCode =                            eSIR_MAC_SUCCESS_STATUS;                            authFrame.type   = SIR_MAC_CHALLENGE_TEXT_EID;                            authFrame.length = SIR_MAC_AUTH_CHALLENGE_LENGTH;                            vos_mem_copy(authFrame.challengeText,                                         pAuthNode->challengeText,                                         SIR_MAC_AUTH_CHALLENGE_LENGTH);                            limSendAuthMgmtFrame(                                                pMac, &authFrame,                                                pHdr->sa,                                                LIM_NO_WEP_IN_FC,psessionEntry);                        } // if (wlan_cfgGetInt(CFG_PRIVACY_OPTION_IMPLEMENTED))                        break;                    default:                         // Log error                       PELOGE( limLog(pMac, LOGE,                               FL("received Auth frame for unsupported auth "                               "algorithm %d "MAC_ADDRESS_STR),                               pRxAuthFrameBody->authAlgoNumber,                               MAC_ADDR_ARRAY(pHdr->sa));)                        /**                         * Responding party does not support the                         * authentication algorithm requested by                         * sending party.                         * Reject by sending Authentication frame                         * with auth algorithm not supported status code                         */                        authFrame.authAlgoNumber =                        pRxAuthFrameBody->authAlgoNumber;                        authFrame.authTransactionSeqNumber =                        pRxAuthFrameBody->authTransactionSeqNumber + 1;                        authFrame.authStatusCode =                        eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS;                        limSendAuthMgmtFrame(                                            pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                } // end switch(pRxAuthFrameBody->authAlgoNumber)            } // if (limIsAuthAlgoSupported(pRxAuthFrameBody->authAlgoNumber))            else            {                // Log error                PELOGE(limLog(pMac, LOGE,                       FL("received Authentication frame for unsupported auth "                       "algorithm %d "MAC_ADDRESS_STR),                       pRxAuthFrameBody->authAlgoNumber,                       MAC_ADDR_ARRAY(pHdr->sa));)                /**                 * Responding party does not support the                 * authentication algorithm requested by sending party.                 * Reject Authentication with StatusCode=13.                 */                authFrame.authAlgoNumber =                pRxAuthFrameBody->authAlgoNumber;                authFrame.authTransactionSeqNumber =                pRxAuthFrameBody->authTransactionSeqNumber + 1;                authFrame.authStatusCode =                eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS;                limSendAuthMgmtFrame(pMac, &authFrame,                                     pHdr->sa,                                     LIM_NO_WEP_IN_FC,psessionEntry);                return;            } //end if (limIsAuthAlgoSupported(pRxAuthFrameBody->authAlgoNumber))            break;        case SIR_MAC_AUTH_FRAME_2:            // AuthFrame 2            if (psessionEntry->limMlmState != eLIM_MLM_WT_AUTH_FRAME2_STATE)            {                /**                 * Received Authentication frame2 in an unexpected state.                 * Log error and ignore the frame.                 */                // Log error                limLog(pMac, LOG1,                       FL("received Auth frame2 from peer in state %d, addr "),                       psessionEntry->limMlmState);                limPrintMacAddr(pMac, pHdr->sa, LOG1);                return;            }            if ( !vos_mem_compare((tANI_U8 *) pHdr->sa,                                  (tANI_U8 *) &pMac->lim.gpLimMlmAuthReq->peerMacAddr,                                  sizeof(tSirMacAddr)) )            {                /**                 * Received Authentication frame from an entity                 * other than one request was initiated.                 * Wait until Authentication Failure Timeout.                 */                // Log error                PELOGW(limLog(pMac, LOGW,                       FL("received Auth frame2 from unexpected peer "                       MAC_ADDRESS_STR),                       MAC_ADDR_ARRAY(pHdr->sa));)                break;            }            if (pRxAuthFrameBody->authStatusCode ==                eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS)            {                /**                 * Interoperability workaround: Linksys WAP4400N is returning                 * wrong authType in OpenAuth response in case of                 * SharedKey AP configuration. Pretend we don't see that,                 * so upper layer can fallback to SharedKey authType,                 * and successfully connect to the AP.                 */                if (pRxAuthFrameBody->authAlgoNumber !=                    pMac->lim.gpLimMlmAuthReq->authType)                {                    pRxAuthFrameBody->authAlgoNumber =                    pMac->lim.gpLimMlmAuthReq->authType;                }            }            if (pRxAuthFrameBody->authAlgoNumber !=                pMac->lim.gpLimMlmAuthReq->authType)            {                /**                 * Received Authentication frame with an auth                 * algorithm other than one requested.                 * Wait until Authentication Failure Timeout.                 */                // Log error                PELOGW(limLog(pMac, LOGW,                       FL("received Auth frame2 for unexpected auth algo number %d "                       MAC_ADDRESS_STR), pRxAuthFrameBody->authAlgoNumber,                       MAC_ADDR_ARRAY(pHdr->sa));)                break;            }            if (pRxAuthFrameBody->authStatusCode ==                eSIR_MAC_SUCCESS_STATUS)            {                if (pRxAuthFrameBody->authAlgoNumber ==                    eSIR_OPEN_SYSTEM)                {                    psessionEntry->limCurrentAuthType = eSIR_OPEN_SYSTEM;                    pAuthNode = limAcquireFreePreAuthNode(pMac, &pMac->lim.gLimPreAuthTimerTable);                    if (pAuthNode == NULL)                    {                        // Log error                        limLog(pMac, LOGW,                               FL("Max pre-auth nodes reached "));                        limPrintMacAddr(pMac, pHdr->sa, LOGW);                        return;                    }                    limLog(pMac, LOG1,                              FL("Alloc new data: peer "MAC_ADDRESS_STR),                                                 MAC_ADDR_ARRAY(pHdr->sa));                    vos_mem_copy((tANI_U8 *) pAuthNode->peerMacAddr,                                 pMac->lim.gpLimMlmAuthReq->peerMacAddr,                                 sizeof(tSirMacAddr));                    pAuthNode->fTimerStarted = 0;                    pAuthNode->authType = pMac->lim.gpLimMlmAuthReq->authType;                    pAuthNode->seqNo = ((pHdr->seqControl.seqNumHi << 4) |                                        (pHdr->seqControl.seqNumLo));                    limAddPreAuthNode(pMac, pAuthNode);                    limRestoreFromAuthState(pMac, eSIR_SME_SUCCESS,                                            pRxAuthFrameBody->authStatusCode,psessionEntry);                } // if (pRxAuthFrameBody->authAlgoNumber == eSIR_OPEN_SYSTEM)                else                {                    // Shared key authentication                    if(psessionEntry->limSystemRole == eLIM_AP_ROLE)                    {                        val = psessionEntry->privacy;                    }                    else                    if (wlan_cfgGetInt(pMac, WNI_CFG_PRIVACY_ENABLED,                                  &val) != eSIR_SUCCESS)                    {                        /**                         * Could not get Privacy option                         * from CFG. Log error.                         */                        limLog(pMac, LOGP,                               FL("could not retrieve Privacy option"));                    }                    cfgPrivacyOptImp = (tANI_U8)val;                    if (!cfgPrivacyOptImp)                    {                        /**                         * Requesting STA does not have WEP implemented.                         * Reject with unsupported authentication algorithm                         * Status code and wait until auth failure timeout                         */                        // Log error                       PELOGE( limLog(pMac, LOGE,                               FL("received Auth frame from peer for "                               "unsupported auth algo %d "                               MAC_ADDRESS_STR), pRxAuthFrameBody->authAlgoNumber,                               MAC_ADDR_ARRAY(pHdr->sa));)                        authFrame.authAlgoNumber =                        pRxAuthFrameBody->authAlgoNumber;                        authFrame.authTransactionSeqNumber =                        pRxAuthFrameBody->authTransactionSeqNumber + 1;                        authFrame.authStatusCode =                        eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS;                        limSendAuthMgmtFrame(pMac, &authFrame,                                            pHdr->sa,                                            LIM_NO_WEP_IN_FC,psessionEntry);                        return;                    }                    else                    {                        if (pRxAuthFrameBody->type !=                            SIR_MAC_CHALLENGE_TEXT_EID)                        {                            // Log error                            PELOGE(limLog(pMac, LOGE,                                   FL("received Auth frame with invalid "                                   "challenge text IE"));)                            return;                        }                        /**                         * Check if there exists a key mappping key                         * for the STA that sent Authentication frame                         */                        pKeyMapEntry = limLookUpKeyMappings(                                                           pHdr->sa);                        if (pKeyMapEntry)                        {                            if (pKeyMapEntry->key == NULL)                            {                                // Log error                                PELOGE(limLog(pMac, LOGE,                                       FL("received Auth frame from peer when "                                       "key mapping key is NULL"MAC_ADDRESS_STR),                                       MAC_ADDR_ARRAY(pHdr->sa));)                                /**                                 * Key Mapping entry has null key.                                 * Send Auth frame with                                 * challenge failure status code                                 */                                authFrame.authAlgoNumber =                                pRxAuthFrameBody->authAlgoNumber;                                authFrame.authTransactionSeqNumber =                                pRxAuthFrameBody->authTransactionSeqNumber + 1;                                authFrame.authStatusCode =                                eSIR_MAC_CHALLENGE_FAILURE_STATUS;                                limSendAuthMgmtFrame(pMac, &authFrame,                                                     pHdr->sa,                                                     LIM_NO_WEP_IN_FC,psessionEntry);                                limRestoreFromAuthState(pMac, eSIR_SME_NO_KEY_MAPPING_KEY_FOR_PEER,                                                              eSIR_MAC_UNSPEC_FAILURE_REASON,psessionEntry);                                return;                            } // if (pKeyMapEntry->key == NULL)                            else                            {                                ((tpSirMacAuthFrameBody) plainBody)->authAlgoNumber =                                sirSwapU16ifNeeded(pRxAuthFrameBody->authAlgoNumber);                                ((tpSirMacAuthFrameBody) plainBody)->authTransactionSeqNumber =                                sirSwapU16ifNeeded((tANI_U16) (pRxAuthFrameBody->authTransactionSeqNumber + 1));                                ((tpSirMacAuthFrameBody) plainBody)->authStatusCode = eSIR_MAC_SUCCESS_STATUS;                                ((tpSirMacAuthFrameBody) plainBody)->type   = SIR_MAC_CHALLENGE_TEXT_EID;                                ((tpSirMacAuthFrameBody) plainBody)->length = SIR_MAC_AUTH_CHALLENGE_LENGTH;                                vos_mem_copy((tANI_U8 *) ((tpSirMacAuthFrameBody) plainBody)->challengeText,                                              pRxAuthFrameBody->challengeText,                                              SIR_MAC_AUTH_CHALLENGE_LENGTH);                                limEncryptAuthFrame(pMac, 0,                                                    pKeyMapEntry->key,                                                    plainBody,                                                    encrAuthFrame,key_length);                                psessionEntry->limMlmState = eLIM_MLM_WT_AUTH_FRAME4_STATE;                                MTRACE(macTrace(pMac, TRACE_CODE_MLM_STATE, psessionEntry->peSessionId, psessionEntry->limMlmState));                                limSendAuthMgmtFrame(pMac,                                                     (tpSirMacAuthFrameBody) encrAuthFrame,                                                     pHdr->sa,                                                     LIM_WEP_IN_FC,psessionEntry);                                break;                            } // end if (pKeyMapEntry->key == NULL)                        } // if (pKeyMapEntry)                        else                        {                            if (wlan_cfgGetInt(pMac, WNI_CFG_WEP_DEFAULT_KEYID,                                          &val) != eSIR_SUCCESS)                            {                                /**                                 * Could not get Default keyId                                 * from CFG. Log error.                                 */                                limLog(pMac, LOGP,                                       FL("could not retrieve Default keyId"));                            }                            keyId = (tANI_U8)val;                            val = SIR_MAC_KEY_LENGTH;                            if(psessionEntry->limSystemRole == eLIM_AP_ROLE)                            {                                tpSirKeys pKey;                                pKey =  &psessionEntry->WEPKeyMaterial[keyId].key[0];                                vos_mem_copy(defaultKey, pKey->key, pKey->keyLength);                            }                            else                            if (wlan_cfgGetStr(pMac, (tANI_U16) (WNI_CFG_WEP_DEFAULT_KEY_1 + keyId),                                          defaultKey,                                          &val)                                != eSIR_SUCCESS)                            {                                /// Could not get Default key from CFG.                                //Log error.                                limLog(pMac, LOGP,                                       FL("could not retrieve Default key"));                                authFrame.authAlgoNumber =                                pRxAuthFrameBody->authAlgoNumber;                                authFrame.authTransactionSeqNumber =                                pRxAuthFrameBody->authTransactionSeqNumber + 1;                                authFrame.authStatusCode =                                eSIR_MAC_CHALLENGE_FAILURE_STATUS;                                limSendAuthMgmtFrame(                                                    pMac, &authFrame,                                                    pHdr->sa,                                                    LIM_NO_WEP_IN_FC,psessionEntry);                                limRestoreFromAuthState(pMac, eSIR_SME_INVALID_WEP_DEFAULT_KEY,                                                              eSIR_MAC_UNSPEC_FAILURE_REASON,psessionEntry);                                break;                            }                                key_length=val;                                ((tpSirMacAuthFrameBody) plainBody)->authAlgoNumber =                                sirSwapU16ifNeeded(pRxAuthFrameBody->authAlgoNumber);                                ((tpSirMacAuthFrameBody) plainBody)->authTransactionSeqNumber =                                sirSwapU16ifNeeded((tANI_U16) (pRxAuthFrameBody->authTransactionSeqNumber + 1));                                ((tpSirMacAuthFrameBody) plainBody)->authStatusCode = eSIR_MAC_SUCCESS_STATUS;                                ((tpSirMacAuthFrameBody) plainBody)->type   = SIR_MAC_CHALLENGE_TEXT_EID;                                ((tpSirMacAuthFrameBody) plainBody)->length = SIR_MAC_AUTH_CHALLENGE_LENGTH;                                vos_mem_copy((tANI_U8 *) ((tpSirMacAuthFrameBody) plainBody)->challengeText,                                              pRxAuthFrameBody->challengeText,                                              SIR_MAC_AUTH_CHALLENGE_LENGTH);                                limEncryptAuthFrame(pMac, keyId,                                                    defaultKey,                                                    plainBody,                                                    encrAuthFrame,key_length);                                psessionEntry->limMlmState =                                eLIM_MLM_WT_AUTH_FRAME4_STATE;                                MTRACE(macTrace(pMac, TRACE_CODE_MLM_STATE, psessionEntry->peSessionId, psessionEntry->limMlmState));                                limSendAuthMgmtFrame(pMac,                                                     (tpSirMacAuthFrameBody) encrAuthFrame,                                                     pHdr->sa,                                                     LIM_WEP_IN_FC,psessionEntry);                                break;                        } // end if (pKeyMapEntry)                    } // end if (!wlan_cfgGetInt(CFG_PRIVACY_OPTION_IMPLEMENTED))                } // end if (pRxAuthFrameBody->authAlgoNumber == eSIR_OPEN_SYSTEM)            } // if (pRxAuthFrameBody->authStatusCode == eSIR_MAC_SUCCESS_STATUS)            else            {                /**                 * Authentication failure.                 * Return Auth confirm with received failure code to SME                 */                // Log error                PELOGE(limLog(pMac, LOGE,                       FL("received Auth frame from peer with failure code %d "                       MAC_ADDRESS_STR), pRxAuthFrameBody->authStatusCode,                       MAC_ADDR_ARRAY(pHdr->sa));)                limRestoreFromAuthState(pMac, eSIR_SME_AUTH_REFUSED,                                              pRxAuthFrameBody->authStatusCode,psessionEntry);            } // end if (pRxAuthFrameBody->authStatusCode == eSIR_MAC_SUCCESS_STATUS)            break;        case SIR_MAC_AUTH_FRAME_3:            // AuthFrame 3            if (pRxAuthFrameBody->authAlgoNumber != eSIR_SHARED_KEY)            {                // Log error                PELOGE(limLog(pMac, LOGE,                       FL("received Auth frame3 from peer with auth algo "                       "number %d "MAC_ADDRESS_STR),                       pRxAuthFrameBody->authAlgoNumber,                       MAC_ADDR_ARRAY(pHdr->sa));)                /**                 * Received Authentication frame3 with algorithm other than                 * Shared Key authentication type. Reject with Auth frame4                 * with 'out of sequence' status code.                 */                authFrame.authAlgoNumber = eSIR_SHARED_KEY;                authFrame.authTransactionSeqNumber =                SIR_MAC_AUTH_FRAME_4;                authFrame.authStatusCode =                eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                limSendAuthMgmtFrame(pMac, &authFrame,                                     pHdr->sa,                                     LIM_NO_WEP_IN_FC,psessionEntry);                return;            }            if (psessionEntry->limSystemRole == eLIM_AP_ROLE || psessionEntry->limSystemRole == eLIM_BT_AMP_AP_ROLE ||                psessionEntry->limSystemRole == eLIM_STA_IN_IBSS_ROLE)            {                /**                 * Check if wep bit was set in FC. If not set,                 * reject with Authentication frame4 with                 * 'challenge failure' status code.                 */                if (!pHdr->fc.wep)                {                    // Log error                    PELOGE(limLog(pMac, LOGE,                           FL("received Auth frame3 from peer with no WEP bit "                           "set "MAC_ADDRESS_STR),                           MAC_ADDR_ARRAY(pHdr->sa));)                    /// WEP bit is not set in FC of Auth Frame3                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }                pAuthNode = limSearchPreAuthList(pMac,                                                pHdr->sa);                if (pAuthNode == NULL)                {                     // Log error                    PELOGE(limLog(pMac, LOGW,                           FL("received AuthFrame3 from peer that has no "                           "preauth context "MAC_ADDRESS_STR),                            MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * No 'pre-auth' context exists for                     * this STA that sent an Authentication                     * frame3.                     * Send Auth frame4 with 'out of sequence'                     * status code.                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }                if (pAuthNode->mlmState == eLIM_MLM_AUTH_RSP_TIMEOUT_STATE)                {                    // Log error                    limLog(pMac, LOGW,                           FL("auth response timer timedout for peer "                           MAC_ADDRESS_STR),MAC_ADDR_ARRAY(pHdr->sa));                    /**                     * Received Auth Frame3 after Auth Response timeout.                     * Reject by sending Auth Frame4 with                     * Auth respone timeout Status Code.                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                    SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                    eSIR_MAC_AUTH_RSP_TIMEOUT_STATUS;                    limSendAuthMgmtFrame(                                        pMac, &authFrame,                                        pHdr->sa,                                        LIM_NO_WEP_IN_FC,psessionEntry);                    /// Delete pre-auth context of STA                    limDeletePreAuthNode(pMac,                                         pHdr->sa);                    return;                } // end switch (pAuthNode->mlmState)                if (pRxAuthFrameBody->authStatusCode != eSIR_MAC_SUCCESS_STATUS)                {                    /**                     * Received Authenetication Frame 3 with status code                     * other than success. Wait until Auth response timeout                     * to delete STA context.                     */                    // Log error                    PELOGE(limLog(pMac, LOGE,                           FL("received Auth frame3 from peer with status code %d "                           MAC_ADDRESS_STR), pRxAuthFrameBody->authStatusCode,                           MAC_ADDR_ARRAY(pHdr->sa));)                    return;                }                /**                 * Check if received challenge text is same as one sent in                 * Authentication frame3                 */                if (vos_mem_compare(pRxAuthFrameBody->challengeText,                                    pAuthNode->challengeText,                                    SIR_MAC_AUTH_CHALLENGE_LENGTH))                {                    /// Challenge match. STA is autheticated !                    /// Delete Authentication response timer if running                    limDeactivateAndChangePerStaIdTimer(pMac,                                                        eLIM_AUTH_RSP_TIMER,                                                        pAuthNode->authNodeIdx);                    pAuthNode->fTimerStarted = 0;                    pAuthNode->mlmState = eLIM_MLM_AUTHENTICATED_STATE;                    /**                     * Send Authentication Frame4 with 'success' Status Code.                     */                    authFrame.authAlgoNumber = eSIR_SHARED_KEY;                    authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode = eSIR_MAC_SUCCESS_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    /// Send Auth indication to SME                    vos_mem_copy((tANI_U8 *) mlmAuthInd.peerMacAddr,                                 (tANI_U8 *) pHdr->sa,                                  sizeof(tSirMacAddr));                    mlmAuthInd.authType = (tAniAuthType)                                          pRxAuthFrameBody->authAlgoNumber;                    mlmAuthInd.sessionId = psessionEntry->smeSessionId;                    limPostSmeMessage(pMac,                                      LIM_MLM_AUTH_IND,                                      (tANI_U32 *) &mlmAuthInd);                    break;                }                else                {                     // Log error                    PELOGE( limLog(pMac, LOGW,                                   FL("Challenge failure for peer "                                   MAC_ADDRESS_STR),                                   MAC_ADDR_ARRAY(pHdr->sa));)                    /**                     * Challenge Failure.                     * Send Authentication frame4 with 'challenge failure'                     * status code and wait until Auth response timeout to                     * delete STA context.                     */                    authFrame.authAlgoNumber =                        pRxAuthFrameBody->authAlgoNumber;                    authFrame.authTransactionSeqNumber =                        SIR_MAC_AUTH_FRAME_4;                    authFrame.authStatusCode =                        eSIR_MAC_CHALLENGE_FAILURE_STATUS;                    limSendAuthMgmtFrame(pMac, &authFrame,                                         pHdr->sa,                                         LIM_NO_WEP_IN_FC,psessionEntry);                    return;                }            } // if (pMac->lim.gLimSystemRole == eLIM_AP_ROLE || ...            break;        case SIR_MAC_AUTH_FRAME_4:            // AuthFrame 4            if (psessionEntry->limMlmState != eLIM_MLM_WT_AUTH_FRAME4_STATE)            {                /**                 * Received Authentication frame4 in an unexpected state.                 * Log error and ignore the frame.                 */                // Log error                limLog(pMac, LOG1,                       FL("received unexpected Auth frame4 from peer in state "                       "%d, addr "MAC_ADDRESS_STR), psessionEntry->limMlmState,                       MAC_ADDR_ARRAY(pHdr->sa));                return;            }            if (pRxAuthFrameBody->authAlgoNumber != eSIR_SHARED_KEY)            {                /**                 * Received Authentication frame4 with algorithm other than                 * Shared Key authentication type.                 * Wait until Auth failure timeout to report authentication                 * failure to SME.                 */                // Log error                PELOGE(limLog(pMac, LOGE,                       FL("received Auth frame4 from peer with invalid auth "                       "algo %d "MAC_ADDRESS_STR), pRxAuthFrameBody->authAlgoNumber,                       MAC_ADDR_ARRAY(pHdr->sa));)                return;            }            if ( !vos_mem_compare((tANI_U8 *) pHdr->sa,                                  (tANI_U8 *) &pMac->lim.gpLimMlmAuthReq->peerMacAddr,                                  sizeof(tSirMacAddr)) )            {                /**                 * Received Authentication frame from an entity                 * other than one to which request was initiated.                 * Wait until Authentication Failure Timeout.                 */                // Log error                PELOGE(limLog(pMac, LOGW,                       FL("received Auth frame4 from unexpected peer "                       MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                break;            }            if (pRxAuthFrameBody->authAlgoNumber !=                pMac->lim.gpLimMlmAuthReq->authType)            {                /**                 * Received Authentication frame with an auth algorithm                 * other than one requested.                 * Wait until Authentication Failure Timeout.                 */                PELOGE(limLog(pMac, LOGE,                       FL("received Authentication frame from peer with "                       "invalid auth seq number %d "                       MAC_ADDRESS_STR), pRxAuthFrameBody->authTransactionSeqNumber,                       MAC_ADDR_ARRAY(pHdr->sa));)                break;            }            if (pRxAuthFrameBody->authStatusCode ==                eSIR_MAC_SUCCESS_STATUS)            {                /**                 * Authentication Success !                 * Inform SME of same.                 */                psessionEntry->limCurrentAuthType = eSIR_SHARED_KEY;                pAuthNode = limAcquireFreePreAuthNode(pMac, &pMac->lim.gLimPreAuthTimerTable);                if (pAuthNode == NULL)                {                    // Log error                    limLog(pMac, LOGW,                           FL("Max pre-auth nodes reached "));                    limPrintMacAddr(pMac, pHdr->sa, LOGW);                    return;                }                limLog(pMac, LOG1,                         FL("Alloc new data: peer " MAC_ADDRESS_STR),                                              MAC_ADDR_ARRAY(pHdr->sa));                vos_mem_copy((tANI_U8 *) pAuthNode->peerMacAddr,                             pMac->lim.gpLimMlmAuthReq->peerMacAddr,                             sizeof(tSirMacAddr));                pAuthNode->fTimerStarted = 0;                pAuthNode->authType = pMac->lim.gpLimMlmAuthReq->authType;                pAuthNode->seqNo = ((pHdr->seqControl.seqNumHi << 4) |                                    (pHdr->seqControl.seqNumLo));                limAddPreAuthNode(pMac, pAuthNode);                limRestoreFromAuthState(pMac, eSIR_SME_SUCCESS,                                              pRxAuthFrameBody->authStatusCode,psessionEntry);            } // if (pRxAuthFrameBody->authStatusCode == eSIR_MAC_SUCCESS_STATUS)            else            {                /**                 * Authentication failure.                 * Return Auth confirm with received failure code to SME                 */                // Log error                PELOGE(limLog(pMac, LOGE, FL("Authentication failure from peer "                       MAC_ADDRESS_STR), MAC_ADDR_ARRAY(pHdr->sa));)                limRestoreFromAuthState(pMac, eSIR_SME_AUTH_REFUSED,                                              pRxAuthFrameBody->authStatusCode,psessionEntry);            } // end if (pRxAuthFrameBody->Status == 0)            break;        default:            /// Invalid Authentication Frame received. Ignore it.            // Log error            PELOGE(limLog(pMac, LOGE,                   FL("received Auth frame from peer with invalid auth seq "                   "number %d " MAC_ADDRESS_STR),                   pRxAuthFrameBody->authTransactionSeqNumber,                   MAC_ADDR_ARRAY(pHdr->sa));)            break;    }
-----joern-----
(856,162,0)
(487,88,0)
(441,1097,0)
(543,68,0)
(30,609,0)
(828,654,0)
(239,990,0)
(395,277,0)
(48,1130,0)
(405,78,0)
(365,759,0)
(105,489,0)
(303,613,0)
(400,162,0)
(815,489,0)
(445,489,0)
(1130,202,0)
(915,848,0)
(292,653,0)
(554,52,0)
(1137,489,0)
(162,202,0)
(339,1116,0)
(386,78,0)
(949,0,0)
(440,779,0)
(455,815,0)
(1034,274,0)
(213,58,0)
(966,438,0)
(511,813,0)
(866,713,0)
(769,919,0)
(1000,414,0)
(847,78,0)
(1097,1006,0)
(258,889,0)
(984,489,0)
(97,922,0)
(777,1094,0)
(1141,1062,0)
(904,987,0)
(468,348,0)
(516,78,0)
(184,737,0)
(990,167,0)
(387,47,0)
(944,154,0)
(358,988,0)
(491,133,0)
(238,587,0)
(457,146,0)
(929,482,0)
(247,489,0)
(932,191,0)
(125,827,0)
(1039,503,0)
(1066,78,0)
(250,105,0)
(447,43,0)
(748,292,0)
(817,1124,0)
(158,68,0)
(144,827,0)
(336,489,0)
(853,277,0)
(1077,569,0)
(857,776,0)
(757,353,0)
(290,819,0)
(522,78,0)
(58,213,0)
(493,553,0)
(679,1053,0)
(337,791,0)
(918,609,0)
(633,1082,0)
(587,935,0)
(225,1064,0)
(259,1097,0)
(112,138,0)
(252,609,0)
(181,499,0)
(338,531,0)
(352,134,0)
(716,960,0)
(602,273,0)
(797,609,0)
(802,1124,0)
(332,805,0)
(299,331,0)
(755,1004,0)
(1136,78,0)
(822,677,0)
(276,1004,0)
(507,279,0)
(811,325,0)
(47,609,0)
(1128,202,0)
(959,817,0)
(138,112,0)
(412,489,0)
(1018,1145,0)
(1015,621,0)
(370,385,0)
(497,855,0)
(281,202,0)
(210,224,0)
(960,716,0)
(974,280,0)
(726,346,0)
(1024,820,0)
(704,391,0)
(941,57,0)
(620,191,0)
(180,489,0)
(738,267,0)
(481,78,0)
(423,1124,0)
(1128,912,0)
(175,437,0)
(1053,527,0)
(1021,609,0)
(1054,985,0)
(737,965,0)
(1053,202,0)
(29,202,0)
(1036,878,0)
(437,489,0)
(253,577,0)
(174,1028,0)
(756,1094,0)
(380,1082,0)
(1006,244,0)
(1040,489,0)
(32,988,0)
(553,493,0)
(595,134,0)
(475,732,0)
(22,595,0)
(50,915,0)
(87,790,0)
(115,859,0)
(453,964,0)
(414,1054,0)
(996,653,0)
(950,454,0)
(948,1024,0)
(170,609,0)
(864,838,0)
(283,855,0)
(306,380,0)
(35,609,0)
(1004,276,0)
(363,433,0)
(757,531,0)
(750,489,0)
(1145,489,0)
(129,812,0)
(369,869,0)
(884,317,0)
(693,609,0)
(452,691,0)
(264,964,0)
(1027,134,0)
(583,489,0)
(603,202,0)
(1062,202,0)
(930,678,0)
(1117,526,0)
(380,983,0)
(711,202,0)
(432,282,0)
(249,790,0)
(721,205,0)
(273,489,0)
(172,110,0)
(373,78,0)
(933,249,0)
(911,797,0)
(120,626,0)
(517,583,0)
(977,489,0)
(789,1129,0)
(812,129,0)
(126,98,0)
(392,1146,0)
(1065,924,0)
(13,78,0)
(384,609,0)
(830,407,0)
(212,489,0)
(790,87,0)
(1097,823,0)
(397,823,0)
(646,987,0)
(535,1128,0)
(1132,29,0)
(161,1082,0)
(732,475,0)
(741,677,0)
(575,924,0)
(669,437,0)
(1070,77,0)
(801,545,0)
(894,561,0)
(57,244,0)
(164,320,0)
(867,856,0)
(686,489,0)
(621,1015,0)
(807,1082,0)
(626,120,0)
(43,838,0)
(305,617,0)
(839,489,0)
(545,605,0)
(46,808,0)
(994,458,0)
(579,983,0)
(38,134,0)
(450,736,0)
(452,839,0)
(987,904,0)
(863,915,0)
(545,489,0)
(167,990,0)
(484,819,0)
(780,482,0)
(954,489,0)
(594,560,0)
(515,116,0)
(263,78,0)
(840,620,0)
(804,1044,0)
(76,948,0)
(224,1124,0)
(527,1053,0)
(1125,609,0)
(487,489,0)
(594,609,0)
(360,954,0)
(798,380,0)
(1047,937,0)
(852,995,0)
(41,711,0)
(19,896,0)
(574,489,0)
(442,1124,0)
(575,142,0)
(716,306,0)
(1131,880,0)
(795,523,0)
(366,489,0)
(224,489,0)
(168,954,0)
(75,325,0)
(92,609,0)
(1031,346,0)
(705,94,0)
(771,1118,0)
(1083,244,0)
(72,895,0)
(445,0,0)
(353,653,0)
(1004,755,0)
(509,77,0)
(35,815,0)
(848,3,0)
(241,489,0)
(671,977,0)
(1028,924,0)
(730,446,0)
(421,1031,0)
(733,1050,0)
(1007,1082,0)
(886,737,0)
(1049,643,0)
(3,848,0)
(180,1048,0)
(378,609,0)
(751,399,0)
(1075,999,0)
(482,780,0)
(407,489,0)
(28,348,0)
(699,306,0)
(129,489,0)
(112,244,0)
(816,422,0)
(732,59,0)
(104,49,0)
(664,77,0)
(354,1050,0)
(120,78,0)
(262,802,0)
(973,1129,0)
(588,1137,0)
(59,732,0)
(654,828,0)
(636,742,0)
(337,721,0)
(854,213,0)
(1112,1015,0)
(668,501,0)
(15,509,0)
(102,202,0)
(1109,609,0)
(553,749,0)
(94,213,0)
(133,877,0)
(697,794,0)
(681,78,0)
(348,202,0)
(414,489,0)
(357,112,0)
(1046,142,0)
(162,856,0)
(973,489,0)
(382,839,0)
(192,189,0)
(433,363,0)
(695,49,0)
(324,1040,0)
(1085,78,0)
(183,78,0)
(399,859,0)
(735,141,0)
(919,327,0)
(882,108,0)
(607,609,0)
(142,575,0)
(416,609,0)
(271,804,0)
(780,489,0)
(980,609,0)
(366,551,0)
(1017,972,0)
(108,839,0)
(181,202,0)
(91,276,0)
(901,564,0)
(982,755,0)
(974,1146,0)
(713,607,0)
(410,521,0)
(1139,502,0)
(1054,414,0)
(282,823,0)
(319,724,0)
(844,815,0)
(243,446,0)
(729,878,0)
(503,489,0)
(502,202,0)
(995,609,0)
(811,1019,0)
(1050,674,0)
(565,670,0)
(291,765,0)
(790,249,0)
(119,789,0)
(217,1037,0)
(804,51,0)
(560,594,0)
(430,796,0)
(255,489,0)
(674,1050,0)
(997,984,0)
(829,863,0)
(27,560,0)
(312,1124,0)
(991,1122,0)
(658,614,0)
(212,952,0)
(243,489,0)
(364,228,0)
(815,35,0)
(1054,77,0)
(528,297,0)
(590,417,0)
(224,134,0)
(1126,614,0)
(792,1132,0)
(261,686,0)
(862,122,0)
(983,579,0)
(902,190,0)
(716,288,0)
(521,489,0)
(785,489,0)
(383,1125,0)
(865,626,0)
(1050,772,0)
(749,1082,0)
(116,489,0)
(587,238,0)
(348,28,0)
(638,265,0)
(214,711,0)
(694,416,0)
(132,347,0)
(1005,148,0)
(660,804,0)
(689,795,0)
(986,1095,0)
(999,1075,0)
(169,918,0)
(1024,948,0)
(17,811,0)
(577,253,0)
(1068,94,0)
(331,1124,0)
(1001,446,0)
(463,202,0)
(298,469,0)
(151,78,0)
(674,609,0)
(1108,577,0)
(914,827,0)
(1003,426,0)
(375,320,0)
(1098,785,0)
(508,1095,0)
(368,1025,0)
(231,446,0)
(229,489,0)
(573,134,0)
(714,36,0)
(585,523,0)
(288,489,0)
(198,412,0)
(804,660,0)
(750,265,0)
(122,489,0)
(896,202,0)
(47,69,0)
(1104,1054,0)
(839,108,0)
(1030,1028,0)
(804,271,0)
(399,975,0)
(766,1064,0)
(710,609,0)
(924,575,0)
(399,489,0)
(531,757,0)
(454,802,0)
(761,911,0)
(849,609,0)
(30,630,0)
(460,273,0)
(280,974,0)
(509,15,0)
(1137,687,0)
(202,78,0)
(687,1137,0)
(285,609,0)
(992,842,0)
(945,1072,0)
(794,937,0)
(371,1030,0)
(845,985,0)
(961,906,0)
(911,761,0)
(987,646,0)
(406,336,0)
(977,671,0)
(325,811,0)
(313,5,0)
(173,213,0)
(288,716,0)
(1044,804,0)
(320,55,0)
(572,927,0)
(25,1037,0)
(281,412,0)
(859,399,0)
(252,498,0)
(474,640,0)
(262,134,0)
(1073,816,0)
(160,1136,0)
(229,458,0)
(639,1040,0)
(134,255,0)
(1115,1094,0)
(505,605,0)
(424,609,0)
(213,78,0)
(892,991,0)
(488,599,0)
(69,47,0)
(123,631,0)
(541,246,0)
(277,395,0)
(549,426,0)
(1075,653,0)
(10,529,0)
(327,919,0)
(691,452,0)
(799,229,0)
(353,757,0)
(443,980,0)
(306,716,0)
(739,935,0)
(935,489,0)
(839,452,0)
(868,543,0)
(412,281,0)
(577,489,0)
(336,406,0)
(569,256,0)
(1105,118,0)
(269,1082,0)
(924,1028,0)
(406,246,0)
(454,1124,0)
(991,1024,0)
(147,212,0)
(314,1075,0)
(1086,444,0)
(1016,277,0)
(16,136,0)
(205,721,0)
(998,869,0)
(870,780,0)
(280,630,0)
(817,126,0)
(665,406,0)
(912,1128,0)
(609,424,0)
(630,280,0)
(248,790,0)
(120,489,0)
(521,842,0)
(1020,45,0)
(640,609,0)
(456,202,0)
(327,202,0)
(1060,67,0)
(747,112,0)
(1146,980,0)
(265,750,0)
(869,369,0)
(719,347,0)
(1122,991,0)
(942,549,0)
(488,134,0)
(100,116,0)
(509,985,0)
(934,1072,0)
(676,1023,0)
(49,104,0)
(191,620,0)
(105,0,0)
(864,202,0)
(873,621,0)
(504,972,0)
(935,587,0)
(599,1124,0)
(896,19,0)
(586,848,0)
(112,747,0)
(499,181,0)
(186,122,0)
(126,817,0)
(1046,108,0)
(276,91,0)
(802,262,0)
(435,807,0)
(1023,489,0)
(247,134,0)
(150,503,0)
(675,597,0)
(645,609,0)
(94,489,0)
(937,1082,0)
(644,593,0)
(402,417,0)
(628,573,0)
(185,289,0)
(356,456,0)
(891,454,0)
(351,116,0)
(817,959,0)
(128,797,0)
(642,915,0)
(1116,636,0)
(970,353,0)
(310,202,0)
(247,1124,0)
(63,363,0)
(953,38,0)
(112,357,0)
(446,243,0)
(983,77,0)
(57,489,0)
(855,202,0)
(270,732,0)
(1024,991,0)
(203,796,0)
(795,458,0)
(514,242,0)
(1019,811,0)
(12,609,0)
(963,92,0)
(129,78,0)
(1094,489,0)
(791,987,0)
(278,988,0)
(819,609,0)
(1146,974,0)
(315,288,0)
(231,496,0)
(127,148,0)
(469,776,0)
(614,658,0)
(426,489,0)
(134,1124,0)
(85,146,0)
(980,1146,0)
(1052,487,0)
(57,823,0)
(959,609,0)
(1025,988,0)
(385,312,0)
(24,1082,0)
(821,489,0)
(1075,314,0)
(381,1127,0)
(116,0,0)
(713,489,0)
(124,281,0)
(1050,489,0)
(1017,489,0)
(910,33,0)
(1134,633,0)
(696,653,0)
(226,202,0)
(176,785,0)
(422,643,0)
(731,498,0)
(106,543,0)
(882,781,0)
(806,923,0)
(29,1132,0)
(634,775,0)
(51,479,0)
(2,997,0)
(684,1035,0)
(647,526,0)
(838,605,0)
(1096,45,0)
(746,205,0)
(537,996,0)
(1114,226,0)
(983,985,0)
(1088,508,0)
(1055,412,0)
(915,863,0)
(734,102,0)
(506,742,0)
(1041,120,0)
(292,489,0)
(832,1023,0)
(496,653,0)
(1045,78,0)
(55,605,0)
(721,337,0)
(797,911,0)
(238,202,0)
(1030,609,0)
(630,30,0)
(52,554,0)
(163,78,0)
(879,778,0)
(453,489,0)
(633,380,0)
(991,892,0)
(897,12,0)
(81,1145,0)
(372,813,0)
(987,791,0)
(557,1124,0)
(827,489,0)
(583,653,0)
(796,202,0)
(246,406,0)
(391,1094,0)
(964,453,0)
(820,1024,0)
(1106,33,0)
(909,390,0)
(827,144,0)
(98,126,0)
(411,244,0)
(635,693,0)
(51,804,0)
(809,202,0)
(479,51,0)
(477,413,0)
(255,134,0)
(523,795,0)
(140,154,0)
(279,489,0)
(1145,1018,0)
(625,970,0)
(615,1036,0)
(813,446,0)
(990,202,0)
(343,1015,0)
(266,327,0)
(498,252,0)
(1129,973,0)
(277,489,0)
(86,994,0)
(1038,395,0)
(65,1072,0)
(498,489,0)
(677,489,0)
(1028,1030,0)
(984,997,0)
(742,636,0)
(964,609,0)
(1100,489,0)
(71,39,0)
(473,121,0)
(607,713,0)
(415,331,0)
(31,424,0)
(851,609,0)
(363,63,0)
(1064,225,0)
(750,466,0)
(823,244,0)
(166,1023,0)
(526,202,0)
(952,212,0)
(346,1031,0)
(454,891,0)
(426,549,0)
(633,489,0)
(187,1109,0)
(838,864,0)
(1031,489,0)
(614,1129,0)
(99,824,0)
(758,1048,0)
(334,1030,0)
(1094,391,0)
(40,104,0)
(700,453,0)
(230,545,0)
(791,337,0)
(657,1130,0)
(1037,489,0)
(374,78,0)
(6,609,0)
(330,35,0)
(672,1124,0)
(5,411,0)
(508,1088,0)
(260,931,0)
(677,741,0)
(558,633,0)
(207,882,0)
(808,46,0)
(446,347,0)
(62,114,0)
(391,202,0)
(824,99,0)
(529,499,0)
(1110,990,0)
(209,1082,0)
(976,1035,0)
(197,877,0)
(983,380,0)
(436,765,0)
(531,202,0)
(157,834,0)
(131,310,0)
(609,78,0)
(942,426,1)
(126,98,1)
(1068,705,1)
(795,458,1)
(290,524,1)
(915,50,1)
(736,450,1)
(291,436,1)
(930,431,1)
(790,248,1)
(213,58,1)
(839,489,1)
(791,337,1)
(674,609,1)
(922,97,1)
(35,330,1)
(906,961,1)
(277,489,1)
(141,735,1)
(762,407,1)
(864,202,1)
(449,190,1)
(723,795,1)
(144,827,1)
(704,1115,1)
(829,915,1)
(849,609,1)
(363,433,1)
(136,16,1)
(851,609,1)
(780,489,1)
(4,352,1)
(727,560,1)
(499,181,1)
(371,334,1)
(935,489,1)
(1050,674,1)
(647,1117,1)
(636,742,1)
(796,202,1)
(1040,489,1)
(414,489,1)
(763,863,1)
(370,423,1)
(935,739,1)
(1097,441,1)
(348,202,1)
(395,1038,1)
(452,691,1)
(896,202,1)
(456,356,1)
(1035,976,1)
(686,489,1)
(839,452,1)
(765,291,1)
(571,517,1)
(103,218,1)
(1075,999,1)
(677,489,1)
(863,915,1)
(246,406,1)
(626,865,1)
(1064,766,1)
(211,329,1)
(785,1098,1)
(407,489,1)
(731,252,1)
(843,1140,1)
(981,70,1)
(294,331,1)
(112,357,1)
(966,820,1)
(255,489,1)
(591,789,1)
(6,609,1)
(406,336,1)
(265,638,1)
(248,249,1)
(553,493,1)
(832,676,1)
(528,19,1)
(791,987,1)
(921,711,1)
(834,157,1)
(869,998,1)
(617,305,1)
(732,270,1)
(940,939,1)
(560,27,1)
(887,437,1)
(641,446,1)
(259,1083,1)
(334,1046,1)
(997,2,1)
(1094,391,1)
(1089,204,1)
(85,457,1)
(779,440,1)
(983,77,1)
(710,405,1)
(624,444,1)
(59,732,1)
(994,458,1)
(595,22,1)
(208,488,1)
(784,1129,1)
(886,1059,1)
(840,191,1)
(412,489,1)
(670,565,1)
(116,489,1)
(970,625,1)
(915,848,1)
(406,665,1)
(569,1077,1)
(327,202,1)
(1134,558,1)
(280,630,1)
(229,489,1)
(580,503,1)
(105,489,1)
(464,501,1)
(739,587,1)
(120,489,1)
(87,790,1)
(768,94,1)
(109,950,1)
(982,276,1)
(1009,384,1)
(115,751,1)
(819,609,1)
(306,699,1)
(873,1015,1)
(621,1015,1)
(720,912,1)
(817,126,1)
(191,932,1)
(595,134,1)
(114,62,1)
(228,364,1)
(1019,811,1)
(152,1004,1)
(96,813,1)
(1053,679,1)
(498,489,1)
(448,153,1)
(437,669,1)
(224,210,1)
(1132,792,1)
(1146,392,1)
(987,904,1)
(331,415,1)
(326,456,1)
(545,489,1)
(866,274,1)
(984,489,1)
(785,489,1)
(289,185,1)
(841,563,1)
(487,489,1)
(1046,108,1)
(543,868,1)
(57,823,1)
(678,930,1)
(1032,591,1)
(750,265,1)
(346,726,1)
(351,515,1)
(954,489,1)
(238,202,1)
(498,252,1)
(957,166,1)
(601,750,1)
(1030,609,1)
(900,740,1)
(792,29,1)
(57,489,1)
(869,369,1)
(502,202,1)
(164,375,1)
(1004,755,1)
(308,180,1)
(1022,395,1)
(995,852,1)
(240,52,1)
(112,747,1)
(531,202,1)
(365,55,1)
(492,176,1)
(854,213,1)
(540,660,1)
(855,497,1)
(415,299,1)
(660,804,1)
(826,849,1)
(158,543,1)
(1130,657,1)
(217,595,1)
(992,521,1)
(349,618,1)
(19,896,1)
(401,673,1)
(243,489,1)
(919,769,1)
(813,446,1)
(658,614,1)
(608,707,1)
(454,802,1)
(1107,417,1)
(212,489,1)
(780,482,1)
(69,47,1)
(953,817,1)
(463,344,1)
(186,796,1)
(148,127,1)
(168,360,1)
(408,712,1)
(94,489,1)
(815,489,1)
(911,761,1)
(1145,489,1)
(817,959,1)
(162,202,1)
(944,140,1)
(206,969,1)
(1023,832,1)
(1145,1018,1)
(979,645,1)
(37,1056,1)
(797,128,1)
(1074,985,1)
(288,716,1)
(262,134,1)
(180,489,1)
(1021,609,1)
(139,1068,1)
(529,10,1)
(129,489,1)
(954,168,1)
(167,990,1)
(713,607,1)
(711,202,1)
(463,1090,1)
(756,391,1)
(815,35,1)
(859,115,1)
(848,3,1)
(396,232,1)
(1115,777,1)
(905,784,1)
(1100,489,1)
(923,806,1)
(973,489,1)
(971,459,1)
(621,873,1)
(1149,308,1)
(276,91,1)
(899,1118,1)
(76,991,1)
(409,120,1)
(174,1030,1)
(51,479,1)
(1027,134,1)
(501,668,1)
(714,692,1)
(798,549,1)
(40,49,1)
(689,994,1)
(590,402,1)
(509,77,1)
(924,1028,1)
(509,985,1)
(949,116,1)
(1065,1028,1)
(1050,733,1)
(657,48,1)
(1050,489,1)
(790,249,1)
(560,594,1)
(497,283,1)
(270,475,1)
(397,411,1)
(412,198,1)
(277,395,1)
(796,203,1)
(224,489,1)
(620,191,1)
(833,943,1)
(39,71,1)
(1023,489,1)
(300,355,1)
(70,67,1)
(863,829,1)
(31,710,1)
(52,554,1)
(1075,314,1)
(391,202,1)
(918,609,1)
(273,602,1)
(508,1088,1)
(317,884,1)
(35,609,1)
(503,489,1)
(41,214,1)
(203,430,1)
(1063,250,1)
(38,134,1)
(1109,187,1)
(549,426,1)
(574,489,1)
(614,1129,1)
(805,332,1)
(716,306,1)
(7,925,1)
(690,808,1)
(241,489,1)
(876,686,1)
(1130,202,1)
(1074,144,1)
(1028,1030,1)
(1105,409,1)
(573,134,1)
(181,202,1)
(513,793,1)
(456,202,1)
(108,839,1)
(583,489,1)
(453,964,1)
(412,281,1)
(29,202,1)
(811,325,1)
(868,106,1)
(521,489,1)
(198,281,1)
(329,869,1)
(882,108,1)
(561,894,1)
(1091,285,1)
(577,489,1)
(1014,83,1)
(987,646,1)
(122,489,1)
(789,1129,1)
(1030,371,1)
(1031,346,1)
(556,1125,1)
(1135,807,1)
(663,1090,1)
(446,243,1)
(827,489,1)
(483,547,1)
(640,474,1)
(855,202,1)
(814,219,1)
(189,192,1)
(974,280,1)
(77,1070,1)
(613,303,1)
(281,124,1)
(750,489,1)
(239,1110,1)
(92,963,1)
(916,288,1)
(104,49,1)
(372,511,1)
(1031,489,1)
(711,41,1)
(955,1132,1)
(267,738,1)
(928,1099,1)
(204,1081,1)
(194,1040,1)
(484,290,1)
(431,293,1)
(120,626,1)
(196,781,1)
(1028,174,1)
(1017,489,1)
(1010,562,1)
(964,264,1)
(959,609,1)
(728,45,1)
(418,696,1)
(102,202,1)
(767,626,1)
(327,266,1)
(549,942,1)
(79,732,1)
(950,802,1)
(307,310,1)
(807,435,1)
(272,455,1)
(958,121,1)
(614,1126,1)
(110,172,1)
(353,757,1)
(320,164,1)
(231,446,1)
(824,99,1)
(142,575,1)
(526,647,1)
(253,577,1)
(702,1027,1)
(769,327,1)
(535,1076,1)
(991,1122,1)
(797,609,1)
(399,859,1)
(282,823,1)
(941,1006,1)
(665,336,1)
(340,114,1)
(224,134,1)
(63,363,1)
(1141,221,1)
(184,886,1)
(1095,986,1)
(348,468,1)
(764,803,1)
(990,239,1)
(36,714,1)
(1069,453,1)
(600,494,1)
(490,236,1)
(732,475,1)
(991,892,1)
(603,202,1)
(134,255,1)
(771,736,1)
(669,175,1)
(778,879,1)
(89,32,1)
(18,854,1)
(246,541,1)
(645,609,1)
(482,929,1)
(104,40,1)
(795,523,1)
(1070,664,1)
(802,262,1)
(882,207,1)
(154,944,1)
(341,324,1)
(285,609,1)
(693,635,1)
(724,319,1)
(633,489,1)
(611,162,1)
(713,489,1)
(655,828,1)
(309,722,1)
(730,446,1)
(935,587,1)
(56,720,1)
(1127,381,1)
(721,205,1)
(1062,202,1)
(80,333,1)
(94,213,1)
(1137,687,1)
(695,799,1)
(984,997,1)
(1054,1104,1)
(993,826,1)
(912,1128,1)
(737,184,1)
(27,594,1)
(980,609,1)
(1020,1096,1)
(860,911,1)
(821,489,1)
(546,1021,1)
(378,609,1)
(212,952,1)
(457,758,1)
(693,609,1)
(811,17,1)
(160,1136,1)
(343,1112,1)
(974,1146,1)
(150,1039,1)
(976,684,1)
(451,513,1)
(1125,609,1)
(498,731,1)
(229,458,1)
(526,202,1)
(306,380,1)
(911,797,1)
(1116,339,1)
(685,713,1)
(494,1037,1)
(927,572,1)
(1040,639,1)
(1132,29,1)
(649,928,1)
(757,531,1)
(402,1007,1)
(68,158,1)
(1128,202,1)
(523,585,1)
(1144,924,1)
(919,327,1)
(288,489,1)
(505,545,1)
(607,609,1)
(226,1114,1)
(925,1116,1)
(760,819,1)
(247,134,1)
(338,970,1)
(75,160,1)
(1112,895,1)
(337,721,1)
(1057,818,1)
(929,870,1)
(707,995,1)
(620,840,1)
(380,983,1)
(298,857,1)
(127,1005,1)
(50,642,1)
(862,186,1)
(816,1073,1)
(428,749,1)
(856,867,1)
(856,162,1)
(723,171,1)
(226,202,1)
(424,31,1)
(964,609,1)
(977,489,1)
(804,1044,1)
(1146,980,1)
(722,805,1)
(794,937,1)
(1137,489,1)
(1024,991,1)
(596,555,1)
(249,933,1)
(677,822,1)
(675,690,1)
(1094,489,1)
(512,650,1)
(352,134,1)
(1053,202,1)
(223,429,1)
(815,844,1)
(12,609,1)
(1092,422,1)
(225,1064,1)
(310,202,1)
(1097,823,1)
(509,15,1)
(801,230,1)
(744,1119,1)
(694,337,1)
(996,537,1)
(45,1020,1)
(594,609,1)
(324,564,1)
(541,406,1)
(261,144,1)
(252,609,1)
(190,902,1)
(907,728,1)
(630,30,1)
(917,445,1)
(319,570,1)
(453,489,1)
(17,325,1)
(53,880,1)
(698,178,1)
(962,548,1)
(488,134,1)
(47,387,1)
(983,579,1)
(913,815,1)
(1080,845,1)
(924,1065,1)
(273,489,1)
(279,489,1)
(527,1053,1)
(1054,77,1)
(426,489,1)
(1054,985,1)
(417,590,1)
(822,741,1)
(804,51,1)
(416,609,1)
(1096,627,1)
(994,86,1)
(990,202,1)
(445,489,1)
(754,193,1)
(830,603,1)
(1038,853,1)
(28,348,1)
(86,311,1)
(980,443,1)
(895,72,1)
(146,85,1)
(1109,609,1)
(514,644,1)
(434,1087,1)
(5,313,1)
(73,495,1)
(392,980,1)
(480,683,1)
(783,251,1)
(948,76,1)
(491,133,1)
(804,271,1)
(587,238,1)
(995,609,1)
(447,863,1)
(100,351,1)
(573,628,1)
(82,872,1)
(733,674,1)
(1094,756,1)
(819,484,1)
(1015,343,1)
(983,985,1)
(609,424,1)
(247,489,1)
(350,546,1)
(30,609,1)
(129,812,1)
(436,1025,1)
(575,924,1)
(813,372,1)
(454,891,1)
(375,838,1)
(170,609,1)
(532,1121,1)
(47,609,1)
(809,202,1)
(1099,854,1)
(486,905,1)
(547,89,1)
(742,506,1)
(808,46,1)
(845,978,1)
(846,410,1)
(1056,574,1)
(684,353,1)
(322,959,1)
(977,671,1)
(1037,489,1)
(828,654,1)
(121,473,1)
(1140,451,1)
(336,489,1)
(67,1060,1)
(399,489,1)
(689,458,1)
(282,432,1)
(439,389,1)
(1024,948,1)
(162,400,1)
(321,920,1)
(716,960,1)
(774,1079,1)
(444,1086,1)
(1129,973,1)
(920,173,1)
(503,150,1)
(122,862,1)
(898,549,1)
(455,136,1)
(820,1024,1)
(677,741,1)
(384,609,1)
(274,1034,1)
(524,780,1)
(388,595,1)
(112,138,1)
(118,1105,1)
(281,202,1)
(515,105,1)
(1119,624,1)
(173,213,1)
(311,67,1)
(414,1054,1)
(441,259,1)
(507,83,1)
(755,982,1)
(775,634,1)
(633,380,1)
(880,1131,1)
(640,609,1)
(718,242,1)
(25,217,1)
(171,791,1)
(838,864,1)
(92,609,1)
(362,573,1)
(437,489,1)
(292,489,1)
(390,909,1)
(1000,808,1)
(366,489,1)
(1004,276,1)
(986,508,1)
(748,856,2)
(934,1067,2)
(108,839,2)
(1094,489,2)
(327,809,2)
(1092,301,2)
(866,935,2)
(502,202,2)
(453,489,2)
(592,863,2)
(452,691,2)
(983,77,2)
(924,1028,2)
(973,1067,2)
(1088,863,2)
(779,245,2)
(311,67,2)
(1137,489,2)
(206,856,2)
(1097,823,2)
(849,809,2)
(935,587,2)
(445,489,2)
(814,83,2)
(973,489,2)
(407,489,2)
(194,552,2)
(1110,809,2)
(215,144,2)
(143,856,2)
(1060,795,2)
(241,1090,2)
(858,491,2)
(577,489,2)
(961,912,2)
(490,236,2)
(303,809,2)
(955,1132,2)
(614,1129,2)
(51,479,2)
(330,245,2)
(426,489,2)
(815,35,2)
(87,790,2)
(966,820,2)
(1145,1018,2)
(380,983,2)
(802,262,2)
(790,249,2)
(128,1067,2)
(568,789,2)
(57,823,2)
(1056,83,2)
(919,809,2)
(338,856,2)
(509,15,2)
(645,609,2)
(1148,784,2)
(32,854,2)
(200,491,2)
(1053,202,2)
(950,245,2)
(352,595,2)
(352,134,2)
(791,337,2)
(30,609,2)
(531,202,2)
(1125,609,2)
(906,912,2)
(399,859,2)
(545,863,2)
(752,856,2)
(393,444,2)
(811,325,2)
(820,1024,2)
(261,144,2)
(995,609,2)
(946,863,2)
(797,1067,2)
(228,784,2)
(412,281,2)
(911,1067,2)
(1099,854,2)
(12,609,2)
(744,444,2)
(730,856,2)
(1128,202,2)
(1049,301,2)
(273,89,2)
(220,83,2)
(636,742,2)
(745,28,2)
(349,245,2)
(963,245,2)
(305,89,2)
(764,144,2)
(248,1132,2)
(915,848,2)
(257,595,2)
(502,1090,2)
(543,552,2)
(1123,173,2)
(1031,489,2)
(242,617,2)
(804,51,2)
(285,245,2)
(1104,808,2)
(784,1067,2)
(366,267,2)
(1014,83,2)
(29,202,2)
(1121,144,2)
(1059,935,2)
(63,863,2)
(532,144,2)
(241,344,2)
(331,245,2)
(208,595,2)
(684,856,2)
(505,863,2)
(912,1128,2)
(203,820,2)
(279,83,2)
(387,738,2)
(987,646,2)
(788,863,2)
(52,863,2)
(412,1076,2)
(838,863,2)
(1145,245,2)
(696,856,2)
(1028,1030,2)
(229,458,2)
(224,245,2)
(508,1088,2)
(141,1067,2)
(1090,83,2)
(951,1067,2)
(316,856,2)
(92,245,2)
(52,554,2)
(112,138,2)
(867,19,2)
(1075,856,2)
(273,489,2)
(5,28,2)
(824,99,2)
(974,1146,2)
(462,144,2)
(589,83,2)
(603,202,2)
(596,617,2)
(529,245,2)
(674,609,2)
(594,609,2)
(876,144,2)
(82,595,2)
(990,202,2)
(363,433,2)
(281,1076,2)
(844,245,2)
(412,489,2)
(688,344,2)
(573,595,2)
(984,809,2)
(104,795,2)
(247,489,2)
(757,531,2)
(689,791,2)
(272,245,2)
(998,863,2)
(969,856,2)
(281,202,2)
(117,245,2)
(491,133,2)
(607,935,2)
(1095,863,2)
(92,609,2)
(164,863,2)
(416,609,2)
(1018,245,2)
(1043,1067,2)
(794,937,2)
(253,577,2)
(79,595,2)
(658,614,2)
(517,856,2)
(808,46,2)
(851,609,2)
(362,595,2)
(1119,444,2)
(56,912,2)
(301,617,2)
(920,173,2)
(35,245,2)
(919,327,2)
(231,856,2)
(986,863,2)
(633,489,2)
(889,863,2)
(795,791,2)
(808,912,2)
(1125,854,2)
(1133,1067,2)
(150,144,2)
(550,1067,2)
(855,202,2)
(36,491,2)
(959,609,2)
(43,863,2)
(1050,489,2)
(976,856,2)
(632,809,2)
(47,609,2)
(239,809,2)
(485,245,2)
(977,489,2)
(329,863,2)
(463,344,2)
(81,245,2)
(184,935,2)
(1129,1067,2)
(819,609,2)
(430,820,2)
(37,83,2)
(46,912,2)
(230,863,2)
(660,1067,2)
(670,491,2)
(170,609,2)
(634,83,2)
(243,489,2)
(954,489,2)
(1139,1090,2)
(198,1076,2)
(774,245,2)
(456,202,2)
(843,552,2)
(848,3,2)
(1035,856,2)
(68,552,2)
(873,895,2)
(498,245,2)
(320,863,2)
(366,489,2)
(508,863,2)
(1137,687,2)
(711,202,2)
(384,609,2)
(860,1067,2)
(531,856,2)
(202,344,2)
(827,489,2)
(863,915,2)
(611,19,2)
(1091,245,2)
(246,406,2)
(385,245,2)
(928,854,2)
(126,98,2)
(401,863,2)
(245,595,2)
(488,595,2)
(1017,489,2)
(363,863,2)
(852,856,2)
(677,741,2)
(991,1122,2)
(437,489,2)
(217,595,2)
(382,809,2)
(606,245,2)
(447,863,2)
(224,489,2)
(1128,1076,2)
(456,245,2)
(9,863,2)
(429,863,2)
(327,202,2)
(108,809,2)
(901,552,2)
(609,424,2)
(106,552,2)
(570,491,2)
(454,802,2)
(965,935,2)
(918,609,2)
(872,595,2)
(893,1090,2)
(649,854,2)
(1139,344,2)
(672,245,2)
(691,809,2)
(660,804,2)
(69,47,2)
(835,344,2)
(1130,202,2)
(598,863,2)
(212,489,2)
(578,1067,2)
(801,863,2)
(133,552,2)
(446,243,2)
(411,28,2)
(353,757,2)
(720,912,2)
(1073,301,2)
(754,863,2)
(613,809,2)
(247,134,2)
(1004,276,2)
(452,809,2)
(724,491,2)
(977,671,2)
(414,1054,2)
(608,856,2)
(640,89,2)
(523,67,2)
(535,1076,2)
(580,144,2)
(1147,617,2)
(69,738,2)
(1029,809,2)
(1040,489,2)
(996,856,2)
(231,446,2)
(731,245,2)
(262,245,2)
(49,795,2)
(622,856,2)
(502,344,2)
(453,964,2)
(780,482,2)
(129,1090,2)
(25,595,2)
(238,202,2)
(940,1067,2)
(882,108,2)
(1106,301,2)
(73,791,2)
(202,1090,2)
(826,809,2)
(414,489,2)
(34,863,2)
(521,489,2)
(224,134,2)
(38,595,2)
(812,344,2)
(304,856,2)
(809,202,2)
(294,245,2)
(564,552,2)
(884,784,2)
(597,808,2)
(475,595,2)
(6,609,2)
(640,609,2)
(1068,236,2)
(87,1132,2)
(129,489,2)
(896,202,2)
(839,489,2)
(987,904,2)
(1140,552,2)
(526,202,2)
(496,856,2)
(42,144,2)
(63,363,2)
(455,245,2)
(815,489,2)
(698,83,2)
(474,89,2)
(810,863,2)
(947,809,2)
(789,1129,2)
(1026,1132,2)
(210,245,2)
(994,791,2)
(376,1090,2)
(893,344,2)
(677,489,2)
(503,144,2)
(64,28,2)
(495,791,2)
(864,202,2)
(1112,895,2)
(418,856,2)
(851,491,2)
(180,489,2)
(415,245,2)
(1062,202,2)
(644,617,2)
(109,245,2)
(440,245,2)
(509,985,2)
(995,856,2)
(487,489,2)
(342,344,2)
(595,134,2)
(494,595,2)
(797,609,2)
(688,1090,2)
(834,14,2)
(750,265,2)
(225,1064,2)
(587,238,2)
(835,1090,2)
(562,863,2)
(323,789,2)
(476,83,2)
(671,173,2)
(1031,346,2)
(4,595,2)
(547,89,2)
(1054,77,2)
(628,595,2)
(162,202,2)
(35,609,2)
(721,205,2)
(186,820,2)
(390,552,2)
(414,808,2)
(823,28,2)
(621,1015,2)
(971,89,2)
(993,809,2)
(193,863,2)
(680,738,2)
(574,489,2)
(1146,980,2)
(1012,863,2)
(211,863,2)
(122,489,2)
(459,89,2)
(675,808,2)
(498,489,2)
(610,1067,2)
(388,595,2)
(280,630,2)
(212,952,2)
(240,863,2)
(869,369,2)
(909,552,2)
(780,489,2)
(356,245,2)
(861,83,2)
(86,67,2)
(139,236,2)
(874,820,2)
(718,617,2)
(856,19,2)
(219,83,2)
(991,892,2)
(288,489,2)
(714,491,2)
(18,854,2)
(83,144,2)
(869,863,2)
(364,784,2)
(142,575,2)
(344,491,2)
(695,795,2)
(732,475,2)
(809,935,2)
(478,1132,2)
(583,489,2)
(1102,912,2)
(1145,489,2)
(266,809,2)
(55,863,2)
(241,489,2)
(530,28,2)
(812,1090,2)
(514,617,2)
(247,595,2)
(802,245,2)
(1074,144,2)
(1094,391,2)
(256,863,2)
(984,489,2)
(539,1132,2)
(599,595,2)
(483,89,2)
(1132,29,2)
(507,83,2)
(39,809,2)
(528,19,2)
(813,446,2)
(375,863,2)
(510,491,2)
(879,784,2)
(862,820,2)
(713,607,2)
(1023,489,2)
(199,344,2)
(620,191,2)
(499,245,2)
(796,820,2)
(1010,863,2)
(162,19,2)
(1071,617,2)
(94,236,2)
(145,863,2)
(1021,609,2)
(252,245,2)
(763,863,2)
(933,1132,2)
(542,856,2)
(775,83,2)
(120,626,2)
(513,552,2)
(423,245,2)
(383,854,2)
(178,83,2)
(1024,991,2)
(964,609,2)
(340,144,2)
(1079,245,2)
(451,552,2)
(821,539,2)
(114,144,2)
(573,134,2)
(348,202,2)
(172,301,2)
(337,721,2)
(839,452,2)
(815,245,2)
(759,863,2)
(730,446,2)
(499,181,2)
(616,856,2)
(1058,863,2)
(1034,935,2)
(1042,89,2)
(804,271,2)
(799,795,2)
(1126,228,2)
(999,856,2)
(817,126,2)
(313,28,2)
(702,245,2)
(735,1067,2)
(279,489,2)
(938,809,2)
(319,491,2)
(40,795,2)
(1027,245,2)
(565,491,2)
(974,280,2)
(335,89,2)
(1142,1067,2)
(454,891,2)
(314,856,2)
(538,820,2)
(101,856,2)
(977,173,2)
(113,791,2)
(500,491,2)
(102,202,2)
(277,489,2)
(716,306,2)
(67,795,2)
(1054,985,2)
(1039,144,2)
(959,595,2)
(486,784,2)
(1109,609,2)
(160,1136,2)
(574,83,2)
(1000,808,2)
(10,245,2)
(540,1067,2)
(274,935,2)
(607,609,2)
(712,83,2)
(229,795,2)
(157,14,2)
(1004,755,2)
(173,213,2)
(353,856,2)
(288,716,2)
(104,49,2)
(167,990,2)
(785,489,2)
(136,245,2)
(864,863,2)
(258,863,2)
(523,791,2)
(1019,811,2)
(1061,245,2)
(553,493,2)
(289,809,2)
(62,144,2)
(86,791,2)
(1046,108,2)
(463,1090,2)
(707,856,2)
(326,245,2)
(981,67,2)
(693,609,2)
(226,863,2)
(624,444,2)
(795,458,2)
(2,809,2)
(1015,895,2)
(397,28,2)
(181,245,2)
(167,809,2)
(57,489,2)
(400,19,2)
(73,67,2)
(89,854,2)
(370,245,2)
(585,791,2)
(600,595,2)
(661,301,2)
(732,595,2)
(498,252,2)
(1100,489,2)
(158,552,2)
(1114,863,2)
(84,856,2)
(817,595,2)
(663,1090,2)
(838,864,2)
(911,797,2)
(803,144,2)
(817,959,2)
(285,609,2)
(790,1132,2)
(571,856,2)
(406,336,2)
(849,609,2)
(737,935,2)
(185,809,2)
(1138,173,2)
(343,895,2)
(408,83,2)
(361,863,2)
(575,924,2)
(582,738,2)
(983,579,2)
(491,552,2)
(1075,999,2)
(839,809,2)
(821,489,2)
(226,202,2)
(856,162,2)
(229,489,2)
(19,896,2)
(757,856,2)
(556,854,2)
(1050,674,2)
(59,595,2)
(527,1053,2)
(299,245,2)
(601,912,2)
(378,863,2)
(105,489,2)
(617,89,2)
(630,30,2)
(716,960,2)
(816,301,2)
(778,784,2)
(990,809,2)
(633,380,2)
(1075,314,2)
(249,1132,2)
(769,809,2)
(276,91,2)
(690,808,2)
(444,854,2)
(888,660,2)
(287,1132,2)
(621,895,2)
(324,552,2)
(555,617,2)
(804,1044,2)
(868,552,2)
(182,173,2)
(913,245,2)
(306,380,2)
(254,491,2)
(686,489,2)
(149,344,2)
(292,856,2)
(292,489,2)
(341,552,2)
(116,489,2)
(129,812,2)
(713,935,2)
(939,1067,2)
(112,747,2)
(262,134,2)
(1013,552,2)
(378,609,2)
(1103,552,2)
(503,489,2)
(639,552,2)
(59,732,2)
(124,1076,2)
(629,245,2)
(818,912,2)
(110,301,2)
(569,863,2)
(359,617,2)
(648,856,2)
(994,67,2)
(391,202,2)
(682,301,2)
(282,823,2)
(159,245,2)
(255,489,2)
(454,245,2)
(545,489,2)
(252,609,2)
(28,348,2)
(549,426,2)
(984,997,2)
(673,863,2)
(911,761,2)
(560,594,2)
(70,67,2)
(1086,854,2)
(317,784,2)
(1077,863,2)
(134,255,2)
(1129,973,2)
(692,491,2)
(705,236,2)
(585,67,2)
(422,301,2)
(93,144,2)
(322,595,2)
(310,202,2)
(1054,808,2)
(686,144,2)
(898,549,2)
(791,987,2)
(488,134,2)
(795,523,2)
(144,827,2)
(886,935,2)
(795,67,2)
(94,213,2)
(1055,1076,2)
(828,654,2)
(994,458,2)
(495,67,2)
(71,809,2)
(270,595,2)
(905,784,2)
(793,552,2)
(583,856,2)
(970,856,2)
(658,228,2)
(277,395,2)
(796,202,2)
(685,935,2)
(625,856,2)
(399,489,2)
(750,489,2)
(509,77,2)
(1030,609,2)
(460,89,2)
(16,245,2)
(953,595,2)
(1024,948,2)
(891,245,2)
(321,173,2)
(404,83,2)
(1100,28,2)
(365,863,2)
(689,67,2)
(112,357,2)
(614,228,2)
(912,1076,2)
(537,856,2)
(1057,912,2)
(768,236,2)
(738,1067,2)
(850,245,2)
(935,489,2)
(171,791,2)
(47,738,2)
(336,489,2)
(602,89,2)
(854,213,2)
(181,202,2)
(94,489,2)
(983,985,2)
(120,489,2)
(129,344,2)
(713,489,2)
(509,809,2)
(1037,489,2)
(223,863,2)
(1027,134,2)
(126,595,2)
(1037,595,2)
(213,58,2)
(1040,552,2)
(122,820,2)
(267,1067,2)
(312,245,2)
(518,617,2)
(38,134,2)
(980,609,2)
(997,809,2)
-----------------------------------
(0,)
(1,)
(2,"=======> eSIR_OPEN_SYSTEM  ...")
(3,limLookUpKeyMappings(\n\\n                                                           pHdr->sa)
(4,0)
(5,psessionEntry->limCurrentAuthType)
(6,pHdr->sa)
(7,authTransactionSeqNumber)
(8,val)
(9,vos_mem_copy((tANI_U8 *)
(10,authAlgoNumber)
(11,tANI_U8 *)
(12,pHdr->sa)
(13,keyId)
(14,VOS_P2P_CLIENT_MODE == psessionEntry->pePersona)
(15,tANI_U8)
(16,eSIR_MAC_UNSPEC_FAILURE_STATUS)
(17,dphHashTable)
(18,psessionEntry)
(19,pRxAuthFrameBody->authStatusCode != eSIR_MAC_SUCCESS_STATUS)
(20,LIM_WEP_IN_FC)
(21,tANI_U8)
(22,NULL)
(23,mlmAuthInd.authType = (tAniAuthType)
(24,if(psessionEntry->limSystemRole == eLIM_AP_ROLE)
(25,LOGW)
(26,authFrame)
(27,seqNumHi)
(28,pRxAuthFrameBody->authStatusCode ==\n\\n                eSIR_MAC_SUCCESS_STATUS)
(29,pRxAuthFrameBody->authAlgoNumber)
(30,pHdr->seqControl)
(31,pRxPacketInfo)
(32,cfgPrivacyOptImp = (tANI_U8)
(33,)
(34,plainBody)
(35,pHdr->sa)
(36,&authFrame)
(37,authAlgoNumber)
(38,pAuthNode->mlmState)
(39,authFrame.authTransactionSeqNumber)
(40,dphHashTable)
(41,challengeText)
(42,pHdr)
(43,authFrame.authAlgoNumber)
(44,psessionEntry)
(45,authFrame.authTransactionSeqNumber)
(46,psessionEntry->limSystemRole)
(47,pHdr->sa)
(48,pRxAuthFrameBody)
(49,psessionEntry->dph)
(50,key)
(51,(tANI_U8 *)
(52,(tpSirMacAuthFrameBody)
(53,eLIM_AP_ROLE)
(54,if ((pAuthNode->mlmState !=\n\\n                     eLIM_MLM_WT_AUTH_FRAME3_STATE)
(55,authFrame.authTransactionSeqNumber =\n\\n                                pRxAuthFrameBody->authTransactionSeqNumber + 1)
(56,limCurrentAuthType)
(57,limAddPreAuthNode(pMac, pAuthNode)
(58,WDA_GET_RX_PAYLOAD_LEN(pRxPacketInfo)
(59,(pHdr->seqControl.seqNumHi << 4)
(60,psessionEntry->WEPKeyMaterial[keyId].key[0])
(61,if (pAuthNode == NULL)
(62,eSIR_SHARED_KEY)
(63,((tpSirMacAuthFrameBody)
(64,&pMac->lim.gLimPreAuthTimerTable)
(65,if (pMlmDeauthReq &&\n\\n                        (vos_mem_compare((tANI_U8 *)
(66,1)
(67,NULL == pStaDs)
(68,authFrame.authTransactionSeqNumber =\n\\n                    SIR_MAC_AUTH_FRAME_4)
(69,(tANI_U8 *)
(70,pStaDs)
(71,authTransactionSeqNumber)
(72,eLIM_AP_ROLE)
(73,dphHashTable)
(74,bssId)
(75,psessionEntry)
(76,tSirMacAddr)
(77,val = SIR_MAC_KEY_LENGTH)
(78,)
(79,pHdr)
(80,peerMacAddr)
(81,pMac)
(82,authNodeIdx)
(83,decryptResult == LIM_DECRYPT_ICV_FAIL)
(84,sa)
(85,authTransactionSeqNumber)
(86,assocId)
(87,&pMac->lim.gpLimMlmAuthReq->peerMacAddr)
(88,)
(89,cfgPrivacyOptImp)
(90,return;)
(91,tANI_U8 *)
(92,pHdr->sa)
(93,plainBody)
(94,sirConvertAuthFrame2Struct(pMac, pBody,\n\\n            frameLen, &rxAuthFrame)
(95,if (pRxAuthFrameBody->authAlgoNumber != eSIR_SHARED_KEY)
(96,eLIM_MLM_AUTH_RSP_TIMEOUT_STATE)
(97,challengeText)
(98,tANI_U8 *)
(99,pBody + 3)
(100,eSIR_MAC_UNSPEC_FAILURE_REASON)
(101,&authFrame)
(102,pRxAuthFrameBody->authStatusCode)
(103,authAlgoNumber)
(104,psessionEntry->dph.dphHashTable)
(105,limSendAuthMgmtFrame(\n\\n                                                    pMac, &authFrame,\n\\n                                                    pHdr->sa,\n\\n                                                    LIM_NO_WEP_IN_FC,psessionEntry)
(106,authFrame)
(107,if (NULL == pStaDs)
(108,pAuthNode = limAcquireFreePreAuthNode(pMac, &pMac->lim.gLimPreAuthTimerTable)
(109,challengeTextArray)
(110,authFrame.authStatusCode)
(111,"could not retrieve MaxNumPreAuth")
(112,vos_mem_copy((tANI_U8 *)
(113,NULL)
(114,authFrame.authAlgoNumber = eSIR_SHARED_KEY)
(115,"STA is initiating "\n\\n                    "Authentication after ACK lost...")
(116,limRestoreFromAuthState(pMac, eSIR_SME_INVALID_WEP_DEFAULT_KEY,\n\\n                                                              eSIR_MAC_UNSPEC_FAILURE_REASON,psessionEntry)
(117,&authFrame)
(118,WDA_GET_RX_MPDU_DATA(pRxPacketInfo)
(119,pAuthNode)
(120,limLog(pMac, LOG1,\n\\n               FL("Sessionid: %d System role : %d limMlmState: %d :Auth "\n\\n               "Frame Received: BSSID: "MAC_ADDRESS_STR " (RSSI %d)
(121,authFrame.authStatusCode)
(122,pMac->lim)
(123,if (pRxAuthFrameBody->authAlgoNumber !=\n\\n                    pMac->lim.gpLimMlmAuthReq->authType)
(124,authStatusCode)
(125,pMac)
(126,(tANI_U8 *)
(127,eSIR_MAC_CHALLENGE_FAILURE_STATUS)
(128,sa)
(129,limLog(pMac, LOGW,\n\\n           FL("Received Auth frame with type=%d seqnum=%d, status=%d (%d)
(130,tANI_U8 *)
(131,pRxAuthFrameBody)
(132,if (pAuthNode->mlmState == eLIM_MLM_AUTH_RSP_TIMEOUT_STATE)
(133,decryptResult = limDecryptAuthFrame(pMac, pKeyMapEntry->key,\n\\n                                                        pBody,\n\\n                                                        plainBody,\n\\n                                                        key_length,\n\\n                                                        (tANI_U16)
(134,pAuthNode = limAcquireFreePreAuthNode(pMac, &pMac->lim.gLimPreAuthTimerTable)
(135,sa)
(136,authFrame.authStatusCode =\n\\n                                        eSIR_MAC_UNSPEC_FAILURE_STATUS)
(137,pMac)
(138,(tANI_U8 *)
(139,rxAuthFrame)
(140,authFrame)
(141,pMac->lim.limDisassocDeauthCnfReq)
(142,pAuthNode->seqNo = ((pHdr->seqControl.seqNumHi << 4)
(143,authFrame)
(144,wlan_cfgGetStr(pMac, (tANI_U16)
(145,break;)
(146,authFrame.authTransactionSeqNumber)
(147,LOGE)
(148,authFrame.authStatusCode =\n\\n                    eSIR_MAC_CHALLENGE_FAILURE_STATUS)
(149,return;)
(150,psessionEntry)
(151,pRxAuthFrameBody)
(152,mlmAuthInd)
(153,psessionEntry->WEPKeyMaterial)
(154,authFrame.authAlgoNumber)
(155,authAlgoNumber)
(156,peerMacAddr)
(157,defaultAuthFailureTimeout)
(158,SIR_MAC_AUTH_FRAME_4)
(159,authFrame.authStatusCode)
(160,&assocId)
(161,if (wlan_cfgGetInt(pMac, WNI_CFG_WEP_DEFAULT_KEYID,\n\\n                                          &val)
(162,pRxAuthFrameBody->challengeText)
(163,pHdr)
(164,authTransactionSeqNumber)
(165,psessionEntry)
(166,pMac)
(167,authFrame.authAlgoNumber =\n\\n                        pRxAuthFrameBody->authAlgoNumber)
(168,FALSE)
(169,pHdr)
(170,pHdr->seqControl)
(171,break;)
(172,authStatusCode)
(173,!frameLen)
(174,seqNumHi)
(175,psessionEntry)
(176,pMac)
(177,tpSirMacAuthFrameBody)
(178,LIM_NO_WEP_IN_FC)
(179,authFrame.authStatusCode = eSIR_MAC_CHALLENGE_FAILURE_STATUS)
(180,limLog(pMac, LOGE, FL("Max number of "\n\\n                    "preauth context reached")
(181,pRxAuthFrameBody->authAlgoNumber)
(182,return;)
(183,if (pHdr->fc.wep)
(184,authTransactionSeqNumber)
(185,limSystemRole)
(186,pMac)
(187,sa)
(188,if(psessionEntry->limSystemRole == eLIM_AP_ROLE)
(189,psessionEntry->privacy)
(190,FL("lim Delete Station "\n\\n                        "Context (staId: %d, assocId: %d)
(191,(tpSirMacAuthFrameBody)
(192,privacy)
(193,psessionEntry)
(194,return;)
(195,if (pHdr->fc.retry == 0 || pAuthNode->seqNo != currSeqNo)
(196,pAuthNode)
(197,if (decryptResult == LIM_DECRYPT_ICV_FAIL)
(198,psessionEntry)
(199,FL("failed to convert Auth Frame to structure "\n\\n                               "or Auth is not valid ")
(200,return;)
(201,pAuthNode)
(202,pRxAuthFrameBody = &rxAuthFrame)
(203,authAlgoNumber)
(204,pHdr)
(205,pStaDs->staAddr)
(206,eSIR_SHARED_KEY)
(207,fSeen)
(208,pRxAuthFrameBody)
(209,MTRACE(macTrace(pMac, TRACE_CODE_MLM_STATE, psessionEntry->peSessionId, psessionEntry->limMlmState)
(210,pAuthNode)
(211,sa)
(212,limLog(pMac, LOGE,\n\\n                                   FL("received Auth frame with invalid "\n\\n                                   "challenge text IE")
(213,frameLen = WDA_GET_RX_PAYLOAD_LEN(pRxPacketInfo)
(214,pRxAuthFrameBody)
(215,authFrame.authStatusCode =\n\\n                    eSIR_MAC_CHALLENGE_FAILURE_STATUS)
(216,sa)
(217,pMac)
(218,authFrame)
(219,authFrame.authStatusCode)
(220,return;)
(221,((tpSirMacAuthFrameBody)
(222,assocId)
(223,pMac)
(224,limActivateAuthRspTimer(pMac, pAuthNode)
(225,(tANI_U16)
(226,pRxAuthFrameBody->authAlgoNumber)
(227,tANI_U32)
(228,pHdr->fc.retry == 0)
(229,dphGetHashEntry(pMac, assocId, &psessionEntry->dph.dphHashTable)
(230,pMac)
(231,pAuthNode->fTimerStarted)
(232,pRxAuthFrameBody)
(233,if(psessionEntry->limSystemRole == eLIM_AP_ROLE)
(234,pMac->lim.gpLimMlmAuthReq)
(235,sa)
(236,pHdr->fc.wep)
(237,)
(238,pRxAuthFrameBody->authAlgoNumber)
(239,authAlgoNumber)
(240,type)
(241,pMac->lim)
(242,authFrame.authStatusCode)
(243,limSearchPreAuthList(pMac,\n\\n                                                pHdr->sa)
(244,)
(245,tx_timer_change_context(&pAuthNode->timer, pAuthNode->authNodeIdx)
(246,pMac->lim.gpLimMlmAuthReq->authType)
(247,limAddPreAuthNode(pMac, pAuthNode)
(248,peerMacAddr)
(249,pMac->lim.gpLimMlmAuthReq)
(250,pMac)
(251,pKeyMapEntry)
(252,pHdr->sa)
(253,!isAuthValid(pMac, &rxAuthFrame,psessionEntry)
(254,authFrame)
(255,limAcquireFreePreAuthNode(pMac, &pMac->lim.gLimPreAuthTimerTable)
(256,((tpSirMacAuthFrameBody)
(257,seqControl)
(258,((tpSirMacAuthFrameBody)
(259,pAuthNode)
(260,authFrame)
(261,pMac)
(262,pAuthNode->challengeText)
(263,frameLen)
(264,sa)
(265,FL("could not retrieve Privacy option")
(266,authTransactionSeqNumber)
(267,pMlmDeauthReq &&\n\\n                        (vos_mem_compare((tANI_U8 *)
(268,tAniAuthType)
(269,((tpSirMacAuthFrameBody)
(270,4)
(271,(tANI_U8 *)
(272,authFrame)
(273,limSendAuthMgmtFrame(pMac, &authFrame,\n\\n                                 pHdr->sa,\n\\n                                 LIM_NO_WEP_IN_FC,psessionEntry)
(274,authFrame.authStatusCode =\n\\n                eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS)
(275,pMac)
(276,(tANI_U8 *)
(277,limSendAuthMgmtFrame(\n\\n                                            pMac, &authFrame,\n\\n                                            pHdr->sa,\n\\n                                            LIM_NO_WEP_IN_FC,psessionEntry)
(278,if (psessionEntry->limSystemRole == eLIM_STA_ROLE || psessionEntry->limSystemRole == eLIM_BT_AMP_STA_ROLE)
(279,limLog(pMac, LOGW, FL("=====> decryptResult == "\n\\n                        "LIM_DECRYPT_ICV_FAIL ...")
(280,pHdr->seqControl.seqNumHi << 4)
(281,pRxAuthFrameBody->authStatusCode)
(282,pAuthNode->fTimerStarted)
(283,pRxAuthFrameBody)
(284,case SIR_MAC_AUTH_FRAME_1:)
(285,pHdr->sa)
(286,return;)
(287,sizeof(tSirMacAddr)
(288,wlan_cfgGetStr(pMac, (tANI_U16)
(289,psessionEntry->limSystemRole)
(290,pHdr)
(291,limSystemRole)
(292,limPostSmeMessage(pMac,\n\\n                                      LIM_MLM_AUTH_IND,\n\\n                                      (tANI_U32 *)
(293,pMac)
(294,authFrame)
(295,tpSirMacAuthFrameBody)
(296,authFrame.authStatusCode =\n\\n                        eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS)
(297,)
(298,defaultKey)
(299,authFrame.length)
(300,"received Auth frame2 from peer in state %d, addr ")
(301,(pAuthNode->mlmState !=\n\\n                     eLIM_MLM_WT_AUTH_FRAME3_STATE)
(302,fc)
(303,"=======> eSIR_SHARED_KEY  ...")
(304,mlmAuthInd)
(305,NULL)
(306,WNI_CFG_WEP_DEFAULT_KEY_1 + keyId)
(307,pMac)
(308,authFrame)
(309,sa)
(310,pRxAuthFrameBody->authAlgoNumber)
(311,continue;)
(312,authFrame.authTransactionSeqNumber =\n\\n                            pRxAuthFrameBody->authTransactionSeqNumber + 1)
(313,limCurrentAuthType)
(314,sizeof(tSirMacAddr)
(315,pMac)
(316,authFrame.authAlgoNumber)
(317,pMac->lim.gLimNumPreAuthContexts)
(318,4)
(319,"=====> decryptResult == "\n\\n                        "LIM_DECRYPT_ICV_FAIL ...")
(320,authFrame.authTransactionSeqNumber)
(321,sa)
(322,tSirMacAddr)
(323,authNodeIdx)
(324,pMac)
(325,psessionEntry->dph)
(326,1)
(327,pRxAuthFrameBody->authTransactionSeqNumber)
(328,tANI_U16)
(329,pHdr)
(330,sa)
(331,authFrame.length = SIR_MAC_AUTH_CHALLENGE_LENGTH)
(332,authFrame)
(333,pAuthNode)
(334,pHdr)
(335,SIR_MAC_AUTH_FRAME_4)
(336,pMac->lim)
(337,(tANI_U8 *)
(338,pRxAuthFrameBody)
(339,authTransactionSeqNumber)
(340,authFrame)
(341,authFrame)
(342,LOGE)
(343,limSystemRole)
(344,( sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,\n\\n                         &rxAuthFrame)
(345,"could not retrieve Privacy option")
(346,psessionEntry->defaultAuthFailureTimeout)
(347,)
(348,pRxAuthFrameBody->authStatusCode)
(349,break;)
(350,psessionEntry)
(351,eSIR_SME_INVALID_WEP_DEFAULT_KEY)
(352,pAuthNode->fTimerStarted)
(353,mlmAuthInd.authType = (tAniAuthType)
(354,pMac)
(355,LOG1)
(356,authTransactionSeqNumber)
(357,pMac->lim.gpLimMlmAuthReq->peerMacAddr)
(358,if (frameLen < LIM_ENCR_AUTH_BODY_LEN)
(359,authFrame)
(360,psessionEntry)
(361,sirSwapU16ifNeeded((tANI_U16)
(362,0)
(363,(tpSirMacAuthFrameBody)
(364,0)
(365,authFrame)
(366,limProcessDeauthAckTimeout(pMac)
(367,authType)
(368,keyId)
(369,tpSirMacAuthFrameBody)
(370,authFrame)
(371,seqControl)
(372,mlmState)
(373,assocId)
(374,pStaDs)
(375,authFrame)
(376,return;)
(377,if ( ( sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,\n\\n                           &rxAuthFrame)
(378,pHdr->sa)
(379,1)
(380,keyId = (tANI_U8)
(381,encrAuthFrame)
(382,pMac)
(383,pHdr)
(384,pHdr->fc)
(385,authFrame.authTransactionSeqNumber)
(386,rxAuthFrame)
(387,sa)
(388,pAuthNode)
(389,authFrame)
(390,authFrame.authAlgoNumber)
(391,pRxAuthFrameBody->authStatusCode)
(392,seqNumLo)
(393,eSIR_SUCCESS)
(394,sa)
(395,&authFrame)
(396,authAlgoNumber)
(397,pAuthNode)
(398,FL("received Auth frame from a BC/MC address - ")
(399,limLog(pMac, LOGE, FL("STA is initiating "\n\\n                    "Authentication after ACK lost...")
(400,challengeText)
(401,psessionEntry)
(402,psessionEntry)
(403,key)
(404,authFrame)
(405,currSeqNo = 0)
(406,pMac->lim.gpLimMlmAuthReq)
(407,pMac->lim)
(408,authFrame)
(409,pBody)
(410,pMac)
(411,psessionEntry->limCurrentAuthType = eSIR_SHARED_KEY)
(412,limRestoreFromAuthState(pMac, eSIR_SME_AUTH_REFUSED,\n\\n                                              pRxAuthFrameBody->authStatusCode,psessionEntry)
(413,psessionEntry->limMlmState)
(414,wlan_cfgGetInt(pMac, WNI_CFG_PRIVACY_ENABLED,\n\\n                                  &val)
(415,SIR_MAC_AUTH_CHALLENGE_LENGTH)
(416,pHdr->sa)
(417,psessionEntry->limSystemRole)
(418,authFrame)
(419,if (!pKeyMapEntry->wepOn)
(420,if (psessionEntry->limMlmState != eLIM_MLM_WT_AUTH_FRAME4_STATE)
(421,pMac)
(422,authFrame.authAlgoNumber = eSIR_SHARED_KEY)
(423,authFrame.authAlgoNumber =\n\\n                            pRxAuthFrameBody->authAlgoNumber)
(424,WDA_GET_RX_MAC_HEADER(pRxPacketInfo)
(425,tANI_S8)
(426,wlan_cfgGetInt(pMac, WNI_CFG_WEP_DEFAULT_KEYID,\n\\n                                          &val)
(427,if (pRxAuthFrameBody->authAlgoNumber !=\n\\n                pMac->lim.gpLimMlmAuthReq->authType)
(428,plainBody)
(429,psessionEntry->limMlmState = eLIM_MLM_WT_AUTH_FRAME4_STATE)
(430,pRxAuthFrameBody)
(431,LOGE)
(432,fTimerStarted)
(433,tpSirMacAuthFrameBody)
(434,lim)
(435,eSIR_MAC_SUCCESS_STATUS)
(436,psessionEntry)
(437,limSendDeauthMgmtFrame( pMac, eSIR_MAC_MIC_FAILURE_REASON,\n\\n                                    pHdr->sa, psessionEntry, FALSE )
(438,)
(439,authTransactionSeqNumber)
(440,1)
(441,seqNo)
(442,if (pAuthNode == NULL)
(443,seqControl)
(444,psessionEntry->limSystemRole == eLIM_AP_ROLE)
(445,limLog(pMac, LOGP,\n\\n                                       FL("could not retrieve Default key")
(446,pAuthNode = limSearchPreAuthList(pMac,\n\\n                                                pHdr->sa)
(447,authFrame)
(448,keyId)
(449,pStaDs)
(450,SIR_MAC_AUTH_FRAME_4)
(451,key_length)
(452,&pMac->lim.gLimPreAuthTimerTable)
(453,limPrintMacAddr(pMac, pHdr->sa, LOG1)
(454,vos_mem_copy(pChallenge,\n\\n                                        (tANI_U8 *)
(455,pMac)
(456,pRxAuthFrameBody->authTransactionSeqNumber)
(457,authFrame)
(458,assocId = 0)
(459,authFrame)
(460,pMac)
(461,pMac)
(462,frameLen)
(463,pRxAuthFrameBody)
(464,eLIM_MLM_WT_AUTH_FRAME4_STATE)
(465,break;)
(466,)
(467,if (pMac->lim.gLimNumPreAuthContexts == maxNumPreAuth)
(468,authStatusCode)
(469,vos_mem_copy(defaultKey, pKey->key, pKey->keyLength)
(470,tANI_U8 *)
(471,authAlgoNumber)
(472,authStatusCode)
(473,authStatusCode)
(474,sa)
(475,pHdr->seqControl.seqNumHi)
(476,eSIR_SHARED_KEY)
(477,psessionEntry)
(478,lim)
(479,tANI_U8 *)
(480,LOGW)
(481,switch (pRxAuthFrameBody->authTransactionSeqNumber)
(482,FL("Max pre-auth nodes reached ")
(483,authAlgoNumber)
(484,sa)
(485,authFrame)
(486,fc)
(487,limLog(pMac, LOGP, FL("could not retrieve Privacy option")
(488,pAuthNode->authType)
(489,tpAniSirGlobal pMac)
(490,psessionEntry)
(491,decryptResult == LIM_DECRYPT_ICV_FAIL)
(492,rxAuthFrame)
(493,(tpSirMacAuthFrameBody)
(494,pMac)
(495,psessionEntry->dph)
(496,pAuthNode->fTimerStarted = 0)
(497,type)
(498,limPrintMacAddr(pMac, pHdr->sa, LOGP)
(499,authFrame.authAlgoNumber =\n\\n                                        pRxAuthFrameBody->authAlgoNumber)
(500,plainBody)
(501,psessionEntry->limMlmState)
(502,pRxAuthFrameBody->authAlgoNumber)
(503,limSendAuthMgmtFrame(pMac, &authFrame,\n\\n                                         pHdr->sa,\n\\n                                         LIM_NO_WEP_IN_FC,psessionEntry)
(504,if(pAuthNode->fTimerStarted)
(505,return;)
(506,1)
(507,pMac)
(508,((tpSirMacAuthFrameBody)
(509,(tANI_U8)
(510,rxAuthFrame)
(511,pAuthNode)
(512,authStatusCode)
(513,plainBody)
(514,authFrame)
(515,pMac)
(516,authFrame)
(517,eLIM_AUTH_RSP_TIMER)
(518,pAuthNode)
(519,gLimPreAuthTimerTable)
(520,gpLimMlmAuthReq)
(521,limPrintMacAddr(pMac, pHdr->sa, LOGE)
(522,cfgPrivacyOptImp)
(523,psessionEntry->dph.dphHashTable.size)
(524,pMac)
(525,if (psessionEntry->limMlmState != eLIM_MLM_WT_AUTH_FRAME2_STATE)
(526,pRxAuthFrameBody->authAlgoNumber)
(527,authFrame.authAlgoNumber =\n\\n                            pRxAuthFrameBody->authAlgoNumber)
(528,return;)
(529,authFrame.authAlgoNumber)
(530,authStatusCode)
(531,pRxAuthFrameBody->authAlgoNumber)
(532,authStatusCode)
(533,)
(534,sessionId)
(535,pRxAuthFrameBody)
(536,NULL)
(537,eSIR_MAC_SUCCESS_STATUS)
(538,authStatusCode)
(539,!vos_mem_compare((tANI_U8 *)
(540,pMlmDeauthReq)
(541,authType)
(542,authAlgoNumber)
(543,authFrame.authTransactionSeqNumber)
(544,limSystemRole)
(545,limRestoreFromAuthState(pMac, eSIR_SME_NO_KEY_MAPPING_KEY_FOR_PEER,\n\\n                                                              eSIR_MAC_UNSPEC_FAILURE_REASON,psessionEntry)
(546,LIM_NO_WEP_IN_FC)
(547,authFrame)
(548,pMac)
(549,wlan_cfgGetInt(pMac, WNI_CFG_WEP_DEFAULT_KEYID,\n\\n                                          &val)
(550,assocId)
(551,)
(552,!pKeyMapEntry->wepOn)
(553,((tpSirMacAuthFrameBody)
(554,tpSirMacAuthFrameBody)
(555,pAuthNode)
(556,LOGE)
(557,if (tx_timer_change_context(&pAuthNode->timer, pAuthNode->authNodeIdx)
(558,plainBody)
(559,tAniAuthType)
(560,pHdr->seqControl.seqNumHi)
(561,pRxAuthFrameBody->authTransactionSeqNumber + 1)
(562,encrAuthFrame)
(563,authFrame)
(564,authFrame.authStatusCode =\n\\n                    eSIR_MAC_CHALLENGE_FAILURE_STATUS)
(565,SIR_MAC_AUTH_FRAME_4)
(566,tpSirMacAuthFrameBody)
(567,pMac)
(568,eLIM_AUTH_RSP_TIMER)
(569,((tpSirMacAuthFrameBody)
(570,LOGW)
(571,pAuthNode)
(572,"Restore default failure timeout")
(573,pAuthNode->fSeen)
(574,limDeletePreAuthNode(pMac,\n\\n                                             pHdr->sa)
(575,(pHdr->seqControl.seqNumHi << 4)
(576,pAuthNode)
(577,isAuthValid(pMac, &rxAuthFrame,psessionEntry)
(578,return;)
(579,tANI_U8)
(580,return;)
(581,eSIR_SHARED_KEY)
(582,&pMlmDeauthReq->peerMacAddr)
(583,limDeactivateAndChangePerStaIdTimer(pMac,\n\\n                                                        eLIM_AUTH_RSP_TIMER,\n\\n                                                        pAuthNode->authNodeIdx)
(584,pMac)
(585,size)
(586,pKeyMapEntry)
(587,(tAniAuthType)
(588,LIM_NO_WEP_IN_FC)
(589,eSIR_SUCCESS)
(590,limSystemRole)
(591,pMac)
(592,challengeText)
(593,)
(594,pHdr->seqControl)
(595,pAuthNode == NULL)
(596,mlmState)
(597,psessionEntry->privacy)
(598,authTransactionSeqNumber)
(599,pAuthNode->authType =\n\\n                            (tAniAuthType)
(600,pHdr)
(601,cfgPrivacyOptImp)
(602,psessionEntry)
(603,pRxAuthFrameBody->authAlgoNumber)
(604,mlmAuthInd.sessionId = psessionEntry->smeSessionId)
(605,)
(606,authFrame)
(607,pHdr->sa)
(608,psessionEntry)
(609,pHdr = WDA_GET_RX_MAC_HEADER(pRxPacketInfo)
(610,pMac->lim.limDisassocDeauthCnfReq.pMlmDisassocReq)
(611,pAuthNode)
(612,authFrame.authAlgoNumber = eSIR_SHARED_KEY)
(613,FL("=======> eSIR_SHARED_KEY  ...")
(614,pAuthNode->seqNo)
(615,authFrame.authAlgoNumber)
(616,psessionEntry)
(617,pAuthNode == NULL)
(618,break;)
(619,psessionEntry)
(620,((tpSirMacAuthFrameBody)
(621,psessionEntry->limSystemRole == eLIM_BT_AMP_AP_ROLE)
(622,eSIR_MAC_CHALLENGE_FAILURE_STATUS)
(623,abs((tANI_S8)
(624,val)
(625,authType)
(626,FL("Sessionid: %d System role : %d limMlmState: %d :Auth "\n\\n               "Frame Received: BSSID: "MAC_ADDRESS_STR " (RSSI %d)
(627,authFrame.authAlgoNumber =\n\\n                        pRxAuthFrameBody->authAlgoNumber)
(628,fSeen)
(629,pAuthNode)
(630,pHdr->seqControl.seqNumHi)
(631,)
(632,authStatusCode)
(633,limEncryptAuthFrame(pMac, keyId,\n\\n                                                    defaultKey,\n\\n                                                    plainBody,\n\\n                                                    encrAuthFrame,key_length)
(634,SIR_MAC_AUTH_FRAME_4)
(635,seqControl)
(636,authFrame.authTransactionSeqNumber =\n\\n                            pRxAuthFrameBody->authTransactionSeqNumber + 1)
(637,tpSirMacAuthFrameBody)
(638,"could not retrieve Privacy option")
(639,psessionEntry)
(640,pHdr->sa)
(641,pAuthNode)
(642,pKeyMapEntry)
(643,)
(644,authFrame.authTransactionSeqNumber =\n\\n                SIR_MAC_AUTH_FRAME_4)
(645,pHdr->sa)
(646,tANI_U8)
(647,authAlgoNumber)
(648,psessionEntry->smeSessionId)
(649,"Not enough size [%d] to decrypt received Auth frame")
(650,authFrame)
(651,pStaDs)
(652,WDA_GET_RX_RSSI_DB(pRxPacketInfo)
(653,)
(654,tpSirMacAuthFrameBody)
(655,authStatusCode)
(656,)
(657,authTransactionSeqNumber)
(658,pAuthNode->seqNo != currSeqNo)
(659,authType)
(660,pMlmDisassocReq &&\n\\n                        (vos_mem_compare((tANI_U8 *)
(661,authFrame)
(662,authAlgoNumber)
(663,pMac)
(664,val)
(665,gpLimMlmAuthReq)
(666,psessionEntry)
(667,pHdr)
(668,limMlmState)
(669,FALSE)
(670,authFrame.authTransactionSeqNumber =\n\\n                        SIR_MAC_AUTH_FRAME_4)
(671,FL("received Authentication frame with no body from ")
(672,authFrame.type   = SIR_MAC_CHALLENGE_TEXT_EID)
(673,LIM_WEP_IN_FC)
(674,pHdr->sa)
(675,psessionEntry)
(676,LIM_NO_WEP_IN_FC)
(677,isAuthValid(pMac, &rxAuthFrame, psessionEntry)
(678,FL("failed to convert Auth Frame to structure or Auth is "\n\\n                   "not valid ")
(679,authAlgoNumber)
(680,peerMacAddr)
(681,pBody)
(682,pHdr)
(683,pMac)
(684,mlmAuthInd)
(685,return;)
(686,limLog(pMac, LOGP,\n\\n                           FL("could not retrieve Default key")
(687,&authFrame)
(688,pRxAuthFrameBody)
(689,assocId)
(690,val)
(691,pMac->lim.gLimPreAuthTimerTable)
(692,pMac)
(693,pHdr->seqControl)
(694,pHdr)
(695,psessionEntry)
(696,authFrame.authTransactionSeqNumber =\n\\n                        SIR_MAC_AUTH_FRAME_4)
(697,psessionEntry)
(698,psessionEntry)
(699,keyId)
(700,pMac)
(701,pKey)
(702,1)
(703,tANI_U16)
(704,pRxAuthFrameBody)
(705,pBody)
(706,psessionEntry->WEPKeyMaterial)
(707,LIM_NO_WEP_IN_FC)
(708,psessionEntry->limSystemRole)
(709,default:)
(710,pHdr)
(711,pRxAuthFrameBody->challengeText)
(712,pMac)
(713,limSendAuthMgmtFrame(pMac, &authFrame,\n\\n                                     pHdr->sa,\n\\n                                     LIM_NO_WEP_IN_FC,psessionEntry)
(714,authFrame)
(715,)
(716,(tANI_U16)
(717,sizeof(tSirMacAddr)
(718,eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS)
(719,if (pRxAuthFrameBody->authStatusCode != eSIR_MAC_SUCCESS_STATUS)
(720,psessionEntry)
(721,&pStaDs->staAddr)
(722,pHdr)
(723,pMac)
(724,FL("=====> decryptResult == "\n\\n                        "LIM_DECRYPT_ICV_FAIL ...")
(725,val)
(726,defaultAuthFailureTimeout)
(727,4)
(728,pRxAuthFrameBody)
(729,return;)
(730,pAuthNode->mlmState)
(731,LOGP)
(732,pHdr->seqControl.seqNumHi << 4)
(733,LOGW)
(734,pRxAuthFrameBody)
(735,limDisassocDeauthCnfReq)
(736,authFrame.authTransactionSeqNumber =\n\\n                SIR_MAC_AUTH_FRAME_4)
(737,authFrame.authTransactionSeqNumber)
(738,pMlmDeauthReq)
(739,psessionEntry)
(740,pRxAuthFrameBody)
(741,&rxAuthFrame)
(742,pRxAuthFrameBody->authTransactionSeqNumber + 1)
(743,LIM_MLM_AUTH_IND)
(744,privacy)
(745,break;)
(746,pStaDs)
(747,sizeof(tSirMacAddr)
(748,pMac)
(749,((tpSirMacAuthFrameBody)
(750,limLog(pMac, LOGP,\n\\n                               FL("could not retrieve Privacy option")
(751,LOGE)
(752,SIR_MAC_AUTH_FRAME_4)
(753,keyLength)
(754,limMlmState)
(755,sizeof(tSirMacAddr)
(756,psessionEntry)
(757,(tAniAuthType)
(758,authFrame.authAlgoNumber =\n\\n                pRxAuthFrameBody->authAlgoNumber)
(759,authFrame.authStatusCode)
(760,LOGW)
(761,tANI_U8 *)
(762,gpLimMlmAuthReq)
(763,plainBody)
(764,pMac)
(765,psessionEntry->limSystemRole)
(766,1)
(767,psessionEntry)
(768,eSIR_SUCCESS)
(769,1)
(770,tANI_U8 *)
(771,authFrame)
(772,)
(773,)
(774,"Unable to chg context auth response timer for peer ")
(775,authFrame.authTransactionSeqNumber =\n\\n                        SIR_MAC_AUTH_FRAME_4)
(776,)
(777,pMac)
(778,&maxNumPreAuth)
(779,pRxAuthFrameBody->authTransactionSeqNumber + 1)
(780,limLog(pMac, LOGW,\n\\n                                   FL("Max pre-auth nodes reached ")
(781,pAuthNode->fSeen = 0)
(782,return;)
(783,wepOn)
(784,pAuthNode)
(785,isAuthValid(pMac, &rxAuthFrame,psessionEntry)
(786,pKey)
(787,pAuthNode)
(788,psessionEntry)
(789,pAuthNode->fTimerStarted)
(790,pMac->lim.gpLimMlmAuthReq->peerMacAddr)
(791,vos_mem_compare((tANI_U8 *)
(792,eSIR_SHARED_KEY)
(793,pBody)
(794,psessionEntry->limMlmState)
(795,assocId < psessionEntry->dph.dphHashTable.size)
(796,pRxAuthFrameBody->authAlgoNumber)
(797,pHdr->sa)
(798,keyId)
(799,assocId)
(800,)
(801,eSIR_SME_NO_KEY_MAPPING_KEY_FOR_PEER)
(802,pChallenge = pAuthNode->challengeText)
(803,decryptResult)
(804,vos_mem_compare((tANI_U8 *)
(805,&authFrame)
(806,0)
(807,((tpSirMacAuthFrameBody)
(808,psessionEntry->limSystemRole == eLIM_AP_ROLE)
(809,pRxAuthFrameBody->authAlgoNumber)
(810,((tpSirMacAuthFrameBody)
(811,psessionEntry->dph.dphHashTable)
(812,(tANI_U32)
(813,pAuthNode->mlmState)
(814,eSIR_MAC_CHALLENGE_FAILURE_STATUS)
(815,limSendAuthMgmtFrame(pMac, &authFrame,\n\\n                                                     pHdr->sa,\n\\n                                                     LIM_NO_WEP_IN_FC,psessionEntry)
(816,authFrame.authAlgoNumber)
(817,vos_mem_copy((tANI_U8 *)
(818,pAuthNode)
(819,pHdr->sa)
(820,!vos_mem_compare((tANI_U8 *)
(821,pMac->lim)
(822,psessionEntry)
(823,pAuthNode = limAcquireFreePreAuthNode(pMac, &pMac->lim.gLimPreAuthTimerTable)
(824,*(pBody + 3)
(825,if (wlan_cfgGetInt(pMac, WNI_CFG_MAX_NUM_PRE_AUTH,\n\\n                          (tANI_U32 *)
(826,LIM_NO_WEP_IN_FC)
(827,wlan_cfgGetStr(pMac, (tANI_U16)
(828,(tpSirMacAuthFrameBody)
(829,NULL)
(830,pMac)
(831,tANI_U8 *)
(832,psessionEntry)
(833,authFrame)
(834,psessionEntry->defaultAuthFailureTimeout)
(835,"Received Auth frame with type=%d seqnum=%d, status=%d (%d)
(836,authStatusCode)
(837,pHdr)
(838,authFrame.authAlgoNumber =\n\\n                                pRxAuthFrameBody->authAlgoNumber)
(839,limAcquireFreePreAuthNode(pMac, &pMac->lim.gLimPreAuthTimerTable)
(840,authTransactionSeqNumber)
(841,authAlgoNumber)
(842,)
(843,SIR_MAC_WEP_IV_LENGTH)
(844,psessionEntry)
(845,val)
(846,pHdr)
(847,if (!frameLen)
(848,pKeyMapEntry = limLookUpKeyMappings(\n\\n                                                           pHdr->sa)
(849,pHdr->sa)
(850,return;)
(851,pHdr->sa)
(852,sa)
(853,pMac)
(854,frameLen < LIM_ENCR_AUTH_BODY_LEN)
(855,pRxAuthFrameBody->type)
(856,vos_mem_compare(pRxAuthFrameBody->challengeText,\n\\n                                    pAuthNode->challengeText,\n\\n                                    SIR_MAC_AUTH_CHALLENGE_LENGTH)
(857,pKey =  &psessionEntry->WEPKeyMaterial[keyId].key[0])
(858,eSIR_SHARED_KEY)
(859,FL("STA is initiating "\n\\n                    "Authentication after ACK lost...")
(860,psessionEntry)
(861,pHdr)
(862,lim)
(863,pKeyMapEntry->key == NULL)
(864,pRxAuthFrameBody->authAlgoNumber)
(865,"Sessionid: %d System role : %d limMlmState: %d :Auth "\n\\n               "Frame Received: BSSID: "MAC_ADDRESS_STR " (RSSI %d)
(866,pMac)
(867,SIR_MAC_AUTH_CHALLENGE_LENGTH)
(868,authTransactionSeqNumber)
(869,(tpSirMacAuthFrameBody)
(870,LOGW)
(871,pMac)
(872,pAuthNode)
(873,eLIM_BT_AMP_AP_ROLE)
(874,pMac->lim.gpLimMlmAuthReq->authType)
(875,if (vos_mem_compare((tANI_U8 *)
(876,authFrame)
(877,)
(878,)
(879,maxNumPreAuth)
(880,psessionEntry->limSystemRole)
(881,authFrame.authStatusCode =\n\\n                            eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS)
(882,pAuthNode->fSeen)
(883,eLIM_BT_AMP_STA_ROLE)
(884,gLimNumPreAuthContexts)
(885,authAlgoNumber)
(886,authFrame)
(887,return;)
(888,eSIR_FALSE)
(889,((tpSirMacAuthFrameBody)
(890,LOGE)
(891,sizeof(challengeTextArray)
(892,tANI_U8 *)
(893,authStatusCode)
(894,1)
(895,psessionEntry->limSystemRole == eLIM_AP_ROLE)
(896,pRxAuthFrameBody->authStatusCode)
(897,pHdr)
(898,pMac)
(899,eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS)
(900,authAlgoNumber)
(901,authFrame.authStatusCode)
(902,"lim Delete Station "\n\\n                        "Context (staId: %d, assocId: %d)
(903,pMac)
(904,sizeof(tSirMacAddr)
(905,pHdr)
(906,pMac->lim.gLimPreAuthTimerTable)
(907,authTransactionSeqNumber)
(908,eSIR_MAC_UNSPEC_FAILURE_STATUS)
(909,authAlgoNumber)
(910,if (pAuthNode == NULL)
(911,(tANI_U8 *)
(912,pRxAuthFrameBody->authAlgoNumber ==\n\\n                    eSIR_OPEN_SYSTEM)
(913,pMac)
(914,defaultKey)
(915,pKeyMapEntry->key)
(916,eSIR_SUCCESS)
(917,authFrame)
(918,pHdr->sa)
(919,pRxAuthFrameBody->authTransactionSeqNumber + 1)
(920,pHdr)
(921,SIR_MAC_AUTH_CHALLENGE_LENGTH)
(922,((tpSirMacAuthFrameBody)
(923,pAuthNode->fTimerStarted = 0)
(924,pHdr->seqControl.seqNumHi << 4)
(925,pRxAuthFrameBody)
(926,pMlmDisassocReq->peerMacAddr)
(927,FL("Restore default failure timeout")
(928,LOGE)
(929,"Max pre-auth nodes reached ")
(930,"failed to convert Auth Frame to structure or Auth is "\n\\n                   "not valid ")
(931,authFrame.authTransactionSeqNumber)
(932,plainBody)
(933,gpLimMlmAuthReq)
(934,isConnected = eSIR_TRUE)
(935,limIsAuthAlgoSupported(\n\\n                                      pMac,\n\\n                                      (tAniAuthType)
(936,tANI_U8 *)
(937,psessionEntry->limMlmState =\n\\n                                eLIM_MLM_WT_AUTH_FRAME4_STATE)
(938,authAlgoNumber)
(939,pMac)
(940,eSIR_MAC_UNSPEC_FAILURE_REASON)
(941,pMac)
(942,eSIR_SUCCESS)
(943,pMac)
(944,authAlgoNumber)
(945,pMlmDisassocReq)
(946,peSessionId)
(947,eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS)
(948,sizeof(tSirMacAddr)
(949,break;)
(950,pChallenge)
(951,pMac)
(952,FL("received Auth frame with invalid "\n\\n                                   "challenge text IE")
(953,pAuthNode)
(954,limSendDeauthMgmtFrame(pMac,\n\\n                               eSIR_MAC_UNSPEC_FAILURE_REASON, (tANI_U8 *)
(955,return;)
(956,pRxAuthFrameBody)
(957,authFrame)
(958,eSIR_MAC_AUTH_RSP_TIMEOUT_STATUS)
(959,pHdr->sa)
(960,tANI_U16)
(961,gLimPreAuthTimerTable)
(962,LOGE)
(963,sa)
(964,pHdr->sa)
(965,authFrame.authTransactionSeqNumber =\n\\n                pRxAuthFrameBody->authTransactionSeqNumber + 1)
(966,break;)
(967,pAuthNode)
(968,if (pStaDs->valid)
(969,authFrame.authAlgoNumber)
(970,mlmAuthInd.authType)
(971,authStatusCode)
(972,)
(973,limSearchPreAuthList(pMac, pHdr->sa)
(974,(pHdr->seqControl.seqNumHi << 4)
(975,)
(976,sessionId)
(977,limLog(pMac, LOGE,\n\\n               FL("received Authentication frame with no body from ")
(978,vos_mem_copy(defaultKey, pKey->key, pKey->keyLength)
(979,LOGE)
(980,pHdr->seqControl)
(981,valid)
(982,tSirMacAddr)
(983,(tANI_U8)
(984,limLog(pMac, LOGW, FL("=======> eSIR_OPEN_SYSTEM  ...")
(985,val = pKey->keyLength)
(986,SIR_MAC_AUTH_CHALLENGE_LENGTH)
(987,(tANI_U8)
(988,)
(989,FL("Max pre-auth nodes reached ")
(990,pRxAuthFrameBody->authAlgoNumber)
(991,(tANI_U8 *)
(992,return;)
(993,psessionEntry)
(994,assocId++)
(995,pHdr->sa)
(996,authFrame.authStatusCode = eSIR_MAC_SUCCESS_STATUS)
(997,FL("=======> eSIR_OPEN_SYSTEM  ...")
(998,encrAuthFrame)
(999,(tANI_U8 *)
(1000,pMac)
(1001,pAuthNode)
(1002,eSIR_SHARED_KEY)
(1003,pMac)
(1004,vos_mem_copy((tANI_U8 *)
(1005,authFrame.authStatusCode)
(1006,pAuthNode->seqNo = ((pHdr->seqControl.seqNumHi << 4)
(1007,val = SIR_MAC_KEY_LENGTH)
(1008,tANI_U8 *)
(1009,wep)
(1010,key_length)
(1011,tAniAuthType)
(1012,&authFrame)
(1013,key)
(1014,pMac)
(1015,psessionEntry->limSystemRole)
(1016,LIM_NO_WEP_IN_FC)
(1017,limDeletePreAuthNode(pMac,\n\\n                                         pHdr->sa)
(1018,FL("Challenge text "\n\\n                               "preparation failed in limProcessAuthFrame")
(1019,&psessionEntry->dph.dphHashTable)
(1020,authTransactionSeqNumber)
(1021,pHdr->sa)
(1022,pHdr)
(1023,limSendAuthMgmtFrame(pMac, &authFrame,\n\\n                                     pHdr->sa,\n\\n                                     LIM_NO_WEP_IN_FC,psessionEntry)
(1024,vos_mem_compare((tANI_U8 *)
(1025,keyId = (*(pBody + 3)
(1026,sa)
(1027,pAuthNode->fTimerStarted)
(1028,pHdr->seqControl.seqNumHi)
(1029,&authFrame)
(1030,pHdr->seqControl)
(1031,ccmCfgSetInt(pMac,WNI_CFG_AUTHENTICATE_FAILURE_TIMEOUT ,\n\\n                          psessionEntry->defaultAuthFailureTimeout, NULL, eANI_BOOLEAN_FALSE)
(1032,LOGE)
(1033,LIM_NO_WEP_IN_FC)
(1034,eSIR_MAC_AUTH_ALGO_NOT_SUPPORTED_STATUS)
(1035,mlmAuthInd.sessionId)
(1036,authFrame.authAlgoNumber = eSIR_SHARED_KEY)
(1037,limLog(pMac, LOGW,\n\\n                                       FL("Max pre-auth nodes reached ")
(1038,authFrame)
(1039,LIM_NO_WEP_IN_FC)
(1040,limSendAuthMgmtFrame(pMac, &authFrame,\n\\n                                         pHdr->sa,\n\\n                                         LIM_NO_WEP_IN_FC,psessionEntry)
(1041,pMac)
(1042,authFrame)
(1043,pStaDs)
(1044,sizeof(tSirMacAddr)
(1045,if (limIsGroupAddr(pHdr->sa)
(1046,pAuthNode->seqNo)
(1047,psessionEntry->limMlmState)
(1048,)
(1049,authFrame.authTransactionSeqNumber =\n\\n                    SIR_MAC_AUTH_FRAME_4)
(1050,limPrintMacAddr(pMac, pHdr->sa, LOGW)
(1051,sa)
(1052,pMac)
(1053,pRxAuthFrameBody->authAlgoNumber)
(1054,&val)
(1055,eSIR_SME_AUTH_REFUSED)
(1056,authFrame)
(1057,NULL)
(1058,MTRACE(macTrace(pMac, TRACE_CODE_MLM_STATE, psessionEntry->peSessionId, psessionEntry->limMlmState)
(1059,authFrame.authAlgoNumber =\n\\n                pRxAuthFrameBody->authAlgoNumber)
(1060,pStaDs)
(1061,authAlgoNumber)
(1062,pRxAuthFrameBody->authAlgoNumber)
(1063,authFrame)
(1064,pRxAuthFrameBody->authTransactionSeqNumber + 1)
(1065,4)
(1066,pKeyMapEntry)
(1067,pStaDs)
(1068,frameLen)
(1069,return;)
(1070,SIR_MAC_KEY_LENGTH)
(1071,authFrame)
(1072,)
(1073,authAlgoNumber)
(1074,key_length)
(1075,vos_mem_copy((tANI_U8 *)
(1076,pRxAuthFrameBody->authStatusCode ==\n\\n                eSIR_MAC_SUCCESS_STATUS)
(1077,authStatusCode)
(1078,FL("could not retrieve Privacy option")
(1079,LOGP)
(1080,pKey)
(1081,&authFrame)
(1082,)
(1083,pAuthNode->authType = pMac->lim.gpLimMlmAuthReq->authType)
(1084,SIR_MAC_AUTH_FRAME_4)
(1085,pChallenge)
(1086,eLIM_AP_ROLE)
(1087,pMac)
(1088,(tpSirMacAuthFrameBody)
(1089,sa)
(1090,( sirConvertAuthFrame2Struct(pMac, plainBody, frameLen-8,\n\\n                           &rxAuthFrame)
(1091,LIM_NO_WEP_IN_FC)
(1092,authFrame)
(1093,break;)
(1094,limRestoreFromAuthState(pMac, eSIR_SME_SUCCESS,\n\\n                                            pRxAuthFrameBody->authStatusCode,psessionEntry)
(1095,((tpSirMacAuthFrameBody)
(1096,authFrame)
(1097,pAuthNode->seqNo)
(1098,psessionEntry)
(1099,pMac)
(1100,pMac->lim)
(1101,eSIR_MAC_AUTH_FRAME_OUT_OF_SEQ_STATUS)
(1102,pMac)
(1103,pHdr)
(1104,val)
(1105,pRxPacketInfo)
(1106,pKeyMapEntry = limLookUpKeyMappings(pHdr->sa)
(1107,eLIM_AP_ROLE)
(1108,pMac)
(1109,pHdr->sa)
(1110,pRxAuthFrameBody)
(1111,tANI_U16)
(1112,psessionEntry)
(1113,sizeof(tSirMacAddr)
(1114,authAlgoNumber)
(1115,eSIR_SME_SUCCESS)
(1116,authFrame.authTransactionSeqNumber)
(1117,pRxAuthFrameBody)
(1118,authFrame.authStatusCode)
(1119,psessionEntry)
(1120,if (!cfgPrivacyOptImp)
(1121,authFrame)
(1122,&pMac->lim.gpLimMlmAuthReq->peerMacAddr)
(1123,LOGE)
(1124,)
(1125,pHdr->sa)
(1126,seqNo)
(1127,(tpSirMacAuthFrameBody)
(1128,pRxAuthFrameBody->authAlgoNumber)
(1129,pAuthNode = limSearchPreAuthList(pMac, pHdr->sa)
(1130,pRxAuthFrameBody->authTransactionSeqNumber)
(1131,limSystemRole)
(1132,pRxAuthFrameBody->authAlgoNumber != eSIR_SHARED_KEY)
(1133,LOGE)
(1134,encrAuthFrame)
(1135,plainBody)
(1136,assocId = 0)
(1137,limSendAuthMgmtFrame(pMac, &authFrame,\n\\n                                 pHdr->sa,\n\\n                                 LIM_NO_WEP_IN_FC,psessionEntry)
(1138,sa)
(1139,pRxAuthFrameBody)
(1140,frameLen)
(1141,pRxAuthFrameBody)
(1142,NULL)
(1143,key_length)
(1144,pHdr)
(1145,limLog(pMac, LOGE,FL("Challenge text "\n\\n                               "preparation failed in limProcessAuthFrame")
(1146,pHdr->seqControl.seqNumLo)
(1147,psessionEntry)
(1148,pMac)
(1149,authAlgoNumber)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^