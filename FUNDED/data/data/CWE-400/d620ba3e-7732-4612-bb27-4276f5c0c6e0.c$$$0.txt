-----label-----
0
-----code-----
static int write_ref_sha1(struct ref_lock *lock,
	const unsigned char *sha1, const char *logmsg)
{
	static char term = '\n';
	struct object *o;

	o = parse_object(sha1);
	if (!o) {
		error("Trying to write ref %s with nonexistent object %s",
			lock->ref_name, sha1_to_hex(sha1));
		unlock_ref(lock);
		errno = EINVAL;
		return -1;
	}
	if (o->type != OBJ_COMMIT && is_branch(lock->ref_name)) {
		error("Trying to write non-commit object %s to branch %s",
			sha1_to_hex(sha1), lock->ref_name);
		unlock_ref(lock);
		errno = EINVAL;
		return -1;
	}
	if (write_in_full(lock->lock_fd, sha1_to_hex(sha1), 40) != 40 ||
	    write_in_full(lock->lock_fd, &term, 1) != 1 ||
	    close_ref(lock) < 0) {
		int save_errno = errno;
		error("Couldn't write %s", lock->lk->filename.buf);
		unlock_ref(lock);
		errno = save_errno;
		return -1;
	}
	clear_loose_ref_cache(&ref_cache);
	if (log_ref_write(lock->ref_name, lock->old_sha1, sha1, logmsg) < 0 ||
	    (strcmp(lock->ref_name, lock->orig_ref_name) &&
	     log_ref_write(lock->orig_ref_name, lock->old_sha1, sha1, logmsg) < 0)) {
		unlock_ref(lock);
		return -1;
	}
	if (strcmp(lock->orig_ref_name, "HEAD") != 0) {
		/*
		 * Special hack: If a branch is updated directly and HEAD
		 * points to it (may happen on the remote side of a push
		 * for example) then logically the HEAD reflog should be
		 * updated too.
		 * A generic solution implies reverse symref information,
		 * but finding all symrefs pointing to the given branch
		 * would be rather costly for this rare event (the direct
		 * update of a branch) to be worth it.  So let's cheat and
		 * check with HEAD only which should cover 99% of all usage
		 * scenarios (even 100% of the default ones).
		 */
		unsigned char head_sha1[20];
		int head_flag;
		const char *head_ref;
		head_ref = resolve_ref_unsafe("HEAD", RESOLVE_REF_READING,
					      head_sha1, &head_flag);
		if (head_ref && (head_flag & REF_ISSYMREF) &&
		    !strcmp(head_ref, lock->ref_name))
			log_ref_write("HEAD", lock->old_sha1, sha1, logmsg);
	}
	if (commit_ref(lock)) {
		error("Couldn't set %s", lock->ref_name);
		unlock_ref(lock);
		return -1;
	}
	unlock_ref(lock);
	return 0;
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
3,7
5,6
5,7
6,7
8,9
8,10
11,12
11,13
13,14
13,15
16,17
16,18
18,19
18,20
21,22
21,23
21,24
21,25
21,26
21,27
21,28
21,29
21,30
21,31
21,32
21,33
22,23
23,24
23,25
25,26
25,27
27,28
29,30
30,31
30,32
31,32
33,34
33,35
36,37
37,38
37,39
38,39
40,41
40,42
41,42
43,44
45,46
45,47
46,47
47,48
49,50
49,51
49,52
49,53
50,51
51,52
51,53
51,54
51,55
52,53
55,56
55,57
56,57
59,60
59,61
60,61
62,63
64,65
65,66
65,67
66,67
68,69
70,71
71,72
71,73
72,73
74,75
76,77
77,78
79,80
79,81
80,81
80,82
81,82
81,83
82,83
82,84
83,84
86,87
88,89
88,90
89,90
91,92
91,93
92,93
95,96
95,97
95,98
95,99
96,97
97,98
97,99
97,100
97,101
98,99
101,102
101,103
102,103
104,105
106,107
106,108
107,108
110,111
111,112
111,113
112,113
114,115
116,117
117,118
117,119
118,119
120,121
122,123
123,124
125,126
125,127
126,127
126,128
127,128
127,129
128,129
128,130
129,130
129,131
129,132
129,133
130,131
132,133
132,134
133,134
136,137
136,138
137,138
139,140
143,144
143,145
144,145
144,146
144,147
144,148
145,146
147,148
147,149
148,149
151,152
152,153
156,157
156,158
157,158
157,159
158,159
160,161
163,164
163,165
163,166
163,167
163,168
164,165
165,166
165,167
167,168
167,169
169,170
170,171
172,173
173,174
173,175
173,176
174,175
177,178
177,179
178,179
178,180
179,180
179,181
180,181
185,186
186,187
186,188
187,188
189,190
191,192
192,193
192,194
193,194
195,196
197,198
198,199
200,201
201,202
201,203
202,203
204,205
205,206
205,207
208,209
208,210
209,210
209,211
210,211
210,212
211,212
211,213
211,214
211,215
211,216
212,213
214,215
214,216
215,216
218,219
218,220
219,220
222,223
224,225
227,228
228,229
228,230
229,230
229,231
229,232
230,231
232,233
232,234
233,234
236,237
236,238
237,238
240,241
240,242
241,242
241,243
241,244
241,245
241,246
242,243
244,245
244,246
245,246
248,249
248,250
249,250
252,253
254,255
257,258
257,259
258,259
259,260
259,261
260,261
262,263
264,265
265,266
267,268
267,269
268,269
268,270
269,270
269,271
269,272
270,271
272,273
272,274
273,274
278,279
278,280
278,281
278,282
278,283
279,280
280,281
280,282
282,283
282,284
284,285
286,287
287,288
287,289
289,290
291,292
292,293
292,294
294,295
294,296
297,298
298,299
298,300
299,300
301,302
301,303
301,304
301,305
301,306
302,303
305,306
307,308
309,310
310,311
312,313
312,314
313,314
313,315
314,315
314,316
315,316
317,318
318,319
318,320
319,320
321,322
323,324
324,325
324,326
324,327
325,326
327,328
329,330
329,331
330,331
333,334
334,335
334,336
334,337
334,338
334,339
335,336
338,339
338,340
339,340
342,343
344,345
346,347
346,348
347,348
347,349
348,349
350,351
352,353
352,354
352,355
353,354
354,355
354,356
354,357
355,356
358,359
358,360
359,360
362,363
363,364
363,365
364,365
366,367
368,369
369,370
371,372
372,373
372,374
373,374
375,376
377,378
-----nextToken-----
2,4,7,9,10,12,14,15,17,19,20,24,26,28,32,34,35,39,42,44,48,53,54,57,58,61,63,67,69,73,75,78,84,85,87,90,93,94,99,100,103,105,108,109,113,115,119,121,124,131,134,135,138,140,141,142,146,149,150,153,154,155,159,161,162,166,168,171,175,176,181,182,183,184,188,190,194,196,199,203,206,207,213,216,217,220,221,223,225,226,231,234,235,238,239,243,246,247,250,251,253,255,256,261,263,266,271,274,275,276,277,281,283,285,288,290,293,295,296,300,303,304,306,308,311,316,320,322,326,328,331,332,336,337,340,341,343,345,349,351,356,357,360,361,365,367,370,374,376,378
-----computeFrom-----
37,38
37,39
71,72
71,73
80,81
80,82
81,82
81,83
117,118
117,119
126,127
126,128
127,128
127,129
128,129
128,130
143,144
143,145
156,157
156,158
192,193
192,194
209,210
209,211
210,211
210,212
228,229
228,230
240,241
240,242
268,269
268,270
298,299
298,300
313,314
313,315
314,315
314,316
318,319
318,320
-----guardedBy-----
94,109
93,115
161,190
250,263
271,326
274,340
331,340
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;UnaryExpression;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;UnaryExpression;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;UnaryExpression;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;ReferenceOperator;Name;IfStatement;BinaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;UnaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;UnaryExpression;LiteralExpression;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;UnaryExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;LiteralExpression;
-----ast_node-----
static int write_ref_sha1(struct ref_lock *lock,	const unsigned char *sha1, const char *logmsg){	static char term = '\n';	struct object *o;	o = parse_object(sha1);	if (!o) {		error("Trying to write ref %s with nonexistent object %s",			lock->ref_name, sha1_to_hex(sha1));		unlock_ref(lock);		errno = EINVAL;		return -1;	}	if (o->type != OBJ_COMMIT && is_branch(lock->ref_name)) {		error("Trying to write non-commit object %s to branch %s",			sha1_to_hex(sha1), lock->ref_name);		unlock_ref(lock);		errno = EINVAL;		return -1;	}	if (write_in_full(lock->lock_fd, sha1_to_hex(sha1), 40) != 40 ||	    write_in_full(lock->lock_fd, &term, 1) != 1 ||	    close_ref(lock) < 0) {		int save_errno = errno;		error("Couldn't write %s", lock->lk->filename.buf);		unlock_ref(lock);		errno = save_errno;		return -1;	}	clear_loose_ref_cache(&ref_cache);	if (log_ref_write(lock->ref_name, lock->old_sha1, sha1, logmsg) < 0 ||	    (strcmp(lock->ref_name, lock->orig_ref_name) &&	     log_ref_write(lock->orig_ref_name, lock->old_sha1, sha1, logmsg) < 0)) {		unlock_ref(lock);		return -1;	}	if (strcmp(lock->orig_ref_name, "HEAD") != 0) {		/*		 * Special hack: If a branch is updated directly and HEAD		 * points to it (may happen on the remote side of a push		 * for example) then logically the HEAD reflog should be		 * updated too.		 * A generic solution implies reverse symref information,		 * but finding all symrefs pointing to the given branch		 * would be rather costly for this rare event (the direct		 * update of a branch) to be worth it.  So let's cheat and		 * check with HEAD only which should cover 99% of all usage		 * scenarios (even 100% of the default ones).		 */		unsigned char head_sha1[20];		int head_flag;		const char *head_ref;		head_ref = resolve_ref_unsafe("HEAD", RESOLVE_REF_READING,					      head_sha1, &head_flag);		if (head_ref && (head_flag & REF_ISSYMREF) &&		    !strcmp(head_ref, lock->ref_name))			log_ref_write("HEAD", lock->old_sha1, sha1, logmsg);	}	if (commit_ref(lock)) {		error("Couldn't set %s", lock->ref_name);		unlock_ref(lock);		return -1;	}	unlock_ref(lock);	return 0;}
static int
write_ref_sha1(struct ref_lock *lock,	const unsigned char *sha1, const char *logmsg)
write_ref_sha1
struct ref_lock *lock
struct ref_lock
ref_lock
*lock
*
lock
const unsigned char *sha1
const unsigned char
*sha1
*
sha1
const char *logmsg
const char
*logmsg
*
logmsg
{	static char term = '\n';	struct object *o;	o = parse_object(sha1);	if (!o) {		error("Trying to write ref %s with nonexistent object %s",			lock->ref_name, sha1_to_hex(sha1));		unlock_ref(lock);		errno = EINVAL;		return -1;	}	if (o->type != OBJ_COMMIT && is_branch(lock->ref_name)) {		error("Trying to write non-commit object %s to branch %s",			sha1_to_hex(sha1), lock->ref_name);		unlock_ref(lock);		errno = EINVAL;		return -1;	}	if (write_in_full(lock->lock_fd, sha1_to_hex(sha1), 40) != 40 ||	    write_in_full(lock->lock_fd, &term, 1) != 1 ||	    close_ref(lock) < 0) {		int save_errno = errno;		error("Couldn't write %s", lock->lk->filename.buf);		unlock_ref(lock);		errno = save_errno;		return -1;	}	clear_loose_ref_cache(&ref_cache);	if (log_ref_write(lock->ref_name, lock->old_sha1, sha1, logmsg) < 0 ||	    (strcmp(lock->ref_name, lock->orig_ref_name) &&	     log_ref_write(lock->orig_ref_name, lock->old_sha1, sha1, logmsg) < 0)) {		unlock_ref(lock);		return -1;	}	if (strcmp(lock->orig_ref_name, "HEAD") != 0) {		/*		 * Special hack: If a branch is updated directly and HEAD		 * points to it (may happen on the remote side of a push		 * for example) then logically the HEAD reflog should be		 * updated too.		 * A generic solution implies reverse symref information,		 * but finding all symrefs pointing to the given branch		 * would be rather costly for this rare event (the direct		 * update of a branch) to be worth it.  So let's cheat and		 * check with HEAD only which should cover 99% of all usage		 * scenarios (even 100% of the default ones).		 */		unsigned char head_sha1[20];		int head_flag;		const char *head_ref;		head_ref = resolve_ref_unsafe("HEAD", RESOLVE_REF_READING,					      head_sha1, &head_flag);		if (head_ref && (head_flag & REF_ISSYMREF) &&		    !strcmp(head_ref, lock->ref_name))			log_ref_write("HEAD", lock->old_sha1, sha1, logmsg);	}	if (commit_ref(lock)) {		error("Couldn't set %s", lock->ref_name);		unlock_ref(lock);		return -1;	}	unlock_ref(lock);	return 0;}
static char term = '\n';
static char term = '\n';
static char
term = '\n'
term
= '\n'
'\n'
struct object *o;
struct object *o;
struct object
object
*o
*
o
o = parse_object(sha1);
o = parse_object(sha1)
o
o
parse_object(sha1)
parse_object
parse_object
sha1
sha1
if (!o) {		error("Trying to write ref %s with nonexistent object %s",			lock->ref_name, sha1_to_hex(sha1));		unlock_ref(lock);		errno = EINVAL;		return -1;	}
!o
o
o
{		error("Trying to write ref %s with nonexistent object %s",			lock->ref_name, sha1_to_hex(sha1));		unlock_ref(lock);		errno = EINVAL;		return -1;	}
error("Trying to write ref %s with nonexistent object %s",			lock->ref_name, sha1_to_hex(sha1));
error("Trying to write ref %s with nonexistent object %s",			lock->ref_name, sha1_to_hex(sha1))
error
error
"Trying to write ref %s with nonexistent object %s"
lock->ref_name
lock
lock
ref_name
sha1_to_hex(sha1)
sha1_to_hex
sha1_to_hex
sha1
sha1
unlock_ref(lock);
unlock_ref(lock)
unlock_ref
unlock_ref
lock
lock
errno = EINVAL;
errno = EINVAL
errno
errno
EINVAL
EINVAL
return -1;
-1
1
if (o->type != OBJ_COMMIT && is_branch(lock->ref_name)) {		error("Trying to write non-commit object %s to branch %s",			sha1_to_hex(sha1), lock->ref_name);		unlock_ref(lock);		errno = EINVAL;		return -1;	}
o->type != OBJ_COMMIT && is_branch(lock->ref_name)
o->type != OBJ_COMMIT
o->type
o
o
type
OBJ_COMMIT
OBJ_COMMIT
is_branch(lock->ref_name)
is_branch
is_branch
lock->ref_name
lock
lock
ref_name
{		error("Trying to write non-commit object %s to branch %s",			sha1_to_hex(sha1), lock->ref_name);		unlock_ref(lock);		errno = EINVAL;		return -1;	}
error("Trying to write non-commit object %s to branch %s",			sha1_to_hex(sha1), lock->ref_name);
error("Trying to write non-commit object %s to branch %s",			sha1_to_hex(sha1), lock->ref_name)
error
error
"Trying to write non-commit object %s to branch %s"
sha1_to_hex(sha1)
sha1_to_hex
sha1_to_hex
sha1
sha1
lock->ref_name
lock
lock
ref_name
unlock_ref(lock);
unlock_ref(lock)
unlock_ref
unlock_ref
lock
lock
errno = EINVAL;
errno = EINVAL
errno
errno
EINVAL
EINVAL
return -1;
-1
1
if (write_in_full(lock->lock_fd, sha1_to_hex(sha1), 40) != 40 ||	    write_in_full(lock->lock_fd, &term, 1) != 1 ||	    close_ref(lock) < 0) {		int save_errno = errno;		error("Couldn't write %s", lock->lk->filename.buf);		unlock_ref(lock);		errno = save_errno;		return -1;	}
write_in_full(lock->lock_fd, sha1_to_hex(sha1), 40) != 40 ||	    write_in_full(lock->lock_fd, &term, 1) != 1 ||	    close_ref(lock) < 0
write_in_full(lock->lock_fd, sha1_to_hex(sha1), 40) != 40 ||	    write_in_full(lock->lock_fd, &term, 1) != 1
write_in_full(lock->lock_fd, sha1_to_hex(sha1), 40) != 40
write_in_full(lock->lock_fd, sha1_to_hex(sha1), 40)
write_in_full
write_in_full
lock->lock_fd
lock
lock
lock_fd
sha1_to_hex(sha1)
sha1_to_hex
sha1_to_hex
sha1
sha1
40
40
write_in_full(lock->lock_fd, &term, 1) != 1
write_in_full(lock->lock_fd, &term, 1)
write_in_full
write_in_full
lock->lock_fd
lock
lock
lock_fd
&term
term
term
1
1
close_ref(lock) < 0
close_ref(lock)
close_ref
close_ref
lock
lock
0
{		int save_errno = errno;		error("Couldn't write %s", lock->lk->filename.buf);		unlock_ref(lock);		errno = save_errno;		return -1;	}
int save_errno = errno;
int save_errno = errno;
int
save_errno = errno
save_errno
= errno
errno
errno
error("Couldn't write %s", lock->lk->filename.buf);
error("Couldn't write %s", lock->lk->filename.buf)
error
error
"Couldn't write %s"
lock->lk->filename.buf
lock->lk->filename
lock->lk
lock
lock
lk
filename
buf
unlock_ref(lock);
unlock_ref(lock)
unlock_ref
unlock_ref
lock
lock
errno = save_errno;
errno = save_errno
errno
errno
save_errno
save_errno
return -1;
-1
1
clear_loose_ref_cache(&ref_cache);
clear_loose_ref_cache(&ref_cache);
clear_loose_ref_cache
clear_loose_ref_cache
(&ref_cache)
&ref_cache
&
ref_cache
if (log_ref_write(lock->ref_name, lock->old_sha1, sha1, logmsg) < 0 ||	    (strcmp(lock->ref_name, lock->orig_ref_name) &&	     log_ref_write(lock->orig_ref_name, lock->old_sha1, sha1, logmsg) < 0)) {		unlock_ref(lock);		return -1;	}
log_ref_write(lock->ref_name, lock->old_sha1, sha1, logmsg) < 0 ||	    (strcmp(lock->ref_name, lock->orig_ref_name) &&	     log_ref_write(lock->orig_ref_name, lock->old_sha1, sha1, logmsg) < 0)
log_ref_write(lock->ref_name, lock->old_sha1, sha1, logmsg) < 0
log_ref_write(lock->ref_name, lock->old_sha1, sha1, logmsg)
log_ref_write
log_ref_write
lock->ref_name
lock
lock
ref_name
lock->old_sha1
lock
lock
old_sha1
sha1
sha1
logmsg
logmsg
0
(strcmp(lock->ref_name, lock->orig_ref_name) &&	     log_ref_write(lock->orig_ref_name, lock->old_sha1, sha1, logmsg) < 0)
strcmp(lock->ref_name, lock->orig_ref_name) &&	     log_ref_write(lock->orig_ref_name, lock->old_sha1, sha1, logmsg) < 0
strcmp(lock->ref_name, lock->orig_ref_name)
strcmp
strcmp
lock->ref_name
lock
lock
ref_name
lock->orig_ref_name
lock
lock
orig_ref_name
log_ref_write(lock->orig_ref_name, lock->old_sha1, sha1, logmsg) < 0
log_ref_write(lock->orig_ref_name, lock->old_sha1, sha1, logmsg)
log_ref_write
log_ref_write
lock->orig_ref_name
lock
lock
orig_ref_name
lock->old_sha1
lock
lock
old_sha1
sha1
sha1
logmsg
logmsg
0
{		unlock_ref(lock);		return -1;	}
unlock_ref(lock);
unlock_ref(lock)
unlock_ref
unlock_ref
lock
lock
return -1;
-1
1
if (strcmp(lock->orig_ref_name, "HEAD") != 0) {		/*		 * Special hack: If a branch is updated directly and HEAD		 * points to it (may happen on the remote side of a push		 * for example) then logically the HEAD reflog should be		 * updated too.		 * A generic solution implies reverse symref information,		 * but finding all symrefs pointing to the given branch		 * would be rather costly for this rare event (the direct		 * update of a branch) to be worth it.  So let's cheat and		 * check with HEAD only which should cover 99% of all usage		 * scenarios (even 100% of the default ones).		 */		unsigned char head_sha1[20];		int head_flag;		const char *head_ref;		head_ref = resolve_ref_unsafe("HEAD", RESOLVE_REF_READING,					      head_sha1, &head_flag);		if (head_ref && (head_flag & REF_ISSYMREF) &&		    !strcmp(head_ref, lock->ref_name))			log_ref_write("HEAD", lock->old_sha1, sha1, logmsg);	}
strcmp(lock->orig_ref_name, "HEAD") != 0
strcmp(lock->orig_ref_name, "HEAD")
strcmp
strcmp
lock->orig_ref_name
lock
lock
orig_ref_name
"HEAD"
0
{		/*		 * Special hack: If a branch is updated directly and HEAD		 * points to it (may happen on the remote side of a push		 * for example) then logically the HEAD reflog should be		 * updated too.		 * A generic solution implies reverse symref information,		 * but finding all symrefs pointing to the given branch		 * would be rather costly for this rare event (the direct		 * update of a branch) to be worth it.  So let's cheat and		 * check with HEAD only which should cover 99% of all usage		 * scenarios (even 100% of the default ones).		 */		unsigned char head_sha1[20];		int head_flag;		const char *head_ref;		head_ref = resolve_ref_unsafe("HEAD", RESOLVE_REF_READING,					      head_sha1, &head_flag);		if (head_ref && (head_flag & REF_ISSYMREF) &&		    !strcmp(head_ref, lock->ref_name))			log_ref_write("HEAD", lock->old_sha1, sha1, logmsg);	}
unsigned char head_sha1[20];
unsigned char head_sha1[20];
unsigned char
head_sha1[20]
head_sha1
[20]
20
int head_flag;
int head_flag;
int
head_flag
head_flag
const char *head_ref;
const char *head_ref;
const char
*head_ref
*
head_ref
head_ref = resolve_ref_unsafe("HEAD", RESOLVE_REF_READING,					      head_sha1, &head_flag);
head_ref = resolve_ref_unsafe("HEAD", RESOLVE_REF_READING,					      head_sha1, &head_flag)
head_ref
head_ref
resolve_ref_unsafe("HEAD", RESOLVE_REF_READING,					      head_sha1, &head_flag)
resolve_ref_unsafe
resolve_ref_unsafe
"HEAD"
RESOLVE_REF_READING
RESOLVE_REF_READING
head_sha1
head_sha1
&head_flag
head_flag
head_flag
if (head_ref && (head_flag & REF_ISSYMREF) &&		    !strcmp(head_ref, lock->ref_name))			log_ref_write("HEAD", lock->old_sha1, sha1, logmsg);
head_ref && (head_flag & REF_ISSYMREF) &&		    !strcmp(head_ref, lock->ref_name)
head_ref && (head_flag & REF_ISSYMREF)
head_ref
head_ref
(head_flag & REF_ISSYMREF)
head_flag & REF_ISSYMREF
head_flag
head_flag
REF_ISSYMREF
REF_ISSYMREF
!strcmp(head_ref, lock->ref_name)
strcmp(head_ref, lock->ref_name)
strcmp
strcmp
head_ref
head_ref
lock->ref_name
lock
lock
ref_name
log_ref_write("HEAD", lock->old_sha1, sha1, logmsg);
log_ref_write("HEAD", lock->old_sha1, sha1, logmsg)
log_ref_write
log_ref_write
"HEAD"
lock->old_sha1
lock
lock
old_sha1
sha1
sha1
logmsg
logmsg
if (commit_ref(lock)) {		error("Couldn't set %s", lock->ref_name);		unlock_ref(lock);		return -1;	}
commit_ref(lock)
commit_ref
commit_ref
lock
lock
{		error("Couldn't set %s", lock->ref_name);		unlock_ref(lock);		return -1;	}
error("Couldn't set %s", lock->ref_name);
error("Couldn't set %s", lock->ref_name)
error
error
"Couldn't set %s"
lock->ref_name
lock
lock
ref_name
unlock_ref(lock);
unlock_ref(lock)
unlock_ref
unlock_ref
lock
lock
return -1;
-1
1
unlock_ref(lock);
unlock_ref(lock)
unlock_ref
unlock_ref
lock
lock
return 0;
0
-----joern-----
(94,202,0)
(175,150,0)
(166,172,0)
(89,36,0)
(66,18,0)
(152,181,0)
(118,196,0)
(185,130,0)
(1,115,0)
(56,112,0)
(205,10,0)
(3,145,0)
(144,170,0)
(66,60,0)
(82,119,0)
(37,165,0)
(193,129,0)
(17,89,0)
(49,191,0)
(35,10,0)
(40,36,0)
(146,94,0)
(170,158,0)
(39,120,0)
(93,203,0)
(119,100,0)
(88,128,0)
(64,75,0)
(39,30,0)
(189,7,0)
(188,184,0)
(90,36,0)
(76,126,0)
(172,2,0)
(173,202,0)
(129,151,0)
(149,94,0)
(121,64,0)
(136,102,0)
(62,126,0)
(88,36,0)
(18,66,0)
(108,30,0)
(115,86,0)
(150,43,0)
(4,79,0)
(90,151,0)
(58,36,0)
(6,9,0)
(150,175,0)
(128,98,0)
(69,38,0)
(161,11,0)
(135,117,0)
(65,150,0)
(172,44,0)
(97,96,0)
(175,36,0)
(195,144,0)
(82,185,0)
(160,100,0)
(124,10,0)
(127,36,0)
(84,40,0)
(20,185,0)
(134,187,0)
(73,20,0)
(2,172,0)
(10,205,0)
(115,1,0)
(179,64,0)
(87,102,0)
(82,129,0)
(174,28,0)
(198,45,0)
(5,83,0)
(117,36,0)
(91,60,0)
(68,58,0)
(34,89,0)
(96,114,0)
(78,112,0)
(26,39,0)
(106,39,0)
(131,16,0)
(150,41,0)
(21,160,0)
(188,108,0)
(32,175,0)
(66,167,0)
(110,95,0)
(128,138,0)
(53,108,0)
(200,102,0)
(199,114,0)
(199,30,0)
(120,36,0)
(126,11,0)
(157,88,0)
(2,40,0)
(101,144,0)
(191,36,0)
(154,94,0)
(180,36,0)
(9,114,0)
(44,172,0)
(139,30,0)
(12,9,0)
(161,167,0)
(33,38,0)
(120,39,0)
(137,95,0)
(111,188,0)
(10,36,0)
(79,150,0)
(8,37,0)
(145,165,0)
(70,136,0)
(77,79,0)
(82,169,0)
(63,2,0)
(112,41,0)
(165,37,0)
(59,75,0)
(145,36,0)
(204,193,0)
(105,15,0)
(14,43,0)
(139,75,0)
(115,137,0)
(47,191,0)
(176,33,0)
(158,159,0)
(184,36,0)
(143,78,0)
(194,187,0)
(113,120,0)
(137,115,0)
(162,15,0)
(44,122,0)
(136,70,0)
(196,153,0)
(29,70,0)
(125,169,0)
(80,199,0)
(77,138,0)
(205,1,0)
(185,122,0)
(54,88,0)
(103,38,0)
(128,88,0)
(132,1,0)
(190,122,0)
(39,41,0)
(28,100,0)
(50,98,0)
(81,187,0)
(85,48,0)
(11,18,0)
(40,2,0)
(38,33,0)
(83,45,0)
(130,122,0)
(48,153,0)
(7,86,0)
(19,139,0)
(116,130,0)
(170,144,0)
(55,184,0)
(23,127,0)
(51,90,0)
(144,36,0)
(167,94,0)
(75,151,0)
(60,66,0)
(188,45,0)
(37,30,0)
(72,102,0)
(197,181,0)
(171,36,0)
(133,103,0)
(79,77,0)
(165,145,0)
(82,196,0)
(43,36,0)
(177,86,0)
(181,102,0)
(169,102,0)
(114,199,0)
(46,102,0)
(155,39,0)
(98,36,0)
(98,128,0)
(94,167,0)
(171,45,0)
(7,36,0)
(52,83,0)
(130,15,0)
(22,130,0)
(25,181,0)
(61,112,0)
(198,83,0)
(184,188,0)
(138,77,0)
(1,205,0)
(159,158,0)
(43,150,0)
(178,102,0)
(38,103,0)
(138,78,0)
(202,94,0)
(186,66,0)
(92,180,0)
(78,138,0)
(141,103,0)
(183,25,0)
(104,180,0)
(127,102,0)
(112,191,0)
(58,122,0)
(148,102,0)
(86,7,0)
(147,184,0)
(103,36,0)
(27,167,0)
(48,36,0)
(42,165,0)
(158,170,0)
(205,25,0)
(112,30,0)
(16,151,0)
(159,9,0)
(168,40,0)
(108,188,0)
(60,36,0)
(138,128,0)
(180,112,0)
(160,36,0)
(164,98,0)
(11,161,0)
(114,102,0)
(18,11,0)
(112,78,0)
(57,102,0)
(95,137,0)
(192,0,0)
(201,16,0)
(31,114,0)
(150,30,0)
(64,36,0)
(71,60,0)
(150,79,0)
(99,145,0)
(142,175,0)
(75,139,0)
(109,44,0)
(74,187,0)
(191,112,0)
(89,28,0)
(123,120,0)
(95,165,0)
(112,180,0)
(9,159,0)
(107,171,0)
(167,187,0)
(140,150,0)
(165,95,0)
(156,118,0)
(203,119,0)
(11,126,0)
(0,198,0)
(25,205,0)
(13,159,0)
(67,43,0)
(15,122,0)
(24,161,0)
(82,198,0)
(86,115,0)
(75,64,0)
(163,205,0)
(182,102,0)
(28,89,0)
(129,16,0)
(48,36,1)
(11,18,1)
(31,181,1)
(58,68,1)
(202,173,1)
(38,103,1)
(3,99,1)
(55,111,1)
(115,86,1)
(95,110,1)
(145,3,1)
(199,30,1)
(191,36,1)
(1,205,1)
(129,193,1)
(177,7,1)
(116,58,1)
(123,113,1)
(156,48,1)
(119,203,1)
(4,150,1)
(9,114,1)
(127,23,1)
(167,94,1)
(39,106,1)
(161,11,1)
(203,93,1)
(168,109,1)
(84,168,1)
(35,95,1)
(19,59,1)
(195,101,1)
(89,36,1)
(51,75,1)
(163,25,1)
(25,181,1)
(133,141,1)
(198,83,1)
(114,199,1)
(135,39,1)
(191,47,1)
(140,65,1)
(64,121,1)
(144,195,1)
(125,127,1)
(64,36,1)
(108,30,1)
(16,201,1)
(158,170,1)
(99,158,1)
(184,36,1)
(48,85,1)
(184,147,1)
(113,26,1)
(67,14,1)
(159,13,1)
(33,38,1)
(88,157,1)
(142,32,1)
(130,15,1)
(2,40,1)
(174,117,1)
(14,136,1)
(53,184,1)
(86,177,1)
(139,19,1)
(172,166,1)
(150,140,1)
(90,36,1)
(80,31,1)
(136,70,1)
(76,62,1)
(124,35,1)
(127,36,1)
(10,124,1)
(103,36,1)
(37,30,1)
(97,114,1)
(150,175,1)
(205,163,1)
(70,29,1)
(71,91,1)
(95,165,1)
(28,89,1)
(120,123,1)
(82,129,1)
(180,92,1)
(157,54,1)
(135,161,1)
(23,117,1)
(192,83,1)
(112,30,1)
(205,10,1)
(161,167,1)
(37,8,1)
(117,135,1)
(94,202,1)
(198,0,1)
(161,24,1)
(63,40,1)
(39,41,1)
(150,30,1)
(11,126,1)
(15,105,1)
(139,30,1)
(39,30,1)
(82,119,1)
(115,1,1)
(165,42,1)
(65,175,1)
(188,184,1)
(137,95,1)
(69,103,1)
(21,28,1)
(171,107,1)
(159,9,1)
(138,78,1)
(121,179,1)
(150,43,1)
(158,159,1)
(77,138,1)
(98,164,1)
(82,185,1)
(12,6,1)
(66,167,1)
(40,84,1)
(33,176,1)
(49,180,1)
(43,67,1)
(175,36,1)
(166,2,1)
(77,79,1)
(83,5,1)
(91,186,1)
(54,98,1)
(107,188,1)
(131,90,1)
(103,133,1)
(169,125,1)
(40,36,1)
(199,80,1)
(8,145,1)
(82,196,1)
(160,21,1)
(117,36,1)
(183,10,1)
(137,115,1)
(179,139,1)
(152,197,1)
(165,145,1)
(0,192,1)
(110,165,1)
(1,132,1)
(118,156,1)
(86,7,1)
(73,130,1)
(96,97,1)
(59,158,1)
(112,191,1)
(20,73,1)
(176,38,1)
(101,159,1)
(106,155,1)
(5,52,1)
(92,104,1)
(56,61,1)
(143,112,1)
(88,36,1)
(62,24,1)
(78,143,1)
(75,64,1)
(52,171,1)
(154,146,1)
(79,4,1)
(138,128,1)
(132,205,1)
(126,76,1)
(155,120,1)
(129,16,1)
(29,137,1)
(98,36,1)
(66,60,1)
(39,120,1)
(149,27,1)
(10,36,1)
(82,169,1)
(60,71,1)
(162,137,1)
(60,36,1)
(120,36,1)
(173,154,1)
(141,77,1)
(171,36,1)
(160,36,1)
(93,160,1)
(112,41,1)
(22,116,1)
(26,161,1)
(112,56,1)
(111,96,1)
(38,69,1)
(13,9,1)
(185,20,1)
(79,150,1)
(186,126,1)
(104,128,1)
(180,36,1)
(68,44,1)
(193,204,1)
(90,51,1)
(170,144,1)
(24,167,1)
(2,63,1)
(128,98,1)
(188,108,1)
(189,1,1)
(32,43,1)
(205,25,1)
(18,66,1)
(43,36,1)
(89,17,1)
(201,131,1)
(108,53,1)
(44,172,1)
(85,77,1)
(6,96,1)
(61,191,1)
(144,36,1)
(112,180,1)
(7,189,1)
(204,16,1)
(75,139,1)
(145,36,1)
(25,183,1)
(185,130,1)
(172,2,1)
(42,37,1)
(150,41,1)
(34,174,1)
(181,152,1)
(50,79,1)
(130,22,1)
(135,33,1)
(109,15,1)
(7,36,1)
(196,118,1)
(9,12,1)
(58,36,1)
(17,34,1)
(165,37,1)
(147,55,1)
(164,50,1)
(47,49,1)
(27,33,1)
(128,88,1)
(175,142,1)
(96,114,1)
(78,112,1)
(82,198,1)
(146,149,1)
(105,162,1)
(39,161,2)
(128,98,2)
(84,137,2)
(191,36,2)
(82,185,2)
(123,161,2)
(189,1,2)
(47,128,2)
(129,16,2)
(161,33,2)
(166,137,2)
(38,103,2)
(75,158,2)
(10,95,2)
(6,96,2)
(42,158,2)
(136,70,2)
(91,126,2)
(165,145,2)
(82,196,2)
(90,158,2)
(154,33,2)
(185,130,2)
(59,158,2)
(62,24,2)
(92,128,2)
(198,96,2)
(33,38,2)
(108,30,2)
(73,137,2)
(120,36,2)
(25,181,2)
(63,137,2)
(171,96,2)
(86,7,2)
(90,36,2)
(118,77,2)
(188,184,2)
(137,158,2)
(19,158,2)
(10,36,2)
(89,36,2)
(77,79,2)
(179,158,2)
(64,158,2)
(192,96,2)
(98,79,2)
(167,33,2)
(58,36,2)
(33,77,2)
(125,117,2)
(185,137,2)
(58,137,2)
(40,36,2)
(117,36,2)
(137,115,2)
(106,161,2)
(75,64,2)
(11,18,2)
(0,96,2)
(38,77,2)
(202,33,2)
(135,77,2)
(205,95,2)
(158,170,2)
(139,30,2)
(131,158,2)
(79,150,2)
(176,77,2)
(48,77,2)
(161,11,2)
(82,169,2)
(69,77,2)
(138,78,2)
(95,165,2)
(141,77,2)
(149,33,2)
(128,88,2)
(195,159,2)
(104,128,2)
(139,158,2)
(150,137,2)
(17,117,2)
(170,159,2)
(26,161,2)
(175,137,2)
(89,117,2)
(196,77,2)
(107,96,2)
(168,137,2)
(44,172,2)
(76,24,2)
(79,137,2)
(43,36,2)
(163,95,2)
(180,128,2)
(112,41,2)
(49,128,2)
(117,77,2)
(158,159,2)
(93,117,2)
(64,36,2)
(5,96,2)
(82,129,2)
(28,117,2)
(110,158,2)
(133,77,2)
(109,137,2)
(88,79,2)
(11,126,2)
(136,137,2)
(1,205,2)
(127,117,2)
(172,137,2)
(128,79,2)
(75,139,2)
(68,137,2)
(112,191,2)
(119,117,2)
(146,33,2)
(54,79,2)
(51,158,2)
(99,158,2)
(158,96,2)
(7,1,2)
(7,36,2)
(115,1,2)
(83,96,2)
(15,137,2)
(159,96,2)
(201,158,2)
(56,128,2)
(88,36,2)
(22,137,2)
(61,128,2)
(204,158,2)
(11,24,2)
(37,30,2)
(175,36,2)
(2,137,2)
(116,137,2)
(129,158,2)
(9,114,2)
(112,128,2)
(39,41,2)
(13,96,2)
(24,33,2)
(172,2,2)
(82,119,2)
(28,89,2)
(66,60,2)
(188,108,2)
(21,117,2)
(23,117,2)
(198,83,2)
(124,95,2)
(191,128,2)
(169,117,2)
(20,137,2)
(150,30,2)
(67,137,2)
(78,128,2)
(108,96,2)
(150,41,2)
(164,79,2)
(4,137,2)
(142,137,2)
(60,36,2)
(44,137,2)
(115,86,2)
(156,77,2)
(127,36,2)
(101,159,2)
(105,137,2)
(170,144,2)
(161,167,2)
(32,137,2)
(112,180,2)
(55,96,2)
(112,30,2)
(121,158,2)
(130,15,2)
(34,117,2)
(82,198,2)
(150,175,2)
(205,25,2)
(96,114,2)
(40,137,2)
(150,43,2)
(18,66,2)
(184,96,2)
(203,117,2)
(138,79,2)
(43,137,2)
(165,158,2)
(95,158,2)
(29,137,2)
(184,36,2)
(132,95,2)
(145,158,2)
(167,94,2)
(111,96,2)
(160,36,2)
(147,96,2)
(113,161,2)
(94,202,2)
(193,158,2)
(145,36,2)
(165,37,2)
(186,126,2)
(86,1,2)
(27,33,2)
(144,159,2)
(143,128,2)
(130,137,2)
(180,36,2)
(144,36,2)
(60,126,2)
(174,117,2)
(9,96,2)
(138,128,2)
(205,10,2)
(65,137,2)
(66,167,2)
(50,79,2)
(12,96,2)
(103,77,2)
(39,120,2)
(94,33,2)
(71,126,2)
(1,95,2)
(137,95,2)
(2,40,2)
(98,36,2)
(160,117,2)
(39,30,2)
(77,138,2)
(126,24,2)
(140,137,2)
(3,158,2)
(16,158,2)
(171,36,2)
(52,96,2)
(120,161,2)
(78,112,2)
(162,137,2)
(188,96,2)
(173,33,2)
(157,79,2)
(25,95,2)
(37,158,2)
(159,9,2)
(18,126,2)
(115,95,2)
(48,36,2)
(103,36,2)
(155,161,2)
(70,137,2)
(177,1,2)
(77,137,2)
(66,126,2)
(8,158,2)
(85,77,2)
(183,95,2)
(53,96,2)
(114,199,2)
(199,30,2)
(35,95,2)
(14,137,2)
-----------------------------------
(0,-1)
(1,write_in_full(lock->lock_fd, &term, 1)
(2,lock->lk->filename)
(3,lock_fd)
(4,0)
(5,EINVAL)
(6,o)
(7,close_ref(lock)
(8,sha1)
(9,o->type)
(10,lock->lock_fd)
(11,(head_flag & REF_ISSYMREF)
(12,type)
(13,OBJ_COMMIT)
(14,lock)
(15,save_errno = errno)
(16,errno = EINVAL)
(17,ref_name)
(18,!strcmp(head_ref, lock->ref_name)
(19,sha1)
(20,-1)
(21,lock)
(22,save_errno)
(23,lock)
(24,head_ref)
(25,&term)
(26,"HEAD")
(27,head_ref)
(28,error("Couldn\'t set %s", lock->ref_name)
(29,ref_cache)
(30,const unsigned char *sha1)
(31,o)
(32,lock)
(33,strcmp(lock->orig_ref_name, "HEAD")
(34,lock)
(35,lock)
(36,struct ref_lock *lock)
(37,sha1_to_hex(sha1)
(38,strcmp(lock->orig_ref_name, "HEAD")
(39,log_ref_write("HEAD", lock->old_sha1, sha1, logmsg)
(40,lock->lk)
(41,const char *logmsg)
(42,40)
(43,lock->ref_name)
(44,error("Couldn\'t write %s", lock->lk->filename.buf)
(45,)
(46,if (log_ref_write(lock->ref_name, lock->old_sha1, sha1, logmsg)
(47,old_sha1)
(48,unlock_ref(lock)
(49,lock)
(50,lock)
(51,lock)
(52,errno)
(53,sha1)
(54,lock)
(55,lock)
(56,logmsg)
(57,term)
(58,unlock_ref(lock)
(59,"Trying to write non-commit object %s to branch %s")
(60,lock->ref_name)
(61,sha1)
(62,head_flag)
(63,filename)
(64,lock->ref_name)
(65,sha1)
(66,strcmp(head_ref, lock->ref_name)
(67,ref_name)
(68,lock)
(69,"HEAD")
(70,&ref_cache)
(71,ref_name)
(72,if (o->type != OBJ_COMMIT && is_branch(lock->ref_name)
(73,1)
(74,head_flag)
(75,error("Trying to write non-commit object %s to branch %s",\n\\n\\t\\t\\tsha1_to_hex(sha1)
(76,REF_ISSYMREF)
(77,log_ref_write(lock->ref_name, lock->old_sha1, sha1, logmsg)
(78,log_ref_write(lock->orig_ref_name, lock->old_sha1, sha1, logmsg)
(79,log_ref_write(lock->ref_name, lock->old_sha1, sha1, logmsg)
(80,sha1)
(81,head_sha1)
(82,RET)
(83,errno = EINVAL)
(84,lk)
(85,lock)
(86,close_ref(lock)
(87,if (write_in_full(lock->lock_fd, sha1_to_hex(sha1)
(88,lock->orig_ref_name)
(89,lock->ref_name)
(90,unlock_ref(lock)
(91,lock)
(92,orig_ref_name)
(93,1)
(94,resolve_ref_unsafe("HEAD", RESOLVE_REF_READING,\n\\n\\t\\t\\t\\t\\t      head_sha1, &head_flag)
(95,write_in_full(lock->lock_fd, sha1_to_hex(sha1)
(96,!o)
(97,o)
(98,lock->ref_name)
(99,lock)
(100,)
(101,lock)
(102,)
(103,lock->orig_ref_name)
(104,lock)
(105,errno)
(106,logmsg)
(107,lock)
(108,sha1_to_hex(sha1)
(109,"Couldn\'t write %s")
(110,40)
(111,"Trying to write ref %s with nonexistent object %s")
(112,log_ref_write(lock->orig_ref_name, lock->old_sha1, sha1, logmsg)
(113,lock)
(114,o = parse_object(sha1)
(115,write_in_full(lock->lock_fd, &term, 1)
(116,errno)
(117,commit_ref(lock)
(118,-1)
(119,return -1;)
(120,lock->old_sha1)
(121,ref_name)
(122,)
(123,old_sha1)
(124,lock_fd)
(125,0)
(126,head_flag & REF_ISSYMREF)
(127,unlock_ref(lock)
(128,strcmp(lock->ref_name, lock->orig_ref_name)
(129,return -1;)
(130,errno = save_errno)
(131,errno)
(132,1)
(133,orig_ref_name)
(134,if (head_ref && (head_flag & REF_ISSYMREF)
(135,lock)
(136,clear_loose_ref_cache(&ref_cache)
(137,write_in_full(lock->lock_fd, sha1_to_hex(sha1)
(138,strcmp(lock->ref_name, lock->orig_ref_name)
(139,sha1_to_hex(sha1)
(140,logmsg)
(141,lock)
(142,old_sha1)
(143,0)
(144,lock->ref_name)
(145,lock->lock_fd)
(146,RESOLVE_REF_READING)
(147,ref_name)
(148,if (commit_ref(lock)
(149,"HEAD")
(150,log_ref_write(lock->ref_name, lock->old_sha1, sha1, logmsg)
(151,)
(152,\'\\n\')
(153,)
(154,head_sha1)
(155,sha1)
(156,1)
(157,orig_ref_name)
(158,o->type != OBJ_COMMIT && is_branch(lock->ref_name)
(159,o->type != OBJ_COMMIT)
(160,unlock_ref(lock)
(161,head_ref && (head_flag & REF_ISSYMREF)
(162,save_errno)
(163,1)
(164,ref_name)
(165,write_in_full(lock->lock_fd, sha1_to_hex(sha1)
(166,buf)
(167,head_ref = resolve_ref_unsafe("HEAD", RESOLVE_REF_READING,\n\\n\\t\\t\\t\\t\\t      head_sha1, &head_flag)
(168,lock)
(169,return 0;)
(170,is_branch(lock->ref_name)
(171,unlock_ref(lock)
(172,lock->lk->filename.buf)
(173,head_flag)
(174,"Couldn\'t set %s")
(175,lock->old_sha1)
(176,0)
(177,0)
(178,o)
(179,lock)
(180,lock->orig_ref_name)
(181,term = \'\\n\')
(182,if (strcmp(lock->orig_ref_name, "HEAD")
(183,term)
(184,lock->ref_name)
(185,return -1;)
(186,head_ref)
(187,)
(188,error("Trying to write ref %s with nonexistent object %s",\n\\n\\t\\t\\tlock->ref_name, sha1_to_hex(sha1)
(189,lock)
(190,save_errno)
(191,lock->old_sha1)
(192,1)
(193,-1)
(194,head_ref)
(195,ref_name)
(196,return -1;)
(197,term)
(198,return -1;)
(199,parse_object(sha1)
(200,if (!o)
(201,EINVAL)
(202,&head_flag)
(203,-1)
(204,1)
(205,write_in_full(lock->lock_fd, &term, 1)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^