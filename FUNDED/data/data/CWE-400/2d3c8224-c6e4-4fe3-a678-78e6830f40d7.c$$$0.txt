-----label-----
1
-----code-----
vm_map_t vm_map_fork(vm_map_t old_map)
{
	vm_map_t	new_map;
	vm_map_entry_t	old_entry;
	vm_map_entry_t	new_entry;
	pmap_t		new_pmap = pmap_create((vm_size_t) 0);
	vm_size_t	new_size = 0;
	vm_size_t	entry_size;
	vm_object_t	object;

	if (new_pmap == PMAP_NULL)
		return VM_MAP_NULL;

	vm_map_lock(old_map);

	new_map = vm_map_create(new_pmap,
			old_map->min_offset,
			old_map->max_offset);
	if (new_pmap == PMAP_NULL) {
		pmap_destroy(new_pmap);
		return VM_MAP_NULL;
	}

	for (
	    old_entry = vm_map_first_entry(old_map);
	    old_entry != vm_map_to_entry(old_map);
	    ) {
		if (old_entry->is_sub_map)
			panic("vm_map_fork: encountered a submap");

		entry_size = (old_entry->vme_end - old_entry->vme_start);

		switch (old_entry->inheritance) {
		case VM_INHERIT_NONE:
			break;

		case VM_INHERIT_SHARE:
		        /*
			 *	New sharing code.  New map entry
			 *	references original object.  Temporary
			 *	objects use asynchronous copy algorithm for
			 *	future copies.  First make sure we have
			 *	the right object.  If we need a shadow,
			 *	or someone else already has one, then
			 *	make a new shadow and share it.
			 */

			object = old_entry->object.vm_object;
			if (object == VM_OBJECT_NULL) {
				object = vm_object_allocate(
					    (vm_size_t)(old_entry->vme_end -
							old_entry->vme_start));
				old_entry->offset = 0;
				old_entry->object.vm_object = object;
				assert(!old_entry->needs_copy);
			}
			else if (old_entry->needs_copy || object->shadowed ||
			    (object->temporary && !old_entry->is_shared &&
			     object->size > (vm_size_t)(old_entry->vme_end -
						old_entry->vme_start))) {

			    assert(object->temporary);
			    assert(!(object->shadowed && old_entry->is_shared));
			    vm_object_shadow(
			        &old_entry->object.vm_object,
			        &old_entry->offset,
			        (vm_size_t) (old_entry->vme_end -
					     old_entry->vme_start));

			    /*
			     *	If we're making a shadow for other than
			     *	copy on write reasons, then we have
			     *	to remove write permission.
			     */

			    if (!old_entry->needs_copy &&
				(old_entry->protection & VM_PROT_WRITE)) {
			    	pmap_protect(vm_map_pmap(old_map),
					     old_entry->vme_start,
					     old_entry->vme_end,
					     old_entry->protection &
					     	~VM_PROT_WRITE);
			    }
			    old_entry->needs_copy = FALSE;
			    object = old_entry->object.vm_object;
			}

			/*
			 *	Set use_shared_copy to indicate that
			 *	object must use shared (delayed) copy-on
			 *	write.  This is ignored for permanent objects.
			 *	Bump the reference count for the new entry
			 */

			vm_object_lock(object);
			object->use_shared_copy = TRUE;
			object->ref_count++;
			vm_object_unlock(object);

			new_entry = vm_map_entry_create(new_map);

			if (old_entry->projected_on != 0) {
			  /*
			   *   If entry is projected buffer, clone the
                           *   entry exactly.
                           */

			  vm_map_entry_copy_full(new_entry, old_entry);

			} else {
			  /*
			   *	Clone the entry, using object ref from above.
			   *	Mark both entries as shared.
			   */

			  vm_map_entry_copy(new_entry, old_entry);
			  old_entry->is_shared = TRUE;
			  new_entry->is_shared = TRUE;
			}

			/*
			 *	Insert the entry into the new map -- we
			 *	know we're inserting at the end of the new
			 *	map.
			 */

			vm_map_entry_link(
				new_map,
				vm_map_last_entry(new_map),
				new_entry);

			/*
			 *	Update the physical map
			 */

			pmap_copy(new_map->pmap, old_map->pmap,
				new_entry->vme_start,
				entry_size,
				old_entry->vme_start);

			new_size += entry_size;
			break;

		case VM_INHERIT_COPY:
			if (old_entry->wired_count == 0) {
				boolean_t	src_needs_copy;
				boolean_t	new_entry_needs_copy;

				new_entry = vm_map_entry_create(new_map);
				vm_map_entry_copy(new_entry, old_entry);

				if (vm_object_copy_temporary(
					&new_entry->object.vm_object,
					&new_entry->offset,
					&src_needs_copy,
					&new_entry_needs_copy)) {

					/*
					 *	Handle copy-on-write obligations
					 */

					if (src_needs_copy && !old_entry->needs_copy) {
						vm_object_pmap_protect(
							old_entry->object.vm_object,
							old_entry->offset,
							entry_size,
							(old_entry->is_shared ?
								PMAP_NULL :
								old_map->pmap),
							old_entry->vme_start,
							old_entry->protection &
							    ~VM_PROT_WRITE);

						old_entry->needs_copy = TRUE;
					}

					new_entry->needs_copy = new_entry_needs_copy;

					/*
					 *	Insert the entry at the end
					 *	of the map.
					 */

					vm_map_entry_link(new_map,
						vm_map_last_entry(new_map),
						new_entry);


					new_size += entry_size;
					break;
				}

				vm_map_entry_dispose(new_map, new_entry);
			}

			/* INNER BLOCK (copy cannot be optimized) */ {

			vm_offset_t	start = old_entry->vme_start;
			vm_map_copy_t	copy;
			vm_map_entry_t	last = vm_map_last_entry(new_map);

			vm_map_unlock(old_map);
			if (vm_map_copyin(old_map,
					start,
					entry_size,
					FALSE,
					&copy)
			    != KERN_SUCCESS) {
			    	vm_map_lock(old_map);
				if (!vm_map_lookup_entry(old_map, start, &last))
					last = last->vme_next;
				old_entry = last;
				/*
				 *	For some error returns, want to
				 *	skip to the next element.
				 */

				continue;
			}

			/*
			 *	Insert the copy into the new map
			 */

			vm_map_copy_insert(new_map, last, copy);
			new_size += entry_size;

			/*
			 *	Pick up the traversal at the end of
			 *	the copied region.
			 */

			vm_map_lock(old_map);
			start += entry_size;
			if (!vm_map_lookup_entry(old_map, start, &last))
				last = last->vme_next;
			 else
				vm_map_clip_start(old_map, last, start);
			old_entry = last;

			continue;
			/* INNER BLOCK (copy cannot be optimized) */ }
		}
		old_entry = old_entry->vme_next;
	}

	new_map->size = new_size;
	vm_map_unlock(old_map);

	return(new_map);
}
-----children-----
1,2
1,3
1,4
2,3
4,5
4,6
6,7
6,8
7,8
9,10
11,12
11,13
11,14
11,15
11,16
11,17
11,18
11,19
11,20
11,21
11,22
11,23
11,24
11,25
11,26
12,13
13,14
13,15
14,15
16,17
18,19
19,20
19,21
20,21
22,23
24,25
25,26
25,27
26,27
28,29
30,31
31,32
31,33
32,33
34,35
34,36
36,37
37,38
37,39
38,39
40,41
40,42
41,42
41,43
42,43
46,47
47,48
47,49
48,49
50,51
50,52
52,53
54,55
55,56
55,57
56,57
58,59
60,61
61,62
61,63
62,63
64,65
66,67
66,68
67,68
67,69
68,69
70,71
72,73
73,74
75,76
76,77
76,78
77,78
79,80
81,82
82,83
82,84
83,84
85,86
85,87
85,88
85,89
86,87
88,89
90,91
90,92
91,92
94,95
94,96
95,96
98,99
98,100
99,100
99,101
100,101
102,103
104,105
104,106
105,106
106,107
106,108
107,108
109,110
111,112
112,113
114,115
114,116
114,117
115,116
116,117
116,118
117,118
119,120
119,121
120,121
122,123
124,125
124,126
125,126
127,128
127,129
128,129
130,131
132,133
132,134
132,135
132,136
133,134
133,135
134,135
134,136
135,136
138,139
139,140
139,141
140,141
143,144
144,145
144,146
145,146
147,148
148,149
148,150
149,150
149,151
150,151
153,154
153,155
154,155
157,158
157,159
158,159
158,160
159,160
162,163
162,164
162,165
162,166
162,167
162,168
162,169
162,170
162,171
162,172
162,173
162,174
162,175
162,176
162,177
162,178
162,179
162,180
163,164
164,165
167,168
168,169
170,171
171,172
171,173
172,173
174,175
174,176
175,176
175,177
176,177
180,181
180,182
180,183
181,182
181,183
182,183
184,185
186,187
186,188
186,189
186,190
187,188
188,189
188,190
189,190
191,192
191,193
192,193
194,195
194,196
195,196
196,197
198,199
198,200
199,200
199,201
200,201
203,204
203,205
204,205
207,208
208,209
208,210
209,210
209,211
210,211
214,215
215,216
215,217
216,217
216,218
217,218
217,219
218,219
222,223
224,225
225,226
225,227
226,227
228,229
229,230
229,231
230,231
233,234
233,235
234,235
234,236
235,236
235,237
236,237
236,238
237,238
240,241
240,242
241,242
244,245
245,246
245,247
246,247
246,248
247,248
247,249
248,249
251,252
252,253
252,254
253,254
256,257
256,258
257,258
257,259
258,259
261,262
261,263
262,263
263,264
265,266
265,267
266,267
266,268
267,268
270,271
270,272
271,272
274,275
274,276
274,277
274,278
274,279
274,280
275,276
276,277
276,278
277,278
279,280
279,281
280,281
283,284
284,285
284,286
285,286
287,288
288,289
289,290
289,291
290,291
290,292
291,292
294,295
294,296
295,296
298,299
299,300
299,301
299,302
299,303
300,301
302,303
303,304
303,305
304,305
304,306
305,306
309,310
310,311
310,312
311,312
314,315
314,316
315,316
316,317
318,319
318,320
319,320
319,321
320,321
323,324
323,325
324,325
327,328
327,329
328,329
328,330
329,330
330,331
330,332
331,332
334,335
335,336
335,337
336,337
336,338
337,338
340,341
342,343
343,344
344,345
344,346
344,347
344,348
344,349
345,346
347,348
347,349
348,349
350,351
352,353
352,354
353,354
356,357
356,358
357,358
360,361
360,362
361,362
361,363
362,363
365,366
366,367
368,369
369,370
369,371
370,371
370,372
371,372
374,375
376,377
377,378
377,379
378,379
380,381
380,382
381,382
381,383
382,383
386,387
387,388
387,389
388,389
390,391
392,393
393,394
393,395
394,395
394,396
395,396
398,399
400,401
401,402
402,403
402,404
403,404
406,407
407,408
407,409
408,409
410,411
412,413
413,414
413,415
414,415
416,417
416,418
417,418
419,420
421,422
421,423
421,424
422,423
422,424
423,424
423,425
424,425
428,429
429,430
430,431
430,432
430,433
431,432
433,434
435,436
437,438
437,439
437,440
438,439
439,440
439,441
439,442
440,441
442,443
444,445
446,447
447,448
447,449
448,449
448,450
449,450
452,453
454,455
455,456
455,457
456,457
456,458
457,458
460,461
462,463
463,464
463,465
463,466
463,467
464,465
466,467
468,469
468,470
469,470
471,472
473,474
475,476
476,477
476,478
476,479
476,480
476,481
476,482
477,478
479,480
479,481
480,481
483,484
483,485
484,485
487,488
487,489
488,489
491,492
493,494
493,495
494,495
497,498
498,499
498,500
499,500
501,502
504,505
505,506
507,508
507,509
508,509
508,510
509,510
509,511
510,511
514,515
514,516
514,517
514,518
514,519
514,520
515,516
516,517
516,518
517,518
519,520
521,522
522,523
522,524
523,524
525,526
527,528
528,529
528,530
529,530
531,532
531,533
532,533
534,535
536,537
537,538
537,539
537,540
538,539
540,541
542,543
544,545
544,546
545,546
545,547
545,548
545,549
545,550
546,547
548,549
549,550
549,551
550,551
550,552
551,552
555,556
556,557
556,558
557,558
560,561
561,562
563,564
564,565
566,567
566,568
566,569
566,570
566,571
567,568
567,569
568,569
568,570
569,570
571,572
572,573
572,574
573,574
576,577
576,578
577,578
578,579
578,580
578,581
578,582
578,583
578,584
578,585
579,580
581,582
581,583
582,583
582,584
583,584
587,588
587,589
588,589
591,592
593,594
594,595
594,596
594,597
595,596
595,597
596,597
599,600
601,602
601,603
602,603
605,606
605,607
606,607
609,610
609,611
610,611
610,612
611,612
614,615
615,616
617,618
618,619
618,620
619,620
619,621
620,621
623,624
625,626
626,627
626,628
627,628
627,629
628,629
631,632
633,634
634,635
634,636
634,637
634,638
635,636
637,638
639,640
639,641
640,641
642,643
644,645
646,647
647,648
647,649
648,649
650,651
653,654
654,655
654,656
654,657
655,656
657,658
659,660
661,662
661,663
661,664
661,665
661,666
661,667
661,668
661,669
661,670
661,671
661,672
661,673
662,663
663,664
663,665
664,665
666,667
666,668
668,669
669,670
669,671
670,671
673,674
674,675
674,676
675,676
677,678
679,680
680,681
680,682
681,682
683,684
683,685
685,686
686,687
686,688
687,688
689,690
691,692
692,693
692,694
693,694
695,696
697,698
697,699
698,699
698,700
699,700
699,701
699,702
699,703
699,704
699,705
700,701
702,703
704,705
706,707
708,709
710,711
711,712
713,714
715,716
715,717
715,718
715,719
716,717
717,718
717,719
718,719
720,721
722,723
722,724
723,724
724,725
724,726
724,727
724,728
725,726
727,728
729,730
731,732
732,733
734,735
735,736
735,737
736,737
738,739
738,740
739,740
742,743
743,744
743,745
744,745
746,747
749,750
750,751
750,752
750,753
750,754
751,752
753,754
755,756
757,758
759,760
760,761
760,762
761,762
763,764
765,766
766,767
766,768
767,768
769,770
771,772
772,773
772,774
773,774
775,776
777,778
777,779
777,780
778,779
779,780
779,781
779,782
779,783
780,781
782,783
784,785
786,787
787,788
789,790
790,791
790,792
791,792
793,794
793,795
794,795
797,798
798,799
798,800
798,801
798,802
799,800
801,802
803,804
805,806
807,808
808,809
808,810
809,810
811,812
814,815
815,816
815,817
816,817
818,819
818,820
819,820
822,823
823,824
823,825
824,825
824,826
825,826
828,829
830,831
831,832
831,833
832,833
834,835
836,837
837,838
838,839
-----nextToken-----
3,5,8,10,15,17,21,23,27,29,33,35,39,43,44,45,49,51,53,57,59,63,65,69,71,74,78,80,84,87,89,92,93,96,97,101,103,108,110,113,118,121,123,126,129,131,136,137,141,142,146,151,152,155,156,160,161,165,166,169,173,177,178,179,183,185,190,193,197,201,202,205,206,211,212,213,219,220,221,223,227,231,232,238,239,242,243,249,250,254,255,259,260,264,268,269,272,273,278,281,282,286,292,293,296,297,301,306,307,308,312,313,317,321,322,325,326,332,333,338,339,341,346,349,351,354,355,358,359,363,364,367,372,373,375,379,383,384,385,389,391,396,397,399,404,405,409,411,415,418,420,425,426,427,432,434,436,441,443,445,450,451,453,458,459,461,465,467,470,472,474,478,481,482,485,486,489,490,492,495,496,500,502,503,506,511,512,513,518,520,524,526,530,533,535,539,541,543,547,552,553,554,558,559,562,565,570,574,575,580,584,585,586,589,590,592,597,598,600,603,604,607,608,612,613,616,621,622,624,629,630,632,636,638,641,643,645,649,651,652,656,658,660,665,667,671,672,676,678,682,684,688,690,694,696,701,703,705,707,709,712,714,719,721,726,728,730,733,737,740,741,745,747,748,752,754,756,758,762,764,768,770,774,776,781,783,785,788,792,795,796,800,802,804,806,810,812,813,817,820,821,826,827,829,833,835,839
-----computeFrom-----
67,68
67,69
82,83
82,84
99,100
99,101
116,117
116,118
124,125
124,126
144,145
144,146
148,149
148,150
171,172
171,173
181,182
181,183
188,189
188,190
198,199
198,200
208,209
208,210
215,216
215,217
234,235
234,236
235,236
235,237
245,246
245,247
246,247
246,248
256,257
256,258
265,266
265,267
289,290
289,291
318,319
318,320
328,329
328,330
335,336
335,337
360,361
360,362
369,370
369,371
377,378
377,379
393,394
393,395
413,414
413,415
422,423
422,424
447,448
447,449
455,456
455,457
498,499
498,500
508,509
508,510
528,529
528,530
568,569
568,570
609,610
609,611
618,619
618,620
626,627
626,628
647,648
647,649
698,699
698,700
735,736
735,737
743,744
743,745
760,761
760,762
772,773
772,774
790,791
790,792
808,809
808,810
815,816
815,817
823,824
823,825
-----guardedBy-----
101,110
183,223
250,282
269,359
272,383
243,293
273,355
255,297
264,317
239,373
259,384
338,363
339,364
341,367
425,436
511,621
574,621
575,622
705,730
703,728
-----guardedByNegation-----
183,384
425,450
-----lastLexicalUse-----
183,384
425,450
-----jump-----
183,384
425,450
-----attribute-----
FunctionDefinition;NamedTypeSpecifier;Name;FunctionDeclarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;IdExpression;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;SwitchStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;CaseStatement;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;UnaryExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;UnaryExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;UnaryExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;ConditionalExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BreakStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ContinueStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ContinueStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;UnaryExpression;IdExpression;Name;
-----ast_node-----
vm_map_t vm_map_fork(vm_map_t old_map){	vm_map_t	new_map;	vm_map_entry_t	old_entry;	vm_map_entry_t	new_entry;	pmap_t		new_pmap = pmap_create((vm_size_t) 0);	vm_size_t	new_size = 0;	vm_size_t	entry_size;	vm_object_t	object;	if (new_pmap == PMAP_NULL)		return VM_MAP_NULL;	vm_map_lock(old_map);	new_map = vm_map_create(new_pmap,			old_map->min_offset,			old_map->max_offset);	if (new_pmap == PMAP_NULL) {		pmap_destroy(new_pmap);		return VM_MAP_NULL;	}	for (	    old_entry = vm_map_first_entry(old_map);	    old_entry != vm_map_to_entry(old_map);	    ) {		if (old_entry->is_sub_map)			panic("vm_map_fork: encountered a submap");		entry_size = (old_entry->vme_end - old_entry->vme_start);		switch (old_entry->inheritance) {		case VM_INHERIT_NONE:			break;		case VM_INHERIT_SHARE:		        /*			 *	New sharing code.  New map entry			 *	references original object.  Temporary			 *	objects use asynchronous copy algorithm for			 *	future copies.  First make sure we have			 *	the right object.  If we need a shadow,			 *	or someone else already has one, then			 *	make a new shadow and share it.			 */			object = old_entry->object.vm_object;			if (object == VM_OBJECT_NULL) {				object = vm_object_allocate(					    (vm_size_t)(old_entry->vme_end -							old_entry->vme_start));				old_entry->offset = 0;				old_entry->object.vm_object = object;				assert(!old_entry->needs_copy);			}			else if (old_entry->needs_copy || object->shadowed ||			    (object->temporary && !old_entry->is_shared &&			     object->size > (vm_size_t)(old_entry->vme_end -						old_entry->vme_start))) {			    assert(object->temporary);			    assert(!(object->shadowed && old_entry->is_shared));			    vm_object_shadow(			        &old_entry->object.vm_object,			        &old_entry->offset,			        (vm_size_t) (old_entry->vme_end -					     old_entry->vme_start));			    /*			     *	If we're making a shadow for other than			     *	copy on write reasons, then we have			     *	to remove write permission.			     */			    if (!old_entry->needs_copy &&				(old_entry->protection & VM_PROT_WRITE)) {			    	pmap_protect(vm_map_pmap(old_map),					     old_entry->vme_start,					     old_entry->vme_end,					     old_entry->protection &					     	~VM_PROT_WRITE);			    }			    old_entry->needs_copy = FALSE;			    object = old_entry->object.vm_object;			}			/*			 *	Set use_shared_copy to indicate that			 *	object must use shared (delayed) copy-on			 *	write.  This is ignored for permanent objects.			 *	Bump the reference count for the new entry			 */			vm_object_lock(object);			object->use_shared_copy = TRUE;			object->ref_count++;			vm_object_unlock(object);			new_entry = vm_map_entry_create(new_map);			if (old_entry->projected_on != 0) {			  /*			   *   If entry is projected buffer, clone the                           *   entry exactly.                           */			  vm_map_entry_copy_full(new_entry, old_entry);			} else {			  /*			   *	Clone the entry, using object ref from above.			   *	Mark both entries as shared.			   */			  vm_map_entry_copy(new_entry, old_entry);			  old_entry->is_shared = TRUE;			  new_entry->is_shared = TRUE;			}			/*			 *	Insert the entry into the new map -- we			 *	know we're inserting at the end of the new			 *	map.			 */			vm_map_entry_link(				new_map,				vm_map_last_entry(new_map),				new_entry);			/*			 *	Update the physical map			 */			pmap_copy(new_map->pmap, old_map->pmap,				new_entry->vme_start,				entry_size,				old_entry->vme_start);			new_size += entry_size;			break;		case VM_INHERIT_COPY:			if (old_entry->wired_count == 0) {				boolean_t	src_needs_copy;				boolean_t	new_entry_needs_copy;				new_entry = vm_map_entry_create(new_map);				vm_map_entry_copy(new_entry, old_entry);				if (vm_object_copy_temporary(					&new_entry->object.vm_object,					&new_entry->offset,					&src_needs_copy,					&new_entry_needs_copy)) {					/*					 *	Handle copy-on-write obligations					 */					if (src_needs_copy && !old_entry->needs_copy) {						vm_object_pmap_protect(							old_entry->object.vm_object,							old_entry->offset,							entry_size,							(old_entry->is_shared ?								PMAP_NULL :								old_map->pmap),							old_entry->vme_start,							old_entry->protection &							    ~VM_PROT_WRITE);						old_entry->needs_copy = TRUE;					}					new_entry->needs_copy = new_entry_needs_copy;					/*					 *	Insert the entry at the end					 *	of the map.					 */					vm_map_entry_link(new_map,						vm_map_last_entry(new_map),						new_entry);					new_size += entry_size;					break;				}				vm_map_entry_dispose(new_map, new_entry);			}			/* INNER BLOCK (copy cannot be optimized) */ {			vm_offset_t	start = old_entry->vme_start;			vm_map_copy_t	copy;			vm_map_entry_t	last = vm_map_last_entry(new_map);			vm_map_unlock(old_map);			if (vm_map_copyin(old_map,					start,					entry_size,					FALSE,					&copy)			    != KERN_SUCCESS) {			    	vm_map_lock(old_map);				if (!vm_map_lookup_entry(old_map, start, &last))					last = last->vme_next;				old_entry = last;				/*				 *	For some error returns, want to				 *	skip to the next element.				 */				continue;			}			/*			 *	Insert the copy into the new map			 */			vm_map_copy_insert(new_map, last, copy);			new_size += entry_size;			/*			 *	Pick up the traversal at the end of			 *	the copied region.			 */			vm_map_lock(old_map);			start += entry_size;			if (!vm_map_lookup_entry(old_map, start, &last))				last = last->vme_next;			 else				vm_map_clip_start(old_map, last, start);			old_entry = last;			continue;			/* INNER BLOCK (copy cannot be optimized) */ }		}		old_entry = old_entry->vme_next;	}	new_map->size = new_size;	vm_map_unlock(old_map);	return(new_map);}
vm_map_t
vm_map_t
vm_map_fork(vm_map_t old_map)
vm_map_fork
vm_map_t old_map
vm_map_t
vm_map_t
old_map
old_map
{	vm_map_t	new_map;	vm_map_entry_t	old_entry;	vm_map_entry_t	new_entry;	pmap_t		new_pmap = pmap_create((vm_size_t) 0);	vm_size_t	new_size = 0;	vm_size_t	entry_size;	vm_object_t	object;	if (new_pmap == PMAP_NULL)		return VM_MAP_NULL;	vm_map_lock(old_map);	new_map = vm_map_create(new_pmap,			old_map->min_offset,			old_map->max_offset);	if (new_pmap == PMAP_NULL) {		pmap_destroy(new_pmap);		return VM_MAP_NULL;	}	for (	    old_entry = vm_map_first_entry(old_map);	    old_entry != vm_map_to_entry(old_map);	    ) {		if (old_entry->is_sub_map)			panic("vm_map_fork: encountered a submap");		entry_size = (old_entry->vme_end - old_entry->vme_start);		switch (old_entry->inheritance) {		case VM_INHERIT_NONE:			break;		case VM_INHERIT_SHARE:		        /*			 *	New sharing code.  New map entry			 *	references original object.  Temporary			 *	objects use asynchronous copy algorithm for			 *	future copies.  First make sure we have			 *	the right object.  If we need a shadow,			 *	or someone else already has one, then			 *	make a new shadow and share it.			 */			object = old_entry->object.vm_object;			if (object == VM_OBJECT_NULL) {				object = vm_object_allocate(					    (vm_size_t)(old_entry->vme_end -							old_entry->vme_start));				old_entry->offset = 0;				old_entry->object.vm_object = object;				assert(!old_entry->needs_copy);			}			else if (old_entry->needs_copy || object->shadowed ||			    (object->temporary && !old_entry->is_shared &&			     object->size > (vm_size_t)(old_entry->vme_end -						old_entry->vme_start))) {			    assert(object->temporary);			    assert(!(object->shadowed && old_entry->is_shared));			    vm_object_shadow(			        &old_entry->object.vm_object,			        &old_entry->offset,			        (vm_size_t) (old_entry->vme_end -					     old_entry->vme_start));			    /*			     *	If we're making a shadow for other than			     *	copy on write reasons, then we have			     *	to remove write permission.			     */			    if (!old_entry->needs_copy &&				(old_entry->protection & VM_PROT_WRITE)) {			    	pmap_protect(vm_map_pmap(old_map),					     old_entry->vme_start,					     old_entry->vme_end,					     old_entry->protection &					     	~VM_PROT_WRITE);			    }			    old_entry->needs_copy = FALSE;			    object = old_entry->object.vm_object;			}			/*			 *	Set use_shared_copy to indicate that			 *	object must use shared (delayed) copy-on			 *	write.  This is ignored for permanent objects.			 *	Bump the reference count for the new entry			 */			vm_object_lock(object);			object->use_shared_copy = TRUE;			object->ref_count++;			vm_object_unlock(object);			new_entry = vm_map_entry_create(new_map);			if (old_entry->projected_on != 0) {			  /*			   *   If entry is projected buffer, clone the                           *   entry exactly.                           */			  vm_map_entry_copy_full(new_entry, old_entry);			} else {			  /*			   *	Clone the entry, using object ref from above.			   *	Mark both entries as shared.			   */			  vm_map_entry_copy(new_entry, old_entry);			  old_entry->is_shared = TRUE;			  new_entry->is_shared = TRUE;			}			/*			 *	Insert the entry into the new map -- we			 *	know we're inserting at the end of the new			 *	map.			 */			vm_map_entry_link(				new_map,				vm_map_last_entry(new_map),				new_entry);			/*			 *	Update the physical map			 */			pmap_copy(new_map->pmap, old_map->pmap,				new_entry->vme_start,				entry_size,				old_entry->vme_start);			new_size += entry_size;			break;		case VM_INHERIT_COPY:			if (old_entry->wired_count == 0) {				boolean_t	src_needs_copy;				boolean_t	new_entry_needs_copy;				new_entry = vm_map_entry_create(new_map);				vm_map_entry_copy(new_entry, old_entry);				if (vm_object_copy_temporary(					&new_entry->object.vm_object,					&new_entry->offset,					&src_needs_copy,					&new_entry_needs_copy)) {					/*					 *	Handle copy-on-write obligations					 */					if (src_needs_copy && !old_entry->needs_copy) {						vm_object_pmap_protect(							old_entry->object.vm_object,							old_entry->offset,							entry_size,							(old_entry->is_shared ?								PMAP_NULL :								old_map->pmap),							old_entry->vme_start,							old_entry->protection &							    ~VM_PROT_WRITE);						old_entry->needs_copy = TRUE;					}					new_entry->needs_copy = new_entry_needs_copy;					/*					 *	Insert the entry at the end					 *	of the map.					 */					vm_map_entry_link(new_map,						vm_map_last_entry(new_map),						new_entry);					new_size += entry_size;					break;				}				vm_map_entry_dispose(new_map, new_entry);			}			/* INNER BLOCK (copy cannot be optimized) */ {			vm_offset_t	start = old_entry->vme_start;			vm_map_copy_t	copy;			vm_map_entry_t	last = vm_map_last_entry(new_map);			vm_map_unlock(old_map);			if (vm_map_copyin(old_map,					start,					entry_size,					FALSE,					&copy)			    != KERN_SUCCESS) {			    	vm_map_lock(old_map);				if (!vm_map_lookup_entry(old_map, start, &last))					last = last->vme_next;				old_entry = last;				/*				 *	For some error returns, want to				 *	skip to the next element.				 */				continue;			}			/*			 *	Insert the copy into the new map			 */			vm_map_copy_insert(new_map, last, copy);			new_size += entry_size;			/*			 *	Pick up the traversal at the end of			 *	the copied region.			 */			vm_map_lock(old_map);			start += entry_size;			if (!vm_map_lookup_entry(old_map, start, &last))				last = last->vme_next;			 else				vm_map_clip_start(old_map, last, start);			old_entry = last;			continue;			/* INNER BLOCK (copy cannot be optimized) */ }		}		old_entry = old_entry->vme_next;	}	new_map->size = new_size;	vm_map_unlock(old_map);	return(new_map);}
vm_map_t	new_map;
vm_map_t	new_map;
vm_map_t
vm_map_t
new_map
new_map
vm_map_entry_t	old_entry;
vm_map_entry_t	old_entry;
vm_map_entry_t
vm_map_entry_t
old_entry
old_entry
vm_map_entry_t	new_entry;
vm_map_entry_t	new_entry;
vm_map_entry_t
vm_map_entry_t
new_entry
new_entry
pmap_t		new_pmap = pmap_create((vm_size_t) 0);
pmap_t		new_pmap = pmap_create((vm_size_t) 0);
pmap_t
pmap_t
new_pmap = pmap_create((vm_size_t) 0)
new_pmap
= pmap_create((vm_size_t) 0)
pmap_create((vm_size_t) 0)
pmap_create
pmap_create
(vm_size_t) 0
vm_size_t
vm_size_t
vm_size_t

0
vm_size_t	new_size = 0;
vm_size_t	new_size = 0;
vm_size_t
vm_size_t
new_size = 0
new_size
= 0
0
vm_size_t	entry_size;
vm_size_t	entry_size;
vm_size_t
vm_size_t
entry_size
entry_size
vm_object_t	object;
vm_object_t	object;
vm_object_t
vm_object_t
object
object
if (new_pmap == PMAP_NULL)		return VM_MAP_NULL;
new_pmap == PMAP_NULL
new_pmap
new_pmap
PMAP_NULL
PMAP_NULL
return VM_MAP_NULL;
VM_MAP_NULL
VM_MAP_NULL
vm_map_lock(old_map);
vm_map_lock(old_map)
vm_map_lock
vm_map_lock
old_map
old_map
new_map = vm_map_create(new_pmap,			old_map->min_offset,			old_map->max_offset);
new_map = vm_map_create(new_pmap,			old_map->min_offset,			old_map->max_offset)
new_map
new_map
vm_map_create(new_pmap,			old_map->min_offset,			old_map->max_offset)
vm_map_create
vm_map_create
new_pmap
new_pmap
old_map->min_offset
old_map
old_map
min_offset
old_map->max_offset
old_map
old_map
max_offset
if (new_pmap == PMAP_NULL) {		pmap_destroy(new_pmap);		return VM_MAP_NULL;	}
new_pmap == PMAP_NULL
new_pmap
new_pmap
PMAP_NULL
PMAP_NULL
{		pmap_destroy(new_pmap);		return VM_MAP_NULL;	}
pmap_destroy(new_pmap);
pmap_destroy(new_pmap)
pmap_destroy
pmap_destroy
new_pmap
new_pmap
return VM_MAP_NULL;
VM_MAP_NULL
VM_MAP_NULL
for (	    old_entry = vm_map_first_entry(old_map);	    old_entry != vm_map_to_entry(old_map);	    ) {		if (old_entry->is_sub_map)			panic("vm_map_fork: encountered a submap");		entry_size = (old_entry->vme_end - old_entry->vme_start);		switch (old_entry->inheritance) {		case VM_INHERIT_NONE:			break;		case VM_INHERIT_SHARE:		        /*			 *	New sharing code.  New map entry			 *	references original object.  Temporary			 *	objects use asynchronous copy algorithm for			 *	future copies.  First make sure we have			 *	the right object.  If we need a shadow,			 *	or someone else already has one, then			 *	make a new shadow and share it.			 */			object = old_entry->object.vm_object;			if (object == VM_OBJECT_NULL) {				object = vm_object_allocate(					    (vm_size_t)(old_entry->vme_end -							old_entry->vme_start));				old_entry->offset = 0;				old_entry->object.vm_object = object;				assert(!old_entry->needs_copy);			}			else if (old_entry->needs_copy || object->shadowed ||			    (object->temporary && !old_entry->is_shared &&			     object->size > (vm_size_t)(old_entry->vme_end -						old_entry->vme_start))) {			    assert(object->temporary);			    assert(!(object->shadowed && old_entry->is_shared));			    vm_object_shadow(			        &old_entry->object.vm_object,			        &old_entry->offset,			        (vm_size_t) (old_entry->vme_end -					     old_entry->vme_start));			    /*			     *	If we're making a shadow for other than			     *	copy on write reasons, then we have			     *	to remove write permission.			     */			    if (!old_entry->needs_copy &&				(old_entry->protection & VM_PROT_WRITE)) {			    	pmap_protect(vm_map_pmap(old_map),					     old_entry->vme_start,					     old_entry->vme_end,					     old_entry->protection &					     	~VM_PROT_WRITE);			    }			    old_entry->needs_copy = FALSE;			    object = old_entry->object.vm_object;			}			/*			 *	Set use_shared_copy to indicate that			 *	object must use shared (delayed) copy-on			 *	write.  This is ignored for permanent objects.			 *	Bump the reference count for the new entry			 */			vm_object_lock(object);			object->use_shared_copy = TRUE;			object->ref_count++;			vm_object_unlock(object);			new_entry = vm_map_entry_create(new_map);			if (old_entry->projected_on != 0) {			  /*			   *   If entry is projected buffer, clone the                           *   entry exactly.                           */			  vm_map_entry_copy_full(new_entry, old_entry);			} else {			  /*			   *	Clone the entry, using object ref from above.			   *	Mark both entries as shared.			   */			  vm_map_entry_copy(new_entry, old_entry);			  old_entry->is_shared = TRUE;			  new_entry->is_shared = TRUE;			}			/*			 *	Insert the entry into the new map -- we			 *	know we're inserting at the end of the new			 *	map.			 */			vm_map_entry_link(				new_map,				vm_map_last_entry(new_map),				new_entry);			/*			 *	Update the physical map			 */			pmap_copy(new_map->pmap, old_map->pmap,				new_entry->vme_start,				entry_size,				old_entry->vme_start);			new_size += entry_size;			break;		case VM_INHERIT_COPY:			if (old_entry->wired_count == 0) {				boolean_t	src_needs_copy;				boolean_t	new_entry_needs_copy;				new_entry = vm_map_entry_create(new_map);				vm_map_entry_copy(new_entry, old_entry);				if (vm_object_copy_temporary(					&new_entry->object.vm_object,					&new_entry->offset,					&src_needs_copy,					&new_entry_needs_copy)) {					/*					 *	Handle copy-on-write obligations					 */					if (src_needs_copy && !old_entry->needs_copy) {						vm_object_pmap_protect(							old_entry->object.vm_object,							old_entry->offset,							entry_size,							(old_entry->is_shared ?								PMAP_NULL :								old_map->pmap),							old_entry->vme_start,							old_entry->protection &							    ~VM_PROT_WRITE);						old_entry->needs_copy = TRUE;					}					new_entry->needs_copy = new_entry_needs_copy;					/*					 *	Insert the entry at the end					 *	of the map.					 */					vm_map_entry_link(new_map,						vm_map_last_entry(new_map),						new_entry);					new_size += entry_size;					break;				}				vm_map_entry_dispose(new_map, new_entry);			}			/* INNER BLOCK (copy cannot be optimized) */ {			vm_offset_t	start = old_entry->vme_start;			vm_map_copy_t	copy;			vm_map_entry_t	last = vm_map_last_entry(new_map);			vm_map_unlock(old_map);			if (vm_map_copyin(old_map,					start,					entry_size,					FALSE,					&copy)			    != KERN_SUCCESS) {			    	vm_map_lock(old_map);				if (!vm_map_lookup_entry(old_map, start, &last))					last = last->vme_next;				old_entry = last;				/*				 *	For some error returns, want to				 *	skip to the next element.				 */				continue;			}			/*			 *	Insert the copy into the new map			 */			vm_map_copy_insert(new_map, last, copy);			new_size += entry_size;			/*			 *	Pick up the traversal at the end of			 *	the copied region.			 */			vm_map_lock(old_map);			start += entry_size;			if (!vm_map_lookup_entry(old_map, start, &last))				last = last->vme_next;			 else				vm_map_clip_start(old_map, last, start);			old_entry = last;			continue;			/* INNER BLOCK (copy cannot be optimized) */ }		}		old_entry = old_entry->vme_next;	}
old_entry = vm_map_first_entry(old_map);
old_entry = vm_map_first_entry(old_map)
old_entry
old_entry
vm_map_first_entry(old_map)
vm_map_first_entry
vm_map_first_entry
old_map
old_map
old_entry != vm_map_to_entry(old_map)
old_entry
old_entry
vm_map_to_entry(old_map)
vm_map_to_entry
vm_map_to_entry
old_map
old_map
{		if (old_entry->is_sub_map)			panic("vm_map_fork: encountered a submap");		entry_size = (old_entry->vme_end - old_entry->vme_start);		switch (old_entry->inheritance) {		case VM_INHERIT_NONE:			break;		case VM_INHERIT_SHARE:		        /*			 *	New sharing code.  New map entry			 *	references original object.  Temporary			 *	objects use asynchronous copy algorithm for			 *	future copies.  First make sure we have			 *	the right object.  If we need a shadow,			 *	or someone else already has one, then			 *	make a new shadow and share it.			 */			object = old_entry->object.vm_object;			if (object == VM_OBJECT_NULL) {				object = vm_object_allocate(					    (vm_size_t)(old_entry->vme_end -							old_entry->vme_start));				old_entry->offset = 0;				old_entry->object.vm_object = object;				assert(!old_entry->needs_copy);			}			else if (old_entry->needs_copy || object->shadowed ||			    (object->temporary && !old_entry->is_shared &&			     object->size > (vm_size_t)(old_entry->vme_end -						old_entry->vme_start))) {			    assert(object->temporary);			    assert(!(object->shadowed && old_entry->is_shared));			    vm_object_shadow(			        &old_entry->object.vm_object,			        &old_entry->offset,			        (vm_size_t) (old_entry->vme_end -					     old_entry->vme_start));			    /*			     *	If we're making a shadow for other than			     *	copy on write reasons, then we have			     *	to remove write permission.			     */			    if (!old_entry->needs_copy &&				(old_entry->protection & VM_PROT_WRITE)) {			    	pmap_protect(vm_map_pmap(old_map),					     old_entry->vme_start,					     old_entry->vme_end,					     old_entry->protection &					     	~VM_PROT_WRITE);			    }			    old_entry->needs_copy = FALSE;			    object = old_entry->object.vm_object;			}			/*			 *	Set use_shared_copy to indicate that			 *	object must use shared (delayed) copy-on			 *	write.  This is ignored for permanent objects.			 *	Bump the reference count for the new entry			 */			vm_object_lock(object);			object->use_shared_copy = TRUE;			object->ref_count++;			vm_object_unlock(object);			new_entry = vm_map_entry_create(new_map);			if (old_entry->projected_on != 0) {			  /*			   *   If entry is projected buffer, clone the                           *   entry exactly.                           */			  vm_map_entry_copy_full(new_entry, old_entry);			} else {			  /*			   *	Clone the entry, using object ref from above.			   *	Mark both entries as shared.			   */			  vm_map_entry_copy(new_entry, old_entry);			  old_entry->is_shared = TRUE;			  new_entry->is_shared = TRUE;			}			/*			 *	Insert the entry into the new map -- we			 *	know we're inserting at the end of the new			 *	map.			 */			vm_map_entry_link(				new_map,				vm_map_last_entry(new_map),				new_entry);			/*			 *	Update the physical map			 */			pmap_copy(new_map->pmap, old_map->pmap,				new_entry->vme_start,				entry_size,				old_entry->vme_start);			new_size += entry_size;			break;		case VM_INHERIT_COPY:			if (old_entry->wired_count == 0) {				boolean_t	src_needs_copy;				boolean_t	new_entry_needs_copy;				new_entry = vm_map_entry_create(new_map);				vm_map_entry_copy(new_entry, old_entry);				if (vm_object_copy_temporary(					&new_entry->object.vm_object,					&new_entry->offset,					&src_needs_copy,					&new_entry_needs_copy)) {					/*					 *	Handle copy-on-write obligations					 */					if (src_needs_copy && !old_entry->needs_copy) {						vm_object_pmap_protect(							old_entry->object.vm_object,							old_entry->offset,							entry_size,							(old_entry->is_shared ?								PMAP_NULL :								old_map->pmap),							old_entry->vme_start,							old_entry->protection &							    ~VM_PROT_WRITE);						old_entry->needs_copy = TRUE;					}					new_entry->needs_copy = new_entry_needs_copy;					/*					 *	Insert the entry at the end					 *	of the map.					 */					vm_map_entry_link(new_map,						vm_map_last_entry(new_map),						new_entry);					new_size += entry_size;					break;				}				vm_map_entry_dispose(new_map, new_entry);			}			/* INNER BLOCK (copy cannot be optimized) */ {			vm_offset_t	start = old_entry->vme_start;			vm_map_copy_t	copy;			vm_map_entry_t	last = vm_map_last_entry(new_map);			vm_map_unlock(old_map);			if (vm_map_copyin(old_map,					start,					entry_size,					FALSE,					&copy)			    != KERN_SUCCESS) {			    	vm_map_lock(old_map);				if (!vm_map_lookup_entry(old_map, start, &last))					last = last->vme_next;				old_entry = last;				/*				 *	For some error returns, want to				 *	skip to the next element.				 */				continue;			}			/*			 *	Insert the copy into the new map			 */			vm_map_copy_insert(new_map, last, copy);			new_size += entry_size;			/*			 *	Pick up the traversal at the end of			 *	the copied region.			 */			vm_map_lock(old_map);			start += entry_size;			if (!vm_map_lookup_entry(old_map, start, &last))				last = last->vme_next;			 else				vm_map_clip_start(old_map, last, start);			old_entry = last;			continue;			/* INNER BLOCK (copy cannot be optimized) */ }		}		old_entry = old_entry->vme_next;	}
if (old_entry->is_sub_map)			panic("vm_map_fork: encountered a submap");
old_entry->is_sub_map
old_entry
old_entry
is_sub_map
panic("vm_map_fork: encountered a submap");
panic("vm_map_fork: encountered a submap")
panic
panic
"vm_map_fork: encountered a submap"
entry_size = (old_entry->vme_end - old_entry->vme_start);
entry_size = (old_entry->vme_end - old_entry->vme_start)
entry_size
entry_size
(old_entry->vme_end - old_entry->vme_start)
old_entry->vme_end - old_entry->vme_start
old_entry->vme_end
old_entry
old_entry
vme_end
old_entry->vme_start
old_entry
old_entry
vme_start
switch (old_entry->inheritance) {		case VM_INHERIT_NONE:			break;		case VM_INHERIT_SHARE:		        /*			 *	New sharing code.  New map entry			 *	references original object.  Temporary			 *	objects use asynchronous copy algorithm for			 *	future copies.  First make sure we have			 *	the right object.  If we need a shadow,			 *	or someone else already has one, then			 *	make a new shadow and share it.			 */			object = old_entry->object.vm_object;			if (object == VM_OBJECT_NULL) {				object = vm_object_allocate(					    (vm_size_t)(old_entry->vme_end -							old_entry->vme_start));				old_entry->offset = 0;				old_entry->object.vm_object = object;				assert(!old_entry->needs_copy);			}			else if (old_entry->needs_copy || object->shadowed ||			    (object->temporary && !old_entry->is_shared &&			     object->size > (vm_size_t)(old_entry->vme_end -						old_entry->vme_start))) {			    assert(object->temporary);			    assert(!(object->shadowed && old_entry->is_shared));			    vm_object_shadow(			        &old_entry->object.vm_object,			        &old_entry->offset,			        (vm_size_t) (old_entry->vme_end -					     old_entry->vme_start));			    /*			     *	If we're making a shadow for other than			     *	copy on write reasons, then we have			     *	to remove write permission.			     */			    if (!old_entry->needs_copy &&				(old_entry->protection & VM_PROT_WRITE)) {			    	pmap_protect(vm_map_pmap(old_map),					     old_entry->vme_start,					     old_entry->vme_end,					     old_entry->protection &					     	~VM_PROT_WRITE);			    }			    old_entry->needs_copy = FALSE;			    object = old_entry->object.vm_object;			}			/*			 *	Set use_shared_copy to indicate that			 *	object must use shared (delayed) copy-on			 *	write.  This is ignored for permanent objects.			 *	Bump the reference count for the new entry			 */			vm_object_lock(object);			object->use_shared_copy = TRUE;			object->ref_count++;			vm_object_unlock(object);			new_entry = vm_map_entry_create(new_map);			if (old_entry->projected_on != 0) {			  /*			   *   If entry is projected buffer, clone the                           *   entry exactly.                           */			  vm_map_entry_copy_full(new_entry, old_entry);			} else {			  /*			   *	Clone the entry, using object ref from above.			   *	Mark both entries as shared.			   */			  vm_map_entry_copy(new_entry, old_entry);			  old_entry->is_shared = TRUE;			  new_entry->is_shared = TRUE;			}			/*			 *	Insert the entry into the new map -- we			 *	know we're inserting at the end of the new			 *	map.			 */			vm_map_entry_link(				new_map,				vm_map_last_entry(new_map),				new_entry);			/*			 *	Update the physical map			 */			pmap_copy(new_map->pmap, old_map->pmap,				new_entry->vme_start,				entry_size,				old_entry->vme_start);			new_size += entry_size;			break;		case VM_INHERIT_COPY:			if (old_entry->wired_count == 0) {				boolean_t	src_needs_copy;				boolean_t	new_entry_needs_copy;				new_entry = vm_map_entry_create(new_map);				vm_map_entry_copy(new_entry, old_entry);				if (vm_object_copy_temporary(					&new_entry->object.vm_object,					&new_entry->offset,					&src_needs_copy,					&new_entry_needs_copy)) {					/*					 *	Handle copy-on-write obligations					 */					if (src_needs_copy && !old_entry->needs_copy) {						vm_object_pmap_protect(							old_entry->object.vm_object,							old_entry->offset,							entry_size,							(old_entry->is_shared ?								PMAP_NULL :								old_map->pmap),							old_entry->vme_start,							old_entry->protection &							    ~VM_PROT_WRITE);						old_entry->needs_copy = TRUE;					}					new_entry->needs_copy = new_entry_needs_copy;					/*					 *	Insert the entry at the end					 *	of the map.					 */					vm_map_entry_link(new_map,						vm_map_last_entry(new_map),						new_entry);					new_size += entry_size;					break;				}				vm_map_entry_dispose(new_map, new_entry);			}			/* INNER BLOCK (copy cannot be optimized) */ {			vm_offset_t	start = old_entry->vme_start;			vm_map_copy_t	copy;			vm_map_entry_t	last = vm_map_last_entry(new_map);			vm_map_unlock(old_map);			if (vm_map_copyin(old_map,					start,					entry_size,					FALSE,					&copy)			    != KERN_SUCCESS) {			    	vm_map_lock(old_map);				if (!vm_map_lookup_entry(old_map, start, &last))					last = last->vme_next;				old_entry = last;				/*				 *	For some error returns, want to				 *	skip to the next element.				 */				continue;			}			/*			 *	Insert the copy into the new map			 */			vm_map_copy_insert(new_map, last, copy);			new_size += entry_size;			/*			 *	Pick up the traversal at the end of			 *	the copied region.			 */			vm_map_lock(old_map);			start += entry_size;			if (!vm_map_lookup_entry(old_map, start, &last))				last = last->vme_next;			 else				vm_map_clip_start(old_map, last, start);			old_entry = last;			continue;			/* INNER BLOCK (copy cannot be optimized) */ }		}
old_entry->inheritance
old_entry
old_entry
inheritance
{		case VM_INHERIT_NONE:			break;		case VM_INHERIT_SHARE:		        /*			 *	New sharing code.  New map entry			 *	references original object.  Temporary			 *	objects use asynchronous copy algorithm for			 *	future copies.  First make sure we have			 *	the right object.  If we need a shadow,			 *	or someone else already has one, then			 *	make a new shadow and share it.			 */			object = old_entry->object.vm_object;			if (object == VM_OBJECT_NULL) {				object = vm_object_allocate(					    (vm_size_t)(old_entry->vme_end -							old_entry->vme_start));				old_entry->offset = 0;				old_entry->object.vm_object = object;				assert(!old_entry->needs_copy);			}			else if (old_entry->needs_copy || object->shadowed ||			    (object->temporary && !old_entry->is_shared &&			     object->size > (vm_size_t)(old_entry->vme_end -						old_entry->vme_start))) {			    assert(object->temporary);			    assert(!(object->shadowed && old_entry->is_shared));			    vm_object_shadow(			        &old_entry->object.vm_object,			        &old_entry->offset,			        (vm_size_t) (old_entry->vme_end -					     old_entry->vme_start));			    /*			     *	If we're making a shadow for other than			     *	copy on write reasons, then we have			     *	to remove write permission.			     */			    if (!old_entry->needs_copy &&				(old_entry->protection & VM_PROT_WRITE)) {			    	pmap_protect(vm_map_pmap(old_map),					     old_entry->vme_start,					     old_entry->vme_end,					     old_entry->protection &					     	~VM_PROT_WRITE);			    }			    old_entry->needs_copy = FALSE;			    object = old_entry->object.vm_object;			}			/*			 *	Set use_shared_copy to indicate that			 *	object must use shared (delayed) copy-on			 *	write.  This is ignored for permanent objects.			 *	Bump the reference count for the new entry			 */			vm_object_lock(object);			object->use_shared_copy = TRUE;			object->ref_count++;			vm_object_unlock(object);			new_entry = vm_map_entry_create(new_map);			if (old_entry->projected_on != 0) {			  /*			   *   If entry is projected buffer, clone the                           *   entry exactly.                           */			  vm_map_entry_copy_full(new_entry, old_entry);			} else {			  /*			   *	Clone the entry, using object ref from above.			   *	Mark both entries as shared.			   */			  vm_map_entry_copy(new_entry, old_entry);			  old_entry->is_shared = TRUE;			  new_entry->is_shared = TRUE;			}			/*			 *	Insert the entry into the new map -- we			 *	know we're inserting at the end of the new			 *	map.			 */			vm_map_entry_link(				new_map,				vm_map_last_entry(new_map),				new_entry);			/*			 *	Update the physical map			 */			pmap_copy(new_map->pmap, old_map->pmap,				new_entry->vme_start,				entry_size,				old_entry->vme_start);			new_size += entry_size;			break;		case VM_INHERIT_COPY:			if (old_entry->wired_count == 0) {				boolean_t	src_needs_copy;				boolean_t	new_entry_needs_copy;				new_entry = vm_map_entry_create(new_map);				vm_map_entry_copy(new_entry, old_entry);				if (vm_object_copy_temporary(					&new_entry->object.vm_object,					&new_entry->offset,					&src_needs_copy,					&new_entry_needs_copy)) {					/*					 *	Handle copy-on-write obligations					 */					if (src_needs_copy && !old_entry->needs_copy) {						vm_object_pmap_protect(							old_entry->object.vm_object,							old_entry->offset,							entry_size,							(old_entry->is_shared ?								PMAP_NULL :								old_map->pmap),							old_entry->vme_start,							old_entry->protection &							    ~VM_PROT_WRITE);						old_entry->needs_copy = TRUE;					}					new_entry->needs_copy = new_entry_needs_copy;					/*					 *	Insert the entry at the end					 *	of the map.					 */					vm_map_entry_link(new_map,						vm_map_last_entry(new_map),						new_entry);					new_size += entry_size;					break;				}				vm_map_entry_dispose(new_map, new_entry);			}			/* INNER BLOCK (copy cannot be optimized) */ {			vm_offset_t	start = old_entry->vme_start;			vm_map_copy_t	copy;			vm_map_entry_t	last = vm_map_last_entry(new_map);			vm_map_unlock(old_map);			if (vm_map_copyin(old_map,					start,					entry_size,					FALSE,					&copy)			    != KERN_SUCCESS) {			    	vm_map_lock(old_map);				if (!vm_map_lookup_entry(old_map, start, &last))					last = last->vme_next;				old_entry = last;				/*				 *	For some error returns, want to				 *	skip to the next element.				 */				continue;			}			/*			 *	Insert the copy into the new map			 */			vm_map_copy_insert(new_map, last, copy);			new_size += entry_size;			/*			 *	Pick up the traversal at the end of			 *	the copied region.			 */			vm_map_lock(old_map);			start += entry_size;			if (!vm_map_lookup_entry(old_map, start, &last))				last = last->vme_next;			 else				vm_map_clip_start(old_map, last, start);			old_entry = last;			continue;			/* INNER BLOCK (copy cannot be optimized) */ }		}
case VM_INHERIT_NONE:
VM_INHERIT_NONE
VM_INHERIT_NONE
break;
case VM_INHERIT_SHARE:
VM_INHERIT_SHARE
VM_INHERIT_SHARE
object = old_entry->object.vm_object;
object = old_entry->object.vm_object
object
object
old_entry->object.vm_object
old_entry->object
old_entry
old_entry
object
vm_object
if (object == VM_OBJECT_NULL) {				object = vm_object_allocate(					    (vm_size_t)(old_entry->vme_end -							old_entry->vme_start));				old_entry->offset = 0;				old_entry->object.vm_object = object;				assert(!old_entry->needs_copy);			}			else if (old_entry->needs_copy || object->shadowed ||			    (object->temporary && !old_entry->is_shared &&			     object->size > (vm_size_t)(old_entry->vme_end -						old_entry->vme_start))) {			    assert(object->temporary);			    assert(!(object->shadowed && old_entry->is_shared));			    vm_object_shadow(			        &old_entry->object.vm_object,			        &old_entry->offset,			        (vm_size_t) (old_entry->vme_end -					     old_entry->vme_start));			    /*			     *	If we're making a shadow for other than			     *	copy on write reasons, then we have			     *	to remove write permission.			     */			    if (!old_entry->needs_copy &&				(old_entry->protection & VM_PROT_WRITE)) {			    	pmap_protect(vm_map_pmap(old_map),					     old_entry->vme_start,					     old_entry->vme_end,					     old_entry->protection &					     	~VM_PROT_WRITE);			    }			    old_entry->needs_copy = FALSE;			    object = old_entry->object.vm_object;			}
object == VM_OBJECT_NULL
object
object
VM_OBJECT_NULL
VM_OBJECT_NULL
{				object = vm_object_allocate(					    (vm_size_t)(old_entry->vme_end -							old_entry->vme_start));				old_entry->offset = 0;				old_entry->object.vm_object = object;				assert(!old_entry->needs_copy);			}
object = vm_object_allocate(					    (vm_size_t)(old_entry->vme_end -							old_entry->vme_start));
object = vm_object_allocate(					    (vm_size_t)(old_entry->vme_end -							old_entry->vme_start))
object
object
vm_object_allocate(					    (vm_size_t)(old_entry->vme_end -							old_entry->vme_start))
vm_object_allocate
vm_object_allocate
(vm_size_t)(old_entry->vme_end -							old_entry->vme_start)
(vm_size_t)
vm_size_t
vm_size_t
old_entry->vme_end -							old_entry->vme_start
old_entry->vme_end
old_entry
old_entry
vme_end
old_entry->vme_start
old_entry
old_entry
vme_start
old_entry->offset = 0;
old_entry->offset = 0
old_entry->offset
old_entry
old_entry
offset
0
old_entry->object.vm_object = object;
old_entry->object.vm_object = object
old_entry->object.vm_object
old_entry->object
old_entry
old_entry
object
vm_object
object
object
assert(!old_entry->needs_copy);
assert(!old_entry->needs_copy)
assert
assert
!old_entry->needs_copy
old_entry->needs_copy
old_entry
old_entry
needs_copy
if (old_entry->needs_copy || object->shadowed ||			    (object->temporary && !old_entry->is_shared &&			     object->size > (vm_size_t)(old_entry->vme_end -						old_entry->vme_start))) {			    assert(object->temporary);			    assert(!(object->shadowed && old_entry->is_shared));			    vm_object_shadow(			        &old_entry->object.vm_object,			        &old_entry->offset,			        (vm_size_t) (old_entry->vme_end -					     old_entry->vme_start));			    /*			     *	If we're making a shadow for other than			     *	copy on write reasons, then we have			     *	to remove write permission.			     */			    if (!old_entry->needs_copy &&				(old_entry->protection & VM_PROT_WRITE)) {			    	pmap_protect(vm_map_pmap(old_map),					     old_entry->vme_start,					     old_entry->vme_end,					     old_entry->protection &					     	~VM_PROT_WRITE);			    }			    old_entry->needs_copy = FALSE;			    object = old_entry->object.vm_object;			}
old_entry->needs_copy || object->shadowed ||			    (object->temporary && !old_entry->is_shared &&			     object->size > (vm_size_t)(old_entry->vme_end -						old_entry->vme_start))
old_entry->needs_copy || object->shadowed
old_entry->needs_copy
old_entry
old_entry
needs_copy
object->shadowed
object
object
shadowed
(object->temporary && !old_entry->is_shared &&			     object->size > (vm_size_t)(old_entry->vme_end -						old_entry->vme_start))
object->temporary && !old_entry->is_shared &&			     object->size > (vm_size_t)(old_entry->vme_end -						old_entry->vme_start)
object->temporary && !old_entry->is_shared
object->temporary
object
object
temporary
!old_entry->is_shared
old_entry->is_shared
old_entry
old_entry
is_shared
object->size > (vm_size_t)(old_entry->vme_end -						old_entry->vme_start)
object->size
object
object
size
(vm_size_t)(old_entry->vme_end -						old_entry->vme_start)
(vm_size_t)
vm_size_t
vm_size_t
old_entry->vme_end -						old_entry->vme_start
old_entry->vme_end
old_entry
old_entry
vme_end
old_entry->vme_start
old_entry
old_entry
vme_start
{			    assert(object->temporary);			    assert(!(object->shadowed && old_entry->is_shared));			    vm_object_shadow(			        &old_entry->object.vm_object,			        &old_entry->offset,			        (vm_size_t) (old_entry->vme_end -					     old_entry->vme_start));			    /*			     *	If we're making a shadow for other than			     *	copy on write reasons, then we have			     *	to remove write permission.			     */			    if (!old_entry->needs_copy &&				(old_entry->protection & VM_PROT_WRITE)) {			    	pmap_protect(vm_map_pmap(old_map),					     old_entry->vme_start,					     old_entry->vme_end,					     old_entry->protection &					     	~VM_PROT_WRITE);			    }			    old_entry->needs_copy = FALSE;			    object = old_entry->object.vm_object;			}
assert(object->temporary);
assert(object->temporary)
assert
assert
object->temporary
object
object
temporary
assert(!(object->shadowed && old_entry->is_shared));
assert(!(object->shadowed && old_entry->is_shared))
assert
assert
!(object->shadowed && old_entry->is_shared)
(object->shadowed && old_entry->is_shared)
object->shadowed && old_entry->is_shared
object->shadowed
object
object
shadowed
old_entry->is_shared
old_entry
old_entry
is_shared
vm_object_shadow(			        &old_entry->object.vm_object,			        &old_entry->offset,			        (vm_size_t) (old_entry->vme_end -					     old_entry->vme_start));
vm_object_shadow(			        &old_entry->object.vm_object,			        &old_entry->offset,			        (vm_size_t) (old_entry->vme_end -					     old_entry->vme_start))
vm_object_shadow
vm_object_shadow
&old_entry->object.vm_object
old_entry->object.vm_object
old_entry->object
old_entry
old_entry
object
vm_object
&old_entry->offset
old_entry->offset
old_entry
old_entry
offset
(vm_size_t) (old_entry->vme_end -					     old_entry->vme_start)
(vm_size_t)
vm_size_t
vm_size_t
old_entry->vme_end -					     old_entry->vme_start
old_entry->vme_end
old_entry
old_entry
vme_end
old_entry->vme_start
old_entry
old_entry
vme_start
if (!old_entry->needs_copy &&				(old_entry->protection & VM_PROT_WRITE)) {			    	pmap_protect(vm_map_pmap(old_map),					     old_entry->vme_start,					     old_entry->vme_end,					     old_entry->protection &					     	~VM_PROT_WRITE);			    }
!old_entry->needs_copy &&				(old_entry->protection & VM_PROT_WRITE)
!old_entry->needs_copy
old_entry->needs_copy
old_entry
old_entry
needs_copy
(old_entry->protection & VM_PROT_WRITE)
old_entry->protection & VM_PROT_WRITE
old_entry->protection
old_entry
old_entry
protection
VM_PROT_WRITE
VM_PROT_WRITE
{			    	pmap_protect(vm_map_pmap(old_map),					     old_entry->vme_start,					     old_entry->vme_end,					     old_entry->protection &					     	~VM_PROT_WRITE);			    }
pmap_protect(vm_map_pmap(old_map),					     old_entry->vme_start,					     old_entry->vme_end,					     old_entry->protection &					     	~VM_PROT_WRITE);
pmap_protect(vm_map_pmap(old_map),					     old_entry->vme_start,					     old_entry->vme_end,					     old_entry->protection &					     	~VM_PROT_WRITE)
pmap_protect
pmap_protect
vm_map_pmap(old_map)
vm_map_pmap
vm_map_pmap
old_map
old_map
old_entry->vme_start
old_entry
old_entry
vme_start
old_entry->vme_end
old_entry
old_entry
vme_end
old_entry->protection &					     	~VM_PROT_WRITE
old_entry->protection
old_entry
old_entry
protection
~VM_PROT_WRITE
VM_PROT_WRITE
VM_PROT_WRITE
old_entry->needs_copy = FALSE;
old_entry->needs_copy = FALSE
old_entry->needs_copy
old_entry
old_entry
needs_copy
FALSE
FALSE
object = old_entry->object.vm_object;
object = old_entry->object.vm_object
object
object
old_entry->object.vm_object
old_entry->object
old_entry
old_entry
object
vm_object
vm_object_lock(object);
vm_object_lock(object)
vm_object_lock
vm_object_lock
object
object
object->use_shared_copy = TRUE;
object->use_shared_copy = TRUE
object->use_shared_copy
object
object
use_shared_copy
TRUE
TRUE
object->ref_count++;
object->ref_count++
object->ref_count
object
object
ref_count
vm_object_unlock(object);
vm_object_unlock(object)
vm_object_unlock
vm_object_unlock
object
object
new_entry = vm_map_entry_create(new_map);
new_entry = vm_map_entry_create(new_map)
new_entry
new_entry
vm_map_entry_create(new_map)
vm_map_entry_create
vm_map_entry_create
new_map
new_map
if (old_entry->projected_on != 0) {			  /*			   *   If entry is projected buffer, clone the                           *   entry exactly.                           */			  vm_map_entry_copy_full(new_entry, old_entry);			} else {			  /*			   *	Clone the entry, using object ref from above.			   *	Mark both entries as shared.			   */			  vm_map_entry_copy(new_entry, old_entry);			  old_entry->is_shared = TRUE;			  new_entry->is_shared = TRUE;			}
old_entry->projected_on != 0
old_entry->projected_on
old_entry
old_entry
projected_on
0
{			  /*			   *   If entry is projected buffer, clone the                           *   entry exactly.                           */			  vm_map_entry_copy_full(new_entry, old_entry);			}
vm_map_entry_copy_full(new_entry, old_entry);
vm_map_entry_copy_full(new_entry, old_entry)
vm_map_entry_copy_full
vm_map_entry_copy_full
new_entry
new_entry
old_entry
old_entry
{			  /*			   *	Clone the entry, using object ref from above.			   *	Mark both entries as shared.			   */			  vm_map_entry_copy(new_entry, old_entry);			  old_entry->is_shared = TRUE;			  new_entry->is_shared = TRUE;			}
vm_map_entry_copy(new_entry, old_entry);
vm_map_entry_copy(new_entry, old_entry)
vm_map_entry_copy
vm_map_entry_copy
new_entry
new_entry
old_entry
old_entry
old_entry->is_shared = TRUE;
old_entry->is_shared = TRUE
old_entry->is_shared
old_entry
old_entry
is_shared
TRUE
TRUE
new_entry->is_shared = TRUE;
new_entry->is_shared = TRUE
new_entry->is_shared
new_entry
new_entry
is_shared
TRUE
TRUE
vm_map_entry_link(				new_map,				vm_map_last_entry(new_map),				new_entry);
vm_map_entry_link(				new_map,				vm_map_last_entry(new_map),				new_entry)
vm_map_entry_link
vm_map_entry_link
new_map
new_map
vm_map_last_entry(new_map)
vm_map_last_entry
vm_map_last_entry
new_map
new_map
new_entry
new_entry
pmap_copy(new_map->pmap, old_map->pmap,				new_entry->vme_start,				entry_size,				old_entry->vme_start);
pmap_copy(new_map->pmap, old_map->pmap,				new_entry->vme_start,				entry_size,				old_entry->vme_start)
pmap_copy
pmap_copy
new_map->pmap
new_map
new_map
pmap
old_map->pmap
old_map
old_map
pmap
new_entry->vme_start
new_entry
new_entry
vme_start
entry_size
entry_size
old_entry->vme_start
old_entry
old_entry
vme_start
new_size += entry_size;
new_size += entry_size
new_size
new_size
entry_size
entry_size
break;
case VM_INHERIT_COPY:
VM_INHERIT_COPY
VM_INHERIT_COPY
if (old_entry->wired_count == 0) {				boolean_t	src_needs_copy;				boolean_t	new_entry_needs_copy;				new_entry = vm_map_entry_create(new_map);				vm_map_entry_copy(new_entry, old_entry);				if (vm_object_copy_temporary(					&new_entry->object.vm_object,					&new_entry->offset,					&src_needs_copy,					&new_entry_needs_copy)) {					/*					 *	Handle copy-on-write obligations					 */					if (src_needs_copy && !old_entry->needs_copy) {						vm_object_pmap_protect(							old_entry->object.vm_object,							old_entry->offset,							entry_size,							(old_entry->is_shared ?								PMAP_NULL :								old_map->pmap),							old_entry->vme_start,							old_entry->protection &							    ~VM_PROT_WRITE);						old_entry->needs_copy = TRUE;					}					new_entry->needs_copy = new_entry_needs_copy;					/*					 *	Insert the entry at the end					 *	of the map.					 */					vm_map_entry_link(new_map,						vm_map_last_entry(new_map),						new_entry);					new_size += entry_size;					break;				}				vm_map_entry_dispose(new_map, new_entry);			}
old_entry->wired_count == 0
old_entry->wired_count
old_entry
old_entry
wired_count
0
{				boolean_t	src_needs_copy;				boolean_t	new_entry_needs_copy;				new_entry = vm_map_entry_create(new_map);				vm_map_entry_copy(new_entry, old_entry);				if (vm_object_copy_temporary(					&new_entry->object.vm_object,					&new_entry->offset,					&src_needs_copy,					&new_entry_needs_copy)) {					/*					 *	Handle copy-on-write obligations					 */					if (src_needs_copy && !old_entry->needs_copy) {						vm_object_pmap_protect(							old_entry->object.vm_object,							old_entry->offset,							entry_size,							(old_entry->is_shared ?								PMAP_NULL :								old_map->pmap),							old_entry->vme_start,							old_entry->protection &							    ~VM_PROT_WRITE);						old_entry->needs_copy = TRUE;					}					new_entry->needs_copy = new_entry_needs_copy;					/*					 *	Insert the entry at the end					 *	of the map.					 */					vm_map_entry_link(new_map,						vm_map_last_entry(new_map),						new_entry);					new_size += entry_size;					break;				}				vm_map_entry_dispose(new_map, new_entry);			}
boolean_t	src_needs_copy;
boolean_t	src_needs_copy;
boolean_t
boolean_t
src_needs_copy
src_needs_copy
boolean_t	new_entry_needs_copy;
boolean_t	new_entry_needs_copy;
boolean_t
boolean_t
new_entry_needs_copy
new_entry_needs_copy
new_entry = vm_map_entry_create(new_map);
new_entry = vm_map_entry_create(new_map)
new_entry
new_entry
vm_map_entry_create(new_map)
vm_map_entry_create
vm_map_entry_create
new_map
new_map
vm_map_entry_copy(new_entry, old_entry);
vm_map_entry_copy(new_entry, old_entry)
vm_map_entry_copy
vm_map_entry_copy
new_entry
new_entry
old_entry
old_entry
if (vm_object_copy_temporary(					&new_entry->object.vm_object,					&new_entry->offset,					&src_needs_copy,					&new_entry_needs_copy)) {					/*					 *	Handle copy-on-write obligations					 */					if (src_needs_copy && !old_entry->needs_copy) {						vm_object_pmap_protect(							old_entry->object.vm_object,							old_entry->offset,							entry_size,							(old_entry->is_shared ?								PMAP_NULL :								old_map->pmap),							old_entry->vme_start,							old_entry->protection &							    ~VM_PROT_WRITE);						old_entry->needs_copy = TRUE;					}					new_entry->needs_copy = new_entry_needs_copy;					/*					 *	Insert the entry at the end					 *	of the map.					 */					vm_map_entry_link(new_map,						vm_map_last_entry(new_map),						new_entry);					new_size += entry_size;					break;				}
vm_object_copy_temporary(					&new_entry->object.vm_object,					&new_entry->offset,					&src_needs_copy,					&new_entry_needs_copy)
vm_object_copy_temporary
vm_object_copy_temporary
&new_entry->object.vm_object
new_entry->object.vm_object
new_entry->object
new_entry
new_entry
object
vm_object
&new_entry->offset
new_entry->offset
new_entry
new_entry
offset
&src_needs_copy
src_needs_copy
src_needs_copy
&new_entry_needs_copy
new_entry_needs_copy
new_entry_needs_copy
{					/*					 *	Handle copy-on-write obligations					 */					if (src_needs_copy && !old_entry->needs_copy) {						vm_object_pmap_protect(							old_entry->object.vm_object,							old_entry->offset,							entry_size,							(old_entry->is_shared ?								PMAP_NULL :								old_map->pmap),							old_entry->vme_start,							old_entry->protection &							    ~VM_PROT_WRITE);						old_entry->needs_copy = TRUE;					}					new_entry->needs_copy = new_entry_needs_copy;					/*					 *	Insert the entry at the end					 *	of the map.					 */					vm_map_entry_link(new_map,						vm_map_last_entry(new_map),						new_entry);					new_size += entry_size;					break;				}
if (src_needs_copy && !old_entry->needs_copy) {						vm_object_pmap_protect(							old_entry->object.vm_object,							old_entry->offset,							entry_size,							(old_entry->is_shared ?								PMAP_NULL :								old_map->pmap),							old_entry->vme_start,							old_entry->protection &							    ~VM_PROT_WRITE);						old_entry->needs_copy = TRUE;					}
src_needs_copy && !old_entry->needs_copy
src_needs_copy
src_needs_copy
!old_entry->needs_copy
old_entry->needs_copy
old_entry
old_entry
needs_copy
{						vm_object_pmap_protect(							old_entry->object.vm_object,							old_entry->offset,							entry_size,							(old_entry->is_shared ?								PMAP_NULL :								old_map->pmap),							old_entry->vme_start,							old_entry->protection &							    ~VM_PROT_WRITE);						old_entry->needs_copy = TRUE;					}
vm_object_pmap_protect(							old_entry->object.vm_object,							old_entry->offset,							entry_size,							(old_entry->is_shared ?								PMAP_NULL :								old_map->pmap),							old_entry->vme_start,							old_entry->protection &							    ~VM_PROT_WRITE);
vm_object_pmap_protect(							old_entry->object.vm_object,							old_entry->offset,							entry_size,							(old_entry->is_shared ?								PMAP_NULL :								old_map->pmap),							old_entry->vme_start,							old_entry->protection &							    ~VM_PROT_WRITE)
vm_object_pmap_protect
vm_object_pmap_protect
old_entry->object.vm_object
old_entry->object
old_entry
old_entry
object
vm_object
old_entry->offset
old_entry
old_entry
offset
entry_size
entry_size
(old_entry->is_shared ?								PMAP_NULL :								old_map->pmap)
old_entry->is_shared ?								PMAP_NULL :								old_map->pmap
old_entry->is_shared
old_entry
old_entry
is_shared
PMAP_NULL
PMAP_NULL
old_map->pmap
old_map
old_map
pmap
old_entry->vme_start
old_entry
old_entry
vme_start
old_entry->protection &							    ~VM_PROT_WRITE
old_entry->protection
old_entry
old_entry
protection
~VM_PROT_WRITE
VM_PROT_WRITE
VM_PROT_WRITE
old_entry->needs_copy = TRUE;
old_entry->needs_copy = TRUE
old_entry->needs_copy
old_entry
old_entry
needs_copy
TRUE
TRUE
new_entry->needs_copy = new_entry_needs_copy;
new_entry->needs_copy = new_entry_needs_copy
new_entry->needs_copy
new_entry
new_entry
needs_copy
new_entry_needs_copy
new_entry_needs_copy
vm_map_entry_link(new_map,						vm_map_last_entry(new_map),						new_entry);
vm_map_entry_link(new_map,						vm_map_last_entry(new_map),						new_entry)
vm_map_entry_link
vm_map_entry_link
new_map
new_map
vm_map_last_entry(new_map)
vm_map_last_entry
vm_map_last_entry
new_map
new_map
new_entry
new_entry
new_size += entry_size;
new_size += entry_size
new_size
new_size
entry_size
entry_size
break;
vm_map_entry_dispose(new_map, new_entry);
vm_map_entry_dispose(new_map, new_entry)
vm_map_entry_dispose
vm_map_entry_dispose
new_map
new_map
new_entry
new_entry
{			vm_offset_t	start = old_entry->vme_start;			vm_map_copy_t	copy;			vm_map_entry_t	last = vm_map_last_entry(new_map);			vm_map_unlock(old_map);			if (vm_map_copyin(old_map,					start,					entry_size,					FALSE,					&copy)			    != KERN_SUCCESS) {			    	vm_map_lock(old_map);				if (!vm_map_lookup_entry(old_map, start, &last))					last = last->vme_next;				old_entry = last;				/*				 *	For some error returns, want to				 *	skip to the next element.				 */				continue;			}			/*			 *	Insert the copy into the new map			 */			vm_map_copy_insert(new_map, last, copy);			new_size += entry_size;			/*			 *	Pick up the traversal at the end of			 *	the copied region.			 */			vm_map_lock(old_map);			start += entry_size;			if (!vm_map_lookup_entry(old_map, start, &last))				last = last->vme_next;			 else				vm_map_clip_start(old_map, last, start);			old_entry = last;			continue;			/* INNER BLOCK (copy cannot be optimized) */ }
vm_offset_t	start = old_entry->vme_start;
vm_offset_t	start = old_entry->vme_start;
vm_offset_t
vm_offset_t
start = old_entry->vme_start
start
= old_entry->vme_start
old_entry->vme_start
old_entry
old_entry
vme_start
vm_map_copy_t	copy;
vm_map_copy_t	copy;
vm_map_copy_t
vm_map_copy_t
copy
copy
vm_map_entry_t	last = vm_map_last_entry(new_map);
vm_map_entry_t	last = vm_map_last_entry(new_map);
vm_map_entry_t
vm_map_entry_t
last = vm_map_last_entry(new_map)
last
= vm_map_last_entry(new_map)
vm_map_last_entry(new_map)
vm_map_last_entry
vm_map_last_entry
new_map
new_map
vm_map_unlock(old_map);
vm_map_unlock(old_map)
vm_map_unlock
vm_map_unlock
old_map
old_map
if (vm_map_copyin(old_map,					start,					entry_size,					FALSE,					&copy)			    != KERN_SUCCESS) {			    	vm_map_lock(old_map);				if (!vm_map_lookup_entry(old_map, start, &last))					last = last->vme_next;				old_entry = last;				/*				 *	For some error returns, want to				 *	skip to the next element.				 */				continue;			}
vm_map_copyin(old_map,					start,					entry_size,					FALSE,					&copy)			    != KERN_SUCCESS
vm_map_copyin(old_map,					start,					entry_size,					FALSE,					&copy)
vm_map_copyin
vm_map_copyin
old_map
old_map
start
start
entry_size
entry_size
FALSE
FALSE
&copy
copy
copy
KERN_SUCCESS
KERN_SUCCESS
{			    	vm_map_lock(old_map);				if (!vm_map_lookup_entry(old_map, start, &last))					last = last->vme_next;				old_entry = last;				/*				 *	For some error returns, want to				 *	skip to the next element.				 */				continue;			}
vm_map_lock(old_map);
vm_map_lock(old_map)
vm_map_lock
vm_map_lock
old_map
old_map
if (!vm_map_lookup_entry(old_map, start, &last))					last = last->vme_next;
!vm_map_lookup_entry(old_map, start, &last)
vm_map_lookup_entry(old_map, start, &last)
vm_map_lookup_entry
vm_map_lookup_entry
old_map
old_map
start
start
&last
last
last
last = last->vme_next;
last = last->vme_next
last
last
last->vme_next
last
last
vme_next
old_entry = last;
old_entry = last
old_entry
old_entry
last
last
continue;
vm_map_copy_insert(new_map, last, copy);
vm_map_copy_insert(new_map, last, copy)
vm_map_copy_insert
vm_map_copy_insert
new_map
new_map
last
last
copy
copy
new_size += entry_size;
new_size += entry_size
new_size
new_size
entry_size
entry_size
vm_map_lock(old_map);
vm_map_lock(old_map)
vm_map_lock
vm_map_lock
old_map
old_map
start += entry_size;
start += entry_size
start
start
entry_size
entry_size
if (!vm_map_lookup_entry(old_map, start, &last))				last = last->vme_next;			 else				vm_map_clip_start(old_map, last, start);
!vm_map_lookup_entry(old_map, start, &last)
vm_map_lookup_entry(old_map, start, &last)
vm_map_lookup_entry
vm_map_lookup_entry
old_map
old_map
start
start
&last
last
last
last = last->vme_next;
last = last->vme_next
last
last
last->vme_next
last
last
vme_next
vm_map_clip_start(old_map, last, start);
vm_map_clip_start(old_map, last, start)
vm_map_clip_start
vm_map_clip_start
old_map
old_map
last
last
start
start
old_entry = last;
old_entry = last
old_entry
old_entry
last
last
continue;
old_entry = old_entry->vme_next;
old_entry = old_entry->vme_next
old_entry
old_entry
old_entry->vme_next
old_entry
old_entry
vme_next
new_map->size = new_size;
new_map->size = new_size
new_map->size
new_map
new_map
size
new_size
new_size
vm_map_unlock(old_map);
vm_map_unlock(old_map)
vm_map_unlock
vm_map_unlock
old_map
old_map
return(new_map);
(new_map)
new_map
new_map
-----joern-----
(118,392,0)
(159,165,0)
(416,107,0)
(121,411,0)
(408,83,0)
(239,422,0)
(384,256,0)
(23,160,0)
(308,197,0)
(118,347,0)
(269,270,0)
(41,338,0)
(413,237,0)
(219,292,0)
(445,374,0)
(186,34,0)
(327,422,0)
(285,368,0)
(448,338,0)
(115,233,0)
(339,354,0)
(290,351,0)
(75,336,0)
(239,85,0)
(293,445,0)
(368,285,0)
(119,287,0)
(24,25,0)
(389,461,0)
(401,62,0)
(147,83,0)
(72,245,0)
(258,83,0)
(80,83,0)
(287,422,0)
(370,336,0)
(183,83,0)
(134,248,0)
(219,219,0)
(266,155,0)
(132,374,0)
(57,376,0)
(157,239,0)
(140,118,0)
(401,319,0)
(57,172,0)
(273,53,0)
(166,133,0)
(451,207,0)
(142,276,0)
(51,145,0)
(328,185,0)
(130,68,0)
(124,18,0)
(270,319,0)
(207,91,0)
(165,458,0)
(232,111,0)
(14,142,0)
(234,83,0)
(0,214,0)
(351,429,0)
(67,62,0)
(408,319,0)
(447,0,0)
(118,148,0)
(371,162,0)
(358,308,0)
(275,31,0)
(280,422,0)
(140,368,0)
(298,108,0)
(108,117,0)
(138,37,0)
(297,270,0)
(21,68,0)
(27,235,0)
(390,336,0)
(462,422,0)
(210,242,0)
(20,390,0)
(31,83,0)
(168,236,0)
(160,83,0)
(139,461,0)
(107,68,0)
(218,83,0)
(436,340,0)
(145,30,0)
(331,0,0)
(122,435,0)
(290,410,0)
(47,118,0)
(279,319,0)
(382,88,0)
(311,319,0)
(218,319,0)
(265,374,0)
(454,184,0)
(142,366,0)
(146,245,0)
(299,187,0)
(345,340,0)
(162,371,0)
(458,165,0)
(129,436,0)
(270,340,0)
(92,376,0)
(189,416,0)
(88,382,0)
(49,108,0)
(139,163,0)
(89,340,0)
(130,422,0)
(279,340,0)
(219,176,0)
(248,183,0)
(461,154,0)
(348,191,0)
(435,257,0)
(276,235,0)
(126,31,0)
(266,326,0)
(316,201,0)
(45,172,0)
(195,340,0)
(242,225,0)
(145,111,0)
(174,256,0)
(78,347,0)
(272,239,0)
(183,340,0)
(34,34,0)
(241,176,0)
(426,165,0)
(351,290,0)
(147,319,0)
(11,406,0)
(183,347,0)
(244,389,0)
(247,445,0)
(234,148,0)
(389,324,0)
(343,374,0)
(235,386,0)
(38,10,0)
(19,98,0)
(179,308,0)
(219,186,0)
(145,374,0)
(25,340,0)
(111,145,0)
(76,234,0)
(239,272,0)
(300,374,0)
(20,374,0)
(213,83,0)
(234,319,0)
(54,89,0)
(106,107,0)
(226,210,0)
(261,68,0)
(440,464,0)
(262,56,0)
(102,347,0)
(127,385,0)
(411,117,0)
(153,308,0)
(39,318,0)
(25,347,0)
(91,207,0)
(435,197,0)
(245,72,0)
(197,308,0)
(118,83,0)
(234,392,0)
(451,83,0)
(317,258,0)
(215,38,0)
(305,123,0)
(465,117,0)
(14,336,0)
(155,303,0)
(375,340,0)
(369,406,0)
(451,347,0)
(359,83,0)
(303,319,0)
(394,45,0)
(121,113,0)
(219,117,0)
(201,340,0)
(201,83,0)
(260,123,0)
(329,464,0)
(30,422,0)
(34,256,0)
(255,319,0)
(234,347,0)
(311,347,0)
(354,347,0)
(152,374,0)
(204,78,0)
(205,382,0)
(303,347,0)
(239,411,0)
(367,117,0)
(354,340,0)
(111,83,0)
(73,68,0)
(233,319,0)
(1,348,0)
(147,185,0)
(83,464,0)
(463,56,0)
(187,83,0)
(117,374,0)
(337,324,0)
(311,83,0)
(340,172,0)
(18,78,0)
(377,172,0)
(274,148,0)
(118,340,0)
(77,219,0)
(294,240,0)
(252,181,0)
(273,347,0)
(182,83,0)
(434,375,0)
(409,239,0)
(336,248,0)
(441,375,0)
(127,83,0)
(331,343,0)
(79,273,0)
(442,294,0)
(237,145,0)
(257,435,0)
(465,411,0)
(183,319,0)
(7,403,0)
(93,303,0)
(91,151,0)
(33,408,0)
(273,340,0)
(165,159,0)
(188,107,0)
(279,347,0)
(58,319,0)
(231,336,0)
(233,240,0)
(102,196,0)
(429,83,0)
(420,422,0)
(294,442,0)
(10,279,0)
(56,211,0)
(136,377,0)
(218,347,0)
(420,133,0)
(80,347,0)
(339,90,0)
(123,225,0)
(187,294,0)
(176,241,0)
(442,83,0)
(120,359,0)
(314,98,0)
(18,124,0)
(429,319,0)
(64,188,0)
(145,293,0)
(26,359,0)
(401,340,0)
(56,336,0)
(185,385,0)
(386,235,0)
(270,83,0)
(98,68,0)
(106,188,0)
(342,340,0)
(451,340,0)
(344,311,0)
(423,186,0)
(442,319,0)
(144,340,0)
(125,213,0)
(458,163,0)
(95,121,0)
(86,256,0)
(359,347,0)
(359,319,0)
(406,336,0)
(45,121,0)
(48,234,0)
(289,389,0)
(243,239,0)
(65,81,0)
(294,222,0)
(213,241,0)
(38,290,0)
(445,247,0)
(109,106,0)
(313,144,0)
(31,126,0)
(279,83,0)
(446,420,0)
(277,242,0)
(258,319,0)
(221,73,0)
(306,163,0)
(144,347,0)
(151,370,0)
(376,57,0)
(143,292,0)
(371,465,0)
(357,68,0)
(91,11,0)
(171,324,0)
(203,319,0)
(403,366,0)
(213,319,0)
(160,285,0)
(323,213,0)
(193,68,0)
(436,347,0)
(359,340,0)
(342,347,0)
(75,374,0)
(398,324,0)
(104,25,0)
(408,351,0)
(18,379,0)
(180,455,0)
(25,83,0)
(14,0,0)
(308,68,0)
(245,83,0)
(11,91,0)
(436,83,0)
(60,224,0)
(59,68,0)
(255,83,0)
(373,342,0)
(14,374,0)
(354,392,0)
(17,103,0)
(311,340,0)
(102,83,0)
(105,59,0)
(418,34,0)
(156,272,0)
(78,18,0)
(416,71,0)
(349,406,0)
(160,319,0)
(432,103,0)
(100,139,0)
(133,107,0)
(410,290,0)
(147,347,0)
(160,340,0)
(29,72,0)
(462,201,0)
(283,465,0)
(361,326,0)
(61,411,0)
(186,374,0)
(188,374,0)
(82,130,0)
(429,351,0)
(245,340,0)
(145,237,0)
(290,38,0)
(318,294,0)
(338,133,0)
(314,224,0)
(303,340,0)
(16,464,0)
(415,451,0)
(335,294,0)
(113,121,0)
(69,442,0)
(200,147,0)
(314,202,0)
(242,210,0)
(393,365,0)
(164,443,0)
(461,324,0)
(224,291,0)
(220,384,0)
(53,35,0)
(258,347,0)
(220,461,0)
(408,340,0)
(284,370,0)
(58,83,0)
(398,107,0)
(2,384,0)
(347,81,0)
(161,358,0)
(177,172,0)
(407,107,0)
(215,123,0)
(296,390,0)
(280,117,0)
(72,294,0)
(430,247,0)
(99,121,0)
(208,305,0)
(237,107,0)
(133,308,0)
(326,336,0)
(103,465,0)
(452,461,0)
(96,177,0)
(353,31,0)
(9,343,0)
(305,347,0)
(89,83,0)
(75,0,0)
(240,294,0)
(386,270,0)
(234,7,0)
(389,340,0)
(195,347,0)
(160,347,0)
(40,401,0)
(447,218,0)
(183,248,0)
(5,35,0)
(12,443,0)
(36,420,0)
(97,371,0)
(370,151,0)
(35,5,0)
(414,293,0)
(259,30,0)
(351,408,0)
(350,68,0)
(387,68,0)
(364,398,0)
(175,218,0)
(11,35,0)
(263,392,0)
(144,83,0)
(421,331,0)
(63,374,0)
(127,340,0)
(246,117,0)
(397,154,0)
(127,445,0)
(80,319,0)
(295,89,0)
(3,236,0)
(359,348,0)
(55,370,0)
(168,165,0)
(53,58,0)
(102,319,0)
(127,347,0)
(80,392,0)
(31,347,0)
(71,107,0)
(154,461,0)
(58,347,0)
(141,220,0)
(167,214,0)
(311,148,0)
(35,53,0)
(223,80,0)
(186,219,0)
(230,233,0)
(389,319,0)
(103,422,0)
(31,340,0)
(273,319,0)
(78,83,0)
(177,107,0)
(389,347,0)
(338,422,0)
(303,148,0)
(124,460,0)
(443,340,0)
(327,318,0)
(379,18,0)
(282,462,0)
(427,57,0)
(294,176,0)
(334,379,0)
(342,319,0)
(390,142,0)
(111,347,0)
(191,348,0)
(401,347,0)
(354,319,0)
(443,347,0)
(155,266,0)
(236,168,0)
(288,126,0)
(255,340,0)
(186,186,0)
(4,58,0)
(341,68,0)
(412,117,0)
(465,176,0)
(460,214,0)
(340,117,0)
(428,371,0)
(165,426,0)
(83,376,0)
(281,111,0)
(302,186,0)
(318,327,0)
(253,342,0)
(123,305,0)
(392,222,0)
(255,318,0)
(144,411,0)
(118,140,0)
(84,279,0)
(372,347,0)
(195,319,0)
(236,461,0)
(312,142,0)
(179,291,0)
(247,107,0)
(107,133,0)
(375,83,0)
(443,83,0)
(248,336,0)
(229,71,0)
(43,105,0)
(442,184,0)
(271,195,0)
(191,89,0)
(429,340,0)
(90,339,0)
(346,117,0)
(391,327,0)
(198,57,0)
(121,45,0)
(127,319,0)
(279,10,0)
(398,461,0)
(13,101,0)
(319,365,0)
(0,447,0)
(255,347,0)
(379,336,0)
(187,340,0)
(118,319,0)
(103,172,0)
(459,327,0)
(207,451,0)
(403,7,0)
(331,336,0)
(255,185,0)
(440,422,0)
(249,139,0)
(1,422,0)
(98,107,0)
(404,255,0)
(405,75,0)
(390,0,0)
(59,219,0)
(273,83,0)
(368,140,0)
(145,176,0)
(319,258,0)
(304,118,0)
(307,390,0)
(211,56,0)
(378,188,0)
(116,239,0)
(266,151,0)
(151,266,0)
(165,168,0)
(375,184,0)
(336,374,0)
(187,347,0)
(251,331,0)
(305,340,0)
(433,1,0)
(293,145,0)
(31,319,0)
(268,14,0)
(310,34,0)
(135,326,0)
(34,292,0)
(190,374,0)
(176,365,0)
(388,183,0)
(400,179,0)
(178,219,0)
(270,347,0)
(123,215,0)
(101,309,0)
(245,319,0)
(38,215,0)
(131,240,0)
(218,447,0)
(303,392,0)
(240,225,0)
(354,339,0)
(38,214,0)
(331,142,0)
(81,347,0)
(35,11,0)
(429,347,0)
(163,139,0)
(144,319,0)
(267,117,0)
(287,117,0)
(78,185,0)
(383,447,0)
(170,68,0)
(396,237,0)
(133,420,0)
(188,106,0)
(6,160,0)
(210,340,0)
(78,319,0)
(186,292,0)
(450,187,0)
(70,374,0)
(278,245,0)
(276,142,0)
(10,38,0)
(59,292,0)
(318,255,0)
(158,429,0)
(128,311,0)
(71,416,0)
(292,68,0)
(169,255,0)
(303,83,0)
(348,1,0)
(212,30,0)
(325,191,0)
(451,319,0)
(194,440,0)
(59,34,0)
(386,342,0)
(332,305,0)
(173,280,0)
(147,340,0)
(294,72,0)
(439,159,0)
(114,354,0)
(241,213,0)
(436,319,0)
(225,142,0)
(22,85,0)
(148,214,0)
(417,0,0)
(348,359,0)
(15,101,0)
(377,371,0)
(228,258,0)
(74,324,0)
(235,27,0)
(399,365,0)
(151,91,0)
(216,210,0)
(406,11,0)
(264,426,0)
(154,107,0)
(25,319,0)
(172,177,0)
(342,386,0)
(402,340,0)
(240,233,0)
(443,241,0)
(94,354,0)
(371,422,0)
(75,142,0)
(451,185,0)
(239,176,0)
(89,319,0)
(238,78,0)
(348,436,0)
(419,398,0)
(431,80,0)
(375,319,0)
(371,377,0)
(186,176,0)
(301,358,0)
(356,103,0)
(110,445,0)
(342,83,0)
(340,382,0)
(315,465,0)
(89,191,0)
(352,172,0)
(241,443,0)
(80,340,0)
(348,424,0)
(309,385,0)
(187,319,0)
(401,83,0)
(8,273,0)
(188,445,0)
(408,347,0)
(206,408,0)
(30,145,0)
(227,105,0)
(354,83,0)
(449,59,0)
(137,127,0)
(225,366,0)
(108,172,0)
(305,319,0)
(270,386,0)
(395,292,0)
(234,340,0)
(42,37,0)
(285,160,0)
(44,236,0)
(245,347,0)
(121,422,0)
(52,218,0)
(219,34,0)
(333,88,0)
(362,147,0)
(78,340,0)
(305,83,0)
(286,442,0)
(279,184,0)
(248,225,0)
(201,319,0)
(111,340,0)
(81,422,0)
(354,148,0)
(389,83,0)
(32,303,0)
(437,102,0)
(201,462,0)
(73,422,0)
(213,347,0)
(71,256,0)
(34,176,0)
(425,225,0)
(199,279,0)
(83,172,0)
(258,340,0)
(447,225,0)
(233,340,0)
(211,214,0)
(442,340,0)
(233,83,0)
(59,186,0)
(7,234,0)
(102,445,0)
(66,374,0)
(355,451,0)
(210,83,0)
(322,176,0)
(133,338,0)
(58,53,0)
(363,88,0)
(195,83,0)
(28,202,0)
(71,461,0)
(111,319,0)
(210,347,0)
(112,127,0)
(218,340,0)
(213,340,0)
(89,347,0)
(320,285,0)
(62,401,0)
(233,347,0)
(235,276,0)
(411,144,0)
(87,108,0)
(381,117,0)
(453,58,0)
(250,68,0)
(294,187,0)
(217,309,0)
(102,340,0)
(37,308,0)
(172,117,0)
(209,195,0)
(443,319,0)
(163,458,0)
(34,186,0)
(303,155,0)
(46,429,0)
(85,239,0)
(105,107,0)
(455,336,0)
(101,445,0)
(192,83,0)
(254,183,0)
(321,455,0)
(184,366,0)
(34,219,0)
(50,71,0)
(108,107,0)
(442,347,0)
(197,435,0)
(58,340,0)
(460,124,0)
(326,266,0)
(375,347,0)
(150,436,0)
(201,347,0)
(390,20,0)
(438,379,0)
(53,273,0)
(210,319,0)
(360,90,0)
(436,348,0)
(444,401,0)
(380,293,0)
(457,68,0)
(294,318,0)
(330,220,0)
(456,144,0)
(88,172,0)
(149,102,0)
(231,195,1)
(147,347,1)
(378,106,1)
(294,318,1)
(461,154,1)
(139,100,1)
(331,336,1)
(75,0,1)
(287,422,1)
(444,40,1)
(396,188,1)
(111,281,1)
(255,347,1)
(440,194,1)
(29,245,1)
(465,283,1)
(123,260,1)
(347,81,1)
(31,275,1)
(303,340,1)
(443,347,1)
(23,140,1)
(55,326,1)
(212,237,1)
(459,391,1)
(451,355,1)
(460,124,1)
(456,313,1)
(188,106,1)
(237,107,1)
(438,334,1)
(255,319,1)
(305,83,1)
(186,186,1)
(335,442,1)
(147,200,1)
(331,251,1)
(287,119,1)
(452,62,1)
(10,279,1)
(414,30,1)
(340,345,1)
(128,368,1)
(183,83,1)
(179,308,1)
(118,319,1)
(61,398,1)
(389,347,1)
(58,83,1)
(19,73,1)
(313,61,1)
(173,219,1)
(89,319,1)
(208,460,1)
(183,340,1)
(463,155,1)
(126,288,1)
(317,203,1)
(127,319,1)
(105,227,1)
(217,101,1)
(140,118,1)
(46,10,1)
(89,340,1)
(221,59,1)
(266,151,1)
(303,83,1)
(128,348,1)
(279,84,1)
(139,461,1)
(118,340,1)
(286,240,1)
(360,165,1)
(202,28,1)
(373,312,1)
(234,148,1)
(354,83,1)
(465,411,1)
(80,223,1)
(255,83,1)
(303,32,1)
(206,429,1)
(447,383,1)
(454,375,1)
(283,315,1)
(398,107,1)
(447,225,1)
(294,72,1)
(99,440,1)
(318,327,1)
(180,321,1)
(89,54,1)
(58,319,1)
(53,273,1)
(38,215,1)
(102,319,1)
(429,158,1)
(78,185,1)
(462,282,1)
(322,181,1)
(382,88,1)
(354,148,1)
(108,172,1)
(351,408,1)
(2,220,1)
(258,319,1)
(71,50,1)
(248,225,1)
(232,51,1)
(443,12,1)
(237,413,1)
(195,83,1)
(431,294,1)
(71,107,1)
(90,360,1)
(80,347,1)
(85,239,1)
(100,249,1)
(145,293,1)
(394,95,1)
(280,422,1)
(234,392,1)
(273,319,1)
(56,336,1)
(386,270,1)
(30,259,1)
(458,163,1)
(121,422,1)
(38,290,1)
(269,342,1)
(109,64,1)
(188,107,1)
(432,162,1)
(78,319,1)
(62,401,1)
(197,435,1)
(218,52,1)
(389,83,1)
(3,44,1)
(354,347,1)
(185,328,1)
(146,187,1)
(183,347,1)
(145,237,1)
(273,79,1)
(234,76,1)
(311,340,1)
(181,252,1)
(400,37,1)
(408,319,1)
(34,292,1)
(0,447,1)
(455,180,1)
(59,449,1)
(30,422,1)
(155,266,1)
(351,429,1)
(31,319,1)
(449,105,1)
(61,62,1)
(342,319,1)
(195,340,1)
(318,255,1)
(253,373,1)
(342,253,1)
(94,114,1)
(301,292,1)
(176,241,1)
(127,340,1)
(408,347,1)
(219,186,1)
(201,347,1)
(226,184,1)
(295,436,1)
(336,248,1)
(45,394,1)
(34,34,1)
(145,111,1)
(159,439,1)
(429,340,1)
(58,4,1)
(288,31,1)
(85,22,1)
(419,165,1)
(255,185,1)
(339,354,1)
(442,184,1)
(297,269,1)
(290,351,1)
(450,299,1)
(439,168,1)
(186,34,1)
(60,179,1)
(83,376,1)
(134,183,1)
(106,109,1)
(292,395,1)
(160,6,1)
(354,392,1)
(392,263,1)
(348,191,1)
(52,175,1)
(342,347,1)
(80,340,1)
(62,67,1)
(401,319,1)
(150,359,1)
(22,239,1)
(210,319,1)
(39,255,1)
(389,461,1)
(314,202,1)
(236,461,1)
(138,42,1)
(14,268,1)
(33,206,1)
(155,303,1)
(57,172,1)
(148,274,1)
(49,85,1)
(245,278,1)
(354,340,1)
(338,448,1)
(230,115,1)
(42,107,1)
(358,308,1)
(401,444,1)
(397,452,1)
(375,347,1)
(12,164,1)
(35,53,1)
(348,436,1)
(213,83,1)
(177,96,1)
(24,201,1)
(442,83,1)
(348,359,1)
(162,371,1)
(183,319,1)
(401,347,1)
(144,340,1)
(316,347,1)
(248,183,1)
(25,104,1)
(37,308,1)
(127,445,1)
(305,347,1)
(160,347,1)
(168,236,1)
(219,77,1)
(234,83,1)
(316,16,1)
(315,280,1)
(115,90,1)
(184,454,1)
(251,421,1)
(386,342,1)
(9,331,1)
(187,450,1)
(204,379,1)
(420,446,1)
(442,69,1)
(201,319,1)
(81,422,1)
(108,107,1)
(428,97,1)
(203,174,1)
(279,184,1)
(218,340,1)
(186,176,1)
(294,187,1)
(255,340,1)
(436,347,1)
(50,416,1)
(376,57,1)
(282,316,1)
(273,83,1)
(83,182,1)
(264,159,1)
(75,142,1)
(35,5,1)
(310,71,1)
(358,161,1)
(417,148,1)
(280,173,1)
(175,417,1)
(195,347,1)
(161,301,1)
(165,159,1)
(58,340,1)
(355,415,1)
(160,83,1)
(218,319,1)
(405,20,1)
(219,292,1)
(95,99,1)
(294,442,1)
(124,18,1)
(178,108,1)
(252,25,1)
(278,146,1)
(327,459,1)
(98,107,1)
(293,380,1)
(220,330,1)
(436,319,1)
(125,323,1)
(1,433,1)
(243,287,1)
(54,295,1)
(314,98,1)
(227,43,1)
(263,80,1)
(56,262,1)
(63,195,1)
(199,215,1)
(111,340,1)
(188,378,1)
(34,219,1)
(224,60,1)
(102,437,1)
(32,93,1)
(11,406,1)
(147,83,1)
(268,155,1)
(239,272,1)
(398,364,1)
(17,356,1)
(245,347,1)
(442,340,1)
(303,347,1)
(31,340,1)
(118,83,1)
(326,336,1)
(270,319,1)
(72,245,1)
(268,403,1)
(174,34,1)
(25,347,1)
(210,216,1)
(102,347,1)
(81,65,1)
(235,386,1)
(51,293,1)
(113,121,1)
(191,325,1)
(144,347,1)
(359,83,1)
(192,113,1)
(116,157,1)
(375,434,1)
(119,172,1)
(210,83,1)
(229,384,1)
(363,205,1)
(274,311,1)
(306,139,1)
(445,247,1)
(118,148,1)
(76,48,1)
(210,340,1)
(281,232,1)
(127,137,1)
(165,426,1)
(34,186,1)
(370,284,1)
(187,340,1)
(277,210,1)
(83,172,1)
(78,347,1)
(28,358,1)
(107,133,1)
(383,218,1)
(65,372,1)
(430,110,1)
(57,198,1)
(239,176,1)
(361,135,1)
(418,310,1)
(320,160,1)
(356,432,1)
(435,122,1)
(294,176,1)
(370,336,1)
(91,207,1)
(142,276,1)
(102,445,1)
(331,0,1)
(305,332,1)
(389,340,1)
(234,347,1)
(172,177,1)
(219,219,1)
(345,402,1)
(234,340,1)
(402,103,1)
(354,94,1)
(338,422,1)
(133,308,1)
(303,392,1)
(218,83,1)
(442,347,1)
(145,30,1)
(177,107,1)
(284,55,1)
(353,445,1)
(344,128,1)
(255,404,1)
(201,462,1)
(421,14,1)
(436,129,1)
(73,221,1)
(144,83,1)
(379,438,1)
(325,89,1)
(126,31,1)
(436,340,1)
(233,319,1)
(1,422,1)
(111,347,1)
(239,411,1)
(194,85,1)
(258,228,1)
(246,340,1)
(340,382,1)
(201,340,1)
(163,139,1)
(275,353,1)
(318,39,1)
(415,370,1)
(240,233,1)
(25,319,1)
(406,369,1)
(118,347,1)
(322,25,1)
(305,319,1)
(270,297,1)
(179,400,1)
(90,339,1)
(220,461,1)
(375,83,1)
(91,11,1)
(103,465,1)
(187,347,1)
(64,102,1)
(311,347,1)
(423,145,1)
(241,213,1)
(186,219,1)
(270,347,1)
(241,443,1)
(296,307,1)
(377,136,1)
(209,176,1)
(41,166,1)
(451,319,1)
(16,83,1)
(420,422,1)
(238,204,1)
(289,461,1)
(285,320,1)
(59,292,1)
(331,142,1)
(188,445,1)
(203,195,1)
(114,360,1)
(442,319,1)
(213,340,1)
(234,319,1)
(299,318,1)
(144,456,1)
(248,134,1)
(368,140,1)
(164,213,1)
(187,319,1)
(198,427,1)
(84,199,1)
(88,172,1)
(82,358,1)
(247,430,1)
(101,445,1)
(240,225,1)
(7,234,1)
(205,162,1)
(233,340,1)
(31,83,1)
(59,34,1)
(75,336,1)
(156,409,1)
(465,176,1)
(73,422,1)
(157,243,1)
(130,422,1)
(160,319,1)
(240,131,1)
(375,340,1)
(103,17,1)
(118,47,1)
(133,338,1)
(105,107,1)
(235,27,1)
(293,445,1)
(426,264,1)
(154,397,1)
(104,24,1)
(276,235,1)
(38,10,1)
(316,246,1)
(443,340,1)
(435,257,1)
(391,255,1)
(88,333,1)
(429,319,1)
(242,210,1)
(323,322,1)
(328,147,1)
(401,340,1)
(195,319,1)
(375,319,1)
(307,343,1)
(342,83,1)
(20,390,1)
(225,142,1)
(359,340,1)
(129,150,1)
(71,461,1)
(258,347,1)
(75,405,1)
(191,89,1)
(233,230,1)
(215,123,1)
(123,305,1)
(326,361,1)
(165,168,1)
(371,377,1)
(407,130,1)
(108,298,1)
(242,277,1)
(384,2,1)
(411,144,1)
(372,37,1)
(203,152,1)
(93,455,1)
(330,141,1)
(236,3,1)
(13,185,1)
(443,319,1)
(451,83,1)
(303,148,1)
(308,197,1)
(31,347,1)
(437,149,1)
(314,224,1)
(290,410,1)
(244,289,1)
(78,238,1)
(343,9,1)
(203,63,1)
(416,189,1)
(379,336,1)
(403,7,1)
(89,83,1)
(239,422,1)
(390,0,1)
(245,319,1)
(92,113,1)
(260,305,1)
(390,336,1)
(87,49,1)
(189,229,1)
(18,78,1)
(79,8,1)
(89,347,1)
(390,296,1)
(67,401,1)
(145,176,1)
(268,0,1)
(462,422,1)
(147,319,1)
(362,127,1)
(395,143,1)
(262,463,1)
(398,461,1)
(279,340,1)
(425,242,1)
(455,336,1)
(47,304,1)
(118,392,1)
(427,92,1)
(270,83,1)
(333,363,1)
(213,125,1)
(53,58,1)
(233,83,1)
(137,112,1)
(298,87,1)
(273,340,1)
(201,83,1)
(451,340,1)
(401,83,1)
(210,347,1)
(279,83,1)
(149,126,1)
(451,185,1)
(413,396,1)
(354,319,1)
(332,208,1)
(266,326,1)
(78,83,1)
(200,362,1)
(364,419,1)
(127,83,1)
(48,225,1)
(389,244,1)
(352,411,1)
(316,319,1)
(408,33,1)
(102,340,1)
(122,153,1)
(380,414,1)
(58,347,1)
(213,319,1)
(34,418,1)
(408,83,1)
(101,15,1)
(14,0,1)
(25,83,1)
(279,319,1)
(225,425,1)
(147,340,1)
(143,308,1)
(409,116,1)
(154,107,1)
(6,23,1)
(340,172,1)
(45,172,1)
(133,420,1)
(78,340,1)
(121,45,1)
(152,186,1)
(416,107,1)
(77,178,1)
(187,83,1)
(112,126,1)
(120,26,1)
(96,352,1)
(158,46,1)
(14,336,1)
(259,212,1)
(182,192,1)
(254,231,1)
(37,138,1)
(312,455,1)
(390,142,1)
(218,347,1)
(371,465,1)
(11,35,1)
(321,336,1)
(8,406,1)
(223,431,1)
(169,335,1)
(71,416,1)
(186,292,1)
(369,349,1)
(219,176,1)
(273,347,1)
(207,451,1)
(294,240,1)
(441,142,1)
(163,306,1)
(359,120,1)
(303,319,1)
(131,233,1)
(80,319,1)
(429,347,1)
(69,286,1)
(34,176,1)
(279,347,1)
(247,107,1)
(111,319,1)
(349,207,1)
(436,83,1)
(216,226,1)
(18,379,1)
(166,407,1)
(123,225,1)
(80,83,1)
(144,319,1)
(302,423,1)
(309,217,1)
(249,389,1)
(151,91,1)
(160,340,1)
(14,142,1)
(408,340,1)
(15,13,1)
(130,82,1)
(213,347,1)
(121,411,1)
(59,186,1)
(40,195,1)
(389,319,1)
(440,422,1)
(448,41,1)
(285,160,1)
(271,209,1)
(270,340,1)
(141,392,1)
(111,83,1)
(103,172,1)
(359,347,1)
(453,273,1)
(245,83,1)
(305,340,1)
(141,90,1)
(98,19,1)
(72,29,1)
(348,1,1)
(406,336,1)
(97,465,1)
(211,56,1)
(64,309,1)
(334,211,1)
(258,83,1)
(359,319,1)
(44,458,1)
(183,388,1)
(342,340,1)
(43,201,1)
(186,302,1)
(327,422,1)
(103,422,1)
(36,338,1)
(135,303,1)
(368,285,1)
(319,258,1)
(106,107,1)
(377,172,1)
(451,347,1)
(272,156,1)
(192,376,1)
(228,317,1)
(443,83,1)
(371,422,1)
(102,83,1)
(219,34,1)
(388,254,1)
(433,368,1)
(26,1,1)
(151,370,1)
(59,219,1)
(402,382,1)
(136,428,1)
(446,36,1)
(165,458,1)
(195,271,1)
(304,38,1)
(434,441,1)
(245,340,1)
(311,83,1)
(110,75,1)
(311,319,1)
(4,453,1)
(233,347,1)
(25,340,1)
(404,169,1)
(429,83,1)
(447,218,1)
(258,340,1)
(127,347,1)
(311,344,1)
(187,83,2)
(239,411,2)
(409,165,2)
(148,155,2)
(44,62,2)
(339,354,2)
(157,165,2)
(426,62,2)
(98,107,2)
(371,377,2)
(364,165,2)
(342,319,2)
(234,83,2)
(119,165,2)
(429,347,2)
(188,445,2)
(58,319,2)
(31,347,2)
(34,34,2)
(103,465,2)
(160,140,2)
(258,319,2)
(411,144,2)
(57,113,2)
(348,191,2)
(445,195,2)
(103,162,2)
(356,162,2)
(129,368,2)
(195,201,2)
(294,187,2)
(359,340,2)
(49,85,2)
(85,165,2)
(145,176,2)
(225,455,2)
(72,90,2)
(127,319,2)
(319,258,2)
(53,207,2)
(249,62,2)
(394,85,2)
(236,461,2)
(354,340,2)
(103,172,2)
(89,368,2)
(398,107,2)
(294,90,2)
(215,155,2)
(239,176,2)
(270,83,2)
(322,201,2)
(90,339,2)
(102,126,2)
(134,195,2)
(14,142,2)
(443,340,2)
(58,340,2)
(201,462,2)
(142,276,2)
(348,359,2)
(318,90,2)
(210,347,2)
(78,347,2)
(177,62,2)
(213,340,2)
(290,410,2)
(411,165,2)
(336,248,2)
(146,90,2)
(271,201,2)
(38,215,2)
(453,207,2)
(118,148,2)
(401,340,2)
(78,185,2)
(268,195,2)
(100,62,2)
(186,219,2)
(312,455,2)
(106,107,2)
(290,351,2)
(43,37,2)
(217,126,2)
(320,140,2)
(179,308,2)
(121,85,2)
(376,113,2)
(11,406,2)
(164,201,2)
(270,340,2)
(75,336,2)
(321,195,2)
(361,303,2)
(252,25,2)
(35,207,2)
(176,241,2)
(155,455,2)
(188,107,2)
(172,62,2)
(316,201,2)
(213,201,2)
(359,368,2)
(147,83,2)
(218,347,2)
(58,207,2)
(165,168,2)
(401,195,2)
(78,83,2)
(178,85,2)
(436,319,2)
(139,461,2)
(423,195,2)
(254,195,2)
(181,25,2)
(355,370,2)
(158,155,2)
(144,165,2)
(219,85,2)
(104,201,2)
(408,155,2)
(294,72,2)
(226,455,2)
(369,207,2)
(133,420,2)
(36,358,2)
(415,370,2)
(183,340,2)
(280,422,2)
(383,155,2)
(233,90,2)
(353,195,2)
(323,201,2)
(349,207,2)
(443,83,2)
(303,455,2)
(429,319,2)
(327,255,2)
(163,62,2)
(140,155,2)
(57,172,2)
(187,347,2)
(465,411,2)
(294,318,2)
(377,85,2)
(266,326,2)
(116,62,2)
(141,165,2)
(71,107,2)
(188,106,2)
(389,347,2)
(0,155,2)
(179,37,2)
(189,165,2)
(436,83,2)
(218,83,2)
(102,319,2)
(39,255,2)
(231,195,2)
(81,422,2)
(437,126,2)
(390,0,2)
(4,207,2)
(110,195,2)
(247,107,2)
(162,85,2)
(443,319,2)
(295,368,2)
(340,382,2)
(244,62,2)
(67,195,2)
(208,155,2)
(210,340,2)
(239,165,2)
(285,140,2)
(186,186,2)
(34,219,2)
(313,165,2)
(326,303,2)
(33,155,2)
(210,455,2)
(358,308,2)
(144,62,2)
(354,392,2)
(430,195,2)
(160,319,2)
(255,90,2)
(95,85,2)
(25,201,2)
(213,347,2)
(201,37,2)
(225,142,2)
(227,37,2)
(120,368,2)
(139,62,2)
(111,340,2)
(31,83,2)
(354,319,2)
(402,85,2)
(186,292,2)
(390,336,2)
(195,83,2)
(420,422,2)
(280,85,2)
(359,83,2)
(354,347,2)
(342,455,2)
(235,455,2)
(443,347,2)
(188,195,2)
(12,201,2)
(59,37,2)
(442,90,2)
(392,90,2)
(102,340,2)
(234,392,2)
(223,90,2)
(299,90,2)
(298,85,2)
(274,155,2)
(76,455,2)
(359,347,2)
(375,347,2)
(215,123,2)
(59,34,2)
(373,455,2)
(151,370,2)
(77,85,2)
(80,340,2)
(354,360,2)
(114,360,2)
(187,319,2)
(455,336,2)
(384,165,2)
(270,319,2)
(191,368,2)
(64,195,2)
(315,85,2)
(420,358,2)
(165,159,2)
(149,126,2)
(463,155,2)
(183,347,2)
(45,172,2)
(118,392,2)
(401,347,2)
(375,83,2)
(272,62,2)
(378,195,2)
(282,37,2)
(438,155,2)
(71,461,2)
(145,195,2)
(237,195,2)
(398,461,2)
(157,62,2)
(119,62,2)
(331,0,2)
(451,347,2)
(155,303,2)
(19,37,2)
(419,165,2)
(304,155,2)
(246,85,2)
(454,455,2)
(413,195,2)
(284,326,2)
(401,319,2)
(2,165,2)
(13,126,2)
(80,83,2)
(118,83,2)
(34,186,2)
(160,340,2)
(242,455,2)
(303,347,2)
(287,62,2)
(375,340,2)
(314,98,2)
(266,303,2)
(440,422,2)
(206,155,2)
(71,165,2)
(177,107,2)
(145,111,2)
(396,195,2)
(41,358,2)
(219,34,2)
(85,62,2)
(6,140,2)
(145,237,2)
(155,266,2)
(123,225,2)
(416,165,2)
(191,89,2)
(7,234,2)
(287,422,2)
(303,83,2)
(53,58,2)
(127,347,2)
(452,62,2)
(118,319,2)
(101,445,2)
(130,358,2)
(118,347,2)
(205,162,2)
(113,85,2)
(195,347,2)
(55,326,2)
(279,83,2)
(433,368,2)
(408,340,2)
(90,165,2)
(169,90,2)
(165,62,2)
(83,172,2)
(127,126,2)
(317,195,2)
(89,347,2)
(281,195,2)
(273,319,2)
(293,445,2)
(431,90,2)
(296,195,2)
(259,195,2)
(20,195,2)
(319,165,2)
(351,155,2)
(35,5,2)
(201,347,2)
(461,154,2)
(245,340,2)
(126,195,2)
(379,336,2)
(183,195,2)
(212,195,2)
(375,319,2)
(241,443,2)
(390,142,2)
(22,62,2)
(311,155,2)
(194,85,2)
(78,319,2)
(61,62,2)
(332,155,2)
(308,197,2)
(209,201,2)
(165,426,2)
(258,165,2)
(135,303,2)
(318,255,2)
(88,172,2)
(0,447,2)
(236,62,2)
(446,358,2)
(78,379,2)
(303,340,2)
(137,126,2)
(248,183,2)
(253,455,2)
(31,319,2)
(409,62,2)
(338,358,2)
(305,340,2)
(372,37,2)
(447,225,2)
(106,195,2)
(400,37,2)
(152,195,2)
(145,30,2)
(316,37,2)
(276,235,2)
(368,285,2)
(273,340,2)
(278,90,2)
(102,347,2)
(144,347,2)
(96,165,2)
(31,340,2)
(123,155,2)
(331,336,2)
(288,195,2)
(279,340,2)
(78,340,2)
(10,279,2)
(345,85,2)
(371,465,2)
(311,83,2)
(35,53,2)
(96,62,2)
(216,455,2)
(38,155,2)
(61,165,2)
(184,455,2)
(389,461,2)
(417,155,2)
(325,368,2)
(455,195,2)
(136,85,2)
(213,319,2)
(172,177,2)
(242,210,2)
(461,62,2)
(160,347,2)
(34,165,2)
(14,195,2)
(105,107,2)
(46,155,2)
(89,83,2)
(255,347,2)
(260,155,2)
(273,347,2)
(160,83,2)
(47,155,2)
(83,85,2)
(328,126,2)
(182,85,2)
(87,85,2)
(108,85,2)
(138,358,2)
(264,62,2)
(389,319,2)
(108,172,2)
(18,379,2)
(294,442,2)
(251,195,2)
(162,371,2)
(65,37,2)
(314,202,2)
(154,62,2)
(180,195,2)
(382,88,2)
(406,207,2)
(192,85,2)
(93,455,2)
(163,139,2)
(59,219,2)
(234,347,2)
(118,155,2)
(218,319,2)
(28,358,2)
(375,455,2)
(270,347,2)
(18,155,2)
(219,292,2)
(436,368,2)
(243,165,2)
(42,358,2)
(451,319,2)
(276,455,2)
(331,142,2)
(144,319,2)
(240,225,2)
(443,201,2)
(107,358,2)
(303,148,2)
(408,319,2)
(147,340,2)
(51,195,2)
(379,155,2)
(241,201,2)
(232,195,2)
(219,219,2)
(401,83,2)
(302,195,2)
(398,165,2)
(127,83,2)
(220,461,2)
(462,201,2)
(159,62,2)
(1,368,2)
(248,225,2)
(258,195,2)
(363,162,2)
(285,160,2)
(411,62,2)
(397,62,2)
(176,201,2)
(201,340,2)
(133,338,2)
(3,62,2)
(7,455,2)
(79,207,2)
(203,165,2)
(127,340,2)
(105,37,2)
(390,195,2)
(370,336,2)
(336,195,2)
(54,368,2)
(435,257,2)
(258,83,2)
(339,360,2)
(75,142,2)
(172,165,2)
(40,195,2)
(318,327,2)
(351,429,2)
(195,319,2)
(144,83,2)
(75,0,2)
(127,445,2)
(348,368,2)
(121,45,2)
(421,195,2)
(123,305,2)
(303,392,2)
(218,155,2)
(289,62,2)
(444,195,2)
(151,326,2)
(334,155,2)
(248,195,2)
(330,165,2)
(282,201,2)
(456,62,2)
(89,319,2)
(449,37,2)
(279,184,2)
(371,422,2)
(277,455,2)
(245,319,2)
(314,224,2)
(237,107,2)
(195,340,2)
(52,155,2)
(406,336,2)
(34,176,2)
(439,62,2)
(58,83,2)
(113,121,2)
(112,126,2)
(203,195,2)
(32,455,2)
(239,62,2)
(380,195,2)
(458,62,2)
(177,165,2)
(53,273,2)
(279,155,2)
(414,195,2)
(198,113,2)
(130,422,2)
(142,455,2)
(408,83,2)
(386,455,2)
(186,176,2)
(270,455,2)
(20,390,2)
(263,90,2)
(354,83,2)
(187,90,2)
(343,195,2)
(56,336,2)
(30,422,2)
(403,455,2)
(239,422,2)
(293,195,2)
(211,155,2)
(418,165,2)
(456,165,2)
(338,422,2)
(311,319,2)
(441,455,2)
(389,83,2)
(165,458,2)
(30,195,2)
(273,207,2)
(234,455,2)
(210,83,2)
(376,57,2)
(24,201,2)
(37,308,2)
(115,90,2)
(109,195,2)
(347,81,2)
(98,37,2)
(147,126,2)
(56,155,2)
(60,37,2)
(368,155,2)
(294,176,2)
(221,37,2)
(352,165,2)
(432,162,2)
(234,340,2)
(362,126,2)
(108,107,2)
(245,83,2)
(297,455,2)
(442,347,2)
(210,319,2)
(15,126,2)
(37,358,2)
(26,368,2)
(156,165,2)
(245,90,2)
(151,91,2)
(131,90,2)
(91,370,2)
(25,347,2)
(234,319,2)
(436,340,2)
(245,347,2)
(407,358,2)
(290,155,2)
(307,195,2)
(102,445,2)
(239,272,2)
(10,155,2)
(121,422,2)
(233,340,2)
(451,185,2)
(1,422,2)
(111,319,2)
(279,319,2)
(386,270,2)
(238,379,2)
(255,319,2)
(224,37,2)
(348,1,2)
(429,155,2)
(247,195,2)
(201,83,2)
(213,83,2)
(16,85,2)
(133,358,2)
(101,126,2)
(103,422,2)
(118,340,2)
(150,368,2)
(59,186,2)
(91,207,2)
(347,37,2)
(80,90,2)
(85,239,2)
(147,319,2)
(352,62,2)
(305,155,2)
(313,62,2)
(360,165,2)
(354,148,2)
(262,155,2)
(174,165,2)
(89,340,2)
(311,340,2)
(116,165,2)
(102,83,2)
(429,83,2)
(187,340,2)
(273,83,2)
(144,340,2)
(465,176,2)
(451,83,2)
(202,358,2)
(255,185,2)
(207,451,2)
(333,162,2)
(200,126,2)
(91,11,2)
(305,83,2)
(230,90,2)
(266,151,2)
(140,118,2)
(38,10,2)
(173,85,2)
(17,162,2)
(319,195,2)
(342,83,2)
(59,292,2)
(186,195,2)
(197,435,2)
(58,347,2)
(404,90,2)
(111,83,2)
(416,107,2)
(448,358,2)
(175,155,2)
(335,90,2)
(11,207,2)
(342,347,2)
(73,37,2)
(445,247,2)
(38,290,2)
(279,347,2)
(408,347,2)
(72,245,2)
(75,195,2)
(25,83,2)
(11,35,2)
(240,90,2)
(305,319,2)
(286,90,2)
(306,62,2)
(233,347,2)
(459,255,2)
(220,165,2)
(228,165,2)
(133,308,2)
(62,401,2)
(168,62,2)
(69,90,2)
(351,408,2)
(168,236,2)
(156,62,2)
(228,195,2)
(340,85,2)
(48,455,2)
(440,85,2)
(434,455,2)
(460,155,2)
(14,0,2)
(183,83,2)
(243,62,2)
(450,90,2)
(126,31,2)
(344,155,2)
(121,411,2)
(310,165,2)
(462,422,2)
(241,213,2)
(294,240,2)
(124,155,2)
(447,155,2)
(388,195,2)
(199,155,2)
(234,148,2)
(201,319,2)
(442,184,2)
(255,340,2)
(107,133,2)
(389,340,2)
(427,113,2)
(25,340,2)
(185,126,2)
(88,162,2)
(29,90,2)
(31,195,2)
(183,319,2)
(62,195,2)
(305,347,2)
(382,162,2)
(272,165,2)
(327,422,2)
(92,113,2)
(166,358,2)
(371,85,2)
(391,255,2)
(8,207,2)
(386,342,2)
(23,140,2)
(147,347,2)
(45,85,2)
(359,319,2)
(258,340,2)
(269,455,2)
(331,195,2)
(377,172,2)
(80,319,2)
(389,62,2)
(83,376,2)
(342,340,2)
(71,416,2)
(428,85,2)
(303,319,2)
(235,27,2)
(111,347,2)
(436,347,2)
(125,201,2)
(340,172,2)
(204,379,2)
(287,165,2)
(462,37,2)
(73,422,2)
(111,195,2)
(9,195,2)
(283,85,2)
(429,340,2)
(124,18,2)
(22,165,2)
(233,319,2)
(81,37,2)
(201,201,2)
(82,358,2)
(14,336,2)
(97,85,2)
(25,319,2)
(451,370,2)
(403,7,2)
(458,163,2)
(50,165,2)
(442,83,2)
(18,78,2)
(255,83,2)
(465,85,2)
(63,195,2)
(317,165,2)
(442,340,2)
(370,326,2)
(442,319,2)
(211,56,2)
(240,233,2)
(326,336,2)
(219,176,2)
(275,195,2)
(229,165,2)
(425,455,2)
(460,124,2)
(154,107,2)
(311,347,2)
(207,370,2)
(186,34,2)
(235,386,2)
(368,140,2)
(405,195,2)
(80,347,2)
(233,83,2)
(34,292,2)
(128,155,2)
(145,293,2)
(99,85,2)
(218,340,2)
(447,218,2)
(309,126,2)
(451,340,2)
(84,155,2)
(258,347,2)
(219,186,2)
(94,360,2)
(348,436,2)
-----------------------------------
(0,object = old_entry->object.vm_object)
(1,vm_map_pmap(old_map)
(2,new_entry_needs_copy)
(3,offset)
(4,vme_start)
(5,vm_size_t)
(6,protection)
(7,!old_entry->needs_copy)
(8,old_entry)
(9,TRUE)
(10,&old_entry->offset)
(11,object->size > (vm_size_t)
(12,vme_start)
(13,new_entry)
(14,vm_object_lock(object)
(15,is_shared)
(16,continue;)
(17,start)
(18,object->shadowed && old_entry->is_shared)
(19,new_map)
(20,object->ref_count++)
(21,new_entry)
(22,KERN_SUCCESS)
(23,old_entry)
(24,old_entry)
(25,old_entry->is_sub_map)
(26,old_entry)
(27,vm_size_t)
(28,VM_MAP_NULL)
(29,~VM_PROT_WRITE)
(30,old_map->pmap)
(31,old_entry->projected_on)
(32,needs_copy)
(33,vme_start)
(34,new_size += entry_size)
(35,(vm_size_t)
(36,old_map)
(37,new_pmap == PMAP_NULL)
(38,vm_object_shadow(\n\\n\\t\\t\\t        &old_entry->object.vm_object,\n\\n\\t\\t\\t        &old_entry->offset,\n\\n\\t\\t\\t        (vm_size_t)
(39,PMAP_NULL)
(40,old_entry)
(41,old_map)
(42,new_pmap)
(43,new_map)
(44,new_entry)
(45,&last)
(46,old_entry)
(47,needs_copy)
(48,old_entry)
(49,new_map)
(50,new_entry)
(51,entry_size)
(52,object)
(53,old_entry->vme_end -\n\\n\\t\\t\\t\\t\\t\\told_entry->vme_start)
(54,protection)
(55,object)
(56,object->temporary)
(57,last->vme_next)
(58,old_entry->vme_start)
(59,new_map->size = new_size)
(60,VM_MAP_NULL)
(61,start)
(62,old_entry->wired_count == 0)
(63,break;)
(64,new_map)
(65,old_map)
(66,if (old_entry->projected_on != 0)
(67,0)
(68,)
(69,offset)
(70,case VM_INHERIT_SHARE:)
(71,vm_map_entry_link(new_map,\n\\n\\t\\t\\t\\t\\t\\tvm_map_last_entry(new_map)
(72,old_entry->protection &\n\\n\\t\\t\\t\\t\\t\\t\\t    ~VM_PROT_WRITE)
(73,vm_map_unlock(old_map)
(74,if (vm_object_copy_temporary(\n\\n\\t\\t\\t\\t\\t&new_entry->object.vm_object,\n\\n\\t\\t\\t\\t\\t&new_entry->offset,\n\\n\\t\\t\\t\\t\\t&src_needs_copy,\n\\n\\t\\t\\t\\t\\t&new_entry_needs_copy)
(75,vm_object_unlock(object)
(76,needs_copy)
(77,entry_size)
(78,old_entry->is_shared)
(79,vme_end)
(80,old_entry->needs_copy)
(81,vm_map_first_entry(old_map)
(82,old_map)
(83,old_entry = last)
(84,offset)
(85,vm_map_copyin(old_map,\n\\n\\t\\t\\t\\t\\tstart,\n\\n\\t\\t\\t\\t\\tentry_size,\n\\n\\t\\t\\t\\t\\tFALSE,\n\\n\\t\\t\\t\\t\\t&copy)
(86,if (src_needs_copy && !old_entry->needs_copy)
(87,last)
(88,last->vme_next)
(89,old_entry->protection)
(90,src_needs_copy && !old_entry->needs_copy)
(91,!old_entry->is_shared &&\n\\n\\t\\t\\t     object->size > (vm_size_t)
(92,last)
(93,old_entry)
(94,needs_copy)
(95,start)
(96,new_map)
(97,old_map)
(98,return(new_map)
(99,old_map)
(100,object)
(101,new_entry->is_shared)
(102,vm_map_entry_copy_full(new_entry, old_entry)
(103,vm_map_clip_start(old_map, last, start)
(104,is_sub_map)
(105,new_map->size)
(106,vm_map_last_entry(new_map)
(107,new_map = vm_map_create(new_pmap,\n\\n\\t\\t\\told_map->min_offset,\n\\n\\t\\t\\told_map->max_offset)
(108,vm_map_copy_insert(new_map, last, copy)
(109,new_map)
(110,new_entry)
(111,old_entry->vme_start)
(112,new_entry)
(113,!vm_map_lookup_entry(old_map, start, &last)
(114,old_entry)
(115,old_entry)
(116,entry_size)
(117,)
(118,old_entry->needs_copy)
(119,old_map)
(120,vme_start)
(121,vm_map_lookup_entry(old_map, start, &last)
(122,0)
(123,old_entry->object.vm_object)
(124,!(object->shadowed && old_entry->is_shared)
(125,vme_end)
(126,old_entry->projected_on != 0)
(127,vm_map_entry_copy(new_entry, old_entry)
(128,old_entry)
(129,vme_end)
(130,vm_map_lock(old_map)
(131,vm_object)
(132,case VM_INHERIT_COPY:)
(133,vm_map_create(new_pmap,\n\\n\\t\\t\\told_map->min_offset,\n\\n\\t\\t\\told_map->max_offset)
(134,vm_object)
(135,object)
(136,last)
(137,old_entry)
(138,PMAP_NULL)
(139,new_entry->object)
(140,!old_entry->needs_copy)
(141,new_entry)
(142,object = vm_object_allocate(\n\\n\\t\\t\\t\\t\\t    (vm_size_t)
(143,new_size)
(144,old_entry->vme_start)
(145,pmap_copy(new_map->pmap, old_map->pmap,\n\\n\\t\\t\\t\\tnew_entry->vme_start,\n\\n\\t\\t\\t\\tentry_size,\n\\n\\t\\t\\t\\told_entry->vme_start)
(146,old_entry)
(147,old_entry->is_shared)
(148,old_entry->needs_copy = FALSE)
(149,new_entry)
(150,old_entry)
(151,object->temporary && !old_entry->is_shared &&\n\\n\\t\\t\\t     object->size > (vm_size_t)
(152,break;)
(153,new_pmap)
(154,vm_map_entry_create(new_map)
(155,old_entry->needs_copy || object->shadowed ||\n\\n\\t\\t\\t    (object->temporary && !old_entry->is_shared &&\n\\n\\t\\t\\t     object->size > (vm_size_t)
(156,copy)
(157,start)
(158,vme_end)
(159,&src_needs_copy)
(160,old_entry->protection)
(161,PMAP_NULL)
(162,!vm_map_lookup_entry(old_map, start, &last)
(163,new_entry->object.vm_object)
(164,old_entry)
(165,vm_object_copy_temporary(\n\\n\\t\\t\\t\\t\\t&new_entry->object.vm_object,\n\\n\\t\\t\\t\\t\\t&new_entry->offset,\n\\n\\t\\t\\t\\t\\t&src_needs_copy,\n\\n\\t\\t\\t\\t\\t&new_entry_needs_copy)
(166,new_pmap)
(167,if (!old_entry->needs_copy &&\n\\n\\t\\t\\t\\t(old_entry->protection & VM_PROT_WRITE)
(168,&new_entry->offset)
(169,old_entry)
(170,if (new_pmap == PMAP_NULL)
(171,src_needs_copy)
(172,last = vm_map_last_entry(new_map)
(173,old_map)
(174,break;)
(175,old_entry)
(176,entry_size = (old_entry->vme_end - old_entry->vme_start)
(177,vm_map_last_entry(new_map)
(178,new_size)
(179,pmap_destroy(new_pmap)
(180,VM_OBJECT_NULL)
(181,panic("vm_map_fork: encountered a submap")
(182,last)
(183,old_entry->object)
(184,old_entry->offset = 0)
(185,old_entry->is_shared = TRUE)
(186,new_size += entry_size)
(187,old_entry->vme_start)
(188,vm_map_entry_link(\n\\n\\t\\t\\t\\tnew_map,\n\\n\\t\\t\\t\\tvm_map_last_entry(new_map)
(189,new_map)
(190,if (object == VM_OBJECT_NULL)
(191,old_entry->protection &\n\\n\\t\\t\\t\\t\\t     \\t~VM_PROT_WRITE)
(192,old_entry)
(193,new_map)
(194,old_map)
(195,old_entry->inheritance)
(196,)
(197,pmap_create((vm_size_t)
(198,vme_next)
(199,old_entry)
(200,is_shared)
(201,old_entry != vm_map_to_entry(old_map)
(202,return VM_MAP_NULL;)
(203,old_entry)
(204,old_entry)
(205,last)
(206,old_entry)
(207,!old_entry->is_shared)
(208,old_entry)
(209,old_entry)
(210,old_entry->object)
(211,assert(object->temporary)
(212,old_map)
(213,old_entry->vme_end)
(214,)
(215,&old_entry->object.vm_object)
(216,object)
(217,TRUE)
(218,old_entry->object)
(219,new_size += entry_size)
(220,new_entry->needs_copy)
(221,old_map)
(222,)
(223,needs_copy)
(224,return VM_MAP_NULL;)
(225,old_entry->object.vm_object = object)
(226,old_entry)
(227,size)
(228,vme_next)
(229,new_map)
(230,object)
(231,object)
(232,old_entry)
(233,old_entry->object)
(234,old_entry->needs_copy)
(235,(vm_size_t)
(236,new_entry->offset)
(237,new_map->pmap)
(238,is_shared)
(239,vm_map_copyin(old_map,\n\\n\\t\\t\\t\\t\\tstart,\n\\n\\t\\t\\t\\t\\tentry_size,\n\\n\\t\\t\\t\\t\\tFALSE,\n\\n\\t\\t\\t\\t\\t&copy)
(240,old_entry->object.vm_object)
(241,old_entry->vme_end - old_entry->vme_start)
(242,old_entry->object.vm_object)
(243,old_map)
(244,old_entry)
(245,old_entry->protection)
(246,continue;)
(247,vm_map_entry_create(new_map)
(248,old_entry->object.vm_object)
(249,new_entry)
(250,for (\n\\n\\t    old_entry = vm_map_first_entry(old_map)
(251,use_shared_copy)
(252,"vm_map_fork: encountered a submap")
(253,vme_end)
(254,old_entry)
(255,old_entry->is_shared)
(256,)
(257,vm_size_t)
(258,old_entry->vme_next)
(259,pmap)
(260,vm_object)
(261,if (new_pmap == PMAP_NULL)
(262,temporary)
(263,TRUE)
(264,new_entry_needs_copy)
(265,case VM_INHERIT_NONE:)
(266,object->shadowed ||\n\\n\\t\\t\\t    (object->temporary && !old_entry->is_shared &&\n\\n\\t\\t\\t     object->size > (vm_size_t)
(267,if (!vm_map_lookup_entry(old_map, start, &last)
(268,object)
(269,old_entry)
(270,old_entry->vme_start)
(271,inheritance)
(272,&copy)
(273,old_entry->vme_end)
(274,FALSE)
(275,projected_on)
(276,vm_object_allocate(\n\\n\\t\\t\\t\\t\\t    (vm_size_t)
(277,vm_object)
(278,protection)
(279,old_entry->offset)
(280,vm_map_lock(old_map)
(281,vme_start)
(282,old_map)
(283,entry_size)
(284,temporary)
(285,old_entry->protection & VM_PROT_WRITE)
(286,old_entry)
(287,vm_map_unlock(old_map)
(288,0)
(289,new_entry)
(290,(vm_size_t)
(291,)
(292,new_size = 0)
(293,new_entry->vme_start)
(294,vm_object_pmap_protect(\n\\n\\t\\t\\t\\t\\t\\t\\told_entry->object.vm_object,\n\\n\\t\\t\\t\\t\\t\\t\\told_entry->offset,\n\\n\\t\\t\\t\\t\\t\\t\\tentry_size,\n\\n\\t\\t\\t\\t\\t\\t\\t(old_entry->is_shared ?\n\\n\\t\\t\\t\\t\\t\\t\\t\\tPMAP_NULL :\n\\n\\t\\t\\t\\t\\t\\t\\t\\told_map->pmap)
(295,old_entry)
(296,ref_count)
(297,vme_start)
(298,copy)
(299,old_entry)
(300,if (old_entry->wired_count == 0)
(301,new_pmap)
(302,entry_size)
(303,old_entry->needs_copy)
(304,old_entry)
(305,old_entry->object)
(306,vm_object)
(307,object)
(308,new_pmap = pmap_create((vm_size_t)
(309,new_entry->is_shared = TRUE)
(310,new_size)
(311,old_entry->needs_copy)
(312,object)
(313,old_entry)
(314,RET)
(315,start)
(316,old_entry)
(317,old_entry)
(318,old_entry->is_shared ?\n\\n\\t\\t\\t\\t\\t\\t\\t\\tPMAP_NULL :\n\\n\\t\\t\\t\\t\\t\\t\\t\\told_map->pmap)
(319,old_entry = old_entry->vme_next)
(320,VM_PROT_WRITE)
(321,object)
(322,entry_size)
(323,old_entry)
(324,)
(325,~VM_PROT_WRITE)
(326,object->shadowed)
(327,old_map->pmap)
(328,TRUE)
(329,if (!vm_map_lookup_entry(old_map, start, &last)
(330,needs_copy)
(331,object->use_shared_copy)
(332,object)
(333,vme_next)
(334,object)
(335,entry_size)
(336,object = old_entry->object.vm_object)
(337,new_entry_needs_copy)
(338,old_map->min_offset)
(339,!old_entry->needs_copy)
(340,old_entry = last)
(341,new_pmap)
(342,old_entry->vme_end)
(343,object->use_shared_copy = TRUE)
(344,needs_copy)
(345,last)
(346,last)
(347,old_entry = vm_map_first_entry(old_map)
(348,pmap_protect(vm_map_pmap(old_map)
(349,object)
(350,old_entry)
(351,old_entry->vme_end -\n\\n\\t\\t\\t\\t\\t     old_entry->vme_start)
(352,last)
(353,old_entry)
(354,old_entry->needs_copy)
(355,is_shared)
(356,last)
(357,object)
(358,new_pmap == PMAP_NULL)
(359,old_entry->vme_start)
(360,src_needs_copy)
(361,shadowed)
(362,old_entry)
(363,last)
(364,new_entry)
(365,)
(366,)
(367,copy)
(368,!old_entry->needs_copy &&\n\\n\\t\\t\\t\\t(old_entry->protection & VM_PROT_WRITE)
(369,size)
(370,object->temporary)
(371,vm_map_lookup_entry(old_map, start, &last)
(372,old_entry)
(373,old_entry)
(374,)
(375,old_entry->offset)
(376,last = last->vme_next)
(377,&last)
(378,new_entry)
(379,object->shadowed)
(380,vme_start)
(381,if (vm_map_copyin(old_map,\n\\n\\t\\t\\t\\t\\tstart,\n\\n\\t\\t\\t\\t\\tentry_size,\n\\n\\t\\t\\t\\t\\tFALSE,\n\\n\\t\\t\\t\\t\\t&copy)
(382,last = last->vme_next)
(383,vm_object)
(384,new_entry->needs_copy = new_entry_needs_copy)
(385,)
(386,old_entry->vme_end -\n\\n\\t\\t\\t\\t\\t\\t\\told_entry->vme_start)
(387,new_size)
(388,object)
(389,vm_map_entry_copy(new_entry, old_entry)
(390,object->ref_count)
(391,old_map)
(392,old_entry->needs_copy = TRUE)
(393,switch (old_entry->inheritance)
(394,last)
(395,0)
(396,new_map)
(397,new_map)
(398,vm_map_entry_dispose(new_map, new_entry)
(399,if (old_entry->is_sub_map)
(400,new_pmap)
(401,old_entry->wired_count)
(402,old_entry)
(403,assert(!old_entry->needs_copy)
(404,is_shared)
(405,object)
(406,object->size)
(407,new_map)
(408,old_entry->vme_start)
(409,FALSE)
(410,vm_size_t)
(411,start = old_entry->vme_start)
(412,start)
(413,pmap)
(414,new_entry)
(415,old_entry)
(416,vm_map_last_entry(new_map)
(417,object)
(418,entry_size)
(419,new_map)
(420,old_map->max_offset)
(421,object)
(422,vm_map_t old_map)
(423,new_size)
(424,)
(425,object)
(426,&new_entry_needs_copy)
(427,last)
(428,start)
(429,old_entry->vme_end)
(430,new_map)
(431,old_entry)
(432,old_map)
(433,old_map)
(434,offset)
(435,(vm_size_t)
(436,old_entry->vme_end)
(437,old_entry)
(438,shadowed)
(439,src_needs_copy)
(440,vm_map_lock(old_map)
(441,old_entry)
(442,old_entry->offset)
(443,old_entry->vme_start)
(444,wired_count)
(445,new_entry = vm_map_entry_create(new_map)
(446,max_offset)
(447,old_entry->object.vm_object)
(448,min_offset)
(449,new_size)
(450,vme_start)
(451,old_entry->is_shared)
(452,new_entry)
(453,old_entry)
(454,0)
(455,object == VM_OBJECT_NULL)
(456,vme_start)
(457,entry_size)
(458,&new_entry->object.vm_object)
(459,pmap)
(460,assert(!(object->shadowed && old_entry->is_shared)
(461,new_entry = vm_map_entry_create(new_map)
(462,vm_map_to_entry(old_map)
(463,object)
(464,)
(465,start += entry_size)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^