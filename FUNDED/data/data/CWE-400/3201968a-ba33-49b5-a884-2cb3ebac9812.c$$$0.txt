-----label-----
1
-----code-----
static void
ImgPhotoInstanceSetSize(
    PhotoInstance *instancePtr)	/* Instance whose size is to be changed. */
{
    PhotoMaster *masterPtr;
    schar *newError, *errSrcPtr, *errDestPtr;
    int h, offset;
    XRectangle validBox;
    Pixmap newPixmap;

    masterPtr = instancePtr->masterPtr;
    TkClipBox(masterPtr->validRegion, &validBox);

    if ((instancePtr->width != masterPtr->width)
	    || (instancePtr->height != masterPtr->height)
	    || (instancePtr->pixels == None)) {
	newPixmap = Tk_GetPixmap(instancePtr->display,
		RootWindow(instancePtr->display,
			instancePtr->visualInfo.screen),
		(masterPtr->width > 0) ? masterPtr->width: 1,
		(masterPtr->height > 0) ? masterPtr->height: 1,
		instancePtr->visualInfo.depth);
	if (!newPixmap) {
	    Tcl_Panic("Fail to create pixmap with Tk_GetPixmap in ImgPhotoInstanceSetSize.\n");
	}

	/*
	 * The following is a gross hack needed to properly support colormaps
	 * under Windows. Before the pixels can be copied to the pixmap, the
	 * relevent colormap must be associated with the drawable. Normally we
	 * can infer this association from the window that was used to create
	 * the pixmap. However, in this case we're using the root window, so
	 * we have to be more explicit.
	 */

	TkSetPixmapColormap(newPixmap, instancePtr->colormap);

	if (instancePtr->pixels != None) {
	    /*
	     * Copy any common pixels from the old pixmap and free it.
	     */

	    XCopyArea(instancePtr->display, instancePtr->pixels, newPixmap,
		    instancePtr->gc, validBox.x, validBox.y,
		    validBox.width, validBox.height, validBox.x, validBox.y);
	    Tk_FreePixmap(instancePtr->display, instancePtr->pixels);
	}
	instancePtr->pixels = newPixmap;
    }

    if ((instancePtr->width != masterPtr->width)
	    || (instancePtr->height != masterPtr->height)
	    || (instancePtr->error == NULL)) {

	if (masterPtr->height > 0 && masterPtr->width > 0) {
	    newError = (schar *) ckalloc((unsigned)
		    masterPtr->height * masterPtr->width * 3 * sizeof(schar));

	    /*
	     * Zero the new array so that we don't get bogus error values
	     * propagating into areas we dither later.
	     */

	    if ((instancePtr->error != NULL)
		    && ((instancePtr->width == masterPtr->width)
		    || (validBox.width == masterPtr->width))) {
		if (validBox.y > 0) {
		    memset(newError, 0, (size_t)
			    validBox.y * masterPtr->width * 3 * sizeof(schar));
		}
		h = validBox.y + validBox.height;
		if (h < masterPtr->height) {
		    memset(newError + h*masterPtr->width*3, 0,
			    (size_t) (masterPtr->height - h)
			    * masterPtr->width * 3 * sizeof(schar));
		}
	    } else {
		memset(newError, 0, (size_t)
			masterPtr->height * masterPtr->width *3*sizeof(schar));
	    }
	} else {
	    newError = NULL;
	}

	if (instancePtr->error != NULL) {
	    /*
	     * Copy the common area over to the new array and free the old
	     * array.
	     */

	    if (masterPtr->width == instancePtr->width) {
		offset = validBox.y * masterPtr->width * 3;
		memcpy(newError + offset, instancePtr->error + offset,
			(size_t) (validBox.height
			* masterPtr->width * 3 * sizeof(schar)));

	    } else if (validBox.width > 0 && validBox.height > 0) {
		errDestPtr = newError +
			(validBox.y * masterPtr->width + validBox.x) * 3;
		errSrcPtr = instancePtr->error +
			(validBox.y * instancePtr->width + validBox.x) * 3;

		for (h = validBox.height; h > 0; --h) {
		    memcpy(errDestPtr, errSrcPtr,
			    validBox.width * 3 * sizeof(schar));
		    errDestPtr += masterPtr->width * 3;
		    errSrcPtr += instancePtr->width * 3;
		}
	    }
	    ckfree((char *) instancePtr->error);
	}

	instancePtr->error = newError;
    }

    instancePtr->width = masterPtr->width;
    instancePtr->height = masterPtr->height;
}
-----children-----
1,2
1,3
1,4
3,4
3,5
5,6
5,7
6,7
8,9
8,10
11,12
11,13
11,14
11,15
11,16
11,17
11,18
11,19
11,20
11,21
11,22
12,13
13,14
13,15
14,15
16,17
16,18
19,20
20,21
20,22
20,23
20,24
21,22
23,24
23,25
26,27
26,28
29,30
29,31
32,33
33,34
33,35
33,36
35,36
37,38
39,40
40,41
40,42
41,42
43,44
45,46
46,47
46,48
47,48
49,50
51,52
52,53
52,54
53,54
55,56
55,57
56,57
59,60
60,61
60,62
60,63
61,62
63,64
63,65
64,65
67,68
68,69
70,71
70,72
71,72
71,73
72,73
72,74
73,74
74,75
74,76
75,76
75,77
76,77
79,80
79,81
80,81
83,84
84,85
84,86
85,86
85,87
86,87
89,90
89,91
90,91
93,94
94,95
94,96
95,96
95,97
96,97
99,100
101,102
101,103
101,104
101,105
101,106
102,103
103,104
103,105
104,105
106,107
106,108
106,109
106,110
106,111
106,112
107,108
109,110
109,111
110,111
113,114
113,115
113,116
114,115
116,117
116,118
117,118
120,121
120,122
121,122
121,123
122,123
126,127
126,128
126,129
127,128
128,129
128,130
129,130
129,131
130,131
134,135
134,136
135,136
139,140
139,141
139,142
140,141
141,142
141,143
142,143
142,144
143,144
147,148
147,149
148,149
152,153
152,154
153,154
153,155
154,155
158,159
158,160
159,160
160,161
162,163
163,164
164,165
164,166
165,166
168,169
169,170
169,171
169,172
170,171
172,173
174,175
174,176
175,176
178,179
178,180
179,180
179,181
180,181
180,182
181,182
184,185
186,187
186,188
187,188
188,189
188,190
188,191
188,192
188,193
188,194
188,195
188,196
188,197
188,198
188,199
189,190
191,192
191,193
192,193
195,196
195,197
196,197
199,200
201,202
201,203
202,203
205,206
205,207
206,207
209,210
209,211
210,211
213,214
213,215
214,215
217,218
217,219
218,219
221,222
221,223
222,223
225,226
225,227
226,227
229,230
230,231
230,232
230,233
231,232
233,234
233,235
234,235
237,238
237,239
238,239
241,242
242,243
242,244
243,244
243,245
244,245
247,248
249,250
249,251
250,251
250,252
251,252
251,253
252,253
253,254
253,255
254,255
254,256
255,256
258,259
258,260
259,260
262,263
263,264
263,265
264,265
264,266
265,266
268,269
268,270
269,270
272,273
273,274
273,275
274,275
274,276
275,276
278,279
280,281
280,282
280,283
281,282
281,283
281,284
282,283
282,284
283,284
283,285
284,285
284,286
285,286
289,290
289,291
290,291
290,292
291,292
295,296
295,297
296,297
297,298
297,299
298,299
300,301
300,302
301,302
301,303
302,303
304,305
306,307
306,308
307,308
309,310
309,311
310,311
310,312
311,312
311,313
312,313
312,314
313,314
313,315
316,317
316,318
317,318
320,321
320,322
321,322
325,326
326,327
326,328
327,328
330,331
330,332
330,333
331,332
331,333
332,333
333,334
333,335
334,335
334,336
335,336
338,339
340,341
341,342
341,343
342,343
343,344
343,345
344,345
344,346
345,346
348,349
348,350
349,350
352,353
353,354
353,355
354,355
354,356
355,356
358,359
358,360
359,360
362,363
362,364
362,365
363,364
363,365
364,365
364,366
365,366
365,367
366,367
370,371
371,372
372,373
372,374
372,375
372,376
373,374
375,376
378,379
378,380
379,380
379,381
380,381
380,382
381,382
381,383
382,383
382,384
383,384
386,387
386,388
387,388
390,391
390,392
391,392
395,396
396,397
396,398
397,398
400,401
401,402
401,403
402,403
404,405
404,406
405,406
405,407
406,407
409,410
409,411
410,411
413,414
413,415
414,415
414,416
415,416
417,418
417,419
418,419
421,422
422,423
423,424
423,425
423,426
423,427
424,425
426,427
426,428
427,428
429,430
429,431
430,431
430,432
431,432
433,434
433,435
434,435
439,440
439,441
440,441
440,442
441,442
441,443
442,443
442,444
443,444
444,445
446,447
446,448
447,448
447,449
448,449
451,452
453,454
453,455
454,455
458,459
459,460
459,461
460,461
463,464
464,465
465,466
465,467
465,468
465,469
466,467
468,469
471,472
471,473
472,473
472,474
473,474
473,475
474,475
474,476
475,476
475,477
476,477
479,480
479,481
480,481
483,484
483,485
484,485
488,489
489,490
489,491
490,491
493,494
494,495
495,496
495,497
496,497
498,499
500,501
500,502
501,502
501,503
502,503
502,504
503,504
506,507
508,509
508,510
509,510
509,511
509,512
510,511
510,512
511,512
511,513
512,513
515,516
515,517
516,517
519,520
519,521
520,521
521,522
521,523
522,523
524,525
524,526
525,526
525,527
526,527
526,528
527,528
530,531
530,532
531,532
535,536
536,537
536,538
536,539
536,540
537,538
539,540
539,541
540,541
542,543
544,545
544,546
545,546
545,547
546,547
549,550
551,552
551,553
552,553
553,554
555,556
555,557
556,557
556,558
557,558
557,559
558,559
558,560
559,560
562,563
562,564
563,564
567,568
568,569
568,570
569,570
572,573
572,574
573,574
573,575
574,575
574,576
575,576
575,577
576,577
580,581
580,582
581,582
581,583
582,583
586,587
586,588
586,589
587,588
588,589
588,590
589,590
591,592
591,593
592,593
594,595
594,596
595,596
596,597
596,598
597,598
597,599
598,599
598,600
599,600
602,603
602,604
603,604
606,607
606,608
607,608
611,612
612,613
612,614
613,614
615,616
615,617
616,617
616,618
617,618
620,621
620,622
621,622
622,623
622,624
623,624
623,625
624,625
624,626
625,626
628,629
628,630
629,630
632,633
632,634
633,634
637,638
637,639
637,640
637,641
638,639
639,640
639,641
640,641
642,643
642,644
643,644
646,647
646,648
647,648
650,651
651,652
653,654
653,655
653,656
654,655
655,656
655,657
655,658
655,659
656,657
658,659
660,661
662,663
662,664
663,664
663,665
664,665
664,666
665,666
669,670
670,671
670,672
671,672
674,675
675,676
675,677
676,677
678,679
678,680
679,680
679,681
680,681
684,685
685,686
685,687
686,687
688,689
688,690
689,690
689,691
690,691
694,695
695,696
695,697
696,697
698,699
698,700
699,700
699,701
701,702
703,704
703,705
704,705
707,708
708,709
708,710
709,710
709,711
710,711
713,714
715,716
716,717
716,718
717,718
717,719
718,719
721,722
721,723
722,723
725,726
726,727
726,728
727,728
727,729
728,729
731,732
731,733
732,733
-----nextToken-----
2,4,7,9,10,15,17,18,22,24,25,27,28,30,31,34,36,38,42,44,48,50,54,57,58,62,65,66,69,77,78,81,82,87,88,91,92,97,98,100,105,108,111,112,115,118,119,123,124,125,131,132,133,136,137,138,144,145,146,149,150,151,155,156,157,161,166,167,171,173,176,177,182,183,185,190,193,194,197,198,200,203,204,207,208,211,212,215,216,219,220,223,224,227,228,232,235,236,239,240,245,246,248,256,257,260,261,266,267,270,271,276,277,279,286,287,288,292,293,294,299,303,305,308,314,315,318,319,322,323,324,328,329,336,337,339,346,347,350,351,356,357,360,361,367,368,369,374,376,377,384,385,388,389,392,393,394,398,399,403,407,408,411,412,416,419,420,425,428,432,435,436,437,438,445,449,450,452,455,456,457,461,462,467,469,470,477,478,481,482,485,486,487,491,492,497,499,504,505,507,513,514,517,518,523,528,529,532,533,534,538,541,543,547,548,550,554,560,561,564,565,566,570,571,577,578,579,583,584,585,590,593,600,601,604,605,608,609,610,614,618,619,626,627,630,631,634,635,636,641,644,645,648,649,652,657,659,661,666,667,668,672,673,677,681,682,683,687,691,692,693,697,700,702,705,706,711,712,714,719,720,723,724,729,730,733,734
-----computeFrom-----
52,53
52,54
71,72
71,73
72,73
72,74
74,75
74,76
84,85
84,86
94,95
94,96
103,104
103,105
128,129
128,130
141,142
141,143
179,180
179,181
242,243
242,244
250,251
250,252
251,252
251,253
253,254
253,255
263,264
263,265
273,274
273,275
282,283
282,284
283,284
283,285
289,290
289,291
297,298
297,299
309,310
309,311
310,311
310,312
311,312
311,313
331,332
331,333
333,334
333,335
341,342
341,343
343,344
343,345
353,354
353,355
364,365
364,366
378,379
378,380
379,380
379,381
380,381
380,382
401,402
401,403
404,405
404,406
414,415
414,416
426,427
426,428
429,430
429,431
430,431
430,432
439,440
439,441
440,441
440,442
441,442
441,443
446,447
446,448
471,472
471,473
472,473
472,474
473,474
473,475
495,496
495,497
501,502
501,503
510,511
510,512
521,522
521,523
524,525
524,526
525,526
525,527
539,540
539,541
544,545
544,546
555,556
555,557
556,557
556,558
557,558
557,559
573,574
573,575
574,575
574,576
580,581
580,582
588,589
588,590
591,592
591,593
594,595
594,596
596,597
596,598
597,598
597,599
612,613
612,614
615,616
615,617
620,621
620,622
622,623
622,624
623,624
623,625
639,640
639,641
646,647
646,648
662,663
662,664
663,664
663,665
675,676
675,677
678,679
678,680
685,686
685,687
688,689
688,690
708,709
708,710
716,717
716,718
726,727
726,728
-----guardedBy-----
98,246
91,149
82,216
97,245
100,185
92,220
183,240
182,239
279,507
270,681
261,692
276,711
277,712
271,645
292,485
293,486
287,482
360,455
356,411
361,456
367,388
368,389
419,455
416,452
420,450
504,705
505,706
513,564
518,565
517,547
583,666
578,692
584,645
-----guardedByNegation-----
360,485
361,486
513,681
518,692
517,691
-----lastLexicalUse-----
360,485
361,486
513,681
518,692
517,691
-----jump-----
360,485
361,486
513,681
518,692
517,691
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;Declarator;Pointer;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;ConditionalExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ConditionalExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;Pointer;FunctionCallExpression;IdExpression;Name;BinaryExpression;BinaryExpression;BinaryExpression;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;BinaryExpression;BinaryExpression;BinaryExpression;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;BinaryExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;BinaryExpression;BinaryExpression;BinaryExpression;FunctionCallExpression;UnaryExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;BinaryExpression;BinaryExpression;BinaryExpression;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;FunctionCallExpression;UnaryExpression;IdExpression;Name;BinaryExpression;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;IfStatement;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;BinaryExpression;UnaryExpression;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;UnaryExpression;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;
-----ast_node-----
static voidImgPhotoInstanceSetSize(    PhotoInstance *instancePtr)	/* Instance whose size is to be changed. */{    PhotoMaster *masterPtr;    schar *newError, *errSrcPtr, *errDestPtr;    int h, offset;    XRectangle validBox;    Pixmap newPixmap;    masterPtr = instancePtr->masterPtr;    TkClipBox(masterPtr->validRegion, &validBox);    if ((instancePtr->width != masterPtr->width)	    || (instancePtr->height != masterPtr->height)	    || (instancePtr->pixels == None)) {	newPixmap = Tk_GetPixmap(instancePtr->display,		RootWindow(instancePtr->display,			instancePtr->visualInfo.screen),		(masterPtr->width > 0) ? masterPtr->width: 1,		(masterPtr->height > 0) ? masterPtr->height: 1,		instancePtr->visualInfo.depth);	if (!newPixmap) {	    Tcl_Panic("Fail to create pixmap with Tk_GetPixmap in ImgPhotoInstanceSetSize.\n");	}	/*	 * The following is a gross hack needed to properly support colormaps	 * under Windows. Before the pixels can be copied to the pixmap, the	 * relevent colormap must be associated with the drawable. Normally we	 * can infer this association from the window that was used to create	 * the pixmap. However, in this case we're using the root window, so	 * we have to be more explicit.	 */	TkSetPixmapColormap(newPixmap, instancePtr->colormap);	if (instancePtr->pixels != None) {	    /*	     * Copy any common pixels from the old pixmap and free it.	     */	    XCopyArea(instancePtr->display, instancePtr->pixels, newPixmap,		    instancePtr->gc, validBox.x, validBox.y,		    validBox.width, validBox.height, validBox.x, validBox.y);	    Tk_FreePixmap(instancePtr->display, instancePtr->pixels);	}	instancePtr->pixels = newPixmap;    }    if ((instancePtr->width != masterPtr->width)	    || (instancePtr->height != masterPtr->height)	    || (instancePtr->error == NULL)) {	if (masterPtr->height > 0 && masterPtr->width > 0) {	    newError = (schar *) ckalloc((unsigned)		    masterPtr->height * masterPtr->width * 3 * sizeof(schar));	    /*	     * Zero the new array so that we don't get bogus error values	     * propagating into areas we dither later.	     */	    if ((instancePtr->error != NULL)		    && ((instancePtr->width == masterPtr->width)		    || (validBox.width == masterPtr->width))) {		if (validBox.y > 0) {		    memset(newError, 0, (size_t)			    validBox.y * masterPtr->width * 3 * sizeof(schar));		}		h = validBox.y + validBox.height;		if (h < masterPtr->height) {		    memset(newError + h*masterPtr->width*3, 0,			    (size_t) (masterPtr->height - h)			    * masterPtr->width * 3 * sizeof(schar));		}	    } else {		memset(newError, 0, (size_t)			masterPtr->height * masterPtr->width *3*sizeof(schar));	    }	} else {	    newError = NULL;	}	if (instancePtr->error != NULL) {	    /*	     * Copy the common area over to the new array and free the old	     * array.	     */	    if (masterPtr->width == instancePtr->width) {		offset = validBox.y * masterPtr->width * 3;		memcpy(newError + offset, instancePtr->error + offset,			(size_t) (validBox.height			* masterPtr->width * 3 * sizeof(schar)));	    } else if (validBox.width > 0 && validBox.height > 0) {		errDestPtr = newError +			(validBox.y * masterPtr->width + validBox.x) * 3;		errSrcPtr = instancePtr->error +			(validBox.y * instancePtr->width + validBox.x) * 3;		for (h = validBox.height; h > 0; --h) {		    memcpy(errDestPtr, errSrcPtr,			    validBox.width * 3 * sizeof(schar));		    errDestPtr += masterPtr->width * 3;		    errSrcPtr += instancePtr->width * 3;		}	    }	    ckfree((char *) instancePtr->error);	}	instancePtr->error = newError;    }    instancePtr->width = masterPtr->width;    instancePtr->height = masterPtr->height;}
static void
ImgPhotoInstanceSetSize(    PhotoInstance *instancePtr)
ImgPhotoInstanceSetSize
PhotoInstance *instancePtr
PhotoInstance
PhotoInstance
*instancePtr
*
instancePtr
{    PhotoMaster *masterPtr;    schar *newError, *errSrcPtr, *errDestPtr;    int h, offset;    XRectangle validBox;    Pixmap newPixmap;    masterPtr = instancePtr->masterPtr;    TkClipBox(masterPtr->validRegion, &validBox);    if ((instancePtr->width != masterPtr->width)	    || (instancePtr->height != masterPtr->height)	    || (instancePtr->pixels == None)) {	newPixmap = Tk_GetPixmap(instancePtr->display,		RootWindow(instancePtr->display,			instancePtr->visualInfo.screen),		(masterPtr->width > 0) ? masterPtr->width: 1,		(masterPtr->height > 0) ? masterPtr->height: 1,		instancePtr->visualInfo.depth);	if (!newPixmap) {	    Tcl_Panic("Fail to create pixmap with Tk_GetPixmap in ImgPhotoInstanceSetSize.\n");	}	/*	 * The following is a gross hack needed to properly support colormaps	 * under Windows. Before the pixels can be copied to the pixmap, the	 * relevent colormap must be associated with the drawable. Normally we	 * can infer this association from the window that was used to create	 * the pixmap. However, in this case we're using the root window, so	 * we have to be more explicit.	 */	TkSetPixmapColormap(newPixmap, instancePtr->colormap);	if (instancePtr->pixels != None) {	    /*	     * Copy any common pixels from the old pixmap and free it.	     */	    XCopyArea(instancePtr->display, instancePtr->pixels, newPixmap,		    instancePtr->gc, validBox.x, validBox.y,		    validBox.width, validBox.height, validBox.x, validBox.y);	    Tk_FreePixmap(instancePtr->display, instancePtr->pixels);	}	instancePtr->pixels = newPixmap;    }    if ((instancePtr->width != masterPtr->width)	    || (instancePtr->height != masterPtr->height)	    || (instancePtr->error == NULL)) {	if (masterPtr->height > 0 && masterPtr->width > 0) {	    newError = (schar *) ckalloc((unsigned)		    masterPtr->height * masterPtr->width * 3 * sizeof(schar));	    /*	     * Zero the new array so that we don't get bogus error values	     * propagating into areas we dither later.	     */	    if ((instancePtr->error != NULL)		    && ((instancePtr->width == masterPtr->width)		    || (validBox.width == masterPtr->width))) {		if (validBox.y > 0) {		    memset(newError, 0, (size_t)			    validBox.y * masterPtr->width * 3 * sizeof(schar));		}		h = validBox.y + validBox.height;		if (h < masterPtr->height) {		    memset(newError + h*masterPtr->width*3, 0,			    (size_t) (masterPtr->height - h)			    * masterPtr->width * 3 * sizeof(schar));		}	    } else {		memset(newError, 0, (size_t)			masterPtr->height * masterPtr->width *3*sizeof(schar));	    }	} else {	    newError = NULL;	}	if (instancePtr->error != NULL) {	    /*	     * Copy the common area over to the new array and free the old	     * array.	     */	    if (masterPtr->width == instancePtr->width) {		offset = validBox.y * masterPtr->width * 3;		memcpy(newError + offset, instancePtr->error + offset,			(size_t) (validBox.height			* masterPtr->width * 3 * sizeof(schar)));	    } else if (validBox.width > 0 && validBox.height > 0) {		errDestPtr = newError +			(validBox.y * masterPtr->width + validBox.x) * 3;		errSrcPtr = instancePtr->error +			(validBox.y * instancePtr->width + validBox.x) * 3;		for (h = validBox.height; h > 0; --h) {		    memcpy(errDestPtr, errSrcPtr,			    validBox.width * 3 * sizeof(schar));		    errDestPtr += masterPtr->width * 3;		    errSrcPtr += instancePtr->width * 3;		}	    }	    ckfree((char *) instancePtr->error);	}	instancePtr->error = newError;    }    instancePtr->width = masterPtr->width;    instancePtr->height = masterPtr->height;}
PhotoMaster *masterPtr;
PhotoMaster *masterPtr;
PhotoMaster
PhotoMaster
*masterPtr
*
masterPtr
schar *newError, *errSrcPtr, *errDestPtr;
schar *newError, *errSrcPtr, *errDestPtr;
schar
schar
*newError
*
newError
*errSrcPtr
*
errSrcPtr
*errDestPtr
*
errDestPtr
int h, offset;
int h, offset;
int
h
h
offset
offset
XRectangle validBox;
XRectangle validBox;
XRectangle
XRectangle
validBox
validBox
Pixmap newPixmap;
Pixmap newPixmap;
Pixmap
Pixmap
newPixmap
newPixmap
masterPtr = instancePtr->masterPtr;
masterPtr = instancePtr->masterPtr
masterPtr
masterPtr
instancePtr->masterPtr
instancePtr
instancePtr
masterPtr
TkClipBox(masterPtr->validRegion, &validBox);
TkClipBox(masterPtr->validRegion, &validBox)
TkClipBox
TkClipBox
masterPtr->validRegion
masterPtr
masterPtr
validRegion
&validBox
validBox
validBox
if ((instancePtr->width != masterPtr->width)	    || (instancePtr->height != masterPtr->height)	    || (instancePtr->pixels == None)) {	newPixmap = Tk_GetPixmap(instancePtr->display,		RootWindow(instancePtr->display,			instancePtr->visualInfo.screen),		(masterPtr->width > 0) ? masterPtr->width: 1,		(masterPtr->height > 0) ? masterPtr->height: 1,		instancePtr->visualInfo.depth);	if (!newPixmap) {	    Tcl_Panic("Fail to create pixmap with Tk_GetPixmap in ImgPhotoInstanceSetSize.\n");	}	/*	 * The following is a gross hack needed to properly support colormaps	 * under Windows. Before the pixels can be copied to the pixmap, the	 * relevent colormap must be associated with the drawable. Normally we	 * can infer this association from the window that was used to create	 * the pixmap. However, in this case we're using the root window, so	 * we have to be more explicit.	 */	TkSetPixmapColormap(newPixmap, instancePtr->colormap);	if (instancePtr->pixels != None) {	    /*	     * Copy any common pixels from the old pixmap and free it.	     */	    XCopyArea(instancePtr->display, instancePtr->pixels, newPixmap,		    instancePtr->gc, validBox.x, validBox.y,		    validBox.width, validBox.height, validBox.x, validBox.y);	    Tk_FreePixmap(instancePtr->display, instancePtr->pixels);	}	instancePtr->pixels = newPixmap;    }
(instancePtr->width != masterPtr->width)	    || (instancePtr->height != masterPtr->height)	    || (instancePtr->pixels == None)
(instancePtr->width != masterPtr->width)	    || (instancePtr->height != masterPtr->height)
(instancePtr->width != masterPtr->width)
instancePtr->width != masterPtr->width
instancePtr->width
instancePtr
instancePtr
width
masterPtr->width
masterPtr
masterPtr
width
(instancePtr->height != masterPtr->height)
instancePtr->height != masterPtr->height
instancePtr->height
instancePtr
instancePtr
height
masterPtr->height
masterPtr
masterPtr
height
(instancePtr->pixels == None)
instancePtr->pixels == None
instancePtr->pixels
instancePtr
instancePtr
pixels
None
None
{	newPixmap = Tk_GetPixmap(instancePtr->display,		RootWindow(instancePtr->display,			instancePtr->visualInfo.screen),		(masterPtr->width > 0) ? masterPtr->width: 1,		(masterPtr->height > 0) ? masterPtr->height: 1,		instancePtr->visualInfo.depth);	if (!newPixmap) {	    Tcl_Panic("Fail to create pixmap with Tk_GetPixmap in ImgPhotoInstanceSetSize.\n");	}	/*	 * The following is a gross hack needed to properly support colormaps	 * under Windows. Before the pixels can be copied to the pixmap, the	 * relevent colormap must be associated with the drawable. Normally we	 * can infer this association from the window that was used to create	 * the pixmap. However, in this case we're using the root window, so	 * we have to be more explicit.	 */	TkSetPixmapColormap(newPixmap, instancePtr->colormap);	if (instancePtr->pixels != None) {	    /*	     * Copy any common pixels from the old pixmap and free it.	     */	    XCopyArea(instancePtr->display, instancePtr->pixels, newPixmap,		    instancePtr->gc, validBox.x, validBox.y,		    validBox.width, validBox.height, validBox.x, validBox.y);	    Tk_FreePixmap(instancePtr->display, instancePtr->pixels);	}	instancePtr->pixels = newPixmap;    }
newPixmap = Tk_GetPixmap(instancePtr->display,		RootWindow(instancePtr->display,			instancePtr->visualInfo.screen),		(masterPtr->width > 0) ? masterPtr->width: 1,		(masterPtr->height > 0) ? masterPtr->height: 1,		instancePtr->visualInfo.depth);
newPixmap = Tk_GetPixmap(instancePtr->display,		RootWindow(instancePtr->display,			instancePtr->visualInfo.screen),		(masterPtr->width > 0) ? masterPtr->width: 1,		(masterPtr->height > 0) ? masterPtr->height: 1,		instancePtr->visualInfo.depth)
newPixmap
newPixmap
Tk_GetPixmap(instancePtr->display,		RootWindow(instancePtr->display,			instancePtr->visualInfo.screen),		(masterPtr->width > 0) ? masterPtr->width: 1,		(masterPtr->height > 0) ? masterPtr->height: 1,		instancePtr->visualInfo.depth)
Tk_GetPixmap
Tk_GetPixmap
instancePtr->display
instancePtr
instancePtr
display
RootWindow(instancePtr->display,			instancePtr->visualInfo.screen)
RootWindow
RootWindow
instancePtr->display
instancePtr
instancePtr
display
instancePtr->visualInfo.screen
instancePtr->visualInfo
instancePtr
instancePtr
visualInfo
screen
(masterPtr->width > 0) ? masterPtr->width: 1
(masterPtr->width > 0)
masterPtr->width > 0
masterPtr->width
masterPtr
masterPtr
width
0
masterPtr->width
masterPtr
masterPtr
width
1
(masterPtr->height > 0) ? masterPtr->height: 1
(masterPtr->height > 0)
masterPtr->height > 0
masterPtr->height
masterPtr
masterPtr
height
0
masterPtr->height
masterPtr
masterPtr
height
1
instancePtr->visualInfo.depth
instancePtr->visualInfo
instancePtr
instancePtr
visualInfo
depth
if (!newPixmap) {	    Tcl_Panic("Fail to create pixmap with Tk_GetPixmap in ImgPhotoInstanceSetSize.\n");	}
!newPixmap
newPixmap
newPixmap
{	    Tcl_Panic("Fail to create pixmap with Tk_GetPixmap in ImgPhotoInstanceSetSize.\n");	}
Tcl_Panic("Fail to create pixmap with Tk_GetPixmap in ImgPhotoInstanceSetSize.\n");
Tcl_Panic("Fail to create pixmap with Tk_GetPixmap in ImgPhotoInstanceSetSize.\n")
Tcl_Panic
Tcl_Panic
"Fail to create pixmap with Tk_GetPixmap in ImgPhotoInstanceSetSize.\n"
TkSetPixmapColormap(newPixmap, instancePtr->colormap);
TkSetPixmapColormap(newPixmap, instancePtr->colormap)
TkSetPixmapColormap
TkSetPixmapColormap
newPixmap
newPixmap
instancePtr->colormap
instancePtr
instancePtr
colormap
if (instancePtr->pixels != None) {	    /*	     * Copy any common pixels from the old pixmap and free it.	     */	    XCopyArea(instancePtr->display, instancePtr->pixels, newPixmap,		    instancePtr->gc, validBox.x, validBox.y,		    validBox.width, validBox.height, validBox.x, validBox.y);	    Tk_FreePixmap(instancePtr->display, instancePtr->pixels);	}
instancePtr->pixels != None
instancePtr->pixels
instancePtr
instancePtr
pixels
None
None
{	    /*	     * Copy any common pixels from the old pixmap and free it.	     */	    XCopyArea(instancePtr->display, instancePtr->pixels, newPixmap,		    instancePtr->gc, validBox.x, validBox.y,		    validBox.width, validBox.height, validBox.x, validBox.y);	    Tk_FreePixmap(instancePtr->display, instancePtr->pixels);	}
XCopyArea(instancePtr->display, instancePtr->pixels, newPixmap,		    instancePtr->gc, validBox.x, validBox.y,		    validBox.width, validBox.height, validBox.x, validBox.y);
XCopyArea(instancePtr->display, instancePtr->pixels, newPixmap,		    instancePtr->gc, validBox.x, validBox.y,		    validBox.width, validBox.height, validBox.x, validBox.y)
XCopyArea
XCopyArea
instancePtr->display
instancePtr
instancePtr
display
instancePtr->pixels
instancePtr
instancePtr
pixels
newPixmap
newPixmap
instancePtr->gc
instancePtr
instancePtr
gc
validBox.x
validBox
validBox
x
validBox.y
validBox
validBox
y
validBox.width
validBox
validBox
width
validBox.height
validBox
validBox
height
validBox.x
validBox
validBox
x
validBox.y
validBox
validBox
y
Tk_FreePixmap(instancePtr->display, instancePtr->pixels);
Tk_FreePixmap(instancePtr->display, instancePtr->pixels)
Tk_FreePixmap
Tk_FreePixmap
instancePtr->display
instancePtr
instancePtr
display
instancePtr->pixels
instancePtr
instancePtr
pixels
instancePtr->pixels = newPixmap;
instancePtr->pixels = newPixmap
instancePtr->pixels
instancePtr
instancePtr
pixels
newPixmap
newPixmap
if ((instancePtr->width != masterPtr->width)	    || (instancePtr->height != masterPtr->height)	    || (instancePtr->error == NULL)) {	if (masterPtr->height > 0 && masterPtr->width > 0) {	    newError = (schar *) ckalloc((unsigned)		    masterPtr->height * masterPtr->width * 3 * sizeof(schar));	    /*	     * Zero the new array so that we don't get bogus error values	     * propagating into areas we dither later.	     */	    if ((instancePtr->error != NULL)		    && ((instancePtr->width == masterPtr->width)		    || (validBox.width == masterPtr->width))) {		if (validBox.y > 0) {		    memset(newError, 0, (size_t)			    validBox.y * masterPtr->width * 3 * sizeof(schar));		}		h = validBox.y + validBox.height;		if (h < masterPtr->height) {		    memset(newError + h*masterPtr->width*3, 0,			    (size_t) (masterPtr->height - h)			    * masterPtr->width * 3 * sizeof(schar));		}	    } else {		memset(newError, 0, (size_t)			masterPtr->height * masterPtr->width *3*sizeof(schar));	    }	} else {	    newError = NULL;	}	if (instancePtr->error != NULL) {	    /*	     * Copy the common area over to the new array and free the old	     * array.	     */	    if (masterPtr->width == instancePtr->width) {		offset = validBox.y * masterPtr->width * 3;		memcpy(newError + offset, instancePtr->error + offset,			(size_t) (validBox.height			* masterPtr->width * 3 * sizeof(schar)));	    } else if (validBox.width > 0 && validBox.height > 0) {		errDestPtr = newError +			(validBox.y * masterPtr->width + validBox.x) * 3;		errSrcPtr = instancePtr->error +			(validBox.y * instancePtr->width + validBox.x) * 3;		for (h = validBox.height; h > 0; --h) {		    memcpy(errDestPtr, errSrcPtr,			    validBox.width * 3 * sizeof(schar));		    errDestPtr += masterPtr->width * 3;		    errSrcPtr += instancePtr->width * 3;		}	    }	    ckfree((char *) instancePtr->error);	}	instancePtr->error = newError;    }
(instancePtr->width != masterPtr->width)	    || (instancePtr->height != masterPtr->height)	    || (instancePtr->error == NULL)
(instancePtr->width != masterPtr->width)	    || (instancePtr->height != masterPtr->height)
(instancePtr->width != masterPtr->width)
instancePtr->width != masterPtr->width
instancePtr->width
instancePtr
instancePtr
width
masterPtr->width
masterPtr
masterPtr
width
(instancePtr->height != masterPtr->height)
instancePtr->height != masterPtr->height
instancePtr->height
instancePtr
instancePtr
height
masterPtr->height
masterPtr
masterPtr
height
(instancePtr->error == NULL)
instancePtr->error == NULL
instancePtr->error
instancePtr
instancePtr
error
NULL
NULL
{	if (masterPtr->height > 0 && masterPtr->width > 0) {	    newError = (schar *) ckalloc((unsigned)		    masterPtr->height * masterPtr->width * 3 * sizeof(schar));	    /*	     * Zero the new array so that we don't get bogus error values	     * propagating into areas we dither later.	     */	    if ((instancePtr->error != NULL)		    && ((instancePtr->width == masterPtr->width)		    || (validBox.width == masterPtr->width))) {		if (validBox.y > 0) {		    memset(newError, 0, (size_t)			    validBox.y * masterPtr->width * 3 * sizeof(schar));		}		h = validBox.y + validBox.height;		if (h < masterPtr->height) {		    memset(newError + h*masterPtr->width*3, 0,			    (size_t) (masterPtr->height - h)			    * masterPtr->width * 3 * sizeof(schar));		}	    } else {		memset(newError, 0, (size_t)			masterPtr->height * masterPtr->width *3*sizeof(schar));	    }	} else {	    newError = NULL;	}	if (instancePtr->error != NULL) {	    /*	     * Copy the common area over to the new array and free the old	     * array.	     */	    if (masterPtr->width == instancePtr->width) {		offset = validBox.y * masterPtr->width * 3;		memcpy(newError + offset, instancePtr->error + offset,			(size_t) (validBox.height			* masterPtr->width * 3 * sizeof(schar)));	    } else if (validBox.width > 0 && validBox.height > 0) {		errDestPtr = newError +			(validBox.y * masterPtr->width + validBox.x) * 3;		errSrcPtr = instancePtr->error +			(validBox.y * instancePtr->width + validBox.x) * 3;		for (h = validBox.height; h > 0; --h) {		    memcpy(errDestPtr, errSrcPtr,			    validBox.width * 3 * sizeof(schar));		    errDestPtr += masterPtr->width * 3;		    errSrcPtr += instancePtr->width * 3;		}	    }	    ckfree((char *) instancePtr->error);	}	instancePtr->error = newError;    }
if (masterPtr->height > 0 && masterPtr->width > 0) {	    newError = (schar *) ckalloc((unsigned)		    masterPtr->height * masterPtr->width * 3 * sizeof(schar));	    /*	     * Zero the new array so that we don't get bogus error values	     * propagating into areas we dither later.	     */	    if ((instancePtr->error != NULL)		    && ((instancePtr->width == masterPtr->width)		    || (validBox.width == masterPtr->width))) {		if (validBox.y > 0) {		    memset(newError, 0, (size_t)			    validBox.y * masterPtr->width * 3 * sizeof(schar));		}		h = validBox.y + validBox.height;		if (h < masterPtr->height) {		    memset(newError + h*masterPtr->width*3, 0,			    (size_t) (masterPtr->height - h)			    * masterPtr->width * 3 * sizeof(schar));		}	    } else {		memset(newError, 0, (size_t)			masterPtr->height * masterPtr->width *3*sizeof(schar));	    }	} else {	    newError = NULL;	}
masterPtr->height > 0 && masterPtr->width > 0
masterPtr->height > 0
masterPtr->height
masterPtr
masterPtr
height
0
masterPtr->width > 0
masterPtr->width
masterPtr
masterPtr
width
0
{	    newError = (schar *) ckalloc((unsigned)		    masterPtr->height * masterPtr->width * 3 * sizeof(schar));	    /*	     * Zero the new array so that we don't get bogus error values	     * propagating into areas we dither later.	     */	    if ((instancePtr->error != NULL)		    && ((instancePtr->width == masterPtr->width)		    || (validBox.width == masterPtr->width))) {		if (validBox.y > 0) {		    memset(newError, 0, (size_t)			    validBox.y * masterPtr->width * 3 * sizeof(schar));		}		h = validBox.y + validBox.height;		if (h < masterPtr->height) {		    memset(newError + h*masterPtr->width*3, 0,			    (size_t) (masterPtr->height - h)			    * masterPtr->width * 3 * sizeof(schar));		}	    } else {		memset(newError, 0, (size_t)			masterPtr->height * masterPtr->width *3*sizeof(schar));	    }	}
newError = (schar *) ckalloc((unsigned)		    masterPtr->height * masterPtr->width * 3 * sizeof(schar));
newError = (schar *) ckalloc((unsigned)		    masterPtr->height * masterPtr->width * 3 * sizeof(schar))
newError
newError
(schar *) ckalloc((unsigned)		    masterPtr->height * masterPtr->width * 3 * sizeof(schar))
schar *
schar
schar
*
*
ckalloc((unsigned)		    masterPtr->height * masterPtr->width * 3 * sizeof(schar))
ckalloc
ckalloc
(unsigned)		    masterPtr->height * masterPtr->width * 3 * sizeof(schar)
(unsigned)		    masterPtr->height * masterPtr->width * 3
(unsigned)		    masterPtr->height * masterPtr->width
(unsigned)		    masterPtr->height
unsigned
unsigned

masterPtr->height
masterPtr
masterPtr
height
masterPtr->width
masterPtr
masterPtr
width
3
sizeof(schar)
schar
schar
schar

if ((instancePtr->error != NULL)		    && ((instancePtr->width == masterPtr->width)		    || (validBox.width == masterPtr->width))) {		if (validBox.y > 0) {		    memset(newError, 0, (size_t)			    validBox.y * masterPtr->width * 3 * sizeof(schar));		}		h = validBox.y + validBox.height;		if (h < masterPtr->height) {		    memset(newError + h*masterPtr->width*3, 0,			    (size_t) (masterPtr->height - h)			    * masterPtr->width * 3 * sizeof(schar));		}	    } else {		memset(newError, 0, (size_t)			masterPtr->height * masterPtr->width *3*sizeof(schar));	    }
(instancePtr->error != NULL)		    && ((instancePtr->width == masterPtr->width)		    || (validBox.width == masterPtr->width))
(instancePtr->error != NULL)
instancePtr->error != NULL
instancePtr->error
instancePtr
instancePtr
error
NULL
NULL
((instancePtr->width == masterPtr->width)		    || (validBox.width == masterPtr->width))
(instancePtr->width == masterPtr->width)		    || (validBox.width == masterPtr->width)
(instancePtr->width == masterPtr->width)
instancePtr->width == masterPtr->width
instancePtr->width
instancePtr
instancePtr
width
masterPtr->width
masterPtr
masterPtr
width
(validBox.width == masterPtr->width)
validBox.width == masterPtr->width
validBox.width
validBox
validBox
width
masterPtr->width
masterPtr
masterPtr
width
{		if (validBox.y > 0) {		    memset(newError, 0, (size_t)			    validBox.y * masterPtr->width * 3 * sizeof(schar));		}		h = validBox.y + validBox.height;		if (h < masterPtr->height) {		    memset(newError + h*masterPtr->width*3, 0,			    (size_t) (masterPtr->height - h)			    * masterPtr->width * 3 * sizeof(schar));		}	    }
if (validBox.y > 0) {		    memset(newError, 0, (size_t)			    validBox.y * masterPtr->width * 3 * sizeof(schar));		}
validBox.y > 0
validBox.y
validBox
validBox
y
0
{		    memset(newError, 0, (size_t)			    validBox.y * masterPtr->width * 3 * sizeof(schar));		}
memset(newError, 0, (size_t)			    validBox.y * masterPtr->width * 3 * sizeof(schar));
memset(newError, 0, (size_t)			    validBox.y * masterPtr->width * 3 * sizeof(schar))
memset
memset
newError
newError
0
(size_t)			    validBox.y * masterPtr->width * 3 * sizeof(schar)
(size_t)			    validBox.y * masterPtr->width * 3
(size_t)			    validBox.y * masterPtr->width
(size_t)			    validBox.y
size_t
size_t
size_t

validBox.y
validBox
validBox
y
masterPtr->width
masterPtr
masterPtr
width
3
sizeof(schar)
schar
schar
schar

h = validBox.y + validBox.height;
h = validBox.y + validBox.height
h
h
validBox.y + validBox.height
validBox.y
validBox
validBox
y
validBox.height
validBox
validBox
height
if (h < masterPtr->height) {		    memset(newError + h*masterPtr->width*3, 0,			    (size_t) (masterPtr->height - h)			    * masterPtr->width * 3 * sizeof(schar));		}
h < masterPtr->height
h
h
masterPtr->height
masterPtr
masterPtr
height
{		    memset(newError + h*masterPtr->width*3, 0,			    (size_t) (masterPtr->height - h)			    * masterPtr->width * 3 * sizeof(schar));		}
memset(newError + h*masterPtr->width*3, 0,			    (size_t) (masterPtr->height - h)			    * masterPtr->width * 3 * sizeof(schar));
memset(newError + h*masterPtr->width*3, 0,			    (size_t) (masterPtr->height - h)			    * masterPtr->width * 3 * sizeof(schar))
memset
memset
newError + h*masterPtr->width*3
newError
newError
h*masterPtr->width*3
h*masterPtr->width
h
h
masterPtr->width
masterPtr
masterPtr
width
3
0
(size_t) (masterPtr->height - h)			    * masterPtr->width * 3 * sizeof(schar)
(size_t) (masterPtr->height - h)			    * masterPtr->width * 3
(size_t) (masterPtr->height - h)			    * masterPtr->width
(size_t) (masterPtr->height - h)
(size_t)
size_t
size_t
masterPtr->height - h
masterPtr->height
masterPtr
masterPtr
height
h
h
masterPtr->width
masterPtr
masterPtr
width
3
sizeof(schar)
schar
schar
schar

{		memset(newError, 0, (size_t)			masterPtr->height * masterPtr->width *3*sizeof(schar));	    }
memset(newError, 0, (size_t)			masterPtr->height * masterPtr->width *3*sizeof(schar));
memset(newError, 0, (size_t)			masterPtr->height * masterPtr->width *3*sizeof(schar))
memset
memset
newError
newError
0
(size_t)			masterPtr->height * masterPtr->width *3*sizeof(schar)
(size_t)			masterPtr->height * masterPtr->width *3
(size_t)			masterPtr->height * masterPtr->width
(size_t)			masterPtr->height
size_t
size_t
size_t

masterPtr->height
masterPtr
masterPtr
height
masterPtr->width
masterPtr
masterPtr
width
3
sizeof(schar)
schar
schar
schar

{	    newError = NULL;	}
newError = NULL;
newError = NULL
newError
newError
NULL
NULL
if (instancePtr->error != NULL) {	    /*	     * Copy the common area over to the new array and free the old	     * array.	     */	    if (masterPtr->width == instancePtr->width) {		offset = validBox.y * masterPtr->width * 3;		memcpy(newError + offset, instancePtr->error + offset,			(size_t) (validBox.height			* masterPtr->width * 3 * sizeof(schar)));	    } else if (validBox.width > 0 && validBox.height > 0) {		errDestPtr = newError +			(validBox.y * masterPtr->width + validBox.x) * 3;		errSrcPtr = instancePtr->error +			(validBox.y * instancePtr->width + validBox.x) * 3;		for (h = validBox.height; h > 0; --h) {		    memcpy(errDestPtr, errSrcPtr,			    validBox.width * 3 * sizeof(schar));		    errDestPtr += masterPtr->width * 3;		    errSrcPtr += instancePtr->width * 3;		}	    }	    ckfree((char *) instancePtr->error);	}
instancePtr->error != NULL
instancePtr->error
instancePtr
instancePtr
error
NULL
NULL
{	    /*	     * Copy the common area over to the new array and free the old	     * array.	     */	    if (masterPtr->width == instancePtr->width) {		offset = validBox.y * masterPtr->width * 3;		memcpy(newError + offset, instancePtr->error + offset,			(size_t) (validBox.height			* masterPtr->width * 3 * sizeof(schar)));	    } else if (validBox.width > 0 && validBox.height > 0) {		errDestPtr = newError +			(validBox.y * masterPtr->width + validBox.x) * 3;		errSrcPtr = instancePtr->error +			(validBox.y * instancePtr->width + validBox.x) * 3;		for (h = validBox.height; h > 0; --h) {		    memcpy(errDestPtr, errSrcPtr,			    validBox.width * 3 * sizeof(schar));		    errDestPtr += masterPtr->width * 3;		    errSrcPtr += instancePtr->width * 3;		}	    }	    ckfree((char *) instancePtr->error);	}
if (masterPtr->width == instancePtr->width) {		offset = validBox.y * masterPtr->width * 3;		memcpy(newError + offset, instancePtr->error + offset,			(size_t) (validBox.height			* masterPtr->width * 3 * sizeof(schar)));	    } else if (validBox.width > 0 && validBox.height > 0) {		errDestPtr = newError +			(validBox.y * masterPtr->width + validBox.x) * 3;		errSrcPtr = instancePtr->error +			(validBox.y * instancePtr->width + validBox.x) * 3;		for (h = validBox.height; h > 0; --h) {		    memcpy(errDestPtr, errSrcPtr,			    validBox.width * 3 * sizeof(schar));		    errDestPtr += masterPtr->width * 3;		    errSrcPtr += instancePtr->width * 3;		}	    }
masterPtr->width == instancePtr->width
masterPtr->width
masterPtr
masterPtr
width
instancePtr->width
instancePtr
instancePtr
width
{		offset = validBox.y * masterPtr->width * 3;		memcpy(newError + offset, instancePtr->error + offset,			(size_t) (validBox.height			* masterPtr->width * 3 * sizeof(schar)));	    }
offset = validBox.y * masterPtr->width * 3;
offset = validBox.y * masterPtr->width * 3
offset
offset
validBox.y * masterPtr->width * 3
validBox.y * masterPtr->width
validBox.y
validBox
validBox
y
masterPtr->width
masterPtr
masterPtr
width
3
memcpy(newError + offset, instancePtr->error + offset,			(size_t) (validBox.height			* masterPtr->width * 3 * sizeof(schar)));
memcpy(newError + offset, instancePtr->error + offset,			(size_t) (validBox.height			* masterPtr->width * 3 * sizeof(schar)))
memcpy
memcpy
newError + offset
newError
newError
offset
offset
instancePtr->error + offset
instancePtr->error
instancePtr
instancePtr
error
offset
offset
(size_t) (validBox.height			* masterPtr->width * 3 * sizeof(schar))
(size_t)
size_t
size_t
validBox.height			* masterPtr->width * 3 * sizeof(schar)
validBox.height			* masterPtr->width * 3
validBox.height			* masterPtr->width
validBox.height
validBox
validBox
height
masterPtr->width
masterPtr
masterPtr
width
3
sizeof(schar)
schar
schar
schar

if (validBox.width > 0 && validBox.height > 0) {		errDestPtr = newError +			(validBox.y * masterPtr->width + validBox.x) * 3;		errSrcPtr = instancePtr->error +			(validBox.y * instancePtr->width + validBox.x) * 3;		for (h = validBox.height; h > 0; --h) {		    memcpy(errDestPtr, errSrcPtr,			    validBox.width * 3 * sizeof(schar));		    errDestPtr += masterPtr->width * 3;		    errSrcPtr += instancePtr->width * 3;		}	    }
validBox.width > 0 && validBox.height > 0
validBox.width > 0
validBox.width
validBox
validBox
width
0
validBox.height > 0
validBox.height
validBox
validBox
height
0
{		errDestPtr = newError +			(validBox.y * masterPtr->width + validBox.x) * 3;		errSrcPtr = instancePtr->error +			(validBox.y * instancePtr->width + validBox.x) * 3;		for (h = validBox.height; h > 0; --h) {		    memcpy(errDestPtr, errSrcPtr,			    validBox.width * 3 * sizeof(schar));		    errDestPtr += masterPtr->width * 3;		    errSrcPtr += instancePtr->width * 3;		}	    }
errDestPtr = newError +			(validBox.y * masterPtr->width + validBox.x) * 3;
errDestPtr = newError +			(validBox.y * masterPtr->width + validBox.x) * 3
errDestPtr
errDestPtr
newError +			(validBox.y * masterPtr->width + validBox.x) * 3
newError
newError
(validBox.y * masterPtr->width + validBox.x) * 3
(validBox.y * masterPtr->width + validBox.x)
validBox.y * masterPtr->width + validBox.x
validBox.y * masterPtr->width
validBox.y
validBox
validBox
y
masterPtr->width
masterPtr
masterPtr
width
validBox.x
validBox
validBox
x
3
errSrcPtr = instancePtr->error +			(validBox.y * instancePtr->width + validBox.x) * 3;
errSrcPtr = instancePtr->error +			(validBox.y * instancePtr->width + validBox.x) * 3
errSrcPtr
errSrcPtr
instancePtr->error +			(validBox.y * instancePtr->width + validBox.x) * 3
instancePtr->error
instancePtr
instancePtr
error
(validBox.y * instancePtr->width + validBox.x) * 3
(validBox.y * instancePtr->width + validBox.x)
validBox.y * instancePtr->width + validBox.x
validBox.y * instancePtr->width
validBox.y
validBox
validBox
y
instancePtr->width
instancePtr
instancePtr
width
validBox.x
validBox
validBox
x
3
for (h = validBox.height; h > 0; --h) {		    memcpy(errDestPtr, errSrcPtr,			    validBox.width * 3 * sizeof(schar));		    errDestPtr += masterPtr->width * 3;		    errSrcPtr += instancePtr->width * 3;		}
h = validBox.height;
h = validBox.height
h
h
validBox.height
validBox
validBox
height
h > 0
h
h
0
--h
h
h
{		    memcpy(errDestPtr, errSrcPtr,			    validBox.width * 3 * sizeof(schar));		    errDestPtr += masterPtr->width * 3;		    errSrcPtr += instancePtr->width * 3;		}
memcpy(errDestPtr, errSrcPtr,			    validBox.width * 3 * sizeof(schar));
memcpy(errDestPtr, errSrcPtr,			    validBox.width * 3 * sizeof(schar))
memcpy
memcpy
errDestPtr
errDestPtr
errSrcPtr
errSrcPtr
validBox.width * 3 * sizeof(schar)
validBox.width * 3
validBox.width
validBox
validBox
width
3
sizeof(schar)
schar
schar
schar

errDestPtr += masterPtr->width * 3;
errDestPtr += masterPtr->width * 3
errDestPtr
errDestPtr
masterPtr->width * 3
masterPtr->width
masterPtr
masterPtr
width
3
errSrcPtr += instancePtr->width * 3;
errSrcPtr += instancePtr->width * 3
errSrcPtr
errSrcPtr
instancePtr->width * 3
instancePtr->width
instancePtr
instancePtr
width
3
ckfree((char *) instancePtr->error);
ckfree((char *) instancePtr->error)
ckfree
ckfree
(char *) instancePtr->error
char *
char
*
*
instancePtr->error
instancePtr
instancePtr
error
instancePtr->error = newError;
instancePtr->error = newError
instancePtr->error
instancePtr
instancePtr
error
newError
newError
instancePtr->width = masterPtr->width;
instancePtr->width = masterPtr->width
instancePtr->width
instancePtr
instancePtr
width
masterPtr->width
masterPtr
masterPtr
width
instancePtr->height = masterPtr->height;
instancePtr->height = masterPtr->height
instancePtr->height
instancePtr
instancePtr
height
masterPtr->height
masterPtr
masterPtr
height
-----joern-----
(342,217,0)
(437,370,0)
(202,88,0)
(117,48,0)
(154,349,0)
(458,150,0)
(376,243,0)
(138,82,0)
(311,96,0)
(79,310,0)
(203,418,0)
(457,60,0)
(38,221,0)
(351,337,0)
(102,86,0)
(459,17,0)
(115,221,0)
(91,402,0)
(414,83,0)
(284,53,0)
(118,468,0)
(306,334,0)
(291,111,0)
(463,372,0)
(80,123,0)
(10,301,0)
(460,147,0)
(269,353,0)
(32,340,0)
(113,221,0)
(252,40,0)
(415,373,0)
(447,221,0)
(468,118,0)
(371,246,0)
(425,201,0)
(32,215,0)
(168,236,0)
(431,372,0)
(376,50,0)
(141,50,0)
(220,217,0)
(317,204,0)
(53,88,0)
(315,104,0)
(296,4,0)
(189,84,0)
(153,336,0)
(411,236,0)
(372,348,0)
(305,152,0)
(18,221,0)
(205,111,0)
(396,469,0)
(355,292,0)
(193,267,0)
(337,17,0)
(51,334,0)
(32,315,0)
(416,157,0)
(313,221,0)
(246,176,0)
(114,437,0)
(240,64,0)
(248,44,0)
(150,372,0)
(465,119,0)
(389,63,0)
(271,213,0)
(166,308,0)
(105,346,0)
(439,460,0)
(264,156,0)
(467,90,0)
(265,162,0)
(445,153,0)
(81,92,0)
(257,349,0)
(109,227,0)
(72,73,0)
(147,349,0)
(237,107,0)
(110,221,0)
(325,225,0)
(78,319,0)
(96,311,0)
(314,65,0)
(212,448,0)
(128,398,0)
(307,48,0)
(317,141,0)
(111,0,0)
(170,147,0)
(3,327,0)
(210,107,0)
(77,32,0)
(297,350,0)
(133,215,0)
(372,257,0)
(141,32,0)
(134,249,0)
(9,85,0)
(116,221,0)
(4,107,0)
(350,284,0)
(296,53,0)
(208,160,0)
(9,349,0)
(329,221,0)
(317,317,0)
(152,404,0)
(63,145,0)
(221,217,0)
(309,250,0)
(155,376,0)
(149,457,0)
(262,221,0)
(466,18,0)
(34,118,0)
(227,349,0)
(126,402,0)
(379,449,0)
(280,346,0)
(258,436,0)
(284,88,0)
(176,211,0)
(470,167,0)
(72,349,0)
(41,227,0)
(196,29,0)
(133,283,0)
(17,459,0)
(356,324,0)
(229,286,0)
(361,349,0)
(404,301,0)
(146,463,0)
(409,9,0)
(129,342,0)
(4,296,0)
(289,221,0)
(131,121,0)
(261,323,0)
(354,384,0)
(286,229,0)
(215,24,0)
(143,366,0)
(276,81,0)
(61,229,0)
(362,388,0)
(62,250,0)
(0,169,0)
(200,258,0)
(206,417,0)
(303,372,0)
(325,179,0)
(424,372,0)
(299,310,0)
(87,110,0)
(439,441,0)
(366,205,0)
(121,221,0)
(1,283,0)
(290,257,0)
(435,172,0)
(377,18,0)
(6,359,0)
(464,446,0)
(216,193,0)
(222,75,0)
(369,388,0)
(100,31,0)
(104,336,0)
(243,376,0)
(345,4,0)
(160,467,0)
(142,225,0)
(242,417,0)
(119,221,0)
(427,88,0)
(459,296,0)
(125,221,0)
(345,162,0)
(127,161,0)
(443,304,0)
(365,133,0)
(187,457,0)
(57,447,0)
(151,420,0)
(288,141,0)
(465,467,0)
(123,29,0)
(166,329,0)
(128,110,0)
(79,83,0)
(391,304,0)
(426,313,0)
(226,33,0)
(454,81,0)
(282,116,0)
(184,17,0)
(0,111,0)
(336,104,0)
(453,217,0)
(397,398,0)
(378,110,0)
(115,311,0)
(292,355,0)
(375,440,0)
(437,221,0)
(30,270,0)
(236,215,0)
(186,395,0)
(118,221,0)
(421,221,0)
(193,349,0)
(413,145,0)
(166,64,0)
(399,350,0)
(381,63,0)
(219,396,0)
(279,50,0)
(323,65,0)
(270,53,0)
(235,40,0)
(363,306,0)
(47,400,0)
(211,176,0)
(319,215,0)
(436,361,0)
(36,261,0)
(90,67,0)
(324,221,0)
(228,465,0)
(364,95,0)
(262,204,0)
(301,221,0)
(5,82,0)
(22,245,0)
(443,313,0)
(292,349,0)
(13,420,0)
(2,115,0)
(251,9,0)
(12,371,0)
(11,125,0)
(347,221,0)
(201,462,0)
(404,353,0)
(372,431,0)
(442,39,0)
(334,306,0)
(130,371,0)
(213,349,0)
(231,217,0)
(94,33,0)
(75,270,0)
(181,115,0)
(305,56,0)
(339,85,0)
(169,0,0)
(335,289,0)
(333,245,0)
(249,56,0)
(348,372,0)
(281,24,0)
(422,345,0)
(451,418,0)
(348,349,0)
(283,133,0)
(419,441,0)
(360,100,0)
(45,94,0)
(392,118,0)
(164,329,0)
(111,291,0)
(111,205,0)
(155,92,0)
(401,217,0)
(267,154,0)
(255,286,0)
(139,113,0)
(190,73,0)
(195,304,0)
(14,340,0)
(353,349,0)
(56,420,0)
(234,307,0)
(321,431,0)
(259,65,0)
(344,199,0)
(428,373,0)
(147,460,0)
(440,349,0)
(257,372,0)
(260,416,0)
(436,296,0)
(215,169,0)
(31,31,0)
(332,116,0)
(417,372,0)
(448,221,0)
(19,200,0)
(452,175,0)
(76,119,0)
(260,283,0)
(254,44,0)
(433,424,0)
(272,324,0)
(308,166,0)
(188,400,0)
(101,215,0)
(28,258,0)
(155,158,0)
(407,319,0)
(372,150,0)
(308,355,0)
(306,90,0)
(152,305,0)
(26,376,0)
(359,256,0)
(27,45,0)
(308,462,0)
(241,72,0)
(302,129,0)
(423,199,0)
(386,249,0)
(444,123,0)
(238,51,0)
(355,308,0)
(395,45,0)
(277,96,0)
(48,307,0)
(44,306,0)
(167,221,0)
(138,312,0)
(398,349,0)
(368,100,0)
(120,133,0)
(119,465,0)
(56,249,0)
(61,121,0)
(350,349,0)
(243,414,0)
(294,276,0)
(233,150,0)
(155,31,0)
(287,72,0)
(180,346,0)
(342,289,0)
(205,366,0)
(304,195,0)
(403,406,0)
(327,448,0)
(329,166,0)
(260,444,0)
(198,253,0)
(444,40,0)
(93,347,0)
(55,60,0)
(180,411,0)
(404,152,0)
(136,198,0)
(200,349,0)
(416,260,0)
(90,467,0)
(60,305,0)
(370,437,0)
(450,22,0)
(78,468,0)
(162,221,0)
(116,349,0)
(71,61,0)
(469,325,0)
(148,256,0)
(177,195,0)
(107,4,0)
(176,334,0)
(336,153,0)
(305,60,0)
(175,53,0)
(337,221,0)
(75,349,0)
(390,169,0)
(172,449,0)
(40,444,0)
(53,296,0)
(167,291,0)
(84,18,0)
(468,78,0)
(267,223,0)
(51,340,0)
(246,253,0)
(68,460,0)
(268,147,0)
(95,83,0)
(385,204,0)
(313,443,0)
(162,345,0)
(20,38,0)
(17,337,0)
(225,325,0)
(295,284,0)
(85,9,0)
(69,262,0)
(73,72,0)
(372,53,0)
(267,193,0)
(97,120,0)
(372,418,0)
(125,469,0)
(319,247,0)
(256,359,0)
(316,348,0)
(434,369,0)
(31,100,0)
(384,86,0)
(429,198,0)
(99,217,0)
(81,276,0)
(395,221,0)
(304,443,0)
(334,51,0)
(245,215,0)
(344,217,0)
(328,337,0)
(459,38,0)
(31,158,0)
(301,404,0)
(245,340,0)
(229,61,0)
(463,349,0)
(353,404,0)
(103,117,0)
(343,430,0)
(89,156,0)
(286,324,0)
(263,340,0)
(393,447,0)
(449,172,0)
(236,192,0)
(460,439,0)
(461,75,0)
(414,243,0)
(197,217,0)
(94,48,0)
(408,291,0)
(266,349,0)
(174,429,0)
(298,329,0)
(396,349,0)
(327,120,0)
(469,125,0)
(59,315,0)
(145,63,0)
(70,119,0)
(443,78,0)
(83,95,0)
(96,349,0)
(366,221,0)
(171,95,0)
(92,406,0)
(45,395,0)
(340,380,0)
(16,292,0)
(387,31,0)
(183,121,0)
(129,349,0)
(29,123,0)
(137,361,0)
(283,260,0)
(37,396,0)
(398,128,0)
(8,437,0)
(132,154,0)
(218,217,0)
(201,440,0)
(306,44,0)
(456,161,0)
(128,179,0)
(311,115,0)
(155,141,0)
(270,88,0)
(324,286,0)
(331,257,0)
(357,262,0)
(25,361,0)
(346,180,0)
(207,160,0)
(250,344,0)
(39,323,0)
(227,446,0)
(468,15,0)
(372,223,0)
(438,167,0)
(179,128,0)
(205,172,0)
(250,221,0)
(52,33,0)
(185,406,0)
(360,349,0)
(448,327,0)
(180,388,0)
(338,113,0)
(312,138,0)
(388,369,0)
(225,430,0)
(320,38,0)
(317,158,0)
(457,349,0)
(48,94,0)
(194,307,0)
(156,349,0)
(275,348,0)
(15,468,0)
(346,221,0)
(405,256,0)
(38,459,0)
(300,94,0)
(319,78,0)
(406,92,0)
(412,398,0)
(221,116,0)
(430,349,0)
(278,414,0)
(372,161,0)
(283,23,0)
(296,85,0)
(133,120,0)
(123,444,0)
(44,349,0)
(74,236,0)
(104,402,0)
(430,225,0)
(383,310,0)
(31,376,0)
(310,79,0)
(274,366,0)
(110,128,0)
(4,345,0)
(388,180,0)
(173,313,0)
(178,359,0)
(54,22,0)
(46,266,0)
(296,436,0)
(293,360,0)
(418,372,0)
(341,323,0)
(224,213,0)
(253,246,0)
(273,395,0)
(66,193,0)
(334,176,0)
(182,39,0)
(420,56,0)
(214,96,0)
(455,289,0)
(40,221,0)
(157,416,0)
(82,138,0)
(144,153,0)
(83,79,0)
(100,360,0)
(296,373,0)
(374,301,0)
(244,162,0)
(330,125,0)
(156,370,0)
(43,292,0)
(155,317,0)
(204,317,0)
(253,347,0)
(232,53,0)
(402,104,0)
(60,457,0)
(35,117,0)
(135,4,0)
(51,215,0)
(113,355,0)
(420,221,0)
(78,443,0)
(7,424,0)
(65,323,0)
(243,266,0)
(436,258,0)
(120,94,0)
(169,390,0)
(467,465,0)
(359,6,0)
(48,117,0)
(84,94,0)
(289,342,0)
(106,217,0)
(176,246,0)
(49,51,0)
(58,353,0)
(198,429,0)
(18,84,0)
(373,296,0)
(161,372,0)
(372,463,0)
(165,319,0)
(112,200,0)
(355,113,0)
(361,436,0)
(51,90,0)
(209,440,0)
(326,82,0)
(121,61,0)
(172,205,0)
(22,349,0)
(159,108,0)
(432,431,0)
(124,430,0)
(45,416,0)
(382,347,0)
(334,67,0)
(32,141,0)
(440,201,0)
(352,159,0)
(86,384,0)
(239,64,0)
(410,266,0)
(163,129,0)
(416,45,0)
(367,217,0)
(370,217,0)
(291,408,0)
(344,250,0)
(411,180,0)
(462,308,0)
(230,463,0)
(249,349,0)
(284,350,0)
(120,327,0)
(236,411,0)
(21,448,0)
(467,160,0)
(315,32,0)
(107,221,0)
(140,90,0)
(444,260,0)
(462,201,0)
(199,344,0)
(246,371,0)
(322,317,0)
(411,138,0)
(98,459,0)
(191,154,0)
(384,6,0)
(92,81,0)
(291,167,0)
(245,400,0)
(258,200,0)
(296,459,0)
(372,417,0)
(372,424,0)
(446,227,0)
(154,267,0)
(469,396,0)
(394,155,0)
(253,198,0)
(56,305,0)
(169,215,0)
(213,79,0)
(6,384,0)
(373,349,0)
(92,155,0)
(122,155,0)
(42,360,0)
(318,217,0)
(336,447,0)
(179,325,0)
(285,86,0)
(325,469,0)
(64,166,0)
(460,68,0)
(85,296,0)
(79,213,0)
(347,253,0)
(138,411,0)
(104,315,0)
(266,243,0)
(83,414,0)
(204,262,0)
(447,336,0)
(267,154,1)
(300,145,1)
(322,155,1)
(85,339,1)
(228,119,1)
(213,224,1)
(235,416,1)
(430,349,1)
(373,428,1)
(234,117,1)
(404,301,1)
(135,345,1)
(100,360,1)
(101,229,1)
(415,232,1)
(141,32,1)
(156,264,1)
(368,360,1)
(388,369,1)
(242,206,1)
(321,150,1)
(128,398,1)
(81,276,1)
(457,149,1)
(291,167,1)
(9,349,1)
(268,334,1)
(136,347,1)
(296,85,1)
(76,70,1)
(459,38,1)
(84,18,1)
(376,243,1)
(191,132,1)
(179,325,1)
(317,204,1)
(303,463,1)
(138,82,1)
(351,436,1)
(195,177,1)
(429,174,1)
(446,464,1)
(422,162,1)
(104,336,1)
(83,79,1)
(40,221,1)
(199,423,1)
(342,289,1)
(260,416,1)
(12,130,1)
(55,457,1)
(246,253,1)
(463,349,1)
(343,124,1)
(39,323,1)
(144,77,1)
(466,189,1)
(245,340,1)
(65,259,1)
(162,221,1)
(184,337,1)
(176,246,1)
(258,200,1)
(277,214,1)
(79,310,1)
(115,181,1)
(179,128,1)
(11,330,1)
(261,323,1)
(120,327,1)
(38,221,1)
(271,310,1)
(193,349,1)
(305,60,1)
(162,265,1)
(353,269,1)
(460,68,1)
(35,300,1)
(111,205,1)
(40,252,1)
(152,305,1)
(105,280,1)
(469,125,1)
(359,256,1)
(325,225,1)
(262,221,1)
(134,404,1)
(287,241,1)
(340,263,1)
(72,287,1)
(468,15,1)
(306,363,1)
(26,141,1)
(250,221,1)
(317,317,1)
(143,274,1)
(163,370,1)
(31,100,1)
(139,292,1)
(129,302,1)
(333,22,1)
(51,238,1)
(72,349,1)
(304,195,1)
(253,347,1)
(243,414,1)
(288,6,1)
(92,406,1)
(113,338,1)
(465,119,1)
(151,249,1)
(132,372,1)
(344,199,1)
(147,349,1)
(372,348,1)
(110,221,1)
(243,266,1)
(393,57,1)
(4,135,1)
(121,131,1)
(20,320,1)
(193,66,1)
(78,443,1)
(334,51,1)
(37,219,1)
(327,448,1)
(93,382,1)
(275,446,1)
(147,170,1)
(392,165,1)
(171,79,1)
(467,465,1)
(437,8,1)
(60,457,1)
(296,436,1)
(407,462,1)
(194,234,1)
(17,337,1)
(86,102,1)
(450,73,1)
(34,392,1)
(172,449,1)
(74,168,1)
(200,349,1)
(38,20,1)
(21,97,1)
(261,36,1)
(383,299,1)
(6,359,1)
(432,321,1)
(71,121,1)
(84,94,1)
(205,172,1)
(17,184,1)
(347,93,1)
(462,308,1)
(283,133,1)
(306,44,1)
(363,44,1)
(240,239,1)
(438,101,1)
(215,169,1)
(335,455,1)
(1,133,1)
(317,141,1)
(365,84,1)
(313,426,1)
(4,345,1)
(315,59,1)
(14,229,1)
(169,0,1)
(426,173,1)
(372,150,1)
(27,395,1)
(18,221,1)
(395,186,1)
(22,349,1)
(274,291,1)
(295,159,1)
(61,121,1)
(442,323,1)
(416,157,1)
(276,294,1)
(56,249,1)
(306,90,1)
(454,406,1)
(456,127,1)
(366,143,1)
(359,178,1)
(180,346,1)
(152,404,1)
(398,349,1)
(153,445,1)
(373,349,1)
(455,129,1)
(297,295,1)
(166,64,1)
(91,336,1)
(356,272,1)
(355,113,1)
(232,152,1)
(372,257,1)
(190,72,1)
(75,349,1)
(212,21,1)
(121,221,1)
(374,10,1)
(316,275,1)
(397,270,1)
(372,431,1)
(107,221,1)
(110,87,1)
(102,285,1)
(284,350,1)
(187,56,1)
(352,175,1)
(372,161,1)
(337,221,1)
(434,362,1)
(142,430,1)
(443,313,1)
(159,352,1)
(140,311,1)
(207,140,1)
(48,117,1)
(372,463,1)
(258,28,1)
(216,154,1)
(104,402,1)
(49,90,1)
(63,381,1)
(10,353,1)
(219,128,1)
(270,53,1)
(254,248,1)
(236,215,1)
(424,7,1)
(377,466,1)
(336,153,1)
(2,73,1)
(282,332,1)
(447,393,1)
(358,342,1)
(357,69,1)
(227,349,1)
(201,425,1)
(210,345,1)
(344,250,1)
(78,468,1)
(440,349,1)
(138,312,1)
(107,237,1)
(259,314,1)
(414,278,1)
(164,64,1)
(325,469,1)
(331,303,1)
(30,75,1)
(382,371,1)
(273,1,1)
(241,283,1)
(43,16,1)
(372,417,1)
(229,61,1)
(353,349,1)
(113,221,1)
(250,309,1)
(112,19,1)
(442,261,1)
(300,236,1)
(53,296,1)
(51,215,1)
(256,148,1)
(315,104,1)
(98,17,1)
(36,31,1)
(245,333,1)
(116,349,1)
(246,371,1)
(444,40,1)
(414,83,1)
(48,307,1)
(290,331,1)
(125,221,1)
(286,255,1)
(225,430,1)
(51,340,1)
(319,215,1)
(18,377,1)
(308,166,1)
(66,216,1)
(170,268,1)
(3,448,1)
(278,83,1)
(178,256,1)
(286,324,1)
(180,388,1)
(224,271,1)
(89,179,1)
(129,349,1)
(45,94,1)
(133,120,1)
(62,221,1)
(444,123,1)
(324,221,1)
(127,431,1)
(346,105,1)
(285,359,1)
(203,451,1)
(117,103,1)
(305,56,1)
(145,413,1)
(270,30,1)
(463,230,1)
(181,2,1)
(364,171,1)
(313,221,1)
(189,94,1)
(236,411,1)
(360,349,1)
(22,54,1)
(410,46,1)
(451,417,1)
(461,267,1)
(329,298,1)
(165,407,1)
(103,35,1)
(345,162,1)
(145,63,1)
(326,5,1)
(249,386,1)
(418,203,1)
(268,39,1)
(302,163,1)
(87,378,1)
(185,403,1)
(385,262,1)
(32,340,1)
(389,462,1)
(204,385,1)
(266,349,1)
(64,240,1)
(262,357,1)
(464,227,1)
(420,221,1)
(96,277,1)
(154,349,1)
(31,31,1)
(465,228,1)
(467,160,1)
(161,456,1)
(266,410,1)
(280,138,1)
(398,412,1)
(420,13,1)
(436,258,1)
(205,366,1)
(296,373,1)
(160,208,1)
(272,179,1)
(89,245,1)
(200,112,1)
(176,211,1)
(221,116,1)
(324,356,1)
(284,53,1)
(293,387,1)
(397,152,1)
(196,80,1)
(90,467,1)
(73,72,1)
(155,31,1)
(79,213,1)
(361,349,1)
(301,374,1)
(92,81,1)
(126,91,1)
(267,193,1)
(154,191,1)
(238,49,1)
(439,460,1)
(201,440,1)
(204,262,1)
(289,221,1)
(9,409,1)
(7,433,1)
(462,201,1)
(469,396,1)
(345,422,1)
(301,221,1)
(70,160,1)
(167,470,1)
(83,95,1)
(214,115,1)
(57,153,1)
(311,96,1)
(470,438,1)
(459,98,1)
(155,92,1)
(387,317,1)
(229,286,1)
(0,111,1)
(166,329,1)
(97,365,1)
(336,447,1)
(183,286,1)
(69,322,1)
(403,394,1)
(320,17,1)
(423,250,1)
(249,349,1)
(371,12,1)
(294,454,1)
(13,151,1)
(265,244,1)
(182,442,1)
(16,201,1)
(115,221,1)
(298,164,1)
(251,4,1)
(177,391,1)
(447,221,1)
(384,86,1)
(109,284,1)
(379,435,1)
(119,221,1)
(341,376,1)
(149,187,1)
(289,335,1)
(430,343,1)
(396,349,1)
(257,349,1)
(114,156,1)
(291,408,1)
(96,349,1)
(348,316,1)
(391,313,1)
(253,198,1)
(241,84,1)
(296,4,1)
(386,134,1)
(354,86,1)
(375,215,1)
(450,439,1)
(329,221,1)
(307,194,1)
(412,397,1)
(330,396,1)
(169,390,1)
(334,306,1)
(120,94,1)
(406,185,1)
(411,138,1)
(292,43,1)
(332,421,1)
(446,227,1)
(5,74,1)
(468,118,1)
(241,319,1)
(54,450,1)
(150,458,1)
(369,434,1)
(310,383,1)
(32,315,1)
(323,65,1)
(308,355,1)
(248,51,1)
(416,45,1)
(431,432,1)
(73,190,1)
(60,55,1)
(338,139,1)
(128,110,1)
(404,353,1)
(264,89,1)
(378,398,1)
(361,137,1)
(350,349,1)
(230,146,1)
(413,63,1)
(227,41,1)
(125,11,1)
(241,340,1)
(118,34,1)
(461,446,1)
(436,361,1)
(459,17,1)
(82,326,1)
(61,71,1)
(28,200,1)
(6,384,1)
(4,107,1)
(32,215,1)
(372,53,1)
(309,62,1)
(268,6,1)
(460,147,1)
(39,182,1)
(295,175,1)
(425,440,1)
(46,26,1)
(174,136,1)
(405,311,1)
(206,161,1)
(399,297,1)
(116,282,1)
(123,29,1)
(440,209,1)
(263,14,1)
(95,364,1)
(209,375,1)
(146,348,1)
(296,459,1)
(314,341,1)
(448,221,1)
(428,415,1)
(222,461,1)
(360,42,1)
(445,144,1)
(402,126,1)
(80,40,1)
(45,27,1)
(156,349,1)
(41,109,1)
(448,212,1)
(372,418,1)
(155,376,1)
(283,260,1)
(237,210,1)
(175,452,1)
(239,355,1)
(124,469,1)
(225,142,1)
(100,368,1)
(59,104,1)
(319,78,1)
(311,115,1)
(433,418,1)
(155,317,1)
(85,9,1)
(75,222,1)
(51,90,1)
(328,351,1)
(245,215,1)
(94,48,1)
(173,468,1)
(458,233,1)
(327,3,1)
(452,53,1)
(337,328,1)
(409,251,1)
(346,221,1)
(133,215,1)
(44,254,1)
(395,221,1)
(131,183,1)
(155,141,1)
(19,361,1)
(8,114,1)
(186,273,1)
(168,145,1)
(213,349,1)
(292,349,1)
(347,221,1)
(175,53,1)
(111,291,1)
(122,39,1)
(257,290,1)
(457,349,1)
(417,242,1)
(355,292,1)
(362,346,1)
(56,420,1)
(58,344,1)
(437,221,1)
(334,176,1)
(255,324,1)
(339,9,1)
(384,354,1)
(44,349,1)
(118,221,1)
(31,376,1)
(299,266,1)
(252,235,1)
(435,366,1)
(372,424,1)
(244,459,1)
(411,180,1)
(130,306,1)
(25,373,1)
(42,293,1)
(29,196,1)
(208,207,1)
(443,304,1)
(381,389,1)
(233,257,1)
(449,379,1)
(350,399,1)
(119,76,1)
(269,58,1)
(370,437,1)
(394,122,1)
(77,288,1)
(167,221,1)
(366,221,1)
(148,405,1)
(198,429,1)
(348,349,1)
(260,444,1)
(137,25,1)
(45,395,1)
(396,37,1)
(414,6,2)
(443,462,2)
(470,229,2)
(444,123,2)
(360,39,2)
(420,404,2)
(155,92,2)
(267,154,2)
(76,311,2)
(320,17,2)
(305,60,2)
(177,462,2)
(18,462,2)
(334,311,2)
(315,104,2)
(225,469,2)
(40,84,2)
(296,373,2)
(75,349,2)
(283,260,2)
(267,446,2)
(253,311,2)
(121,286,2)
(299,6,2)
(465,119,2)
(38,17,2)
(61,121,2)
(296,85,2)
(61,286,2)
(451,446,2)
(359,311,2)
(166,355,2)
(410,6,2)
(215,229,2)
(274,229,2)
(438,229,2)
(446,152,2)
(3,84,2)
(468,118,2)
(115,73,2)
(463,349,2)
(225,430,2)
(350,349,2)
(394,39,2)
(366,229,2)
(5,145,2)
(372,431,2)
(133,120,2)
(32,340,2)
(2,73,2)
(242,446,2)
(311,73,2)
(404,301,2)
(221,116,2)
(387,39,2)
(445,6,2)
(85,152,2)
(39,323,2)
(417,446,2)
(174,311,2)
(442,6,2)
(57,6,2)
(170,73,2)
(329,355,2)
(361,349,2)
(18,221,2)
(371,311,2)
(267,193,2)
(328,152,2)
(276,39,2)
(260,444,2)
(123,29,2)
(326,145,2)
(369,145,2)
(270,152,2)
(80,84,2)
(428,152,2)
(141,6,2)
(190,179,2)
(333,179,2)
(319,462,2)
(134,404,2)
(372,463,2)
(39,39,2)
(317,39,2)
(136,311,2)
(125,128,2)
(459,38,2)
(59,6,2)
(207,311,2)
(364,6,2)
(142,469,2)
(81,276,2)
(203,446,2)
(227,349,2)
(94,48,2)
(372,257,2)
(355,201,2)
(69,39,2)
(432,446,2)
(166,329,2)
(291,408,2)
(462,308,2)
(464,152,2)
(253,198,2)
(12,311,2)
(321,446,2)
(97,84,2)
(96,73,2)
(31,39,2)
(14,229,2)
(330,128,2)
(460,68,2)
(22,179,2)
(155,39,2)
(184,152,2)
(123,84,2)
(78,462,2)
(92,39,2)
(143,229,2)
(172,229,2)
(350,152,2)
(107,345,2)
(120,327,2)
(116,349,2)
(45,395,2)
(259,6,2)
(325,225,2)
(135,345,2)
(32,6,2)
(384,86,2)
(171,6,2)
(205,172,2)
(324,179,2)
(288,6,2)
(415,152,2)
(162,152,2)
(346,145,2)
(193,349,2)
(181,73,2)
(156,349,2)
(246,311,2)
(191,446,2)
(78,443,2)
(308,166,2)
(53,296,2)
(338,201,2)
(219,128,2)
(189,462,2)
(377,462,2)
(175,53,2)
(252,84,2)
(56,404,2)
(366,221,2)
(248,311,2)
(384,359,2)
(95,6,2)
(407,462,2)
(111,205,2)
(372,150,2)
(258,152,2)
(48,117,2)
(342,289,2)
(418,446,2)
(129,349,2)
(214,73,2)
(469,128,2)
(275,446,2)
(465,311,2)
(293,39,2)
(467,160,2)
(395,84,2)
(176,246,2)
(159,175,2)
(28,152,2)
(345,162,2)
(307,462,2)
(124,469,2)
(382,311,2)
(467,311,2)
(292,201,2)
(354,359,2)
(118,462,2)
(160,311,2)
(262,39,2)
(107,221,2)
(272,179,2)
(271,6,2)
(460,147,2)
(209,229,2)
(38,221,2)
(125,221,2)
(146,446,2)
(78,468,2)
(467,465,2)
(92,406,2)
(431,446,2)
(133,215,2)
(381,462,2)
(444,40,2)
(372,53,2)
(210,345,2)
(110,221,2)
(133,84,2)
(212,84,2)
(450,179,2)
(65,6,2)
(20,17,2)
(317,141,2)
(383,6,2)
(409,152,2)
(257,446,2)
(182,6,2)
(172,449,2)
(286,324,2)
(458,446,2)
(462,201,2)
(121,221,2)
(405,311,2)
(11,128,2)
(355,292,2)
(446,227,2)
(9,349,2)
(75,152,2)
(336,6,2)
(243,266,2)
(154,349,2)
(229,61,2)
(79,6,2)
(128,110,2)
(365,84,2)
(1,84,2)
(245,179,2)
(448,84,2)
(79,213,2)
(138,82,2)
(420,221,2)
(204,39,2)
(403,39,2)
(51,340,2)
(100,360,2)
(285,359,2)
(361,152,2)
(72,179,2)
(345,152,2)
(327,448,2)
(30,152,2)
(411,180,2)
(237,345,2)
(71,286,2)
(104,336,2)
(4,107,2)
(416,45,2)
(372,424,2)
(234,462,2)
(363,311,2)
(180,346,2)
(151,404,2)
(169,390,2)
(436,152,2)
(308,201,2)
(414,83,2)
(331,446,2)
(187,56,2)
(169,0,2)
(357,39,2)
(152,404,2)
(155,31,2)
(280,145,2)
(337,221,2)
(344,250,2)
(206,446,2)
(22,349,2)
(0,229,2)
(185,39,2)
(463,446,2)
(196,84,2)
(263,229,2)
(29,84,2)
(168,145,2)
(243,414,2)
(336,447,2)
(32,315,2)
(7,446,2)
(102,359,2)
(144,6,2)
(447,6,2)
(64,355,2)
(13,404,2)
(258,200,2)
(388,145,2)
(179,325,2)
(347,311,2)
(84,94,2)
(292,349,2)
(83,6,2)
(130,311,2)
(112,152,2)
(286,179,2)
(426,462,2)
(444,84,2)
(73,72,2)
(21,84,2)
(104,402,2)
(343,469,2)
(138,145,2)
(273,84,2)
(284,350,2)
(60,56,2)
(461,152,2)
(283,133,2)
(204,262,2)
(372,348,2)
(126,6,2)
(315,6,2)
(270,53,2)
(324,221,2)
(460,73,2)
(319,78,2)
(167,229,2)
(193,446,2)
(323,65,2)
(360,349,2)
(164,355,2)
(319,215,2)
(94,462,2)
(118,221,2)
(17,152,2)
(469,125,2)
(48,462,2)
(314,6,2)
(452,152,2)
(459,17,2)
(148,311,2)
(442,39,2)
(301,221,2)
(180,145,2)
(98,17,2)
(198,311,2)
(396,349,2)
(244,152,2)
(424,446,2)
(4,345,2)
(404,353,2)
(46,6,2)
(84,462,2)
(388,369,2)
(236,145,2)
(413,462,2)
(254,311,2)
(443,313,2)
(268,73,2)
(313,221,2)
(140,311,2)
(100,39,2)
(416,157,2)
(240,355,2)
(373,349,2)
(296,436,2)
(149,56,2)
(27,84,2)
(141,32,2)
(439,460,2)
(74,145,2)
(85,9,2)
(48,307,2)
(305,56,2)
(243,6,2)
(176,311,2)
(372,418,2)
(120,84,2)
(351,152,2)
(255,179,2)
(39,6,2)
(323,6,2)
(348,446,2)
(347,221,2)
(31,31,2)
(25,152,2)
(294,39,2)
(34,462,2)
(228,311,2)
(392,462,2)
(327,84,2)
(51,90,2)
(253,347,2)
(425,229,2)
(311,115,2)
(119,311,2)
(322,39,2)
(200,152,2)
(183,286,2)
(37,128,2)
(232,152,2)
(86,359,2)
(44,349,2)
(179,128,2)
(436,258,2)
(81,39,2)
(150,446,2)
(287,179,2)
(356,179,2)
(155,317,2)
(82,145,2)
(379,229,2)
(229,286,2)
(468,462,2)
(176,211,2)
(91,6,2)
(353,349,2)
(416,84,2)
(395,221,2)
(396,128,2)
(313,462,2)
(337,152,2)
(284,53,2)
(152,305,2)
(306,90,2)
(439,73,2)
(233,446,2)
(54,179,2)
(26,6,2)
(103,462,2)
(344,199,2)
(224,6,2)
(447,221,2)
(131,286,2)
(83,95,2)
(297,152,2)
(317,204,2)
(208,311,2)
(348,349,2)
(368,39,2)
(389,462,2)
(205,229,2)
(298,355,2)
(334,306,2)
(256,311,2)
(154,446,2)
(213,349,2)
(386,404,2)
(290,446,2)
(468,15,2)
(41,152,2)
(372,161,2)
(122,39,2)
(346,221,2)
(104,6,2)
(173,462,2)
(304,462,2)
(73,179,2)
(375,229,2)
(77,6,2)
(31,100,2)
(434,145,2)
(32,215,2)
(246,371,2)
(262,221,2)
(429,311,2)
(35,462,2)
(334,51,2)
(147,73,2)
(296,459,2)
(175,152,2)
(9,152,2)
(138,312,2)
(137,152,2)
(132,446,2)
(443,304,2)
(250,221,2)
(215,169,2)
(372,417,2)
(161,446,2)
(230,446,2)
(457,349,2)
(105,145,2)
(316,446,2)
(113,221,2)
(355,113,2)
(19,152,2)
(165,462,2)
(303,446,2)
(127,446,2)
(385,39,2)
(436,361,2)
(362,145,2)
(411,145,2)
(162,221,2)
(266,349,2)
(0,111,2)
(435,229,2)
(53,152,2)
(245,340,2)
(166,64,2)
(51,311,2)
(236,215,2)
(411,138,2)
(155,376,2)
(63,462,2)
(440,349,2)
(92,81,2)
(83,79,2)
(241,179,2)
(466,462,2)
(117,462,2)
(6,359,2)
(227,152,2)
(437,221,2)
(440,229,2)
(260,84,2)
(111,291,2)
(182,39,2)
(6,311,2)
(265,152,2)
(373,152,2)
(284,152,2)
(222,152,2)
(195,462,2)
(449,229,2)
(194,462,2)
(139,201,2)
(200,349,2)
(310,6,2)
(120,94,2)
(454,39,2)
(109,152,2)
(145,63,2)
(43,201,2)
(44,311,2)
(119,221,2)
(376,243,2)
(336,153,2)
(201,440,2)
(340,229,2)
(111,229,2)
(260,416,2)
(306,44,2)
(399,152,2)
(422,152,2)
(296,152,2)
(198,429,2)
(329,221,2)
(201,229,2)
(370,437,2)
(448,221,2)
(291,229,2)
(147,349,2)
(167,221,2)
(406,39,2)
(101,229,2)
(56,420,2)
(42,39,2)
(308,355,2)
(469,396,2)
(60,457,2)
(213,6,2)
(180,388,2)
(4,152,2)
(295,152,2)
(51,215,2)
(66,446,2)
(84,18,2)
(306,311,2)
(45,94,2)
(352,175,2)
(398,349,2)
(229,179,2)
(155,141,2)
(257,349,2)
(216,446,2)
(305,404,2)
(56,249,2)
(16,201,2)
(153,6,2)
(359,256,2)
(238,311,2)
(300,462,2)
(278,6,2)
(249,404,2)
(296,4,2)
(291,167,2)
(246,253,2)
(304,195,2)
(6,384,2)
(249,349,2)
(45,84,2)
(334,176,2)
(459,152,2)
(235,84,2)
(433,446,2)
(17,337,2)
(169,229,2)
(115,221,2)
(266,6,2)
(261,39,2)
(251,152,2)
(289,221,2)
(283,84,2)
(239,355,2)
(339,152,2)
(205,366,2)
(113,201,2)
(236,411,2)
(93,311,2)
(31,376,2)
(277,73,2)
(391,462,2)
(261,323,2)
(55,56,2)
(90,311,2)
(311,96,2)
(372,446,2)
(70,311,2)
(145,462,2)
(90,467,2)
(128,398,2)
(430,469,2)
(79,310,2)
(393,6,2)
(72,349,2)
(402,6,2)
(376,6,2)
(96,349,2)
(178,311,2)
(317,317,2)
(456,446,2)
(430,349,2)
(40,221,2)
(245,215,2)
(462,229,2)
(457,56,2)
(49,311,2)
(325,469,2)
(36,39,2)
(341,6,2)
(325,128,2)
(186,84,2)
-----------------------------------
(0,ckalloc((unsigned)
(1,0)
(2,masterPtr)
(3,3)
(4,(masterPtr->height > 0)
(5,validBox)
(6,validBox.width > 0 && validBox.height > 0)
(7,y)
(8,width)
(9,instancePtr->visualInfo)
(10,masterPtr)
(11,height)
(12,height)
(13,height)
(14,newError)
(15,size_t)
(16,instancePtr)
(17,masterPtr->width > 0)
(18,masterPtr->height)
(19,instancePtr)
(20,width)
(21,masterPtr)
(22,instancePtr->error)
(23,)
(24,)
(25,instancePtr)
(26,errSrcPtr)
(27,h)
(28,screen)
(29,sizeof(schar)
(30,newPixmap)
(31,errSrcPtr += instancePtr->width * 3)
(32,newError +\n\\n\\t\\t\\t(validBox.y * masterPtr->width + validBox.x)
(33,)
(34,height)
(35,validBox)
(36,h)
(37,height)
(38,masterPtr->width)
(39,h > 0)
(40,masterPtr->width)
(41,pixels)
(42,width)
(43,width)
(44,instancePtr->error)
(45,masterPtr->height - h)
(46,instancePtr)
(47,if (instancePtr->error != NULL)
(48,validBox.y + validBox.height)
(49,newError)
(50,)
(51,newError + offset)
(52,if (h < masterPtr->height)
(53,newPixmap = Tk_GetPixmap(instancePtr->display,\n\\n\\t\\tRootWindow(instancePtr->display,\n\\n\\t\\t\\tinstancePtr->visualInfo.screen)
(54,error)
(55,None)
(56,instancePtr->height != masterPtr->height)
(57,masterPtr)
(58,instancePtr)
(59,3)
(60,instancePtr->pixels == None)
(61,masterPtr->width > 0)
(62,masterPtr)
(63,validBox.y)
(64,validBox.width)
(65,validBox.height)
(66,pixels)
(67,)
(68,char *)
(69,masterPtr)
(70,masterPtr)
(71,0)
(72,instancePtr->error)
(73,instancePtr->error != NULL)
(74,0)
(75,instancePtr->pixels)
(76,width)
(77,newError)
(78,(size_t)
(79,validBox.y * instancePtr->width)
(80,3)
(81,3 * sizeof(schar)
(82,validBox.y)
(83,validBox.y * instancePtr->width + validBox.x)
(84,h < masterPtr->height)
(85,instancePtr->visualInfo.depth)
(86,validBox.height)
(87,width)
(88,)
(89,instancePtr)
(90,offset = validBox.y * masterPtr->width * 3)
(91,validBox)
(92,validBox.width * 3 * sizeof(schar)
(93,width)
(94,h = validBox.y + validBox.height)
(95,validBox.x)
(96,instancePtr->width)
(97,h)
(98,1)
(99,h)
(100,instancePtr->width * 3)
(101,newError)
(102,height)
(103,y)
(104,validBox.y * masterPtr->width + validBox.x)
(105,width)
(106,if ((instancePtr->width != masterPtr->width)
(107,masterPtr->height)
(108,)
(109,instancePtr)
(110,masterPtr->width)
(111,(unsigned)
(112,visualInfo)
(113,masterPtr->width)
(114,masterPtr)
(115,masterPtr->width)
(116,instancePtr->masterPtr)
(117,validBox.y)
(118,masterPtr->height)
(119,masterPtr->width)
(120,h*masterPtr->width*3)
(121,masterPtr->width)
(122,errDestPtr)
(123,3 * sizeof(schar)
(124,instancePtr)
(125,masterPtr->height)
(126,x)
(127,validBox)
(128,instancePtr->width != masterPtr->width)
(129,instancePtr->height)
(130,validBox)
(131,width)
(132,instancePtr)
(133,newError + h*masterPtr->width*3)
(134,instancePtr)
(135,1)
(136,3)
(137,display)
(138,(size_t)
(139,masterPtr)
(140,offset)
(141,errDestPtr = newError +\n\\n\\t\\t\\t(validBox.y * masterPtr->width + validBox.x)
(142,NULL)
(143,width)
(144,validBox)
(145,validBox.y > 0)
(146,instancePtr)
(147,instancePtr->error)
(148,width)
(149,pixels)
(150,validBox.x)
(151,masterPtr)
(152,(instancePtr->width != masterPtr->width)
(153,validBox.y)
(154,instancePtr->display)
(155,memcpy(errDestPtr, errSrcPtr,\n\\n\\t\\t\\t    validBox.width * 3 * sizeof(schar)
(156,instancePtr->width)
(157,size_t)
(158,)
(159,Tcl_Panic("Fail to create pixmap with Tk_GetPixmap in ImgPhotoInstanceSetSize.\\n")
(160,validBox.y)
(161,validBox.width)
(162,masterPtr->height)
(163,instancePtr)
(164,masterPtr)
(165,0)
(166,validBox.width == masterPtr->width)
(167,masterPtr->height)
(168,newError)
(169,(schar *)
(170,error)
(171,validBox)
(172,3 * sizeof(schar)
(173,masterPtr)
(174,schar)
(175,!newPixmap)
(176,(size_t)
(177,schar)
(178,0)
(179,(instancePtr->width != masterPtr->width)
(180,masterPtr->width * 3 * sizeof(schar)
(181,width)
(182,0)
(183,masterPtr)
(184,0)
(185,width)
(186,height)
(187,instancePtr)
(188,if (masterPtr->height > 0 && masterPtr->width > 0)
(189,h)
(190,NULL)
(191,display)
(192,)
(193,instancePtr->pixels)
(194,height)
(195,sizeof(schar)
(196,schar)
(197,masterPtr)
(198,3 * sizeof(schar)
(199,&validBox)
(200,instancePtr->visualInfo)
(201,instancePtr->error != NULL)
(202,if (!newPixmap)
(203,x)
(204,masterPtr->width * 3)
(205,masterPtr->width * 3 * sizeof(schar)
(206,validBox)
(207,validBox)
(208,y)
(209,error)
(210,masterPtr)
(211,size_t)
(212,width)
(213,instancePtr->width)
(214,instancePtr)
(215,newError = (schar *)
(216,instancePtr)
(217,)
(218,validBox)
(219,instancePtr)
(220,offset)
(221,masterPtr = instancePtr->masterPtr)
(222,pixels)
(223,)
(224,width)
(225,instancePtr->error == NULL)
(226,if (validBox.y > 0)
(227,instancePtr->pixels)
(228,3)
(229,masterPtr->height > 0 && masterPtr->width > 0)
(230,pixels)
(231,newError)
(232,newPixmap)
(233,validBox)
(234,validBox)
(235,masterPtr)
(236,memset(newError, 0, (size_t)
(237,height)
(238,offset)
(239,validBox)
(240,width)
(241,instancePtr)
(242,height)
(243,instancePtr->error +\n\\n\\t\\t\\t(validBox.y * instancePtr->width + validBox.x)
(244,masterPtr)
(245,instancePtr->error = newError)
(246,validBox.height\n\\n\\t\\t\\t* masterPtr->width * 3 * sizeof(schar)
(247,)
(248,instancePtr)
(249,instancePtr->height)
(250,masterPtr->validRegion)
(251,instancePtr)
(252,width)
(253,masterPtr->width * 3 * sizeof(schar)
(254,error)
(255,0)
(256,validBox.width)
(257,instancePtr->gc)
(258,instancePtr->visualInfo.screen)
(259,height)
(260,(size_t)
(261,--h)
(262,masterPtr->width)
(263,NULL)
(264,width)
(265,height)
(266,instancePtr->error)
(267,Tk_FreePixmap(instancePtr->display, instancePtr->pixels)
(268,instancePtr)
(269,width)
(270,instancePtr->pixels = newPixmap)
(271,instancePtr)
(272,masterPtr)
(273,masterPtr)
(274,masterPtr)
(275,instancePtr)
(276,sizeof(schar)
(277,width)
(278,3)
(279,for (h = validBox.height; h > 0; --h)
(280,masterPtr)
(281,if ((instancePtr->error != NULL)
(282,masterPtr)
(283,memset(newError + h*masterPtr->width*3, 0,\n\\n\\t\\t\\t    (size_t)
(284,TkSetPixmapColormap(newPixmap, instancePtr->colormap)
(285,validBox)
(286,masterPtr->height > 0)
(287,error)
(288,errDestPtr)
(289,masterPtr->height)
(290,gc)
(291,(unsigned)
(292,instancePtr->width)
(293,instancePtr)
(294,schar)
(295,newPixmap)
(296,Tk_GetPixmap(instancePtr->display,\n\\n\\t\\tRootWindow(instancePtr->display,\n\\n\\t\\t\\tinstancePtr->visualInfo.screen)
(297,instancePtr)
(298,width)
(299,validBox)
(300,h)
(301,masterPtr->width)
(302,height)
(303,newPixmap)
(304,3*sizeof(schar)
(305,(instancePtr->height != masterPtr->height)
(306,instancePtr->error + offset)
(307,validBox.height)
(308,(instancePtr->width == masterPtr->width)
(309,validRegion)
(310,validBox.y)
(311,masterPtr->width == instancePtr->width)
(312,size_t)
(313,masterPtr->width)
(314,validBox)
(315,(validBox.y * masterPtr->width + validBox.x)
(316,display)
(317,errDestPtr += masterPtr->width * 3)
(318,errSrcPtr)
(319,memset(newError, 0, (size_t)
(320,masterPtr)
(321,validBox)
(322,errDestPtr)
(323,h = validBox.height)
(324,masterPtr->height)
(325,(instancePtr->height != masterPtr->height)
(326,y)
(327,masterPtr->width*3)
(328,width)
(329,masterPtr->width)
(330,masterPtr)
(331,instancePtr)
(332,instancePtr)
(333,newError)
(334,memcpy(newError + offset, instancePtr->error + offset,\n\\n\\t\\t\\t(size_t)
(335,height)
(336,validBox.y * masterPtr->width)
(337,masterPtr->width)
(338,width)
(339,depth)
(340,newError = NULL)
(341,h)
(342,instancePtr->height = masterPtr->height)
(343,error)
(344,TkClipBox(masterPtr->validRegion, &validBox)
(345,masterPtr->height > 0)
(346,masterPtr->width)
(347,masterPtr->width)
(348,instancePtr->display)
(349,PhotoInstance *instancePtr)
(350,instancePtr->colormap)
(351,masterPtr)
(352,"Fail to create pixmap with Tk_GetPixmap in ImgPhotoInstanceSetSize.\\n")
(353,instancePtr->width)
(354,0)
(355,instancePtr->width == masterPtr->width)
(356,height)
(357,width)
(358,RET)
(359,validBox.width > 0)
(360,instancePtr->width)
(361,instancePtr->display)
(362,3)
(363,offset)
(364,x)
(365,newError)
(366,masterPtr->width)
(367,newPixmap)
(368,3)
(369,sizeof(schar)
(370,instancePtr->width = masterPtr->width)
(371,validBox.height)
(372,XCopyArea(instancePtr->display, instancePtr->pixels, newPixmap,\n\\n\\t\\t    instancePtr->gc, validBox.x, validBox.y,\n\\n\\t\\t    validBox.width, validBox.height, validBox.x, validBox.y)
(373,instancePtr->display)
(374,width)
(375,instancePtr)
(376,errSrcPtr = instancePtr->error +\n\\n\\t\\t\\t(validBox.y * instancePtr->width + validBox.x)
(377,height)
(378,masterPtr)
(379,schar)
(380,)
(381,y)
(382,masterPtr)
(383,y)
(384,validBox.height > 0)
(385,3)
(386,height)
(387,errSrcPtr)
(388,3 * sizeof(schar)
(389,validBox)
(390,schar *)
(391,3)
(392,masterPtr)
(393,width)
(394,errSrcPtr)
(395,masterPtr->height)
(396,instancePtr->height)
(397,instancePtr)
(398,instancePtr->width)
(399,colormap)
(400,)
(401,if ((instancePtr->width != masterPtr->width)
(402,validBox.x)
(403,validBox)
(404,instancePtr->width != masterPtr->width)
(405,validBox)
(406,validBox.width)
(407,newError)
(408,unsigned)
(409,visualInfo)
(410,error)
(411,(size_t)
(412,width)
(413,0)
(414,(validBox.y * instancePtr->width + validBox.x)
(415,instancePtr)
(416,(size_t)
(417,validBox.height)
(418,validBox.x)
(419,if (masterPtr->width == instancePtr->width)
(420,masterPtr->height)
(421,masterPtr)
(422,0)
(423,validBox)
(424,validBox.y)
(425,NULL)
(426,width)
(427,if (instancePtr->pixels != None)
(428,display)
(429,sizeof(schar)
(430,instancePtr->error)
(431,validBox.y)
(432,y)
(433,validBox)
(434,schar)
(435,3)
(436,RootWindow(instancePtr->display,\n\\n\\t\\t\\tinstancePtr->visualInfo.screen)
(437,masterPtr->width)
(438,masterPtr)
(439,ckfree((char *)
(440,instancePtr->error)
(441,)
(442,h)
(443,masterPtr->width *3*sizeof(schar)
(444,masterPtr->width * 3 * sizeof(schar)
(445,y)
(446,instancePtr->pixels != None)
(447,masterPtr->width)
(448,masterPtr->width)
(449,sizeof(schar)
(450,instancePtr)
(451,validBox)
(452,newPixmap)
(453,errDestPtr)
(454,3)
(455,masterPtr)
(456,width)
(457,instancePtr->pixels)
(458,x)
(459,(masterPtr->width > 0)
(460,(char *)
(461,instancePtr)
(462,(instancePtr->error != NULL)
(463,instancePtr->pixels)
(464,None)
(465,masterPtr->width * 3)
(466,masterPtr)
(467,validBox.y * masterPtr->width * 3)
(468,(size_t)
(469,instancePtr->height != masterPtr->height)
(470,height)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^