-----label-----
1
-----code-----
static int sla_station_exec(struct ast_channel *chan, const char *data)
{
	char *station_name, *trunk_name;
	struct sla_station *station;
	struct sla_trunk_ref *trunk_ref = NULL;
	char conf_name[MAX_CONFNUM];
	struct ast_flags64 conf_flags = { 0 };
	struct ast_conference *conf;

	if (ast_strlen_zero(data)) {
		ast_log(LOG_WARNING, "Invalid Arguments to SLAStation!\n");
		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE");
		return 0;
	}

	trunk_name = ast_strdupa(data);
	station_name = strsep(&trunk_name, "_");

	if (ast_strlen_zero(station_name)) {
		ast_log(LOG_WARNING, "Invalid Arguments to SLAStation!\n");
		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE");
		return 0;
	}

	AST_RWLIST_RDLOCK(&sla_stations);
	station = sla_find_station(station_name);
	if (station)
		ast_atomic_fetchadd_int((int *) &station->ref_count, 1);
	AST_RWLIST_UNLOCK(&sla_stations);

	if (!station) {
		ast_log(LOG_WARNING, "Station '%s' not found!\n", station_name);
		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE");
		sla_queue_event(SLA_EVENT_CHECK_RELOAD);
		return 0;
	}

	AST_RWLIST_RDLOCK(&sla_trunks);
	if (!ast_strlen_zero(trunk_name)) {
		trunk_ref = sla_find_trunk_ref_byname(station, trunk_name);
	} else
		trunk_ref = sla_choose_idle_trunk(station);
	AST_RWLIST_UNLOCK(&sla_trunks);

	if (!trunk_ref) {
		if (ast_strlen_zero(trunk_name))
			ast_log(LOG_NOTICE, "No trunks available for call.\n");
		else {
			ast_log(LOG_NOTICE, "Can't join existing call on trunk "
				"'%s' due to access controls.\n", trunk_name);
		}
		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "CONGESTION");
		ast_atomic_fetchadd_int((int *) &station->ref_count, -1);
		sla_queue_event(SLA_EVENT_CHECK_RELOAD);
		return 0;
	}

	if (trunk_ref->state == SLA_TRUNK_STATE_ONHOLD_BYME) {
		if (ast_atomic_dec_and_test((int *) &trunk_ref->trunk->hold_stations) == 1)
			sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);
		else {
			trunk_ref->state = SLA_TRUNK_STATE_UP;
			ast_devstate_changed(AST_DEVICE_INUSE,
				"SLA:%s_%s", station->name, trunk_ref->trunk->name);
		}
	} else if (trunk_ref->state == SLA_TRUNK_STATE_RINGING) {
		struct sla_ringing_trunk *ringing_trunk;

		ast_mutex_lock(&sla.lock);
		AST_LIST_TRAVERSE_SAFE_BEGIN(&sla.ringing_trunks, ringing_trunk, entry) {
			if (ringing_trunk->trunk == trunk_ref->trunk) {
				AST_LIST_REMOVE_CURRENT(entry);
				break;
			}
		}
		AST_LIST_TRAVERSE_SAFE_END
		ast_mutex_unlock(&sla.lock);

		if (ringing_trunk) {
			answer_trunk_chan(ringing_trunk->trunk->chan);
			sla_change_trunk_state(ringing_trunk->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);

			free(ringing_trunk);

			/* Queue up reprocessing ringing trunks, and then ringing stations again */
			sla_queue_event(SLA_EVENT_RINGING_TRUNK);
			sla_queue_event(SLA_EVENT_DIAL_STATE);
		}
	}

	trunk_ref->chan = chan;

	if (!trunk_ref->trunk->chan) {
		ast_mutex_t cond_lock;
		ast_cond_t cond;
		pthread_t dont_care;
		struct dial_trunk_args args = {
			.trunk_ref = trunk_ref,
			.station = station,
			.cond_lock = &cond_lock,
			.cond = &cond,
		};
		sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);
		/* Create a thread to dial the trunk and dump it into the conference.
		 * However, we want to wait until the trunk has been dialed and the
		 * conference is created before continuing on here. */
		ast_autoservice_start(chan);
		ast_mutex_init(&cond_lock);
		ast_cond_init(&cond, NULL);
		ast_mutex_lock(&cond_lock);
		ast_pthread_create_detached_background(&dont_care, NULL, dial_trunk, &args);
		ast_cond_wait(&cond, &cond_lock);
		ast_mutex_unlock(&cond_lock);
		ast_mutex_destroy(&cond_lock);
		ast_cond_destroy(&cond);
		ast_autoservice_stop(chan);
		if (!trunk_ref->trunk->chan) {
			ast_debug(1, "Trunk didn't get created. chan: %lx\n", (long) trunk_ref->trunk->chan);
			pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "CONGESTION");
			sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_IDLE, ALL_TRUNK_REFS, NULL);
			trunk_ref->chan = NULL;
			ast_atomic_fetchadd_int((int *) &station->ref_count, -1);
			sla_queue_event(SLA_EVENT_CHECK_RELOAD);
			return 0;
		}
	}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
5,6
5,7
6,7
8,9
8,10
11,12
11,13
13,14
13,15
16,17
16,18
16,19
16,20
16,21
16,22
16,23
16,24
16,25
16,26
16,27
16,28
16,29
16,30
16,31
16,32
16,33
16,34
16,35
16,36
16,37
16,38
16,39
16,40
16,41
16,42
16,43
16,44
16,45
16,46
16,47
16,48
16,49
16,50
16,51
17,18
18,19
18,20
18,21
20,21
20,22
23,24
23,25
26,27
27,28
27,29
28,29
30,31
30,32
33,34
34,35
34,36
35,36
37,38
37,39
37,40
40,41
41,42
43,44
44,45
44,46
46,47
46,48
48,49
49,50
51,52
52,53
52,54
53,54
55,56
55,57
57,58
58,59
60,61
61,62
61,63
62,63
64,65
64,66
67,68
67,69
68,69
68,70
69,70
71,72
73,74
73,75
73,76
74,75
75,76
75,77
75,78
76,77
78,79
81,82
82,83
82,84
82,85
82,86
83,84
85,86
89,90
91,92
92,93
92,94
93,94
95,96
95,97
96,97
98,99
100,101
101,102
101,103
102,103
104,105
104,106
104,107
105,106
107,108
108,109
111,112
111,113
112,113
112,114
113,114
115,116
117,118
117,119
117,120
118,119
119,120
119,121
119,122
120,121
122,123
125,126
126,127
126,128
126,129
126,130
127,128
129,130
133,134
135,136
136,137
136,138
137,138
139,140
140,141
140,142
143,144
144,145
144,146
145,146
147,148
147,149
148,149
150,151
152,153
152,154
153,154
155,156
156,157
156,158
156,159
157,158
159,160
159,161
160,161
160,162
162,163
164,165
165,166
165,167
166,167
170,171
171,172
171,173
172,173
174,175
175,176
177,178
177,179
178,179
179,180
181,182
181,183
181,184
181,185
182,183
183,184
183,185
183,186
183,187
184,185
186,187
189,190
191,192
192,193
192,194
192,195
192,196
193,194
195,196
199,200
200,201
200,202
201,202
203,204
204,205
206,207
208,209
209,210
209,211
210,211
212,213
213,214
213,215
216,217
216,218
216,219
217,218
218,219
218,220
219,220
221,222
223,224
224,225
225,226
225,227
226,227
228,229
228,230
228,231
229,230
231,232
233,234
235,236
236,237
236,238
237,238
239,240
239,241
240,241
242,243
244,245
245,246
245,247
246,247
248,249
249,250
251,252
251,253
252,253
253,254
255,256
255,257
255,258
255,259
255,260
256,257
256,258
256,259
257,258
257,259
258,259
260,261
262,263
263,264
263,265
263,266
264,265
266,267
269,270
270,271
271,272
271,273
271,274
271,275
272,273
274,275
277,278
279,280
280,281
280,282
280,283
280,284
281,282
283,284
287,288
288,289
288,290
288,291
289,290
291,292
291,293
292,293
292,294
294,295
296,297
297,298
297,299
298,299
301,302
303,304
304,305
304,306
305,306
307,308
308,309
310,311
312,313
312,314
312,315
313,314
313,315
314,315
314,316
315,316
318,319
320,321
321,322
321,323
321,324
322,323
322,324
323,324
323,325
324,325
326,327
326,328
327,328
327,329
329,330
331,332
332,333
332,334
333,334
333,335
334,335
339,340
340,341
340,342
340,343
340,344
340,345
341,342
343,344
343,345
344,345
347,348
349,350
351,352
353,354
353,355
354,355
355,356
355,357
356,357
356,358
357,358
360,361
362,363
363,364
363,365
363,366
363,367
363,368
364,365
366,367
369,370
369,371
370,371
373,374
373,375
374,375
374,376
375,376
379,380
379,381
380,381
380,382
381,382
381,383
382,383
385,386
387,388
387,389
387,390
387,391
387,392
387,393
387,394
388,389
389,390
389,391
390,391
392,393
392,394
395,396
396,397
396,398
397,398
399,400
400,401
400,402
401,402
404,405
405,406
405,407
405,408
405,409
406,407
408,409
409,410
409,411
410,411
413,414
415,416
417,418
418,419
419,420
419,421
420,421
420,422
421,422
421,423
422,423
425,426
425,427
426,427
429,430
429,431
430,431
431,432
431,433
432,433
434,435
435,436
438,439
439,440
439,441
440,441
442,443
442,444
444,445
445,446
446,447
446,448
447,448
450,451
450,452
451,452
453,454
453,455
453,456
453,457
453,458
454,455
455,456
455,457
456,457
458,459
458,460
459,460
459,461
460,461
464,465
465,466
465,467
465,468
465,469
465,470
466,467
468,469
468,470
469,470
472,473
474,475
476,477
478,479
479,480
479,481
480,481
482,483
484,485
485,486
485,487
486,487
488,489
489,490
491,492
492,493
492,494
493,494
495,496
496,497
498,499
499,500
499,501
500,501
500,502
501,502
504,505
506,507
506,508
507,508
508,509
508,510
509,510
509,511
510,511
514,515
514,516
514,517
514,518
515,516
516,517
516,518
517,518
519,520
521,522
522,523
522,524
523,524
525,526
527,528
528,529
528,530
529,530
531,532
533,534
535,536
536,537
536,538
536,539
536,540
536,541
537,538
539,540
539,541
540,541
543,544
545,546
547,548
549,550
550,551
550,552
551,552
553,554
555,556
556,557
556,558
557,558
559,560
560,561
560,562
563,564
564,565
564,566
564,567
565,566
567,568
568,569
570,571
572,573
573,574
573,575
574,575
576,577
577,578
579,580
580,581
580,582
580,583
580,584
580,585
581,582
583,584
584,585
586,587
588,589
590,591
591,592
593,594
594,595
594,596
594,597
595,596
597,598
598,599
600,601
601,602
603,604
604,605
604,606
605,606
607,608
608,609
610,611
611,612
611,613
612,613
614,615
615,616
617,618
618,619
618,620
619,620
621,622
622,623
622,624
625,626
626,627
626,628
627,628
629,630
631,632
631,633
632,633
633,634
633,635
634,635
634,636
635,636
639,640
639,641
639,642
639,643
639,644
639,645
639,646
640,641
641,642
641,643
641,644
641,645
642,643
646,647
646,648
647,648
647,649
650,651
650,652
651,652
651,653
652,653
656,657
657,658
657,659
657,660
657,661
658,659
660,661
664,665
665,666
665,667
665,668
665,669
665,670
666,667
668,669
668,670
669,670
672,673
674,675
676,677
678,679
679,680
679,681
680,681
680,682
681,682
684,685
686,687
687,688
687,689
687,690
688,689
690,691
690,692
691,692
691,693
693,694
695,696
696,697
696,698
697,698
700,701
702,703
703,704
703,705
704,705
706,707
707,708
709,710
-----nextToken-----
2,4,7,9,10,12,14,15,19,21,22,24,25,29,31,32,36,38,39,42,45,47,50,54,56,59,63,65,66,70,72,77,79,80,84,86,87,88,90,94,97,99,103,106,109,110,114,116,121,123,124,128,130,131,132,134,138,141,142,146,149,151,154,158,161,163,167,168,169,173,176,180,185,187,188,190,194,196,197,198,202,205,207,211,214,215,220,222,227,230,232,234,238,241,243,247,250,254,259,261,265,267,268,273,275,276,278,282,284,285,286,290,293,295,299,300,302,306,309,311,316,317,319,325,328,330,335,336,337,338,342,345,346,348,350,352,358,359,361,365,367,368,371,372,376,377,378,383,384,386,391,393,394,398,402,403,407,411,412,414,416,423,424,427,428,433,436,437,441,443,448,449,452,457,461,462,463,467,470,471,473,475,477,481,483,487,490,494,497,502,503,505,511,512,513,518,520,524,526,530,532,534,538,541,542,544,546,548,552,554,558,561,562,566,569,571,575,578,582,585,587,589,592,596,599,602,606,609,613,616,620,623,624,628,630,636,637,638,643,644,645,648,649,653,654,655,659,661,662,663,667,670,671,673,675,677,682,683,685,689,692,694,698,699,701,705,708,710
-----computeFrom-----
92,93
92,94
101,102
101,103
144,145
144,146
225,226
225,227
236,237
236,238
313,314
313,315
322,323
322,324
355,356
355,357
380,381
380,382
420,421
420,422
499,500
499,501
679,680
679,681
-----guardedBy-----
317,359
316,376
336,346
335,345
383,427
-----guardedByNegation-----
317,384
316,427
336,377
335,376
-----lastLexicalUse-----
316,427
317,384
336,377
335,376
-----jump-----
316,427
317,384
336,377
335,376
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;InitializerList;LiteralExpression;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;ReturnStatement;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;ReturnStatement;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;ReferenceOperator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;UnaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ReturnStatement;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;ReferenceOperator;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;UnaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ReturnStatement;LiteralExpression;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;ProblemStatement;CompoundStatement;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;BreakStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ConstructorInitializer;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ProblemStatement;NullStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;ReferenceOperator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;ReferenceOperator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;UnaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ReturnStatement;LiteralExpression;
-----ast_node-----
static int sla_station_exec(struct ast_channel *chan, const char *data){	char *station_name, *trunk_name;	struct sla_station *station;	struct sla_trunk_ref *trunk_ref = NULL;	char conf_name[MAX_CONFNUM];	struct ast_flags64 conf_flags = { 0 };	struct ast_conference *conf;	if (ast_strlen_zero(data)) {		ast_log(LOG_WARNING, "Invalid Arguments to SLAStation!\n");		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE");		return 0;	}	trunk_name = ast_strdupa(data);	station_name = strsep(&trunk_name, "_");	if (ast_strlen_zero(station_name)) {		ast_log(LOG_WARNING, "Invalid Arguments to SLAStation!\n");		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE");		return 0;	}	AST_RWLIST_RDLOCK(&sla_stations);	station = sla_find_station(station_name);	if (station)		ast_atomic_fetchadd_int((int *) &station->ref_count, 1);	AST_RWLIST_UNLOCK(&sla_stations);	if (!station) {		ast_log(LOG_WARNING, "Station '%s' not found!\n", station_name);		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE");		sla_queue_event(SLA_EVENT_CHECK_RELOAD);		return 0;	}	AST_RWLIST_RDLOCK(&sla_trunks);	if (!ast_strlen_zero(trunk_name)) {		trunk_ref = sla_find_trunk_ref_byname(station, trunk_name);	} else		trunk_ref = sla_choose_idle_trunk(station);	AST_RWLIST_UNLOCK(&sla_trunks);	if (!trunk_ref) {		if (ast_strlen_zero(trunk_name))			ast_log(LOG_NOTICE, "No trunks available for call.\n");		else {			ast_log(LOG_NOTICE, "Can't join existing call on trunk "				"'%s' due to access controls.\n", trunk_name);		}		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "CONGESTION");		ast_atomic_fetchadd_int((int *) &station->ref_count, -1);		sla_queue_event(SLA_EVENT_CHECK_RELOAD);		return 0;	}	if (trunk_ref->state == SLA_TRUNK_STATE_ONHOLD_BYME) {		if (ast_atomic_dec_and_test((int *) &trunk_ref->trunk->hold_stations) == 1)			sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);		else {			trunk_ref->state = SLA_TRUNK_STATE_UP;			ast_devstate_changed(AST_DEVICE_INUSE,				"SLA:%s_%s", station->name, trunk_ref->trunk->name);		}	} else if (trunk_ref->state == SLA_TRUNK_STATE_RINGING) {		struct sla_ringing_trunk *ringing_trunk;		ast_mutex_lock(&sla.lock);		AST_LIST_TRAVERSE_SAFE_BEGIN(&sla.ringing_trunks, ringing_trunk, entry) {			if (ringing_trunk->trunk == trunk_ref->trunk) {				AST_LIST_REMOVE_CURRENT(entry);				break;			}		}		AST_LIST_TRAVERSE_SAFE_END		ast_mutex_unlock(&sla.lock);		if (ringing_trunk) {			answer_trunk_chan(ringing_trunk->trunk->chan);			sla_change_trunk_state(ringing_trunk->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);			free(ringing_trunk);			/* Queue up reprocessing ringing trunks, and then ringing stations again */			sla_queue_event(SLA_EVENT_RINGING_TRUNK);			sla_queue_event(SLA_EVENT_DIAL_STATE);		}	}	trunk_ref->chan = chan;	if (!trunk_ref->trunk->chan) {		ast_mutex_t cond_lock;		ast_cond_t cond;		pthread_t dont_care;		struct dial_trunk_args args = {			.trunk_ref = trunk_ref,			.station = station,			.cond_lock = &cond_lock,			.cond = &cond,		};		sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);		/* Create a thread to dial the trunk and dump it into the conference.		 * However, we want to wait until the trunk has been dialed and the		 * conference is created before continuing on here. */		ast_autoservice_start(chan);		ast_mutex_init(&cond_lock);		ast_cond_init(&cond, NULL);		ast_mutex_lock(&cond_lock);		ast_pthread_create_detached_background(&dont_care, NULL, dial_trunk, &args);		ast_cond_wait(&cond, &cond_lock);		ast_mutex_unlock(&cond_lock);		ast_mutex_destroy(&cond_lock);		ast_cond_destroy(&cond);		ast_autoservice_stop(chan);		if (!trunk_ref->trunk->chan) {			ast_debug(1, "Trunk didn't get created. chan: %lx\n", (long) trunk_ref->trunk->chan);			pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "CONGESTION");			sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_IDLE, ALL_TRUNK_REFS, NULL);			trunk_ref->chan = NULL;			ast_atomic_fetchadd_int((int *) &station->ref_count, -1);			sla_queue_event(SLA_EVENT_CHECK_RELOAD);			return 0;		}	}
static int
sla_station_exec(struct ast_channel *chan, const char *data)
sla_station_exec
struct ast_channel *chan
struct ast_channel
ast_channel
*chan
*
chan
const char *data
const char
*data
*
data
{	char *station_name, *trunk_name;	struct sla_station *station;	struct sla_trunk_ref *trunk_ref = NULL;	char conf_name[MAX_CONFNUM];	struct ast_flags64 conf_flags = { 0 };	struct ast_conference *conf;	if (ast_strlen_zero(data)) {		ast_log(LOG_WARNING, "Invalid Arguments to SLAStation!\n");		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE");		return 0;	}	trunk_name = ast_strdupa(data);	station_name = strsep(&trunk_name, "_");	if (ast_strlen_zero(station_name)) {		ast_log(LOG_WARNING, "Invalid Arguments to SLAStation!\n");		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE");		return 0;	}	AST_RWLIST_RDLOCK(&sla_stations);	station = sla_find_station(station_name);	if (station)		ast_atomic_fetchadd_int((int *) &station->ref_count, 1);	AST_RWLIST_UNLOCK(&sla_stations);	if (!station) {		ast_log(LOG_WARNING, "Station '%s' not found!\n", station_name);		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE");		sla_queue_event(SLA_EVENT_CHECK_RELOAD);		return 0;	}	AST_RWLIST_RDLOCK(&sla_trunks);	if (!ast_strlen_zero(trunk_name)) {		trunk_ref = sla_find_trunk_ref_byname(station, trunk_name);	} else		trunk_ref = sla_choose_idle_trunk(station);	AST_RWLIST_UNLOCK(&sla_trunks);	if (!trunk_ref) {		if (ast_strlen_zero(trunk_name))			ast_log(LOG_NOTICE, "No trunks available for call.\n");		else {			ast_log(LOG_NOTICE, "Can't join existing call on trunk "				"'%s' due to access controls.\n", trunk_name);		}		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "CONGESTION");		ast_atomic_fetchadd_int((int *) &station->ref_count, -1);		sla_queue_event(SLA_EVENT_CHECK_RELOAD);		return 0;	}	if (trunk_ref->state == SLA_TRUNK_STATE_ONHOLD_BYME) {		if (ast_atomic_dec_and_test((int *) &trunk_ref->trunk->hold_stations) == 1)			sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);		else {			trunk_ref->state = SLA_TRUNK_STATE_UP;			ast_devstate_changed(AST_DEVICE_INUSE,				"SLA:%s_%s", station->name, trunk_ref->trunk->name);		}	} else if (trunk_ref->state == SLA_TRUNK_STATE_RINGING) {		struct sla_ringing_trunk *ringing_trunk;		ast_mutex_lock(&sla.lock);		AST_LIST_TRAVERSE_SAFE_BEGIN(&sla.ringing_trunks, ringing_trunk, entry) {			if (ringing_trunk->trunk == trunk_ref->trunk) {				AST_LIST_REMOVE_CURRENT(entry);				break;			}		}		AST_LIST_TRAVERSE_SAFE_END		ast_mutex_unlock(&sla.lock);		if (ringing_trunk) {			answer_trunk_chan(ringing_trunk->trunk->chan);			sla_change_trunk_state(ringing_trunk->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);			free(ringing_trunk);			/* Queue up reprocessing ringing trunks, and then ringing stations again */			sla_queue_event(SLA_EVENT_RINGING_TRUNK);			sla_queue_event(SLA_EVENT_DIAL_STATE);		}	}	trunk_ref->chan = chan;	if (!trunk_ref->trunk->chan) {		ast_mutex_t cond_lock;		ast_cond_t cond;		pthread_t dont_care;		struct dial_trunk_args args = {			.trunk_ref = trunk_ref,			.station = station,			.cond_lock = &cond_lock,			.cond = &cond,		};		sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);		/* Create a thread to dial the trunk and dump it into the conference.		 * However, we want to wait until the trunk has been dialed and the		 * conference is created before continuing on here. */		ast_autoservice_start(chan);		ast_mutex_init(&cond_lock);		ast_cond_init(&cond, NULL);		ast_mutex_lock(&cond_lock);		ast_pthread_create_detached_background(&dont_care, NULL, dial_trunk, &args);		ast_cond_wait(&cond, &cond_lock);		ast_mutex_unlock(&cond_lock);		ast_mutex_destroy(&cond_lock);		ast_cond_destroy(&cond);		ast_autoservice_stop(chan);		if (!trunk_ref->trunk->chan) {			ast_debug(1, "Trunk didn't get created. chan: %lx\n", (long) trunk_ref->trunk->chan);			pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "CONGESTION");			sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_IDLE, ALL_TRUNK_REFS, NULL);			trunk_ref->chan = NULL;			ast_atomic_fetchadd_int((int *) &station->ref_count, -1);			sla_queue_event(SLA_EVENT_CHECK_RELOAD);			return 0;		}	}
char *station_name, *trunk_name;
char *station_name, *trunk_name;
char
*station_name
*
station_name
*trunk_name
*
trunk_name
struct sla_station *station;
struct sla_station *station;
struct sla_station
sla_station
*station
*
station
struct sla_trunk_ref *trunk_ref = NULL;
struct sla_trunk_ref *trunk_ref = NULL;
struct sla_trunk_ref
sla_trunk_ref
*trunk_ref = NULL
*
trunk_ref
= NULL
NULL
NULL
char conf_name[MAX_CONFNUM];
char conf_name[MAX_CONFNUM];
char
conf_name[MAX_CONFNUM]
conf_name
[MAX_CONFNUM]
MAX_CONFNUM
MAX_CONFNUM
struct ast_flags64 conf_flags = { 0 };
struct ast_flags64 conf_flags = { 0 };
struct ast_flags64
ast_flags64
conf_flags = { 0 }
conf_flags
= { 0 }
{ 0 }
0
struct ast_conference *conf;
struct ast_conference *conf;
struct ast_conference
ast_conference
*conf
*
conf
if (ast_strlen_zero(data)) {		ast_log(LOG_WARNING, "Invalid Arguments to SLAStation!\n");		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE");		return 0;	}
ast_strlen_zero(data)
ast_strlen_zero
ast_strlen_zero
data
data
{		ast_log(LOG_WARNING, "Invalid Arguments to SLAStation!\n");		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE");		return 0;	}
ast_log(LOG_WARNING, "Invalid Arguments to SLAStation!\n");
ast_log(LOG_WARNING, "Invalid Arguments to SLAStation!\n")
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"Invalid Arguments to SLAStation!\n"
pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE");
pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE")
pbx_builtin_setvar_helper
pbx_builtin_setvar_helper
chan
chan
"SLASTATION_STATUS"
"FAILURE"
return 0;
0
trunk_name = ast_strdupa(data);
trunk_name = ast_strdupa(data)
trunk_name
trunk_name
ast_strdupa(data)
ast_strdupa
ast_strdupa
data
data
station_name = strsep(&trunk_name, "_");
station_name = strsep(&trunk_name, "_")
station_name
station_name
strsep(&trunk_name, "_")
strsep
strsep
&trunk_name
trunk_name
trunk_name
"_"
if (ast_strlen_zero(station_name)) {		ast_log(LOG_WARNING, "Invalid Arguments to SLAStation!\n");		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE");		return 0;	}
ast_strlen_zero(station_name)
ast_strlen_zero
ast_strlen_zero
station_name
station_name
{		ast_log(LOG_WARNING, "Invalid Arguments to SLAStation!\n");		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE");		return 0;	}
ast_log(LOG_WARNING, "Invalid Arguments to SLAStation!\n");
ast_log(LOG_WARNING, "Invalid Arguments to SLAStation!\n")
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"Invalid Arguments to SLAStation!\n"
pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE");
pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE")
pbx_builtin_setvar_helper
pbx_builtin_setvar_helper
chan
chan
"SLASTATION_STATUS"
"FAILURE"
return 0;
0
AST_RWLIST_RDLOCK(&sla_stations);
AST_RWLIST_RDLOCK(&sla_stations);
AST_RWLIST_RDLOCK
AST_RWLIST_RDLOCK
(&sla_stations)
&sla_stations
&
sla_stations
station = sla_find_station(station_name);
station = sla_find_station(station_name)
station
station
sla_find_station(station_name)
sla_find_station
sla_find_station
station_name
station_name
if (station)		ast_atomic_fetchadd_int((int *) &station->ref_count, 1);
station
station
ast_atomic_fetchadd_int((int *) &station->ref_count, 1);
ast_atomic_fetchadd_int((int *) &station->ref_count, 1)
ast_atomic_fetchadd_int
ast_atomic_fetchadd_int
(int *) &station->ref_count
int *
int
*
*
&station->ref_count
station->ref_count
station
station
ref_count
1
AST_RWLIST_UNLOCK(&sla_stations);
AST_RWLIST_UNLOCK(&sla_stations)
AST_RWLIST_UNLOCK
AST_RWLIST_UNLOCK
&sla_stations
sla_stations
sla_stations
if (!station) {		ast_log(LOG_WARNING, "Station '%s' not found!\n", station_name);		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE");		sla_queue_event(SLA_EVENT_CHECK_RELOAD);		return 0;	}
!station
station
station
{		ast_log(LOG_WARNING, "Station '%s' not found!\n", station_name);		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE");		sla_queue_event(SLA_EVENT_CHECK_RELOAD);		return 0;	}
ast_log(LOG_WARNING, "Station '%s' not found!\n", station_name);
ast_log(LOG_WARNING, "Station '%s' not found!\n", station_name)
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"Station '%s' not found!\n"
station_name
station_name
pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE");
pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE")
pbx_builtin_setvar_helper
pbx_builtin_setvar_helper
chan
chan
"SLASTATION_STATUS"
"FAILURE"
sla_queue_event(SLA_EVENT_CHECK_RELOAD);
sla_queue_event(SLA_EVENT_CHECK_RELOAD);
sla_queue_event
sla_queue_event
(SLA_EVENT_CHECK_RELOAD)
SLA_EVENT_CHECK_RELOAD
SLA_EVENT_CHECK_RELOAD
return 0;
0
AST_RWLIST_RDLOCK(&sla_trunks);
AST_RWLIST_RDLOCK(&sla_trunks);
AST_RWLIST_RDLOCK
AST_RWLIST_RDLOCK
(&sla_trunks)
&sla_trunks
&
sla_trunks
if (!ast_strlen_zero(trunk_name)) {		trunk_ref = sla_find_trunk_ref_byname(station, trunk_name);	} else		trunk_ref = sla_choose_idle_trunk(station);
!ast_strlen_zero(trunk_name)
ast_strlen_zero(trunk_name)
ast_strlen_zero
ast_strlen_zero
trunk_name
trunk_name
{		trunk_ref = sla_find_trunk_ref_byname(station, trunk_name);	}
trunk_ref = sla_find_trunk_ref_byname(station, trunk_name);
trunk_ref = sla_find_trunk_ref_byname(station, trunk_name)
trunk_ref
trunk_ref
sla_find_trunk_ref_byname(station, trunk_name)
sla_find_trunk_ref_byname
sla_find_trunk_ref_byname
station
station
trunk_name
trunk_name
trunk_ref = sla_choose_idle_trunk(station);
trunk_ref = sla_choose_idle_trunk(station)
trunk_ref
trunk_ref
sla_choose_idle_trunk(station)
sla_choose_idle_trunk
sla_choose_idle_trunk
station
station
AST_RWLIST_UNLOCK(&sla_trunks);
AST_RWLIST_UNLOCK(&sla_trunks)
AST_RWLIST_UNLOCK
AST_RWLIST_UNLOCK
&sla_trunks
sla_trunks
sla_trunks
if (!trunk_ref) {		if (ast_strlen_zero(trunk_name))			ast_log(LOG_NOTICE, "No trunks available for call.\n");		else {			ast_log(LOG_NOTICE, "Can't join existing call on trunk "				"'%s' due to access controls.\n", trunk_name);		}		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "CONGESTION");		ast_atomic_fetchadd_int((int *) &station->ref_count, -1);		sla_queue_event(SLA_EVENT_CHECK_RELOAD);		return 0;	}
!trunk_ref
trunk_ref
trunk_ref
{		if (ast_strlen_zero(trunk_name))			ast_log(LOG_NOTICE, "No trunks available for call.\n");		else {			ast_log(LOG_NOTICE, "Can't join existing call on trunk "				"'%s' due to access controls.\n", trunk_name);		}		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "CONGESTION");		ast_atomic_fetchadd_int((int *) &station->ref_count, -1);		sla_queue_event(SLA_EVENT_CHECK_RELOAD);		return 0;	}
if (ast_strlen_zero(trunk_name))			ast_log(LOG_NOTICE, "No trunks available for call.\n");		else {			ast_log(LOG_NOTICE, "Can't join existing call on trunk "				"'%s' due to access controls.\n", trunk_name);		}
ast_strlen_zero(trunk_name)
ast_strlen_zero
ast_strlen_zero
trunk_name
trunk_name
ast_log(LOG_NOTICE, "No trunks available for call.\n");
ast_log(LOG_NOTICE, "No trunks available for call.\n")
ast_log
ast_log
LOG_NOTICE
LOG_NOTICE
"No trunks available for call.\n"
{			ast_log(LOG_NOTICE, "Can't join existing call on trunk "				"'%s' due to access controls.\n", trunk_name);		}
ast_log(LOG_NOTICE, "Can't join existing call on trunk "				"'%s' due to access controls.\n", trunk_name);
ast_log(LOG_NOTICE, "Can't join existing call on trunk "				"'%s' due to access controls.\n", trunk_name)
ast_log
ast_log
LOG_NOTICE
LOG_NOTICE
"Can't join existing call on trunk "				"'%s' due to access controls.\n"
trunk_name
trunk_name
pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "CONGESTION");
pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "CONGESTION")
pbx_builtin_setvar_helper
pbx_builtin_setvar_helper
chan
chan
"SLASTATION_STATUS"
"CONGESTION"
ast_atomic_fetchadd_int((int *) &station->ref_count, -1);
ast_atomic_fetchadd_int((int *) &station->ref_count, -1)
ast_atomic_fetchadd_int
ast_atomic_fetchadd_int
(int *) &station->ref_count
int *
int
*
*
&station->ref_count
station->ref_count
station
station
ref_count
-1
1
sla_queue_event(SLA_EVENT_CHECK_RELOAD);
sla_queue_event(SLA_EVENT_CHECK_RELOAD);
sla_queue_event
sla_queue_event
(SLA_EVENT_CHECK_RELOAD)
SLA_EVENT_CHECK_RELOAD
SLA_EVENT_CHECK_RELOAD
return 0;
0
if (trunk_ref->state == SLA_TRUNK_STATE_ONHOLD_BYME) {		if (ast_atomic_dec_and_test((int *) &trunk_ref->trunk->hold_stations) == 1)			sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);		else {			trunk_ref->state = SLA_TRUNK_STATE_UP;			ast_devstate_changed(AST_DEVICE_INUSE,				"SLA:%s_%s", station->name, trunk_ref->trunk->name);		}	} else if (trunk_ref->state == SLA_TRUNK_STATE_RINGING) {		struct sla_ringing_trunk *ringing_trunk;		ast_mutex_lock(&sla.lock);		AST_LIST_TRAVERSE_SAFE_BEGIN(&sla.ringing_trunks, ringing_trunk, entry) {			if (ringing_trunk->trunk == trunk_ref->trunk) {				AST_LIST_REMOVE_CURRENT(entry);				break;			}		}		AST_LIST_TRAVERSE_SAFE_END		ast_mutex_unlock(&sla.lock);		if (ringing_trunk) {			answer_trunk_chan(ringing_trunk->trunk->chan);			sla_change_trunk_state(ringing_trunk->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);			free(ringing_trunk);			/* Queue up reprocessing ringing trunks, and then ringing stations again */			sla_queue_event(SLA_EVENT_RINGING_TRUNK);			sla_queue_event(SLA_EVENT_DIAL_STATE);		}	}
trunk_ref->state == SLA_TRUNK_STATE_ONHOLD_BYME
trunk_ref->state
trunk_ref
trunk_ref
state
SLA_TRUNK_STATE_ONHOLD_BYME
SLA_TRUNK_STATE_ONHOLD_BYME
{		if (ast_atomic_dec_and_test((int *) &trunk_ref->trunk->hold_stations) == 1)			sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);		else {			trunk_ref->state = SLA_TRUNK_STATE_UP;			ast_devstate_changed(AST_DEVICE_INUSE,				"SLA:%s_%s", station->name, trunk_ref->trunk->name);		}	}
if (ast_atomic_dec_and_test((int *) &trunk_ref->trunk->hold_stations) == 1)			sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);		else {			trunk_ref->state = SLA_TRUNK_STATE_UP;			ast_devstate_changed(AST_DEVICE_INUSE,				"SLA:%s_%s", station->name, trunk_ref->trunk->name);		}
ast_atomic_dec_and_test((int *) &trunk_ref->trunk->hold_stations) == 1
ast_atomic_dec_and_test((int *) &trunk_ref->trunk->hold_stations)
ast_atomic_dec_and_test
ast_atomic_dec_and_test
(int *) &trunk_ref->trunk->hold_stations
int *
int
*
*
&trunk_ref->trunk->hold_stations
trunk_ref->trunk->hold_stations
trunk_ref->trunk
trunk_ref
trunk_ref
trunk
hold_stations
1
sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);
sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL)
sla_change_trunk_state
sla_change_trunk_state
trunk_ref->trunk
trunk_ref
trunk_ref
trunk
SLA_TRUNK_STATE_UP
SLA_TRUNK_STATE_UP
ALL_TRUNK_REFS
ALL_TRUNK_REFS
NULL
NULL
{			trunk_ref->state = SLA_TRUNK_STATE_UP;			ast_devstate_changed(AST_DEVICE_INUSE,				"SLA:%s_%s", station->name, trunk_ref->trunk->name);		}
trunk_ref->state = SLA_TRUNK_STATE_UP;
trunk_ref->state = SLA_TRUNK_STATE_UP
trunk_ref->state
trunk_ref
trunk_ref
state
SLA_TRUNK_STATE_UP
SLA_TRUNK_STATE_UP
ast_devstate_changed(AST_DEVICE_INUSE,				"SLA:%s_%s", station->name, trunk_ref->trunk->name);
ast_devstate_changed(AST_DEVICE_INUSE,				"SLA:%s_%s", station->name, trunk_ref->trunk->name)
ast_devstate_changed
ast_devstate_changed
AST_DEVICE_INUSE
AST_DEVICE_INUSE
"SLA:%s_%s"
station->name
station
station
name
trunk_ref->trunk->name
trunk_ref->trunk
trunk_ref
trunk_ref
trunk
name
if (trunk_ref->state == SLA_TRUNK_STATE_RINGING) {		struct sla_ringing_trunk *ringing_trunk;		ast_mutex_lock(&sla.lock);		AST_LIST_TRAVERSE_SAFE_BEGIN(&sla.ringing_trunks, ringing_trunk, entry) {			if (ringing_trunk->trunk == trunk_ref->trunk) {				AST_LIST_REMOVE_CURRENT(entry);				break;			}		}		AST_LIST_TRAVERSE_SAFE_END		ast_mutex_unlock(&sla.lock);		if (ringing_trunk) {			answer_trunk_chan(ringing_trunk->trunk->chan);			sla_change_trunk_state(ringing_trunk->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);			free(ringing_trunk);			/* Queue up reprocessing ringing trunks, and then ringing stations again */			sla_queue_event(SLA_EVENT_RINGING_TRUNK);			sla_queue_event(SLA_EVENT_DIAL_STATE);		}	}
trunk_ref->state == SLA_TRUNK_STATE_RINGING
trunk_ref->state
trunk_ref
trunk_ref
state
SLA_TRUNK_STATE_RINGING
SLA_TRUNK_STATE_RINGING
{		struct sla_ringing_trunk *ringing_trunk;		ast_mutex_lock(&sla.lock);		AST_LIST_TRAVERSE_SAFE_BEGIN(&sla.ringing_trunks, ringing_trunk, entry) {			if (ringing_trunk->trunk == trunk_ref->trunk) {				AST_LIST_REMOVE_CURRENT(entry);				break;			}		}		AST_LIST_TRAVERSE_SAFE_END		ast_mutex_unlock(&sla.lock);		if (ringing_trunk) {			answer_trunk_chan(ringing_trunk->trunk->chan);			sla_change_trunk_state(ringing_trunk->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);			free(ringing_trunk);			/* Queue up reprocessing ringing trunks, and then ringing stations again */			sla_queue_event(SLA_EVENT_RINGING_TRUNK);			sla_queue_event(SLA_EVENT_DIAL_STATE);		}	}
struct sla_ringing_trunk *ringing_trunk;
struct sla_ringing_trunk *ringing_trunk;
struct sla_ringing_trunk
sla_ringing_trunk
*ringing_trunk
*
ringing_trunk
ast_mutex_lock(&sla.lock);
ast_mutex_lock(&sla.lock)
ast_mutex_lock
ast_mutex_lock
&sla.lock
sla.lock
sla
sla
lock
AST_LIST_TRAVERSE_SAFE_BEGIN(&sla.ringing_trunks, ringing_trunk, entry)
AST_LIST_TRAVERSE_SAFE_BEGIN(&sla.ringing_trunks, ringing_trunk, entry)
AST_LIST_TRAVERSE_SAFE_BEGIN
AST_LIST_TRAVERSE_SAFE_BEGIN
&sla.ringing_trunks
sla.ringing_trunks
sla
sla
ringing_trunks
ringing_trunk
ringing_trunk
entry
entry
)
{			if (ringing_trunk->trunk == trunk_ref->trunk) {				AST_LIST_REMOVE_CURRENT(entry);				break;			}		}
if (ringing_trunk->trunk == trunk_ref->trunk) {				AST_LIST_REMOVE_CURRENT(entry);				break;			}
ringing_trunk->trunk == trunk_ref->trunk
ringing_trunk->trunk
ringing_trunk
ringing_trunk
trunk
trunk_ref->trunk
trunk_ref
trunk_ref
trunk
{				AST_LIST_REMOVE_CURRENT(entry);				break;			}
AST_LIST_REMOVE_CURRENT(entry);
AST_LIST_REMOVE_CURRENT(entry);
AST_LIST_REMOVE_CURRENT
AST_LIST_REMOVE_CURRENT
(entry)
entry
entry
break;
AST_LIST_TRAVERSE_SAFE_END		ast_mutex_unlock(&sla.lock);
AST_LIST_TRAVERSE_SAFE_END		ast_mutex_unlock(&sla.lock);
AST_LIST_TRAVERSE_SAFE_END
AST_LIST_TRAVERSE_SAFE_END
ast_mutex_unlock(&sla.lock)
ast_mutex_unlock
(&sla.lock)
&sla.lock
sla.lock
sla
sla
lock
if (ringing_trunk) {			answer_trunk_chan(ringing_trunk->trunk->chan);			sla_change_trunk_state(ringing_trunk->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);			free(ringing_trunk);			/* Queue up reprocessing ringing trunks, and then ringing stations again */			sla_queue_event(SLA_EVENT_RINGING_TRUNK);			sla_queue_event(SLA_EVENT_DIAL_STATE);		}
ringing_trunk
ringing_trunk
{			answer_trunk_chan(ringing_trunk->trunk->chan);			sla_change_trunk_state(ringing_trunk->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);			free(ringing_trunk);			/* Queue up reprocessing ringing trunks, and then ringing stations again */			sla_queue_event(SLA_EVENT_RINGING_TRUNK);			sla_queue_event(SLA_EVENT_DIAL_STATE);		}
answer_trunk_chan(ringing_trunk->trunk->chan);
answer_trunk_chan(ringing_trunk->trunk->chan)
answer_trunk_chan
answer_trunk_chan
ringing_trunk->trunk->chan
ringing_trunk->trunk
ringing_trunk
ringing_trunk
trunk
chan
sla_change_trunk_state(ringing_trunk->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);
sla_change_trunk_state(ringing_trunk->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL)
sla_change_trunk_state
sla_change_trunk_state
ringing_trunk->trunk
ringing_trunk
ringing_trunk
trunk
SLA_TRUNK_STATE_UP
SLA_TRUNK_STATE_UP
ALL_TRUNK_REFS
ALL_TRUNK_REFS
NULL
NULL
free(ringing_trunk);
free(ringing_trunk)
free
free
ringing_trunk
ringing_trunk
sla_queue_event(SLA_EVENT_RINGING_TRUNK);
sla_queue_event(SLA_EVENT_RINGING_TRUNK);
sla_queue_event
sla_queue_event
(SLA_EVENT_RINGING_TRUNK)
SLA_EVENT_RINGING_TRUNK
SLA_EVENT_RINGING_TRUNK
sla_queue_event(SLA_EVENT_DIAL_STATE);
sla_queue_event(SLA_EVENT_DIAL_STATE);
sla_queue_event
sla_queue_event
(SLA_EVENT_DIAL_STATE)
SLA_EVENT_DIAL_STATE
SLA_EVENT_DIAL_STATE
trunk_ref->chan = chan;
trunk_ref->chan = chan
trunk_ref->chan
trunk_ref
trunk_ref
chan
chan
chan
if (!trunk_ref->trunk->chan) {		ast_mutex_t cond_lock;		ast_cond_t cond;		pthread_t dont_care;		struct dial_trunk_args args = {			.trunk_ref = trunk_ref,			.station = station,			.cond_lock = &cond_lock,			.cond = &cond,		}
!trunk_ref->trunk->chan
trunk_ref->trunk->chan
trunk_ref->trunk
trunk_ref
trunk_ref
trunk
chan
{		ast_mutex_t cond_lock;		ast_cond_t cond;		pthread_t dont_care;		struct dial_trunk_args args = {			.trunk_ref = trunk_ref,			.station = station,			.cond_lock = &cond_lock,			.cond = &cond,		}
ast_mutex_t cond_lock;
ast_mutex_t cond_lock;
ast_mutex_t
ast_mutex_t
cond_lock
cond_lock
ast_cond_t cond;
ast_cond_t cond;
ast_cond_t
ast_cond_t
cond
cond
pthread_t dont_care;
pthread_t dont_care;
pthread_t
pthread_t
dont_care
dont_care
struct dial_trunk_args args = {			.trunk_ref = trunk_ref,			.station = station,			.cond_lock = &cond_lock,			.cond = &cond,
;
sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);
sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL)
sla_change_trunk_state
sla_change_trunk_state
trunk_ref->trunk
trunk_ref
trunk_ref
trunk
SLA_TRUNK_STATE_UP
SLA_TRUNK_STATE_UP
ALL_TRUNK_REFS
ALL_TRUNK_REFS
NULL
NULL
ast_autoservice_start(chan);
ast_autoservice_start(chan)
ast_autoservice_start
ast_autoservice_start
chan
chan
ast_mutex_init(&cond_lock);
ast_mutex_init(&cond_lock);
ast_mutex_init
ast_mutex_init
(&cond_lock)
&cond_lock
&
cond_lock
ast_cond_init(&cond, NULL);
ast_cond_init(&cond, NULL)
ast_cond_init
ast_cond_init
&cond
cond
cond
NULL
NULL
ast_mutex_lock(&cond_lock);
ast_mutex_lock(&cond_lock)
ast_mutex_lock
ast_mutex_lock
&cond_lock
cond_lock
cond_lock
ast_pthread_create_detached_background(&dont_care, NULL, dial_trunk, &args);
ast_pthread_create_detached_background(&dont_care, NULL, dial_trunk, &args)
ast_pthread_create_detached_background
ast_pthread_create_detached_background
&dont_care
dont_care
dont_care
NULL
NULL
dial_trunk
dial_trunk
&args
args
args
ast_cond_wait(&cond, &cond_lock);
ast_cond_wait(&cond, &cond_lock)
ast_cond_wait
ast_cond_wait
&cond
cond
cond
&cond_lock
cond_lock
cond_lock
ast_mutex_unlock(&cond_lock);
ast_mutex_unlock(&cond_lock)
ast_mutex_unlock
ast_mutex_unlock
&cond_lock
cond_lock
cond_lock
ast_mutex_destroy(&cond_lock);
ast_mutex_destroy(&cond_lock)
ast_mutex_destroy
ast_mutex_destroy
&cond_lock
cond_lock
cond_lock
ast_cond_destroy(&cond);
ast_cond_destroy(&cond);
ast_cond_destroy
ast_cond_destroy
(&cond)
&cond
&
cond
ast_autoservice_stop(chan);
ast_autoservice_stop(chan)
ast_autoservice_stop
ast_autoservice_stop
chan
chan
if (!trunk_ref->trunk->chan) {			ast_debug(1, "Trunk didn't get created. chan: %lx\n", (long) trunk_ref->trunk->chan);			pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "CONGESTION");			sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_IDLE, ALL_TRUNK_REFS, NULL);			trunk_ref->chan = NULL;			ast_atomic_fetchadd_int((int *) &station->ref_count, -1);			sla_queue_event(SLA_EVENT_CHECK_RELOAD);			return 0;		}
!trunk_ref->trunk->chan
trunk_ref->trunk->chan
trunk_ref->trunk
trunk_ref
trunk_ref
trunk
chan
{			ast_debug(1, "Trunk didn't get created. chan: %lx\n", (long) trunk_ref->trunk->chan);			pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "CONGESTION");			sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_IDLE, ALL_TRUNK_REFS, NULL);			trunk_ref->chan = NULL;			ast_atomic_fetchadd_int((int *) &station->ref_count, -1);			sla_queue_event(SLA_EVENT_CHECK_RELOAD);			return 0;		}
ast_debug(1, "Trunk didn't get created. chan: %lx\n", (long) trunk_ref->trunk->chan);
ast_debug(1, "Trunk didn't get created. chan: %lx\n", (long) trunk_ref->trunk->chan)
ast_debug
ast_debug
1
"Trunk didn't get created. chan: %lx\n"
(long) trunk_ref->trunk->chan
long
long

trunk_ref->trunk->chan
trunk_ref->trunk
trunk_ref
trunk_ref
trunk
chan
pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "CONGESTION");
pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "CONGESTION")
pbx_builtin_setvar_helper
pbx_builtin_setvar_helper
chan
chan
"SLASTATION_STATUS"
"CONGESTION"
sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_IDLE, ALL_TRUNK_REFS, NULL);
sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_IDLE, ALL_TRUNK_REFS, NULL)
sla_change_trunk_state
sla_change_trunk_state
trunk_ref->trunk
trunk_ref
trunk_ref
trunk
SLA_TRUNK_STATE_IDLE
SLA_TRUNK_STATE_IDLE
ALL_TRUNK_REFS
ALL_TRUNK_REFS
NULL
NULL
trunk_ref->chan = NULL;
trunk_ref->chan = NULL
trunk_ref->chan
trunk_ref
trunk_ref
chan
NULL
NULL
ast_atomic_fetchadd_int((int *) &station->ref_count, -1);
ast_atomic_fetchadd_int((int *) &station->ref_count, -1)
ast_atomic_fetchadd_int
ast_atomic_fetchadd_int
(int *) &station->ref_count
int *
int
*
*
&station->ref_count
station->ref_count
station
station
ref_count
-1
1
sla_queue_event(SLA_EVENT_CHECK_RELOAD);
sla_queue_event(SLA_EVENT_CHECK_RELOAD);
sla_queue_event
sla_queue_event
(SLA_EVENT_CHECK_RELOAD)
SLA_EVENT_CHECK_RELOAD
SLA_EVENT_CHECK_RELOAD
return 0;
0
-----joern-----
(316,430,0)
(31,196,0)
(356,141,0)
(436,141,0)
(489,210,0)
(436,251,0)
(53,152,0)
(309,438,0)
(289,367,0)
(317,436,0)
(152,53,0)
(155,18,0)
(154,29,0)
(395,24,0)
(24,395,0)
(455,171,0)
(127,65,0)
(269,354,0)
(300,280,0)
(8,440,0)
(302,255,0)
(304,299,0)
(80,29,0)
(262,85,0)
(343,474,0)
(161,352,0)
(381,240,0)
(291,298,0)
(219,92,0)
(404,432,0)
(185,196,0)
(246,161,0)
(135,351,0)
(239,115,0)
(108,75,0)
(16,275,0)
(92,219,0)
(68,197,0)
(434,95,0)
(488,285,0)
(305,388,0)
(222,28,0)
(372,274,0)
(256,437,0)
(310,389,0)
(70,213,0)
(338,178,0)
(14,298,0)
(483,479,0)
(376,126,0)
(340,95,0)
(310,115,0)
(143,389,0)
(431,443,0)
(342,374,0)
(26,433,0)
(361,345,0)
(220,443,0)
(399,432,0)
(460,437,0)
(350,347,0)
(207,476,0)
(43,436,0)
(330,278,0)
(185,194,0)
(126,333,0)
(211,115,0)
(257,268,0)
(94,230,0)
(82,103,0)
(382,334,0)
(52,178,0)
(122,159,0)
(5,278,0)
(446,445,0)
(199,178,0)
(20,441,0)
(445,458,0)
(31,121,0)
(336,141,0)
(24,345,0)
(99,214,0)
(433,26,0)
(170,34,0)
(11,141,0)
(149,141,0)
(167,370,0)
(353,264,0)
(269,334,0)
(319,298,0)
(471,443,0)
(166,394,0)
(206,152,0)
(150,272,0)
(264,298,0)
(48,289,0)
(91,450,0)
(260,92,0)
(473,378,0)
(391,325,0)
(318,71,0)
(47,156,0)
(477,115,0)
(55,40,0)
(251,418,0)
(27,181,0)
(432,66,0)
(55,230,0)
(352,161,0)
(341,359,0)
(343,273,0)
(165,135,0)
(229,304,0)
(324,29,0)
(334,274,0)
(124,289,0)
(338,375,0)
(319,156,0)
(386,141,0)
(253,322,0)
(53,29,0)
(412,305,0)
(243,98,0)
(485,409,0)
(370,277,0)
(473,476,0)
(233,486,0)
(339,278,0)
(405,458,0)
(193,309,0)
(407,153,0)
(445,435,0)
(107,266,0)
(161,405,0)
(440,282,0)
(417,234,0)
(285,115,0)
(288,298,0)
(377,399,0)
(475,43,0)
(310,458,0)
(6,86,0)
(66,266,0)
(332,486,0)
(215,67,0)
(263,101,0)
(266,66,0)
(208,474,0)
(348,291,0)
(128,264,0)
(279,141,0)
(244,437,0)
(481,294,0)
(473,329,0)
(137,441,0)
(318,394,0)
(181,27,0)
(467,317,0)
(2,319,0)
(388,305,0)
(86,370,0)
(345,361,0)
(277,140,0)
(389,369,0)
(258,354,0)
(90,141,0)
(408,393,0)
(85,240,0)
(402,92,0)
(196,360,0)
(417,262,0)
(236,436,0)
(327,141,0)
(5,76,0)
(295,174,0)
(304,458,0)
(86,248,0)
(432,399,0)
(462,477,0)
(40,55,0)
(135,165,0)
(385,234,0)
(445,115,0)
(118,435,0)
(276,308,0)
(367,115,0)
(288,141,0)
(312,47,0)
(397,304,0)
(296,115,0)
(126,306,0)
(173,470,0)
(37,310,0)
(97,210,0)
(249,266,0)
(321,291,0)
(142,294,0)
(12,378,0)
(433,418,0)
(454,311,0)
(45,141,0)
(34,29,0)
(375,338,0)
(328,171,0)
(32,458,0)
(474,460,0)
(456,292,0)
(187,292,0)
(278,458,0)
(461,239,0)
(473,86,0)
(355,141,0)
(466,254,0)
(87,31,0)
(378,174,0)
(113,291,0)
(351,135,0)
(92,402,0)
(371,405,0)
(42,351,0)
(205,460,0)
(367,289,0)
(473,308,0)
(294,436,0)
(292,456,0)
(204,333,0)
(379,127,0)
(296,114,0)
(120,437,0)
(299,304,0)
(380,319,0)
(423,325,0)
(425,284,0)
(378,309,0)
(245,438,0)
(361,436,0)
(189,317,0)
(212,437,0)
(30,24,0)
(487,30,0)
(81,3,0)
(194,134,0)
(237,319,0)
(180,141,0)
(226,288,0)
(234,458,0)
(420,39,0)
(326,250,0)
(191,121,0)
(49,213,0)
(264,159,0)
(427,194,0)
(248,458,0)
(459,215,0)
(103,109,0)
(145,431,0)
(314,456,0)
(171,322,0)
(369,389,0)
(13,119,0)
(478,141,0)
(274,115,0)
(174,28,0)
(136,297,0)
(179,141,0)
(490,122,0)
(387,211,0)
(473,409,0)
(44,273,0)
(324,285,0)
(452,398,0)
(474,343,0)
(144,366,0)
(425,115,0)
(134,115,0)
(85,262,0)
(72,5,0)
(456,314,0)
(61,153,0)
(307,405,0)
(439,269,0)
(3,115,0)
(164,274,0)
(225,92,0)
(329,71,0)
(180,393,0)
(211,458,0)
(104,81,0)
(411,169,0)
(60,264,0)
(334,269,0)
(284,479,0)
(333,126,0)
(250,477,0)
(266,115,0)
(57,450,0)
(364,141,0)
(114,298,0)
(234,277,0)
(474,298,0)
(457,56,0)
(309,239,0)
(322,171,0)
(63,215,0)
(322,401,0)
(174,115,0)
(88,418,0)
(190,213,0)
(388,29,0)
(418,141,0)
(112,480,0)
(265,361,0)
(116,410,0)
(18,80,0)
(232,364,0)
(134,194,0)
(7,40,0)
(114,141,0)
(129,433,0)
(54,296,0)
(415,474,0)
(360,196,0)
(301,398,0)
(405,115,0)
(34,298,0)
(266,458,0)
(210,215,0)
(221,296,0)
(151,356,0)
(271,148,0)
(111,275,0)
(366,458,0)
(251,436,0)
(234,115,0)
(21,122,0)
(345,24,0)
(230,55,0)
(23,437,0)
(401,322,0)
(299,197,0)
(84,324,0)
(482,186,0)
(250,411,0)
(406,437,0)
(373,445,0)
(240,381,0)
(231,289,0)
(86,156,0)
(75,56,0)
(325,375,0)
(269,439,0)
(296,458,0)
(268,41,0)
(362,141,0)
(123,465,0)
(227,69,0)
(218,77,0)
(230,76,0)
(227,180,0)
(36,477,0)
(75,458,0)
(73,134,0)
(285,324,0)
(80,18,0)
(410,464,0)
(317,443,0)
(468,324,0)
(224,441,0)
(476,159,0)
(174,458,0)
(148,458,0)
(291,464,0)
(306,169,0)
(74,141,0)
(398,298,0)
(428,460,0)
(131,5,0)
(255,71,0)
(323,3,0)
(274,334,0)
(477,458,0)
(187,435,0)
(458,317,0)
(378,296,0)
(64,80,0)
(262,417,0)
(55,39,0)
(147,292,0)
(374,141,0)
(378,141,0)
(315,101,0)
(400,437,0)
(351,50,0)
(450,153,0)
(344,197,0)
(294,142,0)
(441,20,0)
(112,318,0)
(14,29,0)
(254,466,0)
(418,433,0)
(390,115,0)
(429,29,0)
(188,215,0)
(65,121,0)
(158,343,0)
(95,76,0)
(347,336,0)
(184,67,0)
(138,417,0)
(233,29,0)
(432,141,0)
(451,277,0)
(112,142,0)
(281,407,0)
(202,230,0)
(278,115,0)
(384,436,0)
(77,436,0)
(217,294,0)
(111,141,0)
(358,285,0)
(214,211,0)
(284,425,0)
(444,413,0)
(378,126,0)
(10,29,0)
(346,141,0)
(209,236,0)
(425,458,0)
(105,178,0)
(192,29,0)
(0,374,0)
(203,165,0)
(32,127,0)
(177,20,0)
(435,445,0)
(186,482,0)
(374,298,0)
(241,66,0)
(66,432,0)
(383,425,0)
(430,316,0)
(378,370,0)
(92,29,0)
(75,115,0)
(223,479,0)
(109,103,0)
(9,200,0)
(157,56,0)
(315,141,0)
(227,430,0)
(26,443,0)
(214,93,0)
(313,29,0)
(213,235,0)
(369,240,0)
(443,141,0)
(39,55,0)
(275,111,0)
(196,185,0)
(261,251,0)
(449,450,0)
(175,61,0)
(133,453,0)
(365,306,0)
(354,156,0)
(101,315,0)
(160,67,0)
(368,29,0)
(450,298,0)
(359,418,0)
(248,470,0)
(370,458,0)
(77,115,0)
(3,81,0)
(125,133,0)
(32,115,0)
(69,227,0)
(349,61,0)
(50,141,0)
(414,184,0)
(24,30,0)
(115,77,0)
(216,410,0)
(194,185,0)
(308,464,0)
(100,411,0)
(102,311,0)
(117,329,0)
(303,182,0)
(43,475,0)
(50,351,0)
(293,174,0)
(220,242,0)
(61,418,0)
(20,458,0)
(357,441,0)
(25,324,0)
(398,71,0)
(142,112,0)
(39,200,0)
(366,115,0)
(59,432,0)
(274,458,0)
(477,250,0)
(280,156,0)
(195,186,0)
(3,458,0)
(426,134,0)
(419,20,0)
(463,27,0)
(311,197,0)
(86,296,0)
(200,39,0)
(22,367,0)
(148,465,0)
(292,187,0)
(466,280,0)
(211,214,0)
(335,299,0)
(134,458,0)
(331,43,0)
(182,273,0)
(466,475,0)
(318,112,0)
(121,65,0)
(292,147,0)
(89,14,0)
(333,458,0)
(375,325,0)
(443,119,0)
(62,5,0)
(181,29,0)
(442,402,0)
(396,316,0)
(435,187,0)
(180,227,0)
(198,67,0)
(289,169,0)
(469,135,0)
(1,61,0)
(437,460,0)
(56,75,0)
(168,133,0)
(196,31,0)
(139,26,0)
(421,141,0)
(460,141,0)
(484,333,0)
(367,458,0)
(51,211,0)
(50,182,0)
(182,50,0)
(297,313,0)
(393,180,0)
(354,269,0)
(337,437,0)
(247,310,0)
(65,127,0)
(409,153,0)
(46,132,0)
(197,311,0)
(252,41,0)
(132,53,0)
(267,314,0)
(458,286,0)
(119,443,0)
(280,466,0)
(127,32,0)
(403,248,0)
(56,156,0)
(482,29,0)
(465,148,0)
(213,443,0)
(438,76,0)
(201,398,0)
(437,298,0)
(19,239,0)
(479,284,0)
(290,141,0)
(389,310,0)
(474,453,0)
(313,297,0)
(197,299,0)
(448,316,0)
(317,458,0)
(119,282,0)
(392,370,0)
(285,458,0)
(239,309,0)
(148,115,0)
(172,32,0)
(162,367,0)
(428,453,0)
(240,369,0)
(106,474,0)
(430,227,0)
(53,132,0)
(38,458,0)
(394,318,0)
(83,198,0)
(234,417,0)
(109,141,0)
(238,75,0)
(78,148,0)
(311,436,0)
(242,220,0)
(20,115,0)
(79,141,0)
(15,32,0)
(93,214,0)
(183,160,0)
(33,300,0)
(121,31,0)
(320,361,0)
(58,220,0)
(280,300,0)
(472,234,0)
(176,141,0)
(240,85,0)
(197,140,0)
(405,161,0)
(401,67,0)
(273,141,0)
(304,115,0)
(163,354,0)
(470,156,0)
(270,219,0)
(17,272,0)
(259,374,0)
(110,141,0)
(363,56,0)
(316,436,0)
(278,5,0)
(416,364,0)
(146,248,0)
(35,428,0)
(486,233,0)
(370,115,0)
(239,458,0)
(411,250,0)
(4,43,0)
(228,165,0)
(98,178,0)
(475,466,0)
(336,347,0)
(96,114,0)
(215,210,0)
(422,71,0)
(28,141,0)
(333,115,0)
(480,112,0)
(248,115,0)
(424,425,0)
(287,3,0)
(438,245,1)
(202,262,1)
(335,304,1)
(304,458,1)
(207,264,1)
(412,482,1)
(68,344,1)
(262,417,1)
(1,349,1)
(314,456,1)
(196,185,1)
(123,148,1)
(455,328,1)
(266,115,1)
(274,115,1)
(85,240,1)
(271,366,1)
(276,291,1)
(205,288,1)
(411,100,1)
(17,431,1)
(311,436,1)
(426,93,1)
(333,204,1)
(20,115,1)
(252,268,1)
(114,96,1)
(389,310,1)
(361,436,1)
(2,237,1)
(96,296,1)
(333,115,1)
(432,399,1)
(260,219,1)
(37,28,1)
(353,60,1)
(121,31,1)
(14,298,1)
(245,309,1)
(100,250,1)
(407,281,1)
(87,196,1)
(278,115,1)
(379,32,1)
(457,75,1)
(198,83,1)
(120,406,1)
(299,304,1)
(65,127,1)
(0,262,1)
(236,209,1)
(428,35,1)
(197,299,1)
(431,145,1)
(336,347,1)
(378,296,1)
(428,460,1)
(119,282,1)
(476,207,1)
(4,470,1)
(20,419,1)
(397,229,1)
(203,228,1)
(238,108,1)
(488,93,1)
(210,489,1)
(16,359,1)
(19,95,1)
(291,321,1)
(125,168,1)
(278,458,1)
(405,115,1)
(257,284,1)
(187,435,1)
(366,144,1)
(102,454,1)
(174,293,1)
(50,182,1)
(234,385,1)
(265,320,1)
(383,424,1)
(486,332,1)
(177,314,1)
(234,277,1)
(358,488,1)
(242,220,1)
(302,318,1)
(8,273,1)
(402,442,1)
(396,448,1)
(124,367,1)
(18,155,1)
(305,412,1)
(473,409,1)
(474,415,1)
(24,345,1)
(294,436,1)
(263,115,1)
(25,468,1)
(161,246,1)
(394,166,1)
(366,115,1)
(423,391,1)
(173,248,1)
(378,12,1)
(264,353,1)
(23,244,1)
(55,40,1)
(107,404,1)
(370,458,1)
(34,298,1)
(131,278,1)
(392,314,1)
(477,36,1)
(322,253,1)
(75,458,1)
(296,115,1)
(128,122,1)
(285,115,1)
(268,257,1)
(281,450,1)
(47,312,1)
(273,44,1)
(483,338,1)
(188,210,1)
(75,115,1)
(54,160,1)
(410,216,1)
(3,115,1)
(389,143,1)
(474,460,1)
(461,19,1)
(31,87,1)
(432,66,1)
(359,418,1)
(448,374,1)
(136,14,1)
(414,198,1)
(81,104,1)
(213,70,1)
(250,477,1)
(361,265,1)
(58,109,1)
(43,436,1)
(9,40,1)
(251,418,1)
(239,461,1)
(148,115,1)
(427,134,1)
(350,447,1)
(0,5,1)
(456,292,1)
(367,162,1)
(194,134,1)
(91,57,1)
(289,48,1)
(468,84,1)
(322,171,1)
(223,483,1)
(417,138,1)
(224,137,1)
(357,224,1)
(59,289,1)
(376,333,1)
(317,443,1)
(263,458,1)
(403,56,1)
(40,7,1)
(155,313,1)
(12,356,1)
(215,63,1)
(339,330,1)
(356,151,1)
(375,325,1)
(54,441,1)
(269,334,1)
(30,24,1)
(246,405,1)
(227,69,1)
(309,193,1)
(14,89,1)
(372,164,1)
(324,285,1)
(161,405,1)
(320,447,1)
(126,376,1)
(38,242,1)
(46,152,1)
(426,352,1)
(405,307,1)
(473,308,1)
(274,458,1)
(53,132,1)
(248,146,1)
(31,196,1)
(182,303,1)
(337,256,1)
(280,300,1)
(222,174,1)
(316,436,1)
(93,214,1)
(269,439,1)
(350,30,1)
(28,222,1)
(137,20,1)
(247,37,1)
(441,20,1)
(227,430,1)
(103,82,1)
(66,241,1)
(387,114,1)
(334,382,1)
(435,118,1)
(57,61,1)
(404,399,1)
(351,135,1)
(130,284,1)
(489,97,1)
(272,150,1)
(445,458,1)
(146,403,1)
(377,59,1)
(266,458,1)
(374,259,1)
(250,326,1)
(215,210,1)
(459,188,1)
(167,392,1)
(64,18,1)
(239,458,1)
(132,46,1)
(450,449,1)
(316,396,1)
(399,377,1)
(458,317,1)
(66,266,1)
(284,425,1)
(473,86,1)
(86,6,1)
(425,458,1)
(208,106,1)
(190,431,1)
(311,102,1)
(445,115,1)
(36,462,1)
(378,126,1)
(109,103,1)
(32,15,1)
(425,115,1)
(352,161,1)
(34,170,1)
(86,370,1)
(415,343,1)
(370,115,1)
(301,201,1)
(382,274,1)
(267,456,1)
(309,239,1)
(289,367,1)
(54,197,1)
(433,129,1)
(185,194,1)
(5,72,1)
(348,410,1)
(259,342,1)
(97,401,1)
(313,297,1)
(310,247,1)
(420,200,1)
(378,309,1)
(319,2,1)
(206,92,1)
(449,91,1)
(270,233,1)
(49,190,1)
(409,485,1)
(347,350,1)
(248,115,1)
(333,458,1)
(318,394,1)
(42,182,1)
(166,112,1)
(61,418,1)
(214,99,1)
(231,124,1)
(300,33,1)
(373,465,1)
(239,115,1)
(283,460,1)
(332,80,1)
(112,142,1)
(465,148,1)
(163,352,1)
(345,361,1)
(364,416,1)
(26,139,1)
(95,434,1)
(393,408,1)
(384,111,1)
(200,9,1)
(262,85,1)
(401,322,1)
(484,65,1)
(315,101,1)
(317,436,1)
(81,3,1)
(419,177,1)
(135,165,1)
(400,23,1)
(329,117,1)
(434,340,1)
(211,115,1)
(378,370,1)
(220,443,1)
(3,287,1)
(89,324,1)
(20,458,1)
(211,458,1)
(226,50,1)
(479,223,1)
(323,465,1)
(183,184,1)
(59,65,1)
(86,296,1)
(55,39,1)
(150,17,1)
(13,471,1)
(216,116,1)
(126,333,1)
(304,397,1)
(363,157,1)
(53,152,1)
(237,380,1)
(443,119,1)
(213,443,1)
(430,316,1)
(83,215,1)
(62,131,1)
(219,270,1)
(127,379,1)
(218,390,1)
(21,359,1)
(435,445,1)
(94,202,1)
(482,186,1)
(39,200,1)
(112,480,1)
(113,348,1)
(234,458,1)
(60,128,1)
(288,298,1)
(359,341,1)
(234,115,1)
(275,16,1)
(3,458,1)
(258,163,1)
(50,351,1)
(349,236,1)
(306,365,1)
(148,458,1)
(240,381,1)
(212,120,1)
(56,75,1)
(22,411,1)
(261,384,1)
(378,174,1)
(431,443,1)
(82,236,1)
(441,357,1)
(481,217,1)
(266,249,1)
(471,440,1)
(225,260,1)
(129,26,1)
(134,458,1)
(172,121,1)
(466,475,1)
(118,445,1)
(175,1,1)
(390,242,1)
(264,298,1)
(321,113,1)
(477,458,1)
(365,126,1)
(117,255,1)
(77,436,1)
(324,25,1)
(473,378,1)
(181,27,1)
(295,283,1)
(233,486,1)
(295,133,1)
(288,226,1)
(416,232,1)
(26,443,1)
(15,172,1)
(196,360,1)
(248,458,1)
(473,476,1)
(450,298,1)
(340,230,1)
(446,373,1)
(442,225,1)
(251,261,1)
(436,251,1)
(144,315,1)
(80,18,1)
(344,277,1)
(221,54,1)
(462,306,1)
(6,47,1)
(27,463,1)
(310,115,1)
(197,311,1)
(80,64,1)
(48,231,1)
(385,472,1)
(241,266,1)
(84,285,1)
(174,458,1)
(204,484,1)
(39,420,1)
(342,0,1)
(341,418,1)
(145,366,1)
(114,298,1)
(134,115,1)
(287,323,1)
(370,167,1)
(30,487,1)
(310,458,1)
(308,276,1)
(304,115,1)
(33,466,1)
(236,436,1)
(92,219,1)
(454,68,1)
(255,302,1)
(424,479,1)
(61,175,1)
(406,400,1)
(367,458,1)
(437,298,1)
(170,388,1)
(380,354,1)
(182,273,1)
(106,283,1)
(193,239,1)
(164,258,1)
(256,205,1)
(111,275,1)
(326,477,1)
(437,212,1)
(143,310,1)
(116,440,1)
(303,432,1)
(139,88,1)
(391,81,1)
(174,115,1)
(325,423,1)
(220,58,1)
(65,121,1)
(152,206,1)
(469,42,1)
(130,252,1)
(465,123,1)
(151,180,1)
(296,221,1)
(343,273,1)
(445,446,1)
(127,32,1)
(99,211,1)
(425,383,1)
(293,295,1)
(278,339,1)
(331,4,1)
(158,208,1)
(307,371,1)
(487,24,1)
(186,195,1)
(56,363,1)
(230,55,1)
(253,171,1)
(474,343,1)
(417,234,1)
(77,218,1)
(292,147,1)
(354,269,1)
(201,213,1)
(44,364,1)
(398,452,1)
(240,369,1)
(54,130,1)
(451,370,1)
(299,335,1)
(157,457,1)
(473,329,1)
(160,183,1)
(490,21,1)
(466,254,1)
(367,115,1)
(92,402,1)
(388,305,1)
(122,490,1)
(32,458,1)
(191,31,1)
(463,53,1)
(292,187,1)
(328,130,1)
(440,282,1)
(244,337,1)
(474,298,1)
(405,458,1)
(291,298,1)
(184,414,1)
(88,443,1)
(297,136,1)
(201,272,1)
(115,77,1)
(318,112,1)
(7,94,1)
(317,467,1)
(165,203,1)
(274,372,1)
(330,438,1)
(228,469,1)
(54,81,1)
(134,73,1)
(119,13,1)
(195,181,1)
(314,267,1)
(294,481,1)
(211,51,1)
(312,280,1)
(284,479,1)
(72,62,1)
(162,22,1)
(217,398,1)
(5,278,1)
(86,248,1)
(366,458,1)
(104,3,1)
(285,458,1)
(338,375,1)
(168,428,1)
(63,459,1)
(78,271,1)
(475,43,1)
(138,234,1)
(43,331,1)
(371,34,1)
(24,395,1)
(142,294,1)
(277,451,1)
(171,455,1)
(470,173,1)
(180,227,1)
(398,298,1)
(229,311,1)
(319,298,1)
(75,238,1)
(194,427,1)
(408,227,1)
(209,336,1)
(418,433,1)
(280,466,1)
(70,49,1)
(411,250,1)
(334,274,1)
(374,298,1)
(35,474,1)
(51,387,1)
(189,38,1)
(249,107,1)
(467,189,1)
(214,211,1)
(285,358,1)
(180,393,1)
(447,436,1)
(73,426,1)
(121,191,1)
(477,115,1)
(485,407,1)
(343,158,1)
(452,301,1)
(32,115,1)
(108,319,1)
(101,263,1)
(440,8,1)
(296,458,1)
(369,389,1)
(460,437,1)
(148,78,1)
(133,125,1)
(472,85,1)
(433,26,1)
(196,360,2)
(328,130,2)
(351,352,2)
(234,85,2)
(310,352,2)
(227,69,2)
(115,242,2)
(407,236,2)
(214,211,2)
(375,81,2)
(102,314,2)
(138,85,2)
(291,440,2)
(441,314,2)
(187,435,2)
(24,395,2)
(280,466,2)
(314,456,2)
(197,299,2)
(165,93,2)
(205,352,2)
(417,85,2)
(49,431,2)
(150,431,2)
(306,65,2)
(342,352,2)
(113,440,2)
(458,317,2)
(488,93,2)
(148,458,2)
(163,352,2)
(196,93,2)
(4,352,2)
(366,115,2)
(205,93,2)
(14,298,2)
(296,366,2)
(6,352,2)
(233,93,2)
(443,119,2)
(482,186,2)
(182,352,2)
(65,352,2)
(436,359,2)
(43,436,2)
(22,65,2)
(146,352,2)
(262,417,2)
(135,165,2)
(458,242,2)
(114,366,2)
(370,458,2)
(195,93,2)
(399,93,2)
(220,236,2)
(319,298,2)
(234,115,2)
(14,93,2)
(317,436,2)
(270,93,2)
(256,352,2)
(471,440,2)
(119,282,2)
(39,200,2)
(107,352,2)
(369,352,2)
(180,93,2)
(300,352,2)
(465,148,2)
(190,431,2)
(7,262,2)
(21,359,2)
(321,440,2)
(247,352,2)
(405,458,2)
(432,399,2)
(81,3,2)
(278,262,2)
(234,277,2)
(93,214,2)
(467,242,2)
(72,262,2)
(303,93,2)
(249,93,2)
(142,366,2)
(314,465,2)
(269,439,2)
(378,93,2)
(389,310,2)
(316,352,2)
(2,352,2)
(367,458,2)
(469,352,2)
(58,236,2)
(316,93,2)
(222,93,2)
(124,65,2)
(48,65,2)
(307,93,2)
(313,297,2)
(311,314,2)
(292,187,2)
(430,352,2)
(454,314,2)
(134,458,2)
(377,352,2)
(53,93,2)
(460,352,2)
(180,227,2)
(260,93,2)
(206,93,2)
(216,440,2)
(317,242,2)
(167,314,2)
(474,298,2)
(15,121,2)
(158,283,2)
(472,85,2)
(111,275,2)
(271,366,2)
(92,93,2)
(87,93,2)
(389,93,2)
(400,352,2)
(240,93,2)
(23,352,2)
(73,93,2)
(384,359,2)
(184,130,2)
(408,93,2)
(356,93,2)
(378,296,2)
(89,93,2)
(277,314,2)
(248,352,2)
(75,115,2)
(445,465,2)
(61,418,2)
(432,93,2)
(401,322,2)
(220,443,2)
(112,142,2)
(266,115,2)
(148,366,2)
(463,93,2)
(94,262,2)
(191,93,2)
(452,366,2)
(366,236,2)
(87,352,2)
(242,220,2)
(36,65,2)
(130,81,2)
(310,458,2)
(137,314,2)
(343,283,2)
(423,81,2)
(403,352,2)
(357,314,2)
(80,18,2)
(35,283,2)
(457,352,2)
(123,366,2)
(331,352,2)
(369,389,2)
(211,115,2)
(175,236,2)
(391,81,2)
(430,93,2)
(297,93,2)
(164,352,2)
(285,458,2)
(284,81,2)
(475,43,2)
(473,308,2)
(342,93,2)
(269,352,2)
(299,314,2)
(388,93,2)
(431,443,2)
(97,130,2)
(155,93,2)
(85,352,2)
(70,431,2)
(31,352,2)
(134,352,2)
(269,334,2)
(266,93,2)
(114,298,2)
(230,262,2)
(227,430,2)
(490,359,2)
(193,262,2)
(127,32,2)
(182,273,2)
(42,352,2)
(180,352,2)
(310,115,2)
(244,93,2)
(242,236,2)
(84,93,2)
(95,262,2)
(412,93,2)
(66,93,2)
(77,242,2)
(387,366,2)
(223,81,2)
(283,93,2)
(101,236,2)
(152,93,2)
(356,352,2)
(20,115,2)
(481,366,2)
(354,352,2)
(236,359,2)
(252,284,2)
(37,93,2)
(168,283,2)
(313,93,2)
(240,381,2)
(424,81,2)
(12,93,2)
(333,65,2)
(117,366,2)
(470,352,2)
(455,130,2)
(161,93,2)
(115,77,2)
(215,130,2)
(26,443,2)
(47,352,2)
(30,24,2)
(170,93,2)
(405,93,2)
(177,314,2)
(188,130,2)
(294,366,2)
(389,352,2)
(186,93,2)
(75,352,2)
(185,93,2)
(214,366,2)
(151,352,2)
(448,352,2)
(473,86,2)
(437,298,2)
(433,440,2)
(50,182,2)
(406,352,2)
(32,121,2)
(217,366,2)
(292,465,2)
(85,240,2)
(406,93,2)
(151,93,2)
(93,366,2)
(280,300,2)
(289,367,2)
(65,93,2)
(28,352,2)
(125,283,2)
(450,298,2)
(474,343,2)
(465,366,2)
(226,352,2)
(473,409,2)
(288,93,2)
(103,236,2)
(281,236,2)
(289,65,2)
(181,93,2)
(262,352,2)
(350,359,2)
(236,436,2)
(135,93,2)
(311,436,2)
(228,93,2)
(293,352,2)
(26,440,2)
(460,437,2)
(445,458,2)
(343,273,2)
(34,93,2)
(12,352,2)
(310,93,2)
(366,458,2)
(128,359,2)
(145,366,2)
(165,352,2)
(398,366,2)
(142,294,2)
(194,93,2)
(16,359,2)
(233,486,2)
(349,236,2)
(322,171,2)
(119,440,2)
(399,352,2)
(78,366,2)
(189,242,2)
(24,345,2)
(378,370,2)
(43,352,2)
(285,115,2)
(344,314,2)
(80,93,2)
(396,93,2)
(135,352,2)
(126,65,2)
(456,465,2)
(352,161,2)
(191,352,2)
(55,40,2)
(61,236,2)
(24,447,2)
(197,314,2)
(333,115,2)
(398,298,2)
(462,65,2)
(425,115,2)
(363,352,2)
(253,130,2)
(27,93,2)
(483,81,2)
(419,314,2)
(288,298,2)
(308,440,2)
(482,93,2)
(393,352,2)
(264,359,2)
(55,262,2)
(112,366,2)
(295,352,2)
(476,359,2)
(276,440,2)
(299,304,2)
(39,262,2)
(100,65,2)
(265,447,2)
(293,93,2)
(121,93,2)
(238,352,2)
(348,440,2)
(106,283,2)
(174,115,2)
(337,352,2)
(251,418,2)
(352,93,2)
(226,93,2)
(134,93,2)
(309,239,2)
(194,352,2)
(109,236,2)
(157,352,2)
(251,359,2)
(359,440,2)
(174,352,2)
(335,314,2)
(196,185,2)
(133,283,2)
(266,458,2)
(345,361,2)
(258,352,2)
(161,405,2)
(358,93,2)
(28,93,2)
(203,352,2)
(382,352,2)
(383,81,2)
(396,352,2)
(31,196,2)
(143,93,2)
(54,366,2)
(338,375,2)
(187,465,2)
(445,115,2)
(334,274,2)
(404,352,2)
(326,65,2)
(401,130,2)
(240,369,2)
(3,115,2)
(66,266,2)
(92,219,2)
(304,314,2)
(428,283,2)
(250,477,2)
(425,81,2)
(291,298,2)
(339,262,2)
(91,236,2)
(63,130,2)
(325,81,2)
(485,236,2)
(56,352,2)
(274,352,2)
(287,465,2)
(479,81,2)
(275,359,2)
(414,130,2)
(42,93,2)
(18,93,2)
(309,262,2)
(337,93,2)
(336,347,2)
(139,440,2)
(392,314,2)
(86,248,2)
(109,103,2)
(221,366,2)
(211,366,2)
(259,352,2)
(126,333,2)
(88,440,2)
(436,251,2)
(411,250,2)
(239,262,2)
(23,93,2)
(121,352,2)
(443,440,2)
(371,93,2)
(318,366,2)
(92,402,2)
(417,234,2)
(404,93,2)
(266,352,2)
(62,262,2)
(373,465,2)
(374,298,2)
(213,431,2)
(477,458,2)
(230,55,2)
(174,93,2)
(201,366,2)
(249,352,2)
(274,458,2)
(367,65,2)
(353,359,2)
(107,93,2)
(466,254,2)
(196,352,2)
(202,262,2)
(20,458,2)
(370,314,2)
(51,366,2)
(340,262,2)
(127,121,2)
(104,465,2)
(30,447,2)
(239,115,2)
(83,130,2)
(415,283,2)
(487,447,2)
(379,121,2)
(198,130,2)
(0,352,2)
(99,366,2)
(345,447,2)
(288,352,2)
(484,65,2)
(81,465,2)
(408,352,2)
(17,431,2)
(474,283,2)
(0,93,2)
(425,458,2)
(73,352,2)
(180,393,2)
(40,262,2)
(400,93,2)
(207,359,2)
(173,352,2)
(280,352,2)
(222,352,2)
(432,66,2)
(59,352,2)
(385,85,2)
(450,236,2)
(86,370,2)
(64,93,2)
(304,115,2)
(31,93,2)
(38,242,2)
(312,352,2)
(468,93,2)
(116,440,2)
(120,352,2)
(143,352,2)
(32,115,2)
(330,262,2)
(3,465,2)
(405,115,2)
(248,458,2)
(292,147,2)
(372,352,2)
(374,93,2)
(56,75,2)
(378,309,2)
(19,262,2)
(440,282,2)
(469,93,2)
(55,39,2)
(351,93,2)
(460,93,2)
(241,93,2)
(427,93,2)
(166,366,2)
(324,93,2)
(264,298,2)
(174,458,2)
(431,366,2)
(136,93,2)
(57,236,2)
(324,285,2)
(121,31,2)
(378,174,2)
(477,65,2)
(361,436,2)
(172,121,2)
(211,458,2)
(200,262,2)
(259,93,2)
(53,132,2)
(316,436,2)
(447,359,2)
(108,352,2)
(301,366,2)
(171,130,2)
(182,93,2)
(227,93,2)
(148,115,2)
(134,115,2)
(446,465,2)
(442,93,2)
(60,359,2)
(75,458,2)
(441,20,2)
(393,93,2)
(305,93,2)
(474,460,2)
(132,93,2)
(461,262,2)
(318,394,2)
(437,352,2)
(486,93,2)
(361,447,2)
(120,93,2)
(296,458,2)
(241,352,2)
(466,352,2)
(365,65,2)
(86,352,2)
(336,359,2)
(418,440,2)
(203,93,2)
(369,93,2)
(50,352,2)
(225,93,2)
(13,440,2)
(473,378,2)
(278,458,2)
(86,296,2)
(185,194,2)
(46,93,2)
(122,359,2)
(303,352,2)
(210,130,2)
(144,236,2)
(433,26,2)
(129,440,2)
(231,65,2)
(294,436,2)
(261,359,2)
(213,443,2)
(20,314,2)
(430,316,2)
(322,130,2)
(272,431,2)
(332,93,2)
(224,314,2)
(411,65,2)
(262,85,2)
(376,65,2)
(388,305,2)
(341,440,2)
(208,283,2)
(390,242,2)
(459,130,2)
(410,440,2)
(397,314,2)
(194,134,2)
(437,93,2)
(219,93,2)
(32,458,2)
(427,352,2)
(204,65,2)
(181,27,2)
(212,93,2)
(473,329,2)
(185,352,2)
(320,447,2)
(77,436,2)
(25,93,2)
(466,475,2)
(435,445,2)
(432,352,2)
(351,135,2)
(428,460,2)
(359,418,2)
(434,262,2)
(33,352,2)
(347,359,2)
(296,115,2)
(378,352,2)
(409,236,2)
(228,352,2)
(284,479,2)
(456,292,2)
(215,210,2)
(218,242,2)
(268,284,2)
(319,352,2)
(435,465,2)
(475,352,2)
(302,366,2)
(323,465,2)
(227,352,2)
(37,352,2)
(473,476,2)
(318,112,2)
(248,115,2)
(426,93,2)
(448,93,2)
(426,352,2)
(65,127,2)
(315,236,2)
(374,352,2)
(283,352,2)
(239,458,2)
(477,115,2)
(333,458,2)
(244,352,2)
(112,480,2)
(375,325,2)
(65,121,2)
(274,115,2)
(131,262,2)
(315,101,2)
(257,284,2)
(278,115,2)
(240,352,2)
(329,366,2)
(160,130,2)
(183,130,2)
(245,262,2)
(394,366,2)
(378,126,2)
(304,458,2)
(111,359,2)
(66,352,2)
(449,236,2)
(3,458,2)
(317,443,2)
(59,93,2)
(85,93,2)
(9,262,2)
(246,93,2)
(229,314,2)
(370,115,2)
(367,115,2)
(267,465,2)
(237,352,2)
(96,366,2)
(118,465,2)
(285,93,2)
(420,262,2)
(53,152,2)
(295,93,2)
(418,433,2)
(34,298,2)
(354,269,2)
(162,65,2)
(247,93,2)
(438,262,2)
(284,425,2)
(334,352,2)
(250,65,2)
(338,81,2)
(209,359,2)
(197,311,2)
(402,93,2)
(1,236,2)
(234,458,2)
(5,262,2)
(50,93,2)
(255,366,2)
(68,314,2)
(380,352,2)
(377,93,2)
(262,93,2)
(263,236,2)
(212,352,2)
(82,236,2)
(50,351,2)
(451,314,2)
(489,130,2)
(256,93,2)
(5,278,2)
-----------------------------------
(0,chan)
(1,"Station \'%s\' not found!\\n")
(2,"CONGESTION")
(3,trunk_ref->state)
(4,station)
(5,sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_IDLE, ALL_TRUNK_REFS, NULL)
(6,0)
(7,conf_name)
(8,data)
(9,conf_name)
(10,cond)
(11,if (trunk_ref->state == SLA_TRUNK_STATE_ONHOLD_BYME)
(12,0)
(13,data)
(14,ast_autoservice_start(chan)
(15,trunk)
(16,sla_stations)
(17,LOG_NOTICE)
(18,&cond)
(19,trunk_ref)
(20,trunk_ref->trunk)
(21,LOG_WARNING)
(22,trunk_ref)
(23,0)
(24,(int *)
(25,NULL)
(26,&trunk_name)
(27,&cond_lock)
(28,trunk_ref->chan = NULL)
(29,)
(30,ast_atomic_fetchadd_int((int *)
(31,ast_atomic_fetchadd_int((int *)
(32,trunk_ref->trunk)
(33,1)
(34,ast_autoservice_stop(chan)
(35,conf)
(36,trunk)
(37,trunk_ref)
(38,trunk_ref)
(39,strlen(conf_name)
(40,sizeof(conf_name)
(41,)
(42,CONFFLAG_QUIET)
(43,station->ref_count)
(44,conf_flags)
(45,conf_flags)
(46,cond_lock)
(47,sla_queue_event(SLA_EVENT_CHECK_RELOAD)
(48,NULL)
(49,"Can\'t join existing call on trunk "\n\\n\\t\\t\\t\\t"\'%s\' due to access controls.\\n")
(50,ast_set_flag64(&conf_flags,\n\\n\\t\\tCONFFLAG_QUIET | CONFFLAG_MARKEDEXIT | CONFFLAG_PASS_DTMF | CONFFLAG_SLA_STATION)
(51,trunk)
(52,ringing_trunk)
(53,ast_cond_wait(&cond, &cond_lock)
(54,trunk_ref)
(55,sizeof(conf_name)
(56,sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_IDLE, ALL_TRUNK_REFS, NULL)
(57,chan)
(58,trunk_name)
(59,conf_name)
(60,"SLASTATION_STATUS")
(61,ast_log(LOG_WARNING, "Station \'%s\' not found!\\n", station_name)
(62,ALL_TRUNK_REFS)
(63,NULL)
(64,NULL)
(65,ast_atomic_fetchadd_int((int *)
(66,trunk_ref->trunk->name)
(67,)
(68,"SLA:%s_%s")
(69,int *)
(70,trunk_name)
(71,)
(72,NULL)
(73,trunk)
(74,station_name)
(75,trunk_ref->trunk)
(76,)
(77,sla_choose_idle_trunk(station)
(78,state)
(79,trunk_ref)
(80,ast_cond_init(&cond, NULL)
(81,trunk_ref->state == SLA_TRUNK_STATE_RINGING)
(82,sla_trunks)
(83,ringing_trunk)
(84,SLA_TRUNK_STATE_UP)
(85,ast_atomic_dec_and_test((int *)
(86,return 0;)
(87,1)
(88,station_name)
(89,chan)
(90,if (ast_strlen_zero(station_name)
(91,"SLASTATION_STATUS")
(92,ast_pthread_create_detached_background(&dont_care, NULL, dial_trunk, &args)
(93,!trunk_ref->trunk->chan)
(94,",K")
(95,admin_exec(NULL, conf_name)
(96,chan)
(97,ringing_trunk)
(98,)
(99,chan)
(100,AST_CONTROL_UNHOLD)
(101,&sla_trunks)
(102,name)
(103,&sla_trunks)
(104,SLA_TRUNK_STATE_RINGING)
(105,ast_mutex_unlock)
(106,chan)
(107,trunk_ref)
(108,trunk_ref)
(109,AST_RWLIST_RDLOCK(&sla_trunks)
(110,if (ast_strlen_zero(data)
(111,AST_RWLIST_RDLOCK(&sla_stations)
(112,(int *)
(113,"SLASTATION_STATUS")
(114,trunk_ref->chan = chan)
(115,trunk_ref = sla_choose_idle_trunk(station)
(116,LOG_WARNING)
(117,0)
(118,hold_stations)
(119,ast_strdupa(data)
(120,chan)
(121,ast_atomic_fetchadd_int((int *)
(122,ast_log(LOG_WARNING, "Invalid Arguments to SLAStation!\\n")
(123,SLA_TRUNK_STATE_ONHOLD_BYME)
(124,SLA_TRUNK_STATE_UP)
(125,NULL)
(126,trunk_ref->trunk->on_hold)
(127,trunk_ref->trunk->on_hold)
(128,chan)
(129,"_")
(130,ringing_trunk)
(131,SLA_TRUNK_STATE_IDLE)
(132,&cond_lock)
(133,conf = NULL)
(134,trunk_ref->trunk)
(135,CONFFLAG_MARKEDEXIT | CONFFLAG_PASS_DTMF | CONFFLAG_SLA_STATION)
(136,cond_lock)
(137,SLA_TRUNK_STATE_UP)
(138,SLA_TRUNK_STATE_ONHOLD_BYME)
(139,trunk_name)
(140,)
(141,)
(142,&station->ref_count)
(143,active_stations)
(144,trunk_ref)
(145,trunk_name)
(146,chan)
(147,int *)
(148,trunk_ref->state)
(149,if (conf)
(150,"No trunks available for call.\\n")
(151,SLA_EVENT_CHECK_RELOAD)
(152,&cond)
(153,)
(154,if (!trunk_ref->trunk->chan)
(155,cond)
(156,)
(157,ALL_TRUNK_REFS)
(158,conf_flags)
(159,)
(160,sla_queue_event(SLA_EVENT_DIAL_STATE)
(161,trunk_ref->trunk->chan)
(162,trunk)
(163,1)
(164,trunk_ref)
(165,CONFFLAG_PASS_DTMF | CONFFLAG_SLA_STATION)
(166,1)
(167,state)
(168,conf)
(169,)
(170,chan)
(171,ringing_trunk->trunk)
(172,trunk_ref)
(173,NULL)
(174,trunk_ref->chan)
(175,station_name)
(176,if (!trunk_ref)
(177,trunk_ref)
(178,)
(179,conf)
(180,ast_atomic_fetchadd_int((int *)
(181,ast_mutex_unlock(&cond_lock)
(182,&conf_flags)
(183,SLA_EVENT_DIAL_STATE)
(184,sla_queue_event(SLA_EVENT_RINGING_TRUNK)
(185,&trunk_ref->trunk->active_stations)
(186,&cond_lock)
(187,&trunk_ref->trunk->hold_stations)
(188,SLA_TRUNK_STATE_UP)
(189,station)
(190,LOG_NOTICE)
(191,0)
(192,)
(193,hold_stations)
(194,trunk_ref->trunk->active_stations)
(195,cond_lock)
(196,(int *)
(197,ast_devstate_changed(AST_DEVICE_INUSE,\n\\n\\t\\t\\t\\t"SLA:%s_%s", station->name, trunk_ref->trunk->name)
(198,free(ringing_trunk)
(199,if (ringing_trunk)
(200,strlen(conf_name)
(201,chan)
(202,conf_name)
(203,CONFFLAG_SLA_STATION)
(204,trunk)
(205,conf)
(206,cond)
(207,0)
(208,conf)
(209,station)
(210,ringing_trunk->trunk)
(211,trunk_ref->trunk)
(212,NULL)
(213,ast_log(LOG_NOTICE, "Can\'t join existing call on trunk "\n\\n\\t\\t\\t\\t"\'%s\' due to access controls.\\n", trunk_name)
(214,trunk_ref->trunk->chan)
(215,sla_change_trunk_state(ringing_trunk->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL)
(216,"Invalid Arguments to SLAStation!\\n")
(217,station)
(218,station)
(219,&dont_care)
(220,ast_strlen_zero(trunk_name)
(221,chan)
(222,NULL)
(223,trunk)
(224,ALL_TRUNK_REFS)
(225,dial_trunk)
(226,chan)
(227,(int *)
(228,CONFFLAG_PASS_DTMF)
(229,trunk_ref)
(230,strncat(conf_name, ",K", sizeof(conf_name)
(231,ALL_TRUNK_REFS)
(232,trunk_ref)
(233,ast_mutex_lock(&cond_lock)
(234,trunk_ref->state)
(235,)
(236,!station)
(237,"SLASTATION_STATUS")
(238,trunk)
(239,trunk_ref->trunk)
(240,(int *)
(241,name)
(242,!ast_strlen_zero(trunk_name)
(243,if (ringing_trunk->trunk == trunk_ref->trunk)
(244,"")
(245,0)
(246,chan)
(247,trunk)
(248,trunk_ref->chan)
(249,trunk)
(250,trunk_ref->trunk->chan)
(251,sla_find_station(station_name)
(252,break;)
(253,chan)
(254,int *)
(255,sla_queue_event(SLA_EVENT_CHECK_RELOAD)
(256,conf_name)
(257,entry)
(258,"Trunk didn\'t get created. chan: %lx\\n")
(259,"SUCCESS")
(260,NULL)
(261,station_name)
(262,ast_atomic_dec_and_test((int *)
(263,sla_trunks)
(264,pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE")
(265,ref_count)
(266,trunk_ref->trunk)
(267,1)
(268,AST_LIST_REMOVE_CURRENT(entry)
(269,(long)
(270,dont_care)
(271,trunk_ref)
(272,ast_log(LOG_NOTICE, "No trunks available for call.\\n")
(273,conf_flags = { 0 })
(274,trunk_ref->trunk)
(275,&sla_stations)
(276,0)
(277,trunk_ref->state = SLA_TRUNK_STATE_UP)
(278,trunk_ref->trunk)
(279,if (!ast_strlen_zero(trunk_name)
(280,ast_atomic_fetchadd_int((int *)
(281,SLA_EVENT_CHECK_RELOAD)
(282,const char *data)
(283,conf)
(284,ringing_trunk->trunk == trunk_ref->trunk)
(285,trunk_ref->trunk)
(286,)
(287,state)
(288,ast_answer(chan)
(289,sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL)
(290,if (station)
(291,pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE")
(292,(int *)
(293,chan)
(294,station->ref_count)
(295,trunk_ref)
(296,trunk_ref->chan)
(297,&cond_lock)
(298,struct ast_channel *chan)
(299,trunk_ref->trunk->name)
(300,-1)
(301,"SLASTATION_STATUS")
(302,SLA_EVENT_CHECK_RELOAD)
(303,conf_flags)
(304,trunk_ref->trunk)
(305,&cond)
(306,trunk_ref->trunk->on_hold = 0)
(307,trunk)
(308,return 0;)
(309,trunk_ref->trunk->hold_stations)
(310,trunk_ref->trunk)
(311,station->name)
(312,SLA_EVENT_CHECK_RELOAD)
(313,ast_mutex_init(&cond_lock)
(314,ast_atomic_dec_and_test((int *)
(315,AST_RWLIST_UNLOCK(&sla_trunks)
(316,station->ref_count)
(317,sla_find_trunk_ref_byname(station, trunk_name)
(318,ast_atomic_fetchadd_int((int *)
(319,pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "CONGESTION")
(320,station)
(321,"FAILURE")
(322,ringing_trunk->trunk->chan)
(323,trunk_ref)
(324,sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL)
(325,sla.lock)
(326,chan)
(327,if (ast_atomic_fetchadd_int((int *)
(328,ringing_trunk)
(329,return 0;)
(330,trunk_ref)
(331,ref_count)
(332,cond_lock)
(333,trunk_ref->trunk)
(334,trunk_ref->trunk->chan)
(335,name)
(336,AST_RWLIST_UNLOCK(&sla_stations)
(337,"")
(338,ast_mutex_lock(&sla.lock)
(339,trunk)
(340,NULL)
(341,station_name)
(342,"SLASTATION_STATUS")
(343,&conf_flags)
(344,AST_DEVICE_INUSE)
(345,&station->ref_count)
(346,if (!trunk_ref->trunk->chan)
(347,&sla_stations)
(348,chan)
(349,LOG_WARNING)
(350,sla_stations)
(351,CONFFLAG_QUIET | CONFFLAG_MARKEDEXIT | CONFFLAG_PASS_DTMF | CONFFLAG_SLA_STATION)
(352,!trunk_ref->trunk->chan)
(353,"FAILURE")
(354,ast_debug(1, "Trunk didn\'t get created. chan: %lx\\n", (long)
(355,trunk_name)
(356,sla_queue_event(SLA_EVENT_CHECK_RELOAD)
(357,NULL)
(358,trunk)
(359,ast_strlen_zero(station_name)
(360,int *)
(361,station->ref_count)
(362,if (ast_atomic_dec_and_test((int *)
(363,NULL)
(364,*trunk_ref = NULL)
(365,0)
(366,!trunk_ref)
(367,trunk_ref->trunk)
(368,cond_lock)
(369,&trunk_ref->trunk->active_stations)
(370,trunk_ref->state)
(371,trunk_ref)
(372,trunk)
(373,trunk_ref)
(374,pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "SUCCESS")
(375,&sla.lock)
(376,on_hold)
(377,conf_name)
(378,return 0;)
(379,on_hold)
(380,chan)
(381,int *)
(382,chan)
(383,trunk)
(384,station)
(385,state)
(386,conf_name)
(387,trunk_ref)
(388,ast_cond_destroy(&cond)
(389,trunk_ref->trunk->active_stations)
(390,trunk_ref)
(391,sla)
(392,trunk_ref)
(393,-1)
(394,-1)
(395,int *)
(396,ref_count)
(397,trunk)
(398,pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "CONGESTION")
(399,sizeof(conf_name)
(400,0)
(401,answer_trunk_chan(ringing_trunk->trunk->chan)
(402,&args)
(403,trunk_ref)
(404,"SLA_%s")
(405,trunk_ref->trunk)
(406,1)
(407,sla_queue_event(SLA_EVENT_CHECK_RELOAD)
(408,1)
(409,return 0;)
(410,ast_log(LOG_WARNING, "Invalid Arguments to SLAStation!\\n")
(411,ast_indicate(trunk_ref->trunk->chan, AST_CONTROL_UNHOLD)
(412,cond)
(413,)
(414,SLA_EVENT_RINGING_TRUNK)
(415,NULL)
(416,NULL)
(417,trunk_ref->state != SLA_TRUNK_STATE_ONHOLD_BYME)
(418,station_name = strsep(&trunk_name, "_")
(419,trunk)
(420,1)
(421,if (!station)
(422,if (ast_strlen_zero(trunk_name)
(423,lock)
(424,trunk_ref)
(425,trunk_ref->trunk)
(426,trunk_ref)
(427,active_stations)
(428,dispose_conf(conf)
(429,dont_care)
(430,&station->ref_count)
(431,ast_strlen_zero(trunk_name)
(432,snprintf(conf_name, sizeof(conf_name)
(433,strsep(&trunk_name, "_")
(434,conf_name)
(435,trunk_ref->trunk->hold_stations)
(436,station = sla_find_station(station_name)
(437,build_conf(conf_name, "", "", 0, 0, 1, chan, NULL)
(438,trunk_ref->trunk->hold_stations = 0)
(439,long)
(440,ast_strlen_zero(data)
(441,sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL)
(442,args)
(443,trunk_name = ast_strdupa(data)
(444,if (ast_atomic_dec_and_test((int *)
(445,trunk_ref->trunk)
(446,trunk)
(447,station)
(448,station)
(449,"FAILURE")
(450,pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE")
(451,SLA_TRUNK_STATE_UP)
(452,"CONGESTION")
(453,)
(454,station)
(455,trunk)
(456,ast_atomic_dec_and_test((int *)
(457,SLA_TRUNK_STATE_IDLE)
(458,trunk_ref = sla_find_trunk_ref_byname(station, trunk_name)
(459,ALL_TRUNK_REFS)
(460,conf = build_conf(conf_name, "", "", 0, 0, 1, chan, NULL)
(461,trunk)
(462,trunk_ref)
(463,cond_lock)
(464,)
(465,trunk_ref->state == SLA_TRUNK_STATE_ONHOLD_BYME)
(466,(int *)
(467,trunk_name)
(468,ALL_TRUNK_REFS)
(469,CONFFLAG_MARKEDEXIT)
(470,trunk_ref->chan = NULL)
(471,trunk_name)
(472,trunk_ref)
(473,RET)
(474,conf_run(chan, conf, &conf_flags, NULL)
(475,&station->ref_count)
(476,return 0;)
(477,trunk_ref->trunk)
(478,station)
(479,ringing_trunk->trunk)
(480,int *)
(481,ref_count)
(482,ast_mutex_destroy(&cond_lock)
(483,ringing_trunk)
(484,trunk_ref)
(485,0)
(486,&cond_lock)
(487,1)
(488,trunk_ref)
(489,trunk)
(490,"Invalid Arguments to SLAStation!\\n")
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^