-----label-----
1
-----code-----
static int login_exec(struct ast_channel *chan, const char *data)
{
	int res=0;
	int tries = 0;
	int max_login_tries = maxlogintries;
	struct agent_pvt *p;
	struct ast_module_user *u;
	char user[AST_MAX_AGENT] = "";
	char pass[AST_MAX_AGENT];
	char agent[AST_MAX_AGENT] = "";
	char xpass[AST_MAX_AGENT] = "";
	char *errmsg;
	char *parse;
	AST_DECLARE_APP_ARGS(args,
			     AST_APP_ARG(agent_id);
			     AST_APP_ARG(options);
			     AST_APP_ARG(extension);
		);
	const char *tmpoptions = NULL;
	int play_announcement = 1;
	char agent_goodbye[AST_MAX_FILENAME_LEN];
	int update_cdr = updatecdr;
	char *filename = "agent-loginok";

	u = ast_module_user_add(chan);

	parse = ast_strdupa(data);

	AST_STANDARD_APP_ARGS(args, parse);

	ast_copy_string(agent_goodbye, agentgoodbye, sizeof(agent_goodbye));

	ast_channel_lock(chan);
	/* Set Channel Specific Login Overrides */
	if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTLMAXLOGINTRIES"))) {
		max_login_tries = atoi(pbx_builtin_getvar_helper(chan, "AGENTMAXLOGINTRIES"));
		if (max_login_tries < 0)
			max_login_tries = 0;
		tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTMAXLOGINTRIES");
		ast_verb(3, "Saw variable AGENTMAXLOGINTRIES=%s, setting max_login_tries to: %d on Channel '%s'.\n",tmpoptions,max_login_tries,ast_channel_name(chan));
	}
	if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR"))) {
		if (ast_true(pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR")))
			update_cdr = 1;
		else
			update_cdr = 0;
		tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR");
		ast_verb(3, "Saw variable AGENTUPDATECDR=%s, setting update_cdr to: %d on Channel '%s'.\n",tmpoptions,update_cdr,ast_channel_name(chan));
	}
	if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTGOODBYE"))) {
		strcpy(agent_goodbye, pbx_builtin_getvar_helper(chan, "AGENTGOODBYE"));
		tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTGOODBYE");
		ast_verb(3, "Saw variable AGENTGOODBYE=%s, setting agent_goodbye to: %s on Channel '%s'.\n",tmpoptions,agent_goodbye,ast_channel_name(chan));
	}
	ast_channel_unlock(chan);
	/* End Channel Specific Login Overrides */

	if (!ast_strlen_zero(args.options)) {
		if (strchr(args.options, 's')) {
			play_announcement = 0;
		}
	}

	if (ast_channel_state(chan) != AST_STATE_UP)
		res = ast_answer(chan);
	if (!res) {
		if (!ast_strlen_zero(args.agent_id))
			ast_copy_string(user, args.agent_id, AST_MAX_AGENT);
		else
			res = ast_app_getdata(chan, "agent-user", user, sizeof(user) - 1, 0);
	}
	while (!res && (max_login_tries==0 || tries < max_login_tries)) {
		tries++;
		/* Check for password */
		AST_LIST_LOCK(&agents);
		AST_LIST_TRAVERSE(&agents, p, list) {
			if (!strcmp(p->agent, user) && !p->pending)
				ast_copy_string(xpass, p->password, sizeof(xpass));
		}
		AST_LIST_UNLOCK(&agents);
		if (!res) {
			if (!ast_strlen_zero(xpass))
				res = ast_app_getdata(chan, "agent-pass", pass, sizeof(pass) - 1, 0);
			else
				pass[0] = '\0';
		}
		errmsg = "agent-incorrect";

#if 0
		ast_log(LOG_NOTICE, "user: %s, pass: %s\n", user, pass);
#endif

		/* Check again for accuracy */
		AST_LIST_LOCK(&agents);
		AST_LIST_TRAVERSE(&agents, p, list) {
			int unlock_channel = 1;
			ast_channel_lock(chan);
			ast_mutex_lock(&p->lock);
			if (!strcmp(p->agent, user) &&
			    !strcmp(p->password, pass) && !p->pending) {

				/* Ensure we can't be gotten until we're done */
				p->lastdisc = ast_tvnow();
				p->lastdisc.tv_sec++;

				/* Set Channel Specific Agent Overrides */
				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))) {
					if (ast_true(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))) {
						p->ackcall = 1;
					} else {
						p->ackcall = 0;
					}
					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTACKCALL");
					ast_verb(3, "Saw variable AGENTACKCALL=%s, setting ackcall to: %d for Agent '%s'.\n", tmpoptions, p->ackcall, p->agent);
					ast_set_flag(p, AGENT_FLAG_ACKCALL);
				} else {
					p->ackcall = ackcall;
				}
				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"))) {
					p->autologoff = atoi(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"));
					if (p->autologoff < 0)
						p->autologoff = 0;
					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF");
					ast_verb(3, "Saw variable AGENTAUTOLOGOFF=%s, setting autologff to: %d for Agent '%s'.\n", tmpoptions, p->autologoff, p->agent);
					ast_set_flag(p, AGENT_FLAG_AUTOLOGOFF);
				} else {
					p->autologoff = autologoff;
				}
				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"))) {
					p->wrapuptime = atoi(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"));
					if (p->wrapuptime < 0)
						p->wrapuptime = 0;
					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME");
					ast_verb(3, "Saw variable AGENTWRAPUPTIME=%s, setting wrapuptime to: %d for Agent '%s'.\n", tmpoptions, p->wrapuptime, p->agent);
					ast_set_flag(p, AGENT_FLAG_WRAPUPTIME);
				} else {
					p->wrapuptime = wrapuptime;
				}
				tmpoptions = pbx_builtin_getvar_helper(chan, "AGENTACCEPTDTMF");
				if (!ast_strlen_zero(tmpoptions)) {
					p->acceptdtmf = *tmpoptions;
					ast_verb(3, "Saw variable AGENTACCEPTDTMF=%s, setting acceptdtmf to: %c for Agent '%s'.\n", tmpoptions, p->acceptdtmf, p->agent);
					ast_set_flag(p, AGENT_FLAG_ACCEPTDTMF);
				}
				tmpoptions = pbx_builtin_getvar_helper(chan, "AGENTENDDTMF");
				if (!ast_strlen_zero(tmpoptions)) {
					p->enddtmf = *tmpoptions;
					ast_verb(3, "Saw variable AGENTENDDTMF=%s, setting enddtmf to: %c for Agent '%s'.\n", tmpoptions, p->enddtmf, p->agent);
					ast_set_flag(p, AGENT_FLAG_ENDDTMF);
				}
				ast_channel_unlock(chan);
				unlock_channel = 0;
				/* End Channel Specific Agent Overrides */
				if (!p->chan) {
					long logintime;
					snprintf(agent, sizeof(agent), "Agent/%s", p->agent);

					p->logincallerid[0] = '\0';
					p->acknowledged = 0;

					ast_mutex_unlock(&p->lock);
					AST_LIST_UNLOCK(&agents);
					if( !res && play_announcement==1 )
						res = ast_streamfile(chan, filename, ast_channel_language(chan));
					if (!res)
						ast_waitstream(chan, "");
					AST_LIST_LOCK(&agents);
					ast_mutex_lock(&p->lock);
					if (!res) {
						struct ast_format tmpfmt;
						res = ast_set_read_format_from_cap(chan, ast_channel_nativeformats(chan));
						if (res) {
							ast_log(LOG_WARNING, "Unable to set read format to %s\n", ast_getformatname(&tmpfmt));
						}
					}
					if (!res) {
						struct ast_format tmpfmt;
						res = ast_set_write_format_from_cap(chan, ast_channel_nativeformats(chan));
						if (res) {
							ast_log(LOG_WARNING, "Unable to set write format to %s\n", ast_getformatname(&tmpfmt));
						}
					}
					/* Check once more just in case */
					if (p->chan)
						res = -1;
					if (!res) {
						ast_indicate_data(chan, AST_CONTROL_HOLD,
							S_OR(p->moh, NULL),
							!ast_strlen_zero(p->moh) ? strlen(p->moh) + 1 : 0);
						if (p->loginstart == 0)
							time(&p->loginstart);
						/*** DOCUMENTATION
							<managerEventInstance>
								<synopsis>Raised when an Agent has logged in.</synopsis>
								<syntax>
									<parameter name="Agent">
										<para>The name of the agent.</para>
									</parameter>
								</syntax>
								<see-also>
									<ref type="application">AgentLogin</ref>
									<ref type="managerEvent">Agentlogoff</ref>
								</see-also>
							</managerEventInstance>
						***/
						manager_event(EVENT_FLAG_AGENT, "Agentlogin",
							      "Agent: %s\r\n"
							      "Channel: %s\r\n"
							      "Uniqueid: %s\r\n",
							      p->agent, ast_channel_name(chan), ast_channel_uniqueid(chan));
						if (update_cdr && ast_channel_cdr(chan))
							snprintf(ast_channel_cdr(chan)->channel, sizeof(ast_channel_cdr(chan)->channel), "Agent/%s", p->agent);
						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGIN", "%s", ast_channel_name(chan));
						ast_verb(2, "Agent '%s' logged in (format %s/%s)\n", p->agent,
								    ast_getformatname(ast_channel_readformat(chan)), ast_getformatname(ast_channel_writeformat(chan)));
						/* Login this channel and wait for it to go away */
						p->chan = chan;
						if (p->ackcall) {
							check_beep(p, 0);
						} else {
							check_availability(p, 0);
						}
						ast_mutex_unlock(&p->lock);
						AST_LIST_UNLOCK(&agents);
						ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Agent/%s", p->agent);
						while (res >= 0) {
							ast_mutex_lock(&p->lock);
							if (p->deferlogoff && p->chan) {
								ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);
								p->deferlogoff = 0;
							}
							if (p->chan != chan)
								res = -1;
							ast_mutex_unlock(&p->lock);
							/* Yield here so other interested threads can kick in. */
							sched_yield();
							if (res)
								break;

							AST_LIST_LOCK(&agents);
							ast_mutex_lock(&p->lock);
							if (p->lastdisc.tv_sec) {
								if (ast_tvdiff_ms(ast_tvnow(), p->lastdisc) > 0) {
									ast_debug(1, "Wrapup time for %s expired!\n", p->agent);
									p->lastdisc = ast_tv(0, 0);
									ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Agent/%s", p->agent);
									if (p->ackcall) {
										check_beep(p, 0);
									} else {
										check_availability(p, 0);
									}
								}
							}
							ast_mutex_unlock(&p->lock);
							AST_LIST_UNLOCK(&agents);

							/*	Synchronize channel ownership between call to agent and itself. */
							ast_mutex_lock(&p->lock);
							if (p->app_lock_flag == 1) {
								ast_cond_signal(&p->login_wait_cond);
								ast_cond_wait(&p->app_complete_cond, &p->lock);
							}
							ast_mutex_unlock(&p->lock);
							if (p->ackcall) {
								res = agent_ack_sleep(p);
							} else {
								res = ast_safe_sleep_conditional( chan, 1000, agent_cont_sleep, p );
							}
							if (p->ackcall && (res == 1)) {
								AST_LIST_LOCK(&agents);
								ast_mutex_lock(&p->lock);
								check_availability(p, 0);
								ast_mutex_unlock(&p->lock);
								AST_LIST_UNLOCK(&agents);
								res = 0;
							}
							sched_yield();
						}
						ast_mutex_lock(&p->lock);
						/* Log us off if appropriate */
						if (p->chan == chan) {
							p->chan = NULL;
						}

						/* Synchronize channel ownership between call to agent and itself. */
						if (p->app_lock_flag == 1) {
							ast_cond_signal(&p->login_wait_cond);
							ast_cond_wait(&p->app_complete_cond, &p->lock);
						}

						if (res && p->owner)
							ast_log(LOG_WARNING, "Huh?  We broke out when there was still an owner?\n");

						p->acknowledged = 0;
						logintime = time(NULL) - p->loginstart;
						p->loginstart = 0;
						ast_mutex_unlock(&p->lock);
						/*** DOCUMENTATION
							<managerEventInstance>
								<synopsis>Raised when an Agent has logged off.</synopsis>
								<syntax>
									<xi:include xpointer="xpointer(/docs/managerEvent[@name='Agentlogin']/managerEventInstance/syntax/parameter[@name='Agent'])" />
								</syntax>
								<see-also>
									<ref type="managerEvent">Agentlogin</ref>
								</see-also>
							</managerEventInstance>
						***/
						manager_event(EVENT_FLAG_AGENT, "Agentlogoff",
							      "Agent: %s\r\n"
							      "Logintime: %ld\r\n"
							      "Uniqueid: %s\r\n",
							      p->agent, logintime, ast_channel_uniqueid(chan));
						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGOFF", "%s|%ld", ast_channel_name(chan), logintime);
						ast_verb(2, "Agent '%s' logged out\n", p->agent);
						/* If there is no owner, go ahead and kill it now */
						ast_devstate_changed(AST_DEVICE_UNAVAILABLE, "Agent/%s", p->agent);
						if (p->dead && !p->owner) {
							ast_mutex_destroy(&p->lock);
							ast_cond_destroy(&p->app_complete_cond);
							ast_cond_destroy(&p->login_wait_cond);
							ast_free(p);
						}
					}
					else {
						ast_mutex_unlock(&p->lock);
						p = NULL;
					}
					res = -1;
				} else {
					ast_mutex_unlock(&p->lock);
					errmsg = "agent-alreadyon";
					p = NULL;
				}
				break;
			}
			ast_mutex_unlock(&p->lock);
			if (unlock_channel) {
				ast_channel_unlock(chan);
			}
		}
		if (!p)
			AST_LIST_UNLOCK(&agents);

		if (!res && (max_login_tries==0 || tries < max_login_tries))
			res = ast_app_getdata(chan, errmsg, user, sizeof(user) - 1, 0);
	}

	if (!res)
		res = ast_safe_sleep(chan, 500);

	ast_module_user_remove(u);

 	return -1;
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
5,6
5,7
6,7
8,9
8,10
11,12
11,13
13,14
13,15
16,17
16,18
16,19
16,20
16,21
16,22
16,23
16,24
16,25
16,26
16,27
16,28
16,29
16,30
16,31
16,32
16,33
16,34
16,35
16,36
16,37
16,38
16,39
16,40
16,41
16,42
16,43
16,44
16,45
16,46
16,47
16,48
16,49
16,50
16,51
16,52
17,18
18,19
18,20
20,21
20,22
22,23
24,25
25,26
25,27
27,28
27,29
29,30
31,32
32,33
32,34
34,35
34,36
36,37
37,38
39,40
40,41
40,42
41,42
43,44
43,45
46,47
47,48
47,49
48,49
50,51
50,52
53,54
54,55
54,56
56,57
56,58
56,59
58,59
59,60
61,62
63,64
64,65
64,66
66,67
66,68
68,69
69,70
71,72
72,73
72,74
74,75
74,76
74,77
76,77
77,78
79,80
81,82
82,83
82,84
84,85
84,86
84,87
86,87
87,88
89,90
91,92
92,93
92,94
94,95
94,96
97,98
98,99
98,100
100,101
100,102
103,104
104,105
105,106
105,107
106,107
108,109
109,110
111,112
112,113
112,114
113,114
115,116
116,117
118,119
119,120
120,121
120,122
122,123
122,124
122,125
125,126
126,127
128,129
129,130
129,131
131,132
131,133
133,134
135,136
136,137
136,138
138,139
138,140
140,141
141,142
143,144
144,145
144,146
146,147
146,148
148,149
149,150
151,152
152,153
152,154
154,155
154,156
154,157
157,158
159,160
160,161
160,162
161,162
163,164
163,165
164,165
166,167
168,169
169,170
169,171
170,171
172,173
172,174
173,174
175,176
177,178
178,179
178,180
178,181
179,180
181,182
183,184
185,186
186,187
186,188
186,189
186,190
187,188
189,190
191,192
193,194
194,195
195,196
197,198
198,199
198,200
199,200
201,202
203,204
203,205
204,205
205,206
205,207
206,207
208,209
208,210
208,211
209,210
211,212
214,215
214,216
214,217
214,218
215,216
216,217
216,218
217,218
219,220
219,221
220,221
222,223
222,224
222,225
223,224
225,226
228,229
228,230
229,230
229,231
230,231
233,234
234,235
234,236
235,236
238,239
239,240
239,241
240,241
242,243
242,244
242,245
243,244
245,246
248,249
249,250
249,251
249,252
249,253
249,254
249,255
250,251
254,255
256,257
258,259
258,260
259,260
261,262
263,264
263,265
264,265
265,266
265,267
266,267
268,269
268,270
268,271
269,270
271,272
274,275
274,276
274,277
275,276
275,277
275,278
276,277
276,278
277,278
279,280
279,281
279,282
280,281
282,283
285,286
286,287
286,288
287,288
290,291
291,292
291,293
292,293
295,296
296,297
296,298
297,298
299,300
299,301
299,302
300,301
302,303
305,306
306,307
306,308
306,309
306,310
306,311
306,312
307,308
311,312
313,314
315,316
315,317
316,317
318,319
320,321
320,322
321,322
322,323
322,324
323,324
325,326
325,327
325,328
326,327
328,329
331,332
331,333
331,334
332,333
333,334
333,335
333,336
334,335
336,337
338,339
338,340
338,341
339,340
341,342
344,345
345,346
345,347
346,347
348,349
348,350
348,351
349,350
351,352
354,355
355,356
355,357
355,358
355,359
355,360
355,361
356,357
360,361
362,363
364,365
364,366
365,366
367,368
369,370
370,371
370,372
371,372
373,374
375,376
375,377
376,377
377,378
377,379
378,379
380,381
380,382
381,382
384,385
385,386
385,387
386,387
386,388
386,389
387,388
389,390
389,391
390,391
394,395
395,396
396,397
396,398
397,398
400,401
400,402
401,402
401,403
402,403
402,404
403,404
405,406
407,408
409,410
410,411
410,412
411,412
413,414
413,415
414,415
416,417
418,419
418,420
419,420
420,421
422,423
423,424
423,425
423,426
424,425
425,426
425,427
426,427
428,429
428,430
429,430
432,433
433,434
433,435
433,436
433,437
434,435
436,437
438,439
438,440
439,440
442,443
444,445
445,446
445,447
446,447
448,449
448,450
448,451
448,452
448,453
448,454
449,450
451,452
454,455
456,457
456,458
457,458
458,459
459,460
463,464
463,465
464,465
464,466
465,466
466,467
468,469
469,470
469,471
470,471
470,472
471,472
474,475
474,476
475,476
477,478
479,480
479,481
479,482
479,483
479,484
479,485
479,486
479,487
479,488
479,489
479,490
479,491
479,492
479,493
480,481
481,482
482,483
484,485
485,486
485,487
486,487
488,489
489,490
489,491
492,493
493,494
493,495
493,496
493,497
494,495
496,497
497,498
499,500
501,502
503,504
504,505
505,506
505,507
506,507
506,508
507,508
508,509
508,510
508,511
509,510
511,512
511,513
512,513
515,516
517,518
518,519
518,520
519,520
522,523
523,524
523,525
523,526
523,527
524,525
526,527
528,529
528,530
529,530
532,533
533,534
534,535
536,537
537,538
537,539
538,539
540,541
541,542
543,544
543,545
544,545
545,546
547,548
548,549
548,550
548,551
549,550
550,551
550,552
551,552
553,554
555,556
556,557
556,558
557,558
559,560
559,561
559,562
559,563
559,564
559,565
560,561
562,563
565,566
567,568
567,569
568,569
569,570
570,571
574,575
575,576
575,577
576,577
576,578
577,578
581,582
582,583
582,584
583,584
586,587
587,588
587,589
588,589
590,591
591,592
593,594
594,595
594,596
594,597
594,598
595,596
597,598
598,599
600,601
602,603
604,605
605,606
605,607
605,608
605,609
605,610
605,611
606,607
607,608
607,609
609,610
609,611
611,612
613,614
614,615
614,616
615,616
617,618
619,620
620,621
620,622
621,622
623,624
624,625
624,626
625,626
628,629
628,630
629,630
629,631
630,631
630,632
631,632
632,633
632,634
632,635
633,634
635,636
635,637
636,637
639,640
641,642
642,643
642,644
642,645
643,644
645,646
645,647
646,647
649,650
651,652
652,653
652,654
653,654
656,657
656,658
656,659
656,660
656,661
656,662
656,663
656,664
656,665
656,666
656,667
656,668
656,669
657,658
658,659
658,660
659,660
659,661
660,661
663,664
664,665
666,667
667,668
668,669
668,670
669,670
669,671
670,671
674,675
674,676
674,677
675,676
676,677
676,678
677,678
679,680
679,681
679,682
680,681
682,683
685,686
685,687
685,688
685,689
686,687
686,688
686,689
687,688
687,689
688,689
690,691
690,692
690,693
691,692
693,694
696,697
697,698
698,699
698,700
699,700
699,701
700,701
704,705
705,706
706,707
706,708
707,708
707,709
708,709
712,713
713,714
713,715
714,715
716,717
716,718
716,719
717,718
719,720
722,723
723,724
723,725
723,726
723,727
723,728
723,729
724,725
728,729
730,731
730,732
731,732
734,735
734,736
735,736
738,739
739,740
739,741
739,742
740,741
742,743
744,745
746,747
747,748
748,749
748,750
749,750
749,751
750,751
753,754
755,756
755,757
755,758
756,757
757,758
757,759
758,759
760,761
760,762
760,763
761,762
763,764
766,767
766,768
766,769
766,770
766,771
767,768
768,769
768,770
769,770
769,771
770,771
773,774
773,775
774,775
776,777
776,778
776,779
777,778
779,780
782,783
782,784
783,784
783,785
784,785
784,786
785,786
789,790
790,791
790,792
791,792
791,793
792,793
796,797
797,798
797,799
798,799
800,801
800,802
800,803
801,802
803,804
806,807
807,808
807,809
807,810
807,811
807,812
807,813
808,809
812,813
814,815
814,816
815,816
818,819
818,820
819,820
822,823
823,824
823,825
823,826
824,825
826,827
828,829
830,831
831,832
832,833
832,834
833,834
833,835
834,835
837,838
839,840
839,841
839,842
840,841
841,842
841,843
842,843
844,845
844,846
844,847
845,846
847,848
850,851
850,852
850,853
850,854
850,855
851,852
852,853
852,854
853,854
853,855
854,855
857,858
857,859
858,859
860,861
860,862
860,863
861,862
863,864
866,867
866,868
867,868
867,869
868,869
868,870
869,870
873,874
874,875
874,876
875,876
875,877
876,877
880,881
881,882
881,883
882,883
884,885
884,886
884,887
885,886
887,888
890,891
891,892
891,893
891,894
891,895
891,896
891,897
892,893
896,897
898,899
898,900
899,900
902,903
902,904
903,904
906,907
907,908
907,909
907,910
908,909
910,911
912,913
914,915
915,916
916,917
916,918
917,918
917,919
918,919
921,922
923,924
924,925
924,926
925,926
927,928
927,929
927,930
928,929
930,931
933,934
933,935
934,935
935,936
935,937
936,937
938,939
940,941
940,942
940,943
941,942
942,943
942,944
943,944
943,945
944,945
947,948
948,949
950,951
951,952
951,953
951,954
951,955
951,956
951,957
952,953
956,957
958,959
958,960
959,960
962,963
962,964
963,964
966,967
967,968
967,969
967,970
968,969
970,971
972,973
974,975
975,976
975,977
976,977
978,979
978,980
978,981
979,980
981,982
984,985
984,986
985,986
986,987
986,988
987,988
989,990
991,992
991,993
991,994
992,993
993,994
993,995
994,995
994,996
995,996
998,999
999,1000
1001,1002
1002,1003
1002,1004
1002,1005
1002,1006
1002,1007
1002,1008
1003,1004
1007,1008
1009,1010
1009,1011
1010,1011
1013,1014
1013,1015
1014,1015
1017,1018
1018,1019
1018,1020
1018,1021
1019,1020
1021,1022
1023,1024
1025,1026
1026,1027
1026,1028
1027,1028
1029,1030
1031,1032
1032,1033
1032,1034
1033,1034
1036,1037
1036,1038
1036,1039
1037,1038
1038,1039
1038,1040
1039,1040
1042,1043
1042,1044
1042,1045
1042,1046
1042,1047
1042,1048
1042,1049
1042,1050
1042,1051
1042,1052
1042,1053
1042,1054
1042,1055
1042,1056
1042,1057
1043,1044
1044,1045
1044,1046
1046,1047
1048,1049
1049,1050
1049,1051
1049,1052
1049,1053
1049,1054
1050,1051
1052,1053
1054,1055
1055,1056
1056,1057
1059,1060
1059,1061
1060,1061
1063,1064
1064,1065
1064,1066
1065,1066
1065,1067
1066,1067
1066,1068
1067,1068
1072,1073
1073,1074
1073,1075
1074,1075
1074,1076
1075,1076
1079,1080
1080,1081
1080,1082
1081,1082
1083,1084
1084,1085
1084,1086
1085,1086
1088,1089
1089,1090
1089,1091
1090,1091
1092,1093
1093,1094
1095,1096
1095,1097
1096,1097
1096,1098
1097,1098
1098,1099
1100,1101
1100,1102
1101,1102
1104,1105
1105,1106
1105,1107
1106,1107
1108,1109
1108,1110
1108,1111
1108,1112
1109,1110
1111,1112
1113,1114
1115,1116
1115,1117
1116,1117
1118,1119
1120,1121
1120,1122
1121,1122
1122,1123
1124,1125
1125,1126
1125,1127
1125,1128
1126,1127
1128,1129
1131,1132
1132,1133
1132,1134
1133,1134
1135,1136
1136,1137
1138,1139
1139,1140
1139,1141
1140,1141
1142,1143
1143,1144
1143,1145
1144,1145
1147,1148
1147,1149
1148,1149
1149,1150
1151,1152
1151,1153
1151,1154
1152,1153
1153,1154
1153,1155
1154,1155
1156,1157
1158,1159
1159,1160
1159,1161
1160,1161
1162,1163
1162,1164
1162,1165
1163,1164
1165,1166
1167,1168
1167,1169
1168,1169
1170,1171
1172,1173
1172,1174
1173,1174
1175,1176
1176,1177
1177,1178
1177,1179
1177,1180
1177,1181
1178,1179
1180,1181
1183,1184
1183,1185
1184,1185
1186,1187
1187,1188
1189,1190
1189,1191
1190,1191
1191,1192
1193,1194
1193,1195
1193,1196
1194,1195
1195,1196
1195,1197
1196,1197
1198,1199
1200,1201
1201,1202
1201,1203
1202,1203
1204,1205
1204,1206
1204,1207
1205,1206
1207,1208
1209,1210
1209,1211
1210,1211
1212,1213
1214,1215
1214,1216
1215,1216
1217,1218
1218,1219
1219,1220
1219,1221
1219,1222
1219,1223
1220,1221
1222,1223
1225,1226
1225,1227
1226,1227
1228,1229
1229,1230
1231,1232
1231,1233
1232,1233
1232,1234
1233,1234
1236,1237
1237,1238
1237,1239
1238,1239
1240,1241
1242,1243
1242,1244
1242,1245
1243,1244
1244,1245
1246,1247
1246,1248
1246,1249
1246,1250
1246,1251
1246,1252
1246,1253
1246,1254
1246,1255
1246,1256
1246,1257
1246,1258
1246,1259
1246,1260
1246,1261
1246,1262
1246,1263
1246,1264
1246,1265
1246,1266
1246,1267
1246,1268
1246,1269
1246,1270
1246,1271
1247,1248
1248,1249
1248,1250
1248,1251
1248,1252
1248,1253
1249,1250
1251,1252
1253,1254
1255,1256
1255,1257
1255,1258
1256,1257
1258,1259
1258,1260
1259,1260
1262,1263
1264,1265
1264,1266
1264,1267
1265,1266
1266,1267
1266,1268
1267,1268
1269,1270
1269,1271
1270,1271
1273,1274
1273,1275
1274,1275
1274,1276
1275,1276
1277,1278
1277,1279
1278,1279
1283,1284
1283,1285
1284,1285
1284,1286
1285,1286
1285,1287
1286,1287
1290,1291
1291,1292
1291,1293
1292,1293
1294,1295
1295,1296
1295,1297
1296,1297
1299,1300
1300,1301
1300,1302
1300,1303
1300,1304
1300,1305
1300,1306
1300,1307
1301,1302
1303,1304
1307,1308
1307,1309
1308,1309
1311,1312
1311,1313
1312,1313
1314,1315
1316,1317
1316,1318
1317,1318
1319,1320
1321,1322
1321,1323
1322,1323
1322,1324
1323,1324
1325,1326
1325,1327
1326,1327
1328,1329
1330,1331
1331,1332
1331,1333
1331,1334
1331,1335
1331,1336
1332,1333
1334,1335
1334,1336
1335,1336
1335,1337
1336,1337
1338,1339
1341,1342
1342,1343
1343,1344
1343,1345
1344,1345
1344,1346
1345,1346
1347,1348
1351,1352
1351,1353
1352,1353
1355,1356
1356,1357
1356,1358
1356,1359
1356,1360
1356,1361
1356,1362
1356,1363
1357,1358
1360,1361
1360,1362
1361,1362
1363,1364
1365,1366
1369,1370
1369,1371
1370,1371
1372,1373
1374,1375
1375,1376
1375,1377
1375,1378
1375,1379
1375,1380
1375,1381
1376,1377
1380,1381
1380,1382
1381,1382
1384,1385
1384,1386
1385,1386
1387,1388
1387,1389
1388,1389
1390,1391
1392,1393
1392,1394
1393,1394
1395,1396
1395,1397
1396,1397
1398,1399
1400,1401
1401,1402
1401,1403
1402,1403
1402,1404
1403,1404
1406,1407
1408,1409
1408,1410
1408,1411
1409,1410
1409,1411
1410,1411
1413,1414
1414,1415
1415,1416
1415,1417
1415,1418
1416,1417
1418,1419
1421,1422
1422,1423
1423,1424
1423,1425
1423,1426
1424,1425
1426,1427
1429,1430
1430,1431
1430,1432
1431,1432
1433,1434
1434,1435
1434,1436
1435,1436
1438,1439
1439,1440
1439,1441
1440,1441
1442,1443
1443,1444
1445,1446
1446,1447
1446,1448
1446,1449
1446,1450
1447,1448
1449,1450
1452,1453
1452,1454
1453,1454
1456,1457
1456,1458
1457,1458
1457,1459
1458,1459
1461,1462
1461,1463
1461,1464
1461,1465
1461,1466
1461,1467
1461,1468
1461,1469
1461,1470
1461,1471
1461,1472
1461,1473
1461,1474
1461,1475
1461,1476
1461,1477
1461,1478
1462,1463
1463,1464
1463,1465
1464,1465
1466,1467
1467,1468
1467,1469
1468,1469
1471,1472
1471,1473
1472,1473
1472,1474
1473,1474
1473,1475
1474,1475
1477,1478
1477,1479
1478,1479
1481,1482
1481,1483
1482,1483
1483,1484
1483,1485
1483,1486
1484,1485
1486,1487
1486,1488
1487,1488
1490,1491
1492,1493
1493,1494
1493,1495
1494,1495
1494,1496
1495,1496
1499,1500
1499,1501
1500,1501
1500,1502
1501,1502
1501,1503
1502,1503
1505,1506
1507,1508
1508,1509
1508,1510
1509,1510
1511,1512
1513,1514
1514,1515
1514,1516
1515,1516
1517,1518
1518,1519
1518,1520
1519,1520
1522,1523
1523,1524
1524,1525
1526,1527
1526,1528
1527,1528
1530,1531
1531,1532
1531,1533
1532,1533
1534,1535
1535,1536
1537,1538
1538,1539
1538,1540
1539,1540
1541,1542
1542,1543
1542,1544
1543,1544
1546,1547
1546,1548
1547,1548
1547,1549
1548,1549
1548,1550
1549,1550
1553,1554
1554,1555
1554,1556
1555,1556
1555,1557
1556,1557
1556,1558
1556,1559
1557,1558
1559,1560
1560,1561
1562,1563
1562,1564
1563,1564
1567,1568
1567,1569
1567,1570
1567,1571
1568,1569
1569,1570
1569,1571
1569,1572
1569,1573
1570,1571
1574,1575
1574,1576
1575,1576
1578,1579
1579,1580
1579,1581
1580,1581
1580,1582
1581,1582
1584,1585
1584,1586
1584,1587
1585,1586
1589,1590
1590,1591
1590,1592
1590,1593
1590,1594
1591,1592
1593,1594
1596,1597
1596,1598
1597,1598
1600,1601
1600,1602
1600,1603
1601,1602
1601,1603
1602,1603
1605,1606
1606,1607
1607,1608
1607,1609
1607,1610
1608,1609
1610,1611
1613,1614
1614,1615
1615,1616
1615,1617
1615,1618
1616,1617
1618,1619
1621,1622
1622,1623
1622,1624
1623,1624
1625,1626
1626,1627
1626,1628
1627,1628
1630,1631
1631,1632
1631,1633
1632,1633
1634,1635
1635,1636
1637,1638
1638,1639
1638,1640
1639,1640
1641,1642
1642,1643
1642,1644
1643,1644
1646,1647
1646,1648
1647,1648
1647,1649
1648,1649
1648,1650
1649,1650
1653,1654
1653,1655
1654,1655
1655,1656
1655,1657
1656,1657
1658,1659
1659,1660
1659,1661
1660,1661
1663,1664
1664,1665
1664,1666
1664,1667
1665,1666
1667,1668
1668,1669
1668,1670
1669,1670
1672,1673
1673,1674
1673,1675
1674,1675
1677,1678
1678,1679
1678,1680
1679,1680
1681,1682
1682,1683
1682,1684
1683,1684
1686,1687
1686,1688
1686,1689
1687,1688
1687,1689
1688,1689
1691,1692
1692,1693
1693,1694
1693,1695
1694,1695
1696,1697
1696,1698
1697,1698
1699,1700
1701,1702
1702,1703
1703,1704
1703,1705
1704,1705
1706,1707
1706,1708
1706,1709
1706,1710
1706,1711
1707,1708
1709,1710
1712,1713
1714,1715
1716,1717
1716,1718
1717,1718
1717,1719
1718,1719
1718,1720
1719,1720
1722,1723
1723,1724
1723,1725
1724,1725
1727,1728
1727,1729
1727,1730
1727,1731
1727,1732
1727,1733
1728,1729
1729,1730
1729,1731
1730,1731
1732,1733
1733,1734
1735,1736
1736,1737
1736,1738
1737,1738
1739,1740
1740,1741
1740,1742
1741,1742
1744,1745
1745,1746
1745,1747
1745,1748
1746,1747
1748,1749
1751,1752
1752,1753
1752,1754
1753,1754
1755,1756
1756,1757
1756,1758
1757,1758
1760,1761
1761,1762
1761,1763
1762,1763
1764,1765
1765,1766
1767,1768
1768,1769
1768,1770
1769,1770
1772,1773
1773,1774
1774,1775
1776,1777
1777,1778
1777,1779
1778,1779
1780,1781
1781,1782
1781,1783
1782,1783
1785,1786
1785,1787
1786,1787
1786,1788
1787,1788
1787,1789
1788,1789
1791,1792
1793,1794
1794,1795
1795,1796
1795,1797
1796,1797
1796,1798
1797,1798
1800,1801
1802,1803
1802,1804
1803,1804
1803,1805
1804,1805
1804,1806
1805,1806
1809,1810
1809,1811
1810,1811
1811,1812
1811,1813
1812,1813
1814,1815
1815,1816
1815,1817
1816,1817
1819,1820
1820,1821
1820,1822
1820,1823
1821,1822
1823,1824
1824,1825
1824,1826
1825,1826
1828,1829
1829,1830
1829,1831
1830,1831
1833,1834
1833,1835
1834,1835
1834,1836
1835,1836
1837,1838
1837,1839
1838,1839
1841,1842
1842,1843
1842,1844
1842,1845
1843,1844
1845,1846
1848,1849
1849,1850
1849,1851
1850,1851
1850,1852
1851,1852
1855,1856
1856,1857
1856,1858
1857,1858
1859,1860
1859,1861
1860,1861
1860,1862
1861,1862
1863,1864
1865,1866
1865,1867
1866,1867
1869,1870
1870,1871
1870,1872
1871,1872
1871,1873
1872,1873
1876,1877
1877,1878
1877,1879
1878,1879
1880,1881
1881,1882
1881,1883
1882,1883
1885,1886
1886,1887
1886,1888
1886,1889
1886,1890
1886,1891
1886,1892
1886,1893
1887,1888
1889,1890
1893,1894
1893,1895
1894,1895
1897,1898
1899,1900
1899,1901
1900,1901
1902,1903
1904,1905
1905,1906
1905,1907
1905,1908
1905,1909
1905,1910
1905,1911
1905,1912
1905,1913
1906,1907
1909,1910
1909,1911
1910,1911
1912,1913
1914,1915
1918,1919
1918,1920
1919,1920
1921,1922
1923,1924
1925,1926
1926,1927
1926,1928
1926,1929
1926,1930
1927,1928
1931,1932
1931,1933
1932,1933
1935,1936
1936,1937
1936,1938
1936,1939
1936,1940
1937,1938
1939,1940
1942,1943
1942,1944
1943,1944
1946,1947
1946,1948
1947,1948
1947,1949
1948,1949
1948,1950
1949,1950
1952,1953
1953,1954
1953,1955
1954,1955
1957,1958
1957,1959
1957,1960
1957,1961
1958,1959
1959,1960
1959,1961
1960,1961
1962,1963
1963,1964
1963,1965
1964,1965
1967,1968
1968,1969
1968,1970
1969,1970
1971,1972
1972,1973
1972,1974
1973,1974
1976,1977
1977,1978
1977,1979
1978,1979
1980,1981
1981,1982
1981,1983
1982,1983
1985,1986
1986,1987
1986,1988
1987,1988
1989,1990
1991,1992
1991,1993
1992,1993
1993,1994
1993,1995
1994,1995
1996,1997
1997,1998
1997,1999
1998,1999
2001,2002
2002,2003
2002,2004
2003,2004
2005,2006
2007,2008
2008,2009
2008,2010
2009,2010
2011,2012
2013,2014
2013,2015
2013,2016
2014,2015
2015,2016
2015,2017
2016,2017
2018,2019
2019,2020
2019,2021
2020,2021
2023,2024
2024,2025
2024,2026
2025,2026
2028,2029
2029,2030
2029,2031
2030,2031
2032,2033
2035,2036
2036,2037
2036,2038
2037,2038
2039,2040
2040,2041
2040,2042
2041,2042
2044,2045
2044,2046
2045,2046
2047,2048
2048,2049
2049,2050
2049,2051
2050,2051
2052,2053
2054,2055
2054,2056
2055,2056
2056,2057
2058,2059
2059,2060
2059,2061
2060,2061
2062,2063
2063,2064
2065,2066
2065,2067
2066,2067
2066,2068
2067,2068
2068,2069
2070,2071
2071,2072
2071,2073
2072,2073
2072,2074
2073,2074
2076,2077
2076,2078
2077,2078
2079,2080
2081,2082
2082,2083
2082,2084
2083,2084
2085,2086
2085,2087
2085,2088
2085,2089
2085,2090
2085,2091
2086,2087
2088,2089
2090,2091
2092,2093
2094,2095
2094,2096
2095,2096
2096,2097
2097,2098
2101,2102
2101,2103
2102,2103
2103,2104
2105,2106
2106,2107
2106,2108
2107,2108
2109,2110
2109,2111
2109,2112
2110,2111
2112,2113
2115,2116
2116,2117
2116,2118
2117,2118
2119,2120
2121,2122
2122,2123
-----nextToken-----
2,4,7,9,10,12,14,15,19,21,23,26,28,30,33,35,38,42,44,45,49,51,52,55,57,60,62,65,67,70,73,75,78,80,83,85,88,90,93,95,96,99,101,102,107,110,114,117,121,123,124,127,130,132,134,137,139,142,145,147,150,153,155,156,158,162,165,167,171,174,176,180,182,184,188,190,192,196,200,202,207,210,212,213,218,221,224,226,227,231,232,236,237,241,244,246,247,251,252,253,255,257,260,262,267,270,272,273,278,281,283,284,288,289,293,294,298,301,303,304,308,309,310,312,314,317,319,324,327,329,330,335,337,340,342,343,347,350,352,353,357,358,359,361,363,366,368,372,374,379,382,383,388,391,392,393,398,399,404,406,408,412,415,417,421,427,430,431,435,437,440,441,443,447,450,452,453,455,460,461,462,467,472,473,476,478,483,487,490,491,495,498,500,502,510,513,514,516,520,521,525,527,530,531,535,539,542,546,552,554,558,561,563,564,566,571,572,573,578,579,580,584,585,589,592,596,599,601,603,608,610,612,616,618,622,626,627,634,637,638,640,644,647,648,650,654,655,661,662,665,671,672,673,678,681,683,684,689,692,694,695,701,702,703,709,710,711,715,718,720,721,725,726,727,729,732,733,736,737,741,743,745,751,752,754,759,762,764,765,771,772,775,778,780,781,786,787,788,793,794,795,799,802,804,805,809,810,811,813,816,817,820,821,825,827,829,835,836,838,843,846,848,849,855,856,859,862,864,865,870,871,872,877,878,879,883,886,888,889,893,894,895,897,900,901,904,905,909,911,913,919,920,922,926,929,931,932,937,939,945,946,949,953,954,955,957,960,961,964,965,969,971,973,977,980,982,983,988,990,996,997,1000,1004,1005,1006,1008,1011,1012,1015,1016,1020,1022,1024,1028,1030,1034,1035,1040,1041,1045,1047,1051,1053,1057,1058,1061,1062,1068,1069,1070,1071,1076,1077,1078,1082,1086,1087,1091,1094,1099,1102,1103,1107,1110,1112,1114,1117,1119,1123,1127,1129,1130,1134,1137,1141,1145,1146,1150,1155,1157,1161,1164,1166,1169,1171,1174,1179,1181,1182,1185,1188,1192,1197,1199,1203,1206,1208,1211,1213,1216,1221,1223,1224,1227,1230,1234,1235,1239,1241,1245,1250,1252,1254,1257,1260,1261,1263,1268,1271,1272,1276,1279,1280,1281,1282,1287,1288,1289,1293,1297,1298,1302,1304,1305,1306,1309,1310,1313,1315,1318,1320,1324,1327,1329,1333,1337,1339,1340,1346,1348,1349,1350,1353,1354,1358,1359,1362,1364,1366,1367,1368,1371,1373,1377,1378,1379,1382,1383,1386,1389,1391,1394,1397,1399,1404,1405,1407,1411,1412,1417,1419,1420,1425,1427,1428,1432,1436,1437,1441,1444,1448,1450,1451,1454,1455,1459,1460,1465,1469,1470,1475,1476,1479,1480,1485,1488,1489,1491,1496,1497,1498,1503,1504,1506,1510,1512,1516,1520,1521,1525,1528,1529,1533,1536,1540,1544,1545,1550,1551,1552,1558,1561,1564,1565,1566,1571,1572,1573,1576,1577,1582,1583,1586,1587,1588,1592,1594,1595,1598,1599,1603,1604,1609,1611,1612,1617,1619,1620,1624,1628,1629,1633,1636,1640,1644,1645,1650,1651,1652,1657,1661,1662,1666,1670,1671,1675,1676,1680,1684,1685,1689,1690,1695,1698,1700,1705,1708,1710,1711,1713,1715,1720,1721,1725,1726,1731,1734,1738,1742,1743,1747,1749,1750,1754,1758,1759,1763,1766,1770,1771,1775,1779,1783,1784,1789,1790,1792,1798,1799,1801,1806,1807,1808,1813,1817,1818,1822,1826,1827,1831,1832,1836,1839,1840,1844,1846,1847,1852,1853,1854,1858,1862,1864,1867,1868,1873,1874,1875,1879,1883,1884,1888,1890,1891,1892,1895,1896,1898,1901,1903,1907,1908,1911,1913,1915,1916,1917,1920,1922,1924,1928,1929,1930,1933,1934,1938,1940,1941,1944,1945,1950,1951,1955,1956,1961,1965,1966,1970,1974,1975,1979,1983,1984,1988,1990,1995,1999,2000,2004,2006,2010,2012,2017,2021,2022,2026,2027,2031,2033,2034,2038,2042,2043,2046,2051,2053,2057,2061,2064,2069,2074,2075,2078,2080,2084,2087,2089,2091,2093,2098,2099,2100,2104,2108,2111,2113,2114,2118,2120,2123
-----computeFrom-----
160,161
160,162
169,170
169,171
216,217
216,218
229,230
229,231
234,235
234,236
239,240
239,241
286,287
286,288
291,292
291,293
296,297
296,298
345,346
345,347
396,397
396,398
401,402
401,403
410,411
410,412
445,446
445,447
456,457
456,458
464,465
464,466
469,470
469,471
470,471
470,472
474,475
474,476
506,507
506,508
556,557
556,558
567,568
567,569
575,576
575,577
582,583
582,584
629,630
629,631
630,631
630,632
658,659
658,660
698,699
698,700
706,707
706,708
713,714
713,715
748,749
748,750
768,769
768,770
783,784
783,785
790,791
790,792
797,798
797,799
832,833
832,834
852,853
852,854
867,868
867,869
874,875
874,876
881,882
881,883
916,917
916,918
924,925
924,926
942,943
942,944
975,976
975,977
993,994
993,995
1032,1033
1032,1034
1064,1065
1064,1066
1073,1074
1073,1075
1096,1097
1096,1098
1100,1101
1100,1102
1105,1106
1105,1107
1159,1160
1159,1161
1201,1202
1201,1203
1237,1238
1237,1239
1273,1274
1273,1275
1284,1285
1284,1286
1322,1323
1322,1324
1401,1402
1401,1403
1457,1458
1457,1459
1472,1473
1472,1474
1493,1494
1493,1495
1500,1501
1500,1502
1508,1509
1508,1510
1555,1556
1555,1557
1579,1580
1579,1581
1647,1648
1647,1649
1693,1694
1693,1695
1703,1704
1703,1705
1717,1718
1717,1719
1723,1724
1723,1725
1768,1769
1768,1770
1786,1787
1786,1788
1795,1796
1795,1797
1803,1804
1803,1805
1834,1835
1834,1836
1849,1850
1849,1851
1856,1857
1856,1858
1859,1860
1859,1861
1870,1871
1870,1872
1947,1948
1947,1949
2002,2003
2002,2004
2008,2009
2008,2010
2024,2025
2024,2026
2029,2030
2029,2031
2066,2067
2066,2068
2071,2072
2071,2073
2072,2073
2072,2074
2076,2077
2076,2078
2082,2083
2082,2084
2094,2095
2094,2096
2106,2107
2106,2108
-----guardedBy-----
231,236
406,417
520,530
654,2031
638,1945
786,793
787,794
870,877
871,878
1099,1107
1287,1297
1288,1298
1327,1346
1329,1348
1479,1496
1476,1497
1480,1489
1564,1619
1565,1583
1650,1675
1720,1758
1725,1770
1789,1798
1792,1799
1806,1831
1955,1990
2069,2084
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;IdExpression;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;IdExpression;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;IdExpression;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;IdExpression;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ProblemStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ProblemStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;IdExpression;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;BinaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;WhileStatement;BinaryExpression;UnaryExpression;IdExpression;Name;UnaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;UnaryExpression;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;ReferenceOperator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ProblemStatement;CompoundStatement;IfStatement;BinaryExpression;UnaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;BinaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ProblemStatement;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;BinaryExpression;UnaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;ExpressionStatement;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;UnaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;LiteralExpression;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;ConditionalExpression;UnaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;FunctionCallExpression;IdExpression;Name;IdExpression;Name;Name;UnaryExpression;UnaryExpression;FieldReference;FunctionCallExpression;IdExpression;Name;IdExpression;Name;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;WhileStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IfStatement;IdExpression;Name;BreakStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;FieldReference;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BreakStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;UnaryExpression;IdExpression;Name;UnaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;BinaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IfStatement;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;UnaryExpression;LiteralExpression;
-----ast_node-----
static int login_exec(struct ast_channel *chan, const char *data){	int res=0;	int tries = 0;	int max_login_tries = maxlogintries;	struct agent_pvt *p;	struct ast_module_user *u;	char user[AST_MAX_AGENT] = "";	char pass[AST_MAX_AGENT];	char agent[AST_MAX_AGENT] = "";	char xpass[AST_MAX_AGENT] = "";	char *errmsg;	char *parse;	AST_DECLARE_APP_ARGS(args,			     AST_APP_ARG(agent_id);			     AST_APP_ARG(options);			     AST_APP_ARG(extension);		);	const char *tmpoptions = NULL;	int play_announcement = 1;	char agent_goodbye[AST_MAX_FILENAME_LEN];	int update_cdr = updatecdr;	char *filename = "agent-loginok";	u = ast_module_user_add(chan);	parse = ast_strdupa(data);	AST_STANDARD_APP_ARGS(args, parse);	ast_copy_string(agent_goodbye, agentgoodbye, sizeof(agent_goodbye));	ast_channel_lock(chan);	/* Set Channel Specific Login Overrides */	if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTLMAXLOGINTRIES"))) {		max_login_tries = atoi(pbx_builtin_getvar_helper(chan, "AGENTMAXLOGINTRIES"));		if (max_login_tries < 0)			max_login_tries = 0;		tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTMAXLOGINTRIES");		ast_verb(3, "Saw variable AGENTMAXLOGINTRIES=%s, setting max_login_tries to: %d on Channel '%s'.\n",tmpoptions,max_login_tries,ast_channel_name(chan));	}	if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR"))) {		if (ast_true(pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR")))			update_cdr = 1;		else			update_cdr = 0;		tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR");		ast_verb(3, "Saw variable AGENTUPDATECDR=%s, setting update_cdr to: %d on Channel '%s'.\n",tmpoptions,update_cdr,ast_channel_name(chan));	}	if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTGOODBYE"))) {		strcpy(agent_goodbye, pbx_builtin_getvar_helper(chan, "AGENTGOODBYE"));		tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTGOODBYE");		ast_verb(3, "Saw variable AGENTGOODBYE=%s, setting agent_goodbye to: %s on Channel '%s'.\n",tmpoptions,agent_goodbye,ast_channel_name(chan));	}	ast_channel_unlock(chan);	/* End Channel Specific Login Overrides */	if (!ast_strlen_zero(args.options)) {		if (strchr(args.options, 's')) {			play_announcement = 0;		}	}	if (ast_channel_state(chan) != AST_STATE_UP)		res = ast_answer(chan);	if (!res) {		if (!ast_strlen_zero(args.agent_id))			ast_copy_string(user, args.agent_id, AST_MAX_AGENT);		else			res = ast_app_getdata(chan, "agent-user", user, sizeof(user) - 1, 0);	}	while (!res && (max_login_tries==0 || tries < max_login_tries)) {		tries++;		/* Check for password */		AST_LIST_LOCK(&agents);		AST_LIST_TRAVERSE(&agents, p, list) {			if (!strcmp(p->agent, user) && !p->pending)				ast_copy_string(xpass, p->password, sizeof(xpass));		}		AST_LIST_UNLOCK(&agents);		if (!res) {			if (!ast_strlen_zero(xpass))				res = ast_app_getdata(chan, "agent-pass", pass, sizeof(pass) - 1, 0);			else				pass[0] = '\0';		}		errmsg = "agent-incorrect";#if 0		ast_log(LOG_NOTICE, "user: %s, pass: %s\n", user, pass);#endif		/* Check again for accuracy */		AST_LIST_LOCK(&agents);		AST_LIST_TRAVERSE(&agents, p, list) {			int unlock_channel = 1;			ast_channel_lock(chan);			ast_mutex_lock(&p->lock);			if (!strcmp(p->agent, user) &&			    !strcmp(p->password, pass) && !p->pending) {				/* Ensure we can't be gotten until we're done */				p->lastdisc = ast_tvnow();				p->lastdisc.tv_sec++;				/* Set Channel Specific Agent Overrides */				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))) {					if (ast_true(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))) {						p->ackcall = 1;					} else {						p->ackcall = 0;					}					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTACKCALL");					ast_verb(3, "Saw variable AGENTACKCALL=%s, setting ackcall to: %d for Agent '%s'.\n", tmpoptions, p->ackcall, p->agent);					ast_set_flag(p, AGENT_FLAG_ACKCALL);				} else {					p->ackcall = ackcall;				}				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"))) {					p->autologoff = atoi(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"));					if (p->autologoff < 0)						p->autologoff = 0;					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF");					ast_verb(3, "Saw variable AGENTAUTOLOGOFF=%s, setting autologff to: %d for Agent '%s'.\n", tmpoptions, p->autologoff, p->agent);					ast_set_flag(p, AGENT_FLAG_AUTOLOGOFF);				} else {					p->autologoff = autologoff;				}				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"))) {					p->wrapuptime = atoi(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"));					if (p->wrapuptime < 0)						p->wrapuptime = 0;					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME");					ast_verb(3, "Saw variable AGENTWRAPUPTIME=%s, setting wrapuptime to: %d for Agent '%s'.\n", tmpoptions, p->wrapuptime, p->agent);					ast_set_flag(p, AGENT_FLAG_WRAPUPTIME);				} else {					p->wrapuptime = wrapuptime;				}				tmpoptions = pbx_builtin_getvar_helper(chan, "AGENTACCEPTDTMF");				if (!ast_strlen_zero(tmpoptions)) {					p->acceptdtmf = *tmpoptions;					ast_verb(3, "Saw variable AGENTACCEPTDTMF=%s, setting acceptdtmf to: %c for Agent '%s'.\n", tmpoptions, p->acceptdtmf, p->agent);					ast_set_flag(p, AGENT_FLAG_ACCEPTDTMF);				}				tmpoptions = pbx_builtin_getvar_helper(chan, "AGENTENDDTMF");				if (!ast_strlen_zero(tmpoptions)) {					p->enddtmf = *tmpoptions;					ast_verb(3, "Saw variable AGENTENDDTMF=%s, setting enddtmf to: %c for Agent '%s'.\n", tmpoptions, p->enddtmf, p->agent);					ast_set_flag(p, AGENT_FLAG_ENDDTMF);				}				ast_channel_unlock(chan);				unlock_channel = 0;				/* End Channel Specific Agent Overrides */				if (!p->chan) {					long logintime;					snprintf(agent, sizeof(agent), "Agent/%s", p->agent);					p->logincallerid[0] = '\0';					p->acknowledged = 0;					ast_mutex_unlock(&p->lock);					AST_LIST_UNLOCK(&agents);					if( !res && play_announcement==1 )						res = ast_streamfile(chan, filename, ast_channel_language(chan));					if (!res)						ast_waitstream(chan, "");					AST_LIST_LOCK(&agents);					ast_mutex_lock(&p->lock);					if (!res) {						struct ast_format tmpfmt;						res = ast_set_read_format_from_cap(chan, ast_channel_nativeformats(chan));						if (res) {							ast_log(LOG_WARNING, "Unable to set read format to %s\n", ast_getformatname(&tmpfmt));						}					}					if (!res) {						struct ast_format tmpfmt;						res = ast_set_write_format_from_cap(chan, ast_channel_nativeformats(chan));						if (res) {							ast_log(LOG_WARNING, "Unable to set write format to %s\n", ast_getformatname(&tmpfmt));						}					}					/* Check once more just in case */					if (p->chan)						res = -1;					if (!res) {						ast_indicate_data(chan, AST_CONTROL_HOLD,							S_OR(p->moh, NULL),							!ast_strlen_zero(p->moh) ? strlen(p->moh) + 1 : 0);						if (p->loginstart == 0)							time(&p->loginstart);						/*** DOCUMENTATION							<managerEventInstance>								<synopsis>Raised when an Agent has logged in.</synopsis>								<syntax>									<parameter name="Agent">										<para>The name of the agent.</para>									</parameter>								</syntax>								<see-also>									<ref type="application">AgentLogin</ref>									<ref type="managerEvent">Agentlogoff</ref>								</see-also>							</managerEventInstance>						***/						manager_event(EVENT_FLAG_AGENT, "Agentlogin",							      "Agent: %s\r\n"							      "Channel: %s\r\n"							      "Uniqueid: %s\r\n",							      p->agent, ast_channel_name(chan), ast_channel_uniqueid(chan));						if (update_cdr && ast_channel_cdr(chan))							snprintf(ast_channel_cdr(chan)->channel, sizeof(ast_channel_cdr(chan)->channel), "Agent/%s", p->agent);						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGIN", "%s", ast_channel_name(chan));						ast_verb(2, "Agent '%s' logged in (format %s/%s)\n", p->agent,								    ast_getformatname(ast_channel_readformat(chan)), ast_getformatname(ast_channel_writeformat(chan)));						/* Login this channel and wait for it to go away */						p->chan = chan;						if (p->ackcall) {							check_beep(p, 0);						} else {							check_availability(p, 0);						}						ast_mutex_unlock(&p->lock);						AST_LIST_UNLOCK(&agents);						ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Agent/%s", p->agent);						while (res >= 0) {							ast_mutex_lock(&p->lock);							if (p->deferlogoff && p->chan) {								ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);								p->deferlogoff = 0;							}							if (p->chan != chan)								res = -1;							ast_mutex_unlock(&p->lock);							/* Yield here so other interested threads can kick in. */							sched_yield();							if (res)								break;							AST_LIST_LOCK(&agents);							ast_mutex_lock(&p->lock);							if (p->lastdisc.tv_sec) {								if (ast_tvdiff_ms(ast_tvnow(), p->lastdisc) > 0) {									ast_debug(1, "Wrapup time for %s expired!\n", p->agent);									p->lastdisc = ast_tv(0, 0);									ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Agent/%s", p->agent);									if (p->ackcall) {										check_beep(p, 0);									} else {										check_availability(p, 0);									}								}							}							ast_mutex_unlock(&p->lock);							AST_LIST_UNLOCK(&agents);							/*	Synchronize channel ownership between call to agent and itself. */							ast_mutex_lock(&p->lock);							if (p->app_lock_flag == 1) {								ast_cond_signal(&p->login_wait_cond);								ast_cond_wait(&p->app_complete_cond, &p->lock);							}							ast_mutex_unlock(&p->lock);							if (p->ackcall) {								res = agent_ack_sleep(p);							} else {								res = ast_safe_sleep_conditional( chan, 1000, agent_cont_sleep, p );							}							if (p->ackcall && (res == 1)) {								AST_LIST_LOCK(&agents);								ast_mutex_lock(&p->lock);								check_availability(p, 0);								ast_mutex_unlock(&p->lock);								AST_LIST_UNLOCK(&agents);								res = 0;							}							sched_yield();						}						ast_mutex_lock(&p->lock);						/* Log us off if appropriate */						if (p->chan == chan) {							p->chan = NULL;						}						/* Synchronize channel ownership between call to agent and itself. */						if (p->app_lock_flag == 1) {							ast_cond_signal(&p->login_wait_cond);							ast_cond_wait(&p->app_complete_cond, &p->lock);						}						if (res && p->owner)							ast_log(LOG_WARNING, "Huh?  We broke out when there was still an owner?\n");						p->acknowledged = 0;						logintime = time(NULL) - p->loginstart;						p->loginstart = 0;						ast_mutex_unlock(&p->lock);						/*** DOCUMENTATION							<managerEventInstance>								<synopsis>Raised when an Agent has logged off.</synopsis>								<syntax>									<xi:include xpointer="xpointer(/docs/managerEvent[@name='Agentlogin']/managerEventInstance/syntax/parameter[@name='Agent'])" />								</syntax>								<see-also>									<ref type="managerEvent">Agentlogin</ref>								</see-also>							</managerEventInstance>						***/						manager_event(EVENT_FLAG_AGENT, "Agentlogoff",							      "Agent: %s\r\n"							      "Logintime: %ld\r\n"							      "Uniqueid: %s\r\n",							      p->agent, logintime, ast_channel_uniqueid(chan));						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGOFF", "%s|%ld", ast_channel_name(chan), logintime);						ast_verb(2, "Agent '%s' logged out\n", p->agent);						/* If there is no owner, go ahead and kill it now */						ast_devstate_changed(AST_DEVICE_UNAVAILABLE, "Agent/%s", p->agent);						if (p->dead && !p->owner) {							ast_mutex_destroy(&p->lock);							ast_cond_destroy(&p->app_complete_cond);							ast_cond_destroy(&p->login_wait_cond);							ast_free(p);						}					}					else {						ast_mutex_unlock(&p->lock);						p = NULL;					}					res = -1;				} else {					ast_mutex_unlock(&p->lock);					errmsg = "agent-alreadyon";					p = NULL;				}				break;			}			ast_mutex_unlock(&p->lock);			if (unlock_channel) {				ast_channel_unlock(chan);			}		}		if (!p)			AST_LIST_UNLOCK(&agents);		if (!res && (max_login_tries==0 || tries < max_login_tries))			res = ast_app_getdata(chan, errmsg, user, sizeof(user) - 1, 0);	}	if (!res)		res = ast_safe_sleep(chan, 500);	ast_module_user_remove(u); 	return -1;}
static int
login_exec(struct ast_channel *chan, const char *data)
login_exec
struct ast_channel *chan
struct ast_channel
ast_channel
*chan
*
chan
const char *data
const char
*data
*
data
{	int res=0;	int tries = 0;	int max_login_tries = maxlogintries;	struct agent_pvt *p;	struct ast_module_user *u;	char user[AST_MAX_AGENT] = "";	char pass[AST_MAX_AGENT];	char agent[AST_MAX_AGENT] = "";	char xpass[AST_MAX_AGENT] = "";	char *errmsg;	char *parse;	AST_DECLARE_APP_ARGS(args,			     AST_APP_ARG(agent_id);			     AST_APP_ARG(options);			     AST_APP_ARG(extension);		);	const char *tmpoptions = NULL;	int play_announcement = 1;	char agent_goodbye[AST_MAX_FILENAME_LEN];	int update_cdr = updatecdr;	char *filename = "agent-loginok";	u = ast_module_user_add(chan);	parse = ast_strdupa(data);	AST_STANDARD_APP_ARGS(args, parse);	ast_copy_string(agent_goodbye, agentgoodbye, sizeof(agent_goodbye));	ast_channel_lock(chan);	/* Set Channel Specific Login Overrides */	if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTLMAXLOGINTRIES"))) {		max_login_tries = atoi(pbx_builtin_getvar_helper(chan, "AGENTMAXLOGINTRIES"));		if (max_login_tries < 0)			max_login_tries = 0;		tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTMAXLOGINTRIES");		ast_verb(3, "Saw variable AGENTMAXLOGINTRIES=%s, setting max_login_tries to: %d on Channel '%s'.\n",tmpoptions,max_login_tries,ast_channel_name(chan));	}	if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR"))) {		if (ast_true(pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR")))			update_cdr = 1;		else			update_cdr = 0;		tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR");		ast_verb(3, "Saw variable AGENTUPDATECDR=%s, setting update_cdr to: %d on Channel '%s'.\n",tmpoptions,update_cdr,ast_channel_name(chan));	}	if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTGOODBYE"))) {		strcpy(agent_goodbye, pbx_builtin_getvar_helper(chan, "AGENTGOODBYE"));		tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTGOODBYE");		ast_verb(3, "Saw variable AGENTGOODBYE=%s, setting agent_goodbye to: %s on Channel '%s'.\n",tmpoptions,agent_goodbye,ast_channel_name(chan));	}	ast_channel_unlock(chan);	/* End Channel Specific Login Overrides */	if (!ast_strlen_zero(args.options)) {		if (strchr(args.options, 's')) {			play_announcement = 0;		}	}	if (ast_channel_state(chan) != AST_STATE_UP)		res = ast_answer(chan);	if (!res) {		if (!ast_strlen_zero(args.agent_id))			ast_copy_string(user, args.agent_id, AST_MAX_AGENT);		else			res = ast_app_getdata(chan, "agent-user", user, sizeof(user) - 1, 0);	}	while (!res && (max_login_tries==0 || tries < max_login_tries)) {		tries++;		/* Check for password */		AST_LIST_LOCK(&agents);		AST_LIST_TRAVERSE(&agents, p, list) {			if (!strcmp(p->agent, user) && !p->pending)				ast_copy_string(xpass, p->password, sizeof(xpass));		}		AST_LIST_UNLOCK(&agents);		if (!res) {			if (!ast_strlen_zero(xpass))				res = ast_app_getdata(chan, "agent-pass", pass, sizeof(pass) - 1, 0);			else				pass[0] = '\0';		}		errmsg = "agent-incorrect";#if 0		ast_log(LOG_NOTICE, "user: %s, pass: %s\n", user, pass);#endif		/* Check again for accuracy */		AST_LIST_LOCK(&agents);		AST_LIST_TRAVERSE(&agents, p, list) {			int unlock_channel = 1;			ast_channel_lock(chan);			ast_mutex_lock(&p->lock);			if (!strcmp(p->agent, user) &&			    !strcmp(p->password, pass) && !p->pending) {				/* Ensure we can't be gotten until we're done */				p->lastdisc = ast_tvnow();				p->lastdisc.tv_sec++;				/* Set Channel Specific Agent Overrides */				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))) {					if (ast_true(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))) {						p->ackcall = 1;					} else {						p->ackcall = 0;					}					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTACKCALL");					ast_verb(3, "Saw variable AGENTACKCALL=%s, setting ackcall to: %d for Agent '%s'.\n", tmpoptions, p->ackcall, p->agent);					ast_set_flag(p, AGENT_FLAG_ACKCALL);				} else {					p->ackcall = ackcall;				}				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"))) {					p->autologoff = atoi(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"));					if (p->autologoff < 0)						p->autologoff = 0;					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF");					ast_verb(3, "Saw variable AGENTAUTOLOGOFF=%s, setting autologff to: %d for Agent '%s'.\n", tmpoptions, p->autologoff, p->agent);					ast_set_flag(p, AGENT_FLAG_AUTOLOGOFF);				} else {					p->autologoff = autologoff;				}				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"))) {					p->wrapuptime = atoi(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"));					if (p->wrapuptime < 0)						p->wrapuptime = 0;					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME");					ast_verb(3, "Saw variable AGENTWRAPUPTIME=%s, setting wrapuptime to: %d for Agent '%s'.\n", tmpoptions, p->wrapuptime, p->agent);					ast_set_flag(p, AGENT_FLAG_WRAPUPTIME);				} else {					p->wrapuptime = wrapuptime;				}				tmpoptions = pbx_builtin_getvar_helper(chan, "AGENTACCEPTDTMF");				if (!ast_strlen_zero(tmpoptions)) {					p->acceptdtmf = *tmpoptions;					ast_verb(3, "Saw variable AGENTACCEPTDTMF=%s, setting acceptdtmf to: %c for Agent '%s'.\n", tmpoptions, p->acceptdtmf, p->agent);					ast_set_flag(p, AGENT_FLAG_ACCEPTDTMF);				}				tmpoptions = pbx_builtin_getvar_helper(chan, "AGENTENDDTMF");				if (!ast_strlen_zero(tmpoptions)) {					p->enddtmf = *tmpoptions;					ast_verb(3, "Saw variable AGENTENDDTMF=%s, setting enddtmf to: %c for Agent '%s'.\n", tmpoptions, p->enddtmf, p->agent);					ast_set_flag(p, AGENT_FLAG_ENDDTMF);				}				ast_channel_unlock(chan);				unlock_channel = 0;				/* End Channel Specific Agent Overrides */				if (!p->chan) {					long logintime;					snprintf(agent, sizeof(agent), "Agent/%s", p->agent);					p->logincallerid[0] = '\0';					p->acknowledged = 0;					ast_mutex_unlock(&p->lock);					AST_LIST_UNLOCK(&agents);					if( !res && play_announcement==1 )						res = ast_streamfile(chan, filename, ast_channel_language(chan));					if (!res)						ast_waitstream(chan, "");					AST_LIST_LOCK(&agents);					ast_mutex_lock(&p->lock);					if (!res) {						struct ast_format tmpfmt;						res = ast_set_read_format_from_cap(chan, ast_channel_nativeformats(chan));						if (res) {							ast_log(LOG_WARNING, "Unable to set read format to %s\n", ast_getformatname(&tmpfmt));						}					}					if (!res) {						struct ast_format tmpfmt;						res = ast_set_write_format_from_cap(chan, ast_channel_nativeformats(chan));						if (res) {							ast_log(LOG_WARNING, "Unable to set write format to %s\n", ast_getformatname(&tmpfmt));						}					}					/* Check once more just in case */					if (p->chan)						res = -1;					if (!res) {						ast_indicate_data(chan, AST_CONTROL_HOLD,							S_OR(p->moh, NULL),							!ast_strlen_zero(p->moh) ? strlen(p->moh) + 1 : 0);						if (p->loginstart == 0)							time(&p->loginstart);						/*** DOCUMENTATION							<managerEventInstance>								<synopsis>Raised when an Agent has logged in.</synopsis>								<syntax>									<parameter name="Agent">										<para>The name of the agent.</para>									</parameter>								</syntax>								<see-also>									<ref type="application">AgentLogin</ref>									<ref type="managerEvent">Agentlogoff</ref>								</see-also>							</managerEventInstance>						***/						manager_event(EVENT_FLAG_AGENT, "Agentlogin",							      "Agent: %s\r\n"							      "Channel: %s\r\n"							      "Uniqueid: %s\r\n",							      p->agent, ast_channel_name(chan), ast_channel_uniqueid(chan));						if (update_cdr && ast_channel_cdr(chan))							snprintf(ast_channel_cdr(chan)->channel, sizeof(ast_channel_cdr(chan)->channel), "Agent/%s", p->agent);						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGIN", "%s", ast_channel_name(chan));						ast_verb(2, "Agent '%s' logged in (format %s/%s)\n", p->agent,								    ast_getformatname(ast_channel_readformat(chan)), ast_getformatname(ast_channel_writeformat(chan)));						/* Login this channel and wait for it to go away */						p->chan = chan;						if (p->ackcall) {							check_beep(p, 0);						} else {							check_availability(p, 0);						}						ast_mutex_unlock(&p->lock);						AST_LIST_UNLOCK(&agents);						ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Agent/%s", p->agent);						while (res >= 0) {							ast_mutex_lock(&p->lock);							if (p->deferlogoff && p->chan) {								ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);								p->deferlogoff = 0;							}							if (p->chan != chan)								res = -1;							ast_mutex_unlock(&p->lock);							/* Yield here so other interested threads can kick in. */							sched_yield();							if (res)								break;							AST_LIST_LOCK(&agents);							ast_mutex_lock(&p->lock);							if (p->lastdisc.tv_sec) {								if (ast_tvdiff_ms(ast_tvnow(), p->lastdisc) > 0) {									ast_debug(1, "Wrapup time for %s expired!\n", p->agent);									p->lastdisc = ast_tv(0, 0);									ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Agent/%s", p->agent);									if (p->ackcall) {										check_beep(p, 0);									} else {										check_availability(p, 0);									}								}							}							ast_mutex_unlock(&p->lock);							AST_LIST_UNLOCK(&agents);							/*	Synchronize channel ownership between call to agent and itself. */							ast_mutex_lock(&p->lock);							if (p->app_lock_flag == 1) {								ast_cond_signal(&p->login_wait_cond);								ast_cond_wait(&p->app_complete_cond, &p->lock);							}							ast_mutex_unlock(&p->lock);							if (p->ackcall) {								res = agent_ack_sleep(p);							} else {								res = ast_safe_sleep_conditional( chan, 1000, agent_cont_sleep, p );							}							if (p->ackcall && (res == 1)) {								AST_LIST_LOCK(&agents);								ast_mutex_lock(&p->lock);								check_availability(p, 0);								ast_mutex_unlock(&p->lock);								AST_LIST_UNLOCK(&agents);								res = 0;							}							sched_yield();						}						ast_mutex_lock(&p->lock);						/* Log us off if appropriate */						if (p->chan == chan) {							p->chan = NULL;						}						/* Synchronize channel ownership between call to agent and itself. */						if (p->app_lock_flag == 1) {							ast_cond_signal(&p->login_wait_cond);							ast_cond_wait(&p->app_complete_cond, &p->lock);						}						if (res && p->owner)							ast_log(LOG_WARNING, "Huh?  We broke out when there was still an owner?\n");						p->acknowledged = 0;						logintime = time(NULL) - p->loginstart;						p->loginstart = 0;						ast_mutex_unlock(&p->lock);						/*** DOCUMENTATION							<managerEventInstance>								<synopsis>Raised when an Agent has logged off.</synopsis>								<syntax>									<xi:include xpointer="xpointer(/docs/managerEvent[@name='Agentlogin']/managerEventInstance/syntax/parameter[@name='Agent'])" />								</syntax>								<see-also>									<ref type="managerEvent">Agentlogin</ref>								</see-also>							</managerEventInstance>						***/						manager_event(EVENT_FLAG_AGENT, "Agentlogoff",							      "Agent: %s\r\n"							      "Logintime: %ld\r\n"							      "Uniqueid: %s\r\n",							      p->agent, logintime, ast_channel_uniqueid(chan));						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGOFF", "%s|%ld", ast_channel_name(chan), logintime);						ast_verb(2, "Agent '%s' logged out\n", p->agent);						/* If there is no owner, go ahead and kill it now */						ast_devstate_changed(AST_DEVICE_UNAVAILABLE, "Agent/%s", p->agent);						if (p->dead && !p->owner) {							ast_mutex_destroy(&p->lock);							ast_cond_destroy(&p->app_complete_cond);							ast_cond_destroy(&p->login_wait_cond);							ast_free(p);						}					}					else {						ast_mutex_unlock(&p->lock);						p = NULL;					}					res = -1;				} else {					ast_mutex_unlock(&p->lock);					errmsg = "agent-alreadyon";					p = NULL;				}				break;			}			ast_mutex_unlock(&p->lock);			if (unlock_channel) {				ast_channel_unlock(chan);			}		}		if (!p)			AST_LIST_UNLOCK(&agents);		if (!res && (max_login_tries==0 || tries < max_login_tries))			res = ast_app_getdata(chan, errmsg, user, sizeof(user) - 1, 0);	}	if (!res)		res = ast_safe_sleep(chan, 500);	ast_module_user_remove(u); 	return -1;}
int res=0;
int res=0;
int
res=0
res
=0
0
int tries = 0;
int tries = 0;
int
tries = 0
tries
= 0
0
int max_login_tries = maxlogintries;
int max_login_tries = maxlogintries;
int
max_login_tries = maxlogintries
max_login_tries
= maxlogintries
maxlogintries
maxlogintries
struct agent_pvt *p;
struct agent_pvt *p;
struct agent_pvt
agent_pvt
*p
*
p
struct ast_module_user *u;
struct ast_module_user *u;
struct ast_module_user
ast_module_user
*u
*
u
char user[AST_MAX_AGENT] = "";
char user[AST_MAX_AGENT] = "";
char
user[AST_MAX_AGENT] = ""
user
[AST_MAX_AGENT]
AST_MAX_AGENT
AST_MAX_AGENT
= ""
""
char pass[AST_MAX_AGENT];
char pass[AST_MAX_AGENT];
char
pass[AST_MAX_AGENT]
pass
[AST_MAX_AGENT]
AST_MAX_AGENT
AST_MAX_AGENT
char agent[AST_MAX_AGENT] = "";
char agent[AST_MAX_AGENT] = "";
char
agent[AST_MAX_AGENT] = ""
agent
[AST_MAX_AGENT]
AST_MAX_AGENT
AST_MAX_AGENT
= ""
""
char xpass[AST_MAX_AGENT] = "";
char xpass[AST_MAX_AGENT] = "";
char
xpass[AST_MAX_AGENT] = ""
xpass
[AST_MAX_AGENT]
AST_MAX_AGENT
AST_MAX_AGENT
= ""
""
char *errmsg;
char *errmsg;
char
*errmsg
*
errmsg
char *parse;
char *parse;
char
*parse
*
parse
AST_DECLARE_APP_ARGS(args,			     AST_APP_ARG(agent_id);
AST_APP_ARG(options);
AST_APP_ARG(options);
AST_APP_ARG
AST_APP_ARG
(options)
options
options
AST_APP_ARG(extension);
AST_APP_ARG(extension);
AST_APP_ARG
AST_APP_ARG
(extension)
extension
extension
);
const char *tmpoptions = NULL;
const char *tmpoptions = NULL;
const char
*tmpoptions = NULL
*
tmpoptions
= NULL
NULL
NULL
int play_announcement = 1;
int play_announcement = 1;
int
play_announcement = 1
play_announcement
= 1
1
char agent_goodbye[AST_MAX_FILENAME_LEN];
char agent_goodbye[AST_MAX_FILENAME_LEN];
char
agent_goodbye[AST_MAX_FILENAME_LEN]
agent_goodbye
[AST_MAX_FILENAME_LEN]
AST_MAX_FILENAME_LEN
AST_MAX_FILENAME_LEN
int update_cdr = updatecdr;
int update_cdr = updatecdr;
int
update_cdr = updatecdr
update_cdr
= updatecdr
updatecdr
updatecdr
char *filename = "agent-loginok";
char *filename = "agent-loginok";
char
*filename = "agent-loginok"
*
filename
= "agent-loginok"
"agent-loginok"
u = ast_module_user_add(chan);
u = ast_module_user_add(chan)
u
u
ast_module_user_add(chan)
ast_module_user_add
ast_module_user_add
chan
chan
parse = ast_strdupa(data);
parse = ast_strdupa(data)
parse
parse
ast_strdupa(data)
ast_strdupa
ast_strdupa
data
data
AST_STANDARD_APP_ARGS(args, parse);
AST_STANDARD_APP_ARGS(args, parse)
AST_STANDARD_APP_ARGS
AST_STANDARD_APP_ARGS
args
args
parse
parse
ast_copy_string(agent_goodbye, agentgoodbye, sizeof(agent_goodbye));
ast_copy_string(agent_goodbye, agentgoodbye, sizeof(agent_goodbye))
ast_copy_string
ast_copy_string
agent_goodbye
agent_goodbye
agentgoodbye
agentgoodbye
sizeof(agent_goodbye)
(agent_goodbye)
agent_goodbye
agent_goodbye
ast_channel_lock(chan);
ast_channel_lock(chan)
ast_channel_lock
ast_channel_lock
chan
chan
if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTLMAXLOGINTRIES"))) {		max_login_tries = atoi(pbx_builtin_getvar_helper(chan, "AGENTMAXLOGINTRIES"));		if (max_login_tries < 0)			max_login_tries = 0;		tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTMAXLOGINTRIES");		ast_verb(3, "Saw variable AGENTMAXLOGINTRIES=%s, setting max_login_tries to: %d on Channel '%s'.\n",tmpoptions,max_login_tries,ast_channel_name(chan));	}
!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTLMAXLOGINTRIES"))
ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTLMAXLOGINTRIES"))
ast_strlen_zero
ast_strlen_zero
pbx_builtin_getvar_helper(chan, "AGENTLMAXLOGINTRIES")
pbx_builtin_getvar_helper
pbx_builtin_getvar_helper
chan
chan
"AGENTLMAXLOGINTRIES"
{		max_login_tries = atoi(pbx_builtin_getvar_helper(chan, "AGENTMAXLOGINTRIES"));		if (max_login_tries < 0)			max_login_tries = 0;		tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTMAXLOGINTRIES");		ast_verb(3, "Saw variable AGENTMAXLOGINTRIES=%s, setting max_login_tries to: %d on Channel '%s'.\n",tmpoptions,max_login_tries,ast_channel_name(chan));	}
max_login_tries = atoi(pbx_builtin_getvar_helper(chan, "AGENTMAXLOGINTRIES"));
max_login_tries = atoi(pbx_builtin_getvar_helper(chan, "AGENTMAXLOGINTRIES"))
max_login_tries
max_login_tries
atoi(pbx_builtin_getvar_helper(chan, "AGENTMAXLOGINTRIES"))
atoi
atoi
pbx_builtin_getvar_helper(chan, "AGENTMAXLOGINTRIES")
pbx_builtin_getvar_helper
pbx_builtin_getvar_helper
chan
chan
"AGENTMAXLOGINTRIES"
if (max_login_tries < 0)			max_login_tries = 0;
max_login_tries < 0
max_login_tries
max_login_tries
0
max_login_tries = 0;
max_login_tries = 0
max_login_tries
max_login_tries
0
tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTMAXLOGINTRIES");
tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTMAXLOGINTRIES")
tmpoptions
tmpoptions
pbx_builtin_getvar_helper(chan, "AGENTMAXLOGINTRIES")
pbx_builtin_getvar_helper
pbx_builtin_getvar_helper
chan
chan
"AGENTMAXLOGINTRIES"
ast_verb(3, "Saw variable AGENTMAXLOGINTRIES=%s, setting max_login_tries to: %d on Channel '%s'.\n",tmpoptions,max_login_tries,ast_channel_name(chan));
ast_verb(3, "Saw variable AGENTMAXLOGINTRIES=%s, setting max_login_tries to: %d on Channel '%s'.\n",tmpoptions,max_login_tries,ast_channel_name(chan))
ast_verb
ast_verb
3
"Saw variable AGENTMAXLOGINTRIES=%s, setting max_login_tries to: %d on Channel '%s'.\n"
tmpoptions
tmpoptions
max_login_tries
max_login_tries
ast_channel_name(chan)
ast_channel_name
ast_channel_name
chan
chan
if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR"))) {		if (ast_true(pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR")))			update_cdr = 1;		else			update_cdr = 0;		tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR");		ast_verb(3, "Saw variable AGENTUPDATECDR=%s, setting update_cdr to: %d on Channel '%s'.\n",tmpoptions,update_cdr,ast_channel_name(chan));	}
!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR"))
ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR"))
ast_strlen_zero
ast_strlen_zero
pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR")
pbx_builtin_getvar_helper
pbx_builtin_getvar_helper
chan
chan
"AGENTUPDATECDR"
{		if (ast_true(pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR")))			update_cdr = 1;		else			update_cdr = 0;		tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR");		ast_verb(3, "Saw variable AGENTUPDATECDR=%s, setting update_cdr to: %d on Channel '%s'.\n",tmpoptions,update_cdr,ast_channel_name(chan));	}
if (ast_true(pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR")))			update_cdr = 1;		else			update_cdr = 0;
ast_true(pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR"))
ast_true
ast_true
pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR")
pbx_builtin_getvar_helper
pbx_builtin_getvar_helper
chan
chan
"AGENTUPDATECDR"
update_cdr = 1;
update_cdr = 1
update_cdr
update_cdr
1
update_cdr = 0;
update_cdr = 0
update_cdr
update_cdr
0
tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR");
tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR")
tmpoptions
tmpoptions
pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR")
pbx_builtin_getvar_helper
pbx_builtin_getvar_helper
chan
chan
"AGENTUPDATECDR"
ast_verb(3, "Saw variable AGENTUPDATECDR=%s, setting update_cdr to: %d on Channel '%s'.\n",tmpoptions,update_cdr,ast_channel_name(chan));
ast_verb(3, "Saw variable AGENTUPDATECDR=%s, setting update_cdr to: %d on Channel '%s'.\n",tmpoptions,update_cdr,ast_channel_name(chan))
ast_verb
ast_verb
3
"Saw variable AGENTUPDATECDR=%s, setting update_cdr to: %d on Channel '%s'.\n"
tmpoptions
tmpoptions
update_cdr
update_cdr
ast_channel_name(chan)
ast_channel_name
ast_channel_name
chan
chan
if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTGOODBYE"))) {		strcpy(agent_goodbye, pbx_builtin_getvar_helper(chan, "AGENTGOODBYE"));		tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTGOODBYE");		ast_verb(3, "Saw variable AGENTGOODBYE=%s, setting agent_goodbye to: %s on Channel '%s'.\n",tmpoptions,agent_goodbye,ast_channel_name(chan));	}
!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTGOODBYE"))
ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTGOODBYE"))
ast_strlen_zero
ast_strlen_zero
pbx_builtin_getvar_helper(chan, "AGENTGOODBYE")
pbx_builtin_getvar_helper
pbx_builtin_getvar_helper
chan
chan
"AGENTGOODBYE"
{		strcpy(agent_goodbye, pbx_builtin_getvar_helper(chan, "AGENTGOODBYE"));		tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTGOODBYE");		ast_verb(3, "Saw variable AGENTGOODBYE=%s, setting agent_goodbye to: %s on Channel '%s'.\n",tmpoptions,agent_goodbye,ast_channel_name(chan));	}
strcpy(agent_goodbye, pbx_builtin_getvar_helper(chan, "AGENTGOODBYE"));
strcpy(agent_goodbye, pbx_builtin_getvar_helper(chan, "AGENTGOODBYE"))
strcpy
strcpy
agent_goodbye
agent_goodbye
pbx_builtin_getvar_helper(chan, "AGENTGOODBYE")
pbx_builtin_getvar_helper
pbx_builtin_getvar_helper
chan
chan
"AGENTGOODBYE"
tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTGOODBYE");
tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTGOODBYE")
tmpoptions
tmpoptions
pbx_builtin_getvar_helper(chan, "AGENTGOODBYE")
pbx_builtin_getvar_helper
pbx_builtin_getvar_helper
chan
chan
"AGENTGOODBYE"
ast_verb(3, "Saw variable AGENTGOODBYE=%s, setting agent_goodbye to: %s on Channel '%s'.\n",tmpoptions,agent_goodbye,ast_channel_name(chan));
ast_verb(3, "Saw variable AGENTGOODBYE=%s, setting agent_goodbye to: %s on Channel '%s'.\n",tmpoptions,agent_goodbye,ast_channel_name(chan))
ast_verb
ast_verb
3
"Saw variable AGENTGOODBYE=%s, setting agent_goodbye to: %s on Channel '%s'.\n"
tmpoptions
tmpoptions
agent_goodbye
agent_goodbye
ast_channel_name(chan)
ast_channel_name
ast_channel_name
chan
chan
ast_channel_unlock(chan);
ast_channel_unlock(chan)
ast_channel_unlock
ast_channel_unlock
chan
chan
if (!ast_strlen_zero(args.options)) {		if (strchr(args.options, 's')) {			play_announcement = 0;		}	}
!ast_strlen_zero(args.options)
ast_strlen_zero(args.options)
ast_strlen_zero
ast_strlen_zero
args.options
args
args
options
{		if (strchr(args.options, 's')) {			play_announcement = 0;		}	}
if (strchr(args.options, 's')) {			play_announcement = 0;		}
strchr(args.options, 's')
strchr
strchr
args.options
args
args
options
's'
{			play_announcement = 0;		}
play_announcement = 0;
play_announcement = 0
play_announcement
play_announcement
0
if (ast_channel_state(chan) != AST_STATE_UP)		res = ast_answer(chan);
ast_channel_state(chan) != AST_STATE_UP
ast_channel_state(chan)
ast_channel_state
ast_channel_state
chan
chan
AST_STATE_UP
AST_STATE_UP
res = ast_answer(chan);
res = ast_answer(chan)
res
res
ast_answer(chan)
ast_answer
ast_answer
chan
chan
if (!res) {		if (!ast_strlen_zero(args.agent_id))			ast_copy_string(user, args.agent_id, AST_MAX_AGENT);		else			res = ast_app_getdata(chan, "agent-user", user, sizeof(user) - 1, 0);	}
!res
res
res
{		if (!ast_strlen_zero(args.agent_id))			ast_copy_string(user, args.agent_id, AST_MAX_AGENT);		else			res = ast_app_getdata(chan, "agent-user", user, sizeof(user) - 1, 0);	}
if (!ast_strlen_zero(args.agent_id))			ast_copy_string(user, args.agent_id, AST_MAX_AGENT);		else			res = ast_app_getdata(chan, "agent-user", user, sizeof(user) - 1, 0);
!ast_strlen_zero(args.agent_id)
ast_strlen_zero(args.agent_id)
ast_strlen_zero
ast_strlen_zero
args.agent_id
args
args
agent_id
ast_copy_string(user, args.agent_id, AST_MAX_AGENT);
ast_copy_string(user, args.agent_id, AST_MAX_AGENT)
ast_copy_string
ast_copy_string
user
user
args.agent_id
args
args
agent_id
AST_MAX_AGENT
AST_MAX_AGENT
res = ast_app_getdata(chan, "agent-user", user, sizeof(user) - 1, 0);
res = ast_app_getdata(chan, "agent-user", user, sizeof(user) - 1, 0)
res
res
ast_app_getdata(chan, "agent-user", user, sizeof(user) - 1, 0)
ast_app_getdata
ast_app_getdata
chan
chan
"agent-user"
user
user
sizeof(user) - 1
sizeof(user)
(user)
user
user
1
0
while (!res && (max_login_tries==0 || tries < max_login_tries)) {		tries++;		/* Check for password */		AST_LIST_LOCK(&agents);		AST_LIST_TRAVERSE(&agents, p, list) {			if (!strcmp(p->agent, user) && !p->pending)				ast_copy_string(xpass, p->password, sizeof(xpass));		}		AST_LIST_UNLOCK(&agents);		if (!res) {			if (!ast_strlen_zero(xpass))				res = ast_app_getdata(chan, "agent-pass", pass, sizeof(pass) - 1, 0);			else				pass[0] = '\0';		}		errmsg = "agent-incorrect";#if 0		ast_log(LOG_NOTICE, "user: %s, pass: %s\n", user, pass);#endif		/* Check again for accuracy */		AST_LIST_LOCK(&agents);		AST_LIST_TRAVERSE(&agents, p, list) {			int unlock_channel = 1;			ast_channel_lock(chan);			ast_mutex_lock(&p->lock);			if (!strcmp(p->agent, user) &&			    !strcmp(p->password, pass) && !p->pending) {				/* Ensure we can't be gotten until we're done */				p->lastdisc = ast_tvnow();				p->lastdisc.tv_sec++;				/* Set Channel Specific Agent Overrides */				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))) {					if (ast_true(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))) {						p->ackcall = 1;					} else {						p->ackcall = 0;					}					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTACKCALL");					ast_verb(3, "Saw variable AGENTACKCALL=%s, setting ackcall to: %d for Agent '%s'.\n", tmpoptions, p->ackcall, p->agent);					ast_set_flag(p, AGENT_FLAG_ACKCALL);				} else {					p->ackcall = ackcall;				}				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"))) {					p->autologoff = atoi(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"));					if (p->autologoff < 0)						p->autologoff = 0;					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF");					ast_verb(3, "Saw variable AGENTAUTOLOGOFF=%s, setting autologff to: %d for Agent '%s'.\n", tmpoptions, p->autologoff, p->agent);					ast_set_flag(p, AGENT_FLAG_AUTOLOGOFF);				} else {					p->autologoff = autologoff;				}				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"))) {					p->wrapuptime = atoi(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"));					if (p->wrapuptime < 0)						p->wrapuptime = 0;					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME");					ast_verb(3, "Saw variable AGENTWRAPUPTIME=%s, setting wrapuptime to: %d for Agent '%s'.\n", tmpoptions, p->wrapuptime, p->agent);					ast_set_flag(p, AGENT_FLAG_WRAPUPTIME);				} else {					p->wrapuptime = wrapuptime;				}				tmpoptions = pbx_builtin_getvar_helper(chan, "AGENTACCEPTDTMF");				if (!ast_strlen_zero(tmpoptions)) {					p->acceptdtmf = *tmpoptions;					ast_verb(3, "Saw variable AGENTACCEPTDTMF=%s, setting acceptdtmf to: %c for Agent '%s'.\n", tmpoptions, p->acceptdtmf, p->agent);					ast_set_flag(p, AGENT_FLAG_ACCEPTDTMF);				}				tmpoptions = pbx_builtin_getvar_helper(chan, "AGENTENDDTMF");				if (!ast_strlen_zero(tmpoptions)) {					p->enddtmf = *tmpoptions;					ast_verb(3, "Saw variable AGENTENDDTMF=%s, setting enddtmf to: %c for Agent '%s'.\n", tmpoptions, p->enddtmf, p->agent);					ast_set_flag(p, AGENT_FLAG_ENDDTMF);				}				ast_channel_unlock(chan);				unlock_channel = 0;				/* End Channel Specific Agent Overrides */				if (!p->chan) {					long logintime;					snprintf(agent, sizeof(agent), "Agent/%s", p->agent);					p->logincallerid[0] = '\0';					p->acknowledged = 0;					ast_mutex_unlock(&p->lock);					AST_LIST_UNLOCK(&agents);					if( !res && play_announcement==1 )						res = ast_streamfile(chan, filename, ast_channel_language(chan));					if (!res)						ast_waitstream(chan, "");					AST_LIST_LOCK(&agents);					ast_mutex_lock(&p->lock);					if (!res) {						struct ast_format tmpfmt;						res = ast_set_read_format_from_cap(chan, ast_channel_nativeformats(chan));						if (res) {							ast_log(LOG_WARNING, "Unable to set read format to %s\n", ast_getformatname(&tmpfmt));						}					}					if (!res) {						struct ast_format tmpfmt;						res = ast_set_write_format_from_cap(chan, ast_channel_nativeformats(chan));						if (res) {							ast_log(LOG_WARNING, "Unable to set write format to %s\n", ast_getformatname(&tmpfmt));						}					}					/* Check once more just in case */					if (p->chan)						res = -1;					if (!res) {						ast_indicate_data(chan, AST_CONTROL_HOLD,							S_OR(p->moh, NULL),							!ast_strlen_zero(p->moh) ? strlen(p->moh) + 1 : 0);						if (p->loginstart == 0)							time(&p->loginstart);						/*** DOCUMENTATION							<managerEventInstance>								<synopsis>Raised when an Agent has logged in.</synopsis>								<syntax>									<parameter name="Agent">										<para>The name of the agent.</para>									</parameter>								</syntax>								<see-also>									<ref type="application">AgentLogin</ref>									<ref type="managerEvent">Agentlogoff</ref>								</see-also>							</managerEventInstance>						***/						manager_event(EVENT_FLAG_AGENT, "Agentlogin",							      "Agent: %s\r\n"							      "Channel: %s\r\n"							      "Uniqueid: %s\r\n",							      p->agent, ast_channel_name(chan), ast_channel_uniqueid(chan));						if (update_cdr && ast_channel_cdr(chan))							snprintf(ast_channel_cdr(chan)->channel, sizeof(ast_channel_cdr(chan)->channel), "Agent/%s", p->agent);						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGIN", "%s", ast_channel_name(chan));						ast_verb(2, "Agent '%s' logged in (format %s/%s)\n", p->agent,								    ast_getformatname(ast_channel_readformat(chan)), ast_getformatname(ast_channel_writeformat(chan)));						/* Login this channel and wait for it to go away */						p->chan = chan;						if (p->ackcall) {							check_beep(p, 0);						} else {							check_availability(p, 0);						}						ast_mutex_unlock(&p->lock);						AST_LIST_UNLOCK(&agents);						ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Agent/%s", p->agent);						while (res >= 0) {							ast_mutex_lock(&p->lock);							if (p->deferlogoff && p->chan) {								ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);								p->deferlogoff = 0;							}							if (p->chan != chan)								res = -1;							ast_mutex_unlock(&p->lock);							/* Yield here so other interested threads can kick in. */							sched_yield();							if (res)								break;							AST_LIST_LOCK(&agents);							ast_mutex_lock(&p->lock);							if (p->lastdisc.tv_sec) {								if (ast_tvdiff_ms(ast_tvnow(), p->lastdisc) > 0) {									ast_debug(1, "Wrapup time for %s expired!\n", p->agent);									p->lastdisc = ast_tv(0, 0);									ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Agent/%s", p->agent);									if (p->ackcall) {										check_beep(p, 0);									} else {										check_availability(p, 0);									}								}							}							ast_mutex_unlock(&p->lock);							AST_LIST_UNLOCK(&agents);							/*	Synchronize channel ownership between call to agent and itself. */							ast_mutex_lock(&p->lock);							if (p->app_lock_flag == 1) {								ast_cond_signal(&p->login_wait_cond);								ast_cond_wait(&p->app_complete_cond, &p->lock);							}							ast_mutex_unlock(&p->lock);							if (p->ackcall) {								res = agent_ack_sleep(p);							} else {								res = ast_safe_sleep_conditional( chan, 1000, agent_cont_sleep, p );							}							if (p->ackcall && (res == 1)) {								AST_LIST_LOCK(&agents);								ast_mutex_lock(&p->lock);								check_availability(p, 0);								ast_mutex_unlock(&p->lock);								AST_LIST_UNLOCK(&agents);								res = 0;							}							sched_yield();						}						ast_mutex_lock(&p->lock);						/* Log us off if appropriate */						if (p->chan == chan) {							p->chan = NULL;						}						/* Synchronize channel ownership between call to agent and itself. */						if (p->app_lock_flag == 1) {							ast_cond_signal(&p->login_wait_cond);							ast_cond_wait(&p->app_complete_cond, &p->lock);						}						if (res && p->owner)							ast_log(LOG_WARNING, "Huh?  We broke out when there was still an owner?\n");						p->acknowledged = 0;						logintime = time(NULL) - p->loginstart;						p->loginstart = 0;						ast_mutex_unlock(&p->lock);						/*** DOCUMENTATION							<managerEventInstance>								<synopsis>Raised when an Agent has logged off.</synopsis>								<syntax>									<xi:include xpointer="xpointer(/docs/managerEvent[@name='Agentlogin']/managerEventInstance/syntax/parameter[@name='Agent'])" />								</syntax>								<see-also>									<ref type="managerEvent">Agentlogin</ref>								</see-also>							</managerEventInstance>						***/						manager_event(EVENT_FLAG_AGENT, "Agentlogoff",							      "Agent: %s\r\n"							      "Logintime: %ld\r\n"							      "Uniqueid: %s\r\n",							      p->agent, logintime, ast_channel_uniqueid(chan));						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGOFF", "%s|%ld", ast_channel_name(chan), logintime);						ast_verb(2, "Agent '%s' logged out\n", p->agent);						/* If there is no owner, go ahead and kill it now */						ast_devstate_changed(AST_DEVICE_UNAVAILABLE, "Agent/%s", p->agent);						if (p->dead && !p->owner) {							ast_mutex_destroy(&p->lock);							ast_cond_destroy(&p->app_complete_cond);							ast_cond_destroy(&p->login_wait_cond);							ast_free(p);						}					}					else {						ast_mutex_unlock(&p->lock);						p = NULL;					}					res = -1;				} else {					ast_mutex_unlock(&p->lock);					errmsg = "agent-alreadyon";					p = NULL;				}				break;			}			ast_mutex_unlock(&p->lock);			if (unlock_channel) {				ast_channel_unlock(chan);			}		}		if (!p)			AST_LIST_UNLOCK(&agents);		if (!res && (max_login_tries==0 || tries < max_login_tries))			res = ast_app_getdata(chan, errmsg, user, sizeof(user) - 1, 0);	}
!res && (max_login_tries==0 || tries < max_login_tries)
!res
res
res
(max_login_tries==0 || tries < max_login_tries)
max_login_tries==0 || tries < max_login_tries
max_login_tries==0
max_login_tries
max_login_tries
0
tries < max_login_tries
tries
tries
max_login_tries
max_login_tries
{		tries++;		/* Check for password */		AST_LIST_LOCK(&agents);		AST_LIST_TRAVERSE(&agents, p, list) {			if (!strcmp(p->agent, user) && !p->pending)				ast_copy_string(xpass, p->password, sizeof(xpass));		}		AST_LIST_UNLOCK(&agents);		if (!res) {			if (!ast_strlen_zero(xpass))				res = ast_app_getdata(chan, "agent-pass", pass, sizeof(pass) - 1, 0);			else				pass[0] = '\0';		}		errmsg = "agent-incorrect";#if 0		ast_log(LOG_NOTICE, "user: %s, pass: %s\n", user, pass);#endif		/* Check again for accuracy */		AST_LIST_LOCK(&agents);		AST_LIST_TRAVERSE(&agents, p, list) {			int unlock_channel = 1;			ast_channel_lock(chan);			ast_mutex_lock(&p->lock);			if (!strcmp(p->agent, user) &&			    !strcmp(p->password, pass) && !p->pending) {				/* Ensure we can't be gotten until we're done */				p->lastdisc = ast_tvnow();				p->lastdisc.tv_sec++;				/* Set Channel Specific Agent Overrides */				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))) {					if (ast_true(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))) {						p->ackcall = 1;					} else {						p->ackcall = 0;					}					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTACKCALL");					ast_verb(3, "Saw variable AGENTACKCALL=%s, setting ackcall to: %d for Agent '%s'.\n", tmpoptions, p->ackcall, p->agent);					ast_set_flag(p, AGENT_FLAG_ACKCALL);				} else {					p->ackcall = ackcall;				}				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"))) {					p->autologoff = atoi(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"));					if (p->autologoff < 0)						p->autologoff = 0;					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF");					ast_verb(3, "Saw variable AGENTAUTOLOGOFF=%s, setting autologff to: %d for Agent '%s'.\n", tmpoptions, p->autologoff, p->agent);					ast_set_flag(p, AGENT_FLAG_AUTOLOGOFF);				} else {					p->autologoff = autologoff;				}				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"))) {					p->wrapuptime = atoi(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"));					if (p->wrapuptime < 0)						p->wrapuptime = 0;					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME");					ast_verb(3, "Saw variable AGENTWRAPUPTIME=%s, setting wrapuptime to: %d for Agent '%s'.\n", tmpoptions, p->wrapuptime, p->agent);					ast_set_flag(p, AGENT_FLAG_WRAPUPTIME);				} else {					p->wrapuptime = wrapuptime;				}				tmpoptions = pbx_builtin_getvar_helper(chan, "AGENTACCEPTDTMF");				if (!ast_strlen_zero(tmpoptions)) {					p->acceptdtmf = *tmpoptions;					ast_verb(3, "Saw variable AGENTACCEPTDTMF=%s, setting acceptdtmf to: %c for Agent '%s'.\n", tmpoptions, p->acceptdtmf, p->agent);					ast_set_flag(p, AGENT_FLAG_ACCEPTDTMF);				}				tmpoptions = pbx_builtin_getvar_helper(chan, "AGENTENDDTMF");				if (!ast_strlen_zero(tmpoptions)) {					p->enddtmf = *tmpoptions;					ast_verb(3, "Saw variable AGENTENDDTMF=%s, setting enddtmf to: %c for Agent '%s'.\n", tmpoptions, p->enddtmf, p->agent);					ast_set_flag(p, AGENT_FLAG_ENDDTMF);				}				ast_channel_unlock(chan);				unlock_channel = 0;				/* End Channel Specific Agent Overrides */				if (!p->chan) {					long logintime;					snprintf(agent, sizeof(agent), "Agent/%s", p->agent);					p->logincallerid[0] = '\0';					p->acknowledged = 0;					ast_mutex_unlock(&p->lock);					AST_LIST_UNLOCK(&agents);					if( !res && play_announcement==1 )						res = ast_streamfile(chan, filename, ast_channel_language(chan));					if (!res)						ast_waitstream(chan, "");					AST_LIST_LOCK(&agents);					ast_mutex_lock(&p->lock);					if (!res) {						struct ast_format tmpfmt;						res = ast_set_read_format_from_cap(chan, ast_channel_nativeformats(chan));						if (res) {							ast_log(LOG_WARNING, "Unable to set read format to %s\n", ast_getformatname(&tmpfmt));						}					}					if (!res) {						struct ast_format tmpfmt;						res = ast_set_write_format_from_cap(chan, ast_channel_nativeformats(chan));						if (res) {							ast_log(LOG_WARNING, "Unable to set write format to %s\n", ast_getformatname(&tmpfmt));						}					}					/* Check once more just in case */					if (p->chan)						res = -1;					if (!res) {						ast_indicate_data(chan, AST_CONTROL_HOLD,							S_OR(p->moh, NULL),							!ast_strlen_zero(p->moh) ? strlen(p->moh) + 1 : 0);						if (p->loginstart == 0)							time(&p->loginstart);						/*** DOCUMENTATION							<managerEventInstance>								<synopsis>Raised when an Agent has logged in.</synopsis>								<syntax>									<parameter name="Agent">										<para>The name of the agent.</para>									</parameter>								</syntax>								<see-also>									<ref type="application">AgentLogin</ref>									<ref type="managerEvent">Agentlogoff</ref>								</see-also>							</managerEventInstance>						***/						manager_event(EVENT_FLAG_AGENT, "Agentlogin",							      "Agent: %s\r\n"							      "Channel: %s\r\n"							      "Uniqueid: %s\r\n",							      p->agent, ast_channel_name(chan), ast_channel_uniqueid(chan));						if (update_cdr && ast_channel_cdr(chan))							snprintf(ast_channel_cdr(chan)->channel, sizeof(ast_channel_cdr(chan)->channel), "Agent/%s", p->agent);						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGIN", "%s", ast_channel_name(chan));						ast_verb(2, "Agent '%s' logged in (format %s/%s)\n", p->agent,								    ast_getformatname(ast_channel_readformat(chan)), ast_getformatname(ast_channel_writeformat(chan)));						/* Login this channel and wait for it to go away */						p->chan = chan;						if (p->ackcall) {							check_beep(p, 0);						} else {							check_availability(p, 0);						}						ast_mutex_unlock(&p->lock);						AST_LIST_UNLOCK(&agents);						ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Agent/%s", p->agent);						while (res >= 0) {							ast_mutex_lock(&p->lock);							if (p->deferlogoff && p->chan) {								ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);								p->deferlogoff = 0;							}							if (p->chan != chan)								res = -1;							ast_mutex_unlock(&p->lock);							/* Yield here so other interested threads can kick in. */							sched_yield();							if (res)								break;							AST_LIST_LOCK(&agents);							ast_mutex_lock(&p->lock);							if (p->lastdisc.tv_sec) {								if (ast_tvdiff_ms(ast_tvnow(), p->lastdisc) > 0) {									ast_debug(1, "Wrapup time for %s expired!\n", p->agent);									p->lastdisc = ast_tv(0, 0);									ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Agent/%s", p->agent);									if (p->ackcall) {										check_beep(p, 0);									} else {										check_availability(p, 0);									}								}							}							ast_mutex_unlock(&p->lock);							AST_LIST_UNLOCK(&agents);							/*	Synchronize channel ownership between call to agent and itself. */							ast_mutex_lock(&p->lock);							if (p->app_lock_flag == 1) {								ast_cond_signal(&p->login_wait_cond);								ast_cond_wait(&p->app_complete_cond, &p->lock);							}							ast_mutex_unlock(&p->lock);							if (p->ackcall) {								res = agent_ack_sleep(p);							} else {								res = ast_safe_sleep_conditional( chan, 1000, agent_cont_sleep, p );							}							if (p->ackcall && (res == 1)) {								AST_LIST_LOCK(&agents);								ast_mutex_lock(&p->lock);								check_availability(p, 0);								ast_mutex_unlock(&p->lock);								AST_LIST_UNLOCK(&agents);								res = 0;							}							sched_yield();						}						ast_mutex_lock(&p->lock);						/* Log us off if appropriate */						if (p->chan == chan) {							p->chan = NULL;						}						/* Synchronize channel ownership between call to agent and itself. */						if (p->app_lock_flag == 1) {							ast_cond_signal(&p->login_wait_cond);							ast_cond_wait(&p->app_complete_cond, &p->lock);						}						if (res && p->owner)							ast_log(LOG_WARNING, "Huh?  We broke out when there was still an owner?\n");						p->acknowledged = 0;						logintime = time(NULL) - p->loginstart;						p->loginstart = 0;						ast_mutex_unlock(&p->lock);						/*** DOCUMENTATION							<managerEventInstance>								<synopsis>Raised when an Agent has logged off.</synopsis>								<syntax>									<xi:include xpointer="xpointer(/docs/managerEvent[@name='Agentlogin']/managerEventInstance/syntax/parameter[@name='Agent'])" />								</syntax>								<see-also>									<ref type="managerEvent">Agentlogin</ref>								</see-also>							</managerEventInstance>						***/						manager_event(EVENT_FLAG_AGENT, "Agentlogoff",							      "Agent: %s\r\n"							      "Logintime: %ld\r\n"							      "Uniqueid: %s\r\n",							      p->agent, logintime, ast_channel_uniqueid(chan));						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGOFF", "%s|%ld", ast_channel_name(chan), logintime);						ast_verb(2, "Agent '%s' logged out\n", p->agent);						/* If there is no owner, go ahead and kill it now */						ast_devstate_changed(AST_DEVICE_UNAVAILABLE, "Agent/%s", p->agent);						if (p->dead && !p->owner) {							ast_mutex_destroy(&p->lock);							ast_cond_destroy(&p->app_complete_cond);							ast_cond_destroy(&p->login_wait_cond);							ast_free(p);						}					}					else {						ast_mutex_unlock(&p->lock);						p = NULL;					}					res = -1;				} else {					ast_mutex_unlock(&p->lock);					errmsg = "agent-alreadyon";					p = NULL;				}				break;			}			ast_mutex_unlock(&p->lock);			if (unlock_channel) {				ast_channel_unlock(chan);			}		}		if (!p)			AST_LIST_UNLOCK(&agents);		if (!res && (max_login_tries==0 || tries < max_login_tries))			res = ast_app_getdata(chan, errmsg, user, sizeof(user) - 1, 0);	}
tries++;
tries++
tries
tries
AST_LIST_LOCK(&agents);
AST_LIST_LOCK(&agents);
AST_LIST_LOCK
AST_LIST_LOCK
(&agents)
&agents
&
agents
AST_LIST_TRAVERSE(&agents, p, list)
AST_LIST_TRAVERSE(&agents, p, list)
AST_LIST_TRAVERSE
AST_LIST_TRAVERSE
&agents
agents
agents
p
p
list
list
)
{			if (!strcmp(p->agent, user) && !p->pending)				ast_copy_string(xpass, p->password, sizeof(xpass));		}
if (!strcmp(p->agent, user) && !p->pending)				ast_copy_string(xpass, p->password, sizeof(xpass));
!strcmp(p->agent, user) && !p->pending
!strcmp(p->agent, user)
strcmp(p->agent, user)
strcmp
strcmp
p->agent
p
p
agent
user
user
!p->pending
p->pending
p
p
pending
ast_copy_string(xpass, p->password, sizeof(xpass));
ast_copy_string(xpass, p->password, sizeof(xpass))
ast_copy_string
ast_copy_string
xpass
xpass
p->password
p
p
password
sizeof(xpass)
(xpass)
xpass
xpass
AST_LIST_UNLOCK(&agents);
AST_LIST_UNLOCK(&agents)
AST_LIST_UNLOCK
AST_LIST_UNLOCK
&agents
agents
agents
if (!res) {			if (!ast_strlen_zero(xpass))				res = ast_app_getdata(chan, "agent-pass", pass, sizeof(pass) - 1, 0);			else				pass[0] = '\0';		}
!res
res
res
{			if (!ast_strlen_zero(xpass))				res = ast_app_getdata(chan, "agent-pass", pass, sizeof(pass) - 1, 0);			else				pass[0] = '\0';		}
if (!ast_strlen_zero(xpass))				res = ast_app_getdata(chan, "agent-pass", pass, sizeof(pass) - 1, 0);			else				pass[0] = '\0';
!ast_strlen_zero(xpass)
ast_strlen_zero(xpass)
ast_strlen_zero
ast_strlen_zero
xpass
xpass
res = ast_app_getdata(chan, "agent-pass", pass, sizeof(pass) - 1, 0);
res = ast_app_getdata(chan, "agent-pass", pass, sizeof(pass) - 1, 0)
res
res
ast_app_getdata(chan, "agent-pass", pass, sizeof(pass) - 1, 0)
ast_app_getdata
ast_app_getdata
chan
chan
"agent-pass"
pass
pass
sizeof(pass) - 1
sizeof(pass)
(pass)
pass
pass
1
0
pass[0] = '\0';
pass[0] = '\0'
pass[0]
pass
pass
0
'\0'
errmsg = "agent-incorrect";
errmsg = "agent-incorrect"
errmsg
errmsg
"agent-incorrect"
AST_LIST_LOCK(&agents);
AST_LIST_LOCK(&agents)
AST_LIST_LOCK
AST_LIST_LOCK
&agents
agents
agents
AST_LIST_TRAVERSE(&agents, p, list)
AST_LIST_TRAVERSE(&agents, p, list)
AST_LIST_TRAVERSE
AST_LIST_TRAVERSE
&agents
agents
agents
p
p
list
list
)
{			int unlock_channel = 1;			ast_channel_lock(chan);			ast_mutex_lock(&p->lock);			if (!strcmp(p->agent, user) &&			    !strcmp(p->password, pass) && !p->pending) {				/* Ensure we can't be gotten until we're done */				p->lastdisc = ast_tvnow();				p->lastdisc.tv_sec++;				/* Set Channel Specific Agent Overrides */				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))) {					if (ast_true(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))) {						p->ackcall = 1;					} else {						p->ackcall = 0;					}					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTACKCALL");					ast_verb(3, "Saw variable AGENTACKCALL=%s, setting ackcall to: %d for Agent '%s'.\n", tmpoptions, p->ackcall, p->agent);					ast_set_flag(p, AGENT_FLAG_ACKCALL);				} else {					p->ackcall = ackcall;				}				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"))) {					p->autologoff = atoi(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"));					if (p->autologoff < 0)						p->autologoff = 0;					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF");					ast_verb(3, "Saw variable AGENTAUTOLOGOFF=%s, setting autologff to: %d for Agent '%s'.\n", tmpoptions, p->autologoff, p->agent);					ast_set_flag(p, AGENT_FLAG_AUTOLOGOFF);				} else {					p->autologoff = autologoff;				}				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"))) {					p->wrapuptime = atoi(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"));					if (p->wrapuptime < 0)						p->wrapuptime = 0;					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME");					ast_verb(3, "Saw variable AGENTWRAPUPTIME=%s, setting wrapuptime to: %d for Agent '%s'.\n", tmpoptions, p->wrapuptime, p->agent);					ast_set_flag(p, AGENT_FLAG_WRAPUPTIME);				} else {					p->wrapuptime = wrapuptime;				}				tmpoptions = pbx_builtin_getvar_helper(chan, "AGENTACCEPTDTMF");				if (!ast_strlen_zero(tmpoptions)) {					p->acceptdtmf = *tmpoptions;					ast_verb(3, "Saw variable AGENTACCEPTDTMF=%s, setting acceptdtmf to: %c for Agent '%s'.\n", tmpoptions, p->acceptdtmf, p->agent);					ast_set_flag(p, AGENT_FLAG_ACCEPTDTMF);				}				tmpoptions = pbx_builtin_getvar_helper(chan, "AGENTENDDTMF");				if (!ast_strlen_zero(tmpoptions)) {					p->enddtmf = *tmpoptions;					ast_verb(3, "Saw variable AGENTENDDTMF=%s, setting enddtmf to: %c for Agent '%s'.\n", tmpoptions, p->enddtmf, p->agent);					ast_set_flag(p, AGENT_FLAG_ENDDTMF);				}				ast_channel_unlock(chan);				unlock_channel = 0;				/* End Channel Specific Agent Overrides */				if (!p->chan) {					long logintime;					snprintf(agent, sizeof(agent), "Agent/%s", p->agent);					p->logincallerid[0] = '\0';					p->acknowledged = 0;					ast_mutex_unlock(&p->lock);					AST_LIST_UNLOCK(&agents);					if( !res && play_announcement==1 )						res = ast_streamfile(chan, filename, ast_channel_language(chan));					if (!res)						ast_waitstream(chan, "");					AST_LIST_LOCK(&agents);					ast_mutex_lock(&p->lock);					if (!res) {						struct ast_format tmpfmt;						res = ast_set_read_format_from_cap(chan, ast_channel_nativeformats(chan));						if (res) {							ast_log(LOG_WARNING, "Unable to set read format to %s\n", ast_getformatname(&tmpfmt));						}					}					if (!res) {						struct ast_format tmpfmt;						res = ast_set_write_format_from_cap(chan, ast_channel_nativeformats(chan));						if (res) {							ast_log(LOG_WARNING, "Unable to set write format to %s\n", ast_getformatname(&tmpfmt));						}					}					/* Check once more just in case */					if (p->chan)						res = -1;					if (!res) {						ast_indicate_data(chan, AST_CONTROL_HOLD,							S_OR(p->moh, NULL),							!ast_strlen_zero(p->moh) ? strlen(p->moh) + 1 : 0);						if (p->loginstart == 0)							time(&p->loginstart);						/*** DOCUMENTATION							<managerEventInstance>								<synopsis>Raised when an Agent has logged in.</synopsis>								<syntax>									<parameter name="Agent">										<para>The name of the agent.</para>									</parameter>								</syntax>								<see-also>									<ref type="application">AgentLogin</ref>									<ref type="managerEvent">Agentlogoff</ref>								</see-also>							</managerEventInstance>						***/						manager_event(EVENT_FLAG_AGENT, "Agentlogin",							      "Agent: %s\r\n"							      "Channel: %s\r\n"							      "Uniqueid: %s\r\n",							      p->agent, ast_channel_name(chan), ast_channel_uniqueid(chan));						if (update_cdr && ast_channel_cdr(chan))							snprintf(ast_channel_cdr(chan)->channel, sizeof(ast_channel_cdr(chan)->channel), "Agent/%s", p->agent);						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGIN", "%s", ast_channel_name(chan));						ast_verb(2, "Agent '%s' logged in (format %s/%s)\n", p->agent,								    ast_getformatname(ast_channel_readformat(chan)), ast_getformatname(ast_channel_writeformat(chan)));						/* Login this channel and wait for it to go away */						p->chan = chan;						if (p->ackcall) {							check_beep(p, 0);						} else {							check_availability(p, 0);						}						ast_mutex_unlock(&p->lock);						AST_LIST_UNLOCK(&agents);						ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Agent/%s", p->agent);						while (res >= 0) {							ast_mutex_lock(&p->lock);							if (p->deferlogoff && p->chan) {								ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);								p->deferlogoff = 0;							}							if (p->chan != chan)								res = -1;							ast_mutex_unlock(&p->lock);							/* Yield here so other interested threads can kick in. */							sched_yield();							if (res)								break;							AST_LIST_LOCK(&agents);							ast_mutex_lock(&p->lock);							if (p->lastdisc.tv_sec) {								if (ast_tvdiff_ms(ast_tvnow(), p->lastdisc) > 0) {									ast_debug(1, "Wrapup time for %s expired!\n", p->agent);									p->lastdisc = ast_tv(0, 0);									ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Agent/%s", p->agent);									if (p->ackcall) {										check_beep(p, 0);									} else {										check_availability(p, 0);									}								}							}							ast_mutex_unlock(&p->lock);							AST_LIST_UNLOCK(&agents);							/*	Synchronize channel ownership between call to agent and itself. */							ast_mutex_lock(&p->lock);							if (p->app_lock_flag == 1) {								ast_cond_signal(&p->login_wait_cond);								ast_cond_wait(&p->app_complete_cond, &p->lock);							}							ast_mutex_unlock(&p->lock);							if (p->ackcall) {								res = agent_ack_sleep(p);							} else {								res = ast_safe_sleep_conditional( chan, 1000, agent_cont_sleep, p );							}							if (p->ackcall && (res == 1)) {								AST_LIST_LOCK(&agents);								ast_mutex_lock(&p->lock);								check_availability(p, 0);								ast_mutex_unlock(&p->lock);								AST_LIST_UNLOCK(&agents);								res = 0;							}							sched_yield();						}						ast_mutex_lock(&p->lock);						/* Log us off if appropriate */						if (p->chan == chan) {							p->chan = NULL;						}						/* Synchronize channel ownership between call to agent and itself. */						if (p->app_lock_flag == 1) {							ast_cond_signal(&p->login_wait_cond);							ast_cond_wait(&p->app_complete_cond, &p->lock);						}						if (res && p->owner)							ast_log(LOG_WARNING, "Huh?  We broke out when there was still an owner?\n");						p->acknowledged = 0;						logintime = time(NULL) - p->loginstart;						p->loginstart = 0;						ast_mutex_unlock(&p->lock);						/*** DOCUMENTATION							<managerEventInstance>								<synopsis>Raised when an Agent has logged off.</synopsis>								<syntax>									<xi:include xpointer="xpointer(/docs/managerEvent[@name='Agentlogin']/managerEventInstance/syntax/parameter[@name='Agent'])" />								</syntax>								<see-also>									<ref type="managerEvent">Agentlogin</ref>								</see-also>							</managerEventInstance>						***/						manager_event(EVENT_FLAG_AGENT, "Agentlogoff",							      "Agent: %s\r\n"							      "Logintime: %ld\r\n"							      "Uniqueid: %s\r\n",							      p->agent, logintime, ast_channel_uniqueid(chan));						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGOFF", "%s|%ld", ast_channel_name(chan), logintime);						ast_verb(2, "Agent '%s' logged out\n", p->agent);						/* If there is no owner, go ahead and kill it now */						ast_devstate_changed(AST_DEVICE_UNAVAILABLE, "Agent/%s", p->agent);						if (p->dead && !p->owner) {							ast_mutex_destroy(&p->lock);							ast_cond_destroy(&p->app_complete_cond);							ast_cond_destroy(&p->login_wait_cond);							ast_free(p);						}					}					else {						ast_mutex_unlock(&p->lock);						p = NULL;					}					res = -1;				} else {					ast_mutex_unlock(&p->lock);					errmsg = "agent-alreadyon";					p = NULL;				}				break;			}			ast_mutex_unlock(&p->lock);			if (unlock_channel) {				ast_channel_unlock(chan);			}		}
int unlock_channel = 1;
int unlock_channel = 1;
int
unlock_channel = 1
unlock_channel
= 1
1
ast_channel_lock(chan);
ast_channel_lock(chan)
ast_channel_lock
ast_channel_lock
chan
chan
ast_mutex_lock(&p->lock);
ast_mutex_lock(&p->lock)
ast_mutex_lock
ast_mutex_lock
&p->lock
p->lock
p
p
lock
if (!strcmp(p->agent, user) &&			    !strcmp(p->password, pass) && !p->pending) {				/* Ensure we can't be gotten until we're done */				p->lastdisc = ast_tvnow();				p->lastdisc.tv_sec++;				/* Set Channel Specific Agent Overrides */				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))) {					if (ast_true(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))) {						p->ackcall = 1;					} else {						p->ackcall = 0;					}					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTACKCALL");					ast_verb(3, "Saw variable AGENTACKCALL=%s, setting ackcall to: %d for Agent '%s'.\n", tmpoptions, p->ackcall, p->agent);					ast_set_flag(p, AGENT_FLAG_ACKCALL);				} else {					p->ackcall = ackcall;				}				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"))) {					p->autologoff = atoi(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"));					if (p->autologoff < 0)						p->autologoff = 0;					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF");					ast_verb(3, "Saw variable AGENTAUTOLOGOFF=%s, setting autologff to: %d for Agent '%s'.\n", tmpoptions, p->autologoff, p->agent);					ast_set_flag(p, AGENT_FLAG_AUTOLOGOFF);				} else {					p->autologoff = autologoff;				}				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"))) {					p->wrapuptime = atoi(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"));					if (p->wrapuptime < 0)						p->wrapuptime = 0;					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME");					ast_verb(3, "Saw variable AGENTWRAPUPTIME=%s, setting wrapuptime to: %d for Agent '%s'.\n", tmpoptions, p->wrapuptime, p->agent);					ast_set_flag(p, AGENT_FLAG_WRAPUPTIME);				} else {					p->wrapuptime = wrapuptime;				}				tmpoptions = pbx_builtin_getvar_helper(chan, "AGENTACCEPTDTMF");				if (!ast_strlen_zero(tmpoptions)) {					p->acceptdtmf = *tmpoptions;					ast_verb(3, "Saw variable AGENTACCEPTDTMF=%s, setting acceptdtmf to: %c for Agent '%s'.\n", tmpoptions, p->acceptdtmf, p->agent);					ast_set_flag(p, AGENT_FLAG_ACCEPTDTMF);				}				tmpoptions = pbx_builtin_getvar_helper(chan, "AGENTENDDTMF");				if (!ast_strlen_zero(tmpoptions)) {					p->enddtmf = *tmpoptions;					ast_verb(3, "Saw variable AGENTENDDTMF=%s, setting enddtmf to: %c for Agent '%s'.\n", tmpoptions, p->enddtmf, p->agent);					ast_set_flag(p, AGENT_FLAG_ENDDTMF);				}				ast_channel_unlock(chan);				unlock_channel = 0;				/* End Channel Specific Agent Overrides */				if (!p->chan) {					long logintime;					snprintf(agent, sizeof(agent), "Agent/%s", p->agent);					p->logincallerid[0] = '\0';					p->acknowledged = 0;					ast_mutex_unlock(&p->lock);					AST_LIST_UNLOCK(&agents);					if( !res && play_announcement==1 )						res = ast_streamfile(chan, filename, ast_channel_language(chan));					if (!res)						ast_waitstream(chan, "");					AST_LIST_LOCK(&agents);					ast_mutex_lock(&p->lock);					if (!res) {						struct ast_format tmpfmt;						res = ast_set_read_format_from_cap(chan, ast_channel_nativeformats(chan));						if (res) {							ast_log(LOG_WARNING, "Unable to set read format to %s\n", ast_getformatname(&tmpfmt));						}					}					if (!res) {						struct ast_format tmpfmt;						res = ast_set_write_format_from_cap(chan, ast_channel_nativeformats(chan));						if (res) {							ast_log(LOG_WARNING, "Unable to set write format to %s\n", ast_getformatname(&tmpfmt));						}					}					/* Check once more just in case */					if (p->chan)						res = -1;					if (!res) {						ast_indicate_data(chan, AST_CONTROL_HOLD,							S_OR(p->moh, NULL),							!ast_strlen_zero(p->moh) ? strlen(p->moh) + 1 : 0);						if (p->loginstart == 0)							time(&p->loginstart);						/*** DOCUMENTATION							<managerEventInstance>								<synopsis>Raised when an Agent has logged in.</synopsis>								<syntax>									<parameter name="Agent">										<para>The name of the agent.</para>									</parameter>								</syntax>								<see-also>									<ref type="application">AgentLogin</ref>									<ref type="managerEvent">Agentlogoff</ref>								</see-also>							</managerEventInstance>						***/						manager_event(EVENT_FLAG_AGENT, "Agentlogin",							      "Agent: %s\r\n"							      "Channel: %s\r\n"							      "Uniqueid: %s\r\n",							      p->agent, ast_channel_name(chan), ast_channel_uniqueid(chan));						if (update_cdr && ast_channel_cdr(chan))							snprintf(ast_channel_cdr(chan)->channel, sizeof(ast_channel_cdr(chan)->channel), "Agent/%s", p->agent);						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGIN", "%s", ast_channel_name(chan));						ast_verb(2, "Agent '%s' logged in (format %s/%s)\n", p->agent,								    ast_getformatname(ast_channel_readformat(chan)), ast_getformatname(ast_channel_writeformat(chan)));						/* Login this channel and wait for it to go away */						p->chan = chan;						if (p->ackcall) {							check_beep(p, 0);						} else {							check_availability(p, 0);						}						ast_mutex_unlock(&p->lock);						AST_LIST_UNLOCK(&agents);						ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Agent/%s", p->agent);						while (res >= 0) {							ast_mutex_lock(&p->lock);							if (p->deferlogoff && p->chan) {								ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);								p->deferlogoff = 0;							}							if (p->chan != chan)								res = -1;							ast_mutex_unlock(&p->lock);							/* Yield here so other interested threads can kick in. */							sched_yield();							if (res)								break;							AST_LIST_LOCK(&agents);							ast_mutex_lock(&p->lock);							if (p->lastdisc.tv_sec) {								if (ast_tvdiff_ms(ast_tvnow(), p->lastdisc) > 0) {									ast_debug(1, "Wrapup time for %s expired!\n", p->agent);									p->lastdisc = ast_tv(0, 0);									ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Agent/%s", p->agent);									if (p->ackcall) {										check_beep(p, 0);									} else {										check_availability(p, 0);									}								}							}							ast_mutex_unlock(&p->lock);							AST_LIST_UNLOCK(&agents);							/*	Synchronize channel ownership between call to agent and itself. */							ast_mutex_lock(&p->lock);							if (p->app_lock_flag == 1) {								ast_cond_signal(&p->login_wait_cond);								ast_cond_wait(&p->app_complete_cond, &p->lock);							}							ast_mutex_unlock(&p->lock);							if (p->ackcall) {								res = agent_ack_sleep(p);							} else {								res = ast_safe_sleep_conditional( chan, 1000, agent_cont_sleep, p );							}							if (p->ackcall && (res == 1)) {								AST_LIST_LOCK(&agents);								ast_mutex_lock(&p->lock);								check_availability(p, 0);								ast_mutex_unlock(&p->lock);								AST_LIST_UNLOCK(&agents);								res = 0;							}							sched_yield();						}						ast_mutex_lock(&p->lock);						/* Log us off if appropriate */						if (p->chan == chan) {							p->chan = NULL;						}						/* Synchronize channel ownership between call to agent and itself. */						if (p->app_lock_flag == 1) {							ast_cond_signal(&p->login_wait_cond);							ast_cond_wait(&p->app_complete_cond, &p->lock);						}						if (res && p->owner)							ast_log(LOG_WARNING, "Huh?  We broke out when there was still an owner?\n");						p->acknowledged = 0;						logintime = time(NULL) - p->loginstart;						p->loginstart = 0;						ast_mutex_unlock(&p->lock);						/*** DOCUMENTATION							<managerEventInstance>								<synopsis>Raised when an Agent has logged off.</synopsis>								<syntax>									<xi:include xpointer="xpointer(/docs/managerEvent[@name='Agentlogin']/managerEventInstance/syntax/parameter[@name='Agent'])" />								</syntax>								<see-also>									<ref type="managerEvent">Agentlogin</ref>								</see-also>							</managerEventInstance>						***/						manager_event(EVENT_FLAG_AGENT, "Agentlogoff",							      "Agent: %s\r\n"							      "Logintime: %ld\r\n"							      "Uniqueid: %s\r\n",							      p->agent, logintime, ast_channel_uniqueid(chan));						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGOFF", "%s|%ld", ast_channel_name(chan), logintime);						ast_verb(2, "Agent '%s' logged out\n", p->agent);						/* If there is no owner, go ahead and kill it now */						ast_devstate_changed(AST_DEVICE_UNAVAILABLE, "Agent/%s", p->agent);						if (p->dead && !p->owner) {							ast_mutex_destroy(&p->lock);							ast_cond_destroy(&p->app_complete_cond);							ast_cond_destroy(&p->login_wait_cond);							ast_free(p);						}					}					else {						ast_mutex_unlock(&p->lock);						p = NULL;					}					res = -1;				} else {					ast_mutex_unlock(&p->lock);					errmsg = "agent-alreadyon";					p = NULL;				}				break;			}
!strcmp(p->agent, user) &&			    !strcmp(p->password, pass) && !p->pending
!strcmp(p->agent, user) &&			    !strcmp(p->password, pass)
!strcmp(p->agent, user)
strcmp(p->agent, user)
strcmp
strcmp
p->agent
p
p
agent
user
user
!strcmp(p->password, pass)
strcmp(p->password, pass)
strcmp
strcmp
p->password
p
p
password
pass
pass
!p->pending
p->pending
p
p
pending
{				/* Ensure we can't be gotten until we're done */				p->lastdisc = ast_tvnow();				p->lastdisc.tv_sec++;				/* Set Channel Specific Agent Overrides */				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))) {					if (ast_true(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))) {						p->ackcall = 1;					} else {						p->ackcall = 0;					}					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTACKCALL");					ast_verb(3, "Saw variable AGENTACKCALL=%s, setting ackcall to: %d for Agent '%s'.\n", tmpoptions, p->ackcall, p->agent);					ast_set_flag(p, AGENT_FLAG_ACKCALL);				} else {					p->ackcall = ackcall;				}				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"))) {					p->autologoff = atoi(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"));					if (p->autologoff < 0)						p->autologoff = 0;					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF");					ast_verb(3, "Saw variable AGENTAUTOLOGOFF=%s, setting autologff to: %d for Agent '%s'.\n", tmpoptions, p->autologoff, p->agent);					ast_set_flag(p, AGENT_FLAG_AUTOLOGOFF);				} else {					p->autologoff = autologoff;				}				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"))) {					p->wrapuptime = atoi(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"));					if (p->wrapuptime < 0)						p->wrapuptime = 0;					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME");					ast_verb(3, "Saw variable AGENTWRAPUPTIME=%s, setting wrapuptime to: %d for Agent '%s'.\n", tmpoptions, p->wrapuptime, p->agent);					ast_set_flag(p, AGENT_FLAG_WRAPUPTIME);				} else {					p->wrapuptime = wrapuptime;				}				tmpoptions = pbx_builtin_getvar_helper(chan, "AGENTACCEPTDTMF");				if (!ast_strlen_zero(tmpoptions)) {					p->acceptdtmf = *tmpoptions;					ast_verb(3, "Saw variable AGENTACCEPTDTMF=%s, setting acceptdtmf to: %c for Agent '%s'.\n", tmpoptions, p->acceptdtmf, p->agent);					ast_set_flag(p, AGENT_FLAG_ACCEPTDTMF);				}				tmpoptions = pbx_builtin_getvar_helper(chan, "AGENTENDDTMF");				if (!ast_strlen_zero(tmpoptions)) {					p->enddtmf = *tmpoptions;					ast_verb(3, "Saw variable AGENTENDDTMF=%s, setting enddtmf to: %c for Agent '%s'.\n", tmpoptions, p->enddtmf, p->agent);					ast_set_flag(p, AGENT_FLAG_ENDDTMF);				}				ast_channel_unlock(chan);				unlock_channel = 0;				/* End Channel Specific Agent Overrides */				if (!p->chan) {					long logintime;					snprintf(agent, sizeof(agent), "Agent/%s", p->agent);					p->logincallerid[0] = '\0';					p->acknowledged = 0;					ast_mutex_unlock(&p->lock);					AST_LIST_UNLOCK(&agents);					if( !res && play_announcement==1 )						res = ast_streamfile(chan, filename, ast_channel_language(chan));					if (!res)						ast_waitstream(chan, "");					AST_LIST_LOCK(&agents);					ast_mutex_lock(&p->lock);					if (!res) {						struct ast_format tmpfmt;						res = ast_set_read_format_from_cap(chan, ast_channel_nativeformats(chan));						if (res) {							ast_log(LOG_WARNING, "Unable to set read format to %s\n", ast_getformatname(&tmpfmt));						}					}					if (!res) {						struct ast_format tmpfmt;						res = ast_set_write_format_from_cap(chan, ast_channel_nativeformats(chan));						if (res) {							ast_log(LOG_WARNING, "Unable to set write format to %s\n", ast_getformatname(&tmpfmt));						}					}					/* Check once more just in case */					if (p->chan)						res = -1;					if (!res) {						ast_indicate_data(chan, AST_CONTROL_HOLD,							S_OR(p->moh, NULL),							!ast_strlen_zero(p->moh) ? strlen(p->moh) + 1 : 0);						if (p->loginstart == 0)							time(&p->loginstart);						/*** DOCUMENTATION							<managerEventInstance>								<synopsis>Raised when an Agent has logged in.</synopsis>								<syntax>									<parameter name="Agent">										<para>The name of the agent.</para>									</parameter>								</syntax>								<see-also>									<ref type="application">AgentLogin</ref>									<ref type="managerEvent">Agentlogoff</ref>								</see-also>							</managerEventInstance>						***/						manager_event(EVENT_FLAG_AGENT, "Agentlogin",							      "Agent: %s\r\n"							      "Channel: %s\r\n"							      "Uniqueid: %s\r\n",							      p->agent, ast_channel_name(chan), ast_channel_uniqueid(chan));						if (update_cdr && ast_channel_cdr(chan))							snprintf(ast_channel_cdr(chan)->channel, sizeof(ast_channel_cdr(chan)->channel), "Agent/%s", p->agent);						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGIN", "%s", ast_channel_name(chan));						ast_verb(2, "Agent '%s' logged in (format %s/%s)\n", p->agent,								    ast_getformatname(ast_channel_readformat(chan)), ast_getformatname(ast_channel_writeformat(chan)));						/* Login this channel and wait for it to go away */						p->chan = chan;						if (p->ackcall) {							check_beep(p, 0);						} else {							check_availability(p, 0);						}						ast_mutex_unlock(&p->lock);						AST_LIST_UNLOCK(&agents);						ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Agent/%s", p->agent);						while (res >= 0) {							ast_mutex_lock(&p->lock);							if (p->deferlogoff && p->chan) {								ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);								p->deferlogoff = 0;							}							if (p->chan != chan)								res = -1;							ast_mutex_unlock(&p->lock);							/* Yield here so other interested threads can kick in. */							sched_yield();							if (res)								break;							AST_LIST_LOCK(&agents);							ast_mutex_lock(&p->lock);							if (p->lastdisc.tv_sec) {								if (ast_tvdiff_ms(ast_tvnow(), p->lastdisc) > 0) {									ast_debug(1, "Wrapup time for %s expired!\n", p->agent);									p->lastdisc = ast_tv(0, 0);									ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Agent/%s", p->agent);									if (p->ackcall) {										check_beep(p, 0);									} else {										check_availability(p, 0);									}								}							}							ast_mutex_unlock(&p->lock);							AST_LIST_UNLOCK(&agents);							/*	Synchronize channel ownership between call to agent and itself. */							ast_mutex_lock(&p->lock);							if (p->app_lock_flag == 1) {								ast_cond_signal(&p->login_wait_cond);								ast_cond_wait(&p->app_complete_cond, &p->lock);							}							ast_mutex_unlock(&p->lock);							if (p->ackcall) {								res = agent_ack_sleep(p);							} else {								res = ast_safe_sleep_conditional( chan, 1000, agent_cont_sleep, p );							}							if (p->ackcall && (res == 1)) {								AST_LIST_LOCK(&agents);								ast_mutex_lock(&p->lock);								check_availability(p, 0);								ast_mutex_unlock(&p->lock);								AST_LIST_UNLOCK(&agents);								res = 0;							}							sched_yield();						}						ast_mutex_lock(&p->lock);						/* Log us off if appropriate */						if (p->chan == chan) {							p->chan = NULL;						}						/* Synchronize channel ownership between call to agent and itself. */						if (p->app_lock_flag == 1) {							ast_cond_signal(&p->login_wait_cond);							ast_cond_wait(&p->app_complete_cond, &p->lock);						}						if (res && p->owner)							ast_log(LOG_WARNING, "Huh?  We broke out when there was still an owner?\n");						p->acknowledged = 0;						logintime = time(NULL) - p->loginstart;						p->loginstart = 0;						ast_mutex_unlock(&p->lock);						/*** DOCUMENTATION							<managerEventInstance>								<synopsis>Raised when an Agent has logged off.</synopsis>								<syntax>									<xi:include xpointer="xpointer(/docs/managerEvent[@name='Agentlogin']/managerEventInstance/syntax/parameter[@name='Agent'])" />								</syntax>								<see-also>									<ref type="managerEvent">Agentlogin</ref>								</see-also>							</managerEventInstance>						***/						manager_event(EVENT_FLAG_AGENT, "Agentlogoff",							      "Agent: %s\r\n"							      "Logintime: %ld\r\n"							      "Uniqueid: %s\r\n",							      p->agent, logintime, ast_channel_uniqueid(chan));						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGOFF", "%s|%ld", ast_channel_name(chan), logintime);						ast_verb(2, "Agent '%s' logged out\n", p->agent);						/* If there is no owner, go ahead and kill it now */						ast_devstate_changed(AST_DEVICE_UNAVAILABLE, "Agent/%s", p->agent);						if (p->dead && !p->owner) {							ast_mutex_destroy(&p->lock);							ast_cond_destroy(&p->app_complete_cond);							ast_cond_destroy(&p->login_wait_cond);							ast_free(p);						}					}					else {						ast_mutex_unlock(&p->lock);						p = NULL;					}					res = -1;				} else {					ast_mutex_unlock(&p->lock);					errmsg = "agent-alreadyon";					p = NULL;				}				break;			}
p->lastdisc = ast_tvnow();
p->lastdisc = ast_tvnow()
p->lastdisc
p
p
lastdisc
ast_tvnow()
ast_tvnow
ast_tvnow
p->lastdisc.tv_sec++;
p->lastdisc.tv_sec++
p->lastdisc.tv_sec
p->lastdisc
p
p
lastdisc
tv_sec
if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))) {					if (ast_true(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))) {						p->ackcall = 1;					} else {						p->ackcall = 0;					}					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTACKCALL");					ast_verb(3, "Saw variable AGENTACKCALL=%s, setting ackcall to: %d for Agent '%s'.\n", tmpoptions, p->ackcall, p->agent);					ast_set_flag(p, AGENT_FLAG_ACKCALL);				} else {					p->ackcall = ackcall;				}
!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))
ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))
ast_strlen_zero
ast_strlen_zero
pbx_builtin_getvar_helper(chan, "AGENTACKCALL")
pbx_builtin_getvar_helper
pbx_builtin_getvar_helper
chan
chan
"AGENTACKCALL"
{					if (ast_true(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))) {						p->ackcall = 1;					} else {						p->ackcall = 0;					}					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTACKCALL");					ast_verb(3, "Saw variable AGENTACKCALL=%s, setting ackcall to: %d for Agent '%s'.\n", tmpoptions, p->ackcall, p->agent);					ast_set_flag(p, AGENT_FLAG_ACKCALL);				}
if (ast_true(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))) {						p->ackcall = 1;					} else {						p->ackcall = 0;					}
ast_true(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))
ast_true
ast_true
pbx_builtin_getvar_helper(chan, "AGENTACKCALL")
pbx_builtin_getvar_helper
pbx_builtin_getvar_helper
chan
chan
"AGENTACKCALL"
{						p->ackcall = 1;					}
p->ackcall = 1;
p->ackcall = 1
p->ackcall
p
p
ackcall
1
{						p->ackcall = 0;					}
p->ackcall = 0;
p->ackcall = 0
p->ackcall
p
p
ackcall
0
tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTACKCALL");
tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTACKCALL")
tmpoptions
tmpoptions
pbx_builtin_getvar_helper(chan, "AGENTACKCALL")
pbx_builtin_getvar_helper
pbx_builtin_getvar_helper
chan
chan
"AGENTACKCALL"
ast_verb(3, "Saw variable AGENTACKCALL=%s, setting ackcall to: %d for Agent '%s'.\n", tmpoptions, p->ackcall, p->agent);
ast_verb(3, "Saw variable AGENTACKCALL=%s, setting ackcall to: %d for Agent '%s'.\n", tmpoptions, p->ackcall, p->agent)
ast_verb
ast_verb
3
"Saw variable AGENTACKCALL=%s, setting ackcall to: %d for Agent '%s'.\n"
tmpoptions
tmpoptions
p->ackcall
p
p
ackcall
p->agent
p
p
agent
ast_set_flag(p, AGENT_FLAG_ACKCALL);
ast_set_flag(p, AGENT_FLAG_ACKCALL)
ast_set_flag
ast_set_flag
p
p
AGENT_FLAG_ACKCALL
AGENT_FLAG_ACKCALL
{					p->ackcall = ackcall;				}
p->ackcall = ackcall;
p->ackcall = ackcall
p->ackcall
p
p
ackcall
ackcall
ackcall
if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"))) {					p->autologoff = atoi(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"));					if (p->autologoff < 0)						p->autologoff = 0;					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF");					ast_verb(3, "Saw variable AGENTAUTOLOGOFF=%s, setting autologff to: %d for Agent '%s'.\n", tmpoptions, p->autologoff, p->agent);					ast_set_flag(p, AGENT_FLAG_AUTOLOGOFF);				} else {					p->autologoff = autologoff;				}
!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"))
ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"))
ast_strlen_zero
ast_strlen_zero
pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF")
pbx_builtin_getvar_helper
pbx_builtin_getvar_helper
chan
chan
"AGENTAUTOLOGOFF"
{					p->autologoff = atoi(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"));					if (p->autologoff < 0)						p->autologoff = 0;					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF");					ast_verb(3, "Saw variable AGENTAUTOLOGOFF=%s, setting autologff to: %d for Agent '%s'.\n", tmpoptions, p->autologoff, p->agent);					ast_set_flag(p, AGENT_FLAG_AUTOLOGOFF);				}
p->autologoff = atoi(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"));
p->autologoff = atoi(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"))
p->autologoff
p
p
autologoff
atoi(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"))
atoi
atoi
pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF")
pbx_builtin_getvar_helper
pbx_builtin_getvar_helper
chan
chan
"AGENTAUTOLOGOFF"
if (p->autologoff < 0)						p->autologoff = 0;
p->autologoff < 0
p->autologoff
p
p
autologoff
0
p->autologoff = 0;
p->autologoff = 0
p->autologoff
p
p
autologoff
0
tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF");
tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF")
tmpoptions
tmpoptions
pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF")
pbx_builtin_getvar_helper
pbx_builtin_getvar_helper
chan
chan
"AGENTAUTOLOGOFF"
ast_verb(3, "Saw variable AGENTAUTOLOGOFF=%s, setting autologff to: %d for Agent '%s'.\n", tmpoptions, p->autologoff, p->agent);
ast_verb(3, "Saw variable AGENTAUTOLOGOFF=%s, setting autologff to: %d for Agent '%s'.\n", tmpoptions, p->autologoff, p->agent)
ast_verb
ast_verb
3
"Saw variable AGENTAUTOLOGOFF=%s, setting autologff to: %d for Agent '%s'.\n"
tmpoptions
tmpoptions
p->autologoff
p
p
autologoff
p->agent
p
p
agent
ast_set_flag(p, AGENT_FLAG_AUTOLOGOFF);
ast_set_flag(p, AGENT_FLAG_AUTOLOGOFF)
ast_set_flag
ast_set_flag
p
p
AGENT_FLAG_AUTOLOGOFF
AGENT_FLAG_AUTOLOGOFF
{					p->autologoff = autologoff;				}
p->autologoff = autologoff;
p->autologoff = autologoff
p->autologoff
p
p
autologoff
autologoff
autologoff
if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"))) {					p->wrapuptime = atoi(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"));					if (p->wrapuptime < 0)						p->wrapuptime = 0;					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME");					ast_verb(3, "Saw variable AGENTWRAPUPTIME=%s, setting wrapuptime to: %d for Agent '%s'.\n", tmpoptions, p->wrapuptime, p->agent);					ast_set_flag(p, AGENT_FLAG_WRAPUPTIME);				} else {					p->wrapuptime = wrapuptime;				}
!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"))
ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"))
ast_strlen_zero
ast_strlen_zero
pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME")
pbx_builtin_getvar_helper
pbx_builtin_getvar_helper
chan
chan
"AGENTWRAPUPTIME"
{					p->wrapuptime = atoi(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"));					if (p->wrapuptime < 0)						p->wrapuptime = 0;					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME");					ast_verb(3, "Saw variable AGENTWRAPUPTIME=%s, setting wrapuptime to: %d for Agent '%s'.\n", tmpoptions, p->wrapuptime, p->agent);					ast_set_flag(p, AGENT_FLAG_WRAPUPTIME);				}
p->wrapuptime = atoi(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"));
p->wrapuptime = atoi(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"))
p->wrapuptime
p
p
wrapuptime
atoi(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"))
atoi
atoi
pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME")
pbx_builtin_getvar_helper
pbx_builtin_getvar_helper
chan
chan
"AGENTWRAPUPTIME"
if (p->wrapuptime < 0)						p->wrapuptime = 0;
p->wrapuptime < 0
p->wrapuptime
p
p
wrapuptime
0
p->wrapuptime = 0;
p->wrapuptime = 0
p->wrapuptime
p
p
wrapuptime
0
tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME");
tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME")
tmpoptions
tmpoptions
pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME")
pbx_builtin_getvar_helper
pbx_builtin_getvar_helper
chan
chan
"AGENTWRAPUPTIME"
ast_verb(3, "Saw variable AGENTWRAPUPTIME=%s, setting wrapuptime to: %d for Agent '%s'.\n", tmpoptions, p->wrapuptime, p->agent);
ast_verb(3, "Saw variable AGENTWRAPUPTIME=%s, setting wrapuptime to: %d for Agent '%s'.\n", tmpoptions, p->wrapuptime, p->agent)
ast_verb
ast_verb
3
"Saw variable AGENTWRAPUPTIME=%s, setting wrapuptime to: %d for Agent '%s'.\n"
tmpoptions
tmpoptions
p->wrapuptime
p
p
wrapuptime
p->agent
p
p
agent
ast_set_flag(p, AGENT_FLAG_WRAPUPTIME);
ast_set_flag(p, AGENT_FLAG_WRAPUPTIME)
ast_set_flag
ast_set_flag
p
p
AGENT_FLAG_WRAPUPTIME
AGENT_FLAG_WRAPUPTIME
{					p->wrapuptime = wrapuptime;				}
p->wrapuptime = wrapuptime;
p->wrapuptime = wrapuptime
p->wrapuptime
p
p
wrapuptime
wrapuptime
wrapuptime
tmpoptions = pbx_builtin_getvar_helper(chan, "AGENTACCEPTDTMF");
tmpoptions = pbx_builtin_getvar_helper(chan, "AGENTACCEPTDTMF")
tmpoptions
tmpoptions
pbx_builtin_getvar_helper(chan, "AGENTACCEPTDTMF")
pbx_builtin_getvar_helper
pbx_builtin_getvar_helper
chan
chan
"AGENTACCEPTDTMF"
if (!ast_strlen_zero(tmpoptions)) {					p->acceptdtmf = *tmpoptions;					ast_verb(3, "Saw variable AGENTACCEPTDTMF=%s, setting acceptdtmf to: %c for Agent '%s'.\n", tmpoptions, p->acceptdtmf, p->agent);					ast_set_flag(p, AGENT_FLAG_ACCEPTDTMF);				}
!ast_strlen_zero(tmpoptions)
ast_strlen_zero(tmpoptions)
ast_strlen_zero
ast_strlen_zero
tmpoptions
tmpoptions
{					p->acceptdtmf = *tmpoptions;					ast_verb(3, "Saw variable AGENTACCEPTDTMF=%s, setting acceptdtmf to: %c for Agent '%s'.\n", tmpoptions, p->acceptdtmf, p->agent);					ast_set_flag(p, AGENT_FLAG_ACCEPTDTMF);				}
p->acceptdtmf = *tmpoptions;
p->acceptdtmf = *tmpoptions
p->acceptdtmf
p
p
acceptdtmf
*tmpoptions
tmpoptions
tmpoptions
ast_verb(3, "Saw variable AGENTACCEPTDTMF=%s, setting acceptdtmf to: %c for Agent '%s'.\n", tmpoptions, p->acceptdtmf, p->agent);
ast_verb(3, "Saw variable AGENTACCEPTDTMF=%s, setting acceptdtmf to: %c for Agent '%s'.\n", tmpoptions, p->acceptdtmf, p->agent)
ast_verb
ast_verb
3
"Saw variable AGENTACCEPTDTMF=%s, setting acceptdtmf to: %c for Agent '%s'.\n"
tmpoptions
tmpoptions
p->acceptdtmf
p
p
acceptdtmf
p->agent
p
p
agent
ast_set_flag(p, AGENT_FLAG_ACCEPTDTMF);
ast_set_flag(p, AGENT_FLAG_ACCEPTDTMF)
ast_set_flag
ast_set_flag
p
p
AGENT_FLAG_ACCEPTDTMF
AGENT_FLAG_ACCEPTDTMF
tmpoptions = pbx_builtin_getvar_helper(chan, "AGENTENDDTMF");
tmpoptions = pbx_builtin_getvar_helper(chan, "AGENTENDDTMF")
tmpoptions
tmpoptions
pbx_builtin_getvar_helper(chan, "AGENTENDDTMF")
pbx_builtin_getvar_helper
pbx_builtin_getvar_helper
chan
chan
"AGENTENDDTMF"
if (!ast_strlen_zero(tmpoptions)) {					p->enddtmf = *tmpoptions;					ast_verb(3, "Saw variable AGENTENDDTMF=%s, setting enddtmf to: %c for Agent '%s'.\n", tmpoptions, p->enddtmf, p->agent);					ast_set_flag(p, AGENT_FLAG_ENDDTMF);				}
!ast_strlen_zero(tmpoptions)
ast_strlen_zero(tmpoptions)
ast_strlen_zero
ast_strlen_zero
tmpoptions
tmpoptions
{					p->enddtmf = *tmpoptions;					ast_verb(3, "Saw variable AGENTENDDTMF=%s, setting enddtmf to: %c for Agent '%s'.\n", tmpoptions, p->enddtmf, p->agent);					ast_set_flag(p, AGENT_FLAG_ENDDTMF);				}
p->enddtmf = *tmpoptions;
p->enddtmf = *tmpoptions
p->enddtmf
p
p
enddtmf
*tmpoptions
tmpoptions
tmpoptions
ast_verb(3, "Saw variable AGENTENDDTMF=%s, setting enddtmf to: %c for Agent '%s'.\n", tmpoptions, p->enddtmf, p->agent);
ast_verb(3, "Saw variable AGENTENDDTMF=%s, setting enddtmf to: %c for Agent '%s'.\n", tmpoptions, p->enddtmf, p->agent)
ast_verb
ast_verb
3
"Saw variable AGENTENDDTMF=%s, setting enddtmf to: %c for Agent '%s'.\n"
tmpoptions
tmpoptions
p->enddtmf
p
p
enddtmf
p->agent
p
p
agent
ast_set_flag(p, AGENT_FLAG_ENDDTMF);
ast_set_flag(p, AGENT_FLAG_ENDDTMF)
ast_set_flag
ast_set_flag
p
p
AGENT_FLAG_ENDDTMF
AGENT_FLAG_ENDDTMF
ast_channel_unlock(chan);
ast_channel_unlock(chan)
ast_channel_unlock
ast_channel_unlock
chan
chan
unlock_channel = 0;
unlock_channel = 0
unlock_channel
unlock_channel
0
if (!p->chan) {					long logintime;					snprintf(agent, sizeof(agent), "Agent/%s", p->agent);					p->logincallerid[0] = '\0';					p->acknowledged = 0;					ast_mutex_unlock(&p->lock);					AST_LIST_UNLOCK(&agents);					if( !res && play_announcement==1 )						res = ast_streamfile(chan, filename, ast_channel_language(chan));					if (!res)						ast_waitstream(chan, "");					AST_LIST_LOCK(&agents);					ast_mutex_lock(&p->lock);					if (!res) {						struct ast_format tmpfmt;						res = ast_set_read_format_from_cap(chan, ast_channel_nativeformats(chan));						if (res) {							ast_log(LOG_WARNING, "Unable to set read format to %s\n", ast_getformatname(&tmpfmt));						}					}					if (!res) {						struct ast_format tmpfmt;						res = ast_set_write_format_from_cap(chan, ast_channel_nativeformats(chan));						if (res) {							ast_log(LOG_WARNING, "Unable to set write format to %s\n", ast_getformatname(&tmpfmt));						}					}					/* Check once more just in case */					if (p->chan)						res = -1;					if (!res) {						ast_indicate_data(chan, AST_CONTROL_HOLD,							S_OR(p->moh, NULL),							!ast_strlen_zero(p->moh) ? strlen(p->moh) + 1 : 0);						if (p->loginstart == 0)							time(&p->loginstart);						/*** DOCUMENTATION							<managerEventInstance>								<synopsis>Raised when an Agent has logged in.</synopsis>								<syntax>									<parameter name="Agent">										<para>The name of the agent.</para>									</parameter>								</syntax>								<see-also>									<ref type="application">AgentLogin</ref>									<ref type="managerEvent">Agentlogoff</ref>								</see-also>							</managerEventInstance>						***/						manager_event(EVENT_FLAG_AGENT, "Agentlogin",							      "Agent: %s\r\n"							      "Channel: %s\r\n"							      "Uniqueid: %s\r\n",							      p->agent, ast_channel_name(chan), ast_channel_uniqueid(chan));						if (update_cdr && ast_channel_cdr(chan))							snprintf(ast_channel_cdr(chan)->channel, sizeof(ast_channel_cdr(chan)->channel), "Agent/%s", p->agent);						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGIN", "%s", ast_channel_name(chan));						ast_verb(2, "Agent '%s' logged in (format %s/%s)\n", p->agent,								    ast_getformatname(ast_channel_readformat(chan)), ast_getformatname(ast_channel_writeformat(chan)));						/* Login this channel and wait for it to go away */						p->chan = chan;						if (p->ackcall) {							check_beep(p, 0);						} else {							check_availability(p, 0);						}						ast_mutex_unlock(&p->lock);						AST_LIST_UNLOCK(&agents);						ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Agent/%s", p->agent);						while (res >= 0) {							ast_mutex_lock(&p->lock);							if (p->deferlogoff && p->chan) {								ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);								p->deferlogoff = 0;							}							if (p->chan != chan)								res = -1;							ast_mutex_unlock(&p->lock);							/* Yield here so other interested threads can kick in. */							sched_yield();							if (res)								break;							AST_LIST_LOCK(&agents);							ast_mutex_lock(&p->lock);							if (p->lastdisc.tv_sec) {								if (ast_tvdiff_ms(ast_tvnow(), p->lastdisc) > 0) {									ast_debug(1, "Wrapup time for %s expired!\n", p->agent);									p->lastdisc = ast_tv(0, 0);									ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Agent/%s", p->agent);									if (p->ackcall) {										check_beep(p, 0);									} else {										check_availability(p, 0);									}								}							}							ast_mutex_unlock(&p->lock);							AST_LIST_UNLOCK(&agents);							/*	Synchronize channel ownership between call to agent and itself. */							ast_mutex_lock(&p->lock);							if (p->app_lock_flag == 1) {								ast_cond_signal(&p->login_wait_cond);								ast_cond_wait(&p->app_complete_cond, &p->lock);							}							ast_mutex_unlock(&p->lock);							if (p->ackcall) {								res = agent_ack_sleep(p);							} else {								res = ast_safe_sleep_conditional( chan, 1000, agent_cont_sleep, p );							}							if (p->ackcall && (res == 1)) {								AST_LIST_LOCK(&agents);								ast_mutex_lock(&p->lock);								check_availability(p, 0);								ast_mutex_unlock(&p->lock);								AST_LIST_UNLOCK(&agents);								res = 0;							}							sched_yield();						}						ast_mutex_lock(&p->lock);						/* Log us off if appropriate */						if (p->chan == chan) {							p->chan = NULL;						}						/* Synchronize channel ownership between call to agent and itself. */						if (p->app_lock_flag == 1) {							ast_cond_signal(&p->login_wait_cond);							ast_cond_wait(&p->app_complete_cond, &p->lock);						}						if (res && p->owner)							ast_log(LOG_WARNING, "Huh?  We broke out when there was still an owner?\n");						p->acknowledged = 0;						logintime = time(NULL) - p->loginstart;						p->loginstart = 0;						ast_mutex_unlock(&p->lock);						/*** DOCUMENTATION							<managerEventInstance>								<synopsis>Raised when an Agent has logged off.</synopsis>								<syntax>									<xi:include xpointer="xpointer(/docs/managerEvent[@name='Agentlogin']/managerEventInstance/syntax/parameter[@name='Agent'])" />								</syntax>								<see-also>									<ref type="managerEvent">Agentlogin</ref>								</see-also>							</managerEventInstance>						***/						manager_event(EVENT_FLAG_AGENT, "Agentlogoff",							      "Agent: %s\r\n"							      "Logintime: %ld\r\n"							      "Uniqueid: %s\r\n",							      p->agent, logintime, ast_channel_uniqueid(chan));						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGOFF", "%s|%ld", ast_channel_name(chan), logintime);						ast_verb(2, "Agent '%s' logged out\n", p->agent);						/* If there is no owner, go ahead and kill it now */						ast_devstate_changed(AST_DEVICE_UNAVAILABLE, "Agent/%s", p->agent);						if (p->dead && !p->owner) {							ast_mutex_destroy(&p->lock);							ast_cond_destroy(&p->app_complete_cond);							ast_cond_destroy(&p->login_wait_cond);							ast_free(p);						}					}					else {						ast_mutex_unlock(&p->lock);						p = NULL;					}					res = -1;				} else {					ast_mutex_unlock(&p->lock);					errmsg = "agent-alreadyon";					p = NULL;				}
!p->chan
p->chan
p
p
chan
{					long logintime;					snprintf(agent, sizeof(agent), "Agent/%s", p->agent);					p->logincallerid[0] = '\0';					p->acknowledged = 0;					ast_mutex_unlock(&p->lock);					AST_LIST_UNLOCK(&agents);					if( !res && play_announcement==1 )						res = ast_streamfile(chan, filename, ast_channel_language(chan));					if (!res)						ast_waitstream(chan, "");					AST_LIST_LOCK(&agents);					ast_mutex_lock(&p->lock);					if (!res) {						struct ast_format tmpfmt;						res = ast_set_read_format_from_cap(chan, ast_channel_nativeformats(chan));						if (res) {							ast_log(LOG_WARNING, "Unable to set read format to %s\n", ast_getformatname(&tmpfmt));						}					}					if (!res) {						struct ast_format tmpfmt;						res = ast_set_write_format_from_cap(chan, ast_channel_nativeformats(chan));						if (res) {							ast_log(LOG_WARNING, "Unable to set write format to %s\n", ast_getformatname(&tmpfmt));						}					}					/* Check once more just in case */					if (p->chan)						res = -1;					if (!res) {						ast_indicate_data(chan, AST_CONTROL_HOLD,							S_OR(p->moh, NULL),							!ast_strlen_zero(p->moh) ? strlen(p->moh) + 1 : 0);						if (p->loginstart == 0)							time(&p->loginstart);						/*** DOCUMENTATION							<managerEventInstance>								<synopsis>Raised when an Agent has logged in.</synopsis>								<syntax>									<parameter name="Agent">										<para>The name of the agent.</para>									</parameter>								</syntax>								<see-also>									<ref type="application">AgentLogin</ref>									<ref type="managerEvent">Agentlogoff</ref>								</see-also>							</managerEventInstance>						***/						manager_event(EVENT_FLAG_AGENT, "Agentlogin",							      "Agent: %s\r\n"							      "Channel: %s\r\n"							      "Uniqueid: %s\r\n",							      p->agent, ast_channel_name(chan), ast_channel_uniqueid(chan));						if (update_cdr && ast_channel_cdr(chan))							snprintf(ast_channel_cdr(chan)->channel, sizeof(ast_channel_cdr(chan)->channel), "Agent/%s", p->agent);						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGIN", "%s", ast_channel_name(chan));						ast_verb(2, "Agent '%s' logged in (format %s/%s)\n", p->agent,								    ast_getformatname(ast_channel_readformat(chan)), ast_getformatname(ast_channel_writeformat(chan)));						/* Login this channel and wait for it to go away */						p->chan = chan;						if (p->ackcall) {							check_beep(p, 0);						} else {							check_availability(p, 0);						}						ast_mutex_unlock(&p->lock);						AST_LIST_UNLOCK(&agents);						ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Agent/%s", p->agent);						while (res >= 0) {							ast_mutex_lock(&p->lock);							if (p->deferlogoff && p->chan) {								ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);								p->deferlogoff = 0;							}							if (p->chan != chan)								res = -1;							ast_mutex_unlock(&p->lock);							/* Yield here so other interested threads can kick in. */							sched_yield();							if (res)								break;							AST_LIST_LOCK(&agents);							ast_mutex_lock(&p->lock);							if (p->lastdisc.tv_sec) {								if (ast_tvdiff_ms(ast_tvnow(), p->lastdisc) > 0) {									ast_debug(1, "Wrapup time for %s expired!\n", p->agent);									p->lastdisc = ast_tv(0, 0);									ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Agent/%s", p->agent);									if (p->ackcall) {										check_beep(p, 0);									} else {										check_availability(p, 0);									}								}							}							ast_mutex_unlock(&p->lock);							AST_LIST_UNLOCK(&agents);							/*	Synchronize channel ownership between call to agent and itself. */							ast_mutex_lock(&p->lock);							if (p->app_lock_flag == 1) {								ast_cond_signal(&p->login_wait_cond);								ast_cond_wait(&p->app_complete_cond, &p->lock);							}							ast_mutex_unlock(&p->lock);							if (p->ackcall) {								res = agent_ack_sleep(p);							} else {								res = ast_safe_sleep_conditional( chan, 1000, agent_cont_sleep, p );							}							if (p->ackcall && (res == 1)) {								AST_LIST_LOCK(&agents);								ast_mutex_lock(&p->lock);								check_availability(p, 0);								ast_mutex_unlock(&p->lock);								AST_LIST_UNLOCK(&agents);								res = 0;							}							sched_yield();						}						ast_mutex_lock(&p->lock);						/* Log us off if appropriate */						if (p->chan == chan) {							p->chan = NULL;						}						/* Synchronize channel ownership between call to agent and itself. */						if (p->app_lock_flag == 1) {							ast_cond_signal(&p->login_wait_cond);							ast_cond_wait(&p->app_complete_cond, &p->lock);						}						if (res && p->owner)							ast_log(LOG_WARNING, "Huh?  We broke out when there was still an owner?\n");						p->acknowledged = 0;						logintime = time(NULL) - p->loginstart;						p->loginstart = 0;						ast_mutex_unlock(&p->lock);						/*** DOCUMENTATION							<managerEventInstance>								<synopsis>Raised when an Agent has logged off.</synopsis>								<syntax>									<xi:include xpointer="xpointer(/docs/managerEvent[@name='Agentlogin']/managerEventInstance/syntax/parameter[@name='Agent'])" />								</syntax>								<see-also>									<ref type="managerEvent">Agentlogin</ref>								</see-also>							</managerEventInstance>						***/						manager_event(EVENT_FLAG_AGENT, "Agentlogoff",							      "Agent: %s\r\n"							      "Logintime: %ld\r\n"							      "Uniqueid: %s\r\n",							      p->agent, logintime, ast_channel_uniqueid(chan));						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGOFF", "%s|%ld", ast_channel_name(chan), logintime);						ast_verb(2, "Agent '%s' logged out\n", p->agent);						/* If there is no owner, go ahead and kill it now */						ast_devstate_changed(AST_DEVICE_UNAVAILABLE, "Agent/%s", p->agent);						if (p->dead && !p->owner) {							ast_mutex_destroy(&p->lock);							ast_cond_destroy(&p->app_complete_cond);							ast_cond_destroy(&p->login_wait_cond);							ast_free(p);						}					}					else {						ast_mutex_unlock(&p->lock);						p = NULL;					}					res = -1;				}
long logintime;
long logintime;
long
logintime
logintime
snprintf(agent, sizeof(agent), "Agent/%s", p->agent);
snprintf(agent, sizeof(agent), "Agent/%s", p->agent)
snprintf
snprintf
agent
agent
sizeof(agent)
(agent)
agent
agent
"Agent/%s"
p->agent
p
p
agent
p->logincallerid[0] = '\0';
p->logincallerid[0] = '\0'
p->logincallerid[0]
p->logincallerid
p
p
logincallerid
0
'\0'
p->acknowledged = 0;
p->acknowledged = 0
p->acknowledged
p
p
acknowledged
0
ast_mutex_unlock(&p->lock);
ast_mutex_unlock(&p->lock)
ast_mutex_unlock
ast_mutex_unlock
&p->lock
p->lock
p
p
lock
AST_LIST_UNLOCK(&agents);
AST_LIST_UNLOCK(&agents)
AST_LIST_UNLOCK
AST_LIST_UNLOCK
&agents
agents
agents
if( !res && play_announcement==1 )						res = ast_streamfile(chan, filename, ast_channel_language(chan));
!res && play_announcement==1
!res
res
res
play_announcement==1
play_announcement
play_announcement
1
res = ast_streamfile(chan, filename, ast_channel_language(chan));
res = ast_streamfile(chan, filename, ast_channel_language(chan))
res
res
ast_streamfile(chan, filename, ast_channel_language(chan))
ast_streamfile
ast_streamfile
chan
chan
filename
filename
ast_channel_language(chan)
ast_channel_language
ast_channel_language
chan
chan
if (!res)						ast_waitstream(chan, "");
!res
res
res
ast_waitstream(chan, "");
ast_waitstream(chan, "")
ast_waitstream
ast_waitstream
chan
chan
""
AST_LIST_LOCK(&agents);
AST_LIST_LOCK(&agents)
AST_LIST_LOCK
AST_LIST_LOCK
&agents
agents
agents
ast_mutex_lock(&p->lock);
ast_mutex_lock(&p->lock)
ast_mutex_lock
ast_mutex_lock
&p->lock
p->lock
p
p
lock
if (!res) {						struct ast_format tmpfmt;						res = ast_set_read_format_from_cap(chan, ast_channel_nativeformats(chan));						if (res) {							ast_log(LOG_WARNING, "Unable to set read format to %s\n", ast_getformatname(&tmpfmt));						}					}
!res
res
res
{						struct ast_format tmpfmt;						res = ast_set_read_format_from_cap(chan, ast_channel_nativeformats(chan));						if (res) {							ast_log(LOG_WARNING, "Unable to set read format to %s\n", ast_getformatname(&tmpfmt));						}					}
struct ast_format tmpfmt;
struct ast_format tmpfmt;
struct ast_format
ast_format
tmpfmt
tmpfmt
res = ast_set_read_format_from_cap(chan, ast_channel_nativeformats(chan));
res = ast_set_read_format_from_cap(chan, ast_channel_nativeformats(chan))
res
res
ast_set_read_format_from_cap(chan, ast_channel_nativeformats(chan))
ast_set_read_format_from_cap
ast_set_read_format_from_cap
chan
chan
ast_channel_nativeformats(chan)
ast_channel_nativeformats
ast_channel_nativeformats
chan
chan
if (res) {							ast_log(LOG_WARNING, "Unable to set read format to %s\n", ast_getformatname(&tmpfmt));						}
res
res
{							ast_log(LOG_WARNING, "Unable to set read format to %s\n", ast_getformatname(&tmpfmt));						}
ast_log(LOG_WARNING, "Unable to set read format to %s\n", ast_getformatname(&tmpfmt));
ast_log(LOG_WARNING, "Unable to set read format to %s\n", ast_getformatname(&tmpfmt))
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"Unable to set read format to %s\n"
ast_getformatname(&tmpfmt)
ast_getformatname
ast_getformatname
&tmpfmt
tmpfmt
tmpfmt
if (!res) {						struct ast_format tmpfmt;						res = ast_set_write_format_from_cap(chan, ast_channel_nativeformats(chan));						if (res) {							ast_log(LOG_WARNING, "Unable to set write format to %s\n", ast_getformatname(&tmpfmt));						}					}
!res
res
res
{						struct ast_format tmpfmt;						res = ast_set_write_format_from_cap(chan, ast_channel_nativeformats(chan));						if (res) {							ast_log(LOG_WARNING, "Unable to set write format to %s\n", ast_getformatname(&tmpfmt));						}					}
struct ast_format tmpfmt;
struct ast_format tmpfmt;
struct ast_format
ast_format
tmpfmt
tmpfmt
res = ast_set_write_format_from_cap(chan, ast_channel_nativeformats(chan));
res = ast_set_write_format_from_cap(chan, ast_channel_nativeformats(chan))
res
res
ast_set_write_format_from_cap(chan, ast_channel_nativeformats(chan))
ast_set_write_format_from_cap
ast_set_write_format_from_cap
chan
chan
ast_channel_nativeformats(chan)
ast_channel_nativeformats
ast_channel_nativeformats
chan
chan
if (res) {							ast_log(LOG_WARNING, "Unable to set write format to %s\n", ast_getformatname(&tmpfmt));						}
res
res
{							ast_log(LOG_WARNING, "Unable to set write format to %s\n", ast_getformatname(&tmpfmt));						}
ast_log(LOG_WARNING, "Unable to set write format to %s\n", ast_getformatname(&tmpfmt));
ast_log(LOG_WARNING, "Unable to set write format to %s\n", ast_getformatname(&tmpfmt))
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"Unable to set write format to %s\n"
ast_getformatname(&tmpfmt)
ast_getformatname
ast_getformatname
&tmpfmt
tmpfmt
tmpfmt
if (p->chan)						res = -1;
p->chan
p
p
chan
res = -1;
res = -1
res
res
-1
1
if (!res) {						ast_indicate_data(chan, AST_CONTROL_HOLD,							S_OR(p->moh, NULL),							!ast_strlen_zero(p->moh) ? strlen(p->moh) + 1 : 0);						if (p->loginstart == 0)							time(&p->loginstart);						/*** DOCUMENTATION							<managerEventInstance>								<synopsis>Raised when an Agent has logged in.</synopsis>								<syntax>									<parameter name="Agent">										<para>The name of the agent.</para>									</parameter>								</syntax>								<see-also>									<ref type="application">AgentLogin</ref>									<ref type="managerEvent">Agentlogoff</ref>								</see-also>							</managerEventInstance>						***/						manager_event(EVENT_FLAG_AGENT, "Agentlogin",							      "Agent: %s\r\n"							      "Channel: %s\r\n"							      "Uniqueid: %s\r\n",							      p->agent, ast_channel_name(chan), ast_channel_uniqueid(chan));						if (update_cdr && ast_channel_cdr(chan))							snprintf(ast_channel_cdr(chan)->channel, sizeof(ast_channel_cdr(chan)->channel), "Agent/%s", p->agent);						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGIN", "%s", ast_channel_name(chan));						ast_verb(2, "Agent '%s' logged in (format %s/%s)\n", p->agent,								    ast_getformatname(ast_channel_readformat(chan)), ast_getformatname(ast_channel_writeformat(chan)));						/* Login this channel and wait for it to go away */						p->chan = chan;						if (p->ackcall) {							check_beep(p, 0);						} else {							check_availability(p, 0);						}						ast_mutex_unlock(&p->lock);						AST_LIST_UNLOCK(&agents);						ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Agent/%s", p->agent);						while (res >= 0) {							ast_mutex_lock(&p->lock);							if (p->deferlogoff && p->chan) {								ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);								p->deferlogoff = 0;							}							if (p->chan != chan)								res = -1;							ast_mutex_unlock(&p->lock);							/* Yield here so other interested threads can kick in. */							sched_yield();							if (res)								break;							AST_LIST_LOCK(&agents);							ast_mutex_lock(&p->lock);							if (p->lastdisc.tv_sec) {								if (ast_tvdiff_ms(ast_tvnow(), p->lastdisc) > 0) {									ast_debug(1, "Wrapup time for %s expired!\n", p->agent);									p->lastdisc = ast_tv(0, 0);									ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Agent/%s", p->agent);									if (p->ackcall) {										check_beep(p, 0);									} else {										check_availability(p, 0);									}								}							}							ast_mutex_unlock(&p->lock);							AST_LIST_UNLOCK(&agents);							/*	Synchronize channel ownership between call to agent and itself. */							ast_mutex_lock(&p->lock);							if (p->app_lock_flag == 1) {								ast_cond_signal(&p->login_wait_cond);								ast_cond_wait(&p->app_complete_cond, &p->lock);							}							ast_mutex_unlock(&p->lock);							if (p->ackcall) {								res = agent_ack_sleep(p);							} else {								res = ast_safe_sleep_conditional( chan, 1000, agent_cont_sleep, p );							}							if (p->ackcall && (res == 1)) {								AST_LIST_LOCK(&agents);								ast_mutex_lock(&p->lock);								check_availability(p, 0);								ast_mutex_unlock(&p->lock);								AST_LIST_UNLOCK(&agents);								res = 0;							}							sched_yield();						}						ast_mutex_lock(&p->lock);						/* Log us off if appropriate */						if (p->chan == chan) {							p->chan = NULL;						}						/* Synchronize channel ownership between call to agent and itself. */						if (p->app_lock_flag == 1) {							ast_cond_signal(&p->login_wait_cond);							ast_cond_wait(&p->app_complete_cond, &p->lock);						}						if (res && p->owner)							ast_log(LOG_WARNING, "Huh?  We broke out when there was still an owner?\n");						p->acknowledged = 0;						logintime = time(NULL) - p->loginstart;						p->loginstart = 0;						ast_mutex_unlock(&p->lock);						/*** DOCUMENTATION							<managerEventInstance>								<synopsis>Raised when an Agent has logged off.</synopsis>								<syntax>									<xi:include xpointer="xpointer(/docs/managerEvent[@name='Agentlogin']/managerEventInstance/syntax/parameter[@name='Agent'])" />								</syntax>								<see-also>									<ref type="managerEvent">Agentlogin</ref>								</see-also>							</managerEventInstance>						***/						manager_event(EVENT_FLAG_AGENT, "Agentlogoff",							      "Agent: %s\r\n"							      "Logintime: %ld\r\n"							      "Uniqueid: %s\r\n",							      p->agent, logintime, ast_channel_uniqueid(chan));						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGOFF", "%s|%ld", ast_channel_name(chan), logintime);						ast_verb(2, "Agent '%s' logged out\n", p->agent);						/* If there is no owner, go ahead and kill it now */						ast_devstate_changed(AST_DEVICE_UNAVAILABLE, "Agent/%s", p->agent);						if (p->dead && !p->owner) {							ast_mutex_destroy(&p->lock);							ast_cond_destroy(&p->app_complete_cond);							ast_cond_destroy(&p->login_wait_cond);							ast_free(p);						}					}					else {						ast_mutex_unlock(&p->lock);						p = NULL;					}
!res
res
res
{						ast_indicate_data(chan, AST_CONTROL_HOLD,							S_OR(p->moh, NULL),							!ast_strlen_zero(p->moh) ? strlen(p->moh) + 1 : 0);						if (p->loginstart == 0)							time(&p->loginstart);						/*** DOCUMENTATION							<managerEventInstance>								<synopsis>Raised when an Agent has logged in.</synopsis>								<syntax>									<parameter name="Agent">										<para>The name of the agent.</para>									</parameter>								</syntax>								<see-also>									<ref type="application">AgentLogin</ref>									<ref type="managerEvent">Agentlogoff</ref>								</see-also>							</managerEventInstance>						***/						manager_event(EVENT_FLAG_AGENT, "Agentlogin",							      "Agent: %s\r\n"							      "Channel: %s\r\n"							      "Uniqueid: %s\r\n",							      p->agent, ast_channel_name(chan), ast_channel_uniqueid(chan));						if (update_cdr && ast_channel_cdr(chan))							snprintf(ast_channel_cdr(chan)->channel, sizeof(ast_channel_cdr(chan)->channel), "Agent/%s", p->agent);						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGIN", "%s", ast_channel_name(chan));						ast_verb(2, "Agent '%s' logged in (format %s/%s)\n", p->agent,								    ast_getformatname(ast_channel_readformat(chan)), ast_getformatname(ast_channel_writeformat(chan)));						/* Login this channel and wait for it to go away */						p->chan = chan;						if (p->ackcall) {							check_beep(p, 0);						} else {							check_availability(p, 0);						}						ast_mutex_unlock(&p->lock);						AST_LIST_UNLOCK(&agents);						ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Agent/%s", p->agent);						while (res >= 0) {							ast_mutex_lock(&p->lock);							if (p->deferlogoff && p->chan) {								ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);								p->deferlogoff = 0;							}							if (p->chan != chan)								res = -1;							ast_mutex_unlock(&p->lock);							/* Yield here so other interested threads can kick in. */							sched_yield();							if (res)								break;							AST_LIST_LOCK(&agents);							ast_mutex_lock(&p->lock);							if (p->lastdisc.tv_sec) {								if (ast_tvdiff_ms(ast_tvnow(), p->lastdisc) > 0) {									ast_debug(1, "Wrapup time for %s expired!\n", p->agent);									p->lastdisc = ast_tv(0, 0);									ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Agent/%s", p->agent);									if (p->ackcall) {										check_beep(p, 0);									} else {										check_availability(p, 0);									}								}							}							ast_mutex_unlock(&p->lock);							AST_LIST_UNLOCK(&agents);							/*	Synchronize channel ownership between call to agent and itself. */							ast_mutex_lock(&p->lock);							if (p->app_lock_flag == 1) {								ast_cond_signal(&p->login_wait_cond);								ast_cond_wait(&p->app_complete_cond, &p->lock);							}							ast_mutex_unlock(&p->lock);							if (p->ackcall) {								res = agent_ack_sleep(p);							} else {								res = ast_safe_sleep_conditional( chan, 1000, agent_cont_sleep, p );							}							if (p->ackcall && (res == 1)) {								AST_LIST_LOCK(&agents);								ast_mutex_lock(&p->lock);								check_availability(p, 0);								ast_mutex_unlock(&p->lock);								AST_LIST_UNLOCK(&agents);								res = 0;							}							sched_yield();						}						ast_mutex_lock(&p->lock);						/* Log us off if appropriate */						if (p->chan == chan) {							p->chan = NULL;						}						/* Synchronize channel ownership between call to agent and itself. */						if (p->app_lock_flag == 1) {							ast_cond_signal(&p->login_wait_cond);							ast_cond_wait(&p->app_complete_cond, &p->lock);						}						if (res && p->owner)							ast_log(LOG_WARNING, "Huh?  We broke out when there was still an owner?\n");						p->acknowledged = 0;						logintime = time(NULL) - p->loginstart;						p->loginstart = 0;						ast_mutex_unlock(&p->lock);						/*** DOCUMENTATION							<managerEventInstance>								<synopsis>Raised when an Agent has logged off.</synopsis>								<syntax>									<xi:include xpointer="xpointer(/docs/managerEvent[@name='Agentlogin']/managerEventInstance/syntax/parameter[@name='Agent'])" />								</syntax>								<see-also>									<ref type="managerEvent">Agentlogin</ref>								</see-also>							</managerEventInstance>						***/						manager_event(EVENT_FLAG_AGENT, "Agentlogoff",							      "Agent: %s\r\n"							      "Logintime: %ld\r\n"							      "Uniqueid: %s\r\n",							      p->agent, logintime, ast_channel_uniqueid(chan));						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGOFF", "%s|%ld", ast_channel_name(chan), logintime);						ast_verb(2, "Agent '%s' logged out\n", p->agent);						/* If there is no owner, go ahead and kill it now */						ast_devstate_changed(AST_DEVICE_UNAVAILABLE, "Agent/%s", p->agent);						if (p->dead && !p->owner) {							ast_mutex_destroy(&p->lock);							ast_cond_destroy(&p->app_complete_cond);							ast_cond_destroy(&p->login_wait_cond);							ast_free(p);						}					}
ast_indicate_data(chan, AST_CONTROL_HOLD,							S_OR(p->moh, NULL),							!ast_strlen_zero(p->moh) ? strlen(p->moh) + 1 : 0);
ast_indicate_data(chan, AST_CONTROL_HOLD,							S_OR(p->moh, NULL),							!ast_strlen_zero(p->moh) ? strlen(p->moh) + 1 : 0)
ast_indicate_data
ast_indicate_data
chan
chan
AST_CONTROL_HOLD
AST_CONTROL_HOLD
S_OR(p->moh, NULL)
S_OR
S_OR
p->moh
p
p
moh
NULL
NULL
!ast_strlen_zero(p->moh) ? strlen(p->moh) + 1 : 0
!ast_strlen_zero(p->moh)
ast_strlen_zero(p->moh)
ast_strlen_zero
ast_strlen_zero
p->moh
p
p
moh
strlen(p->moh) + 1
strlen(p->moh)
strlen
strlen
p->moh
p
p
moh
1
0
if (p->loginstart == 0)							time(&p->loginstart);
p->loginstart == 0
p->loginstart
p
p
loginstart
0
time(&p->loginstart);
time(&p->loginstart)
time
time
&p->loginstart
p->loginstart
p
p
loginstart
manager_event(EVENT_FLAG_AGENT, "Agentlogin",							      "Agent: %s\r\n"							      "Channel: %s\r\n"							      "Uniqueid: %s\r\n",							      p->agent, ast_channel_name(chan), ast_channel_uniqueid(chan));
manager_event(EVENT_FLAG_AGENT, "Agentlogin",							      "Agent: %s\r\n"							      "Channel: %s\r\n"							      "Uniqueid: %s\r\n",							      p->agent, ast_channel_name(chan), ast_channel_uniqueid(chan))
manager_event
manager_event
EVENT_FLAG_AGENT
EVENT_FLAG_AGENT
"Agentlogin"
"Agent: %s\r\n"							      "Channel: %s\r\n"							      "Uniqueid: %s\r\n"
p->agent
p
p
agent
ast_channel_name(chan)
ast_channel_name
ast_channel_name
chan
chan
ast_channel_uniqueid(chan)
ast_channel_uniqueid
ast_channel_uniqueid
chan
chan
if (update_cdr && ast_channel_cdr(chan))							snprintf(ast_channel_cdr(chan)->channel, sizeof(ast_channel_cdr(chan)->channel), "Agent/%s", p->agent);
update_cdr && ast_channel_cdr(chan)
update_cdr
update_cdr
ast_channel_cdr(chan)
ast_channel_cdr
ast_channel_cdr
chan
chan
snprintf(ast_channel_cdr(chan)->channel, sizeof(ast_channel_cdr(chan)->channel), "Agent/%s", p->agent);
snprintf(ast_channel_cdr(chan)->channel, sizeof(ast_channel_cdr(chan)->channel), "Agent/%s", p->agent)
snprintf
snprintf
ast_channel_cdr(chan)->channel
ast_channel_cdr(chan)
ast_channel_cdr
ast_channel_cdr
chan
chan
channel
sizeof(ast_channel_cdr(chan)->channel)
(ast_channel_cdr(chan)->channel)
ast_channel_cdr(chan)->channel
ast_channel_cdr(chan)
ast_channel_cdr
ast_channel_cdr
chan
chan
channel
"Agent/%s"
p->agent
p
p
agent
ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGIN", "%s", ast_channel_name(chan));
ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGIN", "%s", ast_channel_name(chan))
ast_queue_log
ast_queue_log
"NONE"
ast_channel_uniqueid(chan)
ast_channel_uniqueid
ast_channel_uniqueid
chan
chan
agent
agent
"AGENTLOGIN"
"%s"
ast_channel_name(chan)
ast_channel_name
ast_channel_name
chan
chan
ast_verb(2, "Agent '%s' logged in (format %s/%s)\n", p->agent,								    ast_getformatname(ast_channel_readformat(chan)), ast_getformatname(ast_channel_writeformat(chan)));
ast_verb(2, "Agent '%s' logged in (format %s/%s)\n", p->agent,								    ast_getformatname(ast_channel_readformat(chan)), ast_getformatname(ast_channel_writeformat(chan)))
ast_verb
ast_verb
2
"Agent '%s' logged in (format %s/%s)\n"
p->agent
p
p
agent
ast_getformatname(ast_channel_readformat(chan))
ast_getformatname
ast_getformatname
ast_channel_readformat(chan)
ast_channel_readformat
ast_channel_readformat
chan
chan
ast_getformatname(ast_channel_writeformat(chan))
ast_getformatname
ast_getformatname
ast_channel_writeformat(chan)
ast_channel_writeformat
ast_channel_writeformat
chan
chan
p->chan = chan;
p->chan = chan
p->chan
p
p
chan
chan
chan
if (p->ackcall) {							check_beep(p, 0);						} else {							check_availability(p, 0);						}
p->ackcall
p
p
ackcall
{							check_beep(p, 0);						}
check_beep(p, 0);
check_beep(p, 0)
check_beep
check_beep
p
p
0
{							check_availability(p, 0);						}
check_availability(p, 0);
check_availability(p, 0)
check_availability
check_availability
p
p
0
ast_mutex_unlock(&p->lock);
ast_mutex_unlock(&p->lock)
ast_mutex_unlock
ast_mutex_unlock
&p->lock
p->lock
p
p
lock
AST_LIST_UNLOCK(&agents);
AST_LIST_UNLOCK(&agents)
AST_LIST_UNLOCK
AST_LIST_UNLOCK
&agents
agents
agents
ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Agent/%s", p->agent);
ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Agent/%s", p->agent)
ast_devstate_changed
ast_devstate_changed
AST_DEVICE_NOT_INUSE
AST_DEVICE_NOT_INUSE
"Agent/%s"
p->agent
p
p
agent
while (res >= 0) {							ast_mutex_lock(&p->lock);							if (p->deferlogoff && p->chan) {								ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);								p->deferlogoff = 0;							}							if (p->chan != chan)								res = -1;							ast_mutex_unlock(&p->lock);							/* Yield here so other interested threads can kick in. */							sched_yield();							if (res)								break;							AST_LIST_LOCK(&agents);							ast_mutex_lock(&p->lock);							if (p->lastdisc.tv_sec) {								if (ast_tvdiff_ms(ast_tvnow(), p->lastdisc) > 0) {									ast_debug(1, "Wrapup time for %s expired!\n", p->agent);									p->lastdisc = ast_tv(0, 0);									ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Agent/%s", p->agent);									if (p->ackcall) {										check_beep(p, 0);									} else {										check_availability(p, 0);									}								}							}							ast_mutex_unlock(&p->lock);							AST_LIST_UNLOCK(&agents);							/*	Synchronize channel ownership between call to agent and itself. */							ast_mutex_lock(&p->lock);							if (p->app_lock_flag == 1) {								ast_cond_signal(&p->login_wait_cond);								ast_cond_wait(&p->app_complete_cond, &p->lock);							}							ast_mutex_unlock(&p->lock);							if (p->ackcall) {								res = agent_ack_sleep(p);							} else {								res = ast_safe_sleep_conditional( chan, 1000, agent_cont_sleep, p );							}							if (p->ackcall && (res == 1)) {								AST_LIST_LOCK(&agents);								ast_mutex_lock(&p->lock);								check_availability(p, 0);								ast_mutex_unlock(&p->lock);								AST_LIST_UNLOCK(&agents);								res = 0;							}							sched_yield();						}
res >= 0
res
res
0
{							ast_mutex_lock(&p->lock);							if (p->deferlogoff && p->chan) {								ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);								p->deferlogoff = 0;							}							if (p->chan != chan)								res = -1;							ast_mutex_unlock(&p->lock);							/* Yield here so other interested threads can kick in. */							sched_yield();							if (res)								break;							AST_LIST_LOCK(&agents);							ast_mutex_lock(&p->lock);							if (p->lastdisc.tv_sec) {								if (ast_tvdiff_ms(ast_tvnow(), p->lastdisc) > 0) {									ast_debug(1, "Wrapup time for %s expired!\n", p->agent);									p->lastdisc = ast_tv(0, 0);									ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Agent/%s", p->agent);									if (p->ackcall) {										check_beep(p, 0);									} else {										check_availability(p, 0);									}								}							}							ast_mutex_unlock(&p->lock);							AST_LIST_UNLOCK(&agents);							/*	Synchronize channel ownership between call to agent and itself. */							ast_mutex_lock(&p->lock);							if (p->app_lock_flag == 1) {								ast_cond_signal(&p->login_wait_cond);								ast_cond_wait(&p->app_complete_cond, &p->lock);							}							ast_mutex_unlock(&p->lock);							if (p->ackcall) {								res = agent_ack_sleep(p);							} else {								res = ast_safe_sleep_conditional( chan, 1000, agent_cont_sleep, p );							}							if (p->ackcall && (res == 1)) {								AST_LIST_LOCK(&agents);								ast_mutex_lock(&p->lock);								check_availability(p, 0);								ast_mutex_unlock(&p->lock);								AST_LIST_UNLOCK(&agents);								res = 0;							}							sched_yield();						}
ast_mutex_lock(&p->lock);
ast_mutex_lock(&p->lock)
ast_mutex_lock
ast_mutex_lock
&p->lock
p->lock
p
p
lock
if (p->deferlogoff && p->chan) {								ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);								p->deferlogoff = 0;							}
p->deferlogoff && p->chan
p->deferlogoff
p
p
deferlogoff
p->chan
p
p
chan
{								ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);								p->deferlogoff = 0;							}
ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);
ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT)
ast_softhangup
ast_softhangup
p->chan
p
p
chan
AST_SOFTHANGUP_EXPLICIT
AST_SOFTHANGUP_EXPLICIT
p->deferlogoff = 0;
p->deferlogoff = 0
p->deferlogoff
p
p
deferlogoff
0
if (p->chan != chan)								res = -1;
p->chan != chan
p->chan
p
p
chan
chan
chan
res = -1;
res = -1
res
res
-1
1
ast_mutex_unlock(&p->lock);
ast_mutex_unlock(&p->lock)
ast_mutex_unlock
ast_mutex_unlock
&p->lock
p->lock
p
p
lock
sched_yield();
sched_yield()
sched_yield
sched_yield
if (res)								break;
res
res
break;
AST_LIST_LOCK(&agents);
AST_LIST_LOCK(&agents)
AST_LIST_LOCK
AST_LIST_LOCK
&agents
agents
agents
ast_mutex_lock(&p->lock);
ast_mutex_lock(&p->lock)
ast_mutex_lock
ast_mutex_lock
&p->lock
p->lock
p
p
lock
if (p->lastdisc.tv_sec) {								if (ast_tvdiff_ms(ast_tvnow(), p->lastdisc) > 0) {									ast_debug(1, "Wrapup time for %s expired!\n", p->agent);									p->lastdisc = ast_tv(0, 0);									ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Agent/%s", p->agent);									if (p->ackcall) {										check_beep(p, 0);									} else {										check_availability(p, 0);									}								}							}
p->lastdisc.tv_sec
p->lastdisc
p
p
lastdisc
tv_sec
{								if (ast_tvdiff_ms(ast_tvnow(), p->lastdisc) > 0) {									ast_debug(1, "Wrapup time for %s expired!\n", p->agent);									p->lastdisc = ast_tv(0, 0);									ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Agent/%s", p->agent);									if (p->ackcall) {										check_beep(p, 0);									} else {										check_availability(p, 0);									}								}							}
if (ast_tvdiff_ms(ast_tvnow(), p->lastdisc) > 0) {									ast_debug(1, "Wrapup time for %s expired!\n", p->agent);									p->lastdisc = ast_tv(0, 0);									ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Agent/%s", p->agent);									if (p->ackcall) {										check_beep(p, 0);									} else {										check_availability(p, 0);									}								}
ast_tvdiff_ms(ast_tvnow(), p->lastdisc) > 0
ast_tvdiff_ms(ast_tvnow(), p->lastdisc)
ast_tvdiff_ms
ast_tvdiff_ms
ast_tvnow()
ast_tvnow
ast_tvnow
p->lastdisc
p
p
lastdisc
0
{									ast_debug(1, "Wrapup time for %s expired!\n", p->agent);									p->lastdisc = ast_tv(0, 0);									ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Agent/%s", p->agent);									if (p->ackcall) {										check_beep(p, 0);									} else {										check_availability(p, 0);									}								}
ast_debug(1, "Wrapup time for %s expired!\n", p->agent);
ast_debug(1, "Wrapup time for %s expired!\n", p->agent)
ast_debug
ast_debug
1
"Wrapup time for %s expired!\n"
p->agent
p
p
agent
p->lastdisc = ast_tv(0, 0);
p->lastdisc = ast_tv(0, 0)
p->lastdisc
p
p
lastdisc
ast_tv(0, 0)
ast_tv
ast_tv
0
0
ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Agent/%s", p->agent);
ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Agent/%s", p->agent)
ast_devstate_changed
ast_devstate_changed
AST_DEVICE_NOT_INUSE
AST_DEVICE_NOT_INUSE
"Agent/%s"
p->agent
p
p
agent
if (p->ackcall) {										check_beep(p, 0);									} else {										check_availability(p, 0);									}
p->ackcall
p
p
ackcall
{										check_beep(p, 0);									}
check_beep(p, 0);
check_beep(p, 0)
check_beep
check_beep
p
p
0
{										check_availability(p, 0);									}
check_availability(p, 0);
check_availability(p, 0)
check_availability
check_availability
p
p
0
ast_mutex_unlock(&p->lock);
ast_mutex_unlock(&p->lock)
ast_mutex_unlock
ast_mutex_unlock
&p->lock
p->lock
p
p
lock
AST_LIST_UNLOCK(&agents);
AST_LIST_UNLOCK(&agents)
AST_LIST_UNLOCK
AST_LIST_UNLOCK
&agents
agents
agents
ast_mutex_lock(&p->lock);
ast_mutex_lock(&p->lock)
ast_mutex_lock
ast_mutex_lock
&p->lock
p->lock
p
p
lock
if (p->app_lock_flag == 1) {								ast_cond_signal(&p->login_wait_cond);								ast_cond_wait(&p->app_complete_cond, &p->lock);							}
p->app_lock_flag == 1
p->app_lock_flag
p
p
app_lock_flag
1
{								ast_cond_signal(&p->login_wait_cond);								ast_cond_wait(&p->app_complete_cond, &p->lock);							}
ast_cond_signal(&p->login_wait_cond);
ast_cond_signal(&p->login_wait_cond)
ast_cond_signal
ast_cond_signal
&p->login_wait_cond
p->login_wait_cond
p
p
login_wait_cond
ast_cond_wait(&p->app_complete_cond, &p->lock);
ast_cond_wait(&p->app_complete_cond, &p->lock)
ast_cond_wait
ast_cond_wait
&p->app_complete_cond
p->app_complete_cond
p
p
app_complete_cond
&p->lock
p->lock
p
p
lock
ast_mutex_unlock(&p->lock);
ast_mutex_unlock(&p->lock)
ast_mutex_unlock
ast_mutex_unlock
&p->lock
p->lock
p
p
lock
if (p->ackcall) {								res = agent_ack_sleep(p);							} else {								res = ast_safe_sleep_conditional( chan, 1000, agent_cont_sleep, p );							}
p->ackcall
p
p
ackcall
{								res = agent_ack_sleep(p);							}
res = agent_ack_sleep(p);
res = agent_ack_sleep(p)
res
res
agent_ack_sleep(p)
agent_ack_sleep
agent_ack_sleep
p
p
{								res = ast_safe_sleep_conditional( chan, 1000, agent_cont_sleep, p );							}
res = ast_safe_sleep_conditional( chan, 1000, agent_cont_sleep, p );
res = ast_safe_sleep_conditional( chan, 1000, agent_cont_sleep, p )
res
res
ast_safe_sleep_conditional( chan, 1000, agent_cont_sleep, p )
ast_safe_sleep_conditional
ast_safe_sleep_conditional
chan
chan
1000
agent_cont_sleep
agent_cont_sleep
p
p
if (p->ackcall && (res == 1)) {								AST_LIST_LOCK(&agents);								ast_mutex_lock(&p->lock);								check_availability(p, 0);								ast_mutex_unlock(&p->lock);								AST_LIST_UNLOCK(&agents);								res = 0;							}
p->ackcall && (res == 1)
p->ackcall
p
p
ackcall
(res == 1)
res == 1
res
res
1
{								AST_LIST_LOCK(&agents);								ast_mutex_lock(&p->lock);								check_availability(p, 0);								ast_mutex_unlock(&p->lock);								AST_LIST_UNLOCK(&agents);								res = 0;							}
AST_LIST_LOCK(&agents);
AST_LIST_LOCK(&agents)
AST_LIST_LOCK
AST_LIST_LOCK
&agents
agents
agents
ast_mutex_lock(&p->lock);
ast_mutex_lock(&p->lock)
ast_mutex_lock
ast_mutex_lock
&p->lock
p->lock
p
p
lock
check_availability(p, 0);
check_availability(p, 0)
check_availability
check_availability
p
p
0
ast_mutex_unlock(&p->lock);
ast_mutex_unlock(&p->lock)
ast_mutex_unlock
ast_mutex_unlock
&p->lock
p->lock
p
p
lock
AST_LIST_UNLOCK(&agents);
AST_LIST_UNLOCK(&agents)
AST_LIST_UNLOCK
AST_LIST_UNLOCK
&agents
agents
agents
res = 0;
res = 0
res
res
0
sched_yield();
sched_yield()
sched_yield
sched_yield
ast_mutex_lock(&p->lock);
ast_mutex_lock(&p->lock)
ast_mutex_lock
ast_mutex_lock
&p->lock
p->lock
p
p
lock
if (p->chan == chan) {							p->chan = NULL;						}
p->chan == chan
p->chan
p
p
chan
chan
chan
{							p->chan = NULL;						}
p->chan = NULL;
p->chan = NULL
p->chan
p
p
chan
NULL
NULL
if (p->app_lock_flag == 1) {							ast_cond_signal(&p->login_wait_cond);							ast_cond_wait(&p->app_complete_cond, &p->lock);						}
p->app_lock_flag == 1
p->app_lock_flag
p
p
app_lock_flag
1
{							ast_cond_signal(&p->login_wait_cond);							ast_cond_wait(&p->app_complete_cond, &p->lock);						}
ast_cond_signal(&p->login_wait_cond);
ast_cond_signal(&p->login_wait_cond)
ast_cond_signal
ast_cond_signal
&p->login_wait_cond
p->login_wait_cond
p
p
login_wait_cond
ast_cond_wait(&p->app_complete_cond, &p->lock);
ast_cond_wait(&p->app_complete_cond, &p->lock)
ast_cond_wait
ast_cond_wait
&p->app_complete_cond
p->app_complete_cond
p
p
app_complete_cond
&p->lock
p->lock
p
p
lock
if (res && p->owner)							ast_log(LOG_WARNING, "Huh?  We broke out when there was still an owner?\n");
res && p->owner
res
res
p->owner
p
p
owner
ast_log(LOG_WARNING, "Huh?  We broke out when there was still an owner?\n");
ast_log(LOG_WARNING, "Huh?  We broke out when there was still an owner?\n")
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"Huh?  We broke out when there was still an owner?\n"
p->acknowledged = 0;
p->acknowledged = 0
p->acknowledged
p
p
acknowledged
0
logintime = time(NULL) - p->loginstart;
logintime = time(NULL) - p->loginstart
logintime
logintime
time(NULL) - p->loginstart
time(NULL)
time
time
NULL
NULL
p->loginstart
p
p
loginstart
p->loginstart = 0;
p->loginstart = 0
p->loginstart
p
p
loginstart
0
ast_mutex_unlock(&p->lock);
ast_mutex_unlock(&p->lock)
ast_mutex_unlock
ast_mutex_unlock
&p->lock
p->lock
p
p
lock
manager_event(EVENT_FLAG_AGENT, "Agentlogoff",							      "Agent: %s\r\n"							      "Logintime: %ld\r\n"							      "Uniqueid: %s\r\n",							      p->agent, logintime, ast_channel_uniqueid(chan));
manager_event(EVENT_FLAG_AGENT, "Agentlogoff",							      "Agent: %s\r\n"							      "Logintime: %ld\r\n"							      "Uniqueid: %s\r\n",							      p->agent, logintime, ast_channel_uniqueid(chan))
manager_event
manager_event
EVENT_FLAG_AGENT
EVENT_FLAG_AGENT
"Agentlogoff"
"Agent: %s\r\n"							      "Logintime: %ld\r\n"							      "Uniqueid: %s\r\n"
p->agent
p
p
agent
logintime
logintime
ast_channel_uniqueid(chan)
ast_channel_uniqueid
ast_channel_uniqueid
chan
chan
ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGOFF", "%s|%ld", ast_channel_name(chan), logintime);
ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGOFF", "%s|%ld", ast_channel_name(chan), logintime)
ast_queue_log
ast_queue_log
"NONE"
ast_channel_uniqueid(chan)
ast_channel_uniqueid
ast_channel_uniqueid
chan
chan
agent
agent
"AGENTLOGOFF"
"%s|%ld"
ast_channel_name(chan)
ast_channel_name
ast_channel_name
chan
chan
logintime
logintime
ast_verb(2, "Agent '%s' logged out\n", p->agent);
ast_verb(2, "Agent '%s' logged out\n", p->agent)
ast_verb
ast_verb
2
"Agent '%s' logged out\n"
p->agent
p
p
agent
ast_devstate_changed(AST_DEVICE_UNAVAILABLE, "Agent/%s", p->agent);
ast_devstate_changed(AST_DEVICE_UNAVAILABLE, "Agent/%s", p->agent)
ast_devstate_changed
ast_devstate_changed
AST_DEVICE_UNAVAILABLE
AST_DEVICE_UNAVAILABLE
"Agent/%s"
p->agent
p
p
agent
if (p->dead && !p->owner) {							ast_mutex_destroy(&p->lock);							ast_cond_destroy(&p->app_complete_cond);							ast_cond_destroy(&p->login_wait_cond);							ast_free(p);						}
p->dead && !p->owner
p->dead
p
p
dead
!p->owner
p->owner
p
p
owner
{							ast_mutex_destroy(&p->lock);							ast_cond_destroy(&p->app_complete_cond);							ast_cond_destroy(&p->login_wait_cond);							ast_free(p);						}
ast_mutex_destroy(&p->lock);
ast_mutex_destroy(&p->lock)
ast_mutex_destroy
ast_mutex_destroy
&p->lock
p->lock
p
p
lock
ast_cond_destroy(&p->app_complete_cond);
ast_cond_destroy(&p->app_complete_cond)
ast_cond_destroy
ast_cond_destroy
&p->app_complete_cond
p->app_complete_cond
p
p
app_complete_cond
ast_cond_destroy(&p->login_wait_cond);
ast_cond_destroy(&p->login_wait_cond)
ast_cond_destroy
ast_cond_destroy
&p->login_wait_cond
p->login_wait_cond
p
p
login_wait_cond
ast_free(p);
ast_free(p)
ast_free
ast_free
p
p
{						ast_mutex_unlock(&p->lock);						p = NULL;					}
ast_mutex_unlock(&p->lock);
ast_mutex_unlock(&p->lock)
ast_mutex_unlock
ast_mutex_unlock
&p->lock
p->lock
p
p
lock
p = NULL;
p = NULL
p
p
NULL
NULL
res = -1;
res = -1
res
res
-1
1
{					ast_mutex_unlock(&p->lock);					errmsg = "agent-alreadyon";					p = NULL;				}
ast_mutex_unlock(&p->lock);
ast_mutex_unlock(&p->lock)
ast_mutex_unlock
ast_mutex_unlock
&p->lock
p->lock
p
p
lock
errmsg = "agent-alreadyon";
errmsg = "agent-alreadyon"
errmsg
errmsg
"agent-alreadyon"
p = NULL;
p = NULL
p
p
NULL
NULL
break;
ast_mutex_unlock(&p->lock);
ast_mutex_unlock(&p->lock)
ast_mutex_unlock
ast_mutex_unlock
&p->lock
p->lock
p
p
lock
if (unlock_channel) {				ast_channel_unlock(chan);			}
unlock_channel
unlock_channel
{				ast_channel_unlock(chan);			}
ast_channel_unlock(chan);
ast_channel_unlock(chan)
ast_channel_unlock
ast_channel_unlock
chan
chan
if (!p)			AST_LIST_UNLOCK(&agents);
!p
p
p
AST_LIST_UNLOCK(&agents);
AST_LIST_UNLOCK(&agents)
AST_LIST_UNLOCK
AST_LIST_UNLOCK
&agents
agents
agents
if (!res && (max_login_tries==0 || tries < max_login_tries))			res = ast_app_getdata(chan, errmsg, user, sizeof(user) - 1, 0);
!res && (max_login_tries==0 || tries < max_login_tries)
!res
res
res
(max_login_tries==0 || tries < max_login_tries)
max_login_tries==0 || tries < max_login_tries
max_login_tries==0
max_login_tries
max_login_tries
0
tries < max_login_tries
tries
tries
max_login_tries
max_login_tries
res = ast_app_getdata(chan, errmsg, user, sizeof(user) - 1, 0);
res = ast_app_getdata(chan, errmsg, user, sizeof(user) - 1, 0)
res
res
ast_app_getdata(chan, errmsg, user, sizeof(user) - 1, 0)
ast_app_getdata
ast_app_getdata
chan
chan
errmsg
errmsg
user
user
sizeof(user) - 1
sizeof(user)
(user)
user
user
1
0
if (!res)		res = ast_safe_sleep(chan, 500);
!res
res
res
res = ast_safe_sleep(chan, 500);
res = ast_safe_sleep(chan, 500)
res
res
ast_safe_sleep(chan, 500)
ast_safe_sleep
ast_safe_sleep
chan
chan
500
ast_module_user_remove(u);
ast_module_user_remove(u)
ast_module_user_remove
ast_module_user_remove
u
u
return -1;
-1
1
-----joern-----
(1131,232,0)
(745,23,0)
(875,887,0)
(421,840,0)
(803,344,0)
(144,505,0)
(347,833,0)
(578,1044,0)
(407,736,0)
(894,306,0)
(22,534,0)
(69,118,0)
(537,520,0)
(47,376,0)
(77,584,0)
(483,334,0)
(650,563,0)
(318,266,0)
(82,886,0)
(265,903,0)
(958,887,0)
(257,141,0)
(47,1139,0)
(750,586,0)
(351,205,0)
(829,130,0)
(52,558,0)
(911,117,0)
(820,752,0)
(1005,971,0)
(684,12,0)
(1041,579,0)
(499,654,0)
(344,803,0)
(928,334,0)
(68,733,0)
(825,345,0)
(989,274,0)
(850,274,0)
(863,1141,0)
(400,305,0)
(811,334,0)
(998,1031,0)
(269,702,0)
(682,550,0)
(263,635,0)
(1078,906,0)
(96,7,0)
(1005,952,0)
(507,586,0)
(649,1021,0)
(1016,536,0)
(982,261,0)
(443,979,0)
(887,106,0)
(345,834,0)
(770,906,0)
(47,641,0)
(1037,1031,0)
(382,430,0)
(943,934,0)
(237,170,0)
(60,673,0)
(110,529,0)
(798,238,0)
(1073,213,0)
(1130,693,0)
(348,886,0)
(911,488,0)
(718,334,0)
(870,212,0)
(274,989,0)
(583,1157,0)
(978,334,0)
(265,116,0)
(175,928,0)
(656,719,0)
(1038,895,0)
(727,359,0)
(915,1088,0)
(1092,687,0)
(104,123,0)
(1097,596,0)
(137,1098,0)
(868,584,0)
(784,643,0)
(326,689,0)
(250,94,0)
(1120,1032,0)
(1094,620,0)
(983,32,0)
(1030,909,0)
(427,116,0)
(789,984,0)
(41,910,0)
(1116,237,0)
(162,675,0)
(1024,318,0)
(413,19,0)
(598,1021,0)
(874,41,0)
(576,768,0)
(1091,110,0)
(624,841,0)
(674,482,0)
(600,908,0)
(434,7,0)
(500,85,0)
(427,736,0)
(28,1021,0)
(557,988,0)
(665,584,0)
(227,94,0)
(547,736,0)
(319,334,0)
(552,751,0)
(601,1009,0)
(977,305,0)
(1106,1121,0)
(717,12,0)
(827,736,0)
(751,934,0)
(793,399,0)
(612,468,0)
(353,628,0)
(882,1031,0)
(912,990,0)
(32,916,0)
(1074,569,0)
(1095,330,0)
(118,1098,0)
(159,727,0)
(517,703,0)
(1056,723,0)
(461,949,0)
(340,785,0)
(1089,550,0)
(43,115,0)
(234,972,0)
(250,805,0)
(1057,306,0)
(913,123,0)
(571,282,0)
(693,46,0)
(515,658,0)
(952,1158,0)
(317,380,0)
(1115,753,0)
(1107,908,0)
(1035,58,0)
(856,908,0)
(815,1031,0)
(250,736,0)
(359,727,0)
(466,1031,0)
(418,1083,0)
(1,972,0)
(1077,371,0)
(105,334,0)
(171,1113,0)
(555,1013,0)
(46,334,0)
(897,948,0)
(777,477,0)
(531,876,0)
(482,584,0)
(876,180,0)
(233,200,0)
(639,766,0)
(85,245,0)
(572,69,0)
(25,529,0)
(505,378,0)
(372,780,0)
(256,458,0)
(328,604,0)
(307,1107,0)
(210,384,0)
(228,1043,0)
(624,1118,0)
(1117,933,0)
(244,1021,0)
(195,504,0)
(229,744,0)
(1141,908,0)
(1154,673,0)
(218,334,0)
(163,157,0)
(1032,659,0)
(994,528,0)
(484,442,0)
(827,931,0)
(303,528,0)
(1052,137,0)
(167,488,0)
(361,815,0)
(861,7,0)
(832,1084,0)
(1153,75,0)
(739,960,0)
(312,910,0)
(506,334,0)
(540,1092,0)
(746,884,0)
(1091,196,0)
(729,1021,0)
(71,1031,0)
(379,378,0)
(349,896,0)
(57,667,0)
(430,1021,0)
(44,733,0)
(427,805,0)
(574,407,0)
(478,827,0)
(1109,368,0)
(625,548,0)
(179,1083,0)
(310,558,0)
(427,217,0)
(394,1031,0)
(139,104,0)
(819,1140,0)
(202,75,0)
(1158,454,0)
(672,884,0)
(731,323,0)
(624,815,0)
(550,1089,0)
(409,6,0)
(301,1031,0)
(15,1021,0)
(129,979,0)
(620,302,0)
(693,569,0)
(251,344,0)
(1066,1031,0)
(490,1115,0)
(27,264,0)
(925,317,0)
(118,1142,0)
(1152,725,0)
(557,687,0)
(623,458,0)
(450,160,0)
(36,523,0)
(763,132,0)
(935,850,0)
(719,334,0)
(1113,334,0)
(221,93,0)
(362,380,0)
(154,678,0)
(663,423,0)
(115,43,0)
(70,1069,0)
(254,844,0)
(1093,160,0)
(895,317,0)
(699,331,0)
(832,1082,0)
(678,154,0)
(629,913,0)
(686,949,0)
(319,97,0)
(192,995,0)
(18,921,0)
(333,455,0)
(557,540,0)
(1000,1004,0)
(74,673,0)
(216,470,0)
(946,240,0)
(47,615,0)
(51,516,0)
(989,132,0)
(403,231,0)
(536,660,0)
(658,666,0)
(565,410,0)
(995,803,0)
(567,708,0)
(35,953,0)
(106,976,0)
(180,876,0)
(1128,182,0)
(754,1098,0)
(220,984,0)
(582,1158,0)
(893,709,0)
(520,1056,0)
(542,972,0)
(411,528,0)
(888,47,0)
(47,796,0)
(816,1088,0)
(493,987,0)
(1012,256,0)
(167,584,0)
(431,995,0)
(855,344,0)
(242,238,0)
(338,334,0)
(622,372,0)
(928,482,0)
(1121,1068,0)
(607,846,0)
(398,60,0)
(847,963,0)
(1150,898,0)
(537,94,0)
(545,672,0)
(468,859,0)
(401,813,0)
(271,710,0)
(894,217,0)
(1140,819,0)
(287,659,0)
(239,334,0)
(1114,659,0)
(388,154,0)
(961,1113,0)
(51,334,0)
(544,126,0)
(1029,129,0)
(518,710,0)
(209,1037,0)
(393,498,0)
(1047,213,0)
(1156,483,0)
(217,423,0)
(369,948,0)
(929,265,0)
(13,1021,0)
(969,334,0)
(521,115,0)
(818,976,0)
(633,147,0)
(965,85,0)
(107,969,0)
(457,126,0)
(145,984,0)
(455,333,0)
(197,908,0)
(467,765,0)
(1000,172,0)
(304,908,0)
(50,60,0)
(513,334,0)
(345,290,0)
(723,1084,0)
(1011,1090,0)
(170,566,0)
(468,1163,0)
(995,933,0)
(47,1149,0)
(432,680,0)
(1164,805,0)
(164,1139,0)
(239,246,0)
(685,819,0)
(440,979,0)
(1025,278,0)
(128,949,0)
(345,232,0)
(1082,128,0)
(318,941,0)
(608,1129,0)
(625,261,0)
(382,535,0)
(124,841,0)
(511,205,0)
(613,718,0)
(390,277,0)
(1170,751,0)
(895,805,0)
(345,334,0)
(39,672,0)
(591,458,0)
(419,334,0)
(252,778,0)
(634,947,0)
(193,356,0)
(20,166,0)
(833,605,0)
(501,374,0)
(29,482,0)
(659,287,0)
(1129,334,0)
(463,660,0)
(1043,29,0)
(688,177,0)
(813,141,0)
(1003,1031,0)
(250,317,0)
(773,801,0)
(936,718,0)
(199,1141,0)
(124,834,0)
(1048,105,0)
(507,1070,0)
(1018,907,0)
(76,476,0)
(1107,1127,0)
(329,1121,0)
(373,205,0)
(470,126,0)
(734,7,0)
(1005,465,0)
(577,1065,0)
(880,323,0)
(771,783,0)
(157,584,0)
(377,788,0)
(98,408,0)
(1152,1098,0)
(1080,779,0)
(537,841,0)
(1092,179,0)
(850,949,0)
(258,583,0)
(594,928,0)
(371,282,0)
(176,610,0)
(817,458,0)
(788,1163,0)
(385,1127,0)
(960,427,0)
(119,1090,0)
(586,507,0)
(47,396,0)
(1067,811,0)
(1144,537,0)
(487,1143,0)
(95,796,0)
(96,953,0)
(438,611,0)
(286,927,0)
(543,27,0)
(833,347,0)
(895,94,0)
(1103,884,0)
(1141,199,0)
(905,395,0)
(473,716,0)
(1112,1031,0)
(9,1005,0)
(902,641,0)
(118,69,0)
(984,908,0)
(1118,972,0)
(772,75,0)
(10,500,0)
(313,504,0)
(1017,702,0)
(942,557,0)
(108,689,0)
(224,768,0)
(1050,240,0)
(757,536,0)
(195,48,0)
(1079,479,0)
(738,1031,0)
(386,1084,0)
(840,421,0)
(143,1133,0)
(951,458,0)
(887,402,0)
(551,549,0)
(723,1056,0)
(335,690,0)
(210,235,0)
(200,483,0)
(1028,1063,0)
(1083,179,0)
(778,558,0)
(128,291,0)
(397,231,0)
(895,834,0)
(331,126,0)
(128,1084,0)
(906,187,0)
(590,672,0)
(240,946,0)
(1087,692,0)
(1151,455,0)
(213,84,0)
(48,195,0)
(208,399,0)
(952,1005,0)
(624,94,0)
(789,334,0)
(996,419,0)
(743,815,0)
(918,7,0)
(857,1103,0)
(1051,154,0)
(152,584,0)
(570,106,0)
(975,672,0)
(100,723,0)
(456,549,0)
(182,1128,0)
(1094,184,0)
(939,290,0)
(284,534,0)
(648,668,0)
(733,357,0)
(113,580,0)
(978,901,0)
(58,769,0)
(748,908,0)
(378,505,0)
(668,896,0)
(327,1031,0)
(852,1085,0)
(964,463,0)
(1124,766,0)
(266,318,0)
(756,384,0)
(514,166,0)
(537,815,0)
(709,264,0)
(316,34,0)
(1050,282,0)
(540,533,0)
(1149,748,0)
(846,934,0)
(898,390,0)
(246,1146,0)
(887,464,0)
(47,1069,0)
(137,334,0)
(3,218,0)
(1104,535,0)
(124,94,0)
(6,834,0)
(646,234,0)
(16,1031,0)
(151,833,0)
(550,334,0)
(563,650,0)
(359,817,0)
(125,1135,0)
(934,846,0)
(799,696,0)
(112,615,0)
(876,464,0)
(941,696,0)
(248,1021,0)
(30,919,0)
(132,989,0)
(801,486,0)
(365,83,0)
(194,514,0)
(962,85,0)
(250,1118,0)
(4,280,0)
(296,513,0)
(24,297,0)
(1006,718,0)
(922,1141,0)
(1090,1031,0)
(1026,87,0)
(47,1013,0)
(20,235,0)
(585,1064,0)
(930,894,0)
(595,954,0)
(715,748,0)
(1135,334,0)
(1010,817,0)
(47,348,0)
(130,803,0)
(186,396,0)
(338,788,0)
(1106,1065,0)
(235,20,0)
(387,445,0)
(1032,884,0)
(782,147,0)
(509,1021,0)
(124,736,0)
(149,777,0)
(1056,850,0)
(188,1153,0)
(2,400,0)
(953,96,0)
(14,674,0)
(447,654,0)
(355,7,0)
(262,1089,0)
(462,261,0)
(948,1018,0)
(879,852,0)
(293,334,0)
(813,410,0)
(843,356,0)
(133,294,0)
(1166,172,0)
(161,29,0)
(155,313,0)
(511,979,0)
(396,1092,0)
(718,979,0)
(836,975,0)
(627,423,0)
(315,887,0)
(1133,1031,0)
(61,1022,0)
(895,736,0)
(66,465,0)
(218,736,0)
(42,243,0)
(931,768,0)
(65,745,0)
(86,87,0)
(662,919,0)
(63,1021,0)
(641,569,0)
(1070,628,0)
(891,752,0)
(632,642,0)
(824,1127,0)
(190,477,0)
(573,1034,0)
(1027,101,0)
(260,376,0)
(166,20,0)
(38,345,0)
(827,94,0)
(1029,718,0)
(376,1028,0)
(1044,1031,0)
(465,1005,0)
(47,1122,0)
(391,457,0)
(85,178,0)
(283,1001,0)
(53,584,0)
(196,1091,0)
(539,292,0)
(1101,901,0)
(122,127,0)
(306,894,0)
(1121,1106,0)
(532,641,0)
(360,979,0)
(984,966,0)
(730,966,0)
(452,1107,0)
(168,1031,0)
(741,444,0)
(1135,1103,0)
(895,217,0)
(645,1003,0)
(786,488,0)
(414,726,0)
(471,314,0)
(618,338,0)
(827,841,0)
(830,1031,0)
(1045,29,0)
(886,348,0)
(488,911,0)
(104,948,0)
(604,905,0)
(672,545,0)
(492,220,0)
(191,908,0)
(821,852,0)
(658,334,0)
(277,908,0)
(672,908,0)
(701,402,0)
(909,1141,0)
(564,76,0)
(142,476,0)
(919,410,0)
(910,41,0)
(342,184,0)
(995,117,0)
(720,118,0)
(647,815,0)
(80,507,0)
(380,317,0)
(181,635,0)
(375,801,0)
(83,458,0)
(992,313,0)
(864,427,0)
(657,1048,0)
(954,595,0)
(522,643,0)
(874,357,0)
(895,1118,0)
(215,960,0)
(762,540,0)
(231,853,0)
(1080,248,0)
(141,813,0)
(489,1018,0)
(243,736,0)
(1019,1031,0)
(900,917,0)
(198,1082,0)
(1136,1021,0)
(894,334,0)
(1140,707,0)
(459,374,0)
(856,23,0)
(318,696,0)
(718,1029,0)
(907,1018,0)
(273,672,0)
(700,1122,0)
(742,662,0)
(781,1103,0)
(548,1021,0)
(267,912,0)
(659,7,0)
(850,291,0)
(1020,584,0)
(128,274,0)
(851,1034,0)
(637,1030,0)
(571,780,0)
(229,1033,0)
(1137,911,0)
(49,1115,0)
(256,291,0)
(1058,513,0)
(47,879,0)
(477,7,0)
(211,990,0)
(562,110,0)
(43,1063,0)
(819,685,0)
(109,765,0)
(974,376,0)
(1119,347,0)
(115,569,0)
(1064,893,0)
(17,544,0)
(422,412,0)
(932,122,0)
(842,525,0)
(556,642,0)
(1147,1026,0)
(956,157,0)
(509,563,0)
(822,108,0)
(56,387,0)
(830,961,0)
(1098,137,0)
(689,7,0)
(426,723,0)
(993,620,0)
(1082,198,0)
(844,983,0)
(250,217,0)
(241,538,0)
(575,7,0)
(18,766,0)
(988,687,0)
(607,235,0)
(129,1029,0)
(479,828,0)
(507,949,0)
(496,1123,0)
(32,983,0)
(614,674,0)
(1001,206,0)
(47,553,0)
(292,212,0)
(1158,952,0)
(944,115,0)
(690,335,0)
(1094,852,0)
(1023,250,0)
(569,908,0)
(285,239,0)
(248,1080,0)
(809,354,0)
(408,580,0)
(631,783,0)
(381,189,0)
(984,220,0)
(97,310,0)
(23,856,0)
(814,348,0)
(787,293,0)
(1059,896,0)
(62,908,0)
(859,468,0)
(1055,187,0)
(1105,387,0)
(624,736,0)
(827,815,0)
(322,1094,0)
(150,513,0)
(337,788,0)
(885,841,0)
(723,274,0)
(75,512,0)
(975,334,0)
(859,334,0)
(343,853,0)
(788,338,0)
(952,334,0)
(649,297,0)
(200,233,0)
(768,931,0)
(678,244,0)
(967,216,0)
(196,523,0)
(323,634,0)
(876,675,0)
(912,1163,0)
(6,841,0)
(643,1128,0)
(1081,1034,0)
(1153,188,0)
(441,615,0)
(454,1158,0)
(979,1031,0)
(934,979,0)
(652,293,0)
(245,620,0)
(275,863,0)
(6,815,0)
(1165,133,0)
(676,927,0)
(356,94,0)
(968,907,0)
(387,334,0)
(1069,803,0)
(439,1123,0)
(887,412,0)
(1110,507,0)
(1103,506,0)
(616,319,0)
(903,1094,0)
(785,334,0)
(309,1094,0)
(178,314,0)
(761,282,0)
(689,108,0)
(407,198,0)
(420,1118,0)
(482,928,0)
(136,1026,0)
(534,954,0)
(905,604,0)
(189,1070,0)
(981,1069,0)
(692,687,0)
(79,287,0)
(1030,334,0)
(270,266,0)
(1143,299,0)
(752,1077,0)
(1145,347,0)
(523,196,0)
(788,912,0)
(392,506,0)
(783,631,0)
(350,232,0)
(264,27,0)
(566,126,0)
(528,303,0)
(881,788,0)
(279,455,0)
(295,679,0)
(140,1037,0)
(517,642,0)
(546,886,0)
(88,817,0)
(187,249,0)
(835,1031,0)
(427,378,0)
(153,913,0)
(907,334,0)
(547,841,0)
(640,220,0)
(840,1021,0)
(619,535,0)
(916,32,0)
(858,736,0)
(1070,189,0)
(425,692,0)
(1126,336,0)
(579,695,0)
(383,46,0)
(223,661,0)
(526,584,0)
(947,126,0)
(547,94,0)
(384,210,0)
(606,685,0)
(1008,828,0)
(765,109,0)
(559,69,0)
(691,597,0)
(712,1143,0)
(554,779,0)
(442,527,0)
(427,815,0)
(1037,209,0)
(683,212,0)
(311,719,0)
(395,905,0)
(895,457,0)
(1102,440,0)
(679,596,0)
(1084,1031,0)
(1015,51,0)
(670,1031,0)
(265,833,0)
(510,702,0)
(775,583,0)
(250,834,0)
(104,310,0)
(1007,345,0)
(588,1149,0)
(927,1031,0)
(475,887,0)
(890,510,0)
(417,1075,0)
(760,104,0)
(673,60,0)
(277,390,0)
(178,969,0)
(566,170,0)
(696,1031,0)
(451,672,0)
(839,336,0)
(638,203,0)
(934,751,0)
(406,832,0)
(348,434,0)
(247,437,0)
(611,917,0)
(893,1064,0)
(705,335,0)
(986,128,0)
(235,607,0)
(959,1021,0)
(1115,490,0)
(299,1143,0)
(597,754,0)
(795,661,0)
(883,596,0)
(779,1080,0)
(636,419,0)
(933,995,0)
(491,464,0)
(764,1149,0)
(55,796,0)
(183,449,0)
(85,500,0)
(722,946,0)
(711,1076,0)
(988,293,0)
(399,310,0)
(1033,229,0)
(445,387,0)
(64,287,0)
(236,788,0)
(895,833,0)
(848,454,0)
(941,318,0)
(651,1141,0)
(110,1091,0)
(495,879,0)
(179,1092,0)
(1061,948,0)
(796,184,0)
(1098,584,0)
(854,449,0)
(766,18,0)
(390,898,0)
(404,129,0)
(523,1129,0)
(430,382,0)
(681,26,0)
(867,809,0)
(427,457,0)
(1072,123,0)
(966,984,0)
(984,789,0)
(1115,856,0)
(84,414,0)
(1160,294,0)
(916,511,0)
(97,319,0)
(366,969,0)
(511,916,0)
(298,1031,0)
(106,412,0)
(73,908,0)
(111,941,0)
(1139,620,0)
(330,713,0)
(185,830,0)
(805,12,0)
(706,457,0)
(709,893,0)
(850,1056,0)
(971,527,0)
(831,859,0)
(541,525,0)
(8,92,0)
(728,428,0)
(805,1089,0)
(940,884,0)
(889,662,0)
(507,628,0)
(1127,1107,0)
(118,691,0)
(0,1031,0)
(1049,58,0)
(877,7,0)
(568,1115,0)
(919,662,0)
(1168,777,0)
(797,463,0)
(758,1121,0)
(1062,159,0)
(869,93,0)
(138,911,0)
(661,314,0)
(47,913,0)
(547,834,0)
(201,137,0)
(217,894,0)
(472,1019,0)
(1134,159,0)
(488,167,0)
(1034,851,0)
(1113,961,0)
(173,444,0)
(823,976,0)
(690,7,0)
(655,196,0)
(1148,1037,0)
(895,841,0)
(465,333,0)
(444,741,0)
(41,874,0)
(449,23,0)
(561,113,0)
(1018,558,0)
(1169,984,0)
(1089,334,0)
(310,97,0)
(253,579,0)
(134,172,0)
(860,952,0)
(117,584,0)
(721,245,0)
(691,118,0)
(243,1118,0)
(196,177,0)
(950,895,0)
(827,834,0)
(703,517,0)
(295,817,0)
(294,133,0)
(972,1118,0)
(90,1044,0)
(630,109,0)
(87,671,0)
(356,334,0)
(419,996,0)
(527,442,0)
(506,1103,0)
(609,1064,0)
(116,899,0)
(1076,908,0)
(339,961,0)
(45,458,0)
(481,27,0)
(34,316,0)
(415,372,0)
(828,479,0)
(6,94,0)
(1040,844,0)
(234,334,0)
(535,382,0)
(593,697,0)
(737,817,0)
(990,334,0)
(504,195,0)
(987,45,0)
(288,128,0)
(887,675,0)
(250,815,0)
(189,334,0)
(198,407,0)
(832,949,0)
(47,428,0)
(914,650,0)
(1125,553,0)
(1109,769,0)
(166,514,0)
(806,910,0)
(67,1115,0)
(476,1031,0)
(895,116,0)
(427,834,0)
(399,538,0)
(534,334,0)
(1090,476,0)
(1100,946,0)
(128,1082,0)
(878,1022,0)
(1088,802,0)
(837,1031,0)
(225,533,0)
(427,960,0)
(580,408,0)
(1111,490,0)
(834,345,0)
(520,537,0)
(525,1031,0)
(75,1153,0)
(131,356,0)
(127,122,0)
(921,18,0)
(937,384,0)
(917,1031,0)
(268,1083,0)
(203,199,0)
(76,923,0)
(972,525,0)
(172,1000,0)
(714,490,0)
(116,278,0)
(414,84,0)
(1046,130,0)
(698,239,0)
(547,1118,0)
(1042,445,0)
(1094,903,0)
(972,234,0)
(973,421,0)
(424,113,0)
(127,458,0)
(204,299,0)
(1140,726,0)
(156,908,0)
(969,178,0)
(749,118,0)
(828,979,0)
(101,103,0)
(615,1001,0)
(23,449,0)
(130,905,0)
(407,834,0)
(503,978,0)
(1128,643,0)
(545,334,0)
(1071,978,0)
(530,832,0)
(538,399,0)
(341,428,0)
(803,410,0)
(321,1043,0)
(170,237,0)
(1013,117,0)
(31,141,0)
(37,458,0)
(791,83,0)
(976,334,0)
(276,166,0)
(245,852,0)
(1159,863,0)
(785,584,0)
(961,1031,0)
(999,907,0)
(347,334,0)
(476,76,0)
(948,558,0)
(664,294,0)
(261,625,0)
(132,334,0)
(219,778,0)
(367,482,0)
(306,334,0)
(634,323,0)
(623,485,0)
(624,834,0)
(1161,83,0)
(29,635,0)
(997,500,0)
(332,789,0)
(647,736,0)
(407,815,0)
(407,841,0)
(494,990,0)
(736,218,0)
(674,614,0)
(990,912,0)
(29,671,0)
(502,1031,0)
(446,442,0)
(60,908,0)
(596,679,0)
(1162,984,0)
(428,1036,0)
(957,124,0)
(767,1103,0)
(1132,180,0)
(976,106,0)
(659,1032,0)
(371,1077,0)
(807,454,0)
(1146,246,0)
(199,203,0)
(732,540,0)
(812,557,0)
(47,697,0)
(768,809,0)
(92,908,0)
(744,229,0)
(1076,238,0)
(790,658,0)
(938,1003,0)
(331,699,0)
(86,482,0)
(46,693,0)
(723,949,0)
(1133,334,0)
(370,434,0)
(6,689,0)
(255,697,0)
(597,1142,0)
(753,334,0)
(826,879,0)
(838,675,0)
(872,316,0)
(697,330,0)
(460,1031,0)
(47,906,0)
(800,291,0)
(553,597,0)
(513,1058,0)
(356,444,0)
(862,303,0)
(955,741,0)
(617,724,0)
(947,634,0)
(324,553,0)
(485,623,0)
(1103,908,0)
(274,628,0)
(754,597,0)
(427,1118,0)
(599,1122,0)
(718,841,0)
(440,290,0)
(776,624,0)
(81,1152,0)
(93,221,0)
(291,1031,0)
(130,117,0)
(580,113,0)
(389,266,0)
(99,291,0)
(160,274,0)
(19,458,0)
(290,440,0)
(54,761,0)
(59,919,0)
(21,1031,0)
(405,1031,0)
(547,815,0)
(281,1031,0)
(1077,752,0)
(537,834,0)
(91,952,0)
(672,975,0)
(278,116,0)
(433,850,0)
(358,753,0)
(581,1139,0)
(34,448,0)
(849,835,0)
(948,336,0)
(436,996,0)
(84,213,0)
(735,85,0)
(702,510,0)
(1086,189,0)
(1054,209,0)
(679,295,0)
(926,828,0)
(259,898,0)
(519,479,0)
(83,979,0)
(408,1028,0)
(246,239,0)
(635,29,0)
(207,693,0)
(243,841,0)
(1014,610,0)
(416,507,0)
(540,557,0)
(653,116,0)
(954,534,0)
(780,571,0)
(587,485,0)
(87,86,0)
(238,1076,0)
(102,856,0)
(435,1013,0)
(794,48,0)
(841,718,0)
(243,834,0)
(972,334,0)
(592,691,0)
(363,274,0)
(1167,672,0)
(427,841,0)
(780,372,0)
(1141,909,0)
(203,334,0)
(980,1115,0)
(983,844,0)
(508,408,0)
(135,105,0)
(884,1031,0)
(445,1042,0)
(158,1098,0)
(644,718,0)
(850,1084,0)
(924,280,0)
(374,92,0)
(876,1003,0)
(832,274,0)
(290,345,0)
(402,887,0)
(293,988,0)
(970,117,0)
(1122,310,0)
(117,970,0)
(448,34,0)
(853,231,0)
(709,368,0)
(654,334,0)
(896,668,0)
(952,908,0)
(548,625,0)
(407,94,0)
(300,1028,0)
(769,58,0)
(1002,347,0)
(114,29,0)
(524,483,0)
(985,813,0)
(47,1026,0)
(469,691,0)
(72,779,0)
(336,948,0)
(1099,132,0)
(364,1031,0)
(1004,1000,0)
(297,649,0)
(184,33,0)
(945,118,0)
(101,696,0)
(474,177,0)
(205,511,0)
(1141,863,0)
(747,400,0)
(212,292,0)
(901,1101,0)
(1056,520,0)
(727,159,0)
(804,437,0)
(1096,667,0)
(1060,217,0)
(871,547,0)
(448,7,0)
(1089,805,0)
(694,237,0)
(105,1048,0)
(631,908,0)
(1053,687,0)
(624,217,0)
(320,356,0)
(232,458,0)
(865,319,0)
(124,815,0)
(1115,908,0)
(563,509,0)
(240,1050,0)
(133,1165,0)
(895,815,0)
(1082,832,0)
(453,188,0)
(873,1048,0)
(504,313,0)
(769,1109,0)
(483,200,0)
(47,1031,0)
(250,841,0)
(755,1033,0)
(725,1152,0)
(560,464,0)
(1108,988,0)
(586,334,0)
(245,85,0)
(642,517,0)
(903,265,0)
(527,971,0)
(280,557,0)
(1165,1021,0)
(1155,86,0)
(243,94,0)
(85,314,0)
(808,696,0)
(507,274,0)
(1009,671,0)
(40,647,0)
(147,817,0)
(621,1021,0)
(677,507,0)
(811,817,0)
(305,400,0)
(1065,1106,0)
(768,927,0)
(971,1005,0)
(402,334,0)
(510,890,0)
(603,345,0)
(180,334,0)
(427,833,0)
(901,978,0)
(470,216,0)
(1083,334,0)
(1171,1031,0)
(904,834,0)
(47,777,0)
(78,245,0)
(707,1075,0)
(345,979,0)
(47,437,0)
(659,884,0)
(724,654,0)
(753,1115,0)
(113,569,0)
(921,7,0)
(744,660,0)
(226,511,0)
(1129,523,0)
(810,109,0)
(835,334,0)
(774,265,0)
(94,356,0)
(920,396,0)
(537,736,0)
(172,334,0)
(759,809,0)
(174,888,0)
(666,658,0)
(177,196,0)
(846,607,0)
(47,374,0)
(29,1043,0)
(6,736,0)
(289,83,0)
(905,130,0)
(1138,1103,0)
(1039,7,0)
(333,465,0)
(626,545,0)
(325,316,0)
(5,699,0)
(707,1140,0)
(89,659,0)
(480,43,0)
(991,908,0)
(740,685,0)
(892,650,0)
(427,94,0)
(602,1033,0)
(765,467,0)
(11,47,0)
(103,101,0)
(121,859,0)
(528,1092,0)
(669,754,0)
(610,1142,0)
(235,210,0)
(165,1076,0)
(497,1031,0)
(352,1084,0)
(308,1075,0)
(966,334,0)
(264,709,0)
(654,724,0)
(716,1031,0)
(204,908,0)
(909,1030,0)
(45,987,0)
(1103,1135,0)
(529,110,0)
(429,1036,0)
(230,514,0)
(146,178,0)
(120,48,0)
(1075,707,0)
(890,908,0)
(222,1070,0)
(704,347,0)
(529,334,0)
(948,104,0)
(444,356,0)
(243,815,0)
(346,544,0)
(299,204,0)
(427,317,0)
(569,334,0)
(931,827,0)
(557,280,0)
(23,745,0)
(169,1029,0)
(272,557,0)
(792,1009,0)
(635,87,0)
(437,533,0)
(1048,569,0)
(244,678,0)
(672,856,0)
(872,325,1)
(907,968,1)
(303,862,1)
(426,537,1)
(986,288,1)
(105,135,1)
(142,961,1)
(654,499,1)
(47,348,1)
(1135,334,1)
(1037,209,1)
(547,841,1)
(464,560,1)
(933,1117,1)
(827,815,1)
(329,866,1)
(624,94,1)
(697,593,1)
(895,805,1)
(984,966,1)
(362,925,1)
(429,428,1)
(576,224,1)
(666,658,1)
(250,834,1)
(406,530,1)
(504,195,1)
(664,649,1)
(1097,883,1)
(280,924,1)
(723,100,1)
(976,334,1)
(809,759,1)
(9,971,1)
(1023,317,1)
(832,949,1)
(637,199,1)
(427,736,1)
(296,150,1)
(214,359,1)
(17,346,1)
(250,94,1)
(1149,588,1)
(427,94,1)
(428,728,1)
(718,334,1)
(794,120,1)
(776,243,1)
(6,736,1)
(560,491,1)
(313,992,1)
(11,47,1)
(1158,582,1)
(975,836,1)
(943,751,1)
(376,260,1)
(683,105,1)
(30,803,1)
(448,34,1)
(272,988,1)
(865,616,1)
(1090,1011,1)
(596,1097,1)
(544,17,1)
(511,979,1)
(330,1095,1)
(1094,309,1)
(1111,714,1)
(338,618,1)
(611,438,1)
(653,710,1)
(123,1072,1)
(340,610,1)
(407,834,1)
(650,892,1)
(887,464,1)
(819,685,1)
(895,736,1)
(402,334,1)
(1114,851,1)
(528,1092,1)
(855,1069,1)
(69,559,1)
(1069,70,1)
(85,500,1)
(624,815,1)
(720,749,1)
(149,1168,1)
(427,217,1)
(1002,1145,1)
(1133,143,1)
(1108,533,1)
(691,597,1)
(457,391,1)
(876,1003,1)
(701,958,1)
(407,94,1)
(82,546,1)
(444,741,1)
(1083,334,1)
(415,622,1)
(132,1099,1)
(999,489,1)
(950,15,1)
(744,229,1)
(145,1169,1)
(948,1018,1)
(250,736,1)
(707,1075,1)
(652,787,1)
(143,788,1)
(1084,386,1)
(1167,590,1)
(47,615,1)
(1102,825,1)
(240,946,1)
(778,219,1)
(801,773,1)
(538,399,1)
(99,815,1)
(593,255,1)
(1101,901,1)
(1003,938,1)
(506,392,1)
(490,1111,1)
(32,916,1)
(80,416,1)
(777,149,1)
(1144,221,1)
(1056,850,1)
(935,433,1)
(723,1084,1)
(250,815,1)
(646,542,1)
(552,1170,1)
(604,905,1)
(515,1101,1)
(574,828,1)
(408,508,1)
(293,652,1)
(378,505,1)
(440,1102,1)
(44,68,1)
(749,597,1)
(1029,169,1)
(528,411,1)
(308,414,1)
(347,1002,1)
(969,366,1)
(1108,303,1)
(163,785,1)
(1141,863,1)
(827,478,1)
(714,980,1)
(250,317,1)
(103,101,1)
(510,702,1)
(452,307,1)
(570,464,1)
(181,1045,1)
(85,178,1)
(1158,454,1)
(942,272,1)
(229,1033,1)
(83,979,1)
(554,604,1)
(118,1098,1)
(601,792,1)
(193,131,1)
(1038,950,1)
(47,888,1)
(1094,852,1)
(582,454,1)
(265,833,1)
(50,672,1)
(36,1129,1)
(46,334,1)
(812,942,1)
(130,117,1)
(902,1141,1)
(129,404,1)
(47,374,1)
(719,656,1)
(47,437,1)
(385,824,1)
(609,585,1)
(892,914,1)
(39,1167,1)
(64,79,1)
(641,532,1)
(35,547,1)
(844,254,1)
(118,691,1)
(382,535,1)
(234,646,1)
(876,675,1)
(55,1004,1)
(658,790,1)
(1162,305,1)
(1099,763,1)
(484,446,1)
(748,715,1)
(647,736,1)
(124,736,1)
(656,311,1)
(24,248,1)
(636,809,1)
(1103,1135,1)
(886,82,1)
(1050,240,1)
(634,323,1)
(1098,137,1)
(851,1034,1)
(725,1152,1)
(307,631,1)
(1156,524,1)
(105,1048,1)
(196,1091,1)
(1073,668,1)
(56,1105,1)
(588,764,1)
(979,360,1)
(984,789,1)
(335,705,1)
(459,501,1)
(363,1146,1)
(161,87,1)
(237,694,1)
(803,344,1)
(323,880,1)
(1004,1000,1)
(72,554,1)
(409,198,1)
(173,741,1)
(421,973,1)
(154,388,1)
(895,833,1)
(939,440,1)
(175,367,1)
(402,701,1)
(1132,531,1)
(574,841,1)
(350,124,1)
(599,233,1)
(222,949,1)
(1106,1065,1)
(915,667,1)
(1116,331,1)
(674,482,1)
(235,20,1)
(761,54,1)
(265,929,1)
(288,832,1)
(1013,555,1)
(96,953,1)
(741,955,1)
(262,1164,1)
(1155,1026,1)
(1138,196,1)
(239,698,1)
(1168,434,1)
(952,334,1)
(345,290,1)
(895,815,1)
(316,872,1)
(100,426,1)
(722,1100,1)
(1070,189,1)
(496,439,1)
(980,568,1)
(1030,637,1)
(973,845,1)
(787,1108,1)
(864,292,1)
(47,1149,1)
(540,533,1)
(124,94,1)
(343,231,1)
(159,1134,1)
(753,358,1)
(828,1008,1)
(83,791,1)
(160,274,1)
(315,875,1)
(507,586,1)
(1087,557,1)
(888,174,1)
(68,874,1)
(955,320,1)
(27,543,1)
(41,910,1)
(203,334,1)
(147,633,1)
(887,675,1)
(557,988,1)
(1141,909,1)
(162,838,1)
(367,1001,1)
(746,940,1)
(223,85,1)
(124,834,1)
(990,334,1)
(842,1003,1)
(243,736,1)
(507,1070,1)
(331,699,1)
(1,420,1)
(589,845,1)
(463,797,1)
(532,902,1)
(1048,569,1)
(644,613,1)
(1032,1120,1)
(38,904,1)
(551,624,1)
(1017,269,1)
(786,911,1)
(236,881,1)
(67,490,1)
(905,130,1)
(47,376,1)
(633,782,1)
(547,834,1)
(547,94,1)
(635,263,1)
(950,1107,1)
(553,324,1)
(849,1037,1)
(747,952,1)
(467,765,1)
(845,959,1)
(356,444,1)
(366,107,1)
(453,202,1)
(104,760,1)
(92,8,1)
(826,1058,1)
(827,94,1)
(830,961,1)
(754,1098,1)
(788,338,1)
(969,334,1)
(1067,147,1)
(972,234,1)
(858,996,1)
(146,852,1)
(131,227,1)
(427,864,1)
(124,957,1)
(624,776,1)
(543,481,1)
(342,796,1)
(373,127,1)
(265,116,1)
(934,979,1)
(456,551,1)
(250,841,1)
(295,679,1)
(47,1069,1)
(530,407,1)
(110,562,1)
(48,794,1)
(657,873,1)
(831,121,1)
(172,334,1)
(407,736,1)
(87,86,1)
(548,625,1)
(573,1081,1)
(134,167,1)
(958,475,1)
(111,266,1)
(407,574,1)
(110,529,1)
(825,1007,1)
(182,1128,1)
(805,1089,1)
(916,511,1)
(755,851,1)
(642,556,1)
(910,806,1)
(551,1121,1)
(242,798,1)
(1026,1147,1)
(1147,136,1)
(10,997,1)
(349,1059,1)
(900,696,1)
(569,334,1)
(276,514,1)
(970,1013,1)
(788,912,1)
(338,334,1)
(375,667,1)
(152,689,1)
(934,943,1)
(369,897,1)
(1140,819,1)
(604,328,1)
(101,696,1)
(893,1064,1)
(752,820,1)
(540,1092,1)
(733,44,1)
(121,612,1)
(389,270,1)
(933,995,1)
(1115,856,1)
(4,540,1)
(799,884,1)
(864,709,1)
(250,1118,1)
(494,267,1)
(564,142,1)
(1008,479,1)
(571,780,1)
(841,718,1)
(706,470,1)
(937,20,1)
(1011,119,1)
(54,371,1)
(569,1074,1)
(49,204,1)
(286,676,1)
(578,90,1)
(551,866,1)
(1059,1165,1)
(914,668,1)
(867,853,1)
(938,645,1)
(344,251,1)
(213,1047,1)
(537,815,1)
(139,369,1)
(130,1046,1)
(1103,506,1)
(1023,549,1)
(436,419,1)
(796,95,1)
(795,223,1)
(1041,1123,1)
(243,42,1)
(474,655,1)
(860,91,1)
(1076,238,1)
(1018,907,1)
(1094,184,1)
(387,56,1)
(102,748,1)
(781,1135,1)
(931,768,1)
(450,274,1)
(1150,589,1)
(1009,601,1)
(1042,445,1)
(948,336,1)
(926,703,1)
(754,669,1)
(86,482,1)
(1012,198,1)
(395,933,1)
(47,428,1)
(759,867,1)
(574,834,1)
(127,122,1)
(472,611,1)
(743,361,1)
(1080,779,1)
(1072,913,1)
(556,632,1)
(216,967,1)
(135,1048,1)
(167,488,1)
(808,799,1)
(124,841,1)
(501,856,1)
(540,732,1)
(690,335,1)
(1151,971,1)
(978,503,1)
(1082,128,1)
(32,983,1)
(700,599,1)
(1092,179,1)
(23,449,1)
(944,521,1)
(1071,507,1)
(104,310,1)
(871,1118,1)
(122,932,1)
(988,293,1)
(311,547,1)
(84,213,1)
(776,75,1)
(740,707,1)
(1027,124,1)
(705,921,1)
(350,94,1)
(727,159,1)
(776,148,1)
(685,606,1)
(513,334,1)
(1154,398,1)
(961,1113,1)
(209,1054,1)
(581,164,1)
(639,1124,1)
(904,520,1)
(29,1043,1)
(840,421,1)
(1093,450,1)
(180,1132,1)
(941,111,1)
(692,425,1)
(491,666,1)
(165,711,1)
(481,1109,1)
(325,96,1)
(233,200,1)
(6,815,1)
(204,299,1)
(235,210,1)
(762,812,1)
(1035,1049,1)
(1015,214,1)
(124,815,1)
(806,312,1)
(397,467,1)
(959,430,1)
(164,1058,1)
(1043,321,1)
(876,180,1)
(879,495,1)
(612,595,1)
(995,117,1)
(427,960,1)
(360,443,1)
(461,160,1)
(243,94,1)
(1122,700,1)
(728,341,1)
(534,334,1)
(1159,275,1)
(310,97,1)
(655,1091,1)
(258,775,1)
(1170,295,1)
(245,852,1)
(963,847,1)
(704,1119,1)
(1028,300,1)
(1089,550,1)
(23,745,1)
(797,964,1)
(1079,926,1)
(226,205,1)
(70,981,1)
(203,638,1)
(29,635,1)
(222,160,1)
(1164,624,1)
(294,1160,1)
(78,962,1)
(1083,418,1)
(60,673,1)
(151,710,1)
(587,32,1)
(290,440,1)
(495,826,1)
(351,373,1)
(128,1084,1)
(254,1040,1)
(511,226,1)
(427,116,1)
(387,334,1)
(132,334,1)
(160,1093,1)
(247,303,1)
(1129,334,1)
(427,457,1)
(539,212,1)
(377,912,1)
(392,767,1)
(537,1144,1)
(617,6,1)
(297,24,1)
(529,25,1)
(264,27,1)
(674,14,1)
(1161,365,1)
(625,261,1)
(198,407,1)
(120,313,1)
(763,363,1)
(774,1094,1)
(580,408,1)
(624,834,1)
(847,214,1)
(269,583,1)
(1014,118,1)
(46,693,1)
(533,225,1)
(640,145,1)
(292,212,1)
(756,937,1)
(984,220,1)
(409,152,1)
(227,103,1)
(6,94,1)
(1129,608,1)
(525,541,1)
(47,777,1)
(170,237,1)
(871,931,1)
(117,970,1)
(185,724,1)
(541,842,1)
(508,98,1)
(874,41,1)
(547,1118,1)
(245,721,1)
(419,334,1)
(878,427,1)
(590,545,1)
(445,387,1)
(74,1154,1)
(1065,577,1)
(195,48,1)
(850,291,1)
(109,630,1)
(631,783,1)
(610,176,1)
(947,634,1)
(504,313,1)
(245,620,1)
(978,334,1)
(136,614,1)
(603,290,1)
(1137,138,1)
(434,370,1)
(624,841,1)
(339,525,1)
(914,1140,1)
(40,996,1)
(284,887,1)
(47,641,1)
(519,1079,1)
(903,1094,1)
(493,83,1)
(972,334,1)
(324,1125,1)
(243,1118,1)
(411,994,1)
(6,689,1)
(996,419,1)
(769,58,1)
(1117,995,1)
(6,834,1)
(615,112,1)
(359,727,1)
(686,461,1)
(277,390,1)
(89,1032,1)
(993,1139,1)
(198,1082,1)
(166,514,1)
(1047,1073,1)
(407,815,1)
(832,1084,1)
(505,144,1)
(716,473,1)
(225,437,1)
(371,1077,1)
(562,529,1)
(146,620,1)
(770,1078,1)
(317,380,1)
(859,831,1)
(773,375,1)
(678,154,1)
(319,334,1)
(35,719,1)
(520,1056,1)
(1005,465,1)
(1119,151,1)
(318,941,1)
(833,347,1)
(47,1026,1)
(322,833,1)
(1060,243,1)
(946,722,1)
(202,772,1)
(180,334,1)
(669,553,1)
(967,947,1)
(659,1032,1)
(25,523,1)
(1118,972,1)
(597,754,1)
(1131,350,1)
(766,639,1)
(1125,725,1)
(8,374,1)
(250,1023,1)
(852,821,1)
(94,356,1)
(827,841,1)
(1071,1146,1)
(785,340,1)
(659,884,1)
(443,1084,1)
(974,43,1)
(643,522,1)
(404,1006,1)
(1143,487,1)
(810,1133,1)
(534,22,1)
(1058,513,1)
(1095,697,1)
(1074,641,1)
(419,636,1)
(895,1118,1)
(152,536,1)
(451,975,1)
(527,442,1)
(711,60,1)
(47,697,1)
(862,528,1)
(554,933,1)
(59,30,1)
(626,273,1)
(238,242,1)
(592,469,1)
(607,846,1)
(616,1122,1)
(718,1029,1)
(140,1090,1)
(793,208,1)
(112,441,1)
(768,809,1)
(1086,381,1)
(130,803,1)
(693,569,1)
(43,480,1)
(772,148,1)
(832,406,1)
(137,334,1)
(921,18,1)
(115,569,1)
(624,1118,1)
(243,841,1)
(927,286,1)
(618,337,1)
(241,399,1)
(141,31,1)
(648,896,1)
(619,378,1)
(332,966,1)
(815,743,1)
(1019,472,1)
(155,1076,1)
(989,132,1)
(401,985,1)
(912,990,1)
(208,310,1)
(1152,1098,1)
(85,245,1)
(523,36,1)
(1024,32,1)
(400,2,1)
(903,265,1)
(318,266,1)
(566,170,1)
(348,886,1)
(850,1084,1)
(936,1029,1)
(928,334,1)
(133,294,1)
(672,856,1)
(651,1103,1)
(114,161,1)
(960,215,1)
(489,123,1)
(91,250,1)
(274,989,1)
(570,675,1)
(731,544,1)
(95,55,1)
(661,795,1)
(719,334,1)
(698,285,1)
(894,334,1)
(388,1051,1)
(1139,581,1)
(118,69,1)
(635,87,1)
(1075,417,1)
(125,1138,1)
(128,949,1)
(1054,1148,1)
(279,1151,1)
(956,163,1)
(1107,1127,1)
(47,1139,1)
(1153,188,1)
(104,123,1)
(507,949,1)
(614,674,1)
(285,835,1)
(20,166,1)
(981,813,1)
(691,592,1)
(129,979,1)
(215,739,1)
(522,784,1)
(630,810,1)
(345,979,1)
(518,509,1)
(336,1126,1)
(524,184,1)
(407,841,1)
(1146,246,1)
(830,185,1)
(638,863,1)
(283,615,1)
(559,572,1)
(326,504,1)
(153,629,1)
(675,162,1)
(537,736,1)
(834,345,1)
(425,1087,1)
(480,115,1)
(895,834,1)
(1045,114,1)
(341,103,1)
(473,1019,1)
(779,72,1)
(289,232,1)
(326,733,1)
(47,1122,1)
(911,117,1)
(275,922,1)
(568,49,1)
(843,444,1)
(647,40,1)
(326,761,1)
(1113,334,1)
(224,827,1)
(735,965,1)
(470,216,1)
(672,545,1)
(427,833,1)
(427,378,1)
(1104,619,1)
(595,954,1)
(547,736,1)
(699,5,1)
(863,1159,1)
(613,885,1)
(219,252,1)
(531,984,1)
(890,510,1)
(791,1161,1)
(47,553,1)
(953,35,1)
(488,911,1)
(144,379,1)
(1057,930,1)
(668,648,1)
(34,316,1)
(174,830,1)
(183,745,1)
(1055,906,1)
(760,139,1)
(529,334,1)
(580,113,1)
(645,927,1)
(789,334,1)
(694,1116,1)
(348,814,1)
(875,106,1)
(1061,1018,1)
(1046,829,1)
(739,864,1)
(1109,769,1)
(306,334,1)
(1091,110,1)
(358,67,1)
(256,291,1)
(158,614,1)
(6,409,1)
(503,1071,1)
(399,310,1)
(1036,429,1)
(1025,653,1)
(710,271,1)
(190,777,1)
(1134,1062,1)
(814,886,1)
(305,400,1)
(676,1044,1)
(835,849,1)
(107,146,1)
(1048,657,1)
(305,977,1)
(624,217,1)
(945,720,1)
(184,342,1)
(396,920,1)
(1082,832,1)
(51,1015,1)
(985,604,1)
(76,564,1)
(199,203,1)
(563,650,1)
(977,400,1)
(1145,704,1)
(895,116,1)
(804,247,1)
(1016,463,1)
(829,395,1)
(14,482,1)
(523,1129,1)
(47,906,1)
(499,447,1)
(636,853,1)
(255,233,1)
(895,841,1)
(1040,916,1)
(169,129,1)
(217,894,1)
(537,841,1)
(115,944,1)
(1077,752,1)
(579,253,1)
(550,334,1)
(771,890,1)
(113,569,1)
(506,334,1)
(785,334,1)
(622,504,1)
(374,459,1)
(475,315,1)
(284,1101,1)
(1022,61,1)
(932,256,1)
(765,109,1)
(1110,80,1)
(537,834,1)
(90,716,1)
(1049,292,1)
(192,244,1)
(557,540,1)
(507,274,1)
(683,187,1)
(414,84,1)
(1052,158,1)
(827,736,1)
(549,456,1)
(919,662,1)
(854,183,1)
(1000,172,1)
(538,241,1)
(718,936,1)
(673,74,1)
(440,979,1)
(957,623,1)
(997,245,1)
(784,305,1)
(887,106,1)
(909,1030,1)
(150,1004,1)
(386,352,1)
(218,3,1)
(1160,664,1)
(108,822,1)
(418,268,1)
(736,218,1)
(624,736,1)
(1130,1028,1)
(922,651,1)
(750,677,1)
(446,1158,1)
(320,193,1)
(187,1055,1)
(218,334,1)
(483,334,1)
(632,647,1)
(427,834,1)
(106,976,1)
(372,415,1)
(709,264,1)
(577,758,1)
(273,1115,1)
(987,493,1)
(1135,125,1)
(881,377,1)
(270,1024,1)
(454,848,1)
(31,257,1)
(350,1036,1)
(798,165,1)
(896,349,1)
(838,666,1)
(479,519,1)
(455,279,1)
(252,948,1)
(928,594,1)
(850,274,1)
(545,334,1)
(65,102,1)
(380,362,1)
(1150,895,1)
(1126,839,1)
(86,1155,1)
(608,876,1)
(513,296,1)
(489,538,1)
(811,1067,1)
(116,278,1)
(1100,571,1)
(659,287,1)
(58,1035,1)
(602,755,1)
(119,476,1)
(768,576,1)
(742,59,1)
(954,534,1)
(271,518,1)
(901,978,1)
(188,453,1)
(898,259,1)
(352,291,1)
(228,635,1)
(895,457,1)
(1078,105,1)
(291,800,1)
(1128,643,1)
(449,854,1)
(818,570,1)
(712,92,1)
(390,898,1)
(1152,81,1)
(1103,884,1)
(266,389,1)
(1088,816,1)
(177,688,1)
(846,934,1)
(267,468,1)
(157,956,1)
(688,474,1)
(535,1104,1)
(430,382,1)
(547,871,1)
(780,372,1)
(488,786,1)
(924,4,1)
(345,232,1)
(239,334,1)
(178,969,1)
(243,815,1)
(764,427,1)
(895,94,1)
(384,756,1)
(941,696,1)
(260,974,1)
(399,793,1)
(253,1041,1)
(148,217,1)
(1094,620,1)
(18,766,1)
(850,949,1)
(487,712,1)
(462,895,1)
(574,647,1)
(40,736,1)
(662,889,1)
(268,396,1)
(547,815,1)
(925,549,1)
(447,617,1)
(555,435,1)
(101,1027,1)
(620,993,1)
(583,258,1)
(477,190,1)
(1148,140,1)
(439,569,1)
(889,742,1)
(732,762,1)
(511,205,1)
(293,334,1)
(427,805,1)
(6,841,1)
(2,747,1)
(211,494,1)
(1030,334,1)
(1169,1162,1)
(857,781,1)
(347,334,1)
(672,884,1)
(250,805,1)
(636,467,1)
(442,484,1)
(201,1052,1)
(437,804,1)
(221,93,1)
(606,740,1)
(46,383,1)
(1032,884,1)
(873,277,1)
(300,376,1)
(672,451,1)
(906,770,1)
(948,104,1)
(696,808,1)
(47,879,1)
(81,1098,1)
(93,869,1)
(482,928,1)
(45,987,1)
(820,891,1)
(775,1123,1)
(807,860,1)
(492,640,1)
(176,1014,1)
(57,1096,1)
(520,537,1)
(356,843,1)
(745,65,1)
(990,211,1)
(546,659,1)
(1056,723,1)
(269,579,1)
(212,870,1)
(509,563,1)
(828,979,1)
(205,351,1)
(256,1012,1)
(764,1022,1)
(859,334,1)
(210,384,1)
(403,397,1)
(172,1166,1)
(822,326,1)
(587,318,1)
(586,750,1)
(427,841,1)
(730,220,1)
(337,236,1)
(444,173,1)
(261,982,1)
(545,626,1)
(572,691,1)
(629,538,1)
(679,596,1)
(667,57,1)
(964,744,1)
(346,566,1)
(965,178,1)
(420,931,1)
(1105,330,1)
(952,1005,1)
(391,706,1)
(143,595,1)
(22,284,1)
(1007,38,1)
(949,686,1)
(365,289,1)
(983,844,1)
(435,607,1)
(982,462,1)
(827,834,1)
(693,207,1)
(231,403,1)
(813,141,1)
(196,523,1)
(1121,1106,1)
(465,333,1)
(723,274,1)
(586,334,1)
(866,805,1)
(478,690,1)
(312,250,1)
(934,751,1)
(607,235,1)
(5,903,1)
(972,525,1)
(883,811,1)
(47,1013,1)
(379,46,1)
(79,89,1)
(194,230,1)
(968,999,1)
(724,654,1)
(383,693,1)
(469,945,1)
(920,186,1)
(128,274,1)
(1130,580,1)
(1089,334,1)
(895,1038,1)
(790,515,1)
(672,975,1)
(321,228,1)
(234,334,1)
(594,175,1)
(930,1060,1)
(47,913,1)
(416,1070,1)
(246,239,1)
(29,482,1)
(319,865,1)
(557,280,1)
(907,334,1)
(1124,477,1)
(931,827,1)
(654,334,1)
(398,50,1)
(839,104,1)
(417,308,1)
(113,424,1)
(292,539,1)
(51,334,1)
(751,552,1)
(427,1118,1)
(832,274,1)
(876,464,1)
(137,201,1)
(835,334,1)
(966,730,1)
(782,45,1)
(1127,385,1)
(97,319,1)
(98,548,1)
(1005,971,1)
(1006,644,1)
(689,108,1)
(427,317,1)
(971,527,1)
(976,823,1)
(333,455,1)
(952,1158,1)
(514,194,1)
(821,879,1)
(76,923,1)
(995,803,1)
(299,1143,1)
(1051,840,1)
(718,979,1)
(485,587,1)
(703,517,1)
(895,317,1)
(318,696,1)
(709,893,1)
(356,334,1)
(322,116,1)
(105,334,1)
(500,10,1)
(185,6,1)
(171,339,1)
(884,746,1)
(1123,496,1)
(438,900,1)
(1105,778,1)
(623,485,1)
(554,801,1)
(251,855,1)
(381,222,1)
(309,322,1)
(757,1016,1)
(232,1131,1)
(550,682,1)
(1001,283,1)
(424,561,1)
(441,1042,1)
(816,915,1)
(259,1150,1)
(682,262,1)
(758,329,1)
(1166,134,1)
(166,276,1)
(677,1110,1)
(767,857,1)
(1144,963,1)
(75,1153,1)
(15,903,1)
(47,396,1)
(524,661,1)
(220,492,1)
(431,192,1)
(789,332,1)
(1044,578,1)
(42,448,1)
(913,153,1)
(43,115,1)
(306,1057,1)
(894,306,1)
(574,520,1)
(345,334,1)
(257,401,1)
(715,1149,1)
(433,723,1)
(340,725,1)
(367,692,1)
(3,858,1)
(517,642,1)
(880,731,1)
(179,1083,1)
(408,1028,1)
(897,1061,1)
(856,23,1)
(647,815,1)
(895,217,1)
(1133,334,1)
(328,905,1)
(287,64,1)
(128,986,1)
(1141,199,1)
(649,297,1)
(723,949,1)
(911,1137,1)
(1120,1114,1)
(1062,607,1)
(200,483,1)
(905,395,1)
(15,457,1)
(994,1092,1)
(189,334,1)
(995,431,1)
(992,155,1)
(476,76,1)
(702,1017,1)
(850,935,1)
(158,1009,1)
(536,757,1)
(753,334,1)
(619,46,1)
(823,818,1)
(1034,573,1)
(66,333,1)
(870,683,1)
(1029,129,1)
(658,334,1)
(561,408,1)
(1096,919,1)
(975,334,1)
(887,402,1)
(847,51,1)
(468,859,1)
(554,1088,1)
(537,94,1)
(876,531,1)
(244,678,1)
(585,264,1)
(1115,753,1)
(427,815,1)
(1081,157,1)
(1165,133,1)
(828,479,1)
(61,878,1)
(248,1080,1)
(465,66,1)
(250,217,1)
(243,834,1)
(853,231,1)
(836,39,1)
(207,1130,1)
(783,771,1)
(940,979,1)
(186,1042,1)
(869,963,1)
(189,1086,1)
(278,1025,1)
(1162,182,1)
(1115,490,1)
(47,796,1)
(303,528,1)
(966,334,1)
(483,1156,1)
(1064,609,1)
(370,348,1)
(138,117,1)
(800,99,1)
(996,436,1)
(1138,876,1)
(1140,707,1)
(792,29,1)
(768,927,1)
(811,334,1)
(521,580,1)
(721,78,1)
(668,896,1)
(290,939,1)
(345,603,1)
(1033,602,1)
(1005,9,1)
(891,1050,1)
(962,735,1)
(848,807,1)
(196,177,1)
(263,181,1)
(853,343,1)
(1090,476,1)
(885,703,1)
(929,774,1)
(542,1,1)
(230,846,1)
(128,291,1)
(824,452,1)
(1113,171,1)
(929,1094,2)
(348,851,2)
(1147,614,2)
(609,292,2)
(345,290,2)
(1101,901,2)
(424,408,2)
(830,961,2)
(399,310,2)
(315,1101,2)
(1079,703,2)
(1070,189,2)
(509,563,2)
(620,1058,2)
(860,250,2)
(1034,607,2)
(192,845,2)
(1080,779,2)
(843,103,2)
(819,668,2)
(1105,607,2)
(96,851,2)
(523,1129,2)
(647,815,2)
(1076,238,2)
(1089,550,2)
(1056,537,2)
(546,851,2)
(155,250,2)
(895,845,2)
(699,903,2)
(1103,1135,2)
(782,198,2)
(550,334,2)
(952,1005,2)
(1051,845,2)
(890,510,2)
(549,851,2)
(31,604,2)
(903,845,2)
(709,292,2)
(856,23,2)
(101,696,2)
(195,313,2)
(566,903,2)
(177,876,2)
(510,702,2)
(363,1146,2)
(203,334,2)
(930,243,2)
(755,851,2)
(905,933,2)
(6,689,2)
(969,1004,2)
(113,569,2)
(406,407,2)
(1036,103,2)
(175,607,2)
(1129,334,2)
(15,845,2)
(1005,250,2)
(521,580,2)
(129,703,2)
(204,299,2)
(652,1042,2)
(896,845,2)
(245,620,2)
(24,845,2)
(261,895,2)
(47,374,2)
(234,931,2)
(954,534,2)
(798,250,2)
(651,250,2)
(1092,1042,2)
(1103,884,2)
(507,1070,2)
(942,1042,2)
(540,533,2)
(934,751,2)
(226,198,2)
(47,376,2)
(8,250,2)
(916,198,2)
(905,395,2)
(588,250,2)
(338,595,2)
(199,250,2)
(86,482,2)
(1155,614,2)
(795,1004,2)
(1077,752,2)
(376,580,2)
(1033,851,2)
(845,895,2)
(821,1058,2)
(894,306,2)
(1062,607,2)
(972,234,2)
(563,845,2)
(265,1094,2)
(240,946,2)
(1006,703,2)
(135,250,2)
(828,979,2)
(305,250,2)
(545,334,2)
(79,851,2)
(217,243,2)
(148,243,2)
(193,103,2)
(616,233,2)
(933,845,2)
(108,851,2)
(256,198,2)
(1103,506,2)
(1108,1042,2)
(128,274,2)
(779,845,2)
(274,1146,2)
(305,400,2)
(144,46,2)
(1000,172,2)
(876,464,2)
(535,895,2)
(757,851,2)
(317,549,2)
(41,910,2)
(741,103,2)
(981,604,2)
(427,116,2)
(519,703,2)
(990,595,2)
(132,1146,2)
(279,971,2)
(322,845,2)
(543,292,2)
(524,607,2)
(312,250,2)
(1115,856,2)
(607,198,2)
(996,419,2)
(391,903,2)
(971,527,2)
(248,1080,2)
(1078,105,2)
(427,736,2)
(307,250,2)
(407,834,2)
(6,834,2)
(537,841,2)
(895,457,2)
(825,520,2)
(402,334,2)
(1041,1123,2)
(397,467,2)
(631,250,2)
(657,250,2)
(1030,250,2)
(243,1118,2)
(1146,246,2)
(637,250,2)
(850,723,2)
(686,160,2)
(292,212,2)
(17,903,2)
(335,851,2)
(865,233,2)
(691,597,2)
(702,250,2)
(233,607,2)
(522,305,2)
(688,876,2)
(105,250,2)
(233,200,2)
(1016,851,2)
(966,334,2)
(399,233,2)
(1140,707,2)
(237,903,2)
(1008,703,2)
(559,725,2)
(1043,614,2)
(1149,250,2)
(160,1146,2)
(568,250,2)
(190,851,2)
(166,514,2)
(787,1042,2)
(624,834,2)
(1154,250,2)
(772,148,2)
(732,1042,2)
(690,851,2)
(961,1113,2)
(1152,607,2)
(607,235,2)
(254,916,2)
(674,482,2)
(776,851,2)
(1045,614,2)
(1018,233,2)
(752,504,2)
(178,969,2)
(1118,931,2)
(1023,851,2)
(167,607,2)
(111,32,2)
(297,845,2)
(1048,569,2)
(873,250,2)
(1098,137,2)
(950,845,2)
(838,666,2)
(133,845,2)
(520,1056,2)
(324,725,2)
(594,607,2)
(427,217,2)
(509,845,2)
(995,803,2)
(265,116,2)
(382,895,2)
(765,109,2)
(121,595,2)
(1046,933,2)
(506,334,2)
(385,250,2)
(365,198,2)
(703,647,2)
(97,319,2)
(194,846,2)
(1091,110,2)
(953,851,2)
(1116,903,2)
(709,893,2)
(248,845,2)
(1135,334,2)
(103,124,2)
(100,537,2)
(1005,465,2)
(46,334,2)
(727,159,2)
(985,604,2)
(445,387,2)
(180,531,2)
(1141,199,2)
(419,334,2)
(517,642,2)
(518,845,2)
(1092,179,2)
(162,666,2)
(700,233,2)
(47,641,2)
(1093,1146,2)
(430,895,2)
(1099,1146,2)
(47,428,2)
(818,1101,2)
(447,6,2)
(850,274,2)
(759,853,2)
(1025,710,2)
(850,949,2)
(788,595,2)
(124,815,2)
(870,250,2)
(403,467,2)
(483,607,2)
(400,250,2)
(488,911,2)
(208,233,2)
(1059,845,2)
(562,876,2)
(456,851,2)
(1076,250,2)
(895,217,2)
(659,287,2)
(551,851,2)
(32,198,2)
(926,703,2)
(788,338,2)
(624,815,2)
(492,250,2)
(47,1026,2)
(813,604,2)
(450,1146,2)
(468,595,2)
(677,1146,2)
(1042,445,2)
(159,607,2)
(736,996,2)
(595,954,2)
(313,250,2)
(1145,710,2)
(975,334,2)
(184,1004,2)
(1141,250,2)
(706,903,2)
(454,250,2)
(1097,198,2)
(931,768,2)
(1166,607,2)
(6,815,2)
(816,667,2)
(789,250,2)
(250,834,2)
(501,250,2)
(188,148,2)
(179,1083,2)
(827,815,2)
(224,827,2)
(123,538,2)
(839,233,2)
(269,250,2)
(895,94,2)
(990,334,2)
(390,898,2)
(34,316,2)
(245,852,2)
(993,1058,2)
(724,6,2)
(4,1042,2)
(1038,845,2)
(539,250,2)
(488,607,2)
(914,845,2)
(295,679,2)
(259,250,2)
(1094,845,2)
(813,141,2)
(964,851,2)
(1106,1065,2)
(672,545,2)
(1137,607,2)
(504,195,2)
(972,931,2)
(1088,667,2)
(901,978,2)
(216,903,2)
(461,160,2)
(118,725,2)
(931,851,2)
(1111,250,2)
(306,334,2)
(557,280,2)
(231,467,2)
(407,841,2)
(963,607,2)
(744,229,2)
(1090,476,2)
(982,895,2)
(78,1004,2)
(766,851,2)
(751,198,2)
(396,1042,2)
(1153,148,2)
(540,1042,2)
(705,851,2)
(668,845,2)
(674,607,2)
(1094,852,2)
(858,996,2)
(992,250,2)
(1158,454,2)
(1064,292,2)
(948,1018,2)
(1139,1058,2)
(212,250,2)
(968,233,2)
(983,844,2)
(1013,607,2)
(293,334,2)
(87,614,2)
(318,941,2)
(1130,895,2)
(625,895,2)
(537,736,2)
(773,667,2)
(483,334,2)
(1032,851,2)
(898,250,2)
(164,1058,2)
(619,895,2)
(1014,725,2)
(682,624,2)
(957,198,2)
(1,931,2)
(29,635,2)
(967,903,2)
(435,607,2)
(210,20,2)
(649,845,2)
(157,607,2)
(851,1034,2)
(907,334,2)
(427,960,2)
(969,334,2)
(243,736,2)
(398,250,2)
(934,198,2)
(1026,614,2)
(1164,624,2)
(229,1033,2)
(478,851,2)
(81,607,2)
(496,250,2)
(577,866,2)
(959,895,2)
(811,198,2)
(124,198,2)
(864,250,2)
(331,699,2)
(582,250,2)
(117,970,2)
(1100,504,2)
(47,553,2)
(1012,198,2)
(1153,188,2)
(950,250,2)
(60,673,2)
(32,983,2)
(1128,305,2)
(106,1101,2)
(617,6,2)
(1017,250,2)
(70,604,2)
(74,250,2)
(941,696,2)
(30,604,2)
(47,913,2)
(317,380,2)
(1050,504,2)
(151,710,2)
(1056,723,2)
(408,1028,2)
(47,879,2)
(198,407,2)
(756,20,2)
(623,198,2)
(107,1004,2)
(427,250,2)
(946,504,2)
(427,841,2)
(583,1123,2)
(84,213,2)
(345,979,2)
(6,736,2)
(253,1123,2)
(1113,334,2)
(34,851,2)
(803,344,2)
(862,1042,2)
(1094,620,2)
(871,851,2)
(470,216,2)
(895,841,2)
(179,1042,2)
(1106,866,2)
(532,250,2)
(1109,769,2)
(649,297,2)
(983,916,2)
(1081,607,2)
(102,250,2)
(718,1029,2)
(872,851,2)
(513,1004,2)
(56,607,2)
(989,132,2)
(523,876,2)
(971,250,2)
(618,595,2)
(407,815,2)
(426,537,2)
(995,845,2)
(124,94,2)
(867,853,2)
(45,987,2)
(476,76,2)
(401,604,2)
(939,520,2)
(223,1004,2)
(828,479,2)
(50,250,2)
(585,292,2)
(739,864,2)
(690,335,2)
(387,334,2)
(648,845,2)
(789,334,2)
(921,851,2)
(1119,710,2)
(537,607,2)
(928,334,2)
(507,586,2)
(878,427,2)
(381,1146,2)
(895,815,2)
(1160,845,2)
(263,614,2)
(922,250,2)
(949,160,2)
(1152,1098,2)
(701,1101,2)
(306,243,2)
(805,1089,2)
(154,845,2)
(770,105,2)
(528,1042,2)
(714,250,2)
(440,520,2)
(1121,866,2)
(723,537,2)
(3,996,2)
(277,390,2)
(1151,971,2)
(118,1098,2)
(1117,845,2)
(673,250,2)
(293,1042,2)
(49,250,2)
(718,334,2)
(857,250,2)
(624,841,2)
(247,303,2)
(555,607,2)
(566,170,2)
(463,851,2)
(571,780,2)
(258,1123,2)
(655,876,2)
(383,895,2)
(596,198,2)
(482,607,2)
(444,741,2)
(61,427,2)
(904,520,2)
(827,736,2)
(213,668,2)
(219,233,2)
(623,485,2)
(59,604,2)
(257,604,2)
(590,250,2)
(781,250,2)
(47,348,2)
(445,607,2)
(92,250,2)
(67,250,2)
(876,250,2)
(1030,334,2)
(75,1153,2)
(337,595,2)
(635,614,2)
(1015,214,2)
(250,94,2)
(948,104,2)
(832,949,2)
(915,667,2)
(342,1004,2)
(82,851,2)
(767,250,2)
(326,851,2)
(467,765,2)
(477,851,2)
(850,291,2)
(6,841,2)
(356,334,2)
(425,1042,2)
(221,963,2)
(894,334,2)
(679,198,2)
(931,827,2)
(178,1004,2)
(853,467,2)
(427,378,2)
(296,1004,2)
(793,233,2)
(718,979,2)
(64,851,2)
(780,372,2)
(569,334,2)
(407,736,2)
(484,250,2)
(250,841,2)
(642,647,2)
(769,58,2)
(538,233,2)
(710,845,2)
(753,334,2)
(1018,907,2)
(634,903,2)
(220,250,2)
(1091,876,2)
(431,845,2)
(69,725,2)
(427,833,2)
(866,624,2)
(290,440,2)
(104,310,2)
(374,250,2)
(542,931,2)
(153,538,2)
(201,607,2)
(83,979,2)
(667,604,2)
(204,250,2)
(505,46,2)
(411,1042,2)
(238,250,2)
(966,250,2)
(149,851,2)
(262,624,2)
(25,876,2)
(23,745,2)
(731,903,2)
(880,903,2)
(956,607,2)
(390,250,2)
(42,851,2)
(124,834,2)
(369,233,2)
(66,971,2)
(250,805,2)
(730,250,2)
(310,233,2)
(557,988,2)
(980,250,2)
(442,250,2)
(290,520,2)
(494,595,2)
(85,1004,2)
(887,464,2)
(235,20,2)
(846,934,2)
(343,467,2)
(760,233,2)
(978,334,2)
(758,866,2)
(832,407,2)
(199,203,2)
(902,250,2)
(147,198,2)
(895,116,2)
(1094,184,2)
(170,237,2)
(392,250,2)
(198,607,2)
(181,614,2)
(389,32,2)
(976,334,2)
(1165,133,2)
(840,845,2)
(29,614,2)
(196,876,2)
(115,580,2)
(932,198,2)
(1082,832,2)
(371,504,2)
(20,846,2)
(448,34,2)
(586,334,2)
(553,725,2)
(1098,607,2)
(875,1101,2)
(1140,668,2)
(333,455,2)
(840,421,2)
(93,963,2)
(576,827,2)
(218,334,2)
(222,1146,2)
(685,668,2)
(172,334,2)
(318,266,2)
(987,198,2)
(180,334,2)
(395,933,2)
(887,1101,2)
(724,654,2)
(68,250,2)
(299,250,2)
(196,523,2)
(418,1042,2)
(245,1004,2)
(1067,198,2)
(329,866,2)
(1115,490,2)
(462,895,2)
(211,595,2)
(972,334,2)
(95,1004,2)
(997,1004,2)
(229,851,2)
(152,607,2)
(20,166,2)
(1029,129,2)
(1170,198,2)
(777,851,2)
(548,625,2)
(692,1042,2)
(161,614,2)
(1123,250,2)
(404,703,2)
(378,505,2)
(995,117,2)
(547,1118,2)
(440,979,2)
(909,1030,2)
(1169,250,2)
(895,805,2)
(1009,614,2)
(482,928,2)
(94,356,2)
(948,336,2)
(1058,1004,2)
(264,292,2)
(504,313,2)
(527,442,2)
(83,198,2)
(103,101,2)
(138,607,2)
(428,103,2)
(421,845,2)
(116,278,2)
(250,217,2)
(683,250,2)
(984,789,2)
(747,250,2)
(38,520,2)
(912,595,2)
(592,725,2)
(427,457,2)
(944,580,2)
(480,580,2)
(429,103,2)
(656,547,2)
(707,1075,2)
(203,250,2)
(529,334,2)
(909,250,2)
(1069,604,2)
(924,1042,2)
(35,851,2)
(5,903,2)
(243,834,2)
(1158,250,2)
(672,975,2)
(1167,250,2)
(417,668,2)
(693,895,2)
(723,274,2)
(937,20,2)
(1060,243,2)
(712,250,2)
(128,291,2)
(841,718,2)
(527,250,2)
(833,347,2)
(91,250,2)
(537,94,2)
(407,607,2)
(319,233,2)
(130,117,2)
(912,990,2)
(427,317,2)
(377,595,2)
(183,250,2)
(1131,198,2)
(662,604,2)
(545,250,2)
(380,549,2)
(387,607,2)
(691,725,2)
(47,1069,2)
(805,624,2)
(1077,504,2)
(172,607,2)
(493,198,2)
(903,1094,2)
(96,953,2)
(723,949,2)
(44,250,2)
(278,710,2)
(593,233,2)
(1029,703,2)
(344,604,2)
(1056,850,2)
(388,845,2)
(85,245,2)
(244,845,2)
(1141,909,2)
(761,504,2)
(350,198,2)
(547,736,2)
(658,1101,2)
(214,607,2)
(105,1048,2)
(581,1058,2)
(1120,851,2)
(824,250,2)
(251,604,2)
(289,198,2)
(1004,607,2)
(348,886,2)
(270,32,2)
(1080,845,2)
(490,250,2)
(1134,607,2)
(841,703,2)
(276,846,2)
(653,710,2)
(277,250,2)
(23,250,2)
(1004,1000,2)
(952,334,2)
(243,851,2)
(487,250,2)
(332,250,2)
(36,876,2)
(881,595,2)
(893,1064,2)
(550,624,2)
(511,205,2)
(310,97,2)
(892,845,2)
(634,323,2)
(829,933,2)
(876,1003,2)
(876,675,2)
(854,250,2)
(974,580,2)
(1126,233,2)
(557,540,2)
(104,123,2)
(124,736,2)
(895,834,2)
(631,783,2)
(160,274,2)
(574,607,2)
(427,1118,2)
(809,853,2)
(130,803,2)
(537,834,2)
(958,1101,2)
(819,685,2)
(29,1043,2)
(280,1042,2)
(694,903,2)
(925,549,2)
(485,198,2)
(444,103,2)
(511,198,2)
(10,1004,2)
(299,1143,2)
(833,710,2)
(889,604,2)
(122,198,2)
(308,668,2)
(972,525,2)
(754,1098,2)
(1082,128,2)
(252,233,2)
(200,607,2)
(1102,520,2)
(414,668,2)
(230,846,2)
(650,845,2)
(47,697,2)
(547,94,2)
(1050,240,2)
(768,927,2)
(1047,668,2)
(920,1042,2)
(764,250,2)
(1125,725,2)
(18,766,2)
(420,931,2)
(303,528,2)
(859,334,2)
(1032,884,2)
(740,668,2)
(994,1042,2)
(820,504,2)
(51,214,2)
(145,250,2)
(719,547,2)
(921,18,2)
(139,233,2)
(745,250,2)
(856,250,2)
(166,846,2)
(863,250,2)
(200,483,2)
(533,303,2)
(689,108,2)
(479,703,2)
(544,903,2)
(1089,334,2)
(1122,233,2)
(547,841,2)
(1168,851,2)
(427,805,2)
(823,1101,2)
(47,1013,2)
(283,1042,2)
(1150,250,2)
(807,250,2)
(905,130,2)
(235,846,2)
(720,725,2)
(260,580,2)
(879,1058,2)
(128,949,2)
(1118,972,2)
(272,1042,2)
(167,488,2)
(1035,292,2)
(1022,427,2)
(292,250,2)
(689,851,2)
(402,1101,2)
(836,250,2)
(351,198,2)
(228,614,2)
(452,250,2)
(928,607,2)
(128,1084,2)
(703,517,2)
(241,233,2)
(47,1139,2)
(988,1042,2)
(359,727,2)
(554,845,2)
(318,696,2)
(333,971,2)
(110,529,2)
(196,1091,2)
(587,198,2)
(579,1123,2)
(907,233,2)
(552,198,2)
(847,607,2)
(547,815,2)
(182,305,2)
(814,851,2)
(725,607,2)
(1073,668,2)
(345,334,2)
(973,845,2)
(507,1146,2)
(85,178,2)
(622,504,2)
(1114,851,2)
(125,250,2)
(321,614,2)
(885,703,2)
(1048,250,2)
(693,569,2)
(853,231,2)
(984,220,2)
(414,84,2)
(1104,895,2)
(834,345,2)
(89,851,2)
(733,250,2)
(173,103,2)
(117,607,2)
(268,1042,2)
(356,103,2)
(137,334,2)
(783,250,2)
(771,250,2)
(1058,513,2)
(569,250,2)
(130,933,2)
(869,963,2)
(528,1092,2)
(1065,866,2)
(632,647,2)
(548,895,2)
(913,538,2)
(719,334,2)
(116,710,2)
(234,334,2)
(668,896,2)
(669,725,2)
(309,845,2)
(11,47,2)
(827,851,2)
(459,250,2)
(919,662,2)
(547,851,2)
(1083,1042,2)
(580,113,2)
(189,1146,2)
(114,614,2)
(945,725,2)
(1000,607,2)
(811,334,2)
(597,754,2)
(345,232,2)
(513,334,2)
(666,1101,2)
(295,198,2)
(610,725,2)
(646,931,2)
(489,233,2)
(1143,250,2)
(606,668,2)
(55,1004,2)
(274,989,2)
(9,971,2)
(612,595,2)
(347,710,2)
(715,250,2)
(1038,250,2)
(330,233,2)
(39,250,2)
(250,851,2)
(832,1084,2)
(356,444,2)
(1162,250,2)
(437,303,2)
(887,675,2)
(615,1042,2)
(561,408,2)
(530,407,2)
(1159,250,2)
(45,198,2)
(72,845,2)
(859,595,2)
(470,903,2)
(97,233,2)
(48,313,2)
(749,725,2)
(947,903,2)
(762,1042,2)
(384,20,2)
(589,845,2)
(43,115,2)
(895,1118,2)
(32,916,2)
(1055,105,2)
(852,1058,2)
(531,250,2)
(366,1004,2)
(1144,607,2)
(796,1004,2)
(267,595,2)
(641,250,2)
(101,124,2)
(1089,624,2)
(803,604,2)
(560,666,2)
(1107,1127,2)
(897,233,2)
(511,979,2)
(784,305,2)
(742,604,2)
(288,832,2)
(916,511,2)
(1049,292,2)
(707,668,2)
(1115,250,2)
(786,607,2)
(563,650,2)
(1096,604,2)
(427,815,2)
(345,520,2)
(604,905,2)
(120,313,2)
(165,250,2)
(906,105,2)
(23,449,2)
(891,504,2)
(625,261,2)
(728,103,2)
(1086,1146,2)
(895,250,2)
(439,250,2)
(60,250,2)
(835,334,2)
(571,504,2)
(195,48,2)
(127,198,2)
(221,93,2)
(373,198,2)
(1005,971,2)
(1075,668,2)
(346,903,2)
(273,250,2)
(794,313,2)
(1138,250,2)
(855,604,2)
(18,851,2)
(129,979,2)
(1107,250,2)
(202,148,2)
(1128,643,2)
(131,103,2)
(952,250,2)
(416,1146,2)
(1141,863,2)
(1161,198,2)
(774,1094,2)
(331,903,2)
(989,1146,2)
(748,250,2)
(679,596,2)
(367,607,2)
(1095,233,2)
(118,69,2)
(801,667,2)
(797,851,2)
(999,233,2)
(602,851,2)
(1052,607,2)
(572,725,2)
(1132,531,2)
(124,841,2)
(828,703,2)
(874,250,2)
(372,504,2)
(848,250,2)
(47,796,2)
(822,851,2)
(893,292,2)
(984,966,2)
(176,725,2)
(47,396,2)
(382,535,2)
(1070,1146,2)
(449,250,2)
(515,1101,2)
(256,291,2)
(57,604,2)
(242,250,2)
(547,834,2)
(785,334,2)
(6,94,2)
(186,1042,2)
(624,1118,2)
(430,382,2)
(65,250,2)
(294,845,2)
(104,233,2)
(47,1122,2)
(198,1082,2)
(1083,334,2)
(744,851,2)
(722,504,2)
(323,903,2)
(975,250,2)
(750,1146,2)
(678,845,2)
(218,996,2)
(709,264,2)
(275,250,2)
(883,198,2)
(763,1146,2)
(319,334,2)
(664,845,2)
(43,580,2)
(844,916,2)
(911,607,2)
(239,334,2)
(640,250,2)
(941,32,2)
(1028,580,2)
(675,666,2)
(624,736,2)
(1135,250,2)
(1082,407,2)
(75,148,2)
(607,846,2)
(407,94,2)
(586,1146,2)
(51,334,2)
(465,333,2)
(255,233,2)
(886,851,2)
(935,723,2)
(1072,538,2)
(613,703,2)
(207,895,2)
(556,647,2)
(988,293,2)
(672,856,2)
(1110,1146,2)
(658,334,2)
(850,1084,2)
(661,1004,2)
(243,94,2)
(246,239,2)
(887,402,2)
(250,1118,2)
(362,549,2)
(570,1101,2)
(723,1084,2)
(736,218,2)
(608,876,2)
(98,895,2)
(169,703,2)
(639,851,2)
(827,834,2)
(170,903,2)
(654,6,2)
(370,851,2)
(580,408,2)
(718,703,2)
(158,607,2)
(1057,243,2)
(903,265,2)
(629,538,2)
(936,703,2)
(638,250,2)
(846,198,2)
(557,1042,2)
(196,177,2)
(189,334,2)
(118,691,2)
(934,979,2)
(874,41,2)
(182,1128,2)
(1156,607,2)
(1121,1106,2)
(666,658,2)
(659,851,2)
(408,895,2)
(887,106,2)
(232,198,2)
(614,607,2)
(427,94,2)
(110,876,2)
(379,46,2)
(47,906,2)
(910,250,2)
(890,250,2)
(633,198,2)
(1109,292,2)
(446,250,2)
(510,250,2)
(977,250,2)
(540,1092,2)
(434,851,2)
(85,500,2)
(303,1042,2)
(775,1123,2)
(537,815,2)
(266,32,2)
(457,903,2)
(1124,851,2)
(318,32,2)
(1103,250,2)
(141,604,2)
(735,1004,2)
(287,851,2)
(371,1077,2)
(534,334,2)
(316,851,2)
(47,777,2)
(1087,1042,2)
(827,841,2)
(113,408,2)
(1027,124,2)
(451,250,2)
(132,334,2)
(349,845,2)
(678,154,2)
(80,1146,2)
(84,668,2)
(520,537,2)
(507,949,2)
(163,607,2)
(895,736,2)
(453,148,2)
(500,1004,2)
(264,27,2)
(827,94,2)
(792,614,2)
(136,614,2)
(780,504,2)
(965,1004,2)
(1165,845,2)
(919,604,2)
(1040,916,2)
(54,504,2)
(29,482,2)
(250,815,2)
(271,845,2)
(659,884,2)
(265,833,2)
(947,634,2)
(788,912,2)
(754,725,2)
(1002,710,2)
(225,303,2)
(538,399,2)
(507,274,2)
(76,923,2)
(340,607,2)
(659,1032,2)
(433,723,2)
(133,294,2)
(227,103,2)
(604,933,2)
(791,198,2)
(1007,520,2)
(495,1058,2)
(336,233,2)
(962,1004,2)
(895,317,2)
(137,607,2)
(790,1101,2)
(895,833,2)
(86,614,2)
(311,547,2)
(150,1004,2)
(468,859,2)
(338,334,2)
(876,180,2)
(624,851,2)
(474,876,2)
(753,250,2)
(504,250,2)
(672,884,2)
(826,1058,2)
(672,250,2)
(635,87,2)
(614,674,2)
(465,971,2)
(520,607,2)
(644,703,2)
(601,614,2)
(481,292,2)
(378,46,2)
(1140,819,2)
(47,437,2)
(943,198,2)
(834,520,2)
(725,1152,2)
(933,995,2)
(812,1042,2)
(243,815,2)
(105,334,2)
(464,666,2)
(217,894,2)
(41,250,2)
(106,976,2)
(205,198,2)
(14,607,2)
(970,607,2)
(499,6,2)
(1024,32,2)
(711,250,2)
(955,103,2)
(599,233,2)
(441,1042,2)
(58,292,2)
(448,851,2)
(320,103,2)
(215,864,2)
(654,334,2)
(976,1101,2)
(517,647,2)
(1042,607,2)
(785,607,2)
(573,607,2)
(341,103,2)
(250,736,2)
(455,971,2)
(134,607,2)
(643,305,2)
(768,809,2)
(778,233,2)
(210,384,2)
(626,250,2)
(721,1004,2)
(960,864,2)
(806,250,2)
(804,303,2)
(146,1004,2)
(948,233,2)
(1115,753,2)
(984,250,2)
(624,94,2)
(727,607,2)
(87,86,2)
(894,243,2)
(243,841,2)
(952,1158,2)
(94,103,2)
(1129,876,2)
(347,334,2)
(2,250,2)
(46,693,2)
(236,595,2)
(536,851,2)
(1061,233,2)
(986,832,2)
(1074,250,2)
(187,105,2)
(1037,209,2)
(427,834,2)
(832,274,2)
(375,667,2)
(358,250,2)
(115,569,2)
(415,504,2)
(47,615,2)
(491,666,2)
(697,233,2)
(603,520,2)
(580,895,2)
(240,504,2)
(1127,250,2)
(475,1101,2)
(359,607,2)
(469,725,2)
(127,122,2)
(704,710,2)
(647,736,2)
(112,1042,2)
(128,832,2)
(244,678,2)
(47,1149,2)
(624,217,2)
(235,210,2)
(27,292,2)
(514,846,2)
(508,895,2)
(1001,1042,2)
(769,292,2)
(325,851,2)
(46,895,2)
(1133,334,2)
(529,876,2)
(768,827,2)
(851,607,2)
(597,725,2)
(328,933,2)
(831,595,2)
(911,117,2)
(506,250,2)
(250,317,2)
(300,580,2)
-----------------------------------
(0,agent_goodbye)
(1,chan)
(2,loginstart)
(3,chan)
(4,p)
(5,agents)
(6,!res)
(7,)
(8,0)
(9,0)
(10,agent)
(11,RET)
(12,)
(13,if (res)
(14,tmpoptions)
(15,sched_yield()
(16,tmpoptions)
(17,0)
(18,&p->lock)
(19,)
(20,!strcmp(p->password, pass)
(21,u)
(22,"AGENTGOODBYE")
(23,time(NULL)
(24,agents)
(25,chan)
(26,)
(27,p->app_complete_cond)
(28,if (p->chan != chan)
(29,ast_verb(3, "Saw variable AGENTACCEPTDTMF=%s, setting acceptdtmf to: %c for Agent \'%s\'.\\n", tmpoptions, p->acceptdtmf, p->agent)
(30,AST_DEVICE_NOT_INUSE)
(31,agent)
(32,!strcmp(p->agent, user)
(33,)
(34,&p->lock)
(35,agents)
(36,channel)
(37,if (!res)
(38,chan)
(39,"%s|%ld")
(40,res)
(41,&p->lock)
(42,res)
(43,ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT)
(44,NULL)
(45,AST_LIST_LOCK(&agents)
(46,p->chan != chan)
(47,return -1;)
(48,p->owner)
(49,EVENT_FLAG_AGENT)
(50,2)
(51,ast_channel_unlock(chan)
(52,if (p->autologoff < 0)
(53,if (!ast_strlen_zero(tmpoptions)
(54,p)
(55,p)
(56,"AGENTWRAPUPTIME")
(57,ackcall)
(58,p->login_wait_cond)
(59,"Agent/%s")
(60,ast_verb(2, "Agent \'%s\' logged out\\n", p->agent)
(61,"Huh?  We broke out when there was still an owner?\\n")
(62,if (res && p->owner)
(63,if (p->deferlogoff && p->chan)
(64,agent)
(65,NULL)
(66,1)
(67,logintime)
(68,p)
(69,p->agent)
(70,lastdisc)
(71,update_cdr)
(72,lock)
(73,if (p->ackcall)
(74,agent)
(75,ast_log(LOG_WARNING, "Unable to set read format to %s\\n", ast_getformatname(&tmpfmt)
(76,ast_strdupa(data)
(77,if (!p->chan)
(78,p)
(79,p)
(80,"Saw variable AGENTMAXLOGINTRIES=%s, setting max_login_tries to: %d on Channel \'%s\'.\\n")
(81,tmpoptions)
(82,logincallerid)
(83,ast_log(LOG_NOTICE, "user: %s, pass: %s\\n", user, pass)
(84,&p->login_wait_cond)
(85,ast_verb(3, "Saw variable AGENTACKCALL=%s, setting ackcall to: %d for Agent \'%s\'.\\n", tmpoptions, p->ackcall, p->agent)
(86,*tmpoptions)
(87,p->acceptdtmf = *tmpoptions)
(88,if (unlock_channel)
(89,"Agent/%s")
(90,tmpoptions)
(91,chan)
(92,p->loginstart = 0)
(93,&agents)
(94,res = ast_app_getdata(chan, "agent-pass", pass, sizeof(pass)
(95,ackcall)
(96,AST_LIST_LOCK(&agents)
(97,atoi(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF")
(98,p)
(99,tries)
(100,0)
(101,ast_strlen_zero(xpass)
(102,logintime)
(103,!ast_strlen_zero(xpass)
(104,p->autologoff)
(105,p->chan == chan)
(106,tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR")
(107,chan)
(108,-1)
(109,args.options)
(110,ast_channel_cdr(chan)
(111,xpass)
(112,wrapuptime)
(113,p->chan)
(114,"Saw variable AGENTACCEPTDTMF=%s, setting acceptdtmf to: %c for Agent \'%s\'.\\n")
(115,p->chan)
(116,res = agent_ack_sleep(p)
(117,p->lastdisc = ast_tvnow()
(118,ast_verb(3, "Saw variable AGENTENDDTMF=%s, setting enddtmf to: %c for Agent \'%s\'.\\n", tmpoptions, p->enddtmf, p->agent)
(119,args)
(120,p)
(121,chan)
(122,&agents)
(123,p->autologoff = 0)
(124,!res)
(125,chan)
(126,)
(127,AST_LIST_LOCK(&agents)
(128,tries < max_login_tries)
(129,sizeof(user)
(130,p->lastdisc)
(131,chan)
(132,pbx_builtin_getvar_helper(chan, "AGENTMAXLOGINTRIES")
(133,&p->lock)
(134,chan)
(135,chan)
(136,p)
(137,pbx_builtin_getvar_helper(chan, "AGENTENDDTMF")
(138,p)
(139,p)
(140,agent_goodbye)
(141,p->agent)
(142,parse)
(143,chan)
(144,1)
(145,"Agent: %s\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t      "Channel: %s\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t      "Uniqueid: %s\\r\\n")
(146,tmpoptions)
(147,unlock_channel = 1)
(148,res)
(149,acknowledged)
(150,chan)
(151,res)
(152,break;)
(153,autologoff)
(154,p->lock)
(155,p)
(156,if (update_cdr && ast_channel_cdr(chan)
(157,unlock_channel = 0)
(158,tmpoptions)
(159,p->lock)
(160,max_login_tries < 0)
(161,3)
(162,0)
(163,unlock_channel)
(164,p)
(165,"Agent/%s")
(166,strcmp(p->password, pass)
(167,p->lastdisc.tv_sec++)
(168,if (!res)
(169,1)
(170,&p->lock)
(171,chan)
(172,pbx_builtin_getvar_helper(chan, "AGENTACKCALL")
(173,1)
(174,1)
(175,chan)
(176,AGENT_FLAG_ENDDTMF)
(177,p->agent)
(178,tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTACKCALL")
(179,atoi(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME")
(180,ast_channel_cdr(chan)
(181,p)
(182,time(&p->loginstart)
(183,p)
(184,p->ackcall = ackcall)
(185,u)
(186,p)
(187,p->chan = NULL)
(188,&tmpfmt)
(189,pbx_builtin_getvar_helper(chan, "AGENTMAXLOGINTRIES")
(190,0)
(191,if (p->chan == chan)
(192,p)
(193,"agent-pass")
(194,password)
(195,!p->owner)
(196,snprintf(ast_channel_cdr(chan)
(197,if (p->dead && !p->owner)
(198,!res && (max_login_tries==0 || tries < max_login_tries)
(199,ast_getformatname(ast_channel_readformat(chan)
(200,ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF")
(201,"AGENTENDDTMF")
(202,"Unable to set read format to %s\\n")
(203,ast_channel_readformat(chan)
(204,ast_mutex_unlock(&p->lock)
(205,p->agent)
(206,)
(207,chan)
(208,p)
(209,sizeof(agent_goodbye)
(210,!p->pending)
(211,"AGENTGOODBYE")
(212,p->app_lock_flag)
(213,p->login_wait_cond)
(214,unlock_channel)
(215,owner)
(216,&agents)
(217,res = ast_set_read_format_from_cap(chan, ast_channel_nativeformats(chan)
(218,ast_answer(chan)
(219,AGENT_FLAG_AUTOLOGOFF)
(220,p->agent)
(221,AST_LIST_UNLOCK(&agents)
(222,tmpoptions)
(223,p)
(224,play_announcement)
(225,0)
(226,user)
(227,res)
(228,p)
(229,&p->lock)
(230,p)
(231,args.options)
(232,errmsg = "agent-incorrect")
(233,!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF")
(234,ast_channel_language(chan)
(235,!strcmp(p->password, pass)
(236,tmpoptions)
(237,p->lock)
(238,p->agent)
(239,pbx_builtin_getvar_helper(chan, "AGENTLMAXLOGINTRIES")
(240,&p->app_complete_cond)
(241,0)
(242,agent)
(243,!res)
(244,ast_mutex_lock(&p->lock)
(245,p->ackcall)
(246,ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTLMAXLOGINTRIES")
(247,p)
(248,ast_mutex_unlock(&p->lock)
(249,)
(250,!res)
(251,0)
(252,p)
(253,0)
(254,pending)
(255,p)
(256,tries++)
(257,p)
(258,0)
(259,lock)
(260,deferlogoff)
(261,p->lock)
(262,chan)
(263,acceptdtmf)
(264,&p->app_complete_cond)
(265,res == 1)
(266,p->password)
(267,tmpoptions)
(268,chan)
(269,p)
(270,p)
(271,ackcall)
(272,3)
(273,"NONE")
(274,max_login_tries = atoi(pbx_builtin_getvar_helper(chan, "AGENTMAXLOGINTRIES")
(275,p)
(276,pass)
(277,ast_mutex_lock(&p->lock)
(278,agent_ack_sleep(p)
(279,moh)
(280,p->agent)
(281,while (!res && (max_login_tries==0 || tries < max_login_tries)
(282,)
(283,wrapuptime)
(284,chan)
(285,chan)
(286,1)
(287,p->agent)
(288,tries)
(289,LOG_NOTICE)
(290,sizeof(user)
(291,tries = 0)
(292,p->app_lock_flag == 1)
(293,pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME")
(294,p->lock)
(295,ast_mutex_lock(&p->lock)
(296,"AGENTACKCALL")
(297,&agents)
(298,agent)
(299,&p->lock)
(300,0)
(301,xpass)
(302,)
(303,p->wrapuptime < 0)
(304,while (res >= 0)
(305,p->loginstart == 0)
(306,ast_channel_nativeformats(chan)
(307,AST_DEVICE_NOT_INUSE)
(308,p)
(309,ackcall)
(310,p->autologoff = atoi(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF")
(311,chan)
(312,p)
(313,p->dead)
(314,)
(315,"Saw variable AGENTUPDATECDR=%s, setting update_cdr to: %d on Channel \'%s\'.\\n")
(316,p->lock)
(317,res = -1)
(318,ast_copy_string(xpass, p->password, sizeof(xpass)
(319,pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF")
(320,pass)
(321,agent)
(322,p)
(323,p->lock)
(324,enddtmf)
(325,p)
(326,res)
(327,errmsg)
(328,0)
(329,LOG_WARNING)
(330,p->autologoff = autologoff)
(331,AST_LIST_LOCK(&agents)
(332,chan)
(333,strlen(p->moh)
(334,struct ast_channel *chan)
(335,&agents)
(336,p->agent)
(337,agent_goodbye)
(338,ast_channel_name(chan)
(339,u)
(340,chan)
(341,pass)
(342,ackcall)
(343,\'s\')
(344,ast_tv(0, 0)
(345,ast_app_getdata(chan, errmsg, user, sizeof(user)
(346,p)
(347,ast_safe_sleep_conditional( chan, 1000, agent_cont_sleep, p )
(348,p->logincallerid[0])
(349,app_lock_flag)
(350,errmsg)
(351,agent)
(352,max_login_tries)
(353,if (max_login_tries < 0)
(354,)
(355,logintime)
(356,ast_app_getdata(chan, "agent-pass", pass, sizeof(pass)
(357,)
(358,chan)
(359,ast_mutex_unlock(&p->lock)
(360,"")
(361,res)
(362,1)
(363,max_login_tries)
(364,p)
(365,"user: %s, pass: %s\\n")
(366,"AGENTACKCALL")
(367,tmpoptions)
(368,)
(369,tmpoptions)
(370,\'\\0\')
(371,ast_cond_destroy(&p->login_wait_cond)
(372,p->lock)
(373,p)
(374,p->loginstart)
(375,p)
(376,p->deferlogoff)
(377,3)
(378,res = -1)
(379,res)
(380,-1)
(381,chan)
(382,&p->lock)
(383,chan)
(384,p->pending)
(385,agent)
(386,maxlogintries)
(387,pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME")
(388,lock)
(389,password)
(390,&p->lock)
(391,0)
(392,chan)
(393,if (ast_tvdiff_ms(ast_tvnow()
(394,parse)
(395,ast_tvnow()
(396,p->wrapuptime)
(397,args)
(398,"Agent \'%s\' logged out\\n")
(399,p->autologoff)
(400,p->loginstart)
(401,"Wrapup time for %s expired!\\n")
(402,ast_channel_name(chan)
(403,options)
(404,user)
(405,if (ast_channel_state(chan)
(406,0)
(407,!res)
(408,p->deferlogoff)
(409,res)
(410,)
(411,wrapuptime)
(412,)
(413,if (!strcmp(p->agent, user)
(414,ast_cond_signal(&p->login_wait_cond)
(415,lock)
(416,3)
(417,app_complete_cond)
(418,"AGENTWRAPUPTIME")
(419,ast_channel_state(chan)
(420,res)
(421,&agents)
(422,if (ast_true(pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR")
(423,)
(424,chan)
(425,AGENT_FLAG_WRAPUPTIME)
(426,max_login_tries)
(427,res && p->owner)
(428,pass[0])
(429,\'\\0\')
(430,ast_mutex_unlock(&p->lock)
(431,lastdisc)
(432,if (strchr(args.options, \'s\')
(433,tries)
(434,p->logincallerid[0] = \'\\0\')
(435,p)
(436,AST_STATE_UP)
(437,p->wrapuptime)
(438,agent_id)
(439,p)
(440,sizeof(user)
(441,p)
(442,p->moh)
(443,user)
(444,sizeof(pass)
(445,ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME")
(446,p)
(447,chan)
(448,ast_mutex_lock(&p->lock)
(449,p->loginstart)
(450,max_login_tries)
(451,logintime)
(452,"Agent/%s")
(453,tmpfmt)
(454,p->moh)
(455,p->moh)
(456,chan)
(457,res = 0)
(458,)
(459,loginstart)
(460,if (!ast_strlen_zero(args.options)
(461,max_login_tries)
(462,p)
(463,errmsg = "agent-alreadyon")
(464,update_cdr = 1)
(465,strlen(p->moh)
(466,max_login_tries)
(467,!ast_strlen_zero(args.options)
(468,strcpy(agent_goodbye, pbx_builtin_getvar_helper(chan, "AGENTGOODBYE")
(469,p)
(470,AST_LIST_UNLOCK(&agents)
(471,if (ast_true(pbx_builtin_getvar_helper(chan, "AGENTACKCALL")
(472,options)
(473,extension)
(474,p)
(475,tmpoptions)
(476,parse = ast_strdupa(data)
(477,p->acknowledged = 0)
(478,res)
(479,args.agent_id)
(480,AST_SOFTHANGUP_EXPLICIT)
(481,p)
(482,tmpoptions = pbx_builtin_getvar_helper(chan, "AGENTACCEPTDTMF")
(483,pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF")
(484,moh)
(485,&agents)
(486,)
(487,lock)
(488,p->lastdisc.tv_sec)
(489,tmpoptions)
(490,p->agent)
(491,update_cdr)
(492,agent)
(493,agents)
(494,chan)
(495,ackcall)
(496,ackcall)
(497,if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTGOODBYE")
(498,)
(499,500)
(500,p->agent)
(501,p)
(502,if (!res)
(503,"AGENTUPDATECDR")
(504,p->dead && !p->owner)
(505,-1)
(506,ast_channel_name(chan)
(507,ast_verb(3, "Saw variable AGENTMAXLOGINTRIES=%s, setting max_login_tries to: %d on Channel \'%s\'.\\n",tmpoptions,max_login_tries,ast_channel_name(chan)
(508,deferlogoff)
(509,ast_mutex_unlock(&p->lock)
(510,&p->lock)
(511,strcmp(p->agent, user)
(512,)
(513,pbx_builtin_getvar_helper(chan, "AGENTACKCALL")
(514,p->password)
(515,chan)
(516,)
(517,ast_strlen_zero(args.agent_id)
(518,p)
(519,agent_id)
(520,!res && (max_login_tries==0 || tries < max_login_tries)
(521,p)
(522,loginstart)
(523,ast_channel_cdr(chan)
(524,chan)
(525,*filename = "agent-loginok")
(526,if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTACKCALL")
(527,ast_strlen_zero(p->moh)
(528,p->wrapuptime)
(529,ast_channel_cdr(chan)
(530,max_login_tries)
(531,update_cdr)
(532,chan)
(533,p->wrapuptime = 0)
(534,pbx_builtin_getvar_helper(chan, "AGENTGOODBYE")
(535,p->lock)
(536,p = NULL)
(537,!res)
(538,p->autologoff < 0)
(539,1)
(540,p->wrapuptime)
(541,"agent-loginok")
(542,filename)
(543,app_complete_cond)
(544,check_availability(p, 0)
(545,ast_channel_uniqueid(chan)
(546,p)
(547,!res)
(548,ast_mutex_lock(&p->lock)
(549,p->chan)
(550,ast_channel_nativeformats(chan)
(551,p)
(552,agent)
(553,p->enddtmf)
(554,p)
(555,lastdisc)
(556,agent_id)
(557,ast_verb(3, "Saw variable AGENTWRAPUPTIME=%s, setting wrapuptime to: %d for Agent \'%s\'.\\n", tmpoptions, p->wrapuptime, p->agent)
(558,)
(559,agent)
(560,1)
(561,p)
(562,channel)
(563,&p->lock)
(564,data)
(565,if (p->ackcall)
(566,ast_mutex_lock(&p->lock)
(567,if (!ast_strlen_zero(xpass)
(568,"Agentlogoff")
(569,p->chan = chan)
(570,tmpoptions)
(571,ast_mutex_destroy(&p->lock)
(572,p)
(573,chan)
(574,res)
(575,if (!res)
(576,1)
(577,tmpfmt)
(578,NULL)
(579,check_beep(p, 0)
(580,p->deferlogoff && p->chan)
(581,ackcall)
(582,NULL)
(583,check_availability(p, 0)
(584,)
(585,p)
(586,ast_channel_name(chan)
(587,agents)
(588,acknowledged)
(589,break;)
(590,agent)
(591,if (!res && (max_login_tries==0 || tries < max_login_tries)
(592,enddtmf)
(593,autologoff)
(594,"AGENTACCEPTDTMF")
(595,!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTGOODBYE")
(596,p->lock)
(597,p->enddtmf = *tmpoptions)
(598,if (p->ackcall && (res == 1)
(599,p)
(600,if (p->app_lock_flag == 1)
(601,AGENT_FLAG_ACCEPTDTMF)
(602,lock)
(603,0)
(604,ast_tvdiff_ms(ast_tvnow()
(605,)
(606,lock)
(607,!strcmp(p->agent, user)
(608,chan)
(609,lock)
(610,ast_set_flag(p, AGENT_FLAG_ENDDTMF)
(611,AST_APP_ARG(agent_id)
(612,agent_goodbye)
(613,chan)
(614,!ast_strlen_zero(tmpoptions)
(615,p->wrapuptime)
(616,chan)
(617,res)
(618,chan)
(619,p)
(620,p->ackcall = 1)
(621,if (p->ackcall)
(622,p)
(623,AST_LIST_UNLOCK(&agents)
(624,!res)
(625,&p->lock)
(626,chan)
(627,if (res)
(628,)
(629,p)
(630,options)
(631,AST_LIST_UNLOCK(&agents)
(632,args)
(633,1)
(634,&p->lock)
(635,p->acceptdtmf)
(636,chan)
(637,chan)
(638,chan)
(639,lock)
(640,p)
(641,p->chan)
(642,args.agent_id)
(643,p->loginstart)
(644,"agent-user")
(645,update_cdr)
(646,chan)
(647,!res)
(648,1)
(649,AST_LIST_UNLOCK(&agents)
(650,p->lock)
(651,2)
(652,"AGENTWRAPUPTIME")
(653,res)
(654,ast_safe_sleep(chan, 500)
(655,"Agent/%s")
(656,"")
(657,chan)
(658,pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR")
(659,snprintf(agent, sizeof(agent)
(660,)
(661,ast_set_flag(p, AGENT_FLAG_ACKCALL)
(662,p->agent)
(663,tmpfmt)
(664,p)
(665,if (!ast_strlen_zero(tmpoptions)
(666,ast_true(pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR")
(667,p->ackcall)
(668,p->app_lock_flag == 1)
(669,tmpoptions)
(670,if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTLMAXLOGINTRIES")
(671,)
(672,ast_queue_log("NONE", ast_channel_uniqueid(chan)
(673,p->agent)
(674,ast_strlen_zero(tmpoptions)
(675,update_cdr = 0)
(676,play_announcement)
(677,max_login_tries)
(678,&p->lock)
(679,&p->lock)
(680,)
(681,if (!ast_strlen_zero(args.agent_id)
(682,chan)
(683,p)
(684,if (res)
(685,p->lock)
(686,0)
(687,)
(688,agent)
(689,res = -1)
(690,AST_LIST_UNLOCK(&agents)
(691,p->enddtmf)
(692,ast_set_flag(p, AGENT_FLAG_WRAPUPTIME)
(693,p->chan)
(694,lock)
(695,)
(696,xpass[AST_MAX_AGENT] = "")
(697,p->autologoff)
(698,"AGENTLMAXLOGINTRIES")
(699,&agents)
(700,autologoff)
(701,chan)
(702,p->lock)
(703,!ast_strlen_zero(args.agent_id)
(704,1000)
(705,agents)
(706,res)
(707,&p->app_complete_cond)
(708,)
(709,ast_cond_wait(&p->app_complete_cond, &p->lock)
(710,p->ackcall)
(711,AST_DEVICE_UNAVAILABLE)
(712,p)
(713,)
(714,p)
(715,0)
(716,AST_APP_ARG(extension)
(717,tmpfmt)
(718,ast_app_getdata(chan, "agent-user", user, sizeof(user)
(719,ast_waitstream(chan, "")
(720,"Saw variable AGENTENDDTMF=%s, setting enddtmf to: %c for Agent \'%s\'.\\n")
(721,ackcall)
(722,app_complete_cond)
(723,max_login_tries==0)
(724,res = ast_safe_sleep(chan, 500)
(725,!ast_strlen_zero(tmpoptions)
(726,)
(727,&p->lock)
(728,0)
(729,if (p->lastdisc.tv_sec)
(730,chan)
(731,p)
(732,wrapuptime)
(733,p = NULL)
(734,if (!res)
(735,"Saw variable AGENTACKCALL=%s, setting ackcall to: %d for Agent \'%s\'.\\n")
(736,res = ast_answer(chan)
(737,unlock_channel)
(738,tries)
(739,p)
(740,p)
(741,sizeof(pass)
(742,p)
(743,0)
(744,ast_mutex_unlock(&p->lock)
(745,time(NULL)
(746,"")
(747,p)
(748,p->acknowledged = 0)
(749,3)
(750,chan)
(751,p->agent)
(752,p->login_wait_cond)
(753,ast_channel_uniqueid(chan)
(754,*tmpoptions)
(755,p)
(756,pending)
(757,NULL)
(758,"Unable to set write format to %s\\n")
(759,0)
(760,autologoff)
(761,ast_free(p)
(762,p)
(763,chan)
(764,p)
(765,ast_strlen_zero(args.options)
(766,p->lock)
(767,"%s")
(768,play_announcement==1)
(769,&p->login_wait_cond)
(770,chan)
(771,agents)
(772,LOG_WARNING)
(773,0)
(774,res)
(775,p)
(776,res)
(777,p->acknowledged)
(778,ast_set_flag(p, AGENT_FLAG_AUTOLOGOFF)
(779,p->lock)
(780,&p->lock)
(781,agent)
(782,unlock_channel)
(783,&agents)
(784,p)
(785,ast_channel_unlock(chan)
(786,tv_sec)
(787,chan)
(788,ast_verb(3, "Saw variable AGENTGOODBYE=%s, setting agent_goodbye to: %s on Channel \'%s\'.\\n",tmpoptions,agent_goodbye,ast_channel_name(chan)
(789,ast_channel_uniqueid(chan)
(790,"AGENTUPDATECDR")
(791,pass)
(792,p)
(793,autologoff)
(794,owner)
(795,AGENT_FLAG_ACKCALL)
(796,p->ackcall)
(797,"agent-alreadyon")
(798,p)
(799,xpass)
(800,0)
(801,check_beep(p, 0)
(802,)
(803,p->lastdisc = ast_tv(0, 0)
(804,wrapuptime)
(805,res = ast_set_write_format_from_cap(chan, ast_channel_nativeformats(chan)
(806,lock)
(807,p)
(808,"")
(809,play_announcement = 0)
(810,args)
(811,ast_channel_lock(chan)
(812,tmpoptions)
(813,ast_debug(1, "Wrapup time for %s expired!\\n", p->agent)
(814,0)
(815,res=0)
(816,0)
(817,)
(818,chan)
(819,&p->lock)
(820,login_wait_cond)
(821,0)
(822,1)
(823,"AGENTUPDATECDR")
(824,p)
(825,user)
(826,p)
(827,!res)
(828,ast_copy_string(user, args.agent_id, AST_MAX_AGENT)
(829,p)
(830,ast_module_user_remove(u)
(831,"AGENTGOODBYE")
(832,max_login_tries==0)
(833,res = ast_safe_sleep_conditional( chan, 1000, agent_cont_sleep, p )
(834,res = ast_app_getdata(chan, errmsg, user, sizeof(user)
(835,ast_channel_lock(chan)
(836,chan)
(837,res)
(838,update_cdr)
(839,p)
(840,AST_LIST_LOCK(&agents)
(841,res = ast_app_getdata(chan, "agent-user", user, sizeof(user)
(842,filename)
(843,0)
(844,p->pending)
(845,res)
(846,!strcmp(p->agent, user)
(847,p)
(848,moh)
(849,chan)
(850,tries < max_login_tries)
(851,!p->chan)
(852,p->ackcall = 0)
(853,strchr(args.options, \'s\')
(854,loginstart)
(855,0)
(856,logintime = time(NULL)
(857,"AGENTLOGIN")
(858,res)
(859,pbx_builtin_getvar_helper(chan, "AGENTGOODBYE")
(860,AST_CONTROL_HOLD)
(861,if (p->chan)
(862,0)
(863,p->agent)
(864,res)
(865,"AGENTAUTOLOGOFF")
(866,res)
(867,play_announcement)
(868,if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF")
(869,agents)
(870,app_lock_flag)
(871,res)
(872,lock)
(873,p)
(874,ast_mutex_unlock(&p->lock)
(875,3)
(876,update_cdr && ast_channel_cdr(chan)
(877,if (!res)
(878,LOG_WARNING)
(879,p->ackcall)
(880,lock)
(881,"Saw variable AGENTGOODBYE=%s, setting agent_goodbye to: %s on Channel \'%s\'.\\n")
(882,play_announcement)
(883,p)
(884,agent[AST_MAX_AGENT] = "")
(885,res)
(886,p->logincallerid)
(887,ast_verb(3, "Saw variable AGENTUPDATECDR=%s, setting update_cdr to: %d on Channel \'%s\'.\\n",tmpoptions,update_cdr,ast_channel_name(chan)
(888,-1)
(889,agent)
(890,ast_mutex_unlock(&p->lock)
(891,p)
(892,lock)
(893,&p->lock)
(894,ast_set_read_format_from_cap(chan, ast_channel_nativeformats(chan)
(895,res >= 0)
(896,p->app_lock_flag)
(897,"Saw variable AGENTAUTOLOGOFF=%s, setting autologff to: %d for Agent \'%s\'.\\n")
(898,p->lock)
(899,)
(900,args)
(901,ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR")
(902,p)
(903,p->ackcall && (res == 1)
(904,res)
(905,ast_tvdiff_ms(ast_tvnow()
(906,p->chan)
(907,pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF")
(908,)
(909,ast_getformatname(ast_channel_writeformat(chan)
(910,p->lock)
(911,p->lastdisc)
(912,tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTGOODBYE")
(913,p->autologoff)
(914,p)
(915,p)
(916,!strcmp(p->agent, user)
(917,)
(918,if( !res && play_announcement==1 )
(919,ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Agent/%s", p->agent)
(920,wrapuptime)
(921,ast_mutex_unlock(&p->lock)
(922,"Agent \'%s\' logged in (format %s/%s)
(923,const char *data)
(924,agent)
(925,res)
(926,user)
(927,play_announcement = 1)
(928,pbx_builtin_getvar_helper(chan, "AGENTACCEPTDTMF")
(929,1)
(930,chan)
(931,!res && play_announcement==1)
(932,agents)
(933,p->lastdisc.tv_sec)
(934,strcmp(p->agent, user)
(935,max_login_tries)
(936,0)
(937,p)
(938,updatecdr)
(939,1)
(940,agent)
(941,sizeof(xpass)
(942,"Saw variable AGENTWRAPUPTIME=%s, setting wrapuptime to: %d for Agent \'%s\'.\\n")
(943,user)
(944,chan)
(945,tmpoptions)
(946,p->app_complete_cond)
(947,ast_mutex_unlock(&p->lock)
(948,ast_verb(3, "Saw variable AGENTAUTOLOGOFF=%s, setting autologff to: %d for Agent \'%s\'.\\n", tmpoptions, p->autologoff, p->agent)
(949,max_login_tries = 0)
(950,res)
(951,if (!p)
(952,ast_indicate_data(chan, AST_CONTROL_HOLD,\n\\n\\t\\t\\t\\t\\t\\t\\tS_OR(p->moh, NULL)
(953,&agents)
(954,ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTGOODBYE")
(955,pass)
(956,0)
(957,res)
(958,update_cdr)
(959,sched_yield()
(960,p->owner)
(961,u = ast_module_user_add(chan)
(962,tmpoptions)
(963,!p)
(964,errmsg)
(965,3)
(966,ast_channel_name(chan)
(967,agents)
(968,"AGENTAUTOLOGOFF")
(969,pbx_builtin_getvar_helper(chan, "AGENTACKCALL")
(970,ast_tvnow()
(971,!ast_strlen_zero(p->moh)
(972,ast_streamfile(chan, filename, ast_channel_language(chan)
(973,agents)
(974,p)
(975,ast_channel_name(chan)
(976,pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR")
(977,0)
(978,pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR")
(979,user[AST_MAX_AGENT] = "")
(980,"Agent: %s\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t      "Logintime: %ld\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t      "Uniqueid: %s\\r\\n")
(981,p)
(982,lock)
(983,!p->pending)
(984,manager_event(EVENT_FLAG_AGENT, "Agentlogin",\n\\n\\t\\t\\t\\t\\t\\t\\t      "Agent: %s\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t      "Channel: %s\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t      "Uniqueid: %s\\r\\n",\n\\n\\t\\t\\t\\t\\t\\t\\t      p->agent, ast_channel_name(chan)
(985,1)
(986,max_login_tries)
(987,&agents)
(988,tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME")
(989,atoi(pbx_builtin_getvar_helper(chan, "AGENTMAXLOGINTRIES")
(990,pbx_builtin_getvar_helper(chan, "AGENTGOODBYE")
(991,if (p->loginstart == 0)
(992,dead)
(993,1)
(994,p)
(995,p->lastdisc)
(996,ast_channel_state(chan)
(997,p)
(998,pass)
(999,chan)
(1000,ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTACKCALL")
(1001,p->wrapuptime = wrapuptime)
(1002,p)
(1003,update_cdr = updatecdr)
(1004,!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTACKCALL")
(1005,!ast_strlen_zero(p->moh)
(1006,user)
(1007,errmsg)
(1008,AST_MAX_AGENT)
(1009,ast_set_flag(p, AGENT_FLAG_ACCEPTDTMF)
(1010,if (!strcmp(p->agent, user)
(1011,parse)
(1012,tries)
(1013,p->lastdisc)
(1014,p)
(1015,chan)
(1016,p)
(1017,lock)
(1018,tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF")
(1019,AST_APP_ARG(options)
(1020,if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME")
(1021,)
(1022,ast_log(LOG_WARNING, "Huh?  We broke out when there was still an owner?\\n")
(1023,res)
(1024,xpass)
(1025,p)
(1026,p->acceptdtmf)
(1027,xpass)
(1028,p->deferlogoff = 0)
(1029,sizeof(user)
(1030,ast_channel_writeformat(chan)
(1031,)
(1032,sizeof(agent)
(1033,p->lock)
(1034,p->chan)
(1035,login_wait_cond)
(1036,pass[0] = \'\\0\')
(1037,ast_copy_string(agent_goodbye, agentgoodbye, sizeof(agent_goodbye)
(1038,0)
(1039,if (!res)
(1040,p)
(1041,p)
(1042,!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME")
(1043,p->agent)
(1044,*tmpoptions = NULL)
(1045,tmpoptions)
(1046,lastdisc)
(1047,login_wait_cond)
(1048,p->chan)
(1049,p)
(1050,ast_cond_destroy(&p->app_complete_cond)
(1051,p)
(1052,chan)
(1053,if (p->wrapuptime < 0)
(1054,agent_goodbye)
(1055,NULL)
(1056,max_login_tries==0 || tries < max_login_tries)
(1057,chan)
(1058,ast_true(pbx_builtin_getvar_helper(chan, "AGENTACKCALL")
(1059,p)
(1060,res)
(1061,3)
(1062,p)
(1063,)
(1064,p->lock)
(1065,&tmpfmt)
(1066,user)
(1067,chan)
(1068,)
(1069,p->lastdisc)
(1070,tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTMAXLOGINTRIES")
(1071,chan)
(1072,0)
(1073,p)
(1074,chan)
(1075,p->app_complete_cond)
(1076,ast_devstate_changed(AST_DEVICE_UNAVAILABLE, "Agent/%s", p->agent)
(1077,&p->login_wait_cond)
(1078,p)
(1079,args)
(1080,&p->lock)
(1081,p)
(1082,max_login_tries==0 || tries < max_login_tries)
(1083,pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME")
(1084,max_login_tries = maxlogintries)
(1085,)
(1086,"AGENTMAXLOGINTRIES")
(1087,p)
(1088,check_availability(p, 0)
(1089,ast_set_write_format_from_cap(chan, ast_channel_nativeformats(chan)
(1090,AST_STANDARD_APP_ARGS(args, parse)
(1091,sizeof(ast_channel_cdr(chan)
(1092,p->wrapuptime = atoi(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME")
(1093,0)
(1094,p->ackcall)
(1095,autologoff)
(1096,p)
(1097,lock)
(1098,tmpoptions = pbx_builtin_getvar_helper(chan, "AGENTENDDTMF")
(1099,"AGENTMAXLOGINTRIES")
(1100,p)
(1101,!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR")
(1102,user)
(1103,ast_queue_log("NONE", ast_channel_uniqueid(chan)
(1104,lock)
(1105,chan)
(1106,ast_getformatname(&tmpfmt)
(1107,ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Agent/%s", p->agent)
(1108,tmpoptions)
(1109,ast_cond_signal(&p->login_wait_cond)
(1110,tmpoptions)
(1111,agent)
(1112,filename)
(1113,ast_module_user_add(chan)
(1114,agent)
(1115,manager_event(EVENT_FLAG_AGENT, "Agentlogoff",\n\\n\\t\\t\\t\\t\\t\\t\\t      "Agent: %s\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t      "Logintime: %ld\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t      "Uniqueid: %s\\r\\n",\n\\n\\t\\t\\t\\t\\t\\t\\t      p->agent, logintime, ast_channel_uniqueid(chan)
(1116,p)
(1117,tv_sec)
(1118,res = ast_streamfile(chan, filename, ast_channel_language(chan)
(1119,chan)
(1120,agent)
(1121,ast_log(LOG_WARNING, "Unable to set write format to %s\\n", ast_getformatname(&tmpfmt)
(1122,p->autologoff)
(1123,p->ackcall)
(1124,p)
(1125,p)
(1126,agent)
(1127,p->agent)
(1128,&p->loginstart)
(1129,ast_channel_cdr(chan)
(1130,p)
(1131,"agent-incorrect")
(1132,chan)
(1133,ast_channel_unlock(chan)
(1134,lock)
(1135,ast_channel_uniqueid(chan)
(1136,if (p->app_lock_flag == 1)
(1137,lastdisc)
(1138,"NONE")
(1139,p->ackcall)
(1140,ast_cond_wait(&p->app_complete_cond, &p->lock)
(1141,ast_verb(2, "Agent \'%s\' logged in (format %s/%s)
(1142,)
(1143,p->lock)
(1144,res)
(1145,agent_cont_sleep)
(1146,!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTLMAXLOGINTRIES")
(1147,acceptdtmf)
(1148,agentgoodbye)
(1149,p->acknowledged)
(1150,p)
(1151,p)
(1152,ast_strlen_zero(tmpoptions)
(1153,ast_getformatname(&tmpfmt)
(1154,p)
(1155,tmpoptions)
(1156,"AGENTAUTOLOGOFF")
(1157,)
(1158,S_OR(p->moh, NULL)
(1159,agent)
(1160,lock)
(1161,user)
(1162,EVENT_FLAG_AGENT)
(1163,)
(1164,res)
(1165,ast_mutex_lock(&p->lock)
(1166,"AGENTACKCALL")
(1167,"AGENTLOGOFF")
(1168,p)
(1169,"Agentlogin")
(1170,p)
(1171,if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR")
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^