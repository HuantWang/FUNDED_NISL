-----label-----
0
-----code-----
static void goodB2G()
{
    size_t data;
    /* Initialize data */
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = "";
        /* POTENTIAL FLAW: Read data from the console using fgets() */
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            /* Convert to unsigned int */
            data = strtoul(inputBuffer, NULL, 0);
        }
        else
        {
            printLine("fgets() failed.");
        }
    }
    {
        size_t dataCopy = data;
        size_t data = dataCopy;
        {
            char * myString;
            /* FIX: Include a MAXIMUM limitation for memory allocation and a check to ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */
            if (data > strlen(HELLO_STRING) && data < 100)
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                /* Copy a small string into myString */
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine("Input is less than the length of the source string or too large");
            }
        }
    }
}
-----children-----
1,2
1,3
1,4
3,4
5,6
5,7
5,8
5,9
6,7
7,8
7,9
8,9
10,11
12,13
13,14
13,15
14,15
17,18
17,19
18,19
19,20
19,21
21,22
21,23
21,24
23,24
24,25
26,27
28,29
28,30
28,31
29,30
29,31
30,31
30,32
30,33
30,34
31,32
33,34
35,36
37,38
39,40
41,42
42,43
43,44
43,45
44,45
46,47
46,48
46,49
46,50
47,48
49,50
51,52
54,55
55,56
56,57
56,58
57,58
60,61
60,62
60,63
61,62
62,63
62,64
63,64
65,66
65,67
67,68
68,69
70,71
71,72
71,73
72,73
74,75
74,76
76,77
77,78
79,80
79,81
80,81
81,82
81,83
83,84
83,85
86,87
86,88
86,89
87,88
87,89
88,89
88,90
89,90
91,92
91,93
92,93
94,95
96,97
96,98
97,98
100,101
100,102
100,103
100,104
100,105
101,102
102,103
102,104
103,104
105,106
105,107
106,107
106,108
108,109
110,111
110,112
111,112
113,114
113,115
114,115
116,117
117,118
117,119
120,121
120,122
121,122
121,123
122,123
124,125
126,127
127,128
128,129
128,130
129,130
131,132
133,134
134,135
134,136
134,137
135,136
137,138
139,140
141,142
142,143
142,144
143,144
145,146
147,148
148,149
148,150
149,150
151,152
153,154
154,155
155,156
155,157
156,157
-----nextToken-----
2,4,9,11,15,16,20,22,25,27,32,34,36,38,40,45,48,50,52,53,58,59,64,66,69,73,75,78,82,84,85,90,93,95,98,99,104,107,109,112,115,118,119,123,125,130,132,136,138,140,144,146,150,152,157,158
-----computeFrom-----
13,14
13,15
29,30
29,31
43,44
43,45
87,88
87,89
88,89
88,90
96,97
96,98
102,103
102,104
113,114
113,115
121,122
121,123
-----guardedBy-----
34,50
40,52
95,140
98,115
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;IdExpression;Name;EqualsInitializer;LiteralExpression;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FunctionCallExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;TypeIdExpression;TypeId;SimpleDeclSpecifier;Declarator;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;
-----ast_node-----
static void goodB2G(){    size_t data;    /* Initialize data */    data = 0;    {        char inputBuffer[CHAR_ARRAY_SIZE] = "";        /* POTENTIAL FLAW: Read data from the console using fgets() */        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)        {            /* Convert to unsigned int */            data = strtoul(inputBuffer, NULL, 0);        }        else        {            printLine("fgets() failed.");        }    }    {        size_t dataCopy = data;        size_t data = dataCopy;        {            char * myString;            /* FIX: Include a MAXIMUM limitation for memory allocation and a check to ensure data is large enough             * for the strcpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > strlen(HELLO_STRING) && data < 100)            {                myString = (char *)malloc(data*sizeof(char));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                strcpy(myString, HELLO_STRING);                printLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string or too large");            }        }    }}
static void
goodB2G()
goodB2G
{    size_t data;    /* Initialize data */    data = 0;    {        char inputBuffer[CHAR_ARRAY_SIZE] = "";        /* POTENTIAL FLAW: Read data from the console using fgets() */        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)        {            /* Convert to unsigned int */            data = strtoul(inputBuffer, NULL, 0);        }        else        {            printLine("fgets() failed.");        }    }    {        size_t dataCopy = data;        size_t data = dataCopy;        {            char * myString;            /* FIX: Include a MAXIMUM limitation for memory allocation and a check to ensure data is large enough             * for the strcpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > strlen(HELLO_STRING) && data < 100)            {                myString = (char *)malloc(data*sizeof(char));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                strcpy(myString, HELLO_STRING);                printLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string or too large");            }        }    }}
size_t data;
size_t data;
size_t
size_t
data
data
data = 0;
data = 0
data
data
0
{        char inputBuffer[CHAR_ARRAY_SIZE] = "";        /* POTENTIAL FLAW: Read data from the console using fgets() */        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)        {            /* Convert to unsigned int */            data = strtoul(inputBuffer, NULL, 0);        }        else        {            printLine("fgets() failed.");        }    }
char inputBuffer[CHAR_ARRAY_SIZE] = "";
char inputBuffer[CHAR_ARRAY_SIZE] = "";
char
inputBuffer[CHAR_ARRAY_SIZE] = ""
inputBuffer
[CHAR_ARRAY_SIZE]
CHAR_ARRAY_SIZE
CHAR_ARRAY_SIZE
= ""
""
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)        {            /* Convert to unsigned int */            data = strtoul(inputBuffer, NULL, 0);        }        else        {            printLine("fgets() failed.");        }
fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL
fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin)
fgets
fgets
inputBuffer
inputBuffer
CHAR_ARRAY_SIZE
CHAR_ARRAY_SIZE
stdin
stdin
NULL
NULL
{            /* Convert to unsigned int */            data = strtoul(inputBuffer, NULL, 0);        }
data = strtoul(inputBuffer, NULL, 0);
data = strtoul(inputBuffer, NULL, 0)
data
data
strtoul(inputBuffer, NULL, 0)
strtoul
strtoul
inputBuffer
inputBuffer
NULL
NULL
0
{            printLine("fgets() failed.");        }
printLine("fgets() failed.");
printLine("fgets() failed.")
printLine
printLine
"fgets() failed."
{        size_t dataCopy = data;        size_t data = dataCopy;        {            char * myString;            /* FIX: Include a MAXIMUM limitation for memory allocation and a check to ensure data is large enough             * for the strcpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > strlen(HELLO_STRING) && data < 100)            {                myString = (char *)malloc(data*sizeof(char));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                strcpy(myString, HELLO_STRING);                printLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string or too large");            }        }    }
size_t dataCopy = data;
size_t dataCopy = data;
size_t
size_t
dataCopy = data
dataCopy
= data
data
data
size_t data = dataCopy;
size_t data = dataCopy;
size_t
size_t
data = dataCopy
data
= dataCopy
dataCopy
dataCopy
{            char * myString;            /* FIX: Include a MAXIMUM limitation for memory allocation and a check to ensure data is large enough             * for the strcpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > strlen(HELLO_STRING) && data < 100)            {                myString = (char *)malloc(data*sizeof(char));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                strcpy(myString, HELLO_STRING);                printLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string or too large");            }        }
char * myString;
char * myString;
char
* myString
*
myString
if (data > strlen(HELLO_STRING) && data < 100)            {                myString = (char *)malloc(data*sizeof(char));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                strcpy(myString, HELLO_STRING);                printLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string or too large");            }
data > strlen(HELLO_STRING) && data < 100
data > strlen(HELLO_STRING)
data
data
strlen(HELLO_STRING)
strlen
strlen
HELLO_STRING
HELLO_STRING
data < 100
data
data
100
{                myString = (char *)malloc(data*sizeof(char));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                strcpy(myString, HELLO_STRING);                printLine(myString);                free(myString);            }
myString = (char *)malloc(data*sizeof(char));
myString = (char *)malloc(data*sizeof(char))
myString
myString
(char *)malloc(data*sizeof(char))
char *
char
*
*
malloc(data*sizeof(char))
malloc
malloc
data*sizeof(char)
data
data
sizeof(char)
char
char

if (myString == NULL) {exit(-1);}
myString == NULL
myString
myString
NULL
NULL
{exit(-1);}
exit(-1);
exit(-1)
exit
exit
-1
1
strcpy(myString, HELLO_STRING);
strcpy(myString, HELLO_STRING)
strcpy
strcpy
myString
myString
HELLO_STRING
HELLO_STRING
printLine(myString);
printLine(myString)
printLine
printLine
myString
myString
free(myString);
free(myString)
free
free
myString
myString
{                printLine("Input is less than the length of the source string or too large");            }
printLine("Input is less than the length of the source string or too large");
printLine("Input is less than the length of the source string or too large")
printLine
printLine
"Input is less than the length of the source string or too large"
-----joern-----
(28,37,0)
(58,75,0)
(47,56,0)
(10,7,0)
(17,11,0)
(11,55,0)
(13,25,0)
(9,7,0)
(27,51,0)
(31,55,0)
(29,49,0)
(68,37,0)
(41,51,0)
(70,38,0)
(8,42,0)
(55,20,0)
(2,59,0)
(73,55,0)
(72,14,0)
(42,53,0)
(62,23,0)
(8,17,0)
(69,20,0)
(61,51,0)
(11,17,0)
(51,37,0)
(11,48,0)
(48,11,0)
(23,62,0)
(35,53,0)
(39,24,0)
(67,56,0)
(34,51,0)
(45,31,0)
(19,8,0)
(63,5,0)
(8,49,0)
(46,13,0)
(23,42,0)
(5,7,0)
(56,53,0)
(3,40,0)
(21,23,0)
(65,59,0)
(75,62,0)
(51,41,0)
(18,24,0)
(50,75,0)
(71,12,0)
(75,50,0)
(15,66,0)
(54,69,0)
(62,75,0)
(49,8,0)
(36,23,0)
(57,50,0)
(75,42,0)
(42,56,0)
(56,24,0)
(16,52,0)
(69,55,0)
(24,74,0)
(31,20,0)
(41,22,0)
(12,74,0)
(38,20,0)
(7,5,0)
(60,41,0)
(4,42,0)
(55,11,0)
(52,72,0)
(7,37,0)
(53,74,0)
(44,42,0)
(1,53,0)
(32,12,0)
(17,8,0)
(38,55,0)
(37,12,0)
(56,41,0)
(26,40,0)
(59,55,0)
(0,7,0)
(72,52,0)
(33,74,0)
(66,30,0)
(40,53,0)
(43,31,0)
(6,20,0)
(4,56,1)
(68,24,1)
(29,19,1)
(7,37,1)
(9,0,1)
(21,75,1)
(7,10,1)
(50,57,1)
(60,5,1)
(59,55,1)
(42,56,1)
(46,62,1)
(67,47,1)
(11,48,1)
(11,17,1)
(37,28,1)
(59,2,1)
(51,37,1)
(64,13,1)
(45,72,1)
(49,29,1)
(38,55,1)
(0,37,1)
(10,9,1)
(47,66,1)
(16,59,1)
(43,45,1)
(41,51,1)
(24,39,1)
(5,7,1)
(63,7,1)
(44,4,1)
(34,60,1)
(62,23,1)
(56,24,1)
(17,8,1)
(69,54,1)
(39,18,1)
(51,61,1)
(19,73,1)
(62,75,1)
(54,38,1)
(69,55,1)
(45,59,1)
(55,11,1)
(56,41,1)
(57,58,1)
(56,67,1)
(75,42,1)
(66,15,1)
(23,42,1)
(31,43,1)
(27,34,1)
(8,49,1)
(47,41,1)
(64,69,1)
(72,52,1)
(28,68,1)
(73,62,1)
(13,46,1)
(31,55,1)
(52,16,1)
(42,44,1)
(61,27,1)
(2,65,1)
(38,70,1)
(23,36,1)
(70,31,1)
(8,42,1)
(58,42,1)
(15,5,1)
(65,55,1)
(75,50,1)
(36,21,1)
(5,63,1)
(61,5,2)
(42,56,2)
(60,5,2)
(43,62,2)
(15,5,2)
(27,5,2)
(75,50,2)
(7,37,2)
(34,5,2)
(2,62,2)
(38,62,2)
(17,62,2)
(66,5,2)
(19,62,2)
(29,62,2)
(8,42,2)
(72,59,2)
(16,59,2)
(45,62,2)
(59,55,2)
(52,59,2)
(23,75,2)
(13,62,2)
(69,55,2)
(55,11,2)
(23,42,2)
(55,62,2)
(11,17,2)
(51,37,2)
(62,75,2)
(56,24,2)
(21,75,2)
(8,49,2)
(38,55,2)
(5,7,2)
(70,62,2)
(69,62,2)
(31,62,2)
(31,55,2)
(11,62,2)
(46,62,2)
(49,62,2)
(8,62,2)
(51,5,2)
(65,62,2)
(36,75,2)
(41,51,2)
(75,42,2)
(17,8,2)
(59,62,2)
(54,62,2)
(73,62,2)
(56,41,2)
(62,23,2)
(72,52,2)
(11,48,2)
(41,5,2)
-----------------------------------
(0,inputBuffer)
(1,data)
(2,NULL)
(3,myString)
(4,data)
(5,fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin)
(6,if (myString == NULL)
(7,fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin)
(8,data*sizeof(char)
(9,CHAR_ARRAY_SIZE)
(10,stdin)
(11,(char *)
(12,)
(13,printLine("Input is less than the length of the source string or too large")
(14,)
(15,"fgets()
(16,1)
(17,malloc(data*sizeof(char)
(18,data)
(19,data)
(20,)
(21,data)
(22,)
(23,data < 100)
(24,data = 0)
(25,)
(26,if (data > strlen(HELLO_STRING)
(27,NULL)
(28,"")
(29,char)
(30,)
(31,strcpy(myString, HELLO_STRING)
(32,if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin)
(33,data)
(34,inputBuffer)
(35,dataCopy)
(36,100)
(37,inputBuffer[CHAR_ARRAY_SIZE] = "")
(38,printLine(myString)
(39,0)
(40,)
(41,data = strtoul(inputBuffer, NULL, 0)
(42,data = dataCopy)
(43,HELLO_STRING)
(44,dataCopy)
(45,myString)
(46,"Input is less than the length of the source string or too large")
(47,dataCopy)
(48,char *)
(49,sizeof(char)
(50,strlen(HELLO_STRING)
(51,strtoul(inputBuffer, NULL, 0)
(52,-1)
(53,)
(54,myString)
(55,myString = (char *)
(56,dataCopy = data)
(57,HELLO_STRING)
(58,data)
(59,myString == NULL)
(60,data)
(61,0)
(62,data > strlen(HELLO_STRING)
(63,NULL)
(64,RET)
(65,myString)
(66,printLine("fgets()
(67,data)
(68,inputBuffer)
(69,free(myString)
(70,myString)
(71,inputBuffer)
(72,exit(-1)
(73,myString)
(74,)
(75,data > strlen(HELLO_STRING)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^