-----label-----
1
-----code-----
static void
gdp_event_cb(struct bufferevent *bev, short events, void *ctx)
{
	bool restart_connection = false;
	gdp_chan_t **pchan = ctx;
	gdp_chan_t *chan = *pchan;

	if (ep_dbg_test(Dbg, 25))
	{
		ep_dbg_printf("gdp_event_cb: ");
		ep_prflags(events, EventWhatFlags, ep_dbg_getfile());
		ep_dbg_printf(", fd=%d , errno=%d\n",
				bufferevent_getfd(bev), EVUTIL_SOCKET_ERROR());
	}

	EP_ASSERT(bev == chan->bev);

	if (EP_UT_BITSET(BEV_EVENT_CONNECTED, events))
	{
		// sometimes libevent says we're connected when we're not
		if (EVUTIL_SOCKET_ERROR() == ECONNREFUSED)
			chan->state = GDP_CHAN_ERROR;
		else
			chan->state = GDP_CHAN_CONNECTED;
		ep_thr_cond_broadcast(&chan->cond);
	}
	if (EP_UT_BITSET(BEV_EVENT_EOF, events))
	{
		gdp_buf_t *ievb = bufferevent_get_input(bev);
		size_t l = gdp_buf_getlength(ievb);

		ep_dbg_cprintf(Dbg, 1, "_gdp_event_cb: got EOF, %zu bytes left\n", l);
		restart_connection = true;
	}
	if (EP_UT_BITSET(BEV_EVENT_ERROR, events))
	{
		int sockerr = EVUTIL_SOCKET_ERROR();

		ep_dbg_cprintf(Dbg, 1, "_gdp_event_cb: error: %s\n",
				evutil_socket_error_to_string(sockerr));
		restart_connection = true;
	}

	// if we need to restart, let it run
	if (restart_connection)
	{
		EP_STAT estat;

		chan->state = GDP_CHAN_ERROR;
		ep_thr_cond_broadcast(&chan->cond);

		//_gdp_chan_close(pchan);
		do
		{
			long delay = ep_adm_getlongparam("swarm.gdp.reconnect.delay", 1000L);
			if (delay > 0)
				ep_time_nanosleep(delay * INT64_C(1000000));
			estat = _gdp_chan_open(NULL, NULL, pchan);
		} while (!EP_STAT_ISOK(estat));
		(*chan->advertise)(GDP_CMD_ADVERTISE);
	}
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
3,7
5,6
5,7
6,7
8,9
8,10
11,12
11,13
13,14
15,16
15,17
17,18
17,19
20,21
20,22
20,23
20,24
20,25
20,26
20,27
20,28
20,29
21,22
22,23
22,24
24,25
24,26
26,27
28,29
29,30
29,31
30,31
32,33
32,34
32,35
32,36
36,37
37,38
39,40
40,41
40,42
41,42
43,44
43,45
43,46
46,47
47,48
48,49
50,51
50,52
51,52
51,53
51,54
52,53
54,55
57,58
57,59
57,60
58,59
59,60
59,61
60,61
63,64
64,65
64,66
64,67
64,68
65,66
67,68
69,70
71,72
72,73
74,75
75,76
75,77
75,78
75,79
76,77
79,80
79,81
80,81
82,83
84,85
85,86
87,88
88,89
88,90
89,90
91,92
91,93
92,93
94,95
94,96
95,96
98,99
98,100
99,100
99,101
99,102
100,101
102,103
104,105
106,107
106,108
107,108
107,109
107,110
108,109
108,110
109,110
110,111
112,113
114,115
115,116
115,117
116,117
116,118
117,118
120,121
122,123
123,124
123,125
124,125
124,126
125,126
128,129
130,131
131,132
131,133
132,133
134,135
135,136
135,137
136,137
139,140
139,141
140,141
140,142
140,143
141,142
143,144
145,146
147,148
147,149
147,150
147,151
148,149
149,150
149,151
150,151
152,153
152,154
152,155
155,156
156,157
156,158
157,158
159,160
161,162
162,163
162,164
163,164
165,166
165,167
167,168
168,169
168,170
169,170
171,172
173,174
174,175
174,176
174,177
174,178
174,179
175,176
177,178
181,182
183,184
184,185
184,186
185,186
188,189
188,190
189,190
189,191
189,192
190,191
192,193
194,195
196,197
196,198
196,199
197,198
198,199
198,200
200,201
200,202
202,203
203,204
204,205
206,207
207,208
207,209
207,210
207,211
207,212
208,209
210,211
214,215
214,216
215,216
217,218
219,220
220,221
220,222
221,222
224,225
224,226
225,226
227,228
227,229
227,230
227,231
227,232
228,229
229,230
229,231
230,231
232,233
234,235
235,236
235,237
236,237
236,238
237,238
240,241
242,243
243,244
243,245
244,245
246,247
247,248
247,249
248,249
251,252
251,253
252,253
252,254
252,255
253,254
254,255
254,256
256,257
256,258
258,259
259,260
259,261
259,262
260,261
264,265
264,266
265,266
265,267
266,267
269,270
270,271
270,272
271,272
273,274
273,275
274,275
276,277
276,278
277,278
280,281
281,282
281,283
282,283
284,285
284,286
284,287
284,288
285,286
287,288
289,290
291,292
293,294
294,295
294,296
295,296
297,298
299,300
300,301
300,302
301,302
302,303
303,304
303,305
304,305
307,308
-----nextToken-----
2,4,7,9,10,12,14,16,18,19,23,25,27,31,33,34,35,38,42,44,45,49,53,55,56,61,62,66,68,70,73,77,78,81,83,86,90,93,96,97,101,103,105,111,113,118,119,121,126,127,129,133,137,138,142,144,146,151,153,154,158,160,164,166,170,172,176,178,179,180,182,186,187,191,193,195,199,201,205,209,211,212,213,216,218,222,223,226,231,233,238,239,241,245,249,250,255,257,261,262,263,267,268,272,275,278,279,283,286,288,290,292,296,298,305,306,308
-----computeFrom-----
91,92
91,93
108,109
108,110
115,116
115,117
123,124
123,125
184,185
184,186
220,221
220,222
235,236
235,237
265,266
265,267
273,274
273,275
281,282
281,283
-----guardedBy-----
267,275
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Pointer;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;UnaryExpression;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;DoStatement;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;UnaryExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;
-----ast_node-----
static voidgdp_event_cb(struct bufferevent *bev, short events, void *ctx){	bool restart_connection = false;	gdp_chan_t **pchan = ctx;	gdp_chan_t *chan = *pchan;	if (ep_dbg_test(Dbg, 25))	{		ep_dbg_printf("gdp_event_cb: ");		ep_prflags(events, EventWhatFlags, ep_dbg_getfile());		ep_dbg_printf(", fd=%d , errno=%d\n",				bufferevent_getfd(bev), EVUTIL_SOCKET_ERROR());	}	EP_ASSERT(bev == chan->bev);	if (EP_UT_BITSET(BEV_EVENT_CONNECTED, events))	{		// sometimes libevent says we're connected when we're not		if (EVUTIL_SOCKET_ERROR() == ECONNREFUSED)			chan->state = GDP_CHAN_ERROR;		else			chan->state = GDP_CHAN_CONNECTED;		ep_thr_cond_broadcast(&chan->cond);	}	if (EP_UT_BITSET(BEV_EVENT_EOF, events))	{		gdp_buf_t *ievb = bufferevent_get_input(bev);		size_t l = gdp_buf_getlength(ievb);		ep_dbg_cprintf(Dbg, 1, "_gdp_event_cb: got EOF, %zu bytes left\n", l);		restart_connection = true;	}	if (EP_UT_BITSET(BEV_EVENT_ERROR, events))	{		int sockerr = EVUTIL_SOCKET_ERROR();		ep_dbg_cprintf(Dbg, 1, "_gdp_event_cb: error: %s\n",				evutil_socket_error_to_string(sockerr));		restart_connection = true;	}	// if we need to restart, let it run	if (restart_connection)	{		EP_STAT estat;		chan->state = GDP_CHAN_ERROR;		ep_thr_cond_broadcast(&chan->cond);		//_gdp_chan_close(pchan);		do		{			long delay = ep_adm_getlongparam("swarm.gdp.reconnect.delay", 1000L);			if (delay > 0)				ep_time_nanosleep(delay * INT64_C(1000000));			estat = _gdp_chan_open(NULL, NULL, pchan);		} while (!EP_STAT_ISOK(estat));		(*chan->advertise)(GDP_CMD_ADVERTISE);	}}
static void
gdp_event_cb(struct bufferevent *bev, short events, void *ctx)
gdp_event_cb
struct bufferevent *bev
struct bufferevent
bufferevent
*bev
*
bev
short events
short
events
events
void *ctx
void
*ctx
*
ctx
{	bool restart_connection = false;	gdp_chan_t **pchan = ctx;	gdp_chan_t *chan = *pchan;	if (ep_dbg_test(Dbg, 25))	{		ep_dbg_printf("gdp_event_cb: ");		ep_prflags(events, EventWhatFlags, ep_dbg_getfile());		ep_dbg_printf(", fd=%d , errno=%d\n",				bufferevent_getfd(bev), EVUTIL_SOCKET_ERROR());	}	EP_ASSERT(bev == chan->bev);	if (EP_UT_BITSET(BEV_EVENT_CONNECTED, events))	{		// sometimes libevent says we're connected when we're not		if (EVUTIL_SOCKET_ERROR() == ECONNREFUSED)			chan->state = GDP_CHAN_ERROR;		else			chan->state = GDP_CHAN_CONNECTED;		ep_thr_cond_broadcast(&chan->cond);	}	if (EP_UT_BITSET(BEV_EVENT_EOF, events))	{		gdp_buf_t *ievb = bufferevent_get_input(bev);		size_t l = gdp_buf_getlength(ievb);		ep_dbg_cprintf(Dbg, 1, "_gdp_event_cb: got EOF, %zu bytes left\n", l);		restart_connection = true;	}	if (EP_UT_BITSET(BEV_EVENT_ERROR, events))	{		int sockerr = EVUTIL_SOCKET_ERROR();		ep_dbg_cprintf(Dbg, 1, "_gdp_event_cb: error: %s\n",				evutil_socket_error_to_string(sockerr));		restart_connection = true;	}	// if we need to restart, let it run	if (restart_connection)	{		EP_STAT estat;		chan->state = GDP_CHAN_ERROR;		ep_thr_cond_broadcast(&chan->cond);		//_gdp_chan_close(pchan);		do		{			long delay = ep_adm_getlongparam("swarm.gdp.reconnect.delay", 1000L);			if (delay > 0)				ep_time_nanosleep(delay * INT64_C(1000000));			estat = _gdp_chan_open(NULL, NULL, pchan);		} while (!EP_STAT_ISOK(estat));		(*chan->advertise)(GDP_CMD_ADVERTISE);	}}
bool restart_connection = false;
bool restart_connection = false;
bool
restart_connection = false
restart_connection
= false
false
gdp_chan_t **pchan = ctx;
gdp_chan_t **pchan = ctx;
gdp_chan_t
gdp_chan_t
**pchan = ctx
*
*
pchan
= ctx
ctx
ctx
gdp_chan_t *chan = *pchan;
gdp_chan_t *chan = *pchan;
gdp_chan_t
gdp_chan_t
*chan = *pchan
*
chan
= *pchan
*pchan
pchan
pchan
if (ep_dbg_test(Dbg, 25))	{		ep_dbg_printf("gdp_event_cb: ");		ep_prflags(events, EventWhatFlags, ep_dbg_getfile());		ep_dbg_printf(", fd=%d , errno=%d\n",				bufferevent_getfd(bev), EVUTIL_SOCKET_ERROR());	}
ep_dbg_test(Dbg, 25)
ep_dbg_test
ep_dbg_test
Dbg
Dbg
25
{		ep_dbg_printf("gdp_event_cb: ");		ep_prflags(events, EventWhatFlags, ep_dbg_getfile());		ep_dbg_printf(", fd=%d , errno=%d\n",				bufferevent_getfd(bev), EVUTIL_SOCKET_ERROR());	}
ep_dbg_printf("gdp_event_cb: ");
ep_dbg_printf("gdp_event_cb: ")
ep_dbg_printf
ep_dbg_printf
"gdp_event_cb: "
ep_prflags(events, EventWhatFlags, ep_dbg_getfile());
ep_prflags(events, EventWhatFlags, ep_dbg_getfile())
ep_prflags
ep_prflags
events
events
EventWhatFlags
EventWhatFlags
ep_dbg_getfile()
ep_dbg_getfile
ep_dbg_getfile
ep_dbg_printf(", fd=%d , errno=%d\n",				bufferevent_getfd(bev), EVUTIL_SOCKET_ERROR());
ep_dbg_printf(", fd=%d , errno=%d\n",				bufferevent_getfd(bev), EVUTIL_SOCKET_ERROR())
ep_dbg_printf
ep_dbg_printf
", fd=%d , errno=%d\n"
bufferevent_getfd(bev)
bufferevent_getfd
bufferevent_getfd
bev
bev
EVUTIL_SOCKET_ERROR()
EVUTIL_SOCKET_ERROR
EVUTIL_SOCKET_ERROR
EP_ASSERT(bev == chan->bev);
EP_ASSERT(bev == chan->bev)
EP_ASSERT
EP_ASSERT
bev == chan->bev
bev
bev
chan->bev
chan
chan
bev
if (EP_UT_BITSET(BEV_EVENT_CONNECTED, events))	{		// sometimes libevent says we're connected when we're not		if (EVUTIL_SOCKET_ERROR() == ECONNREFUSED)			chan->state = GDP_CHAN_ERROR;		else			chan->state = GDP_CHAN_CONNECTED;		ep_thr_cond_broadcast(&chan->cond);	}
EP_UT_BITSET(BEV_EVENT_CONNECTED, events)
EP_UT_BITSET
EP_UT_BITSET
BEV_EVENT_CONNECTED
BEV_EVENT_CONNECTED
events
events
{		// sometimes libevent says we're connected when we're not		if (EVUTIL_SOCKET_ERROR() == ECONNREFUSED)			chan->state = GDP_CHAN_ERROR;		else			chan->state = GDP_CHAN_CONNECTED;		ep_thr_cond_broadcast(&chan->cond);	}
if (EVUTIL_SOCKET_ERROR() == ECONNREFUSED)			chan->state = GDP_CHAN_ERROR;		else			chan->state = GDP_CHAN_CONNECTED;
EVUTIL_SOCKET_ERROR() == ECONNREFUSED
EVUTIL_SOCKET_ERROR()
EVUTIL_SOCKET_ERROR
EVUTIL_SOCKET_ERROR
ECONNREFUSED
ECONNREFUSED
chan->state = GDP_CHAN_ERROR;
chan->state = GDP_CHAN_ERROR
chan->state
chan
chan
state
GDP_CHAN_ERROR
GDP_CHAN_ERROR
chan->state = GDP_CHAN_CONNECTED;
chan->state = GDP_CHAN_CONNECTED
chan->state
chan
chan
state
GDP_CHAN_CONNECTED
GDP_CHAN_CONNECTED
ep_thr_cond_broadcast(&chan->cond);
ep_thr_cond_broadcast(&chan->cond)
ep_thr_cond_broadcast
ep_thr_cond_broadcast
&chan->cond
chan->cond
chan
chan
cond
if (EP_UT_BITSET(BEV_EVENT_EOF, events))	{		gdp_buf_t *ievb = bufferevent_get_input(bev);		size_t l = gdp_buf_getlength(ievb);		ep_dbg_cprintf(Dbg, 1, "_gdp_event_cb: got EOF, %zu bytes left\n", l);		restart_connection = true;	}
EP_UT_BITSET(BEV_EVENT_EOF, events)
EP_UT_BITSET
EP_UT_BITSET
BEV_EVENT_EOF
BEV_EVENT_EOF
events
events
{		gdp_buf_t *ievb = bufferevent_get_input(bev);		size_t l = gdp_buf_getlength(ievb);		ep_dbg_cprintf(Dbg, 1, "_gdp_event_cb: got EOF, %zu bytes left\n", l);		restart_connection = true;	}
gdp_buf_t *ievb = bufferevent_get_input(bev);
gdp_buf_t *ievb = bufferevent_get_input(bev);
gdp_buf_t
gdp_buf_t
*ievb = bufferevent_get_input(bev)
*
ievb
= bufferevent_get_input(bev)
bufferevent_get_input(bev)
bufferevent_get_input
bufferevent_get_input
bev
bev
size_t l = gdp_buf_getlength(ievb);
size_t l = gdp_buf_getlength(ievb);
size_t
size_t
l = gdp_buf_getlength(ievb)
l
= gdp_buf_getlength(ievb)
gdp_buf_getlength(ievb)
gdp_buf_getlength
gdp_buf_getlength
ievb
ievb
ep_dbg_cprintf(Dbg, 1, "_gdp_event_cb: got EOF, %zu bytes left\n", l);
ep_dbg_cprintf(Dbg, 1, "_gdp_event_cb: got EOF, %zu bytes left\n", l)
ep_dbg_cprintf
ep_dbg_cprintf
Dbg
Dbg
1
"_gdp_event_cb: got EOF, %zu bytes left\n"
l
l
restart_connection = true;
restart_connection = true
restart_connection
restart_connection
true
if (EP_UT_BITSET(BEV_EVENT_ERROR, events))	{		int sockerr = EVUTIL_SOCKET_ERROR();		ep_dbg_cprintf(Dbg, 1, "_gdp_event_cb: error: %s\n",				evutil_socket_error_to_string(sockerr));		restart_connection = true;	}
EP_UT_BITSET(BEV_EVENT_ERROR, events)
EP_UT_BITSET
EP_UT_BITSET
BEV_EVENT_ERROR
BEV_EVENT_ERROR
events
events
{		int sockerr = EVUTIL_SOCKET_ERROR();		ep_dbg_cprintf(Dbg, 1, "_gdp_event_cb: error: %s\n",				evutil_socket_error_to_string(sockerr));		restart_connection = true;	}
int sockerr = EVUTIL_SOCKET_ERROR();
int sockerr = EVUTIL_SOCKET_ERROR();
int
sockerr = EVUTIL_SOCKET_ERROR()
sockerr
= EVUTIL_SOCKET_ERROR()
EVUTIL_SOCKET_ERROR()
EVUTIL_SOCKET_ERROR
EVUTIL_SOCKET_ERROR
ep_dbg_cprintf(Dbg, 1, "_gdp_event_cb: error: %s\n",				evutil_socket_error_to_string(sockerr));
ep_dbg_cprintf(Dbg, 1, "_gdp_event_cb: error: %s\n",				evutil_socket_error_to_string(sockerr))
ep_dbg_cprintf
ep_dbg_cprintf
Dbg
Dbg
1
"_gdp_event_cb: error: %s\n"
evutil_socket_error_to_string(sockerr)
evutil_socket_error_to_string
evutil_socket_error_to_string
sockerr
sockerr
restart_connection = true;
restart_connection = true
restart_connection
restart_connection
true
if (restart_connection)	{		EP_STAT estat;		chan->state = GDP_CHAN_ERROR;		ep_thr_cond_broadcast(&chan->cond);		//_gdp_chan_close(pchan);		do		{			long delay = ep_adm_getlongparam("swarm.gdp.reconnect.delay", 1000L);			if (delay > 0)				ep_time_nanosleep(delay * INT64_C(1000000));			estat = _gdp_chan_open(NULL, NULL, pchan);		} while (!EP_STAT_ISOK(estat));		(*chan->advertise)(GDP_CMD_ADVERTISE);	}
restart_connection
restart_connection
{		EP_STAT estat;		chan->state = GDP_CHAN_ERROR;		ep_thr_cond_broadcast(&chan->cond);		//_gdp_chan_close(pchan);		do		{			long delay = ep_adm_getlongparam("swarm.gdp.reconnect.delay", 1000L);			if (delay > 0)				ep_time_nanosleep(delay * INT64_C(1000000));			estat = _gdp_chan_open(NULL, NULL, pchan);		} while (!EP_STAT_ISOK(estat));		(*chan->advertise)(GDP_CMD_ADVERTISE);	}
EP_STAT estat;
EP_STAT estat;
EP_STAT
EP_STAT
estat
estat
chan->state = GDP_CHAN_ERROR;
chan->state = GDP_CHAN_ERROR
chan->state
chan
chan
state
GDP_CHAN_ERROR
GDP_CHAN_ERROR
ep_thr_cond_broadcast(&chan->cond);
ep_thr_cond_broadcast(&chan->cond)
ep_thr_cond_broadcast
ep_thr_cond_broadcast
&chan->cond
chan->cond
chan
chan
cond
do		{			long delay = ep_adm_getlongparam("swarm.gdp.reconnect.delay", 1000L);			if (delay > 0)				ep_time_nanosleep(delay * INT64_C(1000000));			estat = _gdp_chan_open(NULL, NULL, pchan);		} while (!EP_STAT_ISOK(estat));
{			long delay = ep_adm_getlongparam("swarm.gdp.reconnect.delay", 1000L);			if (delay > 0)				ep_time_nanosleep(delay * INT64_C(1000000));			estat = _gdp_chan_open(NULL, NULL, pchan);		}
long delay = ep_adm_getlongparam("swarm.gdp.reconnect.delay", 1000L);
long delay = ep_adm_getlongparam("swarm.gdp.reconnect.delay", 1000L);
long
delay = ep_adm_getlongparam("swarm.gdp.reconnect.delay", 1000L)
delay
= ep_adm_getlongparam("swarm.gdp.reconnect.delay", 1000L)
ep_adm_getlongparam("swarm.gdp.reconnect.delay", 1000L)
ep_adm_getlongparam
ep_adm_getlongparam
"swarm.gdp.reconnect.delay"
1000L
if (delay > 0)				ep_time_nanosleep(delay * INT64_C(1000000));
delay > 0
delay
delay
0
ep_time_nanosleep(delay * INT64_C(1000000));
ep_time_nanosleep(delay * INT64_C(1000000))
ep_time_nanosleep
ep_time_nanosleep
delay * INT64_C(1000000)
delay
delay
INT64_C(1000000)
INT64_C
INT64_C
1000000
estat = _gdp_chan_open(NULL, NULL, pchan);
estat = _gdp_chan_open(NULL, NULL, pchan)
estat
estat
_gdp_chan_open(NULL, NULL, pchan)
_gdp_chan_open
_gdp_chan_open
NULL
NULL
NULL
NULL
pchan
pchan
!EP_STAT_ISOK(estat)
EP_STAT_ISOK(estat)
EP_STAT_ISOK
EP_STAT_ISOK
estat
estat
(*chan->advertise)(GDP_CMD_ADVERTISE);
(*chan->advertise)(GDP_CMD_ADVERTISE)
(*chan->advertise)
*chan->advertise
chan->advertise
chan
chan
advertise
GDP_CMD_ADVERTISE
GDP_CMD_ADVERTISE
-----joern-----
(82,48,0)
(27,32,0)
(12,53,0)
(131,93,0)
(101,139,0)
(66,30,0)
(87,48,0)
(123,32,0)
(114,112,0)
(43,74,0)
(97,52,0)
(60,86,0)
(66,82,0)
(108,45,0)
(100,67,0)
(67,81,0)
(39,59,0)
(140,12,0)
(47,66,0)
(79,25,0)
(65,31,0)
(8,82,0)
(21,14,0)
(112,68,0)
(20,144,0)
(64,13,0)
(1,6,0)
(146,106,0)
(50,117,0)
(23,106,0)
(44,108,0)
(142,126,0)
(138,104,0)
(145,39,0)
(69,106,0)
(122,20,0)
(68,45,0)
(137,88,0)
(11,69,0)
(125,104,0)
(9,65,0)
(13,132,0)
(73,51,0)
(25,117,0)
(6,67,0)
(84,106,0)
(135,66,0)
(33,5,0)
(49,13,0)
(68,112,0)
(61,68,0)
(13,143,0)
(78,14,0)
(30,66,0)
(10,106,0)
(63,139,0)
(24,53,0)
(139,101,0)
(46,25,0)
(36,24,0)
(132,13,0)
(0,14,0)
(134,138,0)
(54,20,0)
(90,42,0)
(18,104,0)
(122,26,0)
(88,143,0)
(24,43,0)
(94,5,0)
(71,93,0)
(75,43,0)
(119,98,0)
(15,45,0)
(144,20,0)
(43,24,0)
(32,6,0)
(22,31,0)
(139,63,0)
(55,93,0)
(26,124,0)
(105,98,0)
(121,101,0)
(93,26,0)
(31,48,0)
(37,138,0)
(17,124,0)
(51,41,0)
(7,106,0)
(98,105,0)
(45,108,0)
(91,69,0)
(45,106,0)
(72,135,0)
(99,58,0)
(26,122,0)
(96,104,0)
(144,74,0)
(115,106,0)
(101,45,0)
(39,106,0)
(93,124,0)
(113,134,0)
(4,136,0)
(62,26,0)
(78,84,0)
(13,53,0)
(25,45,0)
(51,31,0)
(65,39,0)
(133,124,0)
(84,78,0)
(76,106,0)
(41,51,0)
(24,35,0)
(77,101,0)
(89,88,0)
(14,45,0)
(116,82,0)
(102,81,0)
(28,58,0)
(129,134,0)
(32,81,0)
(127,93,0)
(35,24,0)
(58,143,0)
(110,106,0)
(103,144,0)
(29,42,0)
(6,32,0)
(86,143,0)
(107,86,0)
(108,39,0)
(114,52,0)
(2,96,0)
(66,135,0)
(112,114,0)
(78,74,0)
(90,45,0)
(141,48,0)
(31,65,0)
(80,65,0)
(130,57,0)
(57,124,0)
(63,104,0)
(111,39,0)
(67,95,0)
(83,122,0)
(19,68,0)
(126,82,0)
(85,65,0)
(120,106,0)
(134,45,0)
(92,8,0)
(95,67,0)
(136,81,0)
(20,124,0)
(14,78,0)
(128,78,0)
(70,90,0)
(56,32,0)
(40,8,0)
(109,126,0)
(118,57,0)
(34,136,0)
(16,90,0)
(82,126,0)
(79,98,1)
(73,31,1)
(123,27,1)
(114,112,1)
(70,16,1)
(51,31,1)
(128,24,1)
(117,50,1)
(30,66,1)
(27,67,1)
(64,49,1)
(122,20,1)
(22,8,1)
(101,77,1)
(145,111,1)
(39,59,1)
(1,56,1)
(63,139,1)
(137,89,1)
(2,41,1)
(51,73,1)
(88,137,1)
(0,21,1)
(57,118,1)
(16,98,1)
(32,6,1)
(95,100,1)
(139,101,1)
(24,43,1)
(78,14,1)
(46,79,1)
(45,108,1)
(44,15,1)
(3,136,1)
(90,45,1)
(118,130,1)
(60,107,1)
(61,117,1)
(130,93,1)
(108,44,1)
(96,2,1)
(119,105,1)
(94,45,1)
(15,39,1)
(49,12,1)
(109,142,1)
(55,71,1)
(8,82,1)
(89,114,1)
(111,69,1)
(122,83,1)
(86,143,1)
(90,70,1)
(77,121,1)
(72,47,1)
(135,72,1)
(69,11,1)
(61,42,1)
(29,90,1)
(82,126,1)
(33,94,1)
(112,68,1)
(65,9,1)
(105,86,1)
(31,65,1)
(144,74,1)
(84,78,1)
(13,143,1)
(28,99,1)
(40,82,1)
(25,46,1)
(75,36,1)
(36,13,1)
(68,19,1)
(116,63,1)
(116,41,1)
(92,40,1)
(54,88,1)
(98,119,1)
(38,3,1)
(129,3,1)
(89,86,1)
(14,0,1)
(9,85,1)
(24,35,1)
(5,33,1)
(136,4,1)
(35,43,1)
(19,61,1)
(65,39,1)
(131,26,1)
(58,143,1)
(66,82,1)
(85,80,1)
(38,96,1)
(121,138,1)
(138,37,1)
(25,45,1)
(99,57,1)
(100,58,1)
(43,74,1)
(126,109,1)
(41,51,1)
(47,8,1)
(99,88,1)
(37,134,1)
(13,132,1)
(93,26,1)
(78,74,1)
(20,144,1)
(39,145,1)
(108,39,1)
(113,129,1)
(11,91,1)
(12,140,1)
(67,95,1)
(142,116,1)
(101,45,1)
(144,103,1)
(132,64,1)
(83,62,1)
(22,30,1)
(127,55,1)
(6,67,1)
(134,45,1)
(4,34,1)
(80,22,1)
(42,29,1)
(62,20,1)
(66,135,1)
(88,143,1)
(43,75,1)
(98,105,1)
(68,45,1)
(50,25,1)
(134,113,1)
(58,28,1)
(6,1,1)
(56,123,1)
(107,84,1)
(86,60,1)
(3,58,1)
(140,5,1)
(21,128,1)
(128,5,1)
(8,92,1)
(93,127,1)
(14,45,1)
(26,122,1)
(71,131,1)
(34,32,1)
(103,54,1)
(56,58,2)
(31,65,2)
(58,143,2)
(126,3,2)
(24,5,2)
(35,5,2)
(24,35,2)
(100,58,2)
(95,58,2)
(75,5,2)
(121,3,2)
(117,98,2)
(85,41,2)
(93,88,2)
(134,45,2)
(65,41,2)
(6,58,2)
(131,88,2)
(109,3,2)
(65,3,2)
(62,88,2)
(8,82,2)
(135,8,2)
(42,98,2)
(45,108,2)
(20,144,2)
(138,3,2)
(101,3,2)
(108,39,2)
(32,6,2)
(78,74,2)
(47,8,2)
(26,122,2)
(82,41,2)
(130,88,2)
(2,3,2)
(70,98,2)
(24,43,2)
(66,135,2)
(1,58,2)
(41,3,2)
(46,98,2)
(85,3,2)
(49,5,2)
(127,88,2)
(77,3,2)
(63,139,2)
(122,88,2)
(136,58,2)
(96,3,2)
(31,41,2)
(29,98,2)
(13,5,2)
(25,45,2)
(109,41,2)
(51,41,2)
(16,98,2)
(92,41,2)
(61,86,2)
(80,3,2)
(84,78,2)
(34,58,2)
(13,132,2)
(65,39,2)
(71,88,2)
(73,3,2)
(66,82,2)
(132,5,2)
(19,86,2)
(98,86,2)
(144,88,2)
(4,58,2)
(63,3,2)
(101,45,2)
(140,5,2)
(41,51,2)
(43,5,2)
(22,41,2)
(142,3,2)
(88,143,2)
(66,8,2)
(129,3,2)
(6,67,2)
(139,101,2)
(51,31,2)
(68,86,2)
(116,3,2)
(82,126,2)
(98,105,2)
(26,88,2)
(113,3,2)
(41,41,2)
(12,5,2)
(30,8,2)
(90,98,2)
(67,95,2)
(25,98,2)
(27,58,2)
(68,45,2)
(142,41,2)
(31,3,2)
(51,3,2)
(8,3,2)
(50,98,2)
(83,88,2)
(40,3,2)
(8,41,2)
(114,86,2)
(39,59,2)
(79,98,2)
(64,5,2)
(90,45,2)
(36,5,2)
(80,41,2)
(82,3,2)
(67,58,2)
(73,41,2)
(22,3,2)
(93,26,2)
(144,74,2)
(30,66,2)
(118,88,2)
(126,41,2)
(40,41,2)
(54,88,2)
(55,88,2)
(122,20,2)
(139,3,2)
(13,143,2)
(78,14,2)
(32,58,2)
(119,86,2)
(72,8,2)
(86,143,2)
(43,74,2)
(112,68,2)
(123,58,2)
(14,45,2)
(114,112,2)
(37,3,2)
(116,41,2)
(112,86,2)
(103,88,2)
(105,86,2)
(20,88,2)
(57,88,2)
(9,3,2)
(134,3,2)
(92,3,2)
(9,41,2)
-----------------------------------
(0,bev)
(1,sockerr)
(2,GDP_CMD_ADVERTISE)
(3,restart_connection)
(4,true)
(5,ep_dbg_test(Dbg, 25)
(6,evutil_socket_error_to_string(sockerr)
(7,if (EP_UT_BITSET(BEV_EVENT_EOF, events)
(8,delay > 0)
(9,pchan)
(10,if (ep_dbg_test(Dbg, 25)
(11,false)
(12,ep_dbg_printf("gdp_event_cb: ")
(13,ep_prflags(events, EventWhatFlags, ep_dbg_getfile()
(14,chan->bev)
(15,chan)
(16,chan)
(17,ievb)
(18,estat)
(19,cond)
(20,*ievb = bufferevent_get_input(bev)
(21,chan)
(22,estat)
(23,restart_connection)
(24,ep_dbg_printf(", fd=%d , errno=%d\\n",\n\\n\\t\\t\\t\\tbufferevent_getfd(bev)
(25,chan->state)
(26,l = gdp_buf_getlength(ievb)
(27,Dbg)
(28,events)
(29,GDP_CHAN_ERROR)
(30,ep_time_nanosleep(delay * INT64_C(1000000)
(31,estat = _gdp_chan_open(NULL, NULL, pchan)
(32,ep_dbg_cprintf(Dbg, 1, "_gdp_event_cb: error: %s\\n",\n\\n\\t\\t\\t\\tevutil_socket_error_to_string(sockerr)
(33,25)
(34,restart_connection)
(35,EVUTIL_SOCKET_ERROR()
(36,", fd=%d , errno=%d\\n")
(37,GDP_CHAN_ERROR)
(38,RET)
(39,**pchan = ctx)
(40,delay)
(41,!EP_STAT_ISOK(estat)
(42,chan->state = GDP_CHAN_ERROR)
(43,bufferevent_getfd(bev)
(44,pchan)
(45,*chan = *pchan)
(46,state)
(47,delay)
(48,)
(49,events)
(50,GDP_CHAN_CONNECTED)
(51,EP_STAT_ISOK(estat)
(52,)
(53,)
(54,ievb)
(55,"_gdp_event_cb: got EOF, %zu bytes left\\n")
(56,"_gdp_event_cb: error: %s\\n")
(57,restart_connection = true)
(58,EP_UT_BITSET(BEV_EVENT_ERROR, events)
(59,void *ctx)
(60,events)
(61,chan)
(62,l)
(63,ep_thr_cond_broadcast(&chan->cond)
(64,EventWhatFlags)
(65,_gdp_chan_open(NULL, NULL, pchan)
(66,delay * INT64_C(1000000)
(67,sockerr = EVUTIL_SOCKET_ERROR()
(68,chan->cond)
(69,restart_connection = false)
(70,state)
(71,1)
(72,1000000)
(73,estat)
(74,struct bufferevent *bev)
(75,bev)
(76,chan)
(77,cond)
(78,bev == chan->bev)
(79,chan)
(80,NULL)
(81,)
(82,delay = ep_adm_getlongparam("swarm.gdp.reconnect.delay", 1000L)
(83,ievb)
(84,EP_ASSERT(bev == chan->bev)
(85,NULL)
(86,EP_UT_BITSET(BEV_EVENT_CONNECTED, events)
(87,if (delay > 0)
(88,EP_UT_BITSET(BEV_EVENT_EOF, events)
(89,BEV_EVENT_EOF)
(90,chan->state)
(91,restart_connection)
(92,0)
(93,ep_dbg_cprintf(Dbg, 1, "_gdp_event_cb: got EOF, %zu bytes left\\n", l)
(94,Dbg)
(95,EVUTIL_SOCKET_ERROR()
(96,(*chan->advertise)
(97,if (EVUTIL_SOCKET_ERROR()
(98,EVUTIL_SOCKET_ERROR()
(99,BEV_EVENT_ERROR)
(100,sockerr)
(101,chan->cond)
(102,sockerr)
(103,bev)
(104,)
(105,EVUTIL_SOCKET_ERROR()
(106,)
(107,BEV_EVENT_CONNECTED)
(108,*pchan)
(109,1000L)
(110,if (EP_UT_BITSET(BEV_EVENT_ERROR, events)
(111,pchan)
(112,&chan->cond)
(113,state)
(114,ep_thr_cond_broadcast(&chan->cond)
(115,if (EP_UT_BITSET(BEV_EVENT_CONNECTED, events)
(116,delay)
(117,chan->state = GDP_CHAN_CONNECTED)
(118,true)
(119,ECONNREFUSED)
(120,pchan)
(121,chan)
(122,gdp_buf_getlength(ievb)
(123,1)
(124,)
(125,do)
(126,ep_adm_getlongparam("swarm.gdp.reconnect.delay", 1000L)
(127,l)
(128,bev)
(129,chan)
(130,restart_connection)
(131,Dbg)
(132,ep_dbg_getfile()
(133,l)
(134,chan->state)
(135,INT64_C(1000000)
(136,restart_connection = true)
(137,events)
(138,chan->state = GDP_CHAN_ERROR)
(139,&chan->cond)
(140,"gdp_event_cb: ")
(141,delay)
(142,"swarm.gdp.reconnect.delay")
(143,short events)
(144,bufferevent_get_input(bev)
(145,ctx)
(146,if (restart_connection)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^