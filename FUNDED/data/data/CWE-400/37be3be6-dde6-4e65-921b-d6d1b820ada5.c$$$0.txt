-----label-----
1
-----code-----
static int login_exec(struct ast_channel *chan, const char *data)
{
	int res=0;
	int tries = 0;
	int max_login_tries = maxlogintries;
	struct agent_pvt *p;
	struct ast_module_user *u;
	char user[AST_MAX_AGENT] = "";
	char pass[AST_MAX_AGENT];
	char agent[AST_MAX_AGENT] = "";
	char xpass[AST_MAX_AGENT] = "";
	char *errmsg;
	char *parse;
	AST_DECLARE_APP_ARGS(args,
			     AST_APP_ARG(agent_id);
			     AST_APP_ARG(options);
			     AST_APP_ARG(extension);
		);
	const char *tmpoptions = NULL;
	int play_announcement = 1;
	char agent_goodbye[AST_MAX_FILENAME_LEN];
	int update_cdr = updatecdr;
	char *filename = "agent-loginok";

	u = ast_module_user_add(chan);

	parse = ast_strdupa(data);

	AST_STANDARD_APP_ARGS(args, parse);

	ast_copy_string(agent_goodbye, agentgoodbye, sizeof(agent_goodbye));

	ast_channel_lock(chan);
	/* Set Channel Specific Login Overrides */
	if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTLMAXLOGINTRIES"))) {
		max_login_tries = atoi(pbx_builtin_getvar_helper(chan, "AGENTMAXLOGINTRIES"));
		if (max_login_tries < 0)
			max_login_tries = 0;
		tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTMAXLOGINTRIES");
		ast_verb(3, "Saw variable AGENTMAXLOGINTRIES=%s, setting max_login_tries to: %d on Channel '%s'.\n",tmpoptions,max_login_tries,ast_channel_name(chan));
	}
	if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR"))) {
		if (ast_true(pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR")))
			update_cdr = 1;
		else
			update_cdr = 0;
		tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR");
		ast_verb(3, "Saw variable AGENTUPDATECDR=%s, setting update_cdr to: %d on Channel '%s'.\n",tmpoptions,update_cdr,ast_channel_name(chan));
	}
	if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTGOODBYE"))) {
		strcpy(agent_goodbye, pbx_builtin_getvar_helper(chan, "AGENTGOODBYE"));
		tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTGOODBYE");
		ast_verb(3, "Saw variable AGENTGOODBYE=%s, setting agent_goodbye to: %s on Channel '%s'.\n",tmpoptions,agent_goodbye,ast_channel_name(chan));
	}
	ast_channel_unlock(chan);
	/* End Channel Specific Login Overrides */

	if (!ast_strlen_zero(args.options)) {
		if (strchr(args.options, 's')) {
			play_announcement = 0;
		}
	}

	if (ast_channel_state(chan) != AST_STATE_UP)
		res = ast_answer(chan);
	if (!res) {
		if (!ast_strlen_zero(args.agent_id))
			ast_copy_string(user, args.agent_id, AST_MAX_AGENT);
		else
			res = ast_app_getdata(chan, "agent-user", user, sizeof(user) - 1, 0);
	}
	while (!res && (max_login_tries==0 || tries < max_login_tries)) {
		tries++;
		/* Check for password */
		AST_LIST_LOCK(&agents);
		AST_LIST_TRAVERSE(&agents, p, list) {
			if (!strcmp(p->agent, user) && !p->pending)
				ast_copy_string(xpass, p->password, sizeof(xpass));
		}
		AST_LIST_UNLOCK(&agents);
		if (!res) {
			if (!ast_strlen_zero(xpass))
				res = ast_app_getdata(chan, "agent-pass", pass, sizeof(pass) - 1, 0);
			else
				pass[0] = '\0';
		}
		errmsg = "agent-incorrect";

#if 0
		ast_log(LOG_NOTICE, "user: %s, pass: %s\n", user, pass);
#endif

		/* Check again for accuracy */
		AST_LIST_LOCK(&agents);
		AST_LIST_TRAVERSE(&agents, p, list) {
			int unlock_channel = 1;
			ast_channel_lock(chan);
			ast_mutex_lock(&p->lock);
			if (!strcmp(p->agent, user) &&
			    !strcmp(p->password, pass) && !p->pending) {

				/* Ensure we can't be gotten until we're done */
				p->lastdisc = ast_tvnow();
				p->lastdisc.tv_sec++;

				/* Set Channel Specific Agent Overrides */
				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))) {
					if (ast_true(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))) {
						p->ackcall = 1;
					} else {
						p->ackcall = 0;
					}
					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTACKCALL");
					ast_verb(3, "Saw variable AGENTACKCALL=%s, setting ackcall to: %d for Agent '%s'.\n", tmpoptions, p->ackcall, p->agent);
					ast_set_flag(p, AGENT_FLAG_ACKCALL);
				} else {
					p->ackcall = ackcall;
				}
				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"))) {
					p->autologoff = atoi(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"));
					if (p->autologoff < 0)
						p->autologoff = 0;
					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF");
					ast_verb(3, "Saw variable AGENTAUTOLOGOFF=%s, setting autologff to: %d for Agent '%s'.\n", tmpoptions, p->autologoff, p->agent);
					ast_set_flag(p, AGENT_FLAG_AUTOLOGOFF);
				} else {
					p->autologoff = autologoff;
				}
				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"))) {
					p->wrapuptime = atoi(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"));
					if (p->wrapuptime < 0)
						p->wrapuptime = 0;
					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME");
					ast_verb(3, "Saw variable AGENTWRAPUPTIME=%s, setting wrapuptime to: %d for Agent '%s'.\n", tmpoptions, p->wrapuptime, p->agent);
					ast_set_flag(p, AGENT_FLAG_WRAPUPTIME);
				} else {
					p->wrapuptime = wrapuptime;
				}
				tmpoptions = pbx_builtin_getvar_helper(chan, "AGENTACCEPTDTMF");
				if (!ast_strlen_zero(tmpoptions)) {
					p->acceptdtmf = *tmpoptions;
					ast_verb(3, "Saw variable AGENTACCEPTDTMF=%s, setting acceptdtmf to: %c for Agent '%s'.\n", tmpoptions, p->acceptdtmf, p->agent);
					ast_set_flag(p, AGENT_FLAG_ACCEPTDTMF);
				}
				tmpoptions = pbx_builtin_getvar_helper(chan, "AGENTENDDTMF");
				if (!ast_strlen_zero(tmpoptions)) {
					p->enddtmf = *tmpoptions;
					ast_verb(3, "Saw variable AGENTENDDTMF=%s, setting enddtmf to: %c for Agent '%s'.\n", tmpoptions, p->enddtmf, p->agent);
					ast_set_flag(p, AGENT_FLAG_ENDDTMF);
				}
				ast_channel_unlock(chan);
				unlock_channel = 0;
				/* End Channel Specific Agent Overrides */
				if (!p->chan) {
					long logintime;
					snprintf(agent, sizeof(agent), "Agent/%s", p->agent);

					p->logincallerid[0] = '\0';
					p->acknowledged = 0;

					ast_mutex_unlock(&p->lock);
					AST_LIST_UNLOCK(&agents);
					if( !res && play_announcement==1 )
						res = ast_streamfile(chan, filename, ast_channel_language(chan));
					if (!res)
						ast_waitstream(chan, "");
					AST_LIST_LOCK(&agents);
					ast_mutex_lock(&p->lock);
					if (!res) {
						struct ast_format tmpfmt;
						res = ast_set_read_format_from_cap(chan, ast_channel_nativeformats(chan));
						if (res) {
							ast_log(LOG_WARNING, "Unable to set read format to %s\n", ast_getformatname(&tmpfmt));
						}
					}
					if (!res) {
						struct ast_format tmpfmt;
						res = ast_set_write_format_from_cap(chan, ast_channel_nativeformats(chan));
						if (res) {
							ast_log(LOG_WARNING, "Unable to set write format to %s\n", ast_getformatname(&tmpfmt));
						}
					}
					/* Check once more just in case */
					if (p->chan)
						res = -1;
					if (!res) {
						ast_indicate_data(chan, AST_CONTROL_HOLD,
							S_OR(p->moh, NULL),
							!ast_strlen_zero(p->moh) ? strlen(p->moh) + 1 : 0);
						if (p->loginstart == 0)
							time(&p->loginstart);
						/*** DOCUMENTATION
							<managerEventInstance>
								<synopsis>Raised when an Agent has logged in.</synopsis>
								<syntax>
									<parameter name="Agent">
										<para>The name of the agent.</para>
									</parameter>
								</syntax>
								<see-also>
									<ref type="application">AgentLogin</ref>
									<ref type="managerEvent">Agentlogoff</ref>
								</see-also>
							</managerEventInstance>
						***/
						manager_event(EVENT_FLAG_AGENT, "Agentlogin",
							      "Agent: %s\r\n"
							      "Channel: %s\r\n"
							      "Uniqueid: %s\r\n",
							      p->agent, ast_channel_name(chan), ast_channel_uniqueid(chan));
						if (update_cdr && ast_channel_cdr(chan))
							snprintf(ast_channel_cdr(chan)->channel, sizeof(ast_channel_cdr(chan)->channel), "Agent/%s", p->agent);
						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGIN", "%s", ast_channel_name(chan));
						ast_verb(2, "Agent '%s' logged in (format %s/%s)\n", p->agent,
								    ast_getformatname(ast_channel_readformat(chan)), ast_getformatname(ast_channel_writeformat(chan)));
						/* Login this channel and wait for it to go away */
						p->chan = chan;
						if (p->ackcall) {
							check_beep(p, 0);
						} else {
							check_availability(p, 0);
						}
						ast_mutex_unlock(&p->lock);
						AST_LIST_UNLOCK(&agents);
						ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);
						while (res >= 0) {
							ast_mutex_lock(&p->lock);
							if (p->deferlogoff && p->chan) {
								ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);
								p->deferlogoff = 0;
							}
							if (p->chan != chan)
								res = -1;
							ast_mutex_unlock(&p->lock);
							/* Yield here so other interested threads can kick in. */
							sched_yield();
							if (res)
								break;

							AST_LIST_LOCK(&agents);
							ast_mutex_lock(&p->lock);
							if (p->lastdisc.tv_sec) {
								if (ast_tvdiff_ms(ast_tvnow(), p->lastdisc) > 0) {
									ast_debug(1, "Wrapup time for %s expired!\n", p->agent);
									p->lastdisc = ast_tv(0, 0);
									ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);
									if (p->ackcall) {
										check_beep(p, 0);
									} else {
										check_availability(p, 0);
									}
								}
							}
							ast_mutex_unlock(&p->lock);
							AST_LIST_UNLOCK(&agents);

							/*	Synchronize channel ownership between call to agent and itself. */
							ast_mutex_lock(&p->lock);
							if (p->app_lock_flag == 1) {
								ast_cond_signal(&p->login_wait_cond);
								ast_cond_wait(&p->app_complete_cond, &p->lock);
							}
							ast_mutex_unlock(&p->lock);
							if (p->ackcall) {
								res = agent_ack_sleep(p);
							} else {
								res = ast_safe_sleep_conditional( chan, 1000, agent_cont_sleep, p );
							}
							if (p->ackcall && (res == 1)) {
								AST_LIST_LOCK(&agents);
								ast_mutex_lock(&p->lock);
								check_availability(p, 0);
								ast_mutex_unlock(&p->lock);
								AST_LIST_UNLOCK(&agents);
								res = 0;
							}
							sched_yield();
						}
						ast_mutex_lock(&p->lock);
						/* Log us off if appropriate */
						if (p->chan == chan) {
							p->chan = NULL;
						}

						/* Synchronize channel ownership between call to agent and itself. */
						if (p->app_lock_flag == 1) {
							ast_cond_signal(&p->login_wait_cond);
							ast_cond_wait(&p->app_complete_cond, &p->lock);
						}

						if (res && p->owner)
							ast_log(LOG_WARNING, "Huh?  We broke out when there was still an owner?\n");

						p->acknowledged = 0;
						logintime = time(NULL) - p->loginstart;
						p->loginstart = 0;
						ast_mutex_unlock(&p->lock);
						/*** DOCUMENTATION
							<managerEventInstance>
								<synopsis>Raised when an Agent has logged off.</synopsis>
								<syntax>
									<xi:include xpointer="xpointer(/docs/managerEvent[@name='Agentlogin']/managerEventInstance/syntax/parameter[@name='Agent'])" />
								</syntax>
								<see-also>
									<ref type="managerEvent">Agentlogin</ref>
								</see-also>
							</managerEventInstance>
						***/
						manager_event(EVENT_FLAG_AGENT, "Agentlogoff",
							      "Agent: %s\r\n"
							      "Logintime: %ld\r\n"
							      "Uniqueid: %s\r\n",
							      p->agent, logintime, ast_channel_uniqueid(chan));
						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGOFF", "%s|%ld", ast_channel_name(chan), logintime);
						ast_verb(2, "Agent '%s' logged out\n", p->agent);
						/* If there is no owner, go ahead and kill it now */
						ast_devstate_changed(AST_DEVICE_UNAVAILABLE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);
						if (p->dead && !p->owner) {
							ast_mutex_destroy(&p->lock);
							ast_cond_destroy(&p->app_complete_cond);
							ast_cond_destroy(&p->login_wait_cond);
							ast_free(p);
						}
					}
					else {
						ast_mutex_unlock(&p->lock);
						p = NULL;
					}
					res = -1;
				} else {
					ast_mutex_unlock(&p->lock);
					errmsg = "agent-alreadyon";
					p = NULL;
				}
				break;
			}
			ast_mutex_unlock(&p->lock);
			if (unlock_channel) {
				ast_channel_unlock(chan);
			}
		}
		if (!p)
			AST_LIST_UNLOCK(&agents);

		if (!res && (max_login_tries==0 || tries < max_login_tries))
			res = ast_app_getdata(chan, errmsg, user, sizeof(user) - 1, 0);
	}

	if (!res)
		res = ast_safe_sleep(chan, 500);

	ast_module_user_remove(u);

 	return -1;
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
5,6
5,7
6,7
8,9
8,10
11,12
11,13
13,14
13,15
16,17
16,18
16,19
16,20
16,21
16,22
16,23
16,24
16,25
16,26
16,27
16,28
16,29
16,30
16,31
16,32
16,33
16,34
16,35
16,36
16,37
16,38
16,39
16,40
16,41
16,42
16,43
16,44
16,45
16,46
16,47
16,48
16,49
16,50
16,51
16,52
17,18
18,19
18,20
20,21
20,22
22,23
24,25
25,26
25,27
27,28
27,29
29,30
31,32
32,33
32,34
34,35
34,36
36,37
37,38
39,40
40,41
40,42
41,42
43,44
43,45
46,47
47,48
47,49
48,49
50,51
50,52
53,54
54,55
54,56
56,57
56,58
56,59
58,59
59,60
61,62
63,64
64,65
64,66
66,67
66,68
68,69
69,70
71,72
72,73
72,74
74,75
74,76
74,77
76,77
77,78
79,80
81,82
82,83
82,84
84,85
84,86
84,87
86,87
87,88
89,90
91,92
92,93
92,94
94,95
94,96
97,98
98,99
98,100
100,101
100,102
103,104
104,105
105,106
105,107
106,107
108,109
109,110
111,112
112,113
112,114
113,114
115,116
116,117
118,119
119,120
120,121
120,122
122,123
122,124
122,125
125,126
126,127
128,129
129,130
129,131
131,132
131,133
133,134
135,136
136,137
136,138
138,139
138,140
140,141
141,142
143,144
144,145
144,146
146,147
146,148
148,149
149,150
151,152
152,153
152,154
154,155
154,156
154,157
157,158
159,160
160,161
160,162
161,162
163,164
163,165
164,165
166,167
168,169
169,170
169,171
170,171
172,173
172,174
173,174
175,176
177,178
178,179
178,180
178,181
179,180
181,182
183,184
185,186
186,187
186,188
186,189
186,190
187,188
189,190
191,192
193,194
194,195
195,196
197,198
198,199
198,200
199,200
201,202
203,204
203,205
204,205
205,206
205,207
206,207
208,209
208,210
208,211
209,210
211,212
214,215
214,216
214,217
214,218
215,216
216,217
216,218
217,218
219,220
219,221
220,221
222,223
222,224
222,225
223,224
225,226
228,229
228,230
229,230
229,231
230,231
233,234
234,235
234,236
235,236
238,239
239,240
239,241
240,241
242,243
242,244
242,245
243,244
245,246
248,249
249,250
249,251
249,252
249,253
249,254
249,255
250,251
254,255
256,257
258,259
258,260
259,260
261,262
263,264
263,265
264,265
265,266
265,267
266,267
268,269
268,270
268,271
269,270
271,272
274,275
274,276
274,277
275,276
275,277
275,278
276,277
276,278
277,278
279,280
279,281
279,282
280,281
282,283
285,286
286,287
286,288
287,288
290,291
291,292
291,293
292,293
295,296
296,297
296,298
297,298
299,300
299,301
299,302
300,301
302,303
305,306
306,307
306,308
306,309
306,310
306,311
306,312
307,308
311,312
313,314
315,316
315,317
316,317
318,319
320,321
320,322
321,322
322,323
322,324
323,324
325,326
325,327
325,328
326,327
328,329
331,332
331,333
331,334
332,333
333,334
333,335
333,336
334,335
336,337
338,339
338,340
338,341
339,340
341,342
344,345
345,346
345,347
346,347
348,349
348,350
348,351
349,350
351,352
354,355
355,356
355,357
355,358
355,359
355,360
355,361
356,357
360,361
362,363
364,365
364,366
365,366
367,368
369,370
370,371
370,372
371,372
373,374
375,376
375,377
376,377
377,378
377,379
378,379
380,381
380,382
381,382
384,385
385,386
385,387
386,387
386,388
386,389
387,388
389,390
389,391
390,391
394,395
395,396
396,397
396,398
397,398
400,401
400,402
401,402
401,403
402,403
402,404
403,404
405,406
407,408
409,410
410,411
410,412
411,412
413,414
413,415
414,415
416,417
418,419
418,420
419,420
420,421
422,423
423,424
423,425
423,426
424,425
425,426
425,427
426,427
428,429
428,430
429,430
432,433
433,434
433,435
433,436
433,437
434,435
436,437
438,439
438,440
439,440
442,443
444,445
445,446
445,447
446,447
448,449
448,450
448,451
448,452
448,453
448,454
449,450
451,452
454,455
456,457
456,458
457,458
458,459
459,460
463,464
463,465
464,465
464,466
465,466
466,467
468,469
469,470
469,471
470,471
470,472
471,472
474,475
474,476
475,476
477,478
479,480
479,481
479,482
479,483
479,484
479,485
479,486
479,487
479,488
479,489
479,490
479,491
479,492
479,493
480,481
481,482
482,483
484,485
485,486
485,487
486,487
488,489
489,490
489,491
492,493
493,494
493,495
493,496
493,497
494,495
496,497
497,498
499,500
501,502
503,504
504,505
505,506
505,507
506,507
506,508
507,508
508,509
508,510
508,511
509,510
511,512
511,513
512,513
515,516
517,518
518,519
518,520
519,520
522,523
523,524
523,525
523,526
523,527
524,525
526,527
528,529
528,530
529,530
532,533
533,534
534,535
536,537
537,538
537,539
538,539
540,541
541,542
543,544
543,545
544,545
545,546
547,548
548,549
548,550
548,551
549,550
550,551
550,552
551,552
553,554
555,556
556,557
556,558
557,558
559,560
559,561
559,562
559,563
559,564
559,565
560,561
562,563
565,566
567,568
567,569
568,569
569,570
570,571
574,575
575,576
575,577
576,577
576,578
577,578
581,582
582,583
582,584
583,584
586,587
587,588
587,589
588,589
590,591
591,592
593,594
594,595
594,596
594,597
594,598
595,596
597,598
598,599
600,601
602,603
604,605
605,606
605,607
605,608
605,609
605,610
605,611
606,607
607,608
607,609
609,610
609,611
611,612
613,614
614,615
614,616
615,616
617,618
619,620
620,621
620,622
621,622
623,624
624,625
624,626
625,626
628,629
628,630
629,630
629,631
630,631
630,632
631,632
632,633
632,634
632,635
633,634
635,636
635,637
636,637
639,640
641,642
642,643
642,644
642,645
643,644
645,646
645,647
646,647
649,650
651,652
652,653
652,654
653,654
656,657
656,658
656,659
656,660
656,661
656,662
656,663
656,664
656,665
656,666
656,667
656,668
656,669
657,658
658,659
658,660
659,660
659,661
660,661
663,664
664,665
666,667
667,668
668,669
668,670
669,670
669,671
670,671
674,675
674,676
674,677
675,676
676,677
676,678
677,678
679,680
679,681
679,682
680,681
682,683
685,686
685,687
685,688
685,689
686,687
686,688
686,689
687,688
687,689
688,689
690,691
690,692
690,693
691,692
693,694
696,697
697,698
698,699
698,700
699,700
699,701
700,701
704,705
705,706
706,707
706,708
707,708
707,709
708,709
712,713
713,714
713,715
714,715
716,717
716,718
716,719
717,718
719,720
722,723
723,724
723,725
723,726
723,727
723,728
723,729
724,725
728,729
730,731
730,732
731,732
734,735
734,736
735,736
738,739
739,740
739,741
739,742
740,741
742,743
744,745
746,747
747,748
748,749
748,750
749,750
749,751
750,751
753,754
755,756
755,757
755,758
756,757
757,758
757,759
758,759
760,761
760,762
760,763
761,762
763,764
766,767
766,768
766,769
766,770
766,771
767,768
768,769
768,770
769,770
769,771
770,771
773,774
773,775
774,775
776,777
776,778
776,779
777,778
779,780
782,783
782,784
783,784
783,785
784,785
784,786
785,786
789,790
790,791
790,792
791,792
791,793
792,793
796,797
797,798
797,799
798,799
800,801
800,802
800,803
801,802
803,804
806,807
807,808
807,809
807,810
807,811
807,812
807,813
808,809
812,813
814,815
814,816
815,816
818,819
818,820
819,820
822,823
823,824
823,825
823,826
824,825
826,827
828,829
830,831
831,832
832,833
832,834
833,834
833,835
834,835
837,838
839,840
839,841
839,842
840,841
841,842
841,843
842,843
844,845
844,846
844,847
845,846
847,848
850,851
850,852
850,853
850,854
850,855
851,852
852,853
852,854
853,854
853,855
854,855
857,858
857,859
858,859
860,861
860,862
860,863
861,862
863,864
866,867
866,868
867,868
867,869
868,869
868,870
869,870
873,874
874,875
874,876
875,876
875,877
876,877
880,881
881,882
881,883
882,883
884,885
884,886
884,887
885,886
887,888
890,891
891,892
891,893
891,894
891,895
891,896
891,897
892,893
896,897
898,899
898,900
899,900
902,903
902,904
903,904
906,907
907,908
907,909
907,910
908,909
910,911
912,913
914,915
915,916
916,917
916,918
917,918
917,919
918,919
921,922
923,924
924,925
924,926
925,926
927,928
927,929
927,930
928,929
930,931
933,934
933,935
934,935
935,936
935,937
936,937
938,939
940,941
940,942
940,943
941,942
942,943
942,944
943,944
943,945
944,945
947,948
948,949
950,951
951,952
951,953
951,954
951,955
951,956
951,957
952,953
956,957
958,959
958,960
959,960
962,963
962,964
963,964
966,967
967,968
967,969
967,970
968,969
970,971
972,973
974,975
975,976
975,977
976,977
978,979
978,980
978,981
979,980
981,982
984,985
984,986
985,986
986,987
986,988
987,988
989,990
991,992
991,993
991,994
992,993
993,994
993,995
994,995
994,996
995,996
998,999
999,1000
1001,1002
1002,1003
1002,1004
1002,1005
1002,1006
1002,1007
1002,1008
1003,1004
1007,1008
1009,1010
1009,1011
1010,1011
1013,1014
1013,1015
1014,1015
1017,1018
1018,1019
1018,1020
1018,1021
1019,1020
1021,1022
1023,1024
1025,1026
1026,1027
1026,1028
1027,1028
1029,1030
1031,1032
1032,1033
1032,1034
1033,1034
1036,1037
1036,1038
1036,1039
1037,1038
1038,1039
1038,1040
1039,1040
1042,1043
1042,1044
1042,1045
1042,1046
1042,1047
1042,1048
1042,1049
1042,1050
1042,1051
1042,1052
1042,1053
1042,1054
1042,1055
1042,1056
1042,1057
1043,1044
1044,1045
1044,1046
1046,1047
1048,1049
1049,1050
1049,1051
1049,1052
1049,1053
1049,1054
1050,1051
1052,1053
1054,1055
1055,1056
1056,1057
1059,1060
1059,1061
1060,1061
1063,1064
1064,1065
1064,1066
1065,1066
1065,1067
1066,1067
1066,1068
1067,1068
1072,1073
1073,1074
1073,1075
1074,1075
1074,1076
1075,1076
1079,1080
1080,1081
1080,1082
1081,1082
1083,1084
1084,1085
1084,1086
1085,1086
1088,1089
1089,1090
1089,1091
1090,1091
1092,1093
1093,1094
1095,1096
1095,1097
1096,1097
1096,1098
1097,1098
1098,1099
1100,1101
1100,1102
1101,1102
1104,1105
1105,1106
1105,1107
1106,1107
1108,1109
1108,1110
1108,1111
1108,1112
1109,1110
1111,1112
1113,1114
1115,1116
1115,1117
1116,1117
1118,1119
1120,1121
1120,1122
1121,1122
1122,1123
1124,1125
1125,1126
1125,1127
1125,1128
1126,1127
1128,1129
1131,1132
1132,1133
1132,1134
1133,1134
1135,1136
1136,1137
1138,1139
1139,1140
1139,1141
1140,1141
1142,1143
1143,1144
1143,1145
1144,1145
1147,1148
1147,1149
1148,1149
1149,1150
1151,1152
1151,1153
1151,1154
1152,1153
1153,1154
1153,1155
1154,1155
1156,1157
1158,1159
1159,1160
1159,1161
1160,1161
1162,1163
1162,1164
1162,1165
1163,1164
1165,1166
1167,1168
1167,1169
1168,1169
1170,1171
1172,1173
1172,1174
1173,1174
1175,1176
1176,1177
1177,1178
1177,1179
1177,1180
1177,1181
1178,1179
1180,1181
1183,1184
1183,1185
1184,1185
1186,1187
1187,1188
1189,1190
1189,1191
1190,1191
1191,1192
1193,1194
1193,1195
1193,1196
1194,1195
1195,1196
1195,1197
1196,1197
1198,1199
1200,1201
1201,1202
1201,1203
1202,1203
1204,1205
1204,1206
1204,1207
1205,1206
1207,1208
1209,1210
1209,1211
1210,1211
1212,1213
1214,1215
1214,1216
1215,1216
1217,1218
1218,1219
1219,1220
1219,1221
1219,1222
1219,1223
1220,1221
1222,1223
1225,1226
1225,1227
1226,1227
1228,1229
1229,1230
1231,1232
1231,1233
1232,1233
1232,1234
1233,1234
1236,1237
1237,1238
1237,1239
1238,1239
1240,1241
1242,1243
1242,1244
1242,1245
1243,1244
1244,1245
1246,1247
1246,1248
1246,1249
1246,1250
1246,1251
1246,1252
1246,1253
1246,1254
1246,1255
1246,1256
1246,1257
1246,1258
1246,1259
1246,1260
1246,1261
1246,1262
1246,1263
1246,1264
1246,1265
1246,1266
1246,1267
1246,1268
1246,1269
1246,1270
1246,1271
1247,1248
1248,1249
1248,1250
1248,1251
1248,1252
1248,1253
1249,1250
1251,1252
1253,1254
1255,1256
1255,1257
1255,1258
1256,1257
1258,1259
1258,1260
1259,1260
1262,1263
1264,1265
1264,1266
1264,1267
1265,1266
1266,1267
1266,1268
1267,1268
1269,1270
1269,1271
1270,1271
1273,1274
1273,1275
1274,1275
1274,1276
1275,1276
1277,1278
1277,1279
1278,1279
1283,1284
1283,1285
1284,1285
1284,1286
1285,1286
1285,1287
1286,1287
1290,1291
1291,1292
1291,1293
1292,1293
1294,1295
1295,1296
1295,1297
1296,1297
1299,1300
1300,1301
1300,1302
1300,1303
1300,1304
1300,1305
1300,1306
1300,1307
1301,1302
1303,1304
1307,1308
1307,1309
1308,1309
1311,1312
1311,1313
1312,1313
1314,1315
1316,1317
1316,1318
1317,1318
1319,1320
1321,1322
1321,1323
1322,1323
1322,1324
1323,1324
1325,1326
1325,1327
1326,1327
1328,1329
1330,1331
1331,1332
1331,1333
1331,1334
1331,1335
1331,1336
1332,1333
1334,1335
1334,1336
1335,1336
1335,1337
1336,1337
1338,1339
1341,1342
1342,1343
1343,1344
1343,1345
1344,1345
1344,1346
1345,1346
1347,1348
1351,1352
1351,1353
1352,1353
1355,1356
1356,1357
1356,1358
1356,1359
1356,1360
1356,1361
1356,1362
1356,1363
1357,1358
1360,1361
1360,1362
1361,1362
1363,1364
1365,1366
1369,1370
1369,1371
1370,1371
1372,1373
1374,1375
1375,1376
1375,1377
1375,1378
1375,1379
1375,1380
1375,1381
1376,1377
1380,1381
1380,1382
1381,1382
1384,1385
1384,1386
1385,1386
1387,1388
1387,1389
1388,1389
1390,1391
1392,1393
1392,1394
1393,1394
1395,1396
1395,1397
1396,1397
1398,1399
1400,1401
1401,1402
1401,1403
1402,1403
1402,1404
1403,1404
1406,1407
1408,1409
1408,1410
1408,1411
1409,1410
1409,1411
1410,1411
1413,1414
1414,1415
1415,1416
1415,1417
1415,1418
1416,1417
1418,1419
1421,1422
1422,1423
1423,1424
1423,1425
1423,1426
1424,1425
1426,1427
1429,1430
1430,1431
1430,1432
1431,1432
1433,1434
1434,1435
1434,1436
1435,1436
1438,1439
1439,1440
1439,1441
1440,1441
1442,1443
1443,1444
1445,1446
1446,1447
1446,1448
1446,1449
1446,1450
1446,1451
1447,1448
1449,1450
1451,1452
1454,1455
1454,1456
1455,1456
1458,1459
1458,1460
1459,1460
1459,1461
1460,1461
1463,1464
1463,1465
1463,1466
1463,1467
1463,1468
1463,1469
1463,1470
1463,1471
1463,1472
1463,1473
1463,1474
1463,1475
1463,1476
1463,1477
1463,1478
1463,1479
1463,1480
1464,1465
1465,1466
1465,1467
1466,1467
1468,1469
1469,1470
1469,1471
1470,1471
1473,1474
1473,1475
1474,1475
1474,1476
1475,1476
1475,1477
1476,1477
1479,1480
1479,1481
1480,1481
1483,1484
1483,1485
1484,1485
1485,1486
1485,1487
1485,1488
1486,1487
1488,1489
1488,1490
1489,1490
1492,1493
1494,1495
1495,1496
1495,1497
1496,1497
1496,1498
1497,1498
1501,1502
1501,1503
1502,1503
1502,1504
1503,1504
1503,1505
1504,1505
1507,1508
1509,1510
1510,1511
1510,1512
1511,1512
1513,1514
1515,1516
1516,1517
1516,1518
1517,1518
1519,1520
1520,1521
1520,1522
1521,1522
1524,1525
1525,1526
1526,1527
1528,1529
1528,1530
1529,1530
1532,1533
1533,1534
1533,1535
1534,1535
1536,1537
1537,1538
1539,1540
1540,1541
1540,1542
1541,1542
1543,1544
1544,1545
1544,1546
1545,1546
1548,1549
1548,1550
1549,1550
1549,1551
1550,1551
1550,1552
1551,1552
1555,1556
1556,1557
1556,1558
1557,1558
1557,1559
1558,1559
1558,1560
1558,1561
1559,1560
1561,1562
1562,1563
1564,1565
1564,1566
1565,1566
1569,1570
1569,1571
1569,1572
1569,1573
1570,1571
1571,1572
1571,1573
1571,1574
1571,1575
1572,1573
1576,1577
1576,1578
1577,1578
1580,1581
1581,1582
1581,1583
1582,1583
1582,1584
1583,1584
1586,1587
1586,1588
1586,1589
1587,1588
1591,1592
1592,1593
1592,1594
1592,1595
1592,1596
1592,1597
1593,1594
1595,1596
1597,1598
1600,1601
1600,1602
1601,1602
1604,1605
1604,1606
1604,1607
1605,1606
1605,1607
1606,1607
1609,1610
1610,1611
1611,1612
1611,1613
1611,1614
1612,1613
1614,1615
1617,1618
1618,1619
1619,1620
1619,1621
1619,1622
1620,1621
1622,1623
1625,1626
1626,1627
1626,1628
1627,1628
1629,1630
1630,1631
1630,1632
1631,1632
1634,1635
1635,1636
1635,1637
1636,1637
1638,1639
1639,1640
1641,1642
1642,1643
1642,1644
1643,1644
1645,1646
1646,1647
1646,1648
1647,1648
1650,1651
1650,1652
1651,1652
1651,1653
1652,1653
1652,1654
1653,1654
1657,1658
1657,1659
1658,1659
1659,1660
1659,1661
1660,1661
1662,1663
1663,1664
1663,1665
1664,1665
1667,1668
1668,1669
1668,1670
1668,1671
1669,1670
1671,1672
1672,1673
1672,1674
1673,1674
1676,1677
1677,1678
1677,1679
1678,1679
1681,1682
1682,1683
1682,1684
1683,1684
1685,1686
1686,1687
1686,1688
1687,1688
1690,1691
1690,1692
1690,1693
1691,1692
1691,1693
1692,1693
1695,1696
1696,1697
1697,1698
1697,1699
1698,1699
1700,1701
1700,1702
1701,1702
1703,1704
1705,1706
1706,1707
1707,1708
1707,1709
1708,1709
1710,1711
1710,1712
1710,1713
1710,1714
1710,1715
1711,1712
1713,1714
1716,1717
1718,1719
1720,1721
1720,1722
1721,1722
1721,1723
1722,1723
1722,1724
1723,1724
1726,1727
1727,1728
1727,1729
1728,1729
1731,1732
1731,1733
1731,1734
1731,1735
1731,1736
1731,1737
1732,1733
1733,1734
1733,1735
1734,1735
1736,1737
1737,1738
1739,1740
1740,1741
1740,1742
1741,1742
1743,1744
1744,1745
1744,1746
1745,1746
1748,1749
1749,1750
1749,1751
1749,1752
1750,1751
1752,1753
1755,1756
1756,1757
1756,1758
1757,1758
1759,1760
1760,1761
1760,1762
1761,1762
1764,1765
1765,1766
1765,1767
1766,1767
1768,1769
1769,1770
1771,1772
1772,1773
1772,1774
1773,1774
1776,1777
1777,1778
1778,1779
1780,1781
1781,1782
1781,1783
1782,1783
1784,1785
1785,1786
1785,1787
1786,1787
1789,1790
1789,1791
1790,1791
1790,1792
1791,1792
1791,1793
1792,1793
1795,1796
1797,1798
1798,1799
1799,1800
1799,1801
1800,1801
1800,1802
1801,1802
1804,1805
1806,1807
1806,1808
1807,1808
1807,1809
1808,1809
1808,1810
1809,1810
1813,1814
1813,1815
1814,1815
1815,1816
1815,1817
1816,1817
1818,1819
1819,1820
1819,1821
1820,1821
1823,1824
1824,1825
1824,1826
1824,1827
1825,1826
1827,1828
1828,1829
1828,1830
1829,1830
1832,1833
1833,1834
1833,1835
1834,1835
1837,1838
1837,1839
1838,1839
1838,1840
1839,1840
1841,1842
1841,1843
1842,1843
1845,1846
1846,1847
1846,1848
1846,1849
1847,1848
1849,1850
1852,1853
1853,1854
1853,1855
1854,1855
1854,1856
1855,1856
1859,1860
1860,1861
1860,1862
1861,1862
1863,1864
1863,1865
1864,1865
1864,1866
1865,1866
1867,1868
1869,1870
1869,1871
1870,1871
1873,1874
1874,1875
1874,1876
1875,1876
1875,1877
1876,1877
1880,1881
1881,1882
1881,1883
1882,1883
1884,1885
1885,1886
1885,1887
1886,1887
1889,1890
1890,1891
1890,1892
1890,1893
1890,1894
1890,1895
1890,1896
1890,1897
1891,1892
1893,1894
1897,1898
1897,1899
1898,1899
1901,1902
1903,1904
1903,1905
1904,1905
1906,1907
1908,1909
1909,1910
1909,1911
1909,1912
1909,1913
1909,1914
1909,1915
1909,1916
1909,1917
1910,1911
1913,1914
1913,1915
1914,1915
1916,1917
1918,1919
1922,1923
1922,1924
1923,1924
1925,1926
1927,1928
1929,1930
1930,1931
1930,1932
1930,1933
1930,1934
1931,1932
1935,1936
1935,1937
1936,1937
1939,1940
1940,1941
1940,1942
1940,1943
1940,1944
1940,1945
1941,1942
1943,1944
1945,1946
1948,1949
1948,1950
1949,1950
1952,1953
1952,1954
1953,1954
1953,1955
1954,1955
1954,1956
1955,1956
1958,1959
1959,1960
1959,1961
1960,1961
1963,1964
1963,1965
1963,1966
1963,1967
1964,1965
1965,1966
1965,1967
1966,1967
1968,1969
1969,1970
1969,1971
1970,1971
1973,1974
1974,1975
1974,1976
1975,1976
1977,1978
1978,1979
1978,1980
1979,1980
1982,1983
1983,1984
1983,1985
1984,1985
1986,1987
1987,1988
1987,1989
1988,1989
1991,1992
1992,1993
1992,1994
1993,1994
1995,1996
1997,1998
1997,1999
1998,1999
1999,2000
1999,2001
2000,2001
2002,2003
2003,2004
2003,2005
2004,2005
2007,2008
2008,2009
2008,2010
2009,2010
2011,2012
2013,2014
2014,2015
2014,2016
2015,2016
2017,2018
2019,2020
2019,2021
2019,2022
2020,2021
2021,2022
2021,2023
2022,2023
2024,2025
2025,2026
2025,2027
2026,2027
2029,2030
2030,2031
2030,2032
2031,2032
2034,2035
2035,2036
2035,2037
2036,2037
2038,2039
2041,2042
2042,2043
2042,2044
2043,2044
2045,2046
2046,2047
2046,2048
2047,2048
2050,2051
2050,2052
2051,2052
2053,2054
2054,2055
2055,2056
2055,2057
2056,2057
2058,2059
2060,2061
2060,2062
2061,2062
2062,2063
2064,2065
2065,2066
2065,2067
2066,2067
2068,2069
2069,2070
2071,2072
2071,2073
2072,2073
2072,2074
2073,2074
2074,2075
2076,2077
2077,2078
2077,2079
2078,2079
2078,2080
2079,2080
2082,2083
2082,2084
2083,2084
2085,2086
2087,2088
2088,2089
2088,2090
2089,2090
2091,2092
2091,2093
2091,2094
2091,2095
2091,2096
2091,2097
2092,2093
2094,2095
2096,2097
2098,2099
2100,2101
2100,2102
2101,2102
2102,2103
2103,2104
2107,2108
2107,2109
2108,2109
2109,2110
2111,2112
2112,2113
2112,2114
2113,2114
2115,2116
2115,2117
2115,2118
2116,2117
2118,2119
2121,2122
2122,2123
2122,2124
2123,2124
2125,2126
2127,2128
2128,2129
-----nextToken-----
2,4,7,9,10,12,14,15,19,21,23,26,28,30,33,35,38,42,44,45,49,51,52,55,57,60,62,65,67,70,73,75,78,80,83,85,88,90,93,95,96,99,101,102,107,110,114,117,121,123,124,127,130,132,134,137,139,142,145,147,150,153,155,156,158,162,165,167,171,174,176,180,182,184,188,190,192,196,200,202,207,210,212,213,218,221,224,226,227,231,232,236,237,241,244,246,247,251,252,253,255,257,260,262,267,270,272,273,278,281,283,284,288,289,293,294,298,301,303,304,308,309,310,312,314,317,319,324,327,329,330,335,337,340,342,343,347,350,352,353,357,358,359,361,363,366,368,372,374,379,382,383,388,391,392,393,398,399,404,406,408,412,415,417,421,427,430,431,435,437,440,441,443,447,450,452,453,455,460,461,462,467,472,473,476,478,483,487,490,491,495,498,500,502,510,513,514,516,520,521,525,527,530,531,535,539,542,546,552,554,558,561,563,564,566,571,572,573,578,579,580,584,585,589,592,596,599,601,603,608,610,612,616,618,622,626,627,634,637,638,640,644,647,648,650,654,655,661,662,665,671,672,673,678,681,683,684,689,692,694,695,701,702,703,709,710,711,715,718,720,721,725,726,727,729,732,733,736,737,741,743,745,751,752,754,759,762,764,765,771,772,775,778,780,781,786,787,788,793,794,795,799,802,804,805,809,810,811,813,816,817,820,821,825,827,829,835,836,838,843,846,848,849,855,856,859,862,864,865,870,871,872,877,878,879,883,886,888,889,893,894,895,897,900,901,904,905,909,911,913,919,920,922,926,929,931,932,937,939,945,946,949,953,954,955,957,960,961,964,965,969,971,973,977,980,982,983,988,990,996,997,1000,1004,1005,1006,1008,1011,1012,1015,1016,1020,1022,1024,1028,1030,1034,1035,1040,1041,1045,1047,1051,1053,1057,1058,1061,1062,1068,1069,1070,1071,1076,1077,1078,1082,1086,1087,1091,1094,1099,1102,1103,1107,1110,1112,1114,1117,1119,1123,1127,1129,1130,1134,1137,1141,1145,1146,1150,1155,1157,1161,1164,1166,1169,1171,1174,1179,1181,1182,1185,1188,1192,1197,1199,1203,1206,1208,1211,1213,1216,1221,1223,1224,1227,1230,1234,1235,1239,1241,1245,1250,1252,1254,1257,1260,1261,1263,1268,1271,1272,1276,1279,1280,1281,1282,1287,1288,1289,1293,1297,1298,1302,1304,1305,1306,1309,1310,1313,1315,1318,1320,1324,1327,1329,1333,1337,1339,1340,1346,1348,1349,1350,1353,1354,1358,1359,1362,1364,1366,1367,1368,1371,1373,1377,1378,1379,1382,1383,1386,1389,1391,1394,1397,1399,1404,1405,1407,1411,1412,1417,1419,1420,1425,1427,1428,1432,1436,1437,1441,1444,1448,1450,1452,1453,1456,1457,1461,1462,1467,1471,1472,1477,1478,1481,1482,1487,1490,1491,1493,1498,1499,1500,1505,1506,1508,1512,1514,1518,1522,1523,1527,1530,1531,1535,1538,1542,1546,1547,1552,1553,1554,1560,1563,1566,1567,1568,1573,1574,1575,1578,1579,1584,1585,1588,1589,1590,1594,1596,1598,1599,1602,1603,1607,1608,1613,1615,1616,1621,1623,1624,1628,1632,1633,1637,1640,1644,1648,1649,1654,1655,1656,1661,1665,1666,1670,1674,1675,1679,1680,1684,1688,1689,1693,1694,1699,1702,1704,1709,1712,1714,1715,1717,1719,1724,1725,1729,1730,1735,1738,1742,1746,1747,1751,1753,1754,1758,1762,1763,1767,1770,1774,1775,1779,1783,1787,1788,1793,1794,1796,1802,1803,1805,1810,1811,1812,1817,1821,1822,1826,1830,1831,1835,1836,1840,1843,1844,1848,1850,1851,1856,1857,1858,1862,1866,1868,1871,1872,1877,1878,1879,1883,1887,1888,1892,1894,1895,1896,1899,1900,1902,1905,1907,1911,1912,1915,1917,1919,1920,1921,1924,1926,1928,1932,1933,1934,1937,1938,1942,1944,1946,1947,1950,1951,1956,1957,1961,1962,1967,1971,1972,1976,1980,1981,1985,1989,1990,1994,1996,2001,2005,2006,2010,2012,2016,2018,2023,2027,2028,2032,2033,2037,2039,2040,2044,2048,2049,2052,2057,2059,2063,2067,2070,2075,2080,2081,2084,2086,2090,2093,2095,2097,2099,2104,2105,2106,2110,2114,2117,2119,2120,2124,2126,2129
-----computeFrom-----
160,161
160,162
169,170
169,171
216,217
216,218
229,230
229,231
234,235
234,236
239,240
239,241
286,287
286,288
291,292
291,293
296,297
296,298
345,346
345,347
396,397
396,398
401,402
401,403
410,411
410,412
445,446
445,447
456,457
456,458
464,465
464,466
469,470
469,471
470,471
470,472
474,475
474,476
506,507
506,508
556,557
556,558
567,568
567,569
575,576
575,577
582,583
582,584
629,630
629,631
630,631
630,632
658,659
658,660
698,699
698,700
706,707
706,708
713,714
713,715
748,749
748,750
768,769
768,770
783,784
783,785
790,791
790,792
797,798
797,799
832,833
832,834
852,853
852,854
867,868
867,869
874,875
874,876
881,882
881,883
916,917
916,918
924,925
924,926
942,943
942,944
975,976
975,977
993,994
993,995
1032,1033
1032,1034
1064,1065
1064,1066
1073,1074
1073,1075
1096,1097
1096,1098
1100,1101
1100,1102
1105,1106
1105,1107
1159,1160
1159,1161
1201,1202
1201,1203
1237,1238
1237,1239
1273,1274
1273,1275
1284,1285
1284,1286
1322,1323
1322,1324
1401,1402
1401,1403
1459,1460
1459,1461
1474,1475
1474,1476
1495,1496
1495,1497
1502,1503
1502,1504
1510,1511
1510,1512
1557,1558
1557,1559
1581,1582
1581,1583
1651,1652
1651,1653
1697,1698
1697,1699
1707,1708
1707,1709
1721,1722
1721,1723
1727,1728
1727,1729
1772,1773
1772,1774
1790,1791
1790,1792
1799,1800
1799,1801
1807,1808
1807,1809
1838,1839
1838,1840
1853,1854
1853,1855
1860,1861
1860,1862
1863,1864
1863,1865
1874,1875
1874,1876
1953,1954
1953,1955
2008,2009
2008,2010
2014,2015
2014,2016
2030,2031
2030,2032
2035,2036
2035,2037
2072,2073
2072,2074
2077,2078
2077,2079
2078,2079
2078,2080
2082,2083
2082,2084
2088,2089
2088,2090
2100,2101
2100,2102
2112,2113
2112,2114
-----guardedBy-----
231,236
406,417
520,530
654,2037
638,1951
786,793
787,794
870,877
871,878
1099,1107
1287,1297
1288,1298
1327,1346
1329,1348
1481,1498
1478,1499
1482,1491
1566,1623
1567,1585
1654,1679
1724,1762
1729,1774
1793,1802
1796,1803
1810,1835
1961,1996
2075,2090
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;IdExpression;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;IdExpression;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;IdExpression;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;IdExpression;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ProblemStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ProblemStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;IdExpression;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;BinaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;WhileStatement;BinaryExpression;UnaryExpression;IdExpression;Name;UnaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;UnaryExpression;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;ReferenceOperator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ProblemStatement;CompoundStatement;IfStatement;BinaryExpression;UnaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;BinaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ProblemStatement;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;BinaryExpression;UnaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;ExpressionStatement;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;UnaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;LiteralExpression;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;ConditionalExpression;UnaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;FunctionCallExpression;IdExpression;Name;IdExpression;Name;Name;UnaryExpression;UnaryExpression;FieldReference;FunctionCallExpression;IdExpression;Name;IdExpression;Name;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;WhileStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IfStatement;IdExpression;Name;BreakStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;FieldReference;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BreakStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;UnaryExpression;IdExpression;Name;UnaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;BinaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IfStatement;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;UnaryExpression;LiteralExpression;
-----ast_node-----
static int login_exec(struct ast_channel *chan, const char *data){	int res=0;	int tries = 0;	int max_login_tries = maxlogintries;	struct agent_pvt *p;	struct ast_module_user *u;	char user[AST_MAX_AGENT] = "";	char pass[AST_MAX_AGENT];	char agent[AST_MAX_AGENT] = "";	char xpass[AST_MAX_AGENT] = "";	char *errmsg;	char *parse;	AST_DECLARE_APP_ARGS(args,			     AST_APP_ARG(agent_id);			     AST_APP_ARG(options);			     AST_APP_ARG(extension);		);	const char *tmpoptions = NULL;	int play_announcement = 1;	char agent_goodbye[AST_MAX_FILENAME_LEN];	int update_cdr = updatecdr;	char *filename = "agent-loginok";	u = ast_module_user_add(chan);	parse = ast_strdupa(data);	AST_STANDARD_APP_ARGS(args, parse);	ast_copy_string(agent_goodbye, agentgoodbye, sizeof(agent_goodbye));	ast_channel_lock(chan);	/* Set Channel Specific Login Overrides */	if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTLMAXLOGINTRIES"))) {		max_login_tries = atoi(pbx_builtin_getvar_helper(chan, "AGENTMAXLOGINTRIES"));		if (max_login_tries < 0)			max_login_tries = 0;		tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTMAXLOGINTRIES");		ast_verb(3, "Saw variable AGENTMAXLOGINTRIES=%s, setting max_login_tries to: %d on Channel '%s'.\n",tmpoptions,max_login_tries,ast_channel_name(chan));	}	if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR"))) {		if (ast_true(pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR")))			update_cdr = 1;		else			update_cdr = 0;		tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR");		ast_verb(3, "Saw variable AGENTUPDATECDR=%s, setting update_cdr to: %d on Channel '%s'.\n",tmpoptions,update_cdr,ast_channel_name(chan));	}	if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTGOODBYE"))) {		strcpy(agent_goodbye, pbx_builtin_getvar_helper(chan, "AGENTGOODBYE"));		tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTGOODBYE");		ast_verb(3, "Saw variable AGENTGOODBYE=%s, setting agent_goodbye to: %s on Channel '%s'.\n",tmpoptions,agent_goodbye,ast_channel_name(chan));	}	ast_channel_unlock(chan);	/* End Channel Specific Login Overrides */	if (!ast_strlen_zero(args.options)) {		if (strchr(args.options, 's')) {			play_announcement = 0;		}	}	if (ast_channel_state(chan) != AST_STATE_UP)		res = ast_answer(chan);	if (!res) {		if (!ast_strlen_zero(args.agent_id))			ast_copy_string(user, args.agent_id, AST_MAX_AGENT);		else			res = ast_app_getdata(chan, "agent-user", user, sizeof(user) - 1, 0);	}	while (!res && (max_login_tries==0 || tries < max_login_tries)) {		tries++;		/* Check for password */		AST_LIST_LOCK(&agents);		AST_LIST_TRAVERSE(&agents, p, list) {			if (!strcmp(p->agent, user) && !p->pending)				ast_copy_string(xpass, p->password, sizeof(xpass));		}		AST_LIST_UNLOCK(&agents);		if (!res) {			if (!ast_strlen_zero(xpass))				res = ast_app_getdata(chan, "agent-pass", pass, sizeof(pass) - 1, 0);			else				pass[0] = '\0';		}		errmsg = "agent-incorrect";#if 0		ast_log(LOG_NOTICE, "user: %s, pass: %s\n", user, pass);#endif		/* Check again for accuracy */		AST_LIST_LOCK(&agents);		AST_LIST_TRAVERSE(&agents, p, list) {			int unlock_channel = 1;			ast_channel_lock(chan);			ast_mutex_lock(&p->lock);			if (!strcmp(p->agent, user) &&			    !strcmp(p->password, pass) && !p->pending) {				/* Ensure we can't be gotten until we're done */				p->lastdisc = ast_tvnow();				p->lastdisc.tv_sec++;				/* Set Channel Specific Agent Overrides */				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))) {					if (ast_true(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))) {						p->ackcall = 1;					} else {						p->ackcall = 0;					}					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTACKCALL");					ast_verb(3, "Saw variable AGENTACKCALL=%s, setting ackcall to: %d for Agent '%s'.\n", tmpoptions, p->ackcall, p->agent);					ast_set_flag(p, AGENT_FLAG_ACKCALL);				} else {					p->ackcall = ackcall;				}				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"))) {					p->autologoff = atoi(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"));					if (p->autologoff < 0)						p->autologoff = 0;					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF");					ast_verb(3, "Saw variable AGENTAUTOLOGOFF=%s, setting autologff to: %d for Agent '%s'.\n", tmpoptions, p->autologoff, p->agent);					ast_set_flag(p, AGENT_FLAG_AUTOLOGOFF);				} else {					p->autologoff = autologoff;				}				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"))) {					p->wrapuptime = atoi(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"));					if (p->wrapuptime < 0)						p->wrapuptime = 0;					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME");					ast_verb(3, "Saw variable AGENTWRAPUPTIME=%s, setting wrapuptime to: %d for Agent '%s'.\n", tmpoptions, p->wrapuptime, p->agent);					ast_set_flag(p, AGENT_FLAG_WRAPUPTIME);				} else {					p->wrapuptime = wrapuptime;				}				tmpoptions = pbx_builtin_getvar_helper(chan, "AGENTACCEPTDTMF");				if (!ast_strlen_zero(tmpoptions)) {					p->acceptdtmf = *tmpoptions;					ast_verb(3, "Saw variable AGENTACCEPTDTMF=%s, setting acceptdtmf to: %c for Agent '%s'.\n", tmpoptions, p->acceptdtmf, p->agent);					ast_set_flag(p, AGENT_FLAG_ACCEPTDTMF);				}				tmpoptions = pbx_builtin_getvar_helper(chan, "AGENTENDDTMF");				if (!ast_strlen_zero(tmpoptions)) {					p->enddtmf = *tmpoptions;					ast_verb(3, "Saw variable AGENTENDDTMF=%s, setting enddtmf to: %c for Agent '%s'.\n", tmpoptions, p->enddtmf, p->agent);					ast_set_flag(p, AGENT_FLAG_ENDDTMF);				}				ast_channel_unlock(chan);				unlock_channel = 0;				/* End Channel Specific Agent Overrides */				if (!p->chan) {					long logintime;					snprintf(agent, sizeof(agent), "Agent/%s", p->agent);					p->logincallerid[0] = '\0';					p->acknowledged = 0;					ast_mutex_unlock(&p->lock);					AST_LIST_UNLOCK(&agents);					if( !res && play_announcement==1 )						res = ast_streamfile(chan, filename, ast_channel_language(chan));					if (!res)						ast_waitstream(chan, "");					AST_LIST_LOCK(&agents);					ast_mutex_lock(&p->lock);					if (!res) {						struct ast_format tmpfmt;						res = ast_set_read_format_from_cap(chan, ast_channel_nativeformats(chan));						if (res) {							ast_log(LOG_WARNING, "Unable to set read format to %s\n", ast_getformatname(&tmpfmt));						}					}					if (!res) {						struct ast_format tmpfmt;						res = ast_set_write_format_from_cap(chan, ast_channel_nativeformats(chan));						if (res) {							ast_log(LOG_WARNING, "Unable to set write format to %s\n", ast_getformatname(&tmpfmt));						}					}					/* Check once more just in case */					if (p->chan)						res = -1;					if (!res) {						ast_indicate_data(chan, AST_CONTROL_HOLD,							S_OR(p->moh, NULL),							!ast_strlen_zero(p->moh) ? strlen(p->moh) + 1 : 0);						if (p->loginstart == 0)							time(&p->loginstart);						/*** DOCUMENTATION							<managerEventInstance>								<synopsis>Raised when an Agent has logged in.</synopsis>								<syntax>									<parameter name="Agent">										<para>The name of the agent.</para>									</parameter>								</syntax>								<see-also>									<ref type="application">AgentLogin</ref>									<ref type="managerEvent">Agentlogoff</ref>								</see-also>							</managerEventInstance>						***/						manager_event(EVENT_FLAG_AGENT, "Agentlogin",							      "Agent: %s\r\n"							      "Channel: %s\r\n"							      "Uniqueid: %s\r\n",							      p->agent, ast_channel_name(chan), ast_channel_uniqueid(chan));						if (update_cdr && ast_channel_cdr(chan))							snprintf(ast_channel_cdr(chan)->channel, sizeof(ast_channel_cdr(chan)->channel), "Agent/%s", p->agent);						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGIN", "%s", ast_channel_name(chan));						ast_verb(2, "Agent '%s' logged in (format %s/%s)\n", p->agent,								    ast_getformatname(ast_channel_readformat(chan)), ast_getformatname(ast_channel_writeformat(chan)));						/* Login this channel and wait for it to go away */						p->chan = chan;						if (p->ackcall) {							check_beep(p, 0);						} else {							check_availability(p, 0);						}						ast_mutex_unlock(&p->lock);						AST_LIST_UNLOCK(&agents);						ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);						while (res >= 0) {							ast_mutex_lock(&p->lock);							if (p->deferlogoff && p->chan) {								ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);								p->deferlogoff = 0;							}							if (p->chan != chan)								res = -1;							ast_mutex_unlock(&p->lock);							/* Yield here so other interested threads can kick in. */							sched_yield();							if (res)								break;							AST_LIST_LOCK(&agents);							ast_mutex_lock(&p->lock);							if (p->lastdisc.tv_sec) {								if (ast_tvdiff_ms(ast_tvnow(), p->lastdisc) > 0) {									ast_debug(1, "Wrapup time for %s expired!\n", p->agent);									p->lastdisc = ast_tv(0, 0);									ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);									if (p->ackcall) {										check_beep(p, 0);									} else {										check_availability(p, 0);									}								}							}							ast_mutex_unlock(&p->lock);							AST_LIST_UNLOCK(&agents);							/*	Synchronize channel ownership between call to agent and itself. */							ast_mutex_lock(&p->lock);							if (p->app_lock_flag == 1) {								ast_cond_signal(&p->login_wait_cond);								ast_cond_wait(&p->app_complete_cond, &p->lock);							}							ast_mutex_unlock(&p->lock);							if (p->ackcall) {								res = agent_ack_sleep(p);							} else {								res = ast_safe_sleep_conditional( chan, 1000, agent_cont_sleep, p );							}							if (p->ackcall && (res == 1)) {								AST_LIST_LOCK(&agents);								ast_mutex_lock(&p->lock);								check_availability(p, 0);								ast_mutex_unlock(&p->lock);								AST_LIST_UNLOCK(&agents);								res = 0;							}							sched_yield();						}						ast_mutex_lock(&p->lock);						/* Log us off if appropriate */						if (p->chan == chan) {							p->chan = NULL;						}						/* Synchronize channel ownership between call to agent and itself. */						if (p->app_lock_flag == 1) {							ast_cond_signal(&p->login_wait_cond);							ast_cond_wait(&p->app_complete_cond, &p->lock);						}						if (res && p->owner)							ast_log(LOG_WARNING, "Huh?  We broke out when there was still an owner?\n");						p->acknowledged = 0;						logintime = time(NULL) - p->loginstart;						p->loginstart = 0;						ast_mutex_unlock(&p->lock);						/*** DOCUMENTATION							<managerEventInstance>								<synopsis>Raised when an Agent has logged off.</synopsis>								<syntax>									<xi:include xpointer="xpointer(/docs/managerEvent[@name='Agentlogin']/managerEventInstance/syntax/parameter[@name='Agent'])" />								</syntax>								<see-also>									<ref type="managerEvent">Agentlogin</ref>								</see-also>							</managerEventInstance>						***/						manager_event(EVENT_FLAG_AGENT, "Agentlogoff",							      "Agent: %s\r\n"							      "Logintime: %ld\r\n"							      "Uniqueid: %s\r\n",							      p->agent, logintime, ast_channel_uniqueid(chan));						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGOFF", "%s|%ld", ast_channel_name(chan), logintime);						ast_verb(2, "Agent '%s' logged out\n", p->agent);						/* If there is no owner, go ahead and kill it now */						ast_devstate_changed(AST_DEVICE_UNAVAILABLE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);						if (p->dead && !p->owner) {							ast_mutex_destroy(&p->lock);							ast_cond_destroy(&p->app_complete_cond);							ast_cond_destroy(&p->login_wait_cond);							ast_free(p);						}					}					else {						ast_mutex_unlock(&p->lock);						p = NULL;					}					res = -1;				} else {					ast_mutex_unlock(&p->lock);					errmsg = "agent-alreadyon";					p = NULL;				}				break;			}			ast_mutex_unlock(&p->lock);			if (unlock_channel) {				ast_channel_unlock(chan);			}		}		if (!p)			AST_LIST_UNLOCK(&agents);		if (!res && (max_login_tries==0 || tries < max_login_tries))			res = ast_app_getdata(chan, errmsg, user, sizeof(user) - 1, 0);	}	if (!res)		res = ast_safe_sleep(chan, 500);	ast_module_user_remove(u); 	return -1;}
static int
login_exec(struct ast_channel *chan, const char *data)
login_exec
struct ast_channel *chan
struct ast_channel
ast_channel
*chan
*
chan
const char *data
const char
*data
*
data
{	int res=0;	int tries = 0;	int max_login_tries = maxlogintries;	struct agent_pvt *p;	struct ast_module_user *u;	char user[AST_MAX_AGENT] = "";	char pass[AST_MAX_AGENT];	char agent[AST_MAX_AGENT] = "";	char xpass[AST_MAX_AGENT] = "";	char *errmsg;	char *parse;	AST_DECLARE_APP_ARGS(args,			     AST_APP_ARG(agent_id);			     AST_APP_ARG(options);			     AST_APP_ARG(extension);		);	const char *tmpoptions = NULL;	int play_announcement = 1;	char agent_goodbye[AST_MAX_FILENAME_LEN];	int update_cdr = updatecdr;	char *filename = "agent-loginok";	u = ast_module_user_add(chan);	parse = ast_strdupa(data);	AST_STANDARD_APP_ARGS(args, parse);	ast_copy_string(agent_goodbye, agentgoodbye, sizeof(agent_goodbye));	ast_channel_lock(chan);	/* Set Channel Specific Login Overrides */	if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTLMAXLOGINTRIES"))) {		max_login_tries = atoi(pbx_builtin_getvar_helper(chan, "AGENTMAXLOGINTRIES"));		if (max_login_tries < 0)			max_login_tries = 0;		tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTMAXLOGINTRIES");		ast_verb(3, "Saw variable AGENTMAXLOGINTRIES=%s, setting max_login_tries to: %d on Channel '%s'.\n",tmpoptions,max_login_tries,ast_channel_name(chan));	}	if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR"))) {		if (ast_true(pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR")))			update_cdr = 1;		else			update_cdr = 0;		tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR");		ast_verb(3, "Saw variable AGENTUPDATECDR=%s, setting update_cdr to: %d on Channel '%s'.\n",tmpoptions,update_cdr,ast_channel_name(chan));	}	if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTGOODBYE"))) {		strcpy(agent_goodbye, pbx_builtin_getvar_helper(chan, "AGENTGOODBYE"));		tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTGOODBYE");		ast_verb(3, "Saw variable AGENTGOODBYE=%s, setting agent_goodbye to: %s on Channel '%s'.\n",tmpoptions,agent_goodbye,ast_channel_name(chan));	}	ast_channel_unlock(chan);	/* End Channel Specific Login Overrides */	if (!ast_strlen_zero(args.options)) {		if (strchr(args.options, 's')) {			play_announcement = 0;		}	}	if (ast_channel_state(chan) != AST_STATE_UP)		res = ast_answer(chan);	if (!res) {		if (!ast_strlen_zero(args.agent_id))			ast_copy_string(user, args.agent_id, AST_MAX_AGENT);		else			res = ast_app_getdata(chan, "agent-user", user, sizeof(user) - 1, 0);	}	while (!res && (max_login_tries==0 || tries < max_login_tries)) {		tries++;		/* Check for password */		AST_LIST_LOCK(&agents);		AST_LIST_TRAVERSE(&agents, p, list) {			if (!strcmp(p->agent, user) && !p->pending)				ast_copy_string(xpass, p->password, sizeof(xpass));		}		AST_LIST_UNLOCK(&agents);		if (!res) {			if (!ast_strlen_zero(xpass))				res = ast_app_getdata(chan, "agent-pass", pass, sizeof(pass) - 1, 0);			else				pass[0] = '\0';		}		errmsg = "agent-incorrect";#if 0		ast_log(LOG_NOTICE, "user: %s, pass: %s\n", user, pass);#endif		/* Check again for accuracy */		AST_LIST_LOCK(&agents);		AST_LIST_TRAVERSE(&agents, p, list) {			int unlock_channel = 1;			ast_channel_lock(chan);			ast_mutex_lock(&p->lock);			if (!strcmp(p->agent, user) &&			    !strcmp(p->password, pass) && !p->pending) {				/* Ensure we can't be gotten until we're done */				p->lastdisc = ast_tvnow();				p->lastdisc.tv_sec++;				/* Set Channel Specific Agent Overrides */				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))) {					if (ast_true(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))) {						p->ackcall = 1;					} else {						p->ackcall = 0;					}					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTACKCALL");					ast_verb(3, "Saw variable AGENTACKCALL=%s, setting ackcall to: %d for Agent '%s'.\n", tmpoptions, p->ackcall, p->agent);					ast_set_flag(p, AGENT_FLAG_ACKCALL);				} else {					p->ackcall = ackcall;				}				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"))) {					p->autologoff = atoi(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"));					if (p->autologoff < 0)						p->autologoff = 0;					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF");					ast_verb(3, "Saw variable AGENTAUTOLOGOFF=%s, setting autologff to: %d for Agent '%s'.\n", tmpoptions, p->autologoff, p->agent);					ast_set_flag(p, AGENT_FLAG_AUTOLOGOFF);				} else {					p->autologoff = autologoff;				}				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"))) {					p->wrapuptime = atoi(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"));					if (p->wrapuptime < 0)						p->wrapuptime = 0;					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME");					ast_verb(3, "Saw variable AGENTWRAPUPTIME=%s, setting wrapuptime to: %d for Agent '%s'.\n", tmpoptions, p->wrapuptime, p->agent);					ast_set_flag(p, AGENT_FLAG_WRAPUPTIME);				} else {					p->wrapuptime = wrapuptime;				}				tmpoptions = pbx_builtin_getvar_helper(chan, "AGENTACCEPTDTMF");				if (!ast_strlen_zero(tmpoptions)) {					p->acceptdtmf = *tmpoptions;					ast_verb(3, "Saw variable AGENTACCEPTDTMF=%s, setting acceptdtmf to: %c for Agent '%s'.\n", tmpoptions, p->acceptdtmf, p->agent);					ast_set_flag(p, AGENT_FLAG_ACCEPTDTMF);				}				tmpoptions = pbx_builtin_getvar_helper(chan, "AGENTENDDTMF");				if (!ast_strlen_zero(tmpoptions)) {					p->enddtmf = *tmpoptions;					ast_verb(3, "Saw variable AGENTENDDTMF=%s, setting enddtmf to: %c for Agent '%s'.\n", tmpoptions, p->enddtmf, p->agent);					ast_set_flag(p, AGENT_FLAG_ENDDTMF);				}				ast_channel_unlock(chan);				unlock_channel = 0;				/* End Channel Specific Agent Overrides */				if (!p->chan) {					long logintime;					snprintf(agent, sizeof(agent), "Agent/%s", p->agent);					p->logincallerid[0] = '\0';					p->acknowledged = 0;					ast_mutex_unlock(&p->lock);					AST_LIST_UNLOCK(&agents);					if( !res && play_announcement==1 )						res = ast_streamfile(chan, filename, ast_channel_language(chan));					if (!res)						ast_waitstream(chan, "");					AST_LIST_LOCK(&agents);					ast_mutex_lock(&p->lock);					if (!res) {						struct ast_format tmpfmt;						res = ast_set_read_format_from_cap(chan, ast_channel_nativeformats(chan));						if (res) {							ast_log(LOG_WARNING, "Unable to set read format to %s\n", ast_getformatname(&tmpfmt));						}					}					if (!res) {						struct ast_format tmpfmt;						res = ast_set_write_format_from_cap(chan, ast_channel_nativeformats(chan));						if (res) {							ast_log(LOG_WARNING, "Unable to set write format to %s\n", ast_getformatname(&tmpfmt));						}					}					/* Check once more just in case */					if (p->chan)						res = -1;					if (!res) {						ast_indicate_data(chan, AST_CONTROL_HOLD,							S_OR(p->moh, NULL),							!ast_strlen_zero(p->moh) ? strlen(p->moh) + 1 : 0);						if (p->loginstart == 0)							time(&p->loginstart);						/*** DOCUMENTATION							<managerEventInstance>								<synopsis>Raised when an Agent has logged in.</synopsis>								<syntax>									<parameter name="Agent">										<para>The name of the agent.</para>									</parameter>								</syntax>								<see-also>									<ref type="application">AgentLogin</ref>									<ref type="managerEvent">Agentlogoff</ref>								</see-also>							</managerEventInstance>						***/						manager_event(EVENT_FLAG_AGENT, "Agentlogin",							      "Agent: %s\r\n"							      "Channel: %s\r\n"							      "Uniqueid: %s\r\n",							      p->agent, ast_channel_name(chan), ast_channel_uniqueid(chan));						if (update_cdr && ast_channel_cdr(chan))							snprintf(ast_channel_cdr(chan)->channel, sizeof(ast_channel_cdr(chan)->channel), "Agent/%s", p->agent);						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGIN", "%s", ast_channel_name(chan));						ast_verb(2, "Agent '%s' logged in (format %s/%s)\n", p->agent,								    ast_getformatname(ast_channel_readformat(chan)), ast_getformatname(ast_channel_writeformat(chan)));						/* Login this channel and wait for it to go away */						p->chan = chan;						if (p->ackcall) {							check_beep(p, 0);						} else {							check_availability(p, 0);						}						ast_mutex_unlock(&p->lock);						AST_LIST_UNLOCK(&agents);						ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);						while (res >= 0) {							ast_mutex_lock(&p->lock);							if (p->deferlogoff && p->chan) {								ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);								p->deferlogoff = 0;							}							if (p->chan != chan)								res = -1;							ast_mutex_unlock(&p->lock);							/* Yield here so other interested threads can kick in. */							sched_yield();							if (res)								break;							AST_LIST_LOCK(&agents);							ast_mutex_lock(&p->lock);							if (p->lastdisc.tv_sec) {								if (ast_tvdiff_ms(ast_tvnow(), p->lastdisc) > 0) {									ast_debug(1, "Wrapup time for %s expired!\n", p->agent);									p->lastdisc = ast_tv(0, 0);									ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);									if (p->ackcall) {										check_beep(p, 0);									} else {										check_availability(p, 0);									}								}							}							ast_mutex_unlock(&p->lock);							AST_LIST_UNLOCK(&agents);							/*	Synchronize channel ownership between call to agent and itself. */							ast_mutex_lock(&p->lock);							if (p->app_lock_flag == 1) {								ast_cond_signal(&p->login_wait_cond);								ast_cond_wait(&p->app_complete_cond, &p->lock);							}							ast_mutex_unlock(&p->lock);							if (p->ackcall) {								res = agent_ack_sleep(p);							} else {								res = ast_safe_sleep_conditional( chan, 1000, agent_cont_sleep, p );							}							if (p->ackcall && (res == 1)) {								AST_LIST_LOCK(&agents);								ast_mutex_lock(&p->lock);								check_availability(p, 0);								ast_mutex_unlock(&p->lock);								AST_LIST_UNLOCK(&agents);								res = 0;							}							sched_yield();						}						ast_mutex_lock(&p->lock);						/* Log us off if appropriate */						if (p->chan == chan) {							p->chan = NULL;						}						/* Synchronize channel ownership between call to agent and itself. */						if (p->app_lock_flag == 1) {							ast_cond_signal(&p->login_wait_cond);							ast_cond_wait(&p->app_complete_cond, &p->lock);						}						if (res && p->owner)							ast_log(LOG_WARNING, "Huh?  We broke out when there was still an owner?\n");						p->acknowledged = 0;						logintime = time(NULL) - p->loginstart;						p->loginstart = 0;						ast_mutex_unlock(&p->lock);						/*** DOCUMENTATION							<managerEventInstance>								<synopsis>Raised when an Agent has logged off.</synopsis>								<syntax>									<xi:include xpointer="xpointer(/docs/managerEvent[@name='Agentlogin']/managerEventInstance/syntax/parameter[@name='Agent'])" />								</syntax>								<see-also>									<ref type="managerEvent">Agentlogin</ref>								</see-also>							</managerEventInstance>						***/						manager_event(EVENT_FLAG_AGENT, "Agentlogoff",							      "Agent: %s\r\n"							      "Logintime: %ld\r\n"							      "Uniqueid: %s\r\n",							      p->agent, logintime, ast_channel_uniqueid(chan));						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGOFF", "%s|%ld", ast_channel_name(chan), logintime);						ast_verb(2, "Agent '%s' logged out\n", p->agent);						/* If there is no owner, go ahead and kill it now */						ast_devstate_changed(AST_DEVICE_UNAVAILABLE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);						if (p->dead && !p->owner) {							ast_mutex_destroy(&p->lock);							ast_cond_destroy(&p->app_complete_cond);							ast_cond_destroy(&p->login_wait_cond);							ast_free(p);						}					}					else {						ast_mutex_unlock(&p->lock);						p = NULL;					}					res = -1;				} else {					ast_mutex_unlock(&p->lock);					errmsg = "agent-alreadyon";					p = NULL;				}				break;			}			ast_mutex_unlock(&p->lock);			if (unlock_channel) {				ast_channel_unlock(chan);			}		}		if (!p)			AST_LIST_UNLOCK(&agents);		if (!res && (max_login_tries==0 || tries < max_login_tries))			res = ast_app_getdata(chan, errmsg, user, sizeof(user) - 1, 0);	}	if (!res)		res = ast_safe_sleep(chan, 500);	ast_module_user_remove(u); 	return -1;}
int res=0;
int res=0;
int
res=0
res
=0
0
int tries = 0;
int tries = 0;
int
tries = 0
tries
= 0
0
int max_login_tries = maxlogintries;
int max_login_tries = maxlogintries;
int
max_login_tries = maxlogintries
max_login_tries
= maxlogintries
maxlogintries
maxlogintries
struct agent_pvt *p;
struct agent_pvt *p;
struct agent_pvt
agent_pvt
*p
*
p
struct ast_module_user *u;
struct ast_module_user *u;
struct ast_module_user
ast_module_user
*u
*
u
char user[AST_MAX_AGENT] = "";
char user[AST_MAX_AGENT] = "";
char
user[AST_MAX_AGENT] = ""
user
[AST_MAX_AGENT]
AST_MAX_AGENT
AST_MAX_AGENT
= ""
""
char pass[AST_MAX_AGENT];
char pass[AST_MAX_AGENT];
char
pass[AST_MAX_AGENT]
pass
[AST_MAX_AGENT]
AST_MAX_AGENT
AST_MAX_AGENT
char agent[AST_MAX_AGENT] = "";
char agent[AST_MAX_AGENT] = "";
char
agent[AST_MAX_AGENT] = ""
agent
[AST_MAX_AGENT]
AST_MAX_AGENT
AST_MAX_AGENT
= ""
""
char xpass[AST_MAX_AGENT] = "";
char xpass[AST_MAX_AGENT] = "";
char
xpass[AST_MAX_AGENT] = ""
xpass
[AST_MAX_AGENT]
AST_MAX_AGENT
AST_MAX_AGENT
= ""
""
char *errmsg;
char *errmsg;
char
*errmsg
*
errmsg
char *parse;
char *parse;
char
*parse
*
parse
AST_DECLARE_APP_ARGS(args,			     AST_APP_ARG(agent_id);
AST_APP_ARG(options);
AST_APP_ARG(options);
AST_APP_ARG
AST_APP_ARG
(options)
options
options
AST_APP_ARG(extension);
AST_APP_ARG(extension);
AST_APP_ARG
AST_APP_ARG
(extension)
extension
extension
);
const char *tmpoptions = NULL;
const char *tmpoptions = NULL;
const char
*tmpoptions = NULL
*
tmpoptions
= NULL
NULL
NULL
int play_announcement = 1;
int play_announcement = 1;
int
play_announcement = 1
play_announcement
= 1
1
char agent_goodbye[AST_MAX_FILENAME_LEN];
char agent_goodbye[AST_MAX_FILENAME_LEN];
char
agent_goodbye[AST_MAX_FILENAME_LEN]
agent_goodbye
[AST_MAX_FILENAME_LEN]
AST_MAX_FILENAME_LEN
AST_MAX_FILENAME_LEN
int update_cdr = updatecdr;
int update_cdr = updatecdr;
int
update_cdr = updatecdr
update_cdr
= updatecdr
updatecdr
updatecdr
char *filename = "agent-loginok";
char *filename = "agent-loginok";
char
*filename = "agent-loginok"
*
filename
= "agent-loginok"
"agent-loginok"
u = ast_module_user_add(chan);
u = ast_module_user_add(chan)
u
u
ast_module_user_add(chan)
ast_module_user_add
ast_module_user_add
chan
chan
parse = ast_strdupa(data);
parse = ast_strdupa(data)
parse
parse
ast_strdupa(data)
ast_strdupa
ast_strdupa
data
data
AST_STANDARD_APP_ARGS(args, parse);
AST_STANDARD_APP_ARGS(args, parse)
AST_STANDARD_APP_ARGS
AST_STANDARD_APP_ARGS
args
args
parse
parse
ast_copy_string(agent_goodbye, agentgoodbye, sizeof(agent_goodbye));
ast_copy_string(agent_goodbye, agentgoodbye, sizeof(agent_goodbye))
ast_copy_string
ast_copy_string
agent_goodbye
agent_goodbye
agentgoodbye
agentgoodbye
sizeof(agent_goodbye)
(agent_goodbye)
agent_goodbye
agent_goodbye
ast_channel_lock(chan);
ast_channel_lock(chan)
ast_channel_lock
ast_channel_lock
chan
chan
if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTLMAXLOGINTRIES"))) {		max_login_tries = atoi(pbx_builtin_getvar_helper(chan, "AGENTMAXLOGINTRIES"));		if (max_login_tries < 0)			max_login_tries = 0;		tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTMAXLOGINTRIES");		ast_verb(3, "Saw variable AGENTMAXLOGINTRIES=%s, setting max_login_tries to: %d on Channel '%s'.\n",tmpoptions,max_login_tries,ast_channel_name(chan));	}
!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTLMAXLOGINTRIES"))
ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTLMAXLOGINTRIES"))
ast_strlen_zero
ast_strlen_zero
pbx_builtin_getvar_helper(chan, "AGENTLMAXLOGINTRIES")
pbx_builtin_getvar_helper
pbx_builtin_getvar_helper
chan
chan
"AGENTLMAXLOGINTRIES"
{		max_login_tries = atoi(pbx_builtin_getvar_helper(chan, "AGENTMAXLOGINTRIES"));		if (max_login_tries < 0)			max_login_tries = 0;		tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTMAXLOGINTRIES");		ast_verb(3, "Saw variable AGENTMAXLOGINTRIES=%s, setting max_login_tries to: %d on Channel '%s'.\n",tmpoptions,max_login_tries,ast_channel_name(chan));	}
max_login_tries = atoi(pbx_builtin_getvar_helper(chan, "AGENTMAXLOGINTRIES"));
max_login_tries = atoi(pbx_builtin_getvar_helper(chan, "AGENTMAXLOGINTRIES"))
max_login_tries
max_login_tries
atoi(pbx_builtin_getvar_helper(chan, "AGENTMAXLOGINTRIES"))
atoi
atoi
pbx_builtin_getvar_helper(chan, "AGENTMAXLOGINTRIES")
pbx_builtin_getvar_helper
pbx_builtin_getvar_helper
chan
chan
"AGENTMAXLOGINTRIES"
if (max_login_tries < 0)			max_login_tries = 0;
max_login_tries < 0
max_login_tries
max_login_tries
0
max_login_tries = 0;
max_login_tries = 0
max_login_tries
max_login_tries
0
tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTMAXLOGINTRIES");
tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTMAXLOGINTRIES")
tmpoptions
tmpoptions
pbx_builtin_getvar_helper(chan, "AGENTMAXLOGINTRIES")
pbx_builtin_getvar_helper
pbx_builtin_getvar_helper
chan
chan
"AGENTMAXLOGINTRIES"
ast_verb(3, "Saw variable AGENTMAXLOGINTRIES=%s, setting max_login_tries to: %d on Channel '%s'.\n",tmpoptions,max_login_tries,ast_channel_name(chan));
ast_verb(3, "Saw variable AGENTMAXLOGINTRIES=%s, setting max_login_tries to: %d on Channel '%s'.\n",tmpoptions,max_login_tries,ast_channel_name(chan))
ast_verb
ast_verb
3
"Saw variable AGENTMAXLOGINTRIES=%s, setting max_login_tries to: %d on Channel '%s'.\n"
tmpoptions
tmpoptions
max_login_tries
max_login_tries
ast_channel_name(chan)
ast_channel_name
ast_channel_name
chan
chan
if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR"))) {		if (ast_true(pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR")))			update_cdr = 1;		else			update_cdr = 0;		tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR");		ast_verb(3, "Saw variable AGENTUPDATECDR=%s, setting update_cdr to: %d on Channel '%s'.\n",tmpoptions,update_cdr,ast_channel_name(chan));	}
!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR"))
ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR"))
ast_strlen_zero
ast_strlen_zero
pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR")
pbx_builtin_getvar_helper
pbx_builtin_getvar_helper
chan
chan
"AGENTUPDATECDR"
{		if (ast_true(pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR")))			update_cdr = 1;		else			update_cdr = 0;		tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR");		ast_verb(3, "Saw variable AGENTUPDATECDR=%s, setting update_cdr to: %d on Channel '%s'.\n",tmpoptions,update_cdr,ast_channel_name(chan));	}
if (ast_true(pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR")))			update_cdr = 1;		else			update_cdr = 0;
ast_true(pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR"))
ast_true
ast_true
pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR")
pbx_builtin_getvar_helper
pbx_builtin_getvar_helper
chan
chan
"AGENTUPDATECDR"
update_cdr = 1;
update_cdr = 1
update_cdr
update_cdr
1
update_cdr = 0;
update_cdr = 0
update_cdr
update_cdr
0
tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR");
tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR")
tmpoptions
tmpoptions
pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR")
pbx_builtin_getvar_helper
pbx_builtin_getvar_helper
chan
chan
"AGENTUPDATECDR"
ast_verb(3, "Saw variable AGENTUPDATECDR=%s, setting update_cdr to: %d on Channel '%s'.\n",tmpoptions,update_cdr,ast_channel_name(chan));
ast_verb(3, "Saw variable AGENTUPDATECDR=%s, setting update_cdr to: %d on Channel '%s'.\n",tmpoptions,update_cdr,ast_channel_name(chan))
ast_verb
ast_verb
3
"Saw variable AGENTUPDATECDR=%s, setting update_cdr to: %d on Channel '%s'.\n"
tmpoptions
tmpoptions
update_cdr
update_cdr
ast_channel_name(chan)
ast_channel_name
ast_channel_name
chan
chan
if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTGOODBYE"))) {		strcpy(agent_goodbye, pbx_builtin_getvar_helper(chan, "AGENTGOODBYE"));		tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTGOODBYE");		ast_verb(3, "Saw variable AGENTGOODBYE=%s, setting agent_goodbye to: %s on Channel '%s'.\n",tmpoptions,agent_goodbye,ast_channel_name(chan));	}
!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTGOODBYE"))
ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTGOODBYE"))
ast_strlen_zero
ast_strlen_zero
pbx_builtin_getvar_helper(chan, "AGENTGOODBYE")
pbx_builtin_getvar_helper
pbx_builtin_getvar_helper
chan
chan
"AGENTGOODBYE"
{		strcpy(agent_goodbye, pbx_builtin_getvar_helper(chan, "AGENTGOODBYE"));		tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTGOODBYE");		ast_verb(3, "Saw variable AGENTGOODBYE=%s, setting agent_goodbye to: %s on Channel '%s'.\n",tmpoptions,agent_goodbye,ast_channel_name(chan));	}
strcpy(agent_goodbye, pbx_builtin_getvar_helper(chan, "AGENTGOODBYE"));
strcpy(agent_goodbye, pbx_builtin_getvar_helper(chan, "AGENTGOODBYE"))
strcpy
strcpy
agent_goodbye
agent_goodbye
pbx_builtin_getvar_helper(chan, "AGENTGOODBYE")
pbx_builtin_getvar_helper
pbx_builtin_getvar_helper
chan
chan
"AGENTGOODBYE"
tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTGOODBYE");
tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTGOODBYE")
tmpoptions
tmpoptions
pbx_builtin_getvar_helper(chan, "AGENTGOODBYE")
pbx_builtin_getvar_helper
pbx_builtin_getvar_helper
chan
chan
"AGENTGOODBYE"
ast_verb(3, "Saw variable AGENTGOODBYE=%s, setting agent_goodbye to: %s on Channel '%s'.\n",tmpoptions,agent_goodbye,ast_channel_name(chan));
ast_verb(3, "Saw variable AGENTGOODBYE=%s, setting agent_goodbye to: %s on Channel '%s'.\n",tmpoptions,agent_goodbye,ast_channel_name(chan))
ast_verb
ast_verb
3
"Saw variable AGENTGOODBYE=%s, setting agent_goodbye to: %s on Channel '%s'.\n"
tmpoptions
tmpoptions
agent_goodbye
agent_goodbye
ast_channel_name(chan)
ast_channel_name
ast_channel_name
chan
chan
ast_channel_unlock(chan);
ast_channel_unlock(chan)
ast_channel_unlock
ast_channel_unlock
chan
chan
if (!ast_strlen_zero(args.options)) {		if (strchr(args.options, 's')) {			play_announcement = 0;		}	}
!ast_strlen_zero(args.options)
ast_strlen_zero(args.options)
ast_strlen_zero
ast_strlen_zero
args.options
args
args
options
{		if (strchr(args.options, 's')) {			play_announcement = 0;		}	}
if (strchr(args.options, 's')) {			play_announcement = 0;		}
strchr(args.options, 's')
strchr
strchr
args.options
args
args
options
's'
{			play_announcement = 0;		}
play_announcement = 0;
play_announcement = 0
play_announcement
play_announcement
0
if (ast_channel_state(chan) != AST_STATE_UP)		res = ast_answer(chan);
ast_channel_state(chan) != AST_STATE_UP
ast_channel_state(chan)
ast_channel_state
ast_channel_state
chan
chan
AST_STATE_UP
AST_STATE_UP
res = ast_answer(chan);
res = ast_answer(chan)
res
res
ast_answer(chan)
ast_answer
ast_answer
chan
chan
if (!res) {		if (!ast_strlen_zero(args.agent_id))			ast_copy_string(user, args.agent_id, AST_MAX_AGENT);		else			res = ast_app_getdata(chan, "agent-user", user, sizeof(user) - 1, 0);	}
!res
res
res
{		if (!ast_strlen_zero(args.agent_id))			ast_copy_string(user, args.agent_id, AST_MAX_AGENT);		else			res = ast_app_getdata(chan, "agent-user", user, sizeof(user) - 1, 0);	}
if (!ast_strlen_zero(args.agent_id))			ast_copy_string(user, args.agent_id, AST_MAX_AGENT);		else			res = ast_app_getdata(chan, "agent-user", user, sizeof(user) - 1, 0);
!ast_strlen_zero(args.agent_id)
ast_strlen_zero(args.agent_id)
ast_strlen_zero
ast_strlen_zero
args.agent_id
args
args
agent_id
ast_copy_string(user, args.agent_id, AST_MAX_AGENT);
ast_copy_string(user, args.agent_id, AST_MAX_AGENT)
ast_copy_string
ast_copy_string
user
user
args.agent_id
args
args
agent_id
AST_MAX_AGENT
AST_MAX_AGENT
res = ast_app_getdata(chan, "agent-user", user, sizeof(user) - 1, 0);
res = ast_app_getdata(chan, "agent-user", user, sizeof(user) - 1, 0)
res
res
ast_app_getdata(chan, "agent-user", user, sizeof(user) - 1, 0)
ast_app_getdata
ast_app_getdata
chan
chan
"agent-user"
user
user
sizeof(user) - 1
sizeof(user)
(user)
user
user
1
0
while (!res && (max_login_tries==0 || tries < max_login_tries)) {		tries++;		/* Check for password */		AST_LIST_LOCK(&agents);		AST_LIST_TRAVERSE(&agents, p, list) {			if (!strcmp(p->agent, user) && !p->pending)				ast_copy_string(xpass, p->password, sizeof(xpass));		}		AST_LIST_UNLOCK(&agents);		if (!res) {			if (!ast_strlen_zero(xpass))				res = ast_app_getdata(chan, "agent-pass", pass, sizeof(pass) - 1, 0);			else				pass[0] = '\0';		}		errmsg = "agent-incorrect";#if 0		ast_log(LOG_NOTICE, "user: %s, pass: %s\n", user, pass);#endif		/* Check again for accuracy */		AST_LIST_LOCK(&agents);		AST_LIST_TRAVERSE(&agents, p, list) {			int unlock_channel = 1;			ast_channel_lock(chan);			ast_mutex_lock(&p->lock);			if (!strcmp(p->agent, user) &&			    !strcmp(p->password, pass) && !p->pending) {				/* Ensure we can't be gotten until we're done */				p->lastdisc = ast_tvnow();				p->lastdisc.tv_sec++;				/* Set Channel Specific Agent Overrides */				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))) {					if (ast_true(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))) {						p->ackcall = 1;					} else {						p->ackcall = 0;					}					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTACKCALL");					ast_verb(3, "Saw variable AGENTACKCALL=%s, setting ackcall to: %d for Agent '%s'.\n", tmpoptions, p->ackcall, p->agent);					ast_set_flag(p, AGENT_FLAG_ACKCALL);				} else {					p->ackcall = ackcall;				}				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"))) {					p->autologoff = atoi(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"));					if (p->autologoff < 0)						p->autologoff = 0;					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF");					ast_verb(3, "Saw variable AGENTAUTOLOGOFF=%s, setting autologff to: %d for Agent '%s'.\n", tmpoptions, p->autologoff, p->agent);					ast_set_flag(p, AGENT_FLAG_AUTOLOGOFF);				} else {					p->autologoff = autologoff;				}				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"))) {					p->wrapuptime = atoi(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"));					if (p->wrapuptime < 0)						p->wrapuptime = 0;					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME");					ast_verb(3, "Saw variable AGENTWRAPUPTIME=%s, setting wrapuptime to: %d for Agent '%s'.\n", tmpoptions, p->wrapuptime, p->agent);					ast_set_flag(p, AGENT_FLAG_WRAPUPTIME);				} else {					p->wrapuptime = wrapuptime;				}				tmpoptions = pbx_builtin_getvar_helper(chan, "AGENTACCEPTDTMF");				if (!ast_strlen_zero(tmpoptions)) {					p->acceptdtmf = *tmpoptions;					ast_verb(3, "Saw variable AGENTACCEPTDTMF=%s, setting acceptdtmf to: %c for Agent '%s'.\n", tmpoptions, p->acceptdtmf, p->agent);					ast_set_flag(p, AGENT_FLAG_ACCEPTDTMF);				}				tmpoptions = pbx_builtin_getvar_helper(chan, "AGENTENDDTMF");				if (!ast_strlen_zero(tmpoptions)) {					p->enddtmf = *tmpoptions;					ast_verb(3, "Saw variable AGENTENDDTMF=%s, setting enddtmf to: %c for Agent '%s'.\n", tmpoptions, p->enddtmf, p->agent);					ast_set_flag(p, AGENT_FLAG_ENDDTMF);				}				ast_channel_unlock(chan);				unlock_channel = 0;				/* End Channel Specific Agent Overrides */				if (!p->chan) {					long logintime;					snprintf(agent, sizeof(agent), "Agent/%s", p->agent);					p->logincallerid[0] = '\0';					p->acknowledged = 0;					ast_mutex_unlock(&p->lock);					AST_LIST_UNLOCK(&agents);					if( !res && play_announcement==1 )						res = ast_streamfile(chan, filename, ast_channel_language(chan));					if (!res)						ast_waitstream(chan, "");					AST_LIST_LOCK(&agents);					ast_mutex_lock(&p->lock);					if (!res) {						struct ast_format tmpfmt;						res = ast_set_read_format_from_cap(chan, ast_channel_nativeformats(chan));						if (res) {							ast_log(LOG_WARNING, "Unable to set read format to %s\n", ast_getformatname(&tmpfmt));						}					}					if (!res) {						struct ast_format tmpfmt;						res = ast_set_write_format_from_cap(chan, ast_channel_nativeformats(chan));						if (res) {							ast_log(LOG_WARNING, "Unable to set write format to %s\n", ast_getformatname(&tmpfmt));						}					}					/* Check once more just in case */					if (p->chan)						res = -1;					if (!res) {						ast_indicate_data(chan, AST_CONTROL_HOLD,							S_OR(p->moh, NULL),							!ast_strlen_zero(p->moh) ? strlen(p->moh) + 1 : 0);						if (p->loginstart == 0)							time(&p->loginstart);						/*** DOCUMENTATION							<managerEventInstance>								<synopsis>Raised when an Agent has logged in.</synopsis>								<syntax>									<parameter name="Agent">										<para>The name of the agent.</para>									</parameter>								</syntax>								<see-also>									<ref type="application">AgentLogin</ref>									<ref type="managerEvent">Agentlogoff</ref>								</see-also>							</managerEventInstance>						***/						manager_event(EVENT_FLAG_AGENT, "Agentlogin",							      "Agent: %s\r\n"							      "Channel: %s\r\n"							      "Uniqueid: %s\r\n",							      p->agent, ast_channel_name(chan), ast_channel_uniqueid(chan));						if (update_cdr && ast_channel_cdr(chan))							snprintf(ast_channel_cdr(chan)->channel, sizeof(ast_channel_cdr(chan)->channel), "Agent/%s", p->agent);						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGIN", "%s", ast_channel_name(chan));						ast_verb(2, "Agent '%s' logged in (format %s/%s)\n", p->agent,								    ast_getformatname(ast_channel_readformat(chan)), ast_getformatname(ast_channel_writeformat(chan)));						/* Login this channel and wait for it to go away */						p->chan = chan;						if (p->ackcall) {							check_beep(p, 0);						} else {							check_availability(p, 0);						}						ast_mutex_unlock(&p->lock);						AST_LIST_UNLOCK(&agents);						ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);						while (res >= 0) {							ast_mutex_lock(&p->lock);							if (p->deferlogoff && p->chan) {								ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);								p->deferlogoff = 0;							}							if (p->chan != chan)								res = -1;							ast_mutex_unlock(&p->lock);							/* Yield here so other interested threads can kick in. */							sched_yield();							if (res)								break;							AST_LIST_LOCK(&agents);							ast_mutex_lock(&p->lock);							if (p->lastdisc.tv_sec) {								if (ast_tvdiff_ms(ast_tvnow(), p->lastdisc) > 0) {									ast_debug(1, "Wrapup time for %s expired!\n", p->agent);									p->lastdisc = ast_tv(0, 0);									ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);									if (p->ackcall) {										check_beep(p, 0);									} else {										check_availability(p, 0);									}								}							}							ast_mutex_unlock(&p->lock);							AST_LIST_UNLOCK(&agents);							/*	Synchronize channel ownership between call to agent and itself. */							ast_mutex_lock(&p->lock);							if (p->app_lock_flag == 1) {								ast_cond_signal(&p->login_wait_cond);								ast_cond_wait(&p->app_complete_cond, &p->lock);							}							ast_mutex_unlock(&p->lock);							if (p->ackcall) {								res = agent_ack_sleep(p);							} else {								res = ast_safe_sleep_conditional( chan, 1000, agent_cont_sleep, p );							}							if (p->ackcall && (res == 1)) {								AST_LIST_LOCK(&agents);								ast_mutex_lock(&p->lock);								check_availability(p, 0);								ast_mutex_unlock(&p->lock);								AST_LIST_UNLOCK(&agents);								res = 0;							}							sched_yield();						}						ast_mutex_lock(&p->lock);						/* Log us off if appropriate */						if (p->chan == chan) {							p->chan = NULL;						}						/* Synchronize channel ownership between call to agent and itself. */						if (p->app_lock_flag == 1) {							ast_cond_signal(&p->login_wait_cond);							ast_cond_wait(&p->app_complete_cond, &p->lock);						}						if (res && p->owner)							ast_log(LOG_WARNING, "Huh?  We broke out when there was still an owner?\n");						p->acknowledged = 0;						logintime = time(NULL) - p->loginstart;						p->loginstart = 0;						ast_mutex_unlock(&p->lock);						/*** DOCUMENTATION							<managerEventInstance>								<synopsis>Raised when an Agent has logged off.</synopsis>								<syntax>									<xi:include xpointer="xpointer(/docs/managerEvent[@name='Agentlogin']/managerEventInstance/syntax/parameter[@name='Agent'])" />								</syntax>								<see-also>									<ref type="managerEvent">Agentlogin</ref>								</see-also>							</managerEventInstance>						***/						manager_event(EVENT_FLAG_AGENT, "Agentlogoff",							      "Agent: %s\r\n"							      "Logintime: %ld\r\n"							      "Uniqueid: %s\r\n",							      p->agent, logintime, ast_channel_uniqueid(chan));						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGOFF", "%s|%ld", ast_channel_name(chan), logintime);						ast_verb(2, "Agent '%s' logged out\n", p->agent);						/* If there is no owner, go ahead and kill it now */						ast_devstate_changed(AST_DEVICE_UNAVAILABLE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);						if (p->dead && !p->owner) {							ast_mutex_destroy(&p->lock);							ast_cond_destroy(&p->app_complete_cond);							ast_cond_destroy(&p->login_wait_cond);							ast_free(p);						}					}					else {						ast_mutex_unlock(&p->lock);						p = NULL;					}					res = -1;				} else {					ast_mutex_unlock(&p->lock);					errmsg = "agent-alreadyon";					p = NULL;				}				break;			}			ast_mutex_unlock(&p->lock);			if (unlock_channel) {				ast_channel_unlock(chan);			}		}		if (!p)			AST_LIST_UNLOCK(&agents);		if (!res && (max_login_tries==0 || tries < max_login_tries))			res = ast_app_getdata(chan, errmsg, user, sizeof(user) - 1, 0);	}
!res && (max_login_tries==0 || tries < max_login_tries)
!res
res
res
(max_login_tries==0 || tries < max_login_tries)
max_login_tries==0 || tries < max_login_tries
max_login_tries==0
max_login_tries
max_login_tries
0
tries < max_login_tries
tries
tries
max_login_tries
max_login_tries
{		tries++;		/* Check for password */		AST_LIST_LOCK(&agents);		AST_LIST_TRAVERSE(&agents, p, list) {			if (!strcmp(p->agent, user) && !p->pending)				ast_copy_string(xpass, p->password, sizeof(xpass));		}		AST_LIST_UNLOCK(&agents);		if (!res) {			if (!ast_strlen_zero(xpass))				res = ast_app_getdata(chan, "agent-pass", pass, sizeof(pass) - 1, 0);			else				pass[0] = '\0';		}		errmsg = "agent-incorrect";#if 0		ast_log(LOG_NOTICE, "user: %s, pass: %s\n", user, pass);#endif		/* Check again for accuracy */		AST_LIST_LOCK(&agents);		AST_LIST_TRAVERSE(&agents, p, list) {			int unlock_channel = 1;			ast_channel_lock(chan);			ast_mutex_lock(&p->lock);			if (!strcmp(p->agent, user) &&			    !strcmp(p->password, pass) && !p->pending) {				/* Ensure we can't be gotten until we're done */				p->lastdisc = ast_tvnow();				p->lastdisc.tv_sec++;				/* Set Channel Specific Agent Overrides */				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))) {					if (ast_true(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))) {						p->ackcall = 1;					} else {						p->ackcall = 0;					}					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTACKCALL");					ast_verb(3, "Saw variable AGENTACKCALL=%s, setting ackcall to: %d for Agent '%s'.\n", tmpoptions, p->ackcall, p->agent);					ast_set_flag(p, AGENT_FLAG_ACKCALL);				} else {					p->ackcall = ackcall;				}				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"))) {					p->autologoff = atoi(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"));					if (p->autologoff < 0)						p->autologoff = 0;					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF");					ast_verb(3, "Saw variable AGENTAUTOLOGOFF=%s, setting autologff to: %d for Agent '%s'.\n", tmpoptions, p->autologoff, p->agent);					ast_set_flag(p, AGENT_FLAG_AUTOLOGOFF);				} else {					p->autologoff = autologoff;				}				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"))) {					p->wrapuptime = atoi(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"));					if (p->wrapuptime < 0)						p->wrapuptime = 0;					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME");					ast_verb(3, "Saw variable AGENTWRAPUPTIME=%s, setting wrapuptime to: %d for Agent '%s'.\n", tmpoptions, p->wrapuptime, p->agent);					ast_set_flag(p, AGENT_FLAG_WRAPUPTIME);				} else {					p->wrapuptime = wrapuptime;				}				tmpoptions = pbx_builtin_getvar_helper(chan, "AGENTACCEPTDTMF");				if (!ast_strlen_zero(tmpoptions)) {					p->acceptdtmf = *tmpoptions;					ast_verb(3, "Saw variable AGENTACCEPTDTMF=%s, setting acceptdtmf to: %c for Agent '%s'.\n", tmpoptions, p->acceptdtmf, p->agent);					ast_set_flag(p, AGENT_FLAG_ACCEPTDTMF);				}				tmpoptions = pbx_builtin_getvar_helper(chan, "AGENTENDDTMF");				if (!ast_strlen_zero(tmpoptions)) {					p->enddtmf = *tmpoptions;					ast_verb(3, "Saw variable AGENTENDDTMF=%s, setting enddtmf to: %c for Agent '%s'.\n", tmpoptions, p->enddtmf, p->agent);					ast_set_flag(p, AGENT_FLAG_ENDDTMF);				}				ast_channel_unlock(chan);				unlock_channel = 0;				/* End Channel Specific Agent Overrides */				if (!p->chan) {					long logintime;					snprintf(agent, sizeof(agent), "Agent/%s", p->agent);					p->logincallerid[0] = '\0';					p->acknowledged = 0;					ast_mutex_unlock(&p->lock);					AST_LIST_UNLOCK(&agents);					if( !res && play_announcement==1 )						res = ast_streamfile(chan, filename, ast_channel_language(chan));					if (!res)						ast_waitstream(chan, "");					AST_LIST_LOCK(&agents);					ast_mutex_lock(&p->lock);					if (!res) {						struct ast_format tmpfmt;						res = ast_set_read_format_from_cap(chan, ast_channel_nativeformats(chan));						if (res) {							ast_log(LOG_WARNING, "Unable to set read format to %s\n", ast_getformatname(&tmpfmt));						}					}					if (!res) {						struct ast_format tmpfmt;						res = ast_set_write_format_from_cap(chan, ast_channel_nativeformats(chan));						if (res) {							ast_log(LOG_WARNING, "Unable to set write format to %s\n", ast_getformatname(&tmpfmt));						}					}					/* Check once more just in case */					if (p->chan)						res = -1;					if (!res) {						ast_indicate_data(chan, AST_CONTROL_HOLD,							S_OR(p->moh, NULL),							!ast_strlen_zero(p->moh) ? strlen(p->moh) + 1 : 0);						if (p->loginstart == 0)							time(&p->loginstart);						/*** DOCUMENTATION							<managerEventInstance>								<synopsis>Raised when an Agent has logged in.</synopsis>								<syntax>									<parameter name="Agent">										<para>The name of the agent.</para>									</parameter>								</syntax>								<see-also>									<ref type="application">AgentLogin</ref>									<ref type="managerEvent">Agentlogoff</ref>								</see-also>							</managerEventInstance>						***/						manager_event(EVENT_FLAG_AGENT, "Agentlogin",							      "Agent: %s\r\n"							      "Channel: %s\r\n"							      "Uniqueid: %s\r\n",							      p->agent, ast_channel_name(chan), ast_channel_uniqueid(chan));						if (update_cdr && ast_channel_cdr(chan))							snprintf(ast_channel_cdr(chan)->channel, sizeof(ast_channel_cdr(chan)->channel), "Agent/%s", p->agent);						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGIN", "%s", ast_channel_name(chan));						ast_verb(2, "Agent '%s' logged in (format %s/%s)\n", p->agent,								    ast_getformatname(ast_channel_readformat(chan)), ast_getformatname(ast_channel_writeformat(chan)));						/* Login this channel and wait for it to go away */						p->chan = chan;						if (p->ackcall) {							check_beep(p, 0);						} else {							check_availability(p, 0);						}						ast_mutex_unlock(&p->lock);						AST_LIST_UNLOCK(&agents);						ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);						while (res >= 0) {							ast_mutex_lock(&p->lock);							if (p->deferlogoff && p->chan) {								ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);								p->deferlogoff = 0;							}							if (p->chan != chan)								res = -1;							ast_mutex_unlock(&p->lock);							/* Yield here so other interested threads can kick in. */							sched_yield();							if (res)								break;							AST_LIST_LOCK(&agents);							ast_mutex_lock(&p->lock);							if (p->lastdisc.tv_sec) {								if (ast_tvdiff_ms(ast_tvnow(), p->lastdisc) > 0) {									ast_debug(1, "Wrapup time for %s expired!\n", p->agent);									p->lastdisc = ast_tv(0, 0);									ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);									if (p->ackcall) {										check_beep(p, 0);									} else {										check_availability(p, 0);									}								}							}							ast_mutex_unlock(&p->lock);							AST_LIST_UNLOCK(&agents);							/*	Synchronize channel ownership between call to agent and itself. */							ast_mutex_lock(&p->lock);							if (p->app_lock_flag == 1) {								ast_cond_signal(&p->login_wait_cond);								ast_cond_wait(&p->app_complete_cond, &p->lock);							}							ast_mutex_unlock(&p->lock);							if (p->ackcall) {								res = agent_ack_sleep(p);							} else {								res = ast_safe_sleep_conditional( chan, 1000, agent_cont_sleep, p );							}							if (p->ackcall && (res == 1)) {								AST_LIST_LOCK(&agents);								ast_mutex_lock(&p->lock);								check_availability(p, 0);								ast_mutex_unlock(&p->lock);								AST_LIST_UNLOCK(&agents);								res = 0;							}							sched_yield();						}						ast_mutex_lock(&p->lock);						/* Log us off if appropriate */						if (p->chan == chan) {							p->chan = NULL;						}						/* Synchronize channel ownership between call to agent and itself. */						if (p->app_lock_flag == 1) {							ast_cond_signal(&p->login_wait_cond);							ast_cond_wait(&p->app_complete_cond, &p->lock);						}						if (res && p->owner)							ast_log(LOG_WARNING, "Huh?  We broke out when there was still an owner?\n");						p->acknowledged = 0;						logintime = time(NULL) - p->loginstart;						p->loginstart = 0;						ast_mutex_unlock(&p->lock);						/*** DOCUMENTATION							<managerEventInstance>								<synopsis>Raised when an Agent has logged off.</synopsis>								<syntax>									<xi:include xpointer="xpointer(/docs/managerEvent[@name='Agentlogin']/managerEventInstance/syntax/parameter[@name='Agent'])" />								</syntax>								<see-also>									<ref type="managerEvent">Agentlogin</ref>								</see-also>							</managerEventInstance>						***/						manager_event(EVENT_FLAG_AGENT, "Agentlogoff",							      "Agent: %s\r\n"							      "Logintime: %ld\r\n"							      "Uniqueid: %s\r\n",							      p->agent, logintime, ast_channel_uniqueid(chan));						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGOFF", "%s|%ld", ast_channel_name(chan), logintime);						ast_verb(2, "Agent '%s' logged out\n", p->agent);						/* If there is no owner, go ahead and kill it now */						ast_devstate_changed(AST_DEVICE_UNAVAILABLE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);						if (p->dead && !p->owner) {							ast_mutex_destroy(&p->lock);							ast_cond_destroy(&p->app_complete_cond);							ast_cond_destroy(&p->login_wait_cond);							ast_free(p);						}					}					else {						ast_mutex_unlock(&p->lock);						p = NULL;					}					res = -1;				} else {					ast_mutex_unlock(&p->lock);					errmsg = "agent-alreadyon";					p = NULL;				}				break;			}			ast_mutex_unlock(&p->lock);			if (unlock_channel) {				ast_channel_unlock(chan);			}		}		if (!p)			AST_LIST_UNLOCK(&agents);		if (!res && (max_login_tries==0 || tries < max_login_tries))			res = ast_app_getdata(chan, errmsg, user, sizeof(user) - 1, 0);	}
tries++;
tries++
tries
tries
AST_LIST_LOCK(&agents);
AST_LIST_LOCK(&agents);
AST_LIST_LOCK
AST_LIST_LOCK
(&agents)
&agents
&
agents
AST_LIST_TRAVERSE(&agents, p, list)
AST_LIST_TRAVERSE(&agents, p, list)
AST_LIST_TRAVERSE
AST_LIST_TRAVERSE
&agents
agents
agents
p
p
list
list
)
{			if (!strcmp(p->agent, user) && !p->pending)				ast_copy_string(xpass, p->password, sizeof(xpass));		}
if (!strcmp(p->agent, user) && !p->pending)				ast_copy_string(xpass, p->password, sizeof(xpass));
!strcmp(p->agent, user) && !p->pending
!strcmp(p->agent, user)
strcmp(p->agent, user)
strcmp
strcmp
p->agent
p
p
agent
user
user
!p->pending
p->pending
p
p
pending
ast_copy_string(xpass, p->password, sizeof(xpass));
ast_copy_string(xpass, p->password, sizeof(xpass))
ast_copy_string
ast_copy_string
xpass
xpass
p->password
p
p
password
sizeof(xpass)
(xpass)
xpass
xpass
AST_LIST_UNLOCK(&agents);
AST_LIST_UNLOCK(&agents)
AST_LIST_UNLOCK
AST_LIST_UNLOCK
&agents
agents
agents
if (!res) {			if (!ast_strlen_zero(xpass))				res = ast_app_getdata(chan, "agent-pass", pass, sizeof(pass) - 1, 0);			else				pass[0] = '\0';		}
!res
res
res
{			if (!ast_strlen_zero(xpass))				res = ast_app_getdata(chan, "agent-pass", pass, sizeof(pass) - 1, 0);			else				pass[0] = '\0';		}
if (!ast_strlen_zero(xpass))				res = ast_app_getdata(chan, "agent-pass", pass, sizeof(pass) - 1, 0);			else				pass[0] = '\0';
!ast_strlen_zero(xpass)
ast_strlen_zero(xpass)
ast_strlen_zero
ast_strlen_zero
xpass
xpass
res = ast_app_getdata(chan, "agent-pass", pass, sizeof(pass) - 1, 0);
res = ast_app_getdata(chan, "agent-pass", pass, sizeof(pass) - 1, 0)
res
res
ast_app_getdata(chan, "agent-pass", pass, sizeof(pass) - 1, 0)
ast_app_getdata
ast_app_getdata
chan
chan
"agent-pass"
pass
pass
sizeof(pass) - 1
sizeof(pass)
(pass)
pass
pass
1
0
pass[0] = '\0';
pass[0] = '\0'
pass[0]
pass
pass
0
'\0'
errmsg = "agent-incorrect";
errmsg = "agent-incorrect"
errmsg
errmsg
"agent-incorrect"
AST_LIST_LOCK(&agents);
AST_LIST_LOCK(&agents)
AST_LIST_LOCK
AST_LIST_LOCK
&agents
agents
agents
AST_LIST_TRAVERSE(&agents, p, list)
AST_LIST_TRAVERSE(&agents, p, list)
AST_LIST_TRAVERSE
AST_LIST_TRAVERSE
&agents
agents
agents
p
p
list
list
)
{			int unlock_channel = 1;			ast_channel_lock(chan);			ast_mutex_lock(&p->lock);			if (!strcmp(p->agent, user) &&			    !strcmp(p->password, pass) && !p->pending) {				/* Ensure we can't be gotten until we're done */				p->lastdisc = ast_tvnow();				p->lastdisc.tv_sec++;				/* Set Channel Specific Agent Overrides */				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))) {					if (ast_true(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))) {						p->ackcall = 1;					} else {						p->ackcall = 0;					}					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTACKCALL");					ast_verb(3, "Saw variable AGENTACKCALL=%s, setting ackcall to: %d for Agent '%s'.\n", tmpoptions, p->ackcall, p->agent);					ast_set_flag(p, AGENT_FLAG_ACKCALL);				} else {					p->ackcall = ackcall;				}				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"))) {					p->autologoff = atoi(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"));					if (p->autologoff < 0)						p->autologoff = 0;					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF");					ast_verb(3, "Saw variable AGENTAUTOLOGOFF=%s, setting autologff to: %d for Agent '%s'.\n", tmpoptions, p->autologoff, p->agent);					ast_set_flag(p, AGENT_FLAG_AUTOLOGOFF);				} else {					p->autologoff = autologoff;				}				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"))) {					p->wrapuptime = atoi(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"));					if (p->wrapuptime < 0)						p->wrapuptime = 0;					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME");					ast_verb(3, "Saw variable AGENTWRAPUPTIME=%s, setting wrapuptime to: %d for Agent '%s'.\n", tmpoptions, p->wrapuptime, p->agent);					ast_set_flag(p, AGENT_FLAG_WRAPUPTIME);				} else {					p->wrapuptime = wrapuptime;				}				tmpoptions = pbx_builtin_getvar_helper(chan, "AGENTACCEPTDTMF");				if (!ast_strlen_zero(tmpoptions)) {					p->acceptdtmf = *tmpoptions;					ast_verb(3, "Saw variable AGENTACCEPTDTMF=%s, setting acceptdtmf to: %c for Agent '%s'.\n", tmpoptions, p->acceptdtmf, p->agent);					ast_set_flag(p, AGENT_FLAG_ACCEPTDTMF);				}				tmpoptions = pbx_builtin_getvar_helper(chan, "AGENTENDDTMF");				if (!ast_strlen_zero(tmpoptions)) {					p->enddtmf = *tmpoptions;					ast_verb(3, "Saw variable AGENTENDDTMF=%s, setting enddtmf to: %c for Agent '%s'.\n", tmpoptions, p->enddtmf, p->agent);					ast_set_flag(p, AGENT_FLAG_ENDDTMF);				}				ast_channel_unlock(chan);				unlock_channel = 0;				/* End Channel Specific Agent Overrides */				if (!p->chan) {					long logintime;					snprintf(agent, sizeof(agent), "Agent/%s", p->agent);					p->logincallerid[0] = '\0';					p->acknowledged = 0;					ast_mutex_unlock(&p->lock);					AST_LIST_UNLOCK(&agents);					if( !res && play_announcement==1 )						res = ast_streamfile(chan, filename, ast_channel_language(chan));					if (!res)						ast_waitstream(chan, "");					AST_LIST_LOCK(&agents);					ast_mutex_lock(&p->lock);					if (!res) {						struct ast_format tmpfmt;						res = ast_set_read_format_from_cap(chan, ast_channel_nativeformats(chan));						if (res) {							ast_log(LOG_WARNING, "Unable to set read format to %s\n", ast_getformatname(&tmpfmt));						}					}					if (!res) {						struct ast_format tmpfmt;						res = ast_set_write_format_from_cap(chan, ast_channel_nativeformats(chan));						if (res) {							ast_log(LOG_WARNING, "Unable to set write format to %s\n", ast_getformatname(&tmpfmt));						}					}					/* Check once more just in case */					if (p->chan)						res = -1;					if (!res) {						ast_indicate_data(chan, AST_CONTROL_HOLD,							S_OR(p->moh, NULL),							!ast_strlen_zero(p->moh) ? strlen(p->moh) + 1 : 0);						if (p->loginstart == 0)							time(&p->loginstart);						/*** DOCUMENTATION							<managerEventInstance>								<synopsis>Raised when an Agent has logged in.</synopsis>								<syntax>									<parameter name="Agent">										<para>The name of the agent.</para>									</parameter>								</syntax>								<see-also>									<ref type="application">AgentLogin</ref>									<ref type="managerEvent">Agentlogoff</ref>								</see-also>							</managerEventInstance>						***/						manager_event(EVENT_FLAG_AGENT, "Agentlogin",							      "Agent: %s\r\n"							      "Channel: %s\r\n"							      "Uniqueid: %s\r\n",							      p->agent, ast_channel_name(chan), ast_channel_uniqueid(chan));						if (update_cdr && ast_channel_cdr(chan))							snprintf(ast_channel_cdr(chan)->channel, sizeof(ast_channel_cdr(chan)->channel), "Agent/%s", p->agent);						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGIN", "%s", ast_channel_name(chan));						ast_verb(2, "Agent '%s' logged in (format %s/%s)\n", p->agent,								    ast_getformatname(ast_channel_readformat(chan)), ast_getformatname(ast_channel_writeformat(chan)));						/* Login this channel and wait for it to go away */						p->chan = chan;						if (p->ackcall) {							check_beep(p, 0);						} else {							check_availability(p, 0);						}						ast_mutex_unlock(&p->lock);						AST_LIST_UNLOCK(&agents);						ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);						while (res >= 0) {							ast_mutex_lock(&p->lock);							if (p->deferlogoff && p->chan) {								ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);								p->deferlogoff = 0;							}							if (p->chan != chan)								res = -1;							ast_mutex_unlock(&p->lock);							/* Yield here so other interested threads can kick in. */							sched_yield();							if (res)								break;							AST_LIST_LOCK(&agents);							ast_mutex_lock(&p->lock);							if (p->lastdisc.tv_sec) {								if (ast_tvdiff_ms(ast_tvnow(), p->lastdisc) > 0) {									ast_debug(1, "Wrapup time for %s expired!\n", p->agent);									p->lastdisc = ast_tv(0, 0);									ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);									if (p->ackcall) {										check_beep(p, 0);									} else {										check_availability(p, 0);									}								}							}							ast_mutex_unlock(&p->lock);							AST_LIST_UNLOCK(&agents);							/*	Synchronize channel ownership between call to agent and itself. */							ast_mutex_lock(&p->lock);							if (p->app_lock_flag == 1) {								ast_cond_signal(&p->login_wait_cond);								ast_cond_wait(&p->app_complete_cond, &p->lock);							}							ast_mutex_unlock(&p->lock);							if (p->ackcall) {								res = agent_ack_sleep(p);							} else {								res = ast_safe_sleep_conditional( chan, 1000, agent_cont_sleep, p );							}							if (p->ackcall && (res == 1)) {								AST_LIST_LOCK(&agents);								ast_mutex_lock(&p->lock);								check_availability(p, 0);								ast_mutex_unlock(&p->lock);								AST_LIST_UNLOCK(&agents);								res = 0;							}							sched_yield();						}						ast_mutex_lock(&p->lock);						/* Log us off if appropriate */						if (p->chan == chan) {							p->chan = NULL;						}						/* Synchronize channel ownership between call to agent and itself. */						if (p->app_lock_flag == 1) {							ast_cond_signal(&p->login_wait_cond);							ast_cond_wait(&p->app_complete_cond, &p->lock);						}						if (res && p->owner)							ast_log(LOG_WARNING, "Huh?  We broke out when there was still an owner?\n");						p->acknowledged = 0;						logintime = time(NULL) - p->loginstart;						p->loginstart = 0;						ast_mutex_unlock(&p->lock);						/*** DOCUMENTATION							<managerEventInstance>								<synopsis>Raised when an Agent has logged off.</synopsis>								<syntax>									<xi:include xpointer="xpointer(/docs/managerEvent[@name='Agentlogin']/managerEventInstance/syntax/parameter[@name='Agent'])" />								</syntax>								<see-also>									<ref type="managerEvent">Agentlogin</ref>								</see-also>							</managerEventInstance>						***/						manager_event(EVENT_FLAG_AGENT, "Agentlogoff",							      "Agent: %s\r\n"							      "Logintime: %ld\r\n"							      "Uniqueid: %s\r\n",							      p->agent, logintime, ast_channel_uniqueid(chan));						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGOFF", "%s|%ld", ast_channel_name(chan), logintime);						ast_verb(2, "Agent '%s' logged out\n", p->agent);						/* If there is no owner, go ahead and kill it now */						ast_devstate_changed(AST_DEVICE_UNAVAILABLE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);						if (p->dead && !p->owner) {							ast_mutex_destroy(&p->lock);							ast_cond_destroy(&p->app_complete_cond);							ast_cond_destroy(&p->login_wait_cond);							ast_free(p);						}					}					else {						ast_mutex_unlock(&p->lock);						p = NULL;					}					res = -1;				} else {					ast_mutex_unlock(&p->lock);					errmsg = "agent-alreadyon";					p = NULL;				}				break;			}			ast_mutex_unlock(&p->lock);			if (unlock_channel) {				ast_channel_unlock(chan);			}		}
int unlock_channel = 1;
int unlock_channel = 1;
int
unlock_channel = 1
unlock_channel
= 1
1
ast_channel_lock(chan);
ast_channel_lock(chan)
ast_channel_lock
ast_channel_lock
chan
chan
ast_mutex_lock(&p->lock);
ast_mutex_lock(&p->lock)
ast_mutex_lock
ast_mutex_lock
&p->lock
p->lock
p
p
lock
if (!strcmp(p->agent, user) &&			    !strcmp(p->password, pass) && !p->pending) {				/* Ensure we can't be gotten until we're done */				p->lastdisc = ast_tvnow();				p->lastdisc.tv_sec++;				/* Set Channel Specific Agent Overrides */				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))) {					if (ast_true(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))) {						p->ackcall = 1;					} else {						p->ackcall = 0;					}					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTACKCALL");					ast_verb(3, "Saw variable AGENTACKCALL=%s, setting ackcall to: %d for Agent '%s'.\n", tmpoptions, p->ackcall, p->agent);					ast_set_flag(p, AGENT_FLAG_ACKCALL);				} else {					p->ackcall = ackcall;				}				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"))) {					p->autologoff = atoi(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"));					if (p->autologoff < 0)						p->autologoff = 0;					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF");					ast_verb(3, "Saw variable AGENTAUTOLOGOFF=%s, setting autologff to: %d for Agent '%s'.\n", tmpoptions, p->autologoff, p->agent);					ast_set_flag(p, AGENT_FLAG_AUTOLOGOFF);				} else {					p->autologoff = autologoff;				}				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"))) {					p->wrapuptime = atoi(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"));					if (p->wrapuptime < 0)						p->wrapuptime = 0;					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME");					ast_verb(3, "Saw variable AGENTWRAPUPTIME=%s, setting wrapuptime to: %d for Agent '%s'.\n", tmpoptions, p->wrapuptime, p->agent);					ast_set_flag(p, AGENT_FLAG_WRAPUPTIME);				} else {					p->wrapuptime = wrapuptime;				}				tmpoptions = pbx_builtin_getvar_helper(chan, "AGENTACCEPTDTMF");				if (!ast_strlen_zero(tmpoptions)) {					p->acceptdtmf = *tmpoptions;					ast_verb(3, "Saw variable AGENTACCEPTDTMF=%s, setting acceptdtmf to: %c for Agent '%s'.\n", tmpoptions, p->acceptdtmf, p->agent);					ast_set_flag(p, AGENT_FLAG_ACCEPTDTMF);				}				tmpoptions = pbx_builtin_getvar_helper(chan, "AGENTENDDTMF");				if (!ast_strlen_zero(tmpoptions)) {					p->enddtmf = *tmpoptions;					ast_verb(3, "Saw variable AGENTENDDTMF=%s, setting enddtmf to: %c for Agent '%s'.\n", tmpoptions, p->enddtmf, p->agent);					ast_set_flag(p, AGENT_FLAG_ENDDTMF);				}				ast_channel_unlock(chan);				unlock_channel = 0;				/* End Channel Specific Agent Overrides */				if (!p->chan) {					long logintime;					snprintf(agent, sizeof(agent), "Agent/%s", p->agent);					p->logincallerid[0] = '\0';					p->acknowledged = 0;					ast_mutex_unlock(&p->lock);					AST_LIST_UNLOCK(&agents);					if( !res && play_announcement==1 )						res = ast_streamfile(chan, filename, ast_channel_language(chan));					if (!res)						ast_waitstream(chan, "");					AST_LIST_LOCK(&agents);					ast_mutex_lock(&p->lock);					if (!res) {						struct ast_format tmpfmt;						res = ast_set_read_format_from_cap(chan, ast_channel_nativeformats(chan));						if (res) {							ast_log(LOG_WARNING, "Unable to set read format to %s\n", ast_getformatname(&tmpfmt));						}					}					if (!res) {						struct ast_format tmpfmt;						res = ast_set_write_format_from_cap(chan, ast_channel_nativeformats(chan));						if (res) {							ast_log(LOG_WARNING, "Unable to set write format to %s\n", ast_getformatname(&tmpfmt));						}					}					/* Check once more just in case */					if (p->chan)						res = -1;					if (!res) {						ast_indicate_data(chan, AST_CONTROL_HOLD,							S_OR(p->moh, NULL),							!ast_strlen_zero(p->moh) ? strlen(p->moh) + 1 : 0);						if (p->loginstart == 0)							time(&p->loginstart);						/*** DOCUMENTATION							<managerEventInstance>								<synopsis>Raised when an Agent has logged in.</synopsis>								<syntax>									<parameter name="Agent">										<para>The name of the agent.</para>									</parameter>								</syntax>								<see-also>									<ref type="application">AgentLogin</ref>									<ref type="managerEvent">Agentlogoff</ref>								</see-also>							</managerEventInstance>						***/						manager_event(EVENT_FLAG_AGENT, "Agentlogin",							      "Agent: %s\r\n"							      "Channel: %s\r\n"							      "Uniqueid: %s\r\n",							      p->agent, ast_channel_name(chan), ast_channel_uniqueid(chan));						if (update_cdr && ast_channel_cdr(chan))							snprintf(ast_channel_cdr(chan)->channel, sizeof(ast_channel_cdr(chan)->channel), "Agent/%s", p->agent);						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGIN", "%s", ast_channel_name(chan));						ast_verb(2, "Agent '%s' logged in (format %s/%s)\n", p->agent,								    ast_getformatname(ast_channel_readformat(chan)), ast_getformatname(ast_channel_writeformat(chan)));						/* Login this channel and wait for it to go away */						p->chan = chan;						if (p->ackcall) {							check_beep(p, 0);						} else {							check_availability(p, 0);						}						ast_mutex_unlock(&p->lock);						AST_LIST_UNLOCK(&agents);						ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);						while (res >= 0) {							ast_mutex_lock(&p->lock);							if (p->deferlogoff && p->chan) {								ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);								p->deferlogoff = 0;							}							if (p->chan != chan)								res = -1;							ast_mutex_unlock(&p->lock);							/* Yield here so other interested threads can kick in. */							sched_yield();							if (res)								break;							AST_LIST_LOCK(&agents);							ast_mutex_lock(&p->lock);							if (p->lastdisc.tv_sec) {								if (ast_tvdiff_ms(ast_tvnow(), p->lastdisc) > 0) {									ast_debug(1, "Wrapup time for %s expired!\n", p->agent);									p->lastdisc = ast_tv(0, 0);									ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);									if (p->ackcall) {										check_beep(p, 0);									} else {										check_availability(p, 0);									}								}							}							ast_mutex_unlock(&p->lock);							AST_LIST_UNLOCK(&agents);							/*	Synchronize channel ownership between call to agent and itself. */							ast_mutex_lock(&p->lock);							if (p->app_lock_flag == 1) {								ast_cond_signal(&p->login_wait_cond);								ast_cond_wait(&p->app_complete_cond, &p->lock);							}							ast_mutex_unlock(&p->lock);							if (p->ackcall) {								res = agent_ack_sleep(p);							} else {								res = ast_safe_sleep_conditional( chan, 1000, agent_cont_sleep, p );							}							if (p->ackcall && (res == 1)) {								AST_LIST_LOCK(&agents);								ast_mutex_lock(&p->lock);								check_availability(p, 0);								ast_mutex_unlock(&p->lock);								AST_LIST_UNLOCK(&agents);								res = 0;							}							sched_yield();						}						ast_mutex_lock(&p->lock);						/* Log us off if appropriate */						if (p->chan == chan) {							p->chan = NULL;						}						/* Synchronize channel ownership between call to agent and itself. */						if (p->app_lock_flag == 1) {							ast_cond_signal(&p->login_wait_cond);							ast_cond_wait(&p->app_complete_cond, &p->lock);						}						if (res && p->owner)							ast_log(LOG_WARNING, "Huh?  We broke out when there was still an owner?\n");						p->acknowledged = 0;						logintime = time(NULL) - p->loginstart;						p->loginstart = 0;						ast_mutex_unlock(&p->lock);						/*** DOCUMENTATION							<managerEventInstance>								<synopsis>Raised when an Agent has logged off.</synopsis>								<syntax>									<xi:include xpointer="xpointer(/docs/managerEvent[@name='Agentlogin']/managerEventInstance/syntax/parameter[@name='Agent'])" />								</syntax>								<see-also>									<ref type="managerEvent">Agentlogin</ref>								</see-also>							</managerEventInstance>						***/						manager_event(EVENT_FLAG_AGENT, "Agentlogoff",							      "Agent: %s\r\n"							      "Logintime: %ld\r\n"							      "Uniqueid: %s\r\n",							      p->agent, logintime, ast_channel_uniqueid(chan));						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGOFF", "%s|%ld", ast_channel_name(chan), logintime);						ast_verb(2, "Agent '%s' logged out\n", p->agent);						/* If there is no owner, go ahead and kill it now */						ast_devstate_changed(AST_DEVICE_UNAVAILABLE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);						if (p->dead && !p->owner) {							ast_mutex_destroy(&p->lock);							ast_cond_destroy(&p->app_complete_cond);							ast_cond_destroy(&p->login_wait_cond);							ast_free(p);						}					}					else {						ast_mutex_unlock(&p->lock);						p = NULL;					}					res = -1;				} else {					ast_mutex_unlock(&p->lock);					errmsg = "agent-alreadyon";					p = NULL;				}				break;			}
!strcmp(p->agent, user) &&			    !strcmp(p->password, pass) && !p->pending
!strcmp(p->agent, user) &&			    !strcmp(p->password, pass)
!strcmp(p->agent, user)
strcmp(p->agent, user)
strcmp
strcmp
p->agent
p
p
agent
user
user
!strcmp(p->password, pass)
strcmp(p->password, pass)
strcmp
strcmp
p->password
p
p
password
pass
pass
!p->pending
p->pending
p
p
pending
{				/* Ensure we can't be gotten until we're done */				p->lastdisc = ast_tvnow();				p->lastdisc.tv_sec++;				/* Set Channel Specific Agent Overrides */				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))) {					if (ast_true(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))) {						p->ackcall = 1;					} else {						p->ackcall = 0;					}					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTACKCALL");					ast_verb(3, "Saw variable AGENTACKCALL=%s, setting ackcall to: %d for Agent '%s'.\n", tmpoptions, p->ackcall, p->agent);					ast_set_flag(p, AGENT_FLAG_ACKCALL);				} else {					p->ackcall = ackcall;				}				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"))) {					p->autologoff = atoi(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"));					if (p->autologoff < 0)						p->autologoff = 0;					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF");					ast_verb(3, "Saw variable AGENTAUTOLOGOFF=%s, setting autologff to: %d for Agent '%s'.\n", tmpoptions, p->autologoff, p->agent);					ast_set_flag(p, AGENT_FLAG_AUTOLOGOFF);				} else {					p->autologoff = autologoff;				}				if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"))) {					p->wrapuptime = atoi(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"));					if (p->wrapuptime < 0)						p->wrapuptime = 0;					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME");					ast_verb(3, "Saw variable AGENTWRAPUPTIME=%s, setting wrapuptime to: %d for Agent '%s'.\n", tmpoptions, p->wrapuptime, p->agent);					ast_set_flag(p, AGENT_FLAG_WRAPUPTIME);				} else {					p->wrapuptime = wrapuptime;				}				tmpoptions = pbx_builtin_getvar_helper(chan, "AGENTACCEPTDTMF");				if (!ast_strlen_zero(tmpoptions)) {					p->acceptdtmf = *tmpoptions;					ast_verb(3, "Saw variable AGENTACCEPTDTMF=%s, setting acceptdtmf to: %c for Agent '%s'.\n", tmpoptions, p->acceptdtmf, p->agent);					ast_set_flag(p, AGENT_FLAG_ACCEPTDTMF);				}				tmpoptions = pbx_builtin_getvar_helper(chan, "AGENTENDDTMF");				if (!ast_strlen_zero(tmpoptions)) {					p->enddtmf = *tmpoptions;					ast_verb(3, "Saw variable AGENTENDDTMF=%s, setting enddtmf to: %c for Agent '%s'.\n", tmpoptions, p->enddtmf, p->agent);					ast_set_flag(p, AGENT_FLAG_ENDDTMF);				}				ast_channel_unlock(chan);				unlock_channel = 0;				/* End Channel Specific Agent Overrides */				if (!p->chan) {					long logintime;					snprintf(agent, sizeof(agent), "Agent/%s", p->agent);					p->logincallerid[0] = '\0';					p->acknowledged = 0;					ast_mutex_unlock(&p->lock);					AST_LIST_UNLOCK(&agents);					if( !res && play_announcement==1 )						res = ast_streamfile(chan, filename, ast_channel_language(chan));					if (!res)						ast_waitstream(chan, "");					AST_LIST_LOCK(&agents);					ast_mutex_lock(&p->lock);					if (!res) {						struct ast_format tmpfmt;						res = ast_set_read_format_from_cap(chan, ast_channel_nativeformats(chan));						if (res) {							ast_log(LOG_WARNING, "Unable to set read format to %s\n", ast_getformatname(&tmpfmt));						}					}					if (!res) {						struct ast_format tmpfmt;						res = ast_set_write_format_from_cap(chan, ast_channel_nativeformats(chan));						if (res) {							ast_log(LOG_WARNING, "Unable to set write format to %s\n", ast_getformatname(&tmpfmt));						}					}					/* Check once more just in case */					if (p->chan)						res = -1;					if (!res) {						ast_indicate_data(chan, AST_CONTROL_HOLD,							S_OR(p->moh, NULL),							!ast_strlen_zero(p->moh) ? strlen(p->moh) + 1 : 0);						if (p->loginstart == 0)							time(&p->loginstart);						/*** DOCUMENTATION							<managerEventInstance>								<synopsis>Raised when an Agent has logged in.</synopsis>								<syntax>									<parameter name="Agent">										<para>The name of the agent.</para>									</parameter>								</syntax>								<see-also>									<ref type="application">AgentLogin</ref>									<ref type="managerEvent">Agentlogoff</ref>								</see-also>							</managerEventInstance>						***/						manager_event(EVENT_FLAG_AGENT, "Agentlogin",							      "Agent: %s\r\n"							      "Channel: %s\r\n"							      "Uniqueid: %s\r\n",							      p->agent, ast_channel_name(chan), ast_channel_uniqueid(chan));						if (update_cdr && ast_channel_cdr(chan))							snprintf(ast_channel_cdr(chan)->channel, sizeof(ast_channel_cdr(chan)->channel), "Agent/%s", p->agent);						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGIN", "%s", ast_channel_name(chan));						ast_verb(2, "Agent '%s' logged in (format %s/%s)\n", p->agent,								    ast_getformatname(ast_channel_readformat(chan)), ast_getformatname(ast_channel_writeformat(chan)));						/* Login this channel and wait for it to go away */						p->chan = chan;						if (p->ackcall) {							check_beep(p, 0);						} else {							check_availability(p, 0);						}						ast_mutex_unlock(&p->lock);						AST_LIST_UNLOCK(&agents);						ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);						while (res >= 0) {							ast_mutex_lock(&p->lock);							if (p->deferlogoff && p->chan) {								ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);								p->deferlogoff = 0;							}							if (p->chan != chan)								res = -1;							ast_mutex_unlock(&p->lock);							/* Yield here so other interested threads can kick in. */							sched_yield();							if (res)								break;							AST_LIST_LOCK(&agents);							ast_mutex_lock(&p->lock);							if (p->lastdisc.tv_sec) {								if (ast_tvdiff_ms(ast_tvnow(), p->lastdisc) > 0) {									ast_debug(1, "Wrapup time for %s expired!\n", p->agent);									p->lastdisc = ast_tv(0, 0);									ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);									if (p->ackcall) {										check_beep(p, 0);									} else {										check_availability(p, 0);									}								}							}							ast_mutex_unlock(&p->lock);							AST_LIST_UNLOCK(&agents);							/*	Synchronize channel ownership between call to agent and itself. */							ast_mutex_lock(&p->lock);							if (p->app_lock_flag == 1) {								ast_cond_signal(&p->login_wait_cond);								ast_cond_wait(&p->app_complete_cond, &p->lock);							}							ast_mutex_unlock(&p->lock);							if (p->ackcall) {								res = agent_ack_sleep(p);							} else {								res = ast_safe_sleep_conditional( chan, 1000, agent_cont_sleep, p );							}							if (p->ackcall && (res == 1)) {								AST_LIST_LOCK(&agents);								ast_mutex_lock(&p->lock);								check_availability(p, 0);								ast_mutex_unlock(&p->lock);								AST_LIST_UNLOCK(&agents);								res = 0;							}							sched_yield();						}						ast_mutex_lock(&p->lock);						/* Log us off if appropriate */						if (p->chan == chan) {							p->chan = NULL;						}						/* Synchronize channel ownership between call to agent and itself. */						if (p->app_lock_flag == 1) {							ast_cond_signal(&p->login_wait_cond);							ast_cond_wait(&p->app_complete_cond, &p->lock);						}						if (res && p->owner)							ast_log(LOG_WARNING, "Huh?  We broke out when there was still an owner?\n");						p->acknowledged = 0;						logintime = time(NULL) - p->loginstart;						p->loginstart = 0;						ast_mutex_unlock(&p->lock);						/*** DOCUMENTATION							<managerEventInstance>								<synopsis>Raised when an Agent has logged off.</synopsis>								<syntax>									<xi:include xpointer="xpointer(/docs/managerEvent[@name='Agentlogin']/managerEventInstance/syntax/parameter[@name='Agent'])" />								</syntax>								<see-also>									<ref type="managerEvent">Agentlogin</ref>								</see-also>							</managerEventInstance>						***/						manager_event(EVENT_FLAG_AGENT, "Agentlogoff",							      "Agent: %s\r\n"							      "Logintime: %ld\r\n"							      "Uniqueid: %s\r\n",							      p->agent, logintime, ast_channel_uniqueid(chan));						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGOFF", "%s|%ld", ast_channel_name(chan), logintime);						ast_verb(2, "Agent '%s' logged out\n", p->agent);						/* If there is no owner, go ahead and kill it now */						ast_devstate_changed(AST_DEVICE_UNAVAILABLE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);						if (p->dead && !p->owner) {							ast_mutex_destroy(&p->lock);							ast_cond_destroy(&p->app_complete_cond);							ast_cond_destroy(&p->login_wait_cond);							ast_free(p);						}					}					else {						ast_mutex_unlock(&p->lock);						p = NULL;					}					res = -1;				} else {					ast_mutex_unlock(&p->lock);					errmsg = "agent-alreadyon";					p = NULL;				}				break;			}
p->lastdisc = ast_tvnow();
p->lastdisc = ast_tvnow()
p->lastdisc
p
p
lastdisc
ast_tvnow()
ast_tvnow
ast_tvnow
p->lastdisc.tv_sec++;
p->lastdisc.tv_sec++
p->lastdisc.tv_sec
p->lastdisc
p
p
lastdisc
tv_sec
if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))) {					if (ast_true(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))) {						p->ackcall = 1;					} else {						p->ackcall = 0;					}					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTACKCALL");					ast_verb(3, "Saw variable AGENTACKCALL=%s, setting ackcall to: %d for Agent '%s'.\n", tmpoptions, p->ackcall, p->agent);					ast_set_flag(p, AGENT_FLAG_ACKCALL);				} else {					p->ackcall = ackcall;				}
!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))
ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))
ast_strlen_zero
ast_strlen_zero
pbx_builtin_getvar_helper(chan, "AGENTACKCALL")
pbx_builtin_getvar_helper
pbx_builtin_getvar_helper
chan
chan
"AGENTACKCALL"
{					if (ast_true(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))) {						p->ackcall = 1;					} else {						p->ackcall = 0;					}					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTACKCALL");					ast_verb(3, "Saw variable AGENTACKCALL=%s, setting ackcall to: %d for Agent '%s'.\n", tmpoptions, p->ackcall, p->agent);					ast_set_flag(p, AGENT_FLAG_ACKCALL);				}
if (ast_true(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))) {						p->ackcall = 1;					} else {						p->ackcall = 0;					}
ast_true(pbx_builtin_getvar_helper(chan, "AGENTACKCALL"))
ast_true
ast_true
pbx_builtin_getvar_helper(chan, "AGENTACKCALL")
pbx_builtin_getvar_helper
pbx_builtin_getvar_helper
chan
chan
"AGENTACKCALL"
{						p->ackcall = 1;					}
p->ackcall = 1;
p->ackcall = 1
p->ackcall
p
p
ackcall
1
{						p->ackcall = 0;					}
p->ackcall = 0;
p->ackcall = 0
p->ackcall
p
p
ackcall
0
tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTACKCALL");
tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTACKCALL")
tmpoptions
tmpoptions
pbx_builtin_getvar_helper(chan, "AGENTACKCALL")
pbx_builtin_getvar_helper
pbx_builtin_getvar_helper
chan
chan
"AGENTACKCALL"
ast_verb(3, "Saw variable AGENTACKCALL=%s, setting ackcall to: %d for Agent '%s'.\n", tmpoptions, p->ackcall, p->agent);
ast_verb(3, "Saw variable AGENTACKCALL=%s, setting ackcall to: %d for Agent '%s'.\n", tmpoptions, p->ackcall, p->agent)
ast_verb
ast_verb
3
"Saw variable AGENTACKCALL=%s, setting ackcall to: %d for Agent '%s'.\n"
tmpoptions
tmpoptions
p->ackcall
p
p
ackcall
p->agent
p
p
agent
ast_set_flag(p, AGENT_FLAG_ACKCALL);
ast_set_flag(p, AGENT_FLAG_ACKCALL)
ast_set_flag
ast_set_flag
p
p
AGENT_FLAG_ACKCALL
AGENT_FLAG_ACKCALL
{					p->ackcall = ackcall;				}
p->ackcall = ackcall;
p->ackcall = ackcall
p->ackcall
p
p
ackcall
ackcall
ackcall
if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"))) {					p->autologoff = atoi(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"));					if (p->autologoff < 0)						p->autologoff = 0;					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF");					ast_verb(3, "Saw variable AGENTAUTOLOGOFF=%s, setting autologff to: %d for Agent '%s'.\n", tmpoptions, p->autologoff, p->agent);					ast_set_flag(p, AGENT_FLAG_AUTOLOGOFF);				} else {					p->autologoff = autologoff;				}
!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"))
ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"))
ast_strlen_zero
ast_strlen_zero
pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF")
pbx_builtin_getvar_helper
pbx_builtin_getvar_helper
chan
chan
"AGENTAUTOLOGOFF"
{					p->autologoff = atoi(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"));					if (p->autologoff < 0)						p->autologoff = 0;					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF");					ast_verb(3, "Saw variable AGENTAUTOLOGOFF=%s, setting autologff to: %d for Agent '%s'.\n", tmpoptions, p->autologoff, p->agent);					ast_set_flag(p, AGENT_FLAG_AUTOLOGOFF);				}
p->autologoff = atoi(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"));
p->autologoff = atoi(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"))
p->autologoff
p
p
autologoff
atoi(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF"))
atoi
atoi
pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF")
pbx_builtin_getvar_helper
pbx_builtin_getvar_helper
chan
chan
"AGENTAUTOLOGOFF"
if (p->autologoff < 0)						p->autologoff = 0;
p->autologoff < 0
p->autologoff
p
p
autologoff
0
p->autologoff = 0;
p->autologoff = 0
p->autologoff
p
p
autologoff
0
tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF");
tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF")
tmpoptions
tmpoptions
pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF")
pbx_builtin_getvar_helper
pbx_builtin_getvar_helper
chan
chan
"AGENTAUTOLOGOFF"
ast_verb(3, "Saw variable AGENTAUTOLOGOFF=%s, setting autologff to: %d for Agent '%s'.\n", tmpoptions, p->autologoff, p->agent);
ast_verb(3, "Saw variable AGENTAUTOLOGOFF=%s, setting autologff to: %d for Agent '%s'.\n", tmpoptions, p->autologoff, p->agent)
ast_verb
ast_verb
3
"Saw variable AGENTAUTOLOGOFF=%s, setting autologff to: %d for Agent '%s'.\n"
tmpoptions
tmpoptions
p->autologoff
p
p
autologoff
p->agent
p
p
agent
ast_set_flag(p, AGENT_FLAG_AUTOLOGOFF);
ast_set_flag(p, AGENT_FLAG_AUTOLOGOFF)
ast_set_flag
ast_set_flag
p
p
AGENT_FLAG_AUTOLOGOFF
AGENT_FLAG_AUTOLOGOFF
{					p->autologoff = autologoff;				}
p->autologoff = autologoff;
p->autologoff = autologoff
p->autologoff
p
p
autologoff
autologoff
autologoff
if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"))) {					p->wrapuptime = atoi(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"));					if (p->wrapuptime < 0)						p->wrapuptime = 0;					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME");					ast_verb(3, "Saw variable AGENTWRAPUPTIME=%s, setting wrapuptime to: %d for Agent '%s'.\n", tmpoptions, p->wrapuptime, p->agent);					ast_set_flag(p, AGENT_FLAG_WRAPUPTIME);				} else {					p->wrapuptime = wrapuptime;				}
!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"))
ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"))
ast_strlen_zero
ast_strlen_zero
pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME")
pbx_builtin_getvar_helper
pbx_builtin_getvar_helper
chan
chan
"AGENTWRAPUPTIME"
{					p->wrapuptime = atoi(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"));					if (p->wrapuptime < 0)						p->wrapuptime = 0;					tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME");					ast_verb(3, "Saw variable AGENTWRAPUPTIME=%s, setting wrapuptime to: %d for Agent '%s'.\n", tmpoptions, p->wrapuptime, p->agent);					ast_set_flag(p, AGENT_FLAG_WRAPUPTIME);				}
p->wrapuptime = atoi(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"));
p->wrapuptime = atoi(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"))
p->wrapuptime
p
p
wrapuptime
atoi(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME"))
atoi
atoi
pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME")
pbx_builtin_getvar_helper
pbx_builtin_getvar_helper
chan
chan
"AGENTWRAPUPTIME"
if (p->wrapuptime < 0)						p->wrapuptime = 0;
p->wrapuptime < 0
p->wrapuptime
p
p
wrapuptime
0
p->wrapuptime = 0;
p->wrapuptime = 0
p->wrapuptime
p
p
wrapuptime
0
tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME");
tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME")
tmpoptions
tmpoptions
pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME")
pbx_builtin_getvar_helper
pbx_builtin_getvar_helper
chan
chan
"AGENTWRAPUPTIME"
ast_verb(3, "Saw variable AGENTWRAPUPTIME=%s, setting wrapuptime to: %d for Agent '%s'.\n", tmpoptions, p->wrapuptime, p->agent);
ast_verb(3, "Saw variable AGENTWRAPUPTIME=%s, setting wrapuptime to: %d for Agent '%s'.\n", tmpoptions, p->wrapuptime, p->agent)
ast_verb
ast_verb
3
"Saw variable AGENTWRAPUPTIME=%s, setting wrapuptime to: %d for Agent '%s'.\n"
tmpoptions
tmpoptions
p->wrapuptime
p
p
wrapuptime
p->agent
p
p
agent
ast_set_flag(p, AGENT_FLAG_WRAPUPTIME);
ast_set_flag(p, AGENT_FLAG_WRAPUPTIME)
ast_set_flag
ast_set_flag
p
p
AGENT_FLAG_WRAPUPTIME
AGENT_FLAG_WRAPUPTIME
{					p->wrapuptime = wrapuptime;				}
p->wrapuptime = wrapuptime;
p->wrapuptime = wrapuptime
p->wrapuptime
p
p
wrapuptime
wrapuptime
wrapuptime
tmpoptions = pbx_builtin_getvar_helper(chan, "AGENTACCEPTDTMF");
tmpoptions = pbx_builtin_getvar_helper(chan, "AGENTACCEPTDTMF")
tmpoptions
tmpoptions
pbx_builtin_getvar_helper(chan, "AGENTACCEPTDTMF")
pbx_builtin_getvar_helper
pbx_builtin_getvar_helper
chan
chan
"AGENTACCEPTDTMF"
if (!ast_strlen_zero(tmpoptions)) {					p->acceptdtmf = *tmpoptions;					ast_verb(3, "Saw variable AGENTACCEPTDTMF=%s, setting acceptdtmf to: %c for Agent '%s'.\n", tmpoptions, p->acceptdtmf, p->agent);					ast_set_flag(p, AGENT_FLAG_ACCEPTDTMF);				}
!ast_strlen_zero(tmpoptions)
ast_strlen_zero(tmpoptions)
ast_strlen_zero
ast_strlen_zero
tmpoptions
tmpoptions
{					p->acceptdtmf = *tmpoptions;					ast_verb(3, "Saw variable AGENTACCEPTDTMF=%s, setting acceptdtmf to: %c for Agent '%s'.\n", tmpoptions, p->acceptdtmf, p->agent);					ast_set_flag(p, AGENT_FLAG_ACCEPTDTMF);				}
p->acceptdtmf = *tmpoptions;
p->acceptdtmf = *tmpoptions
p->acceptdtmf
p
p
acceptdtmf
*tmpoptions
tmpoptions
tmpoptions
ast_verb(3, "Saw variable AGENTACCEPTDTMF=%s, setting acceptdtmf to: %c for Agent '%s'.\n", tmpoptions, p->acceptdtmf, p->agent);
ast_verb(3, "Saw variable AGENTACCEPTDTMF=%s, setting acceptdtmf to: %c for Agent '%s'.\n", tmpoptions, p->acceptdtmf, p->agent)
ast_verb
ast_verb
3
"Saw variable AGENTACCEPTDTMF=%s, setting acceptdtmf to: %c for Agent '%s'.\n"
tmpoptions
tmpoptions
p->acceptdtmf
p
p
acceptdtmf
p->agent
p
p
agent
ast_set_flag(p, AGENT_FLAG_ACCEPTDTMF);
ast_set_flag(p, AGENT_FLAG_ACCEPTDTMF)
ast_set_flag
ast_set_flag
p
p
AGENT_FLAG_ACCEPTDTMF
AGENT_FLAG_ACCEPTDTMF
tmpoptions = pbx_builtin_getvar_helper(chan, "AGENTENDDTMF");
tmpoptions = pbx_builtin_getvar_helper(chan, "AGENTENDDTMF")
tmpoptions
tmpoptions
pbx_builtin_getvar_helper(chan, "AGENTENDDTMF")
pbx_builtin_getvar_helper
pbx_builtin_getvar_helper
chan
chan
"AGENTENDDTMF"
if (!ast_strlen_zero(tmpoptions)) {					p->enddtmf = *tmpoptions;					ast_verb(3, "Saw variable AGENTENDDTMF=%s, setting enddtmf to: %c for Agent '%s'.\n", tmpoptions, p->enddtmf, p->agent);					ast_set_flag(p, AGENT_FLAG_ENDDTMF);				}
!ast_strlen_zero(tmpoptions)
ast_strlen_zero(tmpoptions)
ast_strlen_zero
ast_strlen_zero
tmpoptions
tmpoptions
{					p->enddtmf = *tmpoptions;					ast_verb(3, "Saw variable AGENTENDDTMF=%s, setting enddtmf to: %c for Agent '%s'.\n", tmpoptions, p->enddtmf, p->agent);					ast_set_flag(p, AGENT_FLAG_ENDDTMF);				}
p->enddtmf = *tmpoptions;
p->enddtmf = *tmpoptions
p->enddtmf
p
p
enddtmf
*tmpoptions
tmpoptions
tmpoptions
ast_verb(3, "Saw variable AGENTENDDTMF=%s, setting enddtmf to: %c for Agent '%s'.\n", tmpoptions, p->enddtmf, p->agent);
ast_verb(3, "Saw variable AGENTENDDTMF=%s, setting enddtmf to: %c for Agent '%s'.\n", tmpoptions, p->enddtmf, p->agent)
ast_verb
ast_verb
3
"Saw variable AGENTENDDTMF=%s, setting enddtmf to: %c for Agent '%s'.\n"
tmpoptions
tmpoptions
p->enddtmf
p
p
enddtmf
p->agent
p
p
agent
ast_set_flag(p, AGENT_FLAG_ENDDTMF);
ast_set_flag(p, AGENT_FLAG_ENDDTMF)
ast_set_flag
ast_set_flag
p
p
AGENT_FLAG_ENDDTMF
AGENT_FLAG_ENDDTMF
ast_channel_unlock(chan);
ast_channel_unlock(chan)
ast_channel_unlock
ast_channel_unlock
chan
chan
unlock_channel = 0;
unlock_channel = 0
unlock_channel
unlock_channel
0
if (!p->chan) {					long logintime;					snprintf(agent, sizeof(agent), "Agent/%s", p->agent);					p->logincallerid[0] = '\0';					p->acknowledged = 0;					ast_mutex_unlock(&p->lock);					AST_LIST_UNLOCK(&agents);					if( !res && play_announcement==1 )						res = ast_streamfile(chan, filename, ast_channel_language(chan));					if (!res)						ast_waitstream(chan, "");					AST_LIST_LOCK(&agents);					ast_mutex_lock(&p->lock);					if (!res) {						struct ast_format tmpfmt;						res = ast_set_read_format_from_cap(chan, ast_channel_nativeformats(chan));						if (res) {							ast_log(LOG_WARNING, "Unable to set read format to %s\n", ast_getformatname(&tmpfmt));						}					}					if (!res) {						struct ast_format tmpfmt;						res = ast_set_write_format_from_cap(chan, ast_channel_nativeformats(chan));						if (res) {							ast_log(LOG_WARNING, "Unable to set write format to %s\n", ast_getformatname(&tmpfmt));						}					}					/* Check once more just in case */					if (p->chan)						res = -1;					if (!res) {						ast_indicate_data(chan, AST_CONTROL_HOLD,							S_OR(p->moh, NULL),							!ast_strlen_zero(p->moh) ? strlen(p->moh) + 1 : 0);						if (p->loginstart == 0)							time(&p->loginstart);						/*** DOCUMENTATION							<managerEventInstance>								<synopsis>Raised when an Agent has logged in.</synopsis>								<syntax>									<parameter name="Agent">										<para>The name of the agent.</para>									</parameter>								</syntax>								<see-also>									<ref type="application">AgentLogin</ref>									<ref type="managerEvent">Agentlogoff</ref>								</see-also>							</managerEventInstance>						***/						manager_event(EVENT_FLAG_AGENT, "Agentlogin",							      "Agent: %s\r\n"							      "Channel: %s\r\n"							      "Uniqueid: %s\r\n",							      p->agent, ast_channel_name(chan), ast_channel_uniqueid(chan));						if (update_cdr && ast_channel_cdr(chan))							snprintf(ast_channel_cdr(chan)->channel, sizeof(ast_channel_cdr(chan)->channel), "Agent/%s", p->agent);						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGIN", "%s", ast_channel_name(chan));						ast_verb(2, "Agent '%s' logged in (format %s/%s)\n", p->agent,								    ast_getformatname(ast_channel_readformat(chan)), ast_getformatname(ast_channel_writeformat(chan)));						/* Login this channel and wait for it to go away */						p->chan = chan;						if (p->ackcall) {							check_beep(p, 0);						} else {							check_availability(p, 0);						}						ast_mutex_unlock(&p->lock);						AST_LIST_UNLOCK(&agents);						ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);						while (res >= 0) {							ast_mutex_lock(&p->lock);							if (p->deferlogoff && p->chan) {								ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);								p->deferlogoff = 0;							}							if (p->chan != chan)								res = -1;							ast_mutex_unlock(&p->lock);							/* Yield here so other interested threads can kick in. */							sched_yield();							if (res)								break;							AST_LIST_LOCK(&agents);							ast_mutex_lock(&p->lock);							if (p->lastdisc.tv_sec) {								if (ast_tvdiff_ms(ast_tvnow(), p->lastdisc) > 0) {									ast_debug(1, "Wrapup time for %s expired!\n", p->agent);									p->lastdisc = ast_tv(0, 0);									ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);									if (p->ackcall) {										check_beep(p, 0);									} else {										check_availability(p, 0);									}								}							}							ast_mutex_unlock(&p->lock);							AST_LIST_UNLOCK(&agents);							/*	Synchronize channel ownership between call to agent and itself. */							ast_mutex_lock(&p->lock);							if (p->app_lock_flag == 1) {								ast_cond_signal(&p->login_wait_cond);								ast_cond_wait(&p->app_complete_cond, &p->lock);							}							ast_mutex_unlock(&p->lock);							if (p->ackcall) {								res = agent_ack_sleep(p);							} else {								res = ast_safe_sleep_conditional( chan, 1000, agent_cont_sleep, p );							}							if (p->ackcall && (res == 1)) {								AST_LIST_LOCK(&agents);								ast_mutex_lock(&p->lock);								check_availability(p, 0);								ast_mutex_unlock(&p->lock);								AST_LIST_UNLOCK(&agents);								res = 0;							}							sched_yield();						}						ast_mutex_lock(&p->lock);						/* Log us off if appropriate */						if (p->chan == chan) {							p->chan = NULL;						}						/* Synchronize channel ownership between call to agent and itself. */						if (p->app_lock_flag == 1) {							ast_cond_signal(&p->login_wait_cond);							ast_cond_wait(&p->app_complete_cond, &p->lock);						}						if (res && p->owner)							ast_log(LOG_WARNING, "Huh?  We broke out when there was still an owner?\n");						p->acknowledged = 0;						logintime = time(NULL) - p->loginstart;						p->loginstart = 0;						ast_mutex_unlock(&p->lock);						/*** DOCUMENTATION							<managerEventInstance>								<synopsis>Raised when an Agent has logged off.</synopsis>								<syntax>									<xi:include xpointer="xpointer(/docs/managerEvent[@name='Agentlogin']/managerEventInstance/syntax/parameter[@name='Agent'])" />								</syntax>								<see-also>									<ref type="managerEvent">Agentlogin</ref>								</see-also>							</managerEventInstance>						***/						manager_event(EVENT_FLAG_AGENT, "Agentlogoff",							      "Agent: %s\r\n"							      "Logintime: %ld\r\n"							      "Uniqueid: %s\r\n",							      p->agent, logintime, ast_channel_uniqueid(chan));						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGOFF", "%s|%ld", ast_channel_name(chan), logintime);						ast_verb(2, "Agent '%s' logged out\n", p->agent);						/* If there is no owner, go ahead and kill it now */						ast_devstate_changed(AST_DEVICE_UNAVAILABLE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);						if (p->dead && !p->owner) {							ast_mutex_destroy(&p->lock);							ast_cond_destroy(&p->app_complete_cond);							ast_cond_destroy(&p->login_wait_cond);							ast_free(p);						}					}					else {						ast_mutex_unlock(&p->lock);						p = NULL;					}					res = -1;				} else {					ast_mutex_unlock(&p->lock);					errmsg = "agent-alreadyon";					p = NULL;				}
!p->chan
p->chan
p
p
chan
{					long logintime;					snprintf(agent, sizeof(agent), "Agent/%s", p->agent);					p->logincallerid[0] = '\0';					p->acknowledged = 0;					ast_mutex_unlock(&p->lock);					AST_LIST_UNLOCK(&agents);					if( !res && play_announcement==1 )						res = ast_streamfile(chan, filename, ast_channel_language(chan));					if (!res)						ast_waitstream(chan, "");					AST_LIST_LOCK(&agents);					ast_mutex_lock(&p->lock);					if (!res) {						struct ast_format tmpfmt;						res = ast_set_read_format_from_cap(chan, ast_channel_nativeformats(chan));						if (res) {							ast_log(LOG_WARNING, "Unable to set read format to %s\n", ast_getformatname(&tmpfmt));						}					}					if (!res) {						struct ast_format tmpfmt;						res = ast_set_write_format_from_cap(chan, ast_channel_nativeformats(chan));						if (res) {							ast_log(LOG_WARNING, "Unable to set write format to %s\n", ast_getformatname(&tmpfmt));						}					}					/* Check once more just in case */					if (p->chan)						res = -1;					if (!res) {						ast_indicate_data(chan, AST_CONTROL_HOLD,							S_OR(p->moh, NULL),							!ast_strlen_zero(p->moh) ? strlen(p->moh) + 1 : 0);						if (p->loginstart == 0)							time(&p->loginstart);						/*** DOCUMENTATION							<managerEventInstance>								<synopsis>Raised when an Agent has logged in.</synopsis>								<syntax>									<parameter name="Agent">										<para>The name of the agent.</para>									</parameter>								</syntax>								<see-also>									<ref type="application">AgentLogin</ref>									<ref type="managerEvent">Agentlogoff</ref>								</see-also>							</managerEventInstance>						***/						manager_event(EVENT_FLAG_AGENT, "Agentlogin",							      "Agent: %s\r\n"							      "Channel: %s\r\n"							      "Uniqueid: %s\r\n",							      p->agent, ast_channel_name(chan), ast_channel_uniqueid(chan));						if (update_cdr && ast_channel_cdr(chan))							snprintf(ast_channel_cdr(chan)->channel, sizeof(ast_channel_cdr(chan)->channel), "Agent/%s", p->agent);						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGIN", "%s", ast_channel_name(chan));						ast_verb(2, "Agent '%s' logged in (format %s/%s)\n", p->agent,								    ast_getformatname(ast_channel_readformat(chan)), ast_getformatname(ast_channel_writeformat(chan)));						/* Login this channel and wait for it to go away */						p->chan = chan;						if (p->ackcall) {							check_beep(p, 0);						} else {							check_availability(p, 0);						}						ast_mutex_unlock(&p->lock);						AST_LIST_UNLOCK(&agents);						ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);						while (res >= 0) {							ast_mutex_lock(&p->lock);							if (p->deferlogoff && p->chan) {								ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);								p->deferlogoff = 0;							}							if (p->chan != chan)								res = -1;							ast_mutex_unlock(&p->lock);							/* Yield here so other interested threads can kick in. */							sched_yield();							if (res)								break;							AST_LIST_LOCK(&agents);							ast_mutex_lock(&p->lock);							if (p->lastdisc.tv_sec) {								if (ast_tvdiff_ms(ast_tvnow(), p->lastdisc) > 0) {									ast_debug(1, "Wrapup time for %s expired!\n", p->agent);									p->lastdisc = ast_tv(0, 0);									ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);									if (p->ackcall) {										check_beep(p, 0);									} else {										check_availability(p, 0);									}								}							}							ast_mutex_unlock(&p->lock);							AST_LIST_UNLOCK(&agents);							/*	Synchronize channel ownership between call to agent and itself. */							ast_mutex_lock(&p->lock);							if (p->app_lock_flag == 1) {								ast_cond_signal(&p->login_wait_cond);								ast_cond_wait(&p->app_complete_cond, &p->lock);							}							ast_mutex_unlock(&p->lock);							if (p->ackcall) {								res = agent_ack_sleep(p);							} else {								res = ast_safe_sleep_conditional( chan, 1000, agent_cont_sleep, p );							}							if (p->ackcall && (res == 1)) {								AST_LIST_LOCK(&agents);								ast_mutex_lock(&p->lock);								check_availability(p, 0);								ast_mutex_unlock(&p->lock);								AST_LIST_UNLOCK(&agents);								res = 0;							}							sched_yield();						}						ast_mutex_lock(&p->lock);						/* Log us off if appropriate */						if (p->chan == chan) {							p->chan = NULL;						}						/* Synchronize channel ownership between call to agent and itself. */						if (p->app_lock_flag == 1) {							ast_cond_signal(&p->login_wait_cond);							ast_cond_wait(&p->app_complete_cond, &p->lock);						}						if (res && p->owner)							ast_log(LOG_WARNING, "Huh?  We broke out when there was still an owner?\n");						p->acknowledged = 0;						logintime = time(NULL) - p->loginstart;						p->loginstart = 0;						ast_mutex_unlock(&p->lock);						/*** DOCUMENTATION							<managerEventInstance>								<synopsis>Raised when an Agent has logged off.</synopsis>								<syntax>									<xi:include xpointer="xpointer(/docs/managerEvent[@name='Agentlogin']/managerEventInstance/syntax/parameter[@name='Agent'])" />								</syntax>								<see-also>									<ref type="managerEvent">Agentlogin</ref>								</see-also>							</managerEventInstance>						***/						manager_event(EVENT_FLAG_AGENT, "Agentlogoff",							      "Agent: %s\r\n"							      "Logintime: %ld\r\n"							      "Uniqueid: %s\r\n",							      p->agent, logintime, ast_channel_uniqueid(chan));						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGOFF", "%s|%ld", ast_channel_name(chan), logintime);						ast_verb(2, "Agent '%s' logged out\n", p->agent);						/* If there is no owner, go ahead and kill it now */						ast_devstate_changed(AST_DEVICE_UNAVAILABLE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);						if (p->dead && !p->owner) {							ast_mutex_destroy(&p->lock);							ast_cond_destroy(&p->app_complete_cond);							ast_cond_destroy(&p->login_wait_cond);							ast_free(p);						}					}					else {						ast_mutex_unlock(&p->lock);						p = NULL;					}					res = -1;				}
long logintime;
long logintime;
long
logintime
logintime
snprintf(agent, sizeof(agent), "Agent/%s", p->agent);
snprintf(agent, sizeof(agent), "Agent/%s", p->agent)
snprintf
snprintf
agent
agent
sizeof(agent)
(agent)
agent
agent
"Agent/%s"
p->agent
p
p
agent
p->logincallerid[0] = '\0';
p->logincallerid[0] = '\0'
p->logincallerid[0]
p->logincallerid
p
p
logincallerid
0
'\0'
p->acknowledged = 0;
p->acknowledged = 0
p->acknowledged
p
p
acknowledged
0
ast_mutex_unlock(&p->lock);
ast_mutex_unlock(&p->lock)
ast_mutex_unlock
ast_mutex_unlock
&p->lock
p->lock
p
p
lock
AST_LIST_UNLOCK(&agents);
AST_LIST_UNLOCK(&agents)
AST_LIST_UNLOCK
AST_LIST_UNLOCK
&agents
agents
agents
if( !res && play_announcement==1 )						res = ast_streamfile(chan, filename, ast_channel_language(chan));
!res && play_announcement==1
!res
res
res
play_announcement==1
play_announcement
play_announcement
1
res = ast_streamfile(chan, filename, ast_channel_language(chan));
res = ast_streamfile(chan, filename, ast_channel_language(chan))
res
res
ast_streamfile(chan, filename, ast_channel_language(chan))
ast_streamfile
ast_streamfile
chan
chan
filename
filename
ast_channel_language(chan)
ast_channel_language
ast_channel_language
chan
chan
if (!res)						ast_waitstream(chan, "");
!res
res
res
ast_waitstream(chan, "");
ast_waitstream(chan, "")
ast_waitstream
ast_waitstream
chan
chan
""
AST_LIST_LOCK(&agents);
AST_LIST_LOCK(&agents)
AST_LIST_LOCK
AST_LIST_LOCK
&agents
agents
agents
ast_mutex_lock(&p->lock);
ast_mutex_lock(&p->lock)
ast_mutex_lock
ast_mutex_lock
&p->lock
p->lock
p
p
lock
if (!res) {						struct ast_format tmpfmt;						res = ast_set_read_format_from_cap(chan, ast_channel_nativeformats(chan));						if (res) {							ast_log(LOG_WARNING, "Unable to set read format to %s\n", ast_getformatname(&tmpfmt));						}					}
!res
res
res
{						struct ast_format tmpfmt;						res = ast_set_read_format_from_cap(chan, ast_channel_nativeformats(chan));						if (res) {							ast_log(LOG_WARNING, "Unable to set read format to %s\n", ast_getformatname(&tmpfmt));						}					}
struct ast_format tmpfmt;
struct ast_format tmpfmt;
struct ast_format
ast_format
tmpfmt
tmpfmt
res = ast_set_read_format_from_cap(chan, ast_channel_nativeformats(chan));
res = ast_set_read_format_from_cap(chan, ast_channel_nativeformats(chan))
res
res
ast_set_read_format_from_cap(chan, ast_channel_nativeformats(chan))
ast_set_read_format_from_cap
ast_set_read_format_from_cap
chan
chan
ast_channel_nativeformats(chan)
ast_channel_nativeformats
ast_channel_nativeformats
chan
chan
if (res) {							ast_log(LOG_WARNING, "Unable to set read format to %s\n", ast_getformatname(&tmpfmt));						}
res
res
{							ast_log(LOG_WARNING, "Unable to set read format to %s\n", ast_getformatname(&tmpfmt));						}
ast_log(LOG_WARNING, "Unable to set read format to %s\n", ast_getformatname(&tmpfmt));
ast_log(LOG_WARNING, "Unable to set read format to %s\n", ast_getformatname(&tmpfmt))
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"Unable to set read format to %s\n"
ast_getformatname(&tmpfmt)
ast_getformatname
ast_getformatname
&tmpfmt
tmpfmt
tmpfmt
if (!res) {						struct ast_format tmpfmt;						res = ast_set_write_format_from_cap(chan, ast_channel_nativeformats(chan));						if (res) {							ast_log(LOG_WARNING, "Unable to set write format to %s\n", ast_getformatname(&tmpfmt));						}					}
!res
res
res
{						struct ast_format tmpfmt;						res = ast_set_write_format_from_cap(chan, ast_channel_nativeformats(chan));						if (res) {							ast_log(LOG_WARNING, "Unable to set write format to %s\n", ast_getformatname(&tmpfmt));						}					}
struct ast_format tmpfmt;
struct ast_format tmpfmt;
struct ast_format
ast_format
tmpfmt
tmpfmt
res = ast_set_write_format_from_cap(chan, ast_channel_nativeformats(chan));
res = ast_set_write_format_from_cap(chan, ast_channel_nativeformats(chan))
res
res
ast_set_write_format_from_cap(chan, ast_channel_nativeformats(chan))
ast_set_write_format_from_cap
ast_set_write_format_from_cap
chan
chan
ast_channel_nativeformats(chan)
ast_channel_nativeformats
ast_channel_nativeformats
chan
chan
if (res) {							ast_log(LOG_WARNING, "Unable to set write format to %s\n", ast_getformatname(&tmpfmt));						}
res
res
{							ast_log(LOG_WARNING, "Unable to set write format to %s\n", ast_getformatname(&tmpfmt));						}
ast_log(LOG_WARNING, "Unable to set write format to %s\n", ast_getformatname(&tmpfmt));
ast_log(LOG_WARNING, "Unable to set write format to %s\n", ast_getformatname(&tmpfmt))
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"Unable to set write format to %s\n"
ast_getformatname(&tmpfmt)
ast_getformatname
ast_getformatname
&tmpfmt
tmpfmt
tmpfmt
if (p->chan)						res = -1;
p->chan
p
p
chan
res = -1;
res = -1
res
res
-1
1
if (!res) {						ast_indicate_data(chan, AST_CONTROL_HOLD,							S_OR(p->moh, NULL),							!ast_strlen_zero(p->moh) ? strlen(p->moh) + 1 : 0);						if (p->loginstart == 0)							time(&p->loginstart);						/*** DOCUMENTATION							<managerEventInstance>								<synopsis>Raised when an Agent has logged in.</synopsis>								<syntax>									<parameter name="Agent">										<para>The name of the agent.</para>									</parameter>								</syntax>								<see-also>									<ref type="application">AgentLogin</ref>									<ref type="managerEvent">Agentlogoff</ref>								</see-also>							</managerEventInstance>						***/						manager_event(EVENT_FLAG_AGENT, "Agentlogin",							      "Agent: %s\r\n"							      "Channel: %s\r\n"							      "Uniqueid: %s\r\n",							      p->agent, ast_channel_name(chan), ast_channel_uniqueid(chan));						if (update_cdr && ast_channel_cdr(chan))							snprintf(ast_channel_cdr(chan)->channel, sizeof(ast_channel_cdr(chan)->channel), "Agent/%s", p->agent);						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGIN", "%s", ast_channel_name(chan));						ast_verb(2, "Agent '%s' logged in (format %s/%s)\n", p->agent,								    ast_getformatname(ast_channel_readformat(chan)), ast_getformatname(ast_channel_writeformat(chan)));						/* Login this channel and wait for it to go away */						p->chan = chan;						if (p->ackcall) {							check_beep(p, 0);						} else {							check_availability(p, 0);						}						ast_mutex_unlock(&p->lock);						AST_LIST_UNLOCK(&agents);						ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);						while (res >= 0) {							ast_mutex_lock(&p->lock);							if (p->deferlogoff && p->chan) {								ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);								p->deferlogoff = 0;							}							if (p->chan != chan)								res = -1;							ast_mutex_unlock(&p->lock);							/* Yield here so other interested threads can kick in. */							sched_yield();							if (res)								break;							AST_LIST_LOCK(&agents);							ast_mutex_lock(&p->lock);							if (p->lastdisc.tv_sec) {								if (ast_tvdiff_ms(ast_tvnow(), p->lastdisc) > 0) {									ast_debug(1, "Wrapup time for %s expired!\n", p->agent);									p->lastdisc = ast_tv(0, 0);									ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);									if (p->ackcall) {										check_beep(p, 0);									} else {										check_availability(p, 0);									}								}							}							ast_mutex_unlock(&p->lock);							AST_LIST_UNLOCK(&agents);							/*	Synchronize channel ownership between call to agent and itself. */							ast_mutex_lock(&p->lock);							if (p->app_lock_flag == 1) {								ast_cond_signal(&p->login_wait_cond);								ast_cond_wait(&p->app_complete_cond, &p->lock);							}							ast_mutex_unlock(&p->lock);							if (p->ackcall) {								res = agent_ack_sleep(p);							} else {								res = ast_safe_sleep_conditional( chan, 1000, agent_cont_sleep, p );							}							if (p->ackcall && (res == 1)) {								AST_LIST_LOCK(&agents);								ast_mutex_lock(&p->lock);								check_availability(p, 0);								ast_mutex_unlock(&p->lock);								AST_LIST_UNLOCK(&agents);								res = 0;							}							sched_yield();						}						ast_mutex_lock(&p->lock);						/* Log us off if appropriate */						if (p->chan == chan) {							p->chan = NULL;						}						/* Synchronize channel ownership between call to agent and itself. */						if (p->app_lock_flag == 1) {							ast_cond_signal(&p->login_wait_cond);							ast_cond_wait(&p->app_complete_cond, &p->lock);						}						if (res && p->owner)							ast_log(LOG_WARNING, "Huh?  We broke out when there was still an owner?\n");						p->acknowledged = 0;						logintime = time(NULL) - p->loginstart;						p->loginstart = 0;						ast_mutex_unlock(&p->lock);						/*** DOCUMENTATION							<managerEventInstance>								<synopsis>Raised when an Agent has logged off.</synopsis>								<syntax>									<xi:include xpointer="xpointer(/docs/managerEvent[@name='Agentlogin']/managerEventInstance/syntax/parameter[@name='Agent'])" />								</syntax>								<see-also>									<ref type="managerEvent">Agentlogin</ref>								</see-also>							</managerEventInstance>						***/						manager_event(EVENT_FLAG_AGENT, "Agentlogoff",							      "Agent: %s\r\n"							      "Logintime: %ld\r\n"							      "Uniqueid: %s\r\n",							      p->agent, logintime, ast_channel_uniqueid(chan));						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGOFF", "%s|%ld", ast_channel_name(chan), logintime);						ast_verb(2, "Agent '%s' logged out\n", p->agent);						/* If there is no owner, go ahead and kill it now */						ast_devstate_changed(AST_DEVICE_UNAVAILABLE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);						if (p->dead && !p->owner) {							ast_mutex_destroy(&p->lock);							ast_cond_destroy(&p->app_complete_cond);							ast_cond_destroy(&p->login_wait_cond);							ast_free(p);						}					}					else {						ast_mutex_unlock(&p->lock);						p = NULL;					}
!res
res
res
{						ast_indicate_data(chan, AST_CONTROL_HOLD,							S_OR(p->moh, NULL),							!ast_strlen_zero(p->moh) ? strlen(p->moh) + 1 : 0);						if (p->loginstart == 0)							time(&p->loginstart);						/*** DOCUMENTATION							<managerEventInstance>								<synopsis>Raised when an Agent has logged in.</synopsis>								<syntax>									<parameter name="Agent">										<para>The name of the agent.</para>									</parameter>								</syntax>								<see-also>									<ref type="application">AgentLogin</ref>									<ref type="managerEvent">Agentlogoff</ref>								</see-also>							</managerEventInstance>						***/						manager_event(EVENT_FLAG_AGENT, "Agentlogin",							      "Agent: %s\r\n"							      "Channel: %s\r\n"							      "Uniqueid: %s\r\n",							      p->agent, ast_channel_name(chan), ast_channel_uniqueid(chan));						if (update_cdr && ast_channel_cdr(chan))							snprintf(ast_channel_cdr(chan)->channel, sizeof(ast_channel_cdr(chan)->channel), "Agent/%s", p->agent);						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGIN", "%s", ast_channel_name(chan));						ast_verb(2, "Agent '%s' logged in (format %s/%s)\n", p->agent,								    ast_getformatname(ast_channel_readformat(chan)), ast_getformatname(ast_channel_writeformat(chan)));						/* Login this channel and wait for it to go away */						p->chan = chan;						if (p->ackcall) {							check_beep(p, 0);						} else {							check_availability(p, 0);						}						ast_mutex_unlock(&p->lock);						AST_LIST_UNLOCK(&agents);						ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);						while (res >= 0) {							ast_mutex_lock(&p->lock);							if (p->deferlogoff && p->chan) {								ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);								p->deferlogoff = 0;							}							if (p->chan != chan)								res = -1;							ast_mutex_unlock(&p->lock);							/* Yield here so other interested threads can kick in. */							sched_yield();							if (res)								break;							AST_LIST_LOCK(&agents);							ast_mutex_lock(&p->lock);							if (p->lastdisc.tv_sec) {								if (ast_tvdiff_ms(ast_tvnow(), p->lastdisc) > 0) {									ast_debug(1, "Wrapup time for %s expired!\n", p->agent);									p->lastdisc = ast_tv(0, 0);									ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);									if (p->ackcall) {										check_beep(p, 0);									} else {										check_availability(p, 0);									}								}							}							ast_mutex_unlock(&p->lock);							AST_LIST_UNLOCK(&agents);							/*	Synchronize channel ownership between call to agent and itself. */							ast_mutex_lock(&p->lock);							if (p->app_lock_flag == 1) {								ast_cond_signal(&p->login_wait_cond);								ast_cond_wait(&p->app_complete_cond, &p->lock);							}							ast_mutex_unlock(&p->lock);							if (p->ackcall) {								res = agent_ack_sleep(p);							} else {								res = ast_safe_sleep_conditional( chan, 1000, agent_cont_sleep, p );							}							if (p->ackcall && (res == 1)) {								AST_LIST_LOCK(&agents);								ast_mutex_lock(&p->lock);								check_availability(p, 0);								ast_mutex_unlock(&p->lock);								AST_LIST_UNLOCK(&agents);								res = 0;							}							sched_yield();						}						ast_mutex_lock(&p->lock);						/* Log us off if appropriate */						if (p->chan == chan) {							p->chan = NULL;						}						/* Synchronize channel ownership between call to agent and itself. */						if (p->app_lock_flag == 1) {							ast_cond_signal(&p->login_wait_cond);							ast_cond_wait(&p->app_complete_cond, &p->lock);						}						if (res && p->owner)							ast_log(LOG_WARNING, "Huh?  We broke out when there was still an owner?\n");						p->acknowledged = 0;						logintime = time(NULL) - p->loginstart;						p->loginstart = 0;						ast_mutex_unlock(&p->lock);						/*** DOCUMENTATION							<managerEventInstance>								<synopsis>Raised when an Agent has logged off.</synopsis>								<syntax>									<xi:include xpointer="xpointer(/docs/managerEvent[@name='Agentlogin']/managerEventInstance/syntax/parameter[@name='Agent'])" />								</syntax>								<see-also>									<ref type="managerEvent">Agentlogin</ref>								</see-also>							</managerEventInstance>						***/						manager_event(EVENT_FLAG_AGENT, "Agentlogoff",							      "Agent: %s\r\n"							      "Logintime: %ld\r\n"							      "Uniqueid: %s\r\n",							      p->agent, logintime, ast_channel_uniqueid(chan));						ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGOFF", "%s|%ld", ast_channel_name(chan), logintime);						ast_verb(2, "Agent '%s' logged out\n", p->agent);						/* If there is no owner, go ahead and kill it now */						ast_devstate_changed(AST_DEVICE_UNAVAILABLE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);						if (p->dead && !p->owner) {							ast_mutex_destroy(&p->lock);							ast_cond_destroy(&p->app_complete_cond);							ast_cond_destroy(&p->login_wait_cond);							ast_free(p);						}					}
ast_indicate_data(chan, AST_CONTROL_HOLD,							S_OR(p->moh, NULL),							!ast_strlen_zero(p->moh) ? strlen(p->moh) + 1 : 0);
ast_indicate_data(chan, AST_CONTROL_HOLD,							S_OR(p->moh, NULL),							!ast_strlen_zero(p->moh) ? strlen(p->moh) + 1 : 0)
ast_indicate_data
ast_indicate_data
chan
chan
AST_CONTROL_HOLD
AST_CONTROL_HOLD
S_OR(p->moh, NULL)
S_OR
S_OR
p->moh
p
p
moh
NULL
NULL
!ast_strlen_zero(p->moh) ? strlen(p->moh) + 1 : 0
!ast_strlen_zero(p->moh)
ast_strlen_zero(p->moh)
ast_strlen_zero
ast_strlen_zero
p->moh
p
p
moh
strlen(p->moh) + 1
strlen(p->moh)
strlen
strlen
p->moh
p
p
moh
1
0
if (p->loginstart == 0)							time(&p->loginstart);
p->loginstart == 0
p->loginstart
p
p
loginstart
0
time(&p->loginstart);
time(&p->loginstart)
time
time
&p->loginstart
p->loginstart
p
p
loginstart
manager_event(EVENT_FLAG_AGENT, "Agentlogin",							      "Agent: %s\r\n"							      "Channel: %s\r\n"							      "Uniqueid: %s\r\n",							      p->agent, ast_channel_name(chan), ast_channel_uniqueid(chan));
manager_event(EVENT_FLAG_AGENT, "Agentlogin",							      "Agent: %s\r\n"							      "Channel: %s\r\n"							      "Uniqueid: %s\r\n",							      p->agent, ast_channel_name(chan), ast_channel_uniqueid(chan))
manager_event
manager_event
EVENT_FLAG_AGENT
EVENT_FLAG_AGENT
"Agentlogin"
"Agent: %s\r\n"							      "Channel: %s\r\n"							      "Uniqueid: %s\r\n"
p->agent
p
p
agent
ast_channel_name(chan)
ast_channel_name
ast_channel_name
chan
chan
ast_channel_uniqueid(chan)
ast_channel_uniqueid
ast_channel_uniqueid
chan
chan
if (update_cdr && ast_channel_cdr(chan))							snprintf(ast_channel_cdr(chan)->channel, sizeof(ast_channel_cdr(chan)->channel), "Agent/%s", p->agent);
update_cdr && ast_channel_cdr(chan)
update_cdr
update_cdr
ast_channel_cdr(chan)
ast_channel_cdr
ast_channel_cdr
chan
chan
snprintf(ast_channel_cdr(chan)->channel, sizeof(ast_channel_cdr(chan)->channel), "Agent/%s", p->agent);
snprintf(ast_channel_cdr(chan)->channel, sizeof(ast_channel_cdr(chan)->channel), "Agent/%s", p->agent)
snprintf
snprintf
ast_channel_cdr(chan)->channel
ast_channel_cdr(chan)
ast_channel_cdr
ast_channel_cdr
chan
chan
channel
sizeof(ast_channel_cdr(chan)->channel)
(ast_channel_cdr(chan)->channel)
ast_channel_cdr(chan)->channel
ast_channel_cdr(chan)
ast_channel_cdr
ast_channel_cdr
chan
chan
channel
"Agent/%s"
p->agent
p
p
agent
ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGIN", "%s", ast_channel_name(chan));
ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGIN", "%s", ast_channel_name(chan))
ast_queue_log
ast_queue_log
"NONE"
ast_channel_uniqueid(chan)
ast_channel_uniqueid
ast_channel_uniqueid
chan
chan
agent
agent
"AGENTLOGIN"
"%s"
ast_channel_name(chan)
ast_channel_name
ast_channel_name
chan
chan
ast_verb(2, "Agent '%s' logged in (format %s/%s)\n", p->agent,								    ast_getformatname(ast_channel_readformat(chan)), ast_getformatname(ast_channel_writeformat(chan)));
ast_verb(2, "Agent '%s' logged in (format %s/%s)\n", p->agent,								    ast_getformatname(ast_channel_readformat(chan)), ast_getformatname(ast_channel_writeformat(chan)))
ast_verb
ast_verb
2
"Agent '%s' logged in (format %s/%s)\n"
p->agent
p
p
agent
ast_getformatname(ast_channel_readformat(chan))
ast_getformatname
ast_getformatname
ast_channel_readformat(chan)
ast_channel_readformat
ast_channel_readformat
chan
chan
ast_getformatname(ast_channel_writeformat(chan))
ast_getformatname
ast_getformatname
ast_channel_writeformat(chan)
ast_channel_writeformat
ast_channel_writeformat
chan
chan
p->chan = chan;
p->chan = chan
p->chan
p
p
chan
chan
chan
if (p->ackcall) {							check_beep(p, 0);						} else {							check_availability(p, 0);						}
p->ackcall
p
p
ackcall
{							check_beep(p, 0);						}
check_beep(p, 0);
check_beep(p, 0)
check_beep
check_beep
p
p
0
{							check_availability(p, 0);						}
check_availability(p, 0);
check_availability(p, 0)
check_availability
check_availability
p
p
0
ast_mutex_unlock(&p->lock);
ast_mutex_unlock(&p->lock)
ast_mutex_unlock
ast_mutex_unlock
&p->lock
p->lock
p
p
lock
AST_LIST_UNLOCK(&agents);
AST_LIST_UNLOCK(&agents)
AST_LIST_UNLOCK
AST_LIST_UNLOCK
&agents
agents
agents
ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);
ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent)
ast_devstate_changed
ast_devstate_changed
AST_DEVICE_NOT_INUSE
AST_DEVICE_NOT_INUSE
AST_DEVSTATE_CACHABLE
AST_DEVSTATE_CACHABLE
"Agent/%s"
p->agent
p
p
agent
while (res >= 0) {							ast_mutex_lock(&p->lock);							if (p->deferlogoff && p->chan) {								ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);								p->deferlogoff = 0;							}							if (p->chan != chan)								res = -1;							ast_mutex_unlock(&p->lock);							/* Yield here so other interested threads can kick in. */							sched_yield();							if (res)								break;							AST_LIST_LOCK(&agents);							ast_mutex_lock(&p->lock);							if (p->lastdisc.tv_sec) {								if (ast_tvdiff_ms(ast_tvnow(), p->lastdisc) > 0) {									ast_debug(1, "Wrapup time for %s expired!\n", p->agent);									p->lastdisc = ast_tv(0, 0);									ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);									if (p->ackcall) {										check_beep(p, 0);									} else {										check_availability(p, 0);									}								}							}							ast_mutex_unlock(&p->lock);							AST_LIST_UNLOCK(&agents);							/*	Synchronize channel ownership between call to agent and itself. */							ast_mutex_lock(&p->lock);							if (p->app_lock_flag == 1) {								ast_cond_signal(&p->login_wait_cond);								ast_cond_wait(&p->app_complete_cond, &p->lock);							}							ast_mutex_unlock(&p->lock);							if (p->ackcall) {								res = agent_ack_sleep(p);							} else {								res = ast_safe_sleep_conditional( chan, 1000, agent_cont_sleep, p );							}							if (p->ackcall && (res == 1)) {								AST_LIST_LOCK(&agents);								ast_mutex_lock(&p->lock);								check_availability(p, 0);								ast_mutex_unlock(&p->lock);								AST_LIST_UNLOCK(&agents);								res = 0;							}							sched_yield();						}
res >= 0
res
res
0
{							ast_mutex_lock(&p->lock);							if (p->deferlogoff && p->chan) {								ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);								p->deferlogoff = 0;							}							if (p->chan != chan)								res = -1;							ast_mutex_unlock(&p->lock);							/* Yield here so other interested threads can kick in. */							sched_yield();							if (res)								break;							AST_LIST_LOCK(&agents);							ast_mutex_lock(&p->lock);							if (p->lastdisc.tv_sec) {								if (ast_tvdiff_ms(ast_tvnow(), p->lastdisc) > 0) {									ast_debug(1, "Wrapup time for %s expired!\n", p->agent);									p->lastdisc = ast_tv(0, 0);									ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);									if (p->ackcall) {										check_beep(p, 0);									} else {										check_availability(p, 0);									}								}							}							ast_mutex_unlock(&p->lock);							AST_LIST_UNLOCK(&agents);							/*	Synchronize channel ownership between call to agent and itself. */							ast_mutex_lock(&p->lock);							if (p->app_lock_flag == 1) {								ast_cond_signal(&p->login_wait_cond);								ast_cond_wait(&p->app_complete_cond, &p->lock);							}							ast_mutex_unlock(&p->lock);							if (p->ackcall) {								res = agent_ack_sleep(p);							} else {								res = ast_safe_sleep_conditional( chan, 1000, agent_cont_sleep, p );							}							if (p->ackcall && (res == 1)) {								AST_LIST_LOCK(&agents);								ast_mutex_lock(&p->lock);								check_availability(p, 0);								ast_mutex_unlock(&p->lock);								AST_LIST_UNLOCK(&agents);								res = 0;							}							sched_yield();						}
ast_mutex_lock(&p->lock);
ast_mutex_lock(&p->lock)
ast_mutex_lock
ast_mutex_lock
&p->lock
p->lock
p
p
lock
if (p->deferlogoff && p->chan) {								ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);								p->deferlogoff = 0;							}
p->deferlogoff && p->chan
p->deferlogoff
p
p
deferlogoff
p->chan
p
p
chan
{								ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);								p->deferlogoff = 0;							}
ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);
ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT)
ast_softhangup
ast_softhangup
p->chan
p
p
chan
AST_SOFTHANGUP_EXPLICIT
AST_SOFTHANGUP_EXPLICIT
p->deferlogoff = 0;
p->deferlogoff = 0
p->deferlogoff
p
p
deferlogoff
0
if (p->chan != chan)								res = -1;
p->chan != chan
p->chan
p
p
chan
chan
chan
res = -1;
res = -1
res
res
-1
1
ast_mutex_unlock(&p->lock);
ast_mutex_unlock(&p->lock)
ast_mutex_unlock
ast_mutex_unlock
&p->lock
p->lock
p
p
lock
sched_yield();
sched_yield()
sched_yield
sched_yield
if (res)								break;
res
res
break;
AST_LIST_LOCK(&agents);
AST_LIST_LOCK(&agents)
AST_LIST_LOCK
AST_LIST_LOCK
&agents
agents
agents
ast_mutex_lock(&p->lock);
ast_mutex_lock(&p->lock)
ast_mutex_lock
ast_mutex_lock
&p->lock
p->lock
p
p
lock
if (p->lastdisc.tv_sec) {								if (ast_tvdiff_ms(ast_tvnow(), p->lastdisc) > 0) {									ast_debug(1, "Wrapup time for %s expired!\n", p->agent);									p->lastdisc = ast_tv(0, 0);									ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);									if (p->ackcall) {										check_beep(p, 0);									} else {										check_availability(p, 0);									}								}							}
p->lastdisc.tv_sec
p->lastdisc
p
p
lastdisc
tv_sec
{								if (ast_tvdiff_ms(ast_tvnow(), p->lastdisc) > 0) {									ast_debug(1, "Wrapup time for %s expired!\n", p->agent);									p->lastdisc = ast_tv(0, 0);									ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);									if (p->ackcall) {										check_beep(p, 0);									} else {										check_availability(p, 0);									}								}							}
if (ast_tvdiff_ms(ast_tvnow(), p->lastdisc) > 0) {									ast_debug(1, "Wrapup time for %s expired!\n", p->agent);									p->lastdisc = ast_tv(0, 0);									ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);									if (p->ackcall) {										check_beep(p, 0);									} else {										check_availability(p, 0);									}								}
ast_tvdiff_ms(ast_tvnow(), p->lastdisc) > 0
ast_tvdiff_ms(ast_tvnow(), p->lastdisc)
ast_tvdiff_ms
ast_tvdiff_ms
ast_tvnow()
ast_tvnow
ast_tvnow
p->lastdisc
p
p
lastdisc
0
{									ast_debug(1, "Wrapup time for %s expired!\n", p->agent);									p->lastdisc = ast_tv(0, 0);									ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);									if (p->ackcall) {										check_beep(p, 0);									} else {										check_availability(p, 0);									}								}
ast_debug(1, "Wrapup time for %s expired!\n", p->agent);
ast_debug(1, "Wrapup time for %s expired!\n", p->agent)
ast_debug
ast_debug
1
"Wrapup time for %s expired!\n"
p->agent
p
p
agent
p->lastdisc = ast_tv(0, 0);
p->lastdisc = ast_tv(0, 0)
p->lastdisc
p
p
lastdisc
ast_tv(0, 0)
ast_tv
ast_tv
0
0
ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);
ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent)
ast_devstate_changed
ast_devstate_changed
AST_DEVICE_NOT_INUSE
AST_DEVICE_NOT_INUSE
AST_DEVSTATE_CACHABLE
AST_DEVSTATE_CACHABLE
"Agent/%s"
p->agent
p
p
agent
if (p->ackcall) {										check_beep(p, 0);									} else {										check_availability(p, 0);									}
p->ackcall
p
p
ackcall
{										check_beep(p, 0);									}
check_beep(p, 0);
check_beep(p, 0)
check_beep
check_beep
p
p
0
{										check_availability(p, 0);									}
check_availability(p, 0);
check_availability(p, 0)
check_availability
check_availability
p
p
0
ast_mutex_unlock(&p->lock);
ast_mutex_unlock(&p->lock)
ast_mutex_unlock
ast_mutex_unlock
&p->lock
p->lock
p
p
lock
AST_LIST_UNLOCK(&agents);
AST_LIST_UNLOCK(&agents)
AST_LIST_UNLOCK
AST_LIST_UNLOCK
&agents
agents
agents
ast_mutex_lock(&p->lock);
ast_mutex_lock(&p->lock)
ast_mutex_lock
ast_mutex_lock
&p->lock
p->lock
p
p
lock
if (p->app_lock_flag == 1) {								ast_cond_signal(&p->login_wait_cond);								ast_cond_wait(&p->app_complete_cond, &p->lock);							}
p->app_lock_flag == 1
p->app_lock_flag
p
p
app_lock_flag
1
{								ast_cond_signal(&p->login_wait_cond);								ast_cond_wait(&p->app_complete_cond, &p->lock);							}
ast_cond_signal(&p->login_wait_cond);
ast_cond_signal(&p->login_wait_cond)
ast_cond_signal
ast_cond_signal
&p->login_wait_cond
p->login_wait_cond
p
p
login_wait_cond
ast_cond_wait(&p->app_complete_cond, &p->lock);
ast_cond_wait(&p->app_complete_cond, &p->lock)
ast_cond_wait
ast_cond_wait
&p->app_complete_cond
p->app_complete_cond
p
p
app_complete_cond
&p->lock
p->lock
p
p
lock
ast_mutex_unlock(&p->lock);
ast_mutex_unlock(&p->lock)
ast_mutex_unlock
ast_mutex_unlock
&p->lock
p->lock
p
p
lock
if (p->ackcall) {								res = agent_ack_sleep(p);							} else {								res = ast_safe_sleep_conditional( chan, 1000, agent_cont_sleep, p );							}
p->ackcall
p
p
ackcall
{								res = agent_ack_sleep(p);							}
res = agent_ack_sleep(p);
res = agent_ack_sleep(p)
res
res
agent_ack_sleep(p)
agent_ack_sleep
agent_ack_sleep
p
p
{								res = ast_safe_sleep_conditional( chan, 1000, agent_cont_sleep, p );							}
res = ast_safe_sleep_conditional( chan, 1000, agent_cont_sleep, p );
res = ast_safe_sleep_conditional( chan, 1000, agent_cont_sleep, p )
res
res
ast_safe_sleep_conditional( chan, 1000, agent_cont_sleep, p )
ast_safe_sleep_conditional
ast_safe_sleep_conditional
chan
chan
1000
agent_cont_sleep
agent_cont_sleep
p
p
if (p->ackcall && (res == 1)) {								AST_LIST_LOCK(&agents);								ast_mutex_lock(&p->lock);								check_availability(p, 0);								ast_mutex_unlock(&p->lock);								AST_LIST_UNLOCK(&agents);								res = 0;							}
p->ackcall && (res == 1)
p->ackcall
p
p
ackcall
(res == 1)
res == 1
res
res
1
{								AST_LIST_LOCK(&agents);								ast_mutex_lock(&p->lock);								check_availability(p, 0);								ast_mutex_unlock(&p->lock);								AST_LIST_UNLOCK(&agents);								res = 0;							}
AST_LIST_LOCK(&agents);
AST_LIST_LOCK(&agents)
AST_LIST_LOCK
AST_LIST_LOCK
&agents
agents
agents
ast_mutex_lock(&p->lock);
ast_mutex_lock(&p->lock)
ast_mutex_lock
ast_mutex_lock
&p->lock
p->lock
p
p
lock
check_availability(p, 0);
check_availability(p, 0)
check_availability
check_availability
p
p
0
ast_mutex_unlock(&p->lock);
ast_mutex_unlock(&p->lock)
ast_mutex_unlock
ast_mutex_unlock
&p->lock
p->lock
p
p
lock
AST_LIST_UNLOCK(&agents);
AST_LIST_UNLOCK(&agents)
AST_LIST_UNLOCK
AST_LIST_UNLOCK
&agents
agents
agents
res = 0;
res = 0
res
res
0
sched_yield();
sched_yield()
sched_yield
sched_yield
ast_mutex_lock(&p->lock);
ast_mutex_lock(&p->lock)
ast_mutex_lock
ast_mutex_lock
&p->lock
p->lock
p
p
lock
if (p->chan == chan) {							p->chan = NULL;						}
p->chan == chan
p->chan
p
p
chan
chan
chan
{							p->chan = NULL;						}
p->chan = NULL;
p->chan = NULL
p->chan
p
p
chan
NULL
NULL
if (p->app_lock_flag == 1) {							ast_cond_signal(&p->login_wait_cond);							ast_cond_wait(&p->app_complete_cond, &p->lock);						}
p->app_lock_flag == 1
p->app_lock_flag
p
p
app_lock_flag
1
{							ast_cond_signal(&p->login_wait_cond);							ast_cond_wait(&p->app_complete_cond, &p->lock);						}
ast_cond_signal(&p->login_wait_cond);
ast_cond_signal(&p->login_wait_cond)
ast_cond_signal
ast_cond_signal
&p->login_wait_cond
p->login_wait_cond
p
p
login_wait_cond
ast_cond_wait(&p->app_complete_cond, &p->lock);
ast_cond_wait(&p->app_complete_cond, &p->lock)
ast_cond_wait
ast_cond_wait
&p->app_complete_cond
p->app_complete_cond
p
p
app_complete_cond
&p->lock
p->lock
p
p
lock
if (res && p->owner)							ast_log(LOG_WARNING, "Huh?  We broke out when there was still an owner?\n");
res && p->owner
res
res
p->owner
p
p
owner
ast_log(LOG_WARNING, "Huh?  We broke out when there was still an owner?\n");
ast_log(LOG_WARNING, "Huh?  We broke out when there was still an owner?\n")
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"Huh?  We broke out when there was still an owner?\n"
p->acknowledged = 0;
p->acknowledged = 0
p->acknowledged
p
p
acknowledged
0
logintime = time(NULL) - p->loginstart;
logintime = time(NULL) - p->loginstart
logintime
logintime
time(NULL) - p->loginstart
time(NULL)
time
time
NULL
NULL
p->loginstart
p
p
loginstart
p->loginstart = 0;
p->loginstart = 0
p->loginstart
p
p
loginstart
0
ast_mutex_unlock(&p->lock);
ast_mutex_unlock(&p->lock)
ast_mutex_unlock
ast_mutex_unlock
&p->lock
p->lock
p
p
lock
manager_event(EVENT_FLAG_AGENT, "Agentlogoff",							      "Agent: %s\r\n"							      "Logintime: %ld\r\n"							      "Uniqueid: %s\r\n",							      p->agent, logintime, ast_channel_uniqueid(chan));
manager_event(EVENT_FLAG_AGENT, "Agentlogoff",							      "Agent: %s\r\n"							      "Logintime: %ld\r\n"							      "Uniqueid: %s\r\n",							      p->agent, logintime, ast_channel_uniqueid(chan))
manager_event
manager_event
EVENT_FLAG_AGENT
EVENT_FLAG_AGENT
"Agentlogoff"
"Agent: %s\r\n"							      "Logintime: %ld\r\n"							      "Uniqueid: %s\r\n"
p->agent
p
p
agent
logintime
logintime
ast_channel_uniqueid(chan)
ast_channel_uniqueid
ast_channel_uniqueid
chan
chan
ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGOFF", "%s|%ld", ast_channel_name(chan), logintime);
ast_queue_log("NONE", ast_channel_uniqueid(chan), agent, "AGENTLOGOFF", "%s|%ld", ast_channel_name(chan), logintime)
ast_queue_log
ast_queue_log
"NONE"
ast_channel_uniqueid(chan)
ast_channel_uniqueid
ast_channel_uniqueid
chan
chan
agent
agent
"AGENTLOGOFF"
"%s|%ld"
ast_channel_name(chan)
ast_channel_name
ast_channel_name
chan
chan
logintime
logintime
ast_verb(2, "Agent '%s' logged out\n", p->agent);
ast_verb(2, "Agent '%s' logged out\n", p->agent)
ast_verb
ast_verb
2
"Agent '%s' logged out\n"
p->agent
p
p
agent
ast_devstate_changed(AST_DEVICE_UNAVAILABLE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);
ast_devstate_changed(AST_DEVICE_UNAVAILABLE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent)
ast_devstate_changed
ast_devstate_changed
AST_DEVICE_UNAVAILABLE
AST_DEVICE_UNAVAILABLE
AST_DEVSTATE_CACHABLE
AST_DEVSTATE_CACHABLE
"Agent/%s"
p->agent
p
p
agent
if (p->dead && !p->owner) {							ast_mutex_destroy(&p->lock);							ast_cond_destroy(&p->app_complete_cond);							ast_cond_destroy(&p->login_wait_cond);							ast_free(p);						}
p->dead && !p->owner
p->dead
p
p
dead
!p->owner
p->owner
p
p
owner
{							ast_mutex_destroy(&p->lock);							ast_cond_destroy(&p->app_complete_cond);							ast_cond_destroy(&p->login_wait_cond);							ast_free(p);						}
ast_mutex_destroy(&p->lock);
ast_mutex_destroy(&p->lock)
ast_mutex_destroy
ast_mutex_destroy
&p->lock
p->lock
p
p
lock
ast_cond_destroy(&p->app_complete_cond);
ast_cond_destroy(&p->app_complete_cond)
ast_cond_destroy
ast_cond_destroy
&p->app_complete_cond
p->app_complete_cond
p
p
app_complete_cond
ast_cond_destroy(&p->login_wait_cond);
ast_cond_destroy(&p->login_wait_cond)
ast_cond_destroy
ast_cond_destroy
&p->login_wait_cond
p->login_wait_cond
p
p
login_wait_cond
ast_free(p);
ast_free(p)
ast_free
ast_free
p
p
{						ast_mutex_unlock(&p->lock);						p = NULL;					}
ast_mutex_unlock(&p->lock);
ast_mutex_unlock(&p->lock)
ast_mutex_unlock
ast_mutex_unlock
&p->lock
p->lock
p
p
lock
p = NULL;
p = NULL
p
p
NULL
NULL
res = -1;
res = -1
res
res
-1
1
{					ast_mutex_unlock(&p->lock);					errmsg = "agent-alreadyon";					p = NULL;				}
ast_mutex_unlock(&p->lock);
ast_mutex_unlock(&p->lock)
ast_mutex_unlock
ast_mutex_unlock
&p->lock
p->lock
p
p
lock
errmsg = "agent-alreadyon";
errmsg = "agent-alreadyon"
errmsg
errmsg
"agent-alreadyon"
p = NULL;
p = NULL
p
p
NULL
NULL
break;
ast_mutex_unlock(&p->lock);
ast_mutex_unlock(&p->lock)
ast_mutex_unlock
ast_mutex_unlock
&p->lock
p->lock
p
p
lock
if (unlock_channel) {				ast_channel_unlock(chan);			}
unlock_channel
unlock_channel
{				ast_channel_unlock(chan);			}
ast_channel_unlock(chan);
ast_channel_unlock(chan)
ast_channel_unlock
ast_channel_unlock
chan
chan
if (!p)			AST_LIST_UNLOCK(&agents);
!p
p
p
AST_LIST_UNLOCK(&agents);
AST_LIST_UNLOCK(&agents)
AST_LIST_UNLOCK
AST_LIST_UNLOCK
&agents
agents
agents
if (!res && (max_login_tries==0 || tries < max_login_tries))			res = ast_app_getdata(chan, errmsg, user, sizeof(user) - 1, 0);
!res && (max_login_tries==0 || tries < max_login_tries)
!res
res
res
(max_login_tries==0 || tries < max_login_tries)
max_login_tries==0 || tries < max_login_tries
max_login_tries==0
max_login_tries
max_login_tries
0
tries < max_login_tries
tries
tries
max_login_tries
max_login_tries
res = ast_app_getdata(chan, errmsg, user, sizeof(user) - 1, 0);
res = ast_app_getdata(chan, errmsg, user, sizeof(user) - 1, 0)
res
res
ast_app_getdata(chan, errmsg, user, sizeof(user) - 1, 0)
ast_app_getdata
ast_app_getdata
chan
chan
errmsg
errmsg
user
user
sizeof(user) - 1
sizeof(user)
(user)
user
user
1
0
if (!res)		res = ast_safe_sleep(chan, 500);
!res
res
res
res = ast_safe_sleep(chan, 500);
res = ast_safe_sleep(chan, 500)
res
res
ast_safe_sleep(chan, 500)
ast_safe_sleep
ast_safe_sleep
chan
chan
500
ast_module_user_remove(u);
ast_module_user_remove(u)
ast_module_user_remove
ast_module_user_remove
u
u
return -1;
-1
1
-----joern-----
(3,144,0)
(552,34,0)
(284,688,0)
(757,287,0)
(406,216,0)
(229,53,0)
(119,229,0)
(418,764,0)
(403,1173,0)
(737,59,0)
(375,391,0)
(930,947,0)
(745,313,0)
(973,95,0)
(274,384,0)
(623,654,0)
(703,932,0)
(508,690,0)
(501,261,0)
(557,134,0)
(877,789,0)
(109,203,0)
(331,37,0)
(325,823,0)
(356,1104,0)
(51,845,0)
(1051,747,0)
(194,1149,0)
(779,184,0)
(555,1029,0)
(833,229,0)
(976,223,0)
(960,197,0)
(92,70,0)
(629,301,0)
(115,352,0)
(182,156,0)
(636,1003,0)
(679,263,0)
(946,943,0)
(833,1104,0)
(1144,175,0)
(1173,617,0)
(178,115,0)
(889,762,0)
(18,654,0)
(271,229,0)
(436,875,0)
(787,947,0)
(786,654,0)
(559,59,0)
(874,878,0)
(939,938,0)
(1034,783,0)
(298,654,0)
(192,180,0)
(761,183,0)
(692,215,0)
(806,541,0)
(369,654,0)
(1138,1142,0)
(632,1029,0)
(303,790,0)
(1055,545,0)
(657,227,0)
(140,790,0)
(302,576,0)
(1127,1003,0)
(807,649,0)
(865,493,0)
(485,169,0)
(457,654,0)
(675,984,0)
(758,1096,0)
(311,1048,0)
(765,64,0)
(334,317,0)
(222,435,0)
(73,1029,0)
(1112,134,0)
(477,217,0)
(123,446,0)
(534,240,0)
(906,1096,0)
(817,654,0)
(721,964,0)
(182,656,0)
(195,992,0)
(518,1060,0)
(718,1045,0)
(871,161,0)
(161,654,0)
(555,1104,0)
(696,516,0)
(998,779,0)
(1008,161,0)
(267,64,0)
(84,634,0)
(256,516,0)
(632,229,0)
(416,1166,0)
(400,369,0)
(313,59,0)
(215,90,0)
(518,654,0)
(501,740,0)
(0,70,0)
(1078,234,0)
(242,186,0)
(255,1026,0)
(510,511,0)
(1073,319,0)
(259,1060,0)
(942,244,0)
(632,1104,0)
(214,1166,0)
(1045,718,0)
(655,654,0)
(740,308,0)
(442,531,0)
(539,700,0)
(631,849,0)
(426,1034,0)
(145,833,0)
(616,670,0)
(259,542,0)
(771,1156,0)
(57,385,0)
(226,1036,0)
(417,1156,0)
(305,1118,0)
(959,139,0)
(833,145,0)
(633,131,0)
(322,60,0)
(501,561,0)
(1143,33,0)
(271,1104,0)
(180,192,0)
(801,1057,0)
(1131,809,0)
(182,646,0)
(511,510,0)
(982,924,0)
(501,709,0)
(1100,690,0)
(978,787,0)
(819,263,0)
(109,736,0)
(4,252,0)
(809,404,0)
(1159,361,0)
(770,576,0)
(1122,360,0)
(62,150,0)
(576,302,0)
(283,314,0)
(178,1129,0)
(514,615,0)
(931,138,0)
(777,868,0)
(972,502,0)
(144,3,0)
(785,423,0)
(549,863,0)
(1133,602,0)
(68,593,0)
(930,738,0)
(813,352,0)
(823,141,0)
(996,870,0)
(671,901,0)
(118,697,0)
(18,21,0)
(1031,638,0)
(118,613,0)
(837,777,0)
(971,615,0)
(777,234,0)
(545,518,0)
(886,88,0)
(161,542,0)
(311,617,0)
(1053,616,0)
(989,1029,0)
(265,594,0)
(727,324,0)
(387,994,0)
(538,655,0)
(955,550,0)
(1132,301,0)
(816,231,0)
(667,197,0)
(993,848,0)
(1010,21,0)
(513,688,0)
(762,854,0)
(361,301,0)
(103,915,0)
(1036,583,0)
(958,677,0)
(259,229,0)
(155,1142,0)
(298,648,0)
(672,583,0)
(1023,999,0)
(162,1052,0)
(820,891,0)
(900,521,0)
(1106,118,0)
(459,209,0)
(501,467,0)
(304,1012,0)
(705,844,0)
(479,354,0)
(407,235,0)
(820,1036,0)
(314,817,0)
(423,785,0)
(258,291,0)
(77,352,0)
(898,992,0)
(655,112,0)
(767,637,0)
(334,90,0)
(83,319,0)
(895,369,0)
(616,938,0)
(491,783,0)
(360,279,0)
(501,301,0)
(24,184,0)
(785,384,0)
(0,219,0)
(894,963,0)
(56,186,0)
(1103,271,0)
(456,434,0)
(1130,263,0)
(376,356,0)
(578,848,0)
(831,654,0)
(450,62,0)
(564,831,0)
(910,141,0)
(399,561,0)
(112,655,0)
(528,894,0)
(14,88,0)
(473,219,0)
(75,728,0)
(347,563,0)
(2,62,0)
(779,12,0)
(350,654,0)
(1052,115,0)
(613,118,0)
(480,63,0)
(852,319,0)
(892,868,0)
(247,587,0)
(490,385,0)
(732,715,0)
(145,732,0)
(924,6,0)
(474,13,0)
(307,161,0)
(932,314,0)
(639,12,0)
(902,868,0)
(670,616,0)
(860,654,0)
(410,308,0)
(863,126,0)
(1118,1059,0)
(779,1104,0)
(291,1087,0)
(560,519,0)
(118,738,0)
(389,654,0)
(493,865,0)
(174,178,0)
(0,868,0)
(966,824,0)
(101,1073,0)
(829,300,0)
(968,845,0)
(845,301,0)
(434,875,0)
(404,1116,0)
(715,732,0)
(314,361,0)
(96,1121,0)
(270,1095,0)
(13,918,0)
(579,328,0)
(1088,404,0)
(814,590,0)
(332,986,0)
(215,388,0)
(697,959,0)
(645,301,0)
(1113,662,0)
(961,335,0)
(1069,365,0)
(255,654,0)
(176,53,0)
(528,319,0)
(580,847,0)
(356,473,0)
(25,632,0)
(1054,75,0)
(37,331,0)
(1109,62,0)
(975,281,0)
(316,298,0)
(911,1147,0)
(846,685,0)
(365,59,0)
(1166,214,0)
(530,134,0)
(390,453,0)
(698,354,0)
(884,606,0)
(279,360,0)
(335,513,0)
(750,704,0)
(888,870,0)
(30,83,0)
(27,865,0)
(825,853,0)
(411,498,0)
(993,845,0)
(959,166,0)
(927,563,0)
(979,946,0)
(62,923,0)
(116,59,0)
(963,1130,0)
(1128,694,0)
(519,207,0)
(803,524,0)
(371,135,0)
(609,114,0)
(1084,847,0)
(259,184,0)
(451,738,0)
(534,636,0)
(576,786,0)
(596,552,0)
(627,784,0)
(156,182,0)
(407,1172,0)
(614,986,0)
(1135,114,0)
(974,654,0)
(1087,291,0)
(467,365,0)
(401,1087,0)
(380,349,0)
(321,811,0)
(291,1162,0)
(992,654,0)
(1150,226,0)
(34,59,0)
(172,728,0)
(581,324,0)
(921,762,0)
(97,670,0)
(1028,255,0)
(384,738,0)
(259,932,0)
(779,513,0)
(430,343,0)
(219,902,0)
(150,654,0)
(833,1029,0)
(1025,388,0)
(968,313,0)
(897,202,0)
(1007,738,0)
(553,528,0)
(1089,687,0)
(967,685,0)
(183,761,0)
(1126,301,0)
(141,823,0)
(622,849,0)
(309,301,0)
(1039,132,0)
(24,1060,0)
(473,356,0)
(789,728,0)
(505,852,0)
(542,913,0)
(810,540,0)
(201,90,0)
(872,1045,0)
(87,215,0)
(919,53,0)
(728,301,0)
(990,1007,0)
(632,184,0)
(1160,860,0)
(831,564,0)
(335,932,0)
(372,417,0)
(210,442,0)
(359,759,0)
(406,932,0)
(314,654,0)
(340,75,0)
(1080,244,0)
(315,902,0)
(815,1122,0)
(526,263,0)
(533,260,0)
(371,455,0)
(1030,70,0)
(179,654,0)
(1010,1117,0)
(687,791,0)
(182,1156,0)
(435,222,0)
(715,868,0)
(60,308,0)
(501,1093,0)
(383,1133,0)
(198,357,0)
(952,630,0)
(1085,293,0)
(652,982,0)
(1115,90,0)
(551,113,0)
(35,922,0)
(223,412,0)
(811,201,0)
(432,279,0)
(529,83,0)
(638,1031,0)
(1043,0,0)
(346,391,0)
(644,54,0)
(169,587,0)
(502,1076,0)
(853,654,0)
(515,600,0)
(1164,1104,0)
(354,170,0)
(525,334,0)
(287,112,0)
(1044,343,0)
(1014,487,0)
(1092,1167,0)
(29,738,0)
(509,531,0)
(678,719,0)
(1019,53,0)
(516,288,0)
(650,458,0)
(894,528,0)
(289,811,0)
(1134,1121,0)
(675,268,0)
(345,1064,0)
(779,54,0)
(132,1158,0)
(944,86,0)
(1091,985,0)
(185,253,0)
(24,1029,0)
(931,899,0)
(99,453,0)
(802,1130,0)
(476,777,0)
(1074,833,0)
(779,943,0)
(846,52,0)
(221,1093,0)
(266,259,0)
(1096,758,0)
(117,301,0)
(55,736,0)
(616,738,0)
(591,993,0)
(343,800,0)
(461,102,0)
(422,136,0)
(669,277,0)
(592,738,0)
(595,734,0)
(23,13,0)
(127,255,0)
(782,136,0)
(901,301,0)
(985,1039,0)
(3,654,0)
(971,231,0)
(664,192,0)
(157,715,0)
(621,888,0)
(751,744,0)
(170,18,0)
(261,1048,0)
(924,982,0)
(1049,1110,0)
(558,1122,0)
(953,526,0)
(716,1119,0)
(618,1052,0)
(42,1119,0)
(811,321,0)
(977,993,0)
(169,1102,0)
(246,59,0)
(607,709,0)
(212,667,0)
(938,616,0)
(95,973,0)
(501,57,0)
(582,581,0)
(550,1004,0)
(466,501,0)
(38,661,0)
(817,314,0)
(1154,994,0)
(1141,423,0)
(993,591,0)
(656,425,0)
(487,610,0)
(335,1060,0)
(755,169,0)
(812,694,0)
(624,561,0)
(947,787,0)
(42,541,0)
(584,738,0)
(248,594,0)
(199,518,0)
(306,301,0)
(34,552,0)
(294,962,0)
(852,64,0)
(21,1010,0)
(1110,31,0)
(235,1040,0)
(951,845,0)
(1153,635,0)
(1064,184,0)
(880,662,0)
(21,18,0)
(1120,763,0)
(278,787,0)
(1081,923,0)
(899,931,0)
(722,352,0)
(683,253,0)
(993,738,0)
(227,657,0)
(421,1081,0)
(8,999,0)
(40,59,0)
(950,728,0)
(351,990,0)
(170,354,0)
(169,516,0)
(1145,301,0)
(259,216,0)
(681,1093,0)
(710,83,0)
(75,340,0)
(680,1120,0)
(70,301,0)
(949,635,0)
(1002,124,0)
(826,169,0)
(1013,532,0)
(708,118,0)
(790,615,0)
(1002,730,0)
(39,542,0)
(313,968,0)
(45,377,0)
(779,1029,0)
(691,649,0)
(870,888,0)
(272,724,0)
(452,1004,0)
(165,1034,0)
(531,442,0)
(230,1048,0)
(848,993,0)
(52,125,0)
(207,654,0)
(54,779,0)
(682,301,0)
(530,781,0)
(249,630,0)
(896,53,0)
(656,182,0)
(1018,943,0)
(937,1173,0)
(130,1031,0)
(317,334,0)
(478,584,0)
(53,319,0)
(908,945,0)
(62,608,0)
(657,1167,0)
(0,324,0)
(18,170,0)
(637,288,0)
(593,654,0)
(98,784,0)
(1070,565,0)
(1155,264,0)
(640,203,0)
(1121,760,0)
(113,551,0)
(441,1016,0)
(963,894,0)
(235,407,0)
(1120,954,0)
(152,134,0)
(705,738,0)
(615,654,0)
(91,109,0)
(501,948,0)
(300,960,0)
(107,855,0)
(495,226,0)
(268,675,0)
(501,253,0)
(259,12,0)
(1108,86,0)
(777,1078,0)
(520,654,0)
(918,789,0)
(252,4,0)
(1070,1158,0)
(598,606,0)
(458,184,0)
(46,301,0)
(828,819,0)
(585,654,0)
(37,566,0)
(903,940,0)
(730,1002,0)
(366,247,0)
(428,963,0)
(1020,520,0)
(319,301,0)
(122,615,0)
(160,1016,0)
(1119,42,0)
(482,28,0)
(995,237,0)
(335,1029,0)
(129,186,0)
(775,350,0)
(497,832,0)
(818,702,0)
(859,301,0)
(564,1036,0)
(628,1006,0)
(577,134,0)
(1168,57,0)
(839,1005,0)
(1004,654,0)
(794,159,0)
(201,460,0)
(899,134,0)
(746,298,0)
(707,1102,0)
(934,777,0)
(726,259,0)
(308,410,0)
(282,207,0)
(367,738,0)
(82,173,0)
(375,444,0)
(507,585,0)
(61,993,0)
(1095,870,0)
(253,814,0)
(138,931,0)
(78,319,0)
(231,105,0)
(853,11,0)
(264,1155,0)
(20,688,0)
(641,1071,0)
(167,993,0)
(392,134,0)
(259,513,0)
(764,229,0)
(917,1015,0)
(940,569,0)
(752,3,0)
(493,302,0)
(49,388,0)
(1062,730,0)
(46,654,0)
(133,1102,0)
(992,898,0)
(472,223,0)
(225,800,0)
(502,21,0)
(601,634,0)
(369,216,0)
(830,1171,0)
(204,56,0)
(957,831,0)
(501,300,0)
(226,291,0)
(186,56,0)
(12,541,0)
(1005,860,0)
(271,216,0)
(461,654,0)
(835,317,0)
(151,301,0)
(360,301,0)
(827,806,0)
(1147,911,0)
(733,875,0)
(128,609,0)
(890,1163,0)
(504,74,0)
(882,24,0)
(952,29,0)
(171,215,0)
(336,654,0)
(948,1036,0)
(858,300,0)
(287,301,0)
(908,263,0)
(1015,915,0)
(437,384,0)
(318,817,0)
(254,768,0)
(606,654,0)
(1117,769,0)
(713,591,0)
(382,1147,0)
(64,852,0)
(768,1052,0)
(606,203,0)
(1156,173,0)
(1097,139,0)
(907,780,0)
(870,522,0)
(499,520,0)
(24,1104,0)
(1148,301,0)
(302,493,0)
(444,526,0)
(503,1052,0)
(555,216,0)
(143,112,0)
(321,337,0)
(501,637,0)
(938,654,0)
(988,637,0)
(66,314,0)
(146,586,0)
(643,734,0)
(1147,352,0)
(834,1167,0)
(1000,811,0)
(741,854,0)
(384,684,0)
(842,123,0)
(712,134,0)
(358,144,0)
(193,790,0)
(24,216,0)
(95,964,0)
(945,908,0)
(616,780,0)
(276,1015,0)
(690,508,0)
(291,583,0)
(956,878,0)
(1045,237,0)
(36,901,0)
(1017,603,0)
(388,215,0)
(109,1171,0)
(257,1063,0)
(800,343,0)
(758,712,0)
(1038,551,0)
(506,994,0)
(1060,518,0)
(926,260,0)
(881,301,0)
(847,63,0)
(631,134,0)
(715,70,0)
(1052,197,0)
(137,352,0)
(71,311,0)
(288,468,0)
(149,1107,0)
(974,488,0)
(328,579,0)
(327,10,0)
(862,457,0)
(1157,894,0)
(1022,60,0)
(902,324,0)
(431,684,0)
(701,109,0)
(1107,654,0)
(409,984,0)
(292,1155,0)
(969,646,0)
(448,581,0)
(438,501,0)
(1079,700,0)
(273,214,0)
(527,139,0)
(970,654,0)
(902,734,0)
(168,464,0)
(79,234,0)
(295,993,0)
(594,1089,0)
(250,744,0)
(600,515,0)
(24,229,0)
(964,95,0)
(465,301,0)
(565,759,0)
(109,649,0)
(224,740,0)
(857,654,0)
(885,740,0)
(542,161,0)
(332,125,0)
(702,331,0)
(501,793,0)
(860,1005,0)
(429,260,0)
(856,1003,0)
(915,1015,0)
(808,974,0)
(207,519,0)
(1105,614,0)
(1064,654,0)
(406,1104,0)
(634,601,0)
(433,702,0)
(581,70,0)
(53,521,0)
(1009,1045,0)
(709,175,0)
(1152,263,0)
(381,384,0)
(427,630,0)
(1050,738,0)
(410,593,0)
(962,294,0)
(909,251,0)
(1067,963,0)
(487,1014,0)
(954,524,0)
(147,585,0)
(139,959,0)
(918,728,0)
(395,820,0)
(719,464,0)
(687,1089,0)
(980,327,0)
(417,425,0)
(32,291,0)
(445,1154,0)
(748,150,0)
(423,654,0)
(140,654,0)
(413,134,0)
(866,918,0)
(219,473,0)
(271,932,0)
(488,974,0)
(22,262,0)
(725,923,0)
(131,584,0)
(648,298,0)
(188,656,0)
(164,968,0)
(865,857,0)
(389,526,0)
(28,482,0)
(636,534,0)
(203,1171,0)
(348,855,0)
(819,734,0)
(443,690,0)
(1173,615,0)
(453,1162,0)
(766,820,0)
(191,697,0)
(567,966,0)
(682,654,0)
(779,542,0)
(878,1121,0)
(501,855,0)
(1107,531,0)
(384,785,0)
(19,301,0)
(617,1173,0)
(232,738,0)
(712,758,0)
(386,202,0)
(1122,301,0)
(764,34,0)
(649,385,0)
(579,1156,0)
(72,982,0)
(599,467,0)
(1056,263,0)
(449,1124,0)
(1146,1076,0)
(779,216,0)
(60,1022,0)
(796,984,0)
(335,184,0)
(1058,292,0)
(905,1042,0)
(17,1060,0)
(120,301,0)
(1095,542,0)
(997,349,0)
(220,336,0)
(824,59,0)
(377,914,0)
(312,526,0)
(864,3,0)
(581,732,0)
(321,121,0)
(720,301,0)
(1172,407,0)
(804,461,0)
(521,1073,0)
(604,1120,0)
(190,738,0)
(852,1040,0)
(1083,628,0)
(823,325,0)
(531,1107,0)
(241,1171,0)
(653,412,0)
(875,319,0)
(547,809,0)
(677,958,0)
(299,216,0)
(1098,1095,0)
(863,513,0)
(331,702,0)
(747,526,0)
(1136,926,0)
(335,1104,0)
(793,1042,0)
(666,261,0)
(108,1057,0)
(597,1034,0)
(218,350,0)
(297,141,0)
(419,793,0)
(798,317,0)
(80,526,0)
(470,915,0)
(11,324,0)
(244,324,0)
(425,646,0)
(1104,963,0)
(384,274,0)
(264,59,0)
(146,352,0)
(362,971,0)
(935,467,0)
(898,663,0)
(844,705,0)
(9,182,0)
(80,69,0)
(774,638,0)
(777,934,0)
(356,1029,0)
(31,201,0)
(1036,564,0)
(31,1110,0)
(124,1002,0)
(993,697,0)
(753,31,0)
(902,70,0)
(279,397,0)
(112,301,0)
(402,574,0)
(94,571,0)
(336,393,0)
(1078,585,0)
(1007,990,0)
(1156,352,0)
(855,451,0)
(1057,566,0)
(394,132,0)
(632,25,0)
(615,738,0)
(83,263,0)
(1066,292,0)
(665,993,0)
(81,616,0)
(148,963,0)
(344,389,0)
(570,59,0)
(512,461,0)
(780,616,0)
(463,573,0)
(960,33,0)
(571,209,0)
(294,59,0)
(245,814,0)
(517,548,0)
(323,969,0)
(132,394,0)
(240,674,0)
(836,600,0)
(635,4,0)
(936,420,0)
(124,134,0)
(424,608,0)
(1094,922,0)
(391,375,0)
(407,129,0)
(844,86,0)
(791,1031,0)
(341,609,0)
(983,223,0)
(501,782,0)
(1111,1163,0)
(586,146,0)
(228,747,0)
(126,863,0)
(179,352,0)
(718,1095,0)
(76,857,0)
(1089,594,0)
(1029,301,0)
(875,434,0)
(356,229,0)
(6,924,0)
(869,12,0)
(999,1147,0)
(135,371,0)
(777,324,0)
(464,301,0)
(697,738,0)
(132,1039,0)
(62,648,0)
(524,954,0)
(838,1096,0)
(769,1117,0)
(534,455,0)
(1151,600,0)
(114,609,0)
(779,1060,0)
(575,115,0)
(668,369,0)
(1129,178,0)
(1061,161,0)
(660,782,0)
(863,654,0)
(237,44,0)
(609,654,0)
(440,963,0)
(208,1162,0)
(1,166,0)
(761,541,0)
(18,738,0)
(308,1171,0)
(778,412,0)
(1068,83,0)
(63,847,0)
(1136,541,0)
(285,610,0)
(271,1029,0)
(1031,319,0)
(239,18,0)
(861,593,0)
(406,1029,0)
(214,654,0)
(444,375,0)
(1003,636,0)
(661,69,0)
(166,959,0)
(74,302,0)
(370,514,0)
(1060,202,0)
(883,134,0)
(1039,985,0)
(987,850,0)
(406,184,0)
(788,313,0)
(543,184,0)
(724,420,0)
(259,870,0)
(356,216,0)
(206,971,0)
(462,514,0)
(781,530,0)
(21,502,0)
(425,417,0)
(715,324,0)
(800,658,0)
(420,369,0)
(86,844,0)
(581,868,0)
(314,932,0)
(275,915,0)
(792,59,0)
(1162,583,0)
(205,964,0)
(1034,1032,0)
(1047,209,0)
(833,216,0)
(523,853,0)
(277,654,0)
(540,293,0)
(342,311,0)
(700,304,0)
(1081,623,0)
(33,960,0)
(337,321,0)
(349,583,0)
(986,332,0)
(1155,292,0)
(486,1146,0)
(216,369,0)
(789,918,0)
(548,962,0)
(1037,118,0)
(912,902,0)
(280,34,0)
(926,1136,0)
(916,498,0)
(717,393,0)
(393,615,0)
(732,581,0)
(1169,334,0)
(1102,169,0)
(546,684,0)
(790,140,0)
(489,674,0)
(833,184,0)
(1048,105,0)
(213,736,0)
(223,738,0)
(1031,791,0)
(180,263,0)
(603,301,0)
(1101,958,0)
(623,1081,0)
(158,610,0)
(110,806,0)
(550,1032,0)
(447,302,0)
(420,724,0)
(555,229,0)
(153,301,0)
(876,601,0)
(442,654,0)
(1077,173,0)
(999,586,0)
(928,102,0)
(805,377,0)
(521,53,0)
(173,1156,0)
(1041,532,0)
(458,1029,0)
(772,0,0)
(920,1078,0)
(1040,852,0)
(453,654,0)
(545,654,0)
(941,360,0)
(873,677,0)
(963,1104,0)
(326,603,0)
(744,1052,0)
(832,123,0)
(1114,623,0)
(731,867,0)
(611,730,0)
(686,301,0)
(1081,603,0)
(516,169,0)
(1081,608,0)
(925,540,0)
(918,13,0)
(53,229,0)
(187,288,0)
(535,674,0)
(565,1070,0)
(406,229,0)
(271,184,0)
(700,329,0)
(177,555,0)
(4,635,0)
(791,687,0)
(843,406,0)
(589,301,0)
(970,115,0)
(561,237,0)
(689,301,0)
(325,569,0)
(729,301,0)
(1026,255,0)
(238,156,0)
(781,662,0)
(1056,355,0)
(159,313,0)
(779,677,0)
(310,382,0)
(610,487,0)
(1027,353,0)
(1167,657,0)
(494,134,0)
(439,54,0)
(102,587,0)
(496,513,0)
(355,1056,0)
(1014,125,0)
(714,56,0)
(773,891,0)
(744,960,0)
(591,654,0)
(501,800,0)
(1045,404,0)
(25,878,0)
(811,1147,0)
(16,182,0)
(867,392,0)
(175,368,0)
(104,460,0)
(50,460,0)
(959,697,0)
(513,863,0)
(501,1142,0)
(764,1104,0)
(339,759,0)
(483,438,0)
(981,60,0)
(922,394,0)
(1076,502,0)
(93,661,0)
(7,170,0)
(320,109,0)
(891,820,0)
(183,1149,0)
(189,263,0)
(144,358,0)
(572,756,0)
(642,74,0)
(333,738,0)
(286,729,0)
(231,971,0)
(219,0,0)
(251,118,0)
(693,31,0)
(511,134,0)
(849,631,0)
(651,868,0)
(531,845,0)
(169,102,0)
(1004,550,0)
(313,159,0)
(302,74,0)
(69,661,0)
(764,1029,0)
(1163,28,0)
(33,115,0)
(260,926,0)
(181,648,0)
(414,831,0)
(415,434,0)
(764,184,0)
(563,352,0)
(369,420,0)
(52,846,0)
(786,576,0)
(797,992,0)
(1012,304,0)
(1073,521,0)
(209,571,0)
(1063,876,0)
(454,21,0)
(510,498,0)
(711,940,0)
(1046,793,0)
(795,1012,0)
(986,614,0)
(893,301,0)
(684,384,0)
(779,229,0)
(293,540,0)
(338,780,0)
(585,1078,0)
(412,223,0)
(1076,1146,0)
(211,131,0)
(243,715,0)
(620,616,0)
(1052,744,0)
(396,301,0)
(324,234,0)
(129,407,0)
(658,59,0)
(135,88,0)
(313,845,0)
(943,946,0)
(118,251,0)
(662,781,0)
(26,126,0)
(519,560,0)
(847,301,0)
(1011,948,0)
(501,131,0)
(47,247,0)
(240,534,0)
(330,451,0)
(184,1064,0)
(759,565,0)
(562,709,0)
(625,970,0)
(100,121,0)
(962,548,0)
(799,1146,0)
(568,667,0)
(632,216,0)
(648,1071,0)
(649,308,0)
(114,1032,0)
(1172,532,0)
(1075,1063,0)
(11,853,0)
(102,461,0)
(593,410,0)
(85,18,0)
(262,569,0)
(743,969,0)
(226,1042,0)
(1162,453,0)
(469,632,0)
(259,1104,0)
(954,1120,0)
(173,654,0)
(734,301,0)
(501,382,0)
(1142,425,0)
(296,62,0)
(460,201,0)
(1099,1004,0)
(630,952,0)
(754,182,0)
(699,579,0)
(115,970,0)
(259,1029,0)
(1117,1010,0)
(1001,355,0)
(24,932,0)
(259,943,0)
(1035,832,0)
(984,675,0)
(783,1034,0)
(457,274,0)
(62,1071,0)
(739,361,0)
(887,1124,0)
(581,734,0)
(706,634,0)
(1139,140,0)
(824,966,0)
(749,738,0)
(635,654,0)
(150,62,0)
(673,261,0)
(762,738,0)
(186,129,0)
(537,515,0)
(498,510,0)
(324,11,0)
(10,59,0)
(31,1147,0)
(378,138,0)
(520,435,0)
(676,656,0)
(1021,57,0)
(1006,541,0)
(1006,628,0)
(982,654,0)
(408,948,0)
(236,768,0)
(393,336,0)
(492,934,0)
(163,251,0)
(435,520,0)
(531,738,0)
(516,404,0)
(274,457,0)
(647,923,0)
(405,658,0)
(374,301,0)
(1174,159,0)
(1165,352,0)
(291,226,0)
(1095,718,0)
(736,109,0)
(357,879,0)
(902,219,0)
(501,832,0)
(471,319,0)
(88,135,0)
(756,301,0)
(735,777,0)
(841,830,0)
(929,291,0)
(5,970,0)
(1093,201,0)
(723,782,0)
(544,1022,0)
(379,685,0)
(48,391,0)
(1052,768,0)
(335,229,0)
(269,262,0)
(994,1154,0)
(659,134,0)
(1161,1149,0)
(854,762,0)
(69,80,0)
(356,184,0)
(695,854,0)
(685,846,0)
(353,125,0)
(574,263,0)
(878,729,0)
(363,769,0)
(475,179,0)
(111,638,0)
(1033,156,0)
(536,586,0)
(878,25,0)
(822,357,0)
(649,109,0)
(53,654,0)
(1086,118,0)
(89,704,0)
(612,233,0)
(203,606,0)
(963,654,0)
(364,531,0)
(290,301,0)
(1045,288,0)
(394,922,0)
(41,352,0)
(398,729,0)
(518,545,0)
(554,1087,0)
(840,974,0)
(1072,134,0)
(1123,738,0)
(663,898,0)
(779,870,0)
(776,985,0)
(481,1034,0)
(392,867,0)
(601,876,0)
(58,138,0)
(963,319,0)
(556,382,0)
(586,999,0)
(500,860,0)
(200,608,0)
(1125,769,0)
(779,932,0)
(933,786,0)
(532,1172,0)
(106,587,0)
(851,526,0)
(848,654,0)
(196,393,0)
(1065,613,0)
(335,943,0)
(915,738,0)
(588,1118,0)
(501,514,0)
(29,952,0)
(43,352,0)
(126,654,0)
(821,369,0)
(783,654,0)
(121,321,0)
(613,654,0)
(742,46,0)
(1170,1133,0)
(233,301,0)
(10,327,0)
(304,700,0)
(142,682,0)
(65,154,0)
(965,1130,0)
(28,1163,0)
(732,145,0)
(876,1063,0)
(501,809,0)
(857,865,0)
(670,654,0)
(335,216,0)
(674,240,0)
(764,216,0)
(947,930,0)
(991,548,0)
(1040,235,0)
(373,830,0)
(617,311,0)
(1090,614,0)
(1034,114,0)
(1140,777,0)
(555,184,0)
(626,531,0)
(973,134,0)
(1149,183,0)
(934,654,0)
(67,207,0)
(1082,531,0)
(605,945,0)
(277,904,0)
(724,272,1)
(159,1174,1)
(435,520,1)
(908,945,1)
(332,986,1)
(212,1052,1)
(423,1141,1)
(780,907,1)
(918,728,1)
(442,654,1)
(1149,1161,1)
(1151,814,1)
(515,600,1)
(839,764,1)
(253,683,1)
(46,742,1)
(708,251,1)
(661,38,1)
(36,233,1)
(716,761,1)
(474,23,1)
(24,1104,1)
(552,596,1)
(1153,560,1)
(459,1047,1)
(783,654,1)
(30,1068,1)
(133,707,1)
(864,247,1)
(323,743,1)
(39,784,1)
(1026,255,1)
(371,135,1)
(339,359,1)
(886,14,1)
(929,32,1)
(113,551,1)
(963,654,1)
(963,319,1)
(748,296,1)
(121,100,1)
(1118,305,1)
(982,654,1)
(644,998,1)
(1023,1147,1)
(992,654,1)
(265,248,1)
(408,1011,1)
(300,829,1)
(1140,1078,1)
(415,456,1)
(175,1144,1)
(140,1139,1)
(635,654,1)
(711,262,1)
(488,974,1)
(998,515,1)
(280,1057,1)
(1031,638,1)
(275,470,1)
(1060,518,1)
(638,111,1)
(818,433,1)
(573,463,1)
(971,206,1)
(915,1015,1)
(128,341,1)
(634,706,1)
(731,1137,1)
(345,543,1)
(860,654,1)
(967,379,1)
(46,654,1)
(674,535,1)
(803,680,1)
(779,229,1)
(971,615,1)
(555,184,1)
(335,961,1)
(887,779,1)
(922,35,1)
(181,608,1)
(963,894,1)
(894,1157,1)
(605,83,1)
(340,75,1)
(1074,1104,1)
(277,654,1)
(407,1172,1)
(759,339,1)
(62,923,1)
(874,956,1)
(1144,709,1)
(508,690,1)
(1074,875,1)
(99,208,1)
(479,239,1)
(666,673,1)
(327,980,1)
(986,614,1)
(499,146,1)
(288,187,1)
(863,654,1)
(935,658,1)
(932,314,1)
(1011,6,1)
(33,1143,1)
(473,356,1)
(219,0,1)
(200,424,1)
(347,179,1)
(892,244,1)
(287,112,1)
(145,833,1)
(696,826,1)
(712,758,1)
(381,531,1)
(433,335,1)
(407,129,1)
(1040,852,1)
(1019,119,1)
(372,1142,1)
(272,895,1)
(31,201,1)
(269,22,1)
(512,804,1)
(258,929,1)
(97,780,1)
(501,809,1)
(63,480,1)
(580,1122,1)
(995,561,1)
(37,331,1)
(806,110,1)
(960,33,1)
(1173,615,1)
(1095,542,1)
(452,955,1)
(900,1073,1)
(32,1162,1)
(870,888,1)
(963,148,1)
(936,724,1)
(739,1159,1)
(1070,565,1)
(1087,401,1)
(991,365,1)
(1078,585,1)
(208,891,1)
(1006,628,1)
(683,185,1)
(384,785,1)
(857,76,1)
(981,308,1)
(335,216,1)
(768,254,1)
(262,269,1)
(193,617,1)
(296,450,1)
(209,459,1)
(882,1120,1)
(945,605,1)
(5,575,1)
(786,654,1)
(623,654,1)
(278,978,1)
(779,1104,1)
(632,229,1)
(640,1022,1)
(78,70,1)
(35,1094,1)
(377,45,1)
(163,909,1)
(482,28,1)
(685,967,1)
(588,1016,1)
(420,724,1)
(430,1044,1)
(963,1130,1)
(364,1081,1)
(771,349,1)
(453,654,1)
(885,224,1)
(1077,771,1)
(1063,1075,1)
(577,12,1)
(734,595,1)
(1084,580,1)
(968,164,1)
(185,336,1)
(779,932,1)
(728,950,1)
(93,235,1)
(835,1169,1)
(21,454,1)
(1073,319,1)
(156,1033,1)
(119,482,1)
(356,216,1)
(927,347,1)
(777,1078,1)
(1130,802,1)
(150,654,1)
(993,848,1)
(704,750,1)
(630,427,1)
(823,141,1)
(186,242,1)
(862,684,1)
(1052,115,1)
(412,778,1)
(31,1147,1)
(42,1119,1)
(427,249,1)
(754,425,1)
(664,918,1)
(576,786,1)
(356,229,1)
(411,916,1)
(1164,473,1)
(418,145,1)
(781,662,1)
(617,311,1)
(1102,133,1)
(668,299,1)
(1008,1061,1)
(627,530,1)
(225,343,1)
(475,1129,1)
(525,121,1)
(320,91,1)
(364,302,1)
(600,836,1)
(250,751,1)
(110,827,1)
(1007,990,1)
(831,957,1)
(617,1173,1)
(678,168,1)
(205,721,1)
(187,637,1)
(62,648,1)
(842,832,1)
(989,73,1)
(509,1082,1)
(1128,812,1)
(585,147,1)
(853,654,1)
(331,702,1)
(864,237,1)
(742,1034,1)
(24,216,1)
(797,62,1)
(578,295,1)
(233,612,1)
(298,654,1)
(64,765,1)
(709,562,1)
(999,8,1)
(311,1048,1)
(380,291,1)
(599,935,1)
(137,940,1)
(282,67,1)
(779,513,1)
(766,1036,1)
(547,1026,1)
(1054,555,1)
(632,184,1)
(882,271,1)
(305,588,1)
(410,593,1)
(787,278,1)
(1150,258,1)
(653,976,1)
(518,545,1)
(700,304,1)
(417,372,1)
(353,1027,1)
(1095,1098,1)
(118,613,1)
(466,501,1)
(513,863,1)
(293,540,1)
(316,746,1)
(938,939,1)
(1091,1070,1)
(1085,540,1)
(7,354,1)
(577,718,1)
(259,12,1)
(406,216,1)
(172,845,1)
(485,755,1)
(271,216,1)
(273,293,1)
(752,864,1)
(764,34,1)
(501,1142,1)
(140,654,1)
(167,977,1)
(923,647,1)
(335,1104,1)
(596,280,1)
(655,654,1)
(1172,532,1)
(918,789,1)
(894,528,1)
(613,1065,1)
(280,353,1)
(384,274,1)
(283,66,1)
(443,1100,1)
(761,183,1)
(959,139,1)
(155,1138,1)
(827,1136,1)
(955,663,1)
(9,16,1)
(335,184,1)
(453,390,1)
(336,393,1)
(170,354,1)
(632,1104,1)
(622,124,1)
(665,118,1)
(676,188,1)
(649,385,1)
(426,481,1)
(857,654,1)
(53,176,1)
(302,576,1)
(615,654,1)
(1141,274,1)
(214,273,1)
(848,578,1)
(53,521,1)
(419,1046,1)
(447,493,1)
(764,1104,1)
(235,407,1)
(259,932,1)
(811,1000,1)
(555,1029,1)
(809,1131,1)
(164,745,1)
(940,903,1)
(576,770,1)
(501,514,1)
(1016,441,1)
(503,618,1)
(523,727,1)
(1065,708,1)
(501,261,1)
(441,160,1)
(1080,942,1)
(624,399,1)
(703,25,1)
(649,691,1)
(236,744,1)
(564,831,1)
(373,841,1)
(341,1135,1)
(1082,442,1)
(264,1155,1)
(1041,129,1)
(802,965,1)
(584,478,1)
(1074,458,1)
(693,973,1)
(791,1031,1)
(458,650,1)
(974,840,1)
(543,1166,1)
(976,983,1)
(952,630,1)
(707,516,1)
(330,855,1)
(920,868,1)
(682,142,1)
(60,308,1)
(366,47,1)
(321,337,1)
(548,517,1)
(675,984,1)
(378,58,1)
(429,1006,1)
(695,741,1)
(551,1038,1)
(1046,891,1)
(259,184,1)
(784,98,1)
(764,418,1)
(579,699,1)
(109,649,1)
(213,55,1)
(193,1048,1)
(1081,608,1)
(336,654,1)
(1125,363,1)
(1099,452,1)
(1035,6,1)
(1001,819,1)
(742,663,1)
(501,832,1)
(24,184,1)
(80,69,1)
(439,644,1)
(826,485,1)
(176,521,1)
(222,435,1)
(362,617,1)
(555,229,1)
(101,919,1)
(764,216,1)
(882,15,1)
(571,94,1)
(966,567,1)
(1160,500,1)
(384,684,1)
(891,820,1)
(501,57,1)
(124,1002,1)
(542,161,1)
(104,50,1)
(873,140,1)
(1073,101,1)
(799,486,1)
(259,542,1)
(0,1043,1)
(335,1060,1)
(313,845,1)
(370,384,1)
(863,126,1)
(1093,681,1)
(26,549,1)
(231,816,1)
(951,319,1)
(16,754,1)
(291,226,1)
(633,211,1)
(337,1110,1)
(993,697,1)
(1053,81,1)
(334,317,1)
(521,900,1)
(431,546,1)
(501,793,1)
(1004,654,1)
(31,753,1)
(567,406,1)
(639,42,1)
(876,1063,1)
(658,405,1)
(103,762,1)
(487,610,1)
(581,324,1)
(557,511,1)
(555,1104,1)
(143,361,1)
(240,674,1)
(29,952,1)
(1156,173,1)
(346,48,1)
(493,865,1)
(595,643,1)
(67,682,1)
(295,167,1)
(492,476,1)
(1039,985,1)
(328,579,1)
(335,943,1)
(950,172,1)
(350,654,1)
(215,388,1)
(1155,292,1)
(451,330,1)
(1096,838,1)
(884,598,1)
(785,423,1)
(1110,31,1)
(632,216,1)
(549,496,1)
(910,508,1)
(1031,319,1)
(723,660,1)
(988,1026,1)
(349,997,1)
(875,434,1)
(1157,528,1)
(1002,730,1)
(160,615,1)
(85,335,1)
(949,1153,1)
(804,928,1)
(811,201,1)
(727,560,1)
(797,252,1)
(649,308,1)
(865,857,1)
(406,1104,1)
(833,216,1)
(593,654,1)
(911,382,1)
(254,236,1)
(257,915,1)
(681,221,1)
(1022,60,1)
(256,696,1)
(186,56,1)
(227,657,1)
(461,512,1)
(650,184,1)
(657,1167,1)
(174,115,1)
(808,252,1)
(501,131,1)
(84,1063,1)
(944,451,1)
(553,1067,1)
(845,51,1)
(1036,564,1)
(18,21,1)
(994,506,1)
(779,12,1)
(169,516,1)
(616,670,1)
(636,1003,1)
(207,654,1)
(1108,944,1)
(714,204,1)
(379,332,1)
(626,509,1)
(846,685,1)
(943,946,1)
(365,1069,1)
(1104,963,1)
(450,1109,1)
(1119,716,1)
(798,835,1)
(141,297,1)
(876,601,1)
(796,1154,1)
(369,420,1)
(937,311,1)
(448,715,1)
(747,1051,1)
(811,1147,1)
(779,943,1)
(928,404,1)
(794,788,1)
(531,442,1)
(858,1129,1)
(776,1091,1)
(1098,270,1)
(351,930,1)
(1051,228,1)
(1081,603,1)
(501,709,1)
(375,391,1)
(75,1054,1)
(931,138,1)
(694,1128,1)
(490,57,1)
(891,773,1)
(221,334,1)
(890,1111,1)
(34,552,1)
(462,370,1)
(1133,1170,1)
(962,548,1)
(436,482,1)
(405,800,1)
(1163,890,1)
(501,948,1)
(534,636,1)
(1049,31,1)
(469,10,1)
(1154,994,1)
(355,1001,1)
(108,801,1)
(228,908,1)
(814,245,1)
(60,322,1)
(12,869,1)
(697,959,1)
(746,181,1)
(538,143,1)
(1154,445,1)
(717,29,1)
(662,1113,1)
(706,84,1)
(777,324,1)
(409,796,1)
(673,231,1)
(969,323,1)
(168,728,1)
(1139,790,1)
(483,287,1)
(136,422,1)
(655,538,1)
(403,937,1)
(287,757,1)
(94,209,1)
(1009,870,1)
(567,350,1)
(259,1060,1)
(1114,421,1)
(61,848,1)
(620,1053,1)
(1092,46,1)
(179,475,1)
(849,622,1)
(1038,573,1)
(690,443,1)
(389,654,1)
(506,387,1)
(1056,355,1)
(563,927,1)
(905,793,1)
(416,214,1)
(938,654,1)
(89,215,1)
(1057,108,1)
(66,703,1)
(729,286,1)
(388,49,1)
(820,395,1)
(83,30,1)
(417,1156,1)
(744,250,1)
(501,782,1)
(985,776,1)
(1000,289,1)
(148,894,1)
(1101,873,1)
(906,259,1)
(757,764,1)
(268,675,1)
(755,102,1)
(528,319,1)
(680,604,1)
(556,310,1)
(779,998,1)
(656,425,1)
(280,876,1)
(880,534,1)
(996,784,1)
(956,632,1)
(764,184,1)
(81,268,1)
(335,1029,1)
(8,1023,1)
(173,654,1)
(54,439,1)
(518,654,1)
(520,1020,1)
(1044,313,1)
(947,787,1)
(271,1104,1)
(820,1036,1)
(735,837,1)
(918,13,1)
(10,327,1)
(92,1030,1)
(191,584,1)
(593,68,1)
(710,1130,1)
(533,429,1)
(481,165,1)
(983,472,1)
(726,223,1)
(335,513,1)
(800,225,1)
(62,608,1)
(767,988,1)
(1090,1105,1)
(790,303,1)
(817,654,1)
(715,868,1)
(616,938,1)
(224,358,1)
(45,805,1)
(325,823,1)
(753,693,1)
(501,438,1)
(1142,155,1)
(1137,557,1)
(342,71,1)
(53,654,1)
(613,654,1)
(266,726,1)
(210,364,1)
(684,431,1)
(817,318,1)
(286,398,1)
(535,489,1)
(82,1077,1)
(308,410,1)
(514,462,1)
(1166,416,1)
(4,635,1)
(476,735,1)
(959,166,1)
(434,415,1)
(251,163,1)
(980,294,1)
(501,382,1)
(555,177,1)
(1067,440,1)
(970,654,1)
(934,654,1)
(501,1093,1)
(878,729,1)
(1066,1058,1)
(869,639,1)
(907,338,1)
(901,671,1)
(223,412,1)
(511,510,1)
(608,200,1)
(484,513,1)
(6,924,1)
(179,654,1)
(764,1029,1)
(1107,149,1)
(604,15,1)
(302,493,1)
(1004,1099,1)
(779,54,1)
(531,845,1)
(369,400,1)
(719,678,1)
(902,324,1)
(977,591,1)
(298,316,1)
(1122,558,1)
(398,901,1)
(834,1092,1)
(534,240,1)
(807,701,1)
(1045,288,1)
(801,37,1)
(970,625,1)
(194,806,1)
(572,719,1)
(1107,654,1)
(70,92,1)
(650,1166,1)
(782,723,1)
(607,358,1)
(614,1090,1)
(843,25,1)
(502,1076,1)
(623,1114,1)
(1021,1168,1)
(235,1040,1)
(779,677,1)
(297,910,1)
(126,654,1)
(769,1125,1)
(102,461,1)
(1083,718,1)
(611,121,1)
(677,958,1)
(810,925,1)
(473,219,1)
(147,507,1)
(62,150,1)
(460,104,1)
(815,360,1)
(902,868,1)
(774,1056,1)
(55,649,1)
(57,1021,1)
(1136,926,1)
(314,654,1)
(438,483,1)
(875,733,1)
(896,1019,1)
(360,279,1)
(795,539,1)
(1047,899,1)
(1043,772,1)
(1010,1117,1)
(852,64,1)
(348,697,1)
(880,571,1)
(643,1029,1)
(586,536,1)
(454,1010,1)
(291,1087,1)
(109,736,1)
(821,668,1)
(0,868,1)
(957,414,1)
(140,790,1)
(1110,1049,1)
(1015,917,1)
(406,843,1)
(83,319,1)
(691,807,1)
(1170,383,1)
(871,1008,1)
(555,216,1)
(376,113,1)
(640,385,1)
(318,283,1)
(830,373,1)
(343,430,1)
(356,1104,1)
(208,1042,1)
(516,288,1)
(501,300,1)
(611,377,1)
(74,642,1)
(72,175,1)
(144,3,1)
(698,479,1)
(651,892,1)
(973,95,1)
(338,620,1)
(664,687,1)
(291,1162,1)
(226,1042,1)
(376,573,1)
(226,1036,1)
(243,833,1)
(721,392,1)
(500,839,1)
(770,786,1)
(437,381,1)
(56,714,1)
(867,731,1)
(1069,467,1)
(317,798,1)
(671,36,1)
(1058,824,1)
(326,1017,1)
(463,277,1)
(1031,130,1)
(344,747,1)
(1024,1137,1)
(107,348,1)
(273,1121,1)
(13,474,1)
(1005,860,1)
(81,1154,1)
(271,229,1)
(2,648,1)
(669,619,1)
(1100,563,1)
(49,1025,1)
(837,1140,1)
(1147,911,1)
(1173,403,1)
(72,830,1)
(274,457,1)
(917,276,1)
(336,220,1)
(86,1108,1)
(745,508,1)
(777,934,1)
(177,180,1)
(181,923,1)
(852,505,1)
(404,1088,1)
(779,184,1)
(529,710,1)
(616,780,1)
(277,669,1)
(764,229,1)
(895,821,1)
(786,933,1)
(902,315,1)
(1086,705,1)
(182,656,1)
(888,621,1)
(401,554,1)
(670,97,1)
(1009,542,1)
(1030,734,1)
(1088,809,1)
(170,7,1)
(545,1055,1)
(715,70,1)
(357,822,1)
(271,1029,1)
(96,1134,1)
(779,542,1)
(335,229,1)
(1017,729,1)
(207,282,1)
(965,216,1)
(670,654,1)
(214,654,1)
(252,4,1)
(816,971,1)
(123,842,1)
(1074,473,1)
(632,469,1)
(458,184,1)
(491,597,1)
(166,1,1)
(528,553,1)
(444,375,1)
(24,229,1)
(611,1110,1)
(1045,404,1)
(789,877,1)
(25,878,1)
(259,870,1)
(916,677,1)
(582,448,1)
(1122,360,1)
(324,11,1)
(259,1104,1)
(304,1012,1)
(48,389,1)
(773,820,1)
(946,979,1)
(789,728,1)
(779,1029,1)
(928,288,1)
(733,434,1)
(24,1060,1)
(579,1156,1)
(524,803,1)
(391,346,1)
(1055,199,1)
(978,1118,1)
(406,229,1)
(14,571,1)
(458,1029,1)
(1020,499,1)
(261,666,1)
(21,502,1)
(17,271,1)
(1075,257,1)
(790,615,1)
(358,144,1)
(1081,623,1)
(423,654,1)
(1105,876,1)
(149,626,1)
(501,467,1)
(182,156,1)
(393,196,1)
(687,1089,1)
(218,775,1)
(660,340,1)
(359,515,1)
(432,941,1)
(539,1079,1)
(898,992,1)
(238,656,1)
(169,1102,1)
(467,599,1)
(575,328,1)
(267,444,1)
(244,324,1)
(933,1081,1)
(442,210,1)
(825,523,1)
(489,636,1)
(635,949,1)
(779,1060,1)
(831,654,1)
(565,759,1)
(216,369,1)
(546,437,1)
(98,627,1)
(206,362,1)
(135,88,1)
(726,577,1)
(245,253,1)
(302,74,1)
(1076,1146,1)
(585,654,1)
(848,654,1)
(47,169,1)
(58,631,1)
(211,779,1)
(1117,769,1)
(129,186,1)
(1109,2,1)
(18,170,1)
(157,243,1)
(335,932,1)
(319,471,1)
(495,1150,1)
(239,85,1)
(656,676,1)
(33,115,1)
(259,943,1)
(501,637,1)
(948,408,1)
(445,994,1)
(942,324,1)
(838,906,1)
(356,184,1)
(195,797,1)
(740,885,1)
(199,17,1)
(843,932,1)
(299,340,1)
(201,460,1)
(581,582,1)
(1089,594,1)
(1028,222,1)
(53,319,1)
(866,687,1)
(520,654,1)
(27,857,1)
(1135,550,1)
(259,1029,1)
(621,996,1)
(203,606,1)
(993,845,1)
(1025,171,1)
(510,498,1)
(196,717,1)
(889,921,1)
(916,140,1)
(591,654,1)
(231,971,1)
(771,123,1)
(392,867,1)
(127,1028,1)
(390,99,1)
(255,654,1)
(1094,1039,1)
(540,810,1)
(501,253,1)
(875,319,1)
(501,561,1)
(259,229,1)
(1081,421,1)
(625,5,1)
(501,740,1)
(1161,194,1)
(725,488,1)
(71,712,1)
(532,1013,1)
(550,1004,1)
(11,853,1)
(146,586,1)
(847,63,1)
(611,357,1)
(259,266,1)
(594,265,1)
(422,782,1)
(363,170,1)
(1045,872,1)
(1052,768,1)
(757,1005,1)
(169,102,1)
(315,912,1)
(718,1045,1)
(939,670,1)
(517,991,1)
(130,638,1)
(544,60,1)
(833,1074,1)
(581,868,1)
(504,447,1)
(475,667,1)
(161,654,1)
(527,166,1)
(24,882,1)
(597,426,1)
(184,1064,1)
(606,654,1)
(899,931,1)
(992,195,1)
(537,600,1)
(38,93,1)
(311,342,1)
(1045,237,1)
(28,1163,1)
(1033,238,1)
(968,845,1)
(777,868,1)
(993,61,1)
(383,1016,1)
(165,114,1)
(598,640,1)
(394,922,1)
(109,203,1)
(833,1104,1)
(68,861,1)
(1037,1086,1)
(1103,264,1)
(1124,449,1)
(259,216,1)
(161,871,1)
(457,654,1)
(393,615,1)
(1081,923,1)
(259,513,1)
(1134,293,1)
(575,969,1)
(249,1024,1)
(772,356,1)
(486,1010,1)
(860,1160,1)
(902,734,1)
(1143,300,1)
(356,1029,1)
(24,1029,1)
(1029,989,1)
(902,70,1)
(1153,777,1)
(220,393,1)
(841,109,1)
(877,13,1)
(292,1066,1)
(244,1080,1)
(15,1060,1)
(819,828,1)
(501,855,1)
(972,1076,1)
(647,725,1)
(498,411,1)
(424,488,1)
(990,351,1)
(230,261,1)
(912,0,1)
(354,698,1)
(715,157,1)
(516,404,1)
(852,319,1)
(878,1121,1)
(406,184,1)
(788,968,1)
(822,198,1)
(249,259,1)
(1052,744,1)
(1022,544,1)
(273,227,1)
(115,970,1)
(571,209,1)
(22,325,1)
(1169,525,1)
(865,27,1)
(178,115,1)
(21,1010,1)
(856,1127,1)
(715,324,1)
(471,78,1)
(118,697,1)
(112,655,1)
(515,537,1)
(100,321,1)
(762,854,1)
(421,616,1)
(131,633,1)
(779,216,1)
(91,203,1)
(610,158,1)
(142,847,1)
(545,654,1)
(909,1106,1)
(812,700,1)
(581,734,1)
(775,406,1)
(632,1029,1)
(138,378,1)
(1079,484,1)
(854,695,1)
(530,781,1)
(1159,603,1)
(52,846,1)
(95,964,1)
(979,1018,1)
(701,320,1)
(389,344,1)
(51,951,1)
(1,191,1)
(1131,547,1)
(449,887,1)
(321,811,1)
(171,87,1)
(705,844,1)
(652,72,1)
(531,1107,1)
(192,664,1)
(964,205,1)
(507,920,1)
(978,1133,1)
(303,193,1)
(778,653,1)
(828,145,1)
(568,212,1)
(648,298,1)
(111,774,1)
(965,136,1)
(126,26,1)
(121,321,1)
(783,491,1)
(76,576,1)
(819,734,1)
(619,80,1)
(356,376,1)
(631,849,1)
(926,260,1)
(0,324,1)
(812,24,1)
(279,397,1)
(399,222,1)
(406,1029,1)
(751,503,1)
(824,966,1)
(521,1073,1)
(961,943,1)
(182,1156,1)
(1014,487,1)
(3,654,1)
(211,1124,1)
(18,654,1)
(1162,453,1)
(516,256,1)
(1120,954,1)
(1064,654,1)
(1042,905,1)
(925,227,1)
(601,634,1)
(812,484,1)
(23,866,1)
(954,524,1)
(1166,214,1)
(260,533,1)
(310,235,1)
(271,1103,1)
(271,184,1)
(1034,783,1)
(1138,328,1)
(480,1084,1)
(756,572,1)
(800,343,1)
(313,968,1)
(736,213,1)
(998,132,1)
(920,244,1)
(1048,230,1)
(682,654,1)
(382,556,1)
(637,767,1)
(687,791,1)
(293,1085,1)
(1106,1037,1)
(385,490,1)
(1097,527,1)
(558,815,1)
(198,704,1)
(395,766,1)
(603,326,1)
(478,131,1)
(560,519,1)
(941,112,1)
(833,1029,1)
(997,380,1)
(418,137,1)
(1129,178,1)
(618,162,1)
(1018,694,1)
(226,495,1)
(1113,880,1)
(609,128,1)
(294,962,1)
(1068,529,1)
(501,800,1)
(974,654,1)
(456,436,1)
(1111,458,1)
(132,394,1)
(132,1039,1)
(958,1101,1)
(158,285,1)
(139,1097,1)
(314,817,1)
(183,1149,1)
(844,86,1)
(924,982,1)
(150,748,1)
(836,1151,1)
(361,739,1)
(615,122,1)
(934,492,1)
(702,818,1)
(463,619,1)
(793,419,1)
(982,652,1)
(0,70,1)
(440,428,1)
(1074,229,1)
(406,932,1)
(322,981,1)
(88,886,1)
(718,1095,1)
(758,1096,1)
(122,514,1)
(400,420,1)
(743,182,1)
(255,127,1)
(741,889,1)
(692,201,1)
(472,1007,1)
(285,52,1)
(628,1083,1)
(562,607,1)
(1013,1041,1)
(779,870,1)
(829,858,1)
(25,632,1)
(805,704,1)
(505,64,1)
(496,24,1)
(561,624,1)
(984,409,1)
(247,366,1)
(145,732,1)
(921,993,1)
(1174,794,1)
(609,654,1)
(75,728,1)
(414,948,1)
(732,715,1)
(993,591,1)
(1151,336,1)
(750,89,1)
(612,756,1)
(878,874,1)
(314,361,1)
(1012,795,1)
(861,740,1)
(204,1040,1)
(1027,1014,1)
(765,267,1)
(1127,371,1)
(903,711,1)
(999,1147,1)
(428,1164,1)
(118,251,1)
(350,218,1)
(1003,856,1)
(744,960,1)
(178,174,1)
(87,692,1)
(50,1093,1)
(961,694,1)
(470,103,1)
(1121,96,1)
(425,417,1)
(69,661,1)
(642,504,1)
(237,995,1)
(180,192,1)
(3,752,1)
(276,275,1)
(248,791,1)
(188,9,1)
(162,960,1)
(307,39,1)
(833,229,1)
(1167,834,1)
(173,82,1)
(461,654,1)
(853,825,1)
(1062,611,1)
(554,226,1)
(833,184,1)
(732,581,1)
(387,18,1)
(271,932,1)
(137,34,1)
(730,1062,1)
(313,159,1)
(270,1045,1)
(606,884,1)
(586,999,1)
(497,1035,1)
(502,972,1)
(919,896,1)
(114,609,1)
(1168,1022,1)
(536,999,1)
(1146,799,1)
(242,56,1)
(713,665,1)
(219,902,1)
(289,337,1)
(840,808,1)
(519,207,1)
(581,70,1)
(279,432,1)
(663,898,1)
(24,932,1)
(930,947,1)
(699,1156,1)
(832,497,1)
(591,713,1)
(1064,345,1)
(420,936,1)
(872,1009,1)
(667,568,1)
(457,862,1)
(229,53,1)
(965,555,1)
(1095,870,1)
(369,654,1)
(1061,307,1)
(855,107,1)
(868,651,1)
(1034,114,1)
(1037,335,2)
(420,724,2)
(660,340,2)
(74,1081,2)
(231,971,2)
(444,375,2)
(523,560,2)
(632,1029,2)
(619,235,2)
(878,1121,2)
(911,235,2)
(537,335,2)
(10,508,2)
(167,335,2)
(342,259,2)
(332,986,2)
(1109,252,2)
(952,630,2)
(259,12,2)
(334,121,2)
(384,684,2)
(658,508,2)
(462,335,2)
(294,962,2)
(670,654,2)
(1168,1022,2)
(568,1129,2)
(173,654,2)
(18,654,2)
(275,335,2)
(356,1104,2)
(642,1081,2)
(429,718,2)
(320,358,2)
(403,311,2)
(555,216,2)
(315,0,2)
(557,259,2)
(581,715,2)
(135,88,2)
(1146,1010,2)
(741,335,2)
(199,271,2)
(408,6,2)
(534,571,2)
(243,833,2)
(369,340,2)
(46,654,2)
(112,655,2)
(811,1110,2)
(784,1137,2)
(482,458,2)
(18,335,2)
(118,613,2)
(833,216,2)
(561,222,2)
(1100,235,2)
(169,516,2)
(53,654,2)
(971,617,2)
(1114,421,2)
(1164,473,2)
(616,938,2)
(223,412,2)
(709,358,2)
(1005,860,2)
(963,319,2)
(931,138,2)
(926,718,2)
(179,654,2)
(215,121,2)
(472,335,2)
(501,261,2)
(848,654,2)
(1077,235,2)
(257,335,2)
(371,571,2)
(58,1137,2)
(723,340,2)
(390,6,2)
(425,328,2)
(1045,1137,2)
(285,876,2)
(1066,508,2)
(259,932,2)
(944,335,2)
(0,356,2)
(252,4,2)
(933,1081,2)
(800,343,2)
(122,335,2)
(25,508,2)
(712,259,2)
(854,335,2)
(358,235,2)
(31,201,2)
(698,335,2)
(228,145,2)
(702,335,2)
(816,617,2)
(393,335,2)
(460,121,2)
(274,335,2)
(876,1063,2)
(963,473,2)
(889,335,2)
(487,610,2)
(486,1010,2)
(350,406,2)
(216,340,2)
(869,718,2)
(631,849,2)
(960,1129,2)
(998,335,2)
(140,259,2)
(379,876,2)
(1082,335,2)
(29,952,2)
(132,1039,2)
(1155,292,2)
(811,201,2)
(1034,663,2)
(1090,876,2)
(24,508,2)
(259,184,2)
(977,335,2)
(1098,1045,2)
(321,811,2)
(245,336,2)
(321,1110,2)
(764,184,2)
(549,24,2)
(411,259,2)
(1173,311,2)
(787,335,2)
(137,235,2)
(1001,145,2)
(712,758,2)
(504,1081,2)
(846,685,2)
(939,335,2)
(280,508,2)
(1163,458,2)
(513,863,2)
(999,1147,2)
(518,271,2)
(205,1137,2)
(163,335,2)
(1045,404,2)
(880,1137,2)
(1110,31,2)
(726,1137,2)
(783,654,2)
(141,508,2)
(450,252,2)
(965,145,2)
(695,335,2)
(0,868,2)
(495,6,2)
(66,25,2)
(917,335,2)
(335,229,2)
(973,95,2)
(109,649,2)
(493,865,2)
(1034,114,2)
(636,571,2)
(436,482,2)
(892,244,2)
(777,934,2)
(579,235,2)
(314,654,2)
(531,442,2)
(338,335,2)
(1036,564,2)
(259,335,2)
(277,654,2)
(52,846,2)
(18,21,2)
(1040,145,2)
(328,579,2)
(198,704,2)
(1117,335,2)
(516,222,2)
(1002,730,2)
(3,235,2)
(149,335,2)
(902,868,2)
(346,145,2)
(882,508,2)
(389,654,2)
(499,235,2)
(87,121,2)
(605,145,2)
(103,335,2)
(1107,335,2)
(648,252,2)
(826,222,2)
(501,948,2)
(1047,1137,2)
(910,508,2)
(785,423,2)
(146,235,2)
(226,1036,2)
(440,473,2)
(349,6,2)
(779,677,2)
(303,259,2)
(554,6,2)
(855,335,2)
(817,654,2)
(761,183,2)
(21,502,2)
(806,718,2)
(848,335,2)
(868,244,2)
(708,335,2)
(215,388,2)
(395,6,2)
(334,317,2)
(94,1137,2)
(616,335,2)
(877,687,2)
(270,1045,2)
(216,369,2)
(229,482,2)
(540,227,2)
(0,324,2)
(959,166,2)
(144,235,2)
(528,473,2)
(1174,508,2)
(751,1129,2)
(754,328,2)
(407,129,2)
(111,145,2)
(779,1060,2)
(928,222,2)
(620,335,2)
(45,704,2)
(947,787,2)
(1055,271,2)
(982,654,2)
(974,654,2)
(984,1154,2)
(100,1110,2)
(1007,335,2)
(824,508,2)
(1099,663,2)
(458,1029,2)
(336,654,2)
(6,235,2)
(391,145,2)
(1080,560,2)
(1117,769,2)
(259,1104,2)
(714,1040,2)
(924,235,2)
(1023,235,2)
(700,484,2)
(630,335,2)
(262,508,2)
(935,508,2)
(138,1137,2)
(452,663,2)
(735,560,2)
(779,1029,2)
(487,876,2)
(466,501,2)
(332,876,2)
(227,657,2)
(1155,508,2)
(337,1110,2)
(1078,585,2)
(501,382,2)
(417,1156,2)
(210,335,2)
(908,945,2)
(696,222,2)
(1125,335,2)
(663,898,2)
(718,1045,2)
(938,335,2)
(677,140,2)
(140,654,2)
(860,654,2)
(931,1137,2)
(867,1137,2)
(1011,6,2)
(488,252,2)
(313,159,2)
(1013,129,2)
(923,488,2)
(1067,473,2)
(501,832,2)
(406,184,2)
(1083,718,2)
(633,335,2)
(839,764,2)
(715,833,2)
(1086,335,2)
(715,868,2)
(313,968,2)
(405,508,2)
(819,145,2)
(1008,784,2)
(491,663,2)
(254,1129,2)
(91,358,2)
(952,335,2)
(242,1040,2)
(1057,335,2)
(24,932,2)
(886,571,2)
(1075,335,2)
(399,222,2)
(53,319,2)
(1070,565,2)
(454,1010,2)
(1040,852,2)
(1015,335,2)
(159,508,2)
(356,229,2)
(759,515,2)
(447,1081,2)
(267,145,2)
(870,888,2)
(451,335,2)
(890,458,2)
(680,15,2)
(725,488,2)
(481,663,2)
(193,259,2)
(298,252,2)
(1085,227,2)
(39,784,2)
(550,1004,2)
(235,145,2)
(224,358,2)
(341,663,2)
(967,876,2)
(360,279,2)
(515,600,2)
(918,687,2)
(1096,259,2)
(687,791,2)
(1103,508,2)
(53,521,2)
(394,515,2)
(571,1137,2)
(822,704,2)
(1142,328,2)
(170,335,2)
(609,663,2)
(1119,718,2)
(744,1129,2)
(161,654,2)
(314,817,2)
(820,6,2)
(779,54,2)
(1074,235,2)
(793,891,2)
(178,235,2)
(563,235,2)
(302,493,2)
(331,702,2)
(512,222,2)
(72,235,2)
(335,932,2)
(406,508,2)
(804,222,2)
(80,69,2)
(155,328,2)
(305,1016,2)
(69,235,2)
(1081,603,2)
(528,319,2)
(617,1173,2)
(932,25,2)
(220,335,2)
(353,876,2)
(501,57,2)
(38,235,2)
(942,560,2)
(770,1081,2)
(1156,173,2)
(124,1002,2)
(187,1026,2)
(1073,482,2)
(1088,1026,2)
(865,857,2)
(291,226,2)
(1154,994,2)
(437,335,2)
(682,654,2)
(236,1129,2)
(510,498,2)
(824,966,2)
(649,358,2)
(1128,508,2)
(308,358,2)
(1026,222,2)
(615,654,2)
(266,335,2)
(1062,1137,2)
(670,335,2)
(930,947,2)
(968,508,2)
(853,560,2)
(762,335,2)
(921,335,2)
(503,1129,2)
(1141,335,2)
(201,460,2)
(753,1137,2)
(1068,145,2)
(259,870,2)
(626,335,2)
(27,1081,2)
(104,121,2)
(852,64,2)
(259,216,2)
(248,791,2)
(560,519,2)
(591,335,2)
(730,1137,2)
(617,259,2)
(88,571,2)
(584,335,2)
(24,229,2)
(588,1016,2)
(591,654,2)
(60,358,2)
(247,222,2)
(428,473,2)
(692,121,2)
(118,335,2)
(237,222,2)
(899,1137,2)
(1172,532,2)
(492,560,2)
(765,145,2)
(777,868,2)
(344,145,2)
(1161,718,2)
(842,6,2)
(378,1137,2)
(803,15,2)
(651,244,2)
(56,1040,2)
(204,1040,2)
(555,1104,2)
(407,1172,2)
(575,235,2)
(758,259,2)
(992,654,2)
(1046,891,2)
(133,222,2)
(366,222,2)
(579,1156,2)
(165,663,2)
(383,1016,2)
(28,458,2)
(700,304,2)
(502,1076,2)
(244,560,2)
(145,732,2)
(604,15,2)
(330,335,2)
(755,222,2)
(271,229,2)
(501,793,2)
(57,1022,2)
(508,690,2)
(253,336,2)
(1041,129,2)
(974,252,2)
(833,1029,2)
(1135,663,2)
(697,959,2)
(516,288,2)
(181,252,2)
(231,617,2)
(805,704,2)
(1010,1117,2)
(1081,335,2)
(271,508,2)
(758,1096,2)
(894,528,2)
(96,293,2)
(148,473,2)
(779,542,2)
(1140,560,2)
(833,229,2)
(795,484,2)
(981,358,2)
(150,252,2)
(158,876,2)
(230,617,2)
(340,555,2)
(123,6,2)
(279,397,2)
(647,488,2)
(435,520,2)
(648,298,2)
(1039,985,2)
(191,335,2)
(779,943,2)
(50,121,2)
(582,715,2)
(779,216,2)
(1009,1137,2)
(833,184,2)
(594,791,2)
(777,560,2)
(1104,473,2)
(632,184,2)
(1137,259,2)
(1173,615,2)
(976,335,2)
(764,216,2)
(347,235,2)
(912,0,2)
(1154,335,2)
(934,560,2)
(669,619,2)
(1018,694,2)
(186,56,2)
(1101,140,2)
(769,335,2)
(356,1029,2)
(259,943,2)
(779,870,2)
(444,145,2)
(259,229,2)
(852,145,2)
(636,1003,2)
(694,508,2)
(502,1010,2)
(676,328,2)
(779,932,2)
(0,70,2)
(132,394,2)
(632,1104,2)
(847,63,2)
(878,632,2)
(833,235,2)
(1064,1166,2)
(89,121,2)
(601,634,2)
(865,1081,2)
(449,779,2)
(85,335,2)
(482,28,2)
(375,145,2)
(1026,255,2)
(857,1081,2)
(496,24,2)
(274,457,2)
(174,235,2)
(323,328,2)
(681,121,2)
(707,222,2)
(518,654,2)
(668,340,2)
(169,1102,2)
(260,718,2)
(1162,6,2)
(1087,6,2)
(611,1137,2)
(771,235,2)
(918,728,2)
(891,820,2)
(808,252,2)
(585,560,2)
(406,1104,2)
(927,235,2)
(903,508,2)
(894,473,2)
(519,207,2)
(978,335,2)
(132,515,2)
(201,121,2)
(62,252,2)
(717,335,2)
(926,260,2)
(715,70,2)
(705,844,2)
(140,790,2)
(287,112,2)
(627,1137,2)
(434,482,2)
(715,324,2)
(13,687,2)
(336,335,2)
(501,782,2)
(791,1031,2)
(358,144,2)
(345,1166,2)
(54,998,2)
(516,404,2)
(1002,1137,2)
(530,1137,2)
(547,1026,2)
(1038,573,2)
(214,654,2)
(986,876,2)
(1031,145,2)
(484,24,2)
(915,1015,2)
(283,25,2)
(307,784,2)
(632,216,2)
(761,718,2)
(982,235,2)
(175,358,2)
(656,328,2)
(31,1147,2)
(610,876,2)
(259,513,2)
(473,356,2)
(164,508,2)
(993,845,2)
(1058,508,2)
(1127,571,2)
(922,515,2)
(924,982,2)
(124,1137,2)
(176,482,2)
(200,488,2)
(160,335,2)
(393,615,2)
(501,467,2)
(812,508,2)
(498,259,2)
(212,1129,2)
(993,335,2)
(1025,121,2)
(1091,515,2)
(24,1029,2)
(726,335,2)
(790,259,2)
(101,482,2)
(1014,487,2)
(271,1029,2)
(657,1167,2)
(567,508,2)
(900,482,2)
(705,335,2)
(677,958,2)
(501,637,2)
(844,335,2)
(21,335,2)
(577,1137,2)
(435,235,2)
(1003,571,2)
(628,718,2)
(721,1137,2)
(701,358,2)
(31,1137,2)
(718,1137,2)
(662,1137,2)
(811,1147,2)
(1035,6,2)
(318,25,2)
(776,515,2)
(442,335,2)
(387,335,2)
(1130,145,2)
(113,551,2)
(649,308,2)
(162,1129,2)
(11,853,2)
(515,335,2)
(1150,6,2)
(259,1060,2)
(791,145,2)
(1078,560,2)
(818,335,2)
(501,300,2)
(3,654,2)
(1147,235,2)
(130,145,2)
(420,340,2)
(691,358,2)
(744,960,2)
(930,335,2)
(593,358,2)
(335,1029,2)
(475,235,2)
(406,932,2)
(779,184,2)
(501,1093,2)
(530,781,2)
(963,1130,2)
(324,11,2)
(371,135,2)
(485,222,2)
(1136,926,2)
(14,571,2)
(259,1029,2)
(421,335,2)
(864,235,2)
(324,560,2)
(652,235,2)
(171,121,2)
(109,358,2)
(276,335,2)
(973,1137,2)
(786,1081,2)
(406,229,2)
(15,271,2)
(870,784,2)
(178,115,2)
(849,1137,2)
(581,324,2)
(673,617,2)
(1104,963,2)
(624,222,2)
(653,335,2)
(392,1137,2)
(932,314,2)
(539,484,2)
(235,1040,2)
(713,335,2)
(322,358,2)
(401,6,2)
(724,340,2)
(129,1040,2)
(1089,594,2)
(545,654,2)
(608,488,2)
(442,654,2)
(819,734,2)
(29,335,2)
(135,571,2)
(1053,335,2)
(876,601,2)
(350,654,2)
(98,1137,2)
(801,335,2)
(52,876,2)
(1107,654,2)
(203,358,2)
(521,482,2)
(764,34,2)
(11,560,2)
(520,654,2)
(635,654,2)
(501,800,2)
(856,571,2)
(314,25,2)
(1166,214,2)
(310,235,2)
(794,508,2)
(34,552,2)
(743,328,2)
(69,661,2)
(576,786,2)
(109,736,2)
(962,508,2)
(956,632,2)
(902,324,2)
(948,6,2)
(768,1129,2)
(422,340,2)
(1056,145,2)
(614,876,2)
(1060,271,2)
(727,560,2)
(553,473,2)
(1021,1022,2)
(830,358,2)
(407,1040,2)
(858,1129,2)
(525,121,2)
(81,335,2)
(288,1026,2)
(501,809,2)
(292,508,2)
(156,328,2)
(9,328,2)
(837,560,2)
(170,354,2)
(213,358,2)
(21,1010,2)
(335,513,2)
(114,609,2)
(520,235,2)
(298,654,2)
(873,140,2)
(993,697,2)
(916,259,2)
(821,340,2)
(1139,259,2)
(710,145,2)
(875,434,2)
(470,335,2)
(139,335,2)
(1147,911,2)
(469,508,2)
(147,560,2)
(511,510,2)
(736,358,2)
(18,170,2)
(874,632,2)
(532,129,2)
(23,687,2)
(7,335,2)
(946,694,2)
(1060,518,2)
(2,252,2)
(33,115,2)
(211,335,2)
(501,709,2)
(28,1163,2)
(1143,1129,2)
(613,654,2)
(304,1012,2)
(521,1073,2)
(1004,663,2)
(684,335,2)
(325,508,2)
(885,358,2)
(297,508,2)
(388,121,2)
(618,1129,2)
(433,335,2)
(796,1154,2)
(1095,542,2)
(971,615,2)
(997,6,2)
(918,789,2)
(1095,1045,2)
(623,654,2)
(571,209,2)
(302,74,2)
(55,358,2)
(377,704,2)
(1081,623,2)
(764,229,2)
(544,358,2)
(1051,145,2)
(1094,515,2)
(638,145,2)
(62,923,2)
(732,581,2)
(250,1129,2)
(746,252,2)
(64,145,2)
(196,335,2)
(958,140,2)
(920,560,2)
(833,1104,2)
(272,340,2)
(173,235,2)
(145,833,2)
(182,328,2)
(268,1154,2)
(675,1154,2)
(1006,628,2)
(75,728,2)
(325,823,2)
(335,508,2)
(745,508,2)
(183,718,2)
(1000,1110,2)
(988,1026,2)
(542,784,2)
(1007,990,2)
(489,571,2)
(409,1154,2)
(1,335,2)
(565,515,2)
(731,1137,2)
(445,335,2)
(271,216,2)
(113,573,2)
(26,24,2)
(887,779,2)
(311,259,2)
(258,6,2)
(779,1104,2)
(316,252,2)
(891,6,2)
(940,508,2)
(369,654,2)
(1169,121,2)
(269,508,2)
(157,833,2)
(302,1081,2)
(947,335,2)
(908,145,2)
(363,335,2)
(986,614,2)
(907,335,2)
(1120,15,2)
(1160,764,2)
(551,573,2)
(314,361,2)
(661,235,2)
(47,222,2)
(606,654,2)
(394,922,2)
(555,145,2)
(896,482,2)
(184,1166,2)
(919,482,2)
(606,358,2)
(37,331,2)
(954,524,2)
(598,358,2)
(615,335,2)
(384,785,2)
(457,654,2)
(1118,1016,2)
(581,868,2)
(518,545,2)
(410,358,2)
(514,335,2)
(838,259,2)
(843,508,2)
(238,328,2)
(775,406,2)
(586,235,2)
(909,335,2)
(829,1129,2)
(32,6,2)
(102,461,2)
(144,3,2)
(656,425,2)
(1034,783,2)
(24,216,2)
(1095,870,2)
(331,335,2)
(970,654,2)
(905,891,2)
(463,235,2)
(256,222,2)
(884,358,2)
(1048,617,2)
(906,259,2)
(766,6,2)
(609,654,2)
(607,358,2)
(441,335,2)
(959,139,2)
(166,335,2)
(786,654,2)
(278,335,2)
(752,235,2)
(1052,768,2)
(1045,237,2)
(370,335,2)
(667,1129,2)
(1031,638,2)
(1151,335,2)
(501,1142,2)
(966,508,2)
(955,663,2)
(895,340,2)
(1134,293,2)
(866,687,2)
(779,229,2)
(501,740,2)
(415,482,2)
(527,335,2)
(846,876,2)
(335,943,2)
(545,271,2)
(596,508,2)
(639,718,2)
(1108,335,2)
(863,126,2)
(573,235,2)
(960,33,2)
(1033,328,2)
(458,184,2)
(994,335,2)
(616,670,2)
(118,251,2)
(968,845,2)
(581,734,2)
(831,6,2)
(95,964,2)
(748,252,2)
(406,216,2)
(929,6,2)
(963,894,2)
(355,145,2)
(42,718,2)
(184,1064,2)
(832,6,2)
(599,508,2)
(339,515,2)
(266,1137,2)
(961,508,2)
(782,340,2)
(62,150,2)
(828,145,2)
(291,1087,2)
(218,406,2)
(108,335,2)
(68,358,2)
(473,235,2)
(490,1022,2)
(1081,923,2)
(779,513,2)
(552,508,2)
(1039,515,2)
(95,1137,2)
(675,984,2)
(400,340,2)
(517,508,2)
(732,715,2)
(640,358,2)
(687,1089,2)
(863,654,2)
(97,335,2)
(718,1095,2)
(109,203,2)
(501,561,2)
(308,410,2)
(226,6,2)
(1121,293,2)
(1102,222,2)
(335,184,2)
(1052,744,2)
(788,508,2)
(1010,335,2)
(697,335,2)
(404,1026,2)
(265,791,2)
(340,75,2)
(979,694,2)
(419,891,2)
(841,358,2)
(937,311,2)
(1129,178,2)
(980,508,2)
(637,1026,2)
(42,1119,2)
(767,1026,2)
(970,235,2)
(1122,360,2)
(564,831,2)
(255,654,2)
(222,235,2)
(17,271,2)
(972,1010,2)
(206,617,2)
(962,548,2)
(542,161,2)
(704,121,2)
(1113,1137,2)
(295,335,2)
(747,145,2)
(186,1040,2)
(875,319,2)
(410,593,2)
(431,335,2)
(335,216,2)
(177,145,2)
(271,1104,2)
(565,759,2)
(706,1063,2)
(505,145,2)
(555,184,2)
(840,252,2)
(37,335,2)
(501,855,2)
(239,335,2)
(427,335,2)
(1061,784,2)
(121,321,2)
(1138,328,2)
(938,654,2)
(225,508,2)
(623,421,2)
(902,734,2)
(852,319,2)
(817,25,2)
(555,1029,2)
(1054,555,2)
(943,694,2)
(1006,718,2)
(448,715,2)
(556,235,2)
(271,932,2)
(182,656,2)
(576,1081,2)
(321,337,2)
(317,121,2)
(372,328,2)
(1004,654,2)
(180,192,2)
(1076,1010,2)
(60,308,2)
(1079,484,2)
(1022,358,2)
(335,1060,2)
(814,336,2)
(872,1137,2)
(351,335,2)
(209,1137,2)
(118,697,2)
(1027,876,2)
(831,654,2)
(1012,484,2)
(127,222,2)
(375,391,2)
(536,235,2)
(369,420,2)
(857,654,2)
(1070,515,2)
(1149,718,2)
(918,13,2)
(529,145,2)
(844,86,2)
(382,235,2)
(24,184,2)
(773,6,2)
(550,663,2)
(25,632,2)
(1022,60,2)
(384,274,2)
(364,335,2)
(61,335,2)
(406,1029,2)
(993,591,2)
(581,70,2)
(1156,235,2)
(683,336,2)
(564,6,2)
(655,654,2)
(1089,791,2)
(1056,355,2)
(535,571,2)
(126,24,2)
(169,222,2)
(732,833,2)
(439,998,2)
(478,335,2)
(6,924,2)
(593,654,2)
(510,259,2)
(473,219,2)
(555,229,2)
(783,663,2)
(192,145,2)
(621,784,2)
(129,186,2)
(24,1060,2)
(1024,1137,2)
(110,718,2)
(249,335,2)
(1124,779,2)
(501,131,2)
(1133,1016,2)
(781,1137,2)
(969,328,2)
(467,508,2)
(508,235,2)
(1157,473,2)
(208,6,2)
(925,227,2)
(34,508,2)
(534,240,2)
(711,508,2)
(699,235,2)
(479,335,2)
(119,482,2)
(277,619,2)
(343,508,2)
(373,358,2)
(53,482,2)
(169,102,2)
(827,718,2)
(1131,1026,2)
(1172,129,2)
(497,6,2)
(48,145,2)
(820,1036,2)
(863,24,2)
(219,356,2)
(934,654,2)
(207,654,2)
(86,335,2)
(779,335,2)
(33,1129,2)
(1120,954,2)
(259,542,2)
(954,15,2)
(995,222,2)
(531,335,2)
(136,340,2)
(899,931,2)
(16,328,2)
(509,335,2)
(825,560,2)
(313,508,2)
(222,435,2)
(780,335,2)
(548,508,2)
(1081,608,2)
(389,145,2)
(902,70,2)
(506,335,2)
(634,1063,2)
(781,662,2)
(1052,1129,2)
(251,335,2)
(665,335,2)
(562,358,2)
(76,1081,2)
(716,718,2)
(1014,876,2)
(336,393,2)
(810,227,2)
(1064,654,2)
(426,663,2)
(380,6,2)
(145,235,2)
(666,617,2)
(240,674,2)
(335,1104,2)
(359,515,2)
(461,654,2)
(83,319,2)
(8,235,2)
(964,1137,2)
(180,145,2)
(785,335,2)
(1036,6,2)
(5,235,2)
(115,235,2)
(365,508,2)
(533,718,2)
(983,335,2)
(531,1107,2)
(62,608,2)
(203,606,2)
(62,648,2)
(876,335,2)
(392,867,2)
(4,635,2)
(740,358,2)
(862,335,2)
(146,586,2)
(80,235,2)
(1073,319,2)
(49,121,2)
(83,145,2)
(10,327,2)
(348,335,2)
(1028,222,2)
(414,6,2)
(546,335,2)
(836,335,2)
(354,335,2)
(513,24,2)
(613,335,2)
(779,12,2)
(762,854,2)
(264,1155,2)
(1043,356,2)
(985,515,2)
(430,508,2)
(1042,891,2)
(1020,235,2)
(789,728,2)
(185,336,2)
(1005,764,2)
(357,704,2)
(1097,335,2)
(356,235,2)
(223,335,2)
(25,878,2)
(417,328,2)
(777,324,2)
(423,654,2)
(622,1137,2)
(790,615,2)
(291,1162,2)
(644,998,2)
(991,508,2)
(649,385,2)
(807,358,2)
(1049,1137,2)
(1136,718,2)
(664,145,2)
(1111,458,2)
(1093,121,2)
(423,335,2)
(703,25,2)
(182,1156,2)
(240,571,2)
(99,6,2)
(772,356,2)
(456,482,2)
(293,227,2)
(300,1129,2)
(1052,115,2)
(631,1137,2)
(161,784,2)
(268,675,2)
(229,53,2)
(453,6,2)
(219,0,2)
(476,560,2)
(115,970,2)
(835,121,2)
(687,145,2)
(150,654,2)
(802,145,2)
(799,1010,2)
(93,235,2)
(524,15,2)
(693,1137,2)
(878,729,2)
(474,687,2)
(1076,1146,2)
(82,235,2)
(194,718,2)
(915,335,2)
(798,121,2)
(1129,235,2)
(1019,482,2)
(543,1166,2)
(945,145,2)
(35,515,2)
(789,687,2)
(957,6,2)
(764,1029,2)
(328,235,2)
(219,902,2)
(296,252,2)
(221,121,2)
(996,784,2)
(1106,335,2)
(993,848,2)
(385,1022,2)
(179,235,2)
(302,576,2)
(294,508,2)
(898,992,2)
(809,1026,2)
(902,0,2)
(264,508,2)
(860,764,2)
(861,358,2)
(936,340,2)
(1016,335,2)
(488,974,2)
(384,335,2)
(84,1063,2)
(183,1149,2)
(1170,1016,2)
(1065,335,2)
(1162,453,2)
(1044,508,2)
(601,1063,2)
(304,484,2)
(963,654,2)
(943,946,2)
(102,222,2)
(764,1104,2)
(674,571,2)
(1063,335,2)
(356,184,2)
(507,560,2)
(586,999,2)
(459,1137,2)
(500,764,2)
(774,145,2)
(778,335,2)
(617,311,2)
(534,636,2)
(531,845,2)
(493,1081,2)
(126,654,2)
(259,1137,2)
(22,508,2)
(733,482,2)
(578,335,2)
(1105,876,2)
(131,335,2)
(188,328,2)
(376,235,2)
(511,259,2)
(24,1104,2)
(616,780,2)
(244,324,2)
(128,663,2)
(75,555,2)
(356,216,2)
(585,654,2)
(959,335,2)
(412,335,2)
(107,335,2)
(853,654,2)
(461,222,2)
(261,617,2)
(1144,358,2)
(871,784,2)
(800,508,2)
(114,663,2)
(182,156,2)
(600,335,2)
(777,1078,2)
(597,663,2)
(121,1110,2)
(501,514,2)
(632,229,2)
(289,1110,2)
(457,335,2)
(685,876,2)
(271,184,2)
(226,1042,2)
(293,540,2)
(313,845,2)
(425,417,2)
(888,784,2)
(362,617,2)
(990,335,2)
(750,121,2)
(381,335,2)
(30,145,2)
(291,6,2)
(1110,1137,2)
(12,718,2)
(823,508,2)
(875,482,2)
(235,407,2)
(424,488,2)
(255,222,2)
(632,508,2)
(625,235,2)
(71,259,2)
(1031,319,2)
(1069,508,2)
(823,141,2)
(299,340,2)
(453,654,2)
(327,508,2)
(443,235,2)
(501,253,2)
(1045,288,2)
(999,235,2)
(311,1048,2)
(690,235,2)
-----------------------------------
(0,max_login_tries==0)
(1,NULL)
(2,3)
(3,pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF")
(4,ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR")
(5,chan)
(6,!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME")
(7,NULL)
(8,lastdisc)
(9,tmpoptions)
(10,AST_LIST_UNLOCK(&agents)
(11,atoi(pbx_builtin_getvar_helper(chan, "AGENTMAXLOGINTRIES")
(12,res = 0)
(13,p->password)
(14,p)
(15,res)
(16,"Saw variable AGENTACCEPTDTMF=%s, setting acceptdtmf to: %c for Agent \'%s\'.\\n")
(17,res)
(18,ast_indicate_data(chan, AST_CONTROL_HOLD,\n\\n\\t\\t\\t\\t\\t\\t\\tS_OR(p->moh, NULL)
(19,if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR")
(20,if (res)
(21,!ast_strlen_zero(p->moh)
(22,errmsg)
(23,p)
(24,!res)
(25,!res && play_announcement==1)
(26,chan)
(27,channel)
(28,ast_strlen_zero(args.agent_id)
(29,ast_mutex_lock(&p->lock)
(30,pass)
(31,p->lastdisc)
(32,3)
(33,*tmpoptions)
(34,res = -1)
(35,lock)
(36,tmpoptions)
(37,ast_mutex_unlock(&p->lock)
(38,lock)
(39,res)
(40,if (!res)
(41,if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF")
(42,AST_LIST_UNLOCK(&agents)
(43,if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTACKCALL")
(44,)
(45,0)
(46,ast_channel_unlock(chan)
(47,p)
(48,p)
(49,agent)
(50,0)
(51,"")
(52,ast_cond_destroy(&p->app_complete_cond)
(53,ast_app_getdata(chan, "agent-user", user, sizeof(user)
(54,p->owner)
(55,p)
(56,p->password)
(57,p->autologoff)
(58,p)
(59,)
(60,p->autologoff)
(61,logintime)
(62,ast_verb(3, "Saw variable AGENTUPDATECDR=%s, setting update_cdr to: %d on Channel \'%s\'.\\n",tmpoptions,update_cdr,ast_channel_name(chan)
(63,sizeof(agent_goodbye)
(64,p->agent)
(65,if (!ast_strlen_zero(args.agent_id)
(66,chan)
(67,chan)
(68,"AGENTAUTOLOGOFF")
(69,&p->lock)
(70,max_login_tries = maxlogintries)
(71,p)
(72,chan)
(73,res)
(74,p->agent)
(75,ast_strlen_zero(xpass)
(76,chan)
(77,if (!ast_strlen_zero(tmpoptions)
(78,user)
(79,if (max_login_tries < 0)
(80,ast_mutex_unlock(&p->lock)
(81,EVENT_FLAG_AGENT)
(82,"AGENTACCEPTDTMF")
(83,ast_log(LOG_NOTICE, "user: %s, pass: %s\\n", user, pass)
(84,p)
(85,chan)
(86,p->lock)
(87,AST_DEVSTATE_CACHABLE)
(88,p->login_wait_cond)
(89,p)
(90,)
(91,3)
(92,maxlogintries)
(93,p)
(94,1)
(95,&p->lock)
(96,0)
(97,chan)
(98,ackcall)
(99,chan)
(100,0)
(101,user)
(102,tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTACKCALL")
(103,AST_DEVICE_UNAVAILABLE)
(104,0)
(105,)
(106,if (ast_true(pbx_builtin_getvar_helper(chan, "AGENTACKCALL")
(107,loginstart)
(108,NULL)
(109,ast_verb(3, "Saw variable AGENTAUTOLOGOFF=%s, setting autologff to: %d for Agent \'%s\'.\\n", tmpoptions, p->autologoff, p->agent)
(110,0)
(111,agent)
(112,u = ast_module_user_add(chan)
(113,AST_LIST_UNLOCK(&agents)
(114,tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTGOODBYE")
(115,tmpoptions = pbx_builtin_getvar_helper(chan, "AGENTENDDTMF")
(116,if (!res)
(117,user)
(118,manager_event(EVENT_FLAG_AGENT, "Agentlogoff",\n\\n\\t\\t\\t\\t\\t\\t\\t      "Agent: %s\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t      "Logintime: %ld\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t      "Uniqueid: %s\\r\\n",\n\\n\\t\\t\\t\\t\\t\\t\\t      p->agent, logintime, ast_channel_uniqueid(chan)
(119,res)
(120,pass)
(121,ast_tvdiff_ms(ast_tvnow()
(122,chan)
(123,p->wrapuptime = wrapuptime)
(124,ast_mutex_unlock(&p->lock)
(125,)
(126,ast_channel_nativeformats(chan)
(127,"AGENTACKCALL")
(128,"AGENTGOODBYE")
(129,!strcmp(p->password, pass)
(130,user)
(131,p->acknowledged)
(132,ast_cond_wait(&p->app_complete_cond, &p->lock)
(133,agent)
(134,)
(135,&p->login_wait_cond)
(136,pass[0] = \'\\0\')
(137,break;)
(138,p->lock)
(139,p->loginstart)
(140,p->chan != chan)
(141,p->lock)
(142,chan)
(143,u)
(144,ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF")
(145,!res && (max_login_tries==0 || tries < max_login_tries)
(146,p->lastdisc.tv_sec++)
(147,"AGENTMAXLOGINTRIES")
(148,0)
(149,chan)
(150,ast_channel_name(chan)
(151,filename)
(152,if (p->ackcall && (res == 1)
(153,if (!res)
(154,)
(155,acceptdtmf)
(156,p->agent)
(157,0)
(158,login_wait_cond)
(159,p->agent)
(160,p)
(161,ast_safe_sleep_conditional( chan, 1000, agent_cont_sleep, p )
(162,3)
(163,agent)
(164,agent)
(165,3)
(166,time(NULL)
(167,"AGENTLOGOFF")
(168,args)
(169,ast_verb(3, "Saw variable AGENTACKCALL=%s, setting ackcall to: %d for Agent \'%s\'.\\n", tmpoptions, p->ackcall, p->agent)
(170,S_OR(p->moh, NULL)
(171,"Agent/%s")
(172,xpass)
(173,pbx_builtin_getvar_helper(chan, "AGENTACCEPTDTMF")
(174,tmpoptions)
(175,p->autologoff = autologoff)
(176,0)
(177,res)
(178,ast_strlen_zero(tmpoptions)
(179,ast_channel_unlock(chan)
(180,AST_LIST_UNLOCK(&agents)
(181,tmpoptions)
(182,ast_verb(3, "Saw variable AGENTACCEPTDTMF=%s, setting acceptdtmf to: %c for Agent \'%s\'.\\n", tmpoptions, p->acceptdtmf, p->agent)
(183,&p->lock)
(184,res = ast_answer(chan)
(185,p)
(186,strcmp(p->password, pass)
(187,1)
(188,p)
(189,if (!res)
(190,if (update_cdr && ast_channel_cdr(chan)
(191,logintime)
(192,&agents)
(193,p)
(194,p)
(195,"AGENTGOODBYE")
(196,chan)
(197,)
(198,p)
(199,chan)
(200,1)
(201,p->lastdisc = ast_tv(0, 0)
(202,)
(203,tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF")
(204,p)
(205,lock)
(206,chan)
(207,pbx_builtin_getvar_helper(chan, "AGENTLMAXLOGINTRIES")
(208,tmpoptions)
(209,p->app_lock_flag)
(210,chan)
(211,p)
(212,p)
(213,agent)
(214,ast_channel_state(chan)
(215,ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent)
(216,res = ast_app_getdata(chan, "agent-pass", pass, sizeof(pass)
(217,)
(218,"")
(219,max_login_tries==0 || tries < max_login_tries)
(220,chan)
(221,p)
(222,!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTACKCALL")
(223,ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent)
(224,p)
(225,0)
(226,p->wrapuptime)
(227,!ast_strlen_zero(args.options)
(228,unlock_channel)
(229,res = ast_app_getdata(chan, "agent-user", user, sizeof(user)
(230,0)
(231,ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT)
(232,while (res >= 0)
(233,AST_APP_ARG(extension)
(234,)
(235,!strcmp(p->agent, user)
(236,p)
(237,p->ackcall = ackcall)
(238,p)
(239,AST_CONTROL_HOLD)
(240,&p->lock)
(241,if (p->autologoff < 0)
(242,pass)
(243,max_login_tries)
(244,max_login_tries < 0)
(245,NULL)
(246,if (p->chan)
(247,ast_set_flag(p, AGENT_FLAG_ACKCALL)
(248,p)
(249,p)
(250,enddtmf)
(251,p->agent)
(252,!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR")
(253,p->chan)
(254,agent)
(255,pbx_builtin_getvar_helper(chan, "AGENTACKCALL")
(256,ackcall)
(257,p)
(258,tmpoptions)
(259,res >= 0)
(260,p->lock)
(261,p->deferlogoff)
(262,errmsg = "agent-alreadyon")
(263,)
(264,ast_mutex_lock(&p->lock)
(265,pending)
(266,0)
(267,p)
(268,time(&p->loginstart)
(269,"agent-alreadyon")
(270,res)
(271,!res)
(272,pass)
(273,chan)
(274,ast_getformatname(ast_channel_readformat(chan)
(275,"Agent/%s")
(276,p)
(277,ast_channel_unlock(chan)
(278,lock)
(279,ast_strdupa(data)
(280,res)
(281,)
(282,"AGENTLMAXLOGINTRIES")
(283,filename)
(284,tmpfmt)
(285,p)
(286,1)
(287,ast_module_user_remove(u)
(288,p->ackcall = 1)
(289,p)
(290,parse)
(291,ast_verb(3, "Saw variable AGENTWRAPUPTIME=%s, setting wrapuptime to: %d for Agent \'%s\'.\\n", tmpoptions, p->wrapuptime, p->agent)
(292,p->lock)
(293,strchr(args.options, \'s\')
(294,ast_mutex_unlock(&p->lock)
(295,"%s|%ld")
(296,update_cdr)
(297,lock)
(298,pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR")
(299,res)
(300,p->enddtmf)
(301,)
(302,snprintf(ast_channel_cdr(chan)
(303,chan)
(304,ast_getformatname(&tmpfmt)
(305,0)
(306,if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTLMAXLOGINTRIES")
(307,chan)
(308,p->autologoff = atoi(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF")
(309,if (!ast_strlen_zero(args.options)
(310,p)
(311,p->deferlogoff)
(312,if (unlock_channel)
(313,snprintf(agent, sizeof(agent)
(314,ast_streamfile(chan, filename, ast_channel_language(chan)
(315,max_login_tries)
(316,"AGENTUPDATECDR")
(317,p->agent)
(318,chan)
(319,user[AST_MAX_AGENT] = "")
(320,"Saw variable AGENTAUTOLOGOFF=%s, setting autologff to: %d for Agent \'%s\'.\\n")
(321,ast_tvdiff_ms(ast_tvnow()
(322,autologoff)
(323,AGENT_FLAG_ACCEPTDTMF)
(324,max_login_tries = atoi(pbx_builtin_getvar_helper(chan, "AGENTMAXLOGINTRIES")
(325,ast_mutex_unlock(&p->lock)
(326,updatecdr)
(327,&agents)
(328,!ast_strlen_zero(tmpoptions)
(329,)
(330,0)
(331,&p->lock)
(332,ast_mutex_destroy(&p->lock)
(333,if (p->ackcall)
(334,ast_debug(1, "Wrapup time for %s expired!\\n", p->agent)
(335,!res)
(336,p->chan == chan)
(337,ast_tvnow()
(338,p)
(339,login_wait_cond)
(340,!ast_strlen_zero(xpass)
(341,chan)
(342,deferlogoff)
(343,p->logincallerid)
(344,chan)
(345,chan)
(346,lock)
(347,unlock_channel)
(348,p)
(349,ast_set_flag(p, AGENT_FLAG_WRAPUPTIME)
(350,ast_waitstream(chan, "")
(351,agents)
(352,)
(353,ast_free(p)
(354,p->moh)
(355,&agents)
(356,!res)
(357,check_beep(p, 0)
(358,!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF")
(359,p)
(360,parse = ast_strdupa(data)
(361,*filename = "agent-loginok")
(362,p)
(363,p)
(364,"NONE")
(365,p->acknowledged = 0)
(366,AGENT_FLAG_ACKCALL)
(367,if (p->app_lock_flag == 1)
(368,)
(369,ast_app_getdata(chan, "agent-pass", pass, sizeof(pass)
(370,p)
(371,ast_cond_signal(&p->login_wait_cond)
(372,tmpoptions)
(373,AGENT_FLAG_AUTOLOGOFF)
(374,xpass)
(375,&p->lock)
(376,res)
(377,check_availability(p, 0)
(378,lock)
(379,p)
(380,p)
(381,2)
(382,p->lastdisc)
(383,p)
(384,ast_verb(2, "Agent \'%s\' logged in (format %s/%s)
(385,p->autologoff = 0)
(386,tmpfmt)
(387,p)
(388,p->agent)
(389,ast_channel_lock(chan)
(390,"AGENTWRAPUPTIME")
(391,p->lock)
(392,AST_LIST_LOCK(&agents)
(393,p->chan)
(394,&p->lock)
(395,wrapuptime)
(396,if (!res)
(397,const char *data)
(398,play_announcement)
(399,p)
(400,0)
(401,agent)
(402,if (!strcmp(p->agent, user)
(403,chan)
(404,p->ackcall = 0)
(405,\'\\0\')
(406,!res)
(407,!strcmp(p->password, pass)
(408,wrapuptime)
(409,loginstart)
(410,atoi(pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF")
(411,lock)
(412,p->agent)
(413,if (p->ackcall)
(414,chan)
(415,agent_id)
(416,AST_STATE_UP)
(417,*tmpoptions)
(418,res)
(419,wrapuptime)
(420,sizeof(pass)
(421,update_cdr)
(422,\'\\0\')
(423,ast_channel_writeformat(chan)
(424,update_cdr)
(425,p->acceptdtmf = *tmpoptions)
(426,tmpoptions)
(427,lock)
(428,chan)
(429,p)
(430,logincallerid)
(431,agent)
(432,data)
(433,p)
(434,args.agent_id)
(435,ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTACKCALL")
(436,user)
(437,"Agent \'%s\' logged in (format %s/%s)
(438,-1)
(439,owner)
(440,errmsg)
(441,ackcall)
(442,ast_channel_uniqueid(chan)
(443,chan)
(444,ast_mutex_lock(&p->lock)
(445,0)
(446,)
(447,"Agent/%s")
(448,tries)
(449,"Huh?  We broke out when there was still an owner?\\n")
(450,tmpoptions)
(451,p->loginstart = 0)
(452,chan)
(453,pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME")
(454,0)
(455,)
(456,args)
(457,ast_channel_readformat(chan)
(458,!res)
(459,app_lock_flag)
(460,ast_tv(0, 0)
(461,pbx_builtin_getvar_helper(chan, "AGENTACKCALL")
(462,chan)
(463,p)
(464,)
(465,agent_goodbye)
(466,RET)
(467,p->acknowledged)
(468,)
(469,res)
(470,AST_DEVSTATE_CACHABLE)
(471,"")
(472,AST_DEVICE_NOT_INUSE)
(473,!res && (max_login_tries==0 || tries < max_login_tries)
(474,password)
(475,chan)
(476,max_login_tries)
(477,if (!ast_strlen_zero(xpass)
(478,0)
(479,p)
(480,agent_goodbye)
(481,"Saw variable AGENTGOODBYE=%s, setting agent_goodbye to: %s on Channel \'%s\'.\\n")
(482,!ast_strlen_zero(args.agent_id)
(483,1)
(484,res)
(485,"Saw variable AGENTACKCALL=%s, setting ackcall to: %d for Agent \'%s\'.\\n")
(486,p)
(487,&p->login_wait_cond)
(488,ast_true(pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR")
(489,p)
(490,0)
(491,chan)
(492,chan)
(493,sizeof(ast_channel_cdr(chan)
(494,if (p->deferlogoff && p->chan)
(495,wrapuptime)
(496,res)
(497,wrapuptime)
(498,p->lock)
(499,chan)
(500,chan)
(501,return -1;)
(502,strlen(p->moh)
(503,tmpoptions)
(504,p)
(505,user)
(506,loginstart)
(507,chan)
(508,!p->chan)
(509,"AGENTLOGIN")
(510,&p->lock)
(511,ast_mutex_unlock(&p->lock)
(512,"AGENTACKCALL")
(513,res = ast_set_write_format_from_cap(chan, ast_channel_nativeformats(chan)
(514,p->chan)
(515,p->app_lock_flag == 1)
(516,p->ackcall)
(517,lock)
(518,ast_set_read_format_from_cap(chan, ast_channel_nativeformats(chan)
(519,ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTLMAXLOGINTRIES")
(520,pbx_builtin_getvar_helper(chan, "AGENTACKCALL")
(521,sizeof(user)
(522,)
(523,chan)
(524,&tmpfmt)
(525,1)
(526,)
(527,p)
(528,sizeof(user)
(529,"user: %s, pass: %s\\n")
(530,ast_mutex_unlock(&p->lock)
(531,ast_queue_log("NONE", ast_channel_uniqueid(chan)
(532,p->pending)
(533,lock)
(534,ast_cond_wait(&p->app_complete_cond, &p->lock)
(535,lock)
(536,tv_sec)
(537,1)
(538,chan)
(539,"Unable to set write format to %s\\n")
(540,args.options)
(541,)
(542,res = ast_safe_sleep_conditional( chan, 1000, agent_cont_sleep, p )
(543,res)
(544,0)
(545,ast_channel_nativeformats(chan)
(546,p)
(547,p)
(548,p->lock)
(549,chan)
(550,strcpy(agent_goodbye, pbx_builtin_getvar_helper(chan, "AGENTGOODBYE")
(551,&agents)
(552,-1)
(553,user)
(554,p)
(555,!res)
(556,lastdisc)
(557,sched_yield()
(558,parse)
(559,if( !res && play_announcement==1 )
(560,!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTLMAXLOGINTRIES")
(561,p->ackcall)
(562,autologoff)
(563,unlock_channel = 0)
(564,atoi(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME")
(565,&p->login_wait_cond)
(566,)
(567,agents)
(568,AGENT_FLAG_ENDDTMF)
(569,)
(570,logintime)
(571,p->app_lock_flag == 1)
(572,options)
(573,!p)
(574,)
(575,tmpoptions)
(576,ast_channel_cdr(chan)
(577,sched_yield()
(578,chan)
(579,ast_strlen_zero(tmpoptions)
(580,agent_goodbye)
(581,tries < max_login_tries)
(582,max_login_tries)
(583,)
(584,p->acknowledged = 0)
(585,pbx_builtin_getvar_helper(chan, "AGENTMAXLOGINTRIES")
(586,p->lastdisc.tv_sec)
(587,)
(588,p)
(589,agent)
(590,)
(591,ast_channel_uniqueid(chan)
(592,if (res && p->owner)
(593,pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF")
(594,p->pending)
(595,0)
(596,1)
(597,agent_goodbye)
(598,chan)
(599,acknowledged)
(600,p->app_lock_flag)
(601,!p->owner)
(602,)
(603,update_cdr = updatecdr)
(604,LOG_WARNING)
(605,agents)
(606,pbx_builtin_getvar_helper(chan, "AGENTAUTOLOGOFF")
(607,p)
(608,update_cdr = 1)
(609,pbx_builtin_getvar_helper(chan, "AGENTGOODBYE")
(610,p->login_wait_cond)
(611,p)
(612,extension)
(613,ast_channel_uniqueid(chan)
(614,p->lock)
(615,p->chan = chan)
(616,manager_event(EVENT_FLAG_AGENT, "Agentlogin",\n\\n\\t\\t\\t\\t\\t\\t\\t      "Agent: %s\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t      "Channel: %s\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t      "Uniqueid: %s\\r\\n",\n\\n\\t\\t\\t\\t\\t\\t\\t      p->agent, ast_channel_name(chan)
(617,p->deferlogoff && p->chan)
(618,"Saw variable AGENTENDDTMF=%s, setting enddtmf to: %c for Agent \'%s\'.\\n")
(619,unlock_channel)
(620,"Agent: %s\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t      "Channel: %s\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t      "Uniqueid: %s\\r\\n")
(621,p)
(622,agents)
(623,ast_channel_cdr(chan)
(624,ackcall)
(625,"AGENTENDDTMF")
(626,"%s")
(627,p)
(628,&agents)
(629,tries)
(630,p->lock)
(631,AST_LIST_UNLOCK(&agents)
(632,!res)
(633,acknowledged)
(634,p->owner)
(635,pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR")
(636,&p->app_complete_cond)
(637,p->ackcall)
(638,p->agent)
(639,res)
(640,tmpoptions)
(641,if (ast_true(pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR")
(642,agent)
(643,tries)
(644,p)
(645,u)
(646,)
(647,0)
(648,tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR")
(649,p->autologoff)
(650,res)
(651,0)
(652,"AGENTWRAPUPTIME")
(653,p)
(654,struct ast_channel *chan)
(655,ast_module_user_add(chan)
(656,p->acceptdtmf)
(657,ast_strlen_zero(args.options)
(658,p->logincallerid[0] = \'\\0\')
(659,if (p->chan != chan)
(660,pass)
(661,p->lock)
(662,p->lock)
(663,!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTGOODBYE")
(664,agents)
(665,"NONE")
(666,deferlogoff)
(667,ast_set_flag(p, AGENT_FLAG_ENDDTMF)
(668,chan)
(669,chan)
(670,ast_channel_name(chan)
(671,NULL)
(672,if (p->wrapuptime < 0)
(673,p)
(674,p->lock)
(675,&p->loginstart)
(676,acceptdtmf)
(677,res = -1)
(678,agent_id)
(679,if (!res && (max_login_tries==0 || tries < max_login_tries)
(680,"Unable to set read format to %s\\n")
(681,lastdisc)
(682,ast_channel_lock(chan)
(683,chan)
(684,p->agent)
(685,p->app_complete_cond)
(686,errmsg)
(687,!strcmp(p->agent, user)
(688,)
(689,p)
(690,p->chan)
(691,autologoff)
(692,AST_DEVICE_NOT_INUSE)
(693,p)
(694,p->chan)
(695,agent)
(696,p)
(697,logintime = time(NULL)
(698,moh)
(699,tmpoptions)
(700,ast_log(LOG_WARNING, "Unable to set write format to %s\\n", ast_getformatname(&tmpfmt)
(701,tmpoptions)
(702,p->lock)
(703,res)
(704,p->ackcall)
(705,ast_mutex_unlock(&p->lock)
(706,owner)
(707,p)
(708,logintime)
(709,p->autologoff)
(710,LOG_NOTICE)
(711,p)
(712,ast_mutex_lock(&p->lock)
(713,chan)
(714,password)
(715,max_login_tries==0)
(716,agents)
(717,p)
(718,p->ackcall && (res == 1)
(719,AST_APP_ARG(agent_id)
(720,play_announcement)
(721,p)
(722,if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME")
(723,0)
(724,sizeof(pass)
(725,update_cdr)
(726,res)
(727,max_login_tries)
(728,xpass[AST_MAX_AGENT] = "")
(729,play_announcement = 1)
(730,p->lock)
(731,agents)
(732,max_login_tries==0 || tries < max_login_tries)
(733,AST_MAX_AGENT)
(734,tries = 0)
(735,tmpoptions)
(736,p->agent)
(737,if (!res)
(738,)
(739,"agent-loginok")
(740,p->autologoff)
(741,p)
(742,chan)
(743,p)
(744,p->enddtmf)
(745,agent)
(746,chan)
(747,unlock_channel = 1)
(748,chan)
(749,if (p->dead && !p->owner)
(750,ackcall)
(751,p)
(752,"AGENTAUTOLOGOFF")
(753,lastdisc)
(754,3)
(755,3)
(756,AST_APP_ARG(options)
(757,u)
(758,&p->lock)
(759,p->login_wait_cond)
(760,)
(761,ast_mutex_unlock(&p->lock)
(762,ast_verb(2, "Agent \'%s\' logged out\\n", p->agent)
(763,)
(764,!res)
(765,agent)
(766,p)
(767,ackcall)
(768,p->agent)
(769,p->moh)
(770,channel)
(771,tmpoptions)
(772,max_login_tries)
(773,0)
(774,p)
(775,chan)
(776,app_complete_cond)
(777,ast_verb(3, "Saw variable AGENTMAXLOGINTRIES=%s, setting max_login_tries to: %d on Channel \'%s\'.\\n",tmpoptions,max_login_tries,ast_channel_name(chan)
(778,agent)
(779,res && p->owner)
(780,p->agent)
(781,&p->lock)
(782,pass[0])
(783,ast_channel_name(chan)
(784,p->ackcall)
(785,ast_getformatname(ast_channel_writeformat(chan)
(786,ast_channel_cdr(chan)
(787,p->lock)
(788,"Agent/%s")
(789,sizeof(xpass)
(790,p->chan)
(791,!strcmp(p->agent, user)
(792,if (!res)
(793,p->wrapuptime)
(794,p)
(795,tmpfmt)
(796,p)
(797,chan)
(798,agent)
(799,moh)
(800,p->logincallerid[0])
(801,p)
(802,"agent-incorrect")
(803,tmpfmt)
(804,chan)
(805,p)
(806,check_availability(p, 0)
(807,p)
(808,chan)
(809,p->ackcall)
(810,options)
(811,p->lastdisc)
(812,p)
(813,if (!ast_strlen_zero(tmpoptions)
(814,p->chan = NULL)
(815,args)
(816,AST_SOFTHANGUP_EXPLICIT)
(817,ast_channel_language(chan)
(818,lock)
(819,tries++)
(820,p->wrapuptime)
(821,"agent-pass")
(822,0)
(823,&p->lock)
(824,AST_LIST_LOCK(&agents)
(825,"AGENTMAXLOGINTRIES")
(826,tmpoptions)
(827,p)
(828,tries)
(829,enddtmf)
(830,ast_set_flag(p, AGENT_FLAG_AUTOLOGOFF)
(831,pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME")
(832,p->wrapuptime)
(833,!res)
(834,options)
(835,p)
(836,app_lock_flag)
(837,"Saw variable AGENTMAXLOGINTRIES=%s, setting max_login_tries to: %d on Channel \'%s\'.\\n")
(838,lock)
(839,res)
(840,"AGENTUPDATECDR")
(841,p)
(842,wrapuptime)
(843,res)
(844,&p->lock)
(845,agent[AST_MAX_AGENT] = "")
(846,&p->app_complete_cond)
(847,ast_copy_string(agent_goodbye, agentgoodbye, sizeof(agent_goodbye)
(848,ast_channel_name(chan)
(849,&agents)
(850,)
(851,unlock_channel)
(852,strcmp(p->agent, user)
(853,pbx_builtin_getvar_helper(chan, "AGENTMAXLOGINTRIES")
(854,p->agent)
(855,p->loginstart)
(856,app_complete_cond)
(857,ast_channel_cdr(chan)
(858,p)
(859,while (!res && (max_login_tries==0 || tries < max_login_tries)
(860,ast_safe_sleep(chan, 500)
(861,chan)
(862,chan)
(863,ast_set_write_format_from_cap(chan, ast_channel_nativeformats(chan)
(864,chan)
(865,ast_channel_cdr(chan)
(866,xpass)
(867,&agents)
(868,max_login_tries = 0)
(869,0)
(870,res = agent_ack_sleep(p)
(871,p)
(872,ackcall)
(873,res)
(874,1)
(875,ast_copy_string(user, args.agent_id, AST_MAX_AGENT)
(876,p->dead && !p->owner)
(877,xpass)
(878,play_announcement==1)
(879,)
(880,p)
(881,res)
(882,res)
(883,if (p->app_lock_flag == 1)
(884,"AGENTAUTOLOGOFF")
(885,autologoff)
(886,login_wait_cond)
(887,LOG_WARNING)
(888,agent_ack_sleep(p)
(889,"Agent \'%s\' logged out\\n")
(890,agent_id)
(891,p->wrapuptime < 0)
(892,max_login_tries)
(893,update_cdr)
(894,sizeof(user)
(895,pass)
(896,"agent-user")
(897,if (res)
(898,ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTGOODBYE")
(899,ast_mutex_lock(&p->lock)
(900,1)
(901,*tmpoptions = NULL)
(902,tries < max_login_tries)
(903,NULL)
(904,)
(905,0)
(906,p)
(907,agent)
(908,AST_LIST_LOCK(&agents)
(909,p)
(910,p)
(911,ast_tvnow()
(912,tries)
(913,)
(914,)
(915,ast_devstate_changed(AST_DEVICE_UNAVAILABLE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent)
(916,p)
(917,agent)
(918,ast_copy_string(xpass, p->password, sizeof(xpass)
(919,user)
(920,tmpoptions)
(921,2)
(922,p->lock)
(923,update_cdr = 0)
(924,ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME")
(925,args)
(926,&p->lock)
(927,0)
(928,tmpoptions)
(929,"Saw variable AGENTWRAPUPTIME=%s, setting wrapuptime to: %d for Agent \'%s\'.\\n")
(930,ast_mutex_unlock(&p->lock)
(931,&p->lock)
(932,res = ast_streamfile(chan, filename, ast_channel_language(chan)
(933,chan)
(934,ast_channel_name(chan)
(935,p)
(936,1)
(937,p)
(938,ast_channel_uniqueid(chan)
(939,chan)
(940,p = NULL)
(941,parse)
(942,max_login_tries)
(943,res = -1)
(944,p)
(945,&agents)
(946,-1)
(947,&p->lock)
(948,p->wrapuptime)
(949,"AGENTUPDATECDR")
(950,"")
(951,agent)
(952,&p->lock)
(953,if (!strcmp(p->agent, user)
(954,ast_getformatname(&tmpfmt)
(955,agent_goodbye)
(956,play_announcement)
(957,"AGENTWRAPUPTIME")
(958,-1)
(959,time(NULL)
(960,p->enddtmf = *tmpoptions)
(961,res)
(962,&p->lock)
(963,ast_app_getdata(chan, errmsg, user, sizeof(user)
(964,p->lock)
(965,errmsg)
(966,&agents)
(967,app_complete_cond)
(968,sizeof(agent)
(969,ast_set_flag(p, AGENT_FLAG_ACCEPTDTMF)
(970,pbx_builtin_getvar_helper(chan, "AGENTENDDTMF")
(971,p->chan)
(972,1)
(973,ast_mutex_lock(&p->lock)
(974,pbx_builtin_getvar_helper(chan, "AGENTUPDATECDR")
(975,if (ast_tvdiff_ms(ast_tvnow()
(976,"Agent/%s")
(977,agent)
(978,p)
(979,1)
(980,agents)
(981,p)
(982,pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME")
(983,AST_DEVSTATE_CACHABLE)
(984,p->loginstart)
(985,p->app_complete_cond)
(986,&p->lock)
(987,if (strchr(args.options, \'s\')
(988,p)
(989,0)
(990,&agents)
(991,p)
(992,pbx_builtin_getvar_helper(chan, "AGENTGOODBYE")
(993,ast_queue_log("NONE", ast_channel_uniqueid(chan)
(994,p->loginstart)
(995,ackcall)
(996,res)
(997,AGENT_FLAG_WRAPUPTIME)
(998,res)
(999,p->lastdisc)
(1000,lastdisc)
(1001,agents)
(1002,&p->lock)
(1003,p->app_complete_cond)
(1004,pbx_builtin_getvar_helper(chan, "AGENTGOODBYE")
(1005,res = ast_safe_sleep(chan, 500)
(1006,AST_LIST_LOCK(&agents)
(1007,AST_LIST_UNLOCK(&agents)
(1008,agent_cont_sleep)
(1009,p)
(1010,!ast_strlen_zero(p->moh)
(1011,p)
(1012,&tmpfmt)
(1013,pending)
(1014,ast_cond_destroy(&p->login_wait_cond)
(1015,p->agent)
(1016,p->ackcall)
(1017,update_cdr)
(1018,res)
(1019,chan)
(1020,"AGENTACKCALL")
(1021,autologoff)
(1022,p->autologoff < 0)
(1023,p)
(1024,break;)
(1025,p)
(1026,ast_true(pbx_builtin_getvar_helper(chan, "AGENTACKCALL")
(1027,p)
(1028,chan)
(1029,res=0)
(1030,max_login_tries)
(1031,strcmp(p->agent, user)
(1032,)
(1033,agent)
(1034,ast_verb(3, "Saw variable AGENTGOODBYE=%s, setting agent_goodbye to: %s on Channel \'%s\'.\\n",tmpoptions,agent_goodbye,ast_channel_name(chan)
(1035,p)
(1036,p->wrapuptime = atoi(pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME")
(1037,"Agentlogoff")
(1038,agents)
(1039,&p->app_complete_cond)
(1040,!strcmp(p->agent, user)
(1041,p)
(1042,p->wrapuptime = 0)
(1043,0)
(1044,p)
(1045,p->ackcall)
(1046,p)
(1047,p)
(1048,p->deferlogoff = 0)
(1049,tv_sec)
(1050,if (p->chan == chan)
(1051,1)
(1052,ast_verb(3, "Saw variable AGENTENDDTMF=%s, setting enddtmf to: %c for Agent \'%s\'.\\n", tmpoptions, p->enddtmf, p->agent)
(1053,"Agentlogin")
(1054,xpass)
(1055,chan)
(1056,AST_LIST_LOCK(&agents)
(1057,p = NULL)
(1058,p)
(1059,)
(1060,res = ast_set_read_format_from_cap(chan, ast_channel_nativeformats(chan)
(1061,1000)
(1062,lock)
(1063,p->dead)
(1064,ast_answer(chan)
(1065,chan)
(1066,lock)
(1067,user)
(1068,user)
(1069,0)
(1070,ast_cond_signal(&p->login_wait_cond)
(1071,)
(1072,if (p->lastdisc.tv_sec)
(1073,sizeof(user)
(1074,res)
(1075,dead)
(1076,strlen(p->moh)
(1077,chan)
(1078,tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTMAXLOGINTRIES")
(1079,LOG_WARNING)
(1080,0)
(1081,update_cdr && ast_channel_cdr(chan)
(1082,agent)
(1083,agents)
(1084,agentgoodbye)
(1085,\'s\')
(1086,EVENT_FLAG_AGENT)
(1087,p->agent)
(1088,0)
(1089,!p->pending)
(1090,lock)
(1091,p)
(1092,args)
(1093,p->lastdisc)
(1094,p)
(1095,res == 1)
(1096,p->lock)
(1097,loginstart)
(1098,1)
(1099,"AGENTGOODBYE")
(1100,p)
(1101,1)
(1102,p->agent)
(1103,res)
(1104,res = ast_app_getdata(chan, errmsg, user, sizeof(user)
(1105,p)
(1106,"Agent: %s\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t      "Logintime: %ld\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t\\t      "Uniqueid: %s\\r\\n")
(1107,ast_channel_name(chan)
(1108,lock)
(1109,"Saw variable AGENTUPDATECDR=%s, setting update_cdr to: %d on Channel \'%s\'.\\n")
(1110,p->lastdisc.tv_sec)
(1111,args)
(1112,if (res)
(1113,lock)
(1114,chan)
(1115,if (p->ackcall)
(1116,)
(1117,ast_strlen_zero(p->moh)
(1118,check_availability(p, 0)
(1119,&agents)
(1120,ast_log(LOG_WARNING, "Unable to set read format to %s\\n", ast_getformatname(&tmpfmt)
(1121,play_announcement = 0)
(1122,AST_STANDARD_APP_ARGS(args, parse)
(1123,if (p->loginstart == 0)
(1124,ast_log(LOG_WARNING, "Huh?  We broke out when there was still an owner?\\n")
(1125,moh)
(1126,max_login_tries)
(1127,p)
(1128,chan)
(1129,!ast_strlen_zero(tmpoptions)
(1130,errmsg = "agent-incorrect")
(1131,ackcall)
(1132,if (!ast_strlen_zero(pbx_builtin_getvar_helper(chan, "AGENTGOODBYE")
(1133,check_beep(p, 0)
(1134,play_announcement)
(1135,tmpoptions)
(1136,ast_mutex_lock(&p->lock)
(1137,res)
(1138,p)
(1139,chan)
(1140,3)
(1141,chan)
(1142,p->acceptdtmf)
(1143,tmpoptions)
(1144,autologoff)
(1145,if (ast_channel_state(chan)
(1146,p->moh)
(1147,p->lastdisc = ast_tvnow()
(1148,tmpoptions)
(1149,p->lock)
(1150,p)
(1151,p)
(1152,if (!p)
(1153,chan)
(1154,p->loginstart == 0)
(1155,&p->lock)
(1156,tmpoptions = pbx_builtin_getvar_helper(chan, "AGENTACCEPTDTMF")
(1157,1)
(1158,)
(1159,filename)
(1160,500)
(1161,lock)
(1162,tmpoptions=pbx_builtin_getvar_helper(chan, "AGENTWRAPUPTIME")
(1163,args.agent_id)
(1164,res)
(1165,if (!p->chan)
(1166,ast_channel_state(chan)
(1167,args.options)
(1168,p)
(1169,"Wrapup time for %s expired!\\n")
(1170,0)
(1171,)
(1172,!p->pending)
(1173,p->chan)
(1174,agent)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^