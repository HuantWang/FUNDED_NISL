-----label-----
1
-----code-----
int
kernel_xf_read(int sd, char *buffer, int blen, int seq)
{
	struct sadb_msg *sres = (struct sadb_msg *)buffer;
	int len, forus;

	/*
	 * Read in response from the kernel. If seq number and/or PID are
	 * given, we need to check PID and sequence number to see if it
	 * really is a message for us.
	 */
	do {
		struct pollfd pfd;

		pfd.fd = sd;
		pfd.events = POLLIN;
		pfd.revents = 0;

		if (poll(&pfd, 1, POLL_TIMEOUT) == -1) {
			log_error(__FUNCTION__": poll");
			return (0);
		}

		if (!(pfd.revents & POLLIN)) {
			log_print(__FUNCTION__": no reply from pfkey");
			return (0);
		}

		if (recv(sd, sres, sizeof(*sres), MSG_PEEK) != sizeof(*sres)) {
			log_error(__FUNCTION__": read()");
			return (0);
		}
		len = sres->sadb_msg_len * 8;
		if (len >= BUFFER_SIZE) {
			log_print(__FUNCTION__
				  ": PFKEYV2 message len %d too big", len);
			return (0);
		}
		if (read(sd, sres, len) != len) {
			log_error(__FUNCTION__": read()");
			return (0);
		}

		forus = !(sres->sadb_msg_pid &&
			  sres->sadb_msg_pid != pfkey_pid) &&
			!(seq && sres->sadb_msg_seq != seq);

		if (!forus) {
			switch (sres->sadb_msg_type) {
			case SADB_ACQUIRE:
			case SADB_EXPIRE:
				kernel_queue_msg(sres);
				break;
			default:
				LOG_DBG((LOG_KERNEL, 50, __FUNCTION__
					 ": skipping message type %d",
					 sres->sadb_msg_type));
				break;
			}
		}

	} while (!forus);

	if (sres->sadb_msg_errno) {
		LOG_DBG((LOG_KERNEL, 40, __FUNCTION__": PFKEYV2 result: %s",
			 strerror(sres->sadb_msg_errno)));
		errno = sres->sadb_msg_errno;
		return (0);
	}

	return (1);
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
3,7
3,8
5,6
5,7
7,8
9,10
9,11
11,12
11,13
14,15
14,16
16,17
18,19
18,20
20,21
22,23
22,24
22,25
22,26
22,27
23,24
24,25
24,26
25,26
27,28
27,29
27,30
30,31
31,32
31,33
32,33
32,34
33,34
35,36
37,38
39,40
40,41
40,42
40,43
42,43
44,45
46,47
46,48
47,48
47,49
47,50
47,51
47,52
47,53
47,54
47,55
47,56
47,57
47,58
47,59
48,49
49,50
49,51
50,51
52,53
54,55
55,56
55,57
56,57
56,58
57,58
60,61
62,63
63,64
63,65
64,65
64,66
65,66
68,69
70,71
71,72
71,73
72,73
72,74
73,74
77,78
77,79
78,79
78,80
79,80
79,81
79,82
79,83
80,81
82,83
83,84
86,87
88,89
90,91
90,92
91,92
92,93
93,94
95,96
95,97
96,97
97,98
98,99
98,100
99,100
99,101
100,101
103,104
105,106
105,107
106,107
107,108
108,109
110,111
110,112
111,112
111,113
112,113
112,114
112,115
112,116
112,117
113,114
115,116
117,118
119,120
120,121
121,122
122,123
124,125
126,127
127,128
128,129
129,130
131,132
131,133
132,133
133,134
134,135
136,137
137,138
137,139
138,139
140,141
140,142
141,142
141,143
142,143
146,147
146,148
147,148
147,149
148,149
150,151
152,153
152,154
153,154
154,155
155,156
157,158
157,159
158,159
158,160
159,160
159,161
159,162
159,163
160,161
162,163
164,165
166,167
168,169
170,171
170,172
171,172
172,173
173,174
175,176
176,177
176,178
177,178
179,180
179,181
180,181
181,182
182,183
182,184
183,184
183,185
184,185
187,188
187,189
188,189
188,190
189,190
192,193
194,195
195,196
196,197
196,198
197,198
199,200
199,201
200,201
200,202
201,202
204,205
206,207
206,208
207,208
208,209
210,211
211,212
211,213
212,213
212,214
213,214
216,217
216,218
216,219
216,220
216,221
216,222
216,223
217,218
218,219
220,221
221,222
223,224
224,225
224,226
225,226
227,228
231,232
233,234
234,235
236,237
236,238
237,238
237,239
238,239
241,242
241,243
241,244
242,243
243,244
244,245
244,246
245,246
247,248
247,249
248,249
251,252
252,253
254,255
255,256
-----nextToken-----
2,4,6,8,10,12,13,15,17,19,21,26,28,29,34,36,38,41,43,45,51,53,58,59,61,66,67,69,74,75,76,81,84,85,87,89,94,101,102,104,109,114,116,118,123,125,130,135,139,143,144,145,149,151,156,161,163,165,167,169,174,178,185,186,190,191,193,198,202,203,205,209,214,215,219,222,226,228,229,230,232,235,239,240,246,249,250,253,256
-----computeFrom-----
55,56
55,57
63,64
63,65
71,72
71,73
78,79
78,80
98,99
98,100
111,112
111,113
137,138
137,139
140,141
140,142
147,148
147,149
158,159
158,160
176,177
176,178
179,180
179,181
182,183
182,184
187,188
187,189
196,197
196,198
199,200
199,201
244,245
244,246
-----guardedBy-----
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;CastExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;Pointer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;Declarator;Name;DoStatement;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;UnaryExpression;LiteralExpression;CompoundStatement;ProblemStatement;ReturnStatement;UnaryExpression;LiteralExpression;IfStatement;UnaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ProblemStatement;ReturnStatement;UnaryExpression;LiteralExpression;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;CompoundStatement;ProblemStatement;ReturnStatement;UnaryExpression;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ProblemStatement;ReturnStatement;UnaryExpression;LiteralExpression;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ProblemStatement;ReturnStatement;UnaryExpression;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;UnaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;SwitchStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BreakStatement;DefaultStatement;ProblemStatement;BreakStatement;UnaryExpression;IdExpression;Name;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ProblemStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ReturnStatement;UnaryExpression;LiteralExpression;ReturnStatement;UnaryExpression;LiteralExpression;
-----ast_node-----
intkernel_xf_read(int sd, char *buffer, int blen, int seq){	struct sadb_msg *sres = (struct sadb_msg *)buffer;	int len, forus;	/*	 * Read in response from the kernel. If seq number and/or PID are	 * given, we need to check PID and sequence number to see if it	 * really is a message for us.	 */	do {		struct pollfd pfd;		pfd.fd = sd;		pfd.events = POLLIN;		pfd.revents = 0;		if (poll(&pfd, 1, POLL_TIMEOUT) == -1) {			log_error(__FUNCTION__": poll");			return (0);		}		if (!(pfd.revents & POLLIN)) {			log_print(__FUNCTION__": no reply from pfkey");			return (0);		}		if (recv(sd, sres, sizeof(*sres), MSG_PEEK) != sizeof(*sres)) {			log_error(__FUNCTION__": read()");			return (0);		}		len = sres->sadb_msg_len * 8;		if (len >= BUFFER_SIZE) {			log_print(__FUNCTION__				  ": PFKEYV2 message len %d too big", len);			return (0);		}		if (read(sd, sres, len) != len) {			log_error(__FUNCTION__": read()");			return (0);		}		forus = !(sres->sadb_msg_pid &&			  sres->sadb_msg_pid != pfkey_pid) &&			!(seq && sres->sadb_msg_seq != seq);		if (!forus) {			switch (sres->sadb_msg_type) {			case SADB_ACQUIRE:			case SADB_EXPIRE:				kernel_queue_msg(sres);				break;			default:				LOG_DBG((LOG_KERNEL, 50, __FUNCTION__					 ": skipping message type %d",					 sres->sadb_msg_type));				break;			}		}	} while (!forus);	if (sres->sadb_msg_errno) {		LOG_DBG((LOG_KERNEL, 40, __FUNCTION__": PFKEYV2 result: %s",			 strerror(sres->sadb_msg_errno)));		errno = sres->sadb_msg_errno;		return (0);	}	return (1);}
int
kernel_xf_read(int sd, char *buffer, int blen, int seq)
kernel_xf_read
int sd
int
sd
sd
char *buffer
char
*buffer
*
buffer
int blen
int
blen
blen
int seq
int
seq
seq
{	struct sadb_msg *sres = (struct sadb_msg *)buffer;	int len, forus;	/*	 * Read in response from the kernel. If seq number and/or PID are	 * given, we need to check PID and sequence number to see if it	 * really is a message for us.	 */	do {		struct pollfd pfd;		pfd.fd = sd;		pfd.events = POLLIN;		pfd.revents = 0;		if (poll(&pfd, 1, POLL_TIMEOUT) == -1) {			log_error(__FUNCTION__": poll");			return (0);		}		if (!(pfd.revents & POLLIN)) {			log_print(__FUNCTION__": no reply from pfkey");			return (0);		}		if (recv(sd, sres, sizeof(*sres), MSG_PEEK) != sizeof(*sres)) {			log_error(__FUNCTION__": read()");			return (0);		}		len = sres->sadb_msg_len * 8;		if (len >= BUFFER_SIZE) {			log_print(__FUNCTION__				  ": PFKEYV2 message len %d too big", len);			return (0);		}		if (read(sd, sres, len) != len) {			log_error(__FUNCTION__": read()");			return (0);		}		forus = !(sres->sadb_msg_pid &&			  sres->sadb_msg_pid != pfkey_pid) &&			!(seq && sres->sadb_msg_seq != seq);		if (!forus) {			switch (sres->sadb_msg_type) {			case SADB_ACQUIRE:			case SADB_EXPIRE:				kernel_queue_msg(sres);				break;			default:				LOG_DBG((LOG_KERNEL, 50, __FUNCTION__					 ": skipping message type %d",					 sres->sadb_msg_type));				break;			}		}	} while (!forus);	if (sres->sadb_msg_errno) {		LOG_DBG((LOG_KERNEL, 40, __FUNCTION__": PFKEYV2 result: %s",			 strerror(sres->sadb_msg_errno)));		errno = sres->sadb_msg_errno;		return (0);	}	return (1);}
struct sadb_msg *sres = (struct sadb_msg *)buffer;
struct sadb_msg *sres = (struct sadb_msg *)buffer;
struct sadb_msg
sadb_msg
*sres = (struct sadb_msg *)buffer
*
sres
= (struct sadb_msg *)buffer
(struct sadb_msg *)buffer
struct sadb_msg *
struct sadb_msg
sadb_msg
*
*
buffer
buffer
int len, forus;
int len, forus;
int
len
len
forus
forus
do {		struct pollfd pfd;		pfd.fd = sd;		pfd.events = POLLIN;		pfd.revents = 0;		if (poll(&pfd, 1, POLL_TIMEOUT) == -1) {			log_error(__FUNCTION__": poll");			return (0);		}		if (!(pfd.revents & POLLIN)) {			log_print(__FUNCTION__": no reply from pfkey");			return (0);		}		if (recv(sd, sres, sizeof(*sres), MSG_PEEK) != sizeof(*sres)) {			log_error(__FUNCTION__": read()");			return (0);		}		len = sres->sadb_msg_len * 8;		if (len >= BUFFER_SIZE) {			log_print(__FUNCTION__				  ": PFKEYV2 message len %d too big", len);			return (0);		}		if (read(sd, sres, len) != len) {			log_error(__FUNCTION__": read()");			return (0);		}		forus = !(sres->sadb_msg_pid &&			  sres->sadb_msg_pid != pfkey_pid) &&			!(seq && sres->sadb_msg_seq != seq);		if (!forus) {			switch (sres->sadb_msg_type) {			case SADB_ACQUIRE:			case SADB_EXPIRE:				kernel_queue_msg(sres);				break;			default:				LOG_DBG((LOG_KERNEL, 50, __FUNCTION__					 ": skipping message type %d",					 sres->sadb_msg_type));				break;			}		}	} while (!forus);
{		struct pollfd pfd;		pfd.fd = sd;		pfd.events = POLLIN;		pfd.revents = 0;		if (poll(&pfd, 1, POLL_TIMEOUT) == -1) {			log_error(__FUNCTION__": poll");			return (0);		}		if (!(pfd.revents & POLLIN)) {			log_print(__FUNCTION__": no reply from pfkey");			return (0);		}		if (recv(sd, sres, sizeof(*sres), MSG_PEEK) != sizeof(*sres)) {			log_error(__FUNCTION__": read()");			return (0);		}		len = sres->sadb_msg_len * 8;		if (len >= BUFFER_SIZE) {			log_print(__FUNCTION__				  ": PFKEYV2 message len %d too big", len);			return (0);		}		if (read(sd, sres, len) != len) {			log_error(__FUNCTION__": read()");			return (0);		}		forus = !(sres->sadb_msg_pid &&			  sres->sadb_msg_pid != pfkey_pid) &&			!(seq && sres->sadb_msg_seq != seq);		if (!forus) {			switch (sres->sadb_msg_type) {			case SADB_ACQUIRE:			case SADB_EXPIRE:				kernel_queue_msg(sres);				break;			default:				LOG_DBG((LOG_KERNEL, 50, __FUNCTION__					 ": skipping message type %d",					 sres->sadb_msg_type));				break;			}		}	}
struct pollfd pfd;
struct pollfd pfd;
struct pollfd
pollfd
pfd
pfd
pfd.fd = sd;
pfd.fd = sd
pfd.fd
pfd
pfd
fd
sd
sd
pfd.events = POLLIN;
pfd.events = POLLIN
pfd.events
pfd
pfd
events
POLLIN
POLLIN
pfd.revents = 0;
pfd.revents = 0
pfd.revents
pfd
pfd
revents
0
if (poll(&pfd, 1, POLL_TIMEOUT) == -1) {			log_error(__FUNCTION__": poll");			return (0);		}
poll(&pfd, 1, POLL_TIMEOUT) == -1
poll(&pfd, 1, POLL_TIMEOUT)
poll
poll
&pfd
pfd
pfd
1
POLL_TIMEOUT
POLL_TIMEOUT
-1
1
{			log_error(__FUNCTION__": poll");			return (0);		}
log_error(__FUNCTION__": poll");
return (0);
(0)
0
if (!(pfd.revents & POLLIN)) {			log_print(__FUNCTION__": no reply from pfkey");			return (0);		}
!(pfd.revents & POLLIN)
(pfd.revents & POLLIN)
pfd.revents & POLLIN
pfd.revents
pfd
pfd
revents
POLLIN
POLLIN
{			log_print(__FUNCTION__": no reply from pfkey");			return (0);		}
log_print(__FUNCTION__": no reply from pfkey");
return (0);
(0)
0
if (recv(sd, sres, sizeof(*sres), MSG_PEEK) != sizeof(*sres)) {			log_error(__FUNCTION__": read()");			return (0);		}
recv(sd, sres, sizeof(*sres), MSG_PEEK) != sizeof(*sres)
recv(sd, sres, sizeof(*sres), MSG_PEEK)
recv
recv
sd
sd
sres
sres
sizeof(*sres)
(*sres)
*sres
sres
sres
MSG_PEEK
MSG_PEEK
sizeof(*sres)
(*sres)
*sres
sres
sres
{			log_error(__FUNCTION__": read()");			return (0);		}
log_error(__FUNCTION__": read()");
return (0);
(0)
0
len = sres->sadb_msg_len * 8;
len = sres->sadb_msg_len * 8
len
len
sres->sadb_msg_len * 8
sres->sadb_msg_len
sres
sres
sadb_msg_len
8
if (len >= BUFFER_SIZE) {			log_print(__FUNCTION__				  ": PFKEYV2 message len %d too big", len);			return (0);		}
len >= BUFFER_SIZE
len
len
BUFFER_SIZE
BUFFER_SIZE
{			log_print(__FUNCTION__				  ": PFKEYV2 message len %d too big", len);			return (0);		}
log_print(__FUNCTION__				  ": PFKEYV2 message len %d too big", len);
return (0);
(0)
0
if (read(sd, sres, len) != len) {			log_error(__FUNCTION__": read()");			return (0);		}
read(sd, sres, len) != len
read(sd, sres, len)
read
read
sd
sd
sres
sres
len
len
len
len
{			log_error(__FUNCTION__": read()");			return (0);		}
log_error(__FUNCTION__": read()");
return (0);
(0)
0
forus = !(sres->sadb_msg_pid &&			  sres->sadb_msg_pid != pfkey_pid) &&			!(seq && sres->sadb_msg_seq != seq);
forus = !(sres->sadb_msg_pid &&			  sres->sadb_msg_pid != pfkey_pid) &&			!(seq && sres->sadb_msg_seq != seq)
forus
forus
!(sres->sadb_msg_pid &&			  sres->sadb_msg_pid != pfkey_pid) &&			!(seq && sres->sadb_msg_seq != seq)
!(sres->sadb_msg_pid &&			  sres->sadb_msg_pid != pfkey_pid)
(sres->sadb_msg_pid &&			  sres->sadb_msg_pid != pfkey_pid)
sres->sadb_msg_pid &&			  sres->sadb_msg_pid != pfkey_pid
sres->sadb_msg_pid
sres
sres
sadb_msg_pid
sres->sadb_msg_pid != pfkey_pid
sres->sadb_msg_pid
sres
sres
sadb_msg_pid
pfkey_pid
pfkey_pid
!(seq && sres->sadb_msg_seq != seq)
(seq && sres->sadb_msg_seq != seq)
seq && sres->sadb_msg_seq != seq
seq
seq
sres->sadb_msg_seq != seq
sres->sadb_msg_seq
sres
sres
sadb_msg_seq
seq
seq
if (!forus) {			switch (sres->sadb_msg_type) {			case SADB_ACQUIRE:			case SADB_EXPIRE:				kernel_queue_msg(sres);				break;			default:				LOG_DBG((LOG_KERNEL, 50, __FUNCTION__					 ": skipping message type %d",					 sres->sadb_msg_type));				break;			}		}
!forus
forus
forus
{			switch (sres->sadb_msg_type) {			case SADB_ACQUIRE:			case SADB_EXPIRE:				kernel_queue_msg(sres);				break;			default:				LOG_DBG((LOG_KERNEL, 50, __FUNCTION__					 ": skipping message type %d",					 sres->sadb_msg_type));				break;			}		}
switch (sres->sadb_msg_type) {			case SADB_ACQUIRE:			case SADB_EXPIRE:				kernel_queue_msg(sres);				break;			default:				LOG_DBG((LOG_KERNEL, 50, __FUNCTION__					 ": skipping message type %d",					 sres->sadb_msg_type));				break;			}
sres->sadb_msg_type
sres
sres
sadb_msg_type
{			case SADB_ACQUIRE:			case SADB_EXPIRE:				kernel_queue_msg(sres);				break;			default:				LOG_DBG((LOG_KERNEL, 50, __FUNCTION__					 ": skipping message type %d",					 sres->sadb_msg_type));				break;			}
case SADB_ACQUIRE:
SADB_ACQUIRE
SADB_ACQUIRE
case SADB_EXPIRE:
SADB_EXPIRE
SADB_EXPIRE
kernel_queue_msg(sres);
kernel_queue_msg(sres)
kernel_queue_msg
kernel_queue_msg
sres
sres
break;
default:
LOG_DBG((LOG_KERNEL, 50, __FUNCTION__					 ": skipping message type %d",					 sres->sadb_msg_type));
break;
!forus
forus
forus
if (sres->sadb_msg_errno) {		LOG_DBG((LOG_KERNEL, 40, __FUNCTION__": PFKEYV2 result: %s",			 strerror(sres->sadb_msg_errno)));		errno = sres->sadb_msg_errno;		return (0);	}
sres->sadb_msg_errno
sres
sres
sadb_msg_errno
{		LOG_DBG((LOG_KERNEL, 40, __FUNCTION__": PFKEYV2 result: %s",			 strerror(sres->sadb_msg_errno)));		errno = sres->sadb_msg_errno;		return (0);	}
LOG_DBG((LOG_KERNEL, 40, __FUNCTION__": PFKEYV2 result: %s",			 strerror(sres->sadb_msg_errno)));
errno = sres->sadb_msg_errno;
errno = sres->sadb_msg_errno
errno
errno
sres->sadb_msg_errno
sres
sres
sadb_msg_errno
return (0);
(0)
0
return (1);
(1)
1
-----joern-----
(80,105,0)
(66,139,0)
(38,33,0)
(90,139,0)
(58,72,0)
(63,93,0)
(138,105,0)
(106,16,0)
(4,9,0)
(19,55,0)
(135,72,0)
(60,17,0)
(80,40,0)
(67,60,0)
(61,47,0)
(2,131,0)
(143,114,0)
(45,47,0)
(32,80,0)
(134,103,0)
(16,106,0)
(1,40,0)
(72,81,0)
(103,72,0)
(22,47,0)
(127,126,0)
(92,89,0)
(114,61,0)
(79,105,0)
(106,25,0)
(78,81,0)
(27,57,0)
(123,55,0)
(57,47,0)
(83,114,0)
(131,9,0)
(128,27,0)
(18,80,0)
(13,0,0)
(93,126,0)
(43,138,0)
(7,55,0)
(97,35,0)
(25,106,0)
(120,72,0)
(111,27,0)
(136,12,0)
(108,133,0)
(12,89,0)
(56,122,0)
(58,40,0)
(18,128,0)
(98,72,0)
(87,27,0)
(15,55,0)
(120,108,0)
(9,47,0)
(12,138,0)
(114,83,0)
(94,20,0)
(73,139,0)
(17,34,0)
(120,40,0)
(96,83,0)
(36,105,0)
(63,31,0)
(69,43,0)
(42,72,0)
(31,63,0)
(103,40,0)
(90,122,0)
(8,138,0)
(103,27,0)
(139,90,0)
(84,108,0)
(39,16,0)
(34,17,0)
(26,56,0)
(108,75,0)
(122,90,0)
(86,93,0)
(124,43,0)
(128,72,0)
(122,56,0)
(14,9,0)
(40,20,0)
(62,68,0)
(83,138,0)
(17,85,0)
(81,47,0)
(53,47,0)
(60,85,0)
(64,47,0)
(82,141,0)
(6,34,0)
(71,98,0)
(112,8,0)
(138,59,0)
(59,99,0)
(130,47,0)
(120,133,0)
(83,30,0)
(5,40,0)
(35,138,0)
(18,98,0)
(29,3,0)
(128,40,0)
(37,93,0)
(100,50,0)
(23,33,0)
(128,65,0)
(135,40,0)
(109,105,0)
(59,138,0)
(18,58,0)
(58,27,0)
(144,141,0)
(35,106,0)
(141,144,0)
(49,72,0)
(139,144,0)
(118,12,0)
(68,3,0)
(46,59,0)
(20,47,0)
(24,4,0)
(18,103,0)
(98,27,0)
(41,75,0)
(50,55,0)
(129,17,0)
(16,33,0)
(17,60,0)
(101,68,0)
(3,68,0)
(6,25,0)
(75,138,0)
(141,138,0)
(95,21,0)
(139,30,0)
(56,138,0)
(120,27,0)
(117,0,0)
(60,43,0)
(6,9,0)
(77,139,0)
(18,120,0)
(54,83,0)
(74,120,0)
(119,140,0)
(61,89,0)
(89,61,0)
(98,40,0)
(68,57,0)
(34,6,0)
(106,35,0)
(28,75,0)
(44,138,0)
(137,61,0)
(99,59,0)
(116,83,0)
(75,108,0)
(83,61,0)
(25,6,0)
(135,27,0)
(104,105,0)
(132,55,0)
(3,10,0)
(0,61,0)
(9,6,0)
(144,139,0)
(135,88,0)
(98,52,0)
(121,8,0)
(113,105,0)
(126,93,0)
(115,58,0)
(43,60,0)
(50,138,0)
(89,12,0)
(140,138,0)
(76,128,0)
(80,72,0)
(11,35,0)
(58,70,0)
(102,47,0)
(10,3,0)
(33,138,0)
(142,57,0)
(110,140,0)
(51,31,0)
(18,135,0)
(80,27,0)
(103,125,0)
(59,107,0)
(48,47,0)
(91,135,0)
(139,138,0)
(33,16,0)
(93,63,0)
(20,30,0)
(28,84,1)
(93,86,1)
(0,13,1)
(127,57,1)
(10,3,1)
(103,134,1)
(83,138,1)
(54,0,1)
(89,92,1)
(63,31,1)
(75,138,1)
(5,131,1)
(121,112,1)
(83,30,1)
(84,140,1)
(124,129,1)
(80,40,1)
(3,68,1)
(114,61,1)
(62,63,1)
(61,89,1)
(20,94,1)
(139,144,1)
(126,127,1)
(76,90,1)
(135,27,1)
(118,136,1)
(73,77,1)
(111,87,1)
(38,23,1)
(59,107,1)
(23,35,1)
(63,93,1)
(25,106,1)
(114,83,1)
(74,108,1)
(43,138,1)
(58,115,1)
(87,81,1)
(101,62,1)
(106,16,1)
(14,114,1)
(139,66,1)
(49,20,1)
(98,40,1)
(71,10,1)
(60,85,1)
(33,38,1)
(32,140,1)
(37,126,1)
(98,71,1)
(80,72,1)
(60,67,1)
(58,27,1)
(18,103,1)
(41,28,1)
(78,72,1)
(58,72,1)
(80,27,1)
(100,8,1)
(27,111,1)
(8,138,1)
(93,126,1)
(18,98,1)
(3,29,1)
(24,9,1)
(1,5,1)
(128,27,1)
(82,73,1)
(141,138,1)
(17,85,1)
(20,30,1)
(34,17,1)
(83,96,1)
(77,10,1)
(17,129,1)
(90,139,1)
(39,33,1)
(35,138,1)
(122,56,1)
(90,122,1)
(119,110,1)
(72,42,1)
(33,138,1)
(116,54,1)
(114,143,1)
(136,137,1)
(108,75,1)
(16,39,1)
(4,9,1)
(117,61,1)
(137,90,1)
(110,131,1)
(6,25,1)
(96,116,1)
(129,25,1)
(139,138,1)
(120,27,1)
(120,72,1)
(68,101,1)
(135,40,1)
(56,138,1)
(59,46,1)
(135,72,1)
(140,119,1)
(97,14,1)
(56,26,1)
(103,40,1)
(9,6,1)
(94,40,1)
(140,138,1)
(2,19,1)
(91,63,1)
(16,33,1)
(8,121,1)
(11,97,1)
(68,57,1)
(51,93,1)
(123,50,1)
(69,124,1)
(18,80,1)
(67,43,1)
(141,82,1)
(80,32,1)
(89,12,1)
(18,135,1)
(2,123,1)
(103,27,1)
(57,142,1)
(17,60,1)
(2,4,1)
(138,59,1)
(143,83,1)
(98,27,1)
(19,8,1)
(135,91,1)
(18,128,1)
(18,58,1)
(131,2,1)
(18,120,1)
(66,144,1)
(12,118,1)
(128,72,1)
(134,114,1)
(35,11,1)
(75,41,1)
(115,0,1)
(0,61,1)
(83,61,1)
(13,117,1)
(103,72,1)
(46,44,1)
(50,100,1)
(120,74,1)
(112,4,1)
(139,30,1)
(92,12,1)
(128,76,1)
(29,68,1)
(58,40,1)
(4,24,1)
(40,1,1)
(98,72,1)
(142,27,1)
(12,138,1)
(31,51,1)
(120,40,1)
(131,9,1)
(59,99,1)
(43,69,1)
(128,40,1)
(5,138,1)
(144,141,1)
(106,35,1)
(6,34,1)
(42,49,1)
(120,108,1)
(60,43,1)
(86,37,1)
(50,138,1)
(26,139,1)
(81,78,1)
(120,40,2)
(62,63,2)
(58,72,2)
(108,75,2)
(78,131,2)
(73,10,2)
(114,0,2)
(50,8,2)
(18,128,2)
(11,114,2)
(20,30,2)
(18,120,2)
(18,80,2)
(4,114,2)
(24,114,2)
(103,27,2)
(123,8,2)
(71,10,2)
(112,4,2)
(38,35,2)
(34,17,2)
(58,0,2)
(122,10,2)
(35,114,2)
(18,103,2)
(49,131,2)
(6,25,2)
(68,57,2)
(56,138,2)
(2,114,2)
(1,131,2)
(18,98,2)
(128,27,2)
(98,72,2)
(91,63,2)
(80,27,2)
(17,60,2)
(35,138,2)
(8,4,2)
(90,122,2)
(90,139,2)
(0,90,2)
(6,34,2)
(60,43,2)
(80,72,2)
(83,0,2)
(144,10,2)
(63,31,2)
(126,131,2)
(139,30,2)
(87,131,2)
(3,68,2)
(140,138,2)
(83,61,2)
(103,72,2)
(111,131,2)
(138,59,2)
(25,106,2)
(12,90,2)
(135,72,2)
(60,85,2)
(134,114,2)
(43,129,2)
(10,3,2)
(34,25,2)
(106,114,2)
(124,129,2)
(61,90,2)
(115,0,2)
(75,140,2)
(40,131,2)
(41,140,2)
(82,10,2)
(122,56,2)
(117,90,2)
(74,140,2)
(56,10,2)
(89,12,2)
(57,131,2)
(89,90,2)
(120,140,2)
(42,131,2)
(33,35,2)
(3,63,2)
(80,140,2)
(16,33,2)
(8,138,2)
(131,9,2)
(93,131,2)
(80,40,2)
(63,131,2)
(120,27,2)
(23,35,2)
(114,83,2)
(139,10,2)
(142,131,2)
(116,0,2)
(67,129,2)
(18,58,2)
(60,129,2)
(120,108,2)
(58,40,2)
(128,72,2)
(27,131,2)
(18,135,2)
(50,138,2)
(10,63,2)
(19,8,2)
(6,114,2)
(17,85,2)
(63,93,2)
(13,90,2)
(43,138,2)
(54,0,2)
(0,61,2)
(20,131,2)
(51,131,2)
(135,40,2)
(14,114,2)
(135,27,2)
(103,40,2)
(26,10,2)
(93,126,2)
(9,6,2)
(37,131,2)
(81,131,2)
(144,141,2)
(17,25,2)
(83,138,2)
(118,90,2)
(5,131,2)
(106,16,2)
(77,10,2)
(59,107,2)
(83,30,2)
(141,10,2)
(69,129,2)
(143,0,2)
(119,131,2)
(101,63,2)
(28,140,2)
(9,114,2)
(114,61,2)
(12,138,2)
(135,63,2)
(100,8,2)
(141,138,2)
(97,114,2)
(96,0,2)
(139,138,2)
(59,99,2)
(4,9,2)
(75,138,2)
(131,114,2)
(137,90,2)
(136,90,2)
(72,131,2)
(39,35,2)
(129,25,2)
(94,131,2)
(92,90,2)
(98,40,2)
(98,10,2)
(140,131,2)
(127,131,2)
(90,10,2)
(121,4,2)
(139,144,2)
(108,140,2)
(25,114,2)
(98,27,2)
(128,90,2)
(86,131,2)
(61,89,2)
(128,40,2)
(66,10,2)
(84,140,2)
(16,35,2)
(29,63,2)
(68,63,2)
(32,140,2)
(31,131,2)
(33,138,2)
(120,72,2)
(58,27,2)
(106,35,2)
(76,90,2)
(110,131,2)
(103,114,2)
-----------------------------------
(0,len >= BUFFER_SIZE)
(1,fd)
(2,forus)
(3,pfd.revents & POLLIN)
(4,!forus)
(5,pfd)
(6,!(sres->sadb_msg_pid &&\n\\n\\t\\t\\t  sres->sadb_msg_pid != pfkey_pid)
(7,case SADB_EXPIRE:)
(8,sres->sadb_msg_type)
(9,forus = !(sres->sadb_msg_pid &&\n\\n\\t\\t\\t  sres->sadb_msg_pid != pfkey_pid)
(10,!(pfd.revents & POLLIN)
(11,sadb_msg_pid)
(12,sres->sadb_msg_len)
(13,BUFFER_SIZE)
(14,forus)
(15,default:)
(16,sres->sadb_msg_pid != pfkey_pid)
(17,seq && sres->sadb_msg_seq != seq)
(18,RET)
(19,break;)
(20,pfd.fd = sd)
(21,)
(22,if (read(sd, sres, len)
(23,sres)
(24,forus)
(25,!(sres->sadb_msg_pid &&\n\\n\\t\\t\\t  sres->sadb_msg_pid != pfkey_pid)
(26,sres)
(27,pfd.revents)
(28,sres)
(29,POLLIN)
(30,int sd)
(31,-1)
(32,1)
(33,sres->sadb_msg_pid)
(34,!(seq && sres->sadb_msg_seq != seq)
(35,sres->sadb_msg_pid)
(36,len)
(37,1)
(38,sadb_msg_pid)
(39,pfkey_pid)
(40,pfd.fd)
(41,sadb_msg_errno)
(42,events)
(43,sres->sadb_msg_seq)
(44,sres)
(45,if (poll(&pfd, 1, POLL_TIMEOUT)
(46,buffer)
(47,)
(48,pfd)
(49,pfd)
(50,kernel_queue_msg(sres)
(51,1)
(52,)
(53,if (len >= BUFFER_SIZE)
(54,sd)
(55,)
(56,*sres)
(57,pfd.revents = 0)
(58,return (0)
(59,(struct sadb_msg *)
(60,sres->sadb_msg_seq != seq)
(61,len = sres->sadb_msg_len * 8)
(62,pfd)
(63,poll(&pfd, 1, POLL_TIMEOUT)
(64,if (!(pfd.revents & POLLIN)
(65,)
(66,MSG_PEEK)
(67,seq)
(68,pfd.revents)
(69,sadb_msg_seq)
(70,)
(71,0)
(72,pfd.events)
(73,sres)
(74,0)
(75,sres->sadb_msg_errno)
(76,0)
(77,sd)
(78,POLLIN)
(79,sres)
(80,return (1)
(81,pfd.events = POLLIN)
(82,sres)
(83,read(sd, sres, len)
(84,errno)
(85,int seq)
(86,POLL_TIMEOUT)
(87,pfd)
(88,)
(89,sres->sadb_msg_len * 8)
(90,recv(sd, sres, sizeof(*sres)
(91,0)
(92,8)
(93,poll(&pfd, 1, POLL_TIMEOUT)
(94,sd)
(95,switch (sres->sadb_msg_type)
(96,len)
(97,sres)
(98,return (0)
(99,struct sadb_msg *)
(100,sres)
(101,revents)
(102,if (recv(sd, sres, sizeof(*sres)
(103,return (0)
(104,forus)
(105,)
(106,sres->sadb_msg_pid &&\n\\n\\t\\t\\t  sres->sadb_msg_pid != pfkey_pid)
(107,char *buffer)
(108,errno = sres->sadb_msg_errno)
(109,do)
(110,sres)
(111,revents)
(112,sres)
(113,if (sres->sadb_msg_errno)
(114,read(sd, sres, len)
(115,0)
(116,sres)
(117,len)
(118,sadb_msg_len)
(119,sadb_msg_errno)
(120,return (0)
(121,sadb_msg_type)
(122,sizeof(*sres)
(123,break;)
(124,sres)
(125,)
(126,&pfd)
(127,pfd)
(128,return (0)
(129,seq)
(130,if (!forus)
(131,!forus)
(132,case SADB_ACQUIRE:)
(133,)
(134,0)
(135,return (0)
(136,sres)
(137,len)
(138,*sres = (struct sadb_msg *)
(139,recv(sd, sres, sizeof(*sres)
(140,sres->sadb_msg_errno)
(141,*sres)
(142,0)
(143,len)
(144,sizeof(*sres)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^