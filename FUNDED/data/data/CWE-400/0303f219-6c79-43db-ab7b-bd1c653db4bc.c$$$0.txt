-----label-----
1
-----code-----
void remove_client_lock(struct locks* l, int wakeup_anyones) {
	struct timeval now = { 0 };

	DOUBLE_LLIST_DEL(&l->siblings);

	if ( wakeup_anyones ) {
		while ( l->parent->for_anyone.next != &l->parent->for_anyone ) {
			time_stats( (struct locks*)l->parent->for_anyone.next, waiting_time_for_good );
			send_client( (void*)l->parent->for_anyone.next, "DONE\n" );
			remove_client_lock( (void*)l->parent->for_anyone.next, 0 );
			decr_stats( waiting_workers );
			time_stats( l, gained_time );
		}
	}

	if ( l->state == PROCESSING ) {
		/* One slot freed, wake up another worker */

		time_stats( l, processing_time );
		incr_stats( processed_count );

		/* Give priority to those which need to do it themselves, since
		 * the anyones will benefit from it, too.
		 * TODO: Prefer the first anyone if it's much older.
		 */
		struct locks* new_owner = NULL;
		if ( l->parent->for_them.next != &l->parent->for_them ) {
			/* The oldest waiting worker will be on next */
			new_owner = (struct locks*) l->parent->for_them.next;
			time_stats( new_owner, waiting_time_for_me );
		} else if ( l->parent->for_anyone.next != &l->parent->for_anyone ) {
			new_owner = (struct locks*) l->parent->for_anyone.next;
			time_stats( new_owner, waiting_time_for_anyone );
		}

		if ( new_owner ) {
			time_stats( new_owner, waiting_time );
			DOUBLE_LLIST_DEL( &new_owner->siblings );
			DOUBLE_LLIST_ADD( &l->parent->working, &new_owner->siblings );
			send_client( new_owner, "LOCKED\n" );
			new_owner->state = PROCESSING;
			incr_stats( total_acquired );
			decr_stats( waiting_workers );
			gettimeofday( &l->timeval, NULL );
		} else {
			l->parent->processing--;
			decr_stats( processing_workers );
		}
	}

	l->state = UNLOCKED;
	l->parent->count--;
	if ( !l->parent->count ) {
		decr_stats( hashtable_entries );
		hashtable_remove( l->parent->htentry.parent_hashtable, &l->parent->htentry );
		free( l->parent->htentry.key );
		free( l->parent );
	}
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
5,6
5,7
6,7
8,9
8,10
11,12
11,13
13,14
15,16
15,17
15,18
15,19
15,20
15,21
15,22
16,17
17,18
17,19
18,19
20,21
20,22
22,23
23,24
25,26
26,27
26,28
27,28
29,30
30,31
30,32
31,32
34,35
34,36
35,36
37,38
38,39
38,40
39,40
39,41
40,41
40,42
41,42
41,43
42,43
42,44
43,44
48,49
49,50
49,51
50,51
50,52
51,52
55,56
55,57
55,58
55,59
55,60
56,57
57,58
57,59
57,60
58,59
60,61
60,62
61,62
61,63
62,63
64,65
66,67
66,68
67,68
67,69
68,69
68,70
69,70
74,75
76,77
77,78
77,79
77,80
78,79
80,81
80,82
81,82
81,83
83,84
85,86
85,87
86,87
86,88
87,88
87,89
88,89
94,95
95,96
95,97
95,98
96,97
98,99
98,100
99,100
99,101
101,102
103,104
103,105
104,105
104,106
105,106
105,107
106,107
112,113
113,114
113,115
114,115
116,117
117,118
119,120
120,121
120,122
120,123
121,122
123,124
125,126
127,128
127,129
128,129
128,130
129,130
129,131
130,131
133,134
135,136
135,137
135,138
135,139
135,140
136,137
137,138
137,139
137,140
138,139
140,141
142,143
144,145
145,146
145,147
146,147
148,149
149,150
151,152
152,153
152,154
153,154
155,156
155,157
155,158
158,159
159,160
161,162
161,163
161,164
162,163
162,164
163,164
163,165
164,165
164,166
165,166
165,167
166,167
171,172
172,173
172,174
173,174
173,175
174,175
178,179
178,180
179,180
180,181
180,182
181,182
183,184
183,185
184,185
184,186
185,186
187,188
189,190
189,191
190,191
190,192
191,192
191,193
192,193
197,198
198,199
198,200
198,201
199,200
201,202
203,204
205,206
205,207
206,207
206,208
207,208
207,209
208,209
208,210
209,210
209,211
210,211
215,216
216,217
216,218
217,218
217,219
218,219
222,223
222,224
223,224
224,225
224,226
225,226
227,228
227,229
228,229
228,230
229,230
231,232
233,234
233,235
234,235
234,236
235,236
235,237
236,237
241,242
242,243
242,244
242,245
243,244
245,246
247,248
249,250
249,251
249,252
250,251
252,253
252,254
252,255
252,256
252,257
252,258
252,259
252,260
253,254
254,255
254,256
254,257
255,256
257,258
259,260
261,262
262,263
262,264
263,264
265,266
266,267
266,268
267,268
270,271
271,272
271,273
271,274
272,273
274,275
275,276
275,277
276,277
276,278
277,278
281,282
282,283
282,284
283,284
286,287
287,288
287,289
287,290
288,289
290,291
293,294
294,295
294,296
295,296
295,297
296,297
299,300
301,302
302,303
302,304
303,304
305,306
306,307
308,309
309,310
309,311
310,311
312,313
313,314
315,316
316,317
316,318
316,319
317,318
319,320
320,321
320,322
321,322
324,325
326,327
326,328
327,328
328,329
329,330
329,331
330,331
330,332
331,332
335,336
336,337
336,338
337,338
339,340
340,341
342,343
343,344
343,345
344,345
344,346
345,346
348,349
350,351
351,352
352,353
352,354
353,354
353,355
354,355
358,359
358,360
359,360
360,361
360,362
361,362
361,363
362,363
366,367
366,368
366,369
366,370
367,368
368,369
368,370
369,370
371,372
372,373
374,375
375,376
375,377
375,378
376,377
378,379
378,380
379,380
379,381
380,381
380,382
381,382
386,387
387,388
387,389
388,389
388,390
389,390
393,394
394,395
394,396
395,396
397,398
397,399
398,399
398,400
399,400
399,401
400,401
405,406
406,407
406,408
407,408
409,410
409,411
410,411
-----nextToken-----
2,4,7,9,10,12,14,19,21,24,28,32,33,36,44,45,46,47,52,53,54,59,63,65,70,71,72,73,75,79,82,84,89,90,91,92,93,97,100,102,107,108,109,110,111,115,118,122,124,126,131,132,134,139,141,143,147,150,154,156,157,160,167,168,169,170,175,176,177,182,186,188,193,194,195,196,200,202,204,211,212,213,214,219,220,221,226,230,232,237,238,239,240,244,246,248,251,256,258,260,264,268,269,273,278,279,280,284,285,289,291,292,297,298,300,304,307,311,314,318,322,323,325,332,333,334,338,341,346,347,349,355,356,357,363,364,365,370,373,377,382,383,384,385,390,391,392,396,401,402,403,404,408,411,412
-----computeFrom-----
39,40
39,41
128,129
128,130
162,163
162,164
180,181
180,182
206,207
206,208
224,225
224,226
294,295
294,296
343,344
343,345
-----guardedBy-----
134,300
132,298
131,332
170,196
176,194
177,195
175,193
214,240
220,238
221,239
219,237
-----guardedByNegation-----
170,240
176,238
175,237
-----lastLexicalUse-----
170,240
176,238
175,237
-----jump-----
170,240
176,238
175,237
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;InitializerList;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;IdExpression;Name;CompoundStatement;WhileStatement;BinaryExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;CastExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;Pointer;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;Pointer;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;Pointer;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IfStatement;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;
-----ast_node-----
void remove_client_lock(struct locks* l, int wakeup_anyones) {	struct timeval now = { 0 };	DOUBLE_LLIST_DEL(&l->siblings);	if ( wakeup_anyones ) {		while ( l->parent->for_anyone.next != &l->parent->for_anyone ) {			time_stats( (struct locks*)l->parent->for_anyone.next, waiting_time_for_good );			send_client( (void*)l->parent->for_anyone.next, "DONE\n" );			remove_client_lock( (void*)l->parent->for_anyone.next, 0 );			decr_stats( waiting_workers );			time_stats( l, gained_time );		}	}	if ( l->state == PROCESSING ) {		/* One slot freed, wake up another worker */		time_stats( l, processing_time );		incr_stats( processed_count );		/* Give priority to those which need to do it themselves, since		 * the anyones will benefit from it, too.		 * TODO: Prefer the first anyone if it's much older.		 */		struct locks* new_owner = NULL;		if ( l->parent->for_them.next != &l->parent->for_them ) {			/* The oldest waiting worker will be on next */			new_owner = (struct locks*) l->parent->for_them.next;			time_stats( new_owner, waiting_time_for_me );		} else if ( l->parent->for_anyone.next != &l->parent->for_anyone ) {			new_owner = (struct locks*) l->parent->for_anyone.next;			time_stats( new_owner, waiting_time_for_anyone );		}		if ( new_owner ) {			time_stats( new_owner, waiting_time );			DOUBLE_LLIST_DEL( &new_owner->siblings );			DOUBLE_LLIST_ADD( &l->parent->working, &new_owner->siblings );			send_client( new_owner, "LOCKED\n" );			new_owner->state = PROCESSING;			incr_stats( total_acquired );			decr_stats( waiting_workers );			gettimeofday( &l->timeval, NULL );		} else {			l->parent->processing--;			decr_stats( processing_workers );		}	}	l->state = UNLOCKED;	l->parent->count--;	if ( !l->parent->count ) {		decr_stats( hashtable_entries );		hashtable_remove( l->parent->htentry.parent_hashtable, &l->parent->htentry );		free( l->parent->htentry.key );		free( l->parent );	}}
void
remove_client_lock(struct locks* l, int wakeup_anyones)
remove_client_lock
struct locks* l
struct locks
locks
* l
*
l
int wakeup_anyones
int
wakeup_anyones
wakeup_anyones
{	struct timeval now = { 0 };	DOUBLE_LLIST_DEL(&l->siblings);	if ( wakeup_anyones ) {		while ( l->parent->for_anyone.next != &l->parent->for_anyone ) {			time_stats( (struct locks*)l->parent->for_anyone.next, waiting_time_for_good );			send_client( (void*)l->parent->for_anyone.next, "DONE\n" );			remove_client_lock( (void*)l->parent->for_anyone.next, 0 );			decr_stats( waiting_workers );			time_stats( l, gained_time );		}	}	if ( l->state == PROCESSING ) {		/* One slot freed, wake up another worker */		time_stats( l, processing_time );		incr_stats( processed_count );		/* Give priority to those which need to do it themselves, since		 * the anyones will benefit from it, too.		 * TODO: Prefer the first anyone if it's much older.		 */		struct locks* new_owner = NULL;		if ( l->parent->for_them.next != &l->parent->for_them ) {			/* The oldest waiting worker will be on next */			new_owner = (struct locks*) l->parent->for_them.next;			time_stats( new_owner, waiting_time_for_me );		} else if ( l->parent->for_anyone.next != &l->parent->for_anyone ) {			new_owner = (struct locks*) l->parent->for_anyone.next;			time_stats( new_owner, waiting_time_for_anyone );		}		if ( new_owner ) {			time_stats( new_owner, waiting_time );			DOUBLE_LLIST_DEL( &new_owner->siblings );			DOUBLE_LLIST_ADD( &l->parent->working, &new_owner->siblings );			send_client( new_owner, "LOCKED\n" );			new_owner->state = PROCESSING;			incr_stats( total_acquired );			decr_stats( waiting_workers );			gettimeofday( &l->timeval, NULL );		} else {			l->parent->processing--;			decr_stats( processing_workers );		}	}	l->state = UNLOCKED;	l->parent->count--;	if ( !l->parent->count ) {		decr_stats( hashtable_entries );		hashtable_remove( l->parent->htentry.parent_hashtable, &l->parent->htentry );		free( l->parent->htentry.key );		free( l->parent );	}}
struct timeval now = { 0 };
struct timeval now = { 0 };
struct timeval
timeval
now = { 0 }
now
= { 0 }
{ 0 }
0
DOUBLE_LLIST_DEL(&l->siblings);
DOUBLE_LLIST_DEL(&l->siblings)
DOUBLE_LLIST_DEL
DOUBLE_LLIST_DEL
&l->siblings
l->siblings
l
l
siblings
if ( wakeup_anyones ) {		while ( l->parent->for_anyone.next != &l->parent->for_anyone ) {			time_stats( (struct locks*)l->parent->for_anyone.next, waiting_time_for_good );			send_client( (void*)l->parent->for_anyone.next, "DONE\n" );			remove_client_lock( (void*)l->parent->for_anyone.next, 0 );			decr_stats( waiting_workers );			time_stats( l, gained_time );		}	}
wakeup_anyones
wakeup_anyones
{		while ( l->parent->for_anyone.next != &l->parent->for_anyone ) {			time_stats( (struct locks*)l->parent->for_anyone.next, waiting_time_for_good );			send_client( (void*)l->parent->for_anyone.next, "DONE\n" );			remove_client_lock( (void*)l->parent->for_anyone.next, 0 );			decr_stats( waiting_workers );			time_stats( l, gained_time );		}	}
while ( l->parent->for_anyone.next != &l->parent->for_anyone ) {			time_stats( (struct locks*)l->parent->for_anyone.next, waiting_time_for_good );			send_client( (void*)l->parent->for_anyone.next, "DONE\n" );			remove_client_lock( (void*)l->parent->for_anyone.next, 0 );			decr_stats( waiting_workers );			time_stats( l, gained_time );		}
l->parent->for_anyone.next != &l->parent->for_anyone
l->parent->for_anyone.next
l->parent->for_anyone
l->parent
l
l
parent
for_anyone
next
&l->parent->for_anyone
l->parent->for_anyone
l->parent
l
l
parent
for_anyone
{			time_stats( (struct locks*)l->parent->for_anyone.next, waiting_time_for_good );			send_client( (void*)l->parent->for_anyone.next, "DONE\n" );			remove_client_lock( (void*)l->parent->for_anyone.next, 0 );			decr_stats( waiting_workers );			time_stats( l, gained_time );		}
time_stats( (struct locks*)l->parent->for_anyone.next, waiting_time_for_good );
time_stats( (struct locks*)l->parent->for_anyone.next, waiting_time_for_good )
time_stats
time_stats
(struct locks*)l->parent->for_anyone.next
struct locks*
struct locks
locks
*
*
l->parent->for_anyone.next
l->parent->for_anyone
l->parent
l
l
parent
for_anyone
next
waiting_time_for_good
waiting_time_for_good
send_client( (void*)l->parent->for_anyone.next, "DONE\n" );
send_client( (void*)l->parent->for_anyone.next, "DONE\n" )
send_client
send_client
(void*)l->parent->for_anyone.next
void*
void
*
*
l->parent->for_anyone.next
l->parent->for_anyone
l->parent
l
l
parent
for_anyone
next
"DONE\n"
remove_client_lock( (void*)l->parent->for_anyone.next, 0 );
remove_client_lock( (void*)l->parent->for_anyone.next, 0 )
remove_client_lock
remove_client_lock
(void*)l->parent->for_anyone.next
void*
void
*
*
l->parent->for_anyone.next
l->parent->for_anyone
l->parent
l
l
parent
for_anyone
next
0
decr_stats( waiting_workers );
decr_stats( waiting_workers );
decr_stats
decr_stats
( waiting_workers )
waiting_workers
waiting_workers
time_stats( l, gained_time );
time_stats( l, gained_time )
time_stats
time_stats
l
l
gained_time
gained_time
if ( l->state == PROCESSING ) {		/* One slot freed, wake up another worker */		time_stats( l, processing_time );		incr_stats( processed_count );		/* Give priority to those which need to do it themselves, since		 * the anyones will benefit from it, too.		 * TODO: Prefer the first anyone if it's much older.		 */		struct locks* new_owner = NULL;		if ( l->parent->for_them.next != &l->parent->for_them ) {			/* The oldest waiting worker will be on next */			new_owner = (struct locks*) l->parent->for_them.next;			time_stats( new_owner, waiting_time_for_me );		} else if ( l->parent->for_anyone.next != &l->parent->for_anyone ) {			new_owner = (struct locks*) l->parent->for_anyone.next;			time_stats( new_owner, waiting_time_for_anyone );		}		if ( new_owner ) {			time_stats( new_owner, waiting_time );			DOUBLE_LLIST_DEL( &new_owner->siblings );			DOUBLE_LLIST_ADD( &l->parent->working, &new_owner->siblings );			send_client( new_owner, "LOCKED\n" );			new_owner->state = PROCESSING;			incr_stats( total_acquired );			decr_stats( waiting_workers );			gettimeofday( &l->timeval, NULL );		} else {			l->parent->processing--;			decr_stats( processing_workers );		}	}
l->state == PROCESSING
l->state
l
l
state
PROCESSING
PROCESSING
{		/* One slot freed, wake up another worker */		time_stats( l, processing_time );		incr_stats( processed_count );		/* Give priority to those which need to do it themselves, since		 * the anyones will benefit from it, too.		 * TODO: Prefer the first anyone if it's much older.		 */		struct locks* new_owner = NULL;		if ( l->parent->for_them.next != &l->parent->for_them ) {			/* The oldest waiting worker will be on next */			new_owner = (struct locks*) l->parent->for_them.next;			time_stats( new_owner, waiting_time_for_me );		} else if ( l->parent->for_anyone.next != &l->parent->for_anyone ) {			new_owner = (struct locks*) l->parent->for_anyone.next;			time_stats( new_owner, waiting_time_for_anyone );		}		if ( new_owner ) {			time_stats( new_owner, waiting_time );			DOUBLE_LLIST_DEL( &new_owner->siblings );			DOUBLE_LLIST_ADD( &l->parent->working, &new_owner->siblings );			send_client( new_owner, "LOCKED\n" );			new_owner->state = PROCESSING;			incr_stats( total_acquired );			decr_stats( waiting_workers );			gettimeofday( &l->timeval, NULL );		} else {			l->parent->processing--;			decr_stats( processing_workers );		}	}
time_stats( l, processing_time );
time_stats( l, processing_time )
time_stats
time_stats
l
l
processing_time
processing_time
incr_stats( processed_count );
incr_stats( processed_count );
incr_stats
incr_stats
( processed_count )
processed_count
processed_count
struct locks* new_owner = NULL;
struct locks* new_owner = NULL;
struct locks
locks
* new_owner = NULL
*
new_owner
= NULL
NULL
NULL
if ( l->parent->for_them.next != &l->parent->for_them ) {			/* The oldest waiting worker will be on next */			new_owner = (struct locks*) l->parent->for_them.next;			time_stats( new_owner, waiting_time_for_me );		} else if ( l->parent->for_anyone.next != &l->parent->for_anyone ) {			new_owner = (struct locks*) l->parent->for_anyone.next;			time_stats( new_owner, waiting_time_for_anyone );		}
l->parent->for_them.next != &l->parent->for_them
l->parent->for_them.next
l->parent->for_them
l->parent
l
l
parent
for_them
next
&l->parent->for_them
l->parent->for_them
l->parent
l
l
parent
for_them
{			/* The oldest waiting worker will be on next */			new_owner = (struct locks*) l->parent->for_them.next;			time_stats( new_owner, waiting_time_for_me );		}
new_owner = (struct locks*) l->parent->for_them.next;
new_owner = (struct locks*) l->parent->for_them.next
new_owner
new_owner
(struct locks*) l->parent->for_them.next
struct locks*
struct locks
locks
*
*
l->parent->for_them.next
l->parent->for_them
l->parent
l
l
parent
for_them
next
time_stats( new_owner, waiting_time_for_me );
time_stats( new_owner, waiting_time_for_me )
time_stats
time_stats
new_owner
new_owner
waiting_time_for_me
waiting_time_for_me
if ( l->parent->for_anyone.next != &l->parent->for_anyone ) {			new_owner = (struct locks*) l->parent->for_anyone.next;			time_stats( new_owner, waiting_time_for_anyone );		}
l->parent->for_anyone.next != &l->parent->for_anyone
l->parent->for_anyone.next
l->parent->for_anyone
l->parent
l
l
parent
for_anyone
next
&l->parent->for_anyone
l->parent->for_anyone
l->parent
l
l
parent
for_anyone
{			new_owner = (struct locks*) l->parent->for_anyone.next;			time_stats( new_owner, waiting_time_for_anyone );		}
new_owner = (struct locks*) l->parent->for_anyone.next;
new_owner = (struct locks*) l->parent->for_anyone.next
new_owner
new_owner
(struct locks*) l->parent->for_anyone.next
struct locks*
struct locks
locks
*
*
l->parent->for_anyone.next
l->parent->for_anyone
l->parent
l
l
parent
for_anyone
next
time_stats( new_owner, waiting_time_for_anyone );
time_stats( new_owner, waiting_time_for_anyone )
time_stats
time_stats
new_owner
new_owner
waiting_time_for_anyone
waiting_time_for_anyone
if ( new_owner ) {			time_stats( new_owner, waiting_time );			DOUBLE_LLIST_DEL( &new_owner->siblings );			DOUBLE_LLIST_ADD( &l->parent->working, &new_owner->siblings );			send_client( new_owner, "LOCKED\n" );			new_owner->state = PROCESSING;			incr_stats( total_acquired );			decr_stats( waiting_workers );			gettimeofday( &l->timeval, NULL );		} else {			l->parent->processing--;			decr_stats( processing_workers );		}
new_owner
new_owner
{			time_stats( new_owner, waiting_time );			DOUBLE_LLIST_DEL( &new_owner->siblings );			DOUBLE_LLIST_ADD( &l->parent->working, &new_owner->siblings );			send_client( new_owner, "LOCKED\n" );			new_owner->state = PROCESSING;			incr_stats( total_acquired );			decr_stats( waiting_workers );			gettimeofday( &l->timeval, NULL );		}
time_stats( new_owner, waiting_time );
time_stats( new_owner, waiting_time )
time_stats
time_stats
new_owner
new_owner
waiting_time
waiting_time
DOUBLE_LLIST_DEL( &new_owner->siblings );
DOUBLE_LLIST_DEL( &new_owner->siblings )
DOUBLE_LLIST_DEL
DOUBLE_LLIST_DEL
&new_owner->siblings
new_owner->siblings
new_owner
new_owner
siblings
DOUBLE_LLIST_ADD( &l->parent->working, &new_owner->siblings );
DOUBLE_LLIST_ADD( &l->parent->working, &new_owner->siblings )
DOUBLE_LLIST_ADD
DOUBLE_LLIST_ADD
&l->parent->working
l->parent->working
l->parent
l
l
parent
working
&new_owner->siblings
new_owner->siblings
new_owner
new_owner
siblings
send_client( new_owner, "LOCKED\n" );
send_client( new_owner, "LOCKED\n" )
send_client
send_client
new_owner
new_owner
"LOCKED\n"
new_owner->state = PROCESSING;
new_owner->state = PROCESSING
new_owner->state
new_owner
new_owner
state
PROCESSING
PROCESSING
incr_stats( total_acquired );
incr_stats( total_acquired );
incr_stats
incr_stats
( total_acquired )
total_acquired
total_acquired
decr_stats( waiting_workers );
decr_stats( waiting_workers );
decr_stats
decr_stats
( waiting_workers )
waiting_workers
waiting_workers
gettimeofday( &l->timeval, NULL );
gettimeofday( &l->timeval, NULL )
gettimeofday
gettimeofday
&l->timeval
l->timeval
l
l
timeval
NULL
NULL
{			l->parent->processing--;			decr_stats( processing_workers );		}
l->parent->processing--;
l->parent->processing--
l->parent->processing
l->parent
l
l
parent
processing
decr_stats( processing_workers );
decr_stats( processing_workers );
decr_stats
decr_stats
( processing_workers )
processing_workers
processing_workers
l->state = UNLOCKED;
l->state = UNLOCKED
l->state
l
l
state
UNLOCKED
UNLOCKED
l->parent->count--;
l->parent->count--
l->parent->count
l->parent
l
l
parent
count
if ( !l->parent->count ) {		decr_stats( hashtable_entries );		hashtable_remove( l->parent->htentry.parent_hashtable, &l->parent->htentry );		free( l->parent->htentry.key );		free( l->parent );	}
!l->parent->count
l->parent->count
l->parent
l
l
parent
count
{		decr_stats( hashtable_entries );		hashtable_remove( l->parent->htentry.parent_hashtable, &l->parent->htentry );		free( l->parent->htentry.key );		free( l->parent );	}
decr_stats( hashtable_entries );
decr_stats( hashtable_entries );
decr_stats
decr_stats
( hashtable_entries )
hashtable_entries
hashtable_entries
hashtable_remove( l->parent->htentry.parent_hashtable, &l->parent->htentry );
hashtable_remove( l->parent->htentry.parent_hashtable, &l->parent->htentry )
hashtable_remove
hashtable_remove
l->parent->htentry.parent_hashtable
l->parent->htentry
l->parent
l
l
parent
htentry
parent_hashtable
&l->parent->htentry
l->parent->htentry
l->parent
l
l
parent
htentry
free( l->parent->htentry.key );
free( l->parent->htentry.key )
free
free
l->parent->htentry.key
l->parent->htentry
l->parent
l
l
parent
htentry
key
free( l->parent );
free( l->parent )
free
free
l->parent
l
l
parent
-----joern-----
(106,79,0)
(167,191,0)
(98,193,0)
(167,108,0)
(58,12,0)
(215,216,0)
(196,134,0)
(92,151,0)
(33,77,0)
(108,167,0)
(93,185,0)
(40,155,0)
(145,159,0)
(29,148,0)
(103,56,0)
(191,167,0)
(43,183,0)
(205,151,0)
(73,177,0)
(27,193,0)
(215,156,0)
(117,106,0)
(183,185,0)
(131,103,0)
(122,58,0)
(15,82,0)
(47,185,0)
(187,152,0)
(72,64,0)
(28,82,0)
(229,36,0)
(190,203,0)
(25,71,0)
(62,159,0)
(182,212,0)
(49,70,0)
(83,100,0)
(202,160,0)
(164,216,0)
(23,180,0)
(70,201,0)
(9,111,0)
(26,32,0)
(75,155,0)
(140,53,0)
(59,105,0)
(16,155,0)
(136,231,0)
(52,61,0)
(223,133,0)
(50,191,0)
(102,151,0)
(16,139,0)
(167,178,0)
(228,200,0)
(132,111,0)
(81,70,0)
(173,177,0)
(237,216,0)
(186,139,0)
(69,67,0)
(114,53,0)
(118,185,0)
(65,14,0)
(78,185,0)
(75,108,0)
(238,27,0)
(9,15,0)
(234,57,0)
(112,217,0)
(160,66,0)
(152,187,0)
(56,103,0)
(12,116,0)
(124,58,0)
(229,146,0)
(102,51,0)
(152,56,0)
(67,161,0)
(143,47,0)
(32,228,0)
(198,62,0)
(133,126,0)
(123,93,0)
(16,151,0)
(86,133,0)
(104,228,0)
(125,146,0)
(40,139,0)
(169,185,0)
(12,8,0)
(54,78,0)
(42,151,0)
(37,193,0)
(233,47,0)
(178,167,0)
(58,124,0)
(208,225,0)
(96,118,0)
(161,67,0)
(113,128,0)
(142,169,0)
(57,186,0)
(163,194,0)
(53,177,0)
(128,113,0)
(77,139,0)
(36,153,0)
(32,185,0)
(11,155,0)
(139,186,0)
(152,149,0)
(5,62,0)
(51,102,0)
(224,103,0)
(162,157,0)
(235,146,0)
(77,155,0)
(127,155,0)
(116,12,0)
(220,107,0)
(212,61,0)
(130,65,0)
(2,185,0)
(25,183,0)
(194,231,0)
(12,58,0)
(206,183,0)
(68,40,0)
(211,14,0)
(89,136,0)
(61,185,0)
(131,185,0)
(194,141,0)
(99,198,0)
(93,128,0)
(40,108,0)
(179,158,0)
(183,25,0)
(158,76,0)
(48,29,0)
(87,198,0)
(63,105,0)
(7,116,0)
(0,105,0)
(132,169,0)
(29,185,0)
(71,237,0)
(139,90,0)
(64,162,0)
(192,197,0)
(204,124,0)
(85,136,0)
(133,108,0)
(157,105,0)
(2,97,0)
(95,16,0)
(146,185,0)
(74,34,0)
(148,105,0)
(217,112,0)
(191,212,0)
(80,148,0)
(193,37,0)
(36,229,0)
(129,79,0)
(79,57,0)
(111,9,0)
(165,77,0)
(15,9,0)
(56,152,0)
(201,70,0)
(134,100,0)
(112,31,0)
(174,180,0)
(172,77,0)
(103,131,0)
(162,64,0)
(153,200,0)
(107,180,0)
(195,102,0)
(137,231,0)
(141,216,0)
(30,106,0)
(22,132,0)
(84,75,0)
(40,205,0)
(45,114,0)
(168,156,0)
(10,17,0)
(124,118,0)
(193,27,0)
(128,93,0)
(155,180,0)
(225,207,0)
(136,185,0)
(65,219,0)
(62,198,0)
(1,185,0)
(82,155,0)
(199,97,0)
(219,65,0)
(158,179,0)
(106,185,0)
(13,76,0)
(115,32,0)
(75,151,0)
(46,180,0)
(1,76,0)
(203,66,0)
(51,78,0)
(47,180,0)
(166,61,0)
(82,139,0)
(200,228,0)
(91,112,0)
(4,186,0)
(55,118,0)
(14,65,0)
(18,31,0)
(31,185,0)
(219,179,0)
(88,121,0)
(82,15,0)
(57,79,0)
(34,105,0)
(70,185,0)
(157,162,0)
(114,185,0)
(231,136,0)
(237,71,0)
(100,185,0)
(121,139,0)
(198,185,0)
(230,40,0)
(184,27,0)
(213,31,0)
(67,159,0)
(17,151,0)
(177,173,0)
(150,82,0)
(165,92,0)
(108,126,0)
(109,25,0)
(44,64,0)
(160,185,0)
(92,165,0)
(200,153,0)
(209,160,0)
(201,59,0)
(27,185,0)
(118,124,0)
(39,229,0)
(76,158,0)
(237,176,0)
(175,2,0)
(179,219,0)
(14,185,0)
(97,2,0)
(214,131,0)
(94,164,0)
(177,53,0)
(232,128,0)
(236,131,0)
(78,51,0)
(101,219,0)
(120,105,0)
(221,75,0)
(189,108,0)
(31,112,0)
(111,132,0)
(77,165,0)
(138,16,0)
(176,237,0)
(222,114,0)
(77,108,0)
(159,67,0)
(181,162,0)
(147,161,0)
(154,2,0)
(176,134,0)
(110,139,0)
(53,114,0)
(149,66,0)
(231,194,0)
(171,29,0)
(210,1,0)
(146,229,0)
(8,12,0)
(170,42,0)
(156,215,0)
(20,1,0)
(41,156,0)
(19,169,0)
(59,201,0)
(21,56,0)
(135,78,0)
(16,108,0)
(38,100,0)
(156,185,0)
(186,57,0)
(119,36,0)
(9,151,0)
(159,62,0)
(169,132,0)
(64,185,0)
(3,205,0)
(76,1,0)
(100,134,0)
(113,173,0)
(134,176,0)
(161,66,0)
(149,152,0)
(153,36,0)
(227,149,0)
(61,212,0)
(141,194,0)
(186,4,0)
(173,113,0)
(71,25,0)
(212,191,0)
(188,14,0)
(37,207,0)
(228,32,0)
(60,176,0)
(79,106,0)
(75,139,0)
(116,66,0)
(144,105,0)
(218,93,0)
(121,90,0)
(6,121,0)
(67,69,0)
(82,108,0)
(88,6,1)
(111,132,1)
(184,238,1)
(188,155,1)
(143,97,1)
(17,10,1)
(70,81,1)
(206,43,1)
(25,109,1)
(125,235,1)
(73,53,1)
(57,234,1)
(85,89,1)
(183,206,1)
(10,205,1)
(121,88,1)
(167,191,1)
(20,210,1)
(75,108,1)
(152,187,1)
(224,131,1)
(49,34,1)
(94,217,1)
(193,27,1)
(83,38,1)
(2,175,1)
(196,100,1)
(89,237,1)
(13,1,1)
(118,185,1)
(26,36,1)
(233,143,1)
(189,173,1)
(179,219,1)
(199,2,1)
(179,158,1)
(29,48,1)
(164,94,1)
(98,27,1)
(200,228,1)
(1,185,1)
(82,108,1)
(16,139,1)
(223,86,1)
(129,106,1)
(193,98,1)
(3,40,1)
(1,20,1)
(183,185,1)
(140,114,1)
(153,36,1)
(121,139,1)
(40,68,1)
(236,153,1)
(12,8,1)
(60,134,1)
(170,17,1)
(235,24,1)
(11,107,1)
(229,146,1)
(155,127,1)
(27,185,1)
(132,169,1)
(226,133,1)
(31,185,1)
(162,64,1)
(159,62,1)
(42,170,1)
(102,195,1)
(149,152,1)
(22,169,1)
(116,7,1)
(214,236,1)
(78,185,1)
(41,141,1)
(210,219,1)
(114,222,1)
(65,130,1)
(12,58,1)
(212,61,1)
(147,67,1)
(138,95,1)
(64,185,1)
(53,114,1)
(62,5,1)
(159,145,1)
(91,31,1)
(50,212,1)
(80,29,1)
(162,181,1)
(112,91,1)
(137,136,1)
(72,44,1)
(40,139,1)
(203,190,1)
(64,72,1)
(227,152,1)
(124,204,1)
(204,118,1)
(109,183,1)
(142,19,1)
(32,115,1)
(9,111,1)
(51,78,1)
(156,185,1)
(44,148,1)
(99,87,1)
(67,69,1)
(79,106,1)
(225,208,1)
(77,139,1)
(168,41,1)
(135,42,1)
(53,140,1)
(154,24,1)
(146,125,1)
(124,118,1)
(5,198,1)
(128,93,1)
(158,76,1)
(139,186,1)
(133,223,1)
(75,84,1)
(67,159,1)
(136,85,1)
(9,15,1)
(201,70,1)
(171,97,1)
(101,65,1)
(97,199,1)
(161,67,1)
(100,83,1)
(31,213,1)
(107,220,1)
(93,185,1)
(219,65,1)
(228,32,1)
(202,203,1)
(194,231,1)
(36,119,1)
(116,12,1)
(81,49,1)
(16,108,1)
(36,229,1)
(47,233,1)
(209,202,1)
(71,25,1)
(38,164,1)
(112,31,1)
(235,160,1)
(131,214,1)
(114,185,1)
(25,183,1)
(76,1,1)
(213,18,1)
(182,61,1)
(169,142,1)
(123,177,1)
(221,226,1)
(194,163,1)
(56,21,1)
(56,103,1)
(176,134,1)
(54,135,1)
(234,79,1)
(115,26,1)
(228,104,1)
(103,131,1)
(29,185,1)
(30,110,1)
(219,101,1)
(103,224,1)
(14,185,1)
(45,179,1)
(119,229,1)
(97,2,1)
(134,100,1)
(82,150,1)
(230,16,1)
(134,196,1)
(198,99,1)
(222,45,1)
(136,185,1)
(14,211,1)
(79,129,1)
(171,225,1)
(130,14,1)
(167,178,1)
(16,155,1)
(238,226,1)
(205,3,1)
(7,12,1)
(48,171,1)
(40,108,1)
(28,111,1)
(55,161,1)
(16,138,1)
(43,176,1)
(173,113,1)
(169,185,1)
(163,231,1)
(149,227,1)
(75,155,1)
(218,123,1)
(141,194,1)
(237,176,1)
(190,116,1)
(37,193,1)
(215,156,1)
(76,13,1)
(160,209,1)
(32,185,1)
(93,218,1)
(100,185,1)
(150,28,1)
(104,32,1)
(166,52,1)
(78,54,1)
(34,74,1)
(186,57,1)
(68,230,1)
(160,185,1)
(237,71,1)
(226,173,1)
(110,179,1)
(156,168,1)
(77,33,1)
(232,93,1)
(6,139,1)
(220,47,1)
(128,232,1)
(65,14,1)
(177,73,1)
(198,185,1)
(217,112,1)
(173,177,1)
(122,124,1)
(132,22,1)
(231,136,1)
(211,188,1)
(39,146,1)
(21,103,1)
(18,157,1)
(117,30,1)
(226,121,1)
(82,139,1)
(176,60,1)
(191,212,1)
(84,221,1)
(113,128,1)
(172,75,1)
(106,117,1)
(95,9,1)
(62,198,1)
(157,162,1)
(133,108,1)
(15,82,1)
(33,172,1)
(131,185,1)
(70,185,1)
(2,185,1)
(152,56,1)
(118,96,1)
(186,4,1)
(154,153,1)
(57,79,1)
(58,122,1)
(52,189,1)
(59,201,1)
(61,185,1)
(212,182,1)
(148,80,1)
(145,62,1)
(229,39,1)
(77,108,1)
(92,165,1)
(191,50,1)
(108,167,1)
(171,102,1)
(61,166,1)
(27,184,1)
(87,149,1)
(24,59,1)
(146,185,1)
(127,11,1)
(106,185,1)
(96,55,1)
(181,64,1)
(102,51,1)
(161,147,1)
(75,139,1)
(165,77,1)
(47,185,1)
(35,217,1)
(77,155,1)
(58,124,1)
(40,155,1)
(177,53,1)
(208,37,1)
(175,154,1)
(195,51,1)
(86,108,1)
(153,200,1)
(231,137,1)
(82,155,1)
(19,92,1)
(35,215,1)
(166,173,2)
(210,97,2)
(170,226,2)
(130,97,2)
(15,226,2)
(26,153,2)
(62,198,2)
(77,108,2)
(2,185,2)
(9,226,2)
(19,226,2)
(61,173,2)
(193,27,2)
(98,226,2)
(238,226,2)
(53,179,2)
(22,226,2)
(12,153,2)
(201,70,2)
(131,153,2)
(231,217,2)
(36,153,2)
(27,185,2)
(211,97,2)
(62,153,2)
(112,31,2)
(200,228,2)
(75,108,2)
(193,226,2)
(186,179,2)
(177,53,2)
(214,153,2)
(33,226,2)
(205,226,2)
(12,58,2)
(134,100,2)
(41,217,2)
(167,178,2)
(111,132,2)
(3,226,2)
(222,179,2)
(176,217,2)
(37,193,2)
(167,173,2)
(14,97,2)
(147,153,2)
(125,153,2)
(127,97,2)
(25,183,2)
(84,226,2)
(179,97,2)
(70,185,2)
(61,185,2)
(1,185,2)
(96,153,2)
(116,153,2)
(15,82,2)
(172,226,2)
(176,134,2)
(77,226,2)
(167,191,2)
(169,226,2)
(115,153,2)
(13,97,2)
(135,226,2)
(212,173,2)
(156,185,2)
(133,173,2)
(153,36,2)
(58,153,2)
(228,32,2)
(30,179,2)
(229,24,2)
(194,217,2)
(165,226,2)
(82,108,2)
(93,185,2)
(117,179,2)
(237,176,2)
(29,185,2)
(47,97,2)
(191,212,2)
(92,165,2)
(65,97,2)
(36,229,2)
(150,226,2)
(198,153,2)
(47,185,2)
(215,156,2)
(58,124,2)
(60,217,2)
(79,106,2)
(71,25,2)
(236,153,2)
(38,217,2)
(85,217,2)
(73,179,2)
(168,217,2)
(32,24,2)
(51,226,2)
(114,185,2)
(31,185,2)
(37,226,2)
(158,97,2)
(108,167,2)
(184,226,2)
(57,179,2)
(200,24,2)
(189,173,2)
(103,153,2)
(59,201,2)
(209,153,2)
(153,153,2)
(225,226,2)
(114,179,2)
(104,153,2)
(40,155,2)
(139,186,2)
(68,226,2)
(40,226,2)
(165,77,2)
(232,179,2)
(160,185,2)
(196,217,2)
(208,226,2)
(118,153,2)
(67,69,2)
(94,217,2)
(194,231,2)
(159,62,2)
(20,97,2)
(108,173,2)
(16,108,2)
(123,179,2)
(202,153,2)
(75,139,2)
(128,179,2)
(39,153,2)
(75,226,2)
(79,179,2)
(88,179,2)
(230,226,2)
(143,97,2)
(138,226,2)
(21,153,2)
(212,61,2)
(237,217,2)
(78,226,2)
(234,179,2)
(140,179,2)
(164,217,2)
(218,179,2)
(161,67,2)
(42,226,2)
(76,1,2)
(5,153,2)
(56,153,2)
(224,153,2)
(76,97,2)
(26,24,2)
(125,24,2)
(122,153,2)
(99,153,2)
(109,217,2)
(7,153,2)
(162,64,2)
(136,217,2)
(54,226,2)
(9,111,2)
(146,24,2)
(121,139,2)
(97,2,2)
(179,158,2)
(52,173,2)
(141,217,2)
(136,185,2)
(141,194,2)
(43,217,2)
(87,153,2)
(173,177,2)
(92,226,2)
(103,131,2)
(40,108,2)
(124,118,2)
(206,217,2)
(119,24,2)
(40,139,2)
(16,139,2)
(25,217,2)
(134,217,2)
(86,173,2)
(116,12,2)
(183,217,2)
(237,71,2)
(183,185,2)
(229,146,2)
(9,15,2)
(39,24,2)
(186,57,2)
(101,97,2)
(6,179,2)
(82,139,2)
(10,226,2)
(235,153,2)
(131,185,2)
(118,185,2)
(14,185,2)
(106,185,2)
(100,185,2)
(152,187,2)
(156,217,2)
(190,153,2)
(145,153,2)
(198,185,2)
(12,8,2)
(228,153,2)
(121,179,2)
(215,217,2)
(233,97,2)
(82,226,2)
(177,179,2)
(102,51,2)
(219,97,2)
(95,226,2)
(179,219,2)
(159,153,2)
(67,153,2)
(16,155,2)
(173,113,2)
(119,153,2)
(200,153,2)
(223,173,2)
(132,169,2)
(128,93,2)
(203,153,2)
(45,179,2)
(204,153,2)
(55,153,2)
(17,226,2)
(132,226,2)
(217,112,2)
(102,226,2)
(111,226,2)
(36,24,2)
(146,153,2)
(157,162,2)
(65,14,2)
(169,185,2)
(129,179,2)
(27,226,2)
(221,226,2)
(227,153,2)
(161,153,2)
(153,200,2)
(226,97,2)
(93,179,2)
(100,217,2)
(75,155,2)
(106,179,2)
(110,179,2)
(220,97,2)
(182,173,2)
(173,179,2)
(146,185,2)
(16,226,2)
(32,153,2)
(115,24,2)
(158,76,2)
(104,24,2)
(149,152,2)
(113,179,2)
(149,153,2)
(67,159,2)
(107,97,2)
(64,185,2)
(11,97,2)
(152,56,2)
(89,217,2)
(228,24,2)
(188,97,2)
(191,173,2)
(78,185,2)
(195,226,2)
(28,226,2)
(82,155,2)
(71,217,2)
(229,153,2)
(231,136,2)
(83,217,2)
(56,103,2)
(235,24,2)
(163,217,2)
(139,179,2)
(155,97,2)
(77,155,2)
(152,153,2)
(137,217,2)
(153,24,2)
(142,226,2)
(77,139,2)
(53,114,2)
(57,79,2)
(113,128,2)
(133,108,2)
(51,78,2)
(50,173,2)
(219,65,2)
(124,153,2)
(1,97,2)
(32,185,2)
(160,153,2)
(186,4,2)
-----------------------------------
(0,if ( !l->parent->count )
(1,l->parent)
(2,l->state)
(3,PROCESSING)
(4,struct locks*)
(5,for_anyone)
(6,new_owner)
(7,0)
(8,void*)
(9,DOUBLE_LLIST_ADD( &l->parent->working, &new_owner->siblings )
(10,total_acquired)
(11,new_owner)
(12,(void*)
(13,for_them)
(14,l->parent)
(15,&new_owner->siblings)
(16,send_client( new_owner, "LOCKED\\n" )
(17,incr_stats( total_acquired )
(18,l)
(19,l)
(20,parent)
(21,next)
(22,working)
(23,if ( l->parent->for_them.next != &l->parent->for_them )
(24,wakeup_anyones)
(25,l->parent->htentry)
(26,l)
(27,l->parent)
(28,new_owner)
(29,l->state)
(30,l)
(31,l->parent)
(32,l->parent)
(33,siblings)
(34,now = { 0 })
(35,RET)
(36,l->parent->for_anyone.next)
(37,l->parent->processing--)
(38,l)
(39,for_anyone)
(40,new_owner->state)
(41,l)
(42,decr_stats( waiting_workers )
(43,l)
(44,l)
(45,l)
(46,new_owner)
(47,time_stats( l, processing_time )
(48,state)
(49,l)
(50,next)
(51,&l->timeval)
(52,l)
(53,l->parent->for_anyone)
(54,timeval)
(55,l)
(56,l->parent->for_anyone.next)
(57,l->parent->for_them.next)
(58,l->parent->for_anyone.next)
(59,DOUBLE_LLIST_DEL(&l->siblings)
(60,parent_hashtable)
(61,l->parent)
(62,l->parent->for_anyone)
(63,if ( l->state == PROCESSING )
(64,l->parent)
(65,l->parent->for_them)
(66,)
(67,(void*)
(68,state)
(69,void*)
(70,l->siblings)
(71,&l->parent->htentry)
(72,parent)
(73,next)
(74,now)
(75,time_stats( new_owner, waiting_time )
(76,l->parent->for_them)
(77,new_owner->siblings)
(78,l->timeval)
(79,l->parent->for_them)
(80,UNLOCKED)
(81,siblings)
(82,new_owner->siblings)
(83,parent)
(84,waiting_time)
(85,parent)
(86,new_owner)
(87,l)
(88,waiting_time_for_me)
(89,l)
(90,)
(91,count)
(92,DOUBLE_LLIST_DEL( &new_owner->siblings )
(93,l->parent)
(94,hashtable_entries)
(95,new_owner)
(96,parent)
(97,l->state == PROCESSING)
(98,processing)
(99,parent)
(100,l->parent)
(101,next)
(102,gettimeofday( &l->timeval, NULL )
(103,l->parent->for_anyone)
(104,for_anyone)
(105,)
(106,l->parent)
(107,incr_stats( processed_count )
(108,new_owner = (struct locks*)
(109,htentry)
(110,new_owner)
(111,&l->parent->working)
(112,l->parent->count)
(113,&l->parent->for_anyone)
(114,l->parent)
(115,parent)
(116,remove_client_lock( (void*)
(117,parent)
(118,l->parent)
(119,next)
(120,if ( wakeup_anyones )
(121,time_stats( new_owner, waiting_time_for_me )
(122,next)
(123,l)
(124,l->parent->for_anyone)
(125,parent)
(126,)
(127,NULL)
(128,l->parent->for_anyone)
(129,for_them)
(130,for_them)
(131,l->parent)
(132,l->parent->working)
(133,time_stats( new_owner, waiting_time_for_anyone )
(134,l->parent->htentry)
(135,l)
(136,l->parent)
(137,htentry)
(138,"LOCKED\\n")
(139,new_owner = (struct locks*)
(140,for_anyone)
(141,free( l->parent->htentry.key )
(142,parent)
(143,l)
(144,now)
(145,next)
(146,l->parent)
(147,"DONE\\n")
(148,l->state = UNLOCKED)
(149,time_stats( (struct locks*)
(150,siblings)
(151,)
(152,(struct locks*)
(153,l->parent->for_anyone.next != &l->parent->for_anyone)
(154,l)
(155,* new_owner = NULL)
(156,l->parent)
(157,l->parent->count--)
(158,&l->parent->for_them)
(159,l->parent->for_anyone.next)
(160,time_stats( l, gained_time )
(161,send_client( (void*)
(162,l->parent->count)
(163,key)
(164,decr_stats( hashtable_entries )
(165,&new_owner->siblings)
(166,parent)
(167,(struct locks*)
(168,parent)
(169,l->parent)
(170,waiting_workers)
(171,l)
(172,new_owner)
(173,l->parent->for_anyone.next != &l->parent->for_anyone)
(174,if ( new_owner )
(175,state)
(176,l->parent->htentry.parent_hashtable)
(177,l->parent->for_anyone.next)
(178,struct locks*)
(179,l->parent->for_them.next != &l->parent->for_them)
(180,)
(181,count)
(182,for_anyone)
(183,l->parent)
(184,parent)
(185,struct locks* l)
(186,(struct locks*)
(187,struct locks*)
(188,l)
(189,new_owner)
(190,waiting_workers)
(191,l->parent->for_anyone.next)
(192,while ( l->parent->for_anyone.next != &l->parent->for_anyone )
(193,l->parent->processing)
(194,l->parent->htentry.key)
(195,NULL)
(196,htentry)
(197,)
(198,l->parent)
(199,PROCESSING)
(200,&l->parent->for_anyone)
(201,&l->siblings)
(202,l)
(203,decr_stats( waiting_workers )
(204,for_anyone)
(205,new_owner->state = PROCESSING)
(206,parent)
(207,)
(208,processing_workers)
(209,gained_time)
(210,l)
(211,parent)
(212,l->parent->for_anyone)
(213,parent)
(214,parent)
(215,free( l->parent )
(216,)
(217,!l->parent->count)
(218,parent)
(219,l->parent->for_them.next)
(220,processed_count)
(221,new_owner)
(222,parent)
(223,waiting_time_for_anyone)
(224,for_anyone)
(225,decr_stats( processing_workers )
(226,new_owner)
(227,waiting_time_for_good)
(228,l->parent->for_anyone)
(229,l->parent->for_anyone)
(230,new_owner)
(231,l->parent->htentry)
(232,for_anyone)
(233,processing_time)
(234,next)
(235,l)
(236,l)
(237,hashtable_remove( l->parent->htentry.parent_hashtable, &l->parent->htentry )
(238,l)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^