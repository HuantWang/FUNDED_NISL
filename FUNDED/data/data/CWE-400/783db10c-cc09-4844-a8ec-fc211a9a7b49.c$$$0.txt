-----label-----
1
-----code-----
static int sla_station_exec(struct ast_channel *chan, const char *data)
{
	char *station_name, *trunk_name;
	struct sla_station *station;
	struct sla_trunk_ref *trunk_ref = NULL;
	char conf_name[MAX_CONFNUM];
	struct ast_flags64 conf_flags = { 0 };
	struct ast_conference *conf;

	if (ast_strlen_zero(data)) {
		ast_log(LOG_WARNING, "Invalid Arguments to SLAStation!\n");
		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE");
		return 0;
	}

	trunk_name = ast_strdupa(data);
	station_name = strsep(&trunk_name, "_");

	if (ast_strlen_zero(station_name)) {
		ast_log(LOG_WARNING, "Invalid Arguments to SLAStation!\n");
		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE");
		return 0;
	}

	AST_RWLIST_RDLOCK(&sla_stations);
	station = sla_find_station(station_name);
	if (station)
		ast_atomic_fetchadd_int((int *) &station->ref_count, 1);
	AST_RWLIST_UNLOCK(&sla_stations);

	if (!station) {
		ast_log(LOG_WARNING, "Station '%s' not found!\n", station_name);
		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE");
		sla_queue_event(SLA_EVENT_CHECK_RELOAD);
		return 0;
	}

	AST_RWLIST_RDLOCK(&sla_trunks);
	if (!ast_strlen_zero(trunk_name)) {
		trunk_ref = sla_find_trunk_ref_byname(station, trunk_name);
	} else
		trunk_ref = sla_choose_idle_trunk(station);
	AST_RWLIST_UNLOCK(&sla_trunks);

	if (!trunk_ref) {
		if (ast_strlen_zero(trunk_name))
			ast_log(LOG_NOTICE, "No trunks available for call.\n");
		else {
			ast_log(LOG_NOTICE, "Can't join existing call on trunk "
				"'%s' due to access controls.\n", trunk_name);
		}
		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "CONGESTION");
		ast_atomic_fetchadd_int((int *) &station->ref_count, -1);
		sla_queue_event(SLA_EVENT_CHECK_RELOAD);
		return 0;
	}

	if (trunk_ref->state == SLA_TRUNK_STATE_ONHOLD_BYME) {
		if (ast_atomic_dec_and_test((int *) &trunk_ref->trunk->hold_stations) == 1)
			sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);
		else {
			trunk_ref->state = SLA_TRUNK_STATE_UP;
			ast_devstate_changed(AST_DEVICE_INUSE, AST_DEVSTATE_CACHABLE,
					     "SLA:%s_%s", station->name, trunk_ref->trunk->name);
		}
	} else if (trunk_ref->state == SLA_TRUNK_STATE_RINGING) {
		struct sla_ringing_trunk *ringing_trunk;

		ast_mutex_lock(&sla.lock);
		AST_LIST_TRAVERSE_SAFE_BEGIN(&sla.ringing_trunks, ringing_trunk, entry) {
			if (ringing_trunk->trunk == trunk_ref->trunk) {
				AST_LIST_REMOVE_CURRENT(entry);
				break;
			}
		}
		AST_LIST_TRAVERSE_SAFE_END
		ast_mutex_unlock(&sla.lock);

		if (ringing_trunk) {
			answer_trunk_chan(ringing_trunk->trunk->chan);
			sla_change_trunk_state(ringing_trunk->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);

			free(ringing_trunk);

			/* Queue up reprocessing ringing trunks, and then ringing stations again */
			sla_queue_event(SLA_EVENT_RINGING_TRUNK);
			sla_queue_event(SLA_EVENT_DIAL_STATE);
		}
	}

	trunk_ref->chan = chan;

	if (!trunk_ref->trunk->chan) {
		ast_mutex_t cond_lock;
		ast_cond_t cond;
		pthread_t dont_care;
		struct dial_trunk_args args = {
			.trunk_ref = trunk_ref,
			.station = station,
			.cond_lock = &cond_lock,
			.cond = &cond,
		};
		sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);
		/* Create a thread to dial the trunk and dump it into the conference.
		 * However, we want to wait until the trunk has been dialed and the
		 * conference is created before continuing on here. */
		ast_autoservice_start(chan);
		ast_mutex_init(&cond_lock);
		ast_cond_init(&cond, NULL);
		ast_mutex_lock(&cond_lock);
		ast_pthread_create_detached_background(&dont_care, NULL, dial_trunk, &args);
		ast_cond_wait(&cond, &cond_lock);
		ast_mutex_unlock(&cond_lock);
		ast_mutex_destroy(&cond_lock);
		ast_cond_destroy(&cond);
		ast_autoservice_stop(chan);
		if (!trunk_ref->trunk->chan) {
			ast_debug(1, "Trunk didn't get created. chan: %lx\n", (long) trunk_ref->trunk->chan);
			pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "CONGESTION");
			sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_IDLE, ALL_TRUNK_REFS, NULL);
			trunk_ref->chan = NULL;
			ast_atomic_fetchadd_int((int *) &station->ref_count, -1);
			sla_queue_event(SLA_EVENT_CHECK_RELOAD);
			return 0;
		}
	}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
5,6
5,7
6,7
8,9
8,10
11,12
11,13
13,14
13,15
16,17
16,18
16,19
16,20
16,21
16,22
16,23
16,24
16,25
16,26
16,27
16,28
16,29
16,30
16,31
16,32
16,33
16,34
16,35
16,36
16,37
16,38
16,39
16,40
16,41
16,42
16,43
16,44
16,45
16,46
16,47
16,48
16,49
16,50
16,51
17,18
18,19
18,20
18,21
20,21
20,22
23,24
23,25
26,27
27,28
27,29
28,29
30,31
30,32
33,34
34,35
34,36
35,36
37,38
37,39
37,40
40,41
41,42
43,44
44,45
44,46
46,47
46,48
48,49
49,50
51,52
52,53
52,54
53,54
55,56
55,57
57,58
58,59
60,61
61,62
61,63
62,63
64,65
64,66
67,68
67,69
68,69
68,70
69,70
71,72
73,74
73,75
73,76
74,75
75,76
75,77
75,78
76,77
78,79
81,82
82,83
82,84
82,85
82,86
83,84
85,86
89,90
91,92
92,93
92,94
93,94
95,96
95,97
96,97
98,99
100,101
101,102
101,103
102,103
104,105
104,106
104,107
105,106
107,108
108,109
111,112
111,113
112,113
112,114
113,114
115,116
117,118
117,119
117,120
118,119
119,120
119,121
119,122
120,121
122,123
125,126
126,127
126,128
126,129
126,130
127,128
129,130
133,134
135,136
136,137
136,138
137,138
139,140
140,141
140,142
143,144
144,145
144,146
145,146
147,148
147,149
148,149
150,151
152,153
152,154
153,154
155,156
156,157
156,158
156,159
157,158
159,160
159,161
160,161
160,162
162,163
164,165
165,166
165,167
166,167
170,171
171,172
171,173
172,173
174,175
175,176
177,178
177,179
178,179
179,180
181,182
181,183
181,184
181,185
182,183
183,184
183,185
183,186
183,187
184,185
186,187
189,190
191,192
192,193
192,194
192,195
192,196
193,194
195,196
199,200
200,201
200,202
201,202
203,204
204,205
206,207
208,209
209,210
209,211
210,211
212,213
213,214
213,215
216,217
216,218
216,219
217,218
218,219
218,220
219,220
221,222
223,224
224,225
225,226
225,227
226,227
228,229
228,230
228,231
229,230
231,232
233,234
235,236
236,237
236,238
237,238
239,240
239,241
240,241
242,243
244,245
245,246
245,247
246,247
248,249
249,250
251,252
251,253
252,253
253,254
255,256
255,257
255,258
255,259
255,260
256,257
256,258
256,259
257,258
257,259
258,259
260,261
262,263
263,264
263,265
263,266
264,265
266,267
269,270
270,271
271,272
271,273
271,274
271,275
272,273
274,275
277,278
279,280
280,281
280,282
280,283
280,284
281,282
283,284
287,288
288,289
288,290
288,291
289,290
291,292
291,293
292,293
292,294
294,295
296,297
297,298
297,299
298,299
301,302
303,304
304,305
304,306
305,306
307,308
308,309
310,311
312,313
312,314
312,315
313,314
313,315
314,315
314,316
315,316
318,319
320,321
321,322
321,323
321,324
322,323
322,324
323,324
323,325
324,325
326,327
326,328
327,328
327,329
329,330
331,332
332,333
332,334
333,334
333,335
334,335
339,340
340,341
340,342
340,343
340,344
340,345
341,342
343,344
343,345
344,345
347,348
349,350
351,352
353,354
353,355
354,355
355,356
355,357
356,357
356,358
357,358
360,361
362,363
363,364
363,365
363,366
363,367
363,368
363,369
364,365
366,367
368,369
371,372
371,373
372,373
375,376
375,377
376,377
376,378
377,378
381,382
381,383
382,383
382,384
383,384
383,385
384,385
387,388
389,390
389,391
389,392
389,393
389,394
389,395
389,396
390,391
391,392
391,393
392,393
394,395
394,396
397,398
398,399
398,400
399,400
401,402
402,403
402,404
403,404
406,407
407,408
407,409
407,410
407,411
408,409
410,411
411,412
411,413
412,413
415,416
417,418
419,420
420,421
421,422
421,423
422,423
422,424
423,424
423,425
424,425
427,428
427,429
428,429
431,432
431,433
432,433
433,434
433,435
434,435
436,437
437,438
440,441
441,442
441,443
442,443
444,445
444,446
446,447
447,448
448,449
448,450
449,450
452,453
452,454
453,454
455,456
455,457
455,458
455,459
455,460
456,457
457,458
457,459
458,459
460,461
460,462
461,462
461,463
462,463
466,467
467,468
467,469
467,470
467,471
467,472
468,469
470,471
470,472
471,472
474,475
476,477
478,479
480,481
481,482
481,483
482,483
484,485
486,487
487,488
487,489
488,489
490,491
491,492
493,494
494,495
494,496
495,496
497,498
498,499
500,501
501,502
501,503
502,503
502,504
503,504
506,507
508,509
508,510
509,510
510,511
510,512
511,512
511,513
512,513
516,517
516,518
516,519
516,520
517,518
518,519
518,520
519,520
521,522
523,524
524,525
524,526
525,526
527,528
529,530
530,531
530,532
531,532
533,534
535,536
537,538
538,539
538,540
538,541
538,542
538,543
539,540
541,542
541,543
542,543
545,546
547,548
549,550
551,552
552,553
552,554
553,554
555,556
557,558
558,559
558,560
559,560
561,562
562,563
562,564
565,566
566,567
566,568
566,569
567,568
569,570
570,571
572,573
574,575
575,576
575,577
576,577
578,579
579,580
581,582
582,583
582,584
582,585
582,586
582,587
583,584
585,586
586,587
588,589
590,591
592,593
593,594
595,596
596,597
596,598
596,599
597,598
599,600
600,601
602,603
603,604
605,606
606,607
606,608
607,608
609,610
610,611
612,613
613,614
613,615
614,615
616,617
617,618
619,620
620,621
620,622
621,622
623,624
624,625
624,626
627,628
628,629
628,630
629,630
631,632
633,634
633,635
634,635
635,636
635,637
636,637
636,638
637,638
641,642
641,643
641,644
641,645
641,646
641,647
641,648
642,643
643,644
643,645
643,646
643,647
644,645
648,649
648,650
649,650
649,651
652,653
652,654
653,654
653,655
654,655
658,659
659,660
659,661
659,662
659,663
660,661
662,663
666,667
667,668
667,669
667,670
667,671
667,672
668,669
670,671
670,672
671,672
674,675
676,677
678,679
680,681
681,682
681,683
682,683
682,684
683,684
686,687
688,689
689,690
689,691
689,692
690,691
692,693
692,694
693,694
693,695
695,696
697,698
698,699
698,700
699,700
702,703
704,705
705,706
705,707
706,707
708,709
709,710
711,712
-----nextToken-----
2,4,7,9,10,12,14,15,19,21,22,24,25,29,31,32,36,38,39,42,45,47,50,54,56,59,63,65,66,70,72,77,79,80,84,86,87,88,90,94,97,99,103,106,109,110,114,116,121,123,124,128,130,131,132,134,138,141,142,146,149,151,154,158,161,163,167,168,169,173,176,180,185,187,188,190,194,196,197,198,202,205,207,211,214,215,220,222,227,230,232,234,238,241,243,247,250,254,259,261,265,267,268,273,275,276,278,282,284,285,286,290,293,295,299,300,302,306,309,311,316,317,319,325,328,330,335,336,337,338,342,345,346,348,350,352,358,359,361,365,367,369,370,373,374,378,379,380,385,386,388,393,395,396,400,404,405,409,413,414,416,418,425,426,429,430,435,438,439,443,445,450,451,454,459,463,464,465,469,472,473,475,477,479,483,485,489,492,496,499,504,505,507,513,514,515,520,522,526,528,532,534,536,540,543,544,546,548,550,554,556,560,563,564,568,571,573,577,580,584,587,589,591,594,598,601,604,608,611,615,618,622,625,626,630,632,638,639,640,645,646,647,650,651,655,656,657,661,663,664,665,669,672,673,675,677,679,684,685,687,691,694,696,700,701,703,707,710,712
-----computeFrom-----
92,93
92,94
101,102
101,103
144,145
144,146
225,226
225,227
236,237
236,238
313,314
313,315
322,323
322,324
355,356
355,357
382,383
382,384
422,423
422,424
501,502
501,503
681,682
681,683
-----guardedBy-----
317,359
316,378
336,346
335,345
385,429
-----guardedByNegation-----
317,386
316,429
336,379
335,378
-----lastLexicalUse-----
316,429
317,386
336,379
335,378
-----jump-----
316,429
317,386
336,379
335,378
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;InitializerList;LiteralExpression;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;ReturnStatement;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;ReturnStatement;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;ReferenceOperator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;UnaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ReturnStatement;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;ReferenceOperator;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;UnaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ReturnStatement;LiteralExpression;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;ProblemStatement;CompoundStatement;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;BreakStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ConstructorInitializer;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ProblemStatement;NullStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;ReferenceOperator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;ReferenceOperator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;UnaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ReturnStatement;LiteralExpression;
-----ast_node-----
static int sla_station_exec(struct ast_channel *chan, const char *data){	char *station_name, *trunk_name;	struct sla_station *station;	struct sla_trunk_ref *trunk_ref = NULL;	char conf_name[MAX_CONFNUM];	struct ast_flags64 conf_flags = { 0 };	struct ast_conference *conf;	if (ast_strlen_zero(data)) {		ast_log(LOG_WARNING, "Invalid Arguments to SLAStation!\n");		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE");		return 0;	}	trunk_name = ast_strdupa(data);	station_name = strsep(&trunk_name, "_");	if (ast_strlen_zero(station_name)) {		ast_log(LOG_WARNING, "Invalid Arguments to SLAStation!\n");		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE");		return 0;	}	AST_RWLIST_RDLOCK(&sla_stations);	station = sla_find_station(station_name);	if (station)		ast_atomic_fetchadd_int((int *) &station->ref_count, 1);	AST_RWLIST_UNLOCK(&sla_stations);	if (!station) {		ast_log(LOG_WARNING, "Station '%s' not found!\n", station_name);		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE");		sla_queue_event(SLA_EVENT_CHECK_RELOAD);		return 0;	}	AST_RWLIST_RDLOCK(&sla_trunks);	if (!ast_strlen_zero(trunk_name)) {		trunk_ref = sla_find_trunk_ref_byname(station, trunk_name);	} else		trunk_ref = sla_choose_idle_trunk(station);	AST_RWLIST_UNLOCK(&sla_trunks);	if (!trunk_ref) {		if (ast_strlen_zero(trunk_name))			ast_log(LOG_NOTICE, "No trunks available for call.\n");		else {			ast_log(LOG_NOTICE, "Can't join existing call on trunk "				"'%s' due to access controls.\n", trunk_name);		}		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "CONGESTION");		ast_atomic_fetchadd_int((int *) &station->ref_count, -1);		sla_queue_event(SLA_EVENT_CHECK_RELOAD);		return 0;	}	if (trunk_ref->state == SLA_TRUNK_STATE_ONHOLD_BYME) {		if (ast_atomic_dec_and_test((int *) &trunk_ref->trunk->hold_stations) == 1)			sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);		else {			trunk_ref->state = SLA_TRUNK_STATE_UP;			ast_devstate_changed(AST_DEVICE_INUSE, AST_DEVSTATE_CACHABLE,					     "SLA:%s_%s", station->name, trunk_ref->trunk->name);		}	} else if (trunk_ref->state == SLA_TRUNK_STATE_RINGING) {		struct sla_ringing_trunk *ringing_trunk;		ast_mutex_lock(&sla.lock);		AST_LIST_TRAVERSE_SAFE_BEGIN(&sla.ringing_trunks, ringing_trunk, entry) {			if (ringing_trunk->trunk == trunk_ref->trunk) {				AST_LIST_REMOVE_CURRENT(entry);				break;			}		}		AST_LIST_TRAVERSE_SAFE_END		ast_mutex_unlock(&sla.lock);		if (ringing_trunk) {			answer_trunk_chan(ringing_trunk->trunk->chan);			sla_change_trunk_state(ringing_trunk->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);			free(ringing_trunk);			/* Queue up reprocessing ringing trunks, and then ringing stations again */			sla_queue_event(SLA_EVENT_RINGING_TRUNK);			sla_queue_event(SLA_EVENT_DIAL_STATE);		}	}	trunk_ref->chan = chan;	if (!trunk_ref->trunk->chan) {		ast_mutex_t cond_lock;		ast_cond_t cond;		pthread_t dont_care;		struct dial_trunk_args args = {			.trunk_ref = trunk_ref,			.station = station,			.cond_lock = &cond_lock,			.cond = &cond,		};		sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);		/* Create a thread to dial the trunk and dump it into the conference.		 * However, we want to wait until the trunk has been dialed and the		 * conference is created before continuing on here. */		ast_autoservice_start(chan);		ast_mutex_init(&cond_lock);		ast_cond_init(&cond, NULL);		ast_mutex_lock(&cond_lock);		ast_pthread_create_detached_background(&dont_care, NULL, dial_trunk, &args);		ast_cond_wait(&cond, &cond_lock);		ast_mutex_unlock(&cond_lock);		ast_mutex_destroy(&cond_lock);		ast_cond_destroy(&cond);		ast_autoservice_stop(chan);		if (!trunk_ref->trunk->chan) {			ast_debug(1, "Trunk didn't get created. chan: %lx\n", (long) trunk_ref->trunk->chan);			pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "CONGESTION");			sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_IDLE, ALL_TRUNK_REFS, NULL);			trunk_ref->chan = NULL;			ast_atomic_fetchadd_int((int *) &station->ref_count, -1);			sla_queue_event(SLA_EVENT_CHECK_RELOAD);			return 0;		}	}
static int
sla_station_exec(struct ast_channel *chan, const char *data)
sla_station_exec
struct ast_channel *chan
struct ast_channel
ast_channel
*chan
*
chan
const char *data
const char
*data
*
data
{	char *station_name, *trunk_name;	struct sla_station *station;	struct sla_trunk_ref *trunk_ref = NULL;	char conf_name[MAX_CONFNUM];	struct ast_flags64 conf_flags = { 0 };	struct ast_conference *conf;	if (ast_strlen_zero(data)) {		ast_log(LOG_WARNING, "Invalid Arguments to SLAStation!\n");		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE");		return 0;	}	trunk_name = ast_strdupa(data);	station_name = strsep(&trunk_name, "_");	if (ast_strlen_zero(station_name)) {		ast_log(LOG_WARNING, "Invalid Arguments to SLAStation!\n");		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE");		return 0;	}	AST_RWLIST_RDLOCK(&sla_stations);	station = sla_find_station(station_name);	if (station)		ast_atomic_fetchadd_int((int *) &station->ref_count, 1);	AST_RWLIST_UNLOCK(&sla_stations);	if (!station) {		ast_log(LOG_WARNING, "Station '%s' not found!\n", station_name);		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE");		sla_queue_event(SLA_EVENT_CHECK_RELOAD);		return 0;	}	AST_RWLIST_RDLOCK(&sla_trunks);	if (!ast_strlen_zero(trunk_name)) {		trunk_ref = sla_find_trunk_ref_byname(station, trunk_name);	} else		trunk_ref = sla_choose_idle_trunk(station);	AST_RWLIST_UNLOCK(&sla_trunks);	if (!trunk_ref) {		if (ast_strlen_zero(trunk_name))			ast_log(LOG_NOTICE, "No trunks available for call.\n");		else {			ast_log(LOG_NOTICE, "Can't join existing call on trunk "				"'%s' due to access controls.\n", trunk_name);		}		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "CONGESTION");		ast_atomic_fetchadd_int((int *) &station->ref_count, -1);		sla_queue_event(SLA_EVENT_CHECK_RELOAD);		return 0;	}	if (trunk_ref->state == SLA_TRUNK_STATE_ONHOLD_BYME) {		if (ast_atomic_dec_and_test((int *) &trunk_ref->trunk->hold_stations) == 1)			sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);		else {			trunk_ref->state = SLA_TRUNK_STATE_UP;			ast_devstate_changed(AST_DEVICE_INUSE, AST_DEVSTATE_CACHABLE,					     "SLA:%s_%s", station->name, trunk_ref->trunk->name);		}	} else if (trunk_ref->state == SLA_TRUNK_STATE_RINGING) {		struct sla_ringing_trunk *ringing_trunk;		ast_mutex_lock(&sla.lock);		AST_LIST_TRAVERSE_SAFE_BEGIN(&sla.ringing_trunks, ringing_trunk, entry) {			if (ringing_trunk->trunk == trunk_ref->trunk) {				AST_LIST_REMOVE_CURRENT(entry);				break;			}		}		AST_LIST_TRAVERSE_SAFE_END		ast_mutex_unlock(&sla.lock);		if (ringing_trunk) {			answer_trunk_chan(ringing_trunk->trunk->chan);			sla_change_trunk_state(ringing_trunk->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);			free(ringing_trunk);			/* Queue up reprocessing ringing trunks, and then ringing stations again */			sla_queue_event(SLA_EVENT_RINGING_TRUNK);			sla_queue_event(SLA_EVENT_DIAL_STATE);		}	}	trunk_ref->chan = chan;	if (!trunk_ref->trunk->chan) {		ast_mutex_t cond_lock;		ast_cond_t cond;		pthread_t dont_care;		struct dial_trunk_args args = {			.trunk_ref = trunk_ref,			.station = station,			.cond_lock = &cond_lock,			.cond = &cond,		};		sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);		/* Create a thread to dial the trunk and dump it into the conference.		 * However, we want to wait until the trunk has been dialed and the		 * conference is created before continuing on here. */		ast_autoservice_start(chan);		ast_mutex_init(&cond_lock);		ast_cond_init(&cond, NULL);		ast_mutex_lock(&cond_lock);		ast_pthread_create_detached_background(&dont_care, NULL, dial_trunk, &args);		ast_cond_wait(&cond, &cond_lock);		ast_mutex_unlock(&cond_lock);		ast_mutex_destroy(&cond_lock);		ast_cond_destroy(&cond);		ast_autoservice_stop(chan);		if (!trunk_ref->trunk->chan) {			ast_debug(1, "Trunk didn't get created. chan: %lx\n", (long) trunk_ref->trunk->chan);			pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "CONGESTION");			sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_IDLE, ALL_TRUNK_REFS, NULL);			trunk_ref->chan = NULL;			ast_atomic_fetchadd_int((int *) &station->ref_count, -1);			sla_queue_event(SLA_EVENT_CHECK_RELOAD);			return 0;		}	}
char *station_name, *trunk_name;
char *station_name, *trunk_name;
char
*station_name
*
station_name
*trunk_name
*
trunk_name
struct sla_station *station;
struct sla_station *station;
struct sla_station
sla_station
*station
*
station
struct sla_trunk_ref *trunk_ref = NULL;
struct sla_trunk_ref *trunk_ref = NULL;
struct sla_trunk_ref
sla_trunk_ref
*trunk_ref = NULL
*
trunk_ref
= NULL
NULL
NULL
char conf_name[MAX_CONFNUM];
char conf_name[MAX_CONFNUM];
char
conf_name[MAX_CONFNUM]
conf_name
[MAX_CONFNUM]
MAX_CONFNUM
MAX_CONFNUM
struct ast_flags64 conf_flags = { 0 };
struct ast_flags64 conf_flags = { 0 };
struct ast_flags64
ast_flags64
conf_flags = { 0 }
conf_flags
= { 0 }
{ 0 }
0
struct ast_conference *conf;
struct ast_conference *conf;
struct ast_conference
ast_conference
*conf
*
conf
if (ast_strlen_zero(data)) {		ast_log(LOG_WARNING, "Invalid Arguments to SLAStation!\n");		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE");		return 0;	}
ast_strlen_zero(data)
ast_strlen_zero
ast_strlen_zero
data
data
{		ast_log(LOG_WARNING, "Invalid Arguments to SLAStation!\n");		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE");		return 0;	}
ast_log(LOG_WARNING, "Invalid Arguments to SLAStation!\n");
ast_log(LOG_WARNING, "Invalid Arguments to SLAStation!\n")
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"Invalid Arguments to SLAStation!\n"
pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE");
pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE")
pbx_builtin_setvar_helper
pbx_builtin_setvar_helper
chan
chan
"SLASTATION_STATUS"
"FAILURE"
return 0;
0
trunk_name = ast_strdupa(data);
trunk_name = ast_strdupa(data)
trunk_name
trunk_name
ast_strdupa(data)
ast_strdupa
ast_strdupa
data
data
station_name = strsep(&trunk_name, "_");
station_name = strsep(&trunk_name, "_")
station_name
station_name
strsep(&trunk_name, "_")
strsep
strsep
&trunk_name
trunk_name
trunk_name
"_"
if (ast_strlen_zero(station_name)) {		ast_log(LOG_WARNING, "Invalid Arguments to SLAStation!\n");		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE");		return 0;	}
ast_strlen_zero(station_name)
ast_strlen_zero
ast_strlen_zero
station_name
station_name
{		ast_log(LOG_WARNING, "Invalid Arguments to SLAStation!\n");		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE");		return 0;	}
ast_log(LOG_WARNING, "Invalid Arguments to SLAStation!\n");
ast_log(LOG_WARNING, "Invalid Arguments to SLAStation!\n")
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"Invalid Arguments to SLAStation!\n"
pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE");
pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE")
pbx_builtin_setvar_helper
pbx_builtin_setvar_helper
chan
chan
"SLASTATION_STATUS"
"FAILURE"
return 0;
0
AST_RWLIST_RDLOCK(&sla_stations);
AST_RWLIST_RDLOCK(&sla_stations);
AST_RWLIST_RDLOCK
AST_RWLIST_RDLOCK
(&sla_stations)
&sla_stations
&
sla_stations
station = sla_find_station(station_name);
station = sla_find_station(station_name)
station
station
sla_find_station(station_name)
sla_find_station
sla_find_station
station_name
station_name
if (station)		ast_atomic_fetchadd_int((int *) &station->ref_count, 1);
station
station
ast_atomic_fetchadd_int((int *) &station->ref_count, 1);
ast_atomic_fetchadd_int((int *) &station->ref_count, 1)
ast_atomic_fetchadd_int
ast_atomic_fetchadd_int
(int *) &station->ref_count
int *
int
*
*
&station->ref_count
station->ref_count
station
station
ref_count
1
AST_RWLIST_UNLOCK(&sla_stations);
AST_RWLIST_UNLOCK(&sla_stations)
AST_RWLIST_UNLOCK
AST_RWLIST_UNLOCK
&sla_stations
sla_stations
sla_stations
if (!station) {		ast_log(LOG_WARNING, "Station '%s' not found!\n", station_name);		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE");		sla_queue_event(SLA_EVENT_CHECK_RELOAD);		return 0;	}
!station
station
station
{		ast_log(LOG_WARNING, "Station '%s' not found!\n", station_name);		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE");		sla_queue_event(SLA_EVENT_CHECK_RELOAD);		return 0;	}
ast_log(LOG_WARNING, "Station '%s' not found!\n", station_name);
ast_log(LOG_WARNING, "Station '%s' not found!\n", station_name)
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"Station '%s' not found!\n"
station_name
station_name
pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE");
pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE")
pbx_builtin_setvar_helper
pbx_builtin_setvar_helper
chan
chan
"SLASTATION_STATUS"
"FAILURE"
sla_queue_event(SLA_EVENT_CHECK_RELOAD);
sla_queue_event(SLA_EVENT_CHECK_RELOAD);
sla_queue_event
sla_queue_event
(SLA_EVENT_CHECK_RELOAD)
SLA_EVENT_CHECK_RELOAD
SLA_EVENT_CHECK_RELOAD
return 0;
0
AST_RWLIST_RDLOCK(&sla_trunks);
AST_RWLIST_RDLOCK(&sla_trunks);
AST_RWLIST_RDLOCK
AST_RWLIST_RDLOCK
(&sla_trunks)
&sla_trunks
&
sla_trunks
if (!ast_strlen_zero(trunk_name)) {		trunk_ref = sla_find_trunk_ref_byname(station, trunk_name);	} else		trunk_ref = sla_choose_idle_trunk(station);
!ast_strlen_zero(trunk_name)
ast_strlen_zero(trunk_name)
ast_strlen_zero
ast_strlen_zero
trunk_name
trunk_name
{		trunk_ref = sla_find_trunk_ref_byname(station, trunk_name);	}
trunk_ref = sla_find_trunk_ref_byname(station, trunk_name);
trunk_ref = sla_find_trunk_ref_byname(station, trunk_name)
trunk_ref
trunk_ref
sla_find_trunk_ref_byname(station, trunk_name)
sla_find_trunk_ref_byname
sla_find_trunk_ref_byname
station
station
trunk_name
trunk_name
trunk_ref = sla_choose_idle_trunk(station);
trunk_ref = sla_choose_idle_trunk(station)
trunk_ref
trunk_ref
sla_choose_idle_trunk(station)
sla_choose_idle_trunk
sla_choose_idle_trunk
station
station
AST_RWLIST_UNLOCK(&sla_trunks);
AST_RWLIST_UNLOCK(&sla_trunks)
AST_RWLIST_UNLOCK
AST_RWLIST_UNLOCK
&sla_trunks
sla_trunks
sla_trunks
if (!trunk_ref) {		if (ast_strlen_zero(trunk_name))			ast_log(LOG_NOTICE, "No trunks available for call.\n");		else {			ast_log(LOG_NOTICE, "Can't join existing call on trunk "				"'%s' due to access controls.\n", trunk_name);		}		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "CONGESTION");		ast_atomic_fetchadd_int((int *) &station->ref_count, -1);		sla_queue_event(SLA_EVENT_CHECK_RELOAD);		return 0;	}
!trunk_ref
trunk_ref
trunk_ref
{		if (ast_strlen_zero(trunk_name))			ast_log(LOG_NOTICE, "No trunks available for call.\n");		else {			ast_log(LOG_NOTICE, "Can't join existing call on trunk "				"'%s' due to access controls.\n", trunk_name);		}		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "CONGESTION");		ast_atomic_fetchadd_int((int *) &station->ref_count, -1);		sla_queue_event(SLA_EVENT_CHECK_RELOAD);		return 0;	}
if (ast_strlen_zero(trunk_name))			ast_log(LOG_NOTICE, "No trunks available for call.\n");		else {			ast_log(LOG_NOTICE, "Can't join existing call on trunk "				"'%s' due to access controls.\n", trunk_name);		}
ast_strlen_zero(trunk_name)
ast_strlen_zero
ast_strlen_zero
trunk_name
trunk_name
ast_log(LOG_NOTICE, "No trunks available for call.\n");
ast_log(LOG_NOTICE, "No trunks available for call.\n")
ast_log
ast_log
LOG_NOTICE
LOG_NOTICE
"No trunks available for call.\n"
{			ast_log(LOG_NOTICE, "Can't join existing call on trunk "				"'%s' due to access controls.\n", trunk_name);		}
ast_log(LOG_NOTICE, "Can't join existing call on trunk "				"'%s' due to access controls.\n", trunk_name);
ast_log(LOG_NOTICE, "Can't join existing call on trunk "				"'%s' due to access controls.\n", trunk_name)
ast_log
ast_log
LOG_NOTICE
LOG_NOTICE
"Can't join existing call on trunk "				"'%s' due to access controls.\n"
trunk_name
trunk_name
pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "CONGESTION");
pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "CONGESTION")
pbx_builtin_setvar_helper
pbx_builtin_setvar_helper
chan
chan
"SLASTATION_STATUS"
"CONGESTION"
ast_atomic_fetchadd_int((int *) &station->ref_count, -1);
ast_atomic_fetchadd_int((int *) &station->ref_count, -1)
ast_atomic_fetchadd_int
ast_atomic_fetchadd_int
(int *) &station->ref_count
int *
int
*
*
&station->ref_count
station->ref_count
station
station
ref_count
-1
1
sla_queue_event(SLA_EVENT_CHECK_RELOAD);
sla_queue_event(SLA_EVENT_CHECK_RELOAD);
sla_queue_event
sla_queue_event
(SLA_EVENT_CHECK_RELOAD)
SLA_EVENT_CHECK_RELOAD
SLA_EVENT_CHECK_RELOAD
return 0;
0
if (trunk_ref->state == SLA_TRUNK_STATE_ONHOLD_BYME) {		if (ast_atomic_dec_and_test((int *) &trunk_ref->trunk->hold_stations) == 1)			sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);		else {			trunk_ref->state = SLA_TRUNK_STATE_UP;			ast_devstate_changed(AST_DEVICE_INUSE, AST_DEVSTATE_CACHABLE,					     "SLA:%s_%s", station->name, trunk_ref->trunk->name);		}	} else if (trunk_ref->state == SLA_TRUNK_STATE_RINGING) {		struct sla_ringing_trunk *ringing_trunk;		ast_mutex_lock(&sla.lock);		AST_LIST_TRAVERSE_SAFE_BEGIN(&sla.ringing_trunks, ringing_trunk, entry) {			if (ringing_trunk->trunk == trunk_ref->trunk) {				AST_LIST_REMOVE_CURRENT(entry);				break;			}		}		AST_LIST_TRAVERSE_SAFE_END		ast_mutex_unlock(&sla.lock);		if (ringing_trunk) {			answer_trunk_chan(ringing_trunk->trunk->chan);			sla_change_trunk_state(ringing_trunk->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);			free(ringing_trunk);			/* Queue up reprocessing ringing trunks, and then ringing stations again */			sla_queue_event(SLA_EVENT_RINGING_TRUNK);			sla_queue_event(SLA_EVENT_DIAL_STATE);		}	}
trunk_ref->state == SLA_TRUNK_STATE_ONHOLD_BYME
trunk_ref->state
trunk_ref
trunk_ref
state
SLA_TRUNK_STATE_ONHOLD_BYME
SLA_TRUNK_STATE_ONHOLD_BYME
{		if (ast_atomic_dec_and_test((int *) &trunk_ref->trunk->hold_stations) == 1)			sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);		else {			trunk_ref->state = SLA_TRUNK_STATE_UP;			ast_devstate_changed(AST_DEVICE_INUSE, AST_DEVSTATE_CACHABLE,					     "SLA:%s_%s", station->name, trunk_ref->trunk->name);		}	}
if (ast_atomic_dec_and_test((int *) &trunk_ref->trunk->hold_stations) == 1)			sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);		else {			trunk_ref->state = SLA_TRUNK_STATE_UP;			ast_devstate_changed(AST_DEVICE_INUSE, AST_DEVSTATE_CACHABLE,					     "SLA:%s_%s", station->name, trunk_ref->trunk->name);		}
ast_atomic_dec_and_test((int *) &trunk_ref->trunk->hold_stations) == 1
ast_atomic_dec_and_test((int *) &trunk_ref->trunk->hold_stations)
ast_atomic_dec_and_test
ast_atomic_dec_and_test
(int *) &trunk_ref->trunk->hold_stations
int *
int
*
*
&trunk_ref->trunk->hold_stations
trunk_ref->trunk->hold_stations
trunk_ref->trunk
trunk_ref
trunk_ref
trunk
hold_stations
1
sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);
sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL)
sla_change_trunk_state
sla_change_trunk_state
trunk_ref->trunk
trunk_ref
trunk_ref
trunk
SLA_TRUNK_STATE_UP
SLA_TRUNK_STATE_UP
ALL_TRUNK_REFS
ALL_TRUNK_REFS
NULL
NULL
{			trunk_ref->state = SLA_TRUNK_STATE_UP;			ast_devstate_changed(AST_DEVICE_INUSE, AST_DEVSTATE_CACHABLE,					     "SLA:%s_%s", station->name, trunk_ref->trunk->name);		}
trunk_ref->state = SLA_TRUNK_STATE_UP;
trunk_ref->state = SLA_TRUNK_STATE_UP
trunk_ref->state
trunk_ref
trunk_ref
state
SLA_TRUNK_STATE_UP
SLA_TRUNK_STATE_UP
ast_devstate_changed(AST_DEVICE_INUSE, AST_DEVSTATE_CACHABLE,					     "SLA:%s_%s", station->name, trunk_ref->trunk->name);
ast_devstate_changed(AST_DEVICE_INUSE, AST_DEVSTATE_CACHABLE,					     "SLA:%s_%s", station->name, trunk_ref->trunk->name)
ast_devstate_changed
ast_devstate_changed
AST_DEVICE_INUSE
AST_DEVICE_INUSE
AST_DEVSTATE_CACHABLE
AST_DEVSTATE_CACHABLE
"SLA:%s_%s"
station->name
station
station
name
trunk_ref->trunk->name
trunk_ref->trunk
trunk_ref
trunk_ref
trunk
name
if (trunk_ref->state == SLA_TRUNK_STATE_RINGING) {		struct sla_ringing_trunk *ringing_trunk;		ast_mutex_lock(&sla.lock);		AST_LIST_TRAVERSE_SAFE_BEGIN(&sla.ringing_trunks, ringing_trunk, entry) {			if (ringing_trunk->trunk == trunk_ref->trunk) {				AST_LIST_REMOVE_CURRENT(entry);				break;			}		}		AST_LIST_TRAVERSE_SAFE_END		ast_mutex_unlock(&sla.lock);		if (ringing_trunk) {			answer_trunk_chan(ringing_trunk->trunk->chan);			sla_change_trunk_state(ringing_trunk->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);			free(ringing_trunk);			/* Queue up reprocessing ringing trunks, and then ringing stations again */			sla_queue_event(SLA_EVENT_RINGING_TRUNK);			sla_queue_event(SLA_EVENT_DIAL_STATE);		}	}
trunk_ref->state == SLA_TRUNK_STATE_RINGING
trunk_ref->state
trunk_ref
trunk_ref
state
SLA_TRUNK_STATE_RINGING
SLA_TRUNK_STATE_RINGING
{		struct sla_ringing_trunk *ringing_trunk;		ast_mutex_lock(&sla.lock);		AST_LIST_TRAVERSE_SAFE_BEGIN(&sla.ringing_trunks, ringing_trunk, entry) {			if (ringing_trunk->trunk == trunk_ref->trunk) {				AST_LIST_REMOVE_CURRENT(entry);				break;			}		}		AST_LIST_TRAVERSE_SAFE_END		ast_mutex_unlock(&sla.lock);		if (ringing_trunk) {			answer_trunk_chan(ringing_trunk->trunk->chan);			sla_change_trunk_state(ringing_trunk->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);			free(ringing_trunk);			/* Queue up reprocessing ringing trunks, and then ringing stations again */			sla_queue_event(SLA_EVENT_RINGING_TRUNK);			sla_queue_event(SLA_EVENT_DIAL_STATE);		}	}
struct sla_ringing_trunk *ringing_trunk;
struct sla_ringing_trunk *ringing_trunk;
struct sla_ringing_trunk
sla_ringing_trunk
*ringing_trunk
*
ringing_trunk
ast_mutex_lock(&sla.lock);
ast_mutex_lock(&sla.lock)
ast_mutex_lock
ast_mutex_lock
&sla.lock
sla.lock
sla
sla
lock
AST_LIST_TRAVERSE_SAFE_BEGIN(&sla.ringing_trunks, ringing_trunk, entry)
AST_LIST_TRAVERSE_SAFE_BEGIN(&sla.ringing_trunks, ringing_trunk, entry)
AST_LIST_TRAVERSE_SAFE_BEGIN
AST_LIST_TRAVERSE_SAFE_BEGIN
&sla.ringing_trunks
sla.ringing_trunks
sla
sla
ringing_trunks
ringing_trunk
ringing_trunk
entry
entry
)
{			if (ringing_trunk->trunk == trunk_ref->trunk) {				AST_LIST_REMOVE_CURRENT(entry);				break;			}		}
if (ringing_trunk->trunk == trunk_ref->trunk) {				AST_LIST_REMOVE_CURRENT(entry);				break;			}
ringing_trunk->trunk == trunk_ref->trunk
ringing_trunk->trunk
ringing_trunk
ringing_trunk
trunk
trunk_ref->trunk
trunk_ref
trunk_ref
trunk
{				AST_LIST_REMOVE_CURRENT(entry);				break;			}
AST_LIST_REMOVE_CURRENT(entry);
AST_LIST_REMOVE_CURRENT(entry);
AST_LIST_REMOVE_CURRENT
AST_LIST_REMOVE_CURRENT
(entry)
entry
entry
break;
AST_LIST_TRAVERSE_SAFE_END		ast_mutex_unlock(&sla.lock);
AST_LIST_TRAVERSE_SAFE_END		ast_mutex_unlock(&sla.lock);
AST_LIST_TRAVERSE_SAFE_END
AST_LIST_TRAVERSE_SAFE_END
ast_mutex_unlock(&sla.lock)
ast_mutex_unlock
(&sla.lock)
&sla.lock
sla.lock
sla
sla
lock
if (ringing_trunk) {			answer_trunk_chan(ringing_trunk->trunk->chan);			sla_change_trunk_state(ringing_trunk->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);			free(ringing_trunk);			/* Queue up reprocessing ringing trunks, and then ringing stations again */			sla_queue_event(SLA_EVENT_RINGING_TRUNK);			sla_queue_event(SLA_EVENT_DIAL_STATE);		}
ringing_trunk
ringing_trunk
{			answer_trunk_chan(ringing_trunk->trunk->chan);			sla_change_trunk_state(ringing_trunk->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);			free(ringing_trunk);			/* Queue up reprocessing ringing trunks, and then ringing stations again */			sla_queue_event(SLA_EVENT_RINGING_TRUNK);			sla_queue_event(SLA_EVENT_DIAL_STATE);		}
answer_trunk_chan(ringing_trunk->trunk->chan);
answer_trunk_chan(ringing_trunk->trunk->chan)
answer_trunk_chan
answer_trunk_chan
ringing_trunk->trunk->chan
ringing_trunk->trunk
ringing_trunk
ringing_trunk
trunk
chan
sla_change_trunk_state(ringing_trunk->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);
sla_change_trunk_state(ringing_trunk->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL)
sla_change_trunk_state
sla_change_trunk_state
ringing_trunk->trunk
ringing_trunk
ringing_trunk
trunk
SLA_TRUNK_STATE_UP
SLA_TRUNK_STATE_UP
ALL_TRUNK_REFS
ALL_TRUNK_REFS
NULL
NULL
free(ringing_trunk);
free(ringing_trunk)
free
free
ringing_trunk
ringing_trunk
sla_queue_event(SLA_EVENT_RINGING_TRUNK);
sla_queue_event(SLA_EVENT_RINGING_TRUNK);
sla_queue_event
sla_queue_event
(SLA_EVENT_RINGING_TRUNK)
SLA_EVENT_RINGING_TRUNK
SLA_EVENT_RINGING_TRUNK
sla_queue_event(SLA_EVENT_DIAL_STATE);
sla_queue_event(SLA_EVENT_DIAL_STATE);
sla_queue_event
sla_queue_event
(SLA_EVENT_DIAL_STATE)
SLA_EVENT_DIAL_STATE
SLA_EVENT_DIAL_STATE
trunk_ref->chan = chan;
trunk_ref->chan = chan
trunk_ref->chan
trunk_ref
trunk_ref
chan
chan
chan
if (!trunk_ref->trunk->chan) {		ast_mutex_t cond_lock;		ast_cond_t cond;		pthread_t dont_care;		struct dial_trunk_args args = {			.trunk_ref = trunk_ref,			.station = station,			.cond_lock = &cond_lock,			.cond = &cond,		}
!trunk_ref->trunk->chan
trunk_ref->trunk->chan
trunk_ref->trunk
trunk_ref
trunk_ref
trunk
chan
{		ast_mutex_t cond_lock;		ast_cond_t cond;		pthread_t dont_care;		struct dial_trunk_args args = {			.trunk_ref = trunk_ref,			.station = station,			.cond_lock = &cond_lock,			.cond = &cond,		}
ast_mutex_t cond_lock;
ast_mutex_t cond_lock;
ast_mutex_t
ast_mutex_t
cond_lock
cond_lock
ast_cond_t cond;
ast_cond_t cond;
ast_cond_t
ast_cond_t
cond
cond
pthread_t dont_care;
pthread_t dont_care;
pthread_t
pthread_t
dont_care
dont_care
struct dial_trunk_args args = {			.trunk_ref = trunk_ref,			.station = station,			.cond_lock = &cond_lock,			.cond = &cond,
;
sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);
sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL)
sla_change_trunk_state
sla_change_trunk_state
trunk_ref->trunk
trunk_ref
trunk_ref
trunk
SLA_TRUNK_STATE_UP
SLA_TRUNK_STATE_UP
ALL_TRUNK_REFS
ALL_TRUNK_REFS
NULL
NULL
ast_autoservice_start(chan);
ast_autoservice_start(chan)
ast_autoservice_start
ast_autoservice_start
chan
chan
ast_mutex_init(&cond_lock);
ast_mutex_init(&cond_lock);
ast_mutex_init
ast_mutex_init
(&cond_lock)
&cond_lock
&
cond_lock
ast_cond_init(&cond, NULL);
ast_cond_init(&cond, NULL)
ast_cond_init
ast_cond_init
&cond
cond
cond
NULL
NULL
ast_mutex_lock(&cond_lock);
ast_mutex_lock(&cond_lock)
ast_mutex_lock
ast_mutex_lock
&cond_lock
cond_lock
cond_lock
ast_pthread_create_detached_background(&dont_care, NULL, dial_trunk, &args);
ast_pthread_create_detached_background(&dont_care, NULL, dial_trunk, &args)
ast_pthread_create_detached_background
ast_pthread_create_detached_background
&dont_care
dont_care
dont_care
NULL
NULL
dial_trunk
dial_trunk
&args
args
args
ast_cond_wait(&cond, &cond_lock);
ast_cond_wait(&cond, &cond_lock)
ast_cond_wait
ast_cond_wait
&cond
cond
cond
&cond_lock
cond_lock
cond_lock
ast_mutex_unlock(&cond_lock);
ast_mutex_unlock(&cond_lock)
ast_mutex_unlock
ast_mutex_unlock
&cond_lock
cond_lock
cond_lock
ast_mutex_destroy(&cond_lock);
ast_mutex_destroy(&cond_lock)
ast_mutex_destroy
ast_mutex_destroy
&cond_lock
cond_lock
cond_lock
ast_cond_destroy(&cond);
ast_cond_destroy(&cond);
ast_cond_destroy
ast_cond_destroy
(&cond)
&cond
&
cond
ast_autoservice_stop(chan);
ast_autoservice_stop(chan)
ast_autoservice_stop
ast_autoservice_stop
chan
chan
if (!trunk_ref->trunk->chan) {			ast_debug(1, "Trunk didn't get created. chan: %lx\n", (long) trunk_ref->trunk->chan);			pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "CONGESTION");			sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_IDLE, ALL_TRUNK_REFS, NULL);			trunk_ref->chan = NULL;			ast_atomic_fetchadd_int((int *) &station->ref_count, -1);			sla_queue_event(SLA_EVENT_CHECK_RELOAD);			return 0;		}
!trunk_ref->trunk->chan
trunk_ref->trunk->chan
trunk_ref->trunk
trunk_ref
trunk_ref
trunk
chan
{			ast_debug(1, "Trunk didn't get created. chan: %lx\n", (long) trunk_ref->trunk->chan);			pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "CONGESTION");			sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_IDLE, ALL_TRUNK_REFS, NULL);			trunk_ref->chan = NULL;			ast_atomic_fetchadd_int((int *) &station->ref_count, -1);			sla_queue_event(SLA_EVENT_CHECK_RELOAD);			return 0;		}
ast_debug(1, "Trunk didn't get created. chan: %lx\n", (long) trunk_ref->trunk->chan);
ast_debug(1, "Trunk didn't get created. chan: %lx\n", (long) trunk_ref->trunk->chan)
ast_debug
ast_debug
1
"Trunk didn't get created. chan: %lx\n"
(long) trunk_ref->trunk->chan
long
long

trunk_ref->trunk->chan
trunk_ref->trunk
trunk_ref
trunk_ref
trunk
chan
pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "CONGESTION");
pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "CONGESTION")
pbx_builtin_setvar_helper
pbx_builtin_setvar_helper
chan
chan
"SLASTATION_STATUS"
"CONGESTION"
sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_IDLE, ALL_TRUNK_REFS, NULL);
sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_IDLE, ALL_TRUNK_REFS, NULL)
sla_change_trunk_state
sla_change_trunk_state
trunk_ref->trunk
trunk_ref
trunk_ref
trunk
SLA_TRUNK_STATE_IDLE
SLA_TRUNK_STATE_IDLE
ALL_TRUNK_REFS
ALL_TRUNK_REFS
NULL
NULL
trunk_ref->chan = NULL;
trunk_ref->chan = NULL
trunk_ref->chan
trunk_ref
trunk_ref
chan
NULL
NULL
ast_atomic_fetchadd_int((int *) &station->ref_count, -1);
ast_atomic_fetchadd_int((int *) &station->ref_count, -1)
ast_atomic_fetchadd_int
ast_atomic_fetchadd_int
(int *) &station->ref_count
int *
int
*
*
&station->ref_count
station->ref_count
station
station
ref_count
-1
1
sla_queue_event(SLA_EVENT_CHECK_RELOAD);
sla_queue_event(SLA_EVENT_CHECK_RELOAD);
sla_queue_event
sla_queue_event
(SLA_EVENT_CHECK_RELOAD)
SLA_EVENT_CHECK_RELOAD
SLA_EVENT_CHECK_RELOAD
return 0;
0
-----joern-----
(455,331,0)
(334,135,0)
(332,235,0)
(0,283,0)
(370,27,0)
(362,43,0)
(339,259,0)
(112,160,0)
(139,41,0)
(192,56,0)
(183,19,0)
(438,483,0)
(364,145,0)
(412,5,0)
(55,372,0)
(231,481,0)
(277,114,0)
(188,211,0)
(406,372,0)
(75,314,0)
(138,280,0)
(157,372,0)
(404,348,0)
(275,486,0)
(300,372,0)
(297,172,0)
(481,318,0)
(398,47,0)
(330,206,0)
(485,100,0)
(457,307,0)
(213,334,0)
(324,64,0)
(33,374,0)
(336,128,0)
(395,359,0)
(344,370,0)
(364,300,0)
(180,153,0)
(28,186,0)
(474,325,0)
(296,235,0)
(328,280,0)
(130,272,0)
(80,487,0)
(164,255,0)
(365,91,0)
(489,19,0)
(41,90,0)
(13,424,0)
(81,372,0)
(482,102,0)
(426,153,0)
(160,335,0)
(310,421,0)
(229,419,0)
(348,323,0)
(273,468,0)
(384,372,0)
(427,245,0)
(96,390,0)
(27,71,0)
(357,142,0)
(407,280,0)
(470,14,0)
(7,391,0)
(349,47,0)
(479,240,0)
(75,411,0)
(386,448,0)
(223,307,0)
(236,414,0)
(307,76,0)
(290,318,0)
(353,31,0)
(319,41,0)
(392,268,0)
(451,354,0)
(121,279,0)
(292,136,0)
(333,313,0)
(459,253,0)
(390,280,0)
(437,150,0)
(174,150,0)
(243,36,0)
(176,283,0)
(23,267,0)
(191,280,0)
(451,41,0)
(425,31,0)
(309,386,0)
(72,43,0)
(32,160,0)
(172,41,0)
(454,414,0)
(237,96,0)
(178,344,0)
(326,152,0)
(488,35,0)
(250,37,0)
(120,97,0)
(399,320,0)
(57,76,0)
(76,280,0)
(323,354,0)
(270,304,0)
(118,280,0)
(322,242,0)
(469,145,0)
(249,483,0)
(378,300,0)
(351,293,0)
(102,414,0)
(141,126,0)
(260,372,0)
(144,313,0)
(391,335,0)
(307,47,0)
(467,105,0)
(323,348,0)
(71,41,0)
(210,22,0)
(216,172,0)
(127,41,0)
(222,64,0)
(205,349,0)
(174,47,0)
(315,153,0)
(57,282,0)
(404,278,0)
(402,361,0)
(37,250,0)
(355,433,0)
(240,387,0)
(262,157,0)
(108,150,0)
(217,275,0)
(308,384,0)
(145,312,0)
(52,472,0)
(383,380,0)
(138,167,0)
(65,259,0)
(298,280,0)
(313,431,0)
(44,310,0)
(333,224,0)
(319,372,0)
(422,280,0)
(276,357,0)
(128,486,0)
(438,41,0)
(70,435,0)
(247,397,0)
(260,41,0)
(477,314,0)
(431,313,0)
(268,108,0)
(122,280,0)
(116,12,0)
(363,124,0)
(142,357,0)
(38,411,0)
(101,215,0)
(450,66,0)
(359,44,0)
(370,280,0)
(172,216,0)
(412,150,0)
(421,486,0)
(101,470,0)
(214,382,0)
(292,255,0)
(182,15,0)
(157,116,0)
(88,97,0)
(54,400,0)
(168,398,0)
(71,27,0)
(215,319,0)
(458,433,0)
(36,372,0)
(417,41,0)
(354,323,0)
(220,280,0)
(158,451,0)
(186,28,0)
(169,459,0)
(219,307,0)
(166,97,0)
(221,202,0)
(10,71,0)
(124,280,0)
(487,449,0)
(24,404,0)
(50,83,0)
(28,441,0)
(384,142,0)
(406,41,0)
(21,5,0)
(483,438,0)
(26,150,0)
(424,313,0)
(173,100,0)
(274,258,0)
(471,36,0)
(117,280,0)
(283,372,0)
(418,127,0)
(325,474,0)
(102,435,0)
(155,66,0)
(467,373,0)
(448,150,0)
(232,372,0)
(74,141,0)
(255,130,0)
(145,364,0)
(56,412,0)
(64,76,0)
(217,75,0)
(105,467,0)
(359,313,0)
(341,91,0)
(45,320,0)
(444,220,0)
(444,397,0)
(305,29,0)
(420,150,0)
(313,280,0)
(380,35,0)
(31,425,0)
(373,467,0)
(212,438,0)
(382,135,0)
(217,102,0)
(251,472,0)
(156,466,0)
(406,481,0)
(58,152,0)
(66,47,0)
(164,329,0)
(463,406,0)
(278,404,0)
(195,303,0)
(252,110,0)
(419,220,0)
(243,391,0)
(75,435,0)
(303,109,0)
(458,41,0)
(235,47,0)
(97,135,0)
(393,435,0)
(310,453,0)
(89,388,0)
(397,444,0)
(19,183,0)
(160,283,0)
(408,130,0)
(204,41,0)
(366,331,0)
(428,280,0)
(15,41,0)
(461,150,0)
(172,372,0)
(102,243,0)
(267,109,0)
(136,390,0)
(306,163,0)
(119,144,0)
(102,293,0)
(356,417,0)
(293,238,0)
(217,377,0)
(380,472,0)
(258,459,0)
(4,183,0)
(16,57,0)
(459,258,0)
(127,372,0)
(131,196,0)
(60,139,0)
(196,461,0)
(410,280,0)
(129,15,0)
(100,485,0)
(314,41,0)
(39,157,0)
(468,273,0)
(449,487,0)
(490,52,0)
(108,268,0)
(291,164,0)
(401,421,0)
(98,372,0)
(445,52,0)
(253,139,0)
(239,349,0)
(264,357,0)
(97,374,0)
(468,34,0)
(306,234,0)
(226,280,0)
(151,41,0)
(390,136,0)
(278,201,0)
(36,41,0)
(266,434,0)
(254,420,0)
(314,372,0)
(420,47,0)
(110,368,0)
(304,37,0)
(438,372,0)
(354,451,0)
(208,172,0)
(361,472,0)
(145,126,0)
(171,238,0)
(288,235,0)
(470,95,0)
(199,145,0)
(143,304,0)
(217,303,0)
(61,280,0)
(54,251,0)
(431,390,0)
(104,348,0)
(12,116,0)
(92,147,0)
(384,41,0)
(218,127,0)
(207,28,0)
(200,381,0)
(36,243,0)
(35,380,0)
(52,47,0)
(439,55,0)
(483,29,0)
(83,417,0)
(106,260,0)
(376,251,0)
(459,169,0)
(256,98,0)
(435,372,0)
(281,64,0)
(116,157,0)
(487,260,0)
(224,333,0)
(447,53,0)
(194,255,0)
(287,352,0)
(377,115,0)
(11,312,0)
(91,150,0)
(372,98,0)
(132,150,0)
(86,147,0)
(15,293,0)
(209,64,0)
(295,280,0)
(19,150,0)
(325,280,0)
(55,41,0)
(464,384,0)
(452,431,0)
(29,483,0)
(40,64,0)
(260,487,0)
(2,359,0)
(253,459,0)
(245,6,0)
(152,127,0)
(312,145,0)
(139,253,0)
(385,47,0)
(139,372,0)
(159,481,0)
(227,64,0)
(307,455,0)
(426,468,0)
(123,96,0)
(441,41,0)
(414,372,0)
(211,47,0)
(244,290,0)
(263,280,0)
(245,255,0)
(345,253,0)
(114,115,0)
(414,117,0)
(27,370,0)
(300,41,0)
(8,36,0)
(72,37,0)
(133,380,0)
(3,117,0)
(49,282,0)
(84,75,0)
(242,313,0)
(468,426,0)
(261,472,0)
(201,278,0)
(451,372,0)
(225,381,0)
(348,404,0)
(448,386,0)
(491,280,0)
(96,115,0)
(190,216,0)
(44,359,0)
(113,136,0)
(35,41,0)
(414,41,0)
(241,320,0)
(258,472,0)
(251,376,0)
(29,335,0)
(466,272,0)
(185,167,0)
(242,163,0)
(153,313,0)
(51,319,0)
(476,491,0)
(400,54,0)
(125,232,0)
(98,313,0)
(235,115,0)
(367,232,0)
(95,186,0)
(312,313,0)
(66,109,0)
(413,381,0)
(436,333,0)
(421,401,0)
(491,476,0)
(206,280,0)
(144,41,0)
(79,417,0)
(455,307,0)
(41,144,0)
(55,165,0)
(411,372,0)
(157,41,0)
(327,116,0)
(82,476,0)
(259,65,0)
(134,160,0)
(15,372,0)
(269,425,0)
(465,280,0)
(358,267,0)
(63,243,0)
(187,441,0)
(331,280,0)
(111,380,0)
(317,211,0)
(9,433,0)
(325,306,0)
(415,258,0)
(456,242,0)
(238,318,0)
(368,150,0)
(105,83,0)
(349,203,0)
(347,441,0)
(186,95,0)
(42,124,0)
(161,486,0)
(413,45,0)
(368,110,0)
(458,372,0)
(220,419,0)
(321,139,0)
(441,372,0)
(184,52,0)
(286,191,0)
(233,211,0)
(371,370,0)
(460,300,0)
(37,72,0)
(147,397,0)
(255,280,0)
(412,56,0)
(453,310,0)
(85,451,0)
(68,165,0)
(198,275,0)
(177,280,0)
(54,224,0)
(385,280,0)
(14,470,0)
(197,444,0)
(149,312,0)
(248,66,0)
(91,232,0)
(435,41,0)
(31,150,0)
(294,174,0)
(302,27,0)
(338,26,0)
(69,71,0)
(22,135,0)
(389,377,0)
(419,331,0)
(35,372,0)
(211,486,0)
(435,385,0)
(307,282,0)
(71,372,0)
(481,406,0)
(480,385,0)
(25,144,0)
(411,261,0)
(179,438,0)
(43,72,0)
(442,273,0)
(12,278,0)
(204,372,0)
(285,375,0)
(94,72,0)
(374,97,0)
(170,261,0)
(37,304,0)
(310,44,0)
(5,412,0)
(289,434,0)
(461,196,0)
(217,53,0)
(396,31,0)
(440,390,0)
(375,285,0)
(430,374,0)
(202,31,0)
(421,310,0)
(343,411,0)
(175,255,0)
(265,150,0)
(163,242,0)
(163,306,0)
(17,455,0)
(127,152,0)
(62,364,0)
(213,434,0)
(485,280,0)
(467,285,0)
(271,290,0)
(142,384,0)
(102,280,0)
(95,470,0)
(314,141,0)
(48,370,0)
(446,390,0)
(103,401,0)
(232,91,0)
(411,41,0)
(316,257,0)
(154,381,0)
(130,255,0)
(181,145,0)
(220,444,0)
(346,150,0)
(470,101,0)
(304,318,0)
(434,213,0)
(403,91,0)
(293,15,0)
(45,413,0)
(409,280,0)
(360,280,0)
(394,349,0)
(416,250,0)
(83,105,0)
(417,83,0)
(18,406,0)
(137,313,0)
(148,213,0)
(342,446,0)
(311,124,0)
(405,164,0)
(76,64,0)
(370,344,0)
(350,154,0)
(146,35,0)
(140,314,0)
(78,458,0)
(136,292,0)
(73,150,0)
(65,280,0)
(441,28,0)
(189,164,0)
(228,55,0)
(301,458,0)
(232,41,0)
(299,376,0)
(257,135,0)
(433,458,0)
(246,388,0)
(93,204,0)
(397,147,0)
(484,292,0)
(26,338,0)
(215,101,0)
(306,325,0)
(153,426,0)
(167,138,0)
(379,319,0)
(441,141,0)
(462,280,0)
(75,472,0)
(337,49,0)
(31,202,0)
(64,47,0)
(278,12,0)
(478,481,0)
(124,47,0)
(6,245,0)
(319,215,0)
(473,338,0)
(423,260,0)
(107,381,0)
(432,387,0)
(283,41,0)
(46,375,0)
(87,333,0)
(429,64,0)
(77,96,0)
(99,279,0)
(417,372,0)
(334,213,0)
(224,54,0)
(67,49,0)
(283,160,0)
(59,474,0)
(340,215,0)
(285,467,0)
(53,203,0)
(433,355,0)
(230,64,0)
(369,152,0)
(234,306,0)
(20,194,0)
(475,280,0)
(320,45,0)
(300,364,0)
(144,255,0)
(193,354,0)
(102,314,0)
(279,203,0)
(165,55,0)
(284,76,0)
(398,280,0)
(251,54,0)
(443,191,0)
(34,468,0)
(194,255,1)
(439,228,1)
(29,305,1)
(98,313,1)
(71,372,1)
(414,41,1)
(323,354,1)
(290,271,1)
(429,284,1)
(70,145,1)
(464,308,1)
(317,188,1)
(401,103,1)
(172,41,1)
(274,415,1)
(312,11,1)
(411,372,1)
(362,250,1)
(463,18,1)
(145,364,1)
(383,35,1)
(83,50,1)
(80,260,1)
(417,41,1)
(156,331,1)
(215,319,1)
(412,56,1)
(35,488,1)
(153,315,1)
(25,119,1)
(385,480,1)
(417,356,1)
(477,140,1)
(127,41,1)
(167,185,1)
(72,94,1)
(170,411,1)
(459,253,1)
(273,468,1)
(388,89,1)
(285,467,1)
(211,47,1)
(152,127,1)
(147,86,1)
(250,416,1)
(230,40,1)
(266,289,1)
(479,142,1)
(371,344,1)
(214,22,1)
(232,125,1)
(365,403,1)
(467,373,1)
(40,227,1)
(27,302,1)
(319,372,1)
(406,372,1)
(431,452,1)
(434,266,1)
(231,406,1)
(267,358,1)
(307,47,1)
(138,167,1)
(436,87,1)
(399,165,1)
(424,313,1)
(9,458,1)
(16,307,1)
(256,81,1)
(438,372,1)
(470,14,1)
(300,41,1)
(433,9,1)
(490,184,1)
(204,93,1)
(458,372,1)
(94,43,1)
(279,121,1)
(283,372,1)
(242,322,1)
(235,332,1)
(11,149,1)
(394,279,1)
(165,55,1)
(210,257,1)
(145,312,1)
(185,372,1)
(403,341,1)
(408,175,1)
(217,275,1)
(102,435,1)
(190,172,1)
(102,314,1)
(413,45,1)
(366,191,1)
(102,414,1)
(398,168,1)
(229,370,1)
(356,79,1)
(217,102,1)
(319,41,1)
(27,71,1)
(206,330,1)
(293,15,1)
(258,459,1)
(423,385,1)
(471,8,1)
(56,192,1)
(269,368,1)
(77,424,1)
(241,399,1)
(13,485,1)
(176,29,1)
(441,41,1)
(0,176,1)
(440,255,1)
(75,435,1)
(69,10,1)
(71,41,1)
(78,174,1)
(488,146,1)
(415,355,1)
(95,470,1)
(208,204,1)
(419,229,1)
(60,274,1)
(217,53,1)
(212,179,1)
(406,41,1)
(220,419,1)
(144,25,1)
(245,255,1)
(164,291,1)
(412,5,1)
(48,323,1)
(54,400,1)
(326,369,1)
(438,41,1)
(333,436,1)
(460,378,1)
(445,258,1)
(374,430,1)
(260,106,1)
(140,375,1)
(392,412,1)
(306,163,1)
(197,419,1)
(441,187,1)
(316,97,1)
(100,173,1)
(83,417,1)
(74,314,1)
(70,382,1)
(341,232,1)
(405,189,1)
(354,451,1)
(157,262,1)
(380,35,1)
(183,4,1)
(359,395,1)
(253,345,1)
(342,390,1)
(37,250,1)
(483,249,1)
(215,340,1)
(284,398,1)
(260,372,1)
(237,77,1)
(421,310,1)
(364,62,1)
(301,78,1)
(141,74,1)
(180,30,1)
(144,313,1)
(54,224,1)
(6,245,1)
(338,473,1)
(84,361,1)
(349,205,1)
(36,372,1)
(396,353,1)
(117,3,1)
(124,47,1)
(1,432,1)
(344,178,1)
(64,209,1)
(146,52,1)
(311,481,1)
(96,390,1)
(213,148,1)
(193,451,1)
(15,372,1)
(7,243,1)
(446,342,1)
(325,306,1)
(137,65,1)
(307,76,1)
(220,444,1)
(66,450,1)
(120,88,1)
(478,231,1)
(334,213,1)
(340,319,1)
(216,190,1)
(277,235,1)
(248,267,1)
(222,429,1)
(461,196,1)
(451,85,1)
(217,75,1)
(379,51,1)
(323,348,1)
(217,377,1)
(28,207,1)
(191,443,1)
(442,468,1)
(155,248,1)
(375,285,1)
(391,7,1)
(473,108,1)
(217,303,1)
(204,41,1)
(244,304,1)
(455,17,1)
(87,261,1)
(330,325,1)
(18,238,1)
(300,460,1)
(454,236,1)
(262,39,1)
(433,458,1)
(196,131,1)
(458,41,1)
(188,233,1)
(314,41,1)
(168,220,1)
(174,47,1)
(312,313,1)
(136,113,1)
(242,313,1)
(104,404,1)
(236,49,1)
(324,230,1)
(281,222,1)
(441,372,1)
(455,331,1)
(450,155,1)
(384,41,1)
(292,484,1)
(327,157,1)
(309,26,1)
(101,215,1)
(102,243,1)
(64,47,1)
(223,457,1)
(253,139,1)
(386,309,1)
(142,357,1)
(209,324,1)
(165,68,1)
(163,242,1)
(276,413,1)
(19,183,1)
(160,134,1)
(91,232,1)
(243,36,1)
(110,252,1)
(224,333,1)
(149,199,1)
(489,183,1)
(451,41,1)
(8,323,1)
(421,401,1)
(103,310,1)
(482,206,1)
(402,251,1)
(468,426,1)
(336,421,1)
(252,19,1)
(172,372,1)
(204,372,1)
(70,165,1)
(92,247,1)
(160,283,1)
(216,172,1)
(43,362,1)
(202,221,1)
(239,394,1)
(427,491,1)
(198,128,1)
(354,193,1)
(123,237,1)
(12,116,1)
(21,31,1)
(485,100,1)
(343,380,1)
(245,427,1)
(240,479,1)
(127,218,1)
(159,478,1)
(71,69,1)
(378,312,1)
(232,372,1)
(142,384,1)
(305,483,1)
(134,112,1)
(179,391,1)
(270,186,1)
(185,41,1)
(349,47,1)
(28,441,1)
(384,464,1)
(207,441,1)
(289,1,1)
(288,96,1)
(452,137,1)
(418,375,1)
(257,316,1)
(255,130,1)
(89,246,1)
(17,223,1)
(430,33,1)
(228,216,1)
(443,286,1)
(75,411,1)
(227,281,1)
(466,272,1)
(271,244,1)
(393,70,1)
(93,138,1)
(348,404,1)
(278,12,1)
(119,151,1)
(33,334,1)
(451,372,1)
(469,141,1)
(304,37,1)
(205,239,1)
(435,41,1)
(358,23,1)
(431,390,1)
(420,47,1)
(72,43,1)
(36,41,1)
(353,425,1)
(130,272,1)
(152,58,1)
(19,489,1)
(51,117,1)
(174,294,1)
(325,474,1)
(139,321,1)
(377,389,1)
(251,376,1)
(79,216,1)
(35,372,1)
(97,120,1)
(414,372,1)
(108,268,1)
(417,372,1)
(139,372,1)
(254,91,1)
(447,349,1)
(23,466,1)
(173,30,1)
(102,293,1)
(278,201,1)
(370,27,1)
(364,300,1)
(438,212,1)
(199,181,1)
(470,101,1)
(389,114,1)
(321,60,1)
(361,402,1)
(129,290,1)
(310,453,1)
(37,72,1)
(39,355,1)
(426,153,1)
(458,301,1)
(468,34,1)
(300,372,1)
(233,388,1)
(139,41,1)
(184,445,1)
(372,98,1)
(44,359,1)
(29,483,1)
(58,326,1)
(99,446,1)
(48,160,1)
(189,194,1)
(235,47,1)
(296,288,1)
(397,147,1)
(57,16,1)
(143,270,1)
(307,455,1)
(20,204,1)
(363,42,1)
(121,99,1)
(211,317,1)
(314,477,1)
(246,194,1)
(116,157,1)
(420,254,1)
(175,466,1)
(435,393,1)
(1,142,1)
(273,442,1)
(151,6,1)
(404,278,1)
(348,104,1)
(294,448,1)
(480,435,1)
(261,170,1)
(173,273,1)
(59,306,1)
(466,156,1)
(172,297,1)
(474,59,1)
(36,471,1)
(113,292,1)
(404,24,1)
(376,299,1)
(425,269,1)
(85,158,1)
(411,38,1)
(24,278,1)
(98,256,1)
(459,169,1)
(414,454,1)
(144,255,1)
(319,379,1)
(306,234,1)
(221,396,1)
(367,449,1)
(384,372,1)
(114,277,1)
(385,47,1)
(449,487,1)
(46,285,1)
(395,2,1)
(35,41,1)
(63,36,1)
(483,438,1)
(15,41,1)
(380,133,1)
(302,71,1)
(311,186,1)
(15,182,1)
(322,456,1)
(375,46,1)
(4,461,1)
(238,171,1)
(476,82,1)
(347,95,1)
(65,259,1)
(411,41,1)
(124,363,1)
(275,198,1)
(446,390,1)
(369,127,1)
(313,431,1)
(390,136,1)
(320,241,1)
(88,166,1)
(182,129,1)
(291,405,1)
(157,372,1)
(268,392,1)
(164,255,1)
(435,372,1)
(243,63,1)
(233,164,1)
(91,365,1)
(382,214,1)
(148,434,1)
(481,159,1)
(481,406,1)
(339,446,1)
(441,141,1)
(448,386,1)
(178,48,1)
(259,339,1)
(333,313,1)
(491,476,1)
(5,21,1)
(55,439,1)
(70,1,1)
(194,20,1)
(66,47,1)
(158,348,1)
(52,490,1)
(125,367,1)
(355,433,1)
(112,32,1)
(171,293,1)
(130,408,1)
(236,162,1)
(283,41,1)
(49,337,1)
(293,351,1)
(96,123,1)
(332,296,1)
(116,327,1)
(22,210,1)
(345,139,1)
(251,54,1)
(370,344,1)
(62,300,1)
(41,144,1)
(31,202,1)
(106,423,1)
(45,320,1)
(57,76,1)
(359,313,1)
(81,6,1)
(76,64,1)
(219,455,1)
(432,240,1)
(55,41,1)
(187,347,1)
(52,47,1)
(368,110,1)
(303,195,1)
(42,311,1)
(131,420,1)
(186,95,1)
(67,57,1)
(351,15,1)
(10,371,1)
(53,447,1)
(55,372,1)
(487,260,1)
(68,55,1)
(218,418,1)
(357,264,1)
(70,152,1)
(457,162,1)
(86,92,1)
(398,47,1)
(162,76,1)
(249,438,1)
(283,0,1)
(75,84,1)
(127,372,1)
(419,331,1)
(297,208,1)
(38,343,1)
(307,219,1)
(97,374,1)
(456,124,1)
(3,414,1)
(213,434,1)
(26,338,1)
(195,66,1)
(166,374,1)
(424,13,1)
(260,41,1)
(153,313,1)
(292,255,1)
(337,67,1)
(111,383,1)
(50,417,1)
(192,5,1)
(157,41,1)
(308,357,1)
(444,397,1)
(128,336,1)
(299,54,1)
(82,424,1)
(133,111,1)
(186,28,1)
(310,44,1)
(30,313,1)
(39,449,1)
(136,292,1)
(102,482,1)
(487,80,1)
(32,283,1)
(314,372,1)
(315,180,1)
(406,463,1)
(247,197,1)
(416,143,1)
(105,83,1)
(467,105,1)
(75,314,1)
(2,211,1)
(484,440,1)
(232,41,1)
(331,366,1)
(181,469,1)
(31,425,1)
(264,276,1)
(55,41,2)
(74,375,2)
(131,449,2)
(296,424,2)
(171,186,2)
(2,204,2)
(482,449,2)
(102,355,2)
(213,434,2)
(406,41,2)
(197,355,2)
(230,355,2)
(216,204,2)
(435,372,2)
(419,331,2)
(179,323,2)
(351,186,2)
(476,424,2)
(36,323,2)
(6,245,2)
(242,449,2)
(456,355,2)
(83,216,2)
(224,355,2)
(40,355,2)
(78,449,2)
(470,14,2)
(371,449,2)
(451,348,2)
(256,6,2)
(91,232,2)
(312,313,2)
(142,384,2)
(104,449,2)
(389,424,2)
(336,204,2)
(455,162,2)
(353,449,2)
(417,216,2)
(319,355,2)
(40,449,2)
(382,1,2)
(160,283,2)
(344,449,2)
(163,355,2)
(304,186,2)
(402,355,2)
(36,41,2)
(327,355,2)
(178,355,2)
(438,372,2)
(22,1,2)
(405,194,2)
(372,98,2)
(327,449,2)
(106,204,2)
(173,446,2)
(359,313,2)
(448,386,2)
(491,424,2)
(398,449,2)
(144,255,2)
(76,355,2)
(102,293,2)
(144,313,2)
(320,165,2)
(93,424,2)
(157,41,2)
(489,449,2)
(358,466,2)
(220,355,2)
(412,5,2)
(385,204,2)
(370,449,2)
(15,41,2)
(414,355,2)
(145,375,2)
(124,47,2)
(12,355,2)
(378,375,2)
(262,355,2)
(483,323,2)
(204,41,2)
(383,355,2)
(80,204,2)
(71,372,2)
(85,348,2)
(266,1,2)
(165,216,2)
(414,41,2)
(240,142,2)
(139,372,2)
(297,204,2)
(180,30,2)
(81,6,2)
(330,355,2)
(67,162,2)
(249,323,2)
(137,446,2)
(427,424,2)
(368,449,2)
(76,64,2)
(421,310,2)
(206,355,2)
(278,12,2)
(420,47,2)
(112,323,2)
(105,83,2)
(394,446,2)
(267,466,2)
(13,446,2)
(94,186,2)
(435,41,2)
(178,449,2)
(254,449,2)
(50,216,2)
(217,53,2)
(253,139,2)
(300,375,2)
(312,375,2)
(190,204,2)
(330,449,2)
(31,449,2)
(283,372,2)
(66,466,2)
(129,186,2)
(255,130,2)
(313,431,2)
(332,424,2)
(433,449,2)
(392,449,2)
(124,449,2)
(261,355,2)
(208,204,2)
(433,458,2)
(325,474,2)
(24,355,2)
(260,41,2)
(25,6,2)
(182,186,2)
(59,449,2)
(163,449,2)
(71,41,2)
(278,355,2)
(365,449,2)
(372,6,2)
(314,375,2)
(108,268,2)
(355,449,2)
(458,449,2)
(75,355,2)
(284,449,2)
(455,331,2)
(288,424,2)
(258,355,2)
(229,355,2)
(469,375,2)
(304,37,2)
(390,136,2)
(464,165,2)
(474,449,2)
(490,355,2)
(164,194,2)
(370,27,2)
(28,95,2)
(133,355,2)
(183,449,2)
(37,186,2)
(92,449,2)
(108,449,2)
(212,323,2)
(184,355,2)
(138,424,2)
(470,101,2)
(356,216,2)
(339,446,2)
(102,314,2)
(175,466,2)
(324,355,2)
(134,323,2)
(321,355,2)
(414,449,2)
(88,1,2)
(441,372,2)
(340,449,2)
(338,449,2)
(284,355,2)
(357,165,2)
(185,424,2)
(75,314,2)
(29,483,2)
(438,41,2)
(26,338,2)
(57,162,2)
(7,323,2)
(307,162,2)
(82,424,2)
(37,72,2)
(283,323,2)
(260,372,2)
(273,30,2)
(349,47,2)
(119,6,2)
(390,466,2)
(247,449,2)
(1,165,2)
(33,1,2)
(172,372,2)
(45,320,2)
(300,372,2)
(283,41,2)
(72,43,2)
(334,213,2)
(435,204,2)
(419,449,2)
(301,449,2)
(323,355,2)
(236,449,2)
(121,446,2)
(54,224,2)
(285,216,2)
(458,372,2)
(450,466,2)
(337,162,2)
(257,1,2)
(110,449,2)
(41,6,2)
(460,375,2)
(218,375,2)
(160,323,2)
(395,204,2)
(412,449,2)
(42,449,2)
(51,449,2)
(211,47,2)
(416,186,2)
(97,1,2)
(461,449,2)
(238,186,2)
(255,466,2)
(429,355,2)
(147,449,2)
(421,204,2)
(396,449,2)
(426,153,2)
(116,355,2)
(348,449,2)
(359,204,2)
(423,204,2)
(28,441,2)
(64,47,2)
(159,186,2)
(103,204,2)
(140,375,2)
(398,47,2)
(142,357,2)
(239,446,2)
(380,35,2)
(148,1,2)
(228,216,2)
(198,204,2)
(454,449,2)
(322,449,2)
(102,435,2)
(186,95,2)
(471,323,2)
(441,41,2)
(29,323,2)
(147,355,2)
(426,30,2)
(467,373,2)
(101,355,2)
(166,1,2)
(146,355,2)
(377,424,2)
(18,186,2)
(370,355,2)
(221,449,2)
(157,449,2)
(279,446,2)
(384,41,2)
(278,201,2)
(302,355,2)
(31,425,2)
(245,424,2)
(222,355,2)
(123,424,2)
(45,165,2)
(165,55,2)
(424,446,2)
(229,449,2)
(111,355,2)
(152,127,2)
(102,449,2)
(248,466,2)
(153,313,2)
(278,449,2)
(104,355,2)
(232,372,2)
(246,194,2)
(120,1,2)
(419,355,2)
(307,76,2)
(3,449,2)
(446,390,2)
(243,36,2)
(449,204,2)
(162,355,2)
(89,194,2)
(55,372,2)
(26,449,2)
(62,375,2)
(158,348,2)
(157,355,2)
(84,355,2)
(309,449,2)
(452,446,2)
(391,323,2)
(485,100,2)
(448,449,2)
(77,424,2)
(145,312,2)
(197,449,2)
(15,372,2)
(243,323,2)
(252,449,2)
(315,30,2)
(281,355,2)
(35,372,2)
(46,216,2)
(467,216,2)
(44,359,2)
(39,355,2)
(186,449,2)
(15,186,2)
(113,466,2)
(56,449,2)
(10,355,2)
(202,449,2)
(86,449,2)
(285,467,2)
(484,466,2)
(341,449,2)
(144,6,2)
(168,355,2)
(195,466,2)
(459,169,2)
(302,449,2)
(273,468,2)
(250,186,2)
(303,466,2)
(155,466,2)
(307,47,2)
(458,41,2)
(219,162,2)
(480,204,2)
(451,41,2)
(454,355,2)
(194,204,2)
(292,466,2)
(323,449,2)
(168,449,2)
(487,260,2)
(398,355,2)
(37,250,2)
(170,355,2)
(174,47,2)
(441,141,2)
(55,216,2)
(275,204,2)
(333,355,2)
(314,372,2)
(227,355,2)
(163,242,2)
(188,204,2)
(270,186,2)
(461,196,2)
(251,54,2)
(370,344,2)
(139,41,2)
(189,194,2)
(354,451,2)
(220,419,2)
(116,449,2)
(253,355,2)
(27,355,2)
(127,372,2)
(459,355,2)
(235,424,2)
(417,372,2)
(157,372,2)
(442,30,2)
(354,348,2)
(69,449,2)
(385,47,2)
(211,204,2)
(127,375,2)
(447,446,2)
(319,449,2)
(207,95,2)
(459,253,2)
(58,375,2)
(326,375,2)
(247,355,2)
(397,355,2)
(310,453,2)
(424,313,2)
(214,1,2)
(130,466,2)
(10,449,2)
(215,319,2)
(143,186,2)
(76,449,2)
(227,449,2)
(479,142,2)
(209,355,2)
(438,323,2)
(434,1,2)
(477,375,2)
(380,355,2)
(213,1,2)
(194,255,2)
(411,372,2)
(43,186,2)
(333,313,2)
(451,372,2)
(468,30,2)
(222,449,2)
(264,165,2)
(235,47,2)
(343,355,2)
(375,216,2)
(4,449,2)
(117,355,2)
(19,449,2)
(379,449,2)
(99,446,2)
(204,372,2)
(64,355,2)
(8,323,2)
(485,446,2)
(75,435,2)
(217,275,2)
(306,163,2)
(468,34,2)
(306,449,2)
(467,105,2)
(415,355,2)
(54,355,2)
(384,165,2)
(384,372,2)
(456,449,2)
(139,355,2)
(92,355,2)
(232,41,2)
(44,204,2)
(397,449,2)
(220,444,2)
(311,449,2)
(483,438,2)
(102,414,2)
(399,165,2)
(386,449,2)
(64,449,2)
(23,466,2)
(368,110,2)
(349,446,2)
(334,1,2)
(325,449,2)
(215,355,2)
(79,216,2)
(406,186,2)
(142,165,2)
(251,376,2)
(401,204,2)
(96,424,2)
(413,165,2)
(71,355,2)
(91,449,2)
(251,355,2)
(127,41,2)
(347,95,2)
(417,41,2)
(421,401,2)
(27,449,2)
(429,449,2)
(39,449,2)
(291,194,2)
(375,285,2)
(66,47,2)
(379,355,2)
(406,372,2)
(167,424,2)
(105,216,2)
(12,449,2)
(393,204,2)
(363,355,2)
(440,466,2)
(63,323,2)
(11,375,2)
(130,272,2)
(271,186,2)
(30,446,2)
(68,216,2)
(340,355,2)
(439,216,2)
(258,459,2)
(342,466,2)
(53,446,2)
(482,355,2)
(468,426,2)
(217,377,2)
(124,355,2)
(348,404,2)
(299,355,2)
(316,1,2)
(237,424,2)
(269,449,2)
(457,162,2)
(294,449,2)
(3,355,2)
(404,278,2)
(57,76,2)
(420,449,2)
(52,47,2)
(444,397,2)
(141,375,2)
(217,75,2)
(432,142,2)
(95,470,2)
(363,449,2)
(125,449,2)
(268,449,2)
(217,102,2)
(241,165,2)
(86,355,2)
(408,466,2)
(446,466,2)
(52,355,2)
(436,355,2)
(48,449,2)
(374,1,2)
(36,372,2)
(259,446,2)
(306,355,2)
(21,449,2)
(95,449,2)
(403,449,2)
(449,487,2)
(445,355,2)
(138,167,2)
(17,162,2)
(441,95,2)
(367,449,2)
(51,355,2)
(136,466,2)
(187,95,2)
(411,41,2)
(151,6,2)
(277,424,2)
(262,449,2)
(233,204,2)
(274,355,2)
(369,375,2)
(209,449,2)
(101,215,2)
(210,1,2)
(48,355,2)
(470,355,2)
(196,449,2)
(236,355,2)
(174,449,2)
(38,355,2)
(98,313,2)
(199,375,2)
(242,355,2)
(364,375,2)
(344,355,2)
(376,355,2)
(323,354,2)
(397,147,2)
(463,186,2)
(414,372,2)
(49,162,2)
(314,41,2)
(323,348,2)
(307,455,2)
(176,323,2)
(324,449,2)
(164,255,2)
(325,355,2)
(35,41,2)
(305,323,2)
(388,194,2)
(260,204,2)
(413,45,2)
(364,300,2)
(0,323,2)
(128,204,2)
(95,355,2)
(65,259,2)
(310,44,2)
(75,411,2)
(412,56,2)
(470,449,2)
(9,449,2)
(411,355,2)
(444,449,2)
(31,202,2)
(322,355,2)
(289,1,2)
(418,375,2)
(114,424,2)
(71,449,2)
(362,186,2)
(473,449,2)
(311,355,2)
(215,449,2)
(217,303,2)
(145,364,2)
(87,355,2)
(290,186,2)
(293,15,2)
(98,6,2)
(60,355,2)
(204,424,2)
(116,157,2)
(404,355,2)
(97,374,2)
(245,255,2)
(319,41,2)
(223,162,2)
(41,144,2)
(193,348,2)
(100,446,2)
(220,449,2)
(20,204,2)
(230,449,2)
(292,255,2)
(96,390,2)
(24,449,2)
(27,71,2)
(310,204,2)
(300,41,2)
(319,372,2)
(491,476,2)
(231,186,2)
(117,449,2)
(83,417,2)
(162,449,2)
(488,355,2)
(149,375,2)
(404,449,2)
(12,116,2)
(242,313,2)
(59,355,2)
(430,1,2)
(317,204,2)
(308,165,2)
(32,323,2)
(478,186,2)
(54,400,2)
(345,355,2)
(206,449,2)
(474,355,2)
(371,355,2)
(481,186,2)
(425,449,2)
(348,355,2)
(205,446,2)
(244,186,2)
(42,355,2)
(276,165,2)
(35,355,2)
(102,243,2)
(172,204,2)
(70,204,2)
(72,186,2)
(101,449,2)
(172,41,2)
(224,333,2)
(466,272,2)
(19,183,2)
(136,292,2)
(6,424,2)
(355,433,2)
(5,449,2)
(153,30,2)
(361,355,2)
(306,234,2)
(431,390,2)
(281,449,2)
(444,355,2)
(152,375,2)
(216,172,2)
(69,355,2)
(431,446,2)
(293,186,2)
(232,449,2)
(16,162,2)
(481,406,2)
(487,204,2)
(192,449,2)
(186,355,2)
(186,28,2)
(65,446,2)
(181,375,2)
(325,306,2)
(313,446,2)
-----------------------------------
(0,trunk)
(1,ringing_trunk)
(2,station)
(3,NULL)
(4,cond)
(5,&cond)
(6,!ast_strlen_zero(trunk_name)
(7,0)
(8,trunk_ref)
(9,chan)
(10,trunk_ref)
(11,name)
(12,&trunk_ref->trunk->active_stations)
(13,station)
(14,int *)
(15,trunk_ref->trunk)
(16,conf)
(17,conf_flags)
(18,trunk_ref)
(19,ast_cond_init(&cond, NULL)
(20,trunk_name)
(21,cond)
(22,sla_queue_event(SLA_EVENT_RINGING_TRUNK)
(23,LOG_WARNING)
(24,1)
(25,trunk_name)
(26,ast_mutex_destroy(&cond_lock)
(27,trunk_ref->trunk->name)
(28,trunk_ref->state != SLA_TRUNK_STATE_ONHOLD_BYME)
(29,ast_indicate(trunk_ref->trunk->chan, AST_CONTROL_UNHOLD)
(30,station)
(31,ast_pthread_create_detached_background(&dont_care, NULL, dial_trunk, &args)
(32,SLA_TRUNK_STATE_UP)
(33,ringing_trunk)
(34,int *)
(35,trunk_ref->trunk)
(36,trunk_ref->trunk)
(37,sizeof(conf_name)
(38,chan)
(39,trunk_ref)
(40,0)
(41,trunk_ref = sla_find_trunk_ref_byname(station, trunk_name)
(42,"SLASTATION_STATUS")
(43,strlen(conf_name)
(44,&station->ref_count)
(45,&sla.lock)
(46,1)
(47,struct ast_channel *chan)
(48,conf_name)
(49,conf = NULL)
(50,hold_stations)
(51,trunk_ref)
(52,pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "CONGESTION")
(53,return 0;)
(54,(int *)
(55,trunk_ref->state)
(56,&cond_lock)
(57,dispose_conf(conf)
(58,NULL)
(59,1)
(60,trunk_ref)
(61,if (!trunk_ref->trunk->chan)
(62,name)
(63,on_hold)
(64,build_conf(conf_name, "", "", 0, 0, 1, chan, NULL)
(65,AST_RWLIST_RDLOCK(&sla_stations)
(66,pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE")
(67,conf)
(68,SLA_TRUNK_STATE_RINGING)
(69,trunk)
(70,trunk_ref)
(71,trunk_ref->trunk)
(72,strlen(conf_name)
(73,)
(74,SLA_TRUNK_STATE_UP)
(75,return 0;)
(76,conf = build_conf(conf_name, "", "", 0, 0, 1, chan, NULL)
(77,LOG_WARNING)
(78,trunk_ref)
(79,trunk_ref)
(80,chan)
(81,trunk_ref)
(82,sla_trunks)
(83,trunk_ref->trunk->hold_stations)
(84,0)
(85,trunk)
(86,CONFFLAG_SLA_STATION)
(87,station)
(88,ALL_TRUNK_REFS)
(89,"No trunks available for call.\\n")
(90,)
(91,sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL)
(92,CONFFLAG_PASS_DTMF)
(93,trunk_ref)
(94,1)
(95,ast_atomic_dec_and_test((int *)
(96,ast_log(LOG_WARNING, "Station \'%s\' not found!\\n", station_name)
(97,sla_change_trunk_state(ringing_trunk->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL)
(98,sla_choose_idle_trunk(station)
(99,LOG_WARNING)
(100,&sla_stations)
(101,&trunk_ref->trunk->active_stations)
(102,return 0;)
(103,1)
(104,0)
(105,&trunk_ref->trunk->hold_stations)
(106,trunk)
(107,ast_mutex_unlock)
(108,ast_mutex_unlock(&cond_lock)
(109,)
(110,&cond_lock)
(111,ALL_TRUNK_REFS)
(112,ALL_TRUNK_REFS)
(113,"_")
(114,sla_queue_event(SLA_EVENT_CHECK_RELOAD)
(115,)
(116,trunk_ref->trunk->active_stations)
(117,trunk_ref->chan = NULL)
(118,conf)
(119,station)
(120,NULL)
(121,"Invalid Arguments to SLAStation!\\n")
(122,conf_name)
(123,station_name)
(124,pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "SUCCESS")
(125,trunk)
(126,)
(127,trunk_ref->trunk)
(128,sla_queue_event(SLA_EVENT_CHECK_RELOAD)
(129,trunk_ref)
(130,ast_strdupa(data)
(131,cond_lock)
(132,dont_care)
(133,NULL)
(134,NULL)
(135,)
(136,strsep(&trunk_name, "_")
(137,station)
(138,AST_RWLIST_UNLOCK(&sla_trunks)
(139,trunk_ref->trunk)
(140,trunk_ref)
(141,trunk_ref->state = SLA_TRUNK_STATE_UP)
(142,ringing_trunk->trunk == trunk_ref->trunk)
(143,",K")
(144,sla_find_trunk_ref_byname(station, trunk_name)
(145,ast_devstate_changed(AST_DEVICE_INUSE, AST_DEVSTATE_CACHABLE,\n\\n\\t\\t\\t\\t\\t     "SLA:%s_%s", station->name, trunk_ref->trunk->name)
(146,trunk_ref)
(147,CONFFLAG_PASS_DTMF | CONFFLAG_SLA_STATION)
(148,chan)
(149,station)
(150,)
(151,trunk_ref)
(152,sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL)
(153,station->ref_count)
(154,)
(155,"SLASTATION_STATUS")
(156,data)
(157,trunk_ref->trunk)
(158,trunk_ref)
(159,NULL)
(160,sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL)
(161,if (ast_strlen_zero(trunk_name)
(162,conf)
(163,&station->ref_count)
(164,ast_log(LOG_NOTICE, "Can\'t join existing call on trunk "\n\\n\\t\\t\\t\\t"\'%s\' due to access controls.\\n", trunk_name)
(165,trunk_ref->state == SLA_TRUNK_STATE_RINGING)
(166,SLA_TRUNK_STATE_UP)
(167,&sla_trunks)
(168,chan)
(169,long)
(170,NULL)
(171,0)
(172,trunk_ref->state)
(173,sla_stations)
(174,ast_autoservice_stop(chan)
(175,trunk_name)
(176,trunk_ref)
(177,if (!trunk_ref)
(178,conf_name)
(179,trunk_ref)
(180,station)
(181,AST_DEVSTATE_CACHABLE)
(182,trunk)
(183,&cond)
(184,"SLASTATION_STATUS")
(185,sla_trunks)
(186,ast_atomic_dec_and_test((int *)
(187,state)
(188,"SLASTATION_STATUS")
(189,LOG_NOTICE)
(190,SLA_TRUNK_STATE_ONHOLD_BYME)
(191,*trunk_ref = NULL)
(192,cond_lock)
(193,on_hold)
(194,ast_strlen_zero(trunk_name)
(195,0)
(196,&cond_lock)
(197,CONFFLAG_QUIET)
(198,0)
(199,"SLA:%s_%s")
(200,ringing_trunk)
(201,int *)
(202,&args)
(203,)
(204,!trunk_ref)
(205,"FAILURE")
(206,sla_queue_event(SLA_EVENT_CHECK_RELOAD)
(207,SLA_TRUNK_STATE_ONHOLD_BYME)
(208,trunk_ref)
(209,NULL)
(210,SLA_EVENT_RINGING_TRUNK)
(211,pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "CONGESTION")
(212,trunk)
(213,ringing_trunk->trunk->chan)
(214,SLA_EVENT_DIAL_STATE)
(215,trunk_ref->trunk->active_stations)
(216,trunk_ref->state == SLA_TRUNK_STATE_ONHOLD_BYME)
(217,RET)
(218,trunk)
(219,NULL)
(220,ast_set_flag64(&conf_flags,\n\\n\\t\\tCONFFLAG_QUIET | CONFFLAG_MARKEDEXIT | CONFFLAG_PASS_DTMF | CONFFLAG_SLA_STATION)
(221,args)
(222,"")
(223,conf)
(224,&station->ref_count)
(225,if (ringing_trunk)
(226,if (ast_strlen_zero(station_name)
(227,0)
(228,trunk_ref)
(229,conf_flags)
(230,1)
(231,SLA_TRUNK_STATE_IDLE)
(232,trunk_ref->trunk)
(233,chan)
(234,int *)
(235,pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE")
(236,trunk_ref)
(237,"Station \'%s\' not found!\\n")
(238,trunk_ref->trunk->hold_stations = 0)
(239,"SLASTATION_STATUS")
(240,AST_LIST_REMOVE_CURRENT(entry)
(241,lock)
(242,station->ref_count)
(243,trunk_ref->trunk->on_hold)
(244,NULL)
(245,ast_strlen_zero(trunk_name)
(246,LOG_NOTICE)
(247,CONFFLAG_MARKEDEXIT)
(248,chan)
(249,chan)
(250,sizeof(conf_name)
(251,ast_atomic_fetchadd_int((int *)
(252,cond_lock)
(253,trunk_ref->trunk->chan)
(254,chan)
(255,trunk_name = ast_strdupa(data)
(256,station)
(257,free(ringing_trunk)
(258,ast_debug(1, "Trunk didn\'t get created. chan: %lx\\n", (long)
(259,&sla_stations)
(260,trunk_ref->trunk)
(261,trunk_ref->chan = NULL)
(262,trunk)
(263,if (ast_atomic_fetchadd_int((int *)
(264,trunk)
(265,cond)
(266,trunk)
(267,ast_log(LOG_WARNING, "Invalid Arguments to SLAStation!\\n")
(268,&cond_lock)
(269,dont_care)
(270,conf_name)
(271,conf_name)
(272,const char *data)
(273,ast_atomic_fetchadd_int((int *)
(274,"Trunk didn\'t get created. chan: %lx\\n")
(275,return 0;)
(276,ringing_trunk)
(277,SLA_EVENT_CHECK_RELOAD)
(278,(int *)
(279,ast_log(LOG_WARNING, "Invalid Arguments to SLAStation!\\n")
(280,)
(281,"")
(282,)
(283,trunk_ref->trunk)
(284,conf)
(285,ast_atomic_dec_and_test((int *)
(286,trunk_ref)
(287,if (ast_atomic_dec_and_test((int *)
(288,chan)
(289,ringing_trunk)
(290,admin_exec(NULL, conf_name)
(291,trunk_name)
(292,&trunk_name)
(293,trunk_ref->trunk->hold_stations)
(294,chan)
(295,trunk_name)
(296,"SLASTATION_STATUS")
(297,state)
(298,station)
(299,1)
(300,trunk_ref->trunk)
(301,trunk)
(302,name)
(303,return 0;)
(304,strncat(conf_name, ",K", sizeof(conf_name)
(305,AST_CONTROL_UNHOLD)
(306,(int *)
(307,conf_run(chan, conf, &conf_flags, NULL)
(308,trunk_ref)
(309,cond)
(310,(int *)
(311,chan)
(312,station->name)
(313,station = sla_find_station(station_name)
(314,trunk_ref->state)
(315,ref_count)
(316,ringing_trunk)
(317,"CONGESTION")
(318,)
(319,trunk_ref->trunk)
(320,sla.lock)
(321,trunk)
(322,ref_count)
(323,ast_atomic_fetchadd_int((int *)
(324,chan)
(325,ast_atomic_fetchadd_int((int *)
(326,ALL_TRUNK_REFS)
(327,active_stations)
(328,conf_flags)
(329,)
(330,SLA_EVENT_CHECK_RELOAD)
(331,conf_flags = { 0 })
(332,"FAILURE")
(333,station->ref_count)
(334,answer_trunk_chan(ringing_trunk->trunk->chan)
(335,)
(336,SLA_EVENT_CHECK_RELOAD)
(337,NULL)
(338,&cond_lock)
(339,sla_stations)
(340,active_stations)
(341,SLA_TRUNK_STATE_UP)
(342,station_name)
(343,trunk_ref)
(344,sizeof(conf_name)
(345,chan)
(346,cond_lock)
(347,trunk_ref)
(348,ast_atomic_fetchadd_int((int *)
(349,pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE")
(350,if (ringing_trunk->trunk == trunk_ref->trunk)
(351,hold_stations)
(352,)
(353,NULL)
(354,trunk_ref->trunk->on_hold)
(355,!trunk_ref->trunk->chan)
(356,trunk)
(357,ringing_trunk->trunk)
(358,"Invalid Arguments to SLAStation!\\n")
(359,station->ref_count)
(360,if (ast_strlen_zero(data)
(361,sla_queue_event(SLA_EVENT_CHECK_RELOAD)
(362,conf_name)
(363,"SUCCESS")
(364,trunk_ref->trunk->name)
(365,NULL)
(366,conf_flags)
(367,trunk_ref)
(368,ast_mutex_lock(&cond_lock)
(369,SLA_TRUNK_STATE_UP)
(370,snprintf(conf_name, sizeof(conf_name)
(371,"SLA_%s")
(372,trunk_ref = sla_choose_idle_trunk(station)
(373,int *)
(374,ringing_trunk->trunk)
(375,ast_atomic_dec_and_test((int *)
(376,-1)
(377,return 0;)
(378,trunk_ref)
(379,trunk)
(380,sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_IDLE, ALL_TRUNK_REFS, NULL)
(381,)
(382,sla_queue_event(SLA_EVENT_DIAL_STATE)
(383,SLA_TRUNK_STATE_IDLE)
(384,trunk_ref->trunk)
(385,trunk_ref->chan = chan)
(386,&cond)
(387,)
(388,ast_log(LOG_NOTICE, "No trunks available for call.\\n")
(389,0)
(390,station_name = strsep(&trunk_name, "_")
(391,trunk_ref->trunk->on_hold = 0)
(392,cond_lock)
(393,chan)
(394,chan)
(395,ref_count)
(396,dial_trunk)
(397,CONFFLAG_MARKEDEXIT | CONFFLAG_PASS_DTMF | CONFFLAG_SLA_STATION)
(398,ast_answer(chan)
(399,sla)
(400,int *)
(401,-1)
(402,SLA_EVENT_CHECK_RELOAD)
(403,ALL_TRUNK_REFS)
(404,ast_atomic_fetchadd_int((int *)
(405,"Can\'t join existing call on trunk "\n\\n\\t\\t\\t\\t"\'%s\' due to access controls.\\n")
(406,trunk_ref->trunk)
(407,if (conf)
(408,data)
(409,if (!ast_strlen_zero(trunk_name)
(410,if (station)
(411,trunk_ref->chan)
(412,ast_cond_wait(&cond, &cond_lock)
(413,ast_mutex_lock(&sla.lock)
(414,trunk_ref->chan)
(415,1)
(416,conf_name)
(417,trunk_ref->trunk)
(418,trunk_ref)
(419,&conf_flags)
(420,ast_autoservice_start(chan)
(421,ast_atomic_fetchadd_int((int *)
(422,if (!station)
(423,trunk_ref)
(424,!station)
(425,&dont_care)
(426,&station->ref_count)
(427,trunk_name)
(428,trunk_ref)
(429,conf_name)
(430,trunk)
(431,sla_find_station(station_name)
(432,break;)
(433,trunk_ref->trunk->chan)
(434,ringing_trunk->trunk)
(435,trunk_ref->chan)
(436,ref_count)
(437,if (!trunk_ref->trunk->chan)
(438,trunk_ref->trunk)
(439,state)
(440,station_name)
(441,trunk_ref->state)
(442,1)
(443,NULL)
(444,CONFFLAG_QUIET | CONFFLAG_MARKEDEXIT | CONFFLAG_PASS_DTMF | CONFFLAG_SLA_STATION)
(445,chan)
(446,ast_strlen_zero(station_name)
(447,0)
(448,ast_cond_destroy(&cond)
(449,!trunk_ref->trunk->chan)
(450,"FAILURE")
(451,trunk_ref->trunk)
(452,station_name)
(453,int *)
(454,chan)
(455,&conf_flags)
(456,station)
(457,chan)
(458,trunk_ref->trunk)
(459,(long)
(460,trunk)
(461,ast_mutex_init(&cond_lock)
(462,if (ast_atomic_dec_and_test((int *)
(463,trunk)
(464,trunk)
(465,if (trunk_ref->state == SLA_TRUNK_STATE_ONHOLD_BYME)
(466,ast_strlen_zero(data)
(467,(int *)
(468,(int *)
(469,AST_DEVICE_INUSE)
(470,(int *)
(471,trunk)
(472,)
(473,cond_lock)
(474,-1)
(475,station_name)
(476,&sla_trunks)
(477,state)
(478,ALL_TRUNK_REFS)
(479,entry)
(480,chan)
(481,sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_IDLE, ALL_TRUNK_REFS, NULL)
(482,0)
(483,trunk_ref->trunk->chan)
(484,trunk_name)
(485,AST_RWLIST_UNLOCK(&sla_stations)
(486,)
(487,trunk_ref->trunk->chan)
(488,trunk)
(489,NULL)
(490,"CONGESTION")
(491,AST_RWLIST_RDLOCK(&sla_trunks)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^