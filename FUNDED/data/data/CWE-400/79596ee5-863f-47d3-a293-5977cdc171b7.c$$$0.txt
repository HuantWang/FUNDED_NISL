-----label-----
0
-----code-----
static int write_ref_sha1(struct ref_lock *lock,
	const unsigned char *sha1, const char *logmsg)
{
	static char term = '\n';
	struct object *o;

	o = parse_object(sha1);
	if (!o) {
		error("Trying to write ref %s with nonexistent object %s",
			lock->ref_name, sha1_to_hex(sha1));
		unlock_ref(lock);
		errno = EINVAL;
		return -1;
	}
	if (o->type != OBJ_COMMIT && is_branch(lock->ref_name)) {
		error("Trying to write non-commit object %s to branch %s",
			sha1_to_hex(sha1), lock->ref_name);
		unlock_ref(lock);
		errno = EINVAL;
		return -1;
	}
	if (write_in_full(lock->lk->fd, sha1_to_hex(sha1), 40) != 40 ||
	    write_in_full(lock->lk->fd, &term, 1) != 1 ||
	    close_ref(lock) < 0) {
		int save_errno = errno;
		error("Couldn't write %s", lock->lk->filename.buf);
		unlock_ref(lock);
		errno = save_errno;
		return -1;
	}
	clear_loose_ref_cache(&ref_cache);
	if (log_ref_write(lock->ref_name, lock->old_sha1, sha1, logmsg) < 0 ||
	    (strcmp(lock->ref_name, lock->orig_ref_name) &&
	     log_ref_write(lock->orig_ref_name, lock->old_sha1, sha1, logmsg) < 0)) {
		unlock_ref(lock);
		return -1;
	}
	if (strcmp(lock->orig_ref_name, "HEAD") != 0) {
		/*
		 * Special hack: If a branch is updated directly and HEAD
		 * points to it (may happen on the remote side of a push
		 * for example) then logically the HEAD reflog should be
		 * updated too.
		 * A generic solution implies reverse symref information,
		 * but finding all symrefs pointing to the given branch
		 * would be rather costly for this rare event (the direct
		 * update of a branch) to be worth it.  So let's cheat and
		 * check with HEAD only which should cover 99% of all usage
		 * scenarios (even 100% of the default ones).
		 */
		unsigned char head_sha1[20];
		int head_flag;
		const char *head_ref;
		head_ref = resolve_ref_unsafe("HEAD", RESOLVE_REF_READING,
					      head_sha1, &head_flag);
		if (head_ref && (head_flag & REF_ISSYMREF) &&
		    !strcmp(head_ref, lock->ref_name))
			log_ref_write("HEAD", lock->old_sha1, sha1, logmsg);
	}
	if (commit_ref(lock)) {
		error("Couldn't set %s", lock->ref_name);
		unlock_ref(lock);
		return -1;
	}
	unlock_ref(lock);
	return 0;
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
3,7
5,6
5,7
6,7
8,9
8,10
11,12
11,13
13,14
13,15
16,17
16,18
18,19
18,20
21,22
21,23
21,24
21,25
21,26
21,27
21,28
21,29
21,30
21,31
21,32
21,33
22,23
23,24
23,25
25,26
25,27
27,28
29,30
30,31
30,32
31,32
33,34
33,35
36,37
37,38
37,39
38,39
40,41
40,42
41,42
43,44
45,46
45,47
46,47
47,48
49,50
49,51
49,52
49,53
50,51
51,52
51,53
51,54
51,55
52,53
55,56
55,57
56,57
59,60
59,61
60,61
62,63
64,65
65,66
65,67
66,67
68,69
70,71
71,72
71,73
72,73
74,75
76,77
77,78
79,80
79,81
80,81
80,82
81,82
81,83
82,83
82,84
83,84
86,87
88,89
88,90
89,90
91,92
91,93
92,93
95,96
95,97
95,98
95,99
96,97
97,98
97,99
97,100
97,101
98,99
101,102
101,103
102,103
104,105
106,107
106,108
107,108
110,111
111,112
111,113
112,113
114,115
116,117
117,118
117,119
118,119
120,121
122,123
123,124
125,126
125,127
126,127
126,128
127,128
127,129
128,129
128,130
129,130
129,131
129,132
129,133
130,131
132,133
132,134
133,134
133,135
134,135
138,139
138,140
139,140
141,142
145,146
145,147
146,147
146,148
146,149
146,150
147,148
149,150
149,151
150,151
150,152
151,152
155,156
156,157
160,161
160,162
161,162
161,163
162,163
164,165
167,168
167,169
167,170
167,171
167,172
168,169
169,170
169,171
171,172
171,173
173,174
174,175
176,177
177,178
177,179
177,180
178,179
181,182
181,183
182,183
182,184
183,184
183,185
184,185
189,190
190,191
190,192
191,192
193,194
195,196
196,197
196,198
197,198
199,200
201,202
202,203
204,205
205,206
205,207
206,207
208,209
209,210
209,211
212,213
212,214
213,214
213,215
214,215
214,216
215,216
215,217
215,218
215,219
215,220
216,217
218,219
218,220
219,220
222,223
222,224
223,224
226,227
228,229
231,232
232,233
232,234
233,234
233,235
233,236
234,235
236,237
236,238
237,238
240,241
240,242
241,242
244,245
244,246
245,246
245,247
245,248
245,249
245,250
246,247
248,249
248,250
249,250
252,253
252,254
253,254
256,257
258,259
261,262
261,263
262,263
263,264
263,265
264,265
266,267
268,269
269,270
271,272
271,273
272,273
272,274
273,274
273,275
273,276
274,275
276,277
276,278
277,278
282,283
282,284
282,285
282,286
282,287
283,284
284,285
284,286
286,287
286,288
288,289
290,291
291,292
291,293
293,294
295,296
296,297
296,298
298,299
298,300
301,302
302,303
302,304
303,304
305,306
305,307
305,308
305,309
305,310
306,307
309,310
311,312
313,314
314,315
316,317
316,318
317,318
317,319
318,319
318,320
319,320
321,322
322,323
322,324
323,324
325,326
327,328
328,329
328,330
328,331
329,330
331,332
333,334
333,335
334,335
337,338
338,339
338,340
338,341
338,342
338,343
339,340
342,343
342,344
343,344
346,347
348,349
350,351
350,352
351,352
351,353
352,353
354,355
356,357
356,358
356,359
357,358
358,359
358,360
358,361
359,360
362,363
362,364
363,364
366,367
367,368
367,369
368,369
370,371
372,373
373,374
375,376
376,377
376,378
377,378
379,380
381,382
-----nextToken-----
2,4,7,9,10,12,14,15,17,19,20,24,26,28,32,34,35,39,42,44,48,53,54,57,58,61,63,67,69,73,75,78,84,85,87,90,93,94,99,100,103,105,108,109,113,115,119,121,124,131,135,136,137,140,142,143,144,148,152,153,154,157,158,159,163,165,166,170,172,175,179,180,185,186,187,188,192,194,198,200,203,207,210,211,217,220,221,224,225,227,229,230,235,238,239,242,243,247,250,251,254,255,257,259,260,265,267,270,275,278,279,280,281,285,287,289,292,294,297,299,300,304,307,308,310,312,315,320,324,326,330,332,335,336,340,341,344,345,347,349,353,355,360,361,364,365,369,371,374,378,380,382
-----computeFrom-----
37,38
37,39
71,72
71,73
80,81
80,82
81,82
81,83
117,118
117,119
126,127
126,128
127,128
127,129
128,129
128,130
145,146
145,147
160,161
160,162
196,197
196,198
213,214
213,215
214,215
214,216
232,233
232,234
244,245
244,246
272,273
272,274
302,303
302,304
317,318
317,319
318,319
318,320
322,323
322,324
-----guardedBy-----
94,109
93,115
165,194
153,186
254,267
275,330
278,344
335,344
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;UnaryExpression;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;UnaryExpression;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;UnaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;UnaryExpression;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;ReferenceOperator;Name;IfStatement;BinaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;UnaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;UnaryExpression;LiteralExpression;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;UnaryExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;LiteralExpression;
-----ast_node-----
static int write_ref_sha1(struct ref_lock *lock,	const unsigned char *sha1, const char *logmsg){	static char term = '\n';	struct object *o;	o = parse_object(sha1);	if (!o) {		error("Trying to write ref %s with nonexistent object %s",			lock->ref_name, sha1_to_hex(sha1));		unlock_ref(lock);		errno = EINVAL;		return -1;	}	if (o->type != OBJ_COMMIT && is_branch(lock->ref_name)) {		error("Trying to write non-commit object %s to branch %s",			sha1_to_hex(sha1), lock->ref_name);		unlock_ref(lock);		errno = EINVAL;		return -1;	}	if (write_in_full(lock->lk->fd, sha1_to_hex(sha1), 40) != 40 ||	    write_in_full(lock->lk->fd, &term, 1) != 1 ||	    close_ref(lock) < 0) {		int save_errno = errno;		error("Couldn't write %s", lock->lk->filename.buf);		unlock_ref(lock);		errno = save_errno;		return -1;	}	clear_loose_ref_cache(&ref_cache);	if (log_ref_write(lock->ref_name, lock->old_sha1, sha1, logmsg) < 0 ||	    (strcmp(lock->ref_name, lock->orig_ref_name) &&	     log_ref_write(lock->orig_ref_name, lock->old_sha1, sha1, logmsg) < 0)) {		unlock_ref(lock);		return -1;	}	if (strcmp(lock->orig_ref_name, "HEAD") != 0) {		/*		 * Special hack: If a branch is updated directly and HEAD		 * points to it (may happen on the remote side of a push		 * for example) then logically the HEAD reflog should be		 * updated too.		 * A generic solution implies reverse symref information,		 * but finding all symrefs pointing to the given branch		 * would be rather costly for this rare event (the direct		 * update of a branch) to be worth it.  So let's cheat and		 * check with HEAD only which should cover 99% of all usage		 * scenarios (even 100% of the default ones).		 */		unsigned char head_sha1[20];		int head_flag;		const char *head_ref;		head_ref = resolve_ref_unsafe("HEAD", RESOLVE_REF_READING,					      head_sha1, &head_flag);		if (head_ref && (head_flag & REF_ISSYMREF) &&		    !strcmp(head_ref, lock->ref_name))			log_ref_write("HEAD", lock->old_sha1, sha1, logmsg);	}	if (commit_ref(lock)) {		error("Couldn't set %s", lock->ref_name);		unlock_ref(lock);		return -1;	}	unlock_ref(lock);	return 0;}
static int
write_ref_sha1(struct ref_lock *lock,	const unsigned char *sha1, const char *logmsg)
write_ref_sha1
struct ref_lock *lock
struct ref_lock
ref_lock
*lock
*
lock
const unsigned char *sha1
const unsigned char
*sha1
*
sha1
const char *logmsg
const char
*logmsg
*
logmsg
{	static char term = '\n';	struct object *o;	o = parse_object(sha1);	if (!o) {		error("Trying to write ref %s with nonexistent object %s",			lock->ref_name, sha1_to_hex(sha1));		unlock_ref(lock);		errno = EINVAL;		return -1;	}	if (o->type != OBJ_COMMIT && is_branch(lock->ref_name)) {		error("Trying to write non-commit object %s to branch %s",			sha1_to_hex(sha1), lock->ref_name);		unlock_ref(lock);		errno = EINVAL;		return -1;	}	if (write_in_full(lock->lk->fd, sha1_to_hex(sha1), 40) != 40 ||	    write_in_full(lock->lk->fd, &term, 1) != 1 ||	    close_ref(lock) < 0) {		int save_errno = errno;		error("Couldn't write %s", lock->lk->filename.buf);		unlock_ref(lock);		errno = save_errno;		return -1;	}	clear_loose_ref_cache(&ref_cache);	if (log_ref_write(lock->ref_name, lock->old_sha1, sha1, logmsg) < 0 ||	    (strcmp(lock->ref_name, lock->orig_ref_name) &&	     log_ref_write(lock->orig_ref_name, lock->old_sha1, sha1, logmsg) < 0)) {		unlock_ref(lock);		return -1;	}	if (strcmp(lock->orig_ref_name, "HEAD") != 0) {		/*		 * Special hack: If a branch is updated directly and HEAD		 * points to it (may happen on the remote side of a push		 * for example) then logically the HEAD reflog should be		 * updated too.		 * A generic solution implies reverse symref information,		 * but finding all symrefs pointing to the given branch		 * would be rather costly for this rare event (the direct		 * update of a branch) to be worth it.  So let's cheat and		 * check with HEAD only which should cover 99% of all usage		 * scenarios (even 100% of the default ones).		 */		unsigned char head_sha1[20];		int head_flag;		const char *head_ref;		head_ref = resolve_ref_unsafe("HEAD", RESOLVE_REF_READING,					      head_sha1, &head_flag);		if (head_ref && (head_flag & REF_ISSYMREF) &&		    !strcmp(head_ref, lock->ref_name))			log_ref_write("HEAD", lock->old_sha1, sha1, logmsg);	}	if (commit_ref(lock)) {		error("Couldn't set %s", lock->ref_name);		unlock_ref(lock);		return -1;	}	unlock_ref(lock);	return 0;}
static char term = '\n';
static char term = '\n';
static char
term = '\n'
term
= '\n'
'\n'
struct object *o;
struct object *o;
struct object
object
*o
*
o
o = parse_object(sha1);
o = parse_object(sha1)
o
o
parse_object(sha1)
parse_object
parse_object
sha1
sha1
if (!o) {		error("Trying to write ref %s with nonexistent object %s",			lock->ref_name, sha1_to_hex(sha1));		unlock_ref(lock);		errno = EINVAL;		return -1;	}
!o
o
o
{		error("Trying to write ref %s with nonexistent object %s",			lock->ref_name, sha1_to_hex(sha1));		unlock_ref(lock);		errno = EINVAL;		return -1;	}
error("Trying to write ref %s with nonexistent object %s",			lock->ref_name, sha1_to_hex(sha1));
error("Trying to write ref %s with nonexistent object %s",			lock->ref_name, sha1_to_hex(sha1))
error
error
"Trying to write ref %s with nonexistent object %s"
lock->ref_name
lock
lock
ref_name
sha1_to_hex(sha1)
sha1_to_hex
sha1_to_hex
sha1
sha1
unlock_ref(lock);
unlock_ref(lock)
unlock_ref
unlock_ref
lock
lock
errno = EINVAL;
errno = EINVAL
errno
errno
EINVAL
EINVAL
return -1;
-1
1
if (o->type != OBJ_COMMIT && is_branch(lock->ref_name)) {		error("Trying to write non-commit object %s to branch %s",			sha1_to_hex(sha1), lock->ref_name);		unlock_ref(lock);		errno = EINVAL;		return -1;	}
o->type != OBJ_COMMIT && is_branch(lock->ref_name)
o->type != OBJ_COMMIT
o->type
o
o
type
OBJ_COMMIT
OBJ_COMMIT
is_branch(lock->ref_name)
is_branch
is_branch
lock->ref_name
lock
lock
ref_name
{		error("Trying to write non-commit object %s to branch %s",			sha1_to_hex(sha1), lock->ref_name);		unlock_ref(lock);		errno = EINVAL;		return -1;	}
error("Trying to write non-commit object %s to branch %s",			sha1_to_hex(sha1), lock->ref_name);
error("Trying to write non-commit object %s to branch %s",			sha1_to_hex(sha1), lock->ref_name)
error
error
"Trying to write non-commit object %s to branch %s"
sha1_to_hex(sha1)
sha1_to_hex
sha1_to_hex
sha1
sha1
lock->ref_name
lock
lock
ref_name
unlock_ref(lock);
unlock_ref(lock)
unlock_ref
unlock_ref
lock
lock
errno = EINVAL;
errno = EINVAL
errno
errno
EINVAL
EINVAL
return -1;
-1
1
if (write_in_full(lock->lk->fd, sha1_to_hex(sha1), 40) != 40 ||	    write_in_full(lock->lk->fd, &term, 1) != 1 ||	    close_ref(lock) < 0) {		int save_errno = errno;		error("Couldn't write %s", lock->lk->filename.buf);		unlock_ref(lock);		errno = save_errno;		return -1;	}
write_in_full(lock->lk->fd, sha1_to_hex(sha1), 40) != 40 ||	    write_in_full(lock->lk->fd, &term, 1) != 1 ||	    close_ref(lock) < 0
write_in_full(lock->lk->fd, sha1_to_hex(sha1), 40) != 40 ||	    write_in_full(lock->lk->fd, &term, 1) != 1
write_in_full(lock->lk->fd, sha1_to_hex(sha1), 40) != 40
write_in_full(lock->lk->fd, sha1_to_hex(sha1), 40)
write_in_full
write_in_full
lock->lk->fd
lock->lk
lock
lock
lk
fd
sha1_to_hex(sha1)
sha1_to_hex
sha1_to_hex
sha1
sha1
40
40
write_in_full(lock->lk->fd, &term, 1) != 1
write_in_full(lock->lk->fd, &term, 1)
write_in_full
write_in_full
lock->lk->fd
lock->lk
lock
lock
lk
fd
&term
term
term
1
1
close_ref(lock) < 0
close_ref(lock)
close_ref
close_ref
lock
lock
0
{		int save_errno = errno;		error("Couldn't write %s", lock->lk->filename.buf);		unlock_ref(lock);		errno = save_errno;		return -1;	}
int save_errno = errno;
int save_errno = errno;
int
save_errno = errno
save_errno
= errno
errno
errno
error("Couldn't write %s", lock->lk->filename.buf);
error("Couldn't write %s", lock->lk->filename.buf)
error
error
"Couldn't write %s"
lock->lk->filename.buf
lock->lk->filename
lock->lk
lock
lock
lk
filename
buf
unlock_ref(lock);
unlock_ref(lock)
unlock_ref
unlock_ref
lock
lock
errno = save_errno;
errno = save_errno
errno
errno
save_errno
save_errno
return -1;
-1
1
clear_loose_ref_cache(&ref_cache);
clear_loose_ref_cache(&ref_cache);
clear_loose_ref_cache
clear_loose_ref_cache
(&ref_cache)
&ref_cache
&
ref_cache
if (log_ref_write(lock->ref_name, lock->old_sha1, sha1, logmsg) < 0 ||	    (strcmp(lock->ref_name, lock->orig_ref_name) &&	     log_ref_write(lock->orig_ref_name, lock->old_sha1, sha1, logmsg) < 0)) {		unlock_ref(lock);		return -1;	}
log_ref_write(lock->ref_name, lock->old_sha1, sha1, logmsg) < 0 ||	    (strcmp(lock->ref_name, lock->orig_ref_name) &&	     log_ref_write(lock->orig_ref_name, lock->old_sha1, sha1, logmsg) < 0)
log_ref_write(lock->ref_name, lock->old_sha1, sha1, logmsg) < 0
log_ref_write(lock->ref_name, lock->old_sha1, sha1, logmsg)
log_ref_write
log_ref_write
lock->ref_name
lock
lock
ref_name
lock->old_sha1
lock
lock
old_sha1
sha1
sha1
logmsg
logmsg
0
(strcmp(lock->ref_name, lock->orig_ref_name) &&	     log_ref_write(lock->orig_ref_name, lock->old_sha1, sha1, logmsg) < 0)
strcmp(lock->ref_name, lock->orig_ref_name) &&	     log_ref_write(lock->orig_ref_name, lock->old_sha1, sha1, logmsg) < 0
strcmp(lock->ref_name, lock->orig_ref_name)
strcmp
strcmp
lock->ref_name
lock
lock
ref_name
lock->orig_ref_name
lock
lock
orig_ref_name
log_ref_write(lock->orig_ref_name, lock->old_sha1, sha1, logmsg) < 0
log_ref_write(lock->orig_ref_name, lock->old_sha1, sha1, logmsg)
log_ref_write
log_ref_write
lock->orig_ref_name
lock
lock
orig_ref_name
lock->old_sha1
lock
lock
old_sha1
sha1
sha1
logmsg
logmsg
0
{		unlock_ref(lock);		return -1;	}
unlock_ref(lock);
unlock_ref(lock)
unlock_ref
unlock_ref
lock
lock
return -1;
-1
1
if (strcmp(lock->orig_ref_name, "HEAD") != 0) {		/*		 * Special hack: If a branch is updated directly and HEAD		 * points to it (may happen on the remote side of a push		 * for example) then logically the HEAD reflog should be		 * updated too.		 * A generic solution implies reverse symref information,		 * but finding all symrefs pointing to the given branch		 * would be rather costly for this rare event (the direct		 * update of a branch) to be worth it.  So let's cheat and		 * check with HEAD only which should cover 99% of all usage		 * scenarios (even 100% of the default ones).		 */		unsigned char head_sha1[20];		int head_flag;		const char *head_ref;		head_ref = resolve_ref_unsafe("HEAD", RESOLVE_REF_READING,					      head_sha1, &head_flag);		if (head_ref && (head_flag & REF_ISSYMREF) &&		    !strcmp(head_ref, lock->ref_name))			log_ref_write("HEAD", lock->old_sha1, sha1, logmsg);	}
strcmp(lock->orig_ref_name, "HEAD") != 0
strcmp(lock->orig_ref_name, "HEAD")
strcmp
strcmp
lock->orig_ref_name
lock
lock
orig_ref_name
"HEAD"
0
{		/*		 * Special hack: If a branch is updated directly and HEAD		 * points to it (may happen on the remote side of a push		 * for example) then logically the HEAD reflog should be		 * updated too.		 * A generic solution implies reverse symref information,		 * but finding all symrefs pointing to the given branch		 * would be rather costly for this rare event (the direct		 * update of a branch) to be worth it.  So let's cheat and		 * check with HEAD only which should cover 99% of all usage		 * scenarios (even 100% of the default ones).		 */		unsigned char head_sha1[20];		int head_flag;		const char *head_ref;		head_ref = resolve_ref_unsafe("HEAD", RESOLVE_REF_READING,					      head_sha1, &head_flag);		if (head_ref && (head_flag & REF_ISSYMREF) &&		    !strcmp(head_ref, lock->ref_name))			log_ref_write("HEAD", lock->old_sha1, sha1, logmsg);	}
unsigned char head_sha1[20];
unsigned char head_sha1[20];
unsigned char
head_sha1[20]
head_sha1
[20]
20
int head_flag;
int head_flag;
int
head_flag
head_flag
const char *head_ref;
const char *head_ref;
const char
*head_ref
*
head_ref
head_ref = resolve_ref_unsafe("HEAD", RESOLVE_REF_READING,					      head_sha1, &head_flag);
head_ref = resolve_ref_unsafe("HEAD", RESOLVE_REF_READING,					      head_sha1, &head_flag)
head_ref
head_ref
resolve_ref_unsafe("HEAD", RESOLVE_REF_READING,					      head_sha1, &head_flag)
resolve_ref_unsafe
resolve_ref_unsafe
"HEAD"
RESOLVE_REF_READING
RESOLVE_REF_READING
head_sha1
head_sha1
&head_flag
head_flag
head_flag
if (head_ref && (head_flag & REF_ISSYMREF) &&		    !strcmp(head_ref, lock->ref_name))			log_ref_write("HEAD", lock->old_sha1, sha1, logmsg);
head_ref && (head_flag & REF_ISSYMREF) &&		    !strcmp(head_ref, lock->ref_name)
head_ref && (head_flag & REF_ISSYMREF)
head_ref
head_ref
(head_flag & REF_ISSYMREF)
head_flag & REF_ISSYMREF
head_flag
head_flag
REF_ISSYMREF
REF_ISSYMREF
!strcmp(head_ref, lock->ref_name)
strcmp(head_ref, lock->ref_name)
strcmp
strcmp
head_ref
head_ref
lock->ref_name
lock
lock
ref_name
log_ref_write("HEAD", lock->old_sha1, sha1, logmsg);
log_ref_write("HEAD", lock->old_sha1, sha1, logmsg)
log_ref_write
log_ref_write
"HEAD"
lock->old_sha1
lock
lock
old_sha1
sha1
sha1
logmsg
logmsg
if (commit_ref(lock)) {		error("Couldn't set %s", lock->ref_name);		unlock_ref(lock);		return -1;	}
commit_ref(lock)
commit_ref
commit_ref
lock
lock
{		error("Couldn't set %s", lock->ref_name);		unlock_ref(lock);		return -1;	}
error("Couldn't set %s", lock->ref_name);
error("Couldn't set %s", lock->ref_name)
error
error
"Couldn't set %s"
lock->ref_name
lock
lock
ref_name
unlock_ref(lock);
unlock_ref(lock)
unlock_ref
unlock_ref
lock
lock
return -1;
-1
1
unlock_ref(lock);
unlock_ref(lock)
unlock_ref
unlock_ref
lock
lock
return 0;
0
-----joern-----
(108,92,0)
(78,180,0)
(14,23,0)
(34,79,0)
(166,81,0)
(144,41,0)
(171,161,0)
(130,166,0)
(26,86,0)
(167,200,0)
(115,20,0)
(46,117,0)
(180,78,0)
(72,14,0)
(136,182,0)
(49,91,0)
(75,87,0)
(92,135,0)
(79,41,0)
(156,79,0)
(191,152,0)
(201,169,0)
(208,29,0)
(154,21,0)
(87,171,0)
(151,142,0)
(25,142,0)
(98,115,0)
(3,102,0)
(111,42,0)
(2,91,0)
(79,76,0)
(62,128,0)
(123,185,0)
(46,108,0)
(143,103,0)
(56,161,0)
(201,95,0)
(98,20,0)
(198,207,0)
(84,114,0)
(93,81,0)
(112,87,0)
(152,26,0)
(137,6,0)
(204,91,0)
(200,167,0)
(74,51,0)
(194,207,0)
(200,161,0)
(91,49,0)
(67,3,0)
(103,143,0)
(185,145,0)
(144,31,0)
(49,143,0)
(185,50,0)
(119,112,0)
(171,87,0)
(121,99,0)
(138,190,0)
(70,31,0)
(0,90,0)
(131,14,0)
(128,41,0)
(111,161,0)
(73,167,0)
(106,97,0)
(179,161,0)
(181,6,0)
(97,157,0)
(108,46,0)
(120,79,0)
(162,105,0)
(37,49,0)
(129,122,0)
(31,144,0)
(33,83,0)
(26,152,0)
(40,109,0)
(174,100,0)
(114,135,0)
(118,135,0)
(27,142,0)
(39,144,0)
(86,26,0)
(28,81,0)
(90,161,0)
(127,54,0)
(99,121,0)
(207,198,0)
(53,21,0)
(149,37,0)
(72,29,0)
(71,28,0)
(8,161,0)
(176,142,0)
(146,197,0)
(12,95,0)
(19,83,0)
(125,23,0)
(188,111,0)
(45,145,0)
(202,102,0)
(175,166,0)
(99,177,0)
(145,142,0)
(155,171,0)
(15,102,0)
(158,122,0)
(102,202,0)
(63,54,0)
(79,156,0)
(77,154,0)
(195,54,0)
(178,207,0)
(150,92,0)
(128,145,0)
(1,139,0)
(90,157,0)
(117,46,0)
(199,26,0)
(3,161,0)
(205,24,0)
(59,31,0)
(32,39,0)
(207,161,0)
(28,166,0)
(172,50,0)
(56,6,0)
(122,129,0)
(187,144,0)
(51,74,0)
(180,193,0)
(187,143,0)
(177,41,0)
(135,92,0)
(163,104,0)
(193,169,0)
(182,23,0)
(203,200,0)
(189,108,0)
(153,135,0)
(190,98,0)
(17,169,0)
(93,161,0)
(69,142,0)
(139,103,0)
(117,129,0)
(48,142,0)
(92,54,0)
(110,82,0)
(68,39,0)
(9,185,0)
(202,41,0)
(144,39,0)
(48,161,0)
(168,93,0)
(148,99,0)
(133,82,0)
(103,139,0)
(104,8,0)
(43,156,0)
(141,48,0)
(80,135,0)
(94,129,0)
(104,66,0)
(82,110,0)
(129,92,0)
(96,110,0)
(89,202,0)
(6,56,0)
(160,144,0)
(61,142,0)
(156,161,0)
(72,61,0)
(152,161,0)
(82,161,0)
(72,28,0)
(72,97,0)
(99,51,0)
(143,49,0)
(184,58,0)
(85,74,0)
(58,20,0)
(6,76,0)
(124,56,0)
(154,23,0)
(172,198,0)
(102,20,0)
(110,157,0)
(197,23,0)
(42,111,0)
(107,115,0)
(79,139,0)
(167,169,0)
(95,142,0)
(11,21,0)
(145,128,0)
(192,208,0)
(51,99,0)
(35,179,0)
(64,95,0)
(179,164,0)
(29,164,0)
(198,172,0)
(30,61,0)
(5,8,0)
(10,156,0)
(180,42,0)
(112,182,0)
(36,144,0)
(37,161,0)
(159,187,0)
(13,3,0)
(47,142,0)
(39,161,0)
(102,3,0)
(186,106,0)
(91,161,0)
(50,172,0)
(170,37,0)
(197,161,0)
(169,167,0)
(122,161,0)
(74,161,0)
(6,41,0)
(193,180,0)
(182,112,0)
(101,193,0)
(38,121,0)
(139,79,0)
(52,66,0)
(121,78,0)
(134,177,0)
(88,8,0)
(126,152,0)
(105,161,0)
(132,154,0)
(21,23,0)
(46,83,0)
(24,27,0)
(16,131,0)
(4,115,0)
(140,50,0)
(65,171,0)
(50,185,0)
(66,41,0)
(143,187,0)
(87,112,0)
(72,98,0)
(42,180,0)
(169,201,0)
(55,71,0)
(173,86,0)
(100,161,0)
(116,82,0)
(147,6,0)
(14,154,0)
(183,142,0)
(78,121,0)
(57,51,0)
(27,24,0)
(165,54,0)
(169,193,0)
(58,161,0)
(31,161,0)
(83,46,0)
(49,37,0)
(7,74,0)
(144,187,0)
(60,122,0)
(196,201,0)
(22,42,0)
(104,81,0)
(79,100,0)
(144,76,0)
(209,142,0)
(129,117,0)
(135,114,0)
(100,79,0)
(177,99,0)
(109,145,0)
(206,200,0)
(8,104,0)
(44,100,0)
(18,142,0)
(66,104,0)
(113,56,0)
(102,202,1)
(182,112,1)
(72,97,1)
(83,19,1)
(52,8,1)
(124,113,1)
(93,168,1)
(26,152,1)
(48,161,1)
(72,61,1)
(28,166,1)
(37,170,1)
(53,11,1)
(108,46,1)
(7,172,1)
(144,41,1)
(49,37,1)
(129,92,1)
(184,102,1)
(92,135,1)
(104,8,1)
(159,144,1)
(171,65,1)
(91,161,1)
(86,173,1)
(42,111,1)
(201,95,1)
(46,117,1)
(75,171,1)
(171,161,1)
(169,167,1)
(126,191,1)
(70,39,1)
(31,161,1)
(45,95,1)
(65,155,1)
(56,124,1)
(132,197,1)
(72,14,1)
(122,161,1)
(91,204,1)
(188,193,1)
(139,1,1)
(180,193,1)
(207,161,1)
(71,55,1)
(42,22,1)
(197,146,1)
(14,131,1)
(8,88,1)
(93,161,1)
(148,177,1)
(167,200,1)
(118,153,1)
(193,101,1)
(146,182,1)
(90,0,1)
(107,58,1)
(79,100,1)
(170,149,1)
(192,179,1)
(72,29,1)
(2,139,1)
(117,129,1)
(36,160,1)
(174,156,1)
(79,120,1)
(95,12,1)
(169,17,1)
(160,31,1)
(28,71,1)
(144,39,1)
(156,10,1)
(198,207,1)
(122,158,1)
(196,167,1)
(14,154,1)
(172,198,1)
(11,78,1)
(26,199,1)
(104,66,1)
(193,169,1)
(48,141,1)
(61,30,1)
(180,42,1)
(88,5,1)
(24,205,1)
(149,91,1)
(134,51,1)
(202,41,1)
(74,85,1)
(109,40,1)
(147,108,1)
(201,196,1)
(100,161,1)
(1,79,1)
(72,28,1)
(208,192,1)
(179,35,1)
(73,200,1)
(138,115,1)
(133,96,1)
(4,107,1)
(202,89,1)
(139,79,1)
(103,139,1)
(119,87,1)
(96,105,1)
(86,26,1)
(17,201,1)
(67,202,1)
(168,104,1)
(84,118,1)
(111,161,1)
(8,161,1)
(177,134,1)
(185,145,1)
(199,152,1)
(60,94,1)
(43,27,1)
(6,76,1)
(152,126,1)
(82,161,1)
(116,133,1)
(143,49,1)
(128,41,1)
(162,6,1)
(158,60,1)
(179,161,1)
(22,111,1)
(85,7,1)
(155,136,1)
(35,103,1)
(130,175,1)
(79,41,1)
(150,86,1)
(181,56,1)
(121,38,1)
(6,56,1)
(110,82,1)
(10,43,1)
(74,161,1)
(115,4,1)
(187,159,1)
(102,3,1)
(62,45,1)
(187,144,1)
(3,161,1)
(140,185,1)
(154,21,1)
(108,92,1)
(200,206,1)
(89,15,1)
(19,33,1)
(78,180,1)
(101,169,1)
(203,121,1)
(66,52,1)
(169,201,1)
(207,178,1)
(111,188,1)
(156,161,1)
(51,57,1)
(9,123,1)
(189,92,1)
(144,76,1)
(144,36,1)
(145,128,1)
(56,161,1)
(190,138,1)
(50,185,1)
(5,163,1)
(123,109,1)
(13,67,1)
(87,75,1)
(66,41,1)
(27,24,1)
(0,110,1)
(162,86,1)
(58,161,1)
(49,91,1)
(72,98,1)
(112,119,1)
(129,122,1)
(141,105,1)
(153,80,1)
(108,189,1)
(106,186,1)
(191,103,1)
(40,145,1)
(90,161,1)
(30,48,1)
(162,108,1)
(29,208,1)
(51,74,1)
(6,137,1)
(34,100,1)
(173,26,1)
(99,148,1)
(79,156,1)
(204,2,1)
(94,83,1)
(131,16,1)
(205,78,1)
(206,203,1)
(68,32,1)
(121,99,1)
(105,161,1)
(178,194,1)
(103,143,1)
(37,161,1)
(50,140,1)
(97,106,1)
(59,70,1)
(77,132,1)
(137,181,1)
(172,50,1)
(200,161,1)
(197,161,1)
(163,109,1)
(113,147,1)
(177,41,1)
(55,166,1)
(167,73,1)
(82,116,1)
(109,145,1)
(98,115,1)
(128,62,1)
(166,130,1)
(99,177,1)
(120,34,1)
(57,74,1)
(39,161,1)
(58,184,1)
(152,161,1)
(32,49,1)
(3,13,1)
(105,162,1)
(112,87,1)
(79,76,1)
(185,9,1)
(31,59,1)
(136,21,1)
(21,53,1)
(100,44,1)
(87,171,1)
(46,83,1)
(99,51,1)
(114,84,1)
(194,50,1)
(15,172,1)
(143,187,1)
(78,121,1)
(175,93,1)
(16,154,1)
(33,189,1)
(98,190,1)
(80,150,1)
(44,174,1)
(38,99,1)
(6,41,1)
(186,90,1)
(39,68,1)
(144,31,1)
(154,77,1)
(135,114,1)
(12,64,1)
(73,121,2)
(167,121,2)
(6,41,2)
(15,172,2)
(196,121,2)
(49,91,2)
(149,139,2)
(78,172,2)
(130,109,2)
(179,161,2)
(37,139,2)
(207,161,2)
(104,109,2)
(135,114,2)
(5,109,2)
(162,103,2)
(169,167,2)
(117,129,2)
(154,21,2)
(56,108,2)
(185,109,2)
(141,105,2)
(119,78,2)
(72,97,2)
(146,78,2)
(109,145,2)
(171,78,2)
(182,78,2)
(85,172,2)
(72,14,2)
(193,169,2)
(131,78,2)
(43,78,2)
(108,86,2)
(181,108,2)
(66,109,2)
(152,103,2)
(150,86,2)
(101,121,2)
(128,41,2)
(86,26,2)
(189,86,2)
(72,28,2)
(72,61,2)
(11,78,2)
(201,95,2)
(139,78,2)
(169,201,2)
(105,103,2)
(98,172,2)
(173,103,2)
(9,109,2)
(80,86,2)
(144,76,2)
(178,50,2)
(93,109,2)
(197,161,2)
(200,161,2)
(29,103,2)
(200,121,2)
(86,103,2)
(193,121,2)
(103,78,2)
(175,109,2)
(129,92,2)
(59,49,2)
(92,135,2)
(79,76,2)
(93,161,2)
(6,56,2)
(180,121,2)
(172,50,2)
(191,103,2)
(3,161,2)
(39,161,2)
(8,109,2)
(87,171,2)
(206,121,2)
(58,172,2)
(143,49,2)
(56,161,2)
(122,161,2)
(60,83,2)
(38,172,2)
(182,112,2)
(156,78,2)
(37,161,2)
(163,109,2)
(79,78,2)
(202,172,2)
(58,161,2)
(123,109,2)
(153,86,2)
(16,78,2)
(75,78,2)
(49,37,2)
(115,172,2)
(135,86,2)
(28,109,2)
(112,78,2)
(177,172,2)
(172,198,2)
(170,139,2)
(177,41,2)
(17,121,2)
(129,122,2)
(102,172,2)
(35,103,2)
(74,161,2)
(145,128,2)
(207,50,2)
(48,161,2)
(10,78,2)
(83,189,2)
(39,49,2)
(139,79,2)
(117,83,2)
(147,108,2)
(30,105,2)
(4,172,2)
(144,39,2)
(198,50,2)
(136,78,2)
(98,115,2)
(172,109,2)
(126,103,2)
(187,49,2)
(199,103,2)
(133,105,2)
(67,172,2)
(100,78,2)
(42,193,2)
(71,109,2)
(44,78,2)
(48,105,2)
(1,78,2)
(180,193,2)
(113,108,2)
(204,139,2)
(79,41,2)
(116,105,2)
(171,161,2)
(46,189,2)
(3,172,2)
(79,100,2)
(174,78,2)
(169,121,2)
(72,29,2)
(89,172,2)
(192,103,2)
(7,172,2)
(97,105,2)
(28,166,2)
(179,103,2)
(137,108,2)
(105,161,2)
(57,172,2)
(121,172,2)
(152,161,2)
(138,172,2)
(134,172,2)
(0,105,2)
(33,189,2)
(31,49,2)
(144,41,2)
(77,78,2)
(203,121,2)
(14,78,2)
(121,99,2)
(70,49,2)
(26,152,2)
(185,145,2)
(91,161,2)
(99,177,2)
(21,78,2)
(6,76,2)
(166,109,2)
(27,78,2)
(110,82,2)
(159,49,2)
(88,109,2)
(79,156,2)
(124,108,2)
(155,78,2)
(120,78,2)
(112,87,2)
(168,109,2)
(51,172,2)
(122,83,2)
(140,109,2)
(99,172,2)
(72,98,2)
(201,121,2)
(186,105,2)
(160,49,2)
(100,161,2)
(32,49,2)
(180,42,2)
(78,180,2)
(110,105,2)
(50,109,2)
(90,105,2)
(144,31,2)
(158,83,2)
(99,51,2)
(111,161,2)
(187,144,2)
(156,161,2)
(36,49,2)
(103,143,2)
(42,111,2)
(87,78,2)
(205,78,2)
(46,83,2)
(102,202,2)
(65,78,2)
(190,172,2)
(103,139,2)
(24,78,2)
(53,78,2)
(197,78,2)
(148,172,2)
(202,41,2)
(94,83,2)
(84,86,2)
(31,161,2)
(55,109,2)
(108,92,2)
(66,41,2)
(111,193,2)
(27,24,2)
(106,105,2)
(107,172,2)
(90,161,2)
(78,121,2)
(13,172,2)
(198,207,2)
(61,105,2)
(51,74,2)
(82,105,2)
(118,86,2)
(68,49,2)
(50,185,2)
(132,78,2)
(74,172,2)
(102,3,2)
(6,108,2)
(96,105,2)
(184,172,2)
(34,78,2)
(208,103,2)
(82,161,2)
(154,78,2)
(91,139,2)
(8,161,2)
(92,86,2)
(143,139,2)
(26,103,2)
(19,189,2)
(194,50,2)
(167,200,2)
(104,66,2)
(22,193,2)
(114,86,2)
(144,49,2)
(129,83,2)
(108,46,2)
(104,8,2)
(14,154,2)
(49,139,2)
(188,193,2)
(2,139,2)
(52,109,2)
(46,117,2)
(143,187,2)
-----------------------------------
(0,lock)
(1,0)
(2,lock)
(3,lock->ref_name)
(4,EINVAL)
(5,lock)
(6,log_ref_write("HEAD", lock->old_sha1, sha1, logmsg)
(7,lock)
(8,lock->ref_name)
(9,type)
(10,ref_name)
(11,save_errno)
(12,\'\\n\')
(13,ref_name)
(14,return -1;)
(15,"Trying to write non-commit object %s to branch %s")
(16,1)
(17,1)
(18,if (write_in_full(lock->lk->fd, sha1_to_hex(sha1)
(19,REF_ISSYMREF)
(20,)
(21,save_errno = errno)
(22,0)
(23,)
(24,&ref_cache)
(25,if (o->type != OBJ_COMMIT && is_branch(lock->ref_name)
(26,strcmp(lock->orig_ref_name, "HEAD")
(27,clear_loose_ref_cache(&ref_cache)
(28,return -1;)
(29,return -1;)
(30,0)
(31,lock->old_sha1)
(32,lock)
(33,head_flag)
(34,sha1)
(35,lock)
(36,logmsg)
(37,lock->orig_ref_name)
(38,40)
(39,lock->orig_ref_name)
(40,o)
(41,const unsigned char *sha1)
(42,close_ref(lock)
(43,lock)
(44,old_sha1)
(45,o)
(46,(head_flag & REF_ISSYMREF)
(47,term)
(48,unlock_ref(lock)
(49,strcmp(lock->ref_name, lock->orig_ref_name)
(50,o->type != OBJ_COMMIT)
(51,lock->lk->fd)
(52,sha1)
(53,errno)
(54,)
(55,1)
(56,lock->old_sha1)
(57,fd)
(58,unlock_ref(lock)
(59,old_sha1)
(60,lock)
(61,return 0;)
(62,sha1)
(63,head_sha1)
(64,term)
(65,lk)
(66,sha1_to_hex(sha1)
(67,lock)
(68,orig_ref_name)
(69,if (!o)
(70,lock)
(71,-1)
(72,RET)
(73,fd)
(74,lock->lk)
(75,filename)
(76,const char *logmsg)
(77,save_errno)
(78,write_in_full(lock->lk->fd, sha1_to_hex(sha1)
(79,log_ref_write(lock->ref_name, lock->old_sha1, sha1, logmsg)
(80,"HEAD")
(81,)
(82,lock->ref_name)
(83,head_flag & REF_ISSYMREF)
(84,head_flag)
(85,lk)
(86,strcmp(lock->orig_ref_name, "HEAD")
(87,lock->lk->filename)
(88,ref_name)
(89,sha1)
(90,unlock_ref(lock)
(91,lock->ref_name)
(92,head_ref = resolve_ref_unsafe("HEAD", RESOLVE_REF_READING,\n\\n\\t\\t\\t\\t\\t      head_sha1, &head_flag)
(93,unlock_ref(lock)
(94,head_ref)
(95,term = \'\\n\')
(96,"Couldn\'t set %s")
(97,return -1;)
(98,return -1;)
(99,write_in_full(lock->lk->fd, sha1_to_hex(sha1)
(100,lock->old_sha1)
(101,1)
(102,error("Trying to write non-commit object %s to branch %s",\n\\n\\t\\t\\tsha1_to_hex(sha1)
(103,log_ref_write(lock->ref_name, lock->old_sha1, sha1, logmsg)
(104,error("Trying to write ref %s with nonexistent object %s",\n\\n\\t\\t\\tlock->ref_name, sha1_to_hex(sha1)
(105,commit_ref(lock)
(106,-1)
(107,errno)
(108,head_ref && (head_flag & REF_ISSYMREF)
(109,!o)
(110,error("Couldn\'t set %s", lock->ref_name)
(111,close_ref(lock)
(112,lock->lk->filename.buf)
(113,lock)
(114,&head_flag)
(115,errno = EINVAL)
(116,ref_name)
(117,!strcmp(head_ref, lock->ref_name)
(118,head_sha1)
(119,buf)
(120,logmsg)
(121,write_in_full(lock->lk->fd, sha1_to_hex(sha1)
(122,lock->ref_name)
(123,o)
(124,old_sha1)
(125,save_errno)
(126,orig_ref_name)
(127,head_flag)
(128,parse_object(sha1)
(129,strcmp(head_ref, lock->ref_name)
(130,EINVAL)
(131,-1)
(132,errno)
(133,lock)
(134,sha1)
(135,resolve_ref_unsafe("HEAD", RESOLVE_REF_READING,\n\\n\\t\\t\\t\\t\\t      head_sha1, &head_flag)
(136,"Couldn\'t write %s")
(137,logmsg)
(138,1)
(139,log_ref_write(lock->ref_name, lock->old_sha1, sha1, logmsg)
(140,OBJ_COMMIT)
(141,lock)
(142,)
(143,strcmp(lock->ref_name, lock->orig_ref_name)
(144,log_ref_write(lock->orig_ref_name, lock->old_sha1, sha1, logmsg)
(145,o = parse_object(sha1)
(146,lock)
(147,"HEAD")
(148,40)
(149,lock)
(150,head_ref)
(151,if (strcmp(lock->orig_ref_name, "HEAD")
(152,lock->orig_ref_name)
(153,RESOLVE_REF_READING)
(154,errno = save_errno)
(155,lock)
(156,lock->ref_name)
(157,)
(158,ref_name)
(159,0)
(160,sha1)
(161,struct ref_lock *lock)
(162,lock)
(163,"Trying to write ref %s with nonexistent object %s")
(164,)
(165,head_ref)
(166,errno = EINVAL)
(167,lock->lk->fd)
(168,lock)
(169,write_in_full(lock->lk->fd, &term, 1)
(170,orig_ref_name)
(171,lock->lk)
(172,o->type != OBJ_COMMIT && is_branch(lock->ref_name)
(173,0)
(174,lock)
(175,errno)
(176,o)
(177,sha1_to_hex(sha1)
(178,ref_name)
(179,unlock_ref(lock)
(180,write_in_full(lock->lk->fd, &term, 1)
(181,sha1)
(182,error("Couldn\'t write %s", lock->lk->filename.buf)
(183,if (commit_ref(lock)
(184,lock)
(185,o->type)
(186,1)
(187,log_ref_write(lock->orig_ref_name, lock->old_sha1, sha1, logmsg)
(188,lock)
(189,head_ref)
(190,-1)
(191,lock)
(192,1)
(193,write_in_full(lock->lk->fd, &term, 1)
(194,lock)
(195,if (head_ref && (head_flag & REF_ISSYMREF)
(196,term)
(197,unlock_ref(lock)
(198,is_branch(lock->ref_name)
(199,"HEAD")
(200,lock->lk)
(201,&term)
(202,sha1_to_hex(sha1)
(203,lock)
(204,ref_name)
(205,ref_cache)
(206,lk)
(207,lock->ref_name)
(208,-1)
(209,if (log_ref_write(lock->ref_name, lock->old_sha1, sha1, logmsg)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^