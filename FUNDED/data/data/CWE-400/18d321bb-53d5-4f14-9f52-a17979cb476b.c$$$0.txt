-----label-----
1
-----code-----
int rename_ref(const char *oldrefname, const char *newrefname, const char *logmsg)
{
	unsigned char sha1[20], orig_sha1[20];
	int flag = 0, logmoved = 0;
	struct ref_lock *lock;
	struct stat loginfo;
	int log = !lstat(git_path("logs/%s", oldrefname), &loginfo);
	const char *symref = NULL;
	struct strbuf err = STRBUF_INIT;

	if (log && S_ISLNK(loginfo.st_mode))
		return error("reflog for %s is a symlink", oldrefname);

	symref = resolve_ref_unsafe(oldrefname, RESOLVE_REF_READING,
				    orig_sha1, &flag);
	if (flag & REF_ISSYMREF)
		return error("refname %s is a symbolic ref, renaming it is not supported",
			oldrefname);
	if (!symref)
		return error("refname %s not found", oldrefname);

	if (!rename_ref_available(oldrefname, newrefname))
		return 1;

	if (log && rename(git_path("logs/%s", oldrefname), git_path(TMP_RENAMED_LOG)))
		return error("unable to move logfile logs/%s to "TMP_RENAMED_LOG": %s",
			oldrefname, strerror(errno));

	if (delete_ref(oldrefname, orig_sha1, REF_NODEREF)) {
		error("unable to delete old %s", oldrefname);
		goto rollback;
	}

	if (!read_ref_full(newrefname, RESOLVE_REF_READING, sha1, NULL) &&
	    delete_ref(newrefname, sha1, REF_NODEREF)) {
		if (errno==EISDIR) {
			if (remove_empty_directories(git_path("%s", newrefname))) {
				error("Directory not empty: %s", newrefname);
				goto rollback;
			}
		} else {
			error("unable to delete existing %s", newrefname);
			goto rollback;
		}
	}

	if (log && rename_tmp_log(newrefname))
		goto rollback;

	logmoved = log;

	lock = lock_ref_sha1_basic(newrefname, NULL, NULL, NULL, 0, NULL, &err);
	if (!lock) {
		error("unable to rename '%s' to '%s': %s", oldrefname, newrefname, err.buf);
		strbuf_release(&err);
		goto rollback;
	}
	hashcpy(lock->old_sha1, orig_sha1);
	if (write_ref_sha1(lock, orig_sha1, logmsg)) {
		error("unable to write current sha1 into %s", newrefname);
		goto rollback;
	}

	return 0;

 rollback:
	lock = lock_ref_sha1_basic(oldrefname, NULL, NULL, NULL, 0, NULL, &err);
	if (!lock) {
		error("unable to lock %s for rollback: %s", oldrefname, err.buf);
		strbuf_release(&err);
		goto rollbacklog;
	}

	flag = log_all_ref_updates;
	log_all_ref_updates = 0;
	if (write_ref_sha1(lock, orig_sha1, NULL))
		error("unable to write current sha1 into %s", oldrefname);
	log_all_ref_updates = flag;

 rollbacklog:
	if (logmoved && rename(git_path("logs/%s", newrefname), git_path("logs/%s", oldrefname)))
		error("unable to restore logfile %s from %s: %s",
			oldrefname, newrefname, strerror(errno));
	if (!logmoved && log &&
	    rename(git_path(TMP_RENAMED_LOG), git_path("logs/%s", oldrefname)))
		error("unable to restore logfile %s from "TMP_RENAMED_LOG": %s",
			oldrefname, strerror(errno));

	return 1;
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
3,7
5,6
5,7
7,8
7,9
10,11
10,12
12,13
12,14
15,16
15,17
17,18
17,19
20,21
20,22
20,23
20,24
20,25
20,26
20,27
20,28
20,29
20,30
20,31
20,32
20,33
20,34
20,35
20,36
20,37
20,38
20,39
20,40
20,41
20,42
20,43
20,44
20,45
20,46
20,47
20,48
20,49
20,50
20,51
21,22
22,23
22,24
22,25
24,25
24,26
26,27
28,29
28,30
30,31
32,33
33,34
33,35
33,36
35,36
35,37
37,38
39,40
39,41
41,42
43,44
44,45
44,46
45,46
47,48
47,49
50,51
51,52
51,53
52,53
54,55
56,57
57,58
57,59
59,60
59,61
61,62
62,63
63,64
63,65
63,66
64,65
66,67
66,68
66,69
67,68
70,71
72,73
73,74
75,76
76,77
76,78
78,79
78,80
78,81
81,82
82,83
84,85
85,86
85,87
86,87
88,89
88,90
90,91
91,92
93,94
93,95
94,95
94,96
95,96
97,98
97,99
98,99
100,101
100,102
101,102
104,105
105,106
105,107
105,108
106,107
109,110
111,112
112,113
112,114
113,114
115,116
115,117
115,118
115,119
115,120
116,117
118,119
120,121
122,123
124,125
125,126
127,128
127,129
128,129
128,130
129,130
131,132
133,134
134,135
134,136
134,137
135,136
138,139
140,141
140,142
141,142
142,143
144,145
145,146
145,147
145,148
146,147
149,150
151,152
151,153
152,153
153,154
153,155
153,156
154,155
156,157
158,159
160,161
162,163
163,164
163,165
164,165
164,166
164,167
164,168
165,166
167,168
169,170
171,172
173,174
173,175
174,175
175,176
175,177
175,178
176,177
179,180
181,182
183,184
183,185
184,185
184,186
185,186
186,187
186,188
186,189
186,190
186,191
187,188
189,190
191,192
193,194
195,196
197,198
197,199
197,200
197,201
198,199
200,201
202,203
204,205
206,207
207,208
207,209
207,210
208,209
208,210
209,210
211,212
213,214
214,215
214,216
215,216
215,217
216,217
218,219
218,220
218,221
219,220
222,223
224,225
224,226
225,226
226,227
226,228
226,229
227,228
230,231
232,233
234,235
234,236
235,236
236,237
236,238
236,239
237,238
240,241
242,243
244,245
244,246
245,246
245,247
246,247
248,249
248,250
249,250
251,252
253,254
255,256
256,257
256,258
257,258
259,260
261,262
262,263
262,264
263,264
265,266
265,267
265,268
265,269
265,270
265,271
265,272
265,273
266,267
268,269
270,271
272,273
274,275
277,278
279,280
280,281
282,283
282,284
283,284
284,285
286,287
286,288
286,289
287,288
288,289
288,290
288,291
288,292
288,293
289,290
292,293
294,295
296,297
296,298
297,298
300,301
301,302
301,303
302,303
304,305
305,306
307,308
309,310
310,311
310,312
310,313
311,312
313,314
313,315
314,315
317,318
319,320
319,321
320,321
320,322
320,323
320,324
321,322
323,324
325,326
327,328
329,330
329,331
330,331
331,332
331,333
331,334
332,333
335,336
337,338
339,340
341,342
341,343
343,344
344,345
344,346
345,346
347,348
347,349
347,350
347,351
347,352
347,353
347,354
347,355
348,349
350,351
352,353
354,355
356,357
359,360
361,362
362,363
364,365
364,366
365,366
366,367
368,369
368,370
368,371
369,370
370,371
370,372
370,373
370,374
371,372
374,375
376,377
376,378
377,378
380,381
381,382
381,383
382,383
384,385
385,386
387,388
389,390
390,391
390,392
391,392
393,394
395,396
396,397
396,398
397,398
400,401
400,402
401,402
401,403
401,404
401,405
402,403
404,405
406,407
408,409
410,411
411,412
411,413
411,414
412,413
415,416
417,418
418,419
418,420
419,420
421,422
423,424
423,425
425,426
425,427
426,427
426,428
427,428
429,430
429,431
429,432
430,431
432,433
432,434
432,435
433,434
436,437
438,439
438,440
438,441
439,440
442,443
444,445
445,446
445,447
445,448
445,449
445,450
446,447
449,450
451,452
453,454
453,455
454,455
456,457
458,459
459,460
-----nextToken-----
2,4,6,8,9,11,13,14,16,18,19,23,25,27,29,31,34,36,38,40,42,46,48,49,53,55,58,60,65,68,69,71,74,77,79,80,83,87,89,92,96,99,102,103,107,108,110,114,117,119,121,123,126,130,132,136,137,139,143,147,148,150,155,157,159,161,166,168,170,172,177,178,180,182,188,190,192,194,196,199,201,203,205,210,212,217,220,221,223,228,229,231,233,238,239,241,243,247,250,252,254,258,260,264,267,269,271,273,275,276,278,281,285,290,291,293,295,298,299,303,306,308,312,315,316,318,322,324,326,328,333,334,336,338,340,342,346,349,351,353,355,357,358,360,363,367,372,373,375,378,379,383,386,388,392,394,398,399,403,405,407,409,413,414,416,420,422,424,428,431,434,435,437,440,441,443,447,448,450,452,455,457,460
-----computeFrom-----
94,95
94,96
112,113
112,114
128,129
128,130
184,185
184,186
208,209
208,210
245,246
245,247
256,257
256,258
262,263
262,264
344,345
344,346
390,391
390,392
396,397
396,398
418,419
418,420
426,427
426,428
-----guardedBy-----
201,241
437,452
443,450
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;Declarator;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;UnaryExpression;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ReturnStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;ReturnStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ReturnStatement;LiteralExpression;ProblemStatement;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;GotoStatement;Name;IfStatement;BinaryExpression;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;GotoStatement;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;GotoStatement;Name;IfStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;GotoStatement;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;GotoStatement;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;GotoStatement;Name;ReturnStatement;LiteralExpression;LabelStatement;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;GotoStatement;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;LabelStatement;Name;IfStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ProblemStatement;ReturnStatement;LiteralExpression;
-----ast_node-----
int rename_ref(const char *oldrefname, const char *newrefname, const char *logmsg){	unsigned char sha1[20], orig_sha1[20];	int flag = 0, logmoved = 0;	struct ref_lock *lock;	struct stat loginfo;	int log = !lstat(git_path("logs/%s", oldrefname), &loginfo);	const char *symref = NULL;	struct strbuf err = STRBUF_INIT;	if (log && S_ISLNK(loginfo.st_mode))		return error("reflog for %s is a symlink", oldrefname);	symref = resolve_ref_unsafe(oldrefname, RESOLVE_REF_READING,				    orig_sha1, &flag);	if (flag & REF_ISSYMREF)		return error("refname %s is a symbolic ref, renaming it is not supported",			oldrefname);	if (!symref)		return error("refname %s not found", oldrefname);	if (!rename_ref_available(oldrefname, newrefname))		return 1;	if (log && rename(git_path("logs/%s", oldrefname), git_path(TMP_RENAMED_LOG)))		return error("unable to move logfile logs/%s to "TMP_RENAMED_LOG": %s",			oldrefname, strerror(errno));	if (delete_ref(oldrefname, orig_sha1, REF_NODEREF)) {		error("unable to delete old %s", oldrefname);		goto rollback;	}	if (!read_ref_full(newrefname, RESOLVE_REF_READING, sha1, NULL) &&	    delete_ref(newrefname, sha1, REF_NODEREF)) {		if (errno==EISDIR) {			if (remove_empty_directories(git_path("%s", newrefname))) {				error("Directory not empty: %s", newrefname);				goto rollback;			}		} else {			error("unable to delete existing %s", newrefname);			goto rollback;		}	}	if (log && rename_tmp_log(newrefname))		goto rollback;	logmoved = log;	lock = lock_ref_sha1_basic(newrefname, NULL, NULL, NULL, 0, NULL, &err);	if (!lock) {		error("unable to rename '%s' to '%s': %s", oldrefname, newrefname, err.buf);		strbuf_release(&err);		goto rollback;	}	hashcpy(lock->old_sha1, orig_sha1);	if (write_ref_sha1(lock, orig_sha1, logmsg)) {		error("unable to write current sha1 into %s", newrefname);		goto rollback;	}	return 0; rollback:	lock = lock_ref_sha1_basic(oldrefname, NULL, NULL, NULL, 0, NULL, &err);	if (!lock) {		error("unable to lock %s for rollback: %s", oldrefname, err.buf);		strbuf_release(&err);		goto rollbacklog;	}	flag = log_all_ref_updates;	log_all_ref_updates = 0;	if (write_ref_sha1(lock, orig_sha1, NULL))		error("unable to write current sha1 into %s", oldrefname);	log_all_ref_updates = flag; rollbacklog:	if (logmoved && rename(git_path("logs/%s", newrefname), git_path("logs/%s", oldrefname)))		error("unable to restore logfile %s from %s: %s",			oldrefname, newrefname, strerror(errno));	if (!logmoved && log &&	    rename(git_path(TMP_RENAMED_LOG), git_path("logs/%s", oldrefname)))		error("unable to restore logfile %s from "TMP_RENAMED_LOG": %s",			oldrefname, strerror(errno));	return 1;}
int
rename_ref(const char *oldrefname, const char *newrefname, const char *logmsg)
rename_ref
const char *oldrefname
const char
*oldrefname
*
oldrefname
const char *newrefname
const char
*newrefname
*
newrefname
const char *logmsg
const char
*logmsg
*
logmsg
{	unsigned char sha1[20], orig_sha1[20];	int flag = 0, logmoved = 0;	struct ref_lock *lock;	struct stat loginfo;	int log = !lstat(git_path("logs/%s", oldrefname), &loginfo);	const char *symref = NULL;	struct strbuf err = STRBUF_INIT;	if (log && S_ISLNK(loginfo.st_mode))		return error("reflog for %s is a symlink", oldrefname);	symref = resolve_ref_unsafe(oldrefname, RESOLVE_REF_READING,				    orig_sha1, &flag);	if (flag & REF_ISSYMREF)		return error("refname %s is a symbolic ref, renaming it is not supported",			oldrefname);	if (!symref)		return error("refname %s not found", oldrefname);	if (!rename_ref_available(oldrefname, newrefname))		return 1;	if (log && rename(git_path("logs/%s", oldrefname), git_path(TMP_RENAMED_LOG)))		return error("unable to move logfile logs/%s to "TMP_RENAMED_LOG": %s",			oldrefname, strerror(errno));	if (delete_ref(oldrefname, orig_sha1, REF_NODEREF)) {		error("unable to delete old %s", oldrefname);		goto rollback;	}	if (!read_ref_full(newrefname, RESOLVE_REF_READING, sha1, NULL) &&	    delete_ref(newrefname, sha1, REF_NODEREF)) {		if (errno==EISDIR) {			if (remove_empty_directories(git_path("%s", newrefname))) {				error("Directory not empty: %s", newrefname);				goto rollback;			}		} else {			error("unable to delete existing %s", newrefname);			goto rollback;		}	}	if (log && rename_tmp_log(newrefname))		goto rollback;	logmoved = log;	lock = lock_ref_sha1_basic(newrefname, NULL, NULL, NULL, 0, NULL, &err);	if (!lock) {		error("unable to rename '%s' to '%s': %s", oldrefname, newrefname, err.buf);		strbuf_release(&err);		goto rollback;	}	hashcpy(lock->old_sha1, orig_sha1);	if (write_ref_sha1(lock, orig_sha1, logmsg)) {		error("unable to write current sha1 into %s", newrefname);		goto rollback;	}	return 0; rollback:	lock = lock_ref_sha1_basic(oldrefname, NULL, NULL, NULL, 0, NULL, &err);	if (!lock) {		error("unable to lock %s for rollback: %s", oldrefname, err.buf);		strbuf_release(&err);		goto rollbacklog;	}	flag = log_all_ref_updates;	log_all_ref_updates = 0;	if (write_ref_sha1(lock, orig_sha1, NULL))		error("unable to write current sha1 into %s", oldrefname);	log_all_ref_updates = flag; rollbacklog:	if (logmoved && rename(git_path("logs/%s", newrefname), git_path("logs/%s", oldrefname)))		error("unable to restore logfile %s from %s: %s",			oldrefname, newrefname, strerror(errno));	if (!logmoved && log &&	    rename(git_path(TMP_RENAMED_LOG), git_path("logs/%s", oldrefname)))		error("unable to restore logfile %s from "TMP_RENAMED_LOG": %s",			oldrefname, strerror(errno));	return 1;}
unsigned char sha1[20], orig_sha1[20];
unsigned char sha1[20], orig_sha1[20];
unsigned char
sha1[20]
sha1
[20]
20
orig_sha1[20]
orig_sha1
[20]
20
int flag = 0, logmoved = 0;
int flag = 0, logmoved = 0;
int
flag = 0
flag
= 0
0
logmoved = 0
logmoved
= 0
0
struct ref_lock *lock;
struct ref_lock *lock;
struct ref_lock
ref_lock
*lock
*
lock
struct stat loginfo;
struct stat loginfo;
struct stat
stat
loginfo
loginfo
int log = !lstat(git_path("logs/%s", oldrefname), &loginfo);
int log = !lstat(git_path("logs/%s", oldrefname), &loginfo);
int
log = !lstat(git_path("logs/%s", oldrefname), &loginfo)
log
= !lstat(git_path("logs/%s", oldrefname), &loginfo)
!lstat(git_path("logs/%s", oldrefname), &loginfo)
lstat(git_path("logs/%s", oldrefname), &loginfo)
lstat
lstat
git_path("logs/%s", oldrefname)
git_path
git_path
"logs/%s"
oldrefname
oldrefname
&loginfo
loginfo
loginfo
const char *symref = NULL;
const char *symref = NULL;
const char
*symref = NULL
*
symref
= NULL
NULL
NULL
struct strbuf err = STRBUF_INIT;
struct strbuf err = STRBUF_INIT;
struct strbuf
strbuf
err = STRBUF_INIT
err
= STRBUF_INIT
STRBUF_INIT
STRBUF_INIT
if (log && S_ISLNK(loginfo.st_mode))		return error("reflog for %s is a symlink", oldrefname);
log && S_ISLNK(loginfo.st_mode)
log
log
S_ISLNK(loginfo.st_mode)
S_ISLNK
S_ISLNK
loginfo.st_mode
loginfo
loginfo
st_mode
return error("reflog for %s is a symlink", oldrefname);
error("reflog for %s is a symlink", oldrefname)
error
error
"reflog for %s is a symlink"
oldrefname
oldrefname
symref = resolve_ref_unsafe(oldrefname, RESOLVE_REF_READING,				    orig_sha1, &flag);
symref = resolve_ref_unsafe(oldrefname, RESOLVE_REF_READING,				    orig_sha1, &flag)
symref
symref
resolve_ref_unsafe(oldrefname, RESOLVE_REF_READING,				    orig_sha1, &flag)
resolve_ref_unsafe
resolve_ref_unsafe
oldrefname
oldrefname
RESOLVE_REF_READING
RESOLVE_REF_READING
orig_sha1
orig_sha1
&flag
flag
flag
if (flag & REF_ISSYMREF)		return error("refname %s is a symbolic ref, renaming it is not supported",			oldrefname);
flag & REF_ISSYMREF
flag
flag
REF_ISSYMREF
REF_ISSYMREF
return error("refname %s is a symbolic ref, renaming it is not supported",			oldrefname);
error("refname %s is a symbolic ref, renaming it is not supported",			oldrefname)
error
error
"refname %s is a symbolic ref, renaming it is not supported"
oldrefname
oldrefname
if (!symref)		return error("refname %s not found", oldrefname);
!symref
symref
symref
return error("refname %s not found", oldrefname);
error("refname %s not found", oldrefname)
error
error
"refname %s not found"
oldrefname
oldrefname
if (!rename_ref_available(oldrefname, newrefname))		return 1;
!rename_ref_available(oldrefname, newrefname)
rename_ref_available(oldrefname, newrefname)
rename_ref_available
rename_ref_available
oldrefname
oldrefname
newrefname
newrefname
return 1;
1
if (log && rename(git_path("logs/%s", oldrefname), git_path(TMP_RENAMED_LOG)))		return error("unable to move logfile logs/%s to "TMP_RENAMED_LOG": %s",			oldrefname, strerror(errno));
if (delete_ref(oldrefname, orig_sha1, REF_NODEREF)) {		error("unable to delete old %s", oldrefname);		goto rollback;	}
delete_ref(oldrefname, orig_sha1, REF_NODEREF)
delete_ref
delete_ref
oldrefname
oldrefname
orig_sha1
orig_sha1
REF_NODEREF
REF_NODEREF
{		error("unable to delete old %s", oldrefname);		goto rollback;	}
error("unable to delete old %s", oldrefname);
error("unable to delete old %s", oldrefname)
error
error
"unable to delete old %s"
oldrefname
oldrefname
goto rollback;
rollback
if (!read_ref_full(newrefname, RESOLVE_REF_READING, sha1, NULL) &&	    delete_ref(newrefname, sha1, REF_NODEREF)) {		if (errno==EISDIR) {			if (remove_empty_directories(git_path("%s", newrefname))) {				error("Directory not empty: %s", newrefname);				goto rollback;			}		} else {			error("unable to delete existing %s", newrefname);			goto rollback;		}	}
!read_ref_full(newrefname, RESOLVE_REF_READING, sha1, NULL) &&	    delete_ref(newrefname, sha1, REF_NODEREF)
!read_ref_full(newrefname, RESOLVE_REF_READING, sha1, NULL)
read_ref_full(newrefname, RESOLVE_REF_READING, sha1, NULL)
read_ref_full
read_ref_full
newrefname
newrefname
RESOLVE_REF_READING
RESOLVE_REF_READING
sha1
sha1
NULL
NULL
delete_ref(newrefname, sha1, REF_NODEREF)
delete_ref
delete_ref
newrefname
newrefname
sha1
sha1
REF_NODEREF
REF_NODEREF
{		if (errno==EISDIR) {			if (remove_empty_directories(git_path("%s", newrefname))) {				error("Directory not empty: %s", newrefname);				goto rollback;			}		} else {			error("unable to delete existing %s", newrefname);			goto rollback;		}	}
if (errno==EISDIR) {			if (remove_empty_directories(git_path("%s", newrefname))) {				error("Directory not empty: %s", newrefname);				goto rollback;			}		} else {			error("unable to delete existing %s", newrefname);			goto rollback;		}
errno==EISDIR
errno
errno
EISDIR
EISDIR
{			if (remove_empty_directories(git_path("%s", newrefname))) {				error("Directory not empty: %s", newrefname);				goto rollback;			}		}
if (remove_empty_directories(git_path("%s", newrefname))) {				error("Directory not empty: %s", newrefname);				goto rollback;			}
remove_empty_directories(git_path("%s", newrefname))
remove_empty_directories
remove_empty_directories
git_path("%s", newrefname)
git_path
git_path
"%s"
newrefname
newrefname
{				error("Directory not empty: %s", newrefname);				goto rollback;			}
error("Directory not empty: %s", newrefname);
error("Directory not empty: %s", newrefname)
error
error
"Directory not empty: %s"
newrefname
newrefname
goto rollback;
rollback
{			error("unable to delete existing %s", newrefname);			goto rollback;		}
error("unable to delete existing %s", newrefname);
error("unable to delete existing %s", newrefname)
error
error
"unable to delete existing %s"
newrefname
newrefname
goto rollback;
rollback
if (log && rename_tmp_log(newrefname))		goto rollback;
log && rename_tmp_log(newrefname)
log
log
rename_tmp_log(newrefname)
rename_tmp_log
rename_tmp_log
newrefname
newrefname
goto rollback;
rollback
logmoved = log;
logmoved = log
logmoved
logmoved
log
log
lock = lock_ref_sha1_basic(newrefname, NULL, NULL, NULL, 0, NULL, &err);
lock = lock_ref_sha1_basic(newrefname, NULL, NULL, NULL, 0, NULL, &err)
lock
lock
lock_ref_sha1_basic(newrefname, NULL, NULL, NULL, 0, NULL, &err)
lock_ref_sha1_basic
lock_ref_sha1_basic
newrefname
newrefname
NULL
NULL
NULL
NULL
NULL
NULL
0
NULL
NULL
&err
err
err
if (!lock) {		error("unable to rename '%s' to '%s': %s", oldrefname, newrefname, err.buf);		strbuf_release(&err);		goto rollback;	}
!lock
lock
lock
{		error("unable to rename '%s' to '%s': %s", oldrefname, newrefname, err.buf);		strbuf_release(&err);		goto rollback;	}
error("unable to rename '%s' to '%s': %s", oldrefname, newrefname, err.buf);
error("unable to rename '%s' to '%s': %s", oldrefname, newrefname, err.buf)
error
error
"unable to rename '%s' to '%s': %s"
oldrefname
oldrefname
newrefname
newrefname
err.buf
err
err
buf
strbuf_release(&err);
strbuf_release(&err)
strbuf_release
strbuf_release
&err
err
err
goto rollback;
rollback
hashcpy(lock->old_sha1, orig_sha1);
hashcpy(lock->old_sha1, orig_sha1)
hashcpy
hashcpy
lock->old_sha1
lock
lock
old_sha1
orig_sha1
orig_sha1
if (write_ref_sha1(lock, orig_sha1, logmsg)) {		error("unable to write current sha1 into %s", newrefname);		goto rollback;	}
write_ref_sha1(lock, orig_sha1, logmsg)
write_ref_sha1
write_ref_sha1
lock
lock
orig_sha1
orig_sha1
logmsg
logmsg
{		error("unable to write current sha1 into %s", newrefname);		goto rollback;	}
error("unable to write current sha1 into %s", newrefname);
error("unable to write current sha1 into %s", newrefname)
error
error
"unable to write current sha1 into %s"
newrefname
newrefname
goto rollback;
rollback
return 0;
0
rollback:	lock = lock_ref_sha1_basic(oldrefname, NULL, NULL, NULL, 0, NULL, &err);
rollback
lock = lock_ref_sha1_basic(oldrefname, NULL, NULL, NULL, 0, NULL, &err);
lock = lock_ref_sha1_basic(oldrefname, NULL, NULL, NULL, 0, NULL, &err)
lock
lock
lock_ref_sha1_basic(oldrefname, NULL, NULL, NULL, 0, NULL, &err)
lock_ref_sha1_basic
lock_ref_sha1_basic
oldrefname
oldrefname
NULL
NULL
NULL
NULL
NULL
NULL
0
NULL
NULL
&err
err
err
if (!lock) {		error("unable to lock %s for rollback: %s", oldrefname, err.buf);		strbuf_release(&err);		goto rollbacklog;	}
!lock
lock
lock
{		error("unable to lock %s for rollback: %s", oldrefname, err.buf);		strbuf_release(&err);		goto rollbacklog;	}
error("unable to lock %s for rollback: %s", oldrefname, err.buf);
error("unable to lock %s for rollback: %s", oldrefname, err.buf)
error
error
"unable to lock %s for rollback: %s"
oldrefname
oldrefname
err.buf
err
err
buf
strbuf_release(&err);
strbuf_release(&err)
strbuf_release
strbuf_release
&err
err
err
goto rollbacklog;
rollbacklog
flag = log_all_ref_updates;
flag = log_all_ref_updates
flag
flag
log_all_ref_updates
log_all_ref_updates
log_all_ref_updates = 0;
log_all_ref_updates = 0
log_all_ref_updates
log_all_ref_updates
0
if (write_ref_sha1(lock, orig_sha1, NULL))		error("unable to write current sha1 into %s", oldrefname);
write_ref_sha1(lock, orig_sha1, NULL)
write_ref_sha1
write_ref_sha1
lock
lock
orig_sha1
orig_sha1
NULL
NULL
error("unable to write current sha1 into %s", oldrefname);
error("unable to write current sha1 into %s", oldrefname)
error
error
"unable to write current sha1 into %s"
oldrefname
oldrefname
log_all_ref_updates = flag;
log_all_ref_updates = flag
log_all_ref_updates
log_all_ref_updates
flag
flag
rollbacklog:	if (logmoved && rename(git_path("logs/%s", newrefname), git_path("logs/%s", oldrefname)))		error("unable to restore logfile %s from %s: %s",			oldrefname, newrefname, strerror(errno));
rollbacklog
if (logmoved && rename(git_path("logs/%s", newrefname), git_path("logs/%s", oldrefname)))		error("unable to restore logfile %s from %s: %s",			oldrefname, newrefname, strerror(errno));
logmoved && rename(git_path("logs/%s", newrefname), git_path("logs/%s", oldrefname))
logmoved
logmoved
rename(git_path("logs/%s", newrefname), git_path("logs/%s", oldrefname))
rename
rename
git_path("logs/%s", newrefname)
git_path
git_path
"logs/%s"
newrefname
newrefname
git_path("logs/%s", oldrefname)
git_path
git_path
"logs/%s"
oldrefname
oldrefname
error("unable to restore logfile %s from %s: %s",			oldrefname, newrefname, strerror(errno));
error("unable to restore logfile %s from %s: %s",			oldrefname, newrefname, strerror(errno))
error
error
"unable to restore logfile %s from %s: %s"
oldrefname
oldrefname
newrefname
newrefname
strerror(errno)
strerror
strerror
errno
errno
if (!logmoved && log &&	    rename(git_path(TMP_RENAMED_LOG), git_path("logs/%s", oldrefname)))		error("unable to restore logfile %s from "TMP_RENAMED_LOG": %s",			oldrefname, strerror(errno));
return 1;
1
-----joern-----
(46,48,0)
(236,120,0)
(131,234,0)
(252,0,0)
(155,46,0)
(134,172,0)
(186,59,0)
(77,172,0)
(69,33,0)
(241,235,0)
(96,118,0)
(257,213,0)
(5,201,0)
(64,1,0)
(11,33,0)
(120,210,0)
(264,172,0)
(200,213,0)
(128,139,0)
(257,47,0)
(69,172,0)
(120,235,0)
(234,187,0)
(41,38,0)
(209,187,0)
(185,149,0)
(118,96,0)
(171,172,0)
(180,120,0)
(130,94,0)
(113,8,0)
(227,111,0)
(133,47,0)
(13,40,0)
(67,241,0)
(106,150,0)
(201,235,0)
(110,172,0)
(22,241,0)
(215,172,0)
(218,69,0)
(52,223,0)
(34,201,0)
(50,262,0)
(122,244,0)
(188,204,0)
(72,33,0)
(216,8,0)
(152,120,0)
(207,37,0)
(45,129,0)
(20,264,0)
(219,31,0)
(251,155,0)
(73,262,0)
(32,41,0)
(36,45,0)
(126,33,0)
(150,1,0)
(156,7,0)
(231,85,0)
(85,172,0)
(68,18,0)
(211,161,0)
(18,68,0)
(262,14,0)
(161,1,0)
(139,204,0)
(44,161,0)
(122,235,0)
(214,155,0)
(226,113,0)
(8,172,0)
(195,101,0)
(146,156,0)
(9,8,0)
(157,166,0)
(84,261,0)
(210,120,0)
(149,173,0)
(210,172,0)
(228,162,0)
(181,33,0)
(199,47,0)
(121,119,0)
(246,77,0)
(107,172,0)
(38,19,0)
(15,187,0)
(175,156,0)
(220,91,0)
(213,257,0)
(99,59,0)
(37,7,0)
(114,8,0)
(30,172,0)
(35,218,0)
(237,173,0)
(187,172,0)
(169,217,0)
(132,201,0)
(39,172,0)
(197,77,0)
(199,118,0)
(230,217,0)
(141,114,0)
(173,237,0)
(154,59,0)
(258,71,0)
(163,227,0)
(98,170,0)
(262,113,0)
(164,172,0)
(119,164,0)
(222,53,0)
(26,172,0)
(247,172,0)
(143,60,0)
(25,172,0)
(192,172,0)
(117,151,0)
(156,175,0)
(191,77,0)
(145,37,0)
(264,47,0)
(170,84,0)
(254,104,0)
(195,115,0)
(149,235,0)
(263,113,0)
(243,235,0)
(46,155,0)
(3,108,0)
(0,21,0)
(90,172,0)
(232,174,0)
(137,111,0)
(118,199,0)
(1,201,0)
(89,172,0)
(109,202,0)
(59,7,0)
(220,235,0)
(47,237,0)
(225,27,0)
(33,7,0)
(249,52,0)
(129,45,0)
(71,235,0)
(184,41,0)
(116,164,0)
(83,142,0)
(15,264,0)
(58,101,0)
(92,52,0)
(13,158,0)
(177,220,0)
(205,261,0)
(208,71,0)
(87,142,0)
(153,261,0)
(151,172,0)
(16,100,0)
(136,114,0)
(142,235,0)
(27,210,0)
(29,69,0)
(13,229,0)
(147,202,0)
(86,161,0)
(175,8,0)
(33,69,0)
(103,59,0)
(48,46,0)
(61,172,0)
(45,235,0)
(54,149,0)
(221,115,0)
(62,218,0)
(125,31,0)
(23,37,0)
(220,7,0)
(63,264,0)
(19,59,0)
(13,159,0)
(259,243,0)
(241,67,0)
(96,235,0)
(119,172,0)
(13,198,0)
(84,15,0)
(66,158,0)
(227,7,0)
(127,21,0)
(80,241,0)
(41,7,0)
(253,119,0)
(91,220,0)
(201,1,0)
(242,220,0)
(241,7,0)
(78,55,0)
(261,84,0)
(100,218,0)
(155,235,0)
(139,7,0)
(53,85,0)
(239,96,0)
(240,120,0)
(260,41,0)
(56,139,0)
(53,172,0)
(105,172,0)
(183,101,0)
(170,7,0)
(43,172,0)
(18,166,0)
(48,47,0)
(248,191,0)
(237,47,0)
(217,198,0)
(120,236,0)
(75,67,0)
(15,84,0)
(74,257,0)
(10,191,0)
(203,172,0)
(233,175,0)
(142,40,0)
(131,48,0)
(79,42,0)
(236,77,0)
(46,190,0)
(136,14,0)
(201,94,0)
(53,119,0)
(173,149,0)
(245,68,0)
(178,85,0)
(234,264,0)
(234,131,0)
(148,172,0)
(115,195,0)
(213,7,0)
(4,96,0)
(95,170,0)
(202,55,0)
(224,210,0)
(173,174,0)
(100,172,0)
(52,69,0)
(158,172,0)
(262,235,0)
(140,234,0)
(94,201,0)
(37,145,0)
(156,235,0)
(24,201,0)
(17,15,0)
(118,108,0)
(202,7,0)
(115,47,0)
(174,173,0)
(189,164,0)
(250,122,0)
(13,53,0)
(47,172,0)
(156,166,0)
(168,201,0)
(114,136,0)
(176,144,0)
(255,172,0)
(101,195,0)
(49,243,0)
(212,199,0)
(217,235,0)
(190,46,0)
(124,172,0)
(19,38,0)
(45,229,0)
(68,8,0)
(238,156,0)
(193,175,0)
(165,172,0)
(97,241,0)
(138,227,0)
(13,244,0)
(70,172,0)
(261,235,0)
(182,104,0)
(196,48,0)
(218,100,0)
(42,69,0)
(256,52,0)
(21,235,0)
(76,254,0)
(2,190,0)
(82,201,0)
(28,33,0)
(206,187,0)
(60,8,0)
(84,170,0)
(160,236,0)
(167,159,0)
(113,262,0)
(94,8,0)
(93,151,0)
(21,0,0)
(38,41,0)
(179,14,0)
(48,131,0)
(1,172,0)
(112,71,0)
(6,45,0)
(59,19,0)
(81,172,0)
(12,172,0)
(51,122,0)
(102,156,0)
(60,33,0)
(88,172,0)
(254,235,0)
(108,118,0)
(65,21,0)
(194,254,0)
(135,129,0)
(123,33,0)
(33,60,0)
(64,157,1)
(240,180,1)
(48,196,1)
(100,218,1)
(149,235,1)
(222,131,1)
(198,217,1)
(220,7,1)
(68,8,1)
(73,150,1)
(262,113,1)
(56,128,1)
(115,47,1)
(237,173,1)
(75,22,1)
(151,93,1)
(113,8,1)
(96,235,1)
(191,10,1)
(64,57,1)
(256,92,1)
(53,119,1)
(15,187,1)
(140,15,1)
(19,59,1)
(125,219,1)
(181,29,1)
(38,19,1)
(195,101,1)
(175,8,1)
(87,27,1)
(27,210,1)
(130,5,1)
(29,264,1)
(155,251,1)
(64,182,1)
(173,149,1)
(190,2,1)
(102,42,1)
(71,208,1)
(35,42,1)
(50,73,1)
(1,201,1)
(94,130,1)
(241,235,1)
(145,37,1)
(205,153,1)
(210,120,1)
(59,186,1)
(118,96,1)
(114,8,1)
(155,235,1)
(244,122,1)
(42,69,1)
(220,235,1)
(253,121,1)
(79,69,1)
(157,18,1)
(45,129,1)
(5,24,1)
(201,94,1)
(62,35,1)
(200,74,1)
(132,64,1)
(147,109,1)
(261,235,1)
(170,7,1)
(146,102,1)
(74,145,1)
(52,249,1)
(143,123,1)
(33,60,1)
(34,132,1)
(27,225,1)
(128,52,1)
(4,239,1)
(117,47,1)
(97,15,1)
(257,47,1)
(234,264,1)
(234,187,1)
(257,74,1)
(212,91,1)
(119,253,1)
(13,158,1)
(160,240,1)
(47,237,1)
(139,56,1)
(214,190,1)
(98,95,1)
(17,119,1)
(60,143,1)
(208,112,1)
(245,156,1)
(115,221,1)
(220,177,1)
(178,164,1)
(207,23,1)
(96,4,1)
(156,7,1)
(167,91,1)
(64,78,1)
(225,191,1)
(114,141,1)
(59,7,1)
(67,75,1)
(83,87,1)
(142,235,1)
(161,1,1)
(57,257,1)
(153,170,1)
(71,235,1)
(49,259,1)
(11,126,1)
(135,36,1)
(126,181,1)
(65,131,1)
(219,38,1)
(257,213,1)
(16,218,1)
(156,235,1)
(230,191,1)
(44,85,1)
(224,115,1)
(63,20,1)
(41,7,1)
(86,211,1)
(93,117,1)
(69,33,1)
(231,178,1)
(150,106,1)
(13,40,1)
(196,234,1)
(138,145,1)
(37,7,1)
(120,235,1)
(263,226,1)
(15,84,1)
(242,27,1)
(139,7,1)
(179,136,1)
(18,68,1)
(76,194,1)
(156,175,1)
(121,161,1)
(42,79,1)
(40,142,1)
(28,72,1)
(194,71,1)
(227,163,1)
(254,76,1)
(15,17,1)
(259,161,1)
(209,206,1)
(202,7,1)
(48,46,1)
(173,174,1)
(108,3,1)
(239,212,1)
(24,82,1)
(213,7,1)
(169,230,1)
(119,164,1)
(95,17,1)
(17,179,1)
(0,252,1)
(232,149,1)
(241,7,1)
(85,231,1)
(170,98,1)
(72,11,1)
(122,250,1)
(31,125,1)
(163,138,1)
(222,21,1)
(53,222,1)
(213,200,1)
(131,48,1)
(121,243,1)
(46,190,1)
(199,212,1)
(13,198,1)
(22,80,1)
(140,241,1)
(226,50,1)
(66,52,1)
(23,31,1)
(45,235,1)
(64,137,1)
(13,244,1)
(261,205,1)
(51,115,1)
(262,235,1)
(33,7,1)
(21,0,1)
(77,246,1)
(184,19,1)
(218,62,1)
(258,199,1)
(3,96,1)
(78,202,1)
(243,235,1)
(133,187,1)
(101,183,1)
(136,114,1)
(217,235,1)
(141,262,1)
(21,235,1)
(175,193,1)
(92,100,1)
(227,7,1)
(116,189,1)
(127,65,1)
(206,77,1)
(218,69,1)
(53,85,1)
(13,159,1)
(129,135,1)
(36,6,1)
(52,69,1)
(48,47,1)
(152,224,1)
(264,47,1)
(2,196,1)
(123,28,1)
(186,103,1)
(201,235,1)
(8,9,1)
(32,260,1)
(52,223,1)
(58,221,1)
(9,216,1)
(250,51,1)
(68,245,1)
(15,264,1)
(120,236,1)
(20,257,1)
(158,66,1)
(82,168,1)
(174,232,1)
(185,133,1)
(241,67,1)
(103,99,1)
(122,235,1)
(199,118,1)
(182,254,1)
(251,214,1)
(236,77,1)
(159,167,1)
(118,108,1)
(10,248,1)
(113,263,1)
(168,34,1)
(91,220,1)
(112,258,1)
(211,44,1)
(84,261,1)
(243,49,1)
(161,86,1)
(137,227,1)
(217,169,1)
(202,147,1)
(238,146,1)
(74,38,1)
(233,238,1)
(38,41,1)
(106,1,1)
(216,151,1)
(264,63,1)
(188,139,1)
(54,185,1)
(221,8,1)
(236,160,1)
(94,8,1)
(13,53,1)
(64,188,1)
(80,97,1)
(187,209,1)
(177,242,1)
(99,154,1)
(60,8,1)
(164,116,1)
(249,256,1)
(254,235,1)
(154,71,1)
(142,83,1)
(180,152,1)
(248,210,1)
(100,16,1)
(13,229,1)
(6,199,1)
(199,47,1)
(234,140,1)
(252,127,1)
(229,45,1)
(191,77,1)
(37,207,1)
(131,234,1)
(150,1,1)
(115,195,1)
(149,54,1)
(260,184,1)
(84,170,1)
(183,58,1)
(193,233,1)
(41,32,1)
(246,197,1)
(109,31,1)
(46,155,1)
(189,150,1)
(138,145,2)
(173,174,2)
(153,17,2)
(57,257,2)
(27,191,2)
(32,19,2)
(13,159,2)
(66,52,2)
(130,31,2)
(17,31,2)
(48,46,2)
(201,94,2)
(222,42,2)
(106,71,2)
(103,71,2)
(156,42,2)
(264,47,2)
(227,7,2)
(94,42,2)
(257,47,2)
(80,15,2)
(53,31,2)
(241,7,2)
(178,150,2)
(119,164,2)
(27,210,2)
(140,52,2)
(82,42,2)
(19,71,2)
(72,257,2)
(132,52,2)
(217,235,2)
(150,1,2)
(0,131,2)
(113,150,2)
(260,19,2)
(102,42,2)
(131,145,2)
(181,257,2)
(52,69,2)
(241,67,2)
(257,145,2)
(131,42,2)
(1,145,2)
(84,170,2)
(118,212,2)
(6,199,2)
(46,196,2)
(1,71,2)
(193,42,2)
(217,191,2)
(94,71,2)
(145,31,2)
(41,19,2)
(53,119,2)
(179,150,2)
(17,42,2)
(161,150,2)
(68,42,2)
(146,42,2)
(118,108,2)
(47,237,2)
(140,71,2)
(1,257,2)
(36,199,2)
(106,31,2)
(175,8,2)
(5,145,2)
(48,234,2)
(150,42,2)
(62,42,2)
(234,31,2)
(87,27,2)
(15,257,2)
(254,235,2)
(127,131,2)
(100,218,2)
(52,223,2)
(139,52,2)
(132,71,2)
(186,71,2)
(262,150,2)
(167,91,2)
(137,145,2)
(170,7,2)
(10,115,2)
(17,52,2)
(142,235,2)
(130,257,2)
(234,71,2)
(45,199,2)
(226,150,2)
(261,17,2)
(13,53,2)
(150,71,2)
(99,71,2)
(71,235,2)
(73,150,2)
(155,196,2)
(182,71,2)
(60,8,2)
(46,190,2)
(17,145,2)
(239,212,2)
(34,31,2)
(131,52,2)
(256,42,2)
(119,150,2)
(168,71,2)
(53,85,2)
(161,1,2)
(169,191,2)
(212,91,2)
(13,198,2)
(64,145,2)
(254,71,2)
(222,145,2)
(114,8,2)
(53,52,2)
(69,33,2)
(97,15,2)
(120,115,2)
(201,235,2)
(168,31,2)
(150,145,2)
(64,42,2)
(53,42,2)
(242,27,2)
(76,71,2)
(257,213,2)
(201,52,2)
(24,31,2)
(65,131,2)
(224,115,2)
(234,187,2)
(53,71,2)
(130,52,2)
(38,41,2)
(115,47,2)
(220,235,2)
(157,42,2)
(177,27,2)
(234,145,2)
(163,145,2)
(135,199,2)
(199,91,2)
(94,257,2)
(145,37,2)
(51,115,2)
(78,31,2)
(33,60,2)
(31,38,2)
(154,71,2)
(82,31,2)
(147,31,2)
(264,257,2)
(11,257,2)
(160,115,2)
(101,221,2)
(156,175,2)
(210,120,2)
(128,52,2)
(194,71,2)
(131,257,2)
(130,145,2)
(45,235,2)
(207,31,2)
(49,161,2)
(189,150,2)
(21,131,2)
(190,196,2)
(17,71,2)
(183,221,2)
(122,235,2)
(123,257,2)
(262,113,2)
(29,257,2)
(222,71,2)
(108,212,2)
(46,155,2)
(164,150,2)
(34,42,2)
(240,115,2)
(227,145,2)
(191,115,2)
(113,8,2)
(168,257,2)
(106,42,2)
(248,115,2)
(21,0,2)
(168,52,2)
(24,52,2)
(28,257,2)
(48,47,2)
(100,42,2)
(122,115,2)
(15,145,2)
(83,27,2)
(37,7,2)
(156,7,2)
(34,52,2)
(2,196,2)
(158,52,2)
(263,150,2)
(67,15,2)
(175,42,2)
(140,257,2)
(236,77,2)
(92,42,2)
(202,7,2)
(5,31,2)
(120,235,2)
(213,7,2)
(1,31,2)
(261,235,2)
(243,235,2)
(241,15,2)
(252,131,2)
(262,235,2)
(15,42,2)
(150,52,2)
(173,149,2)
(15,84,2)
(40,27,2)
(142,27,2)
(21,235,2)
(38,71,2)
(243,161,2)
(94,31,2)
(141,150,2)
(129,199,2)
(34,71,2)
(249,42,2)
(234,52,2)
(140,42,2)
(15,187,2)
(131,234,2)
(96,212,2)
(152,115,2)
(222,52,2)
(225,191,2)
(149,235,2)
(201,257,2)
(59,7,2)
(140,145,2)
(132,42,2)
(131,71,2)
(214,196,2)
(155,235,2)
(60,257,2)
(18,42,2)
(13,158,2)
(109,31,2)
(150,31,2)
(42,69,2)
(195,221,2)
(230,191,2)
(86,150,2)
(132,257,2)
(74,145,2)
(116,150,2)
(231,150,2)
(41,7,2)
(180,115,2)
(53,145,2)
(59,71,2)
(244,115,2)
(16,42,2)
(63,257,2)
(24,145,2)
(118,96,2)
(15,71,2)
(95,17,2)
(220,7,2)
(131,48,2)
(44,150,2)
(38,19,2)
(13,244,2)
(236,115,2)
(15,52,2)
(34,145,2)
(4,212,2)
(234,257,2)
(75,15,2)
(24,42,2)
(210,115,2)
(126,257,2)
(17,257,2)
(219,38,2)
(42,257,2)
(33,7,2)
(84,17,2)
(218,42,2)
(82,71,2)
(71,199,2)
(168,145,2)
(85,150,2)
(121,150,2)
(136,150,2)
(245,42,2)
(143,257,2)
(241,235,2)
(253,150,2)
(205,17,2)
(22,15,2)
(130,71,2)
(64,257,2)
(18,68,2)
(15,264,2)
(233,42,2)
(112,199,2)
(258,199,2)
(150,257,2)
(132,31,2)
(84,261,2)
(64,31,2)
(94,8,2)
(5,257,2)
(82,257,2)
(201,42,2)
(106,52,2)
(250,115,2)
(196,234,2)
(191,77,2)
(170,17,2)
(156,235,2)
(211,150,2)
(139,7,2)
(220,27,2)
(98,17,2)
(140,31,2)
(120,236,2)
(1,52,2)
(68,8,2)
(15,31,2)
(136,114,2)
(106,257,2)
(23,31,2)
(184,19,2)
(5,42,2)
(199,47,2)
(24,71,2)
(208,199,2)
(114,150,2)
(19,59,2)
(229,199,2)
(200,74,2)
(202,31,2)
(24,257,2)
(58,221,2)
(74,38,2)
(5,71,2)
(64,52,2)
(33,257,2)
(20,257,2)
(13,40,2)
(198,191,2)
(82,145,2)
(45,129,2)
(96,235,2)
(50,150,2)
(53,257,2)
(1,201,2)
(218,69,2)
(52,42,2)
(201,31,2)
(91,220,2)
(201,145,2)
(1,42,2)
(234,42,2)
(259,161,2)
(34,257,2)
(188,52,2)
(5,52,2)
(3,212,2)
(13,229,2)
(195,101,2)
(35,42,2)
(115,195,2)
(257,38,2)
(222,257,2)
(201,71,2)
(131,31,2)
(159,91,2)
(37,31,2)
(79,257,2)
(234,264,2)
(82,52,2)
(238,42,2)
(91,27,2)
(213,74,2)
(168,42,2)
(69,257,2)
(125,38,2)
(237,173,2)
(130,42,2)
(132,145,2)
(222,31,2)
(106,145,2)
(64,71,2)
(56,52,2)
(94,145,2)
(251,196,2)
(94,52,2)
(199,118,2)
-----------------------------------
(0,strerror(errno)
(1,lock = lock_ref_sha1_basic(oldrefname, NULL, NULL, NULL, 0, NULL, &err)
(2,TMP_RENAMED_LOG)
(3,TMP_RENAMED_LOG)
(4,oldrefname)
(5,NULL)
(6,"unable to move logfile logs/%s to "TMP_RENAMED_LOG": %s")
(7,const char *newrefname)
(8,err = STRBUF_INIT)
(9,STRBUF_INIT)
(10,REF_ISSYMREF)
(11,NULL)
(12,orig_sha1)
(13,RET)
(14,)
(15,logmoved && rename(git_path("logs/%s", newrefname)
(16,orig_sha1)
(17,logmoved)
(18,strbuf_release(&err)
(19,!read_ref_full(newrefname, RESOLVE_REF_READING, sha1, NULL)
(20,logmoved)
(21,error("unable to restore logfile %s from "TMP_RENAMED_LOG": %s",\n\\n\\t\\t\\toldrefname, strerror(errno)
(22,newrefname)
(23,"%s")
(24,0)
(25,sha1)
(26,if (write_ref_sha1(lock, orig_sha1, NULL)
(27,!symref)
(28,0)
(29,lock)
(30,log)
(31,errno==EISDIR)
(32,REF_NODEREF)
(33,lock_ref_sha1_basic(newrefname, NULL, NULL, NULL, 0, NULL, &err)
(34,NULL)
(35,lock)
(36,oldrefname)
(37,git_path("%s", newrefname)
(38,!read_ref_full(newrefname, RESOLVE_REF_READING, sha1, NULL)
(39,rollback:)
(40,return error("refname %s not found", oldrefname)
(41,delete_ref(newrefname, sha1, REF_NODEREF)
(42,!lock)
(43,if (delete_ref(oldrefname, orig_sha1, REF_NODEREF)
(44,lock)
(45,error("unable to move logfile logs/%s to "TMP_RENAMED_LOG": %s",\n\\n\\t\\t\\toldrefname, strerror(errno)
(46,rename(git_path(TMP_RENAMED_LOG)
(47,log = !lstat(git_path("logs/%s", oldrefname)
(48,log &&\n\\n\\t    rename(git_path(TMP_RENAMED_LOG)
(49,oldrefname)
(50,oldrefname)
(51,"reflog for %s is a symlink")
(52,write_ref_sha1(lock, orig_sha1, logmsg)
(53,return 1;)
(54,oldrefname)
(55,)
(56,newrefname)
(57,goto rollback;)
(58,loginfo)
(59,read_ref_full(newrefname, RESOLVE_REF_READING, sha1, NULL)
(60,&err)
(61,logmoved)
(62,old_sha1)
(63,log)
(64,lock)
(65,"unable to restore logfile %s from "TMP_RENAMED_LOG": %s")
(66,0)
(67,strerror(errno)
(68,&err)
(69,lock = lock_ref_sha1_basic(newrefname, NULL, NULL, NULL, 0, NULL, &err)
(70,loginfo)
(71,delete_ref(oldrefname, orig_sha1, REF_NODEREF)
(72,NULL)
(73,"unable to lock %s for rollback: %s")
(74,log)
(75,errno)
(76,oldrefname)
(77,flag = 0)
(78,goto rollback;)
(79,lock)
(80,oldrefname)
(81,if (logmoved && rename(git_path("logs/%s", newrefname)
(82,NULL)
(83,oldrefname)
(84,rename(git_path("logs/%s", newrefname)
(85,log_all_ref_updates = 0)
(86,NULL)
(87,"refname %s not found")
(88,if (log && S_ISLNK(loginfo.st_mode)
(89,symref)
(90,if (flag & REF_ISSYMREF)
(91,!rename_ref_available(oldrefname, newrefname)
(92,lock)
(93,NULL)
(94,&err)
(95,"logs/%s")
(96,git_path("logs/%s", oldrefname)
(97,"unable to restore logfile %s from %s: %s")
(98,newrefname)
(99,RESOLVE_REF_READING)
(100,hashcpy(lock->old_sha1, orig_sha1)
(101,loginfo.st_mode)
(102,"unable to rename \'%s\' to \'%s\': %s")
(103,sha1)
(104,)
(105,if (!lock)
(106,lock)
(107,err)
(108,git_path(TMP_RENAMED_LOG)
(109,"unable to delete existing %s")
(110,if (log && rename_tmp_log(newrefname)
(111,)
(112,orig_sha1)
(113,err.buf)
(114,&err)
(115,log && S_ISLNK(loginfo.st_mode)
(116,log_all_ref_updates)
(117,symref)
(118,rename(git_path("logs/%s", oldrefname)
(119,log_all_ref_updates = flag)
(120,resolve_ref_unsafe(oldrefname, RESOLVE_REF_READING,\n\\n\\t\\t\\t\\t    orig_sha1, &flag)
(121,log_all_ref_updates)
(122,error("reflog for %s is a symlink", oldrefname)
(123,NULL)
(124,lock)
(125,EISDIR)
(126,NULL)
(127,oldrefname)
(128,"unable to write current sha1 into %s")
(129,strerror(errno)
(130,err)
(131,!logmoved && log &&\n\\n\\t    rename(git_path(TMP_RENAMED_LOG)
(132,oldrefname)
(133,log)
(134,if (!rename_ref_available(oldrefname, newrefname)
(135,errno)
(136,strbuf_release(&err)
(137,goto rollback;)
(138,"Directory not empty: %s")
(139,error("unable to write current sha1 into %s", newrefname)
(140,logmoved)
(141,err)
(142,error("refname %s not found", oldrefname)
(143,err)
(144,)
(145,remove_empty_directories(git_path("%s", newrefname)
(146,oldrefname)
(147,newrefname)
(148,rollbacklog:)
(149,git_path("logs/%s", oldrefname)
(150,!lock)
(151,*symref = NULL)
(152,oldrefname)
(153,"logs/%s")
(154,newrefname)
(155,git_path("logs/%s", oldrefname)
(156,error("unable to rename \'%s\' to \'%s\': %s", oldrefname, newrefname, err.buf)
(157,goto rollback;)
(158,return 0;)
(159,return 1;)
(160,flag)
(161,write_ref_sha1(lock, orig_sha1, NULL)
(162,)
(163,newrefname)
(164,flag = log_all_ref_updates)
(165,if (!lock)
(166,)
(167,1)
(168,NULL)
(169,oldrefname)
(170,git_path("logs/%s", newrefname)
(171,if (!logmoved && log &&\n\\n\\t    rename(git_path(TMP_RENAMED_LOG)
(172,)
(173,lstat(git_path("logs/%s", oldrefname)
(174,&loginfo)
(175,err.buf)
(176,if (errno==EISDIR)
(177,newrefname)
(178,log_all_ref_updates)
(179,goto rollbacklog;)
(180,RESOLVE_REF_READING)
(181,newrefname)
(182,goto rollback;)
(183,st_mode)
(184,newrefname)
(185,"logs/%s")
(186,NULL)
(187,logmoved = 0)
(188,goto rollback;)
(189,flag)
(190,git_path(TMP_RENAMED_LOG)
(191,flag & REF_ISSYMREF)
(192,if (write_ref_sha1(lock, orig_sha1, logmsg)
(193,buf)
(194,"unable to delete old %s")
(195,S_ISLNK(loginfo.st_mode)
(196,log)
(197,flag)
(198,return error("refname %s is a symbolic ref, renaming it is not supported",\n\\n\\t\\t\\toldrefname)
(199,log && rename(git_path("logs/%s", oldrefname)
(200,newrefname)
(201,lock_ref_sha1_basic(oldrefname, NULL, NULL, NULL, 0, NULL, &err)
(202,error("unable to delete existing %s", newrefname)
(203,if (!read_ref_full(newrefname, RESOLVE_REF_READING, sha1, NULL)
(204,)
(205,oldrefname)
(206,logmoved)
(207,newrefname)
(208,REF_NODEREF)
(209,0)
(210,symref = resolve_ref_unsafe(oldrefname, RESOLVE_REF_READING,\n\\n\\t\\t\\t\\t    orig_sha1, &flag)
(211,orig_sha1)
(212,log)
(213,rename_tmp_log(newrefname)
(214,"logs/%s")
(215,if (log && rename(git_path("logs/%s", oldrefname)
(216,err)
(217,error("refname %s is a symbolic ref, renaming it is not supported",\n\\n\\t\\t\\toldrefname)
(218,lock->old_sha1)
(219,errno)
(220,rename_ref_available(oldrefname, newrefname)
(221,log)
(222,1)
(223,const char *logmsg)
(224,symref)
(225,symref)
(226,err)
(227,error("Directory not empty: %s", newrefname)
(228,if (remove_empty_directories(git_path("%s", newrefname)
(229,return error("unable to move logfile logs/%s to "TMP_RENAMED_LOG": %s",\n\\n\\t\\t\\toldrefname, strerror(errno)
(230,"refname %s is a symbolic ref, renaming it is not supported")
(231,0)
(232,loginfo)
(233,err)
(234,!logmoved)
(235,const char *oldrefname)
(236,&flag)
(237,!lstat(git_path("logs/%s", oldrefname)
(238,newrefname)
(239,"logs/%s")
(240,orig_sha1)
(241,error("unable to restore logfile %s from %s: %s",\n\\n\\t\\t\\toldrefname, newrefname, strerror(errno)
(242,oldrefname)
(243,error("unable to write current sha1 into %s", oldrefname)
(244,return error("reflog for %s is a symlink", oldrefname)
(245,err)
(246,0)
(247,flag)
(248,flag)
(249,logmsg)
(250,oldrefname)
(251,oldrefname)
(252,errno)
(253,flag)
(254,error("unable to delete old %s", oldrefname)
(255,if (!symref)
(256,orig_sha1)
(257,log && rename_tmp_log(newrefname)
(258,oldrefname)
(259,"unable to write current sha1 into %s")
(260,sha1)
(261,git_path("logs/%s", oldrefname)
(262,error("unable to lock %s for rollback: %s", oldrefname, err.buf)
(263,buf)
(264,logmoved = log)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^