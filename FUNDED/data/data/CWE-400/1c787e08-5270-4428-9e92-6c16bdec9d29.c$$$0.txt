-----label-----
1
-----code-----
int
tcp_reass(struct tcpcb *tp, struct tcphdr *th, int *tlenp, struct mbuf *m)
{
	struct tseg_qent *q;
	struct tseg_qent *p = NULL;
	struct tseg_qent *nq;
	struct tseg_qent *te = NULL;
	struct socket *so = tp->t_inpcb->inp_socket;
	char *s = NULL;
	int flags;
	struct tseg_qent tqs;

	INP_WLOCK_ASSERT(tp->t_inpcb);

	/*
	 * XXX: tcp_reass() is rather inefficient with its data structures
	 * and should be rewritten (see NetBSD for optimizations).
	 */

	/*
	 * Call with th==NULL after become established to
	 * force pre-ESTABLISHED data up to user socket.
	 */
	if (th == NULL)
		goto present;

	/*
	 * Limit the number of segments that can be queued to reduce the
	 * potential for mbuf exhaustion. For best performance, we want to be
	 * able to queue a full window's worth of segments. The size of the
	 * socket receive buffer determines our advertised window and grows
	 * automatically when socket buffer autotuning is enabled. Use it as the
	 * basis for our queue limit.
	 *
	 * However, allow the user to specify a ceiling for the number of
	 * segments in each queue.
	 *
	 * Always let the missing segment through which caused this queue.
	 * NB: Access to the socket buffer is left intentionally unlocked as we
	 * can tolerate stale information here.
	 *
	 * XXXLAS: Using sbspace(so->so_rcv) instead of so->so_rcv.sb_hiwat
	 * should work but causes packets to be dropped when they shouldn't.
	 * Investigate why and re-evaluate the below limit after the behaviour
	 * is understood.
	 */
	if ((th->th_seq != tp->rcv_nxt || !TCPS_HAVEESTABLISHED(tp->t_state)) &&
	    tp->t_segqlen >= min((so->so_rcv.sb_hiwat / tp->t_maxseg) + 1,
	    tcp_reass_maxqueuelen)) {
		TCPSTAT_INC(tcps_rcvreassfull);
		*tlenp = 0;
		if ((s = tcp_log_addrs(&tp->t_inpcb->inp_inc, th, NULL, NULL))) {
			log(LOG_DEBUG, "%s; %s: queue limit reached, "
			    "segment dropped\n", s, __func__);
			free(s, M_TCPLOG);
		}
		m_freem(m);
		return (0);
	}

	/*
	 * Allocate a new queue entry. If we can't, or hit the zone limit
	 * just drop the pkt.
	 *
	 * Use a temporary structure on the stack for the missing segment
	 * when the zone is exhausted. Otherwise we may get stuck.
	 */
	te = uma_zalloc(tcp_reass_zone, M_NOWAIT);
	if (te == NULL) {
		if (th->th_seq != tp->rcv_nxt || !TCPS_HAVEESTABLISHED(tp->t_state)) {
			TCPSTAT_INC(tcps_rcvmemdrop);
			m_freem(m);
			*tlenp = 0;
			if ((s = tcp_log_addrs(&tp->t_inpcb->inp_inc, th, NULL,
			    NULL))) {
				log(LOG_DEBUG, "%s; %s: global zone limit "
				    "reached, segment dropped\n", s, __func__);
				free(s, M_TCPLOG);
			}
			return (0);
		} else {
			bzero(&tqs, sizeof(struct tseg_qent));
			te = &tqs;
			if ((s = tcp_log_addrs(&tp->t_inpcb->inp_inc, th, NULL,
			    NULL))) {
				log(LOG_DEBUG,
				    "%s; %s: global zone limit reached, using "
				    "stack for missing segment\n", s, __func__);
				free(s, M_TCPLOG);
			}
		}
	}
	tp->t_segqlen++;

	/*
	 * Find a segment which begins after this one does.
	 */
	LIST_FOREACH(q, &tp->t_segq, tqe_q) {
		if (SEQ_GT(q->tqe_th->th_seq, th->th_seq))
			break;
		p = q;
	}

	/*
	 * If there is a preceding segment, it may provide some of
	 * our data already.  If so, drop the data from the incoming
	 * segment.  If it provides all of our data, drop us.
	 */
	if (p != NULL) {
		int i;
		/* conversion to int (in i) handles seq wraparound */
		i = p->tqe_th->th_seq + p->tqe_len - th->th_seq;
		if (i > 0) {
			if (i >= *tlenp) {
				TCPSTAT_INC(tcps_rcvduppack);
				TCPSTAT_ADD(tcps_rcvdupbyte, *tlenp);
				m_freem(m);
				if (te != &tqs)
					uma_zfree(tcp_reass_zone, te);
				tp->t_segqlen--;
				/*
				 * Try to present any queued data
				 * at the left window edge to the user.
				 * This is needed after the 3-WHS
				 * completes.
				 */
				goto present;	/* ??? */
			}
			m_adj(m, i);
			*tlenp -= i;
			th->th_seq += i;
		}
	}
	tp->t_rcvoopack++;
	TCPSTAT_INC(tcps_rcvoopack);
	TCPSTAT_ADD(tcps_rcvoobyte, *tlenp);

	/*
	 * While we overlap succeeding segments trim them or,
	 * if they are completely covered, dequeue them.
	 */
	while (q) {
		int i = (th->th_seq + *tlenp) - q->tqe_th->th_seq;
		if (i <= 0)
			break;
		if (i < q->tqe_len) {
			q->tqe_th->th_seq += i;
			q->tqe_len -= i;
			m_adj(q->tqe_m, i);
			break;
		}

		nq = LIST_NEXT(q, tqe_q);
		LIST_REMOVE(q, tqe_q);
		m_freem(q->tqe_m);
		uma_zfree(tcp_reass_zone, q);
		tp->t_segqlen--;
		q = nq;
	}

	/* Insert the new segment queue entry into place. */
	te->tqe_m = m;
	te->tqe_th = th;
	te->tqe_len = *tlenp;

	if (p == NULL) {
		LIST_INSERT_HEAD(&tp->t_segq, te, tqe_q);
	} else {
		KASSERT(te != &tqs, ("%s: temporary stack based entry not "
		    "first element in queue", __func__));
		LIST_INSERT_AFTER(p, te, tqe_q);
	}

present:
	/*
	 * Present data to user, advancing rcv_nxt through
	 * completed sequence space.
	 */
	if (!TCPS_HAVEESTABLISHED(tp->t_state))
		return (0);
	q = LIST_FIRST(&tp->t_segq);
	if (!q || q->tqe_th->th_seq != tp->rcv_nxt)
		return (0);
	SOCKBUF_LOCK(&so->so_rcv);
	do {
		tp->rcv_nxt += q->tqe_len;
		flags = q->tqe_th->th_flags & TH_FIN;
		nq = LIST_NEXT(q, tqe_q);
		LIST_REMOVE(q, tqe_q);
		if (so->so_rcv.sb_state & SBS_CANTRCVMORE)
			m_freem(q->tqe_m);
		else
			sbappendstream_locked(&so->so_rcv, q->tqe_m, 0);
		if (q != &tqs)
			uma_zfree(tcp_reass_zone, q);
		tp->t_segqlen--;
		q = nq;
	} while (q && q->tqe_th->th_seq == tp->rcv_nxt);
	sorwakeup_locked(so);
	return (flags);
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
3,7
3,8
5,6
5,7
6,7
8,9
8,10
11,12
11,13
12,13
14,15
14,16
17,18
17,19
19,20
19,21
22,23
22,24
23,24
25,26
25,27
28,29
28,30
28,31
28,32
28,33
28,34
28,35
28,36
28,37
28,38
28,39
28,40
28,41
28,42
28,43
28,44
28,45
28,46
28,47
28,48
28,49
28,50
28,51
28,52
28,53
28,54
28,55
28,56
28,57
28,58
28,59
28,60
28,61
29,30
30,31
30,32
31,32
33,34
33,35
36,37
37,38
37,39
38,39
40,41
40,42
40,43
43,44
44,45
46,47
47,48
47,49
48,49
50,51
50,52
53,54
54,55
54,56
55,56
57,58
57,59
57,60
60,61
61,62
63,64
64,65
64,66
65,66
67,68
67,69
67,70
70,71
71,72
71,73
72,73
72,74
73,74
77,78
78,79
78,80
80,81
80,82
80,83
83,84
84,85
86,87
87,88
87,89
89,90
91,92
92,93
92,94
93,94
95,96
97,98
98,99
98,100
99,100
101,102
101,103
102,103
105,106
105,107
106,107
106,108
107,108
109,110
111,112
113,114
113,115
114,115
114,116
115,116
116,117
116,118
117,118
117,119
118,119
118,120
119,120
122,123
122,124
123,124
126,127
127,128
127,129
128,129
130,131
130,132
131,132
134,135
134,136
135,136
135,137
136,137
139,140
139,141
139,142
140,141
142,143
142,144
143,144
144,145
144,146
145,146
145,147
146,147
146,148
147,148
151,152
151,153
152,153
156,157
158,159
158,160
158,161
158,162
158,163
159,160
160,161
160,162
161,162
163,164
164,165
166,167
167,168
167,169
168,169
169,170
172,173
172,174
173,174
174,175
174,176
175,176
177,178
177,179
177,180
177,181
177,182
178,179
180,181
181,182
181,183
182,183
182,184
183,184
187,188
189,190
191,192
193,194
193,195
194,195
195,196
195,197
195,198
195,199
195,200
196,197
198,199
201,202
203,204
205,206
206,207
206,208
206,209
207,208
209,210
211,212
213,214
214,215
214,216
215,216
217,218
219,220
220,221
222,223
223,224
223,225
224,225
226,227
226,228
226,229
227,228
229,230
231,232
233,234
233,235
234,235
234,236
235,236
237,238
239,240
240,241
240,242
240,243
241,242
241,243
242,243
242,244
243,244
243,245
244,245
247,248
247,249
248,249
251,252
252,253
252,254
253,254
255,256
255,257
256,257
259,260
259,261
259,262
259,263
259,264
260,261
261,262
261,263
262,263
264,265
265,266
267,268
268,269
268,270
269,270
271,272
273,274
274,275
274,276
275,276
276,277
279,280
279,281
280,281
281,282
281,283
282,283
284,285
284,286
284,287
284,288
284,289
285,286
287,288
288,289
288,290
289,290
289,291
290,291
294,295
296,297
298,299
300,301
300,302
301,302
302,303
302,304
302,305
302,306
302,307
303,304
305,306
308,309
310,311
312,313
313,314
313,315
313,316
314,315
316,317
318,319
320,321
321,322
323,324
323,325
323,326
324,325
325,326
325,327
325,328
326,327
328,329
329,330
331,332
332,333
332,334
333,334
336,337
337,338
337,339
338,339
340,341
341,342
343,344
343,345
344,345
345,346
345,347
346,347
348,349
348,350
348,351
348,352
348,353
349,350
351,352
352,353
352,354
353,354
353,355
354,355
358,359
360,361
362,363
364,365
364,366
365,366
366,367
366,368
366,369
366,370
366,371
367,368
369,370
372,373
374,375
376,377
377,378
377,379
377,380
378,379
380,381
382,383
384,385
385,386
386,387
386,388
387,388
390,391
391,392
391,393
391,394
391,395
392,393
394,395
396,397
397,398
397,399
398,399
401,402
403,404
404,405
404,406
405,406
405,407
406,407
406,408
406,409
407,408
409,410
409,411
410,411
410,412
411,412
415,416
415,417
416,417
420,421
421,422
421,423
422,423
424,425
426,427
426,428
427,428
427,429
428,429
430,431
432,433
432,434
432,435
433,434
434,435
434,436
436,437
438,439
439,440
439,441
440,441
442,443
442,444
443,444
443,445
444,445
444,446
445,446
445,447
446,447
450,451
450,452
451,452
454,455
454,456
455,456
458,459
458,460
459,460
459,461
460,461
463,464
463,465
463,466
463,467
464,465
464,466
465,466
465,467
466,467
468,469
469,470
471,472
471,473
471,474
471,475
471,476
471,477
472,473
473,474
473,475
474,475
476,477
477,478
479,480
480,481
480,482
480,483
481,482
483,484
485,486
486,487
488,489
489,490
489,491
490,491
492,493
494,495
494,496
495,496
495,497
496,497
498,499
499,500
501,502
502,503
502,504
502,505
503,504
505,506
507,508
509,510
510,511
511,512
511,513
512,513
515,516
517,518
518,519
518,520
518,521
519,520
521,522
523,524
525,526
526,527
526,528
527,528
528,529
530,531
532,533
533,534
533,535
534,535
534,536
535,536
538,539
540,541
541,542
542,543
542,544
543,544
546,547
547,548
547,549
548,549
550,551
551,552
553,554
554,555
554,556
554,557
555,556
557,558
559,560
560,561
562,563
562,564
563,564
565,566
565,567
565,568
565,569
565,570
565,571
565,572
565,573
565,574
566,567
567,568
567,569
569,570
569,571
571,572
572,573
572,574
573,574
574,575
574,576
575,576
575,577
576,577
579,580
580,581
582,583
582,584
583,584
583,585
584,585
588,589
588,590
589,590
589,591
590,591
594,595
594,596
595,596
595,597
596,597
598,599
598,600
599,600
602,603
602,604
602,605
602,606
603,604
604,605
604,606
605,606
605,607
606,607
606,608
607,608
611,612
613,614
614,615
614,616
615,616
615,617
616,617
619,620
621,622
622,623
622,624
622,625
623,624
625,626
625,627
626,627
629,630
632,633
633,634
633,635
634,635
636,637
636,638
636,639
637,638
639,640
641,642
643,644
644,645
644,646
644,647
645,646
647,648
649,650
651,652
652,653
652,654
653,654
655,656
655,657
656,657
659,660
660,661
660,662
660,663
661,662
663,664
665,666
667,668
668,669
669,670
669,671
670,671
673,674
674,675
674,676
675,676
677,678
679,680
680,681
680,682
681,682
681,683
682,683
685,686
687,688
688,689
688,690
689,690
689,691
690,691
693,694
695,696
696,697
696,698
697,698
697,699
698,699
701,702
702,703
704,705
704,706
704,707
705,706
705,707
706,707
708,709
710,711
711,712
712,713
712,714
712,715
712,716
713,714
715,716
716,717
716,718
717,718
720,721
722,723
724,725
724,726
725,726
726,727
726,728
726,729
727,728
729,730
729,731
730,731
732,733
733,734
735,736
736,737
736,738
738,739
740,741
741,742
741,743
741,744
741,745
742,743
744,745
746,747
748,749
750,751
750,752
752,753
752,754
753,754
754,755
754,756
755,756
757,758
757,759
758,759
761,762
762,763
764,765
765,766
765,767
766,767
768,769
768,770
769,770
771,772
772,773
772,774
773,774
776,777
776,778
777,778
777,779
778,779
779,780
781,782
781,783
782,783
782,784
783,784
783,785
784,785
788,789
788,790
789,790
792,793
793,794
795,796
796,797
796,798
797,798
799,800
800,801
800,802
801,802
804,805
804,806
805,806
805,807
805,808
805,809
805,810
805,811
805,812
805,813
806,807
807,808
807,809
808,809
808,810
809,810
812,813
812,814
813,814
816,817
817,818
817,819
818,819
820,821
820,822
821,822
821,823
822,823
822,824
823,824
827,828
829,830
830,831
830,832
831,832
833,834
833,835
833,836
834,835
836,837
838,839
840,841
841,842
841,843
841,844
842,843
844,845
846,847
848,849
848,850
848,851
849,850
849,851
850,851
850,852
851,852
851,853
852,853
856,857
858,859
859,860
859,861
860,861
862,863
862,864
863,864
866,867
867,868
867,869
867,870
867,871
868,869
870,871
871,872
871,873
872,873
875,876
875,877
876,877
880,881
880,882
881,882
881,883
882,883
884,885
885,886
887,888
888,889
888,890
888,891
889,890
891,892
893,894
895,896
896,897
897,898
897,899
898,899
901,902
902,903
902,904
903,904
905,906
907,908
907,909
908,909
910,911
910,912
911,912
911,913
912,913
912,914
913,914
917,918
917,919
918,919
921,922
922,923
922,924
923,924
925,926
927,928
928,929
929,930
-----nextToken-----
2,4,7,9,10,13,15,16,18,20,21,24,26,27,32,34,35,39,41,42,45,49,51,52,56,58,59,62,66,68,69,74,75,76,79,81,82,85,88,90,94,96,100,103,104,108,110,112,120,121,124,125,129,132,133,137,138,141,148,149,150,153,154,155,157,162,165,170,171,176,179,184,185,186,188,190,192,197,199,200,202,204,208,210,212,216,218,221,225,228,230,232,236,238,245,246,249,250,254,257,258,263,266,270,272,277,278,283,286,291,292,293,295,297,299,304,306,307,309,311,315,317,319,322,327,330,334,335,339,342,347,350,355,356,357,359,361,363,368,370,371,373,375,379,381,383,388,389,393,395,399,400,402,408,412,413,414,417,418,419,423,425,429,431,435,437,441,447,448,449,452,453,456,457,461,462,467,470,475,478,482,484,487,491,493,497,500,504,506,508,513,514,516,520,522,524,529,531,536,537,539,544,545,549,552,556,558,561,564,568,570,577,578,581,585,586,587,591,592,593,597,600,601,608,609,610,612,617,618,620,624,627,628,630,631,635,638,640,642,646,648,650,654,657,658,662,664,666,671,672,676,678,683,684,686,691,692,694,699,700,703,707,709,714,718,719,721,723,728,731,734,737,739,743,745,747,749,751,756,759,760,763,767,770,774,775,780,785,786,787,790,791,794,798,802,803,810,811,814,815,819,824,825,826,828,832,835,837,839,843,845,847,853,854,855,857,861,864,865,869,873,874,877,878,879,883,886,890,892,894,899,900,904,906,909,914,915,916,919,920,924,926,930
-----computeFrom-----
106,107
106,108
114,115
114,116
116,117
116,118
117,118
117,119
134,135
134,136
142,143
142,144
144,145
144,146
167,168
167,169
174,175
174,176
223,224
223,225
234,235
234,236
241,242
241,243
242,243
242,244
274,275
274,276
281,282
281,283
337,338
337,339
345,346
345,347
421,422
421,423
427,428
427,429
439,440
439,441
442,443
442,444
443,444
443,445
459,460
459,461
465,466
465,467
495,496
495,497
526,527
526,528
533,534
533,535
572,573
572,574
574,575
574,576
589,590
589,591
595,596
595,597
604,605
604,606
614,615
614,616
633,634
633,635
674,675
674,676
680,681
680,682
688,689
688,690
696,697
696,698
705,706
705,707
729,730
729,731
765,766
765,767
777,778
777,779
781,782
781,783
807,808
807,809
817,818
817,819
820,821
820,822
830,831
830,832
849,850
849,851
881,882
881,883
902,903
902,904
907,908
907,909
910,911
910,912
-----guardedBy-----
120,188
153,184
236,339
238,363
245,295
257,291
429,452
461,539
470,487
497,508
600,627
597,630
601,618
883,894
-----guardedByNegation-----
245,359
257,355
707,745
854,874
853,873
-----lastLexicalUse-----
245,359
257,355
-----jump-----
245,359
257,355
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FieldReference;FieldReference;IdExpression;Name;Name;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;GotoStatement;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ExpressionStatement;BinaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;IfStatement;UnaryExpression;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;UnaryExpression;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;IfStatement;UnaryExpression;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ReturnStatement;UnaryExpression;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;TypeIdExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;UnaryExpression;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ProblemStatement;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;BreakStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;IfStatement;BinaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;GotoStatement;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;UnaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;WhileStatement;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BreakStatement;IfStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;BreakStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;UnaryExpression;ExpressionList;LiteralExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;LabelStatement;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ReturnStatement;UnaryExpression;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;UnaryExpression;IdExpression;Name;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;ReturnStatement;UnaryExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;DoStatement;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;UnaryExpression;IdExpression;Name;
-----ast_node-----
inttcp_reass(struct tcpcb *tp, struct tcphdr *th, int *tlenp, struct mbuf *m){	struct tseg_qent *q;	struct tseg_qent *p = NULL;	struct tseg_qent *nq;	struct tseg_qent *te = NULL;	struct socket *so = tp->t_inpcb->inp_socket;	char *s = NULL;	int flags;	struct tseg_qent tqs;	INP_WLOCK_ASSERT(tp->t_inpcb);	/*	 * XXX: tcp_reass() is rather inefficient with its data structures	 * and should be rewritten (see NetBSD for optimizations).	 */	/*	 * Call with th==NULL after become established to	 * force pre-ESTABLISHED data up to user socket.	 */	if (th == NULL)		goto present;	/*	 * Limit the number of segments that can be queued to reduce the	 * potential for mbuf exhaustion. For best performance, we want to be	 * able to queue a full window's worth of segments. The size of the	 * socket receive buffer determines our advertised window and grows	 * automatically when socket buffer autotuning is enabled. Use it as the	 * basis for our queue limit.	 *	 * However, allow the user to specify a ceiling for the number of	 * segments in each queue.	 *	 * Always let the missing segment through which caused this queue.	 * NB: Access to the socket buffer is left intentionally unlocked as we	 * can tolerate stale information here.	 *	 * XXXLAS: Using sbspace(so->so_rcv) instead of so->so_rcv.sb_hiwat	 * should work but causes packets to be dropped when they shouldn't.	 * Investigate why and re-evaluate the below limit after the behaviour	 * is understood.	 */	if ((th->th_seq != tp->rcv_nxt || !TCPS_HAVEESTABLISHED(tp->t_state)) &&	    tp->t_segqlen >= min((so->so_rcv.sb_hiwat / tp->t_maxseg) + 1,	    tcp_reass_maxqueuelen)) {		TCPSTAT_INC(tcps_rcvreassfull);		*tlenp = 0;		if ((s = tcp_log_addrs(&tp->t_inpcb->inp_inc, th, NULL, NULL))) {			log(LOG_DEBUG, "%s; %s: queue limit reached, "			    "segment dropped\n", s, __func__);			free(s, M_TCPLOG);		}		m_freem(m);		return (0);	}	/*	 * Allocate a new queue entry. If we can't, or hit the zone limit	 * just drop the pkt.	 *	 * Use a temporary structure on the stack for the missing segment	 * when the zone is exhausted. Otherwise we may get stuck.	 */	te = uma_zalloc(tcp_reass_zone, M_NOWAIT);	if (te == NULL) {		if (th->th_seq != tp->rcv_nxt || !TCPS_HAVEESTABLISHED(tp->t_state)) {			TCPSTAT_INC(tcps_rcvmemdrop);			m_freem(m);			*tlenp = 0;			if ((s = tcp_log_addrs(&tp->t_inpcb->inp_inc, th, NULL,			    NULL))) {				log(LOG_DEBUG, "%s; %s: global zone limit "				    "reached, segment dropped\n", s, __func__);				free(s, M_TCPLOG);			}			return (0);		} else {			bzero(&tqs, sizeof(struct tseg_qent));			te = &tqs;			if ((s = tcp_log_addrs(&tp->t_inpcb->inp_inc, th, NULL,			    NULL))) {				log(LOG_DEBUG,				    "%s; %s: global zone limit reached, using "				    "stack for missing segment\n", s, __func__);				free(s, M_TCPLOG);			}		}	}	tp->t_segqlen++;	/*	 * Find a segment which begins after this one does.	 */	LIST_FOREACH(q, &tp->t_segq, tqe_q) {		if (SEQ_GT(q->tqe_th->th_seq, th->th_seq))			break;		p = q;	}	/*	 * If there is a preceding segment, it may provide some of	 * our data already.  If so, drop the data from the incoming	 * segment.  If it provides all of our data, drop us.	 */	if (p != NULL) {		int i;		/* conversion to int (in i) handles seq wraparound */		i = p->tqe_th->th_seq + p->tqe_len - th->th_seq;		if (i > 0) {			if (i >= *tlenp) {				TCPSTAT_INC(tcps_rcvduppack);				TCPSTAT_ADD(tcps_rcvdupbyte, *tlenp);				m_freem(m);				if (te != &tqs)					uma_zfree(tcp_reass_zone, te);				tp->t_segqlen--;				/*				 * Try to present any queued data				 * at the left window edge to the user.				 * This is needed after the 3-WHS				 * completes.				 */				goto present;	/* ??? */			}			m_adj(m, i);			*tlenp -= i;			th->th_seq += i;		}	}	tp->t_rcvoopack++;	TCPSTAT_INC(tcps_rcvoopack);	TCPSTAT_ADD(tcps_rcvoobyte, *tlenp);	/*	 * While we overlap succeeding segments trim them or,	 * if they are completely covered, dequeue them.	 */	while (q) {		int i = (th->th_seq + *tlenp) - q->tqe_th->th_seq;		if (i <= 0)			break;		if (i < q->tqe_len) {			q->tqe_th->th_seq += i;			q->tqe_len -= i;			m_adj(q->tqe_m, i);			break;		}		nq = LIST_NEXT(q, tqe_q);		LIST_REMOVE(q, tqe_q);		m_freem(q->tqe_m);		uma_zfree(tcp_reass_zone, q);		tp->t_segqlen--;		q = nq;	}	/* Insert the new segment queue entry into place. */	te->tqe_m = m;	te->tqe_th = th;	te->tqe_len = *tlenp;	if (p == NULL) {		LIST_INSERT_HEAD(&tp->t_segq, te, tqe_q);	} else {		KASSERT(te != &tqs, ("%s: temporary stack based entry not "		    "first element in queue", __func__));		LIST_INSERT_AFTER(p, te, tqe_q);	}present:	/*	 * Present data to user, advancing rcv_nxt through	 * completed sequence space.	 */	if (!TCPS_HAVEESTABLISHED(tp->t_state))		return (0);	q = LIST_FIRST(&tp->t_segq);	if (!q || q->tqe_th->th_seq != tp->rcv_nxt)		return (0);	SOCKBUF_LOCK(&so->so_rcv);	do {		tp->rcv_nxt += q->tqe_len;		flags = q->tqe_th->th_flags & TH_FIN;		nq = LIST_NEXT(q, tqe_q);		LIST_REMOVE(q, tqe_q);		if (so->so_rcv.sb_state & SBS_CANTRCVMORE)			m_freem(q->tqe_m);		else			sbappendstream_locked(&so->so_rcv, q->tqe_m, 0);		if (q != &tqs)			uma_zfree(tcp_reass_zone, q);		tp->t_segqlen--;		q = nq;	} while (q && q->tqe_th->th_seq == tp->rcv_nxt);	sorwakeup_locked(so);	return (flags);}
int
tcp_reass(struct tcpcb *tp, struct tcphdr *th, int *tlenp, struct mbuf *m)
tcp_reass
struct tcpcb *tp
struct tcpcb
tcpcb
*tp
*
tp
struct tcphdr *th
struct tcphdr
tcphdr
*th
*
th
int *tlenp
int
*tlenp
*
tlenp
struct mbuf *m
struct mbuf
mbuf
*m
*
m
{	struct tseg_qent *q;	struct tseg_qent *p = NULL;	struct tseg_qent *nq;	struct tseg_qent *te = NULL;	struct socket *so = tp->t_inpcb->inp_socket;	char *s = NULL;	int flags;	struct tseg_qent tqs;	INP_WLOCK_ASSERT(tp->t_inpcb);	/*	 * XXX: tcp_reass() is rather inefficient with its data structures	 * and should be rewritten (see NetBSD for optimizations).	 */	/*	 * Call with th==NULL after become established to	 * force pre-ESTABLISHED data up to user socket.	 */	if (th == NULL)		goto present;	/*	 * Limit the number of segments that can be queued to reduce the	 * potential for mbuf exhaustion. For best performance, we want to be	 * able to queue a full window's worth of segments. The size of the	 * socket receive buffer determines our advertised window and grows	 * automatically when socket buffer autotuning is enabled. Use it as the	 * basis for our queue limit.	 *	 * However, allow the user to specify a ceiling for the number of	 * segments in each queue.	 *	 * Always let the missing segment through which caused this queue.	 * NB: Access to the socket buffer is left intentionally unlocked as we	 * can tolerate stale information here.	 *	 * XXXLAS: Using sbspace(so->so_rcv) instead of so->so_rcv.sb_hiwat	 * should work but causes packets to be dropped when they shouldn't.	 * Investigate why and re-evaluate the below limit after the behaviour	 * is understood.	 */	if ((th->th_seq != tp->rcv_nxt || !TCPS_HAVEESTABLISHED(tp->t_state)) &&	    tp->t_segqlen >= min((so->so_rcv.sb_hiwat / tp->t_maxseg) + 1,	    tcp_reass_maxqueuelen)) {		TCPSTAT_INC(tcps_rcvreassfull);		*tlenp = 0;		if ((s = tcp_log_addrs(&tp->t_inpcb->inp_inc, th, NULL, NULL))) {			log(LOG_DEBUG, "%s; %s: queue limit reached, "			    "segment dropped\n", s, __func__);			free(s, M_TCPLOG);		}		m_freem(m);		return (0);	}	/*	 * Allocate a new queue entry. If we can't, or hit the zone limit	 * just drop the pkt.	 *	 * Use a temporary structure on the stack for the missing segment	 * when the zone is exhausted. Otherwise we may get stuck.	 */	te = uma_zalloc(tcp_reass_zone, M_NOWAIT);	if (te == NULL) {		if (th->th_seq != tp->rcv_nxt || !TCPS_HAVEESTABLISHED(tp->t_state)) {			TCPSTAT_INC(tcps_rcvmemdrop);			m_freem(m);			*tlenp = 0;			if ((s = tcp_log_addrs(&tp->t_inpcb->inp_inc, th, NULL,			    NULL))) {				log(LOG_DEBUG, "%s; %s: global zone limit "				    "reached, segment dropped\n", s, __func__);				free(s, M_TCPLOG);			}			return (0);		} else {			bzero(&tqs, sizeof(struct tseg_qent));			te = &tqs;			if ((s = tcp_log_addrs(&tp->t_inpcb->inp_inc, th, NULL,			    NULL))) {				log(LOG_DEBUG,				    "%s; %s: global zone limit reached, using "				    "stack for missing segment\n", s, __func__);				free(s, M_TCPLOG);			}		}	}	tp->t_segqlen++;	/*	 * Find a segment which begins after this one does.	 */	LIST_FOREACH(q, &tp->t_segq, tqe_q) {		if (SEQ_GT(q->tqe_th->th_seq, th->th_seq))			break;		p = q;	}	/*	 * If there is a preceding segment, it may provide some of	 * our data already.  If so, drop the data from the incoming	 * segment.  If it provides all of our data, drop us.	 */	if (p != NULL) {		int i;		/* conversion to int (in i) handles seq wraparound */		i = p->tqe_th->th_seq + p->tqe_len - th->th_seq;		if (i > 0) {			if (i >= *tlenp) {				TCPSTAT_INC(tcps_rcvduppack);				TCPSTAT_ADD(tcps_rcvdupbyte, *tlenp);				m_freem(m);				if (te != &tqs)					uma_zfree(tcp_reass_zone, te);				tp->t_segqlen--;				/*				 * Try to present any queued data				 * at the left window edge to the user.				 * This is needed after the 3-WHS				 * completes.				 */				goto present;	/* ??? */			}			m_adj(m, i);			*tlenp -= i;			th->th_seq += i;		}	}	tp->t_rcvoopack++;	TCPSTAT_INC(tcps_rcvoopack);	TCPSTAT_ADD(tcps_rcvoobyte, *tlenp);	/*	 * While we overlap succeeding segments trim them or,	 * if they are completely covered, dequeue them.	 */	while (q) {		int i = (th->th_seq + *tlenp) - q->tqe_th->th_seq;		if (i <= 0)			break;		if (i < q->tqe_len) {			q->tqe_th->th_seq += i;			q->tqe_len -= i;			m_adj(q->tqe_m, i);			break;		}		nq = LIST_NEXT(q, tqe_q);		LIST_REMOVE(q, tqe_q);		m_freem(q->tqe_m);		uma_zfree(tcp_reass_zone, q);		tp->t_segqlen--;		q = nq;	}	/* Insert the new segment queue entry into place. */	te->tqe_m = m;	te->tqe_th = th;	te->tqe_len = *tlenp;	if (p == NULL) {		LIST_INSERT_HEAD(&tp->t_segq, te, tqe_q);	} else {		KASSERT(te != &tqs, ("%s: temporary stack based entry not "		    "first element in queue", __func__));		LIST_INSERT_AFTER(p, te, tqe_q);	}present:	/*	 * Present data to user, advancing rcv_nxt through	 * completed sequence space.	 */	if (!TCPS_HAVEESTABLISHED(tp->t_state))		return (0);	q = LIST_FIRST(&tp->t_segq);	if (!q || q->tqe_th->th_seq != tp->rcv_nxt)		return (0);	SOCKBUF_LOCK(&so->so_rcv);	do {		tp->rcv_nxt += q->tqe_len;		flags = q->tqe_th->th_flags & TH_FIN;		nq = LIST_NEXT(q, tqe_q);		LIST_REMOVE(q, tqe_q);		if (so->so_rcv.sb_state & SBS_CANTRCVMORE)			m_freem(q->tqe_m);		else			sbappendstream_locked(&so->so_rcv, q->tqe_m, 0);		if (q != &tqs)			uma_zfree(tcp_reass_zone, q);		tp->t_segqlen--;		q = nq;	} while (q && q->tqe_th->th_seq == tp->rcv_nxt);	sorwakeup_locked(so);	return (flags);}
struct tseg_qent *q;
struct tseg_qent *q;
struct tseg_qent
tseg_qent
*q
*
q
struct tseg_qent *p = NULL;
struct tseg_qent *p = NULL;
struct tseg_qent
tseg_qent
*p = NULL
*
p
= NULL
NULL
NULL
struct tseg_qent *nq;
struct tseg_qent *nq;
struct tseg_qent
tseg_qent
*nq
*
nq
struct tseg_qent *te = NULL;
struct tseg_qent *te = NULL;
struct tseg_qent
tseg_qent
*te = NULL
*
te
= NULL
NULL
NULL
struct socket *so = tp->t_inpcb->inp_socket;
struct socket *so = tp->t_inpcb->inp_socket;
struct socket
socket
*so = tp->t_inpcb->inp_socket
*
so
= tp->t_inpcb->inp_socket
tp->t_inpcb->inp_socket
tp->t_inpcb
tp
tp
t_inpcb
inp_socket
char *s = NULL;
char *s = NULL;
char
*s = NULL
*
s
= NULL
NULL
NULL
int flags;
int flags;
int
flags
flags
struct tseg_qent tqs;
struct tseg_qent tqs;
struct tseg_qent
tseg_qent
tqs
tqs
INP_WLOCK_ASSERT(tp->t_inpcb);
INP_WLOCK_ASSERT(tp->t_inpcb)
INP_WLOCK_ASSERT
INP_WLOCK_ASSERT
tp->t_inpcb
tp
tp
t_inpcb
if (th == NULL)		goto present;
th == NULL
th
th
NULL
NULL
goto present;
present
if ((th->th_seq != tp->rcv_nxt || !TCPS_HAVEESTABLISHED(tp->t_state)) &&	    tp->t_segqlen >= min((so->so_rcv.sb_hiwat / tp->t_maxseg) + 1,	    tcp_reass_maxqueuelen)) {		TCPSTAT_INC(tcps_rcvreassfull);		*tlenp = 0;		if ((s = tcp_log_addrs(&tp->t_inpcb->inp_inc, th, NULL, NULL))) {			log(LOG_DEBUG, "%s; %s: queue limit reached, "			    "segment dropped\n", s, __func__);			free(s, M_TCPLOG);		}		m_freem(m);		return (0);	}
(th->th_seq != tp->rcv_nxt || !TCPS_HAVEESTABLISHED(tp->t_state)) &&	    tp->t_segqlen >= min((so->so_rcv.sb_hiwat / tp->t_maxseg) + 1,	    tcp_reass_maxqueuelen)
(th->th_seq != tp->rcv_nxt || !TCPS_HAVEESTABLISHED(tp->t_state))
th->th_seq != tp->rcv_nxt || !TCPS_HAVEESTABLISHED(tp->t_state)
th->th_seq != tp->rcv_nxt
th->th_seq
th
th
th_seq
tp->rcv_nxt
tp
tp
rcv_nxt
!TCPS_HAVEESTABLISHED(tp->t_state)
TCPS_HAVEESTABLISHED(tp->t_state)
TCPS_HAVEESTABLISHED
TCPS_HAVEESTABLISHED
tp->t_state
tp
tp
t_state
tp->t_segqlen >= min((so->so_rcv.sb_hiwat / tp->t_maxseg) + 1,	    tcp_reass_maxqueuelen)
tp->t_segqlen
tp
tp
t_segqlen
min((so->so_rcv.sb_hiwat / tp->t_maxseg) + 1,	    tcp_reass_maxqueuelen)
min
min
(so->so_rcv.sb_hiwat / tp->t_maxseg) + 1
(so->so_rcv.sb_hiwat / tp->t_maxseg)
so->so_rcv.sb_hiwat / tp->t_maxseg
so->so_rcv.sb_hiwat
so->so_rcv
so
so
so_rcv
sb_hiwat
tp->t_maxseg
tp
tp
t_maxseg
1
tcp_reass_maxqueuelen
tcp_reass_maxqueuelen
{		TCPSTAT_INC(tcps_rcvreassfull);		*tlenp = 0;		if ((s = tcp_log_addrs(&tp->t_inpcb->inp_inc, th, NULL, NULL))) {			log(LOG_DEBUG, "%s; %s: queue limit reached, "			    "segment dropped\n", s, __func__);			free(s, M_TCPLOG);		}		m_freem(m);		return (0);	}
TCPSTAT_INC(tcps_rcvreassfull);
TCPSTAT_INC(tcps_rcvreassfull);
TCPSTAT_INC
TCPSTAT_INC
(tcps_rcvreassfull)
tcps_rcvreassfull
tcps_rcvreassfull
*tlenp = 0;
*tlenp = 0
*tlenp
tlenp
tlenp
0
if ((s = tcp_log_addrs(&tp->t_inpcb->inp_inc, th, NULL, NULL))) {			log(LOG_DEBUG, "%s; %s: queue limit reached, "			    "segment dropped\n", s, __func__);			free(s, M_TCPLOG);		}
(s = tcp_log_addrs(&tp->t_inpcb->inp_inc, th, NULL, NULL))
s = tcp_log_addrs(&tp->t_inpcb->inp_inc, th, NULL, NULL)
s
s
tcp_log_addrs(&tp->t_inpcb->inp_inc, th, NULL, NULL)
tcp_log_addrs
tcp_log_addrs
&tp->t_inpcb->inp_inc
tp->t_inpcb->inp_inc
tp->t_inpcb
tp
tp
t_inpcb
inp_inc
th
th
NULL
NULL
NULL
NULL
{			log(LOG_DEBUG, "%s; %s: queue limit reached, "			    "segment dropped\n", s, __func__);			free(s, M_TCPLOG);		}
log(LOG_DEBUG, "%s; %s: queue limit reached, "			    "segment dropped\n", s, __func__);
log(LOG_DEBUG, "%s; %s: queue limit reached, "			    "segment dropped\n", s, __func__)
log
log
LOG_DEBUG
LOG_DEBUG
"%s; %s: queue limit reached, "			    "segment dropped\n"
s
s
__func__
__func__
free(s, M_TCPLOG);
free(s, M_TCPLOG)
free
free
s
s
M_TCPLOG
M_TCPLOG
m_freem(m);
m_freem(m)
m_freem
m_freem
m
m
return (0);
(0)
0
te = uma_zalloc(tcp_reass_zone, M_NOWAIT);
te = uma_zalloc(tcp_reass_zone, M_NOWAIT)
te
te
uma_zalloc(tcp_reass_zone, M_NOWAIT)
uma_zalloc
uma_zalloc
tcp_reass_zone
tcp_reass_zone
M_NOWAIT
M_NOWAIT
if (te == NULL) {		if (th->th_seq != tp->rcv_nxt || !TCPS_HAVEESTABLISHED(tp->t_state)) {			TCPSTAT_INC(tcps_rcvmemdrop);			m_freem(m);			*tlenp = 0;			if ((s = tcp_log_addrs(&tp->t_inpcb->inp_inc, th, NULL,			    NULL))) {				log(LOG_DEBUG, "%s; %s: global zone limit "				    "reached, segment dropped\n", s, __func__);				free(s, M_TCPLOG);			}			return (0);		} else {			bzero(&tqs, sizeof(struct tseg_qent));			te = &tqs;			if ((s = tcp_log_addrs(&tp->t_inpcb->inp_inc, th, NULL,			    NULL))) {				log(LOG_DEBUG,				    "%s; %s: global zone limit reached, using "				    "stack for missing segment\n", s, __func__);				free(s, M_TCPLOG);			}		}	}
te == NULL
te
te
NULL
NULL
{		if (th->th_seq != tp->rcv_nxt || !TCPS_HAVEESTABLISHED(tp->t_state)) {			TCPSTAT_INC(tcps_rcvmemdrop);			m_freem(m);			*tlenp = 0;			if ((s = tcp_log_addrs(&tp->t_inpcb->inp_inc, th, NULL,			    NULL))) {				log(LOG_DEBUG, "%s; %s: global zone limit "				    "reached, segment dropped\n", s, __func__);				free(s, M_TCPLOG);			}			return (0);		} else {			bzero(&tqs, sizeof(struct tseg_qent));			te = &tqs;			if ((s = tcp_log_addrs(&tp->t_inpcb->inp_inc, th, NULL,			    NULL))) {				log(LOG_DEBUG,				    "%s; %s: global zone limit reached, using "				    "stack for missing segment\n", s, __func__);				free(s, M_TCPLOG);			}		}	}
if (th->th_seq != tp->rcv_nxt || !TCPS_HAVEESTABLISHED(tp->t_state)) {			TCPSTAT_INC(tcps_rcvmemdrop);			m_freem(m);			*tlenp = 0;			if ((s = tcp_log_addrs(&tp->t_inpcb->inp_inc, th, NULL,			    NULL))) {				log(LOG_DEBUG, "%s; %s: global zone limit "				    "reached, segment dropped\n", s, __func__);				free(s, M_TCPLOG);			}			return (0);		} else {			bzero(&tqs, sizeof(struct tseg_qent));			te = &tqs;			if ((s = tcp_log_addrs(&tp->t_inpcb->inp_inc, th, NULL,			    NULL))) {				log(LOG_DEBUG,				    "%s; %s: global zone limit reached, using "				    "stack for missing segment\n", s, __func__);				free(s, M_TCPLOG);			}		}
th->th_seq != tp->rcv_nxt || !TCPS_HAVEESTABLISHED(tp->t_state)
th->th_seq != tp->rcv_nxt
th->th_seq
th
th
th_seq
tp->rcv_nxt
tp
tp
rcv_nxt
!TCPS_HAVEESTABLISHED(tp->t_state)
TCPS_HAVEESTABLISHED(tp->t_state)
TCPS_HAVEESTABLISHED
TCPS_HAVEESTABLISHED
tp->t_state
tp
tp
t_state
{			TCPSTAT_INC(tcps_rcvmemdrop);			m_freem(m);			*tlenp = 0;			if ((s = tcp_log_addrs(&tp->t_inpcb->inp_inc, th, NULL,			    NULL))) {				log(LOG_DEBUG, "%s; %s: global zone limit "				    "reached, segment dropped\n", s, __func__);				free(s, M_TCPLOG);			}			return (0);		}
TCPSTAT_INC(tcps_rcvmemdrop);
TCPSTAT_INC(tcps_rcvmemdrop);
TCPSTAT_INC
TCPSTAT_INC
(tcps_rcvmemdrop)
tcps_rcvmemdrop
tcps_rcvmemdrop
m_freem(m);
m_freem(m)
m_freem
m_freem
m
m
*tlenp = 0;
*tlenp = 0
*tlenp
tlenp
tlenp
0
if ((s = tcp_log_addrs(&tp->t_inpcb->inp_inc, th, NULL,			    NULL))) {				log(LOG_DEBUG, "%s; %s: global zone limit "				    "reached, segment dropped\n", s, __func__);				free(s, M_TCPLOG);			}
(s = tcp_log_addrs(&tp->t_inpcb->inp_inc, th, NULL,			    NULL))
s = tcp_log_addrs(&tp->t_inpcb->inp_inc, th, NULL,			    NULL)
s
s
tcp_log_addrs(&tp->t_inpcb->inp_inc, th, NULL,			    NULL)
tcp_log_addrs
tcp_log_addrs
&tp->t_inpcb->inp_inc
tp->t_inpcb->inp_inc
tp->t_inpcb
tp
tp
t_inpcb
inp_inc
th
th
NULL
NULL
NULL
NULL
{				log(LOG_DEBUG, "%s; %s: global zone limit "				    "reached, segment dropped\n", s, __func__);				free(s, M_TCPLOG);			}
log(LOG_DEBUG, "%s; %s: global zone limit "				    "reached, segment dropped\n", s, __func__);
log(LOG_DEBUG, "%s; %s: global zone limit "				    "reached, segment dropped\n", s, __func__)
log
log
LOG_DEBUG
LOG_DEBUG
"%s; %s: global zone limit "				    "reached, segment dropped\n"
s
s
__func__
__func__
free(s, M_TCPLOG);
free(s, M_TCPLOG)
free
free
s
s
M_TCPLOG
M_TCPLOG
return (0);
(0)
0
{			bzero(&tqs, sizeof(struct tseg_qent));			te = &tqs;			if ((s = tcp_log_addrs(&tp->t_inpcb->inp_inc, th, NULL,			    NULL))) {				log(LOG_DEBUG,				    "%s; %s: global zone limit reached, using "				    "stack for missing segment\n", s, __func__);				free(s, M_TCPLOG);			}		}
bzero(&tqs, sizeof(struct tseg_qent));
bzero(&tqs, sizeof(struct tseg_qent))
bzero
bzero
&tqs
tqs
tqs
sizeof(struct tseg_qent)
struct tseg_qent
struct tseg_qent
tseg_qent

te = &tqs;
te = &tqs
te
te
&tqs
tqs
tqs
if ((s = tcp_log_addrs(&tp->t_inpcb->inp_inc, th, NULL,			    NULL))) {				log(LOG_DEBUG,				    "%s; %s: global zone limit reached, using "				    "stack for missing segment\n", s, __func__);				free(s, M_TCPLOG);			}
(s = tcp_log_addrs(&tp->t_inpcb->inp_inc, th, NULL,			    NULL))
s = tcp_log_addrs(&tp->t_inpcb->inp_inc, th, NULL,			    NULL)
s
s
tcp_log_addrs(&tp->t_inpcb->inp_inc, th, NULL,			    NULL)
tcp_log_addrs
tcp_log_addrs
&tp->t_inpcb->inp_inc
tp->t_inpcb->inp_inc
tp->t_inpcb
tp
tp
t_inpcb
inp_inc
th
th
NULL
NULL
NULL
NULL
{				log(LOG_DEBUG,				    "%s; %s: global zone limit reached, using "				    "stack for missing segment\n", s, __func__);				free(s, M_TCPLOG);			}
log(LOG_DEBUG,				    "%s; %s: global zone limit reached, using "				    "stack for missing segment\n", s, __func__);
log(LOG_DEBUG,				    "%s; %s: global zone limit reached, using "				    "stack for missing segment\n", s, __func__)
log
log
LOG_DEBUG
LOG_DEBUG
"%s; %s: global zone limit reached, using "				    "stack for missing segment\n"
s
s
__func__
__func__
free(s, M_TCPLOG);
free(s, M_TCPLOG)
free
free
s
s
M_TCPLOG
M_TCPLOG
tp->t_segqlen++;
tp->t_segqlen++
tp->t_segqlen
tp
tp
t_segqlen
LIST_FOREACH(q, &tp->t_segq, tqe_q)
LIST_FOREACH(q, &tp->t_segq, tqe_q)
LIST_FOREACH
LIST_FOREACH
q
q
&tp->t_segq
tp->t_segq
tp
tp
t_segq
tqe_q
tqe_q
)
{		if (SEQ_GT(q->tqe_th->th_seq, th->th_seq))			break;		p = q;	}
if (SEQ_GT(q->tqe_th->th_seq, th->th_seq))			break;
SEQ_GT(q->tqe_th->th_seq, th->th_seq)
SEQ_GT
SEQ_GT
q->tqe_th->th_seq
q->tqe_th
q
q
tqe_th
th_seq
th->th_seq
th
th
th_seq
break;
p = q;
p = q
p
p
q
q
if (p != NULL) {		int i;		/* conversion to int (in i) handles seq wraparound */		i = p->tqe_th->th_seq + p->tqe_len - th->th_seq;		if (i > 0) {			if (i >= *tlenp) {				TCPSTAT_INC(tcps_rcvduppack);				TCPSTAT_ADD(tcps_rcvdupbyte, *tlenp);				m_freem(m);				if (te != &tqs)					uma_zfree(tcp_reass_zone, te);				tp->t_segqlen--;				/*				 * Try to present any queued data				 * at the left window edge to the user.				 * This is needed after the 3-WHS				 * completes.				 */				goto present;	/* ??? */			}			m_adj(m, i);			*tlenp -= i;			th->th_seq += i;		}	}
p != NULL
p
p
NULL
NULL
{		int i;		/* conversion to int (in i) handles seq wraparound */		i = p->tqe_th->th_seq + p->tqe_len - th->th_seq;		if (i > 0) {			if (i >= *tlenp) {				TCPSTAT_INC(tcps_rcvduppack);				TCPSTAT_ADD(tcps_rcvdupbyte, *tlenp);				m_freem(m);				if (te != &tqs)					uma_zfree(tcp_reass_zone, te);				tp->t_segqlen--;				/*				 * Try to present any queued data				 * at the left window edge to the user.				 * This is needed after the 3-WHS				 * completes.				 */				goto present;	/* ??? */			}			m_adj(m, i);			*tlenp -= i;			th->th_seq += i;		}	}
int i;
int i;
int
i
i
i = p->tqe_th->th_seq + p->tqe_len - th->th_seq;
i = p->tqe_th->th_seq + p->tqe_len - th->th_seq
i
i
p->tqe_th->th_seq + p->tqe_len - th->th_seq
p->tqe_th->th_seq + p->tqe_len
p->tqe_th->th_seq
p->tqe_th
p
p
tqe_th
th_seq
p->tqe_len
p
p
tqe_len
th->th_seq
th
th
th_seq
if (i > 0) {			if (i >= *tlenp) {				TCPSTAT_INC(tcps_rcvduppack);				TCPSTAT_ADD(tcps_rcvdupbyte, *tlenp);				m_freem(m);				if (te != &tqs)					uma_zfree(tcp_reass_zone, te);				tp->t_segqlen--;				/*				 * Try to present any queued data				 * at the left window edge to the user.				 * This is needed after the 3-WHS				 * completes.				 */				goto present;	/* ??? */			}			m_adj(m, i);			*tlenp -= i;			th->th_seq += i;		}
i > 0
i
i
0
{			if (i >= *tlenp) {				TCPSTAT_INC(tcps_rcvduppack);				TCPSTAT_ADD(tcps_rcvdupbyte, *tlenp);				m_freem(m);				if (te != &tqs)					uma_zfree(tcp_reass_zone, te);				tp->t_segqlen--;				/*				 * Try to present any queued data				 * at the left window edge to the user.				 * This is needed after the 3-WHS				 * completes.				 */				goto present;	/* ??? */			}			m_adj(m, i);			*tlenp -= i;			th->th_seq += i;		}
if (i >= *tlenp) {				TCPSTAT_INC(tcps_rcvduppack);				TCPSTAT_ADD(tcps_rcvdupbyte, *tlenp);				m_freem(m);				if (te != &tqs)					uma_zfree(tcp_reass_zone, te);				tp->t_segqlen--;				/*				 * Try to present any queued data				 * at the left window edge to the user.				 * This is needed after the 3-WHS				 * completes.				 */				goto present;	/* ??? */			}
i >= *tlenp
i
i
*tlenp
tlenp
tlenp
{				TCPSTAT_INC(tcps_rcvduppack);				TCPSTAT_ADD(tcps_rcvdupbyte, *tlenp);				m_freem(m);				if (te != &tqs)					uma_zfree(tcp_reass_zone, te);				tp->t_segqlen--;				/*				 * Try to present any queued data				 * at the left window edge to the user.				 * This is needed after the 3-WHS				 * completes.				 */				goto present;	/* ??? */			}
TCPSTAT_INC(tcps_rcvduppack);
TCPSTAT_INC(tcps_rcvduppack);
TCPSTAT_INC
TCPSTAT_INC
(tcps_rcvduppack)
tcps_rcvduppack
tcps_rcvduppack
TCPSTAT_ADD(tcps_rcvdupbyte, *tlenp);
TCPSTAT_ADD(tcps_rcvdupbyte, *tlenp)
TCPSTAT_ADD
TCPSTAT_ADD
tcps_rcvdupbyte
tcps_rcvdupbyte
*tlenp
tlenp
tlenp
m_freem(m);
m_freem(m)
m_freem
m_freem
m
m
if (te != &tqs)					uma_zfree(tcp_reass_zone, te);
te != &tqs
te
te
&tqs
tqs
tqs
uma_zfree(tcp_reass_zone, te);
uma_zfree(tcp_reass_zone, te)
uma_zfree
uma_zfree
tcp_reass_zone
tcp_reass_zone
te
te
tp->t_segqlen--;
tp->t_segqlen--
tp->t_segqlen
tp
tp
t_segqlen
goto present;
present
m_adj(m, i);
m_adj(m, i)
m_adj
m_adj
m
m
i
i
*tlenp -= i;
*tlenp -= i
*tlenp
tlenp
tlenp
i
i
th->th_seq += i;
th->th_seq += i
th->th_seq
th
th
th_seq
i
i
tp->t_rcvoopack++;
tp->t_rcvoopack++
tp->t_rcvoopack
tp
tp
t_rcvoopack
TCPSTAT_INC(tcps_rcvoopack);
TCPSTAT_INC(tcps_rcvoopack);
TCPSTAT_INC
TCPSTAT_INC
(tcps_rcvoopack)
tcps_rcvoopack
tcps_rcvoopack
TCPSTAT_ADD(tcps_rcvoobyte, *tlenp);
TCPSTAT_ADD(tcps_rcvoobyte, *tlenp)
TCPSTAT_ADD
TCPSTAT_ADD
tcps_rcvoobyte
tcps_rcvoobyte
*tlenp
tlenp
tlenp
while (q) {		int i = (th->th_seq + *tlenp) - q->tqe_th->th_seq;		if (i <= 0)			break;		if (i < q->tqe_len) {			q->tqe_th->th_seq += i;			q->tqe_len -= i;			m_adj(q->tqe_m, i);			break;		}		nq = LIST_NEXT(q, tqe_q);		LIST_REMOVE(q, tqe_q);		m_freem(q->tqe_m);		uma_zfree(tcp_reass_zone, q);		tp->t_segqlen--;		q = nq;	}
q
q
{		int i = (th->th_seq + *tlenp) - q->tqe_th->th_seq;		if (i <= 0)			break;		if (i < q->tqe_len) {			q->tqe_th->th_seq += i;			q->tqe_len -= i;			m_adj(q->tqe_m, i);			break;		}		nq = LIST_NEXT(q, tqe_q);		LIST_REMOVE(q, tqe_q);		m_freem(q->tqe_m);		uma_zfree(tcp_reass_zone, q);		tp->t_segqlen--;		q = nq;	}
int i = (th->th_seq + *tlenp) - q->tqe_th->th_seq;
int i = (th->th_seq + *tlenp) - q->tqe_th->th_seq;
int
i = (th->th_seq + *tlenp) - q->tqe_th->th_seq
i
= (th->th_seq + *tlenp) - q->tqe_th->th_seq
(th->th_seq + *tlenp) - q->tqe_th->th_seq
(th->th_seq + *tlenp)
th->th_seq + *tlenp
th->th_seq
th
th
th_seq
*tlenp
tlenp
tlenp
q->tqe_th->th_seq
q->tqe_th
q
q
tqe_th
th_seq
if (i <= 0)			break;
i <= 0
i
i
0
break;
if (i < q->tqe_len) {			q->tqe_th->th_seq += i;			q->tqe_len -= i;			m_adj(q->tqe_m, i);			break;		}
i < q->tqe_len
i
i
q->tqe_len
q
q
tqe_len
{			q->tqe_th->th_seq += i;			q->tqe_len -= i;			m_adj(q->tqe_m, i);			break;		}
q->tqe_th->th_seq += i;
q->tqe_th->th_seq += i
q->tqe_th->th_seq
q->tqe_th
q
q
tqe_th
th_seq
i
i
q->tqe_len -= i;
q->tqe_len -= i
q->tqe_len
q
q
tqe_len
i
i
m_adj(q->tqe_m, i);
m_adj(q->tqe_m, i)
m_adj
m_adj
q->tqe_m
q
q
tqe_m
i
i
break;
nq = LIST_NEXT(q, tqe_q);
nq = LIST_NEXT(q, tqe_q)
nq
nq
LIST_NEXT(q, tqe_q)
LIST_NEXT
LIST_NEXT
q
q
tqe_q
tqe_q
LIST_REMOVE(q, tqe_q);
LIST_REMOVE(q, tqe_q)
LIST_REMOVE
LIST_REMOVE
q
q
tqe_q
tqe_q
m_freem(q->tqe_m);
m_freem(q->tqe_m)
m_freem
m_freem
q->tqe_m
q
q
tqe_m
uma_zfree(tcp_reass_zone, q);
uma_zfree(tcp_reass_zone, q)
uma_zfree
uma_zfree
tcp_reass_zone
tcp_reass_zone
q
q
tp->t_segqlen--;
tp->t_segqlen--
tp->t_segqlen
tp
tp
t_segqlen
q = nq;
q = nq
q
q
nq
nq
te->tqe_m = m;
te->tqe_m = m
te->tqe_m
te
te
tqe_m
m
m
te->tqe_th = th;
te->tqe_th = th
te->tqe_th
te
te
tqe_th
th
th
te->tqe_len = *tlenp;
te->tqe_len = *tlenp
te->tqe_len
te
te
tqe_len
*tlenp
tlenp
tlenp
if (p == NULL) {		LIST_INSERT_HEAD(&tp->t_segq, te, tqe_q);	} else {		KASSERT(te != &tqs, ("%s: temporary stack based entry not "		    "first element in queue", __func__));		LIST_INSERT_AFTER(p, te, tqe_q);	}
p == NULL
p
p
NULL
NULL
{		LIST_INSERT_HEAD(&tp->t_segq, te, tqe_q);	}
LIST_INSERT_HEAD(&tp->t_segq, te, tqe_q);
LIST_INSERT_HEAD(&tp->t_segq, te, tqe_q)
LIST_INSERT_HEAD
LIST_INSERT_HEAD
&tp->t_segq
tp->t_segq
tp
tp
t_segq
te
te
tqe_q
tqe_q
{		KASSERT(te != &tqs, ("%s: temporary stack based entry not "		    "first element in queue", __func__));		LIST_INSERT_AFTER(p, te, tqe_q);	}
KASSERT(te != &tqs, ("%s: temporary stack based entry not "		    "first element in queue", __func__));
KASSERT(te != &tqs, ("%s: temporary stack based entry not "		    "first element in queue", __func__))
KASSERT
KASSERT
te != &tqs
te
te
&tqs
tqs
tqs
("%s: temporary stack based entry not "		    "first element in queue", __func__)
"%s: temporary stack based entry not "		    "first element in queue", __func__
"%s: temporary stack based entry not "		    "first element in queue"
__func__
__func__
LIST_INSERT_AFTER(p, te, tqe_q);
LIST_INSERT_AFTER(p, te, tqe_q)
LIST_INSERT_AFTER
LIST_INSERT_AFTER
p
p
te
te
tqe_q
tqe_q
present:	/*	 * Present data to user, advancing rcv_nxt through	 * completed sequence space.	 */	if (!TCPS_HAVEESTABLISHED(tp->t_state))		return (0);
present
if (!TCPS_HAVEESTABLISHED(tp->t_state))		return (0);
!TCPS_HAVEESTABLISHED(tp->t_state)
TCPS_HAVEESTABLISHED(tp->t_state)
TCPS_HAVEESTABLISHED
TCPS_HAVEESTABLISHED
tp->t_state
tp
tp
t_state
return (0);
(0)
0
q = LIST_FIRST(&tp->t_segq);
q = LIST_FIRST(&tp->t_segq)
q
q
LIST_FIRST(&tp->t_segq)
LIST_FIRST
LIST_FIRST
&tp->t_segq
tp->t_segq
tp
tp
t_segq
if (!q || q->tqe_th->th_seq != tp->rcv_nxt)		return (0);
!q || q->tqe_th->th_seq != tp->rcv_nxt
!q
q
q
q->tqe_th->th_seq != tp->rcv_nxt
q->tqe_th->th_seq
q->tqe_th
q
q
tqe_th
th_seq
tp->rcv_nxt
tp
tp
rcv_nxt
return (0);
(0)
0
SOCKBUF_LOCK(&so->so_rcv);
SOCKBUF_LOCK(&so->so_rcv)
SOCKBUF_LOCK
SOCKBUF_LOCK
&so->so_rcv
so->so_rcv
so
so
so_rcv
do {		tp->rcv_nxt += q->tqe_len;		flags = q->tqe_th->th_flags & TH_FIN;		nq = LIST_NEXT(q, tqe_q);		LIST_REMOVE(q, tqe_q);		if (so->so_rcv.sb_state & SBS_CANTRCVMORE)			m_freem(q->tqe_m);		else			sbappendstream_locked(&so->so_rcv, q->tqe_m, 0);		if (q != &tqs)			uma_zfree(tcp_reass_zone, q);		tp->t_segqlen--;		q = nq;	} while (q && q->tqe_th->th_seq == tp->rcv_nxt);
{		tp->rcv_nxt += q->tqe_len;		flags = q->tqe_th->th_flags & TH_FIN;		nq = LIST_NEXT(q, tqe_q);		LIST_REMOVE(q, tqe_q);		if (so->so_rcv.sb_state & SBS_CANTRCVMORE)			m_freem(q->tqe_m);		else			sbappendstream_locked(&so->so_rcv, q->tqe_m, 0);		if (q != &tqs)			uma_zfree(tcp_reass_zone, q);		tp->t_segqlen--;		q = nq;	}
tp->rcv_nxt += q->tqe_len;
tp->rcv_nxt += q->tqe_len
tp->rcv_nxt
tp
tp
rcv_nxt
q->tqe_len
q
q
tqe_len
flags = q->tqe_th->th_flags & TH_FIN;
flags = q->tqe_th->th_flags & TH_FIN
flags
flags
q->tqe_th->th_flags & TH_FIN
q->tqe_th->th_flags
q->tqe_th
q
q
tqe_th
th_flags
TH_FIN
TH_FIN
nq = LIST_NEXT(q, tqe_q);
nq = LIST_NEXT(q, tqe_q)
nq
nq
LIST_NEXT(q, tqe_q)
LIST_NEXT
LIST_NEXT
q
q
tqe_q
tqe_q
LIST_REMOVE(q, tqe_q);
LIST_REMOVE(q, tqe_q)
LIST_REMOVE
LIST_REMOVE
q
q
tqe_q
tqe_q
if (so->so_rcv.sb_state & SBS_CANTRCVMORE)			m_freem(q->tqe_m);		else			sbappendstream_locked(&so->so_rcv, q->tqe_m, 0);
so->so_rcv.sb_state & SBS_CANTRCVMORE
so->so_rcv.sb_state
so->so_rcv
so
so
so_rcv
sb_state
SBS_CANTRCVMORE
SBS_CANTRCVMORE
m_freem(q->tqe_m);
m_freem(q->tqe_m)
m_freem
m_freem
q->tqe_m
q
q
tqe_m
sbappendstream_locked(&so->so_rcv, q->tqe_m, 0);
sbappendstream_locked(&so->so_rcv, q->tqe_m, 0)
sbappendstream_locked
sbappendstream_locked
&so->so_rcv
so->so_rcv
so
so
so_rcv
q->tqe_m
q
q
tqe_m
0
if (q != &tqs)			uma_zfree(tcp_reass_zone, q);
q != &tqs
q
q
&tqs
tqs
tqs
uma_zfree(tcp_reass_zone, q);
uma_zfree(tcp_reass_zone, q)
uma_zfree
uma_zfree
tcp_reass_zone
tcp_reass_zone
q
q
tp->t_segqlen--;
tp->t_segqlen--
tp->t_segqlen
tp
tp
t_segqlen
q = nq;
q = nq
q
q
nq
nq
q && q->tqe_th->th_seq == tp->rcv_nxt
q
q
q->tqe_th->th_seq == tp->rcv_nxt
q->tqe_th->th_seq
q->tqe_th
q
q
tqe_th
th_seq
tp->rcv_nxt
tp
tp
rcv_nxt
sorwakeup_locked(so);
sorwakeup_locked(so)
sorwakeup_locked
sorwakeup_locked
so
so
return (flags);
(flags)
flags
flags
-----joern-----
(256,188,0)
(140,327,0)
(411,423,0)
(267,436,0)
(212,237,0)
(248,456,0)
(258,301,0)
(87,196,0)
(256,380,0)
(247,452,0)
(390,98,0)
(342,166,0)
(8,282,0)
(232,224,0)
(290,237,0)
(270,51,0)
(322,224,0)
(395,232,0)
(19,382,0)
(288,509,0)
(163,84,0)
(282,294,0)
(198,109,0)
(231,270,0)
(25,56,0)
(95,295,0)
(201,295,0)
(92,71,0)
(484,477,0)
(463,325,0)
(107,104,0)
(447,130,0)
(393,196,0)
(144,51,0)
(88,198,0)
(279,191,0)
(40,128,0)
(282,350,0)
(118,391,0)
(79,25,0)
(392,350,0)
(229,32,0)
(277,254,0)
(73,272,0)
(324,230,0)
(198,103,0)
(37,414,0)
(314,471,0)
(199,89,0)
(275,301,0)
(321,483,0)
(247,232,0)
(196,204,0)
(231,328,0)
(60,109,0)
(70,459,0)
(383,166,0)
(173,18,0)
(154,358,0)
(442,448,0)
(386,455,0)
(184,170,0)
(247,328,0)
(492,361,0)
(452,280,0)
(382,160,0)
(327,230,0)
(290,230,0)
(318,18,0)
(320,275,0)
(247,140,0)
(61,399,0)
(313,243,0)
(320,226,0)
(507,61,0)
(406,25,0)
(285,477,0)
(451,391,0)
(84,305,0)
(250,492,0)
(231,232,0)
(440,499,0)
(261,299,0)
(486,18,0)
(186,355,0)
(66,165,0)
(93,224,0)
(356,435,0)
(454,279,0)
(373,230,0)
(315,36,0)
(487,355,0)
(3,309,0)
(477,484,0)
(483,167,0)
(313,357,0)
(41,465,0)
(330,469,0)
(213,202,0)
(77,492,0)
(252,295,0)
(488,507,0)
(51,391,0)
(182,56,0)
(89,391,0)
(182,209,0)
(508,436,0)
(460,190,0)
(291,6,0)
(507,109,0)
(247,25,0)
(182,89,0)
(267,452,0)
(118,280,0)
(97,120,0)
(82,206,0)
(316,439,0)
(293,430,0)
(325,295,0)
(222,51,0)
(108,448,0)
(287,456,0)
(47,388,0)
(504,410,0)
(20,314,0)
(82,209,0)
(294,185,0)
(50,439,0)
(351,348,0)
(28,391,0)
(257,254,0)
(404,406,0)
(399,19,0)
(265,390,0)
(493,510,0)
(324,428,0)
(348,391,0)
(454,301,0)
(487,226,0)
(279,98,0)
(300,357,0)
(80,483,0)
(455,358,0)
(467,299,0)
(267,270,0)
(219,475,0)
(299,109,0)
(54,430,0)
(123,497,0)
(495,325,0)
(157,466,0)
(172,330,0)
(159,186,0)
(233,484,0)
(35,265,0)
(134,407,0)
(17,399,0)
(152,46,0)
(404,235,0)
(14,399,0)
(127,443,0)
(305,84,0)
(175,367,0)
(156,249,0)
(6,71,0)
(296,465,0)
(18,280,0)
(139,391,0)
(93,271,0)
(5,254,0)
(385,290,0)
(20,280,0)
(372,160,0)
(48,236,0)
(15,32,0)
(100,464,0)
(193,136,0)
(220,309,0)
(389,6,0)
(412,327,0)
(156,104,0)
(496,160,0)
(376,85,0)
(183,65,0)
(357,401,0)
(307,178,0)
(468,328,0)
(494,391,0)
(65,391,0)
(192,292,0)
(75,389,0)
(328,230,0)
(267,507,0)
(464,322,0)
(470,391,0)
(492,109,0)
(164,143,0)
(470,456,0)
(202,81,0)
(160,382,0)
(270,206,0)
(474,437,0)
(333,26,0)
(166,342,0)
(235,117,0)
(246,445,0)
(358,455,0)
(33,301,0)
(203,452,0)
(249,83,0)
(366,122,0)
(63,437,0)
(236,51,0)
(394,401,0)
(425,477,0)
(451,380,0)
(295,448,0)
(268,132,0)
(457,510,0)
(274,497,0)
(406,444,0)
(271,93,0)
(125,182,0)
(428,324,0)
(21,391,0)
(374,207,0)
(414,301,0)
(266,436,0)
(445,391,0)
(234,307,0)
(331,95,0)
(167,483,0)
(507,267,0)
(194,386,0)
(244,226,0)
(170,272,0)
(404,168,0)
(133,81,0)
(478,401,0)
(380,189,0)
(117,235,0)
(339,414,0)
(195,401,0)
(9,394,0)
(225,391,0)
(384,81,0)
(377,367,0)
(160,269,0)
(206,391,0)
(236,367,0)
(510,230,0)
(128,355,0)
(387,9,0)
(309,51,0)
(72,505,0)
(216,324,0)
(461,380,0)
(191,279,0)
(45,60,0)
(27,283,0)
(31,505,0)
(210,205,0)
(238,275,0)
(61,444,0)
(267,448,0)
(350,282,0)
(339,391,0)
(489,46,0)
(450,201,0)
(34,391,0)
(127,283,0)
(103,178,0)
(293,28,0)
(43,414,0)
(262,389,0)
(53,269,0)
(110,185,0)
(144,224,0)
(232,51,0)
(433,337,0)
(354,475,0)
(231,144,0)
(178,103,0)
(25,209,0)
(284,205,0)
(343,185,0)
(406,452,0)
(242,295,0)
(371,237,0)
(207,509,0)
(67,454,0)
(191,280,0)
(68,270,0)
(176,230,0)
(104,301,0)
(113,299,0)
(435,224,0)
(408,47,0)
(235,404,0)
(492,295,0)
(297,168,0)
(122,510,0)
(254,449,0)
(231,140,0)
(465,301,0)
(477,380,0)
(62,294,0)
(269,312,0)
(201,109,0)
(409,71,0)
(498,283,0)
(224,435,0)
(56,294,0)
(166,383,0)
(10,367,0)
(56,312,0)
(78,405,0)
(350,209,0)
(418,448,0)
(467,204,0)
(303,471,0)
(464,375,0)
(11,244,0)
(357,9,0)
(217,328,0)
(178,307,0)
(193,345,0)
(471,301,0)
(189,380,0)
(499,391,0)
(458,175,0)
(91,391,0)
(263,82,0)
(292,204,0)
(170,301,0)
(138,353,0)
(341,391,0)
(243,150,0)
(410,307,0)
(22,330,0)
(89,182,0)
(302,236,0)
(97,51,0)
(12,170,0)
(76,275,0)
(465,442,0)
(103,198,0)
(122,399,0)
(207,374,0)
(90,453,0)
(467,406,0)
(181,144,0)
(400,138,0)
(243,190,0)
(353,237,0)
(338,345,0)
(177,322,0)
(283,127,0)
(141,189,0)
(507,295,0)
(358,154,0)
(328,61,0)
(443,127,0)
(165,162,0)
(200,386,0)
(267,140,0)
(189,141,0)
(228,237,0)
(344,97,0)
(241,377,0)
(424,141,0)
(369,97,0)
(480,62,0)
(239,100,0)
(214,363,0)
(464,100,0)
(484,233,0)
(137,315,0)
(382,19,0)
(18,255,0)
(322,363,0)
(497,175,0)
(240,423,0)
(405,6,0)
(260,20,0)
(16,20,0)
(426,61,0)
(208,140,0)
(352,391,0)
(353,138,0)
(205,210,0)
(174,391,0)
(330,255,0)
(473,71,0)
(9,209,0)
(399,237,0)
(126,460,0)
(117,295,0)
(255,18,0)
(272,142,0)
(175,497,0)
(23,258,0)
(116,289,0)
(247,144,0)
(143,164,0)
(509,301,0)
(61,25,0)
(193,151,0)
(14,444,0)
(186,190,0)
(506,394,0)
(24,401,0)
(421,95,0)
(119,219,0)
(245,271,0)
(55,93,0)
(370,150,0)
(361,492,0)
(415,151,0)
(367,65,0)
(278,212,0)
(124,100,0)
(58,224,0)
(197,351,0)
(423,14,0)
(383,388,0)
(14,423,0)
(311,404,0)
(138,301,0)
(150,209,0)
(171,305,0)
(247,270,0)
(104,156,0)
(315,230,0)
(323,391,0)
(334,26,0)
(92,84,0)
(167,274,0)
(85,391,0)
(167,377,0)
(452,269,0)
(269,25,0)
(336,484,0)
(236,375,0)
(219,230,0)
(267,144,0)
(509,207,0)
(407,391,0)
(265,35,0)
(153,383,0)
(267,25,0)
(35,301,0)
(510,122,0)
(218,236,0)
(294,274,0)
(422,391,0)
(196,301,0)
(259,391,0)
(162,165,0)
(430,293,0)
(81,202,0)
(482,312,0)
(99,407,0)
(267,328,0)
(97,224,0)
(313,410,0)
(314,20,0)
(74,453,0)
(437,224,0)
(438,232,0)
(304,391,0)
(158,358,0)
(96,428,0)
(168,295,0)
(212,230,0)
(230,475,0)
(279,454,0)
(501,35,0)
(430,380,0)
(299,467,0)
(390,265,0)
(69,162,0)
(305,301,0)
(135,132,0)
(188,256,0)
(453,367,0)
(427,471,0)
(368,175,0)
(349,47,0)
(204,292,0)
(455,386,0)
(206,82,0)
(94,391,0)
(61,140,0)
(224,151,0)
(39,377,0)
(337,433,0)
(84,92,0)
(433,42,0)
(432,136,0)
(32,469,0)
(497,274,0)
(114,308,0)
(483,280,0)
(416,294,0)
(1,33,0)
(231,25,0)
(258,267,0)
(71,92,0)
(479,237,0)
(397,330,0)
(24,355,0)
(81,380,0)
(98,390,0)
(419,454,0)
(476,467,0)
(164,109,0)
(188,306,0)
(7,198,0)
(317,391,0)
(254,388,0)
(0,191,0)
(26,334,0)
(378,26,0)
(82,56,0)
(265,165,0)
(141,301,0)
(340,255,0)
(130,301,0)
(345,193,0)
(211,233,0)
(471,314,0)
(165,265,0)
(155,444,0)
(365,367,0)
(273,178,0)
(236,224,0)
(60,295,0)
(160,280,0)
(46,51,0)
(322,51,0)
(97,334,0)
(428,19,0)
(36,315,0)
(325,109,0)
(102,219,0)
(386,280,0)
(286,130,0)
(231,452,0)
(270,224,0)
(249,156,0)
(204,196,0)
(475,237,0)
(326,117,0)
(130,286,0)
(192,109,0)
(215,14,0)
(61,452,0)
(223,190,0)
(44,406,0)
(398,391,0)
(377,167,0)
(205,226,0)
(295,434,0)
(59,383,0)
(19,399,0)
(132,399,0)
(187,389,0)
(459,382,0)
(121,305,0)
(481,164,0)
(276,290,0)
(417,210,0)
(502,254,0)
(283,301,0)
(443,98,0)
(179,258,0)
(168,404,0)
(19,428,0)
(140,406,0)
(145,451,0)
(360,351,0)
(52,306,0)
(30,192,0)
(380,391,0)
(396,327,0)
(363,322,0)
(475,219,0)
(83,249,0)
(51,309,0)
(383,280,0)
(431,243,0)
(4,430,0)
(459,56,0)
(337,301,0)
(95,306,0)
(472,60,0)
(33,342,0)
(146,144,0)
(456,470,0)
(423,230,0)
(334,97,0)
(342,33,0)
(429,212,0)
(136,193,0)
(500,342,0)
(306,95,0)
(307,448,0)
(204,467,0)
(505,280,0)
(402,405,0)
(111,308,0)
(93,51,0)
(221,104,0)
(115,389,0)
(227,499,0)
(442,465,0)
(147,256,0)
(403,154,0)
(306,188,0)
(420,391,0)
(434,325,0)
(286,162,0)
(2,168,0)
(456,301,0)
(382,459,0)
(62,355,0)
(436,301,0)
(314,83,0)
(362,231,0)
(164,295,0)
(267,232,0)
(292,192,0)
(436,267,0)
(32,255,0)
(347,337,0)
(64,391,0)
(264,270,0)
(359,226,0)
(251,189,0)
(258,235,0)
(322,464,0)
(274,167,0)
(405,329,0)
(253,130,0)
(198,295,0)
(106,56,0)
(210,209,0)
(180,62,0)
(42,433,0)
(202,286,0)
(98,279,0)
(47,449,0)
(144,128,0)
(319,388,0)
(26,301,0)
(437,51,0)
(298,324,0)
(83,314,0)
(105,191,0)
(281,507,0)
(36,237,0)
(414,339,0)
(327,140,0)
(413,138,0)
(142,18,0)
(129,118,0)
(406,399,0)
(381,143,0)
(95,109,0)
(269,294,0)
(60,448,0)
(109,42,0)
(230,237,0)
(351,301,0)
(388,383,0)
(28,293,0)
(150,460,0)
(286,202,0)
(148,71,0)
(98,443,0)
(42,109,0)
(332,33,0)
(49,452,0)
(62,312,0)
(142,272,0)
(131,109,0)
(441,256,0)
(439,294,0)
(232,118,0)
(169,103,0)
(71,280,0)
(101,35,0)
(313,247,0)
(308,367,0)
(434,448,0)
(348,351,0)
(491,383,0)
(289,190,0)
(86,315,0)
(162,286,0)
(13,337,0)
(136,432,0)
(128,391,0)
(325,434,0)
(389,329,0)
(379,226,0)
(410,391,0)
(446,330,0)
(459,209,0)
(57,154,0)
(310,247,0)
(313,231,0)
(109,391,0)
(462,509,0)
(71,6,0)
(364,201,0)
(503,434,0)
(275,320,0)
(149,24,0)
(274,294,0)
(38,478,0)
(18,142,0)
(29,487,0)
(235,258,0)
(485,85,0)
(272,170,0)
(112,141,0)
(198,295,1)
(95,331,1)
(327,230,1)
(387,24,1)
(252,242,1)
(416,308,1)
(15,229,1)
(70,160,1)
(164,143,1)
(144,224,1)
(166,342,1)
(217,468,1)
(372,17,1)
(336,477,1)
(219,230,1)
(191,280,1)
(135,268,1)
(98,443,1)
(233,484,1)
(232,224,1)
(497,123,1)
(428,96,1)
(476,299,1)
(281,488,1)
(192,30,1)
(374,207,1)
(472,434,1)
(44,140,1)
(76,437,1)
(1,319,1)
(417,284,1)
(3,222,1)
(264,118,1)
(451,380,1)
(487,29,1)
(81,380,1)
(443,127,1)
(488,436,1)
(86,212,1)
(267,452,1)
(89,182,1)
(502,257,1)
(162,69,1)
(373,353,1)
(189,141,1)
(318,173,1)
(247,270,1)
(480,180,1)
(267,270,1)
(123,175,1)
(278,475,1)
(363,214,1)
(170,301,1)
(160,496,1)
(471,427,1)
(453,367,1)
(186,355,1)
(270,51,1)
(247,232,1)
(128,40,1)
(83,249,1)
(430,380,1)
(451,145,1)
(160,280,1)
(446,397,1)
(436,301,1)
(433,337,1)
(59,491,1)
(60,295,1)
(298,382,1)
(464,239,1)
(271,245,1)
(279,191,1)
(14,215,1)
(508,266,1)
(438,395,1)
(61,452,1)
(484,477,1)
(169,198,1)
(477,285,1)
(462,236,1)
(182,125,1)
(489,152,1)
(351,360,1)
(454,301,1)
(254,5,1)
(325,295,1)
(505,280,1)
(324,230,1)
(394,506,1)
(61,399,1)
(483,280,1)
(128,355,1)
(129,232,1)
(272,170,1)
(358,154,1)
(211,484,1)
(219,119,1)
(19,382,1)
(201,364,1)
(346,132,1)
(319,460,1)
(234,267,1)
(164,295,1)
(247,25,1)
(267,144,1)
(32,255,1)
(97,334,1)
(284,244,1)
(130,253,1)
(114,367,1)
(117,235,1)
(414,37,1)
(49,203,1)
(168,295,1)
(282,294,1)
(267,232,1)
(144,181,1)
(201,295,1)
(82,209,1)
(507,61,1)
(26,333,1)
(56,106,1)
(351,301,1)
(165,162,1)
(210,209,1)
(450,164,1)
(302,48,1)
(313,410,1)
(327,412,1)
(18,280,1)
(175,458,1)
(196,301,1)
(231,362,1)
(84,305,1)
(383,166,1)
(453,90,1)
(246,339,1)
(212,429,1)
(62,480,1)
(10,455,1)
(23,404,1)
(393,87,1)
(356,58,1)
(121,171,1)
(452,280,1)
(258,301,1)
(366,132,1)
(156,104,1)
(221,314,1)
(297,2,1)
(405,6,1)
(384,133,1)
(212,230,1)
(386,200,1)
(5,502,1)
(92,84,1)
(445,246,1)
(269,53,1)
(303,20,1)
(308,111,1)
(492,77,1)
(412,396,1)
(43,269,1)
(340,224,1)
(455,358,1)
(45,472,1)
(267,25,1)
(430,4,1)
(296,41,1)
(122,510,1)
(380,189,1)
(305,301,1)
(382,459,1)
(369,344,1)
(36,315,1)
(182,209,1)
(459,56,1)
(231,25,1)
(459,209,1)
(63,93,1)
(357,9,1)
(203,56,1)
(210,417,1)
(141,424,1)
(47,349,1)
(81,384,1)
(265,35,1)
(218,464,1)
(222,390,1)
(495,503,1)
(199,445,1)
(165,66,1)
(406,25,1)
(290,230,1)
(402,389,1)
(79,62,1)
(14,399,1)
(315,137,1)
(88,234,1)
(338,83,1)
(314,20,1)
(440,227,1)
(180,282,1)
(258,267,1)
(119,102,1)
(231,270,1)
(310,374,1)
(300,6,1)
(493,457,1)
(403,470,1)
(93,224,1)
(377,241,1)
(248,46,1)
(458,368,1)
(27,498,1)
(168,297,1)
(509,288,1)
(117,326,1)
(138,400,1)
(150,209,1)
(272,73,1)
(328,230,1)
(383,280,1)
(344,334,1)
(400,413,1)
(101,501,1)
(24,355,1)
(202,81,1)
(132,135,1)
(462,97,1)
(164,109,1)
(330,446,1)
(149,478,1)
(354,122,1)
(46,51,1)
(404,168,1)
(439,294,1)
(464,100,1)
(507,281,1)
(377,367,1)
(263,270,1)
(182,56,1)
(170,184,1)
(154,57,1)
(162,286,1)
(57,403,1)
(483,80,1)
(294,274,1)
(275,238,1)
(194,358,1)
(192,109,1)
(410,504,1)
(437,474,1)
(71,148,1)
(287,248,1)
(97,51,1)
(230,475,1)
(140,208,1)
(490,505,1)
(462,379,1)
(78,402,1)
(235,258,1)
(320,275,1)
(138,301,1)
(207,509,1)
(243,431,1)
(146,346,1)
(186,159,1)
(386,280,1)
(163,305,1)
(136,432,1)
(503,307,1)
(187,75,1)
(423,240,1)
(231,232,1)
(283,27,1)
(193,136,1)
(405,78,1)
(461,407,1)
(133,35,1)
(324,216,1)
(242,442,1)
(14,423,1)
(376,485,1)
(299,109,1)
(146,155,1)
(337,301,1)
(322,224,1)
(397,172,1)
(117,295,1)
(32,15,1)
(18,318,1)
(492,295,1)
(439,50,1)
(262,6,1)
(18,142,1)
(35,101,1)
(247,328,1)
(61,426,1)
(270,68,1)
(326,295,1)
(17,161,1)
(102,354,1)
(43,308,1)
(160,269,1)
(235,404,1)
(232,51,1)
(487,355,1)
(132,399,1)
(76,93,1)
(60,109,1)
(244,11,1)
(115,187,1)
(368,416,1)
(191,105,1)
(331,421,1)
(314,471,1)
(500,33,1)
(9,387,1)
(2,326,1)
(159,47,1)
(47,388,1)
(61,25,1)
(248,255,1)
(231,328,1)
(328,217,1)
(424,112,1)
(230,176,1)
(498,279,1)
(337,347,1)
(236,302,1)
(200,194,1)
(270,224,1)
(55,487,1)
(134,499,1)
(277,388,1)
(118,129,1)
(239,124,1)
(155,14,1)
(431,186,1)
(103,169,1)
(147,441,1)
(471,301,1)
(509,301,1)
(258,179,1)
(427,303,1)
(293,430,1)
(20,280,1)
(456,301,1)
(96,324,1)
(56,294,1)
(0,505,1)
(28,293,1)
(325,109,1)
(437,51,1)
(322,51,1)
(497,175,1)
(266,28,1)
(295,434,1)
(335,455,1)
(507,109,1)
(309,220,1)
(413,290,1)
(388,383,1)
(136,345,1)
(411,61,1)
(31,348,1)
(273,103,1)
(181,146,1)
(408,254,1)
(501,98,1)
(85,376,1)
(330,255,1)
(104,301,1)
(496,372,1)
(266,117,1)
(247,140,1)
(140,327,1)
(71,280,1)
(288,462,1)
(72,31,1)
(251,141,1)
(267,140,1)
(46,489,1)
(357,300,1)
(97,224,1)
(167,377,1)
(137,86,1)
(385,36,1)
(499,440,1)
(95,295,1)
(306,95,1)
(233,211,1)
(107,221,1)
(71,92,1)
(13,131,1)
(436,508,1)
(291,394,1)
(247,310,1)
(50,316,1)
(90,74,1)
(378,453,1)
(486,142,1)
(348,351,1)
(255,18,1)
(404,311,1)
(456,287,1)
(481,361,1)
(141,301,1)
(350,392,1)
(214,177,1)
(232,438,1)
(95,109,1)
(365,10,1)
(167,483,1)
(289,116,1)
(414,301,1)
(475,219,1)
(367,365,1)
(112,461,1)
(29,205,1)
(196,393,1)
(347,13,1)
(143,381,1)
(256,380,1)
(175,367,1)
(274,167,1)
(349,408,1)
(322,363,1)
(437,224,1)
(104,107,1)
(248,32,1)
(171,291,1)
(125,199,1)
(477,380,1)
(43,439,1)
(51,309,1)
(467,406,1)
(260,16,1)
(33,332,1)
(35,301,1)
(238,76,1)
(80,321,1)
(434,325,1)
(406,399,1)
(231,452,1)
(144,51,1)
(97,369,1)
(77,250,1)
(236,367,1)
(82,56,1)
(345,338,1)
(105,0,1)
(467,476,1)
(465,301,1)
(464,322,1)
(33,301,1)
(62,294,1)
(286,202,1)
(249,156,1)
(285,425,1)
(153,59,1)
(267,436,1)
(224,435,1)
(406,44,1)
(267,507,1)
(198,109,1)
(69,286,1)
(30,109,1)
(53,452,1)
(26,301,1)
(292,192,1)
(308,367,1)
(124,322,1)
(342,500,1)
(307,178,1)
(215,423,1)
(161,89,1)
(172,22,1)
(19,428,1)
(247,452,1)
(67,419,1)
(152,51,1)
(103,198,1)
(428,324,1)
(197,85,1)
(145,117,1)
(243,150,1)
(333,378,1)
(485,380,1)
(62,355,1)
(492,109,1)
(459,70,1)
(240,411,1)
(321,377,1)
(118,280,1)
(7,88,1)
(61,140,1)
(16,46,1)
(399,19,1)
(9,209,1)
(364,450,1)
(454,67,1)
(306,52,1)
(179,23,1)
(42,433,1)
(442,465,1)
(491,166,1)
(474,63,1)
(379,320,1)
(127,283,1)
(82,263,1)
(198,7,1)
(193,345,1)
(113,192,1)
(161,230,1)
(159,388,1)
(20,260,1)
(202,213,1)
(24,149,1)
(25,209,1)
(339,414,1)
(130,301,1)
(292,204,1)
(460,126,1)
(441,233,1)
(178,103,1)
(254,388,1)
(421,188,1)
(409,473,1)
(389,6,1)
(265,165,1)
(75,262,1)
(305,121,1)
(11,282,1)
(392,8,1)
(452,49,1)
(425,60,1)
(189,251,1)
(383,153,1)
(286,130,1)
(201,109,1)
(208,327,1)
(267,328,1)
(360,197,1)
(404,406,1)
(93,271,1)
(484,336,1)
(4,54,1)
(478,38,1)
(423,230,1)
(390,98,1)
(158,154,1)
(406,452,1)
(250,233,1)
(506,9,1)
(52,95,1)
(126,150,1)
(261,113,1)
(109,42,1)
(220,3,1)
(142,272,1)
(216,298,1)
(361,492,1)
(268,399,1)
(468,406,1)
(236,51,1)
(435,356,1)
(276,385,1)
(87,467,1)
(470,456,1)
(426,328,1)
(306,188,1)
(41,201,1)
(84,163,1)
(98,279,1)
(390,265,1)
(342,33,1)
(205,210,1)
(177,453,1)
(507,295,1)
(455,386,1)
(465,296,1)
(467,299,1)
(300,405,1)
(122,399,1)
(247,144,1)
(173,486,1)
(188,256,1)
(148,409,1)
(83,314,1)
(325,463,1)
(231,140,1)
(463,495,1)
(295,252,1)
(313,247,1)
(269,294,1)
(457,366,1)
(396,122,1)
(74,206,1)
(38,83,1)
(150,370,1)
(429,278,1)
(176,373,1)
(447,202,1)
(282,350,1)
(39,497,1)
(290,276,1)
(473,92,1)
(213,81,1)
(111,114,1)
(8,439,1)
(504,451,1)
(37,43,1)
(275,301,1)
(48,218,1)
(334,26,1)
(410,307,1)
(370,289,1)
(362,292,1)
(481,306,1)
(60,45,1)
(253,447,1)
(73,170,1)
(6,71,1)
(395,128,1)
(41,164,1)
(146,161,1)
(462,490,1)
(54,292,1)
(178,273,1)
(204,467,1)
(313,231,1)
(231,144,1)
(93,51,1)
(510,230,1)
(99,134,1)
(407,99,1)
(505,72,1)
(66,162,1)
(313,243,1)
(419,191,1)
(313,357,1)
(116,390,1)
(279,454,1)
(274,497,1)
(316,294,1)
(311,168,1)
(58,193,1)
(106,25,1)
(131,374,1)
(22,255,1)
(381,481,1)
(283,301,1)
(350,209,1)
(68,264,1)
(204,196,1)
(257,277,1)
(12,340,1)
(25,79,1)
(256,147,1)
(184,12,1)
(299,261,1)
(10,335,1)
(358,158,1)
(40,144,1)
(269,25,1)
(510,493,1)
(389,115,1)
(229,330,1)
(206,82,1)
(236,224,1)
(332,1,1)
(353,138,1)
(241,39,1)
(315,230,1)
(245,55,1)
(382,160,1)
(337,374,2)
(168,326,2)
(325,117,2)
(267,436,2)
(130,98,2)
(71,92,2)
(380,189,2)
(224,83,2)
(453,308,2)
(314,20,2)
(257,388,2)
(128,282,2)
(306,188,2)
(290,122,2)
(23,326,2)
(484,117,2)
(462,46,2)
(28,293,2)
(212,230,2)
(207,509,2)
(48,453,2)
(114,46,2)
(465,292,2)
(423,230,2)
(37,439,2)
(434,117,2)
(82,308,2)
(58,83,2)
(18,280,2)
(334,26,2)
(399,161,2)
(202,98,2)
(219,230,2)
(465,301,2)
(483,280,2)
(507,109,2)
(109,374,2)
(129,308,2)
(242,292,2)
(315,230,2)
(143,292,2)
(154,46,2)
(43,439,2)
(231,140,2)
(255,83,2)
(374,505,2)
(442,117,2)
(269,294,2)
(66,98,2)
(507,292,2)
(447,98,2)
(306,233,2)
(208,122,2)
(464,322,2)
(179,326,2)
(198,292,2)
(77,233,2)
(339,439,2)
(160,161,2)
(104,301,2)
(129,439,2)
(477,117,2)
(307,292,2)
(206,308,2)
(45,117,2)
(73,83,2)
(1,390,2)
(464,100,2)
(267,270,2)
(128,355,2)
(83,46,2)
(384,98,2)
(138,122,2)
(459,161,2)
(83,314,2)
(43,308,2)
(322,453,2)
(82,439,2)
(309,390,2)
(248,83,2)
(207,46,2)
(281,292,2)
(267,232,2)
(103,198,2)
(370,390,2)
(313,357,2)
(382,161,2)
(98,443,2)
(82,209,2)
(443,279,2)
(162,98,2)
(97,453,2)
(300,83,2)
(159,390,2)
(192,374,2)
(199,282,2)
(61,399,2)
(289,390,2)
(111,83,2)
(425,117,2)
(119,122,2)
(427,46,2)
(52,233,2)
(367,46,2)
(10,46,2)
(245,282,2)
(331,233,2)
(182,308,2)
(327,230,2)
(471,46,2)
(78,6,2)
(74,308,2)
(17,161,2)
(125,308,2)
(305,301,2)
(389,6,2)
(125,439,2)
(96,161,2)
(279,505,2)
(383,390,2)
(472,292,2)
(32,255,2)
(288,83,2)
(56,282,2)
(167,483,2)
(395,282,2)
(167,377,2)
(101,98,2)
(477,380,2)
(488,292,2)
(439,308,2)
(205,210,2)
(361,492,2)
(295,292,2)
(291,83,2)
(507,117,2)
(146,439,2)
(382,459,2)
(95,295,2)
(128,439,2)
(167,308,2)
(436,292,2)
(263,282,2)
(369,453,2)
(404,406,2)
(437,224,2)
(297,326,2)
(406,25,2)
(307,178,2)
(480,282,2)
(390,98,2)
(487,355,2)
(90,308,2)
(500,390,2)
(505,280,2)
(71,83,2)
(165,162,2)
(166,390,2)
(92,83,2)
(232,439,2)
(207,83,2)
(247,232,2)
(286,130,2)
(164,143,2)
(7,292,2)
(347,374,2)
(249,156,2)
(430,292,2)
(60,295,2)
(90,282,2)
(89,439,2)
(122,132,2)
(388,383,2)
(453,367,2)
(456,46,2)
(199,439,2)
(327,122,2)
(490,505,2)
(231,452,2)
(430,380,2)
(232,308,2)
(339,308,2)
(19,382,2)
(37,308,2)
(61,140,2)
(12,83,2)
(286,98,2)
(307,117,2)
(206,82,2)
(299,109,2)
(270,439,2)
(37,282,2)
(109,42,2)
(201,164,2)
(442,465,2)
(169,292,2)
(26,453,2)
(123,308,2)
(404,168,2)
(358,83,2)
(353,138,2)
(417,282,2)
(410,292,2)
(507,61,2)
(40,439,2)
(248,46,2)
(425,292,2)
(326,292,2)
(357,83,2)
(231,328,2)
(19,428,2)
(339,282,2)
(40,308,2)
(143,117,2)
(285,292,2)
(95,109,2)
(132,161,2)
(152,390,2)
(234,117,2)
(270,224,2)
(486,83,2)
(214,453,2)
(232,224,2)
(454,505,2)
(125,282,2)
(445,308,2)
(419,505,2)
(229,255,2)
(210,282,2)
(344,453,2)
(57,46,2)
(365,83,2)
(236,453,2)
(16,46,2)
(393,192,2)
(160,280,2)
(484,477,2)
(324,230,2)
(199,308,2)
(275,301,2)
(484,292,2)
(191,280,2)
(319,390,2)
(437,51,2)
(334,453,2)
(118,282,2)
(502,388,2)
(455,358,2)
(414,439,2)
(273,117,2)
(467,299,2)
(265,35,2)
(153,390,2)
(103,292,2)
(188,256,2)
(235,404,2)
(292,204,2)
(266,292,2)
(455,46,2)
(346,132,2)
(264,308,2)
(385,122,2)
(328,230,2)
(450,164,2)
(161,122,2)
(9,83,2)
(303,46,2)
(233,292,2)
(82,282,2)
(180,282,2)
(230,122,2)
(14,423,2)
(161,282,2)
(252,117,2)
(62,282,2)
(473,83,2)
(287,83,2)
(25,282,2)
(39,308,2)
(122,510,2)
(255,18,2)
(51,390,2)
(362,292,2)
(166,342,2)
(129,282,2)
(270,51,2)
(278,122,2)
(50,308,2)
(168,295,2)
(188,233,2)
(60,292,2)
(330,255,2)
(61,122,2)
(117,292,2)
(118,280,2)
(489,390,2)
(89,282,2)
(322,363,2)
(313,243,2)
(76,282,2)
(236,51,2)
(475,219,2)
(492,295,2)
(220,390,2)
(374,46,2)
(462,505,2)
(178,292,2)
(156,104,2)
(206,439,2)
(460,390,2)
(45,292,2)
(234,292,2)
(314,471,2)
(435,83,2)
(495,292,2)
(261,192,2)
(353,122,2)
(382,160,2)
(74,282,2)
(89,308,2)
(296,292,2)
(49,282,2)
(467,406,2)
(164,117,2)
(267,452,2)
(399,19,2)
(164,292,2)
(82,56,2)
(510,132,2)
(181,282,2)
(189,141,2)
(481,292,2)
(46,51,2)
(137,122,2)
(472,117,2)
(175,367,2)
(446,255,2)
(231,292,2)
(501,98,2)
(282,350,2)
(80,308,2)
(308,367,2)
(198,295,2)
(328,122,2)
(231,270,2)
(477,292,2)
(386,83,2)
(348,351,2)
(211,117,2)
(270,282,2)
(247,374,2)
(115,6,2)
(170,301,2)
(246,439,2)
(193,83,2)
(93,51,2)
(178,103,2)
(288,505,2)
(509,505,2)
(400,122,2)
(322,224,2)
(387,83,2)
(342,33,2)
(170,83,2)
(264,439,2)
(325,109,2)
(381,117,2)
(133,98,2)
(364,164,2)
(313,231,2)
(281,117,2)
(124,453,2)
(367,83,2)
(338,83,2)
(326,117,2)
(127,279,2)
(498,279,2)
(305,83,2)
(60,109,2)
(56,294,2)
(263,308,2)
(121,83,2)
(98,505,2)
(247,452,2)
(308,46,2)
(366,132,2)
(295,434,2)
(182,56,2)
(350,209,2)
(508,117,2)
(254,388,2)
(488,117,2)
(207,505,2)
(271,282,2)
(222,390,2)
(182,282,2)
(130,301,2)
(38,83,2)
(408,388,2)
(442,292,2)
(279,191,2)
(396,122,2)
(441,233,2)
(277,388,2)
(53,282,2)
(193,136,2)
(409,83,2)
(83,249,2)
(46,390,2)
(379,282,2)
(455,83,2)
(132,399,2)
(221,314,2)
(452,280,2)
(434,325,2)
(184,83,2)
(463,117,2)
(452,282,2)
(253,98,2)
(89,182,2)
(463,292,2)
(224,435,2)
(200,46,2)
(105,505,2)
(97,334,2)
(136,432,2)
(136,83,2)
(286,202,2)
(428,161,2)
(111,46,2)
(322,51,2)
(63,93,2)
(510,230,2)
(265,98,2)
(150,209,2)
(238,282,2)
(26,301,2)
(102,122,2)
(438,439,2)
(11,282,2)
(354,122,2)
(5,388,2)
(186,390,2)
(356,83,2)
(476,192,2)
(438,308,2)
(61,452,2)
(236,224,2)
(285,117,2)
(236,367,2)
(41,117,2)
(279,454,2)
(464,453,2)
(60,117,2)
(47,388,2)
(97,224,2)
(274,167,2)
(232,282,2)
(273,292,2)
(456,83,2)
(57,83,2)
(308,83,2)
(13,374,2)
(250,233,2)
(509,301,2)
(81,380,2)
(242,117,2)
(413,122,2)
(92,84,2)
(29,282,2)
(282,439,2)
(51,309,2)
(219,122,2)
(358,46,2)
(336,117,2)
(283,301,2)
(260,46,2)
(138,301,2)
(155,122,2)
(2,326,2)
(231,25,2)
(405,6,2)
(169,117,2)
(171,83,2)
(148,83,2)
(313,247,2)
(164,109,2)
(210,209,2)
(404,326,2)
(497,308,2)
(95,233,2)
(216,161,2)
(201,109,2)
(145,292,2)
(294,274,2)
(267,25,2)
(116,390,2)
(509,46,2)
(302,453,2)
(468,122,2)
(429,122,2)
(403,83,2)
(147,233,2)
(20,280,2)
(144,224,2)
(201,295,2)
(372,161,2)
(54,292,2)
(433,374,2)
(262,6,2)
(268,161,2)
(173,83,2)
(433,337,2)
(274,308,2)
(154,83,2)
(117,117,2)
(247,144,2)
(33,390,2)
(263,439,2)
(14,122,2)
(98,279,2)
(310,374,2)
(386,280,2)
(351,301,2)
(436,301,2)
(241,308,2)
(158,83,2)
(6,83,2)
(456,301,2)
(193,345,2)
(231,232,2)
(18,142,2)
(142,83,2)
(342,390,2)
(467,192,2)
(492,109,2)
(383,280,2)
(287,46,2)
(202,81,2)
(24,355,2)
(414,301,2)
(306,95,2)
(316,308,2)
(28,292,2)
(470,46,2)
(247,270,2)
(233,484,2)
(172,255,2)
(247,328,2)
(87,192,2)
(503,292,2)
(61,25,2)
(186,355,2)
(395,439,2)
(140,327,2)
(68,282,2)
(233,117,2)
(258,267,2)
(4,292,2)
(204,192,2)
(483,308,2)
(140,122,2)
(474,93,2)
(118,439,2)
(509,83,2)
(182,439,2)
(311,326,2)
(402,6,2)
(350,439,2)
(7,117,2)
(410,307,2)
(506,83,2)
(434,292,2)
(213,98,2)
(128,308,2)
(395,308,2)
(146,308,2)
(97,51,2)
(455,386,2)
(81,98,2)
(244,282,2)
(411,122,2)
(267,328,2)
(42,433,2)
(508,292,2)
(428,324,2)
(191,505,2)
(377,367,2)
(30,374,2)
(206,282,2)
(35,98,2)
(491,390,2)
(146,282,2)
(471,301,2)
(335,455,2)
(313,410,2)
(15,255,2)
(314,46,2)
(36,122,2)
(495,117,2)
(165,98,2)
(282,294,2)
(443,127,2)
(453,439,2)
(144,282,2)
(144,308,2)
(75,6,2)
(10,83,2)
(243,150,2)
(103,117,2)
(252,292,2)
(198,117,2)
(6,71,2)
(25,209,2)
(118,308,2)
(497,175,2)
(249,314,2)
(0,505,2)
(290,230,2)
(142,272,2)
(345,83,2)
(363,453,2)
(163,83,2)
(107,314,2)
(181,308,2)
(127,283,2)
(41,292,2)
(325,292,2)
(235,326,2)
(192,109,2)
(194,83,2)
(423,122,2)
(294,308,2)
(231,144,2)
(35,301,2)
(453,282,2)
(68,308,2)
(19,161,2)
(243,390,2)
(247,25,2)
(487,282,2)
(457,132,2)
(295,117,2)
(265,165,2)
(390,265,2)
(175,308,2)
(239,453,2)
(150,390,2)
(74,439,2)
(293,292,2)
(43,282,2)
(406,399,2)
(3,390,2)
(217,122,2)
(383,166,2)
(235,258,2)
(315,122,2)
(246,308,2)
(406,122,2)
(212,122,2)
(507,295,2)
(144,439,2)
(275,282,2)
(104,314,2)
(182,209,2)
(339,414,2)
(33,301,2)
(93,224,2)
(176,122,2)
(358,154,2)
(462,83,2)
(44,122,2)
(378,453,2)
(426,122,2)
(445,439,2)
(270,308,2)
(187,6,2)
(204,467,2)
(247,140,2)
(377,308,2)
(9,209,2)
(388,390,2)
(8,439,2)
(458,308,2)
(459,209,2)
(269,282,2)
(438,282,2)
(503,117,2)
(431,390,2)
(412,122,2)
(40,282,2)
(492,233,2)
(266,117,2)
(269,25,2)
(149,83,2)
(336,292,2)
(24,83,2)
(403,46,2)
(272,170,2)
(333,453,2)
(298,161,2)
(373,122,2)
(421,233,2)
(20,46,2)
(374,83,2)
(465,117,2)
(160,269,2)
(79,282,2)
(470,83,2)
(386,46,2)
(320,282,2)
(164,295,2)
(158,46,2)
(337,301,2)
(178,117,2)
(414,308,2)
(292,192,2)
(381,292,2)
(106,282,2)
(211,292,2)
(131,374,2)
(194,46,2)
(198,109,2)
(437,93,2)
(267,507,2)
(349,388,2)
(293,430,2)
(93,271,2)
(394,83,2)
(90,439,2)
(117,295,2)
(55,282,2)
(296,117,2)
(332,390,2)
(267,292,2)
(88,292,2)
(70,161,2)
(162,286,2)
(392,439,2)
(62,355,2)
(274,497,2)
(470,456,2)
(117,235,2)
(318,83,2)
(36,315,2)
(181,439,2)
(276,122,2)
(451,292,2)
(288,46,2)
(454,301,2)
(496,161,2)
(122,399,2)
(475,122,2)
(14,399,2)
(267,144,2)
(215,122,2)
(267,117,2)
(205,282,2)
(325,295,2)
(144,51,2)
(204,196,2)
(299,192,2)
(256,233,2)
(135,161,2)
(292,374,2)
(232,51,2)
(240,122,2)
(22,255,2)
(436,117,2)
(196,192,2)
(459,56,2)
(414,282,2)
(256,380,2)
(357,9,2)
(200,83,2)
(18,83,2)
(177,453,2)
(374,207,2)
(340,83,2)
(68,439,2)
(126,390,2)
(321,308,2)
(406,452,2)
(439,294,2)
(141,301,2)
(67,505,2)
(320,275,2)
(283,279,2)
(84,305,2)
(27,279,2)
(365,46,2)
(478,83,2)
(93,282,2)
(361,233,2)
(114,83,2)
(368,308,2)
(481,117,2)
(156,314,2)
(451,380,2)
(69,98,2)
(324,161,2)
(272,83,2)
(113,192,2)
(88,117,2)
(445,282,2)
(230,475,2)
(59,390,2)
(397,255,2)
(86,122,2)
(71,280,2)
(258,301,2)
(493,132,2)
(62,294,2)
(161,308,2)
(504,292,2)
(264,282,2)
(284,282,2)
(196,301,2)
(161,439,2)
(390,505,2)
(258,326,2)
(84,83,2)
(203,282,2)
(416,308,2)
(246,282,2)
(218,453,2)
(267,140,2)
(42,374,2)
-----------------------------------
(0,th)
(1,tp)
(2,q)
(3,tcp_reass_zone)
(4,so_rcv)
(5,__func__)
(6,s = tcp_log_addrs(&tp->t_inpcb->inp_inc, th, NULL,\n\\n\\t\\t\\t    NULL)
(7,tqe_th)
(8,i)
(9,*tlenp)
(10,p)
(11,tcps_rcvduppack)
(12,tp)
(13,tp)
(14,m_adj(q->tqe_m, i)
(15,M_TCPLOG)
(16,th)
(17,i)
(18,tcp_log_addrs(&tp->t_inpcb->inp_inc, th, NULL,\n\\n\\t\\t\\t    NULL)
(19,(th->th_seq + *tlenp)
(20,th->th_seq)
(21,if (!q || q->tqe_th->th_seq != tp->rcv_nxt)
(22,LOG_DEBUG)
(23,tp)
(24,m_freem(m)
(25,*tlenp)
(26,tp->t_segq)
(27,t_state)
(28,SOCKBUF_LOCK(&so->so_rcv)
(29,m)
(30,q)
(31,th)
(32,free(s, M_TCPLOG)
(33,tp->t_inpcb)
(34,if (th == NULL)
(35,tp->t_segqlen)
(36,m_freem(q->tqe_m)
(37,t_rcvoopack)
(38,tcps_rcvmemdrop)
(39,p)
(40,m)
(41,tp)
(42,LIST_FIRST(&tp->t_segq)
(43,tp)
(44,i)
(45,tqe_q)
(46,te == NULL)
(47,free(s, M_TCPLOG)
(48,te)
(49,th_seq)
(50,0)
(51,te = uma_zalloc(tcp_reass_zone, M_NOWAIT)
(52,0)
(53,i)
(54,so)
(55,te)
(56,*tlenp -= i)
(57,tqe_th)
(58,te)
(59,NULL)
(60,LIST_REMOVE(q, tqe_q)
(61,q->tqe_len -= i)
(62,m_adj(m, i)
(63,tcp_reass_zone)
(64,nq)
(65,)
(66,tcp_reass_maxqueuelen)
(67,rcv_nxt)
(68,tqe_len)
(69,1)
(70,tlenp)
(71,tcp_log_addrs(&tp->t_inpcb->inp_inc, th, NULL,\n\\n\\t\\t\\t    NULL)
(72,NULL)
(73,inp_inc)
(74,p)
(75,"%s; %s: global zone limit "\n\\n\\t\\t\\t\\t    "reached, segment dropped\\n")
(76,tp)
(77,tqe_m)
(78,M_TCPLOG)
(79,tlenp)
(80,th_seq)
(81,so->so_rcv)
(82,*tlenp)
(83,th->th_seq != tp->rcv_nxt || !TCPS_HAVEESTABLISHED(tp->t_state)
(84,tp->t_inpcb->inp_inc)
(85,*s = NULL)
(86,q)
(87,tp)
(88,q)
(89,TCPSTAT_ADD(tcps_rcvoobyte, *tlenp)
(90,NULL)
(91,do)
(92,&tp->t_inpcb->inp_inc)
(93,te != &tqs)
(94,if (te == NULL)
(95,q->tqe_m)
(96,th_seq)
(97,LIST_INSERT_HEAD(&tp->t_segq, te, tqe_q)
(98,th->th_seq != tp->rcv_nxt || !TCPS_HAVEESTABLISHED(tp->t_state)
(99,NULL)
(100,)
(101,t_segqlen)
(102,q)
(103,q->tqe_th->th_flags)
(104,tp->t_state)
(105,th_seq)
(106,i)
(107,t_state)
(108,if (so->so_rcv.sb_state & SBS_CANTRCVMORE)
(109,q = LIST_FIRST(&tp->t_segq)
(110,i)
(111,NULL)
(112,tp)
(113,q)
(114,p)
(115,__func__)
(116,tcps_rcvreassfull)
(117,q && q->tqe_th->th_seq == tp->rcv_nxt)
(118,te->tqe_th = th)
(119,tqe_q)
(120,)
(121,t_inpcb)
(122,i < q->tqe_len)
(123,th_seq)
(124,"%s: temporary stack based entry not "\n\\n\\t\\t    "first element in queue")
(125,tlenp)
(126,0)
(127,TCPS_HAVEESTABLISHED(tp->t_state)
(128,te->tqe_m = m)
(129,th)
(130,tp->t_maxseg)
(131,q)
(132,i <= 0)
(133,so)
(134,te)
(135,0)
(136,sizeof(struct tseg_qent)
(137,tqe_m)
(138,tp->t_segqlen)
(139,if ((th->th_seq != tp->rcv_nxt || !TCPS_HAVEESTABLISHED(tp->t_state)
(140,q->tqe_th->th_seq)
(141,tp->t_inpcb)
(142,&tp->t_inpcb->inp_inc)
(143,&tqs)
(144,te->tqe_m)
(145,so)
(146,te)
(147,so_rcv)
(148,NULL)
(149,m)
(150,*tlenp)
(151,)
(152,te)
(153,NULL)
(154,q->tqe_th)
(155,break;)
(156,TCPS_HAVEESTABLISHED(tp->t_state)
(157,if (th->th_seq != tp->rcv_nxt || !TCPS_HAVEESTABLISHED(tp->t_state)
(158,th_seq)
(159,m)
(160,th->th_seq)
(161,q)
(162,(so->so_rcv.sb_hiwat / tp->t_maxseg)
(163,inp_inc)
(164,q != &tqs)
(165,min((so->so_rcv.sb_hiwat / tp->t_maxseg)
(166,&tp->t_inpcb->inp_inc)
(167,p->tqe_len - th->th_seq)
(168,q->tqe_th)
(169,th_flags)
(170,tp->t_inpcb)
(171,tp)
(172,"%s; %s: global zone limit reached, using "\n\\n\\t\\t\\t\\t    "stack for missing segment\\n")
(173,NULL)
(174,te)
(175,p->tqe_th)
(176,nq)
(177,te)
(178,q->tqe_th->th_flags & TH_FIN)
(179,rcv_nxt)
(180,m)
(181,tqe_m)
(182,*tlenp)
(183,if (SEQ_GT(q->tqe_th->th_seq, th->th_seq)
(184,t_inpcb)
(185,)
(186,m_freem(m)
(187,s)
(188,&so->so_rcv)
(189,tp->t_inpcb->inp_socket)
(190,)
(191,th->th_seq)
(192,!q)
(193,bzero(&tqs, sizeof(struct tseg_qent)
(194,th)
(195,if ((s = tcp_log_addrs(&tp->t_inpcb->inp_inc, th, NULL,\n\\n\\t\\t\\t    NULL)
(196,tp->rcv_nxt)
(197,tp)
(198,q->tqe_th)
(199,tcps_rcvoobyte)
(200,th_seq)
(201,uma_zfree(tcp_reass_zone, q)
(202,so->so_rcv.sb_hiwat)
(203,th)
(204,q->tqe_th->th_seq != tp->rcv_nxt)
(205,TCPSTAT_ADD(tcps_rcvdupbyte, *tlenp)
(206,te->tqe_len = *tlenp)
(207,TCPS_HAVEESTABLISHED(tp->t_state)
(208,th_seq)
(209,int *tlenp)
(210,*tlenp)
(211,SBS_CANTRCVMORE)
(212,LIST_REMOVE(q, tqe_q)
(213,sb_hiwat)
(214,tqs)
(215,i)
(216,tqe_th)
(217,tqe_len)
(218,p)
(219,LIST_NEXT(q, tqe_q)
(220,M_NOWAIT)
(221,tp)
(222,te)
(223,if ((s = tcp_log_addrs(&tp->t_inpcb->inp_inc, th, NULL, NULL)
(224,te = &tqs)
(225,if (!TCPS_HAVEESTABLISHED(tp->t_state)
(226,)
(227,p)
(228,if (i < q->tqe_len)
(229,s)
(230,q = nq)
(231,return (0)
(232,te->tqe_th)
(233,so->so_rcv.sb_state & SBS_CANTRCVMORE)
(234,flags)
(235,q->tqe_th->th_seq == tp->rcv_nxt)
(236,LIST_INSERT_AFTER(p, te, tqe_q)
(237,)
(238,t_segqlen)
(239,__func__)
(240,tqe_m)
(241,tqe_len)
(242,q)
(243,return (0)
(244,TCPSTAT_INC(tcps_rcvduppack)
(245,tqs)
(246,tcps_rcvoopack)
(247,return (0)
(248,tp)
(249,!TCPS_HAVEESTABLISHED(tp->t_state)
(250,q)
(251,inp_socket)
(252,nq)
(253,t_maxseg)
(254,log(LOG_DEBUG, "%s; %s: queue limit reached, "\n\\n\\t\\t\\t    "segment dropped\\n", s, __func__)
(255,s = tcp_log_addrs(&tp->t_inpcb->inp_inc, th, NULL,\n\\n\\t\\t\\t    NULL)
(256,so->so_rcv)
(257,"%s; %s: queue limit reached, "\n\\n\\t\\t\\t    "segment dropped\\n")
(258,tp->rcv_nxt)
(259,q)
(260,th_seq)
(261,tqe_th)
(262,LOG_DEBUG)
(263,tlenp)
(264,te)
(265,tp->t_segqlen >= min((so->so_rcv.sb_hiwat / tp->t_maxseg)
(266,tp)
(267,tp->rcv_nxt += q->tqe_len)
(268,i)
(269,th->th_seq += i)
(270,te->tqe_len)
(271,&tqs)
(272,tp->t_inpcb->inp_inc)
(273,TH_FIN)
(274,p->tqe_th->th_seq + p->tqe_len - th->th_seq)
(275,tp->t_segqlen)
(276,q)
(277,LOG_DEBUG)
(278,q)
(279,th->th_seq != tp->rcv_nxt)
(280,struct tcphdr *th)
(281,tqe_len)
(282,i >= *tlenp)
(283,tp->t_state)
(284,tcps_rcvdupbyte)
(285,so_rcv)
(286,so->so_rcv.sb_hiwat / tp->t_maxseg)
(287,t_segqlen)
(288,t_state)
(289,TCPSTAT_INC(tcps_rcvreassfull)
(290,uma_zfree(tcp_reass_zone, q)
(291,s)
(292,!q || q->tqe_th->th_seq != tp->rcv_nxt)
(293,&so->so_rcv)
(294,i = p->tqe_th->th_seq + p->tqe_len - th->th_seq)
(295,q = nq)
(296,t_segqlen)
(297,tqe_th)
(298,q)
(299,q->tqe_th)
(300,0)
(301,struct tcpcb *tp)
(302,tqe_q)
(303,tp)
(304,if (p != NULL)
(305,tp->t_inpcb)
(306,sbappendstream_locked(&so->so_rcv, q->tqe_m, 0)
(307,flags = q->tqe_th->th_flags & TH_FIN)
(308,p != NULL)
(309,uma_zalloc(tcp_reass_zone, M_NOWAIT)
(310,0)
(311,th_seq)
(312,)
(313,RET)
(314,th->th_seq != tp->rcv_nxt)
(315,q->tqe_m)
(316,i)
(317,p)
(318,NULL)
(319,s)
(320,tp->t_segqlen--)
(321,th)
(322,te != &tqs)
(323,tqs)
(324,q->tqe_th)
(325,LIST_NEXT(q, tqe_q)
(326,q)
(327,q->tqe_th)
(328,q->tqe_len)
(329,)
(330,log(LOG_DEBUG,\n\\n\\t\\t\\t\\t    "%s; %s: global zone limit reached, using "\n\\n\\t\\t\\t\\t    "stack for missing segment\\n", s, __func__)
(331,tqe_m)
(332,t_inpcb)
(333,t_segq)
(334,&tp->t_segq)
(335,break;)
(336,sb_state)
(337,tp->t_segq)
(338,tqs)
(339,tp->t_rcvoopack++)
(340,s)
(341,if (p == NULL)
(342,tp->t_inpcb->inp_inc)
(343,if (i > 0)
(344,te)
(345,&tqs)
(346,break;)
(347,t_segq)
(348,INP_WLOCK_ASSERT(tp->t_inpcb)
(349,M_TCPLOG)
(350,*tlenp)
(351,tp->t_inpcb)
(352,flags)
(353,tp->t_segqlen--)
(354,nq)
(355,struct mbuf *m)
(356,tqs)
(357,return (0)
(358,q->tqe_th->th_seq)
(359,if (te != &tqs)
(360,t_inpcb)
(361,m_freem(q->tqe_m)
(362,0)
(363,&tqs)
(364,q)
(365,q)
(366,i)
(367,p = q)
(368,p)
(369,tqe_q)
(370,tlenp)
(371,i)
(372,th)
(373,q)
(374,!TCPS_HAVEESTABLISHED(tp->t_state)
(375,)
(376,NULL)
(377,p->tqe_len)
(378,tp)
(379,goto present;)
(380,*so = tp->t_inpcb->inp_socket)
(381,tqs)
(382,th->th_seq + *tlenp)
(383,tcp_log_addrs(&tp->t_inpcb->inp_inc, th, NULL, NULL)
(384,so_rcv)
(385,tcp_reass_zone)
(386,th->th_seq)
(387,tlenp)
(388,s = tcp_log_addrs(&tp->t_inpcb->inp_inc, th, NULL, NULL)
(389,log(LOG_DEBUG, "%s; %s: global zone limit "\n\\n\\t\\t\\t\\t    "reached, segment dropped\\n", s, __func__)
(390,(th->th_seq != tp->rcv_nxt || !TCPS_HAVEESTABLISHED(tp->t_state)
(391,)
(392,tlenp)
(393,rcv_nxt)
(394,*tlenp = 0)
(395,te)
(396,q)
(397,s)
(398,while (q)
(399,i = (th->th_seq + *tlenp)
(400,t_segqlen)
(401,)
(402,s)
(403,q)
(404,q->tqe_th->th_seq)
(405,free(s, M_TCPLOG)
(406,q->tqe_th->th_seq += i)
(407,*te = NULL)
(408,s)
(409,NULL)
(410,return (flags)
(411,q)
(412,tqe_th)
(413,tp)
(414,tp->t_rcvoopack)
(415,if ((s = tcp_log_addrs(&tp->t_inpcb->inp_inc, th, NULL,\n\\n\\t\\t\\t    NULL)
(416,i)
(417,tlenp)
(418,if (q != &tqs)
(419,tp)
(420,present:)
(421,q)
(422,s)
(423,q->tqe_m)
(424,t_inpcb)
(425,so)
(426,i)
(427,rcv_nxt)
(428,q->tqe_th->th_seq)
(429,tqe_q)
(430,so->so_rcv)
(431,0)
(432,struct tseg_qent)
(433,&tp->t_segq)
(434,nq = LIST_NEXT(q, tqe_q)
(435,&tqs)
(436,tp->rcv_nxt)
(437,uma_zfree(tcp_reass_zone, te)
(438,tqe_th)
(439,i > 0)
(440,NULL)
(441,so)
(442,tp->t_segqlen--)
(443,!TCPS_HAVEESTABLISHED(tp->t_state)
(444,)
(445,TCPSTAT_INC(tcps_rcvoopack)
(446,__func__)
(447,tp)
(448,)
(449,)
(450,tcp_reass_zone)
(451,sorwakeup_locked(so)
(452,th->th_seq)
(453,p == NULL)
(454,tp->rcv_nxt)
(455,SEQ_GT(q->tqe_th->th_seq, th->th_seq)
(456,tp->t_segqlen)
(457,q)
(458,tqe_th)
(459,*tlenp)
(460,*tlenp = 0)
(461,so)
(462,tp)
(463,tqe_q)
(464,KASSERT(te != &tqs, ("%s: temporary stack based entry not "\n\\n\\t\\t    "first element in queue", __func__)
(465,tp->t_segqlen)
(466,)
(467,q->tqe_th->th_seq)
(468,q)
(469,)
(470,tp->t_segqlen++)
(471,tp->rcv_nxt)
(472,q)
(473,th)
(474,te)
(475,nq = LIST_NEXT(q, tqe_q)
(476,th_seq)
(477,so->so_rcv)
(478,TCPSTAT_INC(tcps_rcvmemdrop)
(479,if (i <= 0)
(480,i)
(481,q)
(482,if (i >= *tlenp)
(483,th->th_seq)
(484,so->so_rcv.sb_state)
(485,s)
(486,th)
(487,m_freem(m)
(488,q)
(489,NULL)
(490,goto present;)
(491,th)
(492,q->tqe_m)
(493,tqe_len)
(494,so)
(495,q)
(496,th_seq)
(497,p->tqe_th->th_seq)
(498,tp)
(499,*p = NULL)
(500,inp_inc)
(501,tp)
(502,s)
(503,nq)
(504,flags)
(505,th == NULL)
(506,0)
(507,q->tqe_len)
(508,rcv_nxt)
(509,tp->t_state)
(510,q->tqe_len)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^