-----label-----
1
-----code-----
int
Tk_PhotoPutBlock(
    Tcl_Interp *interp,		/* Interpreter for passing back error
				 * messages, or NULL. */
    Tk_PhotoHandle handle,	/* Opaque handle for the photo image to be
				 * updated. */
    register Tk_PhotoImageBlock *blockPtr,
				/* Pointer to a structure describing the pixel
				 * data to be copied into the image. */
    int x, int y,		/* Coordinates of the top-left pixel to be
				 * updated in the image. */
    int width, int height,	/* Dimensions of the area of the image to be
				 * updated. */
    int compRule)		/* Compositing rule to use when processing
				 * transparent pixels. */
{
    register PhotoMaster *masterPtr;
    int xEnd, yEnd, greenOffset, blueOffset, alphaOffset;
    int wLeft, hLeft, wCopy, hCopy, pitch;
    unsigned char *srcPtr, *srcLinePtr, *destPtr, *destLinePtr;
    int sourceIsSimplePhoto = compRule & SOURCE_IS_SIMPLE_ALPHA_PHOTO;
    XRectangle rect;

    masterPtr = (PhotoMaster *) handle;
    compRule &= ~SOURCE_IS_SIMPLE_ALPHA_PHOTO;

    if ((masterPtr->userWidth != 0) && ((x + width) > masterPtr->userWidth)) {
	width = masterPtr->userWidth - x;
    }
    if ((masterPtr->userHeight != 0)
	    && ((y + height) > masterPtr->userHeight)) {
	height = masterPtr->userHeight - y;
    }
    if ((width <= 0) || (height <= 0)) {
	return TCL_OK;
    }

    xEnd = x + width;
    yEnd = y + height;
    if ((xEnd > masterPtr->width) || (yEnd > masterPtr->height)) {
	int sameSrc = (blockPtr->pixelPtr == masterPtr->pix32);

	if (ImgPhotoSetSize(masterPtr, MAX(xEnd, masterPtr->width),
		MAX(yEnd, masterPtr->height)) == TCL_ERROR) {
	    if (interp != NULL) {
		Tcl_ResetResult(interp);
		Tcl_AppendResult(interp, TK_PHOTO_ALLOC_FAILURE_MESSAGE, NULL);
	    }
	    return TCL_ERROR;
	}
	if (sameSrc) {
	    blockPtr->pixelPtr = masterPtr->pix32;
	    blockPtr->pitch = masterPtr->width * 4;
	}
    }

    if ((y < masterPtr->ditherY) || ((y == masterPtr->ditherY)
	    && (x < masterPtr->ditherX))) {
	/*
	 * The dithering isn't correct past the start of this block.
	 */

	masterPtr->ditherX = x;
	masterPtr->ditherY = y;
    }

    /*
     * If this image block could have different red, green and blue
     * components, mark it as a color image.
     */

    greenOffset = blockPtr->offset[1] - blockPtr->offset[0];
    blueOffset = blockPtr->offset[2] - blockPtr->offset[0];
    alphaOffset = blockPtr->offset[3];
    if ((alphaOffset >= blockPtr->pixelSize) || (alphaOffset < 0)) {
	alphaOffset = 0;
	sourceIsSimplePhoto = 1;
    } else {
	alphaOffset -= blockPtr->offset[0];
    }
    if ((greenOffset != 0) || (blueOffset != 0)) {
	masterPtr->flags |= COLOR_IMAGE;
    }

    /*
     * Copy the data into our local 32-bit/pixel array. If we can do it with a
     * single memmove, we do.
     */

    destLinePtr = masterPtr->pix32 + (y * masterPtr->width + x) * 4;
    pitch = masterPtr->width * 4;

    /*
     * Test to see if we can do the whole write in a single copy. This test is
     * probably too restrictive. We should also be able to do a memmove if
     * pixelSize == 3 and alphaOffset == 0. Maybe other cases too.
     */

    if ((blockPtr->pixelSize == 4)
	    && (greenOffset == 1) && (blueOffset == 2) && (alphaOffset == 3)
	    && (width <= blockPtr->width) && (height <= blockPtr->height)
	    && ((height == 1) || ((x == 0) && (width == masterPtr->width)
		&& (blockPtr->pitch == pitch)))
	    && (compRule == TK_PHOTO_COMPOSITE_SET)) {
	memmove(destLinePtr, blockPtr->pixelPtr + blockPtr->offset[0],
		((size_t) height * width * 4));

	/*
	 * We know there's an alpha offset and we're setting the data, so skip
	 * directly to the point when we recompute the photo validity region.
	 */

	goto recalculateValidRegion;
    }

    /*
     * Copy and merge pixels according to the compositing rule.
     */

    for (hLeft = height; hLeft > 0;) {
	int pixelSize = blockPtr->pixelSize;
	int compRuleSet = (compRule == TK_PHOTO_COMPOSITE_SET);

	srcLinePtr = blockPtr->pixelPtr + blockPtr->offset[0];
	hCopy = MIN(hLeft, blockPtr->height);
	hLeft -= hCopy;
	for (; hCopy > 0; --hCopy) {
	    /*
	     * If the layout of the source line matches our memory layout and
	     * we're setting, we can just copy the bytes directly, which is
	     * much faster.
	     */

	    if ((pixelSize == 4) && (greenOffset == 1)
		    && (blueOffset == 2) && (alphaOffset == 3)
		    && (width <= blockPtr->width)
		    && compRuleSet) {
		memcpy(destLinePtr, srcLinePtr, ((size_t) width * 4));
		srcLinePtr += blockPtr->pitch;
		destLinePtr += pitch;
		continue;
	    }

	    /*
	     * Have to copy the slow way.
	     */

	    destPtr = destLinePtr;
	    for (wLeft = width; wLeft > 0;) {
		wCopy = MIN(wLeft, blockPtr->width);
		wLeft -= wCopy;
		srcPtr = srcLinePtr;

		/*
		 * But we might be lucky and be able to use fairly fast loops.
		 * It's worth checking...
		 */

		if (alphaOffset == 0) {
		    /*
		     * This is the non-alpha case, so can still be fairly
		     * fast. Note that in the non-alpha-source case, the
		     * compositing rule doesn't apply.
		     */

		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {
			*destPtr++ = srcPtr[0];
			*destPtr++ = srcPtr[greenOffset];
			*destPtr++ = srcPtr[blueOffset];
			*destPtr++ = 255;
		    }
		    continue;
		} else if (compRuleSet) {
		    /*
		     * This is the SET compositing rule, which just replaces
		     * what was there before with the new data. This is
		     * another fairly fast case. No point in doing a memcpy();
		     * the order of channels is probably wrong.
		     */

		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {
			*destPtr++ = srcPtr[0];
			*destPtr++ = srcPtr[greenOffset];
			*destPtr++ = srcPtr[blueOffset];
			*destPtr++ = srcPtr[alphaOffset];
		    }
		    continue;
		}

		/*
		 * Bother; need to consider the alpha value of each pixel to
		 * know what to do.
		 */

		for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {
		    int alpha = srcPtr[alphaOffset];

		    if (alpha == 255 || !destPtr[3]) {
			/*
			 * Either the source is 100% opaque, or the
			 * destination is entirely blank. In all cases, we
			 * just set the destination to the source.
			 */

			*destPtr++ = srcPtr[0];
			*destPtr++ = srcPtr[greenOffset];
			*destPtr++ = srcPtr[blueOffset];
			*destPtr++ = alpha;
			continue;
		    }

		    /*
		     * Can still skip doing work if the source is 100%
		     * transparent at this point.
		     */

		    if (alpha) {
			int Alpha = destPtr[3];

			/*
			 * OK, there's real work to be done. Luckily, there's
			 * a substantial literature on what to do in this
			 * case. In particular, Porter and Duff have done a
			 * taxonomy of compositing rules, and the right one is
			 * the "Source Over" rule. This code implements that.
			 */

			destPtr[0] = PD_SRC_OVER(srcPtr[0], alpha, destPtr[0],
				Alpha);
			destPtr[1] = PD_SRC_OVER(srcPtr[greenOffset], alpha,
				destPtr[1], Alpha);
			destPtr[2] = PD_SRC_OVER(srcPtr[blueOffset], alpha,
				destPtr[2], Alpha);
			destPtr[3] = PD_SRC_OVER_ALPHA(alpha, Alpha);
		    }

		    destPtr += 4;
		}
	    }
	    srcLinePtr += blockPtr->pitch;
	    destLinePtr += pitch;
	}
    }

    /*
     * Add this new block to the region which specifies which data is valid.
     */

    if (alphaOffset) {
	/*
	 * This block is grossly inefficient. For each row in the image, it
	 * finds each continguous string of nontransparent pixels, then marks
	 * those areas as valid in the validRegion mask. This makes drawing
	 * very efficient, because of the way we use X: we just say, here's
	 * your mask, and here's your data. We need not worry about the
	 * current background color, etc. But this costs us a lot on the image
	 * setup. Still, image setup only happens once, whereas the drawing
	 * happens many times, so this might be the best way to go.
	 *
	 * An alternative might be to not set up this mask, and instead, at
	 * drawing time, for each transparent pixel, set its color to the
	 * color of the background behind that pixel. This is what I suspect
	 * most of programs do. However, they don't have to deal with the
	 * canvas, which could have many different background colors.
	 * Determining the correct bg color for a given pixel might be
	 * expensive.
	 */

	if (compRule != TK_PHOTO_COMPOSITE_OVERLAY) {
	    TkRegion workRgn;

	    /*
	     * Don't need this when using the OVERLAY compositing rule, which
	     * always strictly increases the valid region.
	     */

	recalculateValidRegion:
	    workRgn = TkCreateRegion();
	    rect.x = x;
	    rect.y = y;
	    rect.width = width;
	    rect.height = height;
	    TkUnionRectWithRegion(&rect, workRgn, workRgn);
	    TkSubtractRegion(masterPtr->validRegion, workRgn,
		    masterPtr->validRegion);
	    TkDestroyRegion(workRgn);
	}

	/*
	 * Factorize out the main part of the building of the region data to
	 * allow for more efficient per-platform implementations. [Bug 919066]
	 */

	TkpBuildRegionFromAlphaData(masterPtr->validRegion, (unsigned) x,
		(unsigned) y, (unsigned) width, (unsigned) height,
		masterPtr->pix32 + (y * masterPtr->width + x) * 4 + 3,
		4, (unsigned) masterPtr->width * 4);
    } else {
	rect.x = x;
	rect.y = y;
	rect.width = width;
	rect.height = height;
	TkUnionRectWithRegion(&rect, masterPtr->validRegion,
		masterPtr->validRegion);
    }

    /*
     * Check if display code needs alpha blending...
     */

    if (!sourceIsSimplePhoto && (width == 1) && (height == 1)) {
	/*
	 * Optimize the single pixel case if we can. This speeds up code that
	 * builds up large simple-alpha images by single pixels.  We don't
	 * negate COMPLEX_ALPHA in this case. [Bug 1409140]
	 */

	if (!(masterPtr->flags & COMPLEX_ALPHA)) {
	    unsigned char newAlpha;

	    destLinePtr = masterPtr->pix32 + (y * masterPtr->width + x) * 4;
	    newAlpha = destLinePtr[3];

	    if (newAlpha && newAlpha != 255) {
		masterPtr->flags |= COMPLEX_ALPHA;
	    }
	}
    } else if ((alphaOffset != 0) || (masterPtr->flags & COMPLEX_ALPHA)) {
	/*
	 * Check for partial transparency if alpha pixels are specified, or
	 * rescan if we already knew such pixels existed.  To restrict this
	 * Toggle to only checking the changed pixels requires knowing where
	 * the alpha pixels are.
	 */

	ToggleComplexAlphaIfNeeded(masterPtr);
    }

    /*
     * Update each instance.
     */

    Tk_DitherPhoto((Tk_PhotoHandle)masterPtr, x, y, width, height);

    /*
     * Tell the core image code that this image has changed.
     */

    Tk_ImageChanged(masterPtr->tkMaster, x, y, width, height,
	    masterPtr->width, masterPtr->height);
    return TCL_OK;
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
3,7
3,8
3,9
3,10
3,11
3,12
5,6
5,7
6,7
8,9
8,10
11,12
11,13
12,13
14,15
16,17
16,18
17,18
19,20
19,21
22,23
22,24
24,25
26,27
26,28
28,29
30,31
30,32
32,33
34,35
34,36
36,37
38,39
38,40
40,41
42,43
42,44
42,45
42,46
42,47
42,48
42,49
42,50
42,51
42,52
42,53
42,54
42,55
42,56
42,57
42,58
42,59
42,60
42,61
42,62
42,63
42,64
42,65
42,66
42,67
42,68
42,69
42,70
42,71
43,44
44,45
44,46
45,46
47,48
47,49
50,51
51,52
51,53
51,54
51,55
51,56
51,57
53,54
55,56
57,58
59,60
61,62
63,64
64,65
64,66
64,67
64,68
64,69
64,70
66,67
68,69
70,71
72,73
74,75
76,77
77,78
77,79
77,80
77,81
77,82
79,80
79,81
82,83
82,84
85,86
85,87
88,89
88,90
91,92
92,93
92,94
94,95
94,96
96,97
97,98
97,99
98,99
100,101
102,103
103,104
103,105
104,105
106,107
108,109
109,110
109,111
110,111
112,113
112,114
113,114
113,115
114,115
116,117
118,119
120,121
121,122
121,123
122,123
124,125
125,126
127,128
127,129
128,129
128,130
129,130
130,131
130,132
131,132
131,133
132,133
136,137
137,138
137,139
138,139
139,140
139,141
140,141
142,143
144,145
144,146
145,146
148,149
149,150
150,151
150,152
151,152
153,154
153,155
154,155
154,156
155,156
158,159
160,161
160,162
161,162
161,163
162,163
163,164
163,165
164,165
164,166
165,166
169,170
170,171
170,172
171,172
172,173
172,174
173,174
175,176
177,178
177,179
178,179
181,182
182,183
183,184
183,185
184,185
186,187
186,188
187,188
187,189
188,189
191,192
193,194
193,195
194,195
194,196
195,196
196,197
196,198
197,198
200,201
201,202
201,203
202,203
205,206
206,207
207,208
209,210
210,211
210,212
211,212
213,214
213,215
214,215
216,217
218,219
219,220
219,221
220,221
222,223
222,224
223,224
225,226
227,228
227,229
228,229
228,230
229,230
230,231
230,232
231,232
233,234
233,235
234,235
237,238
238,239
238,240
239,240
241,242
241,243
242,243
245,246
245,247
245,248
246,247
247,248
247,249
249,250
249,251
251,252
252,253
253,254
253,255
254,255
254,256
255,256
258,259
258,260
259,260
262,263
262,264
263,264
263,265
264,265
264,266
264,267
264,268
265,266
267,268
269,270
269,271
269,272
270,271
272,273
274,275
274,276
275,276
278,279
278,280
278,281
279,280
281,282
283,284
283,285
284,285
287,288
289,290
289,291
290,291
290,292
291,292
291,293
292,293
294,295
296,297
296,298
297,298
298,299
298,300
299,300
301,302
303,304
304,305
304,306
304,307
304,308
305,306
307,308
309,310
311,312
313,314
314,315
316,317
316,318
317,318
319,320
319,321
320,321
321,322
321,323
322,323
322,324
323,324
326,327
326,328
327,328
330,331
331,332
331,333
332,333
332,334
333,334
336,337
336,338
337,338
337,339
338,339
342,343
342,344
343,344
343,345
344,345
345,346
345,347
346,347
348,349
348,350
349,350
352,353
353,354
353,355
354,355
355,356
355,357
356,357
358,359
358,360
359,360
362,363
363,364
363,365
364,365
366,367
366,368
367,368
370,371
370,372
371,372
372,373
372,374
373,374
373,375
374,375
377,378
379,380
380,381
380,382
381,382
381,383
382,383
385,386
387,388
388,389
388,390
389,390
391,392
391,393
392,393
392,394
393,394
393,395
394,395
398,399
398,400
399,400
399,401
400,401
404,405
405,406
405,407
406,407
408,409
408,410
409,410
409,411
410,411
410,412
411,412
415,416
415,417
416,417
416,418
417,418
421,422
422,423
422,424
423,424
425,426
425,427
426,427
426,428
427,428
431,432
431,433
431,434
432,433
432,434
433,434
434,435
434,436
435,436
437,438
437,439
438,439
441,442
442,443
442,444
443,444
446,447
446,448
447,448
448,449
448,450
449,450
452,453
453,454
453,455
454,455
457,458
458,459
459,460
459,461
460,461
462,463
462,464
463,464
463,465
464,465
468,469
468,470
469,470
469,471
470,471
471,472
471,473
472,473
475,476
476,477
476,478
477,478
480,481
481,482
482,483
482,484
483,484
483,485
484,485
487,488
489,490
490,491
490,492
491,492
493,494
493,495
494,495
494,496
495,496
498,499
498,500
499,500
500,501
500,502
501,502
501,503
502,503
504,505
504,506
505,506
508,509
511,512
512,513
512,514
513,514
515,516
515,517
516,517
516,518
517,518
521,522
521,523
522,523
522,524
523,524
523,525
524,525
524,526
525,526
525,527
526,527
526,528
527,528
527,529
528,529
528,530
529,530
530,531
530,532
531,532
531,533
532,533
536,537
537,538
537,539
538,539
541,542
542,543
542,544
543,544
546,547
547,548
547,549
548,549
551,552
552,553
552,554
553,554
555,556
555,557
556,557
559,560
560,561
560,562
561,562
563,564
563,565
564,565
567,568
568,569
568,570
569,570
570,571
570,572
571,572
574,575
575,576
575,577
576,577
576,578
577,578
578,579
578,580
579,580
582,583
583,584
583,585
584,585
586,587
586,588
587,588
590,591
591,592
591,593
592,593
592,594
593,594
596,597
598,599
599,600
599,601
600,601
602,603
604,605
604,606
605,606
606,607
606,608
606,609
606,610
607,608
609,610
611,612
611,613
612,613
612,614
613,614
616,617
616,618
617,618
617,619
618,619
622,623
623,624
623,625
624,625
624,626
625,626
625,627
626,627
626,628
627,628
630,631
632,633
635,636
637,638
637,639
637,640
638,639
639,640
639,641
640,641
642,643
644,645
644,646
645,646
648,649
648,650
648,651
648,652
648,653
648,654
649,650
650,651
650,652
652,653
652,654
654,655
655,656
655,657
656,657
659,660
660,661
660,662
662,663
662,664
664,665
665,666
666,667
666,668
667,668
669,670
671,672
672,673
672,674
673,674
675,676
675,677
676,677
676,678
677,678
680,681
680,682
681,682
681,683
682,683
686,687
687,688
687,689
688,689
690,691
690,692
690,693
691,692
693,694
695,696
695,697
696,697
699,700
700,701
700,702
701,702
703,704
705,706
705,707
705,708
705,709
707,708
707,709
708,709
711,712
712,713
714,715
714,716
714,717
714,718
714,719
715,716
715,717
716,717
716,718
717,718
717,719
718,719
718,720
719,720
719,721
720,721
720,722
721,722
722,723
722,724
723,724
726,727
727,728
727,729
728,729
731,732
732,733
732,734
733,734
736,737
737,738
737,739
738,739
741,742
742,743
742,744
743,744
745,746
745,747
746,747
749,750
751,752
751,753
751,754
751,755
752,753
753,754
753,755
753,756
753,757
754,755
756,757
758,759
760,761
761,762
761,763
762,763
762,764
763,764
763,765
764,765
767,768
770,771
771,772
771,773
772,773
774,775
774,776
775,776
778,779
779,780
779,781
780,781
782,783
785,786
786,787
786,788
787,788
789,790
791,792
791,793
791,794
792,793
793,794
793,795
794,795
796,797
798,799
798,800
799,800
802,803
802,804
802,805
802,806
802,807
803,804
804,805
804,806
805,806
807,808
807,809
807,810
808,809
810,811
812,813
812,814
813,814
816,817
817,818
817,819
818,819
820,821
822,823
823,824
823,825
824,825
826,827
828,829
828,830
828,831
829,830
829,831
830,831
833,834
833,835
834,835
834,836
834,837
834,838
836,837
836,838
837,838
840,841
840,842
841,842
842,843
844,845
844,846
845,846
847,848
849,850
849,851
849,852
849,853
850,851
851,852
851,853
852,853
853,854
854,855
856,857
856,858
857,858
860,861
861,862
861,863
862,863
863,864
864,865
866,867
866,868
867,868
869,870
871,872
872,873
872,874
873,874
874,875
875,876
877,878
877,879
878,879
880,881
882,883
883,884
883,885
884,885
885,886
886,887
890,891
890,892
891,892
893,894
893,895
894,895
894,896
894,897
894,898
896,897
896,898
897,898
900,901
900,902
901,902
902,903
904,905
904,906
905,906
907,908
909,910
909,911
909,912
909,913
910,911
911,912
911,913
912,913
913,914
914,915
916,917
916,918
917,918
920,921
921,922
921,923
922,923
923,924
924,925
926,927
926,928
927,928
929,930
931,932
932,933
932,934
933,934
934,935
935,936
937,938
937,939
938,939
940,941
942,943
943,944
943,945
944,945
945,946
946,947
948,949
948,950
949,950
951,952
954,955
954,956
954,957
954,958
956,957
956,958
957,958
960,961
960,962
961,962
962,963
964,965
964,966
965,966
967,968
969,970
969,971
969,972
969,973
970,971
971,972
971,973
973,974
973,975
975,976
976,977
976,978
977,978
979,980
981,982
981,983
982,983
982,984
983,984
983,985
984,985
987,988
988,989
988,990
989,990
992,993
992,994
992,995
992,996
992,997
993,994
994,995
994,996
995,996
996,997
997,998
999,1000
999,1001
1000,1001
1003,1004
1004,1005
1004,1006
1005,1006
1006,1007
1007,1008
1009,1010
1009,1011
1010,1011
1012,1013
1014,1015
1015,1016
1015,1017
1016,1017
1017,1018
1018,1019
1020,1021
1020,1022
1021,1022
1023,1024
1025,1026
1026,1027
1026,1028
1027,1028
1028,1029
1029,1030
1031,1032
1034,1035
1034,1036
1035,1036
1037,1038
1037,1039
1037,1040
1037,1041
1037,1042
1038,1039
1039,1040
1039,1041
1041,1042
1041,1043
1043,1044
1044,1045
1044,1046
1045,1046
1048,1049
1049,1050
1049,1051
1050,1051
1050,1052
1051,1052
1054,1055
1054,1056
1054,1057
1054,1058
1054,1059
1055,1056
1057,1058
1057,1059
1058,1059
1061,1062
1063,1064
1063,1065
1064,1065
1067,1068
1069,1070
1070,1071
1070,1072
1071,1072
1071,1073
1072,1073
1075,1076
1075,1077
1075,1078
1075,1079
1075,1080
1076,1077
1078,1079
1078,1080
1079,1080
1081,1082
1083,1084
1085,1086
1085,1087
1086,1087
1089,1090
1091,1092
1092,1093
1092,1094
1093,1094
1093,1095
1094,1095
1097,1098
1097,1099
1097,1100
1097,1101
1097,1102
1098,1099
1100,1101
1100,1102
1101,1102
1103,1104
1105,1106
1107,1108
1107,1109
1108,1109
1111,1112
1113,1114
1114,1115
1114,1116
1115,1116
1115,1117
1116,1117
1119,1120
1119,1121
1119,1122
1120,1121
1122,1123
1124,1125
1126,1127
1127,1128
1127,1129
1128,1129
1131,1132
1132,1133
1132,1134
1133,1134
1135,1136
1135,1137
1136,1137
1139,1140
1140,1141
1140,1142
1141,1142
1143,1144
1145,1146
1145,1147
1145,1148
1146,1147
1148,1149
1148,1150
1149,1150
1149,1151
1150,1151
1150,1152
1151,1152
1153,1154
1155,1156
1155,1157
1155,1158
1155,1159
1155,1160
1155,1161
1155,1162
1155,1163
1155,1164
1156,1157
1157,1158
1157,1159
1158,1159
1160,1161
1162,1163
1162,1164
1164,1165
1165,1166
1165,1167
1166,1167
1168,1169
1169,1170
1171,1172
1172,1173
1172,1174
1173,1174
1173,1175
1174,1175
1177,1178
1179,1180
1180,1181
1180,1182
1181,1182
1181,1183
1182,1183
1185,1186
1187,1188
1188,1189
1188,1190
1189,1190
1189,1191
1190,1191
1193,1194
1195,1196
1196,1197
1196,1198
1197,1198
1197,1199
1198,1199
1201,1202
1203,1204
1204,1205
1204,1206
1204,1207
1204,1208
1205,1206
1207,1208
1208,1209
1210,1211
1212,1213
1214,1215
1215,1216
1215,1217
1215,1218
1215,1219
1216,1217
1218,1219
1218,1220
1219,1220
1222,1223
1224,1225
1224,1226
1225,1226
1228,1229
1229,1230
1229,1231
1230,1231
1232,1233
1234,1235
1235,1236
1235,1237
1235,1238
1235,1239
1235,1240
1235,1241
1235,1242
1235,1243
1235,1244
1236,1237
1238,1239
1238,1240
1239,1240
1242,1243
1242,1244
1243,1244
1243,1245
1246,1247
1248,1249
1248,1250
1249,1250
1249,1251
1252,1253
1254,1255
1254,1256
1255,1256
1255,1257
1258,1259
1260,1261
1260,1262
1261,1262
1261,1263
1264,1265
1266,1267
1266,1268
1267,1268
1267,1269
1268,1269
1268,1270
1269,1270
1272,1273
1272,1274
1273,1274
1274,1275
1274,1276
1275,1276
1275,1277
1276,1277
1278,1279
1278,1280
1279,1280
1282,1283
1287,1288
1287,1289
1288,1289
1288,1290
1289,1290
1289,1291
1292,1293
1292,1294
1293,1294
1297,1298
1297,1299
1297,1300
1297,1301
1297,1302
1298,1299
1299,1300
1299,1301
1300,1301
1300,1302
1301,1302
1304,1305
1306,1307
1307,1308
1307,1309
1308,1309
1308,1310
1309,1310
1312,1313
1314,1315
1315,1316
1315,1317
1316,1317
1316,1318
1317,1318
1320,1321
1322,1323
1323,1324
1323,1325
1324,1325
1324,1326
1325,1326
1328,1329
1330,1331
1331,1332
1331,1333
1331,1334
1331,1335
1332,1333
1334,1335
1335,1336
1337,1338
1337,1339
1338,1339
1341,1342
1341,1343
1342,1343
1345,1346
1345,1347
1345,1348
1346,1347
1346,1348
1347,1348
1347,1349
1348,1349
1349,1350
1351,1352
1352,1353
1352,1354
1353,1354
1356,1357
1357,1358
1357,1359
1358,1359
1361,1362
1362,1363
1362,1364
1363,1364
1364,1365
1365,1366
1365,1367
1366,1367
1366,1368
1367,1368
1370,1371
1372,1373
1372,1374
1372,1375
1372,1376
1373,1374
1374,1375
1374,1376
1376,1377
1378,1379
1379,1380
1379,1381
1380,1381
1382,1383
1382,1384
1383,1384
1383,1385
1384,1385
1387,1388
1387,1389
1388,1389
1389,1390
1389,1391
1390,1391
1390,1392
1391,1392
1393,1394
1393,1395
1394,1395
1397,1398
1400,1401
1401,1402
1401,1403
1402,1403
1404,1405
1404,1406
1405,1406
1408,1409
1408,1410
1409,1410
1409,1411
1410,1411
1412,1413
1412,1414
1413,1414
1416,1417
1417,1418
1418,1419
1418,1420
1419,1420
1419,1421
1420,1421
1423,1424
1425,1426
1425,1427
1426,1427
1426,1428
1427,1428
1428,1429
1428,1430
1429,1430
1432,1433
1433,1434
1433,1435
1434,1435
1434,1436
1435,1436
1438,1439
1440,1441
1441,1442
1442,1443
1442,1444
1443,1444
1445,1446
1447,1448
1448,1449
1448,1450
1448,1451
1448,1452
1448,1453
1448,1454
1449,1450
1451,1452
1451,1453
1452,1453
1452,1454
1453,1454
1456,1457
1458,1459
1460,1461
1462,1463
1464,1465
1466,1467
1467,1468
1467,1469
1467,1470
1467,1471
1467,1472
1467,1473
1467,1474
1467,1475
1468,1469
1470,1471
1470,1472
1471,1472
1474,1475
1476,1477
1478,1479
1480,1481
1482,1483
1482,1484
1483,1484
1486,1487
1486,1488
1487,1488
1490,1491
1491,1492
-----nextToken-----
2,4,7,9,10,13,15,18,20,21,23,25,27,29,31,33,35,37,39,41,46,48,49,52,54,56,58,60,62,65,67,69,71,73,75,78,80,81,83,84,86,87,89,90,93,95,99,101,105,107,111,115,117,119,123,126,133,134,135,141,143,146,147,152,156,157,159,166,167,168,174,176,179,180,185,189,190,192,198,199,203,204,208,212,215,217,221,224,226,232,235,236,240,243,244,248,250,256,257,260,261,266,268,271,273,276,277,280,282,285,286,288,293,295,300,302,306,308,310,312,315,318,324,325,328,329,334,335,339,340,341,347,350,351,357,360,361,365,368,369,375,376,378,383,384,386,390,395,396,397,401,402,403,407,412,413,414,418,419,420,424,428,429,430,436,439,440,444,445,450,451,455,456,461,465,466,467,473,474,478,479,485,486,488,492,496,497,503,506,507,509,510,514,518,519,520,533,534,535,539,540,544,545,549,550,554,557,558,562,565,566,572,573,580,581,585,588,589,594,595,597,601,603,608,610,614,615,619,620,621,628,629,631,633,634,636,641,643,646,647,651,653,657,658,661,663,668,670,674,678,679,683,684,685,689,692,694,697,698,702,704,706,709,710,713,724,725,729,730,734,735,739,740,744,747,748,750,755,757,759,765,766,768,769,773,776,777,781,783,784,788,790,795,797,800,801,806,809,811,814,815,819,821,825,827,831,832,835,838,839,843,846,848,855,858,859,865,868,870,876,879,881,887,888,889,892,895,898,899,903,906,908,915,918,919,925,928,930,936,939,941,947,950,952,953,955,958,959,963,966,968,972,974,978,980,985,986,990,991,998,1001,1002,1008,1011,1013,1019,1022,1024,1030,1032,1033,1036,1040,1042,1046,1047,1052,1053,1056,1059,1060,1062,1065,1066,1068,1073,1074,1077,1080,1082,1084,1087,1088,1090,1095,1096,1099,1102,1104,1106,1109,1110,1112,1117,1118,1121,1123,1125,1129,1130,1134,1137,1138,1142,1144,1147,1152,1154,1159,1161,1163,1167,1170,1175,1176,1178,1183,1184,1186,1191,1192,1194,1199,1200,1202,1206,1209,1211,1213,1217,1220,1221,1223,1226,1227,1231,1233,1237,1240,1241,1244,1245,1247,1250,1251,1253,1256,1257,1259,1262,1263,1265,1270,1271,1277,1280,1281,1283,1284,1285,1286,1290,1291,1294,1295,1296,1302,1303,1305,1310,1311,1313,1318,1319,1321,1326,1327,1329,1333,1336,1339,1340,1343,1344,1350,1354,1355,1359,1360,1368,1369,1371,1375,1377,1381,1385,1386,1392,1395,1396,1398,1399,1403,1406,1407,1411,1414,1415,1421,1422,1424,1430,1431,1436,1437,1439,1444,1446,1450,1454,1455,1457,1459,1461,1463,1465,1469,1472,1473,1475,1477,1479,1481,1484,1485,1488,1489,1492
-----computeFrom-----
97,98
97,99
109,110
109,111
121,122
121,123
128,129
128,130
130,131
130,132
137,138
137,139
139,140
139,141
150,151
150,152
153,154
153,155
161,162
161,163
163,164
163,165
170,171
170,172
172,173
172,174
183,184
183,185
186,187
186,188
194,195
194,196
196,197
196,198
201,202
201,203
210,211
210,212
213,214
213,215
219,220
219,221
222,223
222,224
228,229
228,230
230,231
230,232
238,239
238,240
253,254
253,255
263,264
263,265
291,292
291,293
321,322
321,323
331,332
331,333
336,337
336,338
343,344
343,345
345,346
345,347
353,354
353,355
355,356
355,357
363,364
363,365
372,373
372,374
380,381
380,382
388,389
388,390
391,392
391,393
405,406
405,407
408,409
408,410
422,423
422,424
432,433
432,434
434,435
434,436
442,443
442,444
448,449
448,450
453,454
453,455
459,460
459,461
469,470
469,471
471,472
471,473
476,477
476,478
482,483
482,484
490,491
490,492
493,494
493,495
498,499
498,500
500,501
500,502
501,502
501,503
512,513
512,514
515,516
515,517
522,523
522,524
523,524
523,525
524,525
524,526
525,526
525,527
526,527
526,528
527,528
527,529
528,529
528,530
530,531
530,532
537,538
537,539
542,543
542,544
547,548
547,549
552,553
552,554
560,561
560,562
568,569
568,570
570,571
570,572
575,576
575,577
576,577
576,578
578,579
578,580
583,584
583,585
591,592
591,593
599,600
599,601
611,612
611,613
623,624
623,625
624,625
624,626
639,640
639,641
644,645
644,646
666,667
666,668
672,673
672,674
675,676
675,677
687,688
687,689
700,701
700,702
707,708
707,709
716,717
716,718
717,718
717,719
718,719
718,720
719,720
719,721
720,721
720,722
722,723
722,724
727,728
727,729
732,733
732,734
737,738
737,739
742,743
742,744
761,762
761,763
771,772
771,773
779,780
779,781
786,787
786,788
793,794
793,795
798,799
798,800
804,805
804,806
817,818
817,819
823,824
823,825
829,830
829,831
836,837
836,838
844,845
844,846
851,852
851,853
861,862
861,863
872,873
872,874
883,884
883,885
896,897
896,898
904,905
904,906
911,912
911,913
921,922
921,923
932,933
932,934
943,944
943,945
956,957
956,958
964,965
964,966
982,983
982,984
983,984
983,985
994,995
994,996
1004,1005
1004,1006
1015,1016
1015,1017
1026,1027
1026,1028
1049,1050
1049,1051
1070,1071
1070,1072
1092,1093
1092,1094
1114,1115
1114,1116
1127,1128
1127,1129
1132,1133
1132,1134
1140,1141
1140,1142
1150,1151
1150,1152
1165,1166
1165,1167
1172,1173
1172,1174
1180,1181
1180,1182
1188,1189
1188,1190
1196,1197
1196,1198
1266,1267
1266,1268
1267,1268
1267,1269
1272,1273
1272,1274
1274,1275
1274,1276
1275,1276
1275,1277
1287,1288
1287,1289
1299,1300
1299,1301
1307,1308
1307,1309
1315,1316
1315,1317
1323,1324
1323,1325
1346,1347
1346,1348
1347,1348
1347,1349
1352,1353
1352,1354
1357,1358
1357,1359
1365,1366
1365,1367
1379,1380
1379,1381
1382,1383
1382,1384
1387,1388
1387,1389
1389,1390
1389,1391
1390,1391
1390,1392
1401,1402
1401,1403
1409,1410
1409,1411
1412,1413
1412,1414
1418,1419
1418,1420
1426,1427
1426,1428
1428,1429
1428,1430
1433,1434
1433,1435
-----guardedBy-----
146,156
141,159
143,152
147,157
179,189
174,192
180,190
176,185
232,273
243,339
236,340
240,282
244,286
288,315
295,312
293,308
368,383
365,378
357,386
361,384
369,376
444,450
594,619
589,633
572,631
747,776
748,768
985,1032
990,1030
1354,1396
1436,1446
-----guardedByNegation-----
439,465
444,461
831,952
-----lastLexicalUse-----
444,461
-----jump-----
444,461
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;Declarator;Name;Declarator;Name;Declarator;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;Declarator;Name;Declarator;Name;Declarator;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;Declarator;Pointer;Name;Declarator;Pointer;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;BinaryExpression;IdExpression;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;Pointer;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;UnaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;UnaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ReturnStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ReturnStatement;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;UnaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;BinaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;UnaryExpression;BinaryExpression;BinaryExpression;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;IdExpression;Name;IdExpression;Name;LiteralExpression;GotoStatement;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ForStatement;NullStatement;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;BinaryExpression;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ContinueStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ForStatement;NullStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionList;UnaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;ContinueStatement;IfStatement;IdExpression;Name;CompoundStatement;ForStatement;NullStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionList;UnaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;ContinueStatement;ForStatement;NullStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionList;UnaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;IdExpression;Name;ContinueStatement;IfStatement;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;LabelStatement;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;IdExpression;Name;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;UnaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;LiteralExpression;LiteralExpression;BinaryExpression;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;BinaryExpression;UnaryExpression;IdExpression;Name;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;IfStatement;UnaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;UnaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ReturnStatement;IdExpression;Name;
-----ast_node-----
intTk_PhotoPutBlock(    Tcl_Interp *interp,		/* Interpreter for passing back error				 * messages, or NULL. */    Tk_PhotoHandle handle,	/* Opaque handle for the photo image to be				 * updated. */    register Tk_PhotoImageBlock *blockPtr,				/* Pointer to a structure describing the pixel				 * data to be copied into the image. */    int x, int y,		/* Coordinates of the top-left pixel to be				 * updated in the image. */    int width, int height,	/* Dimensions of the area of the image to be				 * updated. */    int compRule)		/* Compositing rule to use when processing				 * transparent pixels. */{    register PhotoMaster *masterPtr;    int xEnd, yEnd, greenOffset, blueOffset, alphaOffset;    int wLeft, hLeft, wCopy, hCopy, pitch;    unsigned char *srcPtr, *srcLinePtr, *destPtr, *destLinePtr;    int sourceIsSimplePhoto = compRule & SOURCE_IS_SIMPLE_ALPHA_PHOTO;    XRectangle rect;    masterPtr = (PhotoMaster *) handle;    compRule &= ~SOURCE_IS_SIMPLE_ALPHA_PHOTO;    if ((masterPtr->userWidth != 0) && ((x + width) > masterPtr->userWidth)) {	width = masterPtr->userWidth - x;    }    if ((masterPtr->userHeight != 0)	    && ((y + height) > masterPtr->userHeight)) {	height = masterPtr->userHeight - y;    }    if ((width <= 0) || (height <= 0)) {	return TCL_OK;    }    xEnd = x + width;    yEnd = y + height;    if ((xEnd > masterPtr->width) || (yEnd > masterPtr->height)) {	int sameSrc = (blockPtr->pixelPtr == masterPtr->pix32);	if (ImgPhotoSetSize(masterPtr, MAX(xEnd, masterPtr->width),		MAX(yEnd, masterPtr->height)) == TCL_ERROR) {	    if (interp != NULL) {		Tcl_ResetResult(interp);		Tcl_AppendResult(interp, TK_PHOTO_ALLOC_FAILURE_MESSAGE, NULL);	    }	    return TCL_ERROR;	}	if (sameSrc) {	    blockPtr->pixelPtr = masterPtr->pix32;	    blockPtr->pitch = masterPtr->width * 4;	}    }    if ((y < masterPtr->ditherY) || ((y == masterPtr->ditherY)	    && (x < masterPtr->ditherX))) {	/*	 * The dithering isn't correct past the start of this block.	 */	masterPtr->ditherX = x;	masterPtr->ditherY = y;    }    /*     * If this image block could have different red, green and blue     * components, mark it as a color image.     */    greenOffset = blockPtr->offset[1] - blockPtr->offset[0];    blueOffset = blockPtr->offset[2] - blockPtr->offset[0];    alphaOffset = blockPtr->offset[3];    if ((alphaOffset >= blockPtr->pixelSize) || (alphaOffset < 0)) {	alphaOffset = 0;	sourceIsSimplePhoto = 1;    } else {	alphaOffset -= blockPtr->offset[0];    }    if ((greenOffset != 0) || (blueOffset != 0)) {	masterPtr->flags |= COLOR_IMAGE;    }    /*     * Copy the data into our local 32-bit/pixel array. If we can do it with a     * single memmove, we do.     */    destLinePtr = masterPtr->pix32 + (y * masterPtr->width + x) * 4;    pitch = masterPtr->width * 4;    /*     * Test to see if we can do the whole write in a single copy. This test is     * probably too restrictive. We should also be able to do a memmove if     * pixelSize == 3 and alphaOffset == 0. Maybe other cases too.     */    if ((blockPtr->pixelSize == 4)	    && (greenOffset == 1) && (blueOffset == 2) && (alphaOffset == 3)	    && (width <= blockPtr->width) && (height <= blockPtr->height)	    && ((height == 1) || ((x == 0) && (width == masterPtr->width)		&& (blockPtr->pitch == pitch)))	    && (compRule == TK_PHOTO_COMPOSITE_SET)) {	memmove(destLinePtr, blockPtr->pixelPtr + blockPtr->offset[0],		((size_t) height * width * 4));	/*	 * We know there's an alpha offset and we're setting the data, so skip	 * directly to the point when we recompute the photo validity region.	 */	goto recalculateValidRegion;    }    /*     * Copy and merge pixels according to the compositing rule.     */    for (hLeft = height; hLeft > 0;) {	int pixelSize = blockPtr->pixelSize;	int compRuleSet = (compRule == TK_PHOTO_COMPOSITE_SET);	srcLinePtr = blockPtr->pixelPtr + blockPtr->offset[0];	hCopy = MIN(hLeft, blockPtr->height);	hLeft -= hCopy;	for (; hCopy > 0; --hCopy) {	    /*	     * If the layout of the source line matches our memory layout and	     * we're setting, we can just copy the bytes directly, which is	     * much faster.	     */	    if ((pixelSize == 4) && (greenOffset == 1)		    && (blueOffset == 2) && (alphaOffset == 3)		    && (width <= blockPtr->width)		    && compRuleSet) {		memcpy(destLinePtr, srcLinePtr, ((size_t) width * 4));		srcLinePtr += blockPtr->pitch;		destLinePtr += pitch;		continue;	    }	    /*	     * Have to copy the slow way.	     */	    destPtr = destLinePtr;	    for (wLeft = width; wLeft > 0;) {		wCopy = MIN(wLeft, blockPtr->width);		wLeft -= wCopy;		srcPtr = srcLinePtr;		/*		 * But we might be lucky and be able to use fairly fast loops.		 * It's worth checking...		 */		if (alphaOffset == 0) {		    /*		     * This is the non-alpha case, so can still be fairly		     * fast. Note that in the non-alpha-source case, the		     * compositing rule doesn't apply.		     */		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = 255;		    }		    continue;		} else if (compRuleSet) {		    /*		     * This is the SET compositing rule, which just replaces		     * what was there before with the new data. This is		     * another fairly fast case. No point in doing a memcpy();		     * the order of channels is probably wrong.		     */		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = srcPtr[alphaOffset];		    }		    continue;		}		/*		 * Bother; need to consider the alpha value of each pixel to		 * know what to do.		 */		for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {		    int alpha = srcPtr[alphaOffset];		    if (alpha == 255 || !destPtr[3]) {			/*			 * Either the source is 100% opaque, or the			 * destination is entirely blank. In all cases, we			 * just set the destination to the source.			 */			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = alpha;			continue;		    }		    /*		     * Can still skip doing work if the source is 100%		     * transparent at this point.		     */		    if (alpha) {			int Alpha = destPtr[3];			/*			 * OK, there's real work to be done. Luckily, there's			 * a substantial literature on what to do in this			 * case. In particular, Porter and Duff have done a			 * taxonomy of compositing rules, and the right one is			 * the "Source Over" rule. This code implements that.			 */			destPtr[0] = PD_SRC_OVER(srcPtr[0], alpha, destPtr[0],				Alpha);			destPtr[1] = PD_SRC_OVER(srcPtr[greenOffset], alpha,				destPtr[1], Alpha);			destPtr[2] = PD_SRC_OVER(srcPtr[blueOffset], alpha,				destPtr[2], Alpha);			destPtr[3] = PD_SRC_OVER_ALPHA(alpha, Alpha);		    }		    destPtr += 4;		}	    }	    srcLinePtr += blockPtr->pitch;	    destLinePtr += pitch;	}    }    /*     * Add this new block to the region which specifies which data is valid.     */    if (alphaOffset) {	/*	 * This block is grossly inefficient. For each row in the image, it	 * finds each continguous string of nontransparent pixels, then marks	 * those areas as valid in the validRegion mask. This makes drawing	 * very efficient, because of the way we use X: we just say, here's	 * your mask, and here's your data. We need not worry about the	 * current background color, etc. But this costs us a lot on the image	 * setup. Still, image setup only happens once, whereas the drawing	 * happens many times, so this might be the best way to go.	 *	 * An alternative might be to not set up this mask, and instead, at	 * drawing time, for each transparent pixel, set its color to the	 * color of the background behind that pixel. This is what I suspect	 * most of programs do. However, they don't have to deal with the	 * canvas, which could have many different background colors.	 * Determining the correct bg color for a given pixel might be	 * expensive.	 */	if (compRule != TK_PHOTO_COMPOSITE_OVERLAY) {	    TkRegion workRgn;	    /*	     * Don't need this when using the OVERLAY compositing rule, which	     * always strictly increases the valid region.	     */	recalculateValidRegion:	    workRgn = TkCreateRegion();	    rect.x = x;	    rect.y = y;	    rect.width = width;	    rect.height = height;	    TkUnionRectWithRegion(&rect, workRgn, workRgn);	    TkSubtractRegion(masterPtr->validRegion, workRgn,		    masterPtr->validRegion);	    TkDestroyRegion(workRgn);	}	/*	 * Factorize out the main part of the building of the region data to	 * allow for more efficient per-platform implementations. [Bug 919066]	 */	TkpBuildRegionFromAlphaData(masterPtr->validRegion, (unsigned) x,		(unsigned) y, (unsigned) width, (unsigned) height,		masterPtr->pix32 + (y * masterPtr->width + x) * 4 + 3,		4, (unsigned) masterPtr->width * 4);    } else {	rect.x = x;	rect.y = y;	rect.width = width;	rect.height = height;	TkUnionRectWithRegion(&rect, masterPtr->validRegion,		masterPtr->validRegion);    }    /*     * Check if display code needs alpha blending...     */    if (!sourceIsSimplePhoto && (width == 1) && (height == 1)) {	/*	 * Optimize the single pixel case if we can. This speeds up code that	 * builds up large simple-alpha images by single pixels.  We don't	 * negate COMPLEX_ALPHA in this case. [Bug 1409140]	 */	if (!(masterPtr->flags & COMPLEX_ALPHA)) {	    unsigned char newAlpha;	    destLinePtr = masterPtr->pix32 + (y * masterPtr->width + x) * 4;	    newAlpha = destLinePtr[3];	    if (newAlpha && newAlpha != 255) {		masterPtr->flags |= COMPLEX_ALPHA;	    }	}    } else if ((alphaOffset != 0) || (masterPtr->flags & COMPLEX_ALPHA)) {	/*	 * Check for partial transparency if alpha pixels are specified, or	 * rescan if we already knew such pixels existed.  To restrict this	 * Toggle to only checking the changed pixels requires knowing where	 * the alpha pixels are.	 */	ToggleComplexAlphaIfNeeded(masterPtr);    }    /*     * Update each instance.     */    Tk_DitherPhoto((Tk_PhotoHandle)masterPtr, x, y, width, height);    /*     * Tell the core image code that this image has changed.     */    Tk_ImageChanged(masterPtr->tkMaster, x, y, width, height,	    masterPtr->width, masterPtr->height);    return TCL_OK;}
int
Tk_PhotoPutBlock(    Tcl_Interp *interp,		/* Interpreter for passing back error				 * messages, or NULL. */    Tk_PhotoHandle handle,	/* Opaque handle for the photo image to be				 * updated. */    register Tk_PhotoImageBlock *blockPtr,				/* Pointer to a structure describing the pixel				 * data to be copied into the image. */    int x, int y,		/* Coordinates of the top-left pixel to be				 * updated in the image. */    int width, int height,	/* Dimensions of the area of the image to be				 * updated. */    int compRule)
Tk_PhotoPutBlock
Tcl_Interp *interp
Tcl_Interp
Tcl_Interp
*interp
*
interp
Tk_PhotoHandle handle
Tk_PhotoHandle
Tk_PhotoHandle
handle
handle
register Tk_PhotoImageBlock *blockPtr
register Tk_PhotoImageBlock
Tk_PhotoImageBlock
*blockPtr
*
blockPtr
int x
int
x
x
int y
int
y
y
int width
int
width
width
int height
int
height
height
int compRule
int
compRule
compRule
{    register PhotoMaster *masterPtr;    int xEnd, yEnd, greenOffset, blueOffset, alphaOffset;    int wLeft, hLeft, wCopy, hCopy, pitch;    unsigned char *srcPtr, *srcLinePtr, *destPtr, *destLinePtr;    int sourceIsSimplePhoto = compRule & SOURCE_IS_SIMPLE_ALPHA_PHOTO;    XRectangle rect;    masterPtr = (PhotoMaster *) handle;    compRule &= ~SOURCE_IS_SIMPLE_ALPHA_PHOTO;    if ((masterPtr->userWidth != 0) && ((x + width) > masterPtr->userWidth)) {	width = masterPtr->userWidth - x;    }    if ((masterPtr->userHeight != 0)	    && ((y + height) > masterPtr->userHeight)) {	height = masterPtr->userHeight - y;    }    if ((width <= 0) || (height <= 0)) {	return TCL_OK;    }    xEnd = x + width;    yEnd = y + height;    if ((xEnd > masterPtr->width) || (yEnd > masterPtr->height)) {	int sameSrc = (blockPtr->pixelPtr == masterPtr->pix32);	if (ImgPhotoSetSize(masterPtr, MAX(xEnd, masterPtr->width),		MAX(yEnd, masterPtr->height)) == TCL_ERROR) {	    if (interp != NULL) {		Tcl_ResetResult(interp);		Tcl_AppendResult(interp, TK_PHOTO_ALLOC_FAILURE_MESSAGE, NULL);	    }	    return TCL_ERROR;	}	if (sameSrc) {	    blockPtr->pixelPtr = masterPtr->pix32;	    blockPtr->pitch = masterPtr->width * 4;	}    }    if ((y < masterPtr->ditherY) || ((y == masterPtr->ditherY)	    && (x < masterPtr->ditherX))) {	/*	 * The dithering isn't correct past the start of this block.	 */	masterPtr->ditherX = x;	masterPtr->ditherY = y;    }    /*     * If this image block could have different red, green and blue     * components, mark it as a color image.     */    greenOffset = blockPtr->offset[1] - blockPtr->offset[0];    blueOffset = blockPtr->offset[2] - blockPtr->offset[0];    alphaOffset = blockPtr->offset[3];    if ((alphaOffset >= blockPtr->pixelSize) || (alphaOffset < 0)) {	alphaOffset = 0;	sourceIsSimplePhoto = 1;    } else {	alphaOffset -= blockPtr->offset[0];    }    if ((greenOffset != 0) || (blueOffset != 0)) {	masterPtr->flags |= COLOR_IMAGE;    }    /*     * Copy the data into our local 32-bit/pixel array. If we can do it with a     * single memmove, we do.     */    destLinePtr = masterPtr->pix32 + (y * masterPtr->width + x) * 4;    pitch = masterPtr->width * 4;    /*     * Test to see if we can do the whole write in a single copy. This test is     * probably too restrictive. We should also be able to do a memmove if     * pixelSize == 3 and alphaOffset == 0. Maybe other cases too.     */    if ((blockPtr->pixelSize == 4)	    && (greenOffset == 1) && (blueOffset == 2) && (alphaOffset == 3)	    && (width <= blockPtr->width) && (height <= blockPtr->height)	    && ((height == 1) || ((x == 0) && (width == masterPtr->width)		&& (blockPtr->pitch == pitch)))	    && (compRule == TK_PHOTO_COMPOSITE_SET)) {	memmove(destLinePtr, blockPtr->pixelPtr + blockPtr->offset[0],		((size_t) height * width * 4));	/*	 * We know there's an alpha offset and we're setting the data, so skip	 * directly to the point when we recompute the photo validity region.	 */	goto recalculateValidRegion;    }    /*     * Copy and merge pixels according to the compositing rule.     */    for (hLeft = height; hLeft > 0;) {	int pixelSize = blockPtr->pixelSize;	int compRuleSet = (compRule == TK_PHOTO_COMPOSITE_SET);	srcLinePtr = blockPtr->pixelPtr + blockPtr->offset[0];	hCopy = MIN(hLeft, blockPtr->height);	hLeft -= hCopy;	for (; hCopy > 0; --hCopy) {	    /*	     * If the layout of the source line matches our memory layout and	     * we're setting, we can just copy the bytes directly, which is	     * much faster.	     */	    if ((pixelSize == 4) && (greenOffset == 1)		    && (blueOffset == 2) && (alphaOffset == 3)		    && (width <= blockPtr->width)		    && compRuleSet) {		memcpy(destLinePtr, srcLinePtr, ((size_t) width * 4));		srcLinePtr += blockPtr->pitch;		destLinePtr += pitch;		continue;	    }	    /*	     * Have to copy the slow way.	     */	    destPtr = destLinePtr;	    for (wLeft = width; wLeft > 0;) {		wCopy = MIN(wLeft, blockPtr->width);		wLeft -= wCopy;		srcPtr = srcLinePtr;		/*		 * But we might be lucky and be able to use fairly fast loops.		 * It's worth checking...		 */		if (alphaOffset == 0) {		    /*		     * This is the non-alpha case, so can still be fairly		     * fast. Note that in the non-alpha-source case, the		     * compositing rule doesn't apply.		     */		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = 255;		    }		    continue;		} else if (compRuleSet) {		    /*		     * This is the SET compositing rule, which just replaces		     * what was there before with the new data. This is		     * another fairly fast case. No point in doing a memcpy();		     * the order of channels is probably wrong.		     */		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = srcPtr[alphaOffset];		    }		    continue;		}		/*		 * Bother; need to consider the alpha value of each pixel to		 * know what to do.		 */		for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {		    int alpha = srcPtr[alphaOffset];		    if (alpha == 255 || !destPtr[3]) {			/*			 * Either the source is 100% opaque, or the			 * destination is entirely blank. In all cases, we			 * just set the destination to the source.			 */			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = alpha;			continue;		    }		    /*		     * Can still skip doing work if the source is 100%		     * transparent at this point.		     */		    if (alpha) {			int Alpha = destPtr[3];			/*			 * OK, there's real work to be done. Luckily, there's			 * a substantial literature on what to do in this			 * case. In particular, Porter and Duff have done a			 * taxonomy of compositing rules, and the right one is			 * the "Source Over" rule. This code implements that.			 */			destPtr[0] = PD_SRC_OVER(srcPtr[0], alpha, destPtr[0],				Alpha);			destPtr[1] = PD_SRC_OVER(srcPtr[greenOffset], alpha,				destPtr[1], Alpha);			destPtr[2] = PD_SRC_OVER(srcPtr[blueOffset], alpha,				destPtr[2], Alpha);			destPtr[3] = PD_SRC_OVER_ALPHA(alpha, Alpha);		    }		    destPtr += 4;		}	    }	    srcLinePtr += blockPtr->pitch;	    destLinePtr += pitch;	}    }    /*     * Add this new block to the region which specifies which data is valid.     */    if (alphaOffset) {	/*	 * This block is grossly inefficient. For each row in the image, it	 * finds each continguous string of nontransparent pixels, then marks	 * those areas as valid in the validRegion mask. This makes drawing	 * very efficient, because of the way we use X: we just say, here's	 * your mask, and here's your data. We need not worry about the	 * current background color, etc. But this costs us a lot on the image	 * setup. Still, image setup only happens once, whereas the drawing	 * happens many times, so this might be the best way to go.	 *	 * An alternative might be to not set up this mask, and instead, at	 * drawing time, for each transparent pixel, set its color to the	 * color of the background behind that pixel. This is what I suspect	 * most of programs do. However, they don't have to deal with the	 * canvas, which could have many different background colors.	 * Determining the correct bg color for a given pixel might be	 * expensive.	 */	if (compRule != TK_PHOTO_COMPOSITE_OVERLAY) {	    TkRegion workRgn;	    /*	     * Don't need this when using the OVERLAY compositing rule, which	     * always strictly increases the valid region.	     */	recalculateValidRegion:	    workRgn = TkCreateRegion();	    rect.x = x;	    rect.y = y;	    rect.width = width;	    rect.height = height;	    TkUnionRectWithRegion(&rect, workRgn, workRgn);	    TkSubtractRegion(masterPtr->validRegion, workRgn,		    masterPtr->validRegion);	    TkDestroyRegion(workRgn);	}	/*	 * Factorize out the main part of the building of the region data to	 * allow for more efficient per-platform implementations. [Bug 919066]	 */	TkpBuildRegionFromAlphaData(masterPtr->validRegion, (unsigned) x,		(unsigned) y, (unsigned) width, (unsigned) height,		masterPtr->pix32 + (y * masterPtr->width + x) * 4 + 3,		4, (unsigned) masterPtr->width * 4);    } else {	rect.x = x;	rect.y = y;	rect.width = width;	rect.height = height;	TkUnionRectWithRegion(&rect, masterPtr->validRegion,		masterPtr->validRegion);    }    /*     * Check if display code needs alpha blending...     */    if (!sourceIsSimplePhoto && (width == 1) && (height == 1)) {	/*	 * Optimize the single pixel case if we can. This speeds up code that	 * builds up large simple-alpha images by single pixels.  We don't	 * negate COMPLEX_ALPHA in this case. [Bug 1409140]	 */	if (!(masterPtr->flags & COMPLEX_ALPHA)) {	    unsigned char newAlpha;	    destLinePtr = masterPtr->pix32 + (y * masterPtr->width + x) * 4;	    newAlpha = destLinePtr[3];	    if (newAlpha && newAlpha != 255) {		masterPtr->flags |= COMPLEX_ALPHA;	    }	}    } else if ((alphaOffset != 0) || (masterPtr->flags & COMPLEX_ALPHA)) {	/*	 * Check for partial transparency if alpha pixels are specified, or	 * rescan if we already knew such pixels existed.  To restrict this	 * Toggle to only checking the changed pixels requires knowing where	 * the alpha pixels are.	 */	ToggleComplexAlphaIfNeeded(masterPtr);    }    /*     * Update each instance.     */    Tk_DitherPhoto((Tk_PhotoHandle)masterPtr, x, y, width, height);    /*     * Tell the core image code that this image has changed.     */    Tk_ImageChanged(masterPtr->tkMaster, x, y, width, height,	    masterPtr->width, masterPtr->height);    return TCL_OK;}
register PhotoMaster *masterPtr;
register PhotoMaster *masterPtr;
register PhotoMaster
PhotoMaster
*masterPtr
*
masterPtr
int xEnd, yEnd, greenOffset, blueOffset, alphaOffset;
int xEnd, yEnd, greenOffset, blueOffset, alphaOffset;
int
xEnd
xEnd
yEnd
yEnd
greenOffset
greenOffset
blueOffset
blueOffset
alphaOffset
alphaOffset
int wLeft, hLeft, wCopy, hCopy, pitch;
int wLeft, hLeft, wCopy, hCopy, pitch;
int
wLeft
wLeft
hLeft
hLeft
wCopy
wCopy
hCopy
hCopy
pitch
pitch
unsigned char *srcPtr, *srcLinePtr, *destPtr, *destLinePtr;
unsigned char *srcPtr, *srcLinePtr, *destPtr, *destLinePtr;
unsigned char
*srcPtr
*
srcPtr
*srcLinePtr
*
srcLinePtr
*destPtr
*
destPtr
*destLinePtr
*
destLinePtr
int sourceIsSimplePhoto = compRule & SOURCE_IS_SIMPLE_ALPHA_PHOTO;
int sourceIsSimplePhoto = compRule & SOURCE_IS_SIMPLE_ALPHA_PHOTO;
int
sourceIsSimplePhoto = compRule & SOURCE_IS_SIMPLE_ALPHA_PHOTO
sourceIsSimplePhoto
= compRule & SOURCE_IS_SIMPLE_ALPHA_PHOTO
compRule & SOURCE_IS_SIMPLE_ALPHA_PHOTO
compRule
compRule
SOURCE_IS_SIMPLE_ALPHA_PHOTO
SOURCE_IS_SIMPLE_ALPHA_PHOTO
XRectangle rect;
XRectangle rect;
XRectangle
XRectangle
rect
rect
masterPtr = (PhotoMaster *) handle;
masterPtr = (PhotoMaster *) handle
masterPtr
masterPtr
(PhotoMaster *) handle
PhotoMaster *
PhotoMaster
PhotoMaster
*
*
handle
handle
compRule &= ~SOURCE_IS_SIMPLE_ALPHA_PHOTO;
compRule &= ~SOURCE_IS_SIMPLE_ALPHA_PHOTO
compRule
compRule
~SOURCE_IS_SIMPLE_ALPHA_PHOTO
SOURCE_IS_SIMPLE_ALPHA_PHOTO
SOURCE_IS_SIMPLE_ALPHA_PHOTO
if ((masterPtr->userWidth != 0) && ((x + width) > masterPtr->userWidth)) {	width = masterPtr->userWidth - x;    }
(masterPtr->userWidth != 0) && ((x + width) > masterPtr->userWidth)
(masterPtr->userWidth != 0)
masterPtr->userWidth != 0
masterPtr->userWidth
masterPtr
masterPtr
userWidth
0
((x + width) > masterPtr->userWidth)
(x + width) > masterPtr->userWidth
(x + width)
x + width
x
x
width
width
masterPtr->userWidth
masterPtr
masterPtr
userWidth
{	width = masterPtr->userWidth - x;    }
width = masterPtr->userWidth - x;
width = masterPtr->userWidth - x
width
width
masterPtr->userWidth - x
masterPtr->userWidth
masterPtr
masterPtr
userWidth
x
x
if ((masterPtr->userHeight != 0)	    && ((y + height) > masterPtr->userHeight)) {	height = masterPtr->userHeight - y;    }
(masterPtr->userHeight != 0)	    && ((y + height) > masterPtr->userHeight)
(masterPtr->userHeight != 0)
masterPtr->userHeight != 0
masterPtr->userHeight
masterPtr
masterPtr
userHeight
0
((y + height) > masterPtr->userHeight)
(y + height) > masterPtr->userHeight
(y + height)
y + height
y
y
height
height
masterPtr->userHeight
masterPtr
masterPtr
userHeight
{	height = masterPtr->userHeight - y;    }
height = masterPtr->userHeight - y;
height = masterPtr->userHeight - y
height
height
masterPtr->userHeight - y
masterPtr->userHeight
masterPtr
masterPtr
userHeight
y
y
if ((width <= 0) || (height <= 0)) {	return TCL_OK;    }
(width <= 0) || (height <= 0)
(width <= 0)
width <= 0
width
width
0
(height <= 0)
height <= 0
height
height
0
{	return TCL_OK;    }
return TCL_OK;
TCL_OK
TCL_OK
xEnd = x + width;
xEnd = x + width
xEnd
xEnd
x + width
x
x
width
width
yEnd = y + height;
yEnd = y + height
yEnd
yEnd
y + height
y
y
height
height
if ((xEnd > masterPtr->width) || (yEnd > masterPtr->height)) {	int sameSrc = (blockPtr->pixelPtr == masterPtr->pix32);	if (ImgPhotoSetSize(masterPtr, MAX(xEnd, masterPtr->width),		MAX(yEnd, masterPtr->height)) == TCL_ERROR) {	    if (interp != NULL) {		Tcl_ResetResult(interp);		Tcl_AppendResult(interp, TK_PHOTO_ALLOC_FAILURE_MESSAGE, NULL);	    }	    return TCL_ERROR;	}	if (sameSrc) {	    blockPtr->pixelPtr = masterPtr->pix32;	    blockPtr->pitch = masterPtr->width * 4;	}    }
(xEnd > masterPtr->width) || (yEnd > masterPtr->height)
(xEnd > masterPtr->width)
xEnd > masterPtr->width
xEnd
xEnd
masterPtr->width
masterPtr
masterPtr
width
(yEnd > masterPtr->height)
yEnd > masterPtr->height
yEnd
yEnd
masterPtr->height
masterPtr
masterPtr
height
{	int sameSrc = (blockPtr->pixelPtr == masterPtr->pix32);	if (ImgPhotoSetSize(masterPtr, MAX(xEnd, masterPtr->width),		MAX(yEnd, masterPtr->height)) == TCL_ERROR) {	    if (interp != NULL) {		Tcl_ResetResult(interp);		Tcl_AppendResult(interp, TK_PHOTO_ALLOC_FAILURE_MESSAGE, NULL);	    }	    return TCL_ERROR;	}	if (sameSrc) {	    blockPtr->pixelPtr = masterPtr->pix32;	    blockPtr->pitch = masterPtr->width * 4;	}    }
int sameSrc = (blockPtr->pixelPtr == masterPtr->pix32);
int sameSrc = (blockPtr->pixelPtr == masterPtr->pix32);
int
sameSrc = (blockPtr->pixelPtr == masterPtr->pix32)
sameSrc
= (blockPtr->pixelPtr == masterPtr->pix32)
(blockPtr->pixelPtr == masterPtr->pix32)
blockPtr->pixelPtr == masterPtr->pix32
blockPtr->pixelPtr
blockPtr
blockPtr
pixelPtr
masterPtr->pix32
masterPtr
masterPtr
pix32
if (ImgPhotoSetSize(masterPtr, MAX(xEnd, masterPtr->width),		MAX(yEnd, masterPtr->height)) == TCL_ERROR) {	    if (interp != NULL) {		Tcl_ResetResult(interp);		Tcl_AppendResult(interp, TK_PHOTO_ALLOC_FAILURE_MESSAGE, NULL);	    }	    return TCL_ERROR;	}
ImgPhotoSetSize(masterPtr, MAX(xEnd, masterPtr->width),		MAX(yEnd, masterPtr->height)) == TCL_ERROR
ImgPhotoSetSize(masterPtr, MAX(xEnd, masterPtr->width),		MAX(yEnd, masterPtr->height))
ImgPhotoSetSize
ImgPhotoSetSize
masterPtr
masterPtr
MAX(xEnd, masterPtr->width)
MAX
MAX
xEnd
xEnd
masterPtr->width
masterPtr
masterPtr
width
MAX(yEnd, masterPtr->height)
MAX
MAX
yEnd
yEnd
masterPtr->height
masterPtr
masterPtr
height
TCL_ERROR
TCL_ERROR
{	    if (interp != NULL) {		Tcl_ResetResult(interp);		Tcl_AppendResult(interp, TK_PHOTO_ALLOC_FAILURE_MESSAGE, NULL);	    }	    return TCL_ERROR;	}
if (interp != NULL) {		Tcl_ResetResult(interp);		Tcl_AppendResult(interp, TK_PHOTO_ALLOC_FAILURE_MESSAGE, NULL);	    }
interp != NULL
interp
interp
NULL
NULL
{		Tcl_ResetResult(interp);		Tcl_AppendResult(interp, TK_PHOTO_ALLOC_FAILURE_MESSAGE, NULL);	    }
Tcl_ResetResult(interp);
Tcl_ResetResult(interp)
Tcl_ResetResult
Tcl_ResetResult
interp
interp
Tcl_AppendResult(interp, TK_PHOTO_ALLOC_FAILURE_MESSAGE, NULL);
Tcl_AppendResult(interp, TK_PHOTO_ALLOC_FAILURE_MESSAGE, NULL)
Tcl_AppendResult
Tcl_AppendResult
interp
interp
TK_PHOTO_ALLOC_FAILURE_MESSAGE
TK_PHOTO_ALLOC_FAILURE_MESSAGE
NULL
NULL
return TCL_ERROR;
TCL_ERROR
TCL_ERROR
if (sameSrc) {	    blockPtr->pixelPtr = masterPtr->pix32;	    blockPtr->pitch = masterPtr->width * 4;	}
sameSrc
sameSrc
{	    blockPtr->pixelPtr = masterPtr->pix32;	    blockPtr->pitch = masterPtr->width * 4;	}
blockPtr->pixelPtr = masterPtr->pix32;
blockPtr->pixelPtr = masterPtr->pix32
blockPtr->pixelPtr
blockPtr
blockPtr
pixelPtr
masterPtr->pix32
masterPtr
masterPtr
pix32
blockPtr->pitch = masterPtr->width * 4;
blockPtr->pitch = masterPtr->width * 4
blockPtr->pitch
blockPtr
blockPtr
pitch
masterPtr->width * 4
masterPtr->width
masterPtr
masterPtr
width
4
if ((y < masterPtr->ditherY) || ((y == masterPtr->ditherY)	    && (x < masterPtr->ditherX))) {	/*	 * The dithering isn't correct past the start of this block.	 */	masterPtr->ditherX = x;	masterPtr->ditherY = y;    }
(y < masterPtr->ditherY) || ((y == masterPtr->ditherY)	    && (x < masterPtr->ditherX))
(y < masterPtr->ditherY)
y < masterPtr->ditherY
y
y
masterPtr->ditherY
masterPtr
masterPtr
ditherY
((y == masterPtr->ditherY)	    && (x < masterPtr->ditherX))
(y == masterPtr->ditherY)	    && (x < masterPtr->ditherX)
(y == masterPtr->ditherY)
y == masterPtr->ditherY
y
y
masterPtr->ditherY
masterPtr
masterPtr
ditherY
(x < masterPtr->ditherX)
x < masterPtr->ditherX
x
x
masterPtr->ditherX
masterPtr
masterPtr
ditherX
{	/*	 * The dithering isn't correct past the start of this block.	 */	masterPtr->ditherX = x;	masterPtr->ditherY = y;    }
masterPtr->ditherX = x;
masterPtr->ditherX = x
masterPtr->ditherX
masterPtr
masterPtr
ditherX
x
x
masterPtr->ditherY = y;
masterPtr->ditherY = y
masterPtr->ditherY
masterPtr
masterPtr
ditherY
y
y
greenOffset = blockPtr->offset[1] - blockPtr->offset[0];
greenOffset = blockPtr->offset[1] - blockPtr->offset[0]
greenOffset
greenOffset
blockPtr->offset[1] - blockPtr->offset[0]
blockPtr->offset[1]
blockPtr->offset
blockPtr
blockPtr
offset
1
blockPtr->offset[0]
blockPtr->offset
blockPtr
blockPtr
offset
0
blueOffset = blockPtr->offset[2] - blockPtr->offset[0];
blueOffset = blockPtr->offset[2] - blockPtr->offset[0]
blueOffset
blueOffset
blockPtr->offset[2] - blockPtr->offset[0]
blockPtr->offset[2]
blockPtr->offset
blockPtr
blockPtr
offset
2
blockPtr->offset[0]
blockPtr->offset
blockPtr
blockPtr
offset
0
alphaOffset = blockPtr->offset[3];
alphaOffset = blockPtr->offset[3]
alphaOffset
alphaOffset
blockPtr->offset[3]
blockPtr->offset
blockPtr
blockPtr
offset
3
if ((alphaOffset >= blockPtr->pixelSize) || (alphaOffset < 0)) {	alphaOffset = 0;	sourceIsSimplePhoto = 1;    } else {	alphaOffset -= blockPtr->offset[0];    }
(alphaOffset >= blockPtr->pixelSize) || (alphaOffset < 0)
(alphaOffset >= blockPtr->pixelSize)
alphaOffset >= blockPtr->pixelSize
alphaOffset
alphaOffset
blockPtr->pixelSize
blockPtr
blockPtr
pixelSize
(alphaOffset < 0)
alphaOffset < 0
alphaOffset
alphaOffset
0
{	alphaOffset = 0;	sourceIsSimplePhoto = 1;    }
alphaOffset = 0;
alphaOffset = 0
alphaOffset
alphaOffset
0
sourceIsSimplePhoto = 1;
sourceIsSimplePhoto = 1
sourceIsSimplePhoto
sourceIsSimplePhoto
1
{	alphaOffset -= blockPtr->offset[0];    }
alphaOffset -= blockPtr->offset[0];
alphaOffset -= blockPtr->offset[0]
alphaOffset
alphaOffset
blockPtr->offset[0]
blockPtr->offset
blockPtr
blockPtr
offset
0
if ((greenOffset != 0) || (blueOffset != 0)) {	masterPtr->flags |= COLOR_IMAGE;    }
(greenOffset != 0) || (blueOffset != 0)
(greenOffset != 0)
greenOffset != 0
greenOffset
greenOffset
0
(blueOffset != 0)
blueOffset != 0
blueOffset
blueOffset
0
{	masterPtr->flags |= COLOR_IMAGE;    }
masterPtr->flags |= COLOR_IMAGE;
masterPtr->flags |= COLOR_IMAGE
masterPtr->flags
masterPtr
masterPtr
flags
COLOR_IMAGE
COLOR_IMAGE
destLinePtr = masterPtr->pix32 + (y * masterPtr->width + x) * 4;
destLinePtr = masterPtr->pix32 + (y * masterPtr->width + x) * 4
destLinePtr
destLinePtr
masterPtr->pix32 + (y * masterPtr->width + x) * 4
masterPtr->pix32
masterPtr
masterPtr
pix32
(y * masterPtr->width + x) * 4
(y * masterPtr->width + x)
y * masterPtr->width + x
y * masterPtr->width
y
y
masterPtr->width
masterPtr
masterPtr
width
x
x
4
pitch = masterPtr->width * 4;
pitch = masterPtr->width * 4
pitch
pitch
masterPtr->width * 4
masterPtr->width
masterPtr
masterPtr
width
4
if ((blockPtr->pixelSize == 4)	    && (greenOffset == 1) && (blueOffset == 2) && (alphaOffset == 3)	    && (width <= blockPtr->width) && (height <= blockPtr->height)	    && ((height == 1) || ((x == 0) && (width == masterPtr->width)		&& (blockPtr->pitch == pitch)))	    && (compRule == TK_PHOTO_COMPOSITE_SET)) {	memmove(destLinePtr, blockPtr->pixelPtr + blockPtr->offset[0],		((size_t) height * width * 4));	/*	 * We know there's an alpha offset and we're setting the data, so skip	 * directly to the point when we recompute the photo validity region.	 */	goto recalculateValidRegion;    }
(blockPtr->pixelSize == 4)	    && (greenOffset == 1) && (blueOffset == 2) && (alphaOffset == 3)	    && (width <= blockPtr->width) && (height <= blockPtr->height)	    && ((height == 1) || ((x == 0) && (width == masterPtr->width)		&& (blockPtr->pitch == pitch)))	    && (compRule == TK_PHOTO_COMPOSITE_SET)
(blockPtr->pixelSize == 4)	    && (greenOffset == 1) && (blueOffset == 2) && (alphaOffset == 3)	    && (width <= blockPtr->width) && (height <= blockPtr->height)	    && ((height == 1) || ((x == 0) && (width == masterPtr->width)		&& (blockPtr->pitch == pitch)))
(blockPtr->pixelSize == 4)	    && (greenOffset == 1) && (blueOffset == 2) && (alphaOffset == 3)	    && (width <= blockPtr->width) && (height <= blockPtr->height)
(blockPtr->pixelSize == 4)	    && (greenOffset == 1) && (blueOffset == 2) && (alphaOffset == 3)	    && (width <= blockPtr->width)
(blockPtr->pixelSize == 4)	    && (greenOffset == 1) && (blueOffset == 2) && (alphaOffset == 3)
(blockPtr->pixelSize == 4)	    && (greenOffset == 1) && (blueOffset == 2)
(blockPtr->pixelSize == 4)	    && (greenOffset == 1)
(blockPtr->pixelSize == 4)
blockPtr->pixelSize == 4
blockPtr->pixelSize
blockPtr
blockPtr
pixelSize
4
(greenOffset == 1)
greenOffset == 1
greenOffset
greenOffset
1
(blueOffset == 2)
blueOffset == 2
blueOffset
blueOffset
2
(alphaOffset == 3)
alphaOffset == 3
alphaOffset
alphaOffset
3
(width <= blockPtr->width)
width <= blockPtr->width
width
width
blockPtr->width
blockPtr
blockPtr
width
(height <= blockPtr->height)
height <= blockPtr->height
height
height
blockPtr->height
blockPtr
blockPtr
height
((height == 1) || ((x == 0) && (width == masterPtr->width)		&& (blockPtr->pitch == pitch)))
(height == 1) || ((x == 0) && (width == masterPtr->width)		&& (blockPtr->pitch == pitch))
(height == 1)
height == 1
height
height
1
((x == 0) && (width == masterPtr->width)		&& (blockPtr->pitch == pitch))
(x == 0) && (width == masterPtr->width)		&& (blockPtr->pitch == pitch)
(x == 0) && (width == masterPtr->width)
(x == 0)
x == 0
x
x
0
(width == masterPtr->width)
width == masterPtr->width
width
width
masterPtr->width
masterPtr
masterPtr
width
(blockPtr->pitch == pitch)
blockPtr->pitch == pitch
blockPtr->pitch
blockPtr
blockPtr
pitch
pitch
pitch
(compRule == TK_PHOTO_COMPOSITE_SET)
compRule == TK_PHOTO_COMPOSITE_SET
compRule
compRule
TK_PHOTO_COMPOSITE_SET
TK_PHOTO_COMPOSITE_SET
{	memmove(destLinePtr, blockPtr->pixelPtr + blockPtr->offset[0],		((size_t) height * width * 4));	/*	 * We know there's an alpha offset and we're setting the data, so skip	 * directly to the point when we recompute the photo validity region.	 */	goto recalculateValidRegion;    }
memmove(destLinePtr, blockPtr->pixelPtr + blockPtr->offset[0],		((size_t) height * width * 4));
memmove(destLinePtr, blockPtr->pixelPtr + blockPtr->offset[0],		((size_t) height * width * 4))
memmove
memmove
destLinePtr
destLinePtr
blockPtr->pixelPtr + blockPtr->offset[0]
blockPtr->pixelPtr
blockPtr
blockPtr
pixelPtr
blockPtr->offset[0]
blockPtr->offset
blockPtr
blockPtr
offset
0
((size_t) height * width * 4)
(size_t) height * width * 4
(size_t) height * width
(size_t) height
size_t
size_t
size_t

height
height
width
width
4
goto recalculateValidRegion;
recalculateValidRegion
for (hLeft = height; hLeft > 0;) {	int pixelSize = blockPtr->pixelSize;	int compRuleSet = (compRule == TK_PHOTO_COMPOSITE_SET);	srcLinePtr = blockPtr->pixelPtr + blockPtr->offset[0];	hCopy = MIN(hLeft, blockPtr->height);	hLeft -= hCopy;	for (; hCopy > 0; --hCopy) {	    /*	     * If the layout of the source line matches our memory layout and	     * we're setting, we can just copy the bytes directly, which is	     * much faster.	     */	    if ((pixelSize == 4) && (greenOffset == 1)		    && (blueOffset == 2) && (alphaOffset == 3)		    && (width <= blockPtr->width)		    && compRuleSet) {		memcpy(destLinePtr, srcLinePtr, ((size_t) width * 4));		srcLinePtr += blockPtr->pitch;		destLinePtr += pitch;		continue;	    }	    /*	     * Have to copy the slow way.	     */	    destPtr = destLinePtr;	    for (wLeft = width; wLeft > 0;) {		wCopy = MIN(wLeft, blockPtr->width);		wLeft -= wCopy;		srcPtr = srcLinePtr;		/*		 * But we might be lucky and be able to use fairly fast loops.		 * It's worth checking...		 */		if (alphaOffset == 0) {		    /*		     * This is the non-alpha case, so can still be fairly		     * fast. Note that in the non-alpha-source case, the		     * compositing rule doesn't apply.		     */		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = 255;		    }		    continue;		} else if (compRuleSet) {		    /*		     * This is the SET compositing rule, which just replaces		     * what was there before with the new data. This is		     * another fairly fast case. No point in doing a memcpy();		     * the order of channels is probably wrong.		     */		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = srcPtr[alphaOffset];		    }		    continue;		}		/*		 * Bother; need to consider the alpha value of each pixel to		 * know what to do.		 */		for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {		    int alpha = srcPtr[alphaOffset];		    if (alpha == 255 || !destPtr[3]) {			/*			 * Either the source is 100% opaque, or the			 * destination is entirely blank. In all cases, we			 * just set the destination to the source.			 */			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = alpha;			continue;		    }		    /*		     * Can still skip doing work if the source is 100%		     * transparent at this point.		     */		    if (alpha) {			int Alpha = destPtr[3];			/*			 * OK, there's real work to be done. Luckily, there's			 * a substantial literature on what to do in this			 * case. In particular, Porter and Duff have done a			 * taxonomy of compositing rules, and the right one is			 * the "Source Over" rule. This code implements that.			 */			destPtr[0] = PD_SRC_OVER(srcPtr[0], alpha, destPtr[0],				Alpha);			destPtr[1] = PD_SRC_OVER(srcPtr[greenOffset], alpha,				destPtr[1], Alpha);			destPtr[2] = PD_SRC_OVER(srcPtr[blueOffset], alpha,				destPtr[2], Alpha);			destPtr[3] = PD_SRC_OVER_ALPHA(alpha, Alpha);		    }		    destPtr += 4;		}	    }	    srcLinePtr += blockPtr->pitch;	    destLinePtr += pitch;	}    }
hLeft = height;
hLeft = height
hLeft
hLeft
height
height
hLeft > 0
hLeft
hLeft
0
{	int pixelSize = blockPtr->pixelSize;	int compRuleSet = (compRule == TK_PHOTO_COMPOSITE_SET);	srcLinePtr = blockPtr->pixelPtr + blockPtr->offset[0];	hCopy = MIN(hLeft, blockPtr->height);	hLeft -= hCopy;	for (; hCopy > 0; --hCopy) {	    /*	     * If the layout of the source line matches our memory layout and	     * we're setting, we can just copy the bytes directly, which is	     * much faster.	     */	    if ((pixelSize == 4) && (greenOffset == 1)		    && (blueOffset == 2) && (alphaOffset == 3)		    && (width <= blockPtr->width)		    && compRuleSet) {		memcpy(destLinePtr, srcLinePtr, ((size_t) width * 4));		srcLinePtr += blockPtr->pitch;		destLinePtr += pitch;		continue;	    }	    /*	     * Have to copy the slow way.	     */	    destPtr = destLinePtr;	    for (wLeft = width; wLeft > 0;) {		wCopy = MIN(wLeft, blockPtr->width);		wLeft -= wCopy;		srcPtr = srcLinePtr;		/*		 * But we might be lucky and be able to use fairly fast loops.		 * It's worth checking...		 */		if (alphaOffset == 0) {		    /*		     * This is the non-alpha case, so can still be fairly		     * fast. Note that in the non-alpha-source case, the		     * compositing rule doesn't apply.		     */		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = 255;		    }		    continue;		} else if (compRuleSet) {		    /*		     * This is the SET compositing rule, which just replaces		     * what was there before with the new data. This is		     * another fairly fast case. No point in doing a memcpy();		     * the order of channels is probably wrong.		     */		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = srcPtr[alphaOffset];		    }		    continue;		}		/*		 * Bother; need to consider the alpha value of each pixel to		 * know what to do.		 */		for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {		    int alpha = srcPtr[alphaOffset];		    if (alpha == 255 || !destPtr[3]) {			/*			 * Either the source is 100% opaque, or the			 * destination is entirely blank. In all cases, we			 * just set the destination to the source.			 */			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = alpha;			continue;		    }		    /*		     * Can still skip doing work if the source is 100%		     * transparent at this point.		     */		    if (alpha) {			int Alpha = destPtr[3];			/*			 * OK, there's real work to be done. Luckily, there's			 * a substantial literature on what to do in this			 * case. In particular, Porter and Duff have done a			 * taxonomy of compositing rules, and the right one is			 * the "Source Over" rule. This code implements that.			 */			destPtr[0] = PD_SRC_OVER(srcPtr[0], alpha, destPtr[0],				Alpha);			destPtr[1] = PD_SRC_OVER(srcPtr[greenOffset], alpha,				destPtr[1], Alpha);			destPtr[2] = PD_SRC_OVER(srcPtr[blueOffset], alpha,				destPtr[2], Alpha);			destPtr[3] = PD_SRC_OVER_ALPHA(alpha, Alpha);		    }		    destPtr += 4;		}	    }	    srcLinePtr += blockPtr->pitch;	    destLinePtr += pitch;	}    }
int pixelSize = blockPtr->pixelSize;
int pixelSize = blockPtr->pixelSize;
int
pixelSize = blockPtr->pixelSize
pixelSize
= blockPtr->pixelSize
blockPtr->pixelSize
blockPtr
blockPtr
pixelSize
int compRuleSet = (compRule == TK_PHOTO_COMPOSITE_SET);
int compRuleSet = (compRule == TK_PHOTO_COMPOSITE_SET);
int
compRuleSet = (compRule == TK_PHOTO_COMPOSITE_SET)
compRuleSet
= (compRule == TK_PHOTO_COMPOSITE_SET)
(compRule == TK_PHOTO_COMPOSITE_SET)
compRule == TK_PHOTO_COMPOSITE_SET
compRule
compRule
TK_PHOTO_COMPOSITE_SET
TK_PHOTO_COMPOSITE_SET
srcLinePtr = blockPtr->pixelPtr + blockPtr->offset[0];
srcLinePtr = blockPtr->pixelPtr + blockPtr->offset[0]
srcLinePtr
srcLinePtr
blockPtr->pixelPtr + blockPtr->offset[0]
blockPtr->pixelPtr
blockPtr
blockPtr
pixelPtr
blockPtr->offset[0]
blockPtr->offset
blockPtr
blockPtr
offset
0
hCopy = MIN(hLeft, blockPtr->height);
hCopy = MIN(hLeft, blockPtr->height)
hCopy
hCopy
MIN(hLeft, blockPtr->height)
MIN
MIN
hLeft
hLeft
blockPtr->height
blockPtr
blockPtr
height
hLeft -= hCopy;
hLeft -= hCopy
hLeft
hLeft
hCopy
hCopy
for (; hCopy > 0; --hCopy) {	    /*	     * If the layout of the source line matches our memory layout and	     * we're setting, we can just copy the bytes directly, which is	     * much faster.	     */	    if ((pixelSize == 4) && (greenOffset == 1)		    && (blueOffset == 2) && (alphaOffset == 3)		    && (width <= blockPtr->width)		    && compRuleSet) {		memcpy(destLinePtr, srcLinePtr, ((size_t) width * 4));		srcLinePtr += blockPtr->pitch;		destLinePtr += pitch;		continue;	    }	    /*	     * Have to copy the slow way.	     */	    destPtr = destLinePtr;	    for (wLeft = width; wLeft > 0;) {		wCopy = MIN(wLeft, blockPtr->width);		wLeft -= wCopy;		srcPtr = srcLinePtr;		/*		 * But we might be lucky and be able to use fairly fast loops.		 * It's worth checking...		 */		if (alphaOffset == 0) {		    /*		     * This is the non-alpha case, so can still be fairly		     * fast. Note that in the non-alpha-source case, the		     * compositing rule doesn't apply.		     */		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = 255;		    }		    continue;		} else if (compRuleSet) {		    /*		     * This is the SET compositing rule, which just replaces		     * what was there before with the new data. This is		     * another fairly fast case. No point in doing a memcpy();		     * the order of channels is probably wrong.		     */		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = srcPtr[alphaOffset];		    }		    continue;		}		/*		 * Bother; need to consider the alpha value of each pixel to		 * know what to do.		 */		for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {		    int alpha = srcPtr[alphaOffset];		    if (alpha == 255 || !destPtr[3]) {			/*			 * Either the source is 100% opaque, or the			 * destination is entirely blank. In all cases, we			 * just set the destination to the source.			 */			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = alpha;			continue;		    }		    /*		     * Can still skip doing work if the source is 100%		     * transparent at this point.		     */		    if (alpha) {			int Alpha = destPtr[3];			/*			 * OK, there's real work to be done. Luckily, there's			 * a substantial literature on what to do in this			 * case. In particular, Porter and Duff have done a			 * taxonomy of compositing rules, and the right one is			 * the "Source Over" rule. This code implements that.			 */			destPtr[0] = PD_SRC_OVER(srcPtr[0], alpha, destPtr[0],				Alpha);			destPtr[1] = PD_SRC_OVER(srcPtr[greenOffset], alpha,				destPtr[1], Alpha);			destPtr[2] = PD_SRC_OVER(srcPtr[blueOffset], alpha,				destPtr[2], Alpha);			destPtr[3] = PD_SRC_OVER_ALPHA(alpha, Alpha);		    }		    destPtr += 4;		}	    }	    srcLinePtr += blockPtr->pitch;	    destLinePtr += pitch;	}
;
hCopy > 0
hCopy
hCopy
0
--hCopy
hCopy
hCopy
{	    /*	     * If the layout of the source line matches our memory layout and	     * we're setting, we can just copy the bytes directly, which is	     * much faster.	     */	    if ((pixelSize == 4) && (greenOffset == 1)		    && (blueOffset == 2) && (alphaOffset == 3)		    && (width <= blockPtr->width)		    && compRuleSet) {		memcpy(destLinePtr, srcLinePtr, ((size_t) width * 4));		srcLinePtr += blockPtr->pitch;		destLinePtr += pitch;		continue;	    }	    /*	     * Have to copy the slow way.	     */	    destPtr = destLinePtr;	    for (wLeft = width; wLeft > 0;) {		wCopy = MIN(wLeft, blockPtr->width);		wLeft -= wCopy;		srcPtr = srcLinePtr;		/*		 * But we might be lucky and be able to use fairly fast loops.		 * It's worth checking...		 */		if (alphaOffset == 0) {		    /*		     * This is the non-alpha case, so can still be fairly		     * fast. Note that in the non-alpha-source case, the		     * compositing rule doesn't apply.		     */		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = 255;		    }		    continue;		} else if (compRuleSet) {		    /*		     * This is the SET compositing rule, which just replaces		     * what was there before with the new data. This is		     * another fairly fast case. No point in doing a memcpy();		     * the order of channels is probably wrong.		     */		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = srcPtr[alphaOffset];		    }		    continue;		}		/*		 * Bother; need to consider the alpha value of each pixel to		 * know what to do.		 */		for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {		    int alpha = srcPtr[alphaOffset];		    if (alpha == 255 || !destPtr[3]) {			/*			 * Either the source is 100% opaque, or the			 * destination is entirely blank. In all cases, we			 * just set the destination to the source.			 */			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = alpha;			continue;		    }		    /*		     * Can still skip doing work if the source is 100%		     * transparent at this point.		     */		    if (alpha) {			int Alpha = destPtr[3];			/*			 * OK, there's real work to be done. Luckily, there's			 * a substantial literature on what to do in this			 * case. In particular, Porter and Duff have done a			 * taxonomy of compositing rules, and the right one is			 * the "Source Over" rule. This code implements that.			 */			destPtr[0] = PD_SRC_OVER(srcPtr[0], alpha, destPtr[0],				Alpha);			destPtr[1] = PD_SRC_OVER(srcPtr[greenOffset], alpha,				destPtr[1], Alpha);			destPtr[2] = PD_SRC_OVER(srcPtr[blueOffset], alpha,				destPtr[2], Alpha);			destPtr[3] = PD_SRC_OVER_ALPHA(alpha, Alpha);		    }		    destPtr += 4;		}	    }	    srcLinePtr += blockPtr->pitch;	    destLinePtr += pitch;	}
if ((pixelSize == 4) && (greenOffset == 1)		    && (blueOffset == 2) && (alphaOffset == 3)		    && (width <= blockPtr->width)		    && compRuleSet) {		memcpy(destLinePtr, srcLinePtr, ((size_t) width * 4));		srcLinePtr += blockPtr->pitch;		destLinePtr += pitch;		continue;	    }
(pixelSize == 4) && (greenOffset == 1)		    && (blueOffset == 2) && (alphaOffset == 3)		    && (width <= blockPtr->width)		    && compRuleSet
(pixelSize == 4) && (greenOffset == 1)		    && (blueOffset == 2) && (alphaOffset == 3)		    && (width <= blockPtr->width)
(pixelSize == 4) && (greenOffset == 1)		    && (blueOffset == 2) && (alphaOffset == 3)
(pixelSize == 4) && (greenOffset == 1)		    && (blueOffset == 2)
(pixelSize == 4) && (greenOffset == 1)
(pixelSize == 4)
pixelSize == 4
pixelSize
pixelSize
4
(greenOffset == 1)
greenOffset == 1
greenOffset
greenOffset
1
(blueOffset == 2)
blueOffset == 2
blueOffset
blueOffset
2
(alphaOffset == 3)
alphaOffset == 3
alphaOffset
alphaOffset
3
(width <= blockPtr->width)
width <= blockPtr->width
width
width
blockPtr->width
blockPtr
blockPtr
width
compRuleSet
compRuleSet
{		memcpy(destLinePtr, srcLinePtr, ((size_t) width * 4));		srcLinePtr += blockPtr->pitch;		destLinePtr += pitch;		continue;	    }
memcpy(destLinePtr, srcLinePtr, ((size_t) width * 4));
memcpy(destLinePtr, srcLinePtr, ((size_t) width * 4))
memcpy
memcpy
destLinePtr
destLinePtr
srcLinePtr
srcLinePtr
((size_t) width * 4)
(size_t) width * 4
(size_t) width
size_t
size_t
size_t

width
width
4
srcLinePtr += blockPtr->pitch;
srcLinePtr += blockPtr->pitch
srcLinePtr
srcLinePtr
blockPtr->pitch
blockPtr
blockPtr
pitch
destLinePtr += pitch;
destLinePtr += pitch
destLinePtr
destLinePtr
pitch
pitch
continue;
destPtr = destLinePtr;
destPtr = destLinePtr
destPtr
destPtr
destLinePtr
destLinePtr
for (wLeft = width; wLeft > 0;) {		wCopy = MIN(wLeft, blockPtr->width);		wLeft -= wCopy;		srcPtr = srcLinePtr;		/*		 * But we might be lucky and be able to use fairly fast loops.		 * It's worth checking...		 */		if (alphaOffset == 0) {		    /*		     * This is the non-alpha case, so can still be fairly		     * fast. Note that in the non-alpha-source case, the		     * compositing rule doesn't apply.		     */		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = 255;		    }		    continue;		} else if (compRuleSet) {		    /*		     * This is the SET compositing rule, which just replaces		     * what was there before with the new data. This is		     * another fairly fast case. No point in doing a memcpy();		     * the order of channels is probably wrong.		     */		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = srcPtr[alphaOffset];		    }		    continue;		}		/*		 * Bother; need to consider the alpha value of each pixel to		 * know what to do.		 */		for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {		    int alpha = srcPtr[alphaOffset];		    if (alpha == 255 || !destPtr[3]) {			/*			 * Either the source is 100% opaque, or the			 * destination is entirely blank. In all cases, we			 * just set the destination to the source.			 */			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = alpha;			continue;		    }		    /*		     * Can still skip doing work if the source is 100%		     * transparent at this point.		     */		    if (alpha) {			int Alpha = destPtr[3];			/*			 * OK, there's real work to be done. Luckily, there's			 * a substantial literature on what to do in this			 * case. In particular, Porter and Duff have done a			 * taxonomy of compositing rules, and the right one is			 * the "Source Over" rule. This code implements that.			 */			destPtr[0] = PD_SRC_OVER(srcPtr[0], alpha, destPtr[0],				Alpha);			destPtr[1] = PD_SRC_OVER(srcPtr[greenOffset], alpha,				destPtr[1], Alpha);			destPtr[2] = PD_SRC_OVER(srcPtr[blueOffset], alpha,				destPtr[2], Alpha);			destPtr[3] = PD_SRC_OVER_ALPHA(alpha, Alpha);		    }		    destPtr += 4;		}	    }
wLeft = width;
wLeft = width
wLeft
wLeft
width
width
wLeft > 0
wLeft
wLeft
0
{		wCopy = MIN(wLeft, blockPtr->width);		wLeft -= wCopy;		srcPtr = srcLinePtr;		/*		 * But we might be lucky and be able to use fairly fast loops.		 * It's worth checking...		 */		if (alphaOffset == 0) {		    /*		     * This is the non-alpha case, so can still be fairly		     * fast. Note that in the non-alpha-source case, the		     * compositing rule doesn't apply.		     */		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = 255;		    }		    continue;		} else if (compRuleSet) {		    /*		     * This is the SET compositing rule, which just replaces		     * what was there before with the new data. This is		     * another fairly fast case. No point in doing a memcpy();		     * the order of channels is probably wrong.		     */		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = srcPtr[alphaOffset];		    }		    continue;		}		/*		 * Bother; need to consider the alpha value of each pixel to		 * know what to do.		 */		for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {		    int alpha = srcPtr[alphaOffset];		    if (alpha == 255 || !destPtr[3]) {			/*			 * Either the source is 100% opaque, or the			 * destination is entirely blank. In all cases, we			 * just set the destination to the source.			 */			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = alpha;			continue;		    }		    /*		     * Can still skip doing work if the source is 100%		     * transparent at this point.		     */		    if (alpha) {			int Alpha = destPtr[3];			/*			 * OK, there's real work to be done. Luckily, there's			 * a substantial literature on what to do in this			 * case. In particular, Porter and Duff have done a			 * taxonomy of compositing rules, and the right one is			 * the "Source Over" rule. This code implements that.			 */			destPtr[0] = PD_SRC_OVER(srcPtr[0], alpha, destPtr[0],				Alpha);			destPtr[1] = PD_SRC_OVER(srcPtr[greenOffset], alpha,				destPtr[1], Alpha);			destPtr[2] = PD_SRC_OVER(srcPtr[blueOffset], alpha,				destPtr[2], Alpha);			destPtr[3] = PD_SRC_OVER_ALPHA(alpha, Alpha);		    }		    destPtr += 4;		}	    }
wCopy = MIN(wLeft, blockPtr->width);
wCopy = MIN(wLeft, blockPtr->width)
wCopy
wCopy
MIN(wLeft, blockPtr->width)
MIN
MIN
wLeft
wLeft
blockPtr->width
blockPtr
blockPtr
width
wLeft -= wCopy;
wLeft -= wCopy
wLeft
wLeft
wCopy
wCopy
srcPtr = srcLinePtr;
srcPtr = srcLinePtr
srcPtr
srcPtr
srcLinePtr
srcLinePtr
if (alphaOffset == 0) {		    /*		     * This is the non-alpha case, so can still be fairly		     * fast. Note that in the non-alpha-source case, the		     * compositing rule doesn't apply.		     */		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = 255;		    }		    continue;		} else if (compRuleSet) {		    /*		     * This is the SET compositing rule, which just replaces		     * what was there before with the new data. This is		     * another fairly fast case. No point in doing a memcpy();		     * the order of channels is probably wrong.		     */		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = srcPtr[alphaOffset];		    }		    continue;		}
alphaOffset == 0
alphaOffset
alphaOffset
0
{		    /*		     * This is the non-alpha case, so can still be fairly		     * fast. Note that in the non-alpha-source case, the		     * compositing rule doesn't apply.		     */		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = 255;		    }		    continue;		}
for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = 255;		    }
;
wCopy>0
wCopy
wCopy
0
--wCopy, srcPtr+=pixelSize
--wCopy
wCopy
wCopy
srcPtr+=pixelSize
srcPtr
srcPtr
pixelSize
pixelSize
{			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = 255;		    }
*destPtr++ = srcPtr[0];
*destPtr++ = srcPtr[0]
*destPtr++
destPtr++
destPtr
destPtr
srcPtr[0]
srcPtr
srcPtr
0
*destPtr++ = srcPtr[greenOffset];
*destPtr++ = srcPtr[greenOffset]
*destPtr++
destPtr++
destPtr
destPtr
srcPtr[greenOffset]
srcPtr
srcPtr
greenOffset
greenOffset
*destPtr++ = srcPtr[blueOffset];
*destPtr++ = srcPtr[blueOffset]
*destPtr++
destPtr++
destPtr
destPtr
srcPtr[blueOffset]
srcPtr
srcPtr
blueOffset
blueOffset
*destPtr++ = 255;
*destPtr++ = 255
*destPtr++
destPtr++
destPtr
destPtr
255
continue;
if (compRuleSet) {		    /*		     * This is the SET compositing rule, which just replaces		     * what was there before with the new data. This is		     * another fairly fast case. No point in doing a memcpy();		     * the order of channels is probably wrong.		     */		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = srcPtr[alphaOffset];		    }		    continue;		}
compRuleSet
compRuleSet
{		    /*		     * This is the SET compositing rule, which just replaces		     * what was there before with the new data. This is		     * another fairly fast case. No point in doing a memcpy();		     * the order of channels is probably wrong.		     */		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = srcPtr[alphaOffset];		    }		    continue;		}
for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = srcPtr[alphaOffset];		    }
;
wCopy>0
wCopy
wCopy
0
--wCopy, srcPtr+=pixelSize
--wCopy
wCopy
wCopy
srcPtr+=pixelSize
srcPtr
srcPtr
pixelSize
pixelSize
{			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = srcPtr[alphaOffset];		    }
*destPtr++ = srcPtr[0];
*destPtr++ = srcPtr[0]
*destPtr++
destPtr++
destPtr
destPtr
srcPtr[0]
srcPtr
srcPtr
0
*destPtr++ = srcPtr[greenOffset];
*destPtr++ = srcPtr[greenOffset]
*destPtr++
destPtr++
destPtr
destPtr
srcPtr[greenOffset]
srcPtr
srcPtr
greenOffset
greenOffset
*destPtr++ = srcPtr[blueOffset];
*destPtr++ = srcPtr[blueOffset]
*destPtr++
destPtr++
destPtr
destPtr
srcPtr[blueOffset]
srcPtr
srcPtr
blueOffset
blueOffset
*destPtr++ = srcPtr[alphaOffset];
*destPtr++ = srcPtr[alphaOffset]
*destPtr++
destPtr++
destPtr
destPtr
srcPtr[alphaOffset]
srcPtr
srcPtr
alphaOffset
alphaOffset
continue;
for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {		    int alpha = srcPtr[alphaOffset];		    if (alpha == 255 || !destPtr[3]) {			/*			 * Either the source is 100% opaque, or the			 * destination is entirely blank. In all cases, we			 * just set the destination to the source.			 */			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = alpha;			continue;		    }		    /*		     * Can still skip doing work if the source is 100%		     * transparent at this point.		     */		    if (alpha) {			int Alpha = destPtr[3];			/*			 * OK, there's real work to be done. Luckily, there's			 * a substantial literature on what to do in this			 * case. In particular, Porter and Duff have done a			 * taxonomy of compositing rules, and the right one is			 * the "Source Over" rule. This code implements that.			 */			destPtr[0] = PD_SRC_OVER(srcPtr[0], alpha, destPtr[0],				Alpha);			destPtr[1] = PD_SRC_OVER(srcPtr[greenOffset], alpha,				destPtr[1], Alpha);			destPtr[2] = PD_SRC_OVER(srcPtr[blueOffset], alpha,				destPtr[2], Alpha);			destPtr[3] = PD_SRC_OVER_ALPHA(alpha, Alpha);		    }		    destPtr += 4;		}
;
wCopy>0
wCopy
wCopy
0
--wCopy, srcPtr+=pixelSize
--wCopy
wCopy
wCopy
srcPtr+=pixelSize
srcPtr
srcPtr
pixelSize
pixelSize
{		    int alpha = srcPtr[alphaOffset];		    if (alpha == 255 || !destPtr[3]) {			/*			 * Either the source is 100% opaque, or the			 * destination is entirely blank. In all cases, we			 * just set the destination to the source.			 */			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = alpha;			continue;		    }		    /*		     * Can still skip doing work if the source is 100%		     * transparent at this point.		     */		    if (alpha) {			int Alpha = destPtr[3];			/*			 * OK, there's real work to be done. Luckily, there's			 * a substantial literature on what to do in this			 * case. In particular, Porter and Duff have done a			 * taxonomy of compositing rules, and the right one is			 * the "Source Over" rule. This code implements that.			 */			destPtr[0] = PD_SRC_OVER(srcPtr[0], alpha, destPtr[0],				Alpha);			destPtr[1] = PD_SRC_OVER(srcPtr[greenOffset], alpha,				destPtr[1], Alpha);			destPtr[2] = PD_SRC_OVER(srcPtr[blueOffset], alpha,				destPtr[2], Alpha);			destPtr[3] = PD_SRC_OVER_ALPHA(alpha, Alpha);		    }		    destPtr += 4;		}
int alpha = srcPtr[alphaOffset];
int alpha = srcPtr[alphaOffset];
int
alpha = srcPtr[alphaOffset]
alpha
= srcPtr[alphaOffset]
srcPtr[alphaOffset]
srcPtr
srcPtr
alphaOffset
alphaOffset
if (alpha == 255 || !destPtr[3]) {			/*			 * Either the source is 100% opaque, or the			 * destination is entirely blank. In all cases, we			 * just set the destination to the source.			 */			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = alpha;			continue;		    }
alpha == 255 || !destPtr[3]
alpha == 255
alpha
alpha
255
!destPtr[3]
destPtr[3]
destPtr
destPtr
3
{			/*			 * Either the source is 100% opaque, or the			 * destination is entirely blank. In all cases, we			 * just set the destination to the source.			 */			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = alpha;			continue;		    }
*destPtr++ = srcPtr[0];
*destPtr++ = srcPtr[0]
*destPtr++
destPtr++
destPtr
destPtr
srcPtr[0]
srcPtr
srcPtr
0
*destPtr++ = srcPtr[greenOffset];
*destPtr++ = srcPtr[greenOffset]
*destPtr++
destPtr++
destPtr
destPtr
srcPtr[greenOffset]
srcPtr
srcPtr
greenOffset
greenOffset
*destPtr++ = srcPtr[blueOffset];
*destPtr++ = srcPtr[blueOffset]
*destPtr++
destPtr++
destPtr
destPtr
srcPtr[blueOffset]
srcPtr
srcPtr
blueOffset
blueOffset
*destPtr++ = alpha;
*destPtr++ = alpha
*destPtr++
destPtr++
destPtr
destPtr
alpha
alpha
continue;
if (alpha) {			int Alpha = destPtr[3];			/*			 * OK, there's real work to be done. Luckily, there's			 * a substantial literature on what to do in this			 * case. In particular, Porter and Duff have done a			 * taxonomy of compositing rules, and the right one is			 * the "Source Over" rule. This code implements that.			 */			destPtr[0] = PD_SRC_OVER(srcPtr[0], alpha, destPtr[0],				Alpha);			destPtr[1] = PD_SRC_OVER(srcPtr[greenOffset], alpha,				destPtr[1], Alpha);			destPtr[2] = PD_SRC_OVER(srcPtr[blueOffset], alpha,				destPtr[2], Alpha);			destPtr[3] = PD_SRC_OVER_ALPHA(alpha, Alpha);		    }
alpha
alpha
{			int Alpha = destPtr[3];			/*			 * OK, there's real work to be done. Luckily, there's			 * a substantial literature on what to do in this			 * case. In particular, Porter and Duff have done a			 * taxonomy of compositing rules, and the right one is			 * the "Source Over" rule. This code implements that.			 */			destPtr[0] = PD_SRC_OVER(srcPtr[0], alpha, destPtr[0],				Alpha);			destPtr[1] = PD_SRC_OVER(srcPtr[greenOffset], alpha,				destPtr[1], Alpha);			destPtr[2] = PD_SRC_OVER(srcPtr[blueOffset], alpha,				destPtr[2], Alpha);			destPtr[3] = PD_SRC_OVER_ALPHA(alpha, Alpha);		    }
int Alpha = destPtr[3];
int Alpha = destPtr[3];
int
Alpha = destPtr[3]
Alpha
= destPtr[3]
destPtr[3]
destPtr
destPtr
3
destPtr[0] = PD_SRC_OVER(srcPtr[0], alpha, destPtr[0],				Alpha);
destPtr[0] = PD_SRC_OVER(srcPtr[0], alpha, destPtr[0],				Alpha)
destPtr[0]
destPtr
destPtr
0
PD_SRC_OVER(srcPtr[0], alpha, destPtr[0],				Alpha)
PD_SRC_OVER
PD_SRC_OVER
srcPtr[0]
srcPtr
srcPtr
0
alpha
alpha
destPtr[0]
destPtr
destPtr
0
Alpha
Alpha
destPtr[1] = PD_SRC_OVER(srcPtr[greenOffset], alpha,				destPtr[1], Alpha);
destPtr[1] = PD_SRC_OVER(srcPtr[greenOffset], alpha,				destPtr[1], Alpha)
destPtr[1]
destPtr
destPtr
1
PD_SRC_OVER(srcPtr[greenOffset], alpha,				destPtr[1], Alpha)
PD_SRC_OVER
PD_SRC_OVER
srcPtr[greenOffset]
srcPtr
srcPtr
greenOffset
greenOffset
alpha
alpha
destPtr[1]
destPtr
destPtr
1
Alpha
Alpha
destPtr[2] = PD_SRC_OVER(srcPtr[blueOffset], alpha,				destPtr[2], Alpha);
destPtr[2] = PD_SRC_OVER(srcPtr[blueOffset], alpha,				destPtr[2], Alpha)
destPtr[2]
destPtr
destPtr
2
PD_SRC_OVER(srcPtr[blueOffset], alpha,				destPtr[2], Alpha)
PD_SRC_OVER
PD_SRC_OVER
srcPtr[blueOffset]
srcPtr
srcPtr
blueOffset
blueOffset
alpha
alpha
destPtr[2]
destPtr
destPtr
2
Alpha
Alpha
destPtr[3] = PD_SRC_OVER_ALPHA(alpha, Alpha);
destPtr[3] = PD_SRC_OVER_ALPHA(alpha, Alpha)
destPtr[3]
destPtr
destPtr
3
PD_SRC_OVER_ALPHA(alpha, Alpha)
PD_SRC_OVER_ALPHA
PD_SRC_OVER_ALPHA
alpha
alpha
Alpha
Alpha
destPtr += 4;
destPtr += 4
destPtr
destPtr
4
srcLinePtr += blockPtr->pitch;
srcLinePtr += blockPtr->pitch
srcLinePtr
srcLinePtr
blockPtr->pitch
blockPtr
blockPtr
pitch
destLinePtr += pitch;
destLinePtr += pitch
destLinePtr
destLinePtr
pitch
pitch
if (alphaOffset) {	/*	 * This block is grossly inefficient. For each row in the image, it	 * finds each continguous string of nontransparent pixels, then marks	 * those areas as valid in the validRegion mask. This makes drawing	 * very efficient, because of the way we use X: we just say, here's	 * your mask, and here's your data. We need not worry about the	 * current background color, etc. But this costs us a lot on the image	 * setup. Still, image setup only happens once, whereas the drawing	 * happens many times, so this might be the best way to go.	 *	 * An alternative might be to not set up this mask, and instead, at	 * drawing time, for each transparent pixel, set its color to the	 * color of the background behind that pixel. This is what I suspect	 * most of programs do. However, they don't have to deal with the	 * canvas, which could have many different background colors.	 * Determining the correct bg color for a given pixel might be	 * expensive.	 */	if (compRule != TK_PHOTO_COMPOSITE_OVERLAY) {	    TkRegion workRgn;	    /*	     * Don't need this when using the OVERLAY compositing rule, which	     * always strictly increases the valid region.	     */	recalculateValidRegion:	    workRgn = TkCreateRegion();	    rect.x = x;	    rect.y = y;	    rect.width = width;	    rect.height = height;	    TkUnionRectWithRegion(&rect, workRgn, workRgn);	    TkSubtractRegion(masterPtr->validRegion, workRgn,		    masterPtr->validRegion);	    TkDestroyRegion(workRgn);	}	/*	 * Factorize out the main part of the building of the region data to	 * allow for more efficient per-platform implementations. [Bug 919066]	 */	TkpBuildRegionFromAlphaData(masterPtr->validRegion, (unsigned) x,		(unsigned) y, (unsigned) width, (unsigned) height,		masterPtr->pix32 + (y * masterPtr->width + x) * 4 + 3,		4, (unsigned) masterPtr->width * 4);    } else {	rect.x = x;	rect.y = y;	rect.width = width;	rect.height = height;	TkUnionRectWithRegion(&rect, masterPtr->validRegion,		masterPtr->validRegion);    }
alphaOffset
alphaOffset
{	/*	 * This block is grossly inefficient. For each row in the image, it	 * finds each continguous string of nontransparent pixels, then marks	 * those areas as valid in the validRegion mask. This makes drawing	 * very efficient, because of the way we use X: we just say, here's	 * your mask, and here's your data. We need not worry about the	 * current background color, etc. But this costs us a lot on the image	 * setup. Still, image setup only happens once, whereas the drawing	 * happens many times, so this might be the best way to go.	 *	 * An alternative might be to not set up this mask, and instead, at	 * drawing time, for each transparent pixel, set its color to the	 * color of the background behind that pixel. This is what I suspect	 * most of programs do. However, they don't have to deal with the	 * canvas, which could have many different background colors.	 * Determining the correct bg color for a given pixel might be	 * expensive.	 */	if (compRule != TK_PHOTO_COMPOSITE_OVERLAY) {	    TkRegion workRgn;	    /*	     * Don't need this when using the OVERLAY compositing rule, which	     * always strictly increases the valid region.	     */	recalculateValidRegion:	    workRgn = TkCreateRegion();	    rect.x = x;	    rect.y = y;	    rect.width = width;	    rect.height = height;	    TkUnionRectWithRegion(&rect, workRgn, workRgn);	    TkSubtractRegion(masterPtr->validRegion, workRgn,		    masterPtr->validRegion);	    TkDestroyRegion(workRgn);	}	/*	 * Factorize out the main part of the building of the region data to	 * allow for more efficient per-platform implementations. [Bug 919066]	 */	TkpBuildRegionFromAlphaData(masterPtr->validRegion, (unsigned) x,		(unsigned) y, (unsigned) width, (unsigned) height,		masterPtr->pix32 + (y * masterPtr->width + x) * 4 + 3,		4, (unsigned) masterPtr->width * 4);    }
if (compRule != TK_PHOTO_COMPOSITE_OVERLAY) {	    TkRegion workRgn;	    /*	     * Don't need this when using the OVERLAY compositing rule, which	     * always strictly increases the valid region.	     */	recalculateValidRegion:	    workRgn = TkCreateRegion();	    rect.x = x;	    rect.y = y;	    rect.width = width;	    rect.height = height;	    TkUnionRectWithRegion(&rect, workRgn, workRgn);	    TkSubtractRegion(masterPtr->validRegion, workRgn,		    masterPtr->validRegion);	    TkDestroyRegion(workRgn);	}
compRule != TK_PHOTO_COMPOSITE_OVERLAY
compRule
compRule
TK_PHOTO_COMPOSITE_OVERLAY
TK_PHOTO_COMPOSITE_OVERLAY
{	    TkRegion workRgn;	    /*	     * Don't need this when using the OVERLAY compositing rule, which	     * always strictly increases the valid region.	     */	recalculateValidRegion:	    workRgn = TkCreateRegion();	    rect.x = x;	    rect.y = y;	    rect.width = width;	    rect.height = height;	    TkUnionRectWithRegion(&rect, workRgn, workRgn);	    TkSubtractRegion(masterPtr->validRegion, workRgn,		    masterPtr->validRegion);	    TkDestroyRegion(workRgn);	}
TkRegion workRgn;
TkRegion workRgn;
TkRegion
TkRegion
workRgn
workRgn
recalculateValidRegion:	    workRgn = TkCreateRegion();
recalculateValidRegion
workRgn = TkCreateRegion();
workRgn = TkCreateRegion()
workRgn
workRgn
TkCreateRegion()
TkCreateRegion
TkCreateRegion
rect.x = x;
rect.x = x
rect.x
rect
rect
x
x
x
rect.y = y;
rect.y = y
rect.y
rect
rect
y
y
y
rect.width = width;
rect.width = width
rect.width
rect
rect
width
width
width
rect.height = height;
rect.height = height
rect.height
rect
rect
height
height
height
TkUnionRectWithRegion(&rect, workRgn, workRgn);
TkUnionRectWithRegion(&rect, workRgn, workRgn)
TkUnionRectWithRegion
TkUnionRectWithRegion
&rect
rect
rect
workRgn
workRgn
workRgn
workRgn
TkSubtractRegion(masterPtr->validRegion, workRgn,		    masterPtr->validRegion);
TkSubtractRegion(masterPtr->validRegion, workRgn,		    masterPtr->validRegion)
TkSubtractRegion
TkSubtractRegion
masterPtr->validRegion
masterPtr
masterPtr
validRegion
workRgn
workRgn
masterPtr->validRegion
masterPtr
masterPtr
validRegion
TkDestroyRegion(workRgn);
TkDestroyRegion(workRgn)
TkDestroyRegion
TkDestroyRegion
workRgn
workRgn
TkpBuildRegionFromAlphaData(masterPtr->validRegion, (unsigned) x,		(unsigned) y, (unsigned) width, (unsigned) height,		masterPtr->pix32 + (y * masterPtr->width + x) * 4 + 3,		4, (unsigned) masterPtr->width * 4);
TkpBuildRegionFromAlphaData(masterPtr->validRegion, (unsigned) x,		(unsigned) y, (unsigned) width, (unsigned) height,		masterPtr->pix32 + (y * masterPtr->width + x) * 4 + 3,		4, (unsigned) masterPtr->width * 4)
TkpBuildRegionFromAlphaData
TkpBuildRegionFromAlphaData
masterPtr->validRegion
masterPtr
masterPtr
validRegion
(unsigned) x
unsigned
unsigned

x
x
(unsigned) y
unsigned
unsigned

y
y
(unsigned) width
unsigned
unsigned

width
width
(unsigned) height
unsigned
unsigned

height
height
masterPtr->pix32 + (y * masterPtr->width + x) * 4 + 3
masterPtr->pix32 + (y * masterPtr->width + x) * 4
masterPtr->pix32
masterPtr
masterPtr
pix32
(y * masterPtr->width + x) * 4
(y * masterPtr->width + x)
y * masterPtr->width + x
y * masterPtr->width
y
y
masterPtr->width
masterPtr
masterPtr
width
x
x
4
3
4
(unsigned) masterPtr->width * 4
(unsigned) masterPtr->width
unsigned
unsigned

masterPtr->width
masterPtr
masterPtr
width
4
{	rect.x = x;	rect.y = y;	rect.width = width;	rect.height = height;	TkUnionRectWithRegion(&rect, masterPtr->validRegion,		masterPtr->validRegion);    }
rect.x = x;
rect.x = x
rect.x
rect
rect
x
x
x
rect.y = y;
rect.y = y
rect.y
rect
rect
y
y
y
rect.width = width;
rect.width = width
rect.width
rect
rect
width
width
width
rect.height = height;
rect.height = height
rect.height
rect
rect
height
height
height
TkUnionRectWithRegion(&rect, masterPtr->validRegion,		masterPtr->validRegion);
TkUnionRectWithRegion(&rect, masterPtr->validRegion,		masterPtr->validRegion)
TkUnionRectWithRegion
TkUnionRectWithRegion
&rect
rect
rect
masterPtr->validRegion
masterPtr
masterPtr
validRegion
masterPtr->validRegion
masterPtr
masterPtr
validRegion
if (!sourceIsSimplePhoto && (width == 1) && (height == 1)) {	/*	 * Optimize the single pixel case if we can. This speeds up code that	 * builds up large simple-alpha images by single pixels.  We don't	 * negate COMPLEX_ALPHA in this case. [Bug 1409140]	 */	if (!(masterPtr->flags & COMPLEX_ALPHA)) {	    unsigned char newAlpha;	    destLinePtr = masterPtr->pix32 + (y * masterPtr->width + x) * 4;	    newAlpha = destLinePtr[3];	    if (newAlpha && newAlpha != 255) {		masterPtr->flags |= COMPLEX_ALPHA;	    }	}    } else if ((alphaOffset != 0) || (masterPtr->flags & COMPLEX_ALPHA)) {	/*	 * Check for partial transparency if alpha pixels are specified, or	 * rescan if we already knew such pixels existed.  To restrict this	 * Toggle to only checking the changed pixels requires knowing where	 * the alpha pixels are.	 */	ToggleComplexAlphaIfNeeded(masterPtr);    }
!sourceIsSimplePhoto && (width == 1) && (height == 1)
!sourceIsSimplePhoto && (width == 1)
!sourceIsSimplePhoto
sourceIsSimplePhoto
sourceIsSimplePhoto
(width == 1)
width == 1
width
width
1
(height == 1)
height == 1
height
height
1
{	/*	 * Optimize the single pixel case if we can. This speeds up code that	 * builds up large simple-alpha images by single pixels.  We don't	 * negate COMPLEX_ALPHA in this case. [Bug 1409140]	 */	if (!(masterPtr->flags & COMPLEX_ALPHA)) {	    unsigned char newAlpha;	    destLinePtr = masterPtr->pix32 + (y * masterPtr->width + x) * 4;	    newAlpha = destLinePtr[3];	    if (newAlpha && newAlpha != 255) {		masterPtr->flags |= COMPLEX_ALPHA;	    }	}    }
if (!(masterPtr->flags & COMPLEX_ALPHA)) {	    unsigned char newAlpha;	    destLinePtr = masterPtr->pix32 + (y * masterPtr->width + x) * 4;	    newAlpha = destLinePtr[3];	    if (newAlpha && newAlpha != 255) {		masterPtr->flags |= COMPLEX_ALPHA;	    }	}
!(masterPtr->flags & COMPLEX_ALPHA)
(masterPtr->flags & COMPLEX_ALPHA)
masterPtr->flags & COMPLEX_ALPHA
masterPtr->flags
masterPtr
masterPtr
flags
COMPLEX_ALPHA
COMPLEX_ALPHA
{	    unsigned char newAlpha;	    destLinePtr = masterPtr->pix32 + (y * masterPtr->width + x) * 4;	    newAlpha = destLinePtr[3];	    if (newAlpha && newAlpha != 255) {		masterPtr->flags |= COMPLEX_ALPHA;	    }	}
unsigned char newAlpha;
unsigned char newAlpha;
unsigned char
newAlpha
newAlpha
destLinePtr = masterPtr->pix32 + (y * masterPtr->width + x) * 4;
destLinePtr = masterPtr->pix32 + (y * masterPtr->width + x) * 4
destLinePtr
destLinePtr
masterPtr->pix32 + (y * masterPtr->width + x) * 4
masterPtr->pix32
masterPtr
masterPtr
pix32
(y * masterPtr->width + x) * 4
(y * masterPtr->width + x)
y * masterPtr->width + x
y * masterPtr->width
y
y
masterPtr->width
masterPtr
masterPtr
width
x
x
4
newAlpha = destLinePtr[3];
newAlpha = destLinePtr[3]
newAlpha
newAlpha
destLinePtr[3]
destLinePtr
destLinePtr
3
if (newAlpha && newAlpha != 255) {		masterPtr->flags |= COMPLEX_ALPHA;	    }
newAlpha && newAlpha != 255
newAlpha
newAlpha
newAlpha != 255
newAlpha
newAlpha
255
{		masterPtr->flags |= COMPLEX_ALPHA;	    }
masterPtr->flags |= COMPLEX_ALPHA;
masterPtr->flags |= COMPLEX_ALPHA
masterPtr->flags
masterPtr
masterPtr
flags
COMPLEX_ALPHA
COMPLEX_ALPHA
if ((alphaOffset != 0) || (masterPtr->flags & COMPLEX_ALPHA)) {	/*	 * Check for partial transparency if alpha pixels are specified, or	 * rescan if we already knew such pixels existed.  To restrict this	 * Toggle to only checking the changed pixels requires knowing where	 * the alpha pixels are.	 */	ToggleComplexAlphaIfNeeded(masterPtr);    }
(alphaOffset != 0) || (masterPtr->flags & COMPLEX_ALPHA)
(alphaOffset != 0)
alphaOffset != 0
alphaOffset
alphaOffset
0
(masterPtr->flags & COMPLEX_ALPHA)
masterPtr->flags & COMPLEX_ALPHA
masterPtr->flags
masterPtr
masterPtr
flags
COMPLEX_ALPHA
COMPLEX_ALPHA
{	/*	 * Check for partial transparency if alpha pixels are specified, or	 * rescan if we already knew such pixels existed.  To restrict this	 * Toggle to only checking the changed pixels requires knowing where	 * the alpha pixels are.	 */	ToggleComplexAlphaIfNeeded(masterPtr);    }
ToggleComplexAlphaIfNeeded(masterPtr);
ToggleComplexAlphaIfNeeded(masterPtr)
ToggleComplexAlphaIfNeeded
ToggleComplexAlphaIfNeeded
masterPtr
masterPtr
Tk_DitherPhoto((Tk_PhotoHandle)masterPtr, x, y, width, height);
Tk_DitherPhoto((Tk_PhotoHandle)masterPtr, x, y, width, height)
Tk_DitherPhoto
Tk_DitherPhoto
(Tk_PhotoHandle)masterPtr
Tk_PhotoHandle
Tk_PhotoHandle
Tk_PhotoHandle

masterPtr
masterPtr
x
x
y
y
width
width
height
height
Tk_ImageChanged(masterPtr->tkMaster, x, y, width, height,	    masterPtr->width, masterPtr->height);
Tk_ImageChanged(masterPtr->tkMaster, x, y, width, height,	    masterPtr->width, masterPtr->height)
Tk_ImageChanged
Tk_ImageChanged
masterPtr->tkMaster
masterPtr
masterPtr
tkMaster
x
x
y
y
width
width
height
height
masterPtr->width
masterPtr
masterPtr
width
masterPtr->height
masterPtr
masterPtr
height
return TCL_OK;
TCL_OK
TCL_OK
-----joern-----
(65,873,0)
(325,136,0)
(448,378,0)
(817,249,0)
(602,197,0)
(13,832,0)
(266,402,0)
(332,456,0)
(105,183,0)
(431,730,0)
(755,252,0)
(89,782,0)
(670,197,0)
(822,490,0)
(808,783,0)
(340,422,0)
(832,518,0)
(196,556,0)
(697,142,0)
(780,729,0)
(487,399,0)
(733,648,0)
(89,93,0)
(240,154,0)
(671,727,0)
(765,69,0)
(820,179,0)
(29,491,0)
(265,759,0)
(798,257,0)
(199,185,0)
(595,464,0)
(133,867,0)
(622,542,0)
(426,708,0)
(344,554,0)
(145,632,0)
(420,239,0)
(176,446,0)
(537,353,0)
(327,139,0)
(708,96,0)
(184,433,0)
(448,315,0)
(371,549,0)
(353,267,0)
(246,628,0)
(590,411,0)
(531,124,0)
(347,242,0)
(476,95,0)
(158,556,0)
(151,491,0)
(80,195,0)
(414,538,0)
(643,464,0)
(139,252,0)
(168,802,0)
(528,109,0)
(595,783,0)
(782,595,0)
(681,107,0)
(303,77,0)
(634,601,0)
(198,464,0)
(722,20,0)
(225,68,0)
(416,449,0)
(495,817,0)
(593,702,0)
(425,614,0)
(316,640,0)
(703,556,0)
(839,856,0)
(643,218,0)
(311,538,0)
(561,491,0)
(766,125,0)
(859,508,0)
(567,846,0)
(717,824,0)
(166,734,0)
(821,683,0)
(778,734,0)
(630,303,0)
(259,462,0)
(675,642,0)
(742,877,0)
(361,138,0)
(257,748,0)
(344,69,0)
(66,895,0)
(329,601,0)
(573,491,0)
(528,344,0)
(526,112,0)
(877,856,0)
(660,151,0)
(711,137,0)
(487,661,0)
(158,96,0)
(410,593,0)
(249,807,0)
(43,491,0)
(607,144,0)
(210,251,0)
(763,833,0)
(610,491,0)
(752,834,0)
(281,184,0)
(368,491,0)
(99,571,0)
(448,717,0)
(542,219,0)
(895,66,0)
(321,621,0)
(542,474,0)
(253,448,0)
(221,67,0)
(87,327,0)
(271,407,0)
(263,68,0)
(125,642,0)
(795,616,0)
(727,522,0)
(613,585,0)
(823,664,0)
(371,769,0)
(889,256,0)
(701,66,0)
(824,140,0)
(338,190,0)
(133,112,0)
(222,538,0)
(240,252,0)
(493,414,0)
(223,55,0)
(553,252,0)
(37,293,0)
(369,324,0)
(556,508,0)
(851,35,0)
(784,538,0)
(176,596,0)
(875,85,0)
(422,144,0)
(412,140,0)
(543,808,0)
(385,822,0)
(126,762,0)
(781,675,0)
(664,882,0)
(324,491,0)
(448,606,0)
(158,95,0)
(95,592,0)
(610,119,0)
(778,522,0)
(870,777,0)
(714,309,0)
(884,322,0)
(897,662,0)
(576,397,0)
(272,338,0)
(376,400,0)
(857,574,0)
(64,416,0)
(550,762,0)
(658,491,0)
(185,500,0)
(68,61,0)
(314,3,0)
(339,683,0)
(374,728,0)
(561,848,0)
(643,446,0)
(499,491,0)
(240,400,0)
(692,73,0)
(265,869,0)
(782,89,0)
(580,433,0)
(597,172,0)
(22,238,0)
(438,252,0)
(71,605,0)
(881,749,0)
(518,832,0)
(359,690,0)
(407,538,0)
(605,683,0)
(867,339,0)
(735,618,0)
(292,759,0)
(517,151,0)
(394,388,0)
(854,679,0)
(160,400,0)
(461,50,0)
(861,90,0)
(352,172,0)
(18,728,0)
(19,96,0)
(568,659,0)
(63,173,0)
(456,332,0)
(533,134,0)
(213,572,0)
(542,542,0)
(232,714,0)
(262,640,0)
(833,657,0)
(148,556,0)
(639,417,0)
(702,225,0)
(834,433,0)
(138,35,0)
(764,106,0)
(769,658,0)
(758,556,0)
(625,422,0)
(179,491,0)
(296,882,0)
(18,556,0)
(346,196,0)
(448,39,0)
(8,39,0)
(202,564,0)
(227,458,0)
(734,778,0)
(183,826,0)
(414,314,0)
(160,77,0)
(862,20,0)
(540,703,0)
(337,648,0)
(758,572,0)
(470,838,0)
(182,543,0)
(443,126,0)
(736,170,0)
(850,788,0)
(31,758,0)
(375,139,0)
(28,395,0)
(556,49,0)
(415,467,0)
(185,673,0)
(279,703,0)
(33,846,0)
(653,400,0)
(758,61,0)
(251,549,0)
(479,491,0)
(598,657,0)
(152,182,0)
(185,315,0)
(180,538,0)
(794,441,0)
(260,765,0)
(44,476,0)
(407,457,0)
(847,266,0)
(572,754,0)
(196,728,0)
(194,313,0)
(618,697,0)
(687,446,0)
(817,140,0)
(319,555,0)
(665,231,0)
(185,772,0)
(241,144,0)
(116,176,0)
(391,854,0)
(60,68,0)
(643,252,0)
(448,881,0)
(250,772,0)
(205,343,0)
(441,642,0)
(422,783,0)
(176,116,0)
(637,678,0)
(621,400,0)
(354,95,0)
(880,86,0)
(81,160,0)
(574,823,0)
(856,856,0)
(586,487,0)
(214,223,0)
(445,882,0)
(168,433,0)
(505,220,0)
(270,871,0)
(185,590,0)
(418,343,0)
(254,818,0)
(869,759,0)
(666,154,0)
(68,572,0)
(273,829,0)
(490,186,0)
(805,626,0)
(615,463,0)
(779,90,0)
(858,782,0)
(725,460,0)
(701,834,0)
(431,400,0)
(684,231,0)
(185,757,0)
(56,634,0)
(334,585,0)
(222,869,0)
(185,314,0)
(28,187,0)
(229,757,0)
(276,335,0)
(83,221,0)
(877,679,0)
(216,159,0)
(662,61,0)
(877,243,0)
(608,179,0)
(737,463,0)
(441,446,0)
(577,498,0)
(521,335,0)
(283,397,0)
(66,701,0)
(850,678,0)
(674,69,0)
(5,640,0)
(154,491,0)
(84,772,0)
(192,446,0)
(240,642,0)
(169,252,0)
(603,179,0)
(151,456,0)
(117,491,0)
(783,806,0)
(698,336,0)
(580,183,0)
(649,110,0)
(508,6,0)
(515,491,0)
(185,499,0)
(128,196,0)
(890,83,0)
(161,607,0)
(157,848,0)
(460,251,0)
(491,252,0)
(136,837,0)
(793,198,0)
(563,368,0)
(457,186,0)
(711,564,0)
(525,198,0)
(176,642,0)
(470,426,0)
(708,426,0)
(751,210,0)
(237,708,0)
(185,717,0)
(881,541,0)
(858,446,0)
(189,192,0)
(853,180,0)
(182,662,0)
(434,759,0)
(337,642,0)
(276,511,0)
(852,647,0)
(695,824,0)
(864,636,0)
(509,343,0)
(504,643,0)
(609,95,0)
(560,886,0)
(680,35,0)
(198,783,0)
(16,616,0)
(116,511,0)
(844,226,0)
(327,332,0)
(448,340,0)
(727,556,0)
(20,491,0)
(27,754,0)
(861,188,0)
(1,153,0)
(877,441,0)
(673,110,0)
(96,252,0)
(843,697,0)
(575,371,0)
(873,329,0)
(760,571,0)
(336,140,0)
(19,841,0)
(683,139,0)
(617,136,0)
(532,125,0)
(335,251,0)
(152,652,0)
(51,626,0)
(131,610,0)
(402,53,0)
(607,436,0)
(846,297,0)
(697,618,0)
(429,818,0)
(530,240,0)
(365,829,0)
(772,433,0)
(633,626,0)
(203,407,0)
(286,659,0)
(661,252,0)
(345,477,0)
(643,783,0)
(198,463,0)
(278,310,0)
(150,759,0)
(348,374,0)
(339,867,0)
(534,628,0)
(240,446,0)
(575,433,0)
(837,136,0)
(38,383,0)
(157,544,0)
(628,188,0)
(552,573,0)
(101,863,0)
(467,728,0)
(275,556,0)
(448,460,0)
(882,664,0)
(536,117,0)
(6,508,0)
(606,683,0)
(841,69,0)
(793,802,0)
(809,575,0)
(191,56,0)
(187,400,0)
(153,119,0)
(61,114,0)
(787,538,0)
(282,446,0)
(827,221,0)
(2,717,0)
(740,131,0)
(627,456,0)
(829,348,0)
(566,443,0)
(728,66,0)
(141,140,0)
(217,431,0)
(136,219,0)
(749,476,0)
(442,417,0)
(439,311,0)
(39,336,0)
(346,457,0)
(782,858,0)
(556,242,0)
(95,219,0)
(541,538,0)
(449,416,0)
(360,197,0)
(86,6,0)
(397,433,0)
(451,538,0)
(437,574,0)
(378,715,0)
(329,464,0)
(430,858,0)
(448,232,0)
(494,343,0)
(119,610,0)
(412,249,0)
(632,690,0)
(314,414,0)
(848,561,0)
(635,149,0)
(535,313,0)
(538,538,0)
(163,687,0)
(312,220,0)
(817,285,0)
(822,354,0)
(885,255,0)
(19,556,0)
(244,327,0)
(393,559,0)
(823,574,0)
(753,441,0)
(341,134,0)
(40,340,0)
(801,436,0)
(232,491,0)
(647,245,0)
(646,186,0)
(775,758,0)
(492,252,0)
(621,804,0)
(502,691,0)
(295,658,0)
(632,145,0)
(522,727,0)
(307,856,0)
(213,61,0)
(674,148,0)
(626,633,0)
(61,502,0)
(544,878,0)
(362,252,0)
(803,90,0)
(224,863,0)
(294,252,0)
(349,222,0)
(132,804,0)
(77,160,0)
(222,683,0)
(326,187,0)
(745,702,0)
(417,252,0)
(220,766,0)
(96,692,0)
(703,703,0)
(25,324,0)
(118,337,0)
(611,500,0)
(256,683,0)
(543,205,0)
(398,564,0)
(759,457,0)
(192,28,0)
(475,140,0)
(419,96,0)
(690,632,0)
(258,564,0)
(593,491,0)
(392,661,0)
(734,683,0)
(66,728,0)
(446,98,0)
(185,571,0)
(225,702,0)
(653,170,0)
(623,701,0)
(28,238,0)
(643,601,0)
(17,449,0)
(559,601,0)
(223,880,0)
(705,252,0)
(720,368,0)
(215,593,0)
(253,774,0)
(605,822,0)
(508,508,0)
(276,555,0)
(574,433,0)
(35,95,0)
(183,580,0)
(268,47,0)
(9,232,0)
(750,861,0)
(538,310,0)
(606,538,0)
(554,344,0)
(692,96,0)
(716,252,0)
(448,162,0)
(86,87,0)
(141,400,0)
(345,863,0)
(377,112,0)
(628,242,0)
(861,564,0)
(192,189,0)
(816,93,0)
(3,195,0)
(570,252,0)
(871,838,0)
(828,87,0)
(150,556,0)
(304,238,0)
(481,19,0)
(691,433,0)
(682,454,0)
(378,462,0)
(327,327,0)
(175,564,0)
(293,464,0)
(714,601,0)
(28,142,0)
(388,783,0)
(607,20,0)
(185,846,0)
(800,18,0)
(571,683,0)
(706,511,0)
(426,470,0)
(824,783,0)
(602,491,0)
(268,460,0)
(243,433,0)
(595,782,0)
(491,117,0)
(257,601,0)
(346,180,0)
(387,257,0)
(381,769,0)
(459,564,0)
(109,528,0)
(87,87,0)
(185,489,0)
(500,241,0)
(638,86,0)
(297,186,0)
(142,697,0)
(265,538,0)
(264,606,0)
(559,618,0)
(95,95,0)
(641,150,0)
(867,133,0)
(510,622,0)
(383,433,0)
(878,687,0)
(411,158,0)
(55,223,0)
(240,783,0)
(872,554,0)
(731,802,0)
(358,636,0)
(62,383,0)
(201,598,0)
(729,74,0)
(799,265,0)
(238,601,0)
(336,446,0)
(784,683,0)
(503,679,0)
(886,538,0)
(146,748,0)
(544,157,0)
(821,538,0)
(868,396,0)
(448,107,0)
(315,784,0)
(818,433,0)
(748,477,0)
(375,453,0)
(546,412,0)
(569,714,0)
(73,818,0)
(499,268,0)
(463,198,0)
(124,152,0)
(621,446,0)
(213,470,0)
(346,297,0)
(589,602,0)
(497,67,0)
(772,371,0)
(125,446,0)
(372,888,0)
(648,733,0)
(454,240,0)
(865,346,0)
(824,464,0)
(86,139,0)
(593,268,0)
(206,453,0)
(788,433,0)
(480,239,0)
(712,524,0)
(127,575,0)
(759,265,0)
(177,398,0)
(588,158,0)
(661,487,0)
(68,225,0)
(448,560,0)
(336,642,0)
(397,219,0)
(86,508,0)
(93,661,0)
(406,839,0)
(113,252,0)
(622,715,0)
(354,556,0)
(871,85,0)
(502,61,0)
(443,67,0)
(175,592,0)
(75,252,0)
(327,524,0)
(158,411,0)
(678,850,0)
(288,573,0)
(247,433,0)
(409,499,0)
(338,591,0)
(35,61,0)
(388,394,0)
(599,603,0)
(6,6,0)
(28,293,0)
(428,538,0)
(374,348,0)
(861,628,0)
(575,508,0)
(733,793,0)
(147,232,0)
(624,580,0)
(67,221,0)
(185,162,0)
(34,520,0)
(644,678,0)
(350,25,0)
(700,243,0)
(484,541,0)
(367,821,0)
(476,556,0)
(212,27,0)
(448,222,0)
(10,161,0)
(511,276,0)
(181,108,0)
(376,309,0)
(226,29,0)
(266,28,0)
(79,501,0)
(833,134,0)
(245,446,0)
(664,823,0)
(48,788,0)
(43,544,0)
(49,823,0)
(622,96,0)
(180,297,0)
(724,683,0)
(311,683,0)
(802,332,0)
(185,222,0)
(579,139,0)
(421,711,0)
(240,159,0)
(223,783,0)
(655,74,0)
(573,122,0)
(74,449,0)
(450,119,0)
(804,621,0)
(299,168,0)
(291,148,0)
(85,433,0)
(185,232,0)
(77,303,0)
(245,642,0)
(797,433,0)
(645,448,0)
(456,151,0)
(719,339,0)
(46,499,0)
(770,252,0)
(676,610,0)
(888,131,0)
(447,158,0)
(874,543,0)
(837,652,0)
(121,431,0)
(185,528,0)
(220,464,0)
(185,367,0)
(407,683,0)
(150,96,0)
(110,538,0)
(185,91,0)
(185,39,0)
(455,252,0)
(6,524,0)
(174,717,0)
(92,252,0)
(35,556,0)
(241,400,0)
(355,888,0)
(386,479,0)
(448,499,0)
(677,6,0)
(317,146,0)
(501,591,0)
(448,757,0)
(771,77,0)
(657,303,0)
(108,443,0)
(662,182,0)
(656,192,0)
(846,683,0)
(622,556,0)
(197,601,0)
(451,162,0)
(402,266,0)
(24,554,0)
(179,603,0)
(786,109,0)
(691,502,0)
(423,542,0)
(470,213,0)
(511,139,0)
(253,461,0)
(488,28,0)
(467,652,0)
(721,107,0)
(196,95,0)
(164,564,0)
(636,642,0)
(892,459,0)
(543,182,0)
(848,157,0)
(512,664,0)
(337,446,0)
(107,185,0)
(673,34,0)
(188,464,0)
(443,108,0)
(856,343,0)
(788,850,0)
(36,327,0)
(511,116,0)
(131,888,0)
(164,474,0)
(14,691,0)
(426,518,0)
(80,18,0)
(323,651,0)
(293,28,0)
(56,400,0)
(449,134,0)
(416,833,0)
(111,848,0)
(776,256,0)
(896,501,0)
(506,188,0)
(6,677,0)
(672,39,0)
(70,647,0)
(208,213,0)
(634,453,0)
(802,793,0)
(155,49,0)
(814,834,0)
(220,783,0)
(160,81,0)
(756,329,0)
(90,861,0)
(231,491,0)
(78,502,0)
(471,222,0)
(414,683,0)
(632,140,0)
(501,190,0)
(831,81,0)
(555,276,0)
(285,817,0)
(187,384,0)
(383,808,0)
(612,322,0)
(675,267,0)
(758,542,0)
(200,858,0)
(185,340,0)
(268,232,0)
(643,400,0)
(149,138,0)
(466,459,0)
(616,491,0)
(539,819,0)
(49,343,0)
(404,43,0)
(313,399,0)
(154,240,0)
(653,360,0)
(413,29,0)
(142,368,0)
(148,703,0)
(95,556,0)
(143,175,0)
(396,610,0)
(333,886,0)
(82,819,0)
(690,491,0)
(555,247,0)
(856,441,0)
(454,491,0)
(677,433,0)
(320,168,0)
(353,648,0)
(240,454,0)
(687,642,0)
(678,491,0)
(117,193,0)
(703,137,0)
(102,708,0)
(277,572,0)
(185,460,0)
(54,339,0)
(145,491,0)
(610,131,0)
(322,399,0)
(826,183,0)
(240,464,0)
(139,375,0)
(380,261,0)
(182,152,0)
(709,252,0)
(148,674,0)
(125,766,0)
(477,748,0)
(324,25,0)
(605,538,0)
(401,460,0)
(603,400,0)
(87,139,0)
(407,633,0)
(508,49,0)
(167,728,0)
(808,383,0)
(86,327,0)
(363,650,0)
(767,125,0)
(209,376,0)
(658,769,0)
(408,285,0)
(759,150,0)
(305,145,0)
(86,880,0)
(268,231,0)
(230,479,0)
(858,642,0)
(93,27,0)
(544,43,0)
(652,152,0)
(205,322,0)
(894,542,0)
(587,467,0)
(541,881,0)
(19,703,0)
(218,491,0)
(860,498,0)
(734,538,0)
(403,634,0)
(21,340,0)
(28,266,0)
(198,793,0)
(791,687,0)
(785,832,0)
(571,538,0)
(823,49,0)
(659,491,0)
(94,252,0)
(790,74,0)
(605,490,0)
(773,454,0)
(863,491,0)
(879,683,0)
(683,87,0)
(106,640,0)
(187,28,0)
(855,537,0)
(662,572,0)
(813,821,0)
(448,252,0)
(161,491,0)
(109,538,0)
(280,240,0)
(119,153,0)
(184,675,0)
(761,159,0)
(103,241,0)
(825,382,0)
(367,80,0)
(846,538,0)
(339,538,0)
(718,27,0)
(652,467,0)
(514,595,0)
(551,691,0)
(600,249,0)
(796,457,0)
(810,0,0)
(217,491,0)
(685,245,0)
(150,95,0)
(431,217,0)
(496,124,0)
(257,464,0)
(335,276,0)
(306,451,0)
(888,491,0)
(122,350,0)
(207,170,0)
(895,797,0)
(626,457,0)
(598,491,0)
(56,479,0)
(185,606,0)
(88,184,0)
(332,252,0)
(448,647,0)
(694,188,0)
(0,601,0)
(603,559,0)
(876,196,0)
(110,673,0)
(652,837,0)
(477,345,0)
(293,45,0)
(636,400,0)
(106,850,0)
(290,108,0)
(284,632,0)
(375,616,0)
(582,878,0)
(822,457,0)
(100,180,0)
(235,416,0)
(594,268,0)
(379,354,0)
(829,96,0)
(460,433,0)
(110,683,0)
(683,524,0)
(462,378,0)
(628,628,0)
(759,869,0)
(255,464,0)
(643,642,0)
(696,154,0)
(178,580,0)
(811,643,0)
(267,353,0)
(93,89,0)
(41,240,0)
(368,142,0)
(165,605,0)
(792,491,0)
(210,491,0)
(388,601,0)
(839,441,0)
(28,659,0)
(255,116,0)
(476,728,0)
(218,707,0)
(25,350,0)
(463,491,0)
(77,601,0)
(687,400,0)
(366,61,0)
(596,176,0)
(52,345,0)
(448,590,0)
(185,647,0)
(677,371,0)
(373,394,0)
(762,126,0)
(427,81,0)
(886,683,0)
(315,841,0)
(703,219,0)
(699,324,0)
(119,878,0)
(7,247,0)
(581,895,0)
(893,335,0)
(822,605,0)
(585,601,0)
(159,240,0)
(746,332,0)
(758,3,0)
(743,487,0)
(249,140,0)
(448,528,0)
(239,141,0)
(123,265,0)
(453,634,0)
(238,28,0)
(748,146,0)
(841,19,0)
(124,96,0)
(104,145,0)
(508,575,0)
(792,402,0)
(479,56,0)
(146,491,0)
(11,677,0)
(446,642,0)
(723,252,0)
(248,690,0)
(329,873,0)
(715,622,0)
(783,388,0)
(339,633,0)
(327,87,0)
(693,329,0)
(357,95,0)
(511,173,0)
(759,138,0)
(130,394,0)
(28,192,0)
(122,573,0)
(866,19,0)
(67,252,0)
(538,683,0)
(170,653,0)
(303,657,0)
(710,727,0)
(520,95,0)
(172,188,0)
(838,267,0)
(818,73,0)
(562,252,0)
(350,122,0)
(688,561,0)
(168,371,0)
(819,679,0)
(669,83,0)
(30,337,0)
(228,520,0)
(478,500,0)
(448,91,0)
(440,757,0)
(518,426,0)
(520,34,0)
(226,844,0)
(360,730,0)
(172,628,0)
(476,749,0)
(162,451,0)
(730,431,0)
(302,73,0)
(804,491,0)
(448,778,0)
(18,542,0)
(448,239,0)
(197,360,0)
(142,28,0)
(45,293,0)
(353,537,0)
(856,679,0)
(762,67,0)
(389,205,0)
(702,593,0)
(122,636,0)
(223,464,0)
(574,251,0)
(738,176,0)
(448,231,0)
(508,650,0)
(679,877,0)
(188,783,0)
(335,433,0)
(446,621,0)
(59,572,0)
(793,733,0)
(354,822,0)
(519,520,0)
(507,883,0)
(185,239,0)
(162,149,0)
(651,289,0)
(636,122,0)
(197,602,0)
(58,595,0)
(322,205,0)
(448,673,0)
(692,425,0)
(520,556,0)
(34,458,0)
(402,792,0)
(218,643,0)
(171,252,0)
(733,585,0)
(180,683,0)
(848,873,0)
(629,258,0)
(236,395,0)
(35,572,0)
(90,433,0)
(29,226,0)
(469,398,0)
(256,538,0)
(807,249,0)
(808,543,0)
(616,375,0)
(850,106,0)
(293,783,0)
(405,252,0)
(557,346,0)
(448,776,0)
(0,140,0)
(730,360,0)
(663,501,0)
(149,458,0)
(453,375,0)
(298,141,0)
(251,210,0)
(109,683,0)
(219,343,0)
(348,829,0)
(548,797,0)
(20,607,0)
(558,213,0)
(457,407,0)
(115,614,0)
(482,797,0)
(53,402,0)
(74,729,0)
(330,6,0)
(883,144,0)
(91,0,0)
(57,677,0)
(887,792,0)
(675,446,0)
(880,223,0)
(768,29,0)
(126,443,0)
(619,258,0)
(120,140,0)
(614,433,0)
(185,776,0)
(667,762,0)
(12,658,0)
(221,83,0)
(715,195,0)
(749,458,0)
(815,524,0)
(632,249,0)
(462,683,0)
(76,382,0)
(234,817,0)
(747,146,0)
(554,728,0)
(451,683,0)
(448,772,0)
(869,186,0)
(156,243,0)
(468,598,0)
(243,877,0)
(390,643,0)
(131,873,0)
(537,399,0)
(614,425,0)
(783,464,0)
(585,733,0)
(192,642,0)
(86,49,0)
(713,160,0)
(472,461,0)
(6,49,0)
(97,219,0)
(185,231,0)
(448,314,0)
(138,310,0)
(424,880,0)
(318,366,0)
(610,396,0)
(797,895,0)
(607,161,0)
(826,518,0)
(245,144,0)
(436,607,0)
(411,458,0)
(42,774,0)
(766,220,0)
(185,881,0)
(657,833,0)
(849,217,0)
(554,556,0)
(822,138,0)
(776,674,0)
(834,701,0)
(838,470,0)
(422,464,0)
(112,138,0)
(784,315,0)
(707,218,0)
(117,328,0)
(789,374,0)
(541,683,0)
(808,464,0)
(556,6,0)
(578,561,0)
(565,252,0)
(448,846,0)
(882,433,0)
(61,67,0)
(185,560,0)
(687,878,0)
(584,622,0)
(679,343,0)
(72,739,0)
(564,242,0)
(564,861,0)
(185,778,0)
(542,556,0)
(683,327,0)
(85,871,0)
(744,804,0)
(648,353,0)
(287,252,0)
(425,692,0)
(3,758,0)
(311,590,0)
(675,184,0)
(604,856,0)
(571,490,0)
(836,242,0)
(29,268,0)
(606,633,0)
(308,537,0)
(274,476,0)
(394,491,0)
(741,808,0)
(620,310,0)
(838,871,0)
(518,826,0)
(590,311,0)
(448,571,0)
(654,783,0)
(256,776,0)
(81,491,0)
(523,87,0)
(384,187,0)
(668,226,0)
(129,247,0)
(583,210,0)
(821,367,0)
(35,138,0)
(112,133,0)
(196,346,0)
(651,491,0)
(845,614,0)
(486,784,0)
(657,598,0)
(265,683,0)
(886,560,0)
(462,538,0)
(873,252,0)
(26,252,0)
(835,25,0)
(267,675,0)
(360,653,0)
(87,332,0)
(87,650,0)
(300,86,0)
(331,425,0)
(268,772,0)
(689,252,0)
(364,792,0)
(448,367,0)
(634,56,0)
(729,449,0)
(626,138,0)
(485,153,0)
(802,168,0)
(18,80,0)
(473,148,0)
(863,345,0)
(247,555,0)
(238,304,0)
(219,397,0)
(769,371,0)
(432,602,0)
(346,138,0)
(704,388,0)
(86,650,0)
(240,601,0)
(180,346,0)
(891,91,0)
(23,252,0)
(545,85,0)
(301,61,0)
(366,572,0)
(231,376,0)
(328,117,0)
(152,124,0)
(73,692,0)
(267,838,0)
(370,310,0)
(726,18,0)
(233,354,0)
(728,252,0)
(185,378,0)
(498,190,0)
(659,28,0)
(351,643,0)
(435,739,0)
(108,433,0)
(516,653,0)
(871,783,0)
(883,601,0)
(547,366,0)
(116,255,0)
(211,252,0)
(444,161,0)
(748,257,0)
(417,399,0)
(554,703,0)
(329,783,0)
(342,788,0)
(255,783,0)
(727,542,0)
(135,662,0)
(107,491,0)
(522,195,0)
(878,252,0)
(159,491,0)
(4,374,0)
(356,91,0)
(83,433,0)
(732,606,0)
(774,261,0)
(490,822,0)
(170,491,0)
(297,346,0)
(633,186,0)
(153,491,0)
(32,255,0)
(527,43,0)
(559,603,0)
(483,252,0)
(840,556,0)
(465,150,0)
(15,217,0)
(648,337,0)
(871,464,0)
(842,218,0)
(204,839,0)
(757,883,0)
(269,164,0)
(448,500,0)
(560,765,0)
(686,822,0)
(513,544,0)
(529,240,0)
(832,728,0)
(628,564,0)
(618,559,0)
(368,563,1)
(511,139,1)
(157,544,1)
(184,281,1)
(611,478,1)
(480,420,1)
(253,774,1)
(621,400,1)
(240,154,1)
(71,385,1)
(448,881,1)
(621,804,1)
(359,248,1)
(703,703,1)
(504,351,1)
(141,298,1)
(700,742,1)
(784,683,1)
(366,61,1)
(107,491,1)
(89,782,1)
(556,6,1)
(427,831,1)
(228,519,1)
(86,508,1)
(792,887,1)
(164,564,1)
(110,538,1)
(42,498,1)
(247,129,1)
(759,150,1)
(715,622,1)
(559,601,1)
(272,498,1)
(326,238,1)
(60,89,1)
(19,703,1)
(87,523,1)
(0,810,1)
(366,318,1)
(329,693,1)
(599,368,1)
(522,727,1)
(84,250,1)
(81,427,1)
(789,4,1)
(659,286,1)
(688,578,1)
(835,324,1)
(628,246,1)
(420,0,1)
(839,856,1)
(217,849,1)
(508,49,1)
(61,502,1)
(231,684,1)
(890,669,1)
(662,61,1)
(585,601,1)
(101,224,1)
(441,794,1)
(817,234,1)
(713,598,1)
(631,366,1)
(336,698,1)
(818,433,1)
(448,314,1)
(148,556,1)
(842,185,1)
(34,520,1)
(147,730,1)
(527,404,1)
(117,536,1)
(180,538,1)
(854,679,1)
(221,83,1)
(858,642,1)
(692,425,1)
(312,446,1)
(187,400,1)
(581,797,1)
(493,715,1)
(518,832,1)
(487,586,1)
(291,776,1)
(774,42,1)
(551,14,1)
(2,174,1)
(6,6,1)
(174,141,1)
(456,627,1)
(585,334,1)
(634,56,1)
(861,628,1)
(448,778,1)
(143,538,1)
(3,758,1)
(643,390,1)
(150,96,1)
(865,180,1)
(311,538,1)
(556,49,1)
(758,572,1)
(377,138,1)
(473,291,1)
(756,65,1)
(721,681,1)
(429,425,1)
(643,218,1)
(758,61,1)
(200,595,1)
(765,260,1)
(648,337,1)
(185,91,1)
(804,491,1)
(277,126,1)
(178,332,1)
(116,176,1)
(547,556,1)
(48,764,1)
(14,301,1)
(170,491,1)
(37,187,1)
(234,495,1)
(459,892,1)
(254,429,1)
(759,265,1)
(793,802,1)
(825,258,1)
(263,60,1)
(168,320,1)
(575,809,1)
(268,772,1)
(180,853,1)
(662,572,1)
(127,859,1)
(526,377,1)
(383,38,1)
(266,847,1)
(124,96,1)
(87,139,1)
(541,538,1)
(762,67,1)
(863,491,1)
(582,873,1)
(161,491,1)
(199,107,1)
(346,457,1)
(136,617,1)
(883,601,1)
(441,446,1)
(146,491,1)
(624,178,1)
(788,433,1)
(802,332,1)
(866,481,1)
(451,538,1)
(819,679,1)
(407,683,1)
(886,538,1)
(690,491,1)
(313,399,1)
(541,484,1)
(166,258,1)
(838,267,1)
(327,139,1)
(605,683,1)
(668,29,1)
(18,556,1)
(612,389,1)
(725,452,1)
(417,399,1)
(296,445,1)
(406,204,1)
(805,606,1)
(477,345,1)
(86,880,1)
(605,490,1)
(652,467,1)
(33,490,1)
(325,819,1)
(31,775,1)
(511,116,1)
(180,297,1)
(197,601,1)
(237,102,1)
(240,642,1)
(470,838,1)
(22,659,1)
(692,73,1)
(18,726,1)
(677,433,1)
(855,648,1)
(448,162,1)
(514,93,1)
(9,147,1)
(479,230,1)
(82,856,1)
(224,417,1)
(226,29,1)
(766,220,1)
(857,437,1)
(839,406,1)
(664,882,1)
(74,449,1)
(422,464,1)
(64,17,1)
(449,416,1)
(108,433,1)
(595,464,1)
(314,414,1)
(804,744,1)
(714,569,1)
(850,788,1)
(354,556,1)
(626,457,1)
(244,6,1)
(543,874,1)
(358,864,1)
(253,448,1)
(727,710,1)
(469,703,1)
(15,121,1)
(854,391,1)
(256,889,1)
(758,31,1)
(837,136,1)
(191,616,1)
(185,500,1)
(456,151,1)
(717,2,1)
(431,400,1)
(797,548,1)
(168,433,1)
(628,564,1)
(286,568,1)
(303,77,1)
(676,106,1)
(117,328,1)
(896,79,1)
(751,460,1)
(841,19,1)
(792,491,1)
(419,728,1)
(448,717,1)
(364,488,1)
(112,138,1)
(192,642,1)
(575,371,1)
(295,12,1)
(428,830,1)
(571,683,1)
(469,366,1)
(230,386,1)
(217,491,1)
(135,897,1)
(213,572,1)
(536,515,1)
(327,36,1)
(545,875,1)
(123,434,1)
(538,683,1)
(573,491,1)
(390,504,1)
(724,837,1)
(467,728,1)
(185,717,1)
(816,607,1)
(154,696,1)
(6,677,1)
(487,399,1)
(177,469,1)
(462,259,1)
(807,600,1)
(179,491,1)
(794,753,1)
(498,190,1)
(354,95,1)
(530,280,1)
(466,631,1)
(6,49,1)
(516,431,1)
(176,642,1)
(329,783,1)
(812,839,1)
(411,158,1)
(838,871,1)
(687,400,1)
(126,443,1)
(727,542,1)
(821,538,1)
(256,538,1)
(782,595,1)
(290,181,1)
(226,668,1)
(82,854,1)
(813,522,1)
(404,513,1)
(306,411,1)
(752,814,1)
(409,46,1)
(798,345,1)
(569,232,1)
(677,11,1)
(824,783,1)
(348,829,1)
(584,378,1)
(738,276,1)
(769,658,1)
(773,643,1)
(63,511,1)
(784,486,1)
(188,506,1)
(265,538,1)
(843,618,1)
(842,729,1)
(512,882,1)
(726,800,1)
(385,354,1)
(425,614,1)
(331,614,1)
(588,590,1)
(196,728,1)
(130,654,1)
(268,594,1)
(1,485,1)
(188,464,1)
(396,610,1)
(368,491,1)
(598,491,1)
(703,556,1)
(731,168,1)
(220,464,1)
(608,820,1)
(388,601,1)
(163,791,1)
(90,803,1)
(559,603,1)
(396,868,1)
(73,818,1)
(10,20,1)
(205,322,1)
(93,816,1)
(711,564,1)
(136,219,1)
(157,848,1)
(699,783,1)
(132,282,1)
(498,577,1)
(194,812,1)
(628,628,1)
(28,142,1)
(258,619,1)
(690,359,1)
(476,274,1)
(525,585,1)
(0,601,1)
(297,346,1)
(571,760,1)
(446,642,1)
(388,704,1)
(366,572,1)
(85,433,1)
(839,441,1)
(222,683,1)
(783,388,1)
(394,373,1)
(240,400,1)
(138,35,1)
(146,317,1)
(749,476,1)
(629,631,1)
(448,460,1)
(70,852,1)
(222,538,1)
(298,239,1)
(87,327,1)
(472,766,1)
(538,538,1)
(643,464,1)
(109,786,1)
(46,348,1)
(107,721,1)
(632,249,1)
(16,579,1)
(609,357,1)
(350,25,1)
(476,556,1)
(426,708,1)
(830,133,1)
(678,637,1)
(706,826,1)
(68,61,1)
(769,381,1)
(448,222,1)
(222,349,1)
(210,491,1)
(243,156,1)
(17,833,1)
(644,788,1)
(448,239,1)
(192,656,1)
(51,805,1)
(593,491,1)
(622,556,1)
(701,623,1)
(832,728,1)
(35,572,1)
(484,34,1)
(185,239,1)
(247,433,1)
(452,396,1)
(513,848,1)
(235,64,1)
(305,817,1)
(220,505,1)
(185,378,1)
(425,331,1)
(360,653,1)
(265,869,1)
(708,237,1)
(617,325,1)
(361,459,1)
(501,896,1)
(744,132,1)
(563,720,1)
(83,890,1)
(643,642,1)
(554,728,1)
(410,68,1)
(293,783,1)
(90,433,1)
(448,528,1)
(643,400,1)
(882,296,1)
(746,139,1)
(257,387,1)
(153,491,1)
(336,642,1)
(424,223,1)
(697,618,1)
(431,217,1)
(658,491,1)
(416,833,1)
(8,672,1)
(819,539,1)
(32,885,1)
(633,626,1)
(823,574,1)
(27,718,1)
(879,724,1)
(35,95,1)
(350,122,1)
(185,39,1)
(542,219,1)
(710,671,1)
(28,238,1)
(616,795,1)
(871,85,1)
(555,319,1)
(333,841,1)
(335,251,1)
(594,499,1)
(858,430,1)
(40,241,1)
(793,198,1)
(321,804,1)
(151,660,1)
(232,491,1)
(817,285,1)
(185,606,1)
(352,825,1)
(637,644,1)
(376,209,1)
(167,730,1)
(787,428,1)
(554,703,1)
(848,873,1)
(859,86,1)
(849,15,1)
(430,200,1)
(204,819,1)
(442,639,1)
(481,315,1)
(560,886,1)
(467,587,1)
(218,707,1)
(636,642,1)
(657,598,1)
(192,446,1)
(567,33,1)
(517,746,1)
(188,783,1)
(388,394,1)
(542,556,1)
(203,271,1)
(213,558,1)
(197,602,1)
(795,16,1)
(246,534,1)
(378,462,1)
(702,593,1)
(834,433,1)
(561,688,1)
(345,863,1)
(580,433,1)
(339,683,1)
(703,219,1)
(720,192,1)
(519,673,1)
(119,153,1)
(856,856,1)
(149,635,1)
(590,311,1)
(555,247,1)
(12,772,1)
(639,491,1)
(816,28,1)
(352,72,1)
(520,556,1)
(86,6,1)
(86,49,1)
(158,96,1)
(832,13,1)
(42,501,1)
(255,32,1)
(529,41,1)
(398,177,1)
(426,470,1)
(151,491,1)
(268,460,1)
(614,433,1)
(185,772,1)
(892,466,1)
(568,313,1)
(265,799,1)
(719,54,1)
(334,613,1)
(117,193,1)
(651,323,1)
(539,82,1)
(681,729,1)
(133,112,1)
(448,645,1)
(322,884,1)
(577,860,1)
(771,160,1)
(335,893,1)
(852,422,1)
(462,538,1)
(598,201,1)
(354,379,1)
(119,878,1)
(508,6,1)
(401,725,1)
(185,560,1)
(307,679,1)
(124,496,1)
(518,426,1)
(240,446,1)
(675,642,1)
(822,138,1)
(603,400,1)
(196,95,1)
(209,231,1)
(363,87,1)
(185,231,1)
(574,251,1)
(683,327,1)
(850,678,1)
(675,184,1)
(728,66,1)
(579,268,1)
(851,361,1)
(694,683,1)
(264,869,1)
(782,858,1)
(683,139,1)
(158,95,1)
(180,683,1)
(18,728,1)
(168,371,1)
(556,508,1)
(332,456,1)
(88,781,1)
(448,499,1)
(606,732,1)
(258,564,1)
(357,175,1)
(414,683,1)
(185,590,1)
(24,872,1)
(371,769,1)
(741,662,1)
(245,642,1)
(578,111,1)
(499,491,1)
(834,752,1)
(559,393,1)
(44,881,1)
(860,396,1)
(889,398,1)
(4,27,1)
(680,851,1)
(817,249,1)
(185,315,1)
(653,170,1)
(86,87,1)
(507,757,1)
(100,557,1)
(185,778,1)
(30,675,1)
(391,327,1)
(636,400,1)
(546,632,1)
(183,580,1)
(11,57,1)
(215,410,1)
(457,407,1)
(753,826,1)
(25,324,1)
(696,666,1)
(869,759,1)
(68,263,1)
(379,233,1)
(760,99,1)
(876,846,1)
(28,192,1)
(7,335,1)
(888,355,1)
(49,823,1)
(219,397,1)
(72,398,1)
(221,827,1)
(580,624,1)
(255,464,1)
(86,139,1)
(56,479,1)
(99,457,1)
(25,835,1)
(761,529,1)
(618,735,1)
(550,443,1)
(111,878,1)
(339,538,1)
(663,338,1)
(748,257,1)
(152,182,1)
(273,374,1)
(759,292,1)
(448,232,1)
(345,52,1)
(557,196,1)
(772,433,1)
(448,315,1)
(767,532,1)
(653,400,1)
(622,96,1)
(868,610,1)
(300,638,1)
(635,162,1)
(737,615,1)
(423,164,1)
(187,326,1)
(125,642,1)
(285,408,1)
(216,761,1)
(303,630,1)
(733,585,1)
(28,659,1)
(844,226,1)
(276,335,1)
(330,172,1)
(250,251,1)
(671,778,1)
(656,293,1)
(532,220,1)
(556,275,1)
(775,314,1)
(346,138,1)
(121,157,1)
(182,662,1)
(877,243,1)
(618,559,1)
(587,415,1)
(214,300,1)
(259,80,1)
(821,813,1)
(58,514,1)
(740,676,1)
(185,199,1)
(673,110,1)
(691,433,1)
(185,881,1)
(880,223,1)
(626,138,1)
(888,491,1)
(256,683,1)
(607,436,1)
(579,348,1)
(322,399,1)
(86,327,1)
(74,655,1)
(698,39,1)
(393,603,1)
(520,228,1)
(893,521,1)
(683,879,1)
(445,574,1)
(185,528,1)
(643,783,1)
(626,51,1)
(638,837,1)
(603,179,1)
(161,444,1)
(342,48,1)
(160,400,1)
(691,551,1)
(543,205,1)
(329,601,1)
(589,670,1)
(402,792,1)
(62,741,1)
(829,96,1)
(165,71,1)
(597,352,1)
(54,112,1)
(402,53,1)
(276,555,1)
(77,601,1)
(346,180,1)
(781,871,1)
(875,270,1)
(312,350,1)
(96,692,1)
(641,465,1)
(335,433,1)
(103,500,1)
(95,95,1)
(659,491,1)
(327,87,1)
(208,708,1)
(842,225,1)
(874,808,1)
(894,423,1)
(241,103,1)
(684,665,1)
(18,542,1)
(255,783,1)
(568,412,1)
(630,77,1)
(614,845,1)
(833,657,1)
(35,556,1)
(871,783,1)
(240,464,1)
(416,235,1)
(434,150,1)
(375,453,1)
(183,105,1)
(508,575,1)
(318,547,1)
(634,403,1)
(301,126,1)
(85,545,1)
(734,683,1)
(4,61,1)
(886,683,1)
(105,580,1)
(391,363,1)
(376,400,1)
(729,780,1)
(764,157,1)
(238,601,1)
(878,687,1)
(451,306,1)
(35,680,1)
(218,842,1)
(711,421,1)
(407,203,1)
(505,312,1)
(81,491,1)
(152,124,1)
(495,285,1)
(176,738,1)
(387,798,1)
(150,556,1)
(665,714,1)
(164,269,1)
(172,188,1)
(808,464,1)
(772,84,1)
(693,756,1)
(159,216,1)
(824,464,1)
(502,691,1)
(185,367,1)
(344,554,1)
(201,468,1)
(660,517,1)
(856,441,1)
(502,78,1)
(695,717,1)
(802,168,1)
(454,491,1)
(129,7,1)
(670,653,1)
(468,763,1)
(778,734,1)
(260,560,1)
(453,634,1)
(602,432,1)
(257,601,1)
(240,601,1)
(196,556,1)
(461,472,1)
(141,400,1)
(541,683,1)
(227,149,1)
(463,737,1)
(417,442,1)
(714,601,1)
(19,866,1)
(116,255,1)
(479,491,1)
(115,419,1)
(407,538,1)
(632,145,1)
(73,302,1)
(803,779,1)
(373,130,1)
(327,332,1)
(552,288,1)
(823,664,1)
(125,446,1)
(108,290,1)
(167,376,1)
(196,128,1)
(780,449,1)
(593,268,1)
(895,581,1)
(623,834,1)
(810,91,1)
(862,722,1)
(880,424,1)
(176,596,1)
(436,801,1)
(185,846,1)
(198,464,1)
(682,773,1)
(153,1,1)
(268,231,1)
(666,159,1)
(365,273,1)
(367,821,1)
(610,491,1)
(253,461,1)
(762,667,1)
(20,862,1)
(185,757,1)
(192,189,1)
(448,107,1)
(697,843,1)
(28,187,1)
(118,30,1)
(145,491,1)
(521,706,1)
(403,56,1)
(154,491,1)
(729,74,1)
(202,172,1)
(628,188,1)
(897,124,1)
(632,690,1)
(616,491,1)
(784,538,1)
(149,138,1)
(758,542,1)
(702,745,1)
(185,460,1)
(185,232,1)
(607,161,1)
(397,576,1)
(463,491,1)
(564,861,1)
(223,783,1)
(864,25,1)
(386,191,1)
(883,507,1)
(621,321,1)
(346,196,1)
(683,87,1)
(783,464,1)
(352,459,1)
(872,528,1)
(38,62,1)
(622,542,1)
(856,679,1)
(768,413,1)
(658,295,1)
(448,757,1)
(856,604,1)
(448,91,1)
(66,701,1)
(89,93,1)
(293,45,1)
(198,463,1)
(554,24,1)
(605,165,1)
(861,188,1)
(873,329,1)
(788,342,1)
(699,477,1)
(317,747,1)
(853,100,1)
(421,765,1)
(488,142,1)
(759,138,1)
(324,369,1)
(121,371,1)
(319,247,1)
(877,856,1)
(490,822,1)
(636,358,1)
(340,21,1)
(758,556,1)
(848,561,1)
(648,733,1)
(67,221,1)
(160,81,1)
(280,454,1)
(212,572,1)
(796,830,1)
(308,855,1)
(95,556,1)
(181,566,1)
(822,686,1)
(389,219,1)
(356,249,1)
(722,436,1)
(145,104,1)
(299,198,1)
(175,564,1)
(891,356,1)
(375,616,1)
(43,527,1)
(465,222,1)
(828,508,1)
(802,731,1)
(476,728,1)
(35,61,1)
(36,244,1)
(462,683,1)
(93,27,1)
(548,482,1)
(336,446,1)
(534,564,1)
(412,546,1)
(408,336,1)
(206,634,1)
(43,491,1)
(185,314,1)
(170,736,1)
(808,383,1)
(128,876,1)
(142,697,1)
(885,176,1)
(619,629,1)
(881,541,1)
(448,340,1)
(29,268,1)
(471,297,1)
(39,8,1)
(822,457,1)
(797,433,1)
(523,828,1)
(407,633,1)
(531,467,1)
(734,538,1)
(109,538,1)
(346,865,1)
(398,564,1)
(422,783,1)
(558,208,1)
(674,148,1)
(482,701,1)
(448,606,1)
(121,452,1)
(122,573,1)
(867,339,1)
(185,673,1)
(313,535,1)
(269,3,1)
(353,648,1)
(822,605,1)
(20,491,1)
(629,542,1)
(845,115,1)
(143,227,1)
(422,625,1)
(220,783,1)
(282,350,1)
(655,790,1)
(443,108,1)
(742,503,1)
(91,891,1)
(718,212,1)
(172,628,1)
(245,685,1)
(535,194,1)
(496,531,1)
(238,22,1)
(814,167,1)
(643,601,1)
(747,257,1)
(528,109,1)
(241,400,1)
(448,378,1)
(131,888,1)
(232,9,1)
(745,593,1)
(448,673,1)
(448,590,1)
(687,163,1)
(184,433,1)
(78,691,1)
(65,766,1)
(537,399,1)
(355,372,1)
(542,542,1)
(448,647,1)
(265,683,1)
(662,135,1)
(733,793,1)
(412,249,1)
(842,651,1)
(320,299,1)
(499,409,1)
(440,812,1)
(602,491,1)
(112,526,1)
(544,43,1)
(634,601,1)
(735,559,1)
(223,464,1)
(77,771,1)
(372,740,1)
(80,18,1)
(125,767,1)
(459,564,1)
(79,663,1)
(288,636,1)
(337,642,1)
(554,556,1)
(19,556,1)
(679,877,1)
(846,683,1)
(827,83,1)
(809,127,1)
(882,433,1)
(453,206,1)
(87,332,1)
(448,500,1)
(349,471,1)
(708,96,1)
(448,39,1)
(59,277,1)
(808,783,1)
(270,213,1)
(225,702,1)
(732,264,1)
(861,90,1)
(148,473,1)
(104,305,1)
(675,446,1)
(669,497,1)
(293,464,1)
(185,162,1)
(511,276,1)
(840,628,1)
(799,123,1)
(210,583,1)
(337,446,1)
(824,695,1)
(275,840,1)
(281,88,1)
(606,683,1)
(486,344,1)
(615,525,1)
(198,783,1)
(643,446,1)
(460,433,1)
(664,512,1)
(437,155,1)
(846,538,1)
(649,133,1)
(574,433,1)
(428,633,1)
(652,152,1)
(360,197,1)
(109,683,1)
(572,59,1)
(687,642,1)
(622,510,1)
(279,711,1)
(229,440,1)
(686,605,1)
(352,188,1)
(447,588,1)
(83,433,1)
(381,658,1)
(786,674,1)
(126,762,1)
(821,683,1)
(353,537,1)
(185,340,1)
(162,451,1)
(52,863,1)
(248,284,1)
(627,151,1)
(339,719,1)
(133,867,1)
(485,450,1)
(338,190,1)
(678,491,1)
(284,145,1)
(576,283,1)
(439,749,1)
(444,10,1)
(179,608,1)
(218,491,1)
(645,240,1)
(159,491,1)
(240,454,1)
(561,491,1)
(542,894,1)
(506,694,1)
(730,431,1)
(176,446,1)
(6,508,1)
(687,446,1)
(818,254,1)
(207,516,1)
(583,751,1)
(466,95,1)
(225,68,1)
(667,550,1)
(800,367,1)
(651,491,1)
(829,365,1)
(292,265,1)
(394,491,1)
(757,229,1)
(311,439,1)
(61,67,1)
(172,597,1)
(185,499,1)
(233,571,1)
(704,394,1)
(661,487,1)
(274,44,1)
(566,67,1)
(727,556,1)
(150,641,1)
(448,776,1)
(28,293,1)
(837,652,1)
(779,750,1)
(302,818,1)
(66,895,1)
(19,96,1)
(491,117,1)
(478,883,1)
(122,636,1)
(736,207,1)
(750,202,1)
(327,327,1)
(142,368,1)
(243,433,1)
(95,609,1)
(148,703,1)
(231,491,1)
(223,214,1)
(657,303,1)
(600,313,1)
(606,538,1)
(871,464,1)
(685,647,1)
(441,642,1)
(150,95,1)
(185,647,1)
(185,571,1)
(766,125,1)
(613,337,1)
(703,540,1)
(729,449,1)
(822,354,1)
(476,95,1)
(497,96,1)
(257,464,1)
(785,183,1)
(414,493,1)
(95,219,1)
(842,844,1)
(337,118,1)
(595,58,1)
(182,543,1)
(110,649,1)
(204,441,1)
(311,683,1)
(156,700,1)
(847,402,1)
(369,699,1)
(175,143,1)
(593,215,1)
(293,37,1)
(450,131,1)
(56,400,1)
(846,567,1)
(543,808,1)
(448,367,1)
(155,205,1)
(238,304,1)
(251,210,1)
(501,190,1)
(595,783,1)
(831,713,1)
(185,222,1)
(187,384,1)
(520,95,1)
(448,772,1)
(605,538,1)
(374,728,1)
(500,611,1)
(537,308,1)
(397,433,1)
(451,683,1)
(470,213,1)
(21,40,1)
(863,101,1)
(448,231,1)
(571,538,1)
(432,589,1)
(877,441,1)
(28,266,1)
(158,556,1)
(610,119,1)
(654,477,1)
(544,878,1)
(68,572,1)
(267,675,1)
(884,612,1)
(315,784,1)
(895,797,1)
(13,785,1)
(185,776,1)
(701,834,1)
(415,136,1)
(93,661,1)
(29,768,1)
(77,160,1)
(610,131,1)
(97,839,1)
(600,63,1)
(508,508,1)
(240,783,1)
(443,67,1)
(575,433,1)
(271,796,1)
(811,218,1)
(448,846,1)
(158,447,1)
(348,374,1)
(538,787,1)
(574,857,1)
(586,743,1)
(510,584,1)
(477,748,1)
(776,256,1)
(820,599,1)
(743,392,1)
(102,832,1)
(245,446,1)
(283,97,1)
(748,146,1)
(324,491,1)
(87,87,1)
(413,89,1)
(249,807,1)
(763,844,1)
(791,582,1)
(826,183,1)
(339,633,1)
(448,571,1)
(351,811,1)
(266,402,1)
(515,661,1)
(383,433,1)
(110,683,1)
(267,353,1)
(677,371,1)
(886,333,1)
(448,560,1)
(887,364,1)
(106,850,1)
(790,780,1)
(801,245,1)
(730,360,1)
(625,340,1)
(734,166,1)
(268,232,1)
(540,279,1)
(240,159,1)
(374,789,1)
(647,70,1)
(607,20,1)
(338,272,1)
(57,330,1)
(573,552,1)
(460,401,1)
(503,49,1)
(139,375,1)
(672,824,1)
(604,307,1)
(454,682,1)
(213,61,1)
(239,480,1)
(323,225,1)
(446,621,1)
(329,464,1)
(223,55,1)
(826,518,1)
(131,873,1)
(41,530,1)
(414,538,1)
(759,457,1)
(29,491,1)
(858,446,1)
(104,313,2)
(277,126,2)
(587,136,2)
(248,826,2)
(793,585,2)
(488,826,2)
(28,142,2)
(675,871,2)
(886,398,2)
(752,157,2)
(839,839,2)
(160,844,2)
(459,564,2)
(364,812,2)
(185,776,2)
(610,157,2)
(434,830,2)
(249,807,2)
(426,470,2)
(597,172,2)
(20,491,2)
(44,133,2)
(831,844,2)
(448,162,2)
(35,61,2)
(247,826,2)
(448,772,2)
(622,96,2)
(664,839,2)
(780,844,2)
(407,830,2)
(628,188,2)
(508,575,2)
(861,628,2)
(450,157,2)
(511,276,2)
(448,647,2)
(675,446,2)
(759,830,2)
(766,220,2)
(824,313,2)
(17,844,2)
(222,538,2)
(526,459,2)
(263,89,2)
(131,157,2)
(254,157,2)
(881,133,2)
(255,464,2)
(86,87,2)
(291,398,2)
(702,68,2)
(185,162,2)
(238,304,2)
(58,93,2)
(667,443,2)
(217,491,2)
(159,396,2)
(234,826,2)
(779,172,2)
(276,826,2)
(266,812,2)
(554,728,2)
(822,830,2)
(850,678,2)
(653,400,2)
(28,826,2)
(28,812,2)
(448,571,2)
(478,812,2)
(33,830,2)
(531,467,2)
(198,783,2)
(240,396,2)
(863,491,2)
(619,258,2)
(420,313,2)
(9,730,2)
(141,400,2)
(414,258,2)
(537,648,2)
(89,157,2)
(696,157,2)
(297,346,2)
(807,313,2)
(348,157,2)
(28,659,2)
(876,830,2)
(416,833,2)
(426,708,2)
(152,124,2)
(810,826,2)
(847,812,2)
(769,658,2)
(837,652,2)
(346,138,2)
(448,499,2)
(880,223,2)
(448,107,2)
(185,647,2)
(459,631,2)
(188,783,2)
(93,661,2)
(0,826,2)
(451,133,2)
(676,157,2)
(563,812,2)
(784,683,2)
(888,157,2)
(714,601,2)
(376,400,2)
(892,459,2)
(91,826,2)
(161,812,2)
(256,683,2)
(179,812,2)
(198,585,2)
(871,464,2)
(854,819,2)
(801,812,2)
(841,19,2)
(90,172,2)
(861,90,2)
(185,499,2)
(431,217,2)
(96,157,2)
(507,812,2)
(657,844,2)
(759,150,2)
(148,556,2)
(664,882,2)
(183,396,2)
(643,783,2)
(91,313,2)
(87,837,2)
(376,730,2)
(185,560,2)
(544,878,2)
(406,826,2)
(448,757,2)
(112,138,2)
(687,446,2)
(551,126,2)
(148,398,2)
(858,595,2)
(267,675,2)
(133,867,2)
(456,157,2)
(556,6,2)
(491,117,2)
(293,826,2)
(19,556,2)
(618,826,2)
(42,396,2)
(574,251,2)
(479,157,2)
(301,126,2)
(281,871,2)
(580,433,2)
(311,133,2)
(543,205,2)
(126,443,2)
(728,396,2)
(371,769,2)
(569,730,2)
(201,844,2)
(552,25,2)
(258,564,2)
(172,172,2)
(481,398,2)
(56,157,2)
(593,68,2)
(784,538,2)
(854,679,2)
(476,133,2)
(292,830,2)
(130,477,2)
(600,313,2)
(240,154,2)
(18,728,2)
(448,378,2)
(13,183,2)
(81,844,2)
(792,812,2)
(449,416,2)
(605,830,2)
(554,556,2)
(616,157,2)
(636,400,2)
(266,402,2)
(110,538,2)
(240,157,2)
(845,396,2)
(218,157,2)
(722,812,2)
(387,345,2)
(823,664,2)
(375,396,2)
(453,634,2)
(183,580,2)
(165,830,2)
(174,313,2)
(19,703,2)
(785,183,2)
(728,66,2)
(605,683,2)
(28,238,2)
(446,642,2)
(105,157,2)
(626,457,2)
(206,396,2)
(577,396,2)
(861,188,2)
(655,780,2)
(688,766,2)
(448,157,2)
(834,157,2)
(482,157,2)
(145,313,2)
(375,453,2)
(225,68,2)
(660,157,2)
(322,839,2)
(321,350,2)
(378,258,2)
(731,198,2)
(178,396,2)
(97,839,2)
(730,360,2)
(407,538,2)
(538,683,2)
(758,572,2)
(324,491,2)
(185,340,2)
(37,826,2)
(644,157,2)
(87,139,2)
(121,396,2)
(669,157,2)
(4,157,2)
(873,329,2)
(585,601,2)
(511,826,2)
(566,157,2)
(802,198,2)
(541,133,2)
(187,826,2)
(302,396,2)
(573,491,2)
(523,837,2)
(267,871,2)
(541,538,2)
(758,61,2)
(672,313,2)
(877,856,2)
(406,839,2)
(788,433,2)
(117,328,2)
(290,157,2)
(687,400,2)
(257,601,2)
(185,757,2)
(238,826,2)
(153,157,2)
(185,39,2)
(426,832,2)
(584,258,2)
(127,837,2)
(839,826,2)
(41,157,2)
(787,133,2)
(307,839,2)
(192,826,2)
(425,157,2)
(674,148,2)
(614,433,2)
(393,826,2)
(104,826,2)
(527,848,2)
(444,812,2)
(327,327,2)
(54,112,2)
(512,839,2)
(728,157,2)
(826,183,2)
(225,702,2)
(761,157,2)
(713,844,2)
(420,826,2)
(96,396,2)
(241,812,2)
(817,313,2)
(59,126,2)
(285,313,2)
(480,826,2)
(139,396,2)
(470,213,2)
(221,396,2)
(729,74,2)
(765,398,2)
(607,161,2)
(448,232,2)
(547,172,2)
(467,136,2)
(154,157,2)
(260,398,2)
(28,266,2)
(559,603,2)
(345,863,2)
(623,157,2)
(585,337,2)
(488,812,2)
(196,95,2)
(684,730,2)
(346,180,2)
(397,839,2)
(377,459,2)
(448,367,2)
(368,826,2)
(86,837,2)
(877,839,2)
(313,399,2)
(874,808,2)
(73,818,2)
(762,443,2)
(830,133,2)
(359,313,2)
(344,398,2)
(792,826,2)
(516,431,2)
(157,848,2)
(332,396,2)
(848,766,2)
(748,146,2)
(466,631,2)
(866,398,2)
(315,398,2)
(633,830,2)
(708,96,2)
(590,311,2)
(185,673,2)
(651,491,2)
(683,139,2)
(185,367,2)
(848,873,2)
(378,462,2)
(550,443,2)
(141,826,2)
(360,197,2)
(199,729,2)
(265,830,2)
(469,398,2)
(583,452,2)
(185,590,2)
(602,653,2)
(83,396,2)
(157,544,2)
(469,366,2)
(561,766,2)
(529,396,2)
(336,642,2)
(355,157,2)
(0,313,2)
(661,487,2)
(28,192,2)
(357,459,2)
(579,396,2)
(448,846,2)
(386,396,2)
(197,653,2)
(230,157,2)
(456,151,2)
(15,396,2)
(93,396,2)
(202,172,2)
(648,337,2)
(636,25,2)
(703,703,2)
(149,133,2)
(99,830,2)
(138,35,2)
(842,396,2)
(487,399,2)
(184,871,2)
(846,538,2)
(581,396,2)
(401,452,2)
(346,196,2)
(57,837,2)
(461,766,2)
(273,374,2)
(240,601,2)
(715,258,2)
(246,172,2)
(372,157,2)
(89,396,2)
(800,258,2)
(745,68,2)
(388,477,2)
(735,812,2)
(847,826,2)
(603,812,2)
(443,67,2)
(185,846,2)
(871,213,2)
(0,601,2)
(403,396,2)
(391,819,2)
(895,157,2)
(548,396,2)
(422,464,2)
(223,783,2)
(462,538,2)
(845,157,2)
(673,133,2)
(86,6,2)
(764,157,2)
(564,172,2)
(12,452,2)
(168,371,2)
(356,826,2)
(338,190,2)
(136,219,2)
(82,839,2)
(778,734,2)
(185,772,2)
(272,498,2)
(633,626,2)
(797,157,2)
(697,812,2)
(218,396,2)
(544,848,2)
(364,826,2)
(759,457,2)
(595,783,2)
(843,826,2)
(197,602,2)
(339,683,2)
(93,157,2)
(638,837,2)
(606,538,2)
(83,157,2)
(374,728,2)
(429,157,2)
(598,844,2)
(482,396,2)
(270,213,2)
(96,692,2)
(318,172,2)
(844,89,2)
(68,89,2)
(808,662,2)
(539,839,2)
(358,25,2)
(216,157,2)
(793,198,2)
(808,464,2)
(725,452,2)
(452,396,2)
(116,255,2)
(360,653,2)
(746,157,2)
(158,95,2)
(568,826,2)
(888,491,2)
(824,464,2)
(64,844,2)
(223,55,2)
(504,396,2)
(626,830,2)
(220,464,2)
(448,560,2)
(674,398,2)
(185,314,2)
(893,826,2)
(176,826,2)
(226,89,2)
(627,396,2)
(388,601,2)
(177,398,2)
(749,476,2)
(479,396,2)
(597,837,2)
(634,601,2)
(145,826,2)
(681,729,2)
(352,837,2)
(659,826,2)
(18,258,2)
(139,375,2)
(264,830,2)
(698,826,2)
(460,452,2)
(243,839,2)
(690,313,2)
(221,157,2)
(326,826,2)
(730,157,2)
(497,396,2)
(219,839,2)
(736,431,2)
(670,653,2)
(414,683,2)
(855,648,2)
(293,812,2)
(176,596,2)
(77,160,2)
(274,133,2)
(215,68,2)
(619,631,2)
(240,464,2)
(818,396,2)
(718,126,2)
(611,812,2)
(439,133,2)
(510,258,2)
(627,157,2)
(213,61,2)
(109,398,2)
(756,766,2)
(877,243,2)
(590,133,2)
(86,49,2)
(662,572,2)
(428,133,2)
(846,830,2)
(385,830,2)
(889,398,2)
(543,808,2)
(595,464,2)
(142,812,2)
(616,396,2)
(609,459,2)
(66,157,2)
(606,683,2)
(185,315,2)
(774,396,2)
(124,467,2)
(817,285,2)
(298,313,2)
(625,812,2)
(819,839,2)
(126,762,2)
(636,642,2)
(448,396,2)
(449,844,2)
(758,556,2)
(614,157,2)
(421,398,2)
(411,133,2)
(457,407,2)
(683,87,2)
(470,838,2)
(11,837,2)
(744,350,2)
(180,830,2)
(837,819,2)
(858,446,2)
(39,313,2)
(348,396,2)
(734,258,2)
(773,157,2)
(632,249,2)
(761,396,2)
(822,354,2)
(697,826,2)
(398,398,2)
(730,396,2)
(695,826,2)
(702,593,2)
(848,561,2)
(803,172,2)
(778,258,2)
(191,396,2)
(726,258,2)
(185,528,2)
(80,258,2)
(118,675,2)
(568,812,2)
(659,812,2)
(473,398,2)
(320,198,2)
(280,157,2)
(701,396,2)
(456,396,2)
(185,881,2)
(795,396,2)
(213,572,2)
(643,396,2)
(300,837,2)
(6,6,2)
(579,157,2)
(666,157,2)
(571,683,2)
(506,837,2)
(245,446,2)
(131,873,2)
(884,839,2)
(503,839,2)
(448,91,2)
(657,598,2)
(486,398,2)
(81,491,2)
(826,518,2)
(266,826,2)
(691,126,2)
(109,538,2)
(559,826,2)
(332,456,2)
(333,398,2)
(251,452,2)
(721,729,2)
(164,258,2)
(802,168,2)
(825,631,2)
(204,826,2)
(741,662,2)
(390,396,2)
(218,491,2)
(419,396,2)
(177,366,2)
(841,398,2)
(87,87,2)
(314,414,2)
(156,839,2)
(554,703,2)
(338,498,2)
(759,138,2)
(827,157,2)
(649,133,2)
(183,157,2)
(129,826,2)
(410,68,2)
(353,648,2)
(643,464,2)
(151,157,2)
(223,464,2)
(68,572,2)
(34,520,2)
(501,498,2)
(448,778,2)
(558,708,2)
(150,830,2)
(337,642,2)
(820,826,2)
(571,538,2)
(255,826,2)
(329,766,2)
(326,812,2)
(816,157,2)
(268,772,2)
(354,95,2)
(652,467,2)
(618,812,2)
(615,585,2)
(440,812,2)
(107,491,2)
(185,500,2)
(602,491,2)
(443,108,2)
(857,839,2)
(704,477,2)
(833,657,2)
(67,157,2)
(852,812,2)
(742,839,2)
(123,830,2)
(240,642,2)
(222,683,2)
(740,157,2)
(368,812,2)
(313,812,2)
(717,826,2)
(813,258,2)
(346,457,2)
(138,459,2)
(790,780,2)
(110,683,2)
(656,812,2)
(295,452,2)
(185,460,2)
(275,172,2)
(677,837,2)
(322,399,2)
(637,157,2)
(198,464,2)
(103,812,2)
(71,830,2)
(375,157,2)
(784,398,2)
(734,683,2)
(871,85,2)
(198,463,2)
(692,425,2)
(336,826,2)
(73,396,2)
(692,73,2)
(337,675,2)
(314,258,2)
(390,157,2)
(7,826,2)
(818,433,2)
(821,258,2)
(819,679,2)
(737,585,2)
(628,628,2)
(566,396,2)
(701,834,2)
(485,157,2)
(749,133,2)
(872,398,2)
(829,374,2)
(447,133,2)
(254,396,2)
(354,830,2)
(89,93,2)
(479,491,2)
(61,126,2)
(808,783,2)
(170,491,2)
(786,398,2)
(821,683,2)
(265,869,2)
(842,157,2)
(87,327,2)
(701,157,2)
(412,826,2)
(66,701,2)
(838,213,2)
(154,396,2)
(368,491,2)
(175,564,2)
(610,119,2)
(437,839,2)
(629,258,2)
(293,45,2)
(119,157,2)
(548,157,2)
(678,491,2)
(733,585,2)
(340,812,2)
(823,839,2)
(733,793,2)
(166,258,2)
(697,618,2)
(703,556,2)
(867,339,2)
(502,126,2)
(191,157,2)
(555,247,2)
(265,538,2)
(90,433,2)
(150,95,2)
(808,383,2)
(589,653,2)
(398,366,2)
(119,878,2)
(693,766,2)
(404,848,2)
(231,491,2)
(824,826,2)
(560,398,2)
(342,157,2)
(497,157,2)
(750,172,2)
(448,314,2)
(782,858,2)
(319,826,2)
(188,464,2)
(115,157,2)
(840,172,2)
(897,124,2)
(711,398,2)
(546,826,2)
(366,61,2)
(814,157,2)
(880,837,2)
(354,556,2)
(360,431,2)
(682,157,2)
(16,157,2)
(162,133,2)
(454,396,2)
(685,812,2)
(221,83,2)
(789,157,2)
(197,601,2)
(302,157,2)
(809,837,2)
(187,400,2)
(555,826,2)
(285,826,2)
(344,554,2)
(448,606,2)
(66,396,2)
(305,826,2)
(643,446,2)
(329,464,2)
(214,837,2)
(752,396,2)
(188,837,2)
(268,348,2)
(520,556,2)
(240,400,2)
(797,433,2)
(18,556,2)
(397,433,2)
(660,396,2)
(849,396,2)
(643,400,2)
(635,133,2)
(185,222,2)
(441,826,2)
(856,839,2)
(409,348,2)
(757,812,2)
(772,433,2)
(720,826,2)
(411,158,2)
(648,675,2)
(891,313,2)
(448,340,2)
(895,396,2)
(810,313,2)
(222,830,2)
(759,265,2)
(517,396,2)
(431,396,2)
(498,396,2)
(530,157,2)
(859,837,2)
(622,542,2)
(161,491,2)
(610,491,2)
(427,844,2)
(245,642,2)
(496,467,2)
(794,826,2)
(446,350,2)
(125,642,2)
(528,398,2)
(563,826,2)
(182,543,2)
(151,491,2)
(143,459,2)
(374,157,2)
(864,25,2)
(621,350,2)
(226,29,2)
(35,459,2)
(73,157,2)
(616,491,2)
(268,232,2)
(388,394,2)
(78,126,2)
(653,170,2)
(632,690,2)
(21,812,2)
(381,452,2)
(593,491,2)
(41,396,2)
(758,258,2)
(83,433,2)
(879,837,2)
(394,491,2)
(253,774,2)
(887,826,2)
(375,616,2)
(448,231,2)
(180,683,2)
(738,826,2)
(200,595,2)
(85,433,2)
(520,95,2)
(217,157,2)
(534,172,2)
(811,396,2)
(219,397,2)
(826,157,2)
(77,601,2)
(212,126,2)
(647,812,2)
(539,819,2)
(105,396,2)
(37,812,2)
(520,133,2)
(337,446,2)
(703,219,2)
(259,258,2)
(425,614,2)
(504,157,2)
(1,157,2)
(49,823,2)
(574,839,2)
(634,396,2)
(206,157,2)
(394,477,2)
(268,460,2)
(603,179,2)
(895,797,2)
(361,459,2)
(853,830,2)
(115,396,2)
(205,839,2)
(758,542,2)
(170,431,2)
(67,221,2)
(416,844,2)
(654,477,2)
(666,396,2)
(751,452,2)
(658,491,2)
(862,812,2)
(656,826,2)
(168,198,2)
(518,183,2)
(477,748,2)
(431,400,2)
(886,538,2)
(125,220,2)
(715,622,2)
(213,708,2)
(883,812,2)
(850,157,2)
(431,157,2)
(463,491,2)
(172,628,2)
(30,675,2)
(56,396,2)
(187,812,2)
(106,850,2)
(832,728,2)
(2,313,2)
(245,812,2)
(136,819,2)
(348,374,2)
(502,691,2)
(632,145,2)
(298,826,2)
(121,157,2)
(22,812,2)
(462,683,2)
(703,398,2)
(86,327,2)
(389,839,2)
(176,446,2)
(820,812,2)
(645,396,2)
(727,542,2)
(748,345,2)
(250,452,2)
(556,49,2)
(288,25,2)
(448,590,2)
(6,837,2)
(180,297,2)
(603,400,2)
(624,157,2)
(892,631,2)
(280,396,2)
(210,491,2)
(652,136,2)
(881,541,2)
(838,267,2)
(708,832,2)
(446,621,2)
(423,258,2)
(448,315,2)
(448,776,2)
(158,556,2)
(858,642,2)
(107,729,2)
(46,348,2)
(734,538,2)
(373,477,2)
(231,730,2)
(60,89,2)
(733,337,2)
(150,96,2)
(179,826,2)
(56,479,2)
(89,782,2)
(466,459,2)
(249,826,2)
(293,783,2)
(163,766,2)
(829,96,2)
(339,538,2)
(776,256,2)
(348,829,2)
(612,839,2)
(538,133,2)
(155,839,2)
(812,826,2)
(365,374,2)
(31,258,2)
(827,396,2)
(729,449,2)
(632,826,2)
(239,826,2)
(542,542,2)
(38,662,2)
(665,730,2)
(154,491,2)
(791,766,2)
(443,157,2)
(74,780,2)
(476,95,2)
(366,172,2)
(462,258,2)
(393,812,2)
(448,239,2)
(508,6,2)
(804,491,2)
(251,210,2)
(205,322,2)
(448,528,2)
(63,826,2)
(883,601,2)
(336,446,2)
(781,871,2)
(238,601,2)
(643,601,2)
(634,56,2)
(403,157,2)
(493,258,2)
(56,400,2)
(408,313,2)
(608,826,2)
(131,888,2)
(325,819,2)
(673,110,2)
(706,826,2)
(6,677,2)
(48,157,2)
(476,556,2)
(148,703,2)
(43,491,2)
(366,572,2)
(185,239,2)
(353,675,2)
(108,396,2)
(645,157,2)
(459,459,2)
(6,508,2)
(247,433,2)
(783,388,2)
(350,122,2)
(573,25,2)
(86,139,2)
(238,812,2)
(249,313,2)
(575,837,2)
(396,157,2)
(833,844,2)
(519,133,2)
(407,683,2)
(192,812,2)
(677,371,2)
(210,452,2)
(887,812,2)
(871,783,2)
(610,131,2)
(74,449,2)
(323,225,2)
(886,683,2)
(172,188,2)
(223,837,2)
(192,189,2)
(675,184,2)
(167,157,2)
(628,172,2)
(530,396,2)
(353,537,2)
(422,783,2)
(868,157,2)
(799,830,2)
(185,232,2)
(34,133,2)
(66,895,2)
(682,396,2)
(142,697,2)
(662,124,2)
(28,187,2)
(185,231,2)
(243,433,2)
(225,89,2)
(244,837,2)
(554,398,2)
(14,126,2)
(61,502,2)
(408,826,2)
(605,538,2)
(768,89,2)
(87,332,2)
(374,396,2)
(894,258,2)
(668,89,2)
(477,345,2)
(671,258,2)
(651,225,2)
(232,491,2)
(541,683,2)
(850,788,2)
(501,190,2)
(108,433,2)
(311,538,2)
(522,258,2)
(182,124,2)
(885,826,2)
(413,89,2)
(771,844,2)
(890,157,2)
(108,157,2)
(522,727,2)
(240,454,2)
(621,804,2)
(878,687,2)
(24,398,2)
(882,839,2)
(84,452,2)
(735,826,2)
(51,830,2)
(760,830,2)
(694,837,2)
(544,43,2)
(663,498,2)
(896,498,2)
(158,96,2)
(811,157,2)
(865,830,2)
(284,313,2)
(564,861,2)
(207,431,2)
(891,826,2)
(634,157,2)
(258,258,2)
(594,348,2)
(417,399,2)
(643,642,2)
(363,837,2)
(711,564,2)
(27,126,2)
(470,708,2)
(818,157,2)
(604,839,2)
(62,662,2)
(39,826,2)
(643,157,2)
(875,213,2)
(82,819,2)
(3,758,2)
(802,332,2)
(339,633,2)
(580,157,2)
(683,837,2)
(696,396,2)
(194,812,2)
(532,220,2)
(877,441,2)
(8,826,2)
(662,61,2)
(196,728,2)
(828,837,2)
(122,573,2)
(878,766,2)
(686,830,2)
(476,728,2)
(672,826,2)
(545,213,2)
(185,729,2)
(783,477,2)
(216,396,2)
(65,766,2)
(873,766,2)
(648,733,2)
(279,398,2)
(125,446,2)
(546,313,2)
(659,491,2)
(109,683,2)
(463,585,2)
(276,335,2)
(132,350,2)
(67,396,2)
(153,491,2)
(748,257,2)
(327,139,2)
(282,350,2)
(788,157,2)
(817,249,2)
(762,67,2)
(608,812,2)
(643,218,2)
(396,610,2)
(185,717,2)
(20,812,2)
(152,467,2)
(379,830,2)
(86,508,2)
(581,157,2)
(429,396,2)
(160,81,2)
(789,396,2)
(578,766,2)
(687,642,2)
(572,126,2)
(448,39,2)
(329,601,2)
(607,812,2)
(220,783,2)
(443,396,2)
(68,61,2)
(142,368,2)
(85,213,2)
(624,396,2)
(629,631,2)
(622,258,2)
(457,830,2)
(628,564,2)
(613,337,2)
(335,826,2)
(495,826,2)
(679,839,2)
(290,396,2)
(678,157,2)
(453,157,2)
(528,109,2)
(560,886,2)
(498,190,2)
(776,398,2)
(499,491,2)
(19,96,2)
(424,837,2)
(490,830,2)
(593,268,2)
(159,157,2)
(714,730,2)
(837,136,2)
(151,396,2)
(88,871,2)
(849,157,2)
(306,133,2)
(16,396,2)
(95,459,2)
(352,172,2)
(851,459,2)
(571,830,2)
(700,839,2)
(804,350,2)
(286,812,2)
(822,138,2)
(559,812,2)
(414,538,2)
(472,766,2)
(256,398,2)
(511,116,2)
(669,396,2)
(248,313,2)
(346,830,2)
(182,662,2)
(415,136,2)
(580,396,2)
(187,384,2)
(229,812,2)
(349,830,2)
(35,95,2)
(500,812,2)
(698,313,2)
(454,157,2)
(653,431,2)
(626,138,2)
(860,396,2)
(2,826,2)
(149,138,2)
(29,89,2)
(508,49,2)
(240,783,2)
(350,25,2)
(330,837,2)
(480,313,2)
(730,431,2)
(467,728,2)
(179,491,2)
(769,452,2)
(61,67,2)
(448,717,2)
(95,556,2)
(445,839,2)
(329,783,2)
(276,555,2)
(796,830,2)
(412,313,2)
(441,642,2)
(795,157,2)
(18,542,2)
(253,461,2)
(146,345,2)
(535,812,2)
(40,812,2)
(490,822,2)
(152,182,2)
(8,313,2)
(556,172,2)
(797,396,2)
(176,642,2)
(308,648,2)
(658,452,2)
(293,464,2)
(614,396,2)
(819,819,2)
(499,348,2)
(605,490,2)
(116,176,2)
(180,538,2)
(599,826,2)
(241,400,2)
(846,683,2)
(332,157,2)
(621,400,2)
(95,95,2)
(869,830,2)
(257,464,2)
(232,730,2)
(630,844,2)
(116,826,2)
(145,491,2)
(10,812,2)
(798,345,2)
(305,313,2)
(239,313,2)
(335,433,2)
(632,313,2)
(607,436,2)
(119,153,2)
(603,826,2)
(237,832,2)
(77,844,2)
(192,446,2)
(436,812,2)
(128,830,2)
(839,856,2)
(543,662,2)
(574,433,2)
(402,53,2)
(690,491,2)
(508,508,2)
(184,433,2)
(772,452,2)
(327,332,2)
(147,730,2)
(773,396,2)
(240,159,2)
(451,538,2)
(514,93,2)
(468,844,2)
(303,77,2)
(371,452,2)
(763,844,2)
(22,826,2)
(227,133,2)
(692,157,2)
(542,219,2)
(327,837,2)
(805,830,2)
(451,683,2)
(356,313,2)
(122,25,2)
(600,826,2)
(164,564,2)
(720,812,2)
(181,157,2)
(465,830,2)
(258,631,2)
(29,491,2)
(327,87,2)
(732,830,2)
(19,398,2)
(72,366,2)
(690,826,2)
(508,837,2)
(157,766,2)
(351,396,2)
(838,871,2)
(29,268,2)
(334,337,2)
(383,433,2)
(367,821,2)
(402,826,2)
(537,399,2)
(160,400,2)
(174,826,2)
(32,826,2)
(284,826,2)
(49,839,2)
(618,559,2)
(139,157,2)
(141,313,2)
(6,49,2)
(299,198,2)
(430,595,2)
(15,157,2)
(133,112,2)
(817,826,2)
(35,572,2)
(126,157,2)
(297,830,2)
(882,433,2)
(839,441,2)
(575,433,2)
(559,601,2)
(185,571,2)
(124,96,2)
(146,491,2)
(792,491,2)
(185,378,2)
(727,556,2)
(495,313,2)
(595,93,2)
(402,812,2)
(890,396,2)
(511,139,2)
(631,366,2)
(518,832,2)
(767,220,2)
(448,881,2)
(856,679,2)
(856,856,2)
(80,18,2)
(677,433,2)
(267,353,2)
(135,124,2)
(557,830,2)
(255,783,2)
(185,606,2)
(185,91,2)
(4,396,2)
(234,313,2)
(576,839,2)
(460,433,2)
(814,396,2)
(687,766,2)
(598,491,2)
(448,500,2)
(652,152,2)
(561,491,2)
(28,293,2)
(235,844,2)
(230,396,2)
(843,812,2)
(233,830,2)
(641,830,2)
(823,574,2)
(448,460,2)
(861,172,2)
(111,766,2)
(692,396,2)
(286,826,2)
(268,231,2)
(441,446,2)
(719,112,2)
(228,133,2)
(617,819,2)
(607,20,2)
(133,459,2)
(529,157,2)
(517,157,2)
(484,133,2)
(102,832,2)
(518,426,2)
(471,830,2)
(315,784,2)
(106,157,2)
(724,837,2)
(3,258,2)
(331,157,2)
(766,125,2)
(834,396,2)
(680,459,2)
(112,459,2)
(525,585,2)
(95,219,2)
(538,538,2)
(168,433,2)
(453,396,2)
(386,157,2)
(448,222,2)
(407,633,2)
(203,830,2)
(824,783,2)
(192,642,2)
(867,112,2)
(351,157,2)
(513,848,2)
(367,258,2)
(86,880,2)
(869,759,2)
(271,830,2)
(567,830,2)
(448,673,2)
(150,556,2)
(93,27,2)
(419,157,2)
(204,839,2)
(303,844,2)
(746,396,2)
(822,457,2)
(36,837,2)
(695,313,2)
(657,303,2)
(175,459,2)
(208,708,2)
(196,830,2)
(126,396,2)
(257,345,2)
(821,538,2)
(588,133,2)
(717,313,2)
(793,802,2)
(679,877,2)
(606,830,2)
(844,226,2)
(331,396,2)
(542,556,2)
(582,766,2)
(172,837,2)
(167,396,2)
(336,313,2)
(834,433,2)
(209,730,2)
(142,826,2)
(675,642,2)
(542,258,2)
(710,258,2)
(412,249,2)
(683,327,2)
(691,433,2)
(454,491,2)
(70,812,2)
(807,826,2)
(158,133,2)
(217,396,2)
(296,839,2)
(729,844,2)
(383,662,2)
(79,498,2)
(599,812,2)
(178,157,2)
(622,556,2)
(782,93,2)
(398,564,2)
(783,464,2)
(162,451,2)
(218,707,2)
(422,812,2)
(269,258,2)
(556,508,2)
(623,396,2)
(110,133,2)
(856,441,2)
(775,258,2)
(822,605,2)
(181,396,2)
(826,396,2)
(117,193,2)
(339,112,2)
(432,653,2)
(521,826,2)
(35,556,2)
(782,595,2)
(256,538,2)
(832,183,2)
(185,778,2)
(359,826,2)
(727,258,2)
(43,848,2)
(816,396,2)
(159,491,2)
(402,792,2)
(283,839,2)
(335,251,2)
(100,830,2)
(575,371,2)
(747,345,2)
(540,398,2)
(317,345,2)
(240,446,2)
(25,324,2)
(253,448,2)
(265,683,2)
(425,396,2)
(196,556,2)
(753,826,2)
(311,683,2)
(122,636,2)
-----------------------------------
(0,rect.x = x)
(1,height)
(2,width)
(3,*destPtr++ = srcPtr[alphaOffset])
(4,greenOffset)
(5,if (ImgPhotoSetSize(masterPtr, MAX(xEnd, masterPtr->width)
(6,srcLinePtr += blockPtr->pitch)
(7,blockPtr)
(8,height)
(9,ditherX)
(10,masterPtr)
(11,pitch)
(12,masterPtr)
(13,1)
(14,blockPtr)
(15,masterPtr)
(16,masterPtr)
(17,newAlpha)
(18,srcPtr[greenOffset])
(19,srcPtr[blueOffset])
(20,masterPtr->validRegion)
(21,width)
(22,x)
(23,wLeft)
(24,greenOffset)
(25,masterPtr->userHeight != 0)
(26,hCopy)
(27,sourceIsSimplePhoto = 1)
(28,TkpBuildRegionFromAlphaData(masterPtr->validRegion, (unsigned)
(29,masterPtr->flags)
(30,height)
(31,alphaOffset)
(32,4)
(33,destPtr)
(34,*destPtr++ = srcPtr[0])
(35,srcPtr[alphaOffset])
(36,pitch)
(37,width)
(38,width)
(39,rect.height)
(40,rect)
(41,width)
(42,TCL_ERROR)
(43,masterPtr->height)
(44,srcPtr)
(45,unsigned)
(46,masterPtr)
(47,)
(48,blockPtr)
(49,srcLinePtr = blockPtr->pixelPtr + blockPtr->offset[0])
(50,)
(51,Alpha)
(52,0)
(53,unsigned)
(54,destPtr)
(55,size_t)
(56,y * masterPtr->width)
(57,blockPtr)
(58,1)
(59,0)
(60,alphaOffset)
(61,alphaOffset -= blockPtr->offset[0])
(62,blockPtr)
(63,goto recalculateValidRegion;)
(64,destLinePtr)
(65,xEnd)
(66,blockPtr->offset[1] - blockPtr->offset[0])
(67,alphaOffset = blockPtr->offset[3])
(68,alphaOffset != 0)
(69,)
(70,height)
(71,destPtr)
(72,continue;)
(73,blockPtr->offset[0])
(74,newAlpha != 255)
(75,if ((masterPtr->userWidth != 0)
(76,for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize)
(77,y * masterPtr->width + x)
(78,0)
(79,TK_PHOTO_ALLOC_FAILURE_MESSAGE)
(80,*destPtr++ = srcPtr[greenOffset])
(81,masterPtr->width)
(82,hCopy)
(83,blockPtr->offset)
(84,pitch)
(85,blockPtr->width)
(86,memcpy(destLinePtr, srcLinePtr, ((size_t)
(87,destLinePtr += pitch)
(88,blockPtr)
(89,!sourceIsSimplePhoto && (width == 1)
(90,blockPtr->width)
(91,rect.x)
(92,xEnd)
(93,!sourceIsSimplePhoto)
(94,masterPtr)
(95,srcPtr+=pixelSize)
(96,blueOffset = blockPtr->offset[2] - blockPtr->offset[0])
(97,pixelSize)
(98,)
(99,destPtr)
(100,destPtr)
(101,userWidth)
(102,blueOffset)
(103,y)
(104,validRegion)
(105,4)
(106,sameSrc = (blockPtr->pixelPtr == masterPtr->pix32)
(107,masterPtr->flags)
(108,blockPtr->pixelSize)
(109,destPtr++)
(110,destPtr++)
(111,xEnd)
(112,alpha == 255)
(113,if ((masterPtr->userHeight != 0)
(114,)
(115,blockPtr)
(116,(size_t)
(117,(PhotoMaster *)
(118,1)
(119,MAX(yEnd, masterPtr->height)
(120,recalculateValidRegion:)
(121,y)
(122,(y + height)
(123,destPtr)
(124,blueOffset == 2)
(125,height <= 0)
(126,(alphaOffset >= blockPtr->pixelSize)
(127,blockPtr)
(128,greenOffset)
(129,offset)
(130,masterPtr)
(131,MAX(xEnd, masterPtr->width)
(132,masterPtr)
(133,alpha == 255 || !destPtr[3])
(134,)
(135,3)
(136,pixelSize == 4)
(137,)
(138,alpha = srcPtr[alphaOffset])
(139,destLinePtr = masterPtr->pix32 + (y * masterPtr->width + x)
(140,)
(141,rect.y = y)
(142,masterPtr->pix32 + (y * masterPtr->width + x)
(143,wCopy)
(144,)
(145,masterPtr->validRegion)
(146,masterPtr->userWidth)
(147,masterPtr)
(148,srcPtr[0])
(149,*destPtr++ = alpha)
(150,srcPtr[blueOffset])
(151,masterPtr->width)
(152,(blueOffset == 2)
(153,masterPtr->height)
(154,masterPtr->height)
(155,srcLinePtr)
(156,height)
(157,(xEnd > masterPtr->width)
(158,srcPtr[blueOffset])
(159,masterPtr->width)
(160,y * masterPtr->width)
(161,masterPtr->validRegion)
(162,*destPtr++)
(163,height)
(164,--wCopy)
(165,0)
(166,destPtr)
(167,greenOffset)
(168,blockPtr->pitch)
(169,if (!sourceIsSimplePhoto && (width == 1)
(170,masterPtr->ditherY)
(171,if ((greenOffset != 0)
(172,wLeft > 0)
(173,)
(174,rect)
(175,--wCopy)
(176,(size_t)
(177,0)
(178,blockPtr)
(179,masterPtr->width)
(180,destPtr[1])
(181,blockPtr)
(182,(alphaOffset == 3)
(183,blockPtr->pixelSize == 4)
(184,blockPtr->height)
(185,masterPtr->flags |= COMPLEX_ALPHA)
(186,)
(187,(unsigned)
(188,wLeft = width)
(189,unsigned)
(190,Tcl_Interp *interp)
(191,y)
(192,(unsigned)
(193,Tk_PhotoHandle handle)
(194,compRule)
(195,)
(196,srcPtr[greenOffset])
(197,x < masterPtr->ditherX)
(198,width == masterPtr->width)
(199,COMPLEX_ALPHA)
(200,height)
(201,pix32)
(202,wCopy)
(203,3)
(204,hLeft)
(205,compRuleSet = (compRule == TK_PHOTO_COMPOSITE_SET)
(206,4)
(207,masterPtr)
(208,alphaOffset)
(209,y)
(210,masterPtr->pix32)
(211,alphaOffset)
(212,sourceIsSimplePhoto)
(213,alphaOffset == 3)
(214,width)
(215,flags)
(216,width)
(217,masterPtr->ditherY)
(218,(Tk_PhotoHandle)
(219,pixelSize = blockPtr->pixelSize)
(220,width <= 0)
(221,blockPtr->offset[3])
(222,destPtr[2])
(223,(size_t)
(224,masterPtr)
(225,(alphaOffset != 0)
(226,masterPtr->flags & COMPLEX_ALPHA)
(227,continue;)
(228,0)
(229,x)
(230,width)
(231,masterPtr->ditherY)
(232,masterPtr->ditherX)
(233,srcPtr)
(234,workRgn)
(235,3)
(236,if (compRule != TK_PHOTO_COMPOSITE_OVERLAY)
(237,2)
(238,(unsigned)
(239,rect.y)
(240,Tk_ImageChanged(masterPtr->tkMaster, x, y, width, height,\n\\n\\t    masterPtr->width, masterPtr->height)
(241,rect.y = y)
(242,)
(243,blockPtr->height)
(244,destLinePtr)
(245,rect.height = height)
(246,wCopy)
(247,blockPtr->offset)
(248,masterPtr)
(249,workRgn = TkCreateRegion()
(250,blockPtr)
(251,blockPtr->pixelPtr = masterPtr->pix32)
(252,)
(253,RET)
(254,offset)
(255,width * 4)
(256,destPtr++)
(257,x + width)
(258,wCopy>0)
(259,destPtr)
(260,255)
(261,)
(262,sameSrc)
(263,0)
(264,destPtr)
(265,destPtr[2])
(266,(unsigned)
(267,(height <= blockPtr->height)
(268,masterPtr->flags |= COLOR_IMAGE)
(269,wCopy)
(270,width)
(271,destPtr)
(272,interp)
(273,blueOffset)
(274,greenOffset)
(275,srcLinePtr)
(276,blockPtr->pixelPtr + blockPtr->offset[0])
(277,alphaOffset)
(278,if (alpha == 255 || !destPtr[3])
(279,srcPtr)
(280,x)
(281,height)
(282,height)
(283,blockPtr)
(284,workRgn)
(285,&rect)
(286,validRegion)
(287,pitch)
(288,masterPtr)
(289,)
(290,pixelSize)
(291,srcPtr)
(292,Alpha)
(293,(unsigned)
(294,yEnd)
(295,width)
(296,offset)
(297,destPtr[1] = PD_SRC_OVER(srcPtr[greenOffset], alpha,\n\\n\\t\\t\\t\\tdestPtr[1], Alpha)
(298,y)
(299,blockPtr)
(300,srcLinePtr)
(301,alphaOffset)
(302,0)
(303,(y * masterPtr->width + x)
(304,unsigned)
(305,masterPtr)
(306,destPtr)
(307,hLeft)
(308,TK_PHOTO_COMPOSITE_SET)
(309,)
(310,)
(311,destPtr++)
(312,width)
(313,compRule != TK_PHOTO_COMPOSITE_OVERLAY)
(314,*destPtr++)
(315,*destPtr++)
(316,if (sameSrc)
(317,userWidth)
(318,0)
(319,0)
(320,pitch)
(321,y)
(322,compRule == TK_PHOTO_COMPOSITE_SET)
(323,masterPtr)
(324,masterPtr->userHeight)
(325,pixelSize)
(326,y)
(327,destLinePtr += pitch)
(328,PhotoMaster *)
(329,x + width)
(330,srcLinePtr)
(331,2)
(332,pitch = masterPtr->width * 4)
(333,destPtr)
(334,0)
(335,blockPtr->pixelPtr)
(336,rect.height = height)
(337,height == 1)
(338,Tcl_ResetResult(interp)
(339,destPtr[3])
(340,rect.width)
(341,if (newAlpha && newAlpha != 255)
(342,pixelPtr)
(343,)
(344,*destPtr++ = srcPtr[greenOffset])
(345,masterPtr->userWidth != 0)
(346,PD_SRC_OVER(srcPtr[greenOffset], alpha,\n\\n\\t\\t\\t\\tdestPtr[1], Alpha)
(347,if (alphaOffset == 0)
(348,(greenOffset != 0)
(349,2)
(350,(masterPtr->userHeight != 0)
(351,y)
(352,wLeft)
(353,((height == 1)
(354,srcPtr[0])
(355,width)
(356,rect)
(357,srcPtr)
(358,height)
(359,validRegion)
(360,(y == masterPtr->ditherY)
(361,alpha)
(362,destLinePtr)
(363,continue;)
(364,masterPtr)
(365,0)
(366,alphaOffset == 0)
(367,*destPtr++)
(368,masterPtr->pix32)
(369,userHeight)
(370,if (alpha)
(371,blockPtr->pitch = masterPtr->width * 4)
(372,masterPtr)
(373,userWidth)
(374,greenOffset != 0)
(375,masterPtr->pix32 + (y * masterPtr->width + x)
(376,masterPtr->ditherY = y)
(377,alpha)
(378,*destPtr++)
(379,0)
(380,if (interp != NULL)
(381,4)
(382,)
(383,blockPtr->width)
(384,unsigned)
(385,alpha)
(386,masterPtr)
(387,width)
(388,masterPtr->userWidth - x)
(389,compRuleSet)
(390,height)
(391,hCopy)
(392,sourceIsSimplePhoto)
(393,x)
(394,masterPtr->userWidth)
(395,)
(396,ImgPhotoSetSize(masterPtr, MAX(xEnd, masterPtr->width)
(397,blockPtr->pixelSize)
(398,wCopy>0)
(399,int compRule)
(400,int y)
(401,pixelPtr)
(402,(unsigned)
(403,x)
(404,masterPtr)
(405,sourceIsSimplePhoto)
(406,0)
(407,destPtr[3])
(408,rect)
(409,flags)
(410,masterPtr)
(411,*destPtr++ = srcPtr[blueOffset])
(412,TkDestroyRegion(workRgn)
(413,masterPtr)
(414,destPtr++)
(415,greenOffset)
(416,destLinePtr[3])
(417,compRule &= ~SOURCE_IS_SIMPLE_ALPHA_PHOTO)
(418,for (; hCopy > 0; --hCopy)
(419,blueOffset)
(420,rect)
(421,wCopy)
(422,rect.width = width)
(423,srcPtr)
(424,4)
(425,blockPtr->offset[2])
(426,(blueOffset == 2)
(427,width)
(428,destPtr)
(429,blockPtr)
(430,1)
(431,y < masterPtr->ditherY)
(432,ditherX)
(433,register Tk_PhotoImageBlock *blockPtr)
(434,alpha)
(435,for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize)
(436,&rect)
(437,blockPtr)
(438,wCopy)
(439,destPtr)
(440,rect)
(441,hLeft = height)
(442,~SOURCE_IS_SIMPLE_ALPHA_PHOTO)
(443,alphaOffset >= blockPtr->pixelSize)
(444,validRegion)
(445,blockPtr)
(446,height = masterPtr->userHeight - y)
(447,blueOffset)
(448,return TCL_OK;)
(449,newAlpha = destLinePtr[3])
(450,yEnd)
(451,destPtr++)
(452,sameSrc)
(453,(y * masterPtr->width + x)
(454,masterPtr->tkMaster)
(455,if ((alphaOffset >= blockPtr->pixelSize)
(456,masterPtr->width * 4)
(457,Alpha = destPtr[3])
(458,)
(459,wCopy>0)
(460,blockPtr->pixelPtr)
(461,return TCL_OK;)
(462,destPtr++)
(463,masterPtr->width)
(464,int width)
(465,srcPtr)
(466,wCopy)
(467,greenOffset == 1)
(468,masterPtr)
(469,wCopy)
(470,(alphaOffset == 3)
(471,destPtr)
(472,TCL_OK)
(473,0)
(474,)
(475,workRgn)
(476,srcPtr[greenOffset])
(477,(masterPtr->userWidth != 0)
(478,rect)
(479,masterPtr->width)
(480,y)
(481,srcPtr)
(482,blockPtr)
(483,if ((blockPtr->pixelSize == 4)
(484,destPtr)
(485,masterPtr)
(486,destPtr)
(487,compRule & SOURCE_IS_SIMPLE_ALPHA_PHOTO)
(488,4)
(489,)
(490,destPtr[0] = PD_SRC_OVER(srcPtr[0], alpha, destPtr[0],\n\\n\\t\\t\\t\\tAlpha)
(491,masterPtr = (PhotoMaster *)
(492,if (alphaOffset)
(493,destPtr)
(494,pixelSize)
(495,workRgn)
(496,2)
(497,alphaOffset)
(498,interp != NULL)
(499,masterPtr->flags)
(500,rect.y)
(501,Tcl_AppendResult(interp, TK_PHOTO_ALLOC_FAILURE_MESSAGE, NULL)
(502,blockPtr->offset[0])
(503,hCopy)
(504,width)
(505,0)
(506,width)
(507,x)
(508,srcLinePtr += blockPtr->pitch)
(509,compRuleSet)
(510,blueOffset)
(511,memmove(destLinePtr, blockPtr->pixelPtr + blockPtr->offset[0],\n\\n\\t\\t((size_t)
(512,0)
(513,yEnd)
(514,width)
(515,masterPtr)
(516,y)
(517,masterPtr)
(518,(greenOffset == 1)
(519,srcPtr)
(520,srcPtr[0])
(521,blockPtr)
(522,*destPtr++ = srcPtr[0])
(523,pitch)
(524,)
(525,width)
(526,255)
(527,height)
(528,*destPtr++)
(529,height)
(530,y)
(531,blueOffset)
(532,height)
(533,newAlpha)
(534,wLeft)
(535,TK_PHOTO_COMPOSITE_OVERLAY)
(536,handle)
(537,compRule == TK_PHOTO_COMPOSITE_SET)
(538,destPtr += 4)
(539,0)
(540,pixelSize)
(541,destPtr++)
(542,srcPtr+=pixelSize)
(543,(width <= blockPtr->width)
(544,yEnd > masterPtr->height)
(545,width)
(546,workRgn)
(547,alphaOffset)
(548,offset)
(549,)
(550,alphaOffset)
(551,offset)
(552,userHeight)
(553,for (hLeft = height; hLeft > 0;)
(554,srcPtr[greenOffset])
(555,blockPtr->offset[0])
(556,srcPtr = srcLinePtr)
(557,alpha)
(558,3)
(559,y * masterPtr->width + x)
(560,*destPtr++)
(561,masterPtr->width)
(562,blueOffset)
(563,pix32)
(564,wCopy = MIN(wLeft, blockPtr->width)
(565,destPtr)
(566,alphaOffset)
(567,1)
(568,masterPtr)
(569,x)
(570,greenOffset)
(571,destPtr[0])
(572,alphaOffset = 0)
(573,masterPtr->userHeight)
(574,blockPtr->pixelPtr)
(575,blockPtr->pitch)
(576,pixelSize)
(577,NULL)
(578,masterPtr)
(579,destLinePtr)
(580,blockPtr->pixelSize)
(581,0)
(582,yEnd)
(583,pix32)
(584,srcPtr)
(585,x == 0)
(586,SOURCE_IS_SIMPLE_ALPHA_PHOTO)
(587,1)
(588,srcPtr)
(589,masterPtr)
(590,*destPtr++)
(591,)
(592,)
(593,masterPtr->flags)
(594,COLOR_IMAGE)
(595,width == 1)
(596,size_t)
(597,0)
(598,masterPtr->pix32)
(599,y)
(600,workRgn)
(601,int x)
(602,masterPtr->ditherX)
(603,y * masterPtr->width)
(604,hCopy)
(605,destPtr[0])
(606,destPtr[3])
(607,TkUnionRectWithRegion(&rect, masterPtr->validRegion,\n\\n\\t\\tmasterPtr->validRegion)
(608,width)
(609,pixelSize)
(610,ImgPhotoSetSize(masterPtr, MAX(xEnd, masterPtr->width)
(611,y)
(612,compRule)
(613,x)
(614,blockPtr->offset)
(615,masterPtr)
(616,masterPtr->pix32)
(617,4)
(618,(y * masterPtr->width + x)
(619,0)
(620,alpha)
(621,masterPtr->userHeight - y)
(622,srcPtr[blueOffset])
(623,1)
(624,pixelSize)
(625,width)
(626,PD_SRC_OVER_ALPHA(alpha, Alpha)
(627,4)
(628,wLeft -= wCopy)
(629,wCopy)
(630,4)
(631,compRuleSet)
(632,TkSubtractRegion(masterPtr->validRegion, workRgn,\n\\n\\t\\t    masterPtr->validRegion)
(633,destPtr[3] = PD_SRC_OVER_ALPHA(alpha, Alpha)
(634,y * masterPtr->width + x)
(635,alpha)
(636,y + height)
(637,pix32)
(638,destLinePtr)
(639,compRule)
(640,)
(641,blueOffset)
(642,int height)
(643,Tk_DitherPhoto((Tk_PhotoHandle)
(644,masterPtr)
(645,TCL_OK)
(646,Alpha)
(647,rect.height)
(648,(height == 1)
(649,destPtr)
(650,)
(651,ToggleComplexAlphaIfNeeded(masterPtr)
(652,(greenOffset == 1)
(653,y == masterPtr->ditherY)
(654,width)
(655,255)
(656,height)
(657,masterPtr->pix32 + (y * masterPtr->width + x)
(658,masterPtr->width)
(659,masterPtr->validRegion)
(660,width)
(661,sourceIsSimplePhoto = compRule & SOURCE_IS_SIMPLE_ALPHA_PHOTO)
(662,alphaOffset == 3)
(663,interp)
(664,blockPtr->offset[0])
(665,masterPtr)
(666,masterPtr)
(667,0)
(668,COMPLEX_ALPHA)
(669,blockPtr)
(670,x)
(671,srcPtr)
(672,rect)
(673,*destPtr++)
(674,*destPtr++ = srcPtr[0])
(675,height <= blockPtr->height)
(676,masterPtr)
(677,blockPtr->pitch)
(678,masterPtr->pix32)
(679,hCopy = MIN(hLeft, blockPtr->height)
(680,alphaOffset)
(681,masterPtr)
(682,tkMaster)
(683,destPtr = destLinePtr)
(684,ditherY)
(685,height)
(686,Alpha)
(687,y + height)
(688,width)
(689,if ((width <= 0)
(690,masterPtr->validRegion)
(691,blockPtr->offset)
(692,blockPtr->offset[2] - blockPtr->offset[0])
(693,width)
(694,wLeft)
(695,width)
(696,height)
(697,(y * masterPtr->width + x)
(698,height)
(699,masterPtr)
(700,blockPtr)
(701,blockPtr->offset[1])
(702,masterPtr->flags & COMPLEX_ALPHA)
(703,srcPtr+=pixelSize)
(704,x)
(705,srcLinePtr)
(706,destLinePtr)
(707,Tk_PhotoHandle)
(708,blueOffset == 2)
(709,srcPtr)
(710,0)
(711,--wCopy)
(712,if ((pixelSize == 4)
(713,y)
(714,masterPtr->ditherX = x)
(715,*destPtr++ = srcPtr[blueOffset])
(716,rect)
(717,rect.width)
(718,1)
(719,3)
(720,masterPtr)
(721,flags)
(722,masterPtr)
(723,if ((xEnd > masterPtr->width)
(724,destPtr)
(725,blockPtr)
(726,greenOffset)
(727,srcPtr[0])
(728,greenOffset = blockPtr->offset[1] - blockPtr->offset[0])
(729,newAlpha && newAlpha != 255)
(730,(y < masterPtr->ditherY)
(731,pitch)
(732,3)
(733,(x == 0)
(734,destPtr++)
(735,4)
(736,ditherY)
(737,width)
(738,height)
(739,)
(740,xEnd)
(741,width)
(742,hLeft)
(743,compRule)
(744,userHeight)
(745,COMPLEX_ALPHA)
(746,pitch)
(747,masterPtr)
(748,(x + width)
(749,*destPtr++ = srcPtr[greenOffset])
(750,wLeft)
(751,masterPtr)
(752,offset)
(753,hLeft)
(754,)
(755,if ((y < masterPtr->ditherY)
(756,x)
(757,rect.x)
(758,srcPtr[alphaOffset])
(759,PD_SRC_OVER(srcPtr[blueOffset], alpha,\n\\n\\t\\t\\t\\tdestPtr[2], Alpha)
(760,0)
(761,masterPtr)
(762,alphaOffset < 0)
(763,destLinePtr)
(764,sameSrc)
(765,*destPtr++ = 255)
(766,(width <= 0)
(767,0)
(768,flags)
(769,masterPtr->width * 4)
(770,hLeft)
(771,x)
(772,blockPtr->pitch)
(773,masterPtr)
(774,return TCL_ERROR;)
(775,srcPtr)
(776,*destPtr++)
(777,)
(778,*destPtr++)
(779,blockPtr)
(780,newAlpha)
(781,height)
(782,(width == 1)
(783,width = masterPtr->userWidth - x)
(784,destPtr++)
(785,greenOffset)
(786,destPtr)
(787,4)
(788,blockPtr->pixelPtr)
(789,0)
(790,newAlpha)
(791,y)
(792,masterPtr->width)
(793,(width == masterPtr->width)
(794,height)
(795,pix32)
(796,Alpha)
(797,blockPtr->offset)
(798,x)
(799,2)
(800,srcPtr)
(801,rect)
(802,blockPtr->pitch == pitch)
(803,width)
(804,masterPtr->userHeight)
(805,alpha)
(806,)
(807,TkCreateRegion()
(808,width <= blockPtr->width)
(809,pitch)
(810,x)
(811,x)
(812,alphaOffset)
(813,destPtr)
(814,blockPtr)
(815,for (wLeft = width; wLeft > 0;)
(816,sourceIsSimplePhoto)
(817,TkUnionRectWithRegion(&rect, workRgn, workRgn)
(818,blockPtr->offset)
(819,hCopy > 0)
(820,masterPtr)
(821,destPtr++)
(822,PD_SRC_OVER(srcPtr[0], alpha, destPtr[0],\n\\n\\t\\t\\t\\tAlpha)
(823,blockPtr->pixelPtr + blockPtr->offset[0])
(824,rect.width = width)
(825,continue;)
(826,(blockPtr->pixelSize == 4)
(827,3)
(828,destLinePtr)
(829,blueOffset != 0)
(830,alpha)
(831,masterPtr)
(832,greenOffset == 1)
(833,destLinePtr = masterPtr->pix32 + (y * masterPtr->width + x)
(834,blockPtr->offset)
(835,0)
(836,for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize)
(837,(pixelSize == 4)
(838,(width <= blockPtr->width)
(839,hLeft > 0)
(840,srcPtr)
(841,*destPtr++ = srcPtr[blueOffset])
(842,masterPtr)
(843,3)
(844,!(masterPtr->flags & COMPLEX_ALPHA)
(845,offset)
(846,destPtr[1])
(847,4)
(848,xEnd > masterPtr->width)
(849,ditherY)
(850,blockPtr->pixelPtr == masterPtr->pix32)
(851,srcPtr)
(852,rect)
(853,1)
(854,--hCopy)
(855,compRule)
(856,hLeft -= hCopy)
(857,pixelPtr)
(858,height == 1)
(859,srcLinePtr)
(860,interp)
(861,MIN(wLeft, blockPtr->width)
(862,validRegion)
(863,masterPtr->userWidth)
(864,y)
(865,Alpha)
(866,blueOffset)
(867,!destPtr[3])
(868,TCL_ERROR)
(869,destPtr[2] = PD_SRC_OVER(srcPtr[blueOffset], alpha,\n\\n\\t\\t\\t\\tdestPtr[2], Alpha)
(870,if (!(masterPtr->flags & COMPLEX_ALPHA)
(871,width <= blockPtr->width)
(872,srcPtr)
(873,xEnd = x + width)
(874,compRuleSet)
(875,blockPtr)
(876,srcPtr)
(877,MIN(hLeft, blockPtr->height)
(878,yEnd = y + height)
(879,destLinePtr)
(880,(size_t)
(881,*destPtr++)
(882,blockPtr->offset)
(883,rect.x = x)
(884,TK_PHOTO_COMPOSITE_SET)
(885,width)
(886,destPtr++)
(887,width)
(888,masterPtr->width)
(889,destPtr)
(890,offset)
(891,x)
(892,0)
(893,pixelPtr)
(894,pixelSize)
(895,blockPtr->offset[0])
(896,NULL)
(897,alphaOffset)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^