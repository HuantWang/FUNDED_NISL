-----label-----
0
-----code-----
static int shaper_msg_send(pid_t dst_pid, unsigned int prio,
    long double downrate, long double uprate) {
  unsigned int error_count = 0;
  int res;
  struct shaper_msg *msg;
  size_t msgsz = sizeof(unsigned int) + sizeof(long double) +
    sizeof(long double);

  msg = malloc(sizeof(struct shaper_msg) + msgsz - sizeof(msg->mtext));
  if (msg == NULL) {
    pr_log_pri(PR_LOG_ALERT, MOD_SHAPER_VERSION ": Out of memory!");
    pr_session_disconnect(&shaper_module, PR_SESS_DISCONNECT_NOMEM, NULL);
  }

  msg->mtype = dst_pid;
  memcpy(msg->mtext, &prio, sizeof(unsigned int));
  memcpy(msg->mtext + sizeof(unsigned int), &downrate, sizeof(long double));
  memcpy(msg->mtext + sizeof(unsigned int) + sizeof(long double), &uprate,
    sizeof(long double));

  /* Remove any old messages in the queue for the destination PID.  This
   * helps keep the queue clear and moving, more resistant to (inadvertent
   * or not) DoS situations.
   */
  shaper_msg_clear(dst_pid);

  while (msgsnd(shaper_qid, msg, msgsz, IPC_NOWAIT) < 0) {
    pr_signals_handle();

    if (errno != EAGAIN) {
      free(msg);
      return -1;

    } else {
      /* The EAGAIN error happens when there are too many bytes of messages
       * on the queue.  Check to see what the current number of messages
       * on the queue is, and log the error.
       *
       * If this error is hit too many times in a loop, we may need to give
       * up permanently.  (XXX in the future, if one queue is too small for
       * a busy daemon, look into a different queue allocation strategy.)
       */
      struct msqid_ds ds;

      if (msgctl(shaper_qid, IPC_STAT, &ds) < 0) {
        (void) pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,
          "error checking queue ID %d: %s", shaper_qid, strerror(errno));

      } else {
        (void) pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,
          "unable to send message to PID %lu via queue ID %d, max bytes (%lu) "
          "reached (%lu messages of %lu bytes currently in queue)",
          (unsigned long) dst_pid, shaper_qid, shaper_qmaxbytes,
          (unsigned long) ds.msg_qnum, (unsigned long) ds.msg_qnum * msgsz);
      }

      error_count++;
      if (error_count > SHAPER_MAX_SEND_ATTEMPTS) {
        free(msg);

        (void) pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,
          "unable to send message to PID %lu via queue ID %d after %u attempts "
          "(%u max attempts allowed), failing", (unsigned long) dst_pid,
          shaper_qid, error_count, SHAPER_MAX_SEND_ATTEMPTS);

        errno = EPERM;
        return -1;
      }
    }

  }
  free(msg);

  /* Send SIGUSR2 to the destination process, to let it know that it should
   * check the queue for messages.
   */
  PRIVS_ROOT
  res = kill(dst_pid, SIGUSR2);
  PRIVS_RELINQUISH

  if (res < 0) {
    if (errno == ESRCH) {
      shaper_msg_clear(dst_pid);

    } else {
      (void) pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,
        "error sending notice: %s", strerror(errno));
    }
  }

#if 0
  /* Handle our own signal, if necessary. */
  if (getpid() == dst_pid)
    pr_signals_handle();
#endif

  return 0;
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
3,7
3,8
5,6
5,7
6,7
8,9
10,11
10,12
12,13
14,15
14,16
16,17
18,19
18,20
20,21
22,23
22,24
22,25
22,26
22,27
22,28
22,29
22,30
22,31
22,32
22,33
22,34
22,35
22,36
22,37
22,38
22,39
22,40
23,24
24,25
24,26
26,27
26,28
28,29
30,31
31,32
31,33
33,34
35,36
36,37
36,38
37,38
39,40
39,41
42,43
43,44
43,45
44,45
46,47
46,48
48,49
49,50
49,51
50,51
50,52
51,52
52,53
52,54
55,56
56,57
56,58
59,60
60,61
60,62
63,64
64,65
64,66
65,66
67,68
67,69
68,69
70,71
70,72
71,72
71,73
72,73
73,74
73,75
74,75
77,78
79,80
80,81
81,82
81,83
82,83
85,86
85,87
86,87
86,88
87,88
89,90
91,92
91,93
92,93
93,94
94,95
94,96
94,97
94,98
95,96
97,98
98,99
100,101
102,103
104,105
105,106
105,107
106,107
106,108
107,108
110,111
112,113
113,114
113,115
113,116
113,117
114,115
116,117
116,118
117,118
120,121
121,122
123,124
124,125
124,126
127,128
128,129
128,130
128,131
128,132
129,130
131,132
131,133
132,133
132,134
133,134
136,137
137,138
137,139
140,141
141,142
143,144
144,145
144,146
147,148
148,149
148,150
148,151
148,152
149,150
151,152
151,153
152,153
152,154
153,154
153,155
154,155
157,158
158,159
158,160
161,162
162,163
162,164
165,166
166,167
168,169
169,170
169,171
172,173
173,174
173,175
174,175
176,177
178,179
178,180
179,180
179,181
180,181
180,182
180,183
180,184
180,185
181,182
183,184
185,186
187,188
189,190
192,193
192,194
193,194
194,195
195,196
197,198
197,199
197,200
198,199
198,200
199,200
201,202
203,204
203,205
204,205
205,206
205,207
206,207
208,209
210,211
211,212
213,214
213,215
213,216
213,217
214,215
215,216
215,217
216,217
218,219
220,221
220,222
220,223
221,222
221,223
222,223
222,224
222,225
222,226
223,224
225,226
227,228
229,230
230,231
233,234
234,235
235,236
235,237
236,237
236,238
239,240
239,241
239,242
239,243
239,244
239,245
240,241
242,243
244,245
247,248
249,250
249,251
250,251
252,253
254,255
255,256
256,257
256,258
257,258
257,259
260,261
260,262
260,263
260,264
260,265
260,266
260,267
260,268
260,269
261,262
263,264
265,266
268,269
268,270
269,270
269,271
272,273
274,275
276,277
278,279
278,280
279,280
279,281
282,283
282,284
283,284
286,287
286,288
287,288
287,289
288,289
288,290
291,292
291,293
292,293
295,296
297,298
298,299
299,300
301,302
301,303
302,303
302,304
303,304
305,306
307,308
307,309
307,310
307,311
308,309
309,310
309,311
310,311
312,313
314,315
315,316
315,317
316,317
316,318
319,320
319,321
319,322
319,323
319,324
319,325
319,326
319,327
320,321
322,323
324,325
327,328
327,329
328,329
328,330
331,332
333,334
335,336
337,338
339,340
340,341
340,342
341,342
343,344
345,346
346,347
348,349
349,350
349,351
350,351
352,353
354,355
355,356
355,357
356,357
358,359
358,360
360,361
361,362
361,363
361,364
362,363
364,365
366,367
368,369
369,370
371,372
372,373
372,374
373,374
373,375
374,375
377,378
378,379
378,380
378,381
379,380
379,381
380,381
382,383
384,385
385,386
386,387
386,388
387,388
389,390
391,392
392,393
393,394
393,395
394,395
394,396
397,398
397,399
397,400
397,401
397,402
398,399
400,401
402,403
405,406
405,407
406,407
408,409
410,411
-----nextToken-----
2,4,7,9,11,13,15,17,19,21,25,27,29,32,34,38,40,41,45,47,53,54,57,58,61,62,66,69,75,76,78,83,84,88,90,96,99,101,103,108,109,111,115,118,119,122,125,126,130,134,135,138,139,142,145,146,150,155,156,159,160,163,164,167,170,171,175,177,182,184,186,188,190,191,196,200,202,207,209,212,217,219,224,226,228,231,232,237,238,241,243,245,246,248,251,253,258,259,262,264,266,267,270,271,273,275,277,280,281,284,285,289,290,293,294,296,300,304,306,311,313,317,318,321,323,325,326,329,330,332,334,336,338,342,344,347,351,353,357,359,363,365,367,370,375,376,381,383,388,390,395,396,399,401,403,404,407,409,411
-----computeFrom-----
49,50
49,51
50,51
50,52
64,65
64,66
70,71
70,72
71,72
71,73
86,87
86,88
105,106
105,107
131,132
131,133
151,152
151,153
152,153
152,154
179,180
179,181
198,199
198,200
221,222
221,223
286,287
286,288
302,303
302,304
340,341
340,342
373,374
373,375
379,380
379,381
-----guardedBy-----
90,103
226,248
306,338
304,336
-----guardedByNegation-----
200,342
226,275
231,293
381,409
-----lastLexicalUse-----
226,275
-----jump-----
226,275
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;BinaryExpression;BinaryExpression;TypeIdExpression;TypeId;SimpleDeclSpecifier;Declarator;TypeIdExpression;TypeId;SimpleDeclSpecifier;Declarator;TypeIdExpression;TypeId;SimpleDeclSpecifier;Declarator;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;BinaryExpression;BinaryExpression;TypeIdExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;IdExpression;Name;UnaryExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ProblemStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;TypeIdExpression;TypeId;SimpleDeclSpecifier;Declarator;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;TypeIdExpression;TypeId;SimpleDeclSpecifier;Declarator;UnaryExpression;IdExpression;Name;TypeIdExpression;TypeId;SimpleDeclSpecifier;Declarator;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;TypeIdExpression;TypeId;SimpleDeclSpecifier;Declarator;TypeIdExpression;TypeId;SimpleDeclSpecifier;Declarator;UnaryExpression;IdExpression;Name;TypeIdExpression;TypeId;SimpleDeclSpecifier;Declarator;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;WhileStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;UnaryExpression;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;IdExpression;Name;IdExpression;Name;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;FieldReference;IdExpression;Name;Name;BinaryExpression;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;UnaryExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;IdExpression;Name;ProblemStatement;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;LiteralExpression;
-----ast_node-----
static int shaper_msg_send(pid_t dst_pid, unsigned int prio,    long double downrate, long double uprate) {  unsigned int error_count = 0;  int res;  struct shaper_msg *msg;  size_t msgsz = sizeof(unsigned int) + sizeof(long double) +    sizeof(long double);  msg = malloc(sizeof(struct shaper_msg) + msgsz - sizeof(msg->mtext));  if (msg == NULL) {    pr_log_pri(PR_LOG_ALERT, MOD_SHAPER_VERSION ": Out of memory!");    pr_session_disconnect(&shaper_module, PR_SESS_DISCONNECT_NOMEM, NULL);  }  msg->mtype = dst_pid;  memcpy(msg->mtext, &prio, sizeof(unsigned int));  memcpy(msg->mtext + sizeof(unsigned int), &downrate, sizeof(long double));  memcpy(msg->mtext + sizeof(unsigned int) + sizeof(long double), &uprate,    sizeof(long double));  /* Remove any old messages in the queue for the destination PID.  This   * helps keep the queue clear and moving, more resistant to (inadvertent   * or not) DoS situations.   */  shaper_msg_clear(dst_pid);  while (msgsnd(shaper_qid, msg, msgsz, IPC_NOWAIT) < 0) {    pr_signals_handle();    if (errno != EAGAIN) {      free(msg);      return -1;    } else {      /* The EAGAIN error happens when there are too many bytes of messages       * on the queue.  Check to see what the current number of messages       * on the queue is, and log the error.       *       * If this error is hit too many times in a loop, we may need to give       * up permanently.  (XXX in the future, if one queue is too small for       * a busy daemon, look into a different queue allocation strategy.)       */      struct msqid_ds ds;      if (msgctl(shaper_qid, IPC_STAT, &ds) < 0) {        (void) pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,          "error checking queue ID %d: %s", shaper_qid, strerror(errno));      } else {        (void) pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,          "unable to send message to PID %lu via queue ID %d, max bytes (%lu) "          "reached (%lu messages of %lu bytes currently in queue)",          (unsigned long) dst_pid, shaper_qid, shaper_qmaxbytes,          (unsigned long) ds.msg_qnum, (unsigned long) ds.msg_qnum * msgsz);      }      error_count++;      if (error_count > SHAPER_MAX_SEND_ATTEMPTS) {        free(msg);        (void) pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,          "unable to send message to PID %lu via queue ID %d after %u attempts "          "(%u max attempts allowed), failing", (unsigned long) dst_pid,          shaper_qid, error_count, SHAPER_MAX_SEND_ATTEMPTS);        errno = EPERM;        return -1;      }    }  }  free(msg);  /* Send SIGUSR2 to the destination process, to let it know that it should   * check the queue for messages.   */  PRIVS_ROOT  res = kill(dst_pid, SIGUSR2);  PRIVS_RELINQUISH  if (res < 0) {    if (errno == ESRCH) {      shaper_msg_clear(dst_pid);    } else {      (void) pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,        "error sending notice: %s", strerror(errno));    }  }#if 0  /* Handle our own signal, if necessary. */  if (getpid() == dst_pid)    pr_signals_handle();#endif  return 0;}
static int
shaper_msg_send(pid_t dst_pid, unsigned int prio,    long double downrate, long double uprate)
shaper_msg_send
pid_t dst_pid
pid_t
pid_t
dst_pid
dst_pid
unsigned int prio
unsigned int
prio
prio
long double downrate
long double
downrate
downrate
long double uprate
long double
uprate
uprate
{  unsigned int error_count = 0;  int res;  struct shaper_msg *msg;  size_t msgsz = sizeof(unsigned int) + sizeof(long double) +    sizeof(long double);  msg = malloc(sizeof(struct shaper_msg) + msgsz - sizeof(msg->mtext));  if (msg == NULL) {    pr_log_pri(PR_LOG_ALERT, MOD_SHAPER_VERSION ": Out of memory!");    pr_session_disconnect(&shaper_module, PR_SESS_DISCONNECT_NOMEM, NULL);  }  msg->mtype = dst_pid;  memcpy(msg->mtext, &prio, sizeof(unsigned int));  memcpy(msg->mtext + sizeof(unsigned int), &downrate, sizeof(long double));  memcpy(msg->mtext + sizeof(unsigned int) + sizeof(long double), &uprate,    sizeof(long double));  /* Remove any old messages in the queue for the destination PID.  This   * helps keep the queue clear and moving, more resistant to (inadvertent   * or not) DoS situations.   */  shaper_msg_clear(dst_pid);  while (msgsnd(shaper_qid, msg, msgsz, IPC_NOWAIT) < 0) {    pr_signals_handle();    if (errno != EAGAIN) {      free(msg);      return -1;    } else {      /* The EAGAIN error happens when there are too many bytes of messages       * on the queue.  Check to see what the current number of messages       * on the queue is, and log the error.       *       * If this error is hit too many times in a loop, we may need to give       * up permanently.  (XXX in the future, if one queue is too small for       * a busy daemon, look into a different queue allocation strategy.)       */      struct msqid_ds ds;      if (msgctl(shaper_qid, IPC_STAT, &ds) < 0) {        (void) pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,          "error checking queue ID %d: %s", shaper_qid, strerror(errno));      } else {        (void) pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,          "unable to send message to PID %lu via queue ID %d, max bytes (%lu) "          "reached (%lu messages of %lu bytes currently in queue)",          (unsigned long) dst_pid, shaper_qid, shaper_qmaxbytes,          (unsigned long) ds.msg_qnum, (unsigned long) ds.msg_qnum * msgsz);      }      error_count++;      if (error_count > SHAPER_MAX_SEND_ATTEMPTS) {        free(msg);        (void) pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,          "unable to send message to PID %lu via queue ID %d after %u attempts "          "(%u max attempts allowed), failing", (unsigned long) dst_pid,          shaper_qid, error_count, SHAPER_MAX_SEND_ATTEMPTS);        errno = EPERM;        return -1;      }    }  }  free(msg);  /* Send SIGUSR2 to the destination process, to let it know that it should   * check the queue for messages.   */  PRIVS_ROOT  res = kill(dst_pid, SIGUSR2);  PRIVS_RELINQUISH  if (res < 0) {    if (errno == ESRCH) {      shaper_msg_clear(dst_pid);    } else {      (void) pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,        "error sending notice: %s", strerror(errno));    }  }#if 0  /* Handle our own signal, if necessary. */  if (getpid() == dst_pid)    pr_signals_handle();#endif  return 0;}
unsigned int error_count = 0;
unsigned int error_count = 0;
unsigned int
error_count = 0
error_count
= 0
0
int res;
int res;
int
res
res
struct shaper_msg *msg;
struct shaper_msg *msg;
struct shaper_msg
shaper_msg
*msg
*
msg
size_t msgsz = sizeof(unsigned int) + sizeof(long double) +    sizeof(long double);
size_t msgsz = sizeof(unsigned int) + sizeof(long double) +    sizeof(long double);
size_t
size_t
msgsz = sizeof(unsigned int) + sizeof(long double) +    sizeof(long double)
msgsz
= sizeof(unsigned int) + sizeof(long double) +    sizeof(long double)
sizeof(unsigned int) + sizeof(long double) +    sizeof(long double)
sizeof(unsigned int) + sizeof(long double)
sizeof(unsigned int)
unsigned int
unsigned int

sizeof(long double)
long double
long double

sizeof(long double)
long double
long double

msg = malloc(sizeof(struct shaper_msg) + msgsz - sizeof(msg->mtext));
msg = malloc(sizeof(struct shaper_msg) + msgsz - sizeof(msg->mtext))
msg
msg
malloc(sizeof(struct shaper_msg) + msgsz - sizeof(msg->mtext))
malloc
malloc
sizeof(struct shaper_msg) + msgsz - sizeof(msg->mtext)
sizeof(struct shaper_msg) + msgsz
sizeof(struct shaper_msg)
struct shaper_msg
struct shaper_msg
shaper_msg

msgsz
msgsz
sizeof(msg->mtext)
(msg->mtext)
msg->mtext
msg
msg
mtext
if (msg == NULL) {    pr_log_pri(PR_LOG_ALERT, MOD_SHAPER_VERSION ": Out of memory!");    pr_session_disconnect(&shaper_module, PR_SESS_DISCONNECT_NOMEM, NULL);  }
msg == NULL
msg
msg
NULL
NULL
{    pr_log_pri(PR_LOG_ALERT, MOD_SHAPER_VERSION ": Out of memory!");    pr_session_disconnect(&shaper_module, PR_SESS_DISCONNECT_NOMEM, NULL);  }
pr_log_pri(PR_LOG_ALERT, MOD_SHAPER_VERSION ": Out of memory!");
pr_session_disconnect(&shaper_module, PR_SESS_DISCONNECT_NOMEM, NULL);
pr_session_disconnect(&shaper_module, PR_SESS_DISCONNECT_NOMEM, NULL)
pr_session_disconnect
pr_session_disconnect
&shaper_module
shaper_module
shaper_module
PR_SESS_DISCONNECT_NOMEM
PR_SESS_DISCONNECT_NOMEM
NULL
NULL
msg->mtype = dst_pid;
msg->mtype = dst_pid
msg->mtype
msg
msg
mtype
dst_pid
dst_pid
memcpy(msg->mtext, &prio, sizeof(unsigned int));
memcpy(msg->mtext, &prio, sizeof(unsigned int))
memcpy
memcpy
msg->mtext
msg
msg
mtext
&prio
prio
prio
sizeof(unsigned int)
unsigned int
unsigned int

memcpy(msg->mtext + sizeof(unsigned int), &downrate, sizeof(long double));
memcpy(msg->mtext + sizeof(unsigned int), &downrate, sizeof(long double))
memcpy
memcpy
msg->mtext + sizeof(unsigned int)
msg->mtext
msg
msg
mtext
sizeof(unsigned int)
unsigned int
unsigned int

&downrate
downrate
downrate
sizeof(long double)
long double
long double

memcpy(msg->mtext + sizeof(unsigned int) + sizeof(long double), &uprate,    sizeof(long double));
memcpy(msg->mtext + sizeof(unsigned int) + sizeof(long double), &uprate,    sizeof(long double))
memcpy
memcpy
msg->mtext + sizeof(unsigned int) + sizeof(long double)
msg->mtext + sizeof(unsigned int)
msg->mtext
msg
msg
mtext
sizeof(unsigned int)
unsigned int
unsigned int

sizeof(long double)
long double
long double

&uprate
uprate
uprate
sizeof(long double)
long double
long double

shaper_msg_clear(dst_pid);
shaper_msg_clear(dst_pid)
shaper_msg_clear
shaper_msg_clear
dst_pid
dst_pid
while (msgsnd(shaper_qid, msg, msgsz, IPC_NOWAIT) < 0) {    pr_signals_handle();    if (errno != EAGAIN) {      free(msg);      return -1;    } else {      /* The EAGAIN error happens when there are too many bytes of messages       * on the queue.  Check to see what the current number of messages       * on the queue is, and log the error.       *       * If this error is hit too many times in a loop, we may need to give       * up permanently.  (XXX in the future, if one queue is too small for       * a busy daemon, look into a different queue allocation strategy.)       */      struct msqid_ds ds;      if (msgctl(shaper_qid, IPC_STAT, &ds) < 0) {        (void) pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,          "error checking queue ID %d: %s", shaper_qid, strerror(errno));      } else {        (void) pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,          "unable to send message to PID %lu via queue ID %d, max bytes (%lu) "          "reached (%lu messages of %lu bytes currently in queue)",          (unsigned long) dst_pid, shaper_qid, shaper_qmaxbytes,          (unsigned long) ds.msg_qnum, (unsigned long) ds.msg_qnum * msgsz);      }      error_count++;      if (error_count > SHAPER_MAX_SEND_ATTEMPTS) {        free(msg);        (void) pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,          "unable to send message to PID %lu via queue ID %d after %u attempts "          "(%u max attempts allowed), failing", (unsigned long) dst_pid,          shaper_qid, error_count, SHAPER_MAX_SEND_ATTEMPTS);        errno = EPERM;        return -1;      }    }  }
msgsnd(shaper_qid, msg, msgsz, IPC_NOWAIT) < 0
msgsnd(shaper_qid, msg, msgsz, IPC_NOWAIT)
msgsnd
msgsnd
shaper_qid
shaper_qid
msg
msg
msgsz
msgsz
IPC_NOWAIT
IPC_NOWAIT
0
{    pr_signals_handle();    if (errno != EAGAIN) {      free(msg);      return -1;    } else {      /* The EAGAIN error happens when there are too many bytes of messages       * on the queue.  Check to see what the current number of messages       * on the queue is, and log the error.       *       * If this error is hit too many times in a loop, we may need to give       * up permanently.  (XXX in the future, if one queue is too small for       * a busy daemon, look into a different queue allocation strategy.)       */      struct msqid_ds ds;      if (msgctl(shaper_qid, IPC_STAT, &ds) < 0) {        (void) pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,          "error checking queue ID %d: %s", shaper_qid, strerror(errno));      } else {        (void) pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,          "unable to send message to PID %lu via queue ID %d, max bytes (%lu) "          "reached (%lu messages of %lu bytes currently in queue)",          (unsigned long) dst_pid, shaper_qid, shaper_qmaxbytes,          (unsigned long) ds.msg_qnum, (unsigned long) ds.msg_qnum * msgsz);      }      error_count++;      if (error_count > SHAPER_MAX_SEND_ATTEMPTS) {        free(msg);        (void) pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,          "unable to send message to PID %lu via queue ID %d after %u attempts "          "(%u max attempts allowed), failing", (unsigned long) dst_pid,          shaper_qid, error_count, SHAPER_MAX_SEND_ATTEMPTS);        errno = EPERM;        return -1;      }    }  }
pr_signals_handle();
pr_signals_handle()
pr_signals_handle
pr_signals_handle
if (errno != EAGAIN) {      free(msg);      return -1;    } else {      /* The EAGAIN error happens when there are too many bytes of messages       * on the queue.  Check to see what the current number of messages       * on the queue is, and log the error.       *       * If this error is hit too many times in a loop, we may need to give       * up permanently.  (XXX in the future, if one queue is too small for       * a busy daemon, look into a different queue allocation strategy.)       */      struct msqid_ds ds;      if (msgctl(shaper_qid, IPC_STAT, &ds) < 0) {        (void) pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,          "error checking queue ID %d: %s", shaper_qid, strerror(errno));      } else {        (void) pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,          "unable to send message to PID %lu via queue ID %d, max bytes (%lu) "          "reached (%lu messages of %lu bytes currently in queue)",          (unsigned long) dst_pid, shaper_qid, shaper_qmaxbytes,          (unsigned long) ds.msg_qnum, (unsigned long) ds.msg_qnum * msgsz);      }      error_count++;      if (error_count > SHAPER_MAX_SEND_ATTEMPTS) {        free(msg);        (void) pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,          "unable to send message to PID %lu via queue ID %d after %u attempts "          "(%u max attempts allowed), failing", (unsigned long) dst_pid,          shaper_qid, error_count, SHAPER_MAX_SEND_ATTEMPTS);        errno = EPERM;        return -1;      }    }
errno != EAGAIN
errno
errno
EAGAIN
EAGAIN
{      free(msg);      return -1;    }
free(msg);
free(msg)
free
free
msg
msg
return -1;
-1
1
{      /* The EAGAIN error happens when there are too many bytes of messages       * on the queue.  Check to see what the current number of messages       * on the queue is, and log the error.       *       * If this error is hit too many times in a loop, we may need to give       * up permanently.  (XXX in the future, if one queue is too small for       * a busy daemon, look into a different queue allocation strategy.)       */      struct msqid_ds ds;      if (msgctl(shaper_qid, IPC_STAT, &ds) < 0) {        (void) pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,          "error checking queue ID %d: %s", shaper_qid, strerror(errno));      } else {        (void) pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,          "unable to send message to PID %lu via queue ID %d, max bytes (%lu) "          "reached (%lu messages of %lu bytes currently in queue)",          (unsigned long) dst_pid, shaper_qid, shaper_qmaxbytes,          (unsigned long) ds.msg_qnum, (unsigned long) ds.msg_qnum * msgsz);      }      error_count++;      if (error_count > SHAPER_MAX_SEND_ATTEMPTS) {        free(msg);        (void) pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,          "unable to send message to PID %lu via queue ID %d after %u attempts "          "(%u max attempts allowed), failing", (unsigned long) dst_pid,          shaper_qid, error_count, SHAPER_MAX_SEND_ATTEMPTS);        errno = EPERM;        return -1;      }    }
struct msqid_ds ds;
struct msqid_ds ds;
struct msqid_ds
msqid_ds
ds
ds
if (msgctl(shaper_qid, IPC_STAT, &ds) < 0) {        (void) pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,          "error checking queue ID %d: %s", shaper_qid, strerror(errno));      } else {        (void) pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,          "unable to send message to PID %lu via queue ID %d, max bytes (%lu) "          "reached (%lu messages of %lu bytes currently in queue)",          (unsigned long) dst_pid, shaper_qid, shaper_qmaxbytes,          (unsigned long) ds.msg_qnum, (unsigned long) ds.msg_qnum * msgsz);      }
msgctl(shaper_qid, IPC_STAT, &ds) < 0
msgctl(shaper_qid, IPC_STAT, &ds)
msgctl
msgctl
shaper_qid
shaper_qid
IPC_STAT
IPC_STAT
&ds
ds
ds
0
{        (void) pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,          "error checking queue ID %d: %s", shaper_qid, strerror(errno));      }
(void) pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,          "error checking queue ID %d: %s", shaper_qid, strerror(errno));
(void) pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,          "error checking queue ID %d: %s", shaper_qid, strerror(errno))
void
void

pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,          "error checking queue ID %d: %s", shaper_qid, strerror(errno))
pr_log_writefile
pr_log_writefile
shaper_logfd
shaper_logfd
MOD_SHAPER_VERSION
MOD_SHAPER_VERSION
"error checking queue ID %d: %s"
shaper_qid
shaper_qid
strerror(errno)
strerror
strerror
errno
errno
{        (void) pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,          "unable to send message to PID %lu via queue ID %d, max bytes (%lu) "          "reached (%lu messages of %lu bytes currently in queue)",          (unsigned long) dst_pid, shaper_qid, shaper_qmaxbytes,          (unsigned long) ds.msg_qnum, (unsigned long) ds.msg_qnum * msgsz);      }
(void) pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,          "unable to send message to PID %lu via queue ID %d, max bytes (%lu) "          "reached (%lu messages of %lu bytes currently in queue)",          (unsigned long) dst_pid, shaper_qid, shaper_qmaxbytes,          (unsigned long) ds.msg_qnum, (unsigned long) ds.msg_qnum * msgsz);
(void) pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,          "unable to send message to PID %lu via queue ID %d, max bytes (%lu) "          "reached (%lu messages of %lu bytes currently in queue)",          (unsigned long) dst_pid, shaper_qid, shaper_qmaxbytes,          (unsigned long) ds.msg_qnum, (unsigned long) ds.msg_qnum * msgsz)
void
void

pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,          "unable to send message to PID %lu via queue ID %d, max bytes (%lu) "          "reached (%lu messages of %lu bytes currently in queue)",          (unsigned long) dst_pid, shaper_qid, shaper_qmaxbytes,          (unsigned long) ds.msg_qnum, (unsigned long) ds.msg_qnum * msgsz)
pr_log_writefile
pr_log_writefile
shaper_logfd
shaper_logfd
MOD_SHAPER_VERSION
MOD_SHAPER_VERSION
"unable to send message to PID %lu via queue ID %d, max bytes (%lu) "          "reached (%lu messages of %lu bytes currently in queue)"
(unsigned long) dst_pid
unsigned long
unsigned long

dst_pid
dst_pid
shaper_qid
shaper_qid
shaper_qmaxbytes
shaper_qmaxbytes
(unsigned long) ds.msg_qnum
unsigned long
unsigned long

ds.msg_qnum
ds
ds
msg_qnum
(unsigned long) ds.msg_qnum * msgsz
(unsigned long) ds.msg_qnum
unsigned long
unsigned long

ds.msg_qnum
ds
ds
msg_qnum
msgsz
msgsz
error_count++;
error_count++
error_count
error_count
if (error_count > SHAPER_MAX_SEND_ATTEMPTS) {        free(msg);        (void) pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,          "unable to send message to PID %lu via queue ID %d after %u attempts "          "(%u max attempts allowed), failing", (unsigned long) dst_pid,          shaper_qid, error_count, SHAPER_MAX_SEND_ATTEMPTS);        errno = EPERM;        return -1;      }
error_count > SHAPER_MAX_SEND_ATTEMPTS
error_count
error_count
SHAPER_MAX_SEND_ATTEMPTS
SHAPER_MAX_SEND_ATTEMPTS
{        free(msg);        (void) pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,          "unable to send message to PID %lu via queue ID %d after %u attempts "          "(%u max attempts allowed), failing", (unsigned long) dst_pid,          shaper_qid, error_count, SHAPER_MAX_SEND_ATTEMPTS);        errno = EPERM;        return -1;      }
free(msg);
free(msg)
free
free
msg
msg
(void) pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,          "unable to send message to PID %lu via queue ID %d after %u attempts "          "(%u max attempts allowed), failing", (unsigned long) dst_pid,          shaper_qid, error_count, SHAPER_MAX_SEND_ATTEMPTS);
(void) pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,          "unable to send message to PID %lu via queue ID %d after %u attempts "          "(%u max attempts allowed), failing", (unsigned long) dst_pid,          shaper_qid, error_count, SHAPER_MAX_SEND_ATTEMPTS)
void
void

pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,          "unable to send message to PID %lu via queue ID %d after %u attempts "          "(%u max attempts allowed), failing", (unsigned long) dst_pid,          shaper_qid, error_count, SHAPER_MAX_SEND_ATTEMPTS)
pr_log_writefile
pr_log_writefile
shaper_logfd
shaper_logfd
MOD_SHAPER_VERSION
MOD_SHAPER_VERSION
"unable to send message to PID %lu via queue ID %d after %u attempts "          "(%u max attempts allowed), failing"
(unsigned long) dst_pid
unsigned long
unsigned long

dst_pid
dst_pid
shaper_qid
shaper_qid
error_count
error_count
SHAPER_MAX_SEND_ATTEMPTS
SHAPER_MAX_SEND_ATTEMPTS
errno = EPERM;
errno = EPERM
errno
errno
EPERM
EPERM
return -1;
-1
1
free(msg);
free(msg)
free
free
msg
msg
PRIVS_ROOT  res = kill(dst_pid, SIGUSR2);
PRIVS_ROOT  res = kill(dst_pid, SIGUSR2);
PRIVS_ROOT
PRIVS_ROOT
res = kill(dst_pid, SIGUSR2)
res
= kill(dst_pid, SIGUSR2)
kill(dst_pid, SIGUSR2)
kill
kill
dst_pid
dst_pid
SIGUSR2
SIGUSR2
PRIVS_RELINQUISH
PRIVS_RELINQUISH
PRIVS_RELINQUISH
H
if (res < 0) {    if (errno == ESRCH) {      shaper_msg_clear(dst_pid);    } else {      (void) pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,        "error sending notice: %s", strerror(errno));    }  }
res < 0
res
res
0
{    if (errno == ESRCH) {      shaper_msg_clear(dst_pid);    } else {      (void) pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,        "error sending notice: %s", strerror(errno));    }  }
if (errno == ESRCH) {      shaper_msg_clear(dst_pid);    } else {      (void) pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,        "error sending notice: %s", strerror(errno));    }
errno == ESRCH
errno
errno
ESRCH
ESRCH
{      shaper_msg_clear(dst_pid);    }
shaper_msg_clear(dst_pid);
shaper_msg_clear(dst_pid)
shaper_msg_clear
shaper_msg_clear
dst_pid
dst_pid
{      (void) pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,        "error sending notice: %s", strerror(errno));    }
(void) pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,        "error sending notice: %s", strerror(errno));
(void) pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,        "error sending notice: %s", strerror(errno))
void
void

pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,        "error sending notice: %s", strerror(errno))
pr_log_writefile
pr_log_writefile
shaper_logfd
shaper_logfd
MOD_SHAPER_VERSION
MOD_SHAPER_VERSION
"error sending notice: %s"
strerror(errno)
strerror
strerror
errno
errno
return 0;
0
-----joern-----
(45,16,0)
(208,122,0)
(122,208,0)
(20,115,0)
(79,69,0)
(62,195,0)
(94,20,0)
(154,88,0)
(141,201,0)
(101,169,0)
(162,34,0)
(122,18,0)
(61,77,0)
(78,210,0)
(26,159,0)
(5,170,0)
(177,125,0)
(95,207,0)
(158,176,0)
(61,202,0)
(18,115,0)
(141,68,0)
(2,202,0)
(200,207,0)
(96,161,0)
(8,62,0)
(37,97,0)
(60,68,0)
(34,162,0)
(13,66,0)
(194,54,0)
(166,195,0)
(121,25,0)
(164,96,0)
(166,175,0)
(92,86,0)
(174,169,0)
(120,194,0)
(211,77,0)
(51,9,0)
(124,188,0)
(183,117,0)
(192,169,0)
(45,194,0)
(123,180,0)
(146,39,0)
(44,20,0)
(112,55,0)
(147,47,0)
(135,45,0)
(77,61,0)
(95,86,0)
(16,45,0)
(88,103,0)
(26,95,0)
(166,9,0)
(203,16,0)
(63,160,0)
(71,150,0)
(128,90,0)
(25,121,0)
(67,145,0)
(113,18,0)
(77,190,0)
(129,171,0)
(117,71,0)
(189,186,0)
(39,47,0)
(197,166,0)
(109,63,0)
(87,178,0)
(174,53,0)
(85,20,0)
(163,10,0)
(159,86,0)
(21,54,0)
(116,39,0)
(140,167,0)
(156,47,0)
(89,61,0)
(78,184,0)
(155,121,0)
(104,174,0)
(65,111,0)
(161,96,0)
(19,10,0)
(76,66,0)
(183,83,0)
(121,78,0)
(196,195,0)
(137,195,0)
(193,113,0)
(126,121,0)
(59,20,0)
(153,41,0)
(145,61,0)
(73,108,0)
(204,43,0)
(96,169,0)
(12,7,0)
(165,74,0)
(197,167,0)
(160,63,0)
(113,194,0)
(117,195,0)
(130,97,0)
(58,109,0)
(70,199,0)
(166,197,0)
(28,10,0)
(103,52,0)
(56,44,0)
(75,195,0)
(90,111,0)
(141,54,0)
(78,121,0)
(163,113,0)
(77,211,0)
(109,172,0)
(61,108,0)
(31,162,0)
(93,22,0)
(64,125,0)
(95,178,0)
(47,195,0)
(43,153,0)
(40,73,0)
(153,124,0)
(143,63,0)
(24,207,0)
(144,34,0)
(133,47,0)
(39,174,0)
(106,59,0)
(131,176,0)
(138,160,0)
(69,20,0)
(103,41,0)
(14,121,0)
(149,87,0)
(87,39,0)
(145,67,0)
(6,195,0)
(55,20,0)
(43,204,0)
(100,55,0)
(136,45,0)
(157,195,0)
(145,169,0)
(202,194,0)
(127,44,0)
(132,20,0)
(86,62,0)
(117,183,0)
(152,195,0)
(30,63,0)
(26,170,0)
(150,71,0)
(108,61,0)
(34,195,0)
(170,3,0)
(197,59,0)
(27,82,0)
(22,66,0)
(103,195,0)
(36,171,0)
(110,59,0)
(198,195,0)
(11,5,0)
(45,20,0)
(9,91,0)
(20,195,0)
(210,78,0)
(99,176,0)
(98,86,0)
(15,61,0)
(124,153,0)
(117,44,0)
(85,3,0)
(44,117,0)
(162,169,0)
(41,55,0)
(192,195,0)
(29,101,0)
(38,61,0)
(167,197,0)
(33,45,0)
(103,88,0)
(80,61,0)
(86,20,0)
(52,114,0)
(46,156,0)
(115,20,0)
(105,201,0)
(132,195,0)
(180,123,0)
(125,47,0)
(35,39,0)
(59,197,0)
(84,108,0)
(170,86,0)
(54,21,0)
(7,95,0)
(54,141,0)
(209,195,0)
(66,82,0)
(168,205,0)
(123,186,0)
(62,169,0)
(182,159,0)
(186,123,0)
(115,18,0)
(123,202,0)
(39,87,0)
(108,84,0)
(119,39,0)
(21,0,0)
(63,109,0)
(202,123,0)
(111,90,0)
(48,25,0)
(179,195,0)
(88,154,0)
(87,149,0)
(113,163,0)
(188,124,0)
(32,192,0)
(159,195,0)
(53,174,0)
(82,66,0)
(108,73,0)
(185,205,0)
(57,162,0)
(49,142,0)
(148,85,0)
(42,61,0)
(202,61,0)
(175,166,0)
(0,21,0)
(55,41,0)
(194,195,0)
(142,20,0)
(10,163,0)
(68,60,0)
(61,145,0)
(54,194,0)
(153,43,0)
(18,113,0)
(18,122,0)
(205,34,0)
(191,175,0)
(17,186,0)
(9,166,0)
(68,141,0)
(71,117,0)
(151,90,0)
(175,191,0)
(118,45,0)
(109,58,0)
(206,63,0)
(4,39,0)
(173,199,0)
(50,63,0)
(23,183,0)
(66,22,0)
(41,103,0)
(81,145,0)
(187,73,0)
(174,39,0)
(201,105,0)
(201,141,0)
(181,132,0)
(90,139,0)
(107,39,0)
(1,52,0)
(207,178,0)
(102,69,0)
(101,72,0)
(167,140,0)
(41,153,0)
(142,178,0)
(156,176,0)
(52,103,0)
(113,163,1)
(108,84,1)
(30,22,1)
(80,42,1)
(61,108,1)
(26,95,1)
(117,183,1)
(189,108,1)
(159,182,1)
(133,147,1)
(202,123,1)
(125,177,1)
(9,51,1)
(18,122,1)
(142,20,1)
(5,11,1)
(62,169,1)
(18,113,1)
(126,14,1)
(194,54,1)
(38,80,1)
(202,2,1)
(94,194,1)
(65,69,1)
(166,175,1)
(207,200,1)
(42,22,1)
(50,143,1)
(102,79,1)
(174,104,1)
(36,205,1)
(27,13,1)
(88,52,1)
(69,20,1)
(159,86,1)
(145,169,1)
(17,189,1)
(103,52,1)
(136,33,1)
(41,153,1)
(205,168,1)
(45,20,1)
(52,1,1)
(118,136,1)
(111,65,1)
(59,20,1)
(90,151,1)
(197,167,1)
(96,161,1)
(19,193,1)
(86,20,1)
(123,180,1)
(181,16,1)
(182,134,1)
(151,128,1)
(35,174,1)
(1,41,1)
(52,114,1)
(145,81,1)
(146,116,1)
(193,122,1)
(171,129,1)
(33,192,1)
(20,115,1)
(78,210,1)
(21,0,1)
(39,174,1)
(78,121,1)
(68,21,1)
(48,126,1)
(103,88,1)
(108,73,1)
(55,112,1)
(95,86,1)
(167,59,1)
(125,47,1)
(54,21,1)
(124,55,1)
(192,32,1)
(197,59,1)
(61,202,1)
(41,55,1)
(34,162,1)
(11,85,1)
(45,135,1)
(162,169,1)
(175,191,1)
(141,201,1)
(95,207,1)
(73,187,1)
(16,203,1)
(26,170,1)
(103,41,1)
(175,9,1)
(192,169,1)
(183,23,1)
(153,43,1)
(55,20,1)
(22,93,1)
(160,138,1)
(15,89,1)
(199,173,1)
(161,78,1)
(166,197,1)
(92,69,1)
(95,7,1)
(93,66,1)
(10,28,1)
(85,20,1)
(7,12,1)
(107,142,1)
(31,144,1)
(168,185,1)
(122,94,1)
(33,125,1)
(155,171,1)
(71,183,1)
(98,92,1)
(162,57,1)
(26,159,1)
(62,8,1)
(110,106,1)
(164,161,1)
(134,96,1)
(201,68,1)
(56,62,1)
(156,47,1)
(96,164,1)
(46,109,1)
(143,30,1)
(144,132,1)
(120,47,1)
(2,123,1)
(201,105,1)
(86,98,1)
(16,45,1)
(4,35,1)
(49,125,1)
(54,141,1)
(61,145,1)
(145,67,1)
(173,70,1)
(205,34,1)
(141,68,1)
(148,199,1)
(106,117,1)
(174,169,1)
(81,38,1)
(39,119,1)
(182,96,1)
(12,207,1)
(14,155,1)
(37,16,1)
(132,181,1)
(76,199,1)
(156,46,1)
(69,102,1)
(174,53,1)
(163,10,1)
(101,169,1)
(161,205,1)
(124,188,1)
(25,48,1)
(21,120,1)
(9,91,1)
(46,77,1)
(206,50,1)
(28,19,1)
(167,140,1)
(100,166,1)
(138,206,1)
(79,20,1)
(203,45,1)
(153,124,1)
(51,197,1)
(116,107,1)
(70,37,1)
(127,56,1)
(183,83,1)
(109,63,1)
(117,44,1)
(113,194,1)
(92,90,1)
(128,111,1)
(29,171,1)
(57,31,1)
(47,133,1)
(22,66,1)
(161,101,1)
(119,4,1)
(170,86,1)
(117,71,1)
(122,208,1)
(13,76,1)
(71,150,1)
(40,15,1)
(32,103,1)
(185,34,1)
(43,204,1)
(187,40,1)
(115,18,1)
(87,39,1)
(129,36,1)
(64,156,1)
(170,5,1)
(59,110,1)
(77,61,1)
(88,154,1)
(200,24,1)
(87,149,1)
(90,111,1)
(166,9,1)
(44,20,1)
(121,25,1)
(142,49,1)
(85,148,1)
(109,58,1)
(63,160,1)
(177,64,1)
(45,194,1)
(104,146,1)
(66,82,1)
(39,47,1)
(132,20,1)
(101,29,1)
(123,186,1)
(112,100,1)
(89,145,1)
(77,211,1)
(68,60,1)
(24,87,1)
(82,27,1)
(135,118,1)
(23,44,1)
(8,86,1)
(96,169,1)
(43,124,1)
(186,17,1)
(202,194,1)
(44,127,1)
(43,204,2)
(181,16,2)
(85,20,2)
(68,60,2)
(166,197,2)
(189,22,2)
(142,20,2)
(82,199,2)
(66,199,2)
(187,22,2)
(182,16,2)
(87,125,2)
(101,171,2)
(109,63,2)
(61,145,2)
(63,160,2)
(16,125,2)
(66,82,2)
(77,22,2)
(117,183,2)
(109,22,2)
(9,91,2)
(167,140,2)
(101,169,2)
(76,199,2)
(108,84,2)
(205,34,2)
(174,169,2)
(171,205,2)
(54,21,2)
(119,125,2)
(166,175,2)
(145,22,2)
(61,202,2)
(124,188,2)
(104,125,2)
(48,171,2)
(153,124,2)
(200,125,2)
(162,169,2)
(144,16,2)
(170,199,2)
(108,22,2)
(88,154,2)
(116,125,2)
(129,205,2)
(13,199,2)
(25,171,2)
(29,171,2)
(186,22,2)
(63,22,2)
(30,22,2)
(95,125,2)
(57,16,2)
(118,125,2)
(145,169,2)
(35,125,2)
(123,180,2)
(22,199,2)
(168,16,2)
(199,16,2)
(103,52,2)
(163,10,2)
(113,163,2)
(39,174,2)
(205,16,2)
(174,125,2)
(81,22,2)
(77,211,2)
(159,86,2)
(24,125,2)
(64,199,2)
(73,22,2)
(71,150,2)
(86,20,2)
(4,125,2)
(146,125,2)
(87,149,2)
(49,125,2)
(77,61,2)
(153,43,2)
(202,194,2)
(93,199,2)
(34,162,2)
(122,208,2)
(78,121,2)
(26,95,2)
(162,16,2)
(197,167,2)
(34,16,2)
(128,69,2)
(22,66,2)
(2,22,2)
(136,125,2)
(151,69,2)
(174,53,2)
(20,115,2)
(126,171,2)
(160,22,2)
(89,22,2)
(175,191,2)
(142,125,2)
(26,159,2)
(103,41,2)
(96,16,2)
(183,83,2)
(115,18,2)
(117,71,2)
(170,86,2)
(39,47,2)
(134,96,2)
(37,16,2)
(173,16,2)
(90,111,2)
(54,141,2)
(164,16,2)
(27,199,2)
(103,88,2)
(202,123,2)
(148,199,2)
(62,169,2)
(96,161,2)
(202,22,2)
(61,108,2)
(132,16,2)
(78,210,2)
(65,69,2)
(70,16,2)
(109,58,2)
(143,22,2)
(156,47,2)
(145,67,2)
(5,199,2)
(44,20,2)
(14,171,2)
(38,22,2)
(203,125,2)
(52,114,2)
(45,194,2)
(96,169,2)
(185,16,2)
(36,205,2)
(85,199,2)
(123,22,2)
(41,55,2)
(107,125,2)
(113,194,2)
(50,22,2)
(17,22,2)
(7,125,2)
(59,20,2)
(61,22,2)
(95,207,2)
(33,125,2)
(15,22,2)
(31,16,2)
(194,54,2)
(45,20,2)
(90,69,2)
(161,16,2)
(138,22,2)
(69,20,2)
(207,125,2)
(121,171,2)
(11,199,2)
(156,199,2)
(18,113,2)
(111,69,2)
(206,22,2)
(125,199,2)
(42,22,2)
(166,9,2)
(192,169,2)
(121,25,2)
(78,171,2)
(26,170,2)
(125,47,2)
(46,199,2)
(135,125,2)
(21,0,2)
(141,201,2)
(197,59,2)
(201,105,2)
(123,186,2)
(45,125,2)
(177,199,2)
(155,171,2)
(141,68,2)
(39,125,2)
(18,122,2)
(40,22,2)
(108,73,2)
(117,44,2)
(12,125,2)
(16,45,2)
(80,22,2)
(55,20,2)
(87,39,2)
(159,16,2)
(132,20,2)
(41,153,2)
(95,86,2)
-----------------------------------
(0,unsigned int)
(1,uprate)
(2,msgsz)
(3,)
(4,error_count)
(5,-1)
(6,msg)
(7,-1)
(8,dst_pid)
(9,&downrate)
(10,msg->mtext)
(11,1)
(12,1)
(13,IPC_STAT)
(14,MOD_SHAPER_VERSION)
(15,shaper_qmaxbytes)
(16,msgsnd(shaper_qid, msg, msgsz, IPC_NOWAIT)
(17,msg_qnum)
(18,sizeof(struct shaper_msg)
(19,msg)
(20,msg = malloc(sizeof(struct shaper_msg)
(21,sizeof(unsigned int)
(22,msgctl(shaper_qid, IPC_STAT, &ds)
(23,prio)
(24,errno)
(25,strerror(errno)
(26,RET)
(27,ds)
(28,mtext)
(29,dst_pid)
(30,shaper_logfd)
(31,dst_pid)
(32,dst_pid)
(33,shaper_qid)
(34,res = kill(dst_pid, SIGUSR2)
(35,shaper_qid)
(36,errno)
(37,pr_signals_handle()
(38,"unable to send message to PID %lu via queue ID %d, max bytes (%lu)
(39,pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,\n\\n          "unable to send message to PID %lu via queue ID %d after %u attempts "\n\\n          "(%u max attempts allowed)
(40,ds)
(41,msg->mtext + sizeof(unsigned int)
(42,shaper_logfd)
(43,sizeof(long double)
(44,msg->mtext)
(45,msgsnd(shaper_qid, msg, msgsz, IPC_NOWAIT)
(46,error_count)
(47,error_count = 0)
(48,errno)
(49,msg)
(50,"error checking queue ID %d: %s")
(51,downrate)
(52,&uprate)
(53,unsigned long)
(54,sizeof(unsigned int)
(55,msg->mtext)
(56,msg)
(57,SIGUSR2)
(58,void)
(59,msg->mtext)
(60,long double)
(61,pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,\n\\n          "unable to send message to PID %lu via queue ID %d, max bytes (%lu)
(62,msg->mtype = dst_pid)
(63,pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,\n\\n          "error checking queue ID %d: %s", shaper_qid, strerror(errno)
(64,error_count)
(65,shaper_module)
(66,msgctl(shaper_qid, IPC_STAT, &ds)
(67,unsigned long)
(68,sizeof(long double)
(69,msg == NULL)
(70,errno)
(71,sizeof(unsigned int)
(72,)
(73,ds.msg_qnum)
(74,)
(75,res)
(76,shaper_qid)
(77,(void)
(78,(void)
(79,msg)
(80,MOD_SHAPER_VERSION)
(81,dst_pid)
(82,&ds)
(83,unsigned int prio)
(84,unsigned long)
(85,free(msg)
(86,msg->mtype)
(87,(void)
(88,sizeof(long double)
(89,shaper_qid)
(90,pr_session_disconnect(&shaper_module, PR_SESS_DISCONNECT_NOMEM, NULL)
(91,long double downrate)
(92,msg)
(93,0)
(94,msg)
(95,return -1;)
(96,getpid()
(97,)
(98,mtype)
(99,ds)
(100,msg)
(101,shaper_msg_clear(dst_pid)
(102,NULL)
(103,memcpy(msg->mtext + sizeof(unsigned int)
(104,dst_pid)
(105,long double)
(106,msg)
(107,shaper_logfd)
(108,(unsigned long)
(109,(void)
(110,mtext)
(111,&shaper_module)
(112,mtext)
(113,msgsz - sizeof(msg->mtext)
(114,long double uprate)
(115,malloc(sizeof(struct shaper_msg)
(116,MOD_SHAPER_VERSION)
(117,memcpy(msg->mtext, &prio, sizeof(unsigned int)
(118,msgsz)
(119,SHAPER_MAX_SEND_ATTEMPTS)
(120,msgsz)
(121,pr_log_writefile(shaper_logfd, MOD_SHAPER_VERSION,\n\\n        "error sending notice: %s", strerror(errno)
(122,sizeof(struct shaper_msg)
(123,(unsigned long)
(124,sizeof(unsigned int)
(125,error_count > SHAPER_MAX_SEND_ATTEMPTS)
(126,"error sending notice: %s")
(127,mtext)
(128,PR_SESS_DISCONNECT_NOMEM)
(129,ESRCH)
(130,if (errno != EAGAIN)
(131,if (msgctl(shaper_qid, IPC_STAT, &ds)
(132,free(msg)
(133,0)
(134,pr_signals_handle()
(135,IPC_NOWAIT)
(136,msg)
(137,if (msg == NULL)
(138,errno)
(139,)
(140,unsigned int)
(141,sizeof(long double)
(142,free(msg)
(143,MOD_SHAPER_VERSION)
(144,res)
(145,(unsigned long)
(146,"unable to send message to PID %lu via queue ID %d after %u attempts "\n\\n          "(%u max attempts allowed)
(147,error_count)
(148,msg)
(149,void)
(150,unsigned int)
(151,NULL)
(152,while (msgsnd(shaper_qid, msg, msgsz, IPC_NOWAIT)
(153,sizeof(unsigned int)
(154,long double)
(155,shaper_logfd)
(156,error_count++)
(157,if (res < 0)
(158,if (error_count > SHAPER_MAX_SEND_ATTEMPTS)
(159,return 0;)
(160,strerror(errno)
(161,getpid()
(162,kill(dst_pid, SIGUSR2)
(163,sizeof(msg->mtext)
(164,dst_pid)
(165,if (errno == ESRCH)
(166,memcpy(msg->mtext + sizeof(unsigned int)
(167,sizeof(unsigned int)
(168,0)
(169,pid_t dst_pid)
(170,return -1;)
(171,errno == ESRCH)
(172,)
(173,EAGAIN)
(174,(unsigned long)
(175,sizeof(long double)
(176,)
(177,SHAPER_MAX_SEND_ATTEMPTS)
(178,)
(179,error_count)
(180,unsigned long)
(181,msg)
(182,0)
(183,&prio)
(184,)
(185,res)
(186,ds.msg_qnum)
(187,msg_qnum)
(188,unsigned int)
(189,ds)
(190,)
(191,long double)
(192,shaper_msg_clear(dst_pid)
(193,msgsz)
(194,msgsz = sizeof(unsigned int)
(195,)
(196,res)
(197,msg->mtext + sizeof(unsigned int)
(198,if (getpid()
(199,errno != EAGAIN)
(200,EPERM)
(201,sizeof(long double)
(202,(unsigned long)
(203,0)
(204,long double)
(205,res < 0)
(206,shaper_qid)
(207,errno = EPERM)
(208,struct shaper_msg)
(209,msgsz)
(210,void)
(211,void)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^