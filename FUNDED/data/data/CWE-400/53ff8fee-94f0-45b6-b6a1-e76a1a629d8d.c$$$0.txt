-----label-----
1
-----code-----
int rename_ref(const char *oldrefname, const char *newrefname, const char *logmsg)
{
	unsigned char sha1[20], orig_sha1[20];
	int flag = 0, logmoved = 0;
	struct ref_lock *lock;
	struct stat loginfo;
	int log = !lstat(git_path("logs/%s", oldrefname), &loginfo);
	const char *symref = NULL;
	struct strbuf err = STRBUF_INIT;

	if (log && S_ISLNK(loginfo.st_mode))
		return error("reflog for %s is a symlink", oldrefname);

	symref = resolve_ref_unsafe(oldrefname, RESOLVE_REF_READING,
				    orig_sha1, &flag);
	if (flag & REF_ISSYMREF)
		return error("refname %s is a symbolic ref, renaming it is not supported",
			oldrefname);
	if (!symref)
		return error("refname %s not found", oldrefname);

	if (!rename_ref_available(oldrefname, newrefname))
		return 1;

	if (log && rename(git_path("logs/%s", oldrefname), git_path(TMP_RENAMED_LOG)))
		return error("unable to move logfile logs/%s to "TMP_RENAMED_LOG": %s",
			oldrefname, strerror(errno));

	if (delete_ref(oldrefname, orig_sha1, REF_NODEREF)) {
		error("unable to delete old %s", oldrefname);
		goto rollback;
	}

	if (!read_ref_full(newrefname, RESOLVE_REF_READING, sha1, NULL) &&
	    delete_ref(newrefname, sha1, REF_NODEREF)) {
		if (errno==EISDIR) {
			if (remove_empty_directories(git_path("%s", newrefname))) {
				error("Directory not empty: %s", newrefname);
				goto rollback;
			}
		} else {
			error("unable to delete existing %s", newrefname);
			goto rollback;
		}
	}

	if (log && rename_tmp_log(newrefname))
		goto rollback;

	logmoved = log;

	lock = lock_ref_sha1_basic(newrefname, NULL, NULL, NULL, 0, NULL, &err);
	if (!lock) {
		error("unable to rename '%s' to '%s': %s", oldrefname, newrefname, err.buf);
		strbuf_release(&err);
		goto rollback;
	}
	hashcpy(lock->old_sha1, orig_sha1);

	if (write_ref_to_lockfile(lock, orig_sha1) ||
	    commit_ref_update(lock, orig_sha1, logmsg)) {
		error("unable to write current sha1 into %s", newrefname);
		goto rollback;
	}

	return 0;

 rollback:
	lock = lock_ref_sha1_basic(oldrefname, NULL, NULL, NULL, 0, NULL, &err);
	if (!lock) {
		error("unable to lock %s for rollback: %s", oldrefname, err.buf);
		strbuf_release(&err);
		goto rollbacklog;
	}

	flag = log_all_ref_updates;
	log_all_ref_updates = 0;
	if (write_ref_to_lockfile(lock, orig_sha1) ||
	    commit_ref_update(lock, orig_sha1, NULL))
		error("unable to write current sha1 into %s", oldrefname);
	log_all_ref_updates = flag;

 rollbacklog:
	if (logmoved && rename(git_path("logs/%s", newrefname), git_path("logs/%s", oldrefname)))
		error("unable to restore logfile %s from %s: %s",
			oldrefname, newrefname, strerror(errno));
	if (!logmoved && log &&
	    rename(git_path(TMP_RENAMED_LOG), git_path("logs/%s", oldrefname)))
		error("unable to restore logfile %s from "TMP_RENAMED_LOG": %s",
			oldrefname, strerror(errno));

	return 1;
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
3,7
5,6
5,7
7,8
7,9
10,11
10,12
12,13
12,14
15,16
15,17
17,18
17,19
20,21
20,22
20,23
20,24
20,25
20,26
20,27
20,28
20,29
20,30
20,31
20,32
20,33
20,34
20,35
20,36
20,37
20,38
20,39
20,40
20,41
20,42
20,43
20,44
20,45
20,46
20,47
20,48
20,49
20,50
20,51
21,22
22,23
22,24
22,25
24,25
24,26
26,27
28,29
28,30
30,31
32,33
33,34
33,35
33,36
35,36
35,37
37,38
39,40
39,41
41,42
43,44
44,45
44,46
45,46
47,48
47,49
50,51
51,52
51,53
52,53
54,55
56,57
57,58
57,59
59,60
59,61
61,62
62,63
63,64
63,65
63,66
64,65
66,67
66,68
66,69
67,68
70,71
72,73
73,74
75,76
76,77
76,78
78,79
78,80
78,81
81,82
82,83
84,85
85,86
85,87
86,87
88,89
88,90
90,91
91,92
93,94
93,95
94,95
94,96
95,96
97,98
97,99
98,99
100,101
100,102
101,102
104,105
105,106
105,107
105,108
106,107
109,110
111,112
112,113
112,114
113,114
115,116
115,117
115,118
115,119
115,120
116,117
118,119
120,121
122,123
124,125
125,126
127,128
127,129
128,129
128,130
129,130
131,132
133,134
134,135
134,136
134,137
135,136
138,139
140,141
140,142
141,142
142,143
144,145
145,146
145,147
145,148
146,147
149,150
151,152
151,153
152,153
153,154
153,155
153,156
154,155
156,157
158,159
160,161
162,163
163,164
163,165
164,165
164,166
164,167
164,168
165,166
167,168
169,170
171,172
173,174
173,175
174,175
175,176
175,177
175,178
176,177
179,180
181,182
183,184
183,185
184,185
184,186
185,186
186,187
186,188
186,189
186,190
186,191
187,188
189,190
191,192
193,194
195,196
197,198
197,199
197,200
197,201
198,199
200,201
202,203
204,205
206,207
207,208
207,209
207,210
208,209
208,210
209,210
211,212
213,214
214,215
214,216
215,216
215,217
216,217
218,219
218,220
218,221
219,220
222,223
224,225
224,226
225,226
226,227
226,228
226,229
227,228
230,231
232,233
234,235
234,236
235,236
236,237
236,238
236,239
237,238
240,241
242,243
244,245
244,246
245,246
245,247
246,247
248,249
248,250
249,250
251,252
253,254
255,256
256,257
256,258
257,258
259,260
261,262
262,263
262,264
263,264
265,266
265,267
265,268
265,269
265,270
265,271
265,272
265,273
266,267
268,269
270,271
272,273
274,275
277,278
279,280
280,281
282,283
282,284
283,284
284,285
286,287
286,288
286,289
287,288
288,289
288,290
288,291
288,292
288,293
289,290
292,293
294,295
296,297
296,298
297,298
300,301
301,302
301,303
302,303
304,305
305,306
307,308
309,310
310,311
310,312
310,313
311,312
313,314
313,315
314,315
317,318
319,320
319,321
320,321
320,322
321,322
321,323
321,324
322,323
324,325
326,327
328,329
328,330
328,331
328,332
329,330
331,332
333,334
335,336
337,338
337,339
338,339
339,340
339,341
339,342
340,341
343,344
345,346
347,348
349,350
349,351
351,352
352,353
352,354
353,354
355,356
355,357
355,358
355,359
355,360
355,361
355,362
355,363
356,357
358,359
360,361
362,363
364,365
367,368
369,370
370,371
372,373
372,374
373,374
374,375
376,377
376,378
376,379
377,378
378,379
378,380
378,381
378,382
379,380
382,383
384,385
384,386
385,386
388,389
389,390
389,391
390,391
392,393
393,394
395,396
397,398
398,399
398,400
399,400
401,402
403,404
404,405
404,406
405,406
408,409
408,410
409,410
409,411
410,411
410,412
410,413
411,412
413,414
415,416
417,418
417,419
417,420
417,421
418,419
420,421
422,423
424,425
426,427
427,428
427,429
427,430
428,429
431,432
433,434
434,435
434,436
435,436
437,438
439,440
439,441
441,442
441,443
442,443
442,444
443,444
445,446
445,447
445,448
446,447
448,449
448,450
448,451
449,450
452,453
454,455
454,456
454,457
455,456
458,459
460,461
461,462
461,463
461,464
461,465
461,466
462,463
465,466
467,468
469,470
469,471
470,471
472,473
474,475
475,476
-----nextToken-----
2,4,6,8,9,11,13,14,16,18,19,23,25,27,29,31,34,36,38,40,42,46,48,49,53,55,58,60,65,68,69,71,74,77,79,80,83,87,89,92,96,99,102,103,107,108,110,114,117,119,121,123,126,130,132,136,137,139,143,147,148,150,155,157,159,161,166,168,170,172,177,178,180,182,188,190,192,194,196,199,201,203,205,210,212,217,220,221,223,228,229,231,233,238,239,241,243,247,250,252,254,258,260,264,267,269,271,273,275,276,278,281,285,290,291,293,295,298,299,303,306,308,312,315,316,318,323,325,327,330,332,334,336,341,342,344,346,348,350,354,357,359,361,363,365,366,368,371,375,380,381,383,386,387,391,394,396,400,402,406,407,412,414,416,419,421,423,425,429,430,432,436,438,440,444,447,450,451,453,456,457,459,463,464,466,468,471,473,476
-----computeFrom-----
94,95
94,96
112,113
112,114
128,129
128,130
184,185
184,186
208,209
208,210
245,246
245,247
256,257
256,258
262,263
262,264
320,321
320,322
352,353
352,354
398,399
398,400
404,405
404,406
409,410
409,411
434,435
434,436
442,443
442,444
-----guardedBy-----
201,241
453,468
459,466
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;Declarator;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;UnaryExpression;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ReturnStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;ReturnStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ReturnStatement;LiteralExpression;ProblemStatement;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;GotoStatement;Name;IfStatement;BinaryExpression;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;GotoStatement;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;GotoStatement;Name;IfStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;GotoStatement;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;GotoStatement;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;GotoStatement;Name;ReturnStatement;LiteralExpression;LabelStatement;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;GotoStatement;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;LabelStatement;Name;IfStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ProblemStatement;ReturnStatement;LiteralExpression;
-----ast_node-----
int rename_ref(const char *oldrefname, const char *newrefname, const char *logmsg){	unsigned char sha1[20], orig_sha1[20];	int flag = 0, logmoved = 0;	struct ref_lock *lock;	struct stat loginfo;	int log = !lstat(git_path("logs/%s", oldrefname), &loginfo);	const char *symref = NULL;	struct strbuf err = STRBUF_INIT;	if (log && S_ISLNK(loginfo.st_mode))		return error("reflog for %s is a symlink", oldrefname);	symref = resolve_ref_unsafe(oldrefname, RESOLVE_REF_READING,				    orig_sha1, &flag);	if (flag & REF_ISSYMREF)		return error("refname %s is a symbolic ref, renaming it is not supported",			oldrefname);	if (!symref)		return error("refname %s not found", oldrefname);	if (!rename_ref_available(oldrefname, newrefname))		return 1;	if (log && rename(git_path("logs/%s", oldrefname), git_path(TMP_RENAMED_LOG)))		return error("unable to move logfile logs/%s to "TMP_RENAMED_LOG": %s",			oldrefname, strerror(errno));	if (delete_ref(oldrefname, orig_sha1, REF_NODEREF)) {		error("unable to delete old %s", oldrefname);		goto rollback;	}	if (!read_ref_full(newrefname, RESOLVE_REF_READING, sha1, NULL) &&	    delete_ref(newrefname, sha1, REF_NODEREF)) {		if (errno==EISDIR) {			if (remove_empty_directories(git_path("%s", newrefname))) {				error("Directory not empty: %s", newrefname);				goto rollback;			}		} else {			error("unable to delete existing %s", newrefname);			goto rollback;		}	}	if (log && rename_tmp_log(newrefname))		goto rollback;	logmoved = log;	lock = lock_ref_sha1_basic(newrefname, NULL, NULL, NULL, 0, NULL, &err);	if (!lock) {		error("unable to rename '%s' to '%s': %s", oldrefname, newrefname, err.buf);		strbuf_release(&err);		goto rollback;	}	hashcpy(lock->old_sha1, orig_sha1);	if (write_ref_to_lockfile(lock, orig_sha1) ||	    commit_ref_update(lock, orig_sha1, logmsg)) {		error("unable to write current sha1 into %s", newrefname);		goto rollback;	}	return 0; rollback:	lock = lock_ref_sha1_basic(oldrefname, NULL, NULL, NULL, 0, NULL, &err);	if (!lock) {		error("unable to lock %s for rollback: %s", oldrefname, err.buf);		strbuf_release(&err);		goto rollbacklog;	}	flag = log_all_ref_updates;	log_all_ref_updates = 0;	if (write_ref_to_lockfile(lock, orig_sha1) ||	    commit_ref_update(lock, orig_sha1, NULL))		error("unable to write current sha1 into %s", oldrefname);	log_all_ref_updates = flag; rollbacklog:	if (logmoved && rename(git_path("logs/%s", newrefname), git_path("logs/%s", oldrefname)))		error("unable to restore logfile %s from %s: %s",			oldrefname, newrefname, strerror(errno));	if (!logmoved && log &&	    rename(git_path(TMP_RENAMED_LOG), git_path("logs/%s", oldrefname)))		error("unable to restore logfile %s from "TMP_RENAMED_LOG": %s",			oldrefname, strerror(errno));	return 1;}
int
rename_ref(const char *oldrefname, const char *newrefname, const char *logmsg)
rename_ref
const char *oldrefname
const char
*oldrefname
*
oldrefname
const char *newrefname
const char
*newrefname
*
newrefname
const char *logmsg
const char
*logmsg
*
logmsg
{	unsigned char sha1[20], orig_sha1[20];	int flag = 0, logmoved = 0;	struct ref_lock *lock;	struct stat loginfo;	int log = !lstat(git_path("logs/%s", oldrefname), &loginfo);	const char *symref = NULL;	struct strbuf err = STRBUF_INIT;	if (log && S_ISLNK(loginfo.st_mode))		return error("reflog for %s is a symlink", oldrefname);	symref = resolve_ref_unsafe(oldrefname, RESOLVE_REF_READING,				    orig_sha1, &flag);	if (flag & REF_ISSYMREF)		return error("refname %s is a symbolic ref, renaming it is not supported",			oldrefname);	if (!symref)		return error("refname %s not found", oldrefname);	if (!rename_ref_available(oldrefname, newrefname))		return 1;	if (log && rename(git_path("logs/%s", oldrefname), git_path(TMP_RENAMED_LOG)))		return error("unable to move logfile logs/%s to "TMP_RENAMED_LOG": %s",			oldrefname, strerror(errno));	if (delete_ref(oldrefname, orig_sha1, REF_NODEREF)) {		error("unable to delete old %s", oldrefname);		goto rollback;	}	if (!read_ref_full(newrefname, RESOLVE_REF_READING, sha1, NULL) &&	    delete_ref(newrefname, sha1, REF_NODEREF)) {		if (errno==EISDIR) {			if (remove_empty_directories(git_path("%s", newrefname))) {				error("Directory not empty: %s", newrefname);				goto rollback;			}		} else {			error("unable to delete existing %s", newrefname);			goto rollback;		}	}	if (log && rename_tmp_log(newrefname))		goto rollback;	logmoved = log;	lock = lock_ref_sha1_basic(newrefname, NULL, NULL, NULL, 0, NULL, &err);	if (!lock) {		error("unable to rename '%s' to '%s': %s", oldrefname, newrefname, err.buf);		strbuf_release(&err);		goto rollback;	}	hashcpy(lock->old_sha1, orig_sha1);	if (write_ref_to_lockfile(lock, orig_sha1) ||	    commit_ref_update(lock, orig_sha1, logmsg)) {		error("unable to write current sha1 into %s", newrefname);		goto rollback;	}	return 0; rollback:	lock = lock_ref_sha1_basic(oldrefname, NULL, NULL, NULL, 0, NULL, &err);	if (!lock) {		error("unable to lock %s for rollback: %s", oldrefname, err.buf);		strbuf_release(&err);		goto rollbacklog;	}	flag = log_all_ref_updates;	log_all_ref_updates = 0;	if (write_ref_to_lockfile(lock, orig_sha1) ||	    commit_ref_update(lock, orig_sha1, NULL))		error("unable to write current sha1 into %s", oldrefname);	log_all_ref_updates = flag; rollbacklog:	if (logmoved && rename(git_path("logs/%s", newrefname), git_path("logs/%s", oldrefname)))		error("unable to restore logfile %s from %s: %s",			oldrefname, newrefname, strerror(errno));	if (!logmoved && log &&	    rename(git_path(TMP_RENAMED_LOG), git_path("logs/%s", oldrefname)))		error("unable to restore logfile %s from "TMP_RENAMED_LOG": %s",			oldrefname, strerror(errno));	return 1;}
unsigned char sha1[20], orig_sha1[20];
unsigned char sha1[20], orig_sha1[20];
unsigned char
sha1[20]
sha1
[20]
20
orig_sha1[20]
orig_sha1
[20]
20
int flag = 0, logmoved = 0;
int flag = 0, logmoved = 0;
int
flag = 0
flag
= 0
0
logmoved = 0
logmoved
= 0
0
struct ref_lock *lock;
struct ref_lock *lock;
struct ref_lock
ref_lock
*lock
*
lock
struct stat loginfo;
struct stat loginfo;
struct stat
stat
loginfo
loginfo
int log = !lstat(git_path("logs/%s", oldrefname), &loginfo);
int log = !lstat(git_path("logs/%s", oldrefname), &loginfo);
int
log = !lstat(git_path("logs/%s", oldrefname), &loginfo)
log
= !lstat(git_path("logs/%s", oldrefname), &loginfo)
!lstat(git_path("logs/%s", oldrefname), &loginfo)
lstat(git_path("logs/%s", oldrefname), &loginfo)
lstat
lstat
git_path("logs/%s", oldrefname)
git_path
git_path
"logs/%s"
oldrefname
oldrefname
&loginfo
loginfo
loginfo
const char *symref = NULL;
const char *symref = NULL;
const char
*symref = NULL
*
symref
= NULL
NULL
NULL
struct strbuf err = STRBUF_INIT;
struct strbuf err = STRBUF_INIT;
struct strbuf
strbuf
err = STRBUF_INIT
err
= STRBUF_INIT
STRBUF_INIT
STRBUF_INIT
if (log && S_ISLNK(loginfo.st_mode))		return error("reflog for %s is a symlink", oldrefname);
log && S_ISLNK(loginfo.st_mode)
log
log
S_ISLNK(loginfo.st_mode)
S_ISLNK
S_ISLNK
loginfo.st_mode
loginfo
loginfo
st_mode
return error("reflog for %s is a symlink", oldrefname);
error("reflog for %s is a symlink", oldrefname)
error
error
"reflog for %s is a symlink"
oldrefname
oldrefname
symref = resolve_ref_unsafe(oldrefname, RESOLVE_REF_READING,				    orig_sha1, &flag);
symref = resolve_ref_unsafe(oldrefname, RESOLVE_REF_READING,				    orig_sha1, &flag)
symref
symref
resolve_ref_unsafe(oldrefname, RESOLVE_REF_READING,				    orig_sha1, &flag)
resolve_ref_unsafe
resolve_ref_unsafe
oldrefname
oldrefname
RESOLVE_REF_READING
RESOLVE_REF_READING
orig_sha1
orig_sha1
&flag
flag
flag
if (flag & REF_ISSYMREF)		return error("refname %s is a symbolic ref, renaming it is not supported",			oldrefname);
flag & REF_ISSYMREF
flag
flag
REF_ISSYMREF
REF_ISSYMREF
return error("refname %s is a symbolic ref, renaming it is not supported",			oldrefname);
error("refname %s is a symbolic ref, renaming it is not supported",			oldrefname)
error
error
"refname %s is a symbolic ref, renaming it is not supported"
oldrefname
oldrefname
if (!symref)		return error("refname %s not found", oldrefname);
!symref
symref
symref
return error("refname %s not found", oldrefname);
error("refname %s not found", oldrefname)
error
error
"refname %s not found"
oldrefname
oldrefname
if (!rename_ref_available(oldrefname, newrefname))		return 1;
!rename_ref_available(oldrefname, newrefname)
rename_ref_available(oldrefname, newrefname)
rename_ref_available
rename_ref_available
oldrefname
oldrefname
newrefname
newrefname
return 1;
1
if (log && rename(git_path("logs/%s", oldrefname), git_path(TMP_RENAMED_LOG)))		return error("unable to move logfile logs/%s to "TMP_RENAMED_LOG": %s",			oldrefname, strerror(errno));
if (delete_ref(oldrefname, orig_sha1, REF_NODEREF)) {		error("unable to delete old %s", oldrefname);		goto rollback;	}
delete_ref(oldrefname, orig_sha1, REF_NODEREF)
delete_ref
delete_ref
oldrefname
oldrefname
orig_sha1
orig_sha1
REF_NODEREF
REF_NODEREF
{		error("unable to delete old %s", oldrefname);		goto rollback;	}
error("unable to delete old %s", oldrefname);
error("unable to delete old %s", oldrefname)
error
error
"unable to delete old %s"
oldrefname
oldrefname
goto rollback;
rollback
if (!read_ref_full(newrefname, RESOLVE_REF_READING, sha1, NULL) &&	    delete_ref(newrefname, sha1, REF_NODEREF)) {		if (errno==EISDIR) {			if (remove_empty_directories(git_path("%s", newrefname))) {				error("Directory not empty: %s", newrefname);				goto rollback;			}		} else {			error("unable to delete existing %s", newrefname);			goto rollback;		}	}
!read_ref_full(newrefname, RESOLVE_REF_READING, sha1, NULL) &&	    delete_ref(newrefname, sha1, REF_NODEREF)
!read_ref_full(newrefname, RESOLVE_REF_READING, sha1, NULL)
read_ref_full(newrefname, RESOLVE_REF_READING, sha1, NULL)
read_ref_full
read_ref_full
newrefname
newrefname
RESOLVE_REF_READING
RESOLVE_REF_READING
sha1
sha1
NULL
NULL
delete_ref(newrefname, sha1, REF_NODEREF)
delete_ref
delete_ref
newrefname
newrefname
sha1
sha1
REF_NODEREF
REF_NODEREF
{		if (errno==EISDIR) {			if (remove_empty_directories(git_path("%s", newrefname))) {				error("Directory not empty: %s", newrefname);				goto rollback;			}		} else {			error("unable to delete existing %s", newrefname);			goto rollback;		}	}
if (errno==EISDIR) {			if (remove_empty_directories(git_path("%s", newrefname))) {				error("Directory not empty: %s", newrefname);				goto rollback;			}		} else {			error("unable to delete existing %s", newrefname);			goto rollback;		}
errno==EISDIR
errno
errno
EISDIR
EISDIR
{			if (remove_empty_directories(git_path("%s", newrefname))) {				error("Directory not empty: %s", newrefname);				goto rollback;			}		}
if (remove_empty_directories(git_path("%s", newrefname))) {				error("Directory not empty: %s", newrefname);				goto rollback;			}
remove_empty_directories(git_path("%s", newrefname))
remove_empty_directories
remove_empty_directories
git_path("%s", newrefname)
git_path
git_path
"%s"
newrefname
newrefname
{				error("Directory not empty: %s", newrefname);				goto rollback;			}
error("Directory not empty: %s", newrefname);
error("Directory not empty: %s", newrefname)
error
error
"Directory not empty: %s"
newrefname
newrefname
goto rollback;
rollback
{			error("unable to delete existing %s", newrefname);			goto rollback;		}
error("unable to delete existing %s", newrefname);
error("unable to delete existing %s", newrefname)
error
error
"unable to delete existing %s"
newrefname
newrefname
goto rollback;
rollback
if (log && rename_tmp_log(newrefname))		goto rollback;
log && rename_tmp_log(newrefname)
log
log
rename_tmp_log(newrefname)
rename_tmp_log
rename_tmp_log
newrefname
newrefname
goto rollback;
rollback
logmoved = log;
logmoved = log
logmoved
logmoved
log
log
lock = lock_ref_sha1_basic(newrefname, NULL, NULL, NULL, 0, NULL, &err);
lock = lock_ref_sha1_basic(newrefname, NULL, NULL, NULL, 0, NULL, &err)
lock
lock
lock_ref_sha1_basic(newrefname, NULL, NULL, NULL, 0, NULL, &err)
lock_ref_sha1_basic
lock_ref_sha1_basic
newrefname
newrefname
NULL
NULL
NULL
NULL
NULL
NULL
0
NULL
NULL
&err
err
err
if (!lock) {		error("unable to rename '%s' to '%s': %s", oldrefname, newrefname, err.buf);		strbuf_release(&err);		goto rollback;	}
!lock
lock
lock
{		error("unable to rename '%s' to '%s': %s", oldrefname, newrefname, err.buf);		strbuf_release(&err);		goto rollback;	}
error("unable to rename '%s' to '%s': %s", oldrefname, newrefname, err.buf);
error("unable to rename '%s' to '%s': %s", oldrefname, newrefname, err.buf)
error
error
"unable to rename '%s' to '%s': %s"
oldrefname
oldrefname
newrefname
newrefname
err.buf
err
err
buf
strbuf_release(&err);
strbuf_release(&err)
strbuf_release
strbuf_release
&err
err
err
goto rollback;
rollback
hashcpy(lock->old_sha1, orig_sha1);
hashcpy(lock->old_sha1, orig_sha1)
hashcpy
hashcpy
lock->old_sha1
lock
lock
old_sha1
orig_sha1
orig_sha1
if (write_ref_to_lockfile(lock, orig_sha1) ||	    commit_ref_update(lock, orig_sha1, logmsg)) {		error("unable to write current sha1 into %s", newrefname);		goto rollback;	}
write_ref_to_lockfile(lock, orig_sha1) ||	    commit_ref_update(lock, orig_sha1, logmsg)
write_ref_to_lockfile(lock, orig_sha1)
write_ref_to_lockfile
write_ref_to_lockfile
lock
lock
orig_sha1
orig_sha1
commit_ref_update(lock, orig_sha1, logmsg)
commit_ref_update
commit_ref_update
lock
lock
orig_sha1
orig_sha1
logmsg
logmsg
{		error("unable to write current sha1 into %s", newrefname);		goto rollback;	}
error("unable to write current sha1 into %s", newrefname);
error("unable to write current sha1 into %s", newrefname)
error
error
"unable to write current sha1 into %s"
newrefname
newrefname
goto rollback;
rollback
return 0;
0
rollback:	lock = lock_ref_sha1_basic(oldrefname, NULL, NULL, NULL, 0, NULL, &err);
rollback
lock = lock_ref_sha1_basic(oldrefname, NULL, NULL, NULL, 0, NULL, &err);
lock = lock_ref_sha1_basic(oldrefname, NULL, NULL, NULL, 0, NULL, &err)
lock
lock
lock_ref_sha1_basic(oldrefname, NULL, NULL, NULL, 0, NULL, &err)
lock_ref_sha1_basic
lock_ref_sha1_basic
oldrefname
oldrefname
NULL
NULL
NULL
NULL
NULL
NULL
0
NULL
NULL
&err
err
err
if (!lock) {		error("unable to lock %s for rollback: %s", oldrefname, err.buf);		strbuf_release(&err);		goto rollbacklog;	}
!lock
lock
lock
{		error("unable to lock %s for rollback: %s", oldrefname, err.buf);		strbuf_release(&err);		goto rollbacklog;	}
error("unable to lock %s for rollback: %s", oldrefname, err.buf);
error("unable to lock %s for rollback: %s", oldrefname, err.buf)
error
error
"unable to lock %s for rollback: %s"
oldrefname
oldrefname
err.buf
err
err
buf
strbuf_release(&err);
strbuf_release(&err)
strbuf_release
strbuf_release
&err
err
err
goto rollbacklog;
rollbacklog
flag = log_all_ref_updates;
flag = log_all_ref_updates
flag
flag
log_all_ref_updates
log_all_ref_updates
log_all_ref_updates = 0;
log_all_ref_updates = 0
log_all_ref_updates
log_all_ref_updates
0
if (write_ref_to_lockfile(lock, orig_sha1) ||	    commit_ref_update(lock, orig_sha1, NULL))		error("unable to write current sha1 into %s", oldrefname);
write_ref_to_lockfile(lock, orig_sha1) ||	    commit_ref_update(lock, orig_sha1, NULL)
write_ref_to_lockfile(lock, orig_sha1)
write_ref_to_lockfile
write_ref_to_lockfile
lock
lock
orig_sha1
orig_sha1
commit_ref_update(lock, orig_sha1, NULL)
commit_ref_update
commit_ref_update
lock
lock
orig_sha1
orig_sha1
NULL
NULL
error("unable to write current sha1 into %s", oldrefname);
error("unable to write current sha1 into %s", oldrefname)
error
error
"unable to write current sha1 into %s"
oldrefname
oldrefname
log_all_ref_updates = flag;
log_all_ref_updates = flag
log_all_ref_updates
log_all_ref_updates
flag
flag
rollbacklog:	if (logmoved && rename(git_path("logs/%s", newrefname), git_path("logs/%s", oldrefname)))		error("unable to restore logfile %s from %s: %s",			oldrefname, newrefname, strerror(errno));
rollbacklog
if (logmoved && rename(git_path("logs/%s", newrefname), git_path("logs/%s", oldrefname)))		error("unable to restore logfile %s from %s: %s",			oldrefname, newrefname, strerror(errno));
logmoved && rename(git_path("logs/%s", newrefname), git_path("logs/%s", oldrefname))
logmoved
logmoved
rename(git_path("logs/%s", newrefname), git_path("logs/%s", oldrefname))
rename
rename
git_path("logs/%s", newrefname)
git_path
git_path
"logs/%s"
newrefname
newrefname
git_path("logs/%s", oldrefname)
git_path
git_path
"logs/%s"
oldrefname
oldrefname
error("unable to restore logfile %s from %s: %s",			oldrefname, newrefname, strerror(errno));
error("unable to restore logfile %s from %s: %s",			oldrefname, newrefname, strerror(errno))
error
error
"unable to restore logfile %s from %s: %s"
oldrefname
oldrefname
newrefname
newrefname
strerror(errno)
strerror
strerror
errno
errno
if (!logmoved && log &&	    rename(git_path(TMP_RENAMED_LOG), git_path("logs/%s", oldrefname)))		error("unable to restore logfile %s from "TMP_RENAMED_LOG": %s",			oldrefname, strerror(errno));
return 1;
1
-----joern-----
(18,47,0)
(167,249,0)
(69,184,0)
(160,100,0)
(223,36,0)
(237,181,0)
(208,78,0)
(105,170,0)
(166,1,0)
(0,137,0)
(140,180,0)
(237,124,0)
(149,266,0)
(86,108,0)
(39,145,0)
(174,137,0)
(192,108,0)
(5,124,0)
(34,265,0)
(171,265,0)
(19,175,0)
(194,137,0)
(248,23,0)
(64,265,0)
(238,23,0)
(269,183,0)
(11,237,0)
(84,249,0)
(49,18,0)
(108,265,0)
(149,23,0)
(22,229,0)
(180,3,0)
(55,265,0)
(96,88,0)
(248,175,0)
(102,265,0)
(118,163,0)
(51,18,0)
(92,157,0)
(145,188,0)
(103,265,0)
(267,102,0)
(117,265,0)
(42,268,0)
(71,2,0)
(70,163,0)
(197,248,0)
(77,179,0)
(135,23,0)
(188,145,0)
(240,86,0)
(221,26,0)
(102,165,0)
(184,102,0)
(217,265,0)
(239,181,0)
(2,0,0)
(72,23,0)
(21,134,0)
(170,105,0)
(143,265,0)
(271,3,0)
(165,262,0)
(21,209,0)
(228,190,0)
(43,242,0)
(266,149,0)
(29,198,0)
(2,245,0)
(183,23,0)
(10,178,0)
(147,5,0)
(31,170,0)
(47,18,0)
(22,114,0)
(207,36,0)
(238,209,0)
(261,100,0)
(27,57,0)
(262,123,0)
(176,267,0)
(4,102,0)
(76,107,0)
(260,32,0)
(60,108,0)
(13,230,0)
(166,49,0)
(252,108,0)
(1,102,0)
(180,265,0)
(213,80,0)
(163,53,0)
(18,49,0)
(65,102,0)
(113,240,0)
(80,47,0)
(41,107,0)
(97,135,0)
(253,107,0)
(170,65,0)
(232,265,0)
(230,124,0)
(44,123,0)
(244,148,0)
(264,23,0)
(204,145,0)
(219,56,0)
(26,46,0)
(58,48,0)
(49,166,0)
(36,124,0)
(202,137,0)
(52,17,0)
(86,240,0)
(262,139,0)
(100,23,0)
(58,124,0)
(136,265,0)
(73,58,0)
(85,230,0)
(157,265,0)
(116,265,0)
(185,53,0)
(196,66,0)
(16,137,0)
(5,66,0)
(234,160,0)
(263,26,0)
(193,36,0)
(138,238,0)
(2,71,0)
(46,265,0)
(15,5,0)
(254,25,0)
(178,201,0)
(249,23,0)
(227,265,0)
(53,265,0)
(127,249,0)
(122,180,0)
(137,202,0)
(262,165,0)
(112,7,0)
(54,123,0)
(111,265,0)
(199,23,0)
(60,6,0)
(135,120,0)
(65,170,0)
(26,23,0)
(90,32,0)
(177,265,0)
(163,201,0)
(18,102,0)
(251,2,0)
(212,3,0)
(225,137,0)
(38,99,0)
(149,124,0)
(259,25,0)
(242,0,0)
(241,31,0)
(88,265,0)
(153,0,0)
(272,199,0)
(22,230,0)
(267,188,0)
(248,87,0)
(240,23,0)
(131,137,0)
(202,108,0)
(33,210,0)
(48,193,0)
(91,116,0)
(3,265,0)
(104,190,0)
(246,38,0)
(59,265,0)
(229,22,0)
(17,72,0)
(214,265,0)
(63,202,0)
(133,264,0)
(6,60,0)
(224,265,0)
(201,178,0)
(114,22,0)
(42,124,0)
(162,265,0)
(193,48,0)
(186,42,0)
(114,116,0)
(21,7,0)
(24,31,0)
(89,42,0)
(240,124,0)
(230,22,0)
(122,157,0)
(172,210,0)
(268,42,0)
(21,120,0)
(164,265,0)
(71,32,0)
(270,240,0)
(155,160,0)
(123,262,0)
(95,26,0)
(94,166,0)
(35,264,0)
(82,229,0)
(215,99,0)
(169,248,0)
(72,17,0)
(72,124,0)
(257,150,0)
(21,87,0)
(9,46,0)
(8,229,0)
(121,28,0)
(151,265,0)
(100,56,0)
(247,265,0)
(110,249,0)
(21,162,0)
(62,103,0)
(98,88,0)
(201,163,0)
(119,178,0)
(159,83,0)
(226,180,0)
(125,77,0)
(123,23,0)
(206,263,0)
(107,23,0)
(142,264,0)
(148,184,0)
(53,249,0)
(198,47,0)
(20,265,0)
(68,139,0)
(139,262,0)
(220,116,0)
(99,38,0)
(36,193,0)
(210,231,0)
(106,199,0)
(141,99,0)
(67,142,0)
(198,23,0)
(187,265,0)
(26,263,0)
(156,238,0)
(126,58,0)
(109,60,0)
(81,162,0)
(99,0,0)
(218,237,0)
(249,53,0)
(160,108,0)
(178,53,0)
(101,265,0)
(190,88,0)
(166,116,0)
(0,265,0)
(61,86,0)
(28,249,0)
(115,183,0)
(31,23,0)
(263,88,0)
(173,1,0)
(46,26,0)
(240,216,0)
(255,103,0)
(40,265,0)
(45,249,0)
(235,265,0)
(38,265,0)
(93,216,0)
(195,240,0)
(47,198,0)
(258,72,0)
(205,72,0)
(128,114,0)
(168,58,0)
(77,108,0)
(203,46,0)
(78,134,0)
(175,248,0)
(222,249,0)
(129,122,0)
(236,36,0)
(184,148,0)
(21,122,0)
(146,157,0)
(152,265,0)
(165,102,0)
(78,23,0)
(32,0,0)
(188,267,0)
(74,78,0)
(148,124,0)
(48,58,0)
(114,1,0)
(32,71,0)
(137,124,0)
(179,216,0)
(30,26,0)
(1,265,0)
(158,2,0)
(122,265,0)
(179,77,0)
(229,23,0)
(210,124,0)
(132,105,0)
(191,2,0)
(199,150,0)
(79,58,0)
(47,80,0)
(14,231,0)
(182,265,0)
(130,1,0)
(137,0,0)
(6,56,0)
(233,149,0)
(249,28,0)
(170,31,0)
(100,160,0)
(211,203,0)
(75,135,0)
(161,163,0)
(243,86,0)
(12,149,0)
(28,108,0)
(57,53,0)
(154,65,0)
(144,137,0)
(50,72,0)
(250,198,0)
(37,100,0)
(200,189,0)
(264,142,0)
(226,140,1)
(193,36,1)
(36,124,1)
(51,166,1)
(94,72,1)
(215,141,1)
(78,23,1)
(137,202,1)
(186,25,1)
(71,32,1)
(236,223,1)
(229,23,1)
(262,123,1)
(12,203,1)
(251,158,1)
(63,194,1)
(202,63,1)
(0,137,1)
(44,4,1)
(60,109,1)
(97,190,1)
(5,15,1)
(24,241,1)
(263,206,1)
(43,0,1)
(131,153,1)
(75,97,1)
(210,33,1)
(86,243,1)
(199,272,1)
(148,124,1)
(103,255,1)
(76,41,1)
(3,271,1)
(204,39,1)
(158,32,1)
(65,170,1)
(244,69,1)
(266,149,1)
(184,148,1)
(172,25,1)
(119,157,1)
(148,244,1)
(87,248,1)
(81,71,1)
(228,46,1)
(21,120,1)
(22,230,1)
(240,23,1)
(195,242,1)
(21,134,1)
(21,209,1)
(170,105,1)
(141,242,1)
(91,88,1)
(2,0,1)
(237,124,1)
(166,116,1)
(129,264,1)
(173,184,1)
(96,98,1)
(9,267,1)
(32,90,1)
(18,102,1)
(123,54,1)
(142,67,1)
(183,23,1)
(122,129,1)
(233,12,1)
(146,3,1)
(185,257,1)
(157,92,1)
(168,73,1)
(140,183,1)
(241,154,1)
(174,225,1)
(206,30,1)
(4,116,1)
(180,226,1)
(69,193,1)
(6,60,1)
(163,70,1)
(234,261,1)
(140,201,1)
(73,107,1)
(84,45,1)
(86,108,1)
(28,121,1)
(45,222,1)
(154,266,1)
(220,91,1)
(10,119,1)
(268,42,1)
(237,218,1)
(108,252,1)
(240,124,1)
(42,124,1)
(65,154,1)
(27,53,1)
(197,169,1)
(118,178,1)
(225,16,1)
(33,172,1)
(248,23,1)
(26,23,1)
(7,112,1)
(31,23,1)
(53,249,1)
(95,221,1)
(238,23,1)
(198,250,1)
(47,80,1)
(243,61,1)
(240,86,1)
(36,207,1)
(99,0,1)
(92,146,1)
(79,126,1)
(139,68,1)
(269,115,1)
(184,102,1)
(128,219,1)
(125,240,1)
(149,23,1)
(130,173,1)
(41,253,1)
(207,236,1)
(149,233,1)
(38,246,1)
(250,29,1)
(114,116,1)
(230,85,1)
(58,79,1)
(72,17,1)
(31,24,1)
(210,124,1)
(193,48,1)
(198,23,1)
(35,49,1)
(57,27,1)
(107,76,1)
(160,108,1)
(249,28,1)
(212,57,1)
(259,254,1)
(248,175,1)
(201,178,1)
(264,23,1)
(192,103,1)
(72,23,1)
(196,5,1)
(21,122,1)
(257,199,1)
(38,99,1)
(85,13,1)
(267,102,1)
(110,167,1)
(77,108,1)
(2,191,1)
(202,108,1)
(249,23,1)
(184,69,1)
(223,48,1)
(123,23,1)
(18,51,1)
(99,215,1)
(30,95,1)
(72,124,1)
(185,14,1)
(185,239,1)
(28,108,1)
(169,65,1)
(213,51,1)
(180,3,1)
(246,99,1)
(90,260,1)
(264,142,1)
(109,100,1)
(242,43,1)
(128,180,1)
(165,262,1)
(115,201,1)
(14,210,1)
(50,205,1)
(188,145,1)
(252,192,1)
(185,196,1)
(22,229,1)
(67,133,1)
(191,251,1)
(190,88,1)
(57,53,1)
(262,139,1)
(114,22,1)
(149,124,1)
(65,102,1)
(1,130,1)
(270,113,1)
(183,269,1)
(205,114,1)
(185,93,1)
(16,131,1)
(211,190,1)
(39,176,1)
(42,89,1)
(82,230,1)
(122,180,1)
(209,238,1)
(190,104,1)
(1,102,1)
(122,157,1)
(105,132,1)
(221,9,1)
(254,193,1)
(5,124,1)
(238,156,1)
(145,204,1)
(178,10,1)
(133,35,1)
(126,168,1)
(32,0,1)
(54,44,1)
(222,185,1)
(21,87,1)
(114,128,1)
(8,82,1)
(69,268,1)
(100,160,1)
(13,128,1)
(104,228,1)
(58,124,1)
(258,50,1)
(272,106,1)
(162,81,1)
(135,23,1)
(37,57,1)
(17,52,1)
(102,165,1)
(194,144,1)
(256,184,1)
(93,179,1)
(178,53,1)
(229,8,1)
(218,11,1)
(25,259,1)
(255,62,1)
(47,198,1)
(166,94,1)
(62,102,1)
(15,147,1)
(100,23,1)
(113,195,1)
(46,26,1)
(166,1,1)
(242,0,1)
(263,88,1)
(144,174,1)
(74,203,1)
(199,23,1)
(179,77,1)
(271,212,1)
(49,18,1)
(80,213,1)
(161,118,1)
(261,37,1)
(147,71,1)
(112,266,1)
(163,53,1)
(21,162,1)
(89,186,1)
(120,135,1)
(77,125,1)
(176,108,1)
(60,108,1)
(121,110,1)
(132,31,1)
(26,263,1)
(116,220,1)
(153,1,1)
(134,78,1)
(18,47,1)
(260,38,1)
(137,124,1)
(70,161,1)
(201,163,1)
(94,114,1)
(167,127,1)
(21,7,1)
(29,80,1)
(253,65,1)
(71,2,1)
(160,155,1)
(239,237,1)
(2,245,1)
(78,208,1)
(68,123,1)
(129,49,1)
(88,96,1)
(267,188,1)
(155,234,1)
(219,6,1)
(135,75,1)
(11,268,1)
(49,166,1)
(175,19,1)
(230,124,1)
(48,58,1)
(170,31,1)
(61,270,1)
(19,197,1)
(138,267,1)
(267,176,1)
(156,138,1)
(208,74,1)
(106,107,1)
(52,258,1)
(107,23,1)
(114,1,1)
(203,46,1)
(185,256,1)
(127,84,1)
(203,211,1)
(229,23,2)
(270,242,2)
(9,267,2)
(16,184,2)
(129,71,2)
(65,266,2)
(266,149,2)
(42,25,2)
(212,57,2)
(250,51,2)
(196,71,2)
(24,154,2)
(157,57,2)
(195,242,2)
(53,268,2)
(49,242,2)
(53,249,2)
(37,57,2)
(21,162,2)
(72,17,2)
(248,65,2)
(222,25,2)
(167,184,2)
(180,3,2)
(32,0,2)
(49,107,2)
(60,108,2)
(166,268,2)
(29,51,2)
(112,266,2)
(135,23,2)
(185,268,2)
(174,184,2)
(256,184,2)
(32,242,2)
(129,184,2)
(261,57,2)
(99,0,2)
(41,65,2)
(57,184,2)
(87,65,2)
(27,107,2)
(249,107,2)
(106,107,2)
(228,267,2)
(211,190,2)
(22,128,2)
(141,242,2)
(249,184,2)
(263,267,2)
(57,25,2)
(18,166,2)
(198,51,2)
(122,180,2)
(162,71,2)
(28,242,2)
(190,88,2)
(226,57,2)
(133,49,2)
(94,25,2)
(240,124,2)
(63,184,2)
(167,242,2)
(138,267,2)
(225,184,2)
(45,268,2)
(207,48,2)
(7,266,2)
(46,267,2)
(193,107,2)
(230,128,2)
(70,178,2)
(17,114,2)
(230,124,2)
(259,193,2)
(170,154,2)
(147,71,2)
(142,49,2)
(57,242,2)
(161,178,2)
(95,267,2)
(27,268,2)
(218,268,2)
(223,48,2)
(160,57,2)
(57,71,2)
(114,1,2)
(21,122,2)
(179,77,2)
(262,139,2)
(222,107,2)
(222,71,2)
(172,25,2)
(28,71,2)
(113,242,2)
(137,202,2)
(47,198,2)
(193,48,2)
(168,107,2)
(144,184,2)
(186,25,2)
(167,25,2)
(249,25,2)
(203,46,2)
(134,203,2)
(249,268,2)
(140,57,2)
(156,267,2)
(128,107,2)
(10,57,2)
(51,166,2)
(71,242,2)
(71,2,2)
(114,71,2)
(97,190,2)
(14,25,2)
(114,184,2)
(28,107,2)
(45,107,2)
(122,25,2)
(84,268,2)
(46,26,2)
(94,268,2)
(160,108,2)
(28,184,2)
(209,267,2)
(241,154,2)
(5,124,2)
(110,25,2)
(38,242,2)
(118,178,2)
(127,184,2)
(72,114,2)
(191,32,2)
(215,242,2)
(92,57,2)
(127,242,2)
(74,203,2)
(61,242,2)
(267,102,2)
(45,184,2)
(109,57,2)
(129,25,2)
(237,124,2)
(22,229,2)
(185,107,2)
(166,25,2)
(221,267,2)
(222,184,2)
(188,176,2)
(122,242,2)
(166,71,2)
(18,47,2)
(76,65,2)
(206,267,2)
(84,71,2)
(49,268,2)
(122,107,2)
(33,25,2)
(145,176,2)
(242,0,2)
(264,49,2)
(119,57,2)
(163,178,2)
(49,25,2)
(184,268,2)
(185,242,2)
(267,188,2)
(45,242,2)
(72,124,2)
(155,57,2)
(123,23,2)
(114,268,2)
(127,25,2)
(36,48,2)
(84,107,2)
(194,184,2)
(104,267,2)
(57,53,2)
(254,193,2)
(84,242,2)
(102,165,2)
(178,57,2)
(180,57,2)
(184,102,2)
(90,242,2)
(167,71,2)
(86,108,2)
(236,48,2)
(268,42,2)
(249,23,2)
(137,184,2)
(5,71,2)
(183,201,2)
(185,71,2)
(268,25,2)
(272,107,2)
(249,71,2)
(45,25,2)
(262,123,2)
(13,128,2)
(28,108,2)
(94,71,2)
(58,124,2)
(244,69,2)
(69,268,2)
(131,184,2)
(86,242,2)
(57,107,2)
(128,25,2)
(149,203,2)
(110,184,2)
(121,71,2)
(208,203,2)
(19,65,2)
(260,242,2)
(149,23,2)
(153,184,2)
(110,268,2)
(18,102,2)
(21,134,2)
(201,57,2)
(36,124,2)
(22,230,2)
(132,154,2)
(49,18,2)
(271,57,2)
(130,184,2)
(105,154,2)
(146,57,2)
(71,32,2)
(203,190,2)
(99,242,2)
(28,268,2)
(121,107,2)
(121,242,2)
(65,170,2)
(67,49,2)
(75,190,2)
(114,22,2)
(202,184,2)
(185,25,2)
(248,175,2)
(100,23,2)
(115,201,2)
(0,184,2)
(110,71,2)
(154,266,2)
(253,65,2)
(94,242,2)
(72,23,2)
(239,268,2)
(121,268,2)
(120,190,2)
(77,108,2)
(125,242,2)
(80,51,2)
(170,105,2)
(201,178,2)
(65,102,2)
(6,57,2)
(148,124,2)
(94,184,2)
(93,242,2)
(166,107,2)
(53,107,2)
(27,184,2)
(175,65,2)
(242,184,2)
(27,242,2)
(53,71,2)
(243,242,2)
(263,88,2)
(128,184,2)
(49,71,2)
(114,25,2)
(199,23,2)
(184,148,2)
(184,193,2)
(107,65,2)
(249,28,2)
(27,71,2)
(21,120,2)
(30,267,2)
(122,71,2)
(249,242,2)
(129,242,2)
(121,25,2)
(73,107,2)
(15,71,2)
(169,65,2)
(38,99,2)
(257,107,2)
(129,107,2)
(69,193,2)
(269,201,2)
(53,25,2)
(240,86,2)
(78,203,2)
(107,23,2)
(53,184,2)
(85,128,2)
(264,23,2)
(26,263,2)
(234,57,2)
(78,23,2)
(202,108,2)
(167,107,2)
(48,107,2)
(135,190,2)
(166,1,2)
(122,268,2)
(237,268,2)
(240,23,2)
(79,107,2)
(166,116,2)
(201,163,2)
(28,25,2)
(264,142,2)
(27,25,2)
(163,53,2)
(128,242,2)
(266,203,2)
(127,268,2)
(35,49,2)
(222,242,2)
(21,7,2)
(137,124,2)
(122,184,2)
(240,242,2)
(2,32,2)
(204,176,2)
(127,107,2)
(114,242,2)
(49,166,2)
(126,107,2)
(31,23,2)
(42,124,2)
(57,268,2)
(179,242,2)
(199,107,2)
(6,60,2)
(26,23,2)
(114,116,2)
(45,71,2)
(11,268,2)
(229,128,2)
(31,154,2)
(21,87,2)
(210,124,2)
(39,176,2)
(2,0,2)
(52,114,2)
(89,25,2)
(60,57,2)
(205,114,2)
(47,80,2)
(128,268,2)
(114,107,2)
(213,51,2)
(12,203,2)
(82,128,2)
(148,69,2)
(127,71,2)
(50,114,2)
(251,32,2)
(84,25,2)
(128,71,2)
(53,242,2)
(166,184,2)
(198,23,2)
(238,267,2)
(47,51,2)
(21,209,2)
(183,23,2)
(122,157,2)
(233,203,2)
(165,262,2)
(173,184,2)
(238,23,2)
(1,184,2)
(258,114,2)
(8,128,2)
(48,58,2)
(246,242,2)
(100,160,2)
(1,102,2)
(149,124,2)
(121,184,2)
(2,245,2)
(110,242,2)
(3,57,2)
(248,23,2)
(58,107,2)
(43,184,2)
(219,57,2)
(129,268,2)
(210,25,2)
(94,107,2)
(0,137,2)
(158,32,2)
(166,242,2)
(26,267,2)
(25,193,2)
(167,268,2)
(188,145,2)
(49,184,2)
(185,184,2)
(100,57,2)
(178,53,2)
(84,184,2)
(197,65,2)
(77,242,2)
(193,36,2)
(222,268,2)
(110,107,2)
(170,31,2)
(190,267,2)
(81,71,2)
-----------------------------------
(0,lock = lock_ref_sha1_basic(newrefname, NULL, NULL, NULL, 0, NULL, &err)
(1,logmoved = log)
(2,commit_ref_update(lock, orig_sha1, logmsg)
(3,flag = log_all_ref_updates)
(4,log)
(5,error("unable to write current sha1 into %s", newrefname)
(6,strbuf_release(&err)
(7,return 1;)
(8,oldrefname)
(9,symref)
(10,orig_sha1)
(11,"Directory not empty: %s")
(12,oldrefname)
(13,"logs/%s")
(14,goto rollback;)
(15,newrefname)
(16,NULL)
(17,strerror(errno)
(18,log &&\n\\n\\t    rename(git_path(TMP_RENAMED_LOG)
(19,errno)
(20,flag)
(21,RET)
(22,rename(git_path("logs/%s", newrefname)
(23,const char *oldrefname)
(24,oldrefname)
(25,errno==EISDIR)
(26,resolve_ref_unsafe(oldrefname, RESOLVE_REF_READING,\n\\n\\t\\t\\t\\t    orig_sha1, &flag)
(27,lock)
(28,&err)
(29,"logs/%s")
(30,orig_sha1)
(31,git_path("logs/%s", oldrefname)
(32,write_ref_to_lockfile(lock, orig_sha1)
(33,newrefname)
(34,rollbacklog:)
(35,"unable to restore logfile %s from "TMP_RENAMED_LOG": %s")
(36,delete_ref(newrefname, sha1, REF_NODEREF)
(37,"unable to lock %s for rollback: %s")
(38,hashcpy(lock->old_sha1, orig_sha1)
(39,loginfo)
(40,if (log && rename(git_path("logs/%s", oldrefname)
(41,orig_sha1)
(42,git_path("%s", newrefname)
(43,lock)
(44,"logs/%s")
(45,NULL)
(46,symref = resolve_ref_unsafe(oldrefname, RESOLVE_REF_READING,\n\\n\\t\\t\\t\\t    orig_sha1, &flag)
(47,rename(git_path(TMP_RENAMED_LOG)
(48,!read_ref_full(newrefname, RESOLVE_REF_READING, sha1, NULL)
(49,!logmoved && log &&\n\\n\\t    rename(git_path(TMP_RENAMED_LOG)
(50,oldrefname)
(51,log)
(52,errno)
(53,lock = lock_ref_sha1_basic(oldrefname, NULL, NULL, NULL, 0, NULL, &err)
(54,oldrefname)
(55,if (!rename_ref_available(oldrefname, newrefname)
(56,)
(57,!lock)
(58,read_ref_full(newrefname, RESOLVE_REF_READING, sha1, NULL)
(59,rollback:)
(60,&err)
(61,err)
(62,symref)
(63,err)
(64,if (!lock)
(65,log && rename(git_path("logs/%s", oldrefname)
(66,)
(67,errno)
(68,loginfo)
(69,log)
(70,NULL)
(71,write_ref_to_lockfile(lock, orig_sha1)
(72,error("unable to restore logfile %s from %s: %s",\n\\n\\t\\t\\toldrefname, newrefname, strerror(errno)
(73,newrefname)
(74,"refname %s not found")
(75,oldrefname)
(76,REF_NODEREF)
(77,&err)
(78,error("refname %s not found", oldrefname)
(79,NULL)
(80,git_path(TMP_RENAMED_LOG)
(81,0)
(82,"logs/%s")
(83,)
(84,NULL)
(85,newrefname)
(86,err.buf)
(87,return error("unable to move logfile logs/%s to "TMP_RENAMED_LOG": %s",\n\\n\\t\\t\\toldrefname, strerror(errno)
(88,flag = 0)
(89,newrefname)
(90,orig_sha1)
(91,logmoved)
(92,0)
(93,goto rollback;)
(94,logmoved)
(95,RESOLVE_REF_READING)
(96,0)
(97,"refname %s is a symbolic ref, renaming it is not supported")
(98,flag)
(99,lock->old_sha1)
(100,error("unable to lock %s for rollback: %s", oldrefname, err.buf)
(101,log)
(102,log = !lstat(git_path("logs/%s", oldrefname)
(103,*symref = NULL)
(104,REF_ISSYMREF)
(105,git_path(TMP_RENAMED_LOG)
(106,"unable to delete old %s")
(107,delete_ref(oldrefname, orig_sha1, REF_NODEREF)
(108,err = STRBUF_INIT)
(109,err)
(110,NULL)
(111,if (!symref)
(112,1)
(113,oldrefname)
(114,logmoved && rename(git_path("logs/%s", newrefname)
(115,"unable to write current sha1 into %s")
(116,logmoved = 0)
(117,if (write_ref_to_lockfile(lock, orig_sha1)
(118,lock)
(119,lock)
(120,return error("refname %s is a symbolic ref, renaming it is not supported",\n\\n\\t\\t\\toldrefname)
(121,err)
(122,return 1;)
(123,git_path("logs/%s", oldrefname)
(124,const char *newrefname)
(125,err)
(126,sha1)
(127,NULL)
(128,logmoved)
(129,1)
(130,log)
(131,newrefname)
(132,TMP_RENAMED_LOG)
(133,oldrefname)
(134,return error("refname %s not found", oldrefname)
(135,error("refname %s is a symbolic ref, renaming it is not supported",\n\\n\\t\\t\\toldrefname)
(136,loginfo)
(137,lock_ref_sha1_basic(newrefname, NULL, NULL, NULL, 0, NULL, &err)
(138,"reflog for %s is a symlink")
(139,&loginfo)
(140,log_all_ref_updates)
(141,lock)
(142,strerror(errno)
(143,err)
(144,0)
(145,loginfo.st_mode)
(146,log_all_ref_updates)
(147,"unable to write current sha1 into %s")
(148,rename_tmp_log(newrefname)
(149,rename_ref_available(oldrefname, newrefname)
(150,)
(151,if (flag & REF_ISSYMREF)
(152,symref)
(153,lock)
(154,log)
(155,buf)
(156,oldrefname)
(157,log_all_ref_updates = 0)
(158,lock)
(159,if (errno==EISDIR)
(160,err.buf)
(161,orig_sha1)
(162,return 0;)
(163,commit_ref_update(lock, orig_sha1, NULL)
(164,if (!read_ref_full(newrefname, RESOLVE_REF_READING, sha1, NULL)
(165,!lstat(git_path("logs/%s", oldrefname)
(166,!logmoved)
(167,0)
(168,RESOLVE_REF_READING)
(169,"unable to move logfile logs/%s to "TMP_RENAMED_LOG": %s")
(170,rename(git_path("logs/%s", oldrefname)
(171,if (!logmoved && log &&\n\\n\\t    rename(git_path(TMP_RENAMED_LOG)
(172,"unable to delete existing %s")
(173,logmoved)
(174,NULL)
(175,strerror(errno)
(176,log)
(177,if (logmoved && rename(git_path("logs/%s", newrefname)
(178,write_ref_to_lockfile(lock, orig_sha1)
(179,strbuf_release(&err)
(180,log_all_ref_updates = flag)
(181,)
(182,orig_sha1)
(183,error("unable to write current sha1 into %s", oldrefname)
(184,log && rename_tmp_log(newrefname)
(185,lock)
(186,"%s")
(187,if (write_ref_to_lockfile(lock, orig_sha1)
(188,S_ISLNK(loginfo.st_mode)
(189,)
(190,flag & REF_ISSYMREF)
(191,logmsg)
(192,err)
(193,!read_ref_full(newrefname, RESOLVE_REF_READING, sha1, NULL)
(194,NULL)
(195,"unable to rename \'%s\' to \'%s\': %s")
(196,goto rollback;)
(197,oldrefname)
(198,git_path("logs/%s", oldrefname)
(199,error("unable to delete old %s", oldrefname)
(200,if (remove_empty_directories(git_path("%s", newrefname)
(201,write_ref_to_lockfile(lock, orig_sha1)
(202,&err)
(203,!symref)
(204,st_mode)
(205,"unable to restore logfile %s from %s: %s")
(206,flag)
(207,REF_NODEREF)
(208,oldrefname)
(209,return error("reflog for %s is a symlink", oldrefname)
(210,error("unable to delete existing %s", newrefname)
(211,symref)
(212,flag)
(213,TMP_RENAMED_LOG)
(214,sha1)
(215,old_sha1)
(216,)
(217,lock)
(218,newrefname)
(219,goto rollbacklog;)
(220,0)
(221,oldrefname)
(222,oldrefname)
(223,newrefname)
(224,if (!lock)
(225,NULL)
(226,flag)
(227,if (log && rename_tmp_log(newrefname)
(228,flag)
(229,git_path("logs/%s", oldrefname)
(230,git_path("logs/%s", newrefname)
(231,)
(232,logmoved)
(233,newrefname)
(234,err)
(235,if (log && S_ISLNK(loginfo.st_mode)
(236,sha1)
(237,error("Directory not empty: %s", newrefname)
(238,error("reflog for %s is a symlink", oldrefname)
(239,goto rollback;)
(240,error("unable to rename \'%s\' to \'%s\': %s", oldrefname, newrefname, err.buf)
(241,"logs/%s")
(242,!lock)
(243,buf)
(244,newrefname)
(245,const char *logmsg)
(246,orig_sha1)
(247,if (delete_ref(oldrefname, orig_sha1, REF_NODEREF)
(248,error("unable to move logfile logs/%s to "TMP_RENAMED_LOG": %s",\n\\n\\t\\t\\toldrefname, strerror(errno)
(249,lock_ref_sha1_basic(oldrefname, NULL, NULL, NULL, 0, NULL, &err)
(250,oldrefname)
(251,orig_sha1)
(252,STRBUF_INIT)
(253,oldrefname)
(254,errno)
(255,NULL)
(256,goto rollback;)
(257,goto rollback;)
(258,newrefname)
(259,EISDIR)
(260,lock)
(261,oldrefname)
(262,lstat(git_path("logs/%s", oldrefname)
(263,&flag)
(264,error("unable to restore logfile %s from "TMP_RENAMED_LOG": %s",\n\\n\\t\\t\\toldrefname, strerror(errno)
(265,)
(266,!rename_ref_available(oldrefname, newrefname)
(267,log && S_ISLNK(loginfo.st_mode)
(268,remove_empty_directories(git_path("%s", newrefname)
(269,oldrefname)
(270,newrefname)
(271,log_all_ref_updates)
(272,oldrefname)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^