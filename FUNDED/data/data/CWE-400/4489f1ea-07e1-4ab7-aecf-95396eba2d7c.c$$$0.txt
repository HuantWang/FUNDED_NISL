-----label-----
0
-----code-----
static void goodG2B()
{
    size_t data;
    /* Initialize data */
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        /* FIX: Use a relatively small number for memory allocation */
        data = 20;
    }
    else
    {
        /* FIX: Use a relatively small number for memory allocation */
        data = 20;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */
            if (data > strlen(HELLO_STRING))
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                /* Copy a small string into myString */
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine("Input is less than the length of the source string");
            }
        }
    }
    else
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */
            if (data > strlen(HELLO_STRING))
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                /* Copy a small string into myString */
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine("Input is less than the length of the source string");
            }
        }
    }
}
-----children-----
1,2
1,3
1,4
3,4
5,6
5,7
5,8
5,9
6,7
7,8
7,9
8,9
10,11
12,13
13,14
13,15
14,15
17,18
17,19
17,20
18,19
19,20
21,22
22,23
23,24
23,25
24,25
27,28
28,29
29,30
29,31
30,31
33,34
33,35
33,36
34,35
35,36
37,38
38,39
38,40
39,40
40,41
40,42
42,43
42,44
45,46
45,47
45,48
46,47
46,48
47,48
49,50
49,51
50,51
52,53
54,55
54,56
54,57
54,58
54,59
55,56
56,57
56,58
57,58
59,60
59,61
60,61
60,62
62,63
64,65
64,66
65,66
67,68
67,69
68,69
70,71
71,72
71,73
74,75
74,76
75,76
75,77
76,77
78,79
80,81
81,82
82,83
82,84
83,84
85,86
87,88
88,89
88,90
88,91
89,90
91,92
93,94
95,96
96,97
96,98
97,98
99,100
101,102
102,103
102,104
103,104
105,106
107,108
108,109
109,110
109,111
110,111
113,114
114,115
114,116
115,116
116,117
116,118
118,119
118,120
121,122
121,123
121,124
122,123
122,124
123,124
125,126
125,127
126,127
128,129
130,131
130,132
130,133
130,134
130,135
131,132
132,133
132,134
133,134
135,136
135,137
136,137
136,138
138,139
140,141
140,142
141,142
143,144
143,145
144,145
146,147
147,148
147,149
150,151
150,152
151,152
151,153
152,153
154,155
156,157
157,158
158,159
158,160
159,160
161,162
163,164
164,165
164,166
164,167
165,166
167,168
169,170
171,172
172,173
172,174
173,174
175,176
177,178
178,179
178,180
179,180
181,182
183,184
184,185
185,186
185,187
186,187
-----nextToken-----
2,4,9,11,15,16,20,25,26,31,32,36,41,43,44,48,51,53,58,61,63,66,69,72,73,77,79,84,86,90,92,94,98,100,104,106,111,112,117,119,120,124,127,129,134,137,139,142,145,148,149,153,155,160,162,166,168,170,174,176,180,182,187,188
-----computeFrom-----
13,14
13,15
23,24
23,25
29,30
29,31
46,47
46,48
56,57
56,58
67,68
67,69
75,76
75,77
122,123
122,124
132,133
132,134
143,144
143,145
151,152
151,153
-----guardedBy-----
53,94
48,69
129,170
124,145
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;FunctionCallExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;FunctionCallExpression;IdExpression;Name;CompoundStatement;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;IfStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FunctionCallExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;TypeIdExpression;TypeId;SimpleDeclSpecifier;Declarator;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;CompoundStatement;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;IfStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FunctionCallExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;TypeIdExpression;TypeId;SimpleDeclSpecifier;Declarator;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;
-----ast_node-----
static void goodG2B(){    size_t data;    /* Initialize data */    data = 0;    if(globalReturnsTrueOrFalse())    {        /* FIX: Use a relatively small number for memory allocation */        data = 20;    }    else    {        /* FIX: Use a relatively small number for memory allocation */        data = 20;    }    if(globalReturnsTrueOrFalse())    {        {            char * myString;            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough             * for the strcpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > strlen(HELLO_STRING))            {                myString = (char *)malloc(data*sizeof(char));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                strcpy(myString, HELLO_STRING);                printLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string");            }        }    }    else    {        {            char * myString;            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough             * for the strcpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > strlen(HELLO_STRING))            {                myString = (char *)malloc(data*sizeof(char));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                strcpy(myString, HELLO_STRING);                printLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string");            }        }    }}
static void
goodG2B()
goodG2B
{    size_t data;    /* Initialize data */    data = 0;    if(globalReturnsTrueOrFalse())    {        /* FIX: Use a relatively small number for memory allocation */        data = 20;    }    else    {        /* FIX: Use a relatively small number for memory allocation */        data = 20;    }    if(globalReturnsTrueOrFalse())    {        {            char * myString;            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough             * for the strcpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > strlen(HELLO_STRING))            {                myString = (char *)malloc(data*sizeof(char));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                strcpy(myString, HELLO_STRING);                printLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string");            }        }    }    else    {        {            char * myString;            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough             * for the strcpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > strlen(HELLO_STRING))            {                myString = (char *)malloc(data*sizeof(char));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                strcpy(myString, HELLO_STRING);                printLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string");            }        }    }}
size_t data;
size_t data;
size_t
size_t
data
data
data = 0;
data = 0
data
data
0
if(globalReturnsTrueOrFalse())    {        /* FIX: Use a relatively small number for memory allocation */        data = 20;    }    else    {        /* FIX: Use a relatively small number for memory allocation */        data = 20;    }
globalReturnsTrueOrFalse()
globalReturnsTrueOrFalse
globalReturnsTrueOrFalse
{        /* FIX: Use a relatively small number for memory allocation */        data = 20;    }
data = 20;
data = 20
data
data
20
{        /* FIX: Use a relatively small number for memory allocation */        data = 20;    }
data = 20;
data = 20
data
data
20
if(globalReturnsTrueOrFalse())    {        {            char * myString;            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough             * for the strcpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > strlen(HELLO_STRING))            {                myString = (char *)malloc(data*sizeof(char));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                strcpy(myString, HELLO_STRING);                printLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string");            }        }    }    else    {        {            char * myString;            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough             * for the strcpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > strlen(HELLO_STRING))            {                myString = (char *)malloc(data*sizeof(char));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                strcpy(myString, HELLO_STRING);                printLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string");            }        }    }
globalReturnsTrueOrFalse()
globalReturnsTrueOrFalse
globalReturnsTrueOrFalse
{        {            char * myString;            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough             * for the strcpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > strlen(HELLO_STRING))            {                myString = (char *)malloc(data*sizeof(char));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                strcpy(myString, HELLO_STRING);                printLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string");            }        }    }
{            char * myString;            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough             * for the strcpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > strlen(HELLO_STRING))            {                myString = (char *)malloc(data*sizeof(char));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                strcpy(myString, HELLO_STRING);                printLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string");            }        }
char * myString;
char * myString;
char
* myString
*
myString
if (data > strlen(HELLO_STRING))            {                myString = (char *)malloc(data*sizeof(char));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                strcpy(myString, HELLO_STRING);                printLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string");            }
data > strlen(HELLO_STRING)
data
data
strlen(HELLO_STRING)
strlen
strlen
HELLO_STRING
HELLO_STRING
{                myString = (char *)malloc(data*sizeof(char));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                strcpy(myString, HELLO_STRING);                printLine(myString);                free(myString);            }
myString = (char *)malloc(data*sizeof(char));
myString = (char *)malloc(data*sizeof(char))
myString
myString
(char *)malloc(data*sizeof(char))
char *
char
*
*
malloc(data*sizeof(char))
malloc
malloc
data*sizeof(char)
data
data
sizeof(char)
char
char

if (myString == NULL) {exit(-1);}
myString == NULL
myString
myString
NULL
NULL
{exit(-1);}
exit(-1);
exit(-1)
exit
exit
-1
1
strcpy(myString, HELLO_STRING);
strcpy(myString, HELLO_STRING)
strcpy
strcpy
myString
myString
HELLO_STRING
HELLO_STRING
printLine(myString);
printLine(myString)
printLine
printLine
myString
myString
free(myString);
free(myString)
free
free
myString
myString
{                printLine("Input is less than the length of the source string");            }
printLine("Input is less than the length of the source string");
printLine("Input is less than the length of the source string")
printLine
printLine
"Input is less than the length of the source string"
{        {            char * myString;            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough             * for the strcpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > strlen(HELLO_STRING))            {                myString = (char *)malloc(data*sizeof(char));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                strcpy(myString, HELLO_STRING);                printLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string");            }        }    }
{            char * myString;            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough             * for the strcpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > strlen(HELLO_STRING))            {                myString = (char *)malloc(data*sizeof(char));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                strcpy(myString, HELLO_STRING);                printLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string");            }        }
char * myString;
char * myString;
char
* myString
*
myString
if (data > strlen(HELLO_STRING))            {                myString = (char *)malloc(data*sizeof(char));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                strcpy(myString, HELLO_STRING);                printLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string");            }
data > strlen(HELLO_STRING)
data
data
strlen(HELLO_STRING)
strlen
strlen
HELLO_STRING
HELLO_STRING
{                myString = (char *)malloc(data*sizeof(char));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                strcpy(myString, HELLO_STRING);                printLine(myString);                free(myString);            }
myString = (char *)malloc(data*sizeof(char));
myString = (char *)malloc(data*sizeof(char))
myString
myString
(char *)malloc(data*sizeof(char))
char *
char
*
*
malloc(data*sizeof(char))
malloc
malloc
data*sizeof(char)
data
data
sizeof(char)
char
char

if (myString == NULL) {exit(-1);}
myString == NULL
myString
myString
NULL
NULL
{exit(-1);}
exit(-1);
exit(-1)
exit
exit
-1
1
strcpy(myString, HELLO_STRING);
strcpy(myString, HELLO_STRING)
strcpy
strcpy
myString
myString
HELLO_STRING
HELLO_STRING
printLine(myString);
printLine(myString)
printLine
printLine
myString
myString
free(myString);
free(myString)
free
free
myString
myString
{                printLine("Input is less than the length of the source string");            }
printLine("Input is less than the length of the source string");
printLine("Input is less than the length of the source string")
printLine
printLine
"Input is less than the length of the source string"
-----joern-----
(16,61,0)
(20,6,0)
(4,20,0)
(89,40,0)
(45,76,0)
(16,58,0)
(79,77,0)
(49,64,0)
(39,55,0)
(29,71,0)
(43,67,0)
(57,12,0)
(53,6,0)
(70,0,0)
(84,4,0)
(20,4,0)
(71,12,0)
(26,6,0)
(56,63,0)
(85,77,0)
(21,0,0)
(1,82,0)
(5,16,0)
(24,65,0)
(86,40,0)
(50,81,0)
(44,52,0)
(86,70,0)
(68,82,0)
(75,26,0)
(80,61,0)
(15,20,0)
(26,61,0)
(69,86,0)
(66,26,0)
(21,16,0)
(31,79,0)
(16,21,0)
(72,28,0)
(32,58,0)
(26,72,0)
(0,54,0)
(41,73,0)
(67,27,0)
(47,6,0)
(9,13,0)
(63,38,0)
(9,6,0)
(26,75,0)
(6,2,0)
(73,39,0)
(64,40,0)
(76,48,0)
(74,52,0)
(46,9,0)
(61,19,0)
(9,61,0)
(36,75,0)
(11,77,0)
(78,22,0)
(10,50,0)
(89,70,0)
(28,57,0)
(59,13,0)
(65,57,0)
(0,21,0)
(14,64,0)
(42,77,0)
(28,18,0)
(52,70,0)
(27,67,0)
(27,62,0)
(3,12,0)
(25,57,0)
(8,70,0)
(20,61,0)
(87,12,0)
(70,40,0)
(0,70,0)
(58,16,0)
(82,57,0)
(30,63,0)
(3,57,0)
(71,57,0)
(28,72,0)
(64,70,0)
(16,6,0)
(34,61,0)
(57,28,0)
(88,76,0)
(13,9,0)
(35,40,0)
(51,71,0)
(17,3,0)
(60,89,0)
(72,26,0)
(54,0,0)
(22,33,0)
(65,12,0)
(18,28,0)
(37,79,0)
(39,73,0)
(43,52,1)
(28,18,1)
(3,17,1)
(68,1,1)
(26,6,1)
(8,20,1)
(17,71,1)
(5,8,1)
(69,89,1)
(82,68,1)
(86,70,1)
(60,64,1)
(66,25,1)
(1,57,1)
(26,75,1)
(21,16,1)
(70,0,1)
(20,6,1)
(0,21,1)
(49,27,1)
(89,60,1)
(73,41,1)
(64,14,1)
(46,23,1)
(9,61,1)
(13,59,1)
(36,66,1)
(24,3,1)
(23,61,1)
(89,70,1)
(51,29,1)
(57,28,1)
(4,84,1)
(83,79,1)
(22,78,1)
(16,58,1)
(31,37,1)
(49,52,1)
(26,61,1)
(15,23,1)
(28,72,1)
(79,31,1)
(29,82,1)
(23,6,1)
(16,6,1)
(50,10,1)
(34,80,1)
(84,15,1)
(6,53,1)
(16,61,1)
(75,36,1)
(39,73,1)
(61,34,1)
(7,50,1)
(78,9,1)
(47,83,1)
(3,57,1)
(59,46,1)
(71,51,1)
(7,65,1)
(74,44,1)
(41,82,1)
(10,20,1)
(72,26,1)
(86,69,1)
(44,70,1)
(7,86,1)
(27,67,1)
(7,22,1)
(9,6,1)
(64,70,1)
(80,83,1)
(65,57,1)
(52,74,1)
(58,32,1)
(25,9,1)
(67,43,1)
(20,4,1)
(9,13,1)
(65,24,1)
(29,39,1)
(53,47,1)
(0,54,1)
(82,57,1)
(32,5,1)
(71,57,1)
(20,61,1)
(52,70,1)
(14,49,1)
(41,82,2)
(78,9,2)
(29,9,2)
(80,83,2)
(75,9,2)
(71,9,2)
(82,57,2)
(50,20,2)
(4,23,2)
(16,58,2)
(17,9,2)
(52,20,2)
(8,20,2)
(26,61,2)
(9,23,2)
(28,72,2)
(20,23,2)
(73,82,2)
(1,9,2)
(6,83,2)
(26,75,2)
(27,67,2)
(3,9,2)
(70,20,2)
(51,9,2)
(0,20,2)
(89,20,2)
(21,20,2)
(86,20,2)
(43,52,2)
(47,83,2)
(66,9,2)
(20,6,2)
(57,9,2)
(34,83,2)
(44,20,2)
(61,83,2)
(52,70,2)
(84,23,2)
(64,70,2)
(49,20,2)
(27,52,2)
(9,6,2)
(9,13,2)
(24,9,2)
(60,20,2)
(25,9,2)
(68,9,2)
(16,61,2)
(82,9,2)
(39,73,2)
(10,20,2)
(70,0,2)
(9,61,2)
(64,20,2)
(72,9,2)
(89,70,2)
(26,9,2)
(22,9,2)
(14,20,2)
(20,61,2)
(21,16,2)
(65,57,2)
(86,70,2)
(71,57,2)
(28,9,2)
(16,6,2)
(39,82,2)
(46,23,2)
(72,26,2)
(16,20,2)
(0,21,2)
(65,9,2)
(3,57,2)
(20,4,2)
(67,52,2)
(69,20,2)
(15,23,2)
(59,23,2)
(28,18,2)
(26,6,2)
(74,20,2)
(13,23,2)
(36,9,2)
(58,20,2)
(57,28,2)
(53,83,2)
(32,20,2)
(0,54,2)
(5,20,2)
-----------------------------------
(0,(char *)
(1,myString)
(2,)
(3,printLine(myString)
(4,strlen(HELLO_STRING)
(5,data)
(6,data = 20)
(7,RET)
(8,myString)
(9,data > strlen(HELLO_STRING)
(10,"Input is less than the length of the source string")
(11,data)
(12,)
(13,strlen(HELLO_STRING)
(14,HELLO_STRING)
(15,data)
(16,data*sizeof(char)
(17,myString)
(18,char *)
(19,)
(20,data > strlen(HELLO_STRING)
(21,malloc(data*sizeof(char)
(22,printLine("Input is less than the length of the source string")
(23,globalReturnsTrueOrFalse()
(24,myString)
(25,myString)
(26,data*sizeof(char)
(27,exit(-1)
(28,(char *)
(29,myString)
(30,if (data > strlen(HELLO_STRING)
(31,0)
(32,char)
(33,)
(34,20)
(35,if (myString == NULL)
(36,char)
(37,data)
(38,)
(39,exit(-1)
(40,)
(41,1)
(42,if(globalReturnsTrueOrFalse()
(43,1)
(44,myString)
(45,myString)
(46,data)
(47,data)
(48,)
(49,myString)
(50,printLine("Input is less than the length of the source string")
(51,HELLO_STRING)
(52,myString == NULL)
(53,20)
(54,char *)
(55,)
(56,myString)
(57,myString = (char *)
(58,sizeof(char)
(59,HELLO_STRING)
(60,myString)
(61,data = 20)
(62,)
(63,)
(64,strcpy(myString, HELLO_STRING)
(65,free(myString)
(66,data)
(67,-1)
(68,NULL)
(69,myString)
(70,myString = (char *)
(71,strcpy(myString, HELLO_STRING)
(72,malloc(data*sizeof(char)
(73,-1)
(74,NULL)
(75,sizeof(char)
(76,)
(77,)
(78,"Input is less than the length of the source string")
(79,data = 0)
(80,data)
(81,)
(82,myString == NULL)
(83,globalReturnsTrueOrFalse()
(84,HELLO_STRING)
(85,if(globalReturnsTrueOrFalse()
(86,free(myString)
(87,if (myString == NULL)
(88,if (data > strlen(HELLO_STRING)
(89,printLine(myString)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^