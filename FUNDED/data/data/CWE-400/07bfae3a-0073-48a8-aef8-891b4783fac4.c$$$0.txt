-----label-----
0
-----code-----
static struct ast_frame *agent_read(struct ast_channel *ast)
{
	struct agent_pvt *p = ast_channel_tech_pvt(ast);
	struct ast_frame *f = NULL;
	static struct ast_frame answer_frame = { AST_FRAME_CONTROL, { AST_CONTROL_ANSWER } };
	int cur_time = time(NULL);
	struct ast_channel *owner;

	ast_mutex_lock(&p->lock);
	owner = agent_lock_owner(p);

	CHECK_FORMATS(ast, p);
	if (!p->start) {
		p->start = cur_time;
	}
	if (p->chan) {
		ast_copy_flags(ast_channel_flags(p->chan), ast_channel_flags(ast), AST_FLAG_EXCEPTION);
		ast_channel_fdno_set(p->chan, (ast_channel_fdno(ast) == AST_AGENT_FD) ? AST_TIMING_FD : ast_channel_fdno(ast));
		f = ast_read(p->chan);
	} else
		f = &ast_null_frame;
	if (!f) {
		/* If there's a channel, make it NULL */
		if (p->chan) {
			ast_channel_internal_bridged_channel_set(p->chan, NULL);
			p->chan = NULL;
			ast_devstate_changed(AST_DEVICE_UNAVAILABLE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);
			p->acknowledged = 0;
		}
	} else {
		/* if acknowledgement is not required, and the channel is up, we may have missed
			an AST_CONTROL_ANSWER (if there was one), so mark the call acknowledged anyway */
		if (!p->ackcall && !p->acknowledged && p->chan && (ast_channel_state(p->chan) == AST_STATE_UP)) {
			p->acknowledged = 1;
		}

		if (!p->acknowledged) {
			int howlong = cur_time - p->start;
			if (p->autologoff && (howlong >= p->autologoff)) {
				ast_log(LOG_NOTICE, "Agent '%s' didn't answer/confirm within %d seconds (waited %d)\n", p->name, p->autologoff, howlong);
				if (owner || p->chan) {
					if (owner) {
						ast_softhangup(owner, AST_SOFTHANGUP_EXPLICIT);
						ast_channel_unlock(owner);
						owner = ast_channel_unref(owner);
					}

					while (p->chan && ast_channel_trylock(p->chan)) {
						DEADLOCK_AVOIDANCE(&p->lock);
					}
					if (p->chan) {
						ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);
						ast_channel_unlock(p->chan);
					}
				}
			}
		}
		switch (f->frametype) {
		case AST_FRAME_CONTROL:
			if (f->subclass.integer == AST_CONTROL_ANSWER) {
				if (p->ackcall) {
					ast_verb(3, "%s answered, waiting for '%c' to acknowledge\n", ast_channel_name(p->chan), p->acceptdtmf);
					/* Don't pass answer along */
					ast_frfree(f);
					f = &ast_null_frame;
				} else {
					p->acknowledged = 1;
					/* Use the builtin answer frame for the 
					   recording start check below. */
					ast_frfree(f);
					f = &answer_frame;
				}
			}
			break;
		case AST_FRAME_DTMF_BEGIN:
			/*ignore DTMF begin's as it can cause issues with queue announce files*/
			if((!p->acknowledged && f->subclass.integer == p->acceptdtmf) || (f->subclass.integer == p->enddtmf && endcall)){
				ast_frfree(f);
				f = &ast_null_frame;
			}
			break;
		case AST_FRAME_DTMF_END:
			if (!p->acknowledged && (f->subclass.integer == p->acceptdtmf)) {
				if (p->chan) {
					ast_verb(3, "%s acknowledged\n", ast_channel_name(p->chan));
				}
				p->acknowledged = 1;
				ast_frfree(f);
				f = &answer_frame;
			} else if (f->subclass.integer == p->enddtmf && endcall) {
				/* terminates call */
				ast_frfree(f);
				f = NULL;
			}
			break;
		case AST_FRAME_VOICE:
		case AST_FRAME_VIDEO:
			/* don't pass voice or video until the call is acknowledged */
			if (!p->acknowledged) {
				ast_frfree(f);
				f = &ast_null_frame;
			}
		default:
			/* pass everything else on through */
			break;
		}
	}

	if (owner) {
		ast_channel_unlock(owner);
		owner = ast_channel_unref(owner);
	}

	CLEANUP(ast,p);
	if (p->chan && !ast_channel_internal_bridged_channel(p->chan)) {
		if (strcasecmp(ast_channel_tech(p->chan)->type, "Local")) {
			ast_channel_internal_bridged_channel_set(p->chan, ast);
			if (p->chan)
				ast_debug(1, "Bridge on '%s' being set to '%s' (3)\n", ast_channel_name(p->chan), ast_channel_name(ast_channel_internal_bridged_channel(p->chan)));
		}
	}
	ast_mutex_unlock(&p->lock);
	if (recordagentcalls && f == &answer_frame)
		agent_start_monitoring(ast,0);
	return f;
}
-----children-----
1,2
1,3
1,4
2,3
4,5
4,6
4,7
7,8
7,9
8,9
10,11
10,12
13,14
13,15
13,16
13,17
13,18
13,19
13,20
13,21
13,22
13,23
13,24
13,25
13,26
13,27
13,28
13,29
13,30
14,15
15,16
15,17
16,17
18,19
18,20
18,21
21,22
22,23
22,24
23,24
25,26
27,28
28,29
28,30
29,30
31,32
31,33
31,34
34,35
35,36
37,38
38,39
38,40
39,40
41,42
41,43
43,44
44,45
44,46
45,46
47,48
48,49
50,51
51,52
51,53
53,54
53,55
55,56
56,57
56,58
57,58
59,60
61,62
62,63
62,64
63,64
65,66
65,67
68,69
69,70
69,71
70,71
72,73
73,74
73,75
74,75
77,78
78,79
78,80
79,80
81,82
81,83
82,83
84,85
86,87
87,88
87,89
87,90
88,89
90,91
92,93
94,95
94,96
95,96
96,97
96,98
97,98
100,101
101,102
102,103
102,104
103,104
103,105
104,105
107,108
109,110
109,111
109,112
110,111
110,112
111,112
114,115
114,116
114,117
115,116
116,117
116,118
116,119
116,120
117,118
119,120
119,121
120,121
122,123
122,124
123,124
126,127
126,128
127,128
129,130
131,132
133,134
134,135
134,136
134,137
135,136
137,138
137,139
138,139
141,142
141,143
141,144
142,143
143,144
143,145
144,145
144,146
145,146
147,148
149,150
151,152
153,154
153,155
154,155
156,157
158,159
159,160
159,161
160,161
162,163
162,164
163,164
165,166
165,167
166,167
169,170
170,171
170,172
171,172
173,174
174,175
176,177
176,178
176,179
177,178
178,179
180,181
181,182
181,183
182,183
182,184
183,184
186,187
186,188
186,189
186,190
187,188
188,189
188,190
188,191
189,190
191,192
191,193
192,193
195,196
197,198
198,199
198,200
199,200
199,201
200,201
203,204
205,206
206,207
206,208
206,209
206,210
206,211
207,208
209,210
211,212
214,215
214,216
215,216
218,219
219,220
219,221
220,221
220,222
221,222
225,226
225,227
225,228
226,227
226,228
227,228
227,229
228,229
228,230
229,230
229,231
230,231
231,232
231,233
232,233
235,236
236,237
236,238
237,238
240,241
240,242
241,242
244,245
245,246
245,247
246,247
246,248
247,248
249,250
249,251
250,251
253,254
255,256
256,257
257,258
257,259
258,259
258,260
259,260
263,264
263,265
264,265
265,266
265,267
266,267
269,270
269,271
270,271
271,272
271,273
273,274
273,275
275,276
276,277
276,278
277,278
279,280
279,281
280,281
283,284
283,285
284,285
284,286
285,286
285,287
286,287
289,290
290,291
290,292
291,292
293,294
293,295
294,295
297,298
297,299
298,299
299,300
299,301
299,302
299,303
299,304
299,305
300,301
302,303
305,306
305,307
306,307
309,310
309,311
310,311
313,314
315,316
315,317
316,317
316,318
317,318
319,320
319,321
320,321
323,324
323,325
323,326
324,325
324,326
325,326
327,328
327,329
327,330
328,329
329,330
329,331
329,332
330,331
332,333
334,335
336,337
337,338
337,339
338,339
340,341
342,343
343,344
343,345
344,345
346,347
346,348
347,348
349,350
351,352
351,353
352,353
352,354
353,354
353,355
354,355
357,358
357,359
358,359
360,361
360,362
361,362
364,365
365,366
366,367
366,368
367,368
369,370
370,371
370,372
371,372
374,375
374,376
375,376
375,377
376,377
379,380
379,381
380,381
381,382
381,383
381,384
382,383
384,385
384,386
385,386
388,389
390,391
391,392
391,393
392,393
394,395
394,396
395,396
398,399
398,400
399,400
399,401
400,401
403,404
403,405
403,406
403,407
403,408
403,409
403,410
403,411
403,412
403,413
403,414
403,415
403,416
403,417
404,405
405,406
407,408
407,409
408,409
408,410
409,410
409,411
410,411
410,412
411,412
415,416
417,418
418,419
418,420
418,421
419,420
419,421
420,421
423,424
423,425
423,426
424,425
425,426
425,427
425,428
425,429
425,430
426,427
430,431
430,432
431,432
433,434
433,435
434,435
437,438
437,439
438,439
441,442
442,443
442,444
443,444
445,446
447,448
448,449
448,450
449,450
451,452
452,453
454,455
454,456
454,457
455,456
456,457
456,458
457,458
457,459
458,459
462,463
463,464
463,465
464,465
466,467
468,469
469,470
469,471
470,471
472,473
473,474
476,477
477,478
479,480
479,481
480,481
480,482
481,482
482,483
482,484
483,484
484,485
484,486
485,486
488,489
488,490
489,490
489,491
490,491
490,492
491,492
495,496
495,497
496,497
499,500
500,501
500,502
501,502
501,503
502,503
502,504
503,504
503,505
504,505
508,509
508,510
509,510
512,513
514,515
514,516
515,516
516,517
516,518
517,518
519,520
521,522
522,523
522,524
523,524
525,526
526,527
529,530
530,531
532,533
532,534
532,535
533,534
533,535
534,535
535,536
535,537
536,537
539,540
540,541
540,542
541,542
541,543
542,543
542,544
543,544
547,548
547,549
548,549
551,552
551,553
551,554
551,555
552,553
552,554
553,554
553,555
554,555
557,558
558,559
559,560
559,561
559,562
559,563
560,561
564,565
564,566
565,566
567,568
567,569
568,569
571,572
572,573
572,574
573,574
573,575
574,575
578,579
579,580
579,581
580,581
582,583
584,585
585,586
585,587
586,587
588,589
589,590
591,592
591,593
592,593
592,594
593,594
593,595
594,595
594,596
595,596
595,597
596,597
600,601
600,602
601,602
604,605
606,607
606,608
607,608
608,609
608,610
609,610
611,612
613,614
614,615
614,616
615,616
617,618
620,621
621,622
623,624
624,625
626,627
626,628
627,628
628,629
628,630
629,630
632,633
632,634
633,634
634,635
634,636
635,636
637,638
639,640
640,641
640,642
641,642
643,644
644,645
648,649
648,650
649,650
651,652
651,653
652,653
653,654
653,655
654,655
656,657
658,659
659,660
659,661
660,661
662,663
662,664
663,664
665,666
667,668
668,669
668,670
668,671
669,670
671,672
673,674
675,676
675,677
676,677
676,678
677,678
677,679
678,679
681,682
682,683
682,684
683,684
685,686
685,687
686,687
689,690
690,691
690,692
691,692
691,693
691,694
692,693
694,695
694,696
695,696
695,697
696,697
698,699
698,700
699,700
704,705
704,706
705,706
706,707
706,708
706,709
707,708
709,710
709,711
710,711
713,714
715,716
715,717
716,717
716,718
717,718
720,721
721,722
721,723
721,724
721,725
721,726
722,723
726,727
726,728
727,728
729,730
729,731
730,731
733,734
733,735
734,735
736,737
736,738
737,738
739,740
739,741
740,741
743,744
744,745
744,746
745,746
747,748
748,749
748,750
749,750
752,753
752,754
753,754
753,755
754,755
756,757
756,758
757,758
759,760
760,761
762,763
763,764
763,765
763,766
764,765
766,767
769,770
770,771
-----nextToken-----
3,5,6,9,11,12,17,19,20,24,26,30,32,33,36,40,42,46,49,52,54,58,60,64,66,67,71,75,76,80,83,85,89,91,93,98,99,105,106,108,112,113,118,121,124,125,128,130,132,136,139,140,146,148,150,152,155,157,161,164,167,168,172,175,179,184,185,190,193,194,196,201,202,204,208,210,212,213,216,217,222,223,224,233,234,238,239,242,243,248,251,252,254,260,261,262,267,268,272,274,278,281,282,287,288,292,295,296,301,303,304,307,308,311,312,314,318,321,322,326,331,333,335,339,341,345,348,350,355,356,359,362,363,368,372,373,377,378,383,386,387,389,393,396,397,401,402,406,412,413,414,416,421,422,427,428,429,432,435,436,439,440,444,446,450,453,459,460,461,465,467,471,474,475,478,486,487,492,493,494,497,498,505,506,507,510,511,513,518,520,524,527,528,531,537,538,544,545,546,549,550,555,556,561,562,563,566,569,570,575,576,577,581,583,587,590,597,598,599,602,603,605,610,612,616,618,619,622,625,630,631,636,638,642,645,646,647,650,655,657,661,664,666,670,672,674,679,680,684,687,688,693,697,700,701,702,703,708,711,712,714,718,719,723,724,725,728,731,732,735,738,741,742,746,750,751,755,758,761,765,767,768,771
-----computeFrom-----
78,79
78,80
102,103
102,104
143,144
143,145
159,160
159,161
170,171
170,172
198,199
198,200
219,220
219,221
227,228
227,229
228,229
228,230
229,230
229,231
245,246
245,247
257,258
257,259
276,277
276,278
284,285
284,286
290,291
290,292
316,317
316,318
343,344
343,345
352,353
352,354
408,409
408,410
448,449
448,450
456,457
456,458
469,470
469,471
480,481
480,482
482,483
482,484
488,489
488,490
500,501
500,502
501,502
501,503
522,523
522,524
533,534
533,535
540,541
540,542
572,573
572,574
585,586
585,587
592,593
592,594
593,594
593,595
614,615
614,616
640,641
640,642
659,660
659,661
676,677
676,678
753,754
753,755
756,757
756,758
-----guardedBy-----
251,260
239,261
295,396
296,312
292,314
318,350
321,396
322,397
412,471
505,524
549,575
538,576
544,587
597,616
687,741
684,738
688,742
-----guardedByNegation-----
549,602
544,616
545,598
546,599
-----lastLexicalUse-----
549,602
544,616
-----jump-----
549,602
544,616
-----attribute-----
FunctionDefinition;ElaboratedTypeSpecifier;Name;FunctionDeclarator;Pointer;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;InitializerList;IdExpression;Name;InitializerList;IdExpression;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ConditionalExpression;UnaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IfStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;WhileStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;SwitchStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;CaseStatement;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;IfStatement;BinaryExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;IfStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;DefaultStatement;BreakStatement;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;FieldReference;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ReturnStatement;IdExpression;Name;
-----ast_node-----
static struct ast_frame *agent_read(struct ast_channel *ast){	struct agent_pvt *p = ast_channel_tech_pvt(ast);	struct ast_frame *f = NULL;	static struct ast_frame answer_frame = { AST_FRAME_CONTROL, { AST_CONTROL_ANSWER } };	int cur_time = time(NULL);	struct ast_channel *owner;	ast_mutex_lock(&p->lock);	owner = agent_lock_owner(p);	CHECK_FORMATS(ast, p);	if (!p->start) {		p->start = cur_time;	}	if (p->chan) {		ast_copy_flags(ast_channel_flags(p->chan), ast_channel_flags(ast), AST_FLAG_EXCEPTION);		ast_channel_fdno_set(p->chan, (ast_channel_fdno(ast) == AST_AGENT_FD) ? AST_TIMING_FD : ast_channel_fdno(ast));		f = ast_read(p->chan);	} else		f = &ast_null_frame;	if (!f) {		/* If there's a channel, make it NULL */		if (p->chan) {			ast_channel_internal_bridged_channel_set(p->chan, NULL);			p->chan = NULL;			ast_devstate_changed(AST_DEVICE_UNAVAILABLE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);			p->acknowledged = 0;		}	} else {		/* if acknowledgement is not required, and the channel is up, we may have missed			an AST_CONTROL_ANSWER (if there was one), so mark the call acknowledged anyway */		if (!p->ackcall && !p->acknowledged && p->chan && (ast_channel_state(p->chan) == AST_STATE_UP)) {			p->acknowledged = 1;		}		if (!p->acknowledged) {			int howlong = cur_time - p->start;			if (p->autologoff && (howlong >= p->autologoff)) {				ast_log(LOG_NOTICE, "Agent '%s' didn't answer/confirm within %d seconds (waited %d)\n", p->name, p->autologoff, howlong);				if (owner || p->chan) {					if (owner) {						ast_softhangup(owner, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(owner);						owner = ast_channel_unref(owner);					}					while (p->chan && ast_channel_trylock(p->chan)) {						DEADLOCK_AVOIDANCE(&p->lock);					}					if (p->chan) {						ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(p->chan);					}				}			}		}		switch (f->frametype) {		case AST_FRAME_CONTROL:			if (f->subclass.integer == AST_CONTROL_ANSWER) {				if (p->ackcall) {					ast_verb(3, "%s answered, waiting for '%c' to acknowledge\n", ast_channel_name(p->chan), p->acceptdtmf);					/* Don't pass answer along */					ast_frfree(f);					f = &ast_null_frame;				} else {					p->acknowledged = 1;					/* Use the builtin answer frame for the 					   recording start check below. */					ast_frfree(f);					f = &answer_frame;				}			}			break;		case AST_FRAME_DTMF_BEGIN:			/*ignore DTMF begin's as it can cause issues with queue announce files*/			if((!p->acknowledged && f->subclass.integer == p->acceptdtmf) || (f->subclass.integer == p->enddtmf && endcall)){				ast_frfree(f);				f = &ast_null_frame;			}			break;		case AST_FRAME_DTMF_END:			if (!p->acknowledged && (f->subclass.integer == p->acceptdtmf)) {				if (p->chan) {					ast_verb(3, "%s acknowledged\n", ast_channel_name(p->chan));				}				p->acknowledged = 1;				ast_frfree(f);				f = &answer_frame;			} else if (f->subclass.integer == p->enddtmf && endcall) {				/* terminates call */				ast_frfree(f);				f = NULL;			}			break;		case AST_FRAME_VOICE:		case AST_FRAME_VIDEO:			/* don't pass voice or video until the call is acknowledged */			if (!p->acknowledged) {				ast_frfree(f);				f = &ast_null_frame;			}		default:			/* pass everything else on through */			break;		}	}	if (owner) {		ast_channel_unlock(owner);		owner = ast_channel_unref(owner);	}	CLEANUP(ast,p);	if (p->chan && !ast_channel_internal_bridged_channel(p->chan)) {		if (strcasecmp(ast_channel_tech(p->chan)->type, "Local")) {			ast_channel_internal_bridged_channel_set(p->chan, ast);			if (p->chan)				ast_debug(1, "Bridge on '%s' being set to '%s' (3)\n", ast_channel_name(p->chan), ast_channel_name(ast_channel_internal_bridged_channel(p->chan)));		}	}	ast_mutex_unlock(&p->lock);	if (recordagentcalls && f == &answer_frame)		agent_start_monitoring(ast,0);	return f;}
static struct ast_frame
ast_frame
*agent_read(struct ast_channel *ast)
*
agent_read
struct ast_channel *ast
struct ast_channel
ast_channel
*ast
*
ast
{	struct agent_pvt *p = ast_channel_tech_pvt(ast);	struct ast_frame *f = NULL;	static struct ast_frame answer_frame = { AST_FRAME_CONTROL, { AST_CONTROL_ANSWER } };	int cur_time = time(NULL);	struct ast_channel *owner;	ast_mutex_lock(&p->lock);	owner = agent_lock_owner(p);	CHECK_FORMATS(ast, p);	if (!p->start) {		p->start = cur_time;	}	if (p->chan) {		ast_copy_flags(ast_channel_flags(p->chan), ast_channel_flags(ast), AST_FLAG_EXCEPTION);		ast_channel_fdno_set(p->chan, (ast_channel_fdno(ast) == AST_AGENT_FD) ? AST_TIMING_FD : ast_channel_fdno(ast));		f = ast_read(p->chan);	} else		f = &ast_null_frame;	if (!f) {		/* If there's a channel, make it NULL */		if (p->chan) {			ast_channel_internal_bridged_channel_set(p->chan, NULL);			p->chan = NULL;			ast_devstate_changed(AST_DEVICE_UNAVAILABLE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);			p->acknowledged = 0;		}	} else {		/* if acknowledgement is not required, and the channel is up, we may have missed			an AST_CONTROL_ANSWER (if there was one), so mark the call acknowledged anyway */		if (!p->ackcall && !p->acknowledged && p->chan && (ast_channel_state(p->chan) == AST_STATE_UP)) {			p->acknowledged = 1;		}		if (!p->acknowledged) {			int howlong = cur_time - p->start;			if (p->autologoff && (howlong >= p->autologoff)) {				ast_log(LOG_NOTICE, "Agent '%s' didn't answer/confirm within %d seconds (waited %d)\n", p->name, p->autologoff, howlong);				if (owner || p->chan) {					if (owner) {						ast_softhangup(owner, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(owner);						owner = ast_channel_unref(owner);					}					while (p->chan && ast_channel_trylock(p->chan)) {						DEADLOCK_AVOIDANCE(&p->lock);					}					if (p->chan) {						ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(p->chan);					}				}			}		}		switch (f->frametype) {		case AST_FRAME_CONTROL:			if (f->subclass.integer == AST_CONTROL_ANSWER) {				if (p->ackcall) {					ast_verb(3, "%s answered, waiting for '%c' to acknowledge\n", ast_channel_name(p->chan), p->acceptdtmf);					/* Don't pass answer along */					ast_frfree(f);					f = &ast_null_frame;				} else {					p->acknowledged = 1;					/* Use the builtin answer frame for the 					   recording start check below. */					ast_frfree(f);					f = &answer_frame;				}			}			break;		case AST_FRAME_DTMF_BEGIN:			/*ignore DTMF begin's as it can cause issues with queue announce files*/			if((!p->acknowledged && f->subclass.integer == p->acceptdtmf) || (f->subclass.integer == p->enddtmf && endcall)){				ast_frfree(f);				f = &ast_null_frame;			}			break;		case AST_FRAME_DTMF_END:			if (!p->acknowledged && (f->subclass.integer == p->acceptdtmf)) {				if (p->chan) {					ast_verb(3, "%s acknowledged\n", ast_channel_name(p->chan));				}				p->acknowledged = 1;				ast_frfree(f);				f = &answer_frame;			} else if (f->subclass.integer == p->enddtmf && endcall) {				/* terminates call */				ast_frfree(f);				f = NULL;			}			break;		case AST_FRAME_VOICE:		case AST_FRAME_VIDEO:			/* don't pass voice or video until the call is acknowledged */			if (!p->acknowledged) {				ast_frfree(f);				f = &ast_null_frame;			}		default:			/* pass everything else on through */			break;		}	}	if (owner) {		ast_channel_unlock(owner);		owner = ast_channel_unref(owner);	}	CLEANUP(ast,p);	if (p->chan && !ast_channel_internal_bridged_channel(p->chan)) {		if (strcasecmp(ast_channel_tech(p->chan)->type, "Local")) {			ast_channel_internal_bridged_channel_set(p->chan, ast);			if (p->chan)				ast_debug(1, "Bridge on '%s' being set to '%s' (3)\n", ast_channel_name(p->chan), ast_channel_name(ast_channel_internal_bridged_channel(p->chan)));		}	}	ast_mutex_unlock(&p->lock);	if (recordagentcalls && f == &answer_frame)		agent_start_monitoring(ast,0);	return f;}
struct agent_pvt *p = ast_channel_tech_pvt(ast);
struct agent_pvt *p = ast_channel_tech_pvt(ast);
struct agent_pvt
agent_pvt
*p = ast_channel_tech_pvt(ast)
*
p
= ast_channel_tech_pvt(ast)
ast_channel_tech_pvt(ast)
ast_channel_tech_pvt
ast_channel_tech_pvt
ast
ast
struct ast_frame *f = NULL;
struct ast_frame *f = NULL;
struct ast_frame
ast_frame
*f = NULL
*
f
= NULL
NULL
NULL
static struct ast_frame answer_frame = { AST_FRAME_CONTROL, { AST_CONTROL_ANSWER } };
static struct ast_frame answer_frame = { AST_FRAME_CONTROL, { AST_CONTROL_ANSWER } };
static struct ast_frame
ast_frame
answer_frame = { AST_FRAME_CONTROL, { AST_CONTROL_ANSWER } }
answer_frame
= { AST_FRAME_CONTROL, { AST_CONTROL_ANSWER } }
{ AST_FRAME_CONTROL, { AST_CONTROL_ANSWER } }
AST_FRAME_CONTROL
AST_FRAME_CONTROL
{ AST_CONTROL_ANSWER }
AST_CONTROL_ANSWER
AST_CONTROL_ANSWER
int cur_time = time(NULL);
int cur_time = time(NULL);
int
cur_time = time(NULL)
cur_time
= time(NULL)
time(NULL)
time
time
NULL
NULL
struct ast_channel *owner;
struct ast_channel *owner;
struct ast_channel
ast_channel
*owner
*
owner
ast_mutex_lock(&p->lock);
ast_mutex_lock(&p->lock)
ast_mutex_lock
ast_mutex_lock
&p->lock
p->lock
p
p
lock
owner = agent_lock_owner(p);
owner = agent_lock_owner(p)
owner
owner
agent_lock_owner(p)
agent_lock_owner
agent_lock_owner
p
p
CHECK_FORMATS(ast, p);
CHECK_FORMATS(ast, p)
CHECK_FORMATS
CHECK_FORMATS
ast
ast
p
p
if (!p->start) {		p->start = cur_time;	}
!p->start
p->start
p
p
start
{		p->start = cur_time;	}
p->start = cur_time;
p->start = cur_time
p->start
p
p
start
cur_time
cur_time
if (p->chan) {		ast_copy_flags(ast_channel_flags(p->chan), ast_channel_flags(ast), AST_FLAG_EXCEPTION);		ast_channel_fdno_set(p->chan, (ast_channel_fdno(ast) == AST_AGENT_FD) ? AST_TIMING_FD : ast_channel_fdno(ast));		f = ast_read(p->chan);	} else		f = &ast_null_frame;
p->chan
p
p
chan
{		ast_copy_flags(ast_channel_flags(p->chan), ast_channel_flags(ast), AST_FLAG_EXCEPTION);		ast_channel_fdno_set(p->chan, (ast_channel_fdno(ast) == AST_AGENT_FD) ? AST_TIMING_FD : ast_channel_fdno(ast));		f = ast_read(p->chan);	}
ast_copy_flags(ast_channel_flags(p->chan), ast_channel_flags(ast), AST_FLAG_EXCEPTION);
ast_copy_flags(ast_channel_flags(p->chan), ast_channel_flags(ast), AST_FLAG_EXCEPTION)
ast_copy_flags
ast_copy_flags
ast_channel_flags(p->chan)
ast_channel_flags
ast_channel_flags
p->chan
p
p
chan
ast_channel_flags(ast)
ast_channel_flags
ast_channel_flags
ast
ast
AST_FLAG_EXCEPTION
AST_FLAG_EXCEPTION
ast_channel_fdno_set(p->chan, (ast_channel_fdno(ast) == AST_AGENT_FD) ? AST_TIMING_FD : ast_channel_fdno(ast));
ast_channel_fdno_set(p->chan, (ast_channel_fdno(ast) == AST_AGENT_FD) ? AST_TIMING_FD : ast_channel_fdno(ast))
ast_channel_fdno_set
ast_channel_fdno_set
p->chan
p
p
chan
(ast_channel_fdno(ast) == AST_AGENT_FD) ? AST_TIMING_FD : ast_channel_fdno(ast)
(ast_channel_fdno(ast) == AST_AGENT_FD)
ast_channel_fdno(ast) == AST_AGENT_FD
ast_channel_fdno(ast)
ast_channel_fdno
ast_channel_fdno
ast
ast
AST_AGENT_FD
AST_AGENT_FD
AST_TIMING_FD
AST_TIMING_FD
ast_channel_fdno(ast)
ast_channel_fdno
ast_channel_fdno
ast
ast
f = ast_read(p->chan);
f = ast_read(p->chan)
f
f
ast_read(p->chan)
ast_read
ast_read
p->chan
p
p
chan
f = &ast_null_frame;
f = &ast_null_frame
f
f
&ast_null_frame
ast_null_frame
ast_null_frame
if (!f) {		/* If there's a channel, make it NULL */		if (p->chan) {			ast_channel_internal_bridged_channel_set(p->chan, NULL);			p->chan = NULL;			ast_devstate_changed(AST_DEVICE_UNAVAILABLE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);			p->acknowledged = 0;		}	} else {		/* if acknowledgement is not required, and the channel is up, we may have missed			an AST_CONTROL_ANSWER (if there was one), so mark the call acknowledged anyway */		if (!p->ackcall && !p->acknowledged && p->chan && (ast_channel_state(p->chan) == AST_STATE_UP)) {			p->acknowledged = 1;		}		if (!p->acknowledged) {			int howlong = cur_time - p->start;			if (p->autologoff && (howlong >= p->autologoff)) {				ast_log(LOG_NOTICE, "Agent '%s' didn't answer/confirm within %d seconds (waited %d)\n", p->name, p->autologoff, howlong);				if (owner || p->chan) {					if (owner) {						ast_softhangup(owner, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(owner);						owner = ast_channel_unref(owner);					}					while (p->chan && ast_channel_trylock(p->chan)) {						DEADLOCK_AVOIDANCE(&p->lock);					}					if (p->chan) {						ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(p->chan);					}				}			}		}		switch (f->frametype) {		case AST_FRAME_CONTROL:			if (f->subclass.integer == AST_CONTROL_ANSWER) {				if (p->ackcall) {					ast_verb(3, "%s answered, waiting for '%c' to acknowledge\n", ast_channel_name(p->chan), p->acceptdtmf);					/* Don't pass answer along */					ast_frfree(f);					f = &ast_null_frame;				} else {					p->acknowledged = 1;					/* Use the builtin answer frame for the 					   recording start check below. */					ast_frfree(f);					f = &answer_frame;				}			}			break;		case AST_FRAME_DTMF_BEGIN:			/*ignore DTMF begin's as it can cause issues with queue announce files*/			if((!p->acknowledged && f->subclass.integer == p->acceptdtmf) || (f->subclass.integer == p->enddtmf && endcall)){				ast_frfree(f);				f = &ast_null_frame;			}			break;		case AST_FRAME_DTMF_END:			if (!p->acknowledged && (f->subclass.integer == p->acceptdtmf)) {				if (p->chan) {					ast_verb(3, "%s acknowledged\n", ast_channel_name(p->chan));				}				p->acknowledged = 1;				ast_frfree(f);				f = &answer_frame;			} else if (f->subclass.integer == p->enddtmf && endcall) {				/* terminates call */				ast_frfree(f);				f = NULL;			}			break;		case AST_FRAME_VOICE:		case AST_FRAME_VIDEO:			/* don't pass voice or video until the call is acknowledged */			if (!p->acknowledged) {				ast_frfree(f);				f = &ast_null_frame;			}		default:			/* pass everything else on through */			break;		}	}
!f
f
f
{		/* If there's a channel, make it NULL */		if (p->chan) {			ast_channel_internal_bridged_channel_set(p->chan, NULL);			p->chan = NULL;			ast_devstate_changed(AST_DEVICE_UNAVAILABLE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);			p->acknowledged = 0;		}	}
if (p->chan) {			ast_channel_internal_bridged_channel_set(p->chan, NULL);			p->chan = NULL;			ast_devstate_changed(AST_DEVICE_UNAVAILABLE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);			p->acknowledged = 0;		}
p->chan
p
p
chan
{			ast_channel_internal_bridged_channel_set(p->chan, NULL);			p->chan = NULL;			ast_devstate_changed(AST_DEVICE_UNAVAILABLE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);			p->acknowledged = 0;		}
ast_channel_internal_bridged_channel_set(p->chan, NULL);
ast_channel_internal_bridged_channel_set(p->chan, NULL)
ast_channel_internal_bridged_channel_set
ast_channel_internal_bridged_channel_set
p->chan
p
p
chan
NULL
NULL
p->chan = NULL;
p->chan = NULL
p->chan
p
p
chan
NULL
NULL
ast_devstate_changed(AST_DEVICE_UNAVAILABLE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent);
ast_devstate_changed(AST_DEVICE_UNAVAILABLE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent)
ast_devstate_changed
ast_devstate_changed
AST_DEVICE_UNAVAILABLE
AST_DEVICE_UNAVAILABLE
AST_DEVSTATE_CACHABLE
AST_DEVSTATE_CACHABLE
"Agent/%s"
p->agent
p
p
agent
p->acknowledged = 0;
p->acknowledged = 0
p->acknowledged
p
p
acknowledged
0
{		/* if acknowledgement is not required, and the channel is up, we may have missed			an AST_CONTROL_ANSWER (if there was one), so mark the call acknowledged anyway */		if (!p->ackcall && !p->acknowledged && p->chan && (ast_channel_state(p->chan) == AST_STATE_UP)) {			p->acknowledged = 1;		}		if (!p->acknowledged) {			int howlong = cur_time - p->start;			if (p->autologoff && (howlong >= p->autologoff)) {				ast_log(LOG_NOTICE, "Agent '%s' didn't answer/confirm within %d seconds (waited %d)\n", p->name, p->autologoff, howlong);				if (owner || p->chan) {					if (owner) {						ast_softhangup(owner, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(owner);						owner = ast_channel_unref(owner);					}					while (p->chan && ast_channel_trylock(p->chan)) {						DEADLOCK_AVOIDANCE(&p->lock);					}					if (p->chan) {						ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(p->chan);					}				}			}		}		switch (f->frametype) {		case AST_FRAME_CONTROL:			if (f->subclass.integer == AST_CONTROL_ANSWER) {				if (p->ackcall) {					ast_verb(3, "%s answered, waiting for '%c' to acknowledge\n", ast_channel_name(p->chan), p->acceptdtmf);					/* Don't pass answer along */					ast_frfree(f);					f = &ast_null_frame;				} else {					p->acknowledged = 1;					/* Use the builtin answer frame for the 					   recording start check below. */					ast_frfree(f);					f = &answer_frame;				}			}			break;		case AST_FRAME_DTMF_BEGIN:			/*ignore DTMF begin's as it can cause issues with queue announce files*/			if((!p->acknowledged && f->subclass.integer == p->acceptdtmf) || (f->subclass.integer == p->enddtmf && endcall)){				ast_frfree(f);				f = &ast_null_frame;			}			break;		case AST_FRAME_DTMF_END:			if (!p->acknowledged && (f->subclass.integer == p->acceptdtmf)) {				if (p->chan) {					ast_verb(3, "%s acknowledged\n", ast_channel_name(p->chan));				}				p->acknowledged = 1;				ast_frfree(f);				f = &answer_frame;			} else if (f->subclass.integer == p->enddtmf && endcall) {				/* terminates call */				ast_frfree(f);				f = NULL;			}			break;		case AST_FRAME_VOICE:		case AST_FRAME_VIDEO:			/* don't pass voice or video until the call is acknowledged */			if (!p->acknowledged) {				ast_frfree(f);				f = &ast_null_frame;			}		default:			/* pass everything else on through */			break;		}	}
if (!p->ackcall && !p->acknowledged && p->chan && (ast_channel_state(p->chan) == AST_STATE_UP)) {			p->acknowledged = 1;		}
!p->ackcall && !p->acknowledged && p->chan && (ast_channel_state(p->chan) == AST_STATE_UP)
!p->ackcall && !p->acknowledged && p->chan
!p->ackcall && !p->acknowledged
!p->ackcall
p->ackcall
p
p
ackcall
!p->acknowledged
p->acknowledged
p
p
acknowledged
p->chan
p
p
chan
(ast_channel_state(p->chan) == AST_STATE_UP)
ast_channel_state(p->chan) == AST_STATE_UP
ast_channel_state(p->chan)
ast_channel_state
ast_channel_state
p->chan
p
p
chan
AST_STATE_UP
AST_STATE_UP
{			p->acknowledged = 1;		}
p->acknowledged = 1;
p->acknowledged = 1
p->acknowledged
p
p
acknowledged
1
if (!p->acknowledged) {			int howlong = cur_time - p->start;			if (p->autologoff && (howlong >= p->autologoff)) {				ast_log(LOG_NOTICE, "Agent '%s' didn't answer/confirm within %d seconds (waited %d)\n", p->name, p->autologoff, howlong);				if (owner || p->chan) {					if (owner) {						ast_softhangup(owner, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(owner);						owner = ast_channel_unref(owner);					}					while (p->chan && ast_channel_trylock(p->chan)) {						DEADLOCK_AVOIDANCE(&p->lock);					}					if (p->chan) {						ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(p->chan);					}				}			}		}
!p->acknowledged
p->acknowledged
p
p
acknowledged
{			int howlong = cur_time - p->start;			if (p->autologoff && (howlong >= p->autologoff)) {				ast_log(LOG_NOTICE, "Agent '%s' didn't answer/confirm within %d seconds (waited %d)\n", p->name, p->autologoff, howlong);				if (owner || p->chan) {					if (owner) {						ast_softhangup(owner, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(owner);						owner = ast_channel_unref(owner);					}					while (p->chan && ast_channel_trylock(p->chan)) {						DEADLOCK_AVOIDANCE(&p->lock);					}					if (p->chan) {						ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(p->chan);					}				}			}		}
int howlong = cur_time - p->start;
int howlong = cur_time - p->start;
int
howlong = cur_time - p->start
howlong
= cur_time - p->start
cur_time - p->start
cur_time
cur_time
p->start
p
p
start
if (p->autologoff && (howlong >= p->autologoff)) {				ast_log(LOG_NOTICE, "Agent '%s' didn't answer/confirm within %d seconds (waited %d)\n", p->name, p->autologoff, howlong);				if (owner || p->chan) {					if (owner) {						ast_softhangup(owner, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(owner);						owner = ast_channel_unref(owner);					}					while (p->chan && ast_channel_trylock(p->chan)) {						DEADLOCK_AVOIDANCE(&p->lock);					}					if (p->chan) {						ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(p->chan);					}				}			}
p->autologoff && (howlong >= p->autologoff)
p->autologoff
p
p
autologoff
(howlong >= p->autologoff)
howlong >= p->autologoff
howlong
howlong
p->autologoff
p
p
autologoff
{				ast_log(LOG_NOTICE, "Agent '%s' didn't answer/confirm within %d seconds (waited %d)\n", p->name, p->autologoff, howlong);				if (owner || p->chan) {					if (owner) {						ast_softhangup(owner, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(owner);						owner = ast_channel_unref(owner);					}					while (p->chan && ast_channel_trylock(p->chan)) {						DEADLOCK_AVOIDANCE(&p->lock);					}					if (p->chan) {						ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(p->chan);					}				}			}
ast_log(LOG_NOTICE, "Agent '%s' didn't answer/confirm within %d seconds (waited %d)\n", p->name, p->autologoff, howlong);
ast_log(LOG_NOTICE, "Agent '%s' didn't answer/confirm within %d seconds (waited %d)\n", p->name, p->autologoff, howlong)
ast_log
ast_log
LOG_NOTICE
LOG_NOTICE
"Agent '%s' didn't answer/confirm within %d seconds (waited %d)\n"
p->name
p
p
name
p->autologoff
p
p
autologoff
howlong
howlong
if (owner || p->chan) {					if (owner) {						ast_softhangup(owner, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(owner);						owner = ast_channel_unref(owner);					}					while (p->chan && ast_channel_trylock(p->chan)) {						DEADLOCK_AVOIDANCE(&p->lock);					}					if (p->chan) {						ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(p->chan);					}				}
owner || p->chan
owner
owner
p->chan
p
p
chan
{					if (owner) {						ast_softhangup(owner, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(owner);						owner = ast_channel_unref(owner);					}					while (p->chan && ast_channel_trylock(p->chan)) {						DEADLOCK_AVOIDANCE(&p->lock);					}					if (p->chan) {						ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(p->chan);					}				}
if (owner) {						ast_softhangup(owner, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(owner);						owner = ast_channel_unref(owner);					}
owner
owner
{						ast_softhangup(owner, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(owner);						owner = ast_channel_unref(owner);					}
ast_softhangup(owner, AST_SOFTHANGUP_EXPLICIT);
ast_softhangup(owner, AST_SOFTHANGUP_EXPLICIT)
ast_softhangup
ast_softhangup
owner
owner
AST_SOFTHANGUP_EXPLICIT
AST_SOFTHANGUP_EXPLICIT
ast_channel_unlock(owner);
ast_channel_unlock(owner)
ast_channel_unlock
ast_channel_unlock
owner
owner
owner = ast_channel_unref(owner);
owner = ast_channel_unref(owner)
owner
owner
ast_channel_unref(owner)
ast_channel_unref
ast_channel_unref
owner
owner
while (p->chan && ast_channel_trylock(p->chan)) {						DEADLOCK_AVOIDANCE(&p->lock);					}
p->chan && ast_channel_trylock(p->chan)
p->chan
p
p
chan
ast_channel_trylock(p->chan)
ast_channel_trylock
ast_channel_trylock
p->chan
p
p
chan
{						DEADLOCK_AVOIDANCE(&p->lock);					}
DEADLOCK_AVOIDANCE(&p->lock);
DEADLOCK_AVOIDANCE(&p->lock)
DEADLOCK_AVOIDANCE
DEADLOCK_AVOIDANCE
&p->lock
p->lock
p
p
lock
if (p->chan) {						ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(p->chan);					}
p->chan
p
p
chan
{						ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);						ast_channel_unlock(p->chan);					}
ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT);
ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT)
ast_softhangup
ast_softhangup
p->chan
p
p
chan
AST_SOFTHANGUP_EXPLICIT
AST_SOFTHANGUP_EXPLICIT
ast_channel_unlock(p->chan);
ast_channel_unlock(p->chan)
ast_channel_unlock
ast_channel_unlock
p->chan
p
p
chan
switch (f->frametype) {		case AST_FRAME_CONTROL:			if (f->subclass.integer == AST_CONTROL_ANSWER) {				if (p->ackcall) {					ast_verb(3, "%s answered, waiting for '%c' to acknowledge\n", ast_channel_name(p->chan), p->acceptdtmf);					/* Don't pass answer along */					ast_frfree(f);					f = &ast_null_frame;				} else {					p->acknowledged = 1;					/* Use the builtin answer frame for the 					   recording start check below. */					ast_frfree(f);					f = &answer_frame;				}			}			break;		case AST_FRAME_DTMF_BEGIN:			/*ignore DTMF begin's as it can cause issues with queue announce files*/			if((!p->acknowledged && f->subclass.integer == p->acceptdtmf) || (f->subclass.integer == p->enddtmf && endcall)){				ast_frfree(f);				f = &ast_null_frame;			}			break;		case AST_FRAME_DTMF_END:			if (!p->acknowledged && (f->subclass.integer == p->acceptdtmf)) {				if (p->chan) {					ast_verb(3, "%s acknowledged\n", ast_channel_name(p->chan));				}				p->acknowledged = 1;				ast_frfree(f);				f = &answer_frame;			} else if (f->subclass.integer == p->enddtmf && endcall) {				/* terminates call */				ast_frfree(f);				f = NULL;			}			break;		case AST_FRAME_VOICE:		case AST_FRAME_VIDEO:			/* don't pass voice or video until the call is acknowledged */			if (!p->acknowledged) {				ast_frfree(f);				f = &ast_null_frame;			}		default:			/* pass everything else on through */			break;		}
f->frametype
f
f
frametype
{		case AST_FRAME_CONTROL:			if (f->subclass.integer == AST_CONTROL_ANSWER) {				if (p->ackcall) {					ast_verb(3, "%s answered, waiting for '%c' to acknowledge\n", ast_channel_name(p->chan), p->acceptdtmf);					/* Don't pass answer along */					ast_frfree(f);					f = &ast_null_frame;				} else {					p->acknowledged = 1;					/* Use the builtin answer frame for the 					   recording start check below. */					ast_frfree(f);					f = &answer_frame;				}			}			break;		case AST_FRAME_DTMF_BEGIN:			/*ignore DTMF begin's as it can cause issues with queue announce files*/			if((!p->acknowledged && f->subclass.integer == p->acceptdtmf) || (f->subclass.integer == p->enddtmf && endcall)){				ast_frfree(f);				f = &ast_null_frame;			}			break;		case AST_FRAME_DTMF_END:			if (!p->acknowledged && (f->subclass.integer == p->acceptdtmf)) {				if (p->chan) {					ast_verb(3, "%s acknowledged\n", ast_channel_name(p->chan));				}				p->acknowledged = 1;				ast_frfree(f);				f = &answer_frame;			} else if (f->subclass.integer == p->enddtmf && endcall) {				/* terminates call */				ast_frfree(f);				f = NULL;			}			break;		case AST_FRAME_VOICE:		case AST_FRAME_VIDEO:			/* don't pass voice or video until the call is acknowledged */			if (!p->acknowledged) {				ast_frfree(f);				f = &ast_null_frame;			}		default:			/* pass everything else on through */			break;		}
case AST_FRAME_CONTROL:
AST_FRAME_CONTROL
AST_FRAME_CONTROL
if (f->subclass.integer == AST_CONTROL_ANSWER) {				if (p->ackcall) {					ast_verb(3, "%s answered, waiting for '%c' to acknowledge\n", ast_channel_name(p->chan), p->acceptdtmf);					/* Don't pass answer along */					ast_frfree(f);					f = &ast_null_frame;				} else {					p->acknowledged = 1;					/* Use the builtin answer frame for the 					   recording start check below. */					ast_frfree(f);					f = &answer_frame;				}			}
f->subclass.integer == AST_CONTROL_ANSWER
f->subclass.integer
f->subclass
f
f
subclass
integer
AST_CONTROL_ANSWER
AST_CONTROL_ANSWER
{				if (p->ackcall) {					ast_verb(3, "%s answered, waiting for '%c' to acknowledge\n", ast_channel_name(p->chan), p->acceptdtmf);					/* Don't pass answer along */					ast_frfree(f);					f = &ast_null_frame;				} else {					p->acknowledged = 1;					/* Use the builtin answer frame for the 					   recording start check below. */					ast_frfree(f);					f = &answer_frame;				}			}
if (p->ackcall) {					ast_verb(3, "%s answered, waiting for '%c' to acknowledge\n", ast_channel_name(p->chan), p->acceptdtmf);					/* Don't pass answer along */					ast_frfree(f);					f = &ast_null_frame;				} else {					p->acknowledged = 1;					/* Use the builtin answer frame for the 					   recording start check below. */					ast_frfree(f);					f = &answer_frame;				}
p->ackcall
p
p
ackcall
{					ast_verb(3, "%s answered, waiting for '%c' to acknowledge\n", ast_channel_name(p->chan), p->acceptdtmf);					/* Don't pass answer along */					ast_frfree(f);					f = &ast_null_frame;				}
ast_verb(3, "%s answered, waiting for '%c' to acknowledge\n", ast_channel_name(p->chan), p->acceptdtmf);
ast_verb(3, "%s answered, waiting for '%c' to acknowledge\n", ast_channel_name(p->chan), p->acceptdtmf)
ast_verb
ast_verb
3
"%s answered, waiting for '%c' to acknowledge\n"
ast_channel_name(p->chan)
ast_channel_name
ast_channel_name
p->chan
p
p
chan
p->acceptdtmf
p
p
acceptdtmf
ast_frfree(f);
ast_frfree(f)
ast_frfree
ast_frfree
f
f
f = &ast_null_frame;
f = &ast_null_frame
f
f
&ast_null_frame
ast_null_frame
ast_null_frame
{					p->acknowledged = 1;					/* Use the builtin answer frame for the 					   recording start check below. */					ast_frfree(f);					f = &answer_frame;				}
p->acknowledged = 1;
p->acknowledged = 1
p->acknowledged
p
p
acknowledged
1
ast_frfree(f);
ast_frfree(f)
ast_frfree
ast_frfree
f
f
f = &answer_frame;
f = &answer_frame
f
f
&answer_frame
answer_frame
answer_frame
break;
case AST_FRAME_DTMF_BEGIN:
AST_FRAME_DTMF_BEGIN
AST_FRAME_DTMF_BEGIN
if((!p->acknowledged && f->subclass.integer == p->acceptdtmf) || (f->subclass.integer == p->enddtmf && endcall)){				ast_frfree(f);				f = &ast_null_frame;			}
(!p->acknowledged && f->subclass.integer == p->acceptdtmf) || (f->subclass.integer == p->enddtmf && endcall)
(!p->acknowledged && f->subclass.integer == p->acceptdtmf)
!p->acknowledged && f->subclass.integer == p->acceptdtmf
!p->acknowledged
p->acknowledged
p
p
acknowledged
f->subclass.integer == p->acceptdtmf
f->subclass.integer
f->subclass
f
f
subclass
integer
p->acceptdtmf
p
p
acceptdtmf
(f->subclass.integer == p->enddtmf && endcall)
f->subclass.integer == p->enddtmf && endcall
f->subclass.integer == p->enddtmf
f->subclass.integer
f->subclass
f
f
subclass
integer
p->enddtmf
p
p
enddtmf
endcall
endcall
{				ast_frfree(f);				f = &ast_null_frame;			}
ast_frfree(f);
ast_frfree(f)
ast_frfree
ast_frfree
f
f
f = &ast_null_frame;
f = &ast_null_frame
f
f
&ast_null_frame
ast_null_frame
ast_null_frame
break;
case AST_FRAME_DTMF_END:
AST_FRAME_DTMF_END
AST_FRAME_DTMF_END
if (!p->acknowledged && (f->subclass.integer == p->acceptdtmf)) {				if (p->chan) {					ast_verb(3, "%s acknowledged\n", ast_channel_name(p->chan));				}				p->acknowledged = 1;				ast_frfree(f);				f = &answer_frame;			} else if (f->subclass.integer == p->enddtmf && endcall) {				/* terminates call */				ast_frfree(f);				f = NULL;			}
!p->acknowledged && (f->subclass.integer == p->acceptdtmf)
!p->acknowledged
p->acknowledged
p
p
acknowledged
(f->subclass.integer == p->acceptdtmf)
f->subclass.integer == p->acceptdtmf
f->subclass.integer
f->subclass
f
f
subclass
integer
p->acceptdtmf
p
p
acceptdtmf
{				if (p->chan) {					ast_verb(3, "%s acknowledged\n", ast_channel_name(p->chan));				}				p->acknowledged = 1;				ast_frfree(f);				f = &answer_frame;			}
if (p->chan) {					ast_verb(3, "%s acknowledged\n", ast_channel_name(p->chan));				}
p->chan
p
p
chan
{					ast_verb(3, "%s acknowledged\n", ast_channel_name(p->chan));				}
ast_verb(3, "%s acknowledged\n", ast_channel_name(p->chan));
ast_verb(3, "%s acknowledged\n", ast_channel_name(p->chan))
ast_verb
ast_verb
3
"%s acknowledged\n"
ast_channel_name(p->chan)
ast_channel_name
ast_channel_name
p->chan
p
p
chan
p->acknowledged = 1;
p->acknowledged = 1
p->acknowledged
p
p
acknowledged
1
ast_frfree(f);
ast_frfree(f)
ast_frfree
ast_frfree
f
f
f = &answer_frame;
f = &answer_frame
f
f
&answer_frame
answer_frame
answer_frame
if (f->subclass.integer == p->enddtmf && endcall) {				/* terminates call */				ast_frfree(f);				f = NULL;			}
f->subclass.integer == p->enddtmf && endcall
f->subclass.integer == p->enddtmf
f->subclass.integer
f->subclass
f
f
subclass
integer
p->enddtmf
p
p
enddtmf
endcall
endcall
{				/* terminates call */				ast_frfree(f);				f = NULL;			}
ast_frfree(f);
ast_frfree(f)
ast_frfree
ast_frfree
f
f
f = NULL;
f = NULL
f
f
NULL
NULL
break;
case AST_FRAME_VOICE:
AST_FRAME_VOICE
AST_FRAME_VOICE
case AST_FRAME_VIDEO:
AST_FRAME_VIDEO
AST_FRAME_VIDEO
if (!p->acknowledged) {				ast_frfree(f);				f = &ast_null_frame;			}
!p->acknowledged
p->acknowledged
p
p
acknowledged
{				ast_frfree(f);				f = &ast_null_frame;			}
ast_frfree(f);
ast_frfree(f)
ast_frfree
ast_frfree
f
f
f = &ast_null_frame;
f = &ast_null_frame
f
f
&ast_null_frame
ast_null_frame
ast_null_frame
default:
break;
if (owner) {		ast_channel_unlock(owner);		owner = ast_channel_unref(owner);	}
owner
owner
{		ast_channel_unlock(owner);		owner = ast_channel_unref(owner);	}
ast_channel_unlock(owner);
ast_channel_unlock(owner)
ast_channel_unlock
ast_channel_unlock
owner
owner
owner = ast_channel_unref(owner);
owner = ast_channel_unref(owner)
owner
owner
ast_channel_unref(owner)
ast_channel_unref
ast_channel_unref
owner
owner
CLEANUP(ast,p);
CLEANUP(ast,p)
CLEANUP
CLEANUP
ast
ast
p
p
if (p->chan && !ast_channel_internal_bridged_channel(p->chan)) {		if (strcasecmp(ast_channel_tech(p->chan)->type, "Local")) {			ast_channel_internal_bridged_channel_set(p->chan, ast);			if (p->chan)				ast_debug(1, "Bridge on '%s' being set to '%s' (3)\n", ast_channel_name(p->chan), ast_channel_name(ast_channel_internal_bridged_channel(p->chan)));		}	}
p->chan && !ast_channel_internal_bridged_channel(p->chan)
p->chan
p
p
chan
!ast_channel_internal_bridged_channel(p->chan)
ast_channel_internal_bridged_channel(p->chan)
ast_channel_internal_bridged_channel
ast_channel_internal_bridged_channel
p->chan
p
p
chan
{		if (strcasecmp(ast_channel_tech(p->chan)->type, "Local")) {			ast_channel_internal_bridged_channel_set(p->chan, ast);			if (p->chan)				ast_debug(1, "Bridge on '%s' being set to '%s' (3)\n", ast_channel_name(p->chan), ast_channel_name(ast_channel_internal_bridged_channel(p->chan)));		}	}
if (strcasecmp(ast_channel_tech(p->chan)->type, "Local")) {			ast_channel_internal_bridged_channel_set(p->chan, ast);			if (p->chan)				ast_debug(1, "Bridge on '%s' being set to '%s' (3)\n", ast_channel_name(p->chan), ast_channel_name(ast_channel_internal_bridged_channel(p->chan)));		}
strcasecmp(ast_channel_tech(p->chan)->type, "Local")
strcasecmp
strcasecmp
ast_channel_tech(p->chan)->type
ast_channel_tech(p->chan)
ast_channel_tech
ast_channel_tech
p->chan
p
p
chan
type
"Local"
{			ast_channel_internal_bridged_channel_set(p->chan, ast);			if (p->chan)				ast_debug(1, "Bridge on '%s' being set to '%s' (3)\n", ast_channel_name(p->chan), ast_channel_name(ast_channel_internal_bridged_channel(p->chan)));		}
ast_channel_internal_bridged_channel_set(p->chan, ast);
ast_channel_internal_bridged_channel_set(p->chan, ast)
ast_channel_internal_bridged_channel_set
ast_channel_internal_bridged_channel_set
p->chan
p
p
chan
ast
ast
if (p->chan)				ast_debug(1, "Bridge on '%s' being set to '%s' (3)\n", ast_channel_name(p->chan), ast_channel_name(ast_channel_internal_bridged_channel(p->chan)));
p->chan
p
p
chan
ast_debug(1, "Bridge on '%s' being set to '%s' (3)\n", ast_channel_name(p->chan), ast_channel_name(ast_channel_internal_bridged_channel(p->chan)));
ast_debug(1, "Bridge on '%s' being set to '%s' (3)\n", ast_channel_name(p->chan), ast_channel_name(ast_channel_internal_bridged_channel(p->chan)))
ast_debug
ast_debug
1
"Bridge on '%s' being set to '%s' (3)\n"
ast_channel_name(p->chan)
ast_channel_name
ast_channel_name
p->chan
p
p
chan
ast_channel_name(ast_channel_internal_bridged_channel(p->chan))
ast_channel_name
ast_channel_name
ast_channel_internal_bridged_channel(p->chan)
ast_channel_internal_bridged_channel
ast_channel_internal_bridged_channel
p->chan
p
p
chan
ast_mutex_unlock(&p->lock);
ast_mutex_unlock(&p->lock)
ast_mutex_unlock
ast_mutex_unlock
&p->lock
p->lock
p
p
lock
if (recordagentcalls && f == &answer_frame)		agent_start_monitoring(ast,0);
recordagentcalls && f == &answer_frame
recordagentcalls
recordagentcalls
f == &answer_frame
f
f
&answer_frame
answer_frame
answer_frame
agent_start_monitoring(ast,0);
agent_start_monitoring(ast,0)
agent_start_monitoring
agent_start_monitoring
ast
ast
0
return f;
f
f
-----joern-----
(124,351,0)
(76,111,0)
(188,418,0)
(121,388,0)
(1,46,0)
(212,338,0)
(331,287,0)
(81,236,0)
(415,412,0)
(168,111,0)
(307,111,0)
(59,376,0)
(167,210,0)
(349,14,0)
(191,234,0)
(280,405,0)
(338,111,0)
(201,93,0)
(433,181,0)
(334,260,0)
(107,53,0)
(353,74,0)
(31,396,0)
(111,93,0)
(336,149,0)
(273,77,0)
(231,74,0)
(145,272,0)
(367,228,0)
(374,282,0)
(85,22,0)
(89,267,0)
(140,70,0)
(443,441,0)
(306,265,0)
(447,290,0)
(263,205,0)
(38,58,0)
(350,437,0)
(119,111,0)
(175,39,0)
(157,299,0)
(152,276,0)
(265,400,0)
(218,173,0)
(311,188,0)
(405,178,0)
(49,265,0)
(223,256,0)
(297,275,0)
(428,366,0)
(70,339,0)
(433,217,0)
(276,152,0)
(38,16,0)
(435,33,0)
(441,396,0)
(39,84,0)
(262,167,0)
(91,316,0)
(429,237,0)
(266,234,0)
(393,333,0)
(435,396,0)
(79,211,0)
(203,77,0)
(287,58,0)
(298,381,0)
(274,207,0)
(139,168,0)
(261,286,0)
(300,399,0)
(193,272,0)
(354,305,0)
(433,69,0)
(330,356,0)
(411,15,0)
(399,111,0)
(189,33,0)
(226,40,0)
(340,234,0)
(435,69,0)
(181,317,0)
(318,220,0)
(152,381,0)
(214,440,0)
(131,351,0)
(360,408,0)
(398,226,0)
(151,236,0)
(366,111,0)
(46,337,0)
(21,350,0)
(404,89,0)
(378,93,0)
(402,166,0)
(116,308,0)
(225,89,0)
(225,74,0)
(100,111,0)
(385,160,0)
(11,288,0)
(436,384,0)
(229,18,0)
(163,111,0)
(11,111,0)
(282,367,0)
(437,75,0)
(103,265,0)
(245,306,0)
(110,138,0)
(122,398,0)
(395,319,0)
(83,149,0)
(396,56,0)
(107,440,0)
(310,388,0)
(282,284,0)
(321,74,0)
(329,397,0)
(106,93,0)
(132,160,0)
(242,119,0)
(193,396,0)
(95,236,0)
(128,160,0)
(325,252,0)
(76,345,0)
(204,226,0)
(3,119,0)
(213,196,0)
(236,147,0)
(254,166,0)
(186,160,0)
(418,188,0)
(449,433,0)
(215,100,0)
(445,414,0)
(446,282,0)
(159,229,0)
(75,66,0)
(99,271,0)
(87,84,0)
(432,22,0)
(28,8,0)
(450,285,0)
(129,298,0)
(434,262,0)
(192,307,0)
(103,396,0)
(33,237,0)
(166,402,0)
(185,225,0)
(7,177,0)
(14,32,0)
(296,260,0)
(373,93,0)
(261,40,0)
(34,93,0)
(344,274,0)
(363,70,0)
(408,169,0)
(74,412,0)
(233,282,0)
(51,84,0)
(287,40,0)
(157,82,0)
(231,267,0)
(148,309,0)
(19,299,0)
(372,296,0)
(272,326,0)
(80,160,0)
(406,407,0)
(4,290,0)
(7,74,0)
(316,93,0)
(29,309,0)
(328,73,0)
(52,395,0)
(82,408,0)
(290,111,0)
(278,107,0)
(342,3,0)
(292,377,0)
(117,409,0)
(134,181,0)
(249,338,0)
(343,257,0)
(141,93,0)
(392,435,0)
(75,437,0)
(339,264,0)
(209,154,0)
(115,59,0)
(437,350,0)
(257,396,0)
(206,248,0)
(55,76,0)
(170,284,0)
(351,407,0)
(258,433,0)
(404,74,0)
(41,209,0)
(178,405,0)
(418,396,0)
(270,134,0)
(166,188,0)
(435,181,0)
(259,142,0)
(73,328,0)
(49,396,0)
(35,160,0)
(386,160,0)
(149,111,0)
(102,40,0)
(81,111,0)
(322,328,0)
(405,111,0)
(130,160,0)
(298,111,0)
(306,396,0)
(97,253,0)
(417,168,0)
(184,404,0)
(306,67,0)
(3,342,0)
(105,111,0)
(45,196,0)
(166,254,0)
(226,398,0)
(26,44,0)
(425,350,0)
(359,8,0)
(97,356,0)
(274,74,0)
(113,75,0)
(200,174,0)
(382,303,0)
(8,111,0)
(161,160,0)
(260,397,0)
(207,274,0)
(217,32,0)
(326,272,0)
(371,228,0)
(442,67,0)
(433,265,0)
(205,63,0)
(155,313,0)
(433,205,0)
(46,265,0)
(366,2,0)
(283,211,0)
(96,160,0)
(146,93,0)
(60,54,0)
(159,9,0)
(74,93,0)
(46,396,0)
(412,74,0)
(144,193,0)
(276,334,0)
(435,217,0)
(9,159,0)
(205,84,0)
(241,119,0)
(43,198,0)
(307,414,0)
(397,329,0)
(369,252,0)
(136,275,0)
(208,81,0)
(294,367,0)
(64,157,0)
(188,166,0)
(120,111,0)
(435,107,0)
(257,18,0)
(268,376,0)
(390,329,0)
(252,111,0)
(423,293,0)
(243,68,0)
(30,207,0)
(398,400,0)
(234,111,0)
(244,44,0)
(315,16,0)
(356,97,0)
(422,239,0)
(356,111,0)
(355,329,0)
(199,333,0)
(10,120,0)
(167,262,0)
(282,333,0)
(123,100,0)
(6,246,0)
(435,265,0)
(216,264,0)
(362,262,0)
(77,111,0)
(260,296,0)
(347,15,0)
(125,334,0)
(275,111,0)
(312,306,0)
(53,107,0)
(67,306,0)
(423,111,0)
(346,160,0)
(256,111,0)
(289,321,0)
(243,414,0)
(319,77,0)
(155,256,0)
(16,38,0)
(323,254,0)
(419,399,0)
(232,384,0)
(22,111,0)
(0,111,0)
(275,93,0)
(181,134,0)
(72,217,0)
(414,104,0)
(228,367,0)
(105,172,0)
(441,265,0)
(198,93,0)
(163,143,0)
(68,243,0)
(196,111,0)
(194,293,0)
(42,11,0)
(228,105,0)
(314,257,0)
(82,157,0)
(89,225,0)
(387,399,0)
(251,102,0)
(210,24,0)
(227,286,0)
(299,147,0)
(76,414,0)
(14,265,0)
(333,282,0)
(335,94,0)
(174,172,0)
(301,356,0)
(316,111,0)
(345,76,0)
(73,168,0)
(187,418,0)
(275,40,0)
(108,240,0)
(178,147,0)
(158,388,0)
(88,307,0)
(439,44,0)
(308,111,0)
(236,81,0)
(426,207,0)
(436,400,0)
(395,173,0)
(406,111,0)
(37,231,0)
(230,181,0)
(138,111,0)
(421,7,0)
(99,94,0)
(182,163,0)
(402,111,0)
(101,423,0)
(351,252,0)
(156,93,0)
(66,154,0)
(61,396,0)
(51,265,0)
(25,93,0)
(441,317,0)
(424,163,0)
(376,93,0)
(69,337,0)
(431,103,0)
(433,107,0)
(18,229,0)
(272,193,0)
(296,111,0)
(174,111,0)
(228,376,0)
(281,265,0)
(229,0,0)
(247,193,0)
(9,196,0)
(321,267,0)
(202,298,0)
(336,142,0)
(142,303,0)
(13,54,0)
(163,414,0)
(253,138,0)
(180,56,0)
(413,316,0)
(105,228,0)
(219,326,0)
(438,382,0)
(250,406,0)
(324,75,0)
(71,328,0)
(62,93,0)
(65,308,0)
(196,414,0)
(157,111,0)
(351,317,0)
(435,205,0)
(58,38,0)
(408,82,0)
(361,160,0)
(207,111,0)
(329,265,0)
(401,53,0)
(348,49,0)
(339,70,0)
(172,394,0)
(20,397,0)
(288,11,0)
(357,94,0)
(183,299,0)
(262,111,0)
(377,137,0)
(171,54,0)
(389,285,0)
(382,111,0)
(302,99,0)
(60,271,0)
(165,38,0)
(338,299,0)
(184,177,0)
(409,111,0)
(379,198,0)
(19,261,0)
(5,157,0)
(407,406,0)
(18,257,0)
(103,137,0)
(352,149,0)
(179,173,0)
(69,305,0)
(243,111,0)
(305,69,0)
(303,382,0)
(410,402,0)
(334,276,0)
(261,19,0)
(22,214,0)
(90,296,0)
(234,299,0)
(216,2,0)
(49,440,0)
(54,60,0)
(78,184,0)
(418,265,0)
(328,195,0)
(58,436,0)
(109,243,0)
(319,395,0)
(350,111,0)
(285,111,0)
(395,367,0)
(403,214,0)
(381,67,0)
(94,99,0)
(70,111,0)
(240,111,0)
(154,66,0)
(238,384,0)
(435,220,0)
(51,396,0)
(260,334,0)
(387,106,0)
(119,3,0)
(7,89,0)
(112,93,0)
(399,387,0)
(54,111,0)
(44,244,0)
(168,73,0)
(264,339,0)
(86,290,0)
(433,396,0)
(102,111,0)
(220,435,0)
(290,447,0)
(404,184,0)
(375,0,0)
(293,147,0)
(23,63,0)
(106,387,0)
(221,217,0)
(364,404,0)
(127,209,0)
(17,133,0)
(222,406,0)
(367,246,0)
(36,402,0)
(433,93,0)
(149,336,0)
(295,19,0)
(164,240,0)
(229,159,0)
(380,19,0)
(162,423,0)
(332,256,0)
(420,76,0)
(336,264,0)
(210,167,0)
(252,351,0)
(142,336,0)
(448,133,0)
(63,205,0)
(196,9,0)
(266,313,0)
(269,81,0)
(53,237,0)
(384,111,0)
(391,418,0)
(256,299,0)
(383,246,0)
(427,93,0)
(279,105,0)
(138,253,0)
(342,93,0)
(14,396,0)
(2,216,0)
(313,155,0)
(288,265,0)
(341,444,0)
(150,261,0)
(257,265,0)
(50,236,0)
(66,75,0)
(0,229,0)
(63,237,0)
(433,377,0)
(436,58,0)
(173,111,0)
(365,120,0)
(58,287,0)
(381,298,0)
(316,40,0)
(172,376,0)
(304,18,0)
(237,93,0)
(8,39,0)
(211,265,0)
(114,61,0)
(193,265,0)
(381,152,0)
(126,409,0)
(333,111,0)
(173,395,0)
(234,266,0)
(235,89,0)
(211,396,0)
(303,142,0)
(370,321,0)
(190,105,0)
(244,398,0)
(282,240,0)
(15,40,0)
(264,216,0)
(313,266,0)
(416,160,0)
(264,336,0)
(368,221,0)
(376,59,0)
(358,138,0)
(407,351,0)
(48,382,0)
(12,169,0)
(291,69,0)
(255,111,0)
(384,436,0)
(111,102,0)
(56,396,0)
(67,381,0)
(143,163,0)
(412,111,0)
(33,435,0)
(118,172,0)
(176,178,0)
(152,143,0)
(320,174,0)
(240,282,0)
(277,58,0)
(217,221,0)
(265,288,0)
(94,111,0)
(397,260,0)
(350,299,0)
(143,152,0)
(135,366,0)
(44,111,0)
(92,11,0)
(57,51,0)
(2,366,0)
(327,243,0)
(19,111,0)
(153,309,0)
(256,155,0)
(329,396,0)
(16,40,0)
(77,319,0)
(197,377,0)
(224,0,0)
(47,160,0)
(209,111,0)
(435,377,0)
(133,111,0)
(398,244,0)
(61,265,0)
(253,97,0)
(154,209,0)
(169,408,0)
(209,299,0)
(98,405,0)
(63,23,1)
(351,407,1)
(19,111,1)
(0,224,1)
(435,33,1)
(157,64,1)
(262,111,1)
(67,306,1)
(380,169,1)
(277,38,1)
(333,111,1)
(412,111,1)
(221,368,1)
(192,216,1)
(229,0,1)
(264,336,1)
(382,48,1)
(20,329,1)
(11,111,1)
(296,90,1)
(103,431,1)
(242,75,1)
(75,437,1)
(70,111,1)
(174,320,1)
(127,437,1)
(23,263,1)
(299,183,1)
(404,74,1)
(306,265,1)
(54,13,1)
(432,308,1)
(92,281,1)
(157,111,1)
(114,396,1)
(318,342,1)
(376,59,1)
(125,260,1)
(449,433,1)
(441,396,1)
(349,276,1)
(288,11,1)
(413,91,1)
(280,120,1)
(178,176,1)
(327,216,1)
(109,327,1)
(14,349,1)
(207,111,1)
(157,299,1)
(120,365,1)
(243,111,1)
(10,61,1)
(372,397,1)
(222,124,1)
(79,100,1)
(339,70,1)
(329,390,1)
(439,26,1)
(446,374,1)
(240,164,1)
(266,313,1)
(113,409,1)
(236,81,1)
(242,169,1)
(202,129,1)
(435,265,1)
(14,396,1)
(408,82,1)
(282,233,1)
(351,252,1)
(354,291,1)
(360,82,1)
(418,265,1)
(345,76,1)
(68,243,1)
(209,299,1)
(230,441,1)
(268,237,1)
(96,107,1)
(276,152,1)
(366,428,1)
(17,159,1)
(172,376,1)
(211,396,1)
(33,237,1)
(187,159,1)
(260,296,1)
(142,303,1)
(350,111,1)
(442,306,1)
(51,265,1)
(290,111,1)
(173,218,1)
(140,2,1)
(163,424,1)
(44,111,1)
(259,303,1)
(252,111,1)
(149,352,1)
(46,396,1)
(103,265,1)
(334,260,1)
(251,255,1)
(272,145,1)
(435,217,1)
(1,345,1)
(155,256,1)
(208,269,1)
(163,414,1)
(51,57,1)
(447,290,1)
(204,244,1)
(199,240,1)
(0,111,1)
(19,295,1)
(312,245,1)
(129,67,1)
(183,338,1)
(172,118,1)
(434,362,1)
(306,396,1)
(358,210,1)
(307,111,1)
(335,357,1)
(83,339,1)
(433,396,1)
(18,257,1)
(9,196,1)
(379,43,1)
(4,316,1)
(61,265,1)
(21,425,1)
(100,111,1)
(7,74,1)
(209,41,1)
(441,443,1)
(65,326,1)
(46,1,1)
(231,74,1)
(265,288,1)
(433,107,1)
(175,8,1)
(244,44,1)
(207,30,1)
(323,166,1)
(174,111,1)
(278,49,1)
(238,398,1)
(76,111,1)
(257,396,1)
(274,207,1)
(226,40,1)
(28,328,1)
(391,187,1)
(210,167,1)
(435,377,1)
(426,344,1)
(257,314,1)
(295,380,1)
(8,111,1)
(220,318,1)
(56,180,1)
(90,372,1)
(418,396,1)
(302,94,1)
(256,299,1)
(101,162,1)
(336,142,1)
(111,102,1)
(218,179,1)
(220,435,1)
(320,200,1)
(214,403,1)
(257,265,1)
(346,254,1)
(347,411,1)
(435,107,1)
(430,130,1)
(134,270,1)
(356,111,1)
(430,120,1)
(105,172,1)
(165,16,1)
(58,277,1)
(374,319,1)
(404,89,1)
(247,211,1)
(242,266,1)
(423,111,1)
(325,407,1)
(2,366,1)
(436,58,1)
(77,111,1)
(12,408,1)
(298,202,1)
(404,364,1)
(296,111,1)
(118,174,1)
(226,204,1)
(49,348,1)
(275,297,1)
(152,143,1)
(256,111,1)
(402,36,1)
(76,55,1)
(228,376,1)
(430,293,1)
(396,56,1)
(333,393,1)
(425,324,1)
(224,375,1)
(27,274,1)
(179,52,1)
(342,3,1)
(102,40,1)
(437,350,1)
(316,111,1)
(39,175,1)
(136,430,1)
(327,414,1)
(424,182,1)
(81,111,1)
(225,74,1)
(430,96,1)
(298,111,1)
(306,312,1)
(433,217,1)
(98,280,1)
(285,111,1)
(63,237,1)
(72,14,1)
(57,39,1)
(371,294,1)
(398,122,1)
(406,250,1)
(362,253,1)
(252,369,1)
(393,199,1)
(215,123,1)
(322,71,1)
(387,399,1)
(405,111,1)
(143,163,1)
(261,40,1)
(241,242,1)
(43,111,1)
(13,171,1)
(116,65,1)
(75,66,1)
(281,436,1)
(203,367,1)
(365,10,1)
(16,315,1)
(445,307,1)
(150,19,1)
(117,126,1)
(402,111,1)
(435,205,1)
(357,100,1)
(297,136,1)
(356,330,1)
(123,253,1)
(438,149,1)
(122,226,1)
(294,68,1)
(414,445,1)
(340,191,1)
(377,292,1)
(412,415,1)
(316,40,1)
(196,414,1)
(44,439,1)
(105,111,1)
(26,285,1)
(64,5,1)
(328,73,1)
(144,247,1)
(164,108,1)
(18,304,1)
(11,42,1)
(46,265,1)
(395,173,1)
(315,384,1)
(282,367,1)
(133,111,1)
(77,273,1)
(167,262,1)
(58,287,1)
(384,232,1)
(308,116,1)
(133,448,1)
(36,410,1)
(59,115,1)
(99,94,1)
(290,86,1)
(49,265,1)
(74,412,1)
(254,323,1)
(191,275,1)
(358,89,1)
(332,223,1)
(79,274,1)
(321,74,1)
(399,419,1)
(233,333,1)
(209,111,1)
(171,99,1)
(283,79,1)
(269,151,1)
(198,379,1)
(110,358,1)
(316,413,1)
(99,302,1)
(301,138,1)
(348,214,1)
(51,396,1)
(82,157,1)
(408,360,1)
(260,397,1)
(429,198,1)
(334,125,1)
(389,450,1)
(145,193,1)
(293,194,1)
(138,110,1)
(289,370,1)
(433,69,1)
(105,279,1)
(346,377,1)
(249,178,1)
(213,45,1)
(15,347,1)
(275,40,1)
(326,272,1)
(390,355,1)
(169,408,1)
(418,391,1)
(423,101,1)
(30,426,1)
(19,299,1)
(216,2,1)
(211,283,1)
(135,61,1)
(292,197,1)
(428,135,1)
(441,265,1)
(430,416,1)
(33,189,1)
(81,208,1)
(178,405,1)
(15,40,1)
(409,111,1)
(366,111,1)
(182,211,1)
(3,119,1)
(14,265,1)
(119,111,1)
(94,111,1)
(240,111,1)
(154,209,1)
(22,85,1)
(329,265,1)
(275,111,1)
(115,268,1)
(421,430,1)
(130,276,1)
(181,134,1)
(67,442,1)
(338,111,1)
(435,69,1)
(184,404,1)
(38,165,1)
(415,353,1)
(71,133,1)
(367,228,1)
(61,114,1)
(108,446,1)
(403,22,1)
(330,301,1)
(274,74,1)
(273,203,1)
(417,139,1)
(398,244,1)
(52,77,1)
(375,18,1)
(197,103,1)
(48,438,1)
(53,237,1)
(331,38,1)
(234,340,1)
(397,20,1)
(274,344,1)
(263,51,1)
(243,414,1)
(436,384,1)
(435,396,1)
(60,54,1)
(193,265,1)
(433,265,1)
(326,219,1)
(363,140,1)
(276,334,1)
(305,354,1)
(168,111,1)
(216,264,1)
(190,371,1)
(279,190,1)
(131,308,1)
(399,111,1)
(73,168,1)
(355,152,1)
(55,420,1)
(416,69,1)
(70,363,1)
(433,181,1)
(69,305,1)
(7,89,1)
(448,17,1)
(138,111,1)
(126,261,1)
(212,249,1)
(124,131,1)
(50,299,1)
(291,46,1)
(420,211,1)
(91,74,1)
(79,60,1)
(176,405,1)
(311,418,1)
(381,67,1)
(231,37,1)
(433,377,1)
(411,220,1)
(162,236,1)
(234,111,1)
(450,447,1)
(261,19,1)
(416,211,1)
(180,31,1)
(261,150,1)
(313,155,1)
(346,205,1)
(350,299,1)
(38,16,1)
(200,447,1)
(188,418,1)
(392,318,1)
(130,217,1)
(237,429,1)
(272,193,1)
(431,254,1)
(114,265,1)
(321,289,1)
(409,117,1)
(85,432,1)
(344,282,1)
(435,181,1)
(168,417,1)
(350,21,1)
(282,333,1)
(401,278,1)
(243,109,1)
(352,83,1)
(119,241,1)
(8,359,1)
(382,111,1)
(324,113,1)
(96,181,1)
(368,72,1)
(5,266,1)
(139,322,1)
(173,111,1)
(235,231,1)
(397,329,1)
(96,326,1)
(211,265,1)
(353,106,1)
(430,346,1)
(41,127,1)
(245,143,1)
(232,238,1)
(369,325,1)
(53,401,1)
(159,9,1)
(319,77,1)
(54,111,1)
(166,402,1)
(142,259,1)
(95,50,1)
(166,188,1)
(217,221,1)
(49,396,1)
(308,111,1)
(443,351,1)
(189,392,1)
(79,68,1)
(194,423,1)
(410,188,1)
(285,389,1)
(234,299,1)
(433,205,1)
(185,235,1)
(188,311,1)
(250,222,1)
(159,229,1)
(254,166,1)
(266,234,1)
(103,396,1)
(450,172,1)
(307,88,1)
(381,298,1)
(287,40,1)
(100,215,1)
(256,332,1)
(45,211,1)
(384,111,1)
(79,319,1)
(407,406,1)
(66,154,1)
(86,4,1)
(319,395,1)
(359,28,1)
(196,111,1)
(102,251,1)
(336,149,1)
(416,345,1)
(149,111,1)
(262,434,1)
(329,396,1)
(270,230,1)
(303,382,1)
(287,331,1)
(253,97,1)
(76,414,1)
(406,111,1)
(370,27,1)
(196,213,1)
(300,376,1)
(169,12,1)
(229,18,1)
(22,111,1)
(219,272,1)
(358,27,1)
(58,38,1)
(152,381,1)
(163,111,1)
(282,240,1)
(253,138,1)
(223,234,1)
(258,220,1)
(42,92,1)
(225,185,1)
(16,40,1)
(28,133,1)
(338,212,1)
(343,9,1)
(314,343,1)
(88,192,1)
(97,356,1)
(205,63,1)
(78,7,1)
(242,409,1)
(31,285,1)
(405,98,1)
(193,144,1)
(107,53,1)
(120,111,1)
(228,105,1)
(94,335,1)
(398,226,1)
(433,258,1)
(151,95,1)
(106,387,1)
(258,15,1)
(364,78,1)
(264,339,1)
(136,184,1)
(304,257,1)
(395,367,1)
(419,300,1)
(37,321,1)
(193,396,1)
(61,396,1)
(7,421,1)
(89,225,1)
(108,319,2)
(264,336,2)
(225,27,2)
(12,266,2)
(171,100,2)
(435,377,2)
(220,435,2)
(283,61,2)
(23,159,2)
(433,217,2)
(13,100,2)
(358,253,2)
(257,9,2)
(76,111,2)
(230,308,2)
(370,27,2)
(207,111,2)
(199,319,2)
(168,111,2)
(14,276,2)
(399,111,2)
(209,299,2)
(159,229,2)
(325,308,2)
(150,169,2)
(321,74,2)
(52,77,2)
(131,308,2)
(405,120,2)
(322,133,2)
(253,138,2)
(21,409,2)
(418,159,2)
(63,237,2)
(75,437,2)
(409,169,2)
(19,169,2)
(224,9,2)
(266,313,2)
(436,384,2)
(169,266,2)
(253,253,2)
(216,61,2)
(348,308,2)
(63,159,2)
(31,285,2)
(364,430,2)
(447,290,2)
(219,211,2)
(11,111,2)
(17,159,2)
(356,111,2)
(265,288,2)
(442,143,2)
(178,405,2)
(106,387,2)
(18,257,2)
(343,9,2)
(280,120,2)
(95,120,2)
(58,38,2)
(169,408,2)
(229,9,2)
(441,265,2)
(223,234,2)
(167,262,2)
(172,447,2)
(105,111,2)
(295,169,2)
(183,120,2)
(382,111,2)
(366,111,2)
(145,211,2)
(291,345,2)
(262,253,2)
(37,27,2)
(100,274,2)
(49,396,2)
(138,274,2)
(157,266,2)
(94,111,2)
(352,339,2)
(319,395,2)
(334,152,2)
(85,308,2)
(231,27,2)
(82,266,2)
(380,169,2)
(339,2,2)
(315,285,2)
(326,272,2)
(349,276,2)
(329,396,2)
(351,407,2)
(7,430,2)
(217,221,2)
(423,120,2)
(8,159,2)
(288,11,2)
(100,111,2)
(226,285,2)
(435,217,2)
(168,133,2)
(342,3,2)
(94,100,2)
(298,143,2)
(377,254,2)
(139,133,2)
(120,111,2)
(74,412,2)
(240,111,2)
(228,376,2)
(392,318,2)
(116,326,2)
(328,133,2)
(113,409,2)
(282,240,2)
(253,97,2)
(67,143,2)
(217,276,2)
(49,308,2)
(390,152,2)
(412,111,2)
(403,308,2)
(99,94,2)
(418,396,2)
(366,61,2)
(162,120,2)
(127,409,2)
(282,367,2)
(279,68,2)
(402,111,2)
(426,344,2)
(118,447,2)
(135,61,2)
(56,285,2)
(262,111,2)
(408,82,2)
(67,306,2)
(15,220,2)
(278,308,2)
(287,40,2)
(435,107,2)
(69,305,2)
(276,334,2)
(244,285,2)
(57,159,2)
(164,319,2)
(397,329,2)
(287,38,2)
(109,61,2)
(133,159,2)
(22,308,2)
(159,211,2)
(73,168,2)
(332,234,2)
(275,111,2)
(372,152,2)
(362,253,2)
(252,308,2)
(218,77,2)
(308,111,2)
(433,265,2)
(393,319,2)
(77,68,2)
(324,409,2)
(243,61,2)
(33,318,2)
(347,220,2)
(28,159,2)
(439,285,2)
(159,9,2)
(269,120,2)
(354,345,2)
(298,111,2)
(98,120,2)
(285,111,2)
(314,9,2)
(330,138,2)
(123,274,2)
(433,181,2)
(15,40,2)
(68,243,2)
(211,61,2)
(261,19,2)
(204,285,2)
(435,33,2)
(252,111,2)
(39,159,2)
(60,54,2)
(53,308,2)
(382,149,2)
(51,265,2)
(38,16,2)
(38,285,2)
(154,209,2)
(329,152,2)
(336,339,2)
(55,211,2)
(203,68,2)
(281,285,2)
(72,276,2)
(2,366,2)
(421,430,2)
(277,38,2)
(321,27,2)
(441,308,2)
(111,102,2)
(45,211,2)
(319,77,2)
(254,159,2)
(48,149,2)
(205,63,2)
(228,68,2)
(126,169,2)
(157,299,2)
(433,69,2)
(316,40,2)
(20,152,2)
(435,265,2)
(209,409,2)
(46,265,2)
(110,274,2)
(431,254,2)
(356,138,2)
(416,211,2)
(256,234,2)
(350,111,2)
(129,143,2)
(54,111,2)
(2,61,2)
(65,326,2)
(142,149,2)
(367,68,2)
(138,253,2)
(302,100,2)
(11,285,2)
(243,111,2)
(107,308,2)
(211,265,2)
(345,211,2)
(88,216,2)
(245,143,2)
(231,74,2)
(384,285,2)
(5,266,2)
(152,381,2)
(319,68,2)
(404,430,2)
(14,396,2)
(333,319,2)
(190,68,2)
(351,252,2)
(404,74,2)
(336,142,2)
(26,285,2)
(417,133,2)
(58,285,2)
(401,308,2)
(250,308,2)
(345,76,2)
(232,285,2)
(260,152,2)
(303,382,2)
(71,133,2)
(358,274,2)
(263,159,2)
(307,111,2)
(433,205,2)
(306,396,2)
(368,276,2)
(1,345,2)
(260,296,2)
(290,111,2)
(184,404,2)
(163,414,2)
(240,319,2)
(140,2,2)
(78,430,2)
(138,111,2)
(261,169,2)
(384,111,2)
(253,274,2)
(229,18,2)
(261,40,2)
(336,149,2)
(66,154,2)
(371,68,2)
(274,319,2)
(176,120,2)
(207,344,2)
(225,74,2)
(299,120,2)
(196,211,2)
(432,308,2)
(272,211,2)
(76,211,2)
(313,155,2)
(185,27,2)
(381,298,2)
(433,107,2)
(117,169,2)
(433,377,2)
(406,308,2)
(9,196,2)
(49,265,2)
(212,120,2)
(256,111,2)
(134,308,2)
(398,244,2)
(276,152,2)
(27,274,2)
(257,396,2)
(435,205,2)
(334,260,2)
(184,430,2)
(89,27,2)
(346,211,2)
(166,188,2)
(339,70,2)
(303,149,2)
(155,234,2)
(165,285,2)
(149,111,2)
(210,167,2)
(359,159,2)
(423,111,2)
(180,285,2)
(397,152,2)
(404,89,2)
(306,265,2)
(200,447,2)
(205,159,2)
(308,326,2)
(0,111,2)
(233,319,2)
(105,68,2)
(411,220,2)
(16,40,2)
(155,256,2)
(435,396,2)
(103,265,2)
(81,120,2)
(396,56,2)
(266,234,2)
(152,143,2)
(172,376,2)
(234,299,2)
(288,285,2)
(213,211,2)
(211,396,2)
(216,2,2)
(365,61,2)
(331,38,2)
(174,111,2)
(376,59,2)
(44,111,2)
(244,44,2)
(187,159,2)
(273,68,2)
(312,143,2)
(19,111,2)
(46,345,2)
(178,120,2)
(435,181,2)
(179,77,2)
(97,138,2)
(307,216,2)
(445,216,2)
(166,159,2)
(30,344,2)
(395,367,2)
(120,61,2)
(282,319,2)
(265,285,2)
(282,333,2)
(193,396,2)
(236,81,2)
(51,159,2)
(228,105,2)
(257,265,2)
(236,120,2)
(264,339,2)
(446,319,2)
(181,308,2)
(42,285,2)
(69,345,2)
(70,111,2)
(409,111,2)
(54,100,2)
(320,447,2)
(441,396,2)
(0,9,2)
(363,2,2)
(124,308,2)
(260,397,2)
(428,61,2)
(316,111,2)
(407,308,2)
(289,27,2)
(7,74,2)
(163,211,2)
(406,111,2)
(350,409,2)
(329,265,2)
(107,53,2)
(103,254,2)
(144,211,2)
(256,299,2)
(51,396,2)
(167,253,2)
(151,120,2)
(149,339,2)
(369,308,2)
(436,285,2)
(434,253,2)
(243,414,2)
(193,265,2)
(247,211,2)
(259,149,2)
(188,418,2)
(301,138,2)
(249,120,2)
(296,152,2)
(391,159,2)
(173,111,2)
(8,111,2)
(193,211,2)
(46,396,2)
(99,100,2)
(367,228,2)
(387,399,2)
(208,120,2)
(105,172,2)
(125,260,2)
(166,402,2)
(157,111,2)
(405,111,2)
(33,237,2)
(274,74,2)
(221,276,2)
(79,61,2)
(418,265,2)
(328,73,2)
(276,211,2)
(414,216,2)
(196,111,2)
(408,266,2)
(338,120,2)
(181,134,2)
(96,211,2)
(174,447,2)
(448,159,2)
(82,157,2)
(97,356,2)
(19,299,2)
(189,318,2)
(351,308,2)
(264,2,2)
(194,120,2)
(58,287,2)
(216,264,2)
(350,299,2)
(437,350,2)
(335,100,2)
(420,211,2)
(202,143,2)
(7,89,2)
(294,68,2)
(398,285,2)
(3,119,2)
(437,409,2)
(90,152,2)
(10,61,2)
(275,40,2)
(44,285,2)
(182,211,2)
(18,9,2)
(70,2,2)
(338,111,2)
(101,120,2)
(226,40,2)
(154,409,2)
(381,67,2)
(64,266,2)
(163,111,2)
(433,396,2)
(235,27,2)
(196,414,2)
(143,211,2)
(443,308,2)
(402,159,2)
(305,345,2)
(210,253,2)
(327,61,2)
(9,211,2)
(292,254,2)
(215,274,2)
(293,120,2)
(395,173,2)
(60,100,2)
(344,319,2)
(16,285,2)
(435,69,2)
(83,339,2)
(122,285,2)
(14,265,2)
(53,237,2)
(229,0,2)
(311,159,2)
(296,111,2)
(238,285,2)
(374,319,2)
(143,163,2)
(61,265,2)
(209,111,2)
(375,9,2)
(396,285,2)
(381,143,2)
(407,406,2)
(424,211,2)
(438,149,2)
(355,152,2)
(142,303,2)
(425,409,2)
(89,225,2)
(326,211,2)
(81,111,2)
(103,396,2)
(73,133,2)
(436,58,2)
(222,308,2)
(234,111,2)
(110,253,2)
(92,285,2)
(130,211,2)
(449,433,2)
(357,100,2)
(395,77,2)
(77,111,2)
(68,61,2)
(41,409,2)
(76,414,2)
(192,216,2)
(272,193,2)
(197,254,2)
(398,226,2)
(75,409,2)
(333,111,2)
(102,40,2)
(66,409,2)
(214,308,2)
(175,159,2)
(152,211,2)
(133,111,2)
(270,308,2)
(304,9,2)
(410,159,2)
(50,120,2)
(323,166,2)
(313,234,2)
(61,396,2)
(75,66,2)
(36,159,2)
(119,111,2)
(274,207,2)
(306,143,2)
(22,111,2)
(188,159,2)
(360,266,2)
(435,318,2)
(254,166,2)
(173,77,2)
-----------------------------------
(0,p->acceptdtmf)
(1,f)
(2,!p->ackcall)
(3,&p->lock)
(4,p)
(5,p)
(6,howlong)
(7,ast_channel_unlock(owner)
(8,p->acknowledged)
(9,!p->acknowledged)
(10,p)
(11,p->chan)
(12,"Local")
(13,chan)
(14,ast_frfree(f)
(15,agent_start_monitoring(ast,0)
(16,ast_channel_fdno(ast)
(17,p)
(18,f->subclass.integer)
(19,p->chan)
(20,integer)
(21,chan)
(22,p->acknowledged)
(23,answer_frame)
(24,)
(25,if (p->chan)
(26,p)
(27,owner)
(28,p)
(29,while (p->chan && ast_channel_trylock(p->chan)
(30,chan)
(31,f)
(32,)
(33,&answer_frame)
(34,if (p->chan && !ast_channel_internal_bridged_channel(p->chan)
(35,case AST_FRAME_VOICE:)
(36,enddtmf)
(37,owner)
(38,ast_channel_fdno(ast)
(39,p->acknowledged = 1)
(40,struct ast_channel *ast)
(41,chan)
(42,chan)
(43,f)
(44,p->chan)
(45,p)
(46,ast_frfree(f)
(47,case AST_FRAME_CONTROL:)
(48,chan)
(49,ast_frfree(f)
(50,AST_DEVICE_UNAVAILABLE)
(51,ast_frfree(f)
(52,howlong)
(53,&answer_frame)
(54,p->chan)
(55,acknowledged)
(56,&ast_null_frame)
(57,f)
(58,(ast_channel_fdno(ast)
(59,time(NULL)
(60,ast_channel_unlock(p->chan)
(61,!f)
(62,cur_time)
(63,&answer_frame)
(64,chan)
(65,p)
(66,ast_channel_name(ast_channel_internal_bridged_channel(p->chan)
(67,f->subclass.integer)
(68,!p->acknowledged)
(69,f = &ast_null_frame)
(70,p->acknowledged)
(71,3)
(72,f)
(73,ast_channel_name(p->chan)
(74,owner = agent_lock_owner(p)
(75,ast_debug(1, "Bridge on \'%s\' being set to \'%s\' (3)
(76,p->acknowledged)
(77,p->autologoff)
(78,owner)
(79,f)
(80,case AST_FRAME_VIDEO:)
(81,p->agent)
(82,ast_channel_tech(p->chan)
(83,p)
(84,)
(85,acknowledged)
(86,start)
(87,if (p->chan)
(88,acknowledged)
(89,owner = ast_channel_unref(owner)
(90,enddtmf)
(91,ast)
(92,p)
(93,)
(94,p->chan)
(95,AST_DEVSTATE_CACHABLE)
(96,break;)
(97,ast_channel_trylock(p->chan)
(98,chan)
(99,ast_softhangup(p->chan, AST_SOFTHANGUP_EXPLICIT)
(100,p->chan)
(101,acknowledged)
(102,ast_channel_tech_pvt(ast)
(103,ast_frfree(f)
(104,)
(105,p->start)
(106,ast_mutex_lock(&p->lock)
(107,f = &answer_frame)
(108,p)
(109,acknowledged)
(110,chan)
(111,*p = ast_channel_tech_pvt(ast)
(112,if (!p->start)
(113,1)
(114,f)
(115,NULL)
(116,ackcall)
(117,chan)
(118,cur_time)
(119,p->lock)
(120,p->chan)
(121,switch (f->frametype)
(122,AST_FLAG_EXCEPTION)
(123,p)
(124,"%s answered, waiting for \'%c\' to acknowledge\\n")
(125,endcall)
(126,p)
(127,p)
(128,case AST_FRAME_DTMF_END:)
(129,p)
(130,break;)
(131,3)
(132,case AST_FRAME_DTMF_BEGIN:)
(133,p->chan)
(134,&ast_null_frame)
(135,p)
(136,ast)
(137,)
(138,p->chan)
(139,p)
(140,p)
(141,if (owner)
(142,ast_channel_state(p->chan)
(143,!p->acknowledged)
(144,subclass)
(145,integer)
(146,owner)
(147,)
(148,if (p->chan)
(149,p->chan)
(150,ast)
(151,"Agent/%s")
(152,!p->acknowledged && f->subclass.integer == p->acceptdtmf)
(153,if (owner)
(154,ast_channel_internal_bridged_channel(p->chan)
(155,ast_channel_internal_bridged_channel(p->chan)
(156,if (recordagentcalls && f == &answer_frame)
(157,p->chan)
(158,if (!p->ackcall && !p->acknowledged && p->chan && (ast_channel_state(p->chan)
(159,!p->acknowledged && (f->subclass.integer == p->acceptdtmf)
(160,)
(161,default:)
(162,p)
(163,p->acknowledged)
(164,name)
(165,AST_AGENT_FD)
(166,f->subclass.integer == p->enddtmf)
(167,&p->lock)
(168,p->chan)
(169,strcasecmp(ast_channel_tech(p->chan)
(170,if (owner || p->chan)
(171,p)
(172,p->start = cur_time)
(173,p->autologoff)
(174,p->start)
(175,1)
(176,NULL)
(177,)
(178,ast_channel_internal_bridged_channel_set(p->chan, NULL)
(179,p)
(180,ast_null_frame)
(181,f = &ast_null_frame)
(182,p)
(183,NULL)
(184,owner = ast_channel_unref(owner)
(185,owner)
(186,if (!p->acknowledged && (f->subclass.integer == p->acceptdtmf)
(187,f)
(188,f->subclass.integer)
(189,answer_frame)
(190,p)
(191,p)
(192,p)
(193,f->subclass)
(194,0)
(195,)
(196,p->acknowledged)
(197,f)
(198,*f = NULL)
(199,p)
(200,p)
(201,p)
(202,acceptdtmf)
(203,p)
(204,ast)
(205,f = &answer_frame)
(206,if (p->ackcall)
(207,p->chan)
(208,agent)
(209,p->chan)
(210,DEADLOCK_AVOIDANCE(&p->lock)
(211,f->frametype)
(212,chan)
(213,acknowledged)
(214,p->acknowledged = 1)
(215,chan)
(216,!p->ackcall && !p->acknowledged && p->chan && (ast_channel_state(p->chan)
(217,f = &ast_null_frame)
(218,autologoff)
(219,AST_CONTROL_ANSWER)
(220,recordagentcalls && f == &answer_frame)
(221,&ast_null_frame)
(222,p)
(223,p)
(224,acceptdtmf)
(225,ast_channel_unref(owner)
(226,ast_channel_flags(ast)
(227,if (p->chan)
(228,cur_time - p->start)
(229,f->subclass.integer == p->acceptdtmf)
(230,f)
(231,ast_channel_unlock(owner)
(232,chan)
(233,howlong)
(234,p->chan)
(235,owner)
(236,ast_devstate_changed(AST_DEVICE_UNAVAILABLE, AST_DEVSTATE_CACHABLE, "Agent/%s", p->agent)
(237,answer_frame = { AST_FRAME_CONTROL, { AST_CONTROL_ANSWER } })
(238,p)
(239,)
(240,p->name)
(241,lock)
(242,p)
(243,p->acknowledged)
(244,ast_channel_flags(p->chan)
(245,f)
(246,)
(247,f)
(248,)
(249,p)
(250,chan)
(251,ast)
(252,p->acceptdtmf)
(253,p->chan && ast_channel_trylock(p->chan)
(254,f->subclass.integer == p->enddtmf && endcall)
(255,p)
(256,p->chan)
(257,f->subclass)
(258,f)
(259,AST_STATE_UP)
(260,f->subclass.integer == p->enddtmf)
(261,ast_channel_internal_bridged_channel_set(p->chan, ast)
(262,p->lock)
(263,f)
(264,!p->acknowledged && p->chan && (ast_channel_state(p->chan)
(265,f = ast_read(p->chan)
(266,p->chan && !ast_channel_internal_bridged_channel(p->chan)
(267,)
(268,cur_time)
(269,p)
(270,ast_null_frame)
(271,)
(272,f->subclass.integer)
(273,autologoff)
(274,owner || p->chan)
(275,CLEANUP(ast,p)
(276,(!p->acknowledged && f->subclass.integer == p->acceptdtmf)
(277,AST_TIMING_FD)
(278,f)
(279,start)
(280,p)
(281,f)
(282,ast_log(LOG_NOTICE, "Agent \'%s\' didn\'t answer/confirm within %d seconds (waited %d)
(283,frametype)
(284,)
(285,p->chan)
(286,)
(287,ast_channel_fdno(ast)
(288,ast_read(p->chan)
(289,AST_SOFTHANGUP_EXPLICIT)
(290,p->start)
(291,f)
(292,NULL)
(293,p->acknowledged = 0)
(294,howlong)
(295,chan)
(296,p->enddtmf)
(297,p)
(298,p->acceptdtmf)
(299,p->chan = NULL)
(300,p)
(301,p)
(302,AST_SOFTHANGUP_EXPLICIT)
(303,ast_channel_state(p->chan)
(304,integer)
(305,&ast_null_frame)
(306,f->subclass)
(307,p->acknowledged)
(308,p->ackcall)
(309,)
(310,if (!p->acknowledged)
(311,integer)
(312,subclass)
(313,!ast_channel_internal_bridged_channel(p->chan)
(314,subclass)
(315,ast)
(316,CHECK_FORMATS(ast, p)
(317,)
(318,recordagentcalls)
(319,p->autologoff && (howlong >= p->autologoff)
(320,start)
(321,ast_softhangup(owner, AST_SOFTHANGUP_EXPLICIT)
(322,"%s acknowledged\\n")
(323,endcall)
(324,"Bridge on \'%s\' being set to \'%s\' (3)
(325,p)
(326,f->subclass.integer == AST_CONTROL_ANSWER)
(327,p)
(328,ast_verb(3, "%s acknowledged\\n", ast_channel_name(p->chan)
(329,f->subclass)
(330,chan)
(331,ast)
(332,chan)
(333,p->autologoff)
(334,f->subclass.integer == p->enddtmf && endcall)
(335,chan)
(336,p->chan && (ast_channel_state(p->chan)
(337,)
(338,p->chan)
(339,!p->acknowledged)
(340,chan)
(341,if (p->chan)
(342,ast_mutex_unlock(&p->lock)
(343,f)
(344,owner)
(345,!p->acknowledged)
(346,break;)
(347,0)
(348,f)
(349,f)
(350,p->chan)
(351,ast_verb(3, "%s answered, waiting for \'%c\' to acknowledge\\n", ast_channel_name(p->chan)
(352,chan)
(353,owner)
(354,ast_null_frame)
(355,f)
(356,p->chan)
(357,p)
(358,p)
(359,acknowledged)
(360,type)
(361,if((!p->acknowledged && f->subclass.integer == p->acceptdtmf)
(362,p)
(363,acknowledged)
(364,owner)
(365,chan)
(366,p->ackcall)
(367,howlong = cur_time - p->start)
(368,ast_null_frame)
(369,acceptdtmf)
(370,owner)
(371,cur_time)
(372,p)
(373,if (!f)
(374,LOG_NOTICE)
(375,p)
(376,cur_time = time(NULL)
(377,f = NULL)
(378,answer_frame)
(379,NULL)
(380,p)
(381,f->subclass.integer == p->acceptdtmf)
(382,p->chan)
(383,if (p->autologoff && (howlong >= p->autologoff)
(384,p->chan)
(385,if (!p->acknowledged)
(386,if (f->subclass.integer == AST_CONTROL_ANSWER)
(387,&p->lock)
(388,)
(389,chan)
(390,subclass)
(391,subclass)
(392,f)
(393,autologoff)
(394,)
(395,howlong >= p->autologoff)
(396,f = &ast_null_frame)
(397,f->subclass.integer)
(398,ast_copy_flags(ast_channel_flags(p->chan)
(399,p->lock)
(400,)
(401,answer_frame)
(402,p->enddtmf)
(403,1)
(404,ast_channel_unref(owner)
(405,p->chan)
(406,p->chan)
(407,ast_channel_name(p->chan)
(408,ast_channel_tech(p->chan)
(409,p->chan)
(410,p)
(411,ast)
(412,agent_lock_owner(p)
(413,p)
(414,p->acknowledged = 1)
(415,p)
(416,break;)
(417,chan)
(418,f->subclass)
(419,lock)
(420,p)
(421,owner)
(422,if (strcasecmp(ast_channel_tech(p->chan)
(423,p->acknowledged)
(424,acknowledged)
(425,p)
(426,p)
(427,f)
(428,ackcall)
(429,answer_frame)
(430,owner)
(431,f)
(432,p)
(433,return f;)
(434,lock)
(435,f == &answer_frame)
(436,ast_channel_fdno_set(p->chan, (ast_channel_fdno(ast)
(437,ast_channel_name(p->chan)
(438,p)
(439,chan)
(440,)
(441,ast_frfree(f)
(442,integer)
(443,f)
(444,)
(445,1)
(446,"Agent \'%s\' didn\'t answer/confirm within %d seconds (waited %d)
(447,!p->start)
(448,chan)
(449,RET)
(450,p)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^