-----label-----
1
-----code-----
static struct conn *
conn_not_found(struct conntrack *ct, struct dp_packet *pkt,
               struct conn_lookup_ctx *ctx, bool commit, long long now,
               const struct nat_action_info_t *nat_action_info,
               struct conn *conn_for_un_nat_copy,
               const char *helper,
               const struct alg_exp_node *alg_exp)
{
    unsigned bucket = hash_to_bucket(ctx->hash);
    struct conn *nc = NULL;

    if (!valid_new(pkt, &ctx->key)) {
        pkt->md.ct_state = CS_INVALID;
        return nc;
    }
    pkt->md.ct_state = CS_NEW;
    if (alg_exp) {
        pkt->md.ct_state |= CS_RELATED;
    }

    if (commit) {
        unsigned int n_conn_limit;

        atomic_read_relaxed(&ct->n_conn_limit, &n_conn_limit);

        if (atomic_count_get(&ct->n_conn) >= n_conn_limit) {
            COVERAGE_INC(conntrack_full);
            return nc;
        }

        nc = new_conn(&ct->buckets[bucket], pkt, &ctx->key, now);
        ctx->conn = nc;
        nc->rev_key = nc->key;
        conn_key_reverse(&nc->rev_key);

        if (helper) {
            nc->alg = xstrdup(helper);
        }

        if (alg_exp) {
            nc->alg_related = true;
            nc->mark = alg_exp->master_mark;
            nc->label = alg_exp->master_label;
            nc->master_key = alg_exp->master_key;
        }

        if (nat_action_info) {
            nc->nat_info = xmemdup(nat_action_info, sizeof *nc->nat_info);

            if (alg_exp) {
                if (alg_exp->passive_mode) {
                    nc->rev_key.dst.addr = alg_exp->alg_nat_repl_addr;
                    nc->nat_info->nat_action = NAT_ACTION_SRC;
                } else {
                    nc->rev_key.src.addr = alg_exp->alg_nat_repl_addr;
                    nc->nat_info->nat_action = NAT_ACTION_DST;
                }
                *conn_for_un_nat_copy = *nc;
            } else {
                *conn_for_un_nat_copy = *nc;
                ct_rwlock_wrlock(&ct->resources_lock);
                bool nat_res = nat_select_range_tuple(
                                   ct, nc, conn_for_un_nat_copy);

                if (!nat_res) {
                    goto nat_res_exhaustion;
                }

                /* Update nc with nat adjustments made to
                 * conn_for_un_nat_copy by nat_select_range_tuple(). */
                *nc = *conn_for_un_nat_copy;
                ct_rwlock_unlock(&ct->resources_lock);
            }
            conn_for_un_nat_copy->conn_type = CT_CONN_TYPE_UN_NAT;
            conn_for_un_nat_copy->nat_info = NULL;
            conn_for_un_nat_copy->alg = NULL;
            nat_packet(pkt, nc, ctx->icmp_related);
        }
        hmap_insert(&ct->buckets[bucket].connections, &nc->node, ctx->hash);
        atomic_count_inc(&ct->n_conn);
    }

    return nc;

    /* This would be a user error or a DOS attack.
     * A user error is prevented by allocating enough
     * combinations of NAT addresses when combined with
     * ephemeral ports.  A DOS attack should be protected
     * against with firewall rules or a separate firewall.
     * Also using zone partitioning can limit DoS impact. */
nat_res_exhaustion:
    ovs_list_remove(&nc->exp_node);
    delete_conn(nc);
    /* conn_for_un_nat_copy is a local variable in process_one; this
     * memset() serves to document that conn_for_un_nat_copy is from
     * this point on unused. */
    memset(conn_for_un_nat_copy, 0, sizeof *conn_for_un_nat_copy);
    ct_rwlock_unlock(&ct->resources_lock);
    static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 5);
    VLOG_WARN_RL(&rl, "Unable to NAT due to tuple space exhaustion - "
                 "if DoS attack, use firewalling and/or zone partitioning.");
    return NULL;
}
-----children-----
1,2
1,3
1,4
2,3
4,5
4,6
4,7
4,8
4,9
4,10
4,11
4,12
4,13
4,14
4,15
7,8
7,9
8,9
10,11
10,12
13,14
13,15
14,15
16,17
16,18
19,20
19,21
20,21
22,23
22,24
25,26
25,27
27,28
29,30
29,31
31,32
33,34
33,35
34,35
36,37
36,38
39,40
39,41
40,41
42,43
42,44
45,46
45,47
47,48
47,49
50,51
50,52
51,52
53,54
53,55
56,57
56,58
56,59
56,60
56,61
56,62
56,63
56,64
56,65
56,66
56,67
56,68
56,69
56,70
57,58
58,59
58,60
60,61
60,62
62,63
63,64
63,65
64,65
66,67
66,68
67,68
70,71
71,72
71,73
72,73
74,75
74,76
74,77
77,78
78,79
80,81
80,82
81,82
82,83
82,84
82,85
83,84
85,86
87,88
88,89
88,90
89,90
92,93
92,94
93,94
94,95
94,96
95,96
95,97
96,97
96,98
97,98
101,102
103,104
104,105
106,107
107,108
107,109
108,109
108,110
109,110
109,111
110,111
114,115
116,117
116,118
117,118
119,120
120,121
121,122
121,123
122,123
122,124
123,124
123,125
124,125
128,129
130,131
130,132
131,132
133,134
133,135
133,136
133,137
133,138
133,139
133,140
133,141
133,142
133,143
133,144
133,145
134,135
135,136
135,137
137,138
139,140
140,141
140,142
140,143
141,142
143,144
144,145
144,146
145,146
148,149
149,150
151,152
151,153
152,153
152,154
153,154
153,155
154,155
156,157
157,158
157,159
158,159
161,162
163,164
163,165
164,165
165,166
165,167
166,167
168,169
169,170
171,172
172,173
174,175
175,176
175,177
176,177
178,179
178,180
178,181
178,182
178,183
179,180
181,182
182,183
182,184
183,184
183,185
184,185
187,188
189,190
191,192
192,193
192,194
193,194
196,197
198,199
199,200
199,201
200,201
200,202
201,202
204,205
206,207
207,208
207,209
208,209
208,210
209,210
212,213
212,214
213,214
216,217
217,218
217,219
218,219
220,221
221,222
221,223
222,223
225,226
225,227
226,227
228,229
229,230
230,231
230,232
231,232
231,233
232,233
235,236
235,237
236,237
238,239
240,241
240,242
241,242
243,244
243,245
243,246
243,247
244,245
245,246
245,247
246,247
246,248
247,248
251,252
252,253
252,254
253,254
253,255
254,255
257,258
257,259
258,259
261,262
262,263
262,264
263,264
263,265
264,265
267,268
267,269
268,269
271,272
272,273
272,274
273,274
273,275
274,275
277,278
277,279
278,279
281,282
281,283
282,283
284,285
284,286
284,287
284,288
284,289
284,290
285,286
286,287
286,288
287,288
287,289
288,289
291,292
291,293
291,294
292,293
294,295
296,297
297,298
298,299
298,300
299,300
302,303
302,304
302,305
303,304
305,306
305,307
306,307
306,308
306,309
307,308
307,309
308,309
311,312
311,313
312,313
313,314
313,315
314,315
314,316
315,316
315,317
316,317
316,318
317,318
322,323
322,324
323,324
326,327
327,328
327,329
328,329
328,330
329,330
329,331
330,331
334,335
336,337
336,338
337,338
338,339
338,340
339,340
339,341
340,341
340,342
341,342
341,343
342,343
347,348
347,349
348,349
351,352
352,353
352,354
353,354
353,355
354,355
354,356
355,356
359,360
361,362
362,363
362,364
363,364
364,365
366,367
367,368
369,370
369,371
369,372
369,373
369,374
369,375
370,371
371,372
371,373
372,373
373,374
375,376
376,377
378,379
379,380
379,381
380,381
382,383
383,384
383,385
384,385
387,388
388,389
388,390
390,391
390,392
392,393
393,394
393,395
393,396
393,397
394,395
396,397
398,399
400,401
402,403
402,404
403,404
404,405
406,407
407,408
409,410
410,411
410,412
411,412
412,413
414,415
415,416
417,418
418,419
418,420
419,420
421,422
422,423
422,424
423,424
426,427
427,428
427,429
428,429
428,430
429,430
432,433
434,435
435,436
435,437
436,437
436,438
437,438
440,441
442,443
443,444
443,445
444,445
444,446
445,446
448,449
450,451
451,452
451,453
451,454
451,455
452,453
454,455
456,457
458,459
458,460
459,460
462,463
463,464
463,465
463,466
463,467
464,465
466,467
467,468
467,469
468,469
468,470
469,470
469,471
470,471
473,474
476,477
477,478
477,479
478,479
481,482
481,483
482,483
485,486
486,487
486,488
487,488
489,490
490,491
490,492
491,492
494,495
495,496
497,498
497,499
499,500
500,501
500,502
501,502
503,504
504,505
504,506
505,506
508,509
509,510
509,511
510,511
512,513
514,515
515,516
515,517
515,518
515,519
516,517
518,519
521,522
522,523
523,524
525,526
526,527
526,528
527,528
529,530
530,531
530,532
531,532
534,535
535,536
535,537
536,537
538,539
538,540
540,541
541,542
541,543
541,544
542,543
546,547
547,548
547,549
547,550
548,549
550,551
551,552
554,555
555,556
-----nextToken-----
3,5,6,9,11,12,15,17,18,21,23,24,26,28,30,32,35,37,38,41,43,44,46,48,49,52,54,55,59,61,65,68,69,73,75,76,79,84,86,90,91,98,99,100,102,105,111,112,113,115,118,125,126,127,129,132,136,138,142,146,147,150,155,159,160,162,167,170,173,177,180,185,186,188,190,194,195,197,202,203,205,210,211,214,215,219,223,224,227,233,234,237,239,242,248,249,250,255,256,259,260,265,266,269,270,275,276,279,280,283,289,290,293,295,300,301,304,309,310,318,319,320,321,324,325,331,332,333,335,343,344,345,346,349,350,356,357,358,360,365,368,374,377,381,385,386,389,391,395,397,399,401,405,408,413,416,420,424,425,430,431,433,438,439,441,446,447,449,453,455,457,460,461,465,471,472,474,475,479,480,483,484,488,492,493,496,498,502,506,507,511,513,517,519,520,524,528,532,533,537,539,543,544,545,549,552,553,556
-----computeFrom-----
94,95
94,96
107,108
107,109
121,122
121,123
152,153
152,154
175,176
175,177
199,200
199,201
207,208
207,209
230,231
230,232
245,246
245,247
252,253
252,254
262,263
262,264
272,273
272,274
286,287
286,288
313,314
313,315
327,328
327,329
338,339
338,340
352,353
352,354
362,363
362,364
371,372
371,373
410,411
410,412
427,428
427,429
435,436
435,437
443,444
443,445
-----guardedBy-----
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;ElaboratedTypeSpecifier;Name;FunctionDeclarator;Pointer;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ReturnStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ReturnStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;IdExpression;Name;CompoundStatement;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;GotoStatement;Name;ExpressionStatement;BinaryExpression;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ReturnStatement;IdExpression;Name;LabelStatement;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;ReturnStatement;IdExpression;Name;
-----ast_node-----
static struct conn *conn_not_found(struct conntrack *ct, struct dp_packet *pkt,               struct conn_lookup_ctx *ctx, bool commit, long long now,               const struct nat_action_info_t *nat_action_info,               struct conn *conn_for_un_nat_copy,               const char *helper,               const struct alg_exp_node *alg_exp){    unsigned bucket = hash_to_bucket(ctx->hash);    struct conn *nc = NULL;    if (!valid_new(pkt, &ctx->key)) {        pkt->md.ct_state = CS_INVALID;        return nc;    }    pkt->md.ct_state = CS_NEW;    if (alg_exp) {        pkt->md.ct_state |= CS_RELATED;    }    if (commit) {        unsigned int n_conn_limit;        atomic_read_relaxed(&ct->n_conn_limit, &n_conn_limit);        if (atomic_count_get(&ct->n_conn) >= n_conn_limit) {            COVERAGE_INC(conntrack_full);            return nc;        }        nc = new_conn(&ct->buckets[bucket], pkt, &ctx->key, now);        ctx->conn = nc;        nc->rev_key = nc->key;        conn_key_reverse(&nc->rev_key);        if (helper) {            nc->alg = xstrdup(helper);        }        if (alg_exp) {            nc->alg_related = true;            nc->mark = alg_exp->master_mark;            nc->label = alg_exp->master_label;            nc->master_key = alg_exp->master_key;        }        if (nat_action_info) {            nc->nat_info = xmemdup(nat_action_info, sizeof *nc->nat_info);            if (alg_exp) {                if (alg_exp->passive_mode) {                    nc->rev_key.dst.addr = alg_exp->alg_nat_repl_addr;                    nc->nat_info->nat_action = NAT_ACTION_SRC;                } else {                    nc->rev_key.src.addr = alg_exp->alg_nat_repl_addr;                    nc->nat_info->nat_action = NAT_ACTION_DST;                }                *conn_for_un_nat_copy = *nc;            } else {                *conn_for_un_nat_copy = *nc;                ct_rwlock_wrlock(&ct->resources_lock);                bool nat_res = nat_select_range_tuple(                                   ct, nc, conn_for_un_nat_copy);                if (!nat_res) {                    goto nat_res_exhaustion;                }                /* Update nc with nat adjustments made to                 * conn_for_un_nat_copy by nat_select_range_tuple(). */                *nc = *conn_for_un_nat_copy;                ct_rwlock_unlock(&ct->resources_lock);            }            conn_for_un_nat_copy->conn_type = CT_CONN_TYPE_UN_NAT;            conn_for_un_nat_copy->nat_info = NULL;            conn_for_un_nat_copy->alg = NULL;            nat_packet(pkt, nc, ctx->icmp_related);        }        hmap_insert(&ct->buckets[bucket].connections, &nc->node, ctx->hash);        atomic_count_inc(&ct->n_conn);    }    return nc;    /* This would be a user error or a DOS attack.     * A user error is prevented by allocating enough     * combinations of NAT addresses when combined with     * ephemeral ports.  A DOS attack should be protected     * against with firewall rules or a separate firewall.     * Also using zone partitioning can limit DoS impact. */nat_res_exhaustion:    ovs_list_remove(&nc->exp_node);    delete_conn(nc);    /* conn_for_un_nat_copy is a local variable in process_one; this     * memset() serves to document that conn_for_un_nat_copy is from     * this point on unused. */    memset(conn_for_un_nat_copy, 0, sizeof *conn_for_un_nat_copy);    ct_rwlock_unlock(&ct->resources_lock);    static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 5);    VLOG_WARN_RL(&rl, "Unable to NAT due to tuple space exhaustion - "                 "if DoS attack, use firewalling and/or zone partitioning.");    return NULL;}
static struct conn
conn
*conn_not_found(struct conntrack *ct, struct dp_packet *pkt,               struct conn_lookup_ctx *ctx, bool commit, long long now,               const struct nat_action_info_t *nat_action_info,               struct conn *conn_for_un_nat_copy,               const char *helper,               const struct alg_exp_node *alg_exp)
*
conn_not_found
struct conntrack *ct
struct conntrack
conntrack
*ct
*
ct
struct dp_packet *pkt
struct dp_packet
dp_packet
*pkt
*
pkt
struct conn_lookup_ctx *ctx
struct conn_lookup_ctx
conn_lookup_ctx
*ctx
*
ctx
bool commit
bool
commit
commit
long long now
long long
now
now
const struct nat_action_info_t *nat_action_info
const struct nat_action_info_t
nat_action_info_t
*nat_action_info
*
nat_action_info
struct conn *conn_for_un_nat_copy
struct conn
conn
*conn_for_un_nat_copy
*
conn_for_un_nat_copy
const char *helper
const char
*helper
*
helper
const struct alg_exp_node *alg_exp
const struct alg_exp_node
alg_exp_node
*alg_exp
*
alg_exp
{    unsigned bucket = hash_to_bucket(ctx->hash);    struct conn *nc = NULL;    if (!valid_new(pkt, &ctx->key)) {        pkt->md.ct_state = CS_INVALID;        return nc;    }    pkt->md.ct_state = CS_NEW;    if (alg_exp) {        pkt->md.ct_state |= CS_RELATED;    }    if (commit) {        unsigned int n_conn_limit;        atomic_read_relaxed(&ct->n_conn_limit, &n_conn_limit);        if (atomic_count_get(&ct->n_conn) >= n_conn_limit) {            COVERAGE_INC(conntrack_full);            return nc;        }        nc = new_conn(&ct->buckets[bucket], pkt, &ctx->key, now);        ctx->conn = nc;        nc->rev_key = nc->key;        conn_key_reverse(&nc->rev_key);        if (helper) {            nc->alg = xstrdup(helper);        }        if (alg_exp) {            nc->alg_related = true;            nc->mark = alg_exp->master_mark;            nc->label = alg_exp->master_label;            nc->master_key = alg_exp->master_key;        }        if (nat_action_info) {            nc->nat_info = xmemdup(nat_action_info, sizeof *nc->nat_info);            if (alg_exp) {                if (alg_exp->passive_mode) {                    nc->rev_key.dst.addr = alg_exp->alg_nat_repl_addr;                    nc->nat_info->nat_action = NAT_ACTION_SRC;                } else {                    nc->rev_key.src.addr = alg_exp->alg_nat_repl_addr;                    nc->nat_info->nat_action = NAT_ACTION_DST;                }                *conn_for_un_nat_copy = *nc;            } else {                *conn_for_un_nat_copy = *nc;                ct_rwlock_wrlock(&ct->resources_lock);                bool nat_res = nat_select_range_tuple(                                   ct, nc, conn_for_un_nat_copy);                if (!nat_res) {                    goto nat_res_exhaustion;                }                /* Update nc with nat adjustments made to                 * conn_for_un_nat_copy by nat_select_range_tuple(). */                *nc = *conn_for_un_nat_copy;                ct_rwlock_unlock(&ct->resources_lock);            }            conn_for_un_nat_copy->conn_type = CT_CONN_TYPE_UN_NAT;            conn_for_un_nat_copy->nat_info = NULL;            conn_for_un_nat_copy->alg = NULL;            nat_packet(pkt, nc, ctx->icmp_related);        }        hmap_insert(&ct->buckets[bucket].connections, &nc->node, ctx->hash);        atomic_count_inc(&ct->n_conn);    }    return nc;    /* This would be a user error or a DOS attack.     * A user error is prevented by allocating enough     * combinations of NAT addresses when combined with     * ephemeral ports.  A DOS attack should be protected     * against with firewall rules or a separate firewall.     * Also using zone partitioning can limit DoS impact. */nat_res_exhaustion:    ovs_list_remove(&nc->exp_node);    delete_conn(nc);    /* conn_for_un_nat_copy is a local variable in process_one; this     * memset() serves to document that conn_for_un_nat_copy is from     * this point on unused. */    memset(conn_for_un_nat_copy, 0, sizeof *conn_for_un_nat_copy);    ct_rwlock_unlock(&ct->resources_lock);    static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 5);    VLOG_WARN_RL(&rl, "Unable to NAT due to tuple space exhaustion - "                 "if DoS attack, use firewalling and/or zone partitioning.");    return NULL;}
unsigned bucket = hash_to_bucket(ctx->hash);
unsigned bucket = hash_to_bucket(ctx->hash);
unsigned
bucket = hash_to_bucket(ctx->hash)
bucket
= hash_to_bucket(ctx->hash)
hash_to_bucket(ctx->hash)
hash_to_bucket
hash_to_bucket
ctx->hash
ctx
ctx
hash
struct conn *nc = NULL;
struct conn *nc = NULL;
struct conn
conn
*nc = NULL
*
nc
= NULL
NULL
NULL
if (!valid_new(pkt, &ctx->key)) {        pkt->md.ct_state = CS_INVALID;        return nc;    }
!valid_new(pkt, &ctx->key)
valid_new(pkt, &ctx->key)
valid_new
valid_new
pkt
pkt
&ctx->key
ctx->key
ctx
ctx
key
{        pkt->md.ct_state = CS_INVALID;        return nc;    }
pkt->md.ct_state = CS_INVALID;
pkt->md.ct_state = CS_INVALID
pkt->md.ct_state
pkt->md
pkt
pkt
md
ct_state
CS_INVALID
CS_INVALID
return nc;
nc
nc
pkt->md.ct_state = CS_NEW;
pkt->md.ct_state = CS_NEW
pkt->md.ct_state
pkt->md
pkt
pkt
md
ct_state
CS_NEW
CS_NEW
if (alg_exp) {        pkt->md.ct_state |= CS_RELATED;    }
alg_exp
alg_exp
{        pkt->md.ct_state |= CS_RELATED;    }
pkt->md.ct_state |= CS_RELATED;
pkt->md.ct_state |= CS_RELATED
pkt->md.ct_state
pkt->md
pkt
pkt
md
ct_state
CS_RELATED
CS_RELATED
if (commit) {        unsigned int n_conn_limit;        atomic_read_relaxed(&ct->n_conn_limit, &n_conn_limit);        if (atomic_count_get(&ct->n_conn) >= n_conn_limit) {            COVERAGE_INC(conntrack_full);            return nc;        }        nc = new_conn(&ct->buckets[bucket], pkt, &ctx->key, now);        ctx->conn = nc;        nc->rev_key = nc->key;        conn_key_reverse(&nc->rev_key);        if (helper) {            nc->alg = xstrdup(helper);        }        if (alg_exp) {            nc->alg_related = true;            nc->mark = alg_exp->master_mark;            nc->label = alg_exp->master_label;            nc->master_key = alg_exp->master_key;        }        if (nat_action_info) {            nc->nat_info = xmemdup(nat_action_info, sizeof *nc->nat_info);            if (alg_exp) {                if (alg_exp->passive_mode) {                    nc->rev_key.dst.addr = alg_exp->alg_nat_repl_addr;                    nc->nat_info->nat_action = NAT_ACTION_SRC;                } else {                    nc->rev_key.src.addr = alg_exp->alg_nat_repl_addr;                    nc->nat_info->nat_action = NAT_ACTION_DST;                }                *conn_for_un_nat_copy = *nc;            } else {                *conn_for_un_nat_copy = *nc;                ct_rwlock_wrlock(&ct->resources_lock);                bool nat_res = nat_select_range_tuple(                                   ct, nc, conn_for_un_nat_copy);                if (!nat_res) {                    goto nat_res_exhaustion;                }                /* Update nc with nat adjustments made to                 * conn_for_un_nat_copy by nat_select_range_tuple(). */                *nc = *conn_for_un_nat_copy;                ct_rwlock_unlock(&ct->resources_lock);            }            conn_for_un_nat_copy->conn_type = CT_CONN_TYPE_UN_NAT;            conn_for_un_nat_copy->nat_info = NULL;            conn_for_un_nat_copy->alg = NULL;            nat_packet(pkt, nc, ctx->icmp_related);        }        hmap_insert(&ct->buckets[bucket].connections, &nc->node, ctx->hash);        atomic_count_inc(&ct->n_conn);    }
commit
commit
{        unsigned int n_conn_limit;        atomic_read_relaxed(&ct->n_conn_limit, &n_conn_limit);        if (atomic_count_get(&ct->n_conn) >= n_conn_limit) {            COVERAGE_INC(conntrack_full);            return nc;        }        nc = new_conn(&ct->buckets[bucket], pkt, &ctx->key, now);        ctx->conn = nc;        nc->rev_key = nc->key;        conn_key_reverse(&nc->rev_key);        if (helper) {            nc->alg = xstrdup(helper);        }        if (alg_exp) {            nc->alg_related = true;            nc->mark = alg_exp->master_mark;            nc->label = alg_exp->master_label;            nc->master_key = alg_exp->master_key;        }        if (nat_action_info) {            nc->nat_info = xmemdup(nat_action_info, sizeof *nc->nat_info);            if (alg_exp) {                if (alg_exp->passive_mode) {                    nc->rev_key.dst.addr = alg_exp->alg_nat_repl_addr;                    nc->nat_info->nat_action = NAT_ACTION_SRC;                } else {                    nc->rev_key.src.addr = alg_exp->alg_nat_repl_addr;                    nc->nat_info->nat_action = NAT_ACTION_DST;                }                *conn_for_un_nat_copy = *nc;            } else {                *conn_for_un_nat_copy = *nc;                ct_rwlock_wrlock(&ct->resources_lock);                bool nat_res = nat_select_range_tuple(                                   ct, nc, conn_for_un_nat_copy);                if (!nat_res) {                    goto nat_res_exhaustion;                }                /* Update nc with nat adjustments made to                 * conn_for_un_nat_copy by nat_select_range_tuple(). */                *nc = *conn_for_un_nat_copy;                ct_rwlock_unlock(&ct->resources_lock);            }            conn_for_un_nat_copy->conn_type = CT_CONN_TYPE_UN_NAT;            conn_for_un_nat_copy->nat_info = NULL;            conn_for_un_nat_copy->alg = NULL;            nat_packet(pkt, nc, ctx->icmp_related);        }        hmap_insert(&ct->buckets[bucket].connections, &nc->node, ctx->hash);        atomic_count_inc(&ct->n_conn);    }
unsigned int n_conn_limit;
unsigned int n_conn_limit;
unsigned int
n_conn_limit
n_conn_limit
atomic_read_relaxed(&ct->n_conn_limit, &n_conn_limit);
atomic_read_relaxed(&ct->n_conn_limit, &n_conn_limit)
atomic_read_relaxed
atomic_read_relaxed
&ct->n_conn_limit
ct->n_conn_limit
ct
ct
n_conn_limit
&n_conn_limit
n_conn_limit
n_conn_limit
if (atomic_count_get(&ct->n_conn) >= n_conn_limit) {            COVERAGE_INC(conntrack_full);            return nc;        }
atomic_count_get(&ct->n_conn) >= n_conn_limit
atomic_count_get(&ct->n_conn)
atomic_count_get
atomic_count_get
&ct->n_conn
ct->n_conn
ct
ct
n_conn
n_conn_limit
n_conn_limit
{            COVERAGE_INC(conntrack_full);            return nc;        }
COVERAGE_INC(conntrack_full);
COVERAGE_INC(conntrack_full);
COVERAGE_INC
COVERAGE_INC
(conntrack_full)
conntrack_full
conntrack_full
return nc;
nc
nc
nc = new_conn(&ct->buckets[bucket], pkt, &ctx->key, now);
nc = new_conn(&ct->buckets[bucket], pkt, &ctx->key, now)
nc
nc
new_conn(&ct->buckets[bucket], pkt, &ctx->key, now)
new_conn
new_conn
&ct->buckets[bucket]
ct->buckets[bucket]
ct->buckets
ct
ct
buckets
bucket
bucket
pkt
pkt
&ctx->key
ctx->key
ctx
ctx
key
now
now
ctx->conn = nc;
ctx->conn = nc
ctx->conn
ctx
ctx
conn
nc
nc
nc->rev_key = nc->key;
nc->rev_key = nc->key
nc->rev_key
nc
nc
rev_key
nc->key
nc
nc
key
conn_key_reverse(&nc->rev_key);
conn_key_reverse(&nc->rev_key)
conn_key_reverse
conn_key_reverse
&nc->rev_key
nc->rev_key
nc
nc
rev_key
if (helper) {            nc->alg = xstrdup(helper);        }
helper
helper
{            nc->alg = xstrdup(helper);        }
nc->alg = xstrdup(helper);
nc->alg = xstrdup(helper)
nc->alg
nc
nc
alg
xstrdup(helper)
xstrdup
xstrdup
helper
helper
if (alg_exp) {            nc->alg_related = true;            nc->mark = alg_exp->master_mark;            nc->label = alg_exp->master_label;            nc->master_key = alg_exp->master_key;        }
alg_exp
alg_exp
{            nc->alg_related = true;            nc->mark = alg_exp->master_mark;            nc->label = alg_exp->master_label;            nc->master_key = alg_exp->master_key;        }
nc->alg_related = true;
nc->alg_related = true
nc->alg_related
nc
nc
alg_related
true
nc->mark = alg_exp->master_mark;
nc->mark = alg_exp->master_mark
nc->mark
nc
nc
mark
alg_exp->master_mark
alg_exp
alg_exp
master_mark
nc->label = alg_exp->master_label;
nc->label = alg_exp->master_label
nc->label
nc
nc
label
alg_exp->master_label
alg_exp
alg_exp
master_label
nc->master_key = alg_exp->master_key;
nc->master_key = alg_exp->master_key
nc->master_key
nc
nc
master_key
alg_exp->master_key
alg_exp
alg_exp
master_key
if (nat_action_info) {            nc->nat_info = xmemdup(nat_action_info, sizeof *nc->nat_info);            if (alg_exp) {                if (alg_exp->passive_mode) {                    nc->rev_key.dst.addr = alg_exp->alg_nat_repl_addr;                    nc->nat_info->nat_action = NAT_ACTION_SRC;                } else {                    nc->rev_key.src.addr = alg_exp->alg_nat_repl_addr;                    nc->nat_info->nat_action = NAT_ACTION_DST;                }                *conn_for_un_nat_copy = *nc;            } else {                *conn_for_un_nat_copy = *nc;                ct_rwlock_wrlock(&ct->resources_lock);                bool nat_res = nat_select_range_tuple(                                   ct, nc, conn_for_un_nat_copy);                if (!nat_res) {                    goto nat_res_exhaustion;                }                /* Update nc with nat adjustments made to                 * conn_for_un_nat_copy by nat_select_range_tuple(). */                *nc = *conn_for_un_nat_copy;                ct_rwlock_unlock(&ct->resources_lock);            }            conn_for_un_nat_copy->conn_type = CT_CONN_TYPE_UN_NAT;            conn_for_un_nat_copy->nat_info = NULL;            conn_for_un_nat_copy->alg = NULL;            nat_packet(pkt, nc, ctx->icmp_related);        }
nat_action_info
nat_action_info
{            nc->nat_info = xmemdup(nat_action_info, sizeof *nc->nat_info);            if (alg_exp) {                if (alg_exp->passive_mode) {                    nc->rev_key.dst.addr = alg_exp->alg_nat_repl_addr;                    nc->nat_info->nat_action = NAT_ACTION_SRC;                } else {                    nc->rev_key.src.addr = alg_exp->alg_nat_repl_addr;                    nc->nat_info->nat_action = NAT_ACTION_DST;                }                *conn_for_un_nat_copy = *nc;            } else {                *conn_for_un_nat_copy = *nc;                ct_rwlock_wrlock(&ct->resources_lock);                bool nat_res = nat_select_range_tuple(                                   ct, nc, conn_for_un_nat_copy);                if (!nat_res) {                    goto nat_res_exhaustion;                }                /* Update nc with nat adjustments made to                 * conn_for_un_nat_copy by nat_select_range_tuple(). */                *nc = *conn_for_un_nat_copy;                ct_rwlock_unlock(&ct->resources_lock);            }            conn_for_un_nat_copy->conn_type = CT_CONN_TYPE_UN_NAT;            conn_for_un_nat_copy->nat_info = NULL;            conn_for_un_nat_copy->alg = NULL;            nat_packet(pkt, nc, ctx->icmp_related);        }
nc->nat_info = xmemdup(nat_action_info, sizeof *nc->nat_info);
nc->nat_info = xmemdup(nat_action_info, sizeof *nc->nat_info)
nc->nat_info
nc
nc
nat_info
xmemdup(nat_action_info, sizeof *nc->nat_info)
xmemdup
xmemdup
nat_action_info
nat_action_info
sizeof *nc->nat_info
*nc->nat_info
nc->nat_info
nc
nc
nat_info
if (alg_exp) {                if (alg_exp->passive_mode) {                    nc->rev_key.dst.addr = alg_exp->alg_nat_repl_addr;                    nc->nat_info->nat_action = NAT_ACTION_SRC;                } else {                    nc->rev_key.src.addr = alg_exp->alg_nat_repl_addr;                    nc->nat_info->nat_action = NAT_ACTION_DST;                }                *conn_for_un_nat_copy = *nc;            } else {                *conn_for_un_nat_copy = *nc;                ct_rwlock_wrlock(&ct->resources_lock);                bool nat_res = nat_select_range_tuple(                                   ct, nc, conn_for_un_nat_copy);                if (!nat_res) {                    goto nat_res_exhaustion;                }                /* Update nc with nat adjustments made to                 * conn_for_un_nat_copy by nat_select_range_tuple(). */                *nc = *conn_for_un_nat_copy;                ct_rwlock_unlock(&ct->resources_lock);            }
alg_exp
alg_exp
{                if (alg_exp->passive_mode) {                    nc->rev_key.dst.addr = alg_exp->alg_nat_repl_addr;                    nc->nat_info->nat_action = NAT_ACTION_SRC;                } else {                    nc->rev_key.src.addr = alg_exp->alg_nat_repl_addr;                    nc->nat_info->nat_action = NAT_ACTION_DST;                }                *conn_for_un_nat_copy = *nc;            }
if (alg_exp->passive_mode) {                    nc->rev_key.dst.addr = alg_exp->alg_nat_repl_addr;                    nc->nat_info->nat_action = NAT_ACTION_SRC;                } else {                    nc->rev_key.src.addr = alg_exp->alg_nat_repl_addr;                    nc->nat_info->nat_action = NAT_ACTION_DST;                }
alg_exp->passive_mode
alg_exp
alg_exp
passive_mode
{                    nc->rev_key.dst.addr = alg_exp->alg_nat_repl_addr;                    nc->nat_info->nat_action = NAT_ACTION_SRC;                }
nc->rev_key.dst.addr = alg_exp->alg_nat_repl_addr;
nc->rev_key.dst.addr = alg_exp->alg_nat_repl_addr
nc->rev_key.dst.addr
nc->rev_key.dst
nc->rev_key
nc
nc
rev_key
dst
addr
alg_exp->alg_nat_repl_addr
alg_exp
alg_exp
alg_nat_repl_addr
nc->nat_info->nat_action = NAT_ACTION_SRC;
nc->nat_info->nat_action = NAT_ACTION_SRC
nc->nat_info->nat_action
nc->nat_info
nc
nc
nat_info
nat_action
NAT_ACTION_SRC
NAT_ACTION_SRC
{                    nc->rev_key.src.addr = alg_exp->alg_nat_repl_addr;                    nc->nat_info->nat_action = NAT_ACTION_DST;                }
nc->rev_key.src.addr = alg_exp->alg_nat_repl_addr;
nc->rev_key.src.addr = alg_exp->alg_nat_repl_addr
nc->rev_key.src.addr
nc->rev_key.src
nc->rev_key
nc
nc
rev_key
src
addr
alg_exp->alg_nat_repl_addr
alg_exp
alg_exp
alg_nat_repl_addr
nc->nat_info->nat_action = NAT_ACTION_DST;
nc->nat_info->nat_action = NAT_ACTION_DST
nc->nat_info->nat_action
nc->nat_info
nc
nc
nat_info
nat_action
NAT_ACTION_DST
NAT_ACTION_DST
*conn_for_un_nat_copy = *nc;
*conn_for_un_nat_copy = *nc
*conn_for_un_nat_copy
conn_for_un_nat_copy
conn_for_un_nat_copy
*nc
nc
nc
{                *conn_for_un_nat_copy = *nc;                ct_rwlock_wrlock(&ct->resources_lock);                bool nat_res = nat_select_range_tuple(                                   ct, nc, conn_for_un_nat_copy);                if (!nat_res) {                    goto nat_res_exhaustion;                }                /* Update nc with nat adjustments made to                 * conn_for_un_nat_copy by nat_select_range_tuple(). */                *nc = *conn_for_un_nat_copy;                ct_rwlock_unlock(&ct->resources_lock);            }
*conn_for_un_nat_copy = *nc;
*conn_for_un_nat_copy = *nc
*conn_for_un_nat_copy
conn_for_un_nat_copy
conn_for_un_nat_copy
*nc
nc
nc
ct_rwlock_wrlock(&ct->resources_lock);
ct_rwlock_wrlock(&ct->resources_lock)
ct_rwlock_wrlock
ct_rwlock_wrlock
&ct->resources_lock
ct->resources_lock
ct
ct
resources_lock
bool nat_res = nat_select_range_tuple(                                   ct, nc, conn_for_un_nat_copy);
bool nat_res = nat_select_range_tuple(                                   ct, nc, conn_for_un_nat_copy);
bool
nat_res = nat_select_range_tuple(                                   ct, nc, conn_for_un_nat_copy)
nat_res
= nat_select_range_tuple(                                   ct, nc, conn_for_un_nat_copy)
nat_select_range_tuple(                                   ct, nc, conn_for_un_nat_copy)
nat_select_range_tuple
nat_select_range_tuple
ct
ct
nc
nc
conn_for_un_nat_copy
conn_for_un_nat_copy
if (!nat_res) {                    goto nat_res_exhaustion;                }
!nat_res
nat_res
nat_res
{                    goto nat_res_exhaustion;                }
goto nat_res_exhaustion;
nat_res_exhaustion
*nc = *conn_for_un_nat_copy;
*nc = *conn_for_un_nat_copy
*nc
nc
nc
*conn_for_un_nat_copy
conn_for_un_nat_copy
conn_for_un_nat_copy
ct_rwlock_unlock(&ct->resources_lock);
ct_rwlock_unlock(&ct->resources_lock)
ct_rwlock_unlock
ct_rwlock_unlock
&ct->resources_lock
ct->resources_lock
ct
ct
resources_lock
conn_for_un_nat_copy->conn_type = CT_CONN_TYPE_UN_NAT;
conn_for_un_nat_copy->conn_type = CT_CONN_TYPE_UN_NAT
conn_for_un_nat_copy->conn_type
conn_for_un_nat_copy
conn_for_un_nat_copy
conn_type
CT_CONN_TYPE_UN_NAT
CT_CONN_TYPE_UN_NAT
conn_for_un_nat_copy->nat_info = NULL;
conn_for_un_nat_copy->nat_info = NULL
conn_for_un_nat_copy->nat_info
conn_for_un_nat_copy
conn_for_un_nat_copy
nat_info
NULL
NULL
conn_for_un_nat_copy->alg = NULL;
conn_for_un_nat_copy->alg = NULL
conn_for_un_nat_copy->alg
conn_for_un_nat_copy
conn_for_un_nat_copy
alg
NULL
NULL
nat_packet(pkt, nc, ctx->icmp_related);
nat_packet(pkt, nc, ctx->icmp_related)
nat_packet
nat_packet
pkt
pkt
nc
nc
ctx->icmp_related
ctx
ctx
icmp_related
hmap_insert(&ct->buckets[bucket].connections, &nc->node, ctx->hash);
hmap_insert(&ct->buckets[bucket].connections, &nc->node, ctx->hash)
hmap_insert
hmap_insert
&ct->buckets[bucket].connections
ct->buckets[bucket].connections
ct->buckets[bucket]
ct->buckets
ct
ct
buckets
bucket
bucket
connections
&nc->node
nc->node
nc
nc
node
ctx->hash
ctx
ctx
hash
atomic_count_inc(&ct->n_conn);
atomic_count_inc(&ct->n_conn)
atomic_count_inc
atomic_count_inc
&ct->n_conn
ct->n_conn
ct
ct
n_conn
return nc;
nc
nc
nat_res_exhaustion:    ovs_list_remove(&nc->exp_node);
nat_res_exhaustion
ovs_list_remove(&nc->exp_node);
ovs_list_remove(&nc->exp_node)
ovs_list_remove
ovs_list_remove
&nc->exp_node
nc->exp_node
nc
nc
exp_node
delete_conn(nc);
delete_conn(nc)
delete_conn
delete_conn
nc
nc
memset(conn_for_un_nat_copy, 0, sizeof *conn_for_un_nat_copy);
memset(conn_for_un_nat_copy, 0, sizeof *conn_for_un_nat_copy)
memset
memset
conn_for_un_nat_copy
conn_for_un_nat_copy
0
sizeof *conn_for_un_nat_copy
*conn_for_un_nat_copy
conn_for_un_nat_copy
conn_for_un_nat_copy
ct_rwlock_unlock(&ct->resources_lock);
ct_rwlock_unlock(&ct->resources_lock)
ct_rwlock_unlock
ct_rwlock_unlock
&ct->resources_lock
ct->resources_lock
ct
ct
resources_lock
static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 5);
static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 5);
static struct vlog_rate_limit
vlog_rate_limit
rl = VLOG_RATE_LIMIT_INIT(5, 5)
rl
= VLOG_RATE_LIMIT_INIT(5, 5)
VLOG_RATE_LIMIT_INIT(5, 5)
VLOG_RATE_LIMIT_INIT
VLOG_RATE_LIMIT_INIT
5
5
VLOG_WARN_RL(&rl, "Unable to NAT due to tuple space exhaustion - "                 "if DoS attack, use firewalling and/or zone partitioning.");
VLOG_WARN_RL(&rl, "Unable to NAT due to tuple space exhaustion - "                 "if DoS attack, use firewalling and/or zone partitioning.")
VLOG_WARN_RL
VLOG_WARN_RL
&rl
rl
rl
"Unable to NAT due to tuple space exhaustion - "                 "if DoS attack, use firewalling and/or zone partitioning."
return NULL;
NULL
NULL
-----joern-----
(286,93,0)
(265,194,0)
(149,47,0)
(128,27,0)
(257,161,0)
(181,96,0)
(287,123,0)
(289,118,0)
(321,302,0)
(12,57,0)
(294,102,0)
(53,146,0)
(295,142,0)
(210,215,0)
(253,227,0)
(98,254,0)
(246,142,0)
(2,27,0)
(267,184,0)
(254,280,0)
(16,6,0)
(157,148,0)
(169,2,0)
(4,140,0)
(211,125,0)
(319,205,0)
(99,62,0)
(316,302,0)
(253,263,0)
(175,315,0)
(24,237,0)
(8,194,0)
(110,140,0)
(274,134,0)
(144,269,0)
(304,48,0)
(37,312,0)
(130,197,0)
(65,221,0)
(31,317,0)
(61,280,0)
(155,228,0)
(74,284,0)
(176,37,0)
(296,194,0)
(162,311,0)
(312,37,0)
(318,27,0)
(184,136,0)
(139,187,0)
(168,139,0)
(235,172,0)
(305,198,0)
(118,163,0)
(284,194,0)
(240,107,0)
(224,292,0)
(233,188,0)
(307,296,0)
(17,203,0)
(272,242,0)
(191,58,0)
(297,1,0)
(1,319,0)
(68,302,0)
(47,276,0)
(67,123,0)
(296,87,0)
(233,115,0)
(265,148,0)
(137,83,0)
(80,87,0)
(262,27,0)
(228,256,0)
(296,113,0)
(104,23,0)
(1,297,0)
(82,155,0)
(146,242,0)
(40,159,0)
(217,224,0)
(304,317,0)
(142,256,0)
(126,227,0)
(74,275,0)
(86,148,0)
(189,31,0)
(31,148,0)
(227,194,0)
(231,16,0)
(134,194,0)
(219,227,0)
(32,316,0)
(183,244,0)
(114,95,0)
(160,187,0)
(203,82,0)
(31,96,0)
(299,150,0)
(0,280,0)
(115,233,0)
(78,0,0)
(73,107,0)
(70,122,0)
(260,194,0)
(79,134,0)
(15,10,0)
(102,27,0)
(25,58,0)
(196,250,0)
(150,194,0)
(142,295,0)
(134,73,0)
(120,15,0)
(66,52,0)
(63,148,0)
(83,256,0)
(52,58,0)
(62,194,0)
(194,148,0)
(64,87,0)
(165,150,0)
(156,0,0)
(284,74,0)
(209,191,0)
(9,101,0)
(56,113,0)
(147,76,0)
(237,280,0)
(311,188,0)
(141,280,0)
(41,148,0)
(44,112,0)
(62,21,0)
(64,203,0)
(33,275,0)
(42,254,0)
(36,201,0)
(253,288,0)
(29,319,0)
(313,43,0)
(96,31,0)
(297,27,0)
(6,305,0)
(22,20,0)
(268,112,0)
(161,78,0)
(91,25,0)
(233,140,0)
(26,114,0)
(258,27,0)
(220,21,0)
(60,140,0)
(106,269,0)
(303,62,0)
(57,2,0)
(28,240,0)
(169,269,0)
(193,286,0)
(301,224,0)
(292,194,0)
(170,73,0)
(127,168,0)
(178,141,0)
(68,23,0)
(199,316,0)
(83,185,0)
(181,194,0)
(316,270,0)
(203,64,0)
(205,319,0)
(52,15,0)
(36,148,0)
(216,205,0)
(253,217,0)
(130,256,0)
(14,55,0)
(269,169,0)
(252,205,0)
(301,280,0)
(121,12,0)
(45,64,0)
(11,284,0)
(306,304,0)
(122,184,0)
(221,63,0)
(114,263,0)
(263,110,0)
(218,198,0)
(12,302,0)
(139,55,0)
(300,295,0)
(118,194,0)
(150,299,0)
(125,14,0)
(4,291,0)
(254,244,0)
(155,158,0)
(81,181,0)
(35,64,0)
(94,57,0)
(196,20,0)
(174,254,0)
(261,108,0)
(260,27,0)
(60,122,0)
(272,194,0)
(102,194,0)
(311,107,0)
(113,56,0)
(92,76,0)
(82,203,0)
(253,168,0)
(100,48,0)
(270,312,0)
(242,272,0)
(75,189,0)
(63,135,0)
(119,108,0)
(212,218,0)
(129,286,0)
(215,302,0)
(281,272,0)
(43,27,0)
(73,134,0)
(135,63,0)
(197,89,0)
(59,284,0)
(138,68,0)
(253,27,0)
(21,62,0)
(161,280,0)
(279,311,0)
(168,194,0)
(264,65,0)
(172,58,0)
(253,26,0)
(34,93,0)
(18,181,0)
(71,217,0)
(292,224,0)
(253,8,0)
(173,66,0)
(154,148,0)
(320,300,0)
(4,167,0)
(230,321,0)
(111,288,0)
(243,83,0)
(80,194,0)
(13,175,0)
(259,130,0)
(189,107,0)
(275,89,0)
(250,194,0)
(125,194,0)
(69,158,0)
(317,304,0)
(277,61,0)
(217,280,0)
(218,301,0)
(61,25,0)
(285,27,0)
(56,148,0)
(152,233,0)
(131,321,0)
(239,300,0)
(208,4,0)
(283,189,0)
(77,272,0)
(72,110,0)
(260,159,0)
(34,27,0)
(201,36,0)
(251,292,0)
(23,68,0)
(266,301,0)
(132,288,0)
(40,276,0)
(288,194,0)
(93,34,0)
(213,183,0)
(298,12,0)
(254,302,0)
(161,224,0)
(253,300,0)
(4,94,0)
(234,57,0)
(7,110,0)
(319,27,0)
(227,13,0)
(237,191,0)
(185,83,0)
(164,297,0)
(291,240,0)
(207,228,0)
(65,302,0)
(112,26,0)
(221,65,0)
(202,80,0)
(117,263,0)
(244,254,0)
(123,280,0)
(133,240,0)
(51,212,0)
(48,304,0)
(110,263,0)
(94,4,0)
(105,253,0)
(171,135,0)
(90,159,0)
(309,187,0)
(108,265,0)
(295,55,0)
(204,2,0)
(87,80,0)
(141,196,0)
(57,12,0)
(19,175,0)
(232,163,0)
(220,27,0)
(273,27,0)
(197,130,0)
(90,136,0)
(312,270,0)
(103,244,0)
(228,155,0)
(0,78,0)
(8,185,0)
(291,4,0)
(242,146,0)
(2,169,0)
(247,60,0)
(5,265,0)
(150,52,0)
(88,125,0)
(314,65,0)
(31,189,0)
(225,142,0)
(282,8,0)
(248,40,0)
(145,159,0)
(26,112,0)
(245,14,0)
(85,82,0)
(15,52,0)
(195,296,0)
(54,228,0)
(84,26,0)
(278,16,0)
(182,68,0)
(270,316,0)
(180,242,0)
(232,15,0)
(254,194,0)
(299,69,0)
(188,233,0)
(244,198,0)
(250,196,0)
(93,286,0)
(0,27,0)
(175,13,0)
(23,104,0)
(269,107,0)
(49,4,0)
(290,148,0)
(123,172,0)
(134,58,0)
(109,8,0)
(46,61,0)
(186,150,0)
(64,194,0)
(224,198,0)
(163,118,0)
(253,108,0)
(143,69,0)
(21,220,0)
(179,90,0)
(288,87,0)
(215,48,0)
(241,73,0)
(253,125,0)
(78,161,0)
(134,140,0)
(4,194,0)
(284,52,0)
(240,291,0)
(253,66,0)
(286,302,0)
(226,194,0)
(223,60,0)
(113,296,0)
(166,260,0)
(151,168,0)
(96,181,0)
(293,74,0)
(76,256,0)
(6,16,0)
(272,87,0)
(310,198,0)
(192,80,0)
(185,55,0)
(124,299,0)
(177,159,0)
(187,256,0)
(300,194,0)
(305,6,0)
(200,58,0)
(321,201,0)
(317,31,0)
(159,27,0)
(104,198,0)
(87,148,0)
(108,107,0)
(48,215,0)
(39,118,0)
(249,130,0)
(3,1,0)
(16,302,0)
(13,116,0)
(66,194,0)
(153,253,0)
(105,260,0)
(57,94,0)
(222,66,0)
(15,232,0)
(308,237,0)
(301,218,0)
(38,27,0)
(105,40,0)
(194,4,0)
(238,0,0)
(105,90,0)
(263,43,0)
(112,140,0)
(206,198,0)
(201,321,0)
(187,139,0)
(190,114,0)
(50,215,0)
(30,250,0)
(146,197,0)
(48,2,0)
(188,311,0)
(163,232,0)
(63,221,0)
(122,60,0)
(212,194,0)
(134,140,1)
(105,90,1)
(155,228,1)
(288,111,1)
(263,117,1)
(301,224,1)
(104,23,1)
(205,216,1)
(112,268,1)
(237,280,1)
(4,291,1)
(253,125,1)
(268,44,1)
(187,160,1)
(252,29,1)
(92,147,1)
(12,121,1)
(72,7,1)
(134,73,1)
(110,140,1)
(251,217,1)
(123,287,1)
(254,42,1)
(85,203,1)
(267,122,1)
(151,185,1)
(68,302,1)
(253,8,1)
(50,134,1)
(233,140,1)
(307,87,1)
(253,66,1)
(161,257,1)
(208,94,1)
(65,314,1)
(168,127,1)
(288,194,1)
(246,300,1)
(141,280,1)
(292,194,1)
(12,302,1)
(231,218,1)
(40,248,1)
(130,256,1)
(63,135,1)
(240,107,1)
(81,317,1)
(189,283,1)
(253,153,1)
(221,65,1)
(74,293,1)
(29,34,1)
(189,107,1)
(4,49,1)
(169,269,1)
(24,308,1)
(122,70,1)
(243,137,1)
(164,1,1)
(120,66,1)
(80,192,1)
(181,18,1)
(283,75,1)
(45,76,1)
(314,264,1)
(239,14,1)
(124,150,1)
(216,252,1)
(82,203,1)
(150,52,1)
(303,9,1)
(114,190,1)
(255,229,1)
(191,209,1)
(8,282,1)
(26,84,1)
(202,288,1)
(138,182,1)
(62,99,1)
(253,168,1)
(253,227,1)
(40,159,1)
(88,211,1)
(77,76,1)
(100,215,1)
(64,35,1)
(210,50,1)
(9,183,1)
(254,302,1)
(296,87,1)
(278,231,1)
(271,52,1)
(212,194,1)
(291,240,1)
(226,37,1)
(253,300,1)
(260,166,1)
(17,64,1)
(319,205,1)
(106,144,1)
(114,263,1)
(272,87,1)
(272,194,1)
(178,69,1)
(71,271,1)
(118,194,1)
(79,191,1)
(87,80,1)
(253,263,1)
(105,253,1)
(284,59,1)
(253,288,1)
(224,292,1)
(53,242,1)
(166,36,1)
(28,133,1)
(212,51,1)
(142,256,1)
(240,28,1)
(139,187,1)
(257,238,1)
(97,214,1)
(70,60,1)
(201,321,1)
(30,141,1)
(35,45,1)
(229,56,1)
(36,201,1)
(11,197,1)
(190,26,1)
(287,67,1)
(115,233,1)
(14,245,1)
(217,71,1)
(254,194,1)
(211,255,1)
(102,194,1)
(57,12,1)
(309,168,1)
(146,53,1)
(68,138,1)
(142,225,1)
(15,232,1)
(0,280,1)
(82,85,1)
(69,143,1)
(132,265,1)
(254,280,1)
(108,107,1)
(149,37,1)
(281,77,1)
(165,186,1)
(16,278,1)
(321,302,1)
(119,194,1)
(54,82,1)
(4,140,1)
(18,81,1)
(141,178,1)
(131,31,1)
(99,303,1)
(186,155,1)
(103,104,1)
(286,193,1)
(150,165,1)
(175,19,1)
(150,194,1)
(166,97,1)
(236,255,1)
(187,256,1)
(125,194,1)
(8,194,1)
(296,195,1)
(105,260,1)
(223,115,1)
(37,176,1)
(277,196,1)
(74,284,1)
(5,108,1)
(1,3,1)
(105,40,1)
(135,171,1)
(111,132,1)
(171,221,1)
(159,145,1)
(96,181,1)
(75,96,1)
(294,220,1)
(91,61,1)
(242,180,1)
(16,302,1)
(129,0,1)
(184,267,1)
(237,24,1)
(42,98,1)
(274,79,1)
(183,244,1)
(282,109,1)
(172,235,1)
(272,281,1)
(121,298,1)
(227,194,1)
(286,302,1)
(193,129,1)
(299,150,1)
(234,12,1)
(112,140,1)
(62,194,1)
(67,25,1)
(300,194,1)
(31,96,1)
(162,152,1)
(110,72,1)
(49,291,1)
(94,57,1)
(59,11,1)
(48,215,1)
(270,316,1)
(215,210,1)
(90,179,1)
(260,159,1)
(299,124,1)
(3,319,1)
(228,256,1)
(170,274,1)
(300,320,1)
(293,284,1)
(44,214,1)
(213,244,1)
(64,87,1)
(25,91,1)
(220,21,1)
(4,94,1)
(250,194,1)
(73,241,1)
(259,146,1)
(144,204,1)
(207,54,1)
(238,156,1)
(1,319,1)
(253,108,1)
(235,123,1)
(93,286,1)
(321,230,1)
(130,249,1)
(230,131,1)
(199,63,1)
(289,39,1)
(23,68,1)
(60,140,1)
(83,256,1)
(133,208,1)
(97,114,1)
(147,271,1)
(222,236,1)
(63,221,1)
(6,16,1)
(308,172,1)
(15,10,1)
(284,194,1)
(260,194,1)
(316,32,1)
(168,194,1)
(61,46,1)
(57,2,1)
(317,304,1)
(4,167,1)
(266,212,1)
(295,142,1)
(312,270,1)
(245,125,1)
(304,48,1)
(269,107,1)
(192,202,1)
(304,306,1)
(125,88,1)
(183,213,1)
(134,194,1)
(297,164,1)
(248,47,1)
(126,229,1)
(19,227,1)
(153,297,1)
(48,2,1)
(33,74,1)
(76,92,1)
(253,217,1)
(297,1,1)
(179,184,1)
(261,119,1)
(84,112,1)
(66,173,1)
(161,280,1)
(301,280,1)
(90,159,1)
(233,188,1)
(98,174,1)
(217,280,1)
(32,199,1)
(113,296,1)
(253,26,1)
(181,194,1)
(60,247,1)
(64,194,1)
(66,194,1)
(185,83,1)
(57,234,1)
(196,250,1)
(214,43,1)
(43,313,1)
(265,5,1)
(37,312,1)
(263,110,1)
(137,8,1)
(174,103,1)
(316,302,1)
(51,183,1)
(249,259,1)
(182,224,1)
(108,261,1)
(34,93,1)
(247,223,1)
(250,30,1)
(83,243,1)
(298,226,1)
(195,307,1)
(118,289,1)
(242,272,1)
(178,275,1)
(56,113,1)
(7,115,1)
(123,280,1)
(311,107,1)
(227,219,1)
(80,194,1)
(145,177,1)
(127,151,1)
(305,6,1)
(146,242,1)
(236,139,1)
(161,224,1)
(122,60,1)
(160,309,1)
(50,236,1)
(109,295,1)
(301,266,1)
(264,97,1)
(296,194,1)
(244,254,1)
(21,62,1)
(241,170,1)
(46,277,1)
(203,64,1)
(313,263,1)
(279,162,1)
(102,294,1)
(143,299,1)
(76,256,1)
(215,302,1)
(228,207,1)
(218,301,1)
(255,13,1)
(175,315,1)
(188,311,1)
(180,272,1)
(269,106,1)
(194,4,1)
(13,175,1)
(156,102,1)
(52,15,1)
(320,239,1)
(225,246,1)
(277,305,1)
(292,251,1)
(219,126,1)
(275,33,1)
(152,159,1)
(209,237,1)
(203,17,1)
(311,279,1)
(78,161,1)
(197,130,1)
(176,312,1)
(232,163,1)
(265,194,1)
(26,112,1)
(177,2,1)
(0,78,1)
(306,48,1)
(47,149,1)
(163,118,1)
(65,302,1)
(31,317,1)
(61,280,1)
(2,169,1)
(48,100,1)
(39,120,1)
(117,110,1)
(31,189,1)
(284,52,1)
(173,222,1)
(73,107,1)
(21,62,2)
(4,291,2)
(71,271,2)
(37,312,2)
(243,255,2)
(246,255,2)
(260,159,2)
(316,97,2)
(263,110,2)
(66,236,2)
(210,183,2)
(104,271,2)
(212,194,2)
(111,37,2)
(52,236,2)
(105,253,2)
(294,183,2)
(0,280,2)
(134,194,2)
(64,87,2)
(192,37,2)
(100,236,2)
(33,76,2)
(6,183,2)
(108,37,2)
(81,271,2)
(240,107,2)
(173,236,2)
(82,76,2)
(300,194,2)
(96,236,2)
(283,236,2)
(264,97,2)
(79,271,2)
(260,183,2)
(115,233,2)
(287,183,2)
(213,271,2)
(237,271,2)
(295,255,2)
(73,271,2)
(304,236,2)
(210,236,2)
(239,255,2)
(191,183,2)
(250,194,2)
(19,229,2)
(304,271,2)
(0,183,2)
(75,236,2)
(65,302,2)
(247,115,2)
(43,115,2)
(29,183,2)
(25,183,2)
(189,107,2)
(63,221,2)
(5,37,2)
(257,183,2)
(212,183,2)
(253,183,2)
(254,280,2)
(67,271,2)
(266,183,2)
(224,292,2)
(179,115,2)
(87,37,2)
(307,37,2)
(207,76,2)
(194,4,2)
(23,68,2)
(211,255,2)
(15,236,2)
(13,229,2)
(277,271,2)
(296,37,2)
(189,236,2)
(57,37,2)
(245,255,2)
(46,271,2)
(134,183,2)
(284,52,2)
(253,125,2)
(17,76,2)
(274,271,2)
(253,8,2)
(75,271,2)
(308,271,2)
(12,302,2)
(306,271,2)
(215,271,2)
(168,255,2)
(267,115,2)
(182,271,2)
(118,236,2)
(31,271,2)
(234,37,2)
(124,76,2)
(94,57,2)
(248,37,2)
(296,194,2)
(220,183,2)
(117,115,2)
(321,302,2)
(172,271,2)
(191,271,2)
(131,183,2)
(72,115,2)
(255,37,2)
(13,175,2)
(208,37,2)
(96,183,2)
(35,76,2)
(298,37,2)
(100,271,2)
(31,189,2)
(50,183,2)
(236,37,2)
(57,2,2)
(174,271,2)
(166,271,2)
(85,76,2)
(149,37,2)
(48,2,2)
(172,183,2)
(286,302,2)
(199,97,2)
(253,26,2)
(189,271,2)
(119,37,2)
(170,183,2)
(194,37,2)
(26,214,2)
(166,97,2)
(284,194,2)
(8,255,2)
(283,183,2)
(110,140,2)
(163,236,2)
(4,37,2)
(68,302,2)
(220,21,2)
(275,76,2)
(3,183,2)
(60,115,2)
(21,183,2)
(121,37,2)
(153,183,2)
(253,227,2)
(105,260,2)
(170,271,2)
(127,255,2)
(125,194,2)
(62,183,2)
(282,255,2)
(176,97,2)
(92,271,2)
(118,194,2)
(135,97,2)
(104,23,2)
(254,194,2)
(112,140,2)
(253,168,2)
(317,271,2)
(50,271,2)
(18,271,2)
(252,183,2)
(188,311,2)
(65,97,2)
(76,271,2)
(90,115,2)
(61,271,2)
(64,76,2)
(233,140,2)
(241,271,2)
(197,76,2)
(81,183,2)
(286,183,2)
(96,271,2)
(221,65,2)
(161,224,2)
(308,183,2)
(100,183,2)
(186,76,2)
(216,183,2)
(16,302,2)
(81,236,2)
(23,271,2)
(218,183,2)
(317,304,2)
(321,271,2)
(68,271,2)
(201,183,2)
(6,16,2)
(48,215,2)
(249,76,2)
(253,300,2)
(59,76,2)
(84,214,2)
(4,167,2)
(183,271,2)
(75,183,2)
(305,6,2)
(317,183,2)
(40,37,2)
(175,315,2)
(122,115,2)
(190,214,2)
(292,271,2)
(215,183,2)
(181,194,2)
(203,76,2)
(0,78,2)
(304,48,2)
(134,271,2)
(156,183,2)
(311,107,2)
(63,97,2)
(291,240,2)
(134,73,2)
(319,205,2)
(123,183,2)
(253,66,2)
(102,183,2)
(193,183,2)
(185,83,2)
(240,37,2)
(94,37,2)
(93,286,2)
(293,76,2)
(168,194,2)
(102,194,2)
(180,76,2)
(146,76,2)
(105,90,2)
(1,183,2)
(161,183,2)
(83,255,2)
(69,76,2)
(244,254,2)
(129,183,2)
(150,52,2)
(272,76,2)
(314,97,2)
(292,194,2)
(269,107,2)
(15,232,2)
(123,271,2)
(253,263,2)
(235,271,2)
(30,271,2)
(164,183,2)
(196,271,2)
(321,183,2)
(260,97,2)
(120,236,2)
(70,115,2)
(56,37,2)
(64,194,2)
(32,97,2)
(197,130,2)
(40,159,2)
(231,183,2)
(77,76,2)
(295,142,2)
(91,271,2)
(253,217,2)
(137,255,2)
(56,113,2)
(105,40,2)
(51,183,2)
(309,255,2)
(109,255,2)
(45,76,2)
(171,97,2)
(221,97,2)
(122,60,2)
(18,236,2)
(139,187,2)
(278,183,2)
(8,194,2)
(259,76,2)
(31,236,2)
(242,272,2)
(237,280,2)
(268,214,2)
(229,37,2)
(25,271,2)
(161,280,2)
(160,255,2)
(301,224,2)
(291,37,2)
(202,37,2)
(16,183,2)
(185,255,2)
(26,112,2)
(123,280,2)
(230,183,2)
(230,236,2)
(201,321,2)
(66,194,2)
(215,236,2)
(196,250,2)
(301,183,2)
(15,10,2)
(9,183,2)
(300,255,2)
(227,194,2)
(228,256,2)
(114,214,2)
(88,255,2)
(187,256,2)
(238,183,2)
(312,270,2)
(230,271,2)
(260,236,2)
(76,256,2)
(108,107,2)
(313,115,2)
(283,271,2)
(60,140,2)
(284,76,2)
(80,37,2)
(263,115,2)
(12,37,2)
(181,183,2)
(97,115,2)
(288,194,2)
(130,76,2)
(321,236,2)
(297,183,2)
(87,80,2)
(218,301,2)
(112,214,2)
(272,194,2)
(304,183,2)
(52,15,2)
(241,183,2)
(24,271,2)
(138,271,2)
(203,64,2)
(46,183,2)
(270,97,2)
(260,271,2)
(214,115,2)
(113,37,2)
(254,271,2)
(201,271,2)
(110,115,2)
(48,183,2)
(78,183,2)
(7,115,2)
(142,256,2)
(299,150,2)
(131,236,2)
(34,93,2)
(265,37,2)
(4,140,2)
(141,280,2)
(134,140,2)
(36,183,2)
(31,183,2)
(18,183,2)
(232,163,2)
(143,76,2)
(61,183,2)
(61,280,2)
(74,284,2)
(91,183,2)
(224,271,2)
(201,236,2)
(261,37,2)
(130,256,2)
(287,271,2)
(151,255,2)
(53,76,2)
(150,194,2)
(42,271,2)
(131,271,2)
(277,183,2)
(67,183,2)
(296,87,2)
(228,76,2)
(83,256,2)
(114,263,2)
(184,115,2)
(37,97,2)
(175,229,2)
(209,183,2)
(297,1,2)
(303,183,2)
(132,37,2)
(126,229,2)
(306,183,2)
(209,271,2)
(251,271,2)
(113,296,2)
(305,183,2)
(237,183,2)
(125,255,2)
(166,183,2)
(14,255,2)
(181,271,2)
(99,183,2)
(80,194,2)
(139,255,2)
(210,271,2)
(217,271,2)
(178,271,2)
(163,118,2)
(50,236,2)
(250,271,2)
(54,76,2)
(316,302,2)
(253,288,2)
(155,228,2)
(288,37,2)
(36,271,2)
(183,244,2)
(312,97,2)
(319,183,2)
(155,76,2)
(48,271,2)
(147,271,2)
(74,76,2)
(98,271,2)
(73,107,2)
(78,161,2)
(165,76,2)
(233,188,2)
(281,76,2)
(28,37,2)
(254,302,2)
(253,108,2)
(96,181,2)
(146,242,2)
(49,37,2)
(235,183,2)
(195,37,2)
(39,236,2)
(317,236,2)
(62,194,2)
(150,76,2)
(141,271,2)
(272,87,2)
(181,236,2)
(36,236,2)
(189,183,2)
(166,236,2)
(301,280,2)
(306,236,2)
(271,236,2)
(244,271,2)
(73,183,2)
(2,169,2)
(79,183,2)
(11,76,2)
(299,76,2)
(34,183,2)
(90,159,2)
(1,319,2)
(48,236,2)
(4,94,2)
(47,37,2)
(63,135,2)
(24,183,2)
(222,236,2)
(223,115,2)
(289,236,2)
(225,255,2)
(215,302,2)
(219,229,2)
(187,255,2)
(205,183,2)
(93,183,2)
(320,255,2)
(57,12,2)
(232,236,2)
(265,194,2)
(242,76,2)
(31,96,2)
(44,214,2)
(217,280,2)
(31,317,2)
(260,194,2)
(169,269,2)
(274,183,2)
(103,271,2)
(227,229,2)
(82,203,2)
(270,316,2)
(36,201,2)
(226,37,2)
(142,255,2)
(133,37,2)
-----------------------------------
(0,memset(conn_for_un_nat_copy, 0, sizeof *conn_for_un_nat_copy)
(1,&rl)
(2,bucket = hash_to_bucket(ctx->hash)
(3,rl)
(4,new_conn(&ct->buckets[bucket], pkt, &ctx->key, now)
(5,nc)
(6,&ct->resources_lock)
(7,pkt)
(8,nc->label)
(9,goto nat_res_exhaustion;)
(10,const struct nat_action_info_t *nat_action_info)
(11,nc)
(12,ct->buckets)
(13,nc->alg = xstrdup(helper)
(14,nc->alg_related = true)
(15,xmemdup(nat_action_info, sizeof *nc->nat_info)
(16,ct->resources_lock)
(17,src)
(18,node)
(19,helper)
(20,)
(21,&nc->exp_node)
(22,if (alg_exp->passive_mode)
(23,&ct->resources_lock)
(24,alg)
(25,conn_for_un_nat_copy->conn_type = CT_CONN_TYPE_UN_NAT)
(26,pkt->md.ct_state)
(27,)
(28,key)
(29,rl)
(30,nc)
(31,hmap_insert(&ct->buckets[bucket].connections, &nc->node, ctx->hash)
(32,n_conn)
(33,NAT_ACTION_SRC)
(34,ct_rwlock_unlock(&ct->resources_lock)
(35,rev_key)
(36,atomic_count_inc(&ct->n_conn)
(37,atomic_count_get(&ct->n_conn)
(38,nc)
(39,nc)
(40,return nc;)
(41,n_conn_limit)
(42,conn_for_un_nat_copy)
(43,pkt->md.ct_state = CS_NEW)
(44,pkt)
(45,nc)
(46,conn_type)
(47,COVERAGE_INC(conntrack_full)
(48,ct->buckets[bucket])
(49,now)
(50,ct)
(51,nc)
(52,nc->nat_info = xmemdup(nat_action_info, sizeof *nc->nat_info)
(53,addr)
(54,alg_exp)
(55,)
(56,conn_key_reverse(&nc->rev_key)
(57,ct->buckets[bucket])
(58,)
(59,nat_info)
(60,pkt->md)
(61,conn_for_un_nat_copy->conn_type)
(62,nc->exp_node)
(63,atomic_read_relaxed(&ct->n_conn_limit, &n_conn_limit)
(64,nc->rev_key)
(65,ct->n_conn_limit)
(66,nc->nat_info)
(67,conn_for_un_nat_copy)
(68,ct->resources_lock)
(69,nc->nat_info->nat_action = NAT_ACTION_DST)
(70,ct_state)
(71,conn_for_un_nat_copy)
(72,md)
(73,ctx->icmp_related)
(74,nc->nat_info->nat_action)
(75,ctx)
(76,alg_exp->passive_mode)
(77,nc)
(78,sizeof *conn_for_un_nat_copy)
(79,pkt)
(80,nc->key)
(81,nc)
(82,nc->rev_key.src.addr)
(83,alg_exp->master_label)
(84,ct_state)
(85,addr)
(86,if (helper)
(87,nc->rev_key = nc->key)
(88,alg_related)
(89,)
(90,return nc;)
(91,CT_CONN_TYPE_UN_NAT)
(92,passive_mode)
(93,&ct->resources_lock)
(94,&ct->buckets[bucket])
(95,)
(96,&nc->node)
(97,commit)
(98,nc)
(99,exp_node)
(100,bucket)
(101,)
(102,delete_conn(nc)
(103,nat_res)
(104,ct_rwlock_wrlock(&ct->resources_lock)
(105,RET)
(106,hash)
(107,struct conn_lookup_ctx *ctx)
(108,ctx->conn)
(109,nc)
(110,pkt->md)
(111,rev_key)
(112,pkt->md)
(113,&nc->rev_key)
(114,pkt->md.ct_state |= CS_RELATED)
(115,!valid_new(pkt, &ctx->key)
(116,)
(117,ct_state)
(118,nc->nat_info)
(119,ctx)
(120,nat_action_info)
(121,buckets)
(122,pkt->md.ct_state)
(123,conn_for_un_nat_copy->nat_info)
(124,nat_action)
(125,nc->alg_related)
(126,nc)
(127,master_key)
(128,if (alg_exp)
(129,ct)
(130,alg_exp->alg_nat_repl_addr)
(131,ct)
(132,nc)
(133,ctx)
(134,nat_packet(pkt, nc, ctx->icmp_related)
(135,&n_conn_limit)
(136,)
(137,alg_exp)
(138,resources_lock)
(139,nc->master_key = alg_exp->master_key)
(140,struct dp_packet *pkt)
(141,*conn_for_un_nat_copy)
(142,alg_exp->master_mark)
(143,NAT_ACTION_DST)
(144,ctx)
(145,NULL)
(146,nc->rev_key.dst.addr)
(147,alg_exp)
(148,)
(149,conntrack_full)
(150,nc->nat_info)
(151,nc)
(152,pkt)
(153,NULL)
(154,if (atomic_count_get(&ct->n_conn)
(155,nc->rev_key.src.addr = alg_exp->alg_nat_repl_addr)
(156,conn_for_un_nat_copy)
(157,if (nat_action_info)
(158,)
(159,*nc = NULL)
(160,master_key)
(161,*conn_for_un_nat_copy)
(162,ctx)
(163,*nc->nat_info)
(164,"Unable to NAT due to tuple space exhaustion - "\n\\n                 "if DoS attack, use firewalling and/or zone partitioning.")
(165,nat_info)
(166,nc)
(167,long long now)
(168,nc->master_key)
(169,hash_to_bucket(ctx->hash)
(170,ctx)
(171,n_conn_limit)
(172,conn_for_un_nat_copy->nat_info = NULL)
(173,nat_info)
(174,ct)
(175,xstrdup(helper)
(176,n_conn_limit)
(177,nc)
(178,conn_for_un_nat_copy)
(179,nc)
(180,dst)
(181,nc->node)
(182,ct)
(183,!nat_res)
(184,pkt->md.ct_state = CS_INVALID)
(185,nc->label = alg_exp->master_label)
(186,nc)
(187,alg_exp->master_key)
(188,&ctx->key)
(189,ctx->hash)
(190,CS_RELATED)
(191,conn_for_un_nat_copy->alg = NULL)
(192,key)
(193,resources_lock)
(194,nc = new_conn(&ct->buckets[bucket], pkt, &ctx->key, now)
(195,rev_key)
(196,*conn_for_un_nat_copy = *nc)
(197,nc->rev_key.dst.addr = alg_exp->alg_nat_repl_addr)
(198,)
(199,ct)
(200,if (alg_exp)
(201,&ct->n_conn)
(202,nc)
(203,nc->rev_key.src)
(204,bucket)
(205,VLOG_RATE_LIMIT_INIT(5, 5)
(206,if (!nat_res)
(207,alg_nat_repl_addr)
(208,pkt)
(209,NULL)
(210,buckets)
(211,nc)
(212,*nc)
(213,nat_res)
(214,alg_exp)
(215,ct->buckets)
(216,5)
(217,*conn_for_un_nat_copy)
(218,*nc = *conn_for_un_nat_copy)
(219,alg)
(220,ovs_list_remove(&nc->exp_node)
(221,&ct->n_conn_limit)
(222,nc)
(223,pkt)
(224,*conn_for_un_nat_copy = *nc)
(225,master_mark)
(226,nc)
(227,nc->alg)
(228,alg_exp->alg_nat_repl_addr)
(229,helper)
(230,n_conn)
(231,ct)
(232,sizeof *nc->nat_info)
(233,valid_new(pkt, &ctx->key)
(234,bucket)
(235,NULL)
(236,nat_action_info)
(237,conn_for_un_nat_copy->alg)
(238,0)
(239,nc)
(240,ctx->key)
(241,icmp_related)
(242,nc->rev_key.dst)
(243,master_label)
(244,nat_res = nat_select_range_tuple(\n\\n                                   ct, nc, conn_for_un_nat_copy)
(245,true)
(246,alg_exp)
(247,md)
(248,nc)
(249,alg_nat_repl_addr)
(250,*nc)
(251,nc)
(252,5)
(253,return NULL;)
(254,nat_select_range_tuple(\n\\n                                   ct, nc, conn_for_un_nat_copy)
(255,alg_exp)
(256,const struct alg_exp_node *alg_exp)
(257,conn_for_un_nat_copy)
(258,if (!valid_new(pkt, &ctx->key)
(259,alg_exp)
(260,return nc;)
(261,conn)
(262,if (commit)
(263,pkt->md.ct_state)
(264,ct)
(265,ctx->conn = nc)
(266,conn_for_un_nat_copy)
(267,CS_INVALID)
(268,md)
(269,ctx->hash)
(270,&ct->n_conn)
(271,alg_exp)
(272,nc->rev_key)
(273,bucket)
(274,nc)
(275,nc->nat_info->nat_action = NAT_ACTION_SRC)
(276,)
(277,conn_for_un_nat_copy)
(278,resources_lock)
(279,key)
(280,struct conn *conn_for_un_nat_copy)
(281,rev_key)
(282,label)
(283,hash)
(284,nc->nat_info)
(285,nat_res_exhaustion:)
(286,ct->resources_lock)
(287,nat_info)
(288,nc->rev_key)
(289,nat_info)
(290,if (alg_exp)
(291,&ctx->key)
(292,*nc)
(293,nat_action)
(294,nc)
(295,nc->mark = alg_exp->master_mark)
(296,nc->rev_key)
(297,VLOG_WARN_RL(&rl, "Unable to NAT due to tuple space exhaustion - "\n\\n                 "if DoS attack, use firewalling and/or zone partitioning.")
(298,ct)
(299,nc->nat_info->nat_action)
(300,nc->mark)
(301,*conn_for_un_nat_copy)
(302,struct conntrack *ct)
(303,nc)
(304,ct->buckets[bucket].connections)
(305,ct_rwlock_unlock(&ct->resources_lock)
(306,connections)
(307,nc)
(308,conn_for_un_nat_copy)
(309,alg_exp)
(310,nat_res)
(311,ctx->key)
(312,atomic_count_get(&ct->n_conn)
(313,CS_NEW)
(314,n_conn_limit)
(315,const char *helper)
(316,ct->n_conn)
(317,&ct->buckets[bucket].connections)
(318,rl)
(319,rl = VLOG_RATE_LIMIT_INIT(5, 5)
(320,mark)
(321,ct->n_conn)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^