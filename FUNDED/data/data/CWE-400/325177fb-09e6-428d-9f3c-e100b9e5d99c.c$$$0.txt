-----label-----
1
-----code-----
static int
vmx_init(int ipinum)
{
	int error, use_tpr_shadow;
	uint64_t basic, fixed0, fixed1, feature_control;
	uint32_t tmp, procbased2_vid_bits;

	/* CPUID.1:ECX[bit 5] must be 1 for processor to support VMX */
	if (!(cpu_feature2 & CPUID2_VMX)) {
		printf("vmx_init: processor does not support VMX operation\n");
		return (ENXIO);
	}

	/*
	 * Verify that MSR_IA32_FEATURE_CONTROL lock and VMXON enable bits
	 * are set (bits 0 and 2 respectively).
	 */
	feature_control = rdmsr(MSR_IA32_FEATURE_CONTROL);
	if ((feature_control & IA32_FEATURE_CONTROL_LOCK) == 1 &&
	    (feature_control & IA32_FEATURE_CONTROL_VMX_EN) == 0) {
		printf("vmx_init: VMX operation disabled by BIOS\n");
		return (ENXIO);
	}

	/*
	 * Verify capabilities MSR_VMX_BASIC:
	 * - bit 54 indicates support for INS/OUTS decoding
	 */
	basic = rdmsr(MSR_VMX_BASIC);
	if ((basic & (1UL << 54)) == 0) {
		printf("vmx_init: processor does not support desired basic "
		    "capabilities\n");
		return (EINVAL);
	}

	/* Check support for primary processor-based VM-execution controls */
	error = vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,
			       MSR_VMX_TRUE_PROCBASED_CTLS,
			       PROCBASED_CTLS_ONE_SETTING,
			       PROCBASED_CTLS_ZERO_SETTING, &procbased_ctls);
	if (error) {
		printf("vmx_init: processor does not support desired primary "
		       "processor-based controls\n");
		return (error);
	}

	/* Clear the processor-based ctl bits that are set on demand */
	procbased_ctls &= ~PROCBASED_CTLS_WINDOW_SETTING;

	/* Check support for secondary processor-based VM-execution controls */
	error = vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2,
			       MSR_VMX_PROCBASED_CTLS2,
			       PROCBASED_CTLS2_ONE_SETTING,
			       PROCBASED_CTLS2_ZERO_SETTING, &procbased_ctls2);
	if (error) {
		printf("vmx_init: processor does not support desired secondary "
		       "processor-based controls\n");
		return (error);
	}

	/* Check support for VPID */
	error = vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2, MSR_VMX_PROCBASED_CTLS2,
			       PROCBASED2_ENABLE_VPID, 0, &tmp);
	if (error == 0)
		procbased_ctls2 |= PROCBASED2_ENABLE_VPID;

	/* Check support for pin-based VM-execution controls */
	error = vmx_set_ctlreg(MSR_VMX_PINBASED_CTLS,
			       MSR_VMX_TRUE_PINBASED_CTLS,
			       PINBASED_CTLS_ONE_SETTING,
			       PINBASED_CTLS_ZERO_SETTING, &pinbased_ctls);
	if (error) {
		printf("vmx_init: processor does not support desired "
		       "pin-based controls\n");
		return (error);
	}

	/* Check support for VM-exit controls */
	error = vmx_set_ctlreg(MSR_VMX_EXIT_CTLS, MSR_VMX_TRUE_EXIT_CTLS,
			       VM_EXIT_CTLS_ONE_SETTING,
			       VM_EXIT_CTLS_ZERO_SETTING,
			       &exit_ctls);
	if (error) {
		printf("vmx_init: processor does not support desired "
		    "exit controls\n");
		return (error);
	}

	/* Check support for VM-entry controls */
	error = vmx_set_ctlreg(MSR_VMX_ENTRY_CTLS, MSR_VMX_TRUE_ENTRY_CTLS,
	    VM_ENTRY_CTLS_ONE_SETTING, VM_ENTRY_CTLS_ZERO_SETTING,
	    &entry_ctls);
	if (error) {
		printf("vmx_init: processor does not support desired "
		    "entry controls\n");
		return (error);
	}

	/*
	 * Check support for optional features by testing them
	 * as individual bits
	 */
	cap_halt_exit = (vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,
					MSR_VMX_TRUE_PROCBASED_CTLS,
					PROCBASED_HLT_EXITING, 0,
					&tmp) == 0);

	cap_monitor_trap = (vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,
					MSR_VMX_PROCBASED_CTLS,
					PROCBASED_MTF, 0,
					&tmp) == 0);

	cap_pause_exit = (vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,
					 MSR_VMX_TRUE_PROCBASED_CTLS,
					 PROCBASED_PAUSE_EXITING, 0,
					 &tmp) == 0);

	cap_unrestricted_guest = (vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2,
					MSR_VMX_PROCBASED_CTLS2,
					PROCBASED2_UNRESTRICTED_GUEST, 0,
				        &tmp) == 0);

	cap_invpcid = (vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2,
	    MSR_VMX_PROCBASED_CTLS2, PROCBASED2_ENABLE_INVPCID, 0,
	    &tmp) == 0);

	/*
	 * Check support for virtual interrupt delivery.
	 */
	procbased2_vid_bits = (PROCBASED2_VIRTUALIZE_APIC_ACCESSES |
	    PROCBASED2_VIRTUALIZE_X2APIC_MODE |
	    PROCBASED2_APIC_REGISTER_VIRTUALIZATION |
	    PROCBASED2_VIRTUAL_INTERRUPT_DELIVERY);

	use_tpr_shadow = (vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,
	    MSR_VMX_TRUE_PROCBASED_CTLS, PROCBASED_USE_TPR_SHADOW, 0,
	    &tmp) == 0);

	error = vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2, MSR_VMX_PROCBASED_CTLS2,
	    procbased2_vid_bits, 0, &tmp);
	if (error == 0 && use_tpr_shadow) {
		virtual_interrupt_delivery = 1;
		TUNABLE_INT_FETCH("hw.vmm.vmx.use_apic_vid",
		    &virtual_interrupt_delivery);
	}

	if (virtual_interrupt_delivery) {
		procbased_ctls |= PROCBASED_USE_TPR_SHADOW;
		procbased_ctls2 |= procbased2_vid_bits;
		procbased_ctls2 &= ~PROCBASED2_VIRTUALIZE_X2APIC_MODE;

		/*
		 * No need to emulate accesses to %CR8 if virtual
		 * interrupt delivery is enabled.
		 */
		procbased_ctls &= ~PROCBASED_CR8_LOAD_EXITING;
		procbased_ctls &= ~PROCBASED_CR8_STORE_EXITING;

		/*
		 * Check for Posted Interrupts only if Virtual Interrupt
		 * Delivery is enabled.
		 */
		error = vmx_set_ctlreg(MSR_VMX_PINBASED_CTLS,
		    MSR_VMX_TRUE_PINBASED_CTLS, PINBASED_POSTED_INTERRUPT, 0,
		    &tmp);
		if (error == 0) {
			pirvec = lapic_ipi_alloc(pti ? &IDTVEC(justreturn1_pti) :
			    &IDTVEC(justreturn));
			if (pirvec < 0) {
				if (bootverbose) {
					printf("vmx_init: unable to allocate "
					    "posted interrupt vector\n");
				}
			} else {
				posted_interrupts = 1;
				TUNABLE_INT_FETCH("hw.vmm.vmx.use_apic_pir",
				    &posted_interrupts);
			}
		}
	}

	if (posted_interrupts)
		    pinbased_ctls |= PINBASED_POSTED_INTERRUPT;

	/* Initialize EPT */
	error = ept_init(ipinum);
	if (error) {
		printf("vmx_init: ept initialization failed (%d)\n", error);
		return (error);
	}

	guest_l1d_flush = (cpu_ia32_arch_caps & IA32_ARCH_CAP_RDCL_NO) == 0;
	TUNABLE_INT_FETCH("hw.vmm.l1d_flush", &guest_l1d_flush);
	if (guest_l1d_flush &&
	    (cpu_stdext_feature3 & CPUID_STDEXT3_L1D_FLUSH) != 0)
		vmx_msr_flush_cmd = IA32_FLUSH_CMD_L1D;

	/*
	 * Stash the cr0 and cr4 bits that must be fixed to 0 or 1
	 */
	fixed0 = rdmsr(MSR_VMX_CR0_FIXED0);
	fixed1 = rdmsr(MSR_VMX_CR0_FIXED1);
	cr0_ones_mask = fixed0 & fixed1;
	cr0_zeros_mask = ~fixed0 & ~fixed1;

	/*
	 * CR0_PE and CR0_PG can be set to zero in VMX non-root operation
	 * if unrestricted guest execution is allowed.
	 */
	if (cap_unrestricted_guest)
		cr0_ones_mask &= ~(CR0_PG | CR0_PE);

	/*
	 * Do not allow the guest to set CR0_NW or CR0_CD.
	 */
	cr0_zeros_mask |= (CR0_NW | CR0_CD);

	fixed0 = rdmsr(MSR_VMX_CR4_FIXED0);
	fixed1 = rdmsr(MSR_VMX_CR4_FIXED1);
	cr4_ones_mask = fixed0 & fixed1;
	cr4_zeros_mask = ~fixed0 & ~fixed1;

	vpid_init();

	vmx_msr_init();

	/* enable VMX operation */
	smp_rendezvous(NULL, vmx_enable, NULL, NULL);

	vmx_initialized = 1;

	return (0);
}
-----children-----
1,2
1,3
1,4
3,4
3,5
5,6
5,7
7,8
9,10
9,11
9,12
9,13
9,14
9,15
9,16
9,17
9,18
9,19
9,20
9,21
9,22
9,23
9,24
9,25
9,26
9,27
9,28
9,29
9,30
9,31
9,32
9,33
9,34
9,35
9,36
9,37
9,38
9,39
9,40
9,41
9,42
9,43
9,44
9,45
9,46
9,47
9,48
9,49
9,50
9,51
9,52
9,53
9,54
9,55
9,56
9,57
9,58
9,59
9,60
9,61
10,11
11,12
11,13
11,14
13,14
15,16
17,18
18,19
18,20
18,21
18,22
18,23
19,20
21,22
23,24
25,26
27,28
29,30
30,31
30,32
30,33
31,32
33,34
35,36
37,38
37,39
38,39
39,40
40,41
40,42
41,42
43,44
45,46
45,47
46,47
47,48
47,49
48,49
51,52
52,53
53,54
55,56
56,57
56,58
57,58
59,60
59,61
60,61
62,63
64,65
64,66
65,66
65,67
66,67
66,68
67,68
68,69
68,70
69,70
71,72
74,75
74,76
75,76
76,77
76,78
77,78
79,80
82,83
82,84
83,84
84,85
84,86
85,86
88,89
89,90
90,91
92,93
93,94
93,95
94,95
96,97
96,98
97,98
99,100
101,102
101,103
102,103
102,104
103,104
104,105
104,106
105,106
107,108
108,109
108,110
112,113
112,114
113,114
114,115
114,116
115,116
118,119
119,120
120,121
122,123
123,124
123,125
124,125
126,127
126,128
126,129
126,130
126,131
126,132
127,128
129,130
131,132
133,134
135,136
137,138
138,139
140,141
140,142
141,142
143,144
143,145
144,145
145,146
145,147
146,147
149,150
150,151
151,152
153,154
154,155
154,156
155,156
157,158
158,159
160,161
161,162
161,163
162,163
164,165
164,166
164,167
164,168
164,169
164,170
165,166
167,168
169,170
171,172
173,174
175,176
176,177
178,179
178,180
179,180
181,182
181,183
182,183
183,184
183,185
184,185
187,188
188,189
189,190
191,192
192,193
192,194
193,194
195,196
195,197
195,198
195,199
195,200
195,201
196,197
198,199
200,201
202,203
205,206
206,207
208,209
208,210
209,210
209,211
210,211
213,214
214,215
214,216
215,216
217,218
219,220
220,221
220,222
221,222
223,224
223,225
223,226
223,227
223,228
223,229
224,225
226,227
228,229
230,231
232,233
234,235
235,236
237,238
237,239
238,239
240,241
240,242
241,242
242,243
242,244
243,244
246,247
247,248
248,249
250,251
251,252
251,253
252,253
254,255
254,256
254,257
254,258
254,259
254,260
255,256
257,258
259,260
261,262
263,264
265,266
266,267
268,269
268,270
269,270
271,272
271,273
272,273
273,274
273,275
274,275
277,278
278,279
279,280
281,282
282,283
282,284
283,284
285,286
285,287
285,288
285,289
285,290
285,291
286,287
288,289
290,291
292,293
294,295
296,297
297,298
299,300
299,301
300,301
302,303
302,304
303,304
304,305
304,306
305,306
308,309
309,310
310,311
312,313
313,314
313,315
314,315
316,317
317,318
317,319
318,319
318,320
318,321
318,322
318,323
318,324
319,320
321,322
323,324
325,326
328,329
329,330
332,333
333,334
333,335
334,335
336,337
337,338
337,339
338,339
338,340
338,341
338,342
338,343
338,344
339,340
341,342
343,344
345,346
348,349
349,350
352,353
353,354
353,355
354,355
356,357
357,358
357,359
358,359
358,360
358,361
358,362
358,363
358,364
359,360
361,362
363,364
365,366
368,369
369,370
372,373
373,374
373,375
374,375
376,377
377,378
377,379
378,379
378,380
378,381
378,382
378,383
378,384
379,380
381,382
383,384
385,386
388,389
389,390
392,393
393,394
393,395
394,395
396,397
397,398
397,399
398,399
398,400
398,401
398,402
398,403
398,404
399,400
401,402
403,404
405,406
408,409
409,410
412,413
413,414
413,415
414,415
416,417
417,418
417,419
418,419
418,420
419,420
419,421
420,421
422,423
424,425
426,427
428,429
429,430
429,431
430,431
432,433
433,434
433,435
434,435
434,436
434,437
434,438
434,439
434,440
435,436
437,438
439,440
441,442
444,445
445,446
448,449
449,450
449,451
450,451
452,453
452,454
452,455
452,456
452,457
452,458
453,454
455,456
457,458
459,460
462,463
463,464
465,466
465,467
466,467
466,468
467,468
467,469
468,469
471,472
473,474
473,475
474,475
475,476
475,477
476,477
479,480
480,481
480,482
480,483
481,482
484,485
485,486
487,488
487,489
488,489
490,491
490,492
490,493
490,494
490,495
490,496
490,497
491,492
492,493
492,494
493,494
495,496
497,498
498,499
498,500
499,500
501,502
503,504
504,505
504,506
505,506
507,508
508,509
510,511
511,512
511,513
512,513
514,515
515,516
517,518
518,519
518,520
519,520
521,522
522,523
524,525
525,526
525,527
526,527
528,529
528,530
528,531
528,532
528,533
528,534
529,530
531,532
533,534
535,536
538,539
539,540
541,542
541,543
542,543
542,544
543,544
546,547
546,548
547,548
548,549
548,550
549,550
551,552
551,553
552,553
554,555
554,556
554,557
555,556
557,558
558,559
558,560
559,560
561,562
563,564
564,565
564,566
565,566
567,568
569,570
569,571
569,572
570,571
570,572
571,572
574,575
575,576
575,577
576,577
578,579
579,580
580,581
580,582
581,582
584,585
584,586
585,586
586,587
586,588
587,588
590,591
591,592
591,593
591,594
592,593
595,596
596,597
598,599
598,600
599,600
601,602
602,603
602,604
603,604
605,606
607,608
608,609
608,610
609,610
611,612
611,613
612,613
614,615
616,617
616,618
617,618
619,620
619,621
620,621
621,622
621,623
621,624
622,623
625,626
627,628
628,629
629,630
631,632
632,633
632,634
633,634
635,636
635,637
636,637
637,638
637,639
638,639
640,641
643,644
644,645
644,646
644,647
645,646
648,649
649,650
651,652
651,653
652,653
652,654
653,654
655,656
655,657
656,657
657,658
657,659
658,659
660,661
663,664
664,665
664,666
665,666
667,668
669,670
670,671
670,672
671,672
673,674
673,675
674,675
676,677
678,679
679,680
679,681
680,681
682,683
682,684
683,684
685,686
687,688
688,689
688,690
689,690
691,692
691,693
692,693
694,695
696,697
697,698
697,699
698,699
700,701
700,702
701,702
702,703
704,705
705,706
707,708
707,709
708,709
710,711
711,712
711,713
712,713
714,715
715,716
716,717
716,718
717,718
719,720
721,722
722,723
722,724
723,724
725,726
726,727
726,728
727,728
729,730
731,732
732,733
732,734
733,734
735,736
735,737
736,737
738,739
740,741
741,742
741,743
742,743
744,745
744,746
745,746
747,748
749,750
750,751
750,752
751,752
753,754
753,755
754,755
756,757
758,759
759,760
759,761
760,761
762,763
762,764
763,764
764,765
766,767
767,768
769,770
770,771
771,772
773,774
774,775
775,776
777,778
778,779
778,780
778,781
778,782
778,783
779,780
781,782
783,784
785,786
787,788
789,790
790,791
790,792
791,792
794,795
795,796
-----nextToken-----
2,4,6,8,12,14,16,20,22,24,26,28,32,34,36,42,44,49,50,54,58,61,63,70,72,73,78,80,81,86,87,91,95,98,100,106,109,110,111,116,117,121,125,128,130,132,134,136,139,142,147,148,152,156,159,163,166,168,170,172,174,177,180,185,186,190,194,197,199,201,203,204,207,211,212,216,218,222,225,227,229,231,233,236,239,244,245,249,253,256,258,260,262,264,267,270,275,276,280,284,287,289,291,293,295,298,301,306,307,311,315,320,322,324,326,327,330,331,335,340,342,344,346,347,350,351,355,360,362,364,366,367,370,371,375,380,382,384,386,387,390,391,395,400,402,404,406,407,410,411,415,421,423,425,427,431,436,438,440,442,443,446,447,451,454,456,458,460,461,464,469,470,472,477,478,482,483,486,489,494,496,500,502,506,509,513,516,520,523,527,530,532,534,536,537,540,544,545,550,553,556,560,562,566,568,572,573,577,582,583,588,589,593,594,597,600,604,606,610,613,615,618,623,624,626,630,634,639,641,642,646,647,650,654,659,661,662,666,668,672,675,677,681,684,686,690,693,695,699,703,706,709,713,718,720,724,728,730,734,737,739,743,746,748,752,755,757,761,765,768,772,776,780,782,784,786,788,792,793,796
-----computeFrom-----
40,41
40,42
56,57
56,58
65,66
65,67
66,67
66,68
68,69
68,70
74,75
74,76
76,77
76,78
93,94
93,95
102,103
102,104
104,105
104,106
108,109
108,110
123,124
123,125
154,155
154,156
161,162
161,163
192,193
192,194
209,210
209,211
214,215
214,216
220,221
220,222
251,252
251,253
282,283
282,284
313,314
313,315
317,318
317,319
333,334
333,335
337,338
337,339
353,354
353,355
357,358
357,359
373,374
373,375
377,378
377,379
393,394
393,395
397,398
397,399
413,414
413,415
417,418
417,419
418,419
418,420
419,420
419,421
429,430
429,431
433,434
433,435
449,450
449,451
466,467
466,468
467,468
467,469
475,476
475,477
492,493
492,494
498,499
498,500
504,505
504,506
511,512
511,513
518,519
518,520
525,526
525,527
542,543
542,544
548,549
548,550
570,571
570,572
586,587
586,588
602,603
602,604
608,609
608,610
632,633
632,634
635,636
635,637
637,638
637,639
652,653
652,654
655,656
655,657
657,658
657,659
664,665
664,666
670,671
670,672
679,680
679,681
688,689
688,690
691,692
691,693
697,698
697,699
700,701
700,702
711,712
711,713
716,717
716,718
722,723
722,724
726,727
726,728
732,733
732,734
741,742
741,743
750,751
750,752
753,754
753,755
759,760
759,761
762,763
762,764
790,791
790,792
-----guardedBy-----
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;Declarator;Name;Declarator;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;Declarator;Name;IfStatement;UnaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ReturnStatement;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ReturnStatement;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;UnaryExpression;BinaryExpression;LiteralExpression;LiteralExpression;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ReturnStatement;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ReturnStatement;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ReturnStatement;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ReturnStatement;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ReturnStatement;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ReturnStatement;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;UnaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;UnaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;UnaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;UnaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;UnaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;UnaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;UnaryExpression;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;ConditionalExpression;IdExpression;Name;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;UnaryExpression;IdExpression;Name;IfStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;ReturnStatement;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ReturnStatement;UnaryExpression;LiteralExpression;
-----ast_node-----
static intvmx_init(int ipinum){	int error, use_tpr_shadow;	uint64_t basic, fixed0, fixed1, feature_control;	uint32_t tmp, procbased2_vid_bits;	/* CPUID.1:ECX[bit 5] must be 1 for processor to support VMX */	if (!(cpu_feature2 & CPUID2_VMX)) {		printf("vmx_init: processor does not support VMX operation\n");		return (ENXIO);	}	/*	 * Verify that MSR_IA32_FEATURE_CONTROL lock and VMXON enable bits	 * are set (bits 0 and 2 respectively).	 */	feature_control = rdmsr(MSR_IA32_FEATURE_CONTROL);	if ((feature_control & IA32_FEATURE_CONTROL_LOCK) == 1 &&	    (feature_control & IA32_FEATURE_CONTROL_VMX_EN) == 0) {		printf("vmx_init: VMX operation disabled by BIOS\n");		return (ENXIO);	}	/*	 * Verify capabilities MSR_VMX_BASIC:	 * - bit 54 indicates support for INS/OUTS decoding	 */	basic = rdmsr(MSR_VMX_BASIC);	if ((basic & (1UL << 54)) == 0) {		printf("vmx_init: processor does not support desired basic "		    "capabilities\n");		return (EINVAL);	}	/* Check support for primary processor-based VM-execution controls */	error = vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,			       MSR_VMX_TRUE_PROCBASED_CTLS,			       PROCBASED_CTLS_ONE_SETTING,			       PROCBASED_CTLS_ZERO_SETTING, &procbased_ctls);	if (error) {		printf("vmx_init: processor does not support desired primary "		       "processor-based controls\n");		return (error);	}	/* Clear the processor-based ctl bits that are set on demand */	procbased_ctls &= ~PROCBASED_CTLS_WINDOW_SETTING;	/* Check support for secondary processor-based VM-execution controls */	error = vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2,			       MSR_VMX_PROCBASED_CTLS2,			       PROCBASED_CTLS2_ONE_SETTING,			       PROCBASED_CTLS2_ZERO_SETTING, &procbased_ctls2);	if (error) {		printf("vmx_init: processor does not support desired secondary "		       "processor-based controls\n");		return (error);	}	/* Check support for VPID */	error = vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2, MSR_VMX_PROCBASED_CTLS2,			       PROCBASED2_ENABLE_VPID, 0, &tmp);	if (error == 0)		procbased_ctls2 |= PROCBASED2_ENABLE_VPID;	/* Check support for pin-based VM-execution controls */	error = vmx_set_ctlreg(MSR_VMX_PINBASED_CTLS,			       MSR_VMX_TRUE_PINBASED_CTLS,			       PINBASED_CTLS_ONE_SETTING,			       PINBASED_CTLS_ZERO_SETTING, &pinbased_ctls);	if (error) {		printf("vmx_init: processor does not support desired "		       "pin-based controls\n");		return (error);	}	/* Check support for VM-exit controls */	error = vmx_set_ctlreg(MSR_VMX_EXIT_CTLS, MSR_VMX_TRUE_EXIT_CTLS,			       VM_EXIT_CTLS_ONE_SETTING,			       VM_EXIT_CTLS_ZERO_SETTING,			       &exit_ctls);	if (error) {		printf("vmx_init: processor does not support desired "		    "exit controls\n");		return (error);	}	/* Check support for VM-entry controls */	error = vmx_set_ctlreg(MSR_VMX_ENTRY_CTLS, MSR_VMX_TRUE_ENTRY_CTLS,	    VM_ENTRY_CTLS_ONE_SETTING, VM_ENTRY_CTLS_ZERO_SETTING,	    &entry_ctls);	if (error) {		printf("vmx_init: processor does not support desired "		    "entry controls\n");		return (error);	}	/*	 * Check support for optional features by testing them	 * as individual bits	 */	cap_halt_exit = (vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,					MSR_VMX_TRUE_PROCBASED_CTLS,					PROCBASED_HLT_EXITING, 0,					&tmp) == 0);	cap_monitor_trap = (vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,					MSR_VMX_PROCBASED_CTLS,					PROCBASED_MTF, 0,					&tmp) == 0);	cap_pause_exit = (vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,					 MSR_VMX_TRUE_PROCBASED_CTLS,					 PROCBASED_PAUSE_EXITING, 0,					 &tmp) == 0);	cap_unrestricted_guest = (vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2,					MSR_VMX_PROCBASED_CTLS2,					PROCBASED2_UNRESTRICTED_GUEST, 0,				        &tmp) == 0);	cap_invpcid = (vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2,	    MSR_VMX_PROCBASED_CTLS2, PROCBASED2_ENABLE_INVPCID, 0,	    &tmp) == 0);	/*	 * Check support for virtual interrupt delivery.	 */	procbased2_vid_bits = (PROCBASED2_VIRTUALIZE_APIC_ACCESSES |	    PROCBASED2_VIRTUALIZE_X2APIC_MODE |	    PROCBASED2_APIC_REGISTER_VIRTUALIZATION |	    PROCBASED2_VIRTUAL_INTERRUPT_DELIVERY);	use_tpr_shadow = (vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,	    MSR_VMX_TRUE_PROCBASED_CTLS, PROCBASED_USE_TPR_SHADOW, 0,	    &tmp) == 0);	error = vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2, MSR_VMX_PROCBASED_CTLS2,	    procbased2_vid_bits, 0, &tmp);	if (error == 0 && use_tpr_shadow) {		virtual_interrupt_delivery = 1;		TUNABLE_INT_FETCH("hw.vmm.vmx.use_apic_vid",		    &virtual_interrupt_delivery);	}	if (virtual_interrupt_delivery) {		procbased_ctls |= PROCBASED_USE_TPR_SHADOW;		procbased_ctls2 |= procbased2_vid_bits;		procbased_ctls2 &= ~PROCBASED2_VIRTUALIZE_X2APIC_MODE;		/*		 * No need to emulate accesses to %CR8 if virtual		 * interrupt delivery is enabled.		 */		procbased_ctls &= ~PROCBASED_CR8_LOAD_EXITING;		procbased_ctls &= ~PROCBASED_CR8_STORE_EXITING;		/*		 * Check for Posted Interrupts only if Virtual Interrupt		 * Delivery is enabled.		 */		error = vmx_set_ctlreg(MSR_VMX_PINBASED_CTLS,		    MSR_VMX_TRUE_PINBASED_CTLS, PINBASED_POSTED_INTERRUPT, 0,		    &tmp);		if (error == 0) {			pirvec = lapic_ipi_alloc(pti ? &IDTVEC(justreturn1_pti) :			    &IDTVEC(justreturn));			if (pirvec < 0) {				if (bootverbose) {					printf("vmx_init: unable to allocate "					    "posted interrupt vector\n");				}			} else {				posted_interrupts = 1;				TUNABLE_INT_FETCH("hw.vmm.vmx.use_apic_pir",				    &posted_interrupts);			}		}	}	if (posted_interrupts)		    pinbased_ctls |= PINBASED_POSTED_INTERRUPT;	/* Initialize EPT */	error = ept_init(ipinum);	if (error) {		printf("vmx_init: ept initialization failed (%d)\n", error);		return (error);	}	guest_l1d_flush = (cpu_ia32_arch_caps & IA32_ARCH_CAP_RDCL_NO) == 0;	TUNABLE_INT_FETCH("hw.vmm.l1d_flush", &guest_l1d_flush);	if (guest_l1d_flush &&	    (cpu_stdext_feature3 & CPUID_STDEXT3_L1D_FLUSH) != 0)		vmx_msr_flush_cmd = IA32_FLUSH_CMD_L1D;	/*	 * Stash the cr0 and cr4 bits that must be fixed to 0 or 1	 */	fixed0 = rdmsr(MSR_VMX_CR0_FIXED0);	fixed1 = rdmsr(MSR_VMX_CR0_FIXED1);	cr0_ones_mask = fixed0 & fixed1;	cr0_zeros_mask = ~fixed0 & ~fixed1;	/*	 * CR0_PE and CR0_PG can be set to zero in VMX non-root operation	 * if unrestricted guest execution is allowed.	 */	if (cap_unrestricted_guest)		cr0_ones_mask &= ~(CR0_PG | CR0_PE);	/*	 * Do not allow the guest to set CR0_NW or CR0_CD.	 */	cr0_zeros_mask |= (CR0_NW | CR0_CD);	fixed0 = rdmsr(MSR_VMX_CR4_FIXED0);	fixed1 = rdmsr(MSR_VMX_CR4_FIXED1);	cr4_ones_mask = fixed0 & fixed1;	cr4_zeros_mask = ~fixed0 & ~fixed1;	vpid_init();	vmx_msr_init();	/* enable VMX operation */	smp_rendezvous(NULL, vmx_enable, NULL, NULL);	vmx_initialized = 1;	return (0);}
static int
vmx_init(int ipinum)
vmx_init
int ipinum
int
ipinum
ipinum
{	int error, use_tpr_shadow;	uint64_t basic, fixed0, fixed1, feature_control;	uint32_t tmp, procbased2_vid_bits;	/* CPUID.1:ECX[bit 5] must be 1 for processor to support VMX */	if (!(cpu_feature2 & CPUID2_VMX)) {		printf("vmx_init: processor does not support VMX operation\n");		return (ENXIO);	}	/*	 * Verify that MSR_IA32_FEATURE_CONTROL lock and VMXON enable bits	 * are set (bits 0 and 2 respectively).	 */	feature_control = rdmsr(MSR_IA32_FEATURE_CONTROL);	if ((feature_control & IA32_FEATURE_CONTROL_LOCK) == 1 &&	    (feature_control & IA32_FEATURE_CONTROL_VMX_EN) == 0) {		printf("vmx_init: VMX operation disabled by BIOS\n");		return (ENXIO);	}	/*	 * Verify capabilities MSR_VMX_BASIC:	 * - bit 54 indicates support for INS/OUTS decoding	 */	basic = rdmsr(MSR_VMX_BASIC);	if ((basic & (1UL << 54)) == 0) {		printf("vmx_init: processor does not support desired basic "		    "capabilities\n");		return (EINVAL);	}	/* Check support for primary processor-based VM-execution controls */	error = vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,			       MSR_VMX_TRUE_PROCBASED_CTLS,			       PROCBASED_CTLS_ONE_SETTING,			       PROCBASED_CTLS_ZERO_SETTING, &procbased_ctls);	if (error) {		printf("vmx_init: processor does not support desired primary "		       "processor-based controls\n");		return (error);	}	/* Clear the processor-based ctl bits that are set on demand */	procbased_ctls &= ~PROCBASED_CTLS_WINDOW_SETTING;	/* Check support for secondary processor-based VM-execution controls */	error = vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2,			       MSR_VMX_PROCBASED_CTLS2,			       PROCBASED_CTLS2_ONE_SETTING,			       PROCBASED_CTLS2_ZERO_SETTING, &procbased_ctls2);	if (error) {		printf("vmx_init: processor does not support desired secondary "		       "processor-based controls\n");		return (error);	}	/* Check support for VPID */	error = vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2, MSR_VMX_PROCBASED_CTLS2,			       PROCBASED2_ENABLE_VPID, 0, &tmp);	if (error == 0)		procbased_ctls2 |= PROCBASED2_ENABLE_VPID;	/* Check support for pin-based VM-execution controls */	error = vmx_set_ctlreg(MSR_VMX_PINBASED_CTLS,			       MSR_VMX_TRUE_PINBASED_CTLS,			       PINBASED_CTLS_ONE_SETTING,			       PINBASED_CTLS_ZERO_SETTING, &pinbased_ctls);	if (error) {		printf("vmx_init: processor does not support desired "		       "pin-based controls\n");		return (error);	}	/* Check support for VM-exit controls */	error = vmx_set_ctlreg(MSR_VMX_EXIT_CTLS, MSR_VMX_TRUE_EXIT_CTLS,			       VM_EXIT_CTLS_ONE_SETTING,			       VM_EXIT_CTLS_ZERO_SETTING,			       &exit_ctls);	if (error) {		printf("vmx_init: processor does not support desired "		    "exit controls\n");		return (error);	}	/* Check support for VM-entry controls */	error = vmx_set_ctlreg(MSR_VMX_ENTRY_CTLS, MSR_VMX_TRUE_ENTRY_CTLS,	    VM_ENTRY_CTLS_ONE_SETTING, VM_ENTRY_CTLS_ZERO_SETTING,	    &entry_ctls);	if (error) {		printf("vmx_init: processor does not support desired "		    "entry controls\n");		return (error);	}	/*	 * Check support for optional features by testing them	 * as individual bits	 */	cap_halt_exit = (vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,					MSR_VMX_TRUE_PROCBASED_CTLS,					PROCBASED_HLT_EXITING, 0,					&tmp) == 0);	cap_monitor_trap = (vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,					MSR_VMX_PROCBASED_CTLS,					PROCBASED_MTF, 0,					&tmp) == 0);	cap_pause_exit = (vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,					 MSR_VMX_TRUE_PROCBASED_CTLS,					 PROCBASED_PAUSE_EXITING, 0,					 &tmp) == 0);	cap_unrestricted_guest = (vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2,					MSR_VMX_PROCBASED_CTLS2,					PROCBASED2_UNRESTRICTED_GUEST, 0,				        &tmp) == 0);	cap_invpcid = (vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2,	    MSR_VMX_PROCBASED_CTLS2, PROCBASED2_ENABLE_INVPCID, 0,	    &tmp) == 0);	/*	 * Check support for virtual interrupt delivery.	 */	procbased2_vid_bits = (PROCBASED2_VIRTUALIZE_APIC_ACCESSES |	    PROCBASED2_VIRTUALIZE_X2APIC_MODE |	    PROCBASED2_APIC_REGISTER_VIRTUALIZATION |	    PROCBASED2_VIRTUAL_INTERRUPT_DELIVERY);	use_tpr_shadow = (vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,	    MSR_VMX_TRUE_PROCBASED_CTLS, PROCBASED_USE_TPR_SHADOW, 0,	    &tmp) == 0);	error = vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2, MSR_VMX_PROCBASED_CTLS2,	    procbased2_vid_bits, 0, &tmp);	if (error == 0 && use_tpr_shadow) {		virtual_interrupt_delivery = 1;		TUNABLE_INT_FETCH("hw.vmm.vmx.use_apic_vid",		    &virtual_interrupt_delivery);	}	if (virtual_interrupt_delivery) {		procbased_ctls |= PROCBASED_USE_TPR_SHADOW;		procbased_ctls2 |= procbased2_vid_bits;		procbased_ctls2 &= ~PROCBASED2_VIRTUALIZE_X2APIC_MODE;		/*		 * No need to emulate accesses to %CR8 if virtual		 * interrupt delivery is enabled.		 */		procbased_ctls &= ~PROCBASED_CR8_LOAD_EXITING;		procbased_ctls &= ~PROCBASED_CR8_STORE_EXITING;		/*		 * Check for Posted Interrupts only if Virtual Interrupt		 * Delivery is enabled.		 */		error = vmx_set_ctlreg(MSR_VMX_PINBASED_CTLS,		    MSR_VMX_TRUE_PINBASED_CTLS, PINBASED_POSTED_INTERRUPT, 0,		    &tmp);		if (error == 0) {			pirvec = lapic_ipi_alloc(pti ? &IDTVEC(justreturn1_pti) :			    &IDTVEC(justreturn));			if (pirvec < 0) {				if (bootverbose) {					printf("vmx_init: unable to allocate "					    "posted interrupt vector\n");				}			} else {				posted_interrupts = 1;				TUNABLE_INT_FETCH("hw.vmm.vmx.use_apic_pir",				    &posted_interrupts);			}		}	}	if (posted_interrupts)		    pinbased_ctls |= PINBASED_POSTED_INTERRUPT;	/* Initialize EPT */	error = ept_init(ipinum);	if (error) {		printf("vmx_init: ept initialization failed (%d)\n", error);		return (error);	}	guest_l1d_flush = (cpu_ia32_arch_caps & IA32_ARCH_CAP_RDCL_NO) == 0;	TUNABLE_INT_FETCH("hw.vmm.l1d_flush", &guest_l1d_flush);	if (guest_l1d_flush &&	    (cpu_stdext_feature3 & CPUID_STDEXT3_L1D_FLUSH) != 0)		vmx_msr_flush_cmd = IA32_FLUSH_CMD_L1D;	/*	 * Stash the cr0 and cr4 bits that must be fixed to 0 or 1	 */	fixed0 = rdmsr(MSR_VMX_CR0_FIXED0);	fixed1 = rdmsr(MSR_VMX_CR0_FIXED1);	cr0_ones_mask = fixed0 & fixed1;	cr0_zeros_mask = ~fixed0 & ~fixed1;	/*	 * CR0_PE and CR0_PG can be set to zero in VMX non-root operation	 * if unrestricted guest execution is allowed.	 */	if (cap_unrestricted_guest)		cr0_ones_mask &= ~(CR0_PG | CR0_PE);	/*	 * Do not allow the guest to set CR0_NW or CR0_CD.	 */	cr0_zeros_mask |= (CR0_NW | CR0_CD);	fixed0 = rdmsr(MSR_VMX_CR4_FIXED0);	fixed1 = rdmsr(MSR_VMX_CR4_FIXED1);	cr4_ones_mask = fixed0 & fixed1;	cr4_zeros_mask = ~fixed0 & ~fixed1;	vpid_init();	vmx_msr_init();	/* enable VMX operation */	smp_rendezvous(NULL, vmx_enable, NULL, NULL);	vmx_initialized = 1;	return (0);}
int error, use_tpr_shadow;
int error, use_tpr_shadow;
int
error
error
use_tpr_shadow
use_tpr_shadow
uint64_t basic, fixed0, fixed1, feature_control;
uint64_t basic, fixed0, fixed1, feature_control;
uint64_t
uint64_t
basic
basic
fixed0
fixed0
fixed1
fixed1
feature_control
feature_control
uint32_t tmp, procbased2_vid_bits;
uint32_t tmp, procbased2_vid_bits;
uint32_t
uint32_t
tmp
tmp
procbased2_vid_bits
procbased2_vid_bits
if (!(cpu_feature2 & CPUID2_VMX)) {		printf("vmx_init: processor does not support VMX operation\n");		return (ENXIO);	}
!(cpu_feature2 & CPUID2_VMX)
(cpu_feature2 & CPUID2_VMX)
cpu_feature2 & CPUID2_VMX
cpu_feature2
cpu_feature2
CPUID2_VMX
CPUID2_VMX
{		printf("vmx_init: processor does not support VMX operation\n");		return (ENXIO);	}
printf("vmx_init: processor does not support VMX operation\n");
printf("vmx_init: processor does not support VMX operation\n")
printf
printf
"vmx_init: processor does not support VMX operation\n"
return (ENXIO);
(ENXIO)
ENXIO
ENXIO
feature_control = rdmsr(MSR_IA32_FEATURE_CONTROL);
feature_control = rdmsr(MSR_IA32_FEATURE_CONTROL)
feature_control
feature_control
rdmsr(MSR_IA32_FEATURE_CONTROL)
rdmsr
rdmsr
MSR_IA32_FEATURE_CONTROL
MSR_IA32_FEATURE_CONTROL
if ((feature_control & IA32_FEATURE_CONTROL_LOCK) == 1 &&	    (feature_control & IA32_FEATURE_CONTROL_VMX_EN) == 0) {		printf("vmx_init: VMX operation disabled by BIOS\n");		return (ENXIO);	}
(feature_control & IA32_FEATURE_CONTROL_LOCK) == 1 &&	    (feature_control & IA32_FEATURE_CONTROL_VMX_EN) == 0
(feature_control & IA32_FEATURE_CONTROL_LOCK) == 1
(feature_control & IA32_FEATURE_CONTROL_LOCK)
feature_control & IA32_FEATURE_CONTROL_LOCK
feature_control
feature_control
IA32_FEATURE_CONTROL_LOCK
IA32_FEATURE_CONTROL_LOCK
1
(feature_control & IA32_FEATURE_CONTROL_VMX_EN) == 0
(feature_control & IA32_FEATURE_CONTROL_VMX_EN)
feature_control & IA32_FEATURE_CONTROL_VMX_EN
feature_control
feature_control
IA32_FEATURE_CONTROL_VMX_EN
IA32_FEATURE_CONTROL_VMX_EN
0
{		printf("vmx_init: VMX operation disabled by BIOS\n");		return (ENXIO);	}
printf("vmx_init: VMX operation disabled by BIOS\n");
printf("vmx_init: VMX operation disabled by BIOS\n")
printf
printf
"vmx_init: VMX operation disabled by BIOS\n"
return (ENXIO);
(ENXIO)
ENXIO
ENXIO
basic = rdmsr(MSR_VMX_BASIC);
basic = rdmsr(MSR_VMX_BASIC)
basic
basic
rdmsr(MSR_VMX_BASIC)
rdmsr
rdmsr
MSR_VMX_BASIC
MSR_VMX_BASIC
if ((basic & (1UL << 54)) == 0) {		printf("vmx_init: processor does not support desired basic "		    "capabilities\n");		return (EINVAL);	}
(basic & (1UL << 54)) == 0
(basic & (1UL << 54))
basic & (1UL << 54)
basic
basic
(1UL << 54)
1UL << 54
1UL
54
0
{		printf("vmx_init: processor does not support desired basic "		    "capabilities\n");		return (EINVAL);	}
printf("vmx_init: processor does not support desired basic "		    "capabilities\n");
printf("vmx_init: processor does not support desired basic "		    "capabilities\n")
printf
printf
"vmx_init: processor does not support desired basic "		    "capabilities\n"
return (EINVAL);
(EINVAL)
EINVAL
EINVAL
error = vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,			       MSR_VMX_TRUE_PROCBASED_CTLS,			       PROCBASED_CTLS_ONE_SETTING,			       PROCBASED_CTLS_ZERO_SETTING, &procbased_ctls);
error = vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,			       MSR_VMX_TRUE_PROCBASED_CTLS,			       PROCBASED_CTLS_ONE_SETTING,			       PROCBASED_CTLS_ZERO_SETTING, &procbased_ctls)
error
error
vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,			       MSR_VMX_TRUE_PROCBASED_CTLS,			       PROCBASED_CTLS_ONE_SETTING,			       PROCBASED_CTLS_ZERO_SETTING, &procbased_ctls)
vmx_set_ctlreg
vmx_set_ctlreg
MSR_VMX_PROCBASED_CTLS
MSR_VMX_PROCBASED_CTLS
MSR_VMX_TRUE_PROCBASED_CTLS
MSR_VMX_TRUE_PROCBASED_CTLS
PROCBASED_CTLS_ONE_SETTING
PROCBASED_CTLS_ONE_SETTING
PROCBASED_CTLS_ZERO_SETTING
PROCBASED_CTLS_ZERO_SETTING
&procbased_ctls
procbased_ctls
procbased_ctls
if (error) {		printf("vmx_init: processor does not support desired primary "		       "processor-based controls\n");		return (error);	}
error
error
{		printf("vmx_init: processor does not support desired primary "		       "processor-based controls\n");		return (error);	}
printf("vmx_init: processor does not support desired primary "		       "processor-based controls\n");
printf("vmx_init: processor does not support desired primary "		       "processor-based controls\n")
printf
printf
"vmx_init: processor does not support desired primary "		       "processor-based controls\n"
return (error);
(error)
error
error
procbased_ctls &= ~PROCBASED_CTLS_WINDOW_SETTING;
procbased_ctls &= ~PROCBASED_CTLS_WINDOW_SETTING
procbased_ctls
procbased_ctls
~PROCBASED_CTLS_WINDOW_SETTING
PROCBASED_CTLS_WINDOW_SETTING
PROCBASED_CTLS_WINDOW_SETTING
error = vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2,			       MSR_VMX_PROCBASED_CTLS2,			       PROCBASED_CTLS2_ONE_SETTING,			       PROCBASED_CTLS2_ZERO_SETTING, &procbased_ctls2);
error = vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2,			       MSR_VMX_PROCBASED_CTLS2,			       PROCBASED_CTLS2_ONE_SETTING,			       PROCBASED_CTLS2_ZERO_SETTING, &procbased_ctls2)
error
error
vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2,			       MSR_VMX_PROCBASED_CTLS2,			       PROCBASED_CTLS2_ONE_SETTING,			       PROCBASED_CTLS2_ZERO_SETTING, &procbased_ctls2)
vmx_set_ctlreg
vmx_set_ctlreg
MSR_VMX_PROCBASED_CTLS2
MSR_VMX_PROCBASED_CTLS2
MSR_VMX_PROCBASED_CTLS2
MSR_VMX_PROCBASED_CTLS2
PROCBASED_CTLS2_ONE_SETTING
PROCBASED_CTLS2_ONE_SETTING
PROCBASED_CTLS2_ZERO_SETTING
PROCBASED_CTLS2_ZERO_SETTING
&procbased_ctls2
procbased_ctls2
procbased_ctls2
if (error) {		printf("vmx_init: processor does not support desired secondary "		       "processor-based controls\n");		return (error);	}
error
error
{		printf("vmx_init: processor does not support desired secondary "		       "processor-based controls\n");		return (error);	}
printf("vmx_init: processor does not support desired secondary "		       "processor-based controls\n");
printf("vmx_init: processor does not support desired secondary "		       "processor-based controls\n")
printf
printf
"vmx_init: processor does not support desired secondary "		       "processor-based controls\n"
return (error);
(error)
error
error
error = vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2, MSR_VMX_PROCBASED_CTLS2,			       PROCBASED2_ENABLE_VPID, 0, &tmp);
error = vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2, MSR_VMX_PROCBASED_CTLS2,			       PROCBASED2_ENABLE_VPID, 0, &tmp)
error
error
vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2, MSR_VMX_PROCBASED_CTLS2,			       PROCBASED2_ENABLE_VPID, 0, &tmp)
vmx_set_ctlreg
vmx_set_ctlreg
MSR_VMX_PROCBASED_CTLS2
MSR_VMX_PROCBASED_CTLS2
MSR_VMX_PROCBASED_CTLS2
MSR_VMX_PROCBASED_CTLS2
PROCBASED2_ENABLE_VPID
PROCBASED2_ENABLE_VPID
0
&tmp
tmp
tmp
if (error == 0)		procbased_ctls2 |= PROCBASED2_ENABLE_VPID;
error == 0
error
error
0
procbased_ctls2 |= PROCBASED2_ENABLE_VPID;
procbased_ctls2 |= PROCBASED2_ENABLE_VPID
procbased_ctls2
procbased_ctls2
PROCBASED2_ENABLE_VPID
PROCBASED2_ENABLE_VPID
error = vmx_set_ctlreg(MSR_VMX_PINBASED_CTLS,			       MSR_VMX_TRUE_PINBASED_CTLS,			       PINBASED_CTLS_ONE_SETTING,			       PINBASED_CTLS_ZERO_SETTING, &pinbased_ctls);
error = vmx_set_ctlreg(MSR_VMX_PINBASED_CTLS,			       MSR_VMX_TRUE_PINBASED_CTLS,			       PINBASED_CTLS_ONE_SETTING,			       PINBASED_CTLS_ZERO_SETTING, &pinbased_ctls)
error
error
vmx_set_ctlreg(MSR_VMX_PINBASED_CTLS,			       MSR_VMX_TRUE_PINBASED_CTLS,			       PINBASED_CTLS_ONE_SETTING,			       PINBASED_CTLS_ZERO_SETTING, &pinbased_ctls)
vmx_set_ctlreg
vmx_set_ctlreg
MSR_VMX_PINBASED_CTLS
MSR_VMX_PINBASED_CTLS
MSR_VMX_TRUE_PINBASED_CTLS
MSR_VMX_TRUE_PINBASED_CTLS
PINBASED_CTLS_ONE_SETTING
PINBASED_CTLS_ONE_SETTING
PINBASED_CTLS_ZERO_SETTING
PINBASED_CTLS_ZERO_SETTING
&pinbased_ctls
pinbased_ctls
pinbased_ctls
if (error) {		printf("vmx_init: processor does not support desired "		       "pin-based controls\n");		return (error);	}
error
error
{		printf("vmx_init: processor does not support desired "		       "pin-based controls\n");		return (error);	}
printf("vmx_init: processor does not support desired "		       "pin-based controls\n");
printf("vmx_init: processor does not support desired "		       "pin-based controls\n")
printf
printf
"vmx_init: processor does not support desired "		       "pin-based controls\n"
return (error);
(error)
error
error
error = vmx_set_ctlreg(MSR_VMX_EXIT_CTLS, MSR_VMX_TRUE_EXIT_CTLS,			       VM_EXIT_CTLS_ONE_SETTING,			       VM_EXIT_CTLS_ZERO_SETTING,			       &exit_ctls);
error = vmx_set_ctlreg(MSR_VMX_EXIT_CTLS, MSR_VMX_TRUE_EXIT_CTLS,			       VM_EXIT_CTLS_ONE_SETTING,			       VM_EXIT_CTLS_ZERO_SETTING,			       &exit_ctls)
error
error
vmx_set_ctlreg(MSR_VMX_EXIT_CTLS, MSR_VMX_TRUE_EXIT_CTLS,			       VM_EXIT_CTLS_ONE_SETTING,			       VM_EXIT_CTLS_ZERO_SETTING,			       &exit_ctls)
vmx_set_ctlreg
vmx_set_ctlreg
MSR_VMX_EXIT_CTLS
MSR_VMX_EXIT_CTLS
MSR_VMX_TRUE_EXIT_CTLS
MSR_VMX_TRUE_EXIT_CTLS
VM_EXIT_CTLS_ONE_SETTING
VM_EXIT_CTLS_ONE_SETTING
VM_EXIT_CTLS_ZERO_SETTING
VM_EXIT_CTLS_ZERO_SETTING
&exit_ctls
exit_ctls
exit_ctls
if (error) {		printf("vmx_init: processor does not support desired "		    "exit controls\n");		return (error);	}
error
error
{		printf("vmx_init: processor does not support desired "		    "exit controls\n");		return (error);	}
printf("vmx_init: processor does not support desired "		    "exit controls\n");
printf("vmx_init: processor does not support desired "		    "exit controls\n")
printf
printf
"vmx_init: processor does not support desired "		    "exit controls\n"
return (error);
(error)
error
error
error = vmx_set_ctlreg(MSR_VMX_ENTRY_CTLS, MSR_VMX_TRUE_ENTRY_CTLS,	    VM_ENTRY_CTLS_ONE_SETTING, VM_ENTRY_CTLS_ZERO_SETTING,	    &entry_ctls);
error = vmx_set_ctlreg(MSR_VMX_ENTRY_CTLS, MSR_VMX_TRUE_ENTRY_CTLS,	    VM_ENTRY_CTLS_ONE_SETTING, VM_ENTRY_CTLS_ZERO_SETTING,	    &entry_ctls)
error
error
vmx_set_ctlreg(MSR_VMX_ENTRY_CTLS, MSR_VMX_TRUE_ENTRY_CTLS,	    VM_ENTRY_CTLS_ONE_SETTING, VM_ENTRY_CTLS_ZERO_SETTING,	    &entry_ctls)
vmx_set_ctlreg
vmx_set_ctlreg
MSR_VMX_ENTRY_CTLS
MSR_VMX_ENTRY_CTLS
MSR_VMX_TRUE_ENTRY_CTLS
MSR_VMX_TRUE_ENTRY_CTLS
VM_ENTRY_CTLS_ONE_SETTING
VM_ENTRY_CTLS_ONE_SETTING
VM_ENTRY_CTLS_ZERO_SETTING
VM_ENTRY_CTLS_ZERO_SETTING
&entry_ctls
entry_ctls
entry_ctls
if (error) {		printf("vmx_init: processor does not support desired "		    "entry controls\n");		return (error);	}
error
error
{		printf("vmx_init: processor does not support desired "		    "entry controls\n");		return (error);	}
printf("vmx_init: processor does not support desired "		    "entry controls\n");
printf("vmx_init: processor does not support desired "		    "entry controls\n")
printf
printf
"vmx_init: processor does not support desired "		    "entry controls\n"
return (error);
(error)
error
error
cap_halt_exit = (vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,					MSR_VMX_TRUE_PROCBASED_CTLS,					PROCBASED_HLT_EXITING, 0,					&tmp) == 0);
cap_halt_exit = (vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,					MSR_VMX_TRUE_PROCBASED_CTLS,					PROCBASED_HLT_EXITING, 0,					&tmp) == 0)
cap_halt_exit
cap_halt_exit
(vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,					MSR_VMX_TRUE_PROCBASED_CTLS,					PROCBASED_HLT_EXITING, 0,					&tmp) == 0)
vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,					MSR_VMX_TRUE_PROCBASED_CTLS,					PROCBASED_HLT_EXITING, 0,					&tmp) == 0
vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,					MSR_VMX_TRUE_PROCBASED_CTLS,					PROCBASED_HLT_EXITING, 0,					&tmp)
vmx_set_ctlreg
vmx_set_ctlreg
MSR_VMX_PROCBASED_CTLS
MSR_VMX_PROCBASED_CTLS
MSR_VMX_TRUE_PROCBASED_CTLS
MSR_VMX_TRUE_PROCBASED_CTLS
PROCBASED_HLT_EXITING
PROCBASED_HLT_EXITING
0
&tmp
tmp
tmp
0
cap_monitor_trap = (vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,					MSR_VMX_PROCBASED_CTLS,					PROCBASED_MTF, 0,					&tmp) == 0);
cap_monitor_trap = (vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,					MSR_VMX_PROCBASED_CTLS,					PROCBASED_MTF, 0,					&tmp) == 0)
cap_monitor_trap
cap_monitor_trap
(vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,					MSR_VMX_PROCBASED_CTLS,					PROCBASED_MTF, 0,					&tmp) == 0)
vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,					MSR_VMX_PROCBASED_CTLS,					PROCBASED_MTF, 0,					&tmp) == 0
vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,					MSR_VMX_PROCBASED_CTLS,					PROCBASED_MTF, 0,					&tmp)
vmx_set_ctlreg
vmx_set_ctlreg
MSR_VMX_PROCBASED_CTLS
MSR_VMX_PROCBASED_CTLS
MSR_VMX_PROCBASED_CTLS
MSR_VMX_PROCBASED_CTLS
PROCBASED_MTF
PROCBASED_MTF
0
&tmp
tmp
tmp
0
cap_pause_exit = (vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,					 MSR_VMX_TRUE_PROCBASED_CTLS,					 PROCBASED_PAUSE_EXITING, 0,					 &tmp) == 0);
cap_pause_exit = (vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,					 MSR_VMX_TRUE_PROCBASED_CTLS,					 PROCBASED_PAUSE_EXITING, 0,					 &tmp) == 0)
cap_pause_exit
cap_pause_exit
(vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,					 MSR_VMX_TRUE_PROCBASED_CTLS,					 PROCBASED_PAUSE_EXITING, 0,					 &tmp) == 0)
vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,					 MSR_VMX_TRUE_PROCBASED_CTLS,					 PROCBASED_PAUSE_EXITING, 0,					 &tmp) == 0
vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,					 MSR_VMX_TRUE_PROCBASED_CTLS,					 PROCBASED_PAUSE_EXITING, 0,					 &tmp)
vmx_set_ctlreg
vmx_set_ctlreg
MSR_VMX_PROCBASED_CTLS
MSR_VMX_PROCBASED_CTLS
MSR_VMX_TRUE_PROCBASED_CTLS
MSR_VMX_TRUE_PROCBASED_CTLS
PROCBASED_PAUSE_EXITING
PROCBASED_PAUSE_EXITING
0
&tmp
tmp
tmp
0
cap_unrestricted_guest = (vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2,					MSR_VMX_PROCBASED_CTLS2,					PROCBASED2_UNRESTRICTED_GUEST, 0,				        &tmp) == 0);
cap_unrestricted_guest = (vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2,					MSR_VMX_PROCBASED_CTLS2,					PROCBASED2_UNRESTRICTED_GUEST, 0,				        &tmp) == 0)
cap_unrestricted_guest
cap_unrestricted_guest
(vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2,					MSR_VMX_PROCBASED_CTLS2,					PROCBASED2_UNRESTRICTED_GUEST, 0,				        &tmp) == 0)
vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2,					MSR_VMX_PROCBASED_CTLS2,					PROCBASED2_UNRESTRICTED_GUEST, 0,				        &tmp) == 0
vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2,					MSR_VMX_PROCBASED_CTLS2,					PROCBASED2_UNRESTRICTED_GUEST, 0,				        &tmp)
vmx_set_ctlreg
vmx_set_ctlreg
MSR_VMX_PROCBASED_CTLS2
MSR_VMX_PROCBASED_CTLS2
MSR_VMX_PROCBASED_CTLS2
MSR_VMX_PROCBASED_CTLS2
PROCBASED2_UNRESTRICTED_GUEST
PROCBASED2_UNRESTRICTED_GUEST
0
&tmp
tmp
tmp
0
cap_invpcid = (vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2,	    MSR_VMX_PROCBASED_CTLS2, PROCBASED2_ENABLE_INVPCID, 0,	    &tmp) == 0);
cap_invpcid = (vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2,	    MSR_VMX_PROCBASED_CTLS2, PROCBASED2_ENABLE_INVPCID, 0,	    &tmp) == 0)
cap_invpcid
cap_invpcid
(vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2,	    MSR_VMX_PROCBASED_CTLS2, PROCBASED2_ENABLE_INVPCID, 0,	    &tmp) == 0)
vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2,	    MSR_VMX_PROCBASED_CTLS2, PROCBASED2_ENABLE_INVPCID, 0,	    &tmp) == 0
vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2,	    MSR_VMX_PROCBASED_CTLS2, PROCBASED2_ENABLE_INVPCID, 0,	    &tmp)
vmx_set_ctlreg
vmx_set_ctlreg
MSR_VMX_PROCBASED_CTLS2
MSR_VMX_PROCBASED_CTLS2
MSR_VMX_PROCBASED_CTLS2
MSR_VMX_PROCBASED_CTLS2
PROCBASED2_ENABLE_INVPCID
PROCBASED2_ENABLE_INVPCID
0
&tmp
tmp
tmp
0
procbased2_vid_bits = (PROCBASED2_VIRTUALIZE_APIC_ACCESSES |	    PROCBASED2_VIRTUALIZE_X2APIC_MODE |	    PROCBASED2_APIC_REGISTER_VIRTUALIZATION |	    PROCBASED2_VIRTUAL_INTERRUPT_DELIVERY);
procbased2_vid_bits = (PROCBASED2_VIRTUALIZE_APIC_ACCESSES |	    PROCBASED2_VIRTUALIZE_X2APIC_MODE |	    PROCBASED2_APIC_REGISTER_VIRTUALIZATION |	    PROCBASED2_VIRTUAL_INTERRUPT_DELIVERY)
procbased2_vid_bits
procbased2_vid_bits
(PROCBASED2_VIRTUALIZE_APIC_ACCESSES |	    PROCBASED2_VIRTUALIZE_X2APIC_MODE |	    PROCBASED2_APIC_REGISTER_VIRTUALIZATION |	    PROCBASED2_VIRTUAL_INTERRUPT_DELIVERY)
PROCBASED2_VIRTUALIZE_APIC_ACCESSES |	    PROCBASED2_VIRTUALIZE_X2APIC_MODE |	    PROCBASED2_APIC_REGISTER_VIRTUALIZATION |	    PROCBASED2_VIRTUAL_INTERRUPT_DELIVERY
PROCBASED2_VIRTUALIZE_APIC_ACCESSES |	    PROCBASED2_VIRTUALIZE_X2APIC_MODE |	    PROCBASED2_APIC_REGISTER_VIRTUALIZATION
PROCBASED2_VIRTUALIZE_APIC_ACCESSES |	    PROCBASED2_VIRTUALIZE_X2APIC_MODE
PROCBASED2_VIRTUALIZE_APIC_ACCESSES
PROCBASED2_VIRTUALIZE_APIC_ACCESSES
PROCBASED2_VIRTUALIZE_X2APIC_MODE
PROCBASED2_VIRTUALIZE_X2APIC_MODE
PROCBASED2_APIC_REGISTER_VIRTUALIZATION
PROCBASED2_APIC_REGISTER_VIRTUALIZATION
PROCBASED2_VIRTUAL_INTERRUPT_DELIVERY
PROCBASED2_VIRTUAL_INTERRUPT_DELIVERY
use_tpr_shadow = (vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,	    MSR_VMX_TRUE_PROCBASED_CTLS, PROCBASED_USE_TPR_SHADOW, 0,	    &tmp) == 0);
use_tpr_shadow = (vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,	    MSR_VMX_TRUE_PROCBASED_CTLS, PROCBASED_USE_TPR_SHADOW, 0,	    &tmp) == 0)
use_tpr_shadow
use_tpr_shadow
(vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,	    MSR_VMX_TRUE_PROCBASED_CTLS, PROCBASED_USE_TPR_SHADOW, 0,	    &tmp) == 0)
vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,	    MSR_VMX_TRUE_PROCBASED_CTLS, PROCBASED_USE_TPR_SHADOW, 0,	    &tmp) == 0
vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,	    MSR_VMX_TRUE_PROCBASED_CTLS, PROCBASED_USE_TPR_SHADOW, 0,	    &tmp)
vmx_set_ctlreg
vmx_set_ctlreg
MSR_VMX_PROCBASED_CTLS
MSR_VMX_PROCBASED_CTLS
MSR_VMX_TRUE_PROCBASED_CTLS
MSR_VMX_TRUE_PROCBASED_CTLS
PROCBASED_USE_TPR_SHADOW
PROCBASED_USE_TPR_SHADOW
0
&tmp
tmp
tmp
0
error = vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2, MSR_VMX_PROCBASED_CTLS2,	    procbased2_vid_bits, 0, &tmp);
error = vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2, MSR_VMX_PROCBASED_CTLS2,	    procbased2_vid_bits, 0, &tmp)
error
error
vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2, MSR_VMX_PROCBASED_CTLS2,	    procbased2_vid_bits, 0, &tmp)
vmx_set_ctlreg
vmx_set_ctlreg
MSR_VMX_PROCBASED_CTLS2
MSR_VMX_PROCBASED_CTLS2
MSR_VMX_PROCBASED_CTLS2
MSR_VMX_PROCBASED_CTLS2
procbased2_vid_bits
procbased2_vid_bits
0
&tmp
tmp
tmp
if (error == 0 && use_tpr_shadow) {		virtual_interrupt_delivery = 1;		TUNABLE_INT_FETCH("hw.vmm.vmx.use_apic_vid",		    &virtual_interrupt_delivery);	}
error == 0 && use_tpr_shadow
error == 0
error
error
0
use_tpr_shadow
use_tpr_shadow
{		virtual_interrupt_delivery = 1;		TUNABLE_INT_FETCH("hw.vmm.vmx.use_apic_vid",		    &virtual_interrupt_delivery);	}
virtual_interrupt_delivery = 1;
virtual_interrupt_delivery = 1
virtual_interrupt_delivery
virtual_interrupt_delivery
1
TUNABLE_INT_FETCH("hw.vmm.vmx.use_apic_vid",		    &virtual_interrupt_delivery);
TUNABLE_INT_FETCH("hw.vmm.vmx.use_apic_vid",		    &virtual_interrupt_delivery)
TUNABLE_INT_FETCH
TUNABLE_INT_FETCH
"hw.vmm.vmx.use_apic_vid"
&virtual_interrupt_delivery
virtual_interrupt_delivery
virtual_interrupt_delivery
if (virtual_interrupt_delivery) {		procbased_ctls |= PROCBASED_USE_TPR_SHADOW;		procbased_ctls2 |= procbased2_vid_bits;		procbased_ctls2 &= ~PROCBASED2_VIRTUALIZE_X2APIC_MODE;		/*		 * No need to emulate accesses to %CR8 if virtual		 * interrupt delivery is enabled.		 */		procbased_ctls &= ~PROCBASED_CR8_LOAD_EXITING;		procbased_ctls &= ~PROCBASED_CR8_STORE_EXITING;		/*		 * Check for Posted Interrupts only if Virtual Interrupt		 * Delivery is enabled.		 */		error = vmx_set_ctlreg(MSR_VMX_PINBASED_CTLS,		    MSR_VMX_TRUE_PINBASED_CTLS, PINBASED_POSTED_INTERRUPT, 0,		    &tmp);		if (error == 0) {			pirvec = lapic_ipi_alloc(pti ? &IDTVEC(justreturn1_pti) :			    &IDTVEC(justreturn));			if (pirvec < 0) {				if (bootverbose) {					printf("vmx_init: unable to allocate "					    "posted interrupt vector\n");				}			} else {				posted_interrupts = 1;				TUNABLE_INT_FETCH("hw.vmm.vmx.use_apic_pir",				    &posted_interrupts);			}		}	}
virtual_interrupt_delivery
virtual_interrupt_delivery
{		procbased_ctls |= PROCBASED_USE_TPR_SHADOW;		procbased_ctls2 |= procbased2_vid_bits;		procbased_ctls2 &= ~PROCBASED2_VIRTUALIZE_X2APIC_MODE;		/*		 * No need to emulate accesses to %CR8 if virtual		 * interrupt delivery is enabled.		 */		procbased_ctls &= ~PROCBASED_CR8_LOAD_EXITING;		procbased_ctls &= ~PROCBASED_CR8_STORE_EXITING;		/*		 * Check for Posted Interrupts only if Virtual Interrupt		 * Delivery is enabled.		 */		error = vmx_set_ctlreg(MSR_VMX_PINBASED_CTLS,		    MSR_VMX_TRUE_PINBASED_CTLS, PINBASED_POSTED_INTERRUPT, 0,		    &tmp);		if (error == 0) {			pirvec = lapic_ipi_alloc(pti ? &IDTVEC(justreturn1_pti) :			    &IDTVEC(justreturn));			if (pirvec < 0) {				if (bootverbose) {					printf("vmx_init: unable to allocate "					    "posted interrupt vector\n");				}			} else {				posted_interrupts = 1;				TUNABLE_INT_FETCH("hw.vmm.vmx.use_apic_pir",				    &posted_interrupts);			}		}	}
procbased_ctls |= PROCBASED_USE_TPR_SHADOW;
procbased_ctls |= PROCBASED_USE_TPR_SHADOW
procbased_ctls
procbased_ctls
PROCBASED_USE_TPR_SHADOW
PROCBASED_USE_TPR_SHADOW
procbased_ctls2 |= procbased2_vid_bits;
procbased_ctls2 |= procbased2_vid_bits
procbased_ctls2
procbased_ctls2
procbased2_vid_bits
procbased2_vid_bits
procbased_ctls2 &= ~PROCBASED2_VIRTUALIZE_X2APIC_MODE;
procbased_ctls2 &= ~PROCBASED2_VIRTUALIZE_X2APIC_MODE
procbased_ctls2
procbased_ctls2
~PROCBASED2_VIRTUALIZE_X2APIC_MODE
PROCBASED2_VIRTUALIZE_X2APIC_MODE
PROCBASED2_VIRTUALIZE_X2APIC_MODE
procbased_ctls &= ~PROCBASED_CR8_LOAD_EXITING;
procbased_ctls &= ~PROCBASED_CR8_LOAD_EXITING
procbased_ctls
procbased_ctls
~PROCBASED_CR8_LOAD_EXITING
PROCBASED_CR8_LOAD_EXITING
PROCBASED_CR8_LOAD_EXITING
procbased_ctls &= ~PROCBASED_CR8_STORE_EXITING;
procbased_ctls &= ~PROCBASED_CR8_STORE_EXITING
procbased_ctls
procbased_ctls
~PROCBASED_CR8_STORE_EXITING
PROCBASED_CR8_STORE_EXITING
PROCBASED_CR8_STORE_EXITING
error = vmx_set_ctlreg(MSR_VMX_PINBASED_CTLS,		    MSR_VMX_TRUE_PINBASED_CTLS, PINBASED_POSTED_INTERRUPT, 0,		    &tmp);
error = vmx_set_ctlreg(MSR_VMX_PINBASED_CTLS,		    MSR_VMX_TRUE_PINBASED_CTLS, PINBASED_POSTED_INTERRUPT, 0,		    &tmp)
error
error
vmx_set_ctlreg(MSR_VMX_PINBASED_CTLS,		    MSR_VMX_TRUE_PINBASED_CTLS, PINBASED_POSTED_INTERRUPT, 0,		    &tmp)
vmx_set_ctlreg
vmx_set_ctlreg
MSR_VMX_PINBASED_CTLS
MSR_VMX_PINBASED_CTLS
MSR_VMX_TRUE_PINBASED_CTLS
MSR_VMX_TRUE_PINBASED_CTLS
PINBASED_POSTED_INTERRUPT
PINBASED_POSTED_INTERRUPT
0
&tmp
tmp
tmp
if (error == 0) {			pirvec = lapic_ipi_alloc(pti ? &IDTVEC(justreturn1_pti) :			    &IDTVEC(justreturn));			if (pirvec < 0) {				if (bootverbose) {					printf("vmx_init: unable to allocate "					    "posted interrupt vector\n");				}			} else {				posted_interrupts = 1;				TUNABLE_INT_FETCH("hw.vmm.vmx.use_apic_pir",				    &posted_interrupts);			}		}
error == 0
error
error
0
{			pirvec = lapic_ipi_alloc(pti ? &IDTVEC(justreturn1_pti) :			    &IDTVEC(justreturn));			if (pirvec < 0) {				if (bootverbose) {					printf("vmx_init: unable to allocate "					    "posted interrupt vector\n");				}			} else {				posted_interrupts = 1;				TUNABLE_INT_FETCH("hw.vmm.vmx.use_apic_pir",				    &posted_interrupts);			}		}
pirvec = lapic_ipi_alloc(pti ? &IDTVEC(justreturn1_pti) :			    &IDTVEC(justreturn));
pirvec = lapic_ipi_alloc(pti ? &IDTVEC(justreturn1_pti) :			    &IDTVEC(justreturn))
pirvec
pirvec
lapic_ipi_alloc(pti ? &IDTVEC(justreturn1_pti) :			    &IDTVEC(justreturn))
lapic_ipi_alloc
lapic_ipi_alloc
pti ? &IDTVEC(justreturn1_pti) :			    &IDTVEC(justreturn)
pti
pti
&IDTVEC(justreturn1_pti)
IDTVEC(justreturn1_pti)
IDTVEC
IDTVEC
justreturn1_pti
justreturn1_pti
&IDTVEC(justreturn)
IDTVEC(justreturn)
IDTVEC
IDTVEC
justreturn
justreturn
if (pirvec < 0) {				if (bootverbose) {					printf("vmx_init: unable to allocate "					    "posted interrupt vector\n");				}			} else {				posted_interrupts = 1;				TUNABLE_INT_FETCH("hw.vmm.vmx.use_apic_pir",				    &posted_interrupts);			}
pirvec < 0
pirvec
pirvec
0
{				if (bootverbose) {					printf("vmx_init: unable to allocate "					    "posted interrupt vector\n");				}			}
if (bootverbose) {					printf("vmx_init: unable to allocate "					    "posted interrupt vector\n");				}
bootverbose
bootverbose
{					printf("vmx_init: unable to allocate "					    "posted interrupt vector\n");				}
printf("vmx_init: unable to allocate "					    "posted interrupt vector\n");
printf("vmx_init: unable to allocate "					    "posted interrupt vector\n")
printf
printf
"vmx_init: unable to allocate "					    "posted interrupt vector\n"
{				posted_interrupts = 1;				TUNABLE_INT_FETCH("hw.vmm.vmx.use_apic_pir",				    &posted_interrupts);			}
posted_interrupts = 1;
posted_interrupts = 1
posted_interrupts
posted_interrupts
1
TUNABLE_INT_FETCH("hw.vmm.vmx.use_apic_pir",				    &posted_interrupts);
TUNABLE_INT_FETCH("hw.vmm.vmx.use_apic_pir",				    &posted_interrupts)
TUNABLE_INT_FETCH
TUNABLE_INT_FETCH
"hw.vmm.vmx.use_apic_pir"
&posted_interrupts
posted_interrupts
posted_interrupts
if (posted_interrupts)		    pinbased_ctls |= PINBASED_POSTED_INTERRUPT;
posted_interrupts
posted_interrupts
pinbased_ctls |= PINBASED_POSTED_INTERRUPT;
pinbased_ctls |= PINBASED_POSTED_INTERRUPT
pinbased_ctls
pinbased_ctls
PINBASED_POSTED_INTERRUPT
PINBASED_POSTED_INTERRUPT
error = ept_init(ipinum);
error = ept_init(ipinum)
error
error
ept_init(ipinum)
ept_init
ept_init
ipinum
ipinum
if (error) {		printf("vmx_init: ept initialization failed (%d)\n", error);		return (error);	}
error
error
{		printf("vmx_init: ept initialization failed (%d)\n", error);		return (error);	}
printf("vmx_init: ept initialization failed (%d)\n", error);
printf("vmx_init: ept initialization failed (%d)\n", error)
printf
printf
"vmx_init: ept initialization failed (%d)\n"
error
error
return (error);
(error)
error
error
guest_l1d_flush = (cpu_ia32_arch_caps & IA32_ARCH_CAP_RDCL_NO) == 0;
guest_l1d_flush = (cpu_ia32_arch_caps & IA32_ARCH_CAP_RDCL_NO) == 0
guest_l1d_flush
guest_l1d_flush
(cpu_ia32_arch_caps & IA32_ARCH_CAP_RDCL_NO) == 0
(cpu_ia32_arch_caps & IA32_ARCH_CAP_RDCL_NO)
cpu_ia32_arch_caps & IA32_ARCH_CAP_RDCL_NO
cpu_ia32_arch_caps
cpu_ia32_arch_caps
IA32_ARCH_CAP_RDCL_NO
IA32_ARCH_CAP_RDCL_NO
0
TUNABLE_INT_FETCH("hw.vmm.l1d_flush", &guest_l1d_flush);
TUNABLE_INT_FETCH("hw.vmm.l1d_flush", &guest_l1d_flush)
TUNABLE_INT_FETCH
TUNABLE_INT_FETCH
"hw.vmm.l1d_flush"
&guest_l1d_flush
guest_l1d_flush
guest_l1d_flush
if (guest_l1d_flush &&	    (cpu_stdext_feature3 & CPUID_STDEXT3_L1D_FLUSH) != 0)		vmx_msr_flush_cmd = IA32_FLUSH_CMD_L1D;
guest_l1d_flush &&	    (cpu_stdext_feature3 & CPUID_STDEXT3_L1D_FLUSH) != 0
guest_l1d_flush
guest_l1d_flush
(cpu_stdext_feature3 & CPUID_STDEXT3_L1D_FLUSH) != 0
(cpu_stdext_feature3 & CPUID_STDEXT3_L1D_FLUSH)
cpu_stdext_feature3 & CPUID_STDEXT3_L1D_FLUSH
cpu_stdext_feature3
cpu_stdext_feature3
CPUID_STDEXT3_L1D_FLUSH
CPUID_STDEXT3_L1D_FLUSH
0
vmx_msr_flush_cmd = IA32_FLUSH_CMD_L1D;
vmx_msr_flush_cmd = IA32_FLUSH_CMD_L1D
vmx_msr_flush_cmd
vmx_msr_flush_cmd
IA32_FLUSH_CMD_L1D
IA32_FLUSH_CMD_L1D
fixed0 = rdmsr(MSR_VMX_CR0_FIXED0);
fixed0 = rdmsr(MSR_VMX_CR0_FIXED0)
fixed0
fixed0
rdmsr(MSR_VMX_CR0_FIXED0)
rdmsr
rdmsr
MSR_VMX_CR0_FIXED0
MSR_VMX_CR0_FIXED0
fixed1 = rdmsr(MSR_VMX_CR0_FIXED1);
fixed1 = rdmsr(MSR_VMX_CR0_FIXED1)
fixed1
fixed1
rdmsr(MSR_VMX_CR0_FIXED1)
rdmsr
rdmsr
MSR_VMX_CR0_FIXED1
MSR_VMX_CR0_FIXED1
cr0_ones_mask = fixed0 & fixed1;
cr0_ones_mask = fixed0 & fixed1
cr0_ones_mask
cr0_ones_mask
fixed0 & fixed1
fixed0
fixed0
fixed1
fixed1
cr0_zeros_mask = ~fixed0 & ~fixed1;
cr0_zeros_mask = ~fixed0 & ~fixed1
cr0_zeros_mask
cr0_zeros_mask
~fixed0 & ~fixed1
~fixed0
fixed0
fixed0
~fixed1
fixed1
fixed1
if (cap_unrestricted_guest)		cr0_ones_mask &= ~(CR0_PG | CR0_PE);
cap_unrestricted_guest
cap_unrestricted_guest
cr0_ones_mask &= ~(CR0_PG | CR0_PE);
cr0_ones_mask &= ~(CR0_PG | CR0_PE)
cr0_ones_mask
cr0_ones_mask
~(CR0_PG | CR0_PE)
(CR0_PG | CR0_PE)
CR0_PG | CR0_PE
CR0_PG
CR0_PG
CR0_PE
CR0_PE
cr0_zeros_mask |= (CR0_NW | CR0_CD);
cr0_zeros_mask |= (CR0_NW | CR0_CD)
cr0_zeros_mask
cr0_zeros_mask
(CR0_NW | CR0_CD)
CR0_NW | CR0_CD
CR0_NW
CR0_NW
CR0_CD
CR0_CD
fixed0 = rdmsr(MSR_VMX_CR4_FIXED0);
fixed0 = rdmsr(MSR_VMX_CR4_FIXED0)
fixed0
fixed0
rdmsr(MSR_VMX_CR4_FIXED0)
rdmsr
rdmsr
MSR_VMX_CR4_FIXED0
MSR_VMX_CR4_FIXED0
fixed1 = rdmsr(MSR_VMX_CR4_FIXED1);
fixed1 = rdmsr(MSR_VMX_CR4_FIXED1)
fixed1
fixed1
rdmsr(MSR_VMX_CR4_FIXED1)
rdmsr
rdmsr
MSR_VMX_CR4_FIXED1
MSR_VMX_CR4_FIXED1
cr4_ones_mask = fixed0 & fixed1;
cr4_ones_mask = fixed0 & fixed1
cr4_ones_mask
cr4_ones_mask
fixed0 & fixed1
fixed0
fixed0
fixed1
fixed1
cr4_zeros_mask = ~fixed0 & ~fixed1;
cr4_zeros_mask = ~fixed0 & ~fixed1
cr4_zeros_mask
cr4_zeros_mask
~fixed0 & ~fixed1
~fixed0
fixed0
fixed0
~fixed1
fixed1
fixed1
vpid_init();
vpid_init()
vpid_init
vpid_init
vmx_msr_init();
vmx_msr_init()
vmx_msr_init
vmx_msr_init
smp_rendezvous(NULL, vmx_enable, NULL, NULL);
smp_rendezvous(NULL, vmx_enable, NULL, NULL)
smp_rendezvous
smp_rendezvous
NULL
NULL
vmx_enable
vmx_enable
NULL
NULL
NULL
NULL
vmx_initialized = 1;
vmx_initialized = 1
vmx_initialized
vmx_initialized
1
return (0);
(0)
0
-----joern-----
(146,108,0)
(156,2,0)
(126,324,0)
(334,114,0)
(145,3,0)
(337,74,0)
(345,236,0)
(284,108,0)
(402,329,0)
(36,344,0)
(128,108,0)
(84,351,0)
(44,266,0)
(13,416,0)
(273,134,0)
(302,210,0)
(402,130,0)
(335,108,0)
(292,200,0)
(183,153,0)
(329,128,0)
(87,407,0)
(77,108,0)
(387,231,0)
(224,108,0)
(20,194,0)
(212,125,0)
(382,73,0)
(287,16,0)
(312,44,0)
(405,239,0)
(328,352,0)
(416,52,0)
(410,271,0)
(416,337,0)
(85,108,0)
(17,333,0)
(356,238,0)
(16,326,0)
(401,396,0)
(409,5,0)
(135,136,0)
(13,372,0)
(13,156,0)
(293,65,0)
(23,328,0)
(97,250,0)
(109,22,0)
(282,86,0)
(402,358,0)
(182,380,0)
(166,33,0)
(243,155,0)
(416,224,0)
(300,146,0)
(13,52,0)
(138,108,0)
(392,328,0)
(63,329,0)
(23,48,0)
(336,333,0)
(211,143,0)
(304,385,0)
(101,108,0)
(24,108,0)
(256,275,0)
(22,224,0)
(43,2,0)
(231,174,0)
(26,136,0)
(386,310,0)
(70,88,0)
(374,108,0)
(273,108,0)
(348,13,0)
(167,334,0)
(325,295,0)
(47,88,0)
(321,39,0)
(125,141,0)
(136,26,0)
(223,78,0)
(380,159,0)
(30,310,0)
(29,211,0)
(35,221,0)
(251,179,0)
(156,328,0)
(73,160,0)
(192,262,0)
(381,74,0)
(9,108,0)
(208,78,0)
(250,155,0)
(390,160,0)
(347,108,0)
(224,22,0)
(258,108,0)
(0,58,0)
(260,166,0)
(67,395,0)
(285,86,0)
(151,165,0)
(329,69,0)
(413,108,0)
(121,48,0)
(13,310,0)
(11,337,0)
(32,416,0)
(344,120,0)
(238,222,0)
(170,2,0)
(102,300,0)
(90,69,0)
(72,108,0)
(116,174,0)
(13,337,0)
(310,108,0)
(66,281,0)
(239,324,0)
(320,389,0)
(33,166,0)
(128,3,0)
(5,386,0)
(28,109,0)
(19,411,0)
(299,354,0)
(357,108,0)
(316,138,0)
(301,41,0)
(327,224,0)
(335,260,0)
(3,275,0)
(174,231,0)
(416,83,0)
(416,15,0)
(352,328,0)
(252,169,0)
(185,191,0)
(13,83,0)
(259,114,0)
(194,108,0)
(339,204,0)
(230,169,0)
(188,288,0)
(328,108,0)
(103,33,0)
(306,287,0)
(240,166,0)
(414,21,0)
(355,21,0)
(358,224,0)
(117,221,0)
(13,211,0)
(61,108,0)
(384,105,0)
(300,136,0)
(156,48,0)
(194,100,0)
(233,200,0)
(338,210,0)
(23,337,0)
(122,238,0)
(18,78,0)
(187,226,0)
(393,0,0)
(369,262,0)
(262,170,0)
(322,173,0)
(358,389,0)
(0,393,0)
(193,230,0)
(92,33,0)
(367,311,0)
(323,129,0)
(81,65,0)
(21,414,0)
(362,9,0)
(378,24,0)
(99,83,0)
(161,160,0)
(358,310,0)
(136,108,0)
(313,326,0)
(326,160,0)
(74,337,0)
(156,337,0)
(154,43,0)
(414,391,0)
(311,76,0)
(356,108,0)
(164,200,0)
(133,156,0)
(132,385,0)
(242,3,0)
(205,201,0)
(37,10,0)
(358,9,0)
(388,259,0)
(9,395,0)
(243,356,0)
(225,108,0)
(107,109,0)
(199,23,0)
(322,231,0)
(358,211,0)
(302,24,0)
(226,172,0)
(74,169,0)
(304,172,0)
(310,386,0)
(98,108,0)
(358,305,0)
(131,134,0)
(234,91,0)
(358,416,0)
(396,262,0)
(23,15,0)
(162,16,0)
(402,228,0)
(391,108,0)
(173,322,0)
(263,108,0)
(236,2,0)
(41,185,0)
(332,176,0)
(260,335,0)
(190,222,0)
(204,383,0)
(58,0,0)
(402,304,0)
(4,255,0)
(316,411,0)
(1,108,0)
(264,288,0)
(354,299,0)
(342,31,0)
(37,24,0)
(111,0,0)
(179,25,0)
(272,130,0)
(13,328,0)
(156,335,0)
(280,260,0)
(333,93,0)
(289,393,0)
(231,322,0)
(317,52,0)
(350,26,0)
(259,38,0)
(144,128,0)
(416,391,0)
(139,156,0)
(361,21,0)
(78,208,0)
(337,108,0)
(377,266,0)
(112,169,0)
(13,23,0)
(191,185,0)
(6,169,0)
(282,108,0)
(389,108,0)
(246,352,0)
(288,374,0)
(400,395,0)
(138,316,0)
(115,39,0)
(343,171,0)
(13,146,0)
(206,87,0)
(358,15,0)
(402,179,0)
(270,108,0)
(229,22,0)
(319,105,0)
(406,351,0)
(8,108,0)
(211,38,0)
(21,361,0)
(201,25,0)
(364,228,0)
(358,52,0)
(31,288,0)
(23,391,0)
(354,194,0)
(1,255,0)
(399,108,0)
(324,239,0)
(358,299,0)
(186,48,0)
(305,351,0)
(283,109,0)
(268,208,0)
(373,37,0)
(203,106,0)
(51,141,0)
(394,108,0)
(100,194,0)
(263,207,0)
(24,37,0)
(318,236,0)
(326,108,0)
(351,305,0)
(160,326,0)
(13,91,0)
(363,58,0)
(14,171,0)
(375,271,0)
(141,385,0)
(288,31,0)
(88,170,0)
(309,414,0)
(110,239,0)
(415,316,0)
(358,146,0)
(114,334,0)
(156,15,0)
(358,337,0)
(402,243,0)
(150,338,0)
(93,333,0)
(374,288,0)
(412,279,0)
(7,108,0)
(39,115,0)
(146,300,0)
(23,2,0)
(249,120,0)
(391,414,0)
(255,1,0)
(279,78,0)
(173,65,0)
(59,108,0)
(218,90,0)
(295,247,0)
(15,208,0)
(49,290,0)
(286,174,0)
(388,281,0)
(259,388,0)
(105,374,0)
(119,243,0)
(13,391,0)
(13,224,0)
(54,416,0)
(34,143,0)
(160,335,0)
(153,200,0)
(106,244,0)
(305,108,0)
(17,108,0)
(38,211,0)
(55,2,0)
(333,17,0)
(65,173,0)
(269,129,0)
(275,3,0)
(371,239,0)
(217,333,0)
(68,338,0)
(402,165,0)
(3,128,0)
(416,328,0)
(358,156,0)
(271,195,0)
(71,316,0)
(358,328,0)
(75,244,0)
(15,108,0)
(221,35,0)
(407,87,0)
(12,290,0)
(219,238,0)
(274,78,0)
(185,1,0)
(156,23,0)
(238,356,0)
(127,288,0)
(114,259,0)
(27,93,0)
(109,283,0)
(174,115,0)
(45,17,0)
(23,224,0)
(358,13,0)
(44,198,0)
(303,238,0)
(354,407,0)
(94,108,0)
(257,316,0)
(330,393,0)
(296,78,0)
(79,207,0)
(163,108,0)
(315,386,0)
(22,109,0)
(16,287,0)
(358,108,0)
(152,140,0)
(300,273,0)
(353,191,0)
(248,372,0)
(166,260,0)
(140,2,0)
(149,21,0)
(53,335,0)
(95,304,0)
(180,305,0)
(281,388,0)
(358,48,0)
(207,200,0)
(402,344,0)
(299,108,0)
(407,108,0)
(64,108,0)
(42,106,0)
(297,1,0)
(287,263,0)
(208,15,0)
(370,239,0)
(86,282,0)
(137,16,0)
(416,156,0)
(40,83,0)
(262,396,0)
(416,23,0)
(115,108,0)
(130,247,0)
(189,100,0)
(113,170,0)
(160,73,0)
(13,15,0)
(65,115,0)
(416,211,0)
(156,224,0)
(358,83,0)
(291,173,0)
(214,299,0)
(365,391,0)
(346,302,0)
(62,108,0)
(148,263,0)
(341,129,0)
(221,184,0)
(358,23,0)
(175,109,0)
(171,108,0)
(239,352,0)
(267,3,0)
(265,35,0)
(244,75,0)
(80,160,0)
(403,52,0)
(294,356,0)
(13,48,0)
(200,153,0)
(170,262,0)
(278,109,0)
(141,125,0)
(398,262,0)
(168,108,0)
(147,288,0)
(368,238,0)
(142,160,0)
(185,41,0)
(358,391,0)
(207,263,0)
(397,361,0)
(416,48,0)
(50,169,0)
(129,108,0)
(379,389,0)
(386,5,0)
(179,138,0)
(60,262,0)
(215,354,0)
(177,372,0)
(237,141,0)
(169,230,0)
(83,184,0)
(13,108,0)
(222,238,0)
(165,159,0)
(213,23,0)
(104,200,0)
(89,75,0)
(78,279,0)
(385,141,0)
(245,282,0)
(46,333,0)
(372,13,0)
(158,41,0)
(157,138,0)
(235,140,0)
(276,185,0)
(340,91,0)
(402,302,0)
(195,271,0)
(209,3,0)
(134,273,0)
(200,207,0)
(156,52,0)
(181,108,0)
(57,108,0)
(338,24,0)
(352,239,0)
(156,391,0)
(314,146,0)
(376,316,0)
(359,273,0)
(308,374,0)
(178,283,0)
(165,17,0)
(23,52,0)
(124,115,0)
(38,259,0)
(48,198,0)
(197,5,0)
(228,76,0)
(395,9,0)
(254,141,0)
(261,129,0)
(307,249,0)
(277,21,0)
(118,407,0)
(13,9,0)
(96,354,0)
(123,358,0)
(411,316,0)
(253,141,0)
(331,43,0)
(56,333,0)
(266,44,0)
(358,91,0)
(82,15,0)
(244,106,0)
(360,300,0)
(385,108,0)
(169,74,0)
(202,21,0)
(220,259,0)
(123,389,1)
(403,317,1)
(28,278,1)
(13,328,1)
(397,277,1)
(267,145,1)
(53,224,1)
(21,361,1)
(13,9,1)
(52,403,1)
(100,189,1)
(167,220,1)
(60,113,1)
(13,211,1)
(358,211,1)
(402,344,1)
(183,104,1)
(45,408,1)
(241,204,1)
(156,337,1)
(414,21,1)
(259,388,1)
(215,214,1)
(372,177,1)
(49,12,1)
(156,391,1)
(360,102,1)
(23,213,1)
(83,40,1)
(386,315,1)
(241,88,1)
(105,319,1)
(291,65,1)
(365,349,1)
(402,243,1)
(313,263,1)
(17,333,1)
(319,384,1)
(173,291,1)
(75,244,1)
(300,273,1)
(402,358,1)
(180,299,1)
(271,375,1)
(285,245,1)
(304,95,1)
(311,367,1)
(222,190,1)
(114,334,1)
(149,355,1)
(113,140,1)
(224,22,1)
(19,376,1)
(333,93,1)
(82,337,1)
(358,91,1)
(329,128,1)
(190,368,1)
(255,4,1)
(303,294,1)
(156,224,1)
(328,352,1)
(244,106,1)
(296,274,1)
(323,57,1)
(93,27,1)
(302,24,1)
(402,329,1)
(135,273,1)
(358,389,1)
(416,328,1)
(32,241,1)
(241,221,1)
(185,41,1)
(35,265,1)
(280,53,1)
(358,52,1)
(189,20,1)
(104,233,1)
(41,301,1)
(227,44,1)
(74,381,1)
(265,117,1)
(13,91,1)
(186,121,1)
(121,287,1)
(99,290,1)
(23,52,1)
(137,162,1)
(396,401,1)
(384,374,1)
(300,360,1)
(405,110,1)
(208,78,1)
(416,337,1)
(217,45,1)
(341,261,1)
(273,134,1)
(214,407,1)
(65,81,1)
(322,231,1)
(358,391,1)
(23,328,1)
(173,65,1)
(13,156,1)
(1,255,1)
(242,267,1)
(126,405,1)
(111,393,1)
(355,365,1)
(66,220,1)
(352,246,1)
(22,229,1)
(230,193,1)
(80,161,1)
(401,398,1)
(337,74,1)
(317,105,1)
(24,37,1)
(12,211,1)
(307,322,1)
(409,197,1)
(336,46,1)
(402,304,1)
(103,92,1)
(316,411,1)
(367,195,1)
(358,123,1)
(165,151,1)
(16,137,1)
(22,109,1)
(218,196,1)
(109,283,1)
(6,112,1)
(287,16,1)
(301,158,1)
(192,60,1)
(259,114,1)
(81,293,1)
(160,73,1)
(200,153,1)
(107,28,1)
(23,15,1)
(358,299,1)
(300,136,1)
(14,196,1)
(20,13,1)
(156,139,1)
(161,313,1)
(51,237,1)
(295,325,1)
(371,392,1)
(314,136,1)
(132,171,1)
(131,359,1)
(27,56,1)
(174,115,1)
(329,63,1)
(196,128,1)
(359,91,1)
(395,400,1)
(248,348,1)
(262,396,1)
(156,52,1)
(40,99,1)
(67,362,1)
(412,223,1)
(305,351,1)
(363,282,1)
(281,66,1)
(402,179,1)
(97,408,1)
(105,374,1)
(150,366,1)
(201,205,1)
(42,203,1)
(91,340,1)
(187,216,1)
(119,250,1)
(199,227,1)
(154,236,1)
(354,96,1)
(96,215,1)
(23,337,1)
(346,338,1)
(136,26,1)
(240,280,1)
(415,71,1)
(157,105,1)
(127,188,1)
(179,138,1)
(343,14,1)
(358,337,1)
(331,154,1)
(407,87,1)
(175,327,1)
(58,363,1)
(236,318,1)
(106,42,1)
(261,269,1)
(160,335,1)
(13,48,1)
(13,52,1)
(286,115,1)
(207,79,1)
(390,80,1)
(138,316,1)
(228,364,1)
(11,391,1)
(381,169,1)
(116,286,1)
(13,23,1)
(272,295,1)
(378,416,1)
(226,187,1)
(185,1,1)
(414,309,1)
(309,21,1)
(128,3,1)
(169,230,1)
(366,24,1)
(139,133,1)
(416,48,1)
(289,363,1)
(174,116,1)
(54,32,1)
(158,276,1)
(16,326,1)
(79,200,1)
(348,232,1)
(416,15,1)
(249,307,1)
(358,305,1)
(352,239,1)
(56,336,1)
(253,51,1)
(129,341,1)
(48,186,1)
(43,331,1)
(256,209,1)
(404,290,1)
(9,395,1)
(266,377,1)
(207,200,1)
(327,328,1)
(379,129,1)
(278,175,1)
(115,39,1)
(0,393,1)
(416,52,1)
(386,5,1)
(302,346,1)
(231,387,1)
(338,68,1)
(374,288,1)
(369,192,1)
(243,356,1)
(130,272,1)
(44,266,1)
(345,156,1)
(78,279,1)
(13,224,1)
(213,199,1)
(13,83,1)
(299,354,1)
(202,149,1)
(350,135,1)
(152,235,1)
(270,305,1)
(260,166,1)
(310,386,1)
(392,15,1)
(209,242,1)
(13,391,1)
(377,312,1)
(402,228,1)
(358,9,1)
(288,31,1)
(263,207,1)
(23,224,1)
(191,185,1)
(356,238,1)
(171,343,1)
(122,303,1)
(237,132,1)
(26,350,1)
(156,335,1)
(376,257,1)
(274,18,1)
(359,58,1)
(92,240,1)
(146,300,1)
(188,264,1)
(400,67,1)
(37,10,1)
(364,311,1)
(23,48,1)
(145,144,1)
(241,404,1)
(416,156,1)
(144,191,1)
(38,259,1)
(342,147,1)
(234,58,1)
(416,83,1)
(385,141,1)
(358,146,1)
(238,222,1)
(141,125,1)
(380,182,1)
(29,88,1)
(95,226,1)
(348,75,1)
(5,409,1)
(389,320,1)
(65,115,1)
(368,219,1)
(411,19,1)
(13,416,1)
(221,35,1)
(241,227,1)
(88,170,1)
(243,119,1)
(166,33,1)
(229,109,1)
(87,206,1)
(306,16,1)
(325,191,1)
(408,356,1)
(118,194,1)
(3,275,1)
(216,385,1)
(223,296,1)
(162,326,1)
(148,335,1)
(416,391,1)
(204,339,1)
(297,322,1)
(156,23,1)
(58,0,1)
(324,126,1)
(89,232,1)
(193,6,1)
(406,180,1)
(110,370,1)
(283,178,1)
(353,185,1)
(156,48,1)
(279,412,1)
(227,287,1)
(387,174,1)
(282,86,1)
(318,345,1)
(349,17,1)
(33,103,1)
(18,82,1)
(182,349,1)
(233,292,1)
(308,216,1)
(358,13,1)
(251,201,1)
(57,270,1)
(338,24,1)
(70,47,1)
(416,211,1)
(239,324,1)
(231,174,1)
(358,156,1)
(245,310,1)
(140,152,1)
(235,43,1)
(388,281,1)
(156,15,1)
(112,50,1)
(71,157,1)
(36,249,1)
(312,48,1)
(378,241,1)
(90,218,1)
(117,83,1)
(254,253,1)
(416,224,1)
(50,252,1)
(321,124,1)
(322,173,1)
(330,289,1)
(73,382,1)
(133,23,1)
(391,414,1)
(124,195,1)
(344,36,1)
(197,30,1)
(13,146,1)
(402,165,1)
(31,342,1)
(398,369,1)
(15,208,1)
(246,239,1)
(340,234,1)
(293,231,1)
(334,167,1)
(203,89,1)
(177,248,1)
(219,122,1)
(292,164,1)
(0,111,1)
(358,23,1)
(382,142,1)
(88,70,1)
(74,169,1)
(134,131,1)
(232,9,1)
(147,127,1)
(354,194,1)
(375,410,1)
(13,310,1)
(268,78,1)
(208,268,1)
(358,328,1)
(102,314,1)
(393,330,1)
(205,298,1)
(157,52,1)
(275,256,1)
(170,262,1)
(178,107,1)
(402,302,1)
(13,15,1)
(84,406,1)
(361,397,1)
(13,372,1)
(211,38,1)
(212,254,1)
(416,23,1)
(326,160,1)
(294,298,1)
(4,297,1)
(165,17,1)
(264,308,1)
(179,251,1)
(46,217,1)
(151,380,1)
(358,224,1)
(370,371,1)
(13,337,1)
(358,48,1)
(142,390,1)
(358,15,1)
(298,138,1)
(320,379,1)
(63,90,1)
(153,183,1)
(354,407,1)
(339,404,1)
(257,415,1)
(304,385,1)
(351,84,1)
(206,118,1)
(358,310,1)
(23,391,1)
(252,11,1)
(402,130,1)
(47,170,1)
(195,271,1)
(290,49,1)
(68,150,1)
(269,323,1)
(39,321,1)
(373,378,1)
(164,148,1)
(335,260,1)
(30,366,1)
(416,54,1)
(362,146,1)
(276,1,1)
(250,97,1)
(287,263,1)
(277,202,1)
(220,29,1)
(191,353,1)
(358,83,1)
(358,416,1)
(194,100,1)
(86,285,1)
(156,328,1)
(287,306,1)
(37,373,1)
(315,5,1)
(125,212,1)
(78,279,2)
(177,366,2)
(29,88,2)
(248,366,2)
(152,227,2)
(385,196,2)
(117,290,2)
(39,195,2)
(211,88,2)
(107,349,2)
(314,366,2)
(329,128,2)
(319,216,2)
(259,388,2)
(194,100,2)
(99,290,2)
(317,105,2)
(398,227,2)
(103,349,2)
(402,130,2)
(190,298,2)
(252,349,2)
(84,366,2)
(208,78,2)
(218,196,2)
(170,262,2)
(221,290,2)
(183,349,2)
(260,166,2)
(336,408,2)
(366,349,2)
(68,366,2)
(3,191,2)
(158,322,2)
(4,322,2)
(257,216,2)
(13,372,2)
(11,349,2)
(358,224,2)
(235,227,2)
(189,366,2)
(74,349,2)
(58,366,2)
(200,349,2)
(221,35,2)
(196,191,2)
(382,349,2)
(262,396,2)
(156,224,2)
(37,349,2)
(406,366,2)
(395,366,2)
(40,290,2)
(202,349,2)
(337,74,2)
(185,322,2)
(259,88,2)
(15,349,2)
(358,156,2)
(156,23,2)
(9,366,2)
(216,196,2)
(136,26,2)
(352,349,2)
(156,391,2)
(13,366,2)
(23,224,2)
(45,408,2)
(297,322,2)
(354,194,2)
(73,349,2)
(351,366,2)
(282,86,2)
(384,216,2)
(57,366,2)
(226,216,2)
(13,156,2)
(79,349,2)
(185,41,2)
(38,259,2)
(416,48,2)
(324,349,2)
(141,125,2)
(36,322,2)
(328,352,2)
(200,153,2)
(156,52,2)
(372,366,2)
(13,23,2)
(237,196,2)
(23,337,2)
(278,349,2)
(353,322,2)
(274,349,2)
(212,196,2)
(178,349,2)
(26,366,2)
(285,366,2)
(407,366,2)
(32,241,2)
(358,15,2)
(156,335,2)
(88,227,2)
(411,216,2)
(356,238,2)
(233,349,2)
(358,91,2)
(300,136,2)
(402,304,2)
(141,196,2)
(299,366,2)
(15,208,2)
(318,227,2)
(115,39,2)
(199,227,2)
(365,349,2)
(138,216,2)
(131,366,2)
(135,366,2)
(67,366,2)
(222,298,2)
(391,414,2)
(130,191,2)
(305,366,2)
(160,73,2)
(213,227,2)
(261,366,2)
(373,349,2)
(153,349,2)
(97,408,2)
(304,216,2)
(156,227,2)
(205,298,2)
(291,231,2)
(307,322,2)
(71,216,2)
(13,146,2)
(288,31,2)
(22,349,2)
(170,227,2)
(128,3,2)
(23,15,2)
(224,349,2)
(65,115,2)
(400,366,2)
(402,358,2)
(13,9,2)
(89,232,2)
(396,227,2)
(234,58,2)
(13,15,2)
(192,227,2)
(74,169,2)
(44,287,2)
(113,227,2)
(14,196,2)
(298,216,2)
(75,232,2)
(290,88,2)
(402,344,2)
(95,216,2)
(302,24,2)
(337,349,2)
(335,349,2)
(110,349,2)
(214,366,2)
(323,366,2)
(259,114,2)
(276,322,2)
(12,88,2)
(330,363,2)
(348,366,2)
(264,216,2)
(46,408,2)
(13,211,2)
(164,349,2)
(3,275,2)
(402,243,2)
(352,239,2)
(185,1,2)
(119,408,2)
(404,290,2)
(112,349,2)
(338,366,2)
(376,216,2)
(341,366,2)
(44,266,2)
(13,224,2)
(219,298,2)
(173,65,2)
(21,361,2)
(24,37,2)
(38,88,2)
(1,322,2)
(369,227,2)
(358,299,2)
(53,349,2)
(121,287,2)
(346,366,2)
(17,333,2)
(416,328,2)
(87,366,2)
(249,322,2)
(1,255,2)
(329,196,2)
(224,22,2)
(299,354,2)
(381,349,2)
(161,349,2)
(5,366,2)
(28,349,2)
(273,366,2)
(414,21,2)
(182,349,2)
(35,290,2)
(407,87,2)
(209,191,2)
(359,366,2)
(109,349,2)
(374,216,2)
(13,416,2)
(104,349,2)
(254,196,2)
(385,141,2)
(149,349,2)
(270,366,2)
(243,408,2)
(393,363,2)
(41,322,2)
(175,349,2)
(70,227,2)
(173,231,2)
(63,196,2)
(358,13,2)
(266,287,2)
(416,83,2)
(416,52,2)
(203,232,2)
(126,349,2)
(60,227,2)
(191,322,2)
(86,366,2)
(296,349,2)
(265,290,2)
(340,58,2)
(335,260,2)
(236,227,2)
(146,366,2)
(201,298,2)
(125,196,2)
(166,33,2)
(379,366,2)
(179,138,2)
(316,411,2)
(402,228,2)
(354,407,2)
(302,366,2)
(262,227,2)
(358,9,2)
(388,281,2)
(310,386,2)
(416,23,2)
(157,216,2)
(75,244,2)
(37,10,2)
(416,241,2)
(223,349,2)
(282,366,2)
(327,349,2)
(338,24,2)
(156,48,2)
(136,366,2)
(23,227,2)
(148,349,2)
(13,391,2)
(334,220,2)
(275,191,2)
(6,349,2)
(227,349,2)
(358,310,2)
(114,220,2)
(287,263,2)
(370,349,2)
(339,404,2)
(287,16,2)
(54,241,2)
(19,216,2)
(240,349,2)
(88,170,2)
(33,349,2)
(263,207,2)
(362,366,2)
(90,196,2)
(358,23,2)
(0,393,2)
(401,227,2)
(269,366,2)
(56,408,2)
(286,195,2)
(187,216,2)
(193,349,2)
(388,220,2)
(405,349,2)
(308,216,2)
(402,329,2)
(322,173,2)
(156,337,2)
(154,227,2)
(169,349,2)
(304,385,2)
(195,271,2)
(316,216,2)
(371,349,2)
(91,58,2)
(102,366,2)
(80,349,2)
(51,196,2)
(415,216,2)
(402,179,2)
(355,349,2)
(239,324,2)
(368,298,2)
(241,349,2)
(146,300,2)
(18,349,2)
(380,349,2)
(389,366,2)
(416,211,2)
(409,366,2)
(280,349,2)
(391,349,2)
(397,349,2)
(263,349,2)
(416,224,2)
(82,349,2)
(358,337,2)
(333,93,2)
(325,191,2)
(246,349,2)
(349,408,2)
(17,408,2)
(277,349,2)
(367,195,2)
(305,351,2)
(191,185,2)
(49,88,2)
(23,52,2)
(255,322,2)
(279,349,2)
(243,356,2)
(42,232,2)
(272,191,2)
(206,366,2)
(132,196,2)
(156,328,2)
(378,349,2)
(23,328,2)
(295,191,2)
(273,134,2)
(24,349,2)
(128,191,2)
(118,366,2)
(50,349,2)
(358,211,2)
(174,115,2)
(292,349,2)
(342,216,2)
(228,195,2)
(114,334,2)
(145,191,2)
(283,349,2)
(390,349,2)
(364,195,2)
(134,366,2)
(300,273,2)
(31,216,2)
(9,395,2)
(137,349,2)
(416,156,2)
(244,106,2)
(23,48,2)
(358,305,2)
(313,349,2)
(13,328,2)
(322,231,2)
(13,48,2)
(48,287,2)
(358,416,2)
(30,366,2)
(358,366,2)
(180,366,2)
(165,17,2)
(211,38,2)
(217,408,2)
(238,222,2)
(169,230,2)
(208,349,2)
(13,310,2)
(230,349,2)
(0,363,2)
(129,366,2)
(287,349,2)
(166,349,2)
(293,231,2)
(197,366,2)
(20,366,2)
(167,220,2)
(260,349,2)
(174,195,2)
(326,160,2)
(52,105,2)
(81,231,2)
(78,349,2)
(322,195,2)
(16,349,2)
(144,191,2)
(238,298,2)
(138,316,2)
(416,337,2)
(360,366,2)
(303,298,2)
(13,83,2)
(392,349,2)
(345,227,2)
(311,195,2)
(408,298,2)
(315,366,2)
(358,328,2)
(171,196,2)
(321,195,2)
(43,227,2)
(268,349,2)
(239,349,2)
(156,15,2)
(242,191,2)
(21,349,2)
(215,366,2)
(288,216,2)
(414,349,2)
(331,227,2)
(306,16,2)
(162,349,2)
(93,408,2)
(386,5,2)
(358,391,2)
(300,366,2)
(66,220,2)
(356,298,2)
(310,366,2)
(100,366,2)
(106,232,2)
(92,349,2)
(160,349,2)
(105,216,2)
(328,349,2)
(207,349,2)
(250,408,2)
(320,366,2)
(358,52,2)
(256,191,2)
(343,196,2)
(83,290,2)
(358,48,2)
(127,216,2)
(23,391,2)
(231,174,2)
(377,287,2)
(358,83,2)
(354,366,2)
(281,220,2)
(22,109,2)
(402,165,2)
(188,216,2)
(105,374,2)
(358,146,2)
(58,0,2)
(412,349,2)
(403,105,2)
(133,227,2)
(123,366,2)
(350,366,2)
(179,298,2)
(251,298,2)
(139,227,2)
(116,195,2)
(344,322,2)
(160,335,2)
(253,196,2)
(294,298,2)
(150,366,2)
(416,391,2)
(142,349,2)
(111,363,2)
(312,287,2)
(374,288,2)
(309,349,2)
(65,231,2)
(363,366,2)
(96,366,2)
(124,195,2)
(402,302,2)
(140,227,2)
(147,216,2)
(231,195,2)
(151,349,2)
(326,349,2)
(386,366,2)
(245,366,2)
(13,52,2)
(207,200,2)
(333,408,2)
(27,408,2)
(220,88,2)
(186,287,2)
(109,283,2)
(232,366,2)
(289,363,2)
(194,366,2)
(16,326,2)
(204,404,2)
(13,91,2)
(244,232,2)
(13,337,2)
(115,195,2)
(416,15,2)
(361,349,2)
(229,349,2)
(267,191,2)
(358,389,2)
(47,227,2)
(165,349,2)
(122,298,2)
(301,322,2)
(387,195,2)
-----------------------------------
(0,(cpu_stdext_feature3 & CPUID_STDEXT3_L1D_FLUSH)
(1,basic = rdmsr(MSR_VMX_BASIC)
(2,)
(3,vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,\n\\n\\t\\t\\t       MSR_VMX_TRUE_PROCBASED_CTLS,\n\\n\\t\\t\\t       PROCBASED_CTLS_ONE_SETTING,\n\\n\\t\\t\\t       PROCBASED_CTLS_ZERO_SETTING, &procbased_ctls)
(4,MSR_VMX_BASIC)
(5,cpu_ia32_arch_caps & IA32_ARCH_CAP_RDCL_NO)
(6,0)
(7,if (error)
(8,if (error == 0 && use_tpr_shadow)
(9,cr0_zeros_mask = ~fixed0 & ~fixed1)
(10,int ipinum)
(11,cap_monitor_trap)
(12,pirvec)
(13,cr0_zeros_mask |= (CR0_NW | CR0_CD)
(14,procbased_ctls)
(15,cap_pause_exit = (vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,\n\\n\\t\\t\\t\\t\\t MSR_VMX_TRUE_PROCBASED_CTLS,\n\\n\\t\\t\\t\\t\\t PROCBASED_PAUSE_EXITING, 0,\n\\n\\t\\t\\t\\t\\t &tmp)
(16,error == 0)
(17,error = vmx_set_ctlreg(MSR_VMX_ENTRY_CTLS, MSR_VMX_TRUE_ENTRY_CTLS,\n\\n\\t    VM_ENTRY_CTLS_ONE_SETTING, VM_ENTRY_CTLS_ZERO_SETTING,\n\\n\\t    &entry_ctls)
(18,MSR_VMX_PROCBASED_CTLS)
(19,pinbased_ctls)
(20,fixed0)
(21,vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,\n\\n\\t\\t\\t\\t\\tMSR_VMX_TRUE_PROCBASED_CTLS,\n\\n\\t\\t\\t\\t\\tPROCBASED_HLT_EXITING, 0,\n\\n\\t\\t\\t\\t\\t&tmp)
(22,vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2,\n\\n\\t    MSR_VMX_PROCBASED_CTLS2, PROCBASED2_ENABLE_INVPCID, 0,\n\\n\\t    &tmp)
(23,procbased_ctls |= PROCBASED_USE_TPR_SHADOW)
(24,error = ept_init(ipinum)
(25,)
(26,rdmsr(MSR_VMX_CR0_FIXED1)
(27,entry_ctls)
(28,PROCBASED2_ENABLE_INVPCID)
(29,pirvec)
(30,guest_l1d_flush)
(31,&tmp)
(32,pinbased_ctls)
(33,PROCBASED2_APIC_REGISTER_VIRTUALIZATION |\n\\n\\t    PROCBASED2_VIRTUAL_INTERRUPT_DELIVERY)
(34,if (pirvec < 0)
(35,&posted_interrupts)
(36,ENXIO)
(37,ept_init(ipinum)
(38,lapic_ipi_alloc(pti ? &IDTVEC(justreturn1_pti)
(39,rdmsr(MSR_IA32_FEATURE_CONTROL)
(40,1)
(41,1UL << 54)
(42,CR0_PE)
(43,procbased_ctls &= ~PROCBASED_CR8_LOAD_EXITING)
(44,TUNABLE_INT_FETCH("hw.vmm.vmx.use_apic_vid",\n\\n\\t\\t    &virtual_interrupt_delivery)
(45,error)
(46,MSR_VMX_TRUE_ENTRY_CTLS)
(47,error)
(48,virtual_interrupt_delivery = 1)
(49,0)
(50,MSR_VMX_PROCBASED_CTLS)
(51,MSR_VMX_PROCBASED_CTLS2)
(52,procbased_ctls2 |= PROCBASED2_ENABLE_VPID)
(53,procbased2_vid_bits)
(54,PINBASED_POSTED_INTERRUPT)
(55,if (error == 0)
(56,VM_ENTRY_CTLS_ZERO_SETTING)
(57,vmx_msr_init()
(58,guest_l1d_flush &&\n\\n\\t    (cpu_stdext_feature3 & CPUID_STDEXT3_L1D_FLUSH)
(59,feature_control)
(60,MSR_VMX_PINBASED_CTLS)
(61,basic)
(62,use_tpr_shadow)
(63,error)
(64,if (cap_unrestricted_guest)
(65,feature_control & IA32_FEATURE_CONTROL_VMX_EN)
(66,justreturn)
(67,~fixed0)
(68,error)
(69,)
(70,0)
(71,MSR_VMX_PINBASED_CTLS)
(72,if (error == 0)
(73,&tmp)
(74,vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,\n\\n\\t\\t\\t\\t\\tMSR_VMX_PROCBASED_CTLS,\n\\n\\t\\t\\t\\t\\tPROCBASED_MTF, 0,\n\\n\\t\\t\\t\\t\\t&tmp)
(75,cr0_ones_mask &= ~(CR0_PG | CR0_PE)
(76,)
(77,if (error)
(78,vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,\n\\n\\t\\t\\t\\t\\t MSR_VMX_TRUE_PROCBASED_CTLS,\n\\n\\t\\t\\t\\t\\t PROCBASED_PAUSE_EXITING, 0,\n\\n\\t\\t\\t\\t\\t &tmp)
(79,0)
(80,MSR_VMX_PROCBASED_CTLS2)
(81,IA32_FEATURE_CONTROL_VMX_EN)
(82,cap_pause_exit)
(83,posted_interrupts = 1)
(84,~fixed1)
(85,if ((feature_control & IA32_FEATURE_CONTROL_LOCK)
(86,&guest_l1d_flush)
(87,rdmsr(MSR_VMX_CR4_FIXED1)
(88,error == 0)
(89,cr0_ones_mask)
(90,printf("vmx_init: processor does not support desired primary "\n\\n\\t\\t       "processor-based controls\\n")
(91,vmx_msr_flush_cmd = IA32_FLUSH_CMD_L1D)
(92,PROCBASED2_APIC_REGISTER_VIRTUALIZATION)
(93,&entry_ctls)
(94,if (error)
(95,error)
(96,fixed1)
(97,"vmx_init: processor does not support desired "\n\\n\\t\\t    "exit controls\\n")
(98,tmp)
(99,posted_interrupts)
(100,rdmsr(MSR_VMX_CR4_FIXED0)
(101,if (posted_interrupts)
(102,fixed0)
(103,PROCBASED2_VIRTUAL_INTERRUPT_DELIVERY)
(104,0)
(105,error == 0)
(106,CR0_PG | CR0_PE)
(107,0)
(108,)
(109,vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2,\n\\n\\t    MSR_VMX_PROCBASED_CTLS2, PROCBASED2_ENABLE_INVPCID, 0,\n\\n\\t    &tmp)
(110,PROCBASED2_UNRESTRICTED_GUEST)
(111,0)
(112,PROCBASED_MTF)
(113,error)
(114,&IDTVEC(justreturn1_pti)
(115,feature_control = rdmsr(MSR_IA32_FEATURE_CONTROL)
(116,IA32_FEATURE_CONTROL_LOCK)
(117,"hw.vmm.vmx.use_apic_pir")
(118,fixed1)
(119,error)
(120,)
(121,virtual_interrupt_delivery)
(122,MSR_VMX_TRUE_EXIT_CTLS)
(123,0)
(124,feature_control)
(125,&procbased_ctls2)
(126,tmp)
(127,PROCBASED2_ENABLE_VPID)
(128,error = vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,\n\\n\\t\\t\\t       MSR_VMX_TRUE_PROCBASED_CTLS,\n\\n\\t\\t\\t       PROCBASED_CTLS_ONE_SETTING,\n\\n\\t\\t\\t       PROCBASED_CTLS_ZERO_SETTING, &procbased_ctls)
(129,smp_rendezvous(NULL, vmx_enable, NULL, NULL)
(130,return (EINVAL)
(131,MSR_VMX_CR0_FIXED0)
(132,error)
(133,procbased_ctls2)
(134,rdmsr(MSR_VMX_CR0_FIXED0)
(135,fixed1)
(136,fixed1 = rdmsr(MSR_VMX_CR0_FIXED1)
(137,0)
(138,error = vmx_set_ctlreg(MSR_VMX_PINBASED_CTLS,\n\\n\\t\\t\\t       MSR_VMX_TRUE_PINBASED_CTLS,\n\\n\\t\\t\\t       PINBASED_CTLS_ONE_SETTING,\n\\n\\t\\t\\t       PINBASED_CTLS_ZERO_SETTING, &pinbased_ctls)
(139,procbased2_vid_bits)
(140,procbased_ctls &= ~PROCBASED_CR8_STORE_EXITING)
(141,vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2,\n\\n\\t\\t\\t       MSR_VMX_PROCBASED_CTLS2,\n\\n\\t\\t\\t       PROCBASED_CTLS2_ONE_SETTING,\n\\n\\t\\t\\t       PROCBASED_CTLS2_ZERO_SETTING, &procbased_ctls2)
(142,0)
(143,)
(144,error)
(145,MSR_VMX_PROCBASED_CTLS)
(146,cr0_ones_mask = fixed0 & fixed1)
(147,0)
(148,use_tpr_shadow)
(149,MSR_VMX_TRUE_PROCBASED_CTLS)
(150,"vmx_init: ept initialization failed (%d)
(151,error)
(152,~PROCBASED_CR8_STORE_EXITING)
(153,&tmp)
(154,procbased_ctls)
(155,)
(156,procbased_ctls2 |= procbased2_vid_bits)
(157,error)
(158,1UL)
(159,)
(160,vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2, MSR_VMX_PROCBASED_CTLS2,\n\\n\\t    procbased2_vid_bits, 0, &tmp)
(161,MSR_VMX_PROCBASED_CTLS2)
(162,error)
(163,if (guest_l1d_flush &&\n\\n\\t    (cpu_stdext_feature3 & CPUID_STDEXT3_L1D_FLUSH)
(164,MSR_VMX_PROCBASED_CTLS)
(165,return (error)
(166,PROCBASED2_VIRTUALIZE_X2APIC_MODE |\n\\n\\t    PROCBASED2_APIC_REGISTER_VIRTUALIZATION |\n\\n\\t    PROCBASED2_VIRTUAL_INTERRUPT_DELIVERY)
(167,justreturn1_pti)
(168,fixed1)
(169,vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,\n\\n\\t\\t\\t\\t\\tMSR_VMX_PROCBASED_CTLS,\n\\n\\t\\t\\t\\t\\tPROCBASED_MTF, 0,\n\\n\\t\\t\\t\\t\\t&tmp)
(170,error = vmx_set_ctlreg(MSR_VMX_PINBASED_CTLS,\n\\n\\t\\t    MSR_VMX_TRUE_PINBASED_CTLS, PINBASED_POSTED_INTERRUPT, 0,\n\\n\\t\\t    &tmp)
(171,procbased_ctls &= ~PROCBASED_CTLS_WINDOW_SETTING)
(172,)
(173,(feature_control & IA32_FEATURE_CONTROL_VMX_EN)
(174,feature_control & IA32_FEATURE_CONTROL_LOCK)
(175,MSR_VMX_PROCBASED_CTLS2)
(176,)
(177,CR0_CD)
(178,tmp)
(179,return (error)
(180,cr4_zeros_mask)
(181,if (error)
(182,"vmx_init: processor does not support desired "\n\\n\\t\\t    "entry controls\\n")
(183,tmp)
(184,)
(185,basic & (1UL << 54)
(186,1)
(187,"vmx_init: processor does not support desired secondary "\n\\n\\t\\t       "processor-based controls\\n")
(188,MSR_VMX_PROCBASED_CTLS2)
(189,MSR_VMX_CR4_FIXED0)
(190,exit_ctls)
(191,(basic & (1UL << 54)
(192,MSR_VMX_TRUE_PINBASED_CTLS)
(193,tmp)
(194,fixed0 = rdmsr(MSR_VMX_CR4_FIXED0)
(195,!(cpu_feature2 & CPUID2_VMX)
(196,error)
(197,cpu_ia32_arch_caps)
(198,)
(199,procbased_ctls)
(200,vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,\n\\n\\t    MSR_VMX_TRUE_PROCBASED_CTLS, PROCBASED_USE_TPR_SHADOW, 0,\n\\n\\t    &tmp)
(201,printf("vmx_init: processor does not support desired "\n\\n\\t\\t       "pin-based controls\\n")
(202,PROCBASED_HLT_EXITING)
(203,CR0_PG)
(204,printf("vmx_init: unable to allocate "\n\\n\\t\\t\\t\\t\\t    "posted interrupt vector\\n")
(205,"vmx_init: processor does not support desired "\n\\n\\t\\t       "pin-based controls\\n")
(206,MSR_VMX_CR4_FIXED1)
(207,vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,\n\\n\\t    MSR_VMX_TRUE_PROCBASED_CTLS, PROCBASED_USE_TPR_SHADOW, 0,\n\\n\\t    &tmp)
(208,vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,\n\\n\\t\\t\\t\\t\\t MSR_VMX_TRUE_PROCBASED_CTLS,\n\\n\\t\\t\\t\\t\\t PROCBASED_PAUSE_EXITING, 0,\n\\n\\t\\t\\t\\t\\t &tmp)
(209,PROCBASED_CTLS_ZERO_SETTING)
(210,)
(211,pirvec = lapic_ipi_alloc(pti ? &IDTVEC(justreturn1_pti)
(212,procbased_ctls2)
(213,PROCBASED_USE_TPR_SHADOW)
(214,cr4_ones_mask)
(215,fixed0)
(216,error)
(217,MSR_VMX_ENTRY_CTLS)
(218,"vmx_init: processor does not support desired primary "\n\\n\\t\\t       "processor-based controls\\n")
(219,VM_EXIT_CTLS_ONE_SETTING)
(220,pti)
(221,TUNABLE_INT_FETCH("hw.vmm.vmx.use_apic_pir",\n\\n\\t\\t\\t\\t    &posted_interrupts)
(222,&exit_ctls)
(223,0)
(224,cap_invpcid = (vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2,\n\\n\\t    MSR_VMX_PROCBASED_CTLS2, PROCBASED2_ENABLE_INVPCID, 0,\n\\n\\t    &tmp)
(225,if (virtual_interrupt_delivery)
(226,printf("vmx_init: processor does not support desired secondary "\n\\n\\t\\t       "processor-based controls\\n")
(227,virtual_interrupt_delivery)
(228,return (ENXIO)
(229,0)
(230,&tmp)
(231,(feature_control & IA32_FEATURE_CONTROL_LOCK)
(232,cap_unrestricted_guest)
(233,PROCBASED_USE_TPR_SHADOW)
(234,vmx_msr_flush_cmd)
(235,procbased_ctls)
(236,procbased_ctls2 &= ~PROCBASED2_VIRTUALIZE_X2APIC_MODE)
(237,MSR_VMX_PROCBASED_CTLS2)
(238,vmx_set_ctlreg(MSR_VMX_EXIT_CTLS, MSR_VMX_TRUE_EXIT_CTLS,\n\\n\\t\\t\\t       VM_EXIT_CTLS_ONE_SETTING,\n\\n\\t\\t\\t       VM_EXIT_CTLS_ZERO_SETTING,\n\\n\\t\\t\\t       &exit_ctls)
(239,vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2,\n\\n\\t\\t\\t\\t\\tMSR_VMX_PROCBASED_CTLS2,\n\\n\\t\\t\\t\\t\\tPROCBASED2_UNRESTRICTED_GUEST, 0,\n\\n\\t\\t\\t\\t        &tmp)
(240,PROCBASED2_VIRTUALIZE_X2APIC_MODE)
(241,posted_interrupts)
(242,PROCBASED_CTLS_ONE_SETTING)
(243,return (error)
(244,~(CR0_PG | CR0_PE)
(245,"hw.vmm.l1d_flush")
(246,0)
(247,)
(248,CR0_NW)
(249,printf("vmx_init: VMX operation disabled by BIOS\\n")
(250,printf("vmx_init: processor does not support desired "\n\\n\\t\\t    "exit controls\\n")
(251,error)
(252,MSR_VMX_PROCBASED_CTLS)
(253,PROCBASED_CTLS2_ONE_SETTING)
(254,PROCBASED_CTLS2_ZERO_SETTING)
(255,rdmsr(MSR_VMX_BASIC)
(256,procbased_ctls)
(257,PINBASED_CTLS_ONE_SETTING)
(258,error)
(259,pti ? &IDTVEC(justreturn1_pti)
(260,PROCBASED2_VIRTUALIZE_APIC_ACCESSES |\n\\n\\t    PROCBASED2_VIRTUALIZE_X2APIC_MODE |\n\\n\\t    PROCBASED2_APIC_REGISTER_VIRTUALIZATION |\n\\n\\t    PROCBASED2_VIRTUAL_INTERRUPT_DELIVERY)
(261,NULL)
(262,vmx_set_ctlreg(MSR_VMX_PINBASED_CTLS,\n\\n\\t\\t    MSR_VMX_TRUE_PINBASED_CTLS, PINBASED_POSTED_INTERRUPT, 0,\n\\n\\t\\t    &tmp)
(263,use_tpr_shadow = (vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,\n\\n\\t    MSR_VMX_TRUE_PROCBASED_CTLS, PROCBASED_USE_TPR_SHADOW, 0,\n\\n\\t    &tmp)
(264,MSR_VMX_PROCBASED_CTLS2)
(265,posted_interrupts)
(266,&virtual_interrupt_delivery)
(267,MSR_VMX_TRUE_PROCBASED_CTLS)
(268,0)
(269,vmx_enable)
(270,vpid_init()
(271,cpu_feature2 & CPUID2_VMX)
(272,EINVAL)
(273,fixed0 = rdmsr(MSR_VMX_CR0_FIXED0)
(274,MSR_VMX_TRUE_PROCBASED_CTLS)
(275,&procbased_ctls)
(276,basic)
(277,0)
(278,MSR_VMX_PROCBASED_CTLS2)
(279,&tmp)
(280,PROCBASED2_VIRTUALIZE_APIC_ACCESSES)
(281,IDTVEC(justreturn)
(282,TUNABLE_INT_FETCH("hw.vmm.l1d_flush", &guest_l1d_flush)
(283,&tmp)
(284,if (error)
(285,guest_l1d_flush)
(286,feature_control)
(287,error == 0 && use_tpr_shadow)
(288,vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2, MSR_VMX_PROCBASED_CTLS2,\n\\n\\t\\t\\t       PROCBASED2_ENABLE_VPID, 0, &tmp)
(289,cpu_stdext_feature3)
(290,pirvec < 0)
(291,0)
(292,MSR_VMX_TRUE_PROCBASED_CTLS)
(293,feature_control)
(294,error)
(295,printf("vmx_init: processor does not support desired basic "\n\\n\\t\\t    "capabilities\\n")
(296,PROCBASED_PAUSE_EXITING)
(297,basic)
(298,error)
(299,cr4_ones_mask = fixed0 & fixed1)
(300,fixed0 & fixed1)
(301,54)
(302,return (error)
(303,MSR_VMX_EXIT_CTLS)
(304,return (error)
(305,cr4_zeros_mask = ~fixed0 & ~fixed1)
(306,use_tpr_shadow)
(307,"vmx_init: VMX operation disabled by BIOS\\n")
(308,error)
(309,0)
(310,guest_l1d_flush = (cpu_ia32_arch_caps & IA32_ARCH_CAP_RDCL_NO)
(311,printf("vmx_init: processor does not support VMX operation\\n")
(312,"hw.vmm.vmx.use_apic_vid")
(313,error)
(314,cr0_ones_mask)
(315,0)
(316,vmx_set_ctlreg(MSR_VMX_PINBASED_CTLS,\n\\n\\t\\t\\t       MSR_VMX_TRUE_PINBASED_CTLS,\n\\n\\t\\t\\t       PINBASED_CTLS_ONE_SETTING,\n\\n\\t\\t\\t       PINBASED_CTLS_ZERO_SETTING, &pinbased_ctls)
(317,procbased_ctls2)
(318,~PROCBASED2_VIRTUALIZE_X2APIC_MODE)
(319,0)
(320,1)
(321,MSR_IA32_FEATURE_CONTROL)
(322,(feature_control & IA32_FEATURE_CONTROL_LOCK)
(323,NULL)
(324,&tmp)
(325,"vmx_init: processor does not support desired basic "\n\\n\\t\\t    "capabilities\\n")
(326,error = vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2, MSR_VMX_PROCBASED_CTLS2,\n\\n\\t    procbased2_vid_bits, 0, &tmp)
(327,cap_invpcid)
(328,cap_unrestricted_guest = (vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2,\n\\n\\t\\t\\t\\t\\tMSR_VMX_PROCBASED_CTLS2,\n\\n\\t\\t\\t\\t\\tPROCBASED2_UNRESTRICTED_GUEST, 0,\n\\n\\t\\t\\t\\t        &tmp)
(329,return (error)
(330,CPUID_STDEXT3_L1D_FLUSH)
(331,~PROCBASED_CR8_LOAD_EXITING)
(332,if (bootverbose)
(333,vmx_set_ctlreg(MSR_VMX_ENTRY_CTLS, MSR_VMX_TRUE_ENTRY_CTLS,\n\\n\\t    VM_ENTRY_CTLS_ONE_SETTING, VM_ENTRY_CTLS_ZERO_SETTING,\n\\n\\t    &entry_ctls)
(334,IDTVEC(justreturn1_pti)
(335,procbased2_vid_bits = (PROCBASED2_VIRTUALIZE_APIC_ACCESSES |\n\\n\\t    PROCBASED2_VIRTUALIZE_X2APIC_MODE |\n\\n\\t    PROCBASED2_APIC_REGISTER_VIRTUALIZATION |\n\\n\\t    PROCBASED2_VIRTUAL_INTERRUPT_DELIVERY)
(336,VM_ENTRY_CTLS_ONE_SETTING)
(337,cap_monitor_trap = (vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,\n\\n\\t\\t\\t\\t\\tMSR_VMX_PROCBASED_CTLS,\n\\n\\t\\t\\t\\t\\tPROCBASED_MTF, 0,\n\\n\\t\\t\\t\\t\\t&tmp)
(338,printf("vmx_init: ept initialization failed (%d)
(339,"vmx_init: unable to allocate "\n\\n\\t\\t\\t\\t\\t    "posted interrupt vector\\n")
(340,IA32_FLUSH_CMD_L1D)
(341,NULL)
(342,tmp)
(343,~PROCBASED_CTLS_WINDOW_SETTING)
(344,return (ENXIO)
(345,procbased_ctls2)
(346,error)
(347,if (!(cpu_feature2 & CPUID2_VMX)
(348,cr0_zeros_mask)
(349,error)
(350,MSR_VMX_CR0_FIXED1)
(351,~fixed0 & ~fixed1)
(352,vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2,\n\\n\\t\\t\\t\\t\\tMSR_VMX_PROCBASED_CTLS2,\n\\n\\t\\t\\t\\t\\tPROCBASED2_UNRESTRICTED_GUEST, 0,\n\\n\\t\\t\\t\\t        &tmp)
(353,0)
(354,fixed0 & fixed1)
(355,MSR_VMX_PROCBASED_CTLS)
(356,error = vmx_set_ctlreg(MSR_VMX_EXIT_CTLS, MSR_VMX_TRUE_EXIT_CTLS,\n\\n\\t\\t\\t       VM_EXIT_CTLS_ONE_SETTING,\n\\n\\t\\t\\t       VM_EXIT_CTLS_ZERO_SETTING,\n\\n\\t\\t\\t       &exit_ctls)
(357,fixed0)
(358,return (0)
(359,fixed0)
(360,fixed1)
(361,&tmp)
(362,cr0_zeros_mask)
(363,guest_l1d_flush)
(364,ENXIO)
(365,cap_halt_exit)
(366,error)
(367,"vmx_init: processor does not support VMX operation\\n")
(368,VM_EXIT_CTLS_ZERO_SETTING)
(369,PINBASED_POSTED_INTERRUPT)
(370,MSR_VMX_PROCBASED_CTLS2)
(371,MSR_VMX_PROCBASED_CTLS2)
(372,CR0_NW | CR0_CD)
(373,ipinum)
(374,error = vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2, MSR_VMX_PROCBASED_CTLS2,\n\\n\\t\\t\\t       PROCBASED2_ENABLE_VPID, 0, &tmp)
(375,CPUID2_VMX)
(376,PINBASED_CTLS_ZERO_SETTING)
(377,virtual_interrupt_delivery)
(378,error)
(379,vmx_initialized)
(380,printf("vmx_init: processor does not support desired "\n\\n\\t\\t    "entry controls\\n")
(381,0)
(382,tmp)
(383,)
(384,error)
(385,error = vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS2,\n\\n\\t\\t\\t       MSR_VMX_PROCBASED_CTLS2,\n\\n\\t\\t\\t       PROCBASED_CTLS2_ONE_SETTING,\n\\n\\t\\t\\t       PROCBASED_CTLS2_ZERO_SETTING, &procbased_ctls2)
(386,(cpu_ia32_arch_caps & IA32_ARCH_CAP_RDCL_NO)
(387,1)
(388,&IDTVEC(justreturn)
(389,vmx_initialized = 1)
(390,procbased2_vid_bits)
(391,cap_halt_exit = (vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,\n\\n\\t\\t\\t\\t\\tMSR_VMX_TRUE_PROCBASED_CTLS,\n\\n\\t\\t\\t\\t\\tPROCBASED_HLT_EXITING, 0,\n\\n\\t\\t\\t\\t\\t&tmp)
(392,cap_unrestricted_guest)
(393,cpu_stdext_feature3 & CPUID_STDEXT3_L1D_FLUSH)
(394,procbased2_vid_bits)
(395,~fixed0 & ~fixed1)
(396,&tmp)
(397,tmp)
(398,0)
(399,if (error)
(400,~fixed1)
(401,tmp)
(402,RET)
(403,PROCBASED2_ENABLE_VPID)
(404,bootverbose)
(405,0)
(406,~fixed0)
(407,fixed1 = rdmsr(MSR_VMX_CR4_FIXED1)
(408,error)
(409,IA32_ARCH_CAP_RDCL_NO)
(410,cpu_feature2)
(411,&pinbased_ctls)
(412,tmp)
(413,if ((basic & (1UL << 54)
(414,vmx_set_ctlreg(MSR_VMX_PROCBASED_CTLS,\n\\n\\t\\t\\t\\t\\tMSR_VMX_TRUE_PROCBASED_CTLS,\n\\n\\t\\t\\t\\t\\tPROCBASED_HLT_EXITING, 0,\n\\n\\t\\t\\t\\t\\t&tmp)
(415,MSR_VMX_TRUE_PINBASED_CTLS)
(416,pinbased_ctls |= PINBASED_POSTED_INTERRUPT)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^