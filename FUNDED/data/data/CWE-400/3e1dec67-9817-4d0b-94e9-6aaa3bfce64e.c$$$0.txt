-----label-----
0
-----code-----
static void goodB2G()
{
    size_t data;
    CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_34_unionType myUnion;
    /* Initialize data */
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = "";
        /* POTENTIAL FLAW: Read data from the console using fgets() */
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            /* Convert to unsigned int */
            data = strtoul(inputBuffer, NULL, 0);
        }
        else
        {
            printLine("fgets() failed.");
        }
    }
    myUnion.unionFirst = data;
    {
        size_t data = myUnion.unionSecond;
        {
            char * myString;
            /* FIX: Include a MAXIMUM limitation for memory allocation and a check to ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */
            if (data > strlen(HELLO_STRING) && data < 100)
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                /* Copy a small string into myString */
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine("Input is less than the length of the source string or too large");
            }
        }
    }
}
-----children-----
1,2
1,3
1,4
3,4
5,6
5,7
5,8
5,9
5,10
5,11
6,7
7,8
7,9
8,9
10,11
12,13
13,14
13,15
14,15
16,17
18,19
19,20
19,21
20,21
23,24
23,25
24,25
25,26
25,27
27,28
27,29
27,30
29,30
30,31
32,33
34,35
34,36
34,37
35,36
35,37
36,37
36,38
36,39
36,40
37,38
39,40
41,42
43,44
45,46
47,48
48,49
49,50
49,51
50,51
52,53
52,54
52,55
52,56
53,54
55,56
57,58
60,61
61,62
62,63
62,64
63,64
66,67
67,68
67,69
68,69
68,70
69,70
72,73
74,75
74,76
75,76
76,77
76,78
77,78
79,80
79,81
81,82
82,83
82,84
83,84
86,87
86,88
87,88
88,89
88,90
90,91
90,92
93,94
93,95
93,96
94,95
94,96
95,96
95,97
96,97
98,99
98,100
99,100
101,102
103,104
103,105
104,105
107,108
107,109
107,110
107,111
107,112
108,109
109,110
109,111
110,111
112,113
112,114
113,114
113,115
115,116
117,118
117,119
118,119
120,121
120,122
121,122
123,124
124,125
124,126
127,128
127,129
128,129
128,130
129,130
131,132
133,134
134,135
135,136
135,137
136,137
138,139
140,141
141,142
141,143
141,144
142,143
144,145
146,147
148,149
149,150
149,151
150,151
152,153
154,155
155,156
155,157
156,157
158,159
160,161
161,162
162,163
162,164
163,164
-----nextToken-----
2,4,9,11,15,17,21,22,26,28,31,33,38,40,42,44,46,51,54,56,58,59,64,65,70,71,73,78,80,84,85,89,91,92,97,100,102,105,106,111,114,116,119,122,125,126,130,132,137,139,143,145,147,151,153,157,159,164,165
-----computeFrom-----
19,20
19,21
35,36
35,37
49,50
49,51
67,68
67,69
94,95
94,96
95,96
95,97
103,104
103,105
109,110
109,111
120,121
120,122
128,129
128,130
-----guardedBy-----
40,56
46,58
102,147
105,122
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;IdExpression;Name;EqualsInitializer;LiteralExpression;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;FieldReference;IdExpression;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FunctionCallExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;TypeIdExpression;TypeId;SimpleDeclSpecifier;Declarator;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;
-----ast_node-----
static void goodB2G(){    size_t data;    CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_34_unionType myUnion;    /* Initialize data */    data = 0;    {        char inputBuffer[CHAR_ARRAY_SIZE] = "";        /* POTENTIAL FLAW: Read data from the console using fgets() */        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)        {            /* Convert to unsigned int */            data = strtoul(inputBuffer, NULL, 0);        }        else        {            printLine("fgets() failed.");        }    }    myUnion.unionFirst = data;    {        size_t data = myUnion.unionSecond;        {            char * myString;            /* FIX: Include a MAXIMUM limitation for memory allocation and a check to ensure data is large enough             * for the strcpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > strlen(HELLO_STRING) && data < 100)            {                myString = (char *)malloc(data*sizeof(char));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                strcpy(myString, HELLO_STRING);                printLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string or too large");            }        }    }}
static void
goodB2G()
goodB2G
{    size_t data;    CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_34_unionType myUnion;    /* Initialize data */    data = 0;    {        char inputBuffer[CHAR_ARRAY_SIZE] = "";        /* POTENTIAL FLAW: Read data from the console using fgets() */        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)        {            /* Convert to unsigned int */            data = strtoul(inputBuffer, NULL, 0);        }        else        {            printLine("fgets() failed.");        }    }    myUnion.unionFirst = data;    {        size_t data = myUnion.unionSecond;        {            char * myString;            /* FIX: Include a MAXIMUM limitation for memory allocation and a check to ensure data is large enough             * for the strcpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > strlen(HELLO_STRING) && data < 100)            {                myString = (char *)malloc(data*sizeof(char));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                strcpy(myString, HELLO_STRING);                printLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string or too large");            }        }    }}
size_t data;
size_t data;
size_t
size_t
data
data
CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_34_unionType myUnion;
CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_34_unionType myUnion;
CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_34_unionType
CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_34_unionType
myUnion
myUnion
data = 0;
data = 0
data
data
0
{        char inputBuffer[CHAR_ARRAY_SIZE] = "";        /* POTENTIAL FLAW: Read data from the console using fgets() */        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)        {            /* Convert to unsigned int */            data = strtoul(inputBuffer, NULL, 0);        }        else        {            printLine("fgets() failed.");        }    }
char inputBuffer[CHAR_ARRAY_SIZE] = "";
char inputBuffer[CHAR_ARRAY_SIZE] = "";
char
inputBuffer[CHAR_ARRAY_SIZE] = ""
inputBuffer
[CHAR_ARRAY_SIZE]
CHAR_ARRAY_SIZE
CHAR_ARRAY_SIZE
= ""
""
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)        {            /* Convert to unsigned int */            data = strtoul(inputBuffer, NULL, 0);        }        else        {            printLine("fgets() failed.");        }
fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL
fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin)
fgets
fgets
inputBuffer
inputBuffer
CHAR_ARRAY_SIZE
CHAR_ARRAY_SIZE
stdin
stdin
NULL
NULL
{            /* Convert to unsigned int */            data = strtoul(inputBuffer, NULL, 0);        }
data = strtoul(inputBuffer, NULL, 0);
data = strtoul(inputBuffer, NULL, 0)
data
data
strtoul(inputBuffer, NULL, 0)
strtoul
strtoul
inputBuffer
inputBuffer
NULL
NULL
0
{            printLine("fgets() failed.");        }
printLine("fgets() failed.");
printLine("fgets() failed.")
printLine
printLine
"fgets() failed."
myUnion.unionFirst = data;
myUnion.unionFirst = data
myUnion.unionFirst
myUnion
myUnion
unionFirst
data
data
{        size_t data = myUnion.unionSecond;        {            char * myString;            /* FIX: Include a MAXIMUM limitation for memory allocation and a check to ensure data is large enough             * for the strcpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > strlen(HELLO_STRING) && data < 100)            {                myString = (char *)malloc(data*sizeof(char));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                strcpy(myString, HELLO_STRING);                printLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string or too large");            }        }    }
size_t data = myUnion.unionSecond;
size_t data = myUnion.unionSecond;
size_t
size_t
data = myUnion.unionSecond
data
= myUnion.unionSecond
myUnion.unionSecond
myUnion
myUnion
unionSecond
{            char * myString;            /* FIX: Include a MAXIMUM limitation for memory allocation and a check to ensure data is large enough             * for the strcpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > strlen(HELLO_STRING) && data < 100)            {                myString = (char *)malloc(data*sizeof(char));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                strcpy(myString, HELLO_STRING);                printLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string or too large");            }        }
char * myString;
char * myString;
char
* myString
*
myString
if (data > strlen(HELLO_STRING) && data < 100)            {                myString = (char *)malloc(data*sizeof(char));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                strcpy(myString, HELLO_STRING);                printLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string or too large");            }
data > strlen(HELLO_STRING) && data < 100
data > strlen(HELLO_STRING)
data
data
strlen(HELLO_STRING)
strlen
strlen
HELLO_STRING
HELLO_STRING
data < 100
data
data
100
{                myString = (char *)malloc(data*sizeof(char));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                strcpy(myString, HELLO_STRING);                printLine(myString);                free(myString);            }
myString = (char *)malloc(data*sizeof(char));
myString = (char *)malloc(data*sizeof(char))
myString
myString
(char *)malloc(data*sizeof(char))
char *
char
*
*
malloc(data*sizeof(char))
malloc
malloc
data*sizeof(char)
data
data
sizeof(char)
char
char

if (myString == NULL) {exit(-1);}
myString == NULL
myString
myString
NULL
NULL
{exit(-1);}
exit(-1);
exit(-1)
exit
exit
-1
1
strcpy(myString, HELLO_STRING);
strcpy(myString, HELLO_STRING)
strcpy
strcpy
myString
myString
HELLO_STRING
HELLO_STRING
printLine(myString);
printLine(myString)
printLine
printLine
myString
myString
free(myString);
free(myString)
free
free
myString
myString
{                printLine("Input is less than the length of the source string or too large");            }
printLine("Input is less than the length of the source string or too large");
printLine("Input is less than the length of the source string or too large")
printLine
printLine
"Input is less than the length of the source string or too large"
-----joern-----
(19,66,0)
(60,4,0)
(55,34,0)
(36,34,0)
(16,7,0)
(22,33,0)
(2,56,0)
(40,56,0)
(76,34,0)
(49,0,0)
(69,76,0)
(26,15,0)
(31,15,0)
(40,33,0)
(44,42,0)
(37,24,0)
(38,44,0)
(30,25,0)
(52,75,0)
(42,44,0)
(14,30,0)
(72,45,0)
(18,40,0)
(29,73,0)
(73,10,0)
(27,72,0)
(57,4,0)
(78,75,0)
(32,79,0)
(75,79,0)
(53,74,0)
(6,35,0)
(28,4,0)
(1,76,0)
(29,26,0)
(17,66,0)
(15,26,0)
(50,29,0)
(47,76,0)
(61,29,0)
(29,61,0)
(74,0,0)
(8,28,0)
(7,0,0)
(23,49,0)
(70,18,0)
(74,4,0)
(67,28,0)
(66,79,0)
(42,43,0)
(71,30,0)
(56,76,0)
(41,18,0)
(43,57,0)
(4,0,0)
(20,61,0)
(54,57,0)
(40,79,0)
(25,30,0)
(73,66,0)
(64,6,0)
(49,4,0)
(4,57,0)
(33,79,0)
(42,73,0)
(65,49,0)
(57,43,0)
(12,0,0)
(76,56,0)
(77,42,0)
(11,19,0)
(30,34,0)
(3,73,0)
(7,4,0)
(57,54,0)
(51,37,0)
(9,10,0)
(59,15,0)
(68,19,0)
(43,42,0)
(21,30,0)
(58,40,0)
(56,13,0)
(48,10,0)
(62,79,0)
(39,33,0)
(15,73,0)
(46,27,0)
(5,25,0)
(26,29,0)
(34,75,0)
(10,73,0)
(72,27,0)
(56,76,1)
(16,49,1)
(25,30,1)
(57,54,1)
(26,29,1)
(37,51,1)
(44,38,1)
(25,5,1)
(18,70,1)
(76,47,1)
(28,67,1)
(38,77,1)
(27,46,1)
(55,36,1)
(70,41,1)
(57,43,1)
(69,2,1)
(20,50,1)
(72,27,1)
(3,40,1)
(64,25,1)
(14,71,1)
(6,64,1)
(26,15,1)
(77,60,1)
(23,65,1)
(36,33,1)
(33,22,1)
(73,10,1)
(42,73,1)
(28,4,1)
(29,61,1)
(21,34,1)
(46,28,1)
(41,56,1)
(67,8,1)
(41,6,1)
(63,74,1)
(63,37,1)
(7,4,1)
(60,26,1)
(9,48,1)
(30,14,1)
(22,39,1)
(31,59,1)
(53,7,1)
(8,4,1)
(74,4,1)
(65,28,1)
(5,30,1)
(49,4,1)
(74,53,1)
(40,56,1)
(40,58,1)
(4,57,1)
(61,20,1)
(30,34,1)
(10,9,1)
(58,18,1)
(43,42,1)
(1,69,1)
(71,21,1)
(15,73,1)
(65,72,1)
(34,55,1)
(15,31,1)
(59,29,1)
(49,23,1)
(7,16,1)
(2,25,1)
(29,73,1)
(50,73,1)
(40,33,1)
(42,44,1)
(51,26,1)
(48,3,1)
(47,1,1)
(76,34,1)
(40,56,2)
(57,26,2)
(43,42,2)
(25,30,2)
(28,4,2)
(46,28,2)
(42,73,2)
(29,73,2)
(42,44,2)
(72,27,2)
(40,33,2)
(7,4,2)
(27,28,2)
(60,26,2)
(26,29,2)
(23,26,2)
(57,43,2)
(43,26,2)
(47,25,2)
(49,4,2)
(57,54,2)
(64,25,2)
(15,29,2)
(65,26,2)
(77,26,2)
(6,25,2)
(67,26,2)
(16,26,2)
(76,25,2)
(74,4,2)
(72,28,2)
(4,57,2)
(53,26,2)
(69,25,2)
(76,34,2)
(51,26,2)
(74,26,2)
(15,73,2)
(44,26,2)
(2,25,2)
(42,26,2)
(4,26,2)
(26,15,2)
(31,29,2)
(30,34,2)
(73,10,2)
(1,25,2)
(29,61,2)
(56,25,2)
(8,26,2)
(28,26,2)
(37,26,2)
(7,26,2)
(49,26,2)
(56,76,2)
(59,29,2)
(38,26,2)
-----------------------------------
(0,)
(1,NULL)
(2,data)
(3,data)
(4,myString = (char *)
(5,NULL)
(6,printLine("fgets()
(7,printLine(myString)
(8,myString)
(9,unionSecond)
(10,myUnion.unionSecond)
(11,myString)
(12,if (myString == NULL)
(13,)
(14,stdin)
(15,data < 100)
(16,myString)
(17,data)
(18,myUnion.unionFirst)
(19,)
(20,HELLO_STRING)
(21,inputBuffer)
(22,0)
(23,HELLO_STRING)
(24,)
(25,fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin)
(26,data > strlen(HELLO_STRING)
(27,-1)
(28,myString == NULL)
(29,data > strlen(HELLO_STRING)
(30,fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin)
(31,100)
(32,data)
(33,data = 0)
(34,inputBuffer[CHAR_ARRAY_SIZE] = "")
(35,)
(36,inputBuffer)
(37,printLine("Input is less than the length of the source string or too large")
(38,char)
(39,data)
(40,myUnion.unionFirst = data)
(41,myUnion)
(42,data*sizeof(char)
(43,malloc(data*sizeof(char)
(44,sizeof(char)
(45,)
(46,1)
(47,0)
(48,myUnion)
(49,strcpy(myString, HELLO_STRING)
(50,data)
(51,"Input is less than the length of the source string or too large")
(52,if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin)
(53,myString)
(54,char *)
(55,"")
(56,data = strtoul(inputBuffer, NULL, 0)
(57,(char *)
(58,data)
(59,data)
(60,myString)
(61,strlen(HELLO_STRING)
(62,myUnion)
(63,RET)
(64,"fgets()
(65,myString)
(66,)
(67,NULL)
(68,if (data > strlen(HELLO_STRING)
(69,inputBuffer)
(70,unionFirst)
(71,CHAR_ARRAY_SIZE)
(72,exit(-1)
(73,data = myUnion.unionSecond)
(74,free(myString)
(75,)
(76,strtoul(inputBuffer, NULL, 0)
(77,data)
(78,inputBuffer)
(79,)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^