-----label-----
1
-----code-----
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_32_bad()
{
    size_t data;
    size_t *dataPtr1 = &data;
    size_t *dataPtr2 = &data;
    /* Initialize data */
    data = 0;
    {
        size_t data = *dataPtr1;
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = "";
            /* POTENTIAL FLAW: Read data from the console using fgets() */
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                /* Convert to unsigned int */
                data = strtoul(inputBuffer, NULL, 0);
            }
            else
            {
                printLine("fgets() failed.");
            }
        }
        *dataPtr1 = data;
    }
    {
        size_t data = *dataPtr2;
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */
            if (data > strlen(HELLO_STRING))
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                /* Copy a small string into myString */
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine("Input is less than the length of the source string");
            }
        }
    }
}
-----children-----
1,2
1,3
1,4
3,4
5,6
5,7
5,8
5,9
5,10
5,11
6,7
7,8
7,9
8,9
10,11
12,13
13,14
13,15
14,15
16,17
16,18
16,19
19,20
20,21
21,22
23,24
24,25
24,26
25,26
27,28
27,29
27,30
30,31
31,32
32,33
34,35
35,36
35,37
36,37
39,40
39,41
39,42
40,41
41,42
41,43
42,43
44,45
44,46
46,47
47,48
48,49
50,51
50,52
51,52
52,53
52,54
54,55
54,56
54,57
56,57
57,58
59,60
61,62
61,63
61,64
62,63
62,64
63,64
63,65
63,66
63,67
64,65
66,67
68,69
70,71
72,73
74,75
75,76
76,77
76,78
77,78
79,80
79,81
79,82
79,83
80,81
82,83
84,85
87,88
88,89
89,90
89,91
90,91
93,94
94,95
94,96
95,96
96,97
98,99
100,101
100,102
101,102
102,103
102,104
103,104
105,106
105,107
107,108
108,109
109,110
111,112
111,113
112,113
113,114
113,115
115,116
115,117
118,119
118,120
118,121
119,120
119,121
120,121
122,123
122,124
123,124
125,126
127,128
127,129
127,130
127,131
127,132
128,129
129,130
129,131
130,131
132,133
132,134
133,134
133,135
135,136
137,138
137,139
138,139
140,141
140,142
141,142
143,144
144,145
144,146
147,148
147,149
148,149
148,150
149,150
151,152
153,154
154,155
155,156
155,157
156,157
158,159
160,161
161,162
161,163
161,164
162,163
164,165
166,167
168,169
169,170
169,171
170,171
172,173
174,175
175,176
175,177
176,177
178,179
180,181
181,182
182,183
182,184
183,184
-----nextToken-----
2,4,9,11,15,17,18,22,26,28,29,33,37,38,43,45,49,53,55,58,60,65,67,69,71,73,78,81,83,85,86,91,92,97,99,104,106,110,114,116,117,121,124,126,131,134,136,139,142,145,146,150,152,157,159,163,165,167,171,173,177,179,184,185
-----computeFrom-----
35,36
35,37
62,63
62,64
76,77
76,78
94,95
94,96
119,120
119,121
129,130
129,131
140,141
140,142
148,149
148,150
-----guardedBy-----
67,83
73,85
126,167
121,142
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;UnaryExpression;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;UnaryExpression;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;IdExpression;Name;EqualsInitializer;LiteralExpression;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;UnaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;UnaryExpression;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;IfStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FunctionCallExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;TypeIdExpression;TypeId;SimpleDeclSpecifier;Declarator;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;
-----ast_node-----
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_32_bad(){    size_t data;    size_t *dataPtr1 = &data;    size_t *dataPtr2 = &data;    /* Initialize data */    data = 0;    {        size_t data = *dataPtr1;        {            char inputBuffer[CHAR_ARRAY_SIZE] = "";            /* POTENTIAL FLAW: Read data from the console using fgets() */            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)            {                /* Convert to unsigned int */                data = strtoul(inputBuffer, NULL, 0);            }            else            {                printLine("fgets() failed.");            }        }        *dataPtr1 = data;    }    {        size_t data = *dataPtr2;        {            char * myString;            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough             * for the strcpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > strlen(HELLO_STRING))            {                myString = (char *)malloc(data*sizeof(char));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                strcpy(myString, HELLO_STRING);                printLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string");            }        }    }}
void
CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_32_bad()
CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_32_bad
{    size_t data;    size_t *dataPtr1 = &data;    size_t *dataPtr2 = &data;    /* Initialize data */    data = 0;    {        size_t data = *dataPtr1;        {            char inputBuffer[CHAR_ARRAY_SIZE] = "";            /* POTENTIAL FLAW: Read data from the console using fgets() */            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)            {                /* Convert to unsigned int */                data = strtoul(inputBuffer, NULL, 0);            }            else            {                printLine("fgets() failed.");            }        }        *dataPtr1 = data;    }    {        size_t data = *dataPtr2;        {            char * myString;            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough             * for the strcpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > strlen(HELLO_STRING))            {                myString = (char *)malloc(data*sizeof(char));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                strcpy(myString, HELLO_STRING);                printLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string");            }        }    }}
size_t data;
size_t data;
size_t
size_t
data
data
size_t *dataPtr1 = &data;
size_t *dataPtr1 = &data;
size_t
size_t
*dataPtr1 = &data
*
dataPtr1
= &data
&data
data
data
size_t *dataPtr2 = &data;
size_t *dataPtr2 = &data;
size_t
size_t
*dataPtr2 = &data
*
dataPtr2
= &data
&data
data
data
data = 0;
data = 0
data
data
0
{        size_t data = *dataPtr1;        {            char inputBuffer[CHAR_ARRAY_SIZE] = "";            /* POTENTIAL FLAW: Read data from the console using fgets() */            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)            {                /* Convert to unsigned int */                data = strtoul(inputBuffer, NULL, 0);            }            else            {                printLine("fgets() failed.");            }        }        *dataPtr1 = data;    }
size_t data = *dataPtr1;
size_t data = *dataPtr1;
size_t
size_t
data = *dataPtr1
data
= *dataPtr1
*dataPtr1
dataPtr1
dataPtr1
{            char inputBuffer[CHAR_ARRAY_SIZE] = "";            /* POTENTIAL FLAW: Read data from the console using fgets() */            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)            {                /* Convert to unsigned int */                data = strtoul(inputBuffer, NULL, 0);            }            else            {                printLine("fgets() failed.");            }        }
char inputBuffer[CHAR_ARRAY_SIZE] = "";
char inputBuffer[CHAR_ARRAY_SIZE] = "";
char
inputBuffer[CHAR_ARRAY_SIZE] = ""
inputBuffer
[CHAR_ARRAY_SIZE]
CHAR_ARRAY_SIZE
CHAR_ARRAY_SIZE
= ""
""
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)            {                /* Convert to unsigned int */                data = strtoul(inputBuffer, NULL, 0);            }            else            {                printLine("fgets() failed.");            }
fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL
fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin)
fgets
fgets
inputBuffer
inputBuffer
CHAR_ARRAY_SIZE
CHAR_ARRAY_SIZE
stdin
stdin
NULL
NULL
{                /* Convert to unsigned int */                data = strtoul(inputBuffer, NULL, 0);            }
data = strtoul(inputBuffer, NULL, 0);
data = strtoul(inputBuffer, NULL, 0)
data
data
strtoul(inputBuffer, NULL, 0)
strtoul
strtoul
inputBuffer
inputBuffer
NULL
NULL
0
{                printLine("fgets() failed.");            }
printLine("fgets() failed.");
printLine("fgets() failed.")
printLine
printLine
"fgets() failed."
*dataPtr1 = data;
*dataPtr1 = data
*dataPtr1
dataPtr1
dataPtr1
data
data
{        size_t data = *dataPtr2;        {            char * myString;            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough             * for the strcpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > strlen(HELLO_STRING))            {                myString = (char *)malloc(data*sizeof(char));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                strcpy(myString, HELLO_STRING);                printLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string");            }        }    }
size_t data = *dataPtr2;
size_t data = *dataPtr2;
size_t
size_t
data = *dataPtr2
data
= *dataPtr2
*dataPtr2
dataPtr2
dataPtr2
{            char * myString;            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough             * for the strcpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > strlen(HELLO_STRING))            {                myString = (char *)malloc(data*sizeof(char));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                strcpy(myString, HELLO_STRING);                printLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string");            }        }
char * myString;
char * myString;
char
* myString
*
myString
if (data > strlen(HELLO_STRING))            {                myString = (char *)malloc(data*sizeof(char));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                strcpy(myString, HELLO_STRING);                printLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string");            }
data > strlen(HELLO_STRING)
data
data
strlen(HELLO_STRING)
strlen
strlen
HELLO_STRING
HELLO_STRING
{                myString = (char *)malloc(data*sizeof(char));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                strcpy(myString, HELLO_STRING);                printLine(myString);                free(myString);            }
myString = (char *)malloc(data*sizeof(char));
myString = (char *)malloc(data*sizeof(char))
myString
myString
(char *)malloc(data*sizeof(char))
char *
char
*
*
malloc(data*sizeof(char))
malloc
malloc
data*sizeof(char)
data
data
sizeof(char)
char
char

if (myString == NULL) {exit(-1);}
myString == NULL
myString
myString
NULL
NULL
{exit(-1);}
exit(-1);
exit(-1)
exit
exit
-1
1
strcpy(myString, HELLO_STRING);
strcpy(myString, HELLO_STRING)
strcpy
strcpy
myString
myString
HELLO_STRING
HELLO_STRING
printLine(myString);
printLine(myString)
printLine
printLine
myString
myString
free(myString);
free(myString)
free
free
myString
myString
{                printLine("Input is less than the length of the source string");            }
printLine("Input is less than the length of the source string");
printLine("Input is less than the length of the source string")
printLine
printLine
"Input is less than the length of the source string"
-----joern-----
(15,45,0)
(65,17,0)
(17,57,0)
(80,58,0)
(41,5,0)
(41,75,0)
(9,45,0)
(58,80,0)
(70,9,0)
(50,59,0)
(87,0,0)
(86,69,0)
(77,78,0)
(14,85,0)
(7,6,0)
(39,57,0)
(25,79,0)
(59,56,0)
(4,31,0)
(47,56,0)
(63,23,0)
(27,66,0)
(83,30,0)
(49,0,0)
(84,68,0)
(30,52,0)
(55,35,0)
(16,87,0)
(33,66,0)
(38,23,0)
(87,56,0)
(37,13,0)
(44,25,0)
(82,24,0)
(18,73,0)
(9,87,0)
(40,71,0)
(6,62,0)
(3,41,0)
(61,35,0)
(75,41,0)
(0,87,0)
(19,46,0)
(58,68,0)
(5,41,0)
(59,50,0)
(28,56,0)
(42,77,0)
(64,59,0)
(74,58,0)
(24,3,0)
(3,52,0)
(23,71,0)
(85,71,0)
(41,3,0)
(57,72,0)
(54,80,0)
(85,59,0)
(73,5,0)
(51,58,0)
(1,3,0)
(13,3,0)
(73,71,0)
(2,73,0)
(45,9,0)
(66,69,0)
(32,17,0)
(22,57,0)
(8,76,0)
(24,52,0)
(31,87,0)
(60,28,0)
(79,25,0)
(35,46,0)
(22,45,0)
(17,68,0)
(45,46,0)
(30,3,0)
(48,56,0)
(21,68,0)
(57,17,0)
(12,58,0)
(76,3,0)
(31,22,0)
(73,2,0)
(68,35,0)
(29,17,0)
(36,28,0)
(34,76,0)
(26,52,0)
(71,85,0)
(13,52,0)
(46,56,0)
(23,38,0)
(71,69,0)
(43,22,0)
(22,46,0)
(5,73,0)
(79,53,0)
(69,56,0)
(11,2,0)
(88,38,0)
(10,56,0)
(67,50,0)
(20,30,0)
(68,84,1)
(83,79,1)
(80,58,1)
(22,43,1)
(85,14,1)
(39,80,1)
(24,82,1)
(28,36,1)
(3,41,1)
(11,18,1)
(31,4,1)
(25,44,1)
(0,49,1)
(83,76,1)
(24,3,1)
(76,34,1)
(80,54,1)
(20,83,1)
(13,3,1)
(54,58,1)
(67,64,1)
(9,87,1)
(22,57,1)
(17,68,1)
(41,75,1)
(4,57,1)
(64,87,1)
(73,2,1)
(60,59,1)
(45,9,1)
(42,80,1)
(73,71,1)
(44,76,1)
(76,3,1)
(21,45,1)
(79,25,1)
(88,63,1)
(85,59,1)
(36,60,1)
(82,13,1)
(31,87,1)
(58,68,1)
(51,68,1)
(18,1,1)
(41,5,1)
(43,31,1)
(74,51,1)
(77,42,1)
(40,22,1)
(14,40,1)
(87,0,1)
(32,65,1)
(9,70,1)
(4,77,1)
(15,28,1)
(23,71,1)
(7,23,1)
(59,50,1)
(13,37,1)
(22,45,1)
(5,73,1)
(38,88,1)
(57,17,1)
(81,24,1)
(84,21,1)
(50,67,1)
(30,3,1)
(30,20,1)
(71,85,1)
(65,29,1)
(12,74,1)
(8,3,1)
(17,32,1)
(6,7,1)
(49,16,1)
(29,39,1)
(23,38,1)
(63,71,1)
(81,6,1)
(37,30,1)
(70,15,1)
(1,23,1)
(2,11,1)
(58,12,1)
(34,8,1)
(73,2,2)
(39,80,2)
(32,80,2)
(25,76,2)
(29,80,2)
(24,3,2)
(11,23,2)
(79,25,2)
(30,23,2)
(83,23,2)
(22,45,2)
(7,23,2)
(59,50,2)
(23,71,2)
(23,38,2)
(73,23,2)
(2,23,2)
(31,87,2)
(76,3,2)
(57,80,2)
(65,80,2)
(73,71,2)
(71,85,2)
(77,80,2)
(44,76,2)
(24,23,2)
(41,23,2)
(3,23,2)
(17,68,2)
(8,23,2)
(5,73,2)
(82,23,2)
(6,23,2)
(76,23,2)
(5,23,2)
(30,3,2)
(34,23,2)
(17,80,2)
(80,58,2)
(3,41,2)
(1,23,2)
(42,80,2)
(85,59,2)
(45,9,2)
(37,23,2)
(58,68,2)
(9,87,2)
(87,0,2)
(20,23,2)
(13,3,2)
(41,75,2)
(18,23,2)
(22,57,2)
(79,76,2)
(41,5,2)
(57,17,2)
(13,23,2)
-----------------------------------
(0,&data)
(1,myString)
(2,sizeof(char)
(3,myString = (char *)
(4,dataPtr1)
(5,malloc(data*sizeof(char)
(6,printLine("Input is less than the length of the source string")
(7,"Input is less than the length of the source string")
(8,myString)
(9,*dataPtr1)
(10,dataPtr1)
(11,char)
(12,stdin)
(13,printLine(myString)
(14,dataPtr2)
(15,data)
(16,dataPtr1)
(17,strtoul(inputBuffer, NULL, 0)
(18,data)
(19,data)
(20,HELLO_STRING)
(21,inputBuffer)
(22,*dataPtr1 = data)
(23,data > strlen(HELLO_STRING)
(24,free(myString)
(25,-1)
(26,if (myString == NULL)
(27,if (data > strlen(HELLO_STRING)
(28,data = 0)
(29,inputBuffer)
(30,strcpy(myString, HELLO_STRING)
(31,*dataPtr1)
(32,0)
(33,myString)
(34,NULL)
(35,)
(36,0)
(37,myString)
(38,strlen(HELLO_STRING)
(39,data)
(40,data)
(41,(char *)
(42,"fgets()
(43,data)
(44,1)
(45,data = *dataPtr1)
(46,)
(47,dataPtr2)
(48,data)
(49,data)
(50,&data)
(51,inputBuffer)
(52,)
(53,)
(54,NULL)
(55,inputBuffer)
(56,)
(57,data = strtoul(inputBuffer, NULL, 0)
(58,fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin)
(59,*dataPtr2 = &data)
(60,data)
(61,if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin)
(62,)
(63,data)
(64,dataPtr2)
(65,NULL)
(66,)
(67,data)
(68,inputBuffer[CHAR_ARRAY_SIZE] = "")
(69,)
(70,dataPtr1)
(71,data = *dataPtr2)
(72,)
(73,data*sizeof(char)
(74,CHAR_ARRAY_SIZE)
(75,char *)
(76,myString == NULL)
(77,printLine("fgets()
(78,)
(79,exit(-1)
(80,fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin)
(81,RET)
(82,myString)
(83,myString)
(84,"")
(85,*dataPtr2)
(86,data)
(87,*dataPtr1 = &data)
(88,HELLO_STRING)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^