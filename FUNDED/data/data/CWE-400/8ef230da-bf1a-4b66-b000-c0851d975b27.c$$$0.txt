-----label-----
0
-----code-----
static int nodemgr_host_thread(void *data)
{
	struct hpsb_host *host = data;
	unsigned int g, generation = 0;
	int i, reset_cycles = 0;

	set_freezable();
	/* Setup our device-model entries */
	nodemgr_create_host_dev_files(host);

	for (;;) {
		/* Sleep until next bus reset */
		set_current_state(TASK_INTERRUPTIBLE);
		if (get_hpsb_generation(host) == generation &&
		    !kthread_should_stop())
			schedule();
		__set_current_state(TASK_RUNNING);

		/* Thread may have been woken up to freeze or to exit */
		if (try_to_freeze())
			continue;
		if (kthread_should_stop())
			goto exit;

		/* Pause for 1/4 second in 1/16 second intervals,
		 * to make sure things settle down. */
		g = get_hpsb_generation(host);
		for (i = 0; i < 4 ; i++) {
			msleep_interruptible(63);
			try_to_freeze();
			if (kthread_should_stop())
				goto exit;

			/* Now get the generation in which the node ID's we collect
			 * are valid.  During the bus scan we will use this generation
			 * for the read transactions, so that if another reset occurs
			 * during the scan the transactions will fail instead of
			 * returning bogus data. */
			generation = get_hpsb_generation(host);

			/* If we get a reset before we are done waiting, then
			 * start the waiting over again */
			if (generation != g)
				g = generation, i = 0;
		}

		if (!nodemgr_check_irm_capability(host, reset_cycles) ||
		    !nodemgr_do_irm_duties(host, reset_cycles)) {
			reset_cycles++;
			continue;
		}
		reset_cycles = 0;

		/* Scan our nodes to get the bus options and create node
		 * entries. This does not do the sysfs stuff, since that
		 * would trigger uevents and such, which is a bad idea at
		 * this point. */
		nodemgr_node_scan(host, generation);

		/* This actually does the full probe, with sysfs
		 * registration. */
		if (!nodemgr_node_probe(host, generation))
			continue;

		/* Update some of our sysfs symlinks */
		nodemgr_update_host_dev_links(host);

		/* Sleep 3 seconds */
		for (i = 3000/200; i; i--) {
			msleep_interruptible(200);
			try_to_freeze();
			if (kthread_should_stop())
				goto exit;

			if (generation != get_hpsb_generation(host))
				break;
		}
		/* Remove nodes which are gone, unless a bus reset happened */
		if (!i)
			nodemgr_remove_nodes_in_limbo(host);
	}
exit:
	HPSB_VERBOSE("NodeMgr: Exiting thread");
	return 0;
}
-----children-----
1,2
1,3
1,4
3,4
3,5
5,6
5,7
7,8
7,9
10,11
10,12
10,13
10,14
10,15
10,16
10,17
10,18
11,12
12,13
12,14
13,14
15,16
15,17
15,18
18,19
19,20
21,22
22,23
22,24
22,25
24,25
26,27
26,28
28,29
30,31
31,32
31,33
31,34
33,34
35,36
35,37
37,38
39,40
40,41
41,42
43,44
44,45
44,46
45,46
47,48
49,50
49,51
51,52
51,53
51,54
51,55
51,56
51,57
51,58
51,59
51,60
51,61
51,62
51,63
51,64
51,65
52,53
53,54
53,55
54,55
56,57
57,58
59,60
59,61
60,61
60,62
61,62
61,63
62,63
62,64
63,64
65,66
67,68
69,70
70,71
71,72
73,74
74,75
75,76
77,78
78,79
78,80
79,80
81,82
82,83
84,85
84,86
85,86
86,87
89,90
89,91
90,91
91,92
93,94
95,96
96,97
96,98
97,98
99,100
99,101
100,101
102,103
104,105
104,106
104,107
104,108
105,106
106,107
106,108
107,108
110,111
110,112
111,112
114,115
115,116
117,118
117,119
117,120
117,121
117,122
118,119
119,120
119,121
120,121
123,124
124,125
125,126
127,128
127,129
128,129
129,130
131,132
133,134
134,135
134,136
135,136
137,138
137,139
138,139
140,141
142,143
142,144
143,144
143,145
144,145
146,147
148,149
149,150
149,151
150,151
150,152
151,152
153,154
155,156
155,157
156,157
159,160
159,161
160,161
160,162
161,162
162,163
162,164
162,165
163,164
165,166
167,168
169,170
170,171
170,172
170,173
171,172
173,174
175,176
177,178
177,179
178,179
179,180
180,181
183,184
184,185
184,186
185,186
188,189
189,190
189,191
189,192
190,191
192,193
194,195
196,197
196,198
197,198
198,199
198,200
198,201
199,200
201,202
203,204
206,207
207,208
207,209
208,209
210,211
212,213
212,214
212,215
212,216
213,214
214,215
214,216
215,216
217,218
217,219
220,221
222,223
223,224
225,226
225,227
225,228
225,229
226,227
227,228
227,229
228,229
231,232
232,233
233,234
235,236
235,237
236,237
237,238
239,240
241,242
241,243
242,243
242,244
243,244
245,246
245,247
246,247
248,249
251,252
251,253
252,253
253,254
255,256
256,257
256,258
257,258
259,260
261,262
261,263
263,264
264,265
264,266
265,266
268,269
-----nextToken-----
2,4,6,8,9,14,16,17,20,23,25,27,29,32,34,36,38,42,46,48,50,55,58,64,66,68,72,76,80,83,87,88,92,94,98,101,103,108,109,112,113,116,121,122,126,130,132,136,139,141,145,147,152,154,157,158,164,166,168,172,174,176,181,182,186,187,191,193,195,200,202,204,205,209,211,216,218,219,221,224,229,230,234,238,240,244,247,249,250,254,258,260,262,266,267,269
-----computeFrom-----
60,61
60,62
61,62
61,63
96,97
96,98
106,107
106,108
110,111
110,112
134,135
134,136
143,144
143,145
150,151
150,152
155,156
155,157
160,161
160,162
184,185
184,186
214,215
214,216
217,218
217,219
242,243
242,244
-----guardedBy-----
145,154
147,152
176,181
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;Declarator;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;Declarator;Name;EqualsInitializer;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ForStatement;NullStatement;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;IfStatement;BinaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;FunctionCallExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;IfStatement;FunctionCallExpression;IdExpression;Name;ContinueStatement;IfStatement;FunctionCallExpression;IdExpression;Name;GotoStatement;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;GotoStatement;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;ExpressionList;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;UnaryExpression;IdExpression;Name;ContinueStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ContinueStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;LiteralExpression;LiteralExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;GotoStatement;Name;IfStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BreakStatement;IfStatement;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LabelStatement;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ReturnStatement;LiteralExpression;
-----ast_node-----
static int nodemgr_host_thread(void *data){	struct hpsb_host *host = data;	unsigned int g, generation = 0;	int i, reset_cycles = 0;	set_freezable();	/* Setup our device-model entries */	nodemgr_create_host_dev_files(host);	for (;;) {		/* Sleep until next bus reset */		set_current_state(TASK_INTERRUPTIBLE);		if (get_hpsb_generation(host) == generation &&		    !kthread_should_stop())			schedule();		__set_current_state(TASK_RUNNING);		/* Thread may have been woken up to freeze or to exit */		if (try_to_freeze())			continue;		if (kthread_should_stop())			goto exit;		/* Pause for 1/4 second in 1/16 second intervals,		 * to make sure things settle down. */		g = get_hpsb_generation(host);		for (i = 0; i < 4 ; i++) {			msleep_interruptible(63);			try_to_freeze();			if (kthread_should_stop())				goto exit;			/* Now get the generation in which the node ID's we collect			 * are valid.  During the bus scan we will use this generation			 * for the read transactions, so that if another reset occurs			 * during the scan the transactions will fail instead of			 * returning bogus data. */			generation = get_hpsb_generation(host);			/* If we get a reset before we are done waiting, then			 * start the waiting over again */			if (generation != g)				g = generation, i = 0;		}		if (!nodemgr_check_irm_capability(host, reset_cycles) ||		    !nodemgr_do_irm_duties(host, reset_cycles)) {			reset_cycles++;			continue;		}		reset_cycles = 0;		/* Scan our nodes to get the bus options and create node		 * entries. This does not do the sysfs stuff, since that		 * would trigger uevents and such, which is a bad idea at		 * this point. */		nodemgr_node_scan(host, generation);		/* This actually does the full probe, with sysfs		 * registration. */		if (!nodemgr_node_probe(host, generation))			continue;		/* Update some of our sysfs symlinks */		nodemgr_update_host_dev_links(host);		/* Sleep 3 seconds */		for (i = 3000/200; i; i--) {			msleep_interruptible(200);			try_to_freeze();			if (kthread_should_stop())				goto exit;			if (generation != get_hpsb_generation(host))				break;		}		/* Remove nodes which are gone, unless a bus reset happened */		if (!i)			nodemgr_remove_nodes_in_limbo(host);	}exit:	HPSB_VERBOSE("NodeMgr: Exiting thread");	return 0;}
static int
nodemgr_host_thread(void *data)
nodemgr_host_thread
void *data
void
*data
*
data
{	struct hpsb_host *host = data;	unsigned int g, generation = 0;	int i, reset_cycles = 0;	set_freezable();	/* Setup our device-model entries */	nodemgr_create_host_dev_files(host);	for (;;) {		/* Sleep until next bus reset */		set_current_state(TASK_INTERRUPTIBLE);		if (get_hpsb_generation(host) == generation &&		    !kthread_should_stop())			schedule();		__set_current_state(TASK_RUNNING);		/* Thread may have been woken up to freeze or to exit */		if (try_to_freeze())			continue;		if (kthread_should_stop())			goto exit;		/* Pause for 1/4 second in 1/16 second intervals,		 * to make sure things settle down. */		g = get_hpsb_generation(host);		for (i = 0; i < 4 ; i++) {			msleep_interruptible(63);			try_to_freeze();			if (kthread_should_stop())				goto exit;			/* Now get the generation in which the node ID's we collect			 * are valid.  During the bus scan we will use this generation			 * for the read transactions, so that if another reset occurs			 * during the scan the transactions will fail instead of			 * returning bogus data. */			generation = get_hpsb_generation(host);			/* If we get a reset before we are done waiting, then			 * start the waiting over again */			if (generation != g)				g = generation, i = 0;		}		if (!nodemgr_check_irm_capability(host, reset_cycles) ||		    !nodemgr_do_irm_duties(host, reset_cycles)) {			reset_cycles++;			continue;		}		reset_cycles = 0;		/* Scan our nodes to get the bus options and create node		 * entries. This does not do the sysfs stuff, since that		 * would trigger uevents and such, which is a bad idea at		 * this point. */		nodemgr_node_scan(host, generation);		/* This actually does the full probe, with sysfs		 * registration. */		if (!nodemgr_node_probe(host, generation))			continue;		/* Update some of our sysfs symlinks */		nodemgr_update_host_dev_links(host);		/* Sleep 3 seconds */		for (i = 3000/200; i; i--) {			msleep_interruptible(200);			try_to_freeze();			if (kthread_should_stop())				goto exit;			if (generation != get_hpsb_generation(host))				break;		}		/* Remove nodes which are gone, unless a bus reset happened */		if (!i)			nodemgr_remove_nodes_in_limbo(host);	}exit:	HPSB_VERBOSE("NodeMgr: Exiting thread");	return 0;}
struct hpsb_host *host = data;
struct hpsb_host *host = data;
struct hpsb_host
hpsb_host
*host = data
*
host
= data
data
data
unsigned int g, generation = 0;
unsigned int g, generation = 0;
unsigned int
g
g
generation = 0
generation
= 0
0
int i, reset_cycles = 0;
int i, reset_cycles = 0;
int
i
i
reset_cycles = 0
reset_cycles
= 0
0
set_freezable();
set_freezable()
set_freezable
set_freezable
nodemgr_create_host_dev_files(host);
nodemgr_create_host_dev_files(host)
nodemgr_create_host_dev_files
nodemgr_create_host_dev_files
host
host
for (;;) {		/* Sleep until next bus reset */		set_current_state(TASK_INTERRUPTIBLE);		if (get_hpsb_generation(host) == generation &&		    !kthread_should_stop())			schedule();		__set_current_state(TASK_RUNNING);		/* Thread may have been woken up to freeze or to exit */		if (try_to_freeze())			continue;		if (kthread_should_stop())			goto exit;		/* Pause for 1/4 second in 1/16 second intervals,		 * to make sure things settle down. */		g = get_hpsb_generation(host);		for (i = 0; i < 4 ; i++) {			msleep_interruptible(63);			try_to_freeze();			if (kthread_should_stop())				goto exit;			/* Now get the generation in which the node ID's we collect			 * are valid.  During the bus scan we will use this generation			 * for the read transactions, so that if another reset occurs			 * during the scan the transactions will fail instead of			 * returning bogus data. */			generation = get_hpsb_generation(host);			/* If we get a reset before we are done waiting, then			 * start the waiting over again */			if (generation != g)				g = generation, i = 0;		}		if (!nodemgr_check_irm_capability(host, reset_cycles) ||		    !nodemgr_do_irm_duties(host, reset_cycles)) {			reset_cycles++;			continue;		}		reset_cycles = 0;		/* Scan our nodes to get the bus options and create node		 * entries. This does not do the sysfs stuff, since that		 * would trigger uevents and such, which is a bad idea at		 * this point. */		nodemgr_node_scan(host, generation);		/* This actually does the full probe, with sysfs		 * registration. */		if (!nodemgr_node_probe(host, generation))			continue;		/* Update some of our sysfs symlinks */		nodemgr_update_host_dev_links(host);		/* Sleep 3 seconds */		for (i = 3000/200; i; i--) {			msleep_interruptible(200);			try_to_freeze();			if (kthread_should_stop())				goto exit;			if (generation != get_hpsb_generation(host))				break;		}		/* Remove nodes which are gone, unless a bus reset happened */		if (!i)			nodemgr_remove_nodes_in_limbo(host);	}
;
{		/* Sleep until next bus reset */		set_current_state(TASK_INTERRUPTIBLE);		if (get_hpsb_generation(host) == generation &&		    !kthread_should_stop())			schedule();		__set_current_state(TASK_RUNNING);		/* Thread may have been woken up to freeze or to exit */		if (try_to_freeze())			continue;		if (kthread_should_stop())			goto exit;		/* Pause for 1/4 second in 1/16 second intervals,		 * to make sure things settle down. */		g = get_hpsb_generation(host);		for (i = 0; i < 4 ; i++) {			msleep_interruptible(63);			try_to_freeze();			if (kthread_should_stop())				goto exit;			/* Now get the generation in which the node ID's we collect			 * are valid.  During the bus scan we will use this generation			 * for the read transactions, so that if another reset occurs			 * during the scan the transactions will fail instead of			 * returning bogus data. */			generation = get_hpsb_generation(host);			/* If we get a reset before we are done waiting, then			 * start the waiting over again */			if (generation != g)				g = generation, i = 0;		}		if (!nodemgr_check_irm_capability(host, reset_cycles) ||		    !nodemgr_do_irm_duties(host, reset_cycles)) {			reset_cycles++;			continue;		}		reset_cycles = 0;		/* Scan our nodes to get the bus options and create node		 * entries. This does not do the sysfs stuff, since that		 * would trigger uevents and such, which is a bad idea at		 * this point. */		nodemgr_node_scan(host, generation);		/* This actually does the full probe, with sysfs		 * registration. */		if (!nodemgr_node_probe(host, generation))			continue;		/* Update some of our sysfs symlinks */		nodemgr_update_host_dev_links(host);		/* Sleep 3 seconds */		for (i = 3000/200; i; i--) {			msleep_interruptible(200);			try_to_freeze();			if (kthread_should_stop())				goto exit;			if (generation != get_hpsb_generation(host))				break;		}		/* Remove nodes which are gone, unless a bus reset happened */		if (!i)			nodemgr_remove_nodes_in_limbo(host);	}
set_current_state(TASK_INTERRUPTIBLE);
set_current_state(TASK_INTERRUPTIBLE);
set_current_state
set_current_state
(TASK_INTERRUPTIBLE)
TASK_INTERRUPTIBLE
TASK_INTERRUPTIBLE
if (get_hpsb_generation(host) == generation &&		    !kthread_should_stop())			schedule();
get_hpsb_generation(host) == generation &&		    !kthread_should_stop()
get_hpsb_generation(host) == generation
get_hpsb_generation(host)
get_hpsb_generation
get_hpsb_generation
host
host
generation
generation
!kthread_should_stop()
kthread_should_stop()
kthread_should_stop
kthread_should_stop
schedule();
schedule()
schedule
schedule
__set_current_state(TASK_RUNNING);
__set_current_state(TASK_RUNNING);
__set_current_state
__set_current_state
(TASK_RUNNING)
TASK_RUNNING
TASK_RUNNING
if (try_to_freeze())			continue;
try_to_freeze()
try_to_freeze
try_to_freeze
continue;
if (kthread_should_stop())			goto exit;
kthread_should_stop()
kthread_should_stop
kthread_should_stop
goto exit;
exit
g = get_hpsb_generation(host);
g = get_hpsb_generation(host)
g
g
get_hpsb_generation(host)
get_hpsb_generation
get_hpsb_generation
host
host
for (i = 0; i < 4 ; i++) {			msleep_interruptible(63);			try_to_freeze();			if (kthread_should_stop())				goto exit;			/* Now get the generation in which the node ID's we collect			 * are valid.  During the bus scan we will use this generation			 * for the read transactions, so that if another reset occurs			 * during the scan the transactions will fail instead of			 * returning bogus data. */			generation = get_hpsb_generation(host);			/* If we get a reset before we are done waiting, then			 * start the waiting over again */			if (generation != g)				g = generation, i = 0;		}
i = 0;
i = 0
i
i
0
i < 4
i
i
4
i++
i
i
{			msleep_interruptible(63);			try_to_freeze();			if (kthread_should_stop())				goto exit;			/* Now get the generation in which the node ID's we collect			 * are valid.  During the bus scan we will use this generation			 * for the read transactions, so that if another reset occurs			 * during the scan the transactions will fail instead of			 * returning bogus data. */			generation = get_hpsb_generation(host);			/* If we get a reset before we are done waiting, then			 * start the waiting over again */			if (generation != g)				g = generation, i = 0;		}
msleep_interruptible(63);
msleep_interruptible(63)
msleep_interruptible
msleep_interruptible
63
try_to_freeze();
try_to_freeze()
try_to_freeze
try_to_freeze
if (kthread_should_stop())				goto exit;
kthread_should_stop()
kthread_should_stop
kthread_should_stop
goto exit;
exit
generation = get_hpsb_generation(host);
generation = get_hpsb_generation(host)
generation
generation
get_hpsb_generation(host)
get_hpsb_generation
get_hpsb_generation
host
host
if (generation != g)				g = generation, i = 0;
generation != g
generation
generation
g
g
g = generation, i = 0;
g = generation, i = 0
g = generation
g
g
generation
generation
i = 0
i
i
0
if (!nodemgr_check_irm_capability(host, reset_cycles) ||		    !nodemgr_do_irm_duties(host, reset_cycles)) {			reset_cycles++;			continue;		}
!nodemgr_check_irm_capability(host, reset_cycles) ||		    !nodemgr_do_irm_duties(host, reset_cycles)
!nodemgr_check_irm_capability(host, reset_cycles)
nodemgr_check_irm_capability(host, reset_cycles)
nodemgr_check_irm_capability
nodemgr_check_irm_capability
host
host
reset_cycles
reset_cycles
!nodemgr_do_irm_duties(host, reset_cycles)
nodemgr_do_irm_duties(host, reset_cycles)
nodemgr_do_irm_duties
nodemgr_do_irm_duties
host
host
reset_cycles
reset_cycles
{			reset_cycles++;			continue;		}
reset_cycles++;
reset_cycles++
reset_cycles
reset_cycles
continue;
reset_cycles = 0;
reset_cycles = 0
reset_cycles
reset_cycles
0
nodemgr_node_scan(host, generation);
nodemgr_node_scan(host, generation)
nodemgr_node_scan
nodemgr_node_scan
host
host
generation
generation
if (!nodemgr_node_probe(host, generation))			continue;
!nodemgr_node_probe(host, generation)
nodemgr_node_probe(host, generation)
nodemgr_node_probe
nodemgr_node_probe
host
host
generation
generation
continue;
nodemgr_update_host_dev_links(host);
nodemgr_update_host_dev_links(host)
nodemgr_update_host_dev_links
nodemgr_update_host_dev_links
host
host
for (i = 3000/200; i; i--) {			msleep_interruptible(200);			try_to_freeze();			if (kthread_should_stop())				goto exit;			if (generation != get_hpsb_generation(host))				break;		}
i = 3000/200;
i = 3000/200
i
i
3000/200
3000
200
i
i
i--
i
i
{			msleep_interruptible(200);			try_to_freeze();			if (kthread_should_stop())				goto exit;			if (generation != get_hpsb_generation(host))				break;		}
msleep_interruptible(200);
msleep_interruptible(200)
msleep_interruptible
msleep_interruptible
200
try_to_freeze();
try_to_freeze()
try_to_freeze
try_to_freeze
if (kthread_should_stop())				goto exit;
kthread_should_stop()
kthread_should_stop
kthread_should_stop
goto exit;
exit
if (generation != get_hpsb_generation(host))				break;
generation != get_hpsb_generation(host)
generation
generation
get_hpsb_generation(host)
get_hpsb_generation
get_hpsb_generation
host
host
break;
if (!i)			nodemgr_remove_nodes_in_limbo(host);
!i
i
i
nodemgr_remove_nodes_in_limbo(host);
nodemgr_remove_nodes_in_limbo(host)
nodemgr_remove_nodes_in_limbo
nodemgr_remove_nodes_in_limbo
host
host
exit:	HPSB_VERBOSE("NodeMgr: Exiting thread");
exit
HPSB_VERBOSE("NodeMgr: Exiting thread");
HPSB_VERBOSE("NodeMgr: Exiting thread")
HPSB_VERBOSE
HPSB_VERBOSE
"NodeMgr: Exiting thread"
return 0;
0
-----joern-----
(0,73,0)
(106,23,0)
(5,61,0)
(92,98,0)
(123,7,0)
(4,92,0)
(94,92,0)
(18,83,0)
(59,98,0)
(38,25,0)
(51,115,0)
(34,76,0)
(93,118,0)
(54,115,0)
(101,83,0)
(135,100,0)
(33,98,0)
(117,23,0)
(34,100,0)
(119,4,0)
(118,115,0)
(23,73,0)
(72,93,0)
(78,73,0)
(91,100,0)
(92,108,0)
(66,32,0)
(96,71,0)
(79,99,0)
(55,58,0)
(21,127,0)
(60,22,0)
(60,67,0)
(102,98,0)
(126,26,0)
(70,83,0)
(95,99,0)
(9,48,0)
(131,67,0)
(6,73,0)
(86,90,0)
(8,73,0)
(34,126,0)
(49,8,0)
(132,35,0)
(76,92,0)
(75,118,0)
(67,73,0)
(47,130,0)
(43,111,0)
(85,92,0)
(76,34,0)
(99,40,0)
(28,25,0)
(61,5,0)
(23,83,0)
(41,73,0)
(124,67,0)
(65,46,0)
(70,35,0)
(27,37,0)
(100,98,0)
(68,25,0)
(4,101,0)
(48,130,0)
(61,73,0)
(97,71,0)
(53,98,0)
(90,19,0)
(130,98,0)
(32,99,0)
(112,26,0)
(14,10,0)
(35,40,0)
(1,83,0)
(128,73,0)
(16,22,0)
(101,4,0)
(11,70,0)
(77,35,0)
(56,98,0)
(83,46,0)
(7,98,0)
(101,100,0)
(7,92,0)
(22,16,0)
(103,34,0)
(95,37,0)
(63,76,0)
(111,71,0)
(36,105,0)
(109,53,0)
(24,95,0)
(2,53,0)
(18,92,0)
(39,73,0)
(125,118,0)
(20,75,0)
(113,98,0)
(133,71,0)
(19,90,0)
(84,60,0)
(31,101,0)
(114,73,0)
(70,61,0)
(25,67,0)
(121,73,0)
(107,46,0)
(23,92,0)
(90,92,0)
(60,92,0)
(52,46,0)
(60,130,0)
(16,38,0)
(30,98,0)
(38,16,0)
(3,121,0)
(116,98,0)
(10,46,0)
(90,100,0)
(120,73,0)
(25,92,0)
(44,70,0)
(48,58,0)
(89,98,0)
(23,100,0)
(45,60,0)
(15,99,0)
(26,126,0)
(90,83,0)
(104,18,0)
(83,18,0)
(126,34,0)
(48,67,0)
(115,118,0)
(105,73,0)
(35,83,0)
(74,116,0)
(26,112,0)
(127,92,0)
(105,92,0)
(82,37,0)
(5,92,0)
(50,32,0)
(34,83,0)
(25,38,0)
(29,130,0)
(81,90,0)
(87,98,0)
(17,61,0)
(32,37,0)
(25,130,0)
(22,60,0)
(42,5,0)
(23,92,1)
(23,100,1)
(17,57,1)
(49,12,1)
(49,55,1)
(130,47,1)
(104,1,1)
(13,101,1)
(116,74,1)
(57,80,1)
(75,118,1)
(84,45,1)
(74,134,1)
(44,83,1)
(38,25,1)
(8,49,1)
(70,11,1)
(55,48,1)
(101,83,1)
(5,42,1)
(10,14,1)
(117,67,1)
(88,107,1)
(43,129,1)
(135,91,1)
(27,82,1)
(91,92,1)
(29,100,1)
(3,69,1)
(106,117,1)
(66,95,1)
(63,8,1)
(105,92,1)
(94,85,1)
(81,23,1)
(24,70,1)
(42,17,1)
(95,99,1)
(64,57,1)
(77,70,1)
(18,92,1)
(95,24,1)
(48,130,1)
(90,92,1)
(60,130,1)
(72,13,1)
(34,100,1)
(132,77,1)
(60,67,1)
(21,93,1)
(93,72,1)
(32,99,1)
(83,18,1)
(121,3,1)
(51,54,1)
(115,51,1)
(126,34,1)
(86,81,1)
(119,31,1)
(35,83,1)
(107,10,1)
(36,19,1)
(25,68,1)
(92,94,1)
(109,116,1)
(26,112,1)
(76,92,1)
(49,7,1)
(15,35,1)
(124,131,1)
(16,38,1)
(101,100,1)
(45,32,1)
(75,20,1)
(60,84,1)
(87,130,1)
(100,135,1)
(34,83,1)
(92,108,1)
(3,126,1)
(129,118,1)
(28,22,1)
(9,16,1)
(35,132,1)
(4,119,1)
(19,90,1)
(47,29,1)
(37,27,1)
(96,111,1)
(118,115,1)
(48,67,1)
(82,61,1)
(25,130,1)
(18,104,1)
(25,67,1)
(122,96,1)
(95,37,1)
(23,106,1)
(24,99,1)
(32,50,1)
(69,126,1)
(67,124,1)
(129,75,1)
(53,109,1)
(80,121,1)
(14,32,1)
(20,101,1)
(125,105,1)
(110,19,1)
(66,37,1)
(79,15,1)
(5,92,1)
(1,88,1)
(74,64,1)
(93,118,1)
(34,103,1)
(127,92,1)
(61,5,1)
(70,35,1)
(48,9,1)
(70,83,1)
(126,26,1)
(72,129,1)
(2,53,1)
(134,88,1)
(68,28,1)
(127,21,1)
(34,76,1)
(103,76,1)
(7,92,1)
(25,92,1)
(4,92,1)
(11,44,1)
(70,61,1)
(90,83,1)
(90,86,1)
(49,127,1)
(22,60,1)
(50,66,1)
(49,110,1)
(54,125,1)
(74,62,1)
(123,87,1)
(32,37,1)
(31,122,1)
(90,100,1)
(111,43,1)
(49,93,1)
(101,4,1)
(7,123,1)
(60,92,1)
(23,83,1)
(131,16,1)
(112,34,1)
(99,79,1)
(76,63,1)
(62,122,1)
(12,80,1)
(16,22,1)
(105,36,1)
(99,70,2)
(19,90,2)
(70,88,2)
(38,25,2)
(20,101,2)
(90,100,2)
(45,32,2)
(63,129,2)
(93,129,2)
(127,93,2)
(67,16,2)
(92,108,2)
(105,92,2)
(34,129,2)
(117,16,2)
(70,35,2)
(60,32,2)
(10,32,2)
(3,101,2)
(90,83,2)
(60,92,2)
(24,88,2)
(4,122,2)
(95,88,2)
(19,16,2)
(83,88,2)
(101,4,2)
(75,118,2)
(88,32,2)
(3,19,2)
(122,129,2)
(4,92,2)
(76,19,2)
(49,101,2)
(57,19,2)
(5,92,2)
(121,16,2)
(9,16,2)
(43,129,2)
(129,19,2)
(112,34,2)
(103,19,2)
(38,22,2)
(121,129,2)
(110,19,2)
(134,88,2)
(105,19,2)
(103,80,2)
(126,34,2)
(101,83,2)
(7,92,2)
(60,130,2)
(44,88,2)
(57,129,2)
(37,57,2)
(126,19,2)
(16,38,2)
(79,70,2)
(82,57,2)
(32,37,2)
(63,80,2)
(107,32,2)
(69,126,2)
(16,32,2)
(23,100,2)
(3,129,2)
(18,92,2)
(8,129,2)
(70,61,2)
(35,70,2)
(48,130,2)
(76,129,2)
(62,122,2)
(51,19,2)
(95,37,2)
(72,129,2)
(125,19,2)
(80,16,2)
(93,118,2)
(80,129,2)
(48,16,2)
(132,70,2)
(34,83,2)
(96,129,2)
(25,67,2)
(8,16,2)
(66,57,2)
(22,32,2)
(80,19,2)
(34,76,2)
(119,122,2)
(63,101,2)
(12,80,2)
(16,22,2)
(3,80,2)
(77,70,2)
(86,16,2)
(126,16,2)
(83,18,2)
(36,19,2)
(60,67,2)
(111,129,2)
(22,60,2)
(28,22,2)
(118,19,2)
(25,22,2)
(49,16,2)
(103,16,2)
(50,88,2)
(72,101,2)
(84,32,2)
(95,99,2)
(15,70,2)
(121,19,2)
(14,32,2)
(18,88,2)
(106,16,2)
(34,100,2)
(55,16,2)
(66,88,2)
(25,92,2)
(54,19,2)
(64,57,2)
(3,16,2)
(5,57,2)
(80,80,2)
(76,92,2)
(34,16,2)
(8,101,2)
(49,19,2)
(42,57,2)
(126,129,2)
(127,92,2)
(26,112,2)
(32,99,2)
(49,129,2)
(8,19,2)
(57,101,2)
(103,101,2)
(25,130,2)
(11,88,2)
(34,19,2)
(70,83,2)
(63,16,2)
(115,19,2)
(57,16,2)
(121,101,2)
(93,101,2)
(124,16,2)
(23,16,2)
(61,57,2)
(13,101,2)
(129,101,2)
(131,16,2)
(126,26,2)
(32,88,2)
(48,67,2)
(8,80,2)
(32,57,2)
(68,22,2)
(50,57,2)
(49,80,2)
(101,100,2)
(90,16,2)
(21,93,2)
(31,122,2)
(76,16,2)
(101,122,2)
(1,88,2)
(17,57,2)
(104,88,2)
(75,101,2)
(90,92,2)
(80,101,2)
(63,19,2)
(34,80,2)
(126,80,2)
(34,101,2)
(26,34,2)
(27,57,2)
(23,83,2)
(103,129,2)
(126,101,2)
(61,5,2)
(118,115,2)
(76,101,2)
(2,53,2)
(121,80,2)
(23,92,2)
(81,16,2)
(35,83,2)
(76,80,2)
-----------------------------------
(0,if (!nodemgr_node_probe(host, generation)
(1,generation)
(2,RET)
(3,TASK_RUNNING)
(4,get_hpsb_generation(host)
(5,get_hpsb_generation(host)
(6,for (i = 3000/200; i; i--)
(7,nodemgr_create_host_dev_files(host)
(8,set_current_state(TASK_INTERRUPTIBLE)
(9,reset_cycles)
(10,msleep_interruptible(63)
(11,g)
(12,continue;)
(13,break;)
(14,63)
(15,i)
(16,!nodemgr_check_irm_capability(host, reset_cycles)
(17,g)
(18,get_hpsb_generation(host)
(19,!nodemgr_node_probe(host, generation)
(20,i)
(21,host)
(22,!nodemgr_check_irm_capability(host, reset_cycles)
(23,nodemgr_node_scan(host, generation)
(24,i)
(25,nodemgr_do_irm_duties(host, reset_cycles)
(26,!kthread_should_stop()
(27,0)
(28,host)
(29,reset_cycles)
(30,i)
(31,generation)
(32,i < 4)
(33,reset_cycles)
(34,get_hpsb_generation(host)
(35,g = generation)
(36,host)
(37,i = 0)
(38,!nodemgr_do_irm_duties(host, reset_cycles)
(39,for (i = 0; i < 4 ; i++)
(40,)
(41,if (get_hpsb_generation(host)
(42,host)
(43,200)
(44,generation)
(45,host)
(46,)
(47,0)
(48,reset_cycles++)
(49,TASK_INTERRUPTIBLE)
(50,4)
(51,200)
(52,if (generation != g)
(53,return 0;)
(54,3000)
(55,continue;)
(56,generation)
(57,kthread_should_stop()
(58,)
(59,for (;;)
(60,nodemgr_check_irm_capability(host, reset_cycles)
(61,g = get_hpsb_generation(host)
(62,goto exit;)
(63,host)
(64,goto exit;)
(65,if (kthread_should_stop()
(66,i)
(67,reset_cycles = 0)
(68,reset_cycles)
(69,schedule()
(70,generation != g)
(71,)
(72,i)
(73,)
(74,"NodeMgr: Exiting thread")
(75,i--)
(76,get_hpsb_generation(host)
(77,g)
(78,if (!i)
(79,0)
(80,try_to_freeze()
(81,host)
(82,i)
(83,generation = get_hpsb_generation(host)
(84,reset_cycles)
(85,host)
(86,generation)
(87,set_freezable()
(88,kthread_should_stop()
(89,host)
(90,nodemgr_node_probe(host, generation)
(91,generation)
(92,*host = data)
(93,!i)
(94,data)
(95,i++)
(96,try_to_freeze()
(97,if (kthread_should_stop()
(98,)
(99,i = 0)
(100,generation = 0)
(101,generation != get_hpsb_generation(host)
(102,g)
(103,generation)
(104,host)
(105,nodemgr_update_host_dev_links(host)
(106,generation)
(107,try_to_freeze()
(108,void *data)
(109,0)
(110,continue;)
(111,msleep_interruptible(200)
(112,kthread_should_stop()
(113,exit:)
(114,if (try_to_freeze()
(115,3000/200)
(116,HPSB_VERBOSE("NodeMgr: Exiting thread")
(117,host)
(118,i = 3000/200)
(119,host)
(120,if (!nodemgr_check_irm_capability(host, reset_cycles)
(121,__set_current_state(TASK_RUNNING)
(122,kthread_should_stop()
(123,host)
(124,0)
(125,i)
(126,get_hpsb_generation(host)
(127,nodemgr_remove_nodes_in_limbo(host)
(128,if (kthread_should_stop()
(129,i)
(130,reset_cycles = 0)
(131,reset_cycles)
(132,generation)
(133,if (generation != get_hpsb_generation(host)
(134,goto exit;)
(135,0)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^