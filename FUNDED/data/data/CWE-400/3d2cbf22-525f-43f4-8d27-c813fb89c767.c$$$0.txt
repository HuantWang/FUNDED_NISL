-----label-----
1
-----code-----
int
Tk_PhotoPutBlock(
    Tcl_Interp *interp,		/* Interpreter for passing back error
				 * messages, or NULL. */
    Tk_PhotoHandle handle,	/* Opaque handle for the photo image to be
				 * updated. */
    register Tk_PhotoImageBlock *blockPtr,
				/* Pointer to a structure describing the pixel
				 * data to be copied into the image. */
    int x, int y,		/* Coordinates of the top-left pixel to be
				 * updated in the image. */
    int width, int height,	/* Dimensions of the area of the image to be
				 * updated. */
    int compRule)		/* Compositing rule to use when processing
				 * transparent pixels. */
{
    register PhotoMaster *masterPtr;
    int xEnd, yEnd, greenOffset, blueOffset, alphaOffset;
    int wLeft, hLeft, wCopy, hCopy, pitch;
    unsigned char *srcPtr, *srcLinePtr, *destPtr, *destLinePtr;
    int sourceIsSimplePhoto = compRule & SOURCE_IS_SIMPLE_ALPHA_PHOTO;
    XRectangle rect;

    masterPtr = (PhotoMaster *) handle;
    compRule &= ~SOURCE_IS_SIMPLE_ALPHA_PHOTO;

    if ((masterPtr->userWidth != 0) && ((x + width) > masterPtr->userWidth)) {
	width = masterPtr->userWidth - x;
    }
    if ((masterPtr->userHeight != 0)
	    && ((y + height) > masterPtr->userHeight)) {
	height = masterPtr->userHeight - y;
    }
    if ((width <= 0) || (height <= 0)) {
	return TCL_OK;
    }

    xEnd = x + width;
    yEnd = y + height;
    if ((xEnd > masterPtr->width) || (yEnd > masterPtr->height)) {
	int sameSrc = (blockPtr->pixelPtr == masterPtr->pix32);

	if (ImgPhotoSetSize(masterPtr, MAX(xEnd, masterPtr->width),
		MAX(yEnd, masterPtr->height)) == TCL_ERROR) {
	    if (interp != NULL) {
		Tcl_ResetResult(interp);
		Tcl_AppendResult(interp, TK_PHOTO_ALLOC_FAILURE_MESSAGE, NULL);
	    }
	    return TCL_ERROR;
	}
	if (sameSrc) {
	    blockPtr->pixelPtr = masterPtr->pix32;
	    blockPtr->pitch = masterPtr->width * 4;
	}
    }

    if ((y < masterPtr->ditherY) || ((y == masterPtr->ditherY)
	    && (x < masterPtr->ditherX))) {
	/*
	 * The dithering isn't correct past the start of this block.
	 */

	masterPtr->ditherX = x;
	masterPtr->ditherY = y;
    }

    /*
     * If this image block could have different red, green and blue
     * components, mark it as a color image.
     */

    greenOffset = blockPtr->offset[1] - blockPtr->offset[0];
    blueOffset = blockPtr->offset[2] - blockPtr->offset[0];
    alphaOffset = blockPtr->offset[3];
    if ((alphaOffset >= blockPtr->pixelSize) || (alphaOffset < 0)) {
	alphaOffset = 0;
	sourceIsSimplePhoto = 1;
    } else {
	alphaOffset -= blockPtr->offset[0];
    }
    if ((greenOffset != 0) || (blueOffset != 0)) {
	masterPtr->flags |= COLOR_IMAGE;
    }

    /*
     * Copy the data into our local 32-bit/pixel array. If we can do it with a
     * single memmove, we do.
     */

    destLinePtr = masterPtr->pix32 + (y * masterPtr->width + x) * 4;
    pitch = masterPtr->width * 4;

    /*
     * Test to see if we can do the whole write in a single copy. This test is
     * probably too restrictive. We should also be able to do a memmove if
     * pixelSize == 3 and alphaOffset == 0. Maybe other cases too.
     */

    if ((blockPtr->pixelSize == 4)
	    && (greenOffset == 1) && (blueOffset == 2) && (alphaOffset == 3)
	    && (width <= blockPtr->width) && (height <= blockPtr->height)
	    && ((height == 1) || ((x == 0) && (width == masterPtr->width)
		&& (blockPtr->pitch == pitch)))
	    && (compRule == TK_PHOTO_COMPOSITE_SET)) {
	memmove(destLinePtr, blockPtr->pixelPtr + blockPtr->offset[0],
		(size_t) (height * width * 4));

	/*
	 * We know there's an alpha offset and we're setting the data, so skip
	 * directly to the point when we recompute the photo validity region.
	 */

	goto recalculateValidRegion;
    }

    /*
     * Copy and merge pixels according to the compositing rule.
     */

    for (hLeft = height; hLeft > 0;) {
	int pixelSize = blockPtr->pixelSize;
	int compRuleSet = (compRule == TK_PHOTO_COMPOSITE_SET);

	srcLinePtr = blockPtr->pixelPtr + blockPtr->offset[0];
	hCopy = MIN(hLeft, blockPtr->height);
	hLeft -= hCopy;
	for (; hCopy > 0; --hCopy) {
	    /*
	     * If the layout of the source line matches our memory layout and
	     * we're setting, we can just copy the bytes directly, which is
	     * much faster.
	     */

	    if ((pixelSize == 4) && (greenOffset == 1)
		    && (blueOffset == 2) && (alphaOffset == 3)
		    && (width <= blockPtr->width)
		    && compRuleSet) {
		memcpy(destLinePtr, srcLinePtr, (size_t) (width * 4));
		srcLinePtr += blockPtr->pitch;
		destLinePtr += pitch;
		continue;
	    }

	    /*
	     * Have to copy the slow way.
	     */

	    destPtr = destLinePtr;
	    for (wLeft = width; wLeft > 0;) {
		wCopy = MIN(wLeft, blockPtr->width);
		wLeft -= wCopy;
		srcPtr = srcLinePtr;

		/*
		 * But we might be lucky and be able to use fairly fast loops.
		 * It's worth checking...
		 */

		if (alphaOffset == 0) {
		    /*
		     * This is the non-alpha case, so can still be fairly
		     * fast. Note that in the non-alpha-source case, the
		     * compositing rule doesn't apply.
		     */

		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {
			*destPtr++ = srcPtr[0];
			*destPtr++ = srcPtr[greenOffset];
			*destPtr++ = srcPtr[blueOffset];
			*destPtr++ = 255;
		    }
		    continue;
		} else if (compRuleSet) {
		    /*
		     * This is the SET compositing rule, which just replaces
		     * what was there before with the new data. This is
		     * another fairly fast case. No point in doing a memcpy();
		     * the order of channels is probably wrong.
		     */

		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {
			*destPtr++ = srcPtr[0];
			*destPtr++ = srcPtr[greenOffset];
			*destPtr++ = srcPtr[blueOffset];
			*destPtr++ = srcPtr[alphaOffset];
		    }
		    continue;
		}

		/*
		 * Bother; need to consider the alpha value of each pixel to
		 * know what to do.
		 */

		for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {
		    int alpha = srcPtr[alphaOffset];

		    if (alpha == 255 || !destPtr[3]) {
			/*
			 * Either the source is 100% opaque, or the
			 * destination is entirely blank. In all cases, we
			 * just set the destination to the source.
			 */

			*destPtr++ = srcPtr[0];
			*destPtr++ = srcPtr[greenOffset];
			*destPtr++ = srcPtr[blueOffset];
			*destPtr++ = alpha;
			continue;
		    }

		    /*
		     * Can still skip doing work if the source is 100%
		     * transparent at this point.
		     */

		    if (alpha) {
			int Alpha = destPtr[3];

			/*
			 * OK, there's real work to be done. Luckily, there's
			 * a substantial literature on what to do in this
			 * case. In particular, Porter and Duff have done a
			 * taxonomy of compositing rules, and the right one is
			 * the "Source Over" rule. This code implements that.
			 */

			destPtr[0] = PD_SRC_OVER(srcPtr[0], alpha, destPtr[0],
				Alpha);
			destPtr[1] = PD_SRC_OVER(srcPtr[greenOffset], alpha,
				destPtr[1], Alpha);
			destPtr[2] = PD_SRC_OVER(srcPtr[blueOffset], alpha,
				destPtr[2], Alpha);
			destPtr[3] = PD_SRC_OVER_ALPHA(alpha, Alpha);
		    }

		    destPtr += 4;
		}
	    }
	    srcLinePtr += blockPtr->pitch;
	    destLinePtr += pitch;
	}
    }

    /*
     * Add this new block to the region which specifies which data is valid.
     */

    if (alphaOffset) {
	/*
	 * This block is grossly inefficient. For each row in the image, it
	 * finds each continguous string of nontransparent pixels, then marks
	 * those areas as valid in the validRegion mask. This makes drawing
	 * very efficient, because of the way we use X: we just say, here's
	 * your mask, and here's your data. We need not worry about the
	 * current background color, etc. But this costs us a lot on the image
	 * setup. Still, image setup only happens once, whereas the drawing
	 * happens many times, so this might be the best way to go.
	 *
	 * An alternative might be to not set up this mask, and instead, at
	 * drawing time, for each transparent pixel, set its color to the
	 * color of the background behind that pixel. This is what I suspect
	 * most of programs do. However, they don't have to deal with the
	 * canvas, which could have many different background colors.
	 * Determining the correct bg color for a given pixel might be
	 * expensive.
	 */

	if (compRule != TK_PHOTO_COMPOSITE_OVERLAY) {
	    TkRegion workRgn;

	    /*
	     * Don't need this when using the OVERLAY compositing rule, which
	     * always strictly increases the valid region.
	     */

	recalculateValidRegion:
	    workRgn = TkCreateRegion();
	    rect.x = x;
	    rect.y = y;
	    rect.width = width;
	    rect.height = height;
	    TkUnionRectWithRegion(&rect, workRgn, workRgn);
	    TkSubtractRegion(masterPtr->validRegion, workRgn,
		    masterPtr->validRegion);
	    TkDestroyRegion(workRgn);
	}

	/*
	 * Factorize out the main part of the building of the region data to
	 * allow for more efficient per-platform implementations. [Bug 919066]
	 */

	TkpBuildRegionFromAlphaData(masterPtr->validRegion, (unsigned) x,
		(unsigned) y, (unsigned) width, (unsigned) height,
		masterPtr->pix32 + (y * masterPtr->width + x) * 4 + 3,
		4, (unsigned) masterPtr->width * 4);
    } else {
	rect.x = x;
	rect.y = y;
	rect.width = width;
	rect.height = height;
	TkUnionRectWithRegion(&rect, masterPtr->validRegion,
		masterPtr->validRegion);
    }

    /*
     * Check if display code needs alpha blending...
     */

    if (!sourceIsSimplePhoto && (width == 1) && (height == 1)) {
	/*
	 * Optimize the single pixel case if we can. This speeds up code that
	 * builds up large simple-alpha images by single pixels.  We don't
	 * negate COMPLEX_ALPHA in this case. [Bug 1409140]
	 */

	if (!(masterPtr->flags & COMPLEX_ALPHA)) {
	    unsigned char newAlpha;

	    destLinePtr = masterPtr->pix32 + (y * masterPtr->width + x) * 4;
	    newAlpha = destLinePtr[3];

	    if (newAlpha && newAlpha != 255) {
		masterPtr->flags |= COMPLEX_ALPHA;
	    }
	}
    } else if ((alphaOffset != 0) || (masterPtr->flags & COMPLEX_ALPHA)) {
	/*
	 * Check for partial transparency if alpha pixels are specified, or
	 * rescan if we already knew such pixels existed.  To restrict this
	 * Toggle to only checking the changed pixels requires knowing where
	 * the alpha pixels are.
	 */

	ToggleComplexAlphaIfNeeded(masterPtr);
    }

    /*
     * Update each instance.
     */

    Tk_DitherPhoto((Tk_PhotoHandle)masterPtr, x, y, width, height);

    /*
     * Tell the core image code that this image has changed.
     */

    Tk_ImageChanged(masterPtr->tkMaster, x, y, width, height,
	    masterPtr->width, masterPtr->height);
    return TCL_OK;
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
3,7
3,8
3,9
3,10
3,11
3,12
5,6
5,7
6,7
8,9
8,10
11,12
11,13
12,13
14,15
16,17
16,18
17,18
19,20
19,21
22,23
22,24
24,25
26,27
26,28
28,29
30,31
30,32
32,33
34,35
34,36
36,37
38,39
38,40
40,41
42,43
42,44
42,45
42,46
42,47
42,48
42,49
42,50
42,51
42,52
42,53
42,54
42,55
42,56
42,57
42,58
42,59
42,60
42,61
42,62
42,63
42,64
42,65
42,66
42,67
42,68
42,69
42,70
42,71
43,44
44,45
44,46
45,46
47,48
47,49
50,51
51,52
51,53
51,54
51,55
51,56
51,57
53,54
55,56
57,58
59,60
61,62
63,64
64,65
64,66
64,67
64,68
64,69
64,70
66,67
68,69
70,71
72,73
74,75
76,77
77,78
77,79
77,80
77,81
77,82
79,80
79,81
82,83
82,84
85,86
85,87
88,89
88,90
91,92
92,93
92,94
94,95
94,96
96,97
97,98
97,99
98,99
100,101
102,103
103,104
103,105
104,105
106,107
108,109
109,110
109,111
110,111
112,113
112,114
113,114
113,115
114,115
116,117
118,119
120,121
121,122
121,123
122,123
124,125
125,126
127,128
127,129
128,129
128,130
129,130
130,131
130,132
131,132
131,133
132,133
136,137
137,138
137,139
138,139
139,140
139,141
140,141
142,143
144,145
144,146
145,146
148,149
149,150
150,151
150,152
151,152
153,154
153,155
154,155
154,156
155,156
158,159
160,161
160,162
161,162
161,163
162,163
163,164
163,165
164,165
164,166
165,166
169,170
170,171
170,172
171,172
172,173
172,174
173,174
175,176
177,178
177,179
178,179
181,182
182,183
183,184
183,185
184,185
186,187
186,188
187,188
187,189
188,189
191,192
193,194
193,195
194,195
194,196
195,196
196,197
196,198
197,198
200,201
201,202
201,203
202,203
205,206
206,207
207,208
209,210
210,211
210,212
211,212
213,214
213,215
214,215
216,217
218,219
219,220
219,221
220,221
222,223
222,224
223,224
225,226
227,228
227,229
228,229
228,230
229,230
230,231
230,232
231,232
233,234
233,235
234,235
237,238
238,239
238,240
239,240
241,242
241,243
242,243
245,246
245,247
245,248
246,247
247,248
247,249
249,250
249,251
251,252
252,253
253,254
253,255
254,255
254,256
255,256
258,259
258,260
259,260
262,263
262,264
263,264
263,265
264,265
264,266
264,267
264,268
265,266
267,268
269,270
269,271
269,272
270,271
272,273
274,275
274,276
275,276
278,279
278,280
278,281
279,280
281,282
283,284
283,285
284,285
287,288
289,290
289,291
290,291
290,292
291,292
291,293
292,293
294,295
296,297
296,298
297,298
298,299
298,300
299,300
301,302
303,304
304,305
304,306
304,307
304,308
305,306
307,308
309,310
311,312
313,314
314,315
316,317
316,318
317,318
319,320
319,321
320,321
321,322
321,323
322,323
322,324
323,324
326,327
326,328
327,328
330,331
331,332
331,333
332,333
332,334
333,334
336,337
336,338
337,338
337,339
338,339
342,343
342,344
343,344
343,345
344,345
345,346
345,347
346,347
348,349
348,350
349,350
352,353
353,354
353,355
354,355
355,356
355,357
356,357
358,359
358,360
359,360
362,363
363,364
363,365
364,365
366,367
366,368
367,368
370,371
370,372
371,372
372,373
372,374
373,374
373,375
374,375
377,378
379,380
380,381
380,382
381,382
381,383
382,383
385,386
387,388
388,389
388,390
389,390
391,392
391,393
392,393
392,394
393,394
393,395
394,395
398,399
398,400
399,400
399,401
400,401
404,405
405,406
405,407
406,407
408,409
408,410
409,410
409,411
410,411
410,412
411,412
415,416
415,417
416,417
416,418
417,418
421,422
422,423
422,424
423,424
425,426
425,427
426,427
426,428
427,428
431,432
431,433
431,434
432,433
432,434
433,434
434,435
434,436
435,436
437,438
437,439
438,439
441,442
442,443
442,444
443,444
446,447
446,448
447,448
448,449
448,450
449,450
452,453
453,454
453,455
454,455
457,458
458,459
459,460
459,461
460,461
462,463
462,464
463,464
463,465
464,465
468,469
468,470
469,470
469,471
470,471
471,472
471,473
472,473
475,476
476,477
476,478
477,478
480,481
481,482
482,483
482,484
483,484
483,485
484,485
487,488
489,490
490,491
490,492
491,492
493,494
493,495
494,495
494,496
495,496
498,499
498,500
499,500
500,501
500,502
501,502
501,503
502,503
504,505
504,506
505,506
508,509
511,512
512,513
512,514
513,514
515,516
515,517
516,517
516,518
517,518
521,522
521,523
522,523
522,524
523,524
523,525
524,525
524,526
525,526
525,527
526,527
526,528
527,528
527,529
528,529
528,530
529,530
530,531
530,532
531,532
531,533
532,533
536,537
537,538
537,539
538,539
541,542
542,543
542,544
543,544
546,547
547,548
547,549
548,549
551,552
552,553
552,554
553,554
555,556
555,557
556,557
559,560
560,561
560,562
561,562
563,564
563,565
564,565
567,568
568,569
568,570
569,570
570,571
570,572
571,572
574,575
575,576
575,577
576,577
576,578
577,578
578,579
578,580
579,580
582,583
583,584
583,585
584,585
586,587
586,588
587,588
590,591
591,592
591,593
592,593
592,594
593,594
596,597
598,599
599,600
599,601
600,601
602,603
604,605
604,606
605,606
606,607
606,608
606,609
606,610
607,608
609,610
611,612
611,613
612,613
612,614
613,614
616,617
616,618
617,618
617,619
618,619
622,623
622,624
623,624
624,625
626,627
626,628
627,628
627,629
628,629
630,631
633,634
635,636
635,637
635,638
636,637
637,638
637,639
638,639
640,641
642,643
642,644
643,644
646,647
646,648
646,649
646,650
646,651
646,652
647,648
648,649
648,650
650,651
650,652
652,653
653,654
653,655
654,655
657,658
658,659
658,660
660,661
660,662
662,663
663,664
664,665
664,666
665,666
667,668
669,670
670,671
670,672
671,672
673,674
673,675
674,675
674,676
675,676
678,679
678,680
679,680
679,681
680,681
684,685
685,686
685,687
686,687
688,689
688,690
688,691
689,690
691,692
693,694
693,695
694,695
697,698
698,699
698,700
699,700
701,702
703,704
703,705
703,706
703,707
705,706
705,707
706,707
709,710
710,711
712,713
712,714
712,715
712,716
712,717
713,714
713,715
714,715
714,716
715,716
715,717
716,717
716,718
717,718
717,719
718,719
718,720
719,720
720,721
720,722
721,722
724,725
725,726
725,727
726,727
729,730
730,731
730,732
731,732
734,735
735,736
735,737
736,737
739,740
740,741
740,742
741,742
743,744
743,745
744,745
747,748
749,750
749,751
749,752
749,753
750,751
751,752
751,753
751,754
751,755
752,753
754,755
756,757
758,759
758,760
759,760
760,761
762,763
762,764
763,764
766,767
767,768
767,769
768,769
770,771
770,772
771,772
774,775
775,776
775,777
776,777
778,779
781,782
782,783
782,784
783,784
785,786
787,788
787,789
787,790
788,789
789,790
789,791
790,791
792,793
794,795
794,796
795,796
798,799
798,800
798,801
798,802
798,803
799,800
800,801
800,802
801,802
803,804
803,805
803,806
804,805
806,807
808,809
808,810
809,810
812,813
813,814
813,815
814,815
816,817
818,819
819,820
819,821
820,821
822,823
824,825
824,826
824,827
825,826
825,827
826,827
829,830
829,831
830,831
830,832
830,833
830,834
832,833
832,834
833,834
836,837
836,838
837,838
838,839
840,841
840,842
841,842
843,844
845,846
845,847
845,848
845,849
846,847
847,848
847,849
848,849
849,850
850,851
852,853
852,854
853,854
856,857
857,858
857,859
858,859
859,860
860,861
862,863
862,864
863,864
865,866
867,868
868,869
868,870
869,870
870,871
871,872
873,874
873,875
874,875
876,877
878,879
879,880
879,881
880,881
881,882
882,883
886,887
886,888
887,888
889,890
889,891
890,891
890,892
890,893
890,894
892,893
892,894
893,894
896,897
896,898
897,898
898,899
900,901
900,902
901,902
903,904
905,906
905,907
905,908
905,909
906,907
907,908
907,909
908,909
909,910
910,911
912,913
912,914
913,914
916,917
917,918
917,919
918,919
919,920
920,921
922,923
922,924
923,924
925,926
927,928
928,929
928,930
929,930
930,931
931,932
933,934
933,935
934,935
936,937
938,939
939,940
939,941
940,941
941,942
942,943
944,945
944,946
945,946
947,948
950,951
950,952
950,953
950,954
952,953
952,954
953,954
956,957
956,958
957,958
958,959
960,961
960,962
961,962
963,964
965,966
965,967
965,968
965,969
966,967
967,968
967,969
969,970
969,971
971,972
972,973
972,974
973,974
975,976
977,978
977,979
978,979
978,980
979,980
979,981
980,981
983,984
984,985
984,986
985,986
988,989
988,990
988,991
988,992
988,993
989,990
990,991
990,992
991,992
992,993
993,994
995,996
995,997
996,997
999,1000
1000,1001
1000,1002
1001,1002
1002,1003
1003,1004
1005,1006
1005,1007
1006,1007
1008,1009
1010,1011
1011,1012
1011,1013
1012,1013
1013,1014
1014,1015
1016,1017
1016,1018
1017,1018
1019,1020
1021,1022
1022,1023
1022,1024
1023,1024
1024,1025
1025,1026
1027,1028
1030,1031
1030,1032
1031,1032
1033,1034
1033,1035
1033,1036
1033,1037
1033,1038
1034,1035
1035,1036
1035,1037
1037,1038
1037,1039
1039,1040
1040,1041
1040,1042
1041,1042
1044,1045
1045,1046
1045,1047
1046,1047
1046,1048
1047,1048
1050,1051
1050,1052
1050,1053
1050,1054
1050,1055
1051,1052
1053,1054
1053,1055
1054,1055
1057,1058
1059,1060
1059,1061
1060,1061
1063,1064
1065,1066
1066,1067
1066,1068
1067,1068
1067,1069
1068,1069
1071,1072
1071,1073
1071,1074
1071,1075
1071,1076
1072,1073
1074,1075
1074,1076
1075,1076
1077,1078
1079,1080
1081,1082
1081,1083
1082,1083
1085,1086
1087,1088
1088,1089
1088,1090
1089,1090
1089,1091
1090,1091
1093,1094
1093,1095
1093,1096
1093,1097
1093,1098
1094,1095
1096,1097
1096,1098
1097,1098
1099,1100
1101,1102
1103,1104
1103,1105
1104,1105
1107,1108
1109,1110
1110,1111
1110,1112
1111,1112
1111,1113
1112,1113
1115,1116
1115,1117
1115,1118
1116,1117
1118,1119
1120,1121
1122,1123
1123,1124
1123,1125
1124,1125
1127,1128
1128,1129
1128,1130
1129,1130
1131,1132
1131,1133
1132,1133
1135,1136
1136,1137
1136,1138
1137,1138
1139,1140
1141,1142
1141,1143
1141,1144
1142,1143
1144,1145
1144,1146
1145,1146
1145,1147
1146,1147
1146,1148
1147,1148
1149,1150
1151,1152
1151,1153
1151,1154
1151,1155
1151,1156
1151,1157
1151,1158
1151,1159
1151,1160
1152,1153
1153,1154
1153,1155
1154,1155
1156,1157
1158,1159
1158,1160
1160,1161
1161,1162
1161,1163
1162,1163
1164,1165
1165,1166
1167,1168
1168,1169
1168,1170
1169,1170
1169,1171
1170,1171
1173,1174
1175,1176
1176,1177
1176,1178
1177,1178
1177,1179
1178,1179
1181,1182
1183,1184
1184,1185
1184,1186
1185,1186
1185,1187
1186,1187
1189,1190
1191,1192
1192,1193
1192,1194
1193,1194
1193,1195
1194,1195
1197,1198
1199,1200
1200,1201
1200,1202
1200,1203
1200,1204
1201,1202
1203,1204
1204,1205
1206,1207
1208,1209
1210,1211
1211,1212
1211,1213
1211,1214
1211,1215
1212,1213
1214,1215
1214,1216
1215,1216
1218,1219
1220,1221
1220,1222
1221,1222
1224,1225
1225,1226
1225,1227
1226,1227
1228,1229
1230,1231
1231,1232
1231,1233
1231,1234
1231,1235
1231,1236
1231,1237
1231,1238
1231,1239
1231,1240
1232,1233
1234,1235
1234,1236
1235,1236
1238,1239
1238,1240
1239,1240
1239,1241
1242,1243
1244,1245
1244,1246
1245,1246
1245,1247
1248,1249
1250,1251
1250,1252
1251,1252
1251,1253
1254,1255
1256,1257
1256,1258
1257,1258
1257,1259
1260,1261
1262,1263
1262,1264
1263,1264
1263,1265
1264,1265
1264,1266
1265,1266
1268,1269
1268,1270
1269,1270
1270,1271
1270,1272
1271,1272
1271,1273
1272,1273
1274,1275
1274,1276
1275,1276
1278,1279
1283,1284
1283,1285
1284,1285
1284,1286
1285,1286
1285,1287
1288,1289
1288,1290
1289,1290
1293,1294
1293,1295
1293,1296
1293,1297
1293,1298
1294,1295
1295,1296
1295,1297
1296,1297
1296,1298
1297,1298
1300,1301
1302,1303
1303,1304
1303,1305
1304,1305
1304,1306
1305,1306
1308,1309
1310,1311
1311,1312
1311,1313
1312,1313
1312,1314
1313,1314
1316,1317
1318,1319
1319,1320
1319,1321
1320,1321
1320,1322
1321,1322
1324,1325
1326,1327
1327,1328
1327,1329
1327,1330
1327,1331
1328,1329
1330,1331
1331,1332
1333,1334
1333,1335
1334,1335
1337,1338
1337,1339
1338,1339
1341,1342
1341,1343
1341,1344
1342,1343
1342,1344
1343,1344
1343,1345
1344,1345
1345,1346
1347,1348
1348,1349
1348,1350
1349,1350
1352,1353
1353,1354
1353,1355
1354,1355
1357,1358
1358,1359
1358,1360
1359,1360
1360,1361
1361,1362
1361,1363
1362,1363
1362,1364
1363,1364
1366,1367
1368,1369
1368,1370
1368,1371
1368,1372
1369,1370
1370,1371
1370,1372
1372,1373
1374,1375
1375,1376
1375,1377
1376,1377
1378,1379
1378,1380
1379,1380
1379,1381
1380,1381
1383,1384
1383,1385
1384,1385
1385,1386
1385,1387
1386,1387
1386,1388
1387,1388
1389,1390
1389,1391
1390,1391
1393,1394
1396,1397
1397,1398
1397,1399
1398,1399
1400,1401
1400,1402
1401,1402
1404,1405
1404,1406
1405,1406
1405,1407
1406,1407
1408,1409
1408,1410
1409,1410
1412,1413
1413,1414
1414,1415
1414,1416
1415,1416
1415,1417
1416,1417
1419,1420
1421,1422
1421,1423
1422,1423
1422,1424
1423,1424
1424,1425
1424,1426
1425,1426
1428,1429
1429,1430
1429,1431
1430,1431
1430,1432
1431,1432
1434,1435
1436,1437
1437,1438
1438,1439
1438,1440
1439,1440
1441,1442
1443,1444
1444,1445
1444,1446
1444,1447
1444,1448
1444,1449
1444,1450
1445,1446
1447,1448
1447,1449
1448,1449
1448,1450
1449,1450
1452,1453
1454,1455
1456,1457
1458,1459
1460,1461
1462,1463
1463,1464
1463,1465
1463,1466
1463,1467
1463,1468
1463,1469
1463,1470
1463,1471
1464,1465
1466,1467
1466,1468
1467,1468
1470,1471
1472,1473
1474,1475
1476,1477
1478,1479
1478,1480
1479,1480
1482,1483
1482,1484
1483,1484
1486,1487
1487,1488
-----nextToken-----
2,4,7,9,10,13,15,18,20,21,23,25,27,29,31,33,35,37,39,41,46,48,49,52,54,56,58,60,62,65,67,69,71,73,75,78,80,81,83,84,86,87,89,90,93,95,99,101,105,107,111,115,117,119,123,126,133,134,135,141,143,146,147,152,156,157,159,166,167,168,174,176,179,180,185,189,190,192,198,199,203,204,208,212,215,217,221,224,226,232,235,236,240,243,244,248,250,256,257,260,261,266,268,271,273,276,277,280,282,285,286,288,293,295,300,302,306,308,310,312,315,318,324,325,328,329,334,335,339,340,341,347,350,351,357,360,361,365,368,369,375,376,378,383,384,386,390,395,396,397,401,402,403,407,412,413,414,418,419,420,424,428,429,430,436,439,440,444,445,450,451,455,456,461,465,466,467,473,474,478,479,485,486,488,492,496,497,503,506,507,509,510,514,518,519,520,533,534,535,539,540,544,545,549,550,554,557,558,562,565,566,572,573,580,581,585,588,589,594,595,597,601,603,608,610,614,615,619,620,621,625,629,631,632,634,639,641,644,645,649,651,655,656,659,661,666,668,672,676,677,681,682,683,687,690,692,695,696,700,702,704,707,708,711,722,723,727,728,732,733,737,738,742,745,746,748,753,755,757,761,764,765,769,772,773,777,779,780,784,786,791,793,796,797,802,805,807,810,811,815,817,821,823,827,828,831,834,835,839,842,844,851,854,855,861,864,866,872,875,877,883,884,885,888,891,894,895,899,902,904,911,914,915,921,924,926,932,935,937,943,946,948,949,951,954,955,959,962,964,968,970,974,976,981,982,986,987,994,997,998,1004,1007,1009,1015,1018,1020,1026,1028,1029,1032,1036,1038,1042,1043,1048,1049,1052,1055,1056,1058,1061,1062,1064,1069,1070,1073,1076,1078,1080,1083,1084,1086,1091,1092,1095,1098,1100,1102,1105,1106,1108,1113,1114,1117,1119,1121,1125,1126,1130,1133,1134,1138,1140,1143,1148,1150,1155,1157,1159,1163,1166,1171,1172,1174,1179,1180,1182,1187,1188,1190,1195,1196,1198,1202,1205,1207,1209,1213,1216,1217,1219,1222,1223,1227,1229,1233,1236,1237,1240,1241,1243,1246,1247,1249,1252,1253,1255,1258,1259,1261,1266,1267,1273,1276,1277,1279,1280,1281,1282,1286,1287,1290,1291,1292,1298,1299,1301,1306,1307,1309,1314,1315,1317,1322,1323,1325,1329,1332,1335,1336,1339,1340,1346,1350,1351,1355,1356,1364,1365,1367,1371,1373,1377,1381,1382,1388,1391,1392,1394,1395,1399,1402,1403,1407,1410,1411,1417,1418,1420,1426,1427,1432,1433,1435,1440,1442,1446,1450,1451,1453,1455,1457,1459,1461,1465,1468,1469,1471,1473,1475,1477,1480,1481,1484,1485,1488
-----computeFrom-----
97,98
97,99
109,110
109,111
121,122
121,123
128,129
128,130
130,131
130,132
137,138
137,139
139,140
139,141
150,151
150,152
153,154
153,155
161,162
161,163
163,164
163,165
170,171
170,172
172,173
172,174
183,184
183,185
186,187
186,188
194,195
194,196
196,197
196,198
201,202
201,203
210,211
210,212
213,214
213,215
219,220
219,221
222,223
222,224
228,229
228,230
230,231
230,232
238,239
238,240
253,254
253,255
263,264
263,265
291,292
291,293
321,322
321,323
331,332
331,333
336,337
336,338
343,344
343,345
345,346
345,347
353,354
353,355
355,356
355,357
363,364
363,365
372,373
372,374
380,381
380,382
388,389
388,390
391,392
391,393
405,406
405,407
408,409
408,410
422,423
422,424
432,433
432,434
434,435
434,436
442,443
442,444
448,449
448,450
453,454
453,455
459,460
459,461
469,470
469,471
471,472
471,473
476,477
476,478
482,483
482,484
490,491
490,492
493,494
493,495
498,499
498,500
500,501
500,502
501,502
501,503
512,513
512,514
515,516
515,517
522,523
522,524
523,524
523,525
524,525
524,526
525,526
525,527
526,527
526,528
527,528
527,529
528,529
528,530
530,531
530,532
537,538
537,539
542,543
542,544
547,548
547,549
552,553
552,554
560,561
560,562
568,569
568,570
570,571
570,572
575,576
575,577
576,577
576,578
578,579
578,580
583,584
583,585
591,592
591,593
599,600
599,601
611,612
611,613
626,627
626,628
627,628
627,629
637,638
637,639
642,643
642,644
664,665
664,666
670,671
670,672
673,674
673,675
685,686
685,687
698,699
698,700
705,706
705,707
714,715
714,716
715,716
715,717
716,717
716,718
717,718
717,719
718,719
718,720
720,721
720,722
725,726
725,727
730,731
730,732
735,736
735,737
740,741
740,742
762,763
762,764
767,768
767,769
775,776
775,777
782,783
782,784
789,790
789,791
794,795
794,796
800,801
800,802
813,814
813,815
819,820
819,821
825,826
825,827
832,833
832,834
840,841
840,842
847,848
847,849
857,858
857,859
868,869
868,870
879,880
879,881
892,893
892,894
900,901
900,902
907,908
907,909
917,918
917,919
928,929
928,930
939,940
939,941
952,953
952,954
960,961
960,962
978,979
978,980
979,980
979,981
990,991
990,992
1000,1001
1000,1002
1011,1012
1011,1013
1022,1023
1022,1024
1045,1046
1045,1047
1066,1067
1066,1068
1088,1089
1088,1090
1110,1111
1110,1112
1123,1124
1123,1125
1128,1129
1128,1130
1136,1137
1136,1138
1146,1147
1146,1148
1161,1162
1161,1163
1168,1169
1168,1170
1176,1177
1176,1178
1184,1185
1184,1186
1192,1193
1192,1194
1262,1263
1262,1264
1263,1264
1263,1265
1268,1269
1268,1270
1270,1271
1270,1272
1271,1272
1271,1273
1283,1284
1283,1285
1295,1296
1295,1297
1303,1304
1303,1305
1311,1312
1311,1313
1319,1320
1319,1321
1342,1343
1342,1344
1343,1344
1343,1345
1348,1349
1348,1350
1353,1354
1353,1355
1361,1362
1361,1363
1375,1376
1375,1377
1378,1379
1378,1380
1383,1384
1383,1385
1385,1386
1385,1387
1386,1387
1386,1388
1397,1398
1397,1399
1405,1406
1405,1407
1408,1409
1408,1410
1414,1415
1414,1416
1422,1423
1422,1424
1424,1425
1424,1426
1429,1430
1429,1431
-----guardedBy-----
146,156
141,159
143,152
147,157
179,189
174,192
180,190
176,185
232,273
243,339
236,340
240,282
244,286
288,315
295,312
293,308
368,383
365,378
357,386
361,384
369,376
444,450
594,619
589,631
572,629
745,772
746,764
981,1028
986,1026
1350,1392
1432,1442
-----guardedByNegation-----
439,465
444,461
827,948
-----lastLexicalUse-----
444,461
-----jump-----
444,461
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;Declarator;Name;Declarator;Name;Declarator;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;Declarator;Name;Declarator;Name;Declarator;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;Declarator;Pointer;Name;Declarator;Pointer;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;BinaryExpression;IdExpression;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;Pointer;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;UnaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;UnaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ReturnStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ReturnStatement;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;UnaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;BinaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;FunctionCallExpression;UnaryExpression;IdExpression;Name;BinaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;GotoStatement;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ForStatement;NullStatement;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FunctionCallExpression;UnaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ContinueStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ForStatement;NullStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionList;UnaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;ContinueStatement;IfStatement;IdExpression;Name;CompoundStatement;ForStatement;NullStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionList;UnaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;ContinueStatement;ForStatement;NullStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionList;UnaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;IdExpression;Name;ContinueStatement;IfStatement;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;LabelStatement;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;IdExpression;Name;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;UnaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;LiteralExpression;LiteralExpression;BinaryExpression;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;BinaryExpression;UnaryExpression;IdExpression;Name;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;IfStatement;UnaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;UnaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ReturnStatement;IdExpression;Name;
-----ast_node-----
intTk_PhotoPutBlock(    Tcl_Interp *interp,		/* Interpreter for passing back error				 * messages, or NULL. */    Tk_PhotoHandle handle,	/* Opaque handle for the photo image to be				 * updated. */    register Tk_PhotoImageBlock *blockPtr,				/* Pointer to a structure describing the pixel				 * data to be copied into the image. */    int x, int y,		/* Coordinates of the top-left pixel to be				 * updated in the image. */    int width, int height,	/* Dimensions of the area of the image to be				 * updated. */    int compRule)		/* Compositing rule to use when processing				 * transparent pixels. */{    register PhotoMaster *masterPtr;    int xEnd, yEnd, greenOffset, blueOffset, alphaOffset;    int wLeft, hLeft, wCopy, hCopy, pitch;    unsigned char *srcPtr, *srcLinePtr, *destPtr, *destLinePtr;    int sourceIsSimplePhoto = compRule & SOURCE_IS_SIMPLE_ALPHA_PHOTO;    XRectangle rect;    masterPtr = (PhotoMaster *) handle;    compRule &= ~SOURCE_IS_SIMPLE_ALPHA_PHOTO;    if ((masterPtr->userWidth != 0) && ((x + width) > masterPtr->userWidth)) {	width = masterPtr->userWidth - x;    }    if ((masterPtr->userHeight != 0)	    && ((y + height) > masterPtr->userHeight)) {	height = masterPtr->userHeight - y;    }    if ((width <= 0) || (height <= 0)) {	return TCL_OK;    }    xEnd = x + width;    yEnd = y + height;    if ((xEnd > masterPtr->width) || (yEnd > masterPtr->height)) {	int sameSrc = (blockPtr->pixelPtr == masterPtr->pix32);	if (ImgPhotoSetSize(masterPtr, MAX(xEnd, masterPtr->width),		MAX(yEnd, masterPtr->height)) == TCL_ERROR) {	    if (interp != NULL) {		Tcl_ResetResult(interp);		Tcl_AppendResult(interp, TK_PHOTO_ALLOC_FAILURE_MESSAGE, NULL);	    }	    return TCL_ERROR;	}	if (sameSrc) {	    blockPtr->pixelPtr = masterPtr->pix32;	    blockPtr->pitch = masterPtr->width * 4;	}    }    if ((y < masterPtr->ditherY) || ((y == masterPtr->ditherY)	    && (x < masterPtr->ditherX))) {	/*	 * The dithering isn't correct past the start of this block.	 */	masterPtr->ditherX = x;	masterPtr->ditherY = y;    }    /*     * If this image block could have different red, green and blue     * components, mark it as a color image.     */    greenOffset = blockPtr->offset[1] - blockPtr->offset[0];    blueOffset = blockPtr->offset[2] - blockPtr->offset[0];    alphaOffset = blockPtr->offset[3];    if ((alphaOffset >= blockPtr->pixelSize) || (alphaOffset < 0)) {	alphaOffset = 0;	sourceIsSimplePhoto = 1;    } else {	alphaOffset -= blockPtr->offset[0];    }    if ((greenOffset != 0) || (blueOffset != 0)) {	masterPtr->flags |= COLOR_IMAGE;    }    /*     * Copy the data into our local 32-bit/pixel array. If we can do it with a     * single memmove, we do.     */    destLinePtr = masterPtr->pix32 + (y * masterPtr->width + x) * 4;    pitch = masterPtr->width * 4;    /*     * Test to see if we can do the whole write in a single copy. This test is     * probably too restrictive. We should also be able to do a memmove if     * pixelSize == 3 and alphaOffset == 0. Maybe other cases too.     */    if ((blockPtr->pixelSize == 4)	    && (greenOffset == 1) && (blueOffset == 2) && (alphaOffset == 3)	    && (width <= blockPtr->width) && (height <= blockPtr->height)	    && ((height == 1) || ((x == 0) && (width == masterPtr->width)		&& (blockPtr->pitch == pitch)))	    && (compRule == TK_PHOTO_COMPOSITE_SET)) {	memmove(destLinePtr, blockPtr->pixelPtr + blockPtr->offset[0],		(size_t) (height * width * 4));	/*	 * We know there's an alpha offset and we're setting the data, so skip	 * directly to the point when we recompute the photo validity region.	 */	goto recalculateValidRegion;    }    /*     * Copy and merge pixels according to the compositing rule.     */    for (hLeft = height; hLeft > 0;) {	int pixelSize = blockPtr->pixelSize;	int compRuleSet = (compRule == TK_PHOTO_COMPOSITE_SET);	srcLinePtr = blockPtr->pixelPtr + blockPtr->offset[0];	hCopy = MIN(hLeft, blockPtr->height);	hLeft -= hCopy;	for (; hCopy > 0; --hCopy) {	    /*	     * If the layout of the source line matches our memory layout and	     * we're setting, we can just copy the bytes directly, which is	     * much faster.	     */	    if ((pixelSize == 4) && (greenOffset == 1)		    && (blueOffset == 2) && (alphaOffset == 3)		    && (width <= blockPtr->width)		    && compRuleSet) {		memcpy(destLinePtr, srcLinePtr, (size_t) (width * 4));		srcLinePtr += blockPtr->pitch;		destLinePtr += pitch;		continue;	    }	    /*	     * Have to copy the slow way.	     */	    destPtr = destLinePtr;	    for (wLeft = width; wLeft > 0;) {		wCopy = MIN(wLeft, blockPtr->width);		wLeft -= wCopy;		srcPtr = srcLinePtr;		/*		 * But we might be lucky and be able to use fairly fast loops.		 * It's worth checking...		 */		if (alphaOffset == 0) {		    /*		     * This is the non-alpha case, so can still be fairly		     * fast. Note that in the non-alpha-source case, the		     * compositing rule doesn't apply.		     */		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = 255;		    }		    continue;		} else if (compRuleSet) {		    /*		     * This is the SET compositing rule, which just replaces		     * what was there before with the new data. This is		     * another fairly fast case. No point in doing a memcpy();		     * the order of channels is probably wrong.		     */		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = srcPtr[alphaOffset];		    }		    continue;		}		/*		 * Bother; need to consider the alpha value of each pixel to		 * know what to do.		 */		for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {		    int alpha = srcPtr[alphaOffset];		    if (alpha == 255 || !destPtr[3]) {			/*			 * Either the source is 100% opaque, or the			 * destination is entirely blank. In all cases, we			 * just set the destination to the source.			 */			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = alpha;			continue;		    }		    /*		     * Can still skip doing work if the source is 100%		     * transparent at this point.		     */		    if (alpha) {			int Alpha = destPtr[3];			/*			 * OK, there's real work to be done. Luckily, there's			 * a substantial literature on what to do in this			 * case. In particular, Porter and Duff have done a			 * taxonomy of compositing rules, and the right one is			 * the "Source Over" rule. This code implements that.			 */			destPtr[0] = PD_SRC_OVER(srcPtr[0], alpha, destPtr[0],				Alpha);			destPtr[1] = PD_SRC_OVER(srcPtr[greenOffset], alpha,				destPtr[1], Alpha);			destPtr[2] = PD_SRC_OVER(srcPtr[blueOffset], alpha,				destPtr[2], Alpha);			destPtr[3] = PD_SRC_OVER_ALPHA(alpha, Alpha);		    }		    destPtr += 4;		}	    }	    srcLinePtr += blockPtr->pitch;	    destLinePtr += pitch;	}    }    /*     * Add this new block to the region which specifies which data is valid.     */    if (alphaOffset) {	/*	 * This block is grossly inefficient. For each row in the image, it	 * finds each continguous string of nontransparent pixels, then marks	 * those areas as valid in the validRegion mask. This makes drawing	 * very efficient, because of the way we use X: we just say, here's	 * your mask, and here's your data. We need not worry about the	 * current background color, etc. But this costs us a lot on the image	 * setup. Still, image setup only happens once, whereas the drawing	 * happens many times, so this might be the best way to go.	 *	 * An alternative might be to not set up this mask, and instead, at	 * drawing time, for each transparent pixel, set its color to the	 * color of the background behind that pixel. This is what I suspect	 * most of programs do. However, they don't have to deal with the	 * canvas, which could have many different background colors.	 * Determining the correct bg color for a given pixel might be	 * expensive.	 */	if (compRule != TK_PHOTO_COMPOSITE_OVERLAY) {	    TkRegion workRgn;	    /*	     * Don't need this when using the OVERLAY compositing rule, which	     * always strictly increases the valid region.	     */	recalculateValidRegion:	    workRgn = TkCreateRegion();	    rect.x = x;	    rect.y = y;	    rect.width = width;	    rect.height = height;	    TkUnionRectWithRegion(&rect, workRgn, workRgn);	    TkSubtractRegion(masterPtr->validRegion, workRgn,		    masterPtr->validRegion);	    TkDestroyRegion(workRgn);	}	/*	 * Factorize out the main part of the building of the region data to	 * allow for more efficient per-platform implementations. [Bug 919066]	 */	TkpBuildRegionFromAlphaData(masterPtr->validRegion, (unsigned) x,		(unsigned) y, (unsigned) width, (unsigned) height,		masterPtr->pix32 + (y * masterPtr->width + x) * 4 + 3,		4, (unsigned) masterPtr->width * 4);    } else {	rect.x = x;	rect.y = y;	rect.width = width;	rect.height = height;	TkUnionRectWithRegion(&rect, masterPtr->validRegion,		masterPtr->validRegion);    }    /*     * Check if display code needs alpha blending...     */    if (!sourceIsSimplePhoto && (width == 1) && (height == 1)) {	/*	 * Optimize the single pixel case if we can. This speeds up code that	 * builds up large simple-alpha images by single pixels.  We don't	 * negate COMPLEX_ALPHA in this case. [Bug 1409140]	 */	if (!(masterPtr->flags & COMPLEX_ALPHA)) {	    unsigned char newAlpha;	    destLinePtr = masterPtr->pix32 + (y * masterPtr->width + x) * 4;	    newAlpha = destLinePtr[3];	    if (newAlpha && newAlpha != 255) {		masterPtr->flags |= COMPLEX_ALPHA;	    }	}    } else if ((alphaOffset != 0) || (masterPtr->flags & COMPLEX_ALPHA)) {	/*	 * Check for partial transparency if alpha pixels are specified, or	 * rescan if we already knew such pixels existed.  To restrict this	 * Toggle to only checking the changed pixels requires knowing where	 * the alpha pixels are.	 */	ToggleComplexAlphaIfNeeded(masterPtr);    }    /*     * Update each instance.     */    Tk_DitherPhoto((Tk_PhotoHandle)masterPtr, x, y, width, height);    /*     * Tell the core image code that this image has changed.     */    Tk_ImageChanged(masterPtr->tkMaster, x, y, width, height,	    masterPtr->width, masterPtr->height);    return TCL_OK;}
int
Tk_PhotoPutBlock(    Tcl_Interp *interp,		/* Interpreter for passing back error				 * messages, or NULL. */    Tk_PhotoHandle handle,	/* Opaque handle for the photo image to be				 * updated. */    register Tk_PhotoImageBlock *blockPtr,				/* Pointer to a structure describing the pixel				 * data to be copied into the image. */    int x, int y,		/* Coordinates of the top-left pixel to be				 * updated in the image. */    int width, int height,	/* Dimensions of the area of the image to be				 * updated. */    int compRule)
Tk_PhotoPutBlock
Tcl_Interp *interp
Tcl_Interp
Tcl_Interp
*interp
*
interp
Tk_PhotoHandle handle
Tk_PhotoHandle
Tk_PhotoHandle
handle
handle
register Tk_PhotoImageBlock *blockPtr
register Tk_PhotoImageBlock
Tk_PhotoImageBlock
*blockPtr
*
blockPtr
int x
int
x
x
int y
int
y
y
int width
int
width
width
int height
int
height
height
int compRule
int
compRule
compRule
{    register PhotoMaster *masterPtr;    int xEnd, yEnd, greenOffset, blueOffset, alphaOffset;    int wLeft, hLeft, wCopy, hCopy, pitch;    unsigned char *srcPtr, *srcLinePtr, *destPtr, *destLinePtr;    int sourceIsSimplePhoto = compRule & SOURCE_IS_SIMPLE_ALPHA_PHOTO;    XRectangle rect;    masterPtr = (PhotoMaster *) handle;    compRule &= ~SOURCE_IS_SIMPLE_ALPHA_PHOTO;    if ((masterPtr->userWidth != 0) && ((x + width) > masterPtr->userWidth)) {	width = masterPtr->userWidth - x;    }    if ((masterPtr->userHeight != 0)	    && ((y + height) > masterPtr->userHeight)) {	height = masterPtr->userHeight - y;    }    if ((width <= 0) || (height <= 0)) {	return TCL_OK;    }    xEnd = x + width;    yEnd = y + height;    if ((xEnd > masterPtr->width) || (yEnd > masterPtr->height)) {	int sameSrc = (blockPtr->pixelPtr == masterPtr->pix32);	if (ImgPhotoSetSize(masterPtr, MAX(xEnd, masterPtr->width),		MAX(yEnd, masterPtr->height)) == TCL_ERROR) {	    if (interp != NULL) {		Tcl_ResetResult(interp);		Tcl_AppendResult(interp, TK_PHOTO_ALLOC_FAILURE_MESSAGE, NULL);	    }	    return TCL_ERROR;	}	if (sameSrc) {	    blockPtr->pixelPtr = masterPtr->pix32;	    blockPtr->pitch = masterPtr->width * 4;	}    }    if ((y < masterPtr->ditherY) || ((y == masterPtr->ditherY)	    && (x < masterPtr->ditherX))) {	/*	 * The dithering isn't correct past the start of this block.	 */	masterPtr->ditherX = x;	masterPtr->ditherY = y;    }    /*     * If this image block could have different red, green and blue     * components, mark it as a color image.     */    greenOffset = blockPtr->offset[1] - blockPtr->offset[0];    blueOffset = blockPtr->offset[2] - blockPtr->offset[0];    alphaOffset = blockPtr->offset[3];    if ((alphaOffset >= blockPtr->pixelSize) || (alphaOffset < 0)) {	alphaOffset = 0;	sourceIsSimplePhoto = 1;    } else {	alphaOffset -= blockPtr->offset[0];    }    if ((greenOffset != 0) || (blueOffset != 0)) {	masterPtr->flags |= COLOR_IMAGE;    }    /*     * Copy the data into our local 32-bit/pixel array. If we can do it with a     * single memmove, we do.     */    destLinePtr = masterPtr->pix32 + (y * masterPtr->width + x) * 4;    pitch = masterPtr->width * 4;    /*     * Test to see if we can do the whole write in a single copy. This test is     * probably too restrictive. We should also be able to do a memmove if     * pixelSize == 3 and alphaOffset == 0. Maybe other cases too.     */    if ((blockPtr->pixelSize == 4)	    && (greenOffset == 1) && (blueOffset == 2) && (alphaOffset == 3)	    && (width <= blockPtr->width) && (height <= blockPtr->height)	    && ((height == 1) || ((x == 0) && (width == masterPtr->width)		&& (blockPtr->pitch == pitch)))	    && (compRule == TK_PHOTO_COMPOSITE_SET)) {	memmove(destLinePtr, blockPtr->pixelPtr + blockPtr->offset[0],		(size_t) (height * width * 4));	/*	 * We know there's an alpha offset and we're setting the data, so skip	 * directly to the point when we recompute the photo validity region.	 */	goto recalculateValidRegion;    }    /*     * Copy and merge pixels according to the compositing rule.     */    for (hLeft = height; hLeft > 0;) {	int pixelSize = blockPtr->pixelSize;	int compRuleSet = (compRule == TK_PHOTO_COMPOSITE_SET);	srcLinePtr = blockPtr->pixelPtr + blockPtr->offset[0];	hCopy = MIN(hLeft, blockPtr->height);	hLeft -= hCopy;	for (; hCopy > 0; --hCopy) {	    /*	     * If the layout of the source line matches our memory layout and	     * we're setting, we can just copy the bytes directly, which is	     * much faster.	     */	    if ((pixelSize == 4) && (greenOffset == 1)		    && (blueOffset == 2) && (alphaOffset == 3)		    && (width <= blockPtr->width)		    && compRuleSet) {		memcpy(destLinePtr, srcLinePtr, (size_t) (width * 4));		srcLinePtr += blockPtr->pitch;		destLinePtr += pitch;		continue;	    }	    /*	     * Have to copy the slow way.	     */	    destPtr = destLinePtr;	    for (wLeft = width; wLeft > 0;) {		wCopy = MIN(wLeft, blockPtr->width);		wLeft -= wCopy;		srcPtr = srcLinePtr;		/*		 * But we might be lucky and be able to use fairly fast loops.		 * It's worth checking...		 */		if (alphaOffset == 0) {		    /*		     * This is the non-alpha case, so can still be fairly		     * fast. Note that in the non-alpha-source case, the		     * compositing rule doesn't apply.		     */		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = 255;		    }		    continue;		} else if (compRuleSet) {		    /*		     * This is the SET compositing rule, which just replaces		     * what was there before with the new data. This is		     * another fairly fast case. No point in doing a memcpy();		     * the order of channels is probably wrong.		     */		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = srcPtr[alphaOffset];		    }		    continue;		}		/*		 * Bother; need to consider the alpha value of each pixel to		 * know what to do.		 */		for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {		    int alpha = srcPtr[alphaOffset];		    if (alpha == 255 || !destPtr[3]) {			/*			 * Either the source is 100% opaque, or the			 * destination is entirely blank. In all cases, we			 * just set the destination to the source.			 */			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = alpha;			continue;		    }		    /*		     * Can still skip doing work if the source is 100%		     * transparent at this point.		     */		    if (alpha) {			int Alpha = destPtr[3];			/*			 * OK, there's real work to be done. Luckily, there's			 * a substantial literature on what to do in this			 * case. In particular, Porter and Duff have done a			 * taxonomy of compositing rules, and the right one is			 * the "Source Over" rule. This code implements that.			 */			destPtr[0] = PD_SRC_OVER(srcPtr[0], alpha, destPtr[0],				Alpha);			destPtr[1] = PD_SRC_OVER(srcPtr[greenOffset], alpha,				destPtr[1], Alpha);			destPtr[2] = PD_SRC_OVER(srcPtr[blueOffset], alpha,				destPtr[2], Alpha);			destPtr[3] = PD_SRC_OVER_ALPHA(alpha, Alpha);		    }		    destPtr += 4;		}	    }	    srcLinePtr += blockPtr->pitch;	    destLinePtr += pitch;	}    }    /*     * Add this new block to the region which specifies which data is valid.     */    if (alphaOffset) {	/*	 * This block is grossly inefficient. For each row in the image, it	 * finds each continguous string of nontransparent pixels, then marks	 * those areas as valid in the validRegion mask. This makes drawing	 * very efficient, because of the way we use X: we just say, here's	 * your mask, and here's your data. We need not worry about the	 * current background color, etc. But this costs us a lot on the image	 * setup. Still, image setup only happens once, whereas the drawing	 * happens many times, so this might be the best way to go.	 *	 * An alternative might be to not set up this mask, and instead, at	 * drawing time, for each transparent pixel, set its color to the	 * color of the background behind that pixel. This is what I suspect	 * most of programs do. However, they don't have to deal with the	 * canvas, which could have many different background colors.	 * Determining the correct bg color for a given pixel might be	 * expensive.	 */	if (compRule != TK_PHOTO_COMPOSITE_OVERLAY) {	    TkRegion workRgn;	    /*	     * Don't need this when using the OVERLAY compositing rule, which	     * always strictly increases the valid region.	     */	recalculateValidRegion:	    workRgn = TkCreateRegion();	    rect.x = x;	    rect.y = y;	    rect.width = width;	    rect.height = height;	    TkUnionRectWithRegion(&rect, workRgn, workRgn);	    TkSubtractRegion(masterPtr->validRegion, workRgn,		    masterPtr->validRegion);	    TkDestroyRegion(workRgn);	}	/*	 * Factorize out the main part of the building of the region data to	 * allow for more efficient per-platform implementations. [Bug 919066]	 */	TkpBuildRegionFromAlphaData(masterPtr->validRegion, (unsigned) x,		(unsigned) y, (unsigned) width, (unsigned) height,		masterPtr->pix32 + (y * masterPtr->width + x) * 4 + 3,		4, (unsigned) masterPtr->width * 4);    } else {	rect.x = x;	rect.y = y;	rect.width = width;	rect.height = height;	TkUnionRectWithRegion(&rect, masterPtr->validRegion,		masterPtr->validRegion);    }    /*     * Check if display code needs alpha blending...     */    if (!sourceIsSimplePhoto && (width == 1) && (height == 1)) {	/*	 * Optimize the single pixel case if we can. This speeds up code that	 * builds up large simple-alpha images by single pixels.  We don't	 * negate COMPLEX_ALPHA in this case. [Bug 1409140]	 */	if (!(masterPtr->flags & COMPLEX_ALPHA)) {	    unsigned char newAlpha;	    destLinePtr = masterPtr->pix32 + (y * masterPtr->width + x) * 4;	    newAlpha = destLinePtr[3];	    if (newAlpha && newAlpha != 255) {		masterPtr->flags |= COMPLEX_ALPHA;	    }	}    } else if ((alphaOffset != 0) || (masterPtr->flags & COMPLEX_ALPHA)) {	/*	 * Check for partial transparency if alpha pixels are specified, or	 * rescan if we already knew such pixels existed.  To restrict this	 * Toggle to only checking the changed pixels requires knowing where	 * the alpha pixels are.	 */	ToggleComplexAlphaIfNeeded(masterPtr);    }    /*     * Update each instance.     */    Tk_DitherPhoto((Tk_PhotoHandle)masterPtr, x, y, width, height);    /*     * Tell the core image code that this image has changed.     */    Tk_ImageChanged(masterPtr->tkMaster, x, y, width, height,	    masterPtr->width, masterPtr->height);    return TCL_OK;}
register PhotoMaster *masterPtr;
register PhotoMaster *masterPtr;
register PhotoMaster
PhotoMaster
*masterPtr
*
masterPtr
int xEnd, yEnd, greenOffset, blueOffset, alphaOffset;
int xEnd, yEnd, greenOffset, blueOffset, alphaOffset;
int
xEnd
xEnd
yEnd
yEnd
greenOffset
greenOffset
blueOffset
blueOffset
alphaOffset
alphaOffset
int wLeft, hLeft, wCopy, hCopy, pitch;
int wLeft, hLeft, wCopy, hCopy, pitch;
int
wLeft
wLeft
hLeft
hLeft
wCopy
wCopy
hCopy
hCopy
pitch
pitch
unsigned char *srcPtr, *srcLinePtr, *destPtr, *destLinePtr;
unsigned char *srcPtr, *srcLinePtr, *destPtr, *destLinePtr;
unsigned char
*srcPtr
*
srcPtr
*srcLinePtr
*
srcLinePtr
*destPtr
*
destPtr
*destLinePtr
*
destLinePtr
int sourceIsSimplePhoto = compRule & SOURCE_IS_SIMPLE_ALPHA_PHOTO;
int sourceIsSimplePhoto = compRule & SOURCE_IS_SIMPLE_ALPHA_PHOTO;
int
sourceIsSimplePhoto = compRule & SOURCE_IS_SIMPLE_ALPHA_PHOTO
sourceIsSimplePhoto
= compRule & SOURCE_IS_SIMPLE_ALPHA_PHOTO
compRule & SOURCE_IS_SIMPLE_ALPHA_PHOTO
compRule
compRule
SOURCE_IS_SIMPLE_ALPHA_PHOTO
SOURCE_IS_SIMPLE_ALPHA_PHOTO
XRectangle rect;
XRectangle rect;
XRectangle
XRectangle
rect
rect
masterPtr = (PhotoMaster *) handle;
masterPtr = (PhotoMaster *) handle
masterPtr
masterPtr
(PhotoMaster *) handle
PhotoMaster *
PhotoMaster
PhotoMaster
*
*
handle
handle
compRule &= ~SOURCE_IS_SIMPLE_ALPHA_PHOTO;
compRule &= ~SOURCE_IS_SIMPLE_ALPHA_PHOTO
compRule
compRule
~SOURCE_IS_SIMPLE_ALPHA_PHOTO
SOURCE_IS_SIMPLE_ALPHA_PHOTO
SOURCE_IS_SIMPLE_ALPHA_PHOTO
if ((masterPtr->userWidth != 0) && ((x + width) > masterPtr->userWidth)) {	width = masterPtr->userWidth - x;    }
(masterPtr->userWidth != 0) && ((x + width) > masterPtr->userWidth)
(masterPtr->userWidth != 0)
masterPtr->userWidth != 0
masterPtr->userWidth
masterPtr
masterPtr
userWidth
0
((x + width) > masterPtr->userWidth)
(x + width) > masterPtr->userWidth
(x + width)
x + width
x
x
width
width
masterPtr->userWidth
masterPtr
masterPtr
userWidth
{	width = masterPtr->userWidth - x;    }
width = masterPtr->userWidth - x;
width = masterPtr->userWidth - x
width
width
masterPtr->userWidth - x
masterPtr->userWidth
masterPtr
masterPtr
userWidth
x
x
if ((masterPtr->userHeight != 0)	    && ((y + height) > masterPtr->userHeight)) {	height = masterPtr->userHeight - y;    }
(masterPtr->userHeight != 0)	    && ((y + height) > masterPtr->userHeight)
(masterPtr->userHeight != 0)
masterPtr->userHeight != 0
masterPtr->userHeight
masterPtr
masterPtr
userHeight
0
((y + height) > masterPtr->userHeight)
(y + height) > masterPtr->userHeight
(y + height)
y + height
y
y
height
height
masterPtr->userHeight
masterPtr
masterPtr
userHeight
{	height = masterPtr->userHeight - y;    }
height = masterPtr->userHeight - y;
height = masterPtr->userHeight - y
height
height
masterPtr->userHeight - y
masterPtr->userHeight
masterPtr
masterPtr
userHeight
y
y
if ((width <= 0) || (height <= 0)) {	return TCL_OK;    }
(width <= 0) || (height <= 0)
(width <= 0)
width <= 0
width
width
0
(height <= 0)
height <= 0
height
height
0
{	return TCL_OK;    }
return TCL_OK;
TCL_OK
TCL_OK
xEnd = x + width;
xEnd = x + width
xEnd
xEnd
x + width
x
x
width
width
yEnd = y + height;
yEnd = y + height
yEnd
yEnd
y + height
y
y
height
height
if ((xEnd > masterPtr->width) || (yEnd > masterPtr->height)) {	int sameSrc = (blockPtr->pixelPtr == masterPtr->pix32);	if (ImgPhotoSetSize(masterPtr, MAX(xEnd, masterPtr->width),		MAX(yEnd, masterPtr->height)) == TCL_ERROR) {	    if (interp != NULL) {		Tcl_ResetResult(interp);		Tcl_AppendResult(interp, TK_PHOTO_ALLOC_FAILURE_MESSAGE, NULL);	    }	    return TCL_ERROR;	}	if (sameSrc) {	    blockPtr->pixelPtr = masterPtr->pix32;	    blockPtr->pitch = masterPtr->width * 4;	}    }
(xEnd > masterPtr->width) || (yEnd > masterPtr->height)
(xEnd > masterPtr->width)
xEnd > masterPtr->width
xEnd
xEnd
masterPtr->width
masterPtr
masterPtr
width
(yEnd > masterPtr->height)
yEnd > masterPtr->height
yEnd
yEnd
masterPtr->height
masterPtr
masterPtr
height
{	int sameSrc = (blockPtr->pixelPtr == masterPtr->pix32);	if (ImgPhotoSetSize(masterPtr, MAX(xEnd, masterPtr->width),		MAX(yEnd, masterPtr->height)) == TCL_ERROR) {	    if (interp != NULL) {		Tcl_ResetResult(interp);		Tcl_AppendResult(interp, TK_PHOTO_ALLOC_FAILURE_MESSAGE, NULL);	    }	    return TCL_ERROR;	}	if (sameSrc) {	    blockPtr->pixelPtr = masterPtr->pix32;	    blockPtr->pitch = masterPtr->width * 4;	}    }
int sameSrc = (blockPtr->pixelPtr == masterPtr->pix32);
int sameSrc = (blockPtr->pixelPtr == masterPtr->pix32);
int
sameSrc = (blockPtr->pixelPtr == masterPtr->pix32)
sameSrc
= (blockPtr->pixelPtr == masterPtr->pix32)
(blockPtr->pixelPtr == masterPtr->pix32)
blockPtr->pixelPtr == masterPtr->pix32
blockPtr->pixelPtr
blockPtr
blockPtr
pixelPtr
masterPtr->pix32
masterPtr
masterPtr
pix32
if (ImgPhotoSetSize(masterPtr, MAX(xEnd, masterPtr->width),		MAX(yEnd, masterPtr->height)) == TCL_ERROR) {	    if (interp != NULL) {		Tcl_ResetResult(interp);		Tcl_AppendResult(interp, TK_PHOTO_ALLOC_FAILURE_MESSAGE, NULL);	    }	    return TCL_ERROR;	}
ImgPhotoSetSize(masterPtr, MAX(xEnd, masterPtr->width),		MAX(yEnd, masterPtr->height)) == TCL_ERROR
ImgPhotoSetSize(masterPtr, MAX(xEnd, masterPtr->width),		MAX(yEnd, masterPtr->height))
ImgPhotoSetSize
ImgPhotoSetSize
masterPtr
masterPtr
MAX(xEnd, masterPtr->width)
MAX
MAX
xEnd
xEnd
masterPtr->width
masterPtr
masterPtr
width
MAX(yEnd, masterPtr->height)
MAX
MAX
yEnd
yEnd
masterPtr->height
masterPtr
masterPtr
height
TCL_ERROR
TCL_ERROR
{	    if (interp != NULL) {		Tcl_ResetResult(interp);		Tcl_AppendResult(interp, TK_PHOTO_ALLOC_FAILURE_MESSAGE, NULL);	    }	    return TCL_ERROR;	}
if (interp != NULL) {		Tcl_ResetResult(interp);		Tcl_AppendResult(interp, TK_PHOTO_ALLOC_FAILURE_MESSAGE, NULL);	    }
interp != NULL
interp
interp
NULL
NULL
{		Tcl_ResetResult(interp);		Tcl_AppendResult(interp, TK_PHOTO_ALLOC_FAILURE_MESSAGE, NULL);	    }
Tcl_ResetResult(interp);
Tcl_ResetResult(interp)
Tcl_ResetResult
Tcl_ResetResult
interp
interp
Tcl_AppendResult(interp, TK_PHOTO_ALLOC_FAILURE_MESSAGE, NULL);
Tcl_AppendResult(interp, TK_PHOTO_ALLOC_FAILURE_MESSAGE, NULL)
Tcl_AppendResult
Tcl_AppendResult
interp
interp
TK_PHOTO_ALLOC_FAILURE_MESSAGE
TK_PHOTO_ALLOC_FAILURE_MESSAGE
NULL
NULL
return TCL_ERROR;
TCL_ERROR
TCL_ERROR
if (sameSrc) {	    blockPtr->pixelPtr = masterPtr->pix32;	    blockPtr->pitch = masterPtr->width * 4;	}
sameSrc
sameSrc
{	    blockPtr->pixelPtr = masterPtr->pix32;	    blockPtr->pitch = masterPtr->width * 4;	}
blockPtr->pixelPtr = masterPtr->pix32;
blockPtr->pixelPtr = masterPtr->pix32
blockPtr->pixelPtr
blockPtr
blockPtr
pixelPtr
masterPtr->pix32
masterPtr
masterPtr
pix32
blockPtr->pitch = masterPtr->width * 4;
blockPtr->pitch = masterPtr->width * 4
blockPtr->pitch
blockPtr
blockPtr
pitch
masterPtr->width * 4
masterPtr->width
masterPtr
masterPtr
width
4
if ((y < masterPtr->ditherY) || ((y == masterPtr->ditherY)	    && (x < masterPtr->ditherX))) {	/*	 * The dithering isn't correct past the start of this block.	 */	masterPtr->ditherX = x;	masterPtr->ditherY = y;    }
(y < masterPtr->ditherY) || ((y == masterPtr->ditherY)	    && (x < masterPtr->ditherX))
(y < masterPtr->ditherY)
y < masterPtr->ditherY
y
y
masterPtr->ditherY
masterPtr
masterPtr
ditherY
((y == masterPtr->ditherY)	    && (x < masterPtr->ditherX))
(y == masterPtr->ditherY)	    && (x < masterPtr->ditherX)
(y == masterPtr->ditherY)
y == masterPtr->ditherY
y
y
masterPtr->ditherY
masterPtr
masterPtr
ditherY
(x < masterPtr->ditherX)
x < masterPtr->ditherX
x
x
masterPtr->ditherX
masterPtr
masterPtr
ditherX
{	/*	 * The dithering isn't correct past the start of this block.	 */	masterPtr->ditherX = x;	masterPtr->ditherY = y;    }
masterPtr->ditherX = x;
masterPtr->ditherX = x
masterPtr->ditherX
masterPtr
masterPtr
ditherX
x
x
masterPtr->ditherY = y;
masterPtr->ditherY = y
masterPtr->ditherY
masterPtr
masterPtr
ditherY
y
y
greenOffset = blockPtr->offset[1] - blockPtr->offset[0];
greenOffset = blockPtr->offset[1] - blockPtr->offset[0]
greenOffset
greenOffset
blockPtr->offset[1] - blockPtr->offset[0]
blockPtr->offset[1]
blockPtr->offset
blockPtr
blockPtr
offset
1
blockPtr->offset[0]
blockPtr->offset
blockPtr
blockPtr
offset
0
blueOffset = blockPtr->offset[2] - blockPtr->offset[0];
blueOffset = blockPtr->offset[2] - blockPtr->offset[0]
blueOffset
blueOffset
blockPtr->offset[2] - blockPtr->offset[0]
blockPtr->offset[2]
blockPtr->offset
blockPtr
blockPtr
offset
2
blockPtr->offset[0]
blockPtr->offset
blockPtr
blockPtr
offset
0
alphaOffset = blockPtr->offset[3];
alphaOffset = blockPtr->offset[3]
alphaOffset
alphaOffset
blockPtr->offset[3]
blockPtr->offset
blockPtr
blockPtr
offset
3
if ((alphaOffset >= blockPtr->pixelSize) || (alphaOffset < 0)) {	alphaOffset = 0;	sourceIsSimplePhoto = 1;    } else {	alphaOffset -= blockPtr->offset[0];    }
(alphaOffset >= blockPtr->pixelSize) || (alphaOffset < 0)
(alphaOffset >= blockPtr->pixelSize)
alphaOffset >= blockPtr->pixelSize
alphaOffset
alphaOffset
blockPtr->pixelSize
blockPtr
blockPtr
pixelSize
(alphaOffset < 0)
alphaOffset < 0
alphaOffset
alphaOffset
0
{	alphaOffset = 0;	sourceIsSimplePhoto = 1;    }
alphaOffset = 0;
alphaOffset = 0
alphaOffset
alphaOffset
0
sourceIsSimplePhoto = 1;
sourceIsSimplePhoto = 1
sourceIsSimplePhoto
sourceIsSimplePhoto
1
{	alphaOffset -= blockPtr->offset[0];    }
alphaOffset -= blockPtr->offset[0];
alphaOffset -= blockPtr->offset[0]
alphaOffset
alphaOffset
blockPtr->offset[0]
blockPtr->offset
blockPtr
blockPtr
offset
0
if ((greenOffset != 0) || (blueOffset != 0)) {	masterPtr->flags |= COLOR_IMAGE;    }
(greenOffset != 0) || (blueOffset != 0)
(greenOffset != 0)
greenOffset != 0
greenOffset
greenOffset
0
(blueOffset != 0)
blueOffset != 0
blueOffset
blueOffset
0
{	masterPtr->flags |= COLOR_IMAGE;    }
masterPtr->flags |= COLOR_IMAGE;
masterPtr->flags |= COLOR_IMAGE
masterPtr->flags
masterPtr
masterPtr
flags
COLOR_IMAGE
COLOR_IMAGE
destLinePtr = masterPtr->pix32 + (y * masterPtr->width + x) * 4;
destLinePtr = masterPtr->pix32 + (y * masterPtr->width + x) * 4
destLinePtr
destLinePtr
masterPtr->pix32 + (y * masterPtr->width + x) * 4
masterPtr->pix32
masterPtr
masterPtr
pix32
(y * masterPtr->width + x) * 4
(y * masterPtr->width + x)
y * masterPtr->width + x
y * masterPtr->width
y
y
masterPtr->width
masterPtr
masterPtr
width
x
x
4
pitch = masterPtr->width * 4;
pitch = masterPtr->width * 4
pitch
pitch
masterPtr->width * 4
masterPtr->width
masterPtr
masterPtr
width
4
if ((blockPtr->pixelSize == 4)	    && (greenOffset == 1) && (blueOffset == 2) && (alphaOffset == 3)	    && (width <= blockPtr->width) && (height <= blockPtr->height)	    && ((height == 1) || ((x == 0) && (width == masterPtr->width)		&& (blockPtr->pitch == pitch)))	    && (compRule == TK_PHOTO_COMPOSITE_SET)) {	memmove(destLinePtr, blockPtr->pixelPtr + blockPtr->offset[0],		(size_t) (height * width * 4));	/*	 * We know there's an alpha offset and we're setting the data, so skip	 * directly to the point when we recompute the photo validity region.	 */	goto recalculateValidRegion;    }
(blockPtr->pixelSize == 4)	    && (greenOffset == 1) && (blueOffset == 2) && (alphaOffset == 3)	    && (width <= blockPtr->width) && (height <= blockPtr->height)	    && ((height == 1) || ((x == 0) && (width == masterPtr->width)		&& (blockPtr->pitch == pitch)))	    && (compRule == TK_PHOTO_COMPOSITE_SET)
(blockPtr->pixelSize == 4)	    && (greenOffset == 1) && (blueOffset == 2) && (alphaOffset == 3)	    && (width <= blockPtr->width) && (height <= blockPtr->height)	    && ((height == 1) || ((x == 0) && (width == masterPtr->width)		&& (blockPtr->pitch == pitch)))
(blockPtr->pixelSize == 4)	    && (greenOffset == 1) && (blueOffset == 2) && (alphaOffset == 3)	    && (width <= blockPtr->width) && (height <= blockPtr->height)
(blockPtr->pixelSize == 4)	    && (greenOffset == 1) && (blueOffset == 2) && (alphaOffset == 3)	    && (width <= blockPtr->width)
(blockPtr->pixelSize == 4)	    && (greenOffset == 1) && (blueOffset == 2) && (alphaOffset == 3)
(blockPtr->pixelSize == 4)	    && (greenOffset == 1) && (blueOffset == 2)
(blockPtr->pixelSize == 4)	    && (greenOffset == 1)
(blockPtr->pixelSize == 4)
blockPtr->pixelSize == 4
blockPtr->pixelSize
blockPtr
blockPtr
pixelSize
4
(greenOffset == 1)
greenOffset == 1
greenOffset
greenOffset
1
(blueOffset == 2)
blueOffset == 2
blueOffset
blueOffset
2
(alphaOffset == 3)
alphaOffset == 3
alphaOffset
alphaOffset
3
(width <= blockPtr->width)
width <= blockPtr->width
width
width
blockPtr->width
blockPtr
blockPtr
width
(height <= blockPtr->height)
height <= blockPtr->height
height
height
blockPtr->height
blockPtr
blockPtr
height
((height == 1) || ((x == 0) && (width == masterPtr->width)		&& (blockPtr->pitch == pitch)))
(height == 1) || ((x == 0) && (width == masterPtr->width)		&& (blockPtr->pitch == pitch))
(height == 1)
height == 1
height
height
1
((x == 0) && (width == masterPtr->width)		&& (blockPtr->pitch == pitch))
(x == 0) && (width == masterPtr->width)		&& (blockPtr->pitch == pitch)
(x == 0) && (width == masterPtr->width)
(x == 0)
x == 0
x
x
0
(width == masterPtr->width)
width == masterPtr->width
width
width
masterPtr->width
masterPtr
masterPtr
width
(blockPtr->pitch == pitch)
blockPtr->pitch == pitch
blockPtr->pitch
blockPtr
blockPtr
pitch
pitch
pitch
(compRule == TK_PHOTO_COMPOSITE_SET)
compRule == TK_PHOTO_COMPOSITE_SET
compRule
compRule
TK_PHOTO_COMPOSITE_SET
TK_PHOTO_COMPOSITE_SET
{	memmove(destLinePtr, blockPtr->pixelPtr + blockPtr->offset[0],		(size_t) (height * width * 4));	/*	 * We know there's an alpha offset and we're setting the data, so skip	 * directly to the point when we recompute the photo validity region.	 */	goto recalculateValidRegion;    }
memmove(destLinePtr, blockPtr->pixelPtr + blockPtr->offset[0],		(size_t) (height * width * 4));
memmove(destLinePtr, blockPtr->pixelPtr + blockPtr->offset[0],		(size_t) (height * width * 4))
memmove
memmove
destLinePtr
destLinePtr
blockPtr->pixelPtr + blockPtr->offset[0]
blockPtr->pixelPtr
blockPtr
blockPtr
pixelPtr
blockPtr->offset[0]
blockPtr->offset
blockPtr
blockPtr
offset
0
(size_t) (height * width * 4)
(size_t)
size_t
size_t
height * width * 4
height * width
height
height
width
width
4
goto recalculateValidRegion;
recalculateValidRegion
for (hLeft = height; hLeft > 0;) {	int pixelSize = blockPtr->pixelSize;	int compRuleSet = (compRule == TK_PHOTO_COMPOSITE_SET);	srcLinePtr = blockPtr->pixelPtr + blockPtr->offset[0];	hCopy = MIN(hLeft, blockPtr->height);	hLeft -= hCopy;	for (; hCopy > 0; --hCopy) {	    /*	     * If the layout of the source line matches our memory layout and	     * we're setting, we can just copy the bytes directly, which is	     * much faster.	     */	    if ((pixelSize == 4) && (greenOffset == 1)		    && (blueOffset == 2) && (alphaOffset == 3)		    && (width <= blockPtr->width)		    && compRuleSet) {		memcpy(destLinePtr, srcLinePtr, (size_t) (width * 4));		srcLinePtr += blockPtr->pitch;		destLinePtr += pitch;		continue;	    }	    /*	     * Have to copy the slow way.	     */	    destPtr = destLinePtr;	    for (wLeft = width; wLeft > 0;) {		wCopy = MIN(wLeft, blockPtr->width);		wLeft -= wCopy;		srcPtr = srcLinePtr;		/*		 * But we might be lucky and be able to use fairly fast loops.		 * It's worth checking...		 */		if (alphaOffset == 0) {		    /*		     * This is the non-alpha case, so can still be fairly		     * fast. Note that in the non-alpha-source case, the		     * compositing rule doesn't apply.		     */		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = 255;		    }		    continue;		} else if (compRuleSet) {		    /*		     * This is the SET compositing rule, which just replaces		     * what was there before with the new data. This is		     * another fairly fast case. No point in doing a memcpy();		     * the order of channels is probably wrong.		     */		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = srcPtr[alphaOffset];		    }		    continue;		}		/*		 * Bother; need to consider the alpha value of each pixel to		 * know what to do.		 */		for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {		    int alpha = srcPtr[alphaOffset];		    if (alpha == 255 || !destPtr[3]) {			/*			 * Either the source is 100% opaque, or the			 * destination is entirely blank. In all cases, we			 * just set the destination to the source.			 */			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = alpha;			continue;		    }		    /*		     * Can still skip doing work if the source is 100%		     * transparent at this point.		     */		    if (alpha) {			int Alpha = destPtr[3];			/*			 * OK, there's real work to be done. Luckily, there's			 * a substantial literature on what to do in this			 * case. In particular, Porter and Duff have done a			 * taxonomy of compositing rules, and the right one is			 * the "Source Over" rule. This code implements that.			 */			destPtr[0] = PD_SRC_OVER(srcPtr[0], alpha, destPtr[0],				Alpha);			destPtr[1] = PD_SRC_OVER(srcPtr[greenOffset], alpha,				destPtr[1], Alpha);			destPtr[2] = PD_SRC_OVER(srcPtr[blueOffset], alpha,				destPtr[2], Alpha);			destPtr[3] = PD_SRC_OVER_ALPHA(alpha, Alpha);		    }		    destPtr += 4;		}	    }	    srcLinePtr += blockPtr->pitch;	    destLinePtr += pitch;	}    }
hLeft = height;
hLeft = height
hLeft
hLeft
height
height
hLeft > 0
hLeft
hLeft
0
{	int pixelSize = blockPtr->pixelSize;	int compRuleSet = (compRule == TK_PHOTO_COMPOSITE_SET);	srcLinePtr = blockPtr->pixelPtr + blockPtr->offset[0];	hCopy = MIN(hLeft, blockPtr->height);	hLeft -= hCopy;	for (; hCopy > 0; --hCopy) {	    /*	     * If the layout of the source line matches our memory layout and	     * we're setting, we can just copy the bytes directly, which is	     * much faster.	     */	    if ((pixelSize == 4) && (greenOffset == 1)		    && (blueOffset == 2) && (alphaOffset == 3)		    && (width <= blockPtr->width)		    && compRuleSet) {		memcpy(destLinePtr, srcLinePtr, (size_t) (width * 4));		srcLinePtr += blockPtr->pitch;		destLinePtr += pitch;		continue;	    }	    /*	     * Have to copy the slow way.	     */	    destPtr = destLinePtr;	    for (wLeft = width; wLeft > 0;) {		wCopy = MIN(wLeft, blockPtr->width);		wLeft -= wCopy;		srcPtr = srcLinePtr;		/*		 * But we might be lucky and be able to use fairly fast loops.		 * It's worth checking...		 */		if (alphaOffset == 0) {		    /*		     * This is the non-alpha case, so can still be fairly		     * fast. Note that in the non-alpha-source case, the		     * compositing rule doesn't apply.		     */		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = 255;		    }		    continue;		} else if (compRuleSet) {		    /*		     * This is the SET compositing rule, which just replaces		     * what was there before with the new data. This is		     * another fairly fast case. No point in doing a memcpy();		     * the order of channels is probably wrong.		     */		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = srcPtr[alphaOffset];		    }		    continue;		}		/*		 * Bother; need to consider the alpha value of each pixel to		 * know what to do.		 */		for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {		    int alpha = srcPtr[alphaOffset];		    if (alpha == 255 || !destPtr[3]) {			/*			 * Either the source is 100% opaque, or the			 * destination is entirely blank. In all cases, we			 * just set the destination to the source.			 */			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = alpha;			continue;		    }		    /*		     * Can still skip doing work if the source is 100%		     * transparent at this point.		     */		    if (alpha) {			int Alpha = destPtr[3];			/*			 * OK, there's real work to be done. Luckily, there's			 * a substantial literature on what to do in this			 * case. In particular, Porter and Duff have done a			 * taxonomy of compositing rules, and the right one is			 * the "Source Over" rule. This code implements that.			 */			destPtr[0] = PD_SRC_OVER(srcPtr[0], alpha, destPtr[0],				Alpha);			destPtr[1] = PD_SRC_OVER(srcPtr[greenOffset], alpha,				destPtr[1], Alpha);			destPtr[2] = PD_SRC_OVER(srcPtr[blueOffset], alpha,				destPtr[2], Alpha);			destPtr[3] = PD_SRC_OVER_ALPHA(alpha, Alpha);		    }		    destPtr += 4;		}	    }	    srcLinePtr += blockPtr->pitch;	    destLinePtr += pitch;	}    }
int pixelSize = blockPtr->pixelSize;
int pixelSize = blockPtr->pixelSize;
int
pixelSize = blockPtr->pixelSize
pixelSize
= blockPtr->pixelSize
blockPtr->pixelSize
blockPtr
blockPtr
pixelSize
int compRuleSet = (compRule == TK_PHOTO_COMPOSITE_SET);
int compRuleSet = (compRule == TK_PHOTO_COMPOSITE_SET);
int
compRuleSet = (compRule == TK_PHOTO_COMPOSITE_SET)
compRuleSet
= (compRule == TK_PHOTO_COMPOSITE_SET)
(compRule == TK_PHOTO_COMPOSITE_SET)
compRule == TK_PHOTO_COMPOSITE_SET
compRule
compRule
TK_PHOTO_COMPOSITE_SET
TK_PHOTO_COMPOSITE_SET
srcLinePtr = blockPtr->pixelPtr + blockPtr->offset[0];
srcLinePtr = blockPtr->pixelPtr + blockPtr->offset[0]
srcLinePtr
srcLinePtr
blockPtr->pixelPtr + blockPtr->offset[0]
blockPtr->pixelPtr
blockPtr
blockPtr
pixelPtr
blockPtr->offset[0]
blockPtr->offset
blockPtr
blockPtr
offset
0
hCopy = MIN(hLeft, blockPtr->height);
hCopy = MIN(hLeft, blockPtr->height)
hCopy
hCopy
MIN(hLeft, blockPtr->height)
MIN
MIN
hLeft
hLeft
blockPtr->height
blockPtr
blockPtr
height
hLeft -= hCopy;
hLeft -= hCopy
hLeft
hLeft
hCopy
hCopy
for (; hCopy > 0; --hCopy) {	    /*	     * If the layout of the source line matches our memory layout and	     * we're setting, we can just copy the bytes directly, which is	     * much faster.	     */	    if ((pixelSize == 4) && (greenOffset == 1)		    && (blueOffset == 2) && (alphaOffset == 3)		    && (width <= blockPtr->width)		    && compRuleSet) {		memcpy(destLinePtr, srcLinePtr, (size_t) (width * 4));		srcLinePtr += blockPtr->pitch;		destLinePtr += pitch;		continue;	    }	    /*	     * Have to copy the slow way.	     */	    destPtr = destLinePtr;	    for (wLeft = width; wLeft > 0;) {		wCopy = MIN(wLeft, blockPtr->width);		wLeft -= wCopy;		srcPtr = srcLinePtr;		/*		 * But we might be lucky and be able to use fairly fast loops.		 * It's worth checking...		 */		if (alphaOffset == 0) {		    /*		     * This is the non-alpha case, so can still be fairly		     * fast. Note that in the non-alpha-source case, the		     * compositing rule doesn't apply.		     */		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = 255;		    }		    continue;		} else if (compRuleSet) {		    /*		     * This is the SET compositing rule, which just replaces		     * what was there before with the new data. This is		     * another fairly fast case. No point in doing a memcpy();		     * the order of channels is probably wrong.		     */		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = srcPtr[alphaOffset];		    }		    continue;		}		/*		 * Bother; need to consider the alpha value of each pixel to		 * know what to do.		 */		for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {		    int alpha = srcPtr[alphaOffset];		    if (alpha == 255 || !destPtr[3]) {			/*			 * Either the source is 100% opaque, or the			 * destination is entirely blank. In all cases, we			 * just set the destination to the source.			 */			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = alpha;			continue;		    }		    /*		     * Can still skip doing work if the source is 100%		     * transparent at this point.		     */		    if (alpha) {			int Alpha = destPtr[3];			/*			 * OK, there's real work to be done. Luckily, there's			 * a substantial literature on what to do in this			 * case. In particular, Porter and Duff have done a			 * taxonomy of compositing rules, and the right one is			 * the "Source Over" rule. This code implements that.			 */			destPtr[0] = PD_SRC_OVER(srcPtr[0], alpha, destPtr[0],				Alpha);			destPtr[1] = PD_SRC_OVER(srcPtr[greenOffset], alpha,				destPtr[1], Alpha);			destPtr[2] = PD_SRC_OVER(srcPtr[blueOffset], alpha,				destPtr[2], Alpha);			destPtr[3] = PD_SRC_OVER_ALPHA(alpha, Alpha);		    }		    destPtr += 4;		}	    }	    srcLinePtr += blockPtr->pitch;	    destLinePtr += pitch;	}
;
hCopy > 0
hCopy
hCopy
0
--hCopy
hCopy
hCopy
{	    /*	     * If the layout of the source line matches our memory layout and	     * we're setting, we can just copy the bytes directly, which is	     * much faster.	     */	    if ((pixelSize == 4) && (greenOffset == 1)		    && (blueOffset == 2) && (alphaOffset == 3)		    && (width <= blockPtr->width)		    && compRuleSet) {		memcpy(destLinePtr, srcLinePtr, (size_t) (width * 4));		srcLinePtr += blockPtr->pitch;		destLinePtr += pitch;		continue;	    }	    /*	     * Have to copy the slow way.	     */	    destPtr = destLinePtr;	    for (wLeft = width; wLeft > 0;) {		wCopy = MIN(wLeft, blockPtr->width);		wLeft -= wCopy;		srcPtr = srcLinePtr;		/*		 * But we might be lucky and be able to use fairly fast loops.		 * It's worth checking...		 */		if (alphaOffset == 0) {		    /*		     * This is the non-alpha case, so can still be fairly		     * fast. Note that in the non-alpha-source case, the		     * compositing rule doesn't apply.		     */		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = 255;		    }		    continue;		} else if (compRuleSet) {		    /*		     * This is the SET compositing rule, which just replaces		     * what was there before with the new data. This is		     * another fairly fast case. No point in doing a memcpy();		     * the order of channels is probably wrong.		     */		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = srcPtr[alphaOffset];		    }		    continue;		}		/*		 * Bother; need to consider the alpha value of each pixel to		 * know what to do.		 */		for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {		    int alpha = srcPtr[alphaOffset];		    if (alpha == 255 || !destPtr[3]) {			/*			 * Either the source is 100% opaque, or the			 * destination is entirely blank. In all cases, we			 * just set the destination to the source.			 */			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = alpha;			continue;		    }		    /*		     * Can still skip doing work if the source is 100%		     * transparent at this point.		     */		    if (alpha) {			int Alpha = destPtr[3];			/*			 * OK, there's real work to be done. Luckily, there's			 * a substantial literature on what to do in this			 * case. In particular, Porter and Duff have done a			 * taxonomy of compositing rules, and the right one is			 * the "Source Over" rule. This code implements that.			 */			destPtr[0] = PD_SRC_OVER(srcPtr[0], alpha, destPtr[0],				Alpha);			destPtr[1] = PD_SRC_OVER(srcPtr[greenOffset], alpha,				destPtr[1], Alpha);			destPtr[2] = PD_SRC_OVER(srcPtr[blueOffset], alpha,				destPtr[2], Alpha);			destPtr[3] = PD_SRC_OVER_ALPHA(alpha, Alpha);		    }		    destPtr += 4;		}	    }	    srcLinePtr += blockPtr->pitch;	    destLinePtr += pitch;	}
if ((pixelSize == 4) && (greenOffset == 1)		    && (blueOffset == 2) && (alphaOffset == 3)		    && (width <= blockPtr->width)		    && compRuleSet) {		memcpy(destLinePtr, srcLinePtr, (size_t) (width * 4));		srcLinePtr += blockPtr->pitch;		destLinePtr += pitch;		continue;	    }
(pixelSize == 4) && (greenOffset == 1)		    && (blueOffset == 2) && (alphaOffset == 3)		    && (width <= blockPtr->width)		    && compRuleSet
(pixelSize == 4) && (greenOffset == 1)		    && (blueOffset == 2) && (alphaOffset == 3)		    && (width <= blockPtr->width)
(pixelSize == 4) && (greenOffset == 1)		    && (blueOffset == 2) && (alphaOffset == 3)
(pixelSize == 4) && (greenOffset == 1)		    && (blueOffset == 2)
(pixelSize == 4) && (greenOffset == 1)
(pixelSize == 4)
pixelSize == 4
pixelSize
pixelSize
4
(greenOffset == 1)
greenOffset == 1
greenOffset
greenOffset
1
(blueOffset == 2)
blueOffset == 2
blueOffset
blueOffset
2
(alphaOffset == 3)
alphaOffset == 3
alphaOffset
alphaOffset
3
(width <= blockPtr->width)
width <= blockPtr->width
width
width
blockPtr->width
blockPtr
blockPtr
width
compRuleSet
compRuleSet
{		memcpy(destLinePtr, srcLinePtr, (size_t) (width * 4));		srcLinePtr += blockPtr->pitch;		destLinePtr += pitch;		continue;	    }
memcpy(destLinePtr, srcLinePtr, (size_t) (width * 4));
memcpy(destLinePtr, srcLinePtr, (size_t) (width * 4))
memcpy
memcpy
destLinePtr
destLinePtr
srcLinePtr
srcLinePtr
(size_t) (width * 4)
(size_t)
size_t
size_t
width * 4
width
width
4
srcLinePtr += blockPtr->pitch;
srcLinePtr += blockPtr->pitch
srcLinePtr
srcLinePtr
blockPtr->pitch
blockPtr
blockPtr
pitch
destLinePtr += pitch;
destLinePtr += pitch
destLinePtr
destLinePtr
pitch
pitch
continue;
destPtr = destLinePtr;
destPtr = destLinePtr
destPtr
destPtr
destLinePtr
destLinePtr
for (wLeft = width; wLeft > 0;) {		wCopy = MIN(wLeft, blockPtr->width);		wLeft -= wCopy;		srcPtr = srcLinePtr;		/*		 * But we might be lucky and be able to use fairly fast loops.		 * It's worth checking...		 */		if (alphaOffset == 0) {		    /*		     * This is the non-alpha case, so can still be fairly		     * fast. Note that in the non-alpha-source case, the		     * compositing rule doesn't apply.		     */		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = 255;		    }		    continue;		} else if (compRuleSet) {		    /*		     * This is the SET compositing rule, which just replaces		     * what was there before with the new data. This is		     * another fairly fast case. No point in doing a memcpy();		     * the order of channels is probably wrong.		     */		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = srcPtr[alphaOffset];		    }		    continue;		}		/*		 * Bother; need to consider the alpha value of each pixel to		 * know what to do.		 */		for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {		    int alpha = srcPtr[alphaOffset];		    if (alpha == 255 || !destPtr[3]) {			/*			 * Either the source is 100% opaque, or the			 * destination is entirely blank. In all cases, we			 * just set the destination to the source.			 */			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = alpha;			continue;		    }		    /*		     * Can still skip doing work if the source is 100%		     * transparent at this point.		     */		    if (alpha) {			int Alpha = destPtr[3];			/*			 * OK, there's real work to be done. Luckily, there's			 * a substantial literature on what to do in this			 * case. In particular, Porter and Duff have done a			 * taxonomy of compositing rules, and the right one is			 * the "Source Over" rule. This code implements that.			 */			destPtr[0] = PD_SRC_OVER(srcPtr[0], alpha, destPtr[0],				Alpha);			destPtr[1] = PD_SRC_OVER(srcPtr[greenOffset], alpha,				destPtr[1], Alpha);			destPtr[2] = PD_SRC_OVER(srcPtr[blueOffset], alpha,				destPtr[2], Alpha);			destPtr[3] = PD_SRC_OVER_ALPHA(alpha, Alpha);		    }		    destPtr += 4;		}	    }
wLeft = width;
wLeft = width
wLeft
wLeft
width
width
wLeft > 0
wLeft
wLeft
0
{		wCopy = MIN(wLeft, blockPtr->width);		wLeft -= wCopy;		srcPtr = srcLinePtr;		/*		 * But we might be lucky and be able to use fairly fast loops.		 * It's worth checking...		 */		if (alphaOffset == 0) {		    /*		     * This is the non-alpha case, so can still be fairly		     * fast. Note that in the non-alpha-source case, the		     * compositing rule doesn't apply.		     */		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = 255;		    }		    continue;		} else if (compRuleSet) {		    /*		     * This is the SET compositing rule, which just replaces		     * what was there before with the new data. This is		     * another fairly fast case. No point in doing a memcpy();		     * the order of channels is probably wrong.		     */		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = srcPtr[alphaOffset];		    }		    continue;		}		/*		 * Bother; need to consider the alpha value of each pixel to		 * know what to do.		 */		for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {		    int alpha = srcPtr[alphaOffset];		    if (alpha == 255 || !destPtr[3]) {			/*			 * Either the source is 100% opaque, or the			 * destination is entirely blank. In all cases, we			 * just set the destination to the source.			 */			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = alpha;			continue;		    }		    /*		     * Can still skip doing work if the source is 100%		     * transparent at this point.		     */		    if (alpha) {			int Alpha = destPtr[3];			/*			 * OK, there's real work to be done. Luckily, there's			 * a substantial literature on what to do in this			 * case. In particular, Porter and Duff have done a			 * taxonomy of compositing rules, and the right one is			 * the "Source Over" rule. This code implements that.			 */			destPtr[0] = PD_SRC_OVER(srcPtr[0], alpha, destPtr[0],				Alpha);			destPtr[1] = PD_SRC_OVER(srcPtr[greenOffset], alpha,				destPtr[1], Alpha);			destPtr[2] = PD_SRC_OVER(srcPtr[blueOffset], alpha,				destPtr[2], Alpha);			destPtr[3] = PD_SRC_OVER_ALPHA(alpha, Alpha);		    }		    destPtr += 4;		}	    }
wCopy = MIN(wLeft, blockPtr->width);
wCopy = MIN(wLeft, blockPtr->width)
wCopy
wCopy
MIN(wLeft, blockPtr->width)
MIN
MIN
wLeft
wLeft
blockPtr->width
blockPtr
blockPtr
width
wLeft -= wCopy;
wLeft -= wCopy
wLeft
wLeft
wCopy
wCopy
srcPtr = srcLinePtr;
srcPtr = srcLinePtr
srcPtr
srcPtr
srcLinePtr
srcLinePtr
if (alphaOffset == 0) {		    /*		     * This is the non-alpha case, so can still be fairly		     * fast. Note that in the non-alpha-source case, the		     * compositing rule doesn't apply.		     */		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = 255;		    }		    continue;		} else if (compRuleSet) {		    /*		     * This is the SET compositing rule, which just replaces		     * what was there before with the new data. This is		     * another fairly fast case. No point in doing a memcpy();		     * the order of channels is probably wrong.		     */		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = srcPtr[alphaOffset];		    }		    continue;		}
alphaOffset == 0
alphaOffset
alphaOffset
0
{		    /*		     * This is the non-alpha case, so can still be fairly		     * fast. Note that in the non-alpha-source case, the		     * compositing rule doesn't apply.		     */		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = 255;		    }		    continue;		}
for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = 255;		    }
;
wCopy>0
wCopy
wCopy
0
--wCopy, srcPtr+=pixelSize
--wCopy
wCopy
wCopy
srcPtr+=pixelSize
srcPtr
srcPtr
pixelSize
pixelSize
{			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = 255;		    }
*destPtr++ = srcPtr[0];
*destPtr++ = srcPtr[0]
*destPtr++
destPtr++
destPtr
destPtr
srcPtr[0]
srcPtr
srcPtr
0
*destPtr++ = srcPtr[greenOffset];
*destPtr++ = srcPtr[greenOffset]
*destPtr++
destPtr++
destPtr
destPtr
srcPtr[greenOffset]
srcPtr
srcPtr
greenOffset
greenOffset
*destPtr++ = srcPtr[blueOffset];
*destPtr++ = srcPtr[blueOffset]
*destPtr++
destPtr++
destPtr
destPtr
srcPtr[blueOffset]
srcPtr
srcPtr
blueOffset
blueOffset
*destPtr++ = 255;
*destPtr++ = 255
*destPtr++
destPtr++
destPtr
destPtr
255
continue;
if (compRuleSet) {		    /*		     * This is the SET compositing rule, which just replaces		     * what was there before with the new data. This is		     * another fairly fast case. No point in doing a memcpy();		     * the order of channels is probably wrong.		     */		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = srcPtr[alphaOffset];		    }		    continue;		}
compRuleSet
compRuleSet
{		    /*		     * This is the SET compositing rule, which just replaces		     * what was there before with the new data. This is		     * another fairly fast case. No point in doing a memcpy();		     * the order of channels is probably wrong.		     */		    for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = srcPtr[alphaOffset];		    }		    continue;		}
for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = srcPtr[alphaOffset];		    }
;
wCopy>0
wCopy
wCopy
0
--wCopy, srcPtr+=pixelSize
--wCopy
wCopy
wCopy
srcPtr+=pixelSize
srcPtr
srcPtr
pixelSize
pixelSize
{			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = srcPtr[alphaOffset];		    }
*destPtr++ = srcPtr[0];
*destPtr++ = srcPtr[0]
*destPtr++
destPtr++
destPtr
destPtr
srcPtr[0]
srcPtr
srcPtr
0
*destPtr++ = srcPtr[greenOffset];
*destPtr++ = srcPtr[greenOffset]
*destPtr++
destPtr++
destPtr
destPtr
srcPtr[greenOffset]
srcPtr
srcPtr
greenOffset
greenOffset
*destPtr++ = srcPtr[blueOffset];
*destPtr++ = srcPtr[blueOffset]
*destPtr++
destPtr++
destPtr
destPtr
srcPtr[blueOffset]
srcPtr
srcPtr
blueOffset
blueOffset
*destPtr++ = srcPtr[alphaOffset];
*destPtr++ = srcPtr[alphaOffset]
*destPtr++
destPtr++
destPtr
destPtr
srcPtr[alphaOffset]
srcPtr
srcPtr
alphaOffset
alphaOffset
continue;
for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize) {		    int alpha = srcPtr[alphaOffset];		    if (alpha == 255 || !destPtr[3]) {			/*			 * Either the source is 100% opaque, or the			 * destination is entirely blank. In all cases, we			 * just set the destination to the source.			 */			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = alpha;			continue;		    }		    /*		     * Can still skip doing work if the source is 100%		     * transparent at this point.		     */		    if (alpha) {			int Alpha = destPtr[3];			/*			 * OK, there's real work to be done. Luckily, there's			 * a substantial literature on what to do in this			 * case. In particular, Porter and Duff have done a			 * taxonomy of compositing rules, and the right one is			 * the "Source Over" rule. This code implements that.			 */			destPtr[0] = PD_SRC_OVER(srcPtr[0], alpha, destPtr[0],				Alpha);			destPtr[1] = PD_SRC_OVER(srcPtr[greenOffset], alpha,				destPtr[1], Alpha);			destPtr[2] = PD_SRC_OVER(srcPtr[blueOffset], alpha,				destPtr[2], Alpha);			destPtr[3] = PD_SRC_OVER_ALPHA(alpha, Alpha);		    }		    destPtr += 4;		}
;
wCopy>0
wCopy
wCopy
0
--wCopy, srcPtr+=pixelSize
--wCopy
wCopy
wCopy
srcPtr+=pixelSize
srcPtr
srcPtr
pixelSize
pixelSize
{		    int alpha = srcPtr[alphaOffset];		    if (alpha == 255 || !destPtr[3]) {			/*			 * Either the source is 100% opaque, or the			 * destination is entirely blank. In all cases, we			 * just set the destination to the source.			 */			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = alpha;			continue;		    }		    /*		     * Can still skip doing work if the source is 100%		     * transparent at this point.		     */		    if (alpha) {			int Alpha = destPtr[3];			/*			 * OK, there's real work to be done. Luckily, there's			 * a substantial literature on what to do in this			 * case. In particular, Porter and Duff have done a			 * taxonomy of compositing rules, and the right one is			 * the "Source Over" rule. This code implements that.			 */			destPtr[0] = PD_SRC_OVER(srcPtr[0], alpha, destPtr[0],				Alpha);			destPtr[1] = PD_SRC_OVER(srcPtr[greenOffset], alpha,				destPtr[1], Alpha);			destPtr[2] = PD_SRC_OVER(srcPtr[blueOffset], alpha,				destPtr[2], Alpha);			destPtr[3] = PD_SRC_OVER_ALPHA(alpha, Alpha);		    }		    destPtr += 4;		}
int alpha = srcPtr[alphaOffset];
int alpha = srcPtr[alphaOffset];
int
alpha = srcPtr[alphaOffset]
alpha
= srcPtr[alphaOffset]
srcPtr[alphaOffset]
srcPtr
srcPtr
alphaOffset
alphaOffset
if (alpha == 255 || !destPtr[3]) {			/*			 * Either the source is 100% opaque, or the			 * destination is entirely blank. In all cases, we			 * just set the destination to the source.			 */			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = alpha;			continue;		    }
alpha == 255 || !destPtr[3]
alpha == 255
alpha
alpha
255
!destPtr[3]
destPtr[3]
destPtr
destPtr
3
{			/*			 * Either the source is 100% opaque, or the			 * destination is entirely blank. In all cases, we			 * just set the destination to the source.			 */			*destPtr++ = srcPtr[0];			*destPtr++ = srcPtr[greenOffset];			*destPtr++ = srcPtr[blueOffset];			*destPtr++ = alpha;			continue;		    }
*destPtr++ = srcPtr[0];
*destPtr++ = srcPtr[0]
*destPtr++
destPtr++
destPtr
destPtr
srcPtr[0]
srcPtr
srcPtr
0
*destPtr++ = srcPtr[greenOffset];
*destPtr++ = srcPtr[greenOffset]
*destPtr++
destPtr++
destPtr
destPtr
srcPtr[greenOffset]
srcPtr
srcPtr
greenOffset
greenOffset
*destPtr++ = srcPtr[blueOffset];
*destPtr++ = srcPtr[blueOffset]
*destPtr++
destPtr++
destPtr
destPtr
srcPtr[blueOffset]
srcPtr
srcPtr
blueOffset
blueOffset
*destPtr++ = alpha;
*destPtr++ = alpha
*destPtr++
destPtr++
destPtr
destPtr
alpha
alpha
continue;
if (alpha) {			int Alpha = destPtr[3];			/*			 * OK, there's real work to be done. Luckily, there's			 * a substantial literature on what to do in this			 * case. In particular, Porter and Duff have done a			 * taxonomy of compositing rules, and the right one is			 * the "Source Over" rule. This code implements that.			 */			destPtr[0] = PD_SRC_OVER(srcPtr[0], alpha, destPtr[0],				Alpha);			destPtr[1] = PD_SRC_OVER(srcPtr[greenOffset], alpha,				destPtr[1], Alpha);			destPtr[2] = PD_SRC_OVER(srcPtr[blueOffset], alpha,				destPtr[2], Alpha);			destPtr[3] = PD_SRC_OVER_ALPHA(alpha, Alpha);		    }
alpha
alpha
{			int Alpha = destPtr[3];			/*			 * OK, there's real work to be done. Luckily, there's			 * a substantial literature on what to do in this			 * case. In particular, Porter and Duff have done a			 * taxonomy of compositing rules, and the right one is			 * the "Source Over" rule. This code implements that.			 */			destPtr[0] = PD_SRC_OVER(srcPtr[0], alpha, destPtr[0],				Alpha);			destPtr[1] = PD_SRC_OVER(srcPtr[greenOffset], alpha,				destPtr[1], Alpha);			destPtr[2] = PD_SRC_OVER(srcPtr[blueOffset], alpha,				destPtr[2], Alpha);			destPtr[3] = PD_SRC_OVER_ALPHA(alpha, Alpha);		    }
int Alpha = destPtr[3];
int Alpha = destPtr[3];
int
Alpha = destPtr[3]
Alpha
= destPtr[3]
destPtr[3]
destPtr
destPtr
3
destPtr[0] = PD_SRC_OVER(srcPtr[0], alpha, destPtr[0],				Alpha);
destPtr[0] = PD_SRC_OVER(srcPtr[0], alpha, destPtr[0],				Alpha)
destPtr[0]
destPtr
destPtr
0
PD_SRC_OVER(srcPtr[0], alpha, destPtr[0],				Alpha)
PD_SRC_OVER
PD_SRC_OVER
srcPtr[0]
srcPtr
srcPtr
0
alpha
alpha
destPtr[0]
destPtr
destPtr
0
Alpha
Alpha
destPtr[1] = PD_SRC_OVER(srcPtr[greenOffset], alpha,				destPtr[1], Alpha);
destPtr[1] = PD_SRC_OVER(srcPtr[greenOffset], alpha,				destPtr[1], Alpha)
destPtr[1]
destPtr
destPtr
1
PD_SRC_OVER(srcPtr[greenOffset], alpha,				destPtr[1], Alpha)
PD_SRC_OVER
PD_SRC_OVER
srcPtr[greenOffset]
srcPtr
srcPtr
greenOffset
greenOffset
alpha
alpha
destPtr[1]
destPtr
destPtr
1
Alpha
Alpha
destPtr[2] = PD_SRC_OVER(srcPtr[blueOffset], alpha,				destPtr[2], Alpha);
destPtr[2] = PD_SRC_OVER(srcPtr[blueOffset], alpha,				destPtr[2], Alpha)
destPtr[2]
destPtr
destPtr
2
PD_SRC_OVER(srcPtr[blueOffset], alpha,				destPtr[2], Alpha)
PD_SRC_OVER
PD_SRC_OVER
srcPtr[blueOffset]
srcPtr
srcPtr
blueOffset
blueOffset
alpha
alpha
destPtr[2]
destPtr
destPtr
2
Alpha
Alpha
destPtr[3] = PD_SRC_OVER_ALPHA(alpha, Alpha);
destPtr[3] = PD_SRC_OVER_ALPHA(alpha, Alpha)
destPtr[3]
destPtr
destPtr
3
PD_SRC_OVER_ALPHA(alpha, Alpha)
PD_SRC_OVER_ALPHA
PD_SRC_OVER_ALPHA
alpha
alpha
Alpha
Alpha
destPtr += 4;
destPtr += 4
destPtr
destPtr
4
srcLinePtr += blockPtr->pitch;
srcLinePtr += blockPtr->pitch
srcLinePtr
srcLinePtr
blockPtr->pitch
blockPtr
blockPtr
pitch
destLinePtr += pitch;
destLinePtr += pitch
destLinePtr
destLinePtr
pitch
pitch
if (alphaOffset) {	/*	 * This block is grossly inefficient. For each row in the image, it	 * finds each continguous string of nontransparent pixels, then marks	 * those areas as valid in the validRegion mask. This makes drawing	 * very efficient, because of the way we use X: we just say, here's	 * your mask, and here's your data. We need not worry about the	 * current background color, etc. But this costs us a lot on the image	 * setup. Still, image setup only happens once, whereas the drawing	 * happens many times, so this might be the best way to go.	 *	 * An alternative might be to not set up this mask, and instead, at	 * drawing time, for each transparent pixel, set its color to the	 * color of the background behind that pixel. This is what I suspect	 * most of programs do. However, they don't have to deal with the	 * canvas, which could have many different background colors.	 * Determining the correct bg color for a given pixel might be	 * expensive.	 */	if (compRule != TK_PHOTO_COMPOSITE_OVERLAY) {	    TkRegion workRgn;	    /*	     * Don't need this when using the OVERLAY compositing rule, which	     * always strictly increases the valid region.	     */	recalculateValidRegion:	    workRgn = TkCreateRegion();	    rect.x = x;	    rect.y = y;	    rect.width = width;	    rect.height = height;	    TkUnionRectWithRegion(&rect, workRgn, workRgn);	    TkSubtractRegion(masterPtr->validRegion, workRgn,		    masterPtr->validRegion);	    TkDestroyRegion(workRgn);	}	/*	 * Factorize out the main part of the building of the region data to	 * allow for more efficient per-platform implementations. [Bug 919066]	 */	TkpBuildRegionFromAlphaData(masterPtr->validRegion, (unsigned) x,		(unsigned) y, (unsigned) width, (unsigned) height,		masterPtr->pix32 + (y * masterPtr->width + x) * 4 + 3,		4, (unsigned) masterPtr->width * 4);    } else {	rect.x = x;	rect.y = y;	rect.width = width;	rect.height = height;	TkUnionRectWithRegion(&rect, masterPtr->validRegion,		masterPtr->validRegion);    }
alphaOffset
alphaOffset
{	/*	 * This block is grossly inefficient. For each row in the image, it	 * finds each continguous string of nontransparent pixels, then marks	 * those areas as valid in the validRegion mask. This makes drawing	 * very efficient, because of the way we use X: we just say, here's	 * your mask, and here's your data. We need not worry about the	 * current background color, etc. But this costs us a lot on the image	 * setup. Still, image setup only happens once, whereas the drawing	 * happens many times, so this might be the best way to go.	 *	 * An alternative might be to not set up this mask, and instead, at	 * drawing time, for each transparent pixel, set its color to the	 * color of the background behind that pixel. This is what I suspect	 * most of programs do. However, they don't have to deal with the	 * canvas, which could have many different background colors.	 * Determining the correct bg color for a given pixel might be	 * expensive.	 */	if (compRule != TK_PHOTO_COMPOSITE_OVERLAY) {	    TkRegion workRgn;	    /*	     * Don't need this when using the OVERLAY compositing rule, which	     * always strictly increases the valid region.	     */	recalculateValidRegion:	    workRgn = TkCreateRegion();	    rect.x = x;	    rect.y = y;	    rect.width = width;	    rect.height = height;	    TkUnionRectWithRegion(&rect, workRgn, workRgn);	    TkSubtractRegion(masterPtr->validRegion, workRgn,		    masterPtr->validRegion);	    TkDestroyRegion(workRgn);	}	/*	 * Factorize out the main part of the building of the region data to	 * allow for more efficient per-platform implementations. [Bug 919066]	 */	TkpBuildRegionFromAlphaData(masterPtr->validRegion, (unsigned) x,		(unsigned) y, (unsigned) width, (unsigned) height,		masterPtr->pix32 + (y * masterPtr->width + x) * 4 + 3,		4, (unsigned) masterPtr->width * 4);    }
if (compRule != TK_PHOTO_COMPOSITE_OVERLAY) {	    TkRegion workRgn;	    /*	     * Don't need this when using the OVERLAY compositing rule, which	     * always strictly increases the valid region.	     */	recalculateValidRegion:	    workRgn = TkCreateRegion();	    rect.x = x;	    rect.y = y;	    rect.width = width;	    rect.height = height;	    TkUnionRectWithRegion(&rect, workRgn, workRgn);	    TkSubtractRegion(masterPtr->validRegion, workRgn,		    masterPtr->validRegion);	    TkDestroyRegion(workRgn);	}
compRule != TK_PHOTO_COMPOSITE_OVERLAY
compRule
compRule
TK_PHOTO_COMPOSITE_OVERLAY
TK_PHOTO_COMPOSITE_OVERLAY
{	    TkRegion workRgn;	    /*	     * Don't need this when using the OVERLAY compositing rule, which	     * always strictly increases the valid region.	     */	recalculateValidRegion:	    workRgn = TkCreateRegion();	    rect.x = x;	    rect.y = y;	    rect.width = width;	    rect.height = height;	    TkUnionRectWithRegion(&rect, workRgn, workRgn);	    TkSubtractRegion(masterPtr->validRegion, workRgn,		    masterPtr->validRegion);	    TkDestroyRegion(workRgn);	}
TkRegion workRgn;
TkRegion workRgn;
TkRegion
TkRegion
workRgn
workRgn
recalculateValidRegion:	    workRgn = TkCreateRegion();
recalculateValidRegion
workRgn = TkCreateRegion();
workRgn = TkCreateRegion()
workRgn
workRgn
TkCreateRegion()
TkCreateRegion
TkCreateRegion
rect.x = x;
rect.x = x
rect.x
rect
rect
x
x
x
rect.y = y;
rect.y = y
rect.y
rect
rect
y
y
y
rect.width = width;
rect.width = width
rect.width
rect
rect
width
width
width
rect.height = height;
rect.height = height
rect.height
rect
rect
height
height
height
TkUnionRectWithRegion(&rect, workRgn, workRgn);
TkUnionRectWithRegion(&rect, workRgn, workRgn)
TkUnionRectWithRegion
TkUnionRectWithRegion
&rect
rect
rect
workRgn
workRgn
workRgn
workRgn
TkSubtractRegion(masterPtr->validRegion, workRgn,		    masterPtr->validRegion);
TkSubtractRegion(masterPtr->validRegion, workRgn,		    masterPtr->validRegion)
TkSubtractRegion
TkSubtractRegion
masterPtr->validRegion
masterPtr
masterPtr
validRegion
workRgn
workRgn
masterPtr->validRegion
masterPtr
masterPtr
validRegion
TkDestroyRegion(workRgn);
TkDestroyRegion(workRgn)
TkDestroyRegion
TkDestroyRegion
workRgn
workRgn
TkpBuildRegionFromAlphaData(masterPtr->validRegion, (unsigned) x,		(unsigned) y, (unsigned) width, (unsigned) height,		masterPtr->pix32 + (y * masterPtr->width + x) * 4 + 3,		4, (unsigned) masterPtr->width * 4);
TkpBuildRegionFromAlphaData(masterPtr->validRegion, (unsigned) x,		(unsigned) y, (unsigned) width, (unsigned) height,		masterPtr->pix32 + (y * masterPtr->width + x) * 4 + 3,		4, (unsigned) masterPtr->width * 4)
TkpBuildRegionFromAlphaData
TkpBuildRegionFromAlphaData
masterPtr->validRegion
masterPtr
masterPtr
validRegion
(unsigned) x
unsigned
unsigned

x
x
(unsigned) y
unsigned
unsigned

y
y
(unsigned) width
unsigned
unsigned

width
width
(unsigned) height
unsigned
unsigned

height
height
masterPtr->pix32 + (y * masterPtr->width + x) * 4 + 3
masterPtr->pix32 + (y * masterPtr->width + x) * 4
masterPtr->pix32
masterPtr
masterPtr
pix32
(y * masterPtr->width + x) * 4
(y * masterPtr->width + x)
y * masterPtr->width + x
y * masterPtr->width
y
y
masterPtr->width
masterPtr
masterPtr
width
x
x
4
3
4
(unsigned) masterPtr->width * 4
(unsigned) masterPtr->width
unsigned
unsigned

masterPtr->width
masterPtr
masterPtr
width
4
{	rect.x = x;	rect.y = y;	rect.width = width;	rect.height = height;	TkUnionRectWithRegion(&rect, masterPtr->validRegion,		masterPtr->validRegion);    }
rect.x = x;
rect.x = x
rect.x
rect
rect
x
x
x
rect.y = y;
rect.y = y
rect.y
rect
rect
y
y
y
rect.width = width;
rect.width = width
rect.width
rect
rect
width
width
width
rect.height = height;
rect.height = height
rect.height
rect
rect
height
height
height
TkUnionRectWithRegion(&rect, masterPtr->validRegion,		masterPtr->validRegion);
TkUnionRectWithRegion(&rect, masterPtr->validRegion,		masterPtr->validRegion)
TkUnionRectWithRegion
TkUnionRectWithRegion
&rect
rect
rect
masterPtr->validRegion
masterPtr
masterPtr
validRegion
masterPtr->validRegion
masterPtr
masterPtr
validRegion
if (!sourceIsSimplePhoto && (width == 1) && (height == 1)) {	/*	 * Optimize the single pixel case if we can. This speeds up code that	 * builds up large simple-alpha images by single pixels.  We don't	 * negate COMPLEX_ALPHA in this case. [Bug 1409140]	 */	if (!(masterPtr->flags & COMPLEX_ALPHA)) {	    unsigned char newAlpha;	    destLinePtr = masterPtr->pix32 + (y * masterPtr->width + x) * 4;	    newAlpha = destLinePtr[3];	    if (newAlpha && newAlpha != 255) {		masterPtr->flags |= COMPLEX_ALPHA;	    }	}    } else if ((alphaOffset != 0) || (masterPtr->flags & COMPLEX_ALPHA)) {	/*	 * Check for partial transparency if alpha pixels are specified, or	 * rescan if we already knew such pixels existed.  To restrict this	 * Toggle to only checking the changed pixels requires knowing where	 * the alpha pixels are.	 */	ToggleComplexAlphaIfNeeded(masterPtr);    }
!sourceIsSimplePhoto && (width == 1) && (height == 1)
!sourceIsSimplePhoto && (width == 1)
!sourceIsSimplePhoto
sourceIsSimplePhoto
sourceIsSimplePhoto
(width == 1)
width == 1
width
width
1
(height == 1)
height == 1
height
height
1
{	/*	 * Optimize the single pixel case if we can. This speeds up code that	 * builds up large simple-alpha images by single pixels.  We don't	 * negate COMPLEX_ALPHA in this case. [Bug 1409140]	 */	if (!(masterPtr->flags & COMPLEX_ALPHA)) {	    unsigned char newAlpha;	    destLinePtr = masterPtr->pix32 + (y * masterPtr->width + x) * 4;	    newAlpha = destLinePtr[3];	    if (newAlpha && newAlpha != 255) {		masterPtr->flags |= COMPLEX_ALPHA;	    }	}    }
if (!(masterPtr->flags & COMPLEX_ALPHA)) {	    unsigned char newAlpha;	    destLinePtr = masterPtr->pix32 + (y * masterPtr->width + x) * 4;	    newAlpha = destLinePtr[3];	    if (newAlpha && newAlpha != 255) {		masterPtr->flags |= COMPLEX_ALPHA;	    }	}
!(masterPtr->flags & COMPLEX_ALPHA)
(masterPtr->flags & COMPLEX_ALPHA)
masterPtr->flags & COMPLEX_ALPHA
masterPtr->flags
masterPtr
masterPtr
flags
COMPLEX_ALPHA
COMPLEX_ALPHA
{	    unsigned char newAlpha;	    destLinePtr = masterPtr->pix32 + (y * masterPtr->width + x) * 4;	    newAlpha = destLinePtr[3];	    if (newAlpha && newAlpha != 255) {		masterPtr->flags |= COMPLEX_ALPHA;	    }	}
unsigned char newAlpha;
unsigned char newAlpha;
unsigned char
newAlpha
newAlpha
destLinePtr = masterPtr->pix32 + (y * masterPtr->width + x) * 4;
destLinePtr = masterPtr->pix32 + (y * masterPtr->width + x) * 4
destLinePtr
destLinePtr
masterPtr->pix32 + (y * masterPtr->width + x) * 4
masterPtr->pix32
masterPtr
masterPtr
pix32
(y * masterPtr->width + x) * 4
(y * masterPtr->width + x)
y * masterPtr->width + x
y * masterPtr->width
y
y
masterPtr->width
masterPtr
masterPtr
width
x
x
4
newAlpha = destLinePtr[3];
newAlpha = destLinePtr[3]
newAlpha
newAlpha
destLinePtr[3]
destLinePtr
destLinePtr
3
if (newAlpha && newAlpha != 255) {		masterPtr->flags |= COMPLEX_ALPHA;	    }
newAlpha && newAlpha != 255
newAlpha
newAlpha
newAlpha != 255
newAlpha
newAlpha
255
{		masterPtr->flags |= COMPLEX_ALPHA;	    }
masterPtr->flags |= COMPLEX_ALPHA;
masterPtr->flags |= COMPLEX_ALPHA
masterPtr->flags
masterPtr
masterPtr
flags
COMPLEX_ALPHA
COMPLEX_ALPHA
if ((alphaOffset != 0) || (masterPtr->flags & COMPLEX_ALPHA)) {	/*	 * Check for partial transparency if alpha pixels are specified, or	 * rescan if we already knew such pixels existed.  To restrict this	 * Toggle to only checking the changed pixels requires knowing where	 * the alpha pixels are.	 */	ToggleComplexAlphaIfNeeded(masterPtr);    }
(alphaOffset != 0) || (masterPtr->flags & COMPLEX_ALPHA)
(alphaOffset != 0)
alphaOffset != 0
alphaOffset
alphaOffset
0
(masterPtr->flags & COMPLEX_ALPHA)
masterPtr->flags & COMPLEX_ALPHA
masterPtr->flags
masterPtr
masterPtr
flags
COMPLEX_ALPHA
COMPLEX_ALPHA
{	/*	 * Check for partial transparency if alpha pixels are specified, or	 * rescan if we already knew such pixels existed.  To restrict this	 * Toggle to only checking the changed pixels requires knowing where	 * the alpha pixels are.	 */	ToggleComplexAlphaIfNeeded(masterPtr);    }
ToggleComplexAlphaIfNeeded(masterPtr);
ToggleComplexAlphaIfNeeded(masterPtr)
ToggleComplexAlphaIfNeeded
ToggleComplexAlphaIfNeeded
masterPtr
masterPtr
Tk_DitherPhoto((Tk_PhotoHandle)masterPtr, x, y, width, height);
Tk_DitherPhoto((Tk_PhotoHandle)masterPtr, x, y, width, height)
Tk_DitherPhoto
Tk_DitherPhoto
(Tk_PhotoHandle)masterPtr
Tk_PhotoHandle
Tk_PhotoHandle
Tk_PhotoHandle

masterPtr
masterPtr
x
x
y
y
width
width
height
height
Tk_ImageChanged(masterPtr->tkMaster, x, y, width, height,	    masterPtr->width, masterPtr->height);
Tk_ImageChanged(masterPtr->tkMaster, x, y, width, height,	    masterPtr->width, masterPtr->height)
Tk_ImageChanged
Tk_ImageChanged
masterPtr->tkMaster
masterPtr
masterPtr
tkMaster
x
x
y
y
width
width
height
height
masterPtr->width
masterPtr
masterPtr
width
masterPtr->height
masterPtr
masterPtr
height
return TCL_OK;
TCL_OK
TCL_OK
-----joern-----
(550,825,0)
(216,565,0)
(614,46,0)
(525,250,0)
(352,348,0)
(696,513,0)
(654,311,0)
(747,422,0)
(743,515,0)
(436,524,0)
(542,837,0)
(485,240,0)
(161,719,0)
(576,234,0)
(699,664,0)
(769,779,0)
(640,152,0)
(230,22,0)
(298,414,0)
(726,181,0)
(739,489,0)
(292,870,0)
(172,373,0)
(565,735,0)
(594,142,0)
(25,459,0)
(713,212,0)
(622,465,0)
(664,364,0)
(459,61,0)
(771,460,0)
(46,531,0)
(281,856,0)
(669,148,0)
(459,779,0)
(591,412,0)
(246,609,0)
(741,46,0)
(755,87,0)
(42,640,0)
(409,775,0)
(626,470,0)
(755,830,0)
(143,278,0)
(886,367,0)
(350,87,0)
(25,191,0)
(568,240,0)
(664,451,0)
(674,524,0)
(840,788,0)
(204,32,0)
(337,422,0)
(499,210,0)
(293,337,0)
(409,87,0)
(28,275,0)
(45,781,0)
(49,191,0)
(746,251,0)
(755,865,0)
(17,91,0)
(5,823,0)
(257,666,0)
(314,533,0)
(827,212,0)
(185,529,0)
(750,736,0)
(360,144,0)
(890,318,0)
(823,883,0)
(879,253,0)
(892,178,0)
(657,140,0)
(140,130,0)
(177,194,0)
(6,642,0)
(429,442,0)
(31,285,0)
(672,771,0)
(874,186,0)
(865,562,0)
(834,8,0)
(671,755,0)
(221,197,0)
(341,200,0)
(669,787,0)
(404,102,0)
(580,667,0)
(400,601,0)
(95,808,0)
(721,611,0)
(862,202,0)
(587,285,0)
(603,183,0)
(22,91,0)
(534,487,0)
(465,414,0)
(860,155,0)
(326,578,0)
(529,285,0)
(184,559,0)
(430,1,0)
(725,200,0)
(863,670,0)
(438,784,0)
(893,587,0)
(36,3,0)
(755,861,0)
(441,377,0)
(88,298,0)
(267,2,0)
(159,702,0)
(150,194,0)
(345,364,0)
(784,788,0)
(535,285,0)
(863,91,0)
(828,501,0)
(160,533,0)
(789,140,0)
(191,49,0)
(359,257,0)
(310,122,0)
(599,517,0)
(665,186,0)
(342,635,0)
(500,151,0)
(152,640,0)
(233,582,0)
(651,186,0)
(95,598,0)
(865,504,0)
(398,91,0)
(412,750,0)
(746,449,0)
(411,91,0)
(665,489,0)
(537,131,0)
(783,518,0)
(417,31,0)
(518,511,0)
(373,422,0)
(123,678,0)
(572,135,0)
(596,456,0)
(335,360,0)
(15,155,0)
(755,684,0)
(519,158,0)
(778,436,0)
(204,175,0)
(517,405,0)
(685,398,0)
(278,317,0)
(755,331,0)
(397,113,0)
(276,408,0)
(247,236,0)
(334,764,0)
(248,411,0)
(808,95,0)
(626,31,0)
(634,796,0)
(180,870,0)
(798,745,0)
(412,91,0)
(245,158,0)
(225,60,0)
(169,864,0)
(82,169,0)
(755,182,0)
(613,31,0)
(439,745,0)
(272,566,0)
(647,796,0)
(581,566,0)
(490,240,0)
(598,432,0)
(513,62,0)
(36,850,0)
(73,152,0)
(455,385,0)
(566,581,0)
(238,90,0)
(443,762,0)
(796,787,0)
(10,736,0)
(351,149,0)
(131,523,0)
(507,327,0)
(150,470,0)
(37,316,0)
(88,874,0)
(749,603,0)
(393,735,0)
(570,240,0)
(386,226,0)
(511,46,0)
(14,472,0)
(331,615,0)
(220,306,0)
(594,594,0)
(625,489,0)
(736,348,0)
(545,86,0)
(146,460,0)
(74,384,0)
(5,181,0)
(795,734,0)
(409,182,0)
(65,189,0)
(666,257,0)
(155,240,0)
(182,831,0)
(575,253,0)
(314,250,0)
(606,405,0)
(256,499,0)
(887,172,0)
(236,871,0)
(673,373,0)
(49,196,0)
(733,867,0)
(528,553,0)
(97,91,0)
(324,240,0)
(592,46,0)
(2,458,0)
(749,406,0)
(766,275,0)
(518,621,0)
(464,186,0)
(130,46,0)
(15,745,0)
(152,715,0)
(431,9,0)
(555,196,0)
(703,182,0)
(423,406,0)
(475,880,0)
(452,97,0)
(763,729,0)
(46,573,0)
(11,778,0)
(646,229,0)
(496,721,0)
(767,46,0)
(512,32,0)
(739,186,0)
(210,201,0)
(29,257,0)
(291,240,0)
(573,36,0)
(759,231,0)
(896,711,0)
(575,414,0)
(420,73,0)
(152,761,0)
(339,188,0)
(132,194,0)
(18,35,0)
(609,46,0)
(409,52,0)
(169,397,0)
(643,841,0)
(248,253,0)
(625,152,0)
(559,184,0)
(809,461,0)
(548,864,0)
(371,201,0)
(46,276,0)
(202,862,0)
(483,216,0)
(615,775,0)
(515,472,0)
(84,608,0)
(329,719,0)
(586,432,0)
(211,736,0)
(59,531,0)
(51,871,0)
(40,334,0)
(706,136,0)
(771,364,0)
(578,326,0)
(35,240,0)
(648,406,0)
(511,142,0)
(806,449,0)
(565,216,0)
(870,628,0)
(31,626,0)
(409,240,0)
(695,464,0)
(421,91,0)
(660,28,0)
(413,750,0)
(454,96,0)
(317,119,0)
(682,406,0)
(648,513,0)
(505,715,0)
(362,771,0)
(813,489,0)
(755,775,0)
(734,612,0)
(518,46,0)
(85,303,0)
(121,698,0)
(77,825,0)
(719,258,0)
(274,122,0)
(548,460,0)
(544,576,0)
(81,871,0)
(46,306,0)
(644,196,0)
(750,240,0)
(531,573,0)
(619,292,0)
(790,449,0)
(750,405,0)
(249,850,0)
(629,414,0)
(153,515,0)
(442,1,0)
(745,155,0)
(36,573,0)
(283,812,0)
(630,3,0)
(279,186,0)
(108,565,0)
(6,265,0)
(594,46,0)
(786,629,0)
(188,403,0)
(414,133,0)
(116,750,0)
(797,627,0)
(602,671,0)
(391,210,0)
(202,396,0)
(804,292,0)
(343,604,0)
(214,774,0)
(274,4,0)
(474,760,0)
(480,844,0)
(134,348,0)
(669,829,0)
(334,405,0)
(834,48,0)
(787,401,0)
(823,91,0)
(744,434,0)
(745,722,0)
(453,464,0)
(181,91,0)
(246,818,0)
(650,729,0)
(389,498,0)
(679,665,0)
(514,46,0)
(435,625,0)
(366,149,0)
(10,446,0)
(102,253,0)
(745,745,0)
(158,519,0)
(191,25,0)
(654,155,0)
(826,17,0)
(652,418,0)
(43,8,0)
(168,301,0)
(156,764,0)
(754,152,0)
(148,558,0)
(729,763,0)
(175,91,0)
(511,623,0)
(461,880,0)
(755,136,0)
(745,223,0)
(535,766,0)
(871,236,0)
(113,142,0)
(872,367,0)
(590,265,0)
(251,746,0)
(3,825,0)
(828,414,0)
(181,5,0)
(288,655,0)
(655,57,0)
(730,713,0)
(71,216,0)
(615,582,0)
(276,531,0)
(594,234,0)
(152,539,0)
(409,582,0)
(750,253,0)
(436,778,0)
(254,57,0)
(742,240,0)
(614,1,0)
(556,642,0)
(606,498,0)
(15,722,0)
(212,251,0)
(409,375,0)
(301,717,0)
(771,406,0)
(427,646,0)
(768,146,0)
(373,373,0)
(540,113,0)
(93,2,0)
(760,229,0)
(174,85,0)
(731,160,0)
(317,689,0)
(86,407,0)
(825,285,0)
(614,594,0)
(664,169,0)
(816,880,0)
(141,879,0)
(476,879,0)
(739,736,0)
(243,240,0)
(277,601,0)
(534,587,0)
(575,211,0)
(542,424,0)
(676,91,0)
(377,531,0)
(867,519,0)
(480,119,0)
(459,194,0)
(491,175,0)
(745,15,0)
(279,533,0)
(409,861,0)
(171,248,0)
(354,702,0)
(250,97,0)
(217,795,0)
(310,186,0)
(99,654,0)
(102,414,0)
(142,717,0)
(614,459,0)
(761,152,0)
(364,364,0)
(149,46,0)
(408,208,0)
(303,91,0)
(409,671,0)
(665,253,0)
(702,406,0)
(493,15,0)
(215,405,0)
(276,573,0)
(787,796,0)
(83,618,0)
(384,296,0)
(770,762,0)
(658,867,0)
(432,598,0)
(513,648,0)
(776,750,0)
(560,264,0)
(393,21,0)
(320,863,0)
(878,240,0)
(473,717,0)
(294,25,0)
(456,276,0)
(614,467,0)
(758,421,0)
(788,784,0)
(755,159,0)
(444,548,0)
(718,703,0)
(166,401,0)
(9,654,0)
(751,778,0)
(211,9,0)
(152,625,0)
(262,339,0)
(67,511,0)
(561,8,0)
(345,537,0)
(326,285,0)
(90,253,0)
(829,8,0)
(414,253,0)
(364,406,0)
(290,304,0)
(883,823,0)
(509,605,0)
(784,253,0)
(635,855,0)
(504,406,0)
(722,240,0)
(154,58,0)
(791,524,0)
(514,158,0)
(198,240,0)
(355,223,0)
(152,655,0)
(561,119,0)
(2,91,0)
(587,534,0)
(409,865,0)
(86,414,0)
(30,240,0)
(236,405,0)
(86,253,0)
(501,828,0)
(627,406,0)
(621,518,0)
(346,385,0)
(678,393,0)
(471,540,0)
(266,614,0)
(755,797,0)
(600,561,0)
(211,186,0)
(467,818,0)
(284,514,0)
(256,96,0)
(27,775,0)
(184,498,0)
(632,422,0)
(229,698,0)
(532,677,0)
(854,211,0)
(850,285,0)
(91,863,0)
(581,166,0)
(211,575,0)
(760,474,0)
(850,618,0)
(276,276,0)
(642,285,0)
(808,598,0)
(347,445,0)
(370,214,0)
(232,736,0)
(616,721,0)
(627,797,0)
(336,169,0)
(716,215,0)
(113,46,0)
(177,529,0)
(264,560,0)
(688,766,0)
(524,158,0)
(558,158,0)
(190,279,0)
(94,406,0)
(264,91,0)
(409,684,0)
(738,514,0)
(360,91,0)
(661,331,0)
(761,656,0)
(368,456,0)
(39,377,0)
(456,155,0)
(814,662,0)
(481,113,0)
(165,333,0)
(702,159,0)
(440,52,0)
(47,560,0)
(394,864,0)
(621,523,0)
(58,517,0)
(895,515,0)
(286,10,0)
(318,91,0)
(409,202,0)
(605,17,0)
(799,15,0)
(707,412,0)
(766,535,0)
(308,734,0)
(708,773,0)
(750,412,0)
(750,414,0)
(649,535,0)
(517,218,0)
(460,773,0)
(21,393,0)
(549,676,0)
(307,296,0)
(300,793,0)
(812,283,0)
(378,582,0)
(478,852,0)
(858,640,0)
(504,364,0)
(327,659,0)
(583,474,0)
(832,275,0)
(729,240,0)
(689,317,0)
(479,421,0)
(694,307,0)
(638,651,0)
(618,83,0)
(53,588,0)
(425,885,0)
(795,217,0)
(194,240,0)
(387,406,0)
(102,122,0)
(612,734,0)
(127,240,0)
(734,795,0)
(671,91,0)
(312,193,0)
(271,333,0)
(755,793,0)
(813,225,0)
(327,507,0)
(353,422,0)
(560,60,0)
(330,665,0)
(151,142,0)
(250,314,0)
(755,304,0)
(169,664,0)
(341,6,0)
(449,746,0)
(62,773,0)
(607,733,0)
(149,158,0)
(739,601,0)
(409,711,0)
(465,253,0)
(807,592,0)
(280,423,0)
(709,177,0)
(189,285,0)
(564,387,0)
(278,1,0)
(756,408,0)
(666,231,0)
(487,534,0)
(609,246,0)
(258,719,0)
(463,594,0)
(432,21,0)
(4,418,0)
(526,671,0)
(853,667,0)
(103,94,0)
(256,35,0)
(363,763,0)
(755,711,0)
(124,837,0)
(130,113,0)
(89,14,0)
(605,553,0)
(428,779,0)
(761,736,0)
(372,240,0)
(474,364,0)
(121,481,0)
(724,110,0)
(576,422,0)
(340,264,0)
(275,766,0)
(230,498,0)
(288,91,0)
(241,606,0)
(837,405,0)
(577,747,0)
(460,548,0)
(409,537,0)
(24,184,0)
(120,695,0)
(44,733,0)
(835,578,0)
(735,565,0)
(118,651,0)
(258,523,0)
(397,158,0)
(831,864,0)
(409,135,0)
(48,834,0)
(477,264,0)
(755,891,0)
(592,1,0)
(345,406,0)
(205,158,0)
(519,461,0)
(722,193,0)
(458,2,0)
(677,406,0)
(298,253,0)
(506,97,0)
(574,612,0)
(588,405,0)
(83,91,0)
(96,256,0)
(323,540,0)
(719,46,0)
(23,364,0)
(146,403,0)
(21,841,0)
(531,377,0)
(136,316,0)
(85,208,0)
(304,232,0)
(705,592,0)
(557,83,0)
(9,211,0)
(158,240,0)
(740,559,0)
(735,393,0)
(604,623,0)
(823,5,0)
(579,548,0)
(301,301,0)
(79,645,0)
(719,511,0)
(313,318,0)
(817,90,0)
(170,832,0)
(822,197,0)
(691,534,0)
(25,1,0)
(775,285,0)
(755,760,0)
(303,85,0)
(275,717,0)
(842,561,0)
(175,204,0)
(588,746,0)
(374,375,0)
(409,476,0)
(188,339,0)
(260,113,0)
(732,710,0)
(762,91,0)
(397,46,0)
(795,8,0)
(766,301,0)
(761,186,0)
(640,858,0)
(885,406,0)
(755,423,0)
(423,364,0)
(737,71,0)
(137,834,0)
(152,73,0)
(771,672,0)
(615,811,0)
(72,240,0)
(396,818,0)
(171,542,0)
(857,240,0)
(451,169,0)
(828,253,0)
(814,367,0)
(501,456,0)
(629,253,0)
(115,773,0)
(837,542,0)
(297,874,0)
(538,94,0)
(393,678,0)
(216,71,0)
(796,1,0)
(104,240,0)
(316,296,0)
(723,428,0)
(376,406,0)
(665,405,0)
(848,627,0)
(15,777,0)
(134,91,0)
(861,406,0)
(183,149,0)
(869,717,0)
(383,625,0)
(852,213,0)
(592,459,0)
(239,301,0)
(755,94,0)
(752,303,0)
(397,169,0)
(562,698,0)
(409,532,0)
(686,463,0)
(63,172,0)
(560,489,0)
(542,171,0)
(655,152,0)
(263,635,0)
(755,100,0)
(409,797,0)
(94,115,0)
(831,698,0)
(110,283,0)
(265,91,0)
(588,253,0)
(882,244,0)
(810,612,0)
(800,771,0)
(210,601,0)
(765,463,0)
(449,91,0)
(375,62,0)
(793,91,0)
(384,489,0)
(714,256,0)
(6,341,0)
(513,540,0)
(664,406,0)
(164,418,0)
(894,384,0)
(60,225,0)
(57,655,0)
(695,301,0)
(208,567,0)
(781,285,0)
(702,364,0)
(573,717,0)
(182,703,0)
(445,285,0)
(540,46,0)
(231,666,0)
(529,177,0)
(755,603,0)
(163,232,0)
(145,265,0)
(206,303,0)
(585,240,0)
(229,646,0)
(195,130,0)
(97,250,0)
(178,91,0)
(681,775,0)
(527,304,0)
(270,240,0)
(728,326,0)
(864,592,0)
(375,406,0)
(114,240,0)
(801,5,0)
(273,841,0)
(595,642,0)
(422,353,0)
(56,749,0)
(667,285,0)
(881,223,0)
(140,115,0)
(620,852,0)
(666,155,0)
(388,736,0)
(862,406,0)
(820,863,0)
(167,432,0)
(855,654,0)
(648,364,0)
(610,131,0)
(651,424,0)
(819,539,0)
(265,6,0)
(12,310,0)
(62,513,0)
(155,666,0)
(409,159,0)
(515,111,0)
(520,283,0)
(456,501,0)
(212,713,0)
(135,91,0)
(259,587,0)
(87,258,0)
(353,90,0)
(504,865,0)
(16,150,0)
(531,276,0)
(492,240,0)
(201,91,0)
(80,543,0)
(781,217,0)
(582,285,0)
(245,480,0)
(282,411,0)
(601,739,0)
(13,4,0)
(292,91,0)
(235,217,0)
(346,722,0)
(179,665,0)
(532,621,0)
(629,296,0)
(409,603,0)
(215,253,0)
(639,434,0)
(861,460,0)
(517,58,0)
(48,523,0)
(868,808,0)
(353,667,0)
(8,795,0)
(488,446,0)
(626,194,0)
(64,240,0)
(149,594,0)
(278,459,0)
(316,405,0)
(208,85,0)
(703,406,0)
(422,306,0)
(421,665,0)
(166,581,0)
(381,345,0)
(151,844,0)
(406,223,0)
(8,240,0)
(755,135,0)
(502,74,0)
(125,763,0)
(624,306,0)
(755,582,0)
(173,664,0)
(863,820,0)
(484,504,0)
(803,850,0)
(565,405,0)
(409,136,0)
(750,186,0)
(213,498,0)
(856,91,0)
(321,608,0)
(474,406,0)
(346,171,0)
(322,244,0)
(367,814,0)
(377,208,0)
(218,57,0)
(553,231,0)
(122,102,0)
(4,274,0)
(665,414,0)
(148,669,0)
(704,788,0)
(507,717,0)
(448,665,0)
(409,830,0)
(418,757,0)
(187,226,0)
(287,240,0)
(230,283,0)
(546,327,0)
(365,609,0)
(589,376,0)
(684,885,0)
(356,135,0)
(58,489,0)
(390,175,0)
(554,327,0)
(648,62,0)
(201,210,0)
(382,466,0)
(232,498,0)
(846,828,0)
(178,813,0)
(207,856,0)
(387,364,0)
(642,6,0)
(295,240,0)
(845,74,0)
(283,498,0)
(843,594,0)
(684,121,0)
(172,90,0)
(516,288,0)
(719,158,0)
(189,142,0)
(749,364,0)
(369,711,0)
(855,635,0)
(537,345,0)
(409,74,0)
(119,317,0)
(140,387,0)
(628,870,0)
(551,146,0)
(214,422,0)
(813,178,0)
(481,121,0)
(715,152,0)
(861,364,0)
(510,646,0)
(736,569,0)
(112,808,0)
(879,414,0)
(862,364,0)
(772,648,0)
(871,91,0)
(766,464,0)
(656,761,0)
(100,376,0)
(10,186,0)
(677,532,0)
(215,35,0)
(226,659,0)
(424,651,0)
(461,519,0)
(501,426,0)
(662,814,0)
(91,240,0)
(361,71,0)
(785,326,0)
(22,230,0)
(703,364,0)
(609,594,0)
(465,445,0)
(395,558,0)
(434,91,0)
(426,501,0)
(836,276,0)
(775,618,0)
(152,86,0)
(98,861,0)
(838,626,0)
(457,279,0)
(469,181,0)
(86,152,0)
(823,400,0)
(755,375,0)
(856,400,0)
(409,331,0)
(367,91,0)
(884,710,0)
(677,364,0)
(676,665,0)
(646,113,0)
(636,750,0)
(75,213,0)
(821,761,0)
(521,341,0)
(879,498,0)
(251,212,0)
(332,883,0)
(219,722,0)
(548,672,0)
(450,215,0)
(683,245,0)
(224,339,0)
(319,615,0)
(176,95,0)
(844,151,0)
(736,186,0)
(524,436,0)
(411,248,0)
(720,218,0)
(119,480,0)
(496,645,0)
(755,852,0)
(57,218,0)
(780,698,0)
(711,629,0)
(101,676,0)
(52,307,0)
(9,431,0)
(301,464,0)
(876,717,0)
(408,285,0)
(885,364,0)
(117,448,0)
(10,166,0)
(401,787,0)
(480,245,0)
(833,346,0)
(645,543,0)
(536,52,0)
(598,841,0)
(380,240,0)
(618,567,0)
(793,334,0)
(396,463,0)
(563,747,0)
(437,897,0)
(242,677,0)
(157,823,0)
(446,10,0)
(513,864,0)
(407,86,0)
(76,91,0)
(409,793,0)
(0,689,0)
(228,298,0)
(416,558,0)
(58,762,0)
(448,91,0)
(33,278,0)
(113,113,0)
(446,285,0)
(641,385,0)
(419,230,0)
(467,614,0)
(456,745,0)
(533,279,0)
(578,855,0)
(519,867,0)
(1,757,0)
(503,200,0)
(333,472,0)
(147,665,0)
(409,100,0)
(462,830,0)
(511,511,0)
(106,414,0)
(700,861,0)
(159,467,0)
(482,375,0)
(665,421,0)
(109,832,0)
(139,160,0)
(230,398,0)
(615,135,0)
(834,46,0)
(307,736,0)
(779,459,0)
(227,446,0)
(428,285,0)
(617,409,0)
(252,275,0)
(289,672,0)
(456,573,0)
(481,8,0)
(231,553,0)
(874,736,0)
(110,498,0)
(627,364,0)
(339,864,0)
(530,781,0)
(653,184,0)
(222,609,0)
(78,481,0)
(672,773,0)
(5,35,0)
(113,774,0)
(301,275,0)
(412,591,0)
(373,90,0)
(633,150,0)
(55,364,0)
(755,537,0)
(358,594,0)
(514,113,0)
(566,659,0)
(350,364,0)
(897,422,0)
(54,387,0)
(162,102,0)
(784,689,0)
(41,189,0)
(276,777,0)
(423,451,0)
(867,733,0)
(255,566,0)
(105,713,0)
(637,829,0)
(353,373,0)
(464,736,0)
(373,306,0)
(414,236,0)
(406,745,0)
(870,292,0)
(317,278,0)
(15,15,0)
(403,188,0)
(609,8,0)
(237,739,0)
(194,177,0)
(487,148,0)
(376,100,0)
(513,672,0)
(325,518,0)
(70,397,0)
(73,814,0)
(601,240,0)
(257,91,0)
(268,828,0)
(640,405,0)
(409,760,0)
(193,722,0)
(779,428,0)
(357,156,0)
(4,729,0)
(376,364,0)
(126,464,0)
(494,400,0)
(458,405,0)
(605,489,0)
(486,498,0)
(796,459,0)
(665,676,0)
(403,146,0)
(261,310,0)
(171,346,0)
(839,83,0)
(60,458,0)
(209,398,0)
(315,476,0)
(689,507,0)
(409,304,0)
(592,113,0)
(379,588,0)
(631,134,0)
(465,401,0)
(763,659,0)
(119,561,0)
(377,285,0)
(888,777,0)
(697,834,0)
(196,49,0)
(880,285,0)
(225,813,0)
(778,8,0)
(451,773,0)
(122,274,0)
(7,507,0)
(385,208,0)
(197,659,0)
(531,531,0)
(508,476,0)
(140,864,0)
(463,396,0)
(755,476,0)
(497,735,0)
(292,615,0)
(553,605,0)
(558,148,0)
(66,311,0)
(216,489,0)
(128,862,0)
(410,353,0)
(434,204,0)
(885,684,0)
(401,465,0)
(305,373,0)
(612,285,0)
(592,864,0)
(584,793,0)
(348,736,0)
(456,531,0)
(792,49,0)
(825,3,0)
(299,350,0)
(226,240,0)
(850,36,0)
(667,353,0)
(215,414,0)
(873,608,0)
(138,513,0)
(582,208,0)
(847,331,0)
(166,10,0)
(217,781,0)
(400,856,0)
(199,445,0)
(298,88,0)
(712,535,0)
(531,223,0)
(814,73,0)
(400,823,0)
(34,288,0)
(204,434,0)
(68,575,0)
(689,784,0)
(593,511,0)
(665,736,0)
(665,448,0)
(409,852,0)
(655,288,0)
(398,230,0)
(69,831,0)
(203,200,0)
(100,48,0)
(387,140,0)
(96,91,0)
(755,202,0)
(279,489,0)
(387,115,0)
(248,171,0)
(794,529,0)
(540,8,0)
(456,15,0)
(331,91,0)
(424,581,0)
(401,166,0)
(603,749,0)
(328,245,0)
(635,285,0)
(782,481,0)
(442,459,0)
(733,285,0)
(877,897,0)
(169,451,0)
(746,588,0)
(824,459,0)
(94,364,0)
(60,560,0)
(204,296,0)
(604,422,0)
(547,813,0)
(748,178,0)
(470,626,0)
(19,240,0)
(146,364,0)
(385,285,0)
(385,346,0)
(541,739,0)
(615,793,0)
(522,423,0)
(447,678,0)
(646,46,0)
(122,310,0)
(499,256,0)
(690,248,0)
(148,487,0)
(678,91,0)
(468,21,0)
(193,318,0)
(169,672,0)
(762,58,0)
(38,151,0)
(364,608,0)
(713,91,0)
(663,715,0)
(146,406,0)
(788,285,0)
(481,46,0)
(408,276,0)
(553,405,0)
(130,140,0)
(307,186,0)
(755,52,0)
(17,605,0)
(20,136,0)
(32,204,0)
(880,461,0)
(597,442,0)
(236,414,0)
(184,283,0)
(834,511,0)
(433,142,0)
(654,855,0)
(269,575,0)
(218,517,0)
(302,695,0)
(830,606,0)
(552,598,0)
(409,94,0)
(829,669,0)
(140,672,0)
(406,155,0)
(692,134,0)
(844,480,0)
(496,409,0)
(533,160,0)
(192,458,0)
(87,350,0)
(533,314,0)
(232,186,0)
(248,414,0)
(687,428,0)
(866,22,0)
(402,25,0)
(344,96,0)
(855,578,0)
(715,91,0)
(406,15,0)
(750,489,0)
(183,818,0)
(625,435,0)
(787,669,0)
(784,414,0)
(802,201,0)
(875,113,0)
(514,562,0)
(889,448,0)
(210,499,0)
(581,424,0)
(309,17,0)
(805,829,0)
(348,134,0)
(409,423,0)
(753,406,0)
(310,736,0)
(562,514,0)
(415,874,0)
(160,91,0)
(349,837,0)
(392,411,0)
(495,397,0)
(338,755,0)
(675,573,0)
(874,88,0)
(864,608,0)
(375,364,0)
(149,183,0)
(92,830,0)
(797,246,0)
(196,91,0)
(196,615,0)
(129,240,0)
(665,240,0)
(350,406,0)
(3,36,0)
(668,614,0)
(458,60,0)
(755,532,0)
(654,9,0)
(424,542,0)
(35,215,0)
(142,189,0)
(115,140,0)
(755,74,0)
(71,91,0)
(445,465,0)
(50,298,0)
(90,414,0)
(470,150,0)
(859,1,0)
(727,408,0)
(14,111,0)
(456,777,0)
(318,193,0)
(399,130,0)
(635,618,0)
(213,489,0)
(701,22,0)
(135,156,0)
(851,648,0)
(348,489,0)
(693,337,0)
(26,240,0)
(815,240,0)
(156,489,0)
(463,46,0)
(540,513,0)
(651,736,0)
(316,405,1)
(653,24,1)
(538,672,1)
(140,672,1)
(85,303,1)
(672,771,1)
(613,417,1)
(251,212,1)
(301,464,1)
(605,17,1)
(445,347,1)
(88,298,1)
(703,364,1)
(766,464,1)
(784,414,1)
(577,511,1)
(218,720,1)
(846,268,1)
(540,8,1)
(763,363,1)
(721,616,1)
(384,489,1)
(210,601,1)
(788,285,1)
(652,164,1)
(278,459,1)
(46,767,1)
(755,423,1)
(340,477,1)
(195,399,1)
(415,297,1)
(702,406,1)
(504,406,1)
(610,537,1)
(747,563,1)
(204,175,1)
(146,406,1)
(800,362,1)
(579,861,1)
(278,33,1)
(572,356,1)
(688,252,1)
(205,225,1)
(310,736,1)
(547,571,1)
(347,199,1)
(704,840,1)
(189,65,1)
(594,142,1)
(409,603,1)
(93,267,1)
(276,408,1)
(245,158,1)
(675,507,1)
(755,338,1)
(755,331,1)
(320,76,1)
(252,573,1)
(14,89,1)
(877,113,1)
(755,760,1)
(237,277,1)
(540,46,1)
(689,507,1)
(215,716,1)
(542,837,1)
(755,304,1)
(654,155,1)
(169,82,1)
(162,4,1)
(272,255,1)
(702,364,1)
(36,3,1)
(671,602,1)
(458,2,1)
(514,46,1)
(660,888,1)
(879,253,1)
(361,737,1)
(796,1,1)
(868,112,1)
(456,155,1)
(183,149,1)
(130,113,1)
(814,367,1)
(232,736,1)
(669,829,1)
(836,456,1)
(44,607,1)
(719,46,1)
(850,618,1)
(173,699,1)
(862,364,1)
(756,727,1)
(547,499,1)
(798,531,1)
(635,618,1)
(323,375,1)
(214,370,1)
(274,4,1)
(346,833,1)
(755,375,1)
(196,615,1)
(577,442,1)
(768,339,1)
(122,310,1)
(408,208,1)
(632,172,1)
(695,302,1)
(211,186,1)
(370,780,1)
(226,659,1)
(532,677,1)
(606,405,1)
(495,70,1)
(298,253,1)
(15,722,1)
(531,276,1)
(25,459,1)
(463,46,1)
(2,91,1)
(158,519,1)
(558,158,1)
(152,761,1)
(178,91,1)
(151,142,1)
(353,90,1)
(734,612,1)
(385,455,1)
(169,864,1)
(795,734,1)
(290,527,1)
(256,96,1)
(326,285,1)
(152,73,1)
(102,404,1)
(375,364,1)
(29,860,1)
(592,1,1)
(724,230,1)
(707,628,1)
(837,405,1)
(755,135,1)
(160,731,1)
(456,15,1)
(806,790,1)
(700,62,1)
(116,636,1)
(812,520,1)
(46,573,1)
(647,634,1)
(540,471,1)
(457,250,1)
(316,37,1)
(644,25,1)
(509,257,1)
(593,604,1)
(192,560,1)
(689,784,1)
(770,154,1)
(386,187,1)
(398,91,1)
(212,713,1)
(792,196,1)
(467,614,1)
(601,739,1)
(318,91,1)
(540,113,1)
(202,862,1)
(119,561,1)
(665,405,1)
(719,161,1)
(25,402,1)
(699,336,1)
(345,406,1)
(265,91,1)
(275,766,1)
(692,631,1)
(449,806,1)
(422,353,1)
(117,889,1)
(524,158,1)
(455,641,1)
(622,796,1)
(16,633,1)
(887,90,1)
(28,660,1)
(236,405,1)
(714,601,1)
(750,489,1)
(784,788,1)
(210,201,1)
(39,59,1)
(707,360,1)
(464,186,1)
(442,459,1)
(299,621,1)
(327,554,1)
(120,464,1)
(739,489,1)
(480,245,1)
(587,285,1)
(598,432,1)
(860,615,1)
(745,15,1)
(409,375,1)
(808,598,1)
(470,150,1)
(49,792,1)
(665,489,1)
(456,745,1)
(302,120,1)
(428,285,1)
(4,13,1)
(666,257,1)
(755,852,1)
(781,285,1)
(67,593,1)
(423,406,1)
(755,476,1)
(784,253,1)
(378,233,1)
(866,184,1)
(625,435,1)
(168,239,1)
(232,186,1)
(300,225,1)
(655,288,1)
(401,465,1)
(890,313,1)
(301,275,1)
(366,351,1)
(167,586,1)
(548,444,1)
(728,635,1)
(515,472,1)
(750,736,1)
(147,330,1)
(822,221,1)
(762,91,1)
(377,441,1)
(885,364,1)
(154,288,1)
(896,384,1)
(584,300,1)
(736,186,1)
(443,770,1)
(685,209,1)
(545,625,1)
(409,159,1)
(387,115,1)
(633,626,1)
(279,186,1)
(765,686,1)
(831,69,1)
(648,364,1)
(778,8,1)
(409,865,1)
(718,121,1)
(884,337,1)
(739,736,1)
(49,196,1)
(576,422,1)
(409,202,1)
(787,401,1)
(446,227,1)
(414,253,1)
(367,872,1)
(797,627,1)
(755,684,1)
(481,46,1)
(98,700,1)
(86,414,1)
(626,194,1)
(73,420,1)
(882,747,1)
(134,91,1)
(0,784,1)
(179,679,1)
(470,626,1)
(25,1,1)
(676,91,1)
(847,661,1)
(35,215,1)
(755,136,1)
(391,256,1)
(430,470,1)
(678,91,1)
(453,487,1)
(612,285,1)
(834,8,1)
(406,745,1)
(746,449,1)
(604,422,1)
(832,275,1)
(18,88,1)
(108,216,1)
(81,106,1)
(265,590,1)
(121,481,1)
(665,414,1)
(531,531,1)
(687,723,1)
(719,511,1)
(834,511,1)
(651,638,1)
(458,405,1)
(255,424,1)
(755,865,1)
(221,680,1)
(839,557,1)
(664,173,1)
(566,272,1)
(62,513,1)
(406,753,1)
(397,158,1)
(548,672,1)
(831,864,1)
(627,364,1)
(206,582,1)
(399,94,1)
(307,186,1)
(750,186,1)
(409,537,1)
(145,642,1)
(353,373,1)
(520,197,1)
(761,656,1)
(808,868,1)
(654,855,1)
(824,470,1)
(432,167,1)
(763,659,1)
(581,424,1)
(197,822,1)
(338,671,1)
(544,467,1)
(212,827,1)
(344,454,1)
(235,781,1)
(318,890,1)
(53,212,1)
(231,553,1)
(110,724,1)
(408,756,1)
(737,483,1)
(10,446,1)
(456,501,1)
(771,460,1)
(385,285,1)
(707,755,1)
(889,421,1)
(194,177,1)
(150,194,1)
(90,253,1)
(409,52,1)
(552,21,1)
(849,442,1)
(707,191,1)
(571,883,1)
(782,684,1)
(152,640,1)
(637,805,1)
(626,31,1)
(594,46,1)
(723,824,1)
(527,879,1)
(215,405,1)
(421,758,1)
(267,192,1)
(665,448,1)
(872,886,1)
(58,762,1)
(512,307,1)
(469,801,1)
(605,489,1)
(397,113,1)
(406,15,1)
(152,715,1)
(216,489,1)
(504,484,1)
(248,414,1)
(94,364,1)
(583,188,1)
(514,158,1)
(188,403,1)
(95,176,1)
(409,423,1)
(848,183,1)
(628,870,1)
(703,406,1)
(615,793,1)
(46,276,1)
(785,728,1)
(101,750,1)
(217,235,1)
(351,603,1)
(172,373,1)
(180,292,1)
(137,697,1)
(776,116,1)
(353,667,1)
(779,428,1)
(292,804,1)
(843,576,1)
(760,474,1)
(55,107,1)
(120,832,1)
(23,55,1)
(749,364,1)
(97,91,1)
(897,437,1)
(462,92,1)
(852,478,1)
(74,845,1)
(187,91,1)
(423,522,1)
(130,46,1)
(755,861,1)
(393,678,1)
(58,489,1)
(614,1,1)
(416,395,1)
(384,894,1)
(526,95,1)
(660,745,1)
(424,542,1)
(217,781,1)
(135,91,1)
(894,74,1)
(750,413,1)
(258,719,1)
(691,587,1)
(91,863,1)
(345,381,1)
(343,131,1)
(205,156,1)
(620,606,1)
(228,736,1)
(733,44,1)
(716,450,1)
(88,874,1)
(745,745,1)
(745,439,1)
(409,94,1)
(4,729,1)
(440,536,1)
(156,489,1)
(57,218,1)
(310,186,1)
(305,673,1)
(496,645,1)
(171,346,1)
(128,337,1)
(638,118,1)
(755,603,1)
(413,776,1)
(791,674,1)
(446,285,1)
(317,278,1)
(409,797,1)
(739,186,1)
(216,71,1)
(542,171,1)
(113,142,1)
(428,687,1)
(22,91,1)
(592,705,1)
(752,206,1)
(345,364,1)
(676,549,1)
(536,629,1)
(264,340,1)
(403,146,1)
(838,194,1)
(674,459,1)
(140,387,1)
(705,807,1)
(260,875,1)
(480,119,1)
(383,640,1)
(451,169,1)
(364,406,1)
(886,754,1)
(314,250,1)
(400,856,1)
(118,10,1)
(298,50,1)
(289,107,1)
(441,39,1)
(213,489,1)
(875,214,1)
(786,711,1)
(131,610,1)
(89,333,1)
(249,675,1)
(99,487,1)
(160,91,1)
(487,534,1)
(172,90,1)
(188,339,1)
(887,884,1)
(193,318,1)
(796,459,1)
(15,493,1)
(813,489,1)
(152,625,1)
(709,529,1)
(639,32,1)
(176,598,1)
(592,113,1)
(226,386,1)
(897,422,1)
(684,885,1)
(409,304,1)
(31,613,1)
(863,320,1)
(640,405,1)
(163,304,1)
(456,276,1)
(695,301,1)
(588,405,1)
(854,855,1)
(578,835,1)
(582,285,1)
(663,110,1)
(97,506,1)
(634,829,1)
(727,836,1)
(828,846,1)
(816,205,1)
(136,20,1)
(445,285,1)
(71,91,1)
(326,785,1)
(646,113,1)
(209,419,1)
(826,309,1)
(6,265,1)
(582,378,1)
(597,429,1)
(436,778,1)
(754,655,1)
(390,491,1)
(590,145,1)
(471,323,1)
(178,892,1)
(615,582,1)
(113,46,1)
(755,94,1)
(482,374,1)
(308,612,1)
(501,426,1)
(113,260,1)
(629,786,1)
(755,100,1)
(123,447,1)
(775,681,1)
(166,581,1)
(334,405,1)
(460,548,1)
(830,462,1)
(418,652,1)
(491,434,1)
(855,635,1)
(646,46,1)
(865,504,1)
(657,130,1)
(442,1,1)
(557,775,1)
(71,361,1)
(107,188,1)
(288,91,1)
(82,664,1)
(204,32,1)
(828,253,1)
(864,592,1)
(140,864,1)
(151,38,1)
(1,859,1)
(218,517,1)
(533,279,1)
(817,238,1)
(149,366,1)
(859,430,1)
(140,130,1)
(276,531,1)
(17,826,1)
(332,823,1)
(57,254,1)
(674,418,1)
(135,572,1)
(197,659,1)
(307,736,1)
(758,479,1)
(508,213,1)
(518,325,1)
(438,278,1)
(522,280,1)
(450,18,1)
(387,364,1)
(565,216,1)
(155,666,1)
(851,696,1)
(759,553,1)
(504,364,1)
(166,10,1)
(15,15,1)
(518,511,1)
(2,93,1)
(511,67,1)
(629,414,1)
(12,102,1)
(615,319,1)
(616,88,1)
(169,664,1)
(219,155,1)
(259,722,1)
(325,783,1)
(487,148,1)
(208,85,1)
(376,589,1)
(892,748,1)
(513,540,1)
(525,97,1)
(747,422,1)
(189,285,1)
(139,279,1)
(779,769,1)
(510,760,1)
(96,344,1)
(629,253,1)
(837,124,1)
(879,141,1)
(829,8,1)
(835,326,1)
(448,117,1)
(352,134,1)
(588,253,1)
(535,285,1)
(646,427,1)
(110,283,1)
(560,489,1)
(750,405,1)
(239,275,1)
(335,191,1)
(885,406,1)
(517,58,1)
(172,63,1)
(828,414,1)
(47,813,1)
(159,702,1)
(844,480,1)
(548,864,1)
(750,253,1)
(153,895,1)
(282,690,1)
(276,573,1)
(631,388,1)
(224,864,1)
(874,415,1)
(337,422,1)
(177,529,1)
(387,54,1)
(863,670,1)
(412,91,1)
(788,704,1)
(559,740,1)
(381,48,1)
(15,155,1)
(853,580,1)
(475,816,1)
(432,21,1)
(20,706,1)
(592,46,1)
(753,682,1)
(434,91,1)
(553,528,1)
(185,132,1)
(429,46,1)
(70,423,1)
(246,609,1)
(329,87,1)
(303,91,1)
(106,251,1)
(483,678,1)
(420,814,1)
(625,383,1)
(496,721,1)
(736,348,1)
(330,179,1)
(245,683,1)
(439,798,1)
(141,476,1)
(279,489,1)
(161,329,1)
(149,46,1)
(337,293,1)
(11,524,1)
(519,461,1)
(640,858,1)
(100,376,1)
(357,135,1)
(744,639,1)
(409,135,1)
(146,551,1)
(409,182,1)
(436,524,1)
(5,35,1)
(350,406,1)
(392,282,1)
(262,224,1)
(341,6,1)
(201,91,1)
(823,5,1)
(276,276,1)
(778,751,1)
(174,303,1)
(696,540,1)
(364,23,1)
(769,428,1)
(156,357,1)
(574,43,1)
(251,746,1)
(895,743,1)
(130,195,1)
(346,385,1)
(92,283,1)
(14,472,1)
(500,832,1)
(294,274,1)
(363,125,1)
(787,796,1)
(359,29,1)
(783,532,1)
(3,630,1)
(75,852,1)
(13,204,1)
(3,825,1)
(132,8,1)
(52,440,1)
(184,283,1)
(83,839,1)
(214,422,1)
(749,406,1)
(874,186,1)
(755,159,1)
(96,91,1)
(409,87,1)
(377,285,1)
(138,648,1)
(86,545,1)
(524,791,1)
(348,134,1)
(310,261,1)
(481,8,1)
(375,406,1)
(587,893,1)
(32,512,1)
(48,834,1)
(501,828,1)
(40,793,1)
(79,333,1)
(31,285,1)
(301,301,1)
(257,359,1)
(474,364,1)
(529,794,1)
(368,844,1)
(614,459,1)
(409,684,1)
(283,812,1)
(595,556,1)
(825,77,1)
(755,537,1)
(122,102,1)
(409,830,1)
(465,445,1)
(313,219,1)
(513,138,1)
(51,81,1)
(861,364,1)
(618,83,1)
(827,713,1)
(887,897,1)
(880,475,1)
(867,733,1)
(112,176,1)
(393,735,1)
(507,327,1)
(373,90,1)
(377,208,1)
(478,620,1)
(394,897,1)
(95,808,1)
(350,364,1)
(678,123,1)
(50,228,1)
(376,364,1)
(667,285,1)
(735,565,1)
(34,516,1)
(805,558,1)
(461,880,1)
(175,390,1)
(417,838,1)
(17,91,1)
(771,406,1)
(679,676,1)
(303,752,1)
(499,256,1)
(648,406,1)
(534,587,1)
(834,46,1)
(693,594,1)
(94,103,1)
(564,657,1)
(861,406,1)
(437,877,1)
(722,193,1)
(266,668,1)
(143,561,1)
(230,283,1)
(649,688,1)
(829,637,1)
(796,647,1)
(181,91,1)
(339,262,1)
(669,787,1)
(409,476,1)
(307,694,1)
(298,414,1)
(225,813,1)
(807,394,1)
(668,159,1)
(733,285,1)
(90,414,1)
(680,695,1)
(511,46,1)
(746,588,1)
(645,79,1)
(238,406,1)
(801,157,1)
(37,136,1)
(247,871,1)
(888,15,1)
(877,849,1)
(94,406,1)
(663,197,1)
(654,9,1)
(459,779,1)
(537,345,1)
(211,736,1)
(42,715,1)
(734,308,1)
(484,229,1)
(375,482,1)
(409,582,1)
(46,531,1)
(103,538,1)
(642,595,1)
(271,883,1)
(232,163,1)
(191,49,1)
(27,571,1)
(63,887,1)
(411,392,1)
(59,172,1)
(883,823,1)
(651,736,1)
(755,711,1)
(711,369,1)
(465,414,1)
(315,508,1)
(745,722,1)
(113,113,1)
(712,649,1)
(755,202,1)
(561,8,1)
(36,850,1)
(870,292,1)
(517,599,1)
(274,122,1)
(614,594,1)
(170,109,1)
(95,598,1)
(771,800,1)
(823,91,1)
(497,565,1)
(9,431,1)
(477,47,1)
(505,663,1)
(871,91,1)
(599,58,1)
(530,45,1)
(513,864,1)
(55,460,1)
(148,669,1)
(360,335,1)
(309,509,1)
(677,406,1)
(775,285,1)
(844,151,1)
(799,276,1)
(404,162,1)
(609,222,1)
(521,499,1)
(348,489,1)
(502,316,1)
(442,597,1)
(228,314,1)
(516,761,1)
(863,820,1)
(740,232,1)
(149,594,1)
(109,28,1)
(772,851,1)
(661,436,1)
(879,414,1)
(54,564,1)
(713,91,1)
(425,562,1)
(581,566,1)
(617,665,1)
(677,242,1)
(165,271,1)
(641,248,1)
(755,797,1)
(651,186,1)
(444,579,1)
(821,86,1)
(409,331,1)
(664,364,1)
(780,831,1)
(666,231,1)
(257,91,1)
(549,101,1)
(592,459,1)
(402,294,1)
(575,253,1)
(348,352,1)
(152,655,1)
(56,396,1)
(148,558,1)
(665,186,1)
(109,301,1)
(412,591,1)
(278,1,1)
(77,550,1)
(842,245,1)
(729,763,1)
(83,91,1)
(350,299,1)
(814,662,1)
(264,91,1)
(614,46,1)
(880,285,1)
(60,458,1)
(396,463,1)
(514,284,1)
(665,676,1)
(15,745,1)
(726,469,1)
(65,41,1)
(339,864,1)
(531,377,1)
(609,8,1)
(755,74,1)
(164,1,1)
(102,414,1)
(809,880,1)
(575,269,1)
(69,182,1)
(513,648,1)
(694,52,1)
(268,596,1)
(181,726,1)
(421,91,1)
(5,181,1)
(547,208,1)
(755,87,1)
(693,849,1)
(565,108,1)
(681,27,1)
(766,535,1)
(464,736,1)
(333,165,1)
(41,433,1)
(395,534,1)
(409,617,1)
(667,853,1)
(565,405,1)
(697,100,1)
(87,350,1)
(463,765,1)
(560,264,1)
(474,583,1)
(346,722,1)
(373,373,1)
(409,852,1)
(488,286,1)
(665,253,1)
(409,711,1)
(566,659,1)
(385,208,1)
(215,414,1)
(269,68,1)
(373,422,1)
(713,730,1)
(715,91,1)
(871,51,1)
(562,514,1)
(640,42,1)
(561,600,1)
(76,729,1)
(284,738,1)
(119,317,1)
(627,406,1)
(750,412,1)
(743,14,1)
(621,518,1)
(199,622,1)
(474,406,1)
(715,505,1)
(870,180,1)
(541,237,1)
(254,218,1)
(43,158,1)
(242,747,1)
(609,46,1)
(196,91,1)
(231,759,1)
(665,421,1)
(184,559,1)
(10,186,1)
(682,844,1)
(38,500,1)
(850,285,1)
(832,170,1)
(236,247,1)
(115,140,1)
(169,397,1)
(771,364,1)
(519,867,1)
(741,373,1)
(793,584,1)
(317,689,1)
(146,364,1)
(609,594,1)
(280,115,1)
(297,298,1)
(374,451,1)
(10,736,1)
(263,342,1)
(409,775,1)
(171,248,1)
(664,406,1)
(793,91,1)
(520,66,1)
(7,142,1)
(102,253,1)
(789,387,1)
(690,837,1)
(594,594,1)
(648,772,1)
(225,60,1)
(304,290,1)
(191,25,1)
(134,692,1)
(456,531,1)
(360,91,1)
(409,100,1)
(834,137,1)
(833,385,1)
(576,544,1)
(358,843,1)
(230,398,1)
(213,75,1)
(373,305,1)
(256,35,1)
(862,406,1)
(706,680,1)
(13,152,1)
(790,588,1)
(463,594,1)
(658,733,1)
(642,285,1)
(211,575,1)
(589,258,1)
(664,451,1)
(535,712,1)
(409,74,1)
(580,410,1)
(810,574,1)
(24,559,1)
(401,166,1)
(531,573,1)
(279,190,1)
(594,358,1)
(563,577,1)
(367,91,1)
(6,642,1)
(511,511,1)
(376,406,1)
(603,749,1)
(619,274,1)
(248,253,1)
(518,46,1)
(673,422,1)
(456,573,1)
(142,189,1)
(85,174,1)
(319,331,1)
(795,217,1)
(751,11,1)
(68,854,1)
(738,865,1)
(21,393,1)
(78,782,1)
(533,160,1)
(150,16,1)
(204,434,1)
(862,128,1)
(314,533,1)
(695,464,1)
(748,547,1)
(845,502,1)
(883,332,1)
(550,850,1)
(125,650,1)
(230,22,1)
(408,285,1)
(493,799,1)
(739,541,1)
(293,693,1)
(683,328,1)
(60,560,1)
(648,62,1)
(409,136,1)
(126,453,1)
(409,760,1)
(546,7,1)
(175,91,1)
(893,259,1)
(250,97,1)
(755,793,1)
(627,848,1)
(222,365,1)
(349,651,1)
(745,155,1)
(600,842,1)
(496,409,1)
(409,671,1)
(423,364,1)
(412,707,1)
(277,35,1)
(602,526,1)
(689,0,1)
(755,182,1)
(635,285,1)
(513,672,1)
(604,343,1)
(90,817,1)
(152,86,1)
(514,113,1)
(411,91,1)
(292,91,1)
(804,619,1)
(433,695,1)
(400,601,1)
(517,405,1)
(86,407,1)
(261,12,1)
(45,734,1)
(735,497,1)
(481,78,1)
(781,530,1)
(855,578,1)
(750,414,1)
(434,744,1)
(356,334,1)
(887,882,1)
(79,515,1)
(8,795,1)
(419,22,1)
(461,809,1)
(227,488,1)
(4,418,1)
(553,605,1)
(612,810,1)
(336,397,1)
(767,741,1)
(606,241,1)
(575,414,1)
(596,368,1)
(157,341,1)
(686,202,1)
(464,126,1)
(124,349,1)
(201,371,1)
(702,354,1)
(105,226,1)
(719,158,1)
(499,210,1)
(301,168,1)
(333,472,1)
(207,281,1)
(761,736,1)
(755,52,1)
(511,142,1)
(553,405,1)
(479,147,1)
(677,364,1)
(614,266,1)
(9,211,1)
(762,443,1)
(558,416,1)
(233,618,1)
(248,411,1)
(146,460,1)
(534,691,1)
(452,251,1)
(860,436,1)
(387,406,1)
(885,425,1)
(22,701,1)
(761,821,1)
(766,301,1)
(397,46,1)
(755,830,1)
(331,91,1)
(481,113,1)
(409,793,1)
(671,91,1)
(193,312,1)
(856,91,1)
(427,510,1)
(241,830,1)
(840,438,1)
(755,775,1)
(66,654,1)
(379,53,1)
(720,517,1)
(424,651,1)
(607,461,1)
(556,521,1)
(615,775,1)
(861,98,1)
(196,555,1)
(281,494,1)
(755,582,1)
(867,658,1)
(250,525,1)
(328,151,1)
(229,646,1)
(529,285,1)
(286,465,1)
(86,253,1)
(586,552,1)
(334,40,1)
(364,364,1)
(874,736,1)
(365,797,1)
(369,896,1)
(362,289,1)
(149,158,1)
(465,253,1)
(823,400,1)
(813,178,1)
(707,95,1)
(476,315,1)
(448,91,1)
(856,207,1)
(397,495,1)
(184,653,1)
(625,489,1)
(803,249,1)
(449,91,1)
(331,847,1)
(140,789,1)
(215,253,1)
(182,703,1)
(459,194,1)
(452,414,1)
(409,861,1)
(169,672,1)
(342,99,1)
(703,718,1)
(327,659,1)
(794,185,1)
(73,814,1)
(454,714,1)
(312,318,1)
(578,326,1)
(447,468,1)
(528,605,1)
(515,153,1)
(494,5,1)
(755,532,1)
(701,866,1)
(388,314,1)
(731,139,1)
(410,632,1)
(655,57,1)
(635,263,1)
(371,802,1)
(551,768,1)
(28,275,1)
(730,105,1)
(615,135,1)
(33,143,1)
(573,36,1)
(292,615,1)
(636,412,1)
(802,391,1)
(406,155,1)
(236,871,1)
(409,532,1)
(370,364,1)
(749,56,1)
(825,285,1)
(665,736,1)
(177,709,1)
(554,546,1)
(468,628,1)
(588,379,1)
(555,644,1)
(354,246,1)
(850,803,1)
(506,452,1)
(761,186,1)
(190,457,1)
(288,34,1)
(398,685,1)
(414,236,1)
(630,825,1)
(531,573,2)
(890,499,2)
(481,113,2)
(897,849,2)
(784,253,2)
(476,487,2)
(31,883,2)
(839,571,2)
(685,487,2)
(346,248,2)
(32,680,2)
(332,499,2)
(665,499,2)
(465,414,2)
(108,628,2)
(132,883,2)
(684,885,2)
(314,250,2)
(396,463,2)
(315,197,2)
(397,46,2)
(39,844,2)
(677,406,2)
(832,832,2)
(284,188,2)
(755,52,2)
(874,298,2)
(411,91,2)
(547,499,2)
(301,275,2)
(514,46,2)
(724,197,2)
(755,423,2)
(651,10,2)
(561,245,2)
(409,760,2)
(412,591,2)
(699,107,2)
(736,186,2)
(52,680,2)
(179,499,2)
(201,91,2)
(524,883,2)
(851,107,2)
(516,680,2)
(230,197,2)
(15,745,2)
(817,844,2)
(516,487,2)
(753,844,2)
(442,172,2)
(607,883,2)
(889,499,2)
(179,883,2)
(60,813,2)
(703,364,2)
(772,107,2)
(574,883,2)
(399,107,2)
(515,472,2)
(870,274,2)
(664,107,2)
(249,695,2)
(496,645,2)
(756,844,2)
(665,676,2)
(398,91,2)
(674,499,2)
(755,135,2)
(128,337,2)
(141,487,2)
(546,695,2)
(339,897,2)
(160,250,2)
(755,797,2)
(707,883,2)
(761,736,2)
(155,666,2)
(823,400,2)
(734,883,2)
(810,499,2)
(695,487,2)
(107,188,2)
(749,364,2)
(406,155,2)
(373,422,2)
(836,844,2)
(184,559,2)
(387,107,2)
(433,695,2)
(509,883,2)
(592,897,2)
(469,499,2)
(855,578,2)
(379,212,2)
(102,414,2)
(593,747,2)
(87,350,2)
(705,897,2)
(648,364,2)
(709,499,2)
(640,680,2)
(49,196,2)
(130,46,2)
(181,499,2)
(15,722,2)
(605,17,2)
(208,85,2)
(602,95,2)
(185,883,2)
(581,566,2)
(73,487,2)
(211,487,2)
(451,169,2)
(255,424,2)
(562,188,2)
(849,442,2)
(844,151,2)
(609,337,2)
(745,745,2)
(534,883,2)
(755,202,2)
(553,605,2)
(707,499,2)
(479,499,2)
(763,659,2)
(170,695,2)
(276,276,2)
(122,310,2)
(350,406,2)
(879,253,2)
(140,387,2)
(755,532,2)
(481,46,2)
(134,91,2)
(600,245,2)
(518,511,2)
(373,172,2)
(796,1,2)
(866,197,2)
(592,113,2)
(409,582,2)
(459,470,2)
(663,487,2)
(432,628,2)
(409,852,2)
(458,560,2)
(60,560,2)
(292,274,2)
(511,511,2)
(487,148,2)
(231,553,2)
(563,442,2)
(627,337,2)
(3,825,2)
(733,883,2)
(783,747,2)
(559,197,2)
(251,746,2)
(558,158,2)
(46,172,2)
(204,175,2)
(236,251,2)
(303,571,2)
(318,91,2)
(513,540,2)
(745,722,2)
(87,747,2)
(789,107,2)
(695,695,2)
(553,499,2)
(752,571,2)
(828,253,2)
(665,414,2)
(850,285,2)
(795,217,2)
(532,677,2)
(55,188,2)
(509,499,2)
(835,487,2)
(508,197,2)
(122,4,2)
(9,487,2)
(887,172,2)
(34,487,2)
(804,274,2)
(353,667,2)
(613,883,2)
(367,91,2)
(882,442,2)
(190,250,2)
(293,849,2)
(292,91,2)
(663,680,2)
(734,612,2)
(27,571,2)
(204,32,2)
(719,747,2)
(823,499,2)
(113,46,2)
(10,446,2)
(497,628,2)
(330,883,2)
(552,628,2)
(548,864,2)
(309,883,2)
(268,844,2)
(346,722,2)
(152,715,2)
(376,364,2)
(812,487,2)
(400,601,2)
(260,897,2)
(559,487,2)
(232,197,2)
(387,115,2)
(607,499,2)
(205,883,2)
(872,487,2)
(344,88,2)
(152,86,2)
(743,333,2)
(755,304,2)
(770,487,2)
(130,107,2)
(277,88,2)
(149,594,2)
(411,837,2)
(4,418,2)
(436,524,2)
(766,464,2)
(288,487,2)
(784,788,2)
(409,375,2)
(257,91,2)
(156,225,2)
(94,107,2)
(504,364,2)
(524,158,2)
(236,871,2)
(665,405,2)
(460,107,2)
(448,499,2)
(456,501,2)
(865,188,2)
(397,113,2)
(771,460,2)
(860,883,2)
(142,695,2)
(340,813,2)
(429,172,2)
(678,91,2)
(642,285,2)
(501,828,2)
(755,711,2)
(288,91,2)
(246,609,2)
(776,883,2)
(733,499,2)
(682,844,2)
(614,1,2)
(113,142,2)
(554,695,2)
(666,883,2)
(592,459,2)
(530,499,2)
(653,197,2)
(816,499,2)
(327,659,2)
(892,883,2)
(302,487,2)
(613,499,2)
(621,518,2)
(759,883,2)
(37,680,2)
(371,256,2)
(409,87,2)
(418,470,2)
(442,459,2)
(140,864,2)
(69,188,2)
(532,747,2)
(478,487,2)
(167,628,2)
(409,159,2)
(494,499,2)
(750,253,2)
(661,436,2)
(209,197,2)
(419,197,2)
(25,459,2)
(331,436,2)
(188,339,2)
(266,337,2)
(412,91,2)
(606,487,2)
(96,88,2)
(673,172,2)
(755,182,2)
(8,499,2)
(430,470,2)
(565,405,2)
(751,524,2)
(409,182,2)
(601,88,2)
(646,113,2)
(213,197,2)
(556,499,2)
(576,337,2)
(622,796,2)
(195,107,2)
(202,862,2)
(299,747,2)
(117,499,2)
(874,736,2)
(463,46,2)
(146,339,2)
(13,883,2)
(362,107,2)
(409,74,2)
(459,779,2)
(95,598,2)
(414,236,2)
(288,680,2)
(8,883,2)
(166,581,2)
(276,573,2)
(814,487,2)
(149,46,2)
(669,558,2)
(508,487,2)
(781,285,2)
(540,8,2)
(351,337,2)
(139,250,2)
(278,459,2)
(34,680,2)
(761,487,2)
(689,507,2)
(537,747,2)
(89,333,2)
(610,747,2)
(844,480,2)
(307,680,2)
(148,534,2)
(599,680,2)
(215,414,2)
(897,422,2)
(414,253,2)
(755,331,2)
(582,285,2)
(385,208,2)
(40,225,2)
(843,337,2)
(741,172,2)
(400,856,2)
(404,4,2)
(614,594,2)
(793,225,2)
(152,655,2)
(221,680,2)
(110,487,2)
(762,487,2)
(215,405,2)
(750,412,2)
(747,747,2)
(428,470,2)
(231,499,2)
(409,775,2)
(48,834,2)
(888,844,2)
(574,499,2)
(562,514,2)
(745,844,2)
(15,844,2)
(755,159,2)
(889,883,2)
(514,188,2)
(621,747,2)
(830,487,2)
(184,283,2)
(726,499,2)
(676,883,2)
(784,414,2)
(581,424,2)
(258,719,2)
(615,793,2)
(43,883,2)
(792,25,2)
(755,537,2)
(768,339,2)
(519,883,2)
(551,339,2)
(797,627,2)
(890,883,2)
(702,337,2)
(596,844,2)
(119,245,2)
(259,883,2)
(616,88,2)
(754,680,2)
(679,883,2)
(441,844,2)
(690,837,2)
(265,91,2)
(140,107,2)
(102,4,2)
(417,499,2)
(524,499,2)
(436,499,2)
(782,188,2)
(617,499,2)
(629,680,2)
(232,487,2)
(522,107,2)
(47,813,2)
(121,188,2)
(18,88,2)
(341,6,2)
(383,680,2)
(672,771,2)
(140,130,2)
(225,60,2)
(85,303,2)
(739,736,2)
(374,107,2)
(780,188,2)
(440,680,2)
(180,274,2)
(22,197,2)
(755,476,2)
(454,88,2)
(360,91,2)
(810,883,2)
(755,94,2)
(28,275,2)
(867,499,2)
(866,487,2)
(481,188,2)
(887,844,2)
(594,337,2)
(814,680,2)
(695,464,2)
(215,88,2)
(22,91,2)
(458,405,2)
(326,285,2)
(172,844,2)
(436,883,2)
(813,178,2)
(618,571,2)
(346,385,2)
(794,499,2)
(181,91,2)
(614,337,2)
(188,897,2)
(20,680,2)
(147,499,2)
(566,659,2)
(513,648,2)
(746,212,2)
(801,499,2)
(636,883,2)
(520,197,2)
(161,747,2)
(715,680,2)
(862,337,2)
(75,197,2)
(157,499,2)
(366,337,2)
(182,188,2)
(110,283,2)
(514,158,2)
(178,883,2)
(15,15,2)
(749,337,2)
(697,747,2)
(453,487,2)
(310,102,2)
(370,897,2)
(456,573,2)
(275,766,2)
(771,406,2)
(239,695,2)
(535,285,2)
(393,735,2)
(795,883,2)
(410,172,2)
(384,489,2)
(540,107,2)
(696,107,2)
(586,628,2)
(533,279,2)
(358,337,2)
(409,304,2)
(606,197,2)
(83,91,2)
(491,680,2)
(364,364,2)
(733,285,2)
(456,276,2)
(626,883,2)
(256,96,2)
(337,337,2)
(409,100,2)
(218,517,2)
(6,265,2)
(745,155,2)
(5,181,2)
(612,499,2)
(755,852,2)
(488,465,2)
(163,197,2)
(392,837,2)
(165,883,2)
(169,864,2)
(43,499,2)
(531,531,2)
(158,499,2)
(648,107,2)
(480,151,2)
(471,107,2)
(241,487,2)
(480,245,2)
(348,134,2)
(657,107,2)
(880,883,2)
(609,8,2)
(304,197,2)
(814,662,2)
(728,487,2)
(409,793,2)
(279,250,2)
(248,411,2)
(409,135,2)
(791,883,2)
(481,8,2)
(123,628,2)
(96,91,2)
(614,46,2)
(173,107,2)
(880,499,2)
(398,487,2)
(609,46,2)
(261,102,2)
(365,337,2)
(256,35,2)
(183,337,2)
(709,883,2)
(135,91,2)
(665,253,2)
(731,250,2)
(713,91,2)
(409,331,2)
(409,865,2)
(337,849,2)
(837,405,2)
(863,820,2)
(225,499,2)
(279,186,2)
(413,499,2)
(655,57,2)
(493,844,2)
(375,406,2)
(378,571,2)
(864,592,2)
(720,680,2)
(445,796,2)
(892,499,2)
(65,695,2)
(31,285,2)
(182,703,2)
(755,775,2)
(603,337,2)
(387,406,2)
(364,406,2)
(826,499,2)
(204,680,2)
(140,672,2)
(626,31,2)
(272,424,2)
(706,680,2)
(412,499,2)
(716,88,2)
(436,778,2)
(227,465,2)
(642,499,2)
(235,883,2)
(829,8,2)
(875,897,2)
(667,285,2)
(464,736,2)
(442,1,2)
(683,151,2)
(651,736,2)
(507,327,2)
(315,487,2)
(36,695,2)
(884,849,2)
(71,628,2)
(533,160,2)
(462,487,2)
(755,603,2)
(79,883,2)
(323,107,2)
(778,524,2)
(120,487,2)
(664,364,2)
(150,626,2)
(257,499,2)
(131,747,2)
(629,414,2)
(461,499,2)
(269,487,2)
(813,489,2)
(549,499,2)
(496,409,2)
(178,91,2)
(598,628,2)
(301,301,2)
(689,784,2)
(58,487,2)
(230,22,2)
(635,618,2)
(477,813,2)
(795,734,2)
(412,883,2)
(714,88,2)
(519,499,2)
(184,197,2)
(646,46,2)
(740,197,2)
(205,499,2)
(262,897,2)
(276,408,2)
(224,897,2)
(712,695,2)
(21,628,2)
(790,212,2)
(422,172,2)
(631,314,2)
(364,188,2)
(360,191,2)
(702,406,2)
(138,107,2)
(258,747,2)
(771,364,2)
(210,601,2)
(501,844,2)
(113,897,2)
(177,883,2)
(409,499,2)
(834,511,2)
(152,640,2)
(172,90,2)
(193,318,2)
(448,883,2)
(276,531,2)
(10,465,2)
(540,46,2)
(216,71,2)
(345,747,2)
(256,88,2)
(319,436,2)
(639,680,2)
(11,524,2)
(590,499,2)
(786,680,2)
(394,897,2)
(248,414,2)
(504,188,2)
(648,406,2)
(637,558,2)
(416,534,2)
(666,231,2)
(83,571,2)
(75,487,2)
(750,489,2)
(10,736,2)
(58,762,2)
(513,864,2)
(722,499,2)
(194,499,2)
(603,749,2)
(230,283,2)
(850,618,2)
(451,107,2)
(124,651,2)
(538,107,2)
(640,858,2)
(606,405,2)
(423,406,2)
(755,95,2)
(348,489,2)
(598,432,2)
(534,499,2)
(396,337,2)
(214,897,2)
(795,499,2)
(842,245,2)
(9,431,2)
(861,107,2)
(194,883,2)
(711,680,2)
(587,883,2)
(775,571,2)
(192,560,2)
(102,253,2)
(463,337,2)
(553,883,2)
(229,646,2)
(828,844,2)
(148,558,2)
(63,844,2)
(722,193,2)
(635,285,2)
(759,499,2)
(343,747,2)
(36,3,2)
(218,680,2)
(868,176,2)
(833,248,2)
(237,88,2)
(674,883,2)
(328,151,2)
(601,739,2)
(846,844,2)
(856,91,2)
(42,680,2)
(248,837,2)
(665,448,2)
(739,489,2)
(211,736,2)
(335,191,2)
(615,436,2)
(137,747,2)
(541,88,2)
(677,364,2)
(686,337,2)
(448,91,2)
(871,91,2)
(521,499,2)
(894,680,2)
(719,158,2)
(367,487,2)
(507,695,2)
(150,194,2)
(406,745,2)
(660,832,2)
(49,25,2)
(862,406,2)
(664,451,2)
(826,883,2)
(676,499,2)
(597,172,2)
(831,188,2)
(784,278,2)
(33,561,2)
(760,474,2)
(703,406,2)
(424,651,2)
(665,421,2)
(397,107,2)
(216,628,2)
(199,796,2)
(729,763,2)
(196,25,2)
(779,428,2)
(408,844,2)
(805,558,2)
(171,248,2)
(290,197,2)
(487,534,2)
(877,897,2)
(676,91,2)
(263,487,2)
(119,561,2)
(177,529,2)
(443,680,2)
(115,107,2)
(750,883,2)
(403,339,2)
(655,288,2)
(159,702,2)
(808,598,2)
(648,62,2)
(845,680,2)
(308,883,2)
(350,364,2)
(513,107,2)
(169,664,2)
(113,113,2)
(761,656,2)
(184,487,2)
(865,504,2)
(850,695,2)
(545,680,2)
(193,499,2)
(718,188,2)
(501,426,2)
(68,487,2)
(528,499,2)
(313,499,2)
(353,172,2)
(423,364,2)
(746,588,2)
(755,136,2)
(446,285,2)
(511,747,2)
(307,736,2)
(292,615,2)
(14,472,2)
(91,863,2)
(721,88,2)
(29,883,2)
(669,829,2)
(573,36,2)
(31,499,2)
(232,186,2)
(241,197,2)
(867,883,2)
(565,628,2)
(770,680,2)
(278,561,2)
(654,855,2)
(419,487,2)
(645,883,2)
(403,146,2)
(204,434,2)
(658,499,2)
(604,422,2)
(334,405,2)
(409,202,2)
(852,487,2)
(215,253,2)
(563,747,2)
(680,487,2)
(464,186,2)
(627,406,2)
(348,314,2)
(90,414,2)
(750,414,2)
(502,680,2)
(2,560,2)
(216,489,2)
(356,225,2)
(456,15,2)
(209,487,2)
(734,499,2)
(834,8,2)
(470,626,2)
(528,883,2)
(550,695,2)
(283,487,2)
(408,285,2)
(855,635,2)
(755,582,2)
(194,177,2)
(44,499,2)
(715,91,2)
(347,796,2)
(664,406,2)
(172,172,2)
(58,680,2)
(605,883,2)
(854,487,2)
(738,188,2)
(518,747,2)
(153,333,2)
(628,870,2)
(156,489,2)
(16,626,2)
(823,5,2)
(824,470,2)
(840,278,2)
(57,487,2)
(341,499,2)
(461,883,2)
(482,107,2)
(885,406,2)
(798,844,2)
(318,883,2)
(409,797,2)
(572,225,2)
(512,680,2)
(94,406,2)
(305,172,2)
(629,253,2)
(465,796,2)
(829,558,2)
(230,487,2)
(331,91,2)
(397,158,2)
(428,285,2)
(588,212,2)
(859,470,2)
(666,499,2)
(886,487,2)
(409,861,2)
(693,337,2)
(402,274,2)
(527,197,2)
(41,695,2)
(314,533,2)
(587,499,2)
(612,883,2)
(668,337,2)
(230,398,2)
(178,499,2)
(634,829,2)
(775,285,2)
(625,435,2)
(479,883,2)
(283,812,2)
(470,883,2)
(456,531,2)
(617,883,2)
(767,172,2)
(116,499,2)
(542,651,2)
(280,107,2)
(409,52,2)
(409,603,2)
(81,251,2)
(197,680,2)
(825,285,2)
(511,46,2)
(703,188,2)
(308,499,2)
(67,747,2)
(152,625,2)
(158,519,2)
(74,680,2)
(82,107,2)
(615,135,2)
(70,107,2)
(254,680,2)
(122,102,2)
(679,499,2)
(58,489,2)
(684,188,2)
(484,188,2)
(286,465,2)
(22,487,2)
(609,594,2)
(145,499,2)
(700,107,2)
(831,864,2)
(755,684,2)
(802,256,2)
(578,326,2)
(254,487,2)
(71,91,2)
(86,253,2)
(141,197,2)
(646,188,2)
(487,499,2)
(196,615,2)
(755,100,2)
(152,73,2)
(149,337,2)
(750,736,2)
(5,499,2)
(685,197,2)
(744,680,2)
(457,250,2)
(409,671,2)
(475,883,2)
(294,274,2)
(531,844,2)
(385,285,2)
(219,499,2)
(13,499,2)
(162,4,2)
(544,337,2)
(557,571,2)
(747,442,2)
(897,897,2)
(164,470,2)
(259,499,2)
(870,292,2)
(746,449,2)
(739,88,2)
(317,689,2)
(88,298,2)
(635,487,2)
(264,813,2)
(575,487,2)
(511,142,2)
(755,74,2)
(28,832,2)
(377,285,2)
(46,276,2)
(755,760,2)
(375,364,2)
(447,628,2)
(376,406,2)
(252,695,2)
(844,832,2)
(765,337,2)
(334,225,2)
(534,587,2)
(45,499,2)
(736,314,2)
(146,460,2)
(238,844,2)
(271,883,2)
(814,367,2)
(245,158,2)
(377,208,2)
(771,107,2)
(880,285,2)
(474,364,2)
(86,487,2)
(620,487,2)
(848,337,2)
(217,781,2)
(409,537,2)
(536,680,2)
(213,487,2)
(517,405,2)
(90,844,2)
(78,188,2)
(533,250,2)
(38,832,2)
(785,487,2)
(830,197,2)
(303,91,2)
(283,197,2)
(369,680,2)
(794,883,2)
(73,814,2)
(99,487,2)
(895,333,2)
(325,747,2)
(197,659,2)
(191,25,2)
(671,91,2)
(747,422,2)
(193,883,2)
(409,532,2)
(769,470,2)
(115,140,2)
(342,487,2)
(73,680,2)
(353,90,2)
(555,25,2)
(4,883,2)
(86,407,2)
(235,499,2)
(409,830,2)
(130,113,2)
(385,248,2)
(390,680,2)
(787,796,2)
(152,487,2)
(375,107,2)
(112,176,2)
(6,499,2)
(56,337,2)
(736,348,2)
(526,95,2)
(480,119,2)
(98,107,2)
(821,487,2)
(298,253,2)
(517,487,2)
(170,832,2)
(762,680,2)
(373,90,2)
(834,747,2)
(505,680,2)
(504,406,2)
(149,158,2)
(154,680,2)
(146,364,2)
(250,97,2)
(132,499,2)
(514,113,2)
(93,560,2)
(166,465,2)
(809,499,2)
(24,197,2)
(677,747,2)
(119,317,2)
(226,659,2)
(740,487,2)
(758,883,2)
(57,218,2)
(654,487,2)
(692,314,2)
(289,107,2)
(702,364,2)
(175,91,2)
(225,883,2)
(788,285,2)
(3,695,2)
(719,511,2)
(761,680,2)
(212,713,2)
(627,364,2)
(863,670,2)
(25,274,2)
(432,21,2)
(168,695,2)
(665,489,2)
(158,883,2)
(175,680,2)
(391,256,2)
(517,680,2)
(605,499,2)
(424,542,2)
(169,397,2)
(883,499,2)
(478,197,2)
(333,472,2)
(290,487,2)
(755,375,2)
(615,582,2)
(154,487,2)
(2,91,2)
(460,548,2)
(8,795,2)
(44,883,2)
(333,883,2)
(582,571,2)
(367,680,2)
(463,594,2)
(852,197,2)
(449,91,2)
(202,337,2)
(464,487,2)
(191,49,2)
(359,499,2)
(60,458,2)
(10,186,2)
(251,212,2)
(86,414,2)
(121,481,2)
(560,489,2)
(278,1,2)
(628,274,2)
(100,747,2)
(4,729,2)
(48,747,2)
(444,107,2)
(588,405,2)
(136,680,2)
(879,414,2)
(90,253,2)
(97,91,2)
(24,487,2)
(338,95,2)
(177,499,2)
(654,155,2)
(246,337,2)
(641,248,2)
(510,188,2)
(152,761,2)
(867,733,2)
(545,487,2)
(821,680,2)
(755,861,2)
(434,91,2)
(885,364,2)
(864,897,2)
(893,499,2)
(339,864,2)
(505,487,2)
(475,499,2)
(188,403,2)
(630,695,2)
(612,285,2)
(584,225,2)
(169,672,2)
(638,10,2)
(561,8,2)
(861,406,2)
(776,499,2)
(148,669,2)
(116,883,2)
(359,883,2)
(417,883,2)
(681,571,2)
(781,883,2)
(109,695,2)
(206,571,2)
(62,513,2)
(797,337,2)
(688,695,2)
(94,364,2)
(530,883,2)
(518,46,2)
(393,628,2)
(247,251,2)
(651,186,2)
(42,487,2)
(449,212,2)
(118,10,2)
(813,883,2)
(517,58,2)
(155,883,2)
(336,107,2)
(577,747,2)
(695,301,2)
(66,487,2)
(210,256,2)
(171,837,2)
(779,470,2)
(222,337,2)
(100,376,2)
(393,678,2)
(665,736,2)
(357,225,2)
(420,487,2)
(210,201,2)
(847,436,2)
(231,883,2)
(796,829,2)
(409,684,2)
(422,353,2)
(373,373,2)
(92,487,2)
(406,844,2)
(225,813,2)
(456,844,2)
(701,487,2)
(159,337,2)
(658,883,2)
(406,15,2)
(438,278,2)
(879,197,2)
(838,883,2)
(316,680,2)
(604,747,2)
(110,197,2)
(398,197,2)
(837,651,2)
(515,333,2)
(236,405,2)
(558,534,2)
(529,499,2)
(812,197,2)
(640,405,2)
(529,285,2)
(825,695,2)
(349,651,2)
(527,487,2)
(871,251,2)
(445,285,2)
(232,736,2)
(496,721,2)
(755,793,2)
(63,172,2)
(409,136,2)
(134,314,2)
(762,91,2)
(88,874,2)
(77,695,2)
(487,883,2)
(421,883,2)
(691,499,2)
(201,256,2)
(877,849,2)
(583,188,2)
(276,844,2)
(301,695,2)
(352,314,2)
(326,487,2)
(330,499,2)
(778,8,2)
(152,680,2)
(46,573,2)
(265,499,2)
(183,149,2)
(750,186,2)
(317,278,2)
(499,88,2)
(755,865,2)
(855,487,2)
(446,465,2)
(17,91,2)
(885,188,2)
(640,487,2)
(151,832,2)
(9,211,2)
(117,883,2)
(275,695,2)
(434,680,2)
(560,264,2)
(474,406,2)
(160,91,2)
(605,489,2)
(758,499,2)
(467,614,2)
(513,672,2)
(675,695,2)
(274,499,2)
(665,883,2)
(6,642,2)
(548,672,2)
(35,88,2)
(45,883,2)
(735,565,2)
(395,534,2)
(345,406,2)
(29,499,2)
(307,186,2)
(450,88,2)
(704,278,2)
(547,883,2)
(553,405,2)
(787,829,2)
(655,680,2)
(169,107,2)
(581,10,2)
(625,487,2)
(242,747,2)
(500,832,2)
(185,499,2)
(387,364,2)
(274,883,2)
(760,188,2)
(748,499,2)
(636,499,2)
(51,251,2)
(455,248,2)
(211,186,2)
(724,487,2)
(571,883,2)
(853,172,2)
(54,107,2)
(796,459,2)
(274,4,2)
(781,499,2)
(737,628,2)
(788,278,2)
(17,499,2)
(151,142,2)
(766,301,2)
(495,107,2)
(749,406,2)
(218,487,2)
(462,197,2)
(401,465,2)
(564,107,2)
(531,276,2)
(300,225,2)
(883,823,2)
(588,253,2)
(14,333,2)
(103,107,2)
(282,837,2)
(101,499,2)
(15,155,2)
(424,10,2)
(828,414,2)
(625,680,2)
(755,87,2)
(337,422,2)
(761,186,2)
(573,695,2)
(85,571,2)
(626,499,2)
(614,459,2)
(5,35,2)
(172,373,2)
(529,883,2)
(823,91,2)
(813,499,2)
(408,208,2)
(427,188,2)
(409,883,2)
(575,414,2)
(409,94,2)
(345,364,2)
(21,393,2)
(576,422,2)
(748,883,2)
(318,499,2)
(467,337,2)
(267,560,2)
(862,364,2)
(886,680,2)
(633,626,2)
(476,197,2)
(592,46,2)
(7,695,2)
(86,680,2)
(312,499,2)
(245,151,2)
(36,850,2)
(350,747,2)
(499,256,2)
(542,171,2)
(297,298,2)
(415,298,2)
(155,499,2)
(578,487,2)
(171,346,2)
(163,487,2)
(896,680,2)
(720,487,2)
(693,849,2)
(4,499,2)
(421,91,2)
(383,487,2)
(791,499,2)
(540,113,2)
(715,487,2)
(719,46,2)
(672,107,2)
(461,880,2)
(233,571,2)
(694,680,2)
(599,487,2)
(652,470,2)
(35,215,2)
(766,695,2)
(109,832,2)
(420,680,2)
(142,189,2)
(281,499,2)
(701,197,2)
(470,499,2)
(208,571,2)
(861,364,2)
(519,867,2)
(217,499,2)
(816,883,2)
(832,695,2)
(316,405,2)
(595,499,2)
(548,107,2)
(465,445,2)
(809,883,2)
(317,561,2)
(653,487,2)
(807,897,2)
(665,186,2)
(0,784,2)
(691,883,2)
(856,499,2)
(174,571,2)
(191,274,2)
(46,531,2)
(279,489,2)
(566,424,2)
(353,373,2)
(313,883,2)
(214,422,2)
(304,487,2)
(893,883,2)
(750,405,2)
(465,253,2)
(414,251,2)
(409,711,2)
(1,470,2)
(678,628,2)
(519,461,2)
(456,155,2)
(95,628,2)
(248,253,2)
(301,464,2)
(474,188,2)
(800,107,2)
(787,401,2)
(468,628,2)
(361,628,2)
(766,535,2)
(458,2,2)
(310,186,2)
(560,813,2)
(274,122,2)
(872,680,2)
(615,775,2)
(803,695,2)
(217,883,2)
(143,561,2)
(257,883,2)
(580,172,2)
(368,844,2)
(101,883,2)
(745,15,2)
(806,212,2)
(834,46,2)
(632,172,2)
(437,849,2)
(687,470,2)
(619,274,2)
(666,257,2)
(146,406,2)
(838,499,2)
(120,695,2)
(147,883,2)
(879,487,2)
(298,414,2)
(327,695,2)
(126,487,2)
(166,10,2)
(62,107,2)
(739,186,2)
(470,150,2)
(57,680,2)
(594,594,2)
(499,210,2)
(667,172,2)
(17,883,2)
(755,830,2)
(655,487,2)
(439,844,2)
(579,107,2)
(459,194,2)
(213,489,2)
(735,628,2)
(329,747,2)
(377,844,2)
(409,423,2)
(219,883,2)
(589,747,2)
(401,796,2)
(196,91,2)
(264,91,2)
(535,695,2)
(413,883,2)
(384,680,2)
(409,476,2)
(592,1,2)
(483,628,2)
(625,489,2)
(620,197,2)
(95,808,2)
(618,83,2)
(423,107,2)
(542,837,2)
(106,251,2)
(12,102,2)
(822,680,2)
(723,470,2)
(860,499,2)
(549,883,2)
(53,212,2)
(376,747,2)
(722,883,2)
(727,844,2)
(520,487,2)
(25,1,2)
(401,166,2)
(832,275,2)
(808,176,2)
(750,499,2)
(531,377,2)
(381,747,2)
(425,188,2)
(309,499,2)
(421,499,2)
(793,91,2)
(594,46,2)
(671,95,2)
(874,186,2)
(587,285,2)
(669,787,2)
(649,695,2)
(575,253,2)
(388,314,2)
(207,499,2)
(189,695,2)
(799,844,2)
(754,487,2)
(537,345,2)
(310,736,2)
(456,745,2)
(189,285,2)
(644,25,2)
(23,188,2)
(229,188,2)
(594,142,2)
(400,499,2)
(354,337,2)
(92,197,2)
(647,829,2)
(59,844,2)
(135,225,2)
(565,216,2)
(654,9,2)
(437,897,2)
(293,337,2)
(689,278,2)
(626,194,2)
(577,442,2)
(302,695,2)
(211,575,2)
(312,883,2)
(443,487,2)
(176,628,2)
-----------------------------------
(0,compRuleSet)
(1,alphaOffset = 0)
(2,masterPtr->ditherX)
(3,blockPtr->offset[0])
(4,!sourceIsSimplePhoto)
(5,MAX(xEnd, masterPtr->width)
(6,blockPtr->pixelPtr == masterPtr->pix32)
(7,compRuleSet)
(8,blueOffset = blockPtr->offset[2] - blockPtr->offset[0])
(9,(size_t)
(10,height <= blockPtr->height)
(11,blueOffset)
(12,height)
(13,sourceIsSimplePhoto)
(14,Tcl_ResetResult(interp)
(15,destLinePtr += pitch)
(16,0)
(17,masterPtr->width)
(18,xEnd)
(19,sourceIsSimplePhoto)
(20,x)
(21,destLinePtr = masterPtr->pix32 + (y * masterPtr->width + x)
(22,masterPtr->validRegion)
(23,4)
(24,workRgn)
(25,alphaOffset != 0)
(26,if ((greenOffset != 0)
(27,blockPtr)
(28,--hCopy)
(29,masterPtr)
(30,destPtr)
(31,blockPtr->pixelSize)
(32,&rect)
(33,3)
(34,pix32)
(35,xEnd = x + width)
(36,blockPtr->pixelPtr + blockPtr->offset[0])
(37,x)
(38,4)
(39,blockPtr)
(40,x)
(41,blockPtr)
(42,x)
(43,blueOffset)
(44,offset)
(45,blockPtr)
(46,srcPtr = srcLinePtr)
(47,y)
(48,*destPtr++ = srcPtr[blueOffset])
(49,masterPtr->flags & COMPLEX_ALPHA)
(50,0)
(51,userWidth)
(52,rect.height)
(53,x)
(54,0)
(55,destPtr)
(56,destPtr)
(57,(y * masterPtr->width + x)
(58,y * masterPtr->width)
(59,srcLinePtr)
(60,(y == masterPtr->ditherY)
(61,)
(62,destPtr[2] = PD_SRC_OVER(srcPtr[blueOffset], alpha,\n\\n\\t\\t\\t\\tdestPtr[2], Alpha)
(63,0)
(64,if ((y < masterPtr->ditherY)
(65,pixelSize)
(66,goto recalculateValidRegion;)
(67,pixelSize)
(68,width)
(69,alpha)
(70,srcPtr)
(71,masterPtr->width)
(72,blueOffset)
(73,(unsigned)
(74,rect.y)
(75,y)
(76,masterPtr)
(77,offset)
(78,blueOffset)
(79,TCL_ERROR)
(80,if (interp != NULL)
(81,masterPtr)
(82,Alpha)
(83,masterPtr->pix32)
(84,if (alpha)
(85,masterPtr->width * 4)
(86,(unsigned)
(87,*destPtr++)
(88,(width <= 0)
(89,interp)
(90,wLeft = width)
(91,masterPtr = (PhotoMaster *)
(92,rect)
(93,ditherX)
(94,destPtr[0])
(95,newAlpha && newAlpha != 255)
(96,masterPtr->width)
(97,masterPtr->userHeight)
(98,3)
(99,destLinePtr)
(100,*destPtr++)
(101,masterPtr)
(102,width == 1)
(103,0)
(104,if ((blockPtr->pixelSize == 4)
(105,masterPtr)
(106,width)
(107,alpha)
(108,x)
(109,hCopy)
(110,TkDestroyRegion(workRgn)
(111,)
(112,newAlpha)
(113,srcPtr+=pixelSize)
(114,yEnd)
(115,destPtr[0] = PD_SRC_OVER(srcPtr[0], alpha, destPtr[0],\n\\n\\t\\t\\t\\tAlpha)
(116,y)
(117,height)
(118,height)
(119,(blueOffset == 2)
(120,hLeft)
(121,*destPtr++ = srcPtr[blueOffset])
(122,(width == 1)
(123,pix32)
(124,0)
(125,compRule)
(126,height)
(127,alphaOffset)
(128,destPtr)
(129,srcPtr)
(130,srcPtr[0])
(131,*destPtr++ = 255)
(132,alphaOffset)
(133,)
(134,masterPtr->userHeight)
(135,masterPtr->ditherY)
(136,rect.x)
(137,blueOffset)
(138,Alpha)
(139,masterPtr)
(140,PD_SRC_OVER(srcPtr[0], alpha, destPtr[0],\n\\n\\t\\t\\t\\tAlpha)
(141,width)
(142,pixelSize = blockPtr->pixelSize)
(143,alphaOffset)
(144,)
(145,masterPtr)
(146,destPtr[3])
(147,height)
(148,(greenOffset == 1)
(149,srcPtr[greenOffset])
(150,alphaOffset < 0)
(151,pixelSize == 4)
(152,TkpBuildRegionFromAlphaData(masterPtr->validRegion, (unsigned)
(153,NULL)
(154,y)
(155,destLinePtr = masterPtr->pix32 + (y * masterPtr->width + x)
(156,masterPtr->ditherY = y)
(157,masterPtr)
(158,greenOffset = blockPtr->offset[1] - blockPtr->offset[0])
(159,*destPtr++)
(160,masterPtr->userHeight)
(161,greenOffset)
(162,width)
(163,height)
(164,sourceIsSimplePhoto)
(165,NULL)
(166,(height <= blockPtr->height)
(167,3)
(168,hCopy)
(169,PD_SRC_OVER(srcPtr[greenOffset], alpha,\n\\n\\t\\t\\t\\tdestPtr[1], Alpha)
(170,0)
(171,(width == masterPtr->width)
(172,wLeft > 0)
(173,1)
(174,4)
(175,masterPtr->validRegion)
(176,newAlpha)
(177,blockPtr->offset[3])
(178,masterPtr->ditherY)
(179,y)
(180,COMPLEX_ALPHA)
(181,masterPtr->width)
(182,*destPtr++)
(183,*destPtr++ = srcPtr[greenOffset])
(184,TkUnionRectWithRegion(&rect, workRgn, workRgn)
(185,blockPtr)
(186,int height)
(187,compRule)
(188,alpha == 255 || !destPtr[3])
(189,blockPtr->pixelSize)
(190,height)
(191,(alphaOffset != 0)
(192,x)
(193,masterPtr->width * 4)
(194,alphaOffset = blockPtr->offset[3])
(195,0)
(196,masterPtr->flags)
(197,compRule != TK_PHOTO_COMPOSITE_OVERLAY)
(198,hLeft)
(199,blockPtr)
(200,)
(201,masterPtr->height)
(202,*destPtr++)
(203,if (ImgPhotoSetSize(masterPtr, MAX(xEnd, masterPtr->width)
(204,TkUnionRectWithRegion(&rect, masterPtr->validRegion,\n\\n\\t\\tmasterPtr->validRegion)
(205,greenOffset)
(206,masterPtr)
(207,height)
(208,blockPtr->pitch = masterPtr->width * 4)
(209,masterPtr)
(210,yEnd > masterPtr->height)
(211,height * width * 4)
(212,masterPtr->userWidth != 0)
(213,rect.y = y)
(214,--wCopy)
(215,x + width)
(216,y * masterPtr->width)
(217,blockPtr->offset[0])
(218,(y * masterPtr->width + x)
(219,pitch)
(220,for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize)
(221,compRule)
(222,blueOffset)
(223,)
(224,alpha)
(225,(y < masterPtr->ditherY)
(226,compRule &= ~SOURCE_IS_SIMPLE_ALPHA_PHOTO)
(227,height)
(228,width)
(229,*destPtr++ = srcPtr[0])
(230,TkSubtractRegion(masterPtr->validRegion, workRgn,\n\\n\\t\\t    masterPtr->validRegion)
(231,(y * masterPtr->width + x)
(232,rect.height = height)
(233,blockPtr)
(234,)
(235,0)
(236,masterPtr->userWidth - x)
(237,y)
(238,wLeft)
(239,hLeft)
(240,)
(241,x)
(242,destPtr)
(243,if (!sourceIsSimplePhoto && (width == 1)
(244,)
(245,greenOffset == 1)
(246,*destPtr++ = srcPtr[blueOffset])
(247,x)
(248,width == masterPtr->width)
(249,blockPtr)
(250,masterPtr->userHeight != 0)
(251,(masterPtr->userWidth != 0)
(252,hCopy)
(253,int width)
(254,3)
(255,compRule)
(256,xEnd > masterPtr->width)
(257,masterPtr->pix32)
(258,*destPtr++ = srcPtr[greenOffset])
(259,blockPtr)
(260,pixelSize)
(261,1)
(262,255)
(263,pixelPtr)
(264,masterPtr->ditherY)
(265,masterPtr->pix32)
(266,alphaOffset)
(267,masterPtr)
(268,width)
(269,4)
(270,destLinePtr)
(271,interp)
(272,TK_PHOTO_COMPOSITE_SET)
(273,newAlpha)
(274,!sourceIsSimplePhoto && (width == 1)
(275,hCopy = MIN(hLeft, blockPtr->height)
(276,srcLinePtr += blockPtr->pitch)
(277,yEnd)
(278,alphaOffset == 3)
(279,y + height)
(280,destPtr)
(281,masterPtr)
(282,masterPtr)
(283,workRgn = TkCreateRegion()
(284,greenOffset)
(285,register Tk_PhotoImageBlock *blockPtr)
(286,height)
(287,if ((xEnd > masterPtr->width)
(288,masterPtr->pix32)
(289,Alpha)
(290,height)
(291,if ((masterPtr->userWidth != 0)
(292,masterPtr->flags)
(293,0)
(294,alphaOffset)
(295,hCopy)
(296,)
(297,height)
(298,width <= 0)
(299,destPtr)
(300,masterPtr)
(301,hLeft -= hCopy)
(302,0)
(303,masterPtr->width)
(304,rect.height)
(305,wCopy)
(306,)
(307,rect.height = height)
(308,2)
(309,masterPtr)
(310,height == 1)
(311,)
(312,4)
(313,masterPtr)
(314,(masterPtr->userHeight != 0)
(315,width)
(316,rect.x = x)
(317,(alphaOffset == 3)
(318,masterPtr->width)
(319,COLOR_IMAGE)
(320,handle)
(321,if (alpha == 255 || !destPtr[3])
(322,for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize)
(323,srcPtr)
(324,if ((alphaOffset >= blockPtr->pixelSize)
(325,0)
(326,blockPtr->offset)
(327,compRule == TK_PHOTO_COMPOSITE_SET)
(328,greenOffset)
(329,srcPtr)
(330,width)
(331,masterPtr->flags)
(332,TCL_ERROR)
(333,interp != NULL)
(334,masterPtr->ditherX = x)
(335,masterPtr)
(336,alpha)
(337,wCopy>0)
(338,COMPLEX_ALPHA)
(339,alpha == 255)
(340,ditherY)
(341,sameSrc = (blockPtr->pixelPtr == masterPtr->pix32)
(342,blockPtr)
(343,wCopy)
(344,width)
(345,destPtr++)
(346,blockPtr->pitch == pitch)
(347,width)
(348,masterPtr->userHeight - y)
(349,x)
(350,destPtr++)
(351,srcPtr)
(352,y)
(353,MIN(wLeft, blockPtr->width)
(354,destPtr)
(355,if ((pixelSize == 4)
(356,masterPtr)
(357,y)
(358,pixelSize)
(359,pix32)
(360,ToggleComplexAlphaIfNeeded(masterPtr)
(361,width)
(362,destPtr)
(363,SOURCE_IS_SIMPLE_ALPHA_PHOTO)
(364,destPtr += 4)
(365,srcPtr)
(366,greenOffset)
(367,masterPtr->width)
(368,destLinePtr)
(369,width)
(370,wCopy)
(371,height)
(372,greenOffset)
(373,wLeft -= wCopy)
(374,destPtr)
(375,destPtr[2])
(376,destPtr++)
(377,blockPtr->pitch)
(378,pitch)
(379,width)
(380,if ((width <= 0)
(381,destPtr)
(382,if (!(masterPtr->flags & COMPLEX_ALPHA)
(383,y)
(384,rect.y = y)
(385,blockPtr->pitch)
(386,~SOURCE_IS_SIMPLE_ALPHA_PHOTO)
(387,destPtr[0])
(388,height)
(389,workRgn)
(390,validRegion)
(391,yEnd)
(392,width)
(393,masterPtr->pix32 + (y * masterPtr->width + x)
(394,alpha)
(395,greenOffset)
(396,*destPtr++ = srcPtr[0])
(397,srcPtr[greenOffset])
(398,masterPtr->validRegion)
(399,srcPtr)
(400,MAX(yEnd, masterPtr->height)
(401,(width <= blockPtr->width)
(402,0)
(403,!destPtr[3])
(404,1)
(405,int x)
(406,destPtr = destLinePtr)
(407,unsigned)
(408,blockPtr->pitch)
(409,return TCL_OK;)
(410,wLeft)
(411,masterPtr->width)
(412,(Tk_PhotoHandle)
(413,height)
(414,width = masterPtr->userWidth - x)
(415,0)
(416,1)
(417,blockPtr)
(418,sourceIsSimplePhoto = 1)
(419,workRgn)
(420,4)
(421,masterPtr->width)
(422,wCopy = MIN(wLeft, blockPtr->width)
(423,destPtr[1])
(424,(height == 1)
(425,destPtr)
(426,size_t)
(427,0)
(428,blockPtr->offset)
(429,alphaOffset)
(430,alphaOffset)
(431,size_t)
(432,destLinePtr[3])
(433,pixelSize)
(434,masterPtr->validRegion)
(435,unsigned)
(436,(greenOffset != 0)
(437,0)
(438,width)
(439,pitch)
(440,height)
(441,pitch)
(442,alphaOffset == 0)
(443,width)
(444,Alpha)
(445,blockPtr->width)
(446,blockPtr->height)
(447,masterPtr)
(448,masterPtr->height)
(449,masterPtr->userWidth)
(450,x)
(451,destPtr[1] = PD_SRC_OVER(srcPtr[greenOffset], alpha,\n\\n\\t\\t\\t\\tdestPtr[1], Alpha)
(452,masterPtr)
(453,hLeft)
(454,masterPtr)
(455,pitch)
(456,memcpy(destLinePtr, srcLinePtr, (size_t)
(457,y)
(458,x < masterPtr->ditherX)
(459,alphaOffset -= blockPtr->offset[0])
(460,destPtr[3] = PD_SRC_OVER_ALPHA(alpha, Alpha)
(461,blockPtr->offset[1])
(462,x)
(463,srcPtr[0])
(464,hLeft = height)
(465,width <= blockPtr->width)
(466,)
(467,*destPtr++ = srcPtr[alphaOffset])
(468,destLinePtr)
(469,masterPtr)
(470,(alphaOffset >= blockPtr->pixelSize)
(471,blueOffset)
(472,Tcl_Interp *interp)
(473,pixelSize)
(474,destPtr++)
(475,offset)
(476,rect.width)
(477,masterPtr)
(478,y)
(479,masterPtr)
(480,(greenOffset == 1)
(481,srcPtr[blueOffset])
(482,2)
(483,y)
(484,destPtr)
(485,rect)
(486,recalculateValidRegion:)
(487,(blockPtr->pixelSize == 4)
(488,blockPtr)
(489,int y)
(490,masterPtr)
(491,masterPtr)
(492,wLeft)
(493,pitch)
(494,yEnd)
(495,greenOffset)
(496,RET)
(497,4)
(498,)
(499,(xEnd > masterPtr->width)
(500,pixelSize)
(501,(size_t)
(502,rect)
(503,if (sameSrc)
(504,destPtr++)
(505,validRegion)
(506,userHeight)
(507,compRuleSet = (compRule == TK_PHOTO_COMPOSITE_SET)
(508,rect)
(509,y)
(510,srcPtr)
(511,srcPtr+=pixelSize)
(512,rect)
(513,PD_SRC_OVER(srcPtr[blueOffset], alpha,\n\\n\\t\\t\\t\\tdestPtr[2], Alpha)
(514,srcPtr[greenOffset])
(515,Tcl_AppendResult(interp, TK_PHOTO_ALLOC_FAILURE_MESSAGE, NULL)
(516,masterPtr)
(517,y * masterPtr->width + x)
(518,srcPtr[0])
(519,blockPtr->offset[1] - blockPtr->offset[0])
(520,workRgn)
(521,sameSrc)
(522,1)
(523,)
(524,greenOffset != 0)
(525,0)
(526,masterPtr)
(527,rect)
(528,x)
(529,blockPtr->offset)
(530,offset)
(531,srcLinePtr += blockPtr->pitch)
(532,*destPtr++)
(533,(y + height)
(534,blockPtr->pixelSize == 4)
(535,blockPtr->height)
(536,rect)
(537,*destPtr++)
(538,destPtr)
(539,)
(540,srcPtr[blueOffset])
(541,height)
(542,(x == 0)
(543,)
(544,wCopy)
(545,width)
(546,compRule)
(547,y)
(548,PD_SRC_OVER_ALPHA(alpha, Alpha)
(549,tkMaster)
(550,blockPtr)
(551,3)
(552,newAlpha)
(553,y * masterPtr->width + x)
(554,TK_PHOTO_COMPOSITE_SET)
(555,flags)
(556,blockPtr)
(557,masterPtr)
(558,greenOffset == 1)
(559,&rect)
(560,y == masterPtr->ditherY)
(561,blueOffset == 2)
(562,*destPtr++ = srcPtr[greenOffset])
(563,0)
(564,destPtr)
(565,y * masterPtr->width + x)
(566,compRule == TK_PHOTO_COMPOSITE_SET)
(567,)
(568,srcLinePtr)
(569,)
(570,for (hLeft = height; hLeft > 0;)
(571,sameSrc)
(572,ditherY)
(573,srcLinePtr = blockPtr->pixelPtr + blockPtr->offset[0])
(574,blockPtr)
(575,width * 4)
(576,--wCopy)
(577,wCopy)
(578,blockPtr->offset[0])
(579,alpha)
(580,blockPtr)
(581,((height == 1)
(582,blockPtr->pitch)
(583,destPtr)
(584,ditherX)
(585,pitch)
(586,destLinePtr)
(587,blockPtr->pixelSize)
(588,x + width)
(589,destPtr)
(590,pix32)
(591,Tk_PhotoHandle)
(592,srcPtr[alphaOffset])
(593,srcPtr)
(594,srcPtr+=pixelSize)
(595,pixelPtr)
(596,srcLinePtr)
(597,0)
(598,newAlpha = destLinePtr[3])
(599,x)
(600,2)
(601,yEnd = y + height)
(602,flags)
(603,*destPtr++)
(604,--wCopy)
(605,y * masterPtr->width)
(606,rect.x = x)
(607,blockPtr)
(608,)
(609,srcPtr[blueOffset])
(610,255)
(611,)
(612,blockPtr->offset)
(613,pixelSize)
(614,srcPtr[alphaOffset])
(615,masterPtr->flags |= COLOR_IMAGE)
(616,TCL_OK)
(617,TCL_OK)
(618,blockPtr->pixelPtr = masterPtr->pix32)
(619,masterPtr)
(620,rect)
(621,*destPtr++ = srcPtr[0])
(622,width)
(623,)
(624,if (alphaOffset == 0)
(625,(unsigned)
(626,alphaOffset >= blockPtr->pixelSize)
(627,destPtr++)
(628,!(masterPtr->flags & COMPLEX_ALPHA)
(629,rect.width = width)
(630,0)
(631,masterPtr)
(632,wCopy)
(633,alphaOffset)
(634,alphaOffset)
(635,blockPtr->pixelPtr)
(636,x)
(637,2)
(638,1)
(639,masterPtr)
(640,(unsigned)
(641,blockPtr)
(642,blockPtr->pixelPtr)
(643,if (newAlpha && newAlpha != 255)
(644,masterPtr)
(645,return TCL_ERROR;)
(646,srcPtr[0])
(647,3)
(648,destPtr[2])
(649,blockPtr)
(650,sourceIsSimplePhoto)
(651,height == 1)
(652,1)
(653,workRgn)
(654,memmove(destLinePtr, blockPtr->pixelPtr + blockPtr->offset[0],\n\\n\\t\\t(size_t)
(655,masterPtr->pix32 + (y * masterPtr->width + x)
(656,unsigned)
(657,alpha)
(658,0)
(659,int compRule)
(660,hCopy)
(661,masterPtr)
(662,unsigned)
(663,masterPtr)
(664,destPtr[1])
(665,Tk_ImageChanged(masterPtr->tkMaster, x, y, width, height,\n\\n\\t    masterPtr->width, masterPtr->height)
(666,masterPtr->pix32 + (y * masterPtr->width + x)
(667,blockPtr->width)
(668,srcPtr)
(669,(blueOffset == 2)
(670,Tk_PhotoHandle handle)
(671,masterPtr->flags)
(672,Alpha = destPtr[3])
(673,wLeft)
(674,greenOffset)
(675,srcLinePtr)
(676,masterPtr->tkMaster)
(677,destPtr++)
(678,masterPtr->pix32)
(679,x)
(680,alphaOffset)
(681,pixelPtr)
(682,destPtr)
(683,1)
(684,*destPtr++)
(685,validRegion)
(686,srcPtr)
(687,offset)
(688,hLeft)
(689,(width <= blockPtr->width)
(690,width)
(691,4)
(692,userHeight)
(693,wCopy)
(694,height)
(695,hLeft > 0)
(696,alpha)
(697,srcPtr)
(698,)
(699,destPtr)
(700,destPtr)
(701,validRegion)
(702,destPtr++)
(703,destPtr++)
(704,width)
(705,alphaOffset)
(706,rect)
(707,masterPtr)
(708,Alpha)
(709,3)
(710,)
(711,rect.width)
(712,height)
(713,masterPtr->userWidth)
(714,xEnd)
(715,masterPtr->validRegion)
(716,width)
(717,)
(718,destPtr)
(719,srcPtr[greenOffset])
(720,4)
(721,return TCL_OK;)
(722,pitch = masterPtr->width * 4)
(723,blockPtr)
(724,workRgn)
(725,sameSrc)
(726,width)
(727,blockPtr)
(728,blockPtr)
(729,sourceIsSimplePhoto = compRule & SOURCE_IS_SIMPLE_ALPHA_PHOTO)
(730,userWidth)
(731,userHeight)
(732,for (; wCopy>0 ; --wCopy, srcPtr+=pixelSize)
(733,blockPtr->offset)
(734,blockPtr->offset[2])
(735,(y * masterPtr->width + x)
(736,height = masterPtr->userHeight - y)
(737,masterPtr)
(738,srcPtr)
(739,y + height)
(740,rect)
(741,srcPtr)
(742,if (alphaOffset)
(743,interp)
(744,validRegion)
(745,destLinePtr += pitch)
(746,(x + width)
(747,wCopy>0)
(748,masterPtr)
(749,destPtr++)
(750,Tk_DitherPhoto((Tk_PhotoHandle)
(751,0)
(752,width)
(753,destLinePtr)
(754,4)
(755,masterPtr->flags |= COMPLEX_ALPHA)
(756,pitch)
(757,)
(758,width)
(759,4)
(760,*destPtr++)
(761,(unsigned)
(762,masterPtr->width)
(763,compRule & SOURCE_IS_SIMPLE_ALPHA_PHOTO)
(764,)
(765,0)
(766,MIN(hLeft, blockPtr->height)
(767,srcLinePtr)
(768,destPtr)
(769,0)
(770,masterPtr)
(771,destPtr[3])
(772,2)
(773,)
(774,)
(775,blockPtr->pixelPtr)
(776,width)
(777,)
(778,blueOffset != 0)
(779,blockPtr->offset[0])
(780,continue;)
(781,blockPtr->offset)
(782,srcPtr)
(783,srcPtr)
(784,width <= blockPtr->width)
(785,offset)
(786,width)
(787,(alphaOffset == 3)
(788,blockPtr->width)
(789,Alpha)
(790,masterPtr)
(791,0)
(792,COMPLEX_ALPHA)
(793,masterPtr->ditherX)
(794,offset)
(795,blockPtr->offset[2] - blockPtr->offset[0])
(796,alphaOffset == 3)
(797,*destPtr++)
(798,destLinePtr)
(799,destLinePtr)
(800,3)
(801,xEnd)
(802,masterPtr)
(803,pixelPtr)
(804,flags)
(805,blueOffset)
(806,userWidth)
(807,srcPtr)
(808,newAlpha != 255)
(809,1)
(810,offset)
(811,)
(812,TkCreateRegion()
(813,y < masterPtr->ditherY)
(814,(unsigned)
(815,if ((masterPtr->userHeight != 0)
(816,blockPtr)
(817,width)
(818,)
(819,if (compRule != TK_PHOTO_COMPOSITE_OVERLAY)
(820,PhotoMaster *)
(821,height)
(822,TK_PHOTO_COMPOSITE_OVERLAY)
(823,ImgPhotoSetSize(masterPtr, MAX(xEnd, masterPtr->width)
(824,alphaOffset)
(825,blockPtr->offset)
(826,width)
(827,0)
(828,width * 4)
(829,blueOffset == 2)
(830,rect.x)
(831,*destPtr++ = alpha)
(832,hCopy > 0)
(833,pitch)
(834,srcPtr[blueOffset])
(835,0)
(836,srcLinePtr)
(837,x == 0)
(838,alphaOffset)
(839,pix32)
(840,blockPtr)
(841,)
(842,blueOffset)
(843,srcPtr)
(844,(pixelSize == 4)
(845,y)
(846,4)
(847,flags)
(848,destPtr)
(849,compRuleSet)
(850,blockPtr->pixelPtr)
(851,destPtr)
(852,rect.y)
(853,width)
(854,height)
(855,blockPtr->pixelPtr + blockPtr->offset[0])
(856,masterPtr->height)
(857,xEnd)
(858,unsigned)
(859,0)
(860,destLinePtr)
(861,destPtr[3])
(862,destPtr++)
(863,(PhotoMaster *)
(864,alpha = srcPtr[alphaOffset])
(865,*destPtr++)
(866,masterPtr)
(867,blockPtr->offset[0])
(868,255)
(869,compRuleSet)
(870,masterPtr->flags & COMPLEX_ALPHA)
(871,masterPtr->userWidth)
(872,width)
(873,alpha)
(874,height <= 0)
(875,srcPtr)
(876,for (; hCopy > 0; --hCopy)
(877,wCopy)
(878,wCopy)
(879,rect.width = width)
(880,blockPtr->offset)
(881,for (wLeft = width; wLeft > 0;)
(882,continue;)
(883,ImgPhotoSetSize(masterPtr, MAX(xEnd, masterPtr->width)
(884,continue;)
(885,destPtr++)
(886,masterPtr)
(887,wLeft)
(888,continue;)
(889,masterPtr)
(890,width)
(891,)
(892,ditherY)
(893,pixelSize)
(894,y)
(895,TK_PHOTO_ALLOC_FAILURE_MESSAGE)
(896,rect)
(897,wCopy>0)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^