-----label-----
1
-----code-----
int rmonitor_resources(long int interval /*in microseconds */)
{
    uint64_t round;

    struct rmonitor_process_info *p_acc = calloc(1, sizeof(struct rmonitor_process_info)); //Automatic zeroed.
    struct rmonitor_wdir_info    *d_acc = calloc(1, sizeof(struct rmonitor_wdir_info));
    struct rmonitor_filesys_info *f_acc = calloc(1, sizeof(struct rmonitor_filesys_info));

    struct rmsummary    *resources_now = calloc(1, sizeof(struct rmsummary));

    // Loop while there are processes to monitor, that is
    // itable_size(processes) > 0). The check is done again in a
    // if/break pair below to mitigate a race condition in which
	// the last process exits after the while(...) is tested, but
	// before we reach select.
	round = 1;
	while(itable_size(processes) > 0)
	{
		resources_now->last_error = 0;

		ping_processes();

		rmonitor_poll_all_processes_once(processes, p_acc);

		if(resources_flags->workdir_footprint)
			rmonitor_poll_all_wds_once(wdirs, d_acc, MAX(1, interval/(ONE_SECOND*hash_table_size(wdirs))));

		// rmonitor_fss_once(f); disabled until statfs fs id makes sense.

		rmonitor_collate_tree(resources_now, p_acc, d_acc, f_acc);
		rmonitor_find_max_tree(summary, resources_now);
		rmonitor_log_row(resources_now);

		if(!rmonitor_check_limits(summary))
			rmonitor_final_cleanup(SIGTERM);

		release_waiting_processes();

		cleanup_zombies();
		//If no more process are alive, break out of loop.
		if(itable_size(processes) < 1)
			break;

		wait_for_messages(interval);

		//cleanup processes which by terminating may have awaken
		//select.
		cleanup_zombies();

		round++;
	}

    free(resources_now);
    free(p_acc);
    free(d_acc);
    free(f_acc);

    return 0;
}
-----children-----
1,2
1,3
1,4
3,4
3,5
5,6
5,7
7,8
9,10
9,11
9,12
9,13
9,14
9,15
9,16
9,17
9,18
9,19
9,20
9,21
10,11
11,12
11,13
12,13
14,15
16,17
17,18
17,19
18,19
20,21
20,22
20,23
23,24
24,25
24,26
24,27
25,26
28,29
29,30
29,31
30,31
33,34
34,35
34,36
35,36
37,38
37,39
37,40
40,41
41,42
41,43
41,44
42,43
45,46
46,47
46,48
47,48
50,51
51,52
51,53
52,53
54,55
54,56
54,57
57,58
58,59
58,60
58,61
59,60
62,63
63,64
63,65
64,65
67,68
68,69
68,70
69,70
71,72
71,73
71,74
74,75
75,76
75,77
75,78
76,77
79,80
80,81
80,82
81,82
84,85
85,86
85,87
86,87
89,90
89,91
90,91
90,92
91,92
91,93
92,93
94,95
97,98
97,99
97,100
97,101
97,102
97,103
97,104
97,105
97,106
97,107
97,108
97,109
97,110
97,111
98,99
99,100
99,101
100,101
100,102
101,102
105,106
106,107
107,108
109,110
110,111
110,112
110,113
111,112
113,114
115,116
117,118
117,119
118,119
118,120
119,120
122,123
123,124
123,125
123,126
123,127
124,125
126,127
128,129
130,131
130,132
130,133
131,132
134,135
134,136
135,136
137,138
138,139
138,140
139,140
141,142
141,143
142,143
144,145
146,147
147,148
147,149
147,150
147,151
147,152
148,149
150,151
152,153
154,155
156,157
158,159
159,160
159,161
159,162
160,161
162,163
164,165
166,167
167,168
167,169
168,169
170,171
172,173
172,174
173,174
174,175
174,176
175,176
177,178
179,180
180,181
180,182
181,182
183,184
184,185
186,187
187,188
188,189
190,191
191,192
192,193
194,195
194,196
195,196
195,197
196,197
196,198
197,198
199,200
203,204
204,205
204,206
205,206
207,208
209,210
210,211
211,212
213,214
214,215
215,216
217,218
218,219
218,220
219,220
221,222
223,224
224,225
224,226
225,226
227,228
229,230
230,231
230,232
231,232
233,234
235,236
236,237
236,238
237,238
239,240
241,242
-----nextToken-----
2,4,6,8,13,15,19,21,22,26,27,31,32,36,38,39,43,44,48,49,53,55,56,60,61,65,66,70,72,73,77,78,82,83,87,88,93,95,96,102,103,104,108,112,114,116,120,121,125,127,129,132,133,136,140,143,145,149,151,153,155,157,161,163,165,169,171,176,178,182,185,189,193,198,200,201,202,206,208,212,216,220,222,226,228,232,234,238,240,242
-----computeFrom-----
85,86
85,87
90,91
90,92
99,100
99,101
134,135
134,136
138,139
138,140
195,196
195,197
-----guardedBy-----
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;LiteralExpression;TypeIdExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;LiteralExpression;TypeIdExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;LiteralExpression;TypeIdExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;LiteralExpression;TypeIdExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;WhileStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;UnaryExpression;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;BreakStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ExpressionStatement;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;LiteralExpression;
-----ast_node-----
int rmonitor_resources(long int interval /*in microseconds */){    uint64_t round;    struct rmonitor_process_info *p_acc = calloc(1, sizeof(struct rmonitor_process_info)); //Automatic zeroed.    struct rmonitor_wdir_info    *d_acc = calloc(1, sizeof(struct rmonitor_wdir_info));    struct rmonitor_filesys_info *f_acc = calloc(1, sizeof(struct rmonitor_filesys_info));    struct rmsummary    *resources_now = calloc(1, sizeof(struct rmsummary));    // Loop while there are processes to monitor, that is    // itable_size(processes) > 0). The check is done again in a    // if/break pair below to mitigate a race condition in which	// the last process exits after the while(...) is tested, but	// before we reach select.	round = 1;	while(itable_size(processes) > 0)	{		resources_now->last_error = 0;		ping_processes();		rmonitor_poll_all_processes_once(processes, p_acc);		if(resources_flags->workdir_footprint)			rmonitor_poll_all_wds_once(wdirs, d_acc, MAX(1, interval/(ONE_SECOND*hash_table_size(wdirs))));		// rmonitor_fss_once(f); disabled until statfs fs id makes sense.		rmonitor_collate_tree(resources_now, p_acc, d_acc, f_acc);		rmonitor_find_max_tree(summary, resources_now);		rmonitor_log_row(resources_now);		if(!rmonitor_check_limits(summary))			rmonitor_final_cleanup(SIGTERM);		release_waiting_processes();		cleanup_zombies();		//If no more process are alive, break out of loop.		if(itable_size(processes) < 1)			break;		wait_for_messages(interval);		//cleanup processes which by terminating may have awaken		//select.		cleanup_zombies();		round++;	}    free(resources_now);    free(p_acc);    free(d_acc);    free(f_acc);    return 0;}
int
rmonitor_resources(long int interval /*in microseconds */)
rmonitor_resources
long int interval
long int
interval
interval
{    uint64_t round;    struct rmonitor_process_info *p_acc = calloc(1, sizeof(struct rmonitor_process_info)); //Automatic zeroed.    struct rmonitor_wdir_info    *d_acc = calloc(1, sizeof(struct rmonitor_wdir_info));    struct rmonitor_filesys_info *f_acc = calloc(1, sizeof(struct rmonitor_filesys_info));    struct rmsummary    *resources_now = calloc(1, sizeof(struct rmsummary));    // Loop while there are processes to monitor, that is    // itable_size(processes) > 0). The check is done again in a    // if/break pair below to mitigate a race condition in which	// the last process exits after the while(...) is tested, but	// before we reach select.	round = 1;	while(itable_size(processes) > 0)	{		resources_now->last_error = 0;		ping_processes();		rmonitor_poll_all_processes_once(processes, p_acc);		if(resources_flags->workdir_footprint)			rmonitor_poll_all_wds_once(wdirs, d_acc, MAX(1, interval/(ONE_SECOND*hash_table_size(wdirs))));		// rmonitor_fss_once(f); disabled until statfs fs id makes sense.		rmonitor_collate_tree(resources_now, p_acc, d_acc, f_acc);		rmonitor_find_max_tree(summary, resources_now);		rmonitor_log_row(resources_now);		if(!rmonitor_check_limits(summary))			rmonitor_final_cleanup(SIGTERM);		release_waiting_processes();		cleanup_zombies();		//If no more process are alive, break out of loop.		if(itable_size(processes) < 1)			break;		wait_for_messages(interval);		//cleanup processes which by terminating may have awaken		//select.		cleanup_zombies();		round++;	}    free(resources_now);    free(p_acc);    free(d_acc);    free(f_acc);    return 0;}
uint64_t round;
uint64_t round;
uint64_t
uint64_t
round
round
struct rmonitor_process_info *p_acc = calloc(1, sizeof(struct rmonitor_process_info));
struct rmonitor_process_info *p_acc = calloc(1, sizeof(struct rmonitor_process_info));
struct rmonitor_process_info
rmonitor_process_info
*p_acc = calloc(1, sizeof(struct rmonitor_process_info))
*
p_acc
= calloc(1, sizeof(struct rmonitor_process_info))
calloc(1, sizeof(struct rmonitor_process_info))
calloc
calloc
1
sizeof(struct rmonitor_process_info)
struct rmonitor_process_info
struct rmonitor_process_info
rmonitor_process_info

struct rmonitor_wdir_info    *d_acc = calloc(1, sizeof(struct rmonitor_wdir_info));
struct rmonitor_wdir_info    *d_acc = calloc(1, sizeof(struct rmonitor_wdir_info));
struct rmonitor_wdir_info
rmonitor_wdir_info
*d_acc = calloc(1, sizeof(struct rmonitor_wdir_info))
*
d_acc
= calloc(1, sizeof(struct rmonitor_wdir_info))
calloc(1, sizeof(struct rmonitor_wdir_info))
calloc
calloc
1
sizeof(struct rmonitor_wdir_info)
struct rmonitor_wdir_info
struct rmonitor_wdir_info
rmonitor_wdir_info

struct rmonitor_filesys_info *f_acc = calloc(1, sizeof(struct rmonitor_filesys_info));
struct rmonitor_filesys_info *f_acc = calloc(1, sizeof(struct rmonitor_filesys_info));
struct rmonitor_filesys_info
rmonitor_filesys_info
*f_acc = calloc(1, sizeof(struct rmonitor_filesys_info))
*
f_acc
= calloc(1, sizeof(struct rmonitor_filesys_info))
calloc(1, sizeof(struct rmonitor_filesys_info))
calloc
calloc
1
sizeof(struct rmonitor_filesys_info)
struct rmonitor_filesys_info
struct rmonitor_filesys_info
rmonitor_filesys_info

struct rmsummary    *resources_now = calloc(1, sizeof(struct rmsummary));
struct rmsummary    *resources_now = calloc(1, sizeof(struct rmsummary));
struct rmsummary
rmsummary
*resources_now = calloc(1, sizeof(struct rmsummary))
*
resources_now
= calloc(1, sizeof(struct rmsummary))
calloc(1, sizeof(struct rmsummary))
calloc
calloc
1
sizeof(struct rmsummary)
struct rmsummary
struct rmsummary
rmsummary

round = 1;
round = 1
round
round
1
while(itable_size(processes) > 0)	{		resources_now->last_error = 0;		ping_processes();		rmonitor_poll_all_processes_once(processes, p_acc);		if(resources_flags->workdir_footprint)			rmonitor_poll_all_wds_once(wdirs, d_acc, MAX(1, interval/(ONE_SECOND*hash_table_size(wdirs))));		// rmonitor_fss_once(f); disabled until statfs fs id makes sense.		rmonitor_collate_tree(resources_now, p_acc, d_acc, f_acc);		rmonitor_find_max_tree(summary, resources_now);		rmonitor_log_row(resources_now);		if(!rmonitor_check_limits(summary))			rmonitor_final_cleanup(SIGTERM);		release_waiting_processes();		cleanup_zombies();		//If no more process are alive, break out of loop.		if(itable_size(processes) < 1)			break;		wait_for_messages(interval);		//cleanup processes which by terminating may have awaken		//select.		cleanup_zombies();		round++;	}
itable_size(processes) > 0
itable_size(processes)
itable_size
itable_size
processes
processes
0
{		resources_now->last_error = 0;		ping_processes();		rmonitor_poll_all_processes_once(processes, p_acc);		if(resources_flags->workdir_footprint)			rmonitor_poll_all_wds_once(wdirs, d_acc, MAX(1, interval/(ONE_SECOND*hash_table_size(wdirs))));		// rmonitor_fss_once(f); disabled until statfs fs id makes sense.		rmonitor_collate_tree(resources_now, p_acc, d_acc, f_acc);		rmonitor_find_max_tree(summary, resources_now);		rmonitor_log_row(resources_now);		if(!rmonitor_check_limits(summary))			rmonitor_final_cleanup(SIGTERM);		release_waiting_processes();		cleanup_zombies();		//If no more process are alive, break out of loop.		if(itable_size(processes) < 1)			break;		wait_for_messages(interval);		//cleanup processes which by terminating may have awaken		//select.		cleanup_zombies();		round++;	}
resources_now->last_error = 0;
resources_now->last_error = 0
resources_now->last_error
resources_now
resources_now
last_error
0
ping_processes();
ping_processes()
ping_processes
ping_processes
rmonitor_poll_all_processes_once(processes, p_acc);
rmonitor_poll_all_processes_once(processes, p_acc)
rmonitor_poll_all_processes_once
rmonitor_poll_all_processes_once
processes
processes
p_acc
p_acc
if(resources_flags->workdir_footprint)			rmonitor_poll_all_wds_once(wdirs, d_acc, MAX(1, interval/(ONE_SECOND*hash_table_size(wdirs))));
resources_flags->workdir_footprint
resources_flags
resources_flags
workdir_footprint
rmonitor_poll_all_wds_once(wdirs, d_acc, MAX(1, interval/(ONE_SECOND*hash_table_size(wdirs))));
rmonitor_poll_all_wds_once(wdirs, d_acc, MAX(1, interval/(ONE_SECOND*hash_table_size(wdirs))))
rmonitor_poll_all_wds_once
rmonitor_poll_all_wds_once
wdirs
wdirs
d_acc
d_acc
MAX(1, interval/(ONE_SECOND*hash_table_size(wdirs)))
MAX
MAX
1
interval/(ONE_SECOND*hash_table_size(wdirs))
interval
interval
(ONE_SECOND*hash_table_size(wdirs))
ONE_SECOND*hash_table_size(wdirs)
ONE_SECOND
ONE_SECOND
hash_table_size(wdirs)
hash_table_size
hash_table_size
wdirs
wdirs
rmonitor_collate_tree(resources_now, p_acc, d_acc, f_acc);
rmonitor_collate_tree(resources_now, p_acc, d_acc, f_acc)
rmonitor_collate_tree
rmonitor_collate_tree
resources_now
resources_now
p_acc
p_acc
d_acc
d_acc
f_acc
f_acc
rmonitor_find_max_tree(summary, resources_now);
rmonitor_find_max_tree(summary, resources_now)
rmonitor_find_max_tree
rmonitor_find_max_tree
summary
summary
resources_now
resources_now
rmonitor_log_row(resources_now);
rmonitor_log_row(resources_now)
rmonitor_log_row
rmonitor_log_row
resources_now
resources_now
if(!rmonitor_check_limits(summary))			rmonitor_final_cleanup(SIGTERM);
!rmonitor_check_limits(summary)
rmonitor_check_limits(summary)
rmonitor_check_limits
rmonitor_check_limits
summary
summary
rmonitor_final_cleanup(SIGTERM);
rmonitor_final_cleanup(SIGTERM);
rmonitor_final_cleanup
rmonitor_final_cleanup
(SIGTERM)
SIGTERM
SIGTERM
release_waiting_processes();
release_waiting_processes()
release_waiting_processes
release_waiting_processes
cleanup_zombies();
cleanup_zombies()
cleanup_zombies
cleanup_zombies
if(itable_size(processes) < 1)			break;
itable_size(processes) < 1
itable_size(processes)
itable_size
itable_size
processes
processes
1
break;
wait_for_messages(interval);
wait_for_messages(interval)
wait_for_messages
wait_for_messages
interval
interval
cleanup_zombies();
cleanup_zombies()
cleanup_zombies
cleanup_zombies
round++;
round++
round
round
free(resources_now);
free(resources_now)
free
free
resources_now
resources_now
free(p_acc);
free(p_acc)
free
free
p_acc
p_acc
free(d_acc);
free(d_acc)
free
free
d_acc
d_acc
free(f_acc);
free(f_acc)
free
free
f_acc
f_acc
return 0;
0
-----joern-----
(22,76,0)
(24,71,0)
(49,20,0)
(81,10,0)
(24,64,0)
(60,73,0)
(51,64,0)
(88,48,0)
(91,2,0)
(34,73,0)
(64,59,0)
(62,68,0)
(52,9,0)
(17,73,0)
(11,81,0)
(103,66,0)
(44,40,0)
(92,79,0)
(18,73,0)
(89,40,0)
(94,7,0)
(80,30,0)
(98,73,0)
(101,58,0)
(59,64,0)
(35,39,0)
(33,39,0)
(39,10,0)
(48,58,0)
(31,73,0)
(30,41,0)
(98,53,0)
(71,73,0)
(4,2,0)
(65,24,0)
(10,73,0)
(6,69,0)
(2,91,0)
(25,94,0)
(66,73,0)
(79,73,0)
(47,15,0)
(53,98,0)
(40,44,0)
(29,96,0)
(53,49,0)
(43,98,0)
(85,58,0)
(51,73,0)
(61,70,0)
(83,59,0)
(10,70,0)
(58,101,0)
(40,89,0)
(9,15,0)
(102,79,0)
(54,68,0)
(24,98,0)
(69,64,0)
(97,24,0)
(14,87,0)
(36,43,0)
(24,10,0)
(42,15,0)
(24,15,0)
(74,15,0)
(28,71,0)
(96,98,0)
(70,76,0)
(12,98,0)
(95,45,0)
(95,59,0)
(44,71,0)
(72,101,0)
(100,73,0)
(66,10,0)
(16,81,0)
(20,49,0)
(84,24,0)
(13,15,0)
(48,88,0)
(81,15,0)
(45,95,0)
(90,24,0)
(69,15,0)
(93,15,0)
(5,15,0)
(50,96,0)
(41,30,0)
(43,73,0)
(70,10,0)
(63,15,0)
(99,57,0)
(87,71,0)
(39,42,0)
(27,21,0)
(75,7,0)
(56,5,0)
(76,22,0)
(58,77,0)
(0,73,0)
(82,53,0)
(71,44,0)
(79,39,0)
(57,15,0)
(8,15,0)
(86,48,0)
(9,77,0)
(55,17,0)
(7,94,0)
(49,53,0)
(78,69,0)
(23,44,0)
(38,17,0)
(5,10,0)
(3,88,0)
(96,101,0)
(57,17,0)
(76,70,0)
(67,15,0)
(101,96,0)
(46,10,0)
(19,91,0)
(37,64,0)
(64,73,0)
(58,48,0)
(26,51,0)
(87,73,0)
(59,95,0)
(1,42,0)
(39,33,1)
(66,10,1)
(1,39,1)
(43,36,1)
(82,12,1)
(96,101,1)
(53,49,1)
(81,16,1)
(98,53,1)
(48,88,1)
(87,14,1)
(23,28,1)
(33,35,1)
(78,67,1)
(103,7,1)
(86,85,1)
(40,23,1)
(28,98,1)
(41,30,1)
(66,103,1)
(9,52,1)
(38,55,1)
(39,10,1)
(90,84,1)
(35,7,1)
(17,38,1)
(24,64,1)
(10,70,1)
(25,57,1)
(96,98,1)
(13,74,1)
(11,24,1)
(103,32,1)
(49,82,1)
(57,17,1)
(74,41,1)
(62,69,1)
(44,40,1)
(50,68,1)
(24,65,1)
(58,77,1)
(67,42,1)
(36,51,1)
(97,90,1)
(59,95,1)
(49,20,1)
(16,11,1)
(2,4,1)
(52,2,1)
(74,21,1)
(76,22,1)
(55,10,1)
(21,27,1)
(24,71,1)
(25,17,1)
(75,94,1)
(76,61,1)
(27,41,1)
(12,64,1)
(65,97,1)
(32,2,1)
(5,56,1)
(26,66,1)
(24,10,1)
(95,45,1)
(51,64,1)
(94,25,1)
(4,91,1)
(88,3,1)
(68,54,1)
(43,98,1)
(5,10,1)
(51,26,1)
(57,99,1)
(6,78,1)
(7,94,1)
(92,87,1)
(70,76,1)
(3,86,1)
(47,9,1)
(69,64,1)
(40,89,1)
(87,71,1)
(101,58,1)
(24,98,1)
(99,47,1)
(84,96,1)
(19,13,1)
(91,19,1)
(61,46,1)
(58,48,1)
(7,75,1)
(72,29,1)
(69,6,1)
(2,91,1)
(95,83,1)
(46,71,1)
(80,5,1)
(83,37,1)
(54,62,1)
(14,43,1)
(71,44,1)
(9,77,1)
(84,68,1)
(79,92,1)
(64,59,1)
(102,79,1)
(81,10,1)
(85,72,1)
(30,80,1)
(42,1,1)
(79,39,1)
(56,81,1)
(29,50,1)
(97,7,2)
(58,68,2)
(72,68,2)
(13,7,2)
(54,7,2)
(58,77,2)
(33,7,2)
(51,64,2)
(88,68,2)
(98,53,2)
(4,7,2)
(52,2,2)
(48,88,2)
(19,7,2)
(56,7,2)
(39,10,2)
(44,40,2)
(96,101,2)
(57,2,2)
(69,64,2)
(25,2,2)
(7,2,2)
(1,7,2)
(64,59,2)
(16,7,2)
(24,7,2)
(80,7,2)
(50,68,2)
(76,22,2)
(5,10,2)
(71,44,2)
(21,41,2)
(43,98,2)
(62,7,2)
(68,7,2)
(91,7,2)
(9,2,2)
(49,20,2)
(3,68,2)
(101,58,2)
(94,2,2)
(66,10,2)
(24,64,2)
(2,7,2)
(59,95,2)
(86,68,2)
(29,68,2)
(85,68,2)
(9,77,2)
(74,7,2)
(102,79,2)
(69,7,2)
(53,49,2)
(81,10,2)
(87,71,2)
(95,45,2)
(42,7,2)
(27,41,2)
(48,68,2)
(41,7,2)
(70,76,2)
(35,7,2)
(40,89,2)
(101,68,2)
(99,2,2)
(2,91,2)
(57,17,2)
(96,68,2)
(41,30,2)
(7,94,2)
(96,98,2)
(65,7,2)
(67,7,2)
(24,71,2)
(24,10,2)
(81,7,2)
(79,39,2)
(10,70,2)
(32,2,2)
(58,48,2)
(39,7,2)
(24,98,2)
(78,7,2)
(75,2,2)
(30,7,2)
(5,7,2)
(90,7,2)
(84,7,2)
(11,7,2)
(47,2,2)
(6,7,2)
-----------------------------------
(0,f_acc)
(1,0)
(2,itable_size(processes)
(3,wdirs)
(4,1)
(5,rmonitor_log_row(resources_now)
(6,p_acc)
(7,itable_size(processes)
(8,if(!rmonitor_check_limits(summary)
(9,wait_for_messages(interval)
(10,*resources_now = calloc(1, sizeof(struct rmsummary)
(11,summary)
(12,d_acc)
(13,cleanup_zombies()
(14,f_acc)
(15,)
(16,resources_now)
(17,round = 1)
(18,while(itable_size(processes)
(19,processes)
(20,struct rmonitor_wdir_info)
(21,rmonitor_final_cleanup(SIGTERM)
(22,struct rmsummary)
(23,1)
(24,rmonitor_collate_tree(resources_now, p_acc, d_acc, f_acc)
(25,processes)
(26,p_acc)
(27,SIGTERM)
(28,f_acc)
(29,d_acc)
(30,rmonitor_check_limits(summary)
(31,d_acc)
(32,break;)
(33,last_error)
(34,p_acc)
(35,resources_now)
(36,d_acc)
(37,p_acc)
(38,1)
(39,resources_now->last_error)
(40,sizeof(struct rmonitor_filesys_info)
(41,!rmonitor_check_limits(summary)
(42,resources_now->last_error = 0)
(43,free(d_acc)
(44,calloc(1, sizeof(struct rmonitor_filesys_info)
(45,struct rmonitor_process_info)
(46,resources_now)
(47,cleanup_zombies()
(48,ONE_SECOND*hash_table_size(wdirs)
(49,sizeof(struct rmonitor_wdir_info)
(50,wdirs)
(51,free(p_acc)
(52,interval)
(53,calloc(1, sizeof(struct rmonitor_wdir_info)
(54,workdir_footprint)
(55,round)
(56,resources_now)
(57,round++)
(58,interval/(ONE_SECOND*hash_table_size(wdirs)
(59,calloc(1, sizeof(struct rmonitor_process_info)
(60,resources_now)
(61,1)
(62,resources_flags)
(63,if(itable_size(processes)
(64,*p_acc = calloc(1, sizeof(struct rmonitor_process_info)
(65,f_acc)
(66,free(resources_now)
(67,ping_processes()
(68,resources_flags->workdir_footprint)
(69,rmonitor_poll_all_processes_once(processes, p_acc)
(70,calloc(1, sizeof(struct rmsummary)
(71,*f_acc = calloc(1, sizeof(struct rmonitor_filesys_info)
(72,1)
(73,)
(74,release_waiting_processes()
(75,0)
(76,sizeof(struct rmsummary)
(77,long int interval)
(78,processes)
(79,return 0;)
(80,summary)
(81,rmonitor_find_max_tree(summary, resources_now)
(82,1)
(83,1)
(84,resources_now)
(85,interval)
(86,ONE_SECOND)
(87,free(f_acc)
(88,hash_table_size(wdirs)
(89,struct rmonitor_filesys_info)
(90,p_acc)
(91,itable_size(processes)
(92,0)
(93,if(resources_flags->workdir_footprint)
(94,itable_size(processes)
(95,sizeof(struct rmonitor_process_info)
(96,rmonitor_poll_all_wds_once(wdirs, d_acc, MAX(1, interval/(ONE_SECOND*hash_table_size(wdirs)
(97,d_acc)
(98,*d_acc = calloc(1, sizeof(struct rmonitor_wdir_info)
(99,round)
(100,round)
(101,MAX(1, interval/(ONE_SECOND*hash_table_size(wdirs)
(102,RET)
(103,resources_now)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^