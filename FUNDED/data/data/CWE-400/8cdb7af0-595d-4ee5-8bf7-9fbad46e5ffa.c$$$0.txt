-----label-----
1
-----code-----
static struct nf_conn *
__nf_conntrack_alloc(struct net *net,
		     const struct nf_conntrack_zone *zone,
		     const struct nf_conntrack_tuple *orig,
		     const struct nf_conntrack_tuple *repl,
		     gfp_t gfp, u32 hash)
{
	struct nf_conn *ct;

	/* We don't want any race condition at early drop stage */
	atomic_inc(&net->ct.count);

	if (nf_conntrack_max &&
	    unlikely(atomic_read(&net->ct.count) > nf_conntrack_max)) {
		if (!early_drop(net, hash)) {
			if (!conntrack_gc_work.early_drop)
				conntrack_gc_work.early_drop = true;
			atomic_dec(&net->ct.count);
			net_warn_ratelimited("nf_conntrack: table full, dropping packet\n");
			return ERR_PTR(-ENOMEM);
		}
	}

	/*
	 * Do not use kmem_cache_zalloc(), as this cache uses
	 * SLAB_DESTROY_BY_RCU.
	 */
	ct = kmem_cache_alloc(nf_conntrack_cachep, gfp);
	if (ct == NULL)
		goto out;

	spin_lock_init(&ct->lock);
	ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple = *orig;
	ct->tuplehash[IP_CT_DIR_ORIGINAL].hnnode.pprev = NULL;
	ct->tuplehash[IP_CT_DIR_REPLY].tuple = *repl;
	/* save hash for reusing when confirming */
	*(unsigned long *)(&ct->tuplehash[IP_CT_DIR_REPLY].hnnode.pprev) = hash;
	ct->status = 0;
	write_pnet(&ct->ct_net, net);
	memset(&ct->__nfct_init_offset[0], 0,
	       offsetof(struct nf_conn, proto) -
	       offsetof(struct nf_conn, __nfct_init_offset[0]));

	nf_ct_zone_add(ct, zone);

	/* Because we use RCU lookups, we set ct_general.use to zero before
	 * this is inserted in any list.
	 */
	atomic_set(&ct->ct_general.use, 0);
	return ct;
out:
	atomic_dec(&net->ct.count);
	return ERR_PTR(-ENOMEM);
}
-----children-----
1,2
1,3
1,4
2,3
4,5
4,6
4,7
4,8
4,9
4,10
4,11
4,12
7,8
7,9
8,9
10,11
10,12
13,14
13,15
14,15
16,17
16,18
19,20
19,21
20,21
22,23
22,24
25,26
25,27
26,27
28,29
28,30
31,32
31,33
32,33
34,35
36,37
36,38
37,38
39,40
41,42
41,43
41,44
41,45
41,46
41,47
41,48
41,49
41,50
41,51
41,52
41,53
41,54
41,55
41,56
41,57
41,58
41,59
42,43
43,44
43,45
44,45
46,47
46,48
49,50
50,51
50,52
51,52
53,54
54,55
54,56
55,56
55,57
56,57
60,61
60,62
61,62
61,63
62,63
64,65
64,66
65,66
67,68
67,69
68,69
68,70
69,70
71,72
72,73
72,74
73,74
73,75
74,75
78,79
80,81
81,82
81,83
82,83
83,84
83,85
83,86
84,85
86,87
88,89
90,91
90,92
90,93
90,94
91,92
91,93
92,93
93,94
93,95
94,95
97,98
98,99
98,100
99,100
99,101
100,101
104,105
105,106
105,107
106,107
108,109
109,110
109,111
110,111
110,112
111,112
115,116
116,117
116,118
117,118
120,121
121,122
121,123
122,123
124,125
125,126
127,128
128,129
128,130
129,130
131,132
131,133
131,134
132,133
134,135
136,137
138,139
138,140
139,140
139,141
140,141
142,143
144,145
146,147
147,148
147,149
148,149
150,151
151,152
151,153
152,153
155,156
156,157
156,158
157,158
157,159
158,159
158,160
159,160
159,161
160,161
163,164
166,167
167,168
169,170
170,171
170,172
171,172
171,173
172,173
172,174
173,174
173,175
174,175
174,176
175,176
178,179
182,183
184,185
185,186
185,187
186,187
186,188
187,188
187,189
188,189
188,190
189,190
192,193
195,196
196,197
198,199
199,200
199,201
200,201
201,202
201,203
202,203
202,204
204,205
206,207
207,208
208,209
208,210
209,210
209,211
210,211
210,212
211,212
211,213
212,213
215,216
219,220
221,222
222,223
222,224
223,224
223,225
224,225
228,229
229,230
229,231
229,232
230,231
232,233
233,234
233,235
234,235
237,238
239,240
240,241
241,242
241,243
241,244
242,243
244,245
246,247
248,249
249,250
249,251
249,252
250,251
252,253
253,254
253,255
254,255
254,256
255,256
260,261
261,262
263,264
263,265
265,266
266,267
266,268
267,268
269,270
270,271
270,272
271,272
271,273
272,273
276,277
277,278
277,279
278,279
280,281
281,282
-----nextToken-----
3,5,6,9,11,12,15,17,18,21,23,24,27,29,30,33,35,38,40,45,47,48,52,57,58,59,63,66,70,75,76,77,79,85,87,89,95,96,101,102,103,107,112,113,114,118,119,123,126,130,133,135,137,141,143,145,149,153,154,161,162,164,165,168,176,177,179,180,181,183,190,191,193,194,197,203,205,213,214,216,217,218,220,225,226,227,231,235,236,238,243,245,247,251,256,257,258,259,262,264,268,273,274,275,279,282
-----computeFrom-----
61,62
61,63
67,68
67,69
98,99
98,100
128,129
128,130
139,140
139,141
156,157
156,158
170,171
170,172
185,186
185,187
199,200
199,201
222,223
222,224
-----guardedBy-----
76,113
77,114
75,112
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;ElaboratedTypeSpecifier;Name;FunctionDeclarator;Pointer;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IfStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;BinaryExpression;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ReturnStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;GotoStatement;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;UnaryExpression;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;UnaryExpression;UnaryExpression;FieldReference;FieldReference;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ProblemStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;ReturnStatement;IdExpression;Name;LabelStatement;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;ReturnStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;
-----ast_node-----
static struct nf_conn *__nf_conntrack_alloc(struct net *net,		     const struct nf_conntrack_zone *zone,		     const struct nf_conntrack_tuple *orig,		     const struct nf_conntrack_tuple *repl,		     gfp_t gfp, u32 hash){	struct nf_conn *ct;	/* We don't want any race condition at early drop stage */	atomic_inc(&net->ct.count);	if (nf_conntrack_max &&	    unlikely(atomic_read(&net->ct.count) > nf_conntrack_max)) {		if (!early_drop(net, hash)) {			if (!conntrack_gc_work.early_drop)				conntrack_gc_work.early_drop = true;			atomic_dec(&net->ct.count);			net_warn_ratelimited("nf_conntrack: table full, dropping packet\n");			return ERR_PTR(-ENOMEM);		}	}	/*	 * Do not use kmem_cache_zalloc(), as this cache uses	 * SLAB_DESTROY_BY_RCU.	 */	ct = kmem_cache_alloc(nf_conntrack_cachep, gfp);	if (ct == NULL)		goto out;	spin_lock_init(&ct->lock);	ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple = *orig;	ct->tuplehash[IP_CT_DIR_ORIGINAL].hnnode.pprev = NULL;	ct->tuplehash[IP_CT_DIR_REPLY].tuple = *repl;	/* save hash for reusing when confirming */	*(unsigned long *)(&ct->tuplehash[IP_CT_DIR_REPLY].hnnode.pprev) = hash;	ct->status = 0;	write_pnet(&ct->ct_net, net);	memset(&ct->__nfct_init_offset[0], 0,	       offsetof(struct nf_conn, proto) -	       offsetof(struct nf_conn, __nfct_init_offset[0]));	nf_ct_zone_add(ct, zone);	/* Because we use RCU lookups, we set ct_general.use to zero before	 * this is inserted in any list.	 */	atomic_set(&ct->ct_general.use, 0);	return ct;out:	atomic_dec(&net->ct.count);	return ERR_PTR(-ENOMEM);}
static struct nf_conn
nf_conn
*__nf_conntrack_alloc(struct net *net,		     const struct nf_conntrack_zone *zone,		     const struct nf_conntrack_tuple *orig,		     const struct nf_conntrack_tuple *repl,		     gfp_t gfp, u32 hash)
*
__nf_conntrack_alloc
struct net *net
struct net
net
*net
*
net
const struct nf_conntrack_zone *zone
const struct nf_conntrack_zone
nf_conntrack_zone
*zone
*
zone
const struct nf_conntrack_tuple *orig
const struct nf_conntrack_tuple
nf_conntrack_tuple
*orig
*
orig
const struct nf_conntrack_tuple *repl
const struct nf_conntrack_tuple
nf_conntrack_tuple
*repl
*
repl
gfp_t gfp
gfp_t
gfp_t
gfp
gfp
u32 hash
u32
u32
hash
hash
{	struct nf_conn *ct;	/* We don't want any race condition at early drop stage */	atomic_inc(&net->ct.count);	if (nf_conntrack_max &&	    unlikely(atomic_read(&net->ct.count) > nf_conntrack_max)) {		if (!early_drop(net, hash)) {			if (!conntrack_gc_work.early_drop)				conntrack_gc_work.early_drop = true;			atomic_dec(&net->ct.count);			net_warn_ratelimited("nf_conntrack: table full, dropping packet\n");			return ERR_PTR(-ENOMEM);		}	}	/*	 * Do not use kmem_cache_zalloc(), as this cache uses	 * SLAB_DESTROY_BY_RCU.	 */	ct = kmem_cache_alloc(nf_conntrack_cachep, gfp);	if (ct == NULL)		goto out;	spin_lock_init(&ct->lock);	ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple = *orig;	ct->tuplehash[IP_CT_DIR_ORIGINAL].hnnode.pprev = NULL;	ct->tuplehash[IP_CT_DIR_REPLY].tuple = *repl;	/* save hash for reusing when confirming */	*(unsigned long *)(&ct->tuplehash[IP_CT_DIR_REPLY].hnnode.pprev) = hash;	ct->status = 0;	write_pnet(&ct->ct_net, net);	memset(&ct->__nfct_init_offset[0], 0,	       offsetof(struct nf_conn, proto) -	       offsetof(struct nf_conn, __nfct_init_offset[0]));	nf_ct_zone_add(ct, zone);	/* Because we use RCU lookups, we set ct_general.use to zero before	 * this is inserted in any list.	 */	atomic_set(&ct->ct_general.use, 0);	return ct;out:	atomic_dec(&net->ct.count);	return ERR_PTR(-ENOMEM);}
struct nf_conn *ct;
struct nf_conn *ct;
struct nf_conn
nf_conn
*ct
*
ct
atomic_inc(&net->ct.count);
atomic_inc(&net->ct.count)
atomic_inc
atomic_inc
&net->ct.count
net->ct.count
net->ct
net
net
ct
count
if (nf_conntrack_max &&	    unlikely(atomic_read(&net->ct.count) > nf_conntrack_max)) {		if (!early_drop(net, hash)) {			if (!conntrack_gc_work.early_drop)				conntrack_gc_work.early_drop = true;			atomic_dec(&net->ct.count);			net_warn_ratelimited("nf_conntrack: table full, dropping packet\n");			return ERR_PTR(-ENOMEM);		}	}
nf_conntrack_max &&	    unlikely(atomic_read(&net->ct.count) > nf_conntrack_max)
nf_conntrack_max
nf_conntrack_max
unlikely(atomic_read(&net->ct.count) > nf_conntrack_max)
unlikely
unlikely
atomic_read(&net->ct.count) > nf_conntrack_max
atomic_read(&net->ct.count)
atomic_read
atomic_read
&net->ct.count
net->ct.count
net->ct
net
net
ct
count
nf_conntrack_max
nf_conntrack_max
{		if (!early_drop(net, hash)) {			if (!conntrack_gc_work.early_drop)				conntrack_gc_work.early_drop = true;			atomic_dec(&net->ct.count);			net_warn_ratelimited("nf_conntrack: table full, dropping packet\n");			return ERR_PTR(-ENOMEM);		}	}
if (!early_drop(net, hash)) {			if (!conntrack_gc_work.early_drop)				conntrack_gc_work.early_drop = true;			atomic_dec(&net->ct.count);			net_warn_ratelimited("nf_conntrack: table full, dropping packet\n");			return ERR_PTR(-ENOMEM);		}
!early_drop(net, hash)
early_drop(net, hash)
early_drop
early_drop
net
net
hash
hash
{			if (!conntrack_gc_work.early_drop)				conntrack_gc_work.early_drop = true;			atomic_dec(&net->ct.count);			net_warn_ratelimited("nf_conntrack: table full, dropping packet\n");			return ERR_PTR(-ENOMEM);		}
if (!conntrack_gc_work.early_drop)				conntrack_gc_work.early_drop = true;
!conntrack_gc_work.early_drop
conntrack_gc_work.early_drop
conntrack_gc_work
conntrack_gc_work
early_drop
conntrack_gc_work.early_drop = true;
conntrack_gc_work.early_drop = true
conntrack_gc_work.early_drop
conntrack_gc_work
conntrack_gc_work
early_drop
true
atomic_dec(&net->ct.count);
atomic_dec(&net->ct.count)
atomic_dec
atomic_dec
&net->ct.count
net->ct.count
net->ct
net
net
ct
count
net_warn_ratelimited("nf_conntrack: table full, dropping packet\n");
net_warn_ratelimited("nf_conntrack: table full, dropping packet\n")
net_warn_ratelimited
net_warn_ratelimited
"nf_conntrack: table full, dropping packet\n"
return ERR_PTR(-ENOMEM);
ERR_PTR(-ENOMEM)
ERR_PTR
ERR_PTR
-ENOMEM
ENOMEM
ENOMEM
ct = kmem_cache_alloc(nf_conntrack_cachep, gfp);
ct = kmem_cache_alloc(nf_conntrack_cachep, gfp)
ct
ct
kmem_cache_alloc(nf_conntrack_cachep, gfp)
kmem_cache_alloc
kmem_cache_alloc
nf_conntrack_cachep
nf_conntrack_cachep
gfp
gfp
if (ct == NULL)		goto out;
ct == NULL
ct
ct
NULL
NULL
goto out;
out
spin_lock_init(&ct->lock);
spin_lock_init(&ct->lock)
spin_lock_init
spin_lock_init
&ct->lock
ct->lock
ct
ct
lock
ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple = *orig;
ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple = *orig
ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple
ct->tuplehash[IP_CT_DIR_ORIGINAL]
ct->tuplehash
ct
ct
tuplehash
IP_CT_DIR_ORIGINAL
IP_CT_DIR_ORIGINAL
tuple
*orig
orig
orig
ct->tuplehash[IP_CT_DIR_ORIGINAL].hnnode.pprev = NULL;
ct->tuplehash[IP_CT_DIR_ORIGINAL].hnnode.pprev = NULL
ct->tuplehash[IP_CT_DIR_ORIGINAL].hnnode.pprev
ct->tuplehash[IP_CT_DIR_ORIGINAL].hnnode
ct->tuplehash[IP_CT_DIR_ORIGINAL]
ct->tuplehash
ct
ct
tuplehash
IP_CT_DIR_ORIGINAL
IP_CT_DIR_ORIGINAL
hnnode
pprev
NULL
NULL
ct->tuplehash[IP_CT_DIR_REPLY].tuple = *repl;
ct->tuplehash[IP_CT_DIR_REPLY].tuple = *repl
ct->tuplehash[IP_CT_DIR_REPLY].tuple
ct->tuplehash[IP_CT_DIR_REPLY]
ct->tuplehash
ct
ct
tuplehash
IP_CT_DIR_REPLY
IP_CT_DIR_REPLY
tuple
*repl
repl
repl
*(unsigned long *)(&ct->tuplehash[IP_CT_DIR_REPLY].hnnode.pprev) = hash;
*(unsigned long *)(&ct->tuplehash[IP_CT_DIR_REPLY].hnnode.pprev) = hash
*(unsigned long *)(&ct->tuplehash[IP_CT_DIR_REPLY].hnnode.pprev)
(unsigned long *)(&ct->tuplehash[IP_CT_DIR_REPLY].hnnode.pprev)
unsigned long *
unsigned long
*
*
(&ct->tuplehash[IP_CT_DIR_REPLY].hnnode.pprev)
&ct->tuplehash[IP_CT_DIR_REPLY].hnnode.pprev
ct->tuplehash[IP_CT_DIR_REPLY].hnnode.pprev
ct->tuplehash[IP_CT_DIR_REPLY].hnnode
ct->tuplehash[IP_CT_DIR_REPLY]
ct->tuplehash
ct
ct
tuplehash
IP_CT_DIR_REPLY
IP_CT_DIR_REPLY
hnnode
pprev
hash
hash
ct->status = 0;
ct->status = 0
ct->status
ct
ct
status
0
write_pnet(&ct->ct_net, net);
write_pnet(&ct->ct_net, net)
write_pnet
write_pnet
&ct->ct_net
ct->ct_net
ct
ct
ct_net
net
net
memset(&ct->__nfct_init_offset[0], 0,	       offsetof(struct nf_conn, proto) -	       offsetof(struct nf_conn, __nfct_init_offset[0]));
nf_ct_zone_add(ct, zone);
nf_ct_zone_add(ct, zone)
nf_ct_zone_add
nf_ct_zone_add
ct
ct
zone
zone
atomic_set(&ct->ct_general.use, 0);
atomic_set(&ct->ct_general.use, 0)
atomic_set
atomic_set
&ct->ct_general.use
ct->ct_general.use
ct->ct_general
ct
ct
ct_general
use
0
return ct;
ct
ct
out:	atomic_dec(&net->ct.count);
out
atomic_dec(&net->ct.count);
atomic_dec(&net->ct.count)
atomic_dec
atomic_dec
&net->ct.count
net->ct.count
net->ct
net
net
ct
count
return ERR_PTR(-ENOMEM);
ERR_PTR(-ENOMEM)
ERR_PTR
ERR_PTR
-ENOMEM
ENOMEM
ENOMEM
-----joern-----
(24,23,0)
(128,34,0)
(112,120,0)
(5,38,0)
(101,116,0)
(104,132,0)
(142,23,0)
(23,8,0)
(58,5,0)
(53,138,0)
(60,28,0)
(72,111,0)
(63,129,0)
(144,17,0)
(108,93,0)
(85,32,0)
(79,116,0)
(133,95,0)
(119,36,0)
(30,28,0)
(132,104,0)
(32,108,0)
(126,35,0)
(15,113,0)
(74,69,0)
(59,50,0)
(57,80,0)
(108,120,0)
(27,87,0)
(112,60,0)
(0,150,0)
(78,51,0)
(19,69,0)
(25,104,0)
(97,84,0)
(125,114,0)
(103,137,0)
(82,120,0)
(95,151,0)
(40,98,0)
(91,140,0)
(124,52,0)
(101,99,0)
(150,108,0)
(98,120,0)
(8,79,0)
(7,108,0)
(147,77,0)
(151,95,0)
(4,58,0)
(92,153,0)
(5,58,0)
(93,18,0)
(75,111,0)
(86,9,0)
(29,40,0)
(17,46,0)
(138,128,0)
(139,99,0)
(134,88,0)
(4,66,0)
(118,108,0)
(117,58,0)
(135,5,0)
(109,10,0)
(28,60,0)
(60,112,0)
(80,129,0)
(128,138,0)
(70,120,0)
(96,6,0)
(49,22,0)
(2,142,0)
(35,108,0)
(44,74,0)
(6,96,0)
(99,127,0)
(136,93,0)
(65,120,0)
(51,74,0)
(10,113,0)
(109,38,0)
(12,7,0)
(10,109,0)
(14,75,0)
(137,108,0)
(153,108,0)
(16,120,0)
(52,124,0)
(137,83,0)
(81,88,0)
(106,137,0)
(105,142,0)
(94,84,0)
(146,70,0)
(36,38,0)
(100,7,0)
(107,146,0)
(129,80,0)
(28,108,0)
(74,51,0)
(62,146,0)
(98,40,0)
(111,75,0)
(17,80,0)
(110,82,0)
(93,108,0)
(11,116,0)
(88,134,0)
(150,141,0)
(114,143,0)
(7,138,0)
(41,22,0)
(80,17,0)
(3,109,0)
(34,120,0)
(85,101,0)
(104,68,0)
(42,36,0)
(82,68,0)
(8,23,0)
(142,38,0)
(149,115,0)
(40,73,0)
(114,69,0)
(22,49,0)
(96,9,0)
(71,93,0)
(153,129,0)
(61,124,0)
(22,45,0)
(89,34,0)
(64,70,0)
(39,35,0)
(34,128,0)
(130,5,0)
(51,108,0)
(67,99,0)
(55,124,0)
(14,9,0)
(152,38,0)
(20,104,0)
(13,150,0)
(87,116,0)
(121,28,0)
(138,7,0)
(23,142,0)
(111,36,0)
(85,155,0)
(50,108,0)
(154,127,0)
(76,152,0)
(102,21,0)
(123,120,0)
(49,120,0)
(32,120,0)
(113,108,0)
(94,82,0)
(104,38,0)
(58,4,0)
(143,84,0)
(83,21,0)
(95,133,0)
(129,153,0)
(140,91,0)
(66,120,0)
(143,114,0)
(47,51,0)
(1,151,0)
(84,97,0)
(36,111,0)
(88,49,0)
(152,151,0)
(21,98,0)
(148,32,0)
(33,50,0)
(69,74,0)
(50,134,0)
(145,46,0)
(26,153,0)
(115,149,0)
(113,10,0)
(31,6,0)
(90,152,0)
(151,152,0)
(133,120,0)
(69,114,0)
(9,14,0)
(146,108,0)
(75,14,0)
(9,96,0)
(54,115,0)
(79,8,0)
(109,120,0)
(43,140,0)
(66,4,0)
(48,83,0)
(134,50,0)
(149,155,0)
(46,120,0)
(84,143,0)
(155,120,0)
(84,94,0)
(21,83,0)
(131,113,0)
(91,101,0)
(150,120,0)
(37,134,0)
(56,120,0)
(83,137,0)
(133,95,1)
(29,21,1)
(6,96,1)
(34,128,1)
(150,108,1)
(109,10,1)
(122,35,1)
(39,108,1)
(22,45,1)
(21,102,1)
(55,61,1)
(35,108,1)
(118,6,1)
(37,50,1)
(9,14,1)
(140,43,1)
(84,143,1)
(114,69,1)
(104,38,1)
(100,150,1)
(8,23,1)
(49,22,1)
(72,36,1)
(2,105,1)
(15,131,1)
(113,108,1)
(5,38,1)
(22,41,1)
(60,28,1)
(42,31,1)
(89,128,1)
(109,38,1)
(1,152,1)
(58,5,1)
(33,59,1)
(119,42,1)
(0,13,1)
(142,38,1)
(53,7,1)
(98,40,1)
(69,74,1)
(129,153,1)
(17,80,1)
(138,7,1)
(96,9,1)
(57,129,1)
(146,108,1)
(111,36,1)
(80,129,1)
(139,52,1)
(44,51,1)
(137,106,1)
(3,10,1)
(54,133,1)
(105,52,1)
(14,75,1)
(126,39,1)
(101,99,1)
(62,107,1)
(27,79,1)
(131,70,1)
(112,60,1)
(153,108,1)
(85,32,1)
(103,46,1)
(79,8,1)
(46,145,1)
(82,110,1)
(28,108,1)
(31,66,1)
(104,20,1)
(48,137,1)
(153,26,1)
(121,30,1)
(23,142,1)
(109,3,1)
(132,104,1)
(19,74,1)
(118,132,1)
(76,122,1)
(86,14,1)
(95,151,1)
(20,25,1)
(47,98,1)
(59,112,1)
(84,97,1)
(24,142,1)
(92,49,1)
(67,139,1)
(114,125,1)
(106,103,1)
(28,121,1)
(23,24,1)
(51,78,1)
(82,68,1)
(36,38,1)
(81,134,1)
(91,140,1)
(102,83,1)
(99,67,1)
(21,83,1)
(128,138,1)
(145,17,1)
(51,108,1)
(88,81,1)
(36,119,1)
(104,68,1)
(50,108,1)
(9,86,1)
(75,111,1)
(117,5,1)
(40,73,1)
(124,55,1)
(30,35,1)
(150,0,1)
(137,108,1)
(107,82,1)
(6,31,1)
(66,4,1)
(148,34,1)
(152,38,1)
(41,88,1)
(17,144,1)
(155,149,1)
(34,89,1)
(93,71,1)
(61,132,1)
(113,15,1)
(151,152,1)
(93,18,1)
(32,108,1)
(127,154,1)
(43,87,1)
(63,153,1)
(152,90,1)
(87,27,1)
(146,62,1)
(115,54,1)
(138,53,1)
(130,135,1)
(125,69,1)
(4,58,1)
(32,148,1)
(134,50,1)
(10,113,1)
(105,127,1)
(134,37,1)
(149,115,1)
(5,130,1)
(108,93,1)
(52,124,1)
(111,72,1)
(69,19,1)
(142,2,1)
(78,47,1)
(85,155,1)
(70,64,1)
(80,57,1)
(35,126,1)
(151,1,1)
(129,63,1)
(144,80,1)
(85,101,1)
(143,114,1)
(7,12,1)
(83,48,1)
(25,6,1)
(13,109,1)
(101,91,1)
(150,141,1)
(90,76,1)
(64,146,1)
(12,100,1)
(50,33,1)
(94,84,1)
(74,51,1)
(7,108,1)
(88,134,1)
(74,44,1)
(58,117,1)
(136,118,1)
(110,94,1)
(154,99,1)
(83,137,1)
(71,136,1)
(26,92,1)
(40,29,1)
(7,108,2)
(49,22,2)
(87,132,2)
(150,35,2)
(127,52,2)
(52,124,2)
(75,31,2)
(94,35,2)
(61,132,2)
(25,6,2)
(106,35,2)
(93,6,2)
(40,35,2)
(70,35,2)
(26,35,2)
(27,132,2)
(118,6,2)
(42,31,2)
(43,132,2)
(17,80,2)
(28,35,2)
(137,108,2)
(71,132,2)
(50,108,2)
(144,35,2)
(105,132,2)
(150,141,2)
(128,35,2)
(20,6,2)
(84,35,2)
(104,38,2)
(66,4,2)
(109,10,2)
(10,35,2)
(69,74,2)
(146,108,2)
(151,35,2)
(75,111,2)
(79,8,2)
(34,128,2)
(136,6,2)
(9,31,2)
(93,132,2)
(139,52,2)
(132,104,2)
(122,35,2)
(102,35,2)
(58,5,2)
(99,52,2)
(101,99,2)
(84,143,2)
(109,35,2)
(32,108,2)
(33,35,2)
(46,35,2)
(118,132,2)
(96,9,2)
(82,68,2)
(96,31,2)
(153,35,2)
(128,138,2)
(100,35,2)
(8,23,2)
(37,35,2)
(85,32,2)
(142,132,2)
(95,35,2)
(24,132,2)
(35,108,2)
(114,35,2)
(80,129,2)
(0,35,2)
(76,35,2)
(21,83,2)
(59,35,2)
(1,35,2)
(22,45,2)
(52,132,2)
(129,153,2)
(12,35,2)
(129,35,2)
(153,108,2)
(115,35,2)
(36,31,2)
(132,6,2)
(15,35,2)
(19,35,2)
(149,35,2)
(152,38,2)
(10,113,2)
(29,35,2)
(53,35,2)
(55,132,2)
(83,35,2)
(148,35,2)
(112,35,2)
(143,35,2)
(151,152,2)
(54,35,2)
(113,35,2)
(154,52,2)
(98,35,2)
(126,6,2)
(91,140,2)
(62,35,2)
(85,155,2)
(51,35,2)
(92,35,2)
(84,97,2)
(60,35,2)
(14,31,2)
(57,35,2)
(69,35,2)
(133,35,2)
(9,14,2)
(41,35,2)
(136,132,2)
(108,132,2)
(22,35,2)
(95,151,2)
(35,6,2)
(108,6,2)
(101,132,2)
(2,132,2)
(63,35,2)
(30,35,2)
(142,38,2)
(50,35,2)
(44,35,2)
(14,75,2)
(152,35,2)
(88,35,2)
(3,35,2)
(23,142,2)
(104,68,2)
(91,132,2)
(85,101,2)
(34,35,2)
(134,35,2)
(71,6,2)
(4,58,2)
(23,132,2)
(137,35,2)
(48,35,2)
(67,52,2)
(103,35,2)
(138,35,2)
(94,84,2)
(28,108,2)
(134,50,2)
(145,35,2)
(60,28,2)
(39,132,2)
(51,108,2)
(90,35,2)
(35,132,2)
(110,35,2)
(32,35,2)
(39,6,2)
(146,35,2)
(74,35,2)
(49,35,2)
(40,73,2)
(138,7,2)
(74,51,2)
(93,18,2)
(121,35,2)
(81,35,2)
(5,38,2)
(107,35,2)
(89,35,2)
(72,31,2)
(83,137,2)
(112,60,2)
(47,35,2)
(155,35,2)
(108,93,2)
(6,96,2)
(64,35,2)
(119,31,2)
(78,35,2)
(125,35,2)
(88,134,2)
(7,35,2)
(98,40,2)
(82,35,2)
(149,115,2)
(126,132,2)
(140,132,2)
(111,36,2)
(114,69,2)
(104,6,2)
(86,31,2)
(109,38,2)
(80,35,2)
(131,35,2)
(111,31,2)
(13,35,2)
(17,35,2)
(79,132,2)
(150,108,2)
(113,108,2)
(36,38,2)
(133,95,2)
(143,114,2)
(124,132,2)
(8,132,2)
(21,35,2)
-----------------------------------
(0,zone)
(1,count)
(2,ct)
(3,net)
(4,&net->ct.count)
(5,net->ct)
(6,nf_conntrack_max &&\n\\n\\t    unlikely(atomic_read(&net->ct.count)
(7,ct->ct_general)
(8,&net->ct.count)
(9,atomic_read(&net->ct.count)
(10,&ct->ct_net)
(11,if (!conntrack_gc_work.early_drop)
(12,ct_general)
(13,ct)
(14,atomic_read(&net->ct.count)
(15,ct_net)
(16,if (nf_conntrack_max &&\n\\n\\t    unlikely(atomic_read(&net->ct.count)
(17,ct->tuplehash[IP_CT_DIR_ORIGINAL].hnnode.pprev)
(18,gfp_t gfp)
(19,hnnode)
(20,hash)
(21,ct->tuplehash[IP_CT_DIR_REPLY].tuple)
(22,*orig)
(23,net->ct.count)
(24,count)
(25,net)
(26,tuplehash)
(27,"nf_conntrack: table full, dropping packet\\n")
(28,ct->lock)
(29,repl)
(30,ct)
(31,nf_conntrack_max)
(32,return ct;)
(33,tuplehash)
(34,atomic_set(&ct->ct_general.use, 0)
(35,ct == NULL)
(36,net->ct)
(37,IP_CT_DIR_ORIGINAL)
(38,struct net *net)
(39,ct)
(40,*repl)
(41,orig)
(42,net)
(43,ENOMEM)
(44,IP_CT_DIR_REPLY)
(45,const struct nf_conntrack_tuple *orig)
(46,ct->tuplehash[IP_CT_DIR_ORIGINAL].hnnode.pprev = NULL)
(47,ct)
(48,IP_CT_DIR_REPLY)
(49,ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple = *orig)
(50,ct->tuplehash)
(51,ct->tuplehash)
(52,!conntrack_gc_work.early_drop)
(53,use)
(54,ENOMEM)
(55,early_drop)
(56,ct)
(57,hnnode)
(58,net->ct.count)
(59,ct)
(60,&ct->lock)
(61,conntrack_gc_work)
(62,status)
(63,IP_CT_DIR_ORIGINAL)
(64,0)
(65,if (ct == NULL)
(66,atomic_inc(&net->ct.count)
(67,early_drop)
(68,u32 hash)
(69,ct->tuplehash[IP_CT_DIR_REPLY].hnnode)
(70,ct->status = 0)
(71,gfp)
(72,count)
(73,const struct nf_conntrack_tuple *repl)
(74,ct->tuplehash[IP_CT_DIR_REPLY])
(75,&net->ct.count)
(76,net)
(77,)
(78,tuplehash)
(79,atomic_dec(&net->ct.count)
(80,ct->tuplehash[IP_CT_DIR_ORIGINAL].hnnode)
(81,tuple)
(82,*(unsigned long *)
(83,ct->tuplehash[IP_CT_DIR_REPLY])
(84,(unsigned long *)
(85,RET)
(86,nf_conntrack_max)
(87,net_warn_ratelimited("nf_conntrack: table full, dropping packet\\n")
(88,ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple)
(89,0)
(90,ct)
(91,ERR_PTR(-ENOMEM)
(92,ct)
(93,kmem_cache_alloc(nf_conntrack_cachep, gfp)
(94,*(unsigned long *)
(95,&net->ct.count)
(96,unlikely(atomic_read(&net->ct.count)
(97,unsigned long *)
(98,ct->tuplehash[IP_CT_DIR_REPLY].tuple = *repl)
(99,conntrack_gc_work.early_drop)
(100,ct)
(101,return ERR_PTR(-ENOMEM)
(102,tuple)
(103,ct)
(104,early_drop(net, hash)
(105,net)
(106,tuplehash)
(107,ct)
(108,ct = kmem_cache_alloc(nf_conntrack_cachep, gfp)
(109,write_pnet(&ct->ct_net, net)
(110,hash)
(111,net->ct.count)
(112,spin_lock_init(&ct->lock)
(113,ct->ct_net)
(114,ct->tuplehash[IP_CT_DIR_REPLY].hnnode.pprev)
(115,-ENOMEM)
(116,)
(117,count)
(118,ct)
(119,ct)
(120,)
(121,lock)
(122,goto out;)
(123,out:)
(124,conntrack_gc_work.early_drop)
(125,pprev)
(126,NULL)
(127,conntrack_gc_work.early_drop = true)
(128,&ct->ct_general.use)
(129,ct->tuplehash[IP_CT_DIR_ORIGINAL])
(130,ct)
(131,ct)
(132,!early_drop(net, hash)
(133,atomic_dec(&net->ct.count)
(134,ct->tuplehash[IP_CT_DIR_ORIGINAL])
(135,net)
(136,nf_conntrack_cachep)
(137,ct->tuplehash)
(138,ct->ct_general.use)
(139,conntrack_gc_work)
(140,-ENOMEM)
(141,const struct nf_conntrack_zone *zone)
(142,net->ct)
(143,&ct->tuplehash[IP_CT_DIR_REPLY].hnnode.pprev)
(144,pprev)
(145,NULL)
(146,ct->status)
(147,if (!early_drop(net, hash)
(148,ct)
(149,ERR_PTR(-ENOMEM)
(150,nf_ct_zone_add(ct, zone)
(151,net->ct.count)
(152,net->ct)
(153,ct->tuplehash)
(154,true)
(155,return ERR_PTR(-ENOMEM)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^