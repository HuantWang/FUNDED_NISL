-----label-----
1
-----code-----
int
sosetopt(struct socket *so, int level, int optname, struct mbuf *m0)
{
	int		error;
	struct mbuf	*m;

	error = 0;
	m = m0;
	if (level != SOL_SOCKET) {
		if (so->so_proto && so->so_proto->pr_ctloutput)
			return ((*so->so_proto->pr_ctloutput)
				  (PRCO_SETOPT, so, level, optname, &m0));
		error = ENOPROTOOPT;
	} else {
		switch (optname) {

		case SO_LINGER:
			if (m == NULL || m->m_len != sizeof(struct linger)) {
				error = EINVAL;
				goto bad;
			}
			so->so_linger = mtod(m, struct linger *)->l_linger;
			/* fall thru... */

		case SO_DEBUG:
		case SO_KEEPALIVE:
		case SO_DONTROUTE:
		case SO_USELOOPBACK:
		case SO_BROADCAST:
		case SO_REUSEADDR:
		case SO_REUSEPORT:
		case SO_OOBINLINE:
		case SO_TIMESTAMP:
			if (m == NULL || m->m_len < sizeof(int)) {
				error = EINVAL;
				goto bad;
			}
			if (*mtod(m, int *))
				so->so_options |= optname;
			else
				so->so_options &= ~optname;
			break;

		case SO_SNDBUF:
		case SO_RCVBUF:
		case SO_SNDLOWAT:
		case SO_RCVLOWAT:
		    {
			int optval;

			if (m == NULL || m->m_len < sizeof(int)) {
				error = EINVAL;
				goto bad;
			}

			/*
			 * Values < 1 make no sense for any of these
			 * options, so disallow them.
			 */
			optval = *mtod(m, int *);
			if (optval < 1) {
				error = EINVAL;
				goto bad;
			}

			switch (optname) {

			case SO_SNDBUF:
			case SO_RCVBUF:
				if (sbreserve(optname == SO_SNDBUF ?
				    &so->so_snd : &so->so_rcv,
				    (u_long) optval, so) == 0) {
					error = ENOBUFS;
					goto bad;
				}
				break;

			/*
			 * Make sure the low-water is never greater than
			 * the high-water.
			 */
			case SO_SNDLOWAT:
				so->so_snd.sb_lowat =
				    (optval > so->so_snd.sb_hiwat) ?
				    so->so_snd.sb_hiwat : optval;
				break;
			case SO_RCVLOWAT:
				so->so_rcv.sb_lowat =
				    (optval > so->so_rcv.sb_hiwat) ?
				    so->so_rcv.sb_hiwat : optval;
				break;
			}
			break;
		    }

		case SO_SNDTIMEO:
		case SO_RCVTIMEO:
		    {
			struct timeval *tv;
			short val;

			if (m == NULL || m->m_len < sizeof(*tv)) {
				error = EINVAL;
				goto bad;
			}
			tv = mtod(m, struct timeval *);
			if (tv->tv_sec > (SHRT_MAX - tv->tv_usec / tick) / hz) {
				error = EDOM;
				goto bad;
			}
			val = tv->tv_sec * hz + tv->tv_usec / tick;
			if (val == 0 && tv->tv_usec != 0)
				val = 1;

			switch (optname) {

			case SO_SNDTIMEO:
				so->so_snd.sb_timeo = val;
				break;
			case SO_RCVTIMEO:
				so->so_rcv.sb_timeo = val;
				break;
			}
			break;
		    }

		default:
			error = ENOPROTOOPT;
			break;
		}
		if (error == 0 && so->so_proto && so->so_proto->pr_ctloutput) {
			(void) ((*so->so_proto->pr_ctloutput)
				  (PRCO_SETOPT, so, level, optname, &m0));
			m = NULL;	/* freed by protocol */
		}
	}
 bad:
	if (m)
		(void) m_free(m);
	return (error);
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
3,7
3,8
5,6
5,7
6,7
8,9
8,10
11,12
11,13
13,14
15,16
15,17
17,18
19,20
19,21
20,21
22,23
22,24
25,26
25,27
25,28
25,29
25,30
25,31
25,32
26,27
27,28
27,29
29,30
31,32
32,33
32,34
33,34
35,36
35,37
38,39
39,40
39,41
40,41
43,44
44,45
44,46
45,46
47,48
49,50
49,51
49,52
50,51
50,52
51,52
53,54
55,56
55,57
56,57
56,58
57,58
57,59
58,59
58,60
59,60
62,63
62,64
63,64
63,65
64,65
68,69
69,70
70,71
70,72
70,73
70,74
70,75
70,76
71,72
72,73
73,74
73,75
74,75
74,76
75,76
79,80
81,82
83,84
85,86
87,88
88,89
90,91
91,92
91,93
92,93
94,95
96,97
96,98
97,98
97,99
98,99
100,101
100,102
100,103
100,104
100,105
100,106
100,107
100,108
100,109
100,110
100,111
100,112
100,113
100,114
100,115
100,116
100,117
100,118
100,119
100,120
100,121
100,122
100,123
100,124
100,125
100,126
101,102
102,103
104,105
104,106
105,106
105,107
106,107
106,108
107,108
109,110
111,112
111,113
112,113
112,114
113,114
116,117
117,118
117,119
118,119
121,122
121,123
122,123
123,124
123,125
124,125
126,127
128,129
130,131
131,132
132,133
134,135
135,136
137,138
138,139
140,141
141,142
143,144
144,145
146,147
147,148
149,150
150,151
152,153
153,154
155,156
156,157
158,159
158,160
159,160
159,161
160,161
160,162
161,162
163,164
165,166
165,167
166,167
166,168
167,168
170,171
171,172
171,173
174,175
174,176
175,176
176,177
176,178
177,178
179,180
181,182
183,184
183,185
183,186
184,185
185,186
186,187
186,188
187,188
187,189
188,189
191,192
193,194
194,195
194,196
195,196
195,197
196,197
199,200
200,201
203,204
204,205
206,207
207,208
209,210
210,211
212,213
213,214
215,216
215,217
215,218
215,219
215,220
215,221
216,217
217,218
217,219
219,220
221,222
221,223
222,223
222,224
223,224
223,225
224,225
226,227
228,229
228,230
229,230
229,231
230,231
233,234
234,235
234,236
237,238
237,239
238,239
239,240
239,241
240,241
242,243
244,245
246,247
247,248
247,249
248,249
248,250
249,250
252,253
252,254
253,254
254,255
254,256
255,256
257,258
259,260
261,262
261,263
262,263
264,265
264,266
264,267
264,268
264,269
264,270
264,271
264,272
264,273
264,274
265,266
266,267
268,269
269,270
271,272
271,273
272,273
272,274
273,274
273,275
273,276
273,277
274,275
276,277
276,278
276,279
277,278
277,279
278,279
280,281
282,283
283,284
283,285
284,285
287,288
288,289
288,290
289,290
292,293
292,294
293,294
293,295
294,295
297,298
299,300
302,303
302,304
303,304
304,305
304,306
305,306
307,308
309,310
312,313
313,314
315,316
316,317
316,318
317,318
317,319
318,319
318,320
319,320
323,324
323,325
323,326
324,325
325,326
325,327
326,327
328,329
328,330
329,330
329,331
330,331
334,335
334,336
335,336
335,337
336,337
340,341
343,344
344,345
346,347
347,348
347,349
348,349
348,350
349,350
349,351
350,351
354,355
354,356
354,357
355,356
356,357
356,358
357,358
359,360
359,361
360,361
360,362
361,362
365,366
365,367
366,367
366,368
367,368
371,372
375,376
376,377
378,379
379,380
381,382
381,383
381,384
381,385
381,386
381,387
381,388
381,389
381,390
382,383
383,384
383,385
384,385
386,387
386,388
389,390
390,391
390,392
392,393
394,395
394,396
395,396
395,397
396,397
396,398
397,398
399,400
401,402
401,403
402,403
402,404
403,404
406,407
407,408
408,409
409,410
411,412
411,413
412,413
413,414
413,415
414,415
416,417
418,419
420,421
421,422
421,423
422,423
422,424
423,424
423,425
424,425
427,428
427,429
428,429
429,430
429,431
430,431
432,433
432,434
433,434
433,435
434,435
437,438
439,440
441,442
441,443
442,443
443,444
443,445
444,445
446,447
448,449
450,451
451,452
451,453
452,453
454,455
454,456
455,456
455,457
456,457
456,458
457,458
460,461
462,463
462,464
463,464
463,465
464,465
467,468
469,470
469,471
470,471
470,472
471,472
471,473
472,473
475,476
475,477
476,477
476,478
477,478
481,482
482,483
482,484
483,484
486,487
486,488
487,488
489,490
489,491
489,492
489,493
489,494
489,495
490,491
491,492
493,494
494,495
494,496
495,496
495,497
496,497
496,498
497,498
501,502
504,505
505,506
507,508
508,509
508,510
509,510
509,511
510,511
510,512
511,512
515,516
520,521
521,522
521,523
522,523
524,525
527,528
527,529
528,529
528,530
529,530
529,531
530,531
530,532
531,532
534,535
534,536
535,536
538,539
538,540
539,540
539,541
540,541
544,545
544,546
545,546
546,547
546,548
547,548
547,549
550,551
551,552
551,553
551,554
551,555
551,556
551,557
552,553
553,554
554,555
554,556
555,556
555,557
556,557
560,561
562,563
564,565
566,567
568,569
569,570
571,572
572,573
572,574
573,574
575,576
577,578
577,579
579,580
579,581
580,581
582,583
583,584
583,585
584,585
584,586
587,588
587,589
588,589
590,591
592,593
593,594
594,595
-----nextToken-----
2,4,7,9,10,12,14,16,18,21,23,24,28,30,34,36,37,41,42,46,48,52,54,60,61,65,66,67,76,77,78,80,82,84,86,89,93,95,99,103,108,110,114,115,119,120,125,127,129,133,136,139,142,145,148,151,154,157,162,164,168,169,172,173,178,180,182,189,190,192,197,198,201,202,205,208,211,214,218,220,225,227,231,232,235,236,241,243,245,250,251,256,258,260,263,267,270,275,279,281,285,286,290,291,295,296,298,300,301,306,308,310,311,314,320,321,322,327,331,332,333,337,338,339,341,342,345,351,352,353,358,362,363,364,368,369,370,372,373,374,377,380,385,387,388,391,393,398,400,404,405,410,415,417,419,425,426,431,435,436,438,440,445,447,449,453,458,459,461,465,466,468,473,474,478,479,480,484,485,488,492,498,499,500,502,503,506,512,513,514,516,517,518,519,523,525,526,532,533,536,537,541,542,543,548,549,557,558,559,561,563,565,567,570,574,576,578,581,585,586,589,591,595
-----computeFrom-----
39,40
39,41
44,45
44,46
50,51
50,52
57,58
57,59
91,92
91,93
105,106
105,107
106,107
106,108
111,112
111,113
123,124
123,125
159,160
159,161
160,161
160,162
165,166
165,167
176,177
176,178
186,187
186,188
194,195
194,196
222,223
222,224
223,224
223,225
228,229
228,230
239,240
239,241
248,249
248,250
254,255
254,256
272,273
272,274
277,278
277,279
304,305
304,306
316,317
316,318
325,326
325,327
347,348
347,349
356,357
356,358
395,396
395,397
396,397
396,398
401,402
401,403
413,414
413,415
422,423
422,424
427,428
427,429
429,430
429,431
432,433
432,434
443,444
443,445
451,452
451,453
454,455
454,456
455,456
455,457
462,463
462,464
470,471
470,472
471,472
471,473
475,476
475,477
482,483
482,484
494,495
494,496
508,509
508,510
521,522
521,523
528,529
528,530
529,530
529,531
530,531
530,532
572,573
572,574
-----guardedBy-----
52,84
66,77
65,82
67,78
473,484
542,558
541,563
543,559
-----guardedByNegation-----
52,565
-----lastLexicalUse-----
52,565
-----jump-----
52,565
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;ReturnStatement;UnaryExpression;FunctionCallExpression;UnaryExpression;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;SwitchStatement;IdExpression;Name;CompoundStatement;CaseStatement;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;TypeIdExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;GotoStatement;Name;ProblemStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;TypeIdExpression;TypeId;SimpleDeclSpecifier;Declarator;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;GotoStatement;Name;IfStatement;ProblemExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;TypeIdExpression;TypeId;SimpleDeclSpecifier;Declarator;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;GotoStatement;Name;ProblemStatement;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;GotoStatement;Name;SwitchStatement;IdExpression;Name;CompoundStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;ConditionalExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;GotoStatement;Name;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;ConditionalExpression;UnaryExpression;BinaryExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;ConditionalExpression;UnaryExpression;BinaryExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;BreakStatement;BreakStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;GotoStatement;Name;ProblemStatement;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;GotoStatement;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;SwitchStatement;IdExpression;Name;CompoundStatement;CaseStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;BreakStatement;BreakStatement;DefaultStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BreakStatement;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;UnaryExpression;FunctionCallExpression;UnaryExpression;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;LabelStatement;Name;IfStatement;IdExpression;Name;ExpressionStatement;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;UnaryExpression;IdExpression;Name;
-----ast_node-----
intsosetopt(struct socket *so, int level, int optname, struct mbuf *m0){	int		error;	struct mbuf	*m;	error = 0;	m = m0;	if (level != SOL_SOCKET) {		if (so->so_proto && so->so_proto->pr_ctloutput)			return ((*so->so_proto->pr_ctloutput)				  (PRCO_SETOPT, so, level, optname, &m0));		error = ENOPROTOOPT;	} else {		switch (optname) {		case SO_LINGER:			if (m == NULL || m->m_len != sizeof(struct linger)) {				error = EINVAL;				goto bad;			}			so->so_linger = mtod(m, struct linger *)->l_linger;			/* fall thru... */		case SO_DEBUG:		case SO_KEEPALIVE:		case SO_DONTROUTE:		case SO_USELOOPBACK:		case SO_BROADCAST:		case SO_REUSEADDR:		case SO_REUSEPORT:		case SO_OOBINLINE:		case SO_TIMESTAMP:			if (m == NULL || m->m_len < sizeof(int)) {				error = EINVAL;				goto bad;			}			if (*mtod(m, int *))				so->so_options |= optname;			else				so->so_options &= ~optname;			break;		case SO_SNDBUF:		case SO_RCVBUF:		case SO_SNDLOWAT:		case SO_RCVLOWAT:		    {			int optval;			if (m == NULL || m->m_len < sizeof(int)) {				error = EINVAL;				goto bad;			}			/*			 * Values < 1 make no sense for any of these			 * options, so disallow them.			 */			optval = *mtod(m, int *);			if (optval < 1) {				error = EINVAL;				goto bad;			}			switch (optname) {			case SO_SNDBUF:			case SO_RCVBUF:				if (sbreserve(optname == SO_SNDBUF ?				    &so->so_snd : &so->so_rcv,				    (u_long) optval, so) == 0) {					error = ENOBUFS;					goto bad;				}				break;			/*			 * Make sure the low-water is never greater than			 * the high-water.			 */			case SO_SNDLOWAT:				so->so_snd.sb_lowat =				    (optval > so->so_snd.sb_hiwat) ?				    so->so_snd.sb_hiwat : optval;				break;			case SO_RCVLOWAT:				so->so_rcv.sb_lowat =				    (optval > so->so_rcv.sb_hiwat) ?				    so->so_rcv.sb_hiwat : optval;				break;			}			break;		    }		case SO_SNDTIMEO:		case SO_RCVTIMEO:		    {			struct timeval *tv;			short val;			if (m == NULL || m->m_len < sizeof(*tv)) {				error = EINVAL;				goto bad;			}			tv = mtod(m, struct timeval *);			if (tv->tv_sec > (SHRT_MAX - tv->tv_usec / tick) / hz) {				error = EDOM;				goto bad;			}			val = tv->tv_sec * hz + tv->tv_usec / tick;			if (val == 0 && tv->tv_usec != 0)				val = 1;			switch (optname) {			case SO_SNDTIMEO:				so->so_snd.sb_timeo = val;				break;			case SO_RCVTIMEO:				so->so_rcv.sb_timeo = val;				break;			}			break;		    }		default:			error = ENOPROTOOPT;			break;		}		if (error == 0 && so->so_proto && so->so_proto->pr_ctloutput) {			(void) ((*so->so_proto->pr_ctloutput)				  (PRCO_SETOPT, so, level, optname, &m0));			m = NULL;	/* freed by protocol */		}	} bad:	if (m)		(void) m_free(m);	return (error);}
int
sosetopt(struct socket *so, int level, int optname, struct mbuf *m0)
sosetopt
struct socket *so
struct socket
socket
*so
*
so
int level
int
level
level
int optname
int
optname
optname
struct mbuf *m0
struct mbuf
mbuf
*m0
*
m0
{	int		error;	struct mbuf	*m;	error = 0;	m = m0;	if (level != SOL_SOCKET) {		if (so->so_proto && so->so_proto->pr_ctloutput)			return ((*so->so_proto->pr_ctloutput)				  (PRCO_SETOPT, so, level, optname, &m0));		error = ENOPROTOOPT;	} else {		switch (optname) {		case SO_LINGER:			if (m == NULL || m->m_len != sizeof(struct linger)) {				error = EINVAL;				goto bad;			}			so->so_linger = mtod(m, struct linger *)->l_linger;			/* fall thru... */		case SO_DEBUG:		case SO_KEEPALIVE:		case SO_DONTROUTE:		case SO_USELOOPBACK:		case SO_BROADCAST:		case SO_REUSEADDR:		case SO_REUSEPORT:		case SO_OOBINLINE:		case SO_TIMESTAMP:			if (m == NULL || m->m_len < sizeof(int)) {				error = EINVAL;				goto bad;			}			if (*mtod(m, int *))				so->so_options |= optname;			else				so->so_options &= ~optname;			break;		case SO_SNDBUF:		case SO_RCVBUF:		case SO_SNDLOWAT:		case SO_RCVLOWAT:		    {			int optval;			if (m == NULL || m->m_len < sizeof(int)) {				error = EINVAL;				goto bad;			}			/*			 * Values < 1 make no sense for any of these			 * options, so disallow them.			 */			optval = *mtod(m, int *);			if (optval < 1) {				error = EINVAL;				goto bad;			}			switch (optname) {			case SO_SNDBUF:			case SO_RCVBUF:				if (sbreserve(optname == SO_SNDBUF ?				    &so->so_snd : &so->so_rcv,				    (u_long) optval, so) == 0) {					error = ENOBUFS;					goto bad;				}				break;			/*			 * Make sure the low-water is never greater than			 * the high-water.			 */			case SO_SNDLOWAT:				so->so_snd.sb_lowat =				    (optval > so->so_snd.sb_hiwat) ?				    so->so_snd.sb_hiwat : optval;				break;			case SO_RCVLOWAT:				so->so_rcv.sb_lowat =				    (optval > so->so_rcv.sb_hiwat) ?				    so->so_rcv.sb_hiwat : optval;				break;			}			break;		    }		case SO_SNDTIMEO:		case SO_RCVTIMEO:		    {			struct timeval *tv;			short val;			if (m == NULL || m->m_len < sizeof(*tv)) {				error = EINVAL;				goto bad;			}			tv = mtod(m, struct timeval *);			if (tv->tv_sec > (SHRT_MAX - tv->tv_usec / tick) / hz) {				error = EDOM;				goto bad;			}			val = tv->tv_sec * hz + tv->tv_usec / tick;			if (val == 0 && tv->tv_usec != 0)				val = 1;			switch (optname) {			case SO_SNDTIMEO:				so->so_snd.sb_timeo = val;				break;			case SO_RCVTIMEO:				so->so_rcv.sb_timeo = val;				break;			}			break;		    }		default:			error = ENOPROTOOPT;			break;		}		if (error == 0 && so->so_proto && so->so_proto->pr_ctloutput) {			(void) ((*so->so_proto->pr_ctloutput)				  (PRCO_SETOPT, so, level, optname, &m0));			m = NULL;	/* freed by protocol */		}	} bad:	if (m)		(void) m_free(m);	return (error);}
int		error;
int		error;
int
error
error
struct mbuf	*m;
struct mbuf	*m;
struct mbuf
mbuf
*m
*
m
error = 0;
error = 0
error
error
0
m = m0;
m = m0
m
m
m0
m0
if (level != SOL_SOCKET) {		if (so->so_proto && so->so_proto->pr_ctloutput)			return ((*so->so_proto->pr_ctloutput)				  (PRCO_SETOPT, so, level, optname, &m0));		error = ENOPROTOOPT;	} else {		switch (optname) {		case SO_LINGER:			if (m == NULL || m->m_len != sizeof(struct linger)) {				error = EINVAL;				goto bad;			}			so->so_linger = mtod(m, struct linger *)->l_linger;			/* fall thru... */		case SO_DEBUG:		case SO_KEEPALIVE:		case SO_DONTROUTE:		case SO_USELOOPBACK:		case SO_BROADCAST:		case SO_REUSEADDR:		case SO_REUSEPORT:		case SO_OOBINLINE:		case SO_TIMESTAMP:			if (m == NULL || m->m_len < sizeof(int)) {				error = EINVAL;				goto bad;			}			if (*mtod(m, int *))				so->so_options |= optname;			else				so->so_options &= ~optname;			break;		case SO_SNDBUF:		case SO_RCVBUF:		case SO_SNDLOWAT:		case SO_RCVLOWAT:		    {			int optval;			if (m == NULL || m->m_len < sizeof(int)) {				error = EINVAL;				goto bad;			}			/*			 * Values < 1 make no sense for any of these			 * options, so disallow them.			 */			optval = *mtod(m, int *);			if (optval < 1) {				error = EINVAL;				goto bad;			}			switch (optname) {			case SO_SNDBUF:			case SO_RCVBUF:				if (sbreserve(optname == SO_SNDBUF ?				    &so->so_snd : &so->so_rcv,				    (u_long) optval, so) == 0) {					error = ENOBUFS;					goto bad;				}				break;			/*			 * Make sure the low-water is never greater than			 * the high-water.			 */			case SO_SNDLOWAT:				so->so_snd.sb_lowat =				    (optval > so->so_snd.sb_hiwat) ?				    so->so_snd.sb_hiwat : optval;				break;			case SO_RCVLOWAT:				so->so_rcv.sb_lowat =				    (optval > so->so_rcv.sb_hiwat) ?				    so->so_rcv.sb_hiwat : optval;				break;			}			break;		    }		case SO_SNDTIMEO:		case SO_RCVTIMEO:		    {			struct timeval *tv;			short val;			if (m == NULL || m->m_len < sizeof(*tv)) {				error = EINVAL;				goto bad;			}			tv = mtod(m, struct timeval *);			if (tv->tv_sec > (SHRT_MAX - tv->tv_usec / tick) / hz) {				error = EDOM;				goto bad;			}			val = tv->tv_sec * hz + tv->tv_usec / tick;			if (val == 0 && tv->tv_usec != 0)				val = 1;			switch (optname) {			case SO_SNDTIMEO:				so->so_snd.sb_timeo = val;				break;			case SO_RCVTIMEO:				so->so_rcv.sb_timeo = val;				break;			}			break;		    }		default:			error = ENOPROTOOPT;			break;		}		if (error == 0 && so->so_proto && so->so_proto->pr_ctloutput) {			(void) ((*so->so_proto->pr_ctloutput)				  (PRCO_SETOPT, so, level, optname, &m0));			m = NULL;	/* freed by protocol */		}	}
level != SOL_SOCKET
level
level
SOL_SOCKET
SOL_SOCKET
{		if (so->so_proto && so->so_proto->pr_ctloutput)			return ((*so->so_proto->pr_ctloutput)				  (PRCO_SETOPT, so, level, optname, &m0));		error = ENOPROTOOPT;	}
if (so->so_proto && so->so_proto->pr_ctloutput)			return ((*so->so_proto->pr_ctloutput)				  (PRCO_SETOPT, so, level, optname, &m0));
so->so_proto && so->so_proto->pr_ctloutput
so->so_proto
so
so
so_proto
so->so_proto->pr_ctloutput
so->so_proto
so
so
so_proto
pr_ctloutput
return ((*so->so_proto->pr_ctloutput)				  (PRCO_SETOPT, so, level, optname, &m0));
((*so->so_proto->pr_ctloutput)				  (PRCO_SETOPT, so, level, optname, &m0))
(*so->so_proto->pr_ctloutput)				  (PRCO_SETOPT, so, level, optname, &m0)
(*so->so_proto->pr_ctloutput)
*so->so_proto->pr_ctloutput
so->so_proto->pr_ctloutput
so->so_proto
so
so
so_proto
pr_ctloutput
PRCO_SETOPT
PRCO_SETOPT
so
so
level
level
optname
optname
&m0
m0
m0
error = ENOPROTOOPT;
error = ENOPROTOOPT
error
error
ENOPROTOOPT
ENOPROTOOPT
{		switch (optname) {		case SO_LINGER:			if (m == NULL || m->m_len != sizeof(struct linger)) {				error = EINVAL;				goto bad;			}			so->so_linger = mtod(m, struct linger *)->l_linger;			/* fall thru... */		case SO_DEBUG:		case SO_KEEPALIVE:		case SO_DONTROUTE:		case SO_USELOOPBACK:		case SO_BROADCAST:		case SO_REUSEADDR:		case SO_REUSEPORT:		case SO_OOBINLINE:		case SO_TIMESTAMP:			if (m == NULL || m->m_len < sizeof(int)) {				error = EINVAL;				goto bad;			}			if (*mtod(m, int *))				so->so_options |= optname;			else				so->so_options &= ~optname;			break;		case SO_SNDBUF:		case SO_RCVBUF:		case SO_SNDLOWAT:		case SO_RCVLOWAT:		    {			int optval;			if (m == NULL || m->m_len < sizeof(int)) {				error = EINVAL;				goto bad;			}			/*			 * Values < 1 make no sense for any of these			 * options, so disallow them.			 */			optval = *mtod(m, int *);			if (optval < 1) {				error = EINVAL;				goto bad;			}			switch (optname) {			case SO_SNDBUF:			case SO_RCVBUF:				if (sbreserve(optname == SO_SNDBUF ?				    &so->so_snd : &so->so_rcv,				    (u_long) optval, so) == 0) {					error = ENOBUFS;					goto bad;				}				break;			/*			 * Make sure the low-water is never greater than			 * the high-water.			 */			case SO_SNDLOWAT:				so->so_snd.sb_lowat =				    (optval > so->so_snd.sb_hiwat) ?				    so->so_snd.sb_hiwat : optval;				break;			case SO_RCVLOWAT:				so->so_rcv.sb_lowat =				    (optval > so->so_rcv.sb_hiwat) ?				    so->so_rcv.sb_hiwat : optval;				break;			}			break;		    }		case SO_SNDTIMEO:		case SO_RCVTIMEO:		    {			struct timeval *tv;			short val;			if (m == NULL || m->m_len < sizeof(*tv)) {				error = EINVAL;				goto bad;			}			tv = mtod(m, struct timeval *);			if (tv->tv_sec > (SHRT_MAX - tv->tv_usec / tick) / hz) {				error = EDOM;				goto bad;			}			val = tv->tv_sec * hz + tv->tv_usec / tick;			if (val == 0 && tv->tv_usec != 0)				val = 1;			switch (optname) {			case SO_SNDTIMEO:				so->so_snd.sb_timeo = val;				break;			case SO_RCVTIMEO:				so->so_rcv.sb_timeo = val;				break;			}			break;		    }		default:			error = ENOPROTOOPT;			break;		}		if (error == 0 && so->so_proto && so->so_proto->pr_ctloutput) {			(void) ((*so->so_proto->pr_ctloutput)				  (PRCO_SETOPT, so, level, optname, &m0));			m = NULL;	/* freed by protocol */		}	}
switch (optname) {		case SO_LINGER:			if (m == NULL || m->m_len != sizeof(struct linger)) {				error = EINVAL;				goto bad;			}			so->so_linger = mtod(m, struct linger *)->l_linger;			/* fall thru... */		case SO_DEBUG:		case SO_KEEPALIVE:		case SO_DONTROUTE:		case SO_USELOOPBACK:		case SO_BROADCAST:		case SO_REUSEADDR:		case SO_REUSEPORT:		case SO_OOBINLINE:		case SO_TIMESTAMP:			if (m == NULL || m->m_len < sizeof(int)) {				error = EINVAL;				goto bad;			}			if (*mtod(m, int *))				so->so_options |= optname;			else				so->so_options &= ~optname;			break;		case SO_SNDBUF:		case SO_RCVBUF:		case SO_SNDLOWAT:		case SO_RCVLOWAT:		    {			int optval;			if (m == NULL || m->m_len < sizeof(int)) {				error = EINVAL;				goto bad;			}			/*			 * Values < 1 make no sense for any of these			 * options, so disallow them.			 */			optval = *mtod(m, int *);			if (optval < 1) {				error = EINVAL;				goto bad;			}			switch (optname) {			case SO_SNDBUF:			case SO_RCVBUF:				if (sbreserve(optname == SO_SNDBUF ?				    &so->so_snd : &so->so_rcv,				    (u_long) optval, so) == 0) {					error = ENOBUFS;					goto bad;				}				break;			/*			 * Make sure the low-water is never greater than			 * the high-water.			 */			case SO_SNDLOWAT:				so->so_snd.sb_lowat =				    (optval > so->so_snd.sb_hiwat) ?				    so->so_snd.sb_hiwat : optval;				break;			case SO_RCVLOWAT:				so->so_rcv.sb_lowat =				    (optval > so->so_rcv.sb_hiwat) ?				    so->so_rcv.sb_hiwat : optval;				break;			}			break;		    }		case SO_SNDTIMEO:		case SO_RCVTIMEO:		    {			struct timeval *tv;			short val;			if (m == NULL || m->m_len < sizeof(*tv)) {				error = EINVAL;				goto bad;			}			tv = mtod(m, struct timeval *);			if (tv->tv_sec > (SHRT_MAX - tv->tv_usec / tick) / hz) {				error = EDOM;				goto bad;			}			val = tv->tv_sec * hz + tv->tv_usec / tick;			if (val == 0 && tv->tv_usec != 0)				val = 1;			switch (optname) {			case SO_SNDTIMEO:				so->so_snd.sb_timeo = val;				break;			case SO_RCVTIMEO:				so->so_rcv.sb_timeo = val;				break;			}			break;		    }		default:			error = ENOPROTOOPT;			break;		}
optname
optname
{		case SO_LINGER:			if (m == NULL || m->m_len != sizeof(struct linger)) {				error = EINVAL;				goto bad;			}			so->so_linger = mtod(m, struct linger *)->l_linger;			/* fall thru... */		case SO_DEBUG:		case SO_KEEPALIVE:		case SO_DONTROUTE:		case SO_USELOOPBACK:		case SO_BROADCAST:		case SO_REUSEADDR:		case SO_REUSEPORT:		case SO_OOBINLINE:		case SO_TIMESTAMP:			if (m == NULL || m->m_len < sizeof(int)) {				error = EINVAL;				goto bad;			}			if (*mtod(m, int *))				so->so_options |= optname;			else				so->so_options &= ~optname;			break;		case SO_SNDBUF:		case SO_RCVBUF:		case SO_SNDLOWAT:		case SO_RCVLOWAT:		    {			int optval;			if (m == NULL || m->m_len < sizeof(int)) {				error = EINVAL;				goto bad;			}			/*			 * Values < 1 make no sense for any of these			 * options, so disallow them.			 */			optval = *mtod(m, int *);			if (optval < 1) {				error = EINVAL;				goto bad;			}			switch (optname) {			case SO_SNDBUF:			case SO_RCVBUF:				if (sbreserve(optname == SO_SNDBUF ?				    &so->so_snd : &so->so_rcv,				    (u_long) optval, so) == 0) {					error = ENOBUFS;					goto bad;				}				break;			/*			 * Make sure the low-water is never greater than			 * the high-water.			 */			case SO_SNDLOWAT:				so->so_snd.sb_lowat =				    (optval > so->so_snd.sb_hiwat) ?				    so->so_snd.sb_hiwat : optval;				break;			case SO_RCVLOWAT:				so->so_rcv.sb_lowat =				    (optval > so->so_rcv.sb_hiwat) ?				    so->so_rcv.sb_hiwat : optval;				break;			}			break;		    }		case SO_SNDTIMEO:		case SO_RCVTIMEO:		    {			struct timeval *tv;			short val;			if (m == NULL || m->m_len < sizeof(*tv)) {				error = EINVAL;				goto bad;			}			tv = mtod(m, struct timeval *);			if (tv->tv_sec > (SHRT_MAX - tv->tv_usec / tick) / hz) {				error = EDOM;				goto bad;			}			val = tv->tv_sec * hz + tv->tv_usec / tick;			if (val == 0 && tv->tv_usec != 0)				val = 1;			switch (optname) {			case SO_SNDTIMEO:				so->so_snd.sb_timeo = val;				break;			case SO_RCVTIMEO:				so->so_rcv.sb_timeo = val;				break;			}			break;		    }		default:			error = ENOPROTOOPT;			break;		}
case SO_LINGER:
SO_LINGER
SO_LINGER
if (m == NULL || m->m_len != sizeof(struct linger)) {				error = EINVAL;				goto bad;			}
m == NULL || m->m_len != sizeof(struct linger)
m == NULL
m
m
NULL
NULL
m->m_len != sizeof(struct linger)
m->m_len
m
m
m_len
sizeof(struct linger)
struct linger
struct linger
linger

{				error = EINVAL;				goto bad;			}
error = EINVAL;
error = EINVAL
error
error
EINVAL
EINVAL
goto bad;
bad
so->so_linger = mtod(m, struct linger *)->l_linger;
case SO_DEBUG:
SO_DEBUG
SO_DEBUG
case SO_KEEPALIVE:
SO_KEEPALIVE
SO_KEEPALIVE
case SO_DONTROUTE:
SO_DONTROUTE
SO_DONTROUTE
case SO_USELOOPBACK:
SO_USELOOPBACK
SO_USELOOPBACK
case SO_BROADCAST:
SO_BROADCAST
SO_BROADCAST
case SO_REUSEADDR:
SO_REUSEADDR
SO_REUSEADDR
case SO_REUSEPORT:
SO_REUSEPORT
SO_REUSEPORT
case SO_OOBINLINE:
SO_OOBINLINE
SO_OOBINLINE
case SO_TIMESTAMP:
SO_TIMESTAMP
SO_TIMESTAMP
if (m == NULL || m->m_len < sizeof(int)) {				error = EINVAL;				goto bad;			}
m == NULL || m->m_len < sizeof(int)
m == NULL
m
m
NULL
NULL
m->m_len < sizeof(int)
m->m_len
m
m
m_len
sizeof(int)
int
int

{				error = EINVAL;				goto bad;			}
error = EINVAL;
error = EINVAL
error
error
EINVAL
EINVAL
goto bad;
bad
if (*mtod(m, int *))				so->so_options |= optname;			else				so->so_options &= ~optname;
*mtod(m, int *)
so->so_options |= optname;
so->so_options |= optname
so->so_options
so
so
so_options
optname
optname
so->so_options &= ~optname;
so->so_options &= ~optname
so->so_options
so
so
so_options
~optname
optname
optname
break;
case SO_SNDBUF:
SO_SNDBUF
SO_SNDBUF
case SO_RCVBUF:
SO_RCVBUF
SO_RCVBUF
case SO_SNDLOWAT:
SO_SNDLOWAT
SO_SNDLOWAT
case SO_RCVLOWAT:
SO_RCVLOWAT
SO_RCVLOWAT
{			int optval;			if (m == NULL || m->m_len < sizeof(int)) {				error = EINVAL;				goto bad;			}			/*			 * Values < 1 make no sense for any of these			 * options, so disallow them.			 */			optval = *mtod(m, int *);			if (optval < 1) {				error = EINVAL;				goto bad;			}			switch (optname) {			case SO_SNDBUF:			case SO_RCVBUF:				if (sbreserve(optname == SO_SNDBUF ?				    &so->so_snd : &so->so_rcv,				    (u_long) optval, so) == 0) {					error = ENOBUFS;					goto bad;				}				break;			/*			 * Make sure the low-water is never greater than			 * the high-water.			 */			case SO_SNDLOWAT:				so->so_snd.sb_lowat =				    (optval > so->so_snd.sb_hiwat) ?				    so->so_snd.sb_hiwat : optval;				break;			case SO_RCVLOWAT:				so->so_rcv.sb_lowat =				    (optval > so->so_rcv.sb_hiwat) ?				    so->so_rcv.sb_hiwat : optval;				break;			}			break;		    }
int optval;
int optval;
int
optval
optval
if (m == NULL || m->m_len < sizeof(int)) {				error = EINVAL;				goto bad;			}
m == NULL || m->m_len < sizeof(int)
m == NULL
m
m
NULL
NULL
m->m_len < sizeof(int)
m->m_len
m
m
m_len
sizeof(int)
int
int

{				error = EINVAL;				goto bad;			}
error = EINVAL;
error = EINVAL
error
error
EINVAL
EINVAL
goto bad;
bad
optval = *mtod(m, int *);
if (optval < 1) {				error = EINVAL;				goto bad;			}
optval < 1
optval
optval
1
{				error = EINVAL;				goto bad;			}
error = EINVAL;
error = EINVAL
error
error
EINVAL
EINVAL
goto bad;
bad
switch (optname) {			case SO_SNDBUF:			case SO_RCVBUF:				if (sbreserve(optname == SO_SNDBUF ?				    &so->so_snd : &so->so_rcv,				    (u_long) optval, so) == 0) {					error = ENOBUFS;					goto bad;				}				break;			/*			 * Make sure the low-water is never greater than			 * the high-water.			 */			case SO_SNDLOWAT:				so->so_snd.sb_lowat =				    (optval > so->so_snd.sb_hiwat) ?				    so->so_snd.sb_hiwat : optval;				break;			case SO_RCVLOWAT:				so->so_rcv.sb_lowat =				    (optval > so->so_rcv.sb_hiwat) ?				    so->so_rcv.sb_hiwat : optval;				break;			}
optname
optname
{			case SO_SNDBUF:			case SO_RCVBUF:				if (sbreserve(optname == SO_SNDBUF ?				    &so->so_snd : &so->so_rcv,				    (u_long) optval, so) == 0) {					error = ENOBUFS;					goto bad;				}				break;			/*			 * Make sure the low-water is never greater than			 * the high-water.			 */			case SO_SNDLOWAT:				so->so_snd.sb_lowat =				    (optval > so->so_snd.sb_hiwat) ?				    so->so_snd.sb_hiwat : optval;				break;			case SO_RCVLOWAT:				so->so_rcv.sb_lowat =				    (optval > so->so_rcv.sb_hiwat) ?				    so->so_rcv.sb_hiwat : optval;				break;			}
case SO_SNDBUF:
SO_SNDBUF
SO_SNDBUF
case SO_RCVBUF:
SO_RCVBUF
SO_RCVBUF
if (sbreserve(optname == SO_SNDBUF ?				    &so->so_snd : &so->so_rcv,				    (u_long) optval, so) == 0) {					error = ENOBUFS;					goto bad;				}
sbreserve(optname == SO_SNDBUF ?				    &so->so_snd : &so->so_rcv,				    (u_long) optval, so) == 0
sbreserve(optname == SO_SNDBUF ?				    &so->so_snd : &so->so_rcv,				    (u_long) optval, so)
sbreserve
sbreserve
optname == SO_SNDBUF ?				    &so->so_snd : &so->so_rcv
optname == SO_SNDBUF
optname
optname
SO_SNDBUF
SO_SNDBUF
&so->so_snd
so->so_snd
so
so
so_snd
&so->so_rcv
so->so_rcv
so
so
so_rcv
(u_long) optval
u_long
u_long
u_long

optval
optval
so
so
0
{					error = ENOBUFS;					goto bad;				}
error = ENOBUFS;
error = ENOBUFS
error
error
ENOBUFS
ENOBUFS
goto bad;
bad
break;
case SO_SNDLOWAT:
SO_SNDLOWAT
SO_SNDLOWAT
so->so_snd.sb_lowat =				    (optval > so->so_snd.sb_hiwat) ?				    so->so_snd.sb_hiwat : optval;
so->so_snd.sb_lowat =				    (optval > so->so_snd.sb_hiwat) ?				    so->so_snd.sb_hiwat : optval
so->so_snd.sb_lowat
so->so_snd
so
so
so_snd
sb_lowat
(optval > so->so_snd.sb_hiwat) ?				    so->so_snd.sb_hiwat : optval
(optval > so->so_snd.sb_hiwat)
optval > so->so_snd.sb_hiwat
optval
optval
so->so_snd.sb_hiwat
so->so_snd
so
so
so_snd
sb_hiwat
so->so_snd.sb_hiwat
so->so_snd
so
so
so_snd
sb_hiwat
optval
optval
break;
case SO_RCVLOWAT:
SO_RCVLOWAT
SO_RCVLOWAT
so->so_rcv.sb_lowat =				    (optval > so->so_rcv.sb_hiwat) ?				    so->so_rcv.sb_hiwat : optval;
so->so_rcv.sb_lowat =				    (optval > so->so_rcv.sb_hiwat) ?				    so->so_rcv.sb_hiwat : optval
so->so_rcv.sb_lowat
so->so_rcv
so
so
so_rcv
sb_lowat
(optval > so->so_rcv.sb_hiwat) ?				    so->so_rcv.sb_hiwat : optval
(optval > so->so_rcv.sb_hiwat)
optval > so->so_rcv.sb_hiwat
optval
optval
so->so_rcv.sb_hiwat
so->so_rcv
so
so
so_rcv
sb_hiwat
so->so_rcv.sb_hiwat
so->so_rcv
so
so
so_rcv
sb_hiwat
optval
optval
break;
break;
case SO_SNDTIMEO:
SO_SNDTIMEO
SO_SNDTIMEO
case SO_RCVTIMEO:
SO_RCVTIMEO
SO_RCVTIMEO
{			struct timeval *tv;			short val;			if (m == NULL || m->m_len < sizeof(*tv)) {				error = EINVAL;				goto bad;			}			tv = mtod(m, struct timeval *);			if (tv->tv_sec > (SHRT_MAX - tv->tv_usec / tick) / hz) {				error = EDOM;				goto bad;			}			val = tv->tv_sec * hz + tv->tv_usec / tick;			if (val == 0 && tv->tv_usec != 0)				val = 1;			switch (optname) {			case SO_SNDTIMEO:				so->so_snd.sb_timeo = val;				break;			case SO_RCVTIMEO:				so->so_rcv.sb_timeo = val;				break;			}			break;		    }
struct timeval *tv;
struct timeval *tv;
struct timeval
timeval
*tv
*
tv
short val;
short val;
short
val
val
if (m == NULL || m->m_len < sizeof(*tv)) {				error = EINVAL;				goto bad;			}
m == NULL || m->m_len < sizeof(*tv)
m == NULL
m
m
NULL
NULL
m->m_len < sizeof(*tv)
m->m_len
m
m
m_len
sizeof(*tv)
(*tv)
*tv
tv
tv
{				error = EINVAL;				goto bad;			}
error = EINVAL;
error = EINVAL
error
error
EINVAL
EINVAL
goto bad;
bad
tv = mtod(m, struct timeval *);
if (tv->tv_sec > (SHRT_MAX - tv->tv_usec / tick) / hz) {				error = EDOM;				goto bad;			}
tv->tv_sec > (SHRT_MAX - tv->tv_usec / tick) / hz
tv->tv_sec
tv
tv
tv_sec
(SHRT_MAX - tv->tv_usec / tick) / hz
(SHRT_MAX - tv->tv_usec / tick)
SHRT_MAX - tv->tv_usec / tick
SHRT_MAX
SHRT_MAX
tv->tv_usec / tick
tv->tv_usec
tv
tv
tv_usec
tick
tick
hz
hz
{				error = EDOM;				goto bad;			}
error = EDOM;
error = EDOM
error
error
EDOM
EDOM
goto bad;
bad
val = tv->tv_sec * hz + tv->tv_usec / tick;
val = tv->tv_sec * hz + tv->tv_usec / tick
val
val
tv->tv_sec * hz + tv->tv_usec / tick
tv->tv_sec * hz
tv->tv_sec
tv
tv
tv_sec
hz
hz
tv->tv_usec / tick
tv->tv_usec
tv
tv
tv_usec
tick
tick
if (val == 0 && tv->tv_usec != 0)				val = 1;
val == 0 && tv->tv_usec != 0
val == 0
val
val
0
tv->tv_usec != 0
tv->tv_usec
tv
tv
tv_usec
0
val = 1;
val = 1
val
val
1
switch (optname) {			case SO_SNDTIMEO:				so->so_snd.sb_timeo = val;				break;			case SO_RCVTIMEO:				so->so_rcv.sb_timeo = val;				break;			}
optname
optname
{			case SO_SNDTIMEO:				so->so_snd.sb_timeo = val;				break;			case SO_RCVTIMEO:				so->so_rcv.sb_timeo = val;				break;			}
case SO_SNDTIMEO:
SO_SNDTIMEO
SO_SNDTIMEO
so->so_snd.sb_timeo = val;
so->so_snd.sb_timeo = val
so->so_snd.sb_timeo
so->so_snd
so
so
so_snd
sb_timeo
val
val
break;
case SO_RCVTIMEO:
SO_RCVTIMEO
SO_RCVTIMEO
so->so_rcv.sb_timeo = val;
so->so_rcv.sb_timeo = val
so->so_rcv.sb_timeo
so->so_rcv
so
so
so_rcv
sb_timeo
val
val
break;
break;
default:
error = ENOPROTOOPT;
error = ENOPROTOOPT
error
error
ENOPROTOOPT
ENOPROTOOPT
break;
if (error == 0 && so->so_proto && so->so_proto->pr_ctloutput) {			(void) ((*so->so_proto->pr_ctloutput)				  (PRCO_SETOPT, so, level, optname, &m0));			m = NULL;	/* freed by protocol */		}
error == 0 && so->so_proto && so->so_proto->pr_ctloutput
error == 0 && so->so_proto
error == 0
error
error
0
so->so_proto
so
so
so_proto
so->so_proto->pr_ctloutput
so->so_proto
so
so
so_proto
pr_ctloutput
{			(void) ((*so->so_proto->pr_ctloutput)				  (PRCO_SETOPT, so, level, optname, &m0));			m = NULL;	/* freed by protocol */		}
(void) ((*so->so_proto->pr_ctloutput)				  (PRCO_SETOPT, so, level, optname, &m0));
(void) ((*so->so_proto->pr_ctloutput)				  (PRCO_SETOPT, so, level, optname, &m0))
void
void

((*so->so_proto->pr_ctloutput)				  (PRCO_SETOPT, so, level, optname, &m0))
(*so->so_proto->pr_ctloutput)				  (PRCO_SETOPT, so, level, optname, &m0)
(*so->so_proto->pr_ctloutput)
*so->so_proto->pr_ctloutput
so->so_proto->pr_ctloutput
so->so_proto
so
so
so_proto
pr_ctloutput
PRCO_SETOPT
PRCO_SETOPT
so
so
level
level
optname
optname
&m0
m0
m0
m = NULL;
m = NULL
m
m
NULL
NULL
bad:	if (m)		(void) m_free(m);
bad
if (m)		(void) m_free(m);
m
m
(void) m_free(m);
(void) m_free(m)
void
void

m_free(m)
m_free
m_free
m
m
return (error);
(error)
error
error
-----joern-----
(323,8,0)
(246,37,0)
(203,317,0)
(67,137,0)
(332,131,0)
(121,20,0)
(217,137,0)
(242,81,0)
(245,200,0)
(200,306,0)
(133,63,0)
(141,116,0)
(206,48,0)
(107,89,0)
(189,206,0)
(181,249,0)
(4,101,0)
(207,83,0)
(10,287,0)
(111,1,0)
(312,89,0)
(147,93,0)
(172,13,0)
(7,10,0)
(158,62,0)
(309,137,0)
(116,327,0)
(235,156,0)
(120,35,0)
(56,319,0)
(316,139,0)
(108,10,0)
(228,278,0)
(45,196,0)
(126,105,0)
(208,175,0)
(49,26,0)
(165,271,0)
(66,19,0)
(148,112,0)
(211,19,0)
(139,105,0)
(162,146,0)
(331,327,0)
(20,19,0)
(241,147,0)
(290,104,0)
(75,253,0)
(231,48,0)
(164,178,0)
(265,333,0)
(82,95,0)
(167,294,0)
(225,220,0)
(161,79,0)
(333,19,0)
(126,325,0)
(175,229,0)
(79,161,0)
(90,288,0)
(307,58,0)
(79,18,0)
(183,190,0)
(313,319,0)
(117,18,0)
(223,322,0)
(121,258,0)
(326,81,0)
(208,258,0)
(280,144,0)
(128,56,0)
(196,261,0)
(283,121,0)
(292,80,0)
(324,57,0)
(28,231,0)
(212,325,0)
(322,255,0)
(277,333,0)
(299,205,0)
(53,231,0)
(169,104,0)
(191,265,0)
(327,116,0)
(144,280,0)
(106,82,0)
(119,115,0)
(0,234,0)
(303,16,0)
(237,75,0)
(182,101,0)
(102,19,0)
(57,215,0)
(130,104,0)
(231,329,0)
(138,19,0)
(3,330,0)
(152,143,0)
(17,171,0)
(260,230,0)
(250,328,0)
(27,137,0)
(125,206,0)
(172,126,0)
(2,46,0)
(174,37,0)
(6,2,0)
(95,82,0)
(163,248,0)
(253,75,0)
(63,133,0)
(134,245,0)
(131,304,0)
(194,144,0)
(91,105,0)
(147,241,0)
(208,48,0)
(115,19,0)
(58,330,0)
(314,19,0)
(248,253,0)
(155,19,0)
(323,61,0)
(218,132,0)
(146,258,0)
(231,258,0)
(195,19,0)
(291,115,0)
(25,8,0)
(226,214,0)
(234,258,0)
(116,156,0)
(89,312,0)
(85,65,0)
(69,137,0)
(104,130,0)
(159,180,0)
(156,105,0)
(306,200,0)
(249,156,0)
(200,245,0)
(30,117,0)
(104,290,0)
(315,105,0)
(201,105,0)
(103,232,0)
(44,97,0)
(261,196,0)
(43,80,0)
(240,147,0)
(88,19,0)
(317,203,0)
(160,265,0)
(32,19,0)
(132,258,0)
(122,1,0)
(173,61,0)
(289,258,0)
(56,128,0)
(126,139,0)
(6,65,0)
(208,284,0)
(196,156,0)
(285,323,0)
(208,329,0)
(241,79,0)
(330,58,0)
(255,214,0)
(203,261,0)
(255,322,0)
(260,112,0)
(279,220,0)
(126,294,0)
(298,328,0)
(153,46,0)
(294,21,0)
(238,131,0)
(249,181,0)
(334,171,0)
(84,232,0)
(18,79,0)
(131,156,0)
(52,105,0)
(328,46,0)
(268,326,0)
(27,95,0)
(165,258,0)
(168,137,0)
(190,178,0)
(101,239,0)
(46,153,0)
(321,289,0)
(129,19,0)
(177,333,0)
(51,93,0)
(93,258,0)
(37,258,0)
(274,312,0)
(9,294,0)
(202,325,0)
(60,19,0)
(36,6,0)
(103,6,0)
(30,258,0)
(203,62,0)
(295,162,0)
(330,258,0)
(50,289,0)
(112,258,0)
(128,8,0)
(293,117,0)
(2,171,0)
(70,128,0)
(253,248,0)
(18,137,0)
(312,288,0)
(96,93,0)
(37,264,0)
(164,78,0)
(14,65,0)
(40,247,0)
(180,304,0)
(330,230,0)
(154,26,0)
(126,35,0)
(304,180,0)
(41,231,0)
(181,304,0)
(325,83,0)
(176,190,0)
(8,323,0)
(126,94,0)
(11,144,0)
(321,264,0)
(245,156,0)
(73,161,0)
(210,156,0)
(150,146,0)
(267,63,0)
(29,30,0)
(78,164,0)
(193,137,0)
(317,156,0)
(304,131,0)
(284,208,0)
(156,229,0)
(286,208,0)
(288,80,0)
(253,280,0)
(126,10,0)
(330,26,0)
(288,65,0)
(123,171,0)
(222,121,0)
(157,231,0)
(289,321,0)
(220,329,0)
(233,19,0)
(133,327,0)
(252,78,0)
(95,290,0)
(164,160,0)
(282,132,0)
(127,290,0)
(270,139,0)
(288,2,0)
(79,241,0)
(31,232,0)
(230,330,0)
(98,79,0)
(140,137,0)
(23,116,0)
(204,208,0)
(112,260,0)
(290,95,0)
(6,80,0)
(230,260,0)
(232,258,0)
(166,82,0)
(192,241,0)
(161,132,0)
(106,258,0)
(62,203,0)
(318,243,0)
(308,317,0)
(130,258,0)
(93,147,0)
(199,20,0)
(39,19,0)
(68,276,0)
(261,203,0)
(319,56,0)
(265,139,0)
(55,75,0)
(126,101,0)
(244,61,0)
(311,19,0)
(145,2,0)
(216,171,0)
(46,2,0)
(5,171,0)
(149,130,0)
(75,156,0)
(227,126,0)
(54,249,0)
(310,326,0)
(78,258,0)
(160,164,0)
(153,97,0)
(219,276,0)
(35,247,0)
(188,165,0)
(170,153,0)
(284,87,0)
(231,13,0)
(12,284,0)
(86,319,0)
(34,271,0)
(144,156,0)
(46,328,0)
(74,264,0)
(143,229,0)
(126,57,0)
(265,160,0)
(206,230,0)
(142,19,0)
(271,165,0)
(110,19,0)
(171,19,0)
(266,298,0)
(71,16,0)
(109,130,0)
(42,289,0)
(185,234,0)
(178,190,0)
(89,258,0)
(301,298,0)
(175,208,0)
(331,276,0)
(197,239,0)
(304,181,0)
(26,330,0)
(276,331,0)
(136,243,0)
(264,321,0)
(117,30,0)
(264,37,0)
(234,185,0)
(185,230,0)
(256,19,0)
(180,159,0)
(132,161,0)
(236,115,0)
(179,21,0)
(224,65,0)
(327,133,0)
(328,298,0)
(190,258,0)
(15,208,0)
(126,333,0)
(114,208,0)
(33,94,0)
(231,143,0)
(92,78,0)
(97,153,0)
(327,331,0)
(221,19,0)
(209,89,0)
(126,326,0)
(257,65,0)
(275,30,0)
(16,214,0)
(178,164,0)
(72,19,0)
(251,94,0)
(230,206,0)
(38,196,0)
(187,19,0)
(100,234,0)
(146,162,0)
(135,106,0)
(259,171,0)
(281,287,0)
(262,95,0)
(272,103,0)
(322,2,0)
(95,27,0)
(118,317,0)
(305,106,0)
(280,253,0)
(162,27,0)
(124,278,0)
(94,205,0)
(24,165,0)
(302,146,0)
(213,215,0)
(64,178,0)
(186,105,0)
(47,97,0)
(243,87,0)
(22,322,0)
(59,19,0)
(82,106,0)
(143,231,0)
(269,265,0)
(245,243,0)
(230,185,0)
(151,112,0)
(284,12,0)
(320,115,0)
(26,154,0)
(214,255,0)
(232,103,0)
(273,19,0)
(214,16,0)
(254,137,0)
(276,156,0)
(300,175,0)
(184,115,0)
(198,249,0)
(8,128,0)
(20,48,0)
(61,323,0)
(296,35,0)
(77,57,0)
(297,171,0)
(103,232,1)
(302,150,1)
(251,33,1)
(74,37,1)
(23,276,1)
(165,24,1)
(40,35,1)
(57,324,1)
(182,280,1)
(261,196,1)
(128,8,1)
(202,331,1)
(135,290,1)
(296,58,1)
(153,170,1)
(121,283,1)
(56,319,1)
(157,41,1)
(162,146,1)
(95,82,1)
(293,30,1)
(304,180,1)
(6,2,1)
(219,68,1)
(103,272,1)
(78,252,1)
(9,56,1)
(149,109,1)
(225,279,1)
(228,280,1)
(155,181,1)
(131,156,1)
(147,240,1)
(269,320,1)
(94,251,1)
(288,2,1)
(126,326,1)
(117,293,1)
(99,80,1)
(95,262,1)
(161,73,1)
(180,159,1)
(214,16,1)
(289,42,1)
(181,304,1)
(288,90,1)
(44,47,1)
(148,151,1)
(168,58,1)
(71,322,1)
(242,326,1)
(327,133,1)
(139,270,1)
(327,116,1)
(283,222,1)
(200,306,1)
(328,298,1)
(206,189,1)
(93,258,1)
(232,31,1)
(76,160,1)
(85,288,1)
(249,156,1)
(235,139,1)
(132,258,1)
(43,255,1)
(29,263,1)
(117,30,1)
(8,323,1)
(27,95,1)
(46,153,1)
(330,26,1)
(132,218,1)
(24,188,1)
(216,99,1)
(126,57,1)
(230,185,1)
(180,131,1)
(237,144,1)
(249,198,1)
(271,34,1)
(13,231,1)
(75,156,1)
(165,258,1)
(196,38,1)
(260,112,1)
(6,80,1)
(164,178,1)
(230,260,1)
(209,107,1)
(166,106,1)
(217,18,1)
(245,134,1)
(278,124,1)
(321,264,1)
(34,165,1)
(79,161,1)
(312,89,1)
(61,244,1)
(265,139,1)
(264,37,1)
(26,49,1)
(323,61,1)
(301,266,1)
(208,258,1)
(176,183,1)
(151,206,1)
(76,40,1)
(298,301,1)
(78,258,1)
(263,278,1)
(144,194,1)
(243,318,1)
(76,10,1)
(76,299,1)
(76,242,1)
(31,84,1)
(49,230,1)
(265,333,1)
(203,62,1)
(248,163,1)
(244,173,1)
(164,78,1)
(284,12,1)
(97,44,1)
(25,319,1)
(73,132,1)
(279,156,1)
(113,220,1)
(104,130,1)
(197,101,1)
(234,258,1)
(307,330,1)
(331,276,1)
(245,156,1)
(167,9,1)
(141,23,1)
(181,249,1)
(37,174,1)
(216,14,1)
(18,79,1)
(98,241,1)
(305,135,1)
(208,175,1)
(253,248,1)
(14,6,1)
(93,96,1)
(240,93,1)
(116,156,1)
(295,146,1)
(35,120,1)
(62,158,1)
(290,104,1)
(51,192,1)
(172,126,1)
(280,253,1)
(150,263,1)
(38,45,1)
(126,325,1)
(206,48,1)
(218,282,1)
(131,238,1)
(188,261,1)
(128,70,1)
(37,258,1)
(317,308,1)
(28,157,1)
(333,277,1)
(320,217,1)
(289,258,1)
(160,265,1)
(116,141,1)
(275,29,1)
(58,330,1)
(114,160,1)
(104,169,1)
(198,54,1)
(227,76,1)
(232,258,1)
(50,220,1)
(30,275,1)
(107,99,1)
(213,57,1)
(294,167,1)
(196,156,1)
(324,77,1)
(177,113,1)
(126,294,1)
(64,190,1)
(276,219,1)
(56,128,1)
(76,243,1)
(86,313,1)
(174,246,1)
(42,50,1)
(79,241,1)
(144,156,1)
(322,223,1)
(95,290,1)
(269,211,1)
(330,258,1)
(178,190,1)
(130,258,1)
(127,162,1)
(126,35,1)
(16,303,1)
(312,274,1)
(22,2,1)
(269,216,1)
(286,114,1)
(106,305,1)
(300,15,1)
(208,329,1)
(227,200,1)
(292,43,1)
(226,16,1)
(317,156,1)
(69,27,1)
(15,204,1)
(161,132,1)
(319,86,1)
(126,10,1)
(255,322,1)
(220,225,1)
(77,261,1)
(53,321,1)
(89,258,1)
(222,271,1)
(120,296,1)
(156,210,1)
(20,48,1)
(266,153,1)
(129,333,1)
(308,118,1)
(255,214,1)
(100,206,1)
(262,290,1)
(284,208,1)
(276,156,1)
(285,61,1)
(125,263,1)
(231,143,1)
(271,165,1)
(220,329,1)
(303,71,1)
(270,316,1)
(330,3,1)
(76,207,1)
(126,333,1)
(147,93,1)
(241,147,1)
(325,212,1)
(54,113,1)
(313,331,1)
(126,227,1)
(82,106,1)
(261,203,1)
(160,164,1)
(99,255,1)
(173,25,1)
(252,92,1)
(250,298,1)
(146,258,1)
(92,265,1)
(101,4,1)
(230,206,1)
(211,20,1)
(264,74,1)
(68,113,1)
(190,176,1)
(299,94,1)
(192,117,1)
(76,213,1)
(126,101,1)
(310,268,1)
(7,321,1)
(80,292,1)
(330,230,1)
(79,98,1)
(189,125,1)
(267,116,1)
(41,53,1)
(143,229,1)
(185,234,1)
(124,228,1)
(45,155,1)
(223,22,1)
(82,166,1)
(269,129,1)
(320,69,1)
(2,46,1)
(126,94,1)
(175,229,1)
(163,75,1)
(204,286,1)
(323,285,1)
(234,0,1)
(210,235,1)
(76,197,1)
(212,202,1)
(231,48,1)
(136,284,1)
(318,136,1)
(331,327,1)
(172,13,1)
(332,249,1)
(45,113,1)
(63,267,1)
(133,63,1)
(58,307,1)
(178,64,1)
(280,144,1)
(207,325,1)
(143,152,1)
(231,258,1)
(190,258,1)
(134,76,1)
(274,89,1)
(126,139,1)
(216,85,1)
(112,258,1)
(26,154,1)
(109,127,1)
(156,229,1)
(175,300,1)
(170,97,1)
(11,113,1)
(70,8,1)
(208,48,1)
(84,99,1)
(6,36,1)
(20,199,1)
(121,258,1)
(214,226,1)
(153,97,1)
(191,269,1)
(36,103,1)
(55,237,1)
(118,196,1)
(169,130,1)
(112,148,1)
(272,232,1)
(10,108,1)
(238,332,1)
(322,2,1)
(203,317,1)
(130,149,1)
(200,245,1)
(162,295,1)
(282,241,1)
(30,258,1)
(33,278,1)
(183,78,1)
(320,168,1)
(90,312,1)
(46,328,1)
(108,7,1)
(47,145,1)
(245,243,1)
(326,310,1)
(304,131,1)
(194,11,1)
(199,121,1)
(277,177,1)
(145,56,1)
(152,28,1)
(146,302,1)
(75,55,1)
(76,179,1)
(158,317,1)
(179,294,1)
(268,181,1)
(321,289,1)
(0,100,1)
(328,250,1)
(106,258,1)
(4,182,1)
(89,209,1)
(288,80,1)
(3,26,1)
(253,75,1)
(231,329,1)
(320,263,1)
(265,191,1)
(246,289,1)
(96,51,1)
(38,181,2)
(251,278,2)
(232,99,2)
(42,220,2)
(78,258,2)
(203,62,2)
(330,26,2)
(93,258,2)
(241,263,2)
(106,290,2)
(18,79,2)
(46,56,2)
(179,56,2)
(108,321,2)
(324,261,2)
(149,263,2)
(104,130,2)
(2,46,2)
(313,331,2)
(169,263,2)
(192,263,2)
(312,89,2)
(185,206,2)
(261,196,2)
(131,249,2)
(227,321,2)
(310,181,2)
(181,249,2)
(90,99,2)
(231,258,2)
(197,280,2)
(79,161,2)
(213,261,2)
(260,206,2)
(128,331,2)
(11,113,2)
(126,101,2)
(245,76,2)
(302,263,2)
(177,113,2)
(174,289,2)
(148,206,2)
(330,263,2)
(265,139,2)
(196,113,2)
(151,206,2)
(230,260,2)
(190,78,2)
(333,113,2)
(271,165,2)
(261,113,2)
(126,321,2)
(292,255,2)
(180,159,2)
(89,258,2)
(147,263,2)
(84,99,2)
(98,241,2)
(162,263,2)
(189,263,2)
(58,330,2)
(13,321,2)
(116,156,2)
(38,113,2)
(175,160,2)
(241,147,2)
(153,56,2)
(234,206,2)
(284,160,2)
(321,264,2)
(53,321,2)
(242,181,2)
(45,113,2)
(277,113,2)
(196,181,2)
(255,214,2)
(145,56,2)
(126,35,2)
(51,263,2)
(144,113,2)
(269,56,2)
(16,322,2)
(147,93,2)
(278,280,2)
(245,243,2)
(161,132,2)
(206,48,2)
(36,99,2)
(20,261,2)
(284,12,2)
(34,261,2)
(244,331,2)
(209,99,2)
(131,156,2)
(79,263,2)
(290,263,2)
(220,329,2)
(305,290,2)
(31,99,2)
(37,289,2)
(269,261,2)
(22,56,2)
(328,298,2)
(272,99,2)
(327,276,2)
(265,261,2)
(268,181,2)
(35,58,2)
(71,322,2)
(163,144,2)
(198,113,2)
(118,196,2)
(85,99,2)
(199,261,2)
(252,265,2)
(264,289,2)
(14,99,2)
(10,321,2)
(248,144,2)
(208,258,2)
(29,263,2)
(96,263,2)
(280,144,2)
(271,261,2)
(61,331,2)
(200,245,2)
(203,196,2)
(175,229,2)
(165,258,2)
(113,220,2)
(78,265,2)
(165,261,2)
(284,208,2)
(265,113,2)
(265,263,2)
(168,58,2)
(173,331,2)
(109,263,2)
(243,160,2)
(226,322,2)
(69,263,2)
(143,229,2)
(304,249,2)
(331,113,2)
(172,126,2)
(170,56,2)
(128,8,2)
(8,331,2)
(117,30,2)
(55,144,2)
(191,56,2)
(185,234,2)
(261,203,2)
(261,181,2)
(47,56,2)
(126,139,2)
(293,263,2)
(121,261,2)
(214,322,2)
(330,258,2)
(250,56,2)
(62,196,2)
(30,263,2)
(182,280,2)
(320,263,2)
(92,265,2)
(320,58,2)
(231,329,2)
(114,160,2)
(283,261,2)
(176,78,2)
(155,181,2)
(178,190,2)
(323,331,2)
(249,156,2)
(207,331,2)
(143,321,2)
(331,276,2)
(327,133,2)
(166,290,2)
(294,56,2)
(191,263,2)
(0,206,2)
(218,241,2)
(158,196,2)
(75,144,2)
(230,263,2)
(8,323,2)
(286,160,2)
(276,113,2)
(95,263,2)
(318,160,2)
(27,263,2)
(27,95,2)
(126,57,2)
(265,58,2)
(332,249,2)
(160,263,2)
(9,56,2)
(328,56,2)
(245,156,2)
(232,258,2)
(160,58,2)
(146,263,2)
(68,113,2)
(238,249,2)
(330,230,2)
(308,196,2)
(246,289,2)
(298,56,2)
(289,220,2)
(7,321,2)
(126,10,2)
(230,185,2)
(312,99,2)
(106,258,2)
(141,276,2)
(223,56,2)
(63,276,2)
(191,58,2)
(75,156,2)
(202,331,2)
(191,113,2)
(134,76,2)
(4,280,2)
(301,56,2)
(54,113,2)
(304,180,2)
(25,331,2)
(321,289,2)
(327,116,2)
(276,156,2)
(144,156,2)
(56,319,2)
(153,97,2)
(288,2,2)
(180,249,2)
(56,331,2)
(181,113,2)
(6,80,2)
(82,290,2)
(46,153,2)
(269,263,2)
(160,261,2)
(319,331,2)
(230,206,2)
(150,263,2)
(112,258,2)
(26,154,2)
(255,322,2)
(45,181,2)
(322,2,2)
(299,278,2)
(77,261,2)
(117,263,2)
(82,106,2)
(127,263,2)
(323,61,2)
(100,206,2)
(331,327,2)
(164,178,2)
(164,265,2)
(231,48,2)
(157,321,2)
(178,78,2)
(133,276,2)
(285,331,2)
(116,276,2)
(120,58,2)
(274,99,2)
(214,16,2)
(95,290,2)
(126,325,2)
(325,331,2)
(289,258,2)
(124,280,2)
(208,329,2)
(194,113,2)
(269,58,2)
(191,261,2)
(290,104,2)
(6,2,2)
(280,113,2)
(76,321,2)
(133,63,2)
(307,263,2)
(288,80,2)
(73,241,2)
(303,322,2)
(167,56,2)
(216,56,2)
(103,99,2)
(288,99,2)
(280,253,2)
(50,220,2)
(24,261,2)
(295,263,2)
(57,261,2)
(231,143,2)
(56,128,2)
(6,99,2)
(41,321,2)
(212,331,2)
(211,261,2)
(126,220,2)
(2,56,2)
(152,321,2)
(74,289,2)
(204,160,2)
(265,333,2)
(3,263,2)
(126,94,2)
(253,144,2)
(200,306,2)
(208,175,2)
(112,206,2)
(322,56,2)
(76,220,2)
(231,321,2)
(156,229,2)
(146,258,2)
(206,263,2)
(44,56,2)
(136,160,2)
(208,160,2)
(130,263,2)
(296,58,2)
(269,113,2)
(200,76,2)
(43,255,2)
(196,156,2)
(265,56,2)
(188,261,2)
(217,263,2)
(172,13,2)
(40,58,2)
(58,263,2)
(304,131,2)
(126,294,2)
(20,48,2)
(275,263,2)
(266,56,2)
(101,280,2)
(219,113,2)
(95,82,2)
(23,276,2)
(227,220,2)
(135,290,2)
(70,331,2)
(104,263,2)
(160,164,2)
(49,263,2)
(240,263,2)
(97,56,2)
(317,196,2)
(203,317,2)
(208,48,2)
(300,160,2)
(18,263,2)
(161,241,2)
(94,278,2)
(317,156,2)
(160,56,2)
(64,78,2)
(125,263,2)
(46,328,2)
(164,78,2)
(28,321,2)
(89,99,2)
(183,78,2)
(249,113,2)
(160,265,2)
(267,276,2)
(264,37,2)
(80,255,2)
(132,258,2)
(129,113,2)
(126,333,2)
(321,220,2)
(26,263,2)
(263,278,2)
(79,241,2)
(130,258,2)
(190,258,2)
(132,241,2)
(181,304,2)
(253,248,2)
(253,75,2)
(262,290,2)
(121,258,2)
(260,112,2)
(86,331,2)
(237,144,2)
(160,113,2)
(30,258,2)
(222,261,2)
(33,278,2)
(37,258,2)
(326,181,2)
(15,160,2)
(255,56,2)
(99,56,2)
(93,263,2)
(107,99,2)
(282,241,2)
(162,146,2)
(228,280,2)
(103,232,2)
(126,326,2)
(234,258,2)
-----------------------------------
(0,so_rcv)
(1,)
(2,val = tv->tv_sec * hz + tv->tv_usec / tick)
(3,so)
(4,EINVAL)
(5,if (m == NULL || m->m_len < sizeof(*tv)
(6,so->so_rcv.sb_timeo = val)
(7,error)
(8,SHRT_MAX - tv->tv_usec / tick)
(9,error)
(10,error = ENOPROTOOPT)
(11,m)
(12,void)
(13,return ((*so->so_proto->pr_ctloutput)
(14,break;)
(15,optname)
(16,tv->tv_usec)
(17,val)
(18,so->so_snd.sb_lowat =\n\\n\\t\\t\\t\\t    (optval > so->so_snd.sb_hiwat)
(19,)
(20,so->so_options |= optname)
(21,)
(22,val)
(23,m)
(24,so_options)
(25,SHRT_MAX)
(26,(u_long)
(27,so->so_rcv.sb_lowat =\n\\n\\t\\t\\t\\t    (optval > so->so_rcv.sb_hiwat)
(28,optname)
(29,so)
(30,so->so_snd)
(31,so_rcv)
(32,case SO_TIMESTAMP:)
(33,error)
(34,~optname)
(35,error = ENOBUFS)
(36,val)
(37,so->so_proto)
(38,NULL)
(39,case SO_SNDTIMEO:)
(40,goto bad;)
(41,so)
(42,so_proto)
(43,val)
(44,tv_sec)
(45,m)
(46,tv->tv_sec * hz + tv->tv_usec / tick)
(47,tv)
(48,int optname)
(49,optval)
(50,so)
(51,so)
(52,if (level != SOL_SOCKET)
(53,PRCO_SETOPT)
(54,m)
(55,m_len)
(56,tv->tv_sec > (SHRT_MAX - tv->tv_usec / tick)
(57,error = EINVAL)
(58,sbreserve(optname == SO_SNDBUF ?\n\\n\\t\\t\\t\\t    &so->so_snd : &so->so_rcv,\n\\n\\t\\t\\t\\t    (u_long)
(59,default:)
(60,case SO_RCVLOWAT:)
(61,tv->tv_usec)
(62,sizeof(int)
(63,*tv)
(64,pr_ctloutput)
(65,)
(66,case SO_SNDBUF:)
(67,case SO_SNDLOWAT:)
(68,m)
(69,break;)
(70,hz)
(71,tv)
(72,case SO_DONTROUTE:)
(73,sb_hiwat)
(74,pr_ctloutput)
(75,m->m_len)
(76,m)
(77,error)
(78,so->so_proto)
(79,(optval > so->so_snd.sb_hiwat)
(80,val = 1)
(81,)
(82,so->so_rcv.sb_hiwat)
(83,)
(84,so)
(85,break;)
(86,tv_sec)
(87,)
(88,case SO_KEEPALIVE:)
(89,so->so_snd)
(90,val)
(91,m)
(92,so)
(93,so->so_snd)
(94,error = EINVAL)
(95,(optval > so->so_rcv.sb_hiwat)
(96,so_snd)
(97,tv->tv_sec)
(98,optval)
(99,optname)
(100,so)
(101,error = EINVAL)
(102,case SO_LINGER:)
(103,so->so_rcv.sb_timeo)
(104,so->so_rcv.sb_hiwat)
(105,)
(106,so->so_rcv)
(107,so)
(108,ENOPROTOOPT)
(109,so)
(110,case SO_SNDLOWAT:)
(111,if (error == 0 && so->so_proto && so->so_proto->pr_ctloutput)
(112,so->so_snd)
(113,optname)
(114,PRCO_SETOPT)
(115,)
(116,m->m_len)
(117,so->so_snd.sb_lowat)
(118,m)
(119,if (optval < 1)
(120,ENOBUFS)
(121,so->so_options)
(122,switch (optname)
(123,if (val == 0 && tv->tv_usec != 0)
(124,1)
(125,optname)
(126,return (error)
(127,optval)
(128,(SHRT_MAX - tv->tv_usec / tick)
(129,break;)
(130,so->so_rcv)
(131,m->m_len)
(132,so->so_snd)
(133,sizeof(*tv)
(134,m)
(135,so)
(136,m)
(137,)
(138,case SO_REUSEPORT:)
(139,error = 0)
(140,case SO_RCVLOWAT:)
(141,m_len)
(142,if (m == NULL || m->m_len != sizeof(struct linger)
(143,&m0)
(144,m == NULL)
(145,val)
(146,so->so_rcv)
(147,so->so_snd.sb_hiwat)
(148,so_snd)
(149,so_rcv)
(150,so)
(151,so)
(152,m0)
(153,tv->tv_sec * hz)
(154,u_long)
(155,l_linger)
(156,m = m0)
(157,level)
(158,int)
(159,struct linger)
(160,error == 0 && so->so_proto && so->so_proto->pr_ctloutput)
(161,so->so_snd.sb_hiwat)
(162,so->so_rcv.sb_lowat)
(163,int)
(164,so->so_proto && so->so_proto->pr_ctloutput)
(165,so->so_options)
(166,sb_hiwat)
(167,EDOM)
(168,break;)
(169,sb_hiwat)
(170,hz)
(171,)
(172,RET)
(173,tv)
(174,so_proto)
(175,&m0)
(176,so_proto)
(177,error)
(178,so->so_proto->pr_ctloutput)
(179,goto bad;)
(180,sizeof(struct linger)
(181,m == NULL || m->m_len != sizeof(struct linger)
(182,error)
(183,so)
(184,optval)
(185,&so->so_rcv)
(186,bad:)
(187,case SO_DEBUG:)
(188,so)
(189,SO_SNDBUF)
(190,so->so_proto)
(191,0)
(192,optval)
(193,case SO_RCVBUF:)
(194,NULL)
(195,if (m == NULL || m->m_len < sizeof(int)
(196,m == NULL)
(197,goto bad;)
(198,NULL)
(199,optname)
(200,(void)
(201,error)
(202,error)
(203,m->m_len < sizeof(int)
(204,level)
(205,)
(206,optname == SO_SNDBUF)
(207,goto bad;)
(208,(*so->so_proto->pr_ctloutput)
(209,so_snd)
(210,m0)
(211,break;)
(212,EINVAL)
(213,goto bad;)
(214,tv->tv_usec != 0)
(215,)
(216,break;)
(217,break;)
(218,so_snd)
(219,NULL)
(220,level != SOL_SOCKET)
(221,case SO_RCVBUF:)
(222,so)
(223,0)
(224,case SO_RCVTIMEO:)
(225,SOL_SOCKET)
(226,0)
(227,error)
(228,optval)
(229,struct mbuf *m0)
(230,optname == SO_SNDBUF ?\n\\n\\t\\t\\t\\t    &so->so_snd : &so->so_rcv)
(231,(*so->so_proto->pr_ctloutput)
(232,so->so_rcv)
(233,case SO_REUSEADDR:)
(234,so->so_rcv)
(235,m)
(236,if (m == NULL || m->m_len < sizeof(int)
(237,m)
(238,m_len)
(239,)
(240,sb_hiwat)
(241,optval > so->so_snd.sb_hiwat)
(242,goto bad;)
(243,m = NULL)
(244,tv_usec)
(245,m_free(m)
(246,so)
(247,)
(248,sizeof(int)
(249,m == NULL)
(250,tick)
(251,EINVAL)
(252,so_proto)
(253,m->m_len < sizeof(int)
(254,if (sbreserve(optname == SO_SNDBUF ?\n\\n\\t\\t\\t\\t    &so->so_snd : &so->so_rcv,\n\\n\\t\\t\\t\\t    (u_long)
(255,val == 0 && tv->tv_usec != 0)
(256,case SO_RCVTIMEO:)
(257,case SO_SNDTIMEO:)
(258,struct socket *so)
(259,switch (optname)
(260,&so->so_snd)
(261,m == NULL || m->m_len < sizeof(int)
(262,optval)
(263,optname)
(264,so->so_proto->pr_ctloutput)
(265,error == 0)
(266,tv)
(267,tv)
(268,error)
(269,error)
(270,0)
(271,so->so_options &= ~optname)
(272,sb_timeo)
(273,case SO_OOBINLINE:)
(274,sb_timeo)
(275,so_snd)
(276,m == NULL)
(277,ENOPROTOOPT)
(278,optval < 1)
(279,level)
(280,m == NULL || m->m_len < sizeof(int)
(281,if (so->so_proto && so->so_proto->pr_ctloutput)
(282,so)
(283,so_options)
(284,(void)
(285,tick)
(286,so)
(287,)
(288,so->so_snd.sb_timeo = val)
(289,so->so_proto)
(290,optval > so->so_rcv.sb_hiwat)
(291,switch (optname)
(292,1)
(293,sb_lowat)
(294,error = EDOM)
(295,sb_lowat)
(296,error)
(297,if (tv->tv_sec > (SHRT_MAX - tv->tv_usec / tick)
(298,tv->tv_usec)
(299,goto bad;)
(300,m0)
(301,tv_usec)
(302,so_rcv)
(303,tv_usec)
(304,m->m_len != sizeof(struct linger)
(305,so_rcv)
(306,void)
(307,0)
(308,m_len)
(309,case SO_SNDBUF:)
(310,EINVAL)
(311,case SO_BROADCAST:)
(312,so->so_snd.sb_timeo)
(313,tv)
(314,case SO_USELOOPBACK:)
(315,if (m)
(316,error)
(317,m->m_len)
(318,NULL)
(319,tv->tv_sec)
(320,break;)
(321,so->so_proto && so->so_proto->pr_ctloutput)
(322,val == 0)
(323,tv->tv_usec / tick)
(324,EINVAL)
(325,error = EINVAL)
(326,error = EINVAL)
(327,m->m_len < sizeof(*tv)
(328,tv->tv_usec / tick)
(329,int level)
(330,sbreserve(optname == SO_SNDBUF ?\n\\n\\t\\t\\t\\t    &so->so_snd : &so->so_rcv,\n\\n\\t\\t\\t\\t    (u_long)
(331,m == NULL || m->m_len < sizeof(*tv)
(332,m)
(333,error = ENOPROTOOPT)
(334,tv)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^