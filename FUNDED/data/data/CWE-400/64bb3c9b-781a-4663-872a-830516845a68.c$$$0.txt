-----label-----
1
-----code-----
int
main(int argc, char *argv[])
{
	const struct option longopts[] = {
		{ "help",		0, 0, 'h' },
		{ "detach",		0, 0, 'D' }
	};
	int err, detach = 0;

	program = basename(argv[0]);

	do {
		int c;

		c = getopt_long(argc, argv, "hD", longopts, NULL);
		if (c == -1)
			break;

		switch (c) {
		case 'h':
			usage(stdout);
			return 0;
		case 'D':
			detach = 1;
			break;
		default:
			goto usage;
		}
	} while (1);

	if (argc - optind < 2)
		goto usage;

	if (detach) {
		/* NB. This is expected to rarely, if ever, be
		   used. Blktapctrl is already detached, and breaking
		   affiliation will be exactly not desirable. */
		err = daemon(0, 0);
		if (err) {
			PERROR("daemon");
			return -errno;
		}
	}

	tapdisk_start_logging("TAPDISK");

	err = tapdisk_server_initialize(argv[1], argv[2]);
	if (err) {
		EPRINTF("failed to initialize tapdisk server: %d\n", err);
		goto out;
	}

	err = tapdisk_server_run();

out:
	tapdisk_stop_logging();

	return err ? 1 : 0;

usage:
	usage(stderr);
	return 1;
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
5,6
5,7
7,8
9,10
9,11
11,12
11,13
11,14
15,16
15,17
15,18
15,19
15,20
15,21
15,22
15,23
15,24
15,25
15,26
15,27
15,28
15,29
16,17
17,18
17,19
18,19
20,21
20,22
20,23
23,24
24,25
24,26
25,26
25,27
25,28
25,29
30,31
30,32
30,33
30,34
35,36
36,37
36,38
36,39
38,39
40,41
40,42
42,43
44,45
45,46
45,47
46,47
48,49
48,50
49,50
51,52
51,53
52,53
55,56
55,57
56,57
56,58
56,59
56,60
57,58
58,59
58,60
60,61
62,63
63,64
63,65
64,65
66,67
66,68
66,69
66,70
66,71
66,72
67,68
69,70
71,72
74,75
76,77
78,79
78,80
79,80
79,81
80,81
82,83
85,86
85,87
86,87
88,89
88,90
88,91
88,92
88,93
88,94
88,95
88,96
89,90
91,92
92,93
92,94
93,94
95,96
96,97
98,99
100,101
102,103
103,104
103,105
104,105
109,110
112,113
112,114
113,114
113,115
114,115
114,116
115,116
117,118
120,121
122,123
122,124
123,124
125,126
125,127
126,127
127,128
127,129
128,129
130,131
130,132
130,133
131,132
135,136
135,137
136,137
138,139
138,140
139,140
140,141
140,142
141,142
144,145
145,146
146,147
148,149
149,150
149,151
150,151
153,154
154,155
154,156
155,156
157,158
157,159
157,160
158,159
160,161
160,162
161,162
164,165
164,166
165,166
168,169
168,170
169,170
171,172
171,173
172,173
173,174
173,175
173,176
174,175
177,178
179,180
181,182
182,183
182,184
183,184
185,186
186,187
188,189
188,190
190,191
191,192
192,193
194,195
195,196
195,197
195,198
196,197
200,201
200,202
202,203
203,204
203,205
204,205
206,207
207,208
209,210
-----nextToken-----
2,4,6,8,10,12,13,14,19,21,22,26,27,28,29,31,32,33,34,37,39,41,43,47,50,53,54,59,61,65,68,70,72,73,75,77,81,83,84,87,90,94,97,99,101,105,106,107,108,110,111,116,118,119,121,124,129,132,133,134,137,142,143,147,151,152,156,159,162,163,166,167,170,175,176,178,180,184,187,189,193,197,198,199,201,205,208,210
-----computeFrom-----
45,46
45,47
63,64
63,65
79,80
79,81
103,104
103,105
113,114
113,115
114,115
114,116
127,128
127,129
154,155
154,156
182,183
182,184
-----guardedBy-----
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Pointer;Name;ArrayModifier;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;ArrayDeclarator;Name;ArrayModifier;EqualsInitializer;InitializerList;InitializerList;LiteralExpression;LiteralExpression;LiteralExpression;LiteralExpression;InitializerList;LiteralExpression;LiteralExpression;LiteralExpression;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;Declarator;Name;EqualsInitializer;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;DoStatement;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;UnaryExpression;LiteralExpression;BreakStatement;SwitchStatement;IdExpression;Name;CompoundStatement;CaseStatement;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ReturnStatement;LiteralExpression;CaseStatement;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BreakStatement;DefaultStatement;GotoStatement;Name;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;GotoStatement;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ReturnStatement;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;GotoStatement;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LabelStatement;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ReturnStatement;ConditionalExpression;IdExpression;Name;LiteralExpression;LiteralExpression;LabelStatement;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ReturnStatement;LiteralExpression;
-----ast_node-----
intmain(int argc, char *argv[]){	const struct option longopts[] = {		{ "help",		0, 0, 'h' },		{ "detach",		0, 0, 'D' }	};	int err, detach = 0;	program = basename(argv[0]);	do {		int c;		c = getopt_long(argc, argv, "hD", longopts, NULL);		if (c == -1)			break;		switch (c) {		case 'h':			usage(stdout);			return 0;		case 'D':			detach = 1;			break;		default:			goto usage;		}	} while (1);	if (argc - optind < 2)		goto usage;	if (detach) {		/* NB. This is expected to rarely, if ever, be		   used. Blktapctrl is already detached, and breaking		   affiliation will be exactly not desirable. */		err = daemon(0, 0);		if (err) {			PERROR("daemon");			return -errno;		}	}	tapdisk_start_logging("TAPDISK");	err = tapdisk_server_initialize(argv[1], argv[2]);	if (err) {		EPRINTF("failed to initialize tapdisk server: %d\n", err);		goto out;	}	err = tapdisk_server_run();out:	tapdisk_stop_logging();	return err ? 1 : 0;usage:	usage(stderr);	return 1;}
int
main(int argc, char *argv[])
main
int argc
int
argc
argc
char *argv[]
char
*argv[]
*
argv
[]
{	const struct option longopts[] = {		{ "help",		0, 0, 'h' },		{ "detach",		0, 0, 'D' }	};	int err, detach = 0;	program = basename(argv[0]);	do {		int c;		c = getopt_long(argc, argv, "hD", longopts, NULL);		if (c == -1)			break;		switch (c) {		case 'h':			usage(stdout);			return 0;		case 'D':			detach = 1;			break;		default:			goto usage;		}	} while (1);	if (argc - optind < 2)		goto usage;	if (detach) {		/* NB. This is expected to rarely, if ever, be		   used. Blktapctrl is already detached, and breaking		   affiliation will be exactly not desirable. */		err = daemon(0, 0);		if (err) {			PERROR("daemon");			return -errno;		}	}	tapdisk_start_logging("TAPDISK");	err = tapdisk_server_initialize(argv[1], argv[2]);	if (err) {		EPRINTF("failed to initialize tapdisk server: %d\n", err);		goto out;	}	err = tapdisk_server_run();out:	tapdisk_stop_logging();	return err ? 1 : 0;usage:	usage(stderr);	return 1;}
const struct option longopts[] = {		{ "help",		0, 0, 'h' },		{ "detach",		0, 0, 'D' }	};
const struct option longopts[] = {		{ "help",		0, 0, 'h' },		{ "detach",		0, 0, 'D' }	};
const struct option
option
longopts[] = {		{ "help",		0, 0, 'h' },		{ "detach",		0, 0, 'D' }	}
longopts
[]
= {		{ "help",		0, 0, 'h' },		{ "detach",		0, 0, 'D' }	}
{		{ "help",		0, 0, 'h' },		{ "detach",		0, 0, 'D' }	}
{ "help",		0, 0, 'h' }
"help"
0
0
'h'
{ "detach",		0, 0, 'D' }
"detach"
0
0
'D'
int err, detach = 0;
int err, detach = 0;
int
err
err
detach = 0
detach
= 0
0
program = basename(argv[0]);
program = basename(argv[0])
program
program
basename(argv[0])
basename
basename
argv[0]
argv
argv
0
do {		int c;		c = getopt_long(argc, argv, "hD", longopts, NULL);		if (c == -1)			break;		switch (c) {		case 'h':			usage(stdout);			return 0;		case 'D':			detach = 1;			break;		default:			goto usage;		}	} while (1);
{		int c;		c = getopt_long(argc, argv, "hD", longopts, NULL);		if (c == -1)			break;		switch (c) {		case 'h':			usage(stdout);			return 0;		case 'D':			detach = 1;			break;		default:			goto usage;		}	}
int c;
int c;
int
c
c
c = getopt_long(argc, argv, "hD", longopts, NULL);
c = getopt_long(argc, argv, "hD", longopts, NULL)
c
c
getopt_long(argc, argv, "hD", longopts, NULL)
getopt_long
getopt_long
argc
argc
argv
argv
"hD"
longopts
longopts
NULL
NULL
if (c == -1)			break;
c == -1
c
c
-1
1
break;
switch (c) {		case 'h':			usage(stdout);			return 0;		case 'D':			detach = 1;			break;		default:			goto usage;		}
c
c
{		case 'h':			usage(stdout);			return 0;		case 'D':			detach = 1;			break;		default:			goto usage;		}
case 'h':
'h'
usage(stdout);
usage(stdout);
usage
usage
(stdout)
stdout
stdout
return 0;
0
case 'D':
'D'
detach = 1;
detach = 1
detach
detach
1
break;
default:
goto usage;
usage
1
if (argc - optind < 2)		goto usage;
argc - optind < 2
argc - optind
argc
argc
optind
optind
2
goto usage;
usage
if (detach) {		/* NB. This is expected to rarely, if ever, be		   used. Blktapctrl is already detached, and breaking		   affiliation will be exactly not desirable. */		err = daemon(0, 0);		if (err) {			PERROR("daemon");			return -errno;		}	}
detach
detach
{		/* NB. This is expected to rarely, if ever, be		   used. Blktapctrl is already detached, and breaking		   affiliation will be exactly not desirable. */		err = daemon(0, 0);		if (err) {			PERROR("daemon");			return -errno;		}	}
err = daemon(0, 0);
err = daemon(0, 0)
err
err
daemon(0, 0)
daemon
daemon
0
0
if (err) {			PERROR("daemon");			return -errno;		}
err
err
{			PERROR("daemon");			return -errno;		}
PERROR("daemon");
PERROR("daemon")
PERROR
PERROR
"daemon"
return -errno;
-errno
errno
errno
tapdisk_start_logging("TAPDISK");
tapdisk_start_logging("TAPDISK")
tapdisk_start_logging
tapdisk_start_logging
"TAPDISK"
err = tapdisk_server_initialize(argv[1], argv[2]);
err = tapdisk_server_initialize(argv[1], argv[2])
err
err
tapdisk_server_initialize(argv[1], argv[2])
tapdisk_server_initialize
tapdisk_server_initialize
argv[1]
argv
argv
1
argv[2]
argv
argv
2
if (err) {		EPRINTF("failed to initialize tapdisk server: %d\n", err);		goto out;	}
err
err
{		EPRINTF("failed to initialize tapdisk server: %d\n", err);		goto out;	}
EPRINTF("failed to initialize tapdisk server: %d\n", err);
EPRINTF("failed to initialize tapdisk server: %d\n", err)
EPRINTF
EPRINTF
"failed to initialize tapdisk server: %d\n"
err
err
goto out;
out
err = tapdisk_server_run();
err = tapdisk_server_run()
err
err
tapdisk_server_run()
tapdisk_server_run
tapdisk_server_run
out:	tapdisk_stop_logging();
out
tapdisk_stop_logging();
tapdisk_stop_logging()
tapdisk_stop_logging
tapdisk_stop_logging
return err ? 1 : 0;
err ? 1 : 0
err
err
1
0
usage:	usage(stderr);
usage
usage(stderr);
usage(stderr);
usage
usage
(stderr)
stderr
stderr
return 1;
1
-----joern-----
(101,76,0)
(77,58,0)
(78,55,0)
(21,38,0)
(43,72,0)
(82,58,0)
(26,72,0)
(23,101,0)
(93,4,0)
(42,4,0)
(10,17,0)
(51,49,0)
(83,72,0)
(81,8,0)
(104,40,0)
(62,31,0)
(70,55,0)
(60,40,0)
(7,72,0)
(75,85,0)
(36,103,0)
(32,6,0)
(90,18,0)
(102,90,0)
(31,17,0)
(73,42,0)
(97,4,0)
(89,72,0)
(54,58,0)
(103,44,0)
(58,31,0)
(24,72,0)
(57,49,0)
(5,29,0)
(104,47,0)
(20,72,0)
(65,10,0)
(39,72,0)
(8,72,0)
(46,95,0)
(12,24,0)
(31,72,0)
(24,49,0)
(88,57,0)
(88,76,0)
(47,85,0)
(47,69,0)
(100,40,0)
(52,104,0)
(48,103,0)
(50,90,0)
(53,4,0)
(58,57,0)
(30,47,0)
(0,4,0)
(95,34,0)
(52,38,0)
(47,18,0)
(106,20,0)
(49,16,0)
(79,97,0)
(92,75,0)
(76,49,0)
(14,69,0)
(6,2,0)
(76,34,0)
(88,97,0)
(25,94,0)
(2,6,0)
(90,94,0)
(57,72,0)
(27,9,0)
(17,31,0)
(16,29,0)
(96,75,0)
(29,16,0)
(49,72,0)
(28,41,0)
(10,85,0)
(13,29,0)
(88,24,0)
(9,72,0)
(67,47,0)
(80,72,0)
(97,49,0)
(33,4,0)
(11,72,0)
(56,40,0)
(71,78,0)
(99,4,0)
(103,31,0)
(69,72,0)
(17,75,0)
(16,49,0)
(87,8,0)
(74,44,0)
(64,53,0)
(45,72,0)
(58,6,0)
(29,85,0)
(94,90,0)
(78,41,0)
(98,47,0)
(22,4,0)
(59,104,0)
(3,72,0)
(38,52,0)
(91,47,0)
(66,55,0)
(55,78,0)
(68,52,0)
(6,72,0)
(63,47,0)
(75,17,0)
(19,53,0)
(47,104,0)
(105,10,0)
(17,10,0)
(19,35,1)
(103,36,1)
(47,85,1)
(52,38,1)
(20,106,1)
(12,20,1)
(58,82,1)
(31,17,1)
(9,27,1)
(36,48,1)
(97,79,1)
(89,6,1)
(99,35,1)
(94,25,1)
(42,73,1)
(47,18,1)
(88,76,1)
(73,35,1)
(38,21,1)
(89,74,1)
(102,50,1)
(51,8,1)
(47,69,1)
(105,65,1)
(106,99,1)
(88,24,1)
(58,54,1)
(54,77,1)
(82,77,1)
(17,75,1)
(6,2,1)
(37,78,1)
(106,84,1)
(86,94,1)
(1,22,1)
(76,101,1)
(57,58,1)
(23,95,1)
(104,47,1)
(8,87,1)
(71,86,1)
(2,32,1)
(65,62,1)
(88,57,1)
(29,13,1)
(59,1,1)
(95,46,1)
(77,89,1)
(97,49,1)
(16,29,1)
(103,31,1)
(90,102,1)
(84,94,1)
(92,10,1)
(75,96,1)
(13,5,1)
(10,85,1)
(24,12,1)
(5,51,1)
(17,10,1)
(22,53,1)
(90,18,1)
(25,90,1)
(53,64,1)
(10,105,1)
(79,42,1)
(52,104,1)
(88,97,1)
(81,69,1)
(63,59,1)
(50,61,1)
(96,92,1)
(29,85,1)
(35,52,1)
(87,81,1)
(64,19,1)
(46,37,1)
(58,31,1)
(24,49,1)
(78,55,1)
(55,66,1)
(32,15,1)
(50,1,1)
(98,63,1)
(61,52,1)
(68,104,1)
(69,14,1)
(58,6,1)
(94,90,1)
(27,86,1)
(75,85,1)
(49,16,1)
(66,70,1)
(91,30,1)
(47,67,1)
(74,103,1)
(101,23,1)
(48,15,1)
(67,91,1)
(62,9,1)
(76,49,1)
(30,98,1)
(57,49,1)
(70,71,1)
(15,31,1)
(59,49,1)
(21,68,1)
(27,37,1)
(75,37,2)
(31,37,2)
(57,86,2)
(47,69,2)
(95,37,2)
(103,15,2)
(62,86,2)
(92,37,2)
(50,52,2)
(10,86,2)
(92,86,2)
(47,85,2)
(9,37,2)
(58,37,2)
(88,97,2)
(15,37,2)
(88,57,2)
(70,86,2)
(15,86,2)
(49,16,2)
(98,1,2)
(90,18,2)
(71,86,2)
(25,1,2)
(52,104,2)
(32,15,2)
(31,86,2)
(62,37,2)
(79,35,2)
(27,37,2)
(67,1,2)
(16,29,2)
(6,2,2)
(68,1,2)
(97,49,2)
(73,35,2)
(22,35,2)
(52,1,2)
(37,86,2)
(96,37,2)
(101,37,2)
(29,85,2)
(94,52,2)
(57,49,2)
(65,86,2)
(104,1,2)
(61,52,2)
(63,1,2)
(103,31,2)
(77,86,2)
(30,1,2)
(50,1,2)
(36,15,2)
(105,37,2)
(24,94,2)
(90,1,2)
(94,90,2)
(96,86,2)
(55,86,2)
(91,1,2)
(89,37,2)
(1,35,2)
(17,37,2)
(84,94,2)
(52,38,2)
(77,37,2)
(9,86,2)
(75,85,2)
(102,1,2)
(10,37,2)
(88,24,2)
(86,94,2)
(24,35,2)
(102,52,2)
(78,86,2)
(74,15,2)
(47,18,2)
(76,49,2)
(58,86,2)
(64,35,2)
(106,94,2)
(46,37,2)
(97,35,2)
(17,86,2)
(21,1,2)
(25,52,2)
(24,49,2)
(10,85,2)
(66,86,2)
(57,37,2)
(20,35,2)
(88,76,2)
(75,86,2)
(58,6,2)
(2,15,2)
(38,1,2)
(94,1,2)
(58,31,2)
(89,86,2)
(106,35,2)
(47,1,2)
(17,75,2)
(17,10,2)
(90,52,2)
(19,35,2)
(78,55,2)
(104,47,2)
(105,86,2)
(12,35,2)
(42,35,2)
(27,86,2)
(53,35,2)
(31,17,2)
(59,1,2)
(6,15,2)
(48,15,2)
(20,94,2)
(12,94,2)
(23,37,2)
(82,77,2)
(35,52,2)
(54,77,2)
(99,35,2)
(76,37,2)
(65,37,2)
-----------------------------------
(0,case \'h\':)
(1,1)
(2,tapdisk_server_run()
(3,err)
(4,)
(5,argv)
(6,err = tapdisk_server_run()
(7,do)
(8,detach = 0)
(9,tapdisk_start_logging("TAPDISK")
(10,argv[1])
(11,detach)
(12,1)
(13,0)
(14,longopts)
(15,err)
(16,basename(argv[0])
(17,tapdisk_server_initialize(argv[1], argv[2])
(18,int argc)
(19,detach)
(20,usage(stderr)
(21,1)
(22,break;)
(23,errno)
(24,return 1;)
(25,2)
(26,if (err)
(27,"TAPDISK")
(28,if (err)
(29,argv[0])
(30,"hD")
(31,err = tapdisk_server_initialize(argv[1], argv[2])
(32,err)
(33,default:)
(34,)
(35,c)
(36,err)
(37,err)
(38,-1)
(39,longopts)
(40,)
(41,)
(42,usage(stdout)
(43,if (argc - optind < 2)
(44,)
(45,if (detach)
(46,"daemon")
(47,getopt_long(argc, argv, "hD", longopts, NULL)
(48,"failed to initialize tapdisk server: %d\\n")
(49,program = basename(argv[0])
(50,argc)
(51,program)
(52,c == -1)
(53,detach = 1)
(54,0)
(55,daemon(0, 0)
(56,if (c == -1)
(57,return err ? 1 : 0;)
(58,err ? 1 : 0)
(59,c)
(60,c)
(61,break;)
(62,err)
(63,argc)
(64,1)
(65,argv)
(66,0)
(67,NULL)
(68,c)
(69,longopts[] = {\n\\n\\t\\t{ "help",\\t\\t0, 0, \'h\' },\n\\n\\t\\t{ "detach",\\t\\t0, 0, \'D\' }\n\\n\\t})
(70,0)
(71,err)
(72,)
(73,stdout)
(74,goto out;)
(75,argv[2])
(76,return -errno;)
(77,err)
(78,err = daemon(0, 0)
(79,0)
(80,usage:)
(81,detach)
(82,1)
(83,out:)
(84,goto usage;)
(85,char *argv[])
(86,detach)
(87,0)
(88,RET)
(89,tapdisk_stop_logging()
(90,argc - optind)
(91,longopts)
(92,argv)
(93,case \'D\':)
(94,argc - optind < 2)
(95,PERROR("daemon")
(96,2)
(97,return 0;)
(98,argv)
(99,goto usage;)
(100,switch (c)
(101,-errno)
(102,optind)
(103,EPRINTF("failed to initialize tapdisk server: %d\\n", err)
(104,c = getopt_long(argc, argv, "hD", longopts, NULL)
(105,1)
(106,stderr)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^