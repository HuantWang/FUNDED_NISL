-----label-----
0
-----code-----
static void matchdir(char *pattern, boolean_t check_ncargs)
{
    struct stat stb;

#ifdef HAVE_DIRENT_H
    register struct dirent *dp;
#else
    register struct direct *dp;
#endif

    DIR *dirp;

    dirp = opendir(*gpath == '\0' ? "." : gpath);
    if (dirp == NULL) {
	if (globbed)
	    return;
	goto patherr2;
    }
#ifdef HAVE_DIRFD
    if (fstat(dirfd(dirp), &stb) < 0)
#else /* HAVE_DIRFD */
    if (fstat(dirp->dd_fd, &stb) < 0)
#endif /* HAVE_DIRFD */
	goto patherr1;
    if (limits[GLOB_INDEX_STAT]++ >= GLOB_LIMIT_STAT) {
      globerr = "Arguments too long";
      return;
    }
    if (!isdir(stb)) {
	errno = ENOTDIR;
	goto patherr1;
    }
    while (!globerr && ((dp = readdir(dirp)) != NULL)) {
	if (dp->d_ino == 0)
	    continue;
	if (limits[GLOB_INDEX_READDIR]++ >= GLOB_LIMIT_READDIR)
	  globerr = "Arguments too long";
	else if (match(dp->d_name, pattern, check_ncargs)) {
	    Gcat(gpath, dp->d_name, check_ncargs);
	    globcnt++;
	}
    }
    closedir(dirp);
    return;

  patherr1:
    closedir(dirp);
  patherr2:
    globerr = "Bad directory components";
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
5,6
5,7
7,8
7,9
10,11
10,12
11,12
13,14
15,16
15,17
15,18
15,19
15,20
15,21
15,22
15,23
15,24
15,25
15,26
15,27
15,28
16,17
17,18
17,19
18,19
20,21
22,23
23,24
23,25
24,25
26,27
26,28
29,30
30,31
30,32
31,32
33,34
33,35
36,37
37,38
37,39
38,39
40,41
40,42
41,42
43,44
43,45
43,46
44,45
44,46
45,46
46,47
50,51
52,53
52,54
53,54
53,55
54,55
56,57
58,59
58,60
59,60
59,61
60,61
63,64
65,66
65,67
66,67
66,68
67,68
67,69
67,70
68,69
70,71
70,72
71,72
74,75
75,76
78,79
80,81
80,82
81,82
81,83
82,83
83,84
83,85
84,85
86,87
88,89
90,91
90,92
91,92
92,93
92,94
93,94
97,98
97,99
98,99
99,100
99,101
100,101
102,103
104,105
104,106
105,106
106,107
106,108
107,108
109,110
111,112
113,114
113,115
114,115
114,116
115,116
116,117
118,119
119,120
119,121
120,121
121,122
121,123
122,123
124,125
124,126
125,126
127,128
129,130
131,132
131,133
132,133
132,134
133,134
133,135
134,135
134,136
135,136
140,141
140,142
140,143
141,142
141,143
142,143
143,144
143,145
144,145
146,147
148,149
150,151
151,152
151,153
152,153
155,156
155,157
156,157
156,158
156,159
156,160
157,158
159,160
159,161
160,161
163,164
165,166
167,168
167,169
168,169
169,170
169,171
169,172
169,173
170,171
172,173
174,175
174,176
175,176
178,179
180,181
181,182
182,183
184,185
185,186
185,187
186,187
188,189
191,192
191,193
193,194
194,195
194,196
195,196
197,198
199,200
199,201
201,202
202,203
202,204
203,204
-----nextToken-----
2,4,6,8,9,12,14,19,21,25,27,28,32,34,35,39,42,47,48,49,51,55,57,61,62,64,69,72,73,76,77,79,85,87,89,94,95,96,101,103,108,110,112,117,123,126,128,130,136,137,138,139,145,147,149,153,154,158,161,162,164,166,171,173,176,177,179,183,187,189,190,192,196,198,200,204,205
-----computeFrom-----
37,38
37,39
44,45
44,46
53,54
53,55
66,67
66,68
81,82
81,83
92,93
92,94
106,107
106,108
114,115
114,116
119,120
119,121
121,122
121,123
133,134
133,135
141,142
141,143
151,152
151,153
202,203
202,204
-----guardedBy-----
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;ConditionalExpression;BinaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;IdExpression;Name;ReturnStatement;GotoStatement;Name;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;LiteralExpression;GotoStatement;Name;IfStatement;BinaryExpression;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ReturnStatement;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;GotoStatement;Name;WhileStatement;BinaryExpression;UnaryExpression;IdExpression;Name;UnaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ContinueStatement;IfStatement;BinaryExpression;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;LabelStatement;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LabelStatement;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;
-----ast_node-----
static void matchdir(char *pattern, boolean_t check_ncargs){    struct stat stb;#ifdef HAVE_DIRENT_H    register struct dirent *dp;#else    register struct direct *dp;#endif    DIR *dirp;    dirp = opendir(*gpath == '\0' ? "." : gpath);    if (dirp == NULL) {	if (globbed)	    return;	goto patherr2;    }#ifdef HAVE_DIRFD    if (fstat(dirfd(dirp), &stb) < 0)#else /* HAVE_DIRFD */    if (fstat(dirp->dd_fd, &stb) < 0)#endif /* HAVE_DIRFD */	goto patherr1;    if (limits[GLOB_INDEX_STAT]++ >= GLOB_LIMIT_STAT) {      globerr = "Arguments too long";      return;    }    if (!isdir(stb)) {	errno = ENOTDIR;	goto patherr1;    }    while (!globerr && ((dp = readdir(dirp)) != NULL)) {	if (dp->d_ino == 0)	    continue;	if (limits[GLOB_INDEX_READDIR]++ >= GLOB_LIMIT_READDIR)	  globerr = "Arguments too long";	else if (match(dp->d_name, pattern, check_ncargs)) {	    Gcat(gpath, dp->d_name, check_ncargs);	    globcnt++;	}    }    closedir(dirp);    return;  patherr1:    closedir(dirp);  patherr2:    globerr = "Bad directory components";}
static void
matchdir(char *pattern, boolean_t check_ncargs)
matchdir
char *pattern
char
*pattern
*
pattern
boolean_t check_ncargs
boolean_t
boolean_t
check_ncargs
check_ncargs
{    struct stat stb;#ifdef HAVE_DIRENT_H    register struct dirent *dp;#else    register struct direct *dp;#endif    DIR *dirp;    dirp = opendir(*gpath == '\0' ? "." : gpath);    if (dirp == NULL) {	if (globbed)	    return;	goto patherr2;    }#ifdef HAVE_DIRFD    if (fstat(dirfd(dirp), &stb) < 0)#else /* HAVE_DIRFD */    if (fstat(dirp->dd_fd, &stb) < 0)#endif /* HAVE_DIRFD */	goto patherr1;    if (limits[GLOB_INDEX_STAT]++ >= GLOB_LIMIT_STAT) {      globerr = "Arguments too long";      return;    }    if (!isdir(stb)) {	errno = ENOTDIR;	goto patherr1;    }    while (!globerr && ((dp = readdir(dirp)) != NULL)) {	if (dp->d_ino == 0)	    continue;	if (limits[GLOB_INDEX_READDIR]++ >= GLOB_LIMIT_READDIR)	  globerr = "Arguments too long";	else if (match(dp->d_name, pattern, check_ncargs)) {	    Gcat(gpath, dp->d_name, check_ncargs);	    globcnt++;	}    }    closedir(dirp);    return;  patherr1:    closedir(dirp);  patherr2:    globerr = "Bad directory components";}
struct stat stb;
struct stat stb;
struct stat
stat
stb
stb
register struct direct *dp;
register struct direct *dp;
register struct direct
direct
*dp
*
dp
DIR *dirp;
DIR *dirp;
DIR
DIR
*dirp
*
dirp
dirp = opendir(*gpath == '\0' ? "." : gpath);
dirp = opendir(*gpath == '\0' ? "." : gpath)
dirp
dirp
opendir(*gpath == '\0' ? "." : gpath)
opendir
opendir
*gpath == '\0' ? "." : gpath
*gpath == '\0'
*gpath
gpath
gpath
'\0'
"."
gpath
gpath
if (dirp == NULL) {	if (globbed)	    return;	goto patherr2;    }
dirp == NULL
dirp
dirp
NULL
NULL
{	if (globbed)	    return;	goto patherr2;    }
if (globbed)	    return;
globbed
globbed
return;
goto patherr2;
patherr2
if (fstat(dirp->dd_fd, &stb) < 0)#endif /* HAVE_DIRFD */	goto patherr1;
fstat(dirp->dd_fd, &stb) < 0
fstat(dirp->dd_fd, &stb)
fstat
fstat
dirp->dd_fd
dirp
dirp
dd_fd
&stb
stb
stb
0
goto patherr1;
patherr1
if (limits[GLOB_INDEX_STAT]++ >= GLOB_LIMIT_STAT) {      globerr = "Arguments too long";      return;    }
limits[GLOB_INDEX_STAT]++ >= GLOB_LIMIT_STAT
limits[GLOB_INDEX_STAT]++
limits[GLOB_INDEX_STAT]
limits
limits
GLOB_INDEX_STAT
GLOB_INDEX_STAT
GLOB_LIMIT_STAT
GLOB_LIMIT_STAT
{      globerr = "Arguments too long";      return;    }
globerr = "Arguments too long";
globerr = "Arguments too long"
globerr
globerr
"Arguments too long"
return;
if (!isdir(stb)) {	errno = ENOTDIR;	goto patherr1;    }
!isdir(stb)
isdir(stb)
isdir
isdir
stb
stb
{	errno = ENOTDIR;	goto patherr1;    }
errno = ENOTDIR;
errno = ENOTDIR
errno
errno
ENOTDIR
ENOTDIR
goto patherr1;
patherr1
while (!globerr && ((dp = readdir(dirp)) != NULL)) {	if (dp->d_ino == 0)	    continue;	if (limits[GLOB_INDEX_READDIR]++ >= GLOB_LIMIT_READDIR)	  globerr = "Arguments too long";	else if (match(dp->d_name, pattern, check_ncargs)) {	    Gcat(gpath, dp->d_name, check_ncargs);	    globcnt++;	}    }
!globerr && ((dp = readdir(dirp)) != NULL)
!globerr
globerr
globerr
((dp = readdir(dirp)) != NULL)
(dp = readdir(dirp)) != NULL
(dp = readdir(dirp))
dp = readdir(dirp)
dp
dp
readdir(dirp)
readdir
readdir
dirp
dirp
NULL
NULL
{	if (dp->d_ino == 0)	    continue;	if (limits[GLOB_INDEX_READDIR]++ >= GLOB_LIMIT_READDIR)	  globerr = "Arguments too long";	else if (match(dp->d_name, pattern, check_ncargs)) {	    Gcat(gpath, dp->d_name, check_ncargs);	    globcnt++;	}    }
if (dp->d_ino == 0)	    continue;
dp->d_ino == 0
dp->d_ino
dp
dp
d_ino
0
continue;
if (limits[GLOB_INDEX_READDIR]++ >= GLOB_LIMIT_READDIR)	  globerr = "Arguments too long";	else if (match(dp->d_name, pattern, check_ncargs)) {	    Gcat(gpath, dp->d_name, check_ncargs);	    globcnt++;	}
limits[GLOB_INDEX_READDIR]++ >= GLOB_LIMIT_READDIR
limits[GLOB_INDEX_READDIR]++
limits[GLOB_INDEX_READDIR]
limits
limits
GLOB_INDEX_READDIR
GLOB_INDEX_READDIR
GLOB_LIMIT_READDIR
GLOB_LIMIT_READDIR
globerr = "Arguments too long";
globerr = "Arguments too long"
globerr
globerr
"Arguments too long"
if (match(dp->d_name, pattern, check_ncargs)) {	    Gcat(gpath, dp->d_name, check_ncargs);	    globcnt++;	}
match(dp->d_name, pattern, check_ncargs)
match
match
dp->d_name
dp
dp
d_name
pattern
pattern
check_ncargs
check_ncargs
{	    Gcat(gpath, dp->d_name, check_ncargs);	    globcnt++;	}
Gcat(gpath, dp->d_name, check_ncargs);
Gcat(gpath, dp->d_name, check_ncargs)
Gcat
Gcat
gpath
gpath
dp->d_name
dp
dp
d_name
check_ncargs
check_ncargs
globcnt++;
globcnt++
globcnt
globcnt
closedir(dirp);
closedir(dirp)
closedir
closedir
dirp
dirp
return;
patherr1:    closedir(dirp);
patherr1
closedir(dirp);
closedir(dirp)
closedir
closedir
dirp
dirp
patherr2:    globerr = "Bad directory components";
patherr2
globerr = "Bad directory components";
globerr = "Bad directory components"
globerr
globerr
"Bad directory components"
-----joern-----
(92,82,0)
(45,90,0)
(18,97,0)
(49,106,0)
(7,56,0)
(58,64,0)
(107,49,0)
(25,34,0)
(12,65,0)
(9,99,0)
(31,84,0)
(102,96,0)
(37,76,0)
(34,25,0)
(64,5,0)
(99,9,0)
(70,106,0)
(104,94,0)
(103,99,0)
(60,18,0)
(105,6,0)
(76,25,0)
(57,68,0)
(94,80,0)
(40,80,0)
(65,22,0)
(95,68,0)
(60,12,0)
(20,60,0)
(55,27,0)
(30,68,0)
(79,68,0)
(42,84,0)
(75,102,0)
(2,6,0)
(28,18,0)
(48,68,0)
(50,99,0)
(56,22,0)
(38,45,0)
(66,27,0)
(74,68,0)
(87,68,0)
(48,22,0)
(5,64,0)
(41,104,0)
(83,3,0)
(25,88,0)
(22,68,0)
(73,21,0)
(89,68,0)
(83,14,0)
(83,11,0)
(53,82,0)
(59,56,0)
(61,47,0)
(0,91,0)
(108,60,0)
(102,75,0)
(9,90,0)
(85,105,0)
(32,88,0)
(19,48,0)
(11,54,0)
(67,49,0)
(25,76,0)
(95,22,0)
(81,68,0)
(1,96,0)
(82,53,0)
(14,68,0)
(62,68,0)
(16,9,0)
(39,82,0)
(99,12,0)
(29,64,0)
(63,8,0)
(51,22,0)
(23,95,0)
(76,22,0)
(8,54,0)
(12,104,0)
(46,100,0)
(65,12,0)
(84,68,0)
(72,18,0)
(53,22,0)
(26,10,0)
(86,96,0)
(47,61,0)
(94,104,0)
(69,100,0)
(22,53,0)
(93,10,0)
(82,6,0)
(27,55,0)
(6,105,0)
(96,102,0)
(88,25,0)
(98,5,0)
(10,55,0)
(78,8,0)
(18,60,0)
(4,9,0)
(6,82,0)
(55,10,0)
(33,47,0)
(15,21,0)
(52,34,0)
(104,12,0)
(9,17,0)
(13,12,0)
(71,91,0)
(64,12,0)
(44,68,0)
(18,17,0)
(77,75,0)
(24,68,0)
(36,65,0)
(80,94,0)
(5,98,1)
(6,2,1)
(41,12,1)
(99,12,1)
(28,72,1)
(82,39,1)
(55,10,1)
(83,11,1)
(50,16,1)
(39,6,1)
(101,88,1)
(8,78,1)
(77,102,1)
(92,6,1)
(65,22,1)
(36,13,1)
(75,77,1)
(1,86,1)
(93,88,1)
(84,31,1)
(48,19,1)
(40,91,1)
(45,38,1)
(33,27,1)
(83,3,1)
(9,4,1)
(9,99,1)
(25,76,1)
(88,32,1)
(40,18,1)
(104,12,1)
(64,29,1)
(65,36,1)
(78,63,1)
(29,58,1)
(9,17,1)
(12,65,1)
(40,61,1)
(108,75,1)
(10,26,1)
(22,53,1)
(18,97,1)
(20,108,1)
(0,75,1)
(16,18,1)
(58,94,1)
(18,28,1)
(71,0,1)
(82,6,1)
(75,102,1)
(60,12,1)
(18,60,1)
(83,84,1)
(88,25,1)
(5,64,1)
(73,43,1)
(3,43,1)
(2,105,1)
(32,25,1)
(48,22,1)
(11,8,1)
(96,1,1)
(47,33,1)
(13,80,1)
(56,59,1)
(18,17,1)
(43,56,1)
(53,82,1)
(38,9,1)
(56,22,1)
(27,66,1)
(102,96,1)
(76,37,1)
(40,35,1)
(42,95,1)
(25,34,1)
(94,104,1)
(103,50,1)
(95,23,1)
(14,48,1)
(61,47,1)
(23,101,1)
(7,22,1)
(59,7,1)
(66,55,1)
(60,20,1)
(70,49,1)
(40,45,1)
(85,51,1)
(98,64,1)
(4,99,1)
(35,5,1)
(80,40,1)
(105,85,1)
(99,103,1)
(107,61,1)
(86,5,1)
(91,71,1)
(27,55,1)
(82,92,1)
(31,42,1)
(72,60,1)
(104,41,1)
(6,105,1)
(95,22,1)
(37,56,1)
(49,67,1)
(76,22,1)
(64,12,1)
(63,27,1)
(67,107,1)
(52,76,1)
(34,52,1)
(26,93,1)
(19,94,1)
(83,14,1)
(42,73,1)
(94,80,1)
(23,70,1)
(60,12,2)
(76,56,2)
(108,75,2)
(84,88,2)
(31,43,2)
(25,56,2)
(53,82,2)
(18,60,2)
(26,88,2)
(47,27,2)
(19,61,2)
(101,88,2)
(75,102,2)
(23,88,2)
(88,25,2)
(95,88,2)
(102,96,2)
(13,80,2)
(38,18,2)
(99,12,2)
(82,6,2)
(45,18,2)
(0,75,2)
(104,12,2)
(52,56,2)
(35,5,2)
(4,18,2)
(32,56,2)
(14,61,2)
(39,6,2)
(9,99,2)
(12,65,2)
(58,94,2)
(40,61,2)
(43,56,2)
(73,43,2)
(37,56,2)
(25,76,2)
(83,11,2)
(3,43,2)
(8,27,2)
(103,18,2)
(65,22,2)
(66,88,2)
(18,97,2)
(61,27,2)
(78,27,2)
(22,53,2)
(95,61,2)
(5,94,2)
(64,94,2)
(5,64,2)
(65,80,2)
(92,6,2)
(60,75,2)
(107,61,2)
(12,80,2)
(95,22,2)
(9,18,2)
(75,5,2)
(104,80,2)
(61,47,2)
(80,94,2)
(94,104,2)
(27,88,2)
(71,75,2)
(83,3,2)
(72,75,2)
(29,94,2)
(48,22,2)
(99,18,2)
(94,61,2)
(28,75,2)
(42,43,2)
(16,18,2)
(94,80,2)
(49,61,2)
(42,61,2)
(77,5,2)
(76,22,2)
(42,88,2)
(63,27,2)
(84,43,2)
(70,61,2)
(48,61,2)
(27,55,2)
(55,10,2)
(34,56,2)
(98,94,2)
(36,80,2)
(25,34,2)
(6,105,2)
(91,75,2)
(10,88,2)
(31,88,2)
(9,17,2)
(23,61,2)
(11,27,2)
(1,5,2)
(18,75,2)
(96,5,2)
(88,56,2)
(20,75,2)
(83,14,2)
(55,88,2)
(50,18,2)
(67,61,2)
(64,12,2)
(93,88,2)
(80,61,2)
(56,22,2)
(86,5,2)
(84,61,2)
(40,94,2)
(18,17,2)
(41,80,2)
(94,94,2)
(31,61,2)
(33,27,2)
(102,5,2)
-----------------------------------
(0,globerr)
(1,GLOB_INDEX_READDIR)
(2,\'\\0\')
(3,return;)
(4,check_ncargs)
(5,dp->d_ino == 0)
(6,*gpath == \'\\0\')
(7,dirp)
(8,globerr = "Arguments too long")
(9,Gcat(gpath, dp->d_name, check_ncargs)
(10,limits[GLOB_INDEX_STAT])
(11,return;)
(12,dp = readdir(dirp)
(13,dp)
(14,return;)
(15,if (globbed)
(16,gpath)
(17,boolean_t check_ncargs)
(18,match(dp->d_name, pattern, check_ncargs)
(19,dirp)
(20,d_name)
(21,)
(22,dirp = opendir(*gpath == \'\\0\' ? "." : gpath)
(23,dirp)
(24,if (limits[GLOB_INDEX_STAT]++ >= GLOB_LIMIT_STAT)
(25,fstat(dirfd(dirp)
(26,GLOB_INDEX_STAT)
(27,limits[GLOB_INDEX_STAT]++ >= GLOB_LIMIT_STAT)
(28,check_ncargs)
(29,d_ino)
(30,if (fstat(dirfd(dirp)
(31,"Bad directory components")
(32,0)
(33,stb)
(34,&stb)
(35,continue;)
(36,dirp)
(37,dirp)
(38,globcnt)
(39,".")
(40,globerr)
(41,NULL)
(42,globerr)
(43,globbed)
(44,patherr1:)
(45,globcnt++)
(46,if (dp->d_ino == 0)
(47,isdir(stb)
(48,closedir(dirp)
(49,errno = ENOTDIR)
(50,dp)
(51,dirp)
(52,stb)
(53,opendir(*gpath == \'\\0\' ? "." : gpath)
(54,)
(55,limits[GLOB_INDEX_STAT]++)
(56,dirp == NULL)
(57,dp)
(58,dp)
(59,NULL)
(60,dp->d_name)
(61,!isdir(stb)
(62,if (!isdir(stb)
(63,globerr)
(64,dp->d_ino)
(65,readdir(dirp)
(66,GLOB_LIMIT_STAT)
(67,ENOTDIR)
(68,)
(69,if (limits[GLOB_INDEX_READDIR]++ >= GLOB_LIMIT_READDIR)
(70,goto patherr1;)
(71,"Arguments too long")
(72,pattern)
(73,goto patherr2;)
(74,while (!globerr && ((dp = readdir(dirp)
(75,limits[GLOB_INDEX_READDIR]++ >= GLOB_LIMIT_READDIR)
(76,dirfd(dirp)
(77,GLOB_LIMIT_READDIR)
(78,"Arguments too long")
(79,if (dirp == NULL)
(80,!globerr)
(81,patherr2:)
(82,*gpath == \'\\0\' ? "." : gpath)
(83,RET)
(84,globerr = "Bad directory components")
(85,gpath)
(86,limits)
(87,dirp)
(88,fstat(dirfd(dirp)
(89,stb)
(90,)
(91,globerr = "Arguments too long")
(92,gpath)
(93,limits)
(94,!globerr && ((dp = readdir(dirp)
(95,closedir(dirp)
(96,limits[GLOB_INDEX_READDIR])
(97,char *pattern)
(98,0)
(99,dp->d_name)
(100,)
(101,goto patherr1;)
(102,limits[GLOB_INDEX_READDIR]++)
(103,d_name)
(104,(dp = readdir(dirp)
(105,*gpath)
(106,)
(107,errno)
(108,dp)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^