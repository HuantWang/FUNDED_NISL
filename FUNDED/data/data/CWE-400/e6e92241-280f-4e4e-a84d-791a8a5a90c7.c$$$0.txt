-----label-----
0
-----code-----
static int get_passphrase(struct sftp_pkey *k, const char *path) {
  char prompt[256];
  FILE *fp;
  EVP_PKEY *pkey = NULL;
  int fd, prompt_fd = -1, res, xerrno;
  struct sftp_pkey_data pdata;
  register unsigned int attempt;

  memset(prompt, '\0', sizeof(prompt));
  snprintf(prompt, sizeof(prompt)-1, "Host key for the %s#%d (%s) server: ",
    pr_netaddr_get_ipstr(k->server->addr), k->server->ServerPort,
    k->server->ServerName);
  prompt[sizeof(prompt)-1] = '\0';

  PRIVS_ROOT
  fd = open(path, O_RDONLY);
  xerrno = errno;
  PRIVS_RELINQUISH

  if (fd < 0) {
    SYSerr(SYS_F_FOPEN, xerrno);
    errno = xerrno;
    return -1;
  }

  /* Make sure the fd isn't one of the big three. */
  if (fd <= STDERR_FILENO) {
    res = pr_fs_get_usable_fd(fd);
    if (res >= 0) {
      close(fd);
      fd = res;
    }
  }

  fp = fdopen(fd, "r");
  if (fp == NULL) {
    xerrno = errno;

    (void) close(fd); 
    SYSerr(SYS_F_FOPEN, xerrno);

    errno = xerrno;
    return -1;
  }

  k->host_pkey = get_page(PEM_BUFSIZE, &k->host_pkey_ptr);
  if (k->host_pkey == NULL) {
    pr_log_pri(PR_LOG_ALERT, MOD_SFTP_VERSION ": Out of memory!");
    exit(1);
  }

  pdata.s = k->server;
  pdata.buf = k->host_pkey;
  pdata.buflen = 0;
  pdata.bufsz = k->pkeysz;
  pdata.path = path;
  pdata.prompt = prompt;

  /* Reconnect stderr to the term because proftpd connects stderr, earlier,
   * to the general stderr logfile.
   */
  prompt_fd = open("/dev/null", O_WRONLY);
  if (prompt_fd == -1) {
    /* This is an arbitrary, meaningless placeholder number. */
    prompt_fd = 76;
  }

  dup2(STDERR_FILENO, prompt_fd);
  dup2(STDOUT_FILENO, STDERR_FILENO);

  /* The user gets three tries to enter the correct passphrase. */
  for (attempt = 0; attempt < 3; attempt++) {

    /* Always handle signals in a loop. */
    pr_signals_handle();

    pkey = PEM_read_PrivateKey(fp, NULL, get_passphrase_cb, &pdata);
    if (pkey)
      break;

    fseek(fp, 0, SEEK_SET);
    ERR_clear_error();
    fprintf(stderr, "\nWrong passphrase for this key.  Please try again.\n");
  }

  fclose(fp);

  /* Restore the normal stderr logging. */
  dup2(prompt_fd, STDERR_FILENO);
  close(prompt_fd);

  if (pkey == NULL)
    return -1;

  if (pdata.buflen > 0) {
#if OPENSSL_VERSION_NUMBER >= 0x000905000L
    /* Use the obtained passphrase as additional entropy, ostensibly
     * unknown to attackers who may be watching the network, for
     * OpenSSL's PRNG.
     *
     * Human language gives about 2-3 bits of entropy per byte (RFC1750).
     */
    RAND_add(pdata.buf, pdata.buflen, pdata.buflen * 0.25);
#endif

#ifdef HAVE_MLOCK
    PRIVS_ROOT
    if (mlock(k->host_pkey, k->pkeysz) < 0) {
      pr_log_debug(DEBUG1, MOD_SFTP_VERSION
        ": error locking passphrase into memory: %s", strerror(errno));

    } else {
      pr_log_debug(DEBUG1, MOD_SFTP_VERSION ": passphrase locked into memory");
    }
    PRIVS_RELINQUISH
#endif
  }

  EVP_PKEY_free(pkey);
  return 0;
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
5,6
5,7
6,7
8,9
8,10
11,12
11,13
13,14
13,15
16,17
16,18
16,19
16,20
16,21
16,22
16,23
16,24
16,25
16,26
16,27
16,28
16,29
16,30
16,31
16,32
16,33
16,34
16,35
16,36
16,37
16,38
16,39
16,40
16,41
16,42
16,43
16,44
16,45
16,46
16,47
16,48
16,49
16,50
16,51
16,52
16,53
17,18
18,19
18,20
20,21
20,22
22,23
24,25
25,26
25,27
26,27
28,29
28,30
31,32
32,33
32,34
33,34
35,36
35,37
35,38
38,39
39,40
41,42
42,43
42,44
42,45
42,46
42,47
44,45
46,47
46,48
48,49
49,50
51,52
53,54
55,56
56,57
56,58
57,58
59,60
61,62
62,63
62,64
64,65
66,67
67,68
67,69
67,70
67,71
68,69
70,71
73,74
74,75
75,76
77,78
78,79
78,80
78,81
78,82
78,83
78,84
78,85
79,80
81,82
83,84
83,85
84,85
85,86
86,87
90,91
90,92
91,92
93,94
93,95
94,95
94,96
95,96
99,100
99,101
100,101
100,102
101,102
105,106
105,107
106,107
106,108
107,108
111,112
112,113
112,114
113,114
113,115
114,115
116,117
116,118
117,118
118,119
119,120
123,124
124,125
124,126
125,126
127,128
127,129
129,130
130,131
130,132
130,133
131,132
133,134
135,136
137,138
138,139
138,140
139,140
141,142
143,144
144,145
146,147
147,148
147,149
148,149
148,150
149,150
152,153
152,154
152,155
153,154
154,155
154,156
154,157
155,156
157,158
159,160
161,162
162,163
162,164
163,164
165,166
167,168
168,169
170,171
170,172
171,172
171,173
172,173
174,175
176,177
176,178
177,178
178,179
178,180
179,180
181,182
181,183
182,183
184,185
186,187
186,188
187,188
187,189
188,189
191,192
191,193
192,193
193,194
193,195
194,195
196,197
198,199
199,200
199,201
200,201
202,203
204,205
205,206
205,207
206,207
208,209
208,210
208,211
209,210
211,212
214,215
214,216
215,216
215,217
216,217
218,219
220,221
220,222
220,223
220,224
220,225
221,222
222,223
222,224
223,224
225,226
227,228
228,229
228,230
229,230
229,231
232,233
232,234
233,234
235,236
237,238
238,239
238,240
238,241
239,240
241,242
243,244
245,246
246,247
246,248
247,248
249,250
251,252
252,253
254,255
255,256
255,257
256,257
256,258
257,258
260,261
260,262
260,263
261,262
263,264
265,266
266,267
266,268
267,268
270,271
270,272
271,272
271,273
272,273
272,274
273,274
276,277
278,279
278,280
279,280
280,281
281,282
281,283
282,283
285,286
286,287
286,288
287,288
287,289
288,289
291,292
291,293
292,293
295,296
296,297
296,298
297,298
297,299
298,299
301,302
301,303
302,303
305,306
306,307
306,308
307,308
307,309
308,309
312,313
313,314
313,315
314,315
314,316
315,316
318,319
318,320
319,320
322,323
323,324
323,325
324,325
324,326
325,326
328,329
330,331
331,332
331,333
332,333
332,334
333,334
336,337
338,339
339,340
339,341
340,341
342,343
342,344
342,345
343,344
346,347
348,349
348,350
349,350
349,351
350,351
352,353
354,355
355,356
356,357
356,358
357,358
360,361
361,362
361,363
361,364
362,363
364,365
366,367
368,369
369,370
369,371
369,372
370,371
372,373
374,375
376,377
376,378
376,379
376,380
377,378
378,379
378,380
379,380
382,383
382,384
383,384
386,387
387,388
389,390
389,391
389,392
389,393
389,394
389,395
390,391
391,392
392,393
394,395
395,396
395,397
396,397
398,399
398,400
398,401
398,402
398,403
399,400
401,402
403,404
405,406
407,408
408,409
410,411
410,412
411,412
414,415
415,416
415,417
415,418
415,419
416,417
418,419
421,422
423,424
424,425
425,426
427,428
428,429
428,430
428,431
429,430
431,432
434,435
435,436
435,437
436,437
438,439
440,441
441,442
441,443
441,444
442,443
444,445
446,447
448,449
449,450
449,451
450,451
452,453
454,455
454,456
455,456
455,457
456,457
458,459
460,461
461,462
463,464
463,465
464,465
464,466
465,466
465,467
466,467
471,472
472,473
472,474
473,474
475,476
477,478
-----nextToken-----
2,4,7,9,10,12,14,15,19,21,23,27,29,30,34,36,37,40,43,45,47,50,52,54,58,60,63,65,69,71,72,76,80,82,87,88,89,92,96,97,98,102,103,104,108,109,110,115,120,121,122,126,128,132,134,136,140,142,145,150,151,156,158,160,164,166,169,173,175,180,183,185,189,190,195,197,201,203,207,210,212,213,217,219,224,226,230,231,234,236,240,242,244,248,250,253,258,259,262,264,268,269,274,275,277,283,284,289,290,293,294,299,300,303,304,309,310,311,316,317,320,321,326,327,329,334,335,337,341,344,345,347,351,353,358,359,363,365,367,371,373,375,380,381,384,385,388,393,397,400,402,404,406,409,412,413,417,419,420,422,426,430,432,433,437,439,443,445,447,451,453,457,459,462,467,468,469,470,474,476,478
-----computeFrom-----
83,84
83,85
112,113
112,114
116,117
116,118
138,139
138,140
148,149
148,150
162,163
162,164
171,172
171,173
178,179
178,180
187,188
187,189
199,200
199,201
205,206
205,207
215,216
215,217
222,223
222,224
246,247
246,248
255,256
255,257
271,272
271,273
286,287
286,288
296,297
296,298
306,307
306,308
313,314
313,315
323,324
323,325
331,332
331,333
339,340
339,341
349,350
349,351
356,357
356,358
378,379
378,380
382,383
382,384
395,396
395,397
455,456
455,457
464,465
464,466
-----guardedBy-----
173,201
189,203
351,358
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;Declarator;Name;EqualsInitializer;UnaryExpression;LiteralExpression;Declarator;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;BinaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;IdExpression;Name;ProblemStatement;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;UnaryExpression;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;UnaryExpression;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ProblemStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;UnaryExpression;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;IdExpression;Name;BreakStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;UnaryExpression;LiteralExpression;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;LiteralExpression;
-----ast_node-----
static int get_passphrase(struct sftp_pkey *k, const char *path) {  char prompt[256];  FILE *fp;  EVP_PKEY *pkey = NULL;  int fd, prompt_fd = -1, res, xerrno;  struct sftp_pkey_data pdata;  register unsigned int attempt;  memset(prompt, '\0', sizeof(prompt));  snprintf(prompt, sizeof(prompt)-1, "Host key for the %s#%d (%s) server: ",    pr_netaddr_get_ipstr(k->server->addr), k->server->ServerPort,    k->server->ServerName);  prompt[sizeof(prompt)-1] = '\0';  PRIVS_ROOT  fd = open(path, O_RDONLY);  xerrno = errno;  PRIVS_RELINQUISH  if (fd < 0) {    SYSerr(SYS_F_FOPEN, xerrno);    errno = xerrno;    return -1;  }  /* Make sure the fd isn't one of the big three. */  if (fd <= STDERR_FILENO) {    res = pr_fs_get_usable_fd(fd);    if (res >= 0) {      close(fd);      fd = res;    }  }  fp = fdopen(fd, "r");  if (fp == NULL) {    xerrno = errno;    (void) close(fd);     SYSerr(SYS_F_FOPEN, xerrno);    errno = xerrno;    return -1;  }  k->host_pkey = get_page(PEM_BUFSIZE, &k->host_pkey_ptr);  if (k->host_pkey == NULL) {    pr_log_pri(PR_LOG_ALERT, MOD_SFTP_VERSION ": Out of memory!");    exit(1);  }  pdata.s = k->server;  pdata.buf = k->host_pkey;  pdata.buflen = 0;  pdata.bufsz = k->pkeysz;  pdata.path = path;  pdata.prompt = prompt;  /* Reconnect stderr to the term because proftpd connects stderr, earlier,   * to the general stderr logfile.   */  prompt_fd = open("/dev/null", O_WRONLY);  if (prompt_fd == -1) {    /* This is an arbitrary, meaningless placeholder number. */    prompt_fd = 76;  }  dup2(STDERR_FILENO, prompt_fd);  dup2(STDOUT_FILENO, STDERR_FILENO);  /* The user gets three tries to enter the correct passphrase. */  for (attempt = 0; attempt < 3; attempt++) {    /* Always handle signals in a loop. */    pr_signals_handle();    pkey = PEM_read_PrivateKey(fp, NULL, get_passphrase_cb, &pdata);    if (pkey)      break;    fseek(fp, 0, SEEK_SET);    ERR_clear_error();    fprintf(stderr, "\nWrong passphrase for this key.  Please try again.\n");  }  fclose(fp);  /* Restore the normal stderr logging. */  dup2(prompt_fd, STDERR_FILENO);  close(prompt_fd);  if (pkey == NULL)    return -1;  if (pdata.buflen > 0) {#if OPENSSL_VERSION_NUMBER >= 0x000905000L    /* Use the obtained passphrase as additional entropy, ostensibly     * unknown to attackers who may be watching the network, for     * OpenSSL's PRNG.     *     * Human language gives about 2-3 bits of entropy per byte (RFC1750).     */    RAND_add(pdata.buf, pdata.buflen, pdata.buflen * 0.25);#endif#ifdef HAVE_MLOCK    PRIVS_ROOT    if (mlock(k->host_pkey, k->pkeysz) < 0) {      pr_log_debug(DEBUG1, MOD_SFTP_VERSION        ": error locking passphrase into memory: %s", strerror(errno));    } else {      pr_log_debug(DEBUG1, MOD_SFTP_VERSION ": passphrase locked into memory");    }    PRIVS_RELINQUISH#endif  }  EVP_PKEY_free(pkey);  return 0;}
static int
get_passphrase(struct sftp_pkey *k, const char *path)
get_passphrase
struct sftp_pkey *k
struct sftp_pkey
sftp_pkey
*k
*
k
const char *path
const char
*path
*
path
{  char prompt[256];  FILE *fp;  EVP_PKEY *pkey = NULL;  int fd, prompt_fd = -1, res, xerrno;  struct sftp_pkey_data pdata;  register unsigned int attempt;  memset(prompt, '\0', sizeof(prompt));  snprintf(prompt, sizeof(prompt)-1, "Host key for the %s#%d (%s) server: ",    pr_netaddr_get_ipstr(k->server->addr), k->server->ServerPort,    k->server->ServerName);  prompt[sizeof(prompt)-1] = '\0';  PRIVS_ROOT  fd = open(path, O_RDONLY);  xerrno = errno;  PRIVS_RELINQUISH  if (fd < 0) {    SYSerr(SYS_F_FOPEN, xerrno);    errno = xerrno;    return -1;  }  /* Make sure the fd isn't one of the big three. */  if (fd <= STDERR_FILENO) {    res = pr_fs_get_usable_fd(fd);    if (res >= 0) {      close(fd);      fd = res;    }  }  fp = fdopen(fd, "r");  if (fp == NULL) {    xerrno = errno;    (void) close(fd);     SYSerr(SYS_F_FOPEN, xerrno);    errno = xerrno;    return -1;  }  k->host_pkey = get_page(PEM_BUFSIZE, &k->host_pkey_ptr);  if (k->host_pkey == NULL) {    pr_log_pri(PR_LOG_ALERT, MOD_SFTP_VERSION ": Out of memory!");    exit(1);  }  pdata.s = k->server;  pdata.buf = k->host_pkey;  pdata.buflen = 0;  pdata.bufsz = k->pkeysz;  pdata.path = path;  pdata.prompt = prompt;  /* Reconnect stderr to the term because proftpd connects stderr, earlier,   * to the general stderr logfile.   */  prompt_fd = open("/dev/null", O_WRONLY);  if (prompt_fd == -1) {    /* This is an arbitrary, meaningless placeholder number. */    prompt_fd = 76;  }  dup2(STDERR_FILENO, prompt_fd);  dup2(STDOUT_FILENO, STDERR_FILENO);  /* The user gets three tries to enter the correct passphrase. */  for (attempt = 0; attempt < 3; attempt++) {    /* Always handle signals in a loop. */    pr_signals_handle();    pkey = PEM_read_PrivateKey(fp, NULL, get_passphrase_cb, &pdata);    if (pkey)      break;    fseek(fp, 0, SEEK_SET);    ERR_clear_error();    fprintf(stderr, "\nWrong passphrase for this key.  Please try again.\n");  }  fclose(fp);  /* Restore the normal stderr logging. */  dup2(prompt_fd, STDERR_FILENO);  close(prompt_fd);  if (pkey == NULL)    return -1;  if (pdata.buflen > 0) {#if OPENSSL_VERSION_NUMBER >= 0x000905000L    /* Use the obtained passphrase as additional entropy, ostensibly     * unknown to attackers who may be watching the network, for     * OpenSSL's PRNG.     *     * Human language gives about 2-3 bits of entropy per byte (RFC1750).     */    RAND_add(pdata.buf, pdata.buflen, pdata.buflen * 0.25);#endif#ifdef HAVE_MLOCK    PRIVS_ROOT    if (mlock(k->host_pkey, k->pkeysz) < 0) {      pr_log_debug(DEBUG1, MOD_SFTP_VERSION        ": error locking passphrase into memory: %s", strerror(errno));    } else {      pr_log_debug(DEBUG1, MOD_SFTP_VERSION ": passphrase locked into memory");    }    PRIVS_RELINQUISH#endif  }  EVP_PKEY_free(pkey);  return 0;}
char prompt[256];
char prompt[256];
char
prompt[256]
prompt
[256]
256
FILE *fp;
FILE *fp;
FILE
FILE
*fp
*
fp
EVP_PKEY *pkey = NULL;
EVP_PKEY *pkey = NULL;
EVP_PKEY
EVP_PKEY
*pkey = NULL
*
pkey
= NULL
NULL
NULL
int fd, prompt_fd = -1, res, xerrno;
int fd, prompt_fd = -1, res, xerrno;
int
fd
fd
prompt_fd = -1
prompt_fd
= -1
-1
1
res
res
xerrno
xerrno
struct sftp_pkey_data pdata;
struct sftp_pkey_data pdata;
struct sftp_pkey_data
sftp_pkey_data
pdata
pdata
register unsigned int attempt;
register unsigned int attempt;
register unsigned int
attempt
attempt
memset(prompt, '\0', sizeof(prompt));
memset(prompt, '\0', sizeof(prompt))
memset
memset
prompt
prompt
'\0'
sizeof(prompt)
(prompt)
prompt
prompt
snprintf(prompt, sizeof(prompt)-1, "Host key for the %s#%d (%s) server: ",    pr_netaddr_get_ipstr(k->server->addr), k->server->ServerPort,    k->server->ServerName);
snprintf(prompt, sizeof(prompt)-1, "Host key for the %s#%d (%s) server: ",    pr_netaddr_get_ipstr(k->server->addr), k->server->ServerPort,    k->server->ServerName)
snprintf
snprintf
prompt
prompt
sizeof(prompt)-1
sizeof(prompt)
(prompt)
prompt
prompt
1
"Host key for the %s#%d (%s) server: "
pr_netaddr_get_ipstr(k->server->addr)
pr_netaddr_get_ipstr
pr_netaddr_get_ipstr
k->server->addr
k->server
k
k
server
addr
k->server->ServerPort
k->server
k
k
server
ServerPort
k->server->ServerName
k->server
k
k
server
ServerName
prompt[sizeof(prompt)-1] = '\0';
prompt[sizeof(prompt)-1] = '\0'
prompt[sizeof(prompt)-1]
prompt
prompt
sizeof(prompt)-1
sizeof(prompt)
(prompt)
prompt
prompt
1
'\0'
PRIVS_ROOT  fd = open(path, O_RDONLY);
PRIVS_ROOT  fd = open(path, O_RDONLY);
PRIVS_ROOT
PRIVS_ROOT
fd = open(path, O_RDONLY)
fd
= open(path, O_RDONLY)
open(path, O_RDONLY)
open
open
path
path
O_RDONLY
O_RDONLY
xerrno = errno;
xerrno = errno
xerrno
xerrno
errno
errno
PRIVS_RELINQUISH
PRIVS_RELINQUISH
PRIVS_RELINQUISH
H
if (fd < 0) {    SYSerr(SYS_F_FOPEN, xerrno);    errno = xerrno;    return -1;  }
fd < 0
fd
fd
0
{    SYSerr(SYS_F_FOPEN, xerrno);    errno = xerrno;    return -1;  }
SYSerr(SYS_F_FOPEN, xerrno);
SYSerr(SYS_F_FOPEN, xerrno)
SYSerr
SYSerr
SYS_F_FOPEN
SYS_F_FOPEN
xerrno
xerrno
errno = xerrno;
errno = xerrno
errno
errno
xerrno
xerrno
return -1;
-1
1
if (fd <= STDERR_FILENO) {    res = pr_fs_get_usable_fd(fd);    if (res >= 0) {      close(fd);      fd = res;    }  }
fd <= STDERR_FILENO
fd
fd
STDERR_FILENO
STDERR_FILENO
{    res = pr_fs_get_usable_fd(fd);    if (res >= 0) {      close(fd);      fd = res;    }  }
res = pr_fs_get_usable_fd(fd);
res = pr_fs_get_usable_fd(fd)
res
res
pr_fs_get_usable_fd(fd)
pr_fs_get_usable_fd
pr_fs_get_usable_fd
fd
fd
if (res >= 0) {      close(fd);      fd = res;    }
res >= 0
res
res
0
{      close(fd);      fd = res;    }
close(fd);
close(fd)
close
close
fd
fd
fd = res;
fd = res
fd
fd
res
res
fp = fdopen(fd, "r");
fp = fdopen(fd, "r")
fp
fp
fdopen(fd, "r")
fdopen
fdopen
fd
fd
"r"
if (fp == NULL) {    xerrno = errno;    (void) close(fd);     SYSerr(SYS_F_FOPEN, xerrno);    errno = xerrno;    return -1;  }
fp == NULL
fp
fp
NULL
NULL
{    xerrno = errno;    (void) close(fd);     SYSerr(SYS_F_FOPEN, xerrno);    errno = xerrno;    return -1;  }
xerrno = errno;
xerrno = errno
xerrno
xerrno
errno
errno
(void) close(fd);
(void) close(fd)
void
void

close(fd)
close
close
fd
fd
SYSerr(SYS_F_FOPEN, xerrno);
SYSerr(SYS_F_FOPEN, xerrno)
SYSerr
SYSerr
SYS_F_FOPEN
SYS_F_FOPEN
xerrno
xerrno
errno = xerrno;
errno = xerrno
errno
errno
xerrno
xerrno
return -1;
-1
1
k->host_pkey = get_page(PEM_BUFSIZE, &k->host_pkey_ptr);
k->host_pkey = get_page(PEM_BUFSIZE, &k->host_pkey_ptr)
k->host_pkey
k
k
host_pkey
get_page(PEM_BUFSIZE, &k->host_pkey_ptr)
get_page
get_page
PEM_BUFSIZE
PEM_BUFSIZE
&k->host_pkey_ptr
k->host_pkey_ptr
k
k
host_pkey_ptr
if (k->host_pkey == NULL) {    pr_log_pri(PR_LOG_ALERT, MOD_SFTP_VERSION ": Out of memory!");    exit(1);  }
k->host_pkey == NULL
k->host_pkey
k
k
host_pkey
NULL
NULL
{    pr_log_pri(PR_LOG_ALERT, MOD_SFTP_VERSION ": Out of memory!");    exit(1);  }
pr_log_pri(PR_LOG_ALERT, MOD_SFTP_VERSION ": Out of memory!");
exit(1);
exit(1)
exit
exit
1
pdata.s = k->server;
pdata.s = k->server
pdata.s
pdata
pdata
s
k->server
k
k
server
pdata.buf = k->host_pkey;
pdata.buf = k->host_pkey
pdata.buf
pdata
pdata
buf
k->host_pkey
k
k
host_pkey
pdata.buflen = 0;
pdata.buflen = 0
pdata.buflen
pdata
pdata
buflen
0
pdata.bufsz = k->pkeysz;
pdata.bufsz = k->pkeysz
pdata.bufsz
pdata
pdata
bufsz
k->pkeysz
k
k
pkeysz
pdata.path = path;
pdata.path = path
pdata.path
pdata
pdata
path
path
path
pdata.prompt = prompt;
pdata.prompt = prompt
pdata.prompt
pdata
pdata
prompt
prompt
prompt
prompt_fd = open("/dev/null", O_WRONLY);
prompt_fd = open("/dev/null", O_WRONLY)
prompt_fd
prompt_fd
open("/dev/null", O_WRONLY)
open
open
"/dev/null"
O_WRONLY
O_WRONLY
if (prompt_fd == -1) {    /* This is an arbitrary, meaningless placeholder number. */    prompt_fd = 76;  }
prompt_fd == -1
prompt_fd
prompt_fd
-1
1
{    /* This is an arbitrary, meaningless placeholder number. */    prompt_fd = 76;  }
prompt_fd = 76;
prompt_fd = 76
prompt_fd
prompt_fd
76
dup2(STDERR_FILENO, prompt_fd);
dup2(STDERR_FILENO, prompt_fd)
dup2
dup2
STDERR_FILENO
STDERR_FILENO
prompt_fd
prompt_fd
dup2(STDOUT_FILENO, STDERR_FILENO);
dup2(STDOUT_FILENO, STDERR_FILENO)
dup2
dup2
STDOUT_FILENO
STDOUT_FILENO
STDERR_FILENO
STDERR_FILENO
for (attempt = 0; attempt < 3; attempt++) {    /* Always handle signals in a loop. */    pr_signals_handle();    pkey = PEM_read_PrivateKey(fp, NULL, get_passphrase_cb, &pdata);    if (pkey)      break;    fseek(fp, 0, SEEK_SET);    ERR_clear_error();    fprintf(stderr, "\nWrong passphrase for this key.  Please try again.\n");  }
attempt = 0;
attempt = 0
attempt
attempt
0
attempt < 3
attempt
attempt
3
attempt++
attempt
attempt
{    /* Always handle signals in a loop. */    pr_signals_handle();    pkey = PEM_read_PrivateKey(fp, NULL, get_passphrase_cb, &pdata);    if (pkey)      break;    fseek(fp, 0, SEEK_SET);    ERR_clear_error();    fprintf(stderr, "\nWrong passphrase for this key.  Please try again.\n");  }
pr_signals_handle();
pr_signals_handle()
pr_signals_handle
pr_signals_handle
pkey = PEM_read_PrivateKey(fp, NULL, get_passphrase_cb, &pdata);
pkey = PEM_read_PrivateKey(fp, NULL, get_passphrase_cb, &pdata)
pkey
pkey
PEM_read_PrivateKey(fp, NULL, get_passphrase_cb, &pdata)
PEM_read_PrivateKey
PEM_read_PrivateKey
fp
fp
NULL
NULL
get_passphrase_cb
get_passphrase_cb
&pdata
pdata
pdata
if (pkey)      break;
pkey
pkey
break;
fseek(fp, 0, SEEK_SET);
fseek(fp, 0, SEEK_SET)
fseek
fseek
fp
fp
0
SEEK_SET
SEEK_SET
ERR_clear_error();
ERR_clear_error()
ERR_clear_error
ERR_clear_error
fprintf(stderr, "\nWrong passphrase for this key.  Please try again.\n");
fprintf(stderr, "\nWrong passphrase for this key.  Please try again.\n")
fprintf
fprintf
stderr
stderr
"\nWrong passphrase for this key.  Please try again.\n"
fclose(fp);
fclose(fp)
fclose
fclose
fp
fp
dup2(prompt_fd, STDERR_FILENO);
dup2(prompt_fd, STDERR_FILENO)
dup2
dup2
prompt_fd
prompt_fd
STDERR_FILENO
STDERR_FILENO
close(prompt_fd);
close(prompt_fd)
close
close
prompt_fd
prompt_fd
if (pkey == NULL)    return -1;
pkey == NULL
pkey
pkey
NULL
NULL
return -1;
-1
1
if (pdata.buflen > 0) {#if OPENSSL_VERSION_NUMBER >= 0x000905000L    /* Use the obtained passphrase as additional entropy, ostensibly     * unknown to attackers who may be watching the network, for     * OpenSSL's PRNG.     *     * Human language gives about 2-3 bits of entropy per byte (RFC1750).     */    RAND_add(pdata.buf, pdata.buflen, pdata.buflen * 0.25);#endif#ifdef HAVE_MLOCK    PRIVS_ROOT    if (mlock(k->host_pkey, k->pkeysz) < 0) {      pr_log_debug(DEBUG1, MOD_SFTP_VERSION        ": error locking passphrase into memory: %s", strerror(errno));    } else {      pr_log_debug(DEBUG1, MOD_SFTP_VERSION ": passphrase locked into memory");    }    PRIVS_RELINQUISH#endif  }
pdata.buflen > 0
pdata.buflen
pdata
pdata
buflen
0
{#if OPENSSL_VERSION_NUMBER >= 0x000905000L    /* Use the obtained passphrase as additional entropy, ostensibly     * unknown to attackers who may be watching the network, for     * OpenSSL's PRNG.     *     * Human language gives about 2-3 bits of entropy per byte (RFC1750).     */    RAND_add(pdata.buf, pdata.buflen, pdata.buflen * 0.25);#endif#ifdef HAVE_MLOCK    PRIVS_ROOT    if (mlock(k->host_pkey, k->pkeysz) < 0) {      pr_log_debug(DEBUG1, MOD_SFTP_VERSION        ": error locking passphrase into memory: %s", strerror(errno));    } else {      pr_log_debug(DEBUG1, MOD_SFTP_VERSION ": passphrase locked into memory");    }    PRIVS_RELINQUISH#endif  }
EVP_PKEY_free(pkey);
EVP_PKEY_free(pkey)
EVP_PKEY_free
EVP_PKEY_free
pkey
pkey
return 0;
0
-----joern-----
(29,151,0)
(252,217,0)
(235,90,0)
(215,29,0)
(139,40,0)
(239,201,0)
(275,128,0)
(20,68,0)
(96,230,0)
(143,94,0)
(257,61,0)
(14,244,0)
(114,249,0)
(24,181,0)
(184,209,0)
(187,34,0)
(243,127,0)
(267,22,0)
(140,61,0)
(65,38,0)
(72,146,0)
(120,217,0)
(174,2,0)
(226,46,0)
(73,116,0)
(263,274,0)
(53,255,0)
(216,163,0)
(135,46,0)
(120,9,0)
(115,74,0)
(271,38,0)
(23,36,0)
(188,241,0)
(181,127,0)
(238,204,0)
(135,72,0)
(236,209,0)
(103,230,0)
(84,50,0)
(128,57,0)
(58,54,0)
(74,146,0)
(83,228,0)
(237,87,0)
(261,98,0)
(255,237,0)
(111,249,0)
(234,57,0)
(14,81,0)
(87,237,0)
(109,243,0)
(116,265,0)
(127,207,0)
(94,209,0)
(208,93,0)
(5,98,0)
(151,5,0)
(228,209,0)
(150,127,0)
(82,209,0)
(7,94,0)
(256,151,0)
(194,146,0)
(35,90,0)
(102,101,0)
(219,209,0)
(242,26,0)
(25,98,0)
(68,41,0)
(134,274,0)
(196,180,0)
(59,72,0)
(204,262,0)
(148,85,0)
(112,265,0)
(206,146,0)
(108,214,0)
(119,241,0)
(61,13,0)
(22,267,0)
(155,245,0)
(165,40,0)
(117,209,0)
(88,57,0)
(69,66,0)
(84,209,0)
(91,81,0)
(247,219,0)
(57,183,0)
(4,126,0)
(15,172,0)
(160,194,0)
(22,198,0)
(87,6,0)
(152,245,0)
(205,95,0)
(49,4,0)
(26,214,0)
(182,170,0)
(35,55,0)
(186,262,0)
(227,186,0)
(190,198,0)
(10,78,0)
(147,191,0)
(171,101,0)
(135,81,0)
(16,36,0)
(185,5,0)
(217,133,0)
(90,35,0)
(151,256,0)
(128,18,0)
(177,79,0)
(122,128,0)
(110,207,0)
(65,190,0)
(156,170,0)
(106,209,0)
(246,9,0)
(87,54,0)
(101,9,0)
(217,120,0)
(97,209,0)
(61,243,0)
(167,93,0)
(132,10,0)
(14,241,0)
(88,126,0)
(155,209,0)
(149,209,0)
(22,146,0)
(128,103,0)
(137,243,0)
(253,181,0)
(35,74,0)
(142,265,0)
(258,275,0)
(269,133,0)
(85,57,0)
(274,202,0)
(144,22,0)
(46,267,0)
(78,10,0)
(164,209,0)
(86,132,0)
(127,242,0)
(223,55,0)
(219,95,0)
(190,65,0)
(267,209,0)
(138,88,0)
(192,159,0)
(245,155,0)
(132,243,0)
(180,146,0)
(2,209,0)
(72,198,0)
(11,209,0)
(145,194,0)
(197,9,0)
(124,262,0)
(214,202,0)
(92,201,0)
(2,50,0)
(225,261,0)
(218,172,0)
(66,120,0)
(256,261,0)
(163,228,0)
(14,72,0)
(93,98,0)
(79,45,0)
(236,172,0)
(251,180,0)
(63,169,0)
(10,132,0)
(121,81,0)
(90,146,0)
(193,209,0)
(272,209,0)
(38,65,0)
(85,148,0)
(168,249,0)
(265,116,0)
(88,4,0)
(222,209,0)
(26,209,0)
(151,233,0)
(70,141,0)
(122,88,0)
(266,251,0)
(13,61,0)
(232,84,0)
(87,209,0)
(67,262,0)
(45,79,0)
(132,26,0)
(172,236,0)
(99,209,0)
(38,146,0)
(17,206,0)
(87,189,0)
(98,209,0)
(0,46,0)
(76,209,0)
(14,163,0)
(10,18,0)
(240,63,0)
(32,233,0)
(203,2,0)
(220,263,0)
(250,237,0)
(200,141,0)
(52,5,0)
(135,263,0)
(1,63,0)
(178,206,0)
(93,208,0)
(55,35,0)
(129,209,0)
(242,127,0)
(89,38,0)
(265,209,0)
(111,126,0)
(105,85,0)
(71,208,0)
(3,209,0)
(231,74,0)
(243,41,0)
(268,125,0)
(13,209,0)
(183,209,0)
(14,46,0)
(135,241,0)
(94,50,0)
(40,3,0)
(249,209,0)
(57,85,0)
(189,87,0)
(244,99,0)
(191,209,0)
(118,214,0)
(77,111,0)
(6,87,0)
(40,120,0)
(107,103,0)
(135,163,0)
(74,35,0)
(170,26,0)
(47,179,0)
(195,95,0)
(136,90,0)
(141,209,0)
(14,263,0)
(135,209,0)
(162,217,0)
(133,217,0)
(84,219,0)
(61,26,0)
(30,9,0)
(260,4,0)
(104,189,0)
(199,22,0)
(21,30,0)
(135,57,0)
(103,18,0)
(4,249,0)
(206,99,0)
(180,251,0)
(125,254,0)
(201,18,0)
(36,26,0)
(66,3,0)
(157,135,0)
(74,198,0)
(66,209,0)
(213,50,0)
(211,159,0)
(198,209,0)
(179,13,0)
(54,194,0)
(169,63,0)
(264,263,0)
(122,135,0)
(81,98,0)
(135,244,0)
(6,251,0)
(113,50,0)
(130,180,0)
(273,120,0)
(39,45,0)
(28,72,0)
(237,255,0)
(80,244,0)
(201,230,0)
(63,198,0)
(175,209,0)
(159,189,0)
(33,13,0)
(153,9,0)
(261,256,0)
(161,93,0)
(12,179,0)
(43,148,0)
(79,219,0)
(2,219,0)
(230,18,0)
(241,236,0)
(158,261,0)
(95,219,0)
(34,14,0)
(100,256,0)
(123,183,0)
(176,209,0)
(274,209,0)
(14,57,0)
(60,244,0)
(214,26,0)
(122,14,0)
(159,146,0)
(8,204,0)
(212,29,0)
(154,217,0)
(99,206,0)
(189,159,0)
(62,30,0)
(270,155,0)
(194,54,0)
(42,26,0)
(64,242,0)
(198,190,0)
(251,6,0)
(54,87,0)
(31,230,0)
(63,146,0)
(172,146,0)
(131,30,0)
(19,3,0)
(30,13,0)
(151,29,0)
(248,3,0)
(191,13,0)
(217,13,0)
(75,87,0)
(221,87,0)
(94,219,0)
(27,169,0)
(229,209,0)
(37,103,0)
(68,26,0)
(259,163,0)
(224,190,0)
(51,111,0)
(56,209,0)
(29,267,0)
(50,166,0)
(5,151,0)
(210,138,0)
(44,209,0)
(231,151,1)
(10,132,1)
(250,255,1)
(151,29,1)
(4,49,1)
(269,162,1)
(73,112,1)
(84,232,1)
(247,228,1)
(35,90,1)
(119,125,1)
(89,224,1)
(14,46,1)
(179,13,1)
(189,159,1)
(241,188,1)
(154,273,1)
(165,84,1)
(133,269,1)
(88,4,1)
(28,179,1)
(261,98,1)
(180,146,1)
(90,146,1)
(54,58,1)
(141,200,1)
(243,127,1)
(194,146,1)
(188,119,1)
(131,62,1)
(63,146,1)
(107,37,1)
(43,234,1)
(42,183,1)
(116,73,1)
(105,148,1)
(128,57,1)
(100,261,1)
(262,67,1)
(171,153,1)
(119,169,1)
(225,158,1)
(112,142,1)
(203,50,1)
(83,163,1)
(172,146,1)
(205,195,1)
(213,79,1)
(38,146,1)
(270,3,1)
(24,127,1)
(170,26,1)
(155,245,1)
(240,198,1)
(17,178,1)
(93,161,1)
(134,263,1)
(86,230,1)
(22,146,1)
(2,219,1)
(156,182,1)
(34,187,1)
(216,259,1)
(87,189,1)
(46,226,1)
(14,34,1)
(23,170,1)
(223,35,1)
(227,101,1)
(177,219,1)
(258,103,1)
(94,50,1)
(22,144,1)
(218,241,1)
(71,93,1)
(36,26,1)
(0,236,1)
(4,249,1)
(45,39,1)
(180,130,1)
(251,180,1)
(81,91,1)
(157,66,1)
(69,208,1)
(39,177,1)
(167,40,1)
(33,36,1)
(2,174,1)
(252,154,1)
(125,268,1)
(211,6,1)
(48,173,1)
(88,138,1)
(151,5,1)
(147,48,1)
(122,128,1)
(52,185,1)
(40,3,1)
(243,109,1)
(145,160,1)
(158,5,1)
(14,244,1)
(47,12,1)
(121,267,1)
(57,85,1)
(253,24,1)
(159,192,1)
(94,219,1)
(135,157,1)
(203,79,1)
(122,88,1)
(33,243,1)
(14,163,1)
(19,248,1)
(268,169,1)
(135,263,1)
(169,63,1)
(245,152,1)
(58,194,1)
(12,13,1)
(122,14,1)
(55,35,1)
(244,60,1)
(147,204,1)
(66,3,1)
(79,219,1)
(132,243,1)
(200,70,1)
(74,198,1)
(72,146,1)
(217,133,1)
(150,36,1)
(264,99,1)
(197,204,1)
(135,163,1)
(212,208,1)
(3,19,1)
(50,113,1)
(14,263,1)
(74,146,1)
(87,6,1)
(63,1,1)
(15,218,1)
(181,253,1)
(191,147,1)
(196,221,1)
(183,123,1)
(151,256,1)
(174,203,1)
(260,111,1)
(236,172,1)
(55,223,1)
(1,240,1)
(261,225,1)
(5,98,1)
(91,121,1)
(153,30,1)
(228,83,1)
(115,231,1)
(135,241,1)
(36,16,1)
(118,42,1)
(271,89,1)
(230,96,1)
(221,237,1)
(249,114,1)
(29,215,1)
(142,155,1)
(20,181,1)
(27,63,1)
(66,120,1)
(206,146,1)
(238,186,1)
(7,143,1)
(124,141,1)
(199,46,1)
(135,72,1)
(98,25,1)
(143,191,1)
(123,57,1)
(219,95,1)
(242,64,1)
(93,98,1)
(16,23,1)
(201,230,1)
(186,262,1)
(160,189,1)
(85,148,1)
(87,54,1)
(120,217,1)
(79,45,1)
(102,171,1)
(26,214,1)
(187,40,1)
(68,20,1)
(161,167,1)
(214,108,1)
(224,72,1)
(208,71,1)
(99,206,1)
(135,46,1)
(61,140,1)
(226,0,1)
(179,47,1)
(63,198,1)
(84,219,1)
(8,238,1)
(33,181,1)
(204,262,1)
(170,156,1)
(132,26,1)
(195,247,1)
(208,93,1)
(62,21,1)
(159,146,1)
(88,57,1)
(263,220,1)
(189,104,1)
(70,2,1)
(148,43,1)
(77,170,1)
(186,227,1)
(130,196,1)
(69,55,1)
(266,180,1)
(273,197,1)
(61,243,1)
(94,7,1)
(144,199,1)
(92,239,1)
(2,50,1)
(192,211,1)
(114,168,1)
(67,124,1)
(232,94,1)
(168,26,1)
(31,179,1)
(128,103,1)
(256,261,1)
(84,50,1)
(14,81,1)
(122,135,1)
(251,266,1)
(210,4,1)
(10,78,1)
(35,74,1)
(64,150,1)
(38,271,1)
(206,17,1)
(66,69,1)
(59,28,1)
(259,274,1)
(74,115,1)
(14,72,1)
(237,255,1)
(40,120,1)
(54,194,1)
(182,249,1)
(140,257,1)
(90,136,1)
(235,74,1)
(51,77,1)
(274,202,1)
(21,173,1)
(37,201,1)
(85,105,1)
(178,244,1)
(190,65,1)
(191,13,1)
(25,81,1)
(135,81,1)
(22,198,1)
(6,251,1)
(239,10,1)
(257,33,1)
(194,145,1)
(275,258,1)
(255,53,1)
(198,190,1)
(103,107,1)
(234,87,1)
(127,242,1)
(152,270,1)
(101,102,1)
(220,264,1)
(68,26,1)
(14,241,1)
(40,139,1)
(138,210,1)
(163,216,1)
(185,29,1)
(80,98,1)
(214,202,1)
(111,249,1)
(96,31,1)
(181,127,1)
(217,13,1)
(136,235,1)
(29,267,1)
(162,252,1)
(215,212,1)
(139,165,1)
(72,59,1)
(87,237,1)
(13,61,1)
(128,275,1)
(30,13,1)
(242,26,1)
(256,100,1)
(103,230,1)
(60,80,1)
(108,118,1)
(265,116,1)
(169,27,1)
(237,250,1)
(173,120,1)
(204,8,1)
(53,75,1)
(95,205,1)
(135,57,1)
(30,131,1)
(238,262,1)
(14,57,1)
(104,159,1)
(65,38,1)
(135,244,1)
(113,213,1)
(61,26,1)
(75,265,1)
(5,52,1)
(111,51,1)
(49,260,1)
(137,68,1)
(109,137,1)
(274,134,1)
(172,15,1)
(201,92,1)
(132,86,1)
(267,22,1)
(99,179,2)
(59,179,2)
(63,198,2)
(103,230,2)
(65,38,2)
(35,90,2)
(60,179,2)
(273,204,2)
(267,179,2)
(151,29,2)
(86,179,2)
(66,120,2)
(70,179,2)
(275,179,2)
(274,179,2)
(169,63,2)
(242,26,2)
(128,179,2)
(74,198,2)
(119,179,2)
(8,179,2)
(87,237,2)
(135,163,2)
(224,179,2)
(167,40,2)
(205,179,2)
(46,179,2)
(14,263,2)
(22,198,2)
(195,179,2)
(51,170,2)
(197,204,2)
(216,179,2)
(236,172,2)
(69,40,2)
(191,179,2)
(6,251,2)
(38,179,2)
(14,57,2)
(262,179,2)
(67,179,2)
(122,135,2)
(179,13,2)
(257,170,2)
(36,170,2)
(81,179,2)
(79,219,2)
(172,179,2)
(0,179,2)
(139,179,2)
(10,78,2)
(173,204,2)
(172,146,2)
(135,72,2)
(178,179,2)
(241,179,2)
(269,204,2)
(87,6,2)
(256,261,2)
(14,72,2)
(4,170,2)
(238,173,2)
(92,179,2)
(165,179,2)
(90,146,2)
(125,169,2)
(219,95,2)
(186,173,2)
(226,179,2)
(151,5,2)
(88,57,2)
(122,14,2)
(14,40,2)
(61,243,2)
(208,93,2)
(128,57,2)
(244,179,2)
(194,146,2)
(14,244,2)
(120,217,2)
(220,179,2)
(49,170,2)
(89,179,2)
(45,179,2)
(217,133,2)
(23,170,2)
(243,127,2)
(135,57,2)
(64,36,2)
(26,214,2)
(96,179,2)
(223,208,2)
(208,40,2)
(238,179,2)
(12,170,2)
(85,148,2)
(79,45,2)
(84,179,2)
(74,208,2)
(237,255,2)
(159,146,2)
(185,208,2)
(35,74,2)
(40,120,2)
(61,26,2)
(212,208,2)
(22,179,2)
(218,179,2)
(230,179,2)
(151,208,2)
(62,173,2)
(132,243,2)
(122,88,2)
(40,3,2)
(88,170,2)
(103,179,2)
(203,179,2)
(141,179,2)
(186,262,2)
(17,179,2)
(5,208,2)
(143,179,2)
(217,13,2)
(61,170,2)
(13,170,2)
(127,242,2)
(21,173,2)
(235,208,2)
(71,40,2)
(80,179,2)
(90,208,2)
(261,208,2)
(98,179,2)
(256,208,2)
(189,159,2)
(162,204,2)
(153,173,2)
(181,127,2)
(29,208,2)
(5,98,2)
(30,173,2)
(2,179,2)
(94,179,2)
(84,50,2)
(259,179,2)
(40,179,2)
(263,179,2)
(163,179,2)
(206,179,2)
(95,179,2)
(22,146,2)
(52,208,2)
(177,179,2)
(131,173,2)
(87,189,2)
(2,219,2)
(24,36,2)
(258,179,2)
(99,206,2)
(30,13,2)
(122,128,2)
(55,35,2)
(109,181,2)
(181,36,2)
(198,190,2)
(63,146,2)
(204,173,2)
(199,179,2)
(188,179,2)
(214,202,2)
(10,132,2)
(140,170,2)
(48,173,2)
(201,230,2)
(107,179,2)
(124,179,2)
(155,245,2)
(16,170,2)
(115,208,2)
(87,54,2)
(228,179,2)
(14,241,2)
(120,204,2)
(121,179,2)
(264,179,2)
(38,146,2)
(93,40,2)
(37,179,2)
(243,181,2)
(144,179,2)
(231,208,2)
(271,179,2)
(135,46,2)
(210,170,2)
(34,40,2)
(179,170,2)
(135,81,2)
(157,40,2)
(137,181,2)
(47,170,2)
(1,179,2)
(93,98,2)
(66,3,2)
(28,179,2)
(267,22,2)
(39,179,2)
(190,65,2)
(253,36,2)
(79,179,2)
(135,263,2)
(161,40,2)
(14,163,2)
(72,146,2)
(225,208,2)
(50,79,2)
(252,204,2)
(72,179,2)
(25,179,2)
(65,179,2)
(55,208,2)
(127,36,2)
(150,36,2)
(68,181,2)
(94,50,2)
(204,179,2)
(169,179,2)
(200,179,2)
(158,208,2)
(8,173,2)
(102,173,2)
(261,98,2)
(174,179,2)
(213,79,2)
(206,146,2)
(63,179,2)
(36,26,2)
(111,249,2)
(33,170,2)
(128,103,2)
(180,146,2)
(66,40,2)
(247,179,2)
(135,244,2)
(219,179,2)
(88,4,2)
(251,180,2)
(134,179,2)
(14,46,2)
(133,204,2)
(242,36,2)
(135,241,2)
(74,146,2)
(20,181,2)
(227,173,2)
(100,208,2)
(35,208,2)
(151,256,2)
(10,179,2)
(83,179,2)
(14,81,2)
(135,40,2)
(132,26,2)
(27,179,2)
(7,179,2)
(268,169,2)
(187,40,2)
(215,208,2)
(217,204,2)
(31,179,2)
(171,173,2)
(240,179,2)
(260,170,2)
(232,179,2)
(147,179,2)
(201,179,2)
(191,13,2)
(84,219,2)
(91,179,2)
(190,179,2)
(94,219,2)
(111,170,2)
(170,26,2)
(132,179,2)
(29,267,2)
(265,116,2)
(15,179,2)
(77,170,2)
(239,179,2)
(138,170,2)
(13,61,2)
(4,249,2)
(236,179,2)
(2,50,2)
(54,194,2)
(101,173,2)
(136,208,2)
(68,26,2)
(274,202,2)
(154,204,2)
(198,179,2)
(113,79,2)
(204,262,2)
(57,85,2)
-----------------------------------
(0,pdata)
(1,host_pkey)
(2,dup2(STDERR_FILENO, prompt_fd)
(3,*pkey = NULL)
(4,errno = xerrno)
(5,pdata.buflen)
(6,pr_netaddr_get_ipstr(k->server->addr)
(7,STDERR_FILENO)
(8,3)
(9,)
(10,(void)
(11,if (fd <= STDERR_FILENO)
(12,fp)
(13,fp = fdopen(fd, "r")
(14,return -1;)
(15,server)
(16,STDERR_FILENO)
(17,pkeysz)
(18,)
(19,NULL)
(20,fd)
(21,fp)
(22,k->host_pkey)
(23,fd)
(24,res)
(25,0)
(26,fd = open(path, O_RDONLY)
(27,NULL)
(28,k)
(29,pdata.buf)
(30,fseek(fp, 0, SEEK_SET)
(31,xerrno)
(32,if (mlock(k->host_pkey, k->pkeysz)
(33,fp)
(34,-1)
(35,mlock(k->host_pkey, k->pkeysz)
(36,fd <= STDERR_FILENO)
(37,errno)
(38,k->host_pkey_ptr)
(39,1)
(40,pkey == NULL)
(41,)
(42,fd)
(43,prompt)
(44,if (pdata.buflen > 0)
(45,-1)
(46,pdata.buf)
(47,NULL)
(48,break;)
(49,xerrno)
(50,prompt_fd = 76)
(51,xerrno)
(52,buflen)
(53,prompt)
(54,k->server->ServerName)
(55,mlock(k->host_pkey, k->pkeysz)
(56,if (fd < 0)
(57,prompt[sizeof(prompt)
(58,ServerName)
(59,host_pkey)
(60,bufsz)
(61,fdopen(fd, "r")
(62,0)
(63,k->host_pkey)
(64,fd)
(65,&k->host_pkey_ptr)
(66,EVP_PKEY_free(pkey)
(67,0)
(68,close(fd)
(69,pkey)
(70,STDOUT_FILENO)
(71,0)
(72,k->host_pkey)
(73,prompt)
(74,k->host_pkey)
(75,prompt)
(76,attempt)
(77,SYS_F_FOPEN)
(78,void)
(79,prompt_fd == -1)
(80,pdata)
(81,pdata.buflen)
(82,for (attempt = 0; attempt < 3; attempt++)
(83,prompt)
(84,close(prompt_fd)
(85,sizeof(prompt)
(86,fd)
(87,snprintf(prompt, sizeof(prompt)
(88,return -1;)
(89,k)
(90,k->pkeysz)
(91,buflen)
(92,xerrno)
(93,pdata.buflen)
(94,dup2(prompt_fd, STDERR_FILENO)
(95,open("/dev/null", O_WRONLY)
(96,errno)
(97,prompt)
(98,pdata.buflen = 0)
(99,pdata.bufsz = k->pkeysz)
(100,0.25)
(101,fprintf(stderr, "\\nWrong passphrase for this key.  Please try again.\\n")
(102,"\\nWrong passphrase for this key.  Please try again.\\n")
(103,errno = xerrno)
(104,ServerPort)
(105,1)
(106,if (k->host_pkey == NULL)
(107,xerrno)
(108,O_RDONLY)
(109,res)
(110,if (res >= 0)
(111,SYSerr(SYS_F_FOPEN, xerrno)
(112,\'\\0\')
(113,76)
(114,errno)
(115,host_pkey)
(116,sizeof(prompt)
(117,fd)
(118,path)
(119,pdata)
(120,pkey = PEM_read_PrivateKey(fp, NULL, get_passphrase_cb, &pdata)
(121,pdata)
(122,RET)
(123,\'\\0\')
(124,attempt)
(125,exit(1)
(126,)
(127,res = pr_fs_get_usable_fd(fd)
(128,return -1;)
(129,xerrno)
(130,server)
(131,SEEK_SET)
(132,close(fd)
(133,&pdata)
(134,path)
(135,return 0;)
(136,pkeysz)
(137,fd)
(138,-1)
(139,NULL)
(140,"r")
(141,dup2(STDOUT_FILENO, STDERR_FILENO)
(142,prompt)
(143,prompt_fd)
(144,host_pkey)
(145,server)
(146,struct sftp_pkey *k)
(147,fp)
(148,sizeof(prompt)
(149,pkey)
(150,res)
(151,RAND_add(pdata.buf, pdata.buflen, pdata.buflen * 0.25)
(152,1)
(153,ERR_clear_error()
(154,fp)
(155,prompt_fd = -1)
(156,0)
(157,0)
(158,pdata)
(159,k->server)
(160,k)
(161,buflen)
(162,get_passphrase_cb)
(163,pdata.prompt)
(164,res)
(165,pkey)
(166,)
(167,pdata)
(168,xerrno)
(169,k->host_pkey == NULL)
(170,fd < 0)
(171,stderr)
(172,k->server)
(173,pkey)
(174,prompt_fd)
(175,pdata)
(176,prompt_fd)
(177,prompt_fd)
(178,k)
(179,fp == NULL)
(180,k->server)
(181,res >= 0)
(182,fd)
(183,prompt[sizeof(prompt)
(184,fd)
(185,pdata)
(186,attempt++)
(187,1)
(188,s)
(189,k->server->ServerPort)
(190,get_page(PEM_BUFSIZE, &k->host_pkey_ptr)
(191,fclose(fp)
(192,server)
(193,fp)
(194,k->server)
(195,"/dev/null")
(196,k)
(197,pr_signals_handle()
(198,k->host_pkey = get_page(PEM_BUFSIZE, &k->host_pkey_ptr)
(199,k)
(200,STDERR_FILENO)
(201,SYSerr(SYS_F_FOPEN, xerrno)
(202,const char *path)
(203,STDERR_FILENO)
(204,attempt < 3)
(205,O_WRONLY)
(206,k->pkeysz)
(207,)
(208,pdata.buflen > 0)
(209,)
(210,1)
(211,k)
(212,pdata)
(213,prompt_fd)
(214,open(path, O_RDONLY)
(215,buf)
(216,prompt)
(217,PEM_read_PrivateKey(fp, NULL, get_passphrase_cb, &pdata)
(218,k)
(219,prompt_fd = open("/dev/null", O_WRONLY)
(220,path)
(221,"Host key for the %s#%d (%s)
(222,if (pkey == NULL)
(223,0)
(224,PEM_BUFSIZE)
(225,buflen)
(226,buf)
(227,attempt)
(228,pdata.prompt = prompt)
(229,if (prompt_fd == -1)
(230,xerrno = errno)
(231,k)
(232,prompt_fd)
(233,)
(234,prompt)
(235,k)
(236,pdata.s = k->server)
(237,sizeof(prompt)
(238,attempt)
(239,SYS_F_FOPEN)
(240,k)
(241,pdata.s)
(242,pr_fs_get_usable_fd(fd)
(243,fd = res)
(244,pdata.bufsz)
(245,-1)
(246,if (pkey)
(247,prompt_fd)
(248,pkey)
(249,xerrno = errno)
(250,1)
(251,k->server->addr)
(252,NULL)
(253,0)
(254,)
(255,sizeof(prompt)
(256,pdata.buflen * 0.25)
(257,fd)
(258,1)
(259,pdata)
(260,errno)
(261,pdata.buflen)
(262,attempt = 0)
(263,pdata.path)
(264,pdata)
(265,memset(prompt, \'\\0\', sizeof(prompt)
(266,addr)
(267,pdata.buf = k->host_pkey)
(268,1)
(269,pdata)
(270,prompt_fd)
(271,host_pkey_ptr)
(272,if (fp == NULL)
(273,pkey)
(274,pdata.path = path)
(275,-1)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^