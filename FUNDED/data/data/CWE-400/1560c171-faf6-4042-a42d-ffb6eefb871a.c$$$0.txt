-----label-----
1
-----code-----
int
mca_btl_portals_component_progress(void)
{
    int num_progressed = 0;
    int ret, which;
    static ptl_event_t ev;
    mca_btl_portals_frag_t *frag = NULL;
    mca_btl_portals_recv_block_t *block = NULL;
    mca_btl_base_tag_t tag;

    if (0 == mca_btl_portals_module.portals_num_procs) {
        return 0;
    }

    while (true) {
        ret = PtlEQPoll(mca_btl_portals_module.portals_eq_handles,
                        OMPI_BTL_PORTALS_EQ_SIZE,
#if OMPI_BTL_PORTALS_REDSTORM
                        0, /* timeout */
#else
                        /* with a timeout of 0, the reference
                        implementation seems to get really unhappy
                        really fast when communication starts between
                        all peers at the same time.  Slowing things
                        down a bit seems to help a bunch. */
                        1, /* timeout */
#endif
                        &ev,
                        &which);
        switch (ret) {
        case PTL_OK:
            frag = ev.md.user_ptr;
            num_progressed++;

            switch (ev.type) {
            case PTL_EVENT_GET_START:
                /* generated on source (target) when a get from memory starts */

                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,
                                     "PTL_EVENT_GET_START for 0x%x, %d",
                                     frag, (int) ev.hdr_data));

                break;

            case PTL_EVENT_GET_END:
                /* generated on source (target) when a get from memory ends */

                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,
                                     "PTL_EVENT_GET_END for 0x%x, %d",
                                     frag, (int) ev.hdr_data));

                break;

            case PTL_EVENT_PUT_START:
                /* generated on destination (target) when a put into memory starts */

                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,
                                     "PTL_EVENT_PUT_START for 0x%x, %d",
                                     frag, (int) ev.hdr_data));

#if OMPI_ENABLE_DEBUG
                if (ev.ni_fail_type != PTL_NI_OK) {
                    opal_output(mca_btl_portals_component.portals_output,
                                "Failure to start event\n");
                    return OMPI_ERROR;
                }
#endif
                /* if it's a pending unexpected receive, do book keeping. */
                if (ev.hdr_data < MCA_BTL_TAG_MAX) {
                    block = ev.md.user_ptr;
                    OPAL_THREAD_ADD32(&(block->pending), 1);
                }

                break;

            case PTL_EVENT_PUT_END:
                /* generated on destination (target) when a put into memory ends */

                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,
                                     "PTL_EVENT_PUT_END for 0x%x, %d",
                                     frag, (int) ev.hdr_data));

#if OMPI_ENABLE_DEBUG
                if (ev.ni_fail_type != PTL_NI_OK) {
                    opal_output(mca_btl_portals_component.portals_output,
                                "Failure to end event\n");
                    mca_btl_portals_return_block_part(&mca_btl_portals_module,
                                                      block);
                    return OMPI_ERROR;
                }
#endif
                /* if it's an unexpected receive, do book keeping and send to PML */
                if (ev.hdr_data < MCA_BTL_TAG_MAX) {
                    block = ev.md.user_ptr;
                    tag = ev.hdr_data;

                    OMPI_BTL_PORTALS_FRAG_ALLOC_RECV(&mca_btl_portals_module, frag, ret);
                    frag->segments[0].seg_addr.pval = (((char*) ev.md.start) + ev.offset);
                    frag->segments[0].seg_len = ev.mlength;

                    OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,
                                         "received send fragment %x", frag));

                    if (ev.md.length - (ev.offset + ev.mlength) < ev.md.max_size) {
                        /* the block is full.  It's deactivated automagically, but we
                           can't start it up again until everyone is done with it.
                           The actual reactivation and all that will happen after the
                           free completes the last operation... */
                        OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,
                                             "marking block 0x%x as full", block->start));
                        block->full = true;
                    }

                    assert(NULL != mca_btl_portals_module.portals_reg[tag].cbfunc);

                    mca_btl_portals_module.portals_reg[tag].cbfunc(
                                             &mca_btl_portals_module.super,
                                             tag,
                                             &frag->base,
                                             mca_btl_portals_module.portals_reg[tag].cbdata);
                    OMPI_BTL_PORTALS_FRAG_RETURN_RECV(&mca_btl_portals_module.super,
                                                      frag);
                    mca_btl_portals_return_block_part(&mca_btl_portals_module, block);
                }
                break;

            case PTL_EVENT_REPLY_START:
                /* generated on destination (origin) when a get starts
                   returning data */

                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,
                                     "PTL_EVENT_REPLY_START for 0x%x, %d, %d",
                                     frag, (int) frag->type, (int) ev.hdr_data));

                break;

            case PTL_EVENT_REPLY_END:
                /* generated on destination (origin) when a get is
                   done returning data */

                OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,
                                     "PTL_EVENT_REPLY_END for 0x%x, %d",
                                     frag, (int) frag->type));

                /* let the PML know we're done */
                frag->base.des_cbfunc(&mca_btl_portals_module.super,
                                      frag->endpoint,
                                      &frag->base,
                                      OMPI_SUCCESS);

                break;

            case PTL_EVENT_SEND_START:
                /* generated on source (origin) when put starts sending */

#if OMPI_ENABLE_DEBUG
                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,
                                     "PTL_EVENT_SEND_START for 0x%x, %d, %d",
                                     frag, (int) frag->type, (int) ev.hdr_data));

                if (ev.ni_fail_type != PTL_NI_OK) {
                    opal_output(mca_btl_portals_component.portals_output,
                                "Failure to start send event\n");
                    if (ev.hdr_data < MCA_BTL_TAG_MAX) {
                        OPAL_THREAD_ADD32(&mca_btl_portals_module.portals_outstanding_sends,
                                          -1);
                        /* unlink, since we don't expect to get an end or ack */
                    }
                    PtlMDUnlink(ev.md_handle);
                    frag->base.des_cbfunc(&mca_btl_portals_module.super,
                                          frag->endpoint,
                                          &frag->base,
                                          OMPI_ERROR);
                }
#endif
                break;

            case PTL_EVENT_SEND_END:
                /* generated on source (origin) when put stops sending */
#if OMPI_ENABLE_DEBUG
                OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,
                                     "PTL_EVENT_SEND_END for 0x%x, %d, %d",
                                     frag, (int) frag->type, (int) ev.hdr_data));

                if (ev.ni_fail_type != PTL_NI_OK) {
                    opal_output(mca_btl_portals_component.portals_output,
                                "Failure to end send event\n");
                    if (ev.hdr_data < MCA_BTL_TAG_MAX) {
                        /* unlink, since we don't expect to get an ack */
                        OPAL_THREAD_ADD32(&mca_btl_portals_module.portals_outstanding_sends,
                                          -1);
                        PtlMDUnlink(ev.md_handle);
                    }
                    frag->base.des_cbfunc(&mca_btl_portals_module.super,
                                          frag->endpoint,
                                          &frag->base,
                                          OMPI_ERROR);
                }
#endif
                break;

            case PTL_EVENT_ACK:
                /* ack that a put as completed on other side */

                /* ACK for either send or RDMA put.  Either way, we
                   just call the callback function on goodness.
                   Requeue the put on badness */

                OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,
                                     "PTL_EVENT_ACK for 0x%x, %d",
                                     frag, (int) frag->type));

                if (frag->type == mca_btl_portals_frag_type_send) {
                    OPAL_THREAD_ADD32(&mca_btl_portals_module.portals_outstanding_sends,
                                      -1);
                }

#if OMPI_ENABLE_DEBUG
                if (ev.ni_fail_type != PTL_NI_OK) {
                    opal_output(mca_btl_portals_component.portals_output,
                                "Failure to ack event\n");
                    /* unlink, since we don't expect to get an ack */
                    PtlMDUnlink(ev.md_handle);
                    frag->base.des_cbfunc(&mca_btl_portals_module.super,
                                          frag->endpoint,
                                          &frag->base,
                                          OMPI_ERROR);
                } else
#endif

                if (0 == ev.mlength) {
                    /* other side received message but truncated to 0.
                       This should only happen for unexpected
                       messages, and only when the other side has no
                       buffer space available for receiving */
                    opal_output_verbose(50,
                                        mca_btl_portals_component.portals_output,
                                        "message was dropped.  Adding to front of queue list");
                    opal_list_prepend(&(mca_btl_portals_module.portals_queued_sends),
                                      (opal_list_item_t*) frag);

                } else {
                    /* other side received the message.  should have
                       received entire thing */

                    /* let the PML know we're done */
                    frag->base.des_cbfunc(&mca_btl_portals_module.super,
                                          frag->endpoint,
                                          &frag->base,
                                          OMPI_SUCCESS);
                }

                if (frag->type == mca_btl_portals_frag_type_send) {
                    MCA_BTL_PORTALS_PROGRESS_QUEUED_SENDS();
                }

                break;

            default:
                break;
            }
            break;

        case PTL_EQ_EMPTY:
            /* there's nothing in the queue.  This is actually the
               common case, so the easiest way to make the compiler
               emit something that doesn't completely blow here is to
               just to go back to a good old goto */
            goto done;
            break;

        case PTL_EQ_DROPPED:
            /* not sure how we could deal with this more gracefully */
            opal_output(mca_btl_portals_component.portals_output,
                        "WARNING: EQ events dropped.  Too many messages pending.");
            opal_output(mca_btl_portals_component.portals_output,
                        "WARNING: Giving up in dispair");
            abort();
            break;

        default:
            opal_output(mca_btl_portals_component.portals_output,
                        "WARNING: Error in PtlEQPoll (%d).  This shouldn't happen",
                        ret);
            abort();
            break;
        }
    }

 done:
    return num_progressed;
}
-----children-----
1,2
1,3
1,4
3,4
3,5
5,6
5,7
7,8
9,10
9,11
9,12
9,13
9,14
9,15
9,16
9,17
9,18
10,11
11,12
11,13
13,14
13,15
15,16
17,18
18,19
18,20
18,21
20,21
22,23
24,25
25,26
25,27
26,27
28,29
30,31
31,32
31,33
32,33
34,35
34,36
34,37
37,38
38,39
40,41
41,42
41,43
42,43
44,45
44,46
44,47
47,48
48,49
50,51
51,52
51,53
52,53
54,55
56,57
56,58
57,58
57,59
59,60
59,61
60,61
63,64
64,65
66,67
66,68
68,69
68,70
69,70
70,71
70,72
71,72
73,74
73,75
73,76
73,77
73,78
73,79
74,75
76,77
76,78
77,78
80,81
83,84
84,85
86,87
87,88
89,90
89,91
90,91
92,93
92,94
92,95
92,96
92,97
92,98
92,99
92,100
92,101
92,102
92,103
92,104
92,105
92,106
92,107
92,108
92,109
93,94
94,95
96,97
97,98
97,99
98,99
100,101
100,102
101,102
101,103
102,103
106,107
107,108
108,109
110,111
110,112
111,112
111,113
112,113
115,116
115,117
115,118
115,119
115,120
115,121
115,122
115,123
115,124
115,125
115,126
115,127
115,128
115,129
115,130
115,131
115,132
115,133
115,134
115,135
115,136
115,137
115,138
115,139
115,140
115,141
115,142
115,143
115,144
115,145
115,146
115,147
115,148
116,117
117,118
119,120
120,121
120,122
121,122
123,124
124,125
124,126
124,127
124,128
124,129
126,127
126,128
127,128
131,132
133,134
133,135
134,135
134,136
137,138
137,139
138,139
142,143
143,144
145,146
146,147
146,148
147,148
149,150
150,151
150,152
150,153
150,154
150,155
152,153
152,154
153,154
157,158
159,160
159,161
160,161
160,162
163,164
163,165
164,165
168,169
169,170
171,172
172,173
172,174
173,174
175,176
176,177
176,178
176,179
176,180
176,181
178,179
178,180
179,180
183,184
185,186
185,187
186,187
186,188
189,190
189,191
190,191
193,194
193,195
194,195
194,196
195,196
195,197
196,197
199,200
201,202
201,203
202,203
203,204
203,205
204,205
206,207
206,208
207,208
207,209
208,209
212,213
213,214
213,215
213,216
214,215
216,217
217,218
218,219
218,220
219,220
224,225
225,226
227,228
228,229
228,230
229,230
231,232
232,233
232,234
232,235
232,236
232,237
234,235
234,236
235,236
239,240
241,242
241,243
242,243
242,244
245,246
245,247
246,247
249,250
249,251
250,251
250,252
251,252
251,253
252,253
255,256
257,258
257,259
257,260
257,261
257,262
257,263
257,264
257,265
257,266
257,267
257,268
258,259
259,260
259,261
260,261
262,263
262,264
263,264
263,265
264,265
268,269
269,270
269,271
270,271
272,273
272,274
273,274
276,277
277,278
277,279
277,280
277,281
278,279
280,281
281,282
283,284
285,286
287,288
288,289
288,290
289,290
289,291
290,291
290,292
291,292
291,293
292,293
292,294
293,294
299,300
300,301
300,302
301,302
302,303
302,304
303,304
303,305
305,306
307,308
307,309
308,309
308,310
309,310
313,314
313,315
314,315
317,318
318,319
318,320
319,320
319,321
320,321
320,322
321,322
321,323
322,323
327,328
327,329
328,329
331,332
332,333
332,334
333,334
335,336
336,337
336,338
336,339
336,340
338,339
338,340
339,340
343,344
345,346
345,347
346,347
346,348
347,348
347,349
348,349
348,350
349,350
349,351
350,351
354,355
355,356
355,357
356,357
356,358
357,358
360,361
360,362
361,362
364,365
364,366
365,366
365,367
366,367
370,371
370,372
371,372
372,373
372,374
373,374
375,376
376,377
376,378
376,379
376,380
378,379
378,380
379,380
383,384
383,385
384,385
387,388
388,389
388,390
389,390
389,391
390,391
394,395
395,396
395,397
396,397
398,399
398,400
399,400
401,402
401,403
402,403
402,404
403,404
403,405
404,405
407,408
410,411
411,412
411,413
411,414
411,415
411,416
412,413
412,414
413,414
413,415
414,415
414,416
415,416
418,419
421,422
422,423
422,424
423,424
426,427
428,429
429,430
429,431
430,431
433,434
433,435
434,435
434,436
435,436
435,437
436,437
439,440
442,443
443,444
443,445
443,446
444,445
446,447
447,448
447,449
448,449
451,452
453,454
454,455
454,456
454,457
455,456
457,458
458,459
460,461
463,464
464,465
466,467
467,468
467,469
468,469
470,471
471,472
471,473
471,474
471,475
471,476
471,477
473,474
473,475
474,475
478,479
480,481
480,482
481,482
481,483
484,485
484,486
485,486
488,489
488,490
489,490
489,491
492,493
492,494
493,494
497,498
498,499
500,501
501,502
501,503
502,503
504,505
505,506
505,507
505,508
505,509
505,510
507,508
507,509
508,509
512,513
514,515
514,516
515,516
515,517
518,519
518,520
519,520
522,523
523,524
523,525
523,526
523,527
523,528
524,525
524,526
525,526
525,527
526,527
530,531
531,532
531,533
532,533
535,536
535,537
536,537
539,540
540,541
540,542
541,542
544,545
547,548
548,549
551,552
552,553
555,556
556,557
558,559
559,560
559,561
560,561
562,563
563,564
563,565
563,566
563,567
563,568
565,566
565,567
566,567
570,571
572,573
572,574
573,574
573,575
576,577
576,578
577,578
580,581
580,582
581,582
581,583
582,583
582,584
583,584
586,587
588,589
589,590
590,591
590,592
590,593
591,592
593,594
594,595
594,596
595,596
598,599
600,601
600,602
600,603
601,602
601,603
603,604
603,605
604,605
607,608
607,609
608,609
609,610
609,611
609,612
609,613
610,611
613,614
613,615
614,615
618,619
619,620
619,621
619,622
620,621
622,623
623,624
624,625
624,626
625,626
628,629
628,630
629,630
629,631
630,631
632,633
634,635
636,637
637,638
638,639
638,640
638,641
638,642
638,643
639,640
639,641
640,641
640,642
641,642
645,646
646,647
646,648
647,648
650,651
650,652
651,652
654,655
655,656
655,657
656,657
659,660
661,662
661,663
662,663
662,664
663,664
663,665
664,665
667,668
669,670
670,671
671,672
672,673
678,679
679,680
681,682
684,685
685,686
687,688
688,689
688,690
688,691
689,690
691,692
691,693
692,693
696,697
697,698
697,699
697,700
698,699
700,701
700,702
701,702
705,706
706,707
707,708
711,712
712,713
712,714
712,715
712,716
713,714
715,716
715,717
716,717
720,721
722,723
723,724
724,725
727,728
727,729
729,730
730,731
-----nextToken-----
2,4,6,8,12,14,16,19,21,23,27,29,33,35,36,39,43,45,46,49,53,55,58,61,62,65,67,72,75,78,79,81,82,85,88,91,95,99,103,104,105,109,113,114,118,122,125,128,129,130,132,135,136,139,140,141,144,148,151,154,155,156,158,161,162,165,166,167,170,174,177,180,181,182,184,187,188,191,192,197,198,200,205,209,210,211,215,220,221,222,223,226,230,233,236,237,238,240,243,244,247,248,253,254,256,261,265,266,267,271,274,275,279,282,284,286,294,295,296,297,298,304,306,310,311,312,315,316,323,324,325,326,329,330,334,337,340,341,342,344,351,352,353,358,359,362,363,367,368,369,374,377,380,381,382,385,386,391,392,393,397,400,405,406,408,409,416,417,419,420,424,425,427,431,432,437,438,440,441,445,449,450,452,456,459,461,462,465,469,472,475,476,477,479,482,483,486,487,490,491,494,495,496,499,503,506,509,510,511,513,516,517,520,521,527,528,529,533,534,537,538,542,543,545,546,549,550,553,554,557,561,564,567,568,569,571,574,575,578,579,584,585,587,592,596,597,599,602,605,606,611,612,615,616,617,621,626,627,631,633,635,642,643,644,648,649,652,653,657,658,660,665,666,668,673,674,675,676,677,680,682,683,686,690,693,694,695,699,702,703,704,708,709,710,714,717,718,719,721,725,726,728,731
-----computeFrom-----
57,58
57,59
70,71
70,72
97,98
97,99
194,195
194,196
203,204
203,205
250,251
250,252
259,260
259,261
269,270
269,271
288,289
288,290
300,301
300,302
318,319
318,320
346,347
346,348
347,348
347,349
355,356
355,357
388,389
388,390
398,399
398,400
581,582
581,583
601,602
601,603
662,663
662,664
-----guardedBy-----
197,209
253,367
254,275
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;IfStatement;BinaryExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ReturnStatement;LiteralExpression;WhileStatement;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;SwitchStatement;IdExpression;Name;CompoundStatement;CaseStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;UnaryExpression;IdExpression;Name;SwitchStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;ExpressionList;LiteralExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;FieldReference;IdExpression;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;ExpressionList;LiteralExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;FieldReference;IdExpression;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;ExpressionList;LiteralExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;ExpressionList;LiteralExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;Name;Name;UnaryExpression;BinaryExpression;UnaryExpression;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;ExpressionList;LiteralExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;ExpressionList;LiteralExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;FieldReference;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;ExpressionList;LiteralExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;FieldReference;IdExpression;Name;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;FieldReference;IdExpression;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;ExpressionList;LiteralExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;ExpressionList;LiteralExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;IfStatement;BinaryExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;Pointer;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BreakStatement;DefaultStatement;BreakStatement;BreakStatement;CaseStatement;IdExpression;Name;GotoStatement;Name;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BreakStatement;DefaultStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BreakStatement;LabelStatement;Name;ReturnStatement;IdExpression;Name;
-----ast_node-----
intmca_btl_portals_component_progress(void){    int num_progressed = 0;    int ret, which;    static ptl_event_t ev;    mca_btl_portals_frag_t *frag = NULL;    mca_btl_portals_recv_block_t *block = NULL;    mca_btl_base_tag_t tag;    if (0 == mca_btl_portals_module.portals_num_procs) {        return 0;    }    while (true) {        ret = PtlEQPoll(mca_btl_portals_module.portals_eq_handles,                        OMPI_BTL_PORTALS_EQ_SIZE,#if OMPI_BTL_PORTALS_REDSTORM                        0, /* timeout */#else                        /* with a timeout of 0, the reference                        implementation seems to get really unhappy                        really fast when communication starts between                        all peers at the same time.  Slowing things                        down a bit seems to help a bunch. */                        1, /* timeout */#endif                        &ev,                        &which);        switch (ret) {        case PTL_OK:            frag = ev.md.user_ptr;            num_progressed++;            switch (ev.type) {            case PTL_EVENT_GET_START:                /* generated on source (target) when a get from memory starts */                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_GET_START for 0x%x, %d",                                     frag, (int) ev.hdr_data));                break;            case PTL_EVENT_GET_END:                /* generated on source (target) when a get from memory ends */                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_GET_END for 0x%x, %d",                                     frag, (int) ev.hdr_data));                break;            case PTL_EVENT_PUT_START:                /* generated on destination (target) when a put into memory starts */                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_PUT_START for 0x%x, %d",                                     frag, (int) ev.hdr_data));#if OMPI_ENABLE_DEBUG                if (ev.ni_fail_type != PTL_NI_OK) {                    opal_output(mca_btl_portals_component.portals_output,                                "Failure to start event\n");                    return OMPI_ERROR;                }#endif                /* if it's a pending unexpected receive, do book keeping. */                if (ev.hdr_data < MCA_BTL_TAG_MAX) {                    block = ev.md.user_ptr;                    OPAL_THREAD_ADD32(&(block->pending), 1);                }                break;            case PTL_EVENT_PUT_END:                /* generated on destination (target) when a put into memory ends */                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_PUT_END for 0x%x, %d",                                     frag, (int) ev.hdr_data));#if OMPI_ENABLE_DEBUG                if (ev.ni_fail_type != PTL_NI_OK) {                    opal_output(mca_btl_portals_component.portals_output,                                "Failure to end event\n");                    mca_btl_portals_return_block_part(&mca_btl_portals_module,                                                      block);                    return OMPI_ERROR;                }#endif                /* if it's an unexpected receive, do book keeping and send to PML */                if (ev.hdr_data < MCA_BTL_TAG_MAX) {                    block = ev.md.user_ptr;                    tag = ev.hdr_data;                    OMPI_BTL_PORTALS_FRAG_ALLOC_RECV(&mca_btl_portals_module, frag, ret);                    frag->segments[0].seg_addr.pval = (((char*) ev.md.start) + ev.offset);                    frag->segments[0].seg_len = ev.mlength;                    OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                         "received send fragment %x", frag));                    if (ev.md.length - (ev.offset + ev.mlength) < ev.md.max_size) {                        /* the block is full.  It's deactivated automagically, but we                           can't start it up again until everyone is done with it.                           The actual reactivation and all that will happen after the                           free completes the last operation... */                        OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                             "marking block 0x%x as full", block->start));                        block->full = true;                    }                    assert(NULL != mca_btl_portals_module.portals_reg[tag].cbfunc);                    mca_btl_portals_module.portals_reg[tag].cbfunc(                                             &mca_btl_portals_module.super,                                             tag,                                             &frag->base,                                             mca_btl_portals_module.portals_reg[tag].cbdata);                    OMPI_BTL_PORTALS_FRAG_RETURN_RECV(&mca_btl_portals_module.super,                                                      frag);                    mca_btl_portals_return_block_part(&mca_btl_portals_module, block);                }                break;            case PTL_EVENT_REPLY_START:                /* generated on destination (origin) when a get starts                   returning data */                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_REPLY_START for 0x%x, %d, %d",                                     frag, (int) frag->type, (int) ev.hdr_data));                break;            case PTL_EVENT_REPLY_END:                /* generated on destination (origin) when a get is                   done returning data */                OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_REPLY_END for 0x%x, %d",                                     frag, (int) frag->type));                /* let the PML know we're done */                frag->base.des_cbfunc(&mca_btl_portals_module.super,                                      frag->endpoint,                                      &frag->base,                                      OMPI_SUCCESS);                break;            case PTL_EVENT_SEND_START:                /* generated on source (origin) when put starts sending */#if OMPI_ENABLE_DEBUG                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_SEND_START for 0x%x, %d, %d",                                     frag, (int) frag->type, (int) ev.hdr_data));                if (ev.ni_fail_type != PTL_NI_OK) {                    opal_output(mca_btl_portals_component.portals_output,                                "Failure to start send event\n");                    if (ev.hdr_data < MCA_BTL_TAG_MAX) {                        OPAL_THREAD_ADD32(&mca_btl_portals_module.portals_outstanding_sends,                                          -1);                        /* unlink, since we don't expect to get an end or ack */                    }                    PtlMDUnlink(ev.md_handle);                    frag->base.des_cbfunc(&mca_btl_portals_module.super,                                          frag->endpoint,                                          &frag->base,                                          OMPI_ERROR);                }#endif                break;            case PTL_EVENT_SEND_END:                /* generated on source (origin) when put stops sending */#if OMPI_ENABLE_DEBUG                OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_SEND_END for 0x%x, %d, %d",                                     frag, (int) frag->type, (int) ev.hdr_data));                if (ev.ni_fail_type != PTL_NI_OK) {                    opal_output(mca_btl_portals_component.portals_output,                                "Failure to end send event\n");                    if (ev.hdr_data < MCA_BTL_TAG_MAX) {                        /* unlink, since we don't expect to get an ack */                        OPAL_THREAD_ADD32(&mca_btl_portals_module.portals_outstanding_sends,                                          -1);                        PtlMDUnlink(ev.md_handle);                    }                    frag->base.des_cbfunc(&mca_btl_portals_module.super,                                          frag->endpoint,                                          &frag->base,                                          OMPI_ERROR);                }#endif                break;            case PTL_EVENT_ACK:                /* ack that a put as completed on other side */                /* ACK for either send or RDMA put.  Either way, we                   just call the callback function on goodness.                   Requeue the put on badness */                OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_ACK for 0x%x, %d",                                     frag, (int) frag->type));                if (frag->type == mca_btl_portals_frag_type_send) {                    OPAL_THREAD_ADD32(&mca_btl_portals_module.portals_outstanding_sends,                                      -1);                }#if OMPI_ENABLE_DEBUG                if (ev.ni_fail_type != PTL_NI_OK) {                    opal_output(mca_btl_portals_component.portals_output,                                "Failure to ack event\n");                    /* unlink, since we don't expect to get an ack */                    PtlMDUnlink(ev.md_handle);                    frag->base.des_cbfunc(&mca_btl_portals_module.super,                                          frag->endpoint,                                          &frag->base,                                          OMPI_ERROR);                } else#endif                if (0 == ev.mlength) {                    /* other side received message but truncated to 0.                       This should only happen for unexpected                       messages, and only when the other side has no                       buffer space available for receiving */                    opal_output_verbose(50,                                        mca_btl_portals_component.portals_output,                                        "message was dropped.  Adding to front of queue list");                    opal_list_prepend(&(mca_btl_portals_module.portals_queued_sends),                                      (opal_list_item_t*) frag);                } else {                    /* other side received the message.  should have                       received entire thing */                    /* let the PML know we're done */                    frag->base.des_cbfunc(&mca_btl_portals_module.super,                                          frag->endpoint,                                          &frag->base,                                          OMPI_SUCCESS);                }                if (frag->type == mca_btl_portals_frag_type_send) {                    MCA_BTL_PORTALS_PROGRESS_QUEUED_SENDS();                }                break;            default:                break;            }            break;        case PTL_EQ_EMPTY:            /* there's nothing in the queue.  This is actually the               common case, so the easiest way to make the compiler               emit something that doesn't completely blow here is to               just to go back to a good old goto */            goto done;            break;        case PTL_EQ_DROPPED:            /* not sure how we could deal with this more gracefully */            opal_output(mca_btl_portals_component.portals_output,                        "WARNING: EQ events dropped.  Too many messages pending.");            opal_output(mca_btl_portals_component.portals_output,                        "WARNING: Giving up in dispair");            abort();            break;        default:            opal_output(mca_btl_portals_component.portals_output,                        "WARNING: Error in PtlEQPoll (%d).  This shouldn't happen",                        ret);            abort();            break;        }    } done:    return num_progressed;}
int
mca_btl_portals_component_progress(void)
mca_btl_portals_component_progress
void
void


{    int num_progressed = 0;    int ret, which;    static ptl_event_t ev;    mca_btl_portals_frag_t *frag = NULL;    mca_btl_portals_recv_block_t *block = NULL;    mca_btl_base_tag_t tag;    if (0 == mca_btl_portals_module.portals_num_procs) {        return 0;    }    while (true) {        ret = PtlEQPoll(mca_btl_portals_module.portals_eq_handles,                        OMPI_BTL_PORTALS_EQ_SIZE,#if OMPI_BTL_PORTALS_REDSTORM                        0, /* timeout */#else                        /* with a timeout of 0, the reference                        implementation seems to get really unhappy                        really fast when communication starts between                        all peers at the same time.  Slowing things                        down a bit seems to help a bunch. */                        1, /* timeout */#endif                        &ev,                        &which);        switch (ret) {        case PTL_OK:            frag = ev.md.user_ptr;            num_progressed++;            switch (ev.type) {            case PTL_EVENT_GET_START:                /* generated on source (target) when a get from memory starts */                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_GET_START for 0x%x, %d",                                     frag, (int) ev.hdr_data));                break;            case PTL_EVENT_GET_END:                /* generated on source (target) when a get from memory ends */                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_GET_END for 0x%x, %d",                                     frag, (int) ev.hdr_data));                break;            case PTL_EVENT_PUT_START:                /* generated on destination (target) when a put into memory starts */                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_PUT_START for 0x%x, %d",                                     frag, (int) ev.hdr_data));#if OMPI_ENABLE_DEBUG                if (ev.ni_fail_type != PTL_NI_OK) {                    opal_output(mca_btl_portals_component.portals_output,                                "Failure to start event\n");                    return OMPI_ERROR;                }#endif                /* if it's a pending unexpected receive, do book keeping. */                if (ev.hdr_data < MCA_BTL_TAG_MAX) {                    block = ev.md.user_ptr;                    OPAL_THREAD_ADD32(&(block->pending), 1);                }                break;            case PTL_EVENT_PUT_END:                /* generated on destination (target) when a put into memory ends */                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_PUT_END for 0x%x, %d",                                     frag, (int) ev.hdr_data));#if OMPI_ENABLE_DEBUG                if (ev.ni_fail_type != PTL_NI_OK) {                    opal_output(mca_btl_portals_component.portals_output,                                "Failure to end event\n");                    mca_btl_portals_return_block_part(&mca_btl_portals_module,                                                      block);                    return OMPI_ERROR;                }#endif                /* if it's an unexpected receive, do book keeping and send to PML */                if (ev.hdr_data < MCA_BTL_TAG_MAX) {                    block = ev.md.user_ptr;                    tag = ev.hdr_data;                    OMPI_BTL_PORTALS_FRAG_ALLOC_RECV(&mca_btl_portals_module, frag, ret);                    frag->segments[0].seg_addr.pval = (((char*) ev.md.start) + ev.offset);                    frag->segments[0].seg_len = ev.mlength;                    OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                         "received send fragment %x", frag));                    if (ev.md.length - (ev.offset + ev.mlength) < ev.md.max_size) {                        /* the block is full.  It's deactivated automagically, but we                           can't start it up again until everyone is done with it.                           The actual reactivation and all that will happen after the                           free completes the last operation... */                        OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                             "marking block 0x%x as full", block->start));                        block->full = true;                    }                    assert(NULL != mca_btl_portals_module.portals_reg[tag].cbfunc);                    mca_btl_portals_module.portals_reg[tag].cbfunc(                                             &mca_btl_portals_module.super,                                             tag,                                             &frag->base,                                             mca_btl_portals_module.portals_reg[tag].cbdata);                    OMPI_BTL_PORTALS_FRAG_RETURN_RECV(&mca_btl_portals_module.super,                                                      frag);                    mca_btl_portals_return_block_part(&mca_btl_portals_module, block);                }                break;            case PTL_EVENT_REPLY_START:                /* generated on destination (origin) when a get starts                   returning data */                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_REPLY_START for 0x%x, %d, %d",                                     frag, (int) frag->type, (int) ev.hdr_data));                break;            case PTL_EVENT_REPLY_END:                /* generated on destination (origin) when a get is                   done returning data */                OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_REPLY_END for 0x%x, %d",                                     frag, (int) frag->type));                /* let the PML know we're done */                frag->base.des_cbfunc(&mca_btl_portals_module.super,                                      frag->endpoint,                                      &frag->base,                                      OMPI_SUCCESS);                break;            case PTL_EVENT_SEND_START:                /* generated on source (origin) when put starts sending */#if OMPI_ENABLE_DEBUG                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_SEND_START for 0x%x, %d, %d",                                     frag, (int) frag->type, (int) ev.hdr_data));                if (ev.ni_fail_type != PTL_NI_OK) {                    opal_output(mca_btl_portals_component.portals_output,                                "Failure to start send event\n");                    if (ev.hdr_data < MCA_BTL_TAG_MAX) {                        OPAL_THREAD_ADD32(&mca_btl_portals_module.portals_outstanding_sends,                                          -1);                        /* unlink, since we don't expect to get an end or ack */                    }                    PtlMDUnlink(ev.md_handle);                    frag->base.des_cbfunc(&mca_btl_portals_module.super,                                          frag->endpoint,                                          &frag->base,                                          OMPI_ERROR);                }#endif                break;            case PTL_EVENT_SEND_END:                /* generated on source (origin) when put stops sending */#if OMPI_ENABLE_DEBUG                OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_SEND_END for 0x%x, %d, %d",                                     frag, (int) frag->type, (int) ev.hdr_data));                if (ev.ni_fail_type != PTL_NI_OK) {                    opal_output(mca_btl_portals_component.portals_output,                                "Failure to end send event\n");                    if (ev.hdr_data < MCA_BTL_TAG_MAX) {                        /* unlink, since we don't expect to get an ack */                        OPAL_THREAD_ADD32(&mca_btl_portals_module.portals_outstanding_sends,                                          -1);                        PtlMDUnlink(ev.md_handle);                    }                    frag->base.des_cbfunc(&mca_btl_portals_module.super,                                          frag->endpoint,                                          &frag->base,                                          OMPI_ERROR);                }#endif                break;            case PTL_EVENT_ACK:                /* ack that a put as completed on other side */                /* ACK for either send or RDMA put.  Either way, we                   just call the callback function on goodness.                   Requeue the put on badness */                OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_ACK for 0x%x, %d",                                     frag, (int) frag->type));                if (frag->type == mca_btl_portals_frag_type_send) {                    OPAL_THREAD_ADD32(&mca_btl_portals_module.portals_outstanding_sends,                                      -1);                }#if OMPI_ENABLE_DEBUG                if (ev.ni_fail_type != PTL_NI_OK) {                    opal_output(mca_btl_portals_component.portals_output,                                "Failure to ack event\n");                    /* unlink, since we don't expect to get an ack */                    PtlMDUnlink(ev.md_handle);                    frag->base.des_cbfunc(&mca_btl_portals_module.super,                                          frag->endpoint,                                          &frag->base,                                          OMPI_ERROR);                } else#endif                if (0 == ev.mlength) {                    /* other side received message but truncated to 0.                       This should only happen for unexpected                       messages, and only when the other side has no                       buffer space available for receiving */                    opal_output_verbose(50,                                        mca_btl_portals_component.portals_output,                                        "message was dropped.  Adding to front of queue list");                    opal_list_prepend(&(mca_btl_portals_module.portals_queued_sends),                                      (opal_list_item_t*) frag);                } else {                    /* other side received the message.  should have                       received entire thing */                    /* let the PML know we're done */                    frag->base.des_cbfunc(&mca_btl_portals_module.super,                                          frag->endpoint,                                          &frag->base,                                          OMPI_SUCCESS);                }                if (frag->type == mca_btl_portals_frag_type_send) {                    MCA_BTL_PORTALS_PROGRESS_QUEUED_SENDS();                }                break;            default:                break;            }            break;        case PTL_EQ_EMPTY:            /* there's nothing in the queue.  This is actually the               common case, so the easiest way to make the compiler               emit something that doesn't completely blow here is to               just to go back to a good old goto */            goto done;            break;        case PTL_EQ_DROPPED:            /* not sure how we could deal with this more gracefully */            opal_output(mca_btl_portals_component.portals_output,                        "WARNING: EQ events dropped.  Too many messages pending.");            opal_output(mca_btl_portals_component.portals_output,                        "WARNING: Giving up in dispair");            abort();            break;        default:            opal_output(mca_btl_portals_component.portals_output,                        "WARNING: Error in PtlEQPoll (%d).  This shouldn't happen",                        ret);            abort();            break;        }    } done:    return num_progressed;}
int num_progressed = 0;
int num_progressed = 0;
int
num_progressed = 0
num_progressed
= 0
0
int ret, which;
int ret, which;
int
ret
ret
which
which
static ptl_event_t ev;
static ptl_event_t ev;
static ptl_event_t
ptl_event_t
ev
ev
mca_btl_portals_frag_t *frag = NULL;
mca_btl_portals_frag_t *frag = NULL;
mca_btl_portals_frag_t
mca_btl_portals_frag_t
*frag = NULL
*
frag
= NULL
NULL
NULL
mca_btl_portals_recv_block_t *block = NULL;
mca_btl_portals_recv_block_t *block = NULL;
mca_btl_portals_recv_block_t
mca_btl_portals_recv_block_t
*block = NULL
*
block
= NULL
NULL
NULL
mca_btl_base_tag_t tag;
mca_btl_base_tag_t tag;
mca_btl_base_tag_t
mca_btl_base_tag_t
tag
tag
if (0 == mca_btl_portals_module.portals_num_procs) {        return 0;    }
0 == mca_btl_portals_module.portals_num_procs
0
mca_btl_portals_module.portals_num_procs
mca_btl_portals_module
mca_btl_portals_module
portals_num_procs
{        return 0;    }
return 0;
0
while (true) {        ret = PtlEQPoll(mca_btl_portals_module.portals_eq_handles,                        OMPI_BTL_PORTALS_EQ_SIZE,#if OMPI_BTL_PORTALS_REDSTORM                        0, /* timeout */#else                        /* with a timeout of 0, the reference                        implementation seems to get really unhappy                        really fast when communication starts between                        all peers at the same time.  Slowing things                        down a bit seems to help a bunch. */                        1, /* timeout */#endif                        &ev,                        &which);        switch (ret) {        case PTL_OK:            frag = ev.md.user_ptr;            num_progressed++;            switch (ev.type) {            case PTL_EVENT_GET_START:                /* generated on source (target) when a get from memory starts */                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_GET_START for 0x%x, %d",                                     frag, (int) ev.hdr_data));                break;            case PTL_EVENT_GET_END:                /* generated on source (target) when a get from memory ends */                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_GET_END for 0x%x, %d",                                     frag, (int) ev.hdr_data));                break;            case PTL_EVENT_PUT_START:                /* generated on destination (target) when a put into memory starts */                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_PUT_START for 0x%x, %d",                                     frag, (int) ev.hdr_data));#if OMPI_ENABLE_DEBUG                if (ev.ni_fail_type != PTL_NI_OK) {                    opal_output(mca_btl_portals_component.portals_output,                                "Failure to start event\n");                    return OMPI_ERROR;                }#endif                /* if it's a pending unexpected receive, do book keeping. */                if (ev.hdr_data < MCA_BTL_TAG_MAX) {                    block = ev.md.user_ptr;                    OPAL_THREAD_ADD32(&(block->pending), 1);                }                break;            case PTL_EVENT_PUT_END:                /* generated on destination (target) when a put into memory ends */                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_PUT_END for 0x%x, %d",                                     frag, (int) ev.hdr_data));#if OMPI_ENABLE_DEBUG                if (ev.ni_fail_type != PTL_NI_OK) {                    opal_output(mca_btl_portals_component.portals_output,                                "Failure to end event\n");                    mca_btl_portals_return_block_part(&mca_btl_portals_module,                                                      block);                    return OMPI_ERROR;                }#endif                /* if it's an unexpected receive, do book keeping and send to PML */                if (ev.hdr_data < MCA_BTL_TAG_MAX) {                    block = ev.md.user_ptr;                    tag = ev.hdr_data;                    OMPI_BTL_PORTALS_FRAG_ALLOC_RECV(&mca_btl_portals_module, frag, ret);                    frag->segments[0].seg_addr.pval = (((char*) ev.md.start) + ev.offset);                    frag->segments[0].seg_len = ev.mlength;                    OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                         "received send fragment %x", frag));                    if (ev.md.length - (ev.offset + ev.mlength) < ev.md.max_size) {                        /* the block is full.  It's deactivated automagically, but we                           can't start it up again until everyone is done with it.                           The actual reactivation and all that will happen after the                           free completes the last operation... */                        OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                             "marking block 0x%x as full", block->start));                        block->full = true;                    }                    assert(NULL != mca_btl_portals_module.portals_reg[tag].cbfunc);                    mca_btl_portals_module.portals_reg[tag].cbfunc(                                             &mca_btl_portals_module.super,                                             tag,                                             &frag->base,                                             mca_btl_portals_module.portals_reg[tag].cbdata);                    OMPI_BTL_PORTALS_FRAG_RETURN_RECV(&mca_btl_portals_module.super,                                                      frag);                    mca_btl_portals_return_block_part(&mca_btl_portals_module, block);                }                break;            case PTL_EVENT_REPLY_START:                /* generated on destination (origin) when a get starts                   returning data */                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_REPLY_START for 0x%x, %d, %d",                                     frag, (int) frag->type, (int) ev.hdr_data));                break;            case PTL_EVENT_REPLY_END:                /* generated on destination (origin) when a get is                   done returning data */                OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_REPLY_END for 0x%x, %d",                                     frag, (int) frag->type));                /* let the PML know we're done */                frag->base.des_cbfunc(&mca_btl_portals_module.super,                                      frag->endpoint,                                      &frag->base,                                      OMPI_SUCCESS);                break;            case PTL_EVENT_SEND_START:                /* generated on source (origin) when put starts sending */#if OMPI_ENABLE_DEBUG                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_SEND_START for 0x%x, %d, %d",                                     frag, (int) frag->type, (int) ev.hdr_data));                if (ev.ni_fail_type != PTL_NI_OK) {                    opal_output(mca_btl_portals_component.portals_output,                                "Failure to start send event\n");                    if (ev.hdr_data < MCA_BTL_TAG_MAX) {                        OPAL_THREAD_ADD32(&mca_btl_portals_module.portals_outstanding_sends,                                          -1);                        /* unlink, since we don't expect to get an end or ack */                    }                    PtlMDUnlink(ev.md_handle);                    frag->base.des_cbfunc(&mca_btl_portals_module.super,                                          frag->endpoint,                                          &frag->base,                                          OMPI_ERROR);                }#endif                break;            case PTL_EVENT_SEND_END:                /* generated on source (origin) when put stops sending */#if OMPI_ENABLE_DEBUG                OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_SEND_END for 0x%x, %d, %d",                                     frag, (int) frag->type, (int) ev.hdr_data));                if (ev.ni_fail_type != PTL_NI_OK) {                    opal_output(mca_btl_portals_component.portals_output,                                "Failure to end send event\n");                    if (ev.hdr_data < MCA_BTL_TAG_MAX) {                        /* unlink, since we don't expect to get an ack */                        OPAL_THREAD_ADD32(&mca_btl_portals_module.portals_outstanding_sends,                                          -1);                        PtlMDUnlink(ev.md_handle);                    }                    frag->base.des_cbfunc(&mca_btl_portals_module.super,                                          frag->endpoint,                                          &frag->base,                                          OMPI_ERROR);                }#endif                break;            case PTL_EVENT_ACK:                /* ack that a put as completed on other side */                /* ACK for either send or RDMA put.  Either way, we                   just call the callback function on goodness.                   Requeue the put on badness */                OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_ACK for 0x%x, %d",                                     frag, (int) frag->type));                if (frag->type == mca_btl_portals_frag_type_send) {                    OPAL_THREAD_ADD32(&mca_btl_portals_module.portals_outstanding_sends,                                      -1);                }#if OMPI_ENABLE_DEBUG                if (ev.ni_fail_type != PTL_NI_OK) {                    opal_output(mca_btl_portals_component.portals_output,                                "Failure to ack event\n");                    /* unlink, since we don't expect to get an ack */                    PtlMDUnlink(ev.md_handle);                    frag->base.des_cbfunc(&mca_btl_portals_module.super,                                          frag->endpoint,                                          &frag->base,                                          OMPI_ERROR);                } else#endif                if (0 == ev.mlength) {                    /* other side received message but truncated to 0.                       This should only happen for unexpected                       messages, and only when the other side has no                       buffer space available for receiving */                    opal_output_verbose(50,                                        mca_btl_portals_component.portals_output,                                        "message was dropped.  Adding to front of queue list");                    opal_list_prepend(&(mca_btl_portals_module.portals_queued_sends),                                      (opal_list_item_t*) frag);                } else {                    /* other side received the message.  should have                       received entire thing */                    /* let the PML know we're done */                    frag->base.des_cbfunc(&mca_btl_portals_module.super,                                          frag->endpoint,                                          &frag->base,                                          OMPI_SUCCESS);                }                if (frag->type == mca_btl_portals_frag_type_send) {                    MCA_BTL_PORTALS_PROGRESS_QUEUED_SENDS();                }                break;            default:                break;            }            break;        case PTL_EQ_EMPTY:            /* there's nothing in the queue.  This is actually the               common case, so the easiest way to make the compiler               emit something that doesn't completely blow here is to               just to go back to a good old goto */            goto done;            break;        case PTL_EQ_DROPPED:            /* not sure how we could deal with this more gracefully */            opal_output(mca_btl_portals_component.portals_output,                        "WARNING: EQ events dropped.  Too many messages pending.");            opal_output(mca_btl_portals_component.portals_output,                        "WARNING: Giving up in dispair");            abort();            break;        default:            opal_output(mca_btl_portals_component.portals_output,                        "WARNING: Error in PtlEQPoll (%d).  This shouldn't happen",                        ret);            abort();            break;        }    }
true
{        ret = PtlEQPoll(mca_btl_portals_module.portals_eq_handles,                        OMPI_BTL_PORTALS_EQ_SIZE,#if OMPI_BTL_PORTALS_REDSTORM                        0, /* timeout */#else                        /* with a timeout of 0, the reference                        implementation seems to get really unhappy                        really fast when communication starts between                        all peers at the same time.  Slowing things                        down a bit seems to help a bunch. */                        1, /* timeout */#endif                        &ev,                        &which);        switch (ret) {        case PTL_OK:            frag = ev.md.user_ptr;            num_progressed++;            switch (ev.type) {            case PTL_EVENT_GET_START:                /* generated on source (target) when a get from memory starts */                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_GET_START for 0x%x, %d",                                     frag, (int) ev.hdr_data));                break;            case PTL_EVENT_GET_END:                /* generated on source (target) when a get from memory ends */                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_GET_END for 0x%x, %d",                                     frag, (int) ev.hdr_data));                break;            case PTL_EVENT_PUT_START:                /* generated on destination (target) when a put into memory starts */                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_PUT_START for 0x%x, %d",                                     frag, (int) ev.hdr_data));#if OMPI_ENABLE_DEBUG                if (ev.ni_fail_type != PTL_NI_OK) {                    opal_output(mca_btl_portals_component.portals_output,                                "Failure to start event\n");                    return OMPI_ERROR;                }#endif                /* if it's a pending unexpected receive, do book keeping. */                if (ev.hdr_data < MCA_BTL_TAG_MAX) {                    block = ev.md.user_ptr;                    OPAL_THREAD_ADD32(&(block->pending), 1);                }                break;            case PTL_EVENT_PUT_END:                /* generated on destination (target) when a put into memory ends */                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_PUT_END for 0x%x, %d",                                     frag, (int) ev.hdr_data));#if OMPI_ENABLE_DEBUG                if (ev.ni_fail_type != PTL_NI_OK) {                    opal_output(mca_btl_portals_component.portals_output,                                "Failure to end event\n");                    mca_btl_portals_return_block_part(&mca_btl_portals_module,                                                      block);                    return OMPI_ERROR;                }#endif                /* if it's an unexpected receive, do book keeping and send to PML */                if (ev.hdr_data < MCA_BTL_TAG_MAX) {                    block = ev.md.user_ptr;                    tag = ev.hdr_data;                    OMPI_BTL_PORTALS_FRAG_ALLOC_RECV(&mca_btl_portals_module, frag, ret);                    frag->segments[0].seg_addr.pval = (((char*) ev.md.start) + ev.offset);                    frag->segments[0].seg_len = ev.mlength;                    OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                         "received send fragment %x", frag));                    if (ev.md.length - (ev.offset + ev.mlength) < ev.md.max_size) {                        /* the block is full.  It's deactivated automagically, but we                           can't start it up again until everyone is done with it.                           The actual reactivation and all that will happen after the                           free completes the last operation... */                        OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                             "marking block 0x%x as full", block->start));                        block->full = true;                    }                    assert(NULL != mca_btl_portals_module.portals_reg[tag].cbfunc);                    mca_btl_portals_module.portals_reg[tag].cbfunc(                                             &mca_btl_portals_module.super,                                             tag,                                             &frag->base,                                             mca_btl_portals_module.portals_reg[tag].cbdata);                    OMPI_BTL_PORTALS_FRAG_RETURN_RECV(&mca_btl_portals_module.super,                                                      frag);                    mca_btl_portals_return_block_part(&mca_btl_portals_module, block);                }                break;            case PTL_EVENT_REPLY_START:                /* generated on destination (origin) when a get starts                   returning data */                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_REPLY_START for 0x%x, %d, %d",                                     frag, (int) frag->type, (int) ev.hdr_data));                break;            case PTL_EVENT_REPLY_END:                /* generated on destination (origin) when a get is                   done returning data */                OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_REPLY_END for 0x%x, %d",                                     frag, (int) frag->type));                /* let the PML know we're done */                frag->base.des_cbfunc(&mca_btl_portals_module.super,                                      frag->endpoint,                                      &frag->base,                                      OMPI_SUCCESS);                break;            case PTL_EVENT_SEND_START:                /* generated on source (origin) when put starts sending */#if OMPI_ENABLE_DEBUG                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_SEND_START for 0x%x, %d, %d",                                     frag, (int) frag->type, (int) ev.hdr_data));                if (ev.ni_fail_type != PTL_NI_OK) {                    opal_output(mca_btl_portals_component.portals_output,                                "Failure to start send event\n");                    if (ev.hdr_data < MCA_BTL_TAG_MAX) {                        OPAL_THREAD_ADD32(&mca_btl_portals_module.portals_outstanding_sends,                                          -1);                        /* unlink, since we don't expect to get an end or ack */                    }                    PtlMDUnlink(ev.md_handle);                    frag->base.des_cbfunc(&mca_btl_portals_module.super,                                          frag->endpoint,                                          &frag->base,                                          OMPI_ERROR);                }#endif                break;            case PTL_EVENT_SEND_END:                /* generated on source (origin) when put stops sending */#if OMPI_ENABLE_DEBUG                OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_SEND_END for 0x%x, %d, %d",                                     frag, (int) frag->type, (int) ev.hdr_data));                if (ev.ni_fail_type != PTL_NI_OK) {                    opal_output(mca_btl_portals_component.portals_output,                                "Failure to end send event\n");                    if (ev.hdr_data < MCA_BTL_TAG_MAX) {                        /* unlink, since we don't expect to get an ack */                        OPAL_THREAD_ADD32(&mca_btl_portals_module.portals_outstanding_sends,                                          -1);                        PtlMDUnlink(ev.md_handle);                    }                    frag->base.des_cbfunc(&mca_btl_portals_module.super,                                          frag->endpoint,                                          &frag->base,                                          OMPI_ERROR);                }#endif                break;            case PTL_EVENT_ACK:                /* ack that a put as completed on other side */                /* ACK for either send or RDMA put.  Either way, we                   just call the callback function on goodness.                   Requeue the put on badness */                OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_ACK for 0x%x, %d",                                     frag, (int) frag->type));                if (frag->type == mca_btl_portals_frag_type_send) {                    OPAL_THREAD_ADD32(&mca_btl_portals_module.portals_outstanding_sends,                                      -1);                }#if OMPI_ENABLE_DEBUG                if (ev.ni_fail_type != PTL_NI_OK) {                    opal_output(mca_btl_portals_component.portals_output,                                "Failure to ack event\n");                    /* unlink, since we don't expect to get an ack */                    PtlMDUnlink(ev.md_handle);                    frag->base.des_cbfunc(&mca_btl_portals_module.super,                                          frag->endpoint,                                          &frag->base,                                          OMPI_ERROR);                } else#endif                if (0 == ev.mlength) {                    /* other side received message but truncated to 0.                       This should only happen for unexpected                       messages, and only when the other side has no                       buffer space available for receiving */                    opal_output_verbose(50,                                        mca_btl_portals_component.portals_output,                                        "message was dropped.  Adding to front of queue list");                    opal_list_prepend(&(mca_btl_portals_module.portals_queued_sends),                                      (opal_list_item_t*) frag);                } else {                    /* other side received the message.  should have                       received entire thing */                    /* let the PML know we're done */                    frag->base.des_cbfunc(&mca_btl_portals_module.super,                                          frag->endpoint,                                          &frag->base,                                          OMPI_SUCCESS);                }                if (frag->type == mca_btl_portals_frag_type_send) {                    MCA_BTL_PORTALS_PROGRESS_QUEUED_SENDS();                }                break;            default:                break;            }            break;        case PTL_EQ_EMPTY:            /* there's nothing in the queue.  This is actually the               common case, so the easiest way to make the compiler               emit something that doesn't completely blow here is to               just to go back to a good old goto */            goto done;            break;        case PTL_EQ_DROPPED:            /* not sure how we could deal with this more gracefully */            opal_output(mca_btl_portals_component.portals_output,                        "WARNING: EQ events dropped.  Too many messages pending.");            opal_output(mca_btl_portals_component.portals_output,                        "WARNING: Giving up in dispair");            abort();            break;        default:            opal_output(mca_btl_portals_component.portals_output,                        "WARNING: Error in PtlEQPoll (%d).  This shouldn't happen",                        ret);            abort();            break;        }    }
ret = PtlEQPoll(mca_btl_portals_module.portals_eq_handles,                        OMPI_BTL_PORTALS_EQ_SIZE,#if OMPI_BTL_PORTALS_REDSTORM                        0, /* timeout */#else                        /* with a timeout of 0, the reference                        implementation seems to get really unhappy                        really fast when communication starts between                        all peers at the same time.  Slowing things                        down a bit seems to help a bunch. */                        1, /* timeout */#endif                        &ev,                        &which);
ret = PtlEQPoll(mca_btl_portals_module.portals_eq_handles,                        OMPI_BTL_PORTALS_EQ_SIZE,#if OMPI_BTL_PORTALS_REDSTORM                        0, /* timeout */#else                        /* with a timeout of 0, the reference                        implementation seems to get really unhappy                        really fast when communication starts between                        all peers at the same time.  Slowing things                        down a bit seems to help a bunch. */                        1, /* timeout */#endif                        &ev,                        &which)
ret
ret
PtlEQPoll(mca_btl_portals_module.portals_eq_handles,                        OMPI_BTL_PORTALS_EQ_SIZE,#if OMPI_BTL_PORTALS_REDSTORM                        0, /* timeout */#else                        /* with a timeout of 0, the reference                        implementation seems to get really unhappy                        really fast when communication starts between                        all peers at the same time.  Slowing things                        down a bit seems to help a bunch. */                        1, /* timeout */#endif                        &ev,                        &which)
PtlEQPoll
PtlEQPoll
mca_btl_portals_module.portals_eq_handles
mca_btl_portals_module
mca_btl_portals_module
portals_eq_handles
OMPI_BTL_PORTALS_EQ_SIZE
OMPI_BTL_PORTALS_EQ_SIZE
1
&ev
ev
ev
&which
which
which
switch (ret) {        case PTL_OK:            frag = ev.md.user_ptr;            num_progressed++;            switch (ev.type) {            case PTL_EVENT_GET_START:                /* generated on source (target) when a get from memory starts */                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_GET_START for 0x%x, %d",                                     frag, (int) ev.hdr_data));                break;            case PTL_EVENT_GET_END:                /* generated on source (target) when a get from memory ends */                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_GET_END for 0x%x, %d",                                     frag, (int) ev.hdr_data));                break;            case PTL_EVENT_PUT_START:                /* generated on destination (target) when a put into memory starts */                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_PUT_START for 0x%x, %d",                                     frag, (int) ev.hdr_data));#if OMPI_ENABLE_DEBUG                if (ev.ni_fail_type != PTL_NI_OK) {                    opal_output(mca_btl_portals_component.portals_output,                                "Failure to start event\n");                    return OMPI_ERROR;                }#endif                /* if it's a pending unexpected receive, do book keeping. */                if (ev.hdr_data < MCA_BTL_TAG_MAX) {                    block = ev.md.user_ptr;                    OPAL_THREAD_ADD32(&(block->pending), 1);                }                break;            case PTL_EVENT_PUT_END:                /* generated on destination (target) when a put into memory ends */                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_PUT_END for 0x%x, %d",                                     frag, (int) ev.hdr_data));#if OMPI_ENABLE_DEBUG                if (ev.ni_fail_type != PTL_NI_OK) {                    opal_output(mca_btl_portals_component.portals_output,                                "Failure to end event\n");                    mca_btl_portals_return_block_part(&mca_btl_portals_module,                                                      block);                    return OMPI_ERROR;                }#endif                /* if it's an unexpected receive, do book keeping and send to PML */                if (ev.hdr_data < MCA_BTL_TAG_MAX) {                    block = ev.md.user_ptr;                    tag = ev.hdr_data;                    OMPI_BTL_PORTALS_FRAG_ALLOC_RECV(&mca_btl_portals_module, frag, ret);                    frag->segments[0].seg_addr.pval = (((char*) ev.md.start) + ev.offset);                    frag->segments[0].seg_len = ev.mlength;                    OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                         "received send fragment %x", frag));                    if (ev.md.length - (ev.offset + ev.mlength) < ev.md.max_size) {                        /* the block is full.  It's deactivated automagically, but we                           can't start it up again until everyone is done with it.                           The actual reactivation and all that will happen after the                           free completes the last operation... */                        OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                             "marking block 0x%x as full", block->start));                        block->full = true;                    }                    assert(NULL != mca_btl_portals_module.portals_reg[tag].cbfunc);                    mca_btl_portals_module.portals_reg[tag].cbfunc(                                             &mca_btl_portals_module.super,                                             tag,                                             &frag->base,                                             mca_btl_portals_module.portals_reg[tag].cbdata);                    OMPI_BTL_PORTALS_FRAG_RETURN_RECV(&mca_btl_portals_module.super,                                                      frag);                    mca_btl_portals_return_block_part(&mca_btl_portals_module, block);                }                break;            case PTL_EVENT_REPLY_START:                /* generated on destination (origin) when a get starts                   returning data */                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_REPLY_START for 0x%x, %d, %d",                                     frag, (int) frag->type, (int) ev.hdr_data));                break;            case PTL_EVENT_REPLY_END:                /* generated on destination (origin) when a get is                   done returning data */                OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_REPLY_END for 0x%x, %d",                                     frag, (int) frag->type));                /* let the PML know we're done */                frag->base.des_cbfunc(&mca_btl_portals_module.super,                                      frag->endpoint,                                      &frag->base,                                      OMPI_SUCCESS);                break;            case PTL_EVENT_SEND_START:                /* generated on source (origin) when put starts sending */#if OMPI_ENABLE_DEBUG                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_SEND_START for 0x%x, %d, %d",                                     frag, (int) frag->type, (int) ev.hdr_data));                if (ev.ni_fail_type != PTL_NI_OK) {                    opal_output(mca_btl_portals_component.portals_output,                                "Failure to start send event\n");                    if (ev.hdr_data < MCA_BTL_TAG_MAX) {                        OPAL_THREAD_ADD32(&mca_btl_portals_module.portals_outstanding_sends,                                          -1);                        /* unlink, since we don't expect to get an end or ack */                    }                    PtlMDUnlink(ev.md_handle);                    frag->base.des_cbfunc(&mca_btl_portals_module.super,                                          frag->endpoint,                                          &frag->base,                                          OMPI_ERROR);                }#endif                break;            case PTL_EVENT_SEND_END:                /* generated on source (origin) when put stops sending */#if OMPI_ENABLE_DEBUG                OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_SEND_END for 0x%x, %d, %d",                                     frag, (int) frag->type, (int) ev.hdr_data));                if (ev.ni_fail_type != PTL_NI_OK) {                    opal_output(mca_btl_portals_component.portals_output,                                "Failure to end send event\n");                    if (ev.hdr_data < MCA_BTL_TAG_MAX) {                        /* unlink, since we don't expect to get an ack */                        OPAL_THREAD_ADD32(&mca_btl_portals_module.portals_outstanding_sends,                                          -1);                        PtlMDUnlink(ev.md_handle);                    }                    frag->base.des_cbfunc(&mca_btl_portals_module.super,                                          frag->endpoint,                                          &frag->base,                                          OMPI_ERROR);                }#endif                break;            case PTL_EVENT_ACK:                /* ack that a put as completed on other side */                /* ACK for either send or RDMA put.  Either way, we                   just call the callback function on goodness.                   Requeue the put on badness */                OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_ACK for 0x%x, %d",                                     frag, (int) frag->type));                if (frag->type == mca_btl_portals_frag_type_send) {                    OPAL_THREAD_ADD32(&mca_btl_portals_module.portals_outstanding_sends,                                      -1);                }#if OMPI_ENABLE_DEBUG                if (ev.ni_fail_type != PTL_NI_OK) {                    opal_output(mca_btl_portals_component.portals_output,                                "Failure to ack event\n");                    /* unlink, since we don't expect to get an ack */                    PtlMDUnlink(ev.md_handle);                    frag->base.des_cbfunc(&mca_btl_portals_module.super,                                          frag->endpoint,                                          &frag->base,                                          OMPI_ERROR);                } else#endif                if (0 == ev.mlength) {                    /* other side received message but truncated to 0.                       This should only happen for unexpected                       messages, and only when the other side has no                       buffer space available for receiving */                    opal_output_verbose(50,                                        mca_btl_portals_component.portals_output,                                        "message was dropped.  Adding to front of queue list");                    opal_list_prepend(&(mca_btl_portals_module.portals_queued_sends),                                      (opal_list_item_t*) frag);                } else {                    /* other side received the message.  should have                       received entire thing */                    /* let the PML know we're done */                    frag->base.des_cbfunc(&mca_btl_portals_module.super,                                          frag->endpoint,                                          &frag->base,                                          OMPI_SUCCESS);                }                if (frag->type == mca_btl_portals_frag_type_send) {                    MCA_BTL_PORTALS_PROGRESS_QUEUED_SENDS();                }                break;            default:                break;            }            break;        case PTL_EQ_EMPTY:            /* there's nothing in the queue.  This is actually the               common case, so the easiest way to make the compiler               emit something that doesn't completely blow here is to               just to go back to a good old goto */            goto done;            break;        case PTL_EQ_DROPPED:            /* not sure how we could deal with this more gracefully */            opal_output(mca_btl_portals_component.portals_output,                        "WARNING: EQ events dropped.  Too many messages pending.");            opal_output(mca_btl_portals_component.portals_output,                        "WARNING: Giving up in dispair");            abort();            break;        default:            opal_output(mca_btl_portals_component.portals_output,                        "WARNING: Error in PtlEQPoll (%d).  This shouldn't happen",                        ret);            abort();            break;        }
ret
ret
{        case PTL_OK:            frag = ev.md.user_ptr;            num_progressed++;            switch (ev.type) {            case PTL_EVENT_GET_START:                /* generated on source (target) when a get from memory starts */                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_GET_START for 0x%x, %d",                                     frag, (int) ev.hdr_data));                break;            case PTL_EVENT_GET_END:                /* generated on source (target) when a get from memory ends */                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_GET_END for 0x%x, %d",                                     frag, (int) ev.hdr_data));                break;            case PTL_EVENT_PUT_START:                /* generated on destination (target) when a put into memory starts */                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_PUT_START for 0x%x, %d",                                     frag, (int) ev.hdr_data));#if OMPI_ENABLE_DEBUG                if (ev.ni_fail_type != PTL_NI_OK) {                    opal_output(mca_btl_portals_component.portals_output,                                "Failure to start event\n");                    return OMPI_ERROR;                }#endif                /* if it's a pending unexpected receive, do book keeping. */                if (ev.hdr_data < MCA_BTL_TAG_MAX) {                    block = ev.md.user_ptr;                    OPAL_THREAD_ADD32(&(block->pending), 1);                }                break;            case PTL_EVENT_PUT_END:                /* generated on destination (target) when a put into memory ends */                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_PUT_END for 0x%x, %d",                                     frag, (int) ev.hdr_data));#if OMPI_ENABLE_DEBUG                if (ev.ni_fail_type != PTL_NI_OK) {                    opal_output(mca_btl_portals_component.portals_output,                                "Failure to end event\n");                    mca_btl_portals_return_block_part(&mca_btl_portals_module,                                                      block);                    return OMPI_ERROR;                }#endif                /* if it's an unexpected receive, do book keeping and send to PML */                if (ev.hdr_data < MCA_BTL_TAG_MAX) {                    block = ev.md.user_ptr;                    tag = ev.hdr_data;                    OMPI_BTL_PORTALS_FRAG_ALLOC_RECV(&mca_btl_portals_module, frag, ret);                    frag->segments[0].seg_addr.pval = (((char*) ev.md.start) + ev.offset);                    frag->segments[0].seg_len = ev.mlength;                    OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                         "received send fragment %x", frag));                    if (ev.md.length - (ev.offset + ev.mlength) < ev.md.max_size) {                        /* the block is full.  It's deactivated automagically, but we                           can't start it up again until everyone is done with it.                           The actual reactivation and all that will happen after the                           free completes the last operation... */                        OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                             "marking block 0x%x as full", block->start));                        block->full = true;                    }                    assert(NULL != mca_btl_portals_module.portals_reg[tag].cbfunc);                    mca_btl_portals_module.portals_reg[tag].cbfunc(                                             &mca_btl_portals_module.super,                                             tag,                                             &frag->base,                                             mca_btl_portals_module.portals_reg[tag].cbdata);                    OMPI_BTL_PORTALS_FRAG_RETURN_RECV(&mca_btl_portals_module.super,                                                      frag);                    mca_btl_portals_return_block_part(&mca_btl_portals_module, block);                }                break;            case PTL_EVENT_REPLY_START:                /* generated on destination (origin) when a get starts                   returning data */                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_REPLY_START for 0x%x, %d, %d",                                     frag, (int) frag->type, (int) ev.hdr_data));                break;            case PTL_EVENT_REPLY_END:                /* generated on destination (origin) when a get is                   done returning data */                OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_REPLY_END for 0x%x, %d",                                     frag, (int) frag->type));                /* let the PML know we're done */                frag->base.des_cbfunc(&mca_btl_portals_module.super,                                      frag->endpoint,                                      &frag->base,                                      OMPI_SUCCESS);                break;            case PTL_EVENT_SEND_START:                /* generated on source (origin) when put starts sending */#if OMPI_ENABLE_DEBUG                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_SEND_START for 0x%x, %d, %d",                                     frag, (int) frag->type, (int) ev.hdr_data));                if (ev.ni_fail_type != PTL_NI_OK) {                    opal_output(mca_btl_portals_component.portals_output,                                "Failure to start send event\n");                    if (ev.hdr_data < MCA_BTL_TAG_MAX) {                        OPAL_THREAD_ADD32(&mca_btl_portals_module.portals_outstanding_sends,                                          -1);                        /* unlink, since we don't expect to get an end or ack */                    }                    PtlMDUnlink(ev.md_handle);                    frag->base.des_cbfunc(&mca_btl_portals_module.super,                                          frag->endpoint,                                          &frag->base,                                          OMPI_ERROR);                }#endif                break;            case PTL_EVENT_SEND_END:                /* generated on source (origin) when put stops sending */#if OMPI_ENABLE_DEBUG                OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_SEND_END for 0x%x, %d, %d",                                     frag, (int) frag->type, (int) ev.hdr_data));                if (ev.ni_fail_type != PTL_NI_OK) {                    opal_output(mca_btl_portals_component.portals_output,                                "Failure to end send event\n");                    if (ev.hdr_data < MCA_BTL_TAG_MAX) {                        /* unlink, since we don't expect to get an ack */                        OPAL_THREAD_ADD32(&mca_btl_portals_module.portals_outstanding_sends,                                          -1);                        PtlMDUnlink(ev.md_handle);                    }                    frag->base.des_cbfunc(&mca_btl_portals_module.super,                                          frag->endpoint,                                          &frag->base,                                          OMPI_ERROR);                }#endif                break;            case PTL_EVENT_ACK:                /* ack that a put as completed on other side */                /* ACK for either send or RDMA put.  Either way, we                   just call the callback function on goodness.                   Requeue the put on badness */                OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_ACK for 0x%x, %d",                                     frag, (int) frag->type));                if (frag->type == mca_btl_portals_frag_type_send) {                    OPAL_THREAD_ADD32(&mca_btl_portals_module.portals_outstanding_sends,                                      -1);                }#if OMPI_ENABLE_DEBUG                if (ev.ni_fail_type != PTL_NI_OK) {                    opal_output(mca_btl_portals_component.portals_output,                                "Failure to ack event\n");                    /* unlink, since we don't expect to get an ack */                    PtlMDUnlink(ev.md_handle);                    frag->base.des_cbfunc(&mca_btl_portals_module.super,                                          frag->endpoint,                                          &frag->base,                                          OMPI_ERROR);                } else#endif                if (0 == ev.mlength) {                    /* other side received message but truncated to 0.                       This should only happen for unexpected                       messages, and only when the other side has no                       buffer space available for receiving */                    opal_output_verbose(50,                                        mca_btl_portals_component.portals_output,                                        "message was dropped.  Adding to front of queue list");                    opal_list_prepend(&(mca_btl_portals_module.portals_queued_sends),                                      (opal_list_item_t*) frag);                } else {                    /* other side received the message.  should have                       received entire thing */                    /* let the PML know we're done */                    frag->base.des_cbfunc(&mca_btl_portals_module.super,                                          frag->endpoint,                                          &frag->base,                                          OMPI_SUCCESS);                }                if (frag->type == mca_btl_portals_frag_type_send) {                    MCA_BTL_PORTALS_PROGRESS_QUEUED_SENDS();                }                break;            default:                break;            }            break;        case PTL_EQ_EMPTY:            /* there's nothing in the queue.  This is actually the               common case, so the easiest way to make the compiler               emit something that doesn't completely blow here is to               just to go back to a good old goto */            goto done;            break;        case PTL_EQ_DROPPED:            /* not sure how we could deal with this more gracefully */            opal_output(mca_btl_portals_component.portals_output,                        "WARNING: EQ events dropped.  Too many messages pending.");            opal_output(mca_btl_portals_component.portals_output,                        "WARNING: Giving up in dispair");            abort();            break;        default:            opal_output(mca_btl_portals_component.portals_output,                        "WARNING: Error in PtlEQPoll (%d).  This shouldn't happen",                        ret);            abort();            break;        }
case PTL_OK:
PTL_OK
PTL_OK
frag = ev.md.user_ptr;
frag = ev.md.user_ptr
frag
frag
ev.md.user_ptr
ev.md
ev
ev
md
user_ptr
num_progressed++;
num_progressed++
num_progressed
num_progressed
switch (ev.type) {            case PTL_EVENT_GET_START:                /* generated on source (target) when a get from memory starts */                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_GET_START for 0x%x, %d",                                     frag, (int) ev.hdr_data));                break;            case PTL_EVENT_GET_END:                /* generated on source (target) when a get from memory ends */                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_GET_END for 0x%x, %d",                                     frag, (int) ev.hdr_data));                break;            case PTL_EVENT_PUT_START:                /* generated on destination (target) when a put into memory starts */                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_PUT_START for 0x%x, %d",                                     frag, (int) ev.hdr_data));#if OMPI_ENABLE_DEBUG                if (ev.ni_fail_type != PTL_NI_OK) {                    opal_output(mca_btl_portals_component.portals_output,                                "Failure to start event\n");                    return OMPI_ERROR;                }#endif                /* if it's a pending unexpected receive, do book keeping. */                if (ev.hdr_data < MCA_BTL_TAG_MAX) {                    block = ev.md.user_ptr;                    OPAL_THREAD_ADD32(&(block->pending), 1);                }                break;            case PTL_EVENT_PUT_END:                /* generated on destination (target) when a put into memory ends */                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_PUT_END for 0x%x, %d",                                     frag, (int) ev.hdr_data));#if OMPI_ENABLE_DEBUG                if (ev.ni_fail_type != PTL_NI_OK) {                    opal_output(mca_btl_portals_component.portals_output,                                "Failure to end event\n");                    mca_btl_portals_return_block_part(&mca_btl_portals_module,                                                      block);                    return OMPI_ERROR;                }#endif                /* if it's an unexpected receive, do book keeping and send to PML */                if (ev.hdr_data < MCA_BTL_TAG_MAX) {                    block = ev.md.user_ptr;                    tag = ev.hdr_data;                    OMPI_BTL_PORTALS_FRAG_ALLOC_RECV(&mca_btl_portals_module, frag, ret);                    frag->segments[0].seg_addr.pval = (((char*) ev.md.start) + ev.offset);                    frag->segments[0].seg_len = ev.mlength;                    OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                         "received send fragment %x", frag));                    if (ev.md.length - (ev.offset + ev.mlength) < ev.md.max_size) {                        /* the block is full.  It's deactivated automagically, but we                           can't start it up again until everyone is done with it.                           The actual reactivation and all that will happen after the                           free completes the last operation... */                        OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                             "marking block 0x%x as full", block->start));                        block->full = true;                    }                    assert(NULL != mca_btl_portals_module.portals_reg[tag].cbfunc);                    mca_btl_portals_module.portals_reg[tag].cbfunc(                                             &mca_btl_portals_module.super,                                             tag,                                             &frag->base,                                             mca_btl_portals_module.portals_reg[tag].cbdata);                    OMPI_BTL_PORTALS_FRAG_RETURN_RECV(&mca_btl_portals_module.super,                                                      frag);                    mca_btl_portals_return_block_part(&mca_btl_portals_module, block);                }                break;            case PTL_EVENT_REPLY_START:                /* generated on destination (origin) when a get starts                   returning data */                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_REPLY_START for 0x%x, %d, %d",                                     frag, (int) frag->type, (int) ev.hdr_data));                break;            case PTL_EVENT_REPLY_END:                /* generated on destination (origin) when a get is                   done returning data */                OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_REPLY_END for 0x%x, %d",                                     frag, (int) frag->type));                /* let the PML know we're done */                frag->base.des_cbfunc(&mca_btl_portals_module.super,                                      frag->endpoint,                                      &frag->base,                                      OMPI_SUCCESS);                break;            case PTL_EVENT_SEND_START:                /* generated on source (origin) when put starts sending */#if OMPI_ENABLE_DEBUG                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_SEND_START for 0x%x, %d, %d",                                     frag, (int) frag->type, (int) ev.hdr_data));                if (ev.ni_fail_type != PTL_NI_OK) {                    opal_output(mca_btl_portals_component.portals_output,                                "Failure to start send event\n");                    if (ev.hdr_data < MCA_BTL_TAG_MAX) {                        OPAL_THREAD_ADD32(&mca_btl_portals_module.portals_outstanding_sends,                                          -1);                        /* unlink, since we don't expect to get an end or ack */                    }                    PtlMDUnlink(ev.md_handle);                    frag->base.des_cbfunc(&mca_btl_portals_module.super,                                          frag->endpoint,                                          &frag->base,                                          OMPI_ERROR);                }#endif                break;            case PTL_EVENT_SEND_END:                /* generated on source (origin) when put stops sending */#if OMPI_ENABLE_DEBUG                OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_SEND_END for 0x%x, %d, %d",                                     frag, (int) frag->type, (int) ev.hdr_data));                if (ev.ni_fail_type != PTL_NI_OK) {                    opal_output(mca_btl_portals_component.portals_output,                                "Failure to end send event\n");                    if (ev.hdr_data < MCA_BTL_TAG_MAX) {                        /* unlink, since we don't expect to get an ack */                        OPAL_THREAD_ADD32(&mca_btl_portals_module.portals_outstanding_sends,                                          -1);                        PtlMDUnlink(ev.md_handle);                    }                    frag->base.des_cbfunc(&mca_btl_portals_module.super,                                          frag->endpoint,                                          &frag->base,                                          OMPI_ERROR);                }#endif                break;            case PTL_EVENT_ACK:                /* ack that a put as completed on other side */                /* ACK for either send or RDMA put.  Either way, we                   just call the callback function on goodness.                   Requeue the put on badness */                OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_ACK for 0x%x, %d",                                     frag, (int) frag->type));                if (frag->type == mca_btl_portals_frag_type_send) {                    OPAL_THREAD_ADD32(&mca_btl_portals_module.portals_outstanding_sends,                                      -1);                }#if OMPI_ENABLE_DEBUG                if (ev.ni_fail_type != PTL_NI_OK) {                    opal_output(mca_btl_portals_component.portals_output,                                "Failure to ack event\n");                    /* unlink, since we don't expect to get an ack */                    PtlMDUnlink(ev.md_handle);                    frag->base.des_cbfunc(&mca_btl_portals_module.super,                                          frag->endpoint,                                          &frag->base,                                          OMPI_ERROR);                } else#endif                if (0 == ev.mlength) {                    /* other side received message but truncated to 0.                       This should only happen for unexpected                       messages, and only when the other side has no                       buffer space available for receiving */                    opal_output_verbose(50,                                        mca_btl_portals_component.portals_output,                                        "message was dropped.  Adding to front of queue list");                    opal_list_prepend(&(mca_btl_portals_module.portals_queued_sends),                                      (opal_list_item_t*) frag);                } else {                    /* other side received the message.  should have                       received entire thing */                    /* let the PML know we're done */                    frag->base.des_cbfunc(&mca_btl_portals_module.super,                                          frag->endpoint,                                          &frag->base,                                          OMPI_SUCCESS);                }                if (frag->type == mca_btl_portals_frag_type_send) {                    MCA_BTL_PORTALS_PROGRESS_QUEUED_SENDS();                }                break;            default:                break;            }
ev.type
ev
ev
type
{            case PTL_EVENT_GET_START:                /* generated on source (target) when a get from memory starts */                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_GET_START for 0x%x, %d",                                     frag, (int) ev.hdr_data));                break;            case PTL_EVENT_GET_END:                /* generated on source (target) when a get from memory ends */                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_GET_END for 0x%x, %d",                                     frag, (int) ev.hdr_data));                break;            case PTL_EVENT_PUT_START:                /* generated on destination (target) when a put into memory starts */                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_PUT_START for 0x%x, %d",                                     frag, (int) ev.hdr_data));#if OMPI_ENABLE_DEBUG                if (ev.ni_fail_type != PTL_NI_OK) {                    opal_output(mca_btl_portals_component.portals_output,                                "Failure to start event\n");                    return OMPI_ERROR;                }#endif                /* if it's a pending unexpected receive, do book keeping. */                if (ev.hdr_data < MCA_BTL_TAG_MAX) {                    block = ev.md.user_ptr;                    OPAL_THREAD_ADD32(&(block->pending), 1);                }                break;            case PTL_EVENT_PUT_END:                /* generated on destination (target) when a put into memory ends */                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_PUT_END for 0x%x, %d",                                     frag, (int) ev.hdr_data));#if OMPI_ENABLE_DEBUG                if (ev.ni_fail_type != PTL_NI_OK) {                    opal_output(mca_btl_portals_component.portals_output,                                "Failure to end event\n");                    mca_btl_portals_return_block_part(&mca_btl_portals_module,                                                      block);                    return OMPI_ERROR;                }#endif                /* if it's an unexpected receive, do book keeping and send to PML */                if (ev.hdr_data < MCA_BTL_TAG_MAX) {                    block = ev.md.user_ptr;                    tag = ev.hdr_data;                    OMPI_BTL_PORTALS_FRAG_ALLOC_RECV(&mca_btl_portals_module, frag, ret);                    frag->segments[0].seg_addr.pval = (((char*) ev.md.start) + ev.offset);                    frag->segments[0].seg_len = ev.mlength;                    OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                         "received send fragment %x", frag));                    if (ev.md.length - (ev.offset + ev.mlength) < ev.md.max_size) {                        /* the block is full.  It's deactivated automagically, but we                           can't start it up again until everyone is done with it.                           The actual reactivation and all that will happen after the                           free completes the last operation... */                        OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                             "marking block 0x%x as full", block->start));                        block->full = true;                    }                    assert(NULL != mca_btl_portals_module.portals_reg[tag].cbfunc);                    mca_btl_portals_module.portals_reg[tag].cbfunc(                                             &mca_btl_portals_module.super,                                             tag,                                             &frag->base,                                             mca_btl_portals_module.portals_reg[tag].cbdata);                    OMPI_BTL_PORTALS_FRAG_RETURN_RECV(&mca_btl_portals_module.super,                                                      frag);                    mca_btl_portals_return_block_part(&mca_btl_portals_module, block);                }                break;            case PTL_EVENT_REPLY_START:                /* generated on destination (origin) when a get starts                   returning data */                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_REPLY_START for 0x%x, %d, %d",                                     frag, (int) frag->type, (int) ev.hdr_data));                break;            case PTL_EVENT_REPLY_END:                /* generated on destination (origin) when a get is                   done returning data */                OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_REPLY_END for 0x%x, %d",                                     frag, (int) frag->type));                /* let the PML know we're done */                frag->base.des_cbfunc(&mca_btl_portals_module.super,                                      frag->endpoint,                                      &frag->base,                                      OMPI_SUCCESS);                break;            case PTL_EVENT_SEND_START:                /* generated on source (origin) when put starts sending */#if OMPI_ENABLE_DEBUG                OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_SEND_START for 0x%x, %d, %d",                                     frag, (int) frag->type, (int) ev.hdr_data));                if (ev.ni_fail_type != PTL_NI_OK) {                    opal_output(mca_btl_portals_component.portals_output,                                "Failure to start send event\n");                    if (ev.hdr_data < MCA_BTL_TAG_MAX) {                        OPAL_THREAD_ADD32(&mca_btl_portals_module.portals_outstanding_sends,                                          -1);                        /* unlink, since we don't expect to get an end or ack */                    }                    PtlMDUnlink(ev.md_handle);                    frag->base.des_cbfunc(&mca_btl_portals_module.super,                                          frag->endpoint,                                          &frag->base,                                          OMPI_ERROR);                }#endif                break;            case PTL_EVENT_SEND_END:                /* generated on source (origin) when put stops sending */#if OMPI_ENABLE_DEBUG                OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_SEND_END for 0x%x, %d, %d",                                     frag, (int) frag->type, (int) ev.hdr_data));                if (ev.ni_fail_type != PTL_NI_OK) {                    opal_output(mca_btl_portals_component.portals_output,                                "Failure to end send event\n");                    if (ev.hdr_data < MCA_BTL_TAG_MAX) {                        /* unlink, since we don't expect to get an ack */                        OPAL_THREAD_ADD32(&mca_btl_portals_module.portals_outstanding_sends,                                          -1);                        PtlMDUnlink(ev.md_handle);                    }                    frag->base.des_cbfunc(&mca_btl_portals_module.super,                                          frag->endpoint,                                          &frag->base,                                          OMPI_ERROR);                }#endif                break;            case PTL_EVENT_ACK:                /* ack that a put as completed on other side */                /* ACK for either send or RDMA put.  Either way, we                   just call the callback function on goodness.                   Requeue the put on badness */                OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_ACK for 0x%x, %d",                                     frag, (int) frag->type));                if (frag->type == mca_btl_portals_frag_type_send) {                    OPAL_THREAD_ADD32(&mca_btl_portals_module.portals_outstanding_sends,                                      -1);                }#if OMPI_ENABLE_DEBUG                if (ev.ni_fail_type != PTL_NI_OK) {                    opal_output(mca_btl_portals_component.portals_output,                                "Failure to ack event\n");                    /* unlink, since we don't expect to get an ack */                    PtlMDUnlink(ev.md_handle);                    frag->base.des_cbfunc(&mca_btl_portals_module.super,                                          frag->endpoint,                                          &frag->base,                                          OMPI_ERROR);                } else#endif                if (0 == ev.mlength) {                    /* other side received message but truncated to 0.                       This should only happen for unexpected                       messages, and only when the other side has no                       buffer space available for receiving */                    opal_output_verbose(50,                                        mca_btl_portals_component.portals_output,                                        "message was dropped.  Adding to front of queue list");                    opal_list_prepend(&(mca_btl_portals_module.portals_queued_sends),                                      (opal_list_item_t*) frag);                } else {                    /* other side received the message.  should have                       received entire thing */                    /* let the PML know we're done */                    frag->base.des_cbfunc(&mca_btl_portals_module.super,                                          frag->endpoint,                                          &frag->base,                                          OMPI_SUCCESS);                }                if (frag->type == mca_btl_portals_frag_type_send) {                    MCA_BTL_PORTALS_PROGRESS_QUEUED_SENDS();                }                break;            default:                break;            }
case PTL_EVENT_GET_START:
PTL_EVENT_GET_START
PTL_EVENT_GET_START
OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_GET_START for 0x%x, %d",                                     frag, (int) ev.hdr_data));
OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_GET_START for 0x%x, %d",                                     frag, (int) ev.hdr_data))
OPAL_OUTPUT_VERBOSE
OPAL_OUTPUT_VERBOSE
(900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_GET_START for 0x%x, %d",                                     frag, (int) ev.hdr_data)
900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_GET_START for 0x%x, %d",                                     frag, (int) ev.hdr_data
900
mca_btl_portals_component.portals_output
mca_btl_portals_component
mca_btl_portals_component
portals_output
"PTL_EVENT_GET_START for 0x%x, %d"
frag
frag
(int) ev.hdr_data
int
int

ev.hdr_data
ev
ev
hdr_data
break;
case PTL_EVENT_GET_END:
PTL_EVENT_GET_END
PTL_EVENT_GET_END
OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_GET_END for 0x%x, %d",                                     frag, (int) ev.hdr_data));
OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_GET_END for 0x%x, %d",                                     frag, (int) ev.hdr_data))
OPAL_OUTPUT_VERBOSE
OPAL_OUTPUT_VERBOSE
(900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_GET_END for 0x%x, %d",                                     frag, (int) ev.hdr_data)
900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_GET_END for 0x%x, %d",                                     frag, (int) ev.hdr_data
900
mca_btl_portals_component.portals_output
mca_btl_portals_component
mca_btl_portals_component
portals_output
"PTL_EVENT_GET_END for 0x%x, %d"
frag
frag
(int) ev.hdr_data
int
int

ev.hdr_data
ev
ev
hdr_data
break;
case PTL_EVENT_PUT_START:
PTL_EVENT_PUT_START
PTL_EVENT_PUT_START
OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_PUT_START for 0x%x, %d",                                     frag, (int) ev.hdr_data));
OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_PUT_START for 0x%x, %d",                                     frag, (int) ev.hdr_data))
OPAL_OUTPUT_VERBOSE
OPAL_OUTPUT_VERBOSE
(900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_PUT_START for 0x%x, %d",                                     frag, (int) ev.hdr_data)
900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_PUT_START for 0x%x, %d",                                     frag, (int) ev.hdr_data
900
mca_btl_portals_component.portals_output
mca_btl_portals_component
mca_btl_portals_component
portals_output
"PTL_EVENT_PUT_START for 0x%x, %d"
frag
frag
(int) ev.hdr_data
int
int

ev.hdr_data
ev
ev
hdr_data
if (ev.hdr_data < MCA_BTL_TAG_MAX) {                    block = ev.md.user_ptr;                    OPAL_THREAD_ADD32(&(block->pending), 1);                }
ev.hdr_data < MCA_BTL_TAG_MAX
ev.hdr_data
ev
ev
hdr_data
MCA_BTL_TAG_MAX
MCA_BTL_TAG_MAX
{                    block = ev.md.user_ptr;                    OPAL_THREAD_ADD32(&(block->pending), 1);                }
block = ev.md.user_ptr;
block = ev.md.user_ptr
block
block
ev.md.user_ptr
ev.md
ev
ev
md
user_ptr
OPAL_THREAD_ADD32(&(block->pending), 1);
OPAL_THREAD_ADD32(&(block->pending), 1)
OPAL_THREAD_ADD32
OPAL_THREAD_ADD32
&(block->pending)
(block->pending)
block->pending
block
block
pending
1
break;
case PTL_EVENT_PUT_END:
PTL_EVENT_PUT_END
PTL_EVENT_PUT_END
OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_PUT_END for 0x%x, %d",                                     frag, (int) ev.hdr_data));
OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_PUT_END for 0x%x, %d",                                     frag, (int) ev.hdr_data))
OPAL_OUTPUT_VERBOSE
OPAL_OUTPUT_VERBOSE
(900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_PUT_END for 0x%x, %d",                                     frag, (int) ev.hdr_data)
900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_PUT_END for 0x%x, %d",                                     frag, (int) ev.hdr_data
900
mca_btl_portals_component.portals_output
mca_btl_portals_component
mca_btl_portals_component
portals_output
"PTL_EVENT_PUT_END for 0x%x, %d"
frag
frag
(int) ev.hdr_data
int
int

ev.hdr_data
ev
ev
hdr_data
if (ev.hdr_data < MCA_BTL_TAG_MAX) {                    block = ev.md.user_ptr;                    tag = ev.hdr_data;                    OMPI_BTL_PORTALS_FRAG_ALLOC_RECV(&mca_btl_portals_module, frag, ret);                    frag->segments[0].seg_addr.pval = (((char*) ev.md.start) + ev.offset);                    frag->segments[0].seg_len = ev.mlength;                    OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                         "received send fragment %x", frag));                    if (ev.md.length - (ev.offset + ev.mlength) < ev.md.max_size) {                        /* the block is full.  It's deactivated automagically, but we                           can't start it up again until everyone is done with it.                           The actual reactivation and all that will happen after the                           free completes the last operation... */                        OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                             "marking block 0x%x as full", block->start));                        block->full = true;                    }                    assert(NULL != mca_btl_portals_module.portals_reg[tag].cbfunc);                    mca_btl_portals_module.portals_reg[tag].cbfunc(                                             &mca_btl_portals_module.super,                                             tag,                                             &frag->base,                                             mca_btl_portals_module.portals_reg[tag].cbdata);                    OMPI_BTL_PORTALS_FRAG_RETURN_RECV(&mca_btl_portals_module.super,                                                      frag);                    mca_btl_portals_return_block_part(&mca_btl_portals_module, block);                }
ev.hdr_data < MCA_BTL_TAG_MAX
ev.hdr_data
ev
ev
hdr_data
MCA_BTL_TAG_MAX
MCA_BTL_TAG_MAX
{                    block = ev.md.user_ptr;                    tag = ev.hdr_data;                    OMPI_BTL_PORTALS_FRAG_ALLOC_RECV(&mca_btl_portals_module, frag, ret);                    frag->segments[0].seg_addr.pval = (((char*) ev.md.start) + ev.offset);                    frag->segments[0].seg_len = ev.mlength;                    OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                         "received send fragment %x", frag));                    if (ev.md.length - (ev.offset + ev.mlength) < ev.md.max_size) {                        /* the block is full.  It's deactivated automagically, but we                           can't start it up again until everyone is done with it.                           The actual reactivation and all that will happen after the                           free completes the last operation... */                        OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                             "marking block 0x%x as full", block->start));                        block->full = true;                    }                    assert(NULL != mca_btl_portals_module.portals_reg[tag].cbfunc);                    mca_btl_portals_module.portals_reg[tag].cbfunc(                                             &mca_btl_portals_module.super,                                             tag,                                             &frag->base,                                             mca_btl_portals_module.portals_reg[tag].cbdata);                    OMPI_BTL_PORTALS_FRAG_RETURN_RECV(&mca_btl_portals_module.super,                                                      frag);                    mca_btl_portals_return_block_part(&mca_btl_portals_module, block);                }
block = ev.md.user_ptr;
block = ev.md.user_ptr
block
block
ev.md.user_ptr
ev.md
ev
ev
md
user_ptr
tag = ev.hdr_data;
tag = ev.hdr_data
tag
tag
ev.hdr_data
ev
ev
hdr_data
OMPI_BTL_PORTALS_FRAG_ALLOC_RECV(&mca_btl_portals_module, frag, ret);
OMPI_BTL_PORTALS_FRAG_ALLOC_RECV(&mca_btl_portals_module, frag, ret)
OMPI_BTL_PORTALS_FRAG_ALLOC_RECV
OMPI_BTL_PORTALS_FRAG_ALLOC_RECV
&mca_btl_portals_module
mca_btl_portals_module
mca_btl_portals_module
frag
frag
ret
ret
frag->segments[0].seg_addr.pval = (((char*) ev.md.start) + ev.offset);
frag->segments[0].seg_addr.pval = (((char*) ev.md.start) + ev.offset)
frag->segments[0].seg_addr.pval
frag->segments[0].seg_addr
frag->segments[0]
frag->segments
frag
frag
segments
0
seg_addr
pval
(((char*) ev.md.start) + ev.offset)
((char*) ev.md.start) + ev.offset
((char*) ev.md.start)
(char*) ev.md.start
char*
char
*
*
ev.md.start
ev.md
ev
ev
md
start
ev.offset
ev
ev
offset
frag->segments[0].seg_len = ev.mlength;
frag->segments[0].seg_len = ev.mlength
frag->segments[0].seg_len
frag->segments[0]
frag->segments
frag
frag
segments
0
seg_len
ev.mlength
ev
ev
mlength
OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                         "received send fragment %x", frag));
OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                         "received send fragment %x", frag))
OPAL_OUTPUT_VERBOSE
OPAL_OUTPUT_VERBOSE
(90, mca_btl_portals_component.portals_output,                                         "received send fragment %x", frag)
90, mca_btl_portals_component.portals_output,                                         "received send fragment %x", frag
90
mca_btl_portals_component.portals_output
mca_btl_portals_component
mca_btl_portals_component
portals_output
"received send fragment %x"
frag
frag
if (ev.md.length - (ev.offset + ev.mlength) < ev.md.max_size) {                        /* the block is full.  It's deactivated automagically, but we                           can't start it up again until everyone is done with it.                           The actual reactivation and all that will happen after the                           free completes the last operation... */                        OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                             "marking block 0x%x as full", block->start));                        block->full = true;                    }
ev.md.length - (ev.offset + ev.mlength) < ev.md.max_size
ev.md.length - (ev.offset + ev.mlength)
ev.md.length
ev.md
ev
ev
md
length
(ev.offset + ev.mlength)
ev.offset + ev.mlength
ev.offset
ev
ev
offset
ev.mlength
ev
ev
mlength
ev.md.max_size
ev.md
ev
ev
md
max_size
{                        /* the block is full.  It's deactivated automagically, but we                           can't start it up again until everyone is done with it.                           The actual reactivation and all that will happen after the                           free completes the last operation... */                        OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                             "marking block 0x%x as full", block->start));                        block->full = true;                    }
OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                             "marking block 0x%x as full", block->start));
OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                             "marking block 0x%x as full", block->start))
OPAL_OUTPUT_VERBOSE
OPAL_OUTPUT_VERBOSE
(90, mca_btl_portals_component.portals_output,                                             "marking block 0x%x as full", block->start)
90, mca_btl_portals_component.portals_output,                                             "marking block 0x%x as full", block->start
90
mca_btl_portals_component.portals_output
mca_btl_portals_component
mca_btl_portals_component
portals_output
"marking block 0x%x as full"
block->start
block
block
start
block->full = true;
block->full = true
block->full
block
block
full
true
assert(NULL != mca_btl_portals_module.portals_reg[tag].cbfunc);
assert(NULL != mca_btl_portals_module.portals_reg[tag].cbfunc)
assert
assert
NULL != mca_btl_portals_module.portals_reg[tag].cbfunc
NULL
NULL
mca_btl_portals_module.portals_reg[tag].cbfunc
mca_btl_portals_module.portals_reg[tag]
mca_btl_portals_module.portals_reg
mca_btl_portals_module
mca_btl_portals_module
portals_reg
tag
tag
cbfunc
mca_btl_portals_module.portals_reg[tag].cbfunc(                                             &mca_btl_portals_module.super,                                             tag,                                             &frag->base,                                             mca_btl_portals_module.portals_reg[tag].cbdata);
mca_btl_portals_module.portals_reg[tag].cbfunc(                                             &mca_btl_portals_module.super,                                             tag,                                             &frag->base,                                             mca_btl_portals_module.portals_reg[tag].cbdata)
mca_btl_portals_module.portals_reg[tag].cbfunc
mca_btl_portals_module.portals_reg[tag]
mca_btl_portals_module.portals_reg
mca_btl_portals_module
mca_btl_portals_module
portals_reg
tag
tag
cbfunc
&mca_btl_portals_module.super
mca_btl_portals_module.super
mca_btl_portals_module
mca_btl_portals_module
super
tag
tag
&frag->base
frag->base
frag
frag
base
mca_btl_portals_module.portals_reg[tag].cbdata
mca_btl_portals_module.portals_reg[tag]
mca_btl_portals_module.portals_reg
mca_btl_portals_module
mca_btl_portals_module
portals_reg
tag
tag
cbdata
OMPI_BTL_PORTALS_FRAG_RETURN_RECV(&mca_btl_portals_module.super,                                                      frag);
OMPI_BTL_PORTALS_FRAG_RETURN_RECV(&mca_btl_portals_module.super,                                                      frag)
OMPI_BTL_PORTALS_FRAG_RETURN_RECV
OMPI_BTL_PORTALS_FRAG_RETURN_RECV
&mca_btl_portals_module.super
mca_btl_portals_module.super
mca_btl_portals_module
mca_btl_portals_module
super
frag
frag
mca_btl_portals_return_block_part(&mca_btl_portals_module, block);
mca_btl_portals_return_block_part(&mca_btl_portals_module, block)
mca_btl_portals_return_block_part
mca_btl_portals_return_block_part
&mca_btl_portals_module
mca_btl_portals_module
mca_btl_portals_module
block
block
break;
case PTL_EVENT_REPLY_START:
PTL_EVENT_REPLY_START
PTL_EVENT_REPLY_START
OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_REPLY_START for 0x%x, %d, %d",                                     frag, (int) frag->type, (int) ev.hdr_data));
OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_REPLY_START for 0x%x, %d, %d",                                     frag, (int) frag->type, (int) ev.hdr_data))
OPAL_OUTPUT_VERBOSE
OPAL_OUTPUT_VERBOSE
(900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_REPLY_START for 0x%x, %d, %d",                                     frag, (int) frag->type, (int) ev.hdr_data)
900, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_REPLY_START for 0x%x, %d, %d",                                     frag, (int) frag->type, (int) ev.hdr_data
900
mca_btl_portals_component.portals_output
mca_btl_portals_component
mca_btl_portals_component
portals_output
"PTL_EVENT_REPLY_START for 0x%x, %d, %d"
frag
frag
(int) frag->type
int
int

frag->type
frag
frag
type
(int) ev.hdr_data
int
int

ev.hdr_data
ev
ev
hdr_data
break;
case PTL_EVENT_REPLY_END:
PTL_EVENT_REPLY_END
PTL_EVENT_REPLY_END
OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_REPLY_END for 0x%x, %d",                                     frag, (int) frag->type));
OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_REPLY_END for 0x%x, %d",                                     frag, (int) frag->type))
OPAL_OUTPUT_VERBOSE
OPAL_OUTPUT_VERBOSE
(90, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_REPLY_END for 0x%x, %d",                                     frag, (int) frag->type)
90, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_REPLY_END for 0x%x, %d",                                     frag, (int) frag->type
90
mca_btl_portals_component.portals_output
mca_btl_portals_component
mca_btl_portals_component
portals_output
"PTL_EVENT_REPLY_END for 0x%x, %d"
frag
frag
(int) frag->type
int
int

frag->type
frag
frag
type
frag->base.des_cbfunc(&mca_btl_portals_module.super,                                      frag->endpoint,                                      &frag->base,                                      OMPI_SUCCESS);
frag->base.des_cbfunc(&mca_btl_portals_module.super,                                      frag->endpoint,                                      &frag->base,                                      OMPI_SUCCESS)
frag->base.des_cbfunc
frag->base
frag
frag
base
des_cbfunc
&mca_btl_portals_module.super
mca_btl_portals_module.super
mca_btl_portals_module
mca_btl_portals_module
super
frag->endpoint
frag
frag
endpoint
&frag->base
frag->base
frag
frag
base
OMPI_SUCCESS
OMPI_SUCCESS
break;
case PTL_EVENT_SEND_START:
PTL_EVENT_SEND_START
PTL_EVENT_SEND_START
break;
case PTL_EVENT_SEND_END:
PTL_EVENT_SEND_END
PTL_EVENT_SEND_END
break;
case PTL_EVENT_ACK:
PTL_EVENT_ACK
PTL_EVENT_ACK
OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_ACK for 0x%x, %d",                                     frag, (int) frag->type));
OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_ACK for 0x%x, %d",                                     frag, (int) frag->type))
OPAL_OUTPUT_VERBOSE
OPAL_OUTPUT_VERBOSE
(90, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_ACK for 0x%x, %d",                                     frag, (int) frag->type)
90, mca_btl_portals_component.portals_output,                                     "PTL_EVENT_ACK for 0x%x, %d",                                     frag, (int) frag->type
90
mca_btl_portals_component.portals_output
mca_btl_portals_component
mca_btl_portals_component
portals_output
"PTL_EVENT_ACK for 0x%x, %d"
frag
frag
(int) frag->type
int
int

frag->type
frag
frag
type
if (frag->type == mca_btl_portals_frag_type_send) {                    OPAL_THREAD_ADD32(&mca_btl_portals_module.portals_outstanding_sends,                                      -1);                }
frag->type == mca_btl_portals_frag_type_send
frag->type
frag
frag
type
mca_btl_portals_frag_type_send
mca_btl_portals_frag_type_send
{                    OPAL_THREAD_ADD32(&mca_btl_portals_module.portals_outstanding_sends,                                      -1);                }
OPAL_THREAD_ADD32(&mca_btl_portals_module.portals_outstanding_sends,                                      -1);
OPAL_THREAD_ADD32(&mca_btl_portals_module.portals_outstanding_sends,                                      -1)
OPAL_THREAD_ADD32
OPAL_THREAD_ADD32
&mca_btl_portals_module.portals_outstanding_sends
mca_btl_portals_module.portals_outstanding_sends
mca_btl_portals_module
mca_btl_portals_module
portals_outstanding_sends
-1
1
if (0 == ev.mlength) {                    /* other side received message but truncated to 0.                       This should only happen for unexpected                       messages, and only when the other side has no                       buffer space available for receiving */                    opal_output_verbose(50,                                        mca_btl_portals_component.portals_output,                                        "message was dropped.  Adding to front of queue list");                    opal_list_prepend(&(mca_btl_portals_module.portals_queued_sends),                                      (opal_list_item_t*) frag);                } else {                    /* other side received the message.  should have                       received entire thing */                    /* let the PML know we're done */                    frag->base.des_cbfunc(&mca_btl_portals_module.super,                                          frag->endpoint,                                          &frag->base,                                          OMPI_SUCCESS);                }
0 == ev.mlength
0
ev.mlength
ev
ev
mlength
{                    /* other side received message but truncated to 0.                       This should only happen for unexpected                       messages, and only when the other side has no                       buffer space available for receiving */                    opal_output_verbose(50,                                        mca_btl_portals_component.portals_output,                                        "message was dropped.  Adding to front of queue list");                    opal_list_prepend(&(mca_btl_portals_module.portals_queued_sends),                                      (opal_list_item_t*) frag);                }
opal_output_verbose(50,                                        mca_btl_portals_component.portals_output,                                        "message was dropped.  Adding to front of queue list");
opal_output_verbose(50,                                        mca_btl_portals_component.portals_output,                                        "message was dropped.  Adding to front of queue list")
opal_output_verbose
opal_output_verbose
50
mca_btl_portals_component.portals_output
mca_btl_portals_component
mca_btl_portals_component
portals_output
"message was dropped.  Adding to front of queue list"
opal_list_prepend(&(mca_btl_portals_module.portals_queued_sends),                                      (opal_list_item_t*) frag);
opal_list_prepend(&(mca_btl_portals_module.portals_queued_sends),                                      (opal_list_item_t*) frag)
opal_list_prepend
opal_list_prepend
&(mca_btl_portals_module.portals_queued_sends)
(mca_btl_portals_module.portals_queued_sends)
mca_btl_portals_module.portals_queued_sends
mca_btl_portals_module
mca_btl_portals_module
portals_queued_sends
(opal_list_item_t*) frag
opal_list_item_t*
opal_list_item_t
opal_list_item_t
*
*
frag
frag
{                    /* other side received the message.  should have                       received entire thing */                    /* let the PML know we're done */                    frag->base.des_cbfunc(&mca_btl_portals_module.super,                                          frag->endpoint,                                          &frag->base,                                          OMPI_SUCCESS);                }
frag->base.des_cbfunc(&mca_btl_portals_module.super,                                          frag->endpoint,                                          &frag->base,                                          OMPI_SUCCESS);
frag->base.des_cbfunc(&mca_btl_portals_module.super,                                          frag->endpoint,                                          &frag->base,                                          OMPI_SUCCESS)
frag->base.des_cbfunc
frag->base
frag
frag
base
des_cbfunc
&mca_btl_portals_module.super
mca_btl_portals_module.super
mca_btl_portals_module
mca_btl_portals_module
super
frag->endpoint
frag
frag
endpoint
&frag->base
frag->base
frag
frag
base
OMPI_SUCCESS
OMPI_SUCCESS
if (frag->type == mca_btl_portals_frag_type_send) {                    MCA_BTL_PORTALS_PROGRESS_QUEUED_SENDS();                }
frag->type == mca_btl_portals_frag_type_send
frag->type
frag
frag
type
mca_btl_portals_frag_type_send
mca_btl_portals_frag_type_send
{                    MCA_BTL_PORTALS_PROGRESS_QUEUED_SENDS();                }
MCA_BTL_PORTALS_PROGRESS_QUEUED_SENDS();
MCA_BTL_PORTALS_PROGRESS_QUEUED_SENDS()
MCA_BTL_PORTALS_PROGRESS_QUEUED_SENDS
MCA_BTL_PORTALS_PROGRESS_QUEUED_SENDS
break;
default:
break;
break;
case PTL_EQ_EMPTY:
PTL_EQ_EMPTY
PTL_EQ_EMPTY
goto done;
done
break;
case PTL_EQ_DROPPED:
PTL_EQ_DROPPED
PTL_EQ_DROPPED
opal_output(mca_btl_portals_component.portals_output,                        "WARNING: EQ events dropped.  Too many messages pending.");
opal_output(mca_btl_portals_component.portals_output,                        "WARNING: EQ events dropped.  Too many messages pending.")
opal_output
opal_output
mca_btl_portals_component.portals_output
mca_btl_portals_component
mca_btl_portals_component
portals_output
"WARNING: EQ events dropped.  Too many messages pending."
opal_output(mca_btl_portals_component.portals_output,                        "WARNING: Giving up in dispair");
opal_output(mca_btl_portals_component.portals_output,                        "WARNING: Giving up in dispair")
opal_output
opal_output
mca_btl_portals_component.portals_output
mca_btl_portals_component
mca_btl_portals_component
portals_output
"WARNING: Giving up in dispair"
abort();
abort()
abort
abort
break;
default:
opal_output(mca_btl_portals_component.portals_output,                        "WARNING: Error in PtlEQPoll (%d).  This shouldn't happen",                        ret);
opal_output(mca_btl_portals_component.portals_output,                        "WARNING: Error in PtlEQPoll (%d).  This shouldn't happen",                        ret)
opal_output
opal_output
mca_btl_portals_component.portals_output
mca_btl_portals_component
mca_btl_portals_component
portals_output
"WARNING: Error in PtlEQPoll (%d).  This shouldn't happen"
ret
ret
abort();
abort()
abort
abort
break;
done:    return num_progressed;
done
return num_progressed;
num_progressed
num_progressed
-----joern-----
(438,267,0)
(102,612,0)
(169,426,0)
(364,381,0)
(491,49,0)
(150,99,0)
(585,461,0)
(239,322,0)
(406,97,0)
(33,170,0)
(28,125,0)
(480,426,0)
(156,583,0)
(349,121,0)
(359,501,0)
(90,502,0)
(64,88,0)
(253,217,0)
(428,585,0)
(476,363,0)
(628,556,0)
(380,607,0)
(323,218,0)
(308,219,0)
(606,306,0)
(335,463,0)
(552,219,0)
(495,57,0)
(170,33,0)
(192,566,0)
(56,585,0)
(511,96,0)
(187,358,0)
(155,344,0)
(5,423,0)
(174,178,0)
(622,557,0)
(104,500,0)
(398,283,0)
(334,578,0)
(421,504,0)
(517,621,0)
(303,527,0)
(460,99,0)
(140,42,0)
(155,198,0)
(313,295,0)
(468,568,0)
(201,105,0)
(20,580,0)
(263,581,0)
(98,580,0)
(406,328,0)
(269,287,0)
(134,419,0)
(584,273,0)
(541,502,0)
(54,12,0)
(330,246,0)
(263,313,0)
(487,110,0)
(492,436,0)
(12,54,0)
(448,26,0)
(202,248,0)
(197,173,0)
(76,345,0)
(263,241,0)
(190,607,0)
(233,344,0)
(410,573,0)
(110,96,0)
(536,607,0)
(513,16,0)
(422,219,0)
(84,154,0)
(179,160,0)
(566,504,0)
(552,296,0)
(562,306,0)
(450,85,0)
(594,211,0)
(32,343,0)
(226,607,0)
(295,313,0)
(550,407,0)
(515,248,0)
(311,529,0)
(528,425,0)
(81,204,0)
(582,88,0)
(337,511,0)
(297,466,0)
(167,320,0)
(52,527,0)
(307,124,0)
(532,504,0)
(618,587,0)
(111,243,0)
(492,78,0)
(411,423,0)
(48,205,0)
(95,23,0)
(397,264,0)
(442,574,0)
(595,489,0)
(385,545,0)
(121,9,0)
(250,607,0)
(395,259,0)
(296,552,0)
(439,246,0)
(530,310,0)
(629,550,0)
(479,607,0)
(108,154,0)
(36,623,0)
(88,322,0)
(43,403,0)
(231,412,0)
(405,219,0)
(525,504,0)
(283,431,0)
(271,12,0)
(564,582,0)
(619,216,0)
(519,60,0)
(59,509,0)
(165,302,0)
(366,306,0)
(258,373,0)
(580,98,0)
(604,607,0)
(558,607,0)
(635,98,0)
(205,558,0)
(516,30,0)
(635,496,0)
(121,349,0)
(518,545,0)
(496,477,0)
(203,173,0)
(441,581,0)
(274,26,0)
(455,353,0)
(72,18,0)
(217,253,0)
(569,562,0)
(181,437,0)
(504,421,0)
(334,616,0)
(388,398,0)
(102,628,0)
(336,60,0)
(497,350,0)
(412,293,0)
(389,406,0)
(16,513,0)
(184,55,0)
(566,548,0)
(633,328,0)
(98,464,0)
(605,367,0)
(556,315,0)
(220,353,0)
(374,607,0)
(322,43,0)
(406,389,0)
(572,379,0)
(276,504,0)
(314,577,0)
(331,315,0)
(432,372,0)
(144,309,0)
(444,34,0)
(426,169,0)
(467,55,0)
(75,259,0)
(356,607,0)
(155,69,0)
(615,435,0)
(3,96,0)
(611,205,0)
(162,546,0)
(24,154,0)
(376,424,0)
(623,36,0)
(172,33,0)
(520,607,0)
(246,439,0)
(252,504,0)
(365,222,0)
(317,42,0)
(527,52,0)
(396,607,0)
(342,575,0)
(431,132,0)
(57,495,0)
(338,429,0)
(406,292,0)
(200,110,0)
(291,468,0)
(41,28,0)
(261,541,0)
(62,421,0)
(237,34,0)
(185,574,0)
(555,381,0)
(34,237,0)
(421,62,0)
(103,203,0)
(125,93,0)
(88,582,0)
(586,334,0)
(499,372,0)
(358,276,0)
(471,511,0)
(234,276,0)
(338,63,0)
(160,18,0)
(446,496,0)
(328,633,0)
(543,335,0)
(70,513,0)
(487,476,0)
(509,503,0)
(467,241,0)
(418,623,0)
(68,328,0)
(148,168,0)
(294,529,0)
(537,578,0)
(350,310,0)
(3,573,0)
(13,315,0)
(387,485,0)
(151,82,0)
(58,578,0)
(302,504,0)
(25,439,0)
(458,243,0)
(11,278,0)
(483,614,0)
(482,607,0)
(0,269,0)
(370,105,0)
(598,570,0)
(533,72,0)
(208,624,0)
(180,129,0)
(132,607,0)
(198,155,0)
(402,527,0)
(115,302,0)
(596,252,0)
(485,71,0)
(449,433,0)
(68,0,0)
(394,592,0)
(91,620,0)
(29,574,0)
(187,489,0)
(220,548,0)
(406,196,0)
(145,335,0)
(324,607,0)
(376,57,0)
(135,463,0)
(63,338,0)
(248,515,0)
(357,301,0)
(361,97,0)
(359,302,0)
(82,187,0)
(109,284,0)
(492,99,0)
(470,236,0)
(105,560,0)
(166,569,0)
(1,607,0)
(621,240,0)
(99,220,0)
(240,217,0)
(264,465,0)
(394,525,0)
(223,620,0)
(141,560,0)
(269,0,0)
(577,426,0)
(454,151,0)
(340,65,0)
(124,504,0)
(608,607,0)
(358,187,0)
(266,607,0)
(377,576,0)
(213,502,0)
(2,284,0)
(278,11,0)
(401,167,0)
(494,168,0)
(498,219,0)
(456,162,0)
(347,41,0)
(589,263,0)
(237,575,0)
(182,485,0)
(136,171,0)
(433,509,0)
(88,64,0)
(339,252,0)
(207,218,0)
(18,72,0)
(620,265,0)
(568,566,0)
(334,16,0)
(212,607,0)
(55,467,0)
(570,371,0)
(345,159,0)
(132,431,0)
(242,236,0)
(628,102,0)
(477,496,0)
(260,607,0)
(522,27,0)
(29,575,0)
(298,196,0)
(173,203,0)
(30,352,0)
(161,219,0)
(150,78,0)
(465,264,0)
(524,411,0)
(6,293,0)
(229,320,0)
(33,172,0)
(15,78,0)
(354,437,0)
(635,172,0)
(94,607,0)
(597,562,0)
(579,547,0)
(625,556,0)
(478,217,0)
(489,187,0)
(579,575,0)
(452,607,0)
(566,568,0)
(152,157,0)
(350,548,0)
(255,219,0)
(532,262,0)
(73,300,0)
(581,263,0)
(310,350,0)
(129,607,0)
(51,464,0)
(160,612,0)
(461,48,0)
(302,359,0)
(614,56,0)
(187,607,0)
(474,389,0)
(78,300,0)
(351,157,0)
(501,359,0)
(143,284,0)
(404,607,0)
(583,577,0)
(381,587,0)
(542,235,0)
(99,460,0)
(89,473,0)
(247,343,0)
(321,219,0)
(547,579,0)
(377,539,0)
(319,607,0)
(505,6,0)
(125,53,0)
(400,63,0)
(567,11,0)
(78,196,0)
(57,504,0)
(568,468,0)
(14,328,0)
(300,19,0)
(193,500,0)
(500,193,0)
(9,121,0)
(515,548,0)
(36,488,0)
(102,355,0)
(224,460,0)
(581,504,0)
(573,3,0)
(540,355,0)
(173,241,0)
(72,437,0)
(147,62,0)
(17,419,0)
(154,108,0)
(309,504,0)
(154,504,0)
(472,159,0)
(624,3,0)
(476,96,0)
(560,219,0)
(130,86,0)
(16,334,0)
(178,273,0)
(427,477,0)
(273,178,0)
(138,246,0)
(49,86,0)
(415,30,0)
(570,339,0)
(168,438,0)
(339,570,0)
(196,548,0)
(126,93,0)
(551,548,0)
(63,504,0)
(500,104,0)
(549,236,0)
(28,41,0)
(464,98,0)
(301,75,0)
(232,284,0)
(363,42,0)
(10,55,0)
(268,355,0)
(71,485,0)
(146,529,0)
(599,29,0)
(110,487,0)
(434,296,0)
(128,464,0)
(420,607,0)
(466,600,0)
(22,222,0)
(473,377,0)
(87,470,0)
(119,62,0)
(293,180,0)
(545,69,0)
(227,284,0)
(288,555,0)
(375,303,0)
(631,41,0)
(586,195,0)
(191,616,0)
(21,106,0)
(486,597,0)
(47,284,0)
(476,548,0)
(183,267,0)
(411,517,0)
(236,470,0)
(554,600,0)
(315,556,0)
(526,489,0)
(393,622,0)
(116,49,0)
(369,269,0)
(253,607,0)
(633,65,0)
(520,259,0)
(133,38,0)
(457,65,0)
(100,492,0)
(142,412,0)
(35,600,0)
(430,200,0)
(519,570,0)
(74,252,0)
(355,102,0)
(214,167,0)
(500,539,0)
(123,54,0)
(327,200,0)
(600,284,0)
(376,503,0)
(238,170,0)
(420,267,0)
(620,504,0)
(139,235,0)
(125,28,0)
(612,548,0)
(318,85,0)
(7,580,0)
(560,105,0)
(409,284,0)
(496,635,0)
(67,588,0)
(392,38,0)
(313,263,0)
(57,376,0)
(60,519,0)
(377,473,0)
(4,68,0)
(306,606,0)
(107,504,0)
(556,628,0)
(254,547,0)
(225,276,0)
(45,211,0)
(289,203,0)
(224,504,0)
(602,309,0)
(222,614,0)
(108,476,0)
(403,419,0)
(341,96,0)
(104,504,0)
(282,284,0)
(77,196,0)
(209,68,0)
(39,34,0)
(425,367,0)
(204,424,0)
(504,219,0)
(391,57,0)
(382,219,0)
(285,63,0)
(463,335,0)
(539,615,0)
(164,403,0)
(249,597,0)
(414,12,0)
(228,6,0)
(265,620,0)
(591,607,0)
(612,102,0)
(100,466,0)
(328,287,0)
(23,600,0)
(576,377,0)
(531,99,0)
(169,548,0)
(437,72,0)
(381,555,0)
(557,622,0)
(614,222,0)
(332,314,0)
(390,104,0)
(96,511,0)
(372,292,0)
(338,149,0)
(362,283,0)
(525,394,0)
(360,532,0)
(546,162,0)
(216,309,0)
(617,164,0)
(52,607,0)
(484,435,0)
(93,125,0)
(134,607,0)
(121,345,0)
(416,468,0)
(163,150,0)
(211,112,0)
(565,112,0)
(423,411,0)
(558,205,0)
(363,476,0)
(632,224,0)
(437,504,0)
(609,296,0)
(304,9,0)
(85,588,0)
(40,460,0)
(101,232,0)
(469,532,0)
(413,607,0)
(481,195,0)
(411,524,0)
(236,219,0)
(462,104,0)
(381,364,0)
(571,557,0)
(350,196,0)
(429,338,0)
(326,509,0)
(359,270,0)
(424,376,0)
(194,633,0)
(36,278,0)
(199,445,0)
(590,398,0)
(490,579,0)
(373,572,0)
(535,180,0)
(106,48,0)
(305,477,0)
(459,284,0)
(83,465,0)
(262,579,0)
(348,295,0)
(257,157,0)
(290,148,0)
(281,487,0)
(316,195,0)
(579,351,0)
(259,520,0)
(215,33,0)
(408,178,0)
(329,607,0)
(489,504,0)
(614,483,0)
(42,363,0)
(82,151,0)
(244,77,0)
(383,186,0)
(264,436,0)
(210,476,0)
(221,431,0)
(541,56,0)
(386,106,0)
(601,3,0)
(150,160,0)
(275,295,0)
(92,9,0)
(610,555,0)
(117,367,0)
(277,171,0)
(578,334,0)
(570,519,0)
(77,235,0)
(189,406,0)
(572,373,0)
(187,82,0)
(508,232,0)
(206,607,0)
(270,148,0)
(267,420,0)
(248,624,0)
(343,240,0)
(352,550,0)
(175,124,0)
(222,504,0)
(570,171,0)
(137,11,0)
(86,616,0)
(263,71,0)
(514,219,0)
(262,532,0)
(372,432,0)
(65,633,0)
(129,180,0)
(124,27,0)
(27,124,0)
(230,465,0)
(534,265,0)
(419,134,0)
(66,170,0)
(320,167,0)
(627,525,0)
(593,110,0)
(131,473,0)
(188,284,0)
(579,262,0)
(112,352,0)
(23,219,0)
(440,162,0)
(624,248,0)
(18,160,0)
(353,220,0)
(561,583,0)
(276,358,0)
(0,68,0)
(158,492,0)
(367,425,0)
(547,504,0)
(509,433,0)
(384,443,0)
(529,146,0)
(368,628,0)
(172,635,0)
(26,233,0)
(157,351,0)
(50,198,0)
(150,292,0)
(177,607,0)
(346,432,0)
(399,547,0)
(69,545,0)
(100,186,0)
(544,187,0)
(44,432,0)
(251,18,0)
(159,75,0)
(295,504,0)
(122,60,0)
(443,243,0)
(620,548,0)
(280,461,0)
(279,630,0)
(8,615,0)
(256,219,0)
(407,19,0)
(38,438,0)
(634,224,0)
(476,487,0)
(196,77,0)
(502,541,0)
(245,219,0)
(587,362,0)
(299,421,0)
(312,470,0)
(86,49,0)
(272,433,0)
(553,423,0)
(460,224,0)
(31,375,0)
(492,160,0)
(351,579,0)
(325,525,0)
(171,504,0)
(606,607,0)
(243,443,0)
(613,301,0)
(195,504,0)
(476,108,0)
(334,586,0)
(309,216,0)
(186,61,0)
(3,624,0)
(588,85,0)
(417,353,0)
(97,284,0)
(541,261,0)
(603,582,0)
(507,552,0)
(233,26,0)
(46,513,0)
(626,204,0)
(510,517,0)
(572,270,0)
(120,284,0)
(333,373,0)
(628,368,0)
(521,557,0)
(506,581,0)
(592,394,0)
(394,228,0)
(71,263,0)
(475,151,0)
(523,149,0)
(378,219,0)
(379,572,0)
(563,97,0)
(69,155,0)
(574,29,0)
(278,36,0)
(110,200,0)
(211,196,0)
(493,607,0)
(79,314,0)
(435,303,0)
(37,375,0)
(113,164,0)
(114,362,0)
(127,228,0)
(171,570,0)
(80,78,0)
(98,635,0)
(252,339,0)
(100,150,0)
(466,284,0)
(118,43,0)
(578,504,0)
(96,548,0)
(512,573,0)
(559,607,0)
(149,569,0)
(447,607,0)
(235,77,0)
(538,334,0)
(453,621,0)
(153,146,0)
(176,546,0)
(195,586,0)
(407,550,0)
(424,204,0)
(313,295,1)
(111,134,1)
(78,80,1)
(535,218,1)
(620,223,1)
(85,450,1)
(94,350,1)
(496,446,1)
(510,453,1)
(135,335,1)
(161,493,1)
(463,335,1)
(91,265,1)
(422,498,1)
(25,97,1)
(28,41,1)
(130,49,1)
(500,104,1)
(316,481,1)
(338,63,1)
(387,182,1)
(365,22,1)
(262,532,1)
(59,622,1)
(27,124,1)
(49,116,1)
(195,504,1)
(141,105,1)
(594,45,1)
(484,375,1)
(179,18,1)
(444,125,1)
(297,451,1)
(172,33,1)
(125,93,1)
(334,16,1)
(560,141,1)
(233,26,1)
(570,339,1)
(568,468,1)
(156,480,1)
(94,146,1)
(235,542,1)
(211,594,1)
(573,410,1)
(106,386,1)
(136,519,1)
(442,185,1)
(565,30,1)
(451,439,1)
(223,91,1)
(324,132,1)
(543,145,1)
(359,501,1)
(318,52,1)
(544,358,1)
(462,390,1)
(107,286,1)
(54,123,1)
(296,609,1)
(114,398,1)
(373,258,1)
(251,72,1)
(204,81,1)
(175,376,1)
(350,196,1)
(150,163,1)
(129,394,1)
(160,18,1)
(71,485,1)
(239,118,1)
(521,571,1)
(334,586,1)
(374,279,1)
(7,496,1)
(460,40,1)
(432,346,1)
(489,504,1)
(465,83,1)
(21,611,1)
(183,218,1)
(51,580,1)
(63,285,1)
(202,300,1)
(18,251,1)
(52,377,1)
(485,387,1)
(476,487,1)
(31,37,1)
(244,235,1)
(102,355,1)
(381,555,1)
(30,415,1)
(421,62,1)
(208,3,1)
(441,506,1)
(526,82,1)
(448,155,1)
(3,601,1)
(622,557,1)
(229,167,1)
(440,216,1)
(369,0,1)
(464,128,1)
(579,490,1)
(473,131,1)
(612,102,1)
(281,110,1)
(70,46,1)
(86,130,1)
(553,510,1)
(332,79,1)
(256,286,1)
(175,263,1)
(400,523,1)
(79,583,1)
(433,449,1)
(597,486,1)
(27,522,1)
(234,489,1)
(101,600,1)
(13,331,1)
(132,431,1)
(46,233,1)
(57,495,1)
(173,197,1)
(470,312,1)
(547,504,1)
(377,576,1)
(295,275,1)
(348,581,1)
(570,519,1)
(632,612,1)
(272,59,1)
(424,204,1)
(237,34,1)
(68,4,1)
(195,316,1)
(263,589,1)
(624,208,1)
(579,351,1)
(37,402,1)
(86,49,1)
(0,68,1)
(423,5,1)
(269,0,1)
(338,429,1)
(509,433,1)
(343,247,1)
(451,422,1)
(627,127,1)
(196,77,1)
(537,58,1)
(626,509,1)
(492,99,1)
(166,597,1)
(398,590,1)
(263,581,1)
(307,175,1)
(83,230,1)
(304,92,1)
(439,246,1)
(447,54,1)
(394,525,1)
(161,260,1)
(584,178,1)
(411,423,1)
(325,627,1)
(150,160,1)
(290,494,1)
(418,278,1)
(74,171,1)
(633,65,1)
(192,568,1)
(357,613,1)
(447,334,1)
(276,225,1)
(451,245,1)
(327,430,1)
(456,440,1)
(99,460,1)
(224,504,1)
(476,96,1)
(153,529,1)
(414,420,1)
(450,318,1)
(329,588,1)
(129,180,1)
(202,172,1)
(161,329,1)
(566,504,1)
(330,138,1)
(29,574,1)
(610,288,1)
(519,60,1)
(161,404,1)
(128,51,1)
(530,566,1)
(458,111,1)
(278,11,1)
(20,7,1)
(104,504,1)
(455,417,1)
(556,315,1)
(122,336,1)
(620,265,1)
(370,201,1)
(98,464,1)
(260,273,1)
(392,133,1)
(254,399,1)
(323,207,1)
(355,540,1)
(560,105,1)
(454,129,1)
(360,547,1)
(516,629,1)
(214,29,1)
(18,72,1)
(178,408,1)
(201,552,1)
(273,178,1)
(388,221,1)
(150,78,1)
(57,391,1)
(598,339,1)
(174,443,1)
(472,301,1)
(123,12,1)
(154,84,1)
(350,497,1)
(567,216,1)
(100,186,1)
(23,600,1)
(540,268,1)
(289,546,1)
(541,502,1)
(252,504,1)
(39,444,1)
(579,262,1)
(317,140,1)
(386,21,1)
(155,69,1)
(474,372,1)
(185,588,1)
(42,317,1)
(36,278,1)
(425,367,1)
(375,31,1)
(263,71,1)
(440,36,1)
(218,323,1)
(449,272,1)
(618,114,1)
(631,347,1)
(301,357,1)
(110,200,1)
(50,69,1)
(285,400,1)
(635,496,1)
(334,578,1)
(620,504,1)
(513,70,1)
(72,437,1)
(579,547,1)
(67,85,1)
(265,534,1)
(305,427,1)
(595,526,1)
(625,315,1)
(82,151,1)
(146,153,1)
(236,549,1)
(90,213,1)
(41,631,1)
(487,281,1)
(490,262,1)
(238,635,1)
(258,333,1)
(271,414,1)
(58,16,1)
(33,170,1)
(523,166,1)
(249,366,1)
(320,229,1)
(417,99,1)
(384,243,1)
(430,108,1)
(613,395,1)
(302,115,1)
(518,385,1)
(144,602,1)
(406,196,1)
(252,596,1)
(264,397,1)
(161,374,1)
(124,307,1)
(81,626,1)
(34,39,1)
(561,156,1)
(566,192,1)
(260,269,1)
(480,220,1)
(492,78,1)
(336,622,1)
(359,302,1)
(493,253,1)
(390,8,1)
(467,55,1)
(350,310,1)
(509,326,1)
(520,259,1)
(406,389,1)
(209,328,1)
(353,455,1)
(427,169,1)
(624,3,1)
(410,512,1)
(138,25,1)
(98,580,1)
(443,384,1)
(476,363,1)
(171,504,1)
(154,504,1)
(389,474,1)
(4,209,1)
(187,544,1)
(277,136,1)
(460,224,1)
(220,353,1)
(309,504,1)
(385,425,1)
(532,469,1)
(498,560,1)
(68,328,1)
(118,164,1)
(32,478,1)
(23,95,1)
(581,441,1)
(16,513,1)
(96,511,1)
(161,447,1)
(453,343,1)
(80,15,1)
(391,424,1)
(299,62,1)
(406,189,1)
(89,500,1)
(563,232,1)
(397,465,1)
(54,12,1)
(555,610,1)
(9,304,1)
(339,252,1)
(187,358,1)
(346,44,1)
(481,578,1)
(347,320,1)
(546,176,1)
(334,538,1)
(108,154,1)
(605,86,1)
(411,524,1)
(420,267,1)
(542,139,1)
(552,296,1)
(66,238,1)
(486,249,1)
(295,504,1)
(175,570,1)
(354,181,1)
(161,94,1)
(110,593,1)
(55,184,1)
(623,418,1)
(545,518,1)
(515,248,1)
(331,160,1)
(578,537,1)
(294,463,1)
(366,218,1)
(161,536,1)
(531,460,1)
(279,27,1)
(29,599,1)
(26,274,1)
(169,332,1)
(99,531,1)
(532,504,1)
(547,254,1)
(151,475,1)
(102,628,1)
(402,218,1)
(611,218,1)
(582,603,1)
(137,567,1)
(554,35,1)
(146,529,1)
(505,412,1)
(97,361,1)
(614,222,1)
(142,535,1)
(52,527,1)
(88,64,1)
(525,504,1)
(507,296,1)
(302,504,1)
(574,442,1)
(556,625,1)
(300,73,1)
(57,504,1)
(194,65,1)
(358,276,1)
(268,628,1)
(286,451,1)
(33,215,1)
(222,365,1)
(103,289,1)
(88,582,1)
(253,217,1)
(408,174,1)
(230,443,1)
(606,306,1)
(406,328,1)
(588,85,1)
(133,183,1)
(572,379,1)
(100,492,1)
(297,256,1)
(36,623,1)
(5,553,1)
(198,50,1)
(508,101,1)
(457,14,1)
(329,579,1)
(126,28,1)
(600,554,1)
(614,483,1)
(340,457,1)
(351,157,1)
(40,224,1)
(533,437,1)
(92,76,1)
(65,340,1)
(601,573,1)
(162,456,1)
(274,448,1)
(609,434,1)
(451,161,1)
(1,218,1)
(161,1,1)
(593,200,1)
(189,389,1)
(536,187,1)
(586,195,1)
(420,572,1)
(570,598,1)
(14,273,1)
(376,57,1)
(44,463,1)
(629,172,1)
(571,393,1)
(77,235,1)
(635,98,1)
(62,119,1)
(581,504,1)
(572,373,1)
(170,66,1)
(100,466,1)
(492,160,1)
(164,617,1)
(255,382,1)
(404,558,1)
(11,137,1)
(3,573,1)
(139,298,1)
(309,144,1)
(171,277,1)
(10,173,1)
(264,465,1)
(372,499,1)
(502,90,1)
(12,271,1)
(119,147,1)
(72,533,1)
(121,349,1)
(558,205,1)
(236,470,1)
(275,348,1)
(182,467,1)
(225,234,1)
(134,88,1)
(221,218,1)
(583,561,1)
(257,237,1)
(147,107,1)
(528,367,1)
(320,167,1)
(280,106,1)
(361,563,1)
(63,504,1)
(491,54,1)
(399,351,1)
(17,218,1)
(416,291,1)
(407,211,1)
(496,477,1)
(211,196,1)
(22,428,1)
(104,462,1)
(377,473,1)
(197,203,1)
(140,515,1)
(333,359,1)
(113,17,1)
(215,170,1)
(382,236,1)
(492,158,1)
(499,432,1)
(76,472,1)
(173,203,1)
(588,67,1)
(522,124,1)
(93,126,1)
(570,171,1)
(169,426,1)
(132,381,1)
(512,202,1)
(558,541,1)
(315,13,1)
(187,82,1)
(298,146,1)
(383,439,1)
(497,310,1)
(165,290,1)
(60,122,1)
(8,484,1)
(186,383,1)
(541,261,1)
(158,264,1)
(3,96,1)
(124,504,1)
(160,179,1)
(401,214,1)
(500,193,1)
(578,504,1)
(15,407,1)
(172,635,1)
(125,28,1)
(504,421,1)
(207,23,1)
(428,280,1)
(45,565,1)
(242,470,1)
(415,516,1)
(471,341,1)
(393,546,1)
(628,556,1)
(564,239,1)
(421,299,1)
(511,337,1)
(163,406,1)
(628,368,1)
(247,32,1)
(381,364,1)
(150,99,1)
(248,624,1)
(425,528,1)
(603,564,1)
(276,504,1)
(77,244,1)
(590,388,1)
(269,369,1)
(73,78,1)
(394,592,1)
(538,586,1)
(203,103,1)
(463,135,1)
(243,458,1)
(224,634,1)
(115,165,1)
(520,121,1)
(376,424,1)
(446,477,1)
(222,504,1)
(335,543,1)
(84,24,1)
(580,20,1)
(476,108,1)
(131,89,1)
(596,74,1)
(477,305,1)
(489,595,1)
(46,425,1)
(69,545,1)
(599,574,1)
(525,325,1)
(589,313,1)
(437,504,1)
(602,606,1)
(213,614,1)
(374,27,1)
(326,433,1)
(337,471,1)
(38,392,1)
(566,568,1)
(155,198,1)
(494,38,1)
(100,150,1)
(406,97,1)
(557,521,1)
(549,242,1)
(466,600,1)
(469,360,1)
(157,152,1)
(341,196,1)
(634,632,1)
(200,327,1)
(552,507,1)
(546,162,1)
(407,550,1)
(434,286,1)
(87,286,1)
(444,320,1)
(311,294,1)
(117,605,1)
(246,330,1)
(451,255,1)
(487,110,1)
(363,42,1)
(372,432,1)
(253,411,1)
(145,520,1)
(529,311,1)
(167,401,1)
(24,210,1)
(617,113,1)
(475,454,1)
(367,117,1)
(534,96,1)
(443,243,1)
(232,508,1)
(288,618,1)
(187,489,1)
(506,71,1)
(412,231,1)
(466,297,1)
(105,370,1)
(210,363,1)
(263,313,1)
(127,505,1)
(231,142,1)
(216,309,1)
(184,10,1)
(606,338,1)
(78,196,1)
(116,491,1)
(310,530,1)
(437,354,1)
(152,257,1)
(619,309,1)
(110,96,1)
(633,194,1)
(134,419,1)
(478,218,1)
(176,162,1)
(181,620,1)
(468,416,1)
(328,633,1)
(121,9,1)
(95,504,1)
(161,324,1)
(216,619,1)
(291,476,1)
(312,87,1)
(273,584,1)
(395,218,1)
(507,286,2)
(571,546,2)
(90,218,2)
(542,146,2)
(496,477,2)
(536,218,2)
(248,624,2)
(532,588,2)
(163,463,2)
(384,218,2)
(633,273,2)
(71,546,2)
(200,146,2)
(0,68,2)
(121,218,2)
(316,54,2)
(170,146,2)
(606,218,2)
(34,588,2)
(424,204,2)
(85,218,2)
(411,218,2)
(100,150,2)
(12,218,2)
(215,146,2)
(79,146,2)
(65,273,2)
(150,160,2)
(256,286,2)
(172,146,2)
(400,218,2)
(253,217,2)
(211,172,2)
(104,218,2)
(634,146,2)
(579,351,2)
(237,588,2)
(52,527,2)
(509,622,2)
(18,146,2)
(599,588,2)
(27,218,2)
(141,286,2)
(570,339,2)
(578,54,2)
(404,218,2)
(395,218,2)
(394,592,2)
(29,574,2)
(96,511,2)
(172,635,2)
(512,146,2)
(324,218,2)
(62,286,2)
(294,463,2)
(328,273,2)
(88,218,2)
(365,218,2)
(3,573,2)
(271,218,2)
(50,425,2)
(0,273,2)
(474,463,2)
(606,306,2)
(15,172,2)
(538,54,2)
(129,180,2)
(506,546,2)
(339,252,2)
(427,146,2)
(131,218,2)
(220,353,2)
(534,146,2)
(204,622,2)
(137,216,2)
(311,463,2)
(476,96,2)
(318,218,2)
(58,54,2)
(614,222,2)
(612,102,2)
(476,363,2)
(541,502,2)
(139,146,2)
(239,218,2)
(448,425,2)
(40,146,2)
(626,622,2)
(100,492,2)
(87,286,2)
(175,218,2)
(254,588,2)
(593,146,2)
(229,588,2)
(222,504,2)
(66,146,2)
(127,218,2)
(579,262,2)
(357,218,2)
(88,64,2)
(155,69,2)
(598,622,2)
(10,546,2)
(243,218,2)
(88,582,2)
(552,296,2)
(526,218,2)
(81,622,2)
(176,218,2)
(350,196,2)
(535,218,2)
(242,286,2)
(249,218,2)
(117,54,2)
(118,218,2)
(462,218,2)
(444,588,2)
(82,218,2)
(84,146,2)
(556,315,2)
(265,146,2)
(350,146,2)
(74,622,2)
(161,463,2)
(154,146,2)
(111,218,2)
(372,463,2)
(359,218,2)
(209,273,2)
(432,463,2)
(238,146,2)
(108,146,2)
(466,451,2)
(236,286,2)
(623,216,2)
(425,54,2)
(106,218,2)
(406,389,2)
(341,146,2)
(98,580,2)
(4,273,2)
(296,286,2)
(617,218,2)
(594,172,2)
(41,320,2)
(253,218,2)
(369,273,2)
(449,622,2)
(510,218,2)
(11,216,2)
(463,335,2)
(434,286,2)
(346,463,2)
(469,588,2)
(72,437,2)
(541,261,2)
(83,443,2)
(377,473,2)
(402,218,2)
(154,504,2)
(555,218,2)
(367,54,2)
(625,146,2)
(528,54,2)
(276,218,2)
(460,146,2)
(132,431,2)
(497,146,2)
(622,557,2)
(155,425,2)
(263,581,2)
(458,218,2)
(406,328,2)
(455,146,2)
(213,218,2)
(54,12,2)
(150,463,2)
(276,504,2)
(420,218,2)
(392,218,2)
(451,439,2)
(425,367,2)
(584,443,2)
(620,504,2)
(93,320,2)
(124,218,2)
(290,218,2)
(493,218,2)
(547,588,2)
(568,468,2)
(161,218,2)
(297,286,2)
(225,218,2)
(233,26,2)
(383,439,2)
(628,556,2)
(588,218,2)
(374,218,2)
(520,218,2)
(442,588,2)
(128,146,2)
(187,82,2)
(466,286,2)
(166,218,2)
(130,54,2)
(129,218,2)
(406,196,2)
(610,218,2)
(611,218,2)
(99,460,2)
(381,555,2)
(236,470,2)
(179,146,2)
(172,33,2)
(496,146,2)
(457,273,2)
(581,504,2)
(463,218,2)
(22,218,2)
(470,286,2)
(334,578,2)
(16,513,2)
(489,218,2)
(301,218,2)
(196,146,2)
(278,11,2)
(375,218,2)
(602,218,2)
(27,124,2)
(613,218,2)
(420,267,2)
(620,146,2)
(561,146,2)
(320,588,2)
(549,286,2)
(169,146,2)
(491,54,2)
(545,425,2)
(451,218,2)
(484,218,2)
(464,146,2)
(273,178,2)
(476,487,2)
(142,218,2)
(21,218,2)
(288,218,2)
(416,146,2)
(372,432,2)
(437,146,2)
(358,276,2)
(351,157,2)
(136,622,2)
(339,622,2)
(399,588,2)
(185,588,2)
(618,218,2)
(295,546,2)
(421,286,2)
(174,443,2)
(234,218,2)
(1,218,2)
(467,546,2)
(210,146,2)
(376,57,2)
(91,146,2)
(465,443,2)
(564,218,2)
(582,218,2)
(393,546,2)
(78,172,2)
(156,146,2)
(408,443,2)
(102,628,2)
(23,600,2)
(520,259,2)
(477,146,2)
(247,218,2)
(114,218,2)
(359,501,2)
(389,463,2)
(165,218,2)
(98,464,2)
(377,576,2)
(454,218,2)
(519,60,2)
(331,146,2)
(612,146,2)
(100,466,2)
(590,218,2)
(340,273,2)
(595,218,2)
(439,246,2)
(552,286,2)
(124,504,2)
(146,463,2)
(216,309,2)
(440,218,2)
(351,588,2)
(194,273,2)
(370,286,2)
(39,588,2)
(110,200,2)
(132,218,2)
(566,504,2)
(268,146,2)
(522,218,2)
(566,568,2)
(125,320,2)
(36,623,2)
(269,0,2)
(244,146,2)
(622,546,2)
(285,218,2)
(572,218,2)
(567,216,2)
(359,302,2)
(385,425,2)
(5,218,2)
(151,218,2)
(583,146,2)
(67,218,2)
(633,65,2)
(9,218,2)
(105,286,2)
(252,504,2)
(480,146,2)
(628,368,2)
(414,218,2)
(635,496,2)
(533,146,2)
(348,546,2)
(3,146,2)
(116,54,2)
(71,485,2)
(248,146,2)
(411,524,2)
(150,78,2)
(272,622,2)
(307,218,2)
(494,218,2)
(390,218,2)
(38,218,2)
(103,546,2)
(558,218,2)
(381,218,2)
(160,18,2)
(525,504,2)
(89,218,2)
(216,218,2)
(178,443,2)
(78,196,2)
(110,96,2)
(407,550,2)
(263,71,2)
(358,218,2)
(224,504,2)
(451,463,2)
(422,286,2)
(102,146,2)
(560,105,2)
(146,529,2)
(273,443,2)
(126,320,2)
(275,546,2)
(406,463,2)
(72,146,2)
(169,426,2)
(589,546,2)
(487,110,2)
(541,218,2)
(327,146,2)
(624,146,2)
(596,622,2)
(46,54,2)
(223,146,2)
(433,622,2)
(252,622,2)
(473,218,2)
(313,546,2)
(133,218,2)
(20,146,2)
(264,465,2)
(164,218,2)
(69,545,2)
(277,622,2)
(44,463,2)
(100,186,2)
(363,146,2)
(377,218,2)
(460,224,2)
(546,162,2)
(421,62,2)
(332,146,2)
(77,146,2)
(68,328,2)
(355,146,2)
(207,286,2)
(337,146,2)
(28,41,2)
(335,218,2)
(119,286,2)
(281,146,2)
(347,320,2)
(264,443,2)
(278,216,2)
(350,310,2)
(184,546,2)
(376,424,2)
(603,218,2)
(192,146,2)
(570,171,2)
(354,146,2)
(446,146,2)
(363,42,2)
(565,172,2)
(36,216,2)
(519,622,2)
(515,248,2)
(605,54,2)
(211,196,2)
(274,425,2)
(476,146,2)
(189,463,2)
(485,546,2)
(7,146,2)
(451,443,2)
(529,463,2)
(334,54,2)
(263,313,2)
(472,218,2)
(418,216,2)
(492,99,2)
(619,218,2)
(386,218,2)
(320,167,2)
(113,218,2)
(566,146,2)
(57,504,2)
(401,588,2)
(601,146,2)
(537,54,2)
(257,588,2)
(309,504,2)
(92,218,2)
(629,172,2)
(94,463,2)
(31,218,2)
(525,218,2)
(502,218,2)
(135,218,2)
(579,547,2)
(475,218,2)
(443,218,2)
(202,146,2)
(263,546,2)
(152,588,2)
(221,218,2)
(49,54,2)
(410,146,2)
(417,146,2)
(23,286,2)
(3,96,2)
(70,54,2)
(487,146,2)
(161,443,2)
(220,146,2)
(155,198,2)
(86,49,2)
(305,146,2)
(411,423,2)
(29,588,2)
(398,218,2)
(187,489,2)
(121,349,2)
(160,146,2)
(631,320,2)
(313,295,2)
(16,54,2)
(30,172,2)
(295,504,2)
(110,146,2)
(107,286,2)
(540,146,2)
(17,218,2)
(544,218,2)
(18,72,2)
(96,146,2)
(54,218,2)
(222,218,2)
(453,218,2)
(262,588,2)
(312,286,2)
(376,622,2)
(614,483,2)
(269,273,2)
(309,218,2)
(489,504,2)
(80,172,2)
(570,622,2)
(628,146,2)
(158,443,2)
(181,146,2)
(478,218,2)
(77,235,2)
(338,218,2)
(557,546,2)
(328,633,2)
(397,443,2)
(125,93,2)
(333,218,2)
(95,286,2)
(546,218,2)
(558,205,2)
(515,146,2)
(373,218,2)
(441,546,2)
(60,622,2)
(443,243,2)
(187,218,2)
(55,546,2)
(556,146,2)
(635,98,2)
(235,146,2)
(500,193,2)
(123,218,2)
(218,286,2)
(73,172,2)
(197,546,2)
(424,622,2)
(437,504,2)
(531,146,2)
(69,425,2)
(343,218,2)
(104,504,2)
(573,146,2)
(196,77,2)
(338,429,2)
(353,146,2)
(8,218,2)
(57,622,2)
(499,463,2)
(360,588,2)
(42,146,2)
(387,546,2)
(298,146,2)
(26,425,2)
(230,443,2)
(147,286,2)
(329,218,2)
(32,218,2)
(381,364,2)
(492,160,2)
(187,358,2)
(407,172,2)
(98,146,2)
(237,34,2)
(299,286,2)
(310,146,2)
(68,273,2)
(251,146,2)
(505,218,2)
(291,146,2)
(167,588,2)
(82,151,2)
(99,146,2)
(14,273,2)
(382,286,2)
(509,433,2)
(492,78,2)
(28,320,2)
(57,495,2)
(13,146,2)
(468,146,2)
(183,218,2)
(203,546,2)
(586,195,2)
(498,286,2)
(171,504,2)
(145,218,2)
(521,546,2)
(467,55,2)
(24,146,2)
(516,172,2)
(134,419,2)
(394,218,2)
(258,218,2)
(614,218,2)
(530,146,2)
(523,218,2)
(481,54,2)
(627,218,2)
(323,286,2)
(518,425,2)
(579,588,2)
(513,54,2)
(325,218,2)
(315,146,2)
(134,218,2)
(102,355,2)
(214,588,2)
(447,218,2)
(186,439,2)
(334,586,2)
(122,622,2)
(456,218,2)
(572,373,2)
(632,146,2)
(471,146,2)
(547,504,2)
(280,218,2)
(304,218,2)
(300,172,2)
(144,218,2)
(500,218,2)
(581,546,2)
(492,443,2)
(609,286,2)
(394,525,2)
(486,218,2)
(391,622,2)
(450,218,2)
(171,622,2)
(125,28,2)
(326,622,2)
(150,99,2)
(59,622,2)
(279,27,2)
(504,286,2)
(560,286,2)
(33,170,2)
(504,421,2)
(86,54,2)
(63,218,2)
(490,588,2)
(574,588,2)
(51,146,2)
(428,218,2)
(182,546,2)
(115,218,2)
(624,3,2)
(532,504,2)
(317,146,2)
(33,146,2)
(451,286,2)
(476,108,2)
(201,286,2)
(153,463,2)
(286,451,2)
(588,85,2)
(388,218,2)
(121,9,2)
(580,146,2)
(289,546,2)
(302,504,2)
(140,146,2)
(511,146,2)
(297,451,2)
(233,425,2)
(415,172,2)
(173,203,2)
(568,146,2)
(338,63,2)
(586,54,2)
(334,16,2)
(423,218,2)
(412,218,2)
(262,532,2)
(302,218,2)
(406,97,2)
(620,265,2)
(37,218,2)
(635,146,2)
(231,218,2)
(198,425,2)
(157,588,2)
(255,286,2)
(76,218,2)
(224,146,2)
(162,218,2)
(366,218,2)
(578,504,2)
(500,104,2)
(597,218,2)
(195,54,2)
(63,504,2)
(52,218,2)
(543,218,2)
(570,519,2)
(208,146,2)
(195,504,2)
(173,546,2)
(45,172,2)
(430,146,2)
(553,218,2)
(336,622,2)
(36,278,2)
(466,600,2)
(108,154,2)
(260,443,2)
(572,379,2)
-----------------------------------
(0,&(block->pending)
(1,break;)
(2,which)
(3,mca_btl_portals_module.portals_reg[tag])
(4,pending)
(5,hdr_data)
(6,)
(7,ev)
(8,frag)
(9,ev.hdr_data)
(10,ev)
(11,mca_btl_portals_module.portals_outstanding_sends)
(12,ev.ni_fail_type)
(13,md)
(14,block)
(15,block)
(16,&mca_btl_portals_module.super)
(17,900)
(18,frag->segments[0].seg_addr)
(19,)
(20,offset)
(21,mca_btl_portals_component)
(22,frag)
(23,num_progressed++)
(24,frag)
(25,0)
(26,ev.md_handle)
(27,frag->type == mca_btl_portals_frag_type_send)
(28,&mca_btl_portals_module.portals_outstanding_sends)
(29,opal_output(mca_btl_portals_component.portals_output,\n\\n                                "Failure to start send event\\n")
(30,mca_btl_portals_component.portals_output)
(31,portals_output)
(32,mca_btl_portals_component)
(33,ev.md.max_size)
(34,ev.md_handle)
(35,num_progressed)
(36,OPAL_THREAD_ADD32(&mca_btl_portals_module.portals_outstanding_sends,\n\\n                                      -1)
(37,mca_btl_portals_component)
(38,mca_btl_portals_component.portals_output)
(39,md_handle)
(40,0)
(41,mca_btl_portals_module.portals_outstanding_sends)
(42,mca_btl_portals_module.super)
(43,)
(44,mca_btl_portals_component)
(45,block)
(46,mca_btl_portals_module)
(47,done:)
(48,)
(49,mca_btl_portals_component.portals_output)
(50,1)
(51,ev)
(52,OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,\n\\n                                     "PTL_EVENT_SEND_START for 0x%x, %d, %d",\n\\n                                     frag, (int)
(53,)
(54,ev.ni_fail_type != PTL_NI_OK)
(55,ev.md_handle)
(56,)
(57,(opal_list_item_t*)
(58,frag)
(59,50)
(60,mca_btl_portals_module.super)
(61,)
(62,ev.md)
(63,frag->type)
(64,int)
(65,ev.md)
(66,md)
(67,PTL_NI_OK)
(68,block->pending)
(69,&mca_btl_portals_module.portals_outstanding_sends)
(70,super)
(71,&mca_btl_portals_module.super)
(72,frag->segments[0])
(73,true)
(74,frag)
(75,)
(76,frag)
(77,ev.md.user_ptr)
(78,block->full)
(79,"received send fragment %x")
(80,full)
(81,portals_queued_sends)
(82,&mca_btl_portals_module.super)
(83,portals_output)
(84,base)
(85,ev.ni_fail_type)
(86,opal_output(mca_btl_portals_component.portals_output,\n\\n                                "Failure to end send event\\n")
(87,mca_btl_portals_component)
(88,(int)
(89,ev)
(90,hdr_data)
(91,frag)
(92,ev)
(93,-1)
(94,break;)
(95,num_progressed)
(96,tag = ev.hdr_data)
(97,*block = NULL)
(98,ev.offset + ev.mlength)
(99,frag->segments[0].seg_len)
(100,RET)
(101,frag)
(102,((char*)
(103,portals_output)
(104,frag->type)
(105,mca_btl_portals_component.portals_output)
(106,mca_btl_portals_component.portals_output)
(107,frag)
(108,&frag->base)
(109,while (true)
(110,mca_btl_portals_module.portals_reg[tag])
(111,ev)
(112,)
(113,mca_btl_portals_component)
(114,"PTL_EVENT_GET_START for 0x%x, %d")
(115,type)
(116,portals_output)
(117,hdr_data)
(118,"PTL_EVENT_PUT_START for 0x%x, %d")
(119,md)
(120,ev)
(121,(int)
(122,super)
(123,PTL_NI_OK)
(124,frag->type)
(125,OPAL_THREAD_ADD32(&mca_btl_portals_module.portals_outstanding_sends,\n\\n                                          -1)
(126,1)
(127,frag)
(128,mlength)
(129,OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,\n\\n                                     "PTL_EVENT_REPLY_END for 0x%x, %d",\n\\n                                     frag, (int)
(130,"Failure to end send event\\n")
(131,hdr_data)
(132,OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,\n\\n                                     "PTL_EVENT_GET_START for 0x%x, %d",\n\\n                                     frag, (int)
(133,mca_btl_portals_component)
(134,OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,\n\\n                                     "PTL_EVENT_PUT_START for 0x%x, %d",\n\\n                                     frag, (int)
(135,PTL_NI_OK)
(136,frag)
(137,portals_outstanding_sends)
(138,mca_btl_portals_module)
(139,ev)
(140,mca_btl_portals_module)
(141,"WARNING: Giving up in dispair")
(142,mca_btl_portals_component)
(143,ret)
(144,type)
(145,ev)
(146,ev.hdr_data < MCA_BTL_TAG_MAX)
(147,ev)
(148,)
(149,)
(150,return OMPI_ERROR;)
(151,mca_btl_portals_module.super)
(152,super)
(153,MCA_BTL_TAG_MAX)
(154,frag->base)
(155,OPAL_THREAD_ADD32(&mca_btl_portals_module.portals_outstanding_sends,\n\\n                                          -1)
(156,mca_btl_portals_component)
(157,mca_btl_portals_module.super)
(158,OMPI_ERROR)
(159,)
(160,frag->segments[0].seg_addr.pval)
(161,break;)
(162,ev.ni_fail_type)
(163,OMPI_ERROR)
(164,mca_btl_portals_component.portals_output)
(165,frag)
(166,"PTL_EVENT_ACK for 0x%x, %d")
(167,ev.hdr_data)
(168,)
(169,OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,\n\\n                                         "received send fragment %x", frag)
(170,ev.md)
(171,frag->endpoint)
(172,ev.md.length - (ev.offset + ev.mlength)
(173,opal_output(mca_btl_portals_component.portals_output,\n\\n                                "Failure to ack event\\n")
(174,ev)
(175,frag)
(176,PTL_NI_OK)
(177,if (frag->type == mca_btl_portals_frag_type_send)
(178,ev.hdr_data)
(179,pval)
(180,)
(181,frag)
(182,mca_btl_portals_module)
(183,90)
(184,md_handle)
(185,mca_btl_portals_component)
(186,return 0;)
(187,frag->base.des_cbfunc(&mca_btl_portals_module.super,\n\\n                                      frag->endpoint,\n\\n                                      &frag->base,\n\\n                                      OMPI_SUCCESS)
(188,frag)
(189,block)
(190,if (ev.ni_fail_type != PTL_NI_OK)
(191,if (ev.hdr_data < MCA_BTL_TAG_MAX)
(192,frag)
(193,int)
(194,user_ptr)
(195,frag->base)
(196,block = ev.md.user_ptr)
(197,"Failure to ack event\\n")
(198,-1)
(199,switch (ret)
(200,mca_btl_portals_module.portals_reg)
(201,mca_btl_portals_component)
(202,NULL)
(203,mca_btl_portals_component.portals_output)
(204,mca_btl_portals_module.portals_queued_sends)
(205,)
(206,case PTL_EVENT_REPLY_END:)
(207,ev)
(208,cbfunc)
(209,block)
(210,tag)
(211,block->start)
(212,if (ev.hdr_data < MCA_BTL_TAG_MAX)
(213,ev)
(214,ev)
(215,max_size)
(216,frag->type == mca_btl_portals_frag_type_send)
(217,)
(218,ev.type)
(219,)
(220,frag->segments[0].seg_len = ev.mlength)
(221,900)
(222,frag->type)
(223,ret)
(224,frag->segments)
(225,base)
(226,case PTL_EVENT_ACK:)
(227,if (0 == mca_btl_portals_module.portals_num_procs)
(228,)
(229,MCA_BTL_TAG_MAX)
(230,mca_btl_portals_component)
(231,portals_output)
(232,*frag = NULL)
(233,PtlMDUnlink(ev.md_handle)
(234,frag)
(235,ev.md)
(236,opal_output(mca_btl_portals_component.portals_output,\n\\n                        "WARNING: Error in PtlEQPoll (%d)
(237,PtlMDUnlink(ev.md_handle)
(238,ev)
(239,frag)
(240,)
(241,)
(242,"WARNING: Error in PtlEQPoll (%d)
(243,ev.ni_fail_type)
(244,user_ptr)
(245,break;)
(246,mca_btl_portals_module.portals_num_procs)
(247,portals_output)
(248,NULL != mca_btl_portals_module.portals_reg[tag].cbfunc)
(249,mca_btl_portals_component)
(250,if (ev.ni_fail_type != PTL_NI_OK)
(251,seg_addr)
(252,frag->base)
(253,OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,\n\\n                                     "PTL_EVENT_GET_END for 0x%x, %d",\n\\n                                     frag, (int)
(254,endpoint)
(255,break;)
(256,goto done;)
(257,mca_btl_portals_module)
(258,hdr_data)
(259,)
(260,break;)
(261,int)
(262,&frag->base)
(263,frag->base.des_cbfunc(&mca_btl_portals_module.super,\n\\n                                          frag->endpoint,\n\\n                                          &frag->base,\n\\n                                          OMPI_ERROR)
(264,opal_output(mca_btl_portals_component.portals_output,\n\\n                                "Failure to start event\\n")
(265,&mca_btl_portals_module)
(266,if (ev.ni_fail_type != PTL_NI_OK)
(267,)
(268,ev)
(269,OPAL_THREAD_ADD32(&(block->pending)
(270,)
(271,ni_fail_type)
(272,mca_btl_portals_component)
(273,ev.hdr_data < MCA_BTL_TAG_MAX)
(274,md_handle)
(275,base)
(276,frag->base)
(277,endpoint)
(278,&mca_btl_portals_module.portals_outstanding_sends)
(279,MCA_BTL_PORTALS_PROGRESS_QUEUED_SENDS()
(280,"PTL_EVENT_REPLY_START for 0x%x, %d, %d")
(281,cbdata)
(282,tag)
(283,)
(284,)
(285,type)
(286,ret)
(287,)
(288,ev)
(289,mca_btl_portals_component)
(290,frag)
(291,mca_btl_portals_module)
(292,)
(293,)
(294,ev)
(295,frag->base)
(296,mca_btl_portals_component.portals_output)
(297,num_progressed)
(298,block)
(299,user_ptr)
(300,block->full = true)
(301,mca_btl_portals_component.portals_output)
(302,frag->type)
(303,)
(304,hdr_data)
(305,md)
(306,)
(307,type)
(308,case PTL_OK:)
(309,frag->type)
(310,&mca_btl_portals_module)
(311,hdr_data)
(312,portals_output)
(313,&frag->base)
(314,)
(315,ev.md)
(316,base)
(317,super)
(318,ev)
(319,if (ev.ni_fail_type != PTL_NI_OK)
(320,ev.hdr_data < MCA_BTL_TAG_MAX)
(321,case PTL_EQ_DROPPED:)
(322,)
(323,type)
(324,break;)
(325,type)
(326,"message was dropped.  Adding to front of queue list")
(327,portals_reg)
(328,block = ev.md.user_ptr)
(329,break;)
(330,portals_num_procs)
(331,ev)
(332,frag)
(333,ev)
(334,frag->base.des_cbfunc(&mca_btl_portals_module.super,\n\\n                                          frag->endpoint,\n\\n                                          &frag->base,\n\\n                                          OMPI_ERROR)
(335,ev.ni_fail_type)
(336,mca_btl_portals_module)
(337,hdr_data)
(338,(int)
(339,&frag->base)
(340,md)
(341,tag)
(342,if (ev.hdr_data < MCA_BTL_TAG_MAX)
(343,mca_btl_portals_component.portals_output)
(344,)
(345,)
(346,portals_output)
(347,mca_btl_portals_module)
(348,frag)
(349,int)
(350,mca_btl_portals_return_block_part(&mca_btl_portals_module, block)
(351,&mca_btl_portals_module.super)
(352,)
(353,ev.mlength)
(354,segments)
(355,ev.offset)
(356,case PTL_EVENT_GET_START:)
(357,portals_output)
(358,&frag->base)
(359,(int)
(360,frag)
(361,NULL)
(362,)
(363,&mca_btl_portals_module.super)
(364,int)
(365,type)
(366,90)
(367,ev.hdr_data)
(368,char*)
(369,1)
(370,portals_output)
(371,)
(372,opal_output(mca_btl_portals_component.portals_output,\n\\n                                "Failure to end event\\n")
(373,ev.hdr_data)
(374,break;)
(375,mca_btl_portals_component.portals_output)
(376,opal_list_prepend(&(mca_btl_portals_module.portals_queued_sends)
(377,(int)
(378,switch (ev.type)
(379,int)
(380,if (ev.hdr_data < MCA_BTL_TAG_MAX)
(381,(int)
(382,abort()
(383,0)
(384,PTL_NI_OK)
(385,mca_btl_portals_module)
(386,portals_output)
(387,super)
(388,mca_btl_portals_component)
(389,&mca_btl_portals_module)
(390,frag)
(391,frag)
(392,portals_output)
(393,0)
(394,(int)
(395,900)
(396,default:)
(397,"Failure to start event\\n")
(398,mca_btl_portals_component.portals_output)
(399,frag)
(400,frag)
(401,hdr_data)
(402,900)
(403,)
(404,break;)
(405,default:)
(406,mca_btl_portals_return_block_part(&mca_btl_portals_module,\n\\n                                                      block)
(407,OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,\n\\n                                             "marking block 0x%x as full", block->start)
(408,hdr_data)
(409,block)
(410,portals_reg)
(411,(int)
(412,mca_btl_portals_component.portals_output)
(413,case PTL_EVENT_SEND_START:)
(414,ev)
(415,portals_output)
(416,super)
(417,ev)
(418,1)
(419,)
(420,OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,\n\\n                                     "PTL_EVENT_SEND_END for 0x%x, %d, %d",\n\\n                                     frag, (int)
(421,ev.md.user_ptr)
(422,break;)
(423,ev.hdr_data)
(424,&(mca_btl_portals_module.portals_queued_sends)
(425,ev.hdr_data < MCA_BTL_TAG_MAX)
(426,)
(427,ev)
(428,frag)
(429,int)
(430,mca_btl_portals_module)
(431,)
(432,mca_btl_portals_component.portals_output)
(433,mca_btl_portals_component.portals_output)
(434,mca_btl_portals_component)
(435,)
(436,)
(437,frag->segments)
(438,)
(439,0 == mca_btl_portals_module.portals_num_procs)
(440,ev)
(441,endpoint)
(442,portals_output)
(443,ev.ni_fail_type != PTL_NI_OK)
(444,ev)
(445,)
(446,length)
(447,break;)
(448,ev)
(449,portals_output)
(450,ni_fail_type)
(451,true)
(452,case PTL_EVENT_PUT_START:)
(453,"PTL_EVENT_GET_END for 0x%x, %d")
(454,mca_btl_portals_module)
(455,mlength)
(456,ni_fail_type)
(457,ev)
(458,ni_fail_type)
(459,num_progressed)
(460,frag->segments[0])
(461,)
(462,type)
(463,ev.ni_fail_type != PTL_NI_OK)
(464,ev.mlength)
(465,mca_btl_portals_component.portals_output)
(466,return num_progressed;)
(467,PtlMDUnlink(ev.md_handle)
(468,mca_btl_portals_module.super)
(469,base)
(470,mca_btl_portals_component.portals_output)
(471,ev)
(472,"PTL_EVENT_PUT_END for 0x%x, %d")
(473,ev.hdr_data)
(474,mca_btl_portals_module)
(475,super)
(476,mca_btl_portals_module.portals_reg[tag].cbfunc(\n\\n                                             &mca_btl_portals_module.super,\n\\n                                             tag,\n\\n                                             &frag->base,\n\\n                                             mca_btl_portals_module.portals_reg[tag].cbdata)
(477,ev.md)
(478,900)
(479,case PTL_EVENT_REPLY_START:)
(480,90)
(481,frag)
(482,if (ev.ni_fail_type != PTL_NI_OK)
(483,int)
(484,"PTL_EVENT_SEND_START for 0x%x, %d, %d")
(485,mca_btl_portals_module.super)
(486,portals_output)
(487,mca_btl_portals_module.portals_reg[tag].cbdata)
(488,)
(489,frag->endpoint)
(490,OMPI_ERROR)
(491,mca_btl_portals_component)
(492,return OMPI_ERROR;)
(493,break;)
(494,"PTL_EVENT_SEND_END for 0x%x, %d, %d")
(495,opal_list_item_t*)
(496,ev.md.length)
(497,block)
(498,abort()
(499,"Failure to end event\\n")
(500,(int)
(501,int)
(502,ev.hdr_data)
(503,)
(504,frag = ev.md.user_ptr)
(505,"PTL_EVENT_REPLY_END for 0x%x, %d")
(506,frag)
(507,"WARNING: EQ events dropped.  Too many messages pending.")
(508,NULL)
(509,opal_output_verbose(50,\n\\n                                        mca_btl_portals_component.portals_output,\n\\n                                        "message was dropped.  Adding to front of queue list")
(510,frag)
(511,ev.hdr_data)
(512,mca_btl_portals_module)
(513,mca_btl_portals_module.super)
(514,case PTL_EQ_EMPTY:)
(515,assert(NULL != mca_btl_portals_module.portals_reg[tag].cbfunc)
(516,mca_btl_portals_component)
(517,)
(518,portals_outstanding_sends)
(519,&mca_btl_portals_module.super)
(520,OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,\n\\n                                     "PTL_EVENT_PUT_END for 0x%x, %d",\n\\n                                     frag, (int)
(521,mlength)
(522,mca_btl_portals_frag_type_send)
(523,frag)
(524,int)
(525,frag->type)
(526,frag)
(527,)
(528,MCA_BTL_TAG_MAX)
(529,ev.hdr_data)
(530,mca_btl_portals_module)
(531,seg_len)
(532,frag->base)
(533,0)
(534,mca_btl_portals_module)
(535,90)
(536,break;)
(537,endpoint)
(538,OMPI_ERROR)
(539,)
(540,offset)
(541,(int)
(542,md)
(543,ni_fail_type)
(544,OMPI_SUCCESS)
(545,mca_btl_portals_module.portals_outstanding_sends)
(546,ev.ni_fail_type != PTL_NI_OK)
(547,frag->endpoint)
(548,)
(549,ret)
(550,)
(551,if (ev.md.length - (ev.offset + ev.mlength)
(552,opal_output(mca_btl_portals_component.portals_output,\n\\n                        "WARNING: EQ events dropped.  Too many messages pending.")
(553,ev)
(554,0)
(555,ev.hdr_data)
(556,ev.md.start)
(557,ev.mlength)
(558,OPAL_OUTPUT_VERBOSE((900, mca_btl_portals_component.portals_output,\n\\n                                     "PTL_EVENT_REPLY_START for 0x%x, %d, %d",\n\\n                                     frag, (int)
(559,case PTL_EVENT_GET_END:)
(560,opal_output(mca_btl_portals_component.portals_output,\n\\n                        "WARNING: Giving up in dispair")
(561,portals_output)
(562,)
(563,block)
(564,ev)
(565,"marking block 0x%x as full")
(566,OMPI_BTL_PORTALS_FRAG_RETURN_RECV(&mca_btl_portals_module.super,\n\\n                                                      frag)
(567,mca_btl_portals_module)
(568,&mca_btl_portals_module.super)
(569,)
(570,frag->base.des_cbfunc(&mca_btl_portals_module.super,\n\\n                                          frag->endpoint,\n\\n                                          &frag->base,\n\\n                                          OMPI_SUCCESS)
(571,ev)
(572,(int)
(573,mca_btl_portals_module.portals_reg)
(574,mca_btl_portals_component.portals_output)
(575,)
(576,int)
(577,)
(578,frag->endpoint)
(579,frag->base.des_cbfunc(&mca_btl_portals_module.super,\n\\n                                          frag->endpoint,\n\\n                                          &frag->base,\n\\n                                          OMPI_ERROR)
(580,ev.offset)
(581,frag->endpoint)
(582,ev.hdr_data)
(583,mca_btl_portals_component.portals_output)
(584,MCA_BTL_TAG_MAX)
(585,)
(586,&frag->base)
(587,)
(588,ev.ni_fail_type != PTL_NI_OK)
(589,OMPI_ERROR)
(590,portals_output)
(591,case PTL_EVENT_SEND_END:)
(592,int)
(593,tag)
(594,start)
(595,endpoint)
(596,base)
(597,mca_btl_portals_component.portals_output)
(598,OMPI_SUCCESS)
(599,"Failure to start send event\\n")
(600,num_progressed = 0)
(601,tag)
(602,frag)
(603,hdr_data)
(604,case PTL_EVENT_PUT_END:)
(605,ev)
(606,OPAL_OUTPUT_VERBOSE((90, mca_btl_portals_component.portals_output,\n\\n                                     "PTL_EVENT_ACK for 0x%x, %d",\n\\n                                     frag, (int)
(607,)
(608,if (frag->type == mca_btl_portals_frag_type_send)
(609,portals_output)
(610,hdr_data)
(611,900)
(612,frag->segments[0].seg_addr.pval = (((char*)
(613,mca_btl_portals_component)
(614,(int)
(615,)
(616,)
(617,portals_output)
(618,frag)
(619,mca_btl_portals_frag_type_send)
(620,OMPI_BTL_PORTALS_FRAG_ALLOC_RECV(&mca_btl_portals_module, frag, ret)
(621,)
(622,0 == ev.mlength)
(623,-1)
(624,mca_btl_portals_module.portals_reg[tag].cbfunc)
(625,start)
(626,mca_btl_portals_module)
(627,frag)
(628,(char*)
(629,90)
(630,)
(631,portals_outstanding_sends)
(632,frag)
(633,ev.md.user_ptr)
(634,segments)
(635,ev.md.length - (ev.offset + ev.mlength)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^