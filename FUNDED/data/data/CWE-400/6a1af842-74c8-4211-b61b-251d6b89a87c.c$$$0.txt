-----label-----
1
-----code-----
void
kpsendsig(struct lwp *l, const ksiginfo_t *ksi, const sigset_t *mask)
{
	struct proc *p = l->l_proc;
	struct lwp *le, *li;
	siginfo_t *si;
	int f;

	if (p->p_flag & P_SA) {

		/* XXXUPSXXX What if not on sa_vp ? */

		f = l->l_flag & L_SA;
		l->l_flag &= ~L_SA;
		si = pool_get(&siginfo_pool, PR_WAITOK);
		si->_info = ksi->ksi_info;
		le = li = NULL;
		if (KSI_TRAP_P(ksi))
			le = l;
		else
			li = l;

		sa_upcall(l, SA_UPCALL_SIGNAL | SA_UPCALL_DEFER, le, li,
			    sizeof(siginfo_t), si);
		l->l_flag |= f;
		return;
	}

	(*p->p_emul->e_sendsig)(ksi, mask);
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
3,7
5,6
5,7
6,7
8,9
8,10
11,12
11,13
12,13
14,15
14,16
17,18
17,19
18,19
20,21
20,22
23,24
23,25
23,26
23,27
23,28
23,29
24,25
25,26
25,27
26,27
28,29
28,30
28,31
31,32
32,33
32,34
33,34
36,37
37,38
37,39
37,40
38,39
40,41
40,42
43,44
43,45
46,47
47,48
47,49
48,49
50,51
50,52
53,54
54,55
54,56
56,57
58,59
58,60
59,60
59,61
60,61
60,62
61,62
64,65
66,67
66,68
66,69
66,70
66,71
66,72
66,73
66,74
66,75
67,68
68,69
68,70
69,70
71,72
71,73
72,73
72,74
73,74
76,77
78,79
79,80
79,81
80,81
80,82
81,82
84,85
85,86
87,88
88,89
88,90
89,90
91,92
91,93
91,94
92,93
94,95
95,96
97,98
99,100
100,101
100,102
101,102
101,103
102,103
105,106
105,107
106,107
109,110
110,111
110,112
111,112
113,114
113,115
114,115
116,117
118,119
118,120
118,121
119,120
119,121
120,121
122,123
124,125
125,126
125,127
126,127
128,129
130,131
131,132
131,133
132,133
134,135
136,137
137,138
137,139
137,140
137,141
137,142
137,143
137,144
138,139
140,141
142,143
142,144
143,144
145,146
147,148
149,150
151,152
152,153
152,154
153,154
156,157
158,159
159,160
159,161
160,161
160,162
161,162
164,165
167,168
168,169
168,170
168,171
169,170
170,171
171,172
171,173
172,173
172,174
173,174
177,178
179,180
-----nextToken-----
2,4,7,9,10,13,15,16,19,21,22,27,29,30,34,35,39,41,42,44,45,49,51,52,55,57,62,63,65,70,74,75,77,82,83,86,90,93,96,98,103,104,107,108,112,115,117,121,123,127,129,133,135,139,141,144,146,148,150,154,155,157,162,163,165,166,174,175,176,178,180
-----computeFrom-----
59,60
59,61
68,69
68,70
71,72
71,73
79,80
79,81
88,89
88,90
100,101
100,102
110,111
110,112
113,114
113,115
125,126
125,127
131,132
131,133
142,143
142,144
159,160
159,161
-----guardedBy-----
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ReturnStatement;ExpressionStatement;FunctionCallExpression;UnaryExpression;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;IdExpression;Name;
-----ast_node-----
voidkpsendsig(struct lwp *l, const ksiginfo_t *ksi, const sigset_t *mask){	struct proc *p = l->l_proc;	struct lwp *le, *li;	siginfo_t *si;	int f;	if (p->p_flag & P_SA) {		/* XXXUPSXXX What if not on sa_vp ? */		f = l->l_flag & L_SA;		l->l_flag &= ~L_SA;		si = pool_get(&siginfo_pool, PR_WAITOK);		si->_info = ksi->ksi_info;		le = li = NULL;		if (KSI_TRAP_P(ksi))			le = l;		else			li = l;		sa_upcall(l, SA_UPCALL_SIGNAL | SA_UPCALL_DEFER, le, li,			    sizeof(siginfo_t), si);		l->l_flag |= f;		return;	}	(*p->p_emul->e_sendsig)(ksi, mask);}
void
kpsendsig(struct lwp *l, const ksiginfo_t *ksi, const sigset_t *mask)
kpsendsig
struct lwp *l
struct lwp
lwp
*l
*
l
const ksiginfo_t *ksi
const ksiginfo_t
ksiginfo_t
*ksi
*
ksi
const sigset_t *mask
const sigset_t
sigset_t
*mask
*
mask
{	struct proc *p = l->l_proc;	struct lwp *le, *li;	siginfo_t *si;	int f;	if (p->p_flag & P_SA) {		/* XXXUPSXXX What if not on sa_vp ? */		f = l->l_flag & L_SA;		l->l_flag &= ~L_SA;		si = pool_get(&siginfo_pool, PR_WAITOK);		si->_info = ksi->ksi_info;		le = li = NULL;		if (KSI_TRAP_P(ksi))			le = l;		else			li = l;		sa_upcall(l, SA_UPCALL_SIGNAL | SA_UPCALL_DEFER, le, li,			    sizeof(siginfo_t), si);		l->l_flag |= f;		return;	}	(*p->p_emul->e_sendsig)(ksi, mask);}
struct proc *p = l->l_proc;
struct proc *p = l->l_proc;
struct proc
proc
*p = l->l_proc
*
p
= l->l_proc
l->l_proc
l
l
l_proc
struct lwp *le, *li;
struct lwp *le, *li;
struct lwp
lwp
*le
*
le
*li
*
li
siginfo_t *si;
siginfo_t *si;
siginfo_t
siginfo_t
*si
*
si
int f;
int f;
int
f
f
if (p->p_flag & P_SA) {		/* XXXUPSXXX What if not on sa_vp ? */		f = l->l_flag & L_SA;		l->l_flag &= ~L_SA;		si = pool_get(&siginfo_pool, PR_WAITOK);		si->_info = ksi->ksi_info;		le = li = NULL;		if (KSI_TRAP_P(ksi))			le = l;		else			li = l;		sa_upcall(l, SA_UPCALL_SIGNAL | SA_UPCALL_DEFER, le, li,			    sizeof(siginfo_t), si);		l->l_flag |= f;		return;	}
p->p_flag & P_SA
p->p_flag
p
p
p_flag
P_SA
P_SA
{		/* XXXUPSXXX What if not on sa_vp ? */		f = l->l_flag & L_SA;		l->l_flag &= ~L_SA;		si = pool_get(&siginfo_pool, PR_WAITOK);		si->_info = ksi->ksi_info;		le = li = NULL;		if (KSI_TRAP_P(ksi))			le = l;		else			li = l;		sa_upcall(l, SA_UPCALL_SIGNAL | SA_UPCALL_DEFER, le, li,			    sizeof(siginfo_t), si);		l->l_flag |= f;		return;	}
f = l->l_flag & L_SA;
f = l->l_flag & L_SA
f
f
l->l_flag & L_SA
l->l_flag
l
l
l_flag
L_SA
L_SA
l->l_flag &= ~L_SA;
l->l_flag &= ~L_SA
l->l_flag
l
l
l_flag
~L_SA
L_SA
L_SA
si = pool_get(&siginfo_pool, PR_WAITOK);
si = pool_get(&siginfo_pool, PR_WAITOK)
si
si
pool_get(&siginfo_pool, PR_WAITOK)
pool_get
pool_get
&siginfo_pool
siginfo_pool
siginfo_pool
PR_WAITOK
PR_WAITOK
si->_info = ksi->ksi_info;
si->_info = ksi->ksi_info
si->_info
si
si
_info
ksi->ksi_info
ksi
ksi
ksi_info
le = li = NULL;
le = li = NULL
le
le
li = NULL
li
li
NULL
NULL
if (KSI_TRAP_P(ksi))			le = l;		else			li = l;
KSI_TRAP_P(ksi)
KSI_TRAP_P
KSI_TRAP_P
ksi
ksi
le = l;
le = l
le
le
l
l
li = l;
li = l
li
li
l
l
sa_upcall(l, SA_UPCALL_SIGNAL | SA_UPCALL_DEFER, le, li,			    sizeof(siginfo_t), si);
sa_upcall(l, SA_UPCALL_SIGNAL | SA_UPCALL_DEFER, le, li,			    sizeof(siginfo_t), si)
sa_upcall
sa_upcall
l
l
SA_UPCALL_SIGNAL | SA_UPCALL_DEFER
SA_UPCALL_SIGNAL
SA_UPCALL_SIGNAL
SA_UPCALL_DEFER
SA_UPCALL_DEFER
le
le
li
li
sizeof(siginfo_t)
siginfo_t
siginfo_t
siginfo_t

si
si
l->l_flag |= f;
l->l_flag |= f
l->l_flag
l
l
l_flag
f
f
return;
(*p->p_emul->e_sendsig)(ksi, mask);
(*p->p_emul->e_sendsig)(ksi, mask)
(*p->p_emul->e_sendsig)
*p->p_emul->e_sendsig
p->p_emul->e_sendsig
p->p_emul
p
p
p_emul
e_sendsig
ksi
ksi
mask
mask
-----joern-----
(22,11,0)
(61,38,0)
(6,66,0)
(5,17,0)
(55,21,0)
(71,33,0)
(14,49,0)
(54,49,0)
(48,33,0)
(9,38,0)
(64,21,0)
(33,71,0)
(66,65,0)
(4,9,0)
(50,64,0)
(32,29,0)
(43,32,0)
(57,29,0)
(47,34,0)
(13,9,0)
(17,21,0)
(9,54,0)
(78,8,0)
(23,17,0)
(63,53,0)
(66,29,0)
(31,23,0)
(77,8,0)
(42,59,0)
(73,13,0)
(53,63,0)
(9,21,0)
(9,55,0)
(20,34,0)
(58,32,0)
(24,53,0)
(67,74,0)
(59,38,0)
(66,36,0)
(75,52,0)
(78,17,0)
(8,28,0)
(62,54,0)
(30,43,0)
(37,29,0)
(63,38,0)
(76,65,0)
(9,40,0)
(49,21,0)
(18,78,0)
(46,66,0)
(16,54,0)
(34,65,0)
(23,61,0)
(72,61,0)
(3,21,0)
(28,21,0)
(1,78,0)
(11,32,0)
(49,54,0)
(2,55,0)
(61,23,0)
(7,9,0)
(78,21,0)
(45,29,0)
(34,28,0)
(18,38,0)
(9,52,0)
(9,49,0)
(9,13,0)
(27,76,0)
(52,38,0)
(55,71,0)
(9,59,0)
(15,59,0)
(43,74,0)
(26,18,0)
(51,8,0)
(25,29,0)
(8,55,0)
(69,63,0)
(60,40,0)
(74,43,0)
(40,9,0)
(35,29,0)
(28,34,0)
(12,13,0)
(53,21,0)
(56,9,0)
(41,9,0)
(0,63,0)
(71,55,0)
(44,71,0)
(11,38,0)
(68,11,0)
(17,23,0)
(10,52,0)
(32,11,0)
(79,61,0)
(70,43,0)
(39,29,0)
(19,18,0)
(52,38,1)
(78,17,1)
(74,43,1)
(67,43,1)
(64,78,1)
(32,11,1)
(34,65,1)
(72,79,1)
(49,54,1)
(6,74,1)
(0,69,1)
(61,38,1)
(60,41,1)
(43,32,1)
(9,54,1)
(20,8,1)
(66,36,1)
(17,23,1)
(30,32,1)
(23,61,1)
(40,60,1)
(66,46,1)
(11,38,1)
(1,18,1)
(10,76,1)
(79,5,1)
(9,55,1)
(9,13,1)
(66,65,1)
(62,16,1)
(9,52,1)
(56,59,1)
(5,74,1)
(44,33,1)
(54,62,1)
(59,38,1)
(8,55,1)
(8,77,1)
(18,19,1)
(23,31,1)
(2,53,1)
(78,1,1)
(69,17,1)
(76,65,1)
(78,8,1)
(22,68,1)
(73,56,1)
(47,20,1)
(75,10,1)
(9,49,1)
(46,6,1)
(42,76,1)
(16,14,1)
(53,24,1)
(15,42,1)
(70,30,1)
(51,55,1)
(9,38,1)
(61,72,1)
(50,64,1)
(43,70,1)
(76,27,1)
(56,52,1)
(9,4,1)
(13,12,1)
(71,44,1)
(18,38,1)
(34,47,1)
(63,0,1)
(7,13,1)
(77,51,1)
(33,48,1)
(50,66,1)
(19,26,1)
(55,71,1)
(4,40,1)
(31,61,1)
(52,75,1)
(24,63,1)
(59,15,1)
(53,63,1)
(68,58,1)
(63,38,1)
(28,34,1)
(9,59,1)
(14,28,1)
(48,2,1)
(26,9,1)
(12,73,1)
(71,33,1)
(74,67,1)
(41,7,1)
(11,22,1)
(9,40,1)
(27,49,1)
(53,74,2)
(55,71,2)
(9,54,2)
(26,74,2)
(11,38,2)
(12,74,2)
(62,74,2)
(48,74,2)
(66,65,2)
(17,23,2)
(9,13,2)
(56,74,2)
(74,43,2)
(23,61,2)
(9,74,2)
(42,76,2)
(59,76,2)
(60,74,2)
(41,74,2)
(2,74,2)
(44,74,2)
(76,65,2)
(43,32,2)
(64,74,2)
(28,34,2)
(78,8,2)
(9,49,2)
(63,74,2)
(79,74,2)
(69,74,2)
(49,54,2)
(20,74,2)
(0,74,2)
(32,11,2)
(78,17,2)
(9,52,2)
(17,74,2)
(53,63,2)
(34,74,2)
(28,74,2)
(75,76,2)
(78,74,2)
(1,74,2)
(59,38,2)
(4,74,2)
(73,74,2)
(18,38,2)
(55,74,2)
(72,74,2)
(8,74,2)
(6,74,2)
(46,74,2)
(47,74,2)
(61,74,2)
(66,74,2)
(52,38,2)
(51,74,2)
(54,74,2)
(40,74,2)
(33,74,2)
(16,74,2)
(5,74,2)
(13,74,2)
(66,36,2)
(61,38,2)
(31,74,2)
(9,59,2)
(24,74,2)
(50,64,2)
(63,38,2)
(71,74,2)
(23,74,2)
(10,76,2)
(18,74,2)
(19,74,2)
(8,55,2)
(71,33,2)
(77,74,2)
(9,38,2)
(7,74,2)
(76,74,2)
(14,74,2)
(27,74,2)
(52,76,2)
(49,74,2)
(15,76,2)
(9,40,2)
(9,55,2)
(34,65,2)
-----------------------------------
(0,l_flag)
(1,f)
(2,si)
(3,if (KSI_TRAP_P(ksi)
(4,si)
(5,f)
(6,ksi)
(7,le)
(8,si->_info)
(9,sa_upcall(l, SA_UPCALL_SIGNAL | SA_UPCALL_DEFER, le, li,\n\\n\\t\\t\\t    sizeof(siginfo_t)
(10,li)
(11,l->l_proc)
(12,SA_UPCALL_DEFER)
(13,SA_UPCALL_SIGNAL | SA_UPCALL_DEFER)
(14,le)
(15,l)
(16,li)
(17,f = l->l_flag & L_SA)
(18,l->l_flag)
(19,l_flag)
(20,ksi)
(21,)
(22,l_proc)
(23,l->l_flag & L_SA)
(24,~L_SA)
(25,si)
(26,l)
(27,ksi)
(28,si->_info = ksi->ksi_info)
(29,)
(30,p)
(31,L_SA)
(32,*p = l->l_proc)
(33,&siginfo_pool)
(34,ksi->ksi_info)
(35,li)
(36,const sigset_t *mask)
(37,le)
(38,struct lwp *l)
(39,if (p->p_flag & P_SA)
(40,sizeof(siginfo_t)
(41,li)
(42,le)
(43,p->p_flag)
(44,PR_WAITOK)
(45,f)
(46,mask)
(47,ksi_info)
(48,siginfo_pool)
(49,le = li = NULL)
(50,RET)
(51,si)
(52,li = l)
(53,l->l_flag &= ~L_SA)
(54,li = NULL)
(55,si = pool_get(&siginfo_pool, PR_WAITOK)
(56,l)
(57,p)
(58,p)
(59,le = l)
(60,siginfo_t)
(61,l->l_flag)
(62,NULL)
(63,l->l_flag)
(64,return;)
(65,const ksiginfo_t *ksi)
(66,(*p->p_emul->e_sendsig)
(67,P_SA)
(68,l)
(69,l)
(70,p_flag)
(71,pool_get(&siginfo_pool, PR_WAITOK)
(72,l_flag)
(73,SA_UPCALL_SIGNAL)
(74,p->p_flag & P_SA)
(75,l)
(76,KSI_TRAP_P(ksi)
(77,_info)
(78,l->l_flag |= f)
(79,l)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^