-----label-----
1
-----code-----
struct locks* init_next_lock(struct client_data* cli_data, struct PoolCounter* parent, enum lock_state state) {
	if ( cli_data->next_lock >= MAX_LOCKS_PER_CLIENT ) {
		return NULL;
	}
	struct locks* l = cli_data->client_locks + cli_data->next_lock;
	l->state = state;
	l->parent = parent;
	l->client_data = cli_data;
	cli_data->next_lock++;
	return l;
}
-----children-----
1,2
1,3
1,4
2,3
4,5
4,6
4,7
4,8
4,9
7,8
7,9
8,9
10,11
10,12
13,14
13,15
14,15
16,17
16,18
19,20
19,21
20,21
22,23
24,25
24,26
24,27
24,28
24,29
24,30
24,31
25,26
25,27
26,27
26,28
27,28
27,29
28,29
31,32
33,34
34,35
35,36
37,38
38,39
38,40
39,40
41,42
41,43
41,44
44,45
45,46
45,47
46,47
46,48
47,48
50,51
50,52
51,52
54,55
55,56
55,57
56,57
56,58
57,58
60,61
62,63
63,64
63,65
64,65
64,66
65,66
68,69
70,71
71,72
71,73
72,73
72,74
73,74
76,77
78,79
79,80
80,81
80,82
81,82
84,85
85,86
-----nextToken-----
3,5,6,9,11,12,15,17,18,21,23,29,30,32,36,40,42,43,48,49,52,53,58,59,61,66,67,69,74,75,77,82,83,86
-----computeFrom-----
26,27
26,28
45,46
45,47
55,56
55,57
63,64
63,65
71,72
71,73
-----guardedBy-----
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;ElaboratedTypeSpecifier;Name;FunctionDeclarator;Pointer;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ReturnStatement;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;ReturnStatement;IdExpression;Name;
-----ast_node-----
struct locks* init_next_lock(struct client_data* cli_data, struct PoolCounter* parent, enum lock_state state) {	if ( cli_data->next_lock >= MAX_LOCKS_PER_CLIENT ) {		return NULL;	}	struct locks* l = cli_data->client_locks + cli_data->next_lock;	l->state = state;	l->parent = parent;	l->client_data = cli_data;	cli_data->next_lock++;	return l;}
struct locks
locks
* init_next_lock(struct client_data* cli_data, struct PoolCounter* parent, enum lock_state state)
*
init_next_lock
struct client_data* cli_data
struct client_data
client_data
* cli_data
*
cli_data
struct PoolCounter* parent
struct PoolCounter
PoolCounter
* parent
*
parent
enum lock_state state
enum lock_state
lock_state
state
state
{	if ( cli_data->next_lock >= MAX_LOCKS_PER_CLIENT ) {		return NULL;	}	struct locks* l = cli_data->client_locks + cli_data->next_lock;	l->state = state;	l->parent = parent;	l->client_data = cli_data;	cli_data->next_lock++;	return l;}
if ( cli_data->next_lock >= MAX_LOCKS_PER_CLIENT ) {		return NULL;	}
cli_data->next_lock >= MAX_LOCKS_PER_CLIENT
cli_data->next_lock
cli_data
cli_data
next_lock
MAX_LOCKS_PER_CLIENT
MAX_LOCKS_PER_CLIENT
{		return NULL;	}
return NULL;
NULL
NULL
struct locks* l = cli_data->client_locks + cli_data->next_lock;
struct locks* l = cli_data->client_locks + cli_data->next_lock;
struct locks
locks
* l = cli_data->client_locks + cli_data->next_lock
*
l
= cli_data->client_locks + cli_data->next_lock
cli_data->client_locks + cli_data->next_lock
cli_data->client_locks
cli_data
cli_data
client_locks
cli_data->next_lock
cli_data
cli_data
next_lock
l->state = state;
l->state = state
l->state
l
l
state
state
state
l->parent = parent;
l->parent = parent
l->parent
l
l
parent
parent
parent
l->client_data = cli_data;
l->client_data = cli_data
l->client_data
l
l
client_data
cli_data
cli_data
cli_data->next_lock++;
cli_data->next_lock++
cli_data->next_lock
cli_data
cli_data
next_lock
return l;
l
l
-----joern-----
(18,30,0)
(8,7,0)
(41,28,0)
(35,15,0)
(1,30,0)
(11,0,0)
(2,28,0)
(30,2,0)
(4,6,0)
(16,38,0)
(13,0,0)
(34,7,0)
(37,19,0)
(5,16,0)
(0,2,0)
(28,2,0)
(24,6,0)
(37,0,0)
(3,16,0)
(40,33,0)
(0,7,0)
(5,0,0)
(21,44,0)
(32,28,0)
(17,36,0)
(14,19,0)
(20,37,0)
(26,5,0)
(23,13,0)
(6,12,0)
(6,24,0)
(27,17,0)
(33,31,0)
(44,7,0)
(29,17,0)
(43,6,0)
(2,30,0)
(36,17,0)
(30,12,0)
(2,0,0)
(22,5,0)
(10,15,0)
(17,12,0)
(19,12,0)
(42,24,0)
(44,39,0)
(36,7,0)
(15,44,0)
(19,7,0)
(9,37,0)
(28,12,0)
(15,0,0)
(16,7,0)
(13,7,0)
(25,33,0)
(25,13,0)
(23,36,1)
(32,41,1)
(35,0,1)
(30,12,1)
(29,19,1)
(13,23,1)
(11,24,1)
(24,42,1)
(30,18,1)
(1,28,1)
(37,20,1)
(25,13,1)
(14,37,1)
(6,12,1)
(5,22,1)
(44,21,1)
(44,39,1)
(0,2,1)
(33,40,1)
(27,29,1)
(2,28,1)
(19,14,1)
(17,27,1)
(19,12,1)
(41,11,1)
(22,26,1)
(15,0,1)
(9,16,1)
(28,12,1)
(42,6,1)
(40,24,1)
(25,33,1)
(4,43,1)
(2,30,1)
(37,0,1)
(24,6,1)
(26,44,1)
(36,17,1)
(13,0,1)
(28,32,1)
(3,5,1)
(21,15,1)
(18,1,1)
(16,38,1)
(10,35,1)
(6,4,1)
(15,10,1)
(5,0,1)
(17,12,1)
(16,3,1)
(20,9,1)
(13,24,2)
(17,12,2)
(6,12,2)
(29,24,2)
(33,24,2)
(11,24,2)
(37,24,2)
(26,24,2)
(36,24,2)
(30,12,2)
(2,30,2)
(16,24,2)
(5,24,2)
(18,24,2)
(25,13,2)
(28,12,2)
(15,24,2)
(32,24,2)
(2,24,2)
(19,12,2)
(14,24,2)
(44,24,2)
(35,24,2)
(15,0,2)
(16,38,2)
(40,24,2)
(37,0,2)
(9,24,2)
(30,24,2)
(3,24,2)
(28,24,2)
(36,17,2)
(44,39,2)
(0,24,2)
(23,24,2)
(25,33,2)
(0,2,2)
(5,0,2)
(27,24,2)
(10,24,2)
(21,24,2)
(20,24,2)
(17,24,2)
(19,24,2)
(2,28,2)
(22,24,2)
(24,6,2)
(41,24,2)
(1,24,2)
(13,0,2)
-----------------------------------
(0,* l = cli_data->client_locks + cli_data->next_lock)
(1,cli_data)
(2,cli_data->client_locks + cli_data->next_lock)
(3,parent)
(4,next_lock)
(5,l->parent)
(6,cli_data->next_lock)
(7,)
(8,l)
(9,l)
(10,state)
(11,l)
(12,struct client_data* cli_data)
(13,return l;)
(14,cli_data)
(15,l->state)
(16,l->parent = parent)
(17,cli_data->next_lock)
(18,next_lock)
(19,l->client_data = cli_data)
(20,client_data)
(21,state)
(22,parent)
(23,l)
(24,cli_data->next_lock >= MAX_LOCKS_PER_CLIENT)
(25,RET)
(26,l)
(27,next_lock)
(28,cli_data->client_locks)
(29,cli_data)
(30,cli_data->next_lock)
(31,)
(32,client_locks)
(33,return NULL;)
(34,if ( cli_data->next_lock >= MAX_LOCKS_PER_CLIENT )
(35,l)
(36,cli_data->next_lock++)
(37,l->client_data)
(38,struct PoolCounter* parent)
(39,enum lock_state state)
(40,NULL)
(41,cli_data)
(42,MAX_LOCKS_PER_CLIENT)
(43,cli_data)
(44,l->state = state)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^