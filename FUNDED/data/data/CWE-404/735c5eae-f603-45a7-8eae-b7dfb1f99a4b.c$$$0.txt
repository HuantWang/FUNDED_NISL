-----label-----
1
-----code-----
void
db_stack_trace_cmd(db_expr_t addr, boolean_t have_addr, db_expr_t count,
		   char *modif)
{
	struct i386_frame *frame;
	int *argp;
	db_addr_t callpc;
	boolean_t first;
	struct pcb *pcb;
	struct proc *p;
	pid_t pid;
	int i;

	if (count == -1)
		count = 1024;

	if (!have_addr) {
		frame = (struct i386_frame *)BP_REGS(&ddb_regs);
		if (frame == NULL)
			frame = (struct i386_frame *)(SP_REGS(&ddb_regs) - 4);
		callpc = PC_REGS(&ddb_regs);
	} else if (!INKERNEL(addr)) {
		pid = (addr % 16) + ((addr >> 4) % 16) * 10 +
		    ((addr >> 8) % 16) * 100 + ((addr >> 12) % 16) * 1000 +
		    ((addr >> 16) % 16) * 10000;
		/*
		 * The pcb for curproc is not valid at this point,
		 * so fall back to the default case.
		 */
		if ((curproc != NULL) && (pid == curproc->p_pid)) {
			frame = (struct i386_frame *)BP_REGS(&ddb_regs);
			if (frame == NULL)
				frame = (struct i386_frame *)
				    (SP_REGS(&ddb_regs) - 4);
			callpc = PC_REGS(&ddb_regs);
		} else {

			/* sx_slock(&allproc_lock); */
			FOREACH_PROC_IN_SYSTEM(p) {
				if (p->p_pid == pid)
					break;
			}
			/* sx_sunlock(&allproc_lock); */
			if (p == NULL) {
				db_printf("pid %d not found\n", pid);
				return;
			}
			if ((p->p_flag & P_SWAPPEDOUT)) {
				db_printf("pid %d swapped out\n", pid);
				return;
			}
			pcb = p->p_thread->td_pcb;
			frame = (struct i386_frame *)pcb->pcb_ebp;
			if (frame == NULL)
				frame = (struct i386_frame *)
				    (pcb->pcb_esp - 4);
			callpc = (db_addr_t)pcb->pcb_eip;
		}
	} else {
		/*
		 * Look for something that might be a frame pointer, just as
		 * a convenience.
		 */
		frame = (struct i386_frame *)addr;
		for (i = 0; i < 4096; i += 4) {
			struct i386_frame *check;

			check = (struct i386_frame *)db_get_value((int)((char *)&frame->f_frame + i), 4, FALSE);
			if ((char *)check - (char *)frame >= 0 &&
			    (char *)check - (char *)frame < 4096
			) {
				break;
			}
			db_printf("%p does not look like a stack frame, skipping\n", (char *)&frame->f_frame + i);
		}
		if (i == 4096) {
			db_printf("Unable to find anything that looks like a stack frame\n");
			return;
		}
		frame = (void *)((char *)frame + i);
		db_printf("Trace beginning at frame %p\n", frame);
		callpc = (db_addr_t)db_get_value((int)&frame->f_retaddr, 4, FALSE);
	}

	first = TRUE;
	while (count--) {
		struct i386_frame *actframe;
		int		narg;
		const char *	name;
		db_expr_t	offset;
		c_db_sym_t	sym;
#define MAXNARG	16
		char	*argnames[MAXNARG], **argnp = NULL;

		sym = db_search_symbol(callpc, DB_STGY_ANY, &offset);
		db_symbol_values(sym, &name, NULL);

		/*
		 * Attempt to determine a (possibly fake) frame that gives
		 * the caller's pc.  It may differ from `frame' if the
		 * current function never sets up a standard frame or hasn't
		 * set one up yet or has just discarded one.  The last two
		 * cases can be guessed fairly reliably for code generated
		 * by gcc.  The first case is too much trouble to handle in
		 * general because the amount of junk on the stack depends
		 * on the pc (the special handling of "calltrap", etc. in
		 * db_nextframe() works because the `next' pc is special).
		 */
		actframe = frame;
		if (first) {
			if (!have_addr) {
				int instr;

				instr = db_get_value(callpc, 4, FALSE);
				if ((instr & 0x00ffffff) == 0x00e58955) {
					/* pushl %ebp; movl %esp, %ebp */
					actframe = (struct i386_frame *)
					    (SP_REGS(&ddb_regs) - 4);
				} else if ((instr & 0x0000ffff) == 0x0000e589) {
					/* movl %esp, %ebp */
					actframe = (struct i386_frame *)
					    SP_REGS(&ddb_regs);
					if (ddb_regs.tf_ebp == 0) {
						/* Fake caller's frame better. */
						frame = actframe;
					}
				} else if ((instr & 0x000000ff) == 0x000000c3) {
					/* ret */
					actframe = (struct i386_frame *)
					    (SP_REGS(&ddb_regs) - 4);
				} else if (offset == 0) {
					/* Probably a symbol in assembler code. */
					actframe = (struct i386_frame *)
					    (SP_REGS(&ddb_regs) - 4);
				}
			} else if (!strcmp(name, "fork_trampoline")) {
				/*
				 * Don't try to walk back on a stack for a
				 * process that hasn't actually been run yet.
				 */
				db_print_stack_entry(name, 0, 0, 0, callpc);
				break;
			}
			first = FALSE;
		}

		argp = &actframe->f_arg0;
		narg = MAXNARG;
		if (sym != NULL && db_sym_numargs(sym, &narg, argnames)) {
			argnp = argnames;
		} else {
			narg = db_numargs(frame);
		}

		db_print_stack_entry(name, narg, argnp, argp, callpc);

		if (actframe != frame) {
			/* `frame' belongs to caller. */
			callpc = (db_addr_t)
			    db_get_value((int)&actframe->f_retaddr, 4, FALSE);
			continue;
		}

		db_nextframe(&frame, &callpc);

		if (INKERNEL((int) callpc) && !INKERNEL((int) frame)) {
			sym = db_search_symbol(callpc, DB_STGY_ANY, &offset);
			db_symbol_values(sym, &name, NULL);
			db_print_stack_entry(name, 0, 0, 0, callpc);
			break;
		}
		if (!INKERNEL((int) frame)) {
			break;
		}
	}
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
3,7
3,8
5,6
5,7
6,7
8,9
10,11
10,12
11,12
13,14
15,16
15,17
16,17
18,19
20,21
20,22
22,23
22,24
25,26
25,27
25,28
25,29
25,30
25,31
25,32
25,33
25,34
25,35
25,36
25,37
26,27
27,28
27,29
28,29
30,31
30,32
33,34
34,35
34,36
36,37
36,38
39,40
40,41
40,42
41,42
43,44
45,46
46,47
46,48
47,48
49,50
51,52
52,53
52,54
53,54
55,56
55,57
58,59
59,60
59,61
60,61
62,63
62,64
65,66
66,67
66,68
67,68
69,70
71,72
72,73
72,74
74,75
76,77
76,78
77,78
77,79
78,79
80,81
82,83
83,84
83,85
84,85
87,88
87,89
87,90
88,89
89,90
91,92
91,93
91,94
92,93
93,94
93,95
94,95
96,97
96,98
97,98
97,99
98,99
100,101
102,103
102,104
103,104
105,106
106,107
108,109
108,110
109,110
109,111
110,111
112,113
114,115
115,116
115,117
116,117
118,119
118,120
119,120
119,121
120,121
122,123
124,125
125,126
125,127
126,127
126,128
127,128
129,130
130,131
133,134
134,135
134,136
135,136
137,138
137,139
138,139
140,141
141,142
143,144
143,145
143,146
144,145
145,146
145,147
146,147
148,149
150,151
150,152
151,152
152,153
152,154
153,154
155,156
155,157
156,157
156,158
157,158
157,159
158,159
158,160
159,160
160,161
160,162
161,162
164,165
164,166
165,166
166,167
166,168
167,168
168,169
168,170
169,170
174,175
174,176
175,176
176,177
176,178
177,178
178,179
178,180
179,180
184,185
184,186
185,186
186,187
186,188
187,188
188,189
188,190
189,190
194,195
194,196
195,196
196,197
196,198
197,198
198,199
198,200
199,200
204,205
204,206
204,207
205,206
205,207
206,207
207,208
207,209
208,209
210,211
212,213
213,214
213,215
214,215
216,217
216,218
217,218
220,221
220,222
220,223
221,222
222,223
222,224
223,224
225,226
225,227
226,227
226,228
227,228
229,230
231,232
231,233
232,233
234,235
235,236
237,238
237,239
238,239
238,240
239,240
241,242
243,244
244,245
244,246
245,246
247,248
247,249
248,249
248,250
249,250
251,252
253,254
254,255
254,256
255,256
255,257
256,257
258,259
259,260
262,263
263,264
263,265
264,265
266,267
266,268
267,268
269,270
270,271
272,273
272,274
272,275
272,276
272,277
272,278
272,279
272,280
272,281
273,274
274,275
274,276
275,276
277,278
279,280
280,281
281,282
281,283
282,283
282,284
283,284
283,285
284,285
287,288
290,291
290,292
291,292
291,293
292,293
294,295
296,297
296,298
297,298
298,299
298,300
298,301
299,300
302,303
305,306
305,307
306,307
307,308
307,309
308,309
308,310
309,310
312,313
314,315
314,316
315,316
316,317
316,318
316,319
317,318
320,321
323,324
324,325
324,326
325,326
327,328
327,329
328,329
328,330
329,330
333,334
334,335
334,336
335,336
337,338
337,339
338,339
338,340
339,340
341,342
343,344
343,345
344,345
347,348
347,349
348,349
348,350
349,350
351,352
353,354
354,355
354,356
355,356
357,358
357,359
358,359
358,360
359,360
361,362
363,364
364,365
364,366
365,366
365,367
366,367
370,371
371,372
371,373
372,373
374,375
374,376
375,376
375,377
376,377
379,380
379,381
380,381
383,384
383,385
383,386
383,387
383,388
383,389
384,385
385,386
385,387
386,387
388,389
388,390
389,390
389,391
390,391
392,393
394,395
396,397
396,398
396,399
396,400
397,398
398,399
398,400
399,400
402,403
402,404
403,404
406,407
406,408
407,408
410,411
410,412
410,413
410,414
411,412
412,413
412,414
413,414
415,416
415,417
418,419
419,420
419,421
420,421
422,423
422,424
423,424
423,425
424,425
426,427
428,429
428,430
428,431
428,432
429,430
431,432
431,433
432,433
432,434
435,436
436,437
436,438
437,438
437,439
438,439
438,440
440,441
442,443
443,444
443,445
444,445
447,448
450,451
452,453
452,454
453,454
453,455
454,455
454,456
455,456
455,457
456,457
456,458
457,458
457,459
459,460
461,462
463,464
463,465
464,465
464,466
466,467
468,469
471,472
471,473
472,473
472,474
473,474
473,475
474,475
474,476
476,477
478,479
480,481
480,482
481,482
481,483
483,484
485,486
488,489
490,491
491,492
491,493
491,494
492,493
495,496
495,497
496,497
496,498
497,498
497,499
499,500
501,502
502,503
502,504
503,504
506,507
508,509
508,510
509,510
509,511
510,511
513,514
513,515
514,515
515,516
515,517
516,517
520,521
521,522
521,523
522,523
524,525
524,526
525,526
525,527
527,528
529,530
530,531
530,532
531,532
531,533
532,533
532,534
534,535
536,537
538,539
540,541
541,542
541,543
541,544
542,543
545,546
547,548
548,549
548,550
549,550
551,552
551,553
552,553
552,554
553,554
556,557
556,558
556,559
556,560
557,558
559,560
559,561
560,561
560,562
563,564
564,565
564,566
565,566
569,570
571,572
572,573
572,574
573,574
575,576
577,578
577,579
578,579
579,580
581,582
581,583
581,584
581,585
581,586
581,587
581,588
581,589
581,590
581,591
581,592
581,593
581,594
581,595
581,596
581,597
581,598
581,599
582,583
583,584
583,585
584,585
586,587
586,588
589,590
590,591
590,592
592,593
594,595
595,596
595,597
597,598
597,599
600,601
601,602
601,603
602,603
604,605
606,607
607,608
607,609
608,609
610,611
612,613
613,614
613,615
613,616
615,616
615,617
615,618
618,619
620,621
620,622
620,623
620,624
624,625
625,626
627,628
628,629
628,630
629,630
631,632
631,633
631,634
631,635
632,633
634,635
636,637
638,639
639,640
641,642
642,643
642,644
642,645
642,646
643,644
645,646
647,648
648,649
650,651
652,653
653,654
653,655
654,655
656,657
658,659
658,660
659,660
661,662
661,663
662,663
662,664
662,665
663,664
664,665
666,667
666,668
666,669
667,668
668,669
668,670
670,671
672,673
673,674
673,675
674,675
676,677
676,678
676,679
676,680
677,678
679,680
682,683
684,685
684,686
684,687
685,686
685,687
686,687
687,688
687,689
688,689
692,693
693,694
694,695
694,696
695,696
697,698
697,699
698,699
698,700
699,700
701,702
703,704
704,705
704,706
705,706
705,707
706,707
708,709
709,710
712,713
712,714
712,715
713,714
713,715
714,715
715,716
715,717
716,717
720,721
720,722
721,722
722,723
722,724
723,724
725,726
725,727
726,727
726,728
727,728
729,730
731,732
731,733
732,733
734,735
735,736
737,738
737,739
738,739
738,740
739,740
739,741
740,741
744,745
745,746
746,747
746,748
747,748
749,750
751,752
751,753
751,754
752,753
752,754
753,754
754,755
754,756
755,756
759,760
760,761
761,762
761,763
762,763
764,765
764,766
765,766
765,767
766,767
768,769
770,771
771,772
771,773
772,773
772,774
773,774
775,776
776,777
779,780
779,781
780,781
780,782
781,782
784,785
785,786
786,787
786,788
787,788
789,790
789,791
790,791
790,792
791,792
793,794
795,796
796,797
796,798
797,798
797,799
798,799
800,801
801,802
804,805
804,806
805,806
806,807
806,808
806,809
807,808
809,810
812,813
812,814
813,814
814,815
814,816
814,817
814,818
814,819
814,820
815,816
817,818
822,823
825,826
826,827
826,828
827,828
829,830
831,832
832,833
832,834
833,834
835,836
836,837
836,838
837,838
840,841
841,842
841,843
842,843
845,846
845,847
845,848
846,847
846,848
847,848
847,849
848,849
850,851
852,853
852,854
852,855
852,856
853,854
855,856
857,858
858,859
860,861
862,863
863,864
864,865
864,866
865,866
867,868
869,870
870,871
871,872
871,873
872,873
874,875
874,876
875,876
877,878
879,880
880,881
880,882
880,883
880,884
880,885
880,886
881,882
883,884
885,886
887,888
889,890
891,892
893,894
893,895
894,895
894,896
895,896
897,898
899,900
899,901
900,901
901,902
901,903
902,903
904,905
904,906
905,906
905,907
906,907
909,910
909,911
909,912
909,913
910,911
912,913
912,914
913,914
913,915
916,917
917,918
917,919
918,919
922,923
925,926
926,927
926,928
926,929
927,928
929,930
930,931
932,933
933,934
935,936
935,937
936,937
936,938
937,938
937,939
938,939
940,941
940,942
941,942
941,943
944,945
946,947
947,948
947,949
948,949
950,951
950,952
951,952
951,953
954,955
956,957
956,958
956,959
956,960
957,958
958,959
958,960
959,960
961,962
961,963
961,964
961,965
962,963
964,965
966,967
968,969
969,970
971,972
972,973
972,974
972,975
972,976
973,974
975,976
977,978
978,979
980,981
982,983
983,984
983,985
983,986
983,987
983,988
983,989
984,985
986,987
991,992
994,995
994,996
995,996
996,997
996,998
997,998
999,1000
999,1001
1000,1001
1000,1002
1003,1004
1005,1006
-----nextToken-----
2,4,7,9,12,14,17,19,21,23,24,29,31,32,35,37,38,42,44,48,50,54,56,57,61,63,64,68,70,73,75,79,81,85,86,90,95,99,101,104,107,111,113,117,121,123,128,131,132,136,139,142,147,149,154,162,163,170,171,172,173,180,181,182,183,190,191,192,193,200,201,202,203,209,211,215,218,219,224,228,230,233,236,240,242,246,250,252,257,260,261,265,268,271,276,278,285,286,288,289,293,295,300,301,303,304,310,311,313,318,319,321,322,326,330,331,332,336,340,342,345,346,350,352,356,360,362,367,368,369,373,377,378,381,382,387,391,393,395,400,401,404,405,408,409,414,416,417,421,425,427,430,433,434,439,441,445,446,448,449,451,458,460,462,465,467,469,470,475,477,479,482,484,486,487,489,493,494,498,500,504,505,507,511,512,517,518,519,523,526,528,533,535,537,539,543,544,546,550,554,555,558,561,562,566,567,568,570,574,576,580,585,587,588,591,593,596,598,599,603,605,609,611,614,616,617,619,621,622,623,626,630,633,635,637,640,644,646,649,651,655,657,660,665,669,671,675,678,680,681,683,689,690,691,696,700,702,707,710,711,717,718,719,724,728,730,733,736,741,742,743,748,750,756,757,758,763,767,769,774,777,778,782,783,788,792,794,799,802,803,808,810,811,816,818,819,820,821,823,824,828,830,834,838,839,843,844,849,851,854,856,859,861,866,868,873,876,878,882,884,886,888,890,892,896,898,903,907,908,911,914,915,919,920,921,923,924,928,931,934,939,942,943,945,949,952,953,955,960,963,965,967,970,974,976,979,981,985,987,988,989,990,992,993,998,1001,1002,1004,1006
-----computeFrom-----
77,78
77,79
83,84
83,85
93,94
93,95
109,110
109,111
115,116
115,117
125,126
125,127
134,135
134,136
152,153
152,154
155,156
155,157
156,157
156,158
157,158
157,159
158,159
158,160
160,161
160,162
164,165
164,166
166,167
166,168
168,169
168,170
174,175
174,176
176,177
176,178
178,179
178,180
184,185
184,186
186,187
186,188
188,189
188,190
194,195
194,196
196,197
196,198
198,199
198,200
205,206
205,207
207,208
207,209
213,214
213,215
222,223
222,224
238,239
238,240
244,245
244,246
254,255
254,256
263,264
263,265
282,283
282,284
291,292
291,293
307,308
307,309
324,325
324,326
334,335
334,336
348,349
348,350
354,355
354,356
364,365
364,366
371,372
371,373
385,386
385,387
398,399
398,400
402,403
402,404
406,407
406,408
419,420
419,421
436,437
436,438
453,454
453,455
454,455
454,456
455,456
455,457
471,472
471,473
472,473
472,474
495,496
495,497
509,510
509,511
521,522
521,523
530,531
530,532
548,549
548,550
572,573
572,574
628,629
628,630
653,654
653,655
673,674
673,675
685,686
685,687
687,688
687,689
694,695
694,696
704,705
704,706
713,714
713,715
715,716
715,717
722,723
722,724
738,739
738,740
746,747
746,748
752,753
752,754
754,755
754,756
761,762
761,763
771,772
771,773
780,781
780,782
786,787
786,788
796,797
796,798
826,827
826,828
832,833
832,834
841,842
841,843
846,847
846,848
847,848
847,849
864,865
864,866
871,872
871,873
894,895
894,896
901,902
901,903
936,937
936,938
958,959
958,960
-----guardedBy-----
79,85
111,117
211,242
240,246
350,356
861,868
896,919
945,992
-----guardedByNegation-----
211,352
215,321
219,286
689,756
717,756
859,873
-----lastLexicalUse-----
211,352
-----jump-----
211,352
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;IfStatement;BinaryExpression;IdExpression;Name;UnaryExpression;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;Pointer;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;Pointer;UnaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;UnaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;LiteralExpression;BinaryExpression;UnaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;LiteralExpression;BinaryExpression;UnaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;LiteralExpression;BinaryExpression;UnaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;LiteralExpression;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;Pointer;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;Pointer;UnaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ProblemStatement;CompoundStatement;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BreakStatement;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;ReturnStatement;IfStatement;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;ReturnStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;Pointer;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;Pointer;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;Pointer;IdExpression;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;Pointer;FunctionCallExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;UnaryExpression;BinaryExpression;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;UnaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;IdExpression;Name;LiteralExpression;BinaryExpression;BinaryExpression;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;IdExpression;Name;LiteralExpression;CompoundStatement;BreakStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;BinaryExpression;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;UnaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ReturnStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;UnaryExpression;BinaryExpression;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;FunctionCallExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;UnaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;WhileStatement;UnaryExpression;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Pointer;Name;ArrayModifier;LiteralExpression;Declarator;Pointer;Pointer;Name;EqualsInitializer;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;Pointer;UnaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;Pointer;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;Pointer;UnaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;Pointer;UnaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;LiteralExpression;IdExpression;Name;BreakStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;FunctionCallExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;UnaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IdExpression;Name;ContinueStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;IdExpression;Name;UnaryExpression;FunctionCallExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;LiteralExpression;IdExpression;Name;BreakStatement;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;IdExpression;Name;CompoundStatement;BreakStatement;
-----ast_node-----
voiddb_stack_trace_cmd(db_expr_t addr, boolean_t have_addr, db_expr_t count,		   char *modif){	struct i386_frame *frame;	int *argp;	db_addr_t callpc;	boolean_t first;	struct pcb *pcb;	struct proc *p;	pid_t pid;	int i;	if (count == -1)		count = 1024;	if (!have_addr) {		frame = (struct i386_frame *)BP_REGS(&ddb_regs);		if (frame == NULL)			frame = (struct i386_frame *)(SP_REGS(&ddb_regs) - 4);		callpc = PC_REGS(&ddb_regs);	} else if (!INKERNEL(addr)) {		pid = (addr % 16) + ((addr >> 4) % 16) * 10 +		    ((addr >> 8) % 16) * 100 + ((addr >> 12) % 16) * 1000 +		    ((addr >> 16) % 16) * 10000;		/*		 * The pcb for curproc is not valid at this point,		 * so fall back to the default case.		 */		if ((curproc != NULL) && (pid == curproc->p_pid)) {			frame = (struct i386_frame *)BP_REGS(&ddb_regs);			if (frame == NULL)				frame = (struct i386_frame *)				    (SP_REGS(&ddb_regs) - 4);			callpc = PC_REGS(&ddb_regs);		} else {			/* sx_slock(&allproc_lock); */			FOREACH_PROC_IN_SYSTEM(p) {				if (p->p_pid == pid)					break;			}			/* sx_sunlock(&allproc_lock); */			if (p == NULL) {				db_printf("pid %d not found\n", pid);				return;			}			if ((p->p_flag & P_SWAPPEDOUT)) {				db_printf("pid %d swapped out\n", pid);				return;			}			pcb = p->p_thread->td_pcb;			frame = (struct i386_frame *)pcb->pcb_ebp;			if (frame == NULL)				frame = (struct i386_frame *)				    (pcb->pcb_esp - 4);			callpc = (db_addr_t)pcb->pcb_eip;		}	} else {		/*		 * Look for something that might be a frame pointer, just as		 * a convenience.		 */		frame = (struct i386_frame *)addr;		for (i = 0; i < 4096; i += 4) {			struct i386_frame *check;			check = (struct i386_frame *)db_get_value((int)((char *)&frame->f_frame + i), 4, FALSE);			if ((char *)check - (char *)frame >= 0 &&			    (char *)check - (char *)frame < 4096			) {				break;			}			db_printf("%p does not look like a stack frame, skipping\n", (char *)&frame->f_frame + i);		}		if (i == 4096) {			db_printf("Unable to find anything that looks like a stack frame\n");			return;		}		frame = (void *)((char *)frame + i);		db_printf("Trace beginning at frame %p\n", frame);		callpc = (db_addr_t)db_get_value((int)&frame->f_retaddr, 4, FALSE);	}	first = TRUE;	while (count--) {		struct i386_frame *actframe;		int		narg;		const char *	name;		db_expr_t	offset;		c_db_sym_t	sym;#define MAXNARG	16		char	*argnames[MAXNARG], **argnp = NULL;		sym = db_search_symbol(callpc, DB_STGY_ANY, &offset);		db_symbol_values(sym, &name, NULL);		/*		 * Attempt to determine a (possibly fake) frame that gives		 * the caller's pc.  It may differ from `frame' if the		 * current function never sets up a standard frame or hasn't		 * set one up yet or has just discarded one.  The last two		 * cases can be guessed fairly reliably for code generated		 * by gcc.  The first case is too much trouble to handle in		 * general because the amount of junk on the stack depends		 * on the pc (the special handling of "calltrap", etc. in		 * db_nextframe() works because the `next' pc is special).		 */		actframe = frame;		if (first) {			if (!have_addr) {				int instr;				instr = db_get_value(callpc, 4, FALSE);				if ((instr & 0x00ffffff) == 0x00e58955) {					/* pushl %ebp; movl %esp, %ebp */					actframe = (struct i386_frame *)					    (SP_REGS(&ddb_regs) - 4);				} else if ((instr & 0x0000ffff) == 0x0000e589) {					/* movl %esp, %ebp */					actframe = (struct i386_frame *)					    SP_REGS(&ddb_regs);					if (ddb_regs.tf_ebp == 0) {						/* Fake caller's frame better. */						frame = actframe;					}				} else if ((instr & 0x000000ff) == 0x000000c3) {					/* ret */					actframe = (struct i386_frame *)					    (SP_REGS(&ddb_regs) - 4);				} else if (offset == 0) {					/* Probably a symbol in assembler code. */					actframe = (struct i386_frame *)					    (SP_REGS(&ddb_regs) - 4);				}			} else if (!strcmp(name, "fork_trampoline")) {				/*				 * Don't try to walk back on a stack for a				 * process that hasn't actually been run yet.				 */				db_print_stack_entry(name, 0, 0, 0, callpc);				break;			}			first = FALSE;		}		argp = &actframe->f_arg0;		narg = MAXNARG;		if (sym != NULL && db_sym_numargs(sym, &narg, argnames)) {			argnp = argnames;		} else {			narg = db_numargs(frame);		}		db_print_stack_entry(name, narg, argnp, argp, callpc);		if (actframe != frame) {			/* `frame' belongs to caller. */			callpc = (db_addr_t)			    db_get_value((int)&actframe->f_retaddr, 4, FALSE);			continue;		}		db_nextframe(&frame, &callpc);		if (INKERNEL((int) callpc) && !INKERNEL((int) frame)) {			sym = db_search_symbol(callpc, DB_STGY_ANY, &offset);			db_symbol_values(sym, &name, NULL);			db_print_stack_entry(name, 0, 0, 0, callpc);			break;		}		if (!INKERNEL((int) frame)) {			break;		}	}}
void
db_stack_trace_cmd(db_expr_t addr, boolean_t have_addr, db_expr_t count,		   char *modif)
db_stack_trace_cmd
db_expr_t addr
db_expr_t
db_expr_t
addr
addr
boolean_t have_addr
boolean_t
boolean_t
have_addr
have_addr
db_expr_t count
db_expr_t
db_expr_t
count
count
char *modif
char
*modif
*
modif
{	struct i386_frame *frame;	int *argp;	db_addr_t callpc;	boolean_t first;	struct pcb *pcb;	struct proc *p;	pid_t pid;	int i;	if (count == -1)		count = 1024;	if (!have_addr) {		frame = (struct i386_frame *)BP_REGS(&ddb_regs);		if (frame == NULL)			frame = (struct i386_frame *)(SP_REGS(&ddb_regs) - 4);		callpc = PC_REGS(&ddb_regs);	} else if (!INKERNEL(addr)) {		pid = (addr % 16) + ((addr >> 4) % 16) * 10 +		    ((addr >> 8) % 16) * 100 + ((addr >> 12) % 16) * 1000 +		    ((addr >> 16) % 16) * 10000;		/*		 * The pcb for curproc is not valid at this point,		 * so fall back to the default case.		 */		if ((curproc != NULL) && (pid == curproc->p_pid)) {			frame = (struct i386_frame *)BP_REGS(&ddb_regs);			if (frame == NULL)				frame = (struct i386_frame *)				    (SP_REGS(&ddb_regs) - 4);			callpc = PC_REGS(&ddb_regs);		} else {			/* sx_slock(&allproc_lock); */			FOREACH_PROC_IN_SYSTEM(p) {				if (p->p_pid == pid)					break;			}			/* sx_sunlock(&allproc_lock); */			if (p == NULL) {				db_printf("pid %d not found\n", pid);				return;			}			if ((p->p_flag & P_SWAPPEDOUT)) {				db_printf("pid %d swapped out\n", pid);				return;			}			pcb = p->p_thread->td_pcb;			frame = (struct i386_frame *)pcb->pcb_ebp;			if (frame == NULL)				frame = (struct i386_frame *)				    (pcb->pcb_esp - 4);			callpc = (db_addr_t)pcb->pcb_eip;		}	} else {		/*		 * Look for something that might be a frame pointer, just as		 * a convenience.		 */		frame = (struct i386_frame *)addr;		for (i = 0; i < 4096; i += 4) {			struct i386_frame *check;			check = (struct i386_frame *)db_get_value((int)((char *)&frame->f_frame + i), 4, FALSE);			if ((char *)check - (char *)frame >= 0 &&			    (char *)check - (char *)frame < 4096			) {				break;			}			db_printf("%p does not look like a stack frame, skipping\n", (char *)&frame->f_frame + i);		}		if (i == 4096) {			db_printf("Unable to find anything that looks like a stack frame\n");			return;		}		frame = (void *)((char *)frame + i);		db_printf("Trace beginning at frame %p\n", frame);		callpc = (db_addr_t)db_get_value((int)&frame->f_retaddr, 4, FALSE);	}	first = TRUE;	while (count--) {		struct i386_frame *actframe;		int		narg;		const char *	name;		db_expr_t	offset;		c_db_sym_t	sym;#define MAXNARG	16		char	*argnames[MAXNARG], **argnp = NULL;		sym = db_search_symbol(callpc, DB_STGY_ANY, &offset);		db_symbol_values(sym, &name, NULL);		/*		 * Attempt to determine a (possibly fake) frame that gives		 * the caller's pc.  It may differ from `frame' if the		 * current function never sets up a standard frame or hasn't		 * set one up yet or has just discarded one.  The last two		 * cases can be guessed fairly reliably for code generated		 * by gcc.  The first case is too much trouble to handle in		 * general because the amount of junk on the stack depends		 * on the pc (the special handling of "calltrap", etc. in		 * db_nextframe() works because the `next' pc is special).		 */		actframe = frame;		if (first) {			if (!have_addr) {				int instr;				instr = db_get_value(callpc, 4, FALSE);				if ((instr & 0x00ffffff) == 0x00e58955) {					/* pushl %ebp; movl %esp, %ebp */					actframe = (struct i386_frame *)					    (SP_REGS(&ddb_regs) - 4);				} else if ((instr & 0x0000ffff) == 0x0000e589) {					/* movl %esp, %ebp */					actframe = (struct i386_frame *)					    SP_REGS(&ddb_regs);					if (ddb_regs.tf_ebp == 0) {						/* Fake caller's frame better. */						frame = actframe;					}				} else if ((instr & 0x000000ff) == 0x000000c3) {					/* ret */					actframe = (struct i386_frame *)					    (SP_REGS(&ddb_regs) - 4);				} else if (offset == 0) {					/* Probably a symbol in assembler code. */					actframe = (struct i386_frame *)					    (SP_REGS(&ddb_regs) - 4);				}			} else if (!strcmp(name, "fork_trampoline")) {				/*				 * Don't try to walk back on a stack for a				 * process that hasn't actually been run yet.				 */				db_print_stack_entry(name, 0, 0, 0, callpc);				break;			}			first = FALSE;		}		argp = &actframe->f_arg0;		narg = MAXNARG;		if (sym != NULL && db_sym_numargs(sym, &narg, argnames)) {			argnp = argnames;		} else {			narg = db_numargs(frame);		}		db_print_stack_entry(name, narg, argnp, argp, callpc);		if (actframe != frame) {			/* `frame' belongs to caller. */			callpc = (db_addr_t)			    db_get_value((int)&actframe->f_retaddr, 4, FALSE);			continue;		}		db_nextframe(&frame, &callpc);		if (INKERNEL((int) callpc) && !INKERNEL((int) frame)) {			sym = db_search_symbol(callpc, DB_STGY_ANY, &offset);			db_symbol_values(sym, &name, NULL);			db_print_stack_entry(name, 0, 0, 0, callpc);			break;		}		if (!INKERNEL((int) frame)) {			break;		}	}}
struct i386_frame *frame;
struct i386_frame *frame;
struct i386_frame
i386_frame
*frame
*
frame
int *argp;
int *argp;
int
*argp
*
argp
db_addr_t callpc;
db_addr_t callpc;
db_addr_t
db_addr_t
callpc
callpc
boolean_t first;
boolean_t first;
boolean_t
boolean_t
first
first
struct pcb *pcb;
struct pcb *pcb;
struct pcb
pcb
*pcb
*
pcb
struct proc *p;
struct proc *p;
struct proc
proc
*p
*
p
pid_t pid;
pid_t pid;
pid_t
pid_t
pid
pid
int i;
int i;
int
i
i
if (count == -1)		count = 1024;
count == -1
count
count
-1
1
count = 1024;
count = 1024
count
count
1024
if (!have_addr) {		frame = (struct i386_frame *)BP_REGS(&ddb_regs);		if (frame == NULL)			frame = (struct i386_frame *)(SP_REGS(&ddb_regs) - 4);		callpc = PC_REGS(&ddb_regs);	} else if (!INKERNEL(addr)) {		pid = (addr % 16) + ((addr >> 4) % 16) * 10 +		    ((addr >> 8) % 16) * 100 + ((addr >> 12) % 16) * 1000 +		    ((addr >> 16) % 16) * 10000;		/*		 * The pcb for curproc is not valid at this point,		 * so fall back to the default case.		 */		if ((curproc != NULL) && (pid == curproc->p_pid)) {			frame = (struct i386_frame *)BP_REGS(&ddb_regs);			if (frame == NULL)				frame = (struct i386_frame *)				    (SP_REGS(&ddb_regs) - 4);			callpc = PC_REGS(&ddb_regs);		} else {			/* sx_slock(&allproc_lock); */			FOREACH_PROC_IN_SYSTEM(p) {				if (p->p_pid == pid)					break;			}			/* sx_sunlock(&allproc_lock); */			if (p == NULL) {				db_printf("pid %d not found\n", pid);				return;			}			if ((p->p_flag & P_SWAPPEDOUT)) {				db_printf("pid %d swapped out\n", pid);				return;			}			pcb = p->p_thread->td_pcb;			frame = (struct i386_frame *)pcb->pcb_ebp;			if (frame == NULL)				frame = (struct i386_frame *)				    (pcb->pcb_esp - 4);			callpc = (db_addr_t)pcb->pcb_eip;		}	} else {		/*		 * Look for something that might be a frame pointer, just as		 * a convenience.		 */		frame = (struct i386_frame *)addr;		for (i = 0; i < 4096; i += 4) {			struct i386_frame *check;			check = (struct i386_frame *)db_get_value((int)((char *)&frame->f_frame + i), 4, FALSE);			if ((char *)check - (char *)frame >= 0 &&			    (char *)check - (char *)frame < 4096			) {				break;			}			db_printf("%p does not look like a stack frame, skipping\n", (char *)&frame->f_frame + i);		}		if (i == 4096) {			db_printf("Unable to find anything that looks like a stack frame\n");			return;		}		frame = (void *)((char *)frame + i);		db_printf("Trace beginning at frame %p\n", frame);		callpc = (db_addr_t)db_get_value((int)&frame->f_retaddr, 4, FALSE);	}
!have_addr
have_addr
have_addr
{		frame = (struct i386_frame *)BP_REGS(&ddb_regs);		if (frame == NULL)			frame = (struct i386_frame *)(SP_REGS(&ddb_regs) - 4);		callpc = PC_REGS(&ddb_regs);	}
frame = (struct i386_frame *)BP_REGS(&ddb_regs);
frame = (struct i386_frame *)BP_REGS(&ddb_regs)
frame
frame
(struct i386_frame *)BP_REGS(&ddb_regs)
struct i386_frame *
struct i386_frame
i386_frame
*
*
BP_REGS(&ddb_regs)
BP_REGS
BP_REGS
&ddb_regs
ddb_regs
ddb_regs
if (frame == NULL)			frame = (struct i386_frame *)(SP_REGS(&ddb_regs) - 4);
frame == NULL
frame
frame
NULL
NULL
frame = (struct i386_frame *)(SP_REGS(&ddb_regs) - 4);
frame = (struct i386_frame *)(SP_REGS(&ddb_regs) - 4)
frame
frame
(struct i386_frame *)(SP_REGS(&ddb_regs) - 4)
struct i386_frame *
struct i386_frame
i386_frame
*
*
(SP_REGS(&ddb_regs) - 4)
SP_REGS(&ddb_regs) - 4
SP_REGS(&ddb_regs)
SP_REGS
SP_REGS
&ddb_regs
ddb_regs
ddb_regs
4
callpc = PC_REGS(&ddb_regs);
callpc = PC_REGS(&ddb_regs)
callpc
callpc
PC_REGS(&ddb_regs)
PC_REGS
PC_REGS
&ddb_regs
ddb_regs
ddb_regs
if (!INKERNEL(addr)) {		pid = (addr % 16) + ((addr >> 4) % 16) * 10 +		    ((addr >> 8) % 16) * 100 + ((addr >> 12) % 16) * 1000 +		    ((addr >> 16) % 16) * 10000;		/*		 * The pcb for curproc is not valid at this point,		 * so fall back to the default case.		 */		if ((curproc != NULL) && (pid == curproc->p_pid)) {			frame = (struct i386_frame *)BP_REGS(&ddb_regs);			if (frame == NULL)				frame = (struct i386_frame *)				    (SP_REGS(&ddb_regs) - 4);			callpc = PC_REGS(&ddb_regs);		} else {			/* sx_slock(&allproc_lock); */			FOREACH_PROC_IN_SYSTEM(p) {				if (p->p_pid == pid)					break;			}			/* sx_sunlock(&allproc_lock); */			if (p == NULL) {				db_printf("pid %d not found\n", pid);				return;			}			if ((p->p_flag & P_SWAPPEDOUT)) {				db_printf("pid %d swapped out\n", pid);				return;			}			pcb = p->p_thread->td_pcb;			frame = (struct i386_frame *)pcb->pcb_ebp;			if (frame == NULL)				frame = (struct i386_frame *)				    (pcb->pcb_esp - 4);			callpc = (db_addr_t)pcb->pcb_eip;		}	} else {		/*		 * Look for something that might be a frame pointer, just as		 * a convenience.		 */		frame = (struct i386_frame *)addr;		for (i = 0; i < 4096; i += 4) {			struct i386_frame *check;			check = (struct i386_frame *)db_get_value((int)((char *)&frame->f_frame + i), 4, FALSE);			if ((char *)check - (char *)frame >= 0 &&			    (char *)check - (char *)frame < 4096			) {				break;			}			db_printf("%p does not look like a stack frame, skipping\n", (char *)&frame->f_frame + i);		}		if (i == 4096) {			db_printf("Unable to find anything that looks like a stack frame\n");			return;		}		frame = (void *)((char *)frame + i);		db_printf("Trace beginning at frame %p\n", frame);		callpc = (db_addr_t)db_get_value((int)&frame->f_retaddr, 4, FALSE);	}
!INKERNEL(addr)
INKERNEL(addr)
INKERNEL
INKERNEL
addr
addr
{		pid = (addr % 16) + ((addr >> 4) % 16) * 10 +		    ((addr >> 8) % 16) * 100 + ((addr >> 12) % 16) * 1000 +		    ((addr >> 16) % 16) * 10000;		/*		 * The pcb for curproc is not valid at this point,		 * so fall back to the default case.		 */		if ((curproc != NULL) && (pid == curproc->p_pid)) {			frame = (struct i386_frame *)BP_REGS(&ddb_regs);			if (frame == NULL)				frame = (struct i386_frame *)				    (SP_REGS(&ddb_regs) - 4);			callpc = PC_REGS(&ddb_regs);		} else {			/* sx_slock(&allproc_lock); */			FOREACH_PROC_IN_SYSTEM(p) {				if (p->p_pid == pid)					break;			}			/* sx_sunlock(&allproc_lock); */			if (p == NULL) {				db_printf("pid %d not found\n", pid);				return;			}			if ((p->p_flag & P_SWAPPEDOUT)) {				db_printf("pid %d swapped out\n", pid);				return;			}			pcb = p->p_thread->td_pcb;			frame = (struct i386_frame *)pcb->pcb_ebp;			if (frame == NULL)				frame = (struct i386_frame *)				    (pcb->pcb_esp - 4);			callpc = (db_addr_t)pcb->pcb_eip;		}	}
pid = (addr % 16) + ((addr >> 4) % 16) * 10 +		    ((addr >> 8) % 16) * 100 + ((addr >> 12) % 16) * 1000 +		    ((addr >> 16) % 16) * 10000;
pid = (addr % 16) + ((addr >> 4) % 16) * 10 +		    ((addr >> 8) % 16) * 100 + ((addr >> 12) % 16) * 1000 +		    ((addr >> 16) % 16) * 10000
pid
pid
(addr % 16) + ((addr >> 4) % 16) * 10 +		    ((addr >> 8) % 16) * 100 + ((addr >> 12) % 16) * 1000 +		    ((addr >> 16) % 16) * 10000
(addr % 16) + ((addr >> 4) % 16) * 10 +		    ((addr >> 8) % 16) * 100 + ((addr >> 12) % 16) * 1000
(addr % 16) + ((addr >> 4) % 16) * 10 +		    ((addr >> 8) % 16) * 100
(addr % 16) + ((addr >> 4) % 16) * 10
(addr % 16)
addr % 16
addr
addr
16
((addr >> 4) % 16) * 10
((addr >> 4) % 16)
(addr >> 4) % 16
(addr >> 4)
addr >> 4
addr
addr
4
16
10
((addr >> 8) % 16) * 100
((addr >> 8) % 16)
(addr >> 8) % 16
(addr >> 8)
addr >> 8
addr
addr
8
16
100
((addr >> 12) % 16) * 1000
((addr >> 12) % 16)
(addr >> 12) % 16
(addr >> 12)
addr >> 12
addr
addr
12
16
1000
((addr >> 16) % 16) * 10000
((addr >> 16) % 16)
(addr >> 16) % 16
(addr >> 16)
addr >> 16
addr
addr
16
16
10000
if ((curproc != NULL) && (pid == curproc->p_pid)) {			frame = (struct i386_frame *)BP_REGS(&ddb_regs);			if (frame == NULL)				frame = (struct i386_frame *)				    (SP_REGS(&ddb_regs) - 4);			callpc = PC_REGS(&ddb_regs);		} else {			/* sx_slock(&allproc_lock); */			FOREACH_PROC_IN_SYSTEM(p) {				if (p->p_pid == pid)					break;			}			/* sx_sunlock(&allproc_lock); */			if (p == NULL) {				db_printf("pid %d not found\n", pid);				return;			}			if ((p->p_flag & P_SWAPPEDOUT)) {				db_printf("pid %d swapped out\n", pid);				return;			}			pcb = p->p_thread->td_pcb;			frame = (struct i386_frame *)pcb->pcb_ebp;			if (frame == NULL)				frame = (struct i386_frame *)				    (pcb->pcb_esp - 4);			callpc = (db_addr_t)pcb->pcb_eip;		}
(curproc != NULL) && (pid == curproc->p_pid)
(curproc != NULL)
curproc != NULL
curproc
curproc
NULL
NULL
(pid == curproc->p_pid)
pid == curproc->p_pid
pid
pid
curproc->p_pid
curproc
curproc
p_pid
{			frame = (struct i386_frame *)BP_REGS(&ddb_regs);			if (frame == NULL)				frame = (struct i386_frame *)				    (SP_REGS(&ddb_regs) - 4);			callpc = PC_REGS(&ddb_regs);		}
frame = (struct i386_frame *)BP_REGS(&ddb_regs);
frame = (struct i386_frame *)BP_REGS(&ddb_regs)
frame
frame
(struct i386_frame *)BP_REGS(&ddb_regs)
struct i386_frame *
struct i386_frame
i386_frame
*
*
BP_REGS(&ddb_regs)
BP_REGS
BP_REGS
&ddb_regs
ddb_regs
ddb_regs
if (frame == NULL)				frame = (struct i386_frame *)				    (SP_REGS(&ddb_regs) - 4);
frame == NULL
frame
frame
NULL
NULL
frame = (struct i386_frame *)				    (SP_REGS(&ddb_regs) - 4);
frame = (struct i386_frame *)				    (SP_REGS(&ddb_regs) - 4)
frame
frame
(struct i386_frame *)				    (SP_REGS(&ddb_regs) - 4)
struct i386_frame *
struct i386_frame
i386_frame
*
*
(SP_REGS(&ddb_regs) - 4)
SP_REGS(&ddb_regs) - 4
SP_REGS(&ddb_regs)
SP_REGS
SP_REGS
&ddb_regs
ddb_regs
ddb_regs
4
callpc = PC_REGS(&ddb_regs);
callpc = PC_REGS(&ddb_regs)
callpc
callpc
PC_REGS(&ddb_regs)
PC_REGS
PC_REGS
&ddb_regs
ddb_regs
ddb_regs
{			/* sx_slock(&allproc_lock); */			FOREACH_PROC_IN_SYSTEM(p) {				if (p->p_pid == pid)					break;			}			/* sx_sunlock(&allproc_lock); */			if (p == NULL) {				db_printf("pid %d not found\n", pid);				return;			}			if ((p->p_flag & P_SWAPPEDOUT)) {				db_printf("pid %d swapped out\n", pid);				return;			}			pcb = p->p_thread->td_pcb;			frame = (struct i386_frame *)pcb->pcb_ebp;			if (frame == NULL)				frame = (struct i386_frame *)				    (pcb->pcb_esp - 4);			callpc = (db_addr_t)pcb->pcb_eip;		}
FOREACH_PROC_IN_SYSTEM(p)
FOREACH_PROC_IN_SYSTEM(p)
FOREACH_PROC_IN_SYSTEM
FOREACH_PROC_IN_SYSTEM
p
p
)
{				if (p->p_pid == pid)					break;			}
if (p->p_pid == pid)					break;
p->p_pid == pid
p->p_pid
p
p
p_pid
pid
pid
break;
if (p == NULL) {				db_printf("pid %d not found\n", pid);				return;			}
p == NULL
p
p
NULL
NULL
{				db_printf("pid %d not found\n", pid);				return;			}
db_printf("pid %d not found\n", pid);
db_printf("pid %d not found\n", pid)
db_printf
db_printf
"pid %d not found\n"
pid
pid
return;
if ((p->p_flag & P_SWAPPEDOUT)) {				db_printf("pid %d swapped out\n", pid);				return;			}
(p->p_flag & P_SWAPPEDOUT)
p->p_flag & P_SWAPPEDOUT
p->p_flag
p
p
p_flag
P_SWAPPEDOUT
P_SWAPPEDOUT
{				db_printf("pid %d swapped out\n", pid);				return;			}
db_printf("pid %d swapped out\n", pid);
db_printf("pid %d swapped out\n", pid)
db_printf
db_printf
"pid %d swapped out\n"
pid
pid
return;
pcb = p->p_thread->td_pcb;
pcb = p->p_thread->td_pcb
pcb
pcb
p->p_thread->td_pcb
p->p_thread
p
p
p_thread
td_pcb
frame = (struct i386_frame *)pcb->pcb_ebp;
frame = (struct i386_frame *)pcb->pcb_ebp
frame
frame
(struct i386_frame *)pcb->pcb_ebp
struct i386_frame *
struct i386_frame
i386_frame
*
*
pcb->pcb_ebp
pcb
pcb
pcb_ebp
if (frame == NULL)				frame = (struct i386_frame *)				    (pcb->pcb_esp - 4);
frame == NULL
frame
frame
NULL
NULL
frame = (struct i386_frame *)				    (pcb->pcb_esp - 4);
frame = (struct i386_frame *)				    (pcb->pcb_esp - 4)
frame
frame
(struct i386_frame *)				    (pcb->pcb_esp - 4)
struct i386_frame *
struct i386_frame
i386_frame
*
*
(pcb->pcb_esp - 4)
pcb->pcb_esp - 4
pcb->pcb_esp
pcb
pcb
pcb_esp
4
callpc = (db_addr_t)pcb->pcb_eip;
callpc = (db_addr_t)pcb->pcb_eip
callpc
callpc
(db_addr_t)pcb->pcb_eip
db_addr_t
db_addr_t
db_addr_t

pcb->pcb_eip
pcb
pcb
pcb_eip
{		/*		 * Look for something that might be a frame pointer, just as		 * a convenience.		 */		frame = (struct i386_frame *)addr;		for (i = 0; i < 4096; i += 4) {			struct i386_frame *check;			check = (struct i386_frame *)db_get_value((int)((char *)&frame->f_frame + i), 4, FALSE);			if ((char *)check - (char *)frame >= 0 &&			    (char *)check - (char *)frame < 4096			) {				break;			}			db_printf("%p does not look like a stack frame, skipping\n", (char *)&frame->f_frame + i);		}		if (i == 4096) {			db_printf("Unable to find anything that looks like a stack frame\n");			return;		}		frame = (void *)((char *)frame + i);		db_printf("Trace beginning at frame %p\n", frame);		callpc = (db_addr_t)db_get_value((int)&frame->f_retaddr, 4, FALSE);	}
frame = (struct i386_frame *)addr;
frame = (struct i386_frame *)addr
frame
frame
(struct i386_frame *)addr
struct i386_frame *
struct i386_frame
i386_frame
*
*
addr
addr
for (i = 0; i < 4096; i += 4) {			struct i386_frame *check;			check = (struct i386_frame *)db_get_value((int)((char *)&frame->f_frame + i), 4, FALSE);			if ((char *)check - (char *)frame >= 0 &&			    (char *)check - (char *)frame < 4096			) {				break;			}			db_printf("%p does not look like a stack frame, skipping\n", (char *)&frame->f_frame + i);		}
i = 0;
i = 0
i
i
0
i < 4096
i
i
4096
i += 4
i
i
4
{			struct i386_frame *check;			check = (struct i386_frame *)db_get_value((int)((char *)&frame->f_frame + i), 4, FALSE);			if ((char *)check - (char *)frame >= 0 &&			    (char *)check - (char *)frame < 4096			) {				break;			}			db_printf("%p does not look like a stack frame, skipping\n", (char *)&frame->f_frame + i);		}
struct i386_frame *check;
struct i386_frame *check;
struct i386_frame
i386_frame
*check
*
check
check = (struct i386_frame *)db_get_value((int)((char *)&frame->f_frame + i), 4, FALSE);
check = (struct i386_frame *)db_get_value((int)((char *)&frame->f_frame + i), 4, FALSE)
check
check
(struct i386_frame *)db_get_value((int)((char *)&frame->f_frame + i), 4, FALSE)
struct i386_frame *
struct i386_frame
i386_frame
*
*
db_get_value((int)((char *)&frame->f_frame + i), 4, FALSE)
db_get_value
db_get_value
(int)((char *)&frame->f_frame + i)
int
int

((char *)&frame->f_frame + i)
(char *)&frame->f_frame + i
(char *)&frame->f_frame
char *
char
*
*
&frame->f_frame
frame->f_frame
frame
frame
f_frame
i
i
4
FALSE
FALSE
if ((char *)check - (char *)frame >= 0 &&			    (char *)check - (char *)frame < 4096			) {				break;			}
(char *)check - (char *)frame >= 0 &&			    (char *)check - (char *)frame < 4096
(char *)check - (char *)frame >= 0
(char *)check - (char *)frame
(char *)check
char *
char
*
*
check
check
(char *)frame
char *
char
*
*
frame
frame
0
(char *)check - (char *)frame < 4096
(char *)check - (char *)frame
(char *)check
char *
char
*
*
check
check
(char *)frame
char *
char
*
*
frame
frame
4096
{				break;			}
break;
db_printf("%p does not look like a stack frame, skipping\n", (char *)&frame->f_frame + i);
db_printf("%p does not look like a stack frame, skipping\n", (char *)&frame->f_frame + i)
db_printf
db_printf
"%p does not look like a stack frame, skipping\n"
(char *)&frame->f_frame + i
(char *)&frame->f_frame
char *
char
*
*
&frame->f_frame
frame->f_frame
frame
frame
f_frame
i
i
if (i == 4096) {			db_printf("Unable to find anything that looks like a stack frame\n");			return;		}
i == 4096
i
i
4096
{			db_printf("Unable to find anything that looks like a stack frame\n");			return;		}
db_printf("Unable to find anything that looks like a stack frame\n");
db_printf("Unable to find anything that looks like a stack frame\n")
db_printf
db_printf
"Unable to find anything that looks like a stack frame\n"
return;
frame = (void *)((char *)frame + i);
frame = (void *)((char *)frame + i)
frame
frame
(void *)((char *)frame + i)
void *
void
*
*
((char *)frame + i)
(char *)frame + i
(char *)frame
char *
char
*
*
frame
frame
i
i
db_printf("Trace beginning at frame %p\n", frame);
db_printf("Trace beginning at frame %p\n", frame)
db_printf
db_printf
"Trace beginning at frame %p\n"
frame
frame
callpc = (db_addr_t)db_get_value((int)&frame->f_retaddr, 4, FALSE);
callpc = (db_addr_t)db_get_value((int)&frame->f_retaddr, 4, FALSE)
callpc
callpc
(db_addr_t)db_get_value((int)&frame->f_retaddr, 4, FALSE)
db_addr_t
db_addr_t
db_addr_t

db_get_value((int)&frame->f_retaddr, 4, FALSE)
db_get_value
db_get_value
(int)&frame->f_retaddr
int
int

&frame->f_retaddr
frame->f_retaddr
frame
frame
f_retaddr
4
FALSE
FALSE
first = TRUE;
first = TRUE
first
first
TRUE
TRUE
while (count--) {		struct i386_frame *actframe;		int		narg;		const char *	name;		db_expr_t	offset;		c_db_sym_t	sym;#define MAXNARG	16		char	*argnames[MAXNARG], **argnp = NULL;		sym = db_search_symbol(callpc, DB_STGY_ANY, &offset);		db_symbol_values(sym, &name, NULL);		/*		 * Attempt to determine a (possibly fake) frame that gives		 * the caller's pc.  It may differ from `frame' if the		 * current function never sets up a standard frame or hasn't		 * set one up yet or has just discarded one.  The last two		 * cases can be guessed fairly reliably for code generated		 * by gcc.  The first case is too much trouble to handle in		 * general because the amount of junk on the stack depends		 * on the pc (the special handling of "calltrap", etc. in		 * db_nextframe() works because the `next' pc is special).		 */		actframe = frame;		if (first) {			if (!have_addr) {				int instr;				instr = db_get_value(callpc, 4, FALSE);				if ((instr & 0x00ffffff) == 0x00e58955) {					/* pushl %ebp; movl %esp, %ebp */					actframe = (struct i386_frame *)					    (SP_REGS(&ddb_regs) - 4);				} else if ((instr & 0x0000ffff) == 0x0000e589) {					/* movl %esp, %ebp */					actframe = (struct i386_frame *)					    SP_REGS(&ddb_regs);					if (ddb_regs.tf_ebp == 0) {						/* Fake caller's frame better. */						frame = actframe;					}				} else if ((instr & 0x000000ff) == 0x000000c3) {					/* ret */					actframe = (struct i386_frame *)					    (SP_REGS(&ddb_regs) - 4);				} else if (offset == 0) {					/* Probably a symbol in assembler code. */					actframe = (struct i386_frame *)					    (SP_REGS(&ddb_regs) - 4);				}			} else if (!strcmp(name, "fork_trampoline")) {				/*				 * Don't try to walk back on a stack for a				 * process that hasn't actually been run yet.				 */				db_print_stack_entry(name, 0, 0, 0, callpc);				break;			}			first = FALSE;		}		argp = &actframe->f_arg0;		narg = MAXNARG;		if (sym != NULL && db_sym_numargs(sym, &narg, argnames)) {			argnp = argnames;		} else {			narg = db_numargs(frame);		}		db_print_stack_entry(name, narg, argnp, argp, callpc);		if (actframe != frame) {			/* `frame' belongs to caller. */			callpc = (db_addr_t)			    db_get_value((int)&actframe->f_retaddr, 4, FALSE);			continue;		}		db_nextframe(&frame, &callpc);		if (INKERNEL((int) callpc) && !INKERNEL((int) frame)) {			sym = db_search_symbol(callpc, DB_STGY_ANY, &offset);			db_symbol_values(sym, &name, NULL);			db_print_stack_entry(name, 0, 0, 0, callpc);			break;		}		if (!INKERNEL((int) frame)) {			break;		}	}
count--
count
count
{		struct i386_frame *actframe;		int		narg;		const char *	name;		db_expr_t	offset;		c_db_sym_t	sym;#define MAXNARG	16		char	*argnames[MAXNARG], **argnp = NULL;		sym = db_search_symbol(callpc, DB_STGY_ANY, &offset);		db_symbol_values(sym, &name, NULL);		/*		 * Attempt to determine a (possibly fake) frame that gives		 * the caller's pc.  It may differ from `frame' if the		 * current function never sets up a standard frame or hasn't		 * set one up yet or has just discarded one.  The last two		 * cases can be guessed fairly reliably for code generated		 * by gcc.  The first case is too much trouble to handle in		 * general because the amount of junk on the stack depends		 * on the pc (the special handling of "calltrap", etc. in		 * db_nextframe() works because the `next' pc is special).		 */		actframe = frame;		if (first) {			if (!have_addr) {				int instr;				instr = db_get_value(callpc, 4, FALSE);				if ((instr & 0x00ffffff) == 0x00e58955) {					/* pushl %ebp; movl %esp, %ebp */					actframe = (struct i386_frame *)					    (SP_REGS(&ddb_regs) - 4);				} else if ((instr & 0x0000ffff) == 0x0000e589) {					/* movl %esp, %ebp */					actframe = (struct i386_frame *)					    SP_REGS(&ddb_regs);					if (ddb_regs.tf_ebp == 0) {						/* Fake caller's frame better. */						frame = actframe;					}				} else if ((instr & 0x000000ff) == 0x000000c3) {					/* ret */					actframe = (struct i386_frame *)					    (SP_REGS(&ddb_regs) - 4);				} else if (offset == 0) {					/* Probably a symbol in assembler code. */					actframe = (struct i386_frame *)					    (SP_REGS(&ddb_regs) - 4);				}			} else if (!strcmp(name, "fork_trampoline")) {				/*				 * Don't try to walk back on a stack for a				 * process that hasn't actually been run yet.				 */				db_print_stack_entry(name, 0, 0, 0, callpc);				break;			}			first = FALSE;		}		argp = &actframe->f_arg0;		narg = MAXNARG;		if (sym != NULL && db_sym_numargs(sym, &narg, argnames)) {			argnp = argnames;		} else {			narg = db_numargs(frame);		}		db_print_stack_entry(name, narg, argnp, argp, callpc);		if (actframe != frame) {			/* `frame' belongs to caller. */			callpc = (db_addr_t)			    db_get_value((int)&actframe->f_retaddr, 4, FALSE);			continue;		}		db_nextframe(&frame, &callpc);		if (INKERNEL((int) callpc) && !INKERNEL((int) frame)) {			sym = db_search_symbol(callpc, DB_STGY_ANY, &offset);			db_symbol_values(sym, &name, NULL);			db_print_stack_entry(name, 0, 0, 0, callpc);			break;		}		if (!INKERNEL((int) frame)) {			break;		}	}
struct i386_frame *actframe;
struct i386_frame *actframe;
struct i386_frame
i386_frame
*actframe
*
actframe
int		narg;
int		narg;
int
narg
narg
const char *	name;
const char *	name;
const char
*	name
*
name
db_expr_t	offset;
db_expr_t	offset;
db_expr_t
db_expr_t
offset
offset
c_db_sym_t	sym;
c_db_sym_t	sym;
c_db_sym_t
c_db_sym_t
sym
sym
char	*argnames[MAXNARG], **argnp = NULL;
char	*argnames[MAXNARG], **argnp = NULL;
char
*argnames[MAXNARG]
*
argnames
[MAXNARG]
MAXNARG
**argnp = NULL
*
*
argnp
= NULL
NULL
NULL
sym = db_search_symbol(callpc, DB_STGY_ANY, &offset);
sym = db_search_symbol(callpc, DB_STGY_ANY, &offset)
sym
sym
db_search_symbol(callpc, DB_STGY_ANY, &offset)
db_search_symbol
db_search_symbol
callpc
callpc
DB_STGY_ANY
DB_STGY_ANY
&offset
offset
offset
db_symbol_values(sym, &name, NULL);
db_symbol_values(sym, &name, NULL)
db_symbol_values
db_symbol_values
sym
sym
&name
name
name
NULL
NULL
actframe = frame;
actframe = frame
actframe
actframe
frame
frame
if (first) {			if (!have_addr) {				int instr;				instr = db_get_value(callpc, 4, FALSE);				if ((instr & 0x00ffffff) == 0x00e58955) {					/* pushl %ebp; movl %esp, %ebp */					actframe = (struct i386_frame *)					    (SP_REGS(&ddb_regs) - 4);				} else if ((instr & 0x0000ffff) == 0x0000e589) {					/* movl %esp, %ebp */					actframe = (struct i386_frame *)					    SP_REGS(&ddb_regs);					if (ddb_regs.tf_ebp == 0) {						/* Fake caller's frame better. */						frame = actframe;					}				} else if ((instr & 0x000000ff) == 0x000000c3) {					/* ret */					actframe = (struct i386_frame *)					    (SP_REGS(&ddb_regs) - 4);				} else if (offset == 0) {					/* Probably a symbol in assembler code. */					actframe = (struct i386_frame *)					    (SP_REGS(&ddb_regs) - 4);				}			} else if (!strcmp(name, "fork_trampoline")) {				/*				 * Don't try to walk back on a stack for a				 * process that hasn't actually been run yet.				 */				db_print_stack_entry(name, 0, 0, 0, callpc);				break;			}			first = FALSE;		}
first
first
{			if (!have_addr) {				int instr;				instr = db_get_value(callpc, 4, FALSE);				if ((instr & 0x00ffffff) == 0x00e58955) {					/* pushl %ebp; movl %esp, %ebp */					actframe = (struct i386_frame *)					    (SP_REGS(&ddb_regs) - 4);				} else if ((instr & 0x0000ffff) == 0x0000e589) {					/* movl %esp, %ebp */					actframe = (struct i386_frame *)					    SP_REGS(&ddb_regs);					if (ddb_regs.tf_ebp == 0) {						/* Fake caller's frame better. */						frame = actframe;					}				} else if ((instr & 0x000000ff) == 0x000000c3) {					/* ret */					actframe = (struct i386_frame *)					    (SP_REGS(&ddb_regs) - 4);				} else if (offset == 0) {					/* Probably a symbol in assembler code. */					actframe = (struct i386_frame *)					    (SP_REGS(&ddb_regs) - 4);				}			} else if (!strcmp(name, "fork_trampoline")) {				/*				 * Don't try to walk back on a stack for a				 * process that hasn't actually been run yet.				 */				db_print_stack_entry(name, 0, 0, 0, callpc);				break;			}			first = FALSE;		}
if (!have_addr) {				int instr;				instr = db_get_value(callpc, 4, FALSE);				if ((instr & 0x00ffffff) == 0x00e58955) {					/* pushl %ebp; movl %esp, %ebp */					actframe = (struct i386_frame *)					    (SP_REGS(&ddb_regs) - 4);				} else if ((instr & 0x0000ffff) == 0x0000e589) {					/* movl %esp, %ebp */					actframe = (struct i386_frame *)					    SP_REGS(&ddb_regs);					if (ddb_regs.tf_ebp == 0) {						/* Fake caller's frame better. */						frame = actframe;					}				} else if ((instr & 0x000000ff) == 0x000000c3) {					/* ret */					actframe = (struct i386_frame *)					    (SP_REGS(&ddb_regs) - 4);				} else if (offset == 0) {					/* Probably a symbol in assembler code. */					actframe = (struct i386_frame *)					    (SP_REGS(&ddb_regs) - 4);				}			} else if (!strcmp(name, "fork_trampoline")) {				/*				 * Don't try to walk back on a stack for a				 * process that hasn't actually been run yet.				 */				db_print_stack_entry(name, 0, 0, 0, callpc);				break;			}
!have_addr
have_addr
have_addr
{				int instr;				instr = db_get_value(callpc, 4, FALSE);				if ((instr & 0x00ffffff) == 0x00e58955) {					/* pushl %ebp; movl %esp, %ebp */					actframe = (struct i386_frame *)					    (SP_REGS(&ddb_regs) - 4);				} else if ((instr & 0x0000ffff) == 0x0000e589) {					/* movl %esp, %ebp */					actframe = (struct i386_frame *)					    SP_REGS(&ddb_regs);					if (ddb_regs.tf_ebp == 0) {						/* Fake caller's frame better. */						frame = actframe;					}				} else if ((instr & 0x000000ff) == 0x000000c3) {					/* ret */					actframe = (struct i386_frame *)					    (SP_REGS(&ddb_regs) - 4);				} else if (offset == 0) {					/* Probably a symbol in assembler code. */					actframe = (struct i386_frame *)					    (SP_REGS(&ddb_regs) - 4);				}			}
int instr;
int instr;
int
instr
instr
instr = db_get_value(callpc, 4, FALSE);
instr = db_get_value(callpc, 4, FALSE)
instr
instr
db_get_value(callpc, 4, FALSE)
db_get_value
db_get_value
callpc
callpc
4
FALSE
FALSE
if ((instr & 0x00ffffff) == 0x00e58955) {					/* pushl %ebp; movl %esp, %ebp */					actframe = (struct i386_frame *)					    (SP_REGS(&ddb_regs) - 4);				} else if ((instr & 0x0000ffff) == 0x0000e589) {					/* movl %esp, %ebp */					actframe = (struct i386_frame *)					    SP_REGS(&ddb_regs);					if (ddb_regs.tf_ebp == 0) {						/* Fake caller's frame better. */						frame = actframe;					}				} else if ((instr & 0x000000ff) == 0x000000c3) {					/* ret */					actframe = (struct i386_frame *)					    (SP_REGS(&ddb_regs) - 4);				} else if (offset == 0) {					/* Probably a symbol in assembler code. */					actframe = (struct i386_frame *)					    (SP_REGS(&ddb_regs) - 4);				}
(instr & 0x00ffffff) == 0x00e58955
(instr & 0x00ffffff)
instr & 0x00ffffff
instr
instr
0x00ffffff
0x00e58955
{					/* pushl %ebp; movl %esp, %ebp */					actframe = (struct i386_frame *)					    (SP_REGS(&ddb_regs) - 4);				}
actframe = (struct i386_frame *)					    (SP_REGS(&ddb_regs) - 4);
actframe = (struct i386_frame *)					    (SP_REGS(&ddb_regs) - 4)
actframe
actframe
(struct i386_frame *)					    (SP_REGS(&ddb_regs) - 4)
struct i386_frame *
struct i386_frame
i386_frame
*
*
(SP_REGS(&ddb_regs) - 4)
SP_REGS(&ddb_regs) - 4
SP_REGS(&ddb_regs)
SP_REGS
SP_REGS
&ddb_regs
ddb_regs
ddb_regs
4
if ((instr & 0x0000ffff) == 0x0000e589) {					/* movl %esp, %ebp */					actframe = (struct i386_frame *)					    SP_REGS(&ddb_regs);					if (ddb_regs.tf_ebp == 0) {						/* Fake caller's frame better. */						frame = actframe;					}				} else if ((instr & 0x000000ff) == 0x000000c3) {					/* ret */					actframe = (struct i386_frame *)					    (SP_REGS(&ddb_regs) - 4);				} else if (offset == 0) {					/* Probably a symbol in assembler code. */					actframe = (struct i386_frame *)					    (SP_REGS(&ddb_regs) - 4);				}
(instr & 0x0000ffff) == 0x0000e589
(instr & 0x0000ffff)
instr & 0x0000ffff
instr
instr
0x0000ffff
0x0000e589
{					/* movl %esp, %ebp */					actframe = (struct i386_frame *)					    SP_REGS(&ddb_regs);					if (ddb_regs.tf_ebp == 0) {						/* Fake caller's frame better. */						frame = actframe;					}				}
actframe = (struct i386_frame *)					    SP_REGS(&ddb_regs);
actframe = (struct i386_frame *)					    SP_REGS(&ddb_regs)
actframe
actframe
(struct i386_frame *)					    SP_REGS(&ddb_regs)
struct i386_frame *
struct i386_frame
i386_frame
*
*
SP_REGS(&ddb_regs)
SP_REGS
SP_REGS
&ddb_regs
ddb_regs
ddb_regs
if (ddb_regs.tf_ebp == 0) {						/* Fake caller's frame better. */						frame = actframe;					}
ddb_regs.tf_ebp == 0
ddb_regs.tf_ebp
ddb_regs
ddb_regs
tf_ebp
0
{						/* Fake caller's frame better. */						frame = actframe;					}
frame = actframe;
frame = actframe
frame
frame
actframe
actframe
if ((instr & 0x000000ff) == 0x000000c3) {					/* ret */					actframe = (struct i386_frame *)					    (SP_REGS(&ddb_regs) - 4);				} else if (offset == 0) {					/* Probably a symbol in assembler code. */					actframe = (struct i386_frame *)					    (SP_REGS(&ddb_regs) - 4);				}
(instr & 0x000000ff) == 0x000000c3
(instr & 0x000000ff)
instr & 0x000000ff
instr
instr
0x000000ff
0x000000c3
{					/* ret */					actframe = (struct i386_frame *)					    (SP_REGS(&ddb_regs) - 4);				}
actframe = (struct i386_frame *)					    (SP_REGS(&ddb_regs) - 4);
actframe = (struct i386_frame *)					    (SP_REGS(&ddb_regs) - 4)
actframe
actframe
(struct i386_frame *)					    (SP_REGS(&ddb_regs) - 4)
struct i386_frame *
struct i386_frame
i386_frame
*
*
(SP_REGS(&ddb_regs) - 4)
SP_REGS(&ddb_regs) - 4
SP_REGS(&ddb_regs)
SP_REGS
SP_REGS
&ddb_regs
ddb_regs
ddb_regs
4
if (offset == 0) {					/* Probably a symbol in assembler code. */					actframe = (struct i386_frame *)					    (SP_REGS(&ddb_regs) - 4);				}
offset == 0
offset
offset
0
{					/* Probably a symbol in assembler code. */					actframe = (struct i386_frame *)					    (SP_REGS(&ddb_regs) - 4);				}
actframe = (struct i386_frame *)					    (SP_REGS(&ddb_regs) - 4);
actframe = (struct i386_frame *)					    (SP_REGS(&ddb_regs) - 4)
actframe
actframe
(struct i386_frame *)					    (SP_REGS(&ddb_regs) - 4)
struct i386_frame *
struct i386_frame
i386_frame
*
*
(SP_REGS(&ddb_regs) - 4)
SP_REGS(&ddb_regs) - 4
SP_REGS(&ddb_regs)
SP_REGS
SP_REGS
&ddb_regs
ddb_regs
ddb_regs
4
if (!strcmp(name, "fork_trampoline")) {				/*				 * Don't try to walk back on a stack for a				 * process that hasn't actually been run yet.				 */				db_print_stack_entry(name, 0, 0, 0, callpc);				break;			}
!strcmp(name, "fork_trampoline")
strcmp(name, "fork_trampoline")
strcmp
strcmp
name
name
"fork_trampoline"
{				/*				 * Don't try to walk back on a stack for a				 * process that hasn't actually been run yet.				 */				db_print_stack_entry(name, 0, 0, 0, callpc);				break;			}
db_print_stack_entry(name, 0, 0, 0, callpc);
db_print_stack_entry(name, 0, 0, 0, callpc)
db_print_stack_entry
db_print_stack_entry
name
name
0
0
0
callpc
callpc
break;
first = FALSE;
first = FALSE
first
first
FALSE
FALSE
argp = &actframe->f_arg0;
argp = &actframe->f_arg0
argp
argp
&actframe->f_arg0
actframe->f_arg0
actframe
actframe
f_arg0
narg = MAXNARG;
narg = MAXNARG
narg
narg
MAXNARG
if (sym != NULL && db_sym_numargs(sym, &narg, argnames)) {			argnp = argnames;		} else {			narg = db_numargs(frame);		}
sym != NULL && db_sym_numargs(sym, &narg, argnames)
sym != NULL
sym
sym
NULL
NULL
db_sym_numargs(sym, &narg, argnames)
db_sym_numargs
db_sym_numargs
sym
sym
&narg
narg
narg
argnames
argnames
{			argnp = argnames;		}
argnp = argnames;
argnp = argnames
argnp
argnp
argnames
argnames
{			narg = db_numargs(frame);		}
narg = db_numargs(frame);
narg = db_numargs(frame)
narg
narg
db_numargs(frame)
db_numargs
db_numargs
frame
frame
db_print_stack_entry(name, narg, argnp, argp, callpc);
db_print_stack_entry(name, narg, argnp, argp, callpc)
db_print_stack_entry
db_print_stack_entry
name
name
narg
narg
argnp
argnp
argp
argp
callpc
callpc
if (actframe != frame) {			/* `frame' belongs to caller. */			callpc = (db_addr_t)			    db_get_value((int)&actframe->f_retaddr, 4, FALSE);			continue;		}
actframe != frame
actframe
actframe
frame
frame
{			/* `frame' belongs to caller. */			callpc = (db_addr_t)			    db_get_value((int)&actframe->f_retaddr, 4, FALSE);			continue;		}
callpc = (db_addr_t)			    db_get_value((int)&actframe->f_retaddr, 4, FALSE);
callpc = (db_addr_t)			    db_get_value((int)&actframe->f_retaddr, 4, FALSE)
callpc
callpc
(db_addr_t)			    db_get_value((int)&actframe->f_retaddr, 4, FALSE)
db_addr_t
db_addr_t
db_addr_t

db_get_value((int)&actframe->f_retaddr, 4, FALSE)
db_get_value
db_get_value
(int)&actframe->f_retaddr
int
int

&actframe->f_retaddr
actframe->f_retaddr
actframe
actframe
f_retaddr
4
FALSE
FALSE
continue;
db_nextframe(&frame, &callpc);
db_nextframe(&frame, &callpc)
db_nextframe
db_nextframe
&frame
frame
frame
&callpc
callpc
callpc
if (INKERNEL((int) callpc) && !INKERNEL((int) frame)) {			sym = db_search_symbol(callpc, DB_STGY_ANY, &offset);			db_symbol_values(sym, &name, NULL);			db_print_stack_entry(name, 0, 0, 0, callpc);			break;		}
INKERNEL((int) callpc) && !INKERNEL((int) frame)
INKERNEL((int) callpc)
INKERNEL
INKERNEL
(int) callpc
int
int

callpc
callpc
!INKERNEL((int) frame)
INKERNEL((int) frame)
INKERNEL
INKERNEL
(int) frame
int
int

frame
frame
{			sym = db_search_symbol(callpc, DB_STGY_ANY, &offset);			db_symbol_values(sym, &name, NULL);			db_print_stack_entry(name, 0, 0, 0, callpc);			break;		}
sym = db_search_symbol(callpc, DB_STGY_ANY, &offset);
sym = db_search_symbol(callpc, DB_STGY_ANY, &offset)
sym
sym
db_search_symbol(callpc, DB_STGY_ANY, &offset)
db_search_symbol
db_search_symbol
callpc
callpc
DB_STGY_ANY
DB_STGY_ANY
&offset
offset
offset
db_symbol_values(sym, &name, NULL);
db_symbol_values(sym, &name, NULL)
db_symbol_values
db_symbol_values
sym
sym
&name
name
name
NULL
NULL
db_print_stack_entry(name, 0, 0, 0, callpc);
db_print_stack_entry(name, 0, 0, 0, callpc)
db_print_stack_entry
db_print_stack_entry
name
name
0
0
0
callpc
callpc
break;
if (!INKERNEL((int) frame)) {			break;		}
!INKERNEL((int) frame)
INKERNEL((int) frame)
INKERNEL
INKERNEL
(int) frame
int
int

frame
frame
{			break;		}
break;
-----joern-----
(437,98,0)
(436,120,0)
(468,315,0)
(145,352,0)
(337,242,0)
(284,312,0)
(462,184,0)
(26,241,0)
(220,292,0)
(53,73,0)
(78,222,0)
(249,296,0)
(43,109,0)
(206,403,0)
(196,97,0)
(182,475,0)
(445,53,0)
(383,305,0)
(13,420,0)
(41,35,0)
(14,31,0)
(109,62,0)
(504,397,0)
(417,470,0)
(272,31,0)
(157,47,0)
(312,486,0)
(399,295,0)
(414,109,0)
(98,475,0)
(142,76,0)
(173,35,0)
(369,167,0)
(160,258,0)
(92,467,0)
(130,485,0)
(315,74,0)
(218,382,0)
(428,177,0)
(111,110,0)
(0,362,0)
(111,269,0)
(40,446,0)
(260,30,0)
(42,290,0)
(487,509,0)
(263,101,0)
(233,477,0)
(424,329,0)
(197,493,0)
(450,110,0)
(51,415,0)
(200,411,0)
(402,460,0)
(30,477,0)
(101,475,0)
(267,391,0)
(181,475,0)
(22,184,0)
(279,403,0)
(503,382,0)
(293,359,0)
(108,452,0)
(455,489,0)
(62,239,0)
(65,500,0)
(305,185,0)
(403,338,0)
(470,303,0)
(75,452,0)
(273,490,0)
(394,217,0)
(149,493,0)
(245,111,0)
(28,186,0)
(390,354,0)
(73,403,0)
(131,218,0)
(232,303,0)
(98,466,0)
(315,232,0)
(186,28,0)
(12,461,0)
(278,243,0)
(138,222,0)
(30,504,0)
(350,98,0)
(38,389,0)
(294,405,0)
(71,428,0)
(111,500,0)
(124,11,0)
(483,507,0)
(100,198,0)
(9,57,0)
(37,432,0)
(235,113,0)
(96,182,0)
(399,113,0)
(387,287,0)
(256,353,0)
(514,90,0)
(355,146,0)
(236,162,0)
(89,369,0)
(325,394,0)
(380,238,0)
(446,40,0)
(352,145,0)
(279,296,0)
(415,475,0)
(224,285,0)
(486,504,0)
(228,509,0)
(303,232,0)
(156,30,0)
(486,232,0)
(38,461,0)
(432,37,0)
(151,295,0)
(133,410,0)
(299,296,0)
(4,501,0)
(328,359,0)
(110,231,0)
(31,14,0)
(501,295,0)
(60,491,0)
(510,94,0)
(101,485,0)
(318,260,0)
(172,2,0)
(354,357,0)
(123,504,0)
(315,477,0)
(102,321,0)
(458,429,0)
(421,269,0)
(8,314,0)
(397,504,0)
(215,503,0)
(24,278,0)
(120,19,0)
(285,111,0)
(508,212,0)
(493,193,0)
(361,206,0)
(31,475,0)
(377,424,0)
(465,297,0)
(400,395,0)
(310,303,0)
(420,184,0)
(329,424,0)
(345,184,0)
(224,485,0)
(419,434,0)
(489,84,0)
(123,460,0)
(508,254,0)
(30,222,0)
(32,190,0)
(266,334,0)
(495,149,0)
(247,315,0)
(31,110,0)
(315,504,0)
(65,110,0)
(229,101,0)
(472,139,0)
(73,53,0)
(343,202,0)
(258,275,0)
(240,59,0)
(260,508,0)
(308,414,0)
(97,292,0)
(427,162,0)
(29,26,0)
(220,143,0)
(404,336,0)
(111,395,0)
(293,281,0)
(187,53,0)
(185,293,0)
(74,493,0)
(381,224,0)
(3,184,0)
(209,406,0)
(334,297,0)
(101,500,0)
(88,279,0)
(23,415,0)
(225,431,0)
(291,184,0)
(460,459,0)
(292,97,0)
(239,62,0)
(373,208,0)
(448,418,0)
(397,447,0)
(346,500,0)
(91,290,0)
(134,184,0)
(435,141,0)
(393,74,0)
(161,329,0)
(486,477,0)
(65,395,0)
(303,470,0)
(298,76,0)
(220,42,0)
(123,477,0)
(363,444,0)
(53,187,0)
(53,445,0)
(439,74,0)
(90,94,0)
(254,385,0)
(257,15,0)
(112,447,0)
(440,297,0)
(489,215,0)
(353,89,0)
(207,215,0)
(120,433,0)
(280,73,0)
(450,500,0)
(142,15,0)
(6,94,0)
(315,247,0)
(372,114,0)
(431,225,0)
(182,103,0)
(206,67,0)
(347,513,0)
(101,466,0)
(248,450,0)
(259,378,0)
(17,305,0)
(438,57,0)
(180,94,0)
(226,394,0)
(215,489,0)
(97,105,0)
(191,300,0)
(446,175,0)
(202,343,0)
(2,224,0)
(99,124,0)
(132,314,0)
(415,23,0)
(65,475,0)
(313,210,0)
(1,184,0)
(138,477,0)
(218,131,0)
(450,460,0)
(124,87,0)
(114,452,0)
(287,387,0)
(434,227,0)
(493,149,0)
(182,466,0)
(267,500,0)
(147,126,0)
(105,374,0)
(243,278,0)
(415,51,0)
(303,310,0)
(27,357,0)
(441,280,0)
(194,254,0)
(297,15,0)
(187,404,0)
(445,126,0)
(11,65,0)
(8,363,0)
(331,113,0)
(232,195,0)
(450,94,0)
(300,403,0)
(221,98,0)
(126,294,0)
(129,198,0)
(224,2,0)
(265,230,0)
(227,464,0)
(404,187,0)
(142,273,0)
(362,413,0)
(321,277,0)
(478,466,0)
(486,59,0)
(10,142,0)
(405,294,0)
(30,413,0)
(305,105,0)
(289,42,0)
(84,489,0)
(230,208,0)
(185,488,0)
(262,486,0)
(175,457,0)
(319,69,0)
(190,32,0)
(239,19,0)
(369,429,0)
(260,493,0)
(323,38,0)
(362,0,0)
(486,413,0)
(223,440,0)
(90,17,0)
(444,464,0)
(140,101,0)
(450,418,0)
(365,111,0)
(203,202,0)
(391,138,0)
(267,466,0)
(217,218,0)
(492,169,0)
(307,417,0)
(391,267,0)
(127,260,0)
(214,363,0)
(388,153,0)
(466,290,0)
(353,59,0)
(425,275,0)
(273,432,0)
(300,191,0)
(66,461,0)
(138,413,0)
(311,313,0)
(482,258,0)
(59,390,0)
(19,182,0)
(376,94,0)
(150,429,0)
(336,404,0)
(208,378,0)
(467,92,0)
(98,110,0)
(447,186,0)
(250,467,0)
(294,126,0)
(145,35,0)
(109,19,0)
(182,500,0)
(215,207,0)
(357,27,0)
(31,500,0)
(70,404,0)
(297,297,0)
(155,418,0)
(329,15,0)
(63,504,0)
(30,74,0)
(111,466,0)
(464,444,0)
(189,241,0)
(502,390,0)
(288,397,0)
(391,94,0)
(407,440,0)
(301,65,0)
(367,449,0)
(309,428,0)
(427,362,0)
(7,193,0)
(506,184,0)
(11,238,0)
(305,17,0)
(111,475,0)
(456,284,0)
(461,389,0)
(486,74,0)
(149,495,0)
(344,51,0)
(163,278,0)
(312,284,0)
(351,15,0)
(295,452,0)
(509,487,0)
(454,200,0)
(260,295,0)
(292,220,0)
(283,207,0)
(183,94,0)
(20,468,0)
(152,19,0)
(276,184,0)
(260,59,0)
(394,145,0)
(14,456,0)
(164,40,0)
(50,474,0)
(192,97,0)
(115,405,0)
(204,376,0)
(113,378,0)
(342,31,0)
(397,288,0)
(76,142,0)
(269,111,0)
(54,49,0)
(208,230,0)
(368,241,0)
(188,255,0)
(98,395,0)
(80,123,0)
(382,153,0)
(26,105,0)
(138,59,0)
(123,232,0)
(498,120,0)
(324,42,0)
(207,406,0)
(149,371,0)
(222,190,0)
(386,206,0)
(392,209,0)
(406,209,0)
(449,403,0)
(428,309,0)
(466,146,0)
(81,210,0)
(369,89,0)
(278,145,0)
(457,175,0)
(213,376,0)
(165,139,0)
(398,28,0)
(424,377,0)
(83,109,0)
(463,98,0)
(105,26,0)
(281,293,0)
(241,26,0)
(290,466,0)
(98,500,0)
(470,417,0)
(357,145,0)
(87,124,0)
(241,189,0)
(282,487,0)
(512,106,0)
(480,37,0)
(302,424,0)
(494,280,0)
(30,232,0)
(362,427,0)
(205,267,0)
(109,414,0)
(409,182,0)
(354,297,0)
(335,237,0)
(336,177,0)
(474,50,0)
(395,125,0)
(170,236,0)
(117,49,0)
(339,187,0)
(119,227,0)
(194,100,0)
(477,175,0)
(138,232,0)
(357,354,0)
(230,190,0)
(5,433,0)
(169,300,0)
(500,225,0)
(33,94,0)
(352,166,0)
(82,232,0)
(30,295,0)
(138,504,0)
(315,59,0)
(162,427,0)
(450,376,0)
(471,87,0)
(210,313,0)
(93,508,0)
(444,363,0)
(30,59,0)
(315,295,0)
(216,11,0)
(450,466,0)
(106,11,0)
(378,487,0)
(326,503,0)
(209,217,0)
(273,142,0)
(264,411,0)
(449,507,0)
(343,359,0)
(453,191,0)
(174,297,0)
(139,472,0)
(450,395,0)
(268,94,0)
(41,59,0)
(50,389,0)
(450,410,0)
(316,352,0)
(451,101,0)
(234,492,0)
(422,101,0)
(179,184,0)
(125,68,0)
(65,466,0)
(433,120,0)
(476,305,0)
(190,230,0)
(450,90,0)
(18,65,0)
(320,94,0)
(260,413,0)
(73,280,0)
(503,215,0)
(484,157,0)
(442,450,0)
(495,118,0)
(354,390,0)
(123,59,0)
(304,41,0)
(260,504,0)
(123,222,0)
(500,35,0)
(122,353,0)
(314,8,0)
(128,94,0)
(354,15,0)
(76,153,0)
(378,452,0)
(19,94,0)
(475,415,0)
(65,11,0)
(199,450,0)
(443,110,0)
(486,295,0)
(137,486,0)
(416,105,0)
(360,208,0)
(141,243,0)
(408,153,0)
(154,94,0)
(444,445,0)
(254,508,0)
(79,41,0)
(17,90,0)
(271,285,0)
(260,185,0)
(296,279,0)
(74,85,0)
(31,466,0)
(334,15,0)
(101,110,0)
(333,450,0)
(251,124,0)
(305,493,0)
(125,395,0)
(286,51,0)
(270,242,0)
(98,148,0)
(460,123,0)
(434,177,0)
(100,194,0)
(45,50,0)
(120,94,0)
(144,138,0)
(430,106,0)
(25,106,0)
(340,94,0)
(426,413,0)
(237,477,0)
(329,297,0)
(505,449,0)
(306,239,0)
(464,227,0)
(48,357,0)
(225,429,0)
(432,273,0)
(169,492,0)
(290,91,0)
(315,413,0)
(414,376,0)
(211,377,0)
(243,141,0)
(300,169,0)
(290,42,0)
(267,475,0)
(166,352,0)
(110,47,0)
(260,74,0)
(370,98,0)
(280,177,0)
(42,220,0)
(107,338,0)
(246,195,0)
(189,255,0)
(49,232,0)
(260,222,0)
(418,94,0)
(395,195,0)
(366,334,0)
(390,502,0)
(260,477,0)
(356,483,0)
(317,103,0)
(143,220,0)
(315,468,0)
(322,452,0)
(77,185,0)
(406,207,0)
(30,94,0)
(141,329,0)
(496,145,0)
(123,295,0)
(497,92,0)
(363,8,0)
(332,315,0)
(39,420,0)
(113,399,0)
(399,104,0)
(411,200,0)
(490,273,0)
(477,231,0)
(511,336,0)
(51,378,0)
(104,399,0)
(182,19,0)
(21,35,0)
(225,500,0)
(413,362,0)
(138,295,0)
(198,100,0)
(401,238,0)
(61,427,0)
(141,435,0)
(410,261,0)
(118,495,0)
(260,232,0)
(97,30,0)
(479,65,0)
(379,252,0)
(375,94,0)
(469,405,0)
(123,413,0)
(295,399,0)
(162,236,0)
(52,294,0)
(349,67,0)
(403,73,0)
(384,148,0)
(356,319,0)
(364,118,0)
(167,369,0)
(359,293,0)
(387,377,0)
(481,354,0)
(405,177,0)
(182,395,0)
(486,222,0)
(473,314,0)
(423,68,0)
(429,369,0)
(175,446,0)
(499,411,0)
(356,349,0)
(371,149,0)
(106,512,0)
(382,387,0)
(44,139,0)
(37,145,0)
(429,225,0)
(34,8,0)
(267,110,0)
(314,177,0)
(59,35,0)
(64,178,0)
(394,325,0)
(396,300,0)
(178,69,0)
(255,189,0)
(305,30,0)
(97,508,0)
(385,254,0)
(126,445,0)
(285,485,0)
(260,105,0)
(182,110,0)
(274,492,0)
(136,191,0)
(26,29,0)
(358,464,0)
(56,184,0)
(47,157,0)
(475,452,0)
(175,477,0)
(467,11,0)
(46,37,0)
(486,262,0)
(142,297,0)
(447,397,0)
(217,209,0)
(116,30,0)
(468,20,0)
(327,509,0)
(111,285,0)
(97,185,0)
(377,387,0)
(168,377,0)
(503,86,0)
(252,277,0)
(176,224,0)
(329,141,0)
(218,217,0)
(16,194,0)
(62,109,0)
(305,508,0)
(359,343,0)
(486,312,0)
(424,302,0)
(72,434,0)
(440,15,0)
(86,503,0)
(267,395,0)
(227,434,0)
(103,182,0)
(89,353,0)
(201,218,0)
(293,185,0)
(158,313,0)
(450,475,0)
(36,239,0)
(159,94,0)
(95,231,0)
(244,450,0)
(487,378,0)
(101,395,0)
(352,177,0)
(315,222,0)
(123,74,0)
(55,382,0)
(412,403,0)
(190,222,0)
(341,237,0)
(121,467,0)
(390,59,0)
(219,474,0)
(330,410,0)
(186,447,0)
(135,512,0)
(348,501,0)
(217,394,0)
(58,336,0)
(445,444,0)
(138,391,0)
(47,110,0)
(31,395,0)
(489,145,0)
(68,125,0)
(138,74,0)
(387,382,0)
(97,493,0)
(31,342,0)
(456,14,0)
(284,456,0)
(254,194,0)
(10,273,1)
(147,294,1)
(451,422,1)
(190,32,1)
(315,413,1)
(440,297,1)
(409,152,1)
(160,472,1)
(16,100,1)
(299,249,1)
(449,367,1)
(378,487,1)
(253,279,1)
(243,278,1)
(330,62,1)
(482,160,1)
(473,126,1)
(41,79,1)
(73,53,1)
(460,123,1)
(234,403,1)
(286,344,1)
(220,292,1)
(98,110,1)
(73,280,1)
(354,357,1)
(273,490,1)
(493,149,1)
(239,19,1)
(169,492,1)
(270,87,1)
(122,256,1)
(352,177,1)
(2,172,1)
(141,435,1)
(391,138,1)
(156,116,1)
(227,119,1)
(471,124,1)
(141,243,1)
(411,264,1)
(359,343,1)
(505,57,1)
(97,185,1)
(182,475,1)
(445,126,1)
(260,493,1)
(30,477,1)
(349,206,1)
(260,222,1)
(474,219,1)
(245,271,1)
(450,475,1)
(31,466,1)
(210,81,1)
(60,406,1)
(421,365,1)
(220,143,1)
(312,486,1)
(142,273,1)
(97,196,1)
(469,115,1)
(65,466,1)
(160,105,1)
(257,145,1)
(390,502,1)
(120,498,1)
(334,15,1)
(298,406,1)
(252,277,1)
(382,387,1)
(170,426,1)
(271,456,1)
(343,202,1)
(13,475,1)
(356,349,1)
(182,103,1)
(31,342,1)
(241,368,1)
(172,381,1)
(397,447,1)
(160,185,1)
(66,50,1)
(413,362,1)
(31,475,1)
(416,242,1)
(396,492,1)
(254,385,1)
(216,321,1)
(399,113,1)
(433,5,1)
(267,475,1)
(273,432,1)
(217,218,1)
(129,93,1)
(111,500,1)
(323,420,1)
(370,463,1)
(123,74,1)
(363,214,1)
(151,378,1)
(472,139,1)
(187,404,1)
(203,77,1)
(297,15,1)
(269,421,1)
(357,48,1)
(158,311,1)
(101,395,1)
(200,454,1)
(336,177,1)
(395,125,1)
(208,373,1)
(420,39,1)
(280,494,1)
(118,364,1)
(267,395,1)
(186,28,1)
(26,241,1)
(321,277,1)
(357,27,1)
(121,11,1)
(498,433,1)
(366,15,1)
(429,369,1)
(283,215,1)
(348,4,1)
(353,122,1)
(14,31,1)
(207,215,1)
(461,12,1)
(88,296,1)
(68,423,1)
(260,127,1)
(226,218,1)
(318,450,1)
(55,334,1)
(236,170,1)
(379,461,1)
(314,132,1)
(38,323,1)
(123,295,1)
(92,497,1)
(78,501,1)
(62,109,1)
(356,130,1)
(119,434,1)
(199,442,1)
(294,52,1)
(138,477,1)
(162,236,1)
(446,40,1)
(376,204,1)
(161,141,1)
(120,433,1)
(174,76,1)
(303,310,1)
(210,313,1)
(50,389,1)
(5,436,1)
(137,14,1)
(323,355,1)
(406,207,1)
(456,284,1)
(366,297,1)
(4,295,1)
(461,389,1)
(97,30,1)
(18,479,1)
(51,286,1)
(101,110,1)
(102,171,1)
(123,232,1)
(63,237,1)
(481,357,1)
(20,468,1)
(295,399,1)
(37,46,1)
(436,19,1)
(241,189,1)
(432,37,1)
(304,59,1)
(221,370,1)
(356,347,1)
(397,288,1)
(333,248,1)
(484,443,1)
(267,110,1)
(384,98,1)
(381,285,1)
(369,167,1)
(407,60,1)
(97,493,1)
(305,493,1)
(30,156,1)
(201,382,1)
(138,232,1)
(407,334,1)
(123,222,1)
(37,145,1)
(198,129,1)
(463,472,1)
(362,427,1)
(61,162,1)
(263,229,1)
(367,505,1)
(315,477,1)
(331,235,1)
(11,65,1)
(116,120,1)
(296,299,1)
(489,84,1)
(244,333,1)
(501,348,1)
(117,232,1)
(324,220,1)
(267,205,1)
(470,417,1)
(418,155,1)
(305,185,1)
(305,476,1)
(211,424,1)
(260,477,1)
(196,192,1)
(9,438,1)
(62,239,1)
(206,403,1)
(440,223,1)
(240,440,1)
(430,92,1)
(412,309,1)
(394,145,1)
(255,188,1)
(64,440,1)
(139,165,1)
(347,20,1)
(65,395,1)
(182,395,1)
(80,402,1)
(58,280,1)
(387,287,1)
(149,371,1)
(248,460,1)
(489,145,1)
(386,361,1)
(228,259,1)
(98,437,1)
(113,378,1)
(487,509,1)
(442,244,1)
(406,209,1)
(79,304,1)
(132,473,1)
(443,504,1)
(144,260,1)
(38,461,1)
(190,230,1)
(77,92,1)
(97,508,1)
(453,136,1)
(54,117,1)
(264,499,1)
(282,509,1)
(393,439,1)
(83,414,1)
(260,508,1)
(272,391,1)
(65,301,1)
(13,395,1)
(334,266,1)
(30,413,1)
(479,216,1)
(57,9,1)
(398,63,1)
(394,325,1)
(103,317,1)
(46,480,1)
(256,346,1)
(41,59,1)
(399,104,1)
(225,431,1)
(97,105,1)
(352,166,1)
(464,227,1)
(351,257,1)
(142,10,1)
(427,162,1)
(106,25,1)
(483,449,1)
(30,74,1)
(237,477,1)
(359,328,1)
(126,147,1)
(301,18,1)
(189,255,1)
(466,290,1)
(8,314,1)
(450,410,1)
(360,78,1)
(138,295,1)
(111,110,1)
(52,405,1)
(260,30,1)
(65,475,1)
(489,455,1)
(356,38,1)
(447,112,1)
(207,283,1)
(138,74,1)
(109,83,1)
(387,377,1)
(486,232,1)
(176,2,1)
(181,222,1)
(101,500,1)
(13,500,1)
(274,234,1)
(135,106,1)
(12,66,1)
(155,448,1)
(455,503,1)
(377,424,1)
(42,289,1)
(218,201,1)
(443,237,1)
(17,305,1)
(209,392,1)
(127,318,1)
(150,458,1)
(160,242,1)
(260,295,1)
(450,418,1)
(337,270,1)
(441,412,1)
(424,302,1)
(112,186,1)
(464,358,1)
(486,262,1)
(138,59,1)
(160,200,1)
(90,17,1)
(315,295,1)
(358,227,1)
(30,222,1)
(171,30,1)
(379,50,1)
(294,405,1)
(217,394,1)
(250,121,1)
(503,86,1)
(309,428,1)
(414,308,1)
(292,97,1)
(230,208,1)
(496,309,1)
(280,177,1)
(428,177,1)
(450,466,1)
(334,297,1)
(450,110,1)
(265,208,1)
(486,295,1)
(76,142,1)
(242,337,1)
(209,217,1)
(260,59,1)
(223,407,1)
(232,303,1)
(113,331,1)
(503,326,1)
(511,58,1)
(323,20,1)
(204,213,1)
(300,191,1)
(332,456,1)
(26,29,1)
(329,297,1)
(512,135,1)
(267,500,1)
(356,384,1)
(48,240,1)
(182,466,1)
(87,124,1)
(233,252,1)
(101,466,1)
(438,279,1)
(486,59,1)
(213,90,1)
(305,508,1)
(111,475,1)
(290,42,1)
(81,313,1)
(512,106,1)
(165,44,1)
(329,161,1)
(285,111,1)
(65,110,1)
(249,169,1)
(487,282,1)
(185,293,1)
(447,186,1)
(51,378,1)
(50,474,1)
(43,239,1)
(494,441,1)
(218,131,1)
(423,400,1)
(450,90,1)
(42,220,1)
(329,15,1)
(356,483,1)
(438,253,1)
(317,96,1)
(260,504,1)
(426,49,1)
(293,281,1)
(394,226,1)
(124,11,1)
(327,228,1)
(30,504,1)
(444,363,1)
(214,8,1)
(123,413,1)
(326,209,1)
(260,232,1)
(429,150,1)
(93,87,1)
(74,393,1)
(391,267,1)
(30,59,1)
(405,177,1)
(106,11,1)
(501,295,1)
(259,210,1)
(98,395,1)
(19,182,1)
(477,175,1)
(248,410,1)
(341,335,1)
(160,508,1)
(314,177,1)
(82,169,1)
(219,45,1)
(260,105,1)
(476,383,1)
(450,460,1)
(53,187,1)
(454,411,1)
(368,189,1)
(486,413,1)
(390,354,1)
(404,336,1)
(126,294,1)
(140,263,1)
(278,145,1)
(392,217,1)
(410,133,1)
(458,369,1)
(486,504,1)
(163,55,1)
(181,501,1)
(30,295,1)
(313,158,1)
(205,138,1)
(315,59,1)
(305,105,1)
(504,397,1)
(279,296,1)
(175,457,1)
(72,419,1)
(224,285,1)
(290,91,1)
(30,232,1)
(353,59,1)
(499,493,1)
(315,247,1)
(500,225,1)
(111,269,1)
(31,110,1)
(266,366,1)
(157,484,1)
(138,222,1)
(110,47,1)
(415,51,1)
(278,24,1)
(187,339,1)
(123,477,1)
(315,504,1)
(53,445,1)
(47,157,1)
(402,62,1)
(123,504,1)
(191,453,1)
(465,174,1)
(34,314,1)
(448,38,1)
(495,118,1)
(178,64,1)
(254,194,1)
(8,34,1)
(138,144,1)
(251,99,1)
(65,500,1)
(237,341,1)
(346,41,1)
(303,470,1)
(467,250,1)
(468,315,1)
(405,469,1)
(514,258,1)
(31,272,1)
(419,363,1)
(475,415,1)
(400,413,1)
(197,512,1)
(450,376,1)
(44,321,1)
(328,343,1)
(315,232,1)
(514,171,1)
(417,307,1)
(279,88,1)
(36,306,1)
(229,451,1)
(361,210,1)
(434,177,1)
(308,43,1)
(111,466,1)
(383,514,1)
(508,254,1)
(329,141,1)
(437,350,1)
(267,466,1)
(105,26,1)
(125,68,1)
(444,464,1)
(335,477,1)
(101,140,1)
(130,101,1)
(365,245,1)
(486,222,1)
(260,413,1)
(373,360,1)
(31,500,1)
(434,72,1)
(87,471,1)
(89,353,1)
(31,395,1)
(98,475,1)
(138,413,1)
(202,203,1)
(206,386,1)
(284,312,1)
(297,465,1)
(39,13,1)
(24,163,1)
(486,137,1)
(364,197,1)
(124,251,1)
(101,475,1)
(145,352,1)
(260,74,1)
(456,14,1)
(252,379,1)
(188,416,1)
(354,15,1)
(239,36,1)
(509,327,1)
(218,382,1)
(339,404,1)
(486,74,1)
(357,145,1)
(142,15,1)
(439,200,1)
(164,233,1)
(306,376,1)
(427,61,1)
(152,418,1)
(354,481,1)
(350,221,1)
(354,297,1)
(307,82,1)
(258,482,1)
(503,382,1)
(138,504,1)
(111,395,1)
(321,102,1)
(222,190,1)
(449,403,1)
(414,376,1)
(224,176,1)
(200,411,1)
(99,512,1)
(133,330,1)
(136,396,1)
(194,16,1)
(13,110,1)
(235,151,1)
(450,199,1)
(109,414,1)
(96,409,1)
(182,110,1)
(293,359,1)
(316,496,1)
(478,260,1)
(168,211,1)
(319,178,1)
(230,265,1)
(28,398,1)
(315,74,1)
(311,57,1)
(59,390,1)
(142,297,1)
(467,11,1)
(149,495,1)
(215,503,1)
(289,324,1)
(208,378,1)
(369,89,1)
(377,168,1)
(92,467,1)
(415,23,1)
(315,332,1)
(344,181,1)
(109,19,1)
(25,430,1)
(175,446,1)
(49,232,1)
(49,54,1)
(215,489,1)
(486,477,1)
(480,298,1)
(100,198,1)
(71,252,1)
(120,19,1)
(169,300,1)
(356,319,1)
(227,434,1)
(352,316,1)
(70,336,1)
(40,164,1)
(38,389,1)
(160,74,1)
(424,329,1)
(450,500,1)
(450,395,1)
(225,429,1)
(362,0,1)
(297,297,1)
(98,466,1)
(123,80,1)
(182,500,1)
(305,30,1)
(400,49,1)
(74,493,1)
(404,70,1)
(497,467,1)
(279,403,1)
(492,274,1)
(98,500,1)
(194,100,1)
(260,185,1)
(300,403,1)
(192,478,1)
(422,224,1)
(440,15,1)
(224,2,1)
(15,351,1)
(315,222,1)
(115,187,1)
(363,8,1)
(403,73,1)
(123,59,1)
(336,511,1)
(428,71,1)
(355,466,1)
(445,444,1)
(305,508,2)
(333,171,2)
(498,38,2)
(36,472,2)
(329,15,2)
(445,309,2)
(316,309,2)
(376,472,2)
(350,472,2)
(315,232,2)
(299,169,2)
(382,334,2)
(206,210,2)
(357,145,2)
(90,17,2)
(442,321,2)
(106,11,2)
(411,512,2)
(377,424,2)
(496,309,2)
(123,62,2)
(465,406,2)
(393,200,2)
(456,284,2)
(17,171,2)
(300,492,2)
(97,185,2)
(157,252,2)
(63,237,2)
(305,171,2)
(185,293,2)
(138,260,2)
(477,175,2)
(399,104,2)
(118,512,2)
(432,37,2)
(135,92,2)
(50,389,2)
(332,456,2)
(303,169,2)
(30,222,2)
(92,467,2)
(150,440,2)
(239,472,2)
(245,456,2)
(210,57,2)
(470,169,2)
(224,285,2)
(359,343,2)
(98,466,2)
(466,260,2)
(207,209,2)
(137,14,2)
(484,252,2)
(58,309,2)
(239,321,2)
(208,378,2)
(307,169,2)
(486,477,2)
(225,431,2)
(278,145,2)
(337,87,2)
(330,62,2)
(390,440,2)
(98,472,2)
(428,177,2)
(31,466,2)
(397,447,2)
(61,49,2)
(424,302,2)
(39,252,2)
(190,230,2)
(378,487,2)
(312,486,2)
(469,309,2)
(404,336,2)
(138,232,2)
(501,210,2)
(141,243,2)
(508,87,2)
(116,38,2)
(476,472,2)
(475,415,2)
(217,334,2)
(451,456,2)
(504,237,2)
(62,109,2)
(476,171,2)
(514,321,2)
(174,406,2)
(318,472,2)
(344,210,2)
(182,103,2)
(218,382,2)
(391,267,2)
(65,321,2)
(461,389,2)
(355,260,2)
(495,118,2)
(304,440,2)
(450,410,2)
(395,125,2)
(348,210,2)
(336,177,2)
(26,241,2)
(351,309,2)
(349,210,2)
(309,252,2)
(489,84,2)
(237,252,2)
(260,477,2)
(382,387,2)
(98,475,2)
(323,20,2)
(356,349,2)
(220,143,2)
(17,472,2)
(264,512,2)
(257,309,2)
(147,309,2)
(169,300,2)
(274,309,2)
(209,217,2)
(460,62,2)
(434,309,2)
(217,394,2)
(483,57,2)
(222,501,2)
(109,414,2)
(51,210,2)
(260,321,2)
(266,309,2)
(285,111,2)
(182,500,2)
(30,504,2)
(199,171,2)
(12,50,2)
(18,321,2)
(8,309,2)
(125,169,2)
(420,169,2)
(429,369,2)
(284,14,2)
(65,500,2)
(356,319,2)
(138,74,2)
(293,359,2)
(13,440,2)
(460,123,2)
(323,440,2)
(273,406,2)
(315,59,2)
(204,171,2)
(225,429,2)
(98,500,2)
(162,236,2)
(201,334,2)
(165,321,2)
(199,472,2)
(89,440,2)
(77,92,2)
(432,406,2)
(222,190,2)
(323,169,2)
(333,472,2)
(505,57,2)
(424,334,2)
(100,198,2)
(189,242,2)
(160,472,2)
(447,186,2)
(123,295,2)
(213,472,2)
(65,475,2)
(387,334,2)
(111,456,2)
(450,110,2)
(456,14,2)
(234,309,2)
(450,460,2)
(362,427,2)
(198,87,2)
(305,472,2)
(182,466,2)
(197,512,2)
(111,269,2)
(267,475,2)
(215,209,2)
(290,260,2)
(99,512,2)
(387,377,2)
(224,2,2)
(403,309,2)
(65,110,2)
(359,92,2)
(42,220,2)
(182,475,2)
(119,309,2)
(171,38,2)
(113,378,2)
(280,309,2)
(267,500,2)
(123,59,2)
(90,472,2)
(130,456,2)
(479,321,2)
(303,470,2)
(26,29,2)
(239,19,2)
(397,237,2)
(240,440,2)
(51,378,2)
(98,110,2)
(254,194,2)
(434,177,2)
(123,413,2)
(175,457,2)
(227,434,2)
(101,456,2)
(260,508,2)
(194,100,2)
(105,242,2)
(446,252,2)
(384,472,2)
(163,334,2)
(34,309,2)
(343,202,2)
(53,445,2)
(426,49,2)
(30,59,2)
(59,390,2)
(126,309,2)
(289,260,2)
(145,352,2)
(450,321,2)
(453,492,2)
(504,397,2)
(509,210,2)
(254,385,2)
(105,26,2)
(258,321,2)
(271,456,2)
(423,169,2)
(39,210,2)
(38,260,2)
(415,210,2)
(98,395,2)
(102,171,2)
(319,440,2)
(71,252,2)
(450,500,2)
(97,30,2)
(53,187,2)
(176,456,2)
(127,171,2)
(315,477,2)
(442,472,2)
(40,252,2)
(232,303,2)
(415,51,2)
(323,260,2)
(37,406,2)
(369,89,2)
(213,321,2)
(352,177,2)
(13,169,2)
(236,49,2)
(347,20,2)
(30,295,2)
(170,49,2)
(136,492,2)
(392,334,2)
(78,501,2)
(395,169,2)
(115,309,2)
(44,321,2)
(156,38,2)
(209,334,2)
(172,456,2)
(328,92,2)
(113,210,2)
(357,27,2)
(391,138,2)
(406,207,2)
(293,281,2)
(503,209,2)
(377,334,2)
(323,210,2)
(315,222,2)
(405,309,2)
(199,321,2)
(30,477,2)
(468,456,2)
(204,321,2)
(440,309,2)
(306,171,2)
(449,57,2)
(430,92,2)
(255,242,2)
(367,57,2)
(383,321,2)
(512,92,2)
(309,428,2)
(280,177,2)
(468,315,2)
(237,477,2)
(4,210,2)
(439,200,2)
(311,57,2)
(486,14,2)
(263,456,2)
(123,222,2)
(436,38,2)
(15,309,2)
(39,169,2)
(406,334,2)
(88,169,2)
(207,215,2)
(514,472,2)
(445,126,2)
(354,440,2)
(412,309,2)
(279,403,2)
(244,472,2)
(467,11,2)
(353,440,2)
(313,57,2)
(492,309,2)
(226,334,2)
(151,210,2)
(447,237,2)
(65,466,2)
(463,472,2)
(97,260,2)
(450,171,2)
(101,475,2)
(112,237,2)
(286,210,2)
(336,309,2)
(373,501,2)
(73,309,2)
(14,31,2)
(48,440,2)
(90,171,2)
(138,222,2)
(300,403,2)
(450,395,2)
(482,321,2)
(62,321,2)
(440,15,2)
(394,145,2)
(493,512,2)
(369,167,2)
(409,38,2)
(260,504,2)
(400,169,2)
(81,57,2)
(256,440,2)
(378,210,2)
(93,87,2)
(420,252,2)
(410,62,2)
(396,492,2)
(301,321,2)
(486,59,2)
(354,297,2)
(503,382,2)
(352,309,2)
(354,357,2)
(442,171,2)
(487,210,2)
(149,512,2)
(120,19,2)
(96,38,2)
(362,0,2)
(28,237,2)
(413,362,2)
(190,501,2)
(341,252,2)
(444,309,2)
(210,313,2)
(64,440,2)
(267,110,2)
(53,309,2)
(160,321,2)
(248,321,2)
(117,169,2)
(41,59,2)
(486,232,2)
(49,232,2)
(278,334,2)
(444,464,2)
(243,278,2)
(429,440,2)
(253,279,2)
(127,321,2)
(360,501,2)
(353,59,2)
(305,185,2)
(97,105,2)
(394,325,2)
(228,210,2)
(178,440,2)
(100,87,2)
(251,512,2)
(318,321,2)
(101,500,2)
(406,209,2)
(62,239,2)
(306,472,2)
(314,177,2)
(123,504,2)
(79,440,2)
(511,309,2)
(333,321,2)
(306,321,2)
(59,440,2)
(424,329,2)
(127,472,2)
(66,50,2)
(19,182,2)
(260,105,2)
(420,440,2)
(230,501,2)
(158,57,2)
(241,189,2)
(273,490,2)
(495,512,2)
(74,493,2)
(335,252,2)
(440,297,2)
(329,297,2)
(420,210,2)
(394,334,2)
(233,252,2)
(258,472,2)
(76,142,2)
(188,242,2)
(296,169,2)
(52,309,2)
(448,38,2)
(260,222,2)
(514,171,2)
(404,309,2)
(110,47,2)
(329,141,2)
(47,157,2)
(260,493,2)
(472,321,2)
(17,321,2)
(248,472,2)
(38,20,2)
(413,49,2)
(427,162,2)
(106,92,2)
(225,440,2)
(260,232,2)
(76,406,2)
(11,321,2)
(31,475,2)
(132,309,2)
(489,209,2)
(16,87,2)
(279,296,2)
(397,288,2)
(97,493,2)
(260,295,2)
(472,139,2)
(458,440,2)
(358,309,2)
(324,260,2)
(441,309,2)
(334,309,2)
(450,418,2)
(250,321,2)
(449,403,2)
(315,413,2)
(476,321,2)
(82,169,2)
(215,489,2)
(417,169,2)
(450,466,2)
(317,38,2)
(260,171,2)
(31,395,2)
(217,218,2)
(47,252,2)
(175,252,2)
(242,87,2)
(356,483,2)
(19,38,2)
(31,260,2)
(20,468,2)
(414,376,2)
(120,433,2)
(139,321,2)
(124,512,2)
(164,252,2)
(486,74,2)
(467,321,2)
(218,334,2)
(254,87,2)
(284,312,2)
(438,169,2)
(205,260,2)
(141,435,2)
(202,92,2)
(169,309,2)
(187,404,2)
(480,406,2)
(54,169,2)
(497,321,2)
(8,314,2)
(168,334,2)
(211,334,2)
(486,262,2)
(399,113,2)
(26,242,2)
(30,74,2)
(31,110,2)
(327,210,2)
(487,509,2)
(402,62,2)
(142,406,2)
(72,309,2)
(314,309,2)
(152,38,2)
(305,321,2)
(499,512,2)
(312,14,2)
(10,406,2)
(305,493,2)
(427,49,2)
(450,472,2)
(37,145,2)
(512,106,2)
(308,239,2)
(111,500,2)
(30,413,2)
(62,472,2)
(46,406,2)
(366,309,2)
(473,309,2)
(260,185,2)
(303,310,2)
(14,260,2)
(123,477,2)
(68,169,2)
(196,260,2)
(60,406,2)
(318,171,2)
(223,309,2)
(25,92,2)
(186,237,2)
(446,40,2)
(187,309,2)
(241,242,2)
(339,309,2)
(486,504,2)
(391,260,2)
(508,254,2)
(354,15,2)
(244,321,2)
(334,406,2)
(361,210,2)
(305,105,2)
(149,495,2)
(315,295,2)
(362,49,2)
(138,413,2)
(399,210,2)
(428,252,2)
(383,171,2)
(162,49,2)
(97,508,2)
(230,208,2)
(329,334,2)
(2,456,2)
(433,38,2)
(501,295,2)
(376,171,2)
(161,334,2)
(294,309,2)
(486,295,2)
(142,15,2)
(39,440,2)
(38,389,2)
(295,399,2)
(294,405,2)
(346,440,2)
(24,334,2)
(295,210,2)
(235,210,2)
(315,74,2)
(129,87,2)
(141,334,2)
(181,210,2)
(5,38,2)
(403,73,2)
(493,149,2)
(419,309,2)
(227,309,2)
(142,297,2)
(62,171,2)
(450,475,2)
(190,32,2)
(182,395,2)
(140,456,2)
(321,171,2)
(315,456,2)
(478,260,2)
(437,472,2)
(206,403,2)
(326,209,2)
(297,297,2)
(175,446,2)
(464,309,2)
(331,210,2)
(481,440,2)
(260,413,2)
(297,15,2)
(376,321,2)
(185,92,2)
(124,11,2)
(293,92,2)
(471,512,2)
(38,461,2)
(103,38,2)
(265,501,2)
(111,110,2)
(290,91,2)
(290,42,2)
(365,456,2)
(272,260,2)
(110,252,2)
(189,255,2)
(315,504,2)
(191,492,2)
(285,456,2)
(182,110,2)
(13,210,2)
(41,440,2)
(133,62,2)
(267,395,2)
(11,65,2)
(194,87,2)
(470,417,2)
(421,456,2)
(407,309,2)
(142,273,2)
(36,321,2)
(334,15,2)
(220,292,2)
(138,59,2)
(297,406,2)
(155,38,2)
(239,171,2)
(343,92,2)
(213,171,2)
(89,353,2)
(363,309,2)
(390,354,2)
(121,321,2)
(38,169,2)
(87,512,2)
(38,210,2)
(221,472,2)
(466,290,2)
(138,295,2)
(224,456,2)
(252,277,2)
(266,406,2)
(416,242,2)
(405,177,2)
(368,242,2)
(57,169,2)
(200,411,2)
(249,169,2)
(111,475,2)
(20,456,2)
(364,512,2)
(38,440,2)
(38,252,2)
(383,472,2)
(260,472,2)
(138,504,2)
(70,309,2)
(387,287,2)
(30,38,2)
(182,38,2)
(475,210,2)
(243,334,2)
(215,503,2)
(454,512,2)
(200,512,2)
(386,210,2)
(450,376,2)
(323,252,2)
(83,239,2)
(149,371,2)
(267,466,2)
(92,321,2)
(321,277,2)
(366,406,2)
(273,432,2)
(74,200,2)
(500,225,2)
(418,38,2)
(282,210,2)
(220,260,2)
(370,472,2)
(456,260,2)
(464,227,2)
(169,492,2)
(30,232,2)
(494,309,2)
(445,444,2)
(352,166,2)
(214,309,2)
(244,171,2)
(126,294,2)
(259,210,2)
(65,395,2)
(13,252,2)
(267,260,2)
(279,169,2)
(111,395,2)
(138,477,2)
(305,30,2)
(101,395,2)
(101,466,2)
(80,62,2)
(298,406,2)
(270,87,2)
(31,500,2)
(111,466,2)
(186,28,2)
(461,50,2)
(36,171,2)
(260,59,2)
(145,309,2)
(357,440,2)
(381,456,2)
(503,86,2)
(73,280,2)
(363,8,2)
(482,472,2)
(43,239,2)
(500,440,2)
(9,169,2)
(334,297,2)
(73,53,2)
(455,209,2)
(192,260,2)
(208,501,2)
(42,260,2)
(292,97,2)
(486,413,2)
(55,334,2)
(109,239,2)
(292,260,2)
(300,191,2)
(125,68,2)
(398,237,2)
(260,74,2)
(443,252,2)
(218,131,2)
(31,342,2)
(229,456,2)
(203,92,2)
(390,502,2)
(123,74,2)
(17,305,2)
(260,30,2)
(489,145,2)
(144,260,2)
(486,222,2)
(248,171,2)
(269,456,2)
(101,110,2)
(444,363,2)
(315,247,2)
(283,209,2)
(120,38,2)
(49,169,2)
(216,321,2)
(109,19,2)
(204,472,2)
(477,252,2)
(450,90,2)
(369,440,2)
(232,169,2)
(123,232,2)
(415,23,2)
(50,474,2)
(122,440,2)
(90,321,2)
(414,239,2)
(422,456,2)
(87,124,2)
-----------------------------------
(0,struct i386_frame *)
(1,p)
(2,&name)
(3,while (count--)
(4,frame)
(5,name)
(6,sym)
(7,if (ddb_regs.tf_ebp == 0)
(8,(addr >> 12)
(9,NULL)
(10,i)
(11,instr = db_get_value(callpc, 4, FALSE)
(12,1024)
(13,first)
(14,INKERNEL((int)
(15,i = 0)
(16,4)
(17,&actframe->f_arg0)
(18,4)
(19,sym = db_search_symbol(callpc, DB_STGY_ANY, &offset)
(20,!INKERNEL((int)
(21,for (i = 0; i < 4096; i += 4)
(22,callpc)
(23,db_addr_t)
(24,f_frame)
(25,0x0000ffff)
(26,(struct i386_frame *)
(27,char *)
(28,&ddb_regs)
(29,struct i386_frame *)
(30,actframe = frame)
(31,(int)
(32,struct i386_frame *)
(33,actframe)
(34,16)
(35,)
(36,NULL)
(37,frame->f_frame)
(38,count--)
(39,TRUE)
(40,&ddb_regs)
(41,db_printf("Trace beginning at frame %p\\n", frame)
(42,db_get_value((int)
(43,sym)
(44,name)
(45,count)
(46,f_frame)
(47,PC_REGS(&ddb_regs)
(48,frame)
(49,frame == NULL)
(50,count == -1)
(51,pcb->pcb_eip)
(52,16)
(53,((addr >> 4)
(54,NULL)
(55,check)
(56,if (!have_addr)
(57,p == NULL)
(58,addr)
(59,frame = (void *)
(60,break;)
(61,4)
(62,sym != NULL && db_sym_numargs(sym, &narg, argnames)
(63,frame)
(64,"Unable to find anything that looks like a stack frame\\n")
(65,db_get_value(callpc, 4, FALSE)
(66,count)
(67,)
(68,&ddb_regs)
(69,)
(70,16)
(71,addr)
(72,16)
(73,(addr % 16)
(74,frame = actframe)
(75,if (p == NULL)
(76,db_printf("%p does not look like a stack frame, skipping\\n", (char *)
(77,actframe)
(78,frame)
(79,frame)
(80,frame)
(81,P_SWAPPEDOUT)
(82,frame)
(83,argnames)
(84,char *)
(85,)
(86,char *)
(87,(instr & 0x000000ff)
(88,pid)
(89,&frame->f_retaddr)
(90,argp = &actframe->f_arg0)
(91,db_addr_t)
(92,(instr & 0x00ffffff)
(93,actframe)
(94,)
(95,if (frame == NULL)
(96,DB_STGY_ANY)
(97,actframe->f_retaddr)
(98,db_print_stack_entry(name, 0, 0, 0, callpc)
(99,instr)
(100,SP_REGS(&ddb_regs)
(101,db_print_stack_entry(name, 0, 0, 0, callpc)
(102,have_addr)
(103,&offset)
(104,struct i386_frame *)
(105,actframe = (struct i386_frame *)
(106,instr & 0x0000ffff)
(107,if ((curproc != NULL)
(108,if ((p->p_flag & P_SWAPPEDOUT)
(109,db_sym_numargs(sym, &narg, argnames)
(110,callpc = PC_REGS(&ddb_regs)
(111,db_search_symbol(callpc, DB_STGY_ANY, &offset)
(112,4)
(113,pcb->pcb_ebp)
(114,)
(115,addr)
(116,actframe)
(117,frame)
(118,&ddb_regs)
(119,16)
(120,db_symbol_values(sym, &name, NULL)
(121,instr)
(122,f_retaddr)
(123,db_numargs(frame)
(124,instr & 0x000000ff)
(125,PC_REGS(&ddb_regs)
(126,((addr >> 8)
(127,frame)
(128,narg)
(129,ddb_regs)
(130,break;)
(131,char *)
(132,12)
(133,argnames)
(134,i)
(135,0x0000e589)
(136,curproc)
(137,frame)
(138,&frame)
(139,strcmp(name, "fork_trampoline")
(140,callpc)
(141,(char *)
(142,(char *)
(143,int)
(144,frame)
(145,frame = (struct i386_frame *)
(146,)
(147,100)
(148,)
(149,(struct i386_frame *)
(150,FALSE)
(151,frame)
(152,sym)
(153,)
(154,if (INKERNEL((int)
(155,NULL)
(156,frame)
(157,&ddb_regs)
(158,p_flag)
(159,argnp)
(160,first)
(161,i)
(162,SP_REGS(&ddb_regs)
(163,frame)
(164,ddb_regs)
(165,"fork_trampoline")
(166,struct i386_frame *)
(167,int)
(168,FALSE)
(169,(curproc != NULL)
(170,ddb_regs)
(171,first)
(172,name)
(173,if (i == 4096)
(174,i)
(175,(struct i386_frame *)
(176,NULL)
(177,db_expr_t addr)
(178,db_printf("Unable to find anything that looks like a stack frame\\n")
(179,pid)
(180,argnames)
(181,callpc)
(182,db_search_symbol(callpc, DB_STGY_ANY, &offset)
(183,if (sym != NULL && db_sym_numargs(sym, &narg, argnames)
(184,)
(185,actframe = (struct i386_frame *)
(186,SP_REGS(&ddb_regs)
(187,((addr >> 4)
(188,ddb_regs)
(189,SP_REGS(&ddb_regs)
(190,(struct i386_frame *)
(191,curproc->p_pid)
(192,actframe)
(193,)
(194,SP_REGS(&ddb_regs)
(195,)
(196,f_retaddr)
(197,actframe)
(198,&ddb_regs)
(199,callpc)
(200,ddb_regs.tf_ebp == 0)
(201,check)
(202,&ddb_regs)
(203,ddb_regs)
(204,MAXNARG)
(205,callpc)
(206,db_printf("pid %d swapped out\\n", pid)
(207,(char *)
(208,pcb->pcb_esp)
(209,(char *)
(210,p->p_flag & P_SWAPPEDOUT)
(211,4)
(212,)
(213,narg)
(214,1000)
(215,(char *)
(216,instr)
(217,(char *)
(218,(char *)
(219,1)
(220,(int)
(221,0)
(222,frame = (struct i386_frame *)
(223,4096)
(224,db_symbol_values(sym, &name, NULL)
(225,(db_addr_t)
(226,frame)
(227,(addr >> 16)
(228,p)
(229,0)
(230,pcb->pcb_esp - 4)
(231,)
(232,frame = (struct i386_frame *)
(233,frame)
(234,curproc)
(235,pcb)
(236,&ddb_regs)
(237,frame == NULL)
(238,)
(239,sym != NULL)
(240,frame)
(241,SP_REGS(&ddb_regs)
(242,offset == 0)
(243,&frame->f_frame)
(244,argnp)
(245,callpc)
(246,if (frame == NULL)
(247,int)
(248,name)
(249,p)
(250,0x00ffffff)
(251,0x000000ff)
(252,!have_addr)
(253,break;)
(254,(struct i386_frame *)
(255,&ddb_regs)
(256,frame)
(257,i)
(258,first = FALSE)
(259,pcb)
(260,actframe != frame)
(261,)
(262,int)
(263,0)
(264,tf_ebp)
(265,4)
(266,4096)
(267,&callpc)
(268,name)
(269,&offset)
(270,offset)
(271,sym)
(272,callpc)
(273,(char *)
(274,NULL)
(275,)
(276,if (count == -1)
(277,boolean_t have_addr)
(278,frame->f_frame)
(279,p->p_pid == pid)
(280,addr % 16)
(281,struct i386_frame *)
(282,td_pcb)
(283,4096)
(284,!INKERNEL((int)
(285,sym = db_search_symbol(callpc, DB_STGY_ANY, &offset)
(286,pcb_eip)
(287,struct i386_frame *)
(288,struct i386_frame *)
(289,FALSE)
(290,(db_addr_t)
(291,argp)
(292,&actframe->f_retaddr)
(293,(struct i386_frame *)
(294,(addr >> 8)
(295,frame = (struct i386_frame *)
(296,p->p_pid)
(297,i += 4)
(298,"%p does not look like a stack frame, skipping\\n")
(299,p_pid)
(300,pid == curproc->p_pid)
(301,FALSE)
(302,int)
(303,(struct i386_frame *)
(304,"Trace beginning at frame %p\\n")
(305,actframe->f_arg0)
(306,sym)
(307,ddb_regs)
(308,narg)
(309,!INKERNEL(addr)
(310,struct i386_frame *)
(311,p)
(312,INKERNEL((int)
(313,p->p_flag)
(314,addr >> 12)
(315,(int)
(316,addr)
(317,offset)
(318,actframe)
(319,return;)
(320,if (actframe != frame)
(321,!have_addr)
(322,if (frame == NULL)
(323,count)
(324,4)
(325,char *)
(326,check)
(327,p_thread)
(328,4)
(329,(char *)
(330,argnp)
(331,pcb_ebp)
(332,frame)
(333,narg)
(334,i < 4096)
(335,frame)
(336,addr >> 4)
(337,0)
(338,)
(339,10)
(340,offset)
(341,NULL)
(342,int)
(343,SP_REGS(&ddb_regs)
(344,pcb)
(345,frame)
(346,callpc)
(347,break;)
(348,NULL)
(349,return;)
(350,0)
(351,0)
(352,(struct i386_frame *)
(353,frame->f_retaddr)
(354,(char *)
(355,continue;)
(356,RET)
(357,(char *)
(358,10000)
(359,SP_REGS(&ddb_regs)
(360,pcb)
(361,"pid %d swapped out\\n")
(362,(struct i386_frame *)
(363,((addr >> 12)
(364,ddb_regs)
(365,DB_STGY_ANY)
(366,i)
(367,pid)
(368,4)
(369,(int)
(370,0)
(371,struct i386_frame *)
(372,if (p->p_pid == pid)
(373,pcb_esp)
(374,)
(375,if (!INKERNEL((int)
(376,narg = MAXNARG)
(377,db_get_value((int)
(378,pcb = p->p_thread->td_pcb)
(379,have_addr)
(380,if ((instr & 0x00ffffff)
(381,sym)
(382,check = (struct i386_frame *)
(383,actframe)
(384,break;)
(385,struct i386_frame *)
(386,pid)
(387,(struct i386_frame *)
(388,if ((char *)
(389,db_expr_t count)
(390,(void *)
(391,db_nextframe(&frame, &callpc)
(392,0)
(393,actframe)
(394,(char *)
(395,callpc = PC_REGS(&ddb_regs)
(396,pid)
(397,(struct i386_frame *)
(398,ddb_regs)
(399,(struct i386_frame *)
(400,callpc)
(401,instr)
(402,narg)
(403,pid = (addr % 16)
(404,(addr >> 4)
(405,addr >> 8)
(406,(char *)
(407,i)
(408,check)
(409,callpc)
(410,argnp = argnames)
(411,ddb_regs.tf_ebp)
(412,pid)
(413,frame = (struct i386_frame *)
(414,&narg)
(415,(db_addr_t)
(416,actframe)
(417,&ddb_regs)
(418,**argnp = NULL)
(419,addr)
(420,first = TRUE)
(421,offset)
(422,name)
(423,ddb_regs)
(424,(int)
(425,if (!have_addr)
(426,frame)
(427,SP_REGS(&ddb_regs)
(428,INKERNEL(addr)
(429,db_get_value((int)
(430,instr)
(431,db_addr_t)
(432,&frame->f_frame)
(433,&name)
(434,addr >> 16)
(435,char *)
(436,sym)
(437,callpc)
(438,p)
(439,frame)
(440,i == 4096)
(441,addr)
(442,argp)
(443,callpc)
(444,((addr >> 12)
(445,((addr >> 8)
(446,BP_REGS(&ddb_regs)
(447,SP_REGS(&ddb_regs)
(448,argnp)
(449,db_printf("pid %d not found\\n", pid)
(450,db_print_stack_entry(name, narg, argnp, argp, callpc)
(451,0)
(452,)
(453,p_pid)
(454,0)
(455,frame)
(456,INKERNEL((int)
(457,struct i386_frame *)
(458,4)
(459,)
(460,narg = db_numargs(frame)
(461,count = 1024)
(462,pcb)
(463,name)
(464,((addr >> 16)
(465,4)
(466,callpc = (db_addr_t)
(467,instr & 0x00ffffff)
(468,INKERNEL((int)
(469,8)
(470,BP_REGS(&ddb_regs)
(471,0x000000c3)
(472,!strcmp(name, "fork_trampoline")
(473,addr)
(474,-1)
(475,callpc = (db_addr_t)
(476,f_arg0)
(477,frame = (struct i386_frame *)
(478,callpc)
(479,callpc)
(480,frame)
(481,i)
(482,FALSE)
(483,return;)
(484,ddb_regs)
(485,)
(486,(int)
(487,p->p_thread->td_pcb)
(488,)
(489,(char *)
(490,char *)
(491,)
(492,curproc != NULL)
(493,actframe = (struct i386_frame *)
(494,16)
(495,SP_REGS(&ddb_regs)
(496,frame)
(497,0x00e58955)
(498,NULL)
(499,ddb_regs)
(500,callpc = (db_addr_t)
(501,frame == NULL)
(502,void *)
(503,(char *)
(504,frame = (struct i386_frame *)
(505,"pid %d not found\\n")
(506,first)
(507,)
(508,actframe = (struct i386_frame *)
(509,p->p_thread)
(510,if (first)
(511,4)
(512,(instr & 0x0000ffff)
(513,)
(514,argp)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^