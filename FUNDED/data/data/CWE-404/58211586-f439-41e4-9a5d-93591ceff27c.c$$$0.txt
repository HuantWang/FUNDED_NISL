-----label-----
1
-----code-----
static struct drm_mm_node *drm_mm_search_free_in_range_generic(const struct drm_mm *mm,
							u64 size,
							unsigned alignment,
							unsigned long color,
							u64 start,
							u64 end,
							enum drm_mm_search_flags flags)
{
	struct drm_mm_node *entry;
	struct drm_mm_node *best;
	u64 adj_start;
	u64 adj_end;
	u64 best_size;

	BUG_ON(mm->scanned_blocks);

	best = NULL;
	best_size = ~0UL;

	for (entry = get_first_hole(mm, flags);
			drm_mm_hole_traversal_condition(mm, entry, flags);
			entry = get_next_hole(entry, flags)) {
		u64 hole_size;

		adj_start = drm_mm_hole_node_start(entry);
		adj_end = drm_mm_hole_node_end(entry);
		hole_size = adj_end - adj_start;

		if (adj_start < start)
			adj_start = start;
		if (adj_end > end)
			adj_end = end;

		if (mm->color_adjust) {
			mm->color_adjust(entry, color, &adj_start, &adj_end);
			if (adj_end <= adj_start)
				continue;
		}

		if (!check_free_hole(adj_start, adj_end, size, alignment))
			continue;

		if (!(flags & DRM_MM_SEARCH_BEST))
			return entry;

		if (hole_size < best_size) {
			best = entry;
			best_size = hole_size;
		}
	}

	return best;
}
-----children-----
1,2
1,3
1,4
2,3
4,5
4,6
4,7
4,8
4,9
4,10
4,11
4,12
4,13
7,8
7,9
8,9
10,11
10,12
13,14
13,15
14,15
16,17
18,19
18,20
20,21
22,23
22,24
24,25
26,27
26,28
27,28
29,30
31,32
31,33
32,33
34,35
36,37
36,38
37,38
39,40
41,42
41,43
41,44
41,45
41,46
41,47
41,48
41,49
41,50
41,51
42,43
43,44
43,45
44,45
46,47
46,48
49,50
50,51
50,52
51,52
53,54
53,55
56,57
57,58
57,59
58,59
60,61
62,63
63,64
63,65
64,65
66,67
68,69
69,70
69,71
70,71
72,73
74,75
75,76
75,77
76,77
78,79
78,80
79,80
82,83
83,84
83,85
84,85
86,87
88,89
89,90
89,91
90,91
92,93
94,95
94,96
94,97
94,98
95,96
96,97
96,98
97,98
99,100
99,101
99,102
100,101
102,103
104,105
106,107
106,108
106,109
106,110
107,108
109,110
111,112
113,114
115,116
115,117
116,117
118,119
118,120
118,121
119,120
121,122
123,124
125,126
125,127
125,128
125,129
125,130
125,131
125,132
125,133
125,134
125,135
126,127
127,128
127,129
128,129
130,131
132,133
133,134
133,135
134,135
136,137
136,138
137,138
139,140
141,142
142,143
142,144
143,144
145,146
145,147
146,147
148,149
150,151
151,152
151,153
152,153
154,155
154,156
155,156
157,158
159,160
159,161
160,161
160,162
161,162
163,164
165,166
166,167
166,168
167,168
169,170
171,172
171,173
172,173
172,174
173,174
175,176
177,178
178,179
178,180
179,180
181,182
183,184
183,185
184,185
184,186
185,186
188,189
188,190
189,190
190,191
190,192
190,193
190,194
190,195
191,192
191,193
192,193
195,196
197,198
199,200
200,201
202,203
203,204
205,206
205,207
206,207
206,208
207,208
209,210
212,213
212,214
213,214
214,215
214,216
214,217
214,218
214,219
215,216
217,218
219,220
221,222
223,224
226,227
226,228
227,228
228,229
229,230
229,231
230,231
232,233
234,235
235,236
237,238
237,239
238,239
238,240
239,240
241,242
243,244
243,245
244,245
245,246
245,247
246,247
248,249
250,251
251,252
251,253
252,253
254,255
256,257
257,258
-----nextToken-----
3,5,6,9,11,12,15,17,19,21,23,25,28,30,33,35,38,40,45,47,48,52,54,55,59,61,65,67,71,73,77,80,81,85,87,91,93,98,101,103,105,108,110,112,114,117,120,122,124,129,131,135,138,140,144,147,149,153,156,158,162,164,168,170,174,176,180,182,186,187,193,194,196,198,201,204,208,210,211,216,218,220,222,224,225,231,233,236,240,242,247,249,253,255,258
-----computeFrom-----
83,84
83,85
89,90
89,91
96,97
96,98
115,116
115,117
133,134
133,135
142,143
142,144
151,152
151,153
154,155
154,156
160,161
160,162
166,167
166,168
172,173
172,174
178,179
178,180
206,207
206,208
229,230
229,231
238,239
238,240
245,246
245,247
251,252
251,253
-----guardedBy-----
162,168
164,170
174,180
176,182
242,253
240,255
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;ElaboratedTypeSpecifier;Name;FunctionDeclarator;Pointer;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;LiteralExpression;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ContinueStatement;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ContinueStatement;IfStatement;UnaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;IdExpression;Name;
-----ast_node-----
static struct drm_mm_node *drm_mm_search_free_in_range_generic(const struct drm_mm *mm,							u64 size,							unsigned alignment,							unsigned long color,							u64 start,							u64 end,							enum drm_mm_search_flags flags){	struct drm_mm_node *entry;	struct drm_mm_node *best;	u64 adj_start;	u64 adj_end;	u64 best_size;	BUG_ON(mm->scanned_blocks);	best = NULL;	best_size = ~0UL;	for (entry = get_first_hole(mm, flags);			drm_mm_hole_traversal_condition(mm, entry, flags);			entry = get_next_hole(entry, flags)) {		u64 hole_size;		adj_start = drm_mm_hole_node_start(entry);		adj_end = drm_mm_hole_node_end(entry);		hole_size = adj_end - adj_start;		if (adj_start < start)			adj_start = start;		if (adj_end > end)			adj_end = end;		if (mm->color_adjust) {			mm->color_adjust(entry, color, &adj_start, &adj_end);			if (adj_end <= adj_start)				continue;		}		if (!check_free_hole(adj_start, adj_end, size, alignment))			continue;		if (!(flags & DRM_MM_SEARCH_BEST))			return entry;		if (hole_size < best_size) {			best = entry;			best_size = hole_size;		}	}	return best;}
static struct drm_mm_node
drm_mm_node
*drm_mm_search_free_in_range_generic(const struct drm_mm *mm,							u64 size,							unsigned alignment,							unsigned long color,							u64 start,							u64 end,							enum drm_mm_search_flags flags)
*
drm_mm_search_free_in_range_generic
const struct drm_mm *mm
const struct drm_mm
drm_mm
*mm
*
mm
u64 size
u64
u64
size
size
unsigned alignment
unsigned
alignment
alignment
unsigned long color
unsigned long
color
color
u64 start
u64
u64
start
start
u64 end
u64
u64
end
end
enum drm_mm_search_flags flags
enum drm_mm_search_flags
drm_mm_search_flags
flags
flags
{	struct drm_mm_node *entry;	struct drm_mm_node *best;	u64 adj_start;	u64 adj_end;	u64 best_size;	BUG_ON(mm->scanned_blocks);	best = NULL;	best_size = ~0UL;	for (entry = get_first_hole(mm, flags);			drm_mm_hole_traversal_condition(mm, entry, flags);			entry = get_next_hole(entry, flags)) {		u64 hole_size;		adj_start = drm_mm_hole_node_start(entry);		adj_end = drm_mm_hole_node_end(entry);		hole_size = adj_end - adj_start;		if (adj_start < start)			adj_start = start;		if (adj_end > end)			adj_end = end;		if (mm->color_adjust) {			mm->color_adjust(entry, color, &adj_start, &adj_end);			if (adj_end <= adj_start)				continue;		}		if (!check_free_hole(adj_start, adj_end, size, alignment))			continue;		if (!(flags & DRM_MM_SEARCH_BEST))			return entry;		if (hole_size < best_size) {			best = entry;			best_size = hole_size;		}	}	return best;}
struct drm_mm_node *entry;
struct drm_mm_node *entry;
struct drm_mm_node
drm_mm_node
*entry
*
entry
struct drm_mm_node *best;
struct drm_mm_node *best;
struct drm_mm_node
drm_mm_node
*best
*
best
u64 adj_start;
u64 adj_start;
u64
u64
adj_start
adj_start
u64 adj_end;
u64 adj_end;
u64
u64
adj_end
adj_end
u64 best_size;
u64 best_size;
u64
u64
best_size
best_size
BUG_ON(mm->scanned_blocks);
BUG_ON(mm->scanned_blocks)
BUG_ON
BUG_ON
mm->scanned_blocks
mm
mm
scanned_blocks
best = NULL;
best = NULL
best
best
NULL
NULL
best_size = ~0UL;
best_size = ~0UL
best_size
best_size
~0UL
0UL
for (entry = get_first_hole(mm, flags);			drm_mm_hole_traversal_condition(mm, entry, flags);			entry = get_next_hole(entry, flags)) {		u64 hole_size;		adj_start = drm_mm_hole_node_start(entry);		adj_end = drm_mm_hole_node_end(entry);		hole_size = adj_end - adj_start;		if (adj_start < start)			adj_start = start;		if (adj_end > end)			adj_end = end;		if (mm->color_adjust) {			mm->color_adjust(entry, color, &adj_start, &adj_end);			if (adj_end <= adj_start)				continue;		}		if (!check_free_hole(adj_start, adj_end, size, alignment))			continue;		if (!(flags & DRM_MM_SEARCH_BEST))			return entry;		if (hole_size < best_size) {			best = entry;			best_size = hole_size;		}	}
entry = get_first_hole(mm, flags);
entry = get_first_hole(mm, flags)
entry
entry
get_first_hole(mm, flags)
get_first_hole
get_first_hole
mm
mm
flags
flags
drm_mm_hole_traversal_condition(mm, entry, flags)
drm_mm_hole_traversal_condition
drm_mm_hole_traversal_condition
mm
mm
entry
entry
flags
flags
entry = get_next_hole(entry, flags)
entry
entry
get_next_hole(entry, flags)
get_next_hole
get_next_hole
entry
entry
flags
flags
{		u64 hole_size;		adj_start = drm_mm_hole_node_start(entry);		adj_end = drm_mm_hole_node_end(entry);		hole_size = adj_end - adj_start;		if (adj_start < start)			adj_start = start;		if (adj_end > end)			adj_end = end;		if (mm->color_adjust) {			mm->color_adjust(entry, color, &adj_start, &adj_end);			if (adj_end <= adj_start)				continue;		}		if (!check_free_hole(adj_start, adj_end, size, alignment))			continue;		if (!(flags & DRM_MM_SEARCH_BEST))			return entry;		if (hole_size < best_size) {			best = entry;			best_size = hole_size;		}	}
u64 hole_size;
u64 hole_size;
u64
u64
hole_size
hole_size
adj_start = drm_mm_hole_node_start(entry);
adj_start = drm_mm_hole_node_start(entry)
adj_start
adj_start
drm_mm_hole_node_start(entry)
drm_mm_hole_node_start
drm_mm_hole_node_start
entry
entry
adj_end = drm_mm_hole_node_end(entry);
adj_end = drm_mm_hole_node_end(entry)
adj_end
adj_end
drm_mm_hole_node_end(entry)
drm_mm_hole_node_end
drm_mm_hole_node_end
entry
entry
hole_size = adj_end - adj_start;
hole_size = adj_end - adj_start
hole_size
hole_size
adj_end - adj_start
adj_end
adj_end
adj_start
adj_start
if (adj_start < start)			adj_start = start;
adj_start < start
adj_start
adj_start
start
start
adj_start = start;
adj_start = start
adj_start
adj_start
start
start
if (adj_end > end)			adj_end = end;
adj_end > end
adj_end
adj_end
end
end
adj_end = end;
adj_end = end
adj_end
adj_end
end
end
if (mm->color_adjust) {			mm->color_adjust(entry, color, &adj_start, &adj_end);			if (adj_end <= adj_start)				continue;		}
mm->color_adjust
mm
mm
color_adjust
{			mm->color_adjust(entry, color, &adj_start, &adj_end);			if (adj_end <= adj_start)				continue;		}
mm->color_adjust(entry, color, &adj_start, &adj_end);
mm->color_adjust(entry, color, &adj_start, &adj_end)
mm->color_adjust
mm
mm
color_adjust
entry
entry
color
color
&adj_start
adj_start
adj_start
&adj_end
adj_end
adj_end
if (adj_end <= adj_start)				continue;
adj_end <= adj_start
adj_end
adj_end
adj_start
adj_start
continue;
if (!check_free_hole(adj_start, adj_end, size, alignment))			continue;
!check_free_hole(adj_start, adj_end, size, alignment)
check_free_hole(adj_start, adj_end, size, alignment)
check_free_hole
check_free_hole
adj_start
adj_start
adj_end
adj_end
size
size
alignment
alignment
continue;
if (!(flags & DRM_MM_SEARCH_BEST))			return entry;
!(flags & DRM_MM_SEARCH_BEST)
(flags & DRM_MM_SEARCH_BEST)
flags & DRM_MM_SEARCH_BEST
flags
flags
DRM_MM_SEARCH_BEST
DRM_MM_SEARCH_BEST
return entry;
entry
entry
if (hole_size < best_size) {			best = entry;			best_size = hole_size;		}
hole_size < best_size
hole_size
hole_size
best_size
best_size
{			best = entry;			best_size = hole_size;		}
best = entry;
best = entry
best
best
entry
entry
best_size = hole_size;
best_size = hole_size
best_size
best_size
hole_size
hole_size
return best;
best
best
-----joern-----
(68,72,0)
(111,70,0)
(66,82,0)
(112,70,0)
(45,9,0)
(67,71,0)
(29,25,0)
(62,100,0)
(18,43,0)
(20,72,0)
(50,101,0)
(67,74,0)
(53,101,0)
(39,23,0)
(2,43,0)
(1,43,0)
(21,86,0)
(70,22,0)
(26,32,0)
(95,72,0)
(86,85,0)
(17,100,0)
(86,100,0)
(41,15,0)
(38,102,0)
(15,74,0)
(43,85,0)
(86,9,0)
(112,22,0)
(106,72,0)
(46,65,0)
(32,69,0)
(26,25,0)
(78,86,0)
(32,74,0)
(31,76,0)
(76,84,0)
(100,44,0)
(64,22,0)
(37,64,0)
(97,26,0)
(62,9,0)
(26,85,0)
(74,46,0)
(86,25,0)
(8,10,0)
(14,3,0)
(36,3,0)
(58,101,0)
(7,46,0)
(81,70,0)
(23,101,0)
(3,65,0)
(42,62,0)
(22,64,0)
(34,74,0)
(59,61,0)
(3,27,0)
(110,56,0)
(90,64,0)
(56,27,0)
(3,10,0)
(32,12,0)
(46,10,0)
(67,10,0)
(82,63,0)
(22,72,0)
(6,85,0)
(104,101,0)
(73,9,0)
(9,87,0)
(52,44,0)
(43,88,0)
(44,100,0)
(109,43,0)
(25,72,0)
(35,112,0)
(82,25,0)
(77,10,0)
(76,65,0)
(44,10,0)
(108,82,0)
(64,25,0)
(98,67,0)
(13,23,0)
(17,87,0)
(43,109,0)
(57,102,0)
(4,46,0)
(32,62,0)
(105,17,0)
(49,17,0)
(0,50,0)
(62,32,0)
(83,22,0)
(77,65,0)
(84,76,0)
(100,72,0)
(54,74,0)
(89,56,0)
(47,112,0)
(5,43,0)
(25,34,0)
(44,74,0)
(43,100,0)
(30,100,0)
(34,25,0)
(77,27,0)
(107,85,0)
(43,25,0)
(102,53,0)
(91,101,0)
(96,61,0)
(11,101,0)
(43,79,0)
(40,77,0)
(15,10,0)
(10,3,0)
(53,102,0)
(46,74,0)
(51,67,0)
(112,23,0)
(77,74,0)
(33,101,0)
(32,26,0)
(61,67,0)
(61,50,0)
(34,10,0)
(28,32,0)
(103,72,0)
(70,71,0)
(75,50,0)
(94,77,0)
(16,32,0)
(61,101,0)
(102,27,0)
(85,63,0)
(80,76,0)
(32,10,0)
(24,77,0)
(43,9,0)
(19,34,0)
(92,12,0)
(99,101,0)
(96,15,0)
(60,72,0)
(93,72,0)
(64,100,0)
(109,43,1)
(45,17,1)
(81,111,1)
(43,88,1)
(43,79,1)
(96,15,1)
(76,31,1)
(25,34,1)
(66,9,1)
(56,27,1)
(80,109,1)
(0,53,1)
(98,112,1)
(44,10,1)
(50,75,1)
(3,65,1)
(7,4,1)
(105,22,1)
(85,107,1)
(54,70,1)
(77,27,1)
(26,97,1)
(112,47,1)
(82,25,1)
(86,9,1)
(70,81,1)
(34,74,1)
(85,63,1)
(102,57,1)
(55,109,1)
(32,26,1)
(82,108,1)
(26,25,1)
(3,14,1)
(32,69,1)
(24,74,1)
(22,64,1)
(64,90,1)
(15,10,1)
(17,87,1)
(32,10,1)
(61,50,1)
(16,28,1)
(86,78,1)
(54,55,1)
(52,30,1)
(102,27,1)
(53,102,1)
(96,61,1)
(37,83,1)
(1,2,1)
(67,10,1)
(9,73,1)
(24,10,1)
(40,94,1)
(17,100,1)
(77,10,1)
(23,39,1)
(86,25,1)
(84,76,1)
(51,98,1)
(46,74,1)
(32,74,1)
(67,74,1)
(43,9,1)
(100,44,1)
(46,7,1)
(34,19,1)
(61,59,1)
(8,23,1)
(76,65,1)
(13,50,1)
(43,85,1)
(30,77,1)
(112,23,1)
(9,87,1)
(56,89,1)
(21,32,1)
(36,8,1)
(26,85,1)
(64,100,1)
(75,0,1)
(70,22,1)
(77,40,1)
(48,86,1)
(6,82,1)
(61,67,1)
(39,13,1)
(108,66,1)
(49,105,1)
(43,5,1)
(46,10,1)
(54,48,1)
(62,42,1)
(67,51,1)
(110,85,1)
(44,74,1)
(57,38,1)
(2,86,1)
(73,45,1)
(74,46,1)
(19,29,1)
(18,1,1)
(42,16,1)
(43,100,1)
(82,63,1)
(15,74,1)
(15,41,1)
(28,56,1)
(83,25,1)
(34,10,1)
(90,37,1)
(112,70,1)
(77,65,1)
(2,56,1)
(112,22,1)
(41,84,1)
(47,35,1)
(110,82,1)
(86,100,1)
(4,54,1)
(62,100,1)
(77,74,1)
(44,52,1)
(3,27,1)
(78,21,1)
(64,25,1)
(10,3,1)
(97,62,1)
(107,6,1)
(43,25,1)
(111,67,1)
(62,9,1)
(59,77,1)
(86,85,1)
(89,110,1)
(54,112,1)
(17,49,1)
(5,18,1)
(35,84,1)
(14,36,1)
(46,65,1)
(94,24,1)
(32,62,1)
(31,80,1)
(29,100,1)
(66,17,1)
(53,102,2)
(70,112,2)
(74,84,2)
(17,77,2)
(2,86,2)
(40,84,2)
(96,61,2)
(59,77,2)
(15,84,2)
(70,22,2)
(17,100,2)
(102,27,2)
(31,109,2)
(111,112,2)
(34,77,2)
(7,84,2)
(77,27,2)
(34,10,2)
(73,17,2)
(25,77,2)
(62,100,2)
(49,77,2)
(15,10,2)
(54,86,2)
(77,84,2)
(4,84,2)
(52,77,2)
(54,109,2)
(24,86,2)
(82,25,2)
(4,86,2)
(46,84,2)
(32,62,2)
(34,74,2)
(44,74,2)
(43,100,2)
(26,85,2)
(109,43,2)
(4,109,2)
(110,77,2)
(84,76,2)
(62,9,2)
(82,77,2)
(76,65,2)
(61,50,2)
(32,10,2)
(43,86,2)
(56,27,2)
(21,56,2)
(89,77,2)
(77,74,2)
(1,86,2)
(46,86,2)
(67,10,2)
(97,56,2)
(78,56,2)
(74,109,2)
(90,77,2)
(30,77,2)
(85,63,2)
(94,109,2)
(18,86,2)
(9,87,2)
(67,74,2)
(74,86,2)
(80,109,2)
(32,56,2)
(44,10,2)
(55,109,2)
(37,77,2)
(61,67,2)
(43,85,2)
(105,77,2)
(7,109,2)
(26,56,2)
(76,109,2)
(83,77,2)
(56,77,2)
(9,17,2)
(64,100,2)
(43,56,2)
(98,112,2)
(24,84,2)
(3,27,2)
(41,84,2)
(43,88,2)
(26,25,2)
(100,44,2)
(77,65,2)
(86,56,2)
(46,109,2)
(112,22,2)
(40,86,2)
(77,86,2)
(25,34,2)
(112,84,2)
(29,77,2)
(77,10,2)
(7,86,2)
(81,112,2)
(46,10,2)
(45,17,2)
(22,77,2)
(5,56,2)
(17,87,2)
(86,25,2)
(18,56,2)
(108,77,2)
(48,86,2)
(64,25,2)
(32,69,2)
(22,64,2)
(96,15,2)
(43,25,2)
(5,86,2)
(16,56,2)
(42,56,2)
(19,77,2)
(107,82,2)
(35,84,2)
(46,74,2)
(109,86,2)
(51,112,2)
(77,109,2)
(112,23,2)
(32,26,2)
(100,77,2)
(62,56,2)
(47,84,2)
(6,82,2)
(61,77,2)
(2,56,2)
(82,63,2)
(46,65,2)
(40,109,2)
(86,9,2)
(85,82,2)
(86,100,2)
(43,79,2)
(3,65,2)
(66,77,2)
(32,74,2)
(10,3,2)
(28,56,2)
(112,70,2)
(86,85,2)
(94,84,2)
(15,74,2)
(54,84,2)
(84,109,2)
(67,112,2)
(109,56,2)
(94,86,2)
(1,56,2)
(24,109,2)
(43,9,2)
(44,77,2)
(74,46,2)
(64,77,2)
-----------------------------------
(0,best)
(1,adj_end)
(2,adj_start)
(3,get_first_hole(mm, flags)
(4,entry)
(5,alignment)
(6,adj_end)
(7,flags)
(8,entry)
(9,adj_start = start)
(10,entry = get_first_hole(mm, flags)
(11,best)
(12,)
(13,best_size)
(14,flags)
(15,return entry;)
(16,color)
(17,adj_start < start)
(18,size)
(19,entry)
(20,hole_size)
(21,adj_end)
(22,hole_size = adj_end - adj_start)
(23,best_size = ~0UL)
(24,mm)
(25,adj_end = drm_mm_hole_node_end(entry)
(26,&adj_end)
(27,const struct drm_mm *mm)
(28,entry)
(29,adj_end)
(30,adj_start)
(31,DRM_MM_SEARCH_BEST)
(32,mm->color_adjust(entry, color, &adj_start, &adj_end)
(33,for (entry = get_first_hole(mm, flags)
(34,drm_mm_hole_node_end(entry)
(35,hole_size)
(36,mm)
(37,adj_end)
(38,mm)
(39,~0UL)
(40,flags)
(41,entry)
(42,adj_start)
(43,check_free_hole(adj_start, adj_end, size, alignment)
(44,drm_mm_hole_node_start(entry)
(45,adj_start)
(46,get_next_hole(entry, flags)
(47,best_size)
(48,continue;)
(49,start)
(50,best = NULL)
(51,entry)
(52,entry)
(53,BUG_ON(mm->scanned_blocks)
(54,entry)
(55,continue;)
(56,mm->color_adjust)
(57,scanned_blocks)
(58,entry)
(59,best)
(60,if (!(flags & DRM_MM_SEARCH_BEST)
(61,return best;)
(62,&adj_start)
(63,u64 end)
(64,adj_end - adj_start)
(65,enum drm_mm_search_flags flags)
(66,adj_end)
(67,best = entry)
(68,if (hole_size < best_size)
(69,unsigned long color)
(70,best_size = hole_size)
(71,)
(72,)
(73,start)
(74,entry = get_next_hole(entry, flags)
(75,NULL)
(76,flags & DRM_MM_SEARCH_BEST)
(77,drm_mm_hole_traversal_condition(mm, entry, flags)
(78,adj_start)
(79,unsigned alignment)
(80,flags)
(81,hole_size)
(82,adj_end > end)
(83,hole_size)
(84,!(flags & DRM_MM_SEARCH_BEST)
(85,adj_end = end)
(86,adj_end <= adj_start)
(87,u64 start)
(88,u64 size)
(89,color_adjust)
(90,adj_start)
(91,adj_start)
(92,if (adj_end <= adj_start)
(93,if (mm->color_adjust)
(94,entry)
(95,if (adj_start < start)
(96,RET)
(97,adj_end)
(98,best)
(99,best_size)
(100,adj_start = drm_mm_hole_node_start(entry)
(101,)
(102,mm->scanned_blocks)
(103,if (adj_end > end)
(104,adj_end)
(105,adj_start)
(106,if (!check_free_hole(adj_start, adj_end, size, alignment)
(107,end)
(108,end)
(109,!check_free_hole(adj_start, adj_end, size, alignment)
(110,mm)
(111,best_size)
(112,hole_size < best_size)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^