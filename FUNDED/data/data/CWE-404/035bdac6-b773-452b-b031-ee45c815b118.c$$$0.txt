-----label-----
1
-----code-----
int misaligned_fixup(unsigned long address, struct pt_regs *regs,
		     unsigned long cause, struct callee_regs *cregs)
{
	struct disasm_state state;
	char buf[TASK_COMM_LEN];

	/* handle user mode only and only if enabled by sysadmin */
	if (!user_mode(regs) || !unaligned_enabled)
		return 1;

	if (no_unaligned_warning) {
		pr_warn_once("%s(%d) made unaligned access which was emulated"
			     " by kernel assist\n. This can degrade application"
			     " performance significantly\n. To enable further"
			     " logging of such instances, please \n"
			     " echo 0 > /proc/sys/kernel/ignore-unaligned-usertrap\n",
			     get_task_comm(buf, current), task_pid_nr(current));
	} else {
		/* Add rate limiting if it gets down to it */
		pr_warn("%s(%d): unaligned access to/from 0x%lx by PC: 0x%lx\n",
			get_task_comm(buf, current), task_pid_nr(current),
			address, regs->ret);

	}

	disasm_instr(regs->ret, &state, 1, regs, cregs);

	if (state.fault)
		goto fault;

	/* ldb/stb should not have unaligned exception */
	if ((state.zz == 1) || (state.di))
		goto fault;

	if (!state.write)
		fixup_load(&state, regs, cregs);
	else
		fixup_store(&state, regs, cregs);

	if (state.fault)
		goto fault;

	/* clear any remanants of delay slot */
	if (delay_mode(regs)) {
		regs->ret = regs->bta & ~1U;
		regs->status32 &= ~STATUS_DE_MASK;
	} else {
		regs->ret += state.instr_len;

		/* handle zero-overhead-loop */
		if ((regs->ret == regs->lp_end) && (regs->lp_count)) {
			regs->ret = regs->lp_start;
			regs->lp_count--;
		}
	}

	return 0;

fault:
	pr_err("Alignment trap: fault in fix-up %08lx at [<%08lx>]\n",
		state.words[0], address);

	return 1;
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
3,7
3,8
5,6
5,7
7,8
9,10
9,11
10,11
12,13
12,14
15,16
15,17
17,18
19,20
19,21
20,21
22,23
22,24
25,26
25,27
25,28
25,29
25,30
25,31
25,32
25,33
25,34
25,35
25,36
25,37
25,38
26,27
27,28
27,29
28,29
30,31
32,33
33,34
33,35
35,36
35,37
37,38
38,39
40,41
40,42
41,42
41,43
42,43
43,44
43,45
44,45
46,47
48,49
49,50
51,52
53,54
53,55
53,56
54,55
56,57
57,58
58,59
58,60
58,61
58,62
59,60
62,63
62,64
62,65
63,64
65,66
67,68
69,70
69,71
70,71
72,73
74,75
75,76
76,77
76,78
76,79
76,80
76,81
76,82
77,78
80,81
80,82
80,83
81,82
83,84
85,86
87,88
87,89
88,89
90,91
92,93
94,95
94,96
95,96
98,99
99,100
99,101
99,102
99,103
99,104
99,105
100,101
102,103
102,104
103,104
106,107
107,108
110,111
112,113
114,115
114,116
115,116
115,117
116,117
119,120
121,122
121,123
122,123
122,124
123,124
124,125
124,126
125,126
125,127
126,127
130,131
131,132
131,133
132,133
135,136
137,138
137,139
137,140
138,139
139,140
139,141
140,141
143,144
144,145
144,146
144,147
144,148
145,146
147,148
148,149
150,151
152,153
154,155
155,156
155,157
155,158
155,159
156,157
158,159
159,160
161,162
163,164
165,166
165,167
166,167
166,168
167,168
170,171
172,173
172,174
172,175
173,174
173,175
174,175
176,177
178,179
178,180
179,180
180,181
180,182
181,182
181,183
182,183
185,186
185,187
186,187
186,188
187,188
190,191
192,193
193,194
193,195
194,195
194,196
195,196
198,199
199,200
201,202
201,203
202,203
203,204
203,205
204,205
204,206
205,206
208,209
208,210
209,210
212,213
212,214
213,214
213,215
214,215
215,216
215,217
216,217
216,218
217,218
220,221
220,222
221,222
224,225
225,226
225,227
226,227
229,230
229,231
230,231
231,232
231,233
232,233
232,234
233,234
236,237
236,238
237,238
240,241
241,242
242,243
242,244
243,244
246,247
248,249
248,250
250,251
251,252
251,253
251,254
251,255
252,253
255,256
255,257
256,257
256,258
257,258
261,262
263,264
-----nextToken-----
2,4,6,8,11,13,14,16,18,21,23,24,29,31,34,36,39,45,47,50,52,55,60,61,64,66,68,71,73,78,79,82,84,86,89,91,93,96,97,101,104,105,108,109,111,113,117,118,120,127,128,129,133,134,136,141,142,146,149,151,153,157,160,162,164,168,169,171,175,177,183,184,188,189,191,196,197,200,206,207,210,211,218,219,222,223,227,228,234,235,238,239,244,245,247,249,253,254,258,259,260,262,264
-----computeFrom-----
41,42
41,43
122,123
122,124
124,125
124,126
180,181
180,182
185,186
185,187
193,194
193,195
203,204
203,205
213,214
213,215
215,216
215,217
231,232
231,233
-----guardedBy-----
219,235
228,245
227,244
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;IdExpression;Name;IfStatement;BinaryExpression;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;ReturnStatement;LiteralExpression;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;IfStatement;FieldReference;IdExpression;Name;Name;GotoStatement;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;GotoStatement;Name;IfStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;FieldReference;IdExpression;Name;Name;GotoStatement;Name;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;ReturnStatement;LiteralExpression;LabelStatement;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IdExpression;Name;ReturnStatement;LiteralExpression;
-----ast_node-----
int misaligned_fixup(unsigned long address, struct pt_regs *regs,		     unsigned long cause, struct callee_regs *cregs){	struct disasm_state state;	char buf[TASK_COMM_LEN];	/* handle user mode only and only if enabled by sysadmin */	if (!user_mode(regs) || !unaligned_enabled)		return 1;	if (no_unaligned_warning) {		pr_warn_once("%s(%d) made unaligned access which was emulated"			     " by kernel assist\n. This can degrade application"			     " performance significantly\n. To enable further"			     " logging of such instances, please \n"			     " echo 0 > /proc/sys/kernel/ignore-unaligned-usertrap\n",			     get_task_comm(buf, current), task_pid_nr(current));	} else {		/* Add rate limiting if it gets down to it */		pr_warn("%s(%d): unaligned access to/from 0x%lx by PC: 0x%lx\n",			get_task_comm(buf, current), task_pid_nr(current),			address, regs->ret);	}	disasm_instr(regs->ret, &state, 1, regs, cregs);	if (state.fault)		goto fault;	/* ldb/stb should not have unaligned exception */	if ((state.zz == 1) || (state.di))		goto fault;	if (!state.write)		fixup_load(&state, regs, cregs);	else		fixup_store(&state, regs, cregs);	if (state.fault)		goto fault;	/* clear any remanants of delay slot */	if (delay_mode(regs)) {		regs->ret = regs->bta & ~1U;		regs->status32 &= ~STATUS_DE_MASK;	} else {		regs->ret += state.instr_len;		/* handle zero-overhead-loop */		if ((regs->ret == regs->lp_end) && (regs->lp_count)) {			regs->ret = regs->lp_start;			regs->lp_count--;		}	}	return 0;fault:	pr_err("Alignment trap: fault in fix-up %08lx at [<%08lx>]\n",		state.words[0], address);	return 1;}
int
misaligned_fixup(unsigned long address, struct pt_regs *regs,		     unsigned long cause, struct callee_regs *cregs)
misaligned_fixup
unsigned long address
unsigned long
address
address
struct pt_regs *regs
struct pt_regs
pt_regs
*regs
*
regs
unsigned long cause
unsigned long
cause
cause
struct callee_regs *cregs
struct callee_regs
callee_regs
*cregs
*
cregs
{	struct disasm_state state;	char buf[TASK_COMM_LEN];	/* handle user mode only and only if enabled by sysadmin */	if (!user_mode(regs) || !unaligned_enabled)		return 1;	if (no_unaligned_warning) {		pr_warn_once("%s(%d) made unaligned access which was emulated"			     " by kernel assist\n. This can degrade application"			     " performance significantly\n. To enable further"			     " logging of such instances, please \n"			     " echo 0 > /proc/sys/kernel/ignore-unaligned-usertrap\n",			     get_task_comm(buf, current), task_pid_nr(current));	} else {		/* Add rate limiting if it gets down to it */		pr_warn("%s(%d): unaligned access to/from 0x%lx by PC: 0x%lx\n",			get_task_comm(buf, current), task_pid_nr(current),			address, regs->ret);	}	disasm_instr(regs->ret, &state, 1, regs, cregs);	if (state.fault)		goto fault;	/* ldb/stb should not have unaligned exception */	if ((state.zz == 1) || (state.di))		goto fault;	if (!state.write)		fixup_load(&state, regs, cregs);	else		fixup_store(&state, regs, cregs);	if (state.fault)		goto fault;	/* clear any remanants of delay slot */	if (delay_mode(regs)) {		regs->ret = regs->bta & ~1U;		regs->status32 &= ~STATUS_DE_MASK;	} else {		regs->ret += state.instr_len;		/* handle zero-overhead-loop */		if ((regs->ret == regs->lp_end) && (regs->lp_count)) {			regs->ret = regs->lp_start;			regs->lp_count--;		}	}	return 0;fault:	pr_err("Alignment trap: fault in fix-up %08lx at [<%08lx>]\n",		state.words[0], address);	return 1;}
struct disasm_state state;
struct disasm_state state;
struct disasm_state
disasm_state
state
state
char buf[TASK_COMM_LEN];
char buf[TASK_COMM_LEN];
char
buf[TASK_COMM_LEN]
buf
[TASK_COMM_LEN]
TASK_COMM_LEN
TASK_COMM_LEN
if (!user_mode(regs) || !unaligned_enabled)		return 1;
!user_mode(regs) || !unaligned_enabled
!user_mode(regs)
user_mode(regs)
user_mode
user_mode
regs
regs
!unaligned_enabled
unaligned_enabled
unaligned_enabled
return 1;
1
if (no_unaligned_warning) {		pr_warn_once("%s(%d) made unaligned access which was emulated"			     " by kernel assist\n. This can degrade application"			     " performance significantly\n. To enable further"			     " logging of such instances, please \n"			     " echo 0 > /proc/sys/kernel/ignore-unaligned-usertrap\n",			     get_task_comm(buf, current), task_pid_nr(current));	} else {		/* Add rate limiting if it gets down to it */		pr_warn("%s(%d): unaligned access to/from 0x%lx by PC: 0x%lx\n",			get_task_comm(buf, current), task_pid_nr(current),			address, regs->ret);	}
no_unaligned_warning
no_unaligned_warning
{		pr_warn_once("%s(%d) made unaligned access which was emulated"			     " by kernel assist\n. This can degrade application"			     " performance significantly\n. To enable further"			     " logging of such instances, please \n"			     " echo 0 > /proc/sys/kernel/ignore-unaligned-usertrap\n",			     get_task_comm(buf, current), task_pid_nr(current));	}
pr_warn_once("%s(%d) made unaligned access which was emulated"			     " by kernel assist\n. This can degrade application"			     " performance significantly\n. To enable further"			     " logging of such instances, please \n"			     " echo 0 > /proc/sys/kernel/ignore-unaligned-usertrap\n",			     get_task_comm(buf, current), task_pid_nr(current));
pr_warn_once("%s(%d) made unaligned access which was emulated"			     " by kernel assist\n. This can degrade application"			     " performance significantly\n. To enable further"			     " logging of such instances, please \n"			     " echo 0 > /proc/sys/kernel/ignore-unaligned-usertrap\n",			     get_task_comm(buf, current), task_pid_nr(current))
pr_warn_once
pr_warn_once
"%s(%d) made unaligned access which was emulated"			     " by kernel assist\n. This can degrade application"			     " performance significantly\n. To enable further"			     " logging of such instances, please \n"			     " echo 0 > /proc/sys/kernel/ignore-unaligned-usertrap\n"
get_task_comm(buf, current)
get_task_comm
get_task_comm
buf
buf
current
current
task_pid_nr(current)
task_pid_nr
task_pid_nr
current
current
{		/* Add rate limiting if it gets down to it */		pr_warn("%s(%d): unaligned access to/from 0x%lx by PC: 0x%lx\n",			get_task_comm(buf, current), task_pid_nr(current),			address, regs->ret);	}
pr_warn("%s(%d): unaligned access to/from 0x%lx by PC: 0x%lx\n",			get_task_comm(buf, current), task_pid_nr(current),			address, regs->ret);
pr_warn("%s(%d): unaligned access to/from 0x%lx by PC: 0x%lx\n",			get_task_comm(buf, current), task_pid_nr(current),			address, regs->ret)
pr_warn
pr_warn
"%s(%d): unaligned access to/from 0x%lx by PC: 0x%lx\n"
get_task_comm(buf, current)
get_task_comm
get_task_comm
buf
buf
current
current
task_pid_nr(current)
task_pid_nr
task_pid_nr
current
current
address
address
regs->ret
regs
regs
ret
disasm_instr(regs->ret, &state, 1, regs, cregs);
disasm_instr(regs->ret, &state, 1, regs, cregs)
disasm_instr
disasm_instr
regs->ret
regs
regs
ret
&state
state
state
1
regs
regs
cregs
cregs
if (state.fault)		goto fault;
state.fault
state
state
fault
goto fault;
fault
if ((state.zz == 1) || (state.di))		goto fault;
(state.zz == 1) || (state.di)
(state.zz == 1)
state.zz == 1
state.zz
state
state
zz
1
(state.di)
state.di
state
state
di
goto fault;
fault
if (!state.write)		fixup_load(&state, regs, cregs);	else		fixup_store(&state, regs, cregs);
!state.write
state.write
state
state
write
fixup_load(&state, regs, cregs);
fixup_load(&state, regs, cregs)
fixup_load
fixup_load
&state
state
state
regs
regs
cregs
cregs
fixup_store(&state, regs, cregs);
fixup_store(&state, regs, cregs)
fixup_store
fixup_store
&state
state
state
regs
regs
cregs
cregs
if (state.fault)		goto fault;
state.fault
state
state
fault
goto fault;
fault
if (delay_mode(regs)) {		regs->ret = regs->bta & ~1U;		regs->status32 &= ~STATUS_DE_MASK;	} else {		regs->ret += state.instr_len;		/* handle zero-overhead-loop */		if ((regs->ret == regs->lp_end) && (regs->lp_count)) {			regs->ret = regs->lp_start;			regs->lp_count--;		}	}
delay_mode(regs)
delay_mode
delay_mode
regs
regs
{		regs->ret = regs->bta & ~1U;		regs->status32 &= ~STATUS_DE_MASK;	}
regs->ret = regs->bta & ~1U;
regs->ret = regs->bta & ~1U
regs->ret
regs
regs
ret
regs->bta & ~1U
regs->bta
regs
regs
bta
~1U
1U
regs->status32 &= ~STATUS_DE_MASK;
regs->status32 &= ~STATUS_DE_MASK
regs->status32
regs
regs
status32
~STATUS_DE_MASK
STATUS_DE_MASK
STATUS_DE_MASK
{		regs->ret += state.instr_len;		/* handle zero-overhead-loop */		if ((regs->ret == regs->lp_end) && (regs->lp_count)) {			regs->ret = regs->lp_start;			regs->lp_count--;		}	}
regs->ret += state.instr_len;
regs->ret += state.instr_len
regs->ret
regs
regs
ret
state.instr_len
state
state
instr_len
if ((regs->ret == regs->lp_end) && (regs->lp_count)) {			regs->ret = regs->lp_start;			regs->lp_count--;		}
(regs->ret == regs->lp_end) && (regs->lp_count)
(regs->ret == regs->lp_end)
regs->ret == regs->lp_end
regs->ret
regs
regs
ret
regs->lp_end
regs
regs
lp_end
(regs->lp_count)
regs->lp_count
regs
regs
lp_count
{			regs->ret = regs->lp_start;			regs->lp_count--;		}
regs->ret = regs->lp_start;
regs->ret = regs->lp_start
regs->ret
regs
regs
ret
regs->lp_start
regs
regs
lp_start
regs->lp_count--;
regs->lp_count--
regs->lp_count
regs
regs
lp_count
return 0;
0
fault:	pr_err("Alignment trap: fault in fix-up %08lx at [<%08lx>]\n",		state.words[0], address);
fault
pr_err("Alignment trap: fault in fix-up %08lx at [<%08lx>]\n",		state.words[0], address);
pr_err("Alignment trap: fault in fix-up %08lx at [<%08lx>]\n",		state.words[0], address)
pr_err
pr_err
"Alignment trap: fault in fix-up %08lx at [<%08lx>]\n"
state.words[0]
state.words
state
state
words
0
address
address
return 1;
1
-----joern-----
(101,60,0)
(83,87,0)
(65,75,0)
(51,100,0)
(35,24,0)
(25,133,0)
(108,75,0)
(102,45,0)
(38,7,0)
(50,60,0)
(113,135,0)
(125,17,0)
(137,22,0)
(60,74,0)
(67,75,0)
(144,35,0)
(131,46,0)
(42,117,0)
(85,100,0)
(56,139,0)
(111,20,0)
(41,74,0)
(1,65,0)
(26,14,0)
(37,67,0)
(7,75,0)
(12,65,0)
(133,4,0)
(36,75,0)
(90,36,0)
(135,113,0)
(92,39,0)
(20,4,0)
(71,93,0)
(15,94,0)
(65,12,0)
(117,93,0)
(86,10,0)
(91,106,0)
(34,131,0)
(76,137,0)
(68,38,0)
(116,75,0)
(116,99,0)
(103,145,0)
(79,145,0)
(4,30,0)
(103,9,0)
(39,75,0)
(83,47,0)
(128,62,0)
(97,10,0)
(7,100,0)
(46,95,0)
(18,116,0)
(11,100,0)
(52,74,0)
(35,22,0)
(87,67,0)
(102,132,0)
(102,89,0)
(141,46,0)
(47,83,0)
(132,102,0)
(80,10,0)
(7,38,0)
(91,130,0)
(104,23,0)
(123,137,0)
(5,75,0)
(81,73,0)
(70,46,0)
(104,36,0)
(93,75,0)
(4,20,0)
(96,14,0)
(78,95,0)
(67,87,0)
(74,52,0)
(16,102,0)
(112,108,0)
(8,145,0)
(19,7,0)
(17,33,0)
(93,117,0)
(104,70,0)
(77,65,0)
(43,47,0)
(74,60,0)
(119,13,0)
(72,102,0)
(62,137,0)
(39,102,0)
(29,141,0)
(120,108,0)
(23,5,0)
(0,35,0)
(61,135,0)
(33,52,0)
(70,104,0)
(13,75,0)
(136,7,0)
(2,20,0)
(121,36,0)
(9,103,0)
(27,132,0)
(126,106,0)
(124,113,0)
(17,131,0)
(53,70,0)
(108,12,0)
(17,100,0)
(6,70,0)
(87,83,0)
(137,62,0)
(109,93,0)
(7,22,0)
(115,139,0)
(31,100,0)
(102,72,0)
(36,104,0)
(145,89,0)
(40,24,0)
(32,9,0)
(17,108,0)
(57,4,0)
(138,72,0)
(91,17,0)
(66,33,0)
(7,14,0)
(143,100,0)
(48,139,0)
(33,75,0)
(145,103,0)
(98,73,0)
(59,132,0)
(105,141,0)
(24,35,0)
(107,7,0)
(12,127,0)
(139,56,0)
(131,75,0)
(70,75,0)
(88,116,0)
(60,75,0)
(99,127,0)
(63,33,0)
(55,5,0)
(130,100,0)
(3,131,0)
(58,100,0)
(35,75,0)
(10,80,0)
(134,103,0)
(102,39,0)
(46,141,0)
(113,80,0)
(110,5,0)
(21,130,0)
(118,135,0)
(114,100,0)
(44,102,0)
(117,64,0)
(129,94,0)
(145,100,0)
(49,39,0)
(140,100,0)
(23,104,0)
(142,9,0)
(14,75,0)
(14,7,0)
(28,100,0)
(52,64,0)
(99,116,0)
(69,100,0)
(4,133,0)
(137,75,0)
(5,23,0)
(80,113,0)
(29,105,1)
(35,22,1)
(81,98,1)
(137,75,1)
(68,14,1)
(125,99,1)
(63,13,1)
(108,75,1)
(13,75,1)
(20,111,1)
(19,38,1)
(26,102,1)
(80,10,1)
(122,73,1)
(38,68,1)
(96,26,1)
(98,7,1)
(72,138,1)
(132,59,1)
(70,46,1)
(106,126,1)
(47,43,1)
(16,72,1)
(21,145,1)
(46,141,1)
(34,13,1)
(4,20,1)
(53,6,1)
(139,115,1)
(79,54,1)
(7,107,1)
(10,86,1)
(101,50,1)
(80,113,1)
(14,96,1)
(93,75,1)
(2,57,1)
(141,29,1)
(7,38,1)
(36,121,1)
(8,103,1)
(65,75,1)
(35,75,1)
(24,40,1)
(138,132,1)
(17,131,1)
(73,81,1)
(92,16,1)
(118,61,1)
(109,52,1)
(107,136,1)
(145,103,1)
(15,137,1)
(87,67,1)
(137,22,1)
(67,75,1)
(116,75,1)
(17,33,1)
(86,97,1)
(110,104,1)
(102,72,1)
(61,73,1)
(36,75,1)
(113,135,1)
(79,122,1)
(5,55,1)
(115,48,1)
(91,17,1)
(145,8,1)
(70,75,1)
(44,84,1)
(9,142,1)
(112,23,1)
(13,119,1)
(55,110,1)
(104,36,1)
(130,21,1)
(120,112,1)
(134,9,1)
(14,75,1)
(74,60,1)
(56,139,1)
(111,2,1)
(70,53,1)
(103,134,1)
(7,22,1)
(57,84,1)
(5,75,1)
(41,60,1)
(129,15,1)
(33,66,1)
(79,82,1)
(117,42,1)
(12,65,1)
(17,108,1)
(35,24,1)
(83,47,1)
(3,34,1)
(108,120,1)
(142,32,1)
(90,70,1)
(144,0,1)
(91,130,1)
(32,79,1)
(71,109,1)
(88,18,1)
(105,131,1)
(0,24,1)
(121,90,1)
(145,89,1)
(124,135,1)
(23,104,1)
(102,89,1)
(119,94,1)
(97,113,1)
(6,46,1)
(65,77,1)
(59,27,1)
(23,5,1)
(66,63,1)
(60,75,1)
(125,117,1)
(1,108,1)
(131,3,1)
(82,80,1)
(15,35,1)
(33,75,1)
(102,39,1)
(18,12,1)
(43,87,1)
(128,56,1)
(93,71,1)
(103,9,1)
(137,123,1)
(40,56,1)
(67,37,1)
(4,133,1)
(126,83,1)
(50,33,1)
(49,92,1)
(27,44,1)
(117,93,1)
(26,4,1)
(42,93,1)
(131,75,1)
(25,20,1)
(76,62,1)
(84,83,1)
(102,132,1)
(123,76,1)
(83,87,1)
(17,125,1)
(62,128,1)
(54,94,1)
(136,19,1)
(125,23,1)
(35,144,1)
(7,75,1)
(94,129,1)
(77,1,1)
(52,74,1)
(135,118,1)
(39,75,1)
(133,25,1)
(39,49,1)
(99,116,1)
(137,62,1)
(113,124,1)
(91,106,1)
(74,41,1)
(7,14,1)
(116,88,1)
(60,101,1)
(104,70,1)
(48,80,1)
(80,73,2)
(44,84,2)
(14,83,2)
(8,73,2)
(131,13,2)
(17,108,2)
(76,56,2)
(84,83,2)
(9,80,2)
(115,80,2)
(29,13,2)
(24,56,2)
(132,84,2)
(103,94,2)
(47,87,2)
(7,75,2)
(131,75,2)
(142,73,2)
(8,80,2)
(80,10,2)
(32,80,2)
(56,139,2)
(117,93,2)
(50,13,2)
(97,113,2)
(122,73,2)
(6,13,2)
(144,56,2)
(111,84,2)
(4,133,2)
(136,83,2)
(94,80,2)
(145,80,2)
(134,73,2)
(68,83,2)
(26,83,2)
(125,94,2)
(7,83,2)
(61,73,2)
(99,23,2)
(103,9,2)
(21,80,2)
(123,56,2)
(23,13,2)
(110,104,2)
(32,73,2)
(33,13,2)
(13,75,2)
(63,13,2)
(17,131,2)
(57,84,2)
(35,22,2)
(2,84,2)
(92,84,2)
(137,75,2)
(137,22,2)
(35,75,2)
(36,75,2)
(20,84,2)
(54,94,2)
(39,75,2)
(112,23,2)
(13,94,2)
(87,67,2)
(82,80,2)
(79,94,2)
(7,22,2)
(93,13,2)
(109,13,2)
(36,13,2)
(77,23,2)
(72,84,2)
(88,23,2)
(52,74,2)
(18,23,2)
(121,13,2)
(141,13,2)
(23,104,2)
(93,75,2)
(49,84,2)
(104,70,2)
(83,47,2)
(71,13,2)
(35,56,2)
(40,56,2)
(81,83,2)
(90,13,2)
(134,94,2)
(120,23,2)
(130,73,2)
(104,13,2)
(83,87,2)
(33,75,2)
(102,39,2)
(102,72,2)
(86,113,2)
(39,84,2)
(145,103,2)
(55,104,2)
(142,80,2)
(16,84,2)
(102,89,2)
(145,94,2)
(19,83,2)
(25,84,2)
(108,23,2)
(48,80,2)
(41,13,2)
(74,60,2)
(62,56,2)
(70,13,2)
(104,36,2)
(134,80,2)
(59,84,2)
(56,80,2)
(138,84,2)
(8,94,2)
(42,13,2)
(99,116,2)
(80,113,2)
(34,13,2)
(142,94,2)
(130,94,2)
(43,87,2)
(17,33,2)
(73,83,2)
(3,13,2)
(7,14,2)
(91,106,2)
(139,80,2)
(102,84,2)
(137,56,2)
(145,89,2)
(137,62,2)
(91,17,2)
(102,132,2)
(17,94,2)
(128,56,2)
(23,5,2)
(126,83,2)
(52,13,2)
(21,94,2)
(7,38,2)
(1,23,2)
(119,94,2)
(98,83,2)
(10,113,2)
(21,73,2)
(60,13,2)
(91,130,2)
(70,75,2)
(67,75,2)
(129,80,2)
(116,23,2)
(133,84,2)
(5,104,2)
(118,73,2)
(74,13,2)
(12,23,2)
(14,75,2)
(113,135,2)
(27,84,2)
(9,73,2)
(135,73,2)
(101,13,2)
(46,13,2)
(9,94,2)
(107,83,2)
(113,73,2)
(105,13,2)
(12,65,2)
(103,73,2)
(103,80,2)
(96,83,2)
(35,24,2)
(60,75,2)
(79,80,2)
(5,75,2)
(70,46,2)
(0,56,2)
(32,94,2)
(65,75,2)
(4,84,2)
(106,83,2)
(53,13,2)
(66,13,2)
(116,75,2)
(124,73,2)
(38,83,2)
(145,73,2)
(117,13,2)
(79,73,2)
(108,75,2)
(15,80,2)
(130,80,2)
(65,23,2)
(46,141,2)
(4,20,2)
-----------------------------------
(0,regs)
(1,regs)
(2,buf)
(3,ret)
(4,pr_warn_once("%s(%d)
(5,regs->lp_count)
(6,regs)
(7,disasm_instr(regs->ret, &state, 1, regs, cregs)
(8,address)
(9,state.words)
(10,state.di)
(11,if (!state.write)
(12,regs->ret = regs->lp_start)
(13,delay_mode(regs)
(14,regs->ret)
(15,state)
(16,address)
(17,return 0;)
(18,regs)
(19,1)
(20,get_task_comm(buf, current)
(21,1)
(22,struct callee_regs *cregs)
(23,(regs->ret == regs->lp_end)
(24,&state)
(25,current)
(26,regs)
(27,buf)
(28,fault:)
(29,instr_len)
(30,)
(31,buf)
(32,state)
(33,regs->ret)
(34,regs)
(35,fixup_store(&state, regs, cregs)
(36,regs->lp_end)
(37,regs)
(38,&state)
(39,regs->ret)
(40,state)
(41,~1U)
(42,~STATUS_DE_MASK)
(43,unaligned_enabled)
(44,"%s(%d)
(45,)
(46,regs->ret += state.instr_len)
(47,!unaligned_enabled)
(48,state)
(49,ret)
(50,regs)
(51,if (state.fault)
(52,regs->ret = regs->bta & ~1U)
(53,ret)
(54,goto fault;)
(55,lp_count)
(56,!state.write)
(57,"%s(%d)
(58,if (!user_mode(regs)
(59,current)
(60,regs->bta)
(61,state)
(62,&state)
(63,regs)
(64,)
(65,regs->lp_start)
(66,ret)
(67,user_mode(regs)
(68,state)
(69,if ((state.zz == 1)
(70,regs->ret)
(71,status32)
(72,task_pid_nr(current)
(73,state.fault)
(74,regs->bta & ~1U)
(75,struct pt_regs *regs)
(76,regs)
(77,lp_start)
(78,if ((regs->ret == regs->lp_end)
(79,"Alignment trap: fault in fix-up %08lx at [<%08lx>]\\n")
(80,(state.zz == 1)
(81,fault)
(82,goto fault;)
(83,!user_mode(regs)
(84,no_unaligned_warning)
(85,if (delay_mode(regs)
(86,di)
(87,!user_mode(regs)
(88,lp_count)
(89,unsigned long address)
(90,regs)
(91,RET)
(92,regs)
(93,regs->status32)
(94,state.fault)
(95,)
(96,ret)
(97,state)
(98,state)
(99,regs->lp_count--)
(100,)
(101,bta)
(102,pr_warn("%s(%d)
(103,state.words[0])
(104,regs->ret == regs->lp_end)
(105,state)
(106,return 1;)
(107,cregs)
(108,regs->ret)
(109,regs)
(110,regs)
(111,current)
(112,regs)
(113,state.zz == 1)
(114,if (state.fault)
(115,write)
(116,regs->lp_count)
(117,regs->status32 &= ~STATUS_DE_MASK)
(118,zz)
(119,regs)
(120,ret)
(121,lp_end)
(122,goto fault;)
(123,cregs)
(124,1)
(125,0)
(126,1)
(127,)
(128,state)
(129,fault)
(130,return 1;)
(131,regs->ret)
(132,get_task_comm(buf, current)
(133,task_pid_nr(current)
(134,0)
(135,state.zz)
(136,regs)
(137,fixup_load(&state, regs, cregs)
(138,current)
(139,state.write)
(140,state)
(141,state.instr_len)
(142,words)
(143,if (no_unaligned_warning)
(144,cregs)
(145,pr_err("Alignment trap: fault in fix-up %08lx at [<%08lx>]\\n",\n\\n\\t\\tstate.words[0], address)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^