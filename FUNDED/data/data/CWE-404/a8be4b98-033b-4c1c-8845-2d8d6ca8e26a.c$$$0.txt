-----label-----
1
-----code-----
int ksched_setscheduler(register_t *ret, struct ksched *ksched,
	struct proc *p, int policy, const struct sched_param *param)
{
	int e = 0;
	struct rtprio rtp;

	switch(policy)
	{
		case SCHED_RR:
		case SCHED_FIFO:

		if (param->sched_priority >= P1B_PRIO_MIN &&
		param->sched_priority <= P1B_PRIO_MAX)
		{
			rtp.prio = p4prio_to_rtpprio(param->sched_priority);
			rtp.type = (policy == SCHED_FIFO)
				? RTP_PRIO_FIFO : RTP_PRIO_REALTIME;

			p->p_lwp.lwp_rtprio = rtp;
			need_user_resched();
		}
		else
			e = EPERM;


		break;

		case SCHED_OTHER:
		{
			rtp.type = RTP_PRIO_NORMAL;
			rtp.prio = p4prio_to_rtpprio(param->sched_priority);
			p->p_lwp.lwp_rtprio = rtp;

			/* XXX Simply revert to whatever we had for last
			 *     normal scheduler priorities.
			 *     This puts a requirement
			 *     on the scheduling code: You must leave the
			 *     scheduling info alone.
			 */
			need_user_resched();
		}
		break;
	}

	return e;
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
3,7
3,8
3,9
5,6
5,7
6,7
8,9
8,10
11,12
11,13
12,13
14,15
14,16
17,18
17,19
18,19
20,21
20,22
23,24
23,25
25,26
27,28
27,29
28,29
30,31
30,32
33,34
33,35
33,36
33,37
34,35
35,36
35,37
37,38
37,39
39,40
41,42
42,43
42,44
43,44
45,46
47,48
47,49
48,49
50,51
50,52
50,53
50,54
50,55
50,56
50,57
51,52
52,53
54,55
55,56
57,58
57,59
57,60
58,59
58,60
59,60
59,61
60,61
60,62
61,62
64,65
66,67
66,68
67,68
67,69
68,69
71,72
73,74
73,75
73,76
73,77
74,75
75,76
75,77
76,77
76,78
77,78
80,81
80,82
81,82
83,84
83,85
84,85
87,88
88,89
88,90
89,90
89,91
90,91
93,94
93,95
93,96
94,95
95,96
95,97
96,97
98,99
100,101
102,103
104,105
105,106
105,107
106,107
106,108
107,108
107,109
108,109
112,113
114,115
115,116
116,117
118,119
119,120
119,121
120,121
122,123
125,126
126,127
128,129
128,130
128,131
128,132
129,130
130,131
130,132
131,132
131,133
132,133
135,136
137,138
138,139
138,140
139,140
139,141
140,141
143,144
143,145
144,145
146,147
146,148
147,148
150,151
151,152
151,153
152,153
152,154
153,154
153,155
154,155
158,159
160,161
161,162
162,163
165,166
166,167
-----nextToken-----
2,4,7,9,10,13,15,16,19,21,22,24,26,29,31,32,36,38,40,44,46,49,53,56,62,63,65,69,70,72,78,79,82,85,86,91,92,97,99,101,103,109,110,111,113,117,121,123,124,127,133,134,136,141,142,145,148,149,155,156,157,159,163,164,167
-----computeFrom-----
58,59
58,60
59,60
59,61
66,67
66,68
75,76
75,77
88,89
88,90
95,96
95,97
105,106
105,107
119,120
119,121
130,131
130,132
138,139
138,140
151,152
151,153
-----guardedBy-----
69,85
70,86
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;SwitchStatement;IdExpression;Name;CompoundStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;ConditionalExpression;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BreakStatement;ReturnStatement;IdExpression;Name;
-----ast_node-----
int ksched_setscheduler(register_t *ret, struct ksched *ksched,	struct proc *p, int policy, const struct sched_param *param){	int e = 0;	struct rtprio rtp;	switch(policy)	{		case SCHED_RR:		case SCHED_FIFO:		if (param->sched_priority >= P1B_PRIO_MIN &&		param->sched_priority <= P1B_PRIO_MAX)		{			rtp.prio = p4prio_to_rtpprio(param->sched_priority);			rtp.type = (policy == SCHED_FIFO)				? RTP_PRIO_FIFO : RTP_PRIO_REALTIME;			p->p_lwp.lwp_rtprio = rtp;			need_user_resched();		}		else			e = EPERM;		break;		case SCHED_OTHER:		{			rtp.type = RTP_PRIO_NORMAL;			rtp.prio = p4prio_to_rtpprio(param->sched_priority);			p->p_lwp.lwp_rtprio = rtp;			/* XXX Simply revert to whatever we had for last			 *     normal scheduler priorities.			 *     This puts a requirement			 *     on the scheduling code: You must leave the			 *     scheduling info alone.			 */			need_user_resched();		}		break;	}	return e;}
int
ksched_setscheduler(register_t *ret, struct ksched *ksched,	struct proc *p, int policy, const struct sched_param *param)
ksched_setscheduler
register_t *ret
register_t
register_t
*ret
*
ret
struct ksched *ksched
struct ksched
ksched
*ksched
*
ksched
struct proc *p
struct proc
proc
*p
*
p
int policy
int
policy
policy
const struct sched_param *param
const struct sched_param
sched_param
*param
*
param
{	int e = 0;	struct rtprio rtp;	switch(policy)	{		case SCHED_RR:		case SCHED_FIFO:		if (param->sched_priority >= P1B_PRIO_MIN &&		param->sched_priority <= P1B_PRIO_MAX)		{			rtp.prio = p4prio_to_rtpprio(param->sched_priority);			rtp.type = (policy == SCHED_FIFO)				? RTP_PRIO_FIFO : RTP_PRIO_REALTIME;			p->p_lwp.lwp_rtprio = rtp;			need_user_resched();		}		else			e = EPERM;		break;		case SCHED_OTHER:		{			rtp.type = RTP_PRIO_NORMAL;			rtp.prio = p4prio_to_rtpprio(param->sched_priority);			p->p_lwp.lwp_rtprio = rtp;			/* XXX Simply revert to whatever we had for last			 *     normal scheduler priorities.			 *     This puts a requirement			 *     on the scheduling code: You must leave the			 *     scheduling info alone.			 */			need_user_resched();		}		break;	}	return e;}
int e = 0;
int e = 0;
int
e = 0
e
= 0
0
struct rtprio rtp;
struct rtprio rtp;
struct rtprio
rtprio
rtp
rtp
switch(policy)	{		case SCHED_RR:		case SCHED_FIFO:		if (param->sched_priority >= P1B_PRIO_MIN &&		param->sched_priority <= P1B_PRIO_MAX)		{			rtp.prio = p4prio_to_rtpprio(param->sched_priority);			rtp.type = (policy == SCHED_FIFO)				? RTP_PRIO_FIFO : RTP_PRIO_REALTIME;			p->p_lwp.lwp_rtprio = rtp;			need_user_resched();		}		else			e = EPERM;		break;		case SCHED_OTHER:		{			rtp.type = RTP_PRIO_NORMAL;			rtp.prio = p4prio_to_rtpprio(param->sched_priority);			p->p_lwp.lwp_rtprio = rtp;			/* XXX Simply revert to whatever we had for last			 *     normal scheduler priorities.			 *     This puts a requirement			 *     on the scheduling code: You must leave the			 *     scheduling info alone.			 */			need_user_resched();		}		break;	}
policy
policy
{		case SCHED_RR:		case SCHED_FIFO:		if (param->sched_priority >= P1B_PRIO_MIN &&		param->sched_priority <= P1B_PRIO_MAX)		{			rtp.prio = p4prio_to_rtpprio(param->sched_priority);			rtp.type = (policy == SCHED_FIFO)				? RTP_PRIO_FIFO : RTP_PRIO_REALTIME;			p->p_lwp.lwp_rtprio = rtp;			need_user_resched();		}		else			e = EPERM;		break;		case SCHED_OTHER:		{			rtp.type = RTP_PRIO_NORMAL;			rtp.prio = p4prio_to_rtpprio(param->sched_priority);			p->p_lwp.lwp_rtprio = rtp;			/* XXX Simply revert to whatever we had for last			 *     normal scheduler priorities.			 *     This puts a requirement			 *     on the scheduling code: You must leave the			 *     scheduling info alone.			 */			need_user_resched();		}		break;	}
case SCHED_RR:
SCHED_RR
SCHED_RR
case SCHED_FIFO:
SCHED_FIFO
SCHED_FIFO
if (param->sched_priority >= P1B_PRIO_MIN &&		param->sched_priority <= P1B_PRIO_MAX)		{			rtp.prio = p4prio_to_rtpprio(param->sched_priority);			rtp.type = (policy == SCHED_FIFO)				? RTP_PRIO_FIFO : RTP_PRIO_REALTIME;			p->p_lwp.lwp_rtprio = rtp;			need_user_resched();		}		else			e = EPERM;
param->sched_priority >= P1B_PRIO_MIN &&		param->sched_priority <= P1B_PRIO_MAX
param->sched_priority >= P1B_PRIO_MIN
param->sched_priority
param
param
sched_priority
P1B_PRIO_MIN
P1B_PRIO_MIN
param->sched_priority <= P1B_PRIO_MAX
param->sched_priority
param
param
sched_priority
P1B_PRIO_MAX
P1B_PRIO_MAX
{			rtp.prio = p4prio_to_rtpprio(param->sched_priority);			rtp.type = (policy == SCHED_FIFO)				? RTP_PRIO_FIFO : RTP_PRIO_REALTIME;			p->p_lwp.lwp_rtprio = rtp;			need_user_resched();		}
rtp.prio = p4prio_to_rtpprio(param->sched_priority);
rtp.prio = p4prio_to_rtpprio(param->sched_priority)
rtp.prio
rtp
rtp
prio
p4prio_to_rtpprio(param->sched_priority)
p4prio_to_rtpprio
p4prio_to_rtpprio
param->sched_priority
param
param
sched_priority
rtp.type = (policy == SCHED_FIFO)				? RTP_PRIO_FIFO : RTP_PRIO_REALTIME;
rtp.type = (policy == SCHED_FIFO)				? RTP_PRIO_FIFO : RTP_PRIO_REALTIME
rtp.type
rtp
rtp
type
(policy == SCHED_FIFO)				? RTP_PRIO_FIFO : RTP_PRIO_REALTIME
(policy == SCHED_FIFO)
policy == SCHED_FIFO
policy
policy
SCHED_FIFO
SCHED_FIFO
RTP_PRIO_FIFO
RTP_PRIO_FIFO
RTP_PRIO_REALTIME
RTP_PRIO_REALTIME
p->p_lwp.lwp_rtprio = rtp;
p->p_lwp.lwp_rtprio = rtp
p->p_lwp.lwp_rtprio
p->p_lwp
p
p
p_lwp
lwp_rtprio
rtp
rtp
need_user_resched();
need_user_resched()
need_user_resched
need_user_resched
e = EPERM;
e = EPERM
e
e
EPERM
EPERM
break;
case SCHED_OTHER:
SCHED_OTHER
SCHED_OTHER
{			rtp.type = RTP_PRIO_NORMAL;			rtp.prio = p4prio_to_rtpprio(param->sched_priority);			p->p_lwp.lwp_rtprio = rtp;			/* XXX Simply revert to whatever we had for last			 *     normal scheduler priorities.			 *     This puts a requirement			 *     on the scheduling code: You must leave the			 *     scheduling info alone.			 */			need_user_resched();		}
rtp.type = RTP_PRIO_NORMAL;
rtp.type = RTP_PRIO_NORMAL
rtp.type
rtp
rtp
type
RTP_PRIO_NORMAL
RTP_PRIO_NORMAL
rtp.prio = p4prio_to_rtpprio(param->sched_priority);
rtp.prio = p4prio_to_rtpprio(param->sched_priority)
rtp.prio
rtp
rtp
prio
p4prio_to_rtpprio(param->sched_priority)
p4prio_to_rtpprio
p4prio_to_rtpprio
param->sched_priority
param
param
sched_priority
p->p_lwp.lwp_rtprio = rtp;
p->p_lwp.lwp_rtprio = rtp
p->p_lwp.lwp_rtprio
p->p_lwp
p
p
p_lwp
lwp_rtprio
rtp
rtp
need_user_resched();
need_user_resched()
need_user_resched
need_user_resched
break;
return e;
e
e
-----joern-----
(22,45,0)
(43,81,0)
(29,33,0)
(55,38,0)
(36,67,0)
(83,82,0)
(81,78,0)
(75,81,0)
(63,82,0)
(57,67,0)
(59,47,0)
(18,67,0)
(78,70,0)
(69,49,0)
(3,73,0)
(1,61,0)
(28,73,0)
(35,10,0)
(78,81,0)
(52,41,0)
(21,31,0)
(68,23,0)
(81,75,0)
(21,38,0)
(30,61,0)
(41,4,0)
(47,59,0)
(10,53,0)
(4,77,0)
(65,1,0)
(42,69,0)
(16,35,0)
(59,44,0)
(66,22,0)
(38,70,0)
(26,67,0)
(32,66,0)
(46,34,0)
(45,53,0)
(61,67,0)
(64,44,0)
(11,82,0)
(72,67,0)
(77,5,0)
(64,35,0)
(22,66,0)
(47,1,0)
(69,75,0)
(13,6,0)
(74,34,0)
(24,82,0)
(60,67,0)
(17,33,0)
(34,73,0)
(77,4,0)
(14,78,0)
(76,49,0)
(45,22,0)
(15,61,0)
(79,83,0)
(49,70,0)
(25,47,0)
(23,15,0)
(31,21,0)
(58,64,0)
(20,49,0)
(31,61,0)
(54,59,0)
(75,69,0)
(7,64,0)
(51,83,0)
(4,53,0)
(12,77,0)
(50,66,0)
(62,78,0)
(80,10,0)
(66,70,0)
(38,21,0)
(8,59,0)
(5,77,0)
(71,5,0)
(6,45,0)
(49,69,0)
(5,37,0)
(2,38,0)
(19,23,0)
(27,41,0)
(35,64,0)
(48,77,0)
(34,82,0)
(39,6,0)
(0,53,0)
(9,15,0)
(34,83,0)
(33,31,0)
(56,5,0)
(69,42,1)
(36,73,1)
(42,49,1)
(5,71,1)
(38,70,1)
(77,12,1)
(4,77,1)
(65,47,1)
(35,64,1)
(30,1,1)
(75,69,1)
(77,5,1)
(2,55,1)
(45,22,1)
(33,29,1)
(21,38,1)
(28,75,1)
(3,28,1)
(74,36,1)
(56,41,1)
(59,44,1)
(1,65,1)
(41,52,1)
(17,15,1)
(6,13,1)
(20,40,1)
(50,32,1)
(47,59,1)
(47,25,1)
(62,14,1)
(66,50,1)
(7,4,1)
(79,51,1)
(14,69,1)
(27,45,1)
(31,21,1)
(8,54,1)
(39,75,1)
(74,72,1)
(58,7,1)
(48,5,1)
(16,64,1)
(49,70,1)
(10,80,1)
(32,6,1)
(25,59,1)
(64,58,1)
(12,5,1)
(59,8,1)
(52,27,1)
(43,78,1)
(35,16,1)
(64,44,1)
(72,30,1)
(77,48,1)
(9,23,1)
(54,31,1)
(13,39,1)
(36,0,1)
(23,68,1)
(34,74,1)
(55,33,1)
(81,43,1)
(34,83,1)
(29,17,1)
(83,79,1)
(22,66,1)
(68,19,1)
(69,49,1)
(5,37,1)
(38,2,1)
(75,81,1)
(74,40,1)
(40,83,1)
(49,76,1)
(34,73,1)
(15,9,1)
(46,34,1)
(71,56,1)
(78,70,1)
(80,35,1)
(76,20,1)
(19,40,1)
(66,70,1)
(81,78,1)
(78,62,1)
(0,10,1)
(73,3,1)
(69,49,2)
(20,40,2)
(31,21,2)
(25,40,2)
(42,40,2)
(59,40,2)
(5,75,2)
(43,69,2)
(58,75,2)
(19,40,2)
(73,75,2)
(47,40,2)
(8,40,2)
(56,75,2)
(76,40,2)
(16,75,2)
(62,69,2)
(46,34,2)
(49,40,2)
(36,40,2)
(28,75,2)
(9,40,2)
(10,75,2)
(45,75,2)
(69,40,2)
(0,75,2)
(1,40,2)
(80,75,2)
(31,40,2)
(75,40,2)
(50,75,2)
(3,75,2)
(13,75,2)
(12,5,2)
(77,5,2)
(72,40,2)
(33,40,2)
(38,70,2)
(49,70,2)
(48,5,2)
(27,75,2)
(14,69,2)
(5,37,2)
(35,64,2)
(4,77,2)
(4,75,2)
(22,75,2)
(66,70,2)
(15,40,2)
(38,40,2)
(32,75,2)
(21,38,2)
(34,73,2)
(35,75,2)
(2,40,2)
(78,69,2)
(55,40,2)
(54,40,2)
(59,44,2)
(39,75,2)
(47,59,2)
(65,40,2)
(45,22,2)
(75,81,2)
(17,40,2)
(6,75,2)
(30,40,2)
(21,40,2)
(64,75,2)
(41,75,2)
(29,40,2)
(75,69,2)
(81,69,2)
(71,75,2)
(52,75,2)
(77,75,2)
(66,75,2)
(7,75,2)
(22,66,2)
(23,40,2)
(34,83,2)
(68,40,2)
(64,44,2)
(78,70,2)
(81,78,2)
-----------------------------------
(0,need_user_resched()
(1,p->p_lwp.lwp_rtprio = rtp)
(2,sched_priority)
(3,EPERM)
(4,rtp.type = (policy == SCHED_FIFO)
(5,policy == SCHED_FIFO)
(6,rtp.prio)
(7,p)
(8,p_lwp)
(9,RTP_PRIO_NORMAL)
(10,p->p_lwp.lwp_rtprio = rtp)
(11,e)
(12,RTP_PRIO_REALTIME)
(13,prio)
(14,param)
(15,rtp.type = RTP_PRIO_NORMAL)
(16,lwp_rtprio)
(17,rtp)
(18,case SCHED_OTHER:)
(19,rtp)
(20,param)
(21,p4prio_to_rtpprio(param->sched_priority)
(22,p4prio_to_rtpprio(param->sched_priority)
(23,rtp.type)
(24,rtp)
(25,lwp_rtprio)
(26,if (param->sched_priority >= P1B_PRIO_MIN &&\n\\n\\t\\tparam->sched_priority <= P1B_PRIO_MAX)
(27,rtp)
(28,e)
(29,prio)
(30,need_user_resched()
(31,rtp.prio = p4prio_to_rtpprio(param->sched_priority)
(32,param)
(33,rtp.prio)
(34,return e;)
(35,p->p_lwp.lwp_rtprio)
(36,break;)
(37,int policy)
(38,param->sched_priority)
(39,rtp)
(40,policy)
(41,rtp.type)
(42,P1B_PRIO_MIN)
(43,P1B_PRIO_MAX)
(44,struct proc *p)
(45,rtp.prio = p4prio_to_rtpprio(param->sched_priority)
(46,RET)
(47,p->p_lwp.lwp_rtprio)
(48,RTP_PRIO_FIFO)
(49,param->sched_priority)
(50,sched_priority)
(51,e)
(52,type)
(53,)
(54,p)
(55,param)
(56,policy)
(57,case SCHED_RR:)
(58,p_lwp)
(59,p->p_lwp)
(60,case SCHED_FIFO:)
(61,)
(62,sched_priority)
(63,switch(policy)
(64,p->p_lwp)
(65,rtp)
(66,param->sched_priority)
(67,)
(68,type)
(69,param->sched_priority >= P1B_PRIO_MIN)
(70,const struct sched_param *param)
(71,SCHED_FIFO)
(72,break;)
(73,e = EPERM)
(74,e)
(75,param->sched_priority >= P1B_PRIO_MIN &&\n\\n\\t\\tparam->sched_priority <= P1B_PRIO_MAX)
(76,sched_priority)
(77,(policy == SCHED_FIFO)
(78,param->sched_priority)
(79,0)
(80,rtp)
(81,param->sched_priority <= P1B_PRIO_MAX)
(82,)
(83,e = 0)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^