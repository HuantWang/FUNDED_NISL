-----label-----
1
-----code-----
void
vinum_daemon(void)
{
    struct daemonq *request;

    curproc->p_flag |= P_INMEM | P_SYSTEM;		    /* we're a system process */
    daemon_save_config();				    /* start by saving the configuration */
    daemonpid = curproc->p_pid;				    /* mark our territory */
    while (1) {
	tsleep(&vinum_daemon, 0, "vinum", 0);	    /* wait for something to happen */

	/*
	 * It's conceivable that, as the result of an
	 * I/O error, we'll be out of action long
	 * enough that another daemon gets started.
	 * That's OK, just give up gracefully.
	 */
	if (curproc->p_pid != daemonpid) {		    /* we've been ousted in our sleep */
	    if (daemon_options & daemon_verbose)
		log(LOG_INFO, "vinum: abdicating\n");
	    return;
	}
	while (daemonq != NULL) {			    /* we have work to do, */
	    crit_enter();
	    request = daemonq;				    /* get the request */
	    daemonq = daemonq->next;			    /* and detach it */
	    if (daemonq == NULL)			    /* got to the end, */
		dqend = NULL;				    /* no end any more */
	    crit_exit();

	    switch (request->type) {
		/*
		 * We had an I/O error on a request.  Go through the
		 * request and try to salvage it
		 */
	    case daemonrq_ioerror:
		if (daemon_options & daemon_verbose) {
		    struct request *rq = request->info.rq;

		    log(LOG_WARNING,
			"vinum: recovering I/O request: %p\n%s dev %d.%d, offset 0x%x, length %ld\n",
			rq,
			rq->bp->b_flags & B_READ ? "Read" : "Write",
			major(rq->bp->b_dev),
			minor(rq->bp->b_dev),
			rq->bp->b_blkno,
			rq->bp->b_bcount);
		}
		recover_io(request->info.rq);		    /* the failed request */
		break;

		/*
		 * Write the config to disk.  We could end up with
		 * quite a few of these in a row.  Only honour the
		 * last one
		 */
	    case daemonrq_saveconfig:
		if ((daemonq == NULL)			    /* no more requests */
		||(daemonq->type != daemonrq_saveconfig)) { /* or the next isn't the same */
		    if (((daemon_options & daemon_noupdate) == 0) /* we're allowed to do it */
		    &&((vinum_conf.flags & VF_READING_CONFIG) == 0)) { /* and we're not building the config now */
			/*
			   * We obviously don't want to save a
			   * partial configuration.  Less obviously,
			   * we don't need to do anything if we're
			   * asked to write the config when we're
			   * building it up, because we save it at
			   * the end.
			 */
			if (daemon_options & daemon_verbose)
			    log(LOG_INFO, "vinum: saving config\n");
			daemon_save_config();		    /* save it */
		    }
		}
		break;

	    case daemonrq_return:			    /* been told to stop */
		if (daemon_options & daemon_verbose)
		    log(LOG_INFO, "vinum: stopping\n");
		daemon_options |= daemon_stopped;	    /* note that we've stopped */
		Free(request);
		while (daemonq != NULL) {		    /* backed up requests, */
		    request = daemonq;			    /* get the request */
		    daemonq = daemonq->next;		    /* and detach it */
		    Free(request);			    /* then free it */
		}
		wakeup(&vinumclose);			    /* and wake any waiting vinum(8)s */
		return;

	    case daemonrq_ping:				    /* tell the caller we're here */
		if (daemon_options & daemon_verbose)
		    log(LOG_INFO, "vinum: ping reply\n");
		wakeup(&vinum_finddaemon);		    /* wake up the caller */
		break;

	    case daemonrq_closedrive:			    /* close a drive */
		close_drive(request->info.drive);	    /* do it */
		break;

	    case daemonrq_init:				    /* initialize a plex */
		/* XXX */
	    case daemonrq_revive:			    /* revive a subdisk */
		/* XXX */
		/* FALLTHROUGH */
	    default:
		log(LOG_WARNING, "Invalid request\n");
		break;
	    }
	    if (request->privateinuse)			    /* one of ours, */
		request->privateinuse = 0;		    /* no longer in use */
	    else
		Free(request);				    /* return it */
	}
    }
}
-----children-----
1,2
1,3
1,4
3,4
3,5
5,6
5,7
7,8
9,10
9,11
9,12
9,13
9,14
10,11
11,12
11,13
12,13
14,15
14,16
17,18
18,19
18,20
19,20
19,21
20,21
23,24
23,25
24,25
26,27
28,29
29,30
30,31
32,33
33,34
33,35
34,35
36,37
36,38
37,38
40,41
40,42
42,43
42,44
42,45
43,44
44,45
44,46
44,47
44,48
44,49
45,46
47,48
48,49
53,54
53,55
54,55
54,56
55,56
55,57
56,57
59,60
61,62
61,63
62,63
62,64
63,64
63,65
64,65
66,67
66,68
69,70
70,71
70,72
70,73
71,72
73,74
77,78
77,79
78,79
78,80
79,80
81,82
83,84
83,85
83,86
83,87
83,88
83,89
83,90
84,85
85,86
86,87
88,89
89,90
89,91
90,91
92,93
94,95
95,96
95,97
96,97
98,99
98,100
99,100
102,103
102,104
103,104
103,105
104,105
106,107
108,109
109,110
109,111
110,111
112,113
114,115
115,116
116,117
118,119
118,120
119,120
119,121
120,121
123,124
123,125
123,126
123,127
123,128
123,129
123,130
123,131
123,132
123,133
123,134
123,135
123,136
123,137
123,138
123,139
123,140
123,141
123,142
123,143
123,144
123,145
123,146
123,147
123,148
123,149
124,125
125,126
127,128
127,129
128,129
128,130
129,130
131,132
131,133
134,135
134,136
135,136
136,137
136,138
137,138
139,140
139,141
139,142
142,143
143,144
143,145
144,145
144,146
145,146
149,150
150,151
150,152
150,153
150,154
150,155
150,156
150,157
150,158
150,159
151,152
153,154
156,157
158,159
158,160
158,161
159,160
159,161
160,161
160,162
161,162
161,163
162,163
166,167
170,171
170,172
171,172
173,174
173,175
174,175
174,176
175,176
179,180
179,181
180,181
182,183
182,184
183,184
183,185
184,185
188,189
188,190
189,190
189,191
190,191
194,195
194,196
195,196
195,197
196,197
200,201
201,202
201,203
202,203
204,205
204,206
205,206
205,207
206,207
211,212
212,213
214,215
214,216
215,216
215,217
216,217
217,218
217,219
218,219
220,221
222,223
223,224
223,225
224,225
224,226
225,226
228,229
230,231
231,232
231,233
232,233
232,234
233,234
234,235
234,236
235,236
236,237
236,238
237,238
239,240
242,243
243,244
243,245
244,245
245,246
245,247
246,247
246,248
247,248
250,251
253,254
253,255
254,255
254,256
255,256
255,257
256,257
258,259
258,260
261,262
262,263
262,264
262,265
263,264
265,266
268,269
269,270
270,271
273,274
274,275
276,277
276,278
277,278
277,279
278,279
280,281
280,282
283,284
284,285
284,286
284,287
285,286
287,288
290,291
291,292
291,293
292,293
294,295
296,297
297,298
297,299
298,299
300,301
302,303
302,304
303,304
303,305
304,305
306,307
308,309
308,310
308,311
309,310
310,311
310,312
311,312
313,314
315,316
316,317
316,318
317,318
319,320
319,321
320,321
323,324
324,325
324,326
325,326
327,328
329,330
330,331
330,332
331,332
333,334
334,335
334,336
338,339
339,340
341,342
341,343
342,343
342,344
343,344
345,346
345,347
348,349
349,350
349,351
349,352
350,351
352,353
355,356
356,357
356,358
357,358
359,360
360,361
360,362
364,365
365,366
367,368
368,369
368,370
369,370
371,372
371,373
372,373
372,374
373,374
378,379
379,380
381,382
382,383
385,386
386,387
386,388
386,389
387,388
389,390
393,394
393,395
393,396
394,395
394,396
395,396
398,399
399,400
399,401
400,401
400,402
401,402
405,406
406,407
406,408
407,408
409,410
-----nextToken-----
2,4,6,8,13,15,16,21,22,25,27,31,35,38,39,41,46,49,50,51,52,57,58,60,65,67,68,72,74,75,76,80,82,87,91,93,97,100,101,105,107,111,113,117,121,122,126,130,132,133,138,140,141,146,147,148,152,154,155,157,163,164,165,167,168,169,172,176,177,178,181,185,186,187,191,192,193,197,198,199,203,207,208,209,210,213,219,221,226,227,229,238,240,241,248,249,251,252,257,259,260,264,266,267,271,272,275,279,281,282,286,288,289,293,295,299,301,305,307,312,314,318,321,322,326,328,332,335,336,337,340,344,346,347,351,353,354,358,361,362,363,366,370,374,375,376,377,380,383,384,388,390,391,392,396,397,402,403,404,408,410
-----computeFrom-----
18,19
18,20
23,24
23,25
33,34
33,35
54,55
54,56
78,79
78,80
89,90
89,91
95,96
95,97
103,104
103,105
109,110
109,111
159,160
159,161
215,216
215,217
217,218
217,219
223,224
223,225
232,233
232,234
234,235
234,236
236,237
236,238
243,244
243,245
245,246
245,247
291,292
291,293
303,304
303,305
310,311
310,312
316,317
316,318
399,400
399,401
-----guardedBy-----
107,113
238,257
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;WhileStatement;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;LiteralExpression;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ReferenceOperator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ReturnStatement;WhileStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;SwitchStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;CaseStatement;IdExpression;Name;IfStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ReferenceOperator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;ConditionalExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;UnaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;CompoundStatement;IfStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ReferenceOperator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;IfStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ReferenceOperator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;WhileStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;ReferenceOperator;Name;ReturnStatement;CaseStatement;IdExpression;Name;IfStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;ReferenceOperator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;ReferenceOperator;Name;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;DefaultStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;BreakStatement;IfStatement;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;
-----ast_node-----
voidvinum_daemon(void){    struct daemonq *request;    curproc->p_flag |= P_INMEM | P_SYSTEM;		    /* we're a system process */    daemon_save_config();				    /* start by saving the configuration */    daemonpid = curproc->p_pid;				    /* mark our territory */    while (1) {	tsleep(&vinum_daemon, 0, "vinum", 0);	    /* wait for something to happen */	/*	 * It's conceivable that, as the result of an	 * I/O error, we'll be out of action long	 * enough that another daemon gets started.	 * That's OK, just give up gracefully.	 */	if (curproc->p_pid != daemonpid) {		    /* we've been ousted in our sleep */	    if (daemon_options & daemon_verbose)		log(LOG_INFO, "vinum: abdicating\n");	    return;	}	while (daemonq != NULL) {			    /* we have work to do, */	    crit_enter();	    request = daemonq;				    /* get the request */	    daemonq = daemonq->next;			    /* and detach it */	    if (daemonq == NULL)			    /* got to the end, */		dqend = NULL;				    /* no end any more */	    crit_exit();	    switch (request->type) {		/*		 * We had an I/O error on a request.  Go through the		 * request and try to salvage it		 */	    case daemonrq_ioerror:		if (daemon_options & daemon_verbose) {		    struct request *rq = request->info.rq;		    log(LOG_WARNING,			"vinum: recovering I/O request: %p\n%s dev %d.%d, offset 0x%x, length %ld\n",			rq,			rq->bp->b_flags & B_READ ? "Read" : "Write",			major(rq->bp->b_dev),			minor(rq->bp->b_dev),			rq->bp->b_blkno,			rq->bp->b_bcount);		}		recover_io(request->info.rq);		    /* the failed request */		break;		/*		 * Write the config to disk.  We could end up with		 * quite a few of these in a row.  Only honour the		 * last one		 */	    case daemonrq_saveconfig:		if ((daemonq == NULL)			    /* no more requests */		||(daemonq->type != daemonrq_saveconfig)) { /* or the next isn't the same */		    if (((daemon_options & daemon_noupdate) == 0) /* we're allowed to do it */		    &&((vinum_conf.flags & VF_READING_CONFIG) == 0)) { /* and we're not building the config now */			/*			   * We obviously don't want to save a			   * partial configuration.  Less obviously,			   * we don't need to do anything if we're			   * asked to write the config when we're			   * building it up, because we save it at			   * the end.			 */			if (daemon_options & daemon_verbose)			    log(LOG_INFO, "vinum: saving config\n");			daemon_save_config();		    /* save it */		    }		}		break;	    case daemonrq_return:			    /* been told to stop */		if (daemon_options & daemon_verbose)		    log(LOG_INFO, "vinum: stopping\n");		daemon_options |= daemon_stopped;	    /* note that we've stopped */		Free(request);		while (daemonq != NULL) {		    /* backed up requests, */		    request = daemonq;			    /* get the request */		    daemonq = daemonq->next;		    /* and detach it */		    Free(request);			    /* then free it */		}		wakeup(&vinumclose);			    /* and wake any waiting vinum(8)s */		return;	    case daemonrq_ping:				    /* tell the caller we're here */		if (daemon_options & daemon_verbose)		    log(LOG_INFO, "vinum: ping reply\n");		wakeup(&vinum_finddaemon);		    /* wake up the caller */		break;	    case daemonrq_closedrive:			    /* close a drive */		close_drive(request->info.drive);	    /* do it */		break;	    case daemonrq_init:				    /* initialize a plex */		/* XXX */	    case daemonrq_revive:			    /* revive a subdisk */		/* XXX */		/* FALLTHROUGH */	    default:		log(LOG_WARNING, "Invalid request\n");		break;	    }	    if (request->privateinuse)			    /* one of ours, */		request->privateinuse = 0;		    /* no longer in use */	    else		Free(request);				    /* return it */	}    }}
void
vinum_daemon(void)
vinum_daemon
void
void


{    struct daemonq *request;    curproc->p_flag |= P_INMEM | P_SYSTEM;		    /* we're a system process */    daemon_save_config();				    /* start by saving the configuration */    daemonpid = curproc->p_pid;				    /* mark our territory */    while (1) {	tsleep(&vinum_daemon, 0, "vinum", 0);	    /* wait for something to happen */	/*	 * It's conceivable that, as the result of an	 * I/O error, we'll be out of action long	 * enough that another daemon gets started.	 * That's OK, just give up gracefully.	 */	if (curproc->p_pid != daemonpid) {		    /* we've been ousted in our sleep */	    if (daemon_options & daemon_verbose)		log(LOG_INFO, "vinum: abdicating\n");	    return;	}	while (daemonq != NULL) {			    /* we have work to do, */	    crit_enter();	    request = daemonq;				    /* get the request */	    daemonq = daemonq->next;			    /* and detach it */	    if (daemonq == NULL)			    /* got to the end, */		dqend = NULL;				    /* no end any more */	    crit_exit();	    switch (request->type) {		/*		 * We had an I/O error on a request.  Go through the		 * request and try to salvage it		 */	    case daemonrq_ioerror:		if (daemon_options & daemon_verbose) {		    struct request *rq = request->info.rq;		    log(LOG_WARNING,			"vinum: recovering I/O request: %p\n%s dev %d.%d, offset 0x%x, length %ld\n",			rq,			rq->bp->b_flags & B_READ ? "Read" : "Write",			major(rq->bp->b_dev),			minor(rq->bp->b_dev),			rq->bp->b_blkno,			rq->bp->b_bcount);		}		recover_io(request->info.rq);		    /* the failed request */		break;		/*		 * Write the config to disk.  We could end up with		 * quite a few of these in a row.  Only honour the		 * last one		 */	    case daemonrq_saveconfig:		if ((daemonq == NULL)			    /* no more requests */		||(daemonq->type != daemonrq_saveconfig)) { /* or the next isn't the same */		    if (((daemon_options & daemon_noupdate) == 0) /* we're allowed to do it */		    &&((vinum_conf.flags & VF_READING_CONFIG) == 0)) { /* and we're not building the config now */			/*			   * We obviously don't want to save a			   * partial configuration.  Less obviously,			   * we don't need to do anything if we're			   * asked to write the config when we're			   * building it up, because we save it at			   * the end.			 */			if (daemon_options & daemon_verbose)			    log(LOG_INFO, "vinum: saving config\n");			daemon_save_config();		    /* save it */		    }		}		break;	    case daemonrq_return:			    /* been told to stop */		if (daemon_options & daemon_verbose)		    log(LOG_INFO, "vinum: stopping\n");		daemon_options |= daemon_stopped;	    /* note that we've stopped */		Free(request);		while (daemonq != NULL) {		    /* backed up requests, */		    request = daemonq;			    /* get the request */		    daemonq = daemonq->next;		    /* and detach it */		    Free(request);			    /* then free it */		}		wakeup(&vinumclose);			    /* and wake any waiting vinum(8)s */		return;	    case daemonrq_ping:				    /* tell the caller we're here */		if (daemon_options & daemon_verbose)		    log(LOG_INFO, "vinum: ping reply\n");		wakeup(&vinum_finddaemon);		    /* wake up the caller */		break;	    case daemonrq_closedrive:			    /* close a drive */		close_drive(request->info.drive);	    /* do it */		break;	    case daemonrq_init:				    /* initialize a plex */		/* XXX */	    case daemonrq_revive:			    /* revive a subdisk */		/* XXX */		/* FALLTHROUGH */	    default:		log(LOG_WARNING, "Invalid request\n");		break;	    }	    if (request->privateinuse)			    /* one of ours, */		request->privateinuse = 0;		    /* no longer in use */	    else		Free(request);				    /* return it */	}    }}
struct daemonq *request;
struct daemonq *request;
struct daemonq
daemonq
*request
*
request
curproc->p_flag |= P_INMEM | P_SYSTEM;
curproc->p_flag |= P_INMEM | P_SYSTEM
curproc->p_flag
curproc
curproc
p_flag
P_INMEM | P_SYSTEM
P_INMEM
P_INMEM
P_SYSTEM
P_SYSTEM
daemon_save_config();
daemon_save_config()
daemon_save_config
daemon_save_config
daemonpid = curproc->p_pid;
daemonpid = curproc->p_pid
daemonpid
daemonpid
curproc->p_pid
curproc
curproc
p_pid
while (1) {	tsleep(&vinum_daemon, 0, "vinum", 0);	    /* wait for something to happen */	/*	 * It's conceivable that, as the result of an	 * I/O error, we'll be out of action long	 * enough that another daemon gets started.	 * That's OK, just give up gracefully.	 */	if (curproc->p_pid != daemonpid) {		    /* we've been ousted in our sleep */	    if (daemon_options & daemon_verbose)		log(LOG_INFO, "vinum: abdicating\n");	    return;	}	while (daemonq != NULL) {			    /* we have work to do, */	    crit_enter();	    request = daemonq;				    /* get the request */	    daemonq = daemonq->next;			    /* and detach it */	    if (daemonq == NULL)			    /* got to the end, */		dqend = NULL;				    /* no end any more */	    crit_exit();	    switch (request->type) {		/*		 * We had an I/O error on a request.  Go through the		 * request and try to salvage it		 */	    case daemonrq_ioerror:		if (daemon_options & daemon_verbose) {		    struct request *rq = request->info.rq;		    log(LOG_WARNING,			"vinum: recovering I/O request: %p\n%s dev %d.%d, offset 0x%x, length %ld\n",			rq,			rq->bp->b_flags & B_READ ? "Read" : "Write",			major(rq->bp->b_dev),			minor(rq->bp->b_dev),			rq->bp->b_blkno,			rq->bp->b_bcount);		}		recover_io(request->info.rq);		    /* the failed request */		break;		/*		 * Write the config to disk.  We could end up with		 * quite a few of these in a row.  Only honour the		 * last one		 */	    case daemonrq_saveconfig:		if ((daemonq == NULL)			    /* no more requests */		||(daemonq->type != daemonrq_saveconfig)) { /* or the next isn't the same */		    if (((daemon_options & daemon_noupdate) == 0) /* we're allowed to do it */		    &&((vinum_conf.flags & VF_READING_CONFIG) == 0)) { /* and we're not building the config now */			/*			   * We obviously don't want to save a			   * partial configuration.  Less obviously,			   * we don't need to do anything if we're			   * asked to write the config when we're			   * building it up, because we save it at			   * the end.			 */			if (daemon_options & daemon_verbose)			    log(LOG_INFO, "vinum: saving config\n");			daemon_save_config();		    /* save it */		    }		}		break;	    case daemonrq_return:			    /* been told to stop */		if (daemon_options & daemon_verbose)		    log(LOG_INFO, "vinum: stopping\n");		daemon_options |= daemon_stopped;	    /* note that we've stopped */		Free(request);		while (daemonq != NULL) {		    /* backed up requests, */		    request = daemonq;			    /* get the request */		    daemonq = daemonq->next;		    /* and detach it */		    Free(request);			    /* then free it */		}		wakeup(&vinumclose);			    /* and wake any waiting vinum(8)s */		return;	    case daemonrq_ping:				    /* tell the caller we're here */		if (daemon_options & daemon_verbose)		    log(LOG_INFO, "vinum: ping reply\n");		wakeup(&vinum_finddaemon);		    /* wake up the caller */		break;	    case daemonrq_closedrive:			    /* close a drive */		close_drive(request->info.drive);	    /* do it */		break;	    case daemonrq_init:				    /* initialize a plex */		/* XXX */	    case daemonrq_revive:			    /* revive a subdisk */		/* XXX */		/* FALLTHROUGH */	    default:		log(LOG_WARNING, "Invalid request\n");		break;	    }	    if (request->privateinuse)			    /* one of ours, */		request->privateinuse = 0;		    /* no longer in use */	    else		Free(request);				    /* return it */	}    }
1
{	tsleep(&vinum_daemon, 0, "vinum", 0);	    /* wait for something to happen */	/*	 * It's conceivable that, as the result of an	 * I/O error, we'll be out of action long	 * enough that another daemon gets started.	 * That's OK, just give up gracefully.	 */	if (curproc->p_pid != daemonpid) {		    /* we've been ousted in our sleep */	    if (daemon_options & daemon_verbose)		log(LOG_INFO, "vinum: abdicating\n");	    return;	}	while (daemonq != NULL) {			    /* we have work to do, */	    crit_enter();	    request = daemonq;				    /* get the request */	    daemonq = daemonq->next;			    /* and detach it */	    if (daemonq == NULL)			    /* got to the end, */		dqend = NULL;				    /* no end any more */	    crit_exit();	    switch (request->type) {		/*		 * We had an I/O error on a request.  Go through the		 * request and try to salvage it		 */	    case daemonrq_ioerror:		if (daemon_options & daemon_verbose) {		    struct request *rq = request->info.rq;		    log(LOG_WARNING,			"vinum: recovering I/O request: %p\n%s dev %d.%d, offset 0x%x, length %ld\n",			rq,			rq->bp->b_flags & B_READ ? "Read" : "Write",			major(rq->bp->b_dev),			minor(rq->bp->b_dev),			rq->bp->b_blkno,			rq->bp->b_bcount);		}		recover_io(request->info.rq);		    /* the failed request */		break;		/*		 * Write the config to disk.  We could end up with		 * quite a few of these in a row.  Only honour the		 * last one		 */	    case daemonrq_saveconfig:		if ((daemonq == NULL)			    /* no more requests */		||(daemonq->type != daemonrq_saveconfig)) { /* or the next isn't the same */		    if (((daemon_options & daemon_noupdate) == 0) /* we're allowed to do it */		    &&((vinum_conf.flags & VF_READING_CONFIG) == 0)) { /* and we're not building the config now */			/*			   * We obviously don't want to save a			   * partial configuration.  Less obviously,			   * we don't need to do anything if we're			   * asked to write the config when we're			   * building it up, because we save it at			   * the end.			 */			if (daemon_options & daemon_verbose)			    log(LOG_INFO, "vinum: saving config\n");			daemon_save_config();		    /* save it */		    }		}		break;	    case daemonrq_return:			    /* been told to stop */		if (daemon_options & daemon_verbose)		    log(LOG_INFO, "vinum: stopping\n");		daemon_options |= daemon_stopped;	    /* note that we've stopped */		Free(request);		while (daemonq != NULL) {		    /* backed up requests, */		    request = daemonq;			    /* get the request */		    daemonq = daemonq->next;		    /* and detach it */		    Free(request);			    /* then free it */		}		wakeup(&vinumclose);			    /* and wake any waiting vinum(8)s */		return;	    case daemonrq_ping:				    /* tell the caller we're here */		if (daemon_options & daemon_verbose)		    log(LOG_INFO, "vinum: ping reply\n");		wakeup(&vinum_finddaemon);		    /* wake up the caller */		break;	    case daemonrq_closedrive:			    /* close a drive */		close_drive(request->info.drive);	    /* do it */		break;	    case daemonrq_init:				    /* initialize a plex */		/* XXX */	    case daemonrq_revive:			    /* revive a subdisk */		/* XXX */		/* FALLTHROUGH */	    default:		log(LOG_WARNING, "Invalid request\n");		break;	    }	    if (request->privateinuse)			    /* one of ours, */		request->privateinuse = 0;		    /* no longer in use */	    else		Free(request);				    /* return it */	}    }
tsleep(&vinum_daemon, 0, "vinum", 0);
tsleep(&vinum_daemon, 0, "vinum", 0)
tsleep
tsleep
&vinum_daemon
vinum_daemon
vinum_daemon
0
"vinum"
0
if (curproc->p_pid != daemonpid) {		    /* we've been ousted in our sleep */	    if (daemon_options & daemon_verbose)		log(LOG_INFO, "vinum: abdicating\n");	    return;	}
curproc->p_pid != daemonpid
curproc->p_pid
curproc
curproc
p_pid
daemonpid
daemonpid
{		    /* we've been ousted in our sleep */	    if (daemon_options & daemon_verbose)		log(LOG_INFO, "vinum: abdicating\n");	    return;	}
if (daemon_options & daemon_verbose)		log(LOG_INFO, "vinum: abdicating\n");
daemon_options & daemon_verbose
daemon_options
daemon_options
& daemon_verbose
&
daemon_verbose
log(LOG_INFO, "vinum: abdicating\n");
log(LOG_INFO, "vinum: abdicating\n")
log
log
LOG_INFO
LOG_INFO
"vinum: abdicating\n"
return;
while (daemonq != NULL) {			    /* we have work to do, */	    crit_enter();	    request = daemonq;				    /* get the request */	    daemonq = daemonq->next;			    /* and detach it */	    if (daemonq == NULL)			    /* got to the end, */		dqend = NULL;				    /* no end any more */	    crit_exit();	    switch (request->type) {		/*		 * We had an I/O error on a request.  Go through the		 * request and try to salvage it		 */	    case daemonrq_ioerror:		if (daemon_options & daemon_verbose) {		    struct request *rq = request->info.rq;		    log(LOG_WARNING,			"vinum: recovering I/O request: %p\n%s dev %d.%d, offset 0x%x, length %ld\n",			rq,			rq->bp->b_flags & B_READ ? "Read" : "Write",			major(rq->bp->b_dev),			minor(rq->bp->b_dev),			rq->bp->b_blkno,			rq->bp->b_bcount);		}		recover_io(request->info.rq);		    /* the failed request */		break;		/*		 * Write the config to disk.  We could end up with		 * quite a few of these in a row.  Only honour the		 * last one		 */	    case daemonrq_saveconfig:		if ((daemonq == NULL)			    /* no more requests */		||(daemonq->type != daemonrq_saveconfig)) { /* or the next isn't the same */		    if (((daemon_options & daemon_noupdate) == 0) /* we're allowed to do it */		    &&((vinum_conf.flags & VF_READING_CONFIG) == 0)) { /* and we're not building the config now */			/*			   * We obviously don't want to save a			   * partial configuration.  Less obviously,			   * we don't need to do anything if we're			   * asked to write the config when we're			   * building it up, because we save it at			   * the end.			 */			if (daemon_options & daemon_verbose)			    log(LOG_INFO, "vinum: saving config\n");			daemon_save_config();		    /* save it */		    }		}		break;	    case daemonrq_return:			    /* been told to stop */		if (daemon_options & daemon_verbose)		    log(LOG_INFO, "vinum: stopping\n");		daemon_options |= daemon_stopped;	    /* note that we've stopped */		Free(request);		while (daemonq != NULL) {		    /* backed up requests, */		    request = daemonq;			    /* get the request */		    daemonq = daemonq->next;		    /* and detach it */		    Free(request);			    /* then free it */		}		wakeup(&vinumclose);			    /* and wake any waiting vinum(8)s */		return;	    case daemonrq_ping:				    /* tell the caller we're here */		if (daemon_options & daemon_verbose)		    log(LOG_INFO, "vinum: ping reply\n");		wakeup(&vinum_finddaemon);		    /* wake up the caller */		break;	    case daemonrq_closedrive:			    /* close a drive */		close_drive(request->info.drive);	    /* do it */		break;	    case daemonrq_init:				    /* initialize a plex */		/* XXX */	    case daemonrq_revive:			    /* revive a subdisk */		/* XXX */		/* FALLTHROUGH */	    default:		log(LOG_WARNING, "Invalid request\n");		break;	    }	    if (request->privateinuse)			    /* one of ours, */		request->privateinuse = 0;		    /* no longer in use */	    else		Free(request);				    /* return it */	}
daemonq != NULL
daemonq
daemonq
NULL
NULL
{			    /* we have work to do, */	    crit_enter();	    request = daemonq;				    /* get the request */	    daemonq = daemonq->next;			    /* and detach it */	    if (daemonq == NULL)			    /* got to the end, */		dqend = NULL;				    /* no end any more */	    crit_exit();	    switch (request->type) {		/*		 * We had an I/O error on a request.  Go through the		 * request and try to salvage it		 */	    case daemonrq_ioerror:		if (daemon_options & daemon_verbose) {		    struct request *rq = request->info.rq;		    log(LOG_WARNING,			"vinum: recovering I/O request: %p\n%s dev %d.%d, offset 0x%x, length %ld\n",			rq,			rq->bp->b_flags & B_READ ? "Read" : "Write",			major(rq->bp->b_dev),			minor(rq->bp->b_dev),			rq->bp->b_blkno,			rq->bp->b_bcount);		}		recover_io(request->info.rq);		    /* the failed request */		break;		/*		 * Write the config to disk.  We could end up with		 * quite a few of these in a row.  Only honour the		 * last one		 */	    case daemonrq_saveconfig:		if ((daemonq == NULL)			    /* no more requests */		||(daemonq->type != daemonrq_saveconfig)) { /* or the next isn't the same */		    if (((daemon_options & daemon_noupdate) == 0) /* we're allowed to do it */		    &&((vinum_conf.flags & VF_READING_CONFIG) == 0)) { /* and we're not building the config now */			/*			   * We obviously don't want to save a			   * partial configuration.  Less obviously,			   * we don't need to do anything if we're			   * asked to write the config when we're			   * building it up, because we save it at			   * the end.			 */			if (daemon_options & daemon_verbose)			    log(LOG_INFO, "vinum: saving config\n");			daemon_save_config();		    /* save it */		    }		}		break;	    case daemonrq_return:			    /* been told to stop */		if (daemon_options & daemon_verbose)		    log(LOG_INFO, "vinum: stopping\n");		daemon_options |= daemon_stopped;	    /* note that we've stopped */		Free(request);		while (daemonq != NULL) {		    /* backed up requests, */		    request = daemonq;			    /* get the request */		    daemonq = daemonq->next;		    /* and detach it */		    Free(request);			    /* then free it */		}		wakeup(&vinumclose);			    /* and wake any waiting vinum(8)s */		return;	    case daemonrq_ping:				    /* tell the caller we're here */		if (daemon_options & daemon_verbose)		    log(LOG_INFO, "vinum: ping reply\n");		wakeup(&vinum_finddaemon);		    /* wake up the caller */		break;	    case daemonrq_closedrive:			    /* close a drive */		close_drive(request->info.drive);	    /* do it */		break;	    case daemonrq_init:				    /* initialize a plex */		/* XXX */	    case daemonrq_revive:			    /* revive a subdisk */		/* XXX */		/* FALLTHROUGH */	    default:		log(LOG_WARNING, "Invalid request\n");		break;	    }	    if (request->privateinuse)			    /* one of ours, */		request->privateinuse = 0;		    /* no longer in use */	    else		Free(request);				    /* return it */	}
crit_enter();
crit_enter()
crit_enter
crit_enter
request = daemonq;
request = daemonq
request
request
daemonq
daemonq
daemonq = daemonq->next;
daemonq = daemonq->next
daemonq
daemonq
daemonq->next
daemonq
daemonq
next
if (daemonq == NULL)			    /* got to the end, */		dqend = NULL;
daemonq == NULL
daemonq
daemonq
NULL
NULL
dqend = NULL;
dqend = NULL
dqend
dqend
NULL
NULL
crit_exit();
crit_exit()
crit_exit
crit_exit
switch (request->type) {		/*		 * We had an I/O error on a request.  Go through the		 * request and try to salvage it		 */	    case daemonrq_ioerror:		if (daemon_options & daemon_verbose) {		    struct request *rq = request->info.rq;		    log(LOG_WARNING,			"vinum: recovering I/O request: %p\n%s dev %d.%d, offset 0x%x, length %ld\n",			rq,			rq->bp->b_flags & B_READ ? "Read" : "Write",			major(rq->bp->b_dev),			minor(rq->bp->b_dev),			rq->bp->b_blkno,			rq->bp->b_bcount);		}		recover_io(request->info.rq);		    /* the failed request */		break;		/*		 * Write the config to disk.  We could end up with		 * quite a few of these in a row.  Only honour the		 * last one		 */	    case daemonrq_saveconfig:		if ((daemonq == NULL)			    /* no more requests */		||(daemonq->type != daemonrq_saveconfig)) { /* or the next isn't the same */		    if (((daemon_options & daemon_noupdate) == 0) /* we're allowed to do it */		    &&((vinum_conf.flags & VF_READING_CONFIG) == 0)) { /* and we're not building the config now */			/*			   * We obviously don't want to save a			   * partial configuration.  Less obviously,			   * we don't need to do anything if we're			   * asked to write the config when we're			   * building it up, because we save it at			   * the end.			 */			if (daemon_options & daemon_verbose)			    log(LOG_INFO, "vinum: saving config\n");			daemon_save_config();		    /* save it */		    }		}		break;	    case daemonrq_return:			    /* been told to stop */		if (daemon_options & daemon_verbose)		    log(LOG_INFO, "vinum: stopping\n");		daemon_options |= daemon_stopped;	    /* note that we've stopped */		Free(request);		while (daemonq != NULL) {		    /* backed up requests, */		    request = daemonq;			    /* get the request */		    daemonq = daemonq->next;		    /* and detach it */		    Free(request);			    /* then free it */		}		wakeup(&vinumclose);			    /* and wake any waiting vinum(8)s */		return;	    case daemonrq_ping:				    /* tell the caller we're here */		if (daemon_options & daemon_verbose)		    log(LOG_INFO, "vinum: ping reply\n");		wakeup(&vinum_finddaemon);		    /* wake up the caller */		break;	    case daemonrq_closedrive:			    /* close a drive */		close_drive(request->info.drive);	    /* do it */		break;	    case daemonrq_init:				    /* initialize a plex */		/* XXX */	    case daemonrq_revive:			    /* revive a subdisk */		/* XXX */		/* FALLTHROUGH */	    default:		log(LOG_WARNING, "Invalid request\n");		break;	    }
request->type
request
request
type
{		/*		 * We had an I/O error on a request.  Go through the		 * request and try to salvage it		 */	    case daemonrq_ioerror:		if (daemon_options & daemon_verbose) {		    struct request *rq = request->info.rq;		    log(LOG_WARNING,			"vinum: recovering I/O request: %p\n%s dev %d.%d, offset 0x%x, length %ld\n",			rq,			rq->bp->b_flags & B_READ ? "Read" : "Write",			major(rq->bp->b_dev),			minor(rq->bp->b_dev),			rq->bp->b_blkno,			rq->bp->b_bcount);		}		recover_io(request->info.rq);		    /* the failed request */		break;		/*		 * Write the config to disk.  We could end up with		 * quite a few of these in a row.  Only honour the		 * last one		 */	    case daemonrq_saveconfig:		if ((daemonq == NULL)			    /* no more requests */		||(daemonq->type != daemonrq_saveconfig)) { /* or the next isn't the same */		    if (((daemon_options & daemon_noupdate) == 0) /* we're allowed to do it */		    &&((vinum_conf.flags & VF_READING_CONFIG) == 0)) { /* and we're not building the config now */			/*			   * We obviously don't want to save a			   * partial configuration.  Less obviously,			   * we don't need to do anything if we're			   * asked to write the config when we're			   * building it up, because we save it at			   * the end.			 */			if (daemon_options & daemon_verbose)			    log(LOG_INFO, "vinum: saving config\n");			daemon_save_config();		    /* save it */		    }		}		break;	    case daemonrq_return:			    /* been told to stop */		if (daemon_options & daemon_verbose)		    log(LOG_INFO, "vinum: stopping\n");		daemon_options |= daemon_stopped;	    /* note that we've stopped */		Free(request);		while (daemonq != NULL) {		    /* backed up requests, */		    request = daemonq;			    /* get the request */		    daemonq = daemonq->next;		    /* and detach it */		    Free(request);			    /* then free it */		}		wakeup(&vinumclose);			    /* and wake any waiting vinum(8)s */		return;	    case daemonrq_ping:				    /* tell the caller we're here */		if (daemon_options & daemon_verbose)		    log(LOG_INFO, "vinum: ping reply\n");		wakeup(&vinum_finddaemon);		    /* wake up the caller */		break;	    case daemonrq_closedrive:			    /* close a drive */		close_drive(request->info.drive);	    /* do it */		break;	    case daemonrq_init:				    /* initialize a plex */		/* XXX */	    case daemonrq_revive:			    /* revive a subdisk */		/* XXX */		/* FALLTHROUGH */	    default:		log(LOG_WARNING, "Invalid request\n");		break;	    }
case daemonrq_ioerror:
daemonrq_ioerror
daemonrq_ioerror
if (daemon_options & daemon_verbose) {		    struct request *rq = request->info.rq;		    log(LOG_WARNING,			"vinum: recovering I/O request: %p\n%s dev %d.%d, offset 0x%x, length %ld\n",			rq,			rq->bp->b_flags & B_READ ? "Read" : "Write",			major(rq->bp->b_dev),			minor(rq->bp->b_dev),			rq->bp->b_blkno,			rq->bp->b_bcount);		}
daemon_options & daemon_verbose
daemon_options
daemon_options
& daemon_verbose
&
daemon_verbose
{		    struct request *rq = request->info.rq;		    log(LOG_WARNING,			"vinum: recovering I/O request: %p\n%s dev %d.%d, offset 0x%x, length %ld\n",			rq,			rq->bp->b_flags & B_READ ? "Read" : "Write",			major(rq->bp->b_dev),			minor(rq->bp->b_dev),			rq->bp->b_blkno,			rq->bp->b_bcount);		}
struct request *rq = request->info.rq;
struct request *rq = request->info.rq;
struct request
request
*rq = request->info.rq
*
rq
= request->info.rq
request->info.rq
request->info
request
request
info
rq
log(LOG_WARNING,			"vinum: recovering I/O request: %p\n%s dev %d.%d, offset 0x%x, length %ld\n",			rq,			rq->bp->b_flags & B_READ ? "Read" : "Write",			major(rq->bp->b_dev),			minor(rq->bp->b_dev),			rq->bp->b_blkno,			rq->bp->b_bcount);
log(LOG_WARNING,			"vinum: recovering I/O request: %p\n%s dev %d.%d, offset 0x%x, length %ld\n",			rq,			rq->bp->b_flags & B_READ ? "Read" : "Write",			major(rq->bp->b_dev),			minor(rq->bp->b_dev),			rq->bp->b_blkno,			rq->bp->b_bcount)
log
log
LOG_WARNING
LOG_WARNING
"vinum: recovering I/O request: %p\n%s dev %d.%d, offset 0x%x, length %ld\n"
rq
rq
rq->bp->b_flags & B_READ ? "Read" : "Write"
rq->bp->b_flags & B_READ
rq->bp->b_flags
rq->bp
rq
rq
bp
b_flags
B_READ
B_READ
"Read"
"Write"
major(rq->bp->b_dev)
major
major
rq->bp->b_dev
rq->bp
rq
rq
bp
b_dev
minor(rq->bp->b_dev)
minor
minor
rq->bp->b_dev
rq->bp
rq
rq
bp
b_dev
rq->bp->b_blkno
rq->bp
rq
rq
bp
b_blkno
rq->bp->b_bcount
rq->bp
rq
rq
bp
b_bcount
recover_io(request->info.rq);
recover_io(request->info.rq)
recover_io
recover_io
request->info.rq
request->info
request
request
info
rq
break;
case daemonrq_saveconfig:
daemonrq_saveconfig
daemonrq_saveconfig
if ((daemonq == NULL)			    /* no more requests */		||(daemonq->type != daemonrq_saveconfig)) { /* or the next isn't the same */		    if (((daemon_options & daemon_noupdate) == 0) /* we're allowed to do it */		    &&((vinum_conf.flags & VF_READING_CONFIG) == 0)) { /* and we're not building the config now */			/*			   * We obviously don't want to save a			   * partial configuration.  Less obviously,			   * we don't need to do anything if we're			   * asked to write the config when we're			   * building it up, because we save it at			   * the end.			 */			if (daemon_options & daemon_verbose)			    log(LOG_INFO, "vinum: saving config\n");			daemon_save_config();		    /* save it */		    }		}
(daemonq == NULL)			    /* no more requests */		||(daemonq->type != daemonrq_saveconfig)
(daemonq == NULL)
daemonq == NULL
daemonq
daemonq
NULL
NULL
(daemonq->type != daemonrq_saveconfig)
daemonq->type != daemonrq_saveconfig
daemonq->type
daemonq
daemonq
type
daemonrq_saveconfig
daemonrq_saveconfig
{ /* or the next isn't the same */		    if (((daemon_options & daemon_noupdate) == 0) /* we're allowed to do it */		    &&((vinum_conf.flags & VF_READING_CONFIG) == 0)) { /* and we're not building the config now */			/*			   * We obviously don't want to save a			   * partial configuration.  Less obviously,			   * we don't need to do anything if we're			   * asked to write the config when we're			   * building it up, because we save it at			   * the end.			 */			if (daemon_options & daemon_verbose)			    log(LOG_INFO, "vinum: saving config\n");			daemon_save_config();		    /* save it */		    }		}
if (((daemon_options & daemon_noupdate) == 0) /* we're allowed to do it */		    &&((vinum_conf.flags & VF_READING_CONFIG) == 0)) { /* and we're not building the config now */			/*			   * We obviously don't want to save a			   * partial configuration.  Less obviously,			   * we don't need to do anything if we're			   * asked to write the config when we're			   * building it up, because we save it at			   * the end.			 */			if (daemon_options & daemon_verbose)			    log(LOG_INFO, "vinum: saving config\n");			daemon_save_config();		    /* save it */		    }
((daemon_options & daemon_noupdate) == 0) /* we're allowed to do it */		    &&((vinum_conf.flags & VF_READING_CONFIG) == 0)
((daemon_options & daemon_noupdate) == 0)
(daemon_options & daemon_noupdate) == 0
(daemon_options & daemon_noupdate)
daemon_options & daemon_noupdate
daemon_options
daemon_options
daemon_noupdate
daemon_noupdate
0
((vinum_conf.flags & VF_READING_CONFIG) == 0)
(vinum_conf.flags & VF_READING_CONFIG) == 0
(vinum_conf.flags & VF_READING_CONFIG)
vinum_conf.flags & VF_READING_CONFIG
vinum_conf.flags
vinum_conf
vinum_conf
flags
VF_READING_CONFIG
VF_READING_CONFIG
0
{ /* and we're not building the config now */			/*			   * We obviously don't want to save a			   * partial configuration.  Less obviously,			   * we don't need to do anything if we're			   * asked to write the config when we're			   * building it up, because we save it at			   * the end.			 */			if (daemon_options & daemon_verbose)			    log(LOG_INFO, "vinum: saving config\n");			daemon_save_config();		    /* save it */		    }
if (daemon_options & daemon_verbose)			    log(LOG_INFO, "vinum: saving config\n");
daemon_options & daemon_verbose
daemon_options
daemon_options
& daemon_verbose
&
daemon_verbose
log(LOG_INFO, "vinum: saving config\n");
log(LOG_INFO, "vinum: saving config\n")
log
log
LOG_INFO
LOG_INFO
"vinum: saving config\n"
daemon_save_config();
daemon_save_config()
daemon_save_config
daemon_save_config
break;
case daemonrq_return:
daemonrq_return
daemonrq_return
if (daemon_options & daemon_verbose)		    log(LOG_INFO, "vinum: stopping\n");
daemon_options & daemon_verbose
daemon_options
daemon_options
& daemon_verbose
&
daemon_verbose
log(LOG_INFO, "vinum: stopping\n");
log(LOG_INFO, "vinum: stopping\n")
log
log
LOG_INFO
LOG_INFO
"vinum: stopping\n"
daemon_options |= daemon_stopped;
daemon_options |= daemon_stopped
daemon_options
daemon_options
daemon_stopped
daemon_stopped
Free(request);
Free(request)
Free
Free
request
request
while (daemonq != NULL) {		    /* backed up requests, */		    request = daemonq;			    /* get the request */		    daemonq = daemonq->next;		    /* and detach it */		    Free(request);			    /* then free it */		}
daemonq != NULL
daemonq
daemonq
NULL
NULL
{		    /* backed up requests, */		    request = daemonq;			    /* get the request */		    daemonq = daemonq->next;		    /* and detach it */		    Free(request);			    /* then free it */		}
request = daemonq;
request = daemonq
request
request
daemonq
daemonq
daemonq = daemonq->next;
daemonq = daemonq->next
daemonq
daemonq
daemonq->next
daemonq
daemonq
next
Free(request);
Free(request)
Free
Free
request
request
wakeup(&vinumclose);
wakeup(&vinumclose);
wakeup
wakeup
(&vinumclose)
&vinumclose
&
vinumclose
return;
case daemonrq_ping:
daemonrq_ping
daemonrq_ping
if (daemon_options & daemon_verbose)		    log(LOG_INFO, "vinum: ping reply\n");
daemon_options & daemon_verbose
daemon_options
daemon_options
& daemon_verbose
&
daemon_verbose
log(LOG_INFO, "vinum: ping reply\n");
log(LOG_INFO, "vinum: ping reply\n")
log
log
LOG_INFO
LOG_INFO
"vinum: ping reply\n"
wakeup(&vinum_finddaemon);
wakeup(&vinum_finddaemon);
wakeup
wakeup
(&vinum_finddaemon)
&vinum_finddaemon
&
vinum_finddaemon
break;
case daemonrq_closedrive:
daemonrq_closedrive
daemonrq_closedrive
close_drive(request->info.drive);
close_drive(request->info.drive)
close_drive
close_drive
request->info.drive
request->info
request
request
info
drive
break;
case daemonrq_init:
daemonrq_init
daemonrq_init
case daemonrq_revive:
daemonrq_revive
daemonrq_revive
default:
log(LOG_WARNING, "Invalid request\n");
log(LOG_WARNING, "Invalid request\n")
log
log
LOG_WARNING
LOG_WARNING
"Invalid request\n"
break;
if (request->privateinuse)			    /* one of ours, */		request->privateinuse = 0;		    /* no longer in use */	    else		Free(request);
request->privateinuse
request
request
privateinuse
request->privateinuse = 0;
request->privateinuse = 0
request->privateinuse
request
request
privateinuse
0
Free(request);
Free(request)
Free
Free
request
request
-----joern-----
(229,67,0)
(226,5,0)
(89,202,0)
(116,130,0)
(14,79,0)
(126,101,0)
(168,222,0)
(96,157,0)
(89,4,0)
(37,91,0)
(142,56,0)
(202,89,0)
(178,224,0)
(193,119,0)
(170,216,0)
(213,88,0)
(109,152,0)
(92,224,0)
(87,143,0)
(211,157,0)
(10,151,0)
(31,75,0)
(18,212,0)
(216,124,0)
(123,1,0)
(22,67,0)
(80,226,0)
(171,25,0)
(118,142,0)
(36,89,0)
(102,88,0)
(95,48,0)
(143,69,0)
(9,142,0)
(179,89,0)
(158,32,0)
(35,53,0)
(226,76,0)
(176,65,0)
(36,171,0)
(201,223,0)
(196,113,0)
(118,37,0)
(189,88,0)
(155,139,0)
(163,211,0)
(203,88,0)
(225,63,0)
(51,165,0)
(62,198,0)
(134,75,0)
(149,157,0)
(145,173,0)
(119,162,0)
(16,56,0)
(61,88,0)
(27,88,0)
(104,217,0)
(161,227,0)
(115,175,0)
(45,32,0)
(197,129,0)
(74,36,0)
(140,138,0)
(83,76,0)
(136,207,0)
(173,145,0)
(175,89,0)
(188,55,0)
(108,37,0)
(228,88,0)
(127,44,0)
(160,36,0)
(112,167,0)
(91,89,0)
(143,87,0)
(190,214,0)
(200,34,0)
(23,88,0)
(82,227,0)
(85,67,0)
(113,181,0)
(159,70,0)
(184,142,0)
(162,181,0)
(142,89,0)
(129,67,0)
(27,157,0)
(72,1,0)
(30,216,0)
(107,76,0)
(181,113,0)
(215,66,0)
(45,88,0)
(60,71,0)
(75,134,0)
(165,173,0)
(133,142,0)
(28,211,0)
(70,167,0)
(135,34,0)
(14,132,0)
(38,88,0)
(169,4,0)
(73,152,0)
(227,129,0)
(69,143,0)
(81,148,0)
(151,127,0)
(78,184,0)
(39,202,0)
(103,217,0)
(106,189,0)
(87,138,0)
(0,96,0)
(65,157,0)
(77,50,0)
(117,149,0)
(183,48,0)
(29,103,0)
(21,105,0)
(212,198,0)
(2,89,0)
(142,118,0)
(19,151,0)
(114,150,0)
(192,226,0)
(202,149,0)
(226,77,0)
(164,67,0)
(42,2,0)
(50,77,0)
(56,142,0)
(64,152,0)
(131,79,0)
(98,66,0)
(127,151,0)
(124,55,0)
(63,121,0)
(226,48,0)
(52,175,0)
(94,53,0)
(93,209,0)
(198,56,0)
(100,146,0)
(206,50,0)
(154,88,0)
(171,36,0)
(79,132,0)
(167,70,0)
(175,212,0)
(218,152,0)
(44,127,0)
(182,207,0)
(142,4,0)
(226,129,0)
(5,157,0)
(150,89,0)
(120,27,0)
(185,156,0)
(128,209,0)
(70,132,0)
(47,96,0)
(221,77,0)
(2,139,0)
(121,88,0)
(172,69,0)
(142,139,0)
(124,216,0)
(186,148,0)
(44,88,0)
(26,88,0)
(144,88,0)
(48,124,0)
(226,88,0)
(220,88,0)
(187,87,0)
(157,67,0)
(25,142,0)
(90,14,0)
(121,63,0)
(150,184,0)
(46,162,0)
(110,165,0)
(69,134,0)
(32,45,0)
(99,55,0)
(208,105,0)
(43,119,0)
(198,212,0)
(20,157,0)
(56,198,0)
(137,134,0)
(84,88,0)
(97,91,0)
(145,88,0)
(13,88,0)
(142,184,0)
(49,71,0)
(149,202,0)
(199,2,0)
(138,87,0)
(40,5,0)
(59,103,0)
(191,73,0)
(151,157,0)
(12,195,0)
(122,75,0)
(8,138,0)
(24,214,0)
(212,175,0)
(106,7,0)
(139,2,0)
(5,195,0)
(77,55,0)
(66,88,0)
(205,113,0)
(147,91,0)
(125,146,0)
(210,79,0)
(152,73,0)
(219,5,0)
(129,227,0)
(177,127,0)
(174,101,0)
(57,56,0)
(37,118,0)
(141,142,0)
(54,173,0)
(11,149,0)
(180,88,0)
(41,88,0)
(86,50,0)
(17,157,0)
(181,162,0)
(152,148,0)
(134,69,0)
(33,88,0)
(25,171,0)
(6,171,0)
(68,88,0)
(173,165,0)
(204,167,0)
(142,25,0)
(153,67,0)
(58,150,0)
(111,130,0)
(165,157,0)
(217,103,0)
(194,55,0)
(15,88,0)
(166,223,0)
(162,119,0)
(139,142,0)
(7,222,0)
(184,150,0)
(91,37,0)
(163,102,1)
(117,11,1)
(178,92,1)
(122,31,1)
(226,129,1)
(170,48,1)
(198,212,1)
(127,177,1)
(126,195,1)
(216,30,1)
(139,155,1)
(101,174,1)
(110,51,1)
(74,160,1)
(172,134,1)
(163,220,1)
(92,207,1)
(152,218,1)
(157,17,1)
(16,198,1)
(37,108,1)
(130,111,1)
(166,143,1)
(192,53,1)
(70,167,1)
(65,157,1)
(53,94,1)
(17,20,1)
(69,134,1)
(221,188,1)
(226,76,1)
(142,139,1)
(12,5,1)
(138,8,1)
(119,193,1)
(25,171,1)
(80,192,1)
(87,187,1)
(208,21,1)
(10,130,1)
(24,190,1)
(158,224,1)
(139,2,1)
(151,157,1)
(155,2,1)
(27,157,1)
(5,157,1)
(89,202,1)
(183,95,1)
(36,89,1)
(106,3,1)
(150,89,1)
(26,181,1)
(77,50,1)
(76,107,1)
(204,112,1)
(44,127,1)
(218,64,1)
(206,86,1)
(104,103,1)
(163,213,1)
(78,150,1)
(192,105,1)
(226,48,1)
(49,60,1)
(133,89,1)
(149,157,1)
(120,226,1)
(57,198,1)
(224,178,1)
(118,37,1)
(195,12,1)
(142,25,1)
(47,0,1)
(109,73,1)
(52,141,1)
(215,98,1)
(145,173,1)
(151,19,1)
(98,96,1)
(10,142,1)
(107,83,1)
(2,89,1)
(134,137,1)
(134,75,1)
(27,120,1)
(51,96,1)
(94,35,1)
(149,117,1)
(227,161,1)
(171,6,1)
(63,225,1)
(60,223,1)
(126,217,1)
(87,138,1)
(199,42,1)
(150,114,1)
(213,66,1)
(26,143,1)
(158,207,1)
(106,7,1)
(59,152,1)
(143,69,1)
(171,36,1)
(34,135,1)
(220,44,1)
(163,180,1)
(56,57,1)
(31,87,1)
(184,150,1)
(226,80,1)
(181,113,1)
(198,62,1)
(91,97,1)
(79,131,1)
(153,214,1)
(160,56,1)
(211,157,1)
(200,27,1)
(177,151,1)
(126,65,1)
(164,101,1)
(127,151,1)
(75,122,1)
(50,206,1)
(162,46,1)
(11,179,1)
(184,78,1)
(69,172,1)
(2,199,1)
(42,184,1)
(18,175,1)
(56,16,1)
(173,54,1)
(153,76,1)
(30,170,1)
(193,43,1)
(226,77,1)
(90,70,1)
(14,90,1)
(32,158,1)
(189,121,1)
(121,63,1)
(190,129,1)
(5,219,1)
(191,3,1)
(54,165,1)
(182,96,1)
(167,204,1)
(65,176,1)
(9,133,1)
(223,201,1)
(8,140,1)
(142,118,1)
(173,165,1)
(217,103,1)
(20,164,1)
(175,115,1)
(37,91,1)
(141,9,1)
(162,119,1)
(7,1,1)
(66,215,1)
(100,223,1)
(112,159,1)
(102,145,1)
(45,32,1)
(181,162,1)
(71,49,1)
(210,34,1)
(114,58,1)
(7,209,1)
(3,101,1)
(83,214,1)
(161,82,1)
(113,205,1)
(56,198,1)
(136,182,1)
(62,212,1)
(36,74,1)
(152,73,1)
(212,175,1)
(219,40,1)
(26,100,1)
(214,24,1)
(140,181,1)
(48,183,1)
(187,138,1)
(103,29,1)
(64,109,1)
(225,34,1)
(147,25,1)
(137,75,1)
(142,56,1)
(135,200,1)
(1,123,1)
(73,191,1)
(72,209,1)
(93,128,1)
(202,39,1)
(197,157,1)
(96,157,1)
(28,163,1)
(202,149,1)
(207,136,1)
(105,208,1)
(21,96,1)
(142,184,1)
(174,126,1)
(58,118,1)
(82,197,1)
(115,52,1)
(196,96,1)
(209,93,1)
(116,96,1)
(217,104,1)
(108,91,1)
(201,166,1)
(35,105,1)
(100,71,1)
(29,59,1)
(40,211,1)
(176,211,1)
(188,124,1)
(131,210,1)
(179,130,1)
(111,116,1)
(165,157,1)
(142,89,1)
(46,119,1)
(86,221,1)
(200,14,1)
(211,28,1)
(226,5,1)
(124,216,1)
(175,89,1)
(97,147,1)
(96,47,1)
(129,227,1)
(14,79,1)
(0,153,1)
(163,26,1)
(205,196,1)
(123,72,1)
(43,113,1)
(39,149,1)
(19,10,1)
(91,89,1)
(106,189,1)
(212,18,1)
(6,36,1)
(180,45,1)
(165,110,1)
(128,217,1)
(3,77,1)
(143,87,1)
(159,79,1)
(12,211,2)
(65,211,2)
(36,130,2)
(142,89,2)
(102,96,2)
(142,25,2)
(45,32,2)
(143,69,2)
(27,96,2)
(101,96,2)
(123,209,2)
(141,130,2)
(211,157,2)
(7,217,2)
(105,96,2)
(217,103,2)
(91,130,2)
(119,113,2)
(184,130,2)
(150,89,2)
(46,113,2)
(162,119,2)
(177,96,2)
(43,113,2)
(35,105,2)
(21,96,2)
(202,130,2)
(74,130,2)
(56,198,2)
(130,96,2)
(226,5,2)
(137,87,2)
(70,167,2)
(121,96,2)
(122,87,2)
(97,130,2)
(45,96,2)
(101,217,2)
(178,207,2)
(73,3,2)
(113,96,2)
(120,96,2)
(135,34,2)
(127,151,2)
(139,130,2)
(145,173,2)
(2,89,2)
(140,181,2)
(117,130,2)
(28,96,2)
(10,96,2)
(227,101,2)
(165,157,2)
(63,96,2)
(155,130,2)
(226,96,2)
(142,184,2)
(108,130,2)
(197,101,2)
(127,96,2)
(96,101,2)
(142,130,2)
(129,101,2)
(142,56,2)
(8,181,2)
(149,130,2)
(175,130,2)
(200,96,2)
(110,96,2)
(215,96,2)
(25,171,2)
(5,157,2)
(181,162,2)
(171,130,2)
(6,130,2)
(175,89,2)
(172,87,2)
(96,157,2)
(37,91,2)
(157,101,2)
(17,101,2)
(31,87,2)
(147,130,2)
(142,118,2)
(126,217,2)
(224,207,2)
(80,96,2)
(77,50,2)
(208,96,2)
(26,96,2)
(18,130,2)
(173,165,2)
(217,3,2)
(69,134,2)
(179,130,2)
(112,34,2)
(225,96,2)
(32,96,2)
(195,211,2)
(107,214,2)
(60,223,2)
(100,143,2)
(223,143,2)
(14,34,2)
(82,101,2)
(54,96,2)
(210,34,2)
(72,209,2)
(14,79,2)
(34,34,2)
(226,76,2)
(103,3,2)
(152,3,2)
(205,96,2)
(114,130,2)
(5,211,2)
(149,157,2)
(121,63,2)
(47,101,2)
(226,77,2)
(134,75,2)
(52,130,2)
(69,87,2)
(79,34,2)
(44,96,2)
(0,101,2)
(211,96,2)
(115,130,2)
(98,96,2)
(150,130,2)
(214,101,2)
(37,130,2)
(166,143,2)
(34,96,2)
(76,214,2)
(171,36,2)
(106,189,2)
(212,130,2)
(174,96,2)
(1,209,2)
(151,96,2)
(198,130,2)
(49,223,2)
(58,130,2)
(189,96,2)
(75,87,2)
(92,207,2)
(51,96,2)
(167,34,2)
(161,101,2)
(66,96,2)
(219,211,2)
(56,130,2)
(153,101,2)
(187,181,2)
(91,89,2)
(226,48,2)
(27,157,2)
(9,130,2)
(190,101,2)
(212,175,2)
(138,181,2)
(59,3,2)
(11,130,2)
(134,87,2)
(151,157,2)
(44,127,2)
(191,3,2)
(152,73,2)
(181,113,2)
(42,130,2)
(143,87,2)
(213,96,2)
(159,34,2)
(209,217,2)
(36,89,2)
(192,96,2)
(70,34,2)
(204,34,2)
(129,227,2)
(145,96,2)
(133,130,2)
(173,96,2)
(116,96,2)
(87,181,2)
(193,113,2)
(89,202,2)
(142,139,2)
(53,105,2)
(160,130,2)
(207,96,2)
(165,96,2)
(118,37,2)
(71,223,2)
(90,34,2)
(57,198,2)
(143,181,2)
(19,96,2)
(176,211,2)
(39,130,2)
(202,149,2)
(78,130,2)
(87,138,2)
(93,217,2)
(89,130,2)
(218,3,2)
(83,214,2)
(64,3,2)
(181,96,2)
(182,96,2)
(126,96,2)
(196,96,2)
(174,217,2)
(226,129,2)
(131,34,2)
(180,96,2)
(104,3,2)
(25,130,2)
(139,2,2)
(62,130,2)
(40,211,2)
(184,150,2)
(135,96,2)
(128,217,2)
(111,96,2)
(118,130,2)
(124,216,2)
(200,34,2)
(198,212,2)
(24,101,2)
(20,101,2)
(3,101,2)
(94,105,2)
(29,3,2)
(109,3,2)
(16,198,2)
(201,143,2)
(162,113,2)
(158,96,2)
(164,101,2)
(220,96,2)
(199,130,2)
(106,7,2)
(65,157,2)
(163,96,2)
(136,96,2)
(2,130,2)
-----------------------------------
(0,request)
(1,log(LOG_INFO, "vinum: abdicating\\n")
(2,rq->bp)
(3,1)
(4,)
(5,request->privateinuse)
(6,b_dev)
(7,return;)
(8,daemon_noupdate)
(9,"vinum: recovering I/O request: %p\\n%s dev %d.%d, offset 0x%x, length %ld\\n")
(10,request)
(11,request)
(12,0)
(13,if ((daemonq == NULL)
(14,Free(request)
(15,if (daemon_options & daemon_verbose)
(16,"Read")
(17,daemonq)
(18,b_flags)
(19,info)
(20,request)
(21,daemon_options)
(22,switch (request->type)
(23,default:)
(24,NULL)
(25,major(rq->bp->b_dev)
(26,break;)
(27,Free(request)
(28,privateinuse)
(29,p_pid)
(30,P_SYSTEM)
(31,vinum_conf)
(32,&vinum_finddaemon)
(33,case daemonrq_ping:)
(34,daemonq != NULL)
(35,LOG_INFO)
(36,rq->bp)
(37,rq->bp->b_dev)
(38,case daemonrq_revive:)
(39,rq)
(40,request)
(41,while (daemonq != NULL)
(42,rq)
(43,daemonq)
(44,recover_io(request->info.rq)
(45,wakeup(&vinum_finddaemon)
(46,daemonrq_saveconfig)
(47,type)
(48,curproc->p_flag)
(49,"vinum: saving config\\n")
(50,curproc->p_pid)
(51,request)
(52,rq)
(53,log(LOG_INFO, "vinum: stopping\\n")
(54,drive)
(55,)
(56,rq->bp->b_flags & B_READ ? "Read" : "Write")
(57,"Write")
(58,rq)
(59,curproc)
(60,LOG_INFO)
(61,case daemonrq_ioerror:)
(62,B_READ)
(63,&vinumclose)
(64,"vinum")
(65,Free(request)
(66,log(LOG_WARNING, "Invalid request\\n")
(67,)
(68,case daemonrq_return:)
(69,(vinum_conf.flags & VF_READING_CONFIG)
(70,daemonq = daemonq->next)
(71,log(LOG_INFO, "vinum: saving config\\n")
(72,LOG_INFO)
(73,&vinum_daemon)
(74,bp)
(75,vinum_conf.flags)
(76,dqend = NULL)
(77,daemonpid = curproc->p_pid)
(78,b_blkno)
(79,request = daemonq)
(80,daemon_stopped)
(81,while (daemonq != NULL)
(82,daemonq)
(83,dqend)
(84,case daemonrq_closedrive:)
(85,if (daemonq == NULL)
(86,curproc)
(87,(daemon_options & daemon_noupdate)
(88,)
(89,*rq = request->info.rq)
(90,request)
(91,rq->bp)
(92,LOG_INFO)
(93,daemon_verbose)
(94,"vinum: stopping\\n")
(95,curproc)
(96,request->type)
(97,bp)
(98,LOG_WARNING)
(99,request)
(100,daemon_save_config()
(101,daemonq != NULL)
(102,break;)
(103,curproc->p_pid)
(104,daemonpid)
(105,daemon_options & daemon_verbose)
(106,RET)
(107,NULL)
(108,b_dev)
(109,0)
(110,info)
(111,daemon_verbose)
(112,daemonq)
(113,daemonq == NULL)
(114,bp)
(115,bp)
(116,daemon_options)
(117,info)
(118,minor(rq->bp->b_dev)
(119,daemonq->type)
(120,request)
(121,wakeup(&vinumclose)
(122,flags)
(123,"vinum: abdicating\\n")
(124,curproc->p_flag |= P_INMEM | P_SYSTEM)
(125,if (daemon_options & daemon_verbose)
(126,daemonq)
(127,request->info.rq)
(128,daemon_options)
(129,daemonq = daemonq->next)
(130,daemon_options & daemon_verbose)
(131,daemonq)
(132,)
(133,LOG_WARNING)
(134,vinum_conf.flags & VF_READING_CONFIG)
(135,NULL)
(136,daemon_verbose)
(137,VF_READING_CONFIG)
(138,daemon_options & daemon_noupdate)
(139,rq->bp->b_bcount)
(140,daemon_options)
(141,rq)
(142,log(LOG_WARNING,\n\\n\\t\\t\\t"vinum: recovering I/O request: %p\\n%s dev %d.%d, offset 0x%x, length %ld\\n",\n\\n\\t\\t\\trq,\n\\n\\t\\t\\trq->bp->b_flags & B_READ ? "Read" : "Write",\n\\n\\t\\t\\tmajor(rq->bp->b_dev)
(143,((daemon_options & daemon_noupdate)
(144,case daemonrq_init:)
(145,close_drive(request->info.drive)
(146,)
(147,rq)
(148,)
(149,request->info)
(150,rq->bp)
(151,request->info)
(152,tsleep(&vinum_daemon, 0, "vinum", 0)
(153,crit_exit()
(154,if (daemon_options & daemon_verbose)
(155,b_bcount)
(156,)
(157,request = daemonq)
(158,vinum_finddaemon)
(159,daemonq)
(160,rq)
(161,next)
(162,daemonq->type != daemonrq_saveconfig)
(163,request)
(164,crit_enter()
(165,request->info)
(166,daemon_options)
(167,daemonq->next)
(168,if (daemon_options & daemon_verbose)
(169,rq)
(170,P_INMEM)
(171,rq->bp->b_dev)
(172,0)
(173,request->info.drive)
(174,NULL)
(175,rq->bp)
(176,request)
(177,rq)
(178,"vinum: ping reply\\n")
(179,rq)
(180,break;)
(181,(daemonq == NULL)
(182,daemon_options)
(183,p_flag)
(184,rq->bp->b_blkno)
(185,if (((daemon_options & daemon_noupdate)
(186,if (curproc->p_pid != daemonpid)
(187,0)
(188,daemon_save_config()
(189,return;)
(190,daemonq)
(191,vinum_daemon)
(192,daemon_options)
(193,type)
(194,while (1)
(195,request->privateinuse = 0)
(196,daemonq)
(197,daemonq)
(198,rq->bp->b_flags & B_READ)
(199,bp)
(200,daemonq)
(201,daemon_verbose)
(202,request->info.rq)
(203,case daemonrq_saveconfig:)
(204,next)
(205,NULL)
(206,p_pid)
(207,daemon_options & daemon_verbose)
(208,daemon_verbose)
(209,daemon_options & daemon_verbose)
(210,request)
(211,request->privateinuse)
(212,rq->bp->b_flags)
(213,break;)
(214,daemonq == NULL)
(215,"Invalid request\\n")
(216,P_INMEM | P_SYSTEM)
(217,curproc->p_pid != daemonpid)
(218,0)
(219,privateinuse)
(220,break;)
(221,daemonpid)
(222,)
(223,daemon_options & daemon_verbose)
(224,log(LOG_INFO, "vinum: ping reply\\n")
(225,vinumclose)
(226,daemon_options |= daemon_stopped)
(227,daemonq->next)
(228,if (daemon_options & daemon_verbose)
(229,if (request->privateinuse)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^