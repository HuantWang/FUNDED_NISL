-----label-----
1
-----code-----
void do_page_fault(struct pt_regs *regs, int write, unsigned long address,
		   unsigned long cause_code)
{
	struct vm_area_struct *vma = NULL;
	struct task_struct *tsk = current;
	struct mm_struct *mm = tsk->mm;
	siginfo_t info;
	int fault, ret;
	unsigned int flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE;

	/*
	 * We fault-in kernel-space virtual memory on-demand. The
	 * 'reference' page table is init_mm.pgd.
	 *
	 * NOTE! We MUST NOT take any locks for this case. We may
	 * be in an interrupt or a critical region, and should
	 * only copy the information from the master page table,
	 * nothing more.
	 */
	if (address >= VMALLOC_START && address <= VMALLOC_END) {
		ret = handle_vmalloc_fault(address);
		if (unlikely(ret))
			goto bad_area_nosemaphore;
		else
			return;
	}

	info.si_code = SEGV_MAPERR;

	/*
	 * If we're in an interrupt or have no user
	 * context, we must not take the fault..
	 */
	if (in_atomic() || !mm)
		goto no_context;

	if (user_mode(regs))
		flags |= FAULT_FLAG_USER;
retry:
	down_read(&mm->mmap_sem);
	vma = find_vma(mm, address);
	if (!vma)
		goto bad_area;
	if (vma->vm_start <= address)
		goto good_area;
	if (!(vma->vm_flags & VM_GROWSDOWN))
		goto bad_area;
	if (expand_stack(vma, address))
		goto bad_area;

	/*
	 * Ok, we have a good vm_area for this memory access, so
	 * we can handle it..
	 */
good_area:
	info.si_code = SEGV_ACCERR;

	/* Handle protection violation, execute on heap or stack */

	if (cause_code == ((ECR_V_PROTV << 16) | ECR_C_PROTV_INST_FETCH))
		goto bad_area;

	if (write) {
		if (!(vma->vm_flags & VM_WRITE))
			goto bad_area;
		flags |= FAULT_FLAG_WRITE;
	} else {
		if (!(vma->vm_flags & (VM_READ | VM_EXEC)))
			goto bad_area;
	}

	/*
	 * If for any reason at all we couldn't handle the fault,
	 * make sure we exit gracefully rather than endlessly redo
	 * the fault.
	 */
	fault = handle_mm_fault(mm, vma, address, flags);

	/* If Pagefault was interrupted by SIGKILL, exit page fault "early" */
	if (unlikely(fatal_signal_pending(current))) {
		if ((fault & VM_FAULT_ERROR) && !(fault & VM_FAULT_RETRY))
			up_read(&mm->mmap_sem);
		if (user_mode(regs))
			return;
	}

	if (likely(!(fault & VM_FAULT_ERROR))) {
		if (flags & FAULT_FLAG_ALLOW_RETRY) {
			/* To avoid updating stats twice for retry case */
			if (fault & VM_FAULT_MAJOR)
				tsk->maj_flt++;
			else
				tsk->min_flt++;

			if (fault & VM_FAULT_RETRY) {
				flags &= ~FAULT_FLAG_ALLOW_RETRY;
				flags |= FAULT_FLAG_TRIED;
				goto retry;
			}
		}

		/* Fault Handled Gracefully */
		up_read(&mm->mmap_sem);
		return;
	}

	/* TBD: switch to pagefault_out_of_memory() */
	if (fault & VM_FAULT_OOM)
		goto out_of_memory;
	else if (fault & VM_FAULT_SIGBUS)
		goto do_sigbus;

	/* no man's land */
	BUG();

	/*
	 * Something tried to access memory that isn't in our memory map..
	 * Fix it, but check if it's kernel or user first..
	 */
bad_area:
	up_read(&mm->mmap_sem);

bad_area_nosemaphore:
	/* User mode accesses just cause a SIGSEGV */
	if (user_mode(regs)) {
		tsk->thread.fault_address = address;
		tsk->thread.cause_code = cause_code;
		info.si_signo = SIGSEGV;
		info.si_errno = 0;
		/* info.si_code has been set above */
		info.si_addr = (void __user *)address;
		force_sig_info(SIGSEGV, &info, tsk);
		return;
	}

no_context:
	/* Are we prepared to handle this kernel fault?
	 *
	 * (The kernel has valid exception-points in the source
	 *  when it acesses user-memory. When it fails in one
	 *  of those points, we find it in a table and do a jump
	 *  to some fixup code that loads an appropriate error
	 *  code)
	 */
	if (fixup_exception(regs))
		return;

	die("Oops", regs, address, cause_code);

out_of_memory:
	up_read(&mm->mmap_sem);

	if (user_mode(regs)) {
		pagefault_out_of_memory();
		return;
	}

	goto no_context;

do_sigbus:
	up_read(&mm->mmap_sem);

	if (!user_mode(regs))
		goto no_context;

	tsk->thread.fault_address = address;
	tsk->thread.cause_code = cause_code;
	info.si_signo = SIGBUS;
	info.si_errno = 0;
	info.si_code = BUS_ADRERR;
	info.si_addr = (void __user *)address;
	force_sig_info(SIGBUS, &info, tsk);
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
3,7
3,8
5,6
5,7
6,7
8,9
8,10
11,12
11,13
13,14
15,16
15,17
17,18
19,20
19,21
21,22
23,24
23,25
23,26
23,27
23,28
23,29
23,30
23,31
23,32
23,33
23,34
23,35
23,36
23,37
23,38
23,39
23,40
23,41
23,42
23,43
23,44
23,45
23,46
23,47
23,48
23,49
23,50
23,51
23,52
23,53
23,54
23,55
23,56
23,57
23,58
23,59
23,60
23,61
23,62
23,63
24,25
25,26
25,27
26,27
28,29
28,30
28,31
31,32
32,33
34,35
35,36
35,37
36,37
38,39
38,40
38,41
41,42
42,43
44,45
45,46
45,47
46,47
48,49
48,50
48,51
51,52
52,53
52,54
53,54
56,57
57,58
57,59
58,59
60,61
62,63
63,64
63,65
63,66
65,66
67,68
69,70
70,71
70,72
72,73
72,74
74,75
75,76
75,77
76,77
78,79
80,81
80,82
81,82
81,83
82,83
82,84
83,84
85,86
87,88
87,89
88,89
90,91
92,93
92,94
93,94
94,95
94,96
95,96
97,98
97,99
98,99
100,101
102,103
102,104
102,105
103,104
103,105
104,105
106,107
108,109
111,112
112,113
112,114
113,114
113,115
114,115
117,118
119,120
119,121
120,121
120,122
121,122
122,123
124,125
125,126
127,128
129,130
129,131
130,131
130,132
131,132
133,134
135,136
136,137
136,138
137,138
139,140
141,142
141,143
143,144
144,145
144,146
145,146
147,148
148,149
148,150
149,150
152,153
153,154
153,155
154,155
156,157
156,158
156,159
157,158
159,160
161,162
163,164
163,165
164,165
165,166
167,168
169,170
169,171
170,171
170,172
171,172
171,173
172,173
175,176
177,178
179,180
179,181
180,181
181,182
182,183
182,184
183,184
183,185
184,185
187,188
189,190
191,192
191,193
192,193
192,194
192,195
193,194
195,196
197,198
199,200
201,202
201,203
203,204
204,205
204,206
205,206
205,207
206,207
209,210
211,212
211,213
212,213
212,214
213,214
215,216
216,217
216,218
217,218
218,219
218,220
219,220
222,223
224,225
226,227
226,228
226,229
227,228
229,230
229,231
230,231
230,232
231,232
232,233
233,234
233,235
234,235
234,236
235,236
238,239
240,241
242,243
243,244
243,245
244,245
246,247
248,249
249,250
249,251
250,251
251,252
252,253
252,254
253,254
253,255
254,255
257,258
258,259
258,260
259,260
261,262
263,264
265,266
266,267
266,268
267,268
269,270
269,271
269,272
269,273
269,274
270,271
272,273
274,275
276,277
278,279
280,281
280,282
281,282
281,283
282,283
284,285
285,286
285,287
287,288
287,289
288,289
290,291
292,293
292,294
293,294
293,295
294,295
294,296
295,296
296,297
296,298
297,298
299,300
301,302
302,303
303,304
303,305
304,305
306,307
308,309
309,310
309,311
310,311
312,313
313,314
313,315
314,315
317,318
317,319
318,319
318,320
319,320
321,322
324,325
324,326
325,326
325,327
326,327
328,329
329,330
330,331
330,332
331,332
333,334
335,336
335,337
335,338
336,337
336,338
337,338
337,339
338,339
340,341
342,343
342,344
343,344
343,345
343,346
344,345
344,346
345,346
347,348
349,350
350,351
351,352
351,353
352,353
355,356
356,357
357,358
357,359
358,359
361,362
361,363
362,363
362,364
363,364
365,366
367,368
367,369
367,370
368,369
369,370
369,371
370,371
372,373
373,374
375,376
376,377
376,378
377,378
379,380
381,382
383,384
384,385
384,386
385,386
387,388
388,389
388,390
389,390
393,394
393,395
393,396
394,395
394,396
395,396
397,398
399,400
401,402
401,403
402,403
402,404
403,404
405,406
407,408
409,410
410,411
411,412
413,414
413,415
415,416
416,417
416,418
417,418
419,420
420,421
420,422
421,422
424,425
424,426
426,427
426,428
427,428
427,429
428,429
430,431
432,433
432,434
432,435
432,436
432,437
432,438
432,439
433,434
434,435
434,436
435,436
435,437
436,437
436,438
437,438
441,442
443,444
444,445
444,446
445,446
445,447
446,447
446,448
447,448
451,452
453,454
454,455
454,456
455,456
455,457
456,457
459,460
461,462
462,463
462,464
463,464
463,465
464,465
468,469
469,470
470,471
470,472
470,473
470,474
471,472
473,474
475,476
476,477
478,479
481,482
481,483
483,484
483,485
484,485
484,486
485,486
487,488
490,491
491,492
491,493
491,494
491,495
491,496
492,493
495,496
497,498
499,500
501,502
501,503
503,504
504,505
504,506
505,506
507,508
508,509
508,510
509,510
512,513
512,514
513,514
513,515
514,515
516,517
518,519
518,520
519,520
520,521
521,522
524,525
526,527
526,528
528,529
529,530
529,531
530,531
532,533
533,534
533,535
534,535
537,538
537,539
538,539
539,540
539,541
540,541
542,543
544,545
546,547
547,548
547,549
548,549
548,550
549,550
549,551
550,551
554,555
556,557
557,558
557,559
558,559
558,560
559,560
559,561
560,561
564,565
566,567
567,568
567,569
568,569
568,570
569,570
572,573
574,575
575,576
575,577
576,577
576,578
577,578
581,582
582,583
582,584
583,584
583,585
584,585
587,588
589,590
590,591
591,592
591,593
591,594
591,595
592,593
594,595
596,597
597,598
599,600
-----nextToken-----
2,4,7,9,10,12,14,16,18,20,22,27,29,30,33,37,39,40,43,47,49,50,54,55,59,61,64,66,68,71,73,77,79,84,86,89,91,96,99,101,105,107,109,110,115,116,118,123,126,128,132,134,138,140,142,146,150,151,155,158,160,162,166,168,173,174,176,178,185,186,188,190,194,196,198,200,202,207,208,210,214,220,221,223,225,228,236,237,239,241,245,247,255,256,260,262,264,268,271,273,275,277,279,283,286,289,291,298,300,305,307,311,315,316,320,322,323,327,332,334,339,341,346,348,353,354,359,360,364,366,371,374,378,380,382,386,390,391,392,396,398,400,404,406,408,412,414,418,422,423,425,429,431,438,439,440,442,448,449,450,452,457,458,460,465,466,467,472,474,477,479,480,482,486,488,489,493,494,496,498,500,502,506,510,511,515,517,522,523,525,527,531,535,536,541,543,545,551,552,553,555,561,562,563,565,570,571,573,578,579,580,585,586,588,593,595,598,600
-----computeFrom-----
75,76
75,77
81,82
81,83
82,83
82,84
87,88
87,89
94,95
94,96
112,113
112,114
120,121
120,122
136,137
136,138
153,154
153,155
170,171
170,172
182,183
182,184
204,205
204,206
212,213
212,214
216,217
216,218
218,219
218,220
233,234
233,235
243,244
243,245
252,253
252,254
258,259
258,260
266,267
266,268
294,295
294,296
296,297
296,298
303,304
303,305
330,331
330,332
337,338
337,339
344,345
344,346
362,363
362,364
369,370
369,371
376,377
376,378
394,395
394,396
402,403
402,404
434,435
434,436
444,445
444,446
454,455
454,456
462,463
462,464
547,548
547,549
557,558
557,559
567,568
567,569
575,576
575,577
582,583
582,584
-----guardedBy-----
89,101
339,378
341,374
-----guardedByNegation-----
396,404
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;GotoStatement;Name;ReturnStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;GotoStatement;Name;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;LabelStatement;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;GotoStatement;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;GotoStatement;Name;IfStatement;UnaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;GotoStatement;Name;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;GotoStatement;Name;LabelStatement;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;UnaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;GotoStatement;Name;IfStatement;IdExpression;Name;CompoundStatement;IfStatement;UnaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;GotoStatement;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;UnaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;GotoStatement;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;FunctionDeclarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Name;CompoundStatement;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;IfStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;GotoStatement;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ReturnStatement;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;GotoStatement;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;GotoStatement;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LabelStatement;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;LabelStatement;Name;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ProblemStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;LabelStatement;Name;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LabelStatement;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ReturnStatement;GotoStatement;Name;LabelStatement;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;GotoStatement;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ProblemStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;
-----ast_node-----
void do_page_fault(struct pt_regs *regs, int write, unsigned long address,		   unsigned long cause_code){	struct vm_area_struct *vma = NULL;	struct task_struct *tsk = current;	struct mm_struct *mm = tsk->mm;	siginfo_t info;	int fault, ret;	unsigned int flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE;	/*	 * We fault-in kernel-space virtual memory on-demand. The	 * 'reference' page table is init_mm.pgd.	 *	 * NOTE! We MUST NOT take any locks for this case. We may	 * be in an interrupt or a critical region, and should	 * only copy the information from the master page table,	 * nothing more.	 */	if (address >= VMALLOC_START && address <= VMALLOC_END) {		ret = handle_vmalloc_fault(address);		if (unlikely(ret))			goto bad_area_nosemaphore;		else			return;	}	info.si_code = SEGV_MAPERR;	/*	 * If we're in an interrupt or have no user	 * context, we must not take the fault..	 */	if (in_atomic() || !mm)		goto no_context;	if (user_mode(regs))		flags |= FAULT_FLAG_USER;retry:	down_read(&mm->mmap_sem);	vma = find_vma(mm, address);	if (!vma)		goto bad_area;	if (vma->vm_start <= address)		goto good_area;	if (!(vma->vm_flags & VM_GROWSDOWN))		goto bad_area;	if (expand_stack(vma, address))		goto bad_area;	/*	 * Ok, we have a good vm_area for this memory access, so	 * we can handle it..	 */good_area:	info.si_code = SEGV_ACCERR;	/* Handle protection violation, execute on heap or stack */	if (cause_code == ((ECR_V_PROTV << 16) | ECR_C_PROTV_INST_FETCH))		goto bad_area;	if (write) {		if (!(vma->vm_flags & VM_WRITE))			goto bad_area;		flags |= FAULT_FLAG_WRITE;	} else {		if (!(vma->vm_flags & (VM_READ | VM_EXEC)))			goto bad_area;	}	/*	 * If for any reason at all we couldn't handle the fault,	 * make sure we exit gracefully rather than endlessly redo	 * the fault.	 */	fault = handle_mm_fault(mm, vma, address, flags);	/* If Pagefault was interrupted by SIGKILL, exit page fault "early" */	if (unlikely(fatal_signal_pending(current))) {		if ((fault & VM_FAULT_ERROR) && !(fault & VM_FAULT_RETRY))			up_read(&mm->mmap_sem);		if (user_mode(regs))			return;	}	if (likely(!(fault & VM_FAULT_ERROR))) {		if (flags & FAULT_FLAG_ALLOW_RETRY) {			/* To avoid updating stats twice for retry case */			if (fault & VM_FAULT_MAJOR)				tsk->maj_flt++;			else				tsk->min_flt++;			if (fault & VM_FAULT_RETRY) {				flags &= ~FAULT_FLAG_ALLOW_RETRY;				flags |= FAULT_FLAG_TRIED;				goto retry;			}		}		/* Fault Handled Gracefully */		up_read(&mm->mmap_sem);		return;	}	/* TBD: switch to pagefault_out_of_memory() */	if (fault & VM_FAULT_OOM)		goto out_of_memory;	else if (fault & VM_FAULT_SIGBUS)		goto do_sigbus;	/* no man's land */	BUG();	/*	 * Something tried to access memory that isn't in our memory map..	 * Fix it, but check if it's kernel or user first..	 */bad_area:	up_read(&mm->mmap_sem);bad_area_nosemaphore:	/* User mode accesses just cause a SIGSEGV */	if (user_mode(regs)) {		tsk->thread.fault_address = address;		tsk->thread.cause_code = cause_code;		info.si_signo = SIGSEGV;		info.si_errno = 0;		/* info.si_code has been set above */		info.si_addr = (void __user *)address;		force_sig_info(SIGSEGV, &info, tsk);		return;	}no_context:	/* Are we prepared to handle this kernel fault?	 *	 * (The kernel has valid exception-points in the source	 *  when it acesses user-memory. When it fails in one	 *  of those points, we find it in a table and do a jump	 *  to some fixup code that loads an appropriate error	 *  code)	 */	if (fixup_exception(regs))		return;	die("Oops", regs, address, cause_code);out_of_memory:	up_read(&mm->mmap_sem);	if (user_mode(regs)) {		pagefault_out_of_memory();		return;	}	goto no_context;do_sigbus:	up_read(&mm->mmap_sem);	if (!user_mode(regs))		goto no_context;	tsk->thread.fault_address = address;	tsk->thread.cause_code = cause_code;	info.si_signo = SIGBUS;	info.si_errno = 0;	info.si_code = BUS_ADRERR;	info.si_addr = (void __user *)address;	force_sig_info(SIGBUS, &info, tsk);}
void
do_page_fault(struct pt_regs *regs, int write, unsigned long address,		   unsigned long cause_code)
do_page_fault
struct pt_regs *regs
struct pt_regs
pt_regs
*regs
*
regs
int write
int
write
write
unsigned long address
unsigned long
address
address
unsigned long cause_code
unsigned long
cause_code
cause_code
{	struct vm_area_struct *vma = NULL;	struct task_struct *tsk = current;	struct mm_struct *mm = tsk->mm;	siginfo_t info;	int fault, ret;	unsigned int flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE;	/*	 * We fault-in kernel-space virtual memory on-demand. The	 * 'reference' page table is init_mm.pgd.	 *	 * NOTE! We MUST NOT take any locks for this case. We may	 * be in an interrupt or a critical region, and should	 * only copy the information from the master page table,	 * nothing more.	 */	if (address >= VMALLOC_START && address <= VMALLOC_END) {		ret = handle_vmalloc_fault(address);		if (unlikely(ret))			goto bad_area_nosemaphore;		else			return;	}	info.si_code = SEGV_MAPERR;	/*	 * If we're in an interrupt or have no user	 * context, we must not take the fault..	 */	if (in_atomic() || !mm)		goto no_context;	if (user_mode(regs))		flags |= FAULT_FLAG_USER;retry:	down_read(&mm->mmap_sem);	vma = find_vma(mm, address);	if (!vma)		goto bad_area;	if (vma->vm_start <= address)		goto good_area;	if (!(vma->vm_flags & VM_GROWSDOWN))		goto bad_area;	if (expand_stack(vma, address))		goto bad_area;	/*	 * Ok, we have a good vm_area for this memory access, so	 * we can handle it..	 */good_area:	info.si_code = SEGV_ACCERR;	/* Handle protection violation, execute on heap or stack */	if (cause_code == ((ECR_V_PROTV << 16) | ECR_C_PROTV_INST_FETCH))		goto bad_area;	if (write) {		if (!(vma->vm_flags & VM_WRITE))			goto bad_area;		flags |= FAULT_FLAG_WRITE;	} else {		if (!(vma->vm_flags & (VM_READ | VM_EXEC)))			goto bad_area;	}	/*	 * If for any reason at all we couldn't handle the fault,	 * make sure we exit gracefully rather than endlessly redo	 * the fault.	 */	fault = handle_mm_fault(mm, vma, address, flags);	/* If Pagefault was interrupted by SIGKILL, exit page fault "early" */	if (unlikely(fatal_signal_pending(current))) {		if ((fault & VM_FAULT_ERROR) && !(fault & VM_FAULT_RETRY))			up_read(&mm->mmap_sem);		if (user_mode(regs))			return;	}	if (likely(!(fault & VM_FAULT_ERROR))) {		if (flags & FAULT_FLAG_ALLOW_RETRY) {			/* To avoid updating stats twice for retry case */			if (fault & VM_FAULT_MAJOR)				tsk->maj_flt++;			else				tsk->min_flt++;			if (fault & VM_FAULT_RETRY) {				flags &= ~FAULT_FLAG_ALLOW_RETRY;				flags |= FAULT_FLAG_TRIED;				goto retry;			}		}		/* Fault Handled Gracefully */		up_read(&mm->mmap_sem);		return;	}	/* TBD: switch to pagefault_out_of_memory() */	if (fault & VM_FAULT_OOM)		goto out_of_memory;	else if (fault & VM_FAULT_SIGBUS)		goto do_sigbus;	/* no man's land */	BUG();	/*	 * Something tried to access memory that isn't in our memory map..	 * Fix it, but check if it's kernel or user first..	 */bad_area:	up_read(&mm->mmap_sem);bad_area_nosemaphore:	/* User mode accesses just cause a SIGSEGV */	if (user_mode(regs)) {		tsk->thread.fault_address = address;		tsk->thread.cause_code = cause_code;		info.si_signo = SIGSEGV;		info.si_errno = 0;		/* info.si_code has been set above */		info.si_addr = (void __user *)address;		force_sig_info(SIGSEGV, &info, tsk);		return;	}no_context:	/* Are we prepared to handle this kernel fault?	 *	 * (The kernel has valid exception-points in the source	 *  when it acesses user-memory. When it fails in one	 *  of those points, we find it in a table and do a jump	 *  to some fixup code that loads an appropriate error	 *  code)	 */	if (fixup_exception(regs))		return;	die("Oops", regs, address, cause_code);out_of_memory:	up_read(&mm->mmap_sem);	if (user_mode(regs)) {		pagefault_out_of_memory();		return;	}	goto no_context;do_sigbus:	up_read(&mm->mmap_sem);	if (!user_mode(regs))		goto no_context;	tsk->thread.fault_address = address;	tsk->thread.cause_code = cause_code;	info.si_signo = SIGBUS;	info.si_errno = 0;	info.si_code = BUS_ADRERR;	info.si_addr = (void __user *)address;	force_sig_info(SIGBUS, &info, tsk);}
struct vm_area_struct *vma = NULL;
struct vm_area_struct *vma = NULL;
struct vm_area_struct
vm_area_struct
*vma = NULL
*
vma
= NULL
NULL
NULL
struct task_struct *tsk = current;
struct task_struct *tsk = current;
struct task_struct
task_struct
*tsk = current
*
tsk
= current
current
current
struct mm_struct *mm = tsk->mm;
struct mm_struct *mm = tsk->mm;
struct mm_struct
mm_struct
*mm = tsk->mm
*
mm
= tsk->mm
tsk->mm
tsk
tsk
mm
siginfo_t info;
siginfo_t info;
siginfo_t
siginfo_t
info
info
int fault, ret;
int fault, ret;
int
fault
fault
ret
ret
unsigned int flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE;
unsigned int flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE;
unsigned int
flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE
flags
= FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE
FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE
FAULT_FLAG_ALLOW_RETRY
FAULT_FLAG_ALLOW_RETRY
FAULT_FLAG_KILLABLE
FAULT_FLAG_KILLABLE
if (address >= VMALLOC_START && address <= VMALLOC_END) {		ret = handle_vmalloc_fault(address);		if (unlikely(ret))			goto bad_area_nosemaphore;		else			return;	}
address >= VMALLOC_START && address <= VMALLOC_END
address >= VMALLOC_START
address
address
VMALLOC_START
VMALLOC_START
address <= VMALLOC_END
address
address
VMALLOC_END
VMALLOC_END
{		ret = handle_vmalloc_fault(address);		if (unlikely(ret))			goto bad_area_nosemaphore;		else			return;	}
ret = handle_vmalloc_fault(address);
ret = handle_vmalloc_fault(address)
ret
ret
handle_vmalloc_fault(address)
handle_vmalloc_fault
handle_vmalloc_fault
address
address
if (unlikely(ret))			goto bad_area_nosemaphore;		else			return;
unlikely(ret)
unlikely
unlikely
ret
ret
goto bad_area_nosemaphore;
bad_area_nosemaphore
return;
info.si_code = SEGV_MAPERR;
info.si_code = SEGV_MAPERR
info.si_code
info
info
si_code
SEGV_MAPERR
SEGV_MAPERR
if (in_atomic() || !mm)		goto no_context;
in_atomic() || !mm
in_atomic()
in_atomic
in_atomic
!mm
mm
mm
goto no_context;
no_context
if (user_mode(regs))		flags |= FAULT_FLAG_USER;
user_mode(regs)
user_mode
user_mode
regs
regs
flags |= FAULT_FLAG_USER;
flags |= FAULT_FLAG_USER
flags
flags
FAULT_FLAG_USER
FAULT_FLAG_USER
retry:	down_read(&mm->mmap_sem);
retry
down_read(&mm->mmap_sem);
down_read(&mm->mmap_sem)
down_read
down_read
&mm->mmap_sem
mm->mmap_sem
mm
mm
mmap_sem
vma = find_vma(mm, address);
vma = find_vma(mm, address)
vma
vma
find_vma(mm, address)
find_vma
find_vma
mm
mm
address
address
if (!vma)		goto bad_area;
!vma
vma
vma
goto bad_area;
bad_area
if (vma->vm_start <= address)		goto good_area;
vma->vm_start <= address
vma->vm_start
vma
vma
vm_start
address
address
goto good_area;
good_area
if (!(vma->vm_flags & VM_GROWSDOWN))		goto bad_area;
!(vma->vm_flags & VM_GROWSDOWN)
(vma->vm_flags & VM_GROWSDOWN)
vma->vm_flags & VM_GROWSDOWN
vma->vm_flags
vma
vma
vm_flags
VM_GROWSDOWN
VM_GROWSDOWN
goto bad_area;
bad_area
if (expand_stack(vma, address))		goto bad_area;
expand_stack(vma, address)
expand_stack
expand_stack
vma
vma
address
address
goto bad_area;
bad_area
good_area:	info.si_code = SEGV_ACCERR;
good_area
info.si_code = SEGV_ACCERR;
info.si_code = SEGV_ACCERR
info.si_code
info
info
si_code
SEGV_ACCERR
SEGV_ACCERR
if (cause_code == ((ECR_V_PROTV << 16) | ECR_C_PROTV_INST_FETCH))		goto bad_area;
cause_code == ((ECR_V_PROTV << 16) | ECR_C_PROTV_INST_FETCH)
cause_code
cause_code
((ECR_V_PROTV << 16) | ECR_C_PROTV_INST_FETCH)
(ECR_V_PROTV << 16) | ECR_C_PROTV_INST_FETCH
(ECR_V_PROTV << 16)
ECR_V_PROTV << 16
ECR_V_PROTV
ECR_V_PROTV
16
ECR_C_PROTV_INST_FETCH
ECR_C_PROTV_INST_FETCH
goto bad_area;
bad_area
if (write) {		if (!(vma->vm_flags & VM_WRITE))			goto bad_area;		flags |= FAULT_FLAG_WRITE;	} else {		if (!(vma->vm_flags & (VM_READ | VM_EXEC)))			goto bad_area;	}
write
write
{		if (!(vma->vm_flags & VM_WRITE))			goto bad_area;		flags |= FAULT_FLAG_WRITE;	}
if (!(vma->vm_flags & VM_WRITE))			goto bad_area;
!(vma->vm_flags & VM_WRITE)
(vma->vm_flags & VM_WRITE)
vma->vm_flags & VM_WRITE
vma->vm_flags
vma
vma
vm_flags
VM_WRITE
VM_WRITE
goto bad_area;
bad_area
flags |= FAULT_FLAG_WRITE;
flags |= FAULT_FLAG_WRITE
flags
flags
FAULT_FLAG_WRITE
FAULT_FLAG_WRITE
{		if (!(vma->vm_flags & (VM_READ | VM_EXEC)))			goto bad_area;	}
if (!(vma->vm_flags & (VM_READ | VM_EXEC)))			goto bad_area;
!(vma->vm_flags & (VM_READ | VM_EXEC))
(vma->vm_flags & (VM_READ | VM_EXEC))
vma->vm_flags & (VM_READ | VM_EXEC)
vma->vm_flags
vma
vma
vm_flags
(VM_READ | VM_EXEC)
VM_READ | VM_EXEC
VM_READ
VM_READ
VM_EXEC
VM_EXEC
goto bad_area;
bad_area
fault = handle_mm_fault(mm, vma, address, flags);
fault = handle_mm_fault(mm, vma, address, flags)
fault
fault
handle_mm_fault(mm, vma, address, flags)
handle_mm_fault
handle_mm_fault
mm
mm
vma
vma
address
address
flags
flags
if (unlikely(fatal_signal_pending(current))) {		if ((fault & VM_FAULT_ERROR) && !(fault & VM_FAULT_RETRY))			up_read(&mm->mmap_sem);		if (user_mode(regs))			return;	}
unlikely(fatal_signal_pending(current))
unlikely
unlikely
(fatal_signal_pending(current))
fatal_signal_pending(current)
fatal_signal_pending
current
current
current


{		if ((fault & VM_FAULT_ERROR) && !(fault & VM_FAULT_RETRY))			up_read(&mm->mmap_sem);		if (user_mode(regs))			return;	}
if ((fault & VM_FAULT_ERROR) && !(fault & VM_FAULT_RETRY))			up_read(&mm->mmap_sem);
(fault & VM_FAULT_ERROR) && !(fault & VM_FAULT_RETRY)
(fault & VM_FAULT_ERROR)
fault & VM_FAULT_ERROR
fault
fault
VM_FAULT_ERROR
VM_FAULT_ERROR
!(fault & VM_FAULT_RETRY)
(fault & VM_FAULT_RETRY)
fault & VM_FAULT_RETRY
fault
fault
VM_FAULT_RETRY
VM_FAULT_RETRY
up_read(&mm->mmap_sem);
up_read(&mm->mmap_sem)
up_read
up_read
&mm->mmap_sem
mm->mmap_sem
mm
mm
mmap_sem
if (user_mode(regs))			return;
user_mode(regs)
user_mode
user_mode
regs
regs
return;
if (likely(!(fault & VM_FAULT_ERROR))) {		if (flags & FAULT_FLAG_ALLOW_RETRY) {			/* To avoid updating stats twice for retry case */			if (fault & VM_FAULT_MAJOR)				tsk->maj_flt++;			else				tsk->min_flt++;			if (fault & VM_FAULT_RETRY) {				flags &= ~FAULT_FLAG_ALLOW_RETRY;				flags |= FAULT_FLAG_TRIED;				goto retry;			}		}		/* Fault Handled Gracefully */		up_read(&mm->mmap_sem);		return;	}
likely(!(fault & VM_FAULT_ERROR))
likely
likely
!(fault & VM_FAULT_ERROR)
(fault & VM_FAULT_ERROR)
fault & VM_FAULT_ERROR
fault
fault
VM_FAULT_ERROR
VM_FAULT_ERROR
{		if (flags & FAULT_FLAG_ALLOW_RETRY) {			/* To avoid updating stats twice for retry case */			if (fault & VM_FAULT_MAJOR)				tsk->maj_flt++;			else				tsk->min_flt++;			if (fault & VM_FAULT_RETRY) {				flags &= ~FAULT_FLAG_ALLOW_RETRY;				flags |= FAULT_FLAG_TRIED;				goto retry;			}		}		/* Fault Handled Gracefully */		up_read(&mm->mmap_sem);		return;	}
if (flags & FAULT_FLAG_ALLOW_RETRY) {			/* To avoid updating stats twice for retry case */			if (fault & VM_FAULT_MAJOR)				tsk->maj_flt++;			else				tsk->min_flt++;			if (fault & VM_FAULT_RETRY) {				flags &= ~FAULT_FLAG_ALLOW_RETRY;				flags |= FAULT_FLAG_TRIED;				goto retry;			}		}
flags & FAULT_FLAG_ALLOW_RETRY
flags
flags
FAULT_FLAG_ALLOW_RETRY
FAULT_FLAG_ALLOW_RETRY
{			/* To avoid updating stats twice for retry case */			if (fault & VM_FAULT_MAJOR)				tsk->maj_flt++;			else				tsk->min_flt++;			if (fault & VM_FAULT_RETRY) {				flags &= ~FAULT_FLAG_ALLOW_RETRY;				flags |= FAULT_FLAG_TRIED;				goto retry;			}		}
if (fault & VM_FAULT_MAJOR)				tsk->maj_flt++;			else				tsk->min_flt++;
fault & VM_FAULT_MAJOR
fault
fault
VM_FAULT_MAJOR
VM_FAULT_MAJOR
tsk->maj_flt++;
tsk->maj_flt++
tsk->maj_flt
tsk
tsk
maj_flt
tsk->min_flt++;
tsk->min_flt++
tsk->min_flt
tsk
tsk
min_flt
if (fault & VM_FAULT_RETRY) {				flags &= ~FAULT_FLAG_ALLOW_RETRY;				flags |= FAULT_FLAG_TRIED;				goto retry;			}
fault & VM_FAULT_RETRY
fault
fault
VM_FAULT_RETRY
VM_FAULT_RETRY
{				flags &= ~FAULT_FLAG_ALLOW_RETRY;				flags |= FAULT_FLAG_TRIED;				goto retry;			}
flags &= ~FAULT_FLAG_ALLOW_RETRY;
flags &= ~FAULT_FLAG_ALLOW_RETRY
flags
flags
~FAULT_FLAG_ALLOW_RETRY
FAULT_FLAG_ALLOW_RETRY
FAULT_FLAG_ALLOW_RETRY
flags |= FAULT_FLAG_TRIED;
flags |= FAULT_FLAG_TRIED
flags
flags
FAULT_FLAG_TRIED
FAULT_FLAG_TRIED
goto retry;
retry
up_read(&mm->mmap_sem);
up_read(&mm->mmap_sem)
up_read
up_read
&mm->mmap_sem
mm->mmap_sem
mm
mm
mmap_sem
return;
if (fault & VM_FAULT_OOM)		goto out_of_memory;	else if (fault & VM_FAULT_SIGBUS)		goto do_sigbus;
fault & VM_FAULT_OOM
fault
fault
VM_FAULT_OOM
VM_FAULT_OOM
goto out_of_memory;
out_of_memory
if (fault & VM_FAULT_SIGBUS)		goto do_sigbus;
fault & VM_FAULT_SIGBUS
fault
fault
VM_FAULT_SIGBUS
VM_FAULT_SIGBUS
goto do_sigbus;
do_sigbus
BUG();
BUG()
BUG
BUG
bad_area:	up_read(&mm->mmap_sem);
bad_area
up_read(&mm->mmap_sem);
up_read(&mm->mmap_sem)
up_read
up_read
&mm->mmap_sem
mm->mmap_sem
mm
mm
mmap_sem
bad_area_nosemaphore:	/* User mode accesses just cause a SIGSEGV */	if (user_mode(regs)) {		tsk->thread.fault_address = address;		tsk->thread.cause_code = cause_code;		info.si_signo = SIGSEGV;		info.si_errno = 0;		/* info.si_code has been set above */		info.si_addr = (void __user *)address;		force_sig_info(SIGSEGV, &info, tsk);		return;	}
bad_area_nosemaphore
if (user_mode(regs)) {		tsk->thread.fault_address = address;		tsk->thread.cause_code = cause_code;		info.si_signo = SIGSEGV;		info.si_errno = 0;		/* info.si_code has been set above */		info.si_addr = (void __user *)address;		force_sig_info(SIGSEGV, &info, tsk);		return;	}
user_mode(regs)
user_mode
user_mode
regs
regs
{		tsk->thread.fault_address = address;		tsk->thread.cause_code = cause_code;		info.si_signo = SIGSEGV;		info.si_errno = 0;		/* info.si_code has been set above */		info.si_addr = (void __user *)address;		force_sig_info(SIGSEGV, &info, tsk);		return;	}
tsk->thread.fault_address = address;
tsk->thread.fault_address = address
tsk->thread.fault_address
tsk->thread
tsk
tsk
thread
fault_address
address
address
tsk->thread.cause_code = cause_code;
tsk->thread.cause_code = cause_code
tsk->thread.cause_code
tsk->thread
tsk
tsk
thread
cause_code
cause_code
cause_code
info.si_signo = SIGSEGV;
info.si_signo = SIGSEGV
info.si_signo
info
info
si_signo
SIGSEGV
SIGSEGV
info.si_errno = 0;
info.si_errno = 0
info.si_errno
info
info
si_errno
0
info.si_addr = (void __user *)address;
force_sig_info(SIGSEGV, &info, tsk);
force_sig_info(SIGSEGV, &info, tsk)
force_sig_info
force_sig_info
SIGSEGV
SIGSEGV
&info
info
info
tsk
tsk
return;
no_context:	/* Are we prepared to handle this kernel fault?	 *	 * (The kernel has valid exception-points in the source	 *  when it acesses user-memory. When it fails in one	 *  of those points, we find it in a table and do a jump	 *  to some fixup code that loads an appropriate error	 *  code)	 */	if (fixup_exception(regs))		return;
no_context
if (fixup_exception(regs))		return;
fixup_exception(regs)
fixup_exception
fixup_exception
regs
regs
return;
die("Oops", regs, address, cause_code);
die("Oops", regs, address, cause_code)
die
die
"Oops"
regs
regs
address
address
cause_code
cause_code
out_of_memory:	up_read(&mm->mmap_sem);
out_of_memory
up_read(&mm->mmap_sem);
up_read(&mm->mmap_sem)
up_read
up_read
&mm->mmap_sem
mm->mmap_sem
mm
mm
mmap_sem
if (user_mode(regs)) {		pagefault_out_of_memory();		return;	}
user_mode(regs)
user_mode
user_mode
regs
regs
{		pagefault_out_of_memory();		return;	}
pagefault_out_of_memory();
pagefault_out_of_memory()
pagefault_out_of_memory
pagefault_out_of_memory
return;
goto no_context;
no_context
do_sigbus:	up_read(&mm->mmap_sem);
do_sigbus
up_read(&mm->mmap_sem);
up_read(&mm->mmap_sem)
up_read
up_read
&mm->mmap_sem
mm->mmap_sem
mm
mm
mmap_sem
if (!user_mode(regs))		goto no_context;
!user_mode(regs)
user_mode(regs)
user_mode
user_mode
regs
regs
goto no_context;
no_context
tsk->thread.fault_address = address;
tsk->thread.fault_address = address
tsk->thread.fault_address
tsk->thread
tsk
tsk
thread
fault_address
address
address
tsk->thread.cause_code = cause_code;
tsk->thread.cause_code = cause_code
tsk->thread.cause_code
tsk->thread
tsk
tsk
thread
cause_code
cause_code
cause_code
info.si_signo = SIGBUS;
info.si_signo = SIGBUS
info.si_signo
info
info
si_signo
SIGBUS
SIGBUS
info.si_errno = 0;
info.si_errno = 0
info.si_errno
info
info
si_errno
0
info.si_code = BUS_ADRERR;
info.si_code = BUS_ADRERR
info.si_code
info
info
si_code
BUS_ADRERR
BUS_ADRERR
info.si_addr = (void __user *)address;
force_sig_info(SIGBUS, &info, tsk);
force_sig_info(SIGBUS, &info, tsk)
force_sig_info
force_sig_info
SIGBUS
SIGBUS
&info
info
info
tsk
tsk
-----joern-----
(27,94,0)
(263,120,0)
(66,35,0)
(305,123,0)
(309,128,0)
(313,211,0)
(29,286,0)
(175,287,0)
(188,333,0)
(315,147,0)
(219,306,0)
(293,177,0)
(134,330,0)
(328,246,0)
(311,83,0)
(263,35,0)
(224,58,0)
(38,38,0)
(249,188,0)
(9,227,0)
(252,323,0)
(141,106,0)
(169,151,0)
(307,274,0)
(232,125,0)
(225,335,0)
(284,35,0)
(270,306,0)
(245,97,0)
(167,266,0)
(160,74,0)
(297,35,0)
(271,287,0)
(42,38,0)
(79,222,0)
(135,33,0)
(282,208,0)
(221,230,0)
(94,306,0)
(159,261,0)
(174,286,0)
(24,150,0)
(62,227,0)
(238,35,0)
(58,35,0)
(196,249,0)
(44,330,0)
(111,147,0)
(230,253,0)
(168,116,0)
(289,120,0)
(104,61,0)
(92,35,0)
(274,35,0)
(100,35,0)
(13,140,0)
(157,51,0)
(279,35,0)
(157,143,0)
(334,78,0)
(219,261,0)
(322,100,0)
(306,289,0)
(236,80,0)
(218,269,0)
(80,261,0)
(81,83,0)
(269,40,0)
(317,212,0)
(208,282,0)
(88,219,0)
(260,40,0)
(76,35,0)
(258,109,0)
(42,80,0)
(42,340,0)
(48,97,0)
(314,65,0)
(69,256,0)
(42,244,0)
(199,207,0)
(165,124,0)
(137,128,0)
(227,187,0)
(140,259,0)
(170,332,0)
(339,306,0)
(125,120,0)
(323,252,0)
(257,118,0)
(75,117,0)
(316,208,0)
(89,185,0)
(37,203,0)
(219,38,0)
(327,272,0)
(10,35,0)
(330,134,0)
(64,306,0)
(203,109,0)
(163,190,0)
(336,12,0)
(306,35,0)
(84,61,0)
(262,86,0)
(255,183,0)
(0,269,0)
(179,30,0)
(286,29,0)
(339,156,0)
(91,230,0)
(163,120,0)
(289,306,0)
(200,235,0)
(247,327,0)
(250,321,0)
(87,312,0)
(20,272,0)
(18,48,0)
(1,103,0)
(49,64,0)
(146,29,0)
(30,179,0)
(90,200,0)
(230,91,0)
(19,35,0)
(57,124,0)
(129,244,0)
(231,170,0)
(225,113,0)
(261,159,0)
(327,187,0)
(137,63,0)
(313,186,0)
(59,244,0)
(251,270,0)
(186,35,0)
(136,1,0)
(211,317,0)
(63,187,0)
(56,30,0)
(101,109,0)
(116,168,0)
(38,340,0)
(338,33,0)
(96,74,0)
(171,263,0)
(268,233,0)
(187,35,0)
(222,79,0)
(163,58,0)
(242,233,0)
(143,35,0)
(237,35,0)
(269,186,0)
(319,51,0)
(126,97,0)
(207,64,0)
(176,314,0)
(216,35,0)
(205,305,0)
(114,35,0)
(298,35,0)
(36,224,0)
(147,315,0)
(183,86,0)
(234,38,0)
(125,306,0)
(312,261,0)
(207,120,0)
(25,5,0)
(225,153,0)
(58,163,0)
(29,186,0)
(41,320,0)
(332,170,0)
(287,66,0)
(31,100,0)
(140,264,0)
(138,35,0)
(85,289,0)
(168,120,0)
(112,140,0)
(43,35,0)
(202,139,0)
(321,187,0)
(34,327,0)
(241,44,0)
(270,222,0)
(267,259,0)
(86,219,0)
(51,186,0)
(131,299,0)
(115,163,0)
(330,44,0)
(304,35,0)
(91,264,0)
(191,64,0)
(215,276,0)
(98,42,0)
(201,313,0)
(195,54,0)
(280,66,0)
(235,200,0)
(233,101,0)
(192,125,0)
(292,136,0)
(235,282,0)
(12,114,0)
(148,219,0)
(94,30,0)
(261,35,0)
(54,259,0)
(97,109,0)
(229,261,0)
(80,38,0)
(333,35,0)
(33,86,0)
(329,200,0)
(208,86,0)
(248,253,0)
(277,35,0)
(39,101,0)
(65,35,0)
(61,308,0)
(16,151,0)
(223,155,0)
(72,100,0)
(80,244,0)
(204,323,0)
(189,63,0)
(149,35,0)
(310,140,0)
(106,109,0)
(320,186,0)
(200,86,0)
(226,117,0)
(211,313,0)
(77,35,0)
(107,159,0)
(239,4,0)
(52,158,0)
(127,270,0)
(164,227,0)
(53,137,0)
(74,120,0)
(140,120,0)
(285,35,0)
(42,261,0)
(3,312,0)
(132,219,0)
(312,244,0)
(332,263,0)
(152,156,0)
(225,131,0)
(118,120,0)
(275,80,0)
(177,259,0)
(97,48,0)
(214,219,0)
(172,35,0)
(219,186,0)
(281,35,0)
(45,168,0)
(253,230,0)
(243,170,0)
(217,313,0)
(153,109,0)
(166,339,0)
(197,306,0)
(190,163,0)
(47,35,0)
(219,244,0)
(102,42,0)
(122,35,0)
(74,258,0)
(173,35,0)
(63,137,0)
(276,274,0)
(337,326,0)
(219,86,0)
(244,261,0)
(26,63,0)
(303,91,0)
(60,35,0)
(86,35,0)
(318,35,0)
(301,224,0)
(246,264,0)
(156,152,0)
(23,339,0)
(11,35,0)
(55,168,0)
(14,183,0)
(289,186,0)
(312,38,0)
(17,84,0)
(156,339,0)
(323,187,0)
(272,246,0)
(151,86,0)
(203,264,0)
(273,332,0)
(22,38,0)
(142,139,0)
(220,51,0)
(326,321,0)
(123,305,0)
(249,186,0)
(256,116,0)
(282,235,0)
(305,205,0)
(288,158,0)
(254,276,0)
(177,293,0)
(225,46,0)
(61,118,0)
(2,256,0)
(312,80,0)
(342,267,0)
(213,259,0)
(219,80,0)
(68,156,0)
(194,140,0)
(188,249,0)
(294,35,0)
(317,211,0)
(219,120,0)
(44,86,0)
(105,323,0)
(326,203,0)
(155,106,0)
(291,35,0)
(82,308,0)
(283,155,0)
(193,249,0)
(97,187,0)
(290,187,0)
(74,160,0)
(5,259,0)
(227,9,0)
(246,35,0)
(258,74,0)
(99,289,0)
(40,260,0)
(32,205,0)
(30,94,0)
(184,187,0)
(143,157,0)
(80,266,0)
(136,186,0)
(178,205,0)
(116,256,0)
(6,94,0)
(320,187,0)
(103,35,0)
(128,120,0)
(100,187,0)
(321,326,0)
(260,35,0)
(256,120,0)
(278,159,0)
(64,207,0)
(21,320,0)
(162,136,0)
(333,188,0)
(205,186,0)
(181,340,0)
(295,35,0)
(71,186,0)
(324,296,0)
(302,253,0)
(335,212,0)
(40,269,0)
(117,86,0)
(4,258,0)
(222,270,0)
(154,213,0)
(70,108,0)
(133,114,0)
(161,35,0)
(78,259,0)
(150,306,0)
(121,208,0)
(139,296,0)
(228,321,0)
(158,222,0)
(28,31,0)
(38,261,0)
(180,177,0)
(38,244,0)
(140,35,0)
(325,35,0)
(1,136,0)
(206,108,0)
(100,31,0)
(286,174,0)
(15,4,0)
(331,12,0)
(265,35,0)
(225,182,0)
(118,61,0)
(38,80,0)
(170,187,0)
(128,109,0)
(210,65,0)
(103,1,0)
(51,157,0)
(130,314,0)
(272,327,0)
(300,299,0)
(186,320,0)
(296,35,0)
(124,35,0)
(222,158,0)
(8,44,0)
(93,212,0)
(312,244,1)
(335,317,1)
(249,186,1)
(309,137,1)
(45,256,1)
(69,2,1)
(267,342,1)
(269,186,1)
(257,104,1)
(118,257,1)
(333,188,1)
(104,116,1)
(4,239,1)
(302,248,1)
(322,58,1)
(68,339,1)
(64,191,1)
(117,75,1)
(296,324,1)
(74,160,1)
(272,20,1)
(80,236,1)
(71,187,1)
(219,306,1)
(135,134,1)
(280,287,1)
(208,86,1)
(232,179,1)
(157,51,1)
(222,270,1)
(143,157,1)
(94,6,1)
(97,245,1)
(152,156,1)
(223,101,1)
(54,195,1)
(320,21,1)
(37,326,1)
(113,78,1)
(61,118,1)
(292,162,1)
(144,125,1)
(39,233,1)
(145,91,1)
(132,88,1)
(5,25,1)
(16,169,1)
(312,38,1)
(326,321,1)
(13,78,1)
(136,292,1)
(217,183,1)
(102,183,1)
(2,261,1)
(32,282,1)
(125,192,1)
(202,142,1)
(50,152,1)
(336,331,1)
(209,286,1)
(324,139,1)
(258,74,1)
(312,261,1)
(97,187,1)
(319,220,1)
(153,97,1)
(26,189,1)
(176,130,1)
(242,268,1)
(30,56,1)
(44,86,1)
(23,166,1)
(323,204,1)
(329,208,1)
(287,271,1)
(312,3,1)
(312,80,1)
(29,186,1)
(271,175,1)
(99,197,1)
(112,194,1)
(78,259,1)
(211,313,1)
(44,241,1)
(56,94,1)
(116,168,1)
(80,38,1)
(213,154,1)
(225,182,1)
(53,63,1)
(186,320,1)
(14,9,1)
(256,69,1)
(332,273,1)
(116,256,1)
(332,170,1)
(334,209,1)
(233,242,1)
(177,180,1)
(251,145,1)
(52,288,1)
(165,57,1)
(42,261,1)
(3,87,1)
(275,152,1)
(193,140,1)
(260,40,1)
(100,72,1)
(74,120,1)
(175,246,1)
(162,240,1)
(30,94,1)
(166,145,1)
(148,262,1)
(225,131,1)
(286,174,1)
(205,186,1)
(230,221,1)
(219,120,1)
(131,300,1)
(90,329,1)
(217,312,1)
(191,49,1)
(274,307,1)
(125,306,1)
(67,33,1)
(96,4,1)
(48,18,1)
(193,67,1)
(227,187,1)
(51,319,1)
(263,171,1)
(17,61,1)
(283,223,1)
(38,261,1)
(225,153,1)
(59,54,1)
(38,38,1)
(219,244,1)
(210,314,1)
(294,267,1)
(142,66,1)
(38,244,1)
(97,48,1)
(146,174,1)
(273,170,1)
(174,65,1)
(111,86,1)
(192,232,1)
(58,163,1)
(139,202,1)
(42,244,1)
(341,150,1)
(33,86,1)
(55,45,1)
(78,334,1)
(162,341,1)
(128,309,1)
(171,332,1)
(249,196,1)
(220,244,1)
(115,224,1)
(219,38,1)
(219,80,1)
(38,80,1)
(34,263,1)
(219,132,1)
(137,53,1)
(334,213,1)
(262,79,1)
(22,42,1)
(12,336,1)
(136,186,1)
(51,186,1)
(20,327,1)
(289,85,1)
(219,261,1)
(310,13,1)
(41,71,1)
(184,290,1)
(252,323,1)
(197,143,1)
(130,116,1)
(222,158,1)
(9,227,1)
(321,187,1)
(244,261,1)
(224,36,1)
(31,28,1)
(42,80,1)
(88,214,1)
(154,110,1)
(239,15,1)
(168,120,1)
(103,1,1)
(247,34,1)
(119,91,1)
(38,234,1)
(8,315,1)
(225,113,1)
(164,62,1)
(183,86,1)
(126,258,1)
(236,275,1)
(289,186,1)
(194,310,1)
(269,218,1)
(14,252,1)
(94,306,1)
(140,112,1)
(27,207,1)
(200,90,1)
(101,39,1)
(338,135,1)
(75,226,1)
(95,207,1)
(268,203,1)
(207,64,1)
(229,186,1)
(124,165,1)
(63,26,1)
(80,261,1)
(301,114,1)
(178,32,1)
(337,321,1)
(177,259,1)
(163,115,1)
(137,63,1)
(282,235,1)
(201,217,1)
(230,253,1)
(327,187,1)
(198,151,1)
(100,187,1)
(183,255,1)
(121,315,1)
(36,301,1)
(62,117,1)
(54,259,1)
(330,44,1)
(227,164,1)
(215,254,1)
(6,27,1)
(156,68,1)
(289,120,1)
(306,289,1)
(243,231,1)
(127,251,1)
(134,330,1)
(107,229,1)
(140,120,1)
(147,111,1)
(245,48,1)
(276,215,1)
(254,125,1)
(117,86,1)
(187,184,1)
(327,247,1)
(49,150,1)
(129,59,1)
(40,269,1)
(114,133,1)
(272,327,1)
(66,280,1)
(150,306,1)
(151,86,1)
(248,303,1)
(188,249,1)
(317,211,1)
(205,178,1)
(231,293,1)
(84,17,1)
(228,250,1)
(316,121,1)
(25,282,1)
(98,102,1)
(313,186,1)
(334,294,1)
(200,86,1)
(331,296,1)
(33,338,1)
(253,302,1)
(323,187,1)
(24,306,1)
(162,19,1)
(163,190,1)
(182,5,1)
(63,187,1)
(85,99,1)
(8,5,1)
(315,147,1)
(80,244,1)
(220,54,1)
(79,222,1)
(42,38,1)
(156,339,1)
(207,199,1)
(313,201,1)
(170,243,1)
(64,306,1)
(128,120,1)
(170,187,1)
(328,272,1)
(204,105,1)
(28,322,1)
(140,259,1)
(150,24,1)
(65,210,1)
(151,16,1)
(219,186,1)
(203,37,1)
(263,120,1)
(180,260,1)
(15,106,1)
(133,12,1)
(326,337,1)
(270,306,1)
(218,0,1)
(290,124,1)
(106,141,1)
(241,8,1)
(305,205,1)
(293,177,1)
(73,179,1)
(125,120,1)
(244,129,1)
(246,328,1)
(18,126,1)
(169,33,1)
(288,270,1)
(234,22,1)
(100,31,1)
(154,103,1)
(46,84,1)
(235,200,1)
(162,144,1)
(214,148,1)
(278,107,1)
(225,335,1)
(254,95,1)
(86,219,1)
(158,52,1)
(246,264,1)
(42,98,1)
(339,306,1)
(105,117,1)
(256,120,1)
(84,61,1)
(207,120,1)
(240,79,1)
(179,30,1)
(5,259,1)
(320,187,1)
(342,333,1)
(118,120,1)
(339,23,1)
(19,151,1)
(203,264,1)
(334,7,1)
(163,120,1)
(250,128,1)
(314,176,1)
(270,127,1)
(141,155,1)
(195,286,1)
(196,193,1)
(226,312,1)
(189,213,1)
(110,84,1)
(221,253,1)
(225,46,1)
(286,29,1)
(300,267,1)
(123,305,1)
(7,293,1)
(140,264,1)
(162,73,1)
(303,274,1)
(91,230,1)
(29,146,1)
(1,136,1)
(199,64,1)
(208,316,1)
(261,159,1)
(74,96,1)
(91,264,1)
(262,80,1)
(72,31,1)
(225,100,1)
(282,208,1)
(21,41,1)
(162,119,1)
(155,283,1)
(159,278,1)
(0,198,1)
(213,259,1)
(321,228,1)
(220,181,1)
(255,14,1)
(307,276,1)
(181,38,1)
(87,134,1)
(25,123,1)
(267,259,1)
(162,50,1)
(168,55,1)
(222,158,2)
(166,145,2)
(80,152,2)
(260,151,2)
(136,152,2)
(110,84,2)
(211,312,2)
(15,213,2)
(230,253,2)
(324,293,2)
(261,159,2)
(228,213,2)
(148,79,2)
(32,282,2)
(24,183,2)
(29,186,2)
(67,33,2)
(289,183,2)
(123,305,2)
(286,116,2)
(117,86,2)
(319,183,2)
(198,151,2)
(87,134,2)
(13,78,2)
(148,152,2)
(331,293,2)
(327,187,2)
(342,78,2)
(176,116,2)
(256,120,2)
(302,125,2)
(163,120,2)
(208,86,2)
(200,208,2)
(197,286,2)
(218,151,2)
(338,134,2)
(192,179,2)
(326,213,2)
(117,312,2)
(267,259,2)
(219,306,2)
(333,33,2)
(306,183,2)
(310,78,2)
(162,91,2)
(30,207,2)
(80,261,2)
(263,120,2)
(232,179,2)
(1,125,2)
(96,213,2)
(48,213,2)
(19,151,2)
(42,261,2)
(125,179,2)
(214,152,2)
(213,150,2)
(156,145,2)
(225,335,2)
(235,200,2)
(103,125,2)
(95,207,2)
(85,183,2)
(162,125,2)
(317,183,2)
(223,213,2)
(213,125,2)
(150,286,2)
(103,151,2)
(220,183,2)
(306,289,2)
(51,183,2)
(189,213,2)
(207,120,2)
(64,150,2)
(49,150,2)
(152,145,2)
(341,150,2)
(27,207,2)
(53,213,2)
(140,78,2)
(241,5,2)
(40,151,2)
(78,213,2)
(268,213,2)
(51,286,2)
(280,293,2)
(58,293,2)
(286,29,2)
(342,33,2)
(101,213,2)
(128,120,2)
(137,63,2)
(42,183,2)
(296,293,2)
(42,244,2)
(197,183,2)
(78,267,2)
(252,117,2)
(219,152,2)
(61,116,2)
(140,259,2)
(136,186,2)
(114,293,2)
(86,219,2)
(333,78,2)
(99,286,2)
(143,157,2)
(235,208,2)
(56,207,2)
(294,267,2)
(162,79,2)
(9,227,2)
(205,282,2)
(322,293,2)
(317,211,2)
(282,235,2)
(145,91,2)
(293,151,2)
(100,187,2)
(219,80,2)
(283,213,2)
(103,179,2)
(247,293,2)
(168,120,2)
(275,152,2)
(222,145,2)
(293,177,2)
(115,293,2)
(193,78,2)
(221,207,2)
(203,264,2)
(219,244,2)
(12,293,2)
(44,86,2)
(136,91,2)
(334,213,2)
(94,306,2)
(163,293,2)
(246,264,2)
(329,208,2)
(334,293,2)
(58,163,2)
(333,188,2)
(154,152,2)
(140,120,2)
(196,33,2)
(203,213,2)
(183,312,2)
(240,79,2)
(188,78,2)
(5,259,2)
(147,152,2)
(78,259,2)
(86,152,2)
(154,79,2)
(36,293,2)
(249,186,2)
(51,186,2)
(40,269,2)
(204,117,2)
(307,207,2)
(315,152,2)
(292,151,2)
(132,79,2)
(162,150,2)
(314,116,2)
(323,117,2)
(65,116,2)
(328,293,2)
(136,179,2)
(68,145,2)
(73,179,2)
(170,187,2)
(136,151,2)
(7,293,2)
(276,207,2)
(255,312,2)
(78,286,2)
(276,125,2)
(136,150,2)
(302,207,2)
(136,125,2)
(183,86,2)
(106,213,2)
(44,5,2)
(121,315,2)
(127,145,2)
(31,293,2)
(219,38,2)
(321,187,2)
(85,286,2)
(211,313,2)
(91,207,2)
(128,213,2)
(137,213,2)
(79,145,2)
(289,186,2)
(134,5,2)
(38,38,2)
(33,134,2)
(99,183,2)
(72,293,2)
(59,54,2)
(319,286,2)
(289,286,2)
(258,74,2)
(248,207,2)
(103,91,2)
(219,186,2)
(169,33,2)
(209,286,2)
(130,116,2)
(103,150,2)
(100,293,2)
(171,293,2)
(30,94,2)
(292,125,2)
(213,179,2)
(219,120,2)
(150,306,2)
(22,183,2)
(233,213,2)
(244,261,2)
(226,312,2)
(312,134,2)
(97,187,2)
(201,183,2)
(6,207,2)
(249,33,2)
(309,213,2)
(194,78,2)
(97,213,2)
(156,339,2)
(112,78,2)
(38,183,2)
(225,182,2)
(220,286,2)
(215,125,2)
(1,152,2)
(168,256,2)
(245,213,2)
(154,150,2)
(221,125,2)
(42,38,2)
(79,222,2)
(250,213,2)
(303,125,2)
(300,267,2)
(262,152,2)
(292,79,2)
(5,315,2)
(335,312,2)
(207,150,2)
(157,183,2)
(38,244,2)
(75,312,2)
(330,44,2)
(134,330,2)
(193,33,2)
(313,312,2)
(320,187,2)
(8,5,2)
(274,207,2)
(330,315,2)
(91,264,2)
(151,86,2)
(244,54,2)
(258,213,2)
(248,125,2)
(282,315,2)
(1,91,2)
(150,183,2)
(50,152,2)
(157,286,2)
(119,91,2)
(269,151,2)
(177,151,2)
(272,293,2)
(306,286,2)
(317,312,2)
(186,320,2)
(1,179,2)
(104,116,2)
(217,312,2)
(239,213,2)
(8,315,2)
(132,152,2)
(86,79,2)
(170,293,2)
(286,174,2)
(312,80,2)
(227,187,2)
(143,183,2)
(272,327,2)
(142,293,2)
(46,84,2)
(84,61,2)
(274,125,2)
(154,91,2)
(227,117,2)
(135,134,2)
(230,207,2)
(20,293,2)
(222,270,2)
(335,183,2)
(196,78,2)
(16,33,2)
(191,150,2)
(1,136,2)
(321,213,2)
(327,293,2)
(103,1,2)
(39,213,2)
(213,91,2)
(25,315,2)
(37,213,2)
(305,205,2)
(323,187,2)
(63,213,2)
(241,315,2)
(180,151,2)
(254,207,2)
(175,293,2)
(88,152,2)
(1,150,2)
(326,321,2)
(267,78,2)
(42,80,2)
(230,125,2)
(242,213,2)
(243,293,2)
(139,293,2)
(307,125,2)
(17,116,2)
(257,116,2)
(54,286,2)
(179,207,2)
(213,79,2)
(164,117,2)
(102,183,2)
(252,323,2)
(249,78,2)
(78,293,2)
(312,38,2)
(313,183,2)
(18,213,2)
(211,183,2)
(177,259,2)
(303,207,2)
(205,186,2)
(336,293,2)
(143,286,2)
(208,315,2)
(0,151,2)
(289,120,2)
(118,120,2)
(162,152,2)
(74,120,2)
(219,79,2)
(236,152,2)
(61,118,2)
(213,151,2)
(195,286,2)
(54,259,2)
(225,113,2)
(251,145,2)
(116,256,2)
(334,267,2)
(74,213,2)
(29,174,2)
(94,207,2)
(253,207,2)
(219,261,2)
(213,152,2)
(246,293,2)
(231,293,2)
(91,230,2)
(129,54,2)
(201,312,2)
(23,145,2)
(140,264,2)
(207,64,2)
(339,145,2)
(217,183,2)
(181,183,2)
(254,125,2)
(88,79,2)
(234,183,2)
(26,213,2)
(270,145,2)
(200,86,2)
(103,152,2)
(267,33,2)
(214,79,2)
(147,79,2)
(315,147,2)
(260,40,2)
(105,117,2)
(332,293,2)
(136,79,2)
(316,315,2)
(153,213,2)
(97,48,2)
(80,244,2)
(210,116,2)
(262,79,2)
(133,293,2)
(312,261,2)
(146,174,2)
(154,84,2)
(188,249,2)
(125,306,2)
(63,187,2)
(154,151,2)
(152,156,2)
(179,30,2)
(292,91,2)
(292,179,2)
(313,186,2)
(188,33,2)
(330,5,2)
(158,145,2)
(305,282,2)
(45,256,2)
(154,125,2)
(263,293,2)
(225,46,2)
(134,315,2)
(74,160,2)
(224,293,2)
(174,116,2)
(44,315,2)
(312,244,2)
(271,293,2)
(202,293,2)
(339,306,2)
(155,213,2)
(213,84,2)
(151,33,2)
(126,213,2)
(4,213,2)
(273,293,2)
(163,190,2)
(80,38,2)
(38,80,2)
(141,213,2)
(332,170,2)
(125,120,2)
(62,117,2)
(38,261,2)
(253,125,2)
(292,150,2)
(116,168,2)
(111,152,2)
(162,179,2)
(1,79,2)
(64,306,2)
(162,151,2)
(337,213,2)
(182,5,2)
(215,207,2)
(288,145,2)
(118,116,2)
(111,79,2)
(91,125,2)
(301,293,2)
(144,125,2)
(28,293,2)
(282,208,2)
(178,282,2)
(225,131,2)
(98,183,2)
(34,293,2)
(100,31,2)
(199,150,2)
(90,208,2)
(14,312,2)
(123,282,2)
(287,293,2)
(154,179,2)
(33,86,2)
(213,259,2)
(334,286,2)
(269,186,2)
(9,117,2)
(292,152,2)
(3,134,2)
(157,51,2)
(24,286,2)
(66,293,2)
(225,153,2)
(113,78,2)
(84,116,2)
(103,79,2)
(315,79,2)
(1,151,2)
(52,145,2)
(270,306,2)
(55,256,2)
(131,267,2)
-----------------------------------
(0,mm)
(1,&mm->mmap_sem)
(2,address)
(3,FAULT_FLAG_ALLOW_RETRY)
(4,info.si_addr)
(5,user_mode(regs)
(6,vm_flags)
(7,goto no_context;)
(8,fault)
(9,tsk->min_flt++)
(10,mm)
(11,ret)
(12,info.si_code)
(13,"Oops")
(14,fault)
(15,info)
(16,VM_FAULT_SIGBUS)
(17,ret)
(18,info)
(19,BUG()
(20,cause_code)
(21,mm)
(22,flags)
(23,vm_flags)
(24,vma)
(25,regs)
(26,thread)
(27,vma)
(28,info)
(29,!mm)
(30,vma->vm_flags & VM_GROWSDOWN)
(31,&info)
(32,mm)
(33,fault & VM_FAULT_OOM)
(34,tsk)
(35,)
(36,si_addr)
(37,cause_code)
(38,flags |= FAULT_FLAG_TRIED)
(39,SIGSEGV)
(40,&mm->mmap_sem)
(41,tsk)
(42,flags &= ~FAULT_FLAG_ALLOW_RETRY)
(43,bad_area_nosemaphore:)
(44,fault & VM_FAULT_ERROR)
(45,address)
(46,return;)
(47,if (user_mode(regs)
(48,&info)
(49,vma)
(50,goto bad_area;)
(51,mm->mmap_sem)
(52,VM_EXEC)
(53,fault_address)
(54,user_mode(regs)
(55,VMALLOC_END)
(56,VM_GROWSDOWN)
(57,vma)
(58,info.si_addr = (void __user *)
(59,flags)
(60,flags)
(61,ret = handle_vmalloc_fault(address)
(62,tsk)
(63,tsk->thread)
(64,vma->vm_start)
(65,info.si_code = SEGV_MAPERR)
(66,info.si_signo = SIGBUS)
(67,goto out_of_memory;)
(68,VM_WRITE)
(69,VMALLOC_START)
(70,if (fault & VM_FAULT_RETRY)
(71,mm)
(72,tsk)
(73,goto bad_area;)
(74,(void __user *)
(75,VM_FAULT_MAJOR)
(76,if (write)
(77,if (address >= VMALLOC_START && address <= VMALLOC_END)
(78,fixup_exception(regs)
(79,!(vma->vm_flags & (VM_READ | VM_EXEC)
(80,flags |= FAULT_FLAG_WRITE)
(81,if ((fault & VM_FAULT_ERROR)
(82,if (unlikely(ret)
(83,)
(84,unlikely(ret)
(85,address)
(86,fault = handle_mm_fault(mm, vma, address, flags)
(87,flags)
(88,address)
(89,if (!(vma->vm_flags & (VM_READ | VM_EXEC)
(90,VM_FAULT_RETRY)
(91,cause_code == ((ECR_V_PROTV << 16)
(92,info)
(93,if (flags & FAULT_FLAG_ALLOW_RETRY)
(94,vma->vm_flags)
(95,goto good_area;)
(96,address)
(97,force_sig_info(SIGSEGV, &info, tsk)
(98,~FAULT_FLAG_ALLOW_RETRY)
(99,mm)
(100,force_sig_info(SIGBUS, &info, tsk)
(101,info.si_signo = SIGSEGV)
(102,flags)
(103,up_read(&mm->mmap_sem)
(104,ret)
(105,tsk)
(106,info.si_errno = 0)
(107,FAULT_FLAG_ALLOW_RETRY)
(108,)
(109,)
(110,goto bad_area_nosemaphore;)
(111,current)
(112,cause_code)
(113,return;)
(114,info.si_code = BUS_ADRERR)
(115,address)
(116,address >= VMALLOC_START && address <= VMALLOC_END)
(117,fault & VM_FAULT_MAJOR)
(118,handle_vmalloc_fault(address)
(119,goto bad_area;)
(120,unsigned long address)
(121,fault)
(122,if (user_mode(regs)
(123,up_read(&mm->mmap_sem)
(124,*vma = NULL)
(125,expand_stack(vma, address)
(126,SIGSEGV)
(127,vm_flags)
(128,tsk->thread.fault_address = address)
(129,FAULT_FLAG_USER)
(130,info)
(131,return;)
(132,flags)
(133,BUS_ADRERR)
(134,likely(!(fault & VM_FAULT_ERROR)
(135,fault)
(136,mm->mmap_sem)
(137,tsk->thread.fault_address)
(138,retry:)
(139,info.si_errno)
(140,die("Oops", regs, address, cause_code)
(141,0)
(142,info)
(143,down_read(&mm->mmap_sem)
(144,goto bad_area;)
(145,write)
(146,mm)
(147,fatal_signal_pending(current)
(148,mm)
(149,if (!(vma->vm_flags & VM_GROWSDOWN)
(150,!vma)
(151,fault & VM_FAULT_SIGBUS)
(152,!(vma->vm_flags & VM_WRITE)
(153,return;)
(154,regs)
(155,info.si_errno)
(156,vma->vm_flags & VM_WRITE)
(157,&mm->mmap_sem)
(158,VM_READ | VM_EXEC)
(159,FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE)
(160,void __user *)
(161,if (likely(!(fault & VM_FAULT_ERROR)
(162,mm)
(163,(void __user *)
(164,min_flt)
(165,NULL)
(166,vma)
(167,if (!(vma->vm_flags & VM_WRITE)
(168,address <= VMALLOC_END)
(169,fault)
(170,tsk->thread)
(171,address)
(172,if (expand_stack(vma, address)
(173,no_context:)
(174,in_atomic()
(175,info)
(176,si_code)
(177,user_mode(regs)
(178,mmap_sem)
(179,!(vma->vm_flags & VM_GROWSDOWN)
(180,regs)
(181,goto retry;)
(182,return;)
(183,fault & VM_FAULT_RETRY)
(184,current)
(185,)
(186,*mm = tsk->mm)
(187,*tsk = current)
(188,&mm->mmap_sem)
(189,tsk)
(190,void __user *)
(191,vm_start)
(192,address)
(193,mm)
(194,address)
(195,regs)
(196,mmap_sem)
(197,vma)
(198,goto do_sigbus;)
(199,address)
(200,fault & VM_FAULT_RETRY)
(201,mmap_sem)
(202,si_errno)
(203,tsk->thread.cause_code = cause_code)
(204,maj_flt)
(205,mm->mmap_sem)
(206,if (fault & VM_FAULT_MAJOR)
(207,vma->vm_start <= address)
(208,fault & VM_FAULT_ERROR)
(209,goto no_context;)
(210,SEGV_MAPERR)
(211,&mm->mmap_sem)
(212,)
(213,user_mode(regs)
(214,vma)
(215,si_code)
(216,if (vma->vm_start <= address)
(217,mm)
(218,mmap_sem)
(219,handle_mm_fault(mm, vma, address, flags)
(220,mm)
(221,ECR_C_PROTV_INST_FETCH)
(222,vma->vm_flags & (VM_READ | VM_EXEC)
(223,info)
(224,info.si_addr)
(225,RET)
(226,fault)
(227,tsk->min_flt)
(228,thread)
(229,flags)
(230,(ECR_V_PROTV << 16)
(231,tsk)
(232,vma)
(233,info.si_signo)
(234,FAULT_FLAG_TRIED)
(235,!(fault & VM_FAULT_RETRY)
(236,FAULT_FLAG_WRITE)
(237,if (unlikely(fatal_signal_pending(current)
(238,if (!user_mode(regs)
(239,si_addr)
(240,goto bad_area;)
(241,VM_FAULT_ERROR)
(242,si_signo)
(243,thread)
(244,flags |= FAULT_FLAG_USER)
(245,tsk)
(246,tsk->thread.cause_code = cause_code)
(247,thread)
(248,ECR_V_PROTV)
(249,mm->mmap_sem)
(250,tsk)
(251,vma)
(252,tsk->maj_flt++)
(253,ECR_V_PROTV << 16)
(254,info)
(255,VM_FAULT_RETRY)
(256,address >= VMALLOC_START)
(257,address)
(258,info.si_addr = (void __user *)
(259,struct pt_regs *regs)
(260,up_read(&mm->mmap_sem)
(261,flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE)
(262,fault)
(263,tsk->thread.fault_address = address)
(264,unsigned long cause_code)
(265,out_of_memory:)
(266,)
(267,user_mode(regs)
(268,info)
(269,mm->mmap_sem)
(270,vma->vm_flags)
(271,si_signo)
(272,tsk->thread.cause_code)
(273,fault_address)
(274,info.si_code = SEGV_ACCERR)
(275,flags)
(276,info.si_code)
(277,vma)
(278,FAULT_FLAG_KILLABLE)
(279,if (!vma)
(280,SIGBUS)
(281,if (user_mode(regs)
(282,(fault & VM_FAULT_ERROR)
(283,si_errno)
(284,bad_area:)
(285,if (fixup_exception(regs)
(286,in_atomic()
(287,info.si_signo)
(288,VM_READ)
(289,find_vma(mm, address)
(290,tsk)
(291,tsk)
(292,mmap_sem)
(293,!user_mode(regs)
(294,goto no_context;)
(295,fault)
(296,info.si_errno = 0)
(297,good_area:)
(298,do_sigbus:)
(299,)
(300,pagefault_out_of_memory()
(301,info)
(302,16)
(303,cause_code)
(304,if (fault & VM_FAULT_OOM)
(305,&mm->mmap_sem)
(306,vma = find_vma(mm, address)
(307,SEGV_ACCERR)
(308,)
(309,address)
(310,regs)
(311,if (user_mode(regs)
(312,flags & FAULT_FLAG_ALLOW_RETRY)
(313,mm->mmap_sem)
(314,info.si_code)
(315,unlikely(fatal_signal_pending(current)
(316,VM_FAULT_ERROR)
(317,up_read(&mm->mmap_sem)
(318,if (cause_code == ((ECR_V_PROTV << 16)
(319,mmap_sem)
(320,tsk->mm)
(321,tsk->thread)
(322,SIGBUS)
(323,tsk->maj_flt)
(324,0)
(325,if (in_atomic()
(326,tsk->thread.cause_code)
(327,tsk->thread)
(328,cause_code)
(329,fault)
(330,!(fault & VM_FAULT_ERROR)
(331,info)
(332,tsk->thread.fault_address)
(333,up_read(&mm->mmap_sem)
(334,regs)
(335,return;)
(336,si_code)
(337,cause_code)
(338,VM_FAULT_OOM)
(339,vma->vm_flags)
(340,)
(341,goto bad_area;)
(342,regs)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^