-----label-----
1
-----code-----
void do_page_fault(struct pt_regs *regs, int write, unsigned long address,
		   unsigned long cause_code)
{
	struct vm_area_struct *vma = NULL;
	struct task_struct *tsk = current;
	struct mm_struct *mm = tsk->mm;
	siginfo_t info;
	int fault, ret;
	unsigned int flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE;

	/*
	 * We fault-in kernel-space virtual memory on-demand. The
	 * 'reference' page table is init_mm.pgd.
	 *
	 * NOTE! We MUST NOT take any locks for this case. We may
	 * be in an interrupt or a critical region, and should
	 * only copy the information from the master page table,
	 * nothing more.
	 */
	if (address >= VMALLOC_START && address <= VMALLOC_END) {
		ret = handle_vmalloc_fault(address);
		if (unlikely(ret))
			goto bad_area_nosemaphore;
		else
			return;
	}

	info.si_code = SEGV_MAPERR;

	/*
	 * If we're in an interrupt or have no user
	 * context, we must not take the fault..
	 */
	if (in_atomic() || !mm)
		goto no_context;

	if (user_mode(regs))
		flags |= FAULT_FLAG_USER;
retry:
	down_read(&mm->mmap_sem);
	vma = find_vma(mm, address);
	if (!vma)
		goto bad_area;
	if (vma->vm_start <= address)
		goto good_area;
	if (!(vma->vm_flags & VM_GROWSDOWN))
		goto bad_area;
	if (expand_stack(vma, address))
		goto bad_area;

	/*
	 * Ok, we have a good vm_area for this memory access, so
	 * we can handle it..
	 */
good_area:
	info.si_code = SEGV_ACCERR;

	/* Handle protection violation, execute on heap or stack */

	if (cause_code == ((ECR_V_PROTV << 16) | ECR_C_PROTV_INST_FETCH))
		goto bad_area;

	if (write) {
		if (!(vma->vm_flags & VM_WRITE))
			goto bad_area;
		flags |= FAULT_FLAG_WRITE;
	} else {
		if (!(vma->vm_flags & (VM_READ | VM_EXEC)))
			goto bad_area;
	}

survive:
	/*
	 * If for any reason at all we couldn't handle the fault,
	 * make sure we exit gracefully rather than endlessly redo
	 * the fault.
	 */
	fault = handle_mm_fault(mm, vma, address, flags);

	/* If Pagefault was interrupted by SIGKILL, exit page fault "early" */
	if (unlikely(fatal_signal_pending(current))) {
		if ((fault & VM_FAULT_ERROR) && !(fault & VM_FAULT_RETRY))
			up_read(&mm->mmap_sem);
		if (user_mode(regs))
			return;
	}

	if (likely(!(fault & VM_FAULT_ERROR))) {
		if (flags & FAULT_FLAG_ALLOW_RETRY) {
			/* To avoid updating stats twice for retry case */
			if (fault & VM_FAULT_MAJOR)
				tsk->maj_flt++;
			else
				tsk->min_flt++;

			if (fault & VM_FAULT_RETRY) {
				flags &= ~FAULT_FLAG_ALLOW_RETRY;
				flags |= FAULT_FLAG_TRIED;
				goto retry;
			}
		}

		/* Fault Handled Gracefully */
		up_read(&mm->mmap_sem);
		return;
	}

	/* TBD: switch to pagefault_out_of_memory() */
	if (fault & VM_FAULT_OOM)
		goto out_of_memory;
	else if (fault & VM_FAULT_SIGBUS)
		goto do_sigbus;

	/* no man's land */
	BUG();

	/*
	 * Something tried to access memory that isn't in our memory map..
	 * Fix it, but check if it's kernel or user first..
	 */
bad_area:
	up_read(&mm->mmap_sem);

bad_area_nosemaphore:
	/* User mode accesses just cause a SIGSEGV */
	if (user_mode(regs)) {
		tsk->thread.fault_address = address;
		tsk->thread.cause_code = cause_code;
		info.si_signo = SIGSEGV;
		info.si_errno = 0;
		/* info.si_code has been set above */
		info.si_addr = (void __user *)address;
		force_sig_info(SIGSEGV, &info, tsk);
		return;
	}

no_context:
	/* Are we prepared to handle this kernel fault?
	 *
	 * (The kernel has valid exception-points in the source
	 *  when it acesses user-memory. When it fails in one
	 *  of those points, we find it in a table and do a jump
	 *  to some fixup code that loads an appropriate error
	 *  code)
	 */
	if (fixup_exception(regs))
		return;

	die("Oops", regs, address, cause_code);

out_of_memory:
	if (is_global_init(tsk)) {
		yield();
		goto survive;
	}
	up_read(&mm->mmap_sem);

	if (user_mode(regs))
		do_group_exit(SIGKILL);	/* This will never return */

	goto no_context;

do_sigbus:
	up_read(&mm->mmap_sem);

	if (!user_mode(regs))
		goto no_context;

	tsk->thread.fault_address = address;
	tsk->thread.cause_code = cause_code;
	info.si_signo = SIGBUS;
	info.si_errno = 0;
	info.si_code = BUS_ADRERR;
	info.si_addr = (void __user *)address;
	force_sig_info(SIGBUS, &info, tsk);
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
3,7
3,8
5,6
5,7
6,7
8,9
8,10
11,12
11,13
13,14
15,16
15,17
17,18
19,20
19,21
21,22
23,24
23,25
23,26
23,27
23,28
23,29
23,30
23,31
23,32
23,33
23,34
23,35
23,36
23,37
23,38
23,39
23,40
23,41
23,42
23,43
23,44
23,45
23,46
23,47
23,48
23,49
23,50
23,51
23,52
23,53
23,54
23,55
23,56
23,57
23,58
23,59
23,60
23,61
23,62
23,63
23,64
24,25
25,26
25,27
26,27
28,29
28,30
28,31
31,32
32,33
34,35
35,36
35,37
36,37
38,39
38,40
38,41
41,42
42,43
44,45
45,46
45,47
46,47
48,49
48,50
48,51
51,52
52,53
52,54
53,54
56,57
57,58
57,59
58,59
60,61
62,63
63,64
63,65
63,66
65,66
67,68
69,70
70,71
70,72
72,73
72,74
74,75
75,76
75,77
76,77
78,79
80,81
80,82
81,82
81,83
82,83
82,84
83,84
85,86
87,88
87,89
88,89
90,91
92,93
92,94
93,94
94,95
94,96
95,96
97,98
97,99
98,99
100,101
102,103
102,104
102,105
103,104
103,105
104,105
106,107
108,109
111,112
112,113
112,114
113,114
113,115
114,115
117,118
119,120
119,121
120,121
120,122
121,122
122,123
124,125
125,126
127,128
129,130
129,131
130,131
130,132
131,132
133,134
135,136
136,137
136,138
137,138
139,140
141,142
141,143
143,144
144,145
144,146
145,146
147,148
148,149
148,150
149,150
152,153
153,154
153,155
154,155
156,157
156,158
156,159
157,158
159,160
161,162
163,164
163,165
164,165
165,166
167,168
169,170
169,171
170,171
170,172
171,172
171,173
172,173
175,176
177,178
179,180
179,181
180,181
181,182
182,183
182,184
183,184
183,185
184,185
187,188
189,190
191,192
191,193
192,193
192,194
192,195
193,194
195,196
197,198
199,200
201,202
201,203
203,204
204,205
204,206
205,206
205,207
206,207
209,210
211,212
211,213
212,213
212,214
213,214
215,216
216,217
216,218
217,218
218,219
218,220
219,220
222,223
224,225
226,227
226,228
226,229
227,228
229,230
229,231
230,231
230,232
231,232
232,233
233,234
233,235
234,235
234,236
235,236
238,239
240,241
242,243
243,244
243,245
244,245
246,247
248,249
249,250
249,251
250,251
251,252
252,253
252,254
253,254
253,255
254,255
257,258
258,259
258,260
259,260
261,262
263,264
265,266
265,267
267,268
268,269
268,270
269,270
271,272
271,273
271,274
271,275
271,276
272,273
274,275
276,277
278,279
280,281
282,283
282,284
283,284
283,285
284,285
286,287
287,288
287,289
289,290
289,291
290,291
292,293
294,295
294,296
295,296
295,297
296,297
296,298
297,298
298,299
298,300
299,300
301,302
303,304
304,305
305,306
305,307
306,307
308,309
310,311
311,312
311,313
312,313
314,315
315,316
315,317
316,317
319,320
319,321
320,321
320,322
321,322
323,324
326,327
326,328
327,328
327,329
328,329
330,331
331,332
332,333
332,334
333,334
335,336
337,338
337,339
337,340
338,339
338,340
339,340
339,341
340,341
342,343
344,345
344,346
345,346
345,347
345,348
346,347
346,348
347,348
349,350
351,352
352,353
353,354
353,355
354,355
357,358
358,359
359,360
359,361
360,361
363,364
363,365
364,365
364,366
365,366
367,368
369,370
369,371
369,372
370,371
371,372
371,373
372,373
374,375
375,376
377,378
378,379
378,380
379,380
381,382
383,384
385,386
386,387
386,388
387,388
389,390
390,391
390,392
391,392
395,396
395,397
395,398
396,397
396,398
397,398
399,400
401,402
403,404
403,405
404,405
404,406
405,406
407,408
409,410
411,412
412,413
413,414
415,416
415,417
417,418
418,419
418,420
419,420
421,422
422,423
422,424
423,424
426,427
426,428
428,429
428,430
429,430
429,431
430,431
432,433
434,435
434,436
434,437
434,438
434,439
434,440
434,441
435,436
436,437
436,438
437,438
437,439
438,439
438,440
439,440
443,444
445,446
446,447
446,448
447,448
447,449
448,449
448,450
449,450
453,454
455,456
456,457
456,458
457,458
457,459
458,459
461,462
463,464
464,465
464,466
465,466
465,467
466,467
470,471
471,472
472,473
472,474
472,475
472,476
473,474
475,476
477,478
478,479
480,481
483,484
483,485
485,486
485,487
486,487
486,488
487,488
489,490
492,493
493,494
493,495
493,496
493,497
493,498
494,495
497,498
499,500
501,502
503,504
503,505
505,506
505,507
506,507
506,508
507,508
509,510
511,512
511,513
512,513
513,514
514,515
516,517
518,519
519,520
519,521
520,521
522,523
523,524
523,525
524,525
527,528
527,529
528,529
528,530
529,530
531,532
533,534
534,535
534,536
535,536
537,538
538,539
540,541
542,543
542,544
544,545
545,546
545,547
546,547
548,549
549,550
549,551
550,551
553,554
553,555
554,555
555,556
555,557
556,557
558,559
560,561
562,563
563,564
563,565
564,565
564,566
565,566
565,567
566,567
570,571
572,573
573,574
573,575
574,575
574,576
575,576
575,577
576,577
580,581
582,583
583,584
583,585
584,585
584,586
585,586
588,589
590,591
591,592
591,593
592,593
592,594
593,594
597,598
598,599
598,600
599,600
599,601
600,601
603,604
605,606
606,607
607,608
607,609
607,610
607,611
608,609
610,611
612,613
613,614
615,616
-----nextToken-----
2,4,7,9,10,12,14,16,18,20,22,27,29,30,33,37,39,40,43,47,49,50,54,55,59,61,64,66,68,71,73,77,79,84,86,89,91,96,99,101,105,107,109,110,115,116,118,123,126,128,132,134,138,140,142,146,150,151,155,158,160,162,166,168,173,174,176,178,185,186,188,190,194,196,198,200,202,207,208,210,214,220,221,223,225,228,236,237,239,241,245,247,255,256,260,262,264,266,270,273,275,277,279,281,285,288,291,293,300,302,307,309,313,317,318,322,324,325,329,334,336,341,343,348,350,355,356,361,362,366,368,373,376,380,382,384,388,392,393,394,398,400,402,406,408,410,414,416,420,424,425,427,431,433,440,441,442,444,450,451,452,454,459,460,462,467,468,469,474,476,479,481,482,484,488,490,491,495,496,498,500,502,504,508,510,515,517,521,525,526,530,532,536,539,541,543,547,551,552,557,559,561,567,568,569,571,577,578,579,581,586,587,589,594,595,596,601,602,604,609,611,614,616
-----computeFrom-----
75,76
75,77
81,82
81,83
82,83
82,84
87,88
87,89
94,95
94,96
112,113
112,114
120,121
120,122
136,137
136,138
153,154
153,155
170,171
170,172
182,183
182,184
204,205
204,206
212,213
212,214
216,217
216,218
218,219
218,220
233,234
233,235
243,244
243,245
252,253
252,254
258,259
258,260
268,269
268,270
296,297
296,298
298,299
298,300
305,306
305,307
332,333
332,334
339,340
339,341
346,347
346,348
364,365
364,366
371,372
371,373
378,379
378,380
396,397
396,398
404,405
404,406
436,437
436,438
446,447
446,448
456,457
456,458
464,465
464,466
563,564
563,565
573,574
573,575
583,584
583,585
591,592
591,593
598,599
598,600
-----guardedBy-----
89,101
341,380
343,376
-----guardedByNegation-----
398,406
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;GotoStatement;Name;ReturnStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;GotoStatement;Name;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;LabelStatement;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;GotoStatement;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;GotoStatement;Name;IfStatement;UnaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;GotoStatement;Name;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;GotoStatement;Name;LabelStatement;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;UnaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;GotoStatement;Name;IfStatement;IdExpression;Name;CompoundStatement;IfStatement;UnaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;GotoStatement;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;UnaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;GotoStatement;Name;LabelStatement;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;FunctionDeclarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Name;CompoundStatement;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;IfStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;GotoStatement;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ReturnStatement;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;GotoStatement;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;GotoStatement;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LabelStatement;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;LabelStatement;Name;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ProblemStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;LabelStatement;Name;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LabelStatement;Name;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;GotoStatement;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;GotoStatement;Name;LabelStatement;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;GotoStatement;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ProblemStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;
-----ast_node-----
void do_page_fault(struct pt_regs *regs, int write, unsigned long address,		   unsigned long cause_code){	struct vm_area_struct *vma = NULL;	struct task_struct *tsk = current;	struct mm_struct *mm = tsk->mm;	siginfo_t info;	int fault, ret;	unsigned int flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE;	/*	 * We fault-in kernel-space virtual memory on-demand. The	 * 'reference' page table is init_mm.pgd.	 *	 * NOTE! We MUST NOT take any locks for this case. We may	 * be in an interrupt or a critical region, and should	 * only copy the information from the master page table,	 * nothing more.	 */	if (address >= VMALLOC_START && address <= VMALLOC_END) {		ret = handle_vmalloc_fault(address);		if (unlikely(ret))			goto bad_area_nosemaphore;		else			return;	}	info.si_code = SEGV_MAPERR;	/*	 * If we're in an interrupt or have no user	 * context, we must not take the fault..	 */	if (in_atomic() || !mm)		goto no_context;	if (user_mode(regs))		flags |= FAULT_FLAG_USER;retry:	down_read(&mm->mmap_sem);	vma = find_vma(mm, address);	if (!vma)		goto bad_area;	if (vma->vm_start <= address)		goto good_area;	if (!(vma->vm_flags & VM_GROWSDOWN))		goto bad_area;	if (expand_stack(vma, address))		goto bad_area;	/*	 * Ok, we have a good vm_area for this memory access, so	 * we can handle it..	 */good_area:	info.si_code = SEGV_ACCERR;	/* Handle protection violation, execute on heap or stack */	if (cause_code == ((ECR_V_PROTV << 16) | ECR_C_PROTV_INST_FETCH))		goto bad_area;	if (write) {		if (!(vma->vm_flags & VM_WRITE))			goto bad_area;		flags |= FAULT_FLAG_WRITE;	} else {		if (!(vma->vm_flags & (VM_READ | VM_EXEC)))			goto bad_area;	}survive:	/*	 * If for any reason at all we couldn't handle the fault,	 * make sure we exit gracefully rather than endlessly redo	 * the fault.	 */	fault = handle_mm_fault(mm, vma, address, flags);	/* If Pagefault was interrupted by SIGKILL, exit page fault "early" */	if (unlikely(fatal_signal_pending(current))) {		if ((fault & VM_FAULT_ERROR) && !(fault & VM_FAULT_RETRY))			up_read(&mm->mmap_sem);		if (user_mode(regs))			return;	}	if (likely(!(fault & VM_FAULT_ERROR))) {		if (flags & FAULT_FLAG_ALLOW_RETRY) {			/* To avoid updating stats twice for retry case */			if (fault & VM_FAULT_MAJOR)				tsk->maj_flt++;			else				tsk->min_flt++;			if (fault & VM_FAULT_RETRY) {				flags &= ~FAULT_FLAG_ALLOW_RETRY;				flags |= FAULT_FLAG_TRIED;				goto retry;			}		}		/* Fault Handled Gracefully */		up_read(&mm->mmap_sem);		return;	}	/* TBD: switch to pagefault_out_of_memory() */	if (fault & VM_FAULT_OOM)		goto out_of_memory;	else if (fault & VM_FAULT_SIGBUS)		goto do_sigbus;	/* no man's land */	BUG();	/*	 * Something tried to access memory that isn't in our memory map..	 * Fix it, but check if it's kernel or user first..	 */bad_area:	up_read(&mm->mmap_sem);bad_area_nosemaphore:	/* User mode accesses just cause a SIGSEGV */	if (user_mode(regs)) {		tsk->thread.fault_address = address;		tsk->thread.cause_code = cause_code;		info.si_signo = SIGSEGV;		info.si_errno = 0;		/* info.si_code has been set above */		info.si_addr = (void __user *)address;		force_sig_info(SIGSEGV, &info, tsk);		return;	}no_context:	/* Are we prepared to handle this kernel fault?	 *	 * (The kernel has valid exception-points in the source	 *  when it acesses user-memory. When it fails in one	 *  of those points, we find it in a table and do a jump	 *  to some fixup code that loads an appropriate error	 *  code)	 */	if (fixup_exception(regs))		return;	die("Oops", regs, address, cause_code);out_of_memory:	if (is_global_init(tsk)) {		yield();		goto survive;	}	up_read(&mm->mmap_sem);	if (user_mode(regs))		do_group_exit(SIGKILL);	/* This will never return */	goto no_context;do_sigbus:	up_read(&mm->mmap_sem);	if (!user_mode(regs))		goto no_context;	tsk->thread.fault_address = address;	tsk->thread.cause_code = cause_code;	info.si_signo = SIGBUS;	info.si_errno = 0;	info.si_code = BUS_ADRERR;	info.si_addr = (void __user *)address;	force_sig_info(SIGBUS, &info, tsk);}
void
do_page_fault(struct pt_regs *regs, int write, unsigned long address,		   unsigned long cause_code)
do_page_fault
struct pt_regs *regs
struct pt_regs
pt_regs
*regs
*
regs
int write
int
write
write
unsigned long address
unsigned long
address
address
unsigned long cause_code
unsigned long
cause_code
cause_code
{	struct vm_area_struct *vma = NULL;	struct task_struct *tsk = current;	struct mm_struct *mm = tsk->mm;	siginfo_t info;	int fault, ret;	unsigned int flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE;	/*	 * We fault-in kernel-space virtual memory on-demand. The	 * 'reference' page table is init_mm.pgd.	 *	 * NOTE! We MUST NOT take any locks for this case. We may	 * be in an interrupt or a critical region, and should	 * only copy the information from the master page table,	 * nothing more.	 */	if (address >= VMALLOC_START && address <= VMALLOC_END) {		ret = handle_vmalloc_fault(address);		if (unlikely(ret))			goto bad_area_nosemaphore;		else			return;	}	info.si_code = SEGV_MAPERR;	/*	 * If we're in an interrupt or have no user	 * context, we must not take the fault..	 */	if (in_atomic() || !mm)		goto no_context;	if (user_mode(regs))		flags |= FAULT_FLAG_USER;retry:	down_read(&mm->mmap_sem);	vma = find_vma(mm, address);	if (!vma)		goto bad_area;	if (vma->vm_start <= address)		goto good_area;	if (!(vma->vm_flags & VM_GROWSDOWN))		goto bad_area;	if (expand_stack(vma, address))		goto bad_area;	/*	 * Ok, we have a good vm_area for this memory access, so	 * we can handle it..	 */good_area:	info.si_code = SEGV_ACCERR;	/* Handle protection violation, execute on heap or stack */	if (cause_code == ((ECR_V_PROTV << 16) | ECR_C_PROTV_INST_FETCH))		goto bad_area;	if (write) {		if (!(vma->vm_flags & VM_WRITE))			goto bad_area;		flags |= FAULT_FLAG_WRITE;	} else {		if (!(vma->vm_flags & (VM_READ | VM_EXEC)))			goto bad_area;	}survive:	/*	 * If for any reason at all we couldn't handle the fault,	 * make sure we exit gracefully rather than endlessly redo	 * the fault.	 */	fault = handle_mm_fault(mm, vma, address, flags);	/* If Pagefault was interrupted by SIGKILL, exit page fault "early" */	if (unlikely(fatal_signal_pending(current))) {		if ((fault & VM_FAULT_ERROR) && !(fault & VM_FAULT_RETRY))			up_read(&mm->mmap_sem);		if (user_mode(regs))			return;	}	if (likely(!(fault & VM_FAULT_ERROR))) {		if (flags & FAULT_FLAG_ALLOW_RETRY) {			/* To avoid updating stats twice for retry case */			if (fault & VM_FAULT_MAJOR)				tsk->maj_flt++;			else				tsk->min_flt++;			if (fault & VM_FAULT_RETRY) {				flags &= ~FAULT_FLAG_ALLOW_RETRY;				flags |= FAULT_FLAG_TRIED;				goto retry;			}		}		/* Fault Handled Gracefully */		up_read(&mm->mmap_sem);		return;	}	/* TBD: switch to pagefault_out_of_memory() */	if (fault & VM_FAULT_OOM)		goto out_of_memory;	else if (fault & VM_FAULT_SIGBUS)		goto do_sigbus;	/* no man's land */	BUG();	/*	 * Something tried to access memory that isn't in our memory map..	 * Fix it, but check if it's kernel or user first..	 */bad_area:	up_read(&mm->mmap_sem);bad_area_nosemaphore:	/* User mode accesses just cause a SIGSEGV */	if (user_mode(regs)) {		tsk->thread.fault_address = address;		tsk->thread.cause_code = cause_code;		info.si_signo = SIGSEGV;		info.si_errno = 0;		/* info.si_code has been set above */		info.si_addr = (void __user *)address;		force_sig_info(SIGSEGV, &info, tsk);		return;	}no_context:	/* Are we prepared to handle this kernel fault?	 *	 * (The kernel has valid exception-points in the source	 *  when it acesses user-memory. When it fails in one	 *  of those points, we find it in a table and do a jump	 *  to some fixup code that loads an appropriate error	 *  code)	 */	if (fixup_exception(regs))		return;	die("Oops", regs, address, cause_code);out_of_memory:	if (is_global_init(tsk)) {		yield();		goto survive;	}	up_read(&mm->mmap_sem);	if (user_mode(regs))		do_group_exit(SIGKILL);	/* This will never return */	goto no_context;do_sigbus:	up_read(&mm->mmap_sem);	if (!user_mode(regs))		goto no_context;	tsk->thread.fault_address = address;	tsk->thread.cause_code = cause_code;	info.si_signo = SIGBUS;	info.si_errno = 0;	info.si_code = BUS_ADRERR;	info.si_addr = (void __user *)address;	force_sig_info(SIGBUS, &info, tsk);}
struct vm_area_struct *vma = NULL;
struct vm_area_struct *vma = NULL;
struct vm_area_struct
vm_area_struct
*vma = NULL
*
vma
= NULL
NULL
NULL
struct task_struct *tsk = current;
struct task_struct *tsk = current;
struct task_struct
task_struct
*tsk = current
*
tsk
= current
current
current
struct mm_struct *mm = tsk->mm;
struct mm_struct *mm = tsk->mm;
struct mm_struct
mm_struct
*mm = tsk->mm
*
mm
= tsk->mm
tsk->mm
tsk
tsk
mm
siginfo_t info;
siginfo_t info;
siginfo_t
siginfo_t
info
info
int fault, ret;
int fault, ret;
int
fault
fault
ret
ret
unsigned int flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE;
unsigned int flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE;
unsigned int
flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE
flags
= FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE
FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE
FAULT_FLAG_ALLOW_RETRY
FAULT_FLAG_ALLOW_RETRY
FAULT_FLAG_KILLABLE
FAULT_FLAG_KILLABLE
if (address >= VMALLOC_START && address <= VMALLOC_END) {		ret = handle_vmalloc_fault(address);		if (unlikely(ret))			goto bad_area_nosemaphore;		else			return;	}
address >= VMALLOC_START && address <= VMALLOC_END
address >= VMALLOC_START
address
address
VMALLOC_START
VMALLOC_START
address <= VMALLOC_END
address
address
VMALLOC_END
VMALLOC_END
{		ret = handle_vmalloc_fault(address);		if (unlikely(ret))			goto bad_area_nosemaphore;		else			return;	}
ret = handle_vmalloc_fault(address);
ret = handle_vmalloc_fault(address)
ret
ret
handle_vmalloc_fault(address)
handle_vmalloc_fault
handle_vmalloc_fault
address
address
if (unlikely(ret))			goto bad_area_nosemaphore;		else			return;
unlikely(ret)
unlikely
unlikely
ret
ret
goto bad_area_nosemaphore;
bad_area_nosemaphore
return;
info.si_code = SEGV_MAPERR;
info.si_code = SEGV_MAPERR
info.si_code
info
info
si_code
SEGV_MAPERR
SEGV_MAPERR
if (in_atomic() || !mm)		goto no_context;
in_atomic() || !mm
in_atomic()
in_atomic
in_atomic
!mm
mm
mm
goto no_context;
no_context
if (user_mode(regs))		flags |= FAULT_FLAG_USER;
user_mode(regs)
user_mode
user_mode
regs
regs
flags |= FAULT_FLAG_USER;
flags |= FAULT_FLAG_USER
flags
flags
FAULT_FLAG_USER
FAULT_FLAG_USER
retry:	down_read(&mm->mmap_sem);
retry
down_read(&mm->mmap_sem);
down_read(&mm->mmap_sem)
down_read
down_read
&mm->mmap_sem
mm->mmap_sem
mm
mm
mmap_sem
vma = find_vma(mm, address);
vma = find_vma(mm, address)
vma
vma
find_vma(mm, address)
find_vma
find_vma
mm
mm
address
address
if (!vma)		goto bad_area;
!vma
vma
vma
goto bad_area;
bad_area
if (vma->vm_start <= address)		goto good_area;
vma->vm_start <= address
vma->vm_start
vma
vma
vm_start
address
address
goto good_area;
good_area
if (!(vma->vm_flags & VM_GROWSDOWN))		goto bad_area;
!(vma->vm_flags & VM_GROWSDOWN)
(vma->vm_flags & VM_GROWSDOWN)
vma->vm_flags & VM_GROWSDOWN
vma->vm_flags
vma
vma
vm_flags
VM_GROWSDOWN
VM_GROWSDOWN
goto bad_area;
bad_area
if (expand_stack(vma, address))		goto bad_area;
expand_stack(vma, address)
expand_stack
expand_stack
vma
vma
address
address
goto bad_area;
bad_area
good_area:	info.si_code = SEGV_ACCERR;
good_area
info.si_code = SEGV_ACCERR;
info.si_code = SEGV_ACCERR
info.si_code
info
info
si_code
SEGV_ACCERR
SEGV_ACCERR
if (cause_code == ((ECR_V_PROTV << 16) | ECR_C_PROTV_INST_FETCH))		goto bad_area;
cause_code == ((ECR_V_PROTV << 16) | ECR_C_PROTV_INST_FETCH)
cause_code
cause_code
((ECR_V_PROTV << 16) | ECR_C_PROTV_INST_FETCH)
(ECR_V_PROTV << 16) | ECR_C_PROTV_INST_FETCH
(ECR_V_PROTV << 16)
ECR_V_PROTV << 16
ECR_V_PROTV
ECR_V_PROTV
16
ECR_C_PROTV_INST_FETCH
ECR_C_PROTV_INST_FETCH
goto bad_area;
bad_area
if (write) {		if (!(vma->vm_flags & VM_WRITE))			goto bad_area;		flags |= FAULT_FLAG_WRITE;	} else {		if (!(vma->vm_flags & (VM_READ | VM_EXEC)))			goto bad_area;	}
write
write
{		if (!(vma->vm_flags & VM_WRITE))			goto bad_area;		flags |= FAULT_FLAG_WRITE;	}
if (!(vma->vm_flags & VM_WRITE))			goto bad_area;
!(vma->vm_flags & VM_WRITE)
(vma->vm_flags & VM_WRITE)
vma->vm_flags & VM_WRITE
vma->vm_flags
vma
vma
vm_flags
VM_WRITE
VM_WRITE
goto bad_area;
bad_area
flags |= FAULT_FLAG_WRITE;
flags |= FAULT_FLAG_WRITE
flags
flags
FAULT_FLAG_WRITE
FAULT_FLAG_WRITE
{		if (!(vma->vm_flags & (VM_READ | VM_EXEC)))			goto bad_area;	}
if (!(vma->vm_flags & (VM_READ | VM_EXEC)))			goto bad_area;
!(vma->vm_flags & (VM_READ | VM_EXEC))
(vma->vm_flags & (VM_READ | VM_EXEC))
vma->vm_flags & (VM_READ | VM_EXEC)
vma->vm_flags
vma
vma
vm_flags
(VM_READ | VM_EXEC)
VM_READ | VM_EXEC
VM_READ
VM_READ
VM_EXEC
VM_EXEC
goto bad_area;
bad_area
survive:	/*	 * If for any reason at all we couldn't handle the fault,	 * make sure we exit gracefully rather than endlessly redo	 * the fault.	 */	fault = handle_mm_fault(mm, vma, address, flags);
survive
fault = handle_mm_fault(mm, vma, address, flags);
fault = handle_mm_fault(mm, vma, address, flags)
fault
fault
handle_mm_fault(mm, vma, address, flags)
handle_mm_fault
handle_mm_fault
mm
mm
vma
vma
address
address
flags
flags
if (unlikely(fatal_signal_pending(current))) {		if ((fault & VM_FAULT_ERROR) && !(fault & VM_FAULT_RETRY))			up_read(&mm->mmap_sem);		if (user_mode(regs))			return;	}
unlikely(fatal_signal_pending(current))
unlikely
unlikely
(fatal_signal_pending(current))
fatal_signal_pending(current)
fatal_signal_pending
current
current
current


{		if ((fault & VM_FAULT_ERROR) && !(fault & VM_FAULT_RETRY))			up_read(&mm->mmap_sem);		if (user_mode(regs))			return;	}
if ((fault & VM_FAULT_ERROR) && !(fault & VM_FAULT_RETRY))			up_read(&mm->mmap_sem);
(fault & VM_FAULT_ERROR) && !(fault & VM_FAULT_RETRY)
(fault & VM_FAULT_ERROR)
fault & VM_FAULT_ERROR
fault
fault
VM_FAULT_ERROR
VM_FAULT_ERROR
!(fault & VM_FAULT_RETRY)
(fault & VM_FAULT_RETRY)
fault & VM_FAULT_RETRY
fault
fault
VM_FAULT_RETRY
VM_FAULT_RETRY
up_read(&mm->mmap_sem);
up_read(&mm->mmap_sem)
up_read
up_read
&mm->mmap_sem
mm->mmap_sem
mm
mm
mmap_sem
if (user_mode(regs))			return;
user_mode(regs)
user_mode
user_mode
regs
regs
return;
if (likely(!(fault & VM_FAULT_ERROR))) {		if (flags & FAULT_FLAG_ALLOW_RETRY) {			/* To avoid updating stats twice for retry case */			if (fault & VM_FAULT_MAJOR)				tsk->maj_flt++;			else				tsk->min_flt++;			if (fault & VM_FAULT_RETRY) {				flags &= ~FAULT_FLAG_ALLOW_RETRY;				flags |= FAULT_FLAG_TRIED;				goto retry;			}		}		/* Fault Handled Gracefully */		up_read(&mm->mmap_sem);		return;	}
likely(!(fault & VM_FAULT_ERROR))
likely
likely
!(fault & VM_FAULT_ERROR)
(fault & VM_FAULT_ERROR)
fault & VM_FAULT_ERROR
fault
fault
VM_FAULT_ERROR
VM_FAULT_ERROR
{		if (flags & FAULT_FLAG_ALLOW_RETRY) {			/* To avoid updating stats twice for retry case */			if (fault & VM_FAULT_MAJOR)				tsk->maj_flt++;			else				tsk->min_flt++;			if (fault & VM_FAULT_RETRY) {				flags &= ~FAULT_FLAG_ALLOW_RETRY;				flags |= FAULT_FLAG_TRIED;				goto retry;			}		}		/* Fault Handled Gracefully */		up_read(&mm->mmap_sem);		return;	}
if (flags & FAULT_FLAG_ALLOW_RETRY) {			/* To avoid updating stats twice for retry case */			if (fault & VM_FAULT_MAJOR)				tsk->maj_flt++;			else				tsk->min_flt++;			if (fault & VM_FAULT_RETRY) {				flags &= ~FAULT_FLAG_ALLOW_RETRY;				flags |= FAULT_FLAG_TRIED;				goto retry;			}		}
flags & FAULT_FLAG_ALLOW_RETRY
flags
flags
FAULT_FLAG_ALLOW_RETRY
FAULT_FLAG_ALLOW_RETRY
{			/* To avoid updating stats twice for retry case */			if (fault & VM_FAULT_MAJOR)				tsk->maj_flt++;			else				tsk->min_flt++;			if (fault & VM_FAULT_RETRY) {				flags &= ~FAULT_FLAG_ALLOW_RETRY;				flags |= FAULT_FLAG_TRIED;				goto retry;			}		}
if (fault & VM_FAULT_MAJOR)				tsk->maj_flt++;			else				tsk->min_flt++;
fault & VM_FAULT_MAJOR
fault
fault
VM_FAULT_MAJOR
VM_FAULT_MAJOR
tsk->maj_flt++;
tsk->maj_flt++
tsk->maj_flt
tsk
tsk
maj_flt
tsk->min_flt++;
tsk->min_flt++
tsk->min_flt
tsk
tsk
min_flt
if (fault & VM_FAULT_RETRY) {				flags &= ~FAULT_FLAG_ALLOW_RETRY;				flags |= FAULT_FLAG_TRIED;				goto retry;			}
fault & VM_FAULT_RETRY
fault
fault
VM_FAULT_RETRY
VM_FAULT_RETRY
{				flags &= ~FAULT_FLAG_ALLOW_RETRY;				flags |= FAULT_FLAG_TRIED;				goto retry;			}
flags &= ~FAULT_FLAG_ALLOW_RETRY;
flags &= ~FAULT_FLAG_ALLOW_RETRY
flags
flags
~FAULT_FLAG_ALLOW_RETRY
FAULT_FLAG_ALLOW_RETRY
FAULT_FLAG_ALLOW_RETRY
flags |= FAULT_FLAG_TRIED;
flags |= FAULT_FLAG_TRIED
flags
flags
FAULT_FLAG_TRIED
FAULT_FLAG_TRIED
goto retry;
retry
up_read(&mm->mmap_sem);
up_read(&mm->mmap_sem)
up_read
up_read
&mm->mmap_sem
mm->mmap_sem
mm
mm
mmap_sem
return;
if (fault & VM_FAULT_OOM)		goto out_of_memory;	else if (fault & VM_FAULT_SIGBUS)		goto do_sigbus;
fault & VM_FAULT_OOM
fault
fault
VM_FAULT_OOM
VM_FAULT_OOM
goto out_of_memory;
out_of_memory
if (fault & VM_FAULT_SIGBUS)		goto do_sigbus;
fault & VM_FAULT_SIGBUS
fault
fault
VM_FAULT_SIGBUS
VM_FAULT_SIGBUS
goto do_sigbus;
do_sigbus
BUG();
BUG()
BUG
BUG
bad_area:	up_read(&mm->mmap_sem);
bad_area
up_read(&mm->mmap_sem);
up_read(&mm->mmap_sem)
up_read
up_read
&mm->mmap_sem
mm->mmap_sem
mm
mm
mmap_sem
bad_area_nosemaphore:	/* User mode accesses just cause a SIGSEGV */	if (user_mode(regs)) {		tsk->thread.fault_address = address;		tsk->thread.cause_code = cause_code;		info.si_signo = SIGSEGV;		info.si_errno = 0;		/* info.si_code has been set above */		info.si_addr = (void __user *)address;		force_sig_info(SIGSEGV, &info, tsk);		return;	}
bad_area_nosemaphore
if (user_mode(regs)) {		tsk->thread.fault_address = address;		tsk->thread.cause_code = cause_code;		info.si_signo = SIGSEGV;		info.si_errno = 0;		/* info.si_code has been set above */		info.si_addr = (void __user *)address;		force_sig_info(SIGSEGV, &info, tsk);		return;	}
user_mode(regs)
user_mode
user_mode
regs
regs
{		tsk->thread.fault_address = address;		tsk->thread.cause_code = cause_code;		info.si_signo = SIGSEGV;		info.si_errno = 0;		/* info.si_code has been set above */		info.si_addr = (void __user *)address;		force_sig_info(SIGSEGV, &info, tsk);		return;	}
tsk->thread.fault_address = address;
tsk->thread.fault_address = address
tsk->thread.fault_address
tsk->thread
tsk
tsk
thread
fault_address
address
address
tsk->thread.cause_code = cause_code;
tsk->thread.cause_code = cause_code
tsk->thread.cause_code
tsk->thread
tsk
tsk
thread
cause_code
cause_code
cause_code
info.si_signo = SIGSEGV;
info.si_signo = SIGSEGV
info.si_signo
info
info
si_signo
SIGSEGV
SIGSEGV
info.si_errno = 0;
info.si_errno = 0
info.si_errno
info
info
si_errno
0
info.si_addr = (void __user *)address;
force_sig_info(SIGSEGV, &info, tsk);
force_sig_info(SIGSEGV, &info, tsk)
force_sig_info
force_sig_info
SIGSEGV
SIGSEGV
&info
info
info
tsk
tsk
return;
no_context:	/* Are we prepared to handle this kernel fault?	 *	 * (The kernel has valid exception-points in the source	 *  when it acesses user-memory. When it fails in one	 *  of those points, we find it in a table and do a jump	 *  to some fixup code that loads an appropriate error	 *  code)	 */	if (fixup_exception(regs))		return;
no_context
if (fixup_exception(regs))		return;
fixup_exception(regs)
fixup_exception
fixup_exception
regs
regs
return;
die("Oops", regs, address, cause_code);
die("Oops", regs, address, cause_code)
die
die
"Oops"
regs
regs
address
address
cause_code
cause_code
out_of_memory:	if (is_global_init(tsk)) {		yield();		goto survive;	}
out_of_memory
if (is_global_init(tsk)) {		yield();		goto survive;	}
is_global_init(tsk)
is_global_init
is_global_init
tsk
tsk
{		yield();		goto survive;	}
yield();
yield()
yield
yield
goto survive;
survive
up_read(&mm->mmap_sem);
up_read(&mm->mmap_sem)
up_read
up_read
&mm->mmap_sem
mm->mmap_sem
mm
mm
mmap_sem
if (user_mode(regs))		do_group_exit(SIGKILL);
user_mode(regs)
user_mode
user_mode
regs
regs
do_group_exit(SIGKILL);
do_group_exit(SIGKILL);
do_group_exit
do_group_exit
(SIGKILL)
SIGKILL
SIGKILL
goto no_context;
no_context
do_sigbus:	up_read(&mm->mmap_sem);
do_sigbus
up_read(&mm->mmap_sem);
up_read(&mm->mmap_sem)
up_read
up_read
&mm->mmap_sem
mm->mmap_sem
mm
mm
mmap_sem
if (!user_mode(regs))		goto no_context;
!user_mode(regs)
user_mode(regs)
user_mode
user_mode
regs
regs
goto no_context;
no_context
tsk->thread.fault_address = address;
tsk->thread.fault_address = address
tsk->thread.fault_address
tsk->thread
tsk
tsk
thread
fault_address
address
address
tsk->thread.cause_code = cause_code;
tsk->thread.cause_code = cause_code
tsk->thread.cause_code
tsk->thread
tsk
tsk
thread
cause_code
cause_code
cause_code
info.si_signo = SIGBUS;
info.si_signo = SIGBUS
info.si_signo
info
info
si_signo
SIGBUS
SIGBUS
info.si_errno = 0;
info.si_errno = 0
info.si_errno
info
info
si_errno
0
info.si_code = BUS_ADRERR;
info.si_code = BUS_ADRERR
info.si_code
info
info
si_code
BUS_ADRERR
BUS_ADRERR
info.si_addr = (void __user *)address;
force_sig_info(SIGBUS, &info, tsk);
force_sig_info(SIGBUS, &info, tsk)
force_sig_info
force_sig_info
SIGBUS
SIGBUS
&info
info
info
tsk
tsk
-----joern-----
(22,139,0)
(99,331,0)
(294,284,0)
(278,111,0)
(227,27,0)
(110,263,0)
(42,255,0)
(303,121,0)
(241,144,0)
(327,256,0)
(110,33,0)
(52,95,0)
(316,32,0)
(81,312,0)
(333,68,0)
(203,282,0)
(19,243,0)
(115,256,0)
(17,114,0)
(12,338,0)
(221,296,0)
(207,172,0)
(184,228,0)
(26,256,0)
(68,277,0)
(261,13,0)
(1,148,0)
(109,299,0)
(250,116,0)
(31,297,0)
(208,234,0)
(202,111,0)
(328,141,0)
(181,275,0)
(151,285,0)
(197,205,0)
(28,128,0)
(10,256,0)
(188,254,0)
(27,227,0)
(139,22,0)
(128,166,0)
(24,165,0)
(178,236,0)
(158,101,0)
(257,277,0)
(222,256,0)
(84,69,0)
(116,332,0)
(170,221,0)
(122,101,0)
(96,296,0)
(19,87,0)
(14,256,0)
(217,211,0)
(280,63,0)
(94,67,0)
(227,141,0)
(141,121,0)
(315,298,0)
(263,131,0)
(135,14,0)
(177,93,0)
(296,131,0)
(285,55,0)
(272,249,0)
(29,7,0)
(319,257,0)
(37,44,0)
(189,72,0)
(329,256,0)
(298,94,0)
(126,275,0)
(263,110,0)
(305,101,0)
(251,203,0)
(4,255,0)
(101,158,0)
(259,249,0)
(72,189,0)
(249,305,0)
(185,99,0)
(179,249,0)
(51,261,0)
(307,154,0)
(116,211,0)
(66,236,0)
(171,256,0)
(59,303,0)
(41,305,0)
(128,125,0)
(214,7,0)
(102,256,0)
(290,263,0)
(228,121,0)
(187,326,0)
(104,275,0)
(211,43,0)
(265,249,0)
(309,131,0)
(322,282,0)
(98,110,0)
(206,256,0)
(314,256,0)
(255,42,0)
(269,259,0)
(9,100,0)
(162,44,0)
(166,256,0)
(265,205,0)
(97,256,0)
(78,145,0)
(257,319,0)
(62,304,0)
(265,101,0)
(186,245,0)
(158,131,0)
(81,50,0)
(83,316,0)
(305,205,0)
(261,101,0)
(63,172,0)
(249,256,0)
(35,69,0)
(57,3,0)
(46,141,0)
(313,265,0)
(143,5,0)
(60,167,0)
(70,276,0)
(111,169,0)
(300,182,0)
(237,256,0)
(236,101,0)
(172,63,0)
(165,79,0)
(77,245,0)
(120,256,0)
(211,256,0)
(209,131,0)
(299,101,0)
(277,256,0)
(265,125,0)
(219,93,0)
(71,256,0)
(141,227,0)
(347,305,0)
(97,43,0)
(265,166,0)
(192,193,0)
(348,79,0)
(182,256,0)
(281,43,0)
(265,275,0)
(189,247,0)
(297,256,0)
(2,287,0)
(288,268,0)
(128,85,0)
(156,256,0)
(125,275,0)
(175,241,0)
(82,345,0)
(3,121,0)
(268,121,0)
(295,42,0)
(248,326,0)
(33,55,0)
(337,129,0)
(53,242,0)
(242,285,0)
(69,131,0)
(243,19,0)
(91,256,0)
(212,129,0)
(299,31,0)
(161,68,0)
(8,265,0)
(252,256,0)
(123,304,0)
(75,172,0)
(107,256,0)
(99,101,0)
(343,128,0)
(274,256,0)
(134,122,0)
(183,341,0)
(223,228,0)
(50,124,0)
(93,177,0)
(255,131,0)
(260,249,0)
(25,124,0)
(238,256,0)
(326,131,0)
(136,261,0)
(129,85,0)
(245,77,0)
(201,256,0)
(234,245,0)
(279,137,0)
(64,272,0)
(292,326,0)
(31,299,0)
(25,13,0)
(81,200,0)
(21,38,0)
(119,154,0)
(7,249,0)
(233,7,0)
(36,148,0)
(311,177,0)
(281,55,0)
(195,254,0)
(169,55,0)
(44,272,0)
(224,256,0)
(338,302,0)
(259,189,0)
(38,281,0)
(298,101,0)
(282,270,0)
(310,256,0)
(15,299,0)
(296,55,0)
(193,144,0)
(265,102,0)
(65,265,0)
(275,166,0)
(34,256,0)
(287,240,0)
(346,331,0)
(63,280,0)
(190,239,0)
(231,197,0)
(74,177,0)
(121,256,0)
(317,256,0)
(308,268,0)
(253,241,0)
(306,263,0)
(291,33,0)
(183,256,0)
(154,106,0)
(219,268,0)
(340,281,0)
(81,160,0)
(226,55,0)
(213,256,0)
(56,145,0)
(346,256,0)
(286,280,0)
(142,125,0)
(58,152,0)
(128,275,0)
(174,255,0)
(324,345,0)
(126,128,0)
(305,249,0)
(140,265,0)
(265,128,0)
(112,131,0)
(166,254,0)
(276,69,0)
(33,205,0)
(67,256,0)
(214,205,0)
(330,282,0)
(289,102,0)
(150,316,0)
(145,56,0)
(196,112,0)
(122,229,0)
(16,256,0)
(180,332,0)
(247,189,0)
(147,259,0)
(145,205,0)
(13,25,0)
(11,99,0)
(229,339,0)
(167,144,0)
(79,256,0)
(302,256,0)
(80,97,0)
(5,144,0)
(94,298,0)
(241,175,0)
(318,256,0)
(38,112,0)
(81,226,0)
(232,121,0)
(280,43,0)
(234,249,0)
(108,165,0)
(112,38,0)
(125,321,0)
(176,287,0)
(138,199,0)
(95,205,0)
(0,124,0)
(341,183,0)
(129,166,0)
(163,239,0)
(341,236,0)
(235,125,0)
(297,31,0)
(155,243,0)
(272,44,0)
(47,257,0)
(132,131,0)
(106,95,0)
(126,125,0)
(342,300,0)
(13,261,0)
(88,242,0)
(268,219,0)
(218,179,0)
(236,341,0)
(265,121,0)
(129,125,0)
(344,137,0)
(169,145,0)
(54,214,0)
(254,166,0)
(325,256,0)
(69,276,0)
(276,34,0)
(127,139,0)
(264,166,0)
(191,321,0)
(157,158,0)
(293,122,0)
(48,272,0)
(103,85,0)
(301,332,0)
(76,296,0)
(345,14,0)
(87,19,0)
(105,256,0)
(304,121,0)
(131,256,0)
(129,128,0)
(262,234,0)
(189,259,0)
(95,106,0)
(117,298,0)
(145,169,0)
(266,97,0)
(34,205,0)
(230,112,0)
(246,309,0)
(128,128,0)
(332,131,0)
(239,114,0)
(331,346,0)
(7,214,0)
(296,221,0)
(320,32,0)
(323,300,0)
(273,126,0)
(215,158,0)
(126,166,0)
(100,144,0)
(331,99,0)
(240,287,0)
(23,256,0)
(204,95,0)
(118,247,0)
(73,3,0)
(40,256,0)
(164,30,0)
(245,234,0)
(334,126,0)
(216,256,0)
(129,275,0)
(114,55,0)
(277,257,0)
(90,303,0)
(125,166,0)
(125,128,0)
(173,34,0)
(225,302,0)
(257,205,0)
(326,292,0)
(106,154,0)
(336,256,0)
(93,219,0)
(152,144,0)
(44,37,0)
(92,256,0)
(244,256,0)
(197,249,0)
(86,284,0)
(271,102,0)
(229,122,0)
(49,182,0)
(149,101,0)
(32,256,0)
(332,116,0)
(154,205,0)
(101,256,0)
(168,197,0)
(133,97,0)
(177,121,0)
(97,144,0)
(89,247,0)
(339,229,0)
(6,256,0)
(121,265,0)
(255,256,0)
(113,338,0)
(130,97,0)
(97,205,0)
(67,94,0)
(198,322,0)
(322,205,0)
(282,322,0)
(243,101,0)
(220,63,0)
(18,270,0)
(287,131,0)
(286,14,1)
(14,135,1)
(239,190,1)
(185,20,1)
(235,142,1)
(131,209,1)
(332,131,1)
(302,225,1)
(15,109,1)
(96,221,1)
(129,128,1)
(220,172,1)
(76,169,1)
(311,74,1)
(231,168,1)
(106,154,1)
(288,177,1)
(93,219,1)
(30,164,1)
(196,230,1)
(255,42,1)
(226,296,1)
(117,315,1)
(248,304,1)
(265,205,1)
(280,63,1)
(281,43,1)
(193,192,1)
(12,182,1)
(130,266,1)
(185,210,1)
(97,130,1)
(236,101,1)
(158,131,1)
(190,163,1)
(185,258,1)
(104,152,1)
(28,129,1)
(214,54,1)
(175,241,1)
(211,217,1)
(167,60,1)
(340,38,1)
(75,286,1)
(332,301,1)
(348,165,1)
(181,104,1)
(58,19,1)
(38,112,1)
(81,226,1)
(308,288,1)
(103,128,1)
(180,34,1)
(160,203,1)
(255,4,1)
(254,195,1)
(122,134,1)
(242,88,1)
(33,291,1)
(81,312,1)
(258,72,1)
(293,93,1)
(3,57,1)
(206,167,1)
(247,89,1)
(262,208,1)
(125,128,1)
(59,90,1)
(297,31,1)
(278,285,1)
(162,272,1)
(346,331,1)
(108,106,1)
(57,73,1)
(172,207,1)
(241,144,1)
(316,83,1)
(97,43,1)
(192,93,1)
(119,307,1)
(246,97,1)
(68,161,1)
(208,214,1)
(51,126,1)
(282,322,1)
(176,2,1)
(84,35,1)
(265,166,1)
(197,249,1)
(303,59,1)
(19,87,1)
(195,188,1)
(290,5,1)
(315,61,1)
(230,33,1)
(97,144,1)
(207,75,1)
(112,196,1)
(44,162,1)
(305,41,1)
(95,52,1)
(17,239,1)
(126,166,1)
(232,72,1)
(22,139,1)
(275,166,1)
(145,78,1)
(32,320,1)
(339,229,1)
(82,197,1)
(165,24,1)
(63,220,1)
(257,205,1)
(139,127,1)
(263,306,1)
(153,19,1)
(265,275,1)
(81,200,1)
(157,215,1)
(217,116,1)
(296,221,1)
(27,227,1)
(305,101,1)
(184,223,1)
(45,203,1)
(169,145,1)
(322,198,1)
(276,70,1)
(126,125,1)
(74,22,1)
(151,242,1)
(41,347,1)
(328,193,1)
(236,66,1)
(47,68,1)
(125,166,1)
(179,249,1)
(264,101,1)
(36,1,1)
(88,53,1)
(193,144,1)
(11,185,1)
(42,295,1)
(34,173,1)
(326,187,1)
(277,257,1)
(250,332,1)
(100,9,1)
(257,319,1)
(13,261,1)
(185,194,1)
(77,245,1)
(133,80,1)
(94,298,1)
(272,64,1)
(38,21,1)
(125,235,1)
(337,303,1)
(298,117,1)
(347,260,1)
(111,202,1)
(81,50,1)
(243,155,1)
(194,280,1)
(31,299,1)
(82,335,1)
(34,205,1)
(5,144,1)
(114,17,1)
(51,303,1)
(292,326,1)
(202,278,1)
(141,46,1)
(101,158,1)
(185,283,1)
(150,302,1)
(167,144,1)
(129,212,1)
(129,125,1)
(182,49,1)
(283,179,1)
(126,128,1)
(8,313,1)
(129,166,1)
(110,98,1)
(234,249,1)
(296,96,1)
(333,32,1)
(155,87,1)
(304,121,1)
(234,262,1)
(266,133,1)
(232,36,1)
(48,146,1)
(136,51,1)
(246,267,1)
(178,309,1)
(93,177,1)
(240,287,1)
(228,184,1)
(81,255,1)
(209,132,1)
(223,3,1)
(24,108,1)
(63,172,1)
(52,204,1)
(159,77,1)
(304,62,1)
(166,254,1)
(90,240,1)
(300,342,1)
(212,337,1)
(334,273,1)
(25,13,1)
(243,101,1)
(9,39,1)
(134,293,1)
(65,232,1)
(161,333,1)
(338,113,1)
(265,249,1)
(229,122,1)
(265,125,1)
(109,275,1)
(9,206,1)
(200,193,1)
(70,69,1)
(179,218,1)
(128,125,1)
(203,251,1)
(3,121,1)
(275,181,1)
(303,121,1)
(154,119,1)
(285,151,1)
(221,170,1)
(188,264,1)
(129,275,1)
(326,131,1)
(265,101,1)
(336,228,1)
(218,249,1)
(67,94,1)
(330,106,1)
(189,247,1)
(185,159,1)
(214,205,1)
(187,248,1)
(128,343,1)
(125,275,1)
(259,147,1)
(268,308,1)
(112,131,1)
(98,263,1)
(232,125,1)
(1,309,1)
(323,211,1)
(177,121,1)
(219,268,1)
(9,153,1)
(39,175,1)
(126,334,1)
(140,8,1)
(331,99,1)
(227,141,1)
(287,131,1)
(287,176,1)
(128,275,1)
(251,282,1)
(272,249,1)
(260,297,1)
(128,166,1)
(313,65,1)
(69,84,1)
(306,290,1)
(29,179,1)
(143,45,1)
(263,131,1)
(203,282,1)
(295,174,1)
(228,121,1)
(273,27,1)
(206,30,1)
(345,324,1)
(118,259,1)
(7,249,1)
(189,259,1)
(158,157,1)
(127,121,1)
(121,265,1)
(341,236,1)
(267,3,1)
(255,131,1)
(122,101,1)
(97,205,1)
(265,128,1)
(204,154,1)
(78,111,1)
(145,56,1)
(276,69,1)
(265,140,1)
(126,275,1)
(249,305,1)
(81,160,1)
(79,348,1)
(265,102,1)
(301,180,1)
(123,126,1)
(305,205,1)
(281,340,1)
(72,189,1)
(142,37,1)
(342,323,1)
(95,205,1)
(73,27,1)
(309,131,1)
(241,253,1)
(152,144,1)
(269,146,1)
(320,316,1)
(54,7,1)
(5,143,1)
(152,58,1)
(109,152,1)
(145,205,1)
(50,25,1)
(149,131,1)
(66,178,1)
(100,144,1)
(322,205,1)
(4,42,1)
(53,114,1)
(62,123,1)
(328,22,1)
(9,5,1)
(132,102,1)
(61,228,1)
(154,205,1)
(197,231,1)
(185,336,1)
(296,131,1)
(253,67,1)
(110,263,1)
(170,76,1)
(173,276,1)
(44,272,1)
(7,233,1)
(174,277,1)
(335,214,1)
(87,79,1)
(177,311,1)
(99,101,1)
(257,47,1)
(245,234,1)
(186,234,1)
(89,118,1)
(299,101,1)
(307,166,1)
(83,150,1)
(210,37,1)
(192,339,1)
(33,205,1)
(214,7,1)
(106,95,1)
(233,29,1)
(46,328,1)
(164,167,1)
(116,250,1)
(116,332,1)
(245,186,1)
(102,289,1)
(146,280,1)
(324,82,1)
(163,281,1)
(113,12,1)
(268,121,1)
(80,100,1)
(128,128,1)
(259,249,1)
(309,246,1)
(135,345,1)
(49,300,1)
(197,205,1)
(21,112,1)
(90,292,1)
(19,243,1)
(35,175,1)
(69,131,1)
(198,330,1)
(312,100,1)
(147,269,1)
(143,346,1)
(291,110,1)
(225,338,1)
(20,197,1)
(289,271,1)
(215,149,1)
(60,183,1)
(37,44,1)
(99,11,1)
(211,43,1)
(343,28,1)
(168,77,1)
(109,103,1)
(298,101,1)
(64,48,1)
(299,15,1)
(183,341,1)
(141,121,1)
(280,43,1)
(261,136,1)
(2,304,1)
(261,101,1)
(331,37,2)
(129,128,2)
(151,5,2)
(204,154,2)
(8,37,2)
(59,126,2)
(13,303,2)
(322,106,2)
(341,309,2)
(275,166,2)
(153,19,2)
(143,77,2)
(227,141,2)
(253,228,2)
(90,126,2)
(13,126,2)
(265,275,2)
(37,44,2)
(126,27,2)
(147,146,2)
(38,5,2)
(3,27,2)
(93,219,2)
(13,261,2)
(106,95,2)
(265,37,2)
(113,175,2)
(259,146,2)
(141,121,2)
(168,77,2)
(245,214,2)
(31,303,2)
(331,99,2)
(139,72,2)
(304,121,2)
(57,27,2)
(99,101,2)
(265,102,2)
(99,179,2)
(202,5,2)
(220,214,2)
(268,177,2)
(183,309,2)
(126,125,2)
(305,101,2)
(190,5,2)
(347,19,2)
(196,5,2)
(93,177,2)
(273,27,2)
(189,247,2)
(21,5,2)
(143,203,2)
(122,101,2)
(296,131,2)
(80,100,2)
(312,100,2)
(94,228,2)
(9,175,2)
(285,5,2)
(265,205,2)
(5,228,2)
(309,100,2)
(9,309,2)
(15,19,2)
(208,214,2)
(272,146,2)
(233,179,2)
(33,205,2)
(331,77,2)
(154,205,2)
(261,303,2)
(64,146,2)
(81,226,2)
(117,228,2)
(121,72,2)
(2,304,2)
(100,309,2)
(128,166,2)
(140,72,2)
(42,175,2)
(78,5,2)
(179,303,2)
(185,37,2)
(165,106,2)
(11,197,2)
(99,72,2)
(324,197,2)
(178,309,2)
(46,22,2)
(53,5,2)
(248,304,2)
(231,77,2)
(306,5,2)
(5,77,2)
(108,106,2)
(282,106,2)
(296,221,2)
(302,175,2)
(299,19,2)
(283,179,2)
(336,228,2)
(126,166,2)
(12,175,2)
(152,19,2)
(99,197,2)
(22,72,2)
(331,228,2)
(130,100,2)
(269,146,2)
(125,128,2)
(303,126,2)
(286,197,2)
(221,5,2)
(77,214,2)
(334,27,2)
(185,228,2)
(145,56,2)
(172,214,2)
(72,146,2)
(111,5,2)
(185,280,2)
(338,175,2)
(291,5,2)
(136,303,2)
(5,37,2)
(9,19,2)
(175,228,2)
(106,154,2)
(303,121,2)
(160,203,2)
(257,205,2)
(236,309,2)
(27,22,2)
(28,303,2)
(32,175,2)
(185,77,2)
(261,101,2)
(127,37,2)
(118,146,2)
(326,304,2)
(217,175,2)
(87,106,2)
(177,121,2)
(63,197,2)
(249,303,2)
(346,280,2)
(197,77,2)
(129,303,2)
(331,179,2)
(227,22,2)
(65,72,2)
(192,22,2)
(335,214,2)
(139,37,2)
(98,5,2)
(272,249,2)
(228,121,2)
(232,37,2)
(219,177,2)
(81,160,2)
(133,100,2)
(211,175,2)
(25,303,2)
(3,121,2)
(7,249,2)
(69,175,2)
(280,63,2)
(51,126,2)
(41,19,2)
(47,175,2)
(143,37,2)
(227,193,2)
(97,144,2)
(313,37,2)
(194,280,2)
(174,175,2)
(95,154,2)
(143,72,2)
(286,214,2)
(51,303,2)
(11,72,2)
(8,72,2)
(127,72,2)
(309,131,2)
(265,249,2)
(20,197,2)
(234,249,2)
(249,305,2)
(83,175,2)
(121,37,2)
(134,93,2)
(235,37,2)
(97,205,2)
(265,101,2)
(48,146,2)
(300,175,2)
(250,175,2)
(112,131,2)
(179,249,2)
(304,126,2)
(128,125,2)
(84,175,2)
(185,179,2)
(308,177,2)
(240,287,2)
(143,179,2)
(203,106,2)
(328,193,2)
(236,101,2)
(331,197,2)
(177,22,2)
(266,100,2)
(261,126,2)
(5,179,2)
(255,175,2)
(143,228,2)
(63,172,2)
(331,280,2)
(331,72,2)
(280,43,2)
(22,139,2)
(128,275,2)
(203,282,2)
(99,37,2)
(348,106,2)
(81,200,2)
(288,177,2)
(315,228,2)
(337,303,2)
(14,214,2)
(228,3,2)
(185,197,2)
(123,126,2)
(39,175,2)
(60,309,2)
(297,19,2)
(65,309,2)
(73,27,2)
(143,197,2)
(281,43,2)
(232,72,2)
(292,326,2)
(161,175,2)
(163,5,2)
(66,309,2)
(112,5,2)
(100,144,2)
(34,175,2)
(259,249,2)
(100,5,2)
(281,5,2)
(27,193,2)
(268,121,2)
(234,214,2)
(220,197,2)
(11,280,2)
(265,309,2)
(309,3,2)
(185,72,2)
(25,126,2)
(193,144,2)
(169,5,2)
(175,241,2)
(210,37,2)
(17,5,2)
(332,131,2)
(139,309,2)
(5,203,2)
(323,175,2)
(239,5,2)
(186,214,2)
(342,175,2)
(114,5,2)
(22,309,2)
(122,93,2)
(121,265,2)
(167,309,2)
(125,275,2)
(258,72,2)
(263,131,2)
(54,179,2)
(29,179,2)
(297,303,2)
(136,126,2)
(129,275,2)
(162,146,2)
(11,77,2)
(313,72,2)
(287,304,2)
(109,19,2)
(128,303,2)
(125,166,2)
(65,37,2)
(211,43,2)
(81,312,2)
(298,228,2)
(121,309,2)
(82,197,2)
(77,245,2)
(226,5,2)
(125,37,2)
(189,146,2)
(267,3,2)
(45,203,2)
(184,3,2)
(27,227,2)
(260,303,2)
(5,280,2)
(246,3,2)
(219,268,2)
(275,152,2)
(127,309,2)
(146,280,2)
(225,175,2)
(99,228,2)
(232,309,2)
(52,154,2)
(328,22,2)
(7,179,2)
(89,146,2)
(212,303,2)
(299,101,2)
(305,303,2)
(94,298,2)
(280,197,2)
(141,22,2)
(95,205,2)
(82,214,2)
(11,37,2)
(345,197,2)
(324,214,2)
(243,101,2)
(200,193,2)
(276,69,2)
(35,175,2)
(230,5,2)
(38,112,2)
(62,126,2)
(99,280,2)
(49,175,2)
(135,214,2)
(214,7,2)
(110,5,2)
(46,193,2)
(11,228,2)
(182,175,2)
(313,309,2)
(339,229,2)
(74,22,2)
(251,106,2)
(129,166,2)
(287,131,2)
(24,106,2)
(69,131,2)
(135,197,2)
(255,42,2)
(19,243,2)
(214,205,2)
(76,5,2)
(36,309,2)
(320,175,2)
(330,106,2)
(61,228,2)
(142,37,2)
(240,304,2)
(198,106,2)
(97,43,2)
(109,303,2)
(301,175,2)
(152,144,2)
(322,205,2)
(257,319,2)
(88,5,2)
(128,128,2)
(346,228,2)
(180,175,2)
(11,179,2)
(295,175,2)
(150,175,2)
(197,205,2)
(214,179,2)
(96,5,2)
(218,303,2)
(58,19,2)
(179,19,2)
(140,37,2)
(346,37,2)
(34,205,2)
(346,197,2)
(223,3,2)
(276,175,2)
(346,179,2)
(5,197,2)
(158,131,2)
(181,152,2)
(229,122,2)
(299,303,2)
(19,106,2)
(44,146,2)
(145,5,2)
(170,5,2)
(207,197,2)
(5,72,2)
(218,19,2)
(347,303,2)
(99,77,2)
(346,72,2)
(245,234,2)
(67,94,2)
(104,152,2)
(183,341,2)
(311,22,2)
(75,214,2)
(1,309,2)
(37,146,2)
(5,144,2)
(31,299,2)
(278,5,2)
(247,146,2)
(22,37,2)
(345,214,2)
(72,189,2)
(290,5,2)
(346,331,2)
(31,19,2)
(242,5,2)
(33,5,2)
(332,175,2)
(265,72,2)
(187,304,2)
(81,50,2)
(166,254,2)
(167,144,2)
(97,100,2)
(159,77,2)
(265,166,2)
(126,128,2)
(30,167,2)
(68,175,2)
(155,87,2)
(206,309,2)
(207,214,2)
(249,19,2)
(340,5,2)
(4,175,2)
(292,304,2)
(25,13,2)
(316,175,2)
(70,175,2)
(63,214,2)
(346,77,2)
(262,214,2)
(265,128,2)
(101,158,2)
(189,259,2)
(293,93,2)
(169,145,2)
(257,175,2)
(241,228,2)
(110,263,2)
(116,332,2)
(296,5,2)
(305,19,2)
(103,303,2)
(176,304,2)
(193,22,2)
(282,322,2)
(50,303,2)
(44,272,2)
(246,100,2)
(326,131,2)
(255,131,2)
(277,175,2)
(129,125,2)
(50,126,2)
(93,22,2)
(197,249,2)
(280,214,2)
(100,19,2)
(277,257,2)
(141,193,2)
(298,101,2)
(75,197,2)
(79,106,2)
(265,125,2)
(14,197,2)
(8,309,2)
(19,87,2)
(116,175,2)
(229,93,2)
(172,197,2)
(126,275,2)
(305,205,2)
(140,309,2)
(9,5,2)
(260,19,2)
(164,167,2)
(343,303,2)
(173,175,2)
(243,87,2)
(341,236,2)
(145,205,2)
(263,5,2)
(41,303,2)
(339,93,2)
(15,303,2)
(241,144,2)
(297,31,2)
(67,228,2)
(333,175,2)
(100,175,2)
(143,280,2)
-----------------------------------
(0,if (flags & FAULT_FLAG_ALLOW_RETRY)
(1,yield()
(2,tsk)
(3,fault & VM_FAULT_OOM)
(4,tsk)
(5,user_mode(regs)
(6,if (vma->vm_start <= address)
(7,vma->vm_start)
(8,address)
(9,regs)
(10,if (user_mode(regs)
(11,mmap_sem)
(12,info)
(13,&mm->mmap_sem)
(14,info.si_code = SEGV_ACCERR)
(15,mmap_sem)
(16,retry:)
(17,SIGSEGV)
(18,if (unlikely(ret)
(19,in_atomic()
(20,goto bad_area;)
(21,cause_code)
(22,unlikely(fatal_signal_pending(current)
(23,if (user_mode(regs)
(24,si_code)
(25,up_read(&mm->mmap_sem)
(26,if (likely(!(fault & VM_FAULT_ERROR)
(27,likely(!(fault & VM_FAULT_ERROR)
(28,flags)
(29,vma)
(30,do_group_exit(SIGKILL)
(31,&mm->mmap_sem)
(32,info.si_code = BUS_ADRERR)
(33,tsk->thread.fault_address = address)
(34,tsk->thread.fault_address = address)
(35,tsk)
(36,goto survive;)
(37,!(vma->vm_flags & VM_WRITE)
(38,tsk->thread.cause_code)
(39,goto no_context;)
(40,if (unlikely(fatal_signal_pending(current)
(41,address)
(42,&info)
(43,unsigned long cause_code)
(44,vma->vm_flags & VM_WRITE)
(45,goto bad_area_nosemaphore;)
(46,VM_FAULT_ERROR)
(47,address)
(48,vma)
(49,SIGBUS)
(50,return;)
(51,mm)
(52,VMALLOC_END)
(53,info)
(54,address)
(55,)
(56,void __user *)
(57,VM_FAULT_OOM)
(58,regs)
(59,VM_FAULT_RETRY)
(60,regs)
(61,goto do_sigbus;)
(62,VM_FAULT_MAJOR)
(63,(ECR_V_PROTV << 16)
(64,vm_flags)
(65,mm)
(66,mmap_sem)
(67,up_read(&mm->mmap_sem)
(68,info.si_addr)
(69,tsk->thread)
(70,fault_address)
(71,fault)
(72,!(vma->vm_flags & (VM_READ | VM_EXEC)
(73,fault)
(74,fault)
(75,ECR_V_PROTV)
(76,SIGSEGV)
(77,!(vma->vm_flags & VM_GROWSDOWN)
(78,address)
(79,info.si_code = SEGV_MAPERR)
(80,"Oops")
(81,RET)
(82,info)
(83,si_code)
(84,thread)
(85,)
(86,if (fault & VM_FAULT_MAJOR)
(87,in_atomic()
(88,si_errno)
(89,VM_EXEC)
(90,fault)
(91,if (cause_code == ((ECR_V_PROTV << 16)
(92,if (write)
(93,(fault & VM_FAULT_ERROR)
(94,&mm->mmap_sem)
(95,address <= VMALLOC_END)
(96,tsk)
(97,die("Oops", regs, address, cause_code)
(98,fault_address)
(99,mm->mmap_sem)
(100,fixup_exception(regs)
(101,*mm = tsk->mm)
(102,*vma = NULL)
(103,goto retry;)
(104,flags)
(105,ret)
(106,address >= VMALLOC_START && address <= VMALLOC_END)
(107,if (user_mode(regs)
(108,info)
(109,mm)
(110,tsk->thread.fault_address)
(111,info.si_addr)
(112,tsk->thread)
(113,si_errno)
(114,info.si_signo = SIGSEGV)
(115,info)
(116,tsk->thread.cause_code)
(117,mmap_sem)
(118,VM_READ)
(119,VMALLOC_START)
(120,bad_area_nosemaphore:)
(121,fault = handle_mm_fault(mm, vma, address, flags)
(122,mm->mmap_sem)
(123,fault)
(124,)
(125,flags |= FAULT_FLAG_WRITE)
(126,flags & FAULT_FLAG_ALLOW_RETRY)
(127,current)
(128,flags |= FAULT_FLAG_TRIED)
(129,flags &= ~FAULT_FLAG_ALLOW_RETRY)
(130,cause_code)
(131,*tsk = current)
(132,tsk)
(133,regs)
(134,mmap_sem)
(135,SEGV_ACCERR)
(136,mmap_sem)
(137,)
(138,if (!(vma->vm_flags & (VM_READ | VM_EXEC)
(139,fatal_signal_pending(current)
(140,flags)
(141,fault & VM_FAULT_ERROR)
(142,flags)
(143,regs)
(144,struct pt_regs *regs)
(145,(void __user *)
(146,write)
(147,vm_flags)
(148,)
(149,mm)
(150,info)
(151,0)
(152,user_mode(regs)
(153,goto no_context;)
(154,address >= VMALLOC_START)
(155,mm)
(156,if (!(vma->vm_flags & VM_GROWSDOWN)
(157,mm)
(158,tsk->mm)
(159,goto bad_area;)
(160,return;)
(161,si_addr)
(162,VM_WRITE)
(163,info)
(164,SIGKILL)
(165,info.si_code)
(166,flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE)
(167,user_mode(regs)
(168,vma)
(169,info.si_addr = (void __user *)
(170,info)
(171,if (fixup_exception(regs)
(172,ECR_V_PROTV << 16)
(173,address)
(174,SIGBUS)
(175,!user_mode(regs)
(176,maj_flt)
(177,fault & VM_FAULT_ERROR)
(178,mm)
(179,!vma)
(180,tsk)
(181,FAULT_FLAG_USER)
(182,info.si_signo = SIGBUS)
(183,up_read(&mm->mmap_sem)
(184,VM_FAULT_SIGBUS)
(185,mm)
(186,VM_GROWSDOWN)
(187,min_flt)
(188,FAULT_FLAG_ALLOW_RETRY)
(189,vma->vm_flags & (VM_READ | VM_EXEC)
(190,si_signo)
(191,if (!(vma->vm_flags & VM_WRITE)
(192,regs)
(193,user_mode(regs)
(194,goto bad_area;)
(195,FAULT_FLAG_KILLABLE)
(196,thread)
(197,expand_stack(vma, address)
(198,address)
(199,)
(200,return;)
(201,vma)
(202,si_addr)
(203,unlikely(ret)
(204,address)
(205,unsigned long address)
(206,goto no_context;)
(207,16)
(208,vma)
(209,current)
(210,goto bad_area;)
(211,tsk->thread.cause_code = cause_code)
(212,~FAULT_FLAG_ALLOW_RETRY)
(213,no_context:)
(214,vma->vm_start <= address)
(215,tsk)
(216,tsk)
(217,cause_code)
(218,vma)
(219,!(fault & VM_FAULT_RETRY)
(220,ECR_C_PROTV_INST_FETCH)
(221,&info)
(222,if (fault & VM_FAULT_OOM)
(223,fault)
(224,if (address >= VMALLOC_START && address <= VMALLOC_END)
(225,0)
(226,return;)
(227,!(fault & VM_FAULT_ERROR)
(228,fault & VM_FAULT_SIGBUS)
(229,&mm->mmap_sem)
(230,tsk)
(231,address)
(232,fault)
(233,vm_start)
(234,vma->vm_flags)
(235,FAULT_FLAG_WRITE)
(236,mm->mmap_sem)
(237,if (!user_mode(regs)
(238,flags)
(239,info.si_signo)
(240,tsk->maj_flt++)
(241,user_mode(regs)
(242,info.si_errno)
(243,!mm)
(244,out_of_memory:)
(245,vma->vm_flags & VM_GROWSDOWN)
(246,tsk)
(247,VM_READ | VM_EXEC)
(248,tsk)
(249,vma = find_vma(mm, address)
(250,cause_code)
(251,ret)
(252,mm)
(253,regs)
(254,FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE)
(255,force_sig_info(SIGBUS, &info, tsk)
(256,)
(257,(void __user *)
(258,goto bad_area;)
(259,vma->vm_flags)
(260,vma)
(261,mm->mmap_sem)
(262,vm_flags)
(263,tsk->thread)
(264,flags)
(265,handle_mm_fault(mm, vma, address, flags)
(266,address)
(267,goto out_of_memory;)
(268,fault & VM_FAULT_RETRY)
(269,vma)
(270,)
(271,vma)
(272,vma->vm_flags)
(273,flags)
(274,bad_area:)
(275,flags |= FAULT_FLAG_USER)
(276,tsk->thread.fault_address)
(277,info.si_addr = (void __user *)
(278,info)
(279,if (user_mode(regs)
(280,cause_code == ((ECR_V_PROTV << 16)
(281,tsk->thread.cause_code = cause_code)
(282,ret = handle_vmalloc_fault(address)
(283,goto bad_area;)
(284,)
(285,info.si_errno = 0)
(286,cause_code)
(287,tsk->maj_flt)
(288,fault)
(289,NULL)
(290,tsk)
(291,address)
(292,tsk->min_flt++)
(293,mm)
(294,if (fault & VM_FAULT_RETRY)
(295,info)
(296,force_sig_info(SIGSEGV, &info, tsk)
(297,down_read(&mm->mmap_sem)
(298,mm->mmap_sem)
(299,mm->mmap_sem)
(300,info.si_signo)
(301,thread)
(302,info.si_errno = 0)
(303,fault & VM_FAULT_RETRY)
(304,fault & VM_FAULT_MAJOR)
(305,find_vma(mm, address)
(306,thread)
(307,address)
(308,VM_FAULT_RETRY)
(309,is_global_init(tsk)
(310,survive:)
(311,VM_FAULT_ERROR)
(312,return;)
(313,vma)
(314,if (!vma)
(315,mm)
(316,info.si_code)
(317,if (is_global_init(tsk)
(318,if (in_atomic()
(319,void __user *)
(320,BUS_ADRERR)
(321,)
(322,handle_vmalloc_fault(address)
(323,info)
(324,si_code)
(325,good_area:)
(326,tsk->min_flt)
(327,if (expand_stack(vma, address)
(328,fault)
(329,do_sigbus:)
(330,ret)
(331,&mm->mmap_sem)
(332,tsk->thread)
(333,info)
(334,FAULT_FLAG_ALLOW_RETRY)
(335,goto good_area;)
(336,BUG()
(337,flags)
(338,info.si_errno)
(339,up_read(&mm->mmap_sem)
(340,cause_code)
(341,&mm->mmap_sem)
(342,si_signo)
(343,FAULT_FLAG_TRIED)
(344,if ((fault & VM_FAULT_ERROR)
(345,info.si_code)
(346,up_read(&mm->mmap_sem)
(347,mm)
(348,SEGV_MAPERR)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^