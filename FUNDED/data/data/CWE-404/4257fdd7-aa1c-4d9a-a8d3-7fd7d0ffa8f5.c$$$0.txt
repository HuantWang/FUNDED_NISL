-----label-----
1
-----code-----
int ksched_setscheduler(register_t *ret, struct ksched *ksched,
	struct proc *p, int policy, const struct sched_param *param)
{
	int e = 0;
	struct rtprio rtp;

	switch(policy)
	{
		case SCHED_RR:
		case SCHED_FIFO:

		if (param->sched_priority >= P1B_PRIO_MIN &&
		param->sched_priority <= P1B_PRIO_MAX)
		{
			rtp.prio = p4prio_to_rtpprio(param->sched_priority);
			rtp.type = (policy == SCHED_FIFO)
				? RTP_PRIO_FIFO : RTP_PRIO_REALTIME;

			p->p_rtprio = rtp;
			need_user_resched();
		}
		else
			e = EPERM;


		break;

		case SCHED_OTHER:
		{
			rtp.type = RTP_PRIO_NORMAL;
			rtp.prio = p4prio_to_rtpprio(param->sched_priority);
			p->p_rtprio = rtp;

			/* XXX Simply revert to whatever we had for last
			 *     normal scheduler priorities.
			 *     This puts a requirement
			 *     on the scheduling code: You must leave the
			 *     scheduling info alone.
			 */
			need_user_resched();
		}
		break;
	}

	return e;
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
3,7
3,8
3,9
5,6
5,7
6,7
8,9
8,10
11,12
11,13
12,13
14,15
14,16
17,18
17,19
18,19
20,21
20,22
23,24
23,25
25,26
27,28
27,29
28,29
30,31
30,32
33,34
33,35
33,36
33,37
34,35
35,36
35,37
37,38
37,39
39,40
41,42
42,43
42,44
43,44
45,46
47,48
47,49
48,49
50,51
50,52
50,53
50,54
50,55
50,56
50,57
51,52
52,53
54,55
55,56
57,58
57,59
57,60
58,59
58,60
59,60
59,61
60,61
60,62
61,62
64,65
66,67
66,68
67,68
67,69
68,69
71,72
73,74
73,75
73,76
73,77
74,75
75,76
75,77
76,77
76,78
77,78
80,81
80,82
81,82
83,84
83,85
84,85
87,88
88,89
88,90
89,90
89,91
90,91
93,94
93,95
93,96
94,95
95,96
95,97
96,97
98,99
100,101
102,103
104,105
105,106
105,107
106,107
106,108
107,108
110,111
112,113
113,114
114,115
116,117
117,118
117,119
118,119
120,121
123,124
124,125
126,127
126,128
126,129
126,130
127,128
128,129
128,130
129,130
129,131
130,131
133,134
135,136
136,137
136,138
137,138
137,139
138,139
141,142
141,143
142,143
144,145
144,146
145,146
148,149
149,150
149,151
150,151
150,152
151,152
154,155
156,157
157,158
158,159
161,162
162,163
-----nextToken-----
2,4,7,9,10,13,15,16,19,21,22,24,26,29,31,32,36,38,40,44,46,49,53,56,62,63,65,69,70,72,78,79,82,85,86,91,92,97,99,101,103,108,109,111,115,119,121,122,125,131,132,134,139,140,143,146,147,152,153,155,159,160,163
-----computeFrom-----
58,59
58,60
59,60
59,61
66,67
66,68
75,76
75,77
88,89
88,90
95,96
95,97
105,106
105,107
117,118
117,119
128,129
128,130
136,137
136,138
149,150
149,151
-----guardedBy-----
69,85
70,86
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;SwitchStatement;IdExpression;Name;CompoundStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;ConditionalExpression;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BreakStatement;ReturnStatement;IdExpression;Name;
-----ast_node-----
int ksched_setscheduler(register_t *ret, struct ksched *ksched,	struct proc *p, int policy, const struct sched_param *param){	int e = 0;	struct rtprio rtp;	switch(policy)	{		case SCHED_RR:		case SCHED_FIFO:		if (param->sched_priority >= P1B_PRIO_MIN &&		param->sched_priority <= P1B_PRIO_MAX)		{			rtp.prio = p4prio_to_rtpprio(param->sched_priority);			rtp.type = (policy == SCHED_FIFO)				? RTP_PRIO_FIFO : RTP_PRIO_REALTIME;			p->p_rtprio = rtp;			need_user_resched();		}		else			e = EPERM;		break;		case SCHED_OTHER:		{			rtp.type = RTP_PRIO_NORMAL;			rtp.prio = p4prio_to_rtpprio(param->sched_priority);			p->p_rtprio = rtp;			/* XXX Simply revert to whatever we had for last			 *     normal scheduler priorities.			 *     This puts a requirement			 *     on the scheduling code: You must leave the			 *     scheduling info alone.			 */			need_user_resched();		}		break;	}	return e;}
int
ksched_setscheduler(register_t *ret, struct ksched *ksched,	struct proc *p, int policy, const struct sched_param *param)
ksched_setscheduler
register_t *ret
register_t
register_t
*ret
*
ret
struct ksched *ksched
struct ksched
ksched
*ksched
*
ksched
struct proc *p
struct proc
proc
*p
*
p
int policy
int
policy
policy
const struct sched_param *param
const struct sched_param
sched_param
*param
*
param
{	int e = 0;	struct rtprio rtp;	switch(policy)	{		case SCHED_RR:		case SCHED_FIFO:		if (param->sched_priority >= P1B_PRIO_MIN &&		param->sched_priority <= P1B_PRIO_MAX)		{			rtp.prio = p4prio_to_rtpprio(param->sched_priority);			rtp.type = (policy == SCHED_FIFO)				? RTP_PRIO_FIFO : RTP_PRIO_REALTIME;			p->p_rtprio = rtp;			need_user_resched();		}		else			e = EPERM;		break;		case SCHED_OTHER:		{			rtp.type = RTP_PRIO_NORMAL;			rtp.prio = p4prio_to_rtpprio(param->sched_priority);			p->p_rtprio = rtp;			/* XXX Simply revert to whatever we had for last			 *     normal scheduler priorities.			 *     This puts a requirement			 *     on the scheduling code: You must leave the			 *     scheduling info alone.			 */			need_user_resched();		}		break;	}	return e;}
int e = 0;
int e = 0;
int
e = 0
e
= 0
0
struct rtprio rtp;
struct rtprio rtp;
struct rtprio
rtprio
rtp
rtp
switch(policy)	{		case SCHED_RR:		case SCHED_FIFO:		if (param->sched_priority >= P1B_PRIO_MIN &&		param->sched_priority <= P1B_PRIO_MAX)		{			rtp.prio = p4prio_to_rtpprio(param->sched_priority);			rtp.type = (policy == SCHED_FIFO)				? RTP_PRIO_FIFO : RTP_PRIO_REALTIME;			p->p_rtprio = rtp;			need_user_resched();		}		else			e = EPERM;		break;		case SCHED_OTHER:		{			rtp.type = RTP_PRIO_NORMAL;			rtp.prio = p4prio_to_rtpprio(param->sched_priority);			p->p_rtprio = rtp;			/* XXX Simply revert to whatever we had for last			 *     normal scheduler priorities.			 *     This puts a requirement			 *     on the scheduling code: You must leave the			 *     scheduling info alone.			 */			need_user_resched();		}		break;	}
policy
policy
{		case SCHED_RR:		case SCHED_FIFO:		if (param->sched_priority >= P1B_PRIO_MIN &&		param->sched_priority <= P1B_PRIO_MAX)		{			rtp.prio = p4prio_to_rtpprio(param->sched_priority);			rtp.type = (policy == SCHED_FIFO)				? RTP_PRIO_FIFO : RTP_PRIO_REALTIME;			p->p_rtprio = rtp;			need_user_resched();		}		else			e = EPERM;		break;		case SCHED_OTHER:		{			rtp.type = RTP_PRIO_NORMAL;			rtp.prio = p4prio_to_rtpprio(param->sched_priority);			p->p_rtprio = rtp;			/* XXX Simply revert to whatever we had for last			 *     normal scheduler priorities.			 *     This puts a requirement			 *     on the scheduling code: You must leave the			 *     scheduling info alone.			 */			need_user_resched();		}		break;	}
case SCHED_RR:
SCHED_RR
SCHED_RR
case SCHED_FIFO:
SCHED_FIFO
SCHED_FIFO
if (param->sched_priority >= P1B_PRIO_MIN &&		param->sched_priority <= P1B_PRIO_MAX)		{			rtp.prio = p4prio_to_rtpprio(param->sched_priority);			rtp.type = (policy == SCHED_FIFO)				? RTP_PRIO_FIFO : RTP_PRIO_REALTIME;			p->p_rtprio = rtp;			need_user_resched();		}		else			e = EPERM;
param->sched_priority >= P1B_PRIO_MIN &&		param->sched_priority <= P1B_PRIO_MAX
param->sched_priority >= P1B_PRIO_MIN
param->sched_priority
param
param
sched_priority
P1B_PRIO_MIN
P1B_PRIO_MIN
param->sched_priority <= P1B_PRIO_MAX
param->sched_priority
param
param
sched_priority
P1B_PRIO_MAX
P1B_PRIO_MAX
{			rtp.prio = p4prio_to_rtpprio(param->sched_priority);			rtp.type = (policy == SCHED_FIFO)				? RTP_PRIO_FIFO : RTP_PRIO_REALTIME;			p->p_rtprio = rtp;			need_user_resched();		}
rtp.prio = p4prio_to_rtpprio(param->sched_priority);
rtp.prio = p4prio_to_rtpprio(param->sched_priority)
rtp.prio
rtp
rtp
prio
p4prio_to_rtpprio(param->sched_priority)
p4prio_to_rtpprio
p4prio_to_rtpprio
param->sched_priority
param
param
sched_priority
rtp.type = (policy == SCHED_FIFO)				? RTP_PRIO_FIFO : RTP_PRIO_REALTIME;
rtp.type = (policy == SCHED_FIFO)				? RTP_PRIO_FIFO : RTP_PRIO_REALTIME
rtp.type
rtp
rtp
type
(policy == SCHED_FIFO)				? RTP_PRIO_FIFO : RTP_PRIO_REALTIME
(policy == SCHED_FIFO)
policy == SCHED_FIFO
policy
policy
SCHED_FIFO
SCHED_FIFO
RTP_PRIO_FIFO
RTP_PRIO_FIFO
RTP_PRIO_REALTIME
RTP_PRIO_REALTIME
p->p_rtprio = rtp;
p->p_rtprio = rtp
p->p_rtprio
p
p
p_rtprio
rtp
rtp
need_user_resched();
need_user_resched()
need_user_resched
need_user_resched
e = EPERM;
e = EPERM
e
e
EPERM
EPERM
break;
case SCHED_OTHER:
SCHED_OTHER
SCHED_OTHER
{			rtp.type = RTP_PRIO_NORMAL;			rtp.prio = p4prio_to_rtpprio(param->sched_priority);			p->p_rtprio = rtp;			/* XXX Simply revert to whatever we had for last			 *     normal scheduler priorities.			 *     This puts a requirement			 *     on the scheduling code: You must leave the			 *     scheduling info alone.			 */			need_user_resched();		}
rtp.type = RTP_PRIO_NORMAL;
rtp.type = RTP_PRIO_NORMAL
rtp.type
rtp
rtp
type
RTP_PRIO_NORMAL
RTP_PRIO_NORMAL
rtp.prio = p4prio_to_rtpprio(param->sched_priority);
rtp.prio = p4prio_to_rtpprio(param->sched_priority)
rtp.prio
rtp
rtp
prio
p4prio_to_rtpprio(param->sched_priority)
p4prio_to_rtpprio
p4prio_to_rtpprio
param->sched_priority
param
param
sched_priority
p->p_rtprio = rtp;
p->p_rtprio = rtp
p->p_rtprio
p
p
p_rtprio
rtp
rtp
need_user_resched();
need_user_resched()
need_user_resched
need_user_resched
break;
return e;
e
e
-----joern-----
(56,11,0)
(28,51,0)
(27,3,0)
(4,17,0)
(9,5,0)
(79,45,0)
(8,18,0)
(48,77,0)
(31,50,0)
(76,4,0)
(63,23,0)
(61,0,0)
(38,51,0)
(42,10,0)
(66,53,0)
(5,59,0)
(36,11,0)
(11,36,0)
(27,71,0)
(45,20,0)
(14,12,0)
(25,35,0)
(37,51,0)
(63,18,0)
(68,20,0)
(62,0,0)
(75,31,0)
(30,51,0)
(23,63,0)
(16,39,0)
(1,56,0)
(0,77,0)
(3,18,0)
(26,11,0)
(35,46,0)
(15,45,0)
(40,31,0)
(12,6,0)
(33,56,0)
(53,63,0)
(29,51,0)
(2,59,0)
(0,5,0)
(55,35,0)
(35,55,0)
(39,60,0)
(64,79,0)
(36,55,0)
(73,5,0)
(32,59,0)
(41,10,0)
(72,79,0)
(22,59,0)
(31,46,0)
(71,27,0)
(65,71,0)
(50,31,0)
(79,17,0)
(23,12,0)
(60,20,0)
(74,49,0)
(55,36,0)
(4,8,0)
(20,51,0)
(19,23,0)
(56,46,0)
(78,53,0)
(44,23,0)
(43,35,0)
(21,4,0)
(3,27,0)
(50,60,0)
(58,20,0)
(10,58,0)
(71,46,0)
(0,59,0)
(69,8,0)
(57,49,0)
(54,71,0)
(34,18,0)
(13,39,0)
(47,12,0)
(52,51,0)
(70,58,0)
(49,3,0)
(24,55,0)
(7,77,0)
(60,50,0)
(12,23,0)
(11,56,0)
(47,53,1)
(41,67,1)
(3,27,1)
(23,19,1)
(43,67,1)
(11,26,1)
(8,69,1)
(14,47,1)
(56,46,1)
(31,40,1)
(1,33,1)
(55,24,1)
(63,23,1)
(79,17,1)
(31,46,1)
(62,52,1)
(44,12,1)
(52,68,1)
(78,3,1)
(71,54,1)
(23,44,1)
(35,25,1)
(62,67,1)
(33,55,1)
(19,12,1)
(12,14,1)
(58,70,1)
(75,39,1)
(60,50,1)
(36,55,1)
(11,56,1)
(26,56,1)
(79,72,1)
(49,74,1)
(68,45,1)
(21,63,1)
(34,8,1)
(24,35,1)
(38,34,1)
(65,49,1)
(15,79,1)
(9,73,1)
(36,11,1)
(76,21,1)
(35,46,1)
(57,36,1)
(67,5,1)
(0,62,1)
(70,10,1)
(25,43,1)
(0,5,1)
(7,48,1)
(64,60,1)
(42,41,1)
(61,0,1)
(53,66,1)
(40,75,1)
(13,58,1)
(72,64,1)
(48,36,1)
(74,57,1)
(12,6,1)
(71,46,1)
(56,1,1)
(0,77,1)
(16,13,1)
(69,4,1)
(4,76,1)
(55,35,1)
(39,16,1)
(62,38,1)
(10,42,1)
(45,15,1)
(50,31,1)
(54,65,1)
(23,12,1)
(66,78,1)
(4,17,1)
(38,77,1)
(27,71,1)
(77,7,1)
(5,9,1)
(56,55,2)
(39,67,2)
(8,36,2)
(23,12,2)
(63,23,2)
(34,36,2)
(52,67,2)
(36,67,2)
(48,36,2)
(12,36,2)
(63,36,2)
(57,36,2)
(78,36,2)
(50,67,2)
(31,46,2)
(55,35,2)
(79,17,2)
(54,36,2)
(10,67,2)
(42,67,2)
(4,36,2)
(13,67,2)
(71,36,2)
(49,36,2)
(66,36,2)
(3,36,2)
(15,67,2)
(70,67,2)
(27,71,2)
(11,56,2)
(69,36,2)
(75,67,2)
(58,67,2)
(68,67,2)
(1,55,2)
(64,67,2)
(33,55,2)
(72,67,2)
(76,36,2)
(36,55,2)
(44,12,2)
(7,36,2)
(74,36,2)
(16,67,2)
(24,67,2)
(31,67,2)
(25,67,2)
(55,67,2)
(47,36,2)
(45,67,2)
(60,67,2)
(71,46,2)
(60,50,2)
(26,55,2)
(65,36,2)
(0,5,2)
(53,36,2)
(77,36,2)
(79,67,2)
(61,0,2)
(14,36,2)
(11,55,2)
(43,67,2)
(41,67,2)
(0,77,2)
(38,67,2)
(35,46,2)
(50,31,2)
(12,6,2)
(19,12,2)
(36,11,2)
(35,67,2)
(3,27,2)
(40,67,2)
(56,46,2)
(4,17,2)
(23,36,2)
(27,36,2)
(21,36,2)
-----------------------------------
(0,return e;)
(1,sched_priority)
(2,switch(policy)
(3,rtp.prio = p4prio_to_rtpprio(param->sched_priority)
(4,p->p_rtprio)
(5,e = 0)
(6,int policy)
(7,EPERM)
(8,p->p_rtprio = rtp)
(9,0)
(10,rtp.type)
(11,param->sched_priority <= P1B_PRIO_MAX)
(12,policy == SCHED_FIFO)
(13,rtp)
(14,SCHED_FIFO)
(15,rtp)
(16,prio)
(17,struct proc *p)
(18,)
(19,RTP_PRIO_FIFO)
(20,)
(21,p)
(22,e)
(23,(policy == SCHED_FIFO)
(24,P1B_PRIO_MIN)
(25,sched_priority)
(26,P1B_PRIO_MAX)
(27,p4prio_to_rtpprio(param->sched_priority)
(28,if (param->sched_priority >= P1B_PRIO_MIN &&\n\\n\\t\\tparam->sched_priority <= P1B_PRIO_MAX)
(29,case SCHED_RR:)
(30,case SCHED_FIFO:)
(31,param->sched_priority)
(32,rtp)
(33,param)
(34,need_user_resched()
(35,param->sched_priority)
(36,param->sched_priority >= P1B_PRIO_MIN &&\n\\n\\t\\tparam->sched_priority <= P1B_PRIO_MAX)
(37,case SCHED_OTHER:)
(38,break;)
(39,rtp.prio)
(40,sched_priority)
(41,rtp)
(42,type)
(43,param)
(44,RTP_PRIO_REALTIME)
(45,p->p_rtprio = rtp)
(46,const struct sched_param *param)
(47,policy)
(48,e)
(49,rtp.prio)
(50,p4prio_to_rtpprio(param->sched_priority)
(51,)
(52,break;)
(53,rtp.type)
(54,sched_priority)
(55,param->sched_priority >= P1B_PRIO_MIN)
(56,param->sched_priority)
(57,rtp)
(58,rtp.type = RTP_PRIO_NORMAL)
(59,)
(60,rtp.prio = p4prio_to_rtpprio(param->sched_priority)
(61,RET)
(62,e)
(63,rtp.type = (policy == SCHED_FIFO)
(64,p)
(65,param)
(66,type)
(67,policy)
(68,need_user_resched()
(69,rtp)
(70,RTP_PRIO_NORMAL)
(71,param->sched_priority)
(72,p_rtprio)
(73,e)
(74,prio)
(75,param)
(76,p_rtprio)
(77,e = EPERM)
(78,rtp)
(79,p->p_rtprio)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^