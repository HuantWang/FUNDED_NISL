-----label-----
1
-----code-----
void do_tlb_overlap_fault(unsigned long cause, unsigned long address,
			  struct pt_regs *regs)
{
	int set, way, n;
	unsigned long flags, is_valid;
	struct cpuinfo_arc_mmu *mmu = &cpuinfo_arc700[smp_processor_id()].mmu;
	unsigned int pd0[mmu->ways], pd1[mmu->ways];

	local_irq_save(flags);

	/* re-enable the MMU */
	write_aux_reg(ARC_REG_PID, MMU_ENABLE | read_aux_reg(ARC_REG_PID));

	/* loop thru all sets of TLB */
	for (set = 0; set < mmu->sets; set++) {

		/* read out all the ways of current set */
		for (way = 0, is_valid = 0; way < mmu->ways; way++) {
			write_aux_reg(ARC_REG_TLBINDEX,
					  SET_WAY_TO_IDX(mmu, set, way));
			write_aux_reg(ARC_REG_TLBCOMMAND, TLBRead);
			pd0[way] = read_aux_reg(ARC_REG_TLBPD0);
			pd1[way] = read_aux_reg(ARC_REG_TLBPD1);
			is_valid |= pd0[way] & _PAGE_PRESENT;
		}

		/* If all the WAYS in SET are empty, skip to next SET */
		if (!is_valid)
			continue;

		/* Scan the set for duplicate ways: needs a nested loop */
		for (way = 0; way < mmu->ways - 1; way++) {
			if (!pd0[way])
				continue;

			for (n = way + 1; n < mmu->ways; n++) {
				if ((pd0[way] & PAGE_MASK) ==
				    (pd0[n] & PAGE_MASK)) {

					if (dup_pd_verbose) {
						pr_info("Duplicate PD's @"
							"[%d:%d]/[%d:%d]\n",
						     set, way, set, n);
						pr_info("TLBPD0[%u]: %08x\n",
						     way, pd0[way]);
					}

					/*
					 * clear entry @way and not @n. This is
					 * critical to our optimised loop
					 */
					pd0[way] = pd1[way] = 0;
					write_aux_reg(ARC_REG_TLBINDEX,
						SET_WAY_TO_IDX(mmu, set, way));
					__tlb_entry_erase();
				}
			}
		}
	}

	local_irq_restore(flags);
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
3,7
5,6
5,7
7,8
9,10
9,11
11,12
13,14
13,15
14,15
16,17
16,18
19,20
19,21
19,22
19,23
19,24
19,25
19,26
19,27
20,21
21,22
21,23
21,24
21,25
23,24
25,26
27,28
29,30
30,31
30,32
30,33
32,33
34,35
36,37
37,38
37,39
38,39
40,41
40,42
40,43
43,44
44,45
45,46
45,47
46,47
46,48
47,48
49,50
50,51
53,54
54,55
54,56
54,57
56,57
56,58
58,59
59,60
59,61
60,61
63,64
63,65
65,66
66,67
66,68
67,68
70,71
71,72
71,73
72,73
74,75
76,77
77,78
77,79
77,80
78,79
80,81
82,83
82,84
83,84
85,86
85,87
86,87
88,89
90,91
90,92
90,93
90,94
91,92
92,93
92,94
93,94
96,97
96,98
97,98
99,100
99,101
100,101
103,104
104,105
106,107
106,108
106,109
107,108
107,109
107,110
107,111
108,109
109,110
109,111
110,111
110,112
111,112
114,115
114,116
115,116
118,119
118,120
119,120
121,122
121,123
122,123
125,126
126,127
128,129
128,130
128,131
128,132
128,133
129,130
130,131
130,132
130,133
131,132
133,134
135,136
135,137
135,138
135,139
136,137
138,139
140,141
142,143
144,145
145,146
145,147
145,148
146,147
148,149
150,151
152,153
153,154
153,155
154,155
154,156
155,156
157,158
159,160
159,161
160,161
162,163
164,165
165,166
165,167
166,167
166,168
167,168
169,170
171,172
171,173
172,173
174,175
176,177
177,178
177,179
178,179
180,181
180,182
181,182
181,183
182,183
184,185
186,187
188,189
188,190
189,190
190,191
193,194
193,195
193,196
193,197
194,195
195,196
195,197
196,197
199,200
199,201
200,201
202,203
202,204
203,204
203,205
204,205
208,209
209,210
211,212
211,213
212,213
212,214
213,214
214,215
214,216
215,216
217,218
220,221
220,222
220,223
220,224
221,222
222,223
222,224
223,224
225,226
225,227
226,227
229,230
229,231
230,231
232,233
232,234
233,234
236,237
237,238
239,240
240,241
240,242
241,242
241,243
242,243
243,244
243,245
244,245
244,246
245,246
247,248
249,250
251,252
252,253
252,254
253,254
253,255
254,255
256,257
258,259
260,261
260,262
260,263
260,264
261,262
261,263
262,263
264,265
264,266
265,266
266,267
266,268
266,269
266,270
266,271
266,272
267,268
270,271
272,273
274,275
276,277
278,279
279,280
279,281
279,282
279,283
280,281
283,284
285,286
285,287
286,287
288,289
290,291
291,292
291,293
292,293
292,294
293,294
295,296
297,298
297,299
298,299
298,300
299,300
301,302
304,305
305,306
305,307
305,308
306,307
308,309
310,311
310,312
310,313
310,314
311,312
313,314
315,316
317,318
319,320
320,321
321,322
323,324
324,325
324,326
325,326
327,328
-----nextToken-----
2,4,6,8,10,12,15,17,18,22,24,26,28,31,33,35,39,41,42,48,51,52,55,57,61,62,64,68,69,73,75,79,81,84,87,89,94,95,98,101,102,105,112,113,116,117,120,123,124,127,132,134,137,139,141,143,147,149,151,156,158,161,163,168,170,173,175,179,183,185,187,191,192,197,198,201,205,206,207,210,216,218,219,224,227,228,231,234,235,238,246,248,250,255,257,259,263,268,269,271,273,275,277,281,282,284,287,289,294,296,300,302,303,307,309,312,314,316,318,322,326,328
-----computeFrom-----
82,83
82,84
92,93
92,94
96,97
96,98
110,111
110,112
114,115
114,116
118,119
118,120
153,154
153,155
165,166
165,167
177,178
177,179
180,181
180,182
195,196
195,197
199,200
199,201
202,203
202,204
222,223
222,224
225,226
225,227
229,230
229,231
241,242
241,243
243,244
243,245
252,253
252,254
291,292
291,293
297,298
297,299
-----guardedBy-----
255,294
248,318
257,277
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;Declarator;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;UnaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;FieldReference;IdExpression;Name;Name;ArrayDeclarator;Name;ArrayModifier;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ForStatement;ExpressionStatement;ExpressionList;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;ContinueStatement;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;ContinueStatement;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;
-----ast_node-----
void do_tlb_overlap_fault(unsigned long cause, unsigned long address,			  struct pt_regs *regs){	int set, way, n;	unsigned long flags, is_valid;	struct cpuinfo_arc_mmu *mmu = &cpuinfo_arc700[smp_processor_id()].mmu;	unsigned int pd0[mmu->ways], pd1[mmu->ways];	local_irq_save(flags);	/* re-enable the MMU */	write_aux_reg(ARC_REG_PID, MMU_ENABLE | read_aux_reg(ARC_REG_PID));	/* loop thru all sets of TLB */	for (set = 0; set < mmu->sets; set++) {		/* read out all the ways of current set */		for (way = 0, is_valid = 0; way < mmu->ways; way++) {			write_aux_reg(ARC_REG_TLBINDEX,					  SET_WAY_TO_IDX(mmu, set, way));			write_aux_reg(ARC_REG_TLBCOMMAND, TLBRead);			pd0[way] = read_aux_reg(ARC_REG_TLBPD0);			pd1[way] = read_aux_reg(ARC_REG_TLBPD1);			is_valid |= pd0[way] & _PAGE_PRESENT;		}		/* If all the WAYS in SET are empty, skip to next SET */		if (!is_valid)			continue;		/* Scan the set for duplicate ways: needs a nested loop */		for (way = 0; way < mmu->ways - 1; way++) {			if (!pd0[way])				continue;			for (n = way + 1; n < mmu->ways; n++) {				if ((pd0[way] & PAGE_MASK) ==				    (pd0[n] & PAGE_MASK)) {					if (dup_pd_verbose) {						pr_info("Duplicate PD's @"							"[%d:%d]/[%d:%d]\n",						     set, way, set, n);						pr_info("TLBPD0[%u]: %08x\n",						     way, pd0[way]);					}					/*					 * clear entry @way and not @n. This is					 * critical to our optimised loop					 */					pd0[way] = pd1[way] = 0;					write_aux_reg(ARC_REG_TLBINDEX,						SET_WAY_TO_IDX(mmu, set, way));					__tlb_entry_erase();				}			}		}	}	local_irq_restore(flags);}
void
do_tlb_overlap_fault(unsigned long cause, unsigned long address,			  struct pt_regs *regs)
do_tlb_overlap_fault
unsigned long cause
unsigned long
cause
cause
unsigned long address
unsigned long
address
address
struct pt_regs *regs
struct pt_regs
pt_regs
*regs
*
regs
{	int set, way, n;	unsigned long flags, is_valid;	struct cpuinfo_arc_mmu *mmu = &cpuinfo_arc700[smp_processor_id()].mmu;	unsigned int pd0[mmu->ways], pd1[mmu->ways];	local_irq_save(flags);	/* re-enable the MMU */	write_aux_reg(ARC_REG_PID, MMU_ENABLE | read_aux_reg(ARC_REG_PID));	/* loop thru all sets of TLB */	for (set = 0; set < mmu->sets; set++) {		/* read out all the ways of current set */		for (way = 0, is_valid = 0; way < mmu->ways; way++) {			write_aux_reg(ARC_REG_TLBINDEX,					  SET_WAY_TO_IDX(mmu, set, way));			write_aux_reg(ARC_REG_TLBCOMMAND, TLBRead);			pd0[way] = read_aux_reg(ARC_REG_TLBPD0);			pd1[way] = read_aux_reg(ARC_REG_TLBPD1);			is_valid |= pd0[way] & _PAGE_PRESENT;		}		/* If all the WAYS in SET are empty, skip to next SET */		if (!is_valid)			continue;		/* Scan the set for duplicate ways: needs a nested loop */		for (way = 0; way < mmu->ways - 1; way++) {			if (!pd0[way])				continue;			for (n = way + 1; n < mmu->ways; n++) {				if ((pd0[way] & PAGE_MASK) ==				    (pd0[n] & PAGE_MASK)) {					if (dup_pd_verbose) {						pr_info("Duplicate PD's @"							"[%d:%d]/[%d:%d]\n",						     set, way, set, n);						pr_info("TLBPD0[%u]: %08x\n",						     way, pd0[way]);					}					/*					 * clear entry @way and not @n. This is					 * critical to our optimised loop					 */					pd0[way] = pd1[way] = 0;					write_aux_reg(ARC_REG_TLBINDEX,						SET_WAY_TO_IDX(mmu, set, way));					__tlb_entry_erase();				}			}		}	}	local_irq_restore(flags);}
int set, way, n;
int set, way, n;
int
set
set
way
way
n
n
unsigned long flags, is_valid;
unsigned long flags, is_valid;
unsigned long
flags
flags
is_valid
is_valid
struct cpuinfo_arc_mmu *mmu = &cpuinfo_arc700[smp_processor_id()].mmu;
struct cpuinfo_arc_mmu *mmu = &cpuinfo_arc700[smp_processor_id()].mmu;
struct cpuinfo_arc_mmu
cpuinfo_arc_mmu
*mmu = &cpuinfo_arc700[smp_processor_id()].mmu
*
mmu
= &cpuinfo_arc700[smp_processor_id()].mmu
&cpuinfo_arc700[smp_processor_id()].mmu
cpuinfo_arc700[smp_processor_id()].mmu
cpuinfo_arc700[smp_processor_id()]
cpuinfo_arc700
cpuinfo_arc700
smp_processor_id()
smp_processor_id
smp_processor_id
mmu
unsigned int pd0[mmu->ways], pd1[mmu->ways];
unsigned int pd0[mmu->ways], pd1[mmu->ways];
unsigned int
pd0[mmu->ways]
pd0
[mmu->ways]
mmu->ways
mmu
mmu
ways
pd1[mmu->ways]
pd1
[mmu->ways]
mmu->ways
mmu
mmu
ways
local_irq_save(flags);
local_irq_save(flags)
local_irq_save
local_irq_save
flags
flags
write_aux_reg(ARC_REG_PID, MMU_ENABLE | read_aux_reg(ARC_REG_PID));
write_aux_reg(ARC_REG_PID, MMU_ENABLE | read_aux_reg(ARC_REG_PID))
write_aux_reg
write_aux_reg
ARC_REG_PID
ARC_REG_PID
MMU_ENABLE | read_aux_reg(ARC_REG_PID)
MMU_ENABLE
MMU_ENABLE
read_aux_reg(ARC_REG_PID)
read_aux_reg
read_aux_reg
ARC_REG_PID
ARC_REG_PID
for (set = 0; set < mmu->sets; set++) {		/* read out all the ways of current set */		for (way = 0, is_valid = 0; way < mmu->ways; way++) {			write_aux_reg(ARC_REG_TLBINDEX,					  SET_WAY_TO_IDX(mmu, set, way));			write_aux_reg(ARC_REG_TLBCOMMAND, TLBRead);			pd0[way] = read_aux_reg(ARC_REG_TLBPD0);			pd1[way] = read_aux_reg(ARC_REG_TLBPD1);			is_valid |= pd0[way] & _PAGE_PRESENT;		}		/* If all the WAYS in SET are empty, skip to next SET */		if (!is_valid)			continue;		/* Scan the set for duplicate ways: needs a nested loop */		for (way = 0; way < mmu->ways - 1; way++) {			if (!pd0[way])				continue;			for (n = way + 1; n < mmu->ways; n++) {				if ((pd0[way] & PAGE_MASK) ==				    (pd0[n] & PAGE_MASK)) {					if (dup_pd_verbose) {						pr_info("Duplicate PD's @"							"[%d:%d]/[%d:%d]\n",						     set, way, set, n);						pr_info("TLBPD0[%u]: %08x\n",						     way, pd0[way]);					}					/*					 * clear entry @way and not @n. This is					 * critical to our optimised loop					 */					pd0[way] = pd1[way] = 0;					write_aux_reg(ARC_REG_TLBINDEX,						SET_WAY_TO_IDX(mmu, set, way));					__tlb_entry_erase();				}			}		}	}
set = 0;
set = 0
set
set
0
set < mmu->sets
set
set
mmu->sets
mmu
mmu
sets
set++
set
set
{		/* read out all the ways of current set */		for (way = 0, is_valid = 0; way < mmu->ways; way++) {			write_aux_reg(ARC_REG_TLBINDEX,					  SET_WAY_TO_IDX(mmu, set, way));			write_aux_reg(ARC_REG_TLBCOMMAND, TLBRead);			pd0[way] = read_aux_reg(ARC_REG_TLBPD0);			pd1[way] = read_aux_reg(ARC_REG_TLBPD1);			is_valid |= pd0[way] & _PAGE_PRESENT;		}		/* If all the WAYS in SET are empty, skip to next SET */		if (!is_valid)			continue;		/* Scan the set for duplicate ways: needs a nested loop */		for (way = 0; way < mmu->ways - 1; way++) {			if (!pd0[way])				continue;			for (n = way + 1; n < mmu->ways; n++) {				if ((pd0[way] & PAGE_MASK) ==				    (pd0[n] & PAGE_MASK)) {					if (dup_pd_verbose) {						pr_info("Duplicate PD's @"							"[%d:%d]/[%d:%d]\n",						     set, way, set, n);						pr_info("TLBPD0[%u]: %08x\n",						     way, pd0[way]);					}					/*					 * clear entry @way and not @n. This is					 * critical to our optimised loop					 */					pd0[way] = pd1[way] = 0;					write_aux_reg(ARC_REG_TLBINDEX,						SET_WAY_TO_IDX(mmu, set, way));					__tlb_entry_erase();				}			}		}	}
for (way = 0, is_valid = 0; way < mmu->ways; way++) {			write_aux_reg(ARC_REG_TLBINDEX,					  SET_WAY_TO_IDX(mmu, set, way));			write_aux_reg(ARC_REG_TLBCOMMAND, TLBRead);			pd0[way] = read_aux_reg(ARC_REG_TLBPD0);			pd1[way] = read_aux_reg(ARC_REG_TLBPD1);			is_valid |= pd0[way] & _PAGE_PRESENT;		}
way = 0, is_valid = 0;
way = 0, is_valid = 0
way = 0
way
way
0
is_valid = 0
is_valid
is_valid
0
way < mmu->ways
way
way
mmu->ways
mmu
mmu
ways
way++
way
way
{			write_aux_reg(ARC_REG_TLBINDEX,					  SET_WAY_TO_IDX(mmu, set, way));			write_aux_reg(ARC_REG_TLBCOMMAND, TLBRead);			pd0[way] = read_aux_reg(ARC_REG_TLBPD0);			pd1[way] = read_aux_reg(ARC_REG_TLBPD1);			is_valid |= pd0[way] & _PAGE_PRESENT;		}
write_aux_reg(ARC_REG_TLBINDEX,					  SET_WAY_TO_IDX(mmu, set, way));
write_aux_reg(ARC_REG_TLBINDEX,					  SET_WAY_TO_IDX(mmu, set, way))
write_aux_reg
write_aux_reg
ARC_REG_TLBINDEX
ARC_REG_TLBINDEX
SET_WAY_TO_IDX(mmu, set, way)
SET_WAY_TO_IDX
SET_WAY_TO_IDX
mmu
mmu
set
set
way
way
write_aux_reg(ARC_REG_TLBCOMMAND, TLBRead);
write_aux_reg(ARC_REG_TLBCOMMAND, TLBRead)
write_aux_reg
write_aux_reg
ARC_REG_TLBCOMMAND
ARC_REG_TLBCOMMAND
TLBRead
TLBRead
pd0[way] = read_aux_reg(ARC_REG_TLBPD0);
pd0[way] = read_aux_reg(ARC_REG_TLBPD0)
pd0[way]
pd0
pd0
way
way
read_aux_reg(ARC_REG_TLBPD0)
read_aux_reg
read_aux_reg
ARC_REG_TLBPD0
ARC_REG_TLBPD0
pd1[way] = read_aux_reg(ARC_REG_TLBPD1);
pd1[way] = read_aux_reg(ARC_REG_TLBPD1)
pd1[way]
pd1
pd1
way
way
read_aux_reg(ARC_REG_TLBPD1)
read_aux_reg
read_aux_reg
ARC_REG_TLBPD1
ARC_REG_TLBPD1
is_valid |= pd0[way] & _PAGE_PRESENT;
is_valid |= pd0[way] & _PAGE_PRESENT
is_valid
is_valid
pd0[way] & _PAGE_PRESENT
pd0[way]
pd0
pd0
way
way
_PAGE_PRESENT
_PAGE_PRESENT
if (!is_valid)			continue;
!is_valid
is_valid
is_valid
continue;
for (way = 0; way < mmu->ways - 1; way++) {			if (!pd0[way])				continue;			for (n = way + 1; n < mmu->ways; n++) {				if ((pd0[way] & PAGE_MASK) ==				    (pd0[n] & PAGE_MASK)) {					if (dup_pd_verbose) {						pr_info("Duplicate PD's @"							"[%d:%d]/[%d:%d]\n",						     set, way, set, n);						pr_info("TLBPD0[%u]: %08x\n",						     way, pd0[way]);					}					/*					 * clear entry @way and not @n. This is					 * critical to our optimised loop					 */					pd0[way] = pd1[way] = 0;					write_aux_reg(ARC_REG_TLBINDEX,						SET_WAY_TO_IDX(mmu, set, way));					__tlb_entry_erase();				}			}		}
way = 0;
way = 0
way
way
0
way < mmu->ways - 1
way
way
mmu->ways - 1
mmu->ways
mmu
mmu
ways
1
way++
way
way
{			if (!pd0[way])				continue;			for (n = way + 1; n < mmu->ways; n++) {				if ((pd0[way] & PAGE_MASK) ==				    (pd0[n] & PAGE_MASK)) {					if (dup_pd_verbose) {						pr_info("Duplicate PD's @"							"[%d:%d]/[%d:%d]\n",						     set, way, set, n);						pr_info("TLBPD0[%u]: %08x\n",						     way, pd0[way]);					}					/*					 * clear entry @way and not @n. This is					 * critical to our optimised loop					 */					pd0[way] = pd1[way] = 0;					write_aux_reg(ARC_REG_TLBINDEX,						SET_WAY_TO_IDX(mmu, set, way));					__tlb_entry_erase();				}			}		}
if (!pd0[way])				continue;
!pd0[way]
pd0[way]
pd0
pd0
way
way
continue;
for (n = way + 1; n < mmu->ways; n++) {				if ((pd0[way] & PAGE_MASK) ==				    (pd0[n] & PAGE_MASK)) {					if (dup_pd_verbose) {						pr_info("Duplicate PD's @"							"[%d:%d]/[%d:%d]\n",						     set, way, set, n);						pr_info("TLBPD0[%u]: %08x\n",						     way, pd0[way]);					}					/*					 * clear entry @way and not @n. This is					 * critical to our optimised loop					 */					pd0[way] = pd1[way] = 0;					write_aux_reg(ARC_REG_TLBINDEX,						SET_WAY_TO_IDX(mmu, set, way));					__tlb_entry_erase();				}			}
n = way + 1;
n = way + 1
n
n
way + 1
way
way
1
n < mmu->ways
n
n
mmu->ways
mmu
mmu
ways
n++
n
n
{				if ((pd0[way] & PAGE_MASK) ==				    (pd0[n] & PAGE_MASK)) {					if (dup_pd_verbose) {						pr_info("Duplicate PD's @"							"[%d:%d]/[%d:%d]\n",						     set, way, set, n);						pr_info("TLBPD0[%u]: %08x\n",						     way, pd0[way]);					}					/*					 * clear entry @way and not @n. This is					 * critical to our optimised loop					 */					pd0[way] = pd1[way] = 0;					write_aux_reg(ARC_REG_TLBINDEX,						SET_WAY_TO_IDX(mmu, set, way));					__tlb_entry_erase();				}			}
if ((pd0[way] & PAGE_MASK) ==				    (pd0[n] & PAGE_MASK)) {					if (dup_pd_verbose) {						pr_info("Duplicate PD's @"							"[%d:%d]/[%d:%d]\n",						     set, way, set, n);						pr_info("TLBPD0[%u]: %08x\n",						     way, pd0[way]);					}					/*					 * clear entry @way and not @n. This is					 * critical to our optimised loop					 */					pd0[way] = pd1[way] = 0;					write_aux_reg(ARC_REG_TLBINDEX,						SET_WAY_TO_IDX(mmu, set, way));					__tlb_entry_erase();				}
(pd0[way] & PAGE_MASK) ==				    (pd0[n] & PAGE_MASK)
(pd0[way] & PAGE_MASK)
pd0[way] & PAGE_MASK
pd0[way]
pd0
pd0
way
way
PAGE_MASK
PAGE_MASK
(pd0[n] & PAGE_MASK)
pd0[n] & PAGE_MASK
pd0[n]
pd0
pd0
n
n
PAGE_MASK
PAGE_MASK
{					if (dup_pd_verbose) {						pr_info("Duplicate PD's @"							"[%d:%d]/[%d:%d]\n",						     set, way, set, n);						pr_info("TLBPD0[%u]: %08x\n",						     way, pd0[way]);					}					/*					 * clear entry @way and not @n. This is					 * critical to our optimised loop					 */					pd0[way] = pd1[way] = 0;					write_aux_reg(ARC_REG_TLBINDEX,						SET_WAY_TO_IDX(mmu, set, way));					__tlb_entry_erase();				}
if (dup_pd_verbose) {						pr_info("Duplicate PD's @"							"[%d:%d]/[%d:%d]\n",						     set, way, set, n);						pr_info("TLBPD0[%u]: %08x\n",						     way, pd0[way]);					}
dup_pd_verbose
dup_pd_verbose
{						pr_info("Duplicate PD's @"							"[%d:%d]/[%d:%d]\n",						     set, way, set, n);						pr_info("TLBPD0[%u]: %08x\n",						     way, pd0[way]);					}
pr_info("Duplicate PD's @"							"[%d:%d]/[%d:%d]\n",						     set, way, set, n);
pr_info("Duplicate PD's @"							"[%d:%d]/[%d:%d]\n",						     set, way, set, n)
pr_info
pr_info
"Duplicate PD's @"							"[%d:%d]/[%d:%d]\n"
set
set
way
way
set
set
n
n
pr_info("TLBPD0[%u]: %08x\n",						     way, pd0[way]);
pr_info("TLBPD0[%u]: %08x\n",						     way, pd0[way])
pr_info
pr_info
"TLBPD0[%u]: %08x\n"
way
way
pd0[way]
pd0
pd0
way
way
pd0[way] = pd1[way] = 0;
pd0[way] = pd1[way] = 0
pd0[way]
pd0
pd0
way
way
pd1[way] = 0
pd1[way]
pd1
pd1
way
way
0
write_aux_reg(ARC_REG_TLBINDEX,						SET_WAY_TO_IDX(mmu, set, way));
write_aux_reg(ARC_REG_TLBINDEX,						SET_WAY_TO_IDX(mmu, set, way))
write_aux_reg
write_aux_reg
ARC_REG_TLBINDEX
ARC_REG_TLBINDEX
SET_WAY_TO_IDX(mmu, set, way)
SET_WAY_TO_IDX
SET_WAY_TO_IDX
mmu
mmu
set
set
way
way
__tlb_entry_erase();
__tlb_entry_erase()
__tlb_entry_erase
__tlb_entry_erase
local_irq_restore(flags);
local_irq_restore(flags)
local_irq_restore
local_irq_restore
flags
flags
-----joern-----
(116,152,0)
(151,24,0)
(89,92,0)
(158,43,0)
(89,87,0)
(40,16,0)
(16,106,0)
(88,31,0)
(7,72,0)
(144,26,0)
(127,150,0)
(34,16,0)
(87,43,0)
(64,61,0)
(19,24,0)
(79,84,0)
(36,11,0)
(153,77,0)
(87,89,0)
(22,74,0)
(91,156,0)
(73,158,0)
(25,72,0)
(6,163,0)
(121,110,0)
(33,151,0)
(13,106,0)
(59,36,0)
(124,147,0)
(78,135,0)
(161,55,0)
(8,38,0)
(86,158,0)
(85,84,0)
(65,110,0)
(98,101,0)
(43,52,0)
(133,106,0)
(32,61,0)
(154,128,0)
(120,72,0)
(103,5,0)
(107,65,0)
(126,65,0)
(35,16,0)
(148,19,0)
(157,28,0)
(112,133,0)
(6,6,0)
(15,131,0)
(64,11,0)
(129,66,0)
(153,128,0)
(63,110,0)
(55,161,0)
(39,106,0)
(118,108,0)
(160,159,0)
(18,147,0)
(31,104,0)
(113,78,0)
(14,11,0)
(125,108,0)
(37,157,0)
(19,147,0)
(10,41,0)
(143,147,0)
(143,159,0)
(70,74,0)
(29,147,0)
(42,106,0)
(12,72,0)
(21,63,0)
(78,43,0)
(60,24,0)
(38,11,0)
(128,153,0)
(100,143,0)
(74,22,0)
(124,11,0)
(3,124,0)
(17,38,0)
(44,19,0)
(140,150,0)
(161,163,0)
(138,72,0)
(30,19,0)
(139,89,0)
(158,147,0)
(158,104,0)
(148,108,0)
(61,24,0)
(155,18,0)
(19,110,0)
(106,28,0)
(27,128,0)
(135,78,0)
(52,43,0)
(16,35,0)
(41,159,0)
(38,110,0)
(96,52,0)
(81,65,0)
(76,35,0)
(48,163,0)
(123,6,0)
(38,147,0)
(146,72,0)
(74,70,0)
(87,104,0)
(48,65,0)
(149,38,0)
(65,106,0)
(84,43,0)
(151,101,0)
(67,54,0)
(24,72,0)
(68,157,0)
(43,163,0)
(165,70,0)
(158,150,0)
(19,148,0)
(0,72,0)
(53,148,0)
(164,72,0)
(20,19,0)
(6,157,0)
(78,147,0)
(23,147,0)
(105,59,0)
(45,87,0)
(38,92,0)
(35,6,0)
(137,64,0)
(99,11,0)
(93,124,0)
(122,157,0)
(22,72,0)
(142,5,0)
(77,153,0)
(101,151,0)
(104,156,0)
(89,147,0)
(94,26,0)
(141,24,0)
(95,38,0)
(109,26,0)
(159,41,0)
(54,156,0)
(56,66,0)
(134,110,0)
(57,141,0)
(150,127,0)
(46,36,0)
(141,131,0)
(41,24,0)
(27,24,0)
(114,78,0)
(97,31,0)
(87,147,0)
(84,106,0)
(62,41,0)
(90,13,0)
(47,55,0)
(50,122,0)
(132,87,0)
(162,14,0)
(115,74,0)
(61,64,0)
(122,6,0)
(130,89,0)
(4,72,0)
(75,54,0)
(24,27,0)
(111,61,0)
(5,163,0)
(150,158,0)
(104,108,0)
(159,143,0)
(131,110,0)
(71,22,0)
(54,147,0)
(145,133,0)
(133,161,0)
(11,124,0)
(58,4,0)
(117,72,0)
(136,38,0)
(16,104,0)
(6,35,0)
(127,59,0)
(65,48,0)
(102,151,0)
(65,24,0)
(78,104,0)
(59,127,0)
(131,141,0)
(80,12,0)
(101,106,0)
(9,72,0)
(51,48,0)
(31,147,0)
(1,141,0)
(16,43,0)
(156,104,0)
(36,59,0)
(49,36,0)
(128,27,0)
(82,153,0)
(81,107,1)
(21,119,1)
(35,16,1)
(64,61,1)
(39,42,1)
(131,141,1)
(18,155,1)
(136,17,1)
(89,147,1)
(91,54,1)
(50,101,1)
(127,150,1)
(88,97,1)
(22,74,1)
(102,33,1)
(14,162,1)
(14,11,1)
(78,147,1)
(36,11,1)
(46,49,1)
(24,27,1)
(47,133,1)
(54,75,1)
(98,157,1)
(89,87,1)
(128,154,1)
(97,69,1)
(19,110,1)
(134,121,1)
(19,24,1)
(145,112,1)
(37,106,1)
(13,90,1)
(29,122,1)
(43,52,1)
(159,41,1)
(135,78,1)
(10,62,1)
(155,83,1)
(84,106,1)
(87,45,1)
(4,58,1)
(54,147,1)
(147,23,1)
(59,105,1)
(38,8,1)
(16,34,1)
(113,114,1)
(128,153,1)
(112,43,1)
(38,11,1)
(65,106,1)
(16,104,1)
(45,132,1)
(148,19,1)
(17,69,1)
(15,63,1)
(70,165,1)
(101,106,1)
(68,37,1)
(6,157,1)
(137,11,1)
(85,79,1)
(44,20,1)
(149,136,1)
(59,36,1)
(99,135,1)
(97,89,1)
(143,147,1)
(96,84,1)
(141,1,1)
(127,59,1)
(101,151,1)
(74,70,1)
(73,86,1)
(82,60,1)
(87,43,1)
(27,128,1)
(61,111,1)
(31,88,1)
(95,149,1)
(65,110,1)
(103,142,1)
(2,4,1)
(133,106,1)
(162,125,1)
(12,80,1)
(150,140,1)
(142,48,1)
(87,104,1)
(48,65,1)
(123,161,1)
(38,110,1)
(38,147,1)
(139,130,1)
(57,15,1)
(21,143,1)
(11,124,1)
(160,41,1)
(115,71,1)
(33,98,1)
(158,147,1)
(36,46,1)
(125,148,1)
(110,134,1)
(52,96,1)
(6,35,1)
(165,115,1)
(42,131,1)
(121,22,1)
(65,126,1)
(80,24,1)
(140,158,1)
(126,81,1)
(78,113,1)
(13,106,1)
(100,18,1)
(15,110,1)
(105,36,1)
(23,29,1)
(53,104,1)
(84,85,1)
(153,77,1)
(69,127,1)
(90,6,1)
(78,104,1)
(133,145,1)
(19,44,1)
(32,137,1)
(106,39,1)
(151,102,1)
(30,53,1)
(41,10,1)
(143,159,1)
(162,127,1)
(161,55,1)
(63,110,1)
(159,160,1)
(151,24,1)
(158,73,1)
(1,57,1)
(158,104,1)
(35,76,1)
(79,5,1)
(155,64,1)
(131,110,1)
(107,51,1)
(158,43,1)
(87,147,1)
(132,139,1)
(122,157,1)
(41,24,1)
(64,11,1)
(19,147,1)
(119,122,1)
(3,99,1)
(122,50,1)
(111,32,1)
(83,135,1)
(76,16,1)
(124,93,1)
(40,123,1)
(55,47,1)
(78,43,1)
(86,64,1)
(8,95,1)
(62,100,1)
(137,14,1)
(31,147,1)
(156,91,1)
(100,147,1)
(63,21,1)
(77,82,1)
(34,40,1)
(98,13,1)
(61,24,1)
(67,31,1)
(51,101,1)
(130,38,1)
(65,24,1)
(71,12,1)
(58,131,1)
(5,103,1)
(114,143,1)
(93,3,1)
(18,147,1)
(16,106,1)
(122,6,1)
(20,30,1)
(16,43,1)
(150,158,1)
(6,6,1)
(75,67,1)
(104,156,1)
(141,24,1)
(157,68,1)
(49,150,1)
(124,147,1)
(154,153,1)
(98,101,2)
(22,74,2)
(49,64,2)
(112,101,2)
(23,122,2)
(76,101,2)
(88,127,2)
(122,131,2)
(159,41,2)
(32,64,2)
(43,101,2)
(48,101,2)
(24,27,2)
(131,131,2)
(87,147,2)
(55,101,2)
(18,147,2)
(42,131,2)
(127,150,2)
(78,143,2)
(59,64,2)
(113,143,2)
(87,104,2)
(54,147,2)
(99,135,2)
(96,101,2)
(79,101,2)
(15,131,2)
(40,101,2)
(148,19,2)
(119,122,2)
(89,87,2)
(19,147,2)
(38,69,2)
(111,64,2)
(63,131,2)
(155,143,2)
(21,131,2)
(69,127,2)
(35,101,2)
(103,101,2)
(39,131,2)
(87,69,2)
(14,11,2)
(73,64,2)
(6,157,2)
(19,110,2)
(101,151,2)
(161,55,2)
(64,135,2)
(101,131,2)
(95,69,2)
(137,135,2)
(44,127,2)
(100,122,2)
(106,131,2)
(102,101,2)
(65,110,2)
(136,69,2)
(29,122,2)
(48,65,2)
(74,70,2)
(11,124,2)
(135,143,2)
(61,135,2)
(65,24,2)
(35,16,2)
(122,6,2)
(133,101,2)
(151,101,2)
(37,131,2)
(141,131,2)
(51,101,2)
(150,158,2)
(6,35,2)
(17,69,2)
(160,143,2)
(83,135,2)
(62,143,2)
(158,64,2)
(78,43,2)
(111,135,2)
(86,64,2)
(3,135,2)
(50,131,2)
(114,143,2)
(123,101,2)
(19,127,2)
(67,127,2)
(125,127,2)
(133,106,2)
(13,106,2)
(159,122,2)
(153,77,2)
(89,69,2)
(65,101,2)
(143,122,2)
(139,69,2)
(142,101,2)
(132,69,2)
(151,24,2)
(16,101,2)
(64,61,2)
(61,64,2)
(157,131,2)
(32,135,2)
(45,69,2)
(89,147,2)
(97,127,2)
(151,131,2)
(68,131,2)
(20,127,2)
(101,101,2)
(158,147,2)
(6,101,2)
(33,131,2)
(78,147,2)
(140,64,2)
(158,43,2)
(33,101,2)
(93,135,2)
(8,69,2)
(126,101,2)
(81,101,2)
(156,127,2)
(30,127,2)
(10,143,2)
(18,143,2)
(135,78,2)
(36,11,2)
(85,101,2)
(147,122,2)
(38,147,2)
(143,143,2)
(53,127,2)
(31,127,2)
(137,64,2)
(41,122,2)
(143,147,2)
(75,127,2)
(102,131,2)
(47,101,2)
(101,106,2)
(150,64,2)
(160,122,2)
(65,106,2)
(158,104,2)
(62,122,2)
(16,43,2)
(41,143,2)
(43,52,2)
(98,131,2)
(5,101,2)
(143,159,2)
(78,104,2)
(36,64,2)
(1,131,2)
(159,143,2)
(127,64,2)
(38,11,2)
(10,122,2)
(107,101,2)
(52,101,2)
(105,64,2)
(59,36,2)
(31,147,2)
(124,147,2)
(84,106,2)
(87,43,2)
(104,156,2)
(6,6,2)
(149,69,2)
(16,104,2)
(14,64,2)
(145,101,2)
(161,101,2)
(34,101,2)
(38,110,2)
(57,131,2)
(90,101,2)
(54,127,2)
(41,24,2)
(127,59,2)
(122,157,2)
(130,69,2)
(64,11,2)
(141,24,2)
(63,110,2)
(61,24,2)
(13,101,2)
(100,143,2)
(148,127,2)
(131,110,2)
(104,127,2)
(46,64,2)
(11,135,2)
(124,135,2)
(84,101,2)
(16,106,2)
(128,153,2)
(19,24,2)
(64,64,2)
(91,127,2)
(162,64,2)
(131,141,2)
(27,128,2)
-----------------------------------
(0,is_valid)
(1,sets)
(2,RET)
(3,way)
(4,local_irq_restore(flags)
(5,write_aux_reg(ARC_REG_TLBCOMMAND, TLBRead)
(6,is_valid |= pd0[way] & _PAGE_PRESENT)
(7,n)
(8,n)
(9,pd0)
(10,ways)
(11,n = way + 1)
(12,local_irq_save(flags)
(13,way++)
(14,n++)
(15,set)
(16,pd0[way])
(17,"Duplicate PD\'s @"\n\\n\\t\\t\\t\\t\\t\\t\\t"[%d:%d]/[%d:%d]\\n")
(18,way++)
(19,SET_WAY_TO_IDX(mmu, set, way)
(20,set)
(21,set)
(22,write_aux_reg(ARC_REG_PID, MMU_ENABLE | read_aux_reg(ARC_REG_PID)
(23,0)
(24,*mmu = &cpuinfo_arc700[smp_processor_id()
(25,flags)
(26,)
(27,&cpuinfo_arc700[smp_processor_id()
(28,)
(29,way)
(30,mmu)
(31,pd0[way])
(32,mmu)
(33,mmu)
(34,way)
(35,pd0[way] & _PAGE_PRESENT)
(36,pd0[n])
(37,is_valid)
(38,pr_info("Duplicate PD\'s @"\n\\n\\t\\t\\t\\t\\t\\t\\t"[%d:%d]/[%d:%d]\\n",\n\\n\\t\\t\\t\\t\\t\\t     set, way, set, n)
(39,0)
(40,pd0)
(41,mmu->ways)
(42,way)
(43,pd0[way] = read_aux_reg(ARC_REG_TLBPD0)
(44,way)
(45,way)
(46,n)
(47,ARC_REG_TLBPD1)
(48,write_aux_reg(ARC_REG_TLBINDEX,\n\\n\\t\\t\\t\\t\\t  SET_WAY_TO_IDX(mmu, set, way)
(49,pd0)
(50,is_valid)
(51,ARC_REG_TLBINDEX)
(52,read_aux_reg(ARC_REG_TLBPD0)
(53,ARC_REG_TLBINDEX)
(54,pd1[way])
(55,read_aux_reg(ARC_REG_TLBPD1)
(56,for (n = way + 1; n < mmu->ways; n++)
(57,mmu)
(58,flags)
(59,pd0[n] & PAGE_MASK)
(60,mmu)
(61,mmu->ways)
(62,mmu)
(63,set++)
(64,n < mmu->ways)
(65,SET_WAY_TO_IDX(mmu, set, way)
(66,)
(67,pd1)
(68,0)
(69,dup_pd_verbose)
(70,read_aux_reg(ARC_REG_PID)
(71,ARC_REG_PID)
(72,)
(73,way)
(74,MMU_ENABLE | read_aux_reg(ARC_REG_PID)
(75,way)
(76,_PAGE_PRESENT)
(77,smp_processor_id()
(78,pd0[way])
(79,pd0)
(80,flags)
(81,set)
(82,cpuinfo_arc700)
(83,continue;)
(84,pd0[way])
(85,way)
(86,pd0)
(87,pd0[way])
(88,way)
(89,pr_info("TLBPD0[%u]: %08x\\n",\n\\n\\t\\t\\t\\t\\t\\t     way, pd0[way])
(90,way)
(91,0)
(92,)
(93,1)
(94,for (way = 0; way < mmu->ways - 1; way++)
(95,set)
(96,ARC_REG_TLBPD0)
(97,pd0)
(98,way)
(99,n)
(100,way)
(101,way < mmu->ways)
(102,ways)
(103,TLBRead)
(104,pd0[way] = pd1[way] = 0)
(105,PAGE_MASK)
(106,way = 0)
(107,mmu)
(108,)
(109,if (!is_valid)
(110,set = 0)
(111,ways)
(112,pd1)
(113,way)
(114,pd0)
(115,MMU_ENABLE)
(116,if ((pd0[way] & PAGE_MASK)
(117,way)
(118,if (dup_pd_verbose)
(119,continue;)
(120,set)
(121,set)
(122,!is_valid)
(123,is_valid)
(124,way + 1)
(125,__tlb_entry_erase()
(126,way)
(127,(pd0[way] & PAGE_MASK)
(128,cpuinfo_arc700[smp_processor_id()
(129,if (!pd0[way])
(130,"TLBPD0[%u]: %08x\\n")
(131,set < mmu->sets)
(132,pd0)
(133,pd1[way])
(134,0)
(135,!pd0[way])
(136,set)
(137,n)
(138,mmu)
(139,way)
(140,PAGE_MASK)
(141,mmu->sets)
(142,ARC_REG_TLBCOMMAND)
(143,way < mmu->ways - 1)
(144,for (way = 0, is_valid = 0; way < mmu->ways; way++)
(145,way)
(146,pd1)
(147,way = 0)
(148,write_aux_reg(ARC_REG_TLBINDEX,\n\\n\\t\\t\\t\\t\\t\\tSET_WAY_TO_IDX(mmu, set, way)
(149,way)
(150,pd0[way] & PAGE_MASK)
(151,mmu->ways)
(152,)
(153,cpuinfo_arc700[smp_processor_id()
(154,mmu)
(155,way)
(156,pd1[way] = 0)
(157,is_valid = 0)
(158,pd0[way])
(159,mmu->ways - 1)
(160,1)
(161,pd1[way] = read_aux_reg(ARC_REG_TLBPD1)
(162,n)
(163,)
(164,for (set = 0; set < mmu->sets; set++)
(165,ARC_REG_PID)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^