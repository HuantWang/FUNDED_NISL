-----label-----
0
-----code-----
static void mlx5_ib_disassociate_ucontext(struct ib_ucontext *ibcontext)
{
	int ret;
	struct vm_area_struct *vma;
	struct mlx5_ib_vma_private_data *vma_private, *n;
	struct mlx5_ib_ucontext *context = to_mucontext(ibcontext);
	struct task_struct *owning_process  = NULL;
	struct mm_struct   *owning_mm       = NULL;

	owning_process = get_pid_task(ibcontext->tgid, PIDTYPE_PID);
	if (!owning_process)
		return;

	owning_mm = get_task_mm(owning_process);
	if (!owning_mm) {
		pr_info("no mm, disassociate ucontext is pending task termination\n");
		while (1) {
			put_task_struct(owning_process);
			usleep_range(1000, 2000);
			owning_process = get_pid_task(ibcontext->tgid,
						      PIDTYPE_PID);
			if (!owning_process ||
			    owning_process->state == TASK_DEAD) {
				pr_info("disassociate ucontext done, task was terminated\n");
				/* in case task was dead need to release the
				 * task struct.
				 */
				if (owning_process)
					put_task_struct(owning_process);
				return;
			}
		}
	}

	/* need to protect from a race on closing the vma as part of
	 * mlx5_ib_vma_close.
	 */
	down_write(&owning_mm->mmap_sem);
	if (!mmget_still_valid(owning_mm))
		goto skip_mm;
	list_for_each_entry_safe(vma_private, n, &context->vma_private_list,
				 list) {
		vma = vma_private->vma;
		ret = zap_vma_ptes(vma, vma->vm_start,
				   PAGE_SIZE);
		WARN_ONCE(ret, "%s: zap_vma_ptes failed", __func__);
		/* context going to be destroyed, should
		 * not access ops any more.
		 */
		vma->vm_flags &= ~(VM_SHARED | VM_MAYSHARE);
		vma->vm_ops = NULL;
		list_del(&vma_private->list);
		kfree(vma_private);
	}
skip_mm:
	up_write(&owning_mm->mmap_sem);
	mmput(owning_mm);
	put_task_struct(owning_process);
}
-----children-----
1,2
1,3
1,4
3,4
3,5
5,6
5,7
6,7
8,9
8,10
11,12
11,13
11,14
11,15
11,16
11,17
11,18
11,19
11,20
11,21
11,22
11,23
11,24
11,25
11,26
11,27
11,28
11,29
12,13
13,14
13,15
15,16
17,18
18,19
18,20
19,20
21,22
21,23
24,25
25,26
25,27
25,28
26,27
28,29
28,30
31,32
31,33
34,35
35,36
35,37
36,37
38,39
38,40
38,41
41,42
42,43
42,44
43,44
45,46
47,48
48,49
48,50
49,50
51,52
51,53
51,54
54,55
55,56
57,58
58,59
58,60
59,60
61,62
61,63
61,64
64,65
65,66
67,68
68,69
68,70
69,70
71,72
71,73
71,74
72,73
74,75
74,76
75,76
78,79
80,81
80,82
81,82
82,83
85,86
86,87
86,88
87,88
89,90
89,91
90,91
92,93
94,95
94,96
95,96
96,97
98,99
98,100
99,100
100,101
100,102
101,102
104,105
104,106
106,107
106,108
106,109
106,110
107,108
108,109
108,110
109,110
111,112
113,114
114,115
114,116
114,117
115,116
119,120
120,121
120,122
121,122
123,124
123,125
123,126
124,125
126,127
126,128
127,128
130,131
132,133
132,134
133,134
133,135
134,135
135,136
137,138
137,139
138,139
138,140
139,140
142,143
144,145
144,146
144,147
145,146
146,147
146,148
147,148
150,151
150,152
151,152
153,154
154,155
154,156
155,156
157,158
160,161
161,162
161,163
162,163
164,165
165,166
165,167
166,167
169,170
169,171
170,171
171,172
171,173
172,173
174,175
176,177
178,179
179,180
179,181
179,182
179,183
179,184
180,181
182,183
184,185
186,187
187,188
187,189
188,189
191,192
193,194
194,195
194,196
194,197
194,198
194,199
194,200
194,201
195,196
196,197
196,198
197,198
199,200
199,201
200,201
203,204
204,205
204,206
205,206
207,208
207,209
207,210
207,211
208,209
210,211
212,213
212,214
213,214
216,217
218,219
219,220
219,221
219,222
219,223
220,221
222,223
225,226
227,228
228,229
228,230
229,230
229,231
230,231
233,234
234,235
235,236
235,237
236,237
238,239
240,241
241,242
241,243
242,243
242,244
243,244
246,247
248,249
249,250
249,251
250,251
252,253
253,254
253,255
254,255
257,258
258,259
258,260
259,260
261,262
263,264
263,265
265,266
266,267
266,268
267,268
269,270
270,271
270,272
271,272
274,275
275,276
275,277
276,277
278,279
280,281
281,282
281,283
282,283
284,285
-----nextToken-----
2,4,7,9,10,14,16,20,22,23,27,29,30,32,33,37,39,40,44,46,50,52,53,56,60,62,63,66,70,73,76,77,79,83,84,88,91,93,97,102,103,105,110,112,116,117,118,122,125,128,129,131,136,140,141,143,148,149,152,156,158,159,163,167,168,173,175,177,181,183,185,189,190,192,198,201,202,206,209,211,214,215,217,221,223,224,226,231,232,237,239,244,245,247,251,255,256,260,262,264,268,272,273,277,279,283,285
-----computeFrom-----
68,69
68,70
86,87
86,88
120,121
120,122
133,134
133,135
137,138
137,139
196,197
196,198
204,205
204,206
228,229
228,230
235,236
235,237
241,242
241,243
-----guardedBy-----
140,158
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;ReturnStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;WhileStatement;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;UnaryExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;GotoStatement;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ProblemStatement;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LabelStatement;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;
-----ast_node-----
static void mlx5_ib_disassociate_ucontext(struct ib_ucontext *ibcontext){	int ret;	struct vm_area_struct *vma;	struct mlx5_ib_vma_private_data *vma_private, *n;	struct mlx5_ib_ucontext *context = to_mucontext(ibcontext);	struct task_struct *owning_process  = NULL;	struct mm_struct   *owning_mm       = NULL;	owning_process = get_pid_task(ibcontext->tgid, PIDTYPE_PID);	if (!owning_process)		return;	owning_mm = get_task_mm(owning_process);	if (!owning_mm) {		pr_info("no mm, disassociate ucontext is pending task termination\n");		while (1) {			put_task_struct(owning_process);			usleep_range(1000, 2000);			owning_process = get_pid_task(ibcontext->tgid,						      PIDTYPE_PID);			if (!owning_process ||			    owning_process->state == TASK_DEAD) {				pr_info("disassociate ucontext done, task was terminated\n");				/* in case task was dead need to release the				 * task struct.				 */				if (owning_process)					put_task_struct(owning_process);				return;			}		}	}	/* need to protect from a race on closing the vma as part of	 * mlx5_ib_vma_close.	 */	down_write(&owning_mm->mmap_sem);	if (!mmget_still_valid(owning_mm))		goto skip_mm;	list_for_each_entry_safe(vma_private, n, &context->vma_private_list,				 list) {		vma = vma_private->vma;		ret = zap_vma_ptes(vma, vma->vm_start,				   PAGE_SIZE);		WARN_ONCE(ret, "%s: zap_vma_ptes failed", __func__);		/* context going to be destroyed, should		 * not access ops any more.		 */		vma->vm_flags &= ~(VM_SHARED | VM_MAYSHARE);		vma->vm_ops = NULL;		list_del(&vma_private->list);		kfree(vma_private);	}skip_mm:	up_write(&owning_mm->mmap_sem);	mmput(owning_mm);	put_task_struct(owning_process);}
static void
mlx5_ib_disassociate_ucontext(struct ib_ucontext *ibcontext)
mlx5_ib_disassociate_ucontext
struct ib_ucontext *ibcontext
struct ib_ucontext
ib_ucontext
*ibcontext
*
ibcontext
{	int ret;	struct vm_area_struct *vma;	struct mlx5_ib_vma_private_data *vma_private, *n;	struct mlx5_ib_ucontext *context = to_mucontext(ibcontext);	struct task_struct *owning_process  = NULL;	struct mm_struct   *owning_mm       = NULL;	owning_process = get_pid_task(ibcontext->tgid, PIDTYPE_PID);	if (!owning_process)		return;	owning_mm = get_task_mm(owning_process);	if (!owning_mm) {		pr_info("no mm, disassociate ucontext is pending task termination\n");		while (1) {			put_task_struct(owning_process);			usleep_range(1000, 2000);			owning_process = get_pid_task(ibcontext->tgid,						      PIDTYPE_PID);			if (!owning_process ||			    owning_process->state == TASK_DEAD) {				pr_info("disassociate ucontext done, task was terminated\n");				/* in case task was dead need to release the				 * task struct.				 */				if (owning_process)					put_task_struct(owning_process);				return;			}		}	}	/* need to protect from a race on closing the vma as part of	 * mlx5_ib_vma_close.	 */	down_write(&owning_mm->mmap_sem);	if (!mmget_still_valid(owning_mm))		goto skip_mm;	list_for_each_entry_safe(vma_private, n, &context->vma_private_list,				 list) {		vma = vma_private->vma;		ret = zap_vma_ptes(vma, vma->vm_start,				   PAGE_SIZE);		WARN_ONCE(ret, "%s: zap_vma_ptes failed", __func__);		/* context going to be destroyed, should		 * not access ops any more.		 */		vma->vm_flags &= ~(VM_SHARED | VM_MAYSHARE);		vma->vm_ops = NULL;		list_del(&vma_private->list);		kfree(vma_private);	}skip_mm:	up_write(&owning_mm->mmap_sem);	mmput(owning_mm);	put_task_struct(owning_process);}
int ret;
int ret;
int
ret
ret
struct vm_area_struct *vma;
struct vm_area_struct *vma;
struct vm_area_struct
vm_area_struct
*vma
*
vma
struct mlx5_ib_vma_private_data *vma_private, *n;
struct mlx5_ib_vma_private_data *vma_private, *n;
struct mlx5_ib_vma_private_data
mlx5_ib_vma_private_data
*vma_private
*
vma_private
*n
*
n
struct mlx5_ib_ucontext *context = to_mucontext(ibcontext);
struct mlx5_ib_ucontext *context = to_mucontext(ibcontext);
struct mlx5_ib_ucontext
mlx5_ib_ucontext
*context = to_mucontext(ibcontext)
*
context
= to_mucontext(ibcontext)
to_mucontext(ibcontext)
to_mucontext
to_mucontext
ibcontext
ibcontext
struct task_struct *owning_process  = NULL;
struct task_struct *owning_process  = NULL;
struct task_struct
task_struct
*owning_process  = NULL
*
owning_process
= NULL
NULL
NULL
struct mm_struct   *owning_mm       = NULL;
struct mm_struct   *owning_mm       = NULL;
struct mm_struct
mm_struct
*owning_mm       = NULL
*
owning_mm
= NULL
NULL
NULL
owning_process = get_pid_task(ibcontext->tgid, PIDTYPE_PID);
owning_process = get_pid_task(ibcontext->tgid, PIDTYPE_PID)
owning_process
owning_process
get_pid_task(ibcontext->tgid, PIDTYPE_PID)
get_pid_task
get_pid_task
ibcontext->tgid
ibcontext
ibcontext
tgid
PIDTYPE_PID
PIDTYPE_PID
if (!owning_process)		return;
!owning_process
owning_process
owning_process
return;
owning_mm = get_task_mm(owning_process);
owning_mm = get_task_mm(owning_process)
owning_mm
owning_mm
get_task_mm(owning_process)
get_task_mm
get_task_mm
owning_process
owning_process
if (!owning_mm) {		pr_info("no mm, disassociate ucontext is pending task termination\n");		while (1) {			put_task_struct(owning_process);			usleep_range(1000, 2000);			owning_process = get_pid_task(ibcontext->tgid,						      PIDTYPE_PID);			if (!owning_process ||			    owning_process->state == TASK_DEAD) {				pr_info("disassociate ucontext done, task was terminated\n");				/* in case task was dead need to release the				 * task struct.				 */				if (owning_process)					put_task_struct(owning_process);				return;			}		}	}
!owning_mm
owning_mm
owning_mm
{		pr_info("no mm, disassociate ucontext is pending task termination\n");		while (1) {			put_task_struct(owning_process);			usleep_range(1000, 2000);			owning_process = get_pid_task(ibcontext->tgid,						      PIDTYPE_PID);			if (!owning_process ||			    owning_process->state == TASK_DEAD) {				pr_info("disassociate ucontext done, task was terminated\n");				/* in case task was dead need to release the				 * task struct.				 */				if (owning_process)					put_task_struct(owning_process);				return;			}		}	}
pr_info("no mm, disassociate ucontext is pending task termination\n");
pr_info("no mm, disassociate ucontext is pending task termination\n")
pr_info
pr_info
"no mm, disassociate ucontext is pending task termination\n"
while (1) {			put_task_struct(owning_process);			usleep_range(1000, 2000);			owning_process = get_pid_task(ibcontext->tgid,						      PIDTYPE_PID);			if (!owning_process ||			    owning_process->state == TASK_DEAD) {				pr_info("disassociate ucontext done, task was terminated\n");				/* in case task was dead need to release the				 * task struct.				 */				if (owning_process)					put_task_struct(owning_process);				return;			}		}
1
{			put_task_struct(owning_process);			usleep_range(1000, 2000);			owning_process = get_pid_task(ibcontext->tgid,						      PIDTYPE_PID);			if (!owning_process ||			    owning_process->state == TASK_DEAD) {				pr_info("disassociate ucontext done, task was terminated\n");				/* in case task was dead need to release the				 * task struct.				 */				if (owning_process)					put_task_struct(owning_process);				return;			}		}
put_task_struct(owning_process);
put_task_struct(owning_process)
put_task_struct
put_task_struct
owning_process
owning_process
usleep_range(1000, 2000);
usleep_range(1000, 2000)
usleep_range
usleep_range
1000
2000
owning_process = get_pid_task(ibcontext->tgid,						      PIDTYPE_PID);
owning_process = get_pid_task(ibcontext->tgid,						      PIDTYPE_PID)
owning_process
owning_process
get_pid_task(ibcontext->tgid,						      PIDTYPE_PID)
get_pid_task
get_pid_task
ibcontext->tgid
ibcontext
ibcontext
tgid
PIDTYPE_PID
PIDTYPE_PID
if (!owning_process ||			    owning_process->state == TASK_DEAD) {				pr_info("disassociate ucontext done, task was terminated\n");				/* in case task was dead need to release the				 * task struct.				 */				if (owning_process)					put_task_struct(owning_process);				return;			}
!owning_process ||			    owning_process->state == TASK_DEAD
!owning_process
owning_process
owning_process
owning_process->state == TASK_DEAD
owning_process->state
owning_process
owning_process
state
TASK_DEAD
TASK_DEAD
{				pr_info("disassociate ucontext done, task was terminated\n");				/* in case task was dead need to release the				 * task struct.				 */				if (owning_process)					put_task_struct(owning_process);				return;			}
pr_info("disassociate ucontext done, task was terminated\n");
pr_info("disassociate ucontext done, task was terminated\n")
pr_info
pr_info
"disassociate ucontext done, task was terminated\n"
if (owning_process)					put_task_struct(owning_process);
owning_process
owning_process
put_task_struct(owning_process);
put_task_struct(owning_process)
put_task_struct
put_task_struct
owning_process
owning_process
return;
down_write(&owning_mm->mmap_sem);
down_write(&owning_mm->mmap_sem)
down_write
down_write
&owning_mm->mmap_sem
owning_mm->mmap_sem
owning_mm
owning_mm
mmap_sem
if (!mmget_still_valid(owning_mm))		goto skip_mm;
!mmget_still_valid(owning_mm)
mmget_still_valid(owning_mm)
mmget_still_valid
mmget_still_valid
owning_mm
owning_mm
goto skip_mm;
skip_mm
list_for_each_entry_safe(vma_private, n, &context->vma_private_list,				 list)
list_for_each_entry_safe(vma_private, n, &context->vma_private_list,				 list)
list_for_each_entry_safe
list_for_each_entry_safe
vma_private
vma_private
n
n
&context->vma_private_list
context->vma_private_list
context
context
vma_private_list
list
list
)
{		vma = vma_private->vma;		ret = zap_vma_ptes(vma, vma->vm_start,				   PAGE_SIZE);		WARN_ONCE(ret, "%s: zap_vma_ptes failed", __func__);		/* context going to be destroyed, should		 * not access ops any more.		 */		vma->vm_flags &= ~(VM_SHARED | VM_MAYSHARE);		vma->vm_ops = NULL;		list_del(&vma_private->list);		kfree(vma_private);	}
vma = vma_private->vma;
vma = vma_private->vma
vma
vma
vma_private->vma
vma_private
vma_private
vma
ret = zap_vma_ptes(vma, vma->vm_start,				   PAGE_SIZE);
ret = zap_vma_ptes(vma, vma->vm_start,				   PAGE_SIZE)
ret
ret
zap_vma_ptes(vma, vma->vm_start,				   PAGE_SIZE)
zap_vma_ptes
zap_vma_ptes
vma
vma
vma->vm_start
vma
vma
vm_start
PAGE_SIZE
PAGE_SIZE
WARN_ONCE(ret, "%s: zap_vma_ptes failed", __func__);
WARN_ONCE(ret, "%s: zap_vma_ptes failed", __func__)
WARN_ONCE
WARN_ONCE
ret
ret
"%s: zap_vma_ptes failed"
__func__
__func__
vma->vm_flags &= ~(VM_SHARED | VM_MAYSHARE);
vma->vm_flags &= ~(VM_SHARED | VM_MAYSHARE)
vma->vm_flags
vma
vma
vm_flags
~(VM_SHARED | VM_MAYSHARE)
(VM_SHARED | VM_MAYSHARE)
VM_SHARED | VM_MAYSHARE
VM_SHARED
VM_SHARED
VM_MAYSHARE
VM_MAYSHARE
vma->vm_ops = NULL;
vma->vm_ops = NULL
vma->vm_ops
vma
vma
vm_ops
NULL
NULL
list_del(&vma_private->list);
list_del(&vma_private->list)
list_del
list_del
&vma_private->list
vma_private->list
vma_private
vma_private
list
kfree(vma_private);
kfree(vma_private)
kfree
kfree
vma_private
vma_private
skip_mm:	up_write(&owning_mm->mmap_sem);
skip_mm
up_write(&owning_mm->mmap_sem);
up_write(&owning_mm->mmap_sem)
up_write
up_write
&owning_mm->mmap_sem
owning_mm->mmap_sem
owning_mm
owning_mm
mmap_sem
mmput(owning_mm);
mmput(owning_mm)
mmput
mmput
owning_mm
owning_mm
put_task_struct(owning_process);
put_task_struct(owning_process)
put_task_struct
put_task_struct
owning_process
owning_process
-----joern-----
(11,115,0)
(54,94,0)
(91,60,0)
(130,40,0)
(40,96,0)
(100,52,0)
(84,119,0)
(35,75,0)
(110,33,0)
(23,91,0)
(20,60,0)
(86,60,0)
(102,10,0)
(5,120,0)
(109,41,0)
(85,87,0)
(75,35,0)
(53,4,0)
(22,80,0)
(28,88,0)
(31,60,0)
(24,103,0)
(119,90,0)
(103,126,0)
(80,96,0)
(11,10,0)
(90,94,0)
(80,106,0)
(114,35,0)
(93,127,0)
(107,90,0)
(64,34,0)
(123,101,0)
(128,60,0)
(111,60,0)
(65,81,0)
(115,11,0)
(128,106,0)
(107,61,0)
(83,39,0)
(5,15,0)
(16,120,0)
(46,60,0)
(96,60,0)
(95,60,0)
(125,53,0)
(7,46,0)
(66,60,0)
(2,23,0)
(58,120,0)
(18,85,0)
(61,120,0)
(26,91,0)
(68,58,0)
(24,57,0)
(120,60,0)
(23,96,0)
(69,32,0)
(72,111,0)
(41,103,0)
(10,11,0)
(26,60,0)
(50,4,0)
(49,35,0)
(55,26,0)
(119,45,0)
(122,60,0)
(127,126,0)
(29,60,0)
(59,34,0)
(32,103,0)
(79,124,0)
(118,52,0)
(94,90,0)
(56,82,0)
(73,16,0)
(78,7,0)
(27,127,0)
(76,103,0)
(104,122,0)
(1,88,0)
(19,90,0)
(12,82,0)
(111,96,0)
(75,61,0)
(57,24,0)
(116,119,0)
(61,107,0)
(32,85,0)
(45,90,0)
(71,28,0)
(40,130,0)
(129,96,0)
(82,15,0)
(43,52,0)
(85,32,0)
(81,91,0)
(48,60,0)
(42,85,0)
(108,60,0)
(4,87,0)
(36,24,0)
(99,80,0)
(76,91,0)
(30,60,0)
(21,46,0)
(70,28,0)
(10,96,0)
(53,91,0)
(121,40,0)
(90,120,0)
(41,109,0)
(98,24,0)
(38,124,0)
(17,4,0)
(74,45,0)
(47,76,0)
(46,7,0)
(62,117,0)
(45,88,0)
(96,23,0)
(44,122,0)
(14,91,0)
(15,82,0)
(51,103,0)
(88,45,0)
(28,120,0)
(106,80,0)
(63,126,0)
(6,94,0)
(91,53,0)
(113,45,0)
(7,87,0)
(109,57,0)
(88,120,0)
(67,107,0)
(15,5,0)
(25,60,0)
(45,119,0)
(39,96,0)
(115,60,0)
(8,118,0)
(103,32,0)
(76,126,0)
(106,128,0)
(9,10,0)
(34,60,0)
(4,53,0)
(37,100,0)
(124,90,0)
(3,41,0)
(33,117,0)
(112,28,0)
(26,103,0)
(8,89,0)
(124,58,0)
(92,57,0)
(105,107,0)
(101,103,0)
(13,60,0)
(61,75,0)
(57,109,0)
(81,65,1)
(75,35,1)
(82,12,1)
(98,36,1)
(34,64,1)
(107,90,1)
(37,109,1)
(54,19,1)
(45,119,1)
(15,82,1)
(96,23,1)
(42,51,1)
(114,49,1)
(124,90,1)
(26,91,1)
(112,70,1)
(8,89,1)
(104,34,1)
(7,87,1)
(76,103,1)
(23,91,1)
(107,105,1)
(90,94,1)
(70,88,1)
(9,102,1)
(22,39,1)
(61,75,1)
(1,90,1)
(39,83,1)
(17,50,1)
(68,124,1)
(85,18,1)
(11,10,1)
(57,92,1)
(77,100,1)
(38,79,1)
(10,96,1)
(125,4,1)
(101,103,1)
(109,57,1)
(94,6,1)
(118,101,1)
(121,128,1)
(28,71,1)
(36,41,1)
(53,4,1)
(74,119,1)
(50,14,1)
(130,40,1)
(49,107,1)
(124,38,1)
(10,9,1)
(119,90,1)
(128,106,1)
(7,78,1)
(58,68,1)
(0,109,1)
(118,77,1)
(0,33,1)
(16,73,1)
(57,24,1)
(93,76,1)
(6,54,1)
(127,27,1)
(55,111,1)
(88,45,1)
(80,99,1)
(69,85,1)
(33,110,1)
(105,67,1)
(101,123,1)
(97,130,1)
(99,22,1)
(41,103,1)
(46,7,1)
(89,81,1)
(41,3,1)
(78,21,1)
(24,103,1)
(61,107,1)
(26,55,1)
(123,77,1)
(4,17,1)
(65,91,1)
(83,96,1)
(8,118,1)
(102,97,1)
(19,130,1)
(76,91,1)
(32,69,1)
(106,80,1)
(81,91,1)
(8,26,1)
(22,0,1)
(40,121,1)
(26,103,1)
(91,53,1)
(79,61,1)
(113,1,1)
(44,104,1)
(4,87,1)
(76,47,1)
(45,74,1)
(59,46,1)
(115,11,1)
(122,44,1)
(35,114,1)
(2,129,1)
(51,127,1)
(27,93,1)
(85,87,1)
(102,16,1)
(18,42,1)
(45,90,1)
(103,32,1)
(84,116,1)
(3,103,1)
(24,98,1)
(56,58,1)
(72,115,1)
(100,37,1)
(67,28,1)
(111,72,1)
(53,125,1)
(12,56,1)
(5,15,1)
(116,113,1)
(110,39,1)
(80,96,1)
(23,2,1)
(47,0,1)
(64,59,1)
(92,24,1)
(14,122,1)
(129,81,1)
(32,85,1)
(40,96,1)
(109,41,1)
(39,96,1)
(28,88,1)
(111,96,1)
(73,5,1)
(119,84,1)
(71,112,1)
(5,15,2)
(88,130,2)
(32,0,2)
(7,87,2)
(55,0,2)
(99,39,2)
(45,90,2)
(6,130,2)
(47,0,2)
(9,39,2)
(92,41,2)
(116,130,2)
(124,90,2)
(72,0,2)
(24,103,2)
(109,0,2)
(22,39,2)
(57,24,2)
(109,57,2)
(105,130,2)
(107,130,2)
(75,130,2)
(1,130,2)
(24,41,2)
(42,0,2)
(10,0,2)
(0,109,2)
(103,32,2)
(41,0,2)
(11,10,2)
(5,130,2)
(10,96,2)
(27,0,2)
(77,109,2)
(90,94,2)
(100,109,2)
(110,39,2)
(53,4,2)
(38,130,2)
(128,0,2)
(51,0,2)
(81,91,2)
(115,11,2)
(118,109,2)
(97,130,2)
(26,91,2)
(40,96,2)
(69,0,2)
(127,0,2)
(46,7,2)
(0,39,2)
(26,0,2)
(102,0,2)
(85,0,2)
(119,130,2)
(8,118,2)
(113,130,2)
(8,89,2)
(61,107,2)
(11,0,2)
(71,130,2)
(61,130,2)
(130,39,2)
(106,39,2)
(93,0,2)
(80,0,2)
(107,90,2)
(49,130,2)
(115,39,2)
(112,130,2)
(121,39,2)
(106,80,2)
(40,0,2)
(2,81,2)
(128,39,2)
(68,130,2)
(67,130,2)
(75,35,2)
(80,96,2)
(16,130,2)
(96,23,2)
(115,0,2)
(106,0,2)
(119,90,2)
(56,130,2)
(114,130,2)
(111,39,2)
(40,39,2)
(91,53,2)
(35,130,2)
(79,130,2)
(12,130,2)
(121,0,2)
(94,130,2)
(57,41,2)
(23,81,2)
(76,0,2)
(111,0,2)
(9,0,2)
(61,75,2)
(15,82,2)
(80,39,2)
(88,45,2)
(22,0,2)
(102,39,2)
(10,39,2)
(99,0,2)
(4,87,2)
(41,103,2)
(82,130,2)
(28,88,2)
(90,130,2)
(72,39,2)
(103,0,2)
(101,77,2)
(54,130,2)
(130,0,2)
(39,81,2)
(45,119,2)
(55,39,2)
(130,40,2)
(111,96,2)
(32,85,2)
(76,103,2)
(101,103,2)
(15,130,2)
(26,39,2)
(33,39,2)
(96,81,2)
(58,130,2)
(23,91,2)
(74,130,2)
(128,106,2)
(45,130,2)
(76,91,2)
(84,130,2)
(109,41,2)
(37,109,2)
(28,130,2)
(83,81,2)
(124,130,2)
(39,96,2)
(3,0,2)
(36,41,2)
(18,0,2)
(70,130,2)
(129,81,2)
(26,103,2)
(123,77,2)
(73,130,2)
(98,41,2)
(19,130,2)
(85,87,2)
(11,39,2)
(89,81,2)
-----------------------------------
(0,1)
(1,ret)
(2,owning_process)
(3,owning_process)
(4,ibcontext->tgid)
(5,list_del(&vma_private->list)
(6,vma)
(7,to_mucontext(ibcontext)
(8,RET)
(9,mmap_sem)
(10,owning_mm->mmap_sem)
(11,&owning_mm->mmap_sem)
(12,list)
(13,if (!owning_process)
(14,owning_process)
(15,&vma_private->list)
(16,kfree(vma_private)
(17,tgid)
(18,tgid)
(19,vma)
(20,skip_mm:)
(21,context)
(22,owning_mm)
(23,get_task_mm(owning_process)
(24,owning_process->state)
(25,if (!mmget_still_valid(owning_mm)
(26,put_task_struct(owning_process)
(27,2000)
(28,WARN_ONCE(ret, "%s: zap_vma_ptes failed", __func__)
(29,vma_private)
(30,owning_process)
(31,ret)
(32,get_pid_task(ibcontext->tgid,\n\\n\\t\\t\\t\\t\\t\\t      PIDTYPE_PID)
(33,pr_info("no mm, disassociate ucontext is pending task termination\\n")
(34,*owning_process  = NULL)
(35,VM_SHARED | VM_MAYSHARE)
(36,owning_process)
(37,"disassociate ucontext done, task was terminated\\n")
(38,vm_ops)
(39,!owning_mm)
(40,mmget_still_valid(owning_mm)
(41,!owning_process)
(42,ibcontext)
(43,if (owning_process)
(44,NULL)
(45,zap_vma_ptes(vma, vma->vm_start,\n\\n\\t\\t\\t\\t   PAGE_SIZE)
(46,*context = to_mucontext(ibcontext)
(47,owning_process)
(48,owning_mm)
(49,VM_SHARED)
(50,ibcontext)
(51,owning_process)
(52,)
(53,get_pid_task(ibcontext->tgid, PIDTYPE_PID)
(54,vma_private)
(55,owning_process)
(56,vma_private)
(57,owning_process->state == TASK_DEAD)
(58,vma->vm_ops = NULL)
(59,owning_process)
(60,)
(61,vma->vm_flags &= ~(VM_SHARED | VM_MAYSHARE)
(62,while (1)
(63,if (!owning_process ||\n\\n\\t\\t\\t    owning_process->state == TASK_DEAD)
(64,NULL)
(65,owning_process)
(66,n)
(67,vma)
(68,NULL)
(69,PIDTYPE_PID)
(70,ret)
(71,__func__)
(72,owning_mm)
(73,vma_private)
(74,PAGE_SIZE)
(75,~(VM_SHARED | VM_MAYSHARE)
(76,put_task_struct(owning_process)
(77,owning_process)
(78,ibcontext)
(79,vma)
(80,owning_mm->mmap_sem)
(81,!owning_process)
(82,vma_private->list)
(83,owning_mm)
(84,vm_start)
(85,ibcontext->tgid)
(86,vma)
(87,struct ib_ucontext *ibcontext)
(88,ret = zap_vma_ptes(vma, vma->vm_start,\n\\n\\t\\t\\t\\t   PAGE_SIZE)
(89,return;)
(90,vma = vma_private->vma)
(91,owning_process = get_pid_task(ibcontext->tgid, PIDTYPE_PID)
(92,TASK_DEAD)
(93,1000)
(94,vma_private->vma)
(95,if (!owning_mm)
(96,owning_mm = get_task_mm(owning_process)
(97,goto skip_mm;)
(98,state)
(99,mmap_sem)
(100,pr_info("disassociate ucontext done, task was terminated\\n")
(101,put_task_struct(owning_process)
(102,owning_mm)
(103,owning_process = get_pid_task(ibcontext->tgid,\n\\n\\t\\t\\t\\t\\t\\t      PIDTYPE_PID)
(104,owning_mm)
(105,vm_flags)
(106,&owning_mm->mmap_sem)
(107,vma->vm_flags)
(108,context)
(109,!owning_process ||\n\\n\\t\\t\\t    owning_process->state == TASK_DEAD)
(110,"no mm, disassociate ucontext is pending task termination\\n")
(111,mmput(owning_mm)
(112,"%s: zap_vma_ptes failed")
(113,vma)
(114,VM_MAYSHARE)
(115,up_write(&owning_mm->mmap_sem)
(116,vma)
(117,)
(118,return;)
(119,vma->vm_start)
(120,)
(121,owning_mm)
(122,*owning_mm       = NULL)
(123,owning_process)
(124,vma->vm_ops)
(125,PIDTYPE_PID)
(126,)
(127,usleep_range(1000, 2000)
(128,down_write(&owning_mm->mmap_sem)
(129,owning_mm)
(130,!mmget_still_valid(owning_mm)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^