-----label-----
0
-----code-----
static void dw_mci_tasklet_func(unsigned long priv)
{
	struct dw_mci *host = (struct dw_mci *)priv;
	struct mmc_data	*data;
	struct mmc_command *cmd;
	struct mmc_request *mrq;
	enum dw_mci_state state;
	enum dw_mci_state prev_state;
	unsigned int err;

	spin_lock(&host->lock);

	state = host->state;
	data = host->data;
	mrq = host->mrq;

	do {
		prev_state = state;

		switch (state) {
		case STATE_IDLE:
		case STATE_WAITING_CMD11_DONE:
			break;

		case STATE_SENDING_CMD11:
		case STATE_SENDING_CMD:
			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,
						&host->pending_events))
				break;

			cmd = host->cmd;
			host->cmd = NULL;
			set_bit(EVENT_CMD_COMPLETE, &host->completed_events);
			err = dw_mci_command_complete(host, cmd);
			if (cmd == mrq->sbc && !err) {
				prev_state = state = STATE_SENDING_CMD;
				__dw_mci_start_request(host, host->cur_slot,
						       mrq->cmd);
				goto unlock;
			}

			if (cmd->data && err) {
				/*
				 * During UHS tuning sequence, sending the stop
				 * command after the response CRC error would
				 * throw the system into a confused state
				 * causing all future tuning phases to report
				 * failure.
				 *
				 * In such case controller will move into a data
				 * transfer state after a response error or
				 * response CRC error. Let's let that finish
				 * before trying to send a stop, so we'll go to
				 * STATE_SENDING_DATA.
				 *
				 * Although letting the data transfer take place
				 * will waste a bit of time (we already know
				 * the command was bad), it can't cause any
				 * errors since it's possible it would have
				 * taken place anyway if this tasklet got
				 * delayed. Allowing the transfer to take place
				 * avoids races and keeps things simple.
				 */
				if ((err != -ETIMEDOUT) &&
				    (cmd->opcode == MMC_SEND_TUNING_BLOCK)) {
					state = STATE_SENDING_DATA;
					continue;
				}

				dw_mci_stop_dma(host);
				send_stop_abort(host, data);
				state = STATE_SENDING_STOP;
				break;
			}

			if (!cmd->data || err) {
				dw_mci_request_end(host, mrq);
				goto unlock;
			}

			prev_state = state = STATE_SENDING_DATA;
			/* fall through */

		case STATE_SENDING_DATA:
			/*
			 * We could get a data error and never a transfer
			 * complete so we'd better check for it here.
			 *
			 * Note that we don't really care if we also got a
			 * transfer complete; stopping the DMA and sending an
			 * abort won't hurt.
			 */
			if (test_and_clear_bit(EVENT_DATA_ERROR,
					       &host->pending_events)) {
				dw_mci_stop_dma(host);
				if (data->stop ||
				    !(host->data_status & (SDMMC_INT_DRTO |
							   SDMMC_INT_EBE)))
					send_stop_abort(host, data);
				state = STATE_DATA_ERROR;
				break;
			}

			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,
						&host->pending_events)) {
				/*
				 * If all data-related interrupts don't come
				 * within the given time in reading data state.
				 */
				if (host->dir_status == DW_MCI_RECV_STATUS)
					dw_mci_set_drto(host);
				break;
			}

			set_bit(EVENT_XFER_COMPLETE, &host->completed_events);

			/*
			 * Handle an EVENT_DATA_ERROR that might have shown up
			 * before the transfer completed.  This might not have
			 * been caught by the check above because the interrupt
			 * could have gone off between the previous check and
			 * the check for transfer complete.
			 *
			 * Technically this ought not be needed assuming we
			 * get a DATA_COMPLETE eventually (we'll notice the
			 * error and end the request), but it shouldn't hurt.
			 *
			 * This has the advantage of sending the stop command.
			 */
			if (test_and_clear_bit(EVENT_DATA_ERROR,
					       &host->pending_events)) {
				dw_mci_stop_dma(host);
				if (data->stop ||
				    !(host->data_status & (SDMMC_INT_DRTO |
							   SDMMC_INT_EBE)))
					send_stop_abort(host, data);
				state = STATE_DATA_ERROR;
				break;
			}
			prev_state = state = STATE_DATA_BUSY;

			/* fall through */

		case STATE_DATA_BUSY:
			if (!test_and_clear_bit(EVENT_DATA_COMPLETE,
						&host->pending_events)) {
				/*
				 * If data error interrupt comes but data over
				 * interrupt doesn't come within the given time.
				 * in reading data state.
				 */
				if (host->dir_status == DW_MCI_RECV_STATUS)
					dw_mci_set_drto(host);
				break;
			}

			host->data = NULL;
			set_bit(EVENT_DATA_COMPLETE, &host->completed_events);
			err = dw_mci_data_complete(host, data);

			if (!err) {
				if (!data->stop || mrq->sbc) {
					if (mrq->sbc && data->stop)
						data->stop->error = 0;
					dw_mci_request_end(host, mrq);
					goto unlock;
				}

				/* stop command for open-ended transfer*/
				if (data->stop)
					send_stop_abort(host, data);
			} else {
				/*
				 * If we don't have a command complete now we'll
				 * never get one since we just reset everything;
				 * better end the request.
				 *
				 * If we do have a command complete we'll fall
				 * through to the SENDING_STOP command and
				 * everything will be peachy keen.
				 */
				if (!test_bit(EVENT_CMD_COMPLETE,
					      &host->pending_events)) {
					host->cmd = NULL;
					dw_mci_request_end(host, mrq);
					goto unlock;
				}
			}

			/*
			 * If err has non-zero,
			 * stop-abort command has been already issued.
			 */
			prev_state = state = STATE_SENDING_STOP;

			/* fall through */

		case STATE_SENDING_STOP:
			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,
						&host->pending_events))
				break;

			/* CMD error in data command */
			if (mrq->cmd->error && mrq->data)
				dw_mci_reset(host);

			host->cmd = NULL;
			host->data = NULL;

			if (mrq->stop)
				dw_mci_command_complete(host, mrq->stop);
			else
				host->cmd_status = 0;

			dw_mci_request_end(host, mrq);
			goto unlock;

		case STATE_DATA_ERROR:
			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,
						&host->pending_events))
				break;

			state = STATE_DATA_BUSY;
			break;
		}
	} while (state != prev_state);

	host->state = state;
unlock:
	spin_unlock(&host->lock);

}
-----children-----
1,2
1,3
1,4
3,4
3,5
5,6
5,7
7,8
9,10
9,11
9,12
9,13
9,14
9,15
9,16
9,17
9,18
9,19
9,20
9,21
9,22
9,23
10,11
11,12
11,13
12,13
14,15
14,16
14,17
17,18
18,19
18,20
19,20
19,21
20,21
22,23
24,25
26,27
27,28
27,29
28,29
30,31
30,32
33,34
34,35
34,36
35,36
37,38
37,39
40,41
41,42
41,43
42,43
44,45
44,46
47,48
48,49
48,50
49,50
51,52
53,54
54,55
54,56
55,56
57,58
59,60
60,61
60,62
62,63
64,65
65,66
65,67
66,67
68,69
69,70
69,71
70,71
73,74
74,75
74,76
75,76
77,78
77,79
78,79
81,82
82,83
82,84
83,84
85,86
85,87
86,87
89,90
90,91
90,92
91,92
93,94
93,95
94,95
97,98
97,99
98,99
98,100
99,100
100,101
100,102
101,102
103,104
105,106
105,107
106,107
108,109
108,110
108,111
108,112
108,113
108,114
108,115
108,116
108,117
108,118
108,119
108,120
108,121
108,122
108,123
108,124
108,125
108,126
108,127
108,128
108,129
108,130
108,131
108,132
108,133
108,134
108,135
108,136
108,137
108,138
108,139
108,140
108,141
108,142
108,143
108,144
108,145
108,146
108,147
109,110
110,111
112,113
113,114
116,117
117,118
119,120
120,121
122,123
122,124
123,124
124,125
124,126
124,127
125,126
127,128
129,130
130,131
130,132
131,132
135,136
136,137
136,138
137,138
139,140
139,141
140,141
143,144
144,145
144,146
145,146
145,147
146,147
149,150
151,152
152,153
152,154
152,155
153,154
155,156
157,158
158,159
158,160
159,160
162,163
163,164
163,165
164,165
166,167
166,168
166,169
167,168
169,170
171,172
173,174
173,175
174,175
174,176
175,176
175,177
176,177
178,179
178,180
179,180
182,183
183,184
185,186
185,187
185,188
186,187
187,188
187,189
188,189
190,191
190,192
191,192
193,194
195,196
196,197
196,198
196,199
196,200
197,198
199,200
201,202
201,203
202,203
205,206
205,207
206,207
209,210
211,212
211,213
212,213
212,214
213,214
213,215
214,215
217,218
219,220
219,221
219,222
219,223
219,224
220,221
220,222
221,222
221,223
222,223
223,224
223,225
224,225
226,227
227,228
229,230
230,231
230,232
231,232
231,233
232,233
235,236
237,238
237,239
238,239
239,240
239,241
240,241
242,243
245,246
246,247
246,248
247,248
249,250
251,252
252,253
252,254
252,255
253,254
255,256
257,258
259,260
260,261
260,262
261,262
263,264
266,267
266,268
267,268
267,269
268,269
269,270
269,271
270,271
273,274
275,276
275,277
276,277
277,278
277,279
277,280
278,279
280,281
282,283
284,285
286,287
287,288
287,289
288,289
290,291
290,292
291,292
293,294
295,296
296,297
298,299
298,300
299,300
299,301
299,302
300,301
302,303
304,305
305,306
305,307
306,307
309,310
309,311
309,312
309,313
310,311
311,312
311,313
312,313
314,315
316,317
316,318
317,318
317,319
318,319
318,320
319,320
322,323
323,324
324,325
324,326
325,326
325,327
326,327
329,330
330,331
330,332
331,332
333,334
335,336
336,337
336,338
336,339
337,338
339,340
341,342
343,344
344,345
344,346
345,346
347,348
350,351
350,352
351,352
352,353
352,354
352,355
353,354
355,356
357,358
358,359
358,360
359,360
362,363
362,364
363,364
363,365
364,365
364,366
365,366
365,367
366,367
369,370
371,372
372,373
372,374
373,374
375,376
378,379
379,380
379,381
379,382
380,381
382,383
384,385
385,386
385,387
386,387
389,390
389,391
390,391
390,392
390,393
391,392
393,394
395,396
396,397
396,398
397,398
400,401
400,402
400,403
400,404
401,402
402,403
402,404
403,404
405,406
407,408
407,409
408,409
408,410
409,410
409,411
410,411
413,414
414,415
415,416
415,417
416,417
416,418
417,418
420,421
421,422
421,423
422,423
424,425
426,427
427,428
427,429
427,430
428,429
430,431
432,433
434,435
435,436
435,437
436,437
438,439
441,442
442,443
442,444
443,444
445,446
445,447
446,447
448,449
450,451
451,452
453,454
453,455
454,455
455,456
455,457
455,458
456,457
458,459
460,461
461,462
461,463
462,463
465,466
465,467
466,467
466,468
467,468
467,469
468,469
468,470
469,470
472,473
474,475
475,476
475,477
476,477
478,479
481,482
482,483
482,484
483,484
483,485
484,485
487,488
489,490
490,491
490,492
490,493
491,492
493,494
495,496
496,497
496,498
497,498
500,501
501,502
501,503
502,503
504,505
504,506
504,507
505,506
507,508
509,510
511,512
511,513
511,514
512,513
513,514
515,516
515,517
516,517
516,518
517,518
517,519
518,519
519,520
519,521
520,521
523,524
523,525
524,525
527,528
527,529
527,530
528,529
528,530
529,530
529,531
530,531
530,532
531,532
534,535
534,536
535,536
538,539
539,540
539,541
540,541
540,542
541,542
541,543
542,543
547,548
548,549
548,550
548,551
549,550
551,552
553,554
555,556
557,558
557,559
558,559
558,560
559,560
562,563
563,564
563,565
563,566
564,565
566,567
568,569
570,571
571,572
571,573
572,573
573,574
573,575
573,576
574,575
576,577
578,579
579,580
579,581
580,581
583,584
583,585
583,586
584,585
585,586
585,587
586,587
586,588
587,588
590,591
592,593
593,594
593,595
593,596
594,595
596,597
598,599
600,601
602,603
603,604
603,605
604,605
606,607
606,608
607,608
609,610
611,612
612,613
614,615
614,616
615,616
616,617
616,618
616,619
617,618
619,620
621,622
622,623
622,624
623,624
627,628
627,629
628,629
628,630
629,630
629,631
630,631
630,632
631,632
635,636
635,637
636,637
639,640
640,641
640,642
641,642
643,644
645,646
646,647
646,648
647,648
647,649
648,649
651,652
653,654
654,655
654,656
655,656
655,657
656,657
659,660
661,662
661,663
661,664
662,663
662,664
663,664
666,667
667,668
667,669
667,670
668,669
670,671
672,673
672,674
673,674
676,677
677,678
677,679
678,679
678,680
679,680
683,684
684,685
684,686
684,687
685,686
687,688
689,690
691,692
693,694
694,695
696,697
696,698
697,698
698,699
698,700
698,701
699,700
701,702
703,704
704,705
704,706
705,706
709,710
710,711
710,712
711,712
713,714
716,717
716,718
717,718
719,720
721,722
722,723
722,724
723,724
723,725
724,725
727,728
729,730
729,731
731,732
732,733
732,734
733,734
735,736
736,737
736,738
737,738
-----nextToken-----
2,4,6,8,13,15,16,21,23,25,29,31,32,36,38,39,43,45,46,50,52,56,58,61,63,67,71,72,76,79,80,84,87,88,92,95,96,102,104,107,111,114,115,118,121,126,128,132,133,134,138,141,142,147,148,150,154,156,160,161,165,168,170,172,177,180,181,184,189,192,194,198,200,203,204,207,208,210,215,216,218,225,228,233,234,236,241,243,244,248,250,254,256,258,262,264,265,271,272,274,279,281,283,285,289,292,294,297,301,303,307,308,313,315,320,321,327,328,332,334,338,340,342,346,348,349,354,356,360,361,367,368,370,374,376,377,381,383,387,388,392,394,398,399,404,406,411,412,418,419,423,425,429,431,433,437,439,440,444,447,449,452,457,459,463,464,470,471,473,477,479,480,485,486,488,492,494,498,499,503,506,508,510,514,521,522,525,526,532,533,536,537,543,544,545,546,550,552,554,556,560,561,565,567,569,575,577,581,582,588,589,591,595,597,599,601,605,608,610,613,618,620,624,625,626,632,633,634,637,638,642,644,649,650,652,657,658,660,664,665,669,671,674,675,680,681,682,686,688,690,692,695,700,702,706,707,708,712,714,715,718,720,725,726,728,730,734,738,739
-----computeFrom-----
74,75
74,76
82,83
82,84
90,91
90,92
100,101
100,102
136,137
136,138
144,145
144,146
163,164
163,165
174,175
174,176
175,176
175,177
187,188
187,189
190,191
190,192
212,213
212,214
221,222
221,223
223,224
223,225
230,231
230,232
239,240
239,241
260,261
260,262
267,268
267,269
287,288
287,289
290,291
290,292
317,318
317,319
324,325
324,326
330,331
330,332
344,345
344,346
364,365
364,366
408,409
408,410
415,416
415,417
421,422
421,423
435,436
435,437
442,443
442,444
445,446
445,447
467,468
467,469
482,483
482,484
501,502
501,503
517,518
517,519
529,530
529,531
539,540
539,541
585,586
585,587
603,604
603,605
606,607
606,608
628,629
628,630
646,647
646,648
654,655
654,656
677,678
677,679
710,711
710,712
716,717
716,718
722,723
722,724
-----guardedBy-----
177,208
180,207
216,258
218,225
215,233
320,342
327,340
367,376
411,433
418,431
470,479
521,543
522,544
526,533
525,554
536,543
537,544
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;CastExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;Pointer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;DoStatement;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;SwitchStatement;IdExpression;Name;CompoundStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;BreakStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;GotoStatement;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ContinueStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BreakStatement;IfStatement;BinaryExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;GotoStatement;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;CaseStatement;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BreakStatement;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BreakStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BreakStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;CaseStatement;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BreakStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;GotoStatement;Name;IfStatement;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;GotoStatement;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;CaseStatement;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;BreakStatement;IfStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;GotoStatement;Name;CaseStatement;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;BreakStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BreakStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;LabelStatement;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;
-----ast_node-----
static void dw_mci_tasklet_func(unsigned long priv){	struct dw_mci *host = (struct dw_mci *)priv;	struct mmc_data	*data;	struct mmc_command *cmd;	struct mmc_request *mrq;	enum dw_mci_state state;	enum dw_mci_state prev_state;	unsigned int err;	spin_lock(&host->lock);	state = host->state;	data = host->data;	mrq = host->mrq;	do {		prev_state = state;		switch (state) {		case STATE_IDLE:		case STATE_WAITING_CMD11_DONE:			break;		case STATE_SENDING_CMD11:		case STATE_SENDING_CMD:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			cmd = host->cmd;			host->cmd = NULL;			set_bit(EVENT_CMD_COMPLETE, &host->completed_events);			err = dw_mci_command_complete(host, cmd);			if (cmd == mrq->sbc && !err) {				prev_state = state = STATE_SENDING_CMD;				__dw_mci_start_request(host, host->cur_slot,						       mrq->cmd);				goto unlock;			}			if (cmd->data && err) {				/*				 * During UHS tuning sequence, sending the stop				 * command after the response CRC error would				 * throw the system into a confused state				 * causing all future tuning phases to report				 * failure.				 *				 * In such case controller will move into a data				 * transfer state after a response error or				 * response CRC error. Let's let that finish				 * before trying to send a stop, so we'll go to				 * STATE_SENDING_DATA.				 *				 * Although letting the data transfer take place				 * will waste a bit of time (we already know				 * the command was bad), it can't cause any				 * errors since it's possible it would have				 * taken place anyway if this tasklet got				 * delayed. Allowing the transfer to take place				 * avoids races and keeps things simple.				 */				if ((err != -ETIMEDOUT) &&				    (cmd->opcode == MMC_SEND_TUNING_BLOCK)) {					state = STATE_SENDING_DATA;					continue;				}				dw_mci_stop_dma(host);				send_stop_abort(host, data);				state = STATE_SENDING_STOP;				break;			}			if (!cmd->data || err) {				dw_mci_request_end(host, mrq);				goto unlock;			}			prev_state = state = STATE_SENDING_DATA;			/* fall through */		case STATE_SENDING_DATA:			/*			 * We could get a data error and never a transfer			 * complete so we'd better check for it here.			 *			 * Note that we don't really care if we also got a			 * transfer complete; stopping the DMA and sending an			 * abort won't hurt.			 */			if (test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)) {				dw_mci_stop_dma(host);				if (data->stop ||				    !(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE)))					send_stop_abort(host, data);				state = STATE_DATA_ERROR;				break;			}			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events)) {				/*				 * If all data-related interrupts don't come				 * within the given time in reading data state.				 */				if (host->dir_status == DW_MCI_RECV_STATUS)					dw_mci_set_drto(host);				break;			}			set_bit(EVENT_XFER_COMPLETE, &host->completed_events);			/*			 * Handle an EVENT_DATA_ERROR that might have shown up			 * before the transfer completed.  This might not have			 * been caught by the check above because the interrupt			 * could have gone off between the previous check and			 * the check for transfer complete.			 *			 * Technically this ought not be needed assuming we			 * get a DATA_COMPLETE eventually (we'll notice the			 * error and end the request), but it shouldn't hurt.			 *			 * This has the advantage of sending the stop command.			 */			if (test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)) {				dw_mci_stop_dma(host);				if (data->stop ||				    !(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE)))					send_stop_abort(host, data);				state = STATE_DATA_ERROR;				break;			}			prev_state = state = STATE_DATA_BUSY;			/* fall through */		case STATE_DATA_BUSY:			if (!test_and_clear_bit(EVENT_DATA_COMPLETE,						&host->pending_events)) {				/*				 * If data error interrupt comes but data over				 * interrupt doesn't come within the given time.				 * in reading data state.				 */				if (host->dir_status == DW_MCI_RECV_STATUS)					dw_mci_set_drto(host);				break;			}			host->data = NULL;			set_bit(EVENT_DATA_COMPLETE, &host->completed_events);			err = dw_mci_data_complete(host, data);			if (!err) {				if (!data->stop || mrq->sbc) {					if (mrq->sbc && data->stop)						data->stop->error = 0;					dw_mci_request_end(host, mrq);					goto unlock;				}				/* stop command for open-ended transfer*/				if (data->stop)					send_stop_abort(host, data);			} else {				/*				 * If we don't have a command complete now we'll				 * never get one since we just reset everything;				 * better end the request.				 *				 * If we do have a command complete we'll fall				 * through to the SENDING_STOP command and				 * everything will be peachy keen.				 */				if (!test_bit(EVENT_CMD_COMPLETE,					      &host->pending_events)) {					host->cmd = NULL;					dw_mci_request_end(host, mrq);					goto unlock;				}			}			/*			 * If err has non-zero,			 * stop-abort command has been already issued.			 */			prev_state = state = STATE_SENDING_STOP;			/* fall through */		case STATE_SENDING_STOP:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			/* CMD error in data command */			if (mrq->cmd->error && mrq->data)				dw_mci_reset(host);			host->cmd = NULL;			host->data = NULL;			if (mrq->stop)				dw_mci_command_complete(host, mrq->stop);			else				host->cmd_status = 0;			dw_mci_request_end(host, mrq);			goto unlock;		case STATE_DATA_ERROR:			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events))				break;			state = STATE_DATA_BUSY;			break;		}	} while (state != prev_state);	host->state = state;unlock:	spin_unlock(&host->lock);}
static void
dw_mci_tasklet_func(unsigned long priv)
dw_mci_tasklet_func
unsigned long priv
unsigned long
priv
priv
{	struct dw_mci *host = (struct dw_mci *)priv;	struct mmc_data	*data;	struct mmc_command *cmd;	struct mmc_request *mrq;	enum dw_mci_state state;	enum dw_mci_state prev_state;	unsigned int err;	spin_lock(&host->lock);	state = host->state;	data = host->data;	mrq = host->mrq;	do {		prev_state = state;		switch (state) {		case STATE_IDLE:		case STATE_WAITING_CMD11_DONE:			break;		case STATE_SENDING_CMD11:		case STATE_SENDING_CMD:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			cmd = host->cmd;			host->cmd = NULL;			set_bit(EVENT_CMD_COMPLETE, &host->completed_events);			err = dw_mci_command_complete(host, cmd);			if (cmd == mrq->sbc && !err) {				prev_state = state = STATE_SENDING_CMD;				__dw_mci_start_request(host, host->cur_slot,						       mrq->cmd);				goto unlock;			}			if (cmd->data && err) {				/*				 * During UHS tuning sequence, sending the stop				 * command after the response CRC error would				 * throw the system into a confused state				 * causing all future tuning phases to report				 * failure.				 *				 * In such case controller will move into a data				 * transfer state after a response error or				 * response CRC error. Let's let that finish				 * before trying to send a stop, so we'll go to				 * STATE_SENDING_DATA.				 *				 * Although letting the data transfer take place				 * will waste a bit of time (we already know				 * the command was bad), it can't cause any				 * errors since it's possible it would have				 * taken place anyway if this tasklet got				 * delayed. Allowing the transfer to take place				 * avoids races and keeps things simple.				 */				if ((err != -ETIMEDOUT) &&				    (cmd->opcode == MMC_SEND_TUNING_BLOCK)) {					state = STATE_SENDING_DATA;					continue;				}				dw_mci_stop_dma(host);				send_stop_abort(host, data);				state = STATE_SENDING_STOP;				break;			}			if (!cmd->data || err) {				dw_mci_request_end(host, mrq);				goto unlock;			}			prev_state = state = STATE_SENDING_DATA;			/* fall through */		case STATE_SENDING_DATA:			/*			 * We could get a data error and never a transfer			 * complete so we'd better check for it here.			 *			 * Note that we don't really care if we also got a			 * transfer complete; stopping the DMA and sending an			 * abort won't hurt.			 */			if (test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)) {				dw_mci_stop_dma(host);				if (data->stop ||				    !(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE)))					send_stop_abort(host, data);				state = STATE_DATA_ERROR;				break;			}			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events)) {				/*				 * If all data-related interrupts don't come				 * within the given time in reading data state.				 */				if (host->dir_status == DW_MCI_RECV_STATUS)					dw_mci_set_drto(host);				break;			}			set_bit(EVENT_XFER_COMPLETE, &host->completed_events);			/*			 * Handle an EVENT_DATA_ERROR that might have shown up			 * before the transfer completed.  This might not have			 * been caught by the check above because the interrupt			 * could have gone off between the previous check and			 * the check for transfer complete.			 *			 * Technically this ought not be needed assuming we			 * get a DATA_COMPLETE eventually (we'll notice the			 * error and end the request), but it shouldn't hurt.			 *			 * This has the advantage of sending the stop command.			 */			if (test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)) {				dw_mci_stop_dma(host);				if (data->stop ||				    !(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE)))					send_stop_abort(host, data);				state = STATE_DATA_ERROR;				break;			}			prev_state = state = STATE_DATA_BUSY;			/* fall through */		case STATE_DATA_BUSY:			if (!test_and_clear_bit(EVENT_DATA_COMPLETE,						&host->pending_events)) {				/*				 * If data error interrupt comes but data over				 * interrupt doesn't come within the given time.				 * in reading data state.				 */				if (host->dir_status == DW_MCI_RECV_STATUS)					dw_mci_set_drto(host);				break;			}			host->data = NULL;			set_bit(EVENT_DATA_COMPLETE, &host->completed_events);			err = dw_mci_data_complete(host, data);			if (!err) {				if (!data->stop || mrq->sbc) {					if (mrq->sbc && data->stop)						data->stop->error = 0;					dw_mci_request_end(host, mrq);					goto unlock;				}				/* stop command for open-ended transfer*/				if (data->stop)					send_stop_abort(host, data);			} else {				/*				 * If we don't have a command complete now we'll				 * never get one since we just reset everything;				 * better end the request.				 *				 * If we do have a command complete we'll fall				 * through to the SENDING_STOP command and				 * everything will be peachy keen.				 */				if (!test_bit(EVENT_CMD_COMPLETE,					      &host->pending_events)) {					host->cmd = NULL;					dw_mci_request_end(host, mrq);					goto unlock;				}			}			/*			 * If err has non-zero,			 * stop-abort command has been already issued.			 */			prev_state = state = STATE_SENDING_STOP;			/* fall through */		case STATE_SENDING_STOP:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			/* CMD error in data command */			if (mrq->cmd->error && mrq->data)				dw_mci_reset(host);			host->cmd = NULL;			host->data = NULL;			if (mrq->stop)				dw_mci_command_complete(host, mrq->stop);			else				host->cmd_status = 0;			dw_mci_request_end(host, mrq);			goto unlock;		case STATE_DATA_ERROR:			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events))				break;			state = STATE_DATA_BUSY;			break;		}	} while (state != prev_state);	host->state = state;unlock:	spin_unlock(&host->lock);}
struct dw_mci *host = (struct dw_mci *)priv;
struct dw_mci *host = (struct dw_mci *)priv;
struct dw_mci
dw_mci
*host = (struct dw_mci *)priv
*
host
= (struct dw_mci *)priv
(struct dw_mci *)priv
struct dw_mci *
struct dw_mci
dw_mci
*
*
priv
priv
struct mmc_data	*data;
struct mmc_data	*data;
struct mmc_data
mmc_data
*data
*
data
struct mmc_command *cmd;
struct mmc_command *cmd;
struct mmc_command
mmc_command
*cmd
*
cmd
struct mmc_request *mrq;
struct mmc_request *mrq;
struct mmc_request
mmc_request
*mrq
*
mrq
enum dw_mci_state state;
enum dw_mci_state state;
enum dw_mci_state
dw_mci_state
state
state
enum dw_mci_state prev_state;
enum dw_mci_state prev_state;
enum dw_mci_state
dw_mci_state
prev_state
prev_state
unsigned int err;
unsigned int err;
unsigned int
err
err
spin_lock(&host->lock);
spin_lock(&host->lock)
spin_lock
spin_lock
&host->lock
host->lock
host
host
lock
state = host->state;
state = host->state
state
state
host->state
host
host
state
data = host->data;
data = host->data
data
data
host->data
host
host
data
mrq = host->mrq;
mrq = host->mrq
mrq
mrq
host->mrq
host
host
mrq
do {		prev_state = state;		switch (state) {		case STATE_IDLE:		case STATE_WAITING_CMD11_DONE:			break;		case STATE_SENDING_CMD11:		case STATE_SENDING_CMD:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			cmd = host->cmd;			host->cmd = NULL;			set_bit(EVENT_CMD_COMPLETE, &host->completed_events);			err = dw_mci_command_complete(host, cmd);			if (cmd == mrq->sbc && !err) {				prev_state = state = STATE_SENDING_CMD;				__dw_mci_start_request(host, host->cur_slot,						       mrq->cmd);				goto unlock;			}			if (cmd->data && err) {				/*				 * During UHS tuning sequence, sending the stop				 * command after the response CRC error would				 * throw the system into a confused state				 * causing all future tuning phases to report				 * failure.				 *				 * In such case controller will move into a data				 * transfer state after a response error or				 * response CRC error. Let's let that finish				 * before trying to send a stop, so we'll go to				 * STATE_SENDING_DATA.				 *				 * Although letting the data transfer take place				 * will waste a bit of time (we already know				 * the command was bad), it can't cause any				 * errors since it's possible it would have				 * taken place anyway if this tasklet got				 * delayed. Allowing the transfer to take place				 * avoids races and keeps things simple.				 */				if ((err != -ETIMEDOUT) &&				    (cmd->opcode == MMC_SEND_TUNING_BLOCK)) {					state = STATE_SENDING_DATA;					continue;				}				dw_mci_stop_dma(host);				send_stop_abort(host, data);				state = STATE_SENDING_STOP;				break;			}			if (!cmd->data || err) {				dw_mci_request_end(host, mrq);				goto unlock;			}			prev_state = state = STATE_SENDING_DATA;			/* fall through */		case STATE_SENDING_DATA:			/*			 * We could get a data error and never a transfer			 * complete so we'd better check for it here.			 *			 * Note that we don't really care if we also got a			 * transfer complete; stopping the DMA and sending an			 * abort won't hurt.			 */			if (test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)) {				dw_mci_stop_dma(host);				if (data->stop ||				    !(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE)))					send_stop_abort(host, data);				state = STATE_DATA_ERROR;				break;			}			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events)) {				/*				 * If all data-related interrupts don't come				 * within the given time in reading data state.				 */				if (host->dir_status == DW_MCI_RECV_STATUS)					dw_mci_set_drto(host);				break;			}			set_bit(EVENT_XFER_COMPLETE, &host->completed_events);			/*			 * Handle an EVENT_DATA_ERROR that might have shown up			 * before the transfer completed.  This might not have			 * been caught by the check above because the interrupt			 * could have gone off between the previous check and			 * the check for transfer complete.			 *			 * Technically this ought not be needed assuming we			 * get a DATA_COMPLETE eventually (we'll notice the			 * error and end the request), but it shouldn't hurt.			 *			 * This has the advantage of sending the stop command.			 */			if (test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)) {				dw_mci_stop_dma(host);				if (data->stop ||				    !(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE)))					send_stop_abort(host, data);				state = STATE_DATA_ERROR;				break;			}			prev_state = state = STATE_DATA_BUSY;			/* fall through */		case STATE_DATA_BUSY:			if (!test_and_clear_bit(EVENT_DATA_COMPLETE,						&host->pending_events)) {				/*				 * If data error interrupt comes but data over				 * interrupt doesn't come within the given time.				 * in reading data state.				 */				if (host->dir_status == DW_MCI_RECV_STATUS)					dw_mci_set_drto(host);				break;			}			host->data = NULL;			set_bit(EVENT_DATA_COMPLETE, &host->completed_events);			err = dw_mci_data_complete(host, data);			if (!err) {				if (!data->stop || mrq->sbc) {					if (mrq->sbc && data->stop)						data->stop->error = 0;					dw_mci_request_end(host, mrq);					goto unlock;				}				/* stop command for open-ended transfer*/				if (data->stop)					send_stop_abort(host, data);			} else {				/*				 * If we don't have a command complete now we'll				 * never get one since we just reset everything;				 * better end the request.				 *				 * If we do have a command complete we'll fall				 * through to the SENDING_STOP command and				 * everything will be peachy keen.				 */				if (!test_bit(EVENT_CMD_COMPLETE,					      &host->pending_events)) {					host->cmd = NULL;					dw_mci_request_end(host, mrq);					goto unlock;				}			}			/*			 * If err has non-zero,			 * stop-abort command has been already issued.			 */			prev_state = state = STATE_SENDING_STOP;			/* fall through */		case STATE_SENDING_STOP:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			/* CMD error in data command */			if (mrq->cmd->error && mrq->data)				dw_mci_reset(host);			host->cmd = NULL;			host->data = NULL;			if (mrq->stop)				dw_mci_command_complete(host, mrq->stop);			else				host->cmd_status = 0;			dw_mci_request_end(host, mrq);			goto unlock;		case STATE_DATA_ERROR:			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events))				break;			state = STATE_DATA_BUSY;			break;		}	} while (state != prev_state);
{		prev_state = state;		switch (state) {		case STATE_IDLE:		case STATE_WAITING_CMD11_DONE:			break;		case STATE_SENDING_CMD11:		case STATE_SENDING_CMD:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			cmd = host->cmd;			host->cmd = NULL;			set_bit(EVENT_CMD_COMPLETE, &host->completed_events);			err = dw_mci_command_complete(host, cmd);			if (cmd == mrq->sbc && !err) {				prev_state = state = STATE_SENDING_CMD;				__dw_mci_start_request(host, host->cur_slot,						       mrq->cmd);				goto unlock;			}			if (cmd->data && err) {				/*				 * During UHS tuning sequence, sending the stop				 * command after the response CRC error would				 * throw the system into a confused state				 * causing all future tuning phases to report				 * failure.				 *				 * In such case controller will move into a data				 * transfer state after a response error or				 * response CRC error. Let's let that finish				 * before trying to send a stop, so we'll go to				 * STATE_SENDING_DATA.				 *				 * Although letting the data transfer take place				 * will waste a bit of time (we already know				 * the command was bad), it can't cause any				 * errors since it's possible it would have				 * taken place anyway if this tasklet got				 * delayed. Allowing the transfer to take place				 * avoids races and keeps things simple.				 */				if ((err != -ETIMEDOUT) &&				    (cmd->opcode == MMC_SEND_TUNING_BLOCK)) {					state = STATE_SENDING_DATA;					continue;				}				dw_mci_stop_dma(host);				send_stop_abort(host, data);				state = STATE_SENDING_STOP;				break;			}			if (!cmd->data || err) {				dw_mci_request_end(host, mrq);				goto unlock;			}			prev_state = state = STATE_SENDING_DATA;			/* fall through */		case STATE_SENDING_DATA:			/*			 * We could get a data error and never a transfer			 * complete so we'd better check for it here.			 *			 * Note that we don't really care if we also got a			 * transfer complete; stopping the DMA and sending an			 * abort won't hurt.			 */			if (test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)) {				dw_mci_stop_dma(host);				if (data->stop ||				    !(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE)))					send_stop_abort(host, data);				state = STATE_DATA_ERROR;				break;			}			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events)) {				/*				 * If all data-related interrupts don't come				 * within the given time in reading data state.				 */				if (host->dir_status == DW_MCI_RECV_STATUS)					dw_mci_set_drto(host);				break;			}			set_bit(EVENT_XFER_COMPLETE, &host->completed_events);			/*			 * Handle an EVENT_DATA_ERROR that might have shown up			 * before the transfer completed.  This might not have			 * been caught by the check above because the interrupt			 * could have gone off between the previous check and			 * the check for transfer complete.			 *			 * Technically this ought not be needed assuming we			 * get a DATA_COMPLETE eventually (we'll notice the			 * error and end the request), but it shouldn't hurt.			 *			 * This has the advantage of sending the stop command.			 */			if (test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)) {				dw_mci_stop_dma(host);				if (data->stop ||				    !(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE)))					send_stop_abort(host, data);				state = STATE_DATA_ERROR;				break;			}			prev_state = state = STATE_DATA_BUSY;			/* fall through */		case STATE_DATA_BUSY:			if (!test_and_clear_bit(EVENT_DATA_COMPLETE,						&host->pending_events)) {				/*				 * If data error interrupt comes but data over				 * interrupt doesn't come within the given time.				 * in reading data state.				 */				if (host->dir_status == DW_MCI_RECV_STATUS)					dw_mci_set_drto(host);				break;			}			host->data = NULL;			set_bit(EVENT_DATA_COMPLETE, &host->completed_events);			err = dw_mci_data_complete(host, data);			if (!err) {				if (!data->stop || mrq->sbc) {					if (mrq->sbc && data->stop)						data->stop->error = 0;					dw_mci_request_end(host, mrq);					goto unlock;				}				/* stop command for open-ended transfer*/				if (data->stop)					send_stop_abort(host, data);			} else {				/*				 * If we don't have a command complete now we'll				 * never get one since we just reset everything;				 * better end the request.				 *				 * If we do have a command complete we'll fall				 * through to the SENDING_STOP command and				 * everything will be peachy keen.				 */				if (!test_bit(EVENT_CMD_COMPLETE,					      &host->pending_events)) {					host->cmd = NULL;					dw_mci_request_end(host, mrq);					goto unlock;				}			}			/*			 * If err has non-zero,			 * stop-abort command has been already issued.			 */			prev_state = state = STATE_SENDING_STOP;			/* fall through */		case STATE_SENDING_STOP:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			/* CMD error in data command */			if (mrq->cmd->error && mrq->data)				dw_mci_reset(host);			host->cmd = NULL;			host->data = NULL;			if (mrq->stop)				dw_mci_command_complete(host, mrq->stop);			else				host->cmd_status = 0;			dw_mci_request_end(host, mrq);			goto unlock;		case STATE_DATA_ERROR:			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events))				break;			state = STATE_DATA_BUSY;			break;		}	}
prev_state = state;
prev_state = state
prev_state
prev_state
state
state
switch (state) {		case STATE_IDLE:		case STATE_WAITING_CMD11_DONE:			break;		case STATE_SENDING_CMD11:		case STATE_SENDING_CMD:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			cmd = host->cmd;			host->cmd = NULL;			set_bit(EVENT_CMD_COMPLETE, &host->completed_events);			err = dw_mci_command_complete(host, cmd);			if (cmd == mrq->sbc && !err) {				prev_state = state = STATE_SENDING_CMD;				__dw_mci_start_request(host, host->cur_slot,						       mrq->cmd);				goto unlock;			}			if (cmd->data && err) {				/*				 * During UHS tuning sequence, sending the stop				 * command after the response CRC error would				 * throw the system into a confused state				 * causing all future tuning phases to report				 * failure.				 *				 * In such case controller will move into a data				 * transfer state after a response error or				 * response CRC error. Let's let that finish				 * before trying to send a stop, so we'll go to				 * STATE_SENDING_DATA.				 *				 * Although letting the data transfer take place				 * will waste a bit of time (we already know				 * the command was bad), it can't cause any				 * errors since it's possible it would have				 * taken place anyway if this tasklet got				 * delayed. Allowing the transfer to take place				 * avoids races and keeps things simple.				 */				if ((err != -ETIMEDOUT) &&				    (cmd->opcode == MMC_SEND_TUNING_BLOCK)) {					state = STATE_SENDING_DATA;					continue;				}				dw_mci_stop_dma(host);				send_stop_abort(host, data);				state = STATE_SENDING_STOP;				break;			}			if (!cmd->data || err) {				dw_mci_request_end(host, mrq);				goto unlock;			}			prev_state = state = STATE_SENDING_DATA;			/* fall through */		case STATE_SENDING_DATA:			/*			 * We could get a data error and never a transfer			 * complete so we'd better check for it here.			 *			 * Note that we don't really care if we also got a			 * transfer complete; stopping the DMA and sending an			 * abort won't hurt.			 */			if (test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)) {				dw_mci_stop_dma(host);				if (data->stop ||				    !(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE)))					send_stop_abort(host, data);				state = STATE_DATA_ERROR;				break;			}			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events)) {				/*				 * If all data-related interrupts don't come				 * within the given time in reading data state.				 */				if (host->dir_status == DW_MCI_RECV_STATUS)					dw_mci_set_drto(host);				break;			}			set_bit(EVENT_XFER_COMPLETE, &host->completed_events);			/*			 * Handle an EVENT_DATA_ERROR that might have shown up			 * before the transfer completed.  This might not have			 * been caught by the check above because the interrupt			 * could have gone off between the previous check and			 * the check for transfer complete.			 *			 * Technically this ought not be needed assuming we			 * get a DATA_COMPLETE eventually (we'll notice the			 * error and end the request), but it shouldn't hurt.			 *			 * This has the advantage of sending the stop command.			 */			if (test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)) {				dw_mci_stop_dma(host);				if (data->stop ||				    !(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE)))					send_stop_abort(host, data);				state = STATE_DATA_ERROR;				break;			}			prev_state = state = STATE_DATA_BUSY;			/* fall through */		case STATE_DATA_BUSY:			if (!test_and_clear_bit(EVENT_DATA_COMPLETE,						&host->pending_events)) {				/*				 * If data error interrupt comes but data over				 * interrupt doesn't come within the given time.				 * in reading data state.				 */				if (host->dir_status == DW_MCI_RECV_STATUS)					dw_mci_set_drto(host);				break;			}			host->data = NULL;			set_bit(EVENT_DATA_COMPLETE, &host->completed_events);			err = dw_mci_data_complete(host, data);			if (!err) {				if (!data->stop || mrq->sbc) {					if (mrq->sbc && data->stop)						data->stop->error = 0;					dw_mci_request_end(host, mrq);					goto unlock;				}				/* stop command for open-ended transfer*/				if (data->stop)					send_stop_abort(host, data);			} else {				/*				 * If we don't have a command complete now we'll				 * never get one since we just reset everything;				 * better end the request.				 *				 * If we do have a command complete we'll fall				 * through to the SENDING_STOP command and				 * everything will be peachy keen.				 */				if (!test_bit(EVENT_CMD_COMPLETE,					      &host->pending_events)) {					host->cmd = NULL;					dw_mci_request_end(host, mrq);					goto unlock;				}			}			/*			 * If err has non-zero,			 * stop-abort command has been already issued.			 */			prev_state = state = STATE_SENDING_STOP;			/* fall through */		case STATE_SENDING_STOP:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			/* CMD error in data command */			if (mrq->cmd->error && mrq->data)				dw_mci_reset(host);			host->cmd = NULL;			host->data = NULL;			if (mrq->stop)				dw_mci_command_complete(host, mrq->stop);			else				host->cmd_status = 0;			dw_mci_request_end(host, mrq);			goto unlock;		case STATE_DATA_ERROR:			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events))				break;			state = STATE_DATA_BUSY;			break;		}
state
state
{		case STATE_IDLE:		case STATE_WAITING_CMD11_DONE:			break;		case STATE_SENDING_CMD11:		case STATE_SENDING_CMD:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			cmd = host->cmd;			host->cmd = NULL;			set_bit(EVENT_CMD_COMPLETE, &host->completed_events);			err = dw_mci_command_complete(host, cmd);			if (cmd == mrq->sbc && !err) {				prev_state = state = STATE_SENDING_CMD;				__dw_mci_start_request(host, host->cur_slot,						       mrq->cmd);				goto unlock;			}			if (cmd->data && err) {				/*				 * During UHS tuning sequence, sending the stop				 * command after the response CRC error would				 * throw the system into a confused state				 * causing all future tuning phases to report				 * failure.				 *				 * In such case controller will move into a data				 * transfer state after a response error or				 * response CRC error. Let's let that finish				 * before trying to send a stop, so we'll go to				 * STATE_SENDING_DATA.				 *				 * Although letting the data transfer take place				 * will waste a bit of time (we already know				 * the command was bad), it can't cause any				 * errors since it's possible it would have				 * taken place anyway if this tasklet got				 * delayed. Allowing the transfer to take place				 * avoids races and keeps things simple.				 */				if ((err != -ETIMEDOUT) &&				    (cmd->opcode == MMC_SEND_TUNING_BLOCK)) {					state = STATE_SENDING_DATA;					continue;				}				dw_mci_stop_dma(host);				send_stop_abort(host, data);				state = STATE_SENDING_STOP;				break;			}			if (!cmd->data || err) {				dw_mci_request_end(host, mrq);				goto unlock;			}			prev_state = state = STATE_SENDING_DATA;			/* fall through */		case STATE_SENDING_DATA:			/*			 * We could get a data error and never a transfer			 * complete so we'd better check for it here.			 *			 * Note that we don't really care if we also got a			 * transfer complete; stopping the DMA and sending an			 * abort won't hurt.			 */			if (test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)) {				dw_mci_stop_dma(host);				if (data->stop ||				    !(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE)))					send_stop_abort(host, data);				state = STATE_DATA_ERROR;				break;			}			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events)) {				/*				 * If all data-related interrupts don't come				 * within the given time in reading data state.				 */				if (host->dir_status == DW_MCI_RECV_STATUS)					dw_mci_set_drto(host);				break;			}			set_bit(EVENT_XFER_COMPLETE, &host->completed_events);			/*			 * Handle an EVENT_DATA_ERROR that might have shown up			 * before the transfer completed.  This might not have			 * been caught by the check above because the interrupt			 * could have gone off between the previous check and			 * the check for transfer complete.			 *			 * Technically this ought not be needed assuming we			 * get a DATA_COMPLETE eventually (we'll notice the			 * error and end the request), but it shouldn't hurt.			 *			 * This has the advantage of sending the stop command.			 */			if (test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)) {				dw_mci_stop_dma(host);				if (data->stop ||				    !(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE)))					send_stop_abort(host, data);				state = STATE_DATA_ERROR;				break;			}			prev_state = state = STATE_DATA_BUSY;			/* fall through */		case STATE_DATA_BUSY:			if (!test_and_clear_bit(EVENT_DATA_COMPLETE,						&host->pending_events)) {				/*				 * If data error interrupt comes but data over				 * interrupt doesn't come within the given time.				 * in reading data state.				 */				if (host->dir_status == DW_MCI_RECV_STATUS)					dw_mci_set_drto(host);				break;			}			host->data = NULL;			set_bit(EVENT_DATA_COMPLETE, &host->completed_events);			err = dw_mci_data_complete(host, data);			if (!err) {				if (!data->stop || mrq->sbc) {					if (mrq->sbc && data->stop)						data->stop->error = 0;					dw_mci_request_end(host, mrq);					goto unlock;				}				/* stop command for open-ended transfer*/				if (data->stop)					send_stop_abort(host, data);			} else {				/*				 * If we don't have a command complete now we'll				 * never get one since we just reset everything;				 * better end the request.				 *				 * If we do have a command complete we'll fall				 * through to the SENDING_STOP command and				 * everything will be peachy keen.				 */				if (!test_bit(EVENT_CMD_COMPLETE,					      &host->pending_events)) {					host->cmd = NULL;					dw_mci_request_end(host, mrq);					goto unlock;				}			}			/*			 * If err has non-zero,			 * stop-abort command has been already issued.			 */			prev_state = state = STATE_SENDING_STOP;			/* fall through */		case STATE_SENDING_STOP:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			/* CMD error in data command */			if (mrq->cmd->error && mrq->data)				dw_mci_reset(host);			host->cmd = NULL;			host->data = NULL;			if (mrq->stop)				dw_mci_command_complete(host, mrq->stop);			else				host->cmd_status = 0;			dw_mci_request_end(host, mrq);			goto unlock;		case STATE_DATA_ERROR:			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events))				break;			state = STATE_DATA_BUSY;			break;		}
case STATE_IDLE:
STATE_IDLE
STATE_IDLE
case STATE_WAITING_CMD11_DONE:
STATE_WAITING_CMD11_DONE
STATE_WAITING_CMD11_DONE
break;
case STATE_SENDING_CMD11:
STATE_SENDING_CMD11
STATE_SENDING_CMD11
case STATE_SENDING_CMD:
STATE_SENDING_CMD
STATE_SENDING_CMD
if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;
!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events)
test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events)
test_and_clear_bit
test_and_clear_bit
EVENT_CMD_COMPLETE
EVENT_CMD_COMPLETE
&host->pending_events
host->pending_events
host
host
pending_events
break;
cmd = host->cmd;
cmd = host->cmd
cmd
cmd
host->cmd
host
host
cmd
host->cmd = NULL;
host->cmd = NULL
host->cmd
host
host
cmd
NULL
NULL
set_bit(EVENT_CMD_COMPLETE, &host->completed_events);
set_bit(EVENT_CMD_COMPLETE, &host->completed_events)
set_bit
set_bit
EVENT_CMD_COMPLETE
EVENT_CMD_COMPLETE
&host->completed_events
host->completed_events
host
host
completed_events
err = dw_mci_command_complete(host, cmd);
err = dw_mci_command_complete(host, cmd)
err
err
dw_mci_command_complete(host, cmd)
dw_mci_command_complete
dw_mci_command_complete
host
host
cmd
cmd
if (cmd == mrq->sbc && !err) {				prev_state = state = STATE_SENDING_CMD;				__dw_mci_start_request(host, host->cur_slot,						       mrq->cmd);				goto unlock;			}
cmd == mrq->sbc && !err
cmd == mrq->sbc
cmd
cmd
mrq->sbc
mrq
mrq
sbc
!err
err
err
{				prev_state = state = STATE_SENDING_CMD;				__dw_mci_start_request(host, host->cur_slot,						       mrq->cmd);				goto unlock;			}
prev_state = state = STATE_SENDING_CMD;
prev_state = state = STATE_SENDING_CMD
prev_state
prev_state
state = STATE_SENDING_CMD
state
state
STATE_SENDING_CMD
STATE_SENDING_CMD
__dw_mci_start_request(host, host->cur_slot,						       mrq->cmd);
__dw_mci_start_request(host, host->cur_slot,						       mrq->cmd)
__dw_mci_start_request
__dw_mci_start_request
host
host
host->cur_slot
host
host
cur_slot
mrq->cmd
mrq
mrq
cmd
goto unlock;
unlock
if (cmd->data && err) {				/*				 * During UHS tuning sequence, sending the stop				 * command after the response CRC error would				 * throw the system into a confused state				 * causing all future tuning phases to report				 * failure.				 *				 * In such case controller will move into a data				 * transfer state after a response error or				 * response CRC error. Let's let that finish				 * before trying to send a stop, so we'll go to				 * STATE_SENDING_DATA.				 *				 * Although letting the data transfer take place				 * will waste a bit of time (we already know				 * the command was bad), it can't cause any				 * errors since it's possible it would have				 * taken place anyway if this tasklet got				 * delayed. Allowing the transfer to take place				 * avoids races and keeps things simple.				 */				if ((err != -ETIMEDOUT) &&				    (cmd->opcode == MMC_SEND_TUNING_BLOCK)) {					state = STATE_SENDING_DATA;					continue;				}				dw_mci_stop_dma(host);				send_stop_abort(host, data);				state = STATE_SENDING_STOP;				break;			}
cmd->data && err
cmd->data
cmd
cmd
data
err
err
{				/*				 * During UHS tuning sequence, sending the stop				 * command after the response CRC error would				 * throw the system into a confused state				 * causing all future tuning phases to report				 * failure.				 *				 * In such case controller will move into a data				 * transfer state after a response error or				 * response CRC error. Let's let that finish				 * before trying to send a stop, so we'll go to				 * STATE_SENDING_DATA.				 *				 * Although letting the data transfer take place				 * will waste a bit of time (we already know				 * the command was bad), it can't cause any				 * errors since it's possible it would have				 * taken place anyway if this tasklet got				 * delayed. Allowing the transfer to take place				 * avoids races and keeps things simple.				 */				if ((err != -ETIMEDOUT) &&				    (cmd->opcode == MMC_SEND_TUNING_BLOCK)) {					state = STATE_SENDING_DATA;					continue;				}				dw_mci_stop_dma(host);				send_stop_abort(host, data);				state = STATE_SENDING_STOP;				break;			}
if ((err != -ETIMEDOUT) &&				    (cmd->opcode == MMC_SEND_TUNING_BLOCK)) {					state = STATE_SENDING_DATA;					continue;				}
(err != -ETIMEDOUT) &&				    (cmd->opcode == MMC_SEND_TUNING_BLOCK)
(err != -ETIMEDOUT)
err != -ETIMEDOUT
err
err
-ETIMEDOUT
ETIMEDOUT
ETIMEDOUT
(cmd->opcode == MMC_SEND_TUNING_BLOCK)
cmd->opcode == MMC_SEND_TUNING_BLOCK
cmd->opcode
cmd
cmd
opcode
MMC_SEND_TUNING_BLOCK
MMC_SEND_TUNING_BLOCK
{					state = STATE_SENDING_DATA;					continue;				}
state = STATE_SENDING_DATA;
state = STATE_SENDING_DATA
state
state
STATE_SENDING_DATA
STATE_SENDING_DATA
continue;
dw_mci_stop_dma(host);
dw_mci_stop_dma(host)
dw_mci_stop_dma
dw_mci_stop_dma
host
host
send_stop_abort(host, data);
send_stop_abort(host, data)
send_stop_abort
send_stop_abort
host
host
data
data
state = STATE_SENDING_STOP;
state = STATE_SENDING_STOP
state
state
STATE_SENDING_STOP
STATE_SENDING_STOP
break;
if (!cmd->data || err) {				dw_mci_request_end(host, mrq);				goto unlock;			}
!cmd->data || err
!cmd->data
cmd->data
cmd
cmd
data
err
err
{				dw_mci_request_end(host, mrq);				goto unlock;			}
dw_mci_request_end(host, mrq);
dw_mci_request_end(host, mrq)
dw_mci_request_end
dw_mci_request_end
host
host
mrq
mrq
goto unlock;
unlock
prev_state = state = STATE_SENDING_DATA;
prev_state = state = STATE_SENDING_DATA
prev_state
prev_state
state = STATE_SENDING_DATA
state
state
STATE_SENDING_DATA
STATE_SENDING_DATA
case STATE_SENDING_DATA:
STATE_SENDING_DATA
STATE_SENDING_DATA
if (test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)) {				dw_mci_stop_dma(host);				if (data->stop ||				    !(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE)))					send_stop_abort(host, data);				state = STATE_DATA_ERROR;				break;			}
test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)
test_and_clear_bit
test_and_clear_bit
EVENT_DATA_ERROR
EVENT_DATA_ERROR
&host->pending_events
host->pending_events
host
host
pending_events
{				dw_mci_stop_dma(host);				if (data->stop ||				    !(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE)))					send_stop_abort(host, data);				state = STATE_DATA_ERROR;				break;			}
dw_mci_stop_dma(host);
dw_mci_stop_dma(host)
dw_mci_stop_dma
dw_mci_stop_dma
host
host
if (data->stop ||				    !(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE)))					send_stop_abort(host, data);
data->stop ||				    !(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE))
data->stop
data
data
stop
!(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE))
(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE))
host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE)
host->data_status
host
host
data_status
(SDMMC_INT_DRTO |							   SDMMC_INT_EBE)
SDMMC_INT_DRTO |							   SDMMC_INT_EBE
SDMMC_INT_DRTO
SDMMC_INT_DRTO
SDMMC_INT_EBE
SDMMC_INT_EBE
send_stop_abort(host, data);
send_stop_abort(host, data)
send_stop_abort
send_stop_abort
host
host
data
data
state = STATE_DATA_ERROR;
state = STATE_DATA_ERROR
state
state
STATE_DATA_ERROR
STATE_DATA_ERROR
break;
if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events)) {				/*				 * If all data-related interrupts don't come				 * within the given time in reading data state.				 */				if (host->dir_status == DW_MCI_RECV_STATUS)					dw_mci_set_drto(host);				break;			}
!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events)
test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events)
test_and_clear_bit
test_and_clear_bit
EVENT_XFER_COMPLETE
EVENT_XFER_COMPLETE
&host->pending_events
host->pending_events
host
host
pending_events
{				/*				 * If all data-related interrupts don't come				 * within the given time in reading data state.				 */				if (host->dir_status == DW_MCI_RECV_STATUS)					dw_mci_set_drto(host);				break;			}
if (host->dir_status == DW_MCI_RECV_STATUS)					dw_mci_set_drto(host);
host->dir_status == DW_MCI_RECV_STATUS
host->dir_status
host
host
dir_status
DW_MCI_RECV_STATUS
DW_MCI_RECV_STATUS
dw_mci_set_drto(host);
dw_mci_set_drto(host)
dw_mci_set_drto
dw_mci_set_drto
host
host
break;
set_bit(EVENT_XFER_COMPLETE, &host->completed_events);
set_bit(EVENT_XFER_COMPLETE, &host->completed_events)
set_bit
set_bit
EVENT_XFER_COMPLETE
EVENT_XFER_COMPLETE
&host->completed_events
host->completed_events
host
host
completed_events
if (test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)) {				dw_mci_stop_dma(host);				if (data->stop ||				    !(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE)))					send_stop_abort(host, data);				state = STATE_DATA_ERROR;				break;			}
test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)
test_and_clear_bit
test_and_clear_bit
EVENT_DATA_ERROR
EVENT_DATA_ERROR
&host->pending_events
host->pending_events
host
host
pending_events
{				dw_mci_stop_dma(host);				if (data->stop ||				    !(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE)))					send_stop_abort(host, data);				state = STATE_DATA_ERROR;				break;			}
dw_mci_stop_dma(host);
dw_mci_stop_dma(host)
dw_mci_stop_dma
dw_mci_stop_dma
host
host
if (data->stop ||				    !(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE)))					send_stop_abort(host, data);
data->stop ||				    !(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE))
data->stop
data
data
stop
!(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE))
(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE))
host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE)
host->data_status
host
host
data_status
(SDMMC_INT_DRTO |							   SDMMC_INT_EBE)
SDMMC_INT_DRTO |							   SDMMC_INT_EBE
SDMMC_INT_DRTO
SDMMC_INT_DRTO
SDMMC_INT_EBE
SDMMC_INT_EBE
send_stop_abort(host, data);
send_stop_abort(host, data)
send_stop_abort
send_stop_abort
host
host
data
data
state = STATE_DATA_ERROR;
state = STATE_DATA_ERROR
state
state
STATE_DATA_ERROR
STATE_DATA_ERROR
break;
prev_state = state = STATE_DATA_BUSY;
prev_state = state = STATE_DATA_BUSY
prev_state
prev_state
state = STATE_DATA_BUSY
state
state
STATE_DATA_BUSY
STATE_DATA_BUSY
case STATE_DATA_BUSY:
STATE_DATA_BUSY
STATE_DATA_BUSY
if (!test_and_clear_bit(EVENT_DATA_COMPLETE,						&host->pending_events)) {				/*				 * If data error interrupt comes but data over				 * interrupt doesn't come within the given time.				 * in reading data state.				 */				if (host->dir_status == DW_MCI_RECV_STATUS)					dw_mci_set_drto(host);				break;			}
!test_and_clear_bit(EVENT_DATA_COMPLETE,						&host->pending_events)
test_and_clear_bit(EVENT_DATA_COMPLETE,						&host->pending_events)
test_and_clear_bit
test_and_clear_bit
EVENT_DATA_COMPLETE
EVENT_DATA_COMPLETE
&host->pending_events
host->pending_events
host
host
pending_events
{				/*				 * If data error interrupt comes but data over				 * interrupt doesn't come within the given time.				 * in reading data state.				 */				if (host->dir_status == DW_MCI_RECV_STATUS)					dw_mci_set_drto(host);				break;			}
if (host->dir_status == DW_MCI_RECV_STATUS)					dw_mci_set_drto(host);
host->dir_status == DW_MCI_RECV_STATUS
host->dir_status
host
host
dir_status
DW_MCI_RECV_STATUS
DW_MCI_RECV_STATUS
dw_mci_set_drto(host);
dw_mci_set_drto(host)
dw_mci_set_drto
dw_mci_set_drto
host
host
break;
host->data = NULL;
host->data = NULL
host->data
host
host
data
NULL
NULL
set_bit(EVENT_DATA_COMPLETE, &host->completed_events);
set_bit(EVENT_DATA_COMPLETE, &host->completed_events)
set_bit
set_bit
EVENT_DATA_COMPLETE
EVENT_DATA_COMPLETE
&host->completed_events
host->completed_events
host
host
completed_events
err = dw_mci_data_complete(host, data);
err = dw_mci_data_complete(host, data)
err
err
dw_mci_data_complete(host, data)
dw_mci_data_complete
dw_mci_data_complete
host
host
data
data
if (!err) {				if (!data->stop || mrq->sbc) {					if (mrq->sbc && data->stop)						data->stop->error = 0;					dw_mci_request_end(host, mrq);					goto unlock;				}				/* stop command for open-ended transfer*/				if (data->stop)					send_stop_abort(host, data);			} else {				/*				 * If we don't have a command complete now we'll				 * never get one since we just reset everything;				 * better end the request.				 *				 * If we do have a command complete we'll fall				 * through to the SENDING_STOP command and				 * everything will be peachy keen.				 */				if (!test_bit(EVENT_CMD_COMPLETE,					      &host->pending_events)) {					host->cmd = NULL;					dw_mci_request_end(host, mrq);					goto unlock;				}			}
!err
err
err
{				if (!data->stop || mrq->sbc) {					if (mrq->sbc && data->stop)						data->stop->error = 0;					dw_mci_request_end(host, mrq);					goto unlock;				}				/* stop command for open-ended transfer*/				if (data->stop)					send_stop_abort(host, data);			}
if (!data->stop || mrq->sbc) {					if (mrq->sbc && data->stop)						data->stop->error = 0;					dw_mci_request_end(host, mrq);					goto unlock;				}
!data->stop || mrq->sbc
!data->stop
data->stop
data
data
stop
mrq->sbc
mrq
mrq
sbc
{					if (mrq->sbc && data->stop)						data->stop->error = 0;					dw_mci_request_end(host, mrq);					goto unlock;				}
if (mrq->sbc && data->stop)						data->stop->error = 0;
mrq->sbc && data->stop
mrq->sbc
mrq
mrq
sbc
data->stop
data
data
stop
data->stop->error = 0;
data->stop->error = 0
data->stop->error
data->stop
data
data
stop
error
0
dw_mci_request_end(host, mrq);
dw_mci_request_end(host, mrq)
dw_mci_request_end
dw_mci_request_end
host
host
mrq
mrq
goto unlock;
unlock
if (data->stop)					send_stop_abort(host, data);
data->stop
data
data
stop
send_stop_abort(host, data);
send_stop_abort(host, data)
send_stop_abort
send_stop_abort
host
host
data
data
{				/*				 * If we don't have a command complete now we'll				 * never get one since we just reset everything;				 * better end the request.				 *				 * If we do have a command complete we'll fall				 * through to the SENDING_STOP command and				 * everything will be peachy keen.				 */				if (!test_bit(EVENT_CMD_COMPLETE,					      &host->pending_events)) {					host->cmd = NULL;					dw_mci_request_end(host, mrq);					goto unlock;				}			}
if (!test_bit(EVENT_CMD_COMPLETE,					      &host->pending_events)) {					host->cmd = NULL;					dw_mci_request_end(host, mrq);					goto unlock;				}
!test_bit(EVENT_CMD_COMPLETE,					      &host->pending_events)
test_bit(EVENT_CMD_COMPLETE,					      &host->pending_events)
test_bit
test_bit
EVENT_CMD_COMPLETE
EVENT_CMD_COMPLETE
&host->pending_events
host->pending_events
host
host
pending_events
{					host->cmd = NULL;					dw_mci_request_end(host, mrq);					goto unlock;				}
host->cmd = NULL;
host->cmd = NULL
host->cmd
host
host
cmd
NULL
NULL
dw_mci_request_end(host, mrq);
dw_mci_request_end(host, mrq)
dw_mci_request_end
dw_mci_request_end
host
host
mrq
mrq
goto unlock;
unlock
prev_state = state = STATE_SENDING_STOP;
prev_state = state = STATE_SENDING_STOP
prev_state
prev_state
state = STATE_SENDING_STOP
state
state
STATE_SENDING_STOP
STATE_SENDING_STOP
case STATE_SENDING_STOP:
STATE_SENDING_STOP
STATE_SENDING_STOP
if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;
!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events)
test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events)
test_and_clear_bit
test_and_clear_bit
EVENT_CMD_COMPLETE
EVENT_CMD_COMPLETE
&host->pending_events
host->pending_events
host
host
pending_events
break;
if (mrq->cmd->error && mrq->data)				dw_mci_reset(host);
mrq->cmd->error && mrq->data
mrq->cmd->error
mrq->cmd
mrq
mrq
cmd
error
mrq->data
mrq
mrq
data
dw_mci_reset(host);
dw_mci_reset(host)
dw_mci_reset
dw_mci_reset
host
host
host->cmd = NULL;
host->cmd = NULL
host->cmd
host
host
cmd
NULL
NULL
host->data = NULL;
host->data = NULL
host->data
host
host
data
NULL
NULL
if (mrq->stop)				dw_mci_command_complete(host, mrq->stop);			else				host->cmd_status = 0;
mrq->stop
mrq
mrq
stop
dw_mci_command_complete(host, mrq->stop);
dw_mci_command_complete(host, mrq->stop)
dw_mci_command_complete
dw_mci_command_complete
host
host
mrq->stop
mrq
mrq
stop
host->cmd_status = 0;
host->cmd_status = 0
host->cmd_status
host
host
cmd_status
0
dw_mci_request_end(host, mrq);
dw_mci_request_end(host, mrq)
dw_mci_request_end
dw_mci_request_end
host
host
mrq
mrq
goto unlock;
unlock
case STATE_DATA_ERROR:
STATE_DATA_ERROR
STATE_DATA_ERROR
if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events))				break;
!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events)
test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events)
test_and_clear_bit
test_and_clear_bit
EVENT_XFER_COMPLETE
EVENT_XFER_COMPLETE
&host->pending_events
host->pending_events
host
host
pending_events
break;
state = STATE_DATA_BUSY;
state = STATE_DATA_BUSY
state
state
STATE_DATA_BUSY
STATE_DATA_BUSY
break;
state != prev_state
state
state
prev_state
prev_state
host->state = state;
host->state = state
host->state
host
host
state
state
state
unlock:	spin_unlock(&host->lock);
unlock
spin_unlock(&host->lock);
spin_unlock(&host->lock)
spin_unlock
spin_unlock
&host->lock
host->lock
host
host
lock
-----joern-----
(278,82,0)
(35,141,0)
(384,245,0)
(185,241,0)
(128,254,0)
(44,363,0)
(248,294,0)
(197,358,0)
(95,126,0)
(16,82,0)
(213,405,0)
(363,16,0)
(55,374,0)
(341,345,0)
(207,228,0)
(215,363,0)
(235,324,0)
(344,405,0)
(76,30,0)
(360,141,0)
(342,183,0)
(96,370,0)
(88,361,0)
(114,408,0)
(78,82,0)
(287,225,0)
(168,26,0)
(249,43,0)
(33,271,0)
(299,350,0)
(281,290,0)
(149,4,0)
(138,409,0)
(375,163,0)
(119,51,0)
(99,175,0)
(198,375,0)
(340,361,0)
(303,148,0)
(223,49,0)
(330,89,0)
(38,360,0)
(327,335,0)
(406,408,0)
(217,361,0)
(326,364,0)
(395,43,0)
(194,217,0)
(113,361,0)
(261,82,0)
(171,361,0)
(320,289,0)
(167,113,0)
(137,172,0)
(295,369,0)
(276,217,0)
(155,229,0)
(101,223,0)
(245,79,0)
(98,391,0)
(399,380,0)
(204,1,0)
(124,108,0)
(312,228,0)
(305,294,0)
(296,132,0)
(99,281,0)
(351,77,0)
(232,372,0)
(397,82,0)
(28,43,0)
(104,165,0)
(19,372,0)
(152,82,0)
(98,64,0)
(416,302,0)
(68,82,0)
(337,333,0)
(374,55,0)
(96,248,0)
(289,361,0)
(5,392,0)
(347,407,0)
(136,276,0)
(177,35,0)
(311,2,0)
(336,417,0)
(18,366,0)
(325,23,0)
(47,361,0)
(248,358,0)
(106,303,0)
(300,144,0)
(366,361,0)
(103,371,0)
(343,82,0)
(220,245,0)
(227,49,0)
(376,358,0)
(381,406,0)
(90,51,0)
(84,391,0)
(174,154,0)
(388,108,0)
(259,82,0)
(362,82,0)
(250,82,0)
(233,242,0)
(345,93,0)
(17,134,0)
(42,240,0)
(363,245,0)
(366,30,0)
(402,321,0)
(357,248,0)
(162,96,0)
(174,245,0)
(25,361,0)
(395,250,0)
(400,175,0)
(294,248,0)
(0,347,0)
(394,286,0)
(35,361,0)
(316,181,0)
(203,77,0)
(64,98,0)
(4,391,0)
(363,402,0)
(244,402,0)
(164,367,0)
(225,82,0)
(142,79,0)
(112,311,0)
(384,74,0)
(182,361,0)
(328,137,0)
(390,388,0)
(116,187,0)
(258,89,0)
(234,74,0)
(165,57,0)
(222,51,0)
(34,282,0)
(35,391,0)
(174,74,0)
(369,82,0)
(48,248,0)
(174,347,0)
(403,414,0)
(32,357,0)
(373,409,0)
(363,373,0)
(345,391,0)
(52,40,0)
(385,371,0)
(277,120,0)
(363,261,0)
(80,340,0)
(187,361,0)
(350,388,0)
(237,304,0)
(267,280,0)
(85,126,0)
(81,25,0)
(363,74,0)
(113,167,0)
(89,330,0)
(324,409,0)
(102,404,0)
(274,91,0)
(192,153,0)
(285,286,0)
(49,361,0)
(246,294,0)
(411,238,0)
(188,19,0)
(94,260,0)
(338,278,0)
(396,174,0)
(146,358,0)
(349,98,0)
(163,375,0)
(410,250,0)
(49,223,0)
(29,82,0)
(368,40,0)
(20,289,0)
(172,137,0)
(134,384,0)
(117,124,0)
(329,187,0)
(276,371,0)
(151,388,0)
(208,261,0)
(201,282,0)
(207,299,0)
(304,361,0)
(158,233,0)
(321,402,0)
(384,414,0)
(386,210,0)
(120,354,0)
(247,2,0)
(74,358,0)
(291,365,0)
(169,352,0)
(205,392,0)
(144,272,0)
(64,344,0)
(417,361,0)
(164,167,0)
(330,132,0)
(363,414,0)
(29,163,0)
(7,273,0)
(77,108,0)
(345,55,0)
(268,171,0)
(157,113,0)
(15,82,0)
(186,273,0)
(202,79,0)
(346,384,0)
(190,365,0)
(333,284,0)
(335,34,0)
(333,361,0)
(40,391,0)
(241,60,0)
(415,225,0)
(180,358,0)
(310,358,0)
(201,248,0)
(283,47,0)
(87,82,0)
(323,281,0)
(275,361,0)
(280,248,0)
(286,108,0)
(1,306,0)
(260,183,0)
(356,23,0)
(120,284,0)
(170,333,0)
(200,124,0)
(257,358,0)
(334,361,0)
(210,207,0)
(19,361,0)
(111,374,0)
(1,361,0)
(24,358,0)
(108,47,0)
(278,4,0)
(161,347,0)
(3,82,0)
(209,358,0)
(41,181,0)
(30,60,0)
(273,108,0)
(388,350,0)
(123,293,0)
(354,120,0)
(282,34,0)
(36,412,0)
(389,16,0)
(334,74,0)
(181,401,0)
(133,82,0)
(221,82,0)
(311,361,0)
(391,82,0)
(45,408,0)
(352,169,0)
(304,22,0)
(173,4,0)
(83,82,0)
(51,222,0)
(371,276,0)
(22,302,0)
(290,281,0)
(137,108,0)
(132,361,0)
(91,84,0)
(55,345,0)
(284,120,0)
(89,258,0)
(93,345,0)
(16,389,0)
(324,361,0)
(19,248,0)
(376,222,0)
(284,333,0)
(286,339,0)
(139,393,0)
(344,64,0)
(384,261,0)
(167,164,0)
(165,361,0)
(263,217,0)
(294,361,0)
(58,113,0)
(1,229,0)
(223,101,0)
(412,361,0)
(4,361,0)
(8,302,0)
(211,201,0)
(212,101,0)
(348,84,0)
(331,272,0)
(43,395,0)
(363,174,0)
(279,25,0)
(40,368,0)
(143,26,0)
(12,132,0)
(171,118,0)
(408,406,0)
(255,389,0)
(27,402,0)
(357,182,0)
(95,361,0)
(140,82,0)
(352,358,0)
(322,375,0)
(148,248,0)
(293,336,0)
(361,165,0)
(361,358,0)
(2,311,0)
(413,353,0)
(407,82,0)
(398,49,0)
(169,25,0)
(321,82,0)
(236,79,0)
(393,82,0)
(189,242,0)
(238,298,0)
(407,347,0)
(272,144,0)
(265,137,0)
(91,278,0)
(387,82,0)
(216,35,0)
(193,148,0)
(384,233,0)
(9,82,0)
(289,320,0)
(241,248,0)
(191,366,0)
(332,353,0)
(125,320,0)
(92,271,0)
(318,311,0)
(240,243,0)
(384,389,0)
(39,261,0)
(130,247,0)
(156,142,0)
(239,154,0)
(56,373,0)
(77,361,0)
(166,127,0)
(350,299,0)
(365,260,0)
(241,361,0)
(382,229,0)
(214,357,0)
(288,93,0)
(195,82,0)
(217,276,0)
(54,241,0)
(160,174,0)
(380,361,0)
(313,172,0)
(174,261,0)
(187,393,0)
(26,108,0)
(378,175,0)
(25,169,0)
(335,108,0)
(145,82,0)
(71,88,0)
(175,361,0)
(367,164,0)
(96,361,0)
(297,95,0)
(271,298,0)
(174,373,0)
(319,272,0)
(10,98,0)
(414,392,0)
(118,171,0)
(247,82,0)
(363,407,0)
(122,295,0)
(401,303,0)
(22,304,0)
(136,339,0)
(243,240,0)
(174,389,0)
(272,248,0)
(108,358,0)
(11,64,0)
(363,321,0)
(391,35,0)
(309,380,0)
(276,136,0)
(206,300,0)
(97,201,0)
(295,361,0)
(124,361,0)
(266,108,0)
(26,361,0)
(256,280,0)
(307,306,0)
(72,304,0)
(262,84,0)
(43,361,0)
(375,361,0)
(219,373,0)
(374,278,0)
(105,29,0)
(282,201,0)
(250,395,0)
(165,121,0)
(229,1,0)
(314,93,0)
(308,245,0)
(300,108,0)
(2,247,0)
(69,50,0)
(231,19,0)
(65,321,0)
(230,287,0)
(174,233,0)
(134,361,0)
(405,50,0)
(57,165,0)
(222,376,0)
(408,361,0)
(253,300,0)
(302,22,0)
(380,108,0)
(317,295,0)
(303,401,0)
(251,369,0)
(252,210,0)
(118,240,0)
(271,361,0)
(14,233,0)
(383,47,0)
(178,164,0)
(59,409,0)
(129,407,0)
(100,87,0)
(47,108,0)
(176,335,0)
(61,16,0)
(199,228,0)
(31,82,0)
(172,127,0)
(401,181,0)
(181,248,0)
(218,95,0)
(13,360,0)
(66,391,0)
(107,364,0)
(377,87,0)
(109,60,0)
(360,361,0)
(148,303,0)
(384,373,0)
(287,361,0)
(270,40,0)
(51,361,0)
(70,82,0)
(141,82,0)
(306,1,0)
(150,414,0)
(182,357,0)
(1,183,0)
(384,402,0)
(196,82,0)
(153,278,0)
(315,82,0)
(174,414,0)
(153,368,0)
(298,271,0)
(292,417,0)
(405,344,0)
(174,402,0)
(135,82,0)
(34,335,0)
(264,372,0)
(132,330,0)
(74,334,0)
(87,361,0)
(380,409,0)
(299,207,0)
(301,306,0)
(163,29,0)
(147,358,0)
(53,289,0)
(363,389,0)
(405,278,0)
(46,134,0)
(384,347,0)
(226,334,0)
(363,347,0)
(417,336,0)
(142,361,0)
(63,148,0)
(184,171,0)
(144,300,0)
(37,287,0)
(302,8,0)
(254,361,0)
(228,207,0)
(175,99,0)
(339,286,0)
(50,405,0)
(87,248,0)
(359,96,0)
(62,182,0)
(336,293,0)
(21,417,0)
(179,298,0)
(271,108,0)
(228,361,0)
(207,210,0)
(88,392,0)
(240,118,0)
(306,361,0)
(229,248,0)
(131,389,0)
(339,136,0)
(269,370,0)
(75,89,0)
(363,233,0)
(86,334,0)
(298,82,0)
(73,358,0)
(93,248,0)
(84,91,0)
(368,153,0)
(384,358,0)
(379,82,0)
(6,141,0)
(281,99,0)
(115,82,0)
(260,365,0)
(4,278,0)
(417,21,1)
(251,295,1)
(272,319,1)
(53,354,1)
(206,253,1)
(184,42,1)
(44,189,1)
(182,357,1)
(122,317,1)
(407,347,1)
(108,47,1)
(321,402,1)
(55,374,1)
(165,104,1)
(350,299,1)
(200,339,1)
(41,316,1)
(170,277,1)
(171,268,1)
(219,56,1)
(92,179,1)
(142,156,1)
(267,225,1)
(398,212,1)
(344,405,1)
(408,361,1)
(189,233,1)
(173,338,1)
(322,198,1)
(4,361,1)
(302,22,1)
(174,233,1)
(359,162,1)
(384,233,1)
(40,391,1)
(27,244,1)
(414,403,1)
(44,159,1)
(410,369,1)
(1,229,1)
(19,248,1)
(381,408,1)
(324,235,1)
(26,108,1)
(26,143,1)
(320,289,1)
(166,172,1)
(67,376,1)
(88,361,1)
(109,241,1)
(153,278,1)
(212,355,1)
(406,408,1)
(153,192,1)
(174,245,1)
(384,402,1)
(44,83,1)
(110,367,1)
(273,108,1)
(323,355,1)
(252,386,1)
(222,51,1)
(292,123,1)
(216,66,1)
(349,10,1)
(276,217,1)
(282,201,1)
(286,108,1)
(84,391,1)
(182,361,1)
(203,350,1)
(363,414,1)
(285,394,1)
(48,108,1)
(148,248,1)
(125,289,1)
(348,262,1)
(371,385,1)
(33,92,1)
(303,106,1)
(61,258,1)
(389,255,1)
(186,7,1)
(132,12,1)
(403,150,1)
(388,108,1)
(118,171,1)
(139,187,1)
(226,86,1)
(116,401,1)
(231,188,1)
(273,186,1)
(335,176,1)
(360,361,1)
(195,261,1)
(386,228,1)
(375,322,1)
(160,396,1)
(283,383,1)
(44,202,1)
(91,84,1)
(338,29,1)
(64,11,1)
(44,110,1)
(262,55,1)
(319,331,1)
(263,194,1)
(43,361,1)
(26,361,1)
(61,273,1)
(384,347,1)
(384,346,1)
(64,98,1)
(65,293,1)
(17,46,1)
(12,296,1)
(89,330,1)
(167,113,1)
(207,228,1)
(81,279,1)
(415,287,1)
(55,345,1)
(384,245,1)
(256,267,1)
(342,1,1)
(334,361,1)
(312,199,1)
(28,249,1)
(49,361,1)
(90,384,1)
(144,272,1)
(14,344,1)
(47,283,1)
(417,361,1)
(90,232,1)
(411,298,1)
(351,203,1)
(43,28,1)
(96,248,1)
(175,378,1)
(365,190,1)
(40,270,1)
(295,122,1)
(202,245,1)
(401,303,1)
(243,240,1)
(100,126,1)
(204,260,1)
(22,304,1)
(308,220,1)
(112,130,1)
(131,61,1)
(394,88,1)
(77,361,1)
(218,280,1)
(323,16,1)
(287,230,1)
(111,345,1)
(277,321,1)
(198,105,1)
(32,214,1)
(384,261,1)
(34,335,1)
(217,361,1)
(250,395,1)
(47,361,1)
(366,361,1)
(1,361,1)
(284,333,1)
(85,95,1)
(325,320,1)
(362,87,1)
(77,108,1)
(44,138,1)
(253,272,1)
(141,6,1)
(174,373,1)
(317,354,1)
(187,361,1)
(336,417,1)
(254,128,1)
(91,278,1)
(331,282,1)
(54,30,1)
(238,298,1)
(174,402,1)
(396,248,1)
(363,407,1)
(357,32,1)
(369,251,1)
(328,144,1)
(293,336,1)
(171,361,1)
(51,361,1)
(113,361,1)
(408,114,1)
(224,8,1)
(240,118,1)
(134,17,1)
(269,96,1)
(149,173,1)
(258,89,1)
(266,74,1)
(99,175,1)
(363,233,1)
(254,361,1)
(345,93,1)
(324,361,1)
(378,400,1)
(390,142,1)
(18,191,1)
(44,355,1)
(87,248,1)
(320,125,1)
(339,136,1)
(42,101,1)
(363,389,1)
(172,313,1)
(344,64,1)
(103,217,1)
(87,361,1)
(58,178,1)
(384,373,1)
(363,74,1)
(25,361,1)
(50,69,1)
(374,278,1)
(385,103,1)
(363,261,1)
(39,208,1)
(416,355,1)
(271,33,1)
(107,406,1)
(352,169,1)
(366,18,1)
(185,54,1)
(241,361,1)
(294,361,1)
(157,58,1)
(168,273,1)
(16,389,1)
(21,292,1)
(75,238,1)
(261,39,1)
(400,323,1)
(318,112,1)
(37,393,1)
(29,163,1)
(117,200,1)
(244,65,1)
(341,278,1)
(124,361,1)
(401,181,1)
(158,14,1)
(83,355,1)
(148,63,1)
(329,116,1)
(281,99,1)
(229,382,1)
(156,293,1)
(94,55,1)
(210,252,1)
(136,276,1)
(396,363,1)
(199,388,1)
(119,90,1)
(288,314,1)
(282,34,1)
(90,362,1)
(271,361,1)
(214,62,1)
(363,174,1)
(325,412,1)
(150,124,1)
(280,256,1)
(165,121,1)
(30,76,1)
(137,108,1)
(373,219,1)
(44,205,1)
(44,195,1)
(412,361,1)
(19,361,1)
(333,337,1)
(77,351,1)
(363,215,1)
(412,36,1)
(190,291,1)
(164,167,1)
(123,247,1)
(380,361,1)
(132,361,1)
(304,361,1)
(235,344,1)
(339,286,1)
(46,363,1)
(96,361,1)
(406,381,1)
(311,361,1)
(35,141,1)
(229,248,1)
(272,248,1)
(227,398,1)
(114,45,1)
(225,415,1)
(211,97,1)
(307,301,1)
(155,306,1)
(271,108,1)
(303,148,1)
(368,40,1)
(241,185,1)
(384,414,1)
(8,302,1)
(354,120,1)
(276,371,1)
(80,406,1)
(245,308,1)
(220,350,1)
(347,161,1)
(304,72,1)
(6,360,1)
(193,290,1)
(104,275,1)
(280,248,1)
(101,223,1)
(335,108,1)
(305,48,1)
(294,246,1)
(265,328,1)
(377,100,1)
(314,341,1)
(297,218,1)
(208,8,1)
(295,361,1)
(388,151,1)
(300,206,1)
(201,248,1)
(395,43,1)
(363,373,1)
(383,266,1)
(13,391,1)
(4,391,1)
(246,305,1)
(174,389,1)
(90,109,1)
(340,80,1)
(44,325,1)
(127,166,1)
(248,294,1)
(382,155,1)
(374,111,1)
(363,402,1)
(130,243,1)
(153,368,1)
(138,373,1)
(327,238,1)
(300,108,1)
(86,234,1)
(93,248,1)
(100,182,1)
(91,274,1)
(179,250,1)
(187,329,1)
(277,355,1)
(87,377,1)
(172,137,1)
(45,243,1)
(74,334,1)
(181,41,1)
(298,271,1)
(223,49,1)
(107,340,1)
(98,391,1)
(76,366,1)
(260,365,1)
(150,339,1)
(384,389,1)
(84,348,1)
(113,157,1)
(278,4,1)
(181,248,1)
(363,347,1)
(38,13,1)
(96,359,1)
(212,407,1)
(0,129,1)
(350,388,1)
(393,139,1)
(52,91,1)
(128,401,1)
(337,170,1)
(88,71,1)
(234,352,1)
(380,108,1)
(363,321,1)
(161,0,1)
(230,37,1)
(169,25,1)
(97,34,1)
(333,361,1)
(367,164,1)
(238,411,1)
(2,311,1)
(213,91,1)
(120,284,1)
(188,144,1)
(162,153,1)
(340,361,1)
(301,204,1)
(175,361,1)
(56,380,1)
(71,101,1)
(289,20,1)
(35,177,1)
(159,290,1)
(134,361,1)
(36,320,1)
(174,414,1)
(363,245,1)
(106,148,1)
(44,107,1)
(174,347,1)
(232,19,1)
(345,391,1)
(105,141,1)
(375,361,1)
(205,414,1)
(174,74,1)
(233,158,1)
(334,226,1)
(66,367,1)
(35,361,1)
(72,237,1)
(357,248,1)
(306,307,1)
(384,74,1)
(143,168,1)
(299,207,1)
(19,231,1)
(4,149,1)
(399,309,1)
(290,281,1)
(380,399,1)
(90,342,1)
(151,390,1)
(69,213,1)
(289,361,1)
(144,300,1)
(376,222,1)
(201,211,1)
(228,312,1)
(405,50,1)
(220,77,1)
(49,227,1)
(129,153,1)
(95,361,1)
(249,410,1)
(255,131,1)
(402,27,1)
(137,265,1)
(274,84,1)
(355,174,1)
(330,132,1)
(194,286,1)
(363,16,1)
(62,280,1)
(270,52,1)
(311,318,1)
(247,2,1)
(217,263,1)
(7,282,1)
(361,165,1)
(63,193,1)
(313,137,1)
(279,361,1)
(207,210,1)
(215,44,1)
(306,361,1)
(286,285,1)
(61,26,1)
(174,160,1)
(291,94,1)
(346,134,1)
(237,416,1)
(191,258,1)
(11,98,1)
(174,261,1)
(51,119,1)
(287,361,1)
(391,35,1)
(241,248,1)
(177,216,1)
(165,57,1)
(296,75,1)
(44,224,1)
(192,368,1)
(93,288,1)
(188,127,1)
(1,306,1)
(90,269,1)
(25,81,1)
(142,361,1)
(309,324,1)
(163,375,1)
(95,297,1)
(116,254,1)
(178,355,1)
(360,38,1)
(176,327,1)
(316,303,1)
(405,278,1)
(124,117,1)
(20,53,1)
(98,349,1)
(126,85,1)
(124,108,1)
(10,405,1)
(268,184,1)
(228,361,1)
(277,355,2)
(62,280,2)
(400,282,2)
(280,248,2)
(291,55,2)
(375,367,2)
(363,347,2)
(131,282,2)
(252,388,2)
(210,388,2)
(354,355,2)
(157,355,2)
(192,368,2)
(1,55,2)
(322,367,2)
(395,43,2)
(63,290,2)
(336,243,2)
(174,347,2)
(377,290,2)
(241,258,2)
(187,290,2)
(174,74,2)
(19,248,2)
(333,293,2)
(156,293,2)
(345,367,2)
(241,361,2)
(227,153,2)
(271,108,2)
(290,282,2)
(391,367,2)
(249,354,2)
(89,330,2)
(417,243,2)
(130,243,2)
(304,361,2)
(347,153,2)
(179,354,2)
(12,238,2)
(28,354,2)
(181,303,2)
(376,222,2)
(341,367,2)
(290,355,2)
(412,320,2)
(251,354,2)
(374,345,2)
(55,345,2)
(205,101,2)
(169,25,2)
(11,405,2)
(13,367,2)
(335,108,2)
(333,361,2)
(262,55,2)
(193,290,2)
(174,414,2)
(399,344,2)
(304,355,2)
(254,401,2)
(369,354,2)
(339,286,2)
(357,280,2)
(278,367,2)
(406,243,2)
(134,363,2)
(95,280,2)
(278,4,2)
(35,141,2)
(216,367,2)
(116,290,2)
(97,34,2)
(201,248,2)
(198,367,2)
(272,282,2)
(302,355,2)
(293,243,2)
(14,344,2)
(91,278,2)
(276,371,2)
(171,101,2)
(131,258,2)
(163,375,2)
(44,91,2)
(336,417,2)
(172,144,2)
(185,258,2)
(340,361,2)
(84,55,2)
(233,344,2)
(307,55,2)
(363,321,2)
(44,293,2)
(53,354,2)
(359,153,2)
(415,290,2)
(367,355,2)
(161,153,2)
(348,55,2)
(243,240,2)
(286,108,2)
(309,344,2)
(172,137,2)
(128,401,2)
(19,361,2)
(339,136,2)
(284,293,2)
(7,282,2)
(405,50,2)
(357,248,2)
(313,144,2)
(32,280,2)
(195,8,2)
(295,361,2)
(25,361,2)
(342,55,2)
(248,294,2)
(160,363,2)
(144,300,2)
(35,361,2)
(84,391,2)
(270,91,2)
(380,344,2)
(290,258,2)
(175,282,2)
(85,280,2)
(363,233,2)
(174,373,2)
(174,261,2)
(17,363,2)
(182,361,2)
(384,261,2)
(144,282,2)
(384,245,2)
(142,361,2)
(44,243,2)
(201,34,2)
(215,354,2)
(44,101,2)
(333,355,2)
(256,290,2)
(405,278,2)
(64,405,2)
(136,286,2)
(223,355,2)
(393,290,2)
(44,354,2)
(292,243,2)
(384,233,2)
(330,132,2)
(44,367,2)
(101,153,2)
(153,368,2)
(49,361,2)
(273,108,2)
(72,355,2)
(114,243,2)
(352,169,2)
(287,361,2)
(34,335,2)
(219,344,2)
(363,367,2)
(337,293,2)
(112,243,2)
(284,355,2)
(21,243,2)
(401,181,2)
(164,167,2)
(276,217,2)
(380,361,2)
(408,361,2)
(218,280,2)
(306,361,2)
(245,293,2)
(26,273,2)
(363,389,2)
(132,361,2)
(231,282,2)
(385,286,2)
(280,290,2)
(215,355,2)
(208,8,2)
(378,258,2)
(223,153,2)
(211,34,2)
(178,355,2)
(311,243,2)
(344,91,2)
(6,367,2)
(174,402,2)
(206,272,2)
(215,293,2)
(230,290,2)
(120,355,2)
(170,293,2)
(363,293,2)
(0,153,2)
(381,243,2)
(260,365,2)
(238,354,2)
(42,101,2)
(337,355,2)
(407,347,2)
(212,153,2)
(362,290,2)
(384,74,2)
(103,286,2)
(16,389,2)
(344,405,2)
(144,272,2)
(363,243,2)
(324,344,2)
(92,354,2)
(363,354,2)
(8,355,2)
(124,361,2)
(222,51,2)
(247,2,2)
(122,354,2)
(174,389,2)
(1,229,2)
(186,282,2)
(194,286,2)
(170,355,2)
(168,273,2)
(416,355,2)
(268,101,2)
(187,361,2)
(98,405,2)
(238,298,2)
(339,101,2)
(83,355,2)
(300,108,2)
(55,374,2)
(127,144,2)
(360,367,2)
(33,354,2)
(207,388,2)
(360,361,2)
(182,280,2)
(406,408,2)
(395,354,2)
(76,258,2)
(312,388,2)
(96,248,2)
(398,355,2)
(294,361,2)
(88,361,2)
(40,391,2)
(350,299,2)
(34,238,2)
(401,290,2)
(225,290,2)
(137,108,2)
(412,361,2)
(273,282,2)
(69,91,2)
(40,91,2)
(247,243,2)
(335,238,2)
(329,290,2)
(87,290,2)
(235,344,2)
(199,388,2)
(295,354,2)
(149,367,2)
(46,363,2)
(58,355,2)
(299,388,2)
(378,355,2)
(403,101,2)
(213,91,2)
(109,258,2)
(410,354,2)
(91,84,2)
(345,391,2)
(94,55,2)
(215,101,2)
(105,367,2)
(55,367,2)
(371,286,2)
(35,367,2)
(181,248,2)
(54,258,2)
(134,361,2)
(388,108,2)
(41,303,2)
(151,293,2)
(338,367,2)
(212,355,2)
(52,91,2)
(286,101,2)
(324,361,2)
(323,282,2)
(10,405,2)
(19,282,2)
(350,293,2)
(405,91,2)
(330,238,2)
(16,282,2)
(363,402,2)
(363,355,2)
(346,363,2)
(143,273,2)
(271,354,2)
(65,293,2)
(340,406,2)
(98,391,2)
(314,367,2)
(368,40,2)
(366,361,2)
(26,361,2)
(289,361,2)
(388,293,2)
(153,278,2)
(29,367,2)
(99,282,2)
(384,347,2)
(77,361,2)
(124,108,2)
(368,91,2)
(391,35,2)
(345,93,2)
(380,108,2)
(351,350,2)
(4,361,2)
(87,248,2)
(137,144,2)
(269,153,2)
(64,98,2)
(129,153,2)
(215,367,2)
(66,367,2)
(27,293,2)
(394,101,2)
(174,245,2)
(142,293,2)
(254,361,2)
(107,243,2)
(207,228,2)
(155,55,2)
(159,290,2)
(123,243,2)
(363,414,2)
(18,258,2)
(188,282,2)
(327,238,2)
(384,389,2)
(297,280,2)
(176,238,2)
(363,261,2)
(207,210,2)
(175,361,2)
(173,367,2)
(138,344,2)
(293,336,2)
(117,339,2)
(36,320,2)
(61,258,2)
(215,290,2)
(389,258,2)
(321,293,2)
(44,290,2)
(281,355,2)
(241,248,2)
(166,144,2)
(43,361,2)
(366,258,2)
(232,282,2)
(136,276,2)
(43,354,2)
(16,258,2)
(190,55,2)
(363,74,2)
(311,361,2)
(417,361,2)
(87,361,2)
(141,367,2)
(400,355,2)
(118,101,2)
(165,57,2)
(182,357,2)
(260,55,2)
(49,153,2)
(163,367,2)
(267,290,2)
(4,391,2)
(363,174,2)
(354,120,2)
(255,282,2)
(110,367,2)
(298,354,2)
(400,258,2)
(258,89,2)
(95,361,2)
(344,64,2)
(214,280,2)
(281,258,2)
(150,101,2)
(363,373,2)
(386,388,2)
(158,344,2)
(1,306,2)
(96,153,2)
(229,248,2)
(355,363,2)
(203,350,2)
(125,354,2)
(290,281,2)
(111,345,2)
(223,49,2)
(363,407,2)
(402,293,2)
(321,402,2)
(118,171,2)
(285,101,2)
(288,367,2)
(367,164,2)
(106,290,2)
(316,303,2)
(50,91,2)
(323,355,2)
(1,361,2)
(37,290,2)
(93,248,2)
(261,8,2)
(302,22,2)
(148,290,2)
(2,243,2)
(250,395,2)
(30,258,2)
(361,165,2)
(4,367,2)
(303,148,2)
(265,144,2)
(334,361,2)
(320,289,2)
(215,243,2)
(89,238,2)
(398,153,2)
(396,363,2)
(162,153,2)
(318,243,2)
(148,248,2)
(120,293,2)
(228,361,2)
(20,354,2)
(277,293,2)
(175,258,2)
(374,278,2)
(276,286,2)
(401,303,2)
(93,367,2)
(227,355,2)
(99,175,2)
(284,333,2)
(132,238,2)
(108,47,2)
(45,243,2)
(38,367,2)
(282,201,2)
(281,99,2)
(373,344,2)
(200,339,2)
(75,238,2)
(306,55,2)
(189,344,2)
(8,302,2)
(174,233,2)
(153,91,2)
(328,144,2)
(272,248,2)
(281,282,2)
(408,243,2)
(202,293,2)
(56,344,2)
(126,280,2)
(240,101,2)
(191,258,2)
(255,258,2)
(296,238,2)
(258,238,2)
(217,361,2)
(164,355,2)
(71,101,2)
(139,290,2)
(80,406,2)
(287,290,2)
(101,223,2)
(215,91,2)
(250,354,2)
(74,334,2)
(39,8,2)
(382,55,2)
(308,293,2)
(220,293,2)
(263,286,2)
(274,84,2)
(282,34,2)
(77,108,2)
(100,290,2)
(375,361,2)
(113,355,2)
(363,101,2)
(113,361,2)
(390,293,2)
(378,282,2)
(349,405,2)
(217,286,2)
(414,101,2)
(44,355,2)
(2,311,2)
(365,55,2)
(271,361,2)
(331,282,2)
(325,354,2)
(91,55,2)
(228,388,2)
(101,355,2)
(243,101,2)
(175,355,2)
(22,355,2)
(298,271,2)
(299,207,2)
(51,361,2)
(49,355,2)
(22,304,2)
(29,163,2)
(282,238,2)
(363,290,2)
(411,354,2)
(88,101,2)
(303,290,2)
(184,101,2)
(99,258,2)
(167,113,2)
(384,363,2)
(174,363,2)
(120,284,2)
(177,367,2)
(167,355,2)
(171,361,2)
(320,354,2)
(229,55,2)
(253,272,2)
(300,272,2)
(26,108,2)
(47,361,2)
(350,388,2)
(407,153,2)
(384,373,2)
(363,91,2)
(99,355,2)
(124,339,2)
(363,16,2)
(244,293,2)
(224,8,2)
(77,350,2)
(363,245,2)
(61,282,2)
(237,355,2)
(301,55,2)
(384,402,2)
(317,354,2)
(96,361,2)
(204,55,2)
(354,293,2)
(289,354,2)
(323,258,2)
(384,414,2)
(240,118,2)
(165,121,2)
(319,282,2)
(389,282,2)
-----------------------------------
(0,state)
(1,__dw_mci_start_request(host, host->cur_slot,\n\\n\\t\\t\\t\\t\\t\\t       mrq->cmd)
(2,&host->completed_events)
(3,if (mrq->stop)
(4,dw_mci_command_complete(host, cmd)
(5,if (data->stop ||\n\\n\\t\\t\\t\\t    !(host->data_status & (SDMMC_INT_DRTO |\n\\n\\t\\t\\t\\t\\t\\t\\t   SDMMC_INT_EBE)
(6,NULL)
(7,data)
(8,!test_and_clear_bit(EVENT_XFER_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(9,if (cmd == mrq->sbc && !err)
(10,cmd)
(11,MMC_SEND_TUNING_BLOCK)
(12,pending_events)
(13,host)
(14,state)
(15,case STATE_SENDING_CMD:)
(16,prev_state = state = STATE_SENDING_STOP)
(17,state)
(18,cmd)
(19,dw_mci_request_end(host, mrq)
(20,dir_status)
(21,pending_events)
(22,&host->pending_events)
(23,)
(24,state)
(25,host->lock)
(26,send_stop_abort(host, data)
(27,STATE_DATA_BUSY)
(28,completed_events)
(29,set_bit(EVENT_CMD_COMPLETE, &host->completed_events)
(30,host->cmd = NULL)
(31,if (!test_and_clear_bit(EVENT_CMD_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(32,stop)
(33,data)
(34,!data->stop)
(35,host->cmd)
(36,host)
(37,host)
(38,cmd)
(39,STATE_DATA_BUSY)
(40,cmd->data)
(41,data)
(42,EVENT_XFER_COMPLETE)
(43,host->completed_events)
(44,state)
(45,host)
(46,host)
(47,host->data)
(48,mrq)
(49,host->pending_events)
(50,-ETIMEDOUT)
(51,host->lock)
(52,cmd)
(53,host)
(54,host)
(55,cmd == mrq->sbc && !err)
(56,state)
(57,struct dw_mci *)
(58,host)
(59,if ((err != -ETIMEDOUT)
(60,)
(61,prev_state)
(62,host)
(63,cmd)
(64,cmd->opcode == MMC_SEND_TUNING_BLOCK)
(65,prev_state)
(66,cmd)
(67,RET)
(68,case STATE_DATA_BUSY:)
(69,ETIMEDOUT)
(70,case STATE_WAITING_CMD11_DONE:)
(71,host)
(72,pending_events)
(73,cmd)
(74,state = host->state)
(75,EVENT_CMD_COMPLETE)
(76,NULL)
(77,send_stop_abort(host, data)
(78,case STATE_DATA_ERROR:)
(79,)
(80,host)
(81,lock)
(82,)
(83,break;)
(84,cmd->data)
(85,0)
(86,host)
(87,dw_mci_request_end(host, mrq)
(88,dw_mci_stop_dma(host)
(89,test_bit(EVENT_CMD_COMPLETE,\n\\n\\t\\t\\t\\t\\t      &host->pending_events)
(90,host)
(91,cmd->data && err)
(92,host)
(93,mrq->sbc)
(94,prev_state)
(95,host->cmd_status)
(96,dw_mci_request_end(host, mrq)
(97,mrq)
(98,cmd->opcode)
(99,&host->pending_events)
(100,host)
(101,test_and_clear_bit(EVENT_DATA_ERROR,\n\\n\\t\\t\\t\\t\\t       &host->pending_events)
(102,if (!test_bit(EVENT_CMD_COMPLETE,\n\\n\\t\\t\\t\\t\\t      &host->pending_events)
(103,SDMMC_INT_DRTO)
(104,priv)
(105,EVENT_CMD_COMPLETE)
(106,error)
(107,break;)
(108,data = host->data)
(109,goto unlock;)
(110,break;)
(111,err)
(112,host)
(113,host->pending_events)
(114,dir_status)
(115,if (test_and_clear_bit(EVENT_DATA_ERROR,\n\\n\\t\\t\\t\\t\\t       &host->pending_events)
(116,host)
(117,data)
(118,&host->pending_events)
(119,lock)
(120,test_and_clear_bit(EVENT_DATA_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(121,unsigned long priv)
(122,data)
(123,EVENT_DATA_ERROR)
(124,send_stop_abort(host, data)
(125,DW_MCI_RECV_STATUS)
(126,host->cmd_status = 0)
(127,data->stop->error = 0)
(128,host)
(129,prev_state)
(130,EVENT_XFER_COMPLETE)
(131,state)
(132,host->pending_events)
(133,if (cmd->data && err)
(134,host->state)
(135,if (!test_and_clear_bit(EVENT_XFER_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(136,!(host->data_status & (SDMMC_INT_DRTO |\n\\n\\t\\t\\t\\t\\t\\t\\t   SDMMC_INT_EBE)
(137,data->stop)
(138,break;)
(139,NULL)
(140,if (test_and_clear_bit(EVENT_DATA_ERROR,\n\\n\\t\\t\\t\\t\\t       &host->pending_events)
(141,host->cmd = NULL)
(142,dw_mci_stop_dma(host)
(143,data)
(144,mrq->sbc && data->stop)
(145,case STATE_SENDING_CMD11:)
(146,do)
(147,data)
(148,mrq->cmd)
(149,cmd)
(150,state)
(151,stop)
(152,case STATE_SENDING_DATA:)
(153,!cmd->data || err)
(154,)
(155,mrq)
(156,host)
(157,pending_events)
(158,STATE_SENDING_DATA)
(159,break;)
(160,state)
(161,STATE_SENDING_DATA)
(162,host)
(163,&host->completed_events)
(164,test_and_clear_bit(EVENT_CMD_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(165,(struct dw_mci *)
(166,0)
(167,&host->pending_events)
(168,host)
(169,&host->lock)
(170,host)
(171,host->pending_events)
(172,data->stop->error)
(173,host)
(174,prev_state = state)
(175,host->pending_events)
(176,stop)
(177,cmd)
(178,EVENT_CMD_COMPLETE)
(179,err)
(180,unlock:)
(181,mrq->data)
(182,dw_mci_command_complete(host, mrq->stop)
(183,)
(184,host)
(185,mrq)
(186,stop)
(187,host->cmd)
(188,host)
(189,continue;)
(190,STATE_SENDING_CMD)
(191,host)
(192,err)
(193,mrq)
(194,host)
(195,break;)
(196,if (!test_and_clear_bit(EVENT_XFER_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(197,host)
(198,host)
(199,host)
(200,host)
(201,mrq->sbc)
(202,break;)
(203,host)
(204,host)
(205,break;)
(206,stop)
(207,host->data_status & (SDMMC_INT_DRTO |\n\\n\\t\\t\\t\\t\\t\\t\\t   SDMMC_INT_EBE)
(208,state)
(209,err)
(210,SDMMC_INT_DRTO |\n\\n\\t\\t\\t\\t\\t\\t\\t   SDMMC_INT_EBE)
(211,sbc)
(212,EVENT_DATA_ERROR)
(213,err)
(214,mrq)
(215,prev_state)
(216,host)
(217,host->data_status)
(218,host)
(219,STATE_SENDING_STOP)
(220,state)
(221,if (mrq->cmd->error && mrq->data)
(222,&host->lock)
(223,&host->pending_events)
(224,break;)
(225,host->data = NULL)
(226,state)
(227,pending_events)
(228,host->data_status)
(229,mrq->cmd)
(230,data)
(231,mrq)
(232,goto unlock;)
(233,state = STATE_SENDING_DATA)
(234,state)
(235,host)
(236,if (data->stop ||\n\\n\\t\\t\\t\\t    !(host->data_status & (SDMMC_INT_DRTO |\n\\n\\t\\t\\t\\t\\t\\t\\t   SDMMC_INT_EBE)
(237,host)
(238,!err)
(239,switch (state)
(240,test_and_clear_bit(EVENT_XFER_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(241,dw_mci_request_end(host, mrq)
(242,)
(243,!test_and_clear_bit(EVENT_XFER_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(244,state)
(245,state = STATE_DATA_ERROR)
(246,mrq)
(247,set_bit(EVENT_XFER_COMPLETE, &host->completed_events)
(248,mrq = host->mrq)
(249,host)
(250,set_bit(EVENT_DATA_COMPLETE, &host->completed_events)
(251,NULL)
(252,SDMMC_INT_EBE)
(253,data)
(254,dw_mci_reset(host)
(255,STATE_SENDING_STOP)
(256,stop)
(257,mrq)
(258,!test_bit(EVENT_CMD_COMPLETE,\n\\n\\t\\t\\t\\t\\t      &host->pending_events)
(259,case STATE_SENDING_STOP:)
(260,prev_state = state = STATE_SENDING_CMD)
(261,state = STATE_DATA_BUSY)
(262,cmd)
(263,data_status)
(264,if (mrq->sbc && data->stop)
(265,stop)
(266,data)
(267,mrq)
(268,pending_events)
(269,goto unlock;)
(270,data)
(271,dw_mci_data_complete(host, data)
(272,mrq->sbc)
(273,data->stop)
(274,err)
(275,host)
(276,host->data_status & (SDMMC_INT_DRTO |\n\\n\\t\\t\\t\\t\\t\\t\\t   SDMMC_INT_EBE)
(277,EVENT_DATA_COMPLETE)
(278,err = dw_mci_command_complete(host, cmd)
(279,host)
(280,mrq->stop)
(281,test_and_clear_bit(EVENT_CMD_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(282,!data->stop || mrq->sbc)
(283,data)
(284,&host->pending_events)
(285,stop)
(286,data->stop)
(287,host->data)
(288,sbc)
(289,host->dir_status)
(290,!test_and_clear_bit(EVENT_CMD_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(291,state)
(292,host)
(293,test_and_clear_bit(EVENT_DATA_ERROR,\n\\n\\t\\t\\t\\t\\t       &host->pending_events)
(294,host->mrq)
(295,host->data)
(296,host)
(297,cmd_status)
(298,err = dw_mci_data_complete(host, data)
(299,!(host->data_status & (SDMMC_INT_DRTO |\n\\n\\t\\t\\t\\t\\t\\t\\t   SDMMC_INT_EBE)
(300,data->stop)
(301,host)
(302,test_and_clear_bit(EVENT_XFER_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(303,mrq->cmd->error)
(304,host->pending_events)
(305,host)
(306,host->cur_slot)
(307,cur_slot)
(308,STATE_DATA_ERROR)
(309,host)
(310,prev_state)
(311,host->completed_events)
(312,data_status)
(313,error)
(314,mrq)
(315,if (!err)
(316,mrq)
(317,host)
(318,completed_events)
(319,sbc)
(320,host->dir_status == DW_MCI_RECV_STATUS)
(321,prev_state = state = STATE_DATA_BUSY)
(322,completed_events)
(323,EVENT_CMD_COMPLETE)
(324,dw_mci_stop_dma(host)
(325,break;)
(326,if (host->dir_status == DW_MCI_RECV_STATUS)
(327,data)
(328,data)
(329,cmd)
(330,&host->pending_events)
(331,mrq)
(332,if (!data->stop || mrq->sbc)
(333,host->pending_events)
(334,host->state)
(335,data->stop)
(336,&host->pending_events)
(337,pending_events)
(338,err)
(339,data->stop ||\n\\n\\t\\t\\t\\t    !(host->data_status & (SDMMC_INT_DRTO |\n\\n\\t\\t\\t\\t\\t\\t\\t   SDMMC_INT_EBE)
(340,dw_mci_set_drto(host)
(341,cmd)
(342,goto unlock;)
(343,if (!cmd->data || err)
(344,(err != -ETIMEDOUT)
(345,cmd == mrq->sbc)
(346,state)
(347,state = STATE_SENDING_DATA)
(348,data)
(349,opcode)
(350,data->stop ||\n\\n\\t\\t\\t\\t    !(host->data_status & (SDMMC_INT_DRTO |\n\\n\\t\\t\\t\\t\\t\\t\\t   SDMMC_INT_EBE)
(351,data)
(352,spin_lock(&host->lock)
(353,)
(354,!test_and_clear_bit(EVENT_DATA_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(355,state)
(356,if (host->dir_status == DW_MCI_RECV_STATUS)
(357,mrq->stop)
(358,)
(359,mrq)
(360,host->cmd)
(361,*host = (struct dw_mci *)
(362,goto unlock;)
(363,state != prev_state)
(364,)
(365,state = STATE_SENDING_CMD)
(366,host->cmd)
(367,!test_and_clear_bit(EVENT_CMD_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(368,!cmd->data)
(369,host->data = NULL)
(370,)
(371,SDMMC_INT_DRTO |\n\\n\\t\\t\\t\\t\\t\\t\\t   SDMMC_INT_EBE)
(372,)
(373,state = STATE_SENDING_STOP)
(374,!err)
(375,host->completed_events)
(376,spin_unlock(&host->lock)
(377,mrq)
(378,pending_events)
(379,if (!test_and_clear_bit(EVENT_DATA_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(380,send_stop_abort(host, data)
(381,DW_MCI_RECV_STATUS)
(382,cmd)
(383,host)
(384,host->state = state)
(385,SDMMC_INT_EBE)
(386,SDMMC_INT_DRTO)
(387,if (!test_and_clear_bit(EVENT_CMD_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(388,data->stop)
(389,state = STATE_SENDING_STOP)
(390,data)
(391,cmd = host->cmd)
(392,)
(393,host->cmd = NULL)
(394,data)
(395,&host->completed_events)
(396,prev_state)
(397,case STATE_IDLE:)
(398,host)
(399,data)
(400,host)
(401,mrq->cmd->error && mrq->data)
(402,state = STATE_DATA_BUSY)
(403,STATE_DATA_ERROR)
(404,)
(405,err != -ETIMEDOUT)
(406,host->dir_status == DW_MCI_RECV_STATUS)
(407,prev_state = state = STATE_SENDING_DATA)
(408,host->dir_status)
(409,)
(410,EVENT_DATA_COMPLETE)
(411,err)
(412,dw_mci_set_drto(host)
(413,if (data->stop)
(414,state = STATE_DATA_ERROR)
(415,NULL)
(416,EVENT_XFER_COMPLETE)
(417,host->pending_events)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^